{"sha": "936615752a29ab245708d40782427c25e60a2114", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM2NjE1NzUyYTI5YWIyNDU3MDhkNDA3ODI0MjdjMjVlNjBhMjExNA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-06-27T04:21:40Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-06-27T04:21:40Z"}, "message": "libgo: add misc/cgo files\n    \n    Copy all the misc/cgo files from the gc toolchain into libgo/misc.\n    \n    These will be used for testing purposes by later changes to the\n    gotools directory.\n    \n    Reviewed-on: https://go-review.googlesource.com/46721\n\nFrom-SVN: r249674", "tree": {"sha": "f43366b59cae9e51da40272eefd1ea71bb3ea055", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f43366b59cae9e51da40272eefd1ea71bb3ea055"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/936615752a29ab245708d40782427c25e60a2114", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/936615752a29ab245708d40782427c25e60a2114", "html_url": "https://github.com/Rust-GCC/gccrs/commit/936615752a29ab245708d40782427c25e60a2114", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/936615752a29ab245708d40782427c25e60a2114/comments", "author": null, "committer": null, "parents": [{"sha": "9913ef5866a64176bac5749080487b0c7d637d4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9913ef5866a64176bac5749080487b0c7d637d4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9913ef5866a64176bac5749080487b0c7d637d4b"}], "stats": {"total": 13745, "additions": 13744, "deletions": 1}, "files": [{"sha": "583d6032e9361d7d14aca859a3f578509f44971d", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -1,4 +1,4 @@\n-bfb18fb16194826bf2bf2d7af873719ddb5e8e42\n+040dc31406d580e33f82e578a840600fea5004ef\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "bc24504e2a095e8ebb3dbd79c4165f15c7983494", "filename": "libgo/merge.sh", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmerge.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmerge.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmerge.sh?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -182,6 +182,13 @@ done\n   done\n done\n \n+(cd ${NEWDIR}/misc/cgo && find . -type f -print) | while read f; do\n+  oldfile=${OLDDIR}/misc/cgo/$f\n+  newfile=${NEWDIR}/misc/cgo/$f\n+  libgofile=misc/cgo/$f\n+  merge $f ${oldfile} ${newfile} ${libgofile}\n+done\n+\n (cd ${OLDDIR}/src && find . -name '*.go' -print) | while read f; do\n   oldfile=${OLDDIR}/src/$f\n   newfile=${NEWDIR}/src/$f\n@@ -197,5 +204,20 @@ done\n   git rm ${libgofile}\n done\n \n+(cd ${OLDDIR}/misc/cgo && find . -type f -print) | while read f; do\n+  oldfile=${OLDDIR}/misc/cgo/$f\n+  newfile=${NEWDIR}/misc/cgo/$f\n+  libgofile=misc/cgo/$f\n+  if test -f ${newfile}; then\n+    continue\n+  fi\n+  if ! test -f ${libgofile}; then\n+    continue\n+  fi\n+  echo \"merge.sh: ${libgofile}: REMOVED\"\n+  rm -f ${libgofile}\n+  git rm ${libgofile}\n+done\n+\n (echo ${new_rev}; sed -ne '2,$p' MERGE) > MERGE.tmp\n mv MERGE.tmp MERGE"}, {"sha": "61bbcd2957747188bee25b559cd71ed22416abab", "filename": "libgo/misc/cgo/errors/err1.go", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Ferr1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Ferr1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Ferr1.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+/*\n+#cgo LDFLAGS: -c\n+\n+void test() {\n+\txxx;\t\t// ERROR HERE\n+}\n+*/\n+import \"C\"\n+\n+func main() {\n+\tC.test()\n+}"}, {"sha": "3ab410bbaacb8a564bb227f98f911626f67952f4", "filename": "libgo/misc/cgo/errors/err2.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Ferr2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Ferr2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Ferr2.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"C\"\n+\n+func main() {\n+\ts := \"\"\n+\t_ = s\n+\tC.malloc(s) // ERROR HERE\n+}"}, {"sha": "609e1a0b7480c649b8db53ca278ede6efc371a6d", "filename": "libgo/misc/cgo/errors/err3.go", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Ferr3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Ferr3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Ferr3.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+/*\n+typedef struct foo foo_t;\n+typedef struct bar bar_t;\n+\n+foo_t *foop;\n+*/\n+import \"C\"\n+\n+func main() {\n+\tx := (*C.bar_t)(nil)\n+\tC.foop = x // ERROR HERE\n+}"}, {"sha": "028d10ce5cb78b42928deee427a1bf3a81f88f48", "filename": "libgo/misc/cgo/errors/issue11097a.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue11097a.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue11097a.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue11097a.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+/*\n+//enum test { foo, bar };\n+*/\n+import \"C\"\n+\n+func main() {\n+\tvar a = C.enum_test(1) // ERROR HERE\n+\t_ = a\n+}"}, {"sha": "b00f24fc103833842fc65ee0088bbee7cbd7bb78", "filename": "libgo/misc/cgo/errors/issue11097b.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue11097b.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue11097b.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue11097b.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+/*\n+//enum test { foo, bar };\n+*/\n+import \"C\"\n+\n+func main() {\n+\tp := new(C.enum_test) // ERROR HERE\n+\t_ = p\n+}"}, {"sha": "f7ad7a7e1499f393514188d7e7226d751d34232c", "filename": "libgo/misc/cgo/errors/issue13129.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue13129.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue13129.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue13129.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// issue 13129: used to output error about C.unsignedshort with CC=clang\n+\n+package main\n+\n+import \"C\"\n+\n+func main() {\n+\tvar x C.ushort\n+\tx = int(0) // ERROR HERE\n+}"}, {"sha": "fc1915723765081b42392923c661fde295e8a27c", "filename": "libgo/misc/cgo/errors/issue13423.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue13423.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue13423.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue13423.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// #include <stdio.h>\n+import \"C\"\n+\n+func main() {\n+\t_ = C.fopen() // ERROR HERE\n+}"}, {"sha": "0ce2b1e83a1940250edf61ebc539b3d6a4e09bd0", "filename": "libgo/misc/cgo/errors/issue13635.go", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue13635.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue13635.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue13635.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// issue 13635: used to output error about C.unsignedchar.\n+// This test tests all such types.\n+\n+package pkg\n+\n+import \"C\"\n+\n+func main() {\n+\tvar (\n+\t\t_ C.uchar         = \"uc\"  // ERROR HERE\n+\t\t_ C.schar         = \"sc\"  // ERROR HERE\n+\t\t_ C.ushort        = \"us\"  // ERROR HERE\n+\t\t_ C.uint          = \"ui\"  // ERROR HERE\n+\t\t_ C.ulong         = \"ul\"  // ERROR HERE\n+\t\t_ C.longlong      = \"ll\"  // ERROR HERE\n+\t\t_ C.ulonglong     = \"ull\" // ERROR HERE\n+\t\t_ C.complexfloat  = \"cf\"  // ERROR HERE\n+\t\t_ C.complexdouble = \"cd\"  // ERROR HERE\n+\t)\n+}"}, {"sha": "ac20c82b81b0d3fe3b6872188491c7139ccf768e", "filename": "libgo/misc/cgo/errors/issue13830.go", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue13830.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue13830.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue13830.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// cgo converts C void* to Go unsafe.Pointer, so despite appearances C\n+// void** is Go *unsafe.Pointer. This test verifies that we detect the\n+// problem at build time.\n+\n+package main\n+\n+// typedef void v;\n+// void F(v** p) {}\n+import \"C\"\n+\n+import \"unsafe\"\n+\n+type v [0]byte\n+\n+func f(p **v) {\n+\tC.F((**C.v)(unsafe.Pointer(p))) // ERROR HERE\n+}\n+\n+func main() {\n+\tvar p *v\n+\tf(&p)\n+}"}, {"sha": "04d2bcb631d2495963cd123e066cd380b4fd53a5", "filename": "libgo/misc/cgo/errors/issue14669.go", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue14669.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue14669.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue14669.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 14669: test that fails when build with CGO_CFLAGS selecting\n+// optimization.\n+\n+package p\n+\n+/*\n+const int E = 1;\n+\n+typedef struct s {\n+\tint       c;\n+} s;\n+*/\n+import \"C\"\n+\n+func F() {\n+\t_ = C.s{\n+\t\tc: C.E,\n+\t}\n+}"}, {"sha": "1e01cab844e99c8116bfef34e1bafc32ef791fed", "filename": "libgo/misc/cgo/errors/issue16116.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue16116.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue16116.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue16116.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// void f(void *p, int x) {}\n+import \"C\"\n+\n+func main() {\n+\t_ = C.f(1) // ERROR HERE\n+}"}, {"sha": "10eb8403cf8efa3330070f5a09c1a387b5085a16", "filename": "libgo/misc/cgo/errors/issue16591.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue16591.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue16591.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue16591.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 16591: Test that we detect an invalid call that was being\n+// hidden by a type conversion inserted by cgo checking.\n+\n+package p\n+\n+// void f(int** p) { }\n+import \"C\"\n+\n+type x *C.int\n+\n+func F(p *x) {\n+\tC.f(p) // ERROR HERE\n+}"}, {"sha": "0426e9fb7efa8b2d60c021134bf977c720a6d6a6", "filename": "libgo/misc/cgo/errors/issue7757.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue7757.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue7757.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue7757.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+/*\n+void foo() {}\n+*/\n+import \"C\"\n+\n+func main() {\n+\tC.foo = C.foo // ERROR HERE\n+}"}, {"sha": "60477ad345e1a563f211613f19d2fa1bbb4dd851", "filename": "libgo/misc/cgo/errors/issue8442.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue8442.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue8442.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Fissue8442.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// Issue 8442.  Cgo output unhelpful error messages for\n+// invalid C preambles.\n+\n+/*\n+void issue8442foo(UNDEF*); // ERROR HERE\n+*/\n+import \"C\"\n+\n+func main() {\n+\tC.issue8442foo(nil)\n+}"}, {"sha": "65da0208b9708f8115abcdc00733acff25358ddc", "filename": "libgo/misc/cgo/errors/malloc.go", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fmalloc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fmalloc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Fmalloc.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test that C.malloc does not return nil.\n+\n+package main\n+\n+// #include <stdlib.h>\n+import \"C\"\n+\n+import (\n+\t\"fmt\"\n+\t\"runtime\"\n+)\n+\n+func main() {\n+\tvar size C.size_t\n+\tsize--\n+\n+\t// The Dragonfly libc succeeds when asked to allocate\n+\t// 0xffffffffffffffff bytes, so pass a different value that\n+\t// causes it to fail.\n+\tif runtime.GOOS == \"dragonfly\" {\n+\t\tsize = C.size_t(0x7fffffff << (32 * (^uintptr(0) >> 63)))\n+\t}\n+\n+\tp := C.malloc(size)\n+\tif p == nil {\n+\t\tfmt.Println(\"malloc: C.malloc returned nil\")\n+\t\t// Just exit normally--the test script expects this\n+\t\t// program to crash, so exiting normally indicates failure.\n+\t}\n+}"}, {"sha": "4dafbdf3c011766b99a53e1e118dfce2e3f76cab", "filename": "libgo/misc/cgo/errors/ptr.go", "status": "added", "additions": 576, "deletions": 0, "changes": 576, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fptr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Fptr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Fptr.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,576 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Tests that cgo detects invalid pointer passing at runtime.\n+\n+package main\n+\n+import (\n+\t\"bufio\"\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"sync\"\n+)\n+\n+// ptrTest is the tests without the boilerplate.\n+type ptrTest struct {\n+\tname      string   // for reporting\n+\tc         string   // the cgo comment\n+\timports   []string // a list of imports\n+\tsupport   string   // supporting functions\n+\tbody      string   // the body of the main function\n+\textra     []extra  // extra files\n+\tfail      bool     // whether the test should fail\n+\texpensive bool     // whether the test requires the expensive check\n+}\n+\n+type extra struct {\n+\tname     string\n+\tcontents string\n+}\n+\n+var ptrTests = []ptrTest{\n+\t{\n+\t\t// Passing a pointer to a struct that contains a Go pointer.\n+\t\tname: \"ptr1\",\n+\t\tc:    `typedef struct s { int *p; } s; void f(s *ps) {}`,\n+\t\tbody: `C.f(&C.s{new(C.int)})`,\n+\t\tfail: true,\n+\t},\n+\t{\n+\t\t// Passing a pointer to a struct that contains a Go pointer.\n+\t\tname: \"ptr2\",\n+\t\tc:    `typedef struct s { int *p; } s; void f(s *ps) {}`,\n+\t\tbody: `p := &C.s{new(C.int)}; C.f(p)`,\n+\t\tfail: true,\n+\t},\n+\t{\n+\t\t// Passing a pointer to an int field of a Go struct\n+\t\t// that (irrelevantly) contains a Go pointer.\n+\t\tname: \"ok1\",\n+\t\tc:    `struct s { int i; int *p; }; void f(int *p) {}`,\n+\t\tbody: `p := &C.struct_s{i: 0, p: new(C.int)}; C.f(&p.i)`,\n+\t\tfail: false,\n+\t},\n+\t{\n+\t\t// Passing a pointer to a pointer field of a Go struct.\n+\t\tname: \"ptr-field\",\n+\t\tc:    `struct s { int i; int *p; }; void f(int **p) {}`,\n+\t\tbody: `p := &C.struct_s{i: 0, p: new(C.int)}; C.f(&p.p)`,\n+\t\tfail: true,\n+\t},\n+\t{\n+\t\t// Passing a pointer to a pointer field of a Go\n+\t\t// struct, where the field does not contain a Go\n+\t\t// pointer, but another field (irrelevantly) does.\n+\t\tname: \"ptr-field-ok\",\n+\t\tc:    `struct s { int *p1; int *p2; }; void f(int **p) {}`,\n+\t\tbody: `p := &C.struct_s{p1: nil, p2: new(C.int)}; C.f(&p.p1)`,\n+\t\tfail: false,\n+\t},\n+\t{\n+\t\t// Passing the address of a slice with no Go pointers.\n+\t\tname:    \"slice-ok-1\",\n+\t\tc:       `void f(void **p) {}`,\n+\t\timports: []string{\"unsafe\"},\n+\t\tbody:    `s := []unsafe.Pointer{nil}; C.f(&s[0])`,\n+\t\tfail:    false,\n+\t},\n+\t{\n+\t\t// Passing the address of a slice with a Go pointer.\n+\t\tname:    \"slice-ptr-1\",\n+\t\tc:       `void f(void **p) {}`,\n+\t\timports: []string{\"unsafe\"},\n+\t\tbody:    `i := 0; s := []unsafe.Pointer{unsafe.Pointer(&i)}; C.f(&s[0])`,\n+\t\tfail:    true,\n+\t},\n+\t{\n+\t\t// Passing the address of a slice with a Go pointer,\n+\t\t// where we are passing the address of an element that\n+\t\t// is not a Go pointer.\n+\t\tname:    \"slice-ptr-2\",\n+\t\tc:       `void f(void **p) {}`,\n+\t\timports: []string{\"unsafe\"},\n+\t\tbody:    `i := 0; s := []unsafe.Pointer{nil, unsafe.Pointer(&i)}; C.f(&s[0])`,\n+\t\tfail:    true,\n+\t},\n+\t{\n+\t\t// Passing the address of a slice that is an element\n+\t\t// in a struct only looks at the slice.\n+\t\tname:    \"slice-ok-2\",\n+\t\tc:       `void f(void **p) {}`,\n+\t\timports: []string{\"unsafe\"},\n+\t\tsupport: `type S struct { p *int; s []unsafe.Pointer }`,\n+\t\tbody:    `i := 0; p := &S{p:&i, s:[]unsafe.Pointer{nil}}; C.f(&p.s[0])`,\n+\t\tfail:    false,\n+\t},\n+\t{\n+\t\t// Passing the address of a slice of an array that is\n+\t\t// an element in a struct, with a type conversion.\n+\t\tname:    \"slice-ok-3\",\n+\t\tc:       `void f(void* p) {}`,\n+\t\timports: []string{\"unsafe\"},\n+\t\tsupport: `type S struct { p *int; a [4]byte }`,\n+\t\tbody:    `i := 0; p := &S{p:&i}; s := p.a[:]; C.f(unsafe.Pointer(&s[0]))`,\n+\t\tfail:    false,\n+\t},\n+\t{\n+\t\t// Passing the address of a slice of an array that is\n+\t\t// an element in a struct, with a type conversion.\n+\t\tname:    \"slice-ok-4\",\n+\t\tc:       `typedef void* PV; void f(PV p) {}`,\n+\t\timports: []string{\"unsafe\"},\n+\t\tsupport: `type S struct { p *int; a [4]byte }`,\n+\t\tbody:    `i := 0; p := &S{p:&i}; C.f(C.PV(unsafe.Pointer(&p.a[0])))`,\n+\t\tfail:    false,\n+\t},\n+\t{\n+\t\t// Passing the address of a static variable with no\n+\t\t// pointers doesn't matter.\n+\t\tname:    \"varok\",\n+\t\tc:       `void f(char** parg) {}`,\n+\t\tsupport: `var hello = [...]C.char{'h', 'e', 'l', 'l', 'o'}`,\n+\t\tbody:    `parg := [1]*C.char{&hello[0]}; C.f(&parg[0])`,\n+\t\tfail:    false,\n+\t},\n+\t{\n+\t\t// Passing the address of a static variable with\n+\t\t// pointers does matter.\n+\t\tname:    \"var\",\n+\t\tc:       `void f(char*** parg) {}`,\n+\t\tsupport: `var hello = [...]*C.char{new(C.char)}`,\n+\t\tbody:    `parg := [1]**C.char{&hello[0]}; C.f(&parg[0])`,\n+\t\tfail:    true,\n+\t},\n+\t{\n+\t\t// Storing a Go pointer into C memory should fail.\n+\t\tname: \"barrier\",\n+\t\tc: `#include <stdlib.h>\n+                    char **f1() { return malloc(sizeof(char*)); }\n+                    void f2(char **p) {}`,\n+\t\tbody:      `p := C.f1(); *p = new(C.char); C.f2(p)`,\n+\t\tfail:      true,\n+\t\texpensive: true,\n+\t},\n+\t{\n+\t\t// Storing a Go pointer into C memory by assigning a\n+\t\t// large value should fail.\n+\t\tname: \"barrier-struct\",\n+\t\tc: `#include <stdlib.h>\n+                    struct s { char *a[10]; };\n+                    struct s *f1() { return malloc(sizeof(struct s)); }\n+                    void f2(struct s *p) {}`,\n+\t\tbody:      `p := C.f1(); p.a = [10]*C.char{new(C.char)}; C.f2(p)`,\n+\t\tfail:      true,\n+\t\texpensive: true,\n+\t},\n+\t{\n+\t\t// Storing a Go pointer into C memory using a slice\n+\t\t// copy should fail.\n+\t\tname: \"barrier-slice\",\n+\t\tc: `#include <stdlib.h>\n+                    struct s { char *a[10]; };\n+                    struct s *f1() { return malloc(sizeof(struct s)); }\n+                    void f2(struct s *p) {}`,\n+\t\tbody:      `p := C.f1(); copy(p.a[:], []*C.char{new(C.char)}); C.f2(p)`,\n+\t\tfail:      true,\n+\t\texpensive: true,\n+\t},\n+\t{\n+\t\t// A very large value uses a GC program, which is a\n+\t\t// different code path.\n+\t\tname: \"barrier-gcprog-array\",\n+\t\tc: `#include <stdlib.h>\n+                    struct s { char *a[32769]; };\n+                    struct s *f1() { return malloc(sizeof(struct s)); }\n+                    void f2(struct s *p) {}`,\n+\t\tbody:      `p := C.f1(); p.a = [32769]*C.char{new(C.char)}; C.f2(p)`,\n+\t\tfail:      true,\n+\t\texpensive: true,\n+\t},\n+\t{\n+\t\t// Similar case, with a source on the heap.\n+\t\tname: \"barrier-gcprog-array-heap\",\n+\t\tc: `#include <stdlib.h>\n+                    struct s { char *a[32769]; };\n+                    struct s *f1() { return malloc(sizeof(struct s)); }\n+                    void f2(struct s *p) {}\n+                    void f3(void *p) {}`,\n+\t\timports:   []string{\"unsafe\"},\n+\t\tbody:      `p := C.f1(); n := &[32769]*C.char{new(C.char)}; p.a = *n; C.f2(p); n[0] = nil; C.f3(unsafe.Pointer(n))`,\n+\t\tfail:      true,\n+\t\texpensive: true,\n+\t},\n+\t{\n+\t\t// A GC program with a struct.\n+\t\tname: \"barrier-gcprog-struct\",\n+\t\tc: `#include <stdlib.h>\n+                    struct s { char *a[32769]; };\n+                    struct s2 { struct s f; };\n+                    struct s2 *f1() { return malloc(sizeof(struct s2)); }\n+                    void f2(struct s2 *p) {}`,\n+\t\tbody:      `p := C.f1(); p.f = C.struct_s{[32769]*C.char{new(C.char)}}; C.f2(p)`,\n+\t\tfail:      true,\n+\t\texpensive: true,\n+\t},\n+\t{\n+\t\t// Similar case, with a source on the heap.\n+\t\tname: \"barrier-gcprog-struct-heap\",\n+\t\tc: `#include <stdlib.h>\n+                    struct s { char *a[32769]; };\n+                    struct s2 { struct s f; };\n+                    struct s2 *f1() { return malloc(sizeof(struct s2)); }\n+                    void f2(struct s2 *p) {}\n+                    void f3(void *p) {}`,\n+\t\timports:   []string{\"unsafe\"},\n+\t\tbody:      `p := C.f1(); n := &C.struct_s{[32769]*C.char{new(C.char)}}; p.f = *n; C.f2(p); n.a[0] = nil; C.f3(unsafe.Pointer(n))`,\n+\t\tfail:      true,\n+\t\texpensive: true,\n+\t},\n+\t{\n+\t\t// Exported functions may not return Go pointers.\n+\t\tname: \"export1\",\n+\t\tc:    `extern unsigned char *GoFn();`,\n+\t\tsupport: `//export GoFn\n+                          func GoFn() *byte { return new(byte) }`,\n+\t\tbody: `C.GoFn()`,\n+\t\tfail: true,\n+\t},\n+\t{\n+\t\t// Returning a C pointer is fine.\n+\t\tname: \"exportok\",\n+\t\tc: `#include <stdlib.h>\n+                    extern unsigned char *GoFn();`,\n+\t\tsupport: `//export GoFn\n+                          func GoFn() *byte { return (*byte)(C.malloc(1)) }`,\n+\t\tbody: `C.GoFn()`,\n+\t},\n+\t{\n+\t\t// Passing a Go string is fine.\n+\t\tname: \"pass-string\",\n+\t\tc: `#include <stddef.h>\n+                    typedef struct { const char *p; ptrdiff_t n; } gostring;\n+                    gostring f(gostring s) { return s; }`,\n+\t\timports: []string{\"unsafe\"},\n+\t\tbody:    `s := \"a\"; r := C.f(*(*C.gostring)(unsafe.Pointer(&s))); if *(*string)(unsafe.Pointer(&r)) != s { panic(r) }`,\n+\t},\n+\t{\n+\t\t// Passing a slice of Go strings fails.\n+\t\tname:    \"pass-string-slice\",\n+\t\tc:       `void f(void *p) {}`,\n+\t\timports: []string{\"strings\", \"unsafe\"},\n+\t\tsupport: `type S struct { a [1]string }`,\n+\t\tbody:    `s := S{a:[1]string{strings.Repeat(\"a\", 2)}}; C.f(unsafe.Pointer(&s.a[0]))`,\n+\t\tfail:    true,\n+\t},\n+\t{\n+\t\t// Exported functions may not return strings.\n+\t\tname:    \"ret-string\",\n+\t\tc:       `extern void f();`,\n+\t\timports: []string{\"strings\"},\n+\t\tsupport: `//export GoStr\n+                          func GoStr() string { return strings.Repeat(\"a\", 2) }`,\n+\t\tbody: `C.f()`,\n+\t\textra: []extra{\n+\t\t\t{\n+\t\t\t\t\"call.c\",\n+\t\t\t\t`#include <stddef.h>\n+                                 typedef struct { const char *p; ptrdiff_t n; } gostring;\n+                                 extern gostring GoStr();\n+                                 void f() { GoStr(); }`,\n+\t\t\t},\n+\t\t},\n+\t\tfail: true,\n+\t},\n+\t{\n+\t\t// Don't check non-pointer data.\n+\t\t// Uses unsafe code to get a pointer we shouldn't check.\n+\t\t// Although we use unsafe, the uintptr represents an integer\n+\t\t// that happens to have the same representation as a pointer;\n+\t\t// that is, we are testing something that is not unsafe.\n+\t\tname: \"ptrdata1\",\n+\t\tc: `#include <stdlib.h>\n+                    void f(void* p) {}`,\n+\t\timports: []string{\"unsafe\"},\n+\t\tsupport: `type S struct { p *int; a [8*8]byte; u uintptr }`,\n+\t\tbody:    `i := 0; p := &S{u:uintptr(unsafe.Pointer(&i))}; q := (*S)(C.malloc(C.size_t(unsafe.Sizeof(*p)))); *q = *p; C.f(unsafe.Pointer(q))`,\n+\t\tfail:    false,\n+\t},\n+\t{\n+\t\t// Like ptrdata1, but with a type that uses a GC program.\n+\t\tname: \"ptrdata2\",\n+\t\tc: `#include <stdlib.h>\n+                    void f(void* p) {}`,\n+\t\timports: []string{\"unsafe\"},\n+\t\tsupport: `type S struct { p *int; a [32769*8]byte; q *int; u uintptr }`,\n+\t\tbody:    `i := 0; p := S{u:uintptr(unsafe.Pointer(&i))}; q := (*S)(C.malloc(C.size_t(unsafe.Sizeof(p)))); *q = p; C.f(unsafe.Pointer(q))`,\n+\t\tfail:    false,\n+\t},\n+\t{\n+\t\t// Check deferred pointers when they are used, not\n+\t\t// when the defer statement is run.\n+\t\tname: \"defer\",\n+\t\tc:    `typedef struct s { int *p; } s; void f(s *ps) {}`,\n+\t\tbody: `p := &C.s{}; defer C.f(p); p.p = new(C.int)`,\n+\t\tfail: true,\n+\t},\n+\t{\n+\t\t// Check a pointer to a union if the union has any\n+\t\t// pointer fields.\n+\t\tname:    \"union1\",\n+\t\tc:       `typedef union { char **p; unsigned long i; } u; void f(u *pu) {}`,\n+\t\timports: []string{\"unsafe\"},\n+\t\tbody:    `var b C.char; p := &b; C.f((*C.u)(unsafe.Pointer(&p)))`,\n+\t\tfail:    true,\n+\t},\n+\t{\n+\t\t// Don't check a pointer to a union if the union does\n+\t\t// not have any pointer fields.\n+\t\t// Like ptrdata1 above, the uintptr represents an\n+\t\t// integer that happens to have the same\n+\t\t// representation as a pointer.\n+\t\tname:    \"union2\",\n+\t\tc:       `typedef union { unsigned long i; } u; void f(u *pu) {}`,\n+\t\timports: []string{\"unsafe\"},\n+\t\tbody:    `var b C.char; p := &b; C.f((*C.u)(unsafe.Pointer(&p)))`,\n+\t\tfail:    false,\n+\t},\n+}\n+\n+func main() {\n+\tos.Exit(doTests())\n+}\n+\n+func doTests() int {\n+\tgopath, err := ioutil.TempDir(\"\", \"cgoerrors\")\n+\tif err != nil {\n+\t\tfmt.Fprintln(os.Stderr, err)\n+\t\treturn 2\n+\t}\n+\tdefer os.RemoveAll(gopath)\n+\n+\tif err := os.MkdirAll(filepath.Join(gopath, \"src\"), 0777); err != nil {\n+\t\tfmt.Fprintln(os.Stderr, err)\n+\t\treturn 2\n+\t}\n+\n+\tworkers := runtime.NumCPU() + 1\n+\n+\tvar wg sync.WaitGroup\n+\tc := make(chan int)\n+\terrs := make(chan int)\n+\tfor i := 0; i < workers; i++ {\n+\t\twg.Add(1)\n+\t\tgo func() {\n+\t\t\tworker(gopath, c, errs)\n+\t\t\twg.Done()\n+\t\t}()\n+\t}\n+\n+\tfor i := range ptrTests {\n+\t\tc <- i\n+\t}\n+\tclose(c)\n+\n+\tgo func() {\n+\t\twg.Wait()\n+\t\tclose(errs)\n+\t}()\n+\n+\ttot := 0\n+\tfor e := range errs {\n+\t\ttot += e\n+\t}\n+\treturn tot\n+}\n+\n+func worker(gopath string, c, errs chan int) {\n+\te := 0\n+\tfor i := range c {\n+\t\tif !doOne(gopath, i) {\n+\t\t\te++\n+\t\t}\n+\t}\n+\tif e > 0 {\n+\t\terrs <- e\n+\t}\n+}\n+\n+func doOne(gopath string, i int) bool {\n+\tt := &ptrTests[i]\n+\n+\tdir := filepath.Join(gopath, \"src\", fmt.Sprintf(\"dir%d\", i))\n+\tif err := os.Mkdir(dir, 0777); err != nil {\n+\t\tfmt.Fprintln(os.Stderr, err)\n+\t\treturn false\n+\t}\n+\n+\tname := filepath.Join(dir, fmt.Sprintf(\"t%d.go\", i))\n+\tf, err := os.Create(name)\n+\tif err != nil {\n+\t\tfmt.Fprintln(os.Stderr, err)\n+\t\treturn false\n+\t}\n+\n+\tb := bufio.NewWriter(f)\n+\tfmt.Fprintln(b, `package main`)\n+\tfmt.Fprintln(b)\n+\tfmt.Fprintln(b, `/*`)\n+\tfmt.Fprintln(b, t.c)\n+\tfmt.Fprintln(b, `*/`)\n+\tfmt.Fprintln(b, `import \"C\"`)\n+\tfmt.Fprintln(b)\n+\tfor _, imp := range t.imports {\n+\t\tfmt.Fprintln(b, `import \"`+imp+`\"`)\n+\t}\n+\tif len(t.imports) > 0 {\n+\t\tfmt.Fprintln(b)\n+\t}\n+\tif len(t.support) > 0 {\n+\t\tfmt.Fprintln(b, t.support)\n+\t\tfmt.Fprintln(b)\n+\t}\n+\tfmt.Fprintln(b, `func main() {`)\n+\tfmt.Fprintln(b, t.body)\n+\tfmt.Fprintln(b, `}`)\n+\n+\tif err := b.Flush(); err != nil {\n+\t\tfmt.Fprintf(os.Stderr, \"flushing %s: %v\\n\", name, err)\n+\t\treturn false\n+\t}\n+\tif err := f.Close(); err != nil {\n+\t\tfmt.Fprintf(os.Stderr, \"closing %s: %v\\n\", name, err)\n+\t\treturn false\n+\t}\n+\n+\tfor _, e := range t.extra {\n+\t\tif err := ioutil.WriteFile(filepath.Join(dir, e.name), []byte(e.contents), 0644); err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"writing %s: %v\\n\", e.name, err)\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\n+\tok := true\n+\n+\tcmd := exec.Command(\"go\", \"build\")\n+\tcmd.Dir = dir\n+\tcmd.Env = addEnv(\"GOPATH\", gopath)\n+\tbuf, err := cmd.CombinedOutput()\n+\tif err != nil {\n+\t\tfmt.Fprintf(os.Stderr, \"test %s failed to build: %v\\n%s\", t.name, err, buf)\n+\t\treturn false\n+\t}\n+\n+\texe := filepath.Join(dir, filepath.Base(dir))\n+\tcmd = exec.Command(exe)\n+\tcmd.Dir = dir\n+\n+\tif t.expensive {\n+\t\tcmd.Env = cgocheckEnv(\"1\")\n+\t\tbuf, err := cmd.CombinedOutput()\n+\t\tif err != nil {\n+\t\t\tvar errbuf bytes.Buffer\n+\t\t\tif t.fail {\n+\t\t\t\tfmt.Fprintf(&errbuf, \"test %s marked expensive but failed when not expensive: %v\\n\", t.name, err)\n+\t\t\t} else {\n+\t\t\t\tfmt.Fprintf(&errbuf, \"test %s failed unexpectedly with GODEBUG=cgocheck=1: %v\\n\", t.name, err)\n+\t\t\t}\n+\t\t\treportTestOutput(&errbuf, t.name, buf)\n+\t\t\tos.Stderr.Write(errbuf.Bytes())\n+\t\t\tok = false\n+\t\t}\n+\n+\t\tcmd = exec.Command(exe)\n+\t\tcmd.Dir = dir\n+\t}\n+\n+\tif t.expensive {\n+\t\tcmd.Env = cgocheckEnv(\"2\")\n+\t}\n+\n+\tbuf, err = cmd.CombinedOutput()\n+\n+\tif t.fail {\n+\t\tif err == nil {\n+\t\t\tvar errbuf bytes.Buffer\n+\t\t\tfmt.Fprintf(&errbuf, \"test %s did not fail as expected\\n\", t.name)\n+\t\t\treportTestOutput(&errbuf, t.name, buf)\n+\t\t\tos.Stderr.Write(errbuf.Bytes())\n+\t\t\tok = false\n+\t\t} else if !bytes.Contains(buf, []byte(\"Go pointer\")) {\n+\t\t\tvar errbuf bytes.Buffer\n+\t\t\tfmt.Fprintf(&errbuf, \"test %s output does not contain expected error (failed with %v)\\n\", t.name, err)\n+\t\t\treportTestOutput(&errbuf, t.name, buf)\n+\t\t\tos.Stderr.Write(errbuf.Bytes())\n+\t\t\tok = false\n+\t\t}\n+\t} else {\n+\t\tif err != nil {\n+\t\t\tvar errbuf bytes.Buffer\n+\t\t\tfmt.Fprintf(&errbuf, \"test %s failed unexpectedly: %v\\n\", t.name, err)\n+\t\t\treportTestOutput(&errbuf, t.name, buf)\n+\t\t\tos.Stderr.Write(errbuf.Bytes())\n+\t\t\tok = false\n+\t\t}\n+\n+\t\tif !t.expensive && ok {\n+\t\t\t// Make sure it passes with the expensive checks.\n+\t\t\tcmd := exec.Command(exe)\n+\t\t\tcmd.Dir = dir\n+\t\t\tcmd.Env = cgocheckEnv(\"2\")\n+\t\t\tbuf, err := cmd.CombinedOutput()\n+\t\t\tif err != nil {\n+\t\t\t\tvar errbuf bytes.Buffer\n+\t\t\t\tfmt.Fprintf(&errbuf, \"test %s failed unexpectedly with expensive checks: %v\\n\", t.name, err)\n+\t\t\t\treportTestOutput(&errbuf, t.name, buf)\n+\t\t\t\tos.Stderr.Write(errbuf.Bytes())\n+\t\t\t\tok = false\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif t.fail && ok {\n+\t\tcmd = exec.Command(exe)\n+\t\tcmd.Dir = dir\n+\t\tcmd.Env = cgocheckEnv(\"0\")\n+\t\tbuf, err := cmd.CombinedOutput()\n+\t\tif err != nil {\n+\t\t\tvar errbuf bytes.Buffer\n+\t\t\tfmt.Fprintf(&errbuf, \"test %s failed unexpectedly with GODEBUG=cgocheck=0: %v\\n\", t.name, err)\n+\t\t\treportTestOutput(&errbuf, t.name, buf)\n+\t\t\tos.Stderr.Write(errbuf.Bytes())\n+\t\t\tok = false\n+\t\t}\n+\t}\n+\n+\treturn ok\n+}\n+\n+func reportTestOutput(w io.Writer, name string, buf []byte) {\n+\tfmt.Fprintf(w, \"=== test %s output ===\\n\", name)\n+\tfmt.Fprintf(w, \"%s\", buf)\n+\tfmt.Fprintf(w, \"=== end of test %s output ===\\n\", name)\n+}\n+\n+func cgocheckEnv(val string) []string {\n+\treturn addEnv(\"GODEBUG\", \"cgocheck=\"+val)\n+}\n+\n+func addEnv(key, val string) []string {\n+\tenv := []string{key + \"=\" + val}\n+\tlook := key + \"=\"\n+\tfor _, e := range os.Environ() {\n+\t\tif !strings.HasPrefix(e, look) {\n+\t\t\tenv = append(env, e)\n+\t\t}\n+\t}\n+\treturn env\n+}"}, {"sha": "05261e9d767c1eb7d34165f869ee9d70b84e8c1f", "filename": "libgo/misc/cgo/errors/test.bash", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Ftest.bash", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ferrors%2Ftest.bash", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Ftest.bash?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,73 @@\n+#!/usr/bin/env bash\n+\n+# Copyright 2013 The Go Authors. All rights reserved.\n+# Use of this source code is governed by a BSD-style\n+# license that can be found in the LICENSE file.\n+\n+check() {\n+\tfile=$1\n+\tline=$(grep -n 'ERROR HERE' $file | sed 's/:.*//')\n+\tif [ \"$line\" = \"\" ]; then\n+\t\techo 1>&2 misc/cgo/errors/test.bash: BUG: cannot find ERROR HERE in $file\n+\t\texit 1\n+\tfi\n+\texpect $file $file:$line:\n+}\n+\n+expect() {\n+\tfile=$1\n+\tshift\n+\tif go build $file >errs 2>&1; then\n+\t\techo 1>&2 misc/cgo/errors/test.bash: BUG: expected cgo to fail on $file but it succeeded\n+\t\texit 1\n+\tfi\n+\tif ! test -s errs; then\n+\t\techo 1>&2 misc/cgo/errors/test.bash: BUG: expected error output for $file but saw none\n+\t\texit 1\n+\tfi\n+\tfor error; do\n+\t\tif ! fgrep $error errs >/dev/null 2>&1; then\n+\t\t\techo 1>&2 misc/cgo/errors/test.bash: BUG: expected error output for $file to contain \\\"$error\\\" but saw:\n+\t\t\tcat 1>&2 errs\n+\t\t\texit 1\n+\t\tfi\n+\tdone\n+}\n+\n+check err1.go\n+check err2.go\n+check err3.go\n+check issue7757.go\n+check issue8442.go\n+check issue11097a.go\n+check issue11097b.go\n+expect issue13129.go C.ushort\n+check issue13423.go\n+expect issue13635.go C.uchar C.schar C.ushort C.uint C.ulong C.longlong C.ulonglong C.complexfloat C.complexdouble\n+check issue13830.go\n+check issue16116.go\n+check issue16591.go\n+\n+if ! go build issue14669.go; then\n+\texit 1\n+fi\n+if ! CGO_CFLAGS=\"-O\" go build issue14669.go; then\n+\texit 1\n+fi\n+\n+if ! go run ptr.go; then\n+\texit 1\n+fi\n+\n+# The malloc.go test should crash.\n+rm -f malloc.out\n+if go run malloc.go >malloc.out 2>&1; then\n+\techo '`go run malloc.go` succeeded unexpectedly'\n+\tcat malloc.out\n+\trm -f malloc.out\n+\texit 1\n+fi\n+rm -f malloc.out\n+\n+rm -rf errs _obj\n+exit 0"}, {"sha": "b3717ee27a67cbf382215128bf4954e4d5193cc9", "filename": "libgo/misc/cgo/fortran/answer.f90", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ffortran%2Fanswer.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ffortran%2Fanswer.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ffortran%2Fanswer.f90?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,9 @@\n+! Copyright 2016 The Go Authors. All rights reserved.\n+! Use of this source code is governed by a BSD-style\n+! license that can be found in the LICENSE file.\n+\n+function the_answer() result(j) bind(C)\n+  use iso_c_binding, only: c_int\n+  integer(c_int) :: j ! output\n+  j = 42\n+end function the_answer"}, {"sha": "0079b535d94ae8be9e7d3a759dcb04393efeeddd", "filename": "libgo/misc/cgo/fortran/fortran.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ffortran%2Ffortran.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ffortran%2Ffortran.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ffortran%2Ffortran.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package fortran\n+\n+// int the_answer();\n+import \"C\"\n+\n+func TheAnswer() int {\n+\treturn int(C.the_answer())\n+}"}, {"sha": "d0cb9f22463007730abdb458084e176bc353b50f", "filename": "libgo/misc/cgo/fortran/fortran_test.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ffortran%2Ffortran_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ffortran%2Ffortran_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ffortran%2Ffortran_test.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package fortran\n+\n+import \"testing\"\n+\n+func TestFortran(t *testing.T) {\n+\tif a := TheAnswer(); a != 42 {\n+\t\tt.Errorf(\"Unexpected result for The Answer. Got: %d Want: 42\", a)\n+\t}\n+}"}, {"sha": "cbc34c16ef733ec3cfd36e0c43de7958f3204242", "filename": "libgo/misc/cgo/fortran/helloworld/helloworld.f90", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ffortran%2Fhelloworld%2Fhelloworld.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ffortran%2Fhelloworld%2Fhelloworld.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ffortran%2Fhelloworld%2Fhelloworld.f90?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,3 @@\n+      program HelloWorldF90\n+              write(*,*) \"Hello World!\"\n+      end program HelloWorldF90"}, {"sha": "3d1bc9de8e9fd03f243346abe3822237aca3ff9d", "filename": "libgo/misc/cgo/fortran/test.bash", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ffortran%2Ftest.bash", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ffortran%2Ftest.bash", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ffortran%2Ftest.bash?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,39 @@\n+#!/usr/bin/env bash\n+# Copyright 2016 The Go Authors. All rights reserved.\n+# Use of this source code is governed by a BSD-style\n+# license that can be found in the LICENSE file.\n+\n+# This directory is intended to test the use of Fortran with cgo.\n+\n+set -e\n+\n+FC=$1\n+\n+goos=$(go env GOOS)\n+\n+libext=\"so\"\n+if [ \"$goos\" == \"darwin\" ]; then\n+\tlibext=\"dylib\"\n+fi\n+\n+case \"$FC\" in\n+*gfortran*)\n+  libpath=$(dirname $($FC -print-file-name=libgfortran.$libext))\n+  export CGO_LDFLAGS=\"$CGO_LDFLAGS -Wl,-rpath,$libpath -L $libpath\"\n+  ;;\n+esac\n+\n+if ! $FC helloworld/helloworld.f90 -o main.exe >& /dev/null; then\n+  echo \"skipping Fortran test: could not build helloworld.f90 with $FC\"\n+  exit 0\n+fi\n+rm -f main.exe\n+\n+status=0\n+\n+if ! go test; then\n+  echo \"FAIL: go test\"\n+  status=1\n+fi\n+\n+exit $status"}, {"sha": "f1091b1c54f45e62187aa6a3776507a0af8e851c", "filename": "libgo/misc/cgo/gmp/fib.go", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fgmp%2Ffib.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fgmp%2Ffib.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Fgmp%2Ffib.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+// Compute Fibonacci numbers with two goroutines\n+// that pass integers back and forth.  No actual\n+// concurrency, just threads and synchronization\n+// and foreign code on multiple pthreads.\n+\n+package main\n+\n+import (\n+\tbig \".\"\n+\t\"runtime\"\n+)\n+\n+func fibber(c chan *big.Int, out chan string, n int64) {\n+\t// Keep the fibbers in dedicated operating system\n+\t// threads, so that this program tests coordination\n+\t// between pthreads and not just goroutines.\n+\truntime.LockOSThread()\n+\n+\ti := big.NewInt(n)\n+\tif n == 0 {\n+\t\tc <- i\n+\t}\n+\tfor {\n+\t\tj := <-c\n+\t\tout <- j.String()\n+\t\ti.Add(i, j)\n+\t\tc <- i\n+\t}\n+}\n+\n+func main() {\n+\tc := make(chan *big.Int)\n+\tout := make(chan string)\n+\tgo fibber(c, out, 0)\n+\tgo fibber(c, out, 1)\n+\tfor i := 0; i < 200; i++ {\n+\t\tprintln(<-out)\n+\t}\n+}"}, {"sha": "971a10aaac644a6012fe0b39571379e7f10f178d", "filename": "libgo/misc/cgo/gmp/gmp.go", "status": "added", "additions": 380, "deletions": 0, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fgmp%2Fgmp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fgmp%2Fgmp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Fgmp%2Fgmp.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,380 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+/*\n+An example of wrapping a C library in Go. This is the GNU\n+multiprecision library gmp's integer type mpz_t wrapped to look like\n+the Go package big's integer type Int.\n+\n+This is a syntactically valid Go program\u2014it can be parsed with the Go\n+parser and processed by godoc\u2014but it is not compiled directly by gc.\n+Instead, a separate tool, cgo, processes it to produce three output\n+files.  The first two, 6g.go and 6c.c, are a Go source file for 6g and\n+a C source file for 6c; both compile as part of the named package\n+(gmp, in this example).  The third, gcc.c, is a C source file for gcc;\n+it compiles into a shared object (.so) that is dynamically linked into\n+any 6.out that imports the first two files.\n+\n+The stanza\n+\n+\t// #include <gmp.h>\n+\timport \"C\"\n+\n+is a signal to cgo.  The doc comment on the import of \"C\" provides\n+additional context for the C file.  Here it is just a single #include\n+but it could contain arbitrary C definitions to be imported and used.\n+\n+Cgo recognizes any use of a qualified identifier C.xxx and uses gcc to\n+find the definition of xxx.  If xxx is a type, cgo replaces C.xxx with\n+a Go translation.  C arithmetic types translate to precisely-sized Go\n+arithmetic types.  A C struct translates to a Go struct, field by\n+field; unrepresentable fields are replaced with opaque byte arrays.  A\n+C union translates into a struct containing the first union member and\n+perhaps additional padding.  C arrays become Go arrays.  C pointers\n+become Go pointers.  C function pointers become Go's uintptr.\n+C void pointers become Go's unsafe.Pointer.\n+\n+For example, mpz_t is defined in <gmp.h> as:\n+\n+\ttypedef unsigned long int mp_limb_t;\n+\n+\ttypedef struct\n+\t{\n+\t\tint _mp_alloc;\n+\t\tint _mp_size;\n+\t\tmp_limb_t *_mp_d;\n+\t} __mpz_struct;\n+\n+\ttypedef __mpz_struct mpz_t[1];\n+\n+Cgo generates:\n+\n+\ttype _C_int int32\n+\ttype _C_mp_limb_t uint64\n+\ttype _C___mpz_struct struct {\n+\t\t_mp_alloc _C_int;\n+\t\t_mp_size _C_int;\n+\t\t_mp_d *_C_mp_limb_t;\n+\t}\n+\ttype _C_mpz_t [1]_C___mpz_struct\n+\n+and then replaces each occurrence of a type C.xxx with _C_xxx.\n+\n+If xxx is data, cgo arranges for C.xxx to refer to the C variable,\n+with the type translated as described above.  To do this, cgo must\n+introduce a Go variable that points at the C variable (the linker can\n+be told to initialize this pointer).  For example, if the gmp library\n+provided\n+\n+\tmpz_t zero;\n+\n+then cgo would rewrite a reference to C.zero by introducing\n+\n+\tvar _C_zero *C.mpz_t\n+\n+and then replacing all instances of C.zero with (*_C_zero).\n+\n+Cgo's most interesting translation is for functions.  If xxx is a C\n+function, then cgo rewrites C.xxx into a new function _C_xxx that\n+calls the C xxx in a standard pthread.  The new function translates\n+its arguments, calls xxx, and translates the return value.\n+\n+Translation of parameters and the return value follows the type\n+translation above except that arrays passed as parameters translate\n+explicitly in Go to pointers to arrays, as they do (implicitly) in C.\n+\n+Garbage collection is the big problem.  It is fine for the Go world to\n+have pointers into the C world and to free those pointers when they\n+are no longer needed.  To help, the Go code can define Go objects\n+holding the C pointers and use runtime.SetFinalizer on those Go objects.\n+\n+It is much more difficult for the C world to have pointers into the Go\n+world, because the Go garbage collector is unaware of the memory\n+allocated by C.  The most important consideration is not to\n+constrain future implementations, so the rule is that Go code can\n+hand a Go pointer to C code but must separately arrange for\n+Go to hang on to a reference to the pointer until C is done with it.\n+*/\n+package gmp\n+\n+/*\n+#cgo LDFLAGS: -lgmp\n+#include <gmp.h>\n+#include <stdlib.h>\n+\n+// gmp 5.0.0+ changed the type of the 3rd argument to mp_bitcnt_t,\n+// so, to support older versions, we wrap these two functions.\n+void _mpz_mul_2exp(mpz_ptr a, mpz_ptr b, unsigned long n) {\n+\tmpz_mul_2exp(a, b, n);\n+}\n+void _mpz_div_2exp(mpz_ptr a, mpz_ptr b, unsigned long n) {\n+\tmpz_div_2exp(a, b, n);\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"os\"\n+\t\"unsafe\"\n+)\n+\n+/*\n+ * one of a kind\n+ */\n+\n+// An Int represents a signed multi-precision integer.\n+// The zero value for an Int represents the value 0.\n+type Int struct {\n+\ti    C.mpz_t\n+\tinit bool\n+}\n+\n+// NewInt returns a new Int initialized to x.\n+func NewInt(x int64) *Int { return new(Int).SetInt64(x) }\n+\n+// Int promises that the zero value is a 0, but in gmp\n+// the zero value is a crash.  To bridge the gap, the\n+// init bool says whether this is a valid gmp value.\n+// doinit initializes z.i if it needs it.  This is not inherent\n+// to FFI, just a mismatch between Go's convention of\n+// making zero values useful and gmp's decision not to.\n+func (z *Int) doinit() {\n+\tif z.init {\n+\t\treturn\n+\t}\n+\tz.init = true\n+\tC.mpz_init(&z.i[0])\n+}\n+\n+// Bytes returns z's representation as a big-endian byte array.\n+func (z *Int) Bytes() []byte {\n+\tb := make([]byte, (z.Len()+7)/8)\n+\tn := C.size_t(len(b))\n+\tC.mpz_export(unsafe.Pointer(&b[0]), &n, 1, 1, 1, 0, &z.i[0])\n+\treturn b[0:n]\n+}\n+\n+// Len returns the length of z in bits.  0 is considered to have length 1.\n+func (z *Int) Len() int {\n+\tz.doinit()\n+\treturn int(C.mpz_sizeinbase(&z.i[0], 2))\n+}\n+\n+// Set sets z = x and returns z.\n+func (z *Int) Set(x *Int) *Int {\n+\tz.doinit()\n+\tC.mpz_set(&z.i[0], &x.i[0])\n+\treturn z\n+}\n+\n+// SetBytes interprets b as the bytes of a big-endian integer\n+// and sets z to that value.\n+func (z *Int) SetBytes(b []byte) *Int {\n+\tz.doinit()\n+\tif len(b) == 0 {\n+\t\tz.SetInt64(0)\n+\t} else {\n+\t\tC.mpz_import(&z.i[0], C.size_t(len(b)), 1, 1, 1, 0, unsafe.Pointer(&b[0]))\n+\t}\n+\treturn z\n+}\n+\n+// SetInt64 sets z = x and returns z.\n+func (z *Int) SetInt64(x int64) *Int {\n+\tz.doinit()\n+\t// TODO(rsc): more work on 32-bit platforms\n+\tC.mpz_set_si(&z.i[0], C.long(x))\n+\treturn z\n+}\n+\n+// SetString interprets s as a number in the given base\n+// and sets z to that value.  The base must be in the range [2,36].\n+// SetString returns an error if s cannot be parsed or the base is invalid.\n+func (z *Int) SetString(s string, base int) error {\n+\tz.doinit()\n+\tif base < 2 || base > 36 {\n+\t\treturn os.ErrInvalid\n+\t}\n+\tp := C.CString(s)\n+\tdefer C.free(unsafe.Pointer(p))\n+\tif C.mpz_set_str(&z.i[0], p, C.int(base)) < 0 {\n+\t\treturn os.ErrInvalid\n+\t}\n+\treturn nil\n+}\n+\n+// String returns the decimal representation of z.\n+func (z *Int) String() string {\n+\tif z == nil {\n+\t\treturn \"nil\"\n+\t}\n+\tz.doinit()\n+\tp := C.mpz_get_str(nil, 10, &z.i[0])\n+\ts := C.GoString(p)\n+\tC.free(unsafe.Pointer(p))\n+\treturn s\n+}\n+\n+func (z *Int) destroy() {\n+\tif z.init {\n+\t\tC.mpz_clear(&z.i[0])\n+\t}\n+\tz.init = false\n+}\n+\n+/*\n+ * arithmetic\n+ */\n+\n+// Add sets z = x + y and returns z.\n+func (z *Int) Add(x, y *Int) *Int {\n+\tx.doinit()\n+\ty.doinit()\n+\tz.doinit()\n+\tC.mpz_add(&z.i[0], &x.i[0], &y.i[0])\n+\treturn z\n+}\n+\n+// Sub sets z = x - y and returns z.\n+func (z *Int) Sub(x, y *Int) *Int {\n+\tx.doinit()\n+\ty.doinit()\n+\tz.doinit()\n+\tC.mpz_sub(&z.i[0], &x.i[0], &y.i[0])\n+\treturn z\n+}\n+\n+// Mul sets z = x * y and returns z.\n+func (z *Int) Mul(x, y *Int) *Int {\n+\tx.doinit()\n+\ty.doinit()\n+\tz.doinit()\n+\tC.mpz_mul(&z.i[0], &x.i[0], &y.i[0])\n+\treturn z\n+}\n+\n+// Div sets z = x / y, rounding toward zero, and returns z.\n+func (z *Int) Div(x, y *Int) *Int {\n+\tx.doinit()\n+\ty.doinit()\n+\tz.doinit()\n+\tC.mpz_tdiv_q(&z.i[0], &x.i[0], &y.i[0])\n+\treturn z\n+}\n+\n+// Mod sets z = x % y and returns z.\n+// Like the result of the Go % operator, z has the same sign as x.\n+func (z *Int) Mod(x, y *Int) *Int {\n+\tx.doinit()\n+\ty.doinit()\n+\tz.doinit()\n+\tC.mpz_tdiv_r(&z.i[0], &x.i[0], &y.i[0])\n+\treturn z\n+}\n+\n+// Lsh sets z = x << s and returns z.\n+func (z *Int) Lsh(x *Int, s uint) *Int {\n+\tx.doinit()\n+\tz.doinit()\n+\tC._mpz_mul_2exp(&z.i[0], &x.i[0], C.ulong(s))\n+\treturn z\n+}\n+\n+// Rsh sets z = x >> s and returns z.\n+func (z *Int) Rsh(x *Int, s uint) *Int {\n+\tx.doinit()\n+\tz.doinit()\n+\tC._mpz_div_2exp(&z.i[0], &x.i[0], C.ulong(s))\n+\treturn z\n+}\n+\n+// Exp sets z = x^y % m and returns z.\n+// If m == nil, Exp sets z = x^y.\n+func (z *Int) Exp(x, y, m *Int) *Int {\n+\tm.doinit()\n+\tx.doinit()\n+\ty.doinit()\n+\tz.doinit()\n+\tif m == nil {\n+\t\tC.mpz_pow_ui(&z.i[0], &x.i[0], C.mpz_get_ui(&y.i[0]))\n+\t} else {\n+\t\tC.mpz_powm(&z.i[0], &x.i[0], &y.i[0], &m.i[0])\n+\t}\n+\treturn z\n+}\n+\n+func (z *Int) Int64() int64 {\n+\tif !z.init {\n+\t\treturn 0\n+\t}\n+\treturn int64(C.mpz_get_si(&z.i[0]))\n+}\n+\n+// Neg sets z = -x and returns z.\n+func (z *Int) Neg(x *Int) *Int {\n+\tx.doinit()\n+\tz.doinit()\n+\tC.mpz_neg(&z.i[0], &x.i[0])\n+\treturn z\n+}\n+\n+// Abs sets z to the absolute value of x and returns z.\n+func (z *Int) Abs(x *Int) *Int {\n+\tx.doinit()\n+\tz.doinit()\n+\tC.mpz_abs(&z.i[0], &x.i[0])\n+\treturn z\n+}\n+\n+/*\n+ * functions without a clear receiver\n+ */\n+\n+// CmpInt compares x and y. The result is\n+//\n+//   -1 if x <  y\n+//    0 if x == y\n+//   +1 if x >  y\n+//\n+func CmpInt(x, y *Int) int {\n+\tx.doinit()\n+\ty.doinit()\n+\tswitch cmp := C.mpz_cmp(&x.i[0], &y.i[0]); {\n+\tcase cmp < 0:\n+\t\treturn -1\n+\tcase cmp == 0:\n+\t\treturn 0\n+\t}\n+\treturn +1\n+}\n+\n+// DivModInt sets q = x / y and r = x % y.\n+func DivModInt(q, r, x, y *Int) {\n+\tq.doinit()\n+\tr.doinit()\n+\tx.doinit()\n+\ty.doinit()\n+\tC.mpz_tdiv_qr(&q.i[0], &r.i[0], &x.i[0], &y.i[0])\n+}\n+\n+// GcdInt sets d to the greatest common divisor of a and b,\n+// which must be positive numbers.\n+// If x and y are not nil, GcdInt sets x and y such that d = a*x + b*y.\n+// If either a or b is not positive, GcdInt sets d = x = y = 0.\n+func GcdInt(d, x, y, a, b *Int) {\n+\td.doinit()\n+\tx.doinit()\n+\ty.doinit()\n+\ta.doinit()\n+\tb.doinit()\n+\tC.mpz_gcdext(&d.i[0], &x.i[0], &y.i[0], &a.i[0], &b.i[0])\n+}\n+\n+// ProbablyPrime performs n Miller-Rabin tests to check whether z is prime.\n+// If it returns true, z is prime with probability 1 - 1/4^n.\n+// If it returns false, z is not prime.\n+func (z *Int) ProbablyPrime(n int) bool {\n+\tz.doinit()\n+\treturn int(C.mpz_probab_prime_p(&z.i[0], C.int(n))) > 0\n+}"}, {"sha": "d5851e8e6bd389a0049d0369f960f1fc4014e090", "filename": "libgo/misc/cgo/gmp/pi.go", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fgmp%2Fpi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fgmp%2Fpi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Fgmp%2Fpi.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+package main\n+\n+import (\n+\tbig \".\"\n+\t\"fmt\"\n+\t\"runtime\"\n+)\n+\n+var (\n+\ttmp1  = big.NewInt(0)\n+\ttmp2  = big.NewInt(0)\n+\tnumer = big.NewInt(1)\n+\taccum = big.NewInt(0)\n+\tdenom = big.NewInt(1)\n+\tten   = big.NewInt(10)\n+)\n+\n+func extractDigit() int64 {\n+\tif big.CmpInt(numer, accum) > 0 {\n+\t\treturn -1\n+\t}\n+\ttmp1.Lsh(numer, 1).Add(tmp1, numer).Add(tmp1, accum)\n+\tbig.DivModInt(tmp1, tmp2, tmp1, denom)\n+\ttmp2.Add(tmp2, numer)\n+\tif big.CmpInt(tmp2, denom) >= 0 {\n+\t\treturn -1\n+\t}\n+\treturn tmp1.Int64()\n+}\n+\n+func nextTerm(k int64) {\n+\ty2 := k*2 + 1\n+\taccum.Add(accum, tmp1.Lsh(numer, 1))\n+\taccum.Mul(accum, tmp1.SetInt64(y2))\n+\tnumer.Mul(numer, tmp1.SetInt64(k))\n+\tdenom.Mul(denom, tmp1.SetInt64(y2))\n+}\n+\n+func eliminateDigit(d int64) {\n+\taccum.Sub(accum, tmp1.Mul(denom, tmp1.SetInt64(d)))\n+\taccum.Mul(accum, ten)\n+\tnumer.Mul(numer, ten)\n+}\n+\n+func main() {\n+\ti := 0\n+\tk := int64(0)\n+\tfor {\n+\t\td := int64(-1)\n+\t\tfor d < 0 {\n+\t\t\tk++\n+\t\t\tnextTerm(k)\n+\t\t\td = extractDigit()\n+\t\t}\n+\t\teliminateDigit(d)\n+\t\tfmt.Printf(\"%c\", d+'0')\n+\n+\t\tif i++; i%50 == 0 {\n+\t\t\tfmt.Printf(\"\\n\")\n+\t\t\tif i >= 1000 {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tfmt.Printf(\"\\n%d calls; bit sizes: %d %d %d\\n\", runtime.NumCgoCall(), numer.Len(), accum.Len(), denom.Len())\n+}"}, {"sha": "f853163e2f0c1ebdc067e166fc2ee2f420149a4b", "filename": "libgo/misc/cgo/life/c-life.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Flife%2Fc-life.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Flife%2Fc-life.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Flife%2Fc-life.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include <assert.h>\n+#include \"life.h\"\n+#include \"_cgo_export.h\"\n+\n+const int MYCONST = 0;\n+\n+// Do the actual manipulation of the life board in C.  This could be\n+// done easily in Go, we are just using C for demonstration\n+// purposes.\n+void\n+Step(int x, int y, int *a, int *n)\n+{\n+\tstruct GoStart_return r;\n+\n+\t// Use Go to start 4 goroutines each of which handles 1/4 of the\n+\t// board.\n+\tr = GoStart(0, x, y, 0, x / 2, 0, y / 2, a, n);\n+\tassert(r.r0 == 0 && r.r1 == 100);\t// test multiple returns\n+\tr = GoStart(1, x, y, x / 2, x, 0, y / 2, a, n);\n+\tassert(r.r0 == 1 && r.r1 == 101);\t// test multiple returns\n+\tGoStart(2, x, y, 0, x / 2, y / 2, y, a, n);\n+\tGoStart(3, x, y, x / 2, x, y / 2, y, a, n);\n+\tGoWait(0);\n+\tGoWait(1);\n+\tGoWait(2);\n+\tGoWait(3);\n+}\n+\n+// The actual computation.  This is called in parallel.\n+void\n+DoStep(int xdim, int ydim, int xstart, int xend, int ystart, int yend, int *a, int *n)\n+{\n+\tint x, y, c, i, j;\n+\n+\tfor(x = xstart; x < xend; x++) {\n+\t\tfor(y = ystart; y < yend; y++) {\n+\t\t\tc = 0;\n+\t\t\tfor(i = -1; i <= 1; i++) {\n+\t\t\t\tfor(j = -1; j <= 1; j++) {\n+\t\t\t\t  if(x+i >= 0 && x+i < xdim &&\n+\t\t\t\t\ty+j >= 0 && y+j < ydim &&\n+\t\t\t\t\t(i != 0 || j != 0))\n+\t\t\t\t    c += a[(x+i)*xdim + (y+j)] != 0;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif(c == 3 || (c == 2 && a[x*xdim + y] != 0))\n+\t\t\t\tn[x*xdim + y] = 1;\n+\t\t\telse\n+\t\t\t\tn[x*xdim + y] = 0;\n+\t\t}\n+\t}\n+}"}, {"sha": "170a620c8788eed7e804741b21af7aa6454f4bd6", "filename": "libgo/misc/cgo/life/life.go", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Flife%2Flife.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Flife%2Flife.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Flife%2Flife.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,41 @@\n+// skip\n+\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package life\n+\n+// #include \"life.h\"\n+import \"C\"\n+\n+import \"unsafe\"\n+\n+func Run(gen, x, y int, a []int32) {\n+\tn := make([]int32, x*y)\n+\tfor i := 0; i < gen; i++ {\n+\t\tC.Step(C.int(x), C.int(y), (*C.int)(unsafe.Pointer(&a[0])), (*C.int)(unsafe.Pointer(&n[0])))\n+\t\tcopy(a, n)\n+\t}\n+}\n+\n+// Keep the channels visible from Go.\n+var chans [4]chan bool\n+\n+//export GoStart\n+// Double return value is just for testing.\n+func GoStart(i, xdim, ydim, xstart, xend, ystart, yend C.int, a *C.int, n *C.int) (int, int) {\n+\tc := make(chan bool, int(C.MYCONST))\n+\tgo func() {\n+\t\tC.DoStep(xdim, ydim, xstart, xend, ystart, yend, a, n)\n+\t\tc <- true\n+\t}()\n+\tchans[i] = c\n+\treturn int(i), int(i + 100)\n+}\n+\n+//export GoWait\n+func GoWait(i C.int) {\n+\t<-chans[i]\n+\tchans[i] = nil\n+}"}, {"sha": "11d2b97226767bb0d4c86ad0dc7a8f991389e54a", "filename": "libgo/misc/cgo/life/life.h", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Flife%2Flife.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Flife%2Flife.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Flife%2Flife.h?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,7 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+extern void Step(int, int, int *, int *);\n+extern void DoStep(int, int, int, int, int, int, int *, int *);\n+extern const int MYCONST;"}, {"sha": "aa2f6d116b392b6150d3a2a94736e55d48c71184", "filename": "libgo/misc/cgo/life/main.go", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Flife%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Flife%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Flife%2Fmain.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,48 @@\n+// cmpout\n+\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build test_run\n+\n+// Run the game of life in C using Go for parallelization.\n+\n+package main\n+\n+import (\n+\t\".\"\n+\t\"flag\"\n+\t\"fmt\"\n+)\n+\n+const MAXDIM = 100\n+\n+var dim = flag.Int(\"dim\", 16, \"board dimensions\")\n+var gen = flag.Int(\"gen\", 10, \"generations\")\n+\n+func main() {\n+\tflag.Parse()\n+\n+\tvar a [MAXDIM * MAXDIM]int32\n+\tfor i := 2; i < *dim; i += 8 {\n+\t\tfor j := 2; j < *dim-3; j += 8 {\n+\t\t\tfor y := 0; y < 3; y++ {\n+\t\t\t\ta[i**dim+j+y] = 1\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tlife.Run(*gen, *dim, *dim, a[:])\n+\n+\tfor i := 0; i < *dim; i++ {\n+\t\tfor j := 0; j < *dim; j++ {\n+\t\t\tif a[i**dim+j] == 0 {\n+\t\t\t\tfmt.Print(\" \")\n+\t\t\t} else {\n+\t\t\t\tfmt.Print(\"X\")\n+\t\t\t}\n+\t\t}\n+\t\tfmt.Print(\"\\n\")\n+\t}\n+}"}, {"sha": "26fc9c6e3ff6d126734a1608560c8efccb95cc1f", "filename": "libgo/misc/cgo/life/main.out", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Flife%2Fmain.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Flife%2Fmain.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Flife%2Fmain.out?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,16 @@\n+                \n+                \n+  XXX     XXX   \n+                \n+                \n+                \n+                \n+                \n+                \n+                \n+  XXX     XXX   \n+                \n+                \n+                \n+                \n+                "}, {"sha": "00ae5e9c86282e2e370265d889203f634316313c", "filename": "libgo/misc/cgo/nocgo/nocgo.go", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fnocgo%2Fnocgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fnocgo%2Fnocgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Fnocgo%2Fnocgo.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test that -static works when not using cgo.  This test is in\n+// misc/cgo to take advantage of the testing framework support for\n+// when -static is expected to work.\n+\n+package nocgo\n+\n+func NoCgo() int {\n+\tc := make(chan int)\n+\n+\t// The test is run with external linking, which means that\n+\t// goroutines will be created via the runtime/cgo package.\n+\t// Make sure that works.\n+\tgo func() {\n+\t\tc <- 42\n+\t}()\n+\n+\treturn <-c\n+}"}, {"sha": "45d247cf9545a644e54b09735779a33c62397850", "filename": "libgo/misc/cgo/nocgo/nocgo_test.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fnocgo%2Fnocgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fnocgo%2Fnocgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Fnocgo%2Fnocgo_test.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package nocgo\n+\n+import \"testing\"\n+\n+func TestNop(t *testing.T) {\n+\ti := NoCgo()\n+\tif i != 42 {\n+\t\tt.Errorf(\"got %d, want %d\", i, 42)\n+\t}\n+}"}, {"sha": "03cddb76888e2faabe0ee65032ec45bfedf2d5a7", "filename": "libgo/misc/cgo/stdio/chain.go", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fstdio%2Fchain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fstdio%2Fchain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Fstdio%2Fchain.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,48 @@\n+// cmpout\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build test_run\n+\n+// Pass numbers along a chain of threads.\n+\n+package main\n+\n+import (\n+\t\"runtime\"\n+\t\"strconv\"\n+\n+\t\"../stdio\"\n+)\n+\n+const N = 10\n+const R = 5\n+\n+func link(left chan<- int, right <-chan int) {\n+\t// Keep the links in dedicated operating system\n+\t// threads, so that this program tests coordination\n+\t// between pthreads and not just goroutines.\n+\truntime.LockOSThread()\n+\tfor {\n+\t\tv := <-right\n+\t\tstdio.Stdout.WriteString(strconv.Itoa(v) + \"\\n\")\n+\t\tleft <- 1 + v\n+\t}\n+}\n+\n+func main() {\n+\tleftmost := make(chan int)\n+\tvar left chan int\n+\tright := leftmost\n+\tfor i := 0; i < N; i++ {\n+\t\tleft, right = right, make(chan int)\n+\t\tgo link(left, right)\n+\t}\n+\tfor i := 0; i < R; i++ {\n+\t\tright <- 0\n+\t\tx := <-leftmost\n+\t\tstdio.Stdout.WriteString(strconv.Itoa(x) + \"\\n\")\n+\t}\n+}"}, {"sha": "963cf9b6679b180a5f6423d847cbd8104bcd7a8c", "filename": "libgo/misc/cgo/stdio/chain.out", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fstdio%2Fchain.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fstdio%2Fchain.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Fstdio%2Fchain.out?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,55 @@\n+0\n+1\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+9\n+10\n+0\n+1\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+9\n+10\n+0\n+1\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+9\n+10\n+0\n+1\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+9\n+10\n+0\n+1\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+9\n+10"}, {"sha": "61a1b83728c1528c08c457477d2b724276471575", "filename": "libgo/misc/cgo/stdio/fib.go", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fstdio%2Ffib.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fstdio%2Ffib.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Fstdio%2Ffib.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,52 @@\n+// cmpout\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build test_run\n+\n+// Compute Fibonacci numbers with two goroutines\n+// that pass integers back and forth.  No actual\n+// concurrency, just threads and synchronization\n+// and foreign code on multiple pthreads.\n+\n+package main\n+\n+import (\n+\t\"runtime\"\n+\t\"strconv\"\n+\n+\t\"../stdio\"\n+)\n+\n+func fibber(c, out chan int64, i int64) {\n+\t// Keep the fibbers in dedicated operating system\n+\t// threads, so that this program tests coordination\n+\t// between pthreads and not just goroutines.\n+\truntime.LockOSThread()\n+\n+\tif i == 0 {\n+\t\tc <- i\n+\t}\n+\tfor {\n+\t\tj := <-c\n+\t\tstdio.Stdout.WriteString(strconv.FormatInt(j, 10) + \"\\n\")\n+\t\tout <- j\n+\t\t<-out\n+\t\ti += j\n+\t\tc <- i\n+\t}\n+}\n+\n+func main() {\n+\tc := make(chan int64)\n+\tout := make(chan int64)\n+\tgo fibber(c, out, 0)\n+\tgo fibber(c, out, 1)\n+\t<-out\n+\tfor i := 0; i < 90; i++ {\n+\t\tout <- 1\n+\t\t<-out\n+\t}\n+}"}, {"sha": "17ff503356d8e40e12ed97ed51b5675299d4879c", "filename": "libgo/misc/cgo/stdio/fib.out", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fstdio%2Ffib.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fstdio%2Ffib.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Fstdio%2Ffib.out?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,91 @@\n+0\n+1\n+1\n+2\n+3\n+5\n+8\n+13\n+21\n+34\n+55\n+89\n+144\n+233\n+377\n+610\n+987\n+1597\n+2584\n+4181\n+6765\n+10946\n+17711\n+28657\n+46368\n+75025\n+121393\n+196418\n+317811\n+514229\n+832040\n+1346269\n+2178309\n+3524578\n+5702887\n+9227465\n+14930352\n+24157817\n+39088169\n+63245986\n+102334155\n+165580141\n+267914296\n+433494437\n+701408733\n+1134903170\n+1836311903\n+2971215073\n+4807526976\n+7778742049\n+12586269025\n+20365011074\n+32951280099\n+53316291173\n+86267571272\n+139583862445\n+225851433717\n+365435296162\n+591286729879\n+956722026041\n+1548008755920\n+2504730781961\n+4052739537881\n+6557470319842\n+10610209857723\n+17167680177565\n+27777890035288\n+44945570212853\n+72723460248141\n+117669030460994\n+190392490709135\n+308061521170129\n+498454011879264\n+806515533049393\n+1304969544928657\n+2111485077978050\n+3416454622906707\n+5527939700884757\n+8944394323791464\n+14472334024676221\n+23416728348467685\n+37889062373143906\n+61305790721611591\n+99194853094755497\n+160500643816367088\n+259695496911122585\n+420196140727489673\n+679891637638612258\n+1100087778366101931\n+1779979416004714189\n+2880067194370816120"}, {"sha": "a024f2c361c8be4b87ab99d89b8b33b1e490e516", "filename": "libgo/misc/cgo/stdio/file.go", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fstdio%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fstdio%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Fstdio%2Ffile.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,44 @@\n+// skip\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+/*\n+A trivial example of wrapping a C library in Go.\n+For a more complex example and explanation,\n+see ../gmp/gmp.go.\n+*/\n+\n+package stdio\n+\n+/*\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <sys/stat.h>\n+#include <errno.h>\n+\n+char* greeting = \"hello, world\";\n+*/\n+import \"C\"\n+import \"unsafe\"\n+\n+type File C.FILE\n+\n+// Test reference to library symbol.\n+// Stdout and stderr are too special to be a reliable test.\n+//var  = C.environ\n+\n+func (f *File) WriteString(s string) {\n+\tp := C.CString(s)\n+\tC.fputs(p, (*C.FILE)(f))\n+\tC.free(unsafe.Pointer(p))\n+\tf.Flush()\n+}\n+\n+func (f *File) Flush() {\n+\tC.fflush((*C.FILE)(f))\n+}\n+\n+var Greeting = C.GoString(C.greeting)\n+var Gbytes = C.GoBytes(unsafe.Pointer(C.greeting), C.int(len(Greeting)))"}, {"sha": "47179ba48278684b45eaff9503728da1be4c2fdf", "filename": "libgo/misc/cgo/stdio/hello.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fstdio%2Fhello.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fstdio%2Fhello.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Fstdio%2Fhello.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,15 @@\n+// cmpout\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build test_run\n+\n+package main\n+\n+import \"../stdio\"\n+\n+func main() {\n+\tstdio.Stdout.WriteString(stdio.Greeting + \"\\n\")\n+}"}, {"sha": "4b5fa63702dd96796042e92787f464e28f09f17d", "filename": "libgo/misc/cgo/stdio/hello.out", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fstdio%2Fhello.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fstdio%2Fhello.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Fstdio%2Fhello.out?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1 @@\n+hello, world"}, {"sha": "c0e496547ed8b59f67b049e95bbdfd5b81544d9e", "filename": "libgo/misc/cgo/stdio/run.out", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fstdio%2Frun.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fstdio%2Frun.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Fstdio%2Frun.out?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,150 @@\n+* hello\n+hello, world\n+* fib\n+0\n+1\n+1\n+2\n+3\n+5\n+8\n+13\n+21\n+34\n+55\n+89\n+144\n+233\n+377\n+610\n+987\n+1597\n+2584\n+4181\n+6765\n+10946\n+17711\n+28657\n+46368\n+75025\n+121393\n+196418\n+317811\n+514229\n+832040\n+1346269\n+2178309\n+3524578\n+5702887\n+9227465\n+14930352\n+24157817\n+39088169\n+63245986\n+102334155\n+165580141\n+267914296\n+433494437\n+701408733\n+1134903170\n+1836311903\n+2971215073\n+4807526976\n+7778742049\n+12586269025\n+20365011074\n+32951280099\n+53316291173\n+86267571272\n+139583862445\n+225851433717\n+365435296162\n+591286729879\n+956722026041\n+1548008755920\n+2504730781961\n+4052739537881\n+6557470319842\n+10610209857723\n+17167680177565\n+27777890035288\n+44945570212853\n+72723460248141\n+117669030460994\n+190392490709135\n+308061521170129\n+498454011879264\n+806515533049393\n+1304969544928657\n+2111485077978050\n+3416454622906707\n+5527939700884757\n+8944394323791464\n+14472334024676221\n+23416728348467685\n+37889062373143906\n+61305790721611591\n+99194853094755497\n+160500643816367088\n+259695496911122585\n+420196140727489673\n+679891637638612258\n+1100087778366101931\n+1779979416004714189\n+2880067194370816120\n+* chain\n+0\n+1\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+9\n+10\n+0\n+1\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+9\n+10\n+0\n+1\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+9\n+10\n+0\n+1\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+9\n+10\n+0\n+1\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+9\n+10"}, {"sha": "d216e44fe7ce3a817c2e1801f8c4bc37a3702eb3", "filename": "libgo/misc/cgo/stdio/stdio.go", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fstdio%2Fstdio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Fstdio%2Fstdio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Fstdio%2Fstdio.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,22 @@\n+// skip\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package stdio\n+\n+/*\n+#include <stdio.h>\n+\n+// on mingw, stderr and stdout are defined as &_iob[FILENO]\n+// on netbsd, they are defined as &__sF[FILENO]\n+// and cgo doesn't recognize them, so write a function to get them,\n+// instead of depending on internals of libc implementation.\n+FILE *getStdout(void) { return stdout; }\n+FILE *getStderr(void) { return stderr; }\n+*/\n+import \"C\"\n+\n+var Stdout = (*File)(C.getStdout())\n+var Stderr = (*File)(C.getStderr())"}, {"sha": "a23b44fc38c83bf872944c71dc55cc0558ef1ae5", "filename": "libgo/misc/cgo/test/align.go", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Falign.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Falign.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Falign.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,76 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+/*\n+#include <stdio.h>\n+\n+typedef unsigned char Uint8;\n+typedef unsigned short Uint16;\n+\n+typedef enum {\n+ MOD1 = 0x0000,\n+ MODX = 0x8000\n+} SDLMod;\n+\n+typedef enum {\n+ A = 1,\n+ B = 322,\n+ SDLK_LAST\n+} SDLKey;\n+\n+typedef struct SDL_keysym {\n+\tUint8 scancode;\n+\tSDLKey sym;\n+\tSDLMod mod;\n+\tUint16 unicode;\n+} SDL_keysym;\n+\n+typedef struct SDL_KeyboardEvent {\n+\tUint8 typ;\n+\tUint8 which;\n+\tUint8 state;\n+\tSDL_keysym keysym;\n+} SDL_KeyboardEvent;\n+\n+void makeEvent(SDL_KeyboardEvent *event) {\n+ unsigned char *p;\n+ int i;\n+\n+ p = (unsigned char*)event;\n+ for (i=0; i<sizeof *event; i++) {\n+   p[i] = i;\n+ }\n+}\n+\n+int same(SDL_KeyboardEvent* e, Uint8 typ, Uint8 which, Uint8 state, Uint8 scan, SDLKey sym, SDLMod mod, Uint16 uni) {\n+  return e->typ == typ && e->which == which && e->state == state && e->keysym.scancode == scan && e->keysym.sym == sym && e->keysym.mod == mod && e->keysym.unicode == uni;\n+}\n+\n+void cTest(SDL_KeyboardEvent *event) {\n+ printf(\"C: %#x %#x %#x %#x %#x %#x %#x\\n\", event->typ, event->which, event->state,\n+   event->keysym.scancode, event->keysym.sym, event->keysym.mod, event->keysym.unicode);\n+ fflush(stdout);\n+}\n+\n+*/\n+import \"C\"\n+\n+import (\n+\t\"testing\"\n+)\n+\n+func testAlign(t *testing.T) {\n+\tvar evt C.SDL_KeyboardEvent\n+\tC.makeEvent(&evt)\n+\tif C.same(&evt, evt.typ, evt.which, evt.state, evt.keysym.scancode, evt.keysym.sym, evt.keysym.mod, evt.keysym.unicode) == 0 {\n+\t\tt.Error(\"*** bad alignment\")\n+\t\tC.cTest(&evt)\n+\t\tt.Errorf(\"Go: %#x %#x %#x %#x %#x %#x %#x\\n\",\n+\t\t\tevt.typ, evt.which, evt.state, evt.keysym.scancode,\n+\t\t\tevt.keysym.sym, evt.keysym.mod, evt.keysym.unicode)\n+\t\tt.Error(evt)\n+\t}\n+}"}, {"sha": "d2b09cbeffedbc8fc46a89aabd38aeaa7f9d583b", "filename": "libgo/misc/cgo/test/api.go", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fapi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fapi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fapi.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// API Compatibility Checks for cgo\n+\n+package cgotest\n+\n+// #include <stdlib.h>\n+//\n+// // Test for issue 17723.\n+// typedef char *cstring_pointer;\n+// static void cstring_pointer_fun(cstring_pointer dummy) { }\n+//\n+// const char *api_hello = \"hello!\";\n+import \"C\"\n+import \"unsafe\"\n+\n+func testAPI() {\n+\tvar cs *C.char\n+\tcs = C.CString(\"hello\")\n+\tdefer C.free(unsafe.Pointer(cs))\n+\tvar s string\n+\ts = C.GoString((*C.char)(C.api_hello))\n+\ts = C.GoStringN((*C.char)(C.api_hello), C.int(6))\n+\tvar b []byte\n+\tb = C.GoBytes(unsafe.Pointer(C.api_hello), C.int(6))\n+\t_, _ = s, b\n+\tC.cstring_pointer_fun(nil)\n+}"}, {"sha": "6fb33d66cb2cf43f72acff28e46bfbb343a25b67", "filename": "libgo/misc/cgo/test/backdoor.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fbackdoor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fbackdoor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fbackdoor.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+import _ \"unsafe\"\n+\n+//go:linkname lockedOSThread runtime.lockedOSThread\n+//extern runtime_lockedOSThread\n+func lockedOSThread() bool"}, {"sha": "3ceb4ce8470d4dac938c5741dcc19932db6616d4", "filename": "libgo/misc/cgo/test/basic.go", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fbasic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fbasic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fbasic.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,167 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Basic test cases for cgo.\n+\n+package cgotest\n+\n+/*\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <sys/stat.h>\n+#include <errno.h>\n+\n+#define SHIFT(x, y)  ((x)<<(y))\n+#define KILO SHIFT(1, 10)\n+#define UINT32VAL 0xc008427bU\n+\n+enum E {\n+\tEnum1 = 1,\n+\tEnum2 = 2,\n+};\n+\n+typedef unsigned char cgo_uuid_t[20];\n+\n+void uuid_generate(cgo_uuid_t x) {\n+\tx[0] = 0;\n+}\n+\n+struct S {\n+\tint x;\n+};\n+\n+extern enum E myConstFunc(struct S* const ctx, int const id, struct S **const filter);\n+\n+enum E myConstFunc(struct S *const ctx, int const id, struct S **const filter) { return 0; }\n+\n+// issue 1222\n+typedef union {\n+\tlong align;\n+} xxpthread_mutex_t;\n+\n+struct ibv_async_event {\n+\tunion {\n+\t\tint x;\n+\t} element;\n+};\n+\n+struct ibv_context {\n+\txxpthread_mutex_t mutex;\n+};\n+\n+int add(int x, int y) {\n+\treturn x+y;\n+};\n+*/\n+import \"C\"\n+import (\n+\t\"runtime\"\n+\t\"syscall\"\n+\t\"testing\"\n+\t\"unsafe\"\n+)\n+\n+const EINVAL = C.EINVAL /* test #define */\n+\n+var KILO = C.KILO\n+\n+func uuidgen() {\n+\tvar uuid C.cgo_uuid_t\n+\tC.uuid_generate(&uuid[0])\n+}\n+\n+func Strtol(s string, base int) (int, error) {\n+\tp := C.CString(s)\n+\tn, err := C.strtol(p, nil, C.int(base))\n+\tC.free(unsafe.Pointer(p))\n+\treturn int(n), err\n+}\n+\n+func Atol(s string) int {\n+\tp := C.CString(s)\n+\tn := C.atol(p)\n+\tC.free(unsafe.Pointer(p))\n+\treturn int(n)\n+}\n+\n+func testConst(t *testing.T) {\n+\tC.myConstFunc(nil, 0, nil)\n+}\n+\n+func testEnum(t *testing.T) {\n+\tif C.Enum1 != 1 || C.Enum2 != 2 {\n+\t\tt.Error(\"bad enum\", C.Enum1, C.Enum2)\n+\t}\n+}\n+\n+func testAtol(t *testing.T) {\n+\tl := Atol(\"123\")\n+\tif l != 123 {\n+\t\tt.Error(\"Atol 123: \", l)\n+\t}\n+}\n+\n+func testErrno(t *testing.T) {\n+\tp := C.CString(\"no-such-file\")\n+\tm := C.CString(\"r\")\n+\tf, err := C.fopen(p, m)\n+\tC.free(unsafe.Pointer(p))\n+\tC.free(unsafe.Pointer(m))\n+\tif err == nil {\n+\t\tC.fclose(f)\n+\t\tt.Fatalf(\"C.fopen: should fail\")\n+\t}\n+\tif err != syscall.ENOENT {\n+\t\tt.Fatalf(\"C.fopen: unexpected error: %v\", err)\n+\t}\n+}\n+\n+func testMultipleAssign(t *testing.T) {\n+\tp := C.CString(\"234\")\n+\tn, m := C.strtol(p, nil, 345), C.strtol(p, nil, 10)\n+\tif runtime.GOOS == \"openbsd\" {\n+\t\t// Bug in OpenBSD strtol(3) - base > 36 succeeds.\n+\t\tif (n != 0 && n != 239089) || m != 234 {\n+\t\t\tt.Fatal(\"Strtol x2: \", n, m)\n+\t\t}\n+\t} else if n != 0 || m != 234 {\n+\t\tt.Fatal(\"Strtol x2: \", n, m)\n+\t}\n+\tC.free(unsafe.Pointer(p))\n+}\n+\n+var (\n+\tcuint  = (C.uint)(0)\n+\tculong C.ulong\n+\tcchar  C.char\n+)\n+\n+type Context struct {\n+\tctx *C.struct_ibv_context\n+}\n+\n+func benchCgoCall(b *testing.B) {\n+\tconst x = C.int(2)\n+\tconst y = C.int(3)\n+\tfor i := 0; i < b.N; i++ {\n+\t\tC.add(x, y)\n+\t}\n+}\n+\n+// Issue 2470.\n+func testUnsignedInt(t *testing.T) {\n+\ta := (int64)(C.UINT32VAL)\n+\tb := (int64)(0xc008427b)\n+\tif a != b {\n+\t\tt.Errorf(\"Incorrect unsigned int - got %x, want %x\", a, b)\n+\t}\n+}\n+\n+// Static (build-time) test that syntax traversal visits all operands of s[i:j:k].\n+func sliceOperands(array [2000]int) {\n+\t_ = array[C.KILO:C.KILO:C.KILO] // no type error\n+}\n+\n+// set in cgo_thread_lock.go init\n+var testThreadLockFunc = func(*testing.T) {}"}, {"sha": "47dd87128fffb4d0b052a17314334852544585ae", "filename": "libgo/misc/cgo/test/buildid_linux.go", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fbuildid_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fbuildid_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fbuildid_linux.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+// Test that we have no more than one build ID.  In the past we used\n+// to generate a separate build ID for each package using cgo, and the\n+// linker concatenated them all.  We don't want that--we only want\n+// one.\n+\n+import (\n+\t\"bytes\"\n+\t\"debug/elf\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+func testBuildID(t *testing.T) {\n+\tf, err := elf.Open(\"/proc/self/exe\")\n+\tif err != nil {\n+\t\tif os.IsNotExist(err) {\n+\t\t\tt.Skip(\"no /proc/self/exe\")\n+\t\t}\n+\t\tt.Fatal(\"opening /proc/self/exe: \", err)\n+\t}\n+\tdefer f.Close()\n+\n+\tc := 0\n+\tfor i, s := range f.Sections {\n+\t\tif s.Type != elf.SHT_NOTE {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\td, err := s.Data()\n+\t\tif err != nil {\n+\t\t\tt.Logf(\"reading data of note section %d: %v\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tfor len(d) > 0 {\n+\n+\t\t\t// ELF standards differ as to the sizes in\n+\t\t\t// note sections.  Both the GNU linker and\n+\t\t\t// gold always generate 32-bit sizes, so that\n+\t\t\t// is what we assume here.\n+\n+\t\t\tif len(d) < 12 {\n+\t\t\t\tt.Logf(\"note section %d too short (%d < 12)\", i, len(d))\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tnamesz := f.ByteOrder.Uint32(d)\n+\t\t\tdescsz := f.ByteOrder.Uint32(d[4:])\n+\t\t\ttyp := f.ByteOrder.Uint32(d[8:])\n+\n+\t\t\tan := (namesz + 3) &^ 3\n+\t\t\tad := (descsz + 3) &^ 3\n+\n+\t\t\tif int(12+an+ad) > len(d) {\n+\t\t\t\tt.Logf(\"note section %d too short for header (%d < 12 + align(%d,4) + align(%d,4))\", i, len(d), namesz, descsz)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\t// 3 == NT_GNU_BUILD_ID\n+\t\t\tif typ == 3 && namesz == 4 && bytes.Equal(d[12:16], []byte(\"GNU\\000\")) {\n+\t\t\t\tc++\n+\t\t\t}\n+\n+\t\t\td = d[12+an+ad:]\n+\t\t}\n+\t}\n+\n+\tif c > 1 {\n+\t\tt.Errorf(\"found %d build ID notes\", c)\n+\t}\n+}"}, {"sha": "b88bf134bc1e40a73109259155da0904f47621a8", "filename": "libgo/misc/cgo/test/callback.go", "status": "added", "additions": 1782, "deletions": 0, "changes": 1782, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcallback.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcallback.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fcallback.go?ref=936615752a29ab245708d40782427c25e60a2114"}, {"sha": "8921b7306c6b148f13611ecaca6da4b47dcbfb98", "filename": "libgo/misc/cgo/test/callback_c.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcallback_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcallback_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fcallback_c.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,90 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include <string.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n+#include \"_cgo_export.h\"\n+\n+void\n+callback(void *f)\n+{\n+\t// use some stack space\n+\tvolatile char data[64*1024];\n+\n+\tdata[0] = 0;\n+\tgoCallback(f);\n+        data[sizeof(data)-1] = 0;\n+}\n+\n+void\n+callGoFoo(void)\n+{\n+\textern void goFoo(void);\n+\tgoFoo();\n+}\n+\n+void\n+IntoC(void)\n+{\n+\tBackIntoGo();\n+}\n+\n+#ifdef WIN32\n+#include <windows.h>\n+long long\n+mysleep(int seconds) {\n+\tlong long st = GetTickCount();\n+\tSleep(1000 * seconds);\n+\treturn st;\n+}\n+#else\n+#include <sys/time.h>\n+long long\n+mysleep(int seconds) {\n+\tlong long st;\n+\tstruct timeval tv;\n+\tgettimeofday(&tv, NULL);\n+\tst = tv.tv_sec * 1000 + tv.tv_usec / 1000;\n+\tsleep(seconds);\n+\treturn st;\n+}\n+#endif\n+\n+long long\n+twoSleep(int n)\n+{\n+\tBackgroundSleep(n);\n+\treturn mysleep(n);\n+}\n+\n+void\n+callGoStackCheck(void)\n+{\n+\textern void goStackCheck(void);\n+\tgoStackCheck();\n+}\n+\n+int\n+returnAfterGrow(void)\n+{\n+\textern int goReturnVal(void);\n+\tgoReturnVal();\n+\treturn 123456;\n+}\n+\n+int\n+returnAfterGrowFromGo(void)\n+{\n+\textern int goReturnVal(void);\n+\treturn goReturnVal();\n+}\n+\n+void\n+callGoWithString(void)\n+{\n+\textern void goWithString(GoString);\n+\tconst char *str = \"string passed from C to Go\";\n+\tgoWithString((GoString){str, strlen(str)});\n+}"}, {"sha": "eb720eba7c469afe32a1580ee8dd1e672767a5e7", "filename": "libgo/misc/cgo/test/callback_c_gc.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcallback_c_gc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcallback_c_gc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fcallback_c_gc.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build gc\n+\n+#include \"_cgo_export.h\"\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+/* Test calling panic from C.  This is what SWIG does.  */\n+\n+extern void crosscall2(void (*fn)(void *, int), void *, int);\n+extern void _cgo_panic(void *, int);\n+extern void _cgo_allocate(void *, int);\n+\n+void\n+callPanic(void)\n+{\n+\tstruct { const char *p; } a;\n+\ta.p = \"panic from C\";\n+\tcrosscall2(_cgo_panic, &a, sizeof a);\n+\t*(int*)1 = 1;\n+}"}, {"sha": "4eaa8184b30482cf510a311062672f1b779cfc09", "filename": "libgo/misc/cgo/test/callback_c_gccgo.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcallback_c_gccgo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcallback_c_gccgo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fcallback_c_gccgo.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build gccgo\n+\n+#include \"_cgo_export.h\"\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+/* Test calling panic from C.  This is what SWIG does.  */\n+\n+extern void _cgo_panic(const char *);\n+extern void *_cgo_allocate(size_t);\n+\n+void\n+callPanic(void)\n+{\n+\t_cgo_panic(\"panic from C\");\n+}"}, {"sha": "bc290bfcd5a795a280a4ce6a689d30f55f2d47b1", "filename": "libgo/misc/cgo/test/cflags.go", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcflags.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcflags.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fcflags.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test that the #cgo CFLAGS directive works,\n+// with and without platform filters.\n+// See https://golang.org/issue/5224 for details.\n+package cgotest\n+\n+/*\n+#cgo CFLAGS: -DCOMMON_VALUE=123\n+#cgo windows CFLAGS: -DIS_WINDOWS=1\n+#cgo !windows CFLAGS: -DIS_WINDOWS=0\n+int common = COMMON_VALUE;\n+int is_windows = IS_WINDOWS;\n+*/\n+import \"C\"\n+\n+import (\n+\t\"runtime\"\n+\t\"testing\"\n+)\n+\n+func testCflags(t *testing.T) {\n+\tis_windows := C.is_windows == 1\n+\tif is_windows != (runtime.GOOS == \"windows\") {\n+\t\tt.Errorf(\"is_windows: %v, runtime.GOOS: %s\", is_windows, runtime.GOOS)\n+\t}\n+\tif C.common != 123 {\n+\t\tt.Errorf(\"common: %v (expected 123)\", C.common)\n+\t}\n+}"}, {"sha": "9c15f69e4015733c8ca95992196092f50368d0cd", "filename": "libgo/misc/cgo/test/cgo_linux_test.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcgo_linux_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcgo_linux_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fcgo_linux_test.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+import \"testing\"\n+\n+func TestSetgid(t *testing.T)  { testSetgid(t) }\n+func Test6997(t *testing.T)    { test6997(t) }\n+func TestBuildID(t *testing.T) { testBuildID(t) }\n+func Test9400(t *testing.T)    { test9400(t) }"}, {"sha": "710e094cf77c1d942b9d3986cdea3a13c512b0ed", "filename": "libgo/misc/cgo/test/cgo_stubs_android_test.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcgo_stubs_android_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcgo_stubs_android_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fcgo_stubs_android_test.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+import \"testing\"\n+\n+// Stubs for tests that fails to build on Android\n+func test6997(t *testing.T)        {}\n+func test3775(t *testing.T)        {}\n+func test8694(t *testing.T)        {}\n+func testSigaltstack(t *testing.T) {}"}, {"sha": "a6de999752b4ff0d6cf14da4ff5caf0f5e61b55c", "filename": "libgo/misc/cgo/test/cgo_test.go", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fcgo_test.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+import \"testing\"\n+\n+// The actual test functions are in non-_test.go files\n+// so that they can use cgo (import \"C\").\n+// These wrappers are here for gotest to find.\n+\n+func TestAlign(t *testing.T)                 { testAlign(t) }\n+func TestConst(t *testing.T)                 { testConst(t) }\n+func TestEnum(t *testing.T)                  { testEnum(t) }\n+func TestAtol(t *testing.T)                  { testAtol(t) }\n+func TestErrno(t *testing.T)                 { testErrno(t) }\n+func TestMultipleAssign(t *testing.T)        { testMultipleAssign(t) }\n+func TestUnsignedInt(t *testing.T)           { testUnsignedInt(t) }\n+func TestCallback(t *testing.T)              { testCallback(t) }\n+func TestCallbackGC(t *testing.T)            { testCallbackGC(t) }\n+func TestCallbackPanic(t *testing.T)         { testCallbackPanic(t) }\n+func TestCallbackPanicLoop(t *testing.T)     { testCallbackPanicLoop(t) }\n+func TestCallbackPanicLocked(t *testing.T)   { testCallbackPanicLocked(t) }\n+func TestPanicFromC(t *testing.T)            { testPanicFromC(t) }\n+func TestZeroArgCallback(t *testing.T)       { testZeroArgCallback(t) }\n+func TestBlocking(t *testing.T)              { testBlocking(t) }\n+func Test1328(t *testing.T)                  { test1328(t) }\n+func TestParallelSleep(t *testing.T)         { testParallelSleep(t) }\n+func TestSetEnv(t *testing.T)                { testSetEnv(t) }\n+func TestHelpers(t *testing.T)               { testHelpers(t) }\n+func TestLibgcc(t *testing.T)                { testLibgcc(t) }\n+func Test1635(t *testing.T)                  { test1635(t) }\n+func TestPrintf(t *testing.T)                { testPrintf(t) }\n+func Test4029(t *testing.T)                  { test4029(t) }\n+func TestBoolAlign(t *testing.T)             { testBoolAlign(t) }\n+func Test3729(t *testing.T)                  { test3729(t) }\n+func Test3775(t *testing.T)                  { test3775(t) }\n+func TestCthread(t *testing.T)               { testCthread(t) }\n+func TestCallbackCallers(t *testing.T)       { testCallbackCallers(t) }\n+func Test5227(t *testing.T)                  { test5227(t) }\n+func TestCflags(t *testing.T)                { testCflags(t) }\n+func Test5337(t *testing.T)                  { test5337(t) }\n+func Test5548(t *testing.T)                  { test5548(t) }\n+func Test5603(t *testing.T)                  { test5603(t) }\n+func Test6833(t *testing.T)                  { test6833(t) }\n+func Test3250(t *testing.T)                  { test3250(t) }\n+func TestCallbackStack(t *testing.T)         { testCallbackStack(t) }\n+func TestFpVar(t *testing.T)                 { testFpVar(t) }\n+func Test4339(t *testing.T)                  { test4339(t) }\n+func Test6390(t *testing.T)                  { test6390(t) }\n+func Test5986(t *testing.T)                  { test5986(t) }\n+func Test7665(t *testing.T)                  { test7665(t) }\n+func TestNaming(t *testing.T)                { testNaming(t) }\n+func Test7560(t *testing.T)                  { test7560(t) }\n+func Test5242(t *testing.T)                  { test5242(t) }\n+func Test8092(t *testing.T)                  { test8092(t) }\n+func Test7978(t *testing.T)                  { test7978(t) }\n+func Test8694(t *testing.T)                  { test8694(t) }\n+func Test8517(t *testing.T)                  { test8517(t) }\n+func Test8811(t *testing.T)                  { test8811(t) }\n+func TestReturnAfterGrow(t *testing.T)       { testReturnAfterGrow(t) }\n+func TestReturnAfterGrowFromGo(t *testing.T) { testReturnAfterGrowFromGo(t) }\n+func Test9026(t *testing.T)                  { test9026(t) }\n+func Test9510(t *testing.T)                  { test9510(t) }\n+func Test9557(t *testing.T)                  { test9557(t) }\n+func Test10303(t *testing.T)                 { test10303(t, 10) }\n+func Test11925(t *testing.T)                 { test11925(t) }\n+func Test12030(t *testing.T)                 { test12030(t) }\n+func TestGCC68255(t *testing.T)              { testGCC68255(t) }\n+func TestCallGoWithString(t *testing.T)      { testCallGoWithString(t) }\n+func Test14838(t *testing.T)                 { test14838(t) }\n+func Test8756(t *testing.T)                  { test8756(t) }\n+func Test17065(t *testing.T)                 { test17065(t) }\n+func TestThreadLock(t *testing.T)            { testThreadLockFunc(t) }\n+func TestCheckConst(t *testing.T)            { testCheckConst(t) }\n+func Test17537(t *testing.T)                 { test17537(t) }\n+func Test18126(t *testing.T)                 { test18126(t) }\n+\n+func BenchmarkCgoCall(b *testing.B) { benchCgoCall(b) }"}, {"sha": "b1050685182287dd563a6d302ea819e1e6fbe138", "filename": "libgo/misc/cgo/test/cgo_thread_lock.go", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcgo_thread_lock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcgo_thread_lock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fcgo_thread_lock.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux,freebsd,openbsd\n+\n+package cgotest\n+\n+/*\n+#include <unistd.h>\n+#include <sys/syscall.h>\n+void Gosched(void);\n+static int Ctid(void) { Gosched(); return syscall(SYS_gettid); }\n+*/\n+import \"C\"\n+\n+import (\n+\t\"runtime\"\n+\t\"syscall\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+//export Gosched\n+func Gosched() {\n+\truntime.Gosched()\n+}\n+\n+func init() {\n+\ttestThreadLockFunc = testThreadLock\n+}\n+\n+func testThreadLock(t *testing.T) {\n+\tstop := make(chan int)\n+\tgo func() {\n+\t\t// We need the G continue running,\n+\t\t// so the M has a chance to run this G.\n+\t\tfor {\n+\t\t\tselect {\n+\t\t\tcase <-stop:\n+\t\t\t\treturn\n+\t\t\tcase <-time.After(time.Millisecond * 100):\n+\t\t\t}\n+\t\t}\n+\t}()\n+\tdefer close(stop)\n+\n+\tfor i := 0; i < 1000; i++ {\n+\t\tif C.int(syscall.Gettid()) != C.Ctid() {\n+\t\t\tt.Fatalf(\"cgo has not locked OS thread\")\n+\t\t}\n+\t}\n+}"}, {"sha": "e3d591664983befc0ef8b6bfe3f251f352f491d5", "filename": "libgo/misc/cgo/test/cgo_unix_test.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcgo_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcgo_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fcgo_unix_test.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !windows\n+\n+package cgotest\n+\n+import \"testing\"\n+\n+func TestSigaltstack(t *testing.T) { testSigaltstack(t) }\n+func TestSigprocmask(t *testing.T) { testSigprocmask(t) }\n+func Test18146(t *testing.T)       { test18146(t) }"}, {"sha": "0160c1e0ced6c1ab27ce4f46d55c99e4b256f896", "filename": "libgo/misc/cgo/test/checkconst.go", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcheckconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcheckconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fcheckconst.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test a constant in conjunction with pointer checking.\n+\n+package cgotest\n+\n+/*\n+#include <stdlib.h>\n+\n+#define CheckConstVal 0\n+\n+typedef struct {\n+\tint *p;\n+} CheckConstStruct;\n+\n+static void CheckConstFunc(CheckConstStruct *p, int e) {\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"testing\"\n+\t\"unsafe\"\n+)\n+\n+func testCheckConst(t *testing.T) {\n+\t// The test is that this compiles successfully.\n+\tp := C.malloc(C.size_t(unsafe.Sizeof(C.int(0))))\n+\tdefer C.free(p)\n+\tC.CheckConstFunc(&C.CheckConstStruct{(*C.int)(p)}, C.CheckConstVal)\n+}"}, {"sha": "ca0a97d9b3499aeaf16beeae71c256b080a24120", "filename": "libgo/misc/cgo/test/complex.go", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcomplex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcomplex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fcomplex.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+/*\n+struct {\n+\tfloat x;\n+\t_Complex float y;\n+} cplxAlign = { 3.14, 2.17 };\n+*/\n+import \"C\"\n+\n+import \"testing\"\n+\n+func TestComplexAlign(t *testing.T) {\n+\tif C.cplxAlign.x != 3.14 {\n+\t\tt.Errorf(\"got %v, expected 3.14\", C.cplxAlign.x)\n+\t}\n+\tif C.cplxAlign.y != 2.17 {\n+\t\tt.Errorf(\"got %v, expected 2.17\", C.cplxAlign.y)\n+\t}\n+}"}, {"sha": "af44911756a9e13f3aa1b2f9c367af54be089ba2", "filename": "libgo/misc/cgo/test/cthread.go", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcthread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcthread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fcthread.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+// extern void doAdd(int, int);\n+import \"C\"\n+\n+import (\n+\t\"runtime\"\n+\t\"sync\"\n+\t\"testing\"\n+)\n+\n+var sum struct {\n+\tsync.Mutex\n+\ti int\n+}\n+\n+//export Add\n+func Add(x int) {\n+\tdefer func() {\n+\t\trecover()\n+\t}()\n+\tsum.Lock()\n+\tsum.i += x\n+\tsum.Unlock()\n+\tvar p *int\n+\t*p = 2\n+}\n+\n+func testCthread(t *testing.T) {\n+\tif runtime.GOOS == \"darwin\" && (runtime.GOARCH == \"arm\" || runtime.GOARCH == \"arm64\") {\n+\t\tt.Skip(\"the iOS exec wrapper is unable to properly handle the panic from Add\")\n+\t}\n+\tsum.i = 0\n+\tC.doAdd(10, 6)\n+\n+\twant := 10 * (10 - 1) / 2 * 6\n+\tif sum.i != want {\n+\t\tt.Fatalf(\"sum=%d, want %d\", sum.i, want)\n+\t}\n+}"}, {"sha": "6323e4980e85bcb4f1433c46fcf6ea79fa19382e", "filename": "libgo/misc/cgo/test/cthread_unix.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcthread_unix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcthread_unix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fcthread_unix.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin dragonfly freebsd linux netbsd openbsd solaris\n+\n+#include <pthread.h>\n+#include \"_cgo_export.h\"\n+\n+static void*\n+addThread(void *p)\n+{\n+\tint i, max;\n+\t\n+\tmax = *(int*)p;\n+\tfor(i=0; i<max; i++)\n+\t\tAdd(i);\n+\treturn 0;\n+}\n+\n+void\n+doAdd(int max, int nthread)\n+{\n+\tenum { MaxThread = 20 };\n+\tint i;\n+\tpthread_t thread_id[MaxThread];\n+\t\n+\tif(nthread > MaxThread)\n+\t\tnthread = MaxThread;\n+\tfor(i=0; i<nthread; i++)\n+\t\tpthread_create(&thread_id[i], 0, addThread, &max);\n+\tfor(i=0; i<nthread; i++)\n+\t\tpthread_join(thread_id[i], 0);\t\t\n+}"}, {"sha": "3a62ddd3730f43b3aa6fafaf7466e35de2539d4f", "filename": "libgo/misc/cgo/test/cthread_windows.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcthread_windows.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fcthread_windows.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fcthread_windows.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#define WIN32_LEAN_AND_MEAN\n+#include <windows.h>\n+#include <process.h>\n+#include \"_cgo_export.h\"\n+\n+__stdcall\n+static unsigned int\n+addThread(void *p)\n+{\n+\tint i, max;\n+\t\n+\tmax = *(int*)p;\n+\tfor(i=0; i<max; i++)\n+\t\tAdd(i);\n+\treturn 0;\n+}\n+\n+void\n+doAdd(int max, int nthread)\n+{\n+\tenum { MaxThread = 20 };\n+\tint i;\n+\tuintptr_t thread_id[MaxThread];\n+\t\n+\tif(nthread > MaxThread)\n+\t\tnthread = MaxThread;\n+\tfor(i=0; i<nthread; i++)\n+\t\tthread_id[i] = _beginthreadex(0, 0, addThread, &max, 0, 0);\n+\tfor(i=0; i<nthread; i++) {\n+\t\tWaitForSingleObject((HANDLE)thread_id[i], INFINITE);\n+\t\tCloseHandle((HANDLE)thread_id[i]);\n+\t}\n+}"}, {"sha": "6144271321593bc83a6ff035bc60ad6dc62e521c", "filename": "libgo/misc/cgo/test/duplicate_symbol.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fduplicate_symbol.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fduplicate_symbol.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fduplicate_symbol.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file contains test cases for cgo.\n+\n+package cgotest\n+\n+/*\n+int base_symbol = 0;\n+\n+#define alias_one base_symbol\n+#define alias_two base_symbol\n+*/\n+import \"C\"\n+\n+import \"fmt\"\n+\n+func duplicateSymbols() {\n+\tfmt.Printf(\"%v %v %v\\n\", C.base_symbol, C.alias_one, C.alias_two)\n+}"}, {"sha": "b2081b72837a02a40531387a21cbf2dd24a77e71", "filename": "libgo/misc/cgo/test/env.go", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fenv.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+/*\n+#include <stdlib.h>\n+*/\n+import \"C\"\n+import (\n+\t\"os\"\n+\t\"runtime\"\n+\t\"testing\"\n+\t\"unsafe\"\n+)\n+\n+// This is really an os package test but here for convenience.\n+func testSetEnv(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\t// Go uses SetEnvironmentVariable on windows. Howerver,\n+\t\t// C runtime takes a *copy* at process startup of thei\n+\t\t// OS environment, and stores it in environ/envp.\n+\t\t// It is this copy that\tgetenv/putenv manipulate.\n+\t\tt.Logf(\"skipping test\")\n+\t\treturn\n+\t}\n+\tconst key = \"CGO_OS_TEST_KEY\"\n+\tconst val = \"CGO_OS_TEST_VALUE\"\n+\tos.Setenv(key, val)\n+\tkeyc := C.CString(key)\n+\tdefer C.free(unsafe.Pointer(keyc))\n+\tv := C.getenv(keyc)\n+\tif uintptr(unsafe.Pointer(v)) == 0 {\n+\t\tt.Fatal(\"getenv returned NULL\")\n+\t}\n+\tvs := C.GoString(v)\n+\tif vs != val {\n+\t\tt.Fatalf(\"getenv() = %q; want %q\", vs, val)\n+\t}\n+}"}, {"sha": "71e5dcdd3df2e76c637f7677de299b4817d213b5", "filename": "libgo/misc/cgo/test/exports.go", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fexports.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fexports.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fexports.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+import \"C\"\n+import \"runtime\"\n+\n+//export ReturnIntLong\n+func ReturnIntLong() (int, C.long) {\n+\treturn 1, 2\n+}\n+\n+//export gc\n+func gc() {\n+\truntime.GC()\n+}"}, {"sha": "7aab8ca2fc2d2d519702373e9da63c1c0a504fba", "filename": "libgo/misc/cgo/test/fpvar.go", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Ffpvar.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Ffpvar.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Ffpvar.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file contains test cases for cgo with function pointer variables.\n+\n+package cgotest\n+\n+/*\n+typedef int (*intFunc) ();\n+\n+int\n+bridge_int_func(intFunc f)\n+{\n+\treturn f();\n+}\n+\n+int fortytwo()\n+{\n+\treturn 42;\n+}\n+\n+*/\n+import \"C\"\n+import \"testing\"\n+\n+func callBridge(f C.intFunc) int {\n+\treturn int(C.bridge_int_func(f))\n+}\n+\n+func callCBridge(f C.intFunc) C.int {\n+\treturn C.bridge_int_func(f)\n+}\n+\n+func testFpVar(t *testing.T) {\n+\tconst expected = 42\n+\tf := C.intFunc(C.fortytwo)\n+\tres1 := C.bridge_int_func(f)\n+\tif r1 := int(res1); r1 != expected {\n+\t\tt.Errorf(\"got %d, want %d\", r1, expected)\n+\t}\n+\tres2 := callCBridge(f)\n+\tif r2 := int(res2); r2 != expected {\n+\t\tt.Errorf(\"got %d, want %d\", r2, expected)\n+\t}\n+\tr3 := callBridge(f)\n+\tif r3 != expected {\n+\t\tt.Errorf(\"got %d, want %d\", r3, expected)\n+\t}\n+}"}, {"sha": "23e103dc1093819ccf012b4187b51cda31b398da", "filename": "libgo/misc/cgo/test/gcc68255.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fgcc68255.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fgcc68255.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fgcc68255.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+import (\n+\t\"testing\"\n+\n+\t\"./gcc68255\"\n+)\n+\n+func testGCC68255(t *testing.T) {\n+\tif !gcc68255.F() {\n+\t\tt.Error(\"C global variable was not initialized\")\n+\t}\n+}"}, {"sha": "e106dee3ec023d652ff9b5e9f917106a2b84e8d8", "filename": "libgo/misc/cgo/test/gcc68255/a.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fgcc68255%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fgcc68255%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fgcc68255%2Fa.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test that it's OK to have C code that does nothing other than\n+// initialize a global variable.  This used to fail with gccgo.\n+\n+package gcc68255\n+\n+/*\n+#include \"c.h\"\n+*/\n+import \"C\"\n+\n+func F() bool {\n+\treturn C.v != nil\n+}"}, {"sha": "a4fe193825b79682086f5293b36a51cc166ac3ec", "filename": "libgo/misc/cgo/test/gcc68255/c.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fgcc68255%2Fc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fgcc68255%2Fc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fgcc68255%2Fc.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,8 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+static void f(void) {\n+}\n+\n+void (*v)(void) = f;"}, {"sha": "05ecd8187c7b04d485e1347a10780cc8f27ab690", "filename": "libgo/misc/cgo/test/gcc68255/c.h", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fgcc68255%2Fc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fgcc68255%2Fc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fgcc68255%2Fc.h?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,5 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+extern void (*v)(void);"}, {"sha": "f6a822a1065b268f37da359b07f6efa2276d3405", "filename": "libgo/misc/cgo/test/helpers.go", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fhelpers.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fhelpers.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fhelpers.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+// const char *greeting = \"hello, world\";\n+import \"C\"\n+\n+import (\n+\t\"reflect\"\n+\t\"testing\"\n+\t\"unsafe\"\n+)\n+\n+const greeting = \"hello, world\"\n+\n+type testPair struct {\n+\tName      string\n+\tGot, Want interface{}\n+}\n+\n+var testPairs = []testPair{\n+\t{\"GoString\", C.GoString(C.greeting), greeting},\n+\t{\"GoStringN\", C.GoStringN(C.greeting, 5), greeting[:5]},\n+\t{\"GoBytes\", C.GoBytes(unsafe.Pointer(C.greeting), 5), []byte(greeting[:5])},\n+}\n+\n+func testHelpers(t *testing.T) {\n+\tfor _, pair := range testPairs {\n+\t\tif !reflect.DeepEqual(pair.Got, pair.Want) {\n+\t\t\tt.Errorf(\"%s: got %#v, want %#v\", pair.Name, pair.Got, pair.Want)\n+\t\t}\n+\t}\n+}"}, {"sha": "66e2644d06648f51dde79547b9e6ae2f802400b3", "filename": "libgo/misc/cgo/test/issue10303.go", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue10303.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue10303.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue10303.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,76 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 10303. Pointers passed to C were not marked as escaping (bug in cgo).\n+\n+package cgotest\n+\n+import \"runtime\"\n+\n+/*\n+typedef int *intptr;\n+\n+void setintstar(int *x) {\n+\t*x = 1;\n+}\n+\n+void setintptr(intptr x) {\n+\t*x = 1;\n+}\n+\n+void setvoidptr(void *x) {\n+\t*(int*)x = 1;\n+}\n+\n+typedef struct Struct Struct;\n+struct Struct {\n+\tint *P;\n+};\n+\n+void setstruct(Struct s) {\n+\t*s.P = 1;\n+}\n+\n+*/\n+import \"C\"\n+\n+import (\n+\t\"testing\"\n+\t\"unsafe\"\n+)\n+\n+func test10303(t *testing.T, n int) {\n+\tif runtime.Compiler == \"gccgo\" {\n+\t\tt.Skip(\"gccgo permits C pointers on the stack\")\n+\t}\n+\n+\t// Run at a few different stack depths just to avoid an unlucky pass\n+\t// due to variables ending up on different pages.\n+\tif n > 0 {\n+\t\ttest10303(t, n-1)\n+\t}\n+\tif t.Failed() {\n+\t\treturn\n+\t}\n+\tvar x, y, z, v, si C.int\n+\tvar s C.Struct\n+\tC.setintstar(&x)\n+\tC.setintptr(&y)\n+\tC.setvoidptr(unsafe.Pointer(&v))\n+\ts.P = &si\n+\tC.setstruct(s)\n+\n+\tif uintptr(unsafe.Pointer(&x))&^0xfff == uintptr(unsafe.Pointer(&z))&^0xfff {\n+\t\tt.Error(\"C int* argument on stack\")\n+\t}\n+\tif uintptr(unsafe.Pointer(&y))&^0xfff == uintptr(unsafe.Pointer(&z))&^0xfff {\n+\t\tt.Error(\"C intptr argument on stack\")\n+\t}\n+\tif uintptr(unsafe.Pointer(&v))&^0xfff == uintptr(unsafe.Pointer(&z))&^0xfff {\n+\t\tt.Error(\"C void* argument on stack\")\n+\t}\n+\tif uintptr(unsafe.Pointer(&si))&^0xfff == uintptr(unsafe.Pointer(&z))&^0xfff {\n+\t\tt.Error(\"C struct field pointer on stack\")\n+\t}\n+}"}, {"sha": "c5c8a269f79d2856a4b0504c76326d54f5e679d0", "filename": "libgo/misc/cgo/test/issue11925.go", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue11925.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue11925.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue11925.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 11925.  Structs with zero-length trailing fields are now\n+// padded by the Go compiler.\n+\n+package cgotest\n+\n+/*\n+struct a11925 {\n+\tint i;\n+\tchar a[0];\n+\tchar b[0];\n+};\n+\n+struct b11925 {\n+\tint i;\n+\tchar a[0];\n+\tchar b[];\n+};\n+*/\n+import \"C\"\n+\n+import (\n+\t\"testing\"\n+\t\"unsafe\"\n+)\n+\n+func test11925(t *testing.T) {\n+\tif C.sizeof_struct_a11925 != unsafe.Sizeof(C.struct_a11925{}) {\n+\t\tt.Errorf(\"size of a changed: C %d, Go %d\", C.sizeof_struct_a11925, unsafe.Sizeof(C.struct_a11925{}))\n+\t}\n+\tif C.sizeof_struct_b11925 != unsafe.Sizeof(C.struct_b11925{}) {\n+\t\tt.Errorf(\"size of b changed: C %d, Go %d\", C.sizeof_struct_b11925, unsafe.Sizeof(C.struct_b11925{}))\n+\t}\n+}"}, {"sha": "f863c58aa2aae022ed6e1788e27eeb1caa6afcdc", "filename": "libgo/misc/cgo/test/issue12030.go", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue12030.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue12030.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue12030.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 12030. sprintf is defined in both ntdll and msvcrt,\n+// Normally we want the one in the msvcrt.\n+\n+package cgotest\n+\n+/*\n+#include <stdio.h>\n+#include <stdlib.h>\n+void issue12030conv(char *buf, double x) {\n+\tsprintf(buf, \"d=%g\", x);\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"fmt\"\n+\t\"testing\"\n+\t\"unsafe\"\n+)\n+\n+func test12030(t *testing.T) {\n+\tbuf := (*C.char)(C.malloc(256))\n+\tdefer C.free(unsafe.Pointer(buf))\n+\tfor _, f := range []float64{1.0, 2.0, 3.14} {\n+\t\tC.issue12030conv(buf, C.double(f))\n+\t\tgot := C.GoString(buf)\n+\t\tif want := fmt.Sprintf(\"d=%g\", f); got != want {\n+\t\t\tt.Fatalf(\"C.sprintf failed for %g: %q != %q\", f, got, want)\n+\t\t}\n+\t}\n+}"}, {"sha": "4868da8e18508a4a472357eea0d65ee056cb2b42", "filename": "libgo/misc/cgo/test/issue1222.go", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue1222.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue1222.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue1222.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file contains test cases for cgo.\n+\n+package cgotest\n+\n+/*\n+// issue 1222\n+typedef union {\n+\tlong align;\n+} xxpthread_mutex_t;\n+\n+struct ibv_async_event {\n+\tunion {\n+\t\tint x;\n+\t} element;\n+};\n+\n+struct ibv_context {\n+\txxpthread_mutex_t mutex;\n+};\n+*/\n+import \"C\"\n+\n+type AsyncEvent struct {\n+\tevent C.struct_ibv_async_event\n+}"}, {"sha": "2401c10e300687556fde412705b318f3d90785a1", "filename": "libgo/misc/cgo/test/issue1328.go", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue1328.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue1328.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue1328.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+import \"testing\"\n+\n+// extern void BackIntoGo(void);\n+// void IntoC(void);\n+import \"C\"\n+\n+//export BackIntoGo\n+func BackIntoGo() {\n+\tx := 1\n+\n+\tfor i := 0; i < 10000; i++ {\n+\t\txvariadic(x)\n+\t\tif x != 1 {\n+\t\t\tpanic(\"x is not 1?\")\n+\t\t}\n+\t}\n+}\n+\n+func xvariadic(x ...interface{}) {\n+}\n+\n+func test1328(t *testing.T) {\n+\tC.IntoC()\n+}"}, {"sha": "3af24c2d3c24057f14c64fc25d7923b551a3642a", "filename": "libgo/misc/cgo/test/issue13402.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue13402.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue13402.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue13402.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,10 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+import \"C\"\n+\n+var _ C.complexfloat\n+var _ C.complexdouble"}, {"sha": "c4a08ee7c9e11be2dc0c89942662622465951c60", "filename": "libgo/misc/cgo/test/issue13930.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue13930.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue13930.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue13930.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 13930.  Test that cgo's multiple-value special form for\n+// C function calls works in variable declaration statements.\n+\n+package cgotest\n+\n+// #include <stdlib.h>\n+import \"C\"\n+\n+var _, _ = C.abs(0)"}, {"sha": "c8e1681295e8f2e5e082028a4f936d7910edb5a6", "filename": "libgo/misc/cgo/test/issue14838.go", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue14838.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue14838.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue14838.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 14838. add CBytes function\n+\n+package cgotest\n+\n+/*\n+#include <stdlib.h>\n+\n+int check_cbytes(char *b, size_t l) {\n+\tint i;\n+\tfor (i = 0; i < l; i++) {\n+\t\tif (b[i] != i) {\n+\t\t\treturn 0;\n+\t\t}\n+\t}\n+\treturn 1;\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"testing\"\n+\t\"unsafe\"\n+)\n+\n+func test14838(t *testing.T) {\n+\tdata := []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n+\tcData := C.CBytes(data)\n+\tdefer C.free(cData)\n+\n+\tif C.check_cbytes((*C.char)(cData), C.size_t(len(data))) == 0 {\n+\t\tt.Fatalf(\"mismatched data: expected %v, got %v\", data, (*(*[10]byte)(unsafe.Pointer(cData)))[:])\n+\t}\n+}"}, {"sha": "30f615222572a6acd680babbbd92ca43c3f81929", "filename": "libgo/misc/cgo/test/issue1560.go", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue1560.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue1560.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue1560.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+/*\n+// mysleep returns the absolute start time in ms.\n+long long mysleep(int seconds);\n+\n+// twoSleep returns the absolute start time of the first sleep\n+// in ms.\n+long long twoSleep(int);\n+*/\n+import \"C\"\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+var sleepDone = make(chan int64)\n+\n+// parallelSleep returns the absolute difference between the start time\n+// of the two sleeps.\n+func parallelSleep(n int) int64 {\n+\tt := int64(C.twoSleep(C.int(n))) - <-sleepDone\n+\tif t < 0 {\n+\t\treturn -t\n+\t}\n+\treturn t\n+}\n+\n+//export BackgroundSleep\n+func BackgroundSleep(n int32) {\n+\tgo func() {\n+\t\tsleepDone <- int64(C.mysleep(C.int(n)))\n+\t}()\n+}\n+\n+func testParallelSleep(t *testing.T) {\n+\tsleepSec := 1\n+\tdt := time.Duration(parallelSleep(sleepSec)) * time.Millisecond\n+\tt.Logf(\"difference in start time for two sleep(%d) is %v\", sleepSec, dt)\n+\t// bug used to run sleeps in serial, producing a 2*sleepSec-second delay.\n+\t// we detect if the start times of those sleeps are > 0.5*sleepSec-second.\n+\tif dt >= time.Duration(sleepSec)*time.Second/2 {\n+\t\tt.Fatalf(\"parallel %d-second sleeps slept for %f seconds\", sleepSec, dt.Seconds())\n+\t}\n+}"}, {"sha": "25899271c93a181bd2df234acda8b423bf878f4b", "filename": "libgo/misc/cgo/test/issue1635.go", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue1635.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue1635.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue1635.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+/*\n+// Mac OS X's gcc will generate scattered relocation 2/1 for\n+// this function on Darwin/386, and 8l couldn't handle it.\n+// this example is in issue 1635\n+#include <stdio.h>\n+void scatter() {\n+\tvoid *p = scatter;\n+\tprintf(\"scatter = %p\\n\", p);\n+}\n+\n+// Adding this explicit extern declaration makes this a test for\n+// https://gcc.gnu.org/PR68072 aka https://golang.org/issue/13344 .\n+// It used to cause a cgo error when building with GCC 6.\n+extern int hola;\n+\n+// this example is in issue 3253\n+int hola = 0;\n+int testHola() { return hola; }\n+*/\n+import \"C\"\n+\n+import \"testing\"\n+\n+func test1635(t *testing.T) {\n+\tC.scatter()\n+\tif v := C.hola; v != 0 {\n+\t\tt.Fatalf(\"C.hola is %d, should be 0\", v)\n+\t}\n+\tif v := C.testHola(); v != 0 {\n+\t\tt.Fatalf(\"C.testHola() is %d, should be 0\", v)\n+\t}\n+}"}, {"sha": "ede30bc3e638de641b67421d6254bd0287fe5d86", "filename": "libgo/misc/cgo/test/issue17065.go", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue17065.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue17065.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue17065.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+/*\n+// Test that C symbols larger than a page play nicely with the race detector.\n+// See issue 17065.\n+\n+int ii[65537];\n+*/\n+import \"C\"\n+\n+import (\n+\t\"runtime\"\n+\t\"testing\"\n+)\n+\n+var sink C.int\n+\n+func test17065(t *testing.T) {\n+\tif runtime.GOOS == \"darwin\" {\n+\t\tt.Skip(\"broken on darwin; issue 17065\")\n+\t}\n+\tfor i := range C.ii {\n+\t\tsink = C.ii[i]\n+\t}\n+}"}, {"sha": "777104e512209892d4fa856d9d791ad972dc9a35", "filename": "libgo/misc/cgo/test/issue17537.go", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue17537.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue17537.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue17537.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 17537.  The void* cast introduced by cgo to avoid problems\n+// with const/volatile qualifiers breaks C preprocessor macros that\n+// emulate functions.\n+\n+package cgotest\n+\n+/*\n+#include <stdlib.h>\n+\n+typedef struct {\n+\tint i;\n+} S17537;\n+\n+int I17537(S17537 *p);\n+\n+#define I17537(p) ((p)->i)\n+\n+// Calling this function used to fail without the cast.\n+const int F17537(const char **p) {\n+\treturn **p;\n+}\n+\n+// Calling this function used to trigger an error from the C compiler\n+// (issue 18298).\n+void F18298(const void *const *p) {\n+}\n+\n+// Test that conversions between typedefs work as they used to.\n+typedef const void *T18298_1;\n+struct S18298 { int i; };\n+typedef const struct S18298 *T18298_2;\n+void G18298(T18298_1 t) {\n+}\n+*/\n+import \"C\"\n+\n+import \"testing\"\n+\n+func test17537(t *testing.T) {\n+\tv := C.S17537{i: 17537}\n+\tif got, want := C.I17537(&v), C.int(17537); got != want {\n+\t\tt.Errorf(\"got %d, want %d\", got, want)\n+\t}\n+\n+\tp := (*C.char)(C.malloc(1))\n+\t*p = 17\n+\tif got, want := C.F17537(&p), C.int(17); got != want {\n+\t\tt.Errorf(\"got %d, want %d\", got, want)\n+\t}\n+\n+\tC.F18298(nil)\n+\tvar v18298 C.T18298_2\n+\tC.G18298(C.T18298_1(v18298))\n+}"}, {"sha": "ac94a66aab74536a6fb07754e17489216bdd5187", "filename": "libgo/misc/cgo/test/issue18126.go", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue18126.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue18126.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue18126.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 18126: cgo check of void function returning errno.\n+\n+package cgotest\n+\n+/*\n+#include <stdlib.h>\n+\n+void Issue18126C(void **p) {\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"testing\"\n+)\n+\n+func test18126(t *testing.T) {\n+\tp := C.malloc(1)\n+\t_, err := C.Issue18126C(&p)\n+\tC.free(p)\n+\t_ = err\n+}"}, {"sha": "3c600463f0335447f8a36c44fb20f607519f2b64", "filename": "libgo/misc/cgo/test/issue18146.go", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue18146.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue18146.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue18146.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,128 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !windows\n+\n+// Issue 18146: pthread_create failure during syscall.Exec.\n+\n+package cgotest\n+\n+import \"C\"\n+\n+import (\n+\t\"bytes\"\n+\t\"crypto/md5\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"runtime\"\n+\t\"syscall\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func test18146(t *testing.T) {\n+\tif runtime.GOOS == \"darwin\" {\n+\t\tt.Skipf(\"skipping flaky test on %s; see golang.org/issue/18202\", runtime.GOOS)\n+\t}\n+\n+\tif runtime.GOARCH == \"mips\" || runtime.GOARCH == \"mips64\" {\n+\t\tt.Skipf(\"skipping on %s\", runtime.GOARCH)\n+\t}\n+\n+\tattempts := 1000\n+\tthreads := 4\n+\n+\tif testing.Short() {\n+\t\tattempts = 100\n+\t}\n+\n+\t// Restrict the number of attempts based on RLIMIT_NPROC.\n+\t// Tediously, RLIMIT_NPROC was left out of the syscall package,\n+\t// probably because it is not in POSIX.1, so we define it here.\n+\t// It is not defined on Solaris.\n+\tvar nproc int\n+\tsetNproc := true\n+\tswitch runtime.GOOS {\n+\tdefault:\n+\t\tsetNproc = false\n+\tcase \"linux\":\n+\t\tnproc = 6\n+\tcase \"darwin\", \"dragonfly\", \"freebsd\", \"netbsd\", \"openbsd\":\n+\t\tnproc = 7\n+\t}\n+\tif setNproc {\n+\t\tvar rlim syscall.Rlimit\n+\t\tif syscall.Getrlimit(nproc, &rlim) == nil {\n+\t\t\tmax := int(rlim.Cur) / (threads + 5)\n+\t\t\tif attempts > max {\n+\t\t\t\tt.Logf(\"lowering attempts from %d to %d for RLIMIT_NPROC\", attempts, max)\n+\t\t\t\tattempts = max\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif os.Getenv(\"test18146\") == \"exec\" {\n+\t\truntime.GOMAXPROCS(1)\n+\t\tfor n := threads; n > 0; n-- {\n+\t\t\tgo func() {\n+\t\t\t\tfor {\n+\t\t\t\t\t_ = md5.Sum([]byte(\"Hello, \uf800!\"))\n+\t\t\t\t}\n+\t\t\t}()\n+\t\t}\n+\t\truntime.GOMAXPROCS(threads)\n+\t\targv := append(os.Args, \"-test.run=NoSuchTestExists\")\n+\t\tif err := syscall.Exec(os.Args[0], argv, os.Environ()); err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t}\n+\n+\tvar cmds []*exec.Cmd\n+\tdefer func() {\n+\t\tfor _, cmd := range cmds {\n+\t\t\tcmd.Process.Kill()\n+\t\t}\n+\t}()\n+\n+\targs := append(append([]string(nil), os.Args[1:]...), \"-test.run=Test18146\")\n+\tfor n := attempts; n > 0; n-- {\n+\t\tcmd := exec.Command(os.Args[0], args...)\n+\t\tcmd.Env = append(os.Environ(), \"test18146=exec\")\n+\t\tbuf := bytes.NewBuffer(nil)\n+\t\tcmd.Stdout = buf\n+\t\tcmd.Stderr = buf\n+\t\tif err := cmd.Start(); err != nil {\n+\t\t\t// We are starting so many processes that on\n+\t\t\t// some systems (problem seen on Darwin,\n+\t\t\t// Dragonfly, OpenBSD) the fork call will fail\n+\t\t\t// with EAGAIN.\n+\t\t\tif pe, ok := err.(*os.PathError); ok {\n+\t\t\t\terr = pe.Err\n+\t\t\t}\n+\t\t\tif se, ok := err.(syscall.Errno); ok && (se == syscall.EAGAIN || se == syscall.EMFILE) {\n+\t\t\t\ttime.Sleep(time.Millisecond)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tt.Error(err)\n+\t\t\treturn\n+\t\t}\n+\t\tcmds = append(cmds, cmd)\n+\t}\n+\n+\tfailures := 0\n+\tfor _, cmd := range cmds {\n+\t\terr := cmd.Wait()\n+\t\tif err == nil {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tt.Errorf(\"syscall.Exec failed: %v\\n%s\", err, cmd.Stdout)\n+\t\tfailures++\n+\t}\n+\n+\tif failures > 0 {\n+\t\tt.Logf(\"Failed %v of %v attempts.\", failures, len(cmds))\n+\t}\n+}"}, {"sha": "febca1eb085fbd14d1d5cc775bf7b59dadc13e46", "filename": "libgo/misc/cgo/test/issue2462.go", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue2462.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue2462.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue2462.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,102 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+import \"C\"\n+\n+//export exportbyte\n+func exportbyte() byte {\n+\treturn 0\n+}\n+\n+//export exportbool\n+func exportbool() bool {\n+\treturn false\n+}\n+\n+//export exportrune\n+func exportrune() rune {\n+\treturn 0\n+}\n+\n+//export exporterror\n+func exporterror() error {\n+\treturn nil\n+}\n+\n+//export exportint\n+func exportint() int {\n+\treturn 0\n+}\n+\n+//export exportuint\n+func exportuint() uint {\n+\treturn 0\n+}\n+\n+//export exportuintptr\n+func exportuintptr() uintptr {\n+\treturn (uintptr)(0)\n+}\n+\n+//export exportint8\n+func exportint8() int8 {\n+\treturn 0\n+}\n+\n+//export exportuint8\n+func exportuint8() uint8 {\n+\treturn 0\n+}\n+\n+//export exportint16\n+func exportint16() int16 {\n+\treturn 0\n+}\n+\n+//export exportuint16\n+func exportuint16() uint16 {\n+\treturn 0\n+}\n+\n+//export exportint32\n+func exportint32() int32 {\n+\treturn 0\n+}\n+\n+//export exportuint32\n+func exportuint32() uint32 {\n+\treturn 0\n+}\n+\n+//export exportint64\n+func exportint64() int64 {\n+\treturn 0\n+}\n+\n+//export exportuint64\n+func exportuint64() uint64 {\n+\treturn 0\n+}\n+\n+//export exportfloat32\n+func exportfloat32() float32 {\n+\treturn 0\n+}\n+\n+//export exportfloat64\n+func exportfloat64() float64 {\n+\treturn 0\n+}\n+\n+//export exportcomplex64\n+func exportcomplex64() complex64 {\n+\treturn 0\n+}\n+\n+//export exportcomplex128\n+func exportcomplex128() complex128 {\n+\treturn 0\n+}"}, {"sha": "f85c16b2dced30b583a8ff7bbd874b352706de35", "filename": "libgo/misc/cgo/test/issue3250.go", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3250.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3250.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3250.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !windows\n+\n+package cgotest\n+\n+/*\n+#include <signal.h>\n+#include <pthread.h>\n+#include <unistd.h>\n+#include <stdlib.h>\n+\n+static void *thread(void *p) {\n+\tconst int M = 100;\n+\tint i;\n+\t(void)p;\n+\tfor (i = 0; i < M; i++) {\n+\t\tpthread_kill(pthread_self(), SIGCHLD);\n+\t\tusleep(rand() % 20 + 5);\n+\t}\n+\treturn NULL;\n+}\n+void testSendSIG() {\n+\tconst int N = 20;\n+\tint i;\n+\tpthread_t tid[N];\n+\tfor (i = 0; i < N; i++) {\n+\t\tusleep(rand() % 200 + 100);\n+\t\tpthread_create(&tid[i], 0, thread, NULL);\n+\t}\n+\tfor (i = 0; i < N; i++)\n+\t\tpthread_join(tid[i], 0);\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"os\"\n+\t\"os/signal\"\n+\t\"syscall\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func test3250(t *testing.T) {\n+\tt.Skip(\"skipped, see golang.org/issue/5885\")\n+\tconst (\n+\t\tthres = 1\n+\t\tsig   = syscall.SIGCHLD\n+\t)\n+\ttype result struct {\n+\t\tn   int\n+\t\tsig os.Signal\n+\t}\n+\tvar (\n+\t\tsigCh     = make(chan os.Signal, 10)\n+\t\twaitStart = make(chan struct{})\n+\t\twaitDone  = make(chan result)\n+\t)\n+\n+\tsignal.Notify(sigCh, sig)\n+\n+\tgo func() {\n+\t\tn := 0\n+\t\talarm := time.After(time.Second * 3)\n+\t\tfor {\n+\t\t\tselect {\n+\t\t\tcase <-waitStart:\n+\t\t\t\twaitStart = nil\n+\t\t\tcase v := <-sigCh:\n+\t\t\t\tn++\n+\t\t\t\tif v != sig || n > thres {\n+\t\t\t\t\twaitDone <- result{n, v}\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\tcase <-alarm:\n+\t\t\t\twaitDone <- result{n, sig}\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\twaitStart <- struct{}{}\n+\tC.testSendSIG()\n+\tr := <-waitDone\n+\tif r.sig != sig {\n+\t\tt.Fatalf(\"received signal %v, but want %v\", r.sig, sig)\n+\t}\n+\tt.Logf(\"got %d signals\\n\", r.n)\n+\tif r.n <= thres {\n+\t\tt.Fatalf(\"expected more than %d\", thres)\n+\t}\n+}"}, {"sha": "c2193aa1f1cb6cda617ade881946b4ae3b50af23", "filename": "libgo/misc/cgo/test/issue3250w.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3250w.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3250w.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3250w.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build windows\n+\n+package cgotest\n+\n+import \"testing\"\n+\n+func test3250(t *testing.T) {}"}, {"sha": "71375698d376d8832727fab413d1a76a37794f5f", "filename": "libgo/misc/cgo/test/issue3261.go", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3261.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3261.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3261.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+/*\n+// libgcc on ARM might be compiled as thumb code, but our 5l\n+// can't handle that, so we have to disable this test on arm.\n+#ifdef __ARMEL__\n+#include <stdio.h>\n+int vabs(int x) {\n+\tputs(\"testLibgcc is disabled on ARM because 5l cannot handle thumb library.\");\n+\treturn (x < 0) ? -x : x;\n+}\n+#elif defined(__arm64__) && defined(__clang__)\n+#include <stdio.h>\n+int vabs(int x) {\n+\tputs(\"testLibgcc is disabled on ARM64 with clang due to lack of libgcc.\");\n+\treturn (x < 0) ? -x : x;\n+}\n+#else\n+int __absvsi2(int); // dummy prototype for libgcc function\n+// we shouldn't name the function abs, as gcc might use\n+// the builtin one.\n+int vabs(int x) { return __absvsi2(x); }\n+#endif\n+*/\n+import \"C\"\n+\n+import \"testing\"\n+\n+func testLibgcc(t *testing.T) {\n+\tvar table = []struct {\n+\t\tin, out C.int\n+\t}{\n+\t\t{0, 0},\n+\t\t{1, 1},\n+\t\t{-42, 42},\n+\t\t{1000300, 1000300},\n+\t\t{1 - 1<<31, 1<<31 - 1},\n+\t}\n+\tfor _, v := range table {\n+\t\tif o := C.vabs(v.in); o != v.out {\n+\t\t\tt.Fatalf(\"abs(%d) got %d, should be %d\", v.in, o, v.out)\n+\t\t\treturn\n+\t\t}\n+\t}\n+}"}, {"sha": "947b90a00de2e2afde80a356678383231cdbf622", "filename": "libgo/misc/cgo/test/issue3729.go", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3729.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3729.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3729.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 3729:\tcmd/cgo: access errno from void C function\n+// void f(void) returns [0]byte, error in Go world.\n+\n+// +build !windows\n+\n+package cgotest\n+\n+/*\n+#include <errno.h>\n+\n+void g(void) {\n+\terrno = E2BIG;\n+}\n+\n+// try to pass some non-trivial arguments to function g2\n+const char _expA = 0x42;\n+const float _expB = 3.14159;\n+const short _expC = 0x55aa;\n+const int _expD = 0xdeadbeef;\n+void g2(int x, char a, float b, short c, int d) {\n+\tif (a == _expA && b == _expB && c == _expC && d == _expD)\n+\t\terrno = x;\n+\telse\n+\t\terrno = -1;\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"syscall\"\n+\t\"testing\"\n+)\n+\n+func test3729(t *testing.T) {\n+\t_, e := C.g()\n+\tif e != syscall.E2BIG {\n+\t\tt.Errorf(\"got %q, expect %q\", e, syscall.E2BIG)\n+\t}\n+\t_, e = C.g2(C.EINVAL, C._expA, C._expB, C._expC, C._expD)\n+\tif e != syscall.EINVAL {\n+\t\tt.Errorf(\"got %q, expect %q\", e, syscall.EINVAL)\n+\t}\n+}"}, {"sha": "69296b506e7641b158dbf59ec1f08ff87d739d38", "filename": "libgo/misc/cgo/test/issue3729w.go", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3729w.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3729w.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3729w.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 3729:\tcmd/cgo: access errno from void C function\n+// void f(void) returns [0]byte, error in Go world.\n+\n+// +build windows\n+\n+package cgotest\n+\n+import \"testing\"\n+\n+func test3729(t *testing.T) {\n+\tt.Log(\"skip errno test on Windows\")\n+}"}, {"sha": "314038c1fe8be0c306cdbb3f49bf8c345ec8bf79", "filename": "libgo/misc/cgo/test/issue3741.go", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3741.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3741.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3741.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+import \"C\"\n+\n+//export exportSliceIn\n+func exportSliceIn(s []byte) bool {\n+\treturn len(s) == cap(s)\n+}\n+\n+//export exportSliceOut\n+func exportSliceOut() []byte {\n+\treturn []byte{1}\n+}\n+\n+//export exportSliceInOut\n+func exportSliceInOut(s []byte) []byte {\n+\treturn s\n+}"}, {"sha": "5aca7602c03ff55e199b8d063e1b44c2f42b3851", "filename": "libgo/misc/cgo/test/issue3775.go", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3775.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3775.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3775.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,39 @@\n+// +build !android\n+\n+package cgotest\n+\n+/*\n+void lockOSThreadCallback(void);\n+inline static void lockOSThreadC(void)\n+{\n+        lockOSThreadCallback();\n+}\n+int usleep(unsigned usec);\n+*/\n+import \"C\"\n+\n+import (\n+\t\"runtime\"\n+\t\"testing\"\n+)\n+\n+func init() {\n+\t// Same as test3775 but run during init so that\n+\t// there are two levels of internal runtime lock\n+\t// (1 for init, 1 for cgo).\n+\t// This would have been broken by CL 11663043.\n+\tC.lockOSThreadC()\n+}\n+\n+func test3775(t *testing.T) {\n+\t// Used to panic because of the UnlockOSThread below.\n+\tC.lockOSThreadC()\n+}\n+\n+//export lockOSThreadCallback\n+func lockOSThreadCallback() {\n+\truntime.LockOSThread()\n+\truntime.UnlockOSThread()\n+\tgo C.usleep(10000)\n+\truntime.Gosched()\n+}"}, {"sha": "2f9fe23b8dcc3ff10c9795daff7f1bdef21610b1", "filename": "libgo/misc/cgo/test/issue3945.go", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3945.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3945.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue3945.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+// Test that cgo reserves enough stack space during cgo call.\n+// See https://golang.org/issue/3945 for details.\n+\n+// #include <stdio.h>\n+//\n+// void say() {\n+//    printf(\"%s from C\\n\", \"hello\");\n+// }\n+//\n+import \"C\"\n+\n+import \"testing\"\n+\n+func testPrintf(t *testing.T) {\n+\tC.say()\n+}"}, {"sha": "eab36834501ff78389eb00ad127a074c1f65b09e", "filename": "libgo/misc/cgo/test/issue4029.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4029.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4029.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4029.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,10 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !windows\n+\n+void call4029(void *arg) {\n+\tvoid (*fn)(void) = arg;\n+\tfn();\n+}"}, {"sha": "5789b99ef67034f4644bac0aa9186e40675a1cf4", "filename": "libgo/misc/cgo/test/issue4029.go", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4029.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4029.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4029.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !windows\n+\n+package cgotest\n+\n+/*\n+#include <dlfcn.h>\n+#cgo linux LDFLAGS: -ldl\n+\n+extern void call4029(void *arg);\n+*/\n+import \"C\"\n+\n+import (\n+\t\"testing\"\n+)\n+\n+var callbacks int\n+\n+//export IMPIsOpaque\n+func IMPIsOpaque() {\n+\tcallbacks++\n+}\n+\n+//export IMPInitWithFrame\n+func IMPInitWithFrame() {\n+\tcallbacks++\n+}\n+\n+//export IMPDrawRect\n+func IMPDrawRect() {\n+\tcallbacks++\n+}\n+\n+//export IMPWindowResize\n+func IMPWindowResize() {\n+\tcallbacks++\n+}\n+\n+func test4029(t *testing.T) {\n+\tloadThySelf(t, \"IMPWindowResize\")\n+\tloadThySelf(t, \"IMPDrawRect\")\n+\tloadThySelf(t, \"IMPInitWithFrame\")\n+\tloadThySelf(t, \"IMPIsOpaque\")\n+\tif callbacks != 4 {\n+\t\tt.Errorf(\"got %d callbacks, expected 4\", callbacks)\n+\t}\n+}\n+\n+func loadThySelf(t *testing.T, symbol string) {\n+\tthis_process := C.dlopen(nil, C.RTLD_NOW)\n+\tif this_process == nil {\n+\t\tt.Error(\"dlopen:\", C.GoString(C.dlerror()))\n+\t\treturn\n+\t}\n+\tdefer C.dlclose(this_process)\n+\n+\tsymbol_address := C.dlsym(this_process, C.CString(symbol))\n+\tif symbol_address == nil {\n+\t\tt.Error(\"dlsym:\", C.GoString(C.dlerror()))\n+\t\treturn\n+\t}\n+\tt.Log(symbol, symbol_address)\n+\tC.call4029(symbol_address)\n+}"}, {"sha": "18c720191be397dbc0c9a8c759b29054a49247c0", "filename": "libgo/misc/cgo/test/issue4029w.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4029w.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4029w.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4029w.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build windows\n+\n+package cgotest\n+\n+import \"testing\"\n+\n+func test4029(t *testing.T) {\n+}"}, {"sha": "2abdac590471479d48efd1474c01666e68d71f36", "filename": "libgo/misc/cgo/test/issue4054a.go", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4054a.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4054a.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4054a.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+/*\n+typedef enum {\n+\tA = 0,\n+\tB,\n+\tC,\n+\tD,\n+\tE,\n+\tF,\n+\tG,\n+\tH,\n+\tI,\n+\tJ,\n+} issue4054a;\n+*/\n+import \"C\"\n+\n+var issue4054a = []int{C.A, C.B, C.C, C.D, C.E, C.F, C.G, C.H, C.I, C.J}"}, {"sha": "048964c89372ee37593c24ba6473dbd90e019dff", "filename": "libgo/misc/cgo/test/issue4054b.go", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4054b.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4054b.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4054b.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+/*\n+typedef enum {\n+\tA = 0,\n+\tB,\n+\tC,\n+\tD,\n+\tE,\n+\tF,\n+\tG,\n+\tH,\n+\tI,\n+\tJ,\n+} issue4054b;\n+*/\n+import \"C\"\n+\n+var issue4054b = []int{C.A, C.B, C.C, C.D, C.E, C.F, C.G, C.H, C.I, C.J}"}, {"sha": "cac98768dea9c8554fbe5a73c5a2aeed2726955d", "filename": "libgo/misc/cgo/test/issue4273.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4273.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4273.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4273.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,10 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifdef __ELF__\n+__attribute__((weak))\n+__attribute__((visibility(\"hidden\")))\n+void _compilerrt_abort_impl(const char *file, int line, const char *func) {\n+}\n+#endif"}, {"sha": "71e3f0d976ad4e1f5156d1b488a8a8c2844a0066", "filename": "libgo/misc/cgo/test/issue4273b.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4273b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4273b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4273b.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifdef __ELF__\n+extern void _compilerrt_abort_impl(const char *file, int line, const char *func);\n+\n+void __my_abort(const char *file, int line, const char *func) {\n+\t_compilerrt_abort_impl(file, line, func);\n+}\n+#endif"}, {"sha": "15d0004078cfd1cb175e24ff3945082650aba044", "filename": "libgo/misc/cgo/test/issue4339.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4339.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4339.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4339.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,18 @@\n+#include <stdio.h>\n+#include \"issue4339.h\"\n+\n+static void\n+impl(void)\n+{\n+\t//printf(\"impl\\n\");\n+}\n+\n+Issue4339 exported4339 = {\"bar\", impl};\n+\n+void\n+handle4339(Issue4339 *x)\n+{\n+\t//printf(\"handle\\n\");\n+\tx->bar();\n+\t//printf(\"done\\n\");\n+}"}, {"sha": "4fa4b2bbd7e3c6bb2d357d89b97e923d9d311902", "filename": "libgo/misc/cgo/test/issue4339.go", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4339.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4339.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4339.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+/*\n+#include \"issue4339.h\"\n+*/\n+import \"C\"\n+\n+import \"testing\"\n+\n+func test4339(t *testing.T) {\n+\tC.handle4339(&C.exported4339)\n+}"}, {"sha": "20f6cebb6b5b3165d3b0cb429e1172e592e8a975", "filename": "libgo/misc/cgo/test/issue4339.h", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4339.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4339.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4339.h?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,9 @@\n+typedef struct Issue4339 Issue4339;\n+\n+struct Issue4339 {\n+\tchar *name;\n+\tvoid (*bar)(void);\n+};\n+\n+extern Issue4339 exported4339;\n+void\thandle4339(Issue4339*);"}, {"sha": "9b182870d8e16a9118d71bd6ec49263e6f752fd2", "filename": "libgo/misc/cgo/test/issue4417.go", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4417.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4417.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4417.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 4417:\tcmd/cgo: bool alignment/padding issue.\n+// bool alignment is wrong and causing wrong arguments when calling functions.\n+//\n+\n+package cgotest\n+\n+/*\n+#include <stdbool.h>\n+\n+static int c_bool(bool a, bool b, int c, bool d, bool e)  {\n+   return c;\n+}\n+*/\n+import \"C\"\n+import \"testing\"\n+\n+func testBoolAlign(t *testing.T) {\n+\tb := C.c_bool(true, true, 10, true, false)\n+\tif b != 10 {\n+\t\tt.Fatalf(\"found %d expected 10\\n\", b)\n+\t}\n+\tb = C.c_bool(true, true, 5, true, true)\n+\tif b != 5 {\n+\t\tt.Fatalf(\"found %d expected 5\\n\", b)\n+\t}\n+\tb = C.c_bool(true, true, 3, true, false)\n+\tif b != 3 {\n+\t\tt.Fatalf(\"found %d expected 3\\n\", b)\n+\t}\n+\tb = C.c_bool(false, false, 1, true, false)\n+\tif b != 1 {\n+\t\tt.Fatalf(\"found %d expected 1\\n\", b)\n+\t}\n+\tb = C.c_bool(false, true, 200, true, false)\n+\tif b != 200 {\n+\t\tt.Fatalf(\"found %d expected 200\\n\", b)\n+\t}\n+}"}, {"sha": "b18979b5f7ac86e64931264c28c2d04d69d356aa", "filename": "libgo/misc/cgo/test/issue4857.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4857.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4857.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue4857.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+/*\n+#cgo CFLAGS: -Werror\n+const struct { int a; } *issue4857() { return (void *)0; }\n+*/\n+import \"C\"\n+\n+func test4857() {\n+\t_ = C.issue4857()\n+}"}, {"sha": "53c3bf12d740c8bd84a0ba07bf727b9958b0f3fb", "filename": "libgo/misc/cgo/test/issue5227.go", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5227.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5227.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5227.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 5227: linker incorrectly treats common symbols and\n+// leaves them undefined.\n+\n+package cgotest\n+\n+/*\n+typedef struct {\n+        int Count;\n+} Fontinfo;\n+\n+Fontinfo SansTypeface;\n+\n+extern void init();\n+\n+Fontinfo loadfont() {\n+        Fontinfo f = {0};\n+        return f;\n+}\n+\n+void init() {\n+        SansTypeface = loadfont();\n+}\n+*/\n+import \"C\"\n+\n+import \"testing\"\n+\n+func test5227(t *testing.T) {\n+\tC.init()\n+}\n+\n+func selectfont() C.Fontinfo {\n+\treturn C.SansTypeface\n+}"}, {"sha": "c81cd409199f84cd723e555c36b47d6c6943337e", "filename": "libgo/misc/cgo/test/issue5242.go", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5242.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5242.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5242.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 5242.  Cgo incorrectly computed the alignment of structs\n+// with no Go accessible fields as 0, and then panicked on\n+// modulo-by-zero computations.\n+\n+package cgotest\n+\n+/*\n+typedef struct {\n+} foo;\n+\n+typedef struct {\n+\tint x : 1;\n+} bar;\n+\n+int issue5242(foo f, bar b) {\n+\treturn 5242;\n+}\n+*/\n+import \"C\"\n+\n+import \"testing\"\n+\n+func test5242(t *testing.T) {\n+\tif got := C.issue5242(C.foo{}, C.bar{}); got != 5242 {\n+\t\tt.Errorf(\"got %v\", got)\n+\t}\n+}"}, {"sha": "9041d95168d90928f0f31796ac6a56bccb61df48", "filename": "libgo/misc/cgo/test/issue5337.go", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5337.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5337.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5337.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !windows\n+\n+package cgotest\n+\n+/*\n+#include <signal.h>\n+#include <pthread.h>\n+\n+static void *thread1(void *p) {\n+\t(void)p;\n+\tpthread_kill(pthread_self(), SIGPROF);\n+\treturn NULL;\n+}\n+void test5337() {\n+\tpthread_t tid;\n+\tpthread_create(&tid, 0, thread1, NULL);\n+\tpthread_join(tid, 0);\n+}\n+*/\n+import \"C\"\n+\n+import \"testing\"\n+\n+// Verify that we can withstand SIGPROF received on foreign threads\n+func test5337(t *testing.T) {\n+\tC.test5337()\n+}"}, {"sha": "7b46757700756c6368769b4c5ca8de0a630161f4", "filename": "libgo/misc/cgo/test/issue5337w.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5337w.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5337w.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5337w.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build windows\n+\n+package cgotest\n+\n+import \"testing\"\n+\n+func test5337(t *testing.T) {}"}, {"sha": "0710da795071754d1e2a522425cc6777aac35905", "filename": "libgo/misc/cgo/test/issue5548.go", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5548.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5548.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5548.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+import \"testing\"\n+\n+/*\n+extern int issue5548_in_c(void);\n+*/\n+import \"C\"\n+\n+//export issue5548FromC\n+func issue5548FromC(s string, i int) int {\n+\tif len(s) == 4 && s == \"test\" && i == 42 {\n+\t\treturn 12345\n+\t}\n+\tprintln(\"got\", len(s), i)\n+\treturn 9876\n+}\n+\n+func test5548(t *testing.T) {\n+\tif x := C.issue5548_in_c(); x != 12345 {\n+\t\tt.Errorf(\"issue5548_in_c = %d, want %d\", x, 12345)\n+\t}\n+}"}, {"sha": "84115266ffd545a07ac2c81042295f1b304022b7", "filename": "libgo/misc/cgo/test/issue5548_c.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5548_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5548_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5548_c.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"_cgo_export.h\"\n+\n+static void clobber_stack() {\n+\tvolatile char a[1024];\n+\tint i;\n+\tfor(i = 0; i < sizeof a; i++)\n+\t\ta[i] = 0xff;\n+}\n+\n+static int call_go() {\n+\tGoString s;\n+\ts.p = \"test\";\n+\ts.n = 4;\n+\treturn issue5548FromC(s, 42);\n+}\n+\n+int issue5548_in_c() {\n+\tclobber_stack();\n+\treturn call_go();\n+}"}, {"sha": "ab84339e1016f8e65f5185cf326f311b37d307ed", "filename": "libgo/misc/cgo/test/issue5603.go", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5603.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5603.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5603.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+/*\n+const long long issue5603exp = 0x12345678;\n+long long issue5603foo0() { return issue5603exp; }\n+long long issue5603foo1(void *p) { return issue5603exp; }\n+long long issue5603foo2(void *p, void *q) { return issue5603exp; }\n+long long issue5603foo3(void *p, void *q, void *r) { return issue5603exp; }\n+long long issue5603foo4(void *p, void *q, void *r, void *s) { return issue5603exp; }\n+*/\n+import \"C\"\n+\n+import \"testing\"\n+\n+func test5603(t *testing.T) {\n+\tvar x [5]int64\n+\texp := int64(C.issue5603exp)\n+\tx[0] = int64(C.issue5603foo0())\n+\tx[1] = int64(C.issue5603foo1(nil))\n+\tx[2] = int64(C.issue5603foo2(nil, nil))\n+\tx[3] = int64(C.issue5603foo3(nil, nil, nil))\n+\tx[4] = int64(C.issue5603foo4(nil, nil, nil, nil))\n+\tfor i, v := range x {\n+\t\tif v != exp {\n+\t\t\tt.Errorf(\"issue5603foo%d() returns %v, expected %v\", i, v, exp)\n+\t\t}\n+\t}\n+}"}, {"sha": "059e316119d5c1397a79415fc73cb6050d5e33e2", "filename": "libgo/misc/cgo/test/issue5740.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5740.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5740.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5740.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+// int test5740a(void), test5740b(void);\n+import \"C\"\n+import \"testing\"\n+\n+func test5740(t *testing.T) {\n+\tif v := C.test5740a() + C.test5740b(); v != 5 {\n+\t\tt.Errorf(\"expected 5, got %v\", v)\n+\t}\n+}"}, {"sha": "a6a7d0c96015d998f385814368814c55747fb930", "filename": "libgo/misc/cgo/test/issue5740a.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5740a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5740a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5740a.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,9 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+static int volatile val = 2;\n+\n+int test5740a() {\n+\treturn val;\n+}"}, {"sha": "c2ff5fbc4a545cfdd87fb52de3a30cc70d8ef838", "filename": "libgo/misc/cgo/test/issue5740b.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5740b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5740b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5740b.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,9 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+static int volatile val = 3;\n+\n+int test5740b() {\n+\treturn val;\n+}"}, {"sha": "9be1614233e11a09b966ded2247056bbee5c1ee1", "filename": "libgo/misc/cgo/test/issue5986.go", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5986.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5986.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue5986.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+/*\n+#cgo LDFLAGS: -lm\n+#include <stdio.h>\n+#include <math.h>\n+\n+static void output5986()\n+{\n+    int current_row = 0, row_count = 0;\n+    double sum_squares = 0;\n+    double d;\n+    do {\n+        if (current_row == 10) {\n+            current_row = 0;\n+        }\n+        ++row_count;\n+    }\n+    while (current_row++ != 1);\n+    d =  sqrt(sum_squares / row_count);\n+    printf(\"sqrt is: %g\\n\", d);\n+}\n+*/\n+import \"C\"\n+import \"testing\"\n+\n+func test5986(t *testing.T) {\n+\tC.output5986()\n+}"}, {"sha": "9832d799b94ea0105a5ca9e53086a8fa01a0e66f", "filename": "libgo/misc/cgo/test/issue6128.go", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6128.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6128.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6128.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+// Test handling of #defined names in clang.\n+// golang.org/issue/6128.\n+\n+/*\n+// NOTE: Must use hex, or else a shortcut for decimals\n+// in cgo avoids trying to pass this to clang.\n+#define X 0x1\n+*/\n+import \"C\"\n+\n+func test6128() {\n+\t// nothing to run, just make sure this compiles.\n+\t_ = C.X\n+}"}, {"sha": "5642899c587c566d73a122cdbcd5d3cd60c21535", "filename": "libgo/misc/cgo/test/issue6390.go", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6390.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6390.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6390.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+// #include <stdlib.h>\n+import \"C\"\n+\n+import \"testing\"\n+\n+func test6390(t *testing.T) {\n+\tp1 := C.malloc(1024)\n+\tif p1 == nil {\n+\t\tt.Fatalf(\"C.malloc(1024) returned nil\")\n+\t}\n+\tp2 := C.malloc(0)\n+\tif p2 == nil {\n+\t\tt.Fatalf(\"C.malloc(0) returned nil\")\n+\t}\n+\tC.free(p1)\n+\tC.free(p2)\n+}"}, {"sha": "d416a05e29ddb7b350cabcc59b6a08de2c0aa303", "filename": "libgo/misc/cgo/test/issue6472.go", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6472.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6472.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6472.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+/*\n+typedef struct\n+{\n+        struct\n+        {\n+            int x;\n+        } y[16];\n+} z;\n+*/\n+import \"C\"\n+\n+func test6472() {\n+\t// nothing to run, just make sure this compiles\n+\ts := new(C.z)\n+\tprintln(s.y[0].x)\n+}"}, {"sha": "c54b54b64fc20ac0d987868fb795445d5b04dd6b", "filename": "libgo/misc/cgo/test/issue6506.go", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6506.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6506.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6506.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+// Test handling of size_t in the face of incorrect clang debug information.\n+// golang.org/issue/6506.\n+\n+/*\n+#include <stdlib.h>\n+#include <string.h>\n+*/\n+import \"C\"\n+\n+func test6506() {\n+\t// nothing to run, just make sure this compiles\n+\tvar x C.size_t\n+\n+\tC.calloc(x, x)\n+\tC.malloc(x)\n+\tC.realloc(nil, x)\n+\tC.memcpy(nil, nil, x)\n+\tC.memcmp(nil, nil, x)\n+\tC.memmove(nil, nil, x)\n+\tC.strncpy(nil, nil, x)\n+\tC.strncmp(nil, nil, x)\n+\tC.strncat(nil, nil, x)\n+\tx = C.strxfrm(nil, nil, x)\n+\tC.memchr(nil, 0, x)\n+\tx = C.strcspn(nil, nil)\n+\tx = C.strspn(nil, nil)\n+\tC.memset(nil, 0, x)\n+\tx = C.strlen(nil)\n+\t_ = x\n+}"}, {"sha": "c337f911d90f68b8de958feb3285fb88fa55fdb5", "filename": "libgo/misc/cgo/test/issue6612.go", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6612.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6612.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6612.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,93 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// golang.org/issue/6612\n+// Test new scheme for deciding whether C.name is an expression, type, constant.\n+// Clang silences some warnings when the name is a #defined macro, so test those too\n+// (even though we now use errors exclusively, not warnings).\n+\n+package cgotest\n+\n+/*\n+void myfunc(void) {}\n+int myvar = 5;\n+const char *mytext = \"abcdef\";\n+typedef int mytype;\n+enum {\n+\tmyenum = 1234,\n+};\n+\n+#define myfunc_def myfunc\n+#define myvar_def myvar\n+#define mytext_def mytext\n+#define mytype_def mytype\n+#define myenum_def myenum\n+#define myint_def 12345\n+#define myfloat_def 1.5\n+#define mystring_def \"hello\"\n+*/\n+import \"C\"\n+\n+import \"testing\"\n+\n+func testNaming(t *testing.T) {\n+\tC.myfunc()\n+\tC.myfunc_def()\n+\tif v := C.myvar; v != 5 {\n+\t\tt.Errorf(\"C.myvar = %d, want 5\", v)\n+\t}\n+\tif v := C.myvar_def; v != 5 {\n+\t\tt.Errorf(\"C.myvar_def = %d, want 5\", v)\n+\t}\n+\tif s := C.GoString(C.mytext); s != \"abcdef\" {\n+\t\tt.Errorf(\"C.mytext = %q, want %q\", s, \"abcdef\")\n+\t}\n+\tif s := C.GoString(C.mytext_def); s != \"abcdef\" {\n+\t\tt.Errorf(\"C.mytext_def = %q, want %q\", s, \"abcdef\")\n+\t}\n+\tif c := C.myenum; c != 1234 {\n+\t\tt.Errorf(\"C.myenum = %v, want 1234\", c)\n+\t}\n+\tif c := C.myenum_def; c != 1234 {\n+\t\tt.Errorf(\"C.myenum_def = %v, want 1234\", c)\n+\t}\n+\t{\n+\t\tconst c = C.myenum\n+\t\tif c != 1234 {\n+\t\t\tt.Errorf(\"C.myenum as const = %v, want 1234\", c)\n+\t\t}\n+\t}\n+\t{\n+\t\tconst c = C.myenum_def\n+\t\tif c != 1234 {\n+\t\t\tt.Errorf(\"C.myenum as const = %v, want 1234\", c)\n+\t\t}\n+\t}\n+\tif c := C.myint_def; c != 12345 {\n+\t\tt.Errorf(\"C.myint_def = %v, want 12345\", c)\n+\t}\n+\t{\n+\t\tconst c = C.myint_def\n+\t\tif c != 12345 {\n+\t\t\tt.Errorf(\"C.myint as const = %v, want 12345\", c)\n+\t\t}\n+\t}\n+\n+\t// This would be nice, but it has never worked.\n+\t/*\n+\t\tif c := C.myfloat_def; c != 1.5 {\n+\t\t\tt.Errorf(\"C.myint_def = %v, want 1.5\", c)\n+\t\t}\n+\t\t{\n+\t\t\tconst c = C.myfloat_def\n+\t\t\tif c != 1.5 {\n+\t\t\tt.Errorf(\"C.myint as const = %v, want 1.5\", c)\n+\t\t\t}\n+\t\t}\n+\t*/\n+\n+\tif s := C.mystring_def; s != \"hello\" {\n+\t\tt.Errorf(\"C.mystring_def = %q, want %q\", s, \"hello\")\n+\t}\n+}"}, {"sha": "de60dbfcf2033b267eb5ec2ea06bdb09c35d7c26", "filename": "libgo/misc/cgo/test/issue6833.go", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6833.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6833.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6833.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+/*\n+extern unsigned long long issue6833Func(unsigned int, unsigned long long);\n+*/\n+import \"C\"\n+\n+import \"testing\"\n+\n+//export GoIssue6833Func\n+func GoIssue6833Func(aui uint, aui64 uint64) uint64 {\n+\treturn aui64 + uint64(aui)\n+}\n+\n+func test6833(t *testing.T) {\n+\tui := 7\n+\tull := uint64(0x4000300020001000)\n+\tv := uint64(C.issue6833Func(C.uint(ui), C.ulonglong(ull)))\n+\texp := uint64(ui) + ull\n+\tif v != exp {\n+\t\tt.Errorf(\"issue6833Func() returns %x, expected %x\", v, exp)\n+\t}\n+}"}, {"sha": "c94c2c6d4577a929c82d8d6a8f40e20917400cdc", "filename": "libgo/misc/cgo/test/issue6833_c.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6833_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6833_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6833_c.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,10 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"_cgo_export.h\"\n+ \n+unsigned long long\n+issue6833Func(unsigned int aui, unsigned long long aull) {\n+\treturn GoIssue6833Func(aui, aull);\n+}"}, {"sha": "de803d296e9ee61ef5d981d5cec1c86ec8c91390", "filename": "libgo/misc/cgo/test/issue6997_linux.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6997_linux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6997_linux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6997_linux.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !android\n+\n+#include <pthread.h>\n+#include <stdio.h>\n+#include <unistd.h>\n+\n+static pthread_t thread;\n+\n+static void* threadfunc(void* dummy) {\n+\twhile(1) {\n+\t\tsleep(1);\n+\t}\n+}\n+\n+int StartThread() {\n+\treturn pthread_create(&thread, NULL, &threadfunc, NULL);\n+}\n+\n+int CancelThread() {\n+\tvoid *r;\n+\tpthread_cancel(thread);\n+\tpthread_join(thread, &r);\n+\treturn (r == PTHREAD_CANCELED);\n+}"}, {"sha": "0c98ea0794eec302d134e0855769758c7286ec35", "filename": "libgo/misc/cgo/test/issue6997_linux.go", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6997_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6997_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue6997_linux.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !android\n+\n+// Test that pthread_cancel works as expected\n+// (NPTL uses SIGRTMIN to implement thread cancelation)\n+// See https://golang.org/issue/6997\n+package cgotest\n+\n+/*\n+#cgo CFLAGS: -pthread\n+#cgo LDFLAGS: -pthread\n+extern int StartThread();\n+extern int CancelThread();\n+*/\n+import \"C\"\n+\n+import \"testing\"\n+import \"time\"\n+\n+func test6997(t *testing.T) {\n+\tr := C.StartThread()\n+\tif r != 0 {\n+\t\tt.Error(\"pthread_create failed\")\n+\t}\n+\tc := make(chan C.int)\n+\tgo func() {\n+\t\ttime.Sleep(500 * time.Millisecond)\n+\t\tc <- C.CancelThread()\n+\t}()\n+\n+\tselect {\n+\tcase r = <-c:\n+\t\tif r == 0 {\n+\t\t\tt.Error(\"pthread finished but wasn't canceled??\")\n+\t\t}\n+\tcase <-time.After(30 * time.Second):\n+\t\tt.Error(\"hung in pthread_cancel/pthread_join\")\n+\t}\n+}"}, {"sha": "c191a1a66fe2086c3c5c476c1df0ce78482b87d7", "filename": "libgo/misc/cgo/test/issue7234_test.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue7234_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue7234_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue7234_test.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+import \"testing\"\n+\n+// This test actually doesn't have anything to do with cgo.  It is a\n+// test of https://golang.org/issue/7234, a compiler/linker bug in\n+// handling string constants when using -linkmode=external.  The test\n+// is in this directory because we routinely test -linkmode=external\n+// here.\n+\n+var v7234 = [...]string{\"runtime/cgo\"}\n+\n+func Test7234(t *testing.T) {\n+\tif v7234[0] != \"runtime/cgo\" {\n+\t\tt.Errorf(\"bad string constant %q\", v7234[0])\n+\t}\n+}"}, {"sha": "f36d8a10234549c0b298284e63003eb3279b9f7d", "filename": "libgo/misc/cgo/test/issue7560.go", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue7560.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue7560.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue7560.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+/*\n+#include <stdint.h>\n+\n+typedef struct {\n+\tchar x;\n+\tlong y;\n+} __attribute__((__packed__)) misaligned;\n+\n+int\n+offset7560(void)\n+{\n+\treturn (uintptr_t)&((misaligned*)0)->y;\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"reflect\"\n+\t\"testing\"\n+)\n+\n+func test7560(t *testing.T) {\n+\t// some mingw don't implement __packed__ correctly.\n+\tif C.offset7560() != 1 {\n+\t\tt.Skip(\"C compiler did not pack struct\")\n+\t}\n+\n+\t// C.misaligned should have x but then a padding field to get to the end of the struct.\n+\t// There should not be a field named 'y'.\n+\tvar v C.misaligned\n+\trt := reflect.TypeOf(&v).Elem()\n+\tif rt.NumField() != 2 || rt.Field(0).Name != \"x\" || rt.Field(1).Name != \"_\" {\n+\t\tt.Errorf(\"unexpected fields in C.misaligned:\\n\")\n+\t\tfor i := 0; i < rt.NumField(); i++ {\n+\t\t\tt.Logf(\"%+v\\n\", rt.Field(i))\n+\t\t}\n+\t}\n+}"}, {"sha": "ce0345845f9440f2244301d56992eba906b033af", "filename": "libgo/misc/cgo/test/issue7665.go", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue7665.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue7665.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue7665.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+import (\n+\t\"testing\"\n+\t\"unsafe\"\n+)\n+\n+// extern void f7665(void);\n+import \"C\"\n+\n+//export f7665\n+func f7665() {}\n+\n+var bad7665 unsafe.Pointer = C.f7665\n+var good7665 uintptr = uintptr(C.f7665)\n+\n+func test7665(t *testing.T) {\n+\tif bad7665 == nil || uintptr(bad7665) != good7665 {\n+\t\tt.Errorf(\"ptrs = %p, %#x, want same non-nil pointer\", bad7665, good7665)\n+\t}\n+}"}, {"sha": "1344e9eda62b253f61b9e96e0b57f3cc3d92ebde", "filename": "libgo/misc/cgo/test/issue7786.go", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue7786.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue7786.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue7786.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 7786. No runtime test, just make sure that typedef and struct/union/class are interchangeable at compile time.\n+\n+package cgotest\n+\n+// struct test7786;\n+// typedef struct test7786 typedef_test7786;\n+// void f7786(struct test7786 *ctx) {}\n+// void g7786(typedef_test7786 *ctx) {}\n+//\n+// typedef struct body7786 typedef_body7786;\n+// struct body7786 { int x; };\n+// void b7786(struct body7786 *ctx) {}\n+// void c7786(typedef_body7786 *ctx) {}\n+//\n+// typedef union union7786 typedef_union7786;\n+// void u7786(union union7786 *ctx) {}\n+// void v7786(typedef_union7786 *ctx) {}\n+import \"C\"\n+\n+func f() {\n+\tvar x1 *C.typedef_test7786\n+\tvar x2 *C.struct_test7786\n+\tx1 = x2\n+\tx2 = x1\n+\tC.f7786(x1)\n+\tC.f7786(x2)\n+\tC.g7786(x1)\n+\tC.g7786(x2)\n+\n+\tvar b1 *C.typedef_body7786\n+\tvar b2 *C.struct_body7786\n+\tb1 = b2\n+\tb2 = b1\n+\tC.b7786(b1)\n+\tC.b7786(b2)\n+\tC.c7786(b1)\n+\tC.c7786(b2)\n+\n+\tvar u1 *C.typedef_union7786\n+\tvar u2 *C.union_union7786\n+\tu1 = u2\n+\tu2 = u1\n+\tC.u7786(u1)\n+\tC.u7786(u2)\n+\tC.v7786(u1)\n+\tC.v7786(u2)\n+}"}, {"sha": "7fb62e807ba8cca661794309bb2fb34c50d10743", "filename": "libgo/misc/cgo/test/issue7978.go", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue7978.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue7978.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue7978.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,138 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 7978.  Stack tracing didn't work during cgo code after calling a Go\n+// callback.  Make sure GC works and the stack trace is correct.\n+\n+package cgotest\n+\n+/*\n+#include <stdint.h>\n+\n+void issue7978cb(void);\n+\n+#if defined(__APPLE__) && defined(__arm__)\n+// on Darwin/ARM, libSystem doesn't provide implementation of the __sync_fetch_and_add\n+// primitive, and although gcc supports it, it doesn't inline its definition.\n+// Clang could inline its definition, so we require clang on Darwin/ARM.\n+#if defined(__clang__)\n+#define HAS_SYNC_FETCH_AND_ADD 1\n+#else\n+#define HAS_SYNC_FETCH_AND_ADD 0\n+#endif\n+#else\n+#define HAS_SYNC_FETCH_AND_ADD 1\n+#endif\n+\n+// use ugly atomic variable sync since that doesn't require calling back into\n+// Go code or OS dependencies\n+static void issue7978c(uint32_t *sync) {\n+#if HAS_SYNC_FETCH_AND_ADD\n+\twhile(__sync_fetch_and_add(sync, 0) != 0)\n+\t\t;\n+\t__sync_fetch_and_add(sync, 1);\n+\twhile(__sync_fetch_and_add(sync, 0) != 2)\n+\t\t;\n+\tissue7978cb();\n+\t__sync_fetch_and_add(sync, 1);\n+\twhile(__sync_fetch_and_add(sync, 0) != 6)\n+\t\t;\n+#endif\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"os\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"sync/atomic\"\n+\t\"testing\"\n+)\n+\n+var issue7978sync uint32\n+\n+func issue7978check(t *testing.T, wantFunc string, badFunc string, depth int) {\n+\truntime.GC()\n+\tbuf := make([]byte, 65536)\n+\ttrace := string(buf[:runtime.Stack(buf, true)])\n+\tfor _, goroutine := range strings.Split(trace, \"\\n\\n\") {\n+\t\tif strings.Contains(goroutine, \"test.issue7978go\") {\n+\t\t\ttrace := strings.Split(goroutine, \"\\n\")\n+\t\t\t// look for the expected function in the stack\n+\t\t\tfor i := 0; i < depth; i++ {\n+\t\t\t\tif badFunc != \"\" && strings.Contains(trace[1+2*i], badFunc) {\n+\t\t\t\t\tt.Errorf(\"bad stack: found %s in the stack:\\n%s\", badFunc, goroutine)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tif strings.Contains(trace[1+2*i], wantFunc) {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tt.Errorf(\"bad stack: didn't find %s in the stack:\\n%s\", wantFunc, goroutine)\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tt.Errorf(\"bad stack: goroutine not found. Full stack dump:\\n%s\", trace)\n+}\n+\n+func issue7978wait(store uint32, wait uint32) {\n+\tif store != 0 {\n+\t\tatomic.StoreUint32(&issue7978sync, store)\n+\t}\n+\tfor atomic.LoadUint32(&issue7978sync) != wait {\n+\t\truntime.Gosched()\n+\t}\n+}\n+\n+//export issue7978cb\n+func issue7978cb() {\n+\t// Force a stack growth from the callback to put extra\n+\t// pressure on the runtime. See issue #17785.\n+\tgrowStack(64)\n+\tissue7978wait(3, 4)\n+}\n+\n+func growStack(n int) int {\n+\tvar buf [128]int\n+\tif n == 0 {\n+\t\treturn 0\n+\t}\n+\treturn buf[growStack(n-1)]\n+}\n+\n+func issue7978go() {\n+\tC.issue7978c((*C.uint32_t)(&issue7978sync))\n+\tissue7978wait(7, 8)\n+}\n+\n+func test7978(t *testing.T) {\n+\tif runtime.Compiler == \"gccgo\" {\n+\t\tt.Skip(\"gccgo can not do stack traces of C code\")\n+\t}\n+\tif C.HAS_SYNC_FETCH_AND_ADD == 0 {\n+\t\tt.Skip(\"clang required for __sync_fetch_and_add support on darwin/arm\")\n+\t}\n+\tif runtime.GOOS == \"android\" || runtime.GOOS == \"darwin\" && (runtime.GOARCH == \"arm\" || runtime.GOARCH == \"arm64\") {\n+\t\tt.Skip(\"GOTRACEBACK is not passed on to the exec wrapper\")\n+\t}\n+\tif os.Getenv(\"GOTRACEBACK\") != \"2\" {\n+\t\tt.Fatalf(\"GOTRACEBACK must be 2\")\n+\t}\n+\tissue7978sync = 0\n+\tgo issue7978go()\n+\t// test in c code, before callback\n+\tissue7978wait(0, 1)\n+\tissue7978check(t, \"_Cfunc_issue7978c(\", \"\", 1)\n+\t// test in go code, during callback\n+\tissue7978wait(2, 3)\n+\tissue7978check(t, \"test.issue7978cb(\", \"test.issue7978go\", 3)\n+\t// test in c code, after callback\n+\tissue7978wait(4, 5)\n+\tissue7978check(t, \"_Cfunc_issue7978c(\", \"_cgoexpwrap\", 1)\n+\t// test in go code, after return from cgo\n+\tissue7978wait(6, 7)\n+\tissue7978check(t, \"test.issue7978go(\", \"\", 3)\n+\tatomic.StoreUint32(&issue7978sync, 8)\n+}"}, {"sha": "19123e79cfa2556bc40f5a880756cd5444adf18d", "filename": "libgo/misc/cgo/test/issue8092.go", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8092.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8092.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8092.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 8092. Test that linker defined symbols (e.g., text, data) don't\n+// conflict with C symbols.\n+\n+package cgotest\n+\n+/*\n+char text[] = \"text\";\n+char data[] = \"data\";\n+char *ctext(void) { return text; }\n+char *cdata(void) { return data; }\n+*/\n+import \"C\"\n+\n+import \"testing\"\n+\n+func test8092(t *testing.T) {\n+\ttests := []struct {\n+\t\ts    string\n+\t\ta, b *C.char\n+\t}{\n+\t\t{\"text\", &C.text[0], C.ctext()},\n+\t\t{\"data\", &C.data[0], C.cdata()},\n+\t}\n+\tfor _, test := range tests {\n+\t\tif test.a != test.b {\n+\t\t\tt.Errorf(\"%s: pointer mismatch: %v != %v\", test.s, test.a, test.b)\n+\t\t}\n+\t\tif got := C.GoString(test.a); got != test.s {\n+\t\t\tt.Errorf(\"%s: points at %#v, want %#v\", test.s, got, test.s)\n+\t\t}\n+\t}\n+}"}, {"sha": "f704788aef8a45da1d8d195f8c478ee7d617f3e5", "filename": "libgo/misc/cgo/test/issue8148.go", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8148.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8148.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8148.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 8148.  A typedef of an unnamed struct didn't work when used\n+// with an exported Go function.  No runtime test; just make sure it\n+// compiles.\n+\n+package cgotest\n+\n+/*\n+typedef struct { int i; } T;\n+\n+int issue8148Callback(T*);\n+\n+static int get() {\n+\tT t;\n+\tt.i = 42;\n+\treturn issue8148Callback(&t);\n+}\n+*/\n+import \"C\"\n+\n+//export issue8148Callback\n+func issue8148Callback(t *C.T) C.int {\n+\treturn t.i\n+}\n+\n+func Issue8148() int {\n+\treturn int(C.get())\n+}"}, {"sha": "8065be08904de3bcba1f732d0aefed4a67ce71b3", "filename": "libgo/misc/cgo/test/issue8331.h", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8331.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8331.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8331.h?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,7 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+typedef struct {\n+\tint i;\n+} issue8331;"}, {"sha": "92e2579e7ae12ade315a490624b4c121ba8bbd01", "filename": "libgo/misc/cgo/test/issue8331a.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8331a.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8331a.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8331a.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 8331.  A typedef of an unnamed struct is the same struct when\n+// #include'd twice.  No runtime test; just make sure it compiles.\n+\n+package cgotest\n+\n+// #include \"issue8331.h\"\n+import \"C\"\n+\n+func issue8331a() C.issue8331 {\n+\treturn issue8331Var\n+}"}, {"sha": "5324aa2a175f0a16a2b27bae697dc0389dee2c88", "filename": "libgo/misc/cgo/test/issue8331b.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8331b.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8331b.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8331b.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 8331.  A typedef of an unnamed struct is the same struct when\n+// #include'd twice.  No runtime test; just make sure it compiles.\n+\n+package cgotest\n+\n+// #include \"issue8331.h\"\n+import \"C\"\n+\n+var issue8331Var C.issue8331"}, {"sha": "2e5a555b5823bee6e0981ca2e65d74a81cbd9cc5", "filename": "libgo/misc/cgo/test/issue8428.go", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8428.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8428.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8428.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This test fails on older versions of OS X because they use older buggy\n+// versions of Clang that emit ambiguous DWARF info.  See issue 8611.\n+// +build !darwin\n+\n+package cgotest\n+\n+// Issue 8428.  Cgo inconsistently translated zero size arrays.\n+\n+/*\n+struct issue8428one {\n+\tchar b;\n+\tchar rest[];\n+};\n+\n+struct issue8428two {\n+\tvoid *p;\n+\tchar b;\n+\tchar rest[0];\n+\tchar pad;\n+};\n+\n+struct issue8428three {\n+\tchar w[1][2][3][0];\n+\tchar x[2][3][0][1];\n+\tchar y[3][0][1][2];\n+\tchar z[0][1][2][3];\n+};\n+*/\n+import \"C\"\n+\n+import \"unsafe\"\n+\n+var _ = C.struct_issue8428one{\n+\tb: C.char(0),\n+\t// The trailing rest field is not available in cgo.\n+\t// See issue 11925.\n+\t// rest: [0]C.char{},\n+}\n+\n+var _ = C.struct_issue8428two{\n+\tp:    unsafe.Pointer(nil),\n+\tb:    C.char(0),\n+\trest: [0]C.char{},\n+}\n+\n+var _ = C.struct_issue8428three{\n+\tw: [1][2][3][0]C.char{},\n+\tx: [2][3][0][1]C.char{},\n+\ty: [3][0][1][2]C.char{},\n+\tz: [0][1][2][3]C.char{},\n+}"}, {"sha": "4489ca9eb677ca7e8265a3e2727616134de229dc", "filename": "libgo/misc/cgo/test/issue8441.go", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8441.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8441.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8441.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 8368 and 8441.  Recursive struct definitions didn't work.\n+// No runtime test; just make sure it compiles.\n+\n+package cgotest\n+\n+/*\n+typedef struct one one;\n+typedef struct two two;\n+struct one {\n+\ttwo *x;\n+};\n+struct two {\n+\tone *x;\n+};\n+*/\n+import \"C\"\n+\n+func issue8368(one *C.struct_one, two *C.struct_two) {\n+}\n+\n+func issue8441(one *C.one, two *C.two) {\n+\tissue8441(two.x, one.x)\n+}"}, {"sha": "4e431df921d1e33d4ca79faf9ea26e302a4aa6d9", "filename": "libgo/misc/cgo/test/issue8517.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8517.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8517.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8517.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !windows\n+\n+package cgotest\n+\n+import \"testing\"\n+\n+func test8517(t *testing.T) {\n+\tt.Skip(\"skipping windows only test\")\n+}"}, {"sha": "a0b94c126f6330ed2fa5915b69e88a12d12d2872", "filename": "libgo/misc/cgo/test/issue8517_windows.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8517_windows.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8517_windows.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8517_windows.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"windows.h\"\n+\n+extern void testHandleLeaksCallback();\n+\n+DWORD WINAPI testHandleLeaksFunc(LPVOID lpThreadParameter)\n+{\n+\tint i;\n+\tfor(i = 0; i < 100; i++) {\n+\t\ttestHandleLeaksCallback();\n+\t}\n+\treturn 0;\n+}\n+\n+void testHandleLeaks()\n+{\n+\tHANDLE h;\n+\th = CreateThread(NULL, 0, &testHandleLeaksFunc, 0, 0, NULL);\n+\tWaitForSingleObject(h, INFINITE);\n+\tCloseHandle(h);\n+}"}, {"sha": "3782631e91b46488115fec94bdbcd4e8bc73e9f1", "filename": "libgo/misc/cgo/test/issue8517_windows.go", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8517_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8517_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8517_windows.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+//void testHandleLeaks();\n+import \"C\"\n+\n+import (\n+\t\"syscall\"\n+\t\"testing\"\n+\t\"unsafe\"\n+)\n+\n+var issue8517counter int\n+\n+var (\n+\tkernel32              = syscall.MustLoadDLL(\"kernel32.dll\")\n+\tgetProcessHandleCount = kernel32.MustFindProc(\"GetProcessHandleCount\")\n+)\n+\n+func processHandleCount(t *testing.T) int {\n+\tconst current_process = ^uintptr(0)\n+\tvar c uint32\n+\tr, _, err := getProcessHandleCount.Call(current_process, uintptr(unsafe.Pointer(&c)))\n+\tif r == 0 {\n+\t\tt.Fatal(err)\n+\t}\n+\treturn int(c)\n+}\n+\n+func test8517(t *testing.T) {\n+\tc1 := processHandleCount(t)\n+\tC.testHandleLeaks()\n+\tc2 := processHandleCount(t)\n+\tif c1+issue8517counter <= c2 {\n+\t\tt.Fatalf(\"too many handles leaked: issue8517counter=%v c1=%v c2=%v\", issue8517counter, c1, c2)\n+\t}\n+}\n+\n+//export testHandleLeaksCallback\n+func testHandleLeaksCallback() {\n+\tissue8517counter++\n+}"}, {"sha": "89be7ea090763a909e810bbcff1ebf4a67da6986", "filename": "libgo/misc/cgo/test/issue8694.go", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8694.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8694.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8694.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !android\n+\n+package cgotest\n+\n+/*\n+#include <complex.h>\n+\n+complex float complexFloatSquared(complex float a) { return a*a; }\n+complex double complexDoubleSquared(complex double a) { return a*a; }\n+*/\n+import \"C\"\n+\n+import (\n+\t\"runtime\"\n+\t\"testing\"\n+)\n+\n+func test8694(t *testing.T) {\n+\tif runtime.GOARCH == \"arm\" {\n+\t\tt.Skip(\"test8694 is disabled on ARM because 5l cannot handle thumb library.\")\n+\t}\n+\t// Really just testing that this compiles, but check answer anyway.\n+\tx := C.complexfloat(2 + 3i)\n+\tx2 := x * x\n+\tcx2 := C.complexFloatSquared(x)\n+\tif cx2 != x2 {\n+\t\tt.Errorf(\"C.complexFloatSquared(%v) = %v, want %v\", x, cx2, x2)\n+\t}\n+\n+\ty := C.complexdouble(2 + 3i)\n+\ty2 := y * y\n+\tcy2 := C.complexDoubleSquared(y)\n+\tif cy2 != y2 {\n+\t\tt.Errorf(\"C.complexDoubleSquared(%v) = %v, want %v\", y, cy2, y2)\n+\t}\n+}"}, {"sha": "d8ee3b8213d9d47434294b6be5cee5f23d7b1ed1", "filename": "libgo/misc/cgo/test/issue8756.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8756.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8756.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8756.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,17 @@\n+package cgotest\n+\n+/*\n+#cgo LDFLAGS: -lm\n+#include <math.h>\n+*/\n+import \"C\"\n+import (\n+\t\"testing\"\n+\n+\t\"./issue8756\"\n+)\n+\n+func test8756(t *testing.T) {\n+\tissue8756.Pow()\n+\tC.pow(1, 2)\n+}"}, {"sha": "5f6b7778ff6e234f15cdaa7ae40fcbfd64d4b182", "filename": "libgo/misc/cgo/test/issue8756/issue8756.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8756%2Fissue8756.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8756%2Fissue8756.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8756%2Fissue8756.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,11 @@\n+package issue8756\n+\n+/*\n+#cgo LDFLAGS: -lm\n+#include <math.h>\n+*/\n+import \"C\"\n+\n+func Pow() {\n+\tC.pow(1, 2)\n+}"}, {"sha": "41b3c7c8ea3e62e9005f976273e3fed287a64fc2", "filename": "libgo/misc/cgo/test/issue8811.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8811.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8811.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8811.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,8 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+int issue8811Initialized = 0;\n+\n+void issue8811Init() {\n+}"}, {"sha": "f812732cfd7aa657a60e8c3b7276e54e2b09017a", "filename": "libgo/misc/cgo/test/issue8811.go", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8811.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8811.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8811.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotest\n+\n+/*\n+extern int issue8811Initialized;\n+extern void issue8811Init();\n+\n+void issue8811Execute() {\n+\tif(!issue8811Initialized)\n+\t\tissue8811Init();\n+}\n+*/\n+import \"C\"\n+\n+import \"testing\"\n+\n+func test8811(t *testing.T) {\n+\tC.issue8811Execute()\n+}"}, {"sha": "304797c929cc5019a37d505bf8bb349a377b9962", "filename": "libgo/misc/cgo/test/issue8828.go", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8828.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8828.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8828.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,16 @@\n+// compile\n+\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 8828: compiling a file with -compiler=gccgo fails if a .c file\n+// has the same name as compiled directory.\n+\n+package cgotest\n+\n+import \"./issue8828\"\n+\n+func p() {\n+\tissue8828.Bar()\n+}"}, {"sha": "27ec23a26059f48a2774dec01a5dff8b61a95a0d", "filename": "libgo/misc/cgo/test/issue8828/issue8828.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8828%2Fissue8828.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8828%2Fissue8828.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8828%2Fissue8828.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,7 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+void foo()\n+{\n+}"}, {"sha": "e7b9a4e573dc0935f09e5a8bd065f9f0b32edcfd", "filename": "libgo/misc/cgo/test/issue8828/trivial.go", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8828%2Ftrivial.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8828%2Ftrivial.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8828%2Ftrivial.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,8 @@\n+package issue8828\n+\n+//void foo();\n+import \"C\"\n+\n+func Bar() {\n+\tC.foo()\n+}"}, {"sha": "57a5b2db44bbbb6cd1d7cbbf5c2abf4cd76dcfae", "filename": "libgo/misc/cgo/test/issue8945.go", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8945.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8945.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue8945.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build gccgo\n+\n+package cgotest\n+\n+//typedef void (*PFunc)();\n+//PFunc success_cb;\n+import \"C\"\n+\n+//export Test\n+func Test() {\n+\t_ = C.success_cb\n+}"}, {"sha": "8848d0e811818e690d64a127d04b2dd6510a1a97", "filename": "libgo/misc/cgo/test/issue9026.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9026.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9026.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9026.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,9 @@\n+package cgotest\n+\n+import (\n+\t\"testing\"\n+\n+\t\"./issue9026\"\n+)\n+\n+func test9026(t *testing.T) { issue9026.Test(t) }"}, {"sha": "0af86e64da487a44bc342f8c3bfd1aeea8d465fb", "filename": "libgo/misc/cgo/test/issue9026/issue9026.go", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9026%2Fissue9026.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9026%2Fissue9026.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9026%2Fissue9026.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,36 @@\n+package issue9026\n+\n+// This file appears in its own package since the assertion tests the\n+// per-package counter used to create fresh identifiers.\n+\n+/*\n+typedef struct {} git_merge_file_input;\n+\n+typedef struct {} git_merge_file_options;\n+\n+void git_merge_file(\n+        git_merge_file_input *in,\n+        git_merge_file_options *opts) {}\n+*/\n+import \"C\"\n+import (\n+\t\"fmt\"\n+\t\"testing\"\n+)\n+\n+func Test(t *testing.T) {\n+\tvar in C.git_merge_file_input\n+\tvar opts *C.git_merge_file_options\n+\tC.git_merge_file(&in, opts)\n+\n+\t// Test that the generated type names are deterministic.\n+\t// (Previously this would fail about 10% of the time.)\n+\t//\n+\t// Brittle: the assertion may fail spuriously when the algorithm\n+\t// changes, but should remain stable otherwise.\n+\tgot := fmt.Sprintf(\"%T %T\", in, opts)\n+\twant := \"issue9026._Ctype_struct___0 *issue9026._Ctype_struct___1\"\n+\tif got != want {\n+\t\tt.Errorf(\"Non-deterministic type names: got %s, want %s\", got, want)\n+\t}\n+}"}, {"sha": "7f158b5c39d8d299d4fbfbcac465ad71efb30fd9", "filename": "libgo/misc/cgo/test/issue9400/asm_386.s", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_386.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_386.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_386.s?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !gccgo\n+\n+#include \"textflag.h\"\n+\n+TEXT \u00b7RewindAndSetgid(SB),NOSPLIT,$0-0\n+\tMOVL\t$\u00b7Baton(SB), BX\n+\t// Rewind stack pointer so anything that happens on the stack\n+\t// will clobber the test pattern created by the caller\n+\tADDL\t$(1024 * 8), SP\n+\n+\t// Ask signaller to setgid\n+\tMOVL\t$1, (BX)\n+\n+\t// Wait for setgid completion\n+loop:\n+\tPAUSE\n+\tMOVL\t(BX), AX\n+\tCMPL\tAX, $0\n+\tJNE\tloop\n+\n+\t// Restore stack\n+\tSUBL\t$(1024 * 8), SP\n+\tRET"}, {"sha": "48b86190a59fc6378b8a7dda8a644c1da4a52414", "filename": "libgo/misc/cgo/test/issue9400/asm_amd64x.s", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_amd64x.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_amd64x.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_amd64x.s?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build amd64 amd64p32\n+// +build !gccgo\n+\n+#include \"textflag.h\"\n+\n+TEXT \u00b7RewindAndSetgid(SB),NOSPLIT,$0-0\n+\t// Rewind stack pointer so anything that happens on the stack\n+\t// will clobber the test pattern created by the caller\n+\tADDQ\t$(1024 * 8), SP\n+\n+\t// Ask signaller to setgid\n+\tMOVL\t$1, \u00b7Baton(SB)\n+\n+\t// Wait for setgid completion\n+loop:\n+\tPAUSE\n+\tMOVL\t\u00b7Baton(SB), AX\n+\tCMPL\tAX, $0\n+\tJNE\tloop\n+\n+\t// Restore stack\n+\tSUBQ\t$(1024 * 8), SP\n+\tRET"}, {"sha": "166d53f304e404e435342ab170f57a45787120fd", "filename": "libgo/misc/cgo/test/issue9400/asm_arm.s", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_arm.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_arm.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_arm.s?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !gccgo\n+\n+#include \"textflag.h\"\n+\n+TEXT cas<>(SB),NOSPLIT,$0\n+\tMOVW\t$0xffff0fc0, R15 // R15 is PC\n+\n+TEXT \u00b7RewindAndSetgid(SB),NOSPLIT,$-4-0\n+\t// Save link register\n+\tMOVW\tR14, R4\n+\n+\t// Rewind stack pointer so anything that happens on the stack\n+\t// will clobber the test pattern created by the caller\n+\tADD\t$(1024 * 8), R13\n+\n+\t// Ask signaller to setgid\n+\tMOVW\t$\u00b7Baton(SB), R2\n+storeloop:\n+\tMOVW\t0(R2), R0\n+\tMOVW\t$1, R1\n+\tBL\tcas<>(SB)\n+\tBCC\tstoreloop\n+\n+\t// Wait for setgid completion\n+loop:\n+\tMOVW\t$0, R0\n+\tMOVW\t$0, R1\n+\tBL\tcas<>(SB)\n+\tBCC\tloop\n+\n+\t// Restore stack\n+\tSUB\t$(1024 * 8), R13\n+\n+\tMOVW\tR4, R14\n+\tRET"}, {"sha": "9bb50816b4474b96f278838a54a9caf239d1b761", "filename": "libgo/misc/cgo/test/issue9400/asm_arm64.s", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_arm64.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_arm64.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_arm64.s?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !gccgo\n+\n+#include \"textflag.h\"\n+\n+TEXT \u00b7RewindAndSetgid(SB),NOSPLIT,$-8-0\n+\t// Save link register\n+\tMOVD\tR30, R9\n+\n+\t// Rewind stack pointer so anything that happens on the stack\n+\t// will clobber the test pattern created by the caller\n+\tADD\t$(1024 * 8), RSP\n+\n+\t// Ask signaller to setgid\n+\tMOVD\t$\u00b7Baton(SB), R0\n+\tMOVD\t$1, R1\n+storeloop:\n+\tLDAXRW\t(R0), R2\n+\tSTLXRW\tR1, (R0), R3\n+\tCBNZ\tR3, storeloop\n+\n+\t// Wait for setgid completion\n+\tMOVW\t$0, R1\n+\tMOVW\t$0, R2\n+loop:\n+\tLDAXRW\t(R0), R3\n+\tCMPW\tR1, R3\n+\tBNE\tloop\n+\tSTLXRW\tR2, (R0), R3\n+\tCBNZ\tR3, loop\n+\n+\t// Restore stack\n+\tSUB\t$(1024 * 8), RSP\n+\n+\tMOVD\tR9, R30\n+\tRET"}, {"sha": "63dc90605e6f8edf4f5d42150283efe2fad66ed1", "filename": "libgo/misc/cgo/test/issue9400/asm_mips64x.s", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_mips64x.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_mips64x.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_mips64x.s?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2016 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build mips64 mips64le\n+// +build !gccgo\n+\n+#include \"textflag.h\"\n+\n+#define SYNC\tWORD $0xf\n+\n+TEXT \u00b7RewindAndSetgid(SB),NOSPLIT|NOFRAME,$0-0\n+\t// Rewind stack pointer so anything that happens on the stack\n+\t// will clobber the test pattern created by the caller\n+\tADDV\t$(1024*8), R29\n+\n+\t// Ask signaller to setgid\n+\tMOVW\t$1, R1\n+\tSYNC\n+\tMOVW\tR1, \u00b7Baton(SB)\n+\tSYNC\n+\n+\t// Wait for setgid completion\n+loop:\n+\tSYNC\n+\tMOVW\t\u00b7Baton(SB), R1\n+\tOR\tR2, R2, R2\t// hint that we're in a spin loop\n+\tBNE\tR1, loop\n+\tSYNC\n+\n+\t// Restore stack\n+\tADDV\t$(-1024*8), R29\n+\tRET"}, {"sha": "ddf33e9f8e570553b88746d3759c4f0eeed35908", "filename": "libgo/misc/cgo/test/issue9400/asm_mipsx.s", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_mipsx.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_mipsx.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_mipsx.s?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build mips mipsle\n+// +build !gccgo\n+\n+#include \"textflag.h\"\n+\n+TEXT \u00b7RewindAndSetgid(SB),NOSPLIT,$-4-0\n+\t// Rewind stack pointer so anything that happens on the stack\n+\t// will clobber the test pattern created by the caller\n+\tADDU\t$(1024*8), R29\n+\n+\t// Ask signaller to setgid\n+\tMOVW\t$1, R1\n+\tSYNC\n+\tMOVW\tR1, \u00b7Baton(SB)\n+\tSYNC\n+\n+\t// Wait for setgid completion\n+loop:\n+\tSYNC\n+\tMOVW\t\u00b7Baton(SB), R1\n+\tOR\tR2, R2, R2\t// hint that we're in a spin loop\n+\tBNE\tR1, loop\n+\tSYNC\n+\n+\t// Restore stack\n+\tADDU\t$(-1024*8), R29\n+\tRET"}, {"sha": "c88ec3b21e76517d9ec44d0a0b5fe0f236a41d52", "filename": "libgo/misc/cgo/test/issue9400/asm_ppc64x.s", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_ppc64x.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_ppc64x.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_ppc64x.s?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ppc64 ppc64le\n+// +build !gccgo\n+\n+#include \"textflag.h\"\n+\n+TEXT \u00b7RewindAndSetgid(SB),NOSPLIT|NOFRAME,$0-0\n+\t// Rewind stack pointer so anything that happens on the stack\n+\t// will clobber the test pattern created by the caller\n+\tADD\t$(1024 * 8), R1\n+\n+\t// Ask signaller to setgid\n+\tMOVW\t$1, R3\n+\tSYNC\n+\tMOVW\tR3, \u00b7Baton(SB)\n+\n+\t// Wait for setgid completion\n+loop:\n+\tSYNC\n+\tMOVW\t\u00b7Baton(SB), R3\n+\tCMP\tR3, $0\n+\t// Hint that we're in a spin loop\n+\tOR\tR1, R1, R1\n+\tBNE\tloop\n+\tISYNC\n+\n+\t// Restore stack\n+\tSUB\t$(1024 * 8), R1\n+\tRET"}, {"sha": "fc9ad724c15fc11b4544b7fb06cf9c0e68ae30bd", "filename": "libgo/misc/cgo/test/issue9400/asm_s390x.s", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_s390x.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_s390x.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fasm_s390x.s?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !gccgo\n+\n+#include \"textflag.h\"\n+\n+TEXT \u00b7RewindAndSetgid(SB),NOSPLIT,$0-0\n+\t// Rewind stack pointer so anything that happens on the stack\n+\t// will clobber the test pattern created by the caller\n+\tADD\t$(1024 * 8), R15\n+\n+\t// Ask signaller to setgid\n+\tMOVD\t$\u00b7Baton(SB), R5\n+\tMOVW\t$1, 0(R5)\n+\n+\t// Wait for setgid completion\n+loop:\n+\tSYNC\n+\tMOVW\t\u00b7Baton(SB), R3\n+\tCMPBNE\tR3, $0, loop\n+\n+\t// Restore stack\n+\tSUB\t$(1024 * 8), R15\n+\tRET"}, {"sha": "0ef3a8cacf3a3b34da2cb41bdab9f91f7c337e25", "filename": "libgo/misc/cgo/test/issue9400/gccgo.go", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fgccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fgccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fgccgo.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build gccgo\n+\n+package issue9400\n+\n+import (\n+\t\"runtime\"\n+\t\"sync/atomic\"\n+)\n+\n+// The test for the gc compiler resets the stack pointer so that the\n+// stack gets modified.  We don't have a way to do that for gccgo\n+// without writing more assembly code, which we haven't bothered to\n+// do.  So this is not much of a test.\n+\n+func RewindAndSetgid() {\n+\tatomic.StoreInt32(&Baton, 1)\n+\tfor atomic.LoadInt32(&Baton) != 0 {\n+\t\truntime.Gosched()\n+\t}\n+}"}, {"sha": "60193dc4117bdf31d1959fe83c3cebcaf393d24d", "filename": "libgo/misc/cgo/test/issue9400/stubs.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400%2Fstubs.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,9 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package issue9400\n+\n+var Baton int32\n+\n+func RewindAndSetgid()"}, {"sha": "34eb4983a4161c9a708a8a0fb2b12591f29af50f", "filename": "libgo/misc/cgo/test/issue9400_linux.go", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9400_linux.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test that SIGSETXID runs on signal stack, since it's likely to\n+// overflow if it runs on the Go stack.\n+\n+package cgotest\n+\n+/*\n+#include <sys/types.h>\n+#include <unistd.h>\n+*/\n+import \"C\"\n+\n+import (\n+\t\"runtime\"\n+\t\"sync/atomic\"\n+\t\"testing\"\n+\n+\t\"./issue9400\"\n+)\n+\n+func test9400(t *testing.T) {\n+\t// We synchronize through a shared variable, so we need two procs\n+\tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(2))\n+\n+\t// Start signaller\n+\tatomic.StoreInt32(&issue9400.Baton, 0)\n+\tgo func() {\n+\t\t// Wait for RewindAndSetgid\n+\t\tfor atomic.LoadInt32(&issue9400.Baton) == 0 {\n+\t\t\truntime.Gosched()\n+\t\t}\n+\t\t// Broadcast SIGSETXID\n+\t\truntime.LockOSThread()\n+\t\tC.setgid(0)\n+\t\t// Indicate that signalling is done\n+\t\tatomic.StoreInt32(&issue9400.Baton, 0)\n+\t}()\n+\n+\t// Grow the stack and put down a test pattern\n+\tconst pattern = 0x123456789abcdef\n+\tvar big [1024]uint64 // len must match assmebly\n+\tfor i := range big {\n+\t\tbig[i] = pattern\n+\t}\n+\n+\t// Temporarily rewind the stack and trigger SIGSETXID\n+\tissue9400.RewindAndSetgid()\n+\n+\t// Check test pattern\n+\tfor i := range big {\n+\t\tif big[i] != pattern {\n+\t\t\tt.Fatalf(\"entry %d of test pattern is wrong; %#x != %#x\", i, big[i], uint64(pattern))\n+\t\t}\n+\t}\n+}"}, {"sha": "efd3f770b6af124c97f69f72cce3bf7c4dfd475b", "filename": "libgo/misc/cgo/test/issue9510.go", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9510.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9510.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9510.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test that we can link together two different cgo packages that both\n+// use the same libgcc function.\n+\n+package cgotest\n+\n+import (\n+\t\"runtime\"\n+\t\"testing\"\n+\n+\t\"./issue9510a\"\n+\t\"./issue9510b\"\n+)\n+\n+func test9510(t *testing.T) {\n+\tif runtime.GOARCH == \"arm\" {\n+\t\tt.Skip(\"skipping because libgcc may be a Thumb library\")\n+\t}\n+\tissue9510a.F(1, 1)\n+\tissue9510b.F(1, 1)\n+}"}, {"sha": "1a5224b8c6882a7156deaebbaa1cad834fbbd0cf", "filename": "libgo/misc/cgo/test/issue9510a/a.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9510a%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9510a%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9510a%2Fa.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,15 @@\n+package issue9510a\n+\n+/*\n+static double csquare(double a, double b) {\n+\t__complex__ double d;\n+\t__real__ d = a;\n+\t__imag__ d = b;\n+\treturn __real__ (d * d);\n+}\n+*/\n+import \"C\"\n+\n+func F(a, b float64) float64 {\n+\treturn float64(C.csquare(C.double(a), C.double(b)))\n+}"}, {"sha": "5016b39597e13439c7e800df0727467eee18eccb", "filename": "libgo/misc/cgo/test/issue9510b/b.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9510b%2Fb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9510b%2Fb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9510b%2Fb.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,15 @@\n+package issue9510b\n+\n+/*\n+static double csquare(double a, double b) {\n+\t__complex__ double d;\n+\t__real__ d = a;\n+\t__imag__ d = b;\n+\treturn __real__ (d * d);\n+}\n+*/\n+import \"C\"\n+\n+func F(a, b float64) float64 {\n+\treturn float64(C.csquare(C.double(a), C.double(b)))\n+}"}, {"sha": "4e8922a69c60c88caf6468fa291ffae72dc1d01c", "filename": "libgo/misc/cgo/test/issue9557.go", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9557.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9557.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue9557.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// cgo rewrote C.var to *_Cvar_var, but left\n+// C.var.field as _Cvar.var.field.  It now rewrites\n+// the latter as (*_Cvar_var).field.\n+// See https://golang.org/issue/9557.\n+\n+package cgotest\n+\n+// struct issue9557_t {\n+//   int a;\n+// } test9557bar = { 42 };\n+//\n+// struct issue9557_t *issue9557foo = &test9557bar;\n+import \"C\"\n+import \"testing\"\n+\n+func test9557(t *testing.T) {\n+\t// implicitly dereference a Go variable\n+\tfoo := C.issue9557foo\n+\tif v := foo.a; v != 42 {\n+\t\tt.Fatalf(\"foo.a expected 42, but got %d\", v)\n+\t}\n+\n+\t// explicitly dereference a C variable\n+\tif v := (*C.issue9557foo).a; v != 42 {\n+\t\tt.Fatalf(\"(*C.issue9557foo).a expected 42, but is %d\", v)\n+\t}\n+\n+\t// implicitly dereference a C variable\n+\tif v := C.issue9557foo.a; v != 42 {\n+\t\tt.Fatalf(\"C.issue9557foo.a expected 42, but is %d\", v)\n+\t}\n+}"}, {"sha": "6773f94d3d6816c6cbdab8e827e22a908b70ef18", "filename": "libgo/misc/cgo/test/setgid_linux.go", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fsetgid_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fsetgid_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fsetgid_linux.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test that setgid does not hang on GNU/Linux.\n+// See https://golang.org/issue/3871 for details.\n+\n+package cgotest\n+\n+/*\n+#include <sys/types.h>\n+#include <unistd.h>\n+*/\n+import \"C\"\n+\n+import (\n+\t\"os\"\n+\t\"os/signal\"\n+\t\"syscall\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func runTestSetgid() bool {\n+\tc := make(chan bool)\n+\tgo func() {\n+\t\tC.setgid(0)\n+\t\tc <- true\n+\t}()\n+\tselect {\n+\tcase <-c:\n+\t\treturn true\n+\tcase <-time.After(5 * time.Second):\n+\t\treturn false\n+\t}\n+\n+}\n+\n+func testSetgid(t *testing.T) {\n+\tif !runTestSetgid() {\n+\t\tt.Error(\"setgid hung\")\n+\t}\n+\n+\t// Now try it again after using signal.Notify.\n+\tsignal.Notify(make(chan os.Signal, 1), syscall.SIGINT)\n+\tif !runTestSetgid() {\n+\t\tt.Error(\"setgid hung after signal.Notify\")\n+\t}\n+}"}, {"sha": "2b7a1ec9ad0a01e0dcb34f37ca756afbc94011c3", "filename": "libgo/misc/cgo/test/sigaltstack.go", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fsigaltstack.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fsigaltstack.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fsigaltstack.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !windows,!android\n+\n+// Test that the Go runtime still works if C code changes the signal stack.\n+\n+package cgotest\n+\n+/*\n+#include <signal.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+static stack_t oss;\n+static char signalStack[SIGSTKSZ];\n+\n+static void changeSignalStack(void) {\n+\tstack_t ss;\n+\tmemset(&ss, 0, sizeof ss);\n+\tss.ss_sp = signalStack;\n+\tss.ss_flags = 0;\n+\tss.ss_size = SIGSTKSZ;\n+\tif (sigaltstack(&ss, &oss) < 0) {\n+\t\tperror(\"sigaltstack\");\n+\t\tabort();\n+\t}\n+}\n+\n+static void restoreSignalStack(void) {\n+#if (defined(__x86_64__) || defined(__i386__)) && defined(__APPLE__)\n+\t// The Darwin C library enforces a minimum that the kernel does not.\n+\t// This is OK since we allocated this much space in mpreinit,\n+\t// it was just removed from the buffer by stackalloc.\n+\toss.ss_size = MINSIGSTKSZ;\n+#endif\n+\tif (sigaltstack(&oss, NULL) < 0) {\n+\t\tperror(\"sigaltstack restore\");\n+\t\tabort();\n+\t}\n+}\n+\n+static int zero(void) {\n+\treturn 0;\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"runtime\"\n+\t\"testing\"\n+)\n+\n+func testSigaltstack(t *testing.T) {\n+\tswitch {\n+\tcase runtime.GOOS == \"solaris\", runtime.GOOS == \"darwin\" && (runtime.GOARCH == \"arm\" || runtime.GOARCH == \"arm64\"):\n+\t\tt.Skipf(\"switching signal stack not implemented on %s/%s\", runtime.GOOS, runtime.GOARCH)\n+\tcase runtime.GOOS == \"darwin\" && runtime.GOARCH == \"386\":\n+\t\tt.Skipf(\"sigaltstack fails on darwin/386\")\n+\t}\n+\n+\tC.changeSignalStack()\n+\tdefer C.restoreSignalStack()\n+\tdefer func() {\n+\t\tif recover() == nil {\n+\t\t\tt.Error(\"did not see expected panic\")\n+\t\t}\n+\t}()\n+\tv := 1 / int(C.zero())\n+\tt.Errorf(\"unexpected success of division by zero == %d\", v)\n+}"}, {"sha": "bd99647d2b386476eedb996430b29d6fa79a1b96", "filename": "libgo/misc/cgo/test/sigprocmask.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fsigprocmask.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fsigprocmask.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fsigprocmask.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !windows\n+\n+#include <signal.h>\n+#include <stdlib.h>\n+#include <pthread.h>\n+#include <stdio.h>\n+#include <unistd.h>\n+\n+extern void IntoGoAndBack();\n+\n+int CheckBlocked() {\n+\tsigset_t mask;\n+\tsigprocmask(SIG_BLOCK, NULL, &mask);\n+\treturn sigismember(&mask, SIGIO);\n+}\n+\n+static void* sigthreadfunc(void* unused) {\n+\tsigset_t mask;\n+\tsigemptyset(&mask);\n+\tsigaddset(&mask, SIGIO);\n+\tsigprocmask(SIG_BLOCK, &mask, NULL);\n+\tIntoGoAndBack();\n+\treturn NULL;\n+}\n+\n+int RunSigThread() {\n+\tpthread_t thread;\n+\tint r;\n+\n+\tr = pthread_create(&thread, NULL, &sigthreadfunc, NULL);\n+\tif (r != 0)\n+\t\treturn r;\n+\treturn pthread_join(thread, NULL);\n+}"}, {"sha": "39b658e96c3c0c4c9ba3afb5b794951333b523ec", "filename": "libgo/misc/cgo/test/sigprocmask.go", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fsigprocmask.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftest%2Fsigprocmask.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fsigprocmask.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !windows\n+\n+package cgotest\n+\n+/*\n+#cgo CFLAGS: -pthread\n+#cgo LDFLAGS: -pthread\n+extern int RunSigThread();\n+extern int CheckBlocked();\n+*/\n+import \"C\"\n+import (\n+\t\"os\"\n+\t\"os/signal\"\n+\t\"syscall\"\n+\t\"testing\"\n+)\n+\n+var blocked bool\n+\n+//export IntoGoAndBack\n+func IntoGoAndBack() {\n+\t// Verify that SIGIO stays blocked on the C thread\n+\t// even when unblocked for signal.Notify().\n+\tsignal.Notify(make(chan os.Signal), syscall.SIGIO)\n+\tblocked = C.CheckBlocked() != 0\n+}\n+\n+func testSigprocmask(t *testing.T) {\n+\tif r := C.RunSigThread(); r != 0 {\n+\t\tt.Error(\"pthread_create/pthread_join failed\")\n+\t}\n+\tif !blocked {\n+\t\tt.Error(\"Go runtime unblocked SIGIO\")\n+\t}\n+}"}, {"sha": "1837c6cc81de34fc5f8d4552360fd834e6d750da", "filename": "libgo/misc/cgo/testasan/main.go", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestasan%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestasan%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestasan%2Fmain.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+/*\n+#include <sys/mman.h>\n+#include <pthread.h>\n+#include <unistd.h>\n+\n+void ctor(void) __attribute__((constructor));\n+static void* thread(void*);\n+\n+void\n+ctor(void)\n+{\n+\t// occupy memory where Go runtime would normally map heap\n+\tmmap((void*)0x00c000000000, 64<<10, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);\n+\n+\t// allocate 4K every 10us\n+\tpthread_t t;\n+\tpthread_create(&t, 0, thread, 0);\n+}\n+\n+static void*\n+thread(void *p)\n+{\n+\tfor(;;) {\n+\t\tusleep(10000);\n+\t\tmmap(0, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n+\t}\n+\treturn 0;\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"time\"\n+)\n+\n+func main() {\n+\t// ensure that we can function normally\n+\tvar v [][]byte\n+\tfor i := 0; i < 1000; i++ {\n+\t\ttime.Sleep(10 * time.Microsecond)\n+\t\tv = append(v, make([]byte, 64<<10))\n+\t}\n+}"}, {"sha": "499992977517ea7aacdcf86aa437562950696fac", "filename": "libgo/misc/cgo/testcarchive/carchive_test.go", "status": "added", "additions": 540, "deletions": 0, "changes": 540, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fcarchive_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fcarchive_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fcarchive_test.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,540 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package carchive_test\n+\n+import (\n+\t\"bufio\"\n+\t\"debug/elf\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+\t\"syscall\"\n+\t\"testing\"\n+\t\"time\"\n+\t\"unicode\"\n+)\n+\n+// Program to run.\n+var bin []string\n+\n+// C compiler with args (from $(go env CC) $(go env GOGCCFLAGS)).\n+var cc []string\n+\n+// An environment with GOPATH=$(pwd).\n+var gopathEnv []string\n+\n+// \".exe\" on Windows.\n+var exeSuffix string\n+\n+var GOOS, GOARCH string\n+var libgodir string\n+\n+func init() {\n+\tGOOS = goEnv(\"GOOS\")\n+\tGOARCH = goEnv(\"GOARCH\")\n+\tbin = cmdToRun(\"./testp\")\n+\n+\tccOut := goEnv(\"CC\")\n+\tcc = []string{string(ccOut)}\n+\n+\tout := goEnv(\"GOGCCFLAGS\")\n+\tquote := '\\000'\n+\tstart := 0\n+\tlastSpace := true\n+\tbackslash := false\n+\ts := string(out)\n+\tfor i, c := range s {\n+\t\tif quote == '\\000' && unicode.IsSpace(c) {\n+\t\t\tif !lastSpace {\n+\t\t\t\tcc = append(cc, s[start:i])\n+\t\t\t\tlastSpace = true\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif lastSpace {\n+\t\t\t\tstart = i\n+\t\t\t\tlastSpace = false\n+\t\t\t}\n+\t\t\tif quote == '\\000' && !backslash && (c == '\"' || c == '\\'') {\n+\t\t\t\tquote = c\n+\t\t\t\tbackslash = false\n+\t\t\t} else if !backslash && quote == c {\n+\t\t\t\tquote = '\\000'\n+\t\t\t} else if (quote == '\\000' || quote == '\"') && !backslash && c == '\\\\' {\n+\t\t\t\tbackslash = true\n+\t\t\t} else {\n+\t\t\t\tbackslash = false\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif !lastSpace {\n+\t\tcc = append(cc, s[start:])\n+\t}\n+\n+\tif GOOS == \"darwin\" {\n+\t\t// For Darwin/ARM.\n+\t\t// TODO(crawshaw): can we do better?\n+\t\tcc = append(cc, []string{\"-framework\", \"CoreFoundation\", \"-framework\", \"Foundation\"}...)\n+\t}\n+\tlibgodir = GOOS + \"_\" + GOARCH\n+\tswitch GOOS {\n+\tcase \"darwin\":\n+\t\tif GOARCH == \"arm\" || GOARCH == \"arm64\" {\n+\t\t\tlibgodir += \"_shared\"\n+\t\t}\n+\tcase \"dragonfly\", \"freebsd\", \"linux\", \"netbsd\", \"openbsd\", \"solaris\":\n+\t\tlibgodir += \"_shared\"\n+\t}\n+\tcc = append(cc, \"-I\", filepath.Join(\"pkg\", libgodir))\n+\n+\t// Build an environment with GOPATH=$(pwd)\n+\tenv := os.Environ()\n+\tvar n []string\n+\tfor _, e := range env {\n+\t\tif !strings.HasPrefix(e, \"GOPATH=\") {\n+\t\t\tn = append(n, e)\n+\t\t}\n+\t}\n+\tdir, err := os.Getwd()\n+\tif err != nil {\n+\t\tfmt.Fprintln(os.Stderr, err)\n+\t\tos.Exit(2)\n+\t}\n+\tn = append(n, \"GOPATH=\"+dir)\n+\tgopathEnv = n\n+\n+\tif GOOS == \"windows\" {\n+\t\texeSuffix = \".exe\"\n+\t}\n+}\n+\n+func goEnv(key string) string {\n+\tout, err := exec.Command(\"go\", \"env\", key).Output()\n+\tif err != nil {\n+\t\tfmt.Fprintf(os.Stderr, \"go env %s failed:\\n%s\", key, err)\n+\t\tfmt.Fprintf(os.Stderr, \"%s\", err.(*exec.ExitError).Stderr)\n+\t\tos.Exit(2)\n+\t}\n+\treturn strings.TrimSpace(string(out))\n+}\n+\n+func cmdToRun(name string) []string {\n+\texecScript := \"go_\" + goEnv(\"GOOS\") + \"_\" + goEnv(\"GOARCH\") + \"_exec\"\n+\texecutor, err := exec.LookPath(execScript)\n+\tif err != nil {\n+\t\treturn []string{name}\n+\t}\n+\treturn []string{executor, name}\n+}\n+\n+func testInstall(t *testing.T, exe, libgoa, libgoh string, buildcmd ...string) {\n+\tcmd := exec.Command(buildcmd[0], buildcmd[1:]...)\n+\tcmd.Env = gopathEnv\n+\tif out, err := cmd.CombinedOutput(); err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer func() {\n+\t\tos.Remove(libgoa)\n+\t\tos.Remove(libgoh)\n+\t}()\n+\n+\tccArgs := append(cc, \"-o\", exe, \"main.c\")\n+\tif GOOS == \"windows\" {\n+\t\tccArgs = append(ccArgs, \"main_windows.c\", libgoa, \"-lntdll\", \"-lws2_32\", \"-lwinmm\")\n+\t} else {\n+\t\tccArgs = append(ccArgs, \"main_unix.c\", libgoa)\n+\t}\n+\tt.Log(ccArgs)\n+\tif out, err := exec.Command(ccArgs[0], ccArgs[1:]...).CombinedOutput(); err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.Remove(exe)\n+\n+\tbinArgs := append(cmdToRun(exe), \"arg1\", \"arg2\")\n+\tif out, err := exec.Command(binArgs[0], binArgs[1:]...).CombinedOutput(); err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+}\n+\n+func TestInstall(t *testing.T) {\n+\tdefer os.RemoveAll(\"pkg\")\n+\n+\ttestInstall(t, \"./testp1\"+exeSuffix,\n+\t\tfilepath.Join(\"pkg\", libgodir, \"libgo.a\"),\n+\t\tfilepath.Join(\"pkg\", libgodir, \"libgo.h\"),\n+\t\t\"go\", \"install\", \"-buildmode=c-archive\", \"libgo\")\n+\n+\t// Test building libgo other than installing it.\n+\t// Header files are now present.\n+\ttestInstall(t, \"./testp2\"+exeSuffix, \"libgo.a\", \"libgo.h\",\n+\t\t\"go\", \"build\", \"-buildmode=c-archive\", filepath.Join(\"src\", \"libgo\", \"libgo.go\"))\n+\n+\ttestInstall(t, \"./testp3\"+exeSuffix, \"libgo.a\", \"libgo.h\",\n+\t\t\"go\", \"build\", \"-buildmode=c-archive\", \"-o\", \"libgo.a\", \"libgo\")\n+}\n+\n+func TestEarlySignalHandler(t *testing.T) {\n+\tswitch GOOS {\n+\tcase \"darwin\":\n+\t\tswitch GOARCH {\n+\t\tcase \"arm\", \"arm64\":\n+\t\t\tt.Skipf(\"skipping on %s/%s; see https://golang.org/issue/13701\", GOOS, GOARCH)\n+\t\t}\n+\tcase \"windows\":\n+\t\tt.Skip(\"skipping signal test on Windows\")\n+\t}\n+\n+\tdefer func() {\n+\t\tos.Remove(\"libgo2.a\")\n+\t\tos.Remove(\"libgo2.h\")\n+\t\tos.Remove(\"testp\")\n+\t\tos.RemoveAll(\"pkg\")\n+\t}()\n+\n+\tcmd := exec.Command(\"go\", \"build\", \"-buildmode=c-archive\", \"-o\", \"libgo2.a\", \"libgo2\")\n+\tcmd.Env = gopathEnv\n+\tif out, err := cmd.CombinedOutput(); err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tccArgs := append(cc, \"-o\", \"testp\"+exeSuffix, \"main2.c\", \"libgo2.a\")\n+\tif out, err := exec.Command(ccArgs[0], ccArgs[1:]...).CombinedOutput(); err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tif out, err := exec.Command(bin[0], bin[1:]...).CombinedOutput(); err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+}\n+\n+func TestSignalForwarding(t *testing.T) {\n+\tswitch GOOS {\n+\tcase \"darwin\":\n+\t\tswitch GOARCH {\n+\t\tcase \"arm\", \"arm64\":\n+\t\t\tt.Skipf(\"skipping on %s/%s; see https://golang.org/issue/13701\", GOOS, GOARCH)\n+\t\t}\n+\tcase \"windows\":\n+\t\tt.Skip(\"skipping signal test on Windows\")\n+\t}\n+\n+\tdefer func() {\n+\t\tos.Remove(\"libgo2.a\")\n+\t\tos.Remove(\"libgo2.h\")\n+\t\tos.Remove(\"testp\")\n+\t\tos.RemoveAll(\"pkg\")\n+\t}()\n+\n+\tcmd := exec.Command(\"go\", \"build\", \"-buildmode=c-archive\", \"-o\", \"libgo2.a\", \"libgo2\")\n+\tcmd.Env = gopathEnv\n+\tif out, err := cmd.CombinedOutput(); err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tccArgs := append(cc, \"-o\", \"testp\"+exeSuffix, \"main5.c\", \"libgo2.a\")\n+\tif out, err := exec.Command(ccArgs[0], ccArgs[1:]...).CombinedOutput(); err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tcmd = exec.Command(bin[0], append(bin[1:], \"1\")...)\n+\n+\tout, err := cmd.CombinedOutput()\n+\n+\tif err == nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Error(\"test program succeeded unexpectedly\")\n+\t} else if ee, ok := err.(*exec.ExitError); !ok {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Errorf(\"error (%v) has type %T; expected exec.ExitError\", err, err)\n+\t} else if ws, ok := ee.Sys().(syscall.WaitStatus); !ok {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Errorf(\"error.Sys (%v) has type %T; expected syscall.WaitStatus\", ee.Sys(), ee.Sys())\n+\t} else if !ws.Signaled() || ws.Signal() != syscall.SIGSEGV {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Errorf(\"got %v; expected SIGSEGV\", ee)\n+\t}\n+}\n+\n+func TestSignalForwardingExternal(t *testing.T) {\n+\tswitch GOOS {\n+\tcase \"darwin\":\n+\t\tswitch GOARCH {\n+\t\tcase \"arm\", \"arm64\":\n+\t\t\tt.Skipf(\"skipping on %s/%s; see https://golang.org/issue/13701\", GOOS, GOARCH)\n+\t\t}\n+\tcase \"windows\":\n+\t\tt.Skip(\"skipping signal test on Windows\")\n+\t}\n+\n+\tdefer func() {\n+\t\tos.Remove(\"libgo2.a\")\n+\t\tos.Remove(\"libgo2.h\")\n+\t\tos.Remove(\"testp\")\n+\t\tos.RemoveAll(\"pkg\")\n+\t}()\n+\n+\tcmd := exec.Command(\"go\", \"build\", \"-buildmode=c-archive\", \"-o\", \"libgo2.a\", \"libgo2\")\n+\tcmd.Env = gopathEnv\n+\tif out, err := cmd.CombinedOutput(); err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tccArgs := append(cc, \"-o\", \"testp\"+exeSuffix, \"main5.c\", \"libgo2.a\")\n+\tif out, err := exec.Command(ccArgs[0], ccArgs[1:]...).CombinedOutput(); err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// We want to send the process a signal and see if it dies.\n+\t// Normally the signal goes to the C thread, the Go signal\n+\t// handler picks it up, sees that it is running in a C thread,\n+\t// and the program dies. Unfortunately, occasionally the\n+\t// signal is delivered to a Go thread, which winds up\n+\t// discarding it because it was sent by another program and\n+\t// there is no Go handler for it. To avoid this, run the\n+\t// program several times in the hopes that it will eventually\n+\t// fail.\n+\tconst tries = 20\n+\tfor i := 0; i < tries; i++ {\n+\t\tcmd = exec.Command(bin[0], append(bin[1:], \"2\")...)\n+\n+\t\tstderr, err := cmd.StderrPipe()\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tdefer stderr.Close()\n+\n+\t\tr := bufio.NewReader(stderr)\n+\n+\t\terr = cmd.Start()\n+\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\n+\t\t// Wait for trigger to ensure that the process is started.\n+\t\tok, err := r.ReadString('\\n')\n+\n+\t\t// Verify trigger.\n+\t\tif err != nil || ok != \"OK\\n\" {\n+\t\t\tt.Fatalf(\"Did not receive OK signal\")\n+\t\t}\n+\n+\t\t// Give the program a chance to enter the sleep function.\n+\t\ttime.Sleep(time.Millisecond)\n+\n+\t\tcmd.Process.Signal(syscall.SIGSEGV)\n+\n+\t\terr = cmd.Wait()\n+\n+\t\tif err == nil {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif ee, ok := err.(*exec.ExitError); !ok {\n+\t\t\tt.Errorf(\"error (%v) has type %T; expected exec.ExitError\", err, err)\n+\t\t} else if ws, ok := ee.Sys().(syscall.WaitStatus); !ok {\n+\t\t\tt.Errorf(\"error.Sys (%v) has type %T; expected syscall.WaitStatus\", ee.Sys(), ee.Sys())\n+\t\t} else if !ws.Signaled() || ws.Signal() != syscall.SIGSEGV {\n+\t\t\tt.Errorf(\"got %v; expected SIGSEGV\", ee)\n+\t\t} else {\n+\t\t\t// We got the error we expected.\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tt.Errorf(\"program succeeded unexpectedly %d times\", tries)\n+}\n+\n+func TestOsSignal(t *testing.T) {\n+\tswitch GOOS {\n+\tcase \"windows\":\n+\t\tt.Skip(\"skipping signal test on Windows\")\n+\t}\n+\n+\tdefer func() {\n+\t\tos.Remove(\"libgo3.a\")\n+\t\tos.Remove(\"libgo3.h\")\n+\t\tos.Remove(\"testp\")\n+\t\tos.RemoveAll(\"pkg\")\n+\t}()\n+\n+\tcmd := exec.Command(\"go\", \"build\", \"-buildmode=c-archive\", \"-o\", \"libgo3.a\", \"libgo3\")\n+\tcmd.Env = gopathEnv\n+\tif out, err := cmd.CombinedOutput(); err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tccArgs := append(cc, \"-o\", \"testp\"+exeSuffix, \"main3.c\", \"libgo3.a\")\n+\tif out, err := exec.Command(ccArgs[0], ccArgs[1:]...).CombinedOutput(); err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tif out, err := exec.Command(bin[0], bin[1:]...).CombinedOutput(); err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+}\n+\n+func TestSigaltstack(t *testing.T) {\n+\tswitch GOOS {\n+\tcase \"windows\":\n+\t\tt.Skip(\"skipping signal test on Windows\")\n+\t}\n+\n+\tdefer func() {\n+\t\tos.Remove(\"libgo4.a\")\n+\t\tos.Remove(\"libgo4.h\")\n+\t\tos.Remove(\"testp\")\n+\t\tos.RemoveAll(\"pkg\")\n+\t}()\n+\n+\tcmd := exec.Command(\"go\", \"build\", \"-buildmode=c-archive\", \"-o\", \"libgo4.a\", \"libgo4\")\n+\tcmd.Env = gopathEnv\n+\tif out, err := cmd.CombinedOutput(); err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tccArgs := append(cc, \"-o\", \"testp\"+exeSuffix, \"main4.c\", \"libgo4.a\")\n+\tif out, err := exec.Command(ccArgs[0], ccArgs[1:]...).CombinedOutput(); err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tif out, err := exec.Command(bin[0], bin[1:]...).CombinedOutput(); err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+}\n+\n+const testar = `#!/usr/bin/env bash\n+while expr $1 : '[-]' >/dev/null; do\n+  shift\n+done\n+echo \"testar\" > $1\n+echo \"testar\" > PWD/testar.ran\n+`\n+\n+func TestExtar(t *testing.T) {\n+\tswitch GOOS {\n+\tcase \"windows\":\n+\t\tt.Skip(\"skipping signal test on Windows\")\n+\t}\n+\n+\tdefer func() {\n+\t\tos.Remove(\"libgo4.a\")\n+\t\tos.Remove(\"libgo4.h\")\n+\t\tos.Remove(\"testar\")\n+\t\tos.Remove(\"testar.ran\")\n+\t\tos.RemoveAll(\"pkg\")\n+\t}()\n+\n+\tos.Remove(\"testar\")\n+\tdir, err := os.Getwd()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\ts := strings.Replace(testar, \"PWD\", dir, 1)\n+\tif err := ioutil.WriteFile(\"testar\", []byte(s), 0777); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tcmd := exec.Command(\"go\", \"build\", \"-buildmode=c-archive\", \"-ldflags=-extar=\"+filepath.Join(dir, \"testar\"), \"-o\", \"libgo4.a\", \"libgo4\")\n+\tcmd.Env = gopathEnv\n+\tif out, err := cmd.CombinedOutput(); err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tif _, err := os.Stat(\"testar.ran\"); err != nil {\n+\t\tif os.IsNotExist(err) {\n+\t\t\tt.Error(\"testar does not exist after go build\")\n+\t\t} else {\n+\t\t\tt.Errorf(\"error checking testar: %v\", err)\n+\t\t}\n+\t}\n+}\n+\n+func TestPIE(t *testing.T) {\n+\tswitch GOOS {\n+\tcase \"windows\", \"darwin\", \"plan9\":\n+\t\tt.Skipf(\"skipping PIE test on %s\", GOOS)\n+\t}\n+\n+\tdefer func() {\n+\t\tos.Remove(\"testp\" + exeSuffix)\n+\t\tos.RemoveAll(\"pkg\")\n+\t}()\n+\n+\tcmd := exec.Command(\"go\", \"install\", \"-buildmode=c-archive\", \"libgo\")\n+\tcmd.Env = gopathEnv\n+\tif out, err := cmd.CombinedOutput(); err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tccArgs := append(cc, \"-fPIE\", \"-pie\", \"-o\", \"testp\"+exeSuffix, \"main.c\", \"main_unix.c\", filepath.Join(\"pkg\", libgodir, \"libgo.a\"))\n+\tif out, err := exec.Command(ccArgs[0], ccArgs[1:]...).CombinedOutput(); err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tbinArgs := append(bin, \"arg1\", \"arg2\")\n+\tif out, err := exec.Command(binArgs[0], binArgs[1:]...).CombinedOutput(); err != nil {\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tf, err := elf.Open(\"testp\" + exeSuffix)\n+\tif err != nil {\n+\t\tt.Fatal(\"elf.Open failed: \", err)\n+\t}\n+\tdefer f.Close()\n+\tif hasDynTag(t, f, elf.DT_TEXTREL) {\n+\t\tt.Errorf(\"%s has DT_TEXTREL flag\", \"testp\"+exeSuffix)\n+\t}\n+}\n+\n+func hasDynTag(t *testing.T, f *elf.File, tag elf.DynTag) bool {\n+\tds := f.SectionByType(elf.SHT_DYNAMIC)\n+\tif ds == nil {\n+\t\tt.Error(\"no SHT_DYNAMIC section\")\n+\t\treturn false\n+\t}\n+\td, err := ds.Data()\n+\tif err != nil {\n+\t\tt.Errorf(\"can't read SHT_DYNAMIC contents: %v\", err)\n+\t\treturn false\n+\t}\n+\tfor len(d) > 0 {\n+\t\tvar t elf.DynTag\n+\t\tswitch f.Class {\n+\t\tcase elf.ELFCLASS32:\n+\t\t\tt = elf.DynTag(f.ByteOrder.Uint32(d[:4]))\n+\t\t\td = d[8:]\n+\t\tcase elf.ELFCLASS64:\n+\t\t\tt = elf.DynTag(f.ByteOrder.Uint64(d[:8]))\n+\t\t\td = d[16:]\n+\t\t}\n+\t\tif t == tag {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}"}, {"sha": "163b5398e5ecb4bb5d024ee55bfa68df7360b3ac", "filename": "libgo/misc/cgo/testcarchive/main.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fmain.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"p.h\"\n+#include \"libgo.h\"\n+\n+extern int install_handler();\n+extern int check_handler();\n+\n+int main(void) {\n+\tint32_t res;\n+\n+\tint r1 = install_handler();\n+\tif (r1!=0) {\n+\t\treturn r1;\n+\t}\n+\n+\tif (!DidInitRun()) {\n+\t\tfprintf(stderr, \"ERROR: buildmode=c-archive init should run\\n\");\n+\t\treturn 2;\n+\t}\n+\n+\tif (DidMainRun()) {\n+\t\tfprintf(stderr, \"ERROR: buildmode=c-archive should not run main\\n\");\n+\t\treturn 2;\n+\t}\n+\n+\tint r2 = check_handler();\n+\tif (r2!=0) {\n+\t\treturn r2;\n+\t}\n+\n+\tres = FromPkg();\n+\tif (res != 1024) {\n+\t\tfprintf(stderr, \"ERROR: FromPkg()=%d, want 1024\\n\", res);\n+\t\treturn 2;\n+\t}\n+\n+\tCheckArgs();\n+\n+\tfprintf(stderr, \"PASS\\n\");\n+\treturn 0;\n+}"}, {"sha": "774e014a1620967269a99eba962b175b69382c8f", "filename": "libgo/misc/cgo/testcarchive/main2.c", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fmain2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fmain2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fmain2.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,199 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test installing a signal handler before the Go code starts.\n+// This is a lot like misc/cgo/testcshared/main4.c.\n+\n+#include <setjmp.h>\n+#include <signal.h>\n+#include <stdarg.h>\n+#include <stddef.h>\n+#include <stdio.h>\n+#include <stdint.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n+#include <sched.h>\n+#include <time.h>\n+\n+#include \"libgo2.h\"\n+\n+static void die(const char* msg) {\n+\tperror(msg);\n+\texit(EXIT_FAILURE);\n+}\n+\n+static volatile sig_atomic_t sigioSeen;\n+\n+// Use up some stack space.\n+static void recur(int i, char *p) {\n+\tchar a[1024];\n+\n+\t*p = '\\0';\n+\tif (i > 0) {\n+\t\trecur(i - 1, a);\n+\t}\n+}\n+\n+// Signal handler that uses up more stack space than a goroutine will have.\n+static void ioHandler(int signo, siginfo_t* info, void* ctxt) {\n+\tchar a[1024];\n+\n+\trecur(4, a);\n+\tsigioSeen = 1;\n+}\n+\n+static jmp_buf jmp;\n+static char* nullPointer;\n+\n+// An arbitrary function which requires proper stack alignment; see\n+// http://golang.org/issue/17641.\n+static void callWithVarargs(void* dummy, ...) {\n+\tva_list args;\n+\tva_start(args, dummy);\n+\tva_end(args);\n+}\n+\n+// Signal handler for SIGSEGV on a C thread.\n+static void segvHandler(int signo, siginfo_t* info, void* ctxt) {\n+\tsigset_t mask;\n+\tint i;\n+\n+\t// Call an arbitrary function that requires the stack to be properly aligned.\n+\tcallWithVarargs(\"dummy arg\", 3.1415);\n+\n+\tif (sigemptyset(&mask) < 0) {\n+\t\tdie(\"sigemptyset\");\n+\t}\n+\tif (sigaddset(&mask, SIGSEGV) < 0) {\n+\t\tdie(\"sigaddset\");\n+\t}\n+\ti = sigprocmask(SIG_UNBLOCK, &mask, NULL);\n+\tif (i != 0) {\n+\t\tfprintf(stderr, \"sigprocmask: %s\\n\", strerror(i));\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\t// Don't try this at home.\n+\tlongjmp(jmp, signo);\n+\n+\t// We should never get here.\n+\tabort();\n+}\n+\n+// Set up the signal handlers in a high priority constructor,\n+// so that they are installed before the Go code starts.\n+\n+static void init(void) __attribute__ ((constructor (200)));\n+\n+static void init() {\n+\tstruct sigaction sa;\n+\n+\tmemset(&sa, 0, sizeof sa);\n+\tsa.sa_sigaction = ioHandler;\n+\tif (sigemptyset(&sa.sa_mask) < 0) {\n+\t\tdie(\"sigemptyset\");\n+\t}\n+\tsa.sa_flags = SA_SIGINFO;\n+\tif (sigaction(SIGIO, &sa, NULL) < 0) {\n+\t\tdie(\"sigaction\");\n+\t}\n+\n+\tsa.sa_sigaction = segvHandler;\n+\tif (sigaction(SIGSEGV, &sa, NULL) < 0 || sigaction(SIGBUS, &sa, NULL) < 0) {\n+\t\tdie(\"sigaction\");\n+\t}\n+\n+}\n+\n+int main(int argc, char** argv) {\n+\tint verbose;\n+\tsigset_t mask;\n+\tint i;\n+\tstruct timespec ts;\n+\n+\tverbose = argc > 1;\n+\tsetvbuf(stdout, NULL, _IONBF, 0);\n+\n+\t// Call setsid so that we can use kill(0, SIGIO) below.\n+\t// Don't check the return value so that this works both from\n+\t// a job control shell and from a shell script.\n+\tsetsid();\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling RunGoroutines\\n\");\n+\t}\n+\n+\tRunGoroutines();\n+\n+\t// Block SIGIO in this thread to make it more likely that it\n+\t// will be delivered to a goroutine.\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling pthread_sigmask\\n\");\n+\t}\n+\n+\tif (sigemptyset(&mask) < 0) {\n+\t\tdie(\"sigemptyset\");\n+\t}\n+\tif (sigaddset(&mask, SIGIO) < 0) {\n+\t\tdie(\"sigaddset\");\n+\t}\n+\ti = pthread_sigmask(SIG_BLOCK, &mask, NULL);\n+\tif (i != 0) {\n+\t\tfprintf(stderr, \"pthread_sigmask: %s\\n\", strerror(i));\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling kill\\n\");\n+\t}\n+\n+\tif (kill(0, SIGIO) < 0) {\n+\t\tdie(\"kill\");\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"waiting for sigioSeen\\n\");\n+\t}\n+\n+\t// Wait until the signal has been delivered.\n+\ti = 0;\n+\twhile (!sigioSeen) {\n+\t\tts.tv_sec = 0;\n+\t\tts.tv_nsec = 1000000;\n+\t\tnanosleep(&ts, NULL);\n+\t\ti++;\n+\t\tif (i > 5000) {\n+\t\t\tfprintf(stderr, \"looping too long waiting for signal\\n\");\n+\t\t\texit(EXIT_FAILURE);\n+\t\t}\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling setjmp\\n\");\n+\t}\n+\n+\t// Test that a SIGSEGV on this thread is delivered to us.\n+\tif (setjmp(jmp) == 0) {\n+\t\tif (verbose) {\n+\t\t\tprintf(\"triggering SIGSEGV\\n\");\n+\t\t}\n+\n+\t\t*nullPointer = '\\0';\n+\n+\t\tfprintf(stderr, \"continued after address error\\n\");\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling TestSEGV\\n\");\n+\t}\n+\n+\tTestSEGV();\n+\n+\tprintf(\"PASS\\n\");\n+\treturn 0;\n+}"}, {"sha": "0a6c0d3f74e077b01fa7834d9f415f7acb1ea9d0", "filename": "libgo/misc/cgo/testcarchive/main3.c", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fmain3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fmain3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fmain3.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,155 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test os/signal.Notify and os/signal.Reset.\n+// This is a lot like misc/cgo/testcshared/main5.c.\n+\n+#include <signal.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <time.h>\n+#include <sched.h>\n+\n+#include \"libgo3.h\"\n+\n+static void die(const char* msg) {\n+\tperror(msg);\n+\texit(EXIT_FAILURE);\n+}\n+\n+static volatile sig_atomic_t sigioSeen;\n+\n+static void ioHandler(int signo, siginfo_t* info, void* ctxt) {\n+\tsigioSeen = 1;\n+}\n+\n+int main(int argc, char** argv) {\n+\tint verbose;\n+\tstruct sigaction sa;\n+\tint i;\n+\tstruct timespec ts;\n+\n+\tverbose = argc > 2;\n+\tsetvbuf(stdout, NULL, _IONBF, 0);\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling sigaction\\n\");\n+\t}\n+\n+\tmemset(&sa, 0, sizeof sa);\n+\tsa.sa_sigaction = ioHandler;\n+\tif (sigemptyset(&sa.sa_mask) < 0) {\n+\t\tdie(\"sigemptyset\");\n+\t}\n+\tsa.sa_flags = SA_SIGINFO;\n+\tif (sigaction(SIGIO, &sa, NULL) < 0) {\n+\t\tdie(\"sigaction\");\n+\t}\n+\n+\t// At this point there should not be a Go signal handler\n+\t// installed for SIGIO.\n+\n+\tif (verbose) {\n+\t\tprintf(\"raising SIGIO\\n\");\n+\t}\n+\n+\tif (raise(SIGIO) < 0) {\n+\t\tdie(\"raise\");\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"waiting for sigioSeen\\n\");\n+\t}\n+\n+\t// Wait until the signal has been delivered.\n+\ti = 0;\n+\twhile (!sigioSeen) {\n+\t\tts.tv_sec = 0;\n+\t\tts.tv_nsec = 1000000;\n+\t\tnanosleep(&ts, NULL);\n+\t\ti++;\n+\t\tif (i > 5000) {\n+\t\t\tfprintf(stderr, \"looping too long waiting for signal\\n\");\n+\t\t\texit(EXIT_FAILURE);\n+\t\t}\n+\t}\n+\n+\tsigioSeen = 0;\n+\n+\t// Tell the Go code to catch SIGIO.\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling CatchSIGIO\\n\");\n+\t}\n+\n+\tCatchSIGIO();\n+\n+\tif (verbose) {\n+\t\tprintf(\"raising SIGIO\\n\");\n+\t}\n+\n+\tif (raise(SIGIO) < 0) {\n+\t\tdie(\"raise\");\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling SawSIGIO\\n\");\n+\t}\n+\n+\tif (!SawSIGIO()) {\n+\t\tfprintf(stderr, \"Go handler did not see SIGIO\\n\");\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\tif (sigioSeen != 0) {\n+\t\tfprintf(stderr, \"C handler saw SIGIO when only Go handler should have\\n\");\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\t// Tell the Go code to stop catching SIGIO.\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling ResetSIGIO\\n\");\n+\t}\n+\n+\tResetSIGIO();\n+\n+\tif (verbose) {\n+\t\tprintf(\"raising SIGIO\\n\");\n+\t}\n+\n+\tif (raise(SIGIO) < 0) {\n+\t\tdie(\"raise\");\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling SawSIGIO\\n\");\n+\t}\n+\n+\tif (SawSIGIO()) {\n+\t\tfprintf(stderr, \"Go handler saw SIGIO after Reset\\n\");\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"waiting for sigioSeen\\n\");\n+\t}\n+\n+\t// Wait until the signal has been delivered.\n+\ti = 0;\n+\twhile (!sigioSeen) {\n+\t\tts.tv_sec = 0;\n+\t\tts.tv_nsec = 1000000;\n+\t\tnanosleep(&ts, NULL);\n+\t\ti++;\n+\t\tif (i > 5000) {\n+\t\t\tfprintf(stderr, \"looping too long waiting for signal\\n\");\n+\t\t\texit(EXIT_FAILURE);\n+\t\t}\n+\t}\n+\n+\tprintf(\"PASS\\n\");\n+\treturn 0;\n+}"}, {"sha": "4fd55e753d58f7c77c53740105d7be95a0de412a", "filename": "libgo/misc/cgo/testcarchive/main4.c", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fmain4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fmain4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fmain4.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,197 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test a C thread that calls sigaltstack and then calls Go code.\n+\n+#include <signal.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <time.h>\n+#include <sched.h>\n+#include <pthread.h>\n+\n+#include \"libgo4.h\"\n+\n+static void die(const char* msg) {\n+\tperror(msg);\n+\texit(EXIT_FAILURE);\n+}\n+\n+static int ok = 1;\n+\n+static void ioHandler(int signo, siginfo_t* info, void* ctxt) {\n+}\n+\n+// Set up the SIGIO signal handler in a high priority constructor, so\n+// that it is installed before the Go code starts.\n+\n+static void init(void) __attribute__ ((constructor (200)));\n+\n+static void init() {\n+\tstruct sigaction sa;\n+\n+\tmemset(&sa, 0, sizeof sa);\n+\tsa.sa_sigaction = ioHandler;\n+\tif (sigemptyset(&sa.sa_mask) < 0) {\n+\t\tdie(\"sigemptyset\");\n+\t}\n+\tsa.sa_flags = SA_SIGINFO | SA_ONSTACK;\n+\tif (sigaction(SIGIO, &sa, NULL) < 0) {\n+\t\tdie(\"sigaction\");\n+\t}\n+}\n+\n+// Test raising SIGIO on a C thread with an alternate signal stack\n+// when there is a Go signal handler for SIGIO.\n+static void* thread1(void* arg __attribute__ ((unused))) {\n+\tstack_t ss;\n+\tint i;\n+\tstack_t nss;\n+\tstruct timespec ts;\n+\n+\t// Set up an alternate signal stack for this thread.\n+\tmemset(&ss, 0, sizeof ss);\n+\tss.ss_sp = malloc(SIGSTKSZ);\n+\tif (ss.ss_sp == NULL) {\n+\t\tdie(\"malloc\");\n+\t}\n+\tss.ss_flags = 0;\n+\tss.ss_size = SIGSTKSZ;\n+\tif (sigaltstack(&ss, NULL) < 0) {\n+\t\tdie(\"sigaltstack\");\n+\t}\n+\n+\t// Send ourselves a SIGIO.  This will be caught by the Go\n+\t// signal handler which should forward to the C signal\n+\t// handler.\n+\ti = pthread_kill(pthread_self(), SIGIO);\n+\tif (i != 0) {\n+\t\tfprintf(stderr, \"pthread_kill: %s\\n\", strerror(i));\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\t// Wait until the signal has been delivered.\n+\ti = 0;\n+\twhile (SIGIOCount() == 0) {\n+\t\tts.tv_sec = 0;\n+\t\tts.tv_nsec = 1000000;\n+\t\tnanosleep(&ts, NULL);\n+\t\ti++;\n+\t\tif (i > 5000) {\n+\t\t\tfprintf(stderr, \"looping too long waiting for signal\\n\");\n+\t\t\texit(EXIT_FAILURE);\n+\t\t}\n+\t}\n+\n+\t// We should still be on the same signal stack.\n+\tif (sigaltstack(NULL, &nss) < 0) {\n+\t\tdie(\"sigaltstack check\");\n+\t}\n+\tif ((nss.ss_flags & SS_DISABLE) != 0) {\n+\t\tfprintf(stderr, \"sigaltstack disabled on return from Go\\n\");\n+\t\tok = 0;\n+\t} else if (nss.ss_sp != ss.ss_sp) {\n+\t\tfprintf(stderr, \"sigalstack changed on return from Go\\n\");\n+\t\tok = 0;\n+\t}\n+\n+\treturn NULL;\n+}\n+\n+// Test calling a Go function to raise SIGIO on a C thread with an\n+// alternate signal stack when there is a Go signal handler for SIGIO.\n+static void* thread2(void* arg __attribute__ ((unused))) {\n+\tstack_t ss;\n+\tint i;\n+\tint oldcount;\n+\tpthread_t tid;\n+\tstruct timespec ts;\n+\tstack_t nss;\n+\n+\t// Set up an alternate signal stack for this thread.\n+\tmemset(&ss, 0, sizeof ss);\n+\tss.ss_sp = malloc(SIGSTKSZ);\n+\tif (ss.ss_sp == NULL) {\n+\t\tdie(\"malloc\");\n+\t}\n+\tss.ss_flags = 0;\n+\tss.ss_size = SIGSTKSZ;\n+\tif (sigaltstack(&ss, NULL) < 0) {\n+\t\tdie(\"sigaltstack\");\n+\t}\n+\n+\toldcount = SIGIOCount();\n+\n+\t// Call a Go function that will call a C function to send us a\n+\t// SIGIO.\n+\ttid = pthread_self();\n+\tGoRaiseSIGIO(&tid);\n+\n+\t// Wait until the signal has been delivered.\n+\ti = 0;\n+\twhile (SIGIOCount() == oldcount) {\n+\t\tts.tv_sec = 0;\n+\t\tts.tv_nsec = 1000000;\n+\t\tnanosleep(&ts, NULL);\n+\t\ti++;\n+\t\tif (i > 5000) {\n+\t\t\tfprintf(stderr, \"looping too long waiting for signal\\n\");\n+\t\t\texit(EXIT_FAILURE);\n+\t\t}\n+\t}\n+\n+\t// We should still be on the same signal stack.\n+\tif (sigaltstack(NULL, &nss) < 0) {\n+\t\tdie(\"sigaltstack check\");\n+\t}\n+\tif ((nss.ss_flags & SS_DISABLE) != 0) {\n+\t\tfprintf(stderr, \"sigaltstack disabled on return from Go\\n\");\n+\t\tok = 0;\n+\t} else if (nss.ss_sp != ss.ss_sp) {\n+\t\tfprintf(stderr, \"sigalstack changed on return from Go\\n\");\n+\t\tok = 0;\n+\t}\n+\n+\treturn NULL;\n+}\n+\n+int main(int argc, char **argv) {\n+\tpthread_t tid;\n+\tint i;\n+\n+\t// Tell the Go library to start looking for SIGIO.\n+\tGoCatchSIGIO();\n+\n+\ti = pthread_create(&tid, NULL, thread1, NULL);\n+\tif (i != 0) {\n+\t\tfprintf(stderr, \"pthread_create: %s\\n\", strerror(i));\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\ti = pthread_join(tid, NULL);\n+\tif (i != 0) {\n+\t\tfprintf(stderr, \"pthread_join: %s\\n\", strerror(i));\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\ti = pthread_create(&tid, NULL, thread2, NULL);\n+\tif (i != 0) {\n+\t\tfprintf(stderr, \"pthread_create: %s\\n\", strerror(i));\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\ti = pthread_join(tid, NULL);\n+\tif (i != 0) {\n+\t\tfprintf(stderr, \"pthread_join: %s\\n\", strerror(i));\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\tif (!ok) {\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\tprintf(\"PASS\\n\");\n+\treturn 0;\n+}"}, {"sha": "9fadf0801e10c996b2f48b6876d5b491a9984030", "filename": "libgo/misc/cgo/testcarchive/main5.c", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fmain5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fmain5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fmain5.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test for verifying that the Go runtime properly forwards\n+// signals when non-Go signals are raised.\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <sys/types.h>\n+#include <sys/time.h>\n+#include <sys/select.h>\n+\n+#include \"libgo2.h\"\n+\n+int main(int argc, char** argv) {\n+\tint verbose;\n+\tint test;\n+\n+\tif (argc < 2) {\n+\t\tprintf(\"Missing argument\\n\");\n+\t\treturn 1;\n+\t}\n+\n+\ttest = atoi(argv[1]);\n+\n+\tverbose = (argc > 2);\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling RunGoroutines\\n\");\n+\t}\n+\n+\tNoop();\n+\n+\tswitch (test) {\n+\t\tcase 1: {\n+\t\t\tif (verbose) {\n+\t\t\t\tprintf(\"attempting segfault\\n\");\n+\t\t\t}\n+\n+\t\t\tvolatile int crash = *(int *) 0;\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tcase 2: {\n+\t\t\tstruct timeval tv;\n+\n+\t\t\tif (verbose) {\n+\t\t\t\tprintf(\"attempting external signal test\\n\");\n+\t\t\t}\n+\n+\t\t\tfprintf(stderr, \"OK\\n\");\n+\t\t\tfflush(stderr);\n+\n+\t\t\t// The program should be interrupted before\n+\t\t\t// this sleep finishes. We use select rather\n+\t\t\t// than sleep because in older versions of\n+\t\t\t// glibc the sleep function does some signal\n+\t\t\t// fiddling to handle SIGCHLD.  If this\n+\t\t\t// program is fiddling signals just when the\n+\t\t\t// test program sends the signal, the signal\n+\t\t\t// may be delivered to a Go thread which will\n+\t\t\t// break this test.\n+\t\t\ttv.tv_sec = 60;\n+\t\t\ttv.tv_usec = 0;\n+\t\t\tselect(0, NULL, NULL, NULL, &tv);\n+\n+\t\t\tbreak;\n+\t\t}\n+\t\tdefault:\n+\t\t\tprintf(\"Unknown test: %d\\n\", test);\n+\t\t\treturn 0;\n+\t}\n+\n+\tprintf(\"FAIL\\n\");\n+\treturn 0;\n+}"}, {"sha": "4d9d16f03b0348b24d2c468866fe08651248cd28", "filename": "libgo/misc/cgo/testcarchive/main_unix.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fmain_unix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fmain_unix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fmain_unix.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include <signal.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+struct sigaction sa;\n+struct sigaction osa;\n+\n+static void (*oldHandler)(int, siginfo_t*, void*);\n+\n+static void handler(int signo, siginfo_t* info, void* ctxt) {\n+\tif (oldHandler) {\n+\t\toldHandler(signo, info, ctxt);\n+\t}\n+}\n+\n+int install_handler() {\n+\t// Install our own signal handler.\n+\tmemset(&sa, 0, sizeof sa);\n+\tsa.sa_sigaction = handler;\n+\tsigemptyset(&sa.sa_mask);\n+\tsa.sa_flags = SA_ONSTACK | SA_SIGINFO;\n+\tmemset(&osa, 0, sizeof osa);\n+\tsigemptyset(&osa.sa_mask);\n+\tif (sigaction(SIGSEGV, &sa, &osa) < 0) {\n+\t\tperror(\"sigaction\");\n+\t\treturn 2;\n+\t}\n+\tif (osa.sa_handler == SIG_DFL || (osa.sa_flags&SA_ONSTACK) == 0) {\n+\t\tfprintf(stderr, \"Go runtime did not install signal handler\\n\");\n+\t\treturn 2;\n+\t}\n+\toldHandler = osa.sa_sigaction;\n+\n+\treturn 0;\n+}\n+\n+int check_handler() {\n+\tif (sigaction(SIGSEGV, NULL, &sa) < 0) {\n+\t\tperror(\"sigaction check\");\n+\t\treturn 2;\n+\t}\n+\tif (sa.sa_sigaction != handler) {\n+\t\tfprintf(stderr, \"ERROR: wrong signal handler: %p != %p\\n\", sa.sa_sigaction, handler);\n+\t\treturn 2;\n+\t}\n+\treturn 0;\n+}\n+"}, {"sha": "eded8af1a2c9af04576a14828372c9c01c8710e9", "filename": "libgo/misc/cgo/testcarchive/main_windows.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fmain_windows.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fmain_windows.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fmain_windows.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+/*\n+ * Dummy implementations for Windows, because Windows doesn't\n+ * support Unix-style signal handling.\n+ */\n+\n+int install_handler() {\n+\treturn 0;\n+}\n+\n+\n+int check_handler() {\n+\treturn 0;\n+}"}, {"sha": "45958a546cb0e4667fdb121077feb9a4b84a176d", "filename": "libgo/misc/cgo/testcarchive/src/libgo/libgo.go", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fsrc%2Flibgo%2Flibgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fsrc%2Flibgo%2Flibgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fsrc%2Flibgo%2Flibgo.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"syscall\"\n+\t\"time\"\n+\n+\t_ \"p\"\n+)\n+\n+import \"C\"\n+\n+var initCh = make(chan int, 1)\n+var ranMain bool\n+\n+func init() {\n+\t// emulate an exceedingly slow package initialization function\n+\ttime.Sleep(100 * time.Millisecond)\n+\tinitCh <- 42\n+}\n+\n+func main() { ranMain = true }\n+\n+//export DidInitRun\n+func DidInitRun() bool {\n+\tselect {\n+\tcase x := <-initCh:\n+\t\tif x != 42 {\n+\t\t\t// Just in case initCh was not correctly made.\n+\t\t\tprintln(\"want init value of 42, got: \", x)\n+\t\t\tsyscall.Exit(2)\n+\t\t}\n+\t\treturn true\n+\tdefault:\n+\t\treturn false\n+\t}\n+}\n+\n+//export DidMainRun\n+func DidMainRun() bool { return ranMain }\n+\n+//export CheckArgs\n+func CheckArgs() {\n+\tif len(os.Args) != 3 || os.Args[1] != \"arg1\" || os.Args[2] != \"arg2\" {\n+\t\tfmt.Printf(\"CheckArgs: want [_, arg1, arg2], got: %v\\n\", os.Args)\n+\t\tos.Exit(2)\n+\t}\n+}"}, {"sha": "fbed493b93ff20463d25cf71f81f554a0ac728f3", "filename": "libgo/misc/cgo/testcarchive/src/libgo2/libgo2.go", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fsrc%2Flibgo2%2Flibgo2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fsrc%2Flibgo2%2Flibgo2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fsrc%2Flibgo2%2Flibgo2.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"C\"\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"runtime\"\n+)\n+\n+// RunGoroutines starts some goroutines that don't do anything.\n+// The idea is to get some threads going, so that a signal will be delivered\n+// to a thread started by Go.\n+//export RunGoroutines\n+func RunGoroutines() {\n+\tfor i := 0; i < 4; i++ {\n+\t\tgo func() {\n+\t\t\truntime.LockOSThread()\n+\t\t\tselect {}\n+\t\t}()\n+\t}\n+}\n+\n+var P *byte\n+\n+// TestSEGV makes sure that an invalid address turns into a run-time Go panic.\n+//export TestSEGV\n+func TestSEGV() {\n+\tdefer func() {\n+\t\tif recover() == nil {\n+\t\t\tfmt.Fprintln(os.Stderr, \"no panic from segv\")\n+\t\t\tos.Exit(1)\n+\t\t}\n+\t}()\n+\t*P = 0\n+\tfmt.Fprintln(os.Stderr, \"continued after segv\")\n+\tos.Exit(1)\n+}\n+\n+// Noop ensures that the Go runtime is initialized.\n+//export Noop\n+func Noop() {\n+}\n+\n+func main() {\n+}"}, {"sha": "94e5d21c14a83c3019ef4ba09b17fc3222e7e7be", "filename": "libgo/misc/cgo/testcarchive/src/libgo3/libgo3.go", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fsrc%2Flibgo3%2Flibgo3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fsrc%2Flibgo3%2Flibgo3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fsrc%2Flibgo3%2Flibgo3.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"C\"\n+\n+import (\n+\t\"os\"\n+\t\"os/signal\"\n+\t\"syscall\"\n+\t\"time\"\n+)\n+\n+// The channel used to read SIGIO signals.\n+var sigioChan chan os.Signal\n+\n+// CatchSIGIO starts catching SIGIO signals.\n+//export CatchSIGIO\n+func CatchSIGIO() {\n+\tsigioChan = make(chan os.Signal, 1)\n+\tsignal.Notify(sigioChan, syscall.SIGIO)\n+}\n+\n+// ResetSIGIO stops catching SIGIO signals.\n+//export ResetSIGIO\n+func ResetSIGIO() {\n+\tsignal.Reset(syscall.SIGIO)\n+}\n+\n+// SawSIGIO returns whether we saw a SIGIO within a brief pause.\n+//export SawSIGIO\n+func SawSIGIO() C.int {\n+\tselect {\n+\tcase <-sigioChan:\n+\t\treturn 1\n+\tcase <-time.After(100 * time.Millisecond):\n+\t\treturn 0\n+\t}\n+}\n+\n+func main() {\n+}"}, {"sha": "8cc1895f99f5af31f95d351d83e03710627fd7b4", "filename": "libgo/misc/cgo/testcarchive/src/libgo4/libgo4.go", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fsrc%2Flibgo4%2Flibgo4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fsrc%2Flibgo4%2Flibgo4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fsrc%2Flibgo4%2Flibgo4.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+/*\n+#include <signal.h>\n+#include <pthread.h>\n+\n+// Raise SIGIO.\n+static void CRaiseSIGIO(pthread_t* p) {\n+\tpthread_kill(*p, SIGIO);\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"os\"\n+\t\"os/signal\"\n+\t\"sync/atomic\"\n+\t\"syscall\"\n+)\n+\n+var sigioCount int32\n+\n+// Catch SIGIO.\n+//export GoCatchSIGIO\n+func GoCatchSIGIO() {\n+\tc := make(chan os.Signal, 1)\n+\tsignal.Notify(c, syscall.SIGIO)\n+\tgo func() {\n+\t\tfor range c {\n+\t\t\tatomic.AddInt32(&sigioCount, 1)\n+\t\t}\n+\t}()\n+}\n+\n+// Raise SIGIO.\n+//export GoRaiseSIGIO\n+func GoRaiseSIGIO(p *C.pthread_t) {\n+\tC.CRaiseSIGIO(p)\n+}\n+\n+// Return the number of SIGIO signals seen.\n+//export SIGIOCount\n+func SIGIOCount() C.int {\n+\treturn C.int(atomic.LoadInt32(&sigioCount))\n+}\n+\n+func main() {\n+}"}, {"sha": "82b445c12109cb3a01f3ec59a2534d5d97768a3e", "filename": "libgo/misc/cgo/testcarchive/src/p/p.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fsrc%2Fp%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fsrc%2Fp%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcarchive%2Fsrc%2Fp%2Fp.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,10 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+import \"C\"\n+\n+//export FromPkg\n+func FromPkg() int32 { return 1024 }"}, {"sha": "1274b8950ebef787ed16f8c7e487ad7a58af4cb5", "filename": "libgo/misc/cgo/testcshared/main0.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fmain0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fmain0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fmain0.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include <stdint.h>\n+#include <stdio.h>\n+\n+#include \"p.h\"\n+#include \"libgo.h\"\n+\n+// Tests libgo.so to export the following functions.\n+//   int8_t DidInitRun();\n+//   int8_t DidMainRun();\n+//   int32_t FromPkg();\n+int main(void) {\n+  int8_t ran_init = DidInitRun();\n+  if (!ran_init) {\n+    fprintf(stderr, \"ERROR: DidInitRun returned unexpected results: %d\\n\",\n+            ran_init);\n+    return 1;\n+  }\n+  int8_t ran_main = DidMainRun();\n+  if (ran_main) {\n+    fprintf(stderr, \"ERROR: DidMainRun returned unexpected results: %d\\n\",\n+            ran_main);\n+    return 1;\n+  }\n+  int32_t from_pkg = FromPkg();\n+  if (from_pkg != 1024) {\n+    fprintf(stderr, \"ERROR: FromPkg=%d, want %d\\n\", from_pkg, 1024);\n+    return 1;\n+  }\n+  // test.bash looks for \"PASS\" to ensure this program has reached the end. \n+  printf(\"PASS\\n\");\n+  return 0;\n+}"}, {"sha": "420dd1ea97459aa7cf26dd2a1d56e892a6d279f6", "filename": "libgo/misc/cgo/testcshared/main1.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fmain1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fmain1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fmain1.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <dlfcn.h>\n+\n+int check_int8(void* handle, const char* fname, int8_t want) {\n+  int8_t (*fn)();\n+  fn = (int8_t (*)())dlsym(handle, fname);\n+  if (!fn) {\n+    fprintf(stderr, \"ERROR: missing %s: %s\\n\", fname, dlerror());\n+    return 1;\n+  }\n+  signed char ret = fn();\n+  if (ret != want) {\n+    fprintf(stderr, \"ERROR: %s=%d, want %d\\n\", fname, ret, want);\n+    return 1;\n+  }\n+  return 0;\n+}\n+\n+int check_int32(void* handle, const char* fname, int32_t want) {\n+  int32_t (*fn)();\n+  fn = (int32_t (*)())dlsym(handle, fname);\n+  if (!fn) {\n+    fprintf(stderr, \"ERROR: missing %s: %s\\n\", fname, dlerror());\n+    return 1;\n+  }\n+  int32_t ret = fn();\n+  if (ret != want) {\n+    fprintf(stderr, \"ERROR: %s=%d, want %d\\n\", fname, ret, want);\n+    return 1;\n+  }\n+  return 0;\n+}\n+\n+// Tests libgo.so to export the following functions.\n+//   int8_t DidInitRun() // returns true\n+//   int8_t DidMainRun() // returns true\n+//   int32_t FromPkg() // returns 1024\n+int main(int argc, char** argv) {\n+  void* handle = dlopen(argv[1], RTLD_LAZY | RTLD_GLOBAL);\n+  if (!handle) {\n+    fprintf(stderr, \"ERROR: failed to open the shared library: %s\\n\",\n+\t\t    dlerror());\n+    return 2;\n+  }\n+\n+  int ret = 0;\n+  ret = check_int8(handle, \"DidInitRun\", 1);\n+  if (ret != 0) {\n+    return ret;\n+  }\n+\n+  ret = check_int8(handle, \"DidMainRun\", 0);\n+  if (ret != 0) {\n+    return ret;\n+  }\n+\n+  ret = check_int32(handle, \"FromPkg\", 1024);\n+  if (ret != 0) {\n+   return ret;\n+  }\n+  // test.bash looks for \"PASS\" to ensure this program has reached the end. \n+  printf(\"PASS\\n\");\n+  return 0;\n+}"}, {"sha": "6e8bf141cafa81ea340b12112395d3d163518421", "filename": "libgo/misc/cgo/testcshared/main2.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fmain2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fmain2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fmain2.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include <errno.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <time.h>\n+#include <unistd.h>\n+\n+#define fd (100)\n+\n+// Tests libgo2.so, which does not export any functions.\n+// Read a string from the file descriptor and print it.\n+int main(void) {\n+  int i;\n+  ssize_t n;\n+  char buf[20];\n+  struct timespec ts;\n+\n+  // The descriptor will be initialized in a thread, so we have to\n+  // give a chance to get opened.\n+  for (i = 0; i < 1000; i++) {\n+    n = read(fd, buf, sizeof buf);\n+    if (n >= 0)\n+      break;\n+    if (errno != EBADF && errno != EINVAL) {\n+      fprintf(stderr, \"BUG: read: %s\\n\", strerror(errno));\n+      return 2;\n+    }\n+\n+    // An EBADF error means that the shared library has not opened the\n+    // descriptor yet.\n+    ts.tv_sec = 0;\n+    ts.tv_nsec = 1000000;\n+    nanosleep(&ts, NULL);\n+  }\n+\n+  if (n < 0) {\n+    fprintf(stderr, \"BUG: failed to read any data from pipe\\n\");\n+    return 2;\n+  }\n+\n+  if (n == 0) {\n+    fprintf(stderr, \"BUG: unexpected EOF\\n\");\n+    return 2;\n+  }\n+\n+  if (n == sizeof buf) {\n+    n--;\n+  }\n+  buf[n] = '\\0';\n+  printf(\"%s\\n\", buf);\n+  return 0;\n+}"}, {"sha": "49cc0558a01a328b59959ba25724b6bcf5962dc3", "filename": "libgo/misc/cgo/testcshared/main3.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fmain3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fmain3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fmain3.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <dlfcn.h>\n+\n+// Tests \"main.main\" is exported on android/arm,\n+// which golang.org/x/mobile/app depends on.\n+int main(int argc, char** argv) {\n+  void* handle = dlopen(argv[1], RTLD_LAZY | RTLD_GLOBAL);\n+  if (!handle) {\n+    fprintf(stderr, \"ERROR: failed to open the shared library: %s\\n\",\n+            dlerror());\n+    return 2;\n+  }\n+\n+  uintptr_t main_fn = (uintptr_t)dlsym(handle, \"main.main\");\n+  if (!main_fn) {\n+    fprintf(stderr, \"ERROR: missing main.main: %s\\n\", dlerror());\n+    return 2;\n+  }\n+\n+  // TODO(hyangah): check that main.main can run.\n+\n+  printf(\"PASS\\n\");\n+  return 0;\n+}"}, {"sha": "355cdefb0174ec7670f0f5690c97f635759ed99b", "filename": "libgo/misc/cgo/testcshared/main4.c", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fmain4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fmain4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fmain4.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,215 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test that a signal handler that uses up stack space does not crash\n+// if the signal is delivered to a thread running a goroutine.\n+// This is a lot like misc/cgo/testcarchive/main2.c.\n+\n+#include <setjmp.h>\n+#include <signal.h>\n+#include <stddef.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n+#include <sched.h>\n+#include <time.h>\n+#include <dlfcn.h>\n+\n+static void die(const char* msg) {\n+\tperror(msg);\n+\texit(EXIT_FAILURE);\n+}\n+\n+static volatile sig_atomic_t sigioSeen;\n+\n+// Use up some stack space.\n+static void recur(int i, char *p) {\n+\tchar a[1024];\n+\n+\t*p = '\\0';\n+\tif (i > 0) {\n+\t\trecur(i - 1, a);\n+\t}\n+}\n+\n+// Signal handler that uses up more stack space than a goroutine will have.\n+static void ioHandler(int signo, siginfo_t* info, void* ctxt) {\n+\tchar a[1024];\n+\n+\trecur(4, a);\n+\tsigioSeen = 1;\n+}\n+\n+static jmp_buf jmp;\n+static char* nullPointer;\n+\n+// Signal handler for SIGSEGV on a C thread.\n+static void segvHandler(int signo, siginfo_t* info, void* ctxt) {\n+\tsigset_t mask;\n+\tint i;\n+\n+\tif (sigemptyset(&mask) < 0) {\n+\t\tdie(\"sigemptyset\");\n+\t}\n+\tif (sigaddset(&mask, SIGSEGV) < 0) {\n+\t\tdie(\"sigaddset\");\n+\t}\n+\ti = sigprocmask(SIG_UNBLOCK, &mask, NULL);\n+\tif (i != 0) {\n+\t\tfprintf(stderr, \"sigprocmask: %s\\n\", strerror(i));\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\t// Don't try this at home.\n+\tlongjmp(jmp, signo);\n+\n+\t// We should never get here.\n+\tabort();\n+}\n+\n+int main(int argc, char** argv) {\n+\tint verbose;\n+\tstruct sigaction sa;\n+\tvoid* handle;\n+\tvoid (*fn)(void);\n+\tsigset_t mask;\n+\tint i;\n+\tstruct timespec ts;\n+\n+\tverbose = argc > 2;\n+\tsetvbuf(stdout, NULL, _IONBF, 0);\n+\n+\t// Call setsid so that we can use kill(0, SIGIO) below.\n+\t// Don't check the return value so that this works both from\n+\t// a job control shell and from a shell script.\n+\tsetsid();\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling sigaction\\n\");\n+\t}\n+\n+\tmemset(&sa, 0, sizeof sa);\n+\tsa.sa_sigaction = ioHandler;\n+\tif (sigemptyset(&sa.sa_mask) < 0) {\n+\t\tdie(\"sigemptyset\");\n+\t}\n+\tsa.sa_flags = SA_SIGINFO;\n+\tif (sigaction(SIGIO, &sa, NULL) < 0) {\n+\t\tdie(\"sigaction\");\n+\t}\n+\n+\tsa.sa_sigaction = segvHandler;\n+\tif (sigaction(SIGSEGV, &sa, NULL) < 0 || sigaction(SIGBUS, &sa, NULL) < 0) {\n+\t\tdie(\"sigaction\");\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling dlopen\\n\");\n+\t}\n+\n+\thandle = dlopen(argv[1], RTLD_NOW | RTLD_GLOBAL);\n+\tif (handle == NULL) {\n+\t\tfprintf(stderr, \"%s\\n\", dlerror());\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling dlsym\\n\");\n+\t}\n+\n+\t// Start some goroutines.\n+\tfn = (void(*)(void))dlsym(handle, \"RunGoroutines\");\n+\tif (fn == NULL) {\n+\t\tfprintf(stderr, \"%s\\n\", dlerror());\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling RunGoroutines\\n\");\n+\t}\n+\n+\tfn();\n+\n+\t// Block SIGIO in this thread to make it more likely that it\n+\t// will be delivered to a goroutine.\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling pthread_sigmask\\n\");\n+\t}\n+\n+\tif (sigemptyset(&mask) < 0) {\n+\t\tdie(\"sigemptyset\");\n+\t}\n+\tif (sigaddset(&mask, SIGIO) < 0) {\n+\t\tdie(\"sigaddset\");\n+\t}\n+\ti = pthread_sigmask(SIG_BLOCK, &mask, NULL);\n+\tif (i != 0) {\n+\t\tfprintf(stderr, \"pthread_sigmask: %s\\n\", strerror(i));\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling kill\\n\");\n+\t}\n+\n+\tif (kill(0, SIGIO) < 0) {\n+\t\tdie(\"kill\");\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"waiting for sigioSeen\\n\");\n+\t}\n+\n+\t// Wait until the signal has been delivered.\n+\ti = 0;\n+\twhile (!sigioSeen) {\n+\t\tts.tv_sec = 0;\n+\t\tts.tv_nsec = 1000000;\n+\t\tnanosleep(&ts, NULL);\n+\t\ti++;\n+\t\tif (i > 5000) {\n+\t\t\tfprintf(stderr, \"looping too long waiting for signal\\n\");\n+\t\t\texit(EXIT_FAILURE);\n+\t\t}\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling setjmp\\n\");\n+\t}\n+\n+\t// Test that a SIGSEGV on this thread is delivered to us.\n+\tif (setjmp(jmp) == 0) {\n+\t\tif (verbose) {\n+\t\t\tprintf(\"triggering SIGSEGV\\n\");\n+\t\t}\n+\n+\t\t*nullPointer = '\\0';\n+\n+\t\tfprintf(stderr, \"continued after address error\\n\");\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling dlsym\\n\");\n+\t}\n+\n+\t// Make sure that a SIGSEGV in Go causes a run-time panic.\n+\tfn = (void (*)(void))dlsym(handle, \"TestSEGV\");\n+\tif (fn == NULL) {\n+\t\tfprintf(stderr, \"%s\\n\", dlerror());\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling TestSEGV\\n\");\n+\t}\n+\n+\tfn();\n+\n+\tprintf(\"PASS\\n\");\n+\treturn 0;\n+}"}, {"sha": "1bc99101d7a38d6da94f33c14124a17ebd4ee16f", "filename": "libgo/misc/cgo/testcshared/main5.c", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fmain5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fmain5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fmain5.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,199 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Test that a signal handler works in non-Go code when using\n+// os/signal.Notify.\n+// This is a lot like misc/cgo/testcarchive/main3.c.\n+\n+#include <signal.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <time.h>\n+#include <sched.h>\n+#include <dlfcn.h>\n+\n+static void die(const char* msg) {\n+\tperror(msg);\n+\texit(EXIT_FAILURE);\n+}\n+\n+static volatile sig_atomic_t sigioSeen;\n+\n+static void ioHandler(int signo, siginfo_t* info, void* ctxt) {\n+\tsigioSeen = 1;\n+}\n+\n+int main(int argc, char** argv) {\n+\tint verbose;\n+\tstruct sigaction sa;\n+\tvoid* handle;\n+\tvoid (*fn1)(void);\n+\tint (*sawSIGIO)(void);\n+\tint i;\n+\tstruct timespec ts;\n+\n+\tverbose = argc > 2;\n+\tsetvbuf(stdout, NULL, _IONBF, 0);\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling sigaction\\n\");\n+\t}\n+\n+\tmemset(&sa, 0, sizeof sa);\n+\tsa.sa_sigaction = ioHandler;\n+\tif (sigemptyset(&sa.sa_mask) < 0) {\n+\t\tdie(\"sigemptyset\");\n+\t}\n+\tsa.sa_flags = SA_SIGINFO;\n+\tif (sigaction(SIGIO, &sa, NULL) < 0) {\n+\t\tdie(\"sigaction\");\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling dlopen\\n\");\n+\t}\n+\n+\thandle = dlopen(argv[1], RTLD_NOW | RTLD_GLOBAL);\n+\tif (handle == NULL) {\n+\t\tfprintf(stderr, \"%s\\n\", dlerror());\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\t// At this point there should not be a Go signal handler\n+\t// installed for SIGIO.\n+\n+\tif (verbose) {\n+\t\tprintf(\"raising SIGIO\\n\");\n+\t}\n+\n+\tif (raise(SIGIO) < 0) {\n+\t\tdie(\"raise\");\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"waiting for sigioSeen\\n\");\n+\t}\n+\n+\t// Wait until the signal has been delivered.\n+\ti = 0;\n+\twhile (!sigioSeen) {\n+\t\tts.tv_sec = 0;\n+\t\tts.tv_nsec = 1000000;\n+\t\tnanosleep(&ts, NULL);\n+\t\ti++;\n+\t\tif (i > 5000) {\n+\t\t\tfprintf(stderr, \"looping too long waiting for signal\\n\");\n+\t\t\texit(EXIT_FAILURE);\n+\t\t}\n+\t}\n+\n+\tsigioSeen = 0;\n+\n+\t// Tell the Go code to catch SIGIO.\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling dlsym\\n\");\n+\t}\n+\n+\tfn1 = (void(*)(void))dlsym(handle, \"CatchSIGIO\");\n+\tif (fn1 == NULL) {\n+\t\tfprintf(stderr, \"%s\\n\", dlerror());\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling CatchSIGIO\\n\");\n+\t}\n+\n+\tfn1();\n+\n+\tif (verbose) {\n+\t\tprintf(\"raising SIGIO\\n\");\n+\t}\n+\n+\tif (raise(SIGIO) < 0) {\n+\t\tdie(\"raise\");\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling dlsym\\n\");\n+\t}\n+\n+\t// Check that the Go code saw SIGIO.\n+\tsawSIGIO = (int (*)(void))dlsym(handle, \"SawSIGIO\");\n+\tif (sawSIGIO == NULL) {\n+\t\tfprintf(stderr, \"%s\\n\", dlerror());\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling SawSIGIO\\n\");\n+\t}\n+\n+\tif (!sawSIGIO()) {\n+\t\tfprintf(stderr, \"Go handler did not see SIGIO\\n\");\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\tif (sigioSeen != 0) {\n+\t\tfprintf(stderr, \"C handler saw SIGIO when only Go handler should have\\n\");\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\t// Tell the Go code to stop catching SIGIO.\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling dlsym\\n\");\n+\t}\n+\n+\tfn1 = (void(*)(void))dlsym(handle, \"ResetSIGIO\");\n+\tif (fn1 == NULL) {\n+\t\tfprintf(stderr, \"%s\\n\", dlerror());\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling ResetSIGIO\\n\");\n+\t}\n+\n+\tfn1();\n+\n+\tif (verbose) {\n+\t\tprintf(\"raising SIGIO\\n\");\n+\t}\n+\n+\tif (raise(SIGIO) < 0) {\n+\t\tdie(\"raise\");\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"calling SawSIGIO\\n\");\n+\t}\n+\n+\tif (sawSIGIO()) {\n+\t\tfprintf(stderr, \"Go handler saw SIGIO after Reset\\n\");\n+\t\texit(EXIT_FAILURE);\n+\t}\n+\n+\tif (verbose) {\n+\t\tprintf(\"waiting for sigioSeen\\n\");\n+\t}\n+\n+\t// Wait until the signal has been delivered.\n+\ti = 0;\n+\twhile (!sigioSeen) {\n+\t\tts.tv_sec = 0;\n+\t\tts.tv_nsec = 1000000;\n+\t\tnanosleep(&ts, NULL);\n+\t\ti++;\n+\t\tif (i > 5000) {\n+\t\t\tfprintf(stderr, \"looping too long waiting for signal\\n\");\n+\t\t\texit(EXIT_FAILURE);\n+\t\t}\n+\t}\n+\n+\tprintf(\"PASS\\n\");\n+\treturn 0;\n+}"}, {"sha": "8a4bf795e9146586cf83da0140ab0579327773bd", "filename": "libgo/misc/cgo/testcshared/src/libgo/libgo.go", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Flibgo%2Flibgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Flibgo%2Flibgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Flibgo%2Flibgo.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t_ \"p\"\n+\t\"syscall\"\n+\t\"time\"\n+)\n+\n+import \"C\"\n+\n+var initCh = make(chan int, 1)\n+var ranMain bool\n+\n+func init() {\n+\t// emulate an exceedingly slow package initialization function\n+\ttime.Sleep(100 * time.Millisecond)\n+\tinitCh <- 42\n+}\n+\n+func main() {\n+\tranMain = true\n+}\n+\n+//export DidInitRun\n+func DidInitRun() bool {\n+\tselect {\n+\tcase x := <-initCh:\n+\t\tif x != 42 {\n+\t\t\t// Just in case initCh was not correctly made.\n+\t\t\tprintln(\"want init value of 42, got: \", x)\n+\t\t\tsyscall.Exit(2)\n+\t\t}\n+\t\treturn true\n+\tdefault:\n+\t\treturn false\n+\t}\n+}\n+\n+//export DidMainRun\n+func DidMainRun() bool {\n+\treturn ranMain\n+}"}, {"sha": "d18f0b130d3f767671e4030fd34056c85c4bd132", "filename": "libgo/misc/cgo/testcshared/src/libgo2/dup2.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Flibgo2%2Fdup2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Flibgo2%2Fdup2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Flibgo2%2Fdup2.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin dragonfly freebsd linux,!arm64 netbsd openbsd\n+\n+package main\n+\n+import \"syscall\"\n+\n+func dup2(oldfd, newfd int) error {\n+\treturn syscall.Dup2(oldfd, newfd)\n+}"}, {"sha": "c9c65a6e3c1f62be51add7bc6c129cb92dabe2b3", "filename": "libgo/misc/cgo/testcshared/src/libgo2/dup3.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Flibgo2%2Fdup3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Flibgo2%2Fdup3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Flibgo2%2Fdup3.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux,arm64\n+\n+package main\n+\n+import \"syscall\"\n+\n+func dup2(oldfd, newfd int) error {\n+\treturn syscall.Dup3(oldfd, newfd, 0)\n+}"}, {"sha": "1b69d8f09fa33c8f161037bc9260e10f4cf97463", "filename": "libgo/misc/cgo/testcshared/src/libgo2/libgo2.go", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Flibgo2%2Flibgo2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Flibgo2%2Flibgo2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Flibgo2%2Flibgo2.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin dragonfly freebsd linux netbsd openbsd solaris\n+\n+package main\n+\n+// Test a shared library created by -buildmode=c-shared that does not\n+// export anything.\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+// To test this we want to communicate between the main program and\n+// the shared library without using any exported symbols.  The init\n+// function creates a pipe and Dups the read end to a known number\n+// that the C code can also use.\n+\n+const (\n+\tfd = 100\n+)\n+\n+func init() {\n+\tvar p [2]int\n+\tif e := syscall.Pipe(p[0:]); e != nil {\n+\t\tfmt.Fprintf(os.Stderr, \"pipe: %v\\n\", e)\n+\t\tos.Exit(2)\n+\t}\n+\n+\tif e := dup2(p[0], fd); e != nil {\n+\t\tfmt.Fprintf(os.Stderr, \"dup2: %v\\n\", e)\n+\t\tos.Exit(2)\n+\t}\n+\n+\tconst str = \"PASS\"\n+\tif n, e := syscall.Write(p[1], []byte(str)); e != nil || n != len(str) {\n+\t\tfmt.Fprintf(os.Stderr, \"write: %d %v\\n\", n, e)\n+\t\tos.Exit(2)\n+\t}\n+\n+\tif e := syscall.Close(p[1]); e != nil {\n+\t\tfmt.Fprintf(os.Stderr, \"close: %v\\n\", e)\n+\t\tos.Exit(2)\n+\t}\n+}\n+\n+func main() {\n+}"}, {"sha": "ab40b75e78a649f945bdf8f6831c9d32793d3ade", "filename": "libgo/misc/cgo/testcshared/src/libgo4/libgo4.go", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Flibgo4%2Flibgo4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Flibgo4%2Flibgo4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Flibgo4%2Flibgo4.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"C\"\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"runtime\"\n+)\n+\n+// RunGoroutines starts some goroutines that don't do anything.\n+// The idea is to get some threads going, so that a signal will be delivered\n+// to a thread started by Go.\n+//export RunGoroutines\n+func RunGoroutines() {\n+\tfor i := 0; i < 4; i++ {\n+\t\tgo func() {\n+\t\t\truntime.LockOSThread()\n+\t\t\tselect {}\n+\t\t}()\n+\t}\n+}\n+\n+var P *byte\n+\n+// TestSEGV makes sure that an invalid address turns into a run-time Go panic.\n+//export TestSEGV\n+func TestSEGV() {\n+\tdefer func() {\n+\t\tif recover() == nil {\n+\t\t\tfmt.Fprintln(os.Stderr, \"no panic from segv\")\n+\t\t\tos.Exit(1)\n+\t\t}\n+\t}()\n+\t*P = 0\n+\tfmt.Fprintln(os.Stderr, \"continued after segv\")\n+\tos.Exit(1)\n+}\n+\n+func main() {\n+}"}, {"sha": "94e5d21c14a83c3019ef4ba09b17fc3222e7e7be", "filename": "libgo/misc/cgo/testcshared/src/libgo5/libgo5.go", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Flibgo5%2Flibgo5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Flibgo5%2Flibgo5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Flibgo5%2Flibgo5.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"C\"\n+\n+import (\n+\t\"os\"\n+\t\"os/signal\"\n+\t\"syscall\"\n+\t\"time\"\n+)\n+\n+// The channel used to read SIGIO signals.\n+var sigioChan chan os.Signal\n+\n+// CatchSIGIO starts catching SIGIO signals.\n+//export CatchSIGIO\n+func CatchSIGIO() {\n+\tsigioChan = make(chan os.Signal, 1)\n+\tsignal.Notify(sigioChan, syscall.SIGIO)\n+}\n+\n+// ResetSIGIO stops catching SIGIO signals.\n+//export ResetSIGIO\n+func ResetSIGIO() {\n+\tsignal.Reset(syscall.SIGIO)\n+}\n+\n+// SawSIGIO returns whether we saw a SIGIO within a brief pause.\n+//export SawSIGIO\n+func SawSIGIO() C.int {\n+\tselect {\n+\tcase <-sigioChan:\n+\t\treturn 1\n+\tcase <-time.After(100 * time.Millisecond):\n+\t\treturn 0\n+\t}\n+}\n+\n+func main() {\n+}"}, {"sha": "82b445c12109cb3a01f3ec59a2534d5d97768a3e", "filename": "libgo/misc/cgo/testcshared/src/p/p.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Fp%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Fp%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Fsrc%2Fp%2Fp.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,10 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+import \"C\"\n+\n+//export FromPkg\n+func FromPkg() int32 { return 1024 }"}, {"sha": "0315fb07f577644b6d53db6b940e04c8eb455482", "filename": "libgo/misc/cgo/testcshared/test.bash", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Ftest.bash", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Ftest.bash", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestcshared%2Ftest.bash?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,193 @@\n+#!/usr/bin/env bash\n+# Copyright 2015 The Go Authors. All rights reserved.\n+# Use of this source code is governed by a BSD-style\n+# license that can be found in the LICENSE file.\n+\n+# For testing Android, this script requires adb to push and run compiled\n+# binaries on a target device.\n+\n+set -e\n+\n+if [ ! -f src/libgo/libgo.go ]; then\n+\tcwd=$(pwd)\n+\techo \"misc/cgo/testcshared/test.bash is running in $cwd\" 1>&2\n+\texit 1\n+fi\n+\n+goos=$(go env GOOS)\n+goarch=$(go env GOARCH)\n+goroot=$(go env GOROOT)\n+if [ ! -d \"$goroot\" ]; then\n+\techo 'misc/cgo/testcshared/test.bash cannot find GOROOT' 1>&2\n+\techo '$GOROOT:' \"$GOROOT\" 1>&2\n+\techo 'go env GOROOT:' \"$goroot\" 1>&2\n+\texit 1\n+fi\n+\n+# Directory where cgo headers and outputs will be installed.\n+# The installation directory format varies depending on the platform.\n+installdir=pkg/${goos}_${goarch}_testcshared_shared\n+if [ \"${goos}\" == \"darwin\" ]; then\n+\tinstalldir=pkg/${goos}_${goarch}_testcshared\n+fi\n+\n+# Temporary directory on the android device.\n+androidpath=/data/local/tmp/testcshared-$$\n+\n+function cleanup() {\n+\trm -f libgo.$libext libgo2.$libext libgo4.$libext libgo5.$libext\n+\trm -f libgo.h libgo4.h libgo5.h\n+\trm -f testp testp2 testp3 testp4 testp5\n+\trm -rf pkg \"${goroot}/${installdir}\"\n+\n+\tif [ \"$goos\" == \"android\" ]; then\n+\t\tadb shell rm -rf \"$androidpath\"\n+\tfi\n+}\n+trap cleanup EXIT\n+\n+if [ \"$goos\" == \"android\" ]; then\n+\tadb shell mkdir -p \"$androidpath\"\n+fi\n+\n+function run() {\n+\tcase \"$goos\" in\n+\t\"android\")\n+\t\tlocal args=$@\n+\t\toutput=$(adb shell \"cd ${androidpath}; $@\")\n+\t\toutput=$(echo $output|tr -d '\\r')\n+\t\tcase $output in\n+\t\t\t*PASS) echo \"PASS\";; \n+\t\t\t*) echo \"$output\";;\n+\t\tesac\n+\t\t;;\n+\t*)\n+\t\techo $(env $@)\n+\t\t;;\n+\tesac\n+}\n+\n+function binpush() {\n+\tbin=${1}\n+\tif [ \"$goos\" == \"android\" ]; then\n+\t\tadb push \"$bin\"  \"${androidpath}/${bin}\" 2>/dev/null\n+\tfi\n+}\n+\n+rm -rf pkg\n+\n+suffix=\"-installsuffix testcshared\"\n+\n+libext=\"so\"\n+if [ \"$goos\" == \"darwin\" ]; then\n+\tlibext=\"dylib\"\n+fi\n+\n+# Create the header files.\n+GOPATH=$(pwd) go install -buildmode=c-shared $suffix libgo\n+\n+GOPATH=$(pwd) go build -buildmode=c-shared $suffix -o libgo.$libext src/libgo/libgo.go\n+binpush libgo.$libext\n+\n+if [ \"$goos\" == \"linux\" ] || [ \"$goos\" == \"android\" ] ; then\n+    if readelf -d libgo.$libext | grep TEXTREL >/dev/null; then\n+        echo \"libgo.$libext has TEXTREL set\"\n+        exit 1\n+    fi\n+fi\n+\n+GOGCCFLAGS=$(go env GOGCCFLAGS)\n+if [ \"$goos\" == \"android\" ]; then\n+\tGOGCCFLAGS=\"${GOGCCFLAGS} -pie\"\n+fi\n+\n+status=0\n+\n+# test0: exported symbols in shared lib are accessible.\n+# TODO(iant): using _shared here shouldn't really be necessary.\n+$(go env CC) ${GOGCCFLAGS} -I ${installdir} -o testp main0.c ./libgo.$libext\n+binpush testp\n+\n+output=$(run LD_LIBRARY_PATH=. ./testp)\n+if [ \"$output\" != \"PASS\" ]; then\n+\techo \"FAIL test0 got ${output}\"\n+\tstatus=1\n+fi\n+\n+# test1: shared library can be dynamically loaded and exported symbols are accessible.\n+$(go env CC) ${GOGCCFLAGS} -o testp main1.c -ldl\n+binpush testp\n+output=$(run ./testp ./libgo.$libext)\n+if [ \"$output\" != \"PASS\" ]; then\n+\techo \"FAIL test1 got ${output}\"\n+\tstatus=1\n+fi\n+\n+# test2: tests libgo2 which does not export any functions.\n+GOPATH=$(pwd) go build -buildmode=c-shared $suffix -o libgo2.$libext libgo2\n+binpush libgo2.$libext\n+linkflags=\"-Wl,--no-as-needed\"\n+if [ \"$goos\" == \"darwin\" ]; then\n+\tlinkflags=\"\"\n+fi\n+$(go env CC) ${GOGCCFLAGS} -o testp2 main2.c $linkflags libgo2.$libext\n+binpush testp2\n+output=$(run LD_LIBRARY_PATH=. ./testp2)\n+if [ \"$output\" != \"PASS\" ]; then\n+\techo \"FAIL test2 got ${output}\"\n+\tstatus=1\n+fi\n+\n+# test3: tests main.main is exported on android.\n+if [ \"$goos\" == \"android\" ]; then\n+\t$(go env CC) ${GOGCCFLAGS} -o testp3 main3.c -ldl\n+\tbinpush testp3\n+\toutput=$(run ./testp ./libgo.so)\n+\tif [ \"$output\" != \"PASS\" ]; then\n+\t\techo \"FAIL test3 got ${output}\"\n+\t\tstatus=1\n+\tfi\n+fi\n+\n+# test4: tests signal handlers\n+GOPATH=$(pwd) go build -buildmode=c-shared $suffix -o libgo4.$libext libgo4\n+binpush libgo4.$libext\n+$(go env CC) ${GOGCCFLAGS} -pthread -o testp4 main4.c -ldl\n+binpush testp4\n+output=$(run ./testp4 ./libgo4.$libext 2>&1)\n+if test \"$output\" != \"PASS\"; then\n+    echo \"FAIL test4 got ${output}\"\n+    if test \"$goos\" != \"android\"; then\n+\techo \"re-running test4 in verbose mode\"\n+\t./testp4 ./libgo4.$libext verbose\n+    fi\n+    status=1\n+fi\n+\n+# test5: tests signal handlers with os/signal.Notify\n+GOPATH=$(pwd) go build -buildmode=c-shared $suffix -o libgo5.$libext libgo5\n+binpush libgo5.$libext\n+$(go env CC) ${GOGCCFLAGS} -pthread -o testp5 main5.c -ldl\n+binpush testp5\n+output=$(run ./testp5 ./libgo5.$libext 2>&1)\n+if test \"$output\" != \"PASS\"; then\n+    echo \"FAIL test5 got ${output}\"\n+    if test \"$goos\" != \"android\"; then\n+\techo \"re-running test5 in verbose mode\"\n+\t./testp5 ./libgo5.$libext verbose\n+    fi\n+    status=1\n+fi\n+\n+if test \"$libext\" = \"dylib\"; then\n+\t# make sure dylibs are well-formed\n+\tif ! otool -l libgo*.dylib >/dev/null; then\n+\t\tstatus=1\n+\tfi\n+fi\n+\n+if test $status = 0; then\n+    echo \"ok\"\n+fi\n+\n+exit $status"}, {"sha": "18840f2577c2313498af26f3572f1357a2d4f138", "filename": "libgo/misc/cgo/testgodefs/anonunion.go", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Fanonunion.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Fanonunion.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Fanonunion.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+//\n+// +build ignore\n+\n+package main\n+\n+// This file tests that when cgo -godefs sees a struct with a field\n+// that is an anonymous union, the first field in the union is\n+// promoted to become a field of the struct.  See issue 6677 for\n+// background.\n+\n+/*\n+typedef struct {\n+\tunion {\n+\t\tlong l;\n+\t\tint c;\n+\t};\n+} t;\n+*/\n+import \"C\"\n+\n+// Input for cgo -godefs.\n+\n+type T C.t"}, {"sha": "232144617118a36fe7022a9caa30e76e5522f781", "filename": "libgo/misc/cgo/testgodefs/issue8478.go", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Fissue8478.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Fissue8478.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Fissue8478.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+//\n+// +build ignore\n+\n+package main\n+\n+// Issue 8478.  Test that void* is consistently mapped to *byte.\n+\n+/*\n+typedef struct {\n+\tvoid *p;\n+\tvoid **q;\n+\tvoid ***r;\n+} s;\n+*/\n+import \"C\"\n+\n+type Issue8478 C.s"}, {"sha": "1ce0fd0d1e196472ca4c32ada4810e5283de2968", "filename": "libgo/misc/cgo/testgodefs/main.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Fmain.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// Test that the struct field in anonunion.go was promoted.\n+var v1 T\n+var v2 = v1.L\n+\n+// Test that P, Q, and R all point to byte.\n+var v3 = Issue8478{P: (*byte)(nil), Q: (**byte)(nil), R: (***byte)(nil)}\n+\n+func main() {\n+}"}, {"sha": "a82ff9328fe46a205b948d05c6f523e750b03a54", "filename": "libgo/misc/cgo/testgodefs/test.bash", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Ftest.bash", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Ftest.bash", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestgodefs%2Ftest.bash?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,22 @@\n+#!/usr/bin/env bash\n+\n+# Copyright 2014 The Go Authors. All rights reserved.\n+# Use of this source code is governed by a BSD-style\n+# license that can be found in the LICENSE file.\n+\n+# We are testing cgo -godefs, which translates Go files that use\n+# import \"C\" into Go files with Go definitions of types defined in the\n+# import \"C\" block.  Add more tests here.\n+FILE_PREFIXES=\"anonunion issue8478\"\n+\n+RM=\n+for FP in $FILE_PREFIXES\n+do\n+  go tool cgo -godefs -srcdir . ${FP}.go > ${FP}_defs.go\n+  RM=\"${RM} ${FP}_defs.go\"\n+done\n+\n+go build . && ./testgodefs\n+EXIT=$?\n+rm -rf _obj testgodefs ${RM}\n+exit $EXIT"}, {"sha": "505ba02b1f182b6c5d89de21b99cd76f66604d12", "filename": "libgo/misc/cgo/testplugin/altpath/src/common/common.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Faltpath%2Fsrc%2Fcommon%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Faltpath%2Fsrc%2Fcommon%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Faltpath%2Fsrc%2Fcommon%2Fcommon.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package common\n+\n+var X int\n+\n+func init() {\n+\tX = 4\n+}"}, {"sha": "8aacafc45303eebbe24c76ca5f5adecb09015231", "filename": "libgo/misc/cgo/testplugin/altpath/src/plugin-mismatch/main.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Faltpath%2Fsrc%2Fplugin-mismatch%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Faltpath%2Fsrc%2Fplugin-mismatch%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Faltpath%2Fsrc%2Fplugin-mismatch%2Fmain.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// // No C code required.\n+import \"C\"\n+\n+// The common package imported here does not match the common package\n+// imported by plugin1. A program that attempts to load plugin1 and\n+// plugin-mismatch should produce an error.\n+import \"common\"\n+\n+func ReadCommonX() int {\n+\treturn common.X\n+}"}, {"sha": "b064e6bccfe828194a6315ef0e3015e5e1c4e101", "filename": "libgo/misc/cgo/testplugin/src/common/common.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fcommon%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fcommon%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fcommon%2Fcommon.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package common\n+\n+var X int\n+\n+func init() {\n+\tX = 3\n+}"}, {"sha": "898f44efa154e967e026aefbbe14607d67259cca", "filename": "libgo/misc/cgo/testplugin/src/host/host.go", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fhost%2Fhost.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fhost%2Fhost.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fhost%2Fhost.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,148 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"log\"\n+\t\"path/filepath\"\n+\t\"plugin\"\n+\t\"strings\"\n+\n+\t\"common\"\n+)\n+\n+func init() {\n+\tcommon.X *= 5\n+}\n+\n+// testUnnamed tests that two plugins built with .go files passed on\n+// the command line do not have overlapping symbols. That is,\n+// unnamed1.so/FuncInt and unnamed2.so/FuncInt should be distinct functions.\n+func testUnnamed() {\n+\tp, err := plugin.Open(\"unnamed1.so\")\n+\tif err != nil {\n+\t\tlog.Fatalf(`plugin.Open(\"unnamed1.so\"): %v`, err)\n+\t}\n+\tfn, err := p.Lookup(\"FuncInt\")\n+\tif err != nil {\n+\t\tlog.Fatalf(`unnamed1.so: Lookup(\"FuncInt\") failed: %v`, err)\n+\t}\n+\tif got, want := fn.(func() int)(), 1; got != want {\n+\t\tlog.Fatalf(\"unnamed1.so: FuncInt()=%d, want %d\", got, want)\n+\t}\n+\n+\tp, err = plugin.Open(\"unnamed2.so\")\n+\tif err != nil {\n+\t\tlog.Fatalf(`plugin.Open(\"unnamed2.so\"): %v`, err)\n+\t}\n+\tfn, err = p.Lookup(\"FuncInt\")\n+\tif err != nil {\n+\t\tlog.Fatalf(`unnamed2.so: Lookup(\"FuncInt\") failed: %v`, err)\n+\t}\n+\tif got, want := fn.(func() int)(), 2; got != want {\n+\t\tlog.Fatalf(\"unnamed2.so: FuncInt()=%d, want %d\", got, want)\n+\t}\n+}\n+\n+func main() {\n+\tif got, want := common.X, 3*5; got != want {\n+\t\tlog.Fatalf(\"before plugin load common.X=%d, want %d\", got, want)\n+\t}\n+\n+\tp, err := plugin.Open(\"plugin1.so\")\n+\tif err != nil {\n+\t\tlog.Fatalf(\"plugin.Open failed: %v\", err)\n+\t}\n+\n+\tconst wantX = 3 * 5 * 7\n+\tif got := common.X; got != wantX {\n+\t\tlog.Fatalf(\"after plugin load common.X=%d, want %d\", got, wantX)\n+\t}\n+\n+\tseven, err := p.Lookup(\"Seven\")\n+\tif err != nil {\n+\t\tlog.Fatalf(`Lookup(\"Seven\") failed: %v`, err)\n+\t}\n+\tif got, want := *seven.(*int), 7; got != want {\n+\t\tlog.Fatalf(\"plugin1.Seven=%d, want %d\", got, want)\n+\t}\n+\n+\treadFunc, err := p.Lookup(\"ReadCommonX\")\n+\tif err != nil {\n+\t\tlog.Fatalf(`plugin1.Lookup(\"ReadCommonX\") failed: %v`, err)\n+\t}\n+\tif got := readFunc.(func() int)(); got != wantX {\n+\t\tlog.Fatalf(\"plugin1.ReadCommonX()=%d, want %d\", got, wantX)\n+\t}\n+\n+\t// sub/plugin1.so is a different plugin with the same name as\n+\t// the already loaded plugin. It also depends on common. Test\n+\t// that we can load the different plugin, it is actually\n+\t// different, and that it sees the same common package.\n+\tsubpPath, err := filepath.Abs(\"sub/plugin1.so\")\n+\tif err != nil {\n+\t\tlog.Fatalf(\"filepath.Abs(%q) failed: %v\", subpPath, err)\n+\t}\n+\tsubp, err := plugin.Open(subpPath)\n+\tif err != nil {\n+\t\tlog.Fatalf(\"plugin.Open(%q) failed: %v\", subpPath, err)\n+\t}\n+\n+\tfuncVar, err := subp.Lookup(\"FuncVar\")\n+\tif err != nil {\n+\t\tlog.Fatalf(`sub/plugin1.Lookup(\"FuncVar\") failed: %v`, err)\n+\t}\n+\tcalled := false\n+\t*funcVar.(*func()) = func() {\n+\t\tcalled = true\n+\t}\n+\n+\treadFunc, err = subp.Lookup(\"ReadCommonX\")\n+\tif err != nil {\n+\t\tlog.Fatalf(`sub/plugin1.Lookup(\"ReadCommonX\") failed: %v`, err)\n+\t}\n+\tif got := readFunc.(func() int)(); got != wantX {\n+\t\tlog.Fatalf(\"sub/plugin1.ReadCommonX()=%d, want %d\", got, wantX)\n+\t}\n+\tif !called {\n+\t\tlog.Fatal(\"calling ReadCommonX did not call FuncVar\")\n+\t}\n+\n+\tsubf, err := subp.Lookup(\"F\")\n+\tif err != nil {\n+\t\tlog.Fatalf(`sub/plugin1.Lookup(\"F\") failed: %v`, err)\n+\t}\n+\tif gotf := subf.(func() int)(); gotf != 17 {\n+\t\tlog.Fatalf(`sub/plugin1.F()=%d, want 17`, gotf)\n+\t}\n+\tf, err := p.Lookup(\"F\")\n+\tif err != nil {\n+\t\tlog.Fatalf(`plugin1.Lookup(\"F\") failed: %v`, err)\n+\t}\n+\tif gotf := f.(func() int)(); gotf != 3 {\n+\t\tlog.Fatalf(`plugin1.F()=%d, want 17`, gotf)\n+\t}\n+\n+\t// plugin2 has no exported symbols, only an init function.\n+\tif _, err := plugin.Open(\"plugin2.so\"); err != nil {\n+\t\tlog.Fatalf(\"plugin.Open failed: %v\", err)\n+\t}\n+\tif got, want := common.X, 2; got != want {\n+\t\tlog.Fatalf(\"after loading plugin2, common.X=%d, want %d\", got, want)\n+\t}\n+\n+\t_, err = plugin.Open(\"plugin-mismatch.so\")\n+\tif err == nil {\n+\t\tlog.Fatal(`plugin.Open(\"plugin-mismatch.so\"): should have failed`)\n+\t}\n+\tif s := err.Error(); !strings.Contains(s, \"different version\") {\n+\t\tlog.Fatalf(`plugin.Open(\"plugin-mismatch.so\"): error does not mention \"different version\": %v`, s)\n+\t}\n+\n+\ttestUnnamed()\n+\n+\tfmt.Println(\"PASS\")\n+}"}, {"sha": "5e7e4d8b4802141f2e81d2bbb7b9676e0af390e4", "filename": "libgo/misc/cgo/testplugin/src/iface/main.go", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fiface%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fiface%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fiface%2Fmain.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import (\n+\t\"iface_i\"\n+\t\"log\"\n+\t\"plugin\"\n+)\n+\n+func main() {\n+\ta, err := plugin.Open(\"iface_a.so\")\n+\tif err != nil {\n+\t\tlog.Fatalf(`plugin.Open(\"iface_a.so\"): %v`, err)\n+\t}\n+\tb, err := plugin.Open(\"iface_b.so\")\n+\tif err != nil {\n+\t\tlog.Fatalf(`plugin.Open(\"iface_b.so\"): %v`, err)\n+\t}\n+\n+\taf, err := a.Lookup(\"F\")\n+\tif err != nil {\n+\t\tlog.Fatalf(`a.Lookup(\"F\") failed: %v`, err)\n+\t}\n+\tbf, err := b.Lookup(\"F\")\n+\tif err != nil {\n+\t\tlog.Fatalf(`b.Lookup(\"F\") failed: %v`, err)\n+\t}\n+\tif af.(func() interface{})() != bf.(func() interface{})() {\n+\t\tpanic(\"empty interfaces not equal\")\n+\t}\n+\n+\tag, err := a.Lookup(\"G\")\n+\tif err != nil {\n+\t\tlog.Fatalf(`a.Lookup(\"G\") failed: %v`, err)\n+\t}\n+\tbg, err := b.Lookup(\"G\")\n+\tif err != nil {\n+\t\tlog.Fatalf(`b.Lookup(\"G\") failed: %v`, err)\n+\t}\n+\tif ag.(func() iface_i.I)() != bg.(func() iface_i.I)() {\n+\t\tpanic(\"nonempty interfaces not equal\")\n+\t}\n+}"}, {"sha": "29d2e2776406624d76965a420ce4e3fcc8b62d9c", "filename": "libgo/misc/cgo/testplugin/src/iface_a/a.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fiface_a%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fiface_a%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fiface_a%2Fa.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"iface_i\"\n+\n+//go:noinline\n+func F() interface{} {\n+\treturn (*iface_i.T)(nil)\n+}\n+\n+//go:noinline\n+func G() iface_i.I {\n+\treturn (*iface_i.T)(nil)\n+}"}, {"sha": "29d2e2776406624d76965a420ce4e3fcc8b62d9c", "filename": "libgo/misc/cgo/testplugin/src/iface_b/b.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fiface_b%2Fb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fiface_b%2Fb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fiface_b%2Fb.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"iface_i\"\n+\n+//go:noinline\n+func F() interface{} {\n+\treturn (*iface_i.T)(nil)\n+}\n+\n+//go:noinline\n+func G() iface_i.I {\n+\treturn (*iface_i.T)(nil)\n+}"}, {"sha": "31c80387c7e56c752e422fb73e81592d1a34c87b", "filename": "libgo/misc/cgo/testplugin/src/iface_i/i.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fiface_i%2Fi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fiface_i%2Fi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fiface_i%2Fi.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package iface_i\n+\n+type I interface {\n+\tM()\n+}\n+\n+type T struct {\n+}\n+\n+func (t *T) M() {\n+}\n+\n+// *T implements I"}, {"sha": "70fd054d089ee2cde6447298741454f25c3a0b37", "filename": "libgo/misc/cgo/testplugin/src/issue18676/dynamodbstreamsevt/definition.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fissue18676%2Fdynamodbstreamsevt%2Fdefinition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fissue18676%2Fdynamodbstreamsevt%2Fdefinition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fissue18676%2Fdynamodbstreamsevt%2Fdefinition.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package dynamodbstreamsevt\n+\n+import \"encoding/json\"\n+\n+var foo json.RawMessage\n+\n+type Event struct{}\n+\n+func (e *Event) Dummy() {}"}, {"sha": "c75409dafe7fd73e3a85401b158b5a1675d9d44a", "filename": "libgo/misc/cgo/testplugin/src/issue18676/main.go", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fissue18676%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fissue18676%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fissue18676%2Fmain.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// The bug happened like this:\n+// 1) The main binary adds an itab for *json.UnsupportedValueError / error\n+//    (concrete type / interface type).  This itab goes in hash bucket 0x111.\n+// 2) The plugin adds that same itab again.  That makes a cycle in the itab\n+//    chain rooted at hash bucket 0x111.\n+// 3) The main binary then asks for the itab for *dynamodbstreamsevt.Event /\n+//    json.Unmarshaler.  This itab happens to also live in bucket 0x111.\n+//    The lookup code goes into an infinite loop searching for this itab.\n+// The code is carefully crafted so that the two itabs are both from the\n+// same bucket, and so that the second itab doesn't exist in\n+// the itab hashmap yet (so the entire linked list must be searched).\n+package main\n+\n+import (\n+\t\"encoding/json\"\n+\t\"issue18676/dynamodbstreamsevt\"\n+\t\"plugin\"\n+)\n+\n+func main() {\n+\tplugin.Open(\"plugin.so\")\n+\n+\tvar x interface{} = (*dynamodbstreamsevt.Event)(nil)\n+\tif _, ok := x.(json.Unmarshaler); !ok {\n+\t\tprintln(\"something\")\n+\t}\n+}"}, {"sha": "8a3b85a75cd2a87ca8cb8b6fe623a37717da39a7", "filename": "libgo/misc/cgo/testplugin/src/issue18676/plugin.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fissue18676%2Fplugin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fissue18676%2Fplugin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fissue18676%2Fplugin.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"C\"\n+\n+import \"issue18676/dynamodbstreamsevt\"\n+\n+func F(evt *dynamodbstreamsevt.Event) {}"}, {"sha": "edcef2c77e9167fa6548b534bafc0d9dc2c4a319", "filename": "libgo/misc/cgo/testplugin/src/plugin1/plugin1.go", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fplugin1%2Fplugin1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fplugin1%2Fplugin1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fplugin1%2Fplugin1.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// // No C code required.\n+import \"C\"\n+\n+import \"common\"\n+\n+func F() int {\n+\t_ = make([]byte, 1<<21) // trigger stack unwind, Issue #18190.\n+\treturn 3\n+}\n+\n+func ReadCommonX() int {\n+\treturn common.X\n+}\n+\n+var Seven int\n+\n+func call(fn func()) {\n+\tfn()\n+}\n+\n+func g() {\n+\tcommon.X *= Seven\n+}\n+\n+func init() {\n+\tSeven = 7\n+\tcall(g)\n+}\n+\n+func main() {\n+\tpanic(\"plugin1.main called\")\n+}"}, {"sha": "9c507fc36581c7676052ed444c463198aa3621a4", "filename": "libgo/misc/cgo/testplugin/src/plugin2/plugin2.go", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fplugin2%2Fplugin2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fplugin2%2Fplugin2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fplugin2%2Fplugin2.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+//#include <errno.h>\n+//#include <string.h>\n+import \"C\"\n+\n+// #include\n+// void cfunc() {} // uses cgo_topofstack\n+\n+import (\n+\t\"common\"\n+\t\"strings\"\n+)\n+\n+func init() {\n+\t_ = strings.NewReplacer() // trigger stack unwind, Issue #18190.\n+\tC.strerror(C.EIO)         // uses cgo_topofstack\n+\tcommon.X = 2\n+}\n+\n+func main() {\n+\tpanic(\"plugin1.main called\")\n+}"}, {"sha": "cf9000c4a4e09f840ca2847656fc5bc85ff2eeef", "filename": "libgo/misc/cgo/testplugin/src/sub/plugin1/plugin1.go", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fsub%2Fplugin1%2Fplugin1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fsub%2Fplugin1%2Fplugin1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Fsrc%2Fsub%2Fplugin1%2Fplugin1.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// // No C code required.\n+import \"C\"\n+\n+import \"common\"\n+\n+func F() int { return 17 }\n+\n+var FuncVar = func() {}\n+\n+func ReadCommonX() int {\n+\tFuncVar()\n+\treturn common.X\n+}\n+\n+func main() {\n+\tpanic(\"plugin1.main called\")\n+}"}, {"sha": "ab7430acc37f95e580492a1aa341c51e5eaa41e6", "filename": "libgo/misc/cgo/testplugin/test.bash", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Ftest.bash", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Ftest.bash", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Ftest.bash?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,46 @@\n+#!/usr/bin/env bash\n+# Copyright 2016 The Go Authors. All rights reserved.\n+# Use of this source code is governed by a BSD-style\n+# license that can be found in the LICENSE file.\n+\n+set -e\n+\n+if [ ! -f src/host/host.go ]; then\n+\tcwd=$(pwd)\n+\techo \"misc/cgo/testplugin/test.bash is running in $cwd\" 1>&2\n+\texit 1\n+fi\n+\n+goos=$(go env GOOS)\n+goarch=$(go env GOARCH)\n+\n+function cleanup() {\n+\trm -f plugin*.so unnamed*.so iface*.so\n+\trm -rf host pkg sub iface issue18676\n+}\n+trap cleanup EXIT\n+\n+rm -rf pkg sub\n+mkdir sub\n+\n+GOPATH=$(pwd) go build -buildmode=plugin plugin1\n+GOPATH=$(pwd) go build -buildmode=plugin plugin2\n+GOPATH=$(pwd)/altpath go build -buildmode=plugin plugin-mismatch\n+GOPATH=$(pwd) go build -buildmode=plugin -o=sub/plugin1.so sub/plugin1\n+GOPATH=$(pwd) go build -buildmode=plugin unnamed1.go\n+GOPATH=$(pwd) go build -buildmode=plugin unnamed2.go\n+GOPATH=$(pwd) go build host\n+\n+LD_LIBRARY_PATH=$(pwd) ./host\n+\n+# Test that types and itabs get properly uniqified.\n+GOPATH=$(pwd) go build -buildmode=plugin iface_a\n+GOPATH=$(pwd) go build -buildmode=plugin iface_b\n+GOPATH=$(pwd) go build iface\n+LD_LIBRARY_PATH=$(pwd) ./iface\n+\n+# Test for issue 18676 - make sure we don't add the same itab twice.\n+# The buggy code hangs forever, so use a timeout to check for that.\n+GOPATH=$(pwd) go build -buildmode=plugin -o plugin.so src/issue18676/plugin.go\n+GOPATH=$(pwd) go build -o issue18676 src/issue18676/main.go\n+timeout 10s ./issue18676"}, {"sha": "102edaf3e29c97c3643a21a098fc3a17e19f077c", "filename": "libgo/misc/cgo/testplugin/unnamed1.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Funnamed1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Funnamed1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Funnamed1.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// // No C code required.\n+import \"C\"\n+\n+func FuncInt() int { return 1 }\n+\n+func main() {}"}, {"sha": "55070d5e9f79e428afe6ff19529c4232ef9ada5a", "filename": "libgo/misc/cgo/testplugin/unnamed2.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Funnamed2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Funnamed2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestplugin%2Funnamed2.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// // No C code required.\n+import \"C\"\n+\n+func FuncInt() int { return 2 }\n+\n+func main() {}"}, {"sha": "7915fa84f602b8bc3a87ccf0b09e31e97ac227f0", "filename": "libgo/misc/cgo/testsanitizers/msan.go", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+/*\n+#include <stdint.h>\n+\n+void f(int32_t *p, int n) {\n+  int i;\n+\n+  for (i = 0; i < n; i++) {\n+    p[i] = (int32_t)i;\n+  }\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"unsafe\"\n+)\n+\n+func main() {\n+\ta := make([]int32, 10)\n+\tC.f((*C.int32_t)(unsafe.Pointer(&a[0])), C.int(len(a)))\n+\tfor i, v := range a {\n+\t\tif i != int(v) {\n+\t\t\tfmt.Println(\"bad %d: %v\\n\", i, a)\n+\t\t\tos.Exit(1)\n+\t\t}\n+\t}\n+}"}, {"sha": "6690cb034fcf36015f37787e8119c1976804fb28", "filename": "libgo/misc/cgo/testsanitizers/msan2.go", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan2.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+/*\n+#include <string.h>\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+void f(int32_t *p, int n) {\n+  int32_t * volatile q = (int32_t *)malloc(sizeof(int32_t) * n);\n+  memcpy(p, q, n * sizeof(*p));\n+  free(q);\n+}\n+\n+void g(int32_t *p, int n) {\n+  if (p[4] != 1) {\n+    abort();\n+  }\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+func main() {\n+\ta := make([]int32, 10)\n+\tC.f((*C.int32_t)(unsafe.Pointer(&a[0])), C.int(len(a)))\n+\ta[4] = 1\n+\tC.g((*C.int32_t)(unsafe.Pointer(&a[0])), C.int(len(a)))\n+}"}, {"sha": "61a9c29e1a93644d21de1c7ffaa4034524f40a19", "filename": "libgo/misc/cgo/testsanitizers/msan3.go", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan3.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+/*\n+extern int *GoFn(int *);\n+\n+// Yes, you can have definitions if you use //export, as long as they are weak.\n+int f(void) __attribute__ ((weak));\n+\n+int f() {\n+  int i;\n+  int *p = GoFn(&i);\n+  if (*p != 12345)\n+    return 0;\n+  return 1;\n+}\n+*/\n+import \"C\"\n+\n+//export GoFn\n+func GoFn(p *C.int) *C.int {\n+\t*p = C.int(12345)\n+\treturn p\n+}\n+\n+func main() {\n+\tif r := C.f(); r != 1 {\n+\t\tpanic(r)\n+\t}\n+}"}, {"sha": "6c91ff5f091b6227e10ea76f5c7e04346b4dcd96", "filename": "libgo/misc/cgo/testsanitizers/msan4.go", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan4.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// The memory profiler can call copy from a slice on the system stack,\n+// which msan used to think meant a reference to uninitialized memory.\n+\n+/*\n+#include <time.h>\n+#include <unistd.h>\n+\n+extern void Nop(char*);\n+\n+// Use weak as a hack to permit defining a function even though we use export.\n+void poison() __attribute__ ((weak));\n+\n+// Poison the stack.\n+void poison() {\n+\tchar a[1024];\n+\tNop(&a[0]);\n+}\n+\n+*/\n+import \"C\"\n+\n+import (\n+\t\"runtime\"\n+)\n+\n+func main() {\n+\truntime.MemProfileRate = 1\n+\tstart(100)\n+}\n+\n+func start(i int) {\n+\tif i == 0 {\n+\t\treturn\n+\t}\n+\tC.poison()\n+\t// Tie up a thread.\n+\t// We won't actually wait for this sleep to complete.\n+\tgo func() { C.sleep(1) }()\n+\tstart(i - 1)\n+}\n+\n+//export Nop\n+func Nop(*C.char) {\n+}"}, {"sha": "f1479eb8a005693fcea56d476d44454349ec4bb1", "filename": "libgo/misc/cgo/testsanitizers/msan5.go", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan5.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// Using reflect to set a value was not seen by msan.\n+\n+/*\n+#include <stdlib.h>\n+\n+extern void Go1(int*);\n+extern void Go2(char*);\n+\n+// Use weak as a hack to permit defining a function even though we use export.\n+void C1() __attribute__ ((weak));\n+void C2() __attribute__ ((weak));\n+\n+void C1() {\n+\tint i;\n+\tGo1(&i);\n+\tif (i != 42) {\n+\t\tabort();\n+\t}\n+}\n+\n+void C2() {\n+\tchar a[2];\n+\ta[1] = 42;\n+\tGo2(a);\n+\tif (a[0] != 42) {\n+\t\tabort();\n+\t}\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"reflect\"\n+\t\"unsafe\"\n+)\n+\n+//export Go1\n+func Go1(p *C.int) {\n+\treflect.ValueOf(p).Elem().Set(reflect.ValueOf(C.int(42)))\n+}\n+\n+//export Go2\n+func Go2(p *C.char) {\n+\ta := (*[2]byte)(unsafe.Pointer(p))\n+\treflect.Copy(reflect.ValueOf(a[:1]), reflect.ValueOf(a[1:]))\n+}\n+\n+func main() {\n+\tC.C1()\n+\tC.C2()\n+}"}, {"sha": "4c8dab34f6e225ed2fe791063683e97b58265deb", "filename": "libgo/misc/cgo/testsanitizers/msan_fail.go", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan_fail.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan_fail.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan_fail.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+/*\n+#include <string.h>\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+void f(int32_t *p, int n) {\n+  int32_t * volatile q = (int32_t *)malloc(sizeof(int32_t) * n);\n+  memcpy(p, q, n * sizeof(*p));\n+  free(q);\n+}\n+\n+void g(int32_t *p, int n) {\n+  if (p[4] != 1) {\n+    // We shouldn't get here; msan should stop us first.\n+    exit(0);\n+  }\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+func main() {\n+\ta := make([]int32, 10)\n+\tC.f((*C.int32_t)(unsafe.Pointer(&a[0])), C.int(len(a)))\n+\ta[3] = 1\n+\tC.g((*C.int32_t)(unsafe.Pointer(&a[0])), C.int(len(a)))\n+}"}, {"sha": "966947cac359802072372ee044bd40323472b884", "filename": "libgo/misc/cgo/testsanitizers/msan_shared.go", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan_shared.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan_shared.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fmsan_shared.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This program segfaulted during libpreinit when built with -msan:\n+// http://golang.org/issue/18707\n+\n+package main\n+\n+import \"C\"\n+\n+func main() {}"}, {"sha": "4da85020d89800a3db00594b1b7937b04b6646c3", "filename": "libgo/misc/cgo/testsanitizers/test.bash", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftest.bash", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftest.bash", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftest.bash?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,204 @@\n+#!/usr/bin/env bash\n+# Copyright 2015 The Go Authors. All rights reserved.\n+# Use of this source code is governed by a BSD-style\n+# license that can be found in the LICENSE file.\n+\n+# This directory is intended to test the use of Go with sanitizers\n+# like msan, asan, etc.  See https://github.com/google/sanitizers .\n+\n+set -e\n+\n+# The sanitizers were originally developed with clang, so prefer it.\n+CC=cc\n+if test -x \"$(type -p clang)\"; then\n+  CC=clang\n+fi\n+export CC\n+\n+if [ \"$(sysctl -n vm.overcommit_memory)\" = 2 ]; then\n+  echo \"skipping msan/tsan tests: vm.overcommit_memory=2\" >&2\n+  exit 0\n+fi\n+\n+msan=yes\n+\n+TMPDIR=${TMPDIR:-/tmp}\n+echo 'int main() { return 0; }' > ${TMPDIR}/testsanitizers$$.c\n+if $CC -fsanitize=memory -o ${TMPDIR}/testsanitizers$$ ${TMPDIR}/testsanitizers$$.c 2>&1 | grep \"unrecognized\" >& /dev/null; then\n+  echo \"skipping msan tests: $CC -fsanitize=memory not supported\"\n+  msan=no\n+elif ! test -x ${TMPDIR}/testsanitizers$$; then\n+  echo \"skipping msan tests: $CC -fsanitize-memory did not generate an executable\"\n+  msan=no\n+elif ! ${TMPDIR}/testsanitizers$$ >/dev/null 2>&1; then\n+  echo \"skipping msan tests: $CC -fsanitize-memory generates broken executable\"\n+  msan=no\n+fi\n+rm -f ${TMPDIR}/testsanitizers$$.*\n+\n+tsan=yes\n+\n+# The memory and thread sanitizers in versions of clang before 3.6\n+# don't work with Go.\n+if test \"$msan\" = \"yes\" && $CC --version | grep clang >& /dev/null; then\n+  ver=$($CC --version | sed -e 's/.* version \\([0-9.-]*\\).*/\\1/')\n+  major=$(echo $ver | sed -e 's/\\([0-9]*\\).*/\\1/')\n+  minor=$(echo $ver | sed -e 's/[0-9]*\\.\\([0-9]*\\).*/\\1/')\n+  if test \"$major\" -lt 3 || test \"$major\" -eq 3 -a \"$minor\" -lt 6; then\n+    echo \"skipping msan/tsan tests: clang version $major.$minor (older than 3.6)\"\n+    msan=no\n+    tsan=no\n+  fi\n+\n+  # Clang before 3.8 does not work with Linux at or after 4.1.\n+  # golang.org/issue/12898.\n+  if test \"$msan\" = \"yes\" -a \"$major\" -lt 3 || test \"$major\" -eq 3 -a \"$minor\" -lt 8; then\n+    if test \"$(uname)\" = Linux; then\n+      linuxver=$(uname -r)\n+      linuxmajor=$(echo $linuxver | sed -e 's/\\([0-9]*\\).*/\\1/')\n+      linuxminor=$(echo $linuxver | sed -e 's/[0-9]*\\.\\([0-9]*\\).*/\\1/')\n+      if test \"$linuxmajor\" -gt 4 || test \"$linuxmajor\" -eq 4 -a \"$linuxminor\" -ge 1; then\n+        echo \"skipping msan/tsan tests: clang version $major.$minor (older than 3.8) incompatible with linux version $linuxmajor.$linuxminor (4.1 or newer)\"\n+\tmsan=no\n+\ttsan=no\n+      fi\n+    fi\n+  fi\n+fi\n+\n+status=0\n+\n+testmsanshared() {\n+  goos=$(go env GOOS)\n+  suffix=\"-installsuffix testsanitizers\"\n+  libext=\"so\"\n+  if [ \"$goos\" == \"darwin\" ]; then\n+\t  libext=\"dylib\"\n+  fi\n+  go build -msan -buildmode=c-shared $suffix -o ${TMPDIR}/libmsanshared.$libext msan_shared.go\n+\n+\techo 'int main() { return 0; }' > ${TMPDIR}/testmsanshared.c\n+  $CC $(go env GOGCCFLAGS) -fsanitize=memory -o ${TMPDIR}/testmsanshared ${TMPDIR}/testmsanshared.c ${TMPDIR}/libmsanshared.$libext\n+\n+  if ! LD_LIBRARY_PATH=. ${TMPDIR}/testmsanshared; then\n+    echo \"FAIL: msan_shared\"\n+    status=1\n+  fi\n+  rm -f ${TMPDIR}/{testmsanshared,testmsanshared.c,libmsanshared.$libext}\n+}\n+\n+if test \"$msan\" = \"yes\"; then\n+    if ! go build -msan std; then\n+\techo \"FAIL: build -msan std\"\n+\tstatus=1\n+    fi\n+\n+    if ! go run -msan msan.go; then\n+\techo \"FAIL: msan\"\n+\tstatus=1\n+    fi\n+\n+    if ! CGO_LDFLAGS=\"-fsanitize=memory\" CGO_CPPFLAGS=\"-fsanitize=memory\" go run -msan -a msan2.go; then\n+\techo \"FAIL: msan2 with -fsanitize=memory\"\n+\tstatus=1\n+    fi\n+\n+    if ! go run -msan -a msan2.go; then\n+\techo \"FAIL: msan2\"\n+\tstatus=1\n+    fi\n+\n+    if ! go run -msan msan3.go; then\n+\techo \"FAIL: msan3\"\n+\tstatus=1\n+    fi\n+\n+    if ! go run -msan msan4.go; then\n+\techo \"FAIL: msan4\"\n+\tstatus=1\n+    fi\n+\n+    if ! go run -msan msan5.go; then\n+\techo \"FAIL: msan5\"\n+\tstatus=1\n+    fi\n+\n+    if go run -msan msan_fail.go 2>/dev/null; then\n+\techo \"FAIL: msan_fail\"\n+\tstatus=1\n+    fi\n+\n+    testmsanshared\n+fi\n+\n+if test \"$tsan\" = \"yes\"; then\n+    echo 'int main() { return 0; }' > ${TMPDIR}/testsanitizers$$.c\n+    ok=yes\n+    if ! $CC -fsanitize=thread ${TMPDIR}/testsanitizers$$.c -o ${TMPDIR}/testsanitizers$$ &> ${TMPDIR}/testsanitizers$$.err; then\n+\tok=no\n+    fi\n+     if grep \"unrecognized\" ${TMPDIR}/testsanitizers$$.err >& /dev/null; then\n+\techo \"skipping tsan tests: -fsanitize=thread not supported\"\n+\ttsan=no\n+     elif test \"$ok\" != \"yes\"; then\n+\t cat ${TMPDIR}/testsanitizers$$.err\n+\t echo \"skipping tsan tests: -fsanitizer=thread build failed\"\n+\t tsan=no\n+     fi\n+     rm -f ${TMPDIR}/testsanitizers$$*\n+fi\n+\n+# Run a TSAN test.\n+# $1 test name\n+# $2 environment variables\n+# $3 go run args\n+testtsan() {\n+    err=${TMPDIR}/tsanerr$$.out\n+    if ! env $2 go run $3 $1 2>$err; then\n+\tcat $err\n+\techo \"FAIL: $1\"\n+\tstatus=1\n+    elif grep -i warning $err >/dev/null 2>&1; then\n+\tcat $err\n+\techo \"FAIL: $1\"\n+\tstatus=1\n+    fi\n+    rm -f $err\n+}\n+\n+if test \"$tsan\" = \"yes\"; then\n+    testtsan tsan.go\n+    testtsan tsan2.go\n+    testtsan tsan3.go\n+    testtsan tsan4.go\n+    testtsan tsan8.go\n+    testtsan tsan9.go\n+\n+    # These tests are only reliable using clang or GCC version 7 or later.\n+    # Otherwise runtime/cgo/libcgo.h can't tell whether TSAN is in use.\n+    ok=false\n+    if ${CC} --version | grep clang >/dev/null 2>&1; then\n+\tok=true\n+    else\n+\tver=$($CC -dumpversion)\n+\tmajor=$(echo $ver | sed -e 's/\\([0-9]*\\).*/\\1/')\n+\tif test \"$major\" -lt 7; then\n+\t    echo \"skipping remaining TSAN tests: GCC version $major (older than 7)\"\n+\telse\n+\t    ok=true\n+\tfi\n+    fi\n+\n+    if test \"$ok\" = \"true\"; then\n+\t# This test requires rebuilding os/user with -fsanitize=thread.\n+\ttesttsan tsan5.go \"CGO_CFLAGS=-fsanitize=thread CGO_LDFLAGS=-fsanitize=thread\" \"-installsuffix=tsan\"\n+\n+\t# This test requires rebuilding runtime/cgo with -fsanitize=thread.\n+\ttesttsan tsan6.go \"CGO_CFLAGS=-fsanitize=thread CGO_LDFLAGS=-fsanitize=thread\" \"-installsuffix=tsan\"\n+\n+\t# This test requires rebuilding runtime/cgo with -fsanitize=thread.\n+\ttesttsan tsan7.go \"CGO_CFLAGS=-fsanitize=thread CGO_LDFLAGS=-fsanitize=thread\" \"-installsuffix=tsan\"\n+    fi\n+fi\n+\n+exit $status"}, {"sha": "6c377a701fb965fc036fb4fa48c76c99369d09d2", "filename": "libgo/misc/cgo/testsanitizers/tsan.go", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// This program produced false race reports when run under the C/C++\n+// ThreadSanitizer, as it did not understand the synchronization in\n+// the Go code.\n+\n+/*\n+#cgo CFLAGS: -fsanitize=thread\n+#cgo LDFLAGS: -fsanitize=thread\n+\n+int val;\n+\n+int getVal() {\n+\treturn val;\n+}\n+\n+void setVal(int i) {\n+\tval = i;\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"runtime\"\n+)\n+\n+func main() {\n+\truntime.LockOSThread()\n+\tC.setVal(1)\n+\tc := make(chan bool)\n+\tgo func() {\n+\t\truntime.LockOSThread()\n+\t\tC.setVal(2)\n+\t\tc <- true\n+\t}()\n+\t<-c\n+\tif v := C.getVal(); v != 2 {\n+\t\tpanic(v)\n+\t}\n+}"}, {"sha": "5018a1987caca01ea8913906ef1d7f983f6a8eed", "filename": "libgo/misc/cgo/testsanitizers/tsan2.go", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan2.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// This program produced false race reports when run under the C/C++\n+// ThreadSanitizer, as it did not understand the synchronization in\n+// the Go code.\n+\n+/*\n+#cgo CFLAGS: -fsanitize=thread\n+#cgo LDFLAGS: -fsanitize=thread\n+\n+extern void GoRun(void);\n+\n+// Yes, you can have definitions if you use //export, as long as they are weak.\n+\n+int val __attribute__ ((weak));\n+\n+int run(void) __attribute__ ((weak));\n+\n+int run() {\n+\tval = 1;\n+\tGoRun();\n+\treturn val;\n+}\n+\n+void setVal(int) __attribute__ ((weak));\n+\n+void setVal(int i) {\n+\tval = i;\n+}\n+*/\n+import \"C\"\n+\n+import \"runtime\"\n+\n+//export GoRun\n+func GoRun() {\n+\truntime.LockOSThread()\n+\tc := make(chan bool)\n+\tgo func() {\n+\t\truntime.LockOSThread()\n+\t\tC.setVal(2)\n+\t\tc <- true\n+\t}()\n+\t<-c\n+}\n+\n+func main() {\n+\tif v := C.run(); v != 2 {\n+\t\tpanic(v)\n+\t}\n+}"}, {"sha": "87f6c80f1b18d56f9135805cd6af5be600aed1c8", "filename": "libgo/misc/cgo/testsanitizers/tsan3.go", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan3.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// The stubs for the C functions read and write the same slot on the\n+// g0 stack when copying arguments in and out.\n+\n+/*\n+#cgo CFLAGS: -fsanitize=thread\n+#cgo LDFLAGS: -fsanitize=thread\n+\n+int Func1() {\n+\treturn 0;\n+}\n+\n+void Func2(int x) {\n+\t(void)x;\n+}\n+*/\n+import \"C\"\n+\n+func main() {\n+\tconst N = 10000\n+\tdone := make(chan bool, N)\n+\tfor i := 0; i < N; i++ {\n+\t\tgo func() {\n+\t\t\tC.Func1()\n+\t\t\tdone <- true\n+\t\t}()\n+\t\tgo func() {\n+\t\t\tC.Func2(0)\n+\t\t\tdone <- true\n+\t\t}()\n+\t}\n+\tfor i := 0; i < 2*N; i++ {\n+\t\t<-done\n+\t}\n+}"}, {"sha": "f0c76d84116a6010977c09a531bbc96bf208e1cf", "filename": "libgo/misc/cgo/testsanitizers/tsan4.go", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan4.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// Check that calls to C.malloc/C.free do not trigger TSAN false\n+// positive reports.\n+\n+// #cgo CFLAGS: -fsanitize=thread\n+// #cgo LDFLAGS: -fsanitize=thread\n+// #include <stdlib.h>\n+import \"C\"\n+\n+import (\n+\t\"runtime\"\n+\t\"sync\"\n+)\n+\n+func main() {\n+\tvar wg sync.WaitGroup\n+\tfor i := 0; i < 10; i++ {\n+\t\twg.Add(1)\n+\t\tgo func() {\n+\t\t\tdefer wg.Done()\n+\t\t\tfor i := 0; i < 100; i++ {\n+\t\t\t\tp := C.malloc(C.size_t(i * 10))\n+\t\t\t\truntime.Gosched()\n+\t\t\t\tC.free(p)\n+\t\t\t}\n+\t\t}()\n+\t}\n+\twg.Wait()\n+}"}, {"sha": "1214a7743b67ba6f2543f39eecf4b2347b5b3fde", "filename": "libgo/misc/cgo/testsanitizers/tsan5.go", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan5.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// Check that calls to C.malloc/C.free do not collide with the calls\n+// made by the os/user package.\n+\n+// #cgo CFLAGS: -fsanitize=thread\n+// #cgo LDFLAGS: -fsanitize=thread\n+// #include <stdlib.h>\n+import \"C\"\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"os/user\"\n+\t\"runtime\"\n+\t\"sync\"\n+)\n+\n+func main() {\n+\tu, err := user.Current()\n+\tif err != nil {\n+\t\tfmt.Fprintln(os.Stderr, err)\n+\t\t// Let the test pass.\n+\t\tos.Exit(0)\n+\t}\n+\n+\tvar wg sync.WaitGroup\n+\tfor i := 0; i < 20; i++ {\n+\t\twg.Add(2)\n+\t\tgo func() {\n+\t\t\tdefer wg.Done()\n+\t\t\tfor i := 0; i < 1000; i++ {\n+\t\t\t\tuser.Lookup(u.Username)\n+\t\t\t\truntime.Gosched()\n+\t\t\t}\n+\t\t}()\n+\t\tgo func() {\n+\t\t\tdefer wg.Done()\n+\t\t\tfor i := 0; i < 1000; i++ {\n+\t\t\t\tp := C.malloc(C.size_t(len(u.Username) + 1))\n+\t\t\t\truntime.Gosched()\n+\t\t\t\tC.free(p)\n+\t\t\t}\n+\t\t}()\n+\t}\n+\twg.Wait()\n+}"}, {"sha": "c96f08d2f3752f2165a1ee2700d56c08d75539ba", "filename": "libgo/misc/cgo/testsanitizers/tsan6.go", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan6.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan6.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan6.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// Check that writes to Go allocated memory, with Go synchronization,\n+// do not look like a race.\n+\n+/*\n+#cgo CFLAGS: -fsanitize=thread\n+#cgo LDFLAGS: -fsanitize=thread\n+\n+void f(char *p) {\n+\t*p = 1;\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"runtime\"\n+\t\"sync\"\n+)\n+\n+func main() {\n+\tvar wg sync.WaitGroup\n+\tvar mu sync.Mutex\n+\tc := make(chan []C.char, 100)\n+\tfor i := 0; i < 10; i++ {\n+\t\twg.Add(2)\n+\t\tgo func() {\n+\t\t\tdefer wg.Done()\n+\t\t\tfor i := 0; i < 100; i++ {\n+\t\t\t\tc <- make([]C.char, 4096)\n+\t\t\t\truntime.Gosched()\n+\t\t\t}\n+\t\t}()\n+\t\tgo func() {\n+\t\t\tdefer wg.Done()\n+\t\t\tfor i := 0; i < 100; i++ {\n+\t\t\t\tp := &(<-c)[0]\n+\t\t\t\tmu.Lock()\n+\t\t\t\tC.f(p)\n+\t\t\t\tmu.Unlock()\n+\t\t\t}\n+\t\t}()\n+\t}\n+\twg.Wait()\n+}"}, {"sha": "2fb9e45ee2d6081da2de2a8df97875deeea8353e", "filename": "libgo/misc/cgo/testsanitizers/tsan7.go", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan7.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan7.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan7.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// Setting an environment variable in a cgo program changes the C\n+// environment. Test that this does not confuse the race detector.\n+\n+/*\n+#cgo CFLAGS: -fsanitize=thread\n+#cgo LDFLAGS: -fsanitize=thread\n+*/\n+import \"C\"\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"sync\"\n+\t\"time\"\n+)\n+\n+func main() {\n+\tvar wg sync.WaitGroup\n+\tvar mu sync.Mutex\n+\tf := func() {\n+\t\tdefer wg.Done()\n+\t\tfor i := 0; i < 100; i++ {\n+\t\t\ttime.Sleep(time.Microsecond)\n+\t\t\tmu.Lock()\n+\t\t\ts := fmt.Sprint(i)\n+\t\t\tos.Setenv(\"TSAN_TEST\"+s, s)\n+\t\t\tmu.Unlock()\n+\t\t}\n+\t}\n+\twg.Add(2)\n+\tgo f()\n+\tgo f()\n+\twg.Wait()\n+}"}, {"sha": "88d82a6078926aa76bcccc91b90829749edb9f54", "filename": "libgo/misc/cgo/testsanitizers/tsan8.go", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan8.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan8.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan8.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// This program failed when run under the C/C++ ThreadSanitizer.  The TSAN\n+// sigaction function interceptor returned SIG_DFL instead of the Go runtime's\n+// handler in registerSegvForwarder.\n+\n+/*\n+#cgo CFLAGS: -fsanitize=thread\n+#cgo LDFLAGS: -fsanitize=thread\n+\n+#include <signal.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+struct sigaction prev_sa;\n+\n+void forwardSignal(int signo, siginfo_t *info, void *context) {\n+\t// One of sa_sigaction and/or sa_handler\n+\tif ((prev_sa.sa_flags&SA_SIGINFO) != 0) {\n+\t\tprev_sa.sa_sigaction(signo, info, context);\n+\t\treturn;\n+\t}\n+\tif (prev_sa.sa_handler != SIG_IGN && prev_sa.sa_handler != SIG_DFL) {\n+\t\tprev_sa.sa_handler(signo);\n+\t\treturn;\n+\t}\n+\n+\tfprintf(stderr, \"No Go handler to forward to!\\n\");\n+\tabort();\n+}\n+\n+void registerSegvFowarder() {\n+\tstruct sigaction sa;\n+\tmemset(&sa, 0, sizeof(sa));\n+\tsigemptyset(&sa.sa_mask);\n+\tsa.sa_flags = SA_SIGINFO | SA_ONSTACK;\n+\tsa.sa_sigaction = forwardSignal;\n+\n+\tif (sigaction(SIGSEGV, &sa, &prev_sa) != 0) {\n+\t\tperror(\"failed to register SEGV forwarder\");\n+\t\texit(EXIT_FAILURE);\n+\t}\n+}\n+*/\n+import \"C\"\n+\n+func main() {\n+\tC.registerSegvFowarder()\n+\n+\tdefer func() {\n+\t\trecover()\n+\t}()\n+\tvar nilp *int\n+\t*nilp = 42\n+}"}, {"sha": "f166d8b495ac458a4a6dd236d0913cd90a68a0e9", "filename": "libgo/misc/cgo/testsanitizers/tsan9.go", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Ftsan9.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// This program failed when run under the C/C++ ThreadSanitizer. The\n+// TSAN library was not keeping track of whether signals should be\n+// delivered on the alternate signal stack, and the Go signal handler\n+// was not preserving callee-saved registers from C callers.\n+\n+/*\n+#cgo CFLAGS: -g -fsanitize=thread\n+#cgo LDFLAGS: -g -fsanitize=thread\n+\n+#include <stdlib.h>\n+#include <sys/time.h>\n+\n+void spin() {\n+\tsize_t n;\n+\tstruct timeval tvstart, tvnow;\n+\tint diff;\n+\tvoid *prev = NULL, *cur;\n+\n+\tgettimeofday(&tvstart, NULL);\n+\tfor (n = 0; n < 1<<20; n++) {\n+\t\tcur = malloc(n);\n+\t\tfree(prev);\n+\t\tprev = cur;\n+\n+\t\tgettimeofday(&tvnow, NULL);\n+\t\tdiff = (tvnow.tv_sec - tvstart.tv_sec) * 1000 * 1000 + (tvnow.tv_usec - tvstart.tv_usec);\n+\n+\t\t// Profile frequency is 100Hz so we should definitely\n+\t\t// get a signal in 50 milliseconds.\n+\t\tif (diff > 50 * 1000) {\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\tfree(prev);\n+}\n+*/\n+import \"C\"\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"runtime/pprof\"\n+\t\"time\"\n+)\n+\n+func goSpin() {\n+\tstart := time.Now()\n+\tfor n := 0; n < 1<<20; n++ {\n+\t\t_ = make([]byte, n)\n+\t\tif time.Since(start) > 50*time.Millisecond {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+}\n+\n+func main() {\n+\tpprof.StartCPUProfile(ioutil.Discard)\n+\tgo C.spin()\n+\tgoSpin()\n+\tpprof.StopCPUProfile()\n+}"}, {"sha": "f0766e511ec5b3e60f9365afa5d2154793d8349c", "filename": "libgo/misc/cgo/testshared/shared_test.go", "status": "added", "additions": 828, "deletions": 0, "changes": 828, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fshared_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fshared_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fshared_test.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,828 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package shared_test\n+\n+import (\n+\t\"bufio\"\n+\t\"bytes\"\n+\t\"debug/elf\"\n+\t\"encoding/binary\"\n+\t\"errors\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"go/build\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"math/rand\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"regexp\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+var gopathInstallDir, gorootInstallDir, suffix string\n+\n+// This is the smallest set of packages we can link into a shared\n+// library (runtime/cgo is built implicitly).\n+var minpkgs = []string{\"runtime\", \"sync/atomic\"}\n+var soname = \"libruntime,sync-atomic.so\"\n+\n+// run runs a command and calls t.Errorf if it fails.\n+func run(t *testing.T, msg string, args ...string) {\n+\tc := exec.Command(args[0], args[1:]...)\n+\tif output, err := c.CombinedOutput(); err != nil {\n+\t\tt.Errorf(\"executing %s (%s) failed %s:\\n%s\", strings.Join(args, \" \"), msg, err, output)\n+\t}\n+}\n+\n+// goCmd invokes the go tool with the installsuffix set up by TestMain. It calls\n+// t.Fatalf if the command fails.\n+func goCmd(t *testing.T, args ...string) {\n+\tnewargs := []string{args[0], \"-installsuffix=\" + suffix}\n+\tif testing.Verbose() {\n+\t\tnewargs = append(newargs, \"-v\")\n+\t}\n+\tnewargs = append(newargs, args[1:]...)\n+\tc := exec.Command(\"go\", newargs...)\n+\tvar output []byte\n+\tvar err error\n+\tif testing.Verbose() {\n+\t\tfmt.Printf(\"+ go %s\\n\", strings.Join(newargs, \" \"))\n+\t\tc.Stdout = os.Stdout\n+\t\tc.Stderr = os.Stderr\n+\t\terr = c.Run()\n+\t} else {\n+\t\toutput, err = c.CombinedOutput()\n+\t}\n+\tif err != nil {\n+\t\tif t != nil {\n+\t\t\tt.Fatalf(\"executing %s failed %v:\\n%s\", strings.Join(c.Args, \" \"), err, output)\n+\t\t} else {\n+\t\t\tlog.Fatalf(\"executing %s failed %v:\\n%s\", strings.Join(c.Args, \" \"), err, output)\n+\t\t}\n+\t}\n+}\n+\n+// TestMain calls testMain so that the latter can use defer (TestMain exits with os.Exit).\n+func testMain(m *testing.M) (int, error) {\n+\t// Because go install -buildmode=shared $standard_library_package always\n+\t// installs into $GOROOT, here are some gymnastics to come up with a unique\n+\t// installsuffix to use in this test that we can clean up afterwards.\n+\tmyContext := build.Default\n+\truntimeP, err := myContext.Import(\"runtime\", \".\", build.ImportComment)\n+\tif err != nil {\n+\t\treturn 0, fmt.Errorf(\"import failed: %v\", err)\n+\t}\n+\tfor i := 0; i < 10000; i++ {\n+\t\ttry := fmt.Sprintf(\"%s_%d_dynlink\", runtimeP.PkgTargetRoot, rand.Int63())\n+\t\terr = os.Mkdir(try, 0700)\n+\t\tif os.IsExist(err) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err == nil {\n+\t\t\tgorootInstallDir = try\n+\t\t}\n+\t\tbreak\n+\t}\n+\tif err != nil {\n+\t\treturn 0, fmt.Errorf(\"can't create temporary directory: %v\", err)\n+\t}\n+\tif gorootInstallDir == \"\" {\n+\t\treturn 0, errors.New(\"could not create temporary directory after 10000 tries\")\n+\t}\n+\tif testing.Verbose() {\n+\t\tfmt.Printf(\"+ mkdir -p %s\\n\", gorootInstallDir)\n+\t}\n+\tdefer os.RemoveAll(gorootInstallDir)\n+\n+\t// Some tests need to edit the source in GOPATH, so copy this directory to a\n+\t// temporary directory and chdir to that.\n+\tscratchDir, err := ioutil.TempDir(\"\", \"testshared\")\n+\tif err != nil {\n+\t\treturn 0, fmt.Errorf(\"TempDir failed: %v\", err)\n+\t}\n+\tif testing.Verbose() {\n+\t\tfmt.Printf(\"+ mkdir -p %s\\n\", scratchDir)\n+\t}\n+\tdefer os.RemoveAll(scratchDir)\n+\terr = filepath.Walk(\".\", func(path string, info os.FileInfo, err error) error {\n+\t\tscratchPath := filepath.Join(scratchDir, path)\n+\t\tif info.IsDir() {\n+\t\t\tif path == \".\" {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\tif testing.Verbose() {\n+\t\t\t\tfmt.Printf(\"+ mkdir -p %s\\n\", scratchPath)\n+\t\t\t}\n+\t\t\treturn os.Mkdir(scratchPath, info.Mode())\n+\t\t} else {\n+\t\t\tfromBytes, err := ioutil.ReadFile(path)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tif testing.Verbose() {\n+\t\t\t\tfmt.Printf(\"+ cp %s %s\\n\", path, scratchPath)\n+\t\t\t}\n+\t\t\treturn ioutil.WriteFile(scratchPath, fromBytes, info.Mode())\n+\t\t}\n+\t})\n+\tif err != nil {\n+\t\treturn 0, fmt.Errorf(\"walk failed: %v\", err)\n+\t}\n+\tos.Setenv(\"GOPATH\", scratchDir)\n+\tif testing.Verbose() {\n+\t\tfmt.Printf(\"+ export GOPATH=%s\\n\", scratchDir)\n+\t}\n+\tmyContext.GOPATH = scratchDir\n+\tif testing.Verbose() {\n+\t\tfmt.Printf(\"+ cd %s\\n\", scratchDir)\n+\t}\n+\tos.Chdir(scratchDir)\n+\n+\t// All tests depend on runtime being built into a shared library. Because\n+\t// that takes a few seconds, do it here and have all tests use the version\n+\t// built here.\n+\tsuffix = strings.Split(filepath.Base(gorootInstallDir), \"_\")[2]\n+\tgoCmd(nil, append([]string{\"install\", \"-buildmode=shared\"}, minpkgs...)...)\n+\n+\tmyContext.InstallSuffix = suffix + \"_dynlink\"\n+\tdepP, err := myContext.Import(\"depBase\", \".\", build.ImportComment)\n+\tif err != nil {\n+\t\treturn 0, fmt.Errorf(\"import failed: %v\", err)\n+\t}\n+\tgopathInstallDir = depP.PkgTargetRoot\n+\treturn m.Run(), nil\n+}\n+\n+func TestMain(m *testing.M) {\n+\t// Some of the tests install binaries into a custom GOPATH.\n+\t// That won't work if GOBIN is set.\n+\tos.Unsetenv(\"GOBIN\")\n+\n+\tflag.Parse()\n+\texitCode, err := testMain(m)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tos.Exit(exitCode)\n+}\n+\n+// The shared library was built at the expected location.\n+func TestSOBuilt(t *testing.T) {\n+\t_, err := os.Stat(filepath.Join(gorootInstallDir, soname))\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t}\n+}\n+\n+func hasDynTag(f *elf.File, tag elf.DynTag) bool {\n+\tds := f.SectionByType(elf.SHT_DYNAMIC)\n+\tif ds == nil {\n+\t\treturn false\n+\t}\n+\td, err := ds.Data()\n+\tif err != nil {\n+\t\treturn false\n+\t}\n+\tfor len(d) > 0 {\n+\t\tvar t elf.DynTag\n+\t\tswitch f.Class {\n+\t\tcase elf.ELFCLASS32:\n+\t\t\tt = elf.DynTag(f.ByteOrder.Uint32(d[0:4]))\n+\t\t\td = d[8:]\n+\t\tcase elf.ELFCLASS64:\n+\t\t\tt = elf.DynTag(f.ByteOrder.Uint64(d[0:8]))\n+\t\t\td = d[16:]\n+\t\t}\n+\t\tif t == tag {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+// The shared library does not have relocations against the text segment.\n+func TestNoTextrel(t *testing.T) {\n+\tsopath := filepath.Join(gorootInstallDir, soname)\n+\tf, err := elf.Open(sopath)\n+\tif err != nil {\n+\t\tt.Fatal(\"elf.Open failed: \", err)\n+\t}\n+\tdefer f.Close()\n+\tif hasDynTag(f, elf.DT_TEXTREL) {\n+\t\tt.Errorf(\"%s has DT_TEXTREL set\", soname)\n+\t}\n+}\n+\n+// The shared library does not contain symbols called \".dup\"\n+func TestNoDupSymbols(t *testing.T) {\n+\tsopath := filepath.Join(gorootInstallDir, soname)\n+\tf, err := elf.Open(sopath)\n+\tif err != nil {\n+\t\tt.Fatal(\"elf.Open failed: \", err)\n+\t}\n+\tdefer f.Close()\n+\tsyms, err := f.Symbols()\n+\tif err != nil {\n+\t\tt.Errorf(\"error reading symbols %v\", err)\n+\t\treturn\n+\t}\n+\tfor _, s := range syms {\n+\t\tif s.Name == \".dup\" {\n+\t\t\tt.Fatalf(\"%s contains symbol called .dup\", sopath)\n+\t\t}\n+\t}\n+}\n+\n+// The install command should have created a \"shlibname\" file for the\n+// listed packages (and runtime/cgo, and math on arm) indicating the\n+// name of the shared library containing it.\n+func TestShlibnameFiles(t *testing.T) {\n+\tpkgs := append([]string{}, minpkgs...)\n+\tpkgs = append(pkgs, \"runtime/cgo\")\n+\tif runtime.GOARCH == \"arm\" {\n+\t\tpkgs = append(pkgs, \"math\")\n+\t}\n+\tfor _, pkg := range pkgs {\n+\t\tshlibnamefile := filepath.Join(gorootInstallDir, pkg+\".shlibname\")\n+\t\tcontentsb, err := ioutil.ReadFile(shlibnamefile)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"error reading shlibnamefile for %s: %v\", pkg, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tcontents := strings.TrimSpace(string(contentsb))\n+\t\tif contents != soname {\n+\t\t\tt.Errorf(\"shlibnamefile for %s has wrong contents: %q\", pkg, contents)\n+\t\t}\n+\t}\n+}\n+\n+// Is a given offset into the file contained in a loaded segment?\n+func isOffsetLoaded(f *elf.File, offset uint64) bool {\n+\tfor _, prog := range f.Progs {\n+\t\tif prog.Type == elf.PT_LOAD {\n+\t\t\tif prog.Off <= offset && offset < prog.Off+prog.Filesz {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+func rnd(v int32, r int32) int32 {\n+\tif r <= 0 {\n+\t\treturn v\n+\t}\n+\tv += r - 1\n+\tc := v % r\n+\tif c < 0 {\n+\t\tc += r\n+\t}\n+\tv -= c\n+\treturn v\n+}\n+\n+func readwithpad(r io.Reader, sz int32) ([]byte, error) {\n+\tdata := make([]byte, rnd(sz, 4))\n+\t_, err := io.ReadFull(r, data)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdata = data[:sz]\n+\treturn data, nil\n+}\n+\n+type note struct {\n+\tname    string\n+\ttag     int32\n+\tdesc    string\n+\tsection *elf.Section\n+}\n+\n+// Read all notes from f. As ELF section names are not supposed to be special, one\n+// looks for a particular note by scanning all SHT_NOTE sections looking for a note\n+// with a particular \"name\" and \"tag\".\n+func readNotes(f *elf.File) ([]*note, error) {\n+\tvar notes []*note\n+\tfor _, sect := range f.Sections {\n+\t\tif sect.Type != elf.SHT_NOTE {\n+\t\t\tcontinue\n+\t\t}\n+\t\tr := sect.Open()\n+\t\tfor {\n+\t\t\tvar namesize, descsize, tag int32\n+\t\t\terr := binary.Read(r, f.ByteOrder, &namesize)\n+\t\t\tif err != nil {\n+\t\t\t\tif err == io.EOF {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\treturn nil, fmt.Errorf(\"read namesize failed: %v\", err)\n+\t\t\t}\n+\t\t\terr = binary.Read(r, f.ByteOrder, &descsize)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"read descsize failed: %v\", err)\n+\t\t\t}\n+\t\t\terr = binary.Read(r, f.ByteOrder, &tag)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"read type failed: %v\", err)\n+\t\t\t}\n+\t\t\tname, err := readwithpad(r, namesize)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"read name failed: %v\", err)\n+\t\t\t}\n+\t\t\tdesc, err := readwithpad(r, descsize)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"read desc failed: %v\", err)\n+\t\t\t}\n+\t\t\tnotes = append(notes, &note{name: string(name), tag: tag, desc: string(desc), section: sect})\n+\t\t}\n+\t}\n+\treturn notes, nil\n+}\n+\n+func dynStrings(t *testing.T, path string, flag elf.DynTag) []string {\n+\tf, err := elf.Open(path)\n+\tdefer f.Close()\n+\tif err != nil {\n+\t\tt.Fatalf(\"elf.Open(%q) failed: %v\", path, err)\n+\t}\n+\tdynstrings, err := f.DynString(flag)\n+\tif err != nil {\n+\t\tt.Fatalf(\"DynString(%s) failed on %s: %v\", flag, path, err)\n+\t}\n+\treturn dynstrings\n+}\n+\n+func AssertIsLinkedToRegexp(t *testing.T, path string, re *regexp.Regexp) {\n+\tfor _, dynstring := range dynStrings(t, path, elf.DT_NEEDED) {\n+\t\tif re.MatchString(dynstring) {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tt.Errorf(\"%s is not linked to anything matching %v\", path, re)\n+}\n+\n+func AssertIsLinkedTo(t *testing.T, path, lib string) {\n+\tAssertIsLinkedToRegexp(t, path, regexp.MustCompile(regexp.QuoteMeta(lib)))\n+}\n+\n+func AssertHasRPath(t *testing.T, path, dir string) {\n+\tfor _, tag := range []elf.DynTag{elf.DT_RPATH, elf.DT_RUNPATH} {\n+\t\tfor _, dynstring := range dynStrings(t, path, tag) {\n+\t\t\tfor _, rpath := range strings.Split(dynstring, \":\") {\n+\t\t\t\tif filepath.Clean(rpath) == filepath.Clean(dir) {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\tt.Errorf(\"%s does not have rpath %s\", path, dir)\n+}\n+\n+// Build a trivial program that links against the shared runtime and check it runs.\n+func TestTrivialExecutable(t *testing.T) {\n+\tgoCmd(t, \"install\", \"-linkshared\", \"trivial\")\n+\trun(t, \"trivial executable\", \"./bin/trivial\")\n+\tAssertIsLinkedTo(t, \"./bin/trivial\", soname)\n+\tAssertHasRPath(t, \"./bin/trivial\", gorootInstallDir)\n+}\n+\n+// Build a trivial program in PIE mode that links against the shared runtime and check it runs.\n+func TestTrivialExecutablePIE(t *testing.T) {\n+\tgoCmd(t, \"build\", \"-buildmode=pie\", \"-o\", \"trivial.pie\", \"-linkshared\", \"trivial\")\n+\trun(t, \"trivial executable\", \"./trivial.pie\")\n+\tAssertIsLinkedTo(t, \"./trivial.pie\", soname)\n+\tAssertHasRPath(t, \"./trivial.pie\", gorootInstallDir)\n+}\n+\n+// Build an executable that uses cgo linked against the shared runtime and check it\n+// runs.\n+func TestCgoExecutable(t *testing.T) {\n+\tgoCmd(t, \"install\", \"-linkshared\", \"execgo\")\n+\trun(t, \"cgo executable\", \"./bin/execgo\")\n+}\n+\n+func checkPIE(t *testing.T, name string) {\n+\tf, err := elf.Open(name)\n+\tif err != nil {\n+\t\tt.Fatal(\"elf.Open failed: \", err)\n+\t}\n+\tdefer f.Close()\n+\tif f.Type != elf.ET_DYN {\n+\t\tt.Errorf(\"%s has type %v, want ET_DYN\", name, f.Type)\n+\t}\n+\tif hasDynTag(f, elf.DT_TEXTREL) {\n+\t\tt.Errorf(\"%s has DT_TEXTREL set\", name)\n+\t}\n+}\n+\n+func TestTrivialPIE(t *testing.T) {\n+\tname := \"trivial_pie\"\n+\tgoCmd(t, \"build\", \"-buildmode=pie\", \"-o=\"+name, \"trivial\")\n+\tdefer os.Remove(name)\n+\trun(t, name, \"./\"+name)\n+\tcheckPIE(t, name)\n+}\n+\n+func TestCgoPIE(t *testing.T) {\n+\tname := \"cgo_pie\"\n+\tgoCmd(t, \"build\", \"-buildmode=pie\", \"-o=\"+name, \"execgo\")\n+\tdefer os.Remove(name)\n+\trun(t, name, \"./\"+name)\n+\tcheckPIE(t, name)\n+}\n+\n+// Build a GOPATH package into a shared library that links against the goroot runtime\n+// and an executable that links against both.\n+func TestGopathShlib(t *testing.T) {\n+\tgoCmd(t, \"install\", \"-buildmode=shared\", \"-linkshared\", \"depBase\")\n+\tAssertIsLinkedTo(t, filepath.Join(gopathInstallDir, \"libdepBase.so\"), soname)\n+\tgoCmd(t, \"install\", \"-linkshared\", \"exe\")\n+\tAssertIsLinkedTo(t, \"./bin/exe\", soname)\n+\tAssertIsLinkedTo(t, \"./bin/exe\", \"libdepBase.so\")\n+\tAssertHasRPath(t, \"./bin/exe\", gorootInstallDir)\n+\tAssertHasRPath(t, \"./bin/exe\", gopathInstallDir)\n+\t// And check it runs.\n+\trun(t, \"executable linked to GOPATH library\", \"./bin/exe\")\n+}\n+\n+// The shared library contains a note listing the packages it contains in a section\n+// that is not mapped into memory.\n+func testPkgListNote(t *testing.T, f *elf.File, note *note) {\n+\tif note.section.Flags != 0 {\n+\t\tt.Errorf(\"package list section has flags %v\", note.section.Flags)\n+\t}\n+\tif isOffsetLoaded(f, note.section.Offset) {\n+\t\tt.Errorf(\"package list section contained in PT_LOAD segment\")\n+\t}\n+\tif note.desc != \"depBase\\n\" {\n+\t\tt.Errorf(\"incorrect package list %q\", note.desc)\n+\t}\n+}\n+\n+// The shared library contains a note containing the ABI hash that is mapped into\n+// memory and there is a local symbol called go.link.abihashbytes that points 16\n+// bytes into it.\n+func testABIHashNote(t *testing.T, f *elf.File, note *note) {\n+\tif note.section.Flags != elf.SHF_ALLOC {\n+\t\tt.Errorf(\"abi hash section has flags %v\", note.section.Flags)\n+\t}\n+\tif !isOffsetLoaded(f, note.section.Offset) {\n+\t\tt.Errorf(\"abihash section not contained in PT_LOAD segment\")\n+\t}\n+\tvar hashbytes elf.Symbol\n+\tsymbols, err := f.Symbols()\n+\tif err != nil {\n+\t\tt.Errorf(\"error reading symbols %v\", err)\n+\t\treturn\n+\t}\n+\tfor _, sym := range symbols {\n+\t\tif sym.Name == \"go.link.abihashbytes\" {\n+\t\t\thashbytes = sym\n+\t\t}\n+\t}\n+\tif hashbytes.Name == \"\" {\n+\t\tt.Errorf(\"no symbol called go.link.abihashbytes\")\n+\t\treturn\n+\t}\n+\tif elf.ST_BIND(hashbytes.Info) != elf.STB_LOCAL {\n+\t\tt.Errorf(\"%s has incorrect binding %v\", hashbytes.Name, elf.ST_BIND(hashbytes.Info))\n+\t}\n+\tif f.Sections[hashbytes.Section] != note.section {\n+\t\tt.Errorf(\"%s has incorrect section %v\", hashbytes.Name, f.Sections[hashbytes.Section].Name)\n+\t}\n+\tif hashbytes.Value-note.section.Addr != 16 {\n+\t\tt.Errorf(\"%s has incorrect offset into section %d\", hashbytes.Name, hashbytes.Value-note.section.Addr)\n+\t}\n+}\n+\n+// A Go shared library contains a note indicating which other Go shared libraries it\n+// was linked against in an unmapped section.\n+func testDepsNote(t *testing.T, f *elf.File, note *note) {\n+\tif note.section.Flags != 0 {\n+\t\tt.Errorf(\"package list section has flags %v\", note.section.Flags)\n+\t}\n+\tif isOffsetLoaded(f, note.section.Offset) {\n+\t\tt.Errorf(\"package list section contained in PT_LOAD segment\")\n+\t}\n+\t// libdepBase.so just links against the lib containing the runtime.\n+\tif note.desc != soname {\n+\t\tt.Errorf(\"incorrect dependency list %q\", note.desc)\n+\t}\n+}\n+\n+// The shared library contains notes with defined contents; see above.\n+func TestNotes(t *testing.T) {\n+\tgoCmd(t, \"install\", \"-buildmode=shared\", \"-linkshared\", \"depBase\")\n+\tf, err := elf.Open(filepath.Join(gopathInstallDir, \"libdepBase.so\"))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer f.Close()\n+\tnotes, err := readNotes(f)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tpkgListNoteFound := false\n+\tabiHashNoteFound := false\n+\tdepsNoteFound := false\n+\tfor _, note := range notes {\n+\t\tif note.name != \"Go\\x00\\x00\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tswitch note.tag {\n+\t\tcase 1: // ELF_NOTE_GOPKGLIST_TAG\n+\t\t\tif pkgListNoteFound {\n+\t\t\t\tt.Error(\"multiple package list notes\")\n+\t\t\t}\n+\t\t\ttestPkgListNote(t, f, note)\n+\t\t\tpkgListNoteFound = true\n+\t\tcase 2: // ELF_NOTE_GOABIHASH_TAG\n+\t\t\tif abiHashNoteFound {\n+\t\t\t\tt.Error(\"multiple abi hash notes\")\n+\t\t\t}\n+\t\t\ttestABIHashNote(t, f, note)\n+\t\t\tabiHashNoteFound = true\n+\t\tcase 3: // ELF_NOTE_GODEPS_TAG\n+\t\t\tif depsNoteFound {\n+\t\t\t\tt.Error(\"multiple abi hash notes\")\n+\t\t\t}\n+\t\t\ttestDepsNote(t, f, note)\n+\t\t\tdepsNoteFound = true\n+\t\t}\n+\t}\n+\tif !pkgListNoteFound {\n+\t\tt.Error(\"package list note not found\")\n+\t}\n+\tif !abiHashNoteFound {\n+\t\tt.Error(\"abi hash note not found\")\n+\t}\n+\tif !depsNoteFound {\n+\t\tt.Error(\"deps note not found\")\n+\t}\n+}\n+\n+// Build a GOPATH package (depBase) into a shared library that links against the goroot\n+// runtime, another package (dep2) that links against the first, and and an\n+// executable that links against dep2.\n+func TestTwoGopathShlibs(t *testing.T) {\n+\tgoCmd(t, \"install\", \"-buildmode=shared\", \"-linkshared\", \"depBase\")\n+\tgoCmd(t, \"install\", \"-buildmode=shared\", \"-linkshared\", \"dep2\")\n+\tgoCmd(t, \"install\", \"-linkshared\", \"exe2\")\n+\trun(t, \"executable linked to GOPATH library\", \"./bin/exe2\")\n+}\n+\n+func TestThreeGopathShlibs(t *testing.T) {\n+\tgoCmd(t, \"install\", \"-buildmode=shared\", \"-linkshared\", \"depBase\")\n+\tgoCmd(t, \"install\", \"-buildmode=shared\", \"-linkshared\", \"dep2\")\n+\tgoCmd(t, \"install\", \"-buildmode=shared\", \"-linkshared\", \"dep3\")\n+\tgoCmd(t, \"install\", \"-linkshared\", \"exe3\")\n+\trun(t, \"executable linked to GOPATH library\", \"./bin/exe3\")\n+}\n+\n+// If gccgo is not available or not new enough call t.Skip. Otherwise,\n+// return a build.Context that is set up for gccgo.\n+func prepGccgo(t *testing.T) build.Context {\n+\tgccgoName := os.Getenv(\"GCCGO\")\n+\tif gccgoName == \"\" {\n+\t\tgccgoName = \"gccgo\"\n+\t}\n+\tgccgoPath, err := exec.LookPath(gccgoName)\n+\tif err != nil {\n+\t\tt.Skip(\"gccgo not found\")\n+\t}\n+\tcmd := exec.Command(gccgoPath, \"-dumpversion\")\n+\toutput, err := cmd.CombinedOutput()\n+\tif err != nil {\n+\t\tt.Fatalf(\"%s -dumpversion failed: %v\\n%s\", gccgoPath, err, output)\n+\t}\n+\tif string(output) < \"5\" {\n+\t\tt.Skipf(\"gccgo too old (%s)\", strings.TrimSpace(string(output)))\n+\t}\n+\tgccgoContext := build.Default\n+\tgccgoContext.InstallSuffix = suffix + \"_fPIC\"\n+\tgccgoContext.Compiler = \"gccgo\"\n+\tgccgoContext.GOPATH = os.Getenv(\"GOPATH\")\n+\treturn gccgoContext\n+}\n+\n+// Build a GOPATH package into a shared library with gccgo and an executable that\n+// links against it.\n+func TestGoPathShlibGccgo(t *testing.T) {\n+\tgccgoContext := prepGccgo(t)\n+\n+\tlibgoRE := regexp.MustCompile(\"libgo.so.[0-9]+\")\n+\n+\tdepP, err := gccgoContext.Import(\"depBase\", \".\", build.ImportComment)\n+\tif err != nil {\n+\t\tt.Fatalf(\"import failed: %v\", err)\n+\t}\n+\tgccgoInstallDir := filepath.Join(depP.PkgTargetRoot, \"shlibs\")\n+\tgoCmd(t, \"install\", \"-compiler=gccgo\", \"-buildmode=shared\", \"-linkshared\", \"depBase\")\n+\tAssertIsLinkedToRegexp(t, filepath.Join(gccgoInstallDir, \"libdepBase.so\"), libgoRE)\n+\tgoCmd(t, \"install\", \"-compiler=gccgo\", \"-linkshared\", \"exe\")\n+\tAssertIsLinkedToRegexp(t, \"./bin/exe\", libgoRE)\n+\tAssertIsLinkedTo(t, \"./bin/exe\", \"libdepBase.so\")\n+\tAssertHasRPath(t, \"./bin/exe\", gccgoInstallDir)\n+\t// And check it runs.\n+\trun(t, \"gccgo-built\", \"./bin/exe\")\n+}\n+\n+// The gccgo version of TestTwoGopathShlibs: build a GOPATH package into a shared\n+// library with gccgo, another GOPATH package that depends on the first and an\n+// executable that links the second library.\n+func TestTwoGopathShlibsGccgo(t *testing.T) {\n+\tgccgoContext := prepGccgo(t)\n+\n+\tlibgoRE := regexp.MustCompile(\"libgo.so.[0-9]+\")\n+\n+\tdepP, err := gccgoContext.Import(\"depBase\", \".\", build.ImportComment)\n+\tif err != nil {\n+\t\tt.Fatalf(\"import failed: %v\", err)\n+\t}\n+\tgccgoInstallDir := filepath.Join(depP.PkgTargetRoot, \"shlibs\")\n+\tgoCmd(t, \"install\", \"-compiler=gccgo\", \"-buildmode=shared\", \"-linkshared\", \"depBase\")\n+\tgoCmd(t, \"install\", \"-compiler=gccgo\", \"-buildmode=shared\", \"-linkshared\", \"dep2\")\n+\tgoCmd(t, \"install\", \"-compiler=gccgo\", \"-linkshared\", \"exe2\")\n+\n+\tAssertIsLinkedToRegexp(t, filepath.Join(gccgoInstallDir, \"libdepBase.so\"), libgoRE)\n+\tAssertIsLinkedToRegexp(t, filepath.Join(gccgoInstallDir, \"libdep2.so\"), libgoRE)\n+\tAssertIsLinkedTo(t, filepath.Join(gccgoInstallDir, \"libdep2.so\"), \"libdepBase.so\")\n+\tAssertIsLinkedToRegexp(t, \"./bin/exe2\", libgoRE)\n+\tAssertIsLinkedTo(t, \"./bin/exe2\", \"libdep2\")\n+\tAssertIsLinkedTo(t, \"./bin/exe2\", \"libdepBase.so\")\n+\n+\t// And check it runs.\n+\trun(t, \"gccgo-built\", \"./bin/exe2\")\n+}\n+\n+// Testing rebuilding of shared libraries when they are stale is a bit more\n+// complicated that it seems like it should be. First, we make everything \"old\": but\n+// only a few seconds old, or it might be older than gc (or the runtime source) and\n+// everything will get rebuilt. Then define a timestamp slightly newer than this\n+// time, which is what we set the mtime to of a file to cause it to be seen as new,\n+// and finally another slightly even newer one that we can compare files against to\n+// see if they have been rebuilt.\n+var oldTime = time.Now().Add(-9 * time.Second)\n+var nearlyNew = time.Now().Add(-6 * time.Second)\n+var stampTime = time.Now().Add(-3 * time.Second)\n+\n+// resetFileStamps makes \"everything\" (bin, src, pkg from GOPATH and the\n+// test-specific parts of GOROOT) appear old.\n+func resetFileStamps() {\n+\tchtime := func(path string, info os.FileInfo, err error) error {\n+\t\treturn os.Chtimes(path, oldTime, oldTime)\n+\t}\n+\treset := func(path string) {\n+\t\tif err := filepath.Walk(path, chtime); err != nil {\n+\t\t\tlog.Fatalf(\"resetFileStamps failed: %v\", err)\n+\t\t}\n+\n+\t}\n+\treset(\"bin\")\n+\treset(\"pkg\")\n+\treset(\"src\")\n+\treset(gorootInstallDir)\n+}\n+\n+// touch makes path newer than the \"old\" time stamp used by resetFileStamps.\n+func touch(path string) {\n+\tif err := os.Chtimes(path, nearlyNew, nearlyNew); err != nil {\n+\t\tlog.Fatalf(\"os.Chtimes failed: %v\", err)\n+\t}\n+}\n+\n+// isNew returns if the path is newer than the time stamp used by touch.\n+func isNew(path string) bool {\n+\tfi, err := os.Stat(path)\n+\tif err != nil {\n+\t\tlog.Fatalf(\"os.Stat failed: %v\", err)\n+\t}\n+\treturn fi.ModTime().After(stampTime)\n+}\n+\n+// Fail unless path has been rebuilt (i.e. is newer than the time stamp used by\n+// isNew)\n+func AssertRebuilt(t *testing.T, msg, path string) {\n+\tif !isNew(path) {\n+\t\tt.Errorf(\"%s was not rebuilt (%s)\", msg, path)\n+\t}\n+}\n+\n+// Fail if path has been rebuilt (i.e. is newer than the time stamp used by isNew)\n+func AssertNotRebuilt(t *testing.T, msg, path string) {\n+\tif isNew(path) {\n+\t\tt.Errorf(\"%s was rebuilt (%s)\", msg, path)\n+\t}\n+}\n+\n+func TestRebuilding(t *testing.T) {\n+\tgoCmd(t, \"install\", \"-buildmode=shared\", \"-linkshared\", \"depBase\")\n+\tgoCmd(t, \"install\", \"-linkshared\", \"exe\")\n+\n+\t// If the source is newer than both the .a file and the .so, both are rebuilt.\n+\tresetFileStamps()\n+\ttouch(\"src/depBase/dep.go\")\n+\tgoCmd(t, \"install\", \"-linkshared\", \"exe\")\n+\tAssertRebuilt(t, \"new source\", filepath.Join(gopathInstallDir, \"depBase.a\"))\n+\tAssertRebuilt(t, \"new source\", filepath.Join(gopathInstallDir, \"libdepBase.so\"))\n+\n+\t// If the .a file is newer than the .so, the .so is rebuilt (but not the .a)\n+\tresetFileStamps()\n+\ttouch(filepath.Join(gopathInstallDir, \"depBase.a\"))\n+\tgoCmd(t, \"install\", \"-linkshared\", \"exe\")\n+\tAssertNotRebuilt(t, \"new .a file\", filepath.Join(gopathInstallDir, \"depBase.a\"))\n+\tAssertRebuilt(t, \"new .a file\", filepath.Join(gopathInstallDir, \"libdepBase.so\"))\n+}\n+\n+func appendFile(path, content string) {\n+\tf, err := os.OpenFile(path, os.O_WRONLY|os.O_APPEND, 0660)\n+\tif err != nil {\n+\t\tlog.Fatalf(\"os.OpenFile failed: %v\", err)\n+\t}\n+\tdefer func() {\n+\t\terr := f.Close()\n+\t\tif err != nil {\n+\t\t\tlog.Fatalf(\"f.Close failed: %v\", err)\n+\t\t}\n+\t}()\n+\t_, err = f.WriteString(content)\n+\tif err != nil {\n+\t\tlog.Fatalf(\"f.WriteString failed: %v\", err)\n+\t}\n+}\n+\n+func TestABIChecking(t *testing.T) {\n+\tgoCmd(t, \"install\", \"-buildmode=shared\", \"-linkshared\", \"depBase\")\n+\tgoCmd(t, \"install\", \"-linkshared\", \"exe\")\n+\n+\t// If we make an ABI-breaking change to depBase and rebuild libp.so but not exe,\n+\t// exe will abort with a complaint on startup.\n+\t// This assumes adding an exported function breaks ABI, which is not true in\n+\t// some senses but suffices for the narrow definition of ABI compatibility the\n+\t// toolchain uses today.\n+\tresetFileStamps()\n+\tappendFile(\"src/depBase/dep.go\", \"func ABIBreak() {}\\n\")\n+\tgoCmd(t, \"install\", \"-buildmode=shared\", \"-linkshared\", \"depBase\")\n+\tc := exec.Command(\"./bin/exe\")\n+\toutput, err := c.CombinedOutput()\n+\tif err == nil {\n+\t\tt.Fatal(\"executing exe did not fail after ABI break\")\n+\t}\n+\tscanner := bufio.NewScanner(bytes.NewReader(output))\n+\tfoundMsg := false\n+\tconst wantLine = \"abi mismatch detected between the executable and libdepBase.so\"\n+\tfor scanner.Scan() {\n+\t\tif scanner.Text() == wantLine {\n+\t\t\tfoundMsg = true\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif err = scanner.Err(); err != nil {\n+\t\tt.Errorf(\"scanner encountered error: %v\", err)\n+\t}\n+\tif !foundMsg {\n+\t\tt.Fatalf(\"exe failed, but without line %q; got output:\\n%s\", wantLine, output)\n+\t}\n+\n+\t// Rebuilding exe makes it work again.\n+\tgoCmd(t, \"install\", \"-linkshared\", \"exe\")\n+\trun(t, \"rebuilt exe\", \"./bin/exe\")\n+\n+\t// If we make a change which does not break ABI (such as adding an unexported\n+\t// function) and rebuild libdepBase.so, exe still works.\n+\tresetFileStamps()\n+\tappendFile(\"src/depBase/dep.go\", \"func noABIBreak() {}\\n\")\n+\tgoCmd(t, \"install\", \"-buildmode=shared\", \"-linkshared\", \"depBase\")\n+\trun(t, \"after non-ABI breaking change\", \"./bin/exe\")\n+}\n+\n+// If a package 'explicit' imports a package 'implicit', building\n+// 'explicit' into a shared library implicitly includes implicit in\n+// the shared library. Building an executable that imports both\n+// explicit and implicit builds the code from implicit into the\n+// executable rather than fetching it from the shared library. The\n+// link still succeeds and the executable still runs though.\n+func TestImplicitInclusion(t *testing.T) {\n+\tgoCmd(t, \"install\", \"-buildmode=shared\", \"-linkshared\", \"explicit\")\n+\tgoCmd(t, \"install\", \"-linkshared\", \"implicitcmd\")\n+\trun(t, \"running executable linked against library that contains same package as it\", \"./bin/implicitcmd\")\n+}\n+\n+// Tests to make sure that the type fields of empty interfaces and itab\n+// fields of nonempty interfaces are unique even across modules,\n+// so that interface equality works correctly.\n+func TestInterface(t *testing.T) {\n+\tgoCmd(t, \"install\", \"-buildmode=shared\", \"-linkshared\", \"iface_a\")\n+\t// Note: iface_i gets installed implicitly as a dependency of iface_a.\n+\tgoCmd(t, \"install\", \"-buildmode=shared\", \"-linkshared\", \"iface_b\")\n+\tgoCmd(t, \"install\", \"-linkshared\", \"iface\")\n+\trun(t, \"running type/itab uniqueness tester\", \"./bin/iface\")\n+}"}, {"sha": "c2c812adb9b4311cfba33f87de876d3d738de7ef", "filename": "libgo/misc/cgo/testshared/src/dep2/dep2.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fdep2%2Fdep2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fdep2%2Fdep2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fdep2%2Fdep2.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,15 @@\n+package dep2\n+\n+import \"depBase\"\n+\n+var W int = 1\n+\n+var hasProg depBase.HasProg\n+\n+type Dep2 struct {\n+\tdepBase.Dep\n+}\n+\n+func G() int {\n+\treturn depBase.F() + 1\n+}"}, {"sha": "7b7c9dac1f9c1f035f7ddb7a08e574d308cf5795", "filename": "libgo/misc/cgo/testshared/src/dep3/dep3.go", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fdep3%2Fdep3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fdep3%2Fdep3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fdep3%2Fdep3.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,22 @@\n+package dep3\n+\n+// The point of this test file is that it references a type from\n+// depBase that is also referenced in dep2, but dep2 is loaded by the\n+// linker before depBase (because it is earlier in the import list).\n+// There was a bug in the linker where it would not correctly read out\n+// the type data in this case and later crash.\n+\n+import (\n+\t\"dep2\"\n+\t\"depBase\"\n+)\n+\n+type Dep3 struct {\n+\tdep  depBase.Dep\n+\tdep2 dep2.Dep2\n+}\n+\n+func D3() int {\n+\tvar x Dep3\n+\treturn x.dep.X + x.dep2.X\n+}"}, {"sha": "f203f8b0301839accdda8fbd4e7d51950c165aa1", "filename": "libgo/misc/cgo/testshared/src/depBase/asm.s", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2FdepBase%2Fasm.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2FdepBase%2Fasm.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2FdepBase%2Fasm.s?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,10 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+//+build !gccgo\n+\n+#include \"textflag.h\"\n+\n+TEXT \u00b7ImplementedInAsm(SB),NOSPLIT,$0-0\n+       RET"}, {"sha": "9f86710db01a4438fe4ab7fb7e8f3b13829592f5", "filename": "libgo/misc/cgo/testshared/src/depBase/dep.go", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2FdepBase%2Fdep.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2FdepBase%2Fdep.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2FdepBase%2Fdep.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,33 @@\n+package depBase\n+\n+import (\n+\t\"os\"\n+\t\"reflect\"\n+)\n+\n+var SlicePtr interface{} = &[]int{}\n+\n+var V int = 1\n+\n+var HasMask []string = []string{\"hi\"}\n+\n+type HasProg struct {\n+\tarray [1024]*byte\n+}\n+\n+type Dep struct {\n+\tX int\n+}\n+\n+func (d *Dep) Method() int {\n+\t// This code below causes various go.itab.* symbols to be generated in\n+\t// the shared library. Similar code in ../exe/exe.go results in\n+\t// exercising https://github.com/golang/go/issues/17594\n+\treflect.TypeOf(os.Stdout).Elem()\n+\treturn 10\n+}\n+\n+func F() int {\n+\tdefer func() {}()\n+\treturn V\n+}"}, {"sha": "3e2b69b50bc2b0c34fd8ff7b217ac541077deef5", "filename": "libgo/misc/cgo/testshared/src/depBase/gccgo.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2FdepBase%2Fgccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2FdepBase%2Fgccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2FdepBase%2Fgccgo.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,5 @@\n+//+build gccgo\n+\n+package depBase\n+\n+func ImplementedInAsm() {}"}, {"sha": "96573c12ececb0950a28ea77e11999a882f1e85b", "filename": "libgo/misc/cgo/testshared/src/depBase/stubs.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2FdepBase%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2FdepBase%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2FdepBase%2Fstubs.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,5 @@\n+//+build !gccgo\n+\n+package depBase\n+\n+func ImplementedInAsm()"}, {"sha": "84302a811f0919b9035b8da22814581af1d122a0", "filename": "libgo/misc/cgo/testshared/src/exe/exe.go", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fexe%2Fexe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fexe%2Fexe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fexe%2Fexe.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,44 @@\n+package main\n+\n+import (\n+\t\"depBase\"\n+\t\"os\"\n+\t\"reflect\"\n+\t\"runtime\"\n+)\n+\n+// Having a function declared in the main package triggered\n+// golang.org/issue/18250\n+func DeclaredInMain() {\n+}\n+\n+type C struct {\n+}\n+\n+func F() *C {\n+\treturn nil\n+}\n+\n+var slicePtr interface{} = &[]int{}\n+\n+func main() {\n+\tdefer depBase.ImplementedInAsm()\n+\t// This code below causes various go.itab.* symbols to be generated in\n+\t// the executable. Similar code in ../depBase/dep.go results in\n+\t// exercising https://github.com/golang/go/issues/17594\n+\treflect.TypeOf(os.Stdout).Elem()\n+\truntime.GC()\n+\tdepBase.V = depBase.F() + 1\n+\n+\tvar c *C\n+\tif reflect.TypeOf(F).Out(0) != reflect.TypeOf(c) {\n+\t\tpanic(\"bad reflection results, see golang.org/issue/18252\")\n+\t}\n+\n+\tsp := reflect.New(reflect.TypeOf(slicePtr).Elem())\n+\ts := sp.Interface()\n+\n+\tif reflect.TypeOf(s) != reflect.TypeOf(slicePtr) {\n+\t\tpanic(\"bad reflection results, see golang.org/issue/18729\")\n+\t}\n+}"}, {"sha": "675fd1f365cc665b8db52c80db0eed6ab3dd2890", "filename": "libgo/misc/cgo/testshared/src/exe2/exe2.go", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fexe2%2Fexe2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fexe2%2Fexe2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fexe2%2Fexe2.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,8 @@\n+package main\n+\n+import \"dep2\"\n+\n+func main() {\n+\td := &dep2.Dep2{}\n+\tdep2.W = dep2.G() + 1 + d.Method()\n+}"}, {"sha": "643f2605f6600cbd0ba6bbf18d1b6017d7051164", "filename": "libgo/misc/cgo/testshared/src/exe3/exe3.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fexe3%2Fexe3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fexe3%2Fexe3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fexe3%2Fexe3.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,7 @@\n+package main\n+\n+import \"dep3\"\n+\n+func main() {\n+\tdep3.D3()\n+}"}, {"sha": "0427be8bdfdfcb18d00ffe0b0e69a674a091aa62", "filename": "libgo/misc/cgo/testshared/src/execgo/exe.go", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fexecgo%2Fexe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fexecgo%2Fexe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fexecgo%2Fexe.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,8 @@\n+package main\n+\n+/*\n+ */\n+import \"C\"\n+\n+func main() {\n+}"}, {"sha": "6a4453f775861743074e2185f64ca6093f6c74cf", "filename": "libgo/misc/cgo/testshared/src/explicit/explicit.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fexplicit%2Fexplicit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fexplicit%2Fexplicit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fexplicit%2Fexplicit.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,9 @@\n+package explicit\n+\n+import (\n+\t\"implicit\"\n+)\n+\n+func E() int {\n+\treturn implicit.I()\n+}"}, {"sha": "3d5b54e73b9e8b0ad35a925ee845ee0e4698d808", "filename": "libgo/misc/cgo/testshared/src/iface/main.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fiface%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fiface%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fiface%2Fmain.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"iface_a\"\n+import \"iface_b\"\n+\n+func main() {\n+\tif iface_a.F() != iface_b.F() {\n+\t\tpanic(\"empty interfaces not equal\")\n+\t}\n+\tif iface_a.G() != iface_b.G() {\n+\t\tpanic(\"non-empty interfaces not equal\")\n+\t}\n+}"}, {"sha": "e11047c166c66523e5a7960d150465c18eb922ac", "filename": "libgo/misc/cgo/testshared/src/iface_a/a.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fiface_a%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fiface_a%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fiface_a%2Fa.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package iface_a\n+\n+import \"iface_i\"\n+\n+//go:noinline\n+func F() interface{} {\n+\treturn (*iface_i.T)(nil)\n+}\n+\n+//go:noinline\n+func G() iface_i.I {\n+\treturn (*iface_i.T)(nil)\n+}"}, {"sha": "47aee2e77ee9d71e00947099b040ac0de252f52b", "filename": "libgo/misc/cgo/testshared/src/iface_b/b.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fiface_b%2Fb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fiface_b%2Fb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fiface_b%2Fb.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package iface_b\n+\n+import \"iface_i\"\n+\n+//go:noinline\n+func F() interface{} {\n+\treturn (*iface_i.T)(nil)\n+}\n+\n+//go:noinline\n+func G() iface_i.I {\n+\treturn (*iface_i.T)(nil)\n+}"}, {"sha": "31c80387c7e56c752e422fb73e81592d1a34c87b", "filename": "libgo/misc/cgo/testshared/src/iface_i/i.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fiface_i%2Fi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fiface_i%2Fi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fiface_i%2Fi.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package iface_i\n+\n+type I interface {\n+\tM()\n+}\n+\n+type T struct {\n+}\n+\n+func (t *T) M() {\n+}\n+\n+// *T implements I"}, {"sha": "5360188c562386fb1fae175817838fb27a045f5f", "filename": "libgo/misc/cgo/testshared/src/implicit/implicit.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fimplicit%2Fimplicit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fimplicit%2Fimplicit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fimplicit%2Fimplicit.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,5 @@\n+package implicit\n+\n+func I() int {\n+\treturn 42\n+}"}, {"sha": "f6112933e56d6c9189259905388651331ee21517", "filename": "libgo/misc/cgo/testshared/src/implicitcmd/implicitcmd.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fimplicitcmd%2Fimplicitcmd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fimplicitcmd%2Fimplicitcmd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Fimplicitcmd%2Fimplicitcmd.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,10 @@\n+package main\n+\n+import (\n+\t\"explicit\"\n+\t\"implicit\"\n+)\n+\n+func main() {\n+\tprintln(implicit.I() + explicit.E())\n+}"}, {"sha": "da29a2cadf1e00b14b1a4bd0a52780888bf3e532", "filename": "libgo/misc/cgo/testshared/src/trivial/trivial.go", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Ftrivial%2Ftrivial.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Ftrivial%2Ftrivial.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestshared%2Fsrc%2Ftrivial%2Ftrivial.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,4 @@\n+package main\n+\n+func main() {\n+}"}, {"sha": "61bd0da88a839bc20a5a881393413e903b75013c", "filename": "libgo/misc/cgo/testsigfwd/main.go", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsigfwd%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsigfwd%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsigfwd%2Fmain.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,113 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"fmt\"\n+\n+/*\n+#cgo CFLAGS: -pthread\n+#cgo LDFLAGS: -pthread\n+\n+#include <signal.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <pthread.h>\n+\n+int *p;\n+static void sigsegv() {\n+\t*p = 1;\n+\tfprintf(stderr, \"ERROR: C SIGSEGV not thrown on caught?.\\n\");\n+\texit(2);\n+}\n+\n+static void segvhandler(int signum) {\n+\tif (signum == SIGSEGV) {\n+\t\texit(0);  // success\n+\t}\n+}\n+\n+static volatile sig_atomic_t sigioSeen;\n+\n+// Use up some stack space.\n+static void recur(int i, char *p) {\n+\tchar a[1024];\n+\n+\t*p = '\\0';\n+\tif (i > 0) {\n+\t\trecur(i - 1, a);\n+\t}\n+}\n+\n+static void iohandler(int signum) {\n+\tchar a[1024];\n+\n+\trecur(4, a);\n+\tsigioSeen = 1;\n+}\n+\n+static void* sigioThread(void* arg __attribute__ ((unused))) {\n+\traise(SIGIO);\n+\treturn NULL;\n+}\n+\n+static void sigioOnThread() {\n+\tpthread_t tid;\n+\tint i;\n+\n+\tpthread_create(&tid, NULL, sigioThread, NULL);\n+\tpthread_join(tid, NULL);\n+\n+\t// Wait until the signal has been delivered.\n+\ti = 0;\n+\twhile (!sigioSeen) {\n+\t\tif (sched_yield() < 0) {\n+\t\t\tperror(\"sched_yield\");\n+\t\t}\n+\t\ti++;\n+\t\tif (i > 10000) {\n+\t\t\tfprintf(stderr, \"looping too long waiting for signal\\n\");\n+\t\t\texit(EXIT_FAILURE);\n+\t\t}\n+\t}\n+}\n+\n+static void __attribute__ ((constructor)) sigsetup(void) {\n+\tstruct sigaction act;\n+\n+\tmemset(&act, 0, sizeof act);\n+\tact.sa_handler = segvhandler;\n+\tsigaction(SIGSEGV, &act, NULL);\n+\n+\tact.sa_handler = iohandler;\n+\tsigaction(SIGIO, &act, NULL);\n+}\n+*/\n+import \"C\"\n+\n+var p *byte\n+\n+func f() (ret bool) {\n+\tdefer func() {\n+\t\tif recover() == nil {\n+\t\t\tfmt.Errorf(\"ERROR: couldn't raise SIGSEGV in Go.\")\n+\t\t\tC.exit(2)\n+\t\t}\n+\t\tret = true\n+\t}()\n+\t*p = 1\n+\treturn false\n+}\n+\n+func main() {\n+\t// Test that the signal originating in Go is handled (and recovered) by Go.\n+\tif !f() {\n+\t\tfmt.Errorf(\"couldn't recover from SIGSEGV in Go.\")\n+\t\tC.exit(2)\n+\t}\n+\n+\t// Test that the signal originating in C is handled by C.\n+\tC.sigsegv()\n+}"}, {"sha": "917f472d3684bc9f7bd90ea0ab28150027291161", "filename": "libgo/misc/cgo/testso/cgoso.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestso%2Fcgoso.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestso%2Fcgoso.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestso%2Fcgoso.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"_cgo_export.h\"\n+\n+#ifdef WIN32\n+extern void setCallback(void *);\n+void init() {\n+\tsetCallback(goCallback);\n+}\n+#else\n+void init() {}\n+#endif"}, {"sha": "29814fa43aeafe3f0250ef216b2301c29359735a", "filename": "libgo/misc/cgo/testso/cgoso.go", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestso%2Fcgoso.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestso%2Fcgoso.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestso%2Fcgoso.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgosotest\n+\n+/*\n+// intentionally write the same LDFLAGS differently\n+// to test correct handling of LDFLAGS.\n+#cgo linux LDFLAGS: -L. -lcgosotest\n+#cgo dragonfly LDFLAGS: -L. -l cgosotest\n+#cgo freebsd LDFLAGS: -L. -l cgosotest\n+#cgo openbsd LDFLAGS: -L. -l cgosotest\n+#cgo solaris LDFLAGS: -L. -lcgosotest\n+#cgo netbsd LDFLAGS: -L. libcgosotest.so\n+#cgo darwin LDFLAGS: -L. libcgosotest.dylib\n+#cgo windows LDFLAGS: -L. libcgosotest.dll\n+\n+void init(void);\n+void sofunc(void);\n+*/\n+import \"C\"\n+\n+func Test() {\n+\tC.init()\n+\tC.sofunc()\n+}\n+\n+//export goCallback\n+func goCallback() {\n+}"}, {"sha": "7a38022b54736e1c51b48d36b48323c4ea6ecd2a", "filename": "libgo/misc/cgo/testso/cgoso_c.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestso%2Fcgoso_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestso%2Fcgoso_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestso%2Fcgoso_c.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+#ifdef WIN32\n+// A Windows DLL is unable to call an arbitrary function in\n+// the main executable. Work around that by making the main\n+// executable pass the callback function pointer to us.\n+void (*goCallback)(void);\n+__declspec(dllexport) void setCallback(void *f)\n+{\n+\tgoCallback = (void (*)())f;\n+}\n+__declspec(dllexport) void sofunc(void);\n+#else\n+extern void goCallback(void);\n+void setCallback(void *f) { (void)f; }\n+#endif\n+\n+// OpenBSD and older Darwin lack TLS support\n+#if !defined(__OpenBSD__) && !defined(__APPLE__)\n+__thread int tlsvar = 12345;\n+#endif\n+\n+void sofunc(void)\n+{\n+\tgoCallback();\n+}"}, {"sha": "49cdeaa2f59d899fe11f1a7efcec1cbb9d9839fd", "filename": "libgo/misc/cgo/testso/cgoso_unix.go", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestso%2Fcgoso_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestso%2Fcgoso_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestso%2Fcgoso_unix.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build dragonfly freebsd linux netbsd solaris\n+\n+package cgosotest\n+\n+/*\n+extern int __thread tlsvar;\n+int *getTLS() { return &tlsvar; }\n+*/\n+import \"C\"\n+\n+func init() {\n+\tif v := *C.getTLS(); v != 12345 {\n+\t\tprintln(\"got\", v)\n+\t\tpanic(\"BAD TLS value\")\n+\t}\n+}"}, {"sha": "88aa4322d242cf7adc33c0d57b4aa727166f6640", "filename": "libgo/misc/cgo/testso/main.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestso%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestso%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestso%2Fmain.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+package main\n+\n+import \".\"\n+\n+func main() {\n+\tcgosotest.Test()\n+}"}, {"sha": "88d44c2c6ee29b1a3e7de66fc29dcc636609bc4b", "filename": "libgo/misc/cgo/testsovar/cgoso.go", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsovar%2Fcgoso.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsovar%2Fcgoso.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsovar%2Fcgoso.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgosotest\n+\n+// This test verifies that Go can access C variables\n+// in shared object file via cgo.\n+\n+/*\n+// intentionally write the same LDFLAGS differently\n+// to test correct handling of LDFLAGS.\n+#cgo windows CFLAGS: -DIMPORT_DLL\n+#cgo linux LDFLAGS: -L. -lcgosotest\n+#cgo dragonfly LDFLAGS: -L. -l cgosotest\n+#cgo freebsd LDFLAGS: -L. -l cgosotest\n+#cgo openbsd LDFLAGS: -L. -l cgosotest\n+#cgo solaris LDFLAGS: -L. -lcgosotest\n+#cgo netbsd LDFLAGS: -L. libcgosotest.so\n+#cgo darwin LDFLAGS: -L. libcgosotest.dylib\n+#cgo windows LDFLAGS: -L. libcgosotest.dll\n+\n+#include \"cgoso_c.h\"\n+\n+const char* getVar() {\n+\t    return exported_var;\n+}\n+*/\n+import \"C\"\n+\n+import \"fmt\"\n+\n+func Test() {\n+\tconst want = \"Hello world\"\n+\tgot := C.GoString(C.getVar())\n+\tif got != want {\n+\t\tpanic(fmt.Sprintf(\"testExportedVar: got %q, but want %q\", got, want))\n+\t}\n+\tgot = C.GoString(C.exported_var)\n+\tif got != want {\n+\t\tpanic(fmt.Sprintf(\"testExportedVar: got %q, but want %q\", got, want))\n+\t}\n+}"}, {"sha": "a448c013428c9807dcec8a76217383ea82808a19", "filename": "libgo/misc/cgo/testsovar/cgoso_c.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsovar%2Fcgoso_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsovar%2Fcgoso_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsovar%2Fcgoso_c.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,7 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+const char *exported_var = \"Hello world\";"}, {"sha": "640db7b396a1cc8e832baeafa7327b43545fd8e7", "filename": "libgo/misc/cgo/testsovar/cgoso_c.h", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsovar%2Fcgoso_c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsovar%2Fcgoso_c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsovar%2Fcgoso_c.h?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+#ifdef WIN32\n+#if defined(EXPORT_DLL)\n+#    define VAR __declspec(dllexport)\n+#elif defined(IMPORT_DLL)\n+#    define VAR __declspec(dllimport)\n+#endif\n+#else\n+#    define VAR extern\n+#endif\n+\n+VAR const char *exported_var;"}, {"sha": "9c8a1c4e66e630766b4dc4f2ed2d1f4c9f53ef0e", "filename": "libgo/misc/cgo/testsovar/main.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsovar%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftestsovar%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsovar%2Fmain.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+package main\n+\n+import \".\"\n+\n+func main() {\n+\tcgosotest.Test()\n+}"}, {"sha": "e634220be7c1b62c9fbfba726c374dd4e314d21d", "filename": "libgo/misc/cgo/testtls/tls.go", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftesttls%2Ftls.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftesttls%2Ftls.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftesttls%2Ftls.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cgotlstest\n+\n+// #include <pthread.h>\n+// extern void setTLS(int);\n+// extern int getTLS();\n+import \"C\"\n+\n+import (\n+\t\"runtime\"\n+\t\"testing\"\n+)\n+\n+func testTLS(t *testing.T) {\n+\truntime.LockOSThread()\n+\tdefer runtime.UnlockOSThread()\n+\n+\tif val := C.getTLS(); val != 0 {\n+\t\tt.Fatalf(\"at start, C.getTLS() = %#x, want 0\", val)\n+\t}\n+\n+\tconst keyVal = 0x1234\n+\tC.setTLS(keyVal)\n+\tif val := C.getTLS(); val != keyVal {\n+\t\tt.Fatalf(\"at end, C.getTLS() = %#x, want %#x\", val, keyVal)\n+\t}\n+}"}, {"sha": "3076c2d5943b5cbc1482f504e7bbbe016ac71642", "filename": "libgo/misc/cgo/testtls/tls_test.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftesttls%2Ftls_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftesttls%2Ftls_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftesttls%2Ftls_test.go?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !windows\n+\n+package cgotlstest\n+\n+import \"testing\"\n+\n+func TestTLS(t *testing.T) {\n+\ttestTLS(t)\n+}"}, {"sha": "957afce90d4aedc8a79f8bfa5e447871086876b2", "filename": "libgo/misc/cgo/testtls/tls_unix.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftesttls%2Ftls_unix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/936615752a29ab245708d40782427c25e60a2114/libgo%2Fmisc%2Fcgo%2Ftesttls%2Ftls_unix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftesttls%2Ftls_unix.c?ref=936615752a29ab245708d40782427c25e60a2114", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include <pthread.h>\n+\n+static __thread int tls;\n+\n+void\n+setTLS(int v)\n+{\n+\ttls = v;\n+}\n+\n+int\n+getTLS()\n+{\n+\treturn tls;\n+}"}]}