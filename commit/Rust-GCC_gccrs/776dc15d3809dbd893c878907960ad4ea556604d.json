{"sha": "776dc15d3809dbd893c878907960ad4ea556604d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc2ZGMxNWQzODA5ZGJkODkzYzg3ODkwNzk2MGFkNGVhNTU2NjA0ZA==", "commit": {"author": {"name": "Kelley Cook", "email": "kcook@gcc.gnu.org", "date": "2004-06-18T01:59:45Z"}, "committer": {"name": "R. Kelley Cook", "email": "kcook@gcc.gnu.org", "date": "2004-06-18T01:59:45Z"}, "message": "opts.sh: Delete.\n\n2004-06-18  Kelley Cook  <kcook@gcc.gnu.org>\n\n\t* opts.sh: Delete.  Break out generated code to next four files.\n\t* opt-gather.awk: New file.\n\t* optc-gen.awk: New file.\n\t* opth-gen.awk: New file.\n\t* opt-functions.awk: New common file.\n\t* Makefile.in: Update for above.\n\t* configure.ac: Update comment.\n\t* configure: Regenerate.\n\nFrom-SVN: r83333", "tree": {"sha": "c03c3ff40ade5a2a4cd1e88cba60f77e40759d7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c03c3ff40ade5a2a4cd1e88cba60f77e40759d7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/776dc15d3809dbd893c878907960ad4ea556604d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/776dc15d3809dbd893c878907960ad4ea556604d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/776dc15d3809dbd893c878907960ad4ea556604d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/776dc15d3809dbd893c878907960ad4ea556604d/comments", "author": null, "committer": null, "parents": [{"sha": "093c7153029151d28e4f60d9204d0edc31e7e3a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/093c7153029151d28e4f60d9204d0edc31e7e3a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/093c7153029151d28e4f60d9204d0edc31e7e3a2"}], "stats": {"total": 677, "additions": 429, "deletions": 248}, "files": [{"sha": "d3ee7a2e72ee34584299cfa5c0a45c4a3935d589", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/776dc15d3809dbd893c878907960ad4ea556604d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/776dc15d3809dbd893c878907960ad4ea556604d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=776dc15d3809dbd893c878907960ad4ea556604d", "patch": "@@ -1,3 +1,14 @@\n+2004-06-18  Kelley Cook  <kcook@gcc.gnu.org>\n+\n+\t* opts.sh: Delete.  Break out generated code to next four files.\n+\t* opt-gather.awk: New file.\n+\t* optc-gen.awk: New file.\n+\t* opth-gen.awk: New file.\n+\t* opt-functions.awk: New common file.\n+\t* Makefile.in: Update for above.\n+\t* configure.ac: Update comment.\n+\t* configure: Regenerate.\n+\n 2004-06-17  Richard Henderson  <rth@redhat.com>\n \n \t* c-common.c (flag_objc_sjlj_exceptions): New."}, {"sha": "0c1981f4db8d54297b3c349ee1cf9a6164507e8a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/776dc15d3809dbd893c878907960ad4ea556604d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/776dc15d3809dbd893c878907960ad4ea556604d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=776dc15d3809dbd893c878907960ad4ea556604d", "patch": "@@ -1511,13 +1511,21 @@ s-specs : Makefile\n \t$(SHELL) $(srcdir)/../move-if-change tmp-specs.h specs.h\n \t$(STAMP) s-specs\n \n-options.c options.h: s-options ; @true\n-s-options: $(lang_opt_files) $(srcdir)/opts.sh Makefile\n-\tAWK=$(AWK) $(SHELL) $(srcdir)/opts.sh \\\n-               '$(SHELL) $(srcdir)/../move-if-change' \\\n-               options.c options.h $(lang_opt_files)\n+optionlist: s-options ; @true\n+s-options: $(lang_opt_files) Makefile $(srcdir)/opt-gather.awk\n+\t$(AWK) -f $(srcdir)/opt-gather.awk $(lang_opt_files) > tmp-optionlist\n+\t$(SHELL) $(srcdir)/../move-if-change tmp-optionlist optionlist\n \t$(STAMP) s-options\n \n+\n+options.c: optionlist $(srcdir)/opt-functions.awk $(srcdir)/optc-gen.awk\n+\t$(AWK) -f $(srcdir)/opt-functions.awk -f $(srcdir)/optc-gen.awk \\\n+\t       -v header_name=\"options.h\" < $< > $@ \n+\n+options.h: optionlist $(srcdir)/opt-functions.awk $(srcdir)/opth-gen.awk\n+\t$(AWK) -f $(srcdir)/opt-functions.awk -f $(srcdir)/opth-gen.awk \\\n+\t       < $< > $@\n+\n options.o: options.c options.h opts.h intl.h\n \n dumpvers: dumpvers.c\n@@ -3010,6 +3018,7 @@ clean: mostlyclean lang.clean\n \t-rm -f libgcc.a libgcc_eh.a libgcov.a\n \t-rm -f libgcc_s$(SHLIB_EXT) libgcc_s$(SHLIB_EXT).1\n \t-rm -f config.h tconfig.h bconfig.h tm_p.h tm.h\n+\t-rm -f options.c options.h optionlist\n \t-rm -f cs-*\n \t-rm -rf libgcc\n \t-rm -f doc/*.dvi"}, {"sha": "ef40f176ce0c885c5c39e12765d2e1f07632e9f1", "filename": "gcc/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/776dc15d3809dbd893c878907960ad4ea556604d/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/776dc15d3809dbd893c878907960ad4ea556604d/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=776dc15d3809dbd893c878907960ad4ea556604d", "patch": "@@ -4906,7 +4906,7 @@ fi\n   test -n \"$AWK\" && break\n done\n \n-# We need awk to run opts.sh (to create options.c and options.h).\n+# We need awk to create options.c and options.h.\n # Bail out if it's missing.\n case ${AWK} in\n   \"\") { { echo \"$as_me:$LINENO: error: can't build without awk, bailing out\" >&5"}, {"sha": "3460d27ceb6f68ed4dfe7408485210b17577be58", "filename": "gcc/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/776dc15d3809dbd893c878907960ad4ea556604d/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/776dc15d3809dbd893c878907960ad4ea556604d/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=776dc15d3809dbd893c878907960ad4ea556604d", "patch": "@@ -720,7 +720,7 @@ AC_PROG_MAKE_SET\n \n # Find some useful tools\n AC_PROG_AWK\n-# We need awk to run opts.sh (to create options.c and options.h).\n+# We need awk to create options.c and options.h.\n # Bail out if it's missing.\n case ${AWK} in\n   \"\") AC_MSG_ERROR([can't build without awk, bailing out]) ;;"}, {"sha": "a21f29d4b1248f55141e8e951413a59d3ac44707", "filename": "gcc/opt-functions.awk", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/776dc15d3809dbd893c878907960ad4ea556604d/gcc%2Fopt-functions.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/776dc15d3809dbd893c878907960ad4ea556604d/gcc%2Fopt-functions.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopt-functions.awk?ref=776dc15d3809dbd893c878907960ad4ea556604d", "patch": "@@ -0,0 +1,76 @@\n+#  Copyright (C) 2003,2004 Free Software Foundation, Inc.\n+#  Contributed by Kelley Cook, June 2004.\n+#  Original code from Neil Booth, May 2003.\n+#\n+# This program is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 2, or (at your option) any\n+# later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n+\n+# Some common subroutines for use by opt[ch]-gen.awk.\n+\n+function switch_flags (flags)\n+{\n+\tflags = \" \" flags \" \"\n+\tresult = \"0\"\n+\tfor (j = 0; j < n_langs; j++) {\n+\t\tregex = \" \" langs[j] \" \"\n+\t\tgsub ( \"\\\\+\", \"\\\\+\", regex )\n+\t\tif (flags ~ regex)\n+\t\t\tresult = result \" | \" macros[j]\n+\t}\n+\tif (flags ~ \" Common \") result = result \" | CL_COMMON\"\n+\tif (flags ~ \" Joined \") result = result \" | CL_JOINED\"\n+\tif (flags ~ \" JoinedOrMissing \") \\\n+\t    result = result \" | CL_JOINED | CL_MISSING_OK\"\n+\tif (flags ~ \" Separate \") result = result \" | CL_SEPARATE\"\n+\tif (flags ~ \" RejectNegative \") result = result \" | CL_REJECT_NEGATIVE\"\n+\tif (flags ~ \" UInteger \") result = result \" | CL_UINTEGER\"\n+\tif (flags ~ \" Undocumented \") result = result \" | CL_UNDOCUMENTED\"\n+\tif (flags ~ \" Report \") result = result \" | CL_REPORT\"\n+\tsub( \"^0 \\\\| \", \"\", result )\n+\treturn result\n+}\n+\n+function var_args(flags)\n+{\n+\tif (flags !~ \"Var\\\\(\")\n+\t    return \"\"\n+\tsub(\".*Var\\\\(\", \"\", flags)\n+\tsub(\"\\\\).*\", \"\", flags)\n+\n+\treturn flags\n+}\n+function var_name(flags)\n+{\n+\ts = var_args(flags)\n+\tif (s == \"\")\n+\t\treturn \"\";\n+\tsub( \",.*\", \"\", s)\n+\treturn s\n+}\n+function var_set(flags)\n+{\n+\ts = var_args(flags)\n+\tif (s !~ \",\")\n+\t\treturn \"0, 0\"\n+\tsub( \"[^,]*,\", \"\", s)\n+\treturn \"1, \" s\n+}\n+function var_ref(flags)\n+{\n+\tname = var_name(flags)\n+\tif (name == \"\")\n+\t\treturn \"0\"\n+\telse\n+\t\treturn \"&\" name\n+}"}, {"sha": "2feb6d84372cb7cda737e430629a81b2b21d6a93", "filename": "gcc/opt-gather.awk", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/776dc15d3809dbd893c878907960ad4ea556604d/gcc%2Fopt-gather.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/776dc15d3809dbd893c878907960ad4ea556604d/gcc%2Fopt-gather.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopt-gather.awk?ref=776dc15d3809dbd893c878907960ad4ea556604d", "patch": "@@ -0,0 +1,54 @@\n+#  Copyright (C) 2003,2004 Free Software Foundation, Inc.\n+#  Contributed by Kelley Cook, June 2004.\n+#  Original code from Neil Booth, May 2003.\n+#\n+# This program is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 2, or (at your option) any\n+# later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n+\n+# This Awk script takes a list of *.opt files and combines them into \n+# a three-field sorted list suitable for input into opt[ch]-gen.awk.\n+#\n+# Usage: awk -f opt-gather.awk file1.opt [...] > outputfile\n+\n+function sort(ARRAY, ELEMENTS)\n+{\n+\tfor (i = 2; i <= ELEMENTS; ++i) {\n+\t\tfor (j = i; ARRAY[j-1] > ARRAY[j]; --j) {\n+\t\t\ttemp = ARRAY[j]\n+\t\t\tARRAY[j] = ARRAY[j-1]\n+\t\t\tARRAY[j-1] = temp\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+BEGIN {\tnumrec = 0 }\n+\n+# Ignore comments and blank lines\n+/^[ \\t]*(;|$)/  { flag = 0; next }\n+/^[^ \\t]/       { if (flag == 0) {\n+                    record[++numrec] = $0\n+\t\t    flag = 1 }\n+\t\t  else {\n+\t\t    record[numrec] = record[numrec] SUBSEP $0\n+\t          }\n+}\n+\n+# Sort it and output it\n+END {\n+\tsort(record,numrec)\n+\t\n+\tfor (i = 1; i <= numrec; i++) {\n+\t\tprint record[i] }\n+}"}, {"sha": "3ed1cf881bebc617223a7f26ecb6b476e22d0572", "filename": "gcc/optc-gen.awk", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/776dc15d3809dbd893c878907960ad4ea556604d/gcc%2Foptc-gen.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/776dc15d3809dbd893c878907960ad4ea556604d/gcc%2Foptc-gen.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptc-gen.awk?ref=776dc15d3809dbd893c878907960ad4ea556604d", "patch": "@@ -0,0 +1,144 @@\n+#  Copyright (C) 2003,2004 Free Software Foundation, Inc.\n+#  Contributed by Kelley Cook, June 2004.\n+#  Original code from Neil Booth, May 2003.\n+#\n+# This program is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 2, or (at your option) any\n+# later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n+\n+# This Awk script reads in the option records generated from \n+# opt-gather.awk, combines the flags of duplicat options and generates a\n+# C file.\n+#\n+# This program uses functions from opt-functions.awk\n+#\n+# Usage: awk -f opt-functions.awk -f optc-gen.awk \\\n+#            [-v header_name=header.h] < inputfile > options.c\n+\n+BEGIN {\n+\tn_opts = 0\n+\tn_langs = 0\n+        quote = \"\\042\"\n+\tcomma = \",\"\n+\tFS=SUBSEP\n+\t# Default the name of header created from opth-gen.awk to options.h\n+\tif (header_name == \"\") header_name=\"options.h\"\n+}\n+\n+# Collect the text and flags of each option into an array\n+\t{\n+\t\tif ($1 == \"Language\") {\n+\t\t\tlangs[n_langs] = $2\n+\t\t\tn_langs++;\n+\t\t}\n+\t\telse {\n+\t\t\topts[n_opts]  = $1\n+\t\t\tflags[n_opts] = $2\n+\t\t\thelp[n_opts]  = $3\n+\t\t\tn_opts++;\n+\t\t}\n+\t}\n+\n+# Dump that array of options into a C file.\n+END {\n+print \"/* This file is auto-generated by opts.sh.  */\"\n+print \"\"\n+print \"#include <intl.h>\"\n+print \"#include \" quote header_name quote\n+print \"#include \" quote \"opts.h\" quote\n+print \"\"\n+\n+for (i = 0; i < n_opts; i++) {\n+\tname = var_name(flags[i]);\n+\tif (name == \"\")\n+\t\tcontinue;\n+\n+\tif (flags[i] ~ \"VarExists\")\n+\t\tcontinue;\n+\n+\tif (flags[i] ~ \"Init\\\\(\")\n+\t    {\n+\t\t    init = flags[i];\n+\t\t    sub(\".*Init\\\\(\",\"\",init);\n+\t\t    sub(\"\\\\).*\",\"\",init);\n+\t\t    init = \" = \" init;\n+\t    }\n+\t else\n+\t\t    init = \"\";\n+\n+\t printf (\"/* Set by -%s.\\n   %s  */\\nint %s%s;\\n\\n\",\n+\t    opts[i], help[i], name,init)\n+    }\n+\n+\n+print \"const char * const lang_names[] =\\n{\"\n+for (i = 0; i < n_langs; i++) {\n+\tmacros[i] = \"CL_\" langs[i]\n+\tgsub( \"[^A-Za-z0-9_]\", \"X\", macros[i] )\n+\ts = substr(\"         \", length (macros[i]))\n+\tprint \"  \" quote langs[i] quote \",\"\n+    }\n+\n+print \"  0\\n};\\n\"\n+print \"const unsigned int cl_options_count = N_OPTS;\\n\"\n+\n+print \"const struct cl_option cl_options[] =\\n{\"\n+\n+for (i = 0; i < n_opts; i++)\n+\tback_chain[i] = \"N_OPTS\";\n+\n+\tfor (i = 0; i < n_opts; i++) {\n+\t\t# Combine the flags of identical switches.  Switches\n+\t\t# appear many times if they are handled by many front\n+\t\t# ends, for example.\n+\t\twhile( i + 1 != n_opts && opts[i] == opts[i + 1] ) {\n+\t\t\tflags[i + 1] = flags[i] \" \" flags[i + 1];\n+\t\t\ti++;\n+\t\t}\n+\n+\t\tlen = length (opts[i]);\n+\t\tenum = \"OPT_\" opts[i]\n+\t\tif (opts[i] == \"finline-limit=\")\n+\t\t\tenum = enum \"eq\"\n+\t\tgsub (\"[^A-Za-z0-9]\", \"_\", enum)\n+\n+\t\t# If this switch takes joined arguments, back-chain all\n+\t\t# subsequent switches to it for which it is a prefix.  If\n+\t\t# a later switch S is a longer prefix of a switch T, T\n+\t\t# will be back-chained to S in a later iteration of this\n+\t\t# for() loop, which is what we want.\n+\t\tif (flags[i] ~ \"Joined\") {\n+\t\t\tfor (j = i + 1; j < n_opts; j++) {\n+\t\t\t\tif (substr (opts[j], 1, len) != opts[i])\n+\t\t\t\t\tbreak;\n+\t\t\t\tback_chain[j] = enum;\n+\t\t\t}\n+\t\t}\n+\n+\t\ts = substr(\"                                  \", length (opts[i]))\n+\t\tif (i + 1 == n_opts)\n+\t\t\tcomma = \"\"\n+\n+\t\tif (help[i] == \"\")\n+\t\t\thlp = \"0\"\n+\t\telse\n+\t\t\thlp = \"N_(\" quote help[i] quote \")\";\n+\n+\t\tprintf(\"  { %c-%s%c,\\n    %s,\\n    %s, %u, %s, %s, %s }%s\\n\",\n+\t\t\tquote, opts[i], quote, hlp, back_chain[i], len,\n+\t\t\tswitch_flags(flags[i]),\n+\t\t\tvar_ref(flags[i]), var_set(flags[i]), comma)\n+}\n+\n+print \"};\"\n+}"}, {"sha": "6cea944bc494be648704f36ab4acbec3ef1e7e5e", "filename": "gcc/opth-gen.awk", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/776dc15d3809dbd893c878907960ad4ea556604d/gcc%2Fopth-gen.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/776dc15d3809dbd893c878907960ad4ea556604d/gcc%2Fopth-gen.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopth-gen.awk?ref=776dc15d3809dbd893c878907960ad4ea556604d", "patch": "@@ -0,0 +1,128 @@\n+#  Copyright (C) 2003,2004 Free Software Foundation, Inc.\n+#  Contributed by Kelley Cook, June 2004.\n+#  Original code from Neil Booth, May 2003.\n+#\n+# This program is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 2, or (at your option) any\n+# later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n+\n+# This Awk script reads in the option records generated from \n+# opt-gather.awk, combines the flags of duplicate options and generates a\n+# C header file.\n+#\n+# This program uses functions from opt-functions.awk\n+# Usage: awk -f opt-functions.awk -f opth-gen.awk < inputfile > options.h\n+\n+BEGIN {\n+\tn_opts = 0\n+\tn_langs = 0\n+        quote = \"\\042\"\n+\tcomma = \",\"\n+\tFS=SUBSEP\n+}\n+\n+# Collect the text and flags of each option into an array\n+\t{\n+\t\tif ($1 == \"Language\") {\n+\t\t\tlangs[n_langs] = $2\n+\t\t\tn_langs++;\n+\t\t}\n+\t\telse {\n+\t\t\topts[n_opts]  = $1\n+\t\t\tflags[n_opts] = $2\n+\t\t\thelp[n_opts]  = $3\n+\t\t\tn_opts++;\n+\t\t}\n+\t}\n+\n+# Dump out an enumeration into a .h file.\n+# Combine the flags of duplicate options.\n+END {\n+print \"/* This file is auto-generated by opts.sh.  */\"\n+print \"\"\n+print \"#ifndef OPTIONS_H\"\n+print \"#define OPTIONS_H\"\n+print \"\"\n+\n+for (i = 0; i < n_opts; i++) {\n+\tname = var_name(flags[i]);\n+\tif (name == \"\")\n+\t\tcontinue;\n+\n+\tprint \"/* Set by -\" opts[i] \".\"\n+\tprint \"   \" help[i] \"  */\"\n+\tprint \"extern int \" name \";\"\n+\tprint \"\"\n+\n+    }\n+\n+\n+for (i = 0; i < n_langs; i++) {\n+\tmacros[i] = \"CL_\" langs[i]\n+\tgsub( \"[^A-Za-z0-9_]\", \"X\", macros[i] )\n+\ts = substr(\"            \", length (macros[i]))\n+\tprint \"#define \" macros[i] s \" (1 << \" i \")\"\n+    }\n+\n+print \"\"\n+print \"enum opt_code\"\n+print \"{\"\n+\t\n+for (i = 0; i < n_opts; i++)\n+\tback_chain[i] = \"N_OPTS\";\n+\n+\tfor (i = 0; i < n_opts; i++) {\n+\t\t# Combine the flags of identical switches.  Switches\n+\t\t# appear many times if they are handled by many front\n+\t\t# ends, for example.\n+\t\twhile( i + 1 != n_opts && opts[i] == opts[i + 1] ) {\n+\t\t\tflags[i + 1] = flags[i] \" \" flags[i + 1];\n+\t\t\ti++;\n+\t\t}\n+\n+\tlen = length (opts[i]);\n+\tenum = \"OPT_\" opts[i]\n+\tif (opts[i] == \"finline-limit=\")\n+\t\tenum = enum \"eq\"\n+\tgsub (\"[^A-Za-z0-9]\", \"_\", enum)\n+\n+\t# If this switch takes joined arguments, back-chain all\n+\t# subsequent switches to it for which it is a prefix.  If\n+\t# a later switch S is a longer prefix of a switch T, T\n+\t# will be back-chained to S in a later iteration of this\n+\t# for() loop, which is what we want.\n+\tif (flags[i] ~ \"Joined\") {\n+\t\tfor (j = i + 1; j < n_opts; j++) {\n+\t\t\tif (substr (opts[j], 1, len) != opts[i])\n+\t\t\t\tbreak;\n+\t\t\tback_chain[j] = enum;\n+\t\t}\n+\t}\n+\n+\ts = substr(\"                                     \", length (opts[i]))\n+\tif (i + 1 == n_opts)\n+\t\tcomma = \"\"\n+\n+\tif (help[i] == \"\")\n+\t\thlp = \"0\"\n+\telse\n+\t\thlp = \"N_(\\\"\" help[i] \"\\\")\";\n+\n+\tprint \"  \" enum \",\" s \"/* -\" opts[i] \" */\"\n+}\n+\n+print \"  N_OPTS\"\n+print \"};\"\n+print \"\"\n+print \"#endif /* OPTIONS_H */\"\n+}"}, {"sha": "f73618141b155a6cb1b829b13ddc0fb2c01810f6", "filename": "gcc/opts.sh", "status": "removed", "additions": 0, "deletions": 241, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Fopts.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093c7153029151d28e4f60d9204d0edc31e7e3a2/gcc%2Fopts.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.sh?ref=093c7153029151d28e4f60d9204d0edc31e7e3a2", "patch": "@@ -1,241 +0,0 @@\n-#!/bin/sh\n-#\n-#  Copyright (C) 2003 Free Software Foundation, Inc.\n-#  Contributed by Neil Booth, May 2003.\n-#\n-# This program is free software; you can redistribute it and/or modify it\n-# under the terms of the GNU General Public License as published by the\n-# Free Software Foundation; either version 2, or (at your option) any\n-# later version.\n-# \n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-# \n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n-#\n-# Usage: opts.sh moveifchange srcdir outfile.c outfile.h file1.opt [ ...]\n-\n-# Always operate in the C locale.\n-LANG=C\n-LANGUAGE=C\n-LC_ALL=C\n-export LANG LANGUAGE LC_ALL\n-\n-# Set AWK if environment has not already set it.\n-AWK=${AWK-awk}\n-\n-SORT=sort\t\t# Could be /bin/sort or /usr/bin/sort\n-\n-MOVEIFCHANGE=$1; shift\n-C_FILE=$1; shift\n-H_FILE=$1; shift\n-TMP_C_FILE=tmp-${C_FILE}\n-TMP_H_FILE=tmp-${H_FILE}\n-\n-${AWK} '\n-\t# Ignore comments and blank lines\n-\t/^[ \\t]*(;|$)/\t{ next }\n-\t# Note that RS=\"\" falls foul of gawk 3.1.2 bugs\n-\t/^[^ \\t]/       { record = $0\n-\t\t\t  do { getline tmp;\n-\t\t\t       if (!(tmp ~ \"^[ \\t]*(;|$)\"))\n-\t\t\t          record = record \"\\034\" tmp\n-\t\t\t  } while (tmp != \"\")\n-\t\t\t  print record\n-\t\t\t}\n-' \"$@\" | ${SORT} | ${AWK} '\n-    function switch_flags (flags,   result)\n-    {\n-\tflags = \" \" flags \" \"\n-\tresult = \"0\"\n-\tfor (j = 0; j < n_langs; j++) {\n-\t    regex = \" \" langs[j] \" \"\n-\t    gsub ( \"\\\\+\", \"\\\\+\", regex )\n-\t    if (flags ~ regex)\n-\t\tresult = result \" | \" macros[j]\n-\t}\n-        if (flags ~ \" Common \") result = result \" | CL_COMMON\"\n-        if (flags ~ \" Joined \") result = result \" | CL_JOINED\"\n-        if (flags ~ \" JoinedOrMissing \") \\\n-\t\tresult = result \" | CL_JOINED | CL_MISSING_OK\"\n-        if (flags ~ \" Separate \") result = result \" | CL_SEPARATE\"\n-        if (flags ~ \" RejectNegative \") result = result \" | CL_REJECT_NEGATIVE\"\n-        if (flags ~ \" UInteger \") result = result \" | CL_UINTEGER\"\n-        if (flags ~ \" Undocumented \") result = result \" | CL_UNDOCUMENTED\"\n-        if (flags ~ \" Report \") result = result \" | CL_REPORT\"\n-\tsub( \"^0 \\\\| \", \"\", result )\n-\treturn result\n-    }\n-    function var_args(flags)\n-    {\n-\tif (flags !~ \"Var\\\\(\")\n-\t  return \"\";\n-\tsub(\".*Var\\\\(\", \"\", flags);\n-\tsub(\"\\\\).*\", \"\", flags);\n-\n-\treturn flags;\n-    }\n-    function var_name(flags)\n-    {\n-\ts = var_args(flags);\n-\tif (s == \"\")\n-\t  return \"\";\n-\tsub( \",.*\", \"\", s);\n-\treturn s;\n-    }\n-    function var_set(flags)\n-    {\n-\ts = var_args(flags);\n-\tif (s !~ \",\")\n-\t  return \"0, 0\";\n-\tsub( \"[^,]*,\", \"\", s);\n-\treturn \"1, \" s;\n-    }\n-    function var_ref(flags)\n-    {\n-\tname = var_name(flags);\n-\tif (name == \"\")\n-\t  return \"0\";\n-\telse\n-\t  return \"&\" name;\n-    }\n-\n-    BEGIN {\n-\tFS = \"\\034\"\n-\tn_opts = 0\n-\tn_langs = 0\n-    }\n-\n-# Collect the text and flags of each option into an array\n-    {\n-\tif ($1 == \"Language\") {\n-\t\tlangs[n_langs] = $2\n-\t\tn_langs++;\n-\t} else {\n-\t\topts[n_opts] = $1\n-\t\tflags[n_opts] = $2\n-\t\thelp[n_opts] = $3\n-\t\tn_opts++;\n-\t}\n-    }\n-\n-# Dump out an enumeration into a .h file, and an array of options into a\n-# C file.  Combine the flags of duplicate options.\n-    END {\n- \tc_file = \"'${TMP_C_FILE}'\"\n- \th_file = \"'${TMP_H_FILE}'\"\n- \trealh_file = \"'${H_FILE}'\"\n-\tcomma = \",\"\n-\n-\tprint \"/* This file is auto-generated by opts.sh.  */\\n\" > c_file\n-\tprint \"#include <intl.h>\"\t\t\t>> c_file\n-\tprint \"#include \\\"\" realh_file \"\\\"\"\t\t>> c_file\n-\tprint \"#include \\\"opts.h\\\"\\n\"\t\t\t>> c_file\n-\n-\tprint \"/* This file is auto-generated by opts.sh.  */\\n\" > h_file\n-\tprint \"#ifndef OPTIONS_H\"\t\t\t>> h_file\n-\tprint \"#define OPTIONS_H\\n\"\t\t\t>> h_file\n-\n-\tfor (i = 0; i < n_opts; i++) {\n-\t    name = var_name(flags[i]);\n-\t    if (name == \"\")\n-\t       continue;\n-\n-\t    printf (\"/* Set by -%s.\\n   %s  */\\nextern int %s;\\n\\n\",\n-\t      opts[i], help[i], name)\t\t>> h_file\n-\n-\t    if (flags[i] ~ \"VarExists\")\n-\t      continue;\n-\n-\t    if (flags[i] ~ \"Init\\\\(\")\n-\t      {\n-\t\tinit = flags[i];\n-\t\tsub(\".*Init\\\\(\",\"\",init);\n-\t\tsub(\"\\\\).*\",\"\",init);\n-\t\tinit = \" = \" init;\n-\t      }\n-\t    else\n-\t      init = \"\";\n-\n-\t    printf (\"/* Set by -%s.\\n   %s  */\\nint %s%s;\\n\\n\",\n-\t\t    opts[i], help[i], name,init)\t>> c_file\n-\t    }\n-\n-\n-\tprint \"const char * const lang_names[] =\\n{\"\t>> c_file\n-\tfor (i = 0; i < n_langs; i++) {\n-\t    macros[i] = \"CL_\" langs[i]\n-\t    gsub( \"[^A-Za-z0-9_]\", \"X\", macros[i] )\n-\t    s = substr(\"         \", length (macros[i]))\n-\t    print \"#define \" macros[i] s \" (1 << \" i \")\" >> h_file\n-\t    print \"  \\\"\" langs[i] \"\\\",\"\t\t\t>> c_file\n-\t}\n-\n-\tprint \"  0\\n};\\n\"\t\t\t\t>> c_file\n-\tprint \"const unsigned int cl_options_count = N_OPTS;\\n\" >> c_file\n-\n-\tprint \"const struct cl_option cl_options[] =\\n{\" >> c_file\n-\n-\tprint \"\\nenum opt_code\\n{\"\t\t\t>> h_file\n-\n-\tfor (i = 0; i < n_opts; i++)\n-\t    back_chain[i] = \"N_OPTS\";\n-\n-\tfor (i = 0; i < n_opts; i++) {\n-\t    # Combine the flags of identical switches.  Switches\n-\t    # appear many times if they are handled by many front\n-\t    # ends, for example.\n-\t    while( i + 1 != n_opts && opts[i] == opts[i + 1] ) {\n-\t\tflags[i + 1] = flags[i] \" \" flags[i + 1];\n-\t\ti++;\n-\t    }\n-\n-\t    len = length (opts[i]);\n-\t    enum = \"OPT_\" opts[i]\n-\t    if (opts[i] == \"finline-limit=\")\n-\t\tenum = enum \"eq\"\n-\t    gsub (\"[^A-Za-z0-9]\", \"_\", enum)\n-\n-\t    # If this switch takes joined arguments, back-chain all\n-\t    # subsequent switches to it for which it is a prefix.  If\n-\t    # a later switch S is a longer prefix of a switch T, T\n-\t    # will be back-chained to S in a later iteration of this\n-\t    # for() loop, which is what we want.\n-\t    if (flags[i] ~ \"Joined\") {\n-\t\tfor (j = i + 1; j < n_opts; j++) {\n-\t\t    if (substr (opts[j], 1, len) != opts[i])\n-\t\t\tbreak;\n-\t\t    back_chain[j] = enum;\n-\t\t}\n-\t    }\n-\n-\t    s = substr(\"                                  \", length (opts[i]))\n-\t    if (i + 1 == n_opts)\n-\t\tcomma = \"\"\n-\n-\t    if (help[i] == \"\")\n-\t\thlp = \"0\"\n-\t    else\n-\t    \thlp = \"N_(\\\"\" help[i] \"\\\")\";\n-\n-\t    printf(\"  %s,%s/* -%s */\\n\", enum, s, opts[i]) >> h_file\n-\t    printf(\"  { \\\"-%s\\\",\\n    %s,\\n    %s, %u, %s, %s, %s }%s\\n\",\n-\t\t   opts[i], hlp, back_chain[i], len,\n-\t\t   switch_flags(flags[i]),\n-\t\t   var_ref(flags[i]), var_set(flags[i]), comma)\t>> c_file\n-\t}\n-\n-\tprint \"  N_OPTS\\n};\\n\"\t\t\t\t>> h_file\n-\tprint \"#endif /* OPTIONS_H */\"\t\t\t>> h_file\n-\tprint \"};\"\t\t\t\t\t>> c_file\n-    }\n-'\n-\n-# Copy the newly generated files back to the correct names only if different.\n-# This is to prevent a cascade of file rebuilds when not necessary.\n-${MOVEIFCHANGE} ${TMP_H_FILE} ${H_FILE}\n-${MOVEIFCHANGE} ${TMP_C_FILE} ${C_FILE}"}]}