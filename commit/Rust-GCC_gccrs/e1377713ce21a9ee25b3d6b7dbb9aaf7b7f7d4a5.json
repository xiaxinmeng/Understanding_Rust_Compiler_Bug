{"sha": "e1377713ce21a9ee25b3d6b7dbb9aaf7b7f7d4a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTEzNzc3MTNjZTIxYTllZTI1YjNkNmI3ZGJiOWFhZjdiN2Y3ZDRhNQ==", "commit": {"author": {"name": "Evgeny Stupachenko", "email": "evstupac@gmail.com", "date": "2014-06-11T08:37:53Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2014-06-11T08:37:53Z"}, "message": "re PR tree-optimization/52252 (An opportunity for x86 gcc vectorizer (gain up to 3 times))\n\ngcc/\n\t* tree-vect-data-refs.c (vect_grouped_store_supported): New\n\tcheck for stores group of length 3.\n\t(vect_permute_store_chain): New permutations for stores group of\n\tlength 3.\n\t* tree-vect-stmts.c (vect_model_store_cost): Change cost\n\tof vec_perm_shuffle for the new permutations.\n\ngcc/testsuite/\n\tPR tree-optimization/52252\n\t* gcc.dg/vect/pr52252-st.c: Test on stores group of size 3.\n\nFrom-SVN: r211439", "tree": {"sha": "289342ef986aaaa4101dfb80034c93bd6f2e14dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/289342ef986aaaa4101dfb80034c93bd6f2e14dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1377713ce21a9ee25b3d6b7dbb9aaf7b7f7d4a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1377713ce21a9ee25b3d6b7dbb9aaf7b7f7d4a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1377713ce21a9ee25b3d6b7dbb9aaf7b7f7d4a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1377713ce21a9ee25b3d6b7dbb9aaf7b7f7d4a5/comments", "author": {"login": "evstupac", "id": 38332307, "node_id": "MDQ6VXNlcjM4MzMyMzA3", "avatar_url": "https://avatars.githubusercontent.com/u/38332307?v=4", "gravatar_id": "", "url": "https://api.github.com/users/evstupac", "html_url": "https://github.com/evstupac", "followers_url": "https://api.github.com/users/evstupac/followers", "following_url": "https://api.github.com/users/evstupac/following{/other_user}", "gists_url": "https://api.github.com/users/evstupac/gists{/gist_id}", "starred_url": "https://api.github.com/users/evstupac/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/evstupac/subscriptions", "organizations_url": "https://api.github.com/users/evstupac/orgs", "repos_url": "https://api.github.com/users/evstupac/repos", "events_url": "https://api.github.com/users/evstupac/events{/privacy}", "received_events_url": "https://api.github.com/users/evstupac/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "862b3da6a46799de1c1f4a84ef949e52d69fa3ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/862b3da6a46799de1c1f4a84ef949e52d69fa3ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/862b3da6a46799de1c1f4a84ef949e52d69fa3ff"}], "stats": {"total": 262, "additions": 211, "deletions": 51}, "files": [{"sha": "d361c443ca75ace9f5766bc39a63da81c1d57460", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1377713ce21a9ee25b3d6b7dbb9aaf7b7f7d4a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1377713ce21a9ee25b3d6b7dbb9aaf7b7f7d4a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e1377713ce21a9ee25b3d6b7dbb9aaf7b7f7d4a5", "patch": "@@ -1,3 +1,12 @@\n+2014-06-11  Evgeny Stupachenko  <evstupac@gmail.com>\n+\n+\t* tree-vect-data-refs.c (vect_grouped_store_supported): New\n+\tcheck for stores group of length 3.\n+\t(vect_permute_store_chain): New permutations for stores group of\n+\tlength 3.\n+\t* tree-vect-stmts.c (vect_model_store_cost): Change cost\n+\tof vec_perm_shuffle for the new permutations.\n+\n 2014-06-11  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-visibility.c (function_and_variable_visibility): Disable"}, {"sha": "394eca23f38d2fa929f293280048b2a1129210ab", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1377713ce21a9ee25b3d6b7dbb9aaf7b7f7d4a5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1377713ce21a9ee25b3d6b7dbb9aaf7b7f7d4a5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e1377713ce21a9ee25b3d6b7dbb9aaf7b7f7d4a5", "patch": "@@ -1,3 +1,8 @@\n+2014-06-11  Evgeny Stupachenko  <evstupac@gmail.com>\n+\n+\tPR tree-optimization/52252\n+\t* gcc.dg/vect/pr52252-st.c: Test on stores group of size 3.\n+\n 2014-06-11  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/61437"}, {"sha": "e7161f73f86ac993736d0e2f8e51727440a4d5fc", "filename": "gcc/testsuite/gcc.dg/vect/pr52252-st.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1377713ce21a9ee25b3d6b7dbb9aaf7b7f7d4a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr52252-st.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1377713ce21a9ee25b3d6b7dbb9aaf7b7f7d4a5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr52252-st.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr52252-st.c?ref=e1377713ce21a9ee25b3d6b7dbb9aaf7b7f7d4a5", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-mssse3\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+#define byte unsigned char\n+\n+void\n+matrix_mul (byte *in, byte *out, int size)\n+{\n+  int i;\n+  for (i = 0; i < size; i++)\n+    {\n+      out[0] = in[0] + in[1] + in[3];\n+      out[1] = in[0] + in[2] + in[4];\n+      out[2] = in[1] + in[2] + in[4];\n+      in += 4;\n+      out += 3;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { i?86-*-* x86_64-*-* } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "b23046964c13d40e66c85bd2118de908b7b9c980", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 173, "deletions": 48, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1377713ce21a9ee25b3d6b7dbb9aaf7b7f7d4a5/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1377713ce21a9ee25b3d6b7dbb9aaf7b7f7d4a5/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=e1377713ce21a9ee25b3d6b7dbb9aaf7b7f7d4a5", "patch": "@@ -4364,13 +4364,14 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n {\n   enum machine_mode mode = TYPE_MODE (vectype);\n \n-  /* vect_permute_store_chain requires the group size to be a power of two.  */\n-  if (exact_log2 (count) == -1)\n+  /* vect_permute_store_chain requires the group size to be equal to 3 or\n+     be a power of two.  */\n+  if (count != 3 && exact_log2 (count) == -1)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"the size of the group of accesses\"\n-                         \" is not a power of 2\\n\");\n+\t\t\t \"the size of the group of accesses\"\n+\t\t\t \" is not a power of 2 or not eqaul to 3\\n\");\n       return false;\n     }\n \n@@ -4379,23 +4380,76 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n     {\n       unsigned int i, nelt = GET_MODE_NUNITS (mode);\n       unsigned char *sel = XALLOCAVEC (unsigned char, nelt);\n-      for (i = 0; i < nelt / 2; i++)\n+\n+      if (count == 3)\n \t{\n-\t  sel[i * 2] = i;\n-\t  sel[i * 2 + 1] = i + nelt;\n+\t  unsigned int j0 = 0, j1 = 0, j2 = 0;\n+\t  unsigned int i, j;\n+\n+\t  for (j = 0; j < 3; j++)\n+\t    {\n+\t      int nelt0 = ((3 - j) * nelt) % 3;\n+\t      int nelt1 = ((3 - j) * nelt + 1) % 3;\n+\t      int nelt2 = ((3 - j) * nelt + 2) % 3;\n+\t      for (i = 0; i < nelt; i++)\n+\t\t{\n+\t\t  if (3 * i + nelt0 < nelt)\n+\t\t    sel[3 * i + nelt0] = j0++;\n+\t\t  if (3 * i + nelt1 < nelt)\n+\t\t    sel[3 * i + nelt1] = nelt + j1++;\n+\t\t  if (3 * i + nelt2 < nelt)\n+\t\t    sel[3 * i + nelt2] = 0;\n+\t\t}\n+\t      if (!can_vec_perm_p (mode, false, sel))\n+\t\t{\n+\t\t  if (dump_enabled_p ())\n+\t\t    dump_printf (MSG_MISSED_OPTIMIZATION,\n+\t\t\t\t \"permutaion op not supported by target.\\n\");\n+\t\t  return false;\n+\t\t}\n+\n+\t      for (i = 0; i < nelt; i++)\n+\t\t{\n+\t\t  if (3 * i + nelt0 < nelt)\n+\t\t    sel[3 * i + nelt0] = 3 * i + nelt0;\n+\t\t  if (3 * i + nelt1 < nelt)\n+\t\t    sel[3 * i + nelt1] = 3 * i + nelt1;\n+\t\t  if (3 * i + nelt2 < nelt)\n+\t\t    sel[3 * i + nelt2] = nelt + j2++;\n+\t\t}\n+\t      if (!can_vec_perm_p (mode, false, sel))\n+\t\t{\n+\t\t  if (dump_enabled_p ())\n+\t\t    dump_printf (MSG_MISSED_OPTIMIZATION,\n+\t\t\t\t \"permutaion op not supported by target.\\n\");\n+\t\t  return false;\n+\t\t}\n+\t    }\n+\t  return true;\n \t}\n-      if (can_vec_perm_p (mode, false, sel))\n+      else\n \t{\n-\t  for (i = 0; i < nelt; i++)\n-\t    sel[i] += nelt / 2;\n-\t  if (can_vec_perm_p (mode, false, sel))\n-\t    return true;\n+\t  /* If length is not equal to 3 then only power of 2 is supported.  */\n+\t  gcc_assert (exact_log2 (count) != -1);\n+\n+\t  for (i = 0; i < nelt / 2; i++)\n+\t    {\n+\t      sel[i * 2] = i;\n+\t      sel[i * 2 + 1] = i + nelt;\n+\t    }\n+\t    if (can_vec_perm_p (mode, false, sel))\n+\t      {\n+\t\tfor (i = 0; i < nelt; i++)\n+\t\t  sel[i] += nelt / 2;\n+\t\tif (can_vec_perm_p (mode, false, sel))\n+\t\t  return true;\n+\t      }\n \t}\n     }\n \n   if (dump_enabled_p ())\n     dump_printf (MSG_MISSED_OPTIMIZATION,\n-                 \"interleave op not supported by target.\\n\");\n+\t\t \"permutaion op not supported by target.\\n\");\n   return false;\n }\n \n@@ -4415,9 +4469,9 @@ vect_store_lanes_supported (tree vectype, unsigned HOST_WIDE_INT count)\n /* Function vect_permute_store_chain.\n \n    Given a chain of interleaved stores in DR_CHAIN of LENGTH that must be\n-   a power of 2, generate interleave_high/low stmts to reorder the data\n-   correctly for the stores.  Return the final references for stores in\n-   RESULT_CHAIN.\n+   a power of 2 or equal to 3, generate interleave_high/low stmts to reorder\n+   the data correctly for the stores.  Return the final references for stores\n+   in RESULT_CHAIN.\n \n    E.g., LENGTH is 4 and the scalar type is short, i.e., VF is 8.\n    The input is 4 vectors each containing 8 elements.  We assign a number to\n@@ -4484,55 +4538,126 @@ vect_permute_store_chain (vec<tree> dr_chain,\n   gimple perm_stmt;\n   tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n   tree perm_mask_low, perm_mask_high;\n-  unsigned int i, n;\n+  tree data_ref;\n+  tree perm3_mask_low, perm3_mask_high;\n+  unsigned int i, n, log_length = exact_log2 (length);\n   unsigned int j, nelt = TYPE_VECTOR_SUBPARTS (vectype);\n   unsigned char *sel = XALLOCAVEC (unsigned char, nelt);\n \n   result_chain->quick_grow (length);\n   memcpy (result_chain->address (), dr_chain.address (),\n \t  length * sizeof (tree));\n \n-  for (i = 0, n = nelt / 2; i < n; i++)\n+  if (length == 3)\n     {\n-      sel[i * 2] = i;\n-      sel[i * 2 + 1] = i + nelt;\n-    }\n-  perm_mask_high = vect_gen_perm_mask (vectype, sel);\n-  gcc_assert (perm_mask_high != NULL);\n+      unsigned int j0 = 0, j1 = 0, j2 = 0;\n \n-  for (i = 0; i < nelt; i++)\n-    sel[i] += nelt / 2;\n-  perm_mask_low = vect_gen_perm_mask (vectype, sel);\n-  gcc_assert (perm_mask_low != NULL);\n+      for (j = 0; j < 3; j++)\n+        {\n+\t  int nelt0 = ((3 - j) * nelt) % 3;\n+\t  int nelt1 = ((3 - j) * nelt + 1) % 3;\n+\t  int nelt2 = ((3 - j) * nelt + 2) % 3;\n \n-  for (i = 0, n = exact_log2 (length); i < n; i++)\n-    {\n-      for (j = 0; j < length/2; j++)\n-\t{\n-\t  vect1 = dr_chain[j];\n-\t  vect2 = dr_chain[j+length/2];\n+\t  for (i = 0; i < nelt; i++)\n+\t    {\n+\t      if (3 * i + nelt0 < nelt)\n+\t\tsel[3 * i + nelt0] = j0++;\n+\t      if (3 * i + nelt1 < nelt)\n+\t\tsel[3 * i + nelt1] = nelt + j1++;\n+\t      if (3 * i + nelt2 < nelt)\n+\t\tsel[3 * i + nelt2] = 0;\n+\t    }\n+\t  perm3_mask_low = vect_gen_perm_mask (vectype, sel);\n+\t  gcc_assert (perm3_mask_low != NULL);\n+\n+\t  for (i = 0; i < nelt; i++)\n+\t    {\n+\t      if (3 * i + nelt0 < nelt)\n+\t\tsel[3 * i + nelt0] = 3 * i + nelt0;\n+\t      if (3 * i + nelt1 < nelt)\n+\t\tsel[3 * i + nelt1] = 3 * i + nelt1;\n+\t      if (3 * i + nelt2 < nelt)\n+\t\tsel[3 * i + nelt2] = nelt + j2++;\n+\t    }\n+\t  perm3_mask_high = vect_gen_perm_mask (vectype, sel);\n+\t  gcc_assert (perm3_mask_high != NULL);\n+\n+\t  vect1 = dr_chain[0];\n+\t  vect2 = dr_chain[1];\n \n \t  /* Create interleaving stmt:\n-\t     high = VEC_PERM_EXPR <vect1, vect2, {0, nelt, 1, nelt+1, ...}>  */\n-\t  high = make_temp_ssa_name (vectype, NULL, \"vect_inter_high\");\n-\t  perm_stmt\n-\t    = gimple_build_assign_with_ops (VEC_PERM_EXPR, high,\n-\t\t\t\t\t    vect1, vect2, perm_mask_high);\n+\t     low = VEC_PERM_EXPR <vect1, vect2,\n+\t\t\t\t  {j, nelt, *, j + 1, nelt + j + 1, *,\n+\t\t\t\t   j + 2, nelt + j + 2, *, ...}>  */\n+\t  data_ref = make_temp_ssa_name (vectype, NULL, \"vect_shuffle3_low\");\n+\t  perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n+\t\t\t\t\t\t    vect1, vect2,\n+\t\t\t\t\t\t    perm3_mask_low);\n \t  vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n-\t  (*result_chain)[2*j] = high;\n \n+\t  vect1 = data_ref;\n+\t  vect2 = dr_chain[2];\n \t  /* Create interleaving stmt:\n-\t     low = VEC_PERM_EXPR <vect1, vect2, {nelt/2, nelt*3/2, nelt/2+1,\n-\t\t\t\t\t\t nelt*3/2+1, ...}>  */\n-\t  low = make_temp_ssa_name (vectype, NULL, \"vect_inter_low\");\n-\t  perm_stmt\n-\t    = gimple_build_assign_with_ops (VEC_PERM_EXPR, low,\n-\t\t\t\t\t    vect1, vect2, perm_mask_low);\n+\t     low = VEC_PERM_EXPR <vect1, vect2,\n+\t\t\t\t  {0, 1, nelt + j, 3, 4, nelt + j + 1,\n+\t\t\t\t   6, 7, nelt + j + 2, ...}>  */\n+\t  data_ref = make_temp_ssa_name (vectype, NULL, \"vect_shuffle3_high\");\n+\t  perm_stmt = gimple_build_assign_with_ops (VEC_PERM_EXPR, data_ref,\n+\t\t\t\t\t\t    vect1, vect2,\n+\t\t\t\t\t\t    perm3_mask_high);\n \t  vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n-\t  (*result_chain)[2*j+1] = low;\n+\t  (*result_chain)[j] = data_ref;\n+\t}\n+    }\n+  else\n+    {\n+      /* If length is not equal to 3 then only power of 2 is supported.  */\n+      gcc_assert (exact_log2 (length) != -1);\n+\n+      for (i = 0, n = nelt / 2; i < n; i++)\n+\t{\n+\t  sel[i * 2] = i;\n+\t  sel[i * 2 + 1] = i + nelt;\n \t}\n-      memcpy (dr_chain.address (), result_chain->address (),\n-\t      length * sizeof (tree));\n+\tperm_mask_high = vect_gen_perm_mask (vectype, sel);\n+\tgcc_assert (perm_mask_high != NULL);\n+\n+\tfor (i = 0; i < nelt; i++)\n+\t  sel[i] += nelt / 2;\n+\tperm_mask_low = vect_gen_perm_mask (vectype, sel);\n+\tgcc_assert (perm_mask_low != NULL);\n+\n+\tfor (i = 0, n = log_length; i < n; i++)\n+\t  {\n+\t    for (j = 0; j < length/2; j++)\n+\t      {\n+\t\tvect1 = dr_chain[j];\n+\t\tvect2 = dr_chain[j+length/2];\n+\n+\t\t/* Create interleaving stmt:\n+\t\t   high = VEC_PERM_EXPR <vect1, vect2, {0, nelt, 1, nelt+1,\n+\t\t\t\t\t\t\t...}>  */\n+\t\thigh = make_temp_ssa_name (vectype, NULL, \"vect_inter_high\");\n+\t\tperm_stmt\n+\t\t  = gimple_build_assign_with_ops (VEC_PERM_EXPR, high,\n+\t\t\t\t\t\t  vect1, vect2, perm_mask_high);\n+\t\tvect_finish_stmt_generation (stmt, perm_stmt, gsi);\n+\t\t(*result_chain)[2*j] = high;\n+\n+\t\t/* Create interleaving stmt:\n+\t\t   low = VEC_PERM_EXPR <vect1, vect2,\n+\t\t\t\t\t{nelt/2, nelt*3/2, nelt/2+1, nelt*3/2+1,\n+\t\t\t\t\t ...}>  */\n+\t\tlow = make_temp_ssa_name (vectype, NULL, \"vect_inter_low\");\n+\t\tperm_stmt\n+\t\t  = gimple_build_assign_with_ops (VEC_PERM_EXPR, low,\n+\t\t\t\t\t\t  vect1, vect2, perm_mask_low);\n+\t\tvect_finish_stmt_generation (stmt, perm_stmt, gsi);\n+\t\t(*result_chain)[2*j+1] = low;\n+\t      }\n+\t    memcpy (dr_chain.address (), result_chain->address (),\n+\t\t    length * sizeof (tree));\n+\t  }\n     }\n }\n "}, {"sha": "9c77b65f48e1617cfa25b755e1c7b7f82174e6e3", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1377713ce21a9ee25b3d6b7dbb9aaf7b7f7d4a5/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1377713ce21a9ee25b3d6b7dbb9aaf7b7f7d4a5/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=e1377713ce21a9ee25b3d6b7dbb9aaf7b7f7d4a5", "patch": "@@ -975,9 +975,9 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n      include the cost of the permutes.  */\n   if (!store_lanes_p && group_size > 1)\n     {\n-      /* Uses a high and low interleave operation for each needed permute.  */\n-      \n-      int nstmts = ncopies * exact_log2 (group_size) * group_size;\n+      /* Uses a high and low interleave or shuffle operations for each\n+\t needed permute.  */\n+      int nstmts = ncopies * ceil_log2 (group_size) * group_size;\n       inside_cost = record_stmt_cost (body_cost_vec, nstmts, vec_perm,\n \t\t\t\t      stmt_info, 0, vect_body);\n "}]}