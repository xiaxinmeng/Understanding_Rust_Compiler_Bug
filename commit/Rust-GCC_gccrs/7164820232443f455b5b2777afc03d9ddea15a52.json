{"sha": "7164820232443f455b5b2777afc03d9ddea15a52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE2NDgyMDIzMjQ0M2Y0NTViNWIyNzc3YWZjMDNkOWRkZWExNWE1Mg==", "commit": {"author": {"name": "David S. Miller", "email": "davem@pierdol.cobaltmicro.com", "date": "1998-08-23T19:48:11Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1998-08-23T19:48:11Z"}, "message": "sparc.c (sparc_emit_set_const32): If outputting a CONST_INT...\n\n\t* config/sparc/sparc.c (sparc_emit_set_const32): If outputting a\n\tCONST_INT, not a symbolic reference, don't use a HIGH/LO_SUM\n\tsequence, use SET/IOR instead so CSE can see it.\n\t* config/sparc/sparc.md (movhi_const64_special,\n\tmovsi_const64_special): New patterns necessitated by that change.\n\t(movhi_high): Remove.\n\t(movhi_lo_sum): Change to match an IOR.\n\t(movdf_insn_sp32): Test TARGET_V9 not TARGET_ARCH64.\n\t(movdf_insn_v9only): New pattern for when V9 but not ARCH64.\n\t(movdf_insn_sp64): Test both TARGET_V9 and TARGET_ARCH64.\n\t(movdf splits): Allow when not V9 or when not ARCH64 and integer\n\tregisters are involved.\n\t(snesi_zero_extend split): Remove reload_completed test.\n\t(unnamed plus and minus zero_extend sidi splits): Add it.\n\nFrom-SVN: r21919", "tree": {"sha": "7cd12ff56963b071a2fa6e0cf4f34e13cd296776", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7cd12ff56963b071a2fa6e0cf4f34e13cd296776"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7164820232443f455b5b2777afc03d9ddea15a52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7164820232443f455b5b2777afc03d9ddea15a52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7164820232443f455b5b2777afc03d9ddea15a52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7164820232443f455b5b2777afc03d9ddea15a52/comments", "author": null, "committer": null, "parents": [{"sha": "7a6d97a012348a0a610e2f3d6ecb300a17975ce8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a6d97a012348a0a610e2f3d6ecb300a17975ce8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a6d97a012348a0a610e2f3d6ecb300a17975ce8"}], "stats": {"total": 156, "additions": 125, "deletions": 31}, "files": [{"sha": "38a135e8da90d022b5d250405c67c5309f147fb0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7164820232443f455b5b2777afc03d9ddea15a52/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7164820232443f455b5b2777afc03d9ddea15a52/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7164820232443f455b5b2777afc03d9ddea15a52", "patch": "@@ -1,3 +1,20 @@\n+Sun Aug 23 18:39:11 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n+\n+\t* config/sparc/sparc.c (sparc_emit_set_const32): If outputting a\n+\tCONST_INT, not a symbolic reference, don't use a HIGH/LO_SUM\n+\tsequence, use SET/IOR instead so CSE can see it.\n+\t* config/sparc/sparc.md (movhi_const64_special,\n+\tmovsi_const64_special): New patterns necessitated by that change.\n+\t(movhi_high): Remove.\n+\t(movhi_lo_sum): Change to match an IOR.\n+\t(movdf_insn_sp32): Test TARGET_V9 not TARGET_ARCH64.\n+\t(movdf_insn_v9only): New pattern for when V9 but not ARCH64.\n+\t(movdf_insn_sp64): Test both TARGET_V9 and TARGET_ARCH64.\n+\t(movdf splits): Allow when not V9 or when not ARCH64 and integer\n+\tregisters are involved.\n+\t(snesi_zero_extend split): Remove reload_completed test.\n+\t(unnamed plus and minus zero_extend sidi splits): Add it.\n+\n Sun Aug 23 11:56:08 1998  Mark Mitchell  <mark@markmitchell.com>\n \n \t* extend.texi: Remove description of extension to explicit"}, {"sha": "1726c61a7bf254b3122007ede14a36b38727cfd5", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7164820232443f455b5b2777afc03d9ddea15a52/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7164820232443f455b5b2777afc03d9ddea15a52/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=7164820232443f455b5b2777afc03d9ddea15a52", "patch": "@@ -1111,15 +1111,46 @@ sparc_emit_set_const32 (op0, op1)\n   else\n     temp = gen_reg_rtx (mode);\n \n-  emit_insn (gen_rtx_SET (VOIDmode,\n-\t\t\t  temp,\n-\t\t\t  gen_rtx_HIGH (mode,\n-\t\t\t\t\top1)));\n-  emit_insn (gen_rtx_SET (VOIDmode,\n-\t\t\t  op0,\n-\t\t\t  gen_rtx_LO_SUM (mode,\n-\t\t\t\t\t  temp,\n-\t\t\t\t\t  op1)));\n+  if (GET_CODE (op1) == CONST_INT)\n+    {\n+      /* Emit them as real moves instead of a HIGH/LO_SUM,\n+\t this way CSE can see everything and reuse intermediate\n+\t values if it wants.  */\n+      if (TARGET_ARCH64\n+\t  && HOST_BITS_PER_WIDE_INT != 64\n+\t  && (INTVAL (op1) & 0x80000000) != 0)\n+\t{\n+\t  emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t  temp,\n+\t\t\t\t  gen_rtx_CONST_DOUBLE (VOIDmode, const0_rtx,\n+\t\t\t\t\t\t\tINTVAL (op1) & 0xfffffc00, 0)));\n+\t}\n+      else\n+\t{\n+\t  emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t  temp,\n+\t\t\t\t  GEN_INT (INTVAL (op1) & 0xfffffc00)));\n+\t}\n+      emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t      op0,\n+\t\t\t      gen_rtx_IOR (mode,\n+\t\t\t\t\t   temp,\n+\t\t\t\t\t   GEN_INT (INTVAL (op1) & 0x3ff))));\n+    }\n+  else\n+    {\n+      /* A symbol, emit in the traditional way.  */\n+      emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t      temp,\n+\t\t\t      gen_rtx_HIGH (mode,\n+\t\t\t\t\t    op1)));\n+      emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t      op0,\n+\t\t\t      gen_rtx_LO_SUM (mode,\n+\t\t\t\t\t      temp,\n+\t\t\t\t\t      op1)));\n+\n+    }\n }\n \n \f"}, {"sha": "839903557d90f89aac8e3aee41cc6e68c05baed9", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 68, "deletions": 22, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7164820232443f455b5b2777afc03d9ddea15a52/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7164820232443f455b5b2777afc03d9ddea15a52/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=7164820232443f455b5b2777afc03d9ddea15a52", "patch": "@@ -1099,8 +1099,7 @@\n         (ne:DI (match_operand:SI 1 \"register_operand\" \"\")\n                (const_int 0)))\n    (clobber (reg:CC 100))]\n-  \"TARGET_ARCH64\n-   && reload_completed\"\n+  \"TARGET_ARCH64\"\n   [(set (reg:CC_NOOV 100) (compare:CC_NOOV (minus:SI (const_int 0) (match_dup 1))\n                                            (const_int 0)))\n    (set (match_dup 0) (zero_extend:DI (plus:SI (plus:SI (const_int 0)\n@@ -2016,6 +2015,14 @@\n   ;\n }\")\n \n+(define_insn \"*movhi_const64_special\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(match_operand:HI 1 \"const64_high_operand\" \"\"))]\n+  \"TARGET_ARCH64\"\n+  \"sethi\\\\t%%hi(%a1), %0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n (define_insn \"*movhi_insn\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=r,r,r,m\")\n \t(match_operand:HI 1 \"input_operand\"   \"rI,K,m,rJ\"))]\n@@ -2029,25 +2036,16 @@\n   [(set_attr \"type\" \"move,move,load,store\")\n    (set_attr \"length\" \"1\")])\n \n-;; We always work with constants here, never symbols, so no need\n-;; for the funny PIC versions.\n+;; We always work with constants here.\n (define_insn \"*movhi_lo_sum\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(lo_sum:HI (match_operand:HI 1 \"register_operand\" \"r\")\n-                   (match_operand:HI 2 \"immediate_operand\" \"in\")))]\n+\t(ior:HI (match_operand:HI 1 \"register_operand\" \"r\")\n+                (match_operand:HI 2 \"immediate_operand\" \"in\")))]\n   \"\"\n-  \"or\\\\t%1, %%lo(%a2), %0\"\n+  \"or\\\\t%1, %2, %0\"\n   [(set_attr \"type\" \"ialu\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"*movhi_high\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(high:HI (match_operand:SI 1 \"\" \"\")))]\n-  \"\"\n-  \"sethi\\\\t%%hi(%a1), %0\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"1\")])\n-\n (define_expand \"movsi\"\n   [(set (match_operand:SI 0 \"general_operand\" \"\")\n \t(match_operand:SI 1 \"general_operand\" \"\"))]\n@@ -2130,6 +2128,16 @@\n   [(set_attr \"type\" \"binary\")\n    (set_attr \"length\" \"1\")])\n \n+;; This is needed to show CSE exactly which bits are set\n+;; in a 64-bit register by sethi instructions.\n+(define_insn \"*movsi_const64_special\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:SI 1 \"const64_high_operand\" \"\"))]\n+  \"TARGET_ARCH64\"\n+  \"sethi\\\\t%%hi(%a1), %0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"1\")])\n+\n (define_insn \"*movsi_insn\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=r,f,r,r,r,f,m,m,d\")\n \t(match_operand:SI 1 \"input_operand\"   \"rI,!f,K,J,m,!m,rJ,!f,J\"))]\n@@ -2984,12 +2992,12 @@\n   ;\n }\")\n \n-;; Be careful, fmovd does not exist when !arch64.\n+;; Be careful, fmovd does not exist when !v9.\n (define_insn \"*movdf_insn_sp32\"\n   [(set (match_operand:DF 0 \"general_operand\" \"=e,T,U,T,e,r,r,o,e,o\")\n \t(match_operand:DF 1 \"input_operand\"    \"T,e,T,U,e,r,o,r,o,e\"))]\n   \"TARGET_FPU\n-   && ! TARGET_ARCH64\n+   && ! TARGET_V9\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\"\n   \"@\n@@ -3022,10 +3030,35 @@\n   [(set_attr \"type\" \"load,store,*,*,*\")\n    (set_attr \"length\" \"1,1,2,2,2\")])\n \n+;; We have available v9 double floats but not 64-bit\n+;; integer registers.\n+(define_insn \"*movdf_insn_v9only\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=e,e,m,r,U,T,r,o\")\n+        (match_operand:DF 1 \"input_operand\"    \"e,m,e,r,T,U,o,r\"))]\n+  \"TARGET_FPU\n+   && TARGET_V9\n+   && ! TARGET_ARCH64\n+   && (register_operand (operands[0], DFmode)\n+       || register_operand (operands[1], DFmode))\"\n+  \"@\n+  fmovd\\\\t%1, %0\n+  ldd\\\\t%1, %0\n+  std\\\\t%1, %0\n+  ldd\\\\t%1, %0\n+  std\\\\t%1, %0\n+  #\n+  #\n+  #\"\n+  [(set_attr \"type\" \"fpmove,load,store,load,store,*,*,*\")\n+   (set_attr \"length\" \"1,1,1,1,1,2,2,2\")])\n+\n+;; We have available both v9 double floats and 64-bit\n+;; integer registers.\n (define_insn \"*movdf_insn_sp64\"\n   [(set (match_operand:DF 0 \"general_operand\" \"=e,e,m,r,r,m\")\n         (match_operand:DF 1 \"input_operand\"    \"e,m,e,r,m,r\"))]\n   \"TARGET_FPU\n+   && TARGET_V9\n    && TARGET_ARCH64\n    && (register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\"\n@@ -3055,10 +3088,17 @@\n \n ;; Ok, now the splits to handle all the multi insn and\n ;; mis-aligned memory address cases.\n+;; In these splits please take note that we must be\n+;; careful when V9 but not ARCH64 because the integer\n+;; register DFmode cases must be handled.\n (define_split\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n         (match_operand:DF 1 \"register_operand\" \"\"))]\n-  \"! TARGET_ARCH64 && reload_completed\"\n+  \"(! TARGET_V9\n+    || (! TARGET_ARCH64\n+        && GET_CODE (operands[0]) == REG\n+        && REGNO (operands[0]) < 32))\n+   && reload_completed\"\n   [(clobber (const_int 0))]\n   \"\n {\n@@ -3095,7 +3135,10 @@\n (define_split\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(match_operand:DF 1 \"memory_operand\" \"\"))]\n-  \"(! TARGET_ARCH64\n+  \"((! TARGET_V9\n+     || (! TARGET_ARCH64\n+         && GET_CODE (operands[0]) == REG\n+         && REGNO (operands[0]) < 32))\n     && (reload_completed\n         && (((REGNO (operands[0])) % 2) != 0\n              || ! mem_min_alignment (operands[1], 8))\n@@ -3134,7 +3177,10 @@\n (define_split\n   [(set (match_operand:DF 0 \"memory_operand\" \"\")\n \t(match_operand:DF 1 \"register_operand\" \"\"))]\n-  \"(! TARGET_ARCH64\n+  \"((! TARGET_V9\n+     || (! TARGET_ARCH64\n+         && GET_CODE (operands[1]) == REG\n+         && REGNO (operands[1]) < 32))\n     && (reload_completed\n         && (((REGNO (operands[1])) % 2) != 0\n              || ! mem_min_alignment (operands[0], 8))\n@@ -4681,7 +4727,7 @@\n         (plus:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\"))\n                  (match_operand:DI 2 \"register_operand\" \"\")))\n    (clobber (reg:CC 100))]\n-  \"! TARGET_ARCH64\"\n+  \"! TARGET_ARCH64 && reload_completed\"\n   [(parallel [(set (reg:CC_NOOV 100)\n                    (compare:CC_NOOV (plus:SI (match_dup 3) (match_dup 1))\n                                     (const_int 0)))\n@@ -4857,7 +4903,7 @@\n         (minus:DI (match_operand:DI 1 \"register_operand\" \"\")\n                   (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"\"))))\n    (clobber (reg:CC 100))]\n-  \"! TARGET_ARCH64\"\n+  \"! TARGET_ARCH64 && reload_completed\"\n   [(parallel [(set (reg:CC_NOOV 100)\n                    (compare:CC_NOOV (minus:SI (match_dup 3) (match_dup 2))\n                                     (const_int 0)))"}]}