{"sha": "ede7cd44999a94c3eeb6708db37d6939045b554e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWRlN2NkNDQ5OTlhOTRjM2VlYjY3MDhkYjM3ZDY5MzkwNDViNTU0ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-08-31T20:37:09Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-08-31T20:37:09Z"}, "message": "backport: Makefile.in (STAGESTUFF): Add *.peephole2.\n\n        Merge peephole2 from new_ia32_branch:\n        * Makefile.in (STAGESTUFF): Add *.peephole2.\n        (mostlyclean): Likewise.\n        (recog.o): Depend on resource.h.\n\n        * final.c (peephole): Conditionalize decl on HAVE_peephole.\n        (final_scan_insn): Likewise for the invocation of peephole.\n        * genconfig.c (main): Look for peephole and peephole2 patterns.\n        Emit HAVE_peephole* accordingly.\n        * genpeep.c (main): Conditionalize entire output on HAVE_peephole.\n        * flags.h (flag_peephole2): Declare.\n        * toplev.c: New pass peephole2.  New flag -fpeephole2.\n\n        * genattrtab.c (main): Count DEFINE_PEEPHOLE2.\n        * gencodes.c (main): Likewise.\n        * genextract.c (main): Likewise.\n        * genoutput.c (main): Likewise.\n        * genemit.c (max_operand_1): Look for the max scratch operand.\n        (gen_rtx_scratch): New.\n        (gen_exp): Use it, and pass on new arg subroutine_type.\n        (gen_expand): Take max scratch into account.\n        (gen_split): Emit peephole2 functions.\n        (output_peephole2_scratch): New.\n        (main): Include hard-reg-set.h and resource.h.  Handle peephole2.\n        * genrecog.c (routine_type): Add PEEPHOLE2.\n        (IS_SPLIT): New.\n        (make_insn_sequence): Match outer parallel for peep2.  Discard\n        top level scratches and dups.\n        (add_to_sequence): New args insn_type and top.  Update all callers.\n        Handle toplevel peep2 matching insns.\n        (write_subroutine): Handle peep2.\n        (write_tree_1): Likewise.\n        (write_tree): Likewise.\n        (main): Likewise.\n        (change_state): New arg afterward.  Update all callers.\n        Handle matching separate insns.\n        * recog.c (recog_next_insn): New.\n        (peephole2_optimize): New.\n        * rtl.def (DEFINE_PEEPHOLE2): New.\n        * resource.c (find_free_register): New argument last_insn.  Use it\n        to find a register available through the entire span.\n        * resource.h (find_free_register): Update prototype.\n\nFrom-SVN: r29015", "tree": {"sha": "afdcdc35501714ae0479a8139d1ee32d313b0176", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afdcdc35501714ae0479a8139d1ee32d313b0176"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ede7cd44999a94c3eeb6708db37d6939045b554e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ede7cd44999a94c3eeb6708db37d6939045b554e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ede7cd44999a94c3eeb6708db37d6939045b554e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ede7cd44999a94c3eeb6708db37d6939045b554e/comments", "author": null, "committer": null, "parents": [{"sha": "4dfeccf9d064821bede6f09da2949499f19c68c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dfeccf9d064821bede6f09da2949499f19c68c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dfeccf9d064821bede6f09da2949499f19c68c4"}], "stats": {"total": 647, "additions": 562, "deletions": 85}, "files": [{"sha": "c5fa34ce5cecad706c183d8e319823c68998f09d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ede7cd44999a94c3eeb6708db37d6939045b554e", "patch": "@@ -1,3 +1,48 @@\n+Tue Aug 31 13:35:42 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\tMerge peephole2 from new_ia32_branch:\n+\t* Makefile.in (STAGESTUFF): Add *.peephole2.\n+\t(mostlyclean): Likewise.\n+\t(recog.o): Depend on resource.h.\n+\n+\t* final.c (peephole): Conditionalize decl on HAVE_peephole.\n+\t(final_scan_insn): Likewise for the invocation of peephole.\n+\t* genconfig.c (main): Look for peephole and peephole2 patterns.\n+\tEmit HAVE_peephole* accordingly.\n+\t* genpeep.c (main): Conditionalize entire output on HAVE_peephole.\n+\t* flags.h (flag_peephole2): Declare.\n+\t* toplev.c: New pass peephole2.  New flag -fpeephole2.\n+ \n+\t* genattrtab.c (main): Count DEFINE_PEEPHOLE2.\n+\t* gencodes.c (main): Likewise.\n+\t* genextract.c (main): Likewise.\n+\t* genoutput.c (main): Likewise.\n+\t* genemit.c (max_operand_1): Look for the max scratch operand.\n+\t(gen_rtx_scratch): New.\n+\t(gen_exp): Use it, and pass on new arg subroutine_type.\n+\t(gen_expand): Take max scratch into account.\n+\t(gen_split): Emit peephole2 functions.\n+\t(output_peephole2_scratch): New.\n+\t(main): Include hard-reg-set.h and resource.h.  Handle peephole2.\n+\t* genrecog.c (routine_type): Add PEEPHOLE2.\n+\t(IS_SPLIT): New.\n+\t(make_insn_sequence): Match outer parallel for peep2.  Discard\n+\ttop level scratches and dups.\n+\t(add_to_sequence): New args insn_type and top.  Update all callers.\n+\tHandle toplevel peep2 matching insns.\n+\t(write_subroutine): Handle peep2.\n+\t(write_tree_1): Likewise.\n+\t(write_tree): Likewise.\n+\t(main): Likewise.\n+\t(change_state): New arg afterward.  Update all callers.\n+\tHandle matching separate insns.\n+\t* recog.c (recog_next_insn): New.\n+\t(peephole2_optimize): New.\n+\t* rtl.def (DEFINE_PEEPHOLE2): New.\n+\t* resource.c (find_free_register): New argument last_insn.  Use it\n+\tto find a register available through the entire span.\n+\t* resource.h (find_free_register): Update prototype.\n+\n Tue Aug 31 11:51:06 1999  Jim Kingdon  <http://developer.redhat.com>\n \n \t* i386.c (output_strlen_unroll): Don't write xops[7]"}, {"sha": "445a46b230fa28232e0f20862d6c3694aa80e7b5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ede7cd44999a94c3eeb6708db37d6939045b554e", "patch": "@@ -697,7 +697,7 @@ STAGESTUFF = *$(objext) insn-flags.h insn-config.h insn-codes.h \\\n  specs collect2$(exeext) $(USE_COLLECT2) underscore.c \\\n  gcov$(exeext) *.bp \\\n  *.greg *.lreg *.combine *.flow *.cse *.jump *.rtl *.tree *.loop \\\n- *.dbr *.jump2 *.sched *.cse2 *.sched2 *.stack *.gcse *.flow2 \\\n+ *.dbr *.jump2 *.sched *.cse2 *.sched2 *.stack *.gcse *.flow2 *.peephole2 \\\n  *.[si] libcpp.a \\\n  $(LANG_STAGESTUFF)\n \n@@ -1577,10 +1577,10 @@ final.o : final.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h intl.h \\\n    dbxout.h\n recog.o : recog.c $(CONFIG_H) system.h $(RTL_H) function.h \\\n    $(REGS_H) $(RECOG_H) hard-reg-set.h flags.h insn-config.h insn-attr.h \\\n-   insn-flags.h insn-codes.h real.h toplev.h\n+   insn-flags.h insn-codes.h real.h toplev.h output.h resource.h\n reg-stack.o : reg-stack.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) recog.h \\\n    $(REGS_H) hard-reg-set.h flags.h insn-config.h insn-flags.h toplev.h \\\n-   function.h\n+   varray.h function.h\n dyn-string.o: dyn-string.c dyn-string.h $(CONFIG_H) system.h\n lists.o: lists.c $(CONFIG_H) system.h toplev.h $(RTL_H)\n \n@@ -2311,10 +2311,11 @@ mostlyclean: intl.mostlyclean lang.mostlyclean\n # Delete debugging dump files.\n \t-rm -f *.greg *.lreg *.combine *.flow *.cse *.jump *.rtl *.tree *.loop\n \t-rm -f *.dbr *.jump2 *.sched *.cse2 *.sched2 *.stack *.addressof\n-\t-rm -f *.regmove *.mach *.bp *.gcse *.flow2\n+\t-rm -f *.regmove *.mach *.bp *.gcse *.flow2 *.peephole2\n \t-rm -f */*.greg */*.lreg */*.combine */*.flow */*.cse */*.jump */*.rtl\n \t-rm -f */*.tree */*.loop */*.dbr */*.jump2 */*.sched */*.cse2\n \t-rm -f */*.sched2 */*.stack */*.regmove */*.gcse */*.flow2\n+\t-rm -f */*.peephole2\n # Delete some files made during installation.\n \t-rm -f specs float.h-* enquire SYSCALLS.c.X SYSCALLS.c\n \t-rm -f collect collect2 mips-tfile mips-tdump alloca.s"}, {"sha": "4134ae3e407c1a8147c936c1b32f7bb8744b26aa", "filename": "gcc/final.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=ede7cd44999a94c3eeb6708db37d6939045b554e", "patch": "@@ -284,7 +284,9 @@ struct bb_str {\n   int length;\t\t\t/* string length */\n };\n \n+#ifdef HAVE_peephole\n extern rtx peephole\t\tPROTO((rtx));\n+#endif\n \n static struct bb_str *sbb_head\t= 0;\t\t/* Head of string list.  */\n static struct bb_str **sbb_tail\t= &sbb_head;\t/* Ptr to store next bb str */\n@@ -2825,6 +2827,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \n #endif\n \n+#ifdef HAVE_peephole\n \t/* Do machine-specific peephole optimizations if desired.  */\n \n \tif (optimize && !flag_no_peephole && !nopeepholes)\n@@ -2855,6 +2858,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t    /* PEEPHOLE might have changed this.  */\n \t    body = PATTERN (insn);\n \t  }\n+#endif\n \n \t/* Try to recognize the instruction.\n \t   If successful, verify that the operands satisfy the"}, {"sha": "cbdf9cde151e62ee19b7e897caf62e12492e8918", "filename": "gcc/flags.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=ede7cd44999a94c3eeb6708db37d6939045b554e", "patch": "@@ -473,6 +473,9 @@ extern int flag_regmove;\n \n /* Instrument functions with calls at entry and exit, for profiling.  */\n extern int flag_instrument_function_entry_exit;\n+\n+/* Perform a peephole pass before sched2. */\n+extern int flag_peephole2;\n \f\n /* Other basic status info about current function.  */\n "}, {"sha": "a958025cb2bb5a165206248d314b3bef850ef99b", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=ede7cd44999a94c3eeb6708db37d6939045b554e", "patch": "@@ -6018,6 +6018,9 @@ from the machine description file `md'.  */\\n\\n\");\n       else if (GET_CODE (desc) == DEFINE_SPLIT)\n \tinsn_code_number++, insn_index_number++;\n \n+      else if (GET_CODE (desc) == DEFINE_PEEPHOLE2)\n+\tinsn_code_number++, insn_index_number++;\n+\n       else if (GET_CODE (desc) == DEFINE_ATTR)\n \t{\n \t  gen_attr (desc);"}, {"sha": "084cfa80d50f744aade426a2906f758602729103", "filename": "gcc/gencodes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Fgencodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Fgencodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgencodes.c?ref=ede7cd44999a94c3eeb6708db37d6939045b554e", "patch": "@@ -125,6 +125,7 @@ from the machine description file `md'.  */\\n\\n\");\n \t  insn_code_number++;\n \t}\n       if (GET_CODE (desc) == DEFINE_PEEPHOLE\n+\t  || GET_CODE (desc) == DEFINE_PEEPHOLE2\n \t  || GET_CODE (desc) == DEFINE_SPLIT)\n \t{\n \t  insn_code_number++;"}, {"sha": "4001774eba3b7d5d8a0bcbf088896e4f991d7815", "filename": "gcc/genconfig.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Fgenconfig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Fgenconfig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconfig.c?ref=ede7cd44999a94c3eeb6708db37d6939045b554e", "patch": "@@ -43,6 +43,8 @@ static int register_constraint_flag;\n static int have_cc0_flag;\n static int have_cmove_flag;\n static int have_lo_sum_flag;\n+static int have_peephole_flag;\n+static int have_peephole2_flag;\n \n /* Maximum number of insns seen in a split.  */\n static int max_insns_per_split = 1;\n@@ -313,8 +315,16 @@ from the machine description file `md'.  */\\n\\n\");\n \tgen_expand (desc);\n       if (GET_CODE (desc) == DEFINE_SPLIT)\n \tgen_split (desc);\n+      if (GET_CODE (desc) == DEFINE_PEEPHOLE2)\n+\t{\n+\t  have_peephole2_flag = 1;\n+\t  gen_split (desc);\n+\t}\n       if (GET_CODE (desc) == DEFINE_PEEPHOLE)\n-\tgen_peephole (desc);\n+\t{\n+\t  have_peephole_flag = 1;\n+\t  gen_peephole (desc);\n+\t}\n     }\n \n   printf (\"\\n#define MAX_RECOG_OPERANDS %d\\n\", max_recog_operands + 1);\n@@ -338,6 +348,12 @@ from the machine description file `md'.  */\\n\\n\");\n   if (have_lo_sum_flag)\n     printf (\"#define HAVE_lo_sum\\n\");\n \n+  if (have_peephole_flag)\n+    printf (\"#define HAVE_peephole\\n\");\n+\n+  if (have_peephole2_flag)\n+    printf (\"#define HAVE_peephole2\\n\");\n+\n   fflush (stdout);\n   exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n   /* NOTREACHED */"}, {"sha": "68188e6c2ea96b94701043de8a64a9520e61ed4a", "filename": "gcc/genemit.c", "status": "modified", "additions": 129, "deletions": 23, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=ede7cd44999a94c3eeb6708db37d6939045b554e", "patch": "@@ -36,6 +36,7 @@ char **insn_name_ptr = 0;\n \n static int max_opno;\n static int max_dup_opno;\n+static int max_scratch_opno;\n static int register_constraints;\n static int insn_code_number;\n static int insn_index_number;\n@@ -63,12 +64,13 @@ struct clobber_ent\n static void max_operand_1\t\tPROTO((rtx));\n static int max_operand_vec\t\tPROTO((rtx, int));\n static void print_code\t\t\tPROTO((RTX_CODE));\n-static void gen_exp\t\t\tPROTO((rtx));\n+static void gen_exp\t\t\tPROTO((rtx, enum rtx_code));\n static void gen_insn\t\t\tPROTO((rtx));\n static void gen_expand\t\t\tPROTO((rtx));\n static void gen_split\t\t\tPROTO((rtx));\n static void output_add_clobbers\t\tPROTO((void));\n-static void output_init_mov_optab\tPROTO((void));\n+static void gen_rtx_scratch\t\tPROTO((rtx, enum rtx_code));\n+static void output_peephole2_scratches\tPROTO((rtx));\n \n \f\n static void\n@@ -94,6 +96,8 @@ max_operand_1 (x)\n     max_opno = MAX (max_opno, XINT (x, 0));\n   if (code == MATCH_DUP || code == MATCH_OP_DUP || code == MATCH_PAR_DUP)\n     max_dup_opno = MAX (max_dup_opno, XINT (x, 0));\n+  if (code == MATCH_SCRATCH)\n+    max_scratch_opno = MAX (max_scratch_opno, XINT (x, 0));\n \n   fmt = GET_RTX_FORMAT (code);\n   len = GET_RTX_LENGTH (code);\n@@ -120,6 +124,7 @@ max_operand_vec (insn, arg)\n \n   max_opno = -1;\n   max_dup_opno = -1;\n+  max_scratch_opno = -1;\n \n   for (i = 0; i < len; i++)\n     max_operand_1 (XVECEXP (insn, arg, i));\n@@ -141,12 +146,28 @@ print_code (code)\n     }\n }\n \n+static void\n+gen_rtx_scratch (x, subroutine_type)\n+     rtx x;\n+     enum rtx_code subroutine_type;\n+{\n+  if (subroutine_type == DEFINE_PEEPHOLE2)\n+    {\n+      printf (\"operand%d\", XINT (x, 0));\n+    }\n+  else\n+    {\n+      printf (\"gen_rtx_SCRATCH (%smode)\", GET_MODE_NAME (GET_MODE (x)));\n+    }\n+}\n+\n /* Print a C expression to construct an RTX just like X,\n    substituting any operand references appearing within.  */\n \n static void\n-gen_exp (x)\n+gen_exp (x, subroutine_type)\n      rtx x;\n+     enum rtx_code subroutine_type;\n {\n   register RTX_CODE code;\n   register int i;\n@@ -177,7 +198,7 @@ gen_exp (x)\n       for (i = 0; i < XVECLEN (x, 1); i++)\n \t{\n \t  printf (\",\\n\\t\\t\");\n-\t  gen_exp (XVECEXP (x, 1, i));\n+\t  gen_exp (XVECEXP (x, 1, i), subroutine_type);\n \t}\n       printf (\")\");\n       return;\n@@ -188,7 +209,7 @@ gen_exp (x)\n       for (i = 0; i < XVECLEN (x, 2); i++)\n \t{\n \t  printf (\",\\n\\t\\t\");\n-\t  gen_exp (XVECEXP (x, 2, i));\n+\t  gen_exp (XVECEXP (x, 2, i), subroutine_type);\n \t}\n       printf (\")\");\n       return;\n@@ -199,7 +220,7 @@ gen_exp (x)\n       return;\n \n     case MATCH_SCRATCH:\n-      printf (\"gen_rtx_SCRATCH (%smode)\", GET_MODE_NAME (GET_MODE (x)));\n+      gen_rtx_scratch (x, subroutine_type);\n       return;\n \n     case ADDRESS:\n@@ -251,7 +272,7 @@ gen_exp (x)\n \tbreak;\n       printf (\",\\n\\t\");\n       if (fmt[i] == 'e' || fmt[i] == 'u')\n-\tgen_exp (XEXP (x, i));\n+\tgen_exp (XEXP (x, i), subroutine_type);\n       else if (fmt[i] == 'i')\n \tprintf (\"%u\", XINT (x, i));\n       else if (fmt[i] == 's')\n@@ -263,7 +284,7 @@ gen_exp (x)\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    {\n \t      printf (\",\\n\\t\\t\");\n-\t      gen_exp (XVECEXP (x, i, j));\n+\t      gen_exp (XVECEXP (x, i, j), subroutine_type);\n \t    }\n \t  printf (\")\");\n \t}\n@@ -375,7 +396,7 @@ gen_insn (insn)\n   if (XVECLEN (insn, 1) == 1)\n     {\n       printf (\"  return \");\n-      gen_exp (XVECEXP (insn, 1, 0));\n+      gen_exp (XVECEXP (insn, 1, 0), DEFINE_INSN);\n       printf (\";\\n}\\n\\n\");\n     }\n   else\n@@ -384,7 +405,7 @@ gen_insn (insn)\n       for (i = 0; i < XVECLEN (insn, 1); i++)\n \t{\n \t  printf (\",\\n\\t\\t\");\n-\t  gen_exp (XVECEXP (insn, 1, i));\n+\t  gen_exp (XVECEXP (insn, 1, i), DEFINE_INSN);\n \t}\n       printf (\"));\\n}\\n\\n\");\n     }\n@@ -427,7 +448,7 @@ gen_expand (expand)\n       && XVECLEN (expand, 1) == 1)\n     {\n       printf (\"  return \");\n-      gen_exp (XVECEXP (expand, 1, 0));\n+      gen_exp (XVECEXP (expand, 1, 0), DEFINE_EXPAND);\n       printf (\";\\n}\\n\\n\");\n       return;\n     }\n@@ -436,8 +457,11 @@ gen_expand (expand)\n      make a local variable.  */\n   for (i = operands; i <= max_dup_opno; i++)\n     printf (\"  rtx operand%d;\\n\", i);\n-  if (operands > 0 || max_dup_opno >= 0)\n-    printf (\"  rtx operands[%d];\\n\", MAX (operands, max_dup_opno + 1));\n+  for (; i <= max_scratch_opno; i++)\n+    printf (\"  rtx operand%d;\\n\", i);\n+  if (operands > 0 || max_dup_opno >= 0 || max_scratch_opno >= 0)\n+    printf (\"  rtx operands[%d];\\n\",\n+\t    MAX (operands, MAX (max_scratch_opno, max_dup_opno) + 1));\n   printf (\"  rtx _val = 0;\\n\");\n   printf (\"  start_sequence ();\\n\");\n \n@@ -465,6 +489,8 @@ gen_expand (expand)\n \t    printf (\"  operand%d = operands[%d];\\n\", i, i);\n \t  for (; i <= max_dup_opno; i++)\n \t    printf (\"  operand%d = operands[%d];\\n\", i, i);\n+\t  for (; i <= max_scratch_opno; i++)\n+\t    printf (\"  operand%d = operands[%d];\\n\", i, i);\n \t}\n     }\n \n@@ -501,7 +527,7 @@ gen_expand (expand)\n \tprintf (\"  emit (\");\n       else\n \tprintf (\"  emit_insn (\");\n-      gen_exp (next);\n+      gen_exp (next, DEFINE_EXPAND);\n       printf (\");\\n\");\n       if (GET_CODE (next) == SET && GET_CODE (SET_DEST (next)) == PC\n \t  && GET_CODE (SET_SRC (next)) == LABEL_REF)\n@@ -524,28 +550,49 @@ gen_split (split)\n {\n   register int i;\n   int operands;\n+  char *name = \"split\";\n+\n+  if (GET_CODE (split) == DEFINE_PEEPHOLE2)\n+    name = \"peephole2\";\n \n   if (XVEC (split, 0) == 0)\n-    fatal (\"define_split (definition %d) lacks a pattern\", insn_index_number);\n+    fatal (\"define_%s (definition %d) lacks a pattern\", name,\n+\t   insn_index_number);\n   else if (XVEC (split, 2) == 0)\n-    fatal (\"define_split (definition %d) lacks a replacement pattern\",\n+    fatal (\"define_%s (definition %d) lacks a replacement pattern\", name,\n \t   insn_index_number);\n \n   /* Find out how many operands this function has.  */\n \n   max_operand_vec (split, 2);\n-  operands = MAX (max_opno, max_dup_opno) + 1;\n+  operands = MAX (max_opno, MAX (max_dup_opno, max_scratch_opno)) + 1;\n \n-  /* Output the prototype, the function name and argument declarations.  */\n-  printf (\"extern rtx gen_split_%d PROTO ((rtx *));\\n\", insn_code_number);\n-  printf (\"rtx\\ngen_split_%d (operands)\\n     rtx *operands;\\n\",\n-\t  insn_code_number);\n+  /* Output the prototype, function name and argument declarations.  */\n+  if (GET_CODE (split) == DEFINE_PEEPHOLE2)\n+    {\n+      printf (\"extern rtx gen_%s_%d PROTO ((rtx, rtx *));\\n\",\n+\t      name, insn_code_number);\n+      printf (\"rtx\\ngen_%s_%d (curr_insn, operands)\\n\\\n+     rtx curr_insn ATTRIBUTE_UNUSED;\\n\\\n+     rtx *operands;\\n\", \n+\t      name, insn_code_number);\n+    }\n+  else\n+    {\n+      printf (\"extern rtx gen_split_%d PROTO ((rtx *));\\n\", insn_code_number);\n+      printf (\"rtx\\ngen_%s_%d (operands)\\n     rtx *operands;\\n\", name,\n+\t      insn_code_number);\n+    }\n   printf (\"{\\n\");\n \n   /* Declare all local variables.  */\n   for (i = 0; i < operands; i++)\n     printf (\"  rtx operand%d;\\n\", i);\n   printf (\"  rtx _val = 0;\\n\");\n+\n+  if (GET_CODE (split) == DEFINE_PEEPHOLE2)\n+    output_peephole2_scratches (split);\n+\n   printf (\"  start_sequence ();\\n\");\n \n   /* The fourth operand of DEFINE_SPLIT is some code to be executed\n@@ -590,7 +637,7 @@ gen_split (split)\n \tprintf (\"  emit (\");\n       else\n \tprintf (\"  emit_insn (\");\n-      gen_exp (next);\n+      gen_exp (next, GET_CODE (split));\n       printf (\");\\n\");\n       if (GET_CODE (next) == SET && GET_CODE (SET_DEST (next)) == PC\n \t  && GET_CODE (SET_SRC (next)) == LABEL_REF)\n@@ -630,7 +677,8 @@ output_add_clobbers ()\n       for (i = clobber->first_clobber; i < XVECLEN (clobber->pattern, 1); i++)\n \t{\n \t  printf (\"      XVECEXP (pattern, 0, %d) = \", i);\n-\t  gen_exp (XVECEXP (clobber->pattern, 1, i));\n+\t  gen_exp (XVECEXP (clobber->pattern, 1, i),\n+\t\t   GET_CODE (clobber->pattern));\n \t  printf (\";\\n\");\n \t}\n \n@@ -643,6 +691,56 @@ output_add_clobbers ()\n   printf (\"}\\n\");\n }\n \f\n+/* Generate code to invoke find_free_register () as needed for the\n+   scratch registers used by the peephole2 pattern in SPLIT. */\n+\n+static void\n+output_peephole2_scratches (split)\n+     rtx split;\n+{\n+  int i;\n+  int insn_nr = 0;\n+\n+  printf (\"  rtx first_insn ATTRIBUTE_UNUSED;\\n\");\n+  printf (\"  rtx last_insn ATTRIBUTE_UNUSED;\\n\");\n+  printf (\"  HARD_REG_SET _regs_allocated;\\n\");\n+\n+  printf (\"  CLEAR_HARD_REG_SET (_regs_allocated);\\n\");\n+\n+  for (i = 0; i < XVECLEN (split, 0); i++)\n+    {\n+      rtx elt = XVECEXP (split, 0, i);\n+      if (GET_CODE (elt) == MATCH_SCRATCH)\n+\t{\n+\t  int last_insn_nr = insn_nr;\n+\t  int cur_insn_nr = insn_nr;\n+\t  int j;\n+\t  for (j = i + 1; j < XVECLEN (split, 0); j++)\n+\t    if (GET_CODE (XVECEXP (split, 0, j)) == MATCH_DUP)\n+\t      {\n+\t\tif (XINT (XVECEXP (split, 0, j), 0) == XINT (elt, 0))\n+\t\t  last_insn_nr = cur_insn_nr;\n+\t      }\n+\t    else if (GET_CODE (XVECEXP (split, 0, j)) != MATCH_SCRATCH)\n+\t      cur_insn_nr++;\n+\t  printf (\"  first_insn = recog_next_insn (curr_insn, %d);\\n\", insn_nr);\n+\t  if (last_insn_nr > insn_nr)\n+\t    printf (\"  last_insn = recog_next_insn (curr_insn, %d);\\n\",\n+\t\t    last_insn_nr - 1);\n+\t  else\n+\t    printf (\"  last_insn = 0;\\n\");\n+\t  printf (\"  if ((operands[%d] = find_free_register (first_insn, last_insn, \\\"%s\\\", %smode, &_regs_allocated)) == NULL_RTX)\\n\\\n+    return NULL;\\n\", \n+\t\t  XINT (elt, 0),\n+\t\t  XSTR (elt, 1),\n+\t\t  GET_MODE_NAME (GET_MODE (elt)));\n+\n+\t}\n+      else if (GET_CODE (elt) != MATCH_DUP)\n+\tinsn_nr++;\n+    }\n+}\n+\f\n PTR\n xmalloc (size)\n   size_t size;\n@@ -713,6 +811,8 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"#include \\\"insn-flags.h\\\"\\n\");\n   printf (\"#include \\\"insn-codes.h\\\"\\n\");\n   printf (\"#include \\\"recog.h\\\"\\n\");\n+  printf (\"#include \\\"hard-reg-set.h\\\"\\n\");\n+  printf (\"#include \\\"resource.h\\\"\\n\");\n   printf (\"#include \\\"reload.h\\\"\\n\\n\");\n   printf (\"extern rtx recog_operand[];\\n\");\n   printf (\"#define operands emit_operand\\n\\n\");\n@@ -729,6 +829,7 @@ from the machine description file `md'.  */\\n\\n\");\n       ungetc (c, infile);\n \n       desc = read_rtx (infile);\n+\n       if (GET_CODE (desc) == DEFINE_INSN)\n \t{\n \t  gen_insn (desc);\n@@ -744,6 +845,11 @@ from the machine description file `md'.  */\\n\\n\");\n \t  gen_split (desc);\n \t  ++insn_code_number;\n \t}\n+      if (GET_CODE (desc) == DEFINE_PEEPHOLE2)\n+\t{\n+\t  gen_split (desc);\n+\t  ++insn_code_number;\n+\t}\n       if (GET_CODE (desc) == DEFINE_PEEPHOLE)\n \t{\n \t  ++insn_code_number;"}, {"sha": "7caec63ae841dd5a36c51aef3f652b27820fc4a7", "filename": "gcc/genextract.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=ede7cd44999a94c3eeb6708db37d6939045b554e", "patch": "@@ -463,6 +463,7 @@ from the machine description file `md'.  */\\n\\n\");\n \t}\n \n       else if (GET_CODE (desc) == DEFINE_EXPAND\n+\t       || GET_CODE (desc) == DEFINE_PEEPHOLE2\n \t       || GET_CODE (desc) == DEFINE_SPLIT)\n \t++insn_code_number;\n     }"}, {"sha": "abe0b77367f429498a26937c9b330a8e15bad881", "filename": "gcc/genoutput.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=ede7cd44999a94c3eeb6708db37d6939045b554e", "patch": "@@ -968,7 +968,8 @@ main (argc, argv)\n \tgen_peephole (desc);\n       if (GET_CODE (desc) == DEFINE_EXPAND)\n \tgen_expand (desc);\n-      if (GET_CODE (desc) == DEFINE_SPLIT)\n+      if (GET_CODE (desc) == DEFINE_SPLIT\n+ \t  || GET_CODE (desc) == DEFINE_PEEPHOLE2)\n \tgen_split (desc);\n       next_index_number++;\n     }"}, {"sha": "0e6b0dbb1f88680a0b5d589904d04af6b67a8459", "filename": "gcc/genpeep.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Fgenpeep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Fgenpeep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpeep.c?ref=ede7cd44999a94c3eeb6708db37d6939045b554e", "patch": "@@ -445,6 +445,7 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"#include \\\"except.h\\\"\\n\\n\");\n   printf (\"#include \\\"function.h\\\"\\n\\n\");\n \n+  printf (\"#ifdef HAVE_peephole\\n\");\n   printf (\"extern rtx peep_operand[];\\n\\n\");\n   printf (\"#define operands peep_operand\\n\\n\");\n \n@@ -485,6 +486,7 @@ from the machine description file `md'.  */\\n\\n\");\n     max_opno = 1;\n \n   printf (\"rtx peep_operand[%d];\\n\", max_opno + 1);\n+  printf (\"#endif\\n\");\n \n   fflush (stdout);\n   exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);"}, {"sha": "a2eef4617d81b88951a296f2167686c70a9dc6af", "filename": "gcc/genrecog.c", "status": "modified", "additions": 221, "deletions": 47, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=ede7cd44999a94c3eeb6708db37d6939045b554e", "patch": "@@ -111,10 +111,13 @@ struct decision\n \n static int next_subroutine_number;\n \n-/* We can write two types of subroutines: One for insn recognition and\n-   one to split insns.  This defines which type is being written.  */\n+/* We can write three types of subroutines: One for insn recognition,\n+   one to split insns, and one for peephole-type optimizations.  This\n+   defines which type is being written.  */\n \n-enum routine_type {RECOG, SPLIT};\n+enum routine_type {RECOG, SPLIT, PEEPHOLE2};\n+\n+#define IS_SPLIT(X) ((X) == SPLIT || (X)==PEEPHOLE2)\n \n /* Next available node number for tree nodes.  */\n \n@@ -173,7 +176,8 @@ static struct pred_table\n \n static struct decision_head make_insn_sequence PROTO((rtx, enum routine_type));\n static struct decision *add_to_sequence PROTO((rtx, struct decision_head *,\n-\t\t\t\t\t       const char *));\n+\t\t\t\t\t       const char *, \n+\t\t\t\t\t       enum routine_type, int));\n static int not_both_true\tPROTO((struct decision *, struct decision *,\n \t\t\t\t       int));\n static int position_merit\tPROTO((struct decision *, enum machine_mode,\n@@ -193,8 +197,9 @@ static void clear_modes\t\tPROTO((struct decision *));\n static void write_tree\t\tPROTO((struct decision *, const char *,\n \t\t\t\t       struct decision *, int,\n \t\t\t\t       enum routine_type));\n-static void change_state\tPROTO((const char *, const char *, int));\n-\n+static void change_state\tPROTO((const char *, const char *, int,\n+\t\t\t\t       struct decision *));\n+\f\n /* Construct and return a sequence of decisions\n    that will recognize INSN.\n \n@@ -219,9 +224,8 @@ make_insn_sequence (insn, type)\n       {\n \tint new_size;\n \tnew_size = (insn_name_ptr_size ? insn_name_ptr_size * 2 : 512);\n-\tinsn_name_ptr =\n-\t  (char **) xrealloc (insn_name_ptr, sizeof(char *) * new_size);\n-\tbzero ((PTR)(insn_name_ptr + insn_name_ptr_size),\n+\tinsn_name_ptr = xrealloc (insn_name_ptr, sizeof(char *) * new_size);\n+\tbzero (insn_name_ptr + insn_name_ptr_size,\n \t       sizeof(char *) * (new_size - insn_name_ptr_size));\n \tinsn_name_ptr_size = new_size;\n       }\n@@ -243,7 +247,29 @@ make_insn_sequence (insn, type)\n     insn_name_ptr[next_insn_code] = name;\n   }  \n \n-  if (XVECLEN (insn, type == RECOG) == 1)\n+  if (type == PEEPHOLE2)\n+    {\n+      int i, j;\n+\n+      /* peephole2 gets special treatment:\n+\t - X always gets an outer parallel even if it's only one entry\n+\t - we remove all traces of outer-level match_scratch and match_dup\n+           expressions here.  */\n+      x = rtx_alloc (PARALLEL);\n+      PUT_MODE (x, VOIDmode);\n+      XVEC (x, 0) = rtvec_alloc (XVECLEN (insn, 0));\n+      for (i = j = 0; i < XVECLEN (insn, 0); i++)\n+\t{\n+\t  rtx tmp = XVECEXP (insn, 0, i);\n+\t  if (GET_CODE (tmp) != MATCH_SCRATCH && GET_CODE (tmp) != MATCH_DUP)\n+\t    {\n+\t      XVECEXP (x, 0, j) = tmp;\n+\t      j++;\n+\t    }\n+\t}\n+      XVECLEN (x, 0) = j;\n+    }\n+  else if (XVECLEN (insn, type == RECOG) == 1)\n     x = XVECEXP (insn, type == RECOG, 0);\n   else\n     {\n@@ -252,7 +278,7 @@ make_insn_sequence (insn, type)\n       PUT_MODE (x, VOIDmode);\n     }\n \n-  last = add_to_sequence (x, &head, \"\");\n+  last = add_to_sequence (x, &head, \"\", type, 1);\n \n   if (c_test[0])\n     last->c_test = c_test;\n@@ -290,7 +316,7 @@ make_insn_sequence (insn, type)\n \t\tXVECEXP (new, 0, j) = XVECEXP (x, 0, j);\n \t    }\n \n-\t  last = add_to_sequence (new, &clobber_head, \"\");\n+\t  last = add_to_sequence (new, &clobber_head, \"\", type, 1);\n \n \t  if (c_test[0])\n \t    last->c_test = c_test;\n@@ -305,7 +331,13 @@ make_insn_sequence (insn, type)\n \n   if (type == SPLIT)\n     /* Define the subroutine we will call below and emit in genemit.  */\n-    printf (\"extern rtx gen_split_%d PROTO ((rtx *));\\n\", last->insn_code_number);\n+    printf (\"extern rtx gen_split_%d PROTO ((rtx *));\\n\",\n+\t    last->insn_code_number);\n+\n+  else if (type == PEEPHOLE2)\n+    /* Define the subroutine we will call below and emit in genemit.  */\n+    printf (\"extern rtx gen_peephole2_%d PROTO ((rtx, rtx *));\\n\",\n+\t    last->insn_code_number);\n \n   return head;\n }\n@@ -318,13 +350,17 @@ make_insn_sequence (insn, type)\n \n    POSITION is the string representing the current position in the insn.\n \n+   INSN_TYPE is the type of insn for which we are emitting code.\n+\n    A pointer to the final node in the chain is returned.  */\n \n static struct decision *\n-add_to_sequence (pattern, last, position)\n+add_to_sequence (pattern, last, position, insn_type, top)\n      rtx pattern;\n      struct decision_head *last;\n      const char *position;\n+     enum routine_type insn_type;\n+     int top;\n {\n   register RTX_CODE code;\n   register struct decision *new\n@@ -381,6 +417,27 @@ add_to_sequence (pattern, last, position)\n \n   switch (code)\n     {\n+    case PARALLEL:\n+      /* Toplevel peephole pattern. */\n+      if (insn_type == PEEPHOLE2 && top)\n+\t{\n+\t  struct decision_head *place = last;\n+\n+\t  for (i = 0; i < (size_t) XVECLEN (pattern, 0); i++)\n+\t    {\n+\t      /* Which insn we're looking at is represented by A-Z. We don't\n+\t         ever use 'A', however; it is always implied. */\n+\t      if (i > 0)\n+\t\tnewpos[depth] = 'A' + i;\n+\t      else\n+\t\tnewpos[depth] = 0;\n+\t      new = add_to_sequence (XVECEXP (pattern, 0, i),\n+\t\t\t\t     place, newpos, insn_type, 0);\n+\t      place = &new->success;\n+\t    }\n+\t  return new;\n+\t}\n+      break;\n     case MATCH_OPERAND:\n     case MATCH_SCRATCH:\n     case MATCH_OPERATOR:\n@@ -452,7 +509,7 @@ add_to_sequence (pattern, last, position)\n \t    {\n \t      newpos[depth] = i + (code == MATCH_OPERATOR ? '0': 'a');\n \t      new = add_to_sequence (XVECEXP (pattern, 2, i),\n-\t\t\t\t     &new->success, newpos);\n+\t\t\t\t     &new->success, newpos, insn_type, 0);\n \t    }\n \t}\n \n@@ -467,7 +524,7 @@ add_to_sequence (pattern, last, position)\n \t{\n \t  newpos[depth] = i + '0';\n \t  new = add_to_sequence (XVECEXP (pattern, 1, i),\n-\t\t\t\t &new->success, newpos);\n+\t\t\t\t &new->success, newpos, insn_type, 0);\n \t}\n       return new;\n \n@@ -497,10 +554,12 @@ add_to_sequence (pattern, last, position)\n \t  fatal (\"mode mismatch in SET\");\n \t}\n       newpos[depth] = '0';\n-      new = add_to_sequence (SET_DEST (pattern), &new->success, newpos);\n+      new = add_to_sequence (SET_DEST (pattern), &new->success, newpos, \n+\t\t\t     insn_type, 0);\n       this->success.first->enforce_mode = 1;\n       newpos[depth] = '1';\n-      new = add_to_sequence (SET_SRC (pattern), &new->success, newpos);\n+      new = add_to_sequence (SET_SRC (pattern), &new->success, newpos,\n+\t\t\t     insn_type, 0);\n \n       /* If set are setting CC0 from anything other than a COMPARE, we\n \t must enforce the mode so that we do not produce ambiguous insns.  */\n@@ -513,27 +572,32 @@ add_to_sequence (pattern, last, position)\n     case ZERO_EXTEND:\n     case STRICT_LOW_PART:\n       newpos[depth] = '0';\n-      new = add_to_sequence (XEXP (pattern, 0), &new->success, newpos);\n+      new = add_to_sequence (XEXP (pattern, 0), &new->success, newpos, \n+\t\t\t     insn_type, 0);\n       this->success.first->enforce_mode = 1;\n       return new;\n \n     case SUBREG:\n       this->test_elt_one_int = 1;\n       this->elt_one_int = XINT (pattern, 1);\n       newpos[depth] = '0';\n-      new = add_to_sequence (XEXP (pattern, 0), &new->success, newpos);\n+      new = add_to_sequence (XEXP (pattern, 0), &new->success, newpos,\n+\t\t\t     insn_type, 0);\n       this->success.first->enforce_mode = 1;\n       return new;\n \n     case ZERO_EXTRACT:\n     case SIGN_EXTRACT:\n       newpos[depth] = '0';\n-      new = add_to_sequence (XEXP (pattern, 0), &new->success, newpos);\n+      new = add_to_sequence (XEXP (pattern, 0), &new->success, newpos,\n+\t\t\t     insn_type, 0);\n       this->success.first->enforce_mode = 1;\n       newpos[depth] = '1';\n-      new = add_to_sequence (XEXP (pattern, 1), &new->success, newpos);\n+      new = add_to_sequence (XEXP (pattern, 1), &new->success, newpos,\n+\t\t\t     insn_type, 0);\n       newpos[depth] = '2';\n-      new = add_to_sequence (XEXP (pattern, 2), &new->success, newpos);\n+      new = add_to_sequence (XEXP (pattern, 2), &new->success, newpos,\n+\t\t\t     insn_type, 0);\n       return new;\n \n     case EQ:   case NE:   case LE:   case LT:   case GE:  case GT:\n@@ -548,10 +612,12 @@ add_to_sequence (pattern, last, position)\n     case COMPARE:\n       /* Enforce the mode on the first operand to avoid ambiguous insns.  */\n       newpos[depth] = '0';\n-      new = add_to_sequence (XEXP (pattern, 0), &new->success, newpos);\n+      new = add_to_sequence (XEXP (pattern, 0), &new->success, newpos,\n+\t\t\t     insn_type, 0);\n       this->success.first->enforce_mode = 1;\n       newpos[depth] = '1';\n-      new = add_to_sequence (XEXP (pattern, 1), &new->success, newpos);\n+      new = add_to_sequence (XEXP (pattern, 1), &new->success, newpos,\n+\t\t\t     insn_type, 0);\n       return new;\n       \n     default:\n@@ -564,7 +630,8 @@ add_to_sequence (pattern, last, position)\n     {\n       newpos[depth] = '0' + i;\n       if (fmt[i] == 'e' || fmt[i] == 'u')\n-\tnew = add_to_sequence (XEXP (pattern, i), &new->success, newpos);\n+\tnew = add_to_sequence (XEXP (pattern, i), &new->success, newpos,\n+\t\t\t       insn_type, 0);\n       else if (fmt[i] == 'i' && i == 0)\n \t{\n \t  this->test_elt_zero_int = 1;\n@@ -596,7 +663,7 @@ add_to_sequence (pattern, last, position)\n \t    {\n \t      newpos[depth] = 'a' + j;\n \t      new = add_to_sequence (XVECEXP (pattern, i, j),\n-\t\t\t\t     &new->success, newpos);\n+\t\t\t\t     &new->success, newpos, insn_type, 0);\n \t    }\n \t}\n       else if (fmt[i] != '0')\n@@ -1030,7 +1097,9 @@ write_subroutine (tree, type)\n {\n   int i;\n \n-  if (type == SPLIT)\n+  if (type == PEEPHOLE2)\n+    printf (\"extern rtx peephole2\");\n+  else if (type == SPLIT)\n     printf (\"extern rtx split\");\n   else\n     printf (\"extern int recog\");\n@@ -1041,26 +1110,36 @@ write_subroutine (tree, type)\n   printf (\" PROTO ((rtx, rtx\");\n   if (type == RECOG)\n     printf (\", int *\");\n+  else if (type == PEEPHOLE2)\n+    printf (\", rtx *\");\n   printf (\"));\\n\");\n \n-  if (type == SPLIT)\n+  if (type == PEEPHOLE2)\n+    printf (\"rtx\\npeephole2\");\n+  else if (type == SPLIT)\n     printf (\"rtx\\nsplit\");\n   else\n     printf (\"int\\nrecog\");\n \n   if (tree != 0 && tree->subroutine_number > 0)\n     printf (\"_%d\", tree->subroutine_number);\n-  else if (type == SPLIT)\n+  else if (IS_SPLIT (type))\n     printf (\"_insns\");\n \n   printf (\" (x0, insn\");\n   if (type == RECOG)\n     printf (\", pnum_clobbers\");\n+  else if (type == PEEPHOLE2)\n+    printf (\", _plast_insn\");\n \n   printf (\")\\n\");\n+  /* The peephole2 pass uses the insn argument to determine which\n+     hard registers are available at that point. */\n   printf (\"     register rtx x0;\\n     rtx insn ATTRIBUTE_UNUSED;\\n\");\n   if (type == RECOG)\n     printf (\"     int *pnum_clobbers ATTRIBUTE_UNUSED;\\n\");\n+  else if (type == PEEPHOLE2)\n+    printf (\"     rtx *_plast_insn ATTRIBUTE_UNUSED;\\n\");\n \n   printf (\"{\\n\");\n   printf (\"  register rtx *ro = &recog_operand[0];\\n\");\n@@ -1070,9 +1149,13 @@ write_subroutine (tree, type)\n     printf (\"x%d ATTRIBUTE_UNUSED, \", i);\n \n   printf (\"x%d ATTRIBUTE_UNUSED;\\n\", max_depth);\n-  printf (\"  %s tem ATTRIBUTE_UNUSED;\\n\", type == SPLIT ? \"rtx\" : \"int\");\n+  if (type == PEEPHOLE2)\n+    printf (\"  register rtx _last_insn = insn;\\n\");\n+  printf (\"  %s tem ATTRIBUTE_UNUSED;\\n\", IS_SPLIT (type) ? \"rtx\" : \"int\");\n   write_tree (tree, \"\", NULL_PTR, 1, type);\n-  printf (\" ret0: return %d;\\n}\\n\\n\", type == SPLIT ? 0 : -1);\n+  if (type == PEEPHOLE2)\n+    printf (\" ret1:\\n  *_plast_insn = _last_insn;\\n  return tem;\\n\");\n+  printf (\" ret0:\\n  return %d;\\n}\\n\\n\", IS_SPLIT (type) ? 0 : -1);\n }\n \f\n /* This table is used to indent the recog_* functions when we are inside\n@@ -1157,7 +1240,7 @@ write_tree_1 (tree, prevpos, afterward, type)\n \n   if (tree)\n     {\n-      change_state (prevpos, tree->position, 2);\n+      change_state (prevpos, tree->position, 2, afterward);\n       prevpos = tree->position;\n     }\n \n@@ -1308,7 +1391,8 @@ write_tree_1 (tree, prevpos, afterward, type)\n \t      if (afterward)\n \t\t{\n \t\t  printf (\"    {\\n\");\n-\t\t  change_state (p->position, afterward->position, 6);\n+\t\t  change_state (p->position, afterward->position, 6,\n+\t\t\t\tafterward);\n \t\t  printf (\"      goto L%d;\\n    }\\n\", afterward->number);\n \t\t}\n \t      else\n@@ -1328,7 +1412,8 @@ write_tree_1 (tree, prevpos, afterward, type)\n \t      if (afterward)\n \t\t{\n \t\t  printf (\"    {\\n\");\n-\t\t  change_state (p->position, afterward->position, indent + 4);\n+\t\t  change_state (p->position, afterward->position, indent + 4,\n+\t\t\t\tafterward);\n \t\t  printf (\"    goto L%d;\\n    }\\n\", afterward->number);\n \t\t}\n \t      else\n@@ -1466,9 +1551,22 @@ write_tree_1 (tree, prevpos, afterward, type)\n       if (p->insn_code_number >= 0)\n \t{\n \t  if (type == SPLIT)\n-\t    printf (\"%sreturn gen_split_%d (operands);\\n\",\n-\t\t    indents[inner_indent], p->insn_code_number);\n-\t  else\n+\t    {\n+\t      printf (\"%sreturn gen_split_%d (operands);\\n\",\n+\t\t      indents[inner_indent], p->insn_code_number);\n+\t    }\n+\t  else if (type == PEEPHOLE2)\n+\t    {\n+\t      printf (\"%s{\\n\", indents[inner_indent]);\n+\t      inner_indent += 2;\n+\n+\t      printf (\"%stem = gen_peephole2_%d (insn, operands);\\n\",\n+\t\t      indents[inner_indent], p->insn_code_number);\n+\t      printf (\"%sif (tem != 0) goto ret1;\\n\", indents[inner_indent]);\n+\t      inner_indent -= 2;\n+\t      printf (\"%s}\\n\", indents[inner_indent]);\n+\t    }\n+\t  else\t    \n \t    {\n \t      if (p->num_clobbers_to_add)\n \t\t{\n@@ -1528,7 +1626,7 @@ write_tree_1 (tree, prevpos, afterward, type)\n \n   if (afterward)\n     {\n-      change_state (prevpos, afterward->position, 2);\n+      change_state (prevpos, afterward->position, 2, afterward);\n       printf (\"  goto L%d;\\n\", afterward->number);\n     }\n   else\n@@ -1606,9 +1704,24 @@ write_tree (tree, prevpos, afterward, initial, type)\n      enum routine_type type;\n {\n   register struct decision *p;\n-  const char *name_prefix = (type == SPLIT ? \"split\" : \"recog\");\n-  const char *call_suffix = (type == SPLIT ? \"\" : \", pnum_clobbers\");\n+  const char *name_prefix;\n+  const char *call_suffix;\n \n+  switch (type)\n+    {\n+    case SPLIT:\n+      name_prefix = \"split\";\n+      call_suffix = \"\";\n+      break;\n+    case PEEPHOLE2:\n+      name_prefix = \"peephole2\";\n+      call_suffix = \", _plast_insn\";\n+      break;\n+    case RECOG:\n+      name_prefix = \"recog\";\n+      call_suffix = \", pnum_clobbers\";\n+      break;\n+    }\n   if (! initial && tree->subroutine_number > 0)\n     {\n       OUTPUT_LABEL (\" \", tree->number);\n@@ -1617,11 +1730,11 @@ write_tree (tree, prevpos, afterward, initial, type)\n \t{\n \t  printf (\"  tem = %s_%d (x0, insn%s);\\n\",\n \t\t  name_prefix, tree->subroutine_number, call_suffix);\n-\t  if (type == SPLIT)\n+\t  if (IS_SPLIT (type))\n \t    printf (\"  if (tem != 0) return tem;\\n\");\n \t  else\n \t    printf (\"  if (tem >= 0) return tem;\\n\");\n-\t  change_state (tree->position, afterward->position, 2);\n+\t  change_state (tree->position, afterward->position, 2, afterward);\n \t  printf (\"  goto L%d;\\n\", afterward->number);\n \t}\n       else\n@@ -1640,30 +1753,76 @@ write_tree (tree, prevpos, afterward, initial, type)\n \n \f\n /* Assuming that the state of argument is denoted by OLDPOS, take whatever\n-   actions are necessary to move to NEWPOS.\n+   actions are necessary to move to NEWPOS. If we fail to move to the\n+   new state, branch to node AFTERWARD if non-zero, otherwise return.\n+\n+   INDENT says how many blanks to place at the front of lines.  \n \n-   INDENT says how many blanks to place at the front of lines.  */\n+   Failure to move to the new state can only occur if we are trying to\n+   match multiple insns and we try to step past the end of the\n+   stream. */\n \n static void\n-change_state (oldpos, newpos, indent)\n+change_state (oldpos, newpos, indent, afterward)\n      const char *oldpos;\n      const char *newpos;\n      int indent;\n+     struct decision *afterward;\n {\n   int odepth = strlen (oldpos);\n   int depth = odepth;\n   int ndepth = strlen (newpos);\n+  int basedepth;\n+  int old_has_insn, new_has_insn;\n \n   /* Pop up as many levels as necessary.  */\n \n   while (strncmp (oldpos, newpos, depth))\n     --depth;\n+  basedepth = depth;\n+\n+  /* Make sure to reset the _last_insn pointer when popping back up.  */\n+  for (old_has_insn = odepth - 1; old_has_insn >= 0; --old_has_insn)\n+    if (oldpos[old_has_insn] >= 'A' && oldpos[old_has_insn] <= 'Z')\n+      break;\n+  for (new_has_insn = odepth - 1; new_has_insn >= 0; --new_has_insn)\n+    if (newpos[new_has_insn] >= 'A' && newpos[new_has_insn] <= 'Z')\n+      break;\n+\n+  if (old_has_insn >= 0 && new_has_insn < 0)\n+    printf (\"%s_last_insn = insn;\\n\", indents[indent]);\n \n   /* Go down to desired level.  */\n \n   while (depth < ndepth)\n     {\n-      if (newpos[depth] >= 'a' && newpos[depth] <= 'z')\n+      /* It's a different insn from the first one. */\n+      if (newpos[depth] >= 'A' && newpos[depth] <= 'Z')\n+\t{\n+\t  /* We can only fail if we're moving down the tree.  */\n+\t  if (old_has_insn >= 0 && oldpos[old_has_insn] >= newpos[depth])\n+\t    {\n+\t      printf (\"%s_last_insn = recog_next_insn (insn, %d);\\n\", \n+\t\t      indents[indent], newpos[depth] - 'A');\n+\t    }\n+\t  else\n+\t    {\n+\t      printf (\"%stem = recog_next_insn (insn, %d);\\n\", \n+\t\t      indents[indent], newpos[depth] - 'A');\n+\n+\t      printf (\"%sif (tem == NULL_RTX)\\n\", indents[indent]);\n+\t      if (afterward)\n+\t\tprintf (\"%sgoto L%d;\\n\", indents[indent + 2],\n+\t\t\tafterward->number);\n+\t      else\n+\t\tprintf (\"%sgoto ret0;\\n\", indents[indent + 2]);\n+\n+\t      printf (\"%s_last_insn = tem;\\n\", indents[indent]);\n+\t    }\n+\t  printf (\"%sx%d = PATTERN (_last_insn);\\n\",\n+\t\t  indents[indent], depth + 1);\n+\t}\n+      else if (newpos[depth] >= 'a' && newpos[depth] <= 'z')\n \tprintf (\"%sx%d = XVECEXP (x%d, 0, %d);\\n\",\n \t\tindents[indent], depth + 1, depth, newpos[depth] - 'a');\n       else\n@@ -1717,12 +1876,14 @@ main (argc, argv)\n   rtx desc;\n   struct decision_head recog_tree;\n   struct decision_head split_tree;\n+  struct decision_head peephole2_tree;\n   FILE *infile;\n   register int c;\n \n   progname = \"genrecog\";\n   obstack_init (rtl_obstack);\n   recog_tree.first = recog_tree.last = split_tree.first = split_tree.last = 0;\n+  peephole2_tree.first = peephole2_tree.last = 0;\n \n   if (argc <= 1)\n     fatal (\"No input file name.\");\n@@ -1767,6 +1928,10 @@ from the machine description file `md'.  */\\n\\n\");\n       else if (GET_CODE (desc) == DEFINE_SPLIT)\n \tsplit_tree = merge_trees (split_tree,\n \t\t\t\t  make_insn_sequence (desc, SPLIT));\n+      else if (GET_CODE (desc) == DEFINE_PEEPHOLE2)\n+\tpeephole2_tree = merge_trees (peephole2_tree,\n+\t\t\t\t      make_insn_sequence (desc, PEEPHOLE2));\n+\t\n       if (GET_CODE (desc) == DEFINE_PEEPHOLE\n \t  || GET_CODE (desc) == DEFINE_EXPAND)\n \tnext_insn_code++;\n@@ -1797,6 +1962,11 @@ from the machine description file `md'.  */\\n\\n\");\n     printf (\"\\n\\n   The function split_insns returns 0 if the rtl could not\\n\\\n    be split or the split rtl in a SEQUENCE if it can be.\");\n \n+  if (peephole2_tree.first)\n+    printf (\"\\n\\n   The function peephole2_insns returns 0 if the rtl could not\\n\\\n+   be matched. If there was a match, the new rtl is returned in a SEQUENCE,\\n\\\n+   and LAST_INSN will point to the last recognized insn in the old sequence.\");\n+\n   printf (\"*/\\n\\n\");\n \n   printf (\"#define operands recog_operand\\n\\n\");\n@@ -1809,6 +1979,10 @@ from the machine description file `md'.  */\\n\\n\");\n   break_out_subroutines (split_tree, SPLIT, 1);\n   write_subroutine (split_tree.first, SPLIT);\n \n+  next_subroutine_number = 0;\n+  break_out_subroutines (peephole2_tree, PEEPHOLE2, 1);\n+  write_subroutine (peephole2_tree.first, PEEPHOLE2);\n+\n   fflush (stdout);\n   exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n   /* NOTREACHED */"}, {"sha": "95c93d4dcc9307ccf448720513715aa38530b9fb", "filename": "gcc/recog.c", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=ede7cd44999a94c3eeb6708db37d6939045b554e", "patch": "@@ -34,6 +34,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"real.h\"\n #include \"toplev.h\"\n #include \"basic-block.h\"\n+#include \"output.h\"\n+#include \"resource.h\"\n \n #ifndef STACK_PUSH_CODE\n #ifdef STACK_GROWS_DOWNWARD\n@@ -2688,3 +2690,69 @@ split_block_insns (b, do_split)\n \tbreak;\n     }\n }\n+\f\n+#ifdef HAVE_peephole2\n+/* Return the Nth non-note insn after INSN, or return NULL_RTX if it does\n+   not exist.  Used by the recognizer to find the next insn to match in a\n+   multi-insn pattern.  */\n+rtx\n+recog_next_insn (insn, n)\n+     rtx insn;\n+     int n;\n+{\n+  while (insn != NULL_RTX && n > 0)\n+    {\n+      insn = next_nonnote_insn (insn);\n+\n+      if (insn == NULL_RTX)\n+\treturn insn;\n+\n+      if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+\treturn NULL_RTX;\n+\n+      n--;\n+    }\n+\n+  return insn;\n+}\n+\n+/* Perform the peephole2 optimization pass. */\n+void\n+peephole2_optimize (dump_file)\n+     FILE *dump_file ATTRIBUTE_UNUSED;\n+{\n+  rtx insn;\n+  rtx epilogue_insn = 0;\n+\n+  for (insn = get_last_insn (); insn != NULL_RTX; insn = PREV_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == NOTE\n+\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_EPILOGUE_BEG)\n+\t{\n+\t  epilogue_insn = insn;\n+\t  break;\n+\t}\n+    }\n+\n+  init_resource_info (epilogue_insn);\n+\n+  for (insn = get_insns (); insn != NULL;\n+       insn = next_nonnote_insn (insn))\n+    {\n+      if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN)\n+\t{\n+\t  rtx last_insn;\n+\t  rtx before = PREV_INSN (insn);\n+\n+\t  rtx try = peephole2_insns (PATTERN (insn), insn, &last_insn);\n+\t  if (try != NULL)\n+\t    {\n+\t      replace_insns (insn, last_insn, try, NULL_RTX);\n+\t      insn = NEXT_INSN (before);\n+\t    }\n+\t}\n+    }\n+\n+  free_resource_info ();\n+}\n+#endif"}, {"sha": "0337214e76d99496ecc8337528d9a520a4f3aecf", "filename": "gcc/recog.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=ede7cd44999a94c3eeb6708db37d6939045b554e", "patch": "@@ -114,6 +114,9 @@ extern void add_clobbers\t\tPROTO((rtx, int));\n extern void insn_extract\t\tPROTO((rtx));\n extern void extract_insn\t\tPROTO((rtx));\n extern void preprocess_constraints\tPROTO((void));\n+extern rtx recog_next_insn\t\tPROTO((rtx, int));\n+extern void peephole2_optimize\t\tPROTO((FILE *));\n+extern rtx peephole2_insns\t\tPROTO((rtx, rtx, rtx *));\n \n /* Nonzero means volatile operands are recognized.  */\n extern int volatile_ok;"}, {"sha": "880264594f7947f51884da34a6e17cb2ae233f1e", "filename": "gcc/resource.c", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=ede7cd44999a94c3eeb6708db37d6939045b554e", "patch": "@@ -1239,17 +1239,20 @@ mark_end_of_function_resources (trial, include_delayed_effects)\n \t\t\t     include_delayed_effects);\n }\n \f\n-/* Try to find an available hard register of mode MODE at\n-   CURRENT_INSN, matching the register class in CLASS_STR. Registers\n-   that already have bits set in REG_SET will not be considered.\n+/* Try to find a hard register of mode MODE, matching the register class in\n+   CLASS_STR, which is available at the beginning of insn CURRENT_INSN and\n+   remains available until the end of LAST_INSN.  LAST_INSN may be NULL_RTX,\n+   in which case the only condition is that the register must be available\n+   before CURRENT_INSN.\n+   Registers that already have bits set in REG_SET will not be considered.\n \n    If an appropriate register is available, it will be returned and the\n    corresponding bit(s) in REG_SET will be set; otherwise, NULL_RTX is\n    returned.  */\n \n rtx\n-find_free_register (current_insn, class_str, mode, reg_set)\n-     rtx current_insn;\n+find_free_register (current_insn, last_insn, class_str, mode, reg_set)\n+     rtx current_insn, last_insn;\n      char *class_str;\n      int mode;\n      HARD_REG_SET *reg_set;\n@@ -1261,6 +1264,14 @@ find_free_register (current_insn, class_str, mode, reg_set)\n     = (clet == 'r' ? GENERAL_REGS :  REG_CLASS_FROM_LETTER (clet));\n \n   mark_target_live_regs (get_insns (), current_insn, &used);\n+  if (last_insn)\n+    while (current_insn != last_insn)\n+      {\n+\t/* Exclude anything set in this insn.  */\n+\tmark_set_resources (PATTERN (current_insn), &used, 0, 1);\n+\tcurrent_insn = next_nonnote_insn (current_insn);\n+      }\n+\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {"}, {"sha": "49f3c4ff343196159489bea33b9eb538ccc35955", "filename": "gcc/resource.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Fresource.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Fresource.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.h?ref=ede7cd44999a94c3eeb6708db37d6939045b554e", "patch": "@@ -42,5 +42,5 @@ extern void incr_ticks_for_insn\t\tPROTO((rtx));\n extern void mark_end_of_function_resources PROTO ((rtx, int));\n extern void init_resource_info\t\tPROTO((rtx));\n extern void free_resource_info\t\tPROTO((void));\n-extern rtx find_free_register\t\tPROTO((rtx, char *, int,\n+extern rtx find_free_register\t\tPROTO((rtx, rtx, char *, int,\n \t\t\t\t\t       HARD_REG_SET *));"}, {"sha": "0b5a83a85e809dd339a6eb7e39bf69bf120c74f8", "filename": "gcc/rtl.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=ede7cd44999a94c3eeb6708db37d6939045b554e", "patch": "@@ -207,6 +207,10 @@ DEF_RTL_EXPR(DEFINE_PEEPHOLE, \"define_peephole\", \"EssV\", 'x')\n \t(`operands' is an alias here for `recog_operand').   */\n DEF_RTL_EXPR(DEFINE_SPLIT, \"define_split\", \"EsES\", 'x')\n \n+/* Definition of an RTL peephole operation.\n+   Follows the same arguments as define_split.  */\n+DEF_RTL_EXPR(DEFINE_PEEPHOLE2, \"define_peephole2\", \"EsES\", 'x')\n+\n /* Definition of a combiner pattern.\n    Operands not defined yet.  */\n DEF_RTL_EXPR(DEFINE_COMBINE, \"define_combine\", \"Ess\", 'x')"}, {"sha": "a3017b70d3aea77d015242f2509108621eeb37a1", "filename": "gcc/toplev.c", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede7cd44999a94c3eeb6708db37d6939045b554e/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=ede7cd44999a94c3eeb6708db37d6939045b554e", "patch": "@@ -290,6 +290,7 @@ int sched_dump = 0;\n int local_reg_dump = 0;\n int global_reg_dump = 0;\n int flow2_dump = 0;\n+int peephole2_dump = 0;\n int sched2_dump = 0;\n int jump2_opt_dump = 0;\n #ifdef DELAY_SLOTS\n@@ -761,6 +762,9 @@ int flag_instrument_function_entry_exit = 0;\n \n int flag_no_ident = 0;\n \n+/* This will perform a peephole pass before sched2. */\n+int flag_peephole2 = 0;\n+\n /* Table of supported debugging formats.  */\n static struct\n {\n@@ -966,7 +970,9 @@ lang_independent_options f_options[] =\n   {\"leading-underscore\", &flag_leading_underscore, 1,\n    \"External symbols have a leading underscore\" },\n   {\"ident\", &flag_no_ident, 0,\n-   \"Process #ident directives\"}\n+   \"Process #ident directives\"},\n+  { \"peephole2\", &flag_peephole2, 1,\n+    \"Enables an rtl peephole pass run before sched2\" }\n };\n \n #define NUM_ELEM(a)  (sizeof (a) / sizeof ((a)[0]))\n@@ -3004,6 +3010,12 @@ compile_file (name)\n       if (graph_dump_format != no_graph)\n \tclean_graph_dump_file (dump_base_name, \".flow2\");\n     }\n+  if (peephole2_dump)\n+    {\n+      clean_dump_file (\".peephole2\");\n+      if (graph_dump_format != no_graph)\n+\tclean_graph_dump_file (dump_base_name, \".peephole2\");\n+    }\n   if (sched2_dump)\n     {\n       clean_dump_file (\".sched2\");\n@@ -4226,6 +4238,23 @@ rest_of_compilation (decl)\n \tprint_rtl_graph_with_bb (dump_base_name, \".flow2\", insns);\n     }\n \n+#ifdef HAVE_peephole2\n+  if (optimize > 0 && flag_peephole2)\n+    {\n+      if (peephole2_dump)\n+\topen_dump_file (\".peephole2\", decl_printable_name (decl, 2));\n+\n+      peephole2_optimize (rtl_dump_file);\n+\n+      if (peephole2_dump)\n+\t{\n+\t  close_dump_file (print_rtl_with_bb, insns);\n+\t  if (graph_dump_format != no_graph)\n+\t    print_rtl_graph_with_bb (dump_base_name, \".peephole2\", insns);\n+\t}\n+    }\n+#endif\n+\n   if (optimize > 0 && flag_schedule_insns_after_reload)\n     {\n       if (sched2_dump)\n@@ -4822,6 +4851,7 @@ main (argc, argv)\n       flag_rerun_loop_opt = 1;\n       flag_caller_saves = 1;\n       flag_force_mem = 1;\n+      flag_peephole2 = 1;\n #ifdef INSN_SCHEDULING\n       flag_schedule_insns = 1;\n       flag_schedule_insns_after_reload = 1;\n@@ -4917,6 +4947,7 @@ main (argc, argv)\n #ifdef MACHINE_DEPENDENT_REORG\n \t\t    mach_dep_reorg_dump = 1;\n #endif\n+\t\t    peephole2_dump = 1;\n \t\t    break;\n \t\t  case 'A':\n \t\t    flag_debug_asm = 1;\n@@ -4996,11 +5027,14 @@ main (argc, argv)\n \t\t  case 'w':\n \t\t    flow2_dump = 1;\n \t\t    break;\n+\t\t  case 'x':\n+\t\t    rtl_dump_and_exit = 1;\n+\t\t    break;\n \t\t  case 'y':\n \t\t    set_yydebug (1);\n \t\t    break;\n-\t\t  case 'x':\n-\t\t    rtl_dump_and_exit = 1;\n+\t\t  case 'z':\n+\t\t    peephole2_dump = 1;\n \t\t    break;\n \t\t  case 'D':\t/* these are handled by the preprocessor */\n \t\t  case 'I':"}]}