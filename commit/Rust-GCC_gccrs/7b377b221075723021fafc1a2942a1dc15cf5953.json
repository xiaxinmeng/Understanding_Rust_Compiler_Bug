{"sha": "7b377b221075723021fafc1a2942a1dc15cf5953", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2IzNzdiMjIxMDc1NzIzMDIxZmFmYzFhMjk0MmExZGMxNWNmNTk1Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2018-12-04T21:38:01Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-12-04T21:38:01Z"}, "message": "ipa-prop.c (jump_function_useful_p): New.\n\n\n\t* ipa-prop.c (jump_function_useful_p): New.\n\t(ipa_read_node_info): Do not allocated useless jump functions.\n\nFrom-SVN: r266799", "tree": {"sha": "0720f8ba9532f427706cf1b3e7671730ea889f15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0720f8ba9532f427706cf1b3e7671730ea889f15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b377b221075723021fafc1a2942a1dc15cf5953", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b377b221075723021fafc1a2942a1dc15cf5953", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b377b221075723021fafc1a2942a1dc15cf5953", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b377b221075723021fafc1a2942a1dc15cf5953/comments", "author": null, "committer": null, "parents": [{"sha": "206d8779eb286b3bdbfab5723a5265357ccf33b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/206d8779eb286b3bdbfab5723a5265357ccf33b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/206d8779eb286b3bdbfab5723a5265357ccf33b3"}], "stats": {"total": 39, "additions": 39, "deletions": 0}, "files": [{"sha": "baf3825766538f0f0c3f083e8f941246c413d8b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b377b221075723021fafc1a2942a1dc15cf5953/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b377b221075723021fafc1a2942a1dc15cf5953/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b377b221075723021fafc1a2942a1dc15cf5953", "patch": "@@ -1,3 +1,8 @@\n+2018-12-04  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-prop.c (jump_function_useful_p): New.\n+\t(ipa_read_node_info): Do not allocated useless jump functions.\n+\n 2018-12-04  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c/82967"}, {"sha": "f19b3ab2b7f2331b0ea4005b35e83ffb287b9d36", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b377b221075723021fafc1a2942a1dc15cf5953/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b377b221075723021fafc1a2942a1dc15cf5953/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=7b377b221075723021fafc1a2942a1dc15cf5953", "patch": "@@ -4344,6 +4344,26 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n     }\n }\n \n+/* If jump functions points to node we possibly can propagate into.\n+   At this moment symbol table is still not merged, but the prevailing\n+   symbol is always first in the list.  */\n+\n+static bool\n+jump_function_useful_p (symtab_node *node)\n+{\n+  /* While incremental linking we may end up getting function body later.  */\n+  if (flag_incremental_link == INCREMENTAL_LINK_LTO)\n+    return true;\n+  if (!TREE_PUBLIC (node->decl) && !DECL_EXTERNAL (node->decl))\n+    return true;\n+  for (int n = 10; node->previous_sharing_asm_name && n ; n--)\n+    node = node->previous_sharing_asm_name;\n+  if (node->previous_sharing_asm_name)\n+    node = symtab_node::get_for_asmname (DECL_ASSEMBLER_NAME (node->decl));\n+  gcc_assert (TREE_PUBLIC (node->decl));\n+  return node->definition;\n+}\n+\n /* Stream in NODE info from IB.  */\n \n static void\n@@ -4380,6 +4400,20 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n \n       if (!count)\n \tcontinue;\n+      if (!jump_function_useful_p (e->callee))\n+\t{\n+          for (k = 0; k < count; k++)\n+\t    {\n+\t      struct ipa_jump_func dummy;\n+\t      ipa_read_jump_function (ib, &dummy, e, data_in);\n+\t      if (contexts_computed)\n+\t\t{\n+\t\t  struct ipa_polymorphic_call_context ctx;\n+\t\t  ctx.stream_in (ib, data_in);\n+\t\t}\n+\t    }\n+\t  continue;\n+\t}\n       vec_safe_grow_cleared (args->jump_functions, count);\n       if (contexts_computed)\n \tvec_safe_grow_cleared (args->polymorphic_call_contexts, count);"}]}