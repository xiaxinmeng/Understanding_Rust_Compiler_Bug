{"sha": "01439aeea597671b4e292002bc2b1ae2d7e3e82d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE0MzlhZWVhNTk3NjcxYjRlMjkyMDAyYmMyYjFhZTJkN2UzZTgyZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-09-08T05:00:54Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-08T05:00:54Z"}, "message": "alpha.h (alpha_eh_epilogue_sp_ofs): Remove.\n\n        * alpha.h (alpha_eh_epilogue_sp_ofs): Remove.\n        (struct machine_function): Declare; add eh_epilogue_sp_ofs.\n        (INIT_EXPANDERS): Remove.\n        * alpha.c: Include ggc.h.\n        (alpha_eh_epilogue_sp_ofs, alpha_return_addr_rtx): Remove.\n        (alpha_init_machine_status, alpha_mark_machine_status): New.\n        (override_options): Install them.\n        (struct machine_function): Moved to alpha.h.\n        (alpha_save_machine_status, alpha_restore_machine_status): Remove.\n        (alpha_init_expanders): Remove.\n        (alpha_return_addr): Adjust to use current_function->machine.\n        (alpha_ra_ever_killed): Likewise.\n        (alpha_expand_epilogue): Likewise.\n        * alpha.md (eh_epilogue): Likewise.\n\nFrom-SVN: r29182", "tree": {"sha": "ae00fa8433655136bf64936e369c9a43b7ba7401", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae00fa8433655136bf64936e369c9a43b7ba7401"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01439aeea597671b4e292002bc2b1ae2d7e3e82d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01439aeea597671b4e292002bc2b1ae2d7e3e82d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01439aeea597671b4e292002bc2b1ae2d7e3e82d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01439aeea597671b4e292002bc2b1ae2d7e3e82d/comments", "author": null, "committer": null, "parents": [{"sha": "7d617b67c06b5bd615a20982da569aa1c563a00b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d617b67c06b5bd615a20982da569aa1c563a00b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d617b67c06b5bd615a20982da569aa1c563a00b"}], "stats": {"total": 131, "additions": 65, "deletions": 66}, "files": [{"sha": "c5a8b174cdadd6ab778193a1545d825ba607e07b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01439aeea597671b4e292002bc2b1ae2d7e3e82d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01439aeea597671b4e292002bc2b1ae2d7e3e82d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01439aeea597671b4e292002bc2b1ae2d7e3e82d", "patch": "@@ -1,3 +1,20 @@\n+Tue Sep  7 21:55:02 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alpha.h (alpha_eh_epilogue_sp_ofs): Remove.\n+\t(struct machine_function): Declare; add eh_epilogue_sp_ofs.\n+\t(INIT_EXPANDERS): Remove.\n+\t* alpha.c: Include ggc.h.\n+\t(alpha_eh_epilogue_sp_ofs, alpha_return_addr_rtx): Remove.\n+\t(alpha_init_machine_status, alpha_mark_machine_status): New.\n+\t(override_options): Install them.\n+\t(struct machine_function): Moved to alpha.h.\n+\t(alpha_save_machine_status, alpha_restore_machine_status): Remove.\n+\t(alpha_init_expanders): Remove.\n+\t(alpha_return_addr): Adjust to use current_function->machine.\n+\t(alpha_ra_ever_killed): Likewise.\n+\t(alpha_expand_epilogue): Likewise.\n+\t* alpha.md (eh_epilogue): Likewise.\n+\n Wed Sep  8 14:34:42 1999  Ian Piumarta  <piumarta@prof.inria.fr>\n \t\t\t  Melissa O'Neill  <oneill@cs.sfu.ca>\n \t\t\t  Geoffrey Keating  <geoffk@cygnus.com>"}, {"sha": "37699ca5d50422ab0450b2e69e81cdb6bda5fd8c", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 38, "deletions": 57, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01439aeea597671b4e292002bc2b1ae2d7e3e82d/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01439aeea597671b4e292002bc2b1ae2d7e3e82d/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=01439aeea597671b4e292002bc2b1ae2d7e3e82d", "patch": "@@ -40,6 +40,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"function.h\"\n #include \"toplev.h\"\n+#include \"ggc.h\"\n \n /* External data.  */\n extern char *version_string;\n@@ -79,19 +80,11 @@ const char *alpha_mlat_string;\t/* -mmemory-latency= */\n rtx alpha_compare_op0, alpha_compare_op1;\n int alpha_compare_fp_p;\n \n-/* Define the information needed to modify the epilogue for EH.  */\n-\n-rtx alpha_eh_epilogue_sp_ofs;\n-\n /* Non-zero if inside of a function, because the Alpha asm can't\n    handle .files inside of functions.  */\n \n static int inside_function = FALSE;\n \n-/* If non-null, this rtx holds the return address for the function.  */\n-\n-static rtx alpha_return_addr_rtx;\n-\n /* The number of cycles of latency we should assume on memory reads.  */\n \n int alpha_memory_latency = 3;\n@@ -117,6 +110,10 @@ static void alpha_sa_mask\n   PROTO((unsigned long *imaskP, unsigned long *fmaskP));\n static int alpha_does_function_need_gp\n   PROTO((void));\n+static void alpha_init_machine_status\n+  PROTO((struct function *p));\n+static void alpha_mark_machine_status\n+  PROTO((struct function *p));\n \n \n /* Get the number of args of a function in one of two ways.  */\n@@ -319,6 +316,10 @@ override_options ()\n \n   /* Acquire a unique set number for our register saves and restores.  */\n   alpha_sr_alias_set = new_alias_set ();\n+\n+  /* Set up function hooks.  */\n+  init_machine_status = alpha_init_machine_status;\n+  mark_machine_status = alpha_mark_machine_status;\n }\n \f\n /* Returns 1 if VALUE is a mask that contains full bytes of zero or ones.  */\n@@ -2561,45 +2562,22 @@ alpha_adjust_cost (insn, link, dep_insn, cost)\n \f\n /* Functions to save and restore alpha_return_addr_rtx.  */\n \n-struct machine_function\n-{\n-  rtx ra_rtx;\n-};\n-\n static void\n-alpha_save_machine_status (p)\n+alpha_init_machine_status (p)\n      struct function *p;\n {\n-  struct machine_function *machine =\n-    (struct machine_function *) xmalloc (sizeof (struct machine_function));\n-\n-  p->machine = machine;\n-  machine->ra_rtx = alpha_return_addr_rtx;\n+  p->machine =\n+    (struct machine_function *) xcalloc (1, sizeof (struct machine_function));\n }\n \n static void\n-alpha_restore_machine_status (p)\n+alpha_mark_machine_status (p)\n      struct function *p;\n {\n   struct machine_function *machine = p->machine;\n \n-  alpha_return_addr_rtx = machine->ra_rtx;\n-\n-  free (machine);\n-  p->machine = (struct machine_function *)0;\n-}\n-\n-/* Do anything needed before RTL is emitted for each function.  */\n-\n-void\n-alpha_init_expanders ()\n-{\n-  alpha_return_addr_rtx = NULL_RTX;\n-  alpha_eh_epilogue_sp_ofs = NULL_RTX;\n-\n-  /* Arrange to save and restore machine status around nested functions.  */\n-  save_machine_status = alpha_save_machine_status;\n-  restore_machine_status = alpha_restore_machine_status;\n+  ggc_mark_rtx (machine->eh_epilogue_sp_ofs);\n+  ggc_mark_rtx (machine->ra_rtx);\n }\n \n /* Start the ball rolling with RETURN_ADDR_RTX.  */\n@@ -2609,25 +2587,27 @@ alpha_return_addr (count, frame)\n      int count;\n      rtx frame ATTRIBUTE_UNUSED;\n {\n-  rtx init;\n+  rtx init, reg;\n \n   if (count != 0)\n     return const0_rtx;\n \n-  if (alpha_return_addr_rtx)\n-    return alpha_return_addr_rtx;\n-\n-  /* No rtx yet.  Invent one, and initialize it from $26 in the prologue.  */\n-  alpha_return_addr_rtx = gen_reg_rtx (Pmode);\n-  init = gen_rtx_SET (VOIDmode, alpha_return_addr_rtx,\n-\t\t      gen_rtx_REG (Pmode, REG_RA));\n-\n-  /* Emit the insn to the prologue with the other argument copies.  */\n-  push_topmost_sequence ();\n-  emit_insn_after (init, get_insns ());\n-  pop_topmost_sequence ();\n+  reg = current_function->machine->ra_rtx;\n+  if (reg == NULL)\n+    {\n+      /* No rtx yet.  Invent one, and initialize it from $26 in\n+\t the prologue.  */\n+      reg = gen_reg_rtx (Pmode);\n+      current_function->machine->ra_rtx = reg;\n+      init = gen_rtx_SET (VOIDmode, reg, gen_rtx_REG (Pmode, REG_RA));\n+\n+      /* Emit the insn to the prologue with the other argument copies.  */\n+      push_topmost_sequence ();\n+      emit_insn_after (init, get_insns ());\n+      pop_topmost_sequence ();\n+    }\n \n-  return alpha_return_addr_rtx;\n+  return reg;\n }\n \n static int\n@@ -2639,7 +2619,7 @@ alpha_ra_ever_killed ()\n   if (current_function_is_thunk)\n     return 0;\n #endif\n-  if (!alpha_return_addr_rtx)\n+  if (!current_function->machine->ra_rtx)\n     return regs_ever_live[REG_RA];\n \n   push_topmost_sequence ();\n@@ -3932,6 +3912,7 @@ alpha_expand_epilogue ()\n   int fp_is_frame_pointer, fp_offset;\n   rtx sa_reg, sa_reg_exp = NULL;\n   rtx sp_adj1, sp_adj2, mem;\n+  rtx eh_ofs;\n   int i;\n \n   sa_size = alpha_sa_size ();\n@@ -3958,6 +3939,7 @@ alpha_expand_epilogue ()\n   fp_is_frame_pointer = ((TARGET_OPEN_VMS && vms_is_stack_procedure)\n \t\t\t || (!TARGET_OPEN_VMS && frame_pointer_needed));\n \n+  eh_ofs = current_function->machine->eh_epilogue_sp_ofs;\n   if (sa_size)\n     {\n       /* If we have a frame pointer, restore SP from it.  */\n@@ -3988,7 +3970,7 @@ alpha_expand_epilogue ()\n \t  \n       /* Restore registers in order, excepting a true frame pointer. */\n \n-      if (! alpha_eh_epilogue_sp_ofs)\n+      if (! eh_ofs)\n \t{\n \t  mem = gen_rtx_MEM (DImode, plus_constant(sa_reg, reg_offset));\n \t  MEM_ALIAS_SET (mem) = alpha_sr_alias_set;\n@@ -4021,16 +4003,15 @@ alpha_expand_epilogue ()\n \t  }\n     }\n \n-  if (frame_size || alpha_eh_epilogue_sp_ofs)\n+  if (frame_size || eh_ofs)\n     {\n       sp_adj1 = stack_pointer_rtx;\n \n-      if (alpha_eh_epilogue_sp_ofs)\n+      if (eh_ofs)\n \t{\n \t  sp_adj1 = gen_rtx_REG (DImode, 23);\n \t  emit_move_insn (sp_adj1,\n-\t\t\t  gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n-\t\t\t\t\talpha_eh_epilogue_sp_ofs));\n+\t\t\t  gen_rtx_PLUS (Pmode, stack_pointer_rtx, eh_ofs));\n \t}\n \n       /* If the stack size is large, begin computation into a temporary"}, {"sha": "a18ad5fd25fa863d65ab5a27159fe31029f91583", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01439aeea597671b4e292002bc2b1ae2d7e3e82d/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01439aeea597671b4e292002bc2b1ae2d7e3e82d/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=01439aeea597671b4e292002bc2b1ae2d7e3e82d", "patch": "@@ -1200,9 +1200,16 @@ extern struct rtx_def *alpha_emit_conditional_move ();\n extern struct rtx_def *alpha_compare_op0, *alpha_compare_op1;\n extern int alpha_compare_fp_p;\n \n-/* Define the information needed to modify the epilogue for EH.  */\n+/* Machine specific function data.  */\n \n-extern struct rtx_def *alpha_eh_epilogue_sp_ofs;\n+struct machine_function\n+{\n+  /* An offset to apply to the stack pointer when unwinding from EH.  */\n+  struct rtx_def *eh_epilogue_sp_ofs;\n+\n+  /* If non-null, this rtx holds the return address for the function.  */\n+  struct rtx_def *ra_rtx;\n+};\n \n /* Make (or fake) .linkage entry for function call.\n    IS_LOCAL is 0 if name is used in call, 1 if name is used in definition.  */\n@@ -1327,12 +1334,6 @@ extern struct rtx_def *alpha_return_addr ();\n \n /* Before the prologue, RA lives in $26. */\n #define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (Pmode, 26)\n-\n-/* Initialize data used by insn expanders.  This is called from insn_emit,\n-   once for every function before code is generated.  */\n-\n-#define INIT_EXPANDERS  alpha_init_expanders ()\n-extern void alpha_init_expanders ();\n \f\n /* Addressing modes, and classification of registers for them.  */\n "}, {"sha": "456642f050d5fc024f72d1d2e5ce431e85f08689", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01439aeea597671b4e292002bc2b1ae2d7e3e82d/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01439aeea597671b4e292002bc2b1ae2d7e3e82d/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=01439aeea597671b4e292002bc2b1ae2d7e3e82d", "patch": "@@ -5159,7 +5159,7 @@\n   \"! TARGET_OPEN_VMS\"\n   \"\n {\n-  alpha_eh_epilogue_sp_ofs = operands[1];\n+  current_function->machine->eh_epilogue_sp_ofs = operands[1];\n   if (GET_CODE (operands[2]) != REG || REGNO (operands[2]) != 26)\n     {\n       rtx ra = gen_rtx_REG (Pmode, 26);"}]}