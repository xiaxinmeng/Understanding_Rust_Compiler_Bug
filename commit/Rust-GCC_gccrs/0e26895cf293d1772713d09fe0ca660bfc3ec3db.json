{"sha": "0e26895cf293d1772713d09fe0ca660bfc3ec3db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUyNjg5NWNmMjkzZDE3NzI3MTNkMDlmZTBjYTY2MGJmYzNlYzNkYg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-03-02T02:20:21Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-03-02T02:20:21Z"}, "message": "h8300.c (gtle_operator): Accept GT and LE.\n\n\t* config/h8300/h8300.c (gtle_operator): Accept GT and LE.\n\t* config/h8300/h8300.md: Split several peephole2's, each into\n\ttwo.\n\nFrom-SVN: r78741", "tree": {"sha": "2072c8d226142e670166371bad8b608ec3f3bf83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2072c8d226142e670166371bad8b608ec3f3bf83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e26895cf293d1772713d09fe0ca660bfc3ec3db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e26895cf293d1772713d09fe0ca660bfc3ec3db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e26895cf293d1772713d09fe0ca660bfc3ec3db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e26895cf293d1772713d09fe0ca660bfc3ec3db/comments", "author": null, "committer": null, "parents": [{"sha": "676e33ca810aa9f33fd233c75d845638e4755c0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/676e33ca810aa9f33fd233c75d845638e4755c0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/676e33ca810aa9f33fd233c75d845638e4755c0d"}], "stats": {"total": 308, "additions": 218, "deletions": 90}, "files": [{"sha": "62719cee8e9e4d676a9fa78d8170b7b9bd94b8e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e26895cf293d1772713d09fe0ca660bfc3ec3db/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e26895cf293d1772713d09fe0ca660bfc3ec3db/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e26895cf293d1772713d09fe0ca660bfc3ec3db", "patch": "@@ -1,3 +1,9 @@\n+2004-03-01  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/h8300/h8300.c (gtle_operator): Accept GT and LE.\n+\t* config/h8300/h8300.md: Split several peephole2's, each into\n+\ttwo.\n+\n 2004-03-02  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* dominance.c (recount_dominator): Handle postdominators."}, {"sha": "11e675cca21345a1b478d1b8908e738e03c1f710", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e26895cf293d1772713d09fe0ca660bfc3ec3db/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e26895cf293d1772713d09fe0ca660bfc3ec3db/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=0e26895cf293d1772713d09fe0ca660bfc3ec3db", "patch": "@@ -1793,14 +1793,14 @@ eqne_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n   return (code == EQ || code == NE);\n }\n \n-/* Return nonzero if X is GT, LE, GTU, or LEU.  */\n+/* Return nonzero if X is either GT or LE.  */\n \n int\n gtle_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (x);\n \n-  return (code == GT || code == LE || code == GTU || code == LEU);\n+  return (code == GT || code == LE);\n }\n \n /* Return nonzero if X is either GTU or LEU.  */"}, {"sha": "18995e7610b21c6231acc1a1b9c38300fd034a87", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 210, "deletions": 88, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e26895cf293d1772713d09fe0ca660bfc3ec3db/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e26895cf293d1772713d09fe0ca660bfc3ec3db/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=0e26895cf293d1772713d09fe0ca660bfc3ec3db", "patch": "@@ -4135,9 +4135,14 @@\n ;; dead     1                       eq/ne   dec.l\n ;; dead     2                       eq/ne   dec.l\n ;;\n+;; dead     1                       ge/lt shar.l\n+;; dead     3 (H8S)                 ge/lt shar.l\n+;;\n ;; dead     1                       geu/ltu shar.l\n ;; dead     3 (H8S)                 geu/ltu shar.l\n ;;\n+;; ----   255                       ge/lt mov.b\n+;;\n ;; ----   255                       geu/ltu mov.b\n \n ;; Transform\n@@ -4203,22 +4208,10 @@\n    (set (cc0)\n \t(match_dup 0))\n    (set (pc)\n-\t(if_then_else (match_dup 5)\n+\t(if_then_else (match_dup 2)\n \t\t      (label_ref (match_dup 3))\n \t\t      (pc)))]\n-  \"switch (GET_CODE (operands[2]))\n-     {\n-     case GTU:\n-       operands[5] = gen_rtx_NE (VOIDmode, cc0_rtx, const0_rtx);\n-       break;\n-     case LEU:\n-       operands[5] = gen_rtx_EQ (VOIDmode, cc0_rtx, const0_rtx);\n-       break;\n-     default:\n-       operands[5] = operands[2];\n-       break;\n-     }\n-   operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\")\n+  \"operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\")\n \n ;; Transform\n ;;\n@@ -4230,7 +4223,36 @@\n ;;\tshar.w\tr0\n ;;\tbne\t.L1\n \n-;; TODO: Split the above peephole2.\n+(define_peephole2\n+  [(set (cc0)\n+\t(compare (match_operand:HI 0 \"register_operand\" \"\")\n+\t\t (match_operand:HI 1 \"const_int_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 2 \"gtuleu_operator\"\n+\t\t\t[(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"(TARGET_H8300H || TARGET_H8300S)\n+   && peep2_reg_dead_p (1, operands[0])\n+   && (INTVAL (operands[1]) == 1\n+\t|| (TARGET_H8300S && INTVAL (operands[1]) == 3))\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ashiftrt:HI (match_dup 0)\n+\t\t\t\t(match_dup 4)))\n+\t      (clobber (scratch:QI))])\n+   (set (cc0)\n+\t(match_dup 0))\n+   (set (pc)\n+\t(if_then_else (match_dup 5)\n+\t\t      (label_ref (match_dup 3))\n+\t\t      (pc)))]\n+{\n+  operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n+  operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[2]) == GTU ? NE : EQ,\n+\t\t\t\tVOIDmode,\n+\t\t\t\tcc0_rtx,\n+\t\t\t\tconst0_rtx);\n+})\n \n ;; Transform\n ;;\n@@ -4256,21 +4278,10 @@\n \t(and:HI (match_dup 0)\n \t\t(const_int -256)))\n    (set (pc)\n-\t(if_then_else (match_dup 3)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_dup 2))\n \t\t      (pc)))]\n-  \"switch (GET_CODE (operands[1]))\n-     {\n-     case GTU:\n-       operands[3] = gen_rtx_NE (VOIDmode, cc0_rtx, const0_rtx);\n-       break;\n-     case LEU:\n-       operands[3] = gen_rtx_EQ (VOIDmode, cc0_rtx, const0_rtx);\n-       break;\n-     default:\n-       operands[3] = operands[1];\n-       break;\n-     }\")\n+  \"\")\n \n ;; Transform\n ;;\n@@ -4282,7 +4293,29 @@\n ;;\tmov.b\tr0h,r0h\n ;;\tbne\t.L1\n \n-;; TODO: Split the above peephole2.\n+(define_peephole2\n+  [(set (cc0)\n+\t(compare (match_operand:HI 0 \"register_operand\" \"\")\n+\t\t (const_int 255)))\n+   (set (pc)\n+\t(if_then_else (match_operator 1 \"gtuleu_operator\"\n+\t\t\t[(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_H8300H || TARGET_H8300S\"\n+  [(set (cc0)\n+\t(and:HI (match_dup 0)\n+\t\t(const_int -256)))\n+   (set (pc)\n+\t(if_then_else (match_dup 3)\n+\t\t      (label_ref (match_dup 2))\n+\t\t      (pc)))]\n+{\n+  operands[3] = gen_rtx_fmt_ee (GET_CODE (operands[1]) == GTU ? NE : EQ,\n+\t\t\t\tVOIDmode,\n+\t\t\t\tcc0_rtx,\n+\t\t\t\tconst0_rtx);\n+})\n \n ;; (compare (reg:SI) (const_int)) takes 6 bytes, so we try to achieve\n ;; the equivalent with shorter sequences.  Here is the summary.  Cases\n@@ -4314,12 +4347,26 @@\n ;; dead 0x40000000 (H8S)            eq/ne   rotl.l and dec.l\n ;; dead 0x80000000                  eq/ne   rotl.l and dec.l\n ;;\n+;; live     1                       ge/lt copy and shar.l\n+;; live     3 (H8S)                 ge/lt copy and shar.l\n+;;\n ;; live     1                       geu/ltu copy and shar.l\n ;; live     3 (H8S)                 geu/ltu copy and shar.l\n ;;\n+;; dead     1                       ge/lt shar.l\n+;; dead     3 (H8S)                 ge/lt shar.l\n+;;\n ;; dead     1                       geu/ltu shar.l\n ;; dead     3 (H8S)                 geu/ltu shar.l\n ;;\n+;; dead     3 (H8/300H)             ge/lt and.b and test\n+;; dead     7                       ge/lt and.b and test\n+;; dead    15                       ge/lt and.b and test\n+;; dead    31                       ge/lt and.b and test\n+;; dead    63                       ge/lt and.b and test\n+;; dead   127                       ge/lt and.b and test\n+;; dead   255                       ge/lt and.b and test\n+;;\n ;; dead     3 (H8/300H)             geu/ltu and.b and test\n ;; dead     7                       geu/ltu and.b and test\n ;; dead    15                       geu/ltu and.b and test\n@@ -4328,6 +4375,8 @@\n ;; dead   127                       geu/ltu and.b and test\n ;; dead   255                       geu/ltu and.b and test\n ;;\n+;; ---- 65535                       ge/lt mov.w\n+;;\n ;; ---- 65535                       geu/ltu mov.w\n \n ;; For a small constant, it is cheaper to actually do the subtraction\n@@ -4507,22 +4556,10 @@\n    (set (cc0)\n \t(match_dup 4))\n    (set (pc)\n-\t(if_then_else (match_dup 6)\n+\t(if_then_else (match_dup 2)\n \t\t      (label_ref (match_dup 3))\n \t\t      (pc)))]\n-  \"switch (GET_CODE (operands[2]))\n-     {\n-     case GTU:\n-       operands[6] = gen_rtx_NE (VOIDmode, cc0_rtx, const0_rtx);\n-       break;\n-     case LEU:\n-       operands[6] = gen_rtx_EQ (VOIDmode, cc0_rtx, const0_rtx);\n-       break;\n-     default:\n-       operands[6] = operands[2];\n-       break;\n-     }\n-   operands[5] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\")\n+  \"operands[5] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\")\n \n ;; Transform\n ;;\n@@ -4535,7 +4572,43 @@\n ;;\tshar.l\ter1\n ;;\tbne\t.L1\n \n-;; TODO: Split the above peephole2.\n+;; We avoid this transformation if we see more than one copy of the\n+;; same compare insn immediately before this one.\n+\n+(define_peephole2\n+  [(match_scratch:SI 4 \"r\")\n+   (set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 2 \"gtuleu_operator\"\n+\t\t\t[(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"(TARGET_H8300H || TARGET_H8300S)\n+   && !peep2_reg_dead_p (1, operands[0])\n+   && (INTVAL (operands[1]) == 1\n+\t|| (TARGET_H8300S && INTVAL (operands[1]) == 3))\n+   && !same_cmp_preceding_p (insn)\"\n+  [(set (match_dup 4)\n+\t(match_dup 0))\n+   (parallel [(set (match_dup 4)\n+\t\t   (ashiftrt:SI (match_dup 4)\n+\t\t\t\t(match_dup 5)))\n+\t      (clobber (scratch:QI))])\n+   (set (cc0)\n+\t(match_dup 4))\n+   (set (pc)\n+\t(if_then_else (match_dup 6)\n+\t\t      (label_ref (match_dup 3))\n+\t\t      (pc)))]\n+{\n+  operands[5] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n+  operands[6] = gen_rtx_fmt_ee (GET_CODE (operands[2]) == GTU ? NE : EQ,\n+\t\t\t\tVOIDmode,\n+\t\t\t\tcc0_rtx,\n+\t\t\t\tconst0_rtx);\n+})\n \n ;; Transform\n ;;\n@@ -4567,22 +4640,10 @@\n    (set (cc0)\n \t(match_dup 0))\n    (set (pc)\n-\t(if_then_else (match_dup 5)\n+\t(if_then_else (match_dup 2)\n \t\t      (label_ref (match_dup 3))\n \t\t      (pc)))]\n-  \"switch (GET_CODE (operands[2]))\n-     {\n-     case GTU:\n-       operands[5] = gen_rtx_NE (VOIDmode, cc0_rtx, const0_rtx);\n-       break;\n-     case LEU:\n-       operands[5] = gen_rtx_EQ (VOIDmode, cc0_rtx, const0_rtx);\n-       break;\n-     default:\n-       operands[5] = operands[2];\n-       break;\n-     }\n-   operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\")\n+  \"operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\")\n \n ;; Transform\n ;;\n@@ -4594,7 +4655,36 @@\n ;;\tshar.l\ter0\n ;;\tbne\t.L1\n \n-;; TODO: Split the above peephole2.\n+(define_peephole2\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 2 \"gtuleu_operator\"\n+\t\t\t[(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"(TARGET_H8300H || TARGET_H8300S)\n+   && peep2_reg_dead_p (1, operands[0])\n+   && (INTVAL (operands[1]) == 1\n+\t|| (TARGET_H8300S && INTVAL (operands[1]) == 3))\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ashiftrt:SI (match_dup 0)\n+\t\t\t\t(match_dup 4)))\n+\t      (clobber (scratch:QI))])\n+   (set (cc0)\n+\t(match_dup 0))\n+   (set (pc)\n+\t(if_then_else (match_dup 5)\n+\t\t      (label_ref (match_dup 3))\n+\t\t      (pc)))]\n+{\n+  operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));\n+  operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[2]) == GTU ? NE : EQ,\n+\t\t\t\tVOIDmode,\n+\t\t\t\tcc0_rtx,\n+\t\t\t\tconst0_rtx);\n+})\n \n ;; Transform\n ;;\n@@ -4631,22 +4721,10 @@\n    (set (cc0)\n \t(match_dup 0))\n    (set (pc)\n-\t(if_then_else (match_dup 5)\n+\t(if_then_else (match_dup 2)\n \t\t      (label_ref (match_dup 3))\n \t\t      (pc)))]\n-  \"switch (GET_CODE (operands[2]))\n-     {\n-     case GTU:\n-       operands[5] = gen_rtx_NE (VOIDmode, cc0_rtx, const0_rtx);\n-       break;\n-     case LEU:\n-       operands[5] = gen_rtx_EQ (VOIDmode, cc0_rtx, const0_rtx);\n-       break;\n-     default:\n-       operands[5] = operands[2];\n-       break;\n-     }\n-   operands[4] = GEN_INT (~INTVAL (operands[1]));\")\n+  \"operands[4] = GEN_INT (~INTVAL (operands[1]));\")\n \n ;; Transform\n ;;\n@@ -4659,7 +4737,40 @@\n ;;\tmov.l\ter0,er0\n ;;\tbne\t.L1\n \n-;; TODO: Split the above peephole2.\n+(define_peephole2\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t (match_operand:SI 1 \"const_int_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (match_operator 2 \"gtuleu_operator\"\n+\t\t\t[(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"(TARGET_H8300H || TARGET_H8300S)\n+   && peep2_reg_dead_p (1, operands[0])\n+   && ((TARGET_H8300H && INTVAL (operands[1]) == 3)\n+       || INTVAL (operands[1]) == 7\n+       || INTVAL (operands[1]) == 15\n+       || INTVAL (operands[1]) == 31\n+       || INTVAL (operands[1]) == 63\n+       || INTVAL (operands[1]) == 127\n+       || INTVAL (operands[1]) == 255)\"\n+  [(set (match_dup 0)\n+\t(and:SI (match_dup 0)\n+\t\t(match_dup 4)))\n+   (set (cc0)\n+\t(match_dup 0))\n+   (set (pc)\n+\t(if_then_else (match_dup 5)\n+\t\t      (label_ref (match_dup 3))\n+\t\t      (pc)))]\n+{\n+  operands[4] = GEN_INT (~INTVAL (operands[1]));\n+  operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[2]) == GTU ? NE : EQ,\n+\t\t\t\tVOIDmode,\n+\t\t\t\tcc0_rtx,\n+\t\t\t\tconst0_rtx);\n+})\n \n ;; Transform\n ;;\n@@ -4685,21 +4796,10 @@\n \t(and:SI (match_dup 0)\n \t\t(const_int -65536)))\n    (set (pc)\n-\t(if_then_else (match_dup 3)\n+\t(if_then_else (match_dup 1)\n \t\t      (label_ref (match_dup 2))\n \t\t      (pc)))]\n-  \"switch (GET_CODE (operands[1]))\n-     {\n-     case GTU:\n-       operands[3] = gen_rtx_NE (VOIDmode, cc0_rtx, const0_rtx);\n-       break;\n-     case LEU:\n-       operands[3] = gen_rtx_EQ (VOIDmode, cc0_rtx, const0_rtx);\n-       break;\n-     default:\n-       operands[3] = operands[1];\n-       break;\n-     }\")\n+  \"\")\n \n ;; Transform\n ;;\n@@ -4711,7 +4811,29 @@\n ;;\tmov.l\te0,e0\n ;;\tbne\t.L1\n \n-;; TODO: Split the above peephole2.\n+(define_peephole2\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t (const_int 65535)))\n+   (set (pc)\n+\t(if_then_else (match_operator 1 \"gtuleu_operator\"\n+\t\t\t[(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_H8300H || TARGET_H8300S\"\n+  [(set (cc0)\n+\t(and:SI (match_dup 0)\n+\t\t(const_int -65536)))\n+   (set (pc)\n+\t(if_then_else (match_dup 3)\n+\t\t      (label_ref (match_dup 2))\n+\t\t      (pc)))]\n+{\n+  operands[3] = gen_rtx_fmt_ee (GET_CODE (operands[1]) == GTU ? NE : EQ,\n+\t\t\t\tVOIDmode,\n+\t\t\t\tcc0_rtx,\n+\t\t\t\tconst0_rtx);\n+})\n \n ;; For constants like -1, -2, 1, 2, it is still cheaper to make a copy\n ;; of the register being tested, do the subtraction on the copy, and"}]}