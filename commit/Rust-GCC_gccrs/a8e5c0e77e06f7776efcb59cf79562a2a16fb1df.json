{"sha": "a8e5c0e77e06f7776efcb59cf79562a2a16fb1df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThlNWMwZTc3ZTA2Zjc3NzZlZmNiNTljZjc5NTYyYTJhMTZmYjFkZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-07-09T20:39:00Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-09T20:39:00Z"}, "message": "dwarf2cfi: Handle return column save from CIE.\n\nWhen we record a save of the return column in the CIE, remember\nthat while processing the FDE.  This requires propagating the\nhandling of PC_RTX as a representative of the return column to\nmore locations.\n\nMIPS had been handling this case by hand, and is no longer required.\n\n        * dwarf2cfi.c (cie_return_save): New.\n        (queue_reg_save): Use compare_reg_or_pc.\n        (dwarf2out_flush_queued_reg_saves): Handle pc_rtx as return column.\n        (dwarf2out_frame_debug_expr): Likewise.\n        (dwarf2out_frame_debug_cfa_register): Record saved reg for pc too.\n        (initial_return_save): Likewise.\n        (execute_dwarf2_frame): Save and restore initial return save from\n        the cie to the fde.\n        * config/mips/mips.c (mips_frame_set): Remove special case for\n        DWARF_FRAME_RETURN_COLUMN.\n\nFrom-SVN: r176099", "tree": {"sha": "b273c934da93c7ba2fcdf8ed23a51aca37b5171b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b273c934da93c7ba2fcdf8ed23a51aca37b5171b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8e5c0e77e06f7776efcb59cf79562a2a16fb1df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8e5c0e77e06f7776efcb59cf79562a2a16fb1df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8e5c0e77e06f7776efcb59cf79562a2a16fb1df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8e5c0e77e06f7776efcb59cf79562a2a16fb1df/comments", "author": null, "committer": null, "parents": [{"sha": "4a8ee1224175358105056d64a611443680257a2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a8ee1224175358105056d64a611443680257a2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a8ee1224175358105056d64a611443680257a2e"}], "stats": {"total": 242, "additions": 139, "deletions": 103}, "files": [{"sha": "bf10d3d361c475c70fa0af9940cd75464c9b33ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8e5c0e77e06f7776efcb59cf79562a2a16fb1df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8e5c0e77e06f7776efcb59cf79562a2a16fb1df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a8e5c0e77e06f7776efcb59cf79562a2a16fb1df", "patch": "@@ -1,3 +1,16 @@\n+2011-07-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2cfi.c (cie_return_save): New.\n+\t(queue_reg_save): Use compare_reg_or_pc.\n+\t(dwarf2out_flush_queued_reg_saves): Handle pc_rtx as return column.\n+\t(dwarf2out_frame_debug_expr): Likewise.\n+\t(dwarf2out_frame_debug_cfa_register): Record saved reg for pc too.\n+\t(initial_return_save): Likewise.\n+\t(execute_dwarf2_frame): Save and restore initial return save from\n+\tthe cie to the fde.\n+\t* config/mips/mips.c (mips_frame_set): Remove special case for\n+\tDWARF_FRAME_RETURN_COLUMN.\n+\n 2011-07-09  Richard Henderson  <rth@redhat.com>\n \n \t* dwarf2cfi.c (lookup_cfa): Remove."}, {"sha": "ee71c4040c7064f9804743298bd1221024f640db", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8e5c0e77e06f7776efcb59cf79562a2a16fb1df/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8e5c0e77e06f7776efcb59cf79562a2a16fb1df/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=a8e5c0e77e06f7776efcb59cf79562a2a16fb1df", "patch": "@@ -8203,13 +8203,6 @@ mips_frame_set (rtx mem, rtx reg)\n {\n   rtx set;\n \n-  /* If we're saving the return address register and the DWARF return\n-     address column differs from the hard register number, adjust the\n-     note reg to refer to the former.  */\n-  if (REGNO (reg) == RETURN_ADDR_REGNUM\n-      && DWARF_FRAME_RETURN_COLUMN != RETURN_ADDR_REGNUM)\n-    reg = gen_rtx_REG (GET_MODE (reg), DWARF_FRAME_RETURN_COLUMN);\n-\n   set = gen_rtx_SET (VOIDmode, mem, reg);\n   RTX_FRAME_RELATED_P (set) = 1;\n "}, {"sha": "5b76df359f4256ca21aa3ee0c02caf3c6d4feb25", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 126, "deletions": 96, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8e5c0e77e06f7776efcb59cf79562a2a16fb1df/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8e5c0e77e06f7776efcb59cf79562a2a16fb1df/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=a8e5c0e77e06f7776efcb59cf79562a2a16fb1df", "patch": "@@ -603,64 +603,6 @@ reg_save (unsigned int reg, unsigned int sreg, HOST_WIDE_INT offset)\n   add_cfi (cfi);\n }\n \n-/* Record the initial position of the return address.  RTL is\n-   INCOMING_RETURN_ADDR_RTX.  */\n-\n-static void\n-initial_return_save (rtx rtl)\n-{\n-  unsigned int reg = INVALID_REGNUM;\n-  HOST_WIDE_INT offset = 0;\n-\n-  switch (GET_CODE (rtl))\n-    {\n-    case REG:\n-      /* RA is in a register.  */\n-      reg = DWARF_FRAME_REGNUM (REGNO (rtl));\n-      break;\n-\n-    case MEM:\n-      /* RA is on the stack.  */\n-      rtl = XEXP (rtl, 0);\n-      switch (GET_CODE (rtl))\n-\t{\n-\tcase REG:\n-\t  gcc_assert (REGNO (rtl) == STACK_POINTER_REGNUM);\n-\t  offset = 0;\n-\t  break;\n-\n-\tcase PLUS:\n-\t  gcc_assert (REGNO (XEXP (rtl, 0)) == STACK_POINTER_REGNUM);\n-\t  offset = INTVAL (XEXP (rtl, 1));\n-\t  break;\n-\n-\tcase MINUS:\n-\t  gcc_assert (REGNO (XEXP (rtl, 0)) == STACK_POINTER_REGNUM);\n-\t  offset = -INTVAL (XEXP (rtl, 1));\n-\t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-\n-      break;\n-\n-    case PLUS:\n-      /* The return address is at some offset from any value we can\n-\t actually load.  For instance, on the SPARC it is in %i7+8. Just\n-\t ignore the offset for now; it doesn't matter for unwinding frames.  */\n-      gcc_assert (CONST_INT_P (XEXP (rtl, 1)));\n-      initial_return_save (XEXP (rtl, 0));\n-      return;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  if (reg != DWARF_FRAME_RETURN_COLUMN)\n-    reg_save (DWARF_FRAME_RETURN_COLUMN, reg, offset - cfa.offset);\n-}\n-\n /* Given a SET, calculate the amount of stack adjustment it\n    contains.  */\n \n@@ -1088,6 +1030,8 @@ DEF_VEC_ALLOC_O (reg_saved_in_data, gc);\n    5 entries.  */\n static GTY(()) VEC(reg_saved_in_data, gc) *regs_saved_in_regs;\n \n+static GTY(()) reg_saved_in_data *cie_return_save;\n+\n /* Compare X and Y for equivalence.  The inputs may be REGs or PC_RTX.  */\n \n static bool\n@@ -1134,10 +1078,9 @@ queue_reg_save (rtx reg, rtx sreg, HOST_WIDE_INT offset)\n   struct queued_reg_save *q;\n \n   /* Duplicates waste space, but it's also necessary to remove them\n-     for correctness, since the queue gets output in reverse\n-     order.  */\n+     for correctness, since the queue gets output in reverse order.  */\n   for (q = queued_reg_saves; q != NULL; q = q->next)\n-    if (REGNO (q->reg) == REGNO (reg))\n+    if (compare_reg_or_pc (q->reg, reg))\n       break;\n \n   if (q == NULL)\n@@ -1165,7 +1108,10 @@ dwarf2out_flush_queued_reg_saves (void)\n \n       record_reg_saved_in_reg (q->saved_reg, q->reg);\n \n-      reg = DWARF_FRAME_REGNUM (REGNO (q->reg));\n+      if (q->reg == pc_rtx)\n+\treg = DWARF_FRAME_RETURN_COLUMN;\n+      else\n+        reg = DWARF_FRAME_REGNUM (REGNO (q->reg));\n       if (q->saved_reg)\n \tsreg = DWARF_FRAME_REGNUM (REGNO (q->saved_reg));\n       else\n@@ -1375,13 +1321,11 @@ dwarf2out_frame_debug_cfa_register (rtx set)\n   src = XEXP (set, 1);\n   dest = XEXP (set, 0);\n \n+  record_reg_saved_in_reg (dest, src);\n   if (src == pc_rtx)\n     sregno = DWARF_FRAME_RETURN_COLUMN;\n   else\n-    {\n-      record_reg_saved_in_reg (dest, src);\n-      sregno = DWARF_FRAME_REGNUM (REGNO (src));\n-    }\n+    sregno = DWARF_FRAME_REGNUM (REGNO (src));\n \n   dregno = DWARF_FRAME_REGNUM (REGNO (dest));\n \n@@ -2031,14 +1975,14 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t  gcc_unreachable ();\n \t}\n \n-        /* Rule 17 */\n-        /* If the source operand of this MEM operation is not a\n-\t   register, basically the source is return address.  Here\n-\t   we only care how much stack grew and we don't save it.  */\n-      if (!REG_P (src))\n+      /* Rule 17 */\n+      /* If the source operand of this MEM operation is a memory,\n+\t we only care how much stack grew.  */\n+      if (MEM_P (src))\n         break;\n \n-      if (REGNO (src) != STACK_POINTER_REGNUM\n+      if (REG_P (src)\n+\t  && REGNO (src) != STACK_POINTER_REGNUM\n \t  && REGNO (src) != HARD_FRAME_POINTER_REGNUM\n \t  && (unsigned) REGNO (src) == cfa.reg)\n \t{\n@@ -2098,32 +2042,30 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t}\n \n       def_cfa_1 (&cfa);\n-      {\n-\tspan = targetm.dwarf_register_span (src);\n \n-\tif (!span)\n-\t  queue_reg_save (src, NULL_RTX, offset);\n-\telse\n-\t  {\n-\t    /* We have a PARALLEL describing where the contents of SRC\n-\t       live.  Queue register saves for each piece of the\n-\t       PARALLEL.  */\n-\t    int par_index;\n-\t    int limit;\n-\t    HOST_WIDE_INT span_offset = offset;\n-\n-\t    gcc_assert (GET_CODE (span) == PARALLEL);\n+      span = NULL;\n+      if (REG_P (src))\n+\tspan = targetm.dwarf_register_span (src);\n+      if (!span)\n+\tqueue_reg_save (src, NULL_RTX, offset);\n+      else\n+\t{\n+\t  /* We have a PARALLEL describing where the contents of SRC live.\n+\t     Queue register saves for each piece of the PARALLEL.  */\n+\t  int par_index;\n+\t  int limit;\n+\t  HOST_WIDE_INT span_offset = offset;\n \n-\t    limit = XVECLEN (span, 0);\n-\t    for (par_index = 0; par_index < limit; par_index++)\n-\t      {\n-\t\trtx elem = XVECEXP (span, 0, par_index);\n+\t  gcc_assert (GET_CODE (span) == PARALLEL);\n \n-\t\tqueue_reg_save (elem, NULL_RTX, span_offset);\n-\t\tspan_offset += GET_MODE_SIZE (GET_MODE (elem));\n-\t      }\n-\t  }\n-      }\n+\t  limit = XVECLEN (span, 0);\n+\t  for (par_index = 0; par_index < limit; par_index++)\n+\t    {\n+\t      rtx elem = XVECEXP (span, 0, par_index);\n+\t      queue_reg_save (elem, NULL_RTX, span_offset);\n+\t      span_offset += GET_MODE_SIZE (GET_MODE (elem));\n+\t    }\n+\t}\n       break;\n \n     default:\n@@ -2543,6 +2485,67 @@ dwarf2out_frame_debug_restore_state (void)\n   cfa_remember.in_use = 0;\n }\n \f\n+/* Record the initial position of the return address.  RTL is\n+   INCOMING_RETURN_ADDR_RTX.  */\n+\n+static void\n+initial_return_save (rtx rtl)\n+{\n+  unsigned int reg = INVALID_REGNUM;\n+  HOST_WIDE_INT offset = 0;\n+\n+  switch (GET_CODE (rtl))\n+    {\n+    case REG:\n+      /* RA is in a register.  */\n+      reg = DWARF_FRAME_REGNUM (REGNO (rtl));\n+      break;\n+\n+    case MEM:\n+      /* RA is on the stack.  */\n+      rtl = XEXP (rtl, 0);\n+      switch (GET_CODE (rtl))\n+\t{\n+\tcase REG:\n+\t  gcc_assert (REGNO (rtl) == STACK_POINTER_REGNUM);\n+\t  offset = 0;\n+\t  break;\n+\n+\tcase PLUS:\n+\t  gcc_assert (REGNO (XEXP (rtl, 0)) == STACK_POINTER_REGNUM);\n+\t  offset = INTVAL (XEXP (rtl, 1));\n+\t  break;\n+\n+\tcase MINUS:\n+\t  gcc_assert (REGNO (XEXP (rtl, 0)) == STACK_POINTER_REGNUM);\n+\t  offset = -INTVAL (XEXP (rtl, 1));\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      break;\n+\n+    case PLUS:\n+      /* The return address is at some offset from any value we can\n+\t actually load.  For instance, on the SPARC it is in %i7+8. Just\n+\t ignore the offset for now; it doesn't matter for unwinding frames.  */\n+      gcc_assert (CONST_INT_P (XEXP (rtl, 1)));\n+      initial_return_save (XEXP (rtl, 0));\n+      return;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (reg != DWARF_FRAME_RETURN_COLUMN)\n+    {\n+      if (reg != INVALID_REGNUM)\n+        record_reg_saved_in_reg (rtl, pc_rtx);\n+      reg_save (DWARF_FRAME_RETURN_COLUMN, reg, offset - cfa.offset);\n+    }\n+}\n \n /* Annotate the function with NOTE_INSN_CFI notes to record the CFI\n    state at each location within the function.  These notes will be\n@@ -2569,7 +2572,31 @@ execute_dwarf2_frame (void)\n \n       if (targetm.debug_unwind_info () == UI_DWARF2\n           || targetm_common.except_unwind_info (&global_options) == UI_DWARF2)\n-\tinitial_return_save (INCOMING_RETURN_ADDR_RTX);\n+\t{\n+\t  initial_return_save (INCOMING_RETURN_ADDR_RTX);\n+\n+\t  /* For a few targets, we have the return address incoming into a\n+\t     register, but choose a different return column.  This will result\n+\t     in a DW_CFA_register for the return, and an entry in\n+\t     regs_saved_in_regs to match.  If the target later stores that\n+\t     return address register to the stack, we want to be able to emit\n+\t     the DW_CFA_offset against the return column, not the intermediate\n+\t     save register.  Save the contents of regs_saved_in_regs so that\n+\t     we can re-initialize it at the start of each function.  */\n+\t  switch (VEC_length (reg_saved_in_data, regs_saved_in_regs))\n+\t    {\n+\t    case 0:\n+\t      break;\n+\t    case 1:\n+\t      cie_return_save = ggc_alloc_reg_saved_in_data ();\n+\t      *cie_return_save = *VEC_index (reg_saved_in_data,\n+\t\t\t\t\t     regs_saved_in_regs, 0);\n+\t      regs_saved_in_regs = NULL;\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n \n       add_cfi_vec = NULL;\n     }\n@@ -2588,6 +2615,9 @@ execute_dwarf2_frame (void)\n   memset (&cfa_temp, 0, sizeof(cfa_temp));\n   cfa_temp.reg = INVALID_REGNUM;\n \n+  if (cie_return_save)\n+    VEC_safe_push (reg_saved_in_data, gc, regs_saved_in_regs, cie_return_save);\n+\n   dwarf2out_alloc_current_fde ();\n \n   /* Do the work.  */"}]}