{"sha": "46b2c44027f8972329b6f602b57c9fdf1a8e4007", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZiMmM0NDAyN2Y4OTcyMzI5YjZmNjAyYjU3YzlmZGYxYThlNDAwNw==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-02-23T22:38:27Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-02-23T22:38:27Z"}, "message": "re PR fortran/40850 (double free in nested types with allocatable components)\n\n2011-02-23  Mikael Morin  <mikael@gcc.gnu.org>\n\n\tPR fortran/40850\n\t* trans.c (gfc_prepend_expr_to_block): New function.\n\t* trans.h (gfc_prepend_expr_to_block): Declare.\n\t* trans-array.c (gfc_conv_array_parameter): Replace\n\tgfc_add_expr_to_block with gfc_prepend_expr_to_block.\n\n2011-02-23  Mikael Morin  <mikael@gcc.gnu.org>\n\n\tPR fortran/40850\n\t* gfortran.dg/nested_allocatables_1.f90: New.\n\nFrom-SVN: r170445", "tree": {"sha": "a4e7cb1e664ed6ae2b86798290fd00e26da7d19c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4e7cb1e664ed6ae2b86798290fd00e26da7d19c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46b2c44027f8972329b6f602b57c9fdf1a8e4007", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46b2c44027f8972329b6f602b57c9fdf1a8e4007", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46b2c44027f8972329b6f602b57c9fdf1a8e4007", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46b2c44027f8972329b6f602b57c9fdf1a8e4007/comments", "author": null, "committer": null, "parents": [{"sha": "b14fad9dd817fb6f5bd33573a530e7e41131ee0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b14fad9dd817fb6f5bd33573a530e7e41131ee0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b14fad9dd817fb6f5bd33573a530e7e41131ee0c"}], "stats": {"total": 63, "additions": 59, "deletions": 4}, "files": [{"sha": "96c5411e92224623a6bc70334b509c5ecb8b41da", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b2c44027f8972329b6f602b57c9fdf1a8e4007/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b2c44027f8972329b6f602b57c9fdf1a8e4007/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=46b2c44027f8972329b6f602b57c9fdf1a8e4007", "patch": "@@ -1,3 +1,11 @@\n+2011-02-23  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/40850\n+\t* trans.c (gfc_prepend_expr_to_block): New function.\n+\t* trans.h (gfc_prepend_expr_to_block): Declare.\n+\t* trans-array.c (gfc_conv_array_parameter): Replace\n+\tgfc_add_expr_to_block with gfc_prepend_expr_to_block.\n+\n 2011-02-22  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/45743"}, {"sha": "ac08c42c94436a91a78dbe65271d1f7220af705b", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b2c44027f8972329b6f602b57c9fdf1a8e4007/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b2c44027f8972329b6f602b57c9fdf1a8e4007/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=46b2c44027f8972329b6f602b57c9fdf1a8e4007", "patch": "@@ -6097,10 +6097,11 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n \t&& expr->ts.u.derived->attr.alloc_comp\n \t&& expr->expr_type != EXPR_VARIABLE)\n     {\n-      tmp = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t     se->expr);\n+      tmp = build_fold_indirect_ref_loc (input_location, se->expr);\n       tmp = gfc_deallocate_alloc_comp (expr->ts.u.derived, tmp, expr->rank);\n-      gfc_add_expr_to_block (&se->post, tmp);\n+\n+      /* The components shall be deallocated before their containing entity.  */\n+      gfc_prepend_expr_to_block (&se->post, tmp);\n     }\n \n   if (g77 || (fsym && fsym->attr.contiguous"}, {"sha": "27a352ab3bd4f0a524c2abc6220ea6b55f11f811", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b2c44027f8972329b6f602b57c9fdf1a8e4007/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b2c44027f8972329b6f602b57c9fdf1a8e4007/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=46b2c44027f8972329b6f602b57c9fdf1a8e4007", "patch": "@@ -1090,7 +1090,8 @@ add_expr_to_chain (tree* chain, tree expr, bool front)\n     *chain = expr;\n }\n \n-/* Add a statement to a block.  */\n+\n+/* Add a statement at the end of a block.  */\n \n void\n gfc_add_expr_to_block (stmtblock_t * block, tree expr)\n@@ -1100,6 +1101,16 @@ gfc_add_expr_to_block (stmtblock_t * block, tree expr)\n }\n \n \n+/* Add a statement at the beginning of a block.  */\n+\n+void\n+gfc_prepend_expr_to_block (stmtblock_t * block, tree expr)\n+{\n+  gcc_assert (block);\n+  add_expr_to_chain (&block->head, expr, true);\n+}\n+\n+\n /* Add a block the end of a block.  */\n \n void"}, {"sha": "1536f2e806a1abb885aa5f563b72b9e0781c7245", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b2c44027f8972329b6f602b57c9fdf1a8e4007/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b2c44027f8972329b6f602b57c9fdf1a8e4007/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=46b2c44027f8972329b6f602b57c9fdf1a8e4007", "patch": "@@ -396,6 +396,8 @@ void gfc_trans_vla_type_sizes (gfc_symbol *, stmtblock_t *);\n \n /* Add an expression to the end of a block.  */\n void gfc_add_expr_to_block (stmtblock_t *, tree);\n+/* Add an expression to the beginning of a block.  */\n+void gfc_prepend_expr_to_block (stmtblock_t *, tree);\n /* Add a block to the end of a block.  */\n void gfc_add_block_to_block (stmtblock_t *, stmtblock_t *);\n /* Add a MODIFY_EXPR to a block.  */"}, {"sha": "b2abbe7096159a124993aa4b8be77d3ce83ec1ee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b2c44027f8972329b6f602b57c9fdf1a8e4007/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b2c44027f8972329b6f602b57c9fdf1a8e4007/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=46b2c44027f8972329b6f602b57c9fdf1a8e4007", "patch": "@@ -1,3 +1,8 @@\n+2011-02-23  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/40850\n+\t* gfortran.dg/nested_allocatables_1.f90: New.\n+\n 2011-02-23  Nathan Froyd  <froydnj@codesourcery.com>\n \n \tPR c++/46868"}, {"sha": "607a883b707a501120ad15f00317c6716d2f9d7f", "filename": "gcc/testsuite/gfortran.dg/nested_allocatables_1.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b2c44027f8972329b6f602b57c9fdf1a8e4007/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_allocatables_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b2c44027f8972329b6f602b57c9fdf1a8e4007/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_allocatables_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_allocatables_1.f90?ref=46b2c44027f8972329b6f602b57c9fdf1a8e4007", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do run }\n+!\n+! PR fortran/40850\n+! The code freeing allocatable components used to be put after the code\n+! freeing the containing entity.\n+!\n+! Original test case by Marco Restelli <mrestelli@gmail.com>\n+! Reduced by Daniel Franke <franke.daniel@gmail.com>\n+!        and Janus Weil <janus@gcc.gnu.org>\n+\n+\n+  type t\n+    integer, allocatable :: d(:)\n+  end type\n+  type(t), allocatable :: a(:)\n+\n+  ! Big enough to make it fail\n+  allocate(a(2 * 1024))\n+  call sub( (/ a /) )\n+\n+contains\n+\n+  subroutine sub(b)\n+    type(t) :: b(:)\n+  end subroutine\n+\n+end\n+"}]}