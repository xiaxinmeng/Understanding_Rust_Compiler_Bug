{"sha": "4a52eb194ce8a5c9086dbc269210d17430ce706e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE1MmViMTk0Y2U4YTVjOTA4NmRiYzI2OTIxMGQxNzQzMGNlNzA2ZQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-07-05T12:05:44Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-07-05T12:05:44Z"}, "message": "tree-loop-distribution.c (classify_partition): New parameter and better handle reduction statement.\n\n\t* tree-loop-distribution.c (classify_partition): New parameter and\n\tbetter handle reduction statement.\n\t(rdg_build_partitions): Revise comment.\n\t(distribute_loop): Compute statements in all partitions and pass it\n\tto classify_partition.\n\n\tgcc/testsuite\n\t* gcc.dg/tree-ssa/ldist-26.c: New test.\n\nFrom-SVN: r249993", "tree": {"sha": "cee4541aeccab4712ded26aec851773e6ce019c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cee4541aeccab4712ded26aec851773e6ce019c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a52eb194ce8a5c9086dbc269210d17430ce706e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a52eb194ce8a5c9086dbc269210d17430ce706e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a52eb194ce8a5c9086dbc269210d17430ce706e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a52eb194ce8a5c9086dbc269210d17430ce706e/comments", "author": null, "committer": null, "parents": [{"sha": "f1eb462193ff08532934a78671c5b721fd504169", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1eb462193ff08532934a78671c5b721fd504169", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1eb462193ff08532934a78671c5b721fd504169"}], "stats": {"total": 91, "additions": 80, "deletions": 11}, "files": [{"sha": "0b1e653ffa19474ba47de0f29c73ce3cda87cf93", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a52eb194ce8a5c9086dbc269210d17430ce706e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a52eb194ce8a5c9086dbc269210d17430ce706e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a52eb194ce8a5c9086dbc269210d17430ce706e", "patch": "@@ -1,3 +1,11 @@\n+2017-07-05  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-loop-distribution.c (classify_partition): New parameter and\n+\tbetter handle reduction statement.\n+\t(rdg_build_partitions): Revise comment.\n+\t(distribute_loop): Compute statements in all partitions and pass it\n+\tto classify_partition.\n+\n 2017-07-05  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-loop-distribution.c (enum partition_type): New."}, {"sha": "4dbfcc3ae798f6e6afabae23c6262ed3950b82a8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a52eb194ce8a5c9086dbc269210d17430ce706e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a52eb194ce8a5c9086dbc269210d17430ce706e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4a52eb194ce8a5c9086dbc269210d17430ce706e", "patch": "@@ -1,3 +1,7 @@\n+2017-07-05  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.dg/tree-ssa/ldist-26.c: New test.\n+\n 2017-07-05  Bin Cheng  <bin.cheng@arm.com>\n \n \t* gcc.dg/tree-ssa/ldist-6.c: XFAIL."}, {"sha": "3a698846c89bacc9fb53522b2646bd7e7e329dd8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-26.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a52eb194ce8a5c9086dbc269210d17430ce706e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a52eb194ce8a5c9086dbc269210d17430ce706e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-26.c?ref=4a52eb194ce8a5c9086dbc269210d17430ce706e", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -ftree-loop-distribution -fdump-tree-ldist-details\" } */\n+\n+extern void abort (void);\n+\n+int a[130], b[128], c[128];\n+\n+int __attribute__((noinline,noclone))\n+foo (int len, int x)\n+{\n+  int i;\n+  for (i = 1; i <= len; ++i)\n+    {\n+      a[i] = a[i + 2] + 1;\n+      b[i] = 0;\n+      a[i + 1] = a[i] - 3;\n+      if (i < x)\n+\tc[i] = a[i];\n+    }\n+  return i;\n+}\n+\n+int main()\n+{\n+  int i;\n+  for (i = 0; i < 130; ++i)\n+    a[i] = i;\n+  foo (127, 67);\n+  if (a[0] != 0 || a[1] != 4 || a[127] != 130)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"distributed: split to 2 loops and 0 library calls\" \"ldist\" } } */\n+/* { dg-final { scan-tree-dump \"distributed: split to 1 loops and 1 library calls\" \"ldist\" } } */\n+/* { dg-final { scan-tree-dump \"generated memset zero\" \"ldist\" } } */"}, {"sha": "b15ec045521193b4dee0fc6e627ae322baa617f7", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a52eb194ce8a5c9086dbc269210d17430ce706e/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a52eb194ce8a5c9086dbc269210d17430ce706e/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=4a52eb194ce8a5c9086dbc269210d17430ce706e", "patch": "@@ -1254,17 +1254,18 @@ build_rdg_partition_for_vertex (struct graph *rdg, int v)\n }\n \n /* Classifies the builtin kind we can generate for PARTITION of RDG and LOOP.\n-   For the moment we detect only the memset zero pattern.  */\n+   For the moment we detect memset, memcpy and memmove patterns.  Bitmap\n+   STMT_IN_ALL_PARTITIONS contains statements belonging to all partitions.  */\n \n static void\n-classify_partition (loop_p loop, struct graph *rdg, partition *partition)\n+classify_partition (loop_p loop, struct graph *rdg, partition *partition,\n+\t\t    bitmap stmt_in_all_partitions)\n {\n   bitmap_iterator bi;\n   unsigned i;\n   tree nb_iter;\n   data_reference_p single_load, single_store;\n-  bool volatiles_p = false;\n-  bool plus_one = false;\n+  bool volatiles_p = false, plus_one = false, has_reduction = false;\n \n   partition->kind = PKIND_NORMAL;\n   partition->main_dr = NULL;\n@@ -1279,16 +1280,31 @@ classify_partition (loop_p loop, struct graph *rdg, partition *partition)\n       if (gimple_has_volatile_ops (stmt))\n \tvolatiles_p = true;\n \n-      /* If the stmt has uses outside of the loop mark it as reduction.  */\n+      /* If the stmt is not included by all partitions and there is uses\n+\t outside of the loop, then mark the partition as reduction.  */\n       if (stmt_has_scalar_dependences_outside_loop (loop, stmt))\n \t{\n-\t  partition->reduction_p = true;\n-\t  return;\n+\t  /* Due to limitation in the transform phase we have to fuse all\n+\t     reduction partitions.  As a result, this could cancel valid\n+\t     loop distribution especially for loop that induction variable\n+\t     is used outside of loop.  To workaround this issue, we skip\n+\t     marking partition as reudction if the reduction stmt belongs\n+\t     to all partitions.  In such case, reduction will be computed\n+\t     correctly no matter how partitions are fused/distributed.  */\n+\t  if (!bitmap_bit_p (stmt_in_all_partitions, i))\n+\t    {\n+\t      partition->reduction_p = true;\n+\t      return;\n+\t    }\n+\t  has_reduction = true;\n \t}\n     }\n \n   /* Perform general partition disqualification for builtins.  */\n   if (volatiles_p\n+      /* Simple workaround to prevent classifying the partition as builtin\n+\t if it contains any use outside of loop.  */\n+      || has_reduction\n       || !flag_tree_loop_distribute_patterns)\n     return;\n \n@@ -1461,9 +1477,9 @@ share_memory_accesses (struct graph *rdg,\n   return false;\n }\n \n-/* Aggregate several components into a useful partition that is\n-   registered in the PARTITIONS vector.  Partitions will be\n-   distributed in different loops.  */\n+/* For each seed statement in STARTING_STMTS, this function builds\n+   partition for it by adding depended statements according to RDG.\n+   All partitions are recorded in PARTITIONS.  */\n \n static void\n rdg_build_partitions (struct graph *rdg,\n@@ -1731,10 +1747,15 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n   auto_vec<struct partition *, 3> partitions;\n   rdg_build_partitions (rdg, stmts, &partitions);\n \n+  auto_bitmap stmt_in_all_partitions;\n+  bitmap_copy (stmt_in_all_partitions, partitions[0]->stmts);\n+  for (i = 1; partitions.iterate (i, &partition); ++i)\n+    bitmap_and_into (stmt_in_all_partitions, partitions[i]->stmts);\n+\n   any_builtin = false;\n   FOR_EACH_VEC_ELT (partitions, i, partition)\n     {\n-      classify_partition (loop, rdg, partition);\n+      classify_partition (loop, rdg, partition, stmt_in_all_partitions);\n       any_builtin |= partition_builtin_p (partition);\n     }\n "}]}