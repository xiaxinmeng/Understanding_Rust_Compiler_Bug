{"sha": "6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZjMGJiOTlhN2QwZmNlZGQxYjM0NWRhMTRkNGRkMTY5MjZiNTQ1OA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2006-05-28T17:46:46Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2006-05-28T17:46:46Z"}, "message": "cfgcleanup.c, [...]: Fix comment typos.\n\n\t* cfgcleanup.c, cfgexpand.c, cgraphunit.c, config/arm/arm.c,\n\tconfig/fr30/fr30.md, config/i386/i386-interix.h,\n\tconfig/i386/i386.c, config/i386/i386.md, config/sh/superh.h,\n\tconfig/sh/superh64.h, config/v850/v850.c, df-core.c,\n\tdf-problems.c, df.h, except.c, final.c, haifa-sched.c,\n\tlambda-code.c, libgcc2.h, omp-low.c, optabs.c, predict.c,\n\treload.c, tree-flow.h, tree-outof-ssa.c, tree-ssa-dce.c,\n\ttree-ssa-pre.c, tree-vect-transform.c: Fix comment typos.\n\tFollow spelling conventions.\n\t* doc/invoke.texi, doc/rtl.texi, doc/tm.texi: Fix typos.\n\tFollow spelling conventions.\n\nFrom-SVN: r114168", "tree": {"sha": "bfad2d717d3d9605e8fb4c3cba410dc93fdf4df4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfad2d717d3d9605e8fb4c3cba410dc93fdf4df4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/comments", "author": null, "committer": null, "parents": [{"sha": "8967e0295db5621216719a0ea9723774fba31977", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8967e0295db5621216719a0ea9723774fba31977", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8967e0295db5621216719a0ea9723774fba31977"}], "stats": {"total": 94, "additions": 54, "deletions": 40}, "files": [{"sha": "ca0be8b54d74ce721572a9d6bdb378ac5b19f7b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -1,3 +1,17 @@\n+2006-05-28  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* cfgcleanup.c, cfgexpand.c, cgraphunit.c, config/arm/arm.c,\n+\tconfig/fr30/fr30.md, config/i386/i386-interix.h,\n+\tconfig/i386/i386.c, config/i386/i386.md, config/sh/superh.h,\n+\tconfig/sh/superh64.h, config/v850/v850.c, df-core.c,\n+\tdf-problems.c, df.h, except.c, final.c, haifa-sched.c,\n+\tlambda-code.c, libgcc2.h, omp-low.c, optabs.c, predict.c,\n+\treload.c, tree-flow.h, tree-outof-ssa.c, tree-ssa-dce.c,\n+\ttree-ssa-pre.c, tree-vect-transform.c: Fix comment typos.\n+\tFollow spelling conventions.\n+\t* doc/invoke.texi, doc/rtl.texi, doc/tm.texi: Fix typos.\n+\tFollow spelling conventions.\n+\n 2006-05-27  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/27773"}, {"sha": "0e13f7a07cf83430b08b0cf2160efef9820d2fef", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -1733,7 +1733,7 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n \n   redirect_to->count += src1->count;\n   redirect_to->frequency += src1->frequency;\n-  /* We may have some registers visible trought the block.  */\n+  /* We may have some registers visible through the block.  */\n   redirect_to->flags |= BB_DIRTY;\n \n   /* Recompute the frequencies and counts of outgoing edges.  */"}, {"sha": "941cdad86810a0c262392fd10a960b5f1958999d", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -764,7 +764,7 @@ expand_used_vars_for_block (tree block, bool toplevel)\n     expand_used_vars_for_block (t, false);\n \n   /* Since we do not track exact variable lifetimes (which is not even\n-     possible for varibles whose address escapes), we mirror the block\n+     possible for variables whose address escapes), we mirror the block\n      tree in the interference graph.  Here we cause all variables at this\n      level, and all sublevels, to conflict.  Do make certain that a\n      variable conflicts with itself.  */"}, {"sha": "33028b2f331a693ccc97eb14a610282976b1e317", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -222,7 +222,7 @@ decide_is_function_needed (struct cgraph_node *node, tree decl)\n      PR24561), but don't do so for always_inline functions, functions\n      declared inline and nested functions.  These was optimized out\n      in the original implementation and it is unclear whether we want\n-     to change the behaviour here.  */\n+     to change the behavior here.  */\n   if (((TREE_PUBLIC (decl)\n \t|| (!optimize && !node->local.disregard_inline_limits\n \t    && !DECL_DECLARED_INLINE_P (decl)"}, {"sha": "a26222a932b5ccd0f63759cf603c22d53ac25dc0", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -2802,7 +2802,7 @@ arm_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n /* Encode the current state of the #pragma [no_]long_calls.  */\n typedef enum\n {\n-  OFF,\t\t/* No #pramgma [no_]long_calls is in effect.  */\n+  OFF,\t\t/* No #pragma [no_]long_calls is in effect.  */\n   LONG,\t\t/* #pragma long_calls is in effect.  */\n   SHORT\t\t/* #pragma no_long_calls is in effect.  */\n } arm_pragma_enum;"}, {"sha": "c40a7097d6020daa0a9a2315446ddae1a19091f8", "filename": "gcc/config/fr30/fr30.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fconfig%2Ffr30%2Ffr30.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fconfig%2Ffr30%2Ffr30.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.md?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -35,7 +35,7 @@\n \n \n ;; Define an attribute to be used by the delay slot code.\n-;; An instruction by default is considered to be 'delyabable'\n+;; An instruction by default is considered to be 'delayable'\n ;; that is, it can be placed into a delay slot, but it is not\n ;; itself a delayed branch type instruction.  An instruction\n ;; whose type is 'delayed' is one which has a delay slot, and"}, {"sha": "5e9f7dadbc1d522c073ac8d745c375704621c879", "filename": "gcc/config/i386/i386-interix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fconfig%2Fi386%2Fi386-interix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fconfig%2Fi386%2Fi386-interix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-interix.h?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -84,7 +84,7 @@ Boston, MA 02110-1301, USA.  */\n #undef CPP_SPEC\n /* Write out the correct language type definition for the header files.  \n    Unless we have assembler language, write out the symbols for C.\n-   mieee is an Alpha specific variant.  Cross polination a bad idea.\n+   mieee is an Alpha specific variant.  Cross pollination a bad idea.\n    */\n #define CPP_SPEC \"-remap %{posix:-D_POSIX_SOURCE} \\\n -isystem %$INTERIX_ROOT/usr/include\""}, {"sha": "a557c16859cf117626e1b1750624290820b9d0b8", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -604,7 +604,7 @@ struct processor_costs generic64_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n   /* On all chips taken into consideration lea is 2 cycles and more.  With\n      this cost however our current implementation of synth_mult results in\n-     use of unnecesary temporary registers causing regression on several\n+     use of unnecessary temporary registers causing regression on several\n      SPECfp benchmarks.  */\n   COSTS_N_INSNS (1) + 1,\t\t/* cost of a lea instruction */\n   COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n@@ -10513,7 +10513,7 @@ ix86_expand_carry_flag_compare (enum rtx_code code, rtx op0, rtx op1, rtx *pop)\n   enum machine_mode mode =\n     GET_MODE (op0) != VOIDmode ? GET_MODE (op0) : GET_MODE (op1);\n \n-  /* Do not handle DImode compares that go trought special path.  Also we can't\n+  /* Do not handle DImode compares that go through special path.  Also we can't\n      deal with FP compares yet.  This is possible to add.  */\n   if (mode == (TARGET_64BIT ? TImode : DImode))\n     return false;"}, {"sha": "a298e1b4aa751192050de26e200f7faa84fec7f4", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -13877,7 +13877,7 @@\n #else\n   /* It is tempting to use ASM_OUTPUT_ALIGN here, but we don't want to do that.\n      The align insn is used to avoid 3 jump instructions in the row to improve\n-     branch prediction and the benefits hardly outweight the cost of extra 8\n+     branch prediction and the benefits hardly outweigh the cost of extra 8\n      nops on the average inserted by full alignment pseudo operation.  */\n #endif\n   return \"\";"}, {"sha": "49bb6206d43c9d003a6c576f099f32b3d1579956", "filename": "gcc/config/sh/superh.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fconfig%2Fsh%2Fsuperh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fconfig%2Fsh%2Fsuperh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsuperh.h?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -28,7 +28,7 @@ Boston, MA 02110-1301, USA.  */\n    defaults and provide options --defsym _start and --defsym _stack\n    which are required by the SuperH configuration of GNU ld.\n \n-   This file is intended to overide sh.h */\n+   This file is intended to override sh.h.  */\n \n \n #ifndef _SUPERH_H"}, {"sha": "f768c38a9526ca1ee8dfa30e26a71ebb44bd8529", "filename": "gcc/config/sh/superh64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fconfig%2Fsh%2Fsuperh64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fconfig%2Fsh%2Fsuperh64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsuperh64.h?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -25,7 +25,7 @@ Boston, MA 02110-1301, USA.  */\n /* This header file is used when the vendor name is set to 'superh'.\n    It configures the compiler for SH5 only and switches the default\n    endianess to little.\n-   This file is intended to overide sh.h, superh.h and sh64.h (which\n+   This file is intended to override sh.h, superh.h and sh64.h (which\n    should have been included in that order) */\n \n "}, {"sha": "22bb1512562adb4a6bc00d7e70dee8b7f549c728", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -1070,7 +1070,7 @@ ep_memory_operand (rtx op, enum machine_mode mode, int unsigned_load)\n   int mask;\n \n   /* If we are not using the EP register on a per-function basis\n-     then do not allow this optimisation at all.  This is to\n+     then do not allow this optimization at all.  This is to\n      prevent the use of the SLD/SST instructions which cannot be\n      guaranteed to work properly due to a hardware bug.  */\n   if (!TARGET_EP)"}, {"sha": "7f89fccdfb358682e9561884c43426f363a96548", "filename": "gcc/df-core.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -164,7 +164,7 @@ incremental algorithms.\n As for the bit vector problems, there is no interface to give a set of\n blocks over with to resolve the iteration.  In general, restarting a\n dataflow iteration is difficult and expensive.  Again, the best way to\n-keep the dataflow infomation up to data (if this is really what is\n+keep the dataflow information up to data (if this is really what is\n needed) it to formulate a problem specific solution.\n \n There are fine grained calls for creating and deleting references from"}, {"sha": "cdf4141f704c8657200a2c6083c57702967251a9", "filename": "gcc/df-problems.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -315,7 +315,7 @@ df_unset_seen (void)\n    sparse_invalidated_by call both play this game.  */\n \n /* Private data used to compute the solution for this problem.  These\n-   data structures are not accessable outside of this module.  */\n+   data structures are not accessible outside of this module.  */\n struct df_ru_problem_data\n {\n \n@@ -851,7 +851,7 @@ df_ru_add_problem (struct df *df, int flags)\n    here for the defs.  */\n \n /* Private data used to compute the solution for this problem.  These\n-   data structures are not accessable outside of this module.  */\n+   data structures are not accessible outside of this module.  */\n struct df_rd_problem_data\n {\n   /* If the number of defs for regnum N is less than\n@@ -2147,7 +2147,7 @@ df_ur_add_problem (struct df *df, int flags)\n    ----------------------------------------------------------------------------*/\n \n /* Private data used to compute the solution for this problem.  These\n-   data structures are not accessable outside of this module.  */\n+   data structures are not accessible outside of this module.  */\n struct df_urec_problem_data\n {\n   bool earlyclobbers_found;     /* True if any instruction contains an\n@@ -3797,7 +3797,7 @@ static struct df_problem problem_RI =\n   df_ri_dump,                 /* Debugging.  */\n \n   /* Technically this is only dependent on the live registers problem\n-     but it will produce infomation if built one of uninitialized\n+     but it will produce information if built one of uninitialized\n      register problems (UR, UREC) is also run.  */\n   df_lr_add_problem,          /* Dependent problem.  */\n   0                           /* Changeable flags.  */"}, {"sha": "689e058afb11a126d6250025e970e9a8f8752ca4", "filename": "gcc/df.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -214,7 +214,7 @@ struct dataflow\n   /* The pool to allocate the block_info from. */\n   alloc_pool block_pool;                \n \n-  /* Problem specific control infomation.  */\n+  /* Problem specific control information.  */\n \n   /* Scanning flags.  */\n #define DF_HARD_REGS\t     1\t/* Mark hard registers.  */\n@@ -502,7 +502,7 @@ struct df_ru_bb_info\n      sparse_kill, each register gets a slot and a 1 in this bitvector\n      means that all of the uses of that register are killed.  This is\n      a very useful efficiency hack in that it keeps from having push\n-     around big groups of 1s.  This is implemened by the\n+     around big groups of 1s.  This is implemented by the\n      bitmap_clear_range call.  */\n \n   bitmap kill;"}, {"sha": "f49341845321289c66b48757825827a547f1f80c", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -1611,7 +1611,7 @@ when used within the DSO@.  Enabling this option can have a dramatic effect\n on load and link times of a DSO as it massively reduces the size of the\n dynamic export table when the library makes heavy use of templates.\n \n-The behaviour of this switch is not quite the same as marking the\n+The behavior of this switch is not quite the same as marking the\n methods as hidden directly.  Normally if there is a class with default\n visibility which has a hidden method, the effect of this is that the\n method must be defined in only one shared object.  This switch does\n@@ -3271,7 +3271,7 @@ in some fonts or display methodologies, especially once formatting has\n been applied.  For instance @code{\\u207F}, ``SUPERSCRIPT LATIN SMALL\n LETTER N'', will display just like a regular @code{n} which has been\n placed in a superscript.  ISO 10646 defines the @dfn{NFKC}\n-normalisation scheme to convert all these into a standard form as\n+normalization scheme to convert all these into a standard form as\n well, and GCC will warn if your code is not in NFKC if you use\n @option{-Wnormalized=nfkc}.  This warning is comparable to warning\n about every identifier that contains the letter O because it might be"}, {"sha": "9036ddbd983fbb6945ba65f789318f702aa71403", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -1896,7 +1896,7 @@ still known.\n @itemx (ss_neg:@var{m} @var{x})\n These two expressions represent the negation (subtraction from zero) of\n the value represented by @var{x}, carried out in mode @var{m}.  They\n-differ in the behaviour on overflow of integer modes.  In the case of\n+differ in the behavior on overflow of integer modes.  In the case of\n @code{neg}, the negation of the operand may be a number not representable\n in mode @var{m}, in which case it is truncated to @var{m}.  @code{ss_neg}\n ensures that an out-of-bounds result saturates to the maximum or minimum\n@@ -2016,7 +2016,7 @@ fixed-point mode.\n @itemx (ss_ashift:@var{m} @var{x} @var{c})\n These two expressions represent the result of arithmetically shifting @var{x}\n left by @var{c} places.  They differ in their behavior on overflow of integer\n-modes.  An @code{ashift} operation is a plain shift with no special behaviour\n+modes.  An @code{ashift} operation is a plain shift with no special behavior\n in case of a change in the sign bit; @code{ss_ashift} saturates to the minimum\n or maximum representable value if any of the bits shifted out differs from the\n final sign bit."}, {"sha": "9063928711c67fdcdb6a1dcd0a841010a2237a51", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -3090,7 +3090,7 @@ DWARF 2.\n @defmac FRAME_POINTER_CFA_OFFSET (@var{fundecl})\n If defined, a C expression whose value is an integer giving the offset\n in bytes from the frame pointer to the canonical frame address (cfa).\n-The final value should conincide with that calculated by\n+The final value should coincide with that calculated by\n @code{INCOMING_FRAME_SP_OFFSET}.\n \n Normally the CFA is calculated as an offset from the argument pointer,"}, {"sha": "be563e496a4bf257303a9b0db48834b99f04f5dc", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -3572,7 +3572,7 @@ switch_to_exception_section (void)\n \n \n /* Output a reference from an exception table to the type_info object TYPE.\n-   TT_FORMAT and TT_FORMAT_SIZE descibe the DWARF encoding method used for\n+   TT_FORMAT and TT_FORMAT_SIZE describe the DWARF encoding method used for\n    the value.  */\n \n static void"}, {"sha": "13f724ace8ea4e1769ad08ed13f901d834565850", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -380,7 +380,7 @@ init_insn_lengths (void)\n }\n \n /* Obtain the current length of an insn.  If branch shortening has been done,\n-   get its actual length.  Otherwise, use FALLBACK_FN to calcualte the\n+   get its actual length.  Otherwise, use FALLBACK_FN to calculate the\n    length.  */\n static inline int\n get_attr_length_1 (rtx insn ATTRIBUTE_UNUSED,"}, {"sha": "95050476c25447f08198f3247e1bb80db7816e58", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -2765,14 +2765,14 @@ sched_init (void)\n \tspec_info->weakness_cutoff =\n \t  (PARAM_VALUE (PARAM_SCHED_SPEC_PROB_CUTOFF) * MAX_DEP_WEAK) / 100;\n       else\n-\t/* So we won't read anything accidently.  */\n+\t/* So we won't read anything accidentally.  */\n \tspec_info = 0;\n #ifdef ENABLE_CHECKING\n       check_sched_flags ();\n #endif\n     }\n   else\n-    /* So we won't read anything accidently.  */\n+    /* So we won't read anything accidentally.  */\n     spec_info = 0;\n \n   /* Initialize issue_rate.  */"}, {"sha": "8ed9610c6b458a3d73ba32df55fbe883ea889c11", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -623,7 +623,7 @@ compute_nest_using_fourier_motzkin (int size,\n    4. Multiply the composed transformation matrix times the matrix form of the\n    loop.\n    5. Transform the newly created matrix (from step 4) back into a loop nest\n-   using fourier motzkin elimination to figure out the bounds.  */\n+   using Fourier-Motzkin elimination to figure out the bounds.  */\n \n static lambda_loopnest\n lambda_compute_auxillary_space (lambda_loopnest nest,\n@@ -742,7 +742,7 @@ lambda_compute_auxillary_space (lambda_loopnest nest,\n   lambda_matrix_add_mc (B, 1, B1, -1, B1, size, invariants);\n \n   /* Now compute the auxiliary space bounds by first inverting U, multiplying\n-     it by A1, then performing fourier motzkin.  */\n+     it by A1, then performing Fourier-Motzkin.  */\n \n   invertedtrans = lambda_matrix_new (depth, depth);\n "}, {"sha": "c13f0c76bcceed89bf4776d1f9b55d493cac156a", "filename": "gcc/libgcc2.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Flibgcc2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Flibgcc2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.h?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -429,7 +429,7 @@ extern const UQItype __popcount_tab[256];\n /* Defined for L_clz.  Exported here because some targets may want to use\n    it for their own versions of the __clz builtins.  It contains the bit\n    position of the first set bit for the numbers 0 - 255.  This avoids the\n-   need for a seperate table for the __ctz builtins.  */\n+   need for a separate table for the __ctz builtins.  */\n extern const UQItype __clz_tab[256];\n \n #include \"longlong.h\""}, {"sha": "e8e835190e85e5e58b31a3dfccc6283df001f014", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -478,7 +478,7 @@ use_pointer_for_field (tree decl, bool shared_p)\n   if (AGGREGATE_TYPE_P (TREE_TYPE (decl)))\n     return true;\n \n-  /* We can only use copy-in/copy-out semantics for shared varibles\n+  /* We can only use copy-in/copy-out semantics for shared variables\n      when we know the value is not accessible from an outer scope.  */\n   if (shared_p)\n     {"}, {"sha": "5b50f9dceeda338ee7ddea1d9fd69816b4527d99", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -4741,7 +4741,7 @@ expand_fix (rtx to, rtx from, int unsignedp)\n      This is not needed.  Consider, for instance conversion from SFmode\n      into DImode.\n \n-     The hot path trought the code is dealing with inputs smaller than 2^63\n+     The hot path through the code is dealing with inputs smaller than 2^63\n      and doing just the conversion, so there is no bits to lose.\n \n      In the other path we know the value is positive in the range 2^63..2^64-1"}, {"sha": "7ac11f0f2ba9c0cb5c5dcef0797fd1c69731ec55", "filename": "gcc/predict.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -1258,7 +1258,7 @@ tree_estimate_probability (void)\n \t{\n \t  /* Predict early returns to be probable, as we've already taken\n \t     care for error returns and other cases are often used for\n-\t     fast paths trought function.  */\n+\t     fast paths through function.  */\n \t  if (e->dest == EXIT_BLOCK_PTR\n \t      && TREE_CODE (last_stmt (bb)) == RETURN_EXPR\n \t      && !single_pred_p (bb))"}, {"sha": "dd15e0a2e1f57d4a538af2d20a31d287e614a877", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -5375,7 +5375,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t\t\t\t\t\t       GET_MODE (orig_op1))));\n \t  }\n \t/* Plus in the index register may be created only as a result of\n-\t   register remateralization for expression like &localvar*4.  Reload it.\n+\t   register rematerialization for expression like &localvar*4.  Reload it.\n \t   It may be possible to combine the displacement on the outer level,\n \t   but it is probably not worthwhile to do so.  */\n \tif (context == 1)"}, {"sha": "0dad98ba4abe444fdce23e00bece374411b720e6", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -263,7 +263,7 @@ typedef struct immediate_use_iterator_d\n \n \n /* Use this iterator in combination with FOR_EACH_IMM_USE_STMT to \n-   get access to each occurence of ssavar on the stmt returned by\n+   get access to each occurrence of ssavar on the stmt returned by\n    that iterator..  for instance:\n \n      FOR_EACH_IMM_USE_STMT (stmt, iter, var)"}, {"sha": "0366614e5afae795c4c8f43fcf080e83b956826e", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -2214,7 +2214,7 @@ analyze_edges_for_bb (basic_block bb)\n \tleader_match = leader;\n \n \t/* The tree_* cfg manipulation routines use the PENDING_EDGE field\n-\t   for various PHI manipulations, so it gets cleared whhen calls are \n+\t   for various PHI manipulations, so it gets cleared when calls are \n \t   made to make_forwarder_block(). So make sure the edge is clear, \n \t   and use the saved stmt list.  */\n \tPENDING_STMT (leader) = NULL;"}, {"sha": "1487249d89dfd396d99ac9c6a4fd83bdacebc681", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -720,7 +720,7 @@ remove_dead_stmt (block_stmt_iterator *i, basic_block bb)\n      nothing to the program, then we not only remove it, but we also change\n      the flow graph so that the current block will simply fall-thru to its\n      immediate post-dominator.  The blocks we are circumventing will be\n-     removed by cleaup_tree_cfg if this change in the flow graph makes them\n+     removed by cleanup_tree_cfg if this change in the flow graph makes them\n      unreachable.  */\n   if (is_ctrl_stmt (t))\n     {"}, {"sha": "7ae481b2b7a622997b4054924bfade1aba227453", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -264,7 +264,7 @@ typedef struct bb_value_sets\n   bitmap rvuse_gen;\n   bitmap rvuse_kill;\n \n-  /* For actually occuring loads, as long as they occur before all the\n+  /* For actually occurring loads, as long as they occur before all the\n      other stores in the block, we know they are antic at the top of\n      the block, regardless of RVUSE_KILL.  */\n   value_set_t antic_safe_loads;"}, {"sha": "746e9067e4760076e2c1e954b99e8cee51c82703", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fc0bb99a7d0fcedd1b345da14d4dd16926b5458/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=6fc0bb99a7d0fcedd1b345da14d4dd16926b5458", "patch": "@@ -3036,7 +3036,7 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n       bsi_insert_before (&cond_exp_bsi, cond_expr_stmt_list, BSI_SAME_STMT);\n     }\n \n-  /* CHECKME: we wouldn't need this if we calles update_ssa once\n+  /* CHECKME: we wouldn't need this if we called update_ssa once\n      for all loops.  */\n   bitmap_zero (vect_vnames_to_rename);\n "}]}