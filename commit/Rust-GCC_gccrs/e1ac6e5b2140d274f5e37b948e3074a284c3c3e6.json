{"sha": "e1ac6e5b2140d274f5e37b948e3074a284c3c3e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFhYzZlNWIyMTQwZDI3NGY1ZTM3Yjk0OGUzMDc0YTI4NGMzYzNlNg==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2005-11-15T13:54:14Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-11-15T13:54:14Z"}, "message": "cuintp.c (UI_To_gnu): Use a proper type for intermediate computations to ensure bias adjustments take...\n\n2005-11-14  Olivier Hainque  <hainque@adacore.com>\n\n\t* cuintp.c (UI_To_gnu): Use a proper type for intermediate computations\n\tto ensure bias adjustments take place when need be and to prevent\n\toccurrences of intermediate overflows.\n\nFrom-SVN: r106963", "tree": {"sha": "86a95cdf244ee0c5fda1fa480d98b5c92f52d9c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86a95cdf244ee0c5fda1fa480d98b5c92f52d9c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1ac6e5b2140d274f5e37b948e3074a284c3c3e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1ac6e5b2140d274f5e37b948e3074a284c3c3e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1ac6e5b2140d274f5e37b948e3074a284c3c3e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1ac6e5b2140d274f5e37b948e3074a284c3c3e6/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2368f04ec19f5d2aa5439e2454217d3135603dd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2368f04ec19f5d2aa5439e2454217d3135603dd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2368f04ec19f5d2aa5439e2454217d3135603dd0"}], "stats": {"total": 38, "additions": 29, "deletions": 9}, "files": [{"sha": "7adc057ce7c24e8b62acf780eef97d79cc883c92", "filename": "gcc/ada/cuintp.c", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1ac6e5b2140d274f5e37b948e3074a284c3c3e6/gcc%2Fada%2Fcuintp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1ac6e5b2140d274f5e37b948e3074a284c3c3e6/gcc%2Fada%2Fcuintp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcuintp.c?ref=e1ac6e5b2140d274f5e37b948e3074a284c3c3e6", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2003 Free Software Foundation, Inc.          *\n+ *          Copyright (C) 1992-2005 Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -41,6 +41,7 @@\n #include \"stringt.h\"\n #include \"fe.h\"\n #include \"gigi.h\"\n+#include \"ada-tree.h\"\n \n /* Universal integers are represented by the Uint type which is an index into\n    the Uints_Ptr table containing Uint_Entry values.  A Uint_Entry contains an\n@@ -74,22 +75,41 @@ UI_To_gnu (Uint Input, tree type)\n {\n   tree gnu_ret;\n \n+  /* We might have a TYPE with biased representation and be passed an\n+     unbiased value that doesn't fit.  We always use an unbiased type able\n+     to hold any such possible value for intermediate computations, and\n+     then rely on a conversion back to TYPE to perform the bias adjustment\n+     when need be.  */\n+\n+  int biased_type_p\n+    = (TREE_CODE (type) == INTEGER_TYPE\n+       && TYPE_BIASED_REPRESENTATION_P (type));\n+\n+  tree comp_type = biased_type_p ? get_base_type (type) : type;\n+\n   if (Input <= Uint_Direct_Last)\n-    gnu_ret = build_cst_from_int (type, Input - Uint_Direct_Bias);\n+    gnu_ret = build_cst_from_int (comp_type, Input - Uint_Direct_Bias);\n   else\n     {\n       Int Idx = Uints_Ptr[Input].Loc;\n       Pos Length = Uints_Ptr[Input].Length;\n       Int First = Udigits_Ptr[Idx];\n-      /* Do computations in integer type or TYPE whichever is wider, then\n-\t convert later.  This avoid overflow if type is short integer.  */\n-      tree comp_type\n-\t= ((TREE_CODE (type) == REAL_TYPE\n-\t    || TYPE_PRECISION (type) >= TYPE_PRECISION (integer_type_node))\n-\t   ? type : integer_type_node);\n-      tree gnu_base = build_cst_from_int (comp_type, Base);\n+      tree gnu_base;\n \n       gcc_assert (Length > 0);\n+\n+      /* The computations we perform below always require a type at least as\n+\t large as an integer not to overflow.  REAL types are always fine, but\n+\t INTEGER or ENUMERAL types we are handed may be too short.  We use a\n+\t base integer type node for the computations in this case and will\n+\t convert the final result back to the incoming type later on.  */\n+\n+      if (TREE_CODE (comp_type) != REAL_TYPE\n+\t  && TYPE_PRECISION (comp_type) < TYPE_PRECISION (integer_type_node))\n+\tcomp_type = integer_type_node;\n+\n+      gnu_base = build_cst_from_int (comp_type, Base);\n+\n       gnu_ret = build_cst_from_int (comp_type, First);\n       if (First < 0)\n \tfor (Idx++, Length--; Length; Idx++, Length--)"}]}