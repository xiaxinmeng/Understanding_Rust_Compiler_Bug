{"sha": "32bba3c9d848935dbec4b070093574a34b0817a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJiYmEzYzlkODQ4OTM1ZGJlYzRiMDcwMDkzNTc0YTM0YjA4MTdhNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-24T16:30:08Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-24T16:30:08Z"}, "message": "[multiple changes]\n\n2014-02-24  Robert Dewar  <dewar@adacore.com>\n\n\t* sinfo.ads, sem_ch12.adb, sem_res.adb, sem_ch4.adb, par-ch12.adb:\n\tMinor reformatting.\n\t* atree.ads, atree.adb (Node35): New function.\n\t(Set_Node35): New procedure.\n\t* debug.adb: Define new debug flag -gnatd.X.\n\t* einfo.ads, einfo.adb (Import_Pragma): New field.\n\t* freeze.adb (Wrap_Imported_Procedure): New procedure (not\n\treally active yet, has to be activated with -gnatd.X.\n\t* sem_prag.adb (Set_Imported): Set new Import_Pragma\n\tfield (Set_Imported): Don't set Is_Public (see\n\tFreeze.Wrap_Imported_Subprogram)\n\t* par-ch3.adb (P_Component_List): Handle unexpected null component.\n\n2014-02-24  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch3.adb: Correct reference to SPARK RM in error messages.\n\t* gnat_rm.texi: Correct documentation of attribute Update.\n\n2014-02-24  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch5.adb (Analyze_Iterator_Specification): Reject container\n\titerator in older versions of Ada.\n\nFrom-SVN: r208076", "tree": {"sha": "6aec8ad587cff01ba9f05b72d71f56e0fad6ff70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6aec8ad587cff01ba9f05b72d71f56e0fad6ff70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32bba3c9d848935dbec4b070093574a34b0817a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32bba3c9d848935dbec4b070093574a34b0817a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32bba3c9d848935dbec4b070093574a34b0817a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32bba3c9d848935dbec4b070093574a34b0817a4/comments", "author": null, "committer": null, "parents": [{"sha": "97027f64df2958e3ec51605c7e2c6f892d2235bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97027f64df2958e3ec51605c7e2c6f892d2235bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97027f64df2958e3ec51605c7e2c6f892d2235bb"}], "stats": {"total": 463, "additions": 345, "deletions": 118}, "files": [{"sha": "f4208df878e99de7c0f5da6ed7c2358b0fd79065", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=32bba3c9d848935dbec4b070093574a34b0817a4", "patch": "@@ -1,3 +1,28 @@\n+2014-02-24  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sinfo.ads, sem_ch12.adb, sem_res.adb, sem_ch4.adb, par-ch12.adb:\n+\tMinor reformatting.\n+\t* atree.ads, atree.adb (Node35): New function.\n+\t(Set_Node35): New procedure.\n+\t* debug.adb: Define new debug flag -gnatd.X.\n+\t* einfo.ads, einfo.adb (Import_Pragma): New field.\n+\t* freeze.adb (Wrap_Imported_Procedure): New procedure (not\n+\treally active yet, has to be activated with -gnatd.X.\n+\t* sem_prag.adb (Set_Imported): Set new Import_Pragma\n+\tfield (Set_Imported): Don't set Is_Public (see\n+\tFreeze.Wrap_Imported_Subprogram)\n+\t* par-ch3.adb (P_Component_List): Handle unexpected null component.\n+\n+2014-02-24  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch3.adb: Correct reference to SPARK RM in error messages.\n+\t* gnat_rm.texi: Correct documentation of attribute Update.\n+\n+2014-02-24  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch5.adb (Analyze_Iterator_Specification): Reject container\n+\titerator in older versions of Ada.\n+\n 2014-02-24  Gary Dismukes  <dismukes@adacore.com>\n \n \t* sem_ch5.adb, sem_aux.ads, sem_ch12.adb, gnat_ugn.texi, par.adb,"}, {"sha": "2e3f76b5c6497853560e82741238595d99355568", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=32bba3c9d848935dbec4b070093574a34b0817a4", "patch": "@@ -2643,6 +2643,12 @@ package body Atree is\n          return Node_Id (Nodes.Table (N + 5).Field10);\n       end Node34;\n \n+      function Node35 (N : Node_Id) return Node_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Node_Id (Nodes.Table (N + 5).Field11);\n+      end Node35;\n+\n       function List1 (N : Node_Id) return List_Id is\n       begin\n          pragma Assert (N <= Nodes.Last);\n@@ -5407,6 +5413,12 @@ package body Atree is\n          Nodes.Table (N + 5).Field10 := Union_Id (Val);\n       end Set_Node34;\n \n+      procedure Set_Node35 (N : Node_Id; Val : Node_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 5).Field11 := Union_Id (Val);\n+      end Set_Node35;\n+\n       procedure Set_List1 (N : Node_Id; Val : List_Id) is\n       begin\n          pragma Assert (N <= Nodes.Last);"}, {"sha": "ba110825b397d21e1366d9050cdb18fe0f6beff3", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=32bba3c9d848935dbec4b070093574a34b0817a4", "patch": "@@ -1236,6 +1236,9 @@ package Atree is\n       function Node34 (N : Node_Id) return Node_Id;\n       pragma Inline (Node34);\n \n+      function Node35 (N : Node_Id) return Node_Id;\n+      pragma Inline (Node35);\n+\n       function List1 (N : Node_Id) return List_Id;\n       pragma Inline (List1);\n \n@@ -2545,6 +2548,9 @@ package Atree is\n       procedure Set_Node34 (N : Node_Id; Val : Node_Id);\n       pragma Inline (Set_Node34);\n \n+      procedure Set_Node35 (N : Node_Id; Val : Node_Id);\n+      pragma Inline (Set_Node35);\n+\n       procedure Set_List1 (N : Node_Id; Val : List_Id);\n       pragma Inline (Set_List1);\n "}, {"sha": "a6506932982b578ef396fc42f31fc9af56c786ce", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=32bba3c9d848935dbec4b070093574a34b0817a4", "patch": "@@ -141,7 +141,7 @@ package body Debug is\n    --  d.U  Ignore indirect calls for static elaboration\n    --  d.V\n    --  d.W  Print out debugging information for Walk_Library_Items\n-   --  d.X\n+   --  d.X  Activate wrapping of imported subprograms with pre/post conditions\n    --  d.Y\n    --  d.Z\n \n@@ -664,6 +664,9 @@ package body Debug is\n    --       the order in which units are walked. This is primarily for use in\n    --       debugging CodePeer mode.\n \n+   --  d.X  Activates Wrap_Imported_Subprogram in Freeze (not yet working so\n+   --       this allows checkin of partial implementation).\n+\n    --  d1   Error messages have node numbers where possible. Normally error\n    --       messages have only source locations. This option is useful when\n    --       debugging errors caused by expanded code, where the source location"}, {"sha": "01ec45a457d98d93d1d5ad06b36afb7870272ff6", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=32bba3c9d848935dbec4b070093574a34b0817a4", "patch": "@@ -257,7 +257,7 @@ package body Einfo is\n \n    --    Contract                        Node34\n \n-   --    (unused)                        Node35\n+   --    Import_Pragma                   Node35\n \n    ---------------------------------------------\n    -- Usage of Flags in Defining Entity Nodes --\n@@ -1785,6 +1785,12 @@ package body Einfo is\n       return Node4 (Id);\n    end Homonym;\n \n+   function Import_Pragma (Id : E) return E is\n+   begin\n+      pragma Assert (Is_Subprogram (Id));\n+      return Node35 (Id);\n+   end Import_Pragma;\n+\n    function Interface_Alias (Id : E) return E is\n    begin\n       pragma Assert (Is_Subprogram (Id));\n@@ -4483,6 +4489,12 @@ package body Einfo is\n       Set_Node4 (Id, V);\n    end Set_Homonym;\n \n+   procedure Set_Import_Pragma (Id : E; V : E) is\n+   begin\n+      pragma Assert (Is_Subprogram (Id));\n+      Set_Node35 (Id, V);\n+   end Set_Import_Pragma;\n+\n    procedure Set_Interface_Alias (Id : E; V : E) is\n    begin\n       pragma Assert\n@@ -9554,6 +9566,8 @@ package body Einfo is\n    procedure Write_Field35_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when Subprogram_Kind                              =>\n+            Write_Str (\"Import_Pragma\");\n          when others                                       =>\n             Write_Str (\"Field35??\");\n       end case;"}, {"sha": "00cc1fab424d1f283fcc602096ffcb4f331d1032", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=32bba3c9d848935dbec4b070093574a34b0817a4", "patch": "@@ -1973,6 +1973,13 @@ package Einfo is\n --       that we still have a concrete type. For entities other than types,\n --       returns the entity unchanged.\n \n+--    Import_Pragma (Node35)\n+--       Defined in subprogram entities. Set if a valid pragma Import or pragma\n+--       Import_Function or pragma Import_Procedure aplies to the subprogram,\n+--       in which case this field points to the pragma (we can't use the normal\n+--       Rep_Item chain mechanism, because a single pragma Import can apply\n+--       to multiple subprogram entities.\n+\n --    In_Package_Body (Flag48)\n --       Defined in package entities. Set on the entity that denotes the\n --       package (the defining occurrence of the package declaration) while\n@@ -6478,6 +6485,7 @@ package Einfo is\n    function Has_Xref_Entry                      (Id : E) return B;\n    function Hiding_Loop_Variable                (Id : E) return E;\n    function Homonym                             (Id : E) return E;\n+   function Import_Pragma                       (Id : E) return E;\n    function In_Package_Body                     (Id : E) return B;\n    function In_Private_Part                     (Id : E) return B;\n    function In_Use                              (Id : E) return B;\n@@ -7100,6 +7108,7 @@ package Einfo is\n    procedure Set_Has_Xref_Entry                  (Id : E; V : B := True);\n    procedure Set_Hiding_Loop_Variable            (Id : E; V : E);\n    procedure Set_Homonym                         (Id : E; V : E);\n+   procedure Set_Import_Pragma                   (Id : E; V : E);\n    procedure Set_In_Package_Body                 (Id : E; V : B := True);\n    procedure Set_In_Private_Part                 (Id : E; V : B := True);\n    procedure Set_In_Use                          (Id : E; V : B := True);\n@@ -7836,6 +7845,7 @@ package Einfo is\n    pragma Inline (Has_Xref_Entry);\n    pragma Inline (Hiding_Loop_Variable);\n    pragma Inline (Homonym);\n+   pragma Inline (Import_Pragma);\n    pragma Inline (In_Package_Body);\n    pragma Inline (In_Private_Part);\n    pragma Inline (In_Use);\n@@ -8306,6 +8316,7 @@ package Einfo is\n    pragma Inline (Set_Has_Xref_Entry);\n    pragma Inline (Set_Hiding_Loop_Variable);\n    pragma Inline (Set_Homonym);\n+   pragma Inline (Set_Import_Pragma);\n    pragma Inline (Set_In_Package_Body);\n    pragma Inline (Set_In_Private_Part);\n    pragma Inline (Set_In_Use);"}, {"sha": "716a96b42a633bce083de2546108cf4cd40af17d", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 156, "deletions": 25, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=32bba3c9d848935dbec4b070093574a34b0817a4", "patch": "@@ -1742,6 +1742,11 @@ package body Freeze is\n       --  Freeze record type, including freezing component types, and freezing\n       --  primitive operations if this is a tagged type.\n \n+      procedure Wrap_Imported_Subprogram (E : Entity_Id);\n+      --  If E is an entity for an imported subprogram with pre/post-conditions\n+      --  then this procedure will create a wrapper to ensure that proper run-\n+      --  time checking of the pre/postconditions. See body for details.\n+\n       -------------------\n       -- Add_To_Result --\n       -------------------\n@@ -3358,6 +3363,146 @@ package body Freeze is\n          end Check_Variant_Part;\n       end Freeze_Record_Type;\n \n+      ------------------------------\n+      -- Wrap_Imported_Subprogram --\n+      ------------------------------\n+\n+      --  The issue here is that our normal approach of checking preconditions\n+      --  and postconditions does not work for imported procedures, since we\n+      --  are not generating code for the body. To get around this we create\n+      --  a wrapper, as shown by the following example:\n+\n+      --    procedure K (A : Integer);\n+      --    pragma Import (C, K);\n+\n+      --  The spec is rewritten by removing the effects of pragma Import, but\n+      --  leaving the convention unchanged, as though the source had said:\n+\n+      --    procedure K (A : Integer);\n+      --    pragma Convention (C, K);\n+\n+      --  and we create a body, added to the entity K freeze actions, which\n+      --  looks like:\n+\n+      --    procedure K (A : Integer) is\n+      --       procedure K (A : Integer);\n+      --       pragma Import (C, K);\n+      --    begin\n+      --       K (A);\n+      --    end K;\n+\n+      --  Now the contract applies in the normal way to the outer procedure,\n+      --  and the inner procedure has no contracts, so there is no problem\n+      --  in just calling it to get the original effect.\n+\n+      --  In the case of a function, we create an appropriate return statement\n+      --  for the subprogram body that calls the inner procedure.\n+\n+      procedure Wrap_Imported_Subprogram (E : Entity_Id) is\n+         Loc   : constant Source_Ptr := Sloc (E);\n+         Spec  : Node_Id;\n+         Parms : List_Id;\n+         Stmt  : Node_Id;\n+         Iprag : Node_Id;\n+         Bod   : Node_Id;\n+         Forml : Entity_Id;\n+\n+      begin\n+         --  Nothing to do if not imported\n+\n+         if not Is_Imported (E) then\n+            return;\n+         end if;\n+\n+         --  Test enabling conditions for wrapping\n+\n+         if Is_Subprogram (E)\n+           and then Present (Contract (E))\n+           and then Present (Pre_Post_Conditions (Contract (E)))\n+           and then not GNATprove_Mode\n+         then\n+            --  For now, activate this only if -gnatd.X is set, because there\n+            --  are problems with this procedure, it is not working yet, but\n+            --  we would like to be able to check it in ???\n+\n+            if not Debug_Flag_Dot_XX then\n+               Error_Msg_NE\n+                 (\"pre/post conditions on imported subprogram are not \"\n+                  & \"enforced??\", E, Pre_Post_Conditions (Contract (E)));\n+               goto Not_Wrapped;\n+            end if;\n+\n+            --  Fix up spec to be not imported any more\n+\n+            Iprag := Import_Pragma (E);\n+            Set_Is_Imported    (E, False);\n+            Set_Interface_Name (E, Empty);\n+            Set_Has_Completion (E, False);\n+            Set_Import_Pragma  (E, Empty);\n+\n+            --  Grab the subprogram declaration and specification\n+\n+            Spec := Declaration_Node (E);\n+\n+            --  Build parameter list that we need\n+\n+            Parms := New_List;\n+            Forml := First_Formal (E);\n+            while Present (Forml) loop\n+               Append_To (Parms, New_Occurrence_Of (Forml, Loc));\n+               Next_Formal (Forml);\n+            end loop;\n+\n+            --  Build the call\n+\n+            if Ekind_In (E, E_Function, E_Generic_Function) then\n+               Stmt :=\n+                 Make_Simple_Return_Statement (Loc,\n+                   Expression =>\n+                     Make_Function_Call (Loc,\n+                       Name                   => New_Occurrence_Of (E, Loc),\n+                       Parameter_Associations => Parms));\n+\n+            else\n+               Stmt :=\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name                   => New_Occurrence_Of (E, Loc),\n+                   Parameter_Associations => Parms);\n+            end if;\n+\n+            --  Now build the body\n+\n+            Bod :=\n+              Make_Subprogram_Body (Loc,\n+                Specification              => Copy_Separate_Tree (Spec),\n+                Declarations               => New_List (\n+                  Make_Subprogram_Declaration (Loc,\n+                    Specification => Copy_Separate_Tree (Spec)),\n+                  Copy_Separate_Tree (Iprag)),\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements             => New_List (Stmt),\n+                    End_Label              => New_Occurrence_Of (E, Loc)));\n+\n+            --  Append the body to freeze result\n+\n+            Add_To_Result (Bod);\n+            return;\n+         end if;\n+\n+         --  Case of imported subprogram that does not get wrapped\n+\n+         <<Not_Wrapped>>\n+\n+         --  Set Is_Public. All imported entities need an external symbol\n+         --  created for them since they are always referenced from another\n+         --  object file. Note this used to be set when we set Is_Imported\n+         --  back in Sem_Prag, but now we delay it to this point, since we\n+         --  don't want to set this flag if we wrap an imported subprogram.\n+\n+         Set_Is_Public (E);\n+      end Wrap_Imported_Subprogram;\n+\n    --  Start of processing for Freeze_Entity\n \n    begin\n@@ -3539,13 +3684,19 @@ package body Freeze is\n             null;\n          end if;\n \n-         --  For a subprogram, freeze all parameter types and also the return\n-         --  type (RM 13.14(14)). However skip this for internal subprograms.\n-         --  This is also the point where any extra formal parameters are\n-         --  created since we now know whether the subprogram will use a\n-         --  foreign convention.\n+         --  Subprogram case\n \n          if Is_Subprogram (E) then\n+\n+            --  Check for needing to wrap imported subprogram\n+\n+            Wrap_Imported_Subprogram (E);\n+\n+            --  Freeze all parameter types and the return type (RM 13.14(14)).\n+            --  However skip this for internal subprograms. This is also where\n+            --  any extra formal parameters are created since we now know\n+            --  whether the subprogram will use a foreign convention.\n+\n             if not Is_Internal (E) then\n                declare\n                   F_Type    : Entity_Id;\n@@ -3867,26 +4018,6 @@ package body Freeze is\n                      end if;\n                   end if;\n                end;\n-\n-               --  Pre/post conditions are implemented through a subprogram\n-               --  in the corresponding body, and therefore are not checked on\n-               --  an imported subprogram for which the body is not available.\n-               --  This warning is not issued in GNATprove mode, as all these\n-               --  contracts are handled in formal verification, so the warning\n-               --  would be misleading in that case.\n-\n-               --  Could consider generating a wrapper to take care of this???\n-\n-               if Is_Subprogram (E)\n-                 and then Is_Imported (E)\n-                 and then Present (Contract (E))\n-                 and then Present (Pre_Post_Conditions (Contract (E)))\n-                 and then not GNATprove_Mode\n-               then\n-                  Error_Msg_NE\n-                    (\"pre/post conditions on imported subprogram are not \"\n-                     & \"enforced??\", E, Pre_Post_Conditions (Contract (E)));\n-               end if;\n             end if;\n \n             --  Must freeze its parent first if it is a derived subprogram"}, {"sha": "af51de8adbd0b4263f0d2c133414d77a5c15e125", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=32bba3c9d848935dbec4b070093574a34b0817a4", "patch": "@@ -9286,22 +9286,29 @@ The @code{Update} attribute creates a copy of an array or record value\n with one or more modified components. The syntax is:\n \n @smallexample @c ada\n-PREFIX'Update (AGGREGATE)\n+PREFIX'Update ( RECORD_COMPONENT_ASSOCIATION_LIST )\n+PREFIX'Update ( ARRAY_COMPONENT_ASSOCIATION @{, ARRAY_COMPONENT_ASSOCIATION @} )\n+PREFIX'Update ( MULTIDIMENSIONAL_ARRAY_COMPONENT_ASSOCIATION\n+                @{, MULTIDIMENSIONAL_ARRAY_COMPONENT_ASSOCIATION @} )\n+\n+MULTIDIMENSIONAL_ARRAY_COMPONENT_ASSOCIATION ::= INDEX_EXPRESSION_LIST_LIST => EXPRESSION\n+INDEX_EXPRESSION_LIST_LIST                   ::= INDEX_EXPRESSION_LIST @{| INDEX_EXPRESSION_LIST @}\n+INDEX_EXPRESSION_LIST                        ::= ( EXPRESSION @{, EXPRESSION @} )\n @end smallexample\n \n @noindent\n where @code{PREFIX} is the name of an array or record object, and\n-@code{AGGREGATE} is a named aggregate that does not contain an @code{others}\n+the association list in parentheses does not contain an @code{others}\n choice. The effect is to yield a copy of the array or record value which\n-is unchanged apart from the components mentioned in the aggregate, which\n+is unchanged apart from the components mentioned in the association list, which\n are changed to the indicated value. The original value of the array or\n record value is not affected. For example:\n \n @smallexample @c ada\n type Arr is Array (1 .. 5) of Integer;\n ...\n Avar1 : Arr := (1,2,3,4,5);\n-Avar2 : Arr := Avar1'Update ((2 => 10, 3 .. 4 => 20));\n+Avar2 : Arr := Avar1'Update (2 => 10, 3 .. 4 => 20);\n @end smallexample\n \n @noindent\n@@ -9312,7 +9319,7 @@ begin unmodified. Similarly:\n type Rec is A, B, C : Integer;\n ...\n Rvar1 : Rec := (A => 1, B => 2, C => 3);\n-Rvar2 : Rec := Rvar1'Update ((B => 20));\n+Rvar2 : Rec := Rvar1'Update (B => 20);\n @end smallexample\n \n @noindent\n@@ -9322,7 +9329,7 @@ Note that the value of the attribute reference is computed\n completely before it is used. This means that if you write:\n \n @smallexample @c ada\n-Avar1 := Avar1'Update ((1 => 10, 2 => Function_Call));\n+Avar1 := Avar1'Update (1 => 10, 2 => Function_Call);\n @end smallexample\n \n @noindent\n@@ -9338,15 +9345,15 @@ The accessibility level of an Update attribute result object is defined\n as for an aggregate.\n \n In the record case, no component can be mentioned more than once. In\n-the array case, two overlapping ranges can appear in the aggregate,\n+the array case, two overlapping ranges can appear in the association list,\n in which case the modifications are processed left to right.\n \n Multi-dimensional arrays can be modified, as shown by this example:\n \n @smallexample @c ada\n A : array (1 .. 10, 1 .. 10) of Integer;\n ..\n-A := A'Update (1 => (2 => 20), 3 => (4 => 30));\n+A := A'Update ((1, 2) => 20, (3, 4) => 30);\n @end smallexample\n \n @noindent"}, {"sha": "839697c766357211e86caf1c535a70c5bb4e315a", "filename": "gcc/ada/par-ch12.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fpar-ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fpar-ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch12.adb?ref=32bba3c9d848935dbec4b070093574a34b0817a4", "patch": "@@ -350,8 +350,8 @@ package body Ch12 is\n       if Token = Tok_Others then\n          if Ada_Version < Ada_2005 then\n             Error_Msg_SP\n-              (\"partial parameterization of formal packages\" &\n-                \" is an Ada 2005 extension\");\n+              (\"partial parameterization of formal packages\"\n+               & \" is an Ada 2005 extension\");\n             Error_Msg_SP\n               (\"\\unit must be compiled with -gnat05 switch\");\n          end if;"}, {"sha": "11e9f81c4d16f41e7c3bd08d9da9fa3d61c1c383", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 68, "deletions": 55, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=32bba3c9d848935dbec4b070093574a34b0817a4", "patch": "@@ -3270,87 +3270,100 @@ package body Ch3 is\n       Component_List_Node : Node_Id;\n       Decls_List          : List_Id;\n       Scan_State          : Saved_Scan_State;\n+      Null_Loc            : Source_Ptr;\n \n    begin\n       Component_List_Node := New_Node (N_Component_List, Token_Ptr);\n       Decls_List := New_List;\n \n+      --  Handle null\n+\n       if Token = Tok_Null then\n+         Null_Loc := Token_Ptr;\n          Scan; -- past NULL\n          TF_Semicolon;\n          P_Pragmas_Opt (Decls_List);\n-         Set_Null_Present (Component_List_Node, True);\n-         return Component_List_Node;\n \n-      else\n-         P_Pragmas_Opt (Decls_List);\n+         --  If we have an END or WHEN now, everything is fine, otherwise we\n+         --  complain about the null, ignore it, and scan for more components.\n \n-         if Token /= Tok_Case then\n-            Component_Scan_Loop : loop\n-               P_Component_Items (Decls_List);\n-               P_Pragmas_Opt (Decls_List);\n-\n-               exit Component_Scan_Loop when Token = Tok_End\n-                 or else Token = Tok_Case\n-                 or else Token = Tok_When;\n-\n-               --  We are done if we do not have an identifier. However, if\n-               --  we have a misspelled reserved identifier that is in a column\n-               --  to the right of the record definition, we will treat it as\n-               --  an identifier. It turns out to be too dangerous in practice\n-               --  to accept such a mis-spelled identifier which does not have\n-               --  this additional clue that confirms the incorrect spelling.\n-\n-               if Token /= Tok_Identifier then\n-                  if Start_Column > Scope.Table (Scope.Last).Ecol\n-                    and then Is_Reserved_Identifier\n-                  then\n-                     Save_Scan_State (Scan_State); -- at reserved id\n-                     Scan; -- possible reserved id\n+         if Token = Tok_End or else Token = Tok_When then\n+            Set_Null_Present (Component_List_Node, True);\n+            return Component_List_Node;\n+         else\n+            Error_Msg (\"NULL component only allowed in null record\", Null_Loc);\n+         end if;\n+      end if;\n \n-                     if Token = Tok_Comma or else Token = Tok_Colon then\n-                        Restore_Scan_State (Scan_State);\n-                        Scan_Reserved_Identifier (Force_Msg => True);\n+      --  Scan components for non-null record\n \n-                     --  Note reserved identifier used as field name after\n-                     --  all because not followed by colon or comma\n+      P_Pragmas_Opt (Decls_List);\n \n-                     else\n-                        Restore_Scan_State (Scan_State);\n-                        exit Component_Scan_Loop;\n-                     end if;\n+      if Token /= Tok_Case then\n+         Component_Scan_Loop : loop\n+            P_Component_Items (Decls_List);\n+            P_Pragmas_Opt (Decls_List);\n \n-                  --  Non-identifier that definitely was not reserved id\n+            exit Component_Scan_Loop when Token = Tok_End\n+              or else Token = Tok_Case\n+              or else Token = Tok_When;\n+\n+            --  We are done if we do not have an identifier. However, if we\n+            --  have a misspelled reserved identifier that is in a column to\n+            --  the right of the record definition, we will treat it as an\n+            --  identifier. It turns out to be too dangerous in practice to\n+            --  accept such a mis-spelled identifier which does not have this\n+            --  additional clue that confirms the incorrect spelling.\n+\n+            if Token /= Tok_Identifier then\n+               if Start_Column > Scope.Table (Scope.Last).Ecol\n+                 and then Is_Reserved_Identifier\n+               then\n+                  Save_Scan_State (Scan_State); -- at reserved id\n+                  Scan; -- possible reserved id\n+\n+                  if Token = Tok_Comma or else Token = Tok_Colon then\n+                     Restore_Scan_State (Scan_State);\n+                     Scan_Reserved_Identifier (Force_Msg => True);\n+\n+                     --  Note reserved identifier used as field name after all\n+                     --  because not followed by colon or comma.\n \n                   else\n+                     Restore_Scan_State (Scan_State);\n                      exit Component_Scan_Loop;\n                   end if;\n+\n+                  --  Non-identifier that definitely was not reserved id\n+\n+               else\n+                  exit Component_Scan_Loop;\n                end if;\n-            end loop Component_Scan_Loop;\n-         end if;\n+            end if;\n+         end loop Component_Scan_Loop;\n+      end if;\n \n-         if Token = Tok_Case then\n-            Set_Variant_Part (Component_List_Node, P_Variant_Part);\n+      if Token = Tok_Case then\n+         Set_Variant_Part (Component_List_Node, P_Variant_Part);\n \n-            --  Check for junk after variant part\n+         --  Check for junk after variant part\n \n-            if Token = Tok_Identifier then\n-               Save_Scan_State (Scan_State);\n-               Scan; -- past identifier\n+         if Token = Tok_Identifier then\n+            Save_Scan_State (Scan_State);\n+            Scan; -- past identifier\n \n-               if Token = Tok_Colon then\n-                  Restore_Scan_State (Scan_State);\n-                  Error_Msg_SC (\"component may not follow variant part\");\n-                  Discard_Junk_Node (P_Component_List);\n+            if Token = Tok_Colon then\n+               Restore_Scan_State (Scan_State);\n+               Error_Msg_SC (\"component may not follow variant part\");\n+               Discard_Junk_Node (P_Component_List);\n \n-               elsif Token = Tok_Case then\n-                  Restore_Scan_State (Scan_State);\n-                  Error_Msg_SC (\"only one variant part allowed in a record\");\n-                  Discard_Junk_Node (P_Component_List);\n+            elsif Token = Tok_Case then\n+               Restore_Scan_State (Scan_State);\n+               Error_Msg_SC (\"only one variant part allowed in a record\");\n+               Discard_Junk_Node (P_Component_List);\n \n-               else\n-                  Restore_Scan_State (Scan_State);\n-               end if;\n+            else\n+               Restore_Scan_State (Scan_State);\n             end if;\n          end if;\n       end if;"}, {"sha": "5aa090446b6c54049093fe63973216887b3287f2", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=32bba3c9d848935dbec4b070093574a34b0817a4", "patch": "@@ -1505,8 +1505,8 @@ package body Sem_Ch12 is\n                      Check_Overloaded_Formal_Subprogram (Formal);\n                   end if;\n \n-                  --  If there is no corresponding actual, this may be case of\n-                  --  partial parameterization, or else the formal has a\n+                  --  If there is no corresponding actual, this may be case\n+                  --  of partial parameterization, or else the formal has a\n                   --  default or a box.\n \n                   if No (Match) and then Partial_Parameterization then"}, {"sha": "6289f1c577819d899ecda23a22f3dfffe0b9343a", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=32bba3c9d848935dbec4b070093574a34b0817a4", "patch": "@@ -2999,7 +2999,7 @@ package body Sem_Ch3 is\n            and then No (Corresponding_Generic_Association (Parent (Obj_Id)))\n          then\n             Error_Msg_N\n-              (\"constant cannot be volatile (SPARK RM 7.1.3(4))\", Obj_Id);\n+              (\"constant cannot be volatile (SPARK RM 7.1.3(6))\", Obj_Id);\n          end if;\n \n       else pragma Assert (Ekind (Obj_Id) = E_Variable);\n@@ -3016,7 +3016,7 @@ package body Sem_Ch3 is\n             then\n                Error_Msg_N\n                  (\"non-volatile variable & cannot have volatile components \"\n-                  & \"(SPARK RM 7.1.3(6))\", Obj_Id);\n+                  & \"(SPARK RM 7.1.3(7))\", Obj_Id);\n \n             --  The declaration of a volatile object must appear at the library\n             --  level."}, {"sha": "52845b4e511f4b4c766977b3c4463289f739f007", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=32bba3c9d848935dbec4b070093574a34b0817a4", "patch": "@@ -1094,13 +1094,13 @@ package body Sem_Ch4 is\n             --  indexed component and analyze as container indexing.\n \n             if not Is_Overloadable (Nam_Ent) then\n-               if Present (\n-                 Find_Value_Of_Aspect\n-                    (Etype (Nam_Ent), Aspect_Constant_Indexing))\n+               if Present\n+                    (Find_Value_Of_Aspect\n+                       (Etype (Nam_Ent), Aspect_Constant_Indexing))\n                then\n                   Replace (N,\n                     Make_Indexed_Component (Sloc (N),\n-                      Prefix => Nam,\n+                      Prefix      => Nam,\n                       Expressions => Parameter_Associations (N)));\n \n                   if Try_Container_Indexing (N, Nam, Expressions (N)) then\n@@ -1112,6 +1112,7 @@ package body Sem_Ch4 is\n                else\n                   No_Interpretation;\n                end if;\n+\n                return;\n             end if;\n          end if;\n@@ -7065,7 +7066,6 @@ package body Sem_Ch4 is\n             while Present (Disc) loop\n                declare\n                   Elmt_Type : Entity_Id;\n-\n                begin\n                   if Has_Implicit_Dereference (Disc) then\n                      Elmt_Type := Designated_Type (Etype (Disc));\n@@ -7098,6 +7098,7 @@ package body Sem_Ch4 is\n             Set_Etype (Indexing, Any_Type);\n             while Present (It.Nam) loop\n                Analyze_One_Call (Indexing, It.Nam, False, Success);\n+\n                if Success then\n                   Set_Etype (Name (Indexing), It.Typ);\n                   Set_Entity (Name (Indexing), It.Nam);\n@@ -7122,6 +7123,7 @@ package body Sem_Ch4 is\n \n                   exit;\n                end if;\n+\n                Get_Next_Interp (I, It);\n             end loop;\n          end;"}, {"sha": "d4ca288586f332352b09a80183b63fbb854f6af3", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=32bba3c9d848935dbec4b070093574a34b0817a4", "patch": "@@ -1855,6 +1855,9 @@ package body Sem_Ch5 is\n \n       else\n          Set_Ekind (Def_Id, E_Loop_Parameter);\n+         if Ada_Version < Ada_2012 then\n+            Error_Msg_N (\"container iterators are an Ada 2012 feature\", N);\n+         end if;\n \n          --  OF present\n "}, {"sha": "2b24d507f81e3e20ffb1f20dbe9782bdcfe8f9cc", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=32bba3c9d848935dbec4b070093574a34b0817a4", "patch": "@@ -7966,12 +7966,6 @@ package body Sem_Prag is\n                      end if;\n                   end if;\n \n-                  --  All interfaced procedures need an external symbol created\n-                  --  for them since they are always referenced from another\n-                  --  object file.\n-\n-                  Set_Is_Public (Def_Id);\n-\n                   --  Verify that the subprogram does not have a completion\n                   --  through a renaming declaration. For other completions the\n                   --  pragma appears as a too late representation.\n@@ -9425,6 +9419,12 @@ package body Sem_Prag is\n          else\n             Set_Is_Imported (E);\n \n+            --  For subprogram, set Import_Pragma field\n+\n+            if Is_Subprogram (E) then\n+               Set_Import_Pragma (E, N);\n+            end if;\n+\n             --  If the entity is an object that is not at the library level,\n             --  then it is statically allocated. We do not worry about objects\n             --  with address clauses in this context since they are not really"}, {"sha": "461e251e2b31c272616582bfe1139d1f468d669f", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=32bba3c9d848935dbec4b070093574a34b0817a4", "patch": "@@ -7540,7 +7540,6 @@ package body Sem_Res is\n       Pref     : Node_Id;\n \n    begin\n-\n       --  In ASIS mode, propagate the information about the indices back to\n       --  to the original indexing node. The generalized indexing is either\n       --  a function call, or a dereference of one. The actuals include the\n@@ -7550,9 +7549,9 @@ package body Sem_Res is\n          Resolve (Indexing, Typ);\n          Set_Etype  (N, Etype (Indexing));\n          Set_Is_Overloaded (N, False);\n+\n          Call := Indexing;\n-         while Nkind_In (Call,\n-            N_Explicit_Dereference, N_Selected_Component)\n+         while Nkind_In (Call, N_Explicit_Dereference, N_Selected_Component)\n          loop\n             Call := Prefix (Call);\n          end loop;"}, {"sha": "9b1c270d0577ee508e6307ba3f9b4d29c0ff52b2", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32bba3c9d848935dbec4b070093574a34b0817a4/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=32bba3c9d848935dbec4b070093574a34b0817a4", "patch": "@@ -1278,13 +1278,13 @@ package Sinfo is\n    --    ali file.\n \n    --  Generalized_Indexing (Node4-Sem)\n-   --  Generalized_Indexing is set in Indexed_Component nodes that are Ada 2012\n-   --  container indexing operations. The value of the attribute is a function\n-   --  call (possibly dereferenced) that corresponds to the proper expansion\n-   --  of the source indexing operation. Before expansion, the source node\n-   --  is rewritten as the resolved generalized indexing. In ASIS mode, the\n-   --  expansion does not take place, so that the source is preserved and\n-   --  properly annotated with types.\n+   --    Present in N_Indexed_Component nodes. Set for Indexed_Component nodes\n+   --    that are Ada 2012 container indexing operations. The value of the\n+   --    attribute is a function call (possibly dereferenced) that corresponds\n+   --    to the proper expansion of the source indexing operation. Before\n+   --    expansion, the source node is rewritten as the resolved generalized\n+   --    indexing. In ASIS mode, the expansion does not take place, so that\n+   --    the source is preserved and properly annotated with types.\n \n    --  Generic_Parent (Node5-Sem)\n    --    Generic_Parent is defined on declaration nodes that are instances. The\n@@ -8924,6 +8924,7 @@ package Sinfo is\n \n    function Generalized_Indexing\n      (N : Node_Id) return Node_Id;    -- Node4\n+\n    function Generic_Associations\n      (N : Node_Id) return List_Id;    -- List3\n \n@@ -10933,7 +10934,7 @@ package Sinfo is\n        (1 => True,    --  Expressions (List1)\n         2 => False,   --  unused\n         3 => True,    --  Prefix (Node3)\n-        4 => False,    --  Generalized_Indexing (Node4-Sem)\n+        4 => False,   --  Generalized_Indexing (Node4-Sem)\n         5 => False),  --  Etype (Node5-Sem)\n \n      N_Slice =>"}]}