{"sha": "0e5921e8a0f347a7de29c7347738db8de5769a88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU1OTIxZThhMGYzNDdhN2RlMjljNzM0NzczOGRiOGRlNTc2OWE4OA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-09-07T00:37:14Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-09-07T00:37:14Z"}, "message": "Integrated preprocessor.\n\ntop level:\n\t* Makefile.in: Remove all references to c-parse.gperf,\n\tc-gperf.h, and c-parse.h.  Remove -d from yacc command line\n\tgenerating c-parse.c.  Update dependencies.\n\t* c-parse.gperf, c-gperf.h: Delete.\n\n\t* c-common.c: Don't define parse_options, cpp_token, yy_cur,\n\tyy_lim, or yy_get_token.  Don't define get_directive_line if\n\tUSE_CPPLIB.\n\t* c-common.h: Add multiple include guard.  Define RID values\n\tfor every keyword in C, C++, and Objective C.  Put all the\n\tmodifiers first.\n\t(struct c_fileinfo, get_fileinfo, dump_time_statistics): New.\n\t* c-decl.c (c_decode_option): Handle -lang-objc here.\n\t(print_lang_identifier): Handle C_IS_RESERVED_WORD case.\n\t(grokdeclarator): Adjust for new RID scheme.\n\t(extract_interface_info): New stub.\n\t* c-lang.c: Don't declare yy_cur or parse_options.\n\t(lang_init_options): Call cpp_init.  Don't call\n\tcpp_options_init.\n\t(lang_init): Don't call check_newline if USE_CPPLIB.\n\n\t* c-lex.c: Don't include c-parse.h.  Do include timevar.h.\n\tElide lots of unnecessary code if USE_CPPLIB.  Delete code\n\trendered unnecessary by new architecture.  Move routines not\n\tshared with C++ to c-parse.in.  Maintain a local idea of the\n\tline number.    Handle C++ as well as C.\n\t[USE_CPPLIB]: Declare and register callbacks for #ident and\n\tfor entering/leaving files.\n\t(init_c_lex, c_lex): Are now the entry points to this file.\n\t(check_newline): Break out directive handling to\n\tprocess_directive.\n\t(read_ucs, is_extended_char, utf8_extend_token): Moved here\n\tfrom C++ front end.\n\t(readescape, parse_float): Overhaul.\n\t(lex_number, lex_string, lex_charconst): Break out of c_lex\n\t(n'ee yylex).\n\t(get_fileinfo, update_header_times, dump_one_header,\n\tdump_time_statistics): New and/or moved here from C++.\n\tSupport per-file data needed by C++ and per-header timing\n\tstatistics (C++ only, at the moment).\n\t* c-lex.h: Update prototypes.  Add multiple include guard.\n\t* c-tree.h (struct lang_identifier): Add rid_code field.\n\t(C_IS_RESERVED_WORD, C_RID_CODE): New.\n\n\t* c-parse.in: Include c-pragma.h. Remove unnecesary calls to\n\treinit_parse_for_function and/or position_after_white_space.\n\t(save_filename, save_lineno): Look ahead before saving.\n\t(label -> identifier ':'): Save file and line before shifting ':'.\n\t(reservedwords): No need to call get_identifier.\n\t(init_parse, finish_parse, yyerror, yylex, yyprint,\n\tmake_pointer_declarator): Are now here for C/ObjC.\n\t(rid_to_yy): Conversion table from RID constants to Yacc codes.\n\n\t* c-pragma.c: Rewrite parsing logic to fit with cpplib's\n\t#pragma registry.  Provide dummy implementation of that\n\tinterface if !USE_CPPLIB.\n\t* c-pragma.h: Update to match.\n\n\t* flags.h: Add multiple include guard.\n\t(flag_detailed_statistics): Moved here from C++.\n\t* toplev.c: Define flag_detailed_statistics.\n\n\t* gcc.c (C specs): Use %(trad_capable_cpp) for -E|-M|-MM case\n\t#if USE_CPPLIB.\n\t* timevar.def (TV_CPP, TV_LEX): New.\n\t* timevar.h: Add multiple include guard.\n\n\t* objc/lang-specs.h: Use %(trad_capable_cpp) for -E|-M|-MM case\n\t#if USE_CPPLIB.\n\t* objc/objc-act.c: Don't mention yy_cur or parse_options.\n\tInitialize cpplib properly.  Force lineno to 0 after first\n\tcall to check_newline.  Don't handle -lang-objc here.\n\tMove forget_protocol_qualifiers and remember_protocol_qualifiers here.\n\ncp:\n\t* Make-lang.in, Makefile.in: Remove all references to input.c,\n\tgxx.gperf, and hash.h.  Add ../c-lex.o to C_OBJS.\n\t* gxx.gperf, hash.h, input.c: Delete.\n\t* lang-specs.h: Pass -lang-c++ to cc1plus so cpplib is\n\tinitialized properly.\n\n\t* class.c (fixup_pending_inline): Take a tree, not a\n\tstruct pending_inline *.  All callers changed.\n\t(init_class_processing): Set RID_PUBLIC, RID_PRIVATE,\n\tRID_PROTECTED entries in ridpointers[] array here.\n\t* decl.c (duplicate_decls): Do not refer to struct\n\tpending_inline.\n\t(record_builtin_type, init_decl_processing): Use RID_MAX not\n\tCP_RID_MAX.\n\t(grokdeclarator): Use C_IS_RESERVED_WORD.\n\t* decl2.c (lang_decode_option): Ignore -lang-c++ for sake of\n\tcpplib.\n\t(grok_x_components): Do not inspect pending_inlines chain.\n\n\t* cp-tree.h (struct lang_identifier): Add rid_code entry.\n\t(C_IS_RESERVED_WORD, C_RID_CODE, C_RID_YYCODE): New.\n\t(flag_no_gnu_keywords, flag_operator_names, rid_to_yy): Declare.\n\t(DEFARG_LENGTH, struct pending_inline, TIME_IDENTIFIER_TIME,\n\tTIME_IDENTIFIER_FILEINFO): Kill.\n\tUpdate prototypes.\n\t* lex.h: Expunge cp_rid.  Rewrite RIDBIT macros to use just a\n\tsingle 32-bit word.\n\t* parse.y: Call do_pending_inlines unconditionally.\n\treinit_parse_for_method is now snarf_method.  fn.defpen is no\n\tlonger necessary.  Remove unnecessary <itype> annotation on\n\tSCOPE.  Do not refer to end_of_file or struct pending_inline.\n\t* semantics.c (begin_inline_definitions): Call\n\tdo_pending_inlines unconditionally.\n\n\t* lex.c: Remove all code now shared with C front end.\n\tInitialize cpplib properly if USE_CPPLIB.  Put reserved words\n\tinto the get_identifier table.  Rewrite pragma handling to\n\twork with the registry.  Move code to save tokens for later\n\tprocessing to spew.c.\n\n\t* spew.c: Rewrite everything in terms of token streams instead\n\tof text.  Move routines here from lex.c / input.c as\n\tappropriate.  GC-mark trees hanging off the pending inlines\n\tchain.\n\ntestsuite:\n\t* g++.old-deja/g++.benjamin/13478.C: Put meaningful tags on\n\tERROR markers.\n\t* g++.old-deja/g++.brendan/crash8.C: Move ERROR marker up one line.\n\t* gcc.dg/c99-array-nonobj-1.c: Don't expect func[] cases to fail.\n\t* gcc.dg/wtr-label-1.c: Don't use unconstrained .* in error regexps.\n\t* gcc.dg/wtr-suffix-1.c: Correct error regexps.\n\t* gcc.dg/cpp/unc1.c, gcc.dg/cpp/unc2.c, gcc.dg/cpp/unc3.c:\n\tPreprocess only.\n\t* gcc.dg/cpp/unc4.c: Adjust line number in dg-error line.\n\t* gcc.dg/noncompile/const-ll-1.c: Generalize error regexp.\n\nFrom-SVN: r36216", "tree": {"sha": "548c8127a4b2fd1bf95771627c7e8abb3763d577", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/548c8127a4b2fd1bf95771627c7e8abb3763d577"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e5921e8a0f347a7de29c7347738db8de5769a88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e5921e8a0f347a7de29c7347738db8de5769a88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e5921e8a0f347a7de29c7347738db8de5769a88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e5921e8a0f347a7de29c7347738db8de5769a88/comments", "author": null, "committer": null, "parents": [{"sha": "26aa75bef97454f65b437067cf77a5a0255934a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26aa75bef97454f65b437067cf77a5a0255934a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26aa75bef97454f65b437067cf77a5a0255934a3"}], "stats": {"total": 12718, "additions": 5092, "deletions": 7626}, "files": [{"sha": "0ac5556e06504ddd8d61f2f2659b6e9749af7c51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 122, "deletions": 44, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -1,3 +1,81 @@\n+2000-09-06  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\tIntegrated preprocessor.\n+\n+\t* Makefile.in: Remove all references to c-parse.gperf,\n+\tc-gperf.h, and c-parse.h.  Remove -d from yacc command line\n+\tgenerating c-parse.c.  Update dependencies.\n+\t* c-parse.gperf, c-gperf.h: Delete.\n+\n+\t* c-common.c: Don't define parse_options, cpp_token, yy_cur,\n+\tyy_lim, or yy_get_token.  Don't define get_directive_line if\n+\tUSE_CPPLIB.\n+\t* c-common.h: Add multiple include guard.  Define RID values\n+\tfor every keyword in C, C++, and Objective C.  Put all the\n+\tmodifiers first.\n+\t(struct c_fileinfo, get_fileinfo, dump_time_statistics): New.\n+\t* c-decl.c (c_decode_option): Handle -lang-objc here.\n+\t(print_lang_identifier): Handle C_IS_RESERVED_WORD case.\n+\t(grokdeclarator): Adjust for new RID scheme.\n+\t(extract_interface_info): New stub.\n+\t* c-lang.c: Don't declare yy_cur or parse_options.\n+\t(lang_init_options): Call cpp_init.  Don't call\n+\tcpp_options_init.\n+\t(lang_init): Don't call check_newline if USE_CPPLIB.\n+\n+\t* c-lex.c: Don't include c-parse.h.  Do include timevar.h.\n+\tElide lots of unnecessary code if USE_CPPLIB.  Delete code\n+\trendered unnecessary by new architecture.  Move routines not\n+\tshared with C++ to c-parse.in.  Maintain a local idea of the\n+\tline number.    Handle C++ as well as C.\n+\t[USE_CPPLIB]: Declare and register callbacks for #ident and\n+\tfor entering/leaving files.\n+\t(init_c_lex, c_lex): Are now the entry points to this file.\n+\t(check_newline): Break out directive handling to\n+\tprocess_directive.\n+\t(read_ucs, is_extended_char, utf8_extend_token): Moved here\n+\tfrom C++ front end.\n+\t(readescape, parse_float): Overhaul.\n+\t(lex_number, lex_string, lex_charconst): Break out of c_lex\n+\t(n'ee yylex).\n+\t(get_fileinfo, update_header_times, dump_one_header,\n+\tdump_time_statistics): New and/or moved here from C++.\n+\tSupport per-file data needed by C++ and per-header timing\n+\tstatistics (C++ only, at the moment).\n+\t* c-lex.h: Update prototypes.  Add multiple include guard.\n+\t* c-tree.h (struct lang_identifier): Add rid_code field.\n+\t(C_IS_RESERVED_WORD, C_RID_CODE): New.\n+\n+\t* c-parse.in: Include c-pragma.h. Remove unnecesary calls to\n+\treinit_parse_for_function and/or position_after_white_space.\n+\t(save_filename, save_lineno): Look ahead before saving.\n+\t(label -> identifier ':'): Save file and line before shifting ':'.\n+\t(reservedwords): No need to call get_identifier.\n+\t(init_parse, finish_parse, yyerror, yylex, yyprint,\n+\tmake_pointer_declarator): Are now here for C/ObjC.\n+\t(rid_to_yy): Conversion table from RID constants to Yacc codes.\n+\n+\t* c-pragma.c: Rewrite parsing logic to fit with cpplib's\n+\t#pragma registry.  Provide dummy implementation of that\n+\tinterface if !USE_CPPLIB.\n+\t* c-pragma.h: Update to match.\n+\n+\t* flags.h: Add multiple include guard.\n+\t(flag_detailed_statistics): Moved here from C++.\n+\t* toplev.c: Define flag_detailed_statistics.\n+\n+\t* gcc.c (C specs): Use %(trad_capable_cpp) for -E|-M|-MM case\n+\t#if USE_CPPLIB.\n+\t* timevar.def (TV_CPP, TV_LEX): New.\n+\t* timevar.h: Add multiple include guard.\n+\n+\t* objc/lang-specs.h: Use %(trad_capable_cpp) for -E|-M|-MM case\n+\t#if USE_CPPLIB.\n+\t* objc/objc-act.c: Don't mention yy_cur or parse_options.\n+\tInitialize cpplib properly.  Force lineno to 0 after first\n+\tcall to check_newline.  Don't handle -lang-objc here.\n+\tMove forget_protocol_qualifiers and remember_protocol_qualifiers here.\n+\n 2000-09-06  David Edelsohn  <edelsohn@gnu.org>\n \n \t* rs6000.md: Correct function unit definitions for cr_logical and\n@@ -171,8 +249,8 @@\n \n 2000-09-05  Bruce Korb  <bkorb@gnu.org>\n \n-        * fixinc/fixincl.c (load_file): always read header files\n-        with sizes that are a multiple of the page size.\n+\t* fixinc/fixincl.c (load_file): always read header files\n+\twith sizes that are a multiple of the page size.\n \t& use libiberty's getpagesize for determining that.\n \n 2000-09-05  Alexandre Oliva  <aoliva@redhat.com>\n@@ -202,7 +280,7 @@ Wed Jan  1 00:23:59 MET 1997  Jan Hubicka  <jh@suse.cz>\n \n Wed Jan  1 00:17:32 MET 1997  Jan Hubicka  <jh@suse.cz>\n \n-\t* i386.md (pushsi2, pushhi2, pophi2, swapsf, swapdf, \n+\t* i386.md (pushsi2, pushhi2, pophi2, swapsf, swapdf,\n \tumulsi3_highpart, smulsi3_highpart, testqi_ccno_1, xorqi_ext_1):\n \tAdd '*' to insn pattern name.\n \n@@ -222,7 +300,7 @@ Wed Jan  1 00:17:32 MET 1997  Jan Hubicka  <jh@suse.cz>\n \n 2000-09-03  Richard Earnshaw  <rearnsha@arm.com>\n \n-\t* arm.c (final_prescan_insn): If the form of a jump insn isn't \n+\t* arm.c (final_prescan_insn): If the form of a jump insn isn't\n \trecognized, don't try to conditionally execute it.\n \n Sun Sep  3 13:10:56 2000  Denis Chertykov  <denisc@overta.ru>\n@@ -316,7 +394,7 @@ Sat Sep  2 13:58:23 2000  Marek Michalkiewicz <marekm@linux.org.pl>\n \t(prepare_move_operands): Call emit_pic_move or\n \temit_pic_const_move if appropriate.\n \t(output_far_jump): For PIC, use braf and output long offset.\n-\t(machine_dependent_reorg): \n+\t(machine_dependent_reorg):\n \t(sh_expand_prologue): Save and initialize the PIC register.\n \t(sh_expand_epilogue): Restore it.\n \t(initial_elimination_offset): Account for it.\n@@ -349,7 +427,7 @@ Sat Sep  2 13:58:23 2000  Marek Michalkiewicz <marekm@linux.org.pl>\n \n \t* fix-header.c (write_rbrac): Add putc and getc to list of\n \tfunctions to protect against prior definition as a macro.\n- \n+\n 2000-09-01  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* c-common.h (enum c_tree_index): Add CTI_C_SIZE_TYPE.\n@@ -414,18 +492,18 @@ Fri Sep  1 10:59:47 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n 2000-09-01  Andrew Haley  <aph@redhat.com>\n \n-        * dwarf2out.c (stack_adjust_offset): New function.\n-        (dwarf2out_stack_adjust): Break out stack adjust logic into\n-        new stack_adjust_offset function.  Look inside parallels and\n-        sequences for stack adjustments.\n+\t* dwarf2out.c (stack_adjust_offset): New function.\n+\t(dwarf2out_stack_adjust): Break out stack adjust logic into\n+\tnew stack_adjust_offset function.  Look inside parallels and\n+\tsequences for stack adjustments.\n \n 2000-08-31  Jeff Law <law@cygnus.com>\n \n \t* arm.md: Use no_new_pseudos to determine when it is safe\n \tto create new pseudo registers.\n \n-        * arm.c (legitimize_pic_address): Use no_new_pseudos to determine\n-        when we can safely allocate new registers.\n+\t* arm.c (legitimize_pic_address): Use no_new_pseudos to determine\n+\twhen we can safely allocate new registers.\n \n 2000-08-31  Geoffrey Keating  <geoffk@cygnus.com>\n \n@@ -441,7 +519,7 @@ Fri Sep  1 10:59:47 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t* toplev.c (rest_of_compilation): No CONCATs after RTL generation.\n \n 2000-08-22  Philipp Thomas  <pthomas@suse.de>\n-            Masanobu Yuhara <yuhara@flab.fujitsu.co.jp>\n+\t    Masanobu Yuhara <yuhara@flab.fujitsu.co.jp>\n \n \t* gmicro.h (TARGET_SWITCHES): Add descriptions and mark them\n \tfor translation.\n@@ -496,7 +574,7 @@ Tue Aug 29 22:09:59 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* c-common.c (declare_function_name): Use func_id_node,\n \tfunction_id_node, and pretty_function_id_node.  Do not make\n-\t__func__ visible at file scope.   \n+\t__func__ visible at file scope.\n \t* c-common.h (c_tree_index): Add CTI_FUNCTION_ID,\n \tCTI_PRETTY_FUNCTION_ID, and CTI_FUNC_ID.\n \t(function_id_node, pretty_function_id_node, func_id_node): New\n@@ -509,7 +587,7 @@ Tue Aug 29 22:09:59 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* c-decl.c (pushdecl, implicit_decl_warning): Constify a char *.\n \t* c-pragma.h (struct weak_syms): Constify name and value members.\n-\t(add_weak): Constify arguments.   \n+\t(add_weak): Constify arguments.\n \n \t* calls.c (special_function_p): Constify a char *.\n \t(expand_call): Remove variable which is initialized and then\n@@ -590,7 +668,7 @@ Tue Aug 29 22:29:58 2000  Denis Chertykov  <denisc@overta.ru> & Marek Michalkiew\n \t(output_movqi): New prototype.\n \t(output_movhi): New prototype.\n \t(call_insn_operand): Likewise.\n-\t(final_prescan_insn): Likewise.\t\n+\t(final_prescan_insn): Likewise.\n \t(avr_simplify_comparision_p): Likewise.\n \t(avr_normalize_condition): Likewise.\n \t(compare_eq_p): Likewise.\n@@ -800,7 +878,7 @@ Tue Aug 29 15:17:54 EDT 2000  John Wehle  (john@feith.com)\n \t(gen_internal_sym, output_die_symbol, output_symbolic_ref): New fns.\n \t(output_die): Call output_die_symbol and AT_ref_external.\n \t(output_comdat_comp_unit): New fn, split out from...\n-\t(dwarf2out_finish): ...here.  Also call add_sibling_attributes for \n+\t(dwarf2out_finish): ...here.  Also call add_sibling_attributes for\n \tsecondary CUs.\n \t(output_pubnames, output_aranges): Abort if we see entries from\n \tsecondary CUs.\n@@ -928,9 +1006,9 @@ Fri Aug 25 12:52:49 EDT 2000  John Wehle  (john@feith.com)\n \t(flow_loops_find): Call flow_loop_entry_edges_find.\n \t(flow_loop_dump): Dump entry_edges list.\n \t(flow_loops_free): Free entry_edges.\n-\t\n+\n 2000-08-26  Michael Hayes  <mhayes@cygnus.com>\n-\t\n+\n \t* loop.c (loop_dump_aux, debug_loop): New functions.\n \t(LOOP_BLOCK_NUM_1, LOOP_BLOCK_NUM, LOOP_INSN_UID): New macros.\n \n@@ -943,14 +1021,14 @@ Fri Aug 25 12:52:49 EDT 2000  John Wehle  (john@feith.com)\n \n \t* toplev.c (rest_of_compilation): Add NULL callback function pointer\n \tto call to flow_loops_dump.\n-\t\n+\n 2000-08-26  Michael Hayes  <mhayes@cygnus.com>\n \n \t* loop.c (count_loop_regs_set): Replace start and end arguments\n \twith loop argument.  All callers udated.\n-\t\n+\n 2000-08-26  Michael Hayes  <mhayes@cygnus.com>\n-\t\n+\n \t* loop.c (constant_high_bytes): Delete.\n \n 2000-08-26  Michael Hayes  <mhayes@cygnus.com>\n@@ -1000,7 +1078,7 @@ Fri 25-Aug-2000 08:03:27 BST  Neil Booth  <NeilB@earthling.net>\n \t* gcc/c-typeck.c (decl_constant_value): Don't check ITERATOR_P.\n \t(readonly_warning): Likewise.\n \t* gcc/tree.h (ITERATOR_BOUND_P): Don't mention it.\n-\t\t\n+\n 2000-08-24  Jim Wilson  <wilson@cygnus.com>\n \n \t* c-common.c (decl_attributes, case A_ALIGN): Revert last change.\n@@ -1012,7 +1090,7 @@ Fri 25-Aug-2000 08:03:27 BST  Neil Booth  <NeilB@earthling.net>\n \n 2000-08-24  Zack Weinberg  <zack@wolery.cumb.org>\n \n-\t* ggc-page.c (alloc_page): If HAVE_MMAP_ANYWHERE and we're  \n+\t* ggc-page.c (alloc_page): If HAVE_MMAP_ANYWHERE and we're\n \tasked for one page, allocate GGC_QUIRE_SIZE of them and put\n \tthe extras on the free list.\n \t(release_pages): Clean up.\n@@ -1032,7 +1110,7 @@ Fri 25-Aug-2000 08:03:27 BST  Neil Booth  <NeilB@earthling.net>\n \t(fr_register_operand, grfr_register_operand): New.\n \t(gr_nonimmediate_operand, grfr_nonimmediate_operand): New.\n \t(grfr_reg_or_8bit_operand): New.\n-\t(gr_reg_or_0_operand): Rename from reg_or_0_operand and \n+\t(gr_reg_or_0_operand): Rename from reg_or_0_operand and\n \tuse gr_register_operand.\n \t(gr_reg_or_5bit_operand, gr_reg_or_6bit_operand): Likewise.\n \t(gr_reg_or_8bit_operand, gr_reg_or_8bit_adjusted_operand): Likewise.\n@@ -1059,7 +1137,7 @@ Fri 25-Aug-2000 08:03:27 BST  Neil Booth  <NeilB@earthling.net>\n \t* config/ia64/ia64.md (*): Use gr_register_operand and co.\n \t(mf): Indicate that we set memory as well as use it.\n \t(fetchadd_acq_si): Show memory being modified as well.\n-\t(fetchadd_acq_di, cmpxchg_acq_si, cmpxchg_acq_di): Likewise. \n+\t(fetchadd_acq_di, cmpxchg_acq_si, cmpxchg_acq_di): Likewise.\n \t(val_compare_and_swap_si, val_compare_and_swap_di): Remove.\n \t(lock_test_and_set_si, lock_test_and_set_di): Remove.\n \t(fetch_and_add_si, fetch_and_sub_si, fetch_and_or_si): Remove.\n@@ -1082,7 +1160,7 @@ Fri 25-Aug-2000 08:03:27 BST  Neil Booth  <NeilB@earthling.net>\n \n \t* dwarf2out.c (AT_flag, AT_int, AT_unsigned, AT_string, AT_ref,\n \tAT_loc, AT_addr, AT_lbl): Abort on unsuitable input.\n-\t(get_AT_low_pc, get_AT_hi_pc, get_AT_string, get_AT_flag, \n+\t(get_AT_low_pc, get_AT_hi_pc, get_AT_string, get_AT_flag,\n \tget_AT_unsigned, get_AT_ref): Don't call them if get_AT fails.\n \n 2000-08-24  Greg McGary  <greg@mcgary.org>\n@@ -1286,7 +1364,7 @@ Tue Aug 22 21:21:05 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t(THUMB_FUNCTION_START): New macro:  Common code at the start of\n \tThumb functions.\n \t(__divsi3, __udivsi3, __modsi3, __umodsi3): Use new macros.\n-\t\n+\n Tue Aug 22 20:34:52 2000  Kaz Kojima <kkojima@rr.iij4u.or.jp>\n \n \t* config/sh/sh.md (cmpeqdi_t splitter): Fix a reverse testing.\n@@ -1327,7 +1405,7 @@ Tue Aug 22 20:34:52 2000  Kaz Kojima <kkojima@rr.iij4u.or.jp>\n \n \t* Makefile.in (OBJS): Add dependence.o.\n \t* dependence.c: New file.\n-\t\n+\n 2000-08-22  Alexandre Oliva  <aoliva@redhat.com>, John David Anglin  <dave.anglin@nrc.ca>\n \n \t* calls.c (check_sibcall_argument_overlap_1): Adjust for\n@@ -1459,10 +1537,10 @@ Tue Aug 22 02:31:26 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t* mips/linux.h (LINK_SPEC): Use %(endian_spec).\n \n \t* mips/mips.h: Change LINKER_ENDIAN_SPEC to ENDIAN_SPEC\n-\tand linker_endian_spec to endian_spec. \n+\tand linker_endian_spec to endian_spec.\n \t(ENDIAN_SPEC): Add %{EB} and %{EL}.\n \t(LINK_SPEC): Remove %{EB} and %{EL}.\n-\t(ASM_SPEC): Likewise.  Use %(endian_spec). \n+\t(ASM_SPEC): Likewise.  Use %(endian_spec).\n \n 2000-08-21  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n@@ -1676,7 +1754,7 @@ Fri Aug 18 14:23:18 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(fixup_match_1): Likewise.\n \t(fixup_match_1, combine_stack_adjustments_for_block): Add casts to\n \tavoid signed/unsigned warnings.\n-\t\n+\n \t* function.c (fixup_var_refs_1, case MEM): Update CODE after\n \tupdating X.\n \n@@ -1869,7 +1947,7 @@ Tue Aug 15 17:33:05 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \texpands.\n \t(arm_buneq, arm_bltgt, arm_buneq_reversed, arm_bltgt_reveresed): New\n \tpatterns.\n-\t\n+\n Tue Aug 15 00:36:36 2000  Ovidiu Predescu  <ovidiu@cup.hp.com>\n \n \t* gthr-posix.h: Conditionally include <sched.h>; include\n@@ -1939,7 +2017,7 @@ Tue Aug 15 00:36:36 2000  Ovidiu Predescu  <ovidiu@cup.hp.com>\n 2000-08-14  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* cse.c (fold_rtx): Avoid empty body in an if-statement.\n-\t\n+\n \t* doloop.c (doloop_iterations_max, doloop_modify): Avoid using the\n \t`U' integer constant suffix.\n \n@@ -1977,7 +2055,7 @@ Tue Aug 15 00:36:36 2000  Ovidiu Predescu  <ovidiu@cup.hp.com>\n \n \t* configure.in: Accept *-*-linux* not just *-*-linux-gnu*.\n \t* fixinc/inclhack.def: Likewise.\n-\t* fixinc/mkfixinc.sh: Likewise. \n+\t* fixinc/mkfixinc.sh: Likewise.\n \t* configure: Regenerate.\n \t* fixinc/fixincl.x: Regenerate.\n \t* install.texi: Document equivalence of linux and linux-gnu.\n@@ -2067,7 +2145,7 @@ Mon Aug 14 18:51:44 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t(do_restore): Likewise.\n \t(gen_movdi_x, gen_fr_spill_x, gen_fr_restore_x): New.\n \t(ia64_expand_prologue, ia64_expand_epilogue): Use them.\n-\t(rtx_needs_barrier): Track actual bit manipulation for \n+\t(rtx_needs_barrier): Track actual bit manipulation for\n \tar.unat moves, gr_spill, and gr_restore.\n \t(emit_insn_group_barriers): Special case gr_spill/gr_restore.\n \t(process_set): Don't handle varargs spills.\n@@ -2080,7 +2158,7 @@ Mon Aug 14 18:51:44 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t* config/ia64/ia64.h (PROMOTE_MODE): Only extend to SImode.\n \n 2000-08-11  Mark Elbrecht  <snowball3@bigfoot.com>\n- \n+\n \t* gcc.texi (The Configuration File): Document\n \tCOLLECT2_HOST_INITIALIZATION, GCC_DRIVER_HOST_INITIALIZATION, and\n \tUPDATE_PATH_HOST_CANONICALIZATION.\n@@ -2281,7 +2359,7 @@ Thu Aug 10 00:11:04 2000  Ovidiu Predescu  <ovidiu@cup.hp.com>\n 2000-08-08  David Edelsohn  <edelsohn@gnu.org>\n \n \t* rs6000.c (optimization_options): Decorate 'level' as\n-\tATTRIBUTE_UNUSED. \n+\tATTRIBUTE_UNUSED.\n \t(mask64_operand): Remove sign-extend thinko.\n \t(rldic_operand): New function.\n \t(load_multiple_operation): regno's are unsigned ints.\n@@ -2346,7 +2424,7 @@ Thu Aug 10 00:11:04 2000  Ovidiu Predescu  <ovidiu@cup.hp.com>\n \t(ia64_encode_section_info): Silence signed/unsigned warnings.\n \t(spill_offset, sp_offset, spill_offset_emitted): Remove.\n \t(tmp_reg, tmp_saved): Remove.\n-\t(process_set): Rewrite to expect complicated bits via \n+\t(process_set): Rewrite to expect complicated bits via\n \tREG_FRAME_RELATED_EXPR.\n \t(ia64_expand_fetch_and_op): Use emit_move_insn; be explicit\n \tin the use of ar.ccv; never set RTX_UNCHANGING_P.\n@@ -2436,7 +2514,7 @@ Thu Aug 10 00:11:04 2000  Ovidiu Predescu  <ovidiu@cup.hp.com>\n \n \t* mn10300.md: Use nonimmediate_operand instead of general_operand\n \ton output operands.\n-\t\n+\n \t* mn10300.h (PREFERRED_RELOAD_CLASS): Limit memory reloads.\n \n 2000-08-07  Alexandre Oliva  <aoliva@redhat.com>\n@@ -2578,7 +2656,7 @@ Sun Aug  6 00:54:42 2000  Ovidiu Predescu  <ovidiu@cup.hp.com>\n \n \t* tree.c (tree_expr_nonnegative_p): Move to...\n \t* fold-const.c: ... here.  Also handle BIND_EXPR and RTL_EXPR.\n-\t(rtl_expr_nonnegative_p): New.                                \n+\t(rtl_expr_nonnegative_p): New.\n \t* tree.h: Add prototype for rtl_expr_nonnegative_p.\n \n \t* real.h (CONST_DOUBLE_LOW, CONST_DOUBLE_HIGH, CONST_DOUBLE_MEM,\n@@ -2880,9 +2958,9 @@ Fri Aug  4 11:43:49 2000  John Wehle  (john@feith.com)\n \n Fri Aug  4 06:53:46 2000  Clinton Popetz  <cpopetz@cygnus.com>\n \n-\t* (mips_legitimate_address_p): Don't allow register+offset              \n-\tif the offset is large and negative, and we are compiling               \n-\tfor 64 bit registers.                                                   \n+\t* (mips_legitimate_address_p): Don't allow register+offset\n+\tif the offset is large and negative, and we are compiling\n+\tfor 64 bit registers.\n \n 2000-08-04 Herman A.J. ten Brugge <Haj.Ten.Brugge@net.HCC.nl>\n "}, {"sha": "baa7b9d10ec5aebc4c61d9b0af48742cbea4d7d2", "filename": "gcc/Makefile.in", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -1080,27 +1080,19 @@ s-crt0:\t$(CRT0_S) $(MCRT0_S) $(GCC_PASSES) $(CONFIG_H)\n \n c-errors.o: c-errors.c $(CONFIG_H) system.h $(TREE_H) c-tree.h flags.h \\\n     diagnostic.h\n-c-parse.o : $(srcdir)/c-parse.c $(CONFIG_H) $(TREE_H) c-lex.h $(GGC_H) \\\n-    $(srcdir)/c-parse.h c-tree.h c-common.h input.h flags.h system.h \\\n-    toplev.h output.h\n+c-parse.o : $(srcdir)/c-parse.c $(CONFIG_H) $(TREE_H) c-lex.h $(GGC_H) intl.h \\\n+    c-tree.h c-common.h input.h flags.h system.h toplev.h output.h cpplib.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c $(srcdir)/c-parse.c\n-$(srcdir)/c-parse.h: $(srcdir)/c-parse.c\n+\n $(srcdir)/c-parse.c: $(srcdir)/c-parse.y\n-\tcd $(srcdir); $(BISON) $(BISONFLAGS) -d -o c-parse.c c-parse.y\n+\tcd $(srcdir); $(BISON) $(BISONFLAGS) -o c-parse.c c-parse.y\n $(srcdir)/c-parse.y: c-parse.in\n \techo '/*WARNING: This file is automatically generated!*/' >tmp-c-parse.y\n \tsed -e \"/^ifobjc$$/,/^end ifobjc$$/d\" \\\n \t  -e \"/^ifc$$/d\" -e \"/^end ifc$$/d\" \\\n \t  $(srcdir)/c-parse.in >>tmp-c-parse.y\n \t$(SHELL) $(srcdir)/move-if-change tmp-c-parse.y $(srcdir)/c-parse.y\n \n-$(srcdir)/c-gperf.h: c-parse.gperf\n-\tgperf -L C -F ', 0, 0' -p -j1 -i 1 -g -o -t -G -N is_reserved_word \\\n-\t   -k1,3,$$ $(srcdir)/c-parse.gperf >tmp-gperf.h || ( \\\n-\techo \"See $(website)/cvs.html#generated_files\" >&2 ; \\\n-\texit 1 )\n-\t $(SHELL) $(srcdir)/move-if-change tmp-gperf.h $(srcdir)/c-gperf.h\n-\n c-decl.o : c-decl.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) c-tree.h \\\n     c-common.h $(GGC_H) c-lex.h flags.h function.h output.h $(EXPR_H) \\\n     toplev.h defaults.h intl.h\n@@ -1109,8 +1101,8 @@ c-typeck.o : c-typeck.c $(CONFIG_H) system.h $(TREE_H) c-tree.h c-common.h \\\n c-lang.o : c-lang.c $(CONFIG_H) system.h $(TREE_H) c-tree.h c-common.h \\\n     $(GGC_H)  c-lex.h toplev.h diagnostic.h output.h function.h\n c-lex.o : c-lex.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) c-lex.h c-tree.h \\\n-    c-common.h $(srcdir)/c-parse.h $(srcdir)/c-gperf.h c-pragma.h input.h \\\n-    intl.h flags.h toplev.h output.h mbchar.h $(GGC_H)\n+    c-common.h c-pragma.h input.h intl.h flags.h toplev.h output.h \\\n+    mbchar.h $(GGC_H) cpplib.h $(SPLAY_TREE_H)\n c-aux-info.o : c-aux-info.c  $(CONFIG_H) system.h $(TREE_H) c-tree.h \\\n     c-common.h flags.h toplev.h\n c-convert.o : c-convert.c $(CONFIG_H) system.h $(TREE_H) flags.h toplev.h\n@@ -1769,8 +1761,7 @@ intl.o: intl.c intl.h gansidecl.h Makefile\n $(top_builddir)/intl/libintl.a: intl.all\n \n # Make sure all the headers are there for xgettext to scan.\n-$(INTL_TARGETS): $(srcdir)/c-gperf.h \\\n-    $(srcdir)/c-parse.c $(srcdir)/c-parse.h\n+$(INTL_TARGETS): $(srcdir)/c-parse.c\n \n intl.all intl.install intl.uninstall intl.distdir \\\n   intl.mostlyclean intl.clean intl.distclean intl.maintainer-clean:\n@@ -2238,8 +2229,7 @@ maintainer-clean:\n \t@echo 'deletes files that may need special tools to rebuild.'\n \t$(MAKE) INTL_DISTCLEAN= INTL_CLEAN= INTL_MOSTLYCLEAN= \\\n \t\tintl.maintainer-clean lang.maintainer-clean distclean\n-\t-rm -f c-parse.y c-gperf.h\n-\t-rm -f c-parse.c c-parse.h c-parse.output TAGS\n+\t-rm -f c-parse.y c-parse.c c-parse.output TAGS\n \t-rm -f cpp.info* cpp.??s cpp.*aux\n \t-rm -f gcc.info* gcc.??s gcc.*aux\n #\f\n@@ -2681,7 +2671,7 @@ distdir-cvs: force\n \n # This target exists to do the initial work before the language specific\n # stuff gets done.\n-distdir-start: doc $(srcdir)/INSTALL $(srcdir)/c-parse.y $(srcdir)/c-gperf.h \\\n+distdir-start: doc $(srcdir)/INSTALL $(srcdir)/c-parse.y \\\n   $(srcdir)/c-parse.c $(srcdir)/config.in $(srcdir)/version.c TAGS\n \t@case '$(USE_NLS)' in \\\n \tyes) ;; \\\n@@ -2760,7 +2750,7 @@ distdir: distdir-cvs distdir-start intl.distdir intl.distdir-fixup \\\n # creates a diff file between an older distribution and this one.\n # The -P option assumes this is GNU diff.\n diff:\n-\tdiff -rc2P -x c-parse.y -x c-parse.c -x c-parse.h -x c-gperf.h \\\n+\tdiff -rc2P -x c-parse.y -x c-parse.c \\\n \t   -x TAGS -x INSTALL -x configure -x config.in \\\n \t  -x \"gcc.??\" -x \"gcc.??s\" -x gcc.aux -x \"gcc.info*\" \\\n \t  -x \"cpp.??\" -x \"cpp.??s\" -x cpp.aux -x \"cpp.info*\" \\"}, {"sha": "efb81a375283f02d51ca22166ca3bea0e94f03dc", "filename": "gcc/c-common.c", "status": "modified", "additions": 2, "deletions": 102, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -35,8 +35,6 @@ Boston, MA 02111-1307, USA.  */\n #if USE_CPPLIB\n #include \"cpplib.h\"\n cpp_reader  parse_in;\n-cpp_options parse_options;\n-enum cpp_token cpp_token;\n #endif\n \n #undef WCHAR_TYPE_SIZE\n@@ -3518,105 +3516,7 @@ truthvalue_conversion (expr)\n   return build_binary_op (NE_EXPR, expr, integer_zero_node, 1);\n }\n \f\n-#if USE_CPPLIB\n-/* Read the rest of a #-directive from input stream FINPUT.\n-   In normal use, the directive name and the white space after it\n-   have already been read, so they won't be included in the result.\n-   We allow for the fact that the directive line may contain\n-   a newline embedded within a character or string literal which forms\n-   a part of the directive.\n-\n-   The value is a string in a reusable buffer.  It remains valid\n-   only until the next time this function is called.  */\n-unsigned char *yy_cur, *yy_lim;\n-\n-#define GETC() (yy_cur < yy_lim ? *yy_cur++ : yy_get_token ())\n-#define UNGETC(c) ((c) == EOF ? 0 : yy_cur--)\n-\n-int\n-yy_get_token ()\n-{\n-  for (;;)\n-    {\n-      parse_in.limit = parse_in.token_buffer;\n-      cpp_token = cpp_get_token (&parse_in);\n-      if (cpp_token == CPP_EOF)\n-\treturn -1;\n-      yy_lim = CPP_PWRITTEN (&parse_in);\n-      yy_cur = parse_in.token_buffer;\n-      if (yy_cur < yy_lim)\n-\treturn *yy_cur++;\n-    }\n-}\n-\n-char *\n-get_directive_line ()\n-{\n-  static char *directive_buffer = NULL;\n-  static unsigned buffer_length = 0;\n-  register char *p;\n-  register char *buffer_limit;\n-  register int looking_for = 0;\n-  register int char_escaped = 0;\n-\n-  if (buffer_length == 0)\n-    {\n-      directive_buffer = (char *)xmalloc (128);\n-      buffer_length = 128;\n-    }\n-\n-  buffer_limit = &directive_buffer[buffer_length];\n-\n-  for (p = directive_buffer; ; )\n-    {\n-      int c;\n-\n-      /* Make buffer bigger if it is full.  */\n-      if (p >= buffer_limit)\n-        {\n-\t  register unsigned bytes_used = (p - directive_buffer);\n-\n-\t  buffer_length *= 2;\n-\t  directive_buffer\n-\t    = (char *)xrealloc (directive_buffer, buffer_length);\n-\t  p = &directive_buffer[bytes_used];\n-\t  buffer_limit = &directive_buffer[buffer_length];\n-        }\n-\n-      c = GETC ();\n-\n-      /* Discard initial whitespace.  */\n-      if ((c == ' ' || c == '\\t') && p == directive_buffer)\n-\tcontinue;\n-\n-      /* Detect the end of the directive.  */\n-      if (c == '\\n' && looking_for == 0)\n-\t{\n-          UNGETC (c);\n-\t  c = '\\0';\n-\t}\n-\n-      *p++ = c;\n-\n-      if (c == 0)\n-\treturn directive_buffer;\n-\n-      /* Handle string and character constant syntax.  */\n-      if (looking_for)\n-\t{\n-\t  if (looking_for == c && !char_escaped)\n-\t    looking_for = 0;\t/* Found terminator... stop looking.  */\n-\t}\n-      else\n-        if (c == '\\'' || c == '\"')\n-\t  looking_for = c;\t/* Don't stop buffering until we see another\n-\t\t\t\t   another one of these (or an EOF).  */\n-\n-      /* Handle backslash.  */\n-      char_escaped = (c == '\\\\' && ! char_escaped);\n-    }\n-}\n-#else\n+#if !USE_CPPLIB\n /* Read the rest of a #-directive from input stream FINPUT.\n    In normal use, the directive name and the white space after it\n    have already been read, so they won't be included in the result.\n@@ -3699,7 +3599,7 @@ get_directive_line (finput)\n       char_escaped = (c == '\\\\' && ! char_escaped);\n     }\n }\n-#endif /* !USE_CPPLIB */\n+#endif /* USE_CPPLIB */\n \f\n /* Make a variant type in the proper way for C/C++, propagating qualifiers\n    down to the element type of an array.  */"}, {"sha": "7b4912cb03b405809039de8e49ff6fd80947367b", "filename": "gcc/c-common.h", "status": "modified", "additions": 82, "deletions": 41, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -19,6 +19,9 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#ifndef GCC_C_COMMON_H\n+#define GCC_C_COMMON_H\n+\n /* Usage of TREE_LANG_FLAG_?:\n    0: COMPOUND_STMT_NO_SCOPE (in COMPOUND_STMT).\n       TREE_NEGATED_INT (in INTEGER_CST).\n@@ -33,52 +36,72 @@ Boston, MA 02111-1307, USA.  */\n    4: SCOPE_PARTIAL_P (in SCOPE_STMT)\n */\n \n-/* Reserved identifiers.  */\n+/* Reserved identifiers.  This is the union of all the keywords for C,\n+   C++, and Objective C.  All the type modifiers have to be in one\n+   block at the beginning, because they are used as mask bits.  There\n+   are 27 type modifiers; if we add many more we will have to redesign\n+   the mask mechanism.  */\n \n enum rid\n {\n-  RID_UNUSED,\n-  RID_INT,\n-  RID_CHAR,\n-  RID_FLOAT,\n-  RID_DOUBLE,\n-  RID_VOID,\n-  RID_UNUSED1,\n-\n-  /* The first seven are in the order of most frequently used,\n-     as emiprically determined.  */\n-  RID_FIRST_MODIFIER,\n-  RID_EXTERN = RID_FIRST_MODIFIER,\n-  RID_CONST,\n-  RID_LONG,\n-  RID_TYPEDEF,\n-  RID_UNSIGNED,\n-  RID_SHORT,\n-  RID_INLINE,\n-  RID_AUTO,\n-  RID_STATIC,\n-  RID_REGISTER,\n-  RID_SIGNED,\n-  RID_RESTRICT,\n-  RID_VOLATILE,\n-  RID_BOUNDED,\n-  RID_UNBOUNDED,\n-  RID_NOALIAS,\n-  RID_COMPLEX,\n-\n-  RID_IN,\n-  RID_OUT,\n-  RID_INOUT,\n-  RID_BYCOPY,\n-  RID_BYREF,\n-  RID_ONEWAY,\n-  RID_ID,\n-\n-  RID_MAX\n+  /* Modifiers: */\n+  /* C, in empirical order of frequency. */\n+  RID_STATIC = 0,\n+  RID_UNSIGNED, RID_LONG,    RID_CONST, RID_EXTERN,\n+  RID_REGISTER, RID_TYPEDEF, RID_SHORT, RID_INLINE,\n+  RID_VOLATILE, RID_SIGNED,  RID_AUTO,  RID_RESTRICT,\n+\n+  /* C extensions */\n+  RID_BOUNDED, RID_UNBOUNDED, RID_COMPLEX,\n+\n+  /* C++ */\n+  RID_FRIEND, RID_VIRTUAL, RID_EXPLICIT, RID_EXPORT, RID_MUTABLE,\n+\n+  /* ObjC */\n+  RID_IN, RID_OUT, RID_INOUT, RID_BYCOPY, RID_BYREF, RID_ONEWAY,\n+\n+  /* C */\n+  RID_INT,     RID_CHAR,   RID_FLOAT,    RID_DOUBLE, RID_VOID,\n+  RID_ENUM,    RID_STRUCT, RID_UNION,    RID_IF,     RID_ELSE,\n+  RID_WHILE,   RID_DO,     RID_FOR,      RID_SWITCH, RID_CASE,\n+  RID_DEFAULT, RID_BREAK,  RID_CONTINUE, RID_RETURN, RID_GOTO,\n+  RID_SIZEOF,\n+\n+  /* C extensions */\n+  RID_ASM,       RID_TYPEOF,   RID_ALIGNOF,  RID_ATTRIBUTE,  RID_VA_ARG,\n+  RID_EXTENSION, RID_IMAGPART, RID_REALPART, RID_LABEL,      RID_PTRBASE,\n+  RID_PTREXTENT, RID_PTRVALUE,\n+\n+  /* C++ */\n+  RID_BOOL,     RID_WCHAR,    RID_CLASS,\n+  RID_PUBLIC,   RID_PRIVATE,  RID_PROTECTED,\n+  RID_TEMPLATE, RID_NULL,     RID_CATCH,\n+  RID_DELETE,   RID_FALSE,    RID_NAMESPACE,\n+  RID_NEW,      RID_OPERATOR, RID_THIS,\n+  RID_THROW,    RID_TRUE,     RID_TRY,\n+  RID_TYPENAME, RID_TYPEID,   RID_USING,\n+\n+  /* casts */\n+  RID_CONSTCAST, RID_DYNCAST, RID_REINTCAST, RID_STATCAST,\n+\n+  /* alternate spellings */\n+  RID_AND, RID_AND_EQ, RID_NOT, RID_NOT_EQ,\n+  RID_OR,  RID_OR_EQ,  RID_XOR, RID_XOR_EQ,\n+  RID_BITAND, RID_BITOR, RID_COMPL,\n+\n+  /* Objective C */\n+  RID_ID,          RID_AT_ENCODE,    RID_AT_END,\n+  RID_AT_CLASS,    RID_AT_ALIAS,     RID_AT_DEFS,\n+  RID_AT_PRIVATE,  RID_AT_PROTECTED, RID_AT_PUBLIC,\n+  RID_AT_PROTOCOL, RID_AT_SELECTOR,  RID_AT_INTERFACE,\n+  RID_AT_IMPLEMENTATION,\n+\n+  RID_MAX,\n+\n+  RID_FIRST_MODIFIER = RID_STATIC,\n+  RID_LAST_MODIFIER = RID_ONEWAY\n };\n \n-#define NORID RID_UNUSED\n-\n /* The elements of `ridpointers' are identifier nodes for the reserved\n    type names and storage classes.  It is indexed by a RID_... value.  */\n extern tree *ridpointers;\n@@ -523,3 +546,21 @@ extern tree default_conversion                  PARAMS ((tree));\n extern tree common_type                         PARAMS ((tree, tree));\n \n extern tree expand_tree_builtin                 PARAMS ((tree, tree, tree));\n+\n+/* Hook currently used only by the C++ front end to reset internal state\n+   after entering or leaving a header file.  */\n+extern void extract_interface_info\t\tPARAMS ((void));\n+\n+/* Information recorded about each file examined during compilation.  */\n+\n+struct c_fileinfo\n+{\n+  int time;\t/* Time spent in the file.  */\n+  short interface_only;\t\t/* Flags - used only by C++ */\n+  short interface_unknown;\n+};\n+\n+struct c_fileinfo *get_fileinfo\t\t\tPARAMS ((const char *));\n+extern void dump_time_statistics\t\tPARAMS ((void));\n+\n+#endif"}, {"sha": "af9428b012588615780742f8a9dc63ce531701f3", "filename": "gcc/c-decl.c", "status": "modified", "additions": 55, "deletions": 34, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -503,7 +503,9 @@ c_decode_option (argc, argv)\n   strings_processed = 0;\n #endif /* ! USE_CPPLIB */\n \n-  if (!strcmp (p, \"-ftraditional\") || !strcmp (p, \"-traditional\"))\n+  if (!strcmp (p, \"-lang-objc\"))\n+    c_language = clk_objective_c;\n+  else if (!strcmp (p, \"-ftraditional\") || !strcmp (p, \"-traditional\"))\n     {\n       flag_traditional = 1;\n       flag_writable_strings = 1;\n@@ -845,6 +847,14 @@ print_lang_identifier (file, node, indent)\n   print_node (file, \"implicit\", IDENTIFIER_IMPLICIT_DECL (node), indent + 4);\n   print_node (file, \"error locus\", IDENTIFIER_ERROR_LOCUS (node), indent + 4);\n   print_node (file, \"limbo value\", IDENTIFIER_LIMBO_VALUE (node), indent + 4);\n+  if (C_IS_RESERVED_WORD (node))\n+    {\n+      tree rid = ridpointers[C_RID_CODE (node)];\n+      indent_to (file, indent + 4);\n+      fprintf (file, \"rid \");\n+      fprintf (file, HOST_PTR_PRINTF, (void *)rid);\n+      fprintf (file, \" \\\"%s\\\"\", IDENTIFIER_POINTER (rid));\n+    }\n }\n \f\n /* Hook called at end of compilation to assume 1 elt\n@@ -2896,6 +2906,7 @@ lookup_name (name)\n      tree name;\n {\n   register tree val;\n+\n   if (current_binding_level != global_binding_level\n       && IDENTIFIER_LOCAL_VALUE (name))\n     val = IDENTIFIER_LOCAL_VALUE (name);\n@@ -3986,37 +3997,36 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \n   for (spec = declspecs; spec; spec = TREE_CHAIN (spec))\n     {\n-      register int i;\n       register tree id = TREE_VALUE (spec);\n \n       if (id == ridpointers[(int) RID_INT])\n \texplicit_int = 1;\n       if (id == ridpointers[(int) RID_CHAR])\n \texplicit_char = 1;\n \n-      if (TREE_CODE (id) == IDENTIFIER_NODE)\n-\tfor (i = (int) RID_FIRST_MODIFIER; i < (int) RID_MAX; i++)\n-\t  {\n-\t    if (ridpointers[i] == id)\n-\t      {\n-\t\tif (i == (int) RID_LONG && specbits & (1 << i))\n-\t\t  {\n-\t\t    if (longlong)\n-\t\t      error (\"`long long long' is too long for GCC\");\n-\t\t    else\n-\t\t      {\n-\t\t\tif (pedantic && !flag_isoc99 && ! in_system_header\n-\t\t\t    && warn_long_long)\n-\t\t\t  pedwarn (\"ISO C89 does not support `long long'\");\n-\t\t\tlonglong = 1;\n-\t\t      }\n-\t\t  }\n-\t\telse if (specbits & (1 << i))\n-\t\t  pedwarn (\"duplicate `%s'\", IDENTIFIER_POINTER (id));\n-\t\tspecbits |= 1 << i;\n-\t\tgoto found;\n-\t      }\n-\t  }\n+      if (TREE_CODE (id) == IDENTIFIER_NODE && C_IS_RESERVED_WORD (id))\n+\t{\n+\t  enum rid i = C_RID_CODE (id);\n+\t  if (i <= RID_LAST_MODIFIER)\n+\t    {\n+\t      if (i == RID_LONG && specbits & (1<<i))\n+\t\t{\n+\t\t  if (longlong)\n+\t\t    error (\"`long long long' is too long for GCC\");\n+\t\t  else\n+\t\t    {\n+\t\t      if (pedantic && !flag_isoc99 && ! in_system_header\n+\t\t\t  && warn_long_long)\n+\t\t\tpedwarn (\"ISO C89 does not support `long long'\");\n+\t\t      longlong = 1;\n+\t\t    }\n+\t\t}\n+\t      else if (specbits & (1 << i))\n+\t\tpedwarn (\"duplicate `%s'\", IDENTIFIER_POINTER (id));\n+\t      specbits |= 1 << i;\n+\t      goto found;\n+\t    }\n+\t}\n       if (type)\n \terror (\"two or more data types in declaration of `%s'\", name);\n       /* Actual typedefs come to us as TYPE_DECL nodes.  */\n@@ -4560,18 +4570,23 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t\t{\n \t\t  tree qualifier = TREE_VALUE (typemodlist);\n \n-\t\t  if (qualifier == ridpointers[(int) RID_CONST])\n-\t\t    constp++;\n-\t\t  else if (qualifier == ridpointers[(int) RID_VOLATILE])\n-\t\t    volatilep++;\n-\t\t  else if (qualifier == ridpointers[(int) RID_RESTRICT])\n-\t\t    restrictp++;\n-\t\t  else if (!erred)\n+\t\t  if (C_IS_RESERVED_WORD (qualifier))\n \t\t    {\n-\t\t      erred = 1;\n-\t\t      error (\"invalid type modifier within pointer declarator\");\n+\t\t      if (C_RID_CODE (qualifier) == RID_CONST)\n+\t\t\tconstp++;\n+\t\t      else if (C_RID_CODE (qualifier) == RID_VOLATILE)\n+\t\t\tvolatilep++;\n+\t\t      else if (C_RID_CODE (qualifier) == RID_RESTRICT)\n+\t\t\trestrictp++;\n+\t\t      else\n+\t\t\terred++;\n \t\t    }\n+\t\t  else\n+\t\t    erred++;\n \t\t}\n+\n+\t      if (erred)\n+\t\terror (\"invalid type modifier within pointer declarator\");\n \t      if (constp > 1 && ! flag_isoc99)\n \t\tpedwarn (\"duplicate `const'\");\n \t      if (volatilep > 1 && ! flag_isoc99)\n@@ -6990,3 +7005,9 @@ set_current_function_name_declared (i)\n {\n   abort ();\n }\n+\n+/* Dummy function in place of callback used by C++.  */\n+void\n+extract_interface_info ()\n+{\n+}"}, {"sha": "a864d2e30ce5415babfca69f0ed95f6a38f3e44f", "filename": "gcc/c-gperf.h", "status": "removed", "additions": 0, "deletions": 252, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26aa75bef97454f65b437067cf77a5a0255934a3/gcc%2Fc-gperf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26aa75bef97454f65b437067cf77a5a0255934a3/gcc%2Fc-gperf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gperf.h?ref=26aa75bef97454f65b437067cf77a5a0255934a3", "patch": "@@ -1,252 +0,0 @@\n-/* C code produced by gperf version 2.7.1 (19981006 egcs) */\n-/* Command-line: gperf -L C -F , 0, 0 -p -j1 -i 1 -g -o -t -G -N is_reserved_word -k1,3,$ ../../gcc/c-parse.gperf  */\n-/* Command-line: gperf -L C -F ', 0, 0' -p -j1 -i 1 -g -o -t -N is_reserved_word -k1,3,$ c-parse.gperf  */ \n-struct resword { const char *name; short token; enum rid rid; };\n-#ifdef __GNUC__\n-__inline\n-#endif\n-static unsigned int hash PARAMS ((const char *, unsigned int));\n-#ifdef __GNUC__\n-__inline\n-#endif\n-struct resword *is_reserved_word PARAMS ((const char *, unsigned int));\n-\n-#define TOTAL_KEYWORDS 92\n-#define MIN_WORD_LENGTH 2\n-#define MAX_WORD_LENGTH 20\n-#define MIN_HASH_VALUE 17\n-#define MAX_HASH_VALUE 301\n-/* maximum key range = 285, duplicates = 0 */\n-\n-#ifdef __GNUC__\n-__inline\n-#endif\n-static unsigned int\n-hash (str, len)\n-     register const char *str;\n-     register unsigned int len;\n-{\n-  static unsigned short asso_values[] =\n-    {\n-      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n-      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n-      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n-      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n-      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n-      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n-      302, 302, 302, 302, 113, 302, 302, 302, 302, 302,\n-      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n-      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n-      302, 302, 302, 302, 302,   1, 302,  78,  52, 111,\n-       34,   9,  46,  59,   1,  20, 302,   1, 118,  17,\n-       18,  39,  58, 302,   7,   6,  33,  70,  21,   2,\n-        5,   1,   1, 302, 302, 302, 302, 302, 302, 302,\n-      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n-      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n-      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n-      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n-      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n-      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n-      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n-      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n-      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n-      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n-      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n-      302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n-      302, 302, 302, 302, 302, 302\n-    };\n-  register int hval = len;\n-\n-  switch (hval)\n-    {\n-      default:\n-      case 3:\n-        hval += asso_values[(unsigned char)str[2]];\n-      case 2:\n-      case 1:\n-        hval += asso_values[(unsigned char)str[0]];\n-        break;\n-    }\n-  return hval + asso_values[(unsigned char)str[len - 1]];\n-}\n-\n-static struct resword wordlist[] =\n-  {\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"__real__\", REALPART, NORID},\n-    {\"__signed__\", TYPESPEC, RID_SIGNED},\n-    {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"__restrict__\", TYPE_QUAL, RID_RESTRICT},\n-    {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"__extension__\", EXTENSION, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"else\", ELSE, NORID},\n-    {\"\", 0, 0},\n-    {\"__imag__\", IMAGPART, NORID},\n-    {\"\", 0, 0},\n-    {\"__inline__\", SCSPEC, RID_INLINE},\n-    {\"switch\", SWITCH, NORID},\n-    {\"\", 0, 0},\n-    {\"__volatile__\", TYPE_QUAL, RID_VOLATILE},\n-    {\"while\", WHILE, NORID},\n-    {\"\", 0, 0},\n-    {\"__inline\", SCSPEC, RID_INLINE},\n-    {\"\", 0, 0},\n-    {\"in\", TYPE_QUAL, RID_IN},\n-    {\"__volatile\", TYPE_QUAL, RID_VOLATILE},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"__typeof__\", TYPEOF, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"__signed\", TYPESPEC, RID_SIGNED},\n-    {\"\", 0, 0},\n-    {\"__restrict\", TYPE_QUAL, RID_RESTRICT},\n-    {\"struct\", STRUCT, NORID},\n-    {\"\", 0, 0},\n-    {\"restrict\", TYPE_QUAL, RID_RESTRICT},\n-    {\"oneway\", TYPE_QUAL, RID_ONEWAY},\n-    {\"id\", OBJECTNAME, RID_ID},\n-    {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"sizeof\", SIZEOF, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"for\", FOR, NORID},\n-    {\"return\", RETURN, NORID},\n-    {\"__bounded__\", TYPE_QUAL, RID_BOUNDED},\n-    {\"extern\", SCSPEC, RID_EXTERN},\n-    {\"break\", BREAK, NORID},\n-    {\"if\", IF, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"__ptrbase__\", PTR_BASE, NORID},\n-    {\"__ptrvalue__\", PTR_VALUE, NORID},\n-    {\"__ptrextent__\", PTR_EXTENT, NORID},\n-    {\"\", 0, 0},\n-    {\"do\", DO, NORID},\n-    {\"\", 0, 0},\n-    {\"__ptrbase\", PTR_BASE, NORID},\n-    {\"__ptrvalue\", PTR_VALUE, NORID},\n-    {\"void\", TYPESPEC, RID_VOID},\n-    {\"\", 0, 0},\n-    {\"register\", SCSPEC, RID_REGISTER},\n-    {\"\", 0, 0},\n-    {\"short\", TYPESPEC, RID_SHORT},\n-    {\"\", 0, 0},\n-    {\"__unbounded__\", TYPE_QUAL, RID_UNBOUNDED},\n-    {\"__imag\", IMAGPART, NORID},\n-    {\"__asm__\", ASM_KEYWORD, NORID},\n-    {\"__typeof\", TYPEOF, NORID},\n-    {\"int\", TYPESPEC, RID_INT},\n-    {\"\", 0, 0},\n-    {\"__alignof__\", ALIGNOF, NORID},\n-    {\"\", 0, 0},\n-    {\"__attribute__\", ATTRIBUTE, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"__bounded\", TYPE_QUAL, RID_BOUNDED},\n-    {\"inout\", TYPE_QUAL, RID_INOUT},\n-    {\"\", 0, 0},\n-    {\"__attribute\", ATTRIBUTE, NORID},\n-    {\"enum\", ENUM, NORID},\n-    {\"__asm\", ASM_KEYWORD, NORID},\n-    {\"\", 0, 0},\n-    {\"__ptrextent\", PTR_EXTENT, NORID},\n-    {\"\", 0, 0},\n-    {\"signed\", TYPESPEC, RID_SIGNED},\n-    {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"out\", TYPE_QUAL, RID_OUT},\n-    {\"\", 0, 0},\n-    {\"byref\", TYPE_QUAL, RID_BYREF},\n-    {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"union\", UNION, NORID},\n-    {\"\", 0, 0},\n-    {\"asm\", ASM_KEYWORD, NORID},\n-    {\"__unbounded\", TYPE_QUAL, RID_UNBOUNDED},\n-    {\"\", 0, 0},\n-    {\"unsigned\", TYPESPEC, RID_UNSIGNED},\n-    {\"double\", TYPESPEC, RID_DOUBLE},\n-    {\"default\", DEFAULT, NORID},\n-    {\"\", 0, 0},\n-    {\"__const__\", TYPE_QUAL, RID_CONST},\n-    {\"float\", TYPESPEC, RID_FLOAT},\n-    {\"__complex__\", TYPESPEC, RID_COMPLEX},\n-    {\"\", 0, 0},\n-    {\"__complex\", TYPESPEC, RID_COMPLEX},\n-    {\"\", 0, 0},\n-    {\"__builtin_va_arg\", VA_ARG, NORID},\n-    {\"__label__\", LABEL, NORID},\n-    {\"case\", CASE, NORID},\n-    {\"\", 0, 0},\n-    {\"__real\", REALPART, NORID},\n-    {\"@defs\", DEFS, NORID},\n-    {\"__alignof\", ALIGNOF, NORID},\n-    {\"goto\", GOTO, NORID},\n-    {\"\", 0, 0},\n-    {\"@private\", PRIVATE, NORID},\n-    {\"@selector\", SELECTOR, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"typeof\", TYPEOF, NORID},\n-    {\"typedef\", SCSPEC, RID_TYPEDEF},\n-    {\"\", 0, 0},\n-    {\"continue\", CONTINUE, NORID},\n-    {\"@encode\", ENCODE, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"@interface\", INTERFACE, NORID},\n-    {\"\", 0, 0},\n-    {\"__const\", TYPE_QUAL, RID_CONST},\n-    {\"inline\", SCSPEC, RID_INLINE},\n-    {\"auto\", SCSPEC, RID_AUTO},\n-    {\"\", 0, 0},\n-    {\"volatile\", TYPE_QUAL, RID_VOLATILE},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"@implementation\", IMPLEMENTATION, NORID},\n-    {\"@protected\", PROTECTED, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"const\", TYPE_QUAL, RID_CONST},\n-    {\"\", 0, 0},\n-    {\"@end\", END, NORID},\n-    {\"bycopy\", TYPE_QUAL, RID_BYCOPY},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"@compatibility_alias\", ALIAS, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"long\", TYPESPEC, RID_LONG},\n-    {\"char\", TYPESPEC, RID_CHAR},\n-    {\"static\", SCSPEC, RID_STATIC},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"@class\", CLASS, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"@protocol\", PROTOCOL, NORID},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-    {\"@public\", PUBLIC, NORID}\n-  };\n-\n-#ifdef __GNUC__\n-__inline\n-#endif\n-struct resword *\n-is_reserved_word (str, len)\n-     register const char *str;\n-     register unsigned int len;\n-{\n-  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n-    {\n-      register int key = hash (str, len);\n-\n-      if (key <= MAX_HASH_VALUE && key >= 0)\n-        {\n-          register const char *s = wordlist[key].name;\n-\n-          if (*str == *s && !strcmp (str + 1, s + 1))\n-            return &wordlist[key];\n-        }\n-    }\n-  return 0;\n-}"}, {"sha": "f8dd30b8f4398d04b40afce77b822bf7fcd111ad", "filename": "gcc/c-lang.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -37,9 +37,7 @@ static int c_tree_printer PARAMS ((output_buffer *));\n \n #if USE_CPPLIB\n #include \"cpplib.h\"\n-extern char *yy_cur;\n extern cpp_reader  parse_in;\n-extern cpp_options parse_options;\n #endif\n \n /* Each of the functions defined here\n@@ -57,9 +55,8 @@ void\n lang_init_options ()\n {\n #if USE_CPPLIB\n+  cpp_init ();\n   cpp_reader_init (&parse_in);\n-  parse_in.opts = &parse_options;\n-  cpp_options_init (&parse_options);\n #endif\n   /* Mark as \"unspecified\".  */\n   flag_bounds_check = -1;\n@@ -86,10 +83,7 @@ lang_init ()\n      and put it in input_filename.  */\n #if !USE_CPPLIB\n   ungetc (check_newline (), finput);\n-#else\n-  check_newline ();\n-  yy_cur--;\n-#endif \n+#endif\n \n   save_lang_status = &push_c_function_context;\n   restore_lang_status = &pop_c_function_context;"}, {"sha": "84ef09499bca26d54334ef4015b320d2553c3e81", "filename": "gcc/c-lex.c", "status": "modified", "additions": 1769, "deletions": 1700, "changes": 3469, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=0e5921e8a0f347a7de29c7347738db8de5769a88"}, {"sha": "5247c38413284321431cd5be9b751785956a425b", "filename": "gcc/c-lex.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fc-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fc-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.h?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -18,16 +18,20 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-extern char *token_buffer;\t/* Pointer to token buffer.  */\n+#ifndef _C_LEX_H\n+#define _C_LEX_H\n \n extern tree make_pointer_declarator PARAMS ((tree, tree));\n-extern void reinit_parse_for_function PARAMS ((void));\n extern void position_after_white_space PARAMS ((void));\n extern int check_newline PARAMS ((void));\n \n-extern int yylex PARAMS ((void));\n-extern void yyerror PARAMS ((const char *));\n+extern int c_lex PARAMS ((tree *));\n+extern const char *init_c_lex PARAMS ((const char *));\n \n extern void forget_protocol_qualifiers PARAMS ((void));\n extern void remember_protocol_qualifiers PARAMS ((void));\n extern tree is_class_name PARAMS ((tree));\n+\n+extern int indent_level;\n+\n+#endif"}, {"sha": "1f36392b0440e2a654c4cca8c6e88b648d37413a", "filename": "gcc/c-parse.gperf", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26aa75bef97454f65b437067cf77a5a0255934a3/gcc%2Fc-parse.gperf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26aa75bef97454f65b437067cf77a5a0255934a3/gcc%2Fc-parse.gperf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.gperf?ref=26aa75bef97454f65b437067cf77a5a0255934a3", "patch": "@@ -1,105 +0,0 @@\n-%{\n-/* Command-line: gperf -L C -F ', 0, 0' -p -j1 -i 1 -g -o -t -N is_reserved_word -k1,3,$ c-parse.gperf  */ \n-%}\n-struct resword { const char *name; short token; enum rid rid; };\n-#ifdef __GNUC__\n-__inline\n-#endif\n-static unsigned int hash PARAMS ((const char *, unsigned int));\n-#ifdef __GNUC__\n-__inline\n-#endif\n-struct resword *is_reserved_word PARAMS ((const char *, unsigned int));\n-%%\n-@class, CLASS, NORID\n-@compatibility_alias, ALIAS, NORID\n-@defs, DEFS, NORID\n-@encode, ENCODE, NORID\n-@end, END, NORID\n-@implementation, IMPLEMENTATION, NORID\n-@interface, INTERFACE, NORID\n-@private, PRIVATE, NORID\n-@protected, PROTECTED, NORID\n-@protocol, PROTOCOL, NORID\n-@public, PUBLIC, NORID\n-@selector, SELECTOR, NORID\n-__alignof, ALIGNOF, NORID\n-__alignof__, ALIGNOF, NORID\n-__asm, ASM_KEYWORD, NORID\n-__asm__, ASM_KEYWORD, NORID\n-__attribute, ATTRIBUTE, NORID\n-__attribute__, ATTRIBUTE, NORID\n-__bounded, TYPE_QUAL, RID_BOUNDED\n-__bounded__, TYPE_QUAL, RID_BOUNDED\n-__builtin_va_arg, VA_ARG, NORID\n-__complex, TYPESPEC, RID_COMPLEX\n-__complex__, TYPESPEC, RID_COMPLEX\n-__const, TYPE_QUAL, RID_CONST\n-__const__, TYPE_QUAL, RID_CONST\n-__extension__, EXTENSION, NORID\n-__imag, IMAGPART, NORID\n-__imag__, IMAGPART, NORID\n-__inline, SCSPEC, RID_INLINE\n-__inline__, SCSPEC, RID_INLINE\n-__label__, LABEL, NORID\n-__ptrbase, PTR_BASE, NORID\n-__ptrbase__, PTR_BASE, NORID\n-__ptrextent, PTR_EXTENT, NORID\n-__ptrextent__, PTR_EXTENT, NORID\n-__ptrvalue, PTR_VALUE, NORID\n-__ptrvalue__, PTR_VALUE, NORID\n-__real, REALPART, NORID\n-__real__, REALPART, NORID\n-__restrict, TYPE_QUAL, RID_RESTRICT\n-__restrict__, TYPE_QUAL, RID_RESTRICT\n-__signed, TYPESPEC, RID_SIGNED\n-__signed__, TYPESPEC, RID_SIGNED\n-__typeof, TYPEOF, NORID\n-__typeof__, TYPEOF, NORID\n-__unbounded, TYPE_QUAL, RID_UNBOUNDED\n-__unbounded__, TYPE_QUAL, RID_UNBOUNDED\n-__volatile, TYPE_QUAL, RID_VOLATILE\n-__volatile__, TYPE_QUAL, RID_VOLATILE\n-asm, ASM_KEYWORD, NORID\n-auto, SCSPEC, RID_AUTO\n-break, BREAK, NORID\n-bycopy, TYPE_QUAL, RID_BYCOPY\n-byref, TYPE_QUAL, RID_BYREF\n-case, CASE, NORID\n-char, TYPESPEC, RID_CHAR\n-const, TYPE_QUAL, RID_CONST\n-continue, CONTINUE, NORID\n-default, DEFAULT, NORID\n-do, DO, NORID\n-double, TYPESPEC, RID_DOUBLE\n-else, ELSE, NORID\n-enum, ENUM, NORID\n-extern, SCSPEC, RID_EXTERN\n-float, TYPESPEC, RID_FLOAT\n-for, FOR, NORID\n-goto, GOTO, NORID\n-id, OBJECTNAME, RID_ID\n-if, IF, NORID\n-in, TYPE_QUAL, RID_IN\n-inout, TYPE_QUAL, RID_INOUT\n-inline, SCSPEC, RID_INLINE\n-int, TYPESPEC, RID_INT\n-long, TYPESPEC, RID_LONG\n-oneway, TYPE_QUAL, RID_ONEWAY\n-out, TYPE_QUAL, RID_OUT\n-register, SCSPEC, RID_REGISTER\n-restrict, TYPE_QUAL, RID_RESTRICT\n-return, RETURN, NORID\n-short, TYPESPEC, RID_SHORT\n-signed, TYPESPEC, RID_SIGNED\n-sizeof, SIZEOF, NORID\n-static, SCSPEC, RID_STATIC\n-struct, STRUCT, NORID\n-switch, SWITCH, NORID\n-typedef, SCSPEC, RID_TYPEDEF\n-typeof, TYPEOF, NORID\n-union, UNION, NORID\n-unsigned, TYPESPEC, RID_UNSIGNED\n-void, TYPESPEC, RID_VOID\n-volatile, TYPE_QUAL, RID_VOLATILE\n-while, WHILE, NORID"}, {"sha": "9d2001bd5c7c9bad7c478084002d897580dab225", "filename": "gcc/c-parse.in", "status": "modified", "additions": 638, "deletions": 48, "changes": 686, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -43,6 +43,7 @@ end ifc\n #include \"input.h\"\n #include \"c-lex.h\"\n #include \"c-tree.h\"\n+#include \"c-pragma.h\"\n #include \"flags.h\"\n #include \"output.h\"\n #include \"toplev.h\"\n@@ -117,9 +118,6 @@ end ifc\n %token REALPART IMAGPART VA_ARG\n %token PTR_VALUE PTR_BASE PTR_EXTENT\n \n-/* Used in c-lex.c for parsing pragmas.  */\n-%token END_OF_LINE\n-\n /* Add precedence rules to solve dangling else s/r conflict */\n %nonassoc IF\n %nonassoc ELSE\n@@ -155,6 +153,8 @@ end ifc\n \n \n %type <code> unop\n+%type <ttype> ENUM STRUCT UNION IF ELSE WHILE DO FOR SWITCH CASE DEFAULT\n+%type <ttype> BREAK CONTINUE RETURN GOTO ASM_KEYWORD SIZEOF TYPEOF ALIGNOF\n \n %type <ttype> identifier IDENTIFIER TYPENAME CONSTANT expr nonnull_exprlist exprlist\n %type <ttype> expr_no_commas cast_expr unary_expr primary string STRING\n@@ -254,7 +254,12 @@ end ifobjc\n /* Tell yyparse how to print a token's value, if yydebug is set.  */\n \n #define YYPRINT(FILE,YYCHAR,YYLVAL) yyprint(FILE,YYCHAR,YYLVAL)\n-extern void yyprint\t\t\tPARAMS ((FILE *, int, YYSTYPE));\n+\n+static void yyprint\t  PARAMS ((FILE *, int, YYSTYPE));\n+static void yyerror\t  PARAMS ((const char *));\n+static inline int _yylex  PARAMS ((void));\n+static int  yylex\t  PARAMS ((void));\n+static void init_reswords PARAMS ((void));\n \n /* Add GC roots for variables local to this file.  */\n void\n@@ -351,7 +356,7 @@ fndef:\n \t\t{ if (! start_function (current_declspecs, $3,\n \t\t\t\t\tprefix_attributes, NULL_TREE))\n \t\t    YYERROR1;\n-\t\t  reinit_parse_for_function (); }\n+\t\t}\n \t  old_style_parm_decls\n \t\t{ store_parm_decls (); }\n \t  compstmt_or_error\n@@ -367,7 +372,7 @@ fndef:\n \t\t{ if (! start_function (current_declspecs, $3,\n \t\t\t\t\tprefix_attributes, NULL_TREE))\n \t\t    YYERROR1;\n-\t\t  reinit_parse_for_function (); }\n+\t\t}\n \t  old_style_parm_decls\n \t\t{ store_parm_decls (); }\n \t  compstmt_or_error\n@@ -383,7 +388,7 @@ fndef:\n \t\t{ if (! start_function (NULL_TREE, $2,\n \t\t\t\t\tprefix_attributes, NULL_TREE))\n \t\t    YYERROR1;\n-\t\t  reinit_parse_for_function (); }\n+\t\t}\n \t  old_style_parm_decls\n \t\t{ store_parm_decls (); }\n \t  compstmt_or_error\n@@ -1178,7 +1183,7 @@ nested_function:\n \t\t      pop_function_context ();\n \t\t      YYERROR1;\n \t\t    }\n-\t\t  reinit_parse_for_function (); }\n+\t\t}\n \t   old_style_parm_decls\n \t\t{ store_parm_decls (); }\n /* This used to use compstmt_or_error.\n@@ -1204,7 +1209,7 @@ notype_nested_function:\n \t\t      pop_function_context ();\n \t\t      YYERROR1;\n \t\t    }\n-\t\t  reinit_parse_for_function (); }\n+\t\t}\n \t  old_style_parm_decls\n \t\t{ store_parm_decls (); }\n /* This used to use compstmt_or_error.\n@@ -1696,8 +1701,7 @@ if_prefix:\n \t\t\t\t       compstmt_count);\n \t\t  $<itype>$ = stmt_count;\n \t\t  if_stmt_file = $<filename>-1;\n-\t\t  if_stmt_line = $<lineno>0;\n-\t\t  position_after_white_space (); }\n+\t\t  if_stmt_line = $<lineno>0; }\n \t;\n \n /* This is a subroutine of stmt.\n@@ -1710,18 +1714,24 @@ do_stmt_start:\n \t\t  emit_line_note ($<filename>-1, $<lineno>0);\n \t\t  /* See comment in `while' alternative, above.  */\n \t\t  emit_nop ();\n-\t\t  expand_start_loop_continue_elsewhere (1);\n-\t\t  position_after_white_space (); }\n+\t\t  expand_start_loop_continue_elsewhere (1); }\n \t  lineno_labeled_stmt WHILE\n \t\t{ expand_loop_continue_here (); }\n \t;\n \n+/* The forced readahead in here is because we might be at the end of a\n+   line, and the line and file won't be bumped until yylex absorbs the\n+   first token on the next line.  */\n save_filename:\n-\t\t{ $$ = input_filename; }\n+\t\t{ if (yychar == YYEMPTY)\n+\t\t    yychar = YYLEX;\n+\t\t  $$ = input_filename; }\n \t;\n \n save_lineno:\n-\t\t{ $$ = lineno; }\n+\t\t{ if (yychar == YYEMPTY)\n+\t\t    yychar = YYLEX;\n+\t\t  $$ = lineno; }\n \t;\n \n lineno_labeled_stmt:\n@@ -1768,8 +1778,7 @@ stmt:\n \t\t  expand_expr_stmt ($1); }\n \t| simple_if ELSE\n \t\t{ c_expand_start_else ();\n-\t\t  $<itype>1 = stmt_count;\n-\t\t  position_after_white_space (); }\n+\t\t  $<itype>1 = stmt_count; }\n \t  lineno_labeled_stmt\n \t\t{ c_expand_end_cond ();\n \t\t  if (extra_warnings && stmt_count == $<itype>1)\n@@ -1805,8 +1814,7 @@ stmt:\n \t\t  expand_start_loop (1);\n \t\t  emit_line_note (input_filename, lineno);\n \t\t  expand_exit_loop_if_false (NULL_PTR,\n-\t\t\t\t\t     truthvalue_conversion ($4));\n-\t\t  position_after_white_space (); }\n+\t\t\t\t\t     truthvalue_conversion ($4)); }\n \t  lineno_labeled_stmt\n \t\t{ expand_end_loop (); }\n \t| do_stmt_start\n@@ -1845,8 +1853,7 @@ stmt:\n \t\t    expand_exit_loop_if_false (NULL_PTR,\n \t\t\t\t\t       truthvalue_conversion ($6));\n \t\t  $<lineno>7 = lineno;\n-\t\t  $<filename>8 = input_filename;\n-\t\t  position_after_white_space (); }\n+\t\t  $<filename>8 = input_filename; }\n \t  lineno_labeled_stmt\n \t\t{ /* Emit the increment expression, with a line number.  */\n \t\t  emit_line_note ($<filename>8, $<lineno>7);\n@@ -1857,8 +1864,7 @@ stmt:\n \t| SWITCH '(' expr ')'\n \t\t{ stmt_count++;\n \t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  c_expand_start_case ($3);\n-\t\t  position_after_white_space (); }\n+\t\t  c_expand_start_case ($3); }\n \t  lineno_labeled_stmt\n \t\t{ expand_end_case ($3); }\n \t| BREAK ';'\n@@ -1937,30 +1943,27 @@ label:\t  CASE expr_no_commas ':'\n                 { tree case_label_tree = build_case_label ($2, NULL_TREE);\n \t\t  stmt_count++;\n \t\t  genrtl_case_label(CASE_LOW(case_label_tree), CASE_HIGH(case_label_tree));\n-\t\t  position_after_white_space ();\n \t\t}\n \t| CASE expr_no_commas ELLIPSIS expr_no_commas ':'\n                 { tree case_label_tree = build_case_label ($2, $4);\n \t\t  stmt_count++;\n \t\t  genrtl_case_label(CASE_LOW(case_label_tree), CASE_HIGH(case_label_tree));\n-\t\t  position_after_white_space ();\n \t\t}\n \t| DEFAULT ':'\n                 { tree case_label_tree = build_case_label (NULL_TREE, NULL_TREE);\n \t\t  stmt_count++;\n \t\t  genrtl_case_label(CASE_LOW(case_label_tree), CASE_HIGH(case_label_tree));\n-\t\t  position_after_white_space ();\n \t\t}\n-\t| identifier ':' save_filename save_lineno maybe_attribute\n-\t\t{ tree label = define_label ($3, $4, $1);\n+\t| identifier save_filename save_lineno ':' maybe_attribute\n+\t\t{ tree label = define_label ($2, $3, $1);\n \t\t  stmt_count++;\n \t\t  emit_nop ();\n \t\t  if (label)\n \t\t    {\n \t\t      expand_label (label);\n \t\t      decl_attributes (label, $5, NULL_TREE);\n \t\t    }\n-\t\t  position_after_white_space (); }\n+\t\t}\n \t;\n \n /* Either a type-qualifier or nothing.  First thing in an `asm' statement.  */\n@@ -2658,25 +2661,9 @@ selector:\n \t;\n \n reservedwords:\n-\t  ENUM { $$ = get_identifier (token_buffer); }\n-\t| STRUCT { $$ = get_identifier (token_buffer); }\n-\t| UNION { $$ = get_identifier (token_buffer); }\n-\t| IF { $$ = get_identifier (token_buffer); }\n-\t| ELSE { $$ = get_identifier (token_buffer); }\n-\t| WHILE { $$ = get_identifier (token_buffer); }\n-\t| DO { $$ = get_identifier (token_buffer); }\n-\t| FOR { $$ = get_identifier (token_buffer); }\n-\t| SWITCH { $$ = get_identifier (token_buffer); }\n-\t| CASE { $$ = get_identifier (token_buffer); }\n-\t| DEFAULT { $$ = get_identifier (token_buffer); }\n-\t| BREAK { $$ = get_identifier (token_buffer); }\n-\t| CONTINUE { $$ = get_identifier (token_buffer); }\n-\t| RETURN  { $$ = get_identifier (token_buffer); }\n-\t| GOTO { $$ = get_identifier (token_buffer); }\n-\t| ASM_KEYWORD { $$ = get_identifier (token_buffer); }\n-        | SIZEOF { $$ = get_identifier (token_buffer); }\n-\t| TYPEOF { $$ = get_identifier (token_buffer); }\n-\t| ALIGNOF { $$ = get_identifier (token_buffer); }\n+\t  ENUM | STRUCT\t| UNION\t| IF | ELSE | WHILE | DO | FOR\n+\t| SWITCH | CASE | DEFAULT | BREAK | CONTINUE | RETURN\n+\t| GOTO | ASM_KEYWORD | SIZEOF | TYPEOF | ALIGNOF\n \t| TYPESPEC | TYPE_QUAL\n \t;\n \n@@ -2807,3 +2794,606 @@ objcencodeexpr:\n \n end ifobjc\n %%\n+\n+/* yylex() is a thin wrapper around c_lex(), all it does is translate\n+   cpplib.h's token codes into yacc's token codes.  */\n+#include \"cpplib.h\"\n+#include \"intl.h\"\n+#include \"timevar.h\"\n+\n+static enum cpp_ttype last_token;\n+#if USE_CPPLIB\n+extern cpp_reader parse_in;\n+#endif\n+\n+/* The reserved keyword table.  */\n+struct resword\n+{\n+  const char *word;\n+  ENUM_BITFIELD(rid) rid : 16;\n+  unsigned int disable   : 16;\n+};\n+\n+/* Disable mask.  Keywords are disabled if (reswords[i].disable & mask) is\n+   _true_.  */\n+#define D_TRAD\t0x01\t/* not in traditional C */\n+#define D_C89\t0x02\t/* not in C89 */\n+#define D_EXT\t0x04\t/* GCC extension */\n+#define D_EXT89\t0x08\t/* GCC extension incorporated in C99 */\n+#define D_OBJC\t0x10\t/* Objective C only */\n+#define D_YES\t0x20\t/* always starts disabled */\n+\n+static const struct resword reswords[] =\n+{\n+  { \"__alignof\",\tRID_ALIGNOF,\t0 },\n+  { \"__alignof__\",\tRID_ALIGNOF,\t0 },\n+  { \"__asm\",\t\tRID_ASM,\t0 },\n+  { \"__asm__\",\t\tRID_ASM,\t0 },\n+  { \"__attribute\",\tRID_ATTRIBUTE,\t0 },\n+  { \"__attribute__\",\tRID_ATTRIBUTE,\t0 },\n+  { \"__bounded\",\tRID_BOUNDED,\t0 },\n+  { \"__bounded__\",\tRID_BOUNDED,\t0 },\n+  { \"__builtin_va_arg\",\tRID_VA_ARG,\t0 },\n+  { \"__complex\",\tRID_COMPLEX,\t0 },\n+  { \"__complex__\",\tRID_COMPLEX,\t0 },\n+  { \"__const\",\t\tRID_CONST,\t0 },\n+  { \"__const__\",\tRID_CONST,\t0 },\n+  { \"__extension__\",\tRID_EXTENSION,\t0 },\n+  { \"__imag\",\t\tRID_IMAGPART,\t0 },\n+  { \"__imag__\",\t\tRID_IMAGPART,\t0 },\n+  { \"__inline\",\t\tRID_INLINE,\t0 },\n+  { \"__inline__\",\tRID_INLINE,\t0 },\n+  { \"__label__\",\tRID_LABEL,\t0 },\n+  { \"__ptrbase\",\tRID_PTRBASE,\t0 },\n+  { \"__ptrbase__\",\tRID_PTRBASE,\t0 },\n+  { \"__ptrextent\",\tRID_PTREXTENT,\t0 },\n+  { \"__ptrextent__\",\tRID_PTREXTENT,\t0 },\n+  { \"__ptrvalue\",\tRID_PTRVALUE,\t0 },\n+  { \"__ptrvalue__\",\tRID_PTRVALUE,\t0 },\n+  { \"__real\",\t\tRID_REALPART,\t0 },\n+  { \"__real__\",\t\tRID_REALPART,\t0 },\n+  { \"__restrict\",\tRID_RESTRICT,\t0 },\n+  { \"__restrict__\",\tRID_RESTRICT,\t0 },\n+  { \"__signed\",\t\tRID_SIGNED,\t0 },\n+  { \"__signed__\",\tRID_SIGNED,\t0 },\n+  { \"__typeof\",\t\tRID_TYPEOF,\t0 },\n+  { \"__typeof__\",\tRID_TYPEOF,\t0 },\n+  { \"__unbounded\",\tRID_UNBOUNDED,\t0 },\n+  { \"__unbounded__\",\tRID_UNBOUNDED,\t0 },\n+  { \"__volatile\",\tRID_VOLATILE,\t0 },\n+  { \"__volatile__\",\tRID_VOLATILE,\t0 },\n+  { \"asm\",\t\tRID_ASM,\tD_EXT },\n+  { \"auto\",\t\tRID_AUTO,\t0 },\n+  { \"break\",\t\tRID_BREAK,\t0 },\n+  { \"case\",\t\tRID_CASE,\t0 },\n+  { \"char\",\t\tRID_CHAR,\t0 },\n+  { \"const\",\t\tRID_CONST,\tD_TRAD },\n+  { \"continue\",\t\tRID_CONTINUE,\t0 },\n+  { \"default\",\t\tRID_DEFAULT,\t0 },\n+  { \"do\",\t\tRID_DO,\t\t0 },\n+  { \"double\",\t\tRID_DOUBLE,\t0 },\n+  { \"else\",\t\tRID_ELSE,\t0 },\n+  { \"enum\",\t\tRID_ENUM,\t0 },\n+  { \"extern\",\t\tRID_EXTERN,\t0 },\n+  { \"float\",\t\tRID_FLOAT,\t0 },\n+  { \"for\",\t\tRID_FOR,\t0 },\n+  { \"goto\",\t\tRID_GOTO,\t0 },\n+  { \"if\",\t\tRID_IF,\t\t0 },\n+  { \"inline\",\t\tRID_INLINE,\tD_TRAD|D_EXT89 },\n+  { \"int\",\t\tRID_INT,\t0 },\n+  { \"long\",\t\tRID_LONG,\t0 },\n+  { \"register\",\t\tRID_REGISTER,\t0 },\n+  { \"restrict\",\t\tRID_RESTRICT,\tD_TRAD|D_C89 },\n+  { \"return\",\t\tRID_RETURN,\t0 },\n+  { \"short\",\t\tRID_SHORT,\t0 },\n+  { \"signed\",\t\tRID_SIGNED,\tD_TRAD },\n+  { \"sizeof\",\t\tRID_SIZEOF,\t0 },\n+  { \"static\",\t\tRID_STATIC,\t0 },\n+  { \"struct\",\t\tRID_STRUCT,\t0 },\n+  { \"switch\",\t\tRID_SWITCH,\t0 },\n+  { \"typedef\",\t\tRID_TYPEDEF,\t0 },\n+  { \"typeof\",\t\tRID_TYPEOF,\tD_TRAD|D_EXT },\n+  { \"union\",\t\tRID_UNION,\t0 },\n+  { \"unsigned\",\t\tRID_UNSIGNED,\t0 },\n+  { \"void\",\t\tRID_VOID,\t0 },\n+  { \"volatile\",\t\tRID_VOLATILE,\tD_TRAD },\n+  { \"while\",\t\tRID_WHILE,\t0 },\n+ifobjc\n+  { \"@class\",\t\tRID_AT_CLASS,\t\tD_OBJC },\n+  { \"@compatibility_alias\", RID_AT_ALIAS,\tD_OBJC },\n+  { \"@defs\",\t\tRID_AT_DEFS,\t\tD_OBJC },\n+  { \"@encode\",\t\tRID_AT_ENCODE,\t\tD_OBJC },\n+  { \"@end\",\t\tRID_AT_END,\t\tD_OBJC },\n+  { \"@implementation\",\tRID_AT_IMPLEMENTATION,\tD_OBJC },\n+  { \"@interface\",\tRID_AT_INTERFACE,\tD_OBJC },\n+  { \"@private\",\t\tRID_AT_PRIVATE,\t\tD_OBJC },\n+  { \"@protected\",\tRID_AT_PROTECTED,\tD_OBJC },\n+  { \"@protocol\",\tRID_AT_PROTOCOL,\tD_OBJC },\n+  { \"@public\",\t\tRID_AT_PUBLIC,\t\tD_OBJC },\n+  { \"@selector\",\tRID_AT_SELECTOR,\tD_OBJC },\n+  { \"id\",\t\tRID_ID,\t\t\tD_OBJC },\n+  { \"bycopy\",\t\tRID_BYCOPY,\t\tD_OBJC|D_YES },\n+  { \"byref\",\t\tRID_BYREF,\t\tD_OBJC|D_YES },\n+  { \"in\",\t\tRID_IN,\t\t\tD_OBJC|D_YES },\n+  { \"inout\",\t\tRID_INOUT,\t\tD_OBJC|D_YES },\n+  { \"oneway\",\t\tRID_ONEWAY,\t\tD_OBJC|D_YES },\n+  { \"out\",\t\tRID_OUT,\t\tD_OBJC|D_YES },\n+end ifobjc\n+};\n+#define N_reswords (sizeof reswords / sizeof (struct resword))\n+\n+/* Table mapping from RID_* constants to yacc token numbers.\n+   Unfortunately we have to have entries for all the keywords in all\n+   three languages.  */\n+static const short rid_to_yy[RID_MAX] =\n+{\n+  /* RID_STATIC */\tSCSPEC,\n+  /* RID_UNSIGNED */\tTYPESPEC,\n+  /* RID_LONG */\tTYPESPEC,\n+  /* RID_CONST */\tTYPE_QUAL,\n+  /* RID_EXTERN */\tSCSPEC,\n+  /* RID_REGISTER */\tSCSPEC,\n+  /* RID_TYPEDEF */\tSCSPEC,\n+  /* RID_SHORT */\tTYPESPEC,\n+  /* RID_INLINE */\tSCSPEC,\n+  /* RID_VOLATILE */\tTYPE_QUAL,\n+  /* RID_SIGNED */\tTYPESPEC,\n+  /* RID_AUTO */\tSCSPEC,\n+  /* RID_RESTRICT */\tTYPE_QUAL,\n+\n+  /* C extensions */\n+  /* RID_BOUNDED */\tTYPE_QUAL,\n+  /* RID_UNBOUNDED */\tTYPE_QUAL,\n+  /* RID_COMPLEX */\tTYPESPEC,\n+\n+  /* C++ */\n+  /* RID_FRIEND */\t0,\n+  /* RID_VIRTUAL */\t0,\n+  /* RID_EXPLICIT */\t0,\n+  /* RID_EXPORT */\t0,\n+  /* RID_MUTABLE */\t0,\n+\n+  /* ObjC */\n+  /* RID_IN */\t\tTYPE_QUAL,\n+  /* RID_OUT */\t\tTYPE_QUAL,\n+  /* RID_INOUT */\tTYPE_QUAL,\n+  /* RID_BYCOPY */\tTYPE_QUAL,\n+  /* RID_BYREF */\tTYPE_QUAL,\n+  /* RID_ONEWAY */\tTYPE_QUAL,\n+  \n+  /* C */\n+  /* RID_INT */\t\tTYPESPEC,\n+  /* RID_CHAR */\tTYPESPEC,\n+  /* RID_FLOAT */\tTYPESPEC,\n+  /* RID_DOUBLE */\tTYPESPEC,\n+  /* RID_VOID */\tTYPESPEC,\n+  /* RID_ENUM */\tENUM,\n+  /* RID_STRUCT */\tSTRUCT,\n+  /* RID_UNION */\tUNION,\n+  /* RID_IF */\t\tIF,\n+  /* RID_ELSE */\tELSE,\n+  /* RID_WHILE */\tWHILE,\n+  /* RID_DO */\t\tDO,\n+  /* RID_FOR */\t\tFOR,\n+  /* RID_SWITCH */\tSWITCH,\n+  /* RID_CASE */\tCASE,\n+  /* RID_DEFAULT */\tDEFAULT,\n+  /* RID_BREAK */\tBREAK,\n+  /* RID_CONTINUE */\tCONTINUE,\n+  /* RID_RETURN */\tRETURN,\n+  /* RID_GOTO */\tGOTO,\n+  /* RID_SIZEOF */\tSIZEOF,\n+\n+  /* C extensions */\n+  /* RID_ASM */\t\tASM_KEYWORD,\n+  /* RID_TYPEOF */\tTYPEOF,\n+  /* RID_ALIGNOF */\tALIGNOF,\n+  /* RID_ATTRIBUTE */\tATTRIBUTE,\n+  /* RID_VA_ARG */\tVA_ARG,\n+  /* RID_EXTENSION */\tEXTENSION,\n+  /* RID_IMAGPART */\tIMAGPART,\n+  /* RID_REALPART */\tREALPART,\n+  /* RID_LABEL */\tLABEL,\n+  /* RID_PTRBASE */\tPTR_BASE,\n+  /* RID_PTREXTENT */\tPTR_EXTENT,\n+  /* RID_PTRVALUE */\tPTR_VALUE,\n+\n+  /* C++ */\n+  /* RID_BOOL */\t0,\n+  /* RID_WCHAR */\t0,\n+  /* RID_CLASS */\t0,\n+  /* RID_PUBLIC */\t0,\n+  /* RID_PRIVATE */\t0,\n+  /* RID_PROTECTED */\t0,\n+  /* RID_TEMPLATE */\t0,\n+  /* RID_NULL */\t0,\n+  /* RID_CATCH */\t0,\n+  /* RID_DELETE */\t0,\n+  /* RID_FALSE */\t0,\n+  /* RID_NAMESPACE */\t0,\n+  /* RID_NEW */\t\t0,\n+  /* RID_OPERATOR */\t0,\n+  /* RID_THIS */\t0,\n+  /* RID_THROW */\t0,\n+  /* RID_TRUE */\t0,\n+  /* RID_TRY */\t\t0,\n+  /* RID_TYPENAME */\t0,\n+  /* RID_TYPEID */\t0,\n+  /* RID_USING */\t0,\n+\n+  /* casts */\n+  /* RID_CONSTCAST */\t0,\n+  /* RID_DYNCAST */\t0,\n+  /* RID_REINTCAST */\t0,\n+  /* RID_STATCAST */\t0,\n+\n+  /* alternate spellings */\n+  /* RID_AND */\t\t0,\n+  /* RID_AND_EQ */\t0,\n+  /* RID_NOT */\t\t0,\n+  /* RID_NOT_EQ */\t0,\n+  /* RID_OR */\t\t0,\n+  /* RID_OR_EQ */\t0,\n+  /* RID_XOR */\t\t0,\n+  /* RID_XOR_EQ */\t0,\n+  /* RID_BITAND */\t0,\n+  /* RID_BITOR */\t0,\n+  /* RID_COMPL */\t0,\n+\n+  /* Objective C */\n+  /* RID_ID */\t\t\tOBJECTNAME,\n+  /* RID_AT_ENCODE */\t\tENCODE,\n+  /* RID_AT_END */\t\tEND,\n+  /* RID_AT_CLASS */\t\tCLASS,\n+  /* RID_AT_ALIAS */\t\tALIAS,\n+  /* RID_AT_DEFS */\t\tDEFS,\n+  /* RID_AT_PRIVATE */\t\tPRIVATE,\n+  /* RID_AT_PROTECTED */\tPROTECTED,\n+  /* RID_AT_PUBLIC */\t\tPUBLIC,\n+  /* RID_AT_PROTOCOL */\t\tPROTOCOL,\n+  /* RID_AT_SELECTOR */\t\tSELECTOR,\n+  /* RID_AT_INTERFACE */\tINTERFACE,\n+  /* RID_AT_IMPLEMENTATION */\tIMPLEMENTATION\n+};\n+\n+static void\n+init_reswords ()\n+{\n+  unsigned int i;\n+  tree id;\n+  int mask = (D_YES\n+\t      | (doing_objc_thang ? 0 : D_OBJC)\n+\t      | (flag_isoc99 ? 0 : D_C89)\n+\t      | (flag_traditional ? D_TRAD : 0)\n+\t      | (flag_no_asm ? (flag_isoc99 ? D_EXT : D_EXT|D_EXT89) : 0));\n+\n+  /* It is not necessary to register ridpointers as a GC root, because\n+     all the trees it points to are permanently interned in the\n+     get_identifier hash anyway.  */\n+  ridpointers = (tree *) xcalloc ((int) RID_MAX, sizeof (tree));\n+  for (i = 0; i < N_reswords; i++)\n+    {\n+      id = get_identifier (reswords[i].word);\n+      C_RID_CODE (id) = reswords[i].rid;\n+      ridpointers [(int) reswords[i].rid] = id;\n+      if (! (reswords[i].disable & mask))\n+\tC_IS_RESERVED_WORD (id) = 1;\n+    }\n+}\n+\n+const char *\n+init_parse (filename)\n+     const char *filename;\n+{\n+  add_c_tree_codes ();\n+\n+  /* Make identifier nodes long enough for the language-specific slots.  */\n+  set_identifier_size (sizeof (struct lang_identifier));\n+\n+  init_reswords ();\n+  init_pragma ();\n+\n+  return init_c_lex (filename);\n+}\n+\n+void\n+finish_parse ()\n+{\n+#if USE_CPPLIB\n+  cpp_finish (&parse_in, 0 /* no printer */);\n+  errorcount += parse_in.errors;\n+#else\n+  fclose (finput);\n+#endif\n+}\n+\n+#if USE_CPPLIB\n+#define NAME(type) cpp_type2name (type)\n+#else\n+/* Bleah */\n+#include \"symcat.h\"\n+#define OP(e, s) s,\n+#define TK(e, s) STRINGX(e),\n+\n+static const char *type2name[N_TTYPES] = { TTYPE_TABLE };\n+#define NAME(type) type2name[type]\n+#endif\n+\n+static void\n+yyerror (msgid)\n+     const char *msgid;\n+{\n+  const char *string = _(msgid);\n+\n+  if (last_token == CPP_EOF)\n+    error (\"%s at end of input\", string);\n+  else if (last_token == CPP_CHAR || last_token == CPP_WCHAR)\n+    {\n+      unsigned int val = TREE_INT_CST_LOW (yylval.ttype);\n+      const char *ell = (last_token == CPP_CHAR) ? \"\" : \"L\";\n+      if (val <= UCHAR_MAX && ISGRAPH (val))\n+\terror (\"%s before %s'%c'\", string, ell, val);\n+      else\n+\terror (\"%s before %s'\\\\x%x'\", string, ell, val);\n+    }\n+  else if (last_token == CPP_STRING\n+\t   || last_token == CPP_WSTRING\n+\t   || last_token == CPP_OSTRING)\n+    error (\"%s before string constant\", string);\n+  else if (last_token == CPP_NUMBER\n+\t   || last_token == CPP_INT\n+\t   || last_token == CPP_FLOAT)\n+    error (\"%s before numeric constant\", string);\n+  else if (last_token == CPP_NAME)\n+    error (\"%s before \\\"%s\\\"\", string, IDENTIFIER_POINTER (yylval.ttype));\n+  else\n+    error (\"%s before '%s' token\", string, NAME(last_token));\n+}\n+\n+static inline int\n+_yylex ()\n+{\n+ retry:\n+  last_token = c_lex (&yylval.ttype);\n+\n+  switch (last_token)\n+    {\n+    case CPP_EQ:\t\t\t\t\treturn '=';\n+    case CPP_NOT:\t\t\t\t\treturn '!';\n+    case CPP_GREATER:\tyylval.code = GT_EXPR;\t\treturn ARITHCOMPARE;\n+    case CPP_LESS:\tyylval.code = LT_EXPR;\t\treturn ARITHCOMPARE;\n+    case CPP_PLUS:\tyylval.code = PLUS_EXPR;\treturn '+';\n+    case CPP_MINUS:\tyylval.code = MINUS_EXPR;\treturn '-';\n+    case CPP_MULT:\tyylval.code = MULT_EXPR;\treturn '*';\n+    case CPP_DIV:\tyylval.code = TRUNC_DIV_EXPR;\treturn '/';\n+    case CPP_MOD:\tyylval.code = TRUNC_MOD_EXPR;\treturn '%';\n+    case CPP_AND:\tyylval.code = BIT_AND_EXPR;\treturn '&';\n+    case CPP_OR:\tyylval.code = BIT_IOR_EXPR;\treturn '|';\n+    case CPP_XOR:\tyylval.code = BIT_XOR_EXPR;\treturn '^';\n+    case CPP_RSHIFT:\tyylval.code = RSHIFT_EXPR;\treturn RSHIFT;\n+    case CPP_LSHIFT:\tyylval.code = LSHIFT_EXPR;\treturn LSHIFT;\n+\n+    case CPP_COMPL:\t\t\t\t\treturn '~';\n+    case CPP_AND_AND:\t\t\t\t\treturn ANDAND;\n+    case CPP_OR_OR:\t\t\t\t\treturn OROR;\n+    case CPP_QUERY:\t\t\t\t\treturn '?';\n+    case CPP_COLON:\t\t\t\t\treturn ':';\n+    case CPP_COMMA:\t\t\t\t\treturn ',';\n+    case CPP_OPEN_PAREN:\t\t\t\treturn '(';\n+    case CPP_CLOSE_PAREN:\t\t\t\treturn ')';\n+    case CPP_EQ_EQ:\tyylval.code = EQ_EXPR;\t\treturn EQCOMPARE;\n+    case CPP_NOT_EQ:\tyylval.code = NE_EXPR;\t\treturn EQCOMPARE;\n+    case CPP_GREATER_EQ:yylval.code = GE_EXPR;\t\treturn ARITHCOMPARE;\n+    case CPP_LESS_EQ:\tyylval.code = LE_EXPR;\t\treturn ARITHCOMPARE;\n+\n+    case CPP_PLUS_EQ:\tyylval.code = PLUS_EXPR;\treturn ASSIGN;\n+    case CPP_MINUS_EQ:\tyylval.code = MINUS_EXPR;\treturn ASSIGN;\n+    case CPP_MULT_EQ:\tyylval.code = MULT_EXPR;\treturn ASSIGN;\n+    case CPP_DIV_EQ:\tyylval.code = TRUNC_DIV_EXPR;\treturn ASSIGN;\n+    case CPP_MOD_EQ:\tyylval.code = TRUNC_MOD_EXPR;\treturn ASSIGN;\n+    case CPP_AND_EQ:\tyylval.code = BIT_AND_EXPR;\treturn ASSIGN;\n+    case CPP_OR_EQ:\tyylval.code = BIT_IOR_EXPR;\treturn ASSIGN;\n+    case CPP_XOR_EQ:\tyylval.code = BIT_XOR_EXPR;\treturn ASSIGN;\n+    case CPP_RSHIFT_EQ:\tyylval.code = RSHIFT_EXPR;\treturn ASSIGN;\n+    case CPP_LSHIFT_EQ:\tyylval.code = LSHIFT_EXPR;\treturn ASSIGN;\n+\n+    case CPP_OPEN_SQUARE:\t\t\t\treturn '[';\n+    case CPP_CLOSE_SQUARE:\t\t\t\treturn ']';\n+    case CPP_OPEN_BRACE:\t\t\t\treturn '{';\n+    case CPP_CLOSE_BRACE:\t\t\t\treturn '}';\n+    case CPP_SEMICOLON:\t\t\t\t\treturn ';';\n+    case CPP_ELLIPSIS:\t\t\t\t\treturn ELLIPSIS;\n+\n+    case CPP_PLUS_PLUS:\t\t\t\t\treturn PLUSPLUS;\n+    case CPP_MINUS_MINUS:\t\t\t\treturn MINUSMINUS;\n+    case CPP_DEREF:\t\t\t\t\treturn POINTSAT;\n+    case CPP_DOT:\t\t\t\t\treturn '.';\n+\n+    case CPP_EOF:\n+#if USE_CPPLIB\n+      cpp_pop_buffer (&parse_in);\n+      if (! CPP_BUFFER (&parse_in))\n+#endif\n+\treturn 0;\n+      goto retry;\n+\n+    case CPP_NAME:\n+      if (C_IS_RESERVED_WORD (yylval.ttype))\n+\treturn rid_to_yy[C_RID_CODE (yylval.ttype)];\n+\n+      if (IDENTIFIER_POINTER (yylval.ttype)[0] == '@')\n+\t{\n+\t  error (\"invalid identifier `%s'\", IDENTIFIER_POINTER (yylval.ttype));\n+\t  return IDENTIFIER;\n+\t}\n+\n+      {\n+\ttree decl;\n+\n+\tdecl = lookup_name (yylval.ttype);\n+\n+\tif (decl)\n+\t  {\n+\t    if (TREE_CODE (decl) == TYPE_DECL)\n+\t      return TYPENAME;\n+\t    /* A user-invisible read-only initialized variable\n+\t       should be replaced by its value.\n+\t       We handle only strings since that's the only case used in C.  */\n+\t    else if (TREE_CODE (decl) == VAR_DECL\n+\t\t     && DECL_IGNORED_P (decl)\n+\t\t     && TREE_READONLY (decl)\n+\t\t     && DECL_INITIAL (decl) != 0\n+\t\t     && TREE_CODE (DECL_INITIAL (decl)) == STRING_CST)\n+\t      {\n+\t\ttree stringval = DECL_INITIAL (decl);\n+\n+\t\t/* Copy the string value so that we won't clobber anything\n+\t\t   if we put something in the TREE_CHAIN of this one.  */\n+\t\tyylval.ttype = build_string (TREE_STRING_LENGTH (stringval),\n+\t\t\t\t\t     TREE_STRING_POINTER (stringval));\n+\t\treturn STRING;\n+\t      }\n+\t  }\n+\telse if (doing_objc_thang)\n+\t  {\n+\t    tree objc_interface_decl = is_class_name (yylval.ttype);\n+\n+\t    if (objc_interface_decl)\n+\t      {\n+\t\tyylval.ttype = objc_interface_decl;\n+\t\treturn CLASSNAME;\n+\t      }\n+\t  }\n+\n+\treturn IDENTIFIER;\n+      }\n+\n+    case CPP_INT:\n+    case CPP_FLOAT:\n+    case CPP_NUMBER:\n+    case CPP_CHAR:\n+    case CPP_WCHAR:\n+      return CONSTANT;\n+\n+    case CPP_STRING:\n+    case CPP_WSTRING:\n+      return STRING;\n+      \n+    case CPP_OSTRING:\n+      return OBJC_STRING;\n+\n+      /* These tokens are C++ specific (and will not be generated\n+         in C mode, but let's be cautious).  */\n+    case CPP_SCOPE:\n+    case CPP_DEREF_STAR:\n+    case CPP_DOT_STAR:\n+    case CPP_MIN_EQ:\n+    case CPP_MAX_EQ:\n+    case CPP_MIN:\n+    case CPP_MAX:\n+      /* These tokens should not survive translation phase 4.  */\n+    case CPP_HASH:\n+    case CPP_PASTE:\n+    case CPP_BACKSLASH:\n+      error (\"syntax error before '%s' token\", NAME(last_token));\n+      goto retry;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  /* NOTREACHED */\n+}\n+\n+static int\n+yylex()\n+{\n+  int r;\n+  timevar_push (TV_LEX);\n+  r = _yylex();\n+  timevar_pop (TV_LEX);\n+  return r;\n+}\n+\n+/* Sets the value of the 'yydebug' variable to VALUE.\n+   This is a function so we don't have to have YYDEBUG defined\n+   in order to build the compiler.  */\n+\n+void\n+set_yydebug (value)\n+     int value;\n+{\n+#if YYDEBUG != 0\n+  yydebug = value;\n+#else\n+  warning (\"YYDEBUG not defined.\");\n+#endif\n+}\n+\n+/* Function used when yydebug is set, to print a token in more detail.  */\n+\n+static void\n+yyprint (file, yychar, yyl)\n+     FILE *file;\n+     int yychar;\n+     YYSTYPE yyl;\n+{\n+  tree t = yyl.ttype;\n+\n+  fprintf (file, \" [%s]\", NAME(last_token));\n+  \n+  switch (yychar)\n+    {\n+    case IDENTIFIER:\n+    case TYPENAME:\n+    case OBJECTNAME:\n+    case TYPESPEC:\n+    case TYPE_QUAL:\n+    case SCSPEC:\n+      if (IDENTIFIER_POINTER (t))\n+\tfprintf (file, \" `%s'\", IDENTIFIER_POINTER (t));\n+      break;\n+\n+    case CONSTANT:\n+      fprintf (file, \" %s\", GET_MODE_NAME (TYPE_MODE (TREE_TYPE (t))));\n+      if (TREE_CODE (t) == INTEGER_CST)\n+\tfprintf (file,\n+#if HOST_BITS_PER_WIDE_INT == 64\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n+\t\t \" 0x%x%016x\",\n+#else\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_LONG\n+\t\t \" 0x%lx%016lx\",\n+#else\n+\t\t \" 0x%llx%016llx\",\n+#endif\n+#endif\n+#else\n+#if HOST_BITS_PER_WIDE_INT != HOST_BITS_PER_INT\n+\t\t \" 0x%lx%08lx\",\n+#else\n+\t\t \" 0x%x%08x\",\n+#endif\n+#endif\n+\t\t TREE_INT_CST_HIGH (t), TREE_INT_CST_LOW (t));\n+      break;\n+    }\n+}\n+\f\n+/* This is not the ideal place to put these, but we have to get them out\n+   of c-lex.c because cp/lex.c has its own versions.  */\n+\n+/* Return something to represent absolute declarators containing a *.\n+   TARGET is the absolute declarator that the * contains.\n+   TYPE_QUALS is a list of modifiers such as const or volatile\n+   to apply to the pointer type, represented as identifiers.\n+\n+   We return an INDIRECT_REF whose \"contents\" are TARGET\n+   and whose type is the modifier list.  */\n+\n+tree\n+make_pointer_declarator (type_quals, target)\n+     tree type_quals, target;\n+{\n+  return build1 (INDIRECT_REF, type_quals, target);\n+}"}, {"sha": "2d6bee838745fea1cf523d0d2bae926ce4c515f6", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 276, "deletions": 287, "changes": 563, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -28,9 +28,28 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"toplev.h\"\n #include \"ggc.h\"\n+#include \"c-lex.h\"\n+#include \"cpplib.h\"\n \n #ifdef HANDLE_GENERIC_PRAGMAS\n \n+#if USE_CPPLIB\n+extern cpp_reader parse_in;\n+#else\n+struct pragma_entry;\n+static struct pragma_entry *pragmas;\n+\n+void cpp_register_pragma PARAMS ((cpp_reader *, const char *, const char *,\n+\t\t\t\t  void (*) PARAMS ((cpp_reader *)) ));\n+void cpp_register_pragma_space PARAMS ((cpp_reader *, const char *));\n+#endif\n+\n+#define BAD(msgid) do { warning (msgid); return; } while (0)\n+#define BAD2(msgid, arg) do { warning (msgid, arg); return; } while (0)\n+\n+#ifdef HANDLE_PRAGMA_PACK\n+static void handle_pragma_pack PARAMS ((cpp_reader *));\n+\n #ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n typedef struct align_stack\n {\n@@ -48,34 +67,19 @@ static struct align_stack * alignment_stack = NULL;\n    happens, we restore the value to this, not to a value of 0 for\n    maximum_field_alignment.  Value is in bits. */\n static int  default_alignment;\n+#define SET_GLOBAL_ALIGNMENT(ALIGN) \\\n+(default_alignment = maximum_field_alignment = (ALIGN))\n \n-static int  push_alignment PARAMS ((int, tree));\n-static int  pop_alignment  PARAMS ((tree));\n-#ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n+static void push_alignment PARAMS ((int, tree));\n+static void pop_alignment  PARAMS ((tree));\n static void mark_align_stack PARAMS ((void *));\n-#endif\n \n /* Push an alignment value onto the stack.  */\n-static int\n+static void\n push_alignment (alignment, id)\n      int alignment;\n      tree id;\n {\n-  switch (alignment)\n-    {\n-    case 0:\n-    case 1:\n-    case 2:\n-    case 4:\n-    case 8:\n-    case 16:\n-      break;\n-    default:\n-      warning (\"\\\n-Alignment must be a small power of two, not %d, in #pragma pack\",\n-\t       alignment);\n-      return 0;\n-    }\n   \n   if (alignment_stack == NULL\n       || alignment_stack->alignment != alignment\n@@ -98,16 +102,14 @@ Alignment must be a small power of two, not %d, in #pragma pack\",\n       \n       alignment_stack = entry;\n \n-      maximum_field_alignment = alignment * BITS_PER_UNIT;\n+      maximum_field_alignment = alignment;\n     }\n   else\n     alignment_stack->num_pushes ++;\n-\n-  return 1;\n }\n \n /* Undo a push of an alignment onto the stack.  */\n-static int\n+static void\n pop_alignment (id)\n      tree id;\n {\n@@ -118,7 +120,7 @@ pop_alignment (id)\n       warning (\"\\\n #pragma pack (pop) encountered without matching #pragma pack (push, <n>)\"\n \t       );\n-      return 0;\n+      return;\n     }\n \n   /* If we got an identifier, strip away everything above the target\n@@ -145,320 +147,307 @@ pop_alignment (id)\n       if (entry == NULL)\n \tmaximum_field_alignment = default_alignment;\n       else\n-\tmaximum_field_alignment = entry->alignment * BITS_PER_UNIT;\n+\tmaximum_field_alignment = entry->alignment;\n \n       free (alignment_stack);\n \n       alignment_stack = entry;\n     }\n-\n-  return 1;\n }\n-#endif /* HANDLE_PRAGMA_PACK_PUSH_POP */\n-\f\n-/* Handle one token of a pragma directive.  TOKEN is the current token, and\n-   STRING is its printable form.  Some front ends do not support generating\n-   tokens, and will only pass in a STRING.  Also some front ends will reuse\n-   the buffer containing STRING, so it must be copied to a local buffer if\n-   it needs to be preserved.\n-\n-   If STRING is non-NULL, then the return value will be ignored, and there\n-   will be futher calls to handle_pragma_token in order to handle the rest of\n-   the line containing the #pragma directive.  If STRING is NULL, the entire\n-   line has now been presented to handle_pragma_token and the return value\n-   should be zero if the pragma flawed in some way, or if the pragma was not\n-   recognised, and non-zero if it was successfully handled.  */\n-\n-int\n-handle_pragma_token (string, token)\n-     const char *string;\n-     tree token;\n+\n+static void\n+mark_align_stack (p)\n+    void *p;\n {\n-  static enum pragma_state state = ps_start;\n-  static enum pragma_state type;\n-#ifdef HANDLE_PRAGMA_WEAK\n-  static char *name;\n-  static char *value;\n-#endif\n-#if defined(HANDLE_PRAGMA_PACK) || defined(HANDLE_PRAGMA_PACK_PUSH_POP)\n-  static unsigned int align;\n-#endif\n-  static tree id;\n+  align_stack *a = *(align_stack **) p;\n \n-  /* If we have reached the end of the #pragma directive then\n-     determine what value we should return.  */\n-  \n-  if (string == NULL)\n+  while (a)\n     {\n-      int ret_val = 0;\n-\n-      switch (type)\n-\t{\n-\tdefault:\n-\t  abort ();\n-\t  break;\n-\n-\tcase ps_done:\n-\t  /* The pragma was not recognised.  */\n-\t  break;\n-\t  \n-#ifdef HANDLE_PRAGMA_PACK\t  \n-\tcase ps_pack:\n-\t  if (state == ps_right)\n-\t    {\n-\t      maximum_field_alignment = align * BITS_PER_UNIT;\n-#ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n-\t      default_alignment = maximum_field_alignment;\n-#endif\n-\t      ret_val = 1;\n-\t    }\n-\t  else\n-\t    warning (\"malformed `#pragma pack'\");\n-\t  break;\n-#endif /* HANDLE_PRAGMA_PACK */\n-\t  \n-#ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n-\tcase ps_push:\n-\t  if (state == ps_right)\n-\t    ret_val = push_alignment (align, id);\n-\t  else\n-\t    warning (\"malformed '#pragma pack(push[,id],<n>)'\");\n-\t  break;\n-\t  \n-\tcase ps_pop:\n-\t  if (state == ps_right)\n-\t    ret_val = pop_alignment (id);\n-\t  else\n-\t    warning (\"malformed '#pragma pack(pop[,id])'\");\n-\t  break;\n+      ggc_mark_tree (a->id);\n+      a = a->prev;\n+    }\n+}\n+#else  /* not HANDLE_PRAGMA_PACK_PUSH_POP */\n+#define SET_GLOBAL_ALIGNMENT(ALIGN) (maximum_field_alignment = (ALIGN))\n+#define push_alignment(ID, N) \\\n+    BAD(\"#pragma pack(push[, id], <n>) is not supported on this target\")\n+#define pop_alignment(ID) \\\n+    BAD(\"#pragma pack(pop[, id], <n>) is not supported on this target\")\n #endif /* HANDLE_PRAGMA_PACK_PUSH_POP */\n-\t  \n-#ifdef HANDLE_PRAGMA_WEAK\n-\tcase ps_weak:\n-\t  if (HANDLE_PRAGMA_WEAK)\n-\t    {\n-\t      if (state == ps_name)\n-\t\tret_val = add_weak (name, NULL);\n-\t      else if (state == ps_value)\n-\t\tret_val = add_weak (name, value);\n-\t      else\n-\t\twarning (\"malformed `#pragma weak'\");\n-\t    }\n-\t  else\n-\t    ret_val = 1; /* Ignore the pragma.  */\n-\t  break;\n-#endif /* HANDLE_PRAGMA_WEAK */\n-\n-\tcase ps_poison:\n-\t  ret_val = 1;\n-\t  break;\n-\t}\n \n-      type = state = ps_start;\n-      id = NULL_TREE;\n-      \n-      return ret_val;\n+/* #pragma pack ()\n+   #pragma pack (N)\n+   \n+   #pragma pack (push, N)\n+   #pragma pack (push, ID, N)\n+   #pragma pack (pop)\n+   #pragma pack (pop, ID) */\n+static void\n+handle_pragma_pack (dummy)\n+     cpp_reader *dummy ATTRIBUTE_UNUSED;\n+{\n+  tree x, id = 0;\n+  int align;\n+  enum cpp_ttype token;\n+  enum { set, reset, push, pop } action;\n+\n+  if (c_lex (&x) != CPP_OPEN_PAREN)\n+    BAD (\"missing '(' after '#pragma pack' - ignored\");\n+\n+  token = c_lex (&x);\n+  if (token == CPP_CLOSE_PAREN)\n+    action = reset;\n+  else if (token == CPP_NUMBER)\n+    {\n+      align = TREE_INT_CST_LOW (x);\n+      action = set;\n+    }\n+  else if (token == CPP_NAME)\n+    {\n+      if (!strcmp (IDENTIFIER_POINTER (x), \"push\"))\n+\taction = push;\n+      else if (!strcmp (IDENTIFIER_POINTER (x), \"pop\"))\n+\taction = pop;\n+      else\n+\tBAD2 (\"unknown action '%s' for '#pragma pack' - ignored\",\n+\t      IDENTIFIER_POINTER (x));\n     }\n+  else\n+    BAD (\"malformed '#pragma pack' - ignored\");\n \n-  /* If we have been given a token, but it is not an identifier,\n-     or a small constant, then something has gone wrong.  */\n-  if (token)\n+  token = c_lex (&x);\n+  if ((action == set || action == reset) && token != CPP_CLOSE_PAREN)\n+    BAD (\"malformed '#pragma pack' - ignored\");\n+  if ((action == push || action == pop) && token != CPP_COMMA)\n+    BAD2 (\"malformed '#pragma pack(%s[, id], <n>)' - ignored\",\n+\t  action == push ? \"push\" : \"pop\");\n+\n+  if (action == push || action == pop)\n     {\n-      switch (TREE_CODE (token))\n+      token = c_lex (&x);\n+      if (token == CPP_NAME)\n \t{\n-\tcase IDENTIFIER_NODE:\n-\t  break;\n-\t  \n-\tcase INTEGER_CST:\n-\t  if (TREE_INT_CST_HIGH (token) != 0)\n-\t    return 0;\n-\t  break;\n-\t  \n-\tdefault:\n-\t  return 0;\n+\t  id = x;\n+\t  if (c_lex (&x) != CPP_COMMA)\n+\t    BAD2 (\"malformed '#pragma pack(%s[, id], <n>)' - ignored\",\n+\t\t  action == push ? \"push\" : \"pop\");\n+\t  token = c_lex (&x);\n \t}\n+      if (token == CPP_NUMBER)\n+\talign = TREE_INT_CST_LOW (x);\n+      else\n+\tBAD2 (\"malformed '#pragma pack(%s[, id], <n>)' - ignored\",\n+\t      action == push ? \"push\" : \"pop\");\n+\n+      if (c_lex (&x) != CPP_CLOSE_PAREN)\n+\tBAD (\"malformed '#pragma pack' - ignored\");\n     }\n-      \n-  switch (state)\n+  if (c_lex (&x) != CPP_EOF)\n+    warning (\"junk at end of '#pragma pack'\");\n+\n+  switch (align)\n     {\n-    case ps_start:\n-      type = state = ps_done;\n-#ifdef HANDLE_PRAGMA_PACK\n-      if (strcmp (string, \"pack\") == 0)\n-\ttype = state = ps_pack;\n-#endif\n-#ifdef HANDLE_PRAGMA_WEAK\n-      if (strcmp (string, \"weak\") == 0)\n-\ttype = state = ps_weak;\n-#endif\n-      if (strcmp (string, \"poison\") == 0)\n-\ttype = state = ps_poison;\n+    case 0:\n+    case 1:\n+    case 2:\n+    case 4:\n+    case 8:\n+    case 16:\n+      align *= BITS_PER_UNIT;\n       break;\n+    default:\n+      BAD2 (\"alignment must be a small power of two, not %d\", align);\n+    }\n \n-#ifdef HANDLE_PRAGMA_WEAK\n-    case ps_weak:\n-      name = xstrdup (string);\n-      state = ps_name;\n-      break;\n-      \n-    case ps_name:\n-      state = (strcmp (string, \"=\") ? ps_bad : ps_equals);\n-      break;\n+  switch (action)\n+    {\n+    case set:   SET_GLOBAL_ALIGNMENT (align);  break;\n+    case reset: SET_GLOBAL_ALIGNMENT (0);      break;\n+    case push:  push_alignment (align, id);    break;\n+    case pop:   pop_alignment (id);            break;\n+    }\n+}\n+#endif  /* HANDLE_PRAGMA_PACK */\n \n-    case ps_equals:\n-      value = xstrdup (string);\n-      state = ps_value;\n-      break;\n+#ifdef HANDLE_PRAGMA_WEAK\n+static void handle_pragma_weak PARAMS ((cpp_reader *));\n \n-    case ps_value:\n-      state = ps_bad;\n-      break;\n-#endif /* HANDLE_PRAGMA_WEAK */\n-      \n-#ifdef HANDLE_PRAGMA_PACK\n-    case ps_pack:\n-      state = (strcmp (string, \"(\") ? ps_bad : ps_left);\n-      break;\n+/* #pragma weak name [= value] */\n+static void\n+handle_pragma_weak (dummy)\n+     cpp_reader *dummy ATTRIBUTE_UNUSED;\n+{\n+  tree name, value, x;\n+  enum cpp_ttype t;\n \n-    case ps_left:\n+  value = 0;\n \n-      if (token == NULL_TREE)\n-\t{\n-\t  /* #pragma pack () resets packing rules to their\n-\t     defaults.  */\n-\t  if (strcmp (string, \")\") == 0)\n-\t    {\n-\t      align = 0;\n-\t      state = ps_right;\n-\t    }\n-\t  else\n-\t    state = ps_bad;\n-\t}\n-      else if (TREE_CODE (token) == INTEGER_CST)\n-\tgoto handle_align;\n+  if (c_lex (&name) != CPP_NAME)\n+    BAD (\"malformed #pragma weak, ignored\");\n+  t = c_lex (&x);\n+  if (t == CPP_EQ)\n+    {\n+      if (c_lex (&value) != CPP_NAME)\n+\tBAD (\"malformed #pragma weak, ignored\");\n+      t = c_lex (&x);\n+    }\n+  if (t != CPP_EOF)\n+    warning (\"junk at end of #pragma weak\");\n \n-#ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n-      else if (TREE_CODE (token) == IDENTIFIER_NODE)\n-\t{\n-\t  if (strcmp (string, \"push\") == 0)\n-\t    type = state = ps_push;\n-\t  else if (strcmp (string, \"pop\") == 0)\n-\t    type = state = ps_pop;\n-\t  else\n-\t    state = ps_bad;\n-\t}\n+  add_weak (IDENTIFIER_POINTER (name), value ? IDENTIFIER_POINTER (value) : 0);\n+}\n #endif\n-      else\n-\tstate = ps_bad;\n-      break;\n \n-    handle_align:\n-      switch (tree_log2 (token))\n-\t{\n-\tcase 0:\n-\tcase 1:\n-\tcase 2:\n-\tcase 3:\n-\tcase 4:\n-\t  state = ps_align;\n-\t  align = 1 << tree_log2 (token);\n-\t  break;\n-\n-\tdefault:\n-\t  state = ps_bad;\n-\t  break;\n-\t}\n-      break;\n+#if !USE_CPPLIB\n+/* Glue version of cpplib's pragma registration and dispatch system.  */\n+struct pragma_entry\n+{\n+  struct pragma_entry *next;\n+  const char *name;\n+  size_t len;\n+  int isnspace;\n+  union {\n+    void (*handler) PARAMS ((cpp_reader *));\n+    struct pragma_entry *space;\n+  } u;\n+};\n \n-    case ps_align:\n-      state = (strcmp (string, \")\") ? ps_bad : ps_right);\n-      break;\n+void\n+cpp_register_pragma_space (pfile, space)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     const char *space;\n+{\n+  struct pragma_entry *new;\n+  const struct pragma_entry *p = pragmas;\n+  size_t len = strlen (space);\n \n-    case ps_right:\n-      state = ps_bad;\n-      break;\n-#endif /* HANDLE_PRAGMA_PACK */\n+  while (p)\n+    {\n+      if (p->isnspace && p->len == len && !memcmp (p->name, space, len))\n+\treturn;\n+      p = p->next;\n+    }\n \n-#ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n-    case ps_push:\n-      state = (strcmp (string, \",\") ? ps_bad : ps_pushcomma);\n-      break;\n+  new = (struct pragma_entry *) xmalloc (sizeof (struct pragma_entry));\n+  new->name = space;\n+  new->len = len;\n+  new->isnspace = 1;\n+  new->u.space = 0;\n \n-    case ps_pushid:\n-      state = (strcmp (string, \",\") ? ps_bad : ps_pushcomma2);\n-      break;\n+  new->next = pragmas;\n+  pragmas = new;\n+}\n \n-    case ps_pushcomma:\n-      if (token && TREE_CODE (token) == IDENTIFIER_NODE)\n+void\n+cpp_register_pragma (pfile, space, name, handler)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     const char *space;\n+     const char *name;\n+     void (*handler) PARAMS ((cpp_reader *));\n+{\n+  struct pragma_entry **x, *new;\n+  size_t len;\n+\n+  x = &pragmas;\n+  if (space)\n+    {\n+      struct pragma_entry *p = pragmas;\n+      len = strlen (space);\n+      while (p)\n \t{\n-\t  id = token;\n-\t  state = ps_pushid;\n-\t  break;\n+\t  if (p->isnspace && p->len == len && !memcmp (p->name, space, len))\n+\t    {\n+\t      x = &p->u.space;\n+\t      goto found;\n+\t    }\n+\t  p = p->next;\n \t}\n+      abort ();\n+    }\n \n-      /* else fall through */\n-    case ps_pushcomma2:\n-      if (token && TREE_CODE (token) == INTEGER_CST)\n-\tgoto handle_align;\n-      else\n-\tstate = ps_bad;\n-      break;\n+ found:\n+  new = (struct pragma_entry *) xmalloc (sizeof (struct pragma_entry));\n+  new->name = name;\n+  new->len = strlen (name);\n+  new->isnspace = 0;\n+  new->u.handler = handler;\n \n-    case ps_pop:\n-      if (strcmp (string, \",\") == 0)\n-\tstate = ps_popcomma;\n-      else\n-\tstate = (strcmp (string, \")\") ? ps_bad : ps_right);\n-      break;\n+  new->next = *x;\n+  *x = new;\n+}\n \n-    case ps_popcomma:\n-      if (token && TREE_CODE (token) == IDENTIFIER_NODE)\n-\t{\n-\t  id = token;\n-\t  state = ps_align;\n-\t}\n-      else\n-\tstate = ps_bad;\n-      break;\n-#endif /* HANDLE_PRAGMA_PACK_PUSH_POP */\n+/* Called from process_directive() for #pragma lines.  */\n+void\n+dispatch_pragma ()\n+{\n+  enum cpp_ttype t;\n+  tree x;\n+  const struct pragma_entry *p;\n+  const char *name;\n+  size_t len;\n \n-    case ps_poison:\n-      if (token && TREE_CODE (token) != IDENTIFIER_NODE)\n-\tstate = ps_bad;\n-      break;\n+  p = pragmas;\n \n-    case ps_bad:\n-    case ps_done:\n-      break;\n+ new_space:\n+  t = c_lex (&x);\n+  if (t == CPP_EOF)\n+    return;\n \n-    default:\n-      abort ();\n+  if (t != CPP_NAME)\n+    {\n+      warning (\"malformed #pragma directive\");\n+      return;\n     }\n \n-  return 1;\n-}\n-#endif /* HANDLE_GENERIC_PRAGMAS */\n-\f\n-#ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n-static void\n-mark_align_stack (p)\n-    void *p;\n-{\n-  align_stack *a = *(align_stack **) p;\n-\n-  while (a)\n+  name = IDENTIFIER_POINTER (x);\n+  len = IDENTIFIER_LENGTH (x);\n+  while (p)\n     {\n-      ggc_mark_tree (a->id);\n-      a = a->prev;\n+      if (strlen (p->name) == len && !memcmp (p->name, name, len))\n+\t{\n+\t  if (p->isnspace)\n+\t    {\n+\t      p = p->u.space;\n+\t      goto new_space;\n+\t    }\n+\t  else\n+\t    {\n+\t      (*p->u.handler) (0);\n+\t      return;\n+\t    }\n+\t}\n+      p = p->next;\n     }\n+\n+  /* Issue a warning message if we have been asked to do so.  Ignore\n+     unknown pragmas in system header file unless an explcit\n+     -Wunknown-pragmas has been given. */\n+  if (warn_unknown_pragmas > in_system_header)\n+    warning (\"ignoring pragma %s\", name);\n }\n+\n #endif\n \n void\n init_pragma ()\n {\n+#if !USE_CPPLIB\n+  cpp_reader *pfile = 0;\n+#else\n+  cpp_reader *pfile = &parse_in;\n+#endif\n+\n+#ifdef HANDLE_PRAGMA_PACK\n+  cpp_register_pragma (pfile, 0, \"pack\", handle_pragma_pack);\n+#endif\n+#ifdef HANDLE_PRAGMA_WEAK\n+  cpp_register_pragma (pfile, 0, \"weak\", handle_pragma_weak);\n+#endif\n+\n #ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n   ggc_add_root (&alignment_stack, 1, sizeof(alignment_stack),\n \t\tmark_align_stack);\n #endif\n }\n+\n+#endif /* HANDLE_GENERIC_PRAGMAS */"}, {"sha": "50d0f57ab7a598c64468133b2a03100588c3472f", "filename": "gcc/c-pragma.h", "status": "modified", "additions": 11, "deletions": 32, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.h?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -61,41 +61,20 @@ extern int add_weak PARAMS ((const char *, const char *));\n /* Define HANDLE_GENERIC_PRAGMAS if any kind of front-end pragma\n    parsing is to be done.  The code in GCC's generic C source files\n    will only look for the definition of this constant.  They will\n-   ignore definitions of HANDLE_PRAGMA_PACK and so on. \n-   With #pragma poison, this is always set.  */\n-#define HANDLE_GENERIC_PRAGMAS 1\n-\n-\n-#ifdef HANDLE_GENERIC_PRAGMAS\n-enum pragma_state\n-{\n-  ps_start,\n-  ps_done,\n-#ifdef HANDLE_PRAGMA_WEAK\n-  ps_weak,\n-  ps_name,\n-  ps_equals,\n-  ps_value,\n-#endif\n-#ifdef HANDLE_PRAGMA_PACK\n-  ps_pack,\n-  ps_left,\n-  ps_align,\n-  ps_right,\n+   ignore definitions of HANDLE_PRAGMA_PACK and so on.  */\n+#if defined HANDLE_PRAGMA_PACK || defined HANDLE_PRAGMA_WEAK\n+#define HANDLE_GENERIC_PRAGMAS\n #endif\n-#ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n-  ps_push, ps_pushcomma, ps_pushid, ps_pushcomma2,\n-  ps_pop, ps_popcomma,\n-#endif\n-  ps_poison,\n-  ps_bad\n-};\n \n-/* Handle a C style pragma */\n-extern int handle_pragma_token PARAMS ((const char *, tree));\n+#ifdef HANDLE_GENERIC_PRAGMAS\n+extern void init_pragma PARAMS ((void));\n \n-#endif /* HANDLE_GENERIC_PRAGMAS */\n+# if !USE_CPPLIB\n+extern void dispatch_pragma PARAMS ((void));\n+# endif\n \n-extern void init_pragma PARAMS ((void));\n+#else\n+# define init_pragma()\n+#endif\n \n #endif /* _C_PRAGMA_H */"}, {"sha": "290ebe9daa87a1efcaca1da307494510253b4833", "filename": "gcc/c-tree.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -28,13 +28,18 @@ Boston, MA 02111-1307, USA.  */\n \n /* The limbo_value is used for block level extern declarations, which need\n    to be type checked against subsequent extern declarations.  They can't\n-   be referenced after they fall out of scope, so they can't be global.  */\n+   be referenced after they fall out of scope, so they can't be global.\n+\n+   The rid_code field is used for keywords.  It is in all\n+   lang_identifier nodes, because some keywords are only special in a\n+   particular context.  */\n \n struct lang_identifier\n {\n   struct tree_identifier ignore;\n   tree global_value, local_value, label_value, implicit_decl;\n   tree error_locus, limbo_value;\n+  enum rid rid_code;\n };\n \n /* Macros for access to language-specific slots in an identifier.  */\n@@ -83,6 +88,14 @@ extern int pedantic;\n    nonzero if the definition of the type has already started.  */\n #define C_TYPE_BEING_DEFINED(type) TYPE_LANG_FLAG_0 (type)\n \n+/* In an IDENTIFIER_NODE, nonzero if this identifier is actually a\n+   keyword.  C_RID_CODE (node) is then the RID_* value of the keyword,\n+   and C_RID_YYCODE is the token number wanted by Yacc.  */\n+\n+#define C_IS_RESERVED_WORD(id) TREE_LANG_FLAG_0 (id)\n+#define C_RID_CODE(id) \\\n+  (((struct lang_identifier *) (id))->rid_code)\n+\n /* In a RECORD_TYPE, a sorted array of the fields of the type.  */\n struct lang_type\n {"}, {"sha": "4b28703e6d27d144847fe426ba66945a89341ce3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 238, "deletions": 189, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -1,3 +1,52 @@\n+2000-09-06  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\tIntegrated preprocessor.\n+\n+\t* Make-lang.in, Makefile.in: Remove all references to input.c,\n+\tgxx.gperf, and hash.h.  Add ../c-lex.o to C_OBJS.\n+\t* gxx.gperf, hash.h, input.c: Delete.\n+\t* lang-specs.h: Pass -lang-c++ to cc1plus so cpplib is\n+\tinitialized properly.\n+\n+\t* class.c (fixup_pending_inline): Take a tree, not a\n+\tstruct pending_inline *.  All callers changed.\n+\t(init_class_processing): Set RID_PUBLIC, RID_PRIVATE,\n+\tRID_PROTECTED entries in ridpointers[] array here.\n+\t* decl.c (duplicate_decls): Do not refer to struct\n+\tpending_inline.\n+\t(record_builtin_type, init_decl_processing): Use RID_MAX not\n+\tCP_RID_MAX.\n+\t(grokdeclarator): Use C_IS_RESERVED_WORD.\n+\t* decl2.c (lang_decode_option): Ignore -lang-c++ for sake of\n+\tcpplib.\n+\t(grok_x_components): Do not inspect pending_inlines chain.\n+\n+\t* cp-tree.h (struct lang_identifier): Add rid_code entry.\n+\t(C_IS_RESERVED_WORD, C_RID_CODE, C_RID_YYCODE): New.\n+\t(flag_no_gnu_keywords, flag_operator_names, rid_to_yy): Declare.\n+\t(DEFARG_LENGTH, struct pending_inline, TIME_IDENTIFIER_TIME,\n+\tTIME_IDENTIFIER_FILEINFO): Kill.\n+\tUpdate prototypes.\n+\t* lex.h: Expunge cp_rid.  Rewrite RIDBIT macros to use just a\n+\tsingle 32-bit word.\n+\t* parse.y: Call do_pending_inlines unconditionally.\n+\treinit_parse_for_method is now snarf_method.  fn.defpen is no\n+\tlonger necessary.  Remove unnecessary <itype> annotation on\n+\tSCOPE.  Do not refer to end_of_file or struct pending_inline.\n+\t* semantics.c (begin_inline_definitions): Call\n+\tdo_pending_inlines unconditionally.\n+\n+\t* lex.c: Remove all code now shared with C front end.\n+\tInitialize cpplib properly if USE_CPPLIB.  Put reserved words\n+\tinto the get_identifier table.  Rewrite pragma handling to\n+\twork with the registry.  Move code to save tokens for later\n+\tprocessing to spew.c.\n+\n+\t* spew.c: Rewrite everything in terms of token streams instead\n+\tof text.  Move routines here from lex.c / input.c as\n+\tappropriate.  GC-mark trees hanging off the pending inlines\n+\tchain.\n+\n 2000-09-06  Mark Mitchell  <mark@codesourcery.com>\n \n \t* NEWS: Mention that the named return value extension has been\n@@ -110,7 +159,7 @@\n \t(write_template_parm): Likewise.\n \t(write_template_template_parm): Check tree code instead of\n \tusing TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO.\n-\t* method.c (build_overload_nested_name): Add \n+\t* method.c (build_overload_nested_name): Add\n \tBOUND_TEMPLATE_TEMPLATE_PARM.\n \t(process_overload_item): Split TEMPLATE_TEMPLATE_PARM case.\n \t* parse.y (bad_parm): Add BOUND_TEMPLATE_TEMPLATE_PARM.\n@@ -215,10 +264,10 @@\n \t(write_component): Remove.\n \t(write_local_name): Add parameter.  Use direct local entity to\n \tdiscriminator calculation.\n-\t(write_class_enum_type): Pass another argument to write_name.\t\n+\t(write_class_enum_type): Pass another argument to write_name.\n \t(write_template_template_arg): Likewise.\n \t(make_guard_variable): Likewise.\n-\t\n+\n 2000-08-27  Jason Merrill  <jason@redhat.com>\n \n \t* decl.c (pushdecl): Matching decls for local externs are found in\n@@ -260,7 +309,7 @@\n \t(cp_tree_printer, print_function_argument_list, print_declaration,\n \tprint_expression, print_function_declaration,\n \tprint_function_parameter, print_type, print_cv_qualifier): New\n-\tfunctions. \n+\tfunctions.\n \t(init_error): Initialize lang_printer.\n \n 2000-08-24  Jason Merrill  <jason@redhat.com>\n@@ -292,18 +341,18 @@\n \t(write_type): Adjust call to write_function_type.\n \t* pt.c (instantiate_template): Instantiate alternate entry points\n \twhen instantiating the main function.\n-\t\n+\n 2000-08-23  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* error.c (cp_print_error_function): Don't use embedded '\\n' in\n-\toutput_printf. \n+\toutput_printf.\n \n 2000-08-23  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* decl.c (init_decl_processing): Remove bogus initialization.\n \t* error.c (lang_print_error_function): Restore here.\n-\t(init_error): Initialize print_error_function. \n-\t\n+\t(init_error): Initialize print_error_function.\n+\n 2000-08-22  Theodore Papadopoulo  <Theodore.Papadopoulo@sophia.inria.fr>\n \n \t* decl2.c (arg_assoc): Revert my 2000-08-11 change.\n@@ -339,10 +388,10 @@\n \t(print_template_context): Likewise.\n \t(current_tinst_level): Make static to reflect Brendan Kehoe's\n \tchange of 1995-04-13.\n-\t(push_tinst_level): Call print_instantiation_context. \n-\t\n+\t(push_tinst_level): Call print_instantiation_context.\n+\n 2000-08-21  Nix  <nix@esperi.demon.co.uk>\n-        \n+\n \t* lang-specs.h: Do not process -o or run the assembler if\n \t-fsyntax-only.\n \n@@ -374,12 +423,12 @@\n \t* decl.c (member_function_or_else): Use cp_error ... %T.\n \t(grokdeclarator): Likewise.\n \t(start_method): Likewise.\n-\t* friend.c (make_friend_class): Use cp_pedwarn ... %T.\t\n+\t* friend.c (make_friend_class): Use cp_pedwarn ... %T.\n \n 2000-08-18  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* decl2.c (grokfield): Set CLASSTYPE_GOT_SEMICOLON on class\n-\tTYPE_DECLs.\t\n+\tTYPE_DECLs.\n \n 2000-08-18  Nathan Sidwell  <nathan@codesourcery.com>\n \n@@ -436,7 +485,7 @@\n \n \t* class.c (instantiate_type): Reinstate local variable\n \tdeleted in previous change.\n-\t\n+\n \t* cvt.c (cp_convert_to_pointer): Pass itf_complain, not\n \titf_no_attributes.\n \n@@ -466,18 +515,18 @@\n \t(cp_parse_init): Adjust.\n \t(structsp): Clear and restore current_aggr.\n \t(component_decl_list): Clear current_aggr.\n-\t\n+\n \t* error.c (dump_type, case TYPENAME_TYPE): Don't emit the\n \taggregate tag on the typename's context.\n-\t\n+\n \t* pt.c (tsubst_friend_class): Return error_mark_node, if\n \tparms becomes NULL.\n \t(instantiate_class_template): Ignore error_mark_node friend types.\n \n 2000-08-14  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* cvt.c (warn_ref_binding): New static function, broken out of ...\n-\t(convert_to_reference): ... here. Use it.\t\n+\t(convert_to_reference): ... here. Use it.\n \n 2000-08-11  Kriang Lerdsuwanakij <lerdsuwa@scf-fs.usc.edu>\n \n@@ -498,7 +547,7 @@\n \n \t* cp-tree.h (resolve_scope_to_name): Remove unused prototype.\n \t(lookup_nested_tag): Likewise.\n-\t\n+\n \t* decl2.c (grokfield): Fix comment to reflect many types of _DECLs\n \tcan be produced.\n \n@@ -528,12 +577,12 @@\n \t* rtti.c (build_dynamic_cast_1): Set \"C\" linkage for new abi\n \truntime.\n \t* cp/tinfo.cc (__dynamic_cast): Likewise.\n-\t* cp/inc/cxxabi.h (__dynamic_cast): Likewise.\t\n+\t* cp/inc/cxxabi.h (__dynamic_cast): Likewise.\n \n 2000-08-09  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* cvt.c (convert_to_pointer_force): Fix error message when\n-\tattempting to cast from ambiguous base.\t\n+\tattempting to cast from ambiguous base.\n \n 2000-08-08  Jason Merrill  <jason@redhat.com>\n \n@@ -572,9 +621,9 @@\n \n 2000-08-04  Zack Weinberg  <zack@wolery.cumb.org>\n \n-        * Make-lang.in (cc1plus): Depend on $(BACKEND), not stamp-objlist.\n-        * Makefile.in: Add C_OBJS, BACKEND; delete OBJS, OBJDEPS.\n-        (cc1plus): Link with $(BACKEND) and $(C_OBJS).\n+\t* Make-lang.in (cc1plus): Depend on $(BACKEND), not stamp-objlist.\n+\t* Makefile.in: Add C_OBJS, BACKEND; delete OBJS, OBJDEPS.\n+\t(cc1plus): Link with $(BACKEND) and $(C_OBJS).\n \n 2000-08-04  Mark Mitchell  <mark@codesourcery.com>\n \n@@ -586,7 +635,7 @@\n \t(clone_function_decl): Likewise.\n \t* decl2.c (check_classfn): Likewise.\n \t* semantics.c (finish_member_declaration): Likewise.\n-\t\n+\n 2000-08-04  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* decl.c (flag_isoc94): New variable.\n@@ -674,7 +723,7 @@\n \t(binfo_for_vtable): Simplify.\n \t* tree.c (unshare_base_binfos): Clear BINFO_PRIMARY_BASE_OF.\n \t(make_binfo): Make it have 11 entries.\n-\t\n+\n 2000-07-30  Alex Samuel  <samuel@codesourcery.com>\n \n \t* mangle.c (DECL_TEMPLATE_ID_P): Remove.\n@@ -805,7 +854,7 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \n \t* decl2.c (finish_decl_parsing): Handle TEMPLATE_ID_EXPR.\n \n-\t* decl.c (pushdecl): Handle seeing an OVERLOAD in \n+\t* decl.c (pushdecl): Handle seeing an OVERLOAD in\n \tIDENTIFIER_NAMESPACE_VALUE.\n \n 2000-07-16  Mark Mitchell  <mark@codesourcery.com>\n@@ -871,7 +920,7 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \t(initialize_inlined_parameters): Likewise.\n \t(declare_return_variable): Likewise.\n \t(expand_call_inline): Likewise.\n-\t\n+\n 2000-07-10  Jakub Jelinek  <jakub@redhat.com>\n \n \t* semantics.c (expand_body): Sync interface information\n@@ -881,10 +930,10 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \n \t* init.c (build_new_1): Bail early if the call to new fails.\n \n-\t* decl.c (compute_array_index_type): Check specifically for \n+\t* decl.c (compute_array_index_type): Check specifically for\n \tan INTEGER_CST, not just TREE_CONSTANT.\n \n-\t* decl.c (duplicate_decls): Don't call duplicate_decls on \n+\t* decl.c (duplicate_decls): Don't call duplicate_decls on\n \tthe DECL_TEMPLATE_RESULT.\n \t(decls_match): Return 0 if the DECL_TEMPLATE_RESULTs have different\n \tcodes.\n@@ -935,7 +984,7 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n 2000-07-04  scott snyder  <snyder@fnal.gov>\n \t    Jason Merrill  <jason@redhat.com>\n \n-\t* repo.c (repo_get_id): Handle the case where a class with virtual \n+\t* repo.c (repo_get_id): Handle the case where a class with virtual\n \tbases has a null TYPE_BINFO_VTABLE.\n \n 2000-07-04  Kevin Buhr  <buhr@stat.wisc.edu>\n@@ -988,7 +1037,7 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \n \t* semantics.c (lang_expand_stmt): Changed call to\n \tgenrtl_compound_stmt to ignore return value.\n-\t\n+\n 2000-07-02  Mark Mitchell  <mark@codesourcery.com>\n \n \t* mangle.c (canonicalize_for_substitution): Return the canonical\n@@ -1000,14 +1049,14 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \n 2000-07-01  Benjamin Chelf  <chelf@codesourcery.com>\n \n-        * Make-lang.in (cc1plus$(exeext)): Added c-semantics.o.\n-\t\n+\t* Make-lang.in (cc1plus$(exeext)): Added c-semantics.o.\n+\n \t* Makefile.in (OBJS): Added ../c-semantics.o.\n \t(OBJDEPS): Likewise.\n-\t\n+\n \t* cp-tree.h (TREE_LANG_FLAG_?): Moved common documentation to\n \t../c-common.h.\n-\t(struct stmt_tree): Added comment. \n+\t(struct stmt_tree): Added comment.\n \t(current_function_name_declared): Removed.\n \t(stmts_are_full_exprs_p): Likewise.\n \t(genrtl_do_pushlevel): Likewise.\n@@ -1032,10 +1081,10 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \t(push_cp_function_context): Likewise.\n \n \t* expect.c (expand_throw): Change reference to\n-\tstmts_are_full_exprs_p. \n+\tstmts_are_full_exprs_p.\n \n \t* init.c (build_aggr_init): Change reference to\n-\tstmts_are_full_exprs_p. \n+\tstmts_are_full_exprs_p.\n \t(build_vec_init): Likewise.\n \n \t* optimize.c (maybe_clone_body): Change reference to\n@@ -1069,7 +1118,7 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \t(genrtl_decl_cleanup): Likewise.\n \t(expand_cond): Likewise.\n \t(expand_stmt): Renamed to ...\n-\t(lang_expand_stmt): ... this. \n+\t(lang_expand_stmt): ... this.\n \t(lang_expand_expr_stmt): Initialize.\n \t(set_current_function_name_declared): Likewise.\n \t(stmts_are_full_exprs_p): Likewise.\n@@ -1089,7 +1138,7 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \tcurrent_function_name_declared().\n \t(setup_vtbl_ptr): Likewise.\n \t(genrtl_do_poplevel): Removed.\n-\t\n+\n 2000-06-30  Jason Merrill  <jason@redhat.com>\n \n \t* init.c (init_init_processing): Go back to aligning like\n@@ -1143,7 +1192,7 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \t* parse.y: Move inclusion of lex.h.\n \t* parse.c: Regenerated.\n \t* spew.c: Move inclusion of lex.h.\n-\t\n+\n \t* cp-tree.h (struct language_function): Remove temp_name_counter.\n \t(temp_name_counter): Remove.\n \t(get_temp_name): Change prototype.\n@@ -1164,7 +1213,7 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \t(do_static_initialization): Replace sentry with guard throughout.\n \t(do_static_destruction): Likewise.\n \t* init.c (create_temporary_var): Add comment.\n-\t\n+\n 2000-06-28  Alex Samuel  <samuel@codesourcery.com>\n \n \t* mangle.c (find_substitution): Use same_type_p.\n@@ -1215,7 +1264,7 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \t(build_modify_expr): Likewise.\n \t(get_delta_difference): Likewise.\n \t(build_ptrmemfunc): Likewise.\n-\t\n+\n 2000-06-29  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* cp-tree.h (SET_DECL_ARTIFICIAL): Remove.\n@@ -1250,7 +1299,7 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \n \t* pt.c (tsubst, case TEMPLATE_TEMPLATE_PARM): Handle cv-qualified\n \ttypes correctly.\n-\t\n+\n 2000-06-27  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl.c (grokfndecl): Set DECL_CONTEXT for static functions too.\n@@ -1283,7 +1332,7 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \n 2000-06-25 Theodore Papadopoulo <Theodore.Papadopoulo@sophia.inria.fr>\n \n-        * search.c (lookup_member): Fix typo in comment.\n+\t* search.c (lookup_member): Fix typo in comment.\n \n 2000-06-24  Jason Merrill  <jason@redhat.com>\n \n@@ -1394,7 +1443,7 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \t* decl.c (pushdecl): Also pull out one of the FUNCTION_DECLs from\n \tan old OVERLOAD when we're declaring a non-function.\n \t(pushdecl, destroy_local_var): Check for error_mark_node.\n-\t(warn_extern_redeclared_static): Also bail early if \n+\t(warn_extern_redeclared_static): Also bail early if\n \twe're a CONST_DECL.\n \t(push_overloaded_decl): Ignore an old error_mark_node.\n \n@@ -1411,7 +1460,7 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \n 2000-06-20  Jason Merrill  <jason@redhat.com>\n \n-\t* pt.c (tsubst_decl, case TYPE_DECL): Fix test for TYPE_DECLs \n+\t* pt.c (tsubst_decl, case TYPE_DECL): Fix test for TYPE_DECLs\n \tfor which we don't need to look for instantiations.\n \n 2000-06-21  Nathan Sidwell  <nathan@codesourcery.com>\n@@ -1447,7 +1496,7 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \t(build_x_compound_expr): Likewise.\n \t(check_return_expr): Likewise.\n \t* typeck2.c (add_exception_specifier): Likewise.\n-\t\n+\n \t* mangle.c (write_method_parms): Use direct comparison for end\n \tof parmlist.\n \n@@ -1514,7 +1563,7 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \t(genrtl_named_return_value): Likewise.\n \t(genrtl_begin_stmt_expr): Likewise.\n \t(genrtl_finish_stmt_expr): Likewise.\n-\t(finish_for_stmt): Removed first argument and generate rtl \n+\t(finish_for_stmt): Removed first argument and generate rtl\n \tspecific code.\n \t(finish_switch_stmt): Likewise.\n \t(do_poplevel): Removed generate rtl specific code.\n@@ -1567,7 +1616,7 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \t(finish_named_return_value): Likewise.\n \t(begin_stmt_expr): Likewise.\n \t(finish_stmt_expr): Likewise.\n-\t\n+\n \t* decl.c (initialize_local_var): Changed call to finish_expr_stmt\n \tto call genrtl_expr_stmt when appropriate.\n \n@@ -1581,16 +1630,16 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \tgenrtl_expr_stmt when appropriate.\n \t(build_vec_init): Likewise.\n \n-\t* parse.y (simple_stmt): Removed first argument from call to \n-\tfinish_for_stmt. Removed first argument from call to \n+\t* parse.y (simple_stmt): Removed first argument from call to\n+\tfinish_for_stmt. Removed first argument from call to\n \tfinish_switch_stmt.\n \n \t* parse.c: Regenerated.\n \n-\t* pt.c (tsubst_expr): Removed first argument from call to \n-\tfinish_for_stmt. Removed first argument from call to \n+\t* pt.c (tsubst_expr): Removed first argument from call to\n+\tfinish_for_stmt. Removed first argument from call to\n \tfinish_switch_stmt.\n-\t\n+\n 2000-06-16  Benjamin Chelf  <chelf@codesourcery.com>\n \n \t* cp-tree.h (enum cplus_tree_code): Changed __DUMMY to\n@@ -1599,9 +1648,9 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \t* lex.c (cplus_tree_code_type[]): Removed #include \"c-common.def\".\n \t(cplus_tree_code_length[]): Likewise.\n \t(cplus_tree_code_name[]): Likewise.\n-\t(init_parse): Added call to add_c_tree_codes. Changed \n+\t(init_parse): Added call to add_c_tree_codes. Changed\n \tLAST_AND_UNUSED_TREE_CODE to LAST_C_TREE_CODE.\n-\t\n+\n 2000-06-16  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (finish_mem_initializers): Declare.\n@@ -1613,7 +1662,7 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \tthe number of trees.\n \t(n_trees): Remove.\n \t(count_trees): Don't use it.\n-\t\n+\n 2000-06-15  Jason Merrill  <jason@redhat.com>\n \n \t* tree.c (count_trees): New debugging function.\n@@ -1665,12 +1714,12 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \t* semantics.c (setup_vtbl_ptr): Don't use current_member_init_list\n \tand current_base_init_list.\n \t(begin_function_definition): Don't call reinit_parse_for_function.\n-\t\n+\n \t* dump.c (dequeue_and_dump): Use TREE_VEC_LENGTH with vectors.\n \n \t* error.c (dump_expr): Handle ADDR_EXPRs with REFERENCE_TYPE\n \tcorrectly.\n-\t\n+\n \t* cp-tree.h (DECL_PENDING_INLINE_P): Relax checking.\n \n 2000-06-14  Benjamin Chelf  <chelf@codesourcery.com>\n@@ -1722,11 +1771,11 @@ Wed Jul 26 15:05:51 CEST 2000\tMarc Espie <espie@cvs.openbsd.org>\n \n \t* Make-lang.in (CXX_SRCS): Added $(srcdir)/c-common.def.\n \t(cc1plus$(exeext)): Added $(srcdir)/c-common.def.\n-\t\n+\n \t* lex.c (cplus_tree_code_type[]): Added '#include \"c-common.def\"'.\n \t(cplus_tree_code_length[]): Added '#include \"c-common.def\"'.\n \t(cplus_tree_code_name[]): Added '#include \"c-common.def\"'.\n-\t\n+\n 2000-06-14  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (BINFO_OVERRIDE_ALONG_VIRTUAL_PATH): New macro.\n@@ -1777,7 +1826,7 @@ Tue Jun 13 15:48:03 2000  Maciej W. Rozycki  <macro@ds2.pg.gda.pl>\n \tused to initialize the parameters more than once.\n \n 2000-06-11  Mark Mitchell <mark@codesourcery.com>\n-\t\n+\n \t* mangle.c (NESTED_TEMPLATE_MATCH): Fix typo in comment.\n \t(is_std_substitution): Don't check CLASSTYPE_USE_TEMPLATE here.\n \t(find_substitution): Only use the `Sa' substitution for\n@@ -1796,7 +1845,7 @@ Tue Jun 13 15:48:03 2000  Maciej W. Rozycki  <macro@ds2.pg.gda.pl>\n \t* class.c (build_vtable): Clarify comment.\n \t(build_ctor_vtbl_group): Pass the most derived type to\n \tbuild_vtable.\n-\t\n+\n 2000-06-11  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* decl2.c (compare_options): Don't needlessly cast away const-ness.\n@@ -1872,7 +1921,7 @@ Tue Jun 13 15:48:03 2000  Maciej W. Rozycki  <macro@ds2.pg.gda.pl>\n \n \t* decl2.c: Remove #inclusion of diagnostic.h\n \t(lang_decode_option): Move diagnostic formatting options to\n-\ttoplevel. \n+\ttoplevel.\n \n \t* lang-options.h: Remove documentation for diagnostic options.\n \n@@ -1978,7 +2027,7 @@ Mon Jun  5 06:48:55 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(grokvardecl): Call mangle_decl for new ABI.  Only set mangled\n \tname for fully-instantiated templates.\n \t* decl2.c (grokclassfn): Use set_mangled_name_for_decl for\n-\tdestructors with the new ABI.\t\n+\tdestructors with the new ABI.\n \t(finish_static_data_member_decl): Use mangle_decl under the new ABI.\n \t(grokfield): Use mangle_type for new ABI.\n \t(grokoptypename): Use mangle_conv_op_for_type for new ABI.\n@@ -2014,7 +2063,7 @@ Mon Jun  5 06:48:55 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(get_tinfo_decl): Call mangle_typeinfo_for_type for new\tABI.\n \t(tinfo_base_init):  Likewise.  Mangle typeinfo string name with\n \tmangle_typeinfo_string_for_type.\n-\t\n+\n 2000-06-03  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (TMPL_ARGS_LEVEL): Clarify comment.\n@@ -2049,7 +2098,7 @@ Mon Jun  5 06:48:55 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(regenerate_decl_from_template): Tweak formatting.  Use\n \tTMPL_ARGS_DEPTH for clarity.\n \t(set_mangled_name_for_template_decl): Use INNERMOST_ARGS.\n-\t\n+\n \t* dump.c (dequeue_and_dump): Dump information about thunks.\n \n 2000-06-01  Richard Henderson  <rth@cygnus.com>\n@@ -2094,7 +2143,7 @@ Wed May 31 14:09:00 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(unsupported_options): New variable\n \t(compare_options): New function.\n \t(lang_decode_option): Use them.\n-\t\n+\n \t* decl.c (build_cp_library_fn): Set DECL_CONTEXT.\n \n \t* method.c (mangle_expression): Adjust test for legal expression\n@@ -2115,7 +2164,7 @@ Wed May 31 14:09:00 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(build_new_method_call): Use DECL_NONSTATIC_MEMBER_FUNCTION_P.\n \n \t* ir.texi: Update thunk documentation.\n-\t\n+\n \t* call.c (joust): Fix handling of overloaded builtin operators.\n \n 2000-05-30  Zack Weinberg  <zack@wolery.cumb.org>\n@@ -2126,7 +2175,7 @@ Wed May 31 14:09:00 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \tin the user namespace.\n \t* lex.c (do_identifier): If the identifier's declaration has\n \tDECL_ANTICIPATED on, it has not yet been declared.  But do not\n-\treplace it with an ordinary implicit declaration.             \n+\treplace it with an ordinary implicit declaration.\n \n \t* tinfo2.cc: Include stdlib.h.\n \n@@ -2263,7 +2312,7 @@ Sat May 27 11:25:46 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(mark_lang_function): Call it.\n \t(use_label): New fn, split out from...\n \t(make_label_decl): ...here.  Don't call it.\n-\t(decl_jump_unsafe, check_previous_goto, check_previous_goto_1, \n+\t(decl_jump_unsafe, check_previous_goto, check_previous_goto_1,\n \tcheck_previous_gotos): New fns,\tsplit out from...\n \t(define_label): ...here.\n \t(check_switch_goto): New fn.\n@@ -2292,7 +2341,7 @@ Sat May 27 11:25:46 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(ptm_initializer): ... here.\n \t(sythesize_tinfo_var): Adjust. Deal with pointer to member\n \tfunction.\n-\t(create_tinfo_types): Adjust.\t\n+\t(create_tinfo_types): Adjust.\n \n 2000-05-25  Mark Mitchell  <mark@codesourcery.com>\n \n@@ -2343,7 +2392,7 @@ Sat May 27 11:25:46 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(expand_indirect_vtbls_init): Remove.\n \t* semantics.c (setup_vtbl_ptr): Fix typos in comment.\n \t* tree.c (make_binfo): Make them bigger.\n-\t\n+\n 2000-05-25  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* inc/cxxabi.h (__pbase_type_info): Define, based on\n@@ -2388,7 +2437,7 @@ Sat May 27 11:25:46 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \tvalues to indicate the kind of destruction to be done.\n \t(build_vbase_delete): Likewise.\n \t(build_vec_delete): Likewise.\n-\t\n+\n \t* init.c (sort_member_init): Fix typo in error message generation\n \tcode.\n \n@@ -2443,7 +2492,7 @@ Mon May 15 11:46:29 2000  Donald Lindsay  <dlindsay@cygnus.com>\n \t* ptree.c (print_lang_decl): Adjust.\n \t* typeck.c (build_component_ref): Don't check DECL_LANG_SPECIFIC\n \tbefore checking DECL_MUTABLE_P.\n-\t\n+\n \t* decl2.c (maybe_retrofit_in_chrg): Don't create in-charge\n \tparameters for template functions.\n \t* pt.c (tsubst_decl): Make sure we call maybe_retrofit_in_chrg for\n@@ -2474,7 +2523,7 @@ Mon May 15 11:46:29 2000  Donald Lindsay  <dlindsay@cygnus.com>\n \t(tsubst_copy): Adjust use of IDENTIFIER_TYPENAME_P.\n \t* semantics.c (finish_member_declaration): Don't mark members of\n \tclasses declared in an extern \"C\" region as extern \"C\".\n-\t\n+\n 2000-05-22  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* decl2.c (qualified_lookup_using_namespace): Look through\n@@ -2513,7 +2562,7 @@ Mon May 15 11:46:29 2000  Donald Lindsay  <dlindsay@cygnus.com>\n \t(get_ctor_vtbl_name): New function.\n \t* search.c (dfs_walk_real): Use BINFO_N_BASETYPES.\n \t(init_vbase_pointers): Don't mess with the TREE_CHAIN of a binfo.\n-\t\n+\n \t* cp-tree.h (struct lang_type): Remove search_slot.\n \t(CLASSTYPE_SEARCH_SLOT): Remove.\n \t(emit_base_init): Change prototype.\n@@ -2598,7 +2647,7 @@ Mon May 15 11:46:29 2000  Donald Lindsay  <dlindsay@cygnus.com>\n \t(find_vbase_instance): Use binfo_for_vbase.\n \t(binfo_for_vbase): New function.\n \t* typeck.c (get_delta_difference): Use binfo_for_vbase.\n-\t\n+\n 2000-05-17  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl2.c (finish_anon_union): Generalize error messages to handle\n@@ -2611,7 +2660,7 @@ Mon May 15 11:46:29 2000  Donald Lindsay  <dlindsay@cygnus.com>\n \t(expand_member_init): Record the result of name lookup for future\n \treference.\n \t* typeck.c (build_component_ref): Fix formatting.\n-\t\n+\n Wed May 17 17:27:44 2000  Andrew Cagney  <cagney@b1.cygnus.com>\n \n \t* decl.c (pop_label): Replace warn_unused with warn_unused_label.\n@@ -2674,7 +2723,7 @@ Wed May 17 17:27:44 2000  Andrew Cagney  <cagney@b1.cygnus.com>\n \t(lang_init_options): Set default prefixing rules.\n \n \t* lang-options.h: Add -fdiagnostics-show-location=.\n-\t\n+\n \t* decl2.c: #include diagnostic.h.\n \t(lang_decode_option): Handle -fdiagnostics-show-location=.\n \n@@ -2741,7 +2790,7 @@ Wed May 17 17:27:44 2000  Andrew Cagney  <cagney@b1.cygnus.com>\n \n \t* rtti.c (ptmd_initializer): Set non-public, if class is\n \tincomplete.\n-\t\n+\n \t* inc/cxxabi.h (__dynamic_cast): Explicitly say extern \"C++\".\n \t(__cxa_vec_new, __cxa_vec_ctor, __cxa_vec_dtor,\n \t__cxa_vec_delete): Likewise.\n@@ -2806,7 +2855,7 @@ Wed May 17 17:27:44 2000  Andrew Cagney  <cagney@b1.cygnus.com>\n \tset DECL_DESTRUCTOR_P or DECL_CONSTRUCTOR_P on a thunk.\n \t* search.c (covariant_return_p): Remove THUNK_DECL handling.\n \t* ir.texi: Update.\n-\t\n+\n 2000-05-01  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* tree.c (walk_tree): Set lineno.\n@@ -2872,7 +2921,7 @@ Wed May 17 17:27:44 2000  Andrew Cagney  <cagney@b1.cygnus.com>\n \tDECL_RESULT.\n \t(expand_call_inline): Update the pending target_exprs stack.\n \t(optimize_function): Initialize the stack.\n-\t\n+\n \t* decl2.c (finish_file): Fix typo in comment.\n \n \t* method.c (emit_thunk): Don't try to return a `void' value.\n@@ -2920,7 +2969,7 @@ Wed May 17 17:27:44 2000  Andrew Cagney  <cagney@b1.cygnus.com>\n \t(build_reinterpret_cast): Likewise.\n \t(build_c_cast): Likewise.\n \t(convert_for_assignment): Likewise.\n-\t\n+\n 2000-04-26  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* decl.c (finish_function): Don't play games with DECL_INLINE.\n@@ -2983,7 +3032,7 @@ Wed May 17 17:27:44 2000  Andrew Cagney  <cagney@b1.cygnus.com>\n 2000-04-22  Gabriel Dos Reis <gdr@codesourcery.com>\n \n \t* ir.texi:  Document complex number representation.\n-\t\n+\n 2000-04-20  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* rtti.c (init_rtti_processing): Set tinfo_var_id in new-abi.\n@@ -2998,7 +3047,7 @@ Wed May 17 17:27:44 2000  Andrew Cagney  <cagney@b1.cygnus.com>\n \tNew enumeration.\n \t* inc/typeinfo (type_info::before, type_info::operator==):\n \tCompare __name addresses.\n-\t\n+\n \t* tinfo2.cc: Remove new-abi builtins comment.\n \n 2000-04-20  Jason Merrill  <jason@casey.cygnus.com>\n@@ -3070,7 +3119,7 @@ Mon Apr 17 17:11:16 2000  Mark P Mitchell  <mark@codesourcery.com>\n \t* method.c (make_thunk): Tweak mangling for vcall offset thunks.\n \tUse int_size_in_bytes.\n \t(emit_thunk): Handle vcall offset thunks.\n-\t\n+\n Sat Apr 15 16:00:01 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* decl2.c (parse_time, varconst_time): Delete declarations.\n@@ -3080,7 +3129,7 @@ Sat Apr 15 16:00:01 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n 2000-04-13  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* class.c (build_base_field): Reformat comment.\n-\t\n+\n \t* inc/cxxabi.h (stddef.h): Comment inclusion.\n \t(__base_class_info::__offset): Comment shift.\n \n@@ -3114,13 +3163,13 @@ Sat Apr 15 16:00:01 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(build_delete): Use it.  Simplify.\n \t* optimize.c (maybe_clone_body): Handle destructors.\n \t* search.c (lookup_field_queue_p): Use IDENTIFIER_CTOR_OR_DTOR_P.\n-\t\n+\n \t* exception.cc (cleanup_fn): New typedef.\n \t(CALL_CLEANUP): New macro.\n \t(cp_eh_info): Use them.\n \t(__cp_push_exception): Likewise.\n \t(__cp_pop_exception): Likewise.\n-\t\n+\n 2000-04-11  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (cp_tree_index): Add CPTI_DTOR_IDENTIFIER.\n@@ -3173,7 +3222,7 @@ Sat Apr 15 16:00:01 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t* search.c (lookup_fnfields_1): Use CLASSTYPE_CONSTRUCTOR_SLOT,\n \tCLASSTYPE_DESTRUCTOR_SLOT, and CLASSTYPE_FIRST_CONVERSION_SLOT.\n \t* semantics.c (expand_body): Clone function bodies as necessary.\n-\t\n+\n \t* optimize.c (remap_decl): Avoid sharing structure for arrays\n \twhose size is only known at run-time.\n \t* tree.c (copy_tree_r): Don't copy PARM_DECLs.\n@@ -3200,7 +3249,7 @@ Sat Apr 15 16:00:01 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t* pt.c (instantiate_template): Remove goto.\n \t* tree.c (build_cplus_method_type): Remove mention of obstacks in\n \tcomment.\n-\t\n+\n \t* cp-tre.h (finish_function): Change prototype.\n \t* decl.c (end_cleanup_fn): Adjust caller.\n \t(finish_function): Take only one parameter.\n@@ -3218,7 +3267,7 @@ Sat Apr 15 16:00:01 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t* lex.c (copy_decl): Define it.\n \t* pt.c (tsubst_decl): Likewise.\n \t* tree.c (copy_template_template_parm): Likewise.\n-\t\n+\n \t* cp-tree.h (lang_type): Remove has_nonpublic_ctor and\n \thas_nonpublic_assign_ref.\n \t(TYPE_HAS_NONPUBLIC_CTOR): Don't declare.\n@@ -3248,7 +3297,7 @@ Sat Apr 15 16:00:01 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t* decl.c (check_tag_decl): Notice extra fundamental types.\n \tDiagnose empty decls in classes, too.\n \n-\t* decl.c (grokdeclarator): Don't override an anonymous name if no \n+\t* decl.c (grokdeclarator): Don't override an anonymous name if no\n \tdeclarator was given.\n \n \t* cvt.c (convert_to_void): Call resolve_offset_ref.\n@@ -3282,7 +3331,7 @@ Sat Apr 15 16:00:01 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \tspecific catch checking. Fix void conversion check.\n \t(__pointer_to_member_type_info::__do_catch): Remove.\n \t(__pointer_to_member_type_info::__pointer_catch): Implement.\n-\t\n+\n 2000-04-10  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* lex.c (init_parse): Remove traces of classof and headof.\n@@ -3301,7 +3350,7 @@ Sat Apr 15 16:00:01 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t* pt.c (tsubst_decl): Likewise.\n \t* ptree.c (print_lang_decl): Don't print it.\n \t* typeck.c (mark_addressable): Don't use it.\n-\t\n+\n 2000-04-09  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* vec.cc: Include <new> and <exception>.\n@@ -3363,8 +3412,8 @@ Sat Apr 15 16:00:01 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t__class_type_info::__dyncast_result): Move from inc/cxxabi.h.\n \tAdjust.\n \t(__class_type_info::find_public_src): Prepend __. Adjust.\n-\t(__class_type_info::do_find_public_src, \n-\t__si_class_type_info::do_find_public_src, \n+\t(__class_type_info::do_find_public_src,\n+\t__si_class_type_info::do_find_public_src,\n \t__vmi_class_type_info::do_find_public_src): Likewise.\n \t(__class_type_info::do_dyncast,\n \t__si_class_type_info::do_dyncast,\n@@ -3407,7 +3456,7 @@ Sat Apr 15 16:00:01 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t* typeck.c (build_static_cast): Use complete_ctor_identifier.\n \t(build_modify_expr): Likewise.\n \t* typeck2.c (build_functional_cast): Likewise.\n-\t\n+\n \tUnder the new ABI, constructors don't return `this'.\n \t* cp-tree.h (warn_reorder): Declare.\n \t(special_function_kind): New enum.\n@@ -3432,7 +3481,7 @@ Sat Apr 15 16:00:01 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \tof emit_base_init.\n \t* typeck.c (check_return_expr): Don't magically convert return\n \tstatements into `return this' in constructors under the new ABI.\n-\t\n+\n \t* cp-tree.h (cp_tree_index): Add CPTI_BASE_CTOR_IDENTIFIER,\n \tCPTI_BASE_DTOR_IDENTIFIER, and CPTI_DELETING_DTOR_IDENTIFIER.\n \t(base_ctor_identifier): New macro.\n@@ -3453,7 +3502,7 @@ Sat Apr 15 16:00:01 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(build_delete): Use CLASSTYPE_N_BASECLASSES.\n \t* search.c (init_search_processing): Don't initialize\n \tvptr_identifier.\n-\t\n+\n 2000-04-08  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* typeck.c (build_binary_op): Call `tree_expr_nonnegative_p' to elide\n@@ -3471,7 +3520,7 @@ Sat Apr 15 16:00:01 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(__vmi_class_type_info::do_find_public_src): Adjust.\n \t(__vmi_class_type_info::do_dyncast): Adjust.\n \t(__vmi_class_type_info::do_upcast): Adjust.\n-\t\n+\n 2000-04-07  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* tinfo.cc (convert_to_base): New function.\n@@ -3491,7 +3540,7 @@ Sat Apr 15 16:00:01 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(DECL_SAVED_INLINE): Rename to ...\n \t(DECL_DEFERRED_FN): ... this.\n \t(in_function_p): Remove declaration.\n-\t(mark_inline_for_output): Rename to ... \n+\t(mark_inline_for_output): Rename to ...\n \t(defer_fn): ... this.\n \t* decl.c (finish_function): Adjust call to mark_inline_for_output.\n \t(in_function_p): Remove definition.\n@@ -3541,7 +3590,7 @@ Sat Apr 15 16:00:01 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* Makefile.in (GGC_H): New variable.  Use it throughout in place\n \tof ggc.h.\n-\t\n+\n \t* call.c: Don't include obstack.h.  Include ggc.h.\n \t(obstack_chunk_alloc): Don't define.\n \t(obstack_chunk_free): Likewise.\n@@ -3655,7 +3704,7 @@ Wed Apr  5 15:12:18 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \t(__vmi_class_type_info::do_find_public_src): Use it.\n \t(__vmi_class_type_info::do_dyncast): Likewise.\n \t(__vmi_class_type_info::do_upcast): Likewise.\n-\t\n+\n 2000-04-03  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* lang-specs.h: Pass -fno-show-column to the preprocessor.\n@@ -3758,7 +3807,7 @@ Wed Apr  5 15:12:18 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \t* tree.c (debug_binfo): Likewise.\n \t* tinfo.cc (__dynamic_cast): Look for vtable_prefix at appropriate\n \tnegative offset.\n-\t\n+\n Sun Mar 26 20:15:26 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* class.c (check_field_decl): Fix typo.\n@@ -3775,7 +3824,7 @@ Sun Mar 26 20:15:26 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(resolve_overloaded_unification, more_specialized): Likewise.\n \t* semantics.c (finish_member_declaration): Likewise.\n \t* typeck.c (build_x_function_call): Likewise.\n-\t\n+\n 2000-03-26  Mark Mitchell  <mark@codesourcery.com>\n \n \t* class.c (layout_empty_base): Handle empty bases with non-byte\n@@ -3784,7 +3833,7 @@ Sun Mar 26 20:15:26 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(layout_virtual_bases): Likewise.\n \n \t* class.c (finish_struct_1): Fix typo in this change:\n-\t\n+\n \tSat Mar 25 09:12:10 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n 2000-03-25  Mark Mitchell  <mark@codesourcery.com>\n@@ -3793,7 +3842,7 @@ Sun Mar 26 20:15:26 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \tkeeping track of how many template classes have been seen.\n \n \t* dump.c (dequeue_and_dump): Dump DECL_TEMPLATE_RESULT.\n-\t\n+\n Sat Mar 25 09:12:10 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* class.c (build_vbase_pointer_fields): layout_field now place_field.\n@@ -3815,11 +3864,11 @@ Sat Mar 25 09:12:10 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t* rtti.c (expand_class_desc): Use bitsize_one_node.\n \t* typeck.c (build_component_addr): Use byte_position and don't\n \tspecial case for zero offset.\n-\t\n+\n 2000-03-24  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* decl.c (vtype_decl_p): Use TYPE_POLYMORPHIC_P.\n-\t\n+\n \t* rtti.c (get_tinfo_decl): Set comdat linkage on new-abi\n \ttinfo object.\n \t(emit_tinfo_decl): Only emit polymorphic tinfo's when emitting\n@@ -3854,7 +3903,7 @@ Sat Mar 25 09:12:10 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t* search.c (lookup_field_1): Likewise.\n \t* tree.c (walk_tree, get_type_decl, cp_tree_equal, member_p): Likewise.\n \t* xref.c (classname): Likewise.\n-\t\n+\n 2000-03-22  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (BINFO_FOR_VBASE): Adjust documentation.\n@@ -3883,7 +3932,7 @@ Sat Mar 25 09:12:10 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(dfs_find_vbases):  Adjust usage of BINFO_NEW_VTABLE_MARKED.\n \t(dfs_clear_vbase_slots): Likewise.\n \t(init_vbase_pointers): LIkewise.\n-\t\n+\n 2000-03-22  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* typeck.c (type_after_usual_arithmetic_conversions): Prefer a\n@@ -3893,7 +3942,7 @@ Sat Mar 25 09:12:10 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* class.c (layout_virtual_bases): Adjust names in conditionally\n \tcompiled code.\n-\t\n+\n \t* class.c (record_base_offsets): New function.\n \t(layout_conflict_p): Likewise.\n \t(layout_nonempty_base_or_field): Use it.\n@@ -3909,7 +3958,7 @@ Sat Mar 25 09:12:10 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t* cp-tree.h (CLASSTYPE_VBASECLASSES): Fix typo in comment.\n \t(fntype_p): Remove.\n \t* search.c (dfs_skip_nonprimary_vbases_unmarkedp): Fix typo in\n-\tcomment. \n+\tcomment.\n \t(dfs_skip_nonprimary_vbases_markedp): Likewise.\n \t* typeck.c (fntype_p): Remove.\n \n@@ -3995,7 +4044,7 @@ Sat Mar 25 09:12:10 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* init.c (build_offset_ref): Handle the case of a templated member\n \tfunction.\n-    \n+\n 2000-03-19  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* except.c (expand_exception_blocks): Clear catch_clauses_last.\n@@ -4016,7 +4065,7 @@ Sat Mar 25 09:12:10 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \twhen dereferencing them under the new ABI.\n \t* typeck.c (get_member_function_from_ptrfunc): Tweak calculation\n \tof pointers-to-members under the new ABI.\n-\t\n+\n \t* class.c (check_bitfield_decl): Remove restriction on really long\n \tbitfields.\n \t(layout_class_type): Implement new ABI handling of bitfields\n@@ -4057,7 +4106,7 @@ Fri Mar 17 08:09:14 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \thost_integerp, and tree_low_cst.\n \t(pointer_int_sum): Use integer_zerop.\n \t(build_component_addr): Use bit_position.\n-\t\n+\n 2000-03-17  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* typeck.c (require_complete_type): Don't assume size_zero_node.\n@@ -4092,7 +4141,7 @@ Fri Mar 17 08:09:14 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n 2000-03-15  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* decl.c (cp_finish_decl): Remove obsolete comment.\n-\t\n+\n \t* typeck.c (build_ptrmemfunc1): Kill uninitialized warning.\n \n 2000-03-14  Mark Mitchell  <mark@codesourcery.com>\n@@ -4176,7 +4225,7 @@ Fri Mar 17 08:09:14 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(tsubst_decl): Fix typo in code contained in comment.\n \t(instantiate_template): Handle member template specializations.\n \t(most_general_template): Likewise.\n-\t\n+\n 2000-03-11  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* lex.c (whitespace_cr): Compress consecutive calls to warning().\n@@ -4222,8 +4271,8 @@ Fri Mar 17 08:09:14 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(nothrow_libfn_p): New fn.\n \t* decl.c (grokfndecl): Use it.\n \t* cp-tree.h: Declare it.\n-\t\n-\t* decl.c (push_overloaded_decl_1, auto_function, \n+\n+\t* decl.c (push_overloaded_decl_1, auto_function,\n \tdefine_function): Lose.\n \t(build_library_fn_1): New static fn.\n \t(builtin_function): Use it.\n@@ -4237,7 +4286,7 @@ Fri Mar 17 08:09:14 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t* except.c (init_exception_processing, call_eh_info, do_pop_exception,\n \t(expand_end_eh_spec, alloc_eh_object, expand_throw): Use above fns.\n \t* rtti.c (build_runtime_decl): Lose.\n-\t(throw_bad_cast, throw_bad_typeid, get_tinfo_decl, \n+\t(throw_bad_cast, throw_bad_typeid, get_tinfo_decl,\n \tbuild_dynamic_cast_1, expand_si_desc, expand_class_desc,\n \texpand_ptr_desc, expand_attr_desc, expand_generic_desc): Use above fns.\n \n@@ -4287,7 +4336,7 @@ Fri Mar 17 08:09:14 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* typeck.c (convert_for_assignment): Don't look at array\n \tinitializer.\n-\t* call.c (convert_like_real): Likewise.\t\n+\t* call.c (convert_like_real): Likewise.\n \n 2000-03-07  Jason Merrill  <jason@casey.cygnus.com>\n \n@@ -4298,7 +4347,7 @@ Fri Mar 17 08:09:14 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(utf8_extend_token): New fn, #if 0'd out.\n \t(real_yylex): Treat extended chars like letters.\n \n-\t* search.c (note_debug_info_needed): Walk the bases even if we \n+\t* search.c (note_debug_info_needed): Walk the bases even if we\n \tweren't deferring the type itself.\n \n 2000-03-07  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n@@ -4339,15 +4388,15 @@ Mon Mar  6 08:46:47 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* pt.c (instantiate_decl): Clear TI_PENDING_TEMPLATE_FLAG a little\n \tlater.\n-\t\n+\n \t* dump.c (dequeue_and_dump): Dump SCOPE_NO_CLEANUPS_P.\n \n 2000-03-05  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* call.c (convert_like): Macrofy.\n \t(convert_like_with_context): New macro.\n \t(convert_like_real): Renamed from convert_like.  Add calling\n-\tcontext parameters, for diagnostics. Add recursive flag.  Call \n+\tcontext parameters, for diagnostics. Add recursive flag.  Call\n \tdubious_conversion_warnings for outer conversion.\n \t(build_user_type_conversion): Use convert_like_with_context.\n \t(build_over_call): Likewise. Don't warn about dubious\n@@ -4358,7 +4407,7 @@ Mon Mar  6 08:46:47 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(dubious_conversion_warnings): Prototype new function.\n \t* typeck.c (convert_arguments): Adjust convert_default_arg call.\n \t(dubious_conversion_warnings): New function, broken\n-\tout of convert_for_assignment. \n+\tout of convert_for_assignment.\n \t(convert_for_assignment): Adjust.\n \n 2000-03-03  Jason Merrill  <jason@casey.cygnus.com>\n@@ -4369,7 +4418,7 @@ Mon Mar  6 08:46:47 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t* decl.c (finish_function): Don't mess with flag_keep_inline_functions.\n \t* decl2.c (finish_vtable_vardecl): Don't check decl_function_context.\n \n-\t* search.c (note_debug_info_needed, dfs_debug_mark, \n+\t* search.c (note_debug_info_needed, dfs_debug_mark,\n \tdfs_debug_unmarkedp): Uncomment.  Adjust for new scheme.\n \t* decl2.c (finish_vtable_vardecl): Call note_debug_info_needed.\n \n@@ -4435,10 +4484,10 @@ Mon Mar  6 08:46:47 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(build_cplus_array_test_1): Likewise.\n \t(cp_build_qualified_type_real): Likewise.\n \t* typeck.c (complete_type): Likewise.\n-\t\n+\n \t* g++spec.c (lang_specific_driver): Add -fnew-abi at the start of\n \tthe command-line, not the end.\n-\t\n+\n 2000-03-01  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* pt.c (instantiate_decl): Clear TI_PENDING_TEMPLATE_FLAG.\n@@ -4552,19 +4601,19 @@ Sun Feb 27 16:40:33 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t* call.c (add_function_candidate): Add ctype parm; if non-zero,\n \toverride the type of 'this' accordingly.\n \t(add_template_candidate, add_template_candidate_real): Add ctype parm.\n-\t(convert_class_to_reference, build_user_type_conversion_1, \n+\t(convert_class_to_reference, build_user_type_conversion_1,\n \tbuild_new_function_call, build_object_call, build_new_op,\n \tbuild_new_method_call): Pass ctype parm.\n \n \t* search.c (lookup_member): Put rval_binfo, not basetype_path, in\n \tthe baselink.\n-\t* call.c (convert_class_to_reference, build_user_type_conversion_1, \n+\t* call.c (convert_class_to_reference, build_user_type_conversion_1,\n \tbuild_new_function_call, build_object_call, build_new_op,\n \tbuild_new_method_call, build_op_delete_call): Don't get basetype_path\n \tfrom a baselink.\n \t* typeck.c (build_component_ref): Likewise.\n \t* init.c (build_offset_ref): Likewise.\n-\t(resolve_offset_ref): Don't call enforce_access.  \n+\t(resolve_offset_ref): Don't call enforce_access.\n \tCall build_scoped_ref.\n \t* typeck2.c (build_scoped_ref): Simplify.  Do nothing if it\n \twould cause an error or if -pedantic.\n@@ -4590,7 +4639,7 @@ Sun Feb 27 16:40:33 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \tEXPR_WITH_FILE_LOCATION.\n \t* lex.c (check_newline): Tweak filename/lineno setting.\n \t* semantics.c (begin_while_stmt): Fix typo in comment.\n-\t\n+\n Sat Feb 26 19:50:23 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* lang-options.h (-fmessage-length=): Add missing option.\n@@ -4616,7 +4665,7 @@ Fri Feb 25 14:52:33 2000  Jim Wilson  <wilson@cygnus.com>\n \t* parse.c: Regenerated.\n \t* Makefile.in (lex.o): Depend on input.h.\n \t(optimize.o): Likewise.\n-\t\n+\n 2000-02-24  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* decl.c (grokdeclarator): Diagnose qualifiers on non-member\n@@ -4639,7 +4688,7 @@ Fri Feb 25 14:52:33 2000  Jim Wilson  <wilson@cygnus.com>\n \t(parse_float, real_yylex): Likewise.\n \t* parse.y (paren_expr_or_null, paren_cond_or_null): Likewise.\n \t(unary_expr, new_initializer, cast_expr, primary, primary_no_id,\n-\tnew_type_id, maybe_label_decls, simple_stmt, \n+\tnew_type_id, maybe_label_decls, simple_stmt,\n \tfor.init.statement): Likewise.\n \t* pt.c (do_decl_instantiation, do_type_instantiation): Likewise.\n \t* semantics.c (finish_named_return_value): Likewise.\n@@ -4675,7 +4724,7 @@ Fri Feb 25 14:52:33 2000  Jim Wilson  <wilson@cygnus.com>\n \t(expand_ptrmemfunc_cst): Likewise.\n \t(delta2_from_ptrmemfunc): Assert that we're not using the new ABI.\n \t(pfn_from_ptrmemfunc): Adjust for the new ABI.\n-\t\n+\n 2000-02-21  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* call.c (build_object_call): Compress consecutive calls to\n@@ -4684,7 +4733,7 @@ Fri Feb 25 14:52:33 2000  Jim Wilson  <wilson@cygnus.com>\n \t(build_op_delete_call): Adjust message formatting.\n \n \t* class.c (check_bases): Compress consecutive calls to\n-\tcp_pedwarn. \n+\tcp_pedwarn.\n \t(finish_struct_anon): Say 'ISO C++'.\n \n \t* decl.c (start_decl): Same here.\n@@ -4694,7 +4743,7 @@ Fri Feb 25 14:52:33 2000  Jim Wilson  <wilson@cygnus.com>\n \t(check_static_variable_definition): Likewise. Say 'ISO C++'\n \t(compute_array_index_type): Say 'ISO C++'\n \t(create_array_type_for_decl): Compress consecutive calls to\n-\tcp_error. \n+\tcp_error.\n \t(grokdeclarator): Say 'ISO C++'\n \t(grok_op_properties): Likewise.\n \n@@ -4705,7 +4754,7 @@ Fri Feb 25 14:52:33 2000  Jim Wilson  <wilson@cygnus.com>\n \t* expr.c (do_case): Say 'ISO C++'\n \n \t* friend.c (do_friend): Compress consecutive calls to warning.\n-\t\n+\n 2000-02-20  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (merge_primary_and_secondary_vtables_p): New macro.\n@@ -4729,12 +4778,12 @@ Fri Feb 25 14:52:33 2000  Jim Wilson  <wilson@cygnus.com>\n \t(build_secondary_vtable): ... here.\n \n \t* pt.c (tsubst_decl): Fix formatting.\n-\t\n+\n Sat Feb 19 18:43:13 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* class.c (build_primary_vtable, layout_vtable_decl): Likewise.\n \t(avoid_overlap, build_base_field): Likewise.\n-\t(build_base_field, build_base_fields, is_empty_class): \n+\t(build_base_field, build_base_fields, is_empty_class):\n \tTest DECL_SIZE with integer_zero.\n \t(layout_class_type): Set CLASSTYPE_SIZE_UNIT.\n \t* cp-tree.h (struct lang_type): New field size_unit.\n@@ -4754,12 +4803,12 @@ Sat Feb 19 18:43:13 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \tfunctions.\n \t(build_vtbl_initializer): Adjust accordingly.\n \t(get_vtable_decl): Fix formatting.\n-\t\n+\n 2000-02-18  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* semantics.c (deferred_type_access_control): Walk the entire\n \ttype_lookups list.\n-\t(save_type_access_control): Rename from \n+\t(save_type_access_control): Rename from\n \tinitial_deferred_type_access_control.  Just remember the value.\n \t(decl_type_access_control): New fn.\n \t(begin_function_definition): Use deferred_type_access_control, after\n@@ -4773,7 +4822,7 @@ Sat Feb 19 18:43:13 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(notype_component_declarator): Likewise.\n \t* cp-tree.h: Adjust.\n \n-\t* decl.c (redeclaration_error_message): Allow redeclaration of \n+\t* decl.c (redeclaration_error_message): Allow redeclaration of\n \tnamespace-scope decls.\n \n 2000-02-18  Martin von Loewis  <loewis@informatik.hu-berlin.de>\n@@ -4867,7 +4916,7 @@ Sat Feb 19 18:43:13 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(is_member_template): Use decl_function_context, not\n \thack_decl_function_context.  Use DECL_CONTEXT, not\n \tDECL_CLASS_CONTEXT.\n-\t(build_template_decl): Set DECL_VIRTUAL_CONTEXT, not \n+\t(build_template_decl): Set DECL_VIRTUAL_CONTEXT, not\n \tDECL_CLASS_CONTEXT.\n \t(check_default_tmpl_args): Use CP_DECL_CONTEXT, not\n \tDECL_REAL_CONTEXT.\n@@ -4895,7 +4944,7 @@ Sat Feb 19 18:43:13 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t* typeck.c (build_x_function_call): Use DECL_CONTEXT, not\n \tDECL_CLASS_CONTEXT.\n \t* typeck2.c (error_not_base_type): Likewise.\n-\t\n+\n 2000-02-15  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* decl.c (xref_tag): Don't SET_IDENTIFIER_NAMESPACE_VALUE.\n@@ -4964,7 +5013,7 @@ Sat Feb 19 18:43:13 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(struct saved_scope): Add lookups field.\n \t(type_lookups): New macro.\n \t* parse.y (declmods): Now <ftype>.\n-\t(parse_decl): Add lookups parm.  Call \n+\t(parse_decl): Add lookups parm.  Call\n \tinitial_deferred_type_access_control.\n \t(lang_extdef): Clear type_lookups.\n \t(typed_declspecs, declmods, typespec): Set lookups field.\n@@ -5046,9 +5095,9 @@ Mon Jan 31 15:35:29 2000  Jim Wilson  <wilson@cygnus.com>\n \tunreal chilren of virtual bases.\n \t(finish_struct_1): Don't use merge_overrides.  Don't use\n \tdfs_fixup_vtable_deltas.\n-\t* tree.c (reverse_path): Return a TREE_LIST, not a chain of \n+\t* tree.c (reverse_path): Return a TREE_LIST, not a chain of\n \tBINFOs.\n-\t\n+\n 2000-01-31  Herman A.J. ten Brugge <Haj.Ten.Brugge@net.HCC.nl>\n \t    Jason Merrill  <jason@yorick.cygnus.com>\n \n@@ -5073,13 +5122,13 @@ Mon Jan 31 15:35:29 2000  Jim Wilson  <wilson@cygnus.com>\n \t(type_info::is_pointer_p, type_info::is_function_p): Declare\n \tnew virtual functions.\n \t(type_info::do_catch, type_info::do_upcast): Likewise.\n-\t\n+\n \t* tinfo.h (__base_class_info): Define new class.\n \t(__class_type_info): Likewise.\n \t(__si_class_type_info): Likewise.\n \t(__vmi_class_type_info): Likewise.\n \t(__dynamic_cast): Prototype.\n-\t\n+\n \t* tinfo.cc: Conditionalize old and new rtti mechanisms.\n \t(type_info::is_pointer_p): Define new function.\n \t(type_info::is_function_p): Likewise.\n@@ -5107,7 +5156,7 @@ Mon Jan 31 15:35:29 2000  Jim Wilson  <wilson@cygnus.com>\n \t(__si_class_type_info::do_upcast): Likewise.\n \t(__vmi_class_type_info::do_upcast): Likewise.\n \t(__dynamic_cast): Likewise.\n-\t\n+\n \t* tinfo2.cc (__fundamental_type_info): Define new class.\n \t(__pointer_type_info): Likewise.\n \t(__reference_type_info): Likewise.\n@@ -5124,7 +5173,7 @@ Mon Jan 31 15:35:29 2000  Jim Wilson  <wilson@cygnus.com>\n \t(__ptr_to_member_type_info::~__ptr_to_member_type_info): Likewise.\n \t(__pointer_type_info::do_catch): Define new function.\n \t(__ptr_to_member_type_info::do_catch): Define new function.\n-\t\n+\n \t(__throw_type_match_rtti_2): Use new ABI interface, if enabled.\n \t(__is_pointer): Likewise.\n \n@@ -5141,7 +5190,7 @@ Mon Jan 31 15:35:29 2000  Jim Wilson  <wilson@cygnus.com>\n \t(override_one_vtable): Use build_secondary_vtable.\n \t(finish_struct_1): Use build_primary_vtable and\n \tbuild_secondary_vtable.\n-\t\n+\n 2000-01-28  Ulrich Drepper  <drepper@redhat.com>\n \n \t* cp/decl.c: Adjust variable names, comments, help strings.\n@@ -5177,9 +5226,9 @@ Mon Jan 31 15:35:29 2000  Jim Wilson  <wilson@cygnus.com>\n \tand BF_FN.\n \t(modify_one_vtable): Simplify.\n \t(dfs_fixup_vtable_deltas): Likewise.\n-\t(override_one_vtable): Use BF_DELTA, BF_VCALL_INDEX, BF_FN. \n+\t(override_one_vtable): Use BF_DELTA, BF_VCALL_INDEX, BF_FN.\n \t* method.c (make_thunk): Handle vcall indices.\n-\t\n+\n 2000-01-28  Nathan Sidwell  <sidwell@codesourcery.com>\n \n \tCompiler side new abi rtti (not enabled).\n@@ -5283,7 +5332,7 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t(dfs_finish_vtabls): Use layout_vtable_decl.\n \t(modify_one_vtables): Always duplicate vtables under the new ABI.\n \t(finish_struct_1): Use layout_vtable_decl.\n-\t\n+\n 2000-01-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* decl.c (member_function_or_else): Change third arg from a format\n@@ -5294,7 +5343,7 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t* typeck.c (composite_pointer_type, c_sizeof, expr_sizeof,\n \tbuild_binary_op_nodefault, build_unary_op, build_reinterpret_cast,\n \tbuild_const_cast, get_delta_difference, check_return_expr): Avoid\n-\tANSI string concatenation usage.  \n+\tANSI string concatenation usage.\n \n 2000-01-24  Mark Mitchell  <mark@codesourcery.com>\n \n@@ -5414,7 +5463,7 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* typeck.c (convert_arguments): Restore two-message error\n \treporting.\n-\t\n+\n 2000-01-20  Nathan Sidwell  <sidwell@codesourcery.com>\n \n \tRemap dynamic cast hint values to be consistent across ABIs.\n@@ -5425,32 +5474,32 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t* tinfo.cc (__si_type_info::do_dyncast): Remap BOFF meaning.\n \t(__class_type_info::do_dyncast): Likewise.\n \t(__class_type_info::do_find_public_subobj): Likewise.\n-\t* tinfo2.cc (__dynamic_cast): Remap BOFF parameter.\t\n+\t* tinfo2.cc (__dynamic_cast): Remap BOFF parameter.\n \n 2000-01-19  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* typeck.c (build_unary_op): Use cp_pedwarn, not pedwarn.\n \n \t* typeck2.c (incomplete_type_error): Restore previous\n \tcp_error and cp_error_at call sequence.\n-\t\n+\n 2000-01-20  Brad Lucier  <lucier@math.purdue.edu>\n \n \t* class.c (dump_class_hierarchy): Make format agree with argument;\n \tcast pointer to unsigned long and print with %lx.\n-\t\n+\n 2000-01-19  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* decl2.c (lang_decode_option): Set default line-wrap length to 72.\n-\t\n+\n \t* typeck.c (composite_pointer_type, common_type,\n \tcomp_target_parms, c_sizeof, expr_sizeof, build_array_ref,\n \tbuild_function_call_real, convert_arguments,\n \tbuild_binary_op_nodefault, pointer_int_sum, pointer_diff,\n \tbuild_unary_op, mark_addressable, build_compound_expr,\n \tbuild_static_cast, build_reinterpret_cast, build_const_cast,\n \tbuild_c_cast, build_modify_expr, get_delta_difference,\n-\tbuild_ptrmemfunc, check_return_expr): Replace 'ANSI C++' with \n+\tbuild_ptrmemfunc, check_return_expr): Replace 'ANSI C++' with\n \t'ISO C++'.  Fusion consecutive calls to diagnotic message routines\n \tinto a single one.\n \t* typeck2.c (readonly_error, abstract_virtuals_error,\n@@ -5509,7 +5558,7 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t(finish_struct_1): Adjust call to modify_all_vtables.  Add\n \toverridden functions from non-primary bases to the vtable.\n \t* tree.c (build_shared_int_cst): New function.\n-\t\n+\n \t* cp-tree.h (scratchalloc): Remove.\n \t(build_scratch_list): Likewise.\n \t* call.c (convert_class_to_reference): Replace build_scratch_list\n@@ -5543,7 +5592,7 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t* typeck.c (build_x_compound_expr): Likewise.\n \t(build_static_cast): Likewise.\n \t(build_modify_expr): Likewise.\n-\t\n+\n \t* cp-tree.h (DECL_VINDEX): Add documentation.\n \t* class.c (build_vtable_entry): Likewise.\n \t(start_vtable): Add comment.\n@@ -5556,7 +5605,7 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t(create_vtbl_ptr): Likewise.\n \t(layout_class_type): Likewise.\n \t(finish_struct_1): Likewise.  Add comments.\n-\t\n+\n 2000-01-16  Mark Mitchell  <mark@codesourcery.com>\n \n \t* class.c (finish_struct_1): Replace redundant code with\n@@ -5577,7 +5626,7 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t(build_vbase_offset_vtbl_entries): Simplify.\n \t(build_vbase_offset_vtbl_entries): Adjust.\n \t(build_vbase_pointer): Add ability to look up vbase offsets in\n-\tvtable. \n+\tvtable.\n \t(start_vtable): New function.\n \t(add_virtual_function): Use it.\n \t(determine_primary_base): Use TYPE_CONTAINS_VPTR_P.\n@@ -5606,14 +5655,14 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t* search.c (dfs_walk_real): Make it global.\n \t(dfs_debug_mark): Use TYPE_CONTAINS_VPTR_P.\n \t* tree.c (make_binfo): Don't clear BINFO_VPTR_FIELD.\n-\t\n+\n \t* tinfo.h (USItype): Make it signed under the new ABI.\n \t* tinfo.cc (convert_to_base): New function.  Encapsulate base\n \tconversion logic here.\n \t(__class_type_info::do_upcast): Use it.\n \t(__class_type_info::do_dyncast): Likewise.\n \t(__class_type_info::do_find_public_subobj): Likewise.\n-\t\n+\n \t* init.c (construct_virtual_bases): Don't look up the addresses of\n \tvirtual bases at run-time.\n \n@@ -5653,7 +5702,7 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t(dfs_vtable_path_unmarked_real_bases_queue_p): New function.\n \t(dfs_vtable_path_marked_real_bases_queue_p): New function.\n \t(dfs_vtable_path_unmark): Likewise.\n-\t\n+\n 2000-01-14  Mark Mitchell  <mark@codesourcery.com>\n \n \t* optimize.c (copy_body_r): Clear the operand three of a\n@@ -5669,7 +5718,7 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t* pt.c (tsubst_friend_function): Improve comment.\n \t(instantiate_decl): Avoid crashing when a \"nested\" function is\n \tinstantiated from the top level.\n-\t\n+\n \t* dump.c (dqeueue_and_dump): Dump\n \tDECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION.\n \n@@ -5705,7 +5754,7 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t* parse.c: Regenerated.\n \t* pt.c (finish_member_template_decl): Likewise.\n \t* typeck.c (decay_conversion): Likewise.\n-\t\n+\n \t* cp-tree.h (dfs_skip_vbases): New function.\n \t(find_vbase_instance): Likewise.\n \t* class.c (determine_primary_base): Allow a nearly empty base to\n@@ -5732,16 +5781,16 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t(fixup_all_virtual_upcast_offsets): Likewise.\n \t(dfs_find_vbase_instances): New function.\n \t(find_vbase_instance): Likewise.\n-\t\n+\n 2000-01-11  Mumit Khan  <khan@xraylith.wisc.edu>\n \n \t* lex.c (DIR_SEPARATOR): Delete macro.\n \n 2000-01-12  Gabriel Dos Reis  <gdr@codesourcery.com>\n- \n+\n        * decl2.c (lang_decode_option): Handle automatic line wrapping\n        option.\n-\t\n+\n 2000-01-11  Mark Mitchell  <mark@codesourcery.com>\n \n \t* friend.c (do_friend): Don't resolve scopes when processing\n@@ -5766,15 +5815,15 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t(layout_basetypes): Don't call propagate_binfo_offsets.\n \t* search.c (dfs_get_vbase_types): Clone completely fresh binfos\n \tfor the vbases.\n-\t\n+\n \t* class.c (build_base_field): New function, split out from ...\n \t(build_base_fields): ... here.  Use it.  Allocate primary bases\n \tfirst, under the new ABI.\n \t(get_vtable_entry): Remove.\n \t(remove_base_field): New function, split out from ...\n \t(remove_base_fields): ... here.  Adjust since primary bases come\n \tfirst under the new ABI.\n-\t\n+\n \t* cp-tree.h (expand_direct_vtbls_init): Remove declaration.\n \t(initialize_vtbl_ptrs): New function.\n \t(expand_indirect_vtbls_init): Change prototype.\n@@ -5786,11 +5835,11 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t* search.c (convert_pointer_to_vbase): Make it global.\n \t(expand_indirect_vtbls_init): Remove vtable initialization code.\n \t* semantics.c (setup_vtbl_ptr): Use initialize_vtbl_ptrs.\n-\t\n+\n \t* class.c (dfs_finish_vtbls): New function.\n \t(finish_vtbls): Use it.\n \t(dump_class_hierarchy): New function.\n-\t\n+\n \t* cp-tree.h (BINFO_PRIMARY_MARKED_P): Change definition.\n \t(BINFO_VBASE_PRIMARY_P): New macro.\n \t(BINFO_VIRTUALS): Add to documentation.\n@@ -5806,7 +5855,7 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t(dfs_marked_real_bases_queue_p): Likewise.\n \t(dfs_get_pure_virtuals): Simplify.\n \t(get_pure_virtuals): Likewise.\n-\t\n+\n 2000-01-10  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* lex.c: Include tm_p.h.\n@@ -5820,7 +5869,7 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t* decl2.c (comdat_linkage): Don't set DECL_DEFER_OUTPUT.\n \t* pt.c (instantiate_decl): Defer comdat templates that might not be\n \tneeded.\n-\t\n+\n \t* cp-tree.h (DECL_NEEDED_P): Also true if !DECL_COMDAT.\n \t* decl2.c (finish_vtable_vardecl): Don't check !DECL_COMDAT.\n \t(finish_file): Likewise.\n@@ -5859,7 +5908,7 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \tor unshare_base_binfos for virtual bases here.\n \t* search.c (dfs_get_vbase_types): Do it here.\n \t(get_vbase_types): Adjust.\n-\t\n+\n 2000-01-02  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (CLASSTYPE_VFIELDS): Move definition.\n@@ -5873,7 +5922,7 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \tare no base classes.  Call mark_primary_bases here.\n \t(modify_all_direct_vtables): Remove.\n \t(modify_all_indirect_vtables): Remove.\n-\t(dfs_modify_vtables_queue_p): New function.\t\n+\t(dfs_modify_vtables_queue_p): New function.\n \t(dfs_modify_vtables): New function.\n \t(modify_all_vtables): Use them.\n \t(build_base_fields): Build FIELD_DECLs for primary virtual base\n@@ -5920,7 +5969,7 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t* tree.c (CEIL): Remove.\n \t(propagate_binfo_offsets): Remove.\n \t(layout_basetypes): Remove.\n-\t\n+\n 2000-01-01  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (CLASSTYPE_N_BASECLASSES): Use BINFO_N_BASETYPES.\n@@ -5935,7 +5984,7 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t(dfs_unmark_primary_bases): Likewise.\n \t(unmark_primary_bases): Likewise.\n \t(dfs_get_pure_virtuals): Likewise.\n-\t\n+\n 2000-01-01  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (skip_rtti_stuff): Adjust prototype.\n@@ -5947,7 +5996,7 @@ Wed Jan 26 22:19:14 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \t(get_pure_virtuals): Likewise.\n \t(expand_upcast_fixups): Likewise.\n \t* tree.c (debug_binfo): Likewise.\n-\t\n+\n \t* class.c (build_vtable): Don't return a value.  Don't rebuild\n \tvtables for bases that have already been handled.\n \t(prepare_fresh_vtable): Don't rebuild vtables for bases that have"}, {"sha": "5b08fd381722bc8623995002dce27af87ac809cd", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -115,16 +115,16 @@ CXX_SRCS = $(srcdir)/cp/call.c $(srcdir)/cp/class.c $(srcdir)/cp/cp-tree.def \\\n  $(srcdir)/cp/decl.h $(srcdir)/cp/decl2.c $(srcdir)/cp/dump.c \\\n  $(srcdir)/cp/errfn.c $(srcdir)/cp/error.c $(srcdir)/cp/except.c \\\n  $(srcdir)/cp/expr.c $(srcdir)/cp/friend.c $(srcdir)/cp/init.c \\\n- $(srcdir)/cp/input.c $(srcdir)/cp/lex.c $(srcdir)/cp/lex.h \\\n+ $(srcdir)/cp/lex.c $(srcdir)/cp/lex.h \\\n  $(srcdir)/cp/mangle.c $(srcdir)/cp/method.c $(srcdir)/cp/optimize.c \\\n  $(srcdir)/cp/parse.y $(srcdir)/cp/pt.c $(srcdir)/cp/ptree.c \\\n  $(srcdir)/cp/repo.c $(srcdir)/cp/rtti.c $(srcdir)/cp/search.c \\\n  $(srcdir)/cp/semantics.c $(srcdir)/cp/spew.c $(srcdir)/cp/tree.c \\\n  $(srcdir)/cp/typeck.c $(srcdir)/cp/typeck2.c $(srcdir)/cp/xref.c\n \n cc1plus$(exeext): $(P) $(CXX_SRCS) $(LIBDEPS) $(BACKEND) c-common.o \\\n-\tc-pragma.o c-semantics.o $(srcdir)/cp/cp-tree.h $(srcdir)/cp/cp-tree.def \\\n-\t$(srcdir)/c-common.def $(srcdir)/cp/gxx.gperf $(srcdir)/cp/cfns.gperf hash.o \\\n+\tc-pragma.o c-semantics.o c-lex.o $(srcdir)/cp/cp-tree.h $(srcdir)/cp/cp-tree.def \\\n+\t$(srcdir)/c-common.def $(srcdir)/cp/cfns.gperf hash.o \\\n \t$(srcdir)/cp/operators.def\n \tcd cp; $(MAKE) $(LANG_FLAGS_TO_PASS) $(CXX_FLAGS_TO_PASS) ../cc1plus$(exeext)\n #\f"}, {"sha": "e73f6ad11251b762b5bb53a455540281cfa68224", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -172,7 +172,7 @@ INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config -I$(srcdir)\n # Lists of files for various purposes.\n \n # Shared with C front end:\n-C_OBJS = ../c-common.o ../c-pragma.o ../c-semantics.o\n+C_OBJS = ../c-common.o ../c-pragma.o ../c-semantics.o ../c-lex.o\n \n # Language-specific object files for g++\n \n@@ -237,24 +237,14 @@ $(PARSE_H) $(PARSE_C) : $(srcdir)/parse.y\n #\tcp $(PARSE_C) y.tab.c\n #\ttouch stamp-parse\n \n-# We used to try to protect people from having to rerun gperf.  But,\n-# the C front-end already requires this if c-parse.gperf is changed,\n-# so we should be consistent.\n-$(srcdir)/hash.h: $(srcdir)/gxx.gperf\n-\tgperf -L C -F ', 0, 0' -p -j1 -g -o -t -N is_reserved_word \\\n-\t\t'-k1,4,7,$$' $(srcdir)/gxx.gperf >$(srcdir)/hash.h || ( \\\n-\techo \"Please update your 'gperf' from the GCC infrastructure\" >&2 ; \\\n-\techo \"\tftp://sourceware.cygnus.com/pub/egcs/infrastructure/gperf*\" >&2 ; \\\n-\texit 1 )\n-\n $(srcdir)/cfns.h: $(srcdir)/cfns.gperf\n \tgperf -o -C -E -k '1-6,$$' -j1 -D -N 'libc_name_p' \\\n \t\t$(srcdir)/cfns.gperf > $(srcdir)/cfns.h\n \n spew.o : spew.c $(CXX_TREE_H) $(PARSE_H) $(srcdir)/../flags.h \\\n   lex.h $(srcdir)/../toplev.h\n lex.o : lex.c $(CXX_TREE_H) \\\n-  $(PARSE_H) input.c $(srcdir)/../flags.h hash.h lex.h \\\n+  $(PARSE_H) $(srcdir)/../flags.h lex.h \\\n   $(srcdir)/../c-pragma.h $(srcdir)/../toplev.h \\\n   $(srcdir)/../output.h $(srcdir)/../mbchar.h $(GGC_H) \\\n   $(srcdir)/../input.h $(srcdir)/../diagnostic.h operators.def"}, {"sha": "0306df79df964b05a6cee4a829857b61d60deec2", "filename": "gcc/cp/class.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -153,7 +153,7 @@ static void check_bases PARAMS ((tree, int *, int *, int *));\n static void check_bases_and_members PARAMS ((tree, int *));\n static tree create_vtable_ptr PARAMS ((tree, int *, int *, tree *, tree *));\n static void layout_class_type PARAMS ((tree, int *, int *, tree *, tree *));\n-static void fixup_pending_inline PARAMS ((struct pending_inline *));\n+static void fixup_pending_inline PARAMS ((tree));\n static void fixup_inline_methods PARAMS ((tree));\n static void set_primary_base PARAMS ((tree, tree, int *));\n static void propagate_binfo_offsets PARAMS ((tree, tree));\n@@ -4449,15 +4449,12 @@ create_vtable_ptr (t, empty_p, vfuns_p,\n    complete.  */\n \n static void\n-fixup_pending_inline (info)\n-     struct pending_inline *info;\n+fixup_pending_inline (fn)\n+     tree fn;\n {\n-  if (info)\n+  if (DECL_PENDING_INLINE_INFO (fn))\n     {\n-      tree args;\n-      tree fn = info->fndecl;\n-\n-      args = DECL_ARGUMENTS (fn);\n+      tree args = DECL_ARGUMENTS (fn);\n       while (args)\n \t{\n \t  DECL_CONTEXT (args) = fn;\n@@ -4487,13 +4484,13 @@ fixup_inline_methods (type)\n \n   /* Do inline member functions.  */\n   for (; method; method = TREE_CHAIN (method))\n-    fixup_pending_inline (DECL_PENDING_INLINE_INFO (method));\n+    fixup_pending_inline (method);\n \n   /* Do friends.  */\n   for (method = CLASSTYPE_INLINE_FRIENDS (type); \n        method; \n        method = TREE_CHAIN (method))\n-    fixup_pending_inline (DECL_PENDING_INLINE_INFO (TREE_VALUE (method)));\n+    fixup_pending_inline (TREE_VALUE (method));\n   CLASSTYPE_INLINE_FRIENDS (type) = NULL_TREE;\n }\n \n@@ -5426,6 +5423,10 @@ init_class_processing ()\n   access_public_virtual_node = build_int_2 (4 | ak_public, 0);\n   access_protected_virtual_node = build_int_2 (4 | ak_protected, 0);\n   access_private_virtual_node = build_int_2 (4 | ak_private, 0);\n+\n+  ridpointers[(int) RID_PUBLIC] = access_public_node;\n+  ridpointers[(int) RID_PRIVATE] = access_private_node;\n+  ridpointers[(int) RID_PROTECTED] = access_protected_node;\n }\n \n /* Set current scope to NAME. CODE tells us if this is a"}, {"sha": "b32367ba3aad1af6b69a2f2ce56e2657c6b768db", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 30, "deletions": 48, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -32,6 +32,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* Usage of TREE_LANG_FLAG_?:\n    0: BINFO_MARKED (BINFO nodes).\n+      IDENTIFIER_MARKED (IDENTIFIER_NODEs)\n       NEW_EXPR_USE_GLOBAL (in NEW_EXPR).\n       DELETE_EXPR_USE_GLOBAL (in DELETE_EXPR).\n       LOOKUP_EXPR_GLOBAL (in LOOKUP_EXPR).\n@@ -71,7 +72,7 @@ Boston, MA 02111-1307, USA.  */\n           or FIELD_DECL).\n       NEED_TEMPORARY_P (in REF_BIND, BASE_CONV)\n       IDENTIFIER_TYPENAME_P (in IDENTIFIER_NODE)\n-   5: Unused.\n+   5: C_IS_RESERVED_WORD (in IDENTIFIER_NODE)\n    6: BINFO_ACCESS (in BINFO)\n \n    Usage of TYPE_LANG_FLAG_?:\n@@ -282,8 +283,21 @@ struct lang_identifier\n   tree class_value;\n   tree class_template_info;\n   struct lang_id2 *x;\n+  enum rid rid_code;\n };\n \n+/* In an IDENTIFIER_NODE, nonzero if this identifier is actually a\n+   keyword.  C_RID_CODE (node) is then the RID_* value of the keyword,\n+   and C_RID_YYCODE is the token number wanted by Yacc.  */\n+\n+#define C_IS_RESERVED_WORD(id) TREE_LANG_FLAG_5 (id)\n+#define C_RID_CODE(id) \\\n+  (((struct lang_identifier *) (id))->rid_code)\n+\n+extern const short rid_to_yy[RID_MAX];\n+#define C_RID_YYCODE(id) \\\n+  rid_to_yy[((struct lang_identifier *) (id))->rid_code]\n+\n #define LANG_IDENTIFIER_CAST(NODE) \\\n \t((struct lang_identifier*)IDENTIFIER_NODE_CHECK (NODE))\n \n@@ -468,15 +482,6 @@ struct tree_srcloc\n #define IDENTIFIER_CLASS_VALUE(NODE) \\\n   (LANG_IDENTIFIER_CAST (NODE)->class_value)\n \n-/* The amount of time used by the file whose special \"time identifier\"\n-   is NODE, represented as an INTEGER_CST.  See get_time_identifier.  */\n-#define TIME_IDENTIFIER_TIME(NODE) IDENTIFIER_BINDING(NODE)\n-\n-/* For a \"time identifier\" this is a INTEGER_CST.  The\n-   TREE_INT_CST_LOW is 1 if the corresponding file is \"interface only\".\n-   The TRE_INT_CST_HIGH is 1 if it is \"interface unknown\".  */\n-#define TIME_IDENTIFIER_FILEINFO(NODE) IDENTIFIER_CLASS_VALUE (NODE)\n-\n /* TREE_TYPE only indicates on local and class scope the current\n    type. For namespace scope, the presence of a type in any namespace\n    is indicated with global_type_node, and the real type behind must\n@@ -1039,6 +1044,14 @@ extern int flag_cond_mismatch;\n \n extern int flag_no_asm;\n \n+/* Nonzero means don't recognize any extended keywords.  */\n+\n+extern int flag_no_gnu_keywords;\n+\n+/* Nonzero means recognize the named operators from C++98.  */\n+\n+extern int flag_operator_names;\n+\n /* For cross referencing.  */\n \n extern int flag_gnu_xref;\n@@ -1896,6 +1909,8 @@ struct lang_decl_flags\n   } u2;\n };\n \n+struct unparsed_text;\n+\n struct lang_decl\n {\n   struct lang_decl_flags decl_flags;\n@@ -1911,7 +1926,7 @@ struct lang_decl\n   union\n   {\n     tree sorted_fields;\n-    struct pending_inline *pending_inline_info;\n+    struct unparsed_text *pending_inline_info;\n     struct language_function *saved_language_function;\n   } u;\n \n@@ -1925,8 +1940,6 @@ struct lang_decl\n   } u2;\n };\n \n-/* An un-parsed default argument looks like an identifier.  */\n-#define DEFARG_LENGTH(NODE)  (DEFAULT_ARG_CHECK(NODE)->identifier.length)\n #define DEFARG_POINTER(NODE) (DEFAULT_ARG_CHECK(NODE)->identifier.pointer)\n \n /* Non-zero if NODE is a _DECL with TREE_READONLY set.  */\n@@ -3212,10 +3225,6 @@ extern int flag_labels_ok;\n /* Nonzero means allow Microsoft extensions without a pedwarn.  */\n extern int flag_ms_extensions;\n \n-/* Non-zero means to collect statistics which might be expensive\n-   and to print them when we are done.  */\n-extern int flag_detailed_statistics;\n-\n /* Non-zero means warn in function declared in derived class has the\n    same name as a virtual in the base class, but fails to match the\n    type signature of any virtual function in the base class.  */\n@@ -3503,25 +3512,6 @@ extern varray_type local_classes;\n \f\n /* Things for handling inline functions.  */\n \n-struct pending_inline\n-{\n-  struct pending_inline *next;\t/* pointer to next in chain */\n-  int lineno;\t\t\t/* line number we got the text from */\n-  const char *filename;\t\t/* name of file we were processing */\n-  tree fndecl;\t\t\t/* FUNCTION_DECL that brought us here */\n-  int token;\t\t\t/* token we were scanning */\n-  int token_value;\t\t/* value of token we were scanning (YYSTYPE) */\n-\n-  char *buf;\t\t\t/* pointer to character stream */\n-  int len;\t\t\t/* length of stream */\n-  unsigned int can_free : 1;\t/* free this after we're done with it? */\n-  unsigned int deja_vu : 1;\t/* set iff we don't want to see it again.  */\n-  unsigned int interface : 2;\t/* 0=interface 1=unknown 2=implementation */\n-};\n-\n-/* in method.c */\n-extern struct pending_inline *pending_inlines;\n-\n /* Negative values means we know `this' to be of static type.  */\n \n extern int flag_this_is_variable;\n@@ -4148,41 +4138,33 @@ extern void set_quals_and_spec\t\t\tPARAMS ((tree, tree, tree));\n extern void lang_init\t\t\t\tPARAMS ((void));\n extern void lang_finish\t\t\t\tPARAMS ((void));\n extern void print_parse_statistics\t\tPARAMS ((void));\n-extern void extract_interface_info\t\tPARAMS ((void));\n extern void do_pending_inlines\t\t\tPARAMS ((void));\n-extern void process_next_inline\t\t\tPARAMS ((struct pending_inline *));\n-extern struct pending_input *save_pending_input PARAMS ((void));\n-extern void restore_pending_input\t\tPARAMS ((struct pending_input *));\n+extern void process_next_inline\t\t\tPARAMS ((struct unparsed_text *));\n+\n extern void yyungetc\t\t\t\tPARAMS ((int, int));\n-extern void reinit_parse_for_method\t\tPARAMS ((int, tree));\n-extern void reinit_parse_for_block\t\tPARAMS ((int, struct obstack *));\n+extern void snarf_method\t\t\tPARAMS ((tree));\n+\n extern void check_for_missing_semicolon\t\tPARAMS ((tree));\n extern void note_got_semicolon\t\t\tPARAMS ((tree));\n extern void note_list_got_semicolon\t\tPARAMS ((tree));\n extern void do_pending_lang_change\t\tPARAMS ((void));\n-extern int identifier_type\t\t\tPARAMS ((tree));\n extern void see_typename\t\t\tPARAMS ((void));\n extern tree do_identifier\t\t\tPARAMS ((tree, int, tree));\n extern tree do_scoped_id\t\t\tPARAMS ((tree, int));\n extern tree identifier_typedecl_value\t\tPARAMS ((tree));\n-extern int real_yylex\t\t\t\tPARAMS ((void));\n-extern int is_rid\t\t\t\tPARAMS ((tree));\n extern tree build_lang_decl\t\t\tPARAMS ((enum tree_code, tree, tree));\n extern void retrofit_lang_decl\t\t\tPARAMS ((tree));\n extern tree copy_decl                           PARAMS ((tree));\n extern void copy_lang_decl\t\t\tPARAMS ((tree));\n extern tree cp_make_lang_type\t\t\tPARAMS ((enum tree_code));\n extern tree make_aggr_type\t\t\tPARAMS ((enum tree_code));\n-extern void dump_time_statistics\t\tPARAMS ((void));\n extern void compiler_error\t\t\tPARAMS ((const char *, ...))\n   ATTRIBUTE_PRINTF_1;\n extern void yyerror\t\t\t\tPARAMS ((const char *));\n extern void clear_inline_text_obstack\t\tPARAMS ((void));\n extern void maybe_snarf_defarg\t\t\tPARAMS ((void));\n-extern tree snarf_defarg\t\t\tPARAMS ((void));\n extern void add_defarg_fn\t\t\tPARAMS ((tree));\n extern void do_pending_defargs\t\t\tPARAMS ((void));\n-extern int identifier_type\t\t\tPARAMS ((tree));\n extern void yyhook\t\t\t\tPARAMS ((int));\n extern int cp_type_qual_from_rid                PARAMS ((tree));\n "}, {"sha": "03d8c6a13360d31aa525ba5688ee40686ec58cee", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -3464,7 +3464,7 @@ duplicate_decls (newdecl, olddecl)\n \tDECL_VIRTUAL_CONTEXT (newdecl) = DECL_VIRTUAL_CONTEXT (olddecl);\n       if (DECL_CONTEXT (olddecl))\n \tDECL_CONTEXT (newdecl) = DECL_CONTEXT (olddecl);\n-      if (DECL_PENDING_INLINE_INFO (newdecl) == (struct pending_inline *)0)\n+      if (DECL_PENDING_INLINE_INFO (newdecl) == 0)\n \tDECL_PENDING_INLINE_INFO (newdecl) = DECL_PENDING_INLINE_INFO (olddecl);\n       DECL_STATIC_CONSTRUCTOR (newdecl) |= DECL_STATIC_CONSTRUCTOR (olddecl);\n       DECL_STATIC_DESTRUCTOR (newdecl) |= DECL_STATIC_DESTRUCTOR (olddecl);\n@@ -6148,7 +6148,7 @@ end_only_namespace_names ()\n }\n \f\n /* Push the declarations of builtin types into the namespace.\n-   RID_INDEX, if < CP_RID_MAX is the index of the builtin type\n+   RID_INDEX is the index of the builtin type\n    in the array RID_POINTERS.  NAME is the name used when looking\n    up the builtin type.  TYPE is the _TYPE node for the builtin type.  */\n \n@@ -6161,7 +6161,7 @@ record_builtin_type (rid_index, name, type)\n   tree rname = NULL_TREE, tname = NULL_TREE;\n   tree tdecl = NULL_TREE;\n \n-  if ((int) rid_index < (int) CP_RID_MAX)\n+  if ((int) rid_index < (int) RID_MAX)\n     rname = ridpointers[(int) rid_index];\n   if (name)\n     tname = get_identifier (name);\n@@ -6172,7 +6172,7 @@ record_builtin_type (rid_index, name, type)\n     {\n       tdecl = pushdecl (build_decl (TYPE_DECL, tname, type));\n       set_identifier_type_value (tname, NULL_TREE);\n-      if ((int) rid_index < (int) CP_RID_MAX)\n+      if ((int) rid_index < (int) RID_MAX)\n \t/* Built-in types live in the global namespace. */\n \tSET_IDENTIFIER_GLOBAL_VALUE (tname, tdecl);\n     }\n@@ -6215,7 +6215,7 @@ record_builtin_java_type (name, size)\n       TYPE_PRECISION (type) = - size;\n       layout_type (type);\n     }\n-  record_builtin_type (CP_RID_MAX, name, type);\n+  record_builtin_type (RID_MAX, name, type);\n   decl = TYPE_NAME (type);\n \n   /* Suppress generate debug symbol entries for these types,\n@@ -6371,27 +6371,27 @@ init_decl_processing ()\n   record_builtin_type (RID_SIGNED, NULL_PTR, integer_type_node);\n   record_builtin_type (RID_LONG, \"long int\", long_integer_type_node);\n   record_builtin_type (RID_UNSIGNED, \"unsigned int\", unsigned_type_node);\n-  record_builtin_type (CP_RID_MAX, \"long unsigned int\",\n+  record_builtin_type (RID_MAX, \"long unsigned int\",\n \t\t       long_unsigned_type_node);\n-  record_builtin_type (CP_RID_MAX, \"unsigned long\", long_unsigned_type_node);\n-  record_builtin_type (CP_RID_MAX, \"long long int\",\n+  record_builtin_type (RID_MAX, \"unsigned long\", long_unsigned_type_node);\n+  record_builtin_type (RID_MAX, \"long long int\",\n \t\t       long_long_integer_type_node);\n-  record_builtin_type (CP_RID_MAX, \"long long unsigned int\",\n+  record_builtin_type (RID_MAX, \"long long unsigned int\",\n \t\t       long_long_unsigned_type_node);\n-  record_builtin_type (CP_RID_MAX, \"long long unsigned\",\n+  record_builtin_type (RID_MAX, \"long long unsigned\",\n \t\t       long_long_unsigned_type_node);\n   record_builtin_type (RID_SHORT, \"short int\", short_integer_type_node);\n-  record_builtin_type (CP_RID_MAX, \"short unsigned int\",\n+  record_builtin_type (RID_MAX, \"short unsigned int\",\n \t\t       short_unsigned_type_node); \n-  record_builtin_type (CP_RID_MAX, \"unsigned short\",\n+  record_builtin_type (RID_MAX, \"unsigned short\",\n \t\t       short_unsigned_type_node);\n \n   ptrdiff_type_node\n     = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (get_identifier (PTRDIFF_TYPE)));\n \n   /* Define both `signed char' and `unsigned char'.  */\n-  record_builtin_type (CP_RID_MAX, \"signed char\", signed_char_type_node);\n-  record_builtin_type (CP_RID_MAX, \"unsigned char\", unsigned_char_type_node);\n+  record_builtin_type (RID_MAX, \"signed char\", signed_char_type_node);\n+  record_builtin_type (RID_MAX, \"unsigned char\", unsigned_char_type_node);\n \n   /* `unsigned long' is the standard type for sizeof.\n      Note that stddef.h uses `unsigned long',\n@@ -6454,7 +6454,7 @@ init_decl_processing ()\n   signed_size_zero_node = build_int_2 (0, 0);\n   record_builtin_type (RID_FLOAT, NULL_PTR, float_type_node);\n   record_builtin_type (RID_DOUBLE, NULL_PTR, double_type_node);\n-  record_builtin_type (CP_RID_MAX, \"long double\", long_double_type_node);\n+  record_builtin_type (RID_MAX, \"long double\", long_double_type_node);\n \n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"complex int\"),\n \t\t\tcomplex_integer_type_node));\n@@ -6481,7 +6481,7 @@ init_decl_processing ()\n \t\t\t\t\t\tTYPE_QUAL_CONST));\n   empty_except_spec = build_tree_list (NULL_TREE, NULL_TREE);\n #if 0\n-  record_builtin_type (CP_RID_MAX, NULL_PTR, string_type_node);\n+  record_builtin_type (RID_MAX, NULL_PTR, string_type_node);\n #endif\n \n   /* Make a type to be the domain of a few array types\n@@ -6596,16 +6596,16 @@ init_decl_processing ()\n       vtable_entry_type = build_qualified_type (vtable_entry_type,\n \t\t\t\t\t\tTYPE_QUAL_CONST);\n     }\n-  record_builtin_type (CP_RID_MAX, VTBL_PTR_TYPE, vtable_entry_type);\n+  record_builtin_type (RID_MAX, VTBL_PTR_TYPE, vtable_entry_type);\n \n   vtbl_type_node\n     = build_cplus_array_type (vtable_entry_type, NULL_TREE);\n   layout_type (vtbl_type_node);\n   vtbl_type_node = build_qualified_type (vtbl_type_node, TYPE_QUAL_CONST);\n-  record_builtin_type (CP_RID_MAX, NULL_PTR, vtbl_type_node);\n+  record_builtin_type (RID_MAX, NULL_PTR, vtbl_type_node);\n   vtbl_ptr_type_node = build_pointer_type (vtable_entry_type);\n   layout_type (vtbl_ptr_type_node);\n-  record_builtin_type (CP_RID_MAX, NULL_PTR, vtbl_ptr_type_node);\n+  record_builtin_type (RID_MAX, NULL_PTR, vtbl_ptr_type_node);\n \n   std_node = build_decl (NAMESPACE_DECL,\n \t\t\t flag_honor_std \n@@ -9822,7 +9822,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n \t    next = 0;\n \n-\t    if (is_rid (dname))\n+\t    if (C_IS_RESERVED_WORD (dname))\n \t      {\n \t\tcp_error (\"declarator-id missing; using reserved word `%D'\",\n \t\t\t  dname);"}, {"sha": "7bbd998df4561c821b78df4e23f2be50bda9b102", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -368,10 +368,6 @@ int flag_labels_ok;\n \n int flag_ms_extensions;\n \n-/* Non-zero means to collect statistics which might be expensive\n-   and to print them when we are done.  */\n-int flag_detailed_statistics;\n-\n /* C++ specific flags.  */   \n /* Zero means that `this' is a *const.  This gives nice behavior in the\n    2.0 world.  1 gives 1.2-compatible behavior.  2 gives Spring behavior.\n@@ -601,6 +597,8 @@ lang_decode_option (argc, argv)\n \n   if (!strcmp (p, \"-ftraditional\") || !strcmp (p, \"-traditional\"))\n     /* ignore */;\n+  else if (!strcmp (p, \"-lang-c++\"))\n+    /* ignore - cpplib needs to see this */;\n   else if (p[0] == '-' && p[1] == 'f')\n     {\n       /* Some kind of -f option.\n@@ -922,7 +920,6 @@ void\n grok_x_components (specs)\n      tree specs;\n {\n-  struct pending_inline **p;\n   tree t;\n \n   specs = strip_attrs (specs);\n@@ -937,13 +934,6 @@ grok_x_components (specs)\n \n   fixup_anonymous_aggr (t);\n   finish_member_declaration (build_decl (FIELD_DECL, NULL_TREE, t)); \n-\n-  /* Ignore any inline function definitions in the anonymous union\n-     since an anonymous union may not have function members.  */\n-  p = &pending_inlines;\n-  for (; *p; *p = (*p)->next)\n-    if (DECL_CONTEXT ((*p)->fndecl) != t)\n-      break;\n }\n \n /* Returns a PARM_DECL for a parameter of the indicated TYPE, with the"}, {"sha": "fab533d646e2c8635493a3701844cbfa98eeca59", "filename": "gcc/cp/gxx.gperf", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26aa75bef97454f65b437067cf77a5a0255934a3/gcc%2Fcp%2Fgxx.gperf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26aa75bef97454f65b437067cf77a5a0255934a3/gcc%2Fcp%2Fgxx.gperf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxx.gperf?ref=26aa75bef97454f65b437067cf77a5a0255934a3", "patch": "@@ -1,116 +0,0 @@\n-%{\n-/* Command-line: gperf -L C -F ', 0, 0' -p -j1 -g -o -t -N is_reserved_word -k1,4,$,7 gplus.gperf  */\n-%}\n-struct resword { const char *name; short token; enum rid rid;};\n-#ifdef __GNUC__\n-__inline\n-#endif\n-static unsigned int hash PARAMS ((const char *, unsigned int));\n-#ifdef __GNUC__\n-__inline\n-#endif\n-struct resword *is_reserved_word PARAMS ((const char *, unsigned int));\n-%%\n-__alignof, ALIGNOF, RID_UNUSED\n-__alignof__, ALIGNOF, RID_UNUSED\n-__asm, ASM_KEYWORD, RID_UNUSED\n-__asm__, ASM_KEYWORD, RID_UNUSED\n-__attribute, ATTRIBUTE, RID_UNUSED\n-__attribute__, ATTRIBUTE, RID_UNUSED\n-__builtin_va_arg, VA_ARG, RID_UNUSED\n-__complex, TYPESPEC, RID_COMPLEX\n-__complex__, TYPESPEC, RID_COMPLEX\n-__const, CV_QUALIFIER, RID_CONST\n-__const__, CV_QUALIFIER, RID_CONST\n-__extension__, EXTENSION, RID_UNUSED\n-__imag, IMAGPART, RID_UNUSED\n-__imag__, IMAGPART, RID_UNUSED\n-__inline, SCSPEC, RID_INLINE\n-__inline__, SCSPEC, RID_INLINE\n-__label__, LABEL, RID_UNUSED\n-__null, CONSTANT, RID_NULL\n-__real, REALPART, RID_UNUSED\n-__real__, REALPART, RID_UNUSED\n-__restrict, CV_QUALIFIER, RID_RESTRICT\n-__restrict__, CV_QUALIFIER, RID_RESTRICT\n-__signed, TYPESPEC, RID_SIGNED\n-__signed__, TYPESPEC, RID_SIGNED\n-__typeof, TYPEOF, RID_UNUSED\n-__typeof__, TYPEOF, RID_UNUSED\n-__volatile, CV_QUALIFIER, RID_VOLATILE\n-__volatile__, CV_QUALIFIER, RID_VOLATILE\n-__wchar_t, TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,\n-asm, ASM_KEYWORD, RID_UNUSED,\n-and, ANDAND, RID_UNUSED,\n-and_eq, ASSIGN, RID_UNUSED,\n-auto, SCSPEC, RID_AUTO,\n-bitand, '&', RID_UNUSED,\n-bitor, '|', RID_UNUSED,\n-bool, TYPESPEC, RID_BOOL,\n-break, BREAK, RID_UNUSED,\n-case, CASE, RID_UNUSED,\n-catch, CATCH, RID_UNUSED,\n-char, TYPESPEC, RID_CHAR,\n-class, AGGR, RID_CLASS,\n-compl, '~', RID_UNUSED,\n-const, CV_QUALIFIER, RID_CONST,\n-const_cast, CONST_CAST, RID_UNUSED,\n-continue, CONTINUE, RID_UNUSED,\n-default, DEFAULT, RID_UNUSED,\n-delete, DELETE, RID_UNUSED,\n-do, DO, RID_UNUSED,\n-double, TYPESPEC, RID_DOUBLE,\n-dynamic_cast, DYNAMIC_CAST, RID_UNUSED,\n-else, ELSE, RID_UNUSED,\n-enum, ENUM, RID_UNUSED,\n-explicit, SCSPEC, RID_EXPLICIT,\n-export, SCSPEC, RID_EXPORT,\n-extern, SCSPEC, RID_EXTERN,\n-false, CXX_FALSE, RID_UNUSED,\n-float, TYPESPEC, RID_FLOAT,\n-for, FOR, RID_UNUSED,\n-friend, SCSPEC, RID_FRIEND,\n-goto, GOTO, RID_UNUSED,\n-if, IF, RID_UNUSED,\n-inline, SCSPEC, RID_INLINE,\n-int, TYPESPEC, RID_INT,\n-long, TYPESPEC, RID_LONG,\n-mutable, SCSPEC, RID_MUTABLE,\n-namespace, NAMESPACE, RID_UNUSED,\n-new, NEW, RID_UNUSED,\n-not, '!', RID_UNUSED,\n-not_eq, EQCOMPARE, RID_UNUSED,\n-operator, OPERATOR, RID_UNUSED,\n-or, OROR, RID_UNUSED,\n-or_eq, ASSIGN, RID_UNUSED,\n-private, VISSPEC, RID_PRIVATE,\n-protected, VISSPEC, RID_PROTECTED,\n-public, VISSPEC, RID_PUBLIC,\n-register, SCSPEC, RID_REGISTER,\n-reinterpret_cast, REINTERPRET_CAST, RID_UNUSED,\n-return, RETURN_KEYWORD, RID_UNUSED,\n-short, TYPESPEC, RID_SHORT,\n-signed, TYPESPEC, RID_SIGNED,\n-sizeof, SIZEOF, RID_UNUSED,\n-static, SCSPEC, RID_STATIC,\n-static_cast, STATIC_CAST, RID_UNUSED,\n-struct, AGGR, RID_RECORD,\n-switch, SWITCH, RID_UNUSED,\n-template, TEMPLATE, RID_TEMPLATE,\n-this, THIS, RID_UNUSED,\n-throw, THROW, RID_UNUSED,\n-true, CXX_TRUE, RID_UNUSED,\n-try, TRY, RID_UNUSED,\n-typedef, SCSPEC, RID_TYPEDEF,\n-typename, TYPENAME_KEYWORD, RID_UNUSED,\n-typeid, TYPEID, RID_UNUSED,\n-typeof, TYPEOF, RID_UNUSED,\n-union, AGGR, RID_UNION,\n-unsigned, TYPESPEC, RID_UNSIGNED,\n-using, USING, RID_UNUSED,\n-virtual, SCSPEC, RID_VIRTUAL,\n-void, TYPESPEC, RID_VOID,\n-volatile, CV_QUALIFIER, RID_VOLATILE,\n-while, WHILE, RID_UNUSED,\n-xor, '^', RID_UNUSED,\n-xor_eq, ASSIGN, RID_UNUSED,"}, {"sha": "8518d5ba1dcc9146636d778f4550c8af730e0238", "filename": "gcc/cp/hash.h", "status": "removed", "additions": 0, "deletions": 257, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26aa75bef97454f65b437067cf77a5a0255934a3/gcc%2Fcp%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26aa75bef97454f65b437067cf77a5a0255934a3/gcc%2Fcp%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fhash.h?ref=26aa75bef97454f65b437067cf77a5a0255934a3", "patch": "@@ -1,257 +0,0 @@\n-/* C code produced by gperf version 2.7.1 (19981006 egcs) */\n-/* Command-line: gperf -L C -F , 0, 0 -p -j1 -g -o -t -N is_reserved_word -k1,4,7,$ ../../../gcc/cp/gxx.gperf  */\n-/* Command-line: gperf -L C -F ', 0, 0' -p -j1 -g -o -t -N is_reserved_word -k1,4,$,7 gplus.gperf  */\n-struct resword { const char *name; short token; enum rid rid;};\n-#ifdef __GNUC__\n-__inline\n-#endif\n-static unsigned int hash PARAMS ((const char *, unsigned int));\n-#ifdef __GNUC__\n-__inline\n-#endif\n-struct resword *is_reserved_word PARAMS ((const char *, unsigned int));\n-\n-#define TOTAL_KEYWORDS 103\n-#define MIN_WORD_LENGTH 2\n-#define MAX_WORD_LENGTH 16\n-#define MIN_HASH_VALUE 4\n-#define MAX_HASH_VALUE 274\n-/* maximum key range = 271, duplicates = 0 */\n-\n-#ifdef __GNUC__\n-__inline\n-#endif\n-static unsigned int\n-hash (str, len)\n-     register const char *str;\n-     register unsigned int len;\n-{\n-  static unsigned short asso_values[] =\n-    {\n-      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n-      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n-      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n-      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n-      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n-      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n-      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n-      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n-      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n-      275, 275, 275, 275, 275,   0, 275,  97,   1,  19,\n-       40,   0,  12,  68,   0,  74, 275,   0,  11,  67,\n-       27,   0,  70,   6,  96,  43,   6,  37,   3,  10,\n-        8, 104, 275, 275, 275, 275, 275, 275, 275, 275,\n-      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n-      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n-      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n-      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n-      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n-      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n-      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n-      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n-      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n-      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n-      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n-      275, 275, 275, 275, 275, 275, 275, 275, 275, 275,\n-      275, 275, 275, 275, 275, 275\n-    };\n-  register int hval = len;\n-\n-  switch (hval)\n-    {\n-      default:\n-      case 7:\n-        hval += asso_values[(unsigned char)str[6]];\n-      case 6:\n-      case 5:\n-      case 4:\n-        hval += asso_values[(unsigned char)str[3]];\n-      case 3:\n-      case 2:\n-      case 1:\n-        hval += asso_values[(unsigned char)str[0]];\n-        break;\n-    }\n-  return hval + asso_values[(unsigned char)str[len - 1]];\n-}\n-\n-#ifdef __GNUC__\n-__inline\n-#endif\n-struct resword *\n-is_reserved_word (str, len)\n-     register const char *str;\n-     register unsigned int len;\n-{\n-  static struct resword wordlist[] =\n-    {\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"else\", ELSE, RID_UNUSED,},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"__real__\", REALPART, RID_UNUSED},\n-      {\"\", 0, 0},\n-      {\"true\", CXX_TRUE, RID_UNUSED,},\n-      {\"or_eq\", ASSIGN, RID_UNUSED,},\n-      {\"export\", SCSPEC, RID_EXPORT,},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"__const__\", CV_QUALIFIER, RID_CONST},\n-      {\"__volatile\", CV_QUALIFIER, RID_VOLATILE},\n-      {\"__real\", REALPART, RID_UNUSED},\n-      {\"__volatile__\", CV_QUALIFIER, RID_VOLATILE},\n-      {\"__const\", CV_QUALIFIER, RID_CONST},\n-      {\"xor_eq\", ASSIGN, RID_UNUSED,},\n-      {\"throw\", THROW, RID_UNUSED,},\n-      {\"__complex__\", TYPESPEC, RID_COMPLEX},\n-      {\"case\", CASE, RID_UNUSED,},\n-      {\"typeof\", TYPEOF, RID_UNUSED,},\n-      {\"\", 0, 0},\n-      {\"while\", WHILE, RID_UNUSED,},\n-      {\"bool\", TYPESPEC, RID_BOOL,},\n-      {\"__complex\", TYPESPEC, RID_COMPLEX},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"extern\", SCSPEC, RID_EXTERN,},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"not\", '!', RID_UNUSED,},\n-      {\"typedef\", SCSPEC, RID_TYPEDEF,},\n-      {\"virtual\", SCSPEC, RID_VIRTUAL,},\n-      {\"not_eq\", EQCOMPARE, RID_UNUSED,},\n-      {\"new\", NEW, RID_UNUSED,},\n-      {\"\", 0, 0},\n-      {\"do\", DO, RID_UNUSED,},\n-      {\"catch\", CATCH, RID_UNUSED,},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"delete\", DELETE, RID_UNUSED,},\n-      {\"double\", TYPESPEC, RID_DOUBLE,},\n-      {\"__extension__\", EXTENSION, RID_UNUSED},\n-      {\"__alignof__\", ALIGNOF, RID_UNUSED},\n-      {\"__asm__\", ASM_KEYWORD, RID_UNUSED},\n-      {\"\", 0, 0},\n-      {\"typeid\", TYPEID, RID_UNUSED,},\n-      {\"\", 0, 0},\n-      {\"__null\", CONSTANT, RID_NULL},\n-      {\"switch\", SWITCH, RID_UNUSED,},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"friend\", SCSPEC, RID_FRIEND,},\n-      {\"__alignof\", ALIGNOF, RID_UNUSED},\n-      {\"false\", CXX_FALSE, RID_UNUSED,},\n-      {\"sizeof\", SIZEOF, RID_UNUSED,},\n-      {\"__inline\", SCSPEC, RID_INLINE},\n-      {\"\", 0, 0},\n-      {\"__inline__\", SCSPEC, RID_INLINE},\n-      {\"\", 0, 0},\n-      {\"static_cast\", STATIC_CAST, RID_UNUSED,},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"union\", AGGR, RID_UNION,},\n-      {\"continue\", CONTINUE, RID_UNUSED,},\n-      {\"\", 0, 0},\n-      {\"goto\", GOTO, RID_UNUSED,},\n-      {\"const\", CV_QUALIFIER, RID_CONST,},\n-      {\"static\", SCSPEC, RID_STATIC,},\n-      {\"__imag__\", IMAGPART, RID_UNUSED},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"private\", VISSPEC, RID_PRIVATE,},\n-      {\"typename\", TYPENAME_KEYWORD, RID_UNUSED,},\n-      {\"\", 0, 0},\n-      {\"int\", TYPESPEC, RID_INT,},\n-      {\"__signed__\", TYPESPEC, RID_SIGNED},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"void\", TYPESPEC, RID_VOID,},\n-      {\"if\", IF, RID_UNUSED,},\n-      {\"\", 0, 0},\n-      {\"template\", TEMPLATE, RID_TEMPLATE,},\n-      {\"__attribute\", ATTRIBUTE, RID_UNUSED},\n-      {\"struct\", AGGR, RID_RECORD,},\n-      {\"__attribute__\", ATTRIBUTE, RID_UNUSED},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"this\", THIS, RID_UNUSED,},\n-      {\"const_cast\", CONST_CAST, RID_UNUSED,},\n-      {\"or\", OROR, RID_UNUSED,},\n-      {\"explicit\", SCSPEC, RID_EXPLICIT,},\n-      {\"\", 0, 0},\n-      {\"auto\", SCSPEC, RID_AUTO,},\n-      {\"bitor\", '|', RID_UNUSED,},\n-      {\"break\", BREAK, RID_UNUSED,},\n-      {\"\", 0, 0},\n-      {\"compl\", '~', RID_UNUSED,},\n-      {\"public\", VISSPEC, RID_PUBLIC,},\n-      {\"xor\", '^', RID_UNUSED,},\n-      {\"__restrict__\", CV_QUALIFIER, RID_RESTRICT},\n-      {\"and_eq\", ASSIGN, RID_UNUSED,},\n-      {\"class\", AGGR, RID_CLASS,},\n-      {\"for\", FOR, RID_UNUSED,},\n-      {\"__restrict\", CV_QUALIFIER, RID_RESTRICT},\n-      {\"try\", TRY, RID_UNUSED,},\n-      {\"__typeof__\", TYPEOF, RID_UNUSED},\n-      {\"__asm\", ASM_KEYWORD, RID_UNUSED},\n-      {\"signed\", TYPESPEC, RID_SIGNED,},\n-      {\"__label__\", LABEL, RID_UNUSED},\n-      {\"\", 0, 0},\n-      {\"volatile\", CV_QUALIFIER, RID_VOLATILE,},\n-      {\"float\", TYPESPEC, RID_FLOAT,},\n-      {\"\", 0, 0},\n-      {\"__signed\", TYPESPEC, RID_SIGNED},\n-      {\"\", 0, 0},\n-      {\"__typeof\", TYPEOF, RID_UNUSED},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"__builtin_va_arg\", VA_ARG, RID_UNUSED},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"__wchar_t\", TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,},\n-      {\"protected\", VISSPEC, RID_PROTECTED,},\n-      {\"\", 0, 0},\n-      {\"namespace\", NAMESPACE, RID_UNUSED,},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"using\", USING, RID_UNUSED,},\n-      {\"enum\", ENUM, RID_UNUSED,},\n-      {\"\", 0, 0},\n-      {\"and\", ANDAND, RID_UNUSED,},\n-      {\"__imag\", IMAGPART, RID_UNUSED},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"bitand\", '&', RID_UNUSED,},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"short\", TYPESPEC, RID_SHORT,},\n-      {\"long\", TYPESPEC, RID_LONG,},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"inline\", SCSPEC, RID_INLINE,},\n-      {\"\", 0, 0},\n-      {\"default\", DEFAULT, RID_UNUSED,},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"unsigned\", TYPESPEC, RID_UNSIGNED,},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"return\", RETURN_KEYWORD, RID_UNUSED,},\n-      {\"asm\", ASM_KEYWORD, RID_UNUSED,},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"mutable\", SCSPEC, RID_MUTABLE,},\n-      {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"dynamic_cast\", DYNAMIC_CAST, RID_UNUSED,},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"operator\", OPERATOR, RID_UNUSED,},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"char\", TYPESPEC, RID_CHAR,},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"reinterpret_cast\", REINTERPRET_CAST, RID_UNUSED,},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"register\", SCSPEC, RID_REGISTER,}\n-    };\n-\n-  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n-    {\n-      register int key = hash (str, len);\n-\n-      if (key <= MAX_HASH_VALUE && key >= 0)\n-        {\n-          register const char *s = wordlist[key].name;\n-\n-          if (*str == *s && !strcmp (str + 1, s + 1))\n-            return &wordlist[key];\n-        }\n-    }\n-  return 0;\n-}"}, {"sha": "431fed792a8b1684211914899274f4ce85390b5c", "filename": "gcc/cp/input.c", "status": "removed", "additions": 0, "deletions": 240, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26aa75bef97454f65b437067cf77a5a0255934a3/gcc%2Fcp%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26aa75bef97454f65b437067cf77a5a0255934a3/gcc%2Fcp%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finput.c?ref=26aa75bef97454f65b437067cf77a5a0255934a3", "patch": "@@ -1,240 +0,0 @@\n-/* Input handling for G++.\n-   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n-   Free Software Foundation, Inc.\n-   Written by Ken Raeburn (raeburn@cygnus.com) while at Watchmaker Computing.\n-   Enhanced by Michael Tiemann (tiemann@cygnus.com) to better support USE_CPPLIB\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* G++ needs to do enough saving and re-parsing of text that it is\n-   necessary to abandon the simple FILE* model and use a mechanism where\n-   we can pre-empt one input stream with another derived from saved text;\n-   we may need to do this arbitrarily often, and cannot depend on having\n-   the GNU library available, so FILE objects just don't cut it.\n-\n-   This file is written as a separate module, but can be included by\n-   lex.c for very minor efficiency gains (primarily in function\n-   inlining).  */\n-\n-#include \"system.h\"\n-\n-#if !USE_CPPLIB\n-struct putback_buffer {\n-  char *buffer;\n-  int   buffer_size;\n-  int   index;\n-};\n-\n-static struct putback_buffer putback = {NULL, 0, -1};\n-#endif\n-\n-struct input_source {\n-  /* saved string */\n-  const char *str;\n-  int length;\n-  /* current position, when reading as input */\n-  int offset;\n-  /* linked list maintenance */\n-  struct input_source *next;\n-  /* values to restore after reading all of current string */\n-  struct pending_input *input;\n-#if !USE_CPPLIB\n-  const char *filename;\n-  int lineno;\n-  struct putback_buffer putback;\n-#endif\n-};\n-\n-static struct input_source *input, *free_inputs;\n-\n-#if USE_CPPLIB\n-extern unsigned char *yy_cur, *yy_lim;\n-extern int yy_get_token ();\n-#endif\n-\n-extern void feed_input PARAMS ((const char *, int, const char *, int));\n-extern void put_input PARAMS ((int));\n-extern void put_back PARAMS ((int));\n-extern int getch PARAMS ((void));\n-extern int input_redirected PARAMS ((void));\n-\n-static inline struct input_source * allocate_input PARAMS ((void));\n-static inline void free_input PARAMS ((struct input_source *));\n-static inline void end_input PARAMS ((void));\n-\n-static inline struct input_source *\n-allocate_input ()\n-{\n-  struct input_source *inp;\n-  if (free_inputs)\n-    {\n-      inp = free_inputs;\n-      free_inputs = inp->next;\n-      inp->next = 0;\n-      return inp;\n-    }\n-  inp = (struct input_source *) xmalloc (sizeof (struct input_source));\n-  inp->next = 0;\n-  return inp;\n-}\n-\n-static inline void\n-free_input (inp)\n-     struct input_source *inp;\n-{\n-  inp->str = 0;\n-  inp->length = 0;\n-  inp->next = free_inputs;\n-  free_inputs = inp;\n-}\n-\n-/* Some of these external functions are declared inline in case this file\n-   is included in lex.c.  */\n-\n-inline\n-void\n-feed_input (str, len, file, line)\n-     const char *str;\n-     int len;\n-     const char *file;\n-     int line;\n-{\n-  struct input_source *inp = allocate_input ();\n-\n-  /* This shouldn't be necessary.  */\n-  while (len && !str[len-1])\n-    len--;\n-\n-#if USE_CPPLIB\n-  if (yy_lim > yy_cur)\n-    /* If we've started reading the next token, we're hosed.  The\n-       token_getch stuff is supposed to prevent this from happening.  */\n-    my_friendly_abort (990710);\n-  cpp_push_buffer (&parse_in, str, len);\n-  CPP_BUFFER (&parse_in)->manual_pop = 1;\n-  CPP_BUFFER (&parse_in)->nominal_fname\n-    = CPP_BUFFER (&parse_in)->fname = file;\n-  CPP_BUFFER (&parse_in)->lineno = parse_in.lineno = line;\n-#else\n-  inp->str = str;\n-  inp->length = len;\n-  inp->offset = 0;\n-  inp->putback = putback;\n-  inp->filename = input_filename;\n-  inp->lineno = lineno;\n-  putback.buffer = NULL;\n-  putback.buffer_size = 0;\n-  putback.index = -1;\n-#endif\n-  inp->next = input;\n-  inp->input = save_pending_input ();\n-  input = inp;\n-  lineno = line;\n-  input_filename = file;\n-}\n-\n-extern int end_of_file;\n-\n-static inline void\n-end_input ()\n-{\n-  struct input_source *inp = input;\n-\n-#if USE_CPPLIB\n-  cpp_pop_buffer (&parse_in);\n-#else\n-  putback = inp->putback;\n-  input_filename = inp->filename;\n-  lineno = inp->lineno;\n-#endif\n-\n-  end_of_file = 0;\n-  input = inp->next;\n-  /* Get interface/implementation back in sync.  */\n-  extract_interface_info ();\n-  restore_pending_input (inp->input);\n-  free_input (inp);\n-}\n-\n-inline int\n-getch ()\n-{\n-#if USE_CPPLIB\n-  return (yy_cur < yy_lim ? *yy_cur++ : yy_get_token ());\n-#else\n-  if (putback.index != -1)\n-    {\n-      int ch = putback.buffer[putback.index];\n-      --putback.index;\n-      return ch;\n-    }\n-  if (input)\n-    {\n-      if (input->offset >= input->length)\n-\t{\n-\t  my_friendly_assert (putback.index == -1, 223);\n-\t  ++(input->offset);\n-\t  if (input->offset - input->length < 64)\n-\t    return EOF;\n-\n-\t  /* We must be stuck in an error-handling rule; give up.  */\n-\t  end_input ();\n-\t  return getch ();\n-\t}\n-      return (unsigned char)input->str[input->offset++];\n-    }\n-  return getc (finput);\n-#endif\n-}\n-\n-inline\n-void\n-put_back (ch)\n-     int ch;\n-{\n-#if USE_CPPLIB\n-  if (ch == EOF)\n-    ;\n-  else if (yy_cur[-1] != ch)\n-    my_friendly_abort (990709);\n-  else\n-    yy_cur--;\n-#else\n-  if (ch != EOF)\n-    {\n-      if (putback.index == putback.buffer_size - 1)\n-\t{\n-\t  putback.buffer_size += 16;\n-\t  putback.buffer = xrealloc (putback.buffer, putback.buffer_size);\n-\t}\n-      my_friendly_assert (putback.buffer != NULL, 224);\n-      putback.buffer[++putback.index] = ch;\n-    }\n-#endif\n-}\n-\n-inline\n-int\n-input_redirected ()\n-{\n-#ifdef USE_CPPLIB\n-  return CPP_BUFFER(&parse_in)->manual_pop;\n-#else\n-  return input != 0;\n-#endif\n-}"}, {"sha": "a9c47d1c177af4c9144de8cb6630f9bf687ac5cb", "filename": "gcc/cp/lang-specs.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-specs.h?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -44,14 +44,14 @@ Boston, MA 02111-1307, USA.  */\n        %{fnew-abi:-D__GXX_ABI_VERSION=100}\\\n        %{ansi:-trigraphs -$ -D__STRICT_ANSI__} %(cpp_options)\\\n        %{!M:%{!MM:%{!E:%{!pipe:%g.ii} |\\n\\\n-     cc1plus %{!pipe:%g.ii} %(cc1_options) %{+e*}\\\n+     cc1plus -lang-c++ %{!pipe:%g.ii} %(cc1_options) %{+e*}\\\n      %{!fsyntax-only:%{!S:-o %{|!pipe:%g.s} |\\n\\\n      as %(asm_options) %{!pipe:%g.s} %A }}}}}\\n\"\n #endif /* ! USE_CPPLIB */\n   },\n   {\".ii\", \"@c++-cpp-output\"},\n   {\"@c++-cpp-output\",\n    \"%{!M:%{!MM:%{!E:\\\n-    cc1plus -fpreprocessed %i %(cc1_options) %{+e*}\\\n+    cc1plus -lang-c++ -fpreprocessed %i %(cc1_options) %{+e*}\\\n     %{!fsyntax-only:%{!S:-o %{|!pipe:%g.s} |\\n\\\n     as %(asm_options) %{!pipe:%g.s} %A }}}}}\"},"}, {"sha": "1d6ca77168c428af759f8ef89078956399e26cc1", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 537, "deletions": 3742, "changes": 4279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=0e5921e8a0f347a7de29c7347738db8de5769a88"}, {"sha": "1439c18917d381c4b2135f2bd278fa0329e51d84", "filename": "gcc/cp/lex.h", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -21,35 +21,13 @@ can know your rights and responsibilities.  It should be in a\n file named COPYING.  Among other things, the copyright notice\n and this notice must be preserved on all copies.  */\n \n-enum cp_rid\n-{\n-  RID_FRIEND = RID_MAX,\n-  RID_VIRTUAL,\n-  RID_EXPLICIT,\n-  RID_EXPORT,\n-  RID_MUTABLE,\n-  RID_LAST_MODIFIER = RID_MUTABLE,\n-\n-  RID_BOOL,\n-  RID_WCHAR,\n-\n-  /* C++ extension */\n-  RID_CLASS,\n-  RID_RECORD,\n-  RID_UNION,\n-  RID_ENUM,\n-  RID_LONGLONG,\n-\n-  RID_PUBLIC,\n-  RID_PRIVATE,\n-  RID_PROTECTED,\n-  RID_EXCEPTION,\n-  RID_TEMPLATE,\n-  RID_NULL,\n-  /* Before adding enough to get up to 64, the RIDBIT_* macros\n-     will have to be changed a little.  */\n-  CP_RID_MAX\n-};\n+#ifndef _CP_LEX_H\n+#define _CP_LEX_H\n+\n+#if 0\n+/* Formerly, the RID_* values used as mask bits did not fit into a\n+   single 32-bit word.  Now they do, but let's preserve the old logic\n+   in case they ever stop fitting again.  -zw, 8 Aug 2000 */\n \n /* The type that can represent all values of RIDBIT.  */\n /* We assume that we can stick in at least 32 bits into this.  */\n@@ -73,14 +51,28 @@ typedef struct { unsigned long idata[2]; }\n \t\t\t\t   (V).idata[1] = 0;\t\t\t      \\\n \t\t\t\t } while (0)\n #define RIDBIT_ANY_SET(V) ((V).idata[0] || (V).idata[1])\n+#else\n+typedef unsigned long RID_BIT_TYPE;\t/* assumed at least 32 bits */\n+#define RIDBIT_OF(R) ((unsigned long)1 << (int) (R))\n+\n+#define RIDBIT_SETP(N, V) ((V) & RIDBIT_OF (N))\n+#define RIDBIT_NOTSETP(N, V) (! ((V) & RIDBIT_OF (N)))\n+#define RIDBIT_ANY_SET(V) (V)\n+\n+#define RIDBIT_SET(N, V) do { (V) |= RIDBIT_OF (N); } while (0)\n+#define RIDBIT_RESET(N, V) do { (V) &= ~RIDBIT_OF (N); } while (0)\n+#define RIDBIT_RESET_ALL(V) do { (V) = 0; } while (0)\n+#endif\n \n /* the declaration found for the last IDENTIFIER token read in.\n    yylex must look this up to detect typedefs, which get token type TYPENAME,\n    so it is left around in case the identifier is not a typedef but is\n    used in a context which makes it a reference to a variable.  */\n extern tree lastiddecl;\n \n+#if !USE_CPPLIB\n extern char *token_buffer;\t/* Pointer to token buffer.  */\n+#endif\n \n /* Back-door communication channel to the lexer.  */\n extern int looking_for_typename;\n@@ -97,3 +89,5 @@ extern int pending_lang_change;\n extern int yylex PARAMS ((void));\n \n extern struct lang_decl *free_lang_decl_chain;\n+\n+#endif /* _CP_LEX_H */"}, {"sha": "5c69e104d8097fc4749af9912bfda0094eee967e", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 17, "deletions": 28, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -51,8 +51,6 @@ const char * const language_string = \"GNU C++\";\n \n extern struct obstack permanent_obstack;\n \n-extern int end_of_file;\n-\n /* Like YYERROR but do call yyerror.  */\n #define YYERROR1 { yyerror (\"syntax error\"); YYERROR; }\n \n@@ -220,8 +218,8 @@ cp_parse_init ()\n   tree ttype; \n   char *strtype; \n   enum tree_code code; \n-  flagged_type_tree ftype; \n-  struct pending_inline *pi;\n+  flagged_type_tree ftype;\n+  struct unparsed_text *pi;\n }\n \n /* All identifiers that are not reserved words\n@@ -275,7 +273,7 @@ cp_parse_init ()\n %token NAMESPACE TYPENAME_KEYWORD USING\n %token LEFT_RIGHT TEMPLATE\n %token TYPEID DYNAMIC_CAST STATIC_CAST REINTERPRET_CAST CONST_CAST\n-%token <itype> SCOPE\n+%token SCOPE\n \n /* Define the operator tokens and their precedences.\n    The value is an integer because, if used, it is the tree code\n@@ -372,7 +370,6 @@ cp_parse_init ()\n %token <pi> PRE_PARSED_FUNCTION_DECL \n %type <ttype> component_constructor_declarator\n %type <ttype> fn.def2 return_id constructor_declarator\n-%type <pi> fn.defpen \n %type <itype> ctor_initializer_opt function_try_block\n %type <ttype> named_class_head_sans_basetype\n %type <ftype> class_head named_class_head \n@@ -480,22 +477,20 @@ lang_extdef:\n \n extdef:\n \t  fndef eat_saved_input\n-\t\t{ if (pending_inlines) do_pending_inlines (); }\n+\t\t{ do_pending_inlines (); }\n \t| datadef\n-\t\t{ if (pending_inlines) do_pending_inlines (); }\n+\t\t{ do_pending_inlines (); }\n \t| template_def\n-\t\t{ if (pending_inlines) do_pending_inlines (); }\n+\t\t{ do_pending_inlines (); }\n \t| asm_keyword '(' string ')' ';'\n \t\t{ if (TREE_CHAIN ($3)) $3 = combine_strings ($3);\n \t\t  assemble_asm ($3); }\n \t| extern_lang_string '{' extdefs_opt '}'\n \t\t{ pop_lang_context (); }\n \t| extern_lang_string .hush_warning fndef .warning_ok eat_saved_input\n-\t\t{ if (pending_inlines) do_pending_inlines ();\n-\t\t  pop_lang_context (); }\n+\t\t{ do_pending_inlines (); pop_lang_context (); }\n \t| extern_lang_string .hush_warning datadef .warning_ok\n-\t\t{ if (pending_inlines) do_pending_inlines ();\n-\t\t  pop_lang_context (); }\n+\t\t{ do_pending_inlines (); pop_lang_context (); }\n \t| NAMESPACE identifier '{'\n \t\t{ push_namespace ($2); }\n \t  extdefs_opt '}'\n@@ -665,16 +660,16 @@ template_def:\n \n template_extdef:\n \t  fndef eat_saved_input\n-\t\t{ if (pending_inlines) do_pending_inlines (); }\n+\t\t{ do_pending_inlines (); }\n \t| template_datadef\n-\t\t{ if (pending_inlines) do_pending_inlines (); }\n+\t\t{ do_pending_inlines (); }\n \t| template_def\n-\t\t{ if (pending_inlines) do_pending_inlines (); }\n+\t\t{ do_pending_inlines (); }\n \t| extern_lang_string .hush_warning fndef .warning_ok eat_saved_input\n-\t\t{ if (pending_inlines) do_pending_inlines ();\n+\t\t{ do_pending_inlines ();\n \t\t  pop_lang_context (); }\n \t| extern_lang_string .hush_warning template_datadef .warning_ok\n-\t\t{ if (pending_inlines) do_pending_inlines ();\n+\t\t{ do_pending_inlines ();\n \t\t  pop_lang_context (); }\n \t| extension template_extdef\n \t\t{ pedantic = $1; }\n@@ -814,7 +809,7 @@ fn.def2:\n \t\t    YYERROR1;\n \t\t  if (yychar == YYEMPTY)\n \t\t    yychar = YYLEX;\n-\t\t  reinit_parse_for_method (yychar, $$); }\n+\t\t  snarf_method ($$); }\n \t| component_constructor_declarator\n \t\t{ $$ = parse_method ($1, NULL_TREE, NULL_TREE); \n \t\t  goto rest_of_mdef; }\n@@ -2163,24 +2158,18 @@ initlist:\n \t\t{ $$ = tree_cons ($3, $5, $$); }\n \t;\n \n-fn.defpen:\n-\tPRE_PARSED_FUNCTION_DECL\n-\t\t{ start_function (NULL_TREE, $1->fndecl, NULL_TREE, \n-\t\t\t\t  (SF_DEFAULT | SF_PRE_PARSED \n-\t\t\t\t   | SF_INCLASS_INLINE)); }\n-\n pending_inline:\n-\t  fn.defpen maybe_return_init ctor_initializer_opt compstmt_or_error\n+\t  PRE_PARSED_FUNCTION_DECL maybe_return_init ctor_initializer_opt compstmt_or_error\n \t\t{\n \t\t  expand_body (finish_function ((int)$3 | 2));\n \t\t  process_next_inline ($1);\n \t\t}\n-\t| fn.defpen maybe_return_init function_try_block\n+\t| PRE_PARSED_FUNCTION_DECL maybe_return_init function_try_block\n \t\t{ \n \t\t  expand_body (finish_function ((int)$3 | 2)); \n                   process_next_inline ($1);\n \t\t}\n-\t| fn.defpen maybe_return_init error\n+\t| PRE_PARSED_FUNCTION_DECL maybe_return_init error\n \t\t{ \n \t\t  finish_function (2); \n \t\t  process_next_inline ($1); }"}, {"sha": "8b1efab991764887eb30916c56f1f1dc1ccf57f7", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -2041,8 +2041,7 @@ finish_class_definition (t, attributes, semi, pop_scope_p)\n void\n begin_inline_definitions ()\n {\n-  if (pending_inlines \n-      && current_scope () == current_function_decl)\n+  if (current_scope () == current_function_decl)\n     do_pending_inlines ();\n }\n "}, {"sha": "341f772e3abf321ad4b9a12b0527c699cabb2c16", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 1123, "deletions": 188, "changes": 1311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -20,7 +20,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-\n /* This file is the type analyzer for GNU C++.  To debug it, define SPEW_DEBUG\n    when compiling parse.c and spew.c.  */\n \n@@ -29,34 +28,121 @@ Boston, MA 02111-1307, USA.  */\n #include \"input.h\"\n #include \"tree.h\"\n #include \"cp-tree.h\"\n+#include \"cpplib.h\"\n+#include \"c-lex.h\"\n #include \"lex.h\"\n #include \"parse.h\"\n #include \"flags.h\"\n #include \"obstack.h\"\n #include \"toplev.h\"\n+#include \"ggc.h\"\n+#include \"intl.h\"\n+#include \"timevar.h\"\n+\n+#ifdef SPEW_DEBUG\n+#define SPEW_INLINE\n+#else\n+#define SPEW_INLINE inline\n+#endif\n+\n+#if USE_CPPLIB\n+extern cpp_reader parse_in;\n+#endif\n \n /* This takes a token stream that hasn't decided much about types and\n    tries to figure out as much as it can, with excessive lookahead and\n    backtracking.  */\n \n /* fifo of tokens recognized and available to parser.  */\n-struct token  {\n+struct token\n+{\n   /* The values for YYCHAR will fit in a short.  */\n   short\t\tyychar;\n-  short\t\tend_of_file;\n+  unsigned int\tlineno;\n   YYSTYPE\tyylval;\n };\n \n-static int do_aggr PARAMS ((void));\n-static void scan_tokens PARAMS ((unsigned int));\n+/* Since inline methods can refer to text which has not yet been seen,\n+   we store the text of the method in a structure which is placed in the\n+   DECL_PENDING_INLINE_INFO field of the FUNCTION_DECL.\n+   After parsing the body of the class definition, the FUNCTION_DECL's are\n+   scanned to see which ones have this field set.  Those are then digested\n+   one at a time.\n+\n+   This function's FUNCTION_DECL will have a bit set in its common so\n+   that we know to watch out for it.  */\n+\n+struct unparsed_text\n+{\n+  struct unparsed_text *next;\t/* process this one next */\n+  tree decl;\t\t/* associated declaration */\n+  const char *filename;\t/* name of file we were processing */\n+  int lineno;\t\t/* line number we got the text from */\n+  int interface;\t/* remembering interface_unknown and interface_only */\n+\n+  struct token *pos;\t/* current position, when rescanning */\n+  struct token *limit;\t/* end of saved text */\n+};\n+\n+/* Stack of state saved off when we return to an inline method or\n+   default argument that has been stored for later parsing.  */\n+struct feed\n+{\n+  struct unparsed_text *input;\n+  const char *filename;\n+  int lineno;\n+  int yychar;\n+  YYSTYPE yylval;\n+  int first_token;\n+  struct obstack token_obstack;\n+  struct feed *next;\n+};  \n+\n+static struct obstack feed_obstack;\n+static struct feed *feed;\n+\n+static SPEW_INLINE void do_aggr PARAMS ((void));\n+static SPEW_INLINE int identifier_type PARAMS ((tree));\n+static void scan_tokens PARAMS ((int));\n+static void feed_defarg PARAMS ((tree));\n+static void finish_defarg PARAMS ((void));\n+static int read_token PARAMS ((struct token *));\n+\n+static SPEW_INLINE int num_tokens PARAMS ((void));\n+static SPEW_INLINE struct token *nth_token PARAMS ((int));\n+static SPEW_INLINE int add_token PARAMS ((struct token *));\n+static SPEW_INLINE int shift_token PARAMS ((void));\n+static SPEW_INLINE void push_token PARAMS ((struct token *));\n+static SPEW_INLINE void consume_token PARAMS ((void));\n+static SPEW_INLINE int read_process_identifier PARAMS ((YYSTYPE *));\n+\n+static SPEW_INLINE void feed_input PARAMS ((struct unparsed_text *));\n+static SPEW_INLINE void end_input PARAMS ((void));\n+static SPEW_INLINE void snarf_block PARAMS ((const char *, int));\n+static tree snarf_defarg PARAMS ((void));\n+\n+/* The list of inline functions being held off until we reach the end of\n+   the current class declaration.  */\n+struct unparsed_text *pending_inlines;\n+struct unparsed_text *pending_inlines_tail;\n+\n+/* The list of previously-deferred inline functions currently being parsed.\n+   This exists solely to be a GC root.  */\n+struct unparsed_text *processing_these_inlines;\n+\n+static void begin_parsing_inclass_inline PARAMS ((struct unparsed_text *));\n+static void mark_pending_inlines PARAMS ((PTR));\n \n #ifdef SPEW_DEBUG\n-static int num_tokens PARAMS ((void));\n-static struct token *nth_token PARAMS ((int));\n-static void add_token PARAMS ((struct token *));\n-static void consume_token PARAMS ((void));\n-static int debug_yychar PARAMS ((int));\n+int spew_debug = 0;\n+static unsigned int yylex_ctr = 0;\n+\n+static void debug_yychar PARAMS ((int));\n+\n+/* In parse.y: */\n+extern char *debug_yytranslate PARAMS ((int));\n #endif\n+static enum cpp_ttype last_token;\n \n /* From lex.c: */\n /* the declaration found for the last IDENTIFIER token read in.\n@@ -67,31 +153,324 @@ extern tree lastiddecl;\t\t/* let our brains leak out here too */\n extern int\tyychar;\t\t/*  the lookahead symbol\t\t*/\n extern YYSTYPE\tyylval;\t\t/*  the semantic value of the\t\t*/\n \t\t\t\t/*  lookahead symbol\t\t\t*/\n-extern int end_of_file;\n-\n+/* The token fifo lives in this obstack.  */\n struct obstack token_obstack;\n int first_token;\n-  \n-#ifdef SPEW_DEBUG\n-int spew_debug = 0;\n-static unsigned int yylex_ctr = 0;\n-static int debug_yychar ();\n-#endif\n \n-/* Initialize token_obstack. Called once, from init_parse.  */\n+/* Sometimes we need to save tokens for later parsing.  If so, they are\n+   stored on this obstack.  */\n+struct obstack inline_text_obstack;\n+char *inline_text_firstobj;\n+\n+/* When we see a default argument in a method declaration, we snarf it as\n+   text using snarf_defarg.  When we get up to namespace scope, we then go\n+   through and parse all of them using do_pending_defargs.  Since yacc\n+   parsers are not reentrant, we retain defargs state in these two\n+   variables so that subsequent calls to do_pending_defargs can resume\n+   where the previous call left off.  */\n+\n+static tree defarg_fns;\n+static tree defarg_parm;\n+\n+/* Initialize obstacks. Called once, from init_parse.  */\n \n void\n init_spew ()\n {\n+  gcc_obstack_init (&inline_text_obstack);\n+  inline_text_firstobj = (char *) obstack_alloc (&inline_text_obstack, 0);\n   gcc_obstack_init (&token_obstack);\n+  gcc_obstack_init (&feed_obstack);\n+  ggc_add_tree_root (&defarg_fns, 1);\n+  ggc_add_tree_root (&defarg_parm, 1);\n+\n+  ggc_add_root (&pending_inlines, 1, sizeof (struct unparsed_text *),\n+\t\tmark_pending_inlines);\n+  ggc_add_root (&processing_these_inlines, 1, sizeof (struct unparsed_text *),\n+\t\tmark_pending_inlines);\n }\n \n-#ifdef SPEW_DEBUG\n-/* Use functions for debugging...  */\n+void\n+clear_inline_text_obstack ()\n+{\n+  obstack_free (&inline_text_obstack, inline_text_firstobj);\n+}\n \n-/* Return the number of tokens available on the fifo.  */\n+/* Subroutine of read_token.  */\n+static SPEW_INLINE int\n+read_process_identifier (pyylval)\n+     YYSTYPE *pyylval;\n+{\n+  tree id = pyylval->ttype;\n+\n+  if (C_IS_RESERVED_WORD (id))\n+    {\n+      /* Possibly replace the IDENTIFIER_NODE with a magic cookie.\n+\t Can't put yylval.code numbers in ridpointers[].  Bleah.  */\n \n+      switch (C_RID_CODE (id))\n+\t{\n+\tcase RID_BITAND: pyylval->code = BIT_AND_EXPR;\treturn '&';\n+\tcase RID_AND_EQ: pyylval->code = BIT_AND_EXPR;\treturn ASSIGN;\n+\tcase RID_BITOR:\t pyylval->code = BIT_IOR_EXPR;\treturn '|';\n+\tcase RID_OR_EQ:\t pyylval->code = BIT_IOR_EXPR;\treturn ASSIGN;\n+\tcase RID_XOR:\t pyylval->code = BIT_XOR_EXPR;\treturn '^';\n+\tcase RID_XOR_EQ: pyylval->code = BIT_XOR_EXPR;\treturn ASSIGN;\n+\tcase RID_NOT_EQ: pyylval->code = NE_EXPR;\treturn EQCOMPARE;\n+\n+\tdefault:\n+\t  if (C_RID_YYCODE (id) == TYPESPEC)\n+\t    GNU_xref_ref (current_function_decl, IDENTIFIER_POINTER (id));\n+\n+\t  pyylval->ttype = ridpointers[C_RID_CODE (id)];\n+\t  return C_RID_YYCODE (id);\n+\t}\n+    }\n+\n+  GNU_xref_ref (current_function_decl, IDENTIFIER_POINTER (id));\n+\n+  /* Make sure that user does not collide with our internal naming\n+     scheme.  This is not necessary if '.' is used to remove them from\n+     the user's namespace, but is if '$' or double underscores are.  */\n+\n+#if !defined(JOINER) || JOINER == '$'\n+  if (THIS_NAME_P (id)\n+      || VPTR_NAME_P (id)\n+      || DESTRUCTOR_NAME_P (id)\n+      || VTABLE_NAME_P (id)\n+      || TEMP_NAME_P (id)\n+      || ANON_AGGRNAME_P (id)\n+      || ANON_PARMNAME_P (id))\n+     warning (\n+\"identifier name `%s' conflicts with GNU C++ internal naming strategy\",\n+\t      IDENTIFIER_POINTER (id));\n+#endif\n+  return IDENTIFIER;\n+}\n+\n+/* Read the next token from the input file.  The token is written into\n+   T, and its type number is returned.  */\n static int\n+read_token (t)\n+     struct token *t;\n+{\n+ retry:\n+\n+  last_token = c_lex (&t->yylval.ttype);\n+\n+  switch (last_token)\n+    {\n+#define YYCHAR(yy)\tt->yychar = yy;\tbreak;\n+#define YYCODE(c)\tt->yylval.code = c;\n+\n+    case CPP_EQ:\t\t\t\tYYCHAR('=');\n+    case CPP_NOT:\t\t\t\tYYCHAR('!');\n+    case CPP_GREATER:\tYYCODE(GT_EXPR);\tYYCHAR('>');\n+    case CPP_LESS:\tYYCODE(LT_EXPR);\tYYCHAR('<');\n+    case CPP_PLUS:\tYYCODE(PLUS_EXPR);\tYYCHAR('+');\n+    case CPP_MINUS:\tYYCODE(MINUS_EXPR);\tYYCHAR('-');\n+    case CPP_MULT:\tYYCODE(MULT_EXPR);\tYYCHAR('*');\n+    case CPP_DIV:\tYYCODE(TRUNC_DIV_EXPR);\tYYCHAR('/');\n+    case CPP_MOD:\tYYCODE(TRUNC_MOD_EXPR);\tYYCHAR('%');\n+    case CPP_AND:\tYYCODE(BIT_AND_EXPR);\tYYCHAR('&');\n+    case CPP_OR:\tYYCODE(BIT_IOR_EXPR);\tYYCHAR('|');\n+    case CPP_XOR:\tYYCODE(BIT_XOR_EXPR);\tYYCHAR('^');\n+    case CPP_RSHIFT:\tYYCODE(RSHIFT_EXPR);\tYYCHAR(RSHIFT);\n+    case CPP_LSHIFT:\tYYCODE(LSHIFT_EXPR);\tYYCHAR(LSHIFT);\n+\n+    case CPP_COMPL:\t\t\t\tYYCHAR('~');\n+    case CPP_AND_AND:\t\t\t\tYYCHAR(ANDAND);\n+    case CPP_OR_OR:\t\t\t\tYYCHAR(OROR);\n+    case CPP_QUERY:\t\t\t\tYYCHAR('?');\n+    case CPP_COLON:\t\t\t\tYYCHAR(':');\n+    case CPP_COMMA:\t\t\t\tYYCHAR(',');\n+    case CPP_OPEN_PAREN:\t\t\tYYCHAR('(');\n+    case CPP_CLOSE_PAREN:\t\t\tYYCHAR(')');\n+    case CPP_EQ_EQ:\tYYCODE(EQ_EXPR);\tYYCHAR(EQCOMPARE);\n+    case CPP_NOT_EQ:\tYYCODE(NE_EXPR);\tYYCHAR(EQCOMPARE);\n+    case CPP_GREATER_EQ:YYCODE(GE_EXPR);\tYYCHAR(ARITHCOMPARE);\n+    case CPP_LESS_EQ:\tYYCODE(LE_EXPR);\tYYCHAR(ARITHCOMPARE);\n+\n+    case CPP_PLUS_EQ:\tYYCODE(PLUS_EXPR);\tYYCHAR(ASSIGN);\n+    case CPP_MINUS_EQ:\tYYCODE(MINUS_EXPR);\tYYCHAR(ASSIGN);\n+    case CPP_MULT_EQ:\tYYCODE(MULT_EXPR);\tYYCHAR(ASSIGN);\n+    case CPP_DIV_EQ:\tYYCODE(TRUNC_DIV_EXPR);\tYYCHAR(ASSIGN);\n+    case CPP_MOD_EQ:\tYYCODE(TRUNC_MOD_EXPR);\tYYCHAR(ASSIGN);\n+    case CPP_AND_EQ:\tYYCODE(BIT_AND_EXPR);\tYYCHAR(ASSIGN);\n+    case CPP_OR_EQ:\tYYCODE(BIT_IOR_EXPR);\tYYCHAR(ASSIGN);\n+    case CPP_XOR_EQ:\tYYCODE(BIT_XOR_EXPR);\tYYCHAR(ASSIGN);\n+    case CPP_RSHIFT_EQ:\tYYCODE(RSHIFT_EXPR);\tYYCHAR(ASSIGN);\n+    case CPP_LSHIFT_EQ:\tYYCODE(LSHIFT_EXPR);\tYYCHAR(ASSIGN);\n+\n+    case CPP_OPEN_SQUARE:\t\t\tYYCHAR('[');\n+    case CPP_CLOSE_SQUARE:\t\t\tYYCHAR(']');\n+    case CPP_OPEN_BRACE:\t\t\tYYCHAR('{');\n+    case CPP_CLOSE_BRACE:\t\t\tYYCHAR('}');\n+    case CPP_SEMICOLON:\t\t\t\tYYCHAR(';');\n+    case CPP_ELLIPSIS:\t\t\t\tYYCHAR(ELLIPSIS);\n+\n+    case CPP_PLUS_PLUS:\t\t\t\tYYCHAR(PLUSPLUS);\n+    case CPP_MINUS_MINUS:\t\t\tYYCHAR(MINUSMINUS);\n+    case CPP_DEREF:\t\t\t\tYYCHAR(POINTSAT);\n+    case CPP_DOT:\t\t\t\tYYCHAR('.');\n+\n+    /* These tokens are C++ specific.  */\n+    case CPP_SCOPE:\t\t\t\tYYCHAR(SCOPE);\n+    case CPP_DEREF_STAR: \t\t\tYYCHAR(POINTSAT_STAR);\n+    case CPP_DOT_STAR:\t\t\t\tYYCHAR(DOT_STAR);\n+    case CPP_MIN_EQ:\tYYCODE(MIN_EXPR);\tYYCHAR(ASSIGN);\n+    case CPP_MAX_EQ:\tYYCODE(MAX_EXPR);\tYYCHAR(ASSIGN);\n+    case CPP_MIN:\tYYCODE(MIN_EXPR);\tYYCHAR(MIN_MAX);\n+    case CPP_MAX:\tYYCODE(MAX_EXPR);\tYYCHAR(MIN_MAX);\n+#undef YYCHAR\n+#undef YYCODE\n+\n+    case CPP_EOF:\n+#if USE_CPPLIB\n+      cpp_pop_buffer (&parse_in);\n+      if (CPP_BUFFER (&parse_in))\n+\tgoto retry;\n+#endif\n+      t->yychar = 0;\n+      break;\n+      \n+    case CPP_NAME:\n+      t->yychar = read_process_identifier (&t->yylval);\n+      break;\n+\n+    case CPP_INT:\n+    case CPP_FLOAT:\n+    case CPP_NUMBER:\n+    case CPP_CHAR:\n+    case CPP_WCHAR:\n+      t->yychar = CONSTANT;\n+      break;\n+\n+    case CPP_STRING:\n+    case CPP_WSTRING:\n+      t->yychar = STRING;\n+      break;\n+\n+      /* This token should not be generated in C++ mode.  */\n+    case CPP_OSTRING:\n+\n+      /* These tokens should not survive translation phase 4.  */\n+    case CPP_HASH:\n+    case CPP_PASTE:\n+      error (\"syntax error before '#' token\");\n+      goto retry;\n+\n+    case CPP_BACKSLASH:\n+      error (\"syntax error before '\\\\' token\");\n+      goto retry;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  t->lineno = lineno;\n+  return t->yychar;\n+}\n+\n+static SPEW_INLINE void\n+feed_input (input)\n+     struct unparsed_text *input;\n+{\n+  struct feed *f;\n+#if 0\n+  if (feed)\n+    abort ();\n+#endif\n+\n+  f = obstack_alloc (&feed_obstack, sizeof (struct feed));\n+\n+  /* The token list starts just after the struct unparsed_text in memory.  */\n+  input->pos = (struct token *) (input + 1);\n+\n+#ifdef SPEW_DEBUG\n+  if (spew_debug)\n+    fprintf (stderr, \"\\tfeeding %s:%d [%d tokens]\\n\",\n+\t     input->filename, input->lineno, input->limit - input->pos);\n+#endif\n+\n+  f->input = input;\n+  f->filename = input_filename;\n+  f->lineno = lineno;\n+  f->yychar = yychar;\n+  f->yylval = yylval;\n+  f->first_token = first_token;\n+  f->token_obstack = token_obstack;\n+  f->next = feed;\n+\n+  input_filename = input->filename;\n+  lineno = input->lineno;\n+  yychar = YYEMPTY;\n+  yylval.ttype = NULL_TREE;\n+  first_token = 0;\n+  gcc_obstack_init (&token_obstack);\n+  feed = f;\n+}\n+\n+static SPEW_INLINE void\n+end_input ()\n+{\n+  struct feed *f = feed;\n+\n+  input_filename = f->filename;\n+  lineno = f->lineno;\n+  yychar = f->yychar;\n+  yylval = f->yylval;\n+  first_token = f->first_token;\n+  obstack_free (&token_obstack, 0);\n+  token_obstack = f->token_obstack;\n+  feed = f->next;\n+\n+  obstack_free (&feed_obstack, f);\n+\n+#ifdef SPEW_DEBUG\n+  if (spew_debug)\n+    fprintf (stderr, \"\\treturning to %s:%d\\n\", input_filename, lineno);\n+#endif\n+}\n+\n+/* GC callback to mark memory pointed to by the pending inline queue.  */\n+static void\n+mark_pending_inlines (pi)\n+     PTR pi;\n+{\n+  struct unparsed_text *up = * (struct unparsed_text **)pi;\n+\n+  while (up)\n+    {\n+      struct token *t = (struct token *) (up + 1);\n+      struct token *l = up->limit;\n+\n+      while (t < l)\n+\t{\n+\t  /* Some of the possible values for yychar use yylval.code\n+\t     instead of yylval.ttype.  We only have to worry about\n+\t     yychars that could have been returned by read_token.  */\n+\t  switch (t->yychar)\n+\t    {\n+\t    case '+':\t    case '-':\t    case '*':\t    case '/':\n+\t    case '%':\t    case '&':\t    case '|':\t    case '^':\n+\t    case '>':\t    case '<':\t    case LSHIFT:    case RSHIFT:\n+\t    case ASSIGN:    case MIN_MAX:   case EQCOMPARE: case ARITHCOMPARE:\n+\t      t++;\n+\t      continue;\n+\t    }\n+\t  if (t->yylval.ttype)\n+\t    ggc_mark_tree (t->yylval.ttype);\n+\t  t++;\n+\t}\n+      up = up->next;\n+    }\n+}\n+  \n+/* Token queue management.  */\n+\n+/* Return the number of tokens available on the fifo.  */\n+static SPEW_INLINE int\n num_tokens ()\n {\n   return (obstack_object_size (&token_obstack) / sizeof (struct token))\n@@ -100,28 +479,51 @@ num_tokens ()\n \n /* Fetch the token N down the line from the head of the fifo.  */\n \n-static struct token*\n+static SPEW_INLINE struct token*\n nth_token (n)\n      int n;\n {\n+#ifdef ENABLE_CHECKING\n   /* could just have this do slurp_ implicitly, but this way is easier\n      to debug...  */\n-  my_friendly_assert (n < num_tokens (), 298);\n+  my_friendly_assert (n >= 0 && n < num_tokens (), 298);\n+#endif\n   return ((struct token*)obstack_base (&token_obstack)) + n + first_token;\n }\n \n-/* Add a token to the token fifo.  */\n+static const struct token Teosi = { END_OF_SAVED_INPUT, 0 UNION_INIT_ZERO };\n+static const struct token Tpad = { EMPTY, 0 UNION_INIT_ZERO };\n \n-static void\n+/* Copy the next token into T and return its value.  */\n+static SPEW_INLINE int\n add_token (t)\n-     struct token* t;\n+     struct token *t;\n {\n-  obstack_grow (&token_obstack, t, sizeof (struct token));\n+  if (!feed)\n+    return read_token (t);\n+\n+  if (feed->input->pos < feed->input->limit)\n+    {\n+      memcpy (t, feed->input->pos, sizeof (struct token));\n+      return (feed->input->pos++)->yychar;\n+    }\n+  \n+  memcpy (t, &Teosi, sizeof (struct token));\n+  return END_OF_SAVED_INPUT;\n+}\n+\n+/* Shift the next token onto the fifo.  */\n+static SPEW_INLINE int\n+shift_token ()\n+{\n+  size_t point = obstack_object_size (&token_obstack);\n+  obstack_blank (&token_obstack, sizeof (struct token));\n+  return add_token ((struct token *) (obstack_base (&token_obstack) + point));\n }\n \n /* Consume the next token out of the fifo.  */\n \n-static void\n+static SPEW_INLINE void\n consume_token ()\n {\n   if (num_tokens () == 1)\n@@ -133,149 +535,244 @@ consume_token ()\n     first_token++;\n }\n \n-#else\n-/* ...otherwise use macros.  */\n-\n-#define num_tokens() \\\n-  ((obstack_object_size (&token_obstack) / sizeof (struct token)) - first_token)\n-\n-#define nth_token(N) \\\n-  (((struct token*)obstack_base (&token_obstack))+(N)+first_token)\n-\n-#define add_token(T) obstack_grow (&token_obstack, (T), sizeof (struct token))\n+/* Push a token at the head of the queue; it will be the next token read.  */\n+static SPEW_INLINE void\n+push_token (t)\n+     struct token *t;\n+{\n+  if (first_token == 0)  /* We hope this doesn't happen often.  */\n+    {\n+      size_t active = obstack_object_size (&token_obstack);\n+      obstack_blank (&token_obstack, sizeof (struct token));\n+      if (active)\n+\tmemmove (obstack_base (&token_obstack) + sizeof (struct token),\n+\t\t obstack_base (&token_obstack), active);\n+      first_token++;\n+    }\n+  first_token--;\n+  memcpy (nth_token (0), t, sizeof (struct token));\n+}\n \n-#define consume_token() \\\n-  (num_tokens () == 1\t\t\t\t\t\t\t\\\n-   ? (obstack_free (&token_obstack, obstack_base (&token_obstack)),\t\\\n-      (first_token = 0))\t\t\t\t\t\t\\\n-   : first_token++)\n-#endif\n \n-/* Pull in enough tokens from real_yylex that the queue is N long beyond\n-   the current token.  */\n+/* Pull in enough tokens that the queue is N long beyond the current\n+   token.  */\n \n static void\n scan_tokens (n)\n-     unsigned int n;\n+     int n;\n {\n-  unsigned int i;\n-  struct token *tmp;\n+  int i;\n+  int num = num_tokens ();\n+  int yychar;\n+\n+  /* First, prune any empty tokens at the end.  */\n+  i = num;\n+  while (i > 0 && nth_token (i - 1)->yychar == EMPTY)\n+    i--;\n+  if (i < num)\n+    {\n+      obstack_blank (&token_obstack, -((num - i) * sizeof (struct token)));\n+      num = i;\n+    }\n \n-  /* We cannot read past certain tokens, so make sure we don't.  */\n-  i = num_tokens ();\n-  if (i > n)\n+  /* Now, if we already have enough tokens, return.  */\n+  if (num > n)\n     return;\n-  while (i-- > 0)\n+\n+  /* Never read past these characters: they might separate\n+     the current input stream from one we save away later.  */\n+  for (i = 0; i < num; i++)\n     {\n-      tmp = nth_token (i);\n-      /* Never read past these characters: they might separate\n-\t the current input stream from one we save away later.  */\n-      if (tmp->yychar == '{' || tmp->yychar == ':' || tmp->yychar == ';')\n+      yychar = nth_token (i)->yychar;\n+      if (yychar == '{' || yychar == ':' || yychar == ';')\n \tgoto pad_tokens;\n     }\n \n   while (num_tokens () <= n)\n     {\n-      obstack_blank (&token_obstack, sizeof (struct token));\n-      tmp = ((struct token *)obstack_next_free (&token_obstack))-1;\n-      tmp->yychar = real_yylex ();\n-      tmp->end_of_file = end_of_file;\n-      tmp->yylval = yylval;\n-      end_of_file = 0;\n-      if (tmp->yychar == '{'\n-\t  || tmp->yychar == ':'\n-\t  || tmp->yychar == ';')\n-\t{\n-\tpad_tokens:\n-\t  while (num_tokens () <= n)\n-\t    {\n-\t      obstack_blank (&token_obstack, sizeof (struct token));\n-\t      tmp = ((struct token *)obstack_next_free (&token_obstack))-1;\n-\t      tmp->yychar = EMPTY;\n-\t      tmp->end_of_file = 0;\n-\t    }\n-\t}\n+      yychar = shift_token ();\n+      if (yychar == '{' || yychar == ':' || yychar == ';')\n+\tgoto pad_tokens;\n     }\n+  return;\n+  \n+ pad_tokens:\n+  while (num_tokens () <= n)\n+    obstack_grow (&token_obstack, &Tpad, sizeof (struct token));\n }\n \n-/* from lex.c: */\n-/* Value is 1 (or 2) if we should try to make the next identifier look like\n-   a typename (when it may be a local variable or a class variable).\n-   Value is 0 if we treat this name in a default fashion.  */\n-extern int looking_for_typename;\n+int looking_for_typename;\n int looking_for_template;\n-extern int do_snarf_defarg;\n+\n+static int after_friend;\n+static int after_new;\n+static int do_snarf_defarg;\n \n tree got_scope;\n tree got_object;\n \n-int\n-peekyylex ()\n+static SPEW_INLINE int\n+identifier_type (decl)\n+     tree decl;\n+{\n+  tree t;\n+\n+  if (TREE_CODE (decl) == TEMPLATE_DECL)\n+    {\n+      if (TREE_CODE (DECL_TEMPLATE_RESULT (decl)) == TYPE_DECL)\n+\treturn PTYPENAME;\n+      else if (looking_for_template) \n+\treturn PFUNCNAME;\n+    }\n+  if (looking_for_template && really_overloaded_fn (decl))\n+    {\n+      /* See through a baselink.  */\n+      if (TREE_CODE (decl) == TREE_LIST)\n+\tdecl = TREE_VALUE (decl);\n+\n+      for (t = decl; t != NULL_TREE; t = OVL_CHAIN (t))\n+\tif (DECL_FUNCTION_TEMPLATE_P (OVL_FUNCTION (t))) \n+\t  return PFUNCNAME;\n+    }\n+  if (TREE_CODE (decl) == NAMESPACE_DECL)\n+    return NSNAME;\n+  if (TREE_CODE (decl) != TYPE_DECL)\n+    return IDENTIFIER;\n+  if (DECL_ARTIFICIAL (decl) && TREE_TYPE (decl) == current_class_type)\n+    return SELFNAME;\n+\n+  /* A constructor declarator for a template type will get here as an\n+     implicit typename, a TYPENAME_TYPE with a type.  */\n+  t = got_scope;\n+  if (t && TREE_CODE (t) == TYPENAME_TYPE)\n+    t = TREE_TYPE (t);\n+  decl = TREE_TYPE (decl);\n+  if (TREE_CODE (decl) == TYPENAME_TYPE)\n+    decl = TREE_TYPE (decl);\n+  if (t && t == decl)\n+    return SELFNAME;\n+\n+  return TYPENAME;\n+}\n+\n+/* token[0] == AGGR (struct/union/enum)\n+   Thus, token[1] is either a TYPENAME or a TYPENAME_DEFN.\n+   If token[2] == '{' or ':' then it's TYPENAME_DEFN.\n+   It's also a definition if it's a forward declaration (as in 'struct Foo;')\n+   which we can tell if token[2] == ';' *and* token[-1] != FRIEND or NEW.  */\n+\n+static SPEW_INLINE void\n+do_aggr ()\n {\n-  scan_tokens (0);\n-  return nth_token (0)->yychar;\n+  int yc1, yc2;\n+  \n+  scan_tokens (2);\n+  yc1 = nth_token (1)->yychar;\n+  if (yc1 != TYPENAME && yc1 != IDENTIFIER && yc1 != PTYPENAME)\n+    return;\n+  yc2 = nth_token (2)->yychar;\n+  if (yc2 == ';')\n+    {\n+      /* It's a forward declaration iff we were not preceded by\n+         'friend' or `new'.  */\n+      if (after_friend || after_new)\n+\treturn;\n+    }\n+  else if (yc2 != '{' && yc2 != ':')\n+    return;\n+\n+  switch (yc1)\n+    {\n+    case TYPENAME:\n+      nth_token (1)->yychar = TYPENAME_DEFN;\n+      break;\n+    case PTYPENAME:\n+      nth_token (1)->yychar = PTYPENAME_DEFN;\n+      break;\n+    case IDENTIFIER:\n+      nth_token (1)->yychar = IDENTIFIER_DEFN;\n+      break;\n+    default:\n+      my_friendly_abort (102);\n+    }\n+}  \n+\n+void\n+see_typename ()\n+{\n+  /* Only types expected, not even namespaces. */\n+  looking_for_typename = 2;\n+  if (yychar < 0)\n+    if ((yychar = yylex ()) < 0) yychar = 0;\n+  looking_for_typename = 0;\n+  if (yychar == IDENTIFIER)\n+    {\n+      lastiddecl = lookup_name (yylval.ttype, -2);\n+      if (lastiddecl == 0)\n+\t{\n+\t  if (flag_labels_ok)\n+\t    lastiddecl = IDENTIFIER_LABEL_VALUE (yylval.ttype);\n+\t}\n+      else\n+\tyychar = identifier_type (lastiddecl);\n+    }\n }\n \n int\n yylex ()\n {\n-  struct token tmp_token;\n+  int yychr;\n   tree trrr = NULL_TREE;\n   int old_looking_for_typename = 0;\n \n+  timevar_push (TV_LEX);\n+\n  retry:\n #ifdef SPEW_DEBUG\n   if (spew_debug)\n   {\n     yylex_ctr ++;\n-    fprintf (stderr, \"\\t\\t## %d ##\", yylex_ctr);\n+    fprintf (stderr, \"\\t\\t## %d @%d \", yylex_ctr, lineno);\n   }\n #endif\n \n   if (do_snarf_defarg)\n     {\n-      my_friendly_assert (num_tokens () == 0, 2837);\n-      tmp_token.yychar = DEFARG;\n-      tmp_token.yylval.ttype = snarf_defarg ();\n-      tmp_token.end_of_file = 0;\n       do_snarf_defarg = 0;\n-      add_token (&tmp_token);\n+      yylval.ttype = snarf_defarg ();\n+      yychar = DEFARG;\n+      got_object = NULL_TREE;\n+      timevar_pop (TV_LEX);\n+      return DEFARG;\n     }\n \n   /* if we've got tokens, send them */\n   else if (num_tokens ())\n-    tmp_token= *nth_token (0);\n+    yychr = nth_token (0)->yychar;\n   else\n-    {\n-      /* if not, grab the next one and think about it */\n-      tmp_token.yychar = real_yylex ();\n-      tmp_token.yylval = yylval;\n-      tmp_token.end_of_file = end_of_file;\n-      add_token (&tmp_token);\n-    }\n+    yychr = shift_token ();\n \n   /* many tokens just need to be returned. At first glance, all we\n      have to do is send them back up, but some of them are needed to\n      figure out local context.  */\n-  switch (tmp_token.yychar)\n+  switch (yychr)\n     {\n     case EMPTY:\n       /* This is a lexical no-op.  */\n-      consume_token ();\n #ifdef SPEW_DEBUG    \n       if (spew_debug)\n-\tdebug_yychar (tmp_token.yychar);\n+\tdebug_yychar (yychr);\n #endif\n+      consume_token ();\n       goto retry;\n \n     case '(':\n       scan_tokens (1);\n       if (nth_token (1)->yychar == ')')\n \t{\n \t  consume_token ();\n-\t  tmp_token.yychar = LEFT_RIGHT;\n+\t  yychr = LEFT_RIGHT;\n \t}\n-      consume_token ();\n       break;\n \n     case IDENTIFIER:\n@@ -289,12 +786,12 @@ yylex ()\n       else if (nth_token (1)->yychar == '<')\n \tlooking_for_template = 1;\n \n-      trrr = lookup_name (tmp_token.yylval.ttype, -2);\n+      trrr = lookup_name (nth_token (0)->yylval.ttype, -2);\n \n       if (trrr)\n \t{\n-\t  tmp_token.yychar = identifier_type (trrr);\n-\t  switch (tmp_token.yychar)\n+\t  yychr = identifier_type (trrr);\n+\t  switch (yychr)\n \t    {\n \t    case TYPENAME:\n \t    case SELFNAME:\n@@ -305,7 +802,7 @@ yylex ()\n \t      /* If this got special lookup, remember it.  In these\n \t         cases, we know it can't be a declarator-id. */\n \t      if (got_scope || got_object)\n-\t\ttmp_token.yylval.ttype = trrr;\n+\t\tnth_token (0)->yylval.ttype = trrr;\n \t      break;\n \n \t    case PFUNCNAME:\n@@ -326,150 +823,588 @@ yylex ()\n     case TYPENAME_DEFN:\n     case PTYPENAME:\n     case PTYPENAME_DEFN:\n-      consume_token ();\n       /* If we see a SCOPE next, restore the old value.\n \t Otherwise, we got what we want. */\n       looking_for_typename = old_looking_for_typename;\n       looking_for_template = 0;\n       break;\n \n     case SCSPEC:\n-      if (tmp_token.yylval.ttype == ridpointers[RID_EXTERN])\n+      if (nth_token (0)->yylval.ttype == ridpointers[RID_EXTERN])\n \t{\n \t  scan_tokens (1);\n \t  if (nth_token (1)->yychar == STRING)\n \t    {\n-\t      tmp_token.yychar = EXTERN_LANG_STRING;\n-\t      tmp_token.yylval.ttype = get_identifier\n+\t      yychr = EXTERN_LANG_STRING;\n+\t      nth_token (1)->yylval.ttype = get_identifier\n \t\t(TREE_STRING_POINTER (nth_token (1)->yylval.ttype));\n \t      consume_token ();\n \t    }\n \t}\n       /* If export, warn that it's unimplemented and go on. */\n-      else if (tmp_token.yylval.ttype == ridpointers[RID_EXPORT])\n+      else if (nth_token (0)->yylval.ttype == ridpointers[RID_EXPORT])\n \t{\n \t  warning (\"keyword 'export' not implemented and will be ignored\");\n+#ifdef SPEW_DEBUG    \n+\t  if (spew_debug)\n+\t    debug_yychar (yychr);\n+#endif\n \t  consume_token ();\n \t  goto retry;\n \t}\n-      /* do_aggr needs to check if the previous token was `friend',\n-\t so just increment first_token instead of calling consume_token.  */\n-      ++first_token;\n+      /* do_aggr needs to know if the previous token was `friend'.  */\n+      else if (nth_token (0)->yylval.ttype == ridpointers[RID_FRIEND])\n+\tafter_friend = 1;\n+\n       break;\n \n     case NEW:\n-      /* do_aggr needs to check if the previous token was `new',\n-\t so just increment first_token instead of calling consume_token.  */\n-      ++first_token;\n+      /* do_aggr needs to know if the previous token was `new'.  */\n+      after_new = 1;\n       break;\n \n     case TYPESPEC:\n+    case '{':\n+    case ':':\n+    case ';':\n       /* If this provides a type for us, then revert lexical\n \t state to standard state.  */\n       looking_for_typename = 0;\n-      consume_token ();\n       break;\n \n     case AGGR:\n-      *nth_token (0) = tmp_token;\n       do_aggr ();\n-      /* fall through to output...  */\n+      after_friend = after_new = 0;\n+      break;\n+\n     case ENUM:\n       /* Set this again, in case we are rescanning.  */\n       looking_for_typename = 2;\n-      /* fall through...  */\n+      break;\n+\n     default:\n-      consume_token ();\n+      break;\n     }\n \n   /* class member lookup only applies to the first token after the object\n      expression, except for explicit destructor calls.  */\n-  if (tmp_token.yychar != '~')\n+  if (yychr != '~')\n     got_object = NULL_TREE;\n \n-  /* Clear looking_for_typename if we got 'enum { ... };'.  */\n-  if (tmp_token.yychar == '{' || tmp_token.yychar == ':'\n-      || tmp_token.yychar == ';')\n-    looking_for_typename = 0;\n+  yychar = yychr;\n+  yylval = nth_token (0)->yylval;\n+  lineno = nth_token (0)->lineno;\n \n-  yylval = tmp_token.yylval;\n-  yychar = tmp_token.yychar;\n-  end_of_file = tmp_token.end_of_file;\n #ifdef SPEW_DEBUG    \n   if (spew_debug)\n-    debug_yychar (yychar);\n+    debug_yychar (yychr);\n #endif\n+  consume_token ();\n \n-  return yychar;\n+  timevar_pop (TV_LEX);\n+  return yychr;\n }\n \n-/* token[0] == AGGR (struct/union/enum)\n-   Thus, token[1] is either a TYPENAME or a TYPENAME_DEFN.\n-   If token[2] == '{' or ':' then it's TYPENAME_DEFN.\n-   It's also a definition if it's a forward declaration (as in 'struct Foo;')\n-   which we can tell if token[2] == ';' *and* token[-1] != FRIEND or NEW.  */\n+/* Unget character CH from the input stream.\n+   If RESCAN is non-zero, then we want to `see' this\n+   character as the next input token.  */\n \n-static int\n-do_aggr ()\n+void\n+yyungetc (ch, rescan)\n+     int ch;\n+     int rescan;\n {\n-  int yc1, yc2;\n-  \n-  scan_tokens (2);\n-  yc1 = nth_token (1)->yychar;\n-  if (yc1 != TYPENAME && yc1 != IDENTIFIER && yc1 != PTYPENAME)\n-    return 0;\n-  yc2 = nth_token (2)->yychar;\n-  if (yc2 == ';')\n+  /* Unget a character from the input stream.  */\n+  if (yychar == YYEMPTY || rescan == 0)\n     {\n-      /* It's a forward declaration iff we were not preceded by\n-         'friend' or `new'.  */\n-      if (first_token > 0)\n+      struct token fake;\n+\n+      /* If we're putting back a brace, undo the change in indent_level\n+\t from the first time we saw it.  */\n+      if (ch == '{')\n+\tindent_level--;\n+      else if (ch == '}')\n+\tindent_level++;\n+\n+      fake.yychar = ch;\n+      fake.yylval.ttype = 0;\n+      fake.lineno = lineno;\n+\n+      push_token (&fake);\n+    }\n+  else\n+    {\n+      yychar = ch;\n+    }\n+}\n+\n+\n+/* Set up the state required to correctly handle the definition of the\n+   inline function whose preparsed state has been saved in PI.  */\n+\n+static void\n+begin_parsing_inclass_inline (pi)\n+     struct unparsed_text *pi;\n+{\n+  tree context;\n+\n+  /* Record that we are processing the chain of inlines starting at\n+     PI in a special GC root.  */\n+  processing_these_inlines = pi;\n+\n+  ggc_collect ();\n+\n+  /* If this is an inline function in a local class, we must make sure\n+     that we save all pertinent information about the function\n+     surrounding the local class.  */\n+  context = decl_function_context (pi->decl);\n+  if (context)\n+    push_function_context_to (context);\n+\n+  feed_input (pi);\n+  interface_unknown = pi->interface == 1;\n+  interface_only  = pi->interface == 0;\n+  DECL_PENDING_INLINE_P (pi->decl) = 0;\n+  DECL_PENDING_INLINE_INFO (pi->decl) = 0;\n+\n+  /* Pass back a handle to the rest of the inline functions, so that they\n+     can be processed later.  */\n+  yychar = PRE_PARSED_FUNCTION_DECL;\n+  yylval.pi = pi;\n+\n+  start_function (NULL_TREE, pi->decl, NULL_TREE,\n+\t\t  (SF_DEFAULT | SF_PRE_PARSED | SF_INCLASS_INLINE));\n+}\n+\n+/* Called from the top level: if there are any pending inlines to\n+   do, set up to process them now.  This function sets up the first function\n+   to be parsed; after it has been, the rule for fndef in parse.y will\n+   call process_next_inline to start working on the next one.  */\n+\n+void\n+do_pending_inlines ()\n+{\n+  /* Oops, we're still dealing with the last batch.  */\n+  if (yychar == PRE_PARSED_FUNCTION_DECL)\n+    return;\n+\n+  if (pending_inlines)\n+    {\n+      /* Clear the chain, so that any inlines nested inside the batch\n+\t we're to process now don't refer to this batch.  See e.g.\n+\t g++.other/lookup6.C.  */\n+      struct unparsed_text *first = pending_inlines;\n+      pending_inlines = pending_inlines_tail = 0;\n+\n+      begin_parsing_inclass_inline (first);\n+    }\n+}\n+\n+/* Called from the fndecl rule in the parser when the function just parsed\n+   was declared using a PRE_PARSED_FUNCTION_DECL (i.e. came from\n+   do_pending_inlines).  */\n+\n+void\n+process_next_inline (i)\n+     struct unparsed_text *i;\n+{\n+  tree decl = i->decl;\n+  tree context = decl_function_context (decl);\n+\n+  if (context)\n+    pop_function_context_from (context);\n+  if (yychar == YYEMPTY)\n+    yychar = yylex ();\n+  if (yychar != END_OF_SAVED_INPUT)\n+    error (\"parse error at end of saved function text\");\n+  end_input ();\n+\n+  i = i->next;\n+  if (i)\n+    begin_parsing_inclass_inline (i);\n+  else\n+    {\n+      processing_these_inlines = 0;\n+      extract_interface_info ();\n+    }\n+}\n+\n+\n+/* Subroutine of snarf_method, deals with actual absorption of the block.  */\n+\n+static SPEW_INLINE void\n+snarf_block (starting_file, starting_line)\n+     const char *starting_file;\n+     int starting_line;\n+{\n+  int blev = 1;\n+  int look_for_semicolon = 0;\n+  int look_for_lbrac = 0;\n+  int look_for_catch = 0;\n+  int yyc;\n+  struct token tmp;\n+  size_t point;\n+\n+  if (yychar == '{')\n+    /* We incremented indent_level in yylex; undo that.  */\n+    indent_level--;\n+  else if (yychar == '=')\n+    look_for_semicolon = 1;\n+  else if (yychar == ':' || yychar == RETURN_KEYWORD || yychar == TRY)\n+    {\n+      if (yychar == TRY)\n+\tlook_for_catch = 1;\n+      look_for_lbrac = 1;\n+      blev = 0;\n+    }\n+  else\n+    yyerror (\"parse error in method specification\");\n+\n+  /* The current token is the first one to be recorded.  */\n+  tmp.yychar = yychar;\n+  tmp.yylval = yylval;\n+  tmp.lineno = lineno;\n+  obstack_grow (&inline_text_obstack, &tmp, sizeof (struct token));\n+\n+  for (;;)\n+    {\n+      point = obstack_object_size (&inline_text_obstack);\n+      obstack_blank (&inline_text_obstack, sizeof (struct token));\n+      yyc = add_token ((struct token *)\n+\t\t       (obstack_base (&inline_text_obstack) + point));\n+\n+      if (yyc == '{')\n+\t{\n+\t  look_for_lbrac = 0;\n+\t  blev++;\n+\t}\n+      else if (yyc == '}')\n+\t{\n+\t  blev--;\n+\t  if (blev == 0 && !look_for_semicolon)\n+\t    {\n+\t      if (!look_for_catch)\n+\t\tbreak;\n+\t      \n+\t      if (add_token (&tmp) != CATCH)\n+\t\t{\n+\t\t  push_token (&tmp);\n+\t\t  break;\n+\t\t}\n+\n+\t      look_for_lbrac = 1;\n+\t      obstack_grow (&inline_text_obstack, &tmp, sizeof (struct token));\n+\t    }\n+\t}\n+      else if (yyc == ';')\n \t{\n-\t  if (nth_token (-1)->yychar == SCSPEC\n-\t      && nth_token (-1)->yylval.ttype == ridpointers[(int) RID_FRIEND])\n-\t    return 0;\n-\t  if (nth_token (-1)->yychar == NEW)\n-\t    return 0;\n+\t  if (look_for_lbrac)\n+\t    {\n+\t      error (\"function body for constructor missing\");\n+\t      /* fake a { } to avoid further errors */\n+\t      tmp.yylval.ttype = 0;\n+\t      tmp.yychar = '{';\n+\t      obstack_grow (&inline_text_obstack, &tmp, sizeof (struct token));\n+\t      tmp.yychar = '}';\n+\t      obstack_grow (&inline_text_obstack, &tmp, sizeof (struct token));\n+\t      break;\n+\t    }\n+\t  else if (look_for_semicolon && blev == 0)\n+\t    break;\n+\t}\n+      else if (yyc == 0)\n+\t{\n+\t  error_with_file_and_line (starting_file, starting_line,\n+\t\t\t\t    \"end of file read inside definition\");\n+\t  break;\n \t}\n     }\n-  else if (yc2 != '{' && yc2 != ':')\n-    return 0;\n+}\n \n-  switch (yc1)\n+/* This function stores away the text for an inline function that should\n+   be processed later (by do_pending_inlines).  */\n+void\n+snarf_method (decl)\n+     tree decl;\n+{\n+  int starting_lineno = lineno;\n+  const char *starting_filename = input_filename;\n+  size_t len;\n+\n+  struct unparsed_text *meth;\n+\n+  /* Leave room for the header, then absorb the block.  */\n+  obstack_blank (&inline_text_obstack, sizeof (struct unparsed_text));\n+  snarf_block (starting_filename, starting_lineno);\n+\n+  len = obstack_object_size (&inline_text_obstack);\n+  meth = (struct unparsed_text *) obstack_finish (&inline_text_obstack);\n+\n+  /* Happens when we get two declarations of the same function in the\n+     same scope.  */\n+  if (decl == void_type_node\n+      || (current_class_type && TYPE_REDEFINED (current_class_type)))\n     {\n-    case TYPENAME:\n-      nth_token (1)->yychar = TYPENAME_DEFN;\n-      break;\n-    case PTYPENAME:\n-      nth_token (1)->yychar = PTYPENAME_DEFN;\n-      break;\n-    case IDENTIFIER:\n-      nth_token (1)->yychar = IDENTIFIER_DEFN;\n-      break;\n-    default:\n-      my_friendly_abort (102);\n+      obstack_free (&inline_text_obstack, (char *)meth);\n+      return;\n     }\n-  return 0;\n-}  \n+\n+  meth->decl = decl;\n+  meth->filename = starting_filename;\n+  meth->lineno = starting_lineno;\n+  meth->limit = (struct token *) ((char *)meth + len);\n+  meth->interface = (interface_unknown ? 1 : (interface_only ? 0 : 2));\n+  meth->next = 0;\n+\n+#ifdef SPEW_DEBUG\n+  if (spew_debug)\n+    fprintf (stderr, \"\\tsaved method of %d tokens from %s:%d\\n\",\n+\t     meth->limit - (struct token *) (meth + 1),\n+\t     starting_filename, starting_lineno);\n+#endif\n+\n+  DECL_PENDING_INLINE_INFO (decl) = meth;\n+  DECL_PENDING_INLINE_P (decl) = 1;\n+\n+  if (pending_inlines_tail)\n+    pending_inlines_tail->next = meth;\n+  else\n+    pending_inlines = meth;\n+  pending_inlines_tail = meth;\n+}\n+\n+/* Consume a no-commas expression - a default argument - and save it\n+   on the inline_text_obstack.  */\n+\n+static tree\n+snarf_defarg ()\n+{\n+  int starting_lineno = lineno;\n+  const char *starting_filename = input_filename;\n+  int yyc;\n+  int plev = 0;\n+  size_t point;\n+  size_t len;\n+  struct unparsed_text *buf;\n+  tree arg;\n+\n+  obstack_blank (&inline_text_obstack, sizeof (struct unparsed_text));\n+\n+  for (;;)\n+    {\n+      point = obstack_object_size (&inline_text_obstack);\n+      obstack_blank (&inline_text_obstack, sizeof (struct token));\n+      yyc = add_token ((struct token *)\n+\t\t       (obstack_base (&inline_text_obstack) + point));\n+\n+      if (plev <= 0 && (yyc == ')' || yyc == ','))\n+\tbreak;\n+      else if (yyc == '(' || yyc == '[')\n+\t++plev;\n+      else if (yyc == ']' || yyc == ')')\n+\t--plev;\n+      else if (yyc == 0)\n+\t{\n+\t  error_with_file_and_line (starting_filename, starting_lineno,\n+\t\t\t\t    \"end of file read inside default argument\");\n+\t  goto done;\n+\t}\n+    }\n+\n+  /* Unget the last token.  */\n+  push_token ((struct token *) (obstack_base (&inline_text_obstack) + point));\n+  /* This is the documented way to shrink a growing obstack block.  */\n+  obstack_blank (&inline_text_obstack, - sizeof (struct token));\n+\n+ done:\n+  len = obstack_object_size (&inline_text_obstack);\n+  buf = (struct unparsed_text *) obstack_finish (&inline_text_obstack);\n+\n+  buf->decl = 0;\n+  buf->filename = starting_filename;\n+  buf->lineno = starting_lineno;\n+  buf->limit = (struct token *) ((char *)buf + len);\n+  buf->next = 0;\n   \n+#ifdef SPEW_DEBUG\n+  if (spew_debug)\n+    fprintf (stderr, \"\\tsaved defarg of %d tokens from %s:%d\\n\",\n+\t     buf->limit - (struct token *) (buf + 1),\n+\t     starting_filename, starting_lineno);\n+#endif\n+\n+  arg = make_node (DEFAULT_ARG);\n+  DEFARG_POINTER (arg) = (char *)buf;\n+\n+  return arg;\n+}\n+\n+/* Decide whether the default argument we are about to see should be\n+   gobbled up as text for later parsing.  */\n+\n+void\n+maybe_snarf_defarg ()\n+{\n+  if (current_class_type && TYPE_BEING_DEFINED (current_class_type))\n+    do_snarf_defarg = 1;\n+}\n+\n+/* Called from grokfndecl to note a function decl with unparsed default\n+   arguments for later processing.  Also called from grokdeclarator\n+   for function types with unparsed defargs; the call from grokfndecl\n+   will always come second, so we can overwrite the entry from the type.  */\n+\n+void\n+add_defarg_fn (decl)\n+     tree decl;\n+{\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    TREE_VALUE (defarg_fns) = decl;\n+  else\n+    defarg_fns = tree_cons (current_class_type, decl, defarg_fns);  \n+}\n+\n+/* Helper for do_pending_defargs.  Starts the parsing of a default arg.  */\n+\n+static void\n+feed_defarg (p)\n+     tree p;\n+{\n+  tree d = TREE_PURPOSE (p);\n+\n+  feed_input ((struct unparsed_text *)DEFARG_POINTER (d));\n+  yychar = DEFARG_MARKER;\n+  yylval.ttype = p;\n+}\n+\n+/* Helper for do_pending_defargs.  Ends the parsing of a default arg.  */\n+\n+static void\n+finish_defarg ()\n+{\n+  if (yychar == YYEMPTY)\n+    yychar = yylex ();\n+  if (yychar != END_OF_SAVED_INPUT)\n+    error (\"parse error at end of saved function text\");\n+\n+  end_input ();\n+}  \n+\n+/* Main function for deferred parsing of default arguments.  Called from\n+   the parser.  */\n+\n+void\n+do_pending_defargs ()\n+{\n+  if (defarg_parm)\n+    finish_defarg ();\n+\n+  for (; defarg_fns; defarg_fns = TREE_CHAIN (defarg_fns))\n+    {\n+      tree defarg_fn = TREE_VALUE (defarg_fns);\n+      if (defarg_parm == NULL_TREE)\n+\t{\n+\t  push_nested_class (TREE_PURPOSE (defarg_fns), 1);\n+\t  pushlevel (0);\n+\t  if (TREE_CODE (defarg_fn) == FUNCTION_DECL)\n+\t    maybe_begin_member_template_processing (defarg_fn);\n+\n+\t  if (TREE_CODE (defarg_fn) == FUNCTION_DECL)\n+\t    defarg_parm = TYPE_ARG_TYPES (TREE_TYPE (defarg_fn));\n+\t  else\n+\t    defarg_parm = TYPE_ARG_TYPES (defarg_fn);\n+\t}\n+      else\n+\tdefarg_parm = TREE_CHAIN (defarg_parm);\n+\n+      for (; defarg_parm; defarg_parm = TREE_CHAIN (defarg_parm))\n+\tif (TREE_PURPOSE (defarg_parm)\n+\t    && TREE_CODE (TREE_PURPOSE (defarg_parm)) == DEFAULT_ARG)\n+\t  {\n+\t    feed_defarg (defarg_parm);\n+\n+\t    /* Return to the parser, which will process this defarg\n+\t       and call us again.  */\n+\t    return;\n+\t  }\n+\n+      if (TREE_CODE (defarg_fn) == FUNCTION_DECL)\n+\t{\n+\t  maybe_end_member_template_processing ();\n+\t  check_default_args (defarg_fn);\n+\t}\n+\n+      poplevel (0, 0, 0);\n+      pop_nested_class ();\n+    }\n+}\n+\n #ifdef SPEW_DEBUG    \n /* debug_yychar takes a yychar (token number) value and prints its name.  */\n \n-static int\n+static void\n debug_yychar (yy)\n      int yy;\n {\n-  /* In parse.y: */\n-  extern char *debug_yytranslate ();\n-  \n-  int i;\n-  \n-  if (yy<256) {\n-    fprintf (stderr, \"<%d: %c >\\n\", yy, yy);\n-    return 0;\n-  }\n-  fprintf (stderr, \"<%d:%s>\\n\", yy, debug_yytranslate (yy));\n-  return 1;\n+  if (yy<256)\n+    fprintf (stderr, \"->%d < %c >\\n\", lineno, yy);\n+  else if (yy == IDENTIFIER || yy == TYPENAME)\n+    {\n+      const char *id;\n+      if (TREE_CODE (yylval.ttype) == IDENTIFIER_NODE)\n+\tid = IDENTIFIER_POINTER (yylval.ttype);\n+      else if (TREE_CODE_CLASS (TREE_CODE (yylval.ttype)) == 'd')\n+\tid = IDENTIFIER_POINTER (DECL_NAME (yylval.ttype));\n+      else\n+\tid = \"\";\n+      fprintf (stderr, \"->%d <%s `%s'>\\n\", lineno, debug_yytranslate (yy), id);\n+    }\n+  else\n+    fprintf (stderr, \"->%d <%s>\\n\", lineno, debug_yytranslate (yy));\n }\n \n #endif\n+\n+#if USE_CPPLIB\n+#define NAME(type) cpp_type2name (type)\n+#else\n+/* Bleah */\n+#include \"symcat.h\"\n+#define OP(e, s) s,\n+#define TK(e, s) STRINGX(e),\n+\n+static const char *type2name[N_TTYPES] = { TTYPE_TABLE };\n+#define NAME(type) type2name[type]\n+#endif\n+\n+void\n+yyerror (msgid)\n+     const char *msgid;\n+{\n+  const char *string = _(msgid);\n+\n+  if (last_token == CPP_EOF)\n+    error (\"%s at end of input\", string);\n+  else if (last_token == CPP_CHAR || last_token == CPP_WCHAR)\n+    {\n+      unsigned int val = TREE_INT_CST_LOW (yylval.ttype);\n+      const char *ell = (last_token == CPP_CHAR) ? \"\" : \"L\";\n+      if (val <= UCHAR_MAX && ISGRAPH (val))\n+\terror (\"%s before %s'%c'\", string, ell, val);\n+      else\n+\terror (\"%s before %s'\\\\x%x'\", string, ell, val);\n+    }\n+  else if (last_token == CPP_STRING\n+\t   || last_token == CPP_WSTRING\n+\t   || last_token == CPP_OSTRING)\n+    error (\"%s before string constant\", string);\n+  else if (last_token == CPP_NUMBER\n+\t   || last_token == CPP_INT\n+\t   || last_token == CPP_FLOAT)\n+    error (\"%s before numeric constant\", string);\n+  else if (last_token == CPP_NAME\n+\t   && TREE_CODE (yylval.ttype) == IDENTIFIER_NODE)\n+    error (\"%s before \\\"%s\\\"\", string, IDENTIFIER_POINTER (yylval.ttype));\n+  else\n+    error (\"%s before '%s' token\", string, NAME(last_token));\n+}"}, {"sha": "59778c626d4f44a11798c020bd1defb121936917", "filename": "gcc/flags.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -19,6 +19,9 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#ifndef GCC_FLAGS_H\n+#define GCC_FLAGS_H\n+\n /* Name of the input .c file being compiled.  */\n extern const char *main_input_filename;\n \n@@ -590,3 +593,9 @@ extern int flag_no_ident;\n /* Nonzero means we should do dwarf2 duplicate elimination.  */\n \n extern int flag_eliminate_dwarf2_dups;\n+\n+/* Non-zero means to collect statistics which might be expensive\n+   and to print them when we are done.  */\n+extern int flag_detailed_statistics;\n+\n+#endif /* GCC_FLAGS_H */"}, {"sha": "e87b143a622ba9d53c05f4183debe5666ef26f26", "filename": "gcc/gcc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -567,7 +567,7 @@ static const char *cpp_options =\n  %{fshort-wchar:-U__WCHAR_TYPE__ -D__WCHAR_TYPE__=short\\\\ unsigned\\\\ int}\\\n  %{fshow-column} %{fno-show-column}\\\n  %{fleading-underscore} %{fno-leading-underscore}\\\n- %{g*} %{W*} %{w} %{pedantic*} %{H} %{d*} %C %{D*} %{U*} %{i*} %Z %i\\\n+ %{g*} %{W*} %{w} %{pedantic*} %{H} %{d*} %C %{U*} %{D*} %{i*} %Z %i\\\n  %{E:%W{o*}}%{M:%W{o*}}%{MM:%W{o*}}\";\n \n static const char *cc1_options =\n@@ -693,7 +693,7 @@ static struct compiler default_compilers[] =\n   {\".c\", \"@c\"},\n   {\"@c\",\n #if USE_CPPLIB\n-     \"%{E|M|MM:cpp0 -lang-c %{ansi:-std=c89} %(cpp_options)}\\\n+     \"%{E|M|MM:%(trad_capable_cpp) -lang-c %{ansi:-std=c89} %(cpp_options)}\\\n       %{!E:%{!M:%{!MM:cc1 -lang-c %{ansi:-std=c89} %(cpp_options)\\\n \t\t\t  %(cc1_options) %{!fsyntax-only:%{!S:-o %{|!pipe:%g.s} |\\n\\\n       as %(asm_options) %{!pipe:%g.s} %A }}}}}\""}, {"sha": "7ece70589252b2060cbd7204db79f51d719454c6", "filename": "gcc/objc/Make-lang.in", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fobjc%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fobjc%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FMake-lang.in?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -68,7 +68,7 @@ objc-parse.o : $(srcdir)/objc/objc-parse.c \\\n    $(CONFIG_H) $(TREE_H) $(srcdir)/toplev.h $(srcdir)/ggc.h \\\n    $(srcdir)/c-lex.h $(srcdir)/c-tree.h $(srcdir)/c-common.h \\\n    $(srcdir)/input.h $(srcdir)/flags.h $(srcdir)/output.h \\\n-   $(srcdir)/objc/objc-act.h system.h\n+   $(srcdir)/objc/objc-act.h system.h cpplib.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -I$(srcdir)/objc \\\n \t-c $(srcdir)/objc/objc-parse.c\n \n@@ -88,8 +88,7 @@ objc-act.o : $(srcdir)/objc/objc-act.c \\\n    $(CONFIG_H) $(TREE_H) $(RTL_H) system.h \\\n    $(srcdir)/c-tree.h $(srcdir)/c-common.h $(srcdir)/c-lex.h \\\n    $(srcdir)/toplev.h $(srcdir)/flags.h $(srcdir)/objc/objc-act.h \\\n-   $(srcdir)/input.h $(srcdir)/function.h $(srcdir)/output.h \\\n-   $(srcdir)/c-parse.h\n+   $(srcdir)/input.h $(srcdir)/function.h $(srcdir)/output.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -I$(srcdir)/objc \\\n \t-c $(srcdir)/objc/objc-act.c\n "}, {"sha": "d6d50e0663abb742399276bba3aab6a87f49e91d", "filename": "gcc/objc/lang-specs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fobjc%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fobjc%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Flang-specs.h?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -24,7 +24,7 @@ Boston, MA 02111-1307, USA.  */\n   {\".m\", \"@objective-c\"},\n   {\"@objective-c\",\n #if USE_CPPLIB\n-     \"%{E|M|MM:cpp0 -lang-objc %{ansi:-std=c89} %(cpp_options)}\\\n+     \"%{E|M|MM:%(trad_capable_cpp) -lang-objc %{ansi:-std=c89} %(cpp_options)}\\\n       %{!E:%{!M:%{!MM:cc1obj -lang-objc %(cpp_options) %(cc1_options) %{gen-decls}\\\n              %{!fsyntax-only:%{!S:-o %{|!pipe:%g.s} |\\n\\\n       as %(asm_options) %{!pipe:%g.s} %A }}}}}\""}, {"sha": "ba5837ad9f8c44c8c8ed47136c39b3386d1fa579", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -56,7 +56,6 @@ Boston, MA 02111-1307, USA.  */\n #if USE_CPPLIB\n #include \"cpplib.h\"\n extern cpp_reader  parse_in;\n-extern cpp_options parse_options;\n #endif\n \n /* This is the default way of generating a method name.  */\n@@ -137,7 +136,6 @@ char *util_firstobj;\n \n /* for encode_method_def */\n #include \"rtl.h\"\n-#include \"c-parse.h\"\n \n #define OBJC_VERSION\t(flag_next_runtime ? 5 : 8)\n #define PROTOCOL_VERSION 2\n@@ -693,17 +691,12 @@ generate_struct_by_value_array ()\n   exit (0);\n }\n \n-#if USE_CPPLIB\n-extern char *yy_cur;\n-#endif\n-\n void\n lang_init_options ()\n {\n #if USE_CPPLIB\n+  cpp_init ();\n   cpp_reader_init (&parse_in);\n-  parse_in.opts = &parse_options;\n-  cpp_options_init (&parse_options);\n #endif\n }\n \n@@ -715,16 +708,11 @@ lang_init ()\n      With luck, we discover the real source file's name from that\n      and put it in input_filename.  */\n   ungetc (check_newline (), finput);\n-#else\n-  check_newline ();\n-  yy_cur--;\n-#endif \n-\n-  /* The line number can be -1 if we had -g3 and the input file\n-     had a directive specifying line 0.  But we want predefined\n-     functions to have a line number of 0, not -1.  */\n-  if (lineno == -1)\n-    lineno = 0;\n+#endif\n+  /* Force the line number back to 0; check_newline will have\n+     raised it to 1, which will make the builtin functions appear\n+     not to be built in.  */\n+  lineno = 0;\n \n   /* If gen_declaration desired, open the output file.  */\n   if (flag_gen_declaration)\n@@ -800,9 +788,7 @@ lang_decode_option (argc, argv)\n {\n   const char *p = argv[0];\n \n-  if (!strcmp (p, \"-lang-objc\"))\n-    c_language = clk_objective_c;\n-  else if (!strcmp (p, \"-gen-decls\"))\n+  if (!strcmp (p, \"-gen-decls\"))\n     flag_gen_declaration = 1;\n   else if (!strcmp (p, \"-Wselector\"))\n     warn_selector = 1;\n@@ -8632,3 +8618,26 @@ lookup_objc_ivar (id)\n   else\n     return 0;\n }\n+\n+/* Parser callbacks.  */\n+void\n+forget_protocol_qualifiers ()\n+{\n+  C_IS_RESERVED_WORD (ridpointers[(int) RID_IN]) = 0;\n+  C_IS_RESERVED_WORD (ridpointers[(int) RID_OUT]) = 0;\n+  C_IS_RESERVED_WORD (ridpointers[(int) RID_INOUT]) = 0;\n+  C_IS_RESERVED_WORD (ridpointers[(int) RID_BYCOPY]) = 0;\n+  C_IS_RESERVED_WORD (ridpointers[(int) RID_BYREF]) = 0;\n+  C_IS_RESERVED_WORD (ridpointers[(int) RID_ONEWAY]) = 0;\n+}\n+\n+void\n+remember_protocol_qualifiers ()\n+{\n+  C_IS_RESERVED_WORD (ridpointers[(int) RID_IN]) = 1;\n+  C_IS_RESERVED_WORD (ridpointers[(int) RID_OUT]) = 1;\n+  C_IS_RESERVED_WORD (ridpointers[(int) RID_INOUT]) = 1;\n+  C_IS_RESERVED_WORD (ridpointers[(int) RID_BYCOPY]) = 1;\n+  C_IS_RESERVED_WORD (ridpointers[(int) RID_BYREF]) = 1;\n+  C_IS_RESERVED_WORD (ridpointers[(int) RID_ONEWAY]) = 1;\n+}"}, {"sha": "17f824afca6c30d2bf6c2e9901d0cbdfa9ac7aed", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -1,3 +1,16 @@\n+2000-09-06  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* g++.old-deja/g++.benjamin/13478.C: Put meaningful tags on\n+\tERROR markers.\n+\t* g++.old-deja/g++.brendan/crash8.C: Move ERROR marker up one line.\n+\t* gcc.dg/c99-array-nonobj-1.c: Don't expect func[] cases to fail.\n+\t* gcc.dg/wtr-label-1.c: Don't use unconstrained .* in error regexps.\n+\t* gcc.dg/wtr-suffix-1.c: Correct error regexps.\n+\t* gcc.dg/cpp/unc1.c, gcc.dg/cpp/unc2.c, gcc.dg/cpp/unc3.c:\n+\tPreprocess only.\n+\t* gcc.dg/cpp/unc4.c: Adjust line number in dg-error line.\n+\t* gcc.dg/noncompile/const-ll-1.c: Generalize error regexp.\n+\n 2000-09-06  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.old-deja/g++.pt/deduct2.C: New test.\n@@ -57,7 +70,7 @@\n \n 2000-09-01  Nathan Sidwell  <nathan@codesourcery.com>\n \n-\t* g++.old-deja/g++.other/nested4.C: New test.\t\n+\t* g++.old-deja/g++.other/nested4.C: New test.\n \n 2000-09-01  Nathan Sidwell  <nathan@codesourcery.com>\n \n@@ -315,7 +328,7 @@ Sun Aug  6 11:41:51 2000  Ovidiu Predescu  <ovidiu@cup.hp.com>\n \n 2000-08-05  Zack Weinberg  <zack@wolery.cumb.org>\n \n-\t* gcc.c-torture/execute/20000731-1.x: Delete.  \n+\t* gcc.c-torture/execute/20000731-1.x: Delete.\n \n 2000-08-04  Zack Weinberg  <zack@wolery.cumb.org>\n "}, {"sha": "55a948d938852432c4edee043f06244fb8dcc03e", "filename": "gcc/testsuite/g++.old-deja/g++.benjamin/13478.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2F13478.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2F13478.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2F13478.C?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -26,8 +26,8 @@ const hand_table Agent::table_1[] =\n {\n    {0,     &Agent::table_2},\n    {first, &Agent::foo},\n-   {last,  &(hand)Agent::foo} // ERROR - // ERROR -\n-}; // ERROR - // ERROR -\n+   {last,  &(hand)Agent::foo} // ERROR - no match\n+}; // ERROR - cannot convert\n \n \n "}, {"sha": "4de66c6d168cdc185075731ea9e4b3369bc09f3d", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/crash8.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash8.C?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -1,8 +1,8 @@\n // Build don't link: \n // GROUPS passed old-abort\n template<int a, int b>\n-class Elvis\n-{// ERROR - in template.*\n+class Elvis // ERROR - in template.*\n+{\n } ;\n \n template<int a>"}, {"sha": "12e26b48db593d219c1a218f7a4c64597d448361", "filename": "gcc/testsuite/gcc.dg/c99-array-nonobj-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-array-nonobj-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-array-nonobj-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-array-nonobj-1.c?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -21,7 +21,7 @@ void g (struct s []); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n /* { dg-error \"array\" \"struct \\[\\] arg\" { xfail *-*-* } 20 } */\n \n extern func c[]; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n-/* { dg-error \"array\" \"func \\[\\] var\" { xfail *-*-* } 23 } */\n+/* { dg-error \"array\" \"func \\[\\] var\" { target *-*-* } 23 } */\n \n void h (func []); /* { dg-bogus \"warning\" \"warning in place of error\" } */\n-/* { dg-error \"array\" \"func \\[\\] arg\" { xfail *-*-* } 26 } */\n+/* { dg-error \"array\" \"func \\[\\] arg\" { target *-*-* } 26 } */"}, {"sha": "18c306fc89ed43ecbeda2d2c283a708adb11f4d9", "filename": "gcc/testsuite/gcc.dg/cpp/unc1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Func1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Func1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Func1.c?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -1,4 +1,5 @@\n /* Tests for un-terminated conditionals: 1.  */\n+/* { dg-do preprocess } */\n \n #if 1  /* { dg-error \"unterminated\" \"unterminated #if\" } */\n "}, {"sha": "976d2b181ab8d0b1d03eea731143f74407e5bd33", "filename": "gcc/testsuite/gcc.dg/cpp/unc2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Func2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Func2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Func2.c?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -1,4 +1,5 @@\n /* Tests for unterminated conditionals: 2.  */\n+/* { dg-do preprocess } */\n \n #ifdef __sparc__  /* { dg-error \"unterminated\" \"unterminated if-elif-elif...\" } */\n sparc"}, {"sha": "d5f16f738acc283df46e5d28d37ec74cf354fcae", "filename": "gcc/testsuite/gcc.dg/cpp/unc3.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Func3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Func3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Func3.c?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -1,4 +1,5 @@\n /* Tests for unterminated conditionals: 3.  */\n+/* { dg-do preprocess } */\n \n #if 1  /* { dg-error \"#else\" \"unterminated #else\" } */\n #else"}, {"sha": "84ea6e45740a1df29288e310da8d5d0ead7d8bdc", "filename": "gcc/testsuite/gcc.dg/cpp/unc4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Func4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Func4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Func4.c?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -37,4 +37,4 @@ ignored\n \n /* dg.exp doesn't read the included files for tags, so we have to\n    do them explicitly here.  */\n-/* { dg-error \"#if\" \"unc1.c: unterminated #if\" { target *-*-* } 3 } */\n+/* { dg-error \"#if\" \"unc1.c: unterminated #if\" { target *-*-* } 4 } */"}, {"sha": "cac3af6aa76cb59a4785d6df4b80e14e1b1bb112", "filename": "gcc/testsuite/gcc.dg/noncompile/const-ll-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2Fconst-ll-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2Fconst-ll-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2Fconst-ll-1.c?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -20,5 +20,5 @@\n \n */\n \n-unsigned long long a = 1LUL; /* { dg-error \"LUL\" \"error for LUL suffix\" } */\n+unsigned long long a = 1LUL; /* { dg-error \"lul|LUL\" \"error for LUL suffix\" } */\n long long b = 1Ll; /* { dg-error \"Ll\" \"error for Ll suffix\" } */"}, {"sha": "8c7d73ac6207fb197cf0b2ce03858c538f61593b", "filename": "gcc/testsuite/gcc.dg/wtr-label-1.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-label-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-label-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-label-1.c?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -18,12 +18,12 @@ testfunc1 (int foo6)\n  foo1:\n  foo2:\n  foo3:\n- foo4: /* { dg-warning \"traditional C lacks.*`foo4' conflicts\" \"label conflicts with identifier\" } */\n- foo5: /* { dg-warning \"traditional C lacks.*`foo5' conflicts\" \"label conflicts with identifier\" } */\n- foo6: /* { dg-warning \"traditional C lacks.*`foo6' conflicts\" \"label conflicts with identifier\" } */\n- foo7: /* { dg-warning \"traditional C lacks.*`foo7' conflicts\" \"label conflicts with identifier\" } */\n- testfunc1: /* { dg-warning \"traditional C lacks.*`testfunc1' conflicts\" \"label conflicts with identifier\" } */\n- a: /* { dg-warning \"traditional C lacks.*`a' conflicts\" \"label conflicts with identifier\" } */\n+ foo4: /* { dg-warning \"traditional C lacks\" \"label conflicts with identifier\" } */\n+ foo5: /* { dg-warning \"traditional C lacks\" \"label conflicts with identifier\" } */\n+ foo6: /* { dg-warning \"traditional C lacks\" \"label conflicts with identifier\" } */\n+ foo7: /* { dg-warning \"traditional C lacks\" \"label conflicts with identifier\" } */\n+ testfunc1: /* { dg-warning \"traditional C lacks\" \"label conflicts with identifier\" } */\n+ a: /* { dg-warning \"traditional C lacks\" \"label conflicts with identifier\" } */\n  i:\n  j:\n }"}, {"sha": "056dbb7c7ec91dc8cae26c33f4469d7fc0e5482c", "filename": "gcc/testsuite/gcc.dg/wtr-suffix-1.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-suffix-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-suffix-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-suffix-1.c?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -12,14 +12,14 @@ testfunc (void)\n \n   i = 1L;\n   i = 1l;\n-  i = 1U; /* { dg-warning \"traditional C rejects the `U' suffix\" \"numeric constant suffix\" } */\n-  i = 1u; /* { dg-warning \"traditional C rejects the `u' suffix\" \"numeric constant suffix\" } */\n+  i = 1U; /* { dg-warning \"traditional C rejects the 'u' suffix\" \"numeric constant suffix\" } */\n+  i = 1u; /* { dg-warning \"traditional C rejects the 'u' suffix\" \"numeric constant suffix\" } */\n   f = 1.0;\n-  f = 1.0F; /* { dg-warning \"traditional C rejects the `F' suffix\" \"numeric constant suffix\" } */\n-  f = 1.0f; /* { dg-warning \"traditional C rejects the `f' suffix\" \"numeric constant suffix\" } */\n-  f = 1.0L; /* { dg-warning \"traditional C rejects the `L' suffix\" \"numeric constant suffix\" } */\n-  f = 1.0l; /* { dg-warning \"traditional C rejects the `l' suffix\" \"numeric constant suffix\" } */\n-  \n+  f = 1.0F; /* { dg-warning \"traditional C rejects the 'f' suffix\" \"numeric constant suffix\" } */\n+  f = 1.0f; /* { dg-warning \"traditional C rejects the 'f' suffix\" \"numeric constant suffix\" } */\n+  f = 1.0L; /* { dg-warning \"traditional C rejects the 'l' suffix\" \"numeric constant suffix\" } */\n+  f = 1.0l; /* { dg-warning \"traditional C rejects the 'l' suffix\" \"numeric constant suffix\" } */\n+ \n #line 24 \"sys-header.h\" 3\n /* We are in system headers now, no -Wtraditional warnings should issue.  */\n "}, {"sha": "8205caa3a8a697e87e4420a714324b868b582fd6", "filename": "gcc/timevar.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -40,6 +40,8 @@ DEFTIMEVAR (TV_GC                    , \"garbage collection\")\n DEFTIMEVAR (TV_DUMP                  , \"dump files\")\n \n /* Timing in various stages of the compiler.  */\n+DEFTIMEVAR (TV_CPP\t\t     , \"preprocessing\")\n+DEFTIMEVAR (TV_LEX\t\t     , \"lexical analysis\")\n DEFTIMEVAR (TV_PARSE                 , \"parser\")\n DEFTIMEVAR (TV_EXPAND\t\t     , \"expand\")\n DEFTIMEVAR (TV_VARCONST              , \"varconst\")"}, {"sha": "e20a26e5293c391c5d611c8dd377b0279e2f1945", "filename": "gcc/timevar.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftimevar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftimevar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.h?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -19,6 +19,9 @@\n    the Free Software Foundation, 59 Temple Place - Suite 330,\n    Boston, MA 02111-1307, USA.  */\n \n+#ifndef GCC_TIMEVAR_H\n+#define GCC_TIMEVAR_H\n+\n /* Timing variables are used to measure elapsed time in various\n    portions of the compiler.  Each measures elapsed user, system, and\n    wall-clock time, as appropriate to and supported by the host\n@@ -84,3 +87,5 @@ extern void timevar_print PARAMS ((FILE *));\n /* Provided for backward compatibility.  */\n extern long get_run_time PARAMS ((void));\n extern void print_time PARAMS ((const char *, long));\n+\n+#endif"}, {"sha": "b590eee28017f5bf056da24ae3c1167855d8c65e", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e5921e8a0f347a7de29c7347738db8de5769a88/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=0e5921e8a0f347a7de29c7347738db8de5769a88", "patch": "@@ -477,6 +477,10 @@ int time_report = 0;\n \n int mem_report = 0;\n \n+/* Non-zero means to collect statistics which might be expensive\n+   and to print them when we are done.  */\n+int flag_detailed_statistics = 0;\n+\n \f\n /* -f flags.  */\n "}]}