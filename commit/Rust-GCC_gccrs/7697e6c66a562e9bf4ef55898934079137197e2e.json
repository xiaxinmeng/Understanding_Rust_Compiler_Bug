{"sha": "7697e6c66a562e9bf4ef55898934079137197e2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY5N2U2YzY2YTU2MmU5YmY0ZWY1NTg5ODkzNDA3OTEzNzE5N2UyZQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2005-11-18T11:50:22Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2005-11-18T11:50:22Z"}, "message": "rc_string_base.h (__rc_string_base<>::_Rep): Avoid the anonymous struct extension, adjust everywhere.\n\n2005-11-18  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/ext/rc_string_base.h (__rc_string_base<>::_Rep): Avoid the\n\tanonymous struct extension, adjust everywhere.\n\n\t* include/ext/rc_string_base.h (__rc_string_base<>::_S_empty_rep()):\n\tJust use a static member.\n\t(__rc_string_base<>::__rc_string_base(), _S_construct): Adjust.\n\n\t* include/ext/rc_string_base.h (__rc_string_base<>::_Rep): Use anonymous\n\tunion together with _CharT to fix alignment issues, rebind to _Rep and\n\trename _Raw_alloc to _Rep_alloc_type.\n\t(__rc_string_base<>::_Rep::_S_create, _M_destroy): Adjust consistently.\n\n\t* include/ext/vstring_util.h (__is_null_p): Move inside struct\n\t__vstring_utility as static _S_is_null_pointer.\n\t* include/ext/sso_string.h\n\t(__sso_string_base<>::_M_construct(std::forward_iterator_tag): Adjust.\n\t* include/ext/rc_string_base.h\n\t(__rc_string_base<>::_S_construct(std::forward_iterator_tag): Likewise.\n\n\tImplement Option 3 of DR 431 for ext/vstring - both available bases.\n\t* include/bits/cpp_type_traits.h (struct __is_empty): Add.\n\t* include/ext/vstring.h (__versa_string<>::swap): Delegate to\n\tthis->_M_swap.\n\t* include/ext/vstring.tcc (__versa_string<>::swap): Remove.\n\t* include/ext/vstring_util.h (struct __vstring_utility<>): Add struct\n\t_Alloc_hider<>, augmented of allocator swapping facility, specialized\n\tto nop for empty allocators.\n\t* include/ext/rc_string_base.h (__rc_string_base<>::_M_swap): Use it.\n\t(__rc_string_base<>::_M_is_leaked, _M_set_sharable): Change to private.\n\t* include/ext/sso_string_base.h\t(__sso_string_base<>::_M_swap):\n\tLikewise.\n\t(__sso_string_base<>::_M_is_leaked, _M_set_sharable): Remove, unused.\t\n\n\t* include/ext/rc_string_base.h (__rc_string_base<>::_M_data(_CharT*):\n\tReturn void.\n\t* include/ext/sso_string_base.h (__sso_string_base<>::_M_data(_CharT*):\n\tLikewise.\n\nFrom-SVN: r107176", "tree": {"sha": "a5bf3fa64144b286d112a9a48c5f870a8aa71dc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5bf3fa64144b286d112a9a48c5f870a8aa71dc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7697e6c66a562e9bf4ef55898934079137197e2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7697e6c66a562e9bf4ef55898934079137197e2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7697e6c66a562e9bf4ef55898934079137197e2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7697e6c66a562e9bf4ef55898934079137197e2e/comments", "author": null, "committer": null, "parents": [{"sha": "e0709888ef53405b609913dfe1c9bd4ff0ec750e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0709888ef53405b609913dfe1c9bd4ff0ec750e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0709888ef53405b609913dfe1c9bd4ff0ec750e"}], "stats": {"total": 372, "additions": 218, "deletions": 154}, "files": [{"sha": "9b6a0b0a3e022c70af254f126b2fb4bee5df03a5", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7697e6c66a562e9bf4ef55898934079137197e2e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7697e6c66a562e9bf4ef55898934079137197e2e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7697e6c66a562e9bf4ef55898934079137197e2e", "patch": "@@ -1,3 +1,43 @@\n+2005-11-18  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/ext/rc_string_base.h (__rc_string_base<>::_Rep): Avoid the\n+\tanonymous struct extension, adjust everywhere.\n+\n+\t* include/ext/rc_string_base.h (__rc_string_base<>::_S_empty_rep()):\n+\tJust use a static member.\n+\t(__rc_string_base<>::__rc_string_base(), _S_construct): Adjust.\n+\n+\t* include/ext/rc_string_base.h (__rc_string_base<>::_Rep): Use anonymous\n+\tunion together with _CharT to fix alignment issues, rebind to _Rep and\n+\trename _Raw_alloc to _Rep_alloc_type.\n+\t(__rc_string_base<>::_Rep::_S_create, _M_destroy): Adjust consistently.\n+\n+\t* include/ext/vstring_util.h (__is_null_p): Move inside struct\n+\t__vstring_utility as static _S_is_null_pointer.\n+\t* include/ext/sso_string.h\n+\t(__sso_string_base<>::_M_construct(std::forward_iterator_tag): Adjust.\n+\t* include/ext/rc_string_base.h\n+\t(__rc_string_base<>::_S_construct(std::forward_iterator_tag): Likewise.\n+\n+\tImplement Option 3 of DR 431 for ext/vstring - both available bases.\n+\t* include/bits/cpp_type_traits.h (struct __is_empty): Add.\n+\t* include/ext/vstring.h (__versa_string<>::swap): Delegate to\n+\tthis->_M_swap.\n+\t* include/ext/vstring.tcc (__versa_string<>::swap): Remove.\n+\t* include/ext/vstring_util.h (struct __vstring_utility<>): Add struct\n+\t_Alloc_hider<>, augmented of allocator swapping facility, specialized\n+\tto nop for empty allocators.\n+\t* include/ext/rc_string_base.h (__rc_string_base<>::_M_swap): Use it.\n+\t(__rc_string_base<>::_M_is_leaked, _M_set_sharable): Change to private.\n+\t* include/ext/sso_string_base.h\t(__sso_string_base<>::_M_swap):\n+\tLikewise.\n+\t(__sso_string_base<>::_M_is_leaked, _M_set_sharable): Remove, unused.\t\n+\n+\t* include/ext/rc_string_base.h (__rc_string_base<>::_M_data(_CharT*):\n+\tReturn void.\n+\t* include/ext/sso_string_base.h (__sso_string_base<>::_M_data(_CharT*):\n+\tLikewise.\n+\n 2005-11-17  Geoffrey Keating  <geoffk@apple.com>\n \n \t* config/os/bsd/darwin/ppc-extra.ver: New."}, {"sha": "5ac9c98e704dda399d45570f1a99b548f517793f", "filename": "libstdc++-v3/include/bits/cpp_type_traits.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7697e6c66a562e9bf4ef55898934079137197e2e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7697e6c66a562e9bf4ef55898934079137197e2e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h?ref=7697e6c66a562e9bf4ef55898934079137197e2e", "patch": "@@ -364,6 +364,26 @@ namespace std\n \t};\n     };\n \n+  //\n+  // A stripped-down version of std::tr1::is_empty\n+  //\n+  template<typename _Tp>\n+    struct __is_empty\n+    { \n+    private:\n+      template<typename>\n+        struct __first { };\n+      template<typename _Up>\n+        struct __second\n+        : public _Up { };\n+           \n+    public:\n+      enum\n+\t{\n+\t  __value = sizeof(__first<_Tp>) == sizeof(__second<_Tp>)\n+\t};\n+    };\n+\n } // namespace std\n \n #endif //_CPP_TYPE_TRAITS_H"}, {"sha": "58994222eae5d7ee3ea6d6487822400a4afa5411", "filename": "libstdc++-v3/include/ext/rc_string_base.h", "status": "modified", "additions": 95, "deletions": 86, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7697e6c66a562e9bf4ef55898934079137197e2e/libstdc%2B%2B-v3%2Finclude%2Fext%2Frc_string_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7697e6c66a562e9bf4ef55898934079137197e2e/libstdc%2B%2B-v3%2Finclude%2Fext%2Frc_string_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Frc_string_base.h?ref=7697e6c66a562e9bf4ef55898934079137197e2e", "patch": "@@ -92,8 +92,8 @@ namespace __gnu_cxx\n       typedef typename _Traits::char_type\t\t    value_type;\n       typedef _Alloc\t\t\t\t\t    allocator_type;\n \n-      typedef typename __vstring_utility<_CharT, _Traits, _Alloc>::\n-        _CharT_alloc_type                                   _CharT_alloc_type;\n+      typedef __vstring_utility<_CharT, _Traits, _Alloc>    _Util_Base;\n+      typedef typename _Util_Base::_CharT_alloc_type        _CharT_alloc_type;\n       typedef typename _CharT_alloc_type::size_type\t    size_type;\n \n     private:\n@@ -107,16 +107,25 @@ namespace __gnu_cxx\n       //      -1: leaked, one reference, no ref-copies allowed, non-const.\n       //       0: one reference, non-const.\n       //     n>0: n + 1 references, operations require a lock, const.\n-      //   4. All fields==0 is an empty string, given the extra storage\n+      //   4. All fields == 0 is an empty string, given the extra storage\n       //      beyond-the-end for a null terminator; thus, the shared\n       //      empty string representation needs no constructor.\n       struct _Rep\n       {\n-\tsize_type\t\t_M_length;\n-\tsize_type\t\t_M_capacity;\n-\t_Atomic_word\t\t_M_refcount;\n+\tunion\n+\t{\n+\t  struct\n+\t  {\n+\t    size_type\t    _M_length;\n+\t    size_type\t    _M_capacity;\n+\t    _Atomic_word    _M_refcount;\n+\t  }                 _M_info;\n+\t  \n+\t  // Only for alignment purposes.\n+\t  _CharT            _M_align;\n+\t};\n \n-\ttypedef typename _Alloc::template rebind<size_type>::other _Raw_alloc;\n+\ttypedef typename _Alloc::template rebind<_Rep>::other _Rep_alloc_type;\n \n  \t_CharT*\n \t_M_refdata() throw()\n@@ -125,15 +134,15 @@ namespace __gnu_cxx\n \t_CharT*\n \t_M_refcopy() throw()\n \t{\n-\t  __atomic_add(&_M_refcount, 1);\n+\t  __atomic_add(&_M_info._M_refcount, 1);\n \t  return _M_refdata();\n \t}  // XXX MT\n \t\n \tvoid\n \t_M_set_length(size_type __n)\n \t{ \n-\t  _M_refcount = 0;  // One reference.\n-\t  _M_length = __n;\n+\t  _M_info._M_refcount = 0;  // One reference.\n+\t  _M_info._M_length = __n;\n \t  // grrr. (per 21.3.4)\n \t  // You cannot leave those LWG people alone for a second.\n \t  traits_type::assign(_M_refdata()[__n], _CharT());\n@@ -150,11 +159,14 @@ namespace __gnu_cxx\n \t_M_clone(const _Alloc&, size_type __res = 0);\n       };\n \n-      struct _Rep_empty : _Rep\n+      struct _Rep_empty\n+      : public _Rep\n       {\n-\t_CharT                  _M_terminal;\n+\t_CharT              _M_terminal;\n       };\n \n+      static _Rep_empty     _S_empty_rep;\n+\n       // The maximum number of individual char_type elements of an\n       // individual string is determined by _S_max_size. This is the\n       // value that will be returned by max_size().  (Whereas npos\n@@ -169,28 +181,12 @@ namespace __gnu_cxx\n       enum { _S_max_size = (((static_cast<size_type>(-1) - sizeof(_Rep))\n \t\t\t     / sizeof(_CharT)) - 1) / 4 };\n \n-      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html\n-      struct _Alloc_hider : _Alloc\n-      {\n-\t_Alloc_hider(_CharT* __dat, const _Alloc& __a)\n-\t: _Alloc(__a), _M_p(__dat) { }\n-\n-\t_CharT* _M_p; // The actual data.\n-      };\n-\n       // Data Member (private):\n-      mutable _Alloc_hider\t_M_dataplus;\n-\n-      static _Rep_empty&\n-      _S_empty_rep()\n-      {\n-\tstatic _Rep_empty _Empty_rep;\n-\treturn _Empty_rep;\n-      }\n+      mutable typename _Util_Base::template _Alloc_hider<_Alloc>  _M_dataplus;\n \n-      _CharT*\n+      void\n       _M_data(_CharT* __p)\n-      { return (_M_dataplus._M_p = __p); }\n+      { _M_dataplus._M_p = __p; }\n \n       _Rep*\n       _M_rep() const\n@@ -206,15 +202,23 @@ namespace __gnu_cxx\n       void\n       _M_dispose(const _Alloc& __a)\n       {\n-\tif (__exchange_and_add(&_M_rep()->_M_refcount, -1) <= 0)\n+\tif (__exchange_and_add(&_M_rep()->_M_info._M_refcount, -1) <= 0)\n \t  _M_rep()->_M_destroy(__a);\n       }  // XXX MT\n \n+      bool\n+      _M_is_leaked() const\n+      { return _M_rep()->_M_info._M_refcount < 0; }\n+\n+      void\n+      _M_set_sharable()\n+      { _M_rep()->_M_info._M_refcount = 0; }\n+\n       void\n       _M_leak_hard();\n \n       // _S_construct_aux is used to implement the 21.3.1 para 15 which\n-      // requires special behaviour if _InIter is an integral type\n+      // requires special behaviour if _InIterator is an integral type\n       template<class _InIterator>\n         static _CharT*\n         _S_construct_aux(_InIterator __beg, _InIterator __end,\n@@ -266,31 +270,19 @@ namespace __gnu_cxx\n \n       size_type\n       _M_length() const\n-      { return _M_rep()->_M_length; }\n+      { return _M_rep()->_M_info._M_length; }\n \n       size_type\n       _M_capacity() const\n-      { return _M_rep()->_M_capacity; }\n+      { return _M_rep()->_M_info._M_capacity; }\n \n       bool\n       _M_is_shared() const\n-      { return _M_rep()->_M_refcount > 0; }\n-\n-      bool\n-      _M_is_leaked() const\n-      { return _M_rep()->_M_refcount < 0; }\n-\n-      void\n-      _M_set_sharable()\n-      { _M_rep()->_M_refcount = 0; }\n+      { return _M_rep()->_M_info._M_refcount > 0; }\n \n       void\n       _M_set_leaked()\n-      { _M_rep()->_M_refcount = -1; }\n-\n-      void\n-      _M_set_length(size_type __n)\n-      { _M_rep()->_M_set_length(__n); }\n+      { _M_rep()->_M_info._M_refcount = -1; }\n \n       void\n       _M_leak()    // for use in begin() & non-const op[]\n@@ -299,8 +291,12 @@ namespace __gnu_cxx\n \t  _M_leak_hard();\n       }\n \n+      void\n+      _M_set_length(size_type __n)\n+      { _M_rep()->_M_set_length(__n); }\n+\n       __rc_string_base()\n-      : _M_dataplus(_S_empty_rep()._M_refcopy(), _Alloc()) { }\n+      : _M_dataplus(_Alloc(), _S_empty_rep._M_refcopy()) { }\n \n       __rc_string_base(const _Alloc& __a);\n \n@@ -310,7 +306,7 @@ namespace __gnu_cxx\n \n       template<typename _InputIterator>\n         __rc_string_base(_InputIterator __beg, _InputIterator __end,\n-\t\t    const _Alloc& __a);\n+\t\t\t const _Alloc& __a);\n \n       ~__rc_string_base()\n       { _M_dispose(_M_get_allocator()); }      \n@@ -320,12 +316,7 @@ namespace __gnu_cxx\n       { return _M_dataplus; }\n \n       void\n-      _M_swap(__rc_string_base& __rcs)\n-      {\n-\t_CharT* __tmp = _M_data();\n-\t_M_data(__rcs._M_data());\n-\t__rcs._M_data(__tmp);\n-      }\n+      _M_swap(__rc_string_base& __rcs);\n \n       void\n       _M_assign(const __rc_string_base& __rcs);\n@@ -337,6 +328,10 @@ namespace __gnu_cxx\n       _M_mutate(size_type __pos, size_type __len1, size_type __len2);\n     };\n \n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    typename __rc_string_base<_CharT, _Traits, _Alloc>::_Rep_empty\n+    __rc_string_base<_CharT, _Traits, _Alloc>::_S_empty_rep;\n+\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     typename __rc_string_base<_CharT, _Traits, _Alloc>::_Rep*\n     __rc_string_base<_CharT, _Traits, _Alloc>::_Rep::\n@@ -388,8 +383,8 @@ namespace __gnu_cxx\n       // plus sizeof(size_type) - 1 to upper round to a size multiple\n       // of sizeof(size_type).\n       // Whew. Seemingly so needy, yet so elemental.\n-      size_type __size = ((__capacity + 1) * sizeof(_CharT) + sizeof(_Rep)\n-\t\t\t  + sizeof(size_type) - 1);\n+      size_type __size = ((__capacity + 1) * sizeof(_CharT)\n+\t\t\t  + 2 * sizeof(_Rep) - 1);\n \n       const size_type __adj_size = __size + __malloc_header_size;\n       if (__adj_size > __pagesize && __capacity > __old_capacity)\n@@ -399,16 +394,14 @@ namespace __gnu_cxx\n \t  // Never allocate a string bigger than _S_max_size.\n \t  if (__capacity > size_type(_S_max_size))\n \t    __capacity = size_type(_S_max_size);\n-\t  __size = ((__capacity + 1) * sizeof(_CharT) + sizeof(_Rep)\n-\t\t    + sizeof(size_type) - 1);\n+\t  __size = (__capacity + 1) * sizeof(_CharT) + 2 * sizeof(_Rep) - 1;\n \t}\n \n       // NB: Might throw, but no worries about a leak, mate: _Rep()\n       // does not throw.\n-      void* __place = _Raw_alloc(__alloc).allocate(__size\n-\t\t\t\t\t\t   / sizeof(size_type));\n-      _Rep *__p = new (__place) _Rep;\n-      __p->_M_capacity = __capacity;\n+      _Rep* __place = _Rep_alloc_type(__alloc).allocate(__size / sizeof(_Rep));\n+      _Rep* __p = new (__place) _Rep;\n+      __p->_M_info._M_capacity = __capacity;\n       return __p;\n     }\n \n@@ -417,10 +410,9 @@ namespace __gnu_cxx\n     __rc_string_base<_CharT, _Traits, _Alloc>::_Rep::\n     _M_destroy(const _Alloc& __a) throw ()\n     {\n-      const size_type __size = ((_M_capacity + 1) * sizeof(_CharT)\n-\t\t\t\t+ sizeof(_Rep) + sizeof(size_type) - 1);\n-      _Raw_alloc(__a).deallocate(reinterpret_cast<size_type*>(this),\n-\t\t\t\t __size / sizeof(size_type));\n+      const size_type __size = ((_M_info._M_capacity + 1) * sizeof(_CharT)\n+\t\t\t\t+ 2 * sizeof(_Rep) - 1);\n+      _Rep_alloc_type(__a).deallocate(this, __size / sizeof(_Rep));\n     }\n \n   template<typename _CharT, typename _Traits, typename _Alloc>\n@@ -429,41 +421,40 @@ namespace __gnu_cxx\n     _M_clone(const _Alloc& __alloc, size_type __res)\n     {\n       // Requested capacity of the clone.\n-      const size_type __requested_cap = _M_length + __res;\n-      _Rep* __r = _Rep::_S_create(__requested_cap, _M_capacity, __alloc);\n+      const size_type __requested_cap = _M_info._M_length + __res;\n+      _Rep* __r = _Rep::_S_create(__requested_cap, _M_info._M_capacity,\n+\t\t\t\t  __alloc);\n \n-      if (_M_length)\n-\t_S_copy(__r->_M_refdata(), _M_refdata(), _M_length);\n+      if (_M_info._M_length)\n+\t_S_copy(__r->_M_refdata(), _M_refdata(), _M_info._M_length);\n \n-      __r->_M_set_length(_M_length);\n+      __r->_M_set_length(_M_info._M_length);\n       return __r->_M_refdata();\n     }\n \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     __rc_string_base<_CharT, _Traits, _Alloc>::\n     __rc_string_base(const _Alloc& __a)\n-    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a) { }\n+    : _M_dataplus(__a, _S_construct(size_type(), _CharT(), __a)) { }\n \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     __rc_string_base<_CharT, _Traits, _Alloc>::\n     __rc_string_base(const __rc_string_base& __rcs)\n-    : _M_dataplus(__rcs._M_grab(_Alloc(__rcs._M_get_allocator()),\n-\t\t\t\t__rcs._M_get_allocator()),\n-\t\t  __rcs._M_get_allocator()) { }\n+    : _M_dataplus(__rcs._M_get_allocator(),\n+\t\t  __rcs._M_grab(_Alloc(__rcs._M_get_allocator()),\n+\t\t\t\t__rcs._M_get_allocator())) { }\n \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     __rc_string_base<_CharT, _Traits, _Alloc>::\n     __rc_string_base(size_type __n, _CharT __c, const _Alloc& __a)\n-    : _M_dataplus(_S_construct(__n, __c, __a), __a)\n-    { }\n+    : _M_dataplus(__a, _S_construct(__n, __c, __a)) { }\n \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     template<typename _InputIterator>\n     __rc_string_base<_CharT, _Traits, _Alloc>::\n     __rc_string_base(_InputIterator __beg, _InputIterator __end,\n \t\t     const _Alloc& __a)\n-    : _M_dataplus(_S_construct(__beg, __end, __a), __a)\n-    { }\n+    : _M_dataplus(__a, _S_construct(__beg, __end, __a)) { }\n \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     void\n@@ -487,7 +478,7 @@ namespace __gnu_cxx\n \t\t   std::input_iterator_tag)\n       {\n \tif (__beg == __end && __a == _Alloc())\n-\t  return _S_empty_rep()._M_refcopy();\n+\t  return _S_empty_rep._M_refcopy();\n \n \t// Avoid reallocation for common case.\n \t_CharT __buf[128];\n@@ -532,10 +523,10 @@ namespace __gnu_cxx\n \t\t   std::forward_iterator_tag)\n       {\n \tif (__beg == __end && __a == _Alloc())\n-\t  return _S_empty_rep()._M_refcopy();\n+\t  return _S_empty_rep._M_refcopy();\n \n \t// NB: Not required, but considered best practice.\n-\tif (__builtin_expect(__is_null_p(__beg) && __beg != __end, 0))\n+\tif (__builtin_expect(_S_is_null_pointer(__beg) && __beg != __end, 0))\n \t  std::__throw_logic_error(__N(\"__rc_string_base::\"\n \t\t\t\t       \"_S_construct NULL not valid\"));\n \n@@ -560,7 +551,7 @@ namespace __gnu_cxx\n     _S_construct(size_type __n, _CharT __c, const _Alloc& __a)\n     {\n       if (__n == 0 && __a == _Alloc())\n-\treturn _S_empty_rep()._M_refcopy();\n+\treturn _S_empty_rep._M_refcopy();\n \n       // Check for out_of_range and length_error exceptions.\n       _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);\n@@ -571,6 +562,24 @@ namespace __gnu_cxx\n       return __r->_M_refdata();\n     }\n \n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    void\n+    __rc_string_base<_CharT, _Traits, _Alloc>::\n+    _M_swap(__rc_string_base& __rcs)\n+    {\n+      if (_M_is_leaked())\n+\t_M_set_sharable();\n+      if (__rcs._M_is_leaked())\n+\t__rcs._M_set_sharable();\n+      \n+      _CharT* __tmp = _M_data();\n+      _M_data(__rcs._M_data());\n+      __rcs._M_data(__tmp);\n+      \n+      // NB: Implement Option 3 of DR 431 (see N1599).\n+      _M_dataplus._M_alloc_swap(__rcs._M_dataplus);\n+    } \n+\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     void\n     __rc_string_base<_CharT, _Traits, _Alloc>::"}, {"sha": "bd29413eb8325f9d0334775f0a8ce3d46ea6f235", "filename": "libstdc++-v3/include/ext/sso_string_base.h", "status": "modified", "additions": 13, "deletions": 32, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7697e6c66a562e9bf4ef55898934079137197e2e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fsso_string_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7697e6c66a562e9bf4ef55898934079137197e2e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fsso_string_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fsso_string_base.h?ref=7697e6c66a562e9bf4ef55898934079137197e2e", "patch": "@@ -47,8 +47,8 @@ namespace __gnu_cxx\n       typedef typename _Traits::char_type\t\t    value_type;\n       typedef _Alloc\t\t\t\t\t    allocator_type;\n \n-      typedef typename __vstring_utility<_CharT, _Traits, _Alloc>::\n-        _CharT_alloc_type                                   _CharT_alloc_type;\n+      typedef __vstring_utility<_CharT, _Traits, _Alloc>    _Util_Base;\n+      typedef typename _Util_Base::_CharT_alloc_type        _CharT_alloc_type;\n       typedef typename _CharT_alloc_type::size_type\t    size_type;\n       \n     private:\n@@ -66,18 +66,9 @@ namespace __gnu_cxx\n       enum { _S_max_size = (((static_cast<size_type>(-1)\n \t\t\t      / sizeof(_CharT)) - 1) / 4) };\n \n-      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html\n-      struct _Alloc_hider : _Alloc\n-      {\n-\t_Alloc_hider(const _Alloc& __a, _CharT* __ptr)\n-\t: _Alloc(__a), _M_p(__ptr) { }\n-\n-\t_CharT* _M_p; // The actual data.\n-      };\n-\n       // Data Members (private):\n-      _Alloc_hider\t        _M_dataplus;\n-      size_type                 _M_string_length;\n+      typename _Util_Base::template _Alloc_hider<_Alloc>    _M_dataplus;\n+      size_type                                             _M_string_length;\n \n       enum { _S_local_capacity = 15 };\n       \n@@ -87,9 +78,9 @@ namespace __gnu_cxx\n \tsize_type               _M_allocated_capacity;\n       };\n \n-      _CharT*\n+      void\n       _M_data(_CharT* __p)\n-      { return (_M_dataplus._M_p = __p); }\n+      { _M_dataplus._M_p = __p; }\n \n       void\n       _M_length(size_type __length)\n@@ -118,7 +109,7 @@ namespace __gnu_cxx\n       _M_destroy(size_type) throw();\n \n       // _M_construct_aux is used to implement the 21.3.1 para 15 which\n-      // requires special behaviour if _InIter is an integral type\n+      // requires special behaviour if _InIterator is an integral type\n       template<class _InIterator>\n         void\n         _M_construct_aux(_InIterator __beg, _InIterator __end, __false_type)\n@@ -181,28 +172,19 @@ namespace __gnu_cxx\n       _M_is_shared() const\n       { return false; }\n \n-      bool\n-      _M_is_leaked() const\n-      { return false; }\n-\n       void\n-      _M_set_sharable() { }\n+      _M_set_leaked() { }\n \n       void\n-      _M_set_leaked() { }\n+      _M_leak() { }\n \n       void\n       _M_set_length(size_type __n)\n       {\n \t_M_length(__n);\n-\t// grrr. (per 21.3.4)\n-\t// You cannot leave those LWG people alone for a second.\n \ttraits_type::assign(_M_data()[__n], _CharT());\n       }\n \n-      void\n-      _M_leak() { }\n-\n       __sso_string_base()\n       : _M_dataplus(_Alloc(), _M_local_data)\n       { _M_set_length(0); }\n@@ -248,6 +230,9 @@ namespace __gnu_cxx\n     __sso_string_base<_CharT, _Traits, _Alloc>::\n     _M_swap(__sso_string_base& __rcs)\n     {\n+      // NB: Implement Option 3 of DR 431 (see N1599).\n+      _M_dataplus._M_alloc_swap(__rcs._M_dataplus);\n+\n       if (_M_is_local())\n \tif (__rcs._M_is_local())\n \t  {\n@@ -325,9 +310,6 @@ namespace __gnu_cxx\n       // The below implements an exponential growth policy, necessary to\n       // meet amortized linear time requirements of the library: see\n       // http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.\n-      // It's active for allocations requiring an amount of memory above\n-      // system pagesize. This is consistent with the requirements of the\n-      // standard: http://gcc.gnu.org/ml/libstdc++/2001-07/msg00130.html\n       if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)\n \t__capacity = 2 * __old_capacity;\n \n@@ -373,7 +355,6 @@ namespace __gnu_cxx\n       _M_construct(_InIterator __beg, _InIterator __end,\n \t\t   std::input_iterator_tag)\n       {\n-\t// Avoid reallocation for common case.\n \tsize_type __len = 0;\n \tsize_type __capacity = size_type(_S_local_capacity);\n \n@@ -418,7 +399,7 @@ namespace __gnu_cxx\n \t\t   std::forward_iterator_tag)\n       {\n \t// NB: Not required, but considered best practice.\n-\tif (__builtin_expect(__is_null_p(__beg) && __beg != __end, 0))\n+\tif (__builtin_expect(_S_is_null_pointer(__beg) && __beg != __end, 0))\n \t  std::__throw_logic_error(__N(\"__sso_string_base::\"\n \t\t\t\t       \"_M_construct NULL not valid\"));\n "}, {"sha": "1aaa87665e7984cb9b28b3fda66a46e4c0691629", "filename": "libstdc++-v3/include/ext/vstring.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7697e6c66a562e9bf4ef55898934079137197e2e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fvstring.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7697e6c66a562e9bf4ef55898934079137197e2e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fvstring.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fvstring.h?ref=7697e6c66a562e9bf4ef55898934079137197e2e", "patch": "@@ -1214,7 +1214,8 @@ namespace __gnu_cxx\n        *  time.\n       */\n       void\n-      swap(__versa_string& __s);\n+      swap(__versa_string& __s)\n+      { this->_M_swap(__s); }\n \n       // String operations:\n       /**"}, {"sha": "76fa96bcbd3427800db45ffaeae65125390e2145", "filename": "libstdc++-v3/include/ext/vstring.tcc", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7697e6c66a562e9bf4ef55898934079137197e2e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fvstring.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7697e6c66a562e9bf4ef55898934079137197e2e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fvstring.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fvstring.tcc?ref=7697e6c66a562e9bf4ef55898934079137197e2e", "patch": "@@ -218,30 +218,6 @@ namespace __gnu_cxx\n \t }\n      }\n \n-  template<typename _CharT, typename _Traits, typename _Alloc,\n-\t   template <typename, typename, typename> class _Base>\n-    void\n-    __versa_string<_CharT, _Traits, _Alloc, _Base>::\n-    swap(__versa_string& __s)\n-    {\n-      if (this->_M_is_leaked())\n-\tthis->_M_set_sharable();\n-      if (__s._M_is_leaked())\n-\t__s._M_set_sharable();\n-      if (this->get_allocator() == __s.get_allocator())\n-\tthis->_M_swap(__s);\n-      // The code below can usually be optimized away.\n-      else\n-\t{\n-\t  const __versa_string __tmp1(_M_ibegin(), _M_iend(),\n-\t\t\t\t      __s.get_allocator());\n-\t  const __versa_string __tmp2(__s._M_ibegin(), __s._M_iend(),\n-\t\t\t\t      this->get_allocator());\n-\t  *this = __tmp2;\n-\t  __s = __tmp1;\n-\t}\n-    }\n-\n   template<typename _CharT, typename _Traits, typename _Alloc,\n \t   template <typename, typename, typename> class _Base>\n     void"}, {"sha": "2a53fbdd4bd28cedd3860dfb8a117aeb727fa004", "filename": "libstdc++-v3/include/ext/vstring_util.h", "status": "modified", "additions": 48, "deletions": 11, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7697e6c66a562e9bf4ef55898934079137197e2e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fvstring_util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7697e6c66a562e9bf4ef55898934079137197e2e/libstdc%2B%2B-v3%2Finclude%2Fext%2Fvstring_util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fvstring_util.h?ref=7697e6c66a562e9bf4ef55898934079137197e2e", "patch": "@@ -1,4 +1,4 @@\n-// Versatile string utilities -*- C++ -*-\n+// Versatile string utility -*- C++ -*-\n \n // Copyright (C) 2005 Free Software Foundation, Inc.\n //\n@@ -47,16 +47,6 @@\n \n namespace __gnu_cxx\n {\n-  template<typename _Type>\n-    inline bool\n-    __is_null_p(_Type* __ptr)\n-    { return __ptr == 0; }\n-\n-  template<typename _Type>\n-    inline bool\n-    __is_null_p(_Type)\n-    { return false; }\n-\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     struct __vstring_utility\n     {\n@@ -92,6 +82,53 @@ namespace __gnu_cxx\n \t\t\t\t       __rc_string_base> >\n         __const_rc_iterator;\n \n+      // NB:  When the allocator is empty, deriving from it saves space \n+      // (http://www.cantrip.org/emptyopt.html).  We do that anyway for\n+      // consistency.\n+      template<typename _Alloc1, bool = std::__is_empty<_Alloc1>::__value>\n+        struct _Alloc_hider\n+\t: public _Alloc1\n+\t{\n+\t  _Alloc_hider(const _Alloc1& __a, _CharT* __ptr)\n+\t  : _Alloc1(__a), _M_p(__ptr) { }\n+\n+\t  void\n+\t  _M_alloc_swap(_Alloc_hider& __ah)\n+\t  {\n+\t    // Implement Option 3 of DR 431 (see N1599).\n+\t    // Precondition: swappable allocators.\n+\t    _Alloc1& __this = static_cast<_Alloc1&>(*this);\n+\t    _Alloc1& __that = static_cast<_Alloc1&>(__ah);\n+\t    if (__this != __that)\n+\t      swap(__this, __that);\n+\t  }\n+\n+\t  _CharT*  _M_p; // The actual data.\n+\t};\n+\n+      template<typename _Alloc1>\n+        struct _Alloc_hider<_Alloc1, true>\n+\t: public _Alloc1\n+\t{\n+\t  _Alloc_hider(const _Alloc1& __a, _CharT* __ptr)\n+\t  : _Alloc1(__a), _M_p(__ptr) { }\n+\n+\t  void _M_alloc_swap(_Alloc_hider&) { }\n+\n+\t  _CharT*  _M_p; // The actual data.\n+\t};\n+\n+      // For use in _M_construct (_S_construct) forward_iterator_tag.\n+      template<typename _Type>\n+        static bool\n+        _S_is_null_pointer(_Type* __ptr)\n+        { return __ptr == 0; }\n+\n+      template<typename _Type>\n+        static bool\n+        _S_is_null_pointer(_Type)\n+        { return false; }\n+\n       // When __n = 1 way faster than the general multichar\n       // traits_type::copy/move/assign.\n       static void"}]}