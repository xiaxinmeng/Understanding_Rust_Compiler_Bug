{"sha": "3bc268e64b4167a3566c8b53decda0b06668f6fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JjMjY4ZTY0YjQxNjdhMzU2NmM4YjUzZGVjZGEwYjA2NjY4ZjZmZQ==", "commit": {"author": {"name": "Victor Leikehman", "email": "lei@il.ibm.com", "date": "2004-08-18T01:20:06Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-08-18T01:20:06Z"}, "message": "re PR fortran/13278 (derived type namelist I/O support missing, causes ICE)\n\n2004-08-18  Victor Leikehman  <lei@il.ibm.com>\n\n\tPR fortran/13278\n\t* trans-io.c (transfer_namelist_element): New. Recursively handle\n\tderived-type variables.  Pass string lengths.\n\t(build_dt): Code moved to build_namelist, with some\n\tchanges and additions.\n\t(gfc_build_io_library_fndecls): Declare the fifth\n\targument in st_set_nml_var_char -- string_length.\nlibgfortran/\n\t* io/transfer.c (st_set_nml_var)\n\t* io/write.c (namelist_write): Allow var_name and var_name_len to be\n\tnull. For strings, use string_length field instead of len.\n\t* io/io.h (struct namelist_type): New field string_length.\n\t(st_set_nml_var_char): New argument string_length.\n\nFrom-SVN: r86166", "tree": {"sha": "ee99eee77195e9d423d2ec6b517c2cf6ab9bae94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee99eee77195e9d423d2ec6b517c2cf6ab9bae94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bc268e64b4167a3566c8b53decda0b06668f6fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bc268e64b4167a3566c8b53decda0b06668f6fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bc268e64b4167a3566c8b53decda0b06668f6fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bc268e64b4167a3566c8b53decda0b06668f6fe/comments", "author": null, "committer": null, "parents": [{"sha": "b14454ba1a4d273021e354ff30f02f754fedb121", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b14454ba1a4d273021e354ff30f02f754fedb121", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b14454ba1a4d273021e354ff30f02f754fedb121"}], "stats": {"total": 220, "additions": 156, "deletions": 64}, "files": [{"sha": "c6e5cbe191bc192d87a0a878ddf3619fa1efc947", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bc268e64b4167a3566c8b53decda0b06668f6fe/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bc268e64b4167a3566c8b53decda0b06668f6fe/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3bc268e64b4167a3566c8b53decda0b06668f6fe", "patch": "@@ -1,3 +1,13 @@\n+2004-08-18  Victor Leikehman  <lei@il.ibm.com>\n+\n+\tPR fortran/13278\n+\t* trans-io.c (transfer_namelist_element): New. Recursively handle\n+\tderived-type variables.  Pass string lengths.\n+\t(build_dt): Code moved to build_namelist, with some\n+\tchanges and additions.\n+\t(gfc_build_io_library_fndecls): Declare the fifth\n+\targument in st_set_nml_var_char -- string_length.\n+\n 2004-08-17  Paul Brook  <paul@codesourcery.com>\n \tTobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n "}, {"sha": "63d56186c4cf689fb6751ee8c718b1b1a58c5e6d", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 106, "deletions": 50, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bc268e64b4167a3566c8b53decda0b06668f6fe/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bc268e64b4167a3566c8b53decda0b06668f6fe/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=3bc268e64b4167a3566c8b53decda0b06668f6fe", "patch": "@@ -329,9 +329,10 @@ gfc_build_io_library_fndecls (void)\n                                      gfc_int4_type_node,gfc_int4_type_node);\n   iocall_set_nml_val_char =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"st_set_nml_var_char\")),\n-                                     void_type_node, 4,\n+                                     void_type_node, 5,\n                                      pvoid_type_node, pvoid_type_node,\n-                                     gfc_int4_type_node,gfc_int4_type_node);\n+                                     gfc_int4_type_node, gfc_int4_type_node, \n+                                     gfc_strlen_type_node);\n   iocall_set_nml_val_complex =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"st_set_nml_var_complex\")),\n                                      void_type_node, 4,\n@@ -842,6 +843,94 @@ get_new_var_expr(gfc_symbol * sym)\n   return nml_var;\n }\n \n+/* For a scalar variable STRING whose address is ADDR_EXPR, generate a\n+   call to iocall_set_nml_val.  For derived type variable, recursively\n+   generate calls to iocall_set_nml_val for each leaf field. The leafs\n+   have no names -- their STRING field is null, and are interpreted by\n+   the run-time library as having only the value, as in the example:\n+\n+   &foo bzz=1,2,3,4,5/\n+\n+   Note that the first output field appears after the name of the\n+   variable, not of the field name.  This causes a little complication\n+   documented below. */\n+\n+static void\n+transfer_namelist_element (stmtblock_t * block, gfc_typespec * ts, tree addr_expr, \n+                           tree string, tree string_length)\n+{\n+  tree tmp, args, arg2;\n+  tree expr;\n+\n+  assert (POINTER_TYPE_P (TREE_TYPE (addr_expr)));\n+\n+  if (ts->type == BT_DERIVED)\n+    {\n+      gfc_component *c;\n+      expr = gfc_build_indirect_ref (addr_expr);\n+\n+      for (c = ts->derived->components; c; c = c->next)\n+        {\n+          tree field = c->backend_decl;\n+          assert (field && TREE_CODE (field) == FIELD_DECL);\n+          tmp = build (COMPONENT_REF, TREE_TYPE (field), expr, field, NULL_TREE);\n+\n+          if (c->dimension)\n+            gfc_todo_error (\"NAMELIST IO of array in derived type\");\n+          if (!c->pointer)\n+            tmp = gfc_build_addr_expr (NULL, tmp);\n+          transfer_namelist_element (block, &c->ts, tmp, string, string_length);\n+\n+          /* The first output field bears the name of the topmost\n+             derived type variable.  All other fields are anonymous\n+             and appear with nulls in their string and string_length\n+             fields.  After the first use, we set string and\n+             string_length to null. */\n+          string = null_pointer_node;\n+          string_length = integer_zero_node;\n+        }\n+\n+      return;\n+    }\n+\n+  args = gfc_chainon_list (NULL_TREE, addr_expr);\n+  args = gfc_chainon_list (args, string);\n+  args = gfc_chainon_list (args, string_length);\n+  arg2 = build_int_cst (gfc_array_index_type, ts->kind, 0);\n+  args = gfc_chainon_list (args,arg2);\n+\n+  switch (ts->type)\n+    {\n+    case BT_INTEGER:\n+      tmp = gfc_build_function_call (iocall_set_nml_val_int, args);\n+      break;\n+\n+    case BT_CHARACTER:\n+      expr = gfc_build_indirect_ref (addr_expr);\n+      assert (TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE);\n+      args = gfc_chainon_list (args,\n+                               TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (expr))));\n+      tmp = gfc_build_function_call (iocall_set_nml_val_char, args);\n+      break;\n+\n+    case BT_REAL:\n+      tmp = gfc_build_function_call (iocall_set_nml_val_float, args);\n+      break;\n+\n+    case BT_LOGICAL:\n+      tmp = gfc_build_function_call (iocall_set_nml_val_log, args);\n+      break;\n+\n+    case BT_COMPLEX:\n+      tmp = gfc_build_function_call (iocall_set_nml_val_complex, args);\n+      break;\n+\n+    default :\n+      internal_error (\"Bad namelist IO basetype (%d)\", ts->type);\n+    }\n+\n+  gfc_add_expr_to_block (block, tmp);\n+}\n \n /* Create a data transfer statement.  Not all of the fields are valid\n    for both reading and writing, but improper use has been filtered\n@@ -852,11 +941,10 @@ build_dt (tree * function, gfc_code * code)\n {\n   stmtblock_t block, post_block;\n   gfc_dt *dt;\n-  tree tmp, args, arg2;\n+  tree tmp;\n   gfc_expr *nmlname, *nmlvar;\n-  gfc_namelist *nml, *nml_tail;\n+  gfc_namelist *nml;\n   gfc_se se,se2;\n-  int ts_kind, ts_type, name_len;\n \n   gfc_init_block (&block);\n   gfc_init_block (&post_block);\n@@ -925,51 +1013,19 @@ build_dt (tree * function, gfc_code * code)\n        if (last_dt == READ)\n           set_flag (&block, ioparm_namelist_read_mode);\n \n-       nml = dt->namelist->namelist;\n-       nml_tail = dt->namelist->namelist_tail;\n-\n-       while(nml != NULL)\n-       {\n-          gfc_init_se (&se, NULL);\n-          gfc_init_se (&se2, NULL);\n-          nmlvar = get_new_var_expr(nml->sym);\n-          nmlname = gfc_new_nml_name_expr(nml->sym->name);\n-          name_len = strlen(nml->sym->name);\n-          ts_kind = nml->sym->ts.kind;\n-          ts_type = nml->sym->ts.type;\n-\n-          gfc_conv_expr_reference (&se2, nmlname);\n-          gfc_conv_expr_reference (&se, nmlvar);\n-          args = gfc_chainon_list (NULL_TREE, se.expr);\n-          args = gfc_chainon_list (args, se2.expr);\n-          args = gfc_chainon_list (args, se2.string_length);\n-          arg2 = build_int_cst (NULL_TREE, ts_kind, 0);\n-          args = gfc_chainon_list (args,arg2);\n-          switch (ts_type)\n-            {\n-            case BT_INTEGER:\n-              tmp = gfc_build_function_call (iocall_set_nml_val_int, args);\n-              break;\n-            case BT_CHARACTER:\n-              tmp = gfc_build_function_call (iocall_set_nml_val_char, args);\n-              break;\n-            case BT_REAL:\n-              tmp = gfc_build_function_call (iocall_set_nml_val_float, args);\n-              break;\n-            case BT_LOGICAL:\n-              tmp = gfc_build_function_call (iocall_set_nml_val_log, args);\n-              break;\n-            case BT_COMPLEX:\n-              tmp = gfc_build_function_call (iocall_set_nml_val_complex, args);\n-              break;\n-            default :\n-              internal_error (\"Bad namelist IO basetype (%d)\", ts_type);\n-            }\n-\n-          gfc_add_expr_to_block (&block, tmp);\n-\n-          nml = nml->next;\n-       }\n+\tfor (nml = dt->namelist->namelist; nml; nml = nml->next)\n+\t  {\n+\t    gfc_init_se (&se, NULL);\n+\t    gfc_init_se (&se2, NULL);\n+\t    nmlvar = get_new_var_expr (nml->sym);\n+\t    nmlname = gfc_new_nml_name_expr (nml->sym->name);\n+\t    gfc_conv_expr_reference (&se2, nmlname);\n+\t    gfc_conv_expr_reference (&se, nmlvar);\n+\t    gfc_evaluate_now (se.expr, &se.pre); \n+\n+\t    transfer_namelist_element (&block, &nml->sym->ts, se.expr,\n+\t\t\t\t       se2.expr, se2.string_length);\n+\t  }\n     }\n \n   tmp = gfc_build_function_call (*function, NULL_TREE);"}, {"sha": "ff4e9456aacc9f067393012b48d304af0ee7f307", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bc268e64b4167a3566c8b53decda0b06668f6fe/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bc268e64b4167a3566c8b53decda0b06668f6fe/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=3bc268e64b4167a3566c8b53decda0b06668f6fe", "patch": "@@ -1,3 +1,12 @@\n+2004-08-18  Victor Leikehman  <lei@il.ibm.com>\n+\n+\tPR fortran/13278\n+\t* io/transfer.c (st_set_nml_var)\n+\t* io/write.c (namelist_write): Allow var_name and var_name_len to be\n+\tnull. For strings, use string_length field instead of len.\n+\t* io/io.h (struct namelist_type): New field string_length.\n+\t(st_set_nml_var_char): New argument string_length.\n+\n 2004-08-13  Bud Davis  <bdavis9659@comcast.net>\n \n \tPR gfortran/16935"}, {"sha": "87a70f836cd2b0a2eb13e34463ecb374fdadbc0f", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bc268e64b4167a3566c8b53decda0b06668f6fe/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bc268e64b4167a3566c8b53decda0b06668f6fe/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=3bc268e64b4167a3566c8b53decda0b06668f6fe", "patch": "@@ -90,6 +90,7 @@ typedef struct namelist_type\n   void * mem_pos;\n   int  value_acquired;\n   int len;\n+  int string_length;\n   bt type;\n   struct namelist_type * next;\n }\n@@ -545,7 +546,7 @@ void st_set_nml_var_int (void * , char * , int , int );\n void st_set_nml_var_float (void * , char * , int , int );\n \n #define st_set_nml_var_char prefix(st_set_nml_var_char)\n-void st_set_nml_var_char (void * , char * , int , int );\n+void st_set_nml_var_char (void * , char * , int , int, gfc_strlen_type);\n \n #define st_set_nml_var_complex prefix(st_set_nml_var_complex)\n void st_set_nml_var_complex (void * , char * , int , int );"}, {"sha": "d4bec91ea31e90e6050de6145fec6b7835d1187f", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bc268e64b4167a3566c8b53decda0b06668f6fe/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bc268e64b4167a3566c8b53decda0b06668f6fe/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=3bc268e64b4167a3566c8b53decda0b06668f6fe", "patch": "@@ -24,6 +24,7 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include <string.h>\n+#include <assert.h>\n #include \"libgfortran.h\"\n #include \"io.h\"\n \n@@ -1507,17 +1508,28 @@ st_write_done (void)\n \n static void\n st_set_nml_var (void * var_addr, char * var_name, int var_name_len,\n-                int kind, bt type)\n+                int kind, bt type, int string_length)\n {\n   namelist_info *t1 = NULL, *t2 = NULL;\n   namelist_info *nml = (namelist_info *) get_mem (sizeof(\n                                                     namelist_info ));\n   nml->mem_pos = var_addr;\n-  nml->var_name = (char*) get_mem (var_name_len+1);\n-  strncpy (nml->var_name,var_name,var_name_len);\n-  nml->var_name[var_name_len] = 0;\n+  if (var_name)\n+    {\n+      assert (var_name_len > 0);\n+      nml->var_name = (char*) get_mem (var_name_len+1);\n+      strncpy (nml->var_name, var_name, var_name_len);\n+      nml->var_name[var_name_len] = 0;\n+    }\n+  else\n+    {\n+      assert (var_name_len == 0);\n+      nml->var_name = NULL;\n+    }\n+\n   nml->len = kind;\n   nml->type = type;\n+  nml->string_length = string_length;\n \n   nml->next = NULL;\n \n@@ -1539,34 +1551,35 @@ void\n st_set_nml_var_int (void * var_addr, char * var_name, int var_name_len,\n                 int kind)\n {\n-   st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_INTEGER);\n+   st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_INTEGER, 0);\n }\n \n void\n st_set_nml_var_float (void * var_addr, char * var_name, int var_name_len,\n                 int kind)\n {\n-   st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_REAL);\n+   st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_REAL, 0);\n }\n \n void\n st_set_nml_var_char (void * var_addr, char * var_name, int var_name_len,\n-                int kind)\n+                int kind, gfc_strlen_type string_length)\n {\n-   st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_CHARACTER);\n+   st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_CHARACTER,\n+                   string_length);\n }\n \n void\n st_set_nml_var_complex (void * var_addr, char * var_name, int var_name_len,\n                 int kind)\n {\n-   st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_COMPLEX);\n+   st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_COMPLEX, 0);\n }\n \n void\n st_set_nml_var_log (void * var_addr, char * var_name, int var_name_len,\n                 int kind)\n {\n-   st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_LOGICAL);\n+   st_set_nml_var (var_addr, var_name, var_name_len, kind, BT_LOGICAL, 0);\n }\n "}, {"sha": "67c769ae9204c802b886eb385c84ccfd5d6f8457", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bc268e64b4167a3566c8b53decda0b06668f6fe/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bc268e64b4167a3566c8b53decda0b06668f6fe/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=3bc268e64b4167a3566c8b53decda0b06668f6fe", "patch": "@@ -1122,8 +1122,11 @@ namelist_write (void)\n           num ++;\n           t2 = t1;\n           t1 = t1->next;\n-          write_character(t2->var_name, strlen(t2->var_name));\n-          write_character(\"=\",1);\n+          if (t2->var_name)\n+            {\n+              write_character(t2->var_name, strlen(t2->var_name));\n+              write_character(\"=\",1);\n+            }\n           len = t2->len;\n           p = t2->mem_pos;\n           switch (t2->type)\n@@ -1135,7 +1138,7 @@ namelist_write (void)\n               write_logical (p, len);\n               break;\n             case BT_CHARACTER:\n-              write_character (p, len);\n+              write_character (p, t2->string_length);\n               break;\n             case BT_REAL:\n               write_real (p, len);"}]}