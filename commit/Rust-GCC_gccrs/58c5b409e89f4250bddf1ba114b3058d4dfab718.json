{"sha": "58c5b409e89f4250bddf1ba114b3058d4dfab718", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThjNWI0MDllODlmNDI1MGJkZGYxYmExMTRiMzA1OGQ0ZGZhYjcxOA==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobias.schlueter@physik.uni-muenchen.de", "date": "2004-10-04T19:27:29Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-10-04T19:27:29Z"}, "message": "re PR fortran/17283 (UNPACK issues)\n\nPR fortran/17283\nfortran/\n* iresolve.c (gfc_resolve_pack): Choose function depending if mask is\nscalar.\nlibgfortran/\n* intrinsics/pack_generic.c (__pack): Allocate memory for return array\nif not done by caller.\n(__pack_s): New function.\n* runtime/memory.c (internal_malloc, internal_malloc64): Allow\nallocating zero memory.\ntestsuite/\n* gfortran.fortran-torture/execute/intrinsic_pack.f90: Add more tests.\n\nFrom-SVN: r88526", "tree": {"sha": "f997c7996452c6a047a1c132b79457094d5ea30b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f997c7996452c6a047a1c132b79457094d5ea30b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58c5b409e89f4250bddf1ba114b3058d4dfab718", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58c5b409e89f4250bddf1ba114b3058d4dfab718", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58c5b409e89f4250bddf1ba114b3058d4dfab718", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58c5b409e89f4250bddf1ba114b3058d4dfab718/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "110aba1432fa485c5c0ca2ad499822b7bfafd208", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/110aba1432fa485c5c0ca2ad499822b7bfafd208", "html_url": "https://github.com/Rust-GCC/gccrs/commit/110aba1432fa485c5c0ca2ad499822b7bfafd208"}], "stats": {"total": 354, "additions": 336, "deletions": 18}, "files": [{"sha": "204e8eb5c3148f537cc8cae83230a880a9c3eecf", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c5b409e89f4250bddf1ba114b3058d4dfab718/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c5b409e89f4250bddf1ba114b3058d4dfab718/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=58c5b409e89f4250bddf1ba114b3058d4dfab718", "patch": "@@ -1,3 +1,9 @@\n+2004-10-04  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\tPR fortran/17283\n+\t* iresolve.c (gfc_resolve_pack): Choose function depending if mask\n+\tis scalar.\n+\n 2004-10-04  Erik Schnetter  <schnetter@aei.mpg.de>\n \n \t* scanner.c (preprocessor_line): Accept preprocessor lines without"}, {"sha": "36597fa6d844d0fbeab86c2fc92f2b1b605fa32d", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c5b409e89f4250bddf1ba114b3058d4dfab718/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c5b409e89f4250bddf1ba114b3058d4dfab718/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=58c5b409e89f4250bddf1ba114b3058d4dfab718", "patch": "@@ -1022,15 +1022,33 @@ gfc_resolve_not (gfc_expr * f, gfc_expr * i)\n void\n gfc_resolve_pack (gfc_expr * f,\n                   gfc_expr * array ATTRIBUTE_UNUSED,\n-\t\t  gfc_expr * mask ATTRIBUTE_UNUSED,\n+\t\t  gfc_expr * mask,\n \t\t  gfc_expr * vector ATTRIBUTE_UNUSED)\n {\n-  static char pack[] = \"__pack\";\n+  static char pack[] = \"__pack\",\n+    pack_s[] = \"__pack_s\";\n \n   f->ts = array->ts;\n   f->rank = 1;\n \n-  f->value.function.name = pack;\n+  if (mask->rank != 0)\n+    f->value.function.name = pack;\n+  else\n+    {\n+      /* We convert mask to default logical only in the scalar case.\n+\t In the array case we can simply read the array as if it were\n+\t of type default logical.  */\n+      if (mask->ts.kind != gfc_default_logical_kind)\n+\t{\n+\t  gfc_typespec ts;\n+\n+\t  ts.type = BT_LOGICAL;\n+\t  ts.kind = gfc_default_logical_kind;\n+\t  gfc_convert_type (mask, &ts, 2);\n+\t}\n+\n+      f->value.function.name = pack_s;\n+    }\n }\n \n "}, {"sha": "0587e7fa07a243d2ba1b6db279616b5282d8a3b0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c5b409e89f4250bddf1ba114b3058d4dfab718/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c5b409e89f4250bddf1ba114b3058d4dfab718/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=58c5b409e89f4250bddf1ba114b3058d4dfab718", "patch": "@@ -1,3 +1,8 @@\n+2004-10-04  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\tPR fortran/17283\n+\t* gfortran.fortran-torture/execute/intrinsic_pack.f90: Add more tests.\n+\n 2004-10-04  Chao-ying Fu  <fu@mips.com>\n \n \t* gcc.dg/vect/pr16105.c: Enable for mipsisa64*-*-*."}, {"sha": "427fe55ef14f168103c2adfcccd12e4d9441f6fc", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/intrinsic_pack.f90", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c5b409e89f4250bddf1ba114b3058d4dfab718/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_pack.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c5b409e89f4250bddf1ba114b3058d4dfab718/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_pack.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fintrinsic_pack.f90?ref=58c5b409e89f4250bddf1ba114b3058d4dfab718", "patch": "@@ -1,12 +1,25 @@\n ! Program to test the PACK intrinsic\n program intrinsic_pack\n+   integer, parameter :: val(9) = (/0,0,0,0,9,0,0,0,7/)\n    integer, dimension(3, 3) :: a\n    integer, dimension(6) :: b\n \n-   a = reshape ((/0, 0, 0, 0, 9, 0, 0, 0, 7/), (/3, 3/))\n+   a = reshape (val, (/3, 3/))\n    b = 0\n    b(1:6:3) = pack (a, a .ne. 0);\n    if (any (b(1:6:3) .ne. (/9, 7/))) call abort\n    b = pack (a(2:3, 2:3), a(2:3, 2:3) .ne. 0, (/1, 2, 3, 4, 5, 6/));\n    if (any (b .ne. (/9, 7, 3, 4, 5, 6/))) call abort\n+\n+! this is waiting for PR 17756 to be fixed\n+!   call tests_with_temp()\n+contains\n+  subroutine tests_with_temp\n+    ! A few tests which involve a temporary\n+    if (any (pack(a, a.ne.0) .ne. (/9, 7/))) call abort\n+    if (any (pack(a, .true.) .ne. val)) call abort\n+    if (size(pack (a, .false.)) .ne. 0) call abort\n+    if (any (pack(a, .false., (/1,2,3/)).ne. (/1,2,3/))) call abort\n+\n+  end subroutine tests_with_temp\n end program"}, {"sha": "0c2b3818bc610156f356463608a4fa3d4c9a25e8", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c5b409e89f4250bddf1ba114b3058d4dfab718/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c5b409e89f4250bddf1ba114b3058d4dfab718/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=58c5b409e89f4250bddf1ba114b3058d4dfab718", "patch": "@@ -1,3 +1,12 @@\n+2004-10-04  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\tPR fortran/17283\n+\t* intrinsics/pack_generic.c (__pack): Allocate memory for return array\n+\tif not done by caller.\n+\t(__pack_s): New function.\n+\t* runtime/memory.c (internal_malloc, internal_malloc64): Allow\n+\tallocating zero memory.\n+\n 2004-10-04  Paul Brook  <paul@codesourcery.com>\n \tBud Davis  <bdavis9659@comcast.net>\n "}, {"sha": "301948e7e86d2923fc33f604d825b12bb4b6f814", "filename": "libgfortran/intrinsics/pack_generic.c", "status": "modified", "additions": 277, "deletions": 10, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c5b409e89f4250bddf1ba114b3058d4dfab718/libgfortran%2Fintrinsics%2Fpack_generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c5b409e89f4250bddf1ba114b3058d4dfab718/libgfortran%2Fintrinsics%2Fpack_generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fpack_generic.c?ref=58c5b409e89f4250bddf1ba114b3058d4dfab718", "patch": "@@ -1,5 +1,5 @@\n-/* Generic implementation of the RESHAPE intrinsic\n-   Copyright 2002 Free Software Foundation, Inc.\n+/* Generic implementation of the PACK intrinsic\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n This file is part of the GNU Fortran 95 runtime library (libgfor).\n@@ -25,9 +25,49 @@ Boston, MA 02111-1307, USA.  */\n #include <string.h>\n #include \"libgfortran.h\"\n \n+/* PACK is specified as follows:\n+\n+   13.14.80 PACK (ARRAY, MASK, [VECTOR])\n+   \n+   Description: Pack an array into an array of rank one under the\n+   control of a mask.\n+\n+   Class: Transformational fucntion.\n+\n+   Arguments:\n+      ARRAY   may be of any type. It shall not be scalar.\n+      MASK    shall be of type LOGICAL. It shall be conformable with ARRAY.\n+      VECTOR  (optional) shall be of the same type and type parameters\n+              as ARRAY. VECTOR shall have at least as many elements as\n+              there are true elements in MASK. If MASK is a scalar\n+              with the value true, VECTOR shall have at least as many \n+              elements as there are in ARRAY.\n+\n+   Result Characteristics: The result is an array of rank one with the\n+   same type and type parameters as ARRAY. If VECTOR is present, the\n+   result size is that of VECTOR; otherwise, the result size is the\n+   number /t/ of true elements in MASK unless MASK is scalar with the\n+   value true, in which case the result size is the size of ARRAY.\n+\n+   Result Value: Element /i/ of the result is the element of ARRAY\n+   that corresponds to the /i/th true element of MASK, taking elements\n+   in array element order, for /i/ = 1, 2, ..., /t/. If VECTOR is\n+   present and has size /n/ > /t/, element /i/ of the result has the\n+   value VECTOR(/i/), for /i/ = /t/ + 1, ..., /n/.\n+\n+   Examples: The nonzero elements of an array M with the value\n+   | 0 0 0 |\n+   | 9 0 0 | may be \"gathered\" by the function PACK. The result of\n+   | 0 0 7 |\n+   PACK (M, MASK = M.NE.0) is [9,7] and the result of PACK (M, M.NE.0,\n+   VECTOR = (/ 2,4,6,8,10,12 /)) is [9,7,6,8,10,12].  \n+\n+There are two variants of the PACK intrinsic: one, where MASK is\n+array valued, and the other one where MASK is scalar.  */\n+\n void\n-__pack (const gfc_array_char * ret, const gfc_array_char * array,\n-    const gfc_array_l4 * mask, const gfc_array_char * vector)\n+__pack (gfc_array_char * ret, const gfc_array_char * array,\n+\tconst gfc_array_l4 * mask, const gfc_array_char * vector)\n {\n   /* r.* indicates the return array.  */\n   index_type rstride0;\n@@ -62,12 +102,6 @@ __pack (const gfc_array_char * ret, const gfc_array_char * array,\n   if (mstride[0] == 0)\n     mstride[0] = 1;\n \n-  rstride0 = ret->dim[0].stride * size;\n-  if (rstride0 == 0)\n-    rstride0 = size;\n-  sstride0 = sstride[0];\n-  mstride0 = mstride[0];\n-  rptr = ret->data;\n   sptr = array->data;\n   mptr = mask->data;\n \n@@ -82,6 +116,94 @@ __pack (const gfc_array_char * ret, const gfc_array_char * array,\n       mptr = GFOR_POINTER_L8_TO_L4 (mptr);\n     }\n \n+  if (ret->data == NULL)\n+    {\n+      /* Allocate the memory for the result.  */\n+      int total;\n+\n+      if (vector != NULL) \n+\t{ \n+\n+\t  /* The return array will have as many\n+\t     elements as there are in VECTOR.  */ \n+\t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound; \n+\t} \n+      else \n+\t{ \n+\t  /* We have to count the true elements in MASK.  */ \n+\n+\t  /* TODO: We could speed up pack easily in the case of only\n+\t     few .TRUE. entries in MASK, by keeping track of where we\n+\t     would be in the source array during the initial traversal\n+\t     of MASK, and caching the pointers to those elements. Then,\n+\t     supposed the number of elements is small enough, we would\n+\t     only have to traverse the list, and copy those elements\n+\t     into the result array. In the case of datatypes which fit\n+\t     in one of the integer types we could also cache the\n+\t     value instead of a pointer to it. \n+\t     This approach might be bad from the point of view of\n+\t     cache behavior in the case where our cache is not big\n+\t     enough to hold all elements that have to be copied.  */\n+\n+\t  const GFC_LOGICAL_4 *m = mptr;\n+\n+\t  total = 0;\n+\n+\t  while (m)\n+\t    {\n+\t      /* Test this element.  */\n+\t      if (*m)\n+\t\ttotal++;\n+\n+\t      /* Advance to the next element.  */\n+\t      m += mstride[0];\n+\t      count[0]++;\n+\t      n = 0;\n+\t      while (count[n] == extent[n])\n+\t\t{\n+\t\t  /* When we get to the end of a dimension, reset it\n+\t\t     and increment the next dimension.  */\n+\t\t  count[n] = 0;\n+\t\t  /* We could precalculate this product, but this is a\n+\t\t     less frequently used path so proabably not worth\n+\t\t     it.  */\n+\t\t  m -= mstride[n] * extent[n];\n+\t\t  n++;\n+\t\t  if (n >= dim)\n+\t\t    {\n+\t\t      /* Break out of the loop.  */\n+\t\t      m = NULL;\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      count[n]++;\n+\t\t      mptr += mstride[n];\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      \n+      /* Setup the array descriptor.  */\n+      ret->dim[0].lbound = 0;\n+      ret->dim[0].ubound = total - 1;\n+      ret->dim[0].stride = 1;\n+\n+      ret->data = internal_malloc (size * total);\n+      ret->base = 0;\n+\n+      if (total == 0)\n+\t/* In this case, nothing remains to be done.  */\n+\treturn;\n+    }\n+\n+  rstride0 = ret->dim[0].stride * size;\n+  if (rstride0 == 0)\n+    rstride0 = size;\n+  sstride0 = sstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->data;\n+\n   while (sptr)\n     {\n       /* Test this element.  */\n@@ -144,3 +266,148 @@ __pack (const gfc_array_char * ret, const gfc_array_char * array,\n     }\n }\n \n+void\n+__pack_s (gfc_array_char * ret, const gfc_array_char * array,\n+\t  const GFC_LOGICAL_4 * mask, const gfc_array_char * vector)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride0;\n+  char *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  const char *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+  index_type size;\n+  index_type nelem;\n+\n+  size = GFC_DESCRIPTOR_SIZE (array);\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+      sstride[n] = array->dim[n].stride * size;\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = size;\n+\n+  sstride0 = sstride[0];\n+  sptr = array->data;\n+\n+  if (ret->data == NULL)\n+    {\n+      /* Allocate the memory for the result.  */\n+      int total;\n+\n+      if (vector != NULL)\n+\t{\n+\t  /* The return array will have as many elements as there are\n+\t     in vector.  */\n+\t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t}\n+      else\n+\t{\n+\t  if (*mask)\n+\t    {\n+\t      /* The result array will have as many elements as the input\n+\t\t array.  */\n+\t      total = extent[0];\n+\t      for (n = 1; n < dim; n++)\n+\t\ttotal *= extent[n];\n+\t    }\n+\t  else\n+\t    {\n+\t      /* The result array will be empty.  */\n+\t      ret->dim[0].lbound = 0;\n+\t      ret->dim[0].ubound = -1;\n+\t      ret->dim[0].stride = 1;\n+\t      ret->data = internal_malloc (0);\n+\t      ret->base = 0;\n+\t      \n+\t      return;\n+\t    }\n+\t}\n+\n+      /* Setup the array descriptor.  */\n+      ret->dim[0].lbound = 0;\n+      ret->dim[0].ubound = total - 1;\n+      ret->dim[0].stride = 1;\n+\n+      ret->data = internal_malloc (size * total);\n+      ret->base = 0;\n+    }\n+\n+  rstride0 = ret->dim[0].stride * size;\n+  if (rstride0 == 0)\n+    rstride0 = size;\n+  rptr = ret->data;\n+\n+  /* The remaining possibilities are now: \n+       If MASK is .TRUE., we have to copy the source array into the\n+     result array. We then have to fill it up with elements from VECTOR.\n+       If MASK is .FALSE., we have to copy VECTOR into the result\n+     array. If VECTOR were not present we would have already returned.  */\n+\n+  if (*mask)\n+    {\n+      while (sptr)\n+\t{\n+\t  /* Add this element.  */\n+\t  memcpy (rptr, sptr, size);\n+\t  rptr += rstride0;\n+\n+\t  /* Advance to the next element.  */\n+\t  sptr += sstride0;\n+\t  count[0]++;\n+\t  n = 0;\n+\t  while (count[n] == extent[n])\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and\n+\t\t increment the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a\n+\t\t less frequently used path so proabably not worth it.  */\n+\t      sptr -= sstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= dim)\n+\t\t{\n+\t\t  /* Break out of the loop.  */\n+\t\t  sptr = NULL;\n+\t\t  break;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  sptr += sstride[n];\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  \n+  /* Add any remaining elements from VECTOR.  */\n+  if (vector)\n+    {\n+      n = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+      nelem = ((rptr - ret->data) / rstride0);\n+      if (n > nelem)\n+        {\n+          sstride0 = vector->dim[0].stride * size;\n+          if (sstride0 == 0)\n+            sstride0 = size;\n+\n+          sptr = vector->data + sstride0 * nelem;\n+          n -= nelem;\n+          while (n--)\n+            {\n+              memcpy (rptr, sptr, size);\n+              rptr += rstride0;\n+              sptr += sstride0;\n+            }\n+        }\n+    }\n+}"}, {"sha": "5b146000b8d53f2e2191547bb32fc033af0a7409", "filename": "libgfortran/runtime/memory.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c5b409e89f4250bddf1ba114b3058d4dfab718/libgfortran%2Fruntime%2Fmemory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c5b409e89f4250bddf1ba114b3058d4dfab718/libgfortran%2Fruntime%2Fmemory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fmemory.c?ref=58c5b409e89f4250bddf1ba114b3058d4dfab718", "patch": "@@ -165,8 +165,8 @@ internal_malloc (GFC_INTEGER_4 size)\n {\n #ifdef GFC_CHECK_MEMORY\n   /* Under normal circumstances, this is _never_ going to happen!  */\n-  if (size <= 0)\n-    runtime_error (\"Attempt to allocate a non-positive amount of memory.\");\n+  if (size < 0)\n+    runtime_error (\"Attempt to allocate a negative amount of memory.\");\n \n #endif\n   return internal_malloc_size ((size_t) size);\n@@ -178,8 +178,8 @@ internal_malloc64 (GFC_INTEGER_8 size)\n {\n #ifdef GFC_CHECK_MEMORY\n   /* Under normal circumstances, this is _never_ going to happen!  */\n-  if (size <= 0)\n-    runtime_error (\"Attempt to allocate a non-positive amount of memory.\");\n+  if (size < 0)\n+    runtime_error (\"Attempt to allocate a negative amount of memory.\");\n #endif\n   return internal_malloc_size ((size_t) size);\n }"}]}