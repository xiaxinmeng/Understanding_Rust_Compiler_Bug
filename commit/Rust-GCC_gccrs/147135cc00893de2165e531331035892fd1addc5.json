{"sha": "147135cc00893de2165e531331035892fd1addc5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ3MTM1Y2MwMDg5M2RlMjE2NWU1MzEzMzEwMzU4OTJmZDFhZGRjNQ==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2003-09-27T01:55:13Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2003-09-27T01:55:13Z"}, "message": "cp-tree.h, [...]: Remove reference to macros BINDING_SCOPE, BINDING_VALUE and BINDING_TYPE.\n\n\t* cp-tree.h, name-lookup.h, decl.c, decl2.c: Remove reference to\n\tmacros \tBINDING_SCOPE, BINDING_VALUE and BINDING_TYPE.\n\nFrom-SVN: r71848", "tree": {"sha": "e9a0497625b4dd060b32e2390476424b5d9b09cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9a0497625b4dd060b32e2390476424b5d9b09cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/147135cc00893de2165e531331035892fd1addc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/147135cc00893de2165e531331035892fd1addc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/147135cc00893de2165e531331035892fd1addc5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/147135cc00893de2165e531331035892fd1addc5/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "07a6b250e7c97ec61b0484ef74d6cdd37854e62e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07a6b250e7c97ec61b0484ef74d6cdd37854e62e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07a6b250e7c97ec61b0484ef74d6cdd37854e62e"}], "stats": {"total": 196, "additions": 88, "deletions": 108}, "files": [{"sha": "cbf9b54c585f1461af4d101f285436c206ba3836", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/147135cc00893de2165e531331035892fd1addc5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/147135cc00893de2165e531331035892fd1addc5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=147135cc00893de2165e531331035892fd1addc5", "patch": "@@ -1,3 +1,8 @@\n+2003-09-27  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* cp-tree.h, name-lookup.h, decl.c, decl2.c: Remove reference to\n+\tmacros \tBINDING_SCOPE, BINDING_VALUE and BINDING_TYPE.\n+\n 2003-09-26  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* decl.c (pop_binding_level, suspend_binding_level,\n@@ -14,7 +19,7 @@\n \t(cp_parser_member_declaration): Use it.\n \t(cp_parser_template_declaration_after_export): Likewise.\n \n-2003-09-22  Gabriel Dos Reis  <gcc@integrable-solutions.net>\n+2003-09-22  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* cp-tree.h (scope_kind): Add new enumerator.\n \t(keep_next_level): Change parameter type to bool."}, {"sha": "628a0c9ae3f2326b3997f0b94b8bfcfaf7726cd2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/147135cc00893de2165e531331035892fd1addc5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/147135cc00893de2165e531331035892fd1addc5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=147135cc00893de2165e531331035892fd1addc5", "patch": "@@ -379,10 +379,10 @@ typedef enum cp_id_kind\n \n /* The IDENTIFIER_BINDING is the innermost cxx_binding for the\n     identifier.  It's PREVIOUS is the next outermost binding.  Each\n-    BINDING_VALUE is a DECL for the associated declaration.  Thus,\n+    VALUE field is a DECL for the associated declaration.  Thus,\n     name lookup consists simply of pulling off the node at the front\n     of the list (modulo oddities for looking up the names of types,\n-    and such.)  You can use BINDING_SCOPE to determine the scope\n+    and such.)  You can use SCOPE field to determine the scope\n     that bound the name.  */\n #define IDENTIFIER_BINDING(NODE) \\\n   (LANG_IDENTIFIER_CAST (NODE)->bindings)\n@@ -394,7 +394,7 @@ typedef enum cp_id_kind\n \n /* If IDENTIFIER_CLASS_VALUE is set, then NODE is bound in the current\n    class, and IDENTIFIER_CLASS_VALUE is the value binding.  This is\n-   just a pointer to the BINDING_VALUE of one of the bindings in the\n+   just a pointer to the VALUE field of one of the bindings in the\n    IDENTIFIER_BINDINGs list, so any time that this is non-NULL so is\n    IDENTIFIER_BINDING.  */\n #define IDENTIFIER_CLASS_VALUE(NODE) \\"}, {"sha": "51edfd24f8bc9e6320aa1eeaaabf5fcb27029baf", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 51, "deletions": 61, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/147135cc00893de2165e531331035892fd1addc5/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/147135cc00893de2165e531331035892fd1addc5/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=147135cc00893de2165e531331035892fd1addc5", "patch": "@@ -857,7 +857,7 @@ push_binding (tree id, tree decl, cxx_scope* level)\n \n   /* Now, fill in the binding information.  */\n   binding->previous = IDENTIFIER_BINDING (id);\n-  BINDING_SCOPE (binding) = level;\n+  binding->scope = level;\n   INHERITED_VALUE_BINDING_P (binding) = 0;\n   LOCAL_BINDING_P (binding) = (level != class_binding_level);\n \n@@ -953,7 +953,7 @@ push_class_binding (tree id, tree decl)\n      other purpose.  */\n   note_name_declared_in_class (id, decl);\n \n-  if (binding && BINDING_SCOPE (binding) == class_binding_level)\n+  if (binding && binding->scope == class_binding_level)\n     /* Supplement the existing binding.  */\n     result = supplement_binding (IDENTIFIER_BINDING (id), decl);\n   else\n@@ -965,11 +965,11 @@ push_class_binding (tree id, tree decl)\n      because of the possibility of the `struct stat' hack; if DECL is\n      a class-name or enum-name we might prefer a field-name, or some\n      such.  */\n-  IDENTIFIER_CLASS_VALUE (id) = BINDING_VALUE (IDENTIFIER_BINDING (id));\n+  IDENTIFIER_CLASS_VALUE (id) = IDENTIFIER_BINDING (id)->value;\n \n   /* If this is a binding from a base class, mark it as such.  */\n   binding = IDENTIFIER_BINDING (id);\n-  if (BINDING_VALUE (binding) == decl && TREE_CODE (decl) != TREE_LIST)\n+  if (binding->value == decl && TREE_CODE (decl) != TREE_LIST)\n     {\n       if (TREE_CODE (decl) == OVERLOAD)\n \tcontext = CP_DECL_CONTEXT (OVL_CURRENT (decl));\n@@ -984,7 +984,7 @@ push_class_binding (tree id, tree decl)\n       else\n \tINHERITED_VALUE_BINDING_P (binding) = 0;\n     }\n-  else if (BINDING_VALUE (binding) == decl)\n+  else if (binding->value == decl)\n     /* We only encounter a TREE_LIST when push_class_decls detects an\n        ambiguity.  Such an ambiguity can be overridden by a definition\n        in this class.  */\n@@ -1015,14 +1015,14 @@ pop_binding (tree id, tree decl)\n \n   /* The DECL will be either the ordinary binding or the type\n      binding for this identifier.  Remove that binding.  */\n-  if (BINDING_VALUE (binding) == decl)\n-    BINDING_VALUE (binding) = NULL_TREE;\n-  else if (BINDING_TYPE (binding) == decl)\n-    BINDING_TYPE (binding) = NULL_TREE;\n+  if (binding->value == decl)\n+    binding->value = NULL_TREE;\n+  else if (binding->type == decl)\n+    binding->type = NULL_TREE;\n   else\n     abort ();\n \n-  if (!BINDING_VALUE (binding) && !BINDING_TYPE (binding))\n+  if (!binding->value && !binding->type)\n     {\n       /* We're completely done with the innermost binding for this\n \t identifier.  Unhook it from the list of bindings.  */\n@@ -1031,9 +1031,8 @@ pop_binding (tree id, tree decl)\n       /* Add it to the free list.  */\n       cxx_binding_free (binding);\n \n-      /* Clear the BINDING_SCOPE so the garbage collector doesn't walk\n-\t it.  */\n-      BINDING_SCOPE (binding) = NULL;\n+      /* Clear the SCOPE so the garbage collector doesn't walk it.  */\n+      binding->scope = NULL;\n     }\n }\n \n@@ -1250,8 +1249,7 @@ poplevel (int keep, int reverse, int functionbody)\n \t    ns_binding = NULL_TREE;\n \n \t  if (outer_binding\n-\t      && (BINDING_SCOPE (outer_binding)\n-\t\t  == current_binding_level->level_chain))\n+\t      && outer_binding->scope == current_binding_level->level_chain)\n \t    /* We have something like:\n \n \t         int i;\n@@ -1261,10 +1259,8 @@ poplevel (int keep, int reverse, int functionbody)\n \t       keep the binding of the inner `i' in this case.  */\n \t    pop_binding (DECL_NAME (link), link);\n \t  else if ((outer_binding\n-\t\t    && (TREE_CODE (BINDING_VALUE (outer_binding))\n-\t\t\t== TYPE_DECL))\n-\t\t   || (ns_binding\n-\t\t       && TREE_CODE (ns_binding) == TYPE_DECL))\n+\t\t    && (TREE_CODE (outer_binding->value) == TYPE_DECL))\n+\t\t   || (ns_binding && TREE_CODE (ns_binding) == TYPE_DECL))\n \t    /* Here, we have something like:\n \n \t\t typedef int I;\n@@ -1284,9 +1280,8 @@ poplevel (int keep, int reverse, int functionbody)\n \n \t      /* Keep track of what should have happened when we\n \t\t popped the binding.  */\n-\t      if (outer_binding && BINDING_VALUE (outer_binding))\n-\t\tDECL_SHADOWED_FOR_VAR (link)\n-\t\t  = BINDING_VALUE (outer_binding);\n+\t      if (outer_binding && outer_binding->value)\n+\t\tDECL_SHADOWED_FOR_VAR (link) = outer_binding->value;\n \n \t      /* Add it to the list of dead variables in the next\n \t\t outermost binding to that we can remove these when we\n@@ -1297,8 +1292,8 @@ poplevel (int keep, int reverse, int functionbody)\n \t\t\t     dead_vars_from_for);\n \n \t      /* Although we don't pop the cxx_binding, we do clear\n-\t\t its BINDING_SCOPE since the level is going away now.  */\n-\t      BINDING_SCOPE (IDENTIFIER_BINDING (DECL_NAME (link))) = 0;\n+\t\t its SCOPE since the scope is going away now.  */\n+\t      IDENTIFIER_BINDING (DECL_NAME (link))->scope = NULL;\n \t    }\n \t}\n       else\n@@ -1502,12 +1497,12 @@ poplevel_class (void)\n \t    cxx_binding *binding;\n             \n \t    binding = IDENTIFIER_BINDING (TREE_PURPOSE (shadowed));\n-\t    while (binding && BINDING_SCOPE (binding) != b)\n+\t    while (binding && binding->scope != b)\n \t      binding = binding->previous;\n \n \t    if (binding)\n \t      IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (shadowed))\n-\t\t= BINDING_VALUE (binding);\n+\t\t= binding->value;\n \t  }\n     }\n   else\n@@ -2177,10 +2172,10 @@ set_identifier_type_value_with_scope (tree id,\n \tbinding_for_name (NAMESPACE_LEVEL (current_namespace), id);\n       if (decl)\n \t{\n-\t  if (BINDING_VALUE (binding))\n+\t  if (binding->value)\n \t    supplement_binding (binding, decl);\n \t  else\n-\t    BINDING_VALUE (binding) = decl;\n+\t    binding->value = decl;\n \t}\n       else\n \tabort ();\n@@ -4108,9 +4103,9 @@ push_class_level_binding (tree name, tree x)\n      class, then we will need to restore IDENTIFIER_CLASS_VALUE when\n      we leave this class.  Record the shadowed declaration here.  */\n   binding = IDENTIFIER_BINDING (name);\n-  if (binding && BINDING_VALUE (binding))\n+  if (binding && binding->value)\n     {\n-      tree bval = BINDING_VALUE (binding);\n+      tree bval = binding->value;\n       tree old_decl = NULL_TREE;\n \n       if (INHERITED_VALUE_BINDING_P (binding))\n@@ -4122,9 +4117,9 @@ push_class_level_binding (tree name, tree x)\n \t  if (TREE_CODE (bval) == TYPE_DECL && DECL_ARTIFICIAL (bval)\n \t      && !(TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)))\n \t    {\n-\t      old_decl = BINDING_TYPE (binding);\n-\t      BINDING_TYPE (binding) = bval;\n-\t      BINDING_VALUE (binding) = NULL_TREE;\n+\t      old_decl = binding->type;\n+\t      binding->type = bval;\n+\t      binding->value = NULL_TREE;\n \t      INHERITED_VALUE_BINDING_P (binding) = 0;\n \t    }\n \t  else\n@@ -4151,7 +4146,7 @@ push_class_level_binding (tree name, tree x)\n \t    if (TREE_PURPOSE (shadow) == name\n \t\t&& TREE_TYPE (shadow) == old_decl)\n \t      {\n-\t\tBINDING_VALUE (binding) = x;\n+\t\tbinding->value = x;\n \t\tINHERITED_VALUE_BINDING_P (binding) = 0;\n \t\tTREE_TYPE (shadow) = x;\n \t\tIDENTIFIER_CLASS_VALUE (name) = x;\n@@ -4330,7 +4325,7 @@ push_overloaded_decl (tree decl, int flags)\n \t{\n \t  tree *d;\n \n-\t  for (d = &BINDING_SCOPE (IDENTIFIER_BINDING (name))->names;\n+\t  for (d = &IDENTIFIER_BINDING (name)->scope->names;\n \t       *d;\n \t       d = &TREE_CHAIN (*d))\n \t    if (*d == old\n@@ -4346,8 +4341,7 @@ push_overloaded_decl (tree decl, int flags)\n \t\t\t\t  TREE_CHAIN (*d));\n \n \t\t/* And update the cxx_binding node.  */\n-\t\tBINDING_VALUE (IDENTIFIER_BINDING (name))\n-\t\t  = new_binding;\n+\t\tIDENTIFIER_BINDING (name)->value = new_binding;\n \t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n \t      }\n \n@@ -4983,7 +4977,7 @@ follow_tag_typedef (tree type)\n \n /* Given NAME, an IDENTIFIER_NODE,\n    return the structure (or union or enum) definition for that name.\n-   Searches binding levels from BINDING_SCOPE up to the global level.\n+   Searches binding levels from its SCOPE up to the global level.\n    If THISLEVEL_ONLY is nonzero, searches only the specified context\n    (but skips any sk_cleanup contexts to find one that is\n    meaningful for tags).\n@@ -5027,9 +5021,9 @@ lookup_tag (enum tree_code form, tree name,\n \t       class declaration, then we use the _TYPE node for the\n \t       template.  See the example below.  */\n \t    if (thislevel_only && !allow_template_parms_p\n-\t\t&& binding && BINDING_VALUE (binding)\n-\t\t&& DECL_CLASS_TEMPLATE_P (BINDING_VALUE (binding)))\n-\t      old = BINDING_VALUE (binding);\n+\t\t&& binding && binding->value\n+\t\t&& DECL_CLASS_TEMPLATE_P (binding->value))\n+\t      old = binding->value;\n \t    else if (binding)\n \t      old = select_decl (binding, LOOKUP_PREFER_TYPES);\n             else\n@@ -5472,7 +5466,7 @@ static tree\n select_decl (cxx_binding *binding, int flags)\n {\n   tree val;\n-  val = BINDING_VALUE (binding);\n+  val = binding->value;\n \n   timevar_push (TV_NAME_LOOKUP);\n   if (LOOKUP_NAMESPACES_ONLY (flags))\n@@ -5485,9 +5479,8 @@ select_decl (cxx_binding *binding, int flags)\n \n   /* If looking for a type, or if there is no non-type binding, select\n      the value binding.  */\n-  if (BINDING_TYPE (binding) \n-      && (!val || (flags & LOOKUP_PREFER_TYPES)))\n-    val = BINDING_TYPE (binding);\n+  if (binding->type && (!val || (flags & LOOKUP_PREFER_TYPES)))\n+    val = binding->type;\n   /* Don't return non-types if we really prefer types.  */\n   else if (val && LOOKUP_TYPES_ONLY (flags)  && TREE_CODE (val) != TYPE_DECL\n \t   && (TREE_CODE (val) != TEMPLATE_DECL\n@@ -5524,16 +5517,14 @@ unqualified_namespace_lookup (tree name, int flags, tree* spacesp)\n \t*spacesp = tree_cons (scope, NULL_TREE, *spacesp);\n \n       /* Ignore anticipated built-in functions.  */\n-      if (b && BINDING_VALUE (b)\n-          && DECL_P (BINDING_VALUE (b))\n-          && DECL_LANG_SPECIFIC (BINDING_VALUE (b))\n-          && DECL_ANTICIPATED (BINDING_VALUE (b)))\n+      if (b && b->value && DECL_P (b->value)\n+          && DECL_LANG_SPECIFIC (b->value) && DECL_ANTICIPATED (b->value))\n         /* Keep binding cleared.  */;\n       else if (b)\n         {\n           /* Initialize binding for this context.  */\n-          binding.value = BINDING_VALUE (b);\n-          binding.type = BINDING_TYPE (b);\n+          binding.value = b->value;\n+          binding.type = b->type;\n         }\n \n       /* Add all _DECLs seen through local using-directives.  */\n@@ -5760,11 +5751,11 @@ lookup_name_real (tree name, int prefer_type, int nonclass,\n \tcontinue;\n \n       /* If this is the kind of thing we're looking for, we're done.  */\n-      if (qualify_lookup (BINDING_VALUE (iter), flags))\n-\tbinding = BINDING_VALUE (iter);\n+      if (qualify_lookup (iter->value, flags))\n+\tbinding = iter->value;\n       else if ((flags & LOOKUP_PREFER_TYPES)\n-\t       && qualify_lookup (BINDING_TYPE (iter), flags))\n-\tbinding = BINDING_TYPE (iter);\n+\t       && qualify_lookup (iter->type, flags))\n+\tbinding = iter->type;\n       else\n \tbinding = NULL_TREE;\n \n@@ -5836,7 +5827,7 @@ lookup_name_current_level (tree name)\n     {\n       while (1)\n \t{\n-\t  if (BINDING_SCOPE (IDENTIFIER_BINDING (name)) == b)\n+\t  if (IDENTIFIER_BINDING (name)->scope == b)\n \t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, IDENTIFIER_VALUE (name));\n \n \t  if (b->kind == sk_cleanup)\n@@ -7773,12 +7764,11 @@ maybe_inject_for_scope_var (tree decl)\n       cxx_binding *outer_binding\n \t= IDENTIFIER_BINDING (DECL_NAME (decl))->previous;\n \n-      if (outer_binding && BINDING_SCOPE (outer_binding) == outer\n-\t  && (TREE_CODE (BINDING_VALUE (outer_binding)) == VAR_DECL)\n-\t  && DECL_DEAD_FOR_LOCAL (BINDING_VALUE (outer_binding)))\n+      if (outer_binding && outer_binding->scope == outer\n+\t  && (TREE_CODE (outer_binding->value) == VAR_DECL)\n+\t  && DECL_DEAD_FOR_LOCAL (outer_binding->value))\n \t{\n-\t  BINDING_VALUE (outer_binding)\n-\t    = DECL_SHADOWED_FOR_VAR (BINDING_VALUE (outer_binding));\n+\t  outer_binding->value = DECL_SHADOWED_FOR_VAR (outer_binding->value);\n \t  current_binding_level->kind = sk_block;\n \t}\n     }"}, {"sha": "8afd922b9b627123e406647fe463ef44707298d6", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/147135cc00893de2165e531331035892fd1addc5/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/147135cc00893de2165e531331035892fd1addc5/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=147135cc00893de2165e531331035892fd1addc5", "patch": "@@ -3159,7 +3159,7 @@ ambiguous_decl (tree name, cxx_binding *old, cxx_binding *new, int flags)\n   tree val, type;\n   my_friendly_assert (old != NULL, 393);\n   /* Copy the value.  */\n-  val = BINDING_VALUE (new);\n+  val = new->value;\n   if (val)\n     switch (TREE_CODE (val))\n       {\n@@ -3188,43 +3188,43 @@ ambiguous_decl (tree name, cxx_binding *old, cxx_binding *new, int flags)\n           val = NULL_TREE;\n       }\n         \n-  if (!BINDING_VALUE (old))\n-    BINDING_VALUE (old) = val;\n-  else if (val && val != BINDING_VALUE (old))\n+  if (!old->value)\n+    old->value = val;\n+  else if (val && val != old->value)\n     {\n-      if (is_overloaded_fn (BINDING_VALUE (old)) && is_overloaded_fn (val))\n-        BINDING_VALUE (old) = merge_functions (BINDING_VALUE (old), val);\n+      if (is_overloaded_fn (old->value) && is_overloaded_fn (val))\n+        old->value = merge_functions (old->value, val);\n       else\n \t{\n \t  /* Some declarations are functions, some are not.  */\n           if (flags & LOOKUP_COMPLAIN)\n             {\n \t      /* If we've already given this error for this lookup,\n-\t\t BINDING_VALUE (old) is error_mark_node, so let's not\n+\t\t old->value is error_mark_node, so let's not\n \t\t repeat ourselves.  */\n-\t      if (BINDING_VALUE (old) != error_mark_node)\n+\t      if (old->value != error_mark_node)\n \t\t{\n \t\t  error (\"use of `%D' is ambiguous\", name);\n \t\t  cp_error_at (\"  first declared as `%#D' here\",\n-\t\t\t       BINDING_VALUE (old));\n+\t\t\t       old->value);\n \t\t}\n               cp_error_at (\"  also declared as `%#D' here\", val);\n             }\n-\t  BINDING_VALUE (old) = error_mark_node;\n+\t  old->value = error_mark_node;\n \t}\n     }\n   /* ... and copy the type.  */\n-  type = BINDING_TYPE (new);\n+  type = new->type;\n   if (LOOKUP_NAMESPACES_ONLY (flags))\n     type = NULL_TREE;\n-  if (!BINDING_TYPE (old))\n-    BINDING_TYPE (old) = type;\n-  else if (type && BINDING_TYPE (old) != type)\n+  if (!old->type)\n+    old->type = type;\n+  else if (type && old->type != type)\n     {\n       if (flags & LOOKUP_COMPLAIN)\n         {\n           error (\"`%D' denotes an ambiguous type\",name);\n-          error (\"%J  first type here\", TYPE_MAIN_DECL (BINDING_TYPE (old)));\n+          error (\"%J  first type here\", TYPE_MAIN_DECL (old->type));\n           error (\"%J  other type here\", TYPE_MAIN_DECL (type));\n         }\n     }\n@@ -3258,8 +3258,7 @@ lookup_using_namespace (tree name, cxx_binding *val, tree usings, tree scope,\n         if (val1)\n           val = ambiguous_decl (name, val, val1, flags);\n       }\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n-                          BINDING_VALUE (val) != error_mark_node);\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val->value != error_mark_node);\n }\n \n /* [namespace.qual]\n@@ -3286,7 +3285,7 @@ qualified_lookup_using_namespace (tree name, tree scope, cxx_binding *result,\n       seen = tree_cons (scope, NULL_TREE, seen);\n       if (binding)\n         result = ambiguous_decl (name, result, binding, flags);\n-      if (!BINDING_VALUE (result) && !BINDING_TYPE (result))\n+      if (!result->value && !result->type)\n \t/* Consider using directives.  */\n \tfor (usings = DECL_NAMESPACE_USING (scope); usings;\n \t     usings = TREE_CHAIN (usings))\n@@ -3993,16 +3992,16 @@ do_toplevel_using_decl (tree decl)\n   \n   binding = binding_for_name (NAMESPACE_LEVEL (current_namespace), name);\n \n-  oldval = BINDING_VALUE (binding);\n-  oldtype = BINDING_TYPE (binding);\n+  oldval = binding->value;\n+  oldtype = binding->type;\n \n   do_nonmember_using_decl (scope, name, oldval, oldtype, &newval, &newtype);\n \n   /* Copy declarations found.  */\n   if (newval)\n-    BINDING_VALUE (binding) = newval;\n+    binding->value = newval;\n   if (newtype)\n-    BINDING_TYPE (binding) = newtype;\n+    binding->type = newtype;\n   return;\n }\n "}, {"sha": "3e8e4eb7d7d112dbeb29e38013eb0b5ff41ae86d", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/147135cc00893de2165e531331035892fd1addc5/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/147135cc00893de2165e531331035892fd1addc5/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=147135cc00893de2165e531331035892fd1addc5", "patch": "@@ -336,7 +336,7 @@ supplement_binding (cxx_binding *binding, tree decl)\n   else if (TREE_CODE (bval) == TYPE_DECL && DECL_ARTIFICIAL (bval))\n     {\n       /* The old binding was a type name.  It was placed in\n-\t BINDING_VALUE because it was thought, at the point it was\n+\t VALUE field because it was thought, at the point it was\n \t declared, to be the only entity with such a name.  Move the\n \t type name into the type slot; it is now hidden by the new\n \t binding.  */\n@@ -395,7 +395,7 @@ find_binding (cxx_scope *scope, cxx_binding *binding)\n   timevar_push (TV_NAME_LOOKUP);\n \n   for (; binding != NULL; binding = binding->previous)\n-    if (BINDING_SCOPE (binding) == scope)\n+    if (binding->scope == scope)\n       POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, binding);\n \n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, (cxx_binding *)0);\n@@ -409,7 +409,7 @@ cxx_scope_find_binding_for_name (cxx_scope *scope, tree name)\n   if (b)\n     {\n       /* Fold-in case where NAME is used only once.  */\n-      if (scope == BINDING_SCOPE (b) && b->previous == NULL)\n+      if (scope == b->scope && b->previous == NULL)\n         return b;\n       return find_binding (scope, b);\n     }\n@@ -430,7 +430,7 @@ binding_for_name (cxx_scope *scope, tree name)\n   /* Not found, make a new one.  */\n   result = cxx_binding_make (NULL, NULL);\n   result->previous = IDENTIFIER_NAMESPACE_BINDINGS (name);\n-  BINDING_SCOPE (result) = scope;\n+  result->scope = scope;\n   result->is_local = false;\n   result->value_is_inherited = false;\n   IDENTIFIER_NAMESPACE_BINDINGS (name) = result;\n@@ -465,10 +465,8 @@ set_namespace_binding (tree name, tree scope, tree val)\n   if (scope == NULL_TREE)\n     scope = global_namespace;\n   b = binding_for_name (NAMESPACE_LEVEL (scope), name);\n-  if (!BINDING_VALUE (b)\n-      || TREE_CODE (val) == OVERLOAD \n-      || val == error_mark_node)\n-    BINDING_VALUE (b) = val;\n+  if (!b->value || TREE_CODE (val) == OVERLOAD || val == error_mark_node)\n+    b->value = val;\n   else\n     supplement_binding (b, val);\n   timevar_pop (TV_NAME_LOOKUP);"}, {"sha": "923f4806adc8e3d71aba919d7ef4869a56ad54b1", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/147135cc00893de2165e531331035892fd1addc5/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/147135cc00893de2165e531331035892fd1addc5/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=147135cc00893de2165e531331035892fd1addc5", "patch": "@@ -72,22 +72,10 @@ typedef struct cp_binding_level cxx_scope;\n    or namespace scope.  */\n #define LOCAL_BINDING_P(NODE) ((NODE)->is_local)\n \n-/* Nonzero if BINDING_VALUE is from a base class of the class which is\n+/* True if NODE->value is from a base class of the class which is\n    currently being defined.  */\n #define INHERITED_VALUE_BINDING_P(NODE) ((NODE)->value_is_inherited)\n \n-/* For a binding between a name and an entity at a non-local scope,\n-   defines the scope where the binding is declared.  (Either a class\n-   _TYPE node, or a NAMESPACE_DECL.).  */\n-#define BINDING_SCOPE(NODE) ((NODE)->scope)\n-\n-/* This is the declaration bound to the name. Possible values:\n-   variable, overloaded function, namespace, template, enumerator.  */\n-#define BINDING_VALUE(NODE) ((NODE)->value)\n-\n-/* If name is bound to a type, this is the type (struct, union, enum).  */\n-#define BINDING_TYPE(NODE)   ((NODE)->type)\n-\n /* Zero out a cxx_binding pointed to by B.  */\n #define cxx_binding_clear(B) memset ((B), 0, sizeof (cxx_binding))\n "}]}