{"sha": "33f925094d02ce40872d494d384d4494a4313779", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzNmOTI1MDk0ZDAyY2U0MDg3MmQ0OTRkMzg0ZDQ0OTRhNDMxMzc3OQ==", "commit": {"author": {"name": "Marius Hillenbrand", "email": "mhillen@linux.ibm.com", "date": "2020-12-04T09:38:58Z"}, "committer": {"name": "Marius Hillenbrand", "email": "mhillen@linux.ibm.com", "date": "2020-12-17T10:47:23Z"}, "message": "IBM Z: Detect libc's float_t behavior on cross compiles\n\nWhen cross-compiling GCC with target libc headers available and\nconfigure option --enable-s390-excess-float-precision has been omitted,\nidentify whether they clamp float_t to double or respect\n__FLT_EVAL_METHOD__ via a compile test that coerces the build-system\ncompiler to use the target headers. Then derive the setting from that.\n\ngcc/ChangeLog:\n\n2020-12-16  Marius Hillenbrand  <mhillen@linux.ibm.com>\n\n\t* configure.ac: Change --enable-s390-excess-float-precision\n\tdefault behavior for cross compiles with target headers.\n\t* configure: Regenerate.\n\t* doc/install.texi: Adjust documentation.", "tree": {"sha": "38dbb5b156c90f3c7b9ec9eb5ba894f3cc8a8329", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38dbb5b156c90f3c7b9ec9eb5ba894f3cc8a8329"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33f925094d02ce40872d494d384d4494a4313779", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33f925094d02ce40872d494d384d4494a4313779", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33f925094d02ce40872d494d384d4494a4313779", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33f925094d02ce40872d494d384d4494a4313779/comments", "author": {"login": "mhillenbrand", "id": 1150167, "node_id": "MDQ6VXNlcjExNTAxNjc=", "avatar_url": "https://avatars.githubusercontent.com/u/1150167?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mhillenbrand", "html_url": "https://github.com/mhillenbrand", "followers_url": "https://api.github.com/users/mhillenbrand/followers", "following_url": "https://api.github.com/users/mhillenbrand/following{/other_user}", "gists_url": "https://api.github.com/users/mhillenbrand/gists{/gist_id}", "starred_url": "https://api.github.com/users/mhillenbrand/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mhillenbrand/subscriptions", "organizations_url": "https://api.github.com/users/mhillenbrand/orgs", "repos_url": "https://api.github.com/users/mhillenbrand/repos", "events_url": "https://api.github.com/users/mhillenbrand/events{/privacy}", "received_events_url": "https://api.github.com/users/mhillenbrand/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mhillenbrand", "id": 1150167, "node_id": "MDQ6VXNlcjExNTAxNjc=", "avatar_url": "https://avatars.githubusercontent.com/u/1150167?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mhillenbrand", "html_url": "https://github.com/mhillenbrand", "followers_url": "https://api.github.com/users/mhillenbrand/followers", "following_url": "https://api.github.com/users/mhillenbrand/following{/other_user}", "gists_url": "https://api.github.com/users/mhillenbrand/gists{/gist_id}", "starred_url": "https://api.github.com/users/mhillenbrand/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mhillenbrand/subscriptions", "organizations_url": "https://api.github.com/users/mhillenbrand/orgs", "repos_url": "https://api.github.com/users/mhillenbrand/repos", "events_url": "https://api.github.com/users/mhillenbrand/events{/privacy}", "received_events_url": "https://api.github.com/users/mhillenbrand/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f49508599f548f4b2e5f2c876be7247a1c5f8ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f49508599f548f4b2e5f2c876be7247a1c5f8ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f49508599f548f4b2e5f2c876be7247a1c5f8ff"}], "stats": {"total": 126, "additions": 85, "deletions": 41}, "files": [{"sha": "fbe92089640a6040c043d33ef8d29cebdf4f365e", "filename": "gcc/configure", "status": "modified", "additions": 44, "deletions": 23, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f925094d02ce40872d494d384d4494a4313779/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f925094d02ce40872d494d384d4494a4313779/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=33f925094d02ce40872d494d384d4494a4313779", "patch": "@@ -31855,9 +31855,9 @@ $as_echo \"$ld_pushpopstate_support\" >&6; }\n # gcc describes its behavior via the macro __FLT_EVAL_METHOD__ and glibc derives\n # float_t from that, this behavior can be configured with\n # --enable-s390-excess-float-precision. When given as enabled, that flag selects\n-# the old model. When omitted, native builds will derive the flag from the\n-# behavior of glibc. When glibc clamps float_t to double, gcc follows the old\n-# model. In any other case, it defaults to the new model.\n+# the old model. When omitted, native builds and cross compiles that have target\n+# libc headers will detect whether libc clamps float_t to double and in that\n+# case maintain the old model. Otherwise, they will default to the new model.\n # Check whether --enable-s390-excess-float-precision was given.\n if test \"${enable_s390_excess_float_precision+set}\" = set; then :\n   enableval=$enable_s390_excess_float_precision;\n@@ -31868,42 +31868,63 @@ fi\n \n case $target in\n   s390*-linux*)\n-  if test \"$target\" = \"$host\" -a \"$host\" = \"$build\" -a \\\n-      x\"$enable_s390_excess_float_precision\" = xauto; then\n-    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for glibc clamping float_t to double\" >&5\n+  if test x\"$enable_s390_excess_float_precision\" = xauto; then\n+    # Can we autodetect the behavior of the target libc?\n+    if test \"$target\" = \"$host\" -a \"$host\" = \"$build\"; then\n+      enable_s390_excess_float_precision=autodetect\n+    elif test \"x$with_headers\" != xno; then\n+      # cross build. are target headers available?\n+      # carefully coerce the build-system compiler to use target headers\n+      saved_CXXFLAGS=\"$CXXFLAGS\"\n+      CROSS_TEST_CXXFLAGS=\"-nostdinc ${XGCC_FLAGS_FOR_TARGET//-B/-idirafter/}\"\n+      CXXFLAGS=\"$CROSS_TEST_CXXFLAGS\"\n+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+#include <math.h>\n+\n+_ACEOF\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n+  enable_s390_excess_float_precision=autodetect\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+      CXXFLAGS=\"$saved_CXXFLAGS\"\n+    fi\n+\n+    if test x\"$enable_s390_excess_float_precision\" = xautodetect; then\n+      saved_CXXFLAGS=\"$CXXFLAGS\"\n+      if ! test \"$target\" = \"$host\" -a \"$host\" = \"$build\"; then\n+        CXXFLAGS=\"$CROSS_TEST_CXXFLAGS\"\n+\tunset CROSS_TEST_CXXFLAGS\n+      fi\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for glibc clamping float_t to double\" >&5\n $as_echo_n \"checking for glibc clamping float_t to double... \" >&6; }\n if ${gcc_cv_float_t_clamped_to_double+:} false; then :\n   $as_echo_n \"(cached) \" >&6\n else\n-  if test \"$cross_compiling\" = yes; then :\n-  { { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n-$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\n-as_fn_error $? \"cannot run test program while cross compiling\n-See \\`config.log' for more details\" \"$LINENO\" 5; }\n-else\n-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+\n+        cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n /* end confdefs.h.  */\n \n #define __FLT_EVAL_METHOD__ 0\n #include <math.h>\n-int main() {\n-  return !(sizeof(float_t) == sizeof(double));\n-}\n+int dummy[sizeof(float_t) == sizeof(double) ? 1 : -1];\n+\n _ACEOF\n-if ac_fn_cxx_try_run \"$LINENO\"; then :\n+if ac_fn_cxx_try_compile \"$LINENO\"; then :\n   gcc_cv_float_t_clamped_to_double=yes\n else\n   gcc_cv_float_t_clamped_to_double=no\n fi\n-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n-  conftest.$ac_objext conftest.beam conftest.$ac_ext\n-fi\n-\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n fi\n { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_float_t_clamped_to_double\" >&5\n $as_echo \"$gcc_cv_float_t_clamped_to_double\" >&6; }\n-    if test x\"$gcc_cv_float_t_clamped_to_double\" = xyes; then\n-      enable_s390_excess_float_precision=yes\n+      CXXFLAGS=\"$saved_CXXFLAGS\"\n+      enable_s390_excess_float_precision=\"$gcc_cv_float_t_clamped_to_double\"\n+    else\n+      # no way to detect behavior of target libc, default to new model\n+      enable_s390_excess_float_precision=no\n     fi\n   fi\n "}, {"sha": "89b9981e8725a720d9357c0ec8bc8c037a122ed6", "filename": "gcc/configure.ac", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f925094d02ce40872d494d384d4494a4313779/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f925094d02ce40872d494d384d4494a4313779/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=33f925094d02ce40872d494d384d4494a4313779", "patch": "@@ -7375,9 +7375,9 @@ AC_MSG_RESULT($ld_pushpopstate_support)\n # gcc describes its behavior via the macro __FLT_EVAL_METHOD__ and glibc derives\n # float_t from that, this behavior can be configured with\n # --enable-s390-excess-float-precision. When given as enabled, that flag selects\n-# the old model. When omitted, native builds will derive the flag from the\n-# behavior of glibc. When glibc clamps float_t to double, gcc follows the old\n-# model. In any other case, it defaults to the new model.\n+# the old model. When omitted, native builds and cross compiles that have target\n+# libc headers will detect whether libc clamps float_t to double and in that\n+# case maintain the old model. Otherwise, they will default to the new model.\n AC_ARG_ENABLE(s390-excess-float-precision,\n   [AS_HELP_STRING([--enable-s390-excess-float-precision],\n \t\t  [on s390 targets, evaluate float with double precision\n@@ -7386,20 +7386,42 @@ AC_ARG_ENABLE(s390-excess-float-precision,\n \n case $target in\n   s390*-linux*)\n-  if test \"$target\" = \"$host\" -a \"$host\" = \"$build\" -a \\\n-      x\"$enable_s390_excess_float_precision\" = xauto; then\n-    AC_CACHE_CHECK([for glibc clamping float_t to double],\n-      gcc_cv_float_t_clamped_to_double,\n-      [AC_RUN_IFELSE([AC_LANG_SOURCE([\n+  if test x\"$enable_s390_excess_float_precision\" = xauto; then\n+    # Can we autodetect the behavior of the target libc?\n+    if test \"$target\" = \"$host\" -a \"$host\" = \"$build\"; then\n+      enable_s390_excess_float_precision=autodetect\n+    elif test \"x$with_headers\" != xno; then\n+      # cross build. are target headers available?\n+      # carefully coerce the build-system compiler to use target headers\n+      saved_CXXFLAGS=\"$CXXFLAGS\"\n+      CROSS_TEST_CXXFLAGS=\"-nostdinc ${XGCC_FLAGS_FOR_TARGET//-B/-idirafter/}\"\n+      CXXFLAGS=\"$CROSS_TEST_CXXFLAGS\"\n+      AC_COMPILE_IFELSE([AC_LANG_SOURCE([[\n+#include <math.h>\n+]])], [enable_s390_excess_float_precision=autodetect], [])\n+      CXXFLAGS=\"$saved_CXXFLAGS\"\n+    fi\n+\n+    if test x\"$enable_s390_excess_float_precision\" = xautodetect; then\n+      saved_CXXFLAGS=\"$CXXFLAGS\"\n+      if ! test \"$target\" = \"$host\" -a \"$host\" = \"$build\"; then\n+        CXXFLAGS=\"$CROSS_TEST_CXXFLAGS\"\n+\tunset CROSS_TEST_CXXFLAGS\n+      fi\n+      AC_CACHE_CHECK([for glibc clamping float_t to double],\n+        gcc_cv_float_t_clamped_to_double, [\n+        AC_COMPILE_IFELSE([AC_LANG_SOURCE([[\n #define __FLT_EVAL_METHOD__ 0\n #include <math.h>\n-int main() {\n-  return !(sizeof(float_t) == sizeof(double));\n-}])],\n-        [gcc_cv_float_t_clamped_to_double=yes],\n-        [gcc_cv_float_t_clamped_to_double=no])])\n-    if test x\"$gcc_cv_float_t_clamped_to_double\" = xyes; then\n-      enable_s390_excess_float_precision=yes\n+int dummy[sizeof(float_t) == sizeof(double) ? 1 : -1];\n+]])],\n+          [gcc_cv_float_t_clamped_to_double=yes],\n+          [gcc_cv_float_t_clamped_to_double=no])])\n+      CXXFLAGS=\"$saved_CXXFLAGS\"\n+      enable_s390_excess_float_precision=\"$gcc_cv_float_t_clamped_to_double\"\n+    else\n+      # no way to detect behavior of target libc, default to new model\n+      enable_s390_excess_float_precision=no\n     fi\n   fi\n "}, {"sha": "e30d2fc95bcd0f5edc08299e53519928c94df17b", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f925094d02ce40872d494d384d4494a4313779/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f925094d02ce40872d494d384d4494a4313779/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=33f925094d02ce40872d494d384d4494a4313779", "patch": "@@ -2277,9 +2277,10 @@ On s390(x) targets, enable treatment of float expressions with double precision\n when in standards-compliant mode (e.g., when @code{--std=c99} or\n @code{-fexcess-precision=standard} are given).\n \n-For a native build, the option's default is derived from glibc's behavior. When\n-glibc clamps float_t to double, gcc follows and enables the option. In all other\n-cases, it defaults to off.\n+For a native build and cross compiles that have target headers, the option's\n+default is derived from glibc's behavior. When glibc clamps float_t to double,\n+GCC follows and enables the option. For other cross compiles, the default is\n+disabled.\n @end table\n \n @subheading Cross-Compiler-Specific Options"}]}