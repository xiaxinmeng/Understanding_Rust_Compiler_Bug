{"sha": "db4c7386155ebccb152e574bb9786f4d982fdea3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGI0YzczODYxNTVlYmNjYjE1MmU1NzRiYjk3ODZmNGQ5ODJmZGVhMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-08-17T09:44:12Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-08-17T09:44:12Z"}, "message": "re PR tree-optimization/27865 (tree check failure building FreePOOMA)\n\n\tPR tree-optimization/27865\n\t* reload1.c (forget_marked_reloads): New function.\n\t(forget_old_reloads_1): When data are passed, just mark the registers\n\tfor later removal.\n\t(reload_as_needed): Use the new mechanizm.\n\nFrom-SVN: r116220", "tree": {"sha": "1387baa691799365777e206414d997c3c6d86614", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1387baa691799365777e206414d997c3c6d86614"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db4c7386155ebccb152e574bb9786f4d982fdea3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db4c7386155ebccb152e574bb9786f4d982fdea3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db4c7386155ebccb152e574bb9786f4d982fdea3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db4c7386155ebccb152e574bb9786f4d982fdea3/comments", "author": null, "committer": null, "parents": [{"sha": "04499540e222f831f1ebc76c726701779001b8ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04499540e222f831f1ebc76c726701779001b8ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04499540e222f831f1ebc76c726701779001b8ee"}], "stats": {"total": 90, "additions": 68, "deletions": 22}, "files": [{"sha": "6b36ab8a95fcb29d2287f50484ed98af18ce9341", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db4c7386155ebccb152e574bb9786f4d982fdea3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db4c7386155ebccb152e574bb9786f4d982fdea3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db4c7386155ebccb152e574bb9786f4d982fdea3", "patch": "@@ -1,3 +1,11 @@\n+2006-08-17  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR tree-optimization/27865\n+\t* reload1.c (forget_marked_reloads): New function.\n+\t(forget_old_reloads_1): When data are passed, just mark the registers\n+\tfor later removal.\n+\t(reload_as_needed): Use the new mechanizm.\n+\n 2006-08-17  Alexandre Oliva  <aoliva@redhat.com>\n \n \tPR target/28146"}, {"sha": "a86f6f560e3d1b6510849abdb903b95754de5851", "filename": "gcc/reload1.c", "status": "modified", "additions": 60, "deletions": 22, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db4c7386155ebccb152e574bb9786f4d982fdea3/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db4c7386155ebccb152e574bb9786f4d982fdea3/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=db4c7386155ebccb152e574bb9786f4d982fdea3", "patch": "@@ -408,6 +408,7 @@ static void count_pseudo (int);\n static void order_regs_for_reload (struct insn_chain *);\n static void reload_as_needed (int);\n static void forget_old_reloads_1 (rtx, rtx, void *);\n+static void forget_marked_reloads (regset);\n static int reload_reg_class_lower (const void *, const void *);\n static void mark_reload_reg_in_use (unsigned int, int, enum reload_type,\n \t\t\t\t    enum machine_mode);\n@@ -3907,8 +3908,9 @@ reload_as_needed (int live_known)\n \n       else if (INSN_P (insn))\n \t{\n-\t  rtx oldpat = copy_rtx (PATTERN (insn));\n-\n+\t  regset_head regs_to_forget;\n+\t  INIT_REG_SET (&regs_to_forget);\n+\t  note_stores (PATTERN (insn), forget_old_reloads_1, &regs_to_forget);\n \t  /* If this is a USE and CLOBBER of a MEM, ensure that any\n \t     references to eliminable registers have been removed.  */\n \n@@ -3928,6 +3930,7 @@ reload_as_needed (int live_known)\n \t      if (NOTE_P (insn))\n \t\t{\n \t\t  update_eliminable_offsets ();\n+\t\t  CLEAR_REG_SET (&regs_to_forget);\n \t\t  continue;\n \t\t}\n \t    }\n@@ -4014,7 +4017,8 @@ reload_as_needed (int live_known)\n \t     for this insn in order to be stored in\n \t     (obeying register constraints).  That is correct; such reload\n \t     registers ARE still valid.  */\n-\t  note_stores (oldpat, forget_old_reloads_1, NULL);\n+\t  forget_marked_reloads (&regs_to_forget);\n+\t  CLEAR_REG_SET (&regs_to_forget);\n \n \t  /* There may have been CLOBBER insns placed after INSN.  So scan\n \t     between INSN and NEXT and use them to forget old reloads.  */\n@@ -4163,14 +4167,18 @@ reload_as_needed (int live_known)\n    unless X is an output reload reg of the current insn.\n \n    X may be a hard reg (the reload reg)\n-   or it may be a pseudo reg that was reloaded from.  */\n+   or it may be a pseudo reg that was reloaded from.  \n+\n+   When DATA is non-NULL just mark the registers in regset\n+   to be forgotten later.  */\n \n static void\n forget_old_reloads_1 (rtx x, rtx ignored ATTRIBUTE_UNUSED,\n-\t\t      void *data ATTRIBUTE_UNUSED)\n+\t\t      void *data)\n {\n   unsigned int regno;\n   unsigned int nr;\n+  regset regs = (regset) data;\n \n   /* note_stores does give us subregs of hard regs,\n      subreg_regno_offset requires a hard reg.  */\n@@ -4198,26 +4206,56 @@ forget_old_reloads_1 (rtx x, rtx ignored ATTRIBUTE_UNUSED,\n \t This can happen if a block-local pseudo is allocated to that reg\n \t and it wasn't spilled because this block's total need is 0.\n \t Then some insn might have an optional reload and use this reg.  */\n-      for (i = 0; i < nr; i++)\n-\t/* But don't do this if the reg actually serves as an output\n-\t   reload reg in the current instruction.  */\n-\tif (n_reloads == 0\n-\t    || ! TEST_HARD_REG_BIT (reg_is_output_reload, regno + i))\n-\t  {\n-\t    CLEAR_HARD_REG_BIT (reg_reloaded_valid, regno + i);\n-\t    CLEAR_HARD_REG_BIT (reg_reloaded_call_part_clobbered, regno + i);\n-\t    spill_reg_store[regno + i] = 0;\n-\t  }\n+      if (!regs)\n+\tfor (i = 0; i < nr; i++)\n+\t  /* But don't do this if the reg actually serves as an output\n+\t     reload reg in the current instruction.  */\n+\t  if (n_reloads == 0\n+\t      || ! TEST_HARD_REG_BIT (reg_is_output_reload, regno + i))\n+\t    {\n+\t      CLEAR_HARD_REG_BIT (reg_reloaded_valid, regno + i);\n+\t      CLEAR_HARD_REG_BIT (reg_reloaded_call_part_clobbered, regno + i);\n+\t      spill_reg_store[regno + i] = 0;\n+\t    }\n     }\n \n-  /* Since value of X has changed,\n-     forget any value previously copied from it.  */\n+  if (regs)\n+    while (nr-- > 0)\n+      SET_REGNO_REG_SET (regs, regno + nr);\n+  else\n+    {\n+      /* Since value of X has changed,\n+\t forget any value previously copied from it.  */\n+\n+      while (nr-- > 0)\n+\t/* But don't forget a copy if this is the output reload\n+\t   that establishes the copy's validity.  */\n+\tif (n_reloads == 0 || reg_has_output_reload[regno + nr] == 0)\n+\t  reg_last_reload_reg[regno + nr] = 0;\n+     }\n+}\n \n-  while (nr-- > 0)\n-    /* But don't forget a copy if this is the output reload\n-       that establishes the copy's validity.  */\n-    if (n_reloads == 0 || reg_has_output_reload[regno + nr] == 0)\n-      reg_last_reload_reg[regno + nr] = 0;\n+/* Forget the reloads marked in regset by previous function.  */\n+static void\n+forget_marked_reloads (regset regs)\n+{\n+  unsigned int reg;\n+  reg_set_iterator rsi;\n+  EXECUTE_IF_SET_IN_REG_SET (regs, 0, reg, rsi)\n+    {\n+      if (reg < FIRST_PSEUDO_REGISTER\n+\t  /* But don't do this if the reg actually serves as an output\n+\t     reload reg in the current instruction.  */\n+\t  && (n_reloads == 0\n+\t      || ! TEST_HARD_REG_BIT (reg_is_output_reload, reg)))\n+\t  {\n+\t    CLEAR_HARD_REG_BIT (reg_reloaded_valid, reg);\n+\t    CLEAR_HARD_REG_BIT (reg_reloaded_call_part_clobbered, reg);\n+\t    spill_reg_store[reg] = 0;\n+\t  }\n+      if (n_reloads == 0 || reg_has_output_reload[reg] == 0)\n+\treg_last_reload_reg[reg] = 0;\n+    }\n }\n \f\n /* The following HARD_REG_SETs indicate when each hard register is"}]}