{"sha": "fc5515a8a069396531c8f33678a392a57f02f5fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM1NTE1YThhMDY5Mzk2NTMxYzhmMzM2NzhhMzkyYTU3ZjAyZjVmZA==", "commit": {"author": {"name": "Frank Ch. Eigler", "email": "fche@redhat.com", "date": "2004-07-27T18:03:18Z"}, "committer": {"name": "Frank Ch. Eigler", "email": "fche@gcc.gnu.org", "date": "2004-07-27T18:03:18Z"}, "message": "splay-tree.[ch]: Remove.\n\n2004-07-27  Frank Ch. Eigler  <fche@redhat.com>\n\n\t* splay-tree.[ch]: Remove.  Merge contents into ...\n\t* mf-runtime.c: ... here, renaming symbols and making all functions\n\tstatic.  Remove unused min/max functions.\n\t* Makefile.am: Forget about splay-tree.[ch].\n\t* Makefile.in, testsuite/Makefile.in: Regenerated.\n\nFrom-SVN: r85224", "tree": {"sha": "5e96c1cc127c61d5fadb32d5f5239c9b92d065e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e96c1cc127c61d5fadb32d5f5239c9b92d065e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc5515a8a069396531c8f33678a392a57f02f5fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc5515a8a069396531c8f33678a392a57f02f5fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc5515a8a069396531c8f33678a392a57f02f5fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc5515a8a069396531c8f33678a392a57f02f5fd/comments", "author": {"login": "fche", "id": 588885, "node_id": "MDQ6VXNlcjU4ODg4NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/588885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fche", "html_url": "https://github.com/fche", "followers_url": "https://api.github.com/users/fche/followers", "following_url": "https://api.github.com/users/fche/following{/other_user}", "gists_url": "https://api.github.com/users/fche/gists{/gist_id}", "starred_url": "https://api.github.com/users/fche/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fche/subscriptions", "organizations_url": "https://api.github.com/users/fche/orgs", "repos_url": "https://api.github.com/users/fche/repos", "events_url": "https://api.github.com/users/fche/events{/privacy}", "received_events_url": "https://api.github.com/users/fche/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "00bdb87f8e8107ade3abd37e37db8270a0016bc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00bdb87f8e8107ade3abd37e37db8270a0016bc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00bdb87f8e8107ade3abd37e37db8270a0016bc3"}], "stats": {"total": 1290, "additions": 592, "deletions": 698}, "files": [{"sha": "4b29756ebee942ae39d53a181e132fd88654ccca", "filename": "libmudflap/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc5515a8a069396531c8f33678a392a57f02f5fd/libmudflap%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc5515a8a069396531c8f33678a392a57f02f5fd/libmudflap%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2FChangeLog?ref=fc5515a8a069396531c8f33678a392a57f02f5fd", "patch": "@@ -1,3 +1,11 @@\n+2004-07-27  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\t* splay-tree.[ch]: Remove.  Merge contents into ...\n+\t* mf-runtime.c: ... here, renaming symbols and making all functions\n+\tstatic.  Remove unused min/max functions.\n+\t* Makefile.am: Forget about splay-tree.[ch].\n+\t* Makefile.in, testsuite/Makefile.in: Regenerated.\n+\n 2004-07-21  Frank Ch. Eigler  <fche@redhat.com>\n \n \t* mf-runtime.c (__mfu_check): Remove mistaken mode-nop handling."}, {"sha": "cdb608531f7caf8b75a8ed83b18af6efc1d77e67", "filename": "libmudflap/Makefile.am", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc5515a8a069396531c8f33678a392a57f02f5fd/libmudflap%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc5515a8a069396531c8f33678a392a57f02f5fd/libmudflap%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2FMakefile.am?ref=fc5515a8a069396531c8f33678a392a57f02f5fd", "patch": "@@ -26,15 +26,14 @@ libmudflap_la_SOURCES = \\\n \tmf-heuristics.c \\\n \tmf-hooks1.c \\\n \tmf-hooks2.c\n-mf-runtime.lo: mf-runtime.c splay-tree.c splay-tree.h\n libmudflap_la_LIBADD = \n libmudflap_la_DEPENDENCIES = $(libmudflap_la_LIBADD)\n libmudflap_la_LDFLAGS = -version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n \n clean-local:\n \trm -f pth/*.o pth/*.lo\n \n-pth/mf-runtime.lo: mf-runtime.c mf-runtime.h mf-impl.h splay-tree.c splay-tree.h\n+pth/mf-runtime.lo: mf-runtime.c mf-runtime.h mf-impl.h\n \t$(LTCOMPILE) -DLIBMUDFLAPTH -c $(srcdir)/mf-runtime.c -o $@\n pth/mf-heuristics.lo: mf-heuristics.c mf-runtime.h mf-impl.h\n \t$(LTCOMPILE) -DLIBMUDFLAPTH -c $(srcdir)/mf-heuristics.c -o $@"}, {"sha": "1b668fb27cd94174bcd684a82370e9120c180f6e", "filename": "libmudflap/Makefile.in", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc5515a8a069396531c8f33678a392a57f02f5fd/libmudflap%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc5515a8a069396531c8f33678a392a57f02f5fd/libmudflap%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2FMakefile.in?ref=fc5515a8a069396531c8f33678a392a57f02f5fd", "patch": "@@ -818,12 +818,11 @@ uninstall-info: uninstall-info-recursive\n \tuninstall uninstall-am uninstall-includeHEADERS \\\n \tuninstall-info-am uninstall-toolexeclibLTLIBRARIES\n \n-mf-runtime.lo: mf-runtime.c splay-tree.c splay-tree.h\n \n clean-local:\n \trm -f pth/*.o pth/*.lo\n \n-pth/mf-runtime.lo: mf-runtime.c mf-runtime.h mf-impl.h splay-tree.c splay-tree.h\n+pth/mf-runtime.lo: mf-runtime.c mf-runtime.h mf-impl.h\n \t$(LTCOMPILE) -DLIBMUDFLAPTH -c $(srcdir)/mf-runtime.c -o $@\n pth/mf-heuristics.lo: mf-heuristics.c mf-runtime.h mf-impl.h\n \t$(LTCOMPILE) -DLIBMUDFLAPTH -c $(srcdir)/mf-heuristics.c -o $@"}, {"sha": "176898830e1a1305d3ea11711519fb182660e09d", "filename": "libmudflap/mf-runtime.c", "status": "modified", "additions": 582, "deletions": 33, "changes": 615, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc5515a8a069396531c8f33678a392a57f02f5fd/libmudflap%2Fmf-runtime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc5515a8a069396531c8f33678a392a57f02f5fd/libmudflap%2Fmf-runtime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-runtime.c?ref=fc5515a8a069396531c8f33678a392a57f02f5fd", "patch": "@@ -2,6 +2,8 @@\n    Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n    Contributed by Frank Ch. Eigler <fche@redhat.com>\n    and Graydon Hoare <graydon@redhat.com>\n+   Splay Tree code originally by Mark Mitchell <mark@markmitchell.com>,\n+   adapted from libiberty.\n \n This file is part of GCC.\n \n@@ -67,9 +69,62 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #include \"mf-runtime.h\"\n #include \"mf-impl.h\"\n-#include \"splay-tree.h\"\n \n \n+/* ------------------------------------------------------------------------ */\n+/* Splay-tree implementation.  */\n+\n+typedef uintptr_t mfsplay_tree_key;\n+typedef void *mfsplay_tree_value;\n+\n+/* Forward declaration for a node in the tree.  */\n+typedef struct mfsplay_tree_node_s *mfsplay_tree_node;\n+\n+/* The type of a function used to iterate over the tree.  */\n+typedef int (*mfsplay_tree_foreach_fn) (mfsplay_tree_node, void *);\n+\n+/* The nodes in the splay tree.  */\n+struct mfsplay_tree_node_s\n+{\n+  /* Data.  */\n+  mfsplay_tree_key key;\n+  mfsplay_tree_value value;\n+  /* Children.  */\n+  mfsplay_tree_node left;\n+  mfsplay_tree_node right;\n+  /* XXX: The addition of a parent pointer may eliminate some recursion.  */\n+};\n+\n+/* The splay tree itself.  */\n+struct mfsplay_tree_s\n+{\n+  /* The root of the tree.  */\n+  mfsplay_tree_node root;\n+\n+  /* The last key value for which the tree has been splayed, but not\n+     since modified.  */\n+  mfsplay_tree_key last_splayed_key;\n+  int last_splayed_key_p;\n+\n+  /* Statistics.  */\n+  unsigned num_keys;\n+\n+  /* Traversal recursion control flags.  */\n+  unsigned max_depth;\n+  unsigned depth;\n+  unsigned rebalance_p;\n+};\n+typedef struct mfsplay_tree_s *mfsplay_tree;\n+\n+static mfsplay_tree mfsplay_tree_new (void);\n+static mfsplay_tree_node mfsplay_tree_insert (mfsplay_tree, mfsplay_tree_key, mfsplay_tree_value);\n+static void mfsplay_tree_remove (mfsplay_tree, mfsplay_tree_key);\n+static mfsplay_tree_node mfsplay_tree_lookup (mfsplay_tree, mfsplay_tree_key);\n+static mfsplay_tree_node mfsplay_tree_predecessor (mfsplay_tree, mfsplay_tree_key);\n+static mfsplay_tree_node mfsplay_tree_successor (mfsplay_tree, mfsplay_tree_key);\n+static int mfsplay_tree_foreach (mfsplay_tree, mfsplay_tree_foreach_fn, void *);\n+static void mfsplay_tree_rebalance (mfsplay_tree sp);\n+\n /* ------------------------------------------------------------------------ */\n /* Utility macros */\n \n@@ -217,7 +272,7 @@ static unsigned __mf_find_dead_objects (uintptr_t ptr_low, uintptr_t ptr_high,\n static void __mf_adapt_cache ();\n static void __mf_describe_object (__mf_object_t *obj);\n static unsigned __mf_watch_or_not (void *ptr, size_t sz, char flag);\n-static splay_tree __mf_object_tree (int type);\n+static mfsplay_tree __mf_object_tree (int type);\n static void __mf_link_object (__mf_object_t *node);\n static void __mf_unlink_object (__mf_object_t *node);\n \n@@ -611,13 +666,13 @@ struct __mf_dynamic_entry __mf_dynamic [] =\n /* ------------------------------------------------------------------------ */\n \n /* Lookup & manage automatic initialization of the five or so splay trees.  */\n-static splay_tree\n+static mfsplay_tree\n __mf_object_tree (int type)\n {\n-  static splay_tree trees [__MF_TYPE_MAX+1];\n+  static mfsplay_tree trees [__MF_TYPE_MAX+1];\n   assert (type >= 0 && type <= __MF_TYPE_MAX);\n   if (UNLIKELY (trees[type] == NULL))\n-    trees[type] = splay_tree_new ();\n+    trees[type] = mfsplay_tree_new ();\n   return trees[type];\n }\n \n@@ -1254,7 +1309,7 @@ struct tree_stats\n \n \n static int\n-__mf_adapt_cache_fn (splay_tree_node n, void *param)\n+__mf_adapt_cache_fn (mfsplay_tree_node n, void *param)\n {\n   __mf_object_t *obj = (__mf_object_t *) n->value;\n   struct tree_stats *s = (struct tree_stats *) param;\n@@ -1311,11 +1366,11 @@ __mf_adapt_cache ()\n \n   memset (&s, 0, sizeof (s));\n \n-  splay_tree_foreach (__mf_object_tree (__MF_TYPE_HEAP), __mf_adapt_cache_fn, (void *) & s);\n-  splay_tree_foreach (__mf_object_tree (__MF_TYPE_HEAP_I), __mf_adapt_cache_fn, (void *) & s);\n-  splay_tree_foreach (__mf_object_tree (__MF_TYPE_STACK), __mf_adapt_cache_fn, (void *) & s);\n-  splay_tree_foreach (__mf_object_tree (__MF_TYPE_STATIC), __mf_adapt_cache_fn, (void *) & s);\n-  splay_tree_foreach (__mf_object_tree (__MF_TYPE_GUESS), __mf_adapt_cache_fn, (void *) & s);\n+  mfsplay_tree_foreach (__mf_object_tree (__MF_TYPE_HEAP), __mf_adapt_cache_fn, (void *) & s);\n+  mfsplay_tree_foreach (__mf_object_tree (__MF_TYPE_HEAP_I), __mf_adapt_cache_fn, (void *) & s);\n+  mfsplay_tree_foreach (__mf_object_tree (__MF_TYPE_STACK), __mf_adapt_cache_fn, (void *) & s);\n+  mfsplay_tree_foreach (__mf_object_tree (__MF_TYPE_STATIC), __mf_adapt_cache_fn, (void *) & s);\n+  mfsplay_tree_foreach (__mf_object_tree (__MF_TYPE_GUESS), __mf_adapt_cache_fn, (void *) & s);\n \n   /* Maybe we're dealing with funny aging/adaptation parameters, or an\n      empty tree.  Just leave the cache alone in such cases, rather\n@@ -1385,11 +1440,11 @@ __mf_find_objects2 (uintptr_t ptr_low, uintptr_t ptr_high,\n                     __mf_object_t **objs, unsigned max_objs, int type)\n {\n   unsigned count = 0;\n-  splay_tree t = __mf_object_tree (type);\n-  splay_tree_key k = (splay_tree_key) ptr_low;\n+  mfsplay_tree t = __mf_object_tree (type);\n+  mfsplay_tree_key k = (mfsplay_tree_key) ptr_low;\n   int direction;\n \n-  splay_tree_node n = splay_tree_lookup (t, k);\n+  mfsplay_tree_node n = mfsplay_tree_lookup (t, k);\n   /* An exact match for base address implies a hit.  */\n   if (n != NULL)\n     {\n@@ -1402,13 +1457,13 @@ __mf_find_objects2 (uintptr_t ptr_low, uintptr_t ptr_high,\n   for (direction = 0; direction < 2; direction ++)\n     {\n       /* Reset search origin.  */\n-      k = (splay_tree_key) ptr_low;\n+      k = (mfsplay_tree_key) ptr_low;\n \n       while (1)\n         {\n           __mf_object_t *obj;\n               \n-          n = (direction == 0 ? splay_tree_successor (t, k) : splay_tree_predecessor (t, k));\n+          n = (direction == 0 ? mfsplay_tree_successor (t, k) : mfsplay_tree_predecessor (t, k));\n           if (n == NULL) break;\n           obj = (__mf_object_t *) n->value;\n               \n@@ -1419,7 +1474,7 @@ __mf_find_objects2 (uintptr_t ptr_low, uintptr_t ptr_high,\n             objs[count] = (__mf_object_t *) n->value;\n           count ++;\n \n-          k = (splay_tree_key) obj->low;\n+          k = (mfsplay_tree_key) obj->low;\n         }\n     }\n \n@@ -1461,17 +1516,17 @@ __mf_find_objects (uintptr_t ptr_low, uintptr_t ptr_high,\n static void\n __mf_link_object (__mf_object_t *node)\n {\n-  splay_tree t = __mf_object_tree (node->type);\n-  splay_tree_insert (t, (splay_tree_key) node->low, (splay_tree_value) node);\n+  mfsplay_tree t = __mf_object_tree (node->type);\n+  mfsplay_tree_insert (t, (mfsplay_tree_key) node->low, (mfsplay_tree_value) node);\n }\n \n /* __mf_unlink_object */\n \n static void\n __mf_unlink_object (__mf_object_t *node)\n {\n-  splay_tree t = __mf_object_tree (node->type);\n-  splay_tree_remove (t, (splay_tree_key) node->low);\n+  mfsplay_tree t = __mf_object_tree (node->type);\n+  mfsplay_tree_remove (t, (mfsplay_tree_key) node->low);\n }\n \n /* __mf_find_dead_objects */\n@@ -1623,7 +1678,7 @@ __mf_describe_object (__mf_object_t *obj)\n \n \n static int\n-__mf_report_leaks_fn (splay_tree_node n, void *param)\n+__mf_report_leaks_fn (mfsplay_tree_node n, void *param)\n {\n   __mf_object_t *node = (__mf_object_t *) n->value;\n   unsigned *count = (unsigned *) param;\n@@ -1643,9 +1698,9 @@ __mf_report_leaks ()\n {\n   unsigned count = 0;\n \n-  (void) splay_tree_foreach (__mf_object_tree (__MF_TYPE_HEAP),\n+  (void) mfsplay_tree_foreach (__mf_object_tree (__MF_TYPE_HEAP),\n                              __mf_report_leaks_fn, & count);\n-  (void) splay_tree_foreach (__mf_object_tree (__MF_TYPE_HEAP_I),\n+  (void) mfsplay_tree_foreach (__mf_object_tree (__MF_TYPE_HEAP_I),\n                              __mf_report_leaks_fn, & count);\n \n   return count;\n@@ -2162,25 +2217,519 @@ __assert_fail (const char *msg, const char *file, unsigned line, const char *fun\n \n \n \n-\n-\n-/* #include the generic splay tree implementation from libiberty here, to\n-   ensure that it uses our memory allocation primitives.  */\n+/* Adapted splay tree code, originally from libiberty.  It has been\n+   specialized for libmudflap as requested by RMS.  */\n \n static void\n-splay_tree_free (void *p)\n+mfsplay_tree_free (void *p)\n {\n   DECLARE (void, free, void *p);\n   CALL_REAL (free, p);\n }\n \n static void *\n-splay_tree_xmalloc (size_t s)\n+mfsplay_tree_xmalloc (size_t s)\n {\n   DECLARE (void *, malloc, size_t s);\n   return CALL_REAL (malloc, s);\n }\n \n-#define free(z) splay_tree_free(z)\n-#define xmalloc(z) splay_tree_xmalloc(z)\n-#include \"splay-tree.c\"\n+\n+static void mfsplay_tree_splay (mfsplay_tree, mfsplay_tree_key);\n+static mfsplay_tree_node mfsplay_tree_splay_helper (mfsplay_tree,\n+                                                mfsplay_tree_key,\n+                                                mfsplay_tree_node *,\n+                                                mfsplay_tree_node *,\n+                                                mfsplay_tree_node *);\n+static void *mfsplay_tree_xmalloc (size_t size);\n+static void mfsplay_tree_free (void *object);\n+\n+\n+\n+/* Inline comparison function specialized for libmudflap's key type.  */\n+static inline int\n+compare_uintptr_t (mfsplay_tree_key k1, mfsplay_tree_key k2)\n+{\n+  if ((uintptr_t) k1 < (uintptr_t) k2)\n+    return -1;\n+  else if ((uintptr_t) k1 > (uintptr_t) k2)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+\n+/* Help splay SP around KEY.  PARENT and GRANDPARENT are the parent\n+   and grandparent, respectively, of NODE.  */\n+\n+static mfsplay_tree_node\n+mfsplay_tree_splay_helper (mfsplay_tree sp,\n+                         mfsplay_tree_key key,\n+                         mfsplay_tree_node * node,\n+                         mfsplay_tree_node * parent,\n+                         mfsplay_tree_node * grandparent)\n+{\n+  mfsplay_tree_node *next;\n+  mfsplay_tree_node n;\n+  int comparison;\n+\n+  n = *node;\n+\n+  if (!n)\n+    return *parent;\n+\n+  comparison = compare_uintptr_t (key, n->key);\n+\n+  if (comparison == 0)\n+    /* We've found the target.  */\n+    next = 0;\n+  else if (comparison < 0)\n+    /* The target is to the left.  */\n+    next = &n->left;\n+  else\n+    /* The target is to the right.  */\n+    next = &n->right;\n+\n+  if (next)\n+    {\n+      /* Check whether our recursion depth is too high.  Abort this search,\n+         and signal that a rebalance is required to continue.  */\n+      if (sp->depth > sp->max_depth)\n+        {\n+          sp->rebalance_p = 1;\n+          return n;\n+         }\n+\n+      /* Continue down the tree.  */\n+      sp->depth ++;\n+      n = mfsplay_tree_splay_helper (sp, key, next, node, parent);\n+      sp->depth --;\n+\n+      /* The recursive call will change the place to which NODE\n+         points.  */\n+      if (*node != n || sp->rebalance_p)\n+        return n;\n+    }\n+\n+  if (!parent)\n+    /* NODE is the root.  We are done.  */\n+    return n;\n+\n+  /* First, handle the case where there is no grandparent (i.e.,\n+   *PARENT is the root of the tree.)  */\n+  if (!grandparent)\n+    {\n+      if (n == (*parent)->left)\n+        {\n+          *node = n->right;\n+          n->right = *parent;\n+        }\n+      else\n+        {\n+          *node = n->left;\n+          n->left = *parent;\n+        }\n+      *parent = n;\n+      return n;\n+    }\n+\n+  /* Next handle the cases where both N and *PARENT are left children,\n+     or where both are right children.  */\n+  if (n == (*parent)->left && *parent == (*grandparent)->left)\n+    {\n+      mfsplay_tree_node p = *parent;\n+\n+      (*grandparent)->left = p->right;\n+      p->right = *grandparent;\n+      p->left = n->right;\n+      n->right = p;\n+      *grandparent = n;\n+      return n;\n+    }\n+  else if (n == (*parent)->right && *parent == (*grandparent)->right)\n+    {\n+      mfsplay_tree_node p = *parent;\n+\n+      (*grandparent)->right = p->left;\n+      p->left = *grandparent;\n+      p->right = n->left;\n+      n->left = p;\n+      *grandparent = n;\n+      return n;\n+    }\n+\n+  /* Finally, deal with the case where N is a left child, but *PARENT\n+     is a right child, or vice versa.  */\n+  if (n == (*parent)->left)\n+    {\n+      (*parent)->left = n->right;\n+      n->right = *parent;\n+      (*grandparent)->right = n->left;\n+      n->left = *grandparent;\n+      *grandparent = n;\n+      return n;\n+    }\n+  else\n+    {\n+      (*parent)->right = n->left;\n+      n->left = *parent;\n+      (*grandparent)->left = n->right;\n+      n->right = *grandparent;\n+      *grandparent = n;\n+      return n;\n+    }\n+}\n+\n+\n+\n+static int\n+mfsplay_tree_rebalance_helper1 (mfsplay_tree_node n, void *array_ptr)\n+{\n+  mfsplay_tree_node **p = array_ptr;\n+  *(*p) = n;\n+  (*p)++;\n+  return 0;\n+}\n+\n+\n+static mfsplay_tree_node\n+mfsplay_tree_rebalance_helper2 (mfsplay_tree_node * array, unsigned low,\n+                              unsigned high)\n+{\n+  unsigned middle = low + (high - low) / 2;\n+  mfsplay_tree_node n = array[middle];\n+\n+  /* Note that since we're producing a balanced binary tree, it is not a problem\n+     that this function is recursive.  */\n+  if (low + 1 <= middle)\n+    n->left = mfsplay_tree_rebalance_helper2 (array, low, middle - 1);\n+  else\n+    n->left = NULL;\n+\n+  if (middle + 1 <= high)\n+    n->right = mfsplay_tree_rebalance_helper2 (array, middle + 1, high);\n+  else\n+    n->right = NULL;\n+\n+  return n;\n+}\n+\n+\n+/* Rebalance the entire tree.  Do this by copying all the node\n+   pointers into an array, then cleverly re-linking them.  */\n+static void\n+mfsplay_tree_rebalance (mfsplay_tree sp)\n+{\n+  mfsplay_tree_node *all_nodes, *all_nodes_1;\n+\n+  if (sp->num_keys <= 2)\n+    return;\n+\n+  all_nodes = mfsplay_tree_xmalloc (sizeof (mfsplay_tree_node) * sp->num_keys);\n+\n+  /* Traverse all nodes to copy their addresses into this array.  */\n+  all_nodes_1 = all_nodes;\n+  mfsplay_tree_foreach (sp, mfsplay_tree_rebalance_helper1,\n+                      (void *) &all_nodes_1);\n+\n+  /* Relink all the nodes.  */\n+  sp->root = mfsplay_tree_rebalance_helper2 (all_nodes, 0, sp->num_keys - 1);\n+\n+  mfsplay_tree_free (all_nodes);\n+}\n+\n+\n+/* Splay SP around KEY.  */\n+static void\n+mfsplay_tree_splay (mfsplay_tree sp, mfsplay_tree_key key)\n+{\n+  if (sp->root == 0)\n+    return;\n+\n+  /* If we just splayed the tree with the same key, do nothing.  */\n+  if (sp->last_splayed_key_p &&\n+      compare_uintptr_t (sp->last_splayed_key, key) == 0)\n+    return;\n+\n+  /* Compute a maximum recursion depth for a splay tree with NUM nodes.\n+     The idea is to limit excessive stack usage if we're facing\n+     degenerate access patterns.  Unfortunately such patterns can occur\n+     e.g. during static initialization, where many static objects might\n+     be registered in increasing address sequence, or during a case where\n+     large tree-like heap data structures are allocated quickly. \n+\n+     On x86, this corresponds to roughly 200K of stack usage. \n+     XXX: For libmudflapth, this could be a function of __mf_opts.thread_stack.  */\n+  sp->max_depth = 2500;\n+  sp->rebalance_p = sp->depth = 0;\n+\n+  mfsplay_tree_splay_helper (sp, key, &sp->root, NULL, NULL);\n+  if (sp->rebalance_p)\n+    {\n+      mfsplay_tree_rebalance (sp);\n+\n+      sp->rebalance_p = sp->depth = 0;\n+      mfsplay_tree_splay_helper (sp, key, &sp->root, NULL, NULL);\n+\n+      if (sp->rebalance_p)\n+        abort ();\n+    }\n+\n+\n+  /* Cache this splay key. */\n+  sp->last_splayed_key = key;\n+  sp->last_splayed_key_p = 1;\n+}\n+\n+\n+\n+/* Allocate a new splay tree.  */\n+static mfsplay_tree\n+mfsplay_tree_new ()\n+{\n+  mfsplay_tree sp = mfsplay_tree_xmalloc (sizeof (struct mfsplay_tree_s));\n+  sp->root = NULL;\n+  sp->last_splayed_key_p = 0;\n+  sp->num_keys = 0;\n+\n+  return sp;\n+}\n+\n+\n+\n+/* Insert a new node (associating KEY with DATA) into SP.  If a\n+   previous node with the indicated KEY exists, its data is replaced\n+   with the new value.  Returns the new node.  */\n+static mfsplay_tree_node\n+mfsplay_tree_insert (mfsplay_tree sp, mfsplay_tree_key key, mfsplay_tree_value value)\n+{\n+  int comparison = 0;\n+\n+  mfsplay_tree_splay (sp, key);\n+\n+  if (sp->root)\n+    comparison = compare_uintptr_t (sp->root->key, key);\n+\n+  if (sp->root && comparison == 0)\n+    {\n+      /* If the root of the tree already has the indicated KEY, just\n+         replace the value with VALUE.  */\n+      sp->root->value = value;\n+    }\n+  else\n+    {\n+      /* Create a new node, and insert it at the root.  */\n+      mfsplay_tree_node node;\n+\n+      node = mfsplay_tree_xmalloc (sizeof (struct mfsplay_tree_node_s));\n+      node->key = key;\n+      node->value = value;\n+      sp->num_keys++;\n+      if (!sp->root)\n+        node->left = node->right = 0;\n+      else if (comparison < 0)\n+        {\n+          node->left = sp->root;\n+          node->right = node->left->right;\n+          node->left->right = 0;\n+        }\n+      else\n+        {\n+          node->right = sp->root;\n+          node->left = node->right->left;\n+          node->right->left = 0;\n+        }\n+\n+      sp->root = node;\n+      sp->last_splayed_key_p = 0;\n+    }\n+\n+  return sp->root;\n+}\n+\n+/* Remove KEY from SP.  It is not an error if it did not exist.  */\n+\n+static void\n+mfsplay_tree_remove (mfsplay_tree sp, mfsplay_tree_key key)\n+{\n+  mfsplay_tree_splay (sp, key);\n+  sp->last_splayed_key_p = 0;\n+  if (sp->root && compare_uintptr_t (sp->root->key, key) == 0)\n+    {\n+      mfsplay_tree_node left, right;\n+      left = sp->root->left;\n+      right = sp->root->right;\n+      /* Delete the root node itself.  */\n+      mfsplay_tree_free (sp->root);\n+      sp->num_keys--;\n+      /* One of the children is now the root.  Doesn't matter much\n+         which, so long as we preserve the properties of the tree.  */\n+      if (left)\n+        {\n+          sp->root = left;\n+          /* If there was a right child as well, hang it off the \n+             right-most leaf of the left child.  */\n+          if (right)\n+            {\n+              while (left->right)\n+                left = left->right;\n+              left->right = right;\n+            }\n+        }\n+      else\n+        sp->root = right;\n+    }\n+}\n+\n+/* Lookup KEY in SP, returning VALUE if present, and NULL \n+   otherwise.  */\n+\n+static mfsplay_tree_node\n+mfsplay_tree_lookup (mfsplay_tree sp, mfsplay_tree_key key)\n+{\n+  mfsplay_tree_splay (sp, key);\n+  if (sp->root && compare_uintptr_t (sp->root->key, key) == 0)\n+    return sp->root;\n+  else\n+    return 0;\n+}\n+\n+\n+/* Return the immediate predecessor KEY, or NULL if there is no\n+   predecessor.  KEY need not be present in the tree.  */\n+\n+static mfsplay_tree_node\n+mfsplay_tree_predecessor (mfsplay_tree sp, mfsplay_tree_key key)\n+{\n+  int comparison;\n+  mfsplay_tree_node node;\n+  /* If the tree is empty, there is certainly no predecessor.  */\n+  if (!sp->root)\n+    return NULL;\n+  /* Splay the tree around KEY.  That will leave either the KEY\n+     itself, its predecessor, or its successor at the root.  */\n+  mfsplay_tree_splay (sp, key);\n+  comparison = compare_uintptr_t (sp->root->key, key);\n+  /* If the predecessor is at the root, just return it.  */\n+  if (comparison < 0)\n+    return sp->root;\n+  /* Otherwise, find the rightmost element of the left subtree.  */\n+  node = sp->root->left;\n+  if (node)\n+    while (node->right)\n+      node = node->right;\n+  return node;\n+}\n+\n+/* Return the immediate successor KEY, or NULL if there is no\n+   successor.  KEY need not be present in the tree.  */\n+\n+static mfsplay_tree_node\n+mfsplay_tree_successor (mfsplay_tree sp, mfsplay_tree_key key)\n+{\n+  int comparison;\n+  mfsplay_tree_node node;\n+  /* If the tree is empty, there is certainly no successor.  */\n+  if (!sp->root)\n+    return NULL;\n+  /* Splay the tree around KEY.  That will leave either the KEY\n+     itself, its predecessor, or its successor at the root.  */\n+  mfsplay_tree_splay (sp, key);\n+  comparison = compare_uintptr_t (sp->root->key, key);\n+  /* If the successor is at the root, just return it.  */\n+  if (comparison > 0)\n+    return sp->root;\n+  /* Otherwise, find the leftmost element of the right subtree.  */\n+  node = sp->root->right;\n+  if (node)\n+    while (node->left)\n+      node = node->left;\n+  return node;\n+}\n+\n+/* Call FN, passing it the DATA, for every node in SP, following an\n+   in-order traversal.  If FN every returns a non-zero value, the\n+   iteration ceases immediately, and the value is returned.\n+   Otherwise, this function returns 0.\n+   \n+   This function simulates recursion using dynamically allocated\n+   arrays, since it may be called from mfsplay_tree_rebalance(), which\n+   in turn means that the tree is already uncomfortably deep for stack\n+   space limits.  */\n+static int\n+mfsplay_tree_foreach (mfsplay_tree st, mfsplay_tree_foreach_fn fn, void *data)\n+{\n+  mfsplay_tree_node *stack1;\n+  char *stack2;\n+  unsigned sp;\n+  int val = 0;\n+  enum s { s_left, s_here, s_right, s_up };\n+\n+  if (st->root == NULL) /* => num_keys == 0 */\n+    return 0;\n+\n+  stack1 = mfsplay_tree_xmalloc (sizeof (mfsplay_tree_node) * st->num_keys);\n+  stack2 = mfsplay_tree_xmalloc (sizeof (char) * st->num_keys);\n+\n+  sp = 0;\n+  stack1 [sp] = st->root;\n+  stack2 [sp] = s_left;\n+\n+  while (1)\n+    {\n+      mfsplay_tree_node n;\n+      enum s s;\n+\n+      n = stack1 [sp];\n+      s = stack2 [sp];\n+\n+      /* Handle each of the four possible states separately.  */\n+\n+      /* 1: We're here to traverse the left subtree (if any).  */\n+      if (s == s_left)\n+        {\n+          stack2 [sp] = s_here;\n+          if (n->left != NULL)\n+            {\n+              sp ++;\n+              stack1 [sp] = n->left;\n+              stack2 [sp] = s_left;\n+            }\n+        }\n+\n+      /* 2: We're here to traverse this node.  */\n+      else if (s == s_here)\n+        {\n+          stack2 [sp] = s_right;\n+          val = (*fn) (n, data);\n+          if (val) break;\n+        }\n+\n+      /* 3: We're here to traverse the right subtree (if any).  */\n+      else if (s == s_right)\n+        {\n+          stack2 [sp] = s_up;\n+          if (n->right != NULL)\n+            {\n+              sp ++;\n+              stack1 [sp] = n->right;\n+              stack2 [sp] = s_left;\n+            }\n+        }\n+\n+      /* 4: We're here after both subtrees (if any) have been traversed.  */\n+      else if (s == s_up)\n+        {\n+          /* Pop the stack.  */\n+          if (sp == 0) break; /* Popping off the root note: we're finished!  */\n+          sp --;\n+        }\n+\n+      else\n+        abort ();\n+    }\n+\n+  mfsplay_tree_free (stack1);\n+  mfsplay_tree_free (stack2);\n+  return val;\n+}"}, {"sha": "cbd4bfb0cf38c88d3b1421b36e62ab099b7547af", "filename": "libmudflap/splay-tree.c", "status": "removed", "additions": 0, "deletions": 564, "changes": 564, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00bdb87f8e8107ade3abd37e37db8270a0016bc3/libmudflap%2Fsplay-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00bdb87f8e8107ade3abd37e37db8270a0016bc3/libmudflap%2Fsplay-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fsplay-tree.c?ref=00bdb87f8e8107ade3abd37e37db8270a0016bc3", "patch": "@@ -1,564 +0,0 @@\n-/* A splay-tree datatype.  \n-   Copyright (C) 1998, 1999, 2000, 2001, 2004 Free Software Foundation, Inc.\n-   Contributed by Mark Mitchell (mark@markmitchell.com).\n-   Adapted for libmudflap from libiberty.\n-\n-This file is part of GNU CC.\n-   \n-GNU CC is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-In addition to the permissions in the GNU General Public License, the\n-Free Software Foundation gives you unlimited permission to link the\n-compiled version of this file into combinations with other programs,\n-and to distribute those combinations without any restriction coming\n-from the use of this file.  (The General Public License restrictions\n-do apply in other respects; for example, they cover modification of\n-the file, and distribution when not linked into a combine\n-executable.)\n-\n-GNU CC is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* For an easily readable description of splay-trees, see:\n-\n-     Lewis, Harry R. and Denenberg, Larry.  Data Structures and Their\n-     Algorithms.  Harper-Collins, Inc.  1991.  */\n-\n-#include <stdlib.h>\n-#include <stdio.h>\n-#include \"splay-tree.h\"\n-\n-\n-static void splay_tree_splay (splay_tree, splay_tree_key);\n-static splay_tree_node splay_tree_splay_helper (splay_tree,\n-                                                splay_tree_key,\n-                                                splay_tree_node *,\n-                                                splay_tree_node *,\n-                                                splay_tree_node *);\n-static void *splay_tree_xmalloc (size_t size);\n-static void splay_tree_free (void *object);\n-\n-\n-\n-/* Inline comparison function specialized for libmudflap's key type.  */\n-static inline int\n-compare_uintptr_t (splay_tree_key k1, splay_tree_key k2)\n-{\n-  if ((uintptr_t) k1 < (uintptr_t) k2)\n-    return -1;\n-  else if ((uintptr_t) k1 > (uintptr_t) k2)\n-    return 1;\n-  else\n-    return 0;\n-}\n-\n-\n-/* Help splay SP around KEY.  PARENT and GRANDPARENT are the parent\n-   and grandparent, respectively, of NODE.  */\n-\n-static splay_tree_node\n-splay_tree_splay_helper (splay_tree sp,\n-                         splay_tree_key key,\n-                         splay_tree_node * node,\n-                         splay_tree_node * parent,\n-                         splay_tree_node * grandparent)\n-{\n-  splay_tree_node *next;\n-  splay_tree_node n;\n-  int comparison;\n-\n-  n = *node;\n-\n-  if (!n)\n-    return *parent;\n-\n-  comparison = compare_uintptr_t (key, n->key);\n-\n-  if (comparison == 0)\n-    /* We've found the target.  */\n-    next = 0;\n-  else if (comparison < 0)\n-    /* The target is to the left.  */\n-    next = &n->left;\n-  else\n-    /* The target is to the right.  */\n-    next = &n->right;\n-\n-  if (next)\n-    {\n-      /* Check whether our recursion depth is too high.  Abort this search,\n-         and signal that a rebalance is required to continue.  */\n-      if (sp->depth > sp->max_depth)\n-        {\n-          sp->rebalance_p = 1;\n-          return n;\n-         }\n-\n-      /* Continue down the tree.  */\n-      sp->depth ++;\n-      n = splay_tree_splay_helper (sp, key, next, node, parent);\n-      sp->depth --;\n-\n-      /* The recursive call will change the place to which NODE\n-         points.  */\n-      if (*node != n || sp->rebalance_p)\n-        return n;\n-    }\n-\n-  if (!parent)\n-    /* NODE is the root.  We are done.  */\n-    return n;\n-\n-  /* First, handle the case where there is no grandparent (i.e.,\n-   *PARENT is the root of the tree.)  */\n-  if (!grandparent)\n-    {\n-      if (n == (*parent)->left)\n-        {\n-          *node = n->right;\n-          n->right = *parent;\n-        }\n-      else\n-        {\n-          *node = n->left;\n-          n->left = *parent;\n-        }\n-      *parent = n;\n-      return n;\n-    }\n-\n-  /* Next handle the cases where both N and *PARENT are left children,\n-     or where both are right children.  */\n-  if (n == (*parent)->left && *parent == (*grandparent)->left)\n-    {\n-      splay_tree_node p = *parent;\n-\n-      (*grandparent)->left = p->right;\n-      p->right = *grandparent;\n-      p->left = n->right;\n-      n->right = p;\n-      *grandparent = n;\n-      return n;\n-    }\n-  else if (n == (*parent)->right && *parent == (*grandparent)->right)\n-    {\n-      splay_tree_node p = *parent;\n-\n-      (*grandparent)->right = p->left;\n-      p->left = *grandparent;\n-      p->right = n->left;\n-      n->left = p;\n-      *grandparent = n;\n-      return n;\n-    }\n-\n-  /* Finally, deal with the case where N is a left child, but *PARENT\n-     is a right child, or vice versa.  */\n-  if (n == (*parent)->left)\n-    {\n-      (*parent)->left = n->right;\n-      n->right = *parent;\n-      (*grandparent)->right = n->left;\n-      n->left = *grandparent;\n-      *grandparent = n;\n-      return n;\n-    }\n-  else\n-    {\n-      (*parent)->right = n->left;\n-      n->left = *parent;\n-      (*grandparent)->left = n->right;\n-      n->right = *grandparent;\n-      *grandparent = n;\n-      return n;\n-    }\n-}\n-\n-\n-\n-static int\n-splay_tree_rebalance_helper1 (splay_tree_node n, void *array_ptr)\n-{\n-  splay_tree_node **p = array_ptr;\n-  *(*p) = n;\n-  (*p)++;\n-  return 0;\n-}\n-\n-\n-static splay_tree_node\n-splay_tree_rebalance_helper2 (splay_tree_node * array, unsigned low,\n-                              unsigned high)\n-{\n-  unsigned middle = low + (high - low) / 2;\n-  splay_tree_node n = array[middle];\n-\n-  /* Note that since we're producing a balanced binary tree, it is not a problem\n-     that this function is recursive.  */\n-  if (low + 1 <= middle)\n-    n->left = splay_tree_rebalance_helper2 (array, low, middle - 1);\n-  else\n-    n->left = NULL;\n-\n-  if (middle + 1 <= high)\n-    n->right = splay_tree_rebalance_helper2 (array, middle + 1, high);\n-  else\n-    n->right = NULL;\n-\n-  return n;\n-}\n-\n-\n-/* Rebalance the entire tree.  Do this by copying all the node\n-   pointers into an array, then cleverly re-linking them.  */\n-void\n-splay_tree_rebalance (splay_tree sp)\n-{\n-  splay_tree_node *all_nodes, *all_nodes_1;\n-\n-  if (sp->num_keys <= 2)\n-    return;\n-\n-  all_nodes = splay_tree_xmalloc (sizeof (splay_tree_node) * sp->num_keys);\n-\n-  /* Traverse all nodes to copy their addresses into this array.  */\n-  all_nodes_1 = all_nodes;\n-  splay_tree_foreach (sp, splay_tree_rebalance_helper1,\n-                      (void *) &all_nodes_1);\n-\n-  /* Relink all the nodes.  */\n-  sp->root = splay_tree_rebalance_helper2 (all_nodes, 0, sp->num_keys - 1);\n-\n-  splay_tree_free (all_nodes);\n-}\n-\n-\n-/* Splay SP around KEY.  */\n-static void\n-splay_tree_splay (splay_tree sp, splay_tree_key key)\n-{\n-  if (sp->root == 0)\n-    return;\n-\n-  /* If we just splayed the tree with the same key, do nothing.  */\n-  if (sp->last_splayed_key_p &&\n-      compare_uintptr_t (sp->last_splayed_key, key) == 0)\n-    return;\n-\n-  /* Compute a maximum recursion depth for a splay tree with NUM nodes.\n-     The idea is to limit excessive stack usage if we're facing\n-     degenerate access patterns.  Unfortunately such patterns can occur\n-     e.g. during static initialization, where many static objects might\n-     be registered in increasing address sequence, or during a case where\n-     large tree-like heap data structures are allocated quickly. \n-\n-     On x86, this corresponds to roughly 200K of stack usage. \n-     XXX: For libmudflapth, this could be a function of __mf_opts.thread_stack.  */\n-  sp->max_depth = 2500;\n-  sp->rebalance_p = sp->depth = 0;\n-\n-  splay_tree_splay_helper (sp, key, &sp->root, NULL, NULL);\n-  if (sp->rebalance_p)\n-    {\n-      splay_tree_rebalance (sp);\n-\n-      sp->rebalance_p = sp->depth = 0;\n-      splay_tree_splay_helper (sp, key, &sp->root, NULL, NULL);\n-\n-      if (sp->rebalance_p)\n-        abort ();\n-    }\n-\n-\n-  /* Cache this splay key. */\n-  sp->last_splayed_key = key;\n-  sp->last_splayed_key_p = 1;\n-}\n-\n-\n-\n-/* Allocate a new splay tree.  */\n-splay_tree\n-splay_tree_new ()\n-{\n-  splay_tree sp = splay_tree_xmalloc (sizeof (struct splay_tree_s));\n-  sp->root = NULL;\n-  sp->last_splayed_key_p = 0;\n-  sp->num_keys = 0;\n-\n-  return sp;\n-}\n-\n-\n-\n-/* Insert a new node (associating KEY with DATA) into SP.  If a\n-   previous node with the indicated KEY exists, its data is replaced\n-   with the new value.  Returns the new node.  */\n-splay_tree_node\n-splay_tree_insert (splay_tree sp, splay_tree_key key, splay_tree_value value)\n-{\n-  int comparison = 0;\n-\n-  splay_tree_splay (sp, key);\n-\n-  if (sp->root)\n-    comparison = compare_uintptr_t (sp->root->key, key);\n-\n-  if (sp->root && comparison == 0)\n-    {\n-      /* If the root of the tree already has the indicated KEY, just\n-         replace the value with VALUE.  */\n-      sp->root->value = value;\n-    }\n-  else\n-    {\n-      /* Create a new node, and insert it at the root.  */\n-      splay_tree_node node;\n-\n-      node = splay_tree_xmalloc (sizeof (struct splay_tree_node_s));\n-      node->key = key;\n-      node->value = value;\n-      sp->num_keys++;\n-      if (!sp->root)\n-        node->left = node->right = 0;\n-      else if (comparison < 0)\n-        {\n-          node->left = sp->root;\n-          node->right = node->left->right;\n-          node->left->right = 0;\n-        }\n-      else\n-        {\n-          node->right = sp->root;\n-          node->left = node->right->left;\n-          node->right->left = 0;\n-        }\n-\n-      sp->root = node;\n-      sp->last_splayed_key_p = 0;\n-    }\n-\n-  return sp->root;\n-}\n-\n-/* Remove KEY from SP.  It is not an error if it did not exist.  */\n-\n-void\n-splay_tree_remove (splay_tree sp, splay_tree_key key)\n-{\n-  splay_tree_splay (sp, key);\n-  sp->last_splayed_key_p = 0;\n-  if (sp->root && compare_uintptr_t (sp->root->key, key) == 0)\n-    {\n-      splay_tree_node left, right;\n-      left = sp->root->left;\n-      right = sp->root->right;\n-      /* Delete the root node itself.  */\n-      splay_tree_free (sp->root);\n-      sp->num_keys--;\n-      /* One of the children is now the root.  Doesn't matter much\n-         which, so long as we preserve the properties of the tree.  */\n-      if (left)\n-        {\n-          sp->root = left;\n-          /* If there was a right child as well, hang it off the \n-             right-most leaf of the left child.  */\n-          if (right)\n-            {\n-              while (left->right)\n-                left = left->right;\n-              left->right = right;\n-            }\n-        }\n-      else\n-        sp->root = right;\n-    }\n-}\n-\n-/* Lookup KEY in SP, returning VALUE if present, and NULL \n-   otherwise.  */\n-\n-splay_tree_node\n-splay_tree_lookup (splay_tree sp, splay_tree_key key)\n-{\n-  splay_tree_splay (sp, key);\n-  if (sp->root && compare_uintptr_t (sp->root->key, key) == 0)\n-    return sp->root;\n-  else\n-    return 0;\n-}\n-\n-/* Return the node in SP with the greatest key.  */\n-\n-splay_tree_node\n-splay_tree_max (splay_tree sp)\n-{\n-  splay_tree_node n = sp->root;\n-  if (!n)\n-    return NULL;\n-  while (n->right)\n-    n = n->right;\n-  return n;\n-}\n-\n-/* Return the node in SP with the smallest key.  */\n-\n-splay_tree_node\n-splay_tree_min (splay_tree sp)\n-{\n-  splay_tree_node n = sp->root;\n-  if (!n)\n-    return NULL;\n-  while (n->left)\n-    n = n->left;\n-  return n;\n-}\n-\n-/* Return the immediate predecessor KEY, or NULL if there is no\n-   predecessor.  KEY need not be present in the tree.  */\n-\n-splay_tree_node\n-splay_tree_predecessor (splay_tree sp, splay_tree_key key)\n-{\n-  int comparison;\n-  splay_tree_node node;\n-  /* If the tree is empty, there is certainly no predecessor.  */\n-  if (!sp->root)\n-    return NULL;\n-  /* Splay the tree around KEY.  That will leave either the KEY\n-     itself, its predecessor, or its successor at the root.  */\n-  splay_tree_splay (sp, key);\n-  comparison = compare_uintptr_t (sp->root->key, key);\n-  /* If the predecessor is at the root, just return it.  */\n-  if (comparison < 0)\n-    return sp->root;\n-  /* Otherwise, find the rightmost element of the left subtree.  */\n-  node = sp->root->left;\n-  if (node)\n-    while (node->right)\n-      node = node->right;\n-  return node;\n-}\n-\n-/* Return the immediate successor KEY, or NULL if there is no\n-   successor.  KEY need not be present in the tree.  */\n-\n-splay_tree_node\n-splay_tree_successor (splay_tree sp, splay_tree_key key)\n-{\n-  int comparison;\n-  splay_tree_node node;\n-  /* If the tree is empty, there is certainly no successor.  */\n-  if (!sp->root)\n-    return NULL;\n-  /* Splay the tree around KEY.  That will leave either the KEY\n-     itself, its predecessor, or its successor at the root.  */\n-  splay_tree_splay (sp, key);\n-  comparison = compare_uintptr_t (sp->root->key, key);\n-  /* If the successor is at the root, just return it.  */\n-  if (comparison > 0)\n-    return sp->root;\n-  /* Otherwise, find the leftmost element of the right subtree.  */\n-  node = sp->root->right;\n-  if (node)\n-    while (node->left)\n-      node = node->left;\n-  return node;\n-}\n-\n-/* Call FN, passing it the DATA, for every node in SP, following an\n-   in-order traversal.  If FN every returns a non-zero value, the\n-   iteration ceases immediately, and the value is returned.\n-   Otherwise, this function returns 0.\n-   \n-   This function simulates recursion using dynamically allocated\n-   arrays, since it may be called from splay_tree_rebalance(), which\n-   in turn means that the tree is already uncomfortably deep for stack\n-   space limits.  */\n-int\n-splay_tree_foreach (splay_tree st, splay_tree_foreach_fn fn, void *data)\n-{\n-  splay_tree_node *stack1;\n-  char *stack2;\n-  unsigned sp;\n-  int val = 0;\n-  enum s { s_left, s_here, s_right, s_up };\n-\n-  if (st->root == NULL) /* => num_keys == 0 */\n-    return 0;\n-\n-  stack1 = splay_tree_xmalloc (sizeof (splay_tree_node) * st->num_keys);\n-  stack2 = splay_tree_xmalloc (sizeof (char) * st->num_keys);\n-\n-  sp = 0;\n-  stack1 [sp] = st->root;\n-  stack2 [sp] = s_left;\n-\n-  while (1)\n-    {\n-      splay_tree_node n;\n-      enum s s;\n-\n-      n = stack1 [sp];\n-      s = stack2 [sp];\n-\n-      /* Handle each of the four possible states separately.  */\n-\n-      /* 1: We're here to traverse the left subtree (if any).  */\n-      if (s == s_left)\n-        {\n-          stack2 [sp] = s_here;\n-          if (n->left != NULL)\n-            {\n-              sp ++;\n-              stack1 [sp] = n->left;\n-              stack2 [sp] = s_left;\n-            }\n-        }\n-\n-      /* 2: We're here to traverse this node.  */\n-      else if (s == s_here)\n-        {\n-          stack2 [sp] = s_right;\n-          val = (*fn) (n, data);\n-          if (val) break;\n-        }\n-\n-      /* 3: We're here to traverse the right subtree (if any).  */\n-      else if (s == s_right)\n-        {\n-          stack2 [sp] = s_up;\n-          if (n->right != NULL)\n-            {\n-              sp ++;\n-              stack1 [sp] = n->right;\n-              stack2 [sp] = s_left;\n-            }\n-        }\n-\n-      /* 4: We're here after both subtrees (if any) have been traversed.  */\n-      else if (s == s_up)\n-        {\n-          /* Pop the stack.  */\n-          if (sp == 0) break; /* Popping off the root note: we're finished!  */\n-          sp --;\n-        }\n-\n-      else\n-        abort ();\n-    }\n-\n-  splay_tree_free (stack1);\n-  splay_tree_free (stack2);\n-  return val;\n-}"}, {"sha": "742eb4bb888f27962eb776580bf5006e47aa9faa", "filename": "libmudflap/splay-tree.h", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00bdb87f8e8107ade3abd37e37db8270a0016bc3/libmudflap%2Fsplay-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00bdb87f8e8107ade3abd37e37db8270a0016bc3/libmudflap%2Fsplay-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fsplay-tree.h?ref=00bdb87f8e8107ade3abd37e37db8270a0016bc3", "patch": "@@ -1,96 +0,0 @@\n-/* A splay-tree datatype.  \n-   Copyright 1998, 1999, 2000, 2002, 2004 Free Software Foundation, Inc.\n-   Contributed by Mark Mitchell (mark@markmitchell.com).\n-   Adapted for libmudflap from libiberty by Frank Ch. Eigler <fche@redhat.com>.\n-\n-This file is part of GCC.\n-   \n-GCC is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* For an easily readable description of splay-trees, see:\n-\n-     Lewis, Harry R. and Denenberg, Larry.  Data Structures and Their\n-     Algorithms.  Harper-Collins, Inc.  1991.  \n-\n-   The major feature of splay trees is that all basic tree operations\n-   are amortized O(log n) time for a tree with n nodes.  \n-\n-   This version has been further modified to periodically rebalance\n-   the entire tree, should degenerate access patterns result in a very\n-   lopsided tree.\n-*/\n-\n-#ifndef _SPLAY_TREE_H\n-#define _SPLAY_TREE_H\n-\n-/* Use typedefs for the key and data types to facilitate changing\n-   these types, if necessary.  These types should be sufficiently wide\n-   that any pointer or scalar can be cast to these types, and then\n-   cast back, without loss of precision.  */\n-typedef uintptr_t splay_tree_key;\n-typedef void *splay_tree_value;\n-\n-/* Forward declaration for a node in the tree.  */\n-typedef struct splay_tree_node_s *splay_tree_node;\n-\n-/* The type of a function used to iterate over the tree.  */\n-typedef int (*splay_tree_foreach_fn) (splay_tree_node, void *);\n-\n-/* The nodes in the splay tree.  */\n-struct splay_tree_node_s\n-{\n-  /* Data.  */\n-  splay_tree_key key;\n-  splay_tree_value value;\n-  /* Children.  */\n-  splay_tree_node left;\n-  splay_tree_node right;\n-};\n-\n-/* The splay tree itself.  */\n-struct splay_tree_s\n-{\n-  /* The root of the tree.  */\n-  splay_tree_node root;\n-\n-  /* The last key value for which the tree has been splayed, but not\n-     since modified.  */\n-  splay_tree_key last_splayed_key;\n-  int last_splayed_key_p;\n-\n-  /* Statistics.  */\n-  unsigned num_keys;\n-\n-  /* Traversal recursion control flags.  */\n-  unsigned max_depth;\n-  unsigned depth;\n-  unsigned rebalance_p;\n-};\n-typedef struct splay_tree_s *splay_tree;\n-\n-extern splay_tree splay_tree_new (void);\n-extern splay_tree_node splay_tree_insert (splay_tree, splay_tree_key, splay_tree_value);\n-extern void splay_tree_remove (splay_tree, splay_tree_key);\n-extern splay_tree_node splay_tree_lookup (splay_tree, splay_tree_key);\n-extern splay_tree_node splay_tree_predecessor (splay_tree, splay_tree_key);\n-extern splay_tree_node splay_tree_successor (splay_tree, splay_tree_key);\n-extern splay_tree_node splay_tree_max (splay_tree);\n-extern splay_tree_node splay_tree_min (splay_tree);\n-extern int splay_tree_foreach (splay_tree, splay_tree_foreach_fn, void *);\n-extern void splay_tree_rebalance (splay_tree sp);\n-\n-\n-#endif /* _SPLAY_TREE_H */"}, {"sha": "f3ab847eb56d1eb16212da331bb60b21ba47df1d", "filename": "libmudflap/testsuite/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc5515a8a069396531c8f33678a392a57f02f5fd/libmudflap%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc5515a8a069396531c8f33678a392a57f02f5fd/libmudflap%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2FMakefile.in?ref=fc5515a8a069396531c8f33678a392a57f02f5fd", "patch": "@@ -136,7 +136,6 @@ infodir = @infodir@\n install_sh = @install_sh@\n libdir = @libdir@\n libexecdir = @libexecdir@\n-libtool_VERSION = @libtool_VERSION@\n localstatedir = @localstatedir@\n mandir = @mandir@\n mkdir_p = @mkdir_p@"}]}