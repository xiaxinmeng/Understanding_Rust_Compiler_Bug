{"sha": "cc88366a80e35b3e53141f49d3071010ff3c2ef8", "node_id": "C_kwDOANBUbNoAKGNjODgzNjZhODBlMzViM2U1MzE0MWY0OWQzMDcxMDEwZmYzYzJlZjg", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-03-02T08:27:40Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-03-02T08:27:40Z"}, "message": "fold-const: Ignore padding bits in native_interpret_expr REAL_CST reverse verification [PR108934]\n\nIn the following testcase we try to std::bit_cast a (pair of) integral\nvalue(s) which has some non-zero bits in the place of x86 long double\n(for 64-bit 16 byte type with 10 bytes actually loaded/stored by hw,\nfor 32-bit 12 byte) and starting with my PR104522 change we reject that\nas native_interpret_expr fails on it.  The PR104522 change extends what\nhas been done before for MODE_COMPOSITE_P (but those don't have any padding\nbits) to all floating point types, because e.g. the exact x86 long double\nhas various bit combinations we don't support, like\npseudo-(denormals,infinities,NaNs) or unnormals.  The HW handles some of\nthose as exceptional cases and others similarly to the non-pseudo ones.\nBut for the padding bits it actually doesn't load/store those bits at all,\nit loads/stores 10 bytes.  So, I think we should exempt the padding bits\nfrom the reverse comparison (the native_encode_expr bits for the padding\nwill be all zeros), which the following patch does.  For bit_cast it is\nsimilar to e.g. ignoring padding bits if the destination is a structure\nwhich has padding bits in there.\n\nThe change changed auto-init-4.c to how it has been behaving before the\nPR105259 change, where some more VCEs can be now done.\n\n2023-03-02  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/108934\n\t* fold-const.cc (native_interpret_expr) <case REAL_CST>: Before memcmp\n\tcomparison copy the bytes from ptr to a temporary buffer and clearing\n\tpadding bits in there.\n\n\t* gcc.target/i386/auto-init-4.c: Revert PR105259 change.\n\t* g++.target/i386/pr108934.C: New test.", "tree": {"sha": "6bddb8b53d18f50e77dd6b050dfe0a2d0dcf1204", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bddb8b53d18f50e77dd6b050dfe0a2d0dcf1204"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc88366a80e35b3e53141f49d3071010ff3c2ef8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc88366a80e35b3e53141f49d3071010ff3c2ef8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc88366a80e35b3e53141f49d3071010ff3c2ef8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc88366a80e35b3e53141f49d3071010ff3c2ef8/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0ef740d54f47ff614eb02e13e8f4cb11dfbb140", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0ef740d54f47ff614eb02e13e8f4cb11dfbb140", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0ef740d54f47ff614eb02e13e8f4cb11dfbb140"}], "stats": {"total": 39, "additions": 34, "deletions": 5}, "files": [{"sha": "99882ef820a1fe2be2f6153937b700a43f532a53", "filename": "gcc/fold-const.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc88366a80e35b3e53141f49d3071010ff3c2ef8/gcc%2Ffold-const.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc88366a80e35b3e53141f49d3071010ff3c2ef8/gcc%2Ffold-const.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.cc?ref=cc88366a80e35b3e53141f49d3071010ff3c2ef8", "patch": "@@ -8873,11 +8873,13 @@ native_interpret_expr (tree type, const unsigned char *ptr, int len)\n \t     valid values that GCC can't really represent accurately.\n \t     See PR95450.  Even for other modes, e.g. x86 XFmode can have some\n \t     bit combinationations which GCC doesn't preserve.  */\n-\t  unsigned char buf[24];\n+\t  unsigned char buf[24 * 2];\n \t  scalar_float_mode mode = SCALAR_FLOAT_TYPE_MODE (type);\n \t  int total_bytes = GET_MODE_SIZE (mode);\n+\t  memcpy (buf + 24, ptr, total_bytes);\n+\t  clear_type_padding_in_mask (type, buf + 24);\n \t  if (native_encode_expr (ret, buf, total_bytes, 0) != total_bytes\n-\t      || memcmp (ptr, buf, total_bytes) != 0)\n+\t      || memcmp (buf + 24, buf, total_bytes) != 0)\n \t    return NULL_TREE;\n \t  return ret;\n \t}"}, {"sha": "bd8f0ffd820d929dfb458263c9d7ab582495dc1f", "filename": "gcc/testsuite/g++.target/i386/pr108934.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc88366a80e35b3e53141f49d3071010ff3c2ef8/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr108934.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc88366a80e35b3e53141f49d3071010ff3c2ef8/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr108934.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr108934.C?ref=cc88366a80e35b3e53141f49d3071010ff3c2ef8", "patch": "@@ -0,0 +1,28 @@\n+// PR c++/108934\n+// { dg-do compile { target c++11 } }\n+\n+struct S { unsigned long long a[2]; };\n+struct T { unsigned long long b[6]; };\n+struct U { unsigned long long c[2]; long double d; unsigned long long e[2]; };\n+\n+#if __SIZEOF_LONG_DOUBLE__ == 16 && __LDBL_MANT_DIG__ == 64 && __SIZEOF_LONG_LONG__ == 8\n+constexpr long double\n+foo (S x)\n+{\n+  return __builtin_bit_cast (long double, x);\n+}\n+\n+constexpr S a = { 0ULL, 0xffffffffffff0000ULL };\n+constexpr long double b = foo (a);\n+static_assert (b == 0.0L, \"\");\n+\n+constexpr U\n+bar (T x)\n+{\n+  return __builtin_bit_cast (U, x);\n+}\n+\n+constexpr T c = { 0ULL, 0ULL, 0ULL, 0xffffffffffff0000ULL, 0ULL, 0ULL };\n+constexpr U d = bar (c);\n+static_assert (d.d == 0.0L, \"\");\n+#endif"}, {"sha": "d9af8f30bb05a5adf8b8f2be26060136bc170504", "filename": "gcc/testsuite/gcc.target/i386/auto-init-4.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc88366a80e35b3e53141f49d3071010ff3c2ef8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fauto-init-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc88366a80e35b3e53141f49d3071010ff3c2ef8/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fauto-init-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fauto-init-4.c?ref=cc88366a80e35b3e53141f49d3071010ff3c2ef8", "patch": "@@ -15,6 +15,5 @@ long double foo()\n }\n \n \n-/* The long double init isn't expanded optimally, see PR105259.  For ia32\n-   it uses zero-initialization.  */\n-/* { dg-final { scan-assembler-times \"long\\t-16843010\" 3 } } */\n+/*\u00a0{\u00a0dg-final\u00a0{\u00a0scan-assembler-times\u00a0\"long\\t-16843010\"\u00a05\u00a0\u00a0{\u00a0target\u00a0{\u00a0!\u00a0ia32\u00a0}\u00a0}\u00a0}\u00a0}\u00a0*/\n+/*\u00a0{\u00a0dg-final\u00a0{\u00a0scan-assembler-times\u00a0\"long\\t-16843010\"\u00a03\u00a0\u00a0{\u00a0target\u00a0{\u00a0ia32\u00a0}\u00a0}\u00a0}\u00a0}\u00a0*/"}]}