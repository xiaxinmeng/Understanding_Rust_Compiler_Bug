{"sha": "6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNkMDA1YTI1NWYxNWMxYjRiM2VhYWU3MWM4NDRlYTI1OTJjOWRjZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-07-30T16:38:41Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-07-30T16:38:41Z"}, "message": "c++: Implement P0466R5 __cpp_lib_is_pointer_interconvertible compiler helpers [PR101539]\n\nThe following patch attempts to implement the compiler helpers for\nlibstdc++ std::is_pointer_interconvertible_base_of trait and\nstd::is_pointer_interconvertible_with_class template function.\n\nFor the former __is_pointer_interconvertible_base_of trait that checks first\nwhether base and derived aren't non-union class types that are the same\nignoring toplevel cv-qualifiers, otherwise if derived is unambiguously\nderived from base without cv-qualifiers, derived being a complete type,\nand if so, my limited understanding of any derived object being\npointer-interconvertible with base subobject IMHO implies (because one can't\ninherit from unions or unions can't inherit) that we check if derived is\nstandard layout type and we walk bases of derived\nrecursively, stopping on a class that has any non-static data members and\ncheck if any of the bases is base.  On class with non-static data members\nno bases are compared already.\nUpon discussions, this is something that maybe should have been changed\nin the standard with CWG 2254 and the patch no longer performs this and\nassumes all base subobjects of standard-layout class types are\npointer-interconvertible with the whole class objects.\n\nThe latter is implemented using a FE\n__builtin_is_pointer_interconvertible_with_class, but because on the library\nside it will be a template function, the builtin takes ... arguments and\nonly during folding verifies it has a single argument with pointer to member\ntype.  The initial errors IMHO can only happen if one uses the builtin\nincorrectly by hand, the template function should ensure that it has\nexactly a single argument that has pointer to member type.\nOtherwise, again with my limited understanding of what\nthe template function should do and pointer-interconvertibility,\nit folds to false for pointer-to-member-function, errors if\nbasetype of the OFFSET_TYPE is incomplete, folds to false\nfor non-std-layout non-union basetype, then finds the first non-static\ndata member in the basetype or its bases (by ignoring\nDECL_FIELD_IS_BASE FIELD_DECLs that are empty, recursing into\nDECL_FIELD_IS_BASE FIELD_DECLs type that are non-empty (I think\nstd layout should ensure there is at most one), for unions\nchecks if membertype is same type as any of the union FIELD_DECLs,\nfor non-unions the first other FIELD_DECL only, and for anonymous\naggregates similarly (union vs. non-union) but recurses into the\nanon aggr types with std layout check for anon structures.  If\nmembertype doesn't match the type of first non-static data member\n(or for unions any of the members), then the builtin folds to false,\notherwise the built folds to a check whether the argument is equal\nto OFFSET_TYPE of 0 or not, either at compile time if it is constant\n(e.g. for constexpr folding) or at runtime otherwise.\n\nAs I wrote in the PR, I've tried my testcases with MSVC on godbolt\nthat claims to implement it, and https://godbolt.org/z/3PnjM33vM\nfor the first testcase shows it disagrees with my expectations on\nstatic_assert (std::is_pointer_interconvertible_base_of_v<D, F>);\nstatic_assert (std::is_pointer_interconvertible_base_of_v<E, F>);\nstatic_assert (!std::is_pointer_interconvertible_base_of_v<D, G>);\nstatic_assert (!std::is_pointer_interconvertible_base_of_v<D, I>);\nstatic_assert (std::is_pointer_interconvertible_base_of_v<H, volatile I>);\nIs that a bug in my patch or is MSVC buggy on these (or mix thereof)?\nhttps://godbolt.org/z/aYeYnne9d\nshows the second testcase, here it differs on:\nstatic_assert (std::is_pointer_interconvertible_with_class<F, int> (&F::b));\nstatic_assert (std::is_pointer_interconvertible_with_class<I, int> (&I::g));\nstatic_assert (std::is_pointer_interconvertible_with_class<L, int> (&L::b));\nstatic_assert (std::is_pointer_interconvertible_with_class (&V::a));\nstatic_assert (std::is_pointer_interconvertible_with_class (&V::b));\nAgain, my bug, MSVC bug, mix thereof?\nAccording to Jason the <D, G>, <D, I> case are the subject of the\nCWG 2254 above discussed change and the rest are likely MSVC bugs.\n\nOh, and there is another thing, the standard has an example:\nstruct A { int a; };                    // a standard-layout class\nstruct B { int b; };                    // a standard-layout class\nstruct C: public A, public B { };       // not a standard-layout class\n\nstatic_assert( is_pointer_interconvertible_with_class( &C::b ) );\n  // Succeeds because, despite its appearance, &C::b has type\n  // \u201cpointer to member of B of type int\u201d.\nstatic_assert( is_pointer_interconvertible_with_class<C>( &C::b ) );\n  // Forces the use of class C, and fails.\nIt seems to work as written with MSVC (second assertion fails),\nbut fails with GCC with the patch:\n/tmp/1.C:22:57: error: no matching function for call to \u2018is_pointer_interconvertible_with_class<C>(int B::*)\u2019\n   22 | static_assert( is_pointer_interconvertible_with_class<C>( &C::b ) );\n      |                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n/tmp/1.C:8:1: note: candidate: \u2018template<class S, class M> constexpr bool std::is_pointer_interconvertible_with_class(M S::*)\u2019\n    8 | is_pointer_interconvertible_with_class (M S::*m) noexcept\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/1.C:8:1: note:   template argument deduction/substitution failed:\n/tmp/1.C:22:57: note:   mismatched types \u2018C\u2019 and \u2018B\u2019\n   22 | static_assert( is_pointer_interconvertible_with_class<C>( &C::b ) );\n      |                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\nthe second int argument isn't deduced.\n\nThis boils down to:\ntemplate <class S, class M>\nbool foo (M S::*m) noexcept;\nstruct A { int a; };\nstruct B { int b; };\nstruct C : public A, public B {};\nbool a = foo (&C::b);\nbool b = foo<C, int> (&C::b);\nbool c = foo<C> (&C::b);\nwhich with /std:c++20 or -std=c++20 is accepted by latest MSVC and ICC but\nrejected by GCC and clang (in both cases on the last line).\nIs this a GCC/clang bug in argument deduction (in that case I think we want\na separate PR), or a bug in ICC/MSVC and the standard itself that should\nspecify in the examples both template arguments instead of just the first?\nAnd this has been raised with the CWG.\n\n2021-07-30  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/101539\ngcc/c-family/\n\t* c-common.h (enum rid): Add RID_IS_POINTER_INTERCONVERTIBLE_BASE_OF.\n\t* c-common.c (c_common_reswords): Add\n\t__is_pointer_interconvertible_base_of.\ngcc/cp/\n\t* cp-tree.h (enum cp_trait_kind): Add\n\tCPTK_IS_POINTER_INTERCONVERTIBLE_BASE_OF.\n\t(enum cp_built_in_function): Add\n\tCP_BUILT_IN_IS_POINTER_INTERCONVERTIBLE_WITH_CLASS.\n\t(fold_builtin_is_pointer_inverconvertible_with_class): Declare.\n\t* parser.c (cp_parser_primary_expression): Handle\n\tRID_IS_POINTER_INTERCONVERTIBLE_BASE_OF.\n\t(cp_parser_trait_expr): Likewise.\n\t* cp-objcp-common.c (names_builtin_p): Likewise.\n\t* constraint.cc (diagnose_trait_expr): Handle\n\tCPTK_IS_POINTER_INTERCONVERTIBLE_BASE_OF.\n\t* decl.c (cxx_init_decl_processing): Register\n\t__builtin_is_pointer_interconvertible_with_class builtin.\n\t* constexpr.c (cxx_eval_builtin_function_call): Handle\n\tCP_BUILT_IN_IS_POINTER_INTERCONVERTIBLE_WITH_CLASS builtin.\n\t* semantics.c (pointer_interconvertible_base_of_p,\n\tfirst_nonstatic_data_member_p,\n\tfold_builtin_is_pointer_inverconvertible_with_class): New functions.\n\t(trait_expr_value): Handle CPTK_IS_POINTER_INTERCONVERTIBLE_BASE_OF.\n\t(finish_trait_expr): Likewise.  Formatting fix.\n\t* cp-gimplify.c (cp_gimplify_expr): Fold\n\tCP_BUILT_IN_IS_POINTER_INTERCONVERTIBLE_WITH_CLASS.  Call\n\tfndecl_built_in_p just once.\n\t(cp_fold): Likewise.\n\t* tree.c (builtin_valid_in_constant_expr_p): Handle\n\tCP_BUILT_IN_IS_POINTER_INTERCONVERTIBLE_WITH_CLASS.  Call\n\tfndecl_built_in_p just once.\n\t* cxx-pretty-print.c (pp_cxx_trait_expression): Handle\n\tCPTK_IS_POINTER_INTERCONVERTIBLE_BASE_OF.\ngcc/testsuite/\n\t* g++.dg/cpp2a/is-pointer-interconvertible-base-of1.C: New test.\n\t* g++.dg/cpp2a/is-pointer-interconvertible-with-class1.C: New test.\n\t* g++.dg/cpp2a/is-pointer-interconvertible-with-class2.C: New test.\n\t* g++.dg/cpp2a/is-pointer-interconvertible-with-class3.C: New test.\n\t* g++.dg/cpp2a/is-pointer-interconvertible-with-class4.C: New test.\n\t* g++.dg/cpp2a/is-pointer-interconvertible-with-class5.C: New test.\n\t* g++.dg/cpp2a/is-pointer-interconvertible-with-class6.C: New test.", "tree": {"sha": "650f245a19c1a68b5f04a7550e1fe409d635299a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/650f245a19c1a68b5f04a7550e1fe409d635299a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ead06c1cff8fb42b4e278c3624917e6b5477f12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ead06c1cff8fb42b4e278c3624917e6b5477f12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ead06c1cff8fb42b4e278c3624917e6b5477f12"}], "stats": {"total": 602, "additions": 578, "deletions": 24}, "files": [{"sha": "00ac3c5278b4c80cdf144457f6ceaef1df3e59de", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "patch": "@@ -421,6 +421,8 @@ const struct c_common_resword c_common_reswords[] =\n   { \"__is_enum\",\tRID_IS_ENUM,\tD_CXXONLY },\n   { \"__is_final\",\tRID_IS_FINAL,\tD_CXXONLY },\n   { \"__is_literal_type\", RID_IS_LITERAL_TYPE, D_CXXONLY },\n+  { \"__is_pointer_interconvertible_base_of\",\n+\t\t\tRID_IS_POINTER_INTERCONVERTIBLE_BASE_OF, D_CXXONLY },\n   { \"__is_pod\",\t\tRID_IS_POD,\tD_CXXONLY },\n   { \"__is_polymorphic\",\tRID_IS_POLYMORPHIC, D_CXXONLY },\n   { \"__is_same\",     RID_IS_SAME_AS, D_CXXONLY },"}, {"sha": "65d8c1c7cb679ca4b2da01ef66e5d23afe2a3834", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "patch": "@@ -174,6 +174,7 @@ enum rid\n   RID_IS_BASE_OF,              RID_IS_CLASS,\n   RID_IS_EMPTY,                RID_IS_ENUM,\n   RID_IS_FINAL,                RID_IS_LITERAL_TYPE,\n+  RID_IS_POINTER_INTERCONVERTIBLE_BASE_OF,\n   RID_IS_POD,                  RID_IS_POLYMORPHIC,\n   RID_IS_SAME_AS,\n   RID_IS_STD_LAYOUT,           RID_IS_TRIVIAL,"}, {"sha": "1af365d47b934050837ba3d62df63aca212435b0", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "patch": "@@ -1427,8 +1427,20 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n       && ctx->call\n       && ctx->call->fundef)\n     current_function_decl = ctx->call->fundef->decl;\n-  new_call = fold_builtin_call_array (EXPR_LOCATION (t), TREE_TYPE (t),\n-\t\t\t\t      CALL_EXPR_FN (t), nargs, args);\n+  if (fndecl_built_in_p (fun,\n+\t\t\t CP_BUILT_IN_IS_POINTER_INTERCONVERTIBLE_WITH_CLASS,\n+\t\t\t BUILT_IN_FRONTEND))\n+    {\n+      location_t loc = EXPR_LOCATION (t);\n+      if (nargs >= 1)\n+\tVERIFY_CONSTANT (args[0]);\n+      new_call\n+\t= fold_builtin_is_pointer_inverconvertible_with_class (loc, nargs,\n+\t\t\t\t\t\t\t       args);\n+    }\n+  else\n+    new_call = fold_builtin_call_array (EXPR_LOCATION (t), TREE_TYPE (t),\n+\t\t\t\t\tCALL_EXPR_FN (t), nargs, args);\n   current_function_decl = save_cur_fn;\n   force_folding_builtin_constant_p = save_ffbcp;\n   if (new_call == NULL)"}, {"sha": "e608c5aed1b1513cb68a87058ec30aea3059a016", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "patch": "@@ -3631,6 +3631,10 @@ diagnose_trait_expr (tree expr, tree args)\n     case CPTK_IS_LITERAL_TYPE:\n       inform (loc, \"  %qT is not a literal type\", t1);\n       break;\n+    case CPTK_IS_POINTER_INTERCONVERTIBLE_BASE_OF:\n+      inform (loc, \"  %qT is not pointer-interconvertible base of %qT\",\n+\t      t1, t2);\n+      break;\n     case CPTK_IS_POD:\n       inform (loc, \"  %qT is not a POD type\", t1);\n       break;"}, {"sha": "6e274ac62af43a34a1faec9f229f55951da8dea3", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "patch": "@@ -648,14 +648,23 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n       if (ret != GS_ERROR)\n \t{\n \t  tree decl = cp_get_callee_fndecl_nofold (*expr_p);\n-\t  if (decl\n-\t      && fndecl_built_in_p (decl, CP_BUILT_IN_IS_CONSTANT_EVALUATED,\n-\t\t\t\t    BUILT_IN_FRONTEND))\n-\t    *expr_p = boolean_false_node;\n-\t  else if (decl\n-\t\t   && fndecl_built_in_p (decl, CP_BUILT_IN_SOURCE_LOCATION,\n-\t\t\t\t\t BUILT_IN_FRONTEND))\n-\t    *expr_p = fold_builtin_source_location (EXPR_LOCATION (*expr_p));\n+\t  if (decl && fndecl_built_in_p (decl, BUILT_IN_FRONTEND))\n+\t    switch (DECL_FE_FUNCTION_CODE (decl))\n+\t      {\n+\t      case CP_BUILT_IN_IS_CONSTANT_EVALUATED:\n+\t\t*expr_p = boolean_false_node;\n+\t\tbreak;\n+\t      case CP_BUILT_IN_SOURCE_LOCATION:\n+\t\t*expr_p\n+\t\t  = fold_builtin_source_location (EXPR_LOCATION (*expr_p));\n+\t\tbreak;\n+\t      case CP_BUILT_IN_IS_POINTER_INTERCONVERTIBLE_WITH_CLASS:\n+\t\t*expr_p\n+\t\t  = fold_builtin_is_pointer_inverconvertible_with_class\n+\t\t\t(EXPR_LOCATION (*expr_p), call_expr_nargs (*expr_p),\n+\t\t\t &CALL_EXPR_ARG (*expr_p, 0));\n+\t\tbreak;\n+\t      }\n \t}\n       break;\n \n@@ -2560,11 +2569,26 @@ cp_fold (tree x)\n \t    && DECL_DECLARED_CONSTEXPR_P (current_function_decl))\n \t  nw = 1;\n \n-\t/* Defer folding __builtin_is_constant_evaluated.  */\n-\tif (callee\n-\t    && fndecl_built_in_p (callee, CP_BUILT_IN_IS_CONSTANT_EVALUATED,\n-\t\t\t\t  BUILT_IN_FRONTEND))\n-\t  break;\n+\tif (callee && fndecl_built_in_p (callee, BUILT_IN_FRONTEND))\n+\t  {\n+\t    switch (DECL_FE_FUNCTION_CODE (callee))\n+\t      {\n+\t\t/* Defer folding __builtin_is_constant_evaluated.  */\n+\t      case CP_BUILT_IN_IS_CONSTANT_EVALUATED:\n+\t\tbreak;\n+\t      case CP_BUILT_IN_SOURCE_LOCATION:\n+\t\tx = fold_builtin_source_location (EXPR_LOCATION (x));\n+\t\tbreak;\n+\t      case CP_BUILT_IN_IS_POINTER_INTERCONVERTIBLE_WITH_CLASS:\n+                x = fold_builtin_is_pointer_inverconvertible_with_class\n+\t\t\t(EXPR_LOCATION (x), call_expr_nargs (x),\n+\t\t\t &CALL_EXPR_ARG (x, 0));\n+\t\tbreak;\n+\t      default:\n+\t\tbreak;\n+\t      }\n+\t    break;\n+\t  }\n \n \tif (callee\n \t    && fndecl_built_in_p (callee, CP_BUILT_IN_SOURCE_LOCATION,"}, {"sha": "beef0123b042e8127b77ae81e81b0fa2502aa4d5", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "patch": "@@ -414,6 +414,7 @@ names_builtin_p (const char *name)\n     case RID_IS_ENUM:\n     case RID_IS_FINAL:\n     case RID_IS_LITERAL_TYPE:\n+    case RID_IS_POINTER_INTERCONVERTIBLE_BASE_OF:\n     case RID_IS_POD:\n     case RID_IS_POLYMORPHIC:\n     case RID_IS_SAME_AS:"}, {"sha": "9a47a8787d6aa2520bb990fb485314e53187c2a2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "patch": "@@ -1366,6 +1366,7 @@ enum cp_trait_kind\n   CPTK_IS_ENUM,\n   CPTK_IS_FINAL,\n   CPTK_IS_LITERAL_TYPE,\n+  CPTK_IS_POINTER_INTERCONVERTIBLE_BASE_OF,\n   CPTK_IS_POD,\n   CPTK_IS_POLYMORPHIC,\n   CPTK_IS_SAME_AS,\n@@ -6355,6 +6356,7 @@ struct GTY((chain_next (\"%h.next\"))) tinst_level {\n enum cp_built_in_function {\n   CP_BUILT_IN_IS_CONSTANT_EVALUATED,\n   CP_BUILT_IN_INTEGER_PACK,\n+  CP_BUILT_IN_IS_POINTER_INTERCONVERTIBLE_WITH_CLASS,\n   CP_BUILT_IN_SOURCE_LOCATION,\n   CP_BUILT_IN_LAST\n };\n@@ -7570,6 +7572,7 @@ extern tree baselink_for_fns                    (tree);\n extern void finish_static_assert                (tree, tree, location_t,\n \t\t\t\t\t\t bool, bool);\n extern tree finish_decltype_type                (tree, bool, tsubst_flags_t);\n+extern tree fold_builtin_is_pointer_inverconvertible_with_class (location_t, int, tree *);\n extern tree finish_trait_expr\t\t\t(location_t, enum cp_trait_kind, tree, tree);\n extern tree build_lambda_expr                   (void);\n extern tree build_lambda_object\t\t\t(tree);"}, {"sha": "b89916206a6741ce9e6ecb1188aae5a32770e2e3", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "patch": "@@ -2645,6 +2645,9 @@ pp_cxx_trait_expression (cxx_pretty_printer *pp, tree t)\n     case CPTK_IS_FINAL:\n       pp_cxx_ws_string (pp, \"__is_final\");\n       break;\n+    case CPTK_IS_POINTER_INTERCONVERTIBLE_BASE_OF:\n+      pp_cxx_ws_string (pp, \"__is_pointer_interconvertible_base_of\");\n+      break;\n     case CPTK_IS_POD:\n       pp_cxx_ws_string (pp, \"__is_pod\");\n       break;\n@@ -2695,7 +2698,9 @@ pp_cxx_trait_expression (cxx_pretty_printer *pp, tree t)\n   pp_cxx_left_paren (pp);\n   pp->type_id (TRAIT_EXPR_TYPE1 (t));\n \n-  if (kind == CPTK_IS_BASE_OF || kind == CPTK_IS_SAME_AS)\n+  if (kind == CPTK_IS_BASE_OF\n+      || kind == CPTK_IS_SAME_AS\n+      || kind == CPTK_IS_POINTER_INTERCONVERTIBLE_BASE_OF)\n     {\n       pp_cxx_separate_with (pp, ',');\n       pp->type_id (TRAIT_EXPR_TYPE2 (t));"}, {"sha": "e4be6be181981ac5f990ae647caafe44f30ec5e9", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "patch": "@@ -4467,6 +4467,15 @@ cxx_init_decl_processing (void)\n \t\t\t       BUILT_IN_FRONTEND, NULL, NULL_TREE);\n   set_call_expr_flags (decl, ECF_CONST | ECF_NOTHROW | ECF_LEAF);\n \n+  tree bool_vaftype = build_varargs_function_type_list (boolean_type_node,\n+\t\t\t\t\t\t\tNULL_TREE);\n+  decl\n+    = add_builtin_function (\"__builtin_is_pointer_interconvertible_with_class\",\n+\t\t\t    bool_vaftype,\n+\t\t\t    CP_BUILT_IN_IS_POINTER_INTERCONVERTIBLE_WITH_CLASS,\n+\t\t\t    BUILT_IN_FRONTEND, NULL, NULL_TREE);\n+  set_call_expr_flags (decl, ECF_CONST | ECF_NOTHROW | ECF_LEAF);\n+\n   integer_two_node = build_int_cst (NULL_TREE, 2);\n \n   /* Guess at the initial static decls size.  */"}, {"sha": "ab74e9d2fb752a9b216ef02bd8b6154547cfe5e6", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "patch": "@@ -5799,6 +5799,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \tcase RID_IS_ENUM:\n \tcase RID_IS_FINAL:\n \tcase RID_IS_LITERAL_TYPE:\n+\tcase RID_IS_POINTER_INTERCONVERTIBLE_BASE_OF:\n \tcase RID_IS_POD:\n \tcase RID_IS_POLYMORPHIC:\n \tcase RID_IS_SAME_AS:\n@@ -10688,6 +10689,10 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n     case RID_IS_LITERAL_TYPE:\n       kind = CPTK_IS_LITERAL_TYPE;\n       break;\n+    case RID_IS_POINTER_INTERCONVERTIBLE_BASE_OF:\n+      kind = CPTK_IS_POINTER_INTERCONVERTIBLE_BASE_OF;\n+      binary = true;\n+      break;\n     case RID_IS_POD:\n       kind = CPTK_IS_POD;\n       break;"}, {"sha": "34e5d7610b05910912583f7aad6dd7fe19ea0f73", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 111, "deletions": 3, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "patch": "@@ -10566,6 +10566,110 @@ classtype_has_nothrow_assign_or_copy_p (tree type, bool assign_p)\n   return saw_copy;\n }\n \n+/* Return true if DERIVED is pointer interconvertible base of BASE.  */\n+\n+static bool\n+pointer_interconvertible_base_of_p (tree base, tree derived)\n+{\n+  if (base == error_mark_node || derived == error_mark_node)\n+    return false;\n+  base = TYPE_MAIN_VARIANT (base);\n+  derived = TYPE_MAIN_VARIANT (derived);\n+  if (!NON_UNION_CLASS_TYPE_P (base)\n+      || !NON_UNION_CLASS_TYPE_P (derived))\n+    return false;\n+    \n+  if (same_type_p (base, derived))\n+    return true;\n+\n+  if (!std_layout_type_p (derived))\n+    return false;\n+\n+  return uniquely_derived_from_p (base, derived);\n+}\n+\n+/* Helper function for fold_builtin_is_pointer_inverconvertible_with_class,\n+   return true if MEMBERTYPE is the type of the first non-static data member\n+   of TYPE or for unions of any members.  */\n+static bool\n+first_nonstatic_data_member_p (tree type, tree membertype)\n+{\n+  for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+    {\n+      if (TREE_CODE (field) != FIELD_DECL)\n+\tcontinue;\n+      if (DECL_FIELD_IS_BASE (field) && is_empty_field (field))\n+\tcontinue;\n+      if (DECL_FIELD_IS_BASE (field))\n+\treturn first_nonstatic_data_member_p (TREE_TYPE (field), membertype);\n+      if (ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n+\t{\n+\t  if ((TREE_CODE (TREE_TYPE (field)) == UNION_TYPE\n+\t       || std_layout_type_p (TREE_TYPE (field)))\n+\t      && first_nonstatic_data_member_p (TREE_TYPE (field), membertype))\n+\t    return true;\n+\t}\n+      else if (same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (field),\n+\t\t\t\t\t\t\t  membertype))\n+\treturn true;\n+      if (TREE_CODE (type) != UNION_TYPE)\n+\treturn false;\n+    }\n+  return false;\n+}\n+\n+/* Fold __builtin_is_pointer_interconvertible_with_class call.  */\n+\n+tree\n+fold_builtin_is_pointer_inverconvertible_with_class (location_t loc, int nargs,\n+\t\t\t\t\t\t     tree *args)\n+{\n+  /* Unless users call the builtin directly, the following 3 checks should be\n+     ensured from std::is_pointer_interconvertible_with_class function\n+     template.  */\n+  if (nargs != 1)\n+    {\n+      error_at (loc, \"%<__builtin_is_pointer_interconvertible_with_class%> \"\n+\t\t     \"needs a single argument\");\n+      return boolean_false_node;\n+    }\n+  tree arg = args[0];\n+  if (error_operand_p (arg))\n+    return boolean_false_node;\n+  if (!TYPE_PTRMEM_P (TREE_TYPE (arg)))\n+    {\n+      error_at (loc, \"%<__builtin_is_pointer_interconvertible_with_class%> \"\n+\t\t     \"argument is not pointer to member\");\n+      return boolean_false_node;\n+    }\n+\n+  if (!TYPE_PTRDATAMEM_P (TREE_TYPE (arg)))\n+    return boolean_false_node;\n+\n+  tree membertype = TREE_TYPE (TREE_TYPE (arg));\n+  tree basetype = TYPE_OFFSET_BASETYPE (TREE_TYPE (arg));\n+  if (!complete_type_or_else (basetype, NULL_TREE))\n+    return boolean_false_node;\n+\n+  if (TREE_CODE (basetype) != UNION_TYPE\n+      && !std_layout_type_p (basetype))\n+    return boolean_false_node;\n+\n+  if (!first_nonstatic_data_member_p (basetype, membertype))\n+    return boolean_false_node;\n+\n+  if (TREE_CODE (arg) == PTRMEM_CST)\n+    arg = cplus_expand_constant (arg);\n+\n+  if (integer_nonzerop (arg))\n+    return boolean_false_node;\n+  if (integer_zerop (arg))\n+    return boolean_true_node;\n+\n+  return fold_build2 (EQ_EXPR, boolean_type_node, arg,\n+\t\t      build_zero_cst (TREE_TYPE (arg)));\n+}\n+\n /* Actually evaluates the trait.  */\n \n static bool\n@@ -10659,6 +10763,9 @@ trait_expr_value (cp_trait_kind kind, tree type1, tree type2)\n     case CPTK_IS_LITERAL_TYPE:\n       return literal_type_p (type1);\n \n+    case CPTK_IS_POINTER_INTERCONVERTIBLE_BASE_OF:\n+      return pointer_interconvertible_base_of_p (type1, type2);\n+\n     case CPTK_IS_POD:\n       return pod_type_p (type1);\n \n@@ -10786,6 +10893,7 @@ finish_trait_expr (location_t loc, cp_trait_kind kind, tree type1, tree type2)\n       break;\n \n     case CPTK_IS_BASE_OF:\n+    case CPTK_IS_POINTER_INTERCONVERTIBLE_BASE_OF:\n       if (NON_UNION_CLASS_TYPE_P (type1) && NON_UNION_CLASS_TYPE_P (type2)\n \t  && !same_type_ignoring_top_level_qualifiers_p (type1, type2)\n \t  && !complete_type_or_else (type2, NULL_TREE))\n@@ -10803,9 +10911,9 @@ finish_trait_expr (location_t loc, cp_trait_kind kind, tree type1, tree type2)\n       gcc_unreachable ();\n     }\n \n-tree val = (trait_expr_value (kind, type1, type2)\n-\t    ? boolean_true_node : boolean_false_node);\n- return maybe_wrap_with_location (val, loc);\n+  tree val = (trait_expr_value (kind, type1, type2)\n+\t      ? boolean_true_node : boolean_false_node);\n+  return maybe_wrap_with_location (val, loc);\n }\n \n /* Do-nothing variants of functions to handle pragma FLOAT_CONST_DECIMAL64,"}, {"sha": "8345396ec33947ca0ba51da400944d2f75a87ca6", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "patch": "@@ -450,11 +450,16 @@ builtin_valid_in_constant_expr_p (const_tree decl)\n     return false;\n   if (DECL_BUILT_IN_CLASS (decl) != BUILT_IN_NORMAL)\n     {\n-      if (fndecl_built_in_p (decl, CP_BUILT_IN_IS_CONSTANT_EVALUATED,\n-\t\t\t     BUILT_IN_FRONTEND)\n-\t  || fndecl_built_in_p (decl, CP_BUILT_IN_SOURCE_LOCATION,\n-\t\t\t\tBUILT_IN_FRONTEND))\n-\treturn true;\n+      if (fndecl_built_in_p (decl, BUILT_IN_FRONTEND))\n+\tswitch (DECL_FE_FUNCTION_CODE (decl))\n+\t  {\n+\t  case CP_BUILT_IN_IS_CONSTANT_EVALUATED:\n+\t  case CP_BUILT_IN_SOURCE_LOCATION:\n+\t  case CP_BUILT_IN_IS_POINTER_INTERCONVERTIBLE_WITH_CLASS:\n+\t    return true;\n+\t  default:\n+\t    break;\n+\t  }\n       /* Not a built-in.  */\n       return false;\n     }"}, {"sha": "d94f18fbe8a8dd68317432075b99b8314169afd4", "filename": "gcc/testsuite/g++.dg/cpp2a/is-pointer-interconvertible-base-of1.C", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-pointer-interconvertible-base-of1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-pointer-interconvertible-base-of1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-pointer-interconvertible-base-of1.C?ref=6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "patch": "@@ -0,0 +1,55 @@\n+// P0466R5\n+// { dg-do compile { target c++20 } }\n+\n+namespace std\n+{\n+template <typename T, T v>\n+struct integral_constant\n+{\n+  static constexpr T value = v;\n+};\n+\n+template <typename, typename>\n+struct is_pointer_interconvertible_base_of;\n+\n+template<typename T, typename U>\n+struct is_pointer_interconvertible_base_of\n+  : public integral_constant <bool, __is_pointer_interconvertible_base_of (T, U)>\n+{\n+};\n+\n+template <typename T, typename U>\n+inline constexpr bool is_pointer_interconvertible_base_of_v = __is_pointer_interconvertible_base_of (T, U);\n+}\n+\n+struct A;\n+struct B { int b; };\n+struct C : virtual B { int c; };\n+struct D {};\n+struct E {};\n+struct F : public B, D, E {};\n+struct G : public D, E { int g; };\n+struct H {};\n+struct I : public G, H {};\n+struct J { int j1; private: int j2; };\n+struct K : public J {};\n+union U { int a; };\n+\n+static_assert (std::is_pointer_interconvertible_base_of<A, A>::value);\n+static_assert (std::is_pointer_interconvertible_base_of_v<A, A>);\n+static_assert (std::is_pointer_interconvertible_base_of_v<const A, volatile A>);\n+static_assert (std::is_pointer_interconvertible_base_of_v<B, const B>);\n+static_assert (std::is_pointer_interconvertible_base_of_v<C, const volatile C>);\n+static_assert (!std::is_pointer_interconvertible_base_of_v<D, E>);\n+static_assert (!std::is_pointer_interconvertible_base_of_v<D, const B>);\n+static_assert (std::is_pointer_interconvertible_base_of_v<const B, F>);\n+static_assert (std::is_pointer_interconvertible_base_of_v<D, const F>);\n+static_assert (std::is_pointer_interconvertible_base_of_v<E, F>);\n+static_assert (std::is_pointer_interconvertible_base_of_v<D, volatile G>);\n+static_assert (std::is_pointer_interconvertible_base_of_v<const E, volatile G>);\n+static_assert (std::is_pointer_interconvertible_base_of_v<D, I>);\n+static_assert (std::is_pointer_interconvertible_base_of_v<const E, const I>);\n+static_assert (std::is_pointer_interconvertible_base_of_v<G, I>);\n+static_assert (std::is_pointer_interconvertible_base_of_v<H, volatile I>);\n+static_assert (!std::is_pointer_interconvertible_base_of_v<volatile J, const K>);\n+static_assert (!std::is_pointer_interconvertible_base_of_v<U, U>);"}, {"sha": "efce355f4ea226c5f6b524a7dcbcf72b4bfa3d57", "filename": "gcc/testsuite/g++.dg/cpp2a/is-pointer-interconvertible-with-class1.C", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-pointer-interconvertible-with-class1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-pointer-interconvertible-with-class1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-pointer-interconvertible-with-class1.C?ref=6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "patch": "@@ -0,0 +1,65 @@\n+// P0466R5\n+// { dg-do compile { target c++20 } }\n+\n+namespace std\n+{\n+template <class S, class M>\n+constexpr bool\n+is_pointer_interconvertible_with_class (M S::*m) noexcept\n+{\n+  return __builtin_is_pointer_interconvertible_with_class (m);\n+}\n+}\n+\n+struct A;\n+struct B { int b; double b2; };\n+struct C : virtual B { int c; };\n+struct D {};\n+struct E {};\n+struct F : public B, D, E {};\n+struct G : public D, E { int g; };\n+struct H {};\n+struct I : public G, H {};\n+struct J { int j1; private: int j2; public: int j3; };\n+struct K : public J {};\n+struct L : public B, D, E {};\n+struct M { D d [[no_unique_address]]; E e [[no_unique_address]]; int f; };\n+union U { int a; double b; long long c; };\n+struct V { union { int a; long b; }; int c; };\n+union X { int a; union { short b; long c; }; long long d; };\n+struct Y { void foo () {} };\n+union Z { int a; private: int b; protected: int c; public: int d; };\n+\n+static_assert (std::is_pointer_interconvertible_with_class (&B::b));\n+static_assert (!std::is_pointer_interconvertible_with_class (&B::b2));\n+static_assert (std::is_pointer_interconvertible_with_class (&C::b));\n+static_assert (std::is_pointer_interconvertible_with_class (&F::b));\n+static_assert (std::is_pointer_interconvertible_with_class<F, int> (&F::b));\n+static_assert (std::is_pointer_interconvertible_with_class (&G::g));\n+static_assert (std::is_pointer_interconvertible_with_class<G, int> (&G::g));\n+static_assert (std::is_pointer_interconvertible_with_class (&I::g));\n+static_assert (std::is_pointer_interconvertible_with_class<I, int> (&I::g));\n+static_assert (!std::is_pointer_interconvertible_with_class (&J::j1));\n+static_assert (!std::is_pointer_interconvertible_with_class (&J::j3));\n+static_assert (!std::is_pointer_interconvertible_with_class (&K::j1));\n+static_assert (!std::is_pointer_interconvertible_with_class (&K::j3));\n+static_assert (std::is_pointer_interconvertible_with_class (&L::b));\n+static_assert (std::is_pointer_interconvertible_with_class<L, int> (&L::b));\n+static_assert (std::is_pointer_interconvertible_with_class (&L::b));\n+static_assert (std::is_pointer_interconvertible_with_class (&M::d));\n+static_assert (!std::is_pointer_interconvertible_with_class (&M::e));\n+static_assert (!std::is_pointer_interconvertible_with_class (&M::f));\n+static_assert (std::is_pointer_interconvertible_with_class (&U::a));\n+static_assert (std::is_pointer_interconvertible_with_class (&U::b));\n+static_assert (std::is_pointer_interconvertible_with_class (&U::c));\n+static_assert (std::is_pointer_interconvertible_with_class (&V::a));\n+static_assert (std::is_pointer_interconvertible_with_class (&V::b));\n+static_assert (!std::is_pointer_interconvertible_with_class (&V::c));\n+static_assert (std::is_pointer_interconvertible_with_class (&X::a));\n+static_assert (std::is_pointer_interconvertible_with_class (&X::b));\n+static_assert (std::is_pointer_interconvertible_with_class (&X::c));\n+static_assert (std::is_pointer_interconvertible_with_class (&X::d));\n+static_assert (!std::is_pointer_interconvertible_with_class ((int B::*) nullptr));\n+static_assert (!std::is_pointer_interconvertible_with_class (&Y::foo));\n+static_assert (std::is_pointer_interconvertible_with_class (&Z::a));\n+static_assert (std::is_pointer_interconvertible_with_class (&Z::d));"}, {"sha": "b663a3933cfa0628bb0dc17392bda12d506b0003", "filename": "gcc/testsuite/g++.dg/cpp2a/is-pointer-interconvertible-with-class2.C", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-pointer-interconvertible-with-class2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-pointer-interconvertible-with-class2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-pointer-interconvertible-with-class2.C?ref=6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "patch": "@@ -0,0 +1,135 @@\n+// P0466R5\n+// { dg-do run { target c++20 } }\n+\n+namespace std\n+{\n+template <class S, class M>\n+constexpr bool\n+is_pointer_interconvertible_with_class (M S::*m) noexcept\n+{\n+  return __builtin_is_pointer_interconvertible_with_class (m);\n+}\n+}\n+\n+struct A;\n+struct B { int b; double b2; };\n+struct C : virtual B { int c; };\n+struct D {};\n+struct E {};\n+struct F : public B, D, E {};\n+struct G : public D, E { int g; };\n+struct H {};\n+struct I : public G, H {};\n+struct J { int j1; private: int j2; public: int j3; };\n+struct K : public J {};\n+struct L : public B, D, E {};\n+struct M { D d [[no_unique_address]]; E e [[no_unique_address]]; int f; };\n+union U { int a; double b; long long c; };\n+struct V { union { int a; long b; }; int c; };\n+union X { int a; union { short b; long c; }; long long d; };\n+struct Y { void foo () {} };\n+union Z { int a; private: int b; protected: int c; public: int d; };\n+\n+int\n+main ()\n+{\n+  auto t1 = &B::b;\n+  if (!std::is_pointer_interconvertible_with_class (t1))\n+    __builtin_abort ();\n+  auto t2 = &B::b2;\n+  if (std::is_pointer_interconvertible_with_class (t2))\n+    __builtin_abort ();\n+  auto t3 = &C::b;\n+  if (!std::is_pointer_interconvertible_with_class (t3))\n+    __builtin_abort ();\n+  auto t4 = &F::b;\n+  if (!std::is_pointer_interconvertible_with_class (t4))\n+    __builtin_abort ();\n+  int F::*t5 = &F::b;\n+  if (!std::is_pointer_interconvertible_with_class (t5))\n+    __builtin_abort ();\n+  auto t6 = &G::g;\n+  if (!std::is_pointer_interconvertible_with_class (t6))\n+    __builtin_abort ();\n+  int G::*t7 = &G::g;\n+  if (!std::is_pointer_interconvertible_with_class (t7))\n+    __builtin_abort ();\n+  auto t8 = &I::g;\n+  if (!std::is_pointer_interconvertible_with_class (t8))\n+    __builtin_abort ();\n+  int I::*t9 = &I::g;\n+  if (!std::is_pointer_interconvertible_with_class (t9))\n+    __builtin_abort ();\n+  auto t10 = &J::j1;\n+  if (std::is_pointer_interconvertible_with_class (t10))\n+    __builtin_abort ();\n+  auto t11 = &J::j3;\n+  if (std::is_pointer_interconvertible_with_class (t11))\n+    __builtin_abort ();\n+  auto t12 = &K::j1;\n+  if (std::is_pointer_interconvertible_with_class (t12))\n+    __builtin_abort ();\n+  auto t13 = &K::j3;\n+  if (std::is_pointer_interconvertible_with_class (t13))\n+    __builtin_abort ();\n+  auto t14 = &L::b;\n+  if (!std::is_pointer_interconvertible_with_class (t14))\n+    __builtin_abort ();\n+  int L::*t15 = &L::b;\n+  if (!std::is_pointer_interconvertible_with_class (t15))\n+    __builtin_abort ();\n+  auto t16 = &L::b;\n+  if (!std::is_pointer_interconvertible_with_class (t16))\n+    __builtin_abort ();\n+  auto t17 = &M::d;\n+  if (!std::is_pointer_interconvertible_with_class (t17))\n+    __builtin_abort ();\n+  auto t18 = &M::e;\n+  if (std::is_pointer_interconvertible_with_class (t18))\n+    __builtin_abort ();\n+  auto t19 = &M::f;\n+  if (std::is_pointer_interconvertible_with_class (t19))\n+    __builtin_abort ();\n+  auto t20 = &U::a;\n+  if (!std::is_pointer_interconvertible_with_class (t20))\n+    __builtin_abort ();\n+  auto t21 = &U::b;\n+  if (!std::is_pointer_interconvertible_with_class (t21))\n+    __builtin_abort ();\n+  auto t22 = &U::c;\n+  if (!std::is_pointer_interconvertible_with_class (t22))\n+    __builtin_abort ();\n+  auto t23 = &V::a;\n+  if (!std::is_pointer_interconvertible_with_class (t23))\n+    __builtin_abort ();\n+  auto t24 = &V::b;\n+  if (!std::is_pointer_interconvertible_with_class (t24))\n+    __builtin_abort ();\n+  auto t25 = &V::c;\n+  if (std::is_pointer_interconvertible_with_class (t25))\n+    __builtin_abort ();\n+  auto t26 = &X::a;\n+  if (!std::is_pointer_interconvertible_with_class (t26))\n+    __builtin_abort ();\n+  auto t27 = &X::b;\n+  if (!std::is_pointer_interconvertible_with_class (t27))\n+    __builtin_abort ();\n+  auto t28 = &X::c;\n+  if (!std::is_pointer_interconvertible_with_class (t28))\n+    __builtin_abort ();\n+  auto t29 = &X::d;\n+  if (!std::is_pointer_interconvertible_with_class (t29))\n+    __builtin_abort ();\n+  auto t30 = (int B::*) nullptr;\n+  if (std::is_pointer_interconvertible_with_class (t30))\n+    __builtin_abort ();\n+  auto t31 = &Y::foo;\n+  if (std::is_pointer_interconvertible_with_class (t31))\n+    __builtin_abort ();\n+  auto t32 = &Z::a;\n+  if (!std::is_pointer_interconvertible_with_class (t32))\n+    __builtin_abort ();\n+  auto t33 = &Z::d;\n+  if (!std::is_pointer_interconvertible_with_class (t33))\n+    __builtin_abort ();\n+}"}, {"sha": "b02f1b96d9f7e3c427e3325c609a49bc59fdfadc", "filename": "gcc/testsuite/g++.dg/cpp2a/is-pointer-interconvertible-with-class3.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-pointer-interconvertible-with-class3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-pointer-interconvertible-with-class3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-pointer-interconvertible-with-class3.C?ref=6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "patch": "@@ -0,0 +1,11 @@\n+// P0466R5\n+// { dg-do compile { target c++20 } }\n+\n+struct A { int a; };\n+struct B;\n+\n+bool a = __builtin_is_pointer_interconvertible_with_class ();\t\t\t// { dg-error \"needs a single argument\" }\n+bool b = __builtin_is_pointer_interconvertible_with_class (&A::a, &A::a);\t// { dg-error \"needs a single argument\" }\n+bool c = __builtin_is_pointer_interconvertible_with_class (1);\t\t\t// { dg-error \"argument is not pointer to member\" }\n+bool d = __builtin_is_pointer_interconvertible_with_class (1.0);\t\t// { dg-error \"argument is not pointer to member\" }\n+bool e = __builtin_is_pointer_interconvertible_with_class ((int B::*) nullptr);\t// { dg-error \"invalid use of incomplete type\" }"}, {"sha": "e5e24513dd0927377d6c223fa0be4d9b40473ac6", "filename": "gcc/testsuite/g++.dg/cpp2a/is-pointer-interconvertible-with-class4.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-pointer-interconvertible-with-class4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-pointer-interconvertible-with-class4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-pointer-interconvertible-with-class4.C?ref=6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "patch": "@@ -0,0 +1,31 @@\n+// P0466R5\n+// { dg-do compile { target c++20 } }\n+// { dg-options \"\" }\n+\n+namespace std\n+{\n+template <class S, class M>\n+constexpr bool\n+is_pointer_interconvertible_with_class (M S::*m) noexcept\n+{\n+  return __builtin_is_pointer_interconvertible_with_class (m);\n+}\n+}\n+\n+struct W { struct { int a; long b; }; int c; };\n+union X { int a; struct { short b; long c; }; long long d; };\n+struct D { int x; private: int y; };                                                                                                                                                  \n+union Y { int a; struct { short b; long c; D z; }; long long d; };                                                                                                                    \n+\n+static_assert (std::is_pointer_interconvertible_with_class (&W::a));\n+static_assert (!std::is_pointer_interconvertible_with_class (&W::b));\n+static_assert (!std::is_pointer_interconvertible_with_class (&W::c));\n+static_assert (std::is_pointer_interconvertible_with_class (&X::a));\n+static_assert (std::is_pointer_interconvertible_with_class (&X::b));\n+static_assert (!std::is_pointer_interconvertible_with_class (&X::c));\n+static_assert (std::is_pointer_interconvertible_with_class (&X::d));\n+static_assert (std::is_pointer_interconvertible_with_class (&Y::a));\n+static_assert (!std::is_pointer_interconvertible_with_class (&Y::b));\n+static_assert (!std::is_pointer_interconvertible_with_class (&Y::c));\n+static_assert (!std::is_pointer_interconvertible_with_class (&Y::z));\n+static_assert (std::is_pointer_interconvertible_with_class (&Y::d));"}, {"sha": "246ff92ade588dbdaf5104be438aac45e1e90181", "filename": "gcc/testsuite/g++.dg/cpp2a/is-pointer-interconvertible-with-class5.C", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-pointer-interconvertible-with-class5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-pointer-interconvertible-with-class5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-pointer-interconvertible-with-class5.C?ref=6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "patch": "@@ -0,0 +1,59 @@\n+// P0466R5\n+// { dg-do run { target c++20 } }\n+// { dg-options \"\" }\n+\n+namespace std\n+{\n+template <class S, class M>\n+constexpr bool\n+is_pointer_interconvertible_with_class (M S::*m) noexcept\n+{\n+  return __builtin_is_pointer_interconvertible_with_class (m);\n+}\n+}\n+\n+struct W { struct { int a; long b; }; int c; };\n+union X { int a; struct { short b; long c; }; long long d; };\n+struct D { int x; private: int y; };                                                                                                                                                  \n+union Y { int a; struct { short b; long c; D z; }; long long d; };                                                                                                                    \n+\n+int\n+main ()\n+{\n+  auto t1 = &W::a;\n+  if (!std::is_pointer_interconvertible_with_class (t1))\n+    __builtin_abort ();\n+  auto t2 = &W::b;\n+  if (std::is_pointer_interconvertible_with_class (t2))\n+    __builtin_abort ();\n+  auto t3 = &W::c;\n+  if (std::is_pointer_interconvertible_with_class (t3))\n+    __builtin_abort ();\n+  auto t4 = &X::a;\n+  if (!std::is_pointer_interconvertible_with_class (t4))\n+    __builtin_abort ();\n+  auto t5 = &X::b;\n+  if (!std::is_pointer_interconvertible_with_class (t5))\n+    __builtin_abort ();\n+  auto t6 = &X::c;\n+  if (std::is_pointer_interconvertible_with_class (t6))\n+    __builtin_abort ();\n+  auto t7 = &X::d;\n+  if (!std::is_pointer_interconvertible_with_class (t7))\n+    __builtin_abort ();\n+  auto t8 = &Y::a;\n+  if (!std::is_pointer_interconvertible_with_class (t8))\n+    __builtin_abort ();\n+  auto t9 = &Y::b;\n+  if (std::is_pointer_interconvertible_with_class (t9))\n+    __builtin_abort ();\n+  auto t10 = &Y::c;\n+  if (std::is_pointer_interconvertible_with_class (t10))\n+    __builtin_abort ();\n+  auto t11 = &Y::z;\n+  if (std::is_pointer_interconvertible_with_class (t11))\n+    __builtin_abort ();\n+  auto t12 = &Y::d;\n+  if (!std::is_pointer_interconvertible_with_class (t12))\n+    __builtin_abort ();\n+}"}, {"sha": "4b6801c41da61ebfdac1222e4671b59b6e42a5a2", "filename": "gcc/testsuite/g++.dg/cpp2a/is-pointer-interconvertible-with-class6.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-pointer-interconvertible-with-class6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cd005a255f15c1b4b3eaae71c844ea2592c9dce/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-pointer-interconvertible-with-class6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-pointer-interconvertible-with-class6.C?ref=6cd005a255f15c1b4b3eaae71c844ea2592c9dce", "patch": "@@ -0,0 +1,19 @@\n+// P0466R5\n+// { dg-do compile { target c++20 } }\n+\n+namespace std\n+{\n+template <class S, class M>\n+constexpr bool\n+is_pointer_interconvertible_with_class (M S::*m) noexcept\n+{\n+  return __builtin_is_pointer_interconvertible_with_class (m);\n+}\n+}\n+\n+struct A { int a; };\n+\n+double A::*a = nullptr;\n+constexpr double A::*b = nullptr;\n+constexpr auto c = std::is_pointer_interconvertible_with_class (a);\t// { dg-error \"is not usable in a constant expression\" }\n+constexpr auto d = std::is_pointer_interconvertible_with_class (b);"}]}