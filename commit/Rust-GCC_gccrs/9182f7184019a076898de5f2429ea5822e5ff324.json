{"sha": "9182f7184019a076898de5f2429ea5822e5ff324", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE4MmY3MTg0MDE5YTA3Njg5OGRlNWYyNDI5ZWE1ODIyZTVmZjMyNA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-06-29T13:03:22Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-06-29T13:03:22Z"}, "message": "re PR ada/48835 (porting GNAT to m68k-linux)\n\n\tPR ada/48835\n\tPR ada/61954\n\t* gcc-interface/gigi.h (enum standard_datatypes): Add ADT_realloc_decl\n\t(realloc_decl): New macro.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Variable>: Use local\n\tvariable for the entity type and translate it as void pointer if the\n\tentity has convention C.\n\t(gnat_to_gnu_entity) <E_Function>: If this is not a definition and the\n\texternal name matches that of malloc_decl or realloc_decl, return the\n\tcorrespoding node directly.\n\t(gnat_to_gnu_subprog_type): Likewise for parameter and return types.\n\t* gcc-interface/trans.c (gigi): Initialize void_list_node here, not...\n\tInitialize realloc_decl.\n\t* gcc-interface/utils.c (install_builtin_elementary_types): ...here.\n\t(build_void_list_node): Delete.\n\t* gcc-interface/utils2.c (known_alignment) <CALL_EXPR>: Return the\n\talignment of the system allocator for malloc_decl and realloc_decl.\n\tDo not take alignment from void pointer types either.\n\nFrom-SVN: r237850", "tree": {"sha": "3e323522044ad364a4f5045ce965e3e6397562fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e323522044ad364a4f5045ce965e3e6397562fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9182f7184019a076898de5f2429ea5822e5ff324", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9182f7184019a076898de5f2429ea5822e5ff324", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9182f7184019a076898de5f2429ea5822e5ff324", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9182f7184019a076898de5f2429ea5822e5ff324/comments", "author": null, "committer": null, "parents": [{"sha": "1af21224e417d96b363e2b7dec0cbb0e3ed78f99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1af21224e417d96b363e2b7dec0cbb0e3ed78f99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1af21224e417d96b363e2b7dec0cbb0e3ed78f99"}], "stats": {"total": 160, "additions": 103, "deletions": 57}, "files": [{"sha": "50b466a4fd8ac8d1140fb0460d766cfe63af7a76", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9182f7184019a076898de5f2429ea5822e5ff324/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9182f7184019a076898de5f2429ea5822e5ff324/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9182f7184019a076898de5f2429ea5822e5ff324", "patch": "@@ -1,3 +1,24 @@\n+2016-06-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR ada/48835\n+\tPR ada/61954\n+\t* gcc-interface/gigi.h (enum standard_datatypes): Add ADT_realloc_decl\n+\t(realloc_decl): New macro.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Variable>: Use local\n+\tvariable for the entity type and translate it as void pointer if the\n+\tentity has convention C.\n+\t(gnat_to_gnu_entity) <E_Function>: If this is not a definition and the\n+\texternal name matches that of malloc_decl or realloc_decl, return the\n+\tcorrespoding node directly.\n+\t(gnat_to_gnu_subprog_type): Likewise for parameter and return types.\n+\t* gcc-interface/trans.c (gigi): Initialize void_list_node here, not...\n+\tInitialize realloc_decl.\n+\t* gcc-interface/utils.c (install_builtin_elementary_types): ...here.\n+\t(build_void_list_node): Delete.\n+\t* gcc-interface/utils2.c (known_alignment) <CALL_EXPR>: Return the\n+\talignment of the system allocator for malloc_decl and realloc_decl.\n+\tDo not take alignment from void pointer types either.\n+\n 2016-06-29  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/misc.c (LANG_HOOKS_WARN_UNUSED_GLOBAL_DECL): Reorder."}, {"sha": "252f11e4258ab09a6e218c1e63dec1f15da2e308", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 60, "deletions": 34, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9182f7184019a076898de5f2429ea5822e5ff324/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9182f7184019a076898de5f2429ea5822e5ff324/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=9182f7184019a076898de5f2429ea5822e5ff324", "patch": "@@ -603,6 +603,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n     case E_Out_Parameter:\n     case E_Variable:\n       {\n+\tconst Entity_Id gnat_type = Etype (gnat_entity);\n \t/* Always create a variable for volatile objects and variables seen\n \t   constant but with a Linker_Section pragma.  */\n \tbool const_flag\n@@ -643,14 +644,20 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  }\n \n \t/* Get the type after elaborating the renamed object.  */\n-\tgnu_type = gnat_to_gnu_type (Etype (gnat_entity));\n-\n-\t/* If this is a standard exception definition, then use the standard\n-\t   exception type.  This is necessary to make sure that imported and\n-\t   exported views of exceptions are properly merged in LTO mode.  */\n-\tif (TREE_CODE (TYPE_NAME (gnu_type)) == TYPE_DECL\n-\t    && DECL_NAME (TYPE_NAME (gnu_type)) == exception_data_name_id)\n-\t  gnu_type = except_type_node;\n+\tif (Convention (gnat_entity) == Convention_C\n+\t    && Is_Descendant_Of_Address (gnat_type))\n+\t  gnu_type = ptr_type_node;\n+\telse\n+\t  {\n+\t    gnu_type = gnat_to_gnu_type (gnat_type);\n+\n+\t    /* If this is a standard exception definition, use the standard\n+\t       exception type.  This is necessary to make sure that imported\n+\t       and exported views of exceptions are merged in LTO mode.  */\n+\t    if (TREE_CODE (TYPE_NAME (gnu_type)) == TYPE_DECL\n+\t\t&& DECL_NAME (TYPE_NAME (gnu_type)) == exception_data_name_id)\n+\t      gnu_type = except_type_node;\n+\t  }\n \n \t/* For a debug renaming declaration, build a debug-only entity.  */\n \tif (Present (Debug_Renaming_Link (gnat_entity)))\n@@ -812,7 +819,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t     || (TYPE_SIZE (gnu_type)\n \t\t && integer_zerop (TYPE_SIZE (gnu_type))\n \t\t && !TREE_OVERFLOW (TYPE_SIZE (gnu_type))))\n-\t    && !Is_Constr_Subt_For_UN_Aliased (Etype (gnat_entity))\n+\t    && !Is_Constr_Subt_For_UN_Aliased (gnat_type)\n \t    && No (Renamed_Object (gnat_entity))\n \t    && No (Address_Clause (gnat_entity)))\n \t  gnu_size = bitsize_unit_node;\n@@ -828,8 +835,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t|| (!Optimize_Alignment_Space (gnat_entity)\n \t\t    && kind != E_Exception\n \t\t    && kind != E_Out_Parameter\n-\t\t    && Is_Composite_Type (Etype (gnat_entity))\n-\t\t    && !Is_Constr_Subt_For_UN_Aliased (Etype (gnat_entity))\n+\t\t    && Is_Composite_Type (gnat_type)\n+\t\t    && !Is_Constr_Subt_For_UN_Aliased (gnat_type)\n \t\t    && !Is_Exported (gnat_entity)\n \t\t    && !imported_p\n \t\t    && No (Renamed_Object (gnat_entity))\n@@ -895,12 +902,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t/* If this is an aliased object with an unconstrained array nominal\n \t   subtype, make a type that includes the template.  We will either\n \t   allocate or create a variable of that type, see below.  */\n-\tif (Is_Constr_Subt_For_UN_Aliased (Etype (gnat_entity))\n-\t    && Is_Array_Type (Underlying_Type (Etype (gnat_entity)))\n+\tif (Is_Constr_Subt_For_UN_Aliased (gnat_type)\n+\t    && Is_Array_Type (Underlying_Type (gnat_type))\n \t    && !type_annotate_only)\n \t  {\n-\t    tree gnu_array\n-\t      = gnat_to_gnu_type (Base_Type (Etype (gnat_entity)));\n+\t    tree gnu_array = gnat_to_gnu_type (Base_Type (gnat_type));\n \t    gnu_type\n \t      = build_unc_object_type_from_ptr (TREE_TYPE (gnu_array),\n \t\t\t\t\t\tgnu_type,\n@@ -914,7 +920,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t   without pessimizing the allocation.  This is a kludge necessary\n \t   because we don't support dynamic alignment.  */\n \tif (align == 0\n-\t    && Ekind (Etype (gnat_entity)) == E_Class_Wide_Subtype\n+\t    && Ekind (gnat_type) == E_Class_Wide_Subtype\n \t    && No (Renamed_Object (gnat_entity))\n \t    && No (Address_Clause (gnat_entity)))\n \t  align = get_target_system_allocator_alignment () * BITS_PER_UNIT;\n@@ -1194,8 +1200,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    /* If this is an aliased object with an unconstrained array nominal\n \t       subtype, then it can overlay only another aliased object with an\n \t       unconstrained array nominal subtype and compatible template.  */\n-\t    if (Is_Constr_Subt_For_UN_Aliased (Etype (gnat_entity))\n-\t\t&& Is_Array_Type (Underlying_Type (Etype (gnat_entity)))\n+\t    if (Is_Constr_Subt_For_UN_Aliased (gnat_type)\n+\t\t&& Is_Array_Type (Underlying_Type (gnat_type))\n \t\t&& !type_annotate_only)\n \t      {\n \t\ttree rec_type = TREE_TYPE (gnu_type);\n@@ -1408,8 +1414,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t   This is aimed to make it easier for the debugger to decode the\n \t   object.  Note that we have to do it this late because of the\n \t   couple of allocation adjustments that might be made above.  */\n-\tif (Is_Constr_Subt_For_UN_Aliased (Etype (gnat_entity))\n-\t    && Is_Array_Type (Underlying_Type (Etype (gnat_entity)))\n+\tif (Is_Constr_Subt_For_UN_Aliased (gnat_type)\n+\t    && Is_Array_Type (Underlying_Type (gnat_type))\n \t    && !type_annotate_only)\n \t  {\n \t    /* In case the object with the template has already been allocated\n@@ -1436,8 +1442,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\tgnu_size = NULL_TREE;\n \t      }\n \n-\t    tree gnu_array\n-\t      = gnat_to_gnu_type (Base_Type (Etype (gnat_entity)));\n+\t    tree gnu_array = gnat_to_gnu_type (Base_Type (gnat_type));\n \t    gnu_type\n \t      = build_reference_type (TYPE_OBJECT_RECORD_TYPE (gnu_array));\n \t  }\n@@ -1523,7 +1528,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t    && No (Address_Clause (gnat_entity)))\n \t\t|| Address_Taken (gnat_entity)\n \t\t|| Is_Aliased (gnat_entity)\n-\t\t|| Is_Aliased (Etype (gnat_entity))))\n+\t\t|| Is_Aliased (gnat_type)))\n \t  {\n \t    tree gnu_corr_var\n \t      = create_var_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n@@ -4269,6 +4274,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    DECL_BY_REF_P (gnu_decl) = 1;\n \t  }\n \n+\t/* If this is a mere subprogram type, just create the declaration.  */\n \telse if (kind == E_Subprogram_Type)\n \t  {\n \t    process_attributes (&gnu_type, &attr_list, false, gnat_entity);\n@@ -4278,17 +4284,28 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t\t\t  debug_info_p, gnat_entity);\n \t  }\n \n+\t/* Otherwise create the subprogram declaration with the external name,\n+\t   the type and the parameter list.  However, if this a reference to\n+\t   the allocation routines, reuse the canonical declaration nodes as\n+\t   they come with special properties.  */\n \telse\n \t  {\n-\t    gnu_decl\n-\t      = create_subprog_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n-\t\t\t\t     gnu_param_list, inline_status,\n-\t\t\t\t     public_flag, extern_flag,\n-\t\t\t\t     artificial_p, debug_info_p,\n-\t\t\t\t     attr_list, gnat_entity);\n-\n-\t    DECL_STUBBED_P (gnu_decl)\n-\t      = (Convention (gnat_entity) == Convention_Stubbed);\n+\t    if (extern_flag && gnu_ext_name == DECL_NAME (malloc_decl))\n+\t      gnu_decl = malloc_decl;\n+\t    else if (extern_flag && gnu_ext_name == DECL_NAME (realloc_decl))\n+\t      gnu_decl = realloc_decl;\n+\t    else\n+\t      {\n+\t\tgnu_decl\n+\t\t  = create_subprog_decl (gnu_entity_name, gnu_ext_name,\n+\t\t\t\t\t gnu_type, gnu_param_list,\n+\t\t\t\t\t inline_status, public_flag,\n+\t\t\t\t\t extern_flag, artificial_p,\n+\t\t\t\t\t debug_info_p, attr_list, gnat_entity);\n+\n+\t\tDECL_STUBBED_P (gnu_decl)\n+\t\t  = (Convention (gnat_entity) == Convention_Stubbed);\n+\t      }\n \t  }\n       }\n       break;\n@@ -5754,7 +5771,11 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \n   else\n     {\n-      gnu_return_type = gnat_to_gnu_profile_type (gnat_return_type);\n+      if (Convention (gnat_subprog) == Convention_C\n+\t  && Is_Descendant_Of_Address (gnat_return_type))\n+\tgnu_return_type = ptr_type_node;\n+      else\n+\tgnu_return_type = gnat_to_gnu_profile_type (gnat_return_type);\n \n       /* If this function returns by reference, make the actual return type\n \t the reference type and make a note of that.  */\n@@ -5914,7 +5935,12 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n       else\n \t{\n \t  Entity_Id gnat_param_type = Etype (gnat_param);\n-\t  gnu_param_type = gnat_to_gnu_profile_type (gnat_param_type);\n+\n+\t  if (Convention (gnat_subprog) == Convention_C\n+\t      && Is_Descendant_Of_Address (gnat_param_type))\n+\t    gnu_param_type = ptr_type_node;\n+\t  else\n+\t    gnu_param_type = gnat_to_gnu_profile_type (gnat_param_type);\n \n \t  /* If the parameter type is incomplete, there are 2 cases: if it is\n \t     passed by reference, then the type is only linked indirectly in"}, {"sha": "b4fa83f28c282b5d4be1bcbf193589a6f7c6268b", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9182f7184019a076898de5f2429ea5822e5ff324/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9182f7184019a076898de5f2429ea5822e5ff324/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=9182f7184019a076898de5f2429ea5822e5ff324", "patch": "@@ -394,13 +394,15 @@ enum standard_datatypes\n   /* Value BITS_PER_UNIT in signed bitsizetype.  */\n   ADT_sbitsize_unit_node,\n \n-  /* Function declaration nodes for run-time functions for allocating memory.\n-     Ada allocators cause calls to this function to be generated.  */\n+  /* Function declaration node for run-time allocation function.  */\n   ADT_malloc_decl,\n \n-  /* Likewise for freeing memory.  */\n+  /* Function declaration node for run-time freeing function.  */\n   ADT_free_decl,\n \n+  /* Function declaration node for run-time reallocation function.  */\n+  ADT_realloc_decl,\n+\n   /* Function decl node for 64-bit multiplication with overflow checking.  */\n   ADT_mulv64_decl,\n \n@@ -471,6 +473,7 @@ extern GTY(()) tree gnat_raise_decls_ext[(int) LAST_REASON_CODE + 1];\n #define sbitsize_unit_node gnat_std_decls[(int) ADT_sbitsize_unit_node]\n #define malloc_decl gnat_std_decls[(int) ADT_malloc_decl]\n #define free_decl gnat_std_decls[(int) ADT_free_decl]\n+#define realloc_decl gnat_std_decls[(int) ADT_realloc_decl]\n #define mulv64_decl gnat_std_decls[(int) ADT_mulv64_decl]\n #define parent_name_id gnat_std_decls[(int) ADT_parent_name_id]\n #define exception_data_name_id gnat_std_decls[(int) ADT_exception_data_name_id]"}, {"sha": "e23724312b711815c1c8a1c8d7bf0b797c7748aa", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9182f7184019a076898de5f2429ea5822e5ff324/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9182f7184019a076898de5f2429ea5822e5ff324/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=9182f7184019a076898de5f2429ea5822e5ff324", "patch": "@@ -387,27 +387,32 @@ gigi (Node_Id gnat_root,\n \t\t       true, false, NULL, gnat_literal);\n   save_gnu_tree (gnat_literal, t, false);\n \n+  /* Declare the building blocks of function nodes.  */\n+  void_list_node = build_tree_list (NULL_TREE, void_type_node);\n   void_ftype = build_function_type_list (void_type_node, NULL_TREE);\n   ptr_void_ftype = build_pointer_type (void_ftype);\n \n   /* Now declare run-time functions.  */\n   ftype = build_function_type_list (ptr_type_node, sizetype, NULL_TREE);\n-\n-  /* malloc is a function declaration tree for a function to allocate\n-     memory.  */\n   malloc_decl\n     = create_subprog_decl (get_identifier (\"__gnat_malloc\"), NULL_TREE,\n \t\t\t   ftype,\n \t\t\t   NULL_TREE, is_disabled, true, true, true, false,\n \t\t\t   NULL, Empty);\n   DECL_IS_MALLOC (malloc_decl) = 1;\n \n-  /* free is a function declaration tree for a function to free memory.  */\n+  ftype = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n   free_decl\n     = create_subprog_decl (get_identifier (\"__gnat_free\"), NULL_TREE,\n-\t\t\t   build_function_type_list (void_type_node,\n-\t\t\t\t\t\t     ptr_type_node,\n-\t\t\t\t\t\t     NULL_TREE),\n+\t\t\t   ftype,\n+\t\t\t   NULL_TREE, is_disabled, true, true, true, false,\n+\t\t\t   NULL, Empty);\n+\n+  ftype = build_function_type_list (ptr_type_node, ptr_type_node, sizetype,\n+\t\t\t\t    NULL_TREE);\n+  realloc_decl\n+    = create_subprog_decl (get_identifier (\"__gnat_realloc\"), NULL_TREE,\n+\t\t\t   ftype,\n \t\t\t   NULL_TREE, is_disabled, true, true, true, false,\n \t\t\t   NULL, Empty);\n "}, {"sha": "66c5408c564d810b9ed4306d9c4d09a2121fd140", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9182f7184019a076898de5f2429ea5822e5ff324/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9182f7184019a076898de5f2429ea5822e5ff324/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=9182f7184019a076898de5f2429ea5822e5ff324", "patch": "@@ -5432,15 +5432,6 @@ static tree c_global_trees[CTI_MAX];\n #define intmax_type_node  void_type_node\n #define uintmax_type_node void_type_node\n \n-/* Build the void_list_node (void_type_node having been created).  */\n-\n-static tree\n-build_void_list_node (void)\n-{\n-  tree t = build_tree_list (NULL_TREE, void_type_node);\n-  return t;\n-}\n-\n /* Used to help initialize the builtin-types.def table.  When a type of\n    the correct size doesn't exist, use error_mark_node instead of NULL.\n    The later results in segfaults even when a decl using the type doesn't\n@@ -5461,7 +5452,6 @@ install_builtin_elementary_types (void)\n {\n   signed_size_type_node = gnat_signed_type_for (size_type_node);\n   pid_type_node = integer_type_node;\n-  void_list_node = build_void_list_node ();\n \n   string_type_node = build_pointer_type (char_type_node);\n   const_string_type_node"}, {"sha": "638d59b6f9ca392cd2265b4de607e7f7e6af3f38", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9182f7184019a076898de5f2429ea5822e5ff324/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9182f7184019a076898de5f2429ea5822e5ff324/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=9182f7184019a076898de5f2429ea5822e5ff324", "patch": "@@ -171,8 +171,8 @@ known_alignment (tree exp)\n \n     case CALL_EXPR:\n       {\n-\ttree func = get_callee_fndecl (exp);\n-\tif (func && DECL_IS_MALLOC (func))\n+\ttree fndecl = get_callee_fndecl (exp);\n+\tif (fndecl == malloc_decl || fndecl == realloc_decl)\n \t  return get_target_system_allocator_alignment () * BITS_PER_UNIT;\n \n \ttree t = maybe_inline_call_in_expr (exp);\n@@ -188,7 +188,8 @@ known_alignment (tree exp)\n \t have a dummy type here (e.g. a Taft Amendment type), for which the\n \t alignment is meaningless and should be ignored.  */\n       if (POINTER_TYPE_P (TREE_TYPE (exp))\n-\t  && !TYPE_IS_DUMMY_P (TREE_TYPE (TREE_TYPE (exp))))\n+\t  && !TYPE_IS_DUMMY_P (TREE_TYPE (TREE_TYPE (exp)))\n+\t  && !VOID_TYPE_P (TREE_TYPE (TREE_TYPE (exp))))\n \tthis_alignment = TYPE_ALIGN (TREE_TYPE (TREE_TYPE (exp)));\n       else\n \tthis_alignment = 0;"}]}