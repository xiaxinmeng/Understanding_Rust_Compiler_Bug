{"sha": "363080bb8bd2cca81dd9e2e774910a8c8226f430", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzYzMDgwYmI4YmQyY2NhODFkZDllMmU3NzQ5MTBhOGM4MjI2ZjQzMA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-08-24T11:21:10Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-08-26T08:03:19Z"}, "message": "IPA symver: allow multiple symvers for a definition\n\ngcc/ChangeLog:\n\n\t* cgraphunit.c (process_symver_attribute): Allow multiple\n\tsymver attributes for one symbol.\n\t* doc/extend.texi: Document the change.\n\ngcc/testsuite/ChangeLog:\n\n\t* lib/target-supports-dg.exp: Add dg-require-symver.\n\t* lib/target-supports.exp: Likewise.\n\t* gcc.dg/ipa/symver1.c: New test.", "tree": {"sha": "dbd812c1ccd60680bc8aaaa61140d251e64efc4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbd812c1ccd60680bc8aaaa61140d251e64efc4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/363080bb8bd2cca81dd9e2e774910a8c8226f430", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/363080bb8bd2cca81dd9e2e774910a8c8226f430", "html_url": "https://github.com/Rust-GCC/gccrs/commit/363080bb8bd2cca81dd9e2e774910a8c8226f430", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/363080bb8bd2cca81dd9e2e774910a8c8226f430/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d58e7173ef964ddac3ab3ad8cc97de8f9f3b32ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d58e7173ef964ddac3ab3ad8cc97de8f9f3b32ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d58e7173ef964ddac3ab3ad8cc97de8f9f3b32ee"}], "stats": {"total": 192, "additions": 116, "deletions": 76}, "files": [{"sha": "fa3aec79a48e0d2d0657066841dbf05307fbf929", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 72, "deletions": 71, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/363080bb8bd2cca81dd9e2e774910a8c8226f430/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/363080bb8bd2cca81dd9e2e774910a8c8226f430/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=363080bb8bd2cca81dd9e2e774910a8c8226f430", "patch": "@@ -720,80 +720,81 @@ process_symver_attribute (symtab_node *n)\n {\n   tree value = lookup_attribute (\"symver\", DECL_ATTRIBUTES (n->decl));\n \n-  if (!value)\n-    return;\n-  if (lookup_attribute (\"symver\", TREE_CHAIN (value)))\n+  for (; value != NULL; value = TREE_CHAIN (value))\n     {\n-      error_at (DECL_SOURCE_LOCATION (n->decl),\n-\t\t\"multiple versions for one symbol\");\n-      return;\n-    }\n-  tree symver = get_identifier_with_length\n-\t\t  (TREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (value))),\n-\t\t   TREE_STRING_LENGTH (TREE_VALUE (TREE_VALUE (value))));\n-  symtab_node *def = symtab_node::get_for_asmname (symver);\n+      /* Starting from bintuils 2.35 gas supports:\n+\t  # Assign foo to bar@V1 and baz@V2.\n+\t  .symver foo, bar@V1\n+\t  .symver foo, baz@V2\n+      */\n+\n+      tree symver = get_identifier_with_length\n+\t(TREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (value))),\n+\t TREE_STRING_LENGTH (TREE_VALUE (TREE_VALUE (value))));\n+      symtab_node *def = symtab_node::get_for_asmname (symver);\n+\n+      if (def)\n+\t{\n+\t  error_at (DECL_SOURCE_LOCATION (n->decl),\n+\t\t    \"duplicate definition of a symbol version\");\n+\t  inform (DECL_SOURCE_LOCATION (def->decl),\n+\t\t  \"same version was previously defined here\");\n+\t  return;\n+\t}\n+      if (!n->definition)\n+\t{\n+\t  error_at (DECL_SOURCE_LOCATION (n->decl),\n+\t\t    \"symbol needs to be defined to have a version\");\n+\t  return;\n+\t}\n+      if (DECL_COMMON (n->decl))\n+\t{\n+\t  error_at (DECL_SOURCE_LOCATION (n->decl),\n+\t\t    \"common symbol cannot be versioned\");\n+\t  return;\n+\t}\n+      if (DECL_COMDAT (n->decl))\n+\t{\n+\t  error_at (DECL_SOURCE_LOCATION (n->decl),\n+\t\t    \"comdat symbol cannot be versioned\");\n+\t  return;\n+\t}\n+      if (n->weakref)\n+\t{\n+\t  error_at (DECL_SOURCE_LOCATION (n->decl),\n+\t\t    \"%<weakref%> cannot be versioned\");\n+\t  return;\n+\t}\n+      if (!TREE_PUBLIC (n->decl))\n+\t{\n+\t  error_at (DECL_SOURCE_LOCATION (n->decl),\n+\t\t    \"versioned symbol must be public\");\n+\t  return;\n+\t}\n+      if (DECL_VISIBILITY (n->decl) != VISIBILITY_DEFAULT)\n+\t{\n+\t  error_at (DECL_SOURCE_LOCATION (n->decl),\n+\t\t    \"versioned symbol must have default visibility\");\n+\t  return;\n+\t}\n \n-  if (def)\n-    {\n-      error_at (DECL_SOURCE_LOCATION (n->decl),\n-\t\t\"duplicate definition of a symbol version\");\n-      inform (DECL_SOURCE_LOCATION (def->decl),\n-\t      \"same version was previously defined here\");\n-      return;\n-    }\n-  if (!n->definition)\n-    {\n-      error_at (DECL_SOURCE_LOCATION (n->decl),\n-\t\t\"symbol needs to be defined to have a version\");\n-      return;\n-    }\n-  if (DECL_COMMON (n->decl))\n-    {\n-      error_at (DECL_SOURCE_LOCATION (n->decl),\n-\t\t\"common symbol cannot be versioned\");\n-      return;\n-    }\n-  if (DECL_COMDAT (n->decl))\n-    {\n-      error_at (DECL_SOURCE_LOCATION (n->decl),\n-\t\t\"comdat symbol cannot be versioned\");\n-      return;\n-    }\n-  if (n->weakref)\n-    {\n-      error_at (DECL_SOURCE_LOCATION (n->decl),\n-\t\t\"%<weakref%> cannot be versioned\");\n-      return;\n+      /* Create new symbol table entry representing the version.  */\n+      tree new_decl = copy_node (n->decl);\n+\n+      DECL_INITIAL (new_decl) = NULL_TREE;\n+      if (TREE_CODE (new_decl) == FUNCTION_DECL)\n+\tDECL_STRUCT_FUNCTION (new_decl) = NULL;\n+      SET_DECL_ASSEMBLER_NAME (new_decl, symver);\n+      TREE_PUBLIC (new_decl) = 1;\n+      DECL_ATTRIBUTES (new_decl) = NULL;\n+\n+      symtab_node *symver_node = symtab_node::get_create (new_decl);\n+      symver_node->alias = true;\n+      symver_node->definition = true;\n+      symver_node->symver = true;\n+      symver_node->create_reference (n, IPA_REF_ALIAS, NULL);\n+      symver_node->analyzed = true;\n     }\n-  if (!TREE_PUBLIC (n->decl))\n-    {\n-      error_at (DECL_SOURCE_LOCATION (n->decl),\n-\t\t\"versioned symbol must be public\");\n-      return;\n-    }\n-  if (DECL_VISIBILITY (n->decl) != VISIBILITY_DEFAULT)\n-    {\n-      error_at (DECL_SOURCE_LOCATION (n->decl),\n-\t\t\"versioned symbol must have default visibility\");\n-      return;\n-    }\n-\n-  /* Create new symbol table entry representing the version.  */\n-  tree new_decl = copy_node (n->decl);\n-\n-  DECL_INITIAL (new_decl) = NULL_TREE;\n-  if (TREE_CODE (new_decl) == FUNCTION_DECL)\n-    DECL_STRUCT_FUNCTION (new_decl) = NULL;\n-  SET_DECL_ASSEMBLER_NAME (new_decl, symver);\n-  TREE_PUBLIC (new_decl) = 1;\n-  DECL_ATTRIBUTES (new_decl) = NULL;\n-\n-  symtab_node *symver_node = symtab_node::get_create (new_decl);\n-  symver_node->alias = true;\n-  symver_node->definition = true;\n-  symver_node->symver = true;\n-  symver_node->create_reference (n, IPA_REF_ALIAS, NULL);\n-  symver_node->analyzed = true;\n }\n \n /* Process attributes common for vars and functions.  */"}, {"sha": "3b37aba5795d1689890e51390187a15caac4d891", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/363080bb8bd2cca81dd9e2e774910a8c8226f430/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/363080bb8bd2cca81dd9e2e774910a8c8226f430/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=363080bb8bd2cca81dd9e2e774910a8c8226f430", "patch": "@@ -3742,13 +3742,19 @@ foo_v1 (void)\n Will produce a @code{.symver foo_v1, foo@@VERS_1} directive in the assembler\n output. \n \n-It's an error to define multiple version of a given symbol.  In such case\n-an alias can be used.\n+One can also define multiple version for a given symbol.\n \n @smallexample\n-__attribute__ ((__symver__ (\"foo@@VERS_2\")))\n-__attribute__ ((alias (\"foo_v1\")))\n-int symver_foo_v1 (void);\n+__attribute__ ((__symver__ (\"foo@@VERS_2\"), (\"foo@@VERS_3\")))\n+int symver_foo_v1 (void)\n+@{\n+@}\n+\n+__attribute__ ((__symver__ (\"bar@@VERS_2\"))))\n+__attribute__ ((__symver__ (\"bar@@VERS_3\"))))\n+int symver_bar_v1 (void)\n+@{\n+@}\n @end smallexample\n \n This example creates an alias of @code{foo_v1} with symbol name"}, {"sha": "645de7ea259ee346d53c6048ae5e8cd59d7ce196", "filename": "gcc/testsuite/gcc.dg/ipa/symver1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/363080bb8bd2cca81dd9e2e774910a8c8226f430/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fsymver1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/363080bb8bd2cca81dd9e2e774910a8c8226f430/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fsymver1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fsymver1.c?ref=363080bb8bd2cca81dd9e2e774910a8c8226f430", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+\n+__attribute__ ((__symver__ (\"foo@VER_2\")))\n+__attribute__ ((__symver__ (\"foo@VER_3\")))\n+int foo()\n+{\n+  return 2;\n+}\n+\n+/* { dg-final { scan-assembler \".symver.*foo, foo@VER_2\" } } */\n+/* { dg-final { scan-assembler \".symver.*foo, foo@VER_3\" } } */"}, {"sha": "4a03eaae9cecc57d505f2d691c7f0178f5cf5d3b", "filename": "gcc/testsuite/lib/target-supports-dg.exp", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/363080bb8bd2cca81dd9e2e774910a8c8226f430/gcc%2Ftestsuite%2Flib%2Ftarget-supports-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/363080bb8bd2cca81dd9e2e774910a8c8226f430/gcc%2Ftestsuite%2Flib%2Ftarget-supports-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports-dg.exp?ref=363080bb8bd2cca81dd9e2e774910a8c8226f430", "patch": "@@ -665,3 +665,13 @@ if { [info procs saved-dg-process-target] == [list] } {\n \treturn [dg-process-target-1 $selector]\n     }\n }\n+\n+# If this target does not support the \"symver\" attribute, skip this\n+# test.\n+\n+proc dg-require-symver { args } {\n+    if { ![ check_symver_available ] } {\n+\tupvar dg-do-what dg-do-what\n+\tset dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n+    }\n+}"}, {"sha": "f3fc5b80aea34911536de6535c9ca28c9a3d83a6", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/363080bb8bd2cca81dd9e2e774910a8c8226f430/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/363080bb8bd2cca81dd9e2e774910a8c8226f430/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=363080bb8bd2cca81dd9e2e774910a8c8226f430", "patch": "@@ -10445,3 +10445,15 @@ proc check_effective_target_large_initializer { } {\n \n     return 1\n }\n+# Returns 1 if the target toolchain supports extended\n+# syntax of .symver directive, 0 otherwise.\n+\n+proc check_symver_available { } {\n+    return [check_no_compiler_messages symver_available object {\n+\t    int foo(void) { return 0; }\n+\t    int main (void) {\n+\t\tasm volatile (\".symver foo,foo@VER_1, local\");\n+\t\treturn 0;\n+\t    }\n+\t}]\n+}"}]}