{"sha": "d95787e646b7b5f027d7f241707aa0f297949792", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk1Nzg3ZTY0NmI3YjVmMDI3ZDdmMjQxNzA3YWEwZjI5Nzk0OTc5Mg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2007-01-13T05:39:00Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2007-01-13T05:39:00Z"}, "message": "tree.h (force_fit_type_double): Remove unused final argument.\n\n\n\t* tree.h (force_fit_type_double): Remove unused final argument.\n\t* c-common.c (constant_expression_warning): Replace use of\n\tTREE_CONSTANT_OVERFLOW with TREE_OVERFLOW.\n\t(convert_and_check): Likewise.\n\t(shorten_compare): Update call to force_fit_type_double.\n\t(c_common_truthvalue_conversion) <INTEGER_CST>: Use integer_zerop.\n\t* convert.c (convert_to_pointer): Update call to\n\tforce_fit_type_double.\n\t* fold-const.c (force_fit_type_double): Remove overflowed_const\n\targument.\n\t(int_const_binop, fold_convert_const_int_from_int,\n\tfold_convert_const_int_from_real, fold_div_compare,\n\tfold_sign_changed_comparison, fold_unary, fold_negate_const,\n\tfold_abs_const, fold_not_const): Remove the final argument from\n\tcalls to force_fit_type_double.\n\nFrom-SVN: r120746", "tree": {"sha": "e6f9075eb903f1a0ecf0a576fa00b45214c11b15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6f9075eb903f1a0ecf0a576fa00b45214c11b15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d95787e646b7b5f027d7f241707aa0f297949792", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d95787e646b7b5f027d7f241707aa0f297949792", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d95787e646b7b5f027d7f241707aa0f297949792", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d95787e646b7b5f027d7f241707aa0f297949792/comments", "author": null, "committer": null, "parents": [{"sha": "6ef795d2e127b3245150c52931d16a07cae68deb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ef795d2e127b3245150c52931d16a07cae68deb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ef795d2e127b3245150c52931d16a07cae68deb"}], "stats": {"total": 89, "additions": 46, "deletions": 43}, "files": [{"sha": "17baae3bb98f4c55b63e0713687c910567948f4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95787e646b7b5f027d7f241707aa0f297949792/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95787e646b7b5f027d7f241707aa0f297949792/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d95787e646b7b5f027d7f241707aa0f297949792", "patch": "@@ -1,3 +1,21 @@\n+2007-01-12  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* tree.h (force_fit_type_double): Remove unused final argument.\n+\t* c-common.c (constant_expression_warning): Replace use of\n+\tTREE_CONSTANT_OVERFLOW with TREE_OVERFLOW.\n+\t(convert_and_check): Likewise.\n+\t(shorten_compare): Update call to force_fit_type_double.\n+\t(c_common_truthvalue_conversion) <INTEGER_CST>: Use integer_zerop.\n+\t* convert.c (convert_to_pointer): Update call to\n+\tforce_fit_type_double.\n+\t* fold-const.c (force_fit_type_double): Remove overflowed_const\n+\targument.\n+\t(int_const_binop, fold_convert_const_int_from_int,\n+\tfold_convert_const_int_from_real, fold_div_compare,\n+\tfold_sign_changed_comparison, fold_unary, fold_negate_const,\n+\tfold_abs_const, fold_not_const): Remove the final argument from\n+\tcalls to force_fit_type_double.\n+\n 2007-01-12  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \t* configure.ac: Set insn to \"nop\" for spu-*-* also."}, {"sha": "4b1718cd817dffc721c0dabe84f6a22cc7744a3a", "filename": "gcc/c-common.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95787e646b7b5f027d7f241707aa0f297949792/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95787e646b7b5f027d7f241707aa0f297949792/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=d95787e646b7b5f027d7f241707aa0f297949792", "patch": "@@ -918,7 +918,7 @@ constant_expression_warning (tree value)\n   if ((TREE_CODE (value) == INTEGER_CST || TREE_CODE (value) == REAL_CST\n        || TREE_CODE (value) == VECTOR_CST\n        || TREE_CODE (value) == COMPLEX_CST)\n-      && TREE_CONSTANT_OVERFLOW (value)\n+      && TREE_OVERFLOW (value)\n       && warn_overflow\n       && pedantic)\n     pedwarn (\"overflow in constant expression\");\n@@ -1257,11 +1257,8 @@ convert_and_check (tree type, tree expr)\n       /* Do not diagnose overflow in a constant expression merely\n          because a conversion overflowed.  */\n       if (TREE_OVERFLOW (result))\n-        {\n-          TREE_CONSTANT_OVERFLOW (result) = TREE_CONSTANT_OVERFLOW (expr);\n-          TREE_OVERFLOW (result) = TREE_OVERFLOW (expr);\n-        }\n-      \n+        TREE_OVERFLOW (result) = TREE_OVERFLOW (expr);\n+\n       if (TYPE_UNSIGNED (type))\n         {\n           /* This detects cases like converting -129 or 256 to\n@@ -2323,8 +2320,7 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n \t  primop1 = force_fit_type_double (*restype_ptr,\n \t\t\t\t\t   TREE_INT_CST_LOW (primop1),\n \t\t\t\t\t   TREE_INT_CST_HIGH (primop1), 0,\n-\t\t\t\t\t   TREE_OVERFLOW (primop1),\n-\t\t\t\t\t   TREE_CONSTANT_OVERFLOW (primop1));\n+\t\t\t\t\t   TREE_OVERFLOW (primop1));\n \t}\n       if (type != *restype_ptr)\n \t{\n@@ -2685,10 +2681,8 @@ c_common_truthvalue_conversion (tree expr)\n       return expr;\n \n     case INTEGER_CST:\n-      /* Avoid integer_zerop to ignore TREE_CONSTANT_OVERFLOW.  */\n-      return (TREE_INT_CST_LOW (expr) != 0 || TREE_INT_CST_HIGH (expr) != 0)\n-\t     ? truthvalue_true_node\n-\t     : truthvalue_false_node;\n+      return integer_zerop (expr) ? truthvalue_false_node\n+\t\t\t\t  : truthvalue_true_node;\n \n     case REAL_CST:\n       return real_compare (NE_EXPR, &TREE_REAL_CST (expr), &dconst0)"}, {"sha": "b7d26ee3c0a0a148fb8e8f752ee67aa36af9cbf5", "filename": "gcc/convert.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95787e646b7b5f027d7f241707aa0f297949792/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95787e646b7b5f027d7f241707aa0f297949792/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=d95787e646b7b5f027d7f241707aa0f297949792", "patch": "@@ -47,8 +47,7 @@ convert_to_pointer (tree type, tree expr)\n \n   /* Propagate overflow to the NULL pointer.  */\n   if (integer_zerop (expr))\n-    return force_fit_type_double (type, 0, 0, 0, TREE_OVERFLOW (expr),\n-\t\t\t\t  false);\n+    return force_fit_type_double (type, 0, 0, 0, TREE_OVERFLOW (expr));\n \n   switch (TREE_CODE (TREE_TYPE (expr)))\n     {"}, {"sha": "2ae560fa3bdad65984f54658d472fc3cf0fc99ff", "filename": "gcc/fold-const.c", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95787e646b7b5f027d7f241707aa0f297949792/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95787e646b7b5f027d7f241707aa0f297949792/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=d95787e646b7b5f027d7f241707aa0f297949792", "patch": "@@ -1,6 +1,7 @@\n /* Fold a constant sub-tree into a single node for C-compiler\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -28,7 +29,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n   @@ for cross-compilers.  */\n \n /* The entry points in this file are fold, size_int_wide, size_binop\n-   and force_fit_type.\n+   and force_fit_type_double.\n \n    fold takes a tree as argument and returns a simplified tree.\n \n@@ -39,10 +40,10 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    size_int takes an integer value, and creates a tree constant\n    with type from `sizetype'.\n \n-   force_fit_type takes a constant, an overflowable flag and prior\n-   overflow indicators.  It forces the value to fit the type and sets\n-   TREE_OVERFLOW as appropriate.\n-   \n+   force_fit_type_double takes a constant, an overflowable flag and a\n+   prior overflow indicator.  It forces the value to fit the type and\n+   sets TREE_OVERFLOW.\n+\n    Note: Since the folders get called on non-gimple code as well as\n    gimple code, we need to handle GIMPLE tuples as well as their\n    corresponding tree equivalents.  */\n@@ -281,7 +282,7 @@ fit_double_type (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n tree\n force_fit_type_double (tree type, unsigned HOST_WIDE_INT low,\n \t\t       HOST_WIDE_INT high, int overflowable,\n-\t\t       bool overflowed, bool overflowed_const)\n+\t\t       bool overflowed)\n {\n   int sign_extended_type;\n   bool overflow;\n@@ -294,7 +295,7 @@ force_fit_type_double (tree type, unsigned HOST_WIDE_INT low,\n   overflow = fit_double_type (low, high, &low, &high, type);\n \n   /* If we need to set overflow flags, return a new unshared node.  */\n-  if (overflowed || overflowed_const || overflow)\n+  if (overflowed || overflow)\n     {\n       if (overflowed\n \t  || overflowable < 0\n@@ -1607,8 +1608,7 @@ int_const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n   else\n     t = force_fit_type_double (TREE_TYPE (arg1), low, hi, 1,\n \t\t\t       ((!uns || is_sizetype) && overflow)\n-\t\t\t       | TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2),\n-\t\t\t       false);\n+\t\t\t       | TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2));\n \n   return t;\n }\n@@ -1884,8 +1884,7 @@ fold_convert_const_int_from_int (tree type, tree arg1)\n \t\t\t     (TREE_INT_CST_HIGH (arg1) < 0\n \t\t \t      && (TYPE_UNSIGNED (type)\n \t\t\t\t  < TYPE_UNSIGNED (TREE_TYPE (arg1))))\n-\t\t\t     | TREE_OVERFLOW (arg1),\n-\t\t\t     false);\n+\t\t\t     | TREE_OVERFLOW (arg1));\n \n   return t;\n }\n@@ -1964,8 +1963,7 @@ fold_convert_const_int_from_real (enum tree_code code, tree type, tree arg1)\n     REAL_VALUE_TO_INT (&low, &high, r);\n \n   t = force_fit_type_double (type, low, high, -1,\n-\t\t\t     overflow | TREE_OVERFLOW (arg1),\n-\t\t\t     false);\n+\t\t\t     overflow | TREE_OVERFLOW (arg1));\n   return t;\n }\n \n@@ -6143,7 +6141,7 @@ fold_div_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n \t\t\t\t   TREE_INT_CST_HIGH (arg1),\n \t\t\t\t   &lpart, &hpart, unsigned_p);\n   prod = force_fit_type_double (TREE_TYPE (arg00), lpart, hpart,\n-\t\t\t\t-1, overflow, false);\n+\t\t\t\t-1, overflow);\n   neg_overflow = false;\n \n   if (unsigned_p)\n@@ -6159,8 +6157,7 @@ fold_div_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n \t\t\t\t       TREE_INT_CST_HIGH (tmp),\n \t\t\t\t       &lpart, &hpart, unsigned_p);\n       hi = force_fit_type_double (TREE_TYPE (arg00), lpart, hpart,\n-\t\t\t\t  -1, overflow | TREE_OVERFLOW (prod),\n-\t\t\t\t  false);\n+\t\t\t\t  -1, overflow | TREE_OVERFLOW (prod));\n     }\n   else if (tree_int_cst_sgn (arg01) >= 0)\n     {\n@@ -6596,8 +6593,7 @@ fold_sign_changed_comparison (enum tree_code code, tree type,\n   if (TREE_CODE (arg1) == INTEGER_CST)\n     arg1 = force_fit_type_double (inner_type, TREE_INT_CST_LOW (arg1),\n \t\t\t\t  TREE_INT_CST_HIGH (arg1), 0,\n-\t\t\t\t  TREE_OVERFLOW (arg1),\n-\t\t\t\t  false);\n+\t\t\t\t  TREE_OVERFLOW (arg1));\n   else\n     arg1 = fold_convert (inner_type, arg1);\n \n@@ -7531,8 +7527,7 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t    {\n \t      tem = force_fit_type_double (type, TREE_INT_CST_LOW (and1),\n \t\t\t\t\t   TREE_INT_CST_HIGH (and1), 0,\n-\t\t\t\t\t   TREE_OVERFLOW (and1),\n-\t\t\t\t\t   false);\n+\t\t\t\t\t   TREE_OVERFLOW (and1));\n \t      return fold_build2 (BIT_AND_EXPR, type,\n \t\t\t\t  fold_convert (type, and0), tem);\n \t    }\n@@ -13045,8 +13040,7 @@ fold_negate_const (tree arg0, tree type)\n \t\t\t\t   &low, &high);\n \tt = force_fit_type_double (type, low, high, 1,\n \t\t\t\t   (overflow | TREE_OVERFLOW (arg0))\n-\t\t\t\t   && !TYPE_UNSIGNED (type),\n-\t\t\t\t   false);\n+\t\t\t\t   && !TYPE_UNSIGNED (type));\n \tbreak;\n       }\n \n@@ -13091,8 +13085,7 @@ fold_abs_const (tree arg0, tree type)\n \t\t\t\t     TREE_INT_CST_HIGH (arg0),\n \t\t\t\t     &low, &high);\n \t  t = force_fit_type_double (type, low, high, -1,\n-\t\t\t\t     overflow | TREE_OVERFLOW (arg0),\n-\t\t\t\t     false);\n+\t\t\t\t     overflow | TREE_OVERFLOW (arg0));\n \t}\n       break;\n \n@@ -13122,8 +13115,7 @@ fold_not_const (tree arg0, tree type)\n \n   t = force_fit_type_double (type, ~TREE_INT_CST_LOW (arg0),\n \t\t\t     ~TREE_INT_CST_HIGH (arg0), 0,\n-\t\t\t     TREE_OVERFLOW (arg0),\n-\t\t\t     false);\n+\t\t\t     TREE_OVERFLOW (arg0));\n \n   return t;\n }"}, {"sha": "cbb47cc8489039a0770a718f54c48e423ecb773b", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95787e646b7b5f027d7f241707aa0f297949792/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95787e646b7b5f027d7f241707aa0f297949792/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d95787e646b7b5f027d7f241707aa0f297949792", "patch": "@@ -1,6 +1,6 @@\n /* Front-end tree definitions for GNU compiler.\n    Copyright (C) 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   2001, 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -4315,7 +4315,7 @@ extern tree fold_abs_const (tree, tree);\n extern tree fold_indirect_ref_1 (tree, tree);\n \n extern tree force_fit_type_double (tree, unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t   int, bool, bool);\n+\t\t\t\t   int, bool);\n \n extern int fit_double_type (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t    unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, tree);"}]}