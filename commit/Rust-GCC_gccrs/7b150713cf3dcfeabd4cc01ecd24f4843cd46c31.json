{"sha": "7b150713cf3dcfeabd4cc01ecd24f4843cd46c31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2IxNTA3MTNjZjNkY2ZlYWJkNGNjMDFlY2QyNGY0ODQzY2Q0NmMzMQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2005-02-01T06:33:35Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2005-02-01T06:33:35Z"}, "message": "frv.c (movcc_fp_destination_operand): New.\n\n* config/frv/frv.c (movcc_fp_destination_operand): New.\n(gpr_or_memory_operand): Fix typo in comment.\n(gpr_or_memory_operand_with_scratch): New.\n* config/frv/frv.h (PREDICATE_CODES): Add the two new predicates.\n* config/frv/frv.md (movcc_fp, movcc_fp_internal): Use\nmovcc_fp_destination_operand.\n(reload_incc_fp): Use gpr_or_memory_operand_with_scratch.\nLegitimize memory addresses using a scratch register.\n\nFrom-SVN: r94523", "tree": {"sha": "17fb9906b4b1c13fb22721a25ba78ef3468d22ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17fb9906b4b1c13fb22721a25ba78ef3468d22ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b150713cf3dcfeabd4cc01ecd24f4843cd46c31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b150713cf3dcfeabd4cc01ecd24f4843cd46c31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b150713cf3dcfeabd4cc01ecd24f4843cd46c31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b150713cf3dcfeabd4cc01ecd24f4843cd46c31/comments", "author": null, "committer": null, "parents": [{"sha": "e894ab29c7bb872bc9ff2bc79f1b7c05033563cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e894ab29c7bb872bc9ff2bc79f1b7c05033563cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e894ab29c7bb872bc9ff2bc79f1b7c05033563cb"}], "stats": {"total": 88, "additions": 84, "deletions": 4}, "files": [{"sha": "ce0422c9323b80993079f13987d9c10d0523f75e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b150713cf3dcfeabd4cc01ecd24f4843cd46c31/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b150713cf3dcfeabd4cc01ecd24f4843cd46c31/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b150713cf3dcfeabd4cc01ecd24f4843cd46c31", "patch": "@@ -1,3 +1,14 @@\n+2005-02-01  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* config/frv/frv.c (movcc_fp_destination_operand): New.\n+\t(gpr_or_memory_operand): Fix typo in comment.\n+\t(gpr_or_memory_operand_with_scratch): New.\n+\t* config/frv/frv.h (PREDICATE_CODES): Add the two new predicates.\n+\t* config/frv/frv.md (movcc_fp, movcc_fp_internal): Use\n+\tmovcc_fp_destination_operand.\n+\t(reload_incc_fp): Use gpr_or_memory_operand_with_scratch.\n+\tLegitimize memory addresses using a scratch register.\n+\n 2005-01-31  Jeff Law  <law@redhat.com>\n \n \t* tree-into-ssa.c (mark_def_sites_global_data): Make KILLS"}, {"sha": "833ccee686a62d67aa4260fffa9cca87c3dcdadc", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b150713cf3dcfeabd4cc01ecd24f4843cd46c31/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b150713cf3dcfeabd4cc01ecd24f4843cd46c31/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=7b150713cf3dcfeabd4cc01ecd24f4843cd46c31", "patch": "@@ -4569,6 +4569,19 @@ move_destination_operand (rtx op, enum machine_mode mode)\n   return FALSE;\n }\n \n+/* Return true if we the operand is a valid destination for a movcc_fp\n+   instruction.  This means rejecting fcc_operands, since we need\n+   scratch registers to write to them.  */\n+\n+int\n+movcc_fp_destination_operand (rtx op, enum machine_mode mode)\n+{\n+  if (fcc_operand (op, mode))\n+    return FALSE;\n+\n+  return move_destination_operand (op, mode);\n+}\n+\n /* Look for a SYMBOL_REF of a function in an rtx.  We always want to\n    process these separately from any offsets, such that we add any\n    offsets to the function descriptor (the actual pointer), not to the\n@@ -4832,7 +4845,8 @@ const_unspec_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n \n   return frv_const_unspec_p (op, &unspec);\n }\n-/* Return true if operand is a gpr register or a valid memory operation.  */\n+\n+/* Return true if operand is a gpr register or a valid memory operand.  */\n \n int\n gpr_or_memory_operand (rtx op, enum machine_mode mode)\n@@ -4841,6 +4855,38 @@ gpr_or_memory_operand (rtx op, enum machine_mode mode)\n \t  || frv_legitimate_memory_operand (op, mode, FALSE));\n }\n \n+/* Return true if operand is a gpr register, a valid memory operand,\n+   or a memory operand that can be made valid using an additional gpr\n+   register.  */\n+\n+int\n+gpr_or_memory_operand_with_scratch (rtx op, enum machine_mode mode)\n+{\n+  rtx addr;\n+\n+  if (gpr_or_memory_operand (op, mode))\n+    return TRUE;\n+\n+  if (GET_CODE (op) != MEM)\n+    return FALSE;\n+\n+  if (GET_MODE (op) != mode)\n+    return FALSE;\n+\n+  addr = XEXP (op, 0);\n+\n+  if (GET_CODE (addr) != PLUS)\n+    return FALSE;\n+      \n+  if (!integer_register_operand (XEXP (addr, 0), Pmode))\n+    return FALSE;\n+\n+  if (GET_CODE (XEXP (addr, 1)) != CONST_INT)\n+    return FALSE;\n+\n+  return TRUE;\n+}\n+\n /* Return true if operand is a fpr register or a valid memory operation.  */\n \n int"}, {"sha": "148ecae42e60c16d3a361ed3fa76ae3295958cea", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b150713cf3dcfeabd4cc01ecd24f4843cd46c31/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b150713cf3dcfeabd4cc01ecd24f4843cd46c31/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=7b150713cf3dcfeabd4cc01ecd24f4843cd46c31", "patch": "@@ -3023,12 +3023,14 @@ do {                                                                    \\\n \t\t\t\t\t  CONST_DOUBLE, CONST,\t\t\\\n \t\t\t\t\t  SYMBOL_REF, LABEL_REF }},\t\\\n   { \"move_destination_operand\",\t\t{ REG, SUBREG, MEM }},\t\t\\\n+  { \"movcc_fp_destination_operand\",\t{ REG, SUBREG, MEM }},\t\t\\\n   { \"condexec_source_operand\",\t\t{ REG, SUBREG, CONST_INT, MEM,\t\\\n \t\t\t\t\t  CONST_DOUBLE }},\t\t\\\n   { \"condexec_dest_operand\",\t\t{ REG, SUBREG, MEM }},\t\t\\\n   { \"reg_or_0_operand\",\t\t\t{ REG, SUBREG, CONST_INT }},\t\\\n   { \"lr_operand\",\t\t\t{ REG }},\t\t\t\\\n   { \"gpr_or_memory_operand\",\t\t{ REG, SUBREG, MEM }},\t\t\\\n+  { \"gpr_or_memory_operand_with_scratch\", { REG, SUBREG, MEM }},\t\\\n   { \"fpr_or_memory_operand\",\t\t{ REG, SUBREG, MEM }},\t\t\\\n   { \"int12_operand\",\t\t\t{ CONST_INT }},\t\t\t\\\n   { \"int_2word_operand\",\t\t{ CONST_INT, CONST_DOUBLE,\t\\"}, {"sha": "94520ef46a9432b9e5343eabb852e7333874a7e2", "filename": "gcc/config/frv/frv.md", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b150713cf3dcfeabd4cc01ecd24f4843cd46c31/gcc%2Fconfig%2Ffrv%2Ffrv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b150713cf3dcfeabd4cc01ecd24f4843cd46c31/gcc%2Fconfig%2Ffrv%2Ffrv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.md?ref=7b150713cf3dcfeabd4cc01ecd24f4843cd46c31", "patch": "@@ -2426,7 +2426,7 @@\n ;; to make it conditional on reload.\n \n (define_expand \"movcc_fp\"\n-  [(set (match_operand:CC_FP 0 \"move_destination_operand\" \"\")\n+  [(set (match_operand:CC_FP 0 \"movcc_fp_destination_operand\" \"\")\n \t(match_operand:CC_FP 1 \"move_source_operand\" \"\"))]\n   \"TARGET_HAS_FPRS\"\n   \"\n@@ -2436,7 +2436,7 @@\n }\")\n \n (define_insn \"*movcc_fp_internal\"\n-  [(set (match_operand:CC_FP 0 \"move_destination_operand\" \"=d,d,d,m\")\n+  [(set (match_operand:CC_FP 0 \"movcc_fp_destination_operand\" \"=d,d,d,m\")\n \t(match_operand:CC_FP 1 \"move_source_operand\" \"u,d,m,d\"))]\n   \"TARGET_HAS_FPRS && (reload_in_progress || reload_completed)\"\n   \"@\n@@ -2450,7 +2450,7 @@\n \n (define_expand \"reload_incc_fp\"\n   [(match_operand:CC_FP 0 \"fcc_operand\" \"=u\")\n-   (match_operand:CC_FP 1 \"memory_operand\" \"m\")\n+   (match_operand:CC_FP 1 \"gpr_or_memory_operand_with_scratch\" \"m\")\n    (match_operand:TI 2 \"integer_register_operand\" \"=&d\")]\n   \"TARGET_HAS_FPRS\"\n   \"\n@@ -2462,6 +2462,27 @@\n   int shift = CC_SHIFT_RIGHT (REGNO (operands[0]));\n   HOST_WIDE_INT mask;\n \n+  if (!gpr_or_memory_operand (operands[1], CC_FPmode))\n+    {\n+      rtx addr;\n+      rtx temp3 = simplify_gen_subreg (SImode, operands[2], TImode, 12);\n+\n+      if (GET_CODE (operands[1]) != MEM)\n+        abort ();\n+\n+      addr = XEXP (operands[1], 0);\n+\n+      if (GET_CODE (addr) != PLUS)\n+        abort ();\n+\n+      emit_move_insn (temp3, XEXP (addr, 1));\n+\n+      operands[1] = replace_equiv_address (operands[1],\n+\t\t\t\t\t   gen_rtx_PLUS (GET_MODE (addr),\n+\t\t\t\t\t\t\t XEXP (addr, 0),\n+\t\t\t\t\t\t\t temp3));\n+    }\n+\n   emit_insn (gen_movcc_fp (cc_op2, operands[1]));\n   if (shift)\n     emit_insn (gen_ashlsi3 (int_op2, int_op2, GEN_INT (shift)));"}]}