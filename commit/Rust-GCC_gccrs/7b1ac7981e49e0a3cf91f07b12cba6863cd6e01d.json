{"sha": "7b1ac7981e49e0a3cf91f07b12cba6863cd6e01d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2IxYWM3OTgxZTQ5ZTBhM2NmOTFmMDdiMTJjYmE2ODYzY2Q2ZTAxZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2000-01-03T08:53:13Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2000-01-03T08:53:13Z"}, "message": "sparc.c (gen_df_reg): New function.\n\n\t* config/sparc/sparc.c (gen_df_reg): New function.\n\t* config/sparc/sparc-protos.h (gen_df_reg): Add prototype.\n\t* config/sparc/sparc.md (movtf_no_e_insn_sp64+1,\n\tmovtf_no_e_insn_sp64+2, movtf_no_e_insn_sp64+3, movtf_cc_sp64+1,\n\tmovtf_cc_reg_sp64+1): Use it.\n\nFrom-SVN: r31177", "tree": {"sha": "d5794ba8a174476619e791a75af73622dce6e28e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5794ba8a174476619e791a75af73622dce6e28e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b1ac7981e49e0a3cf91f07b12cba6863cd6e01d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b1ac7981e49e0a3cf91f07b12cba6863cd6e01d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b1ac7981e49e0a3cf91f07b12cba6863cd6e01d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b1ac7981e49e0a3cf91f07b12cba6863cd6e01d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3fda1f48b59d02c63ffba289a00042549243f592", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fda1f48b59d02c63ffba289a00042549243f592", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fda1f48b59d02c63ffba289a00042549243f592"}], "stats": {"total": 89, "additions": 46, "deletions": 43}, "files": [{"sha": "0b55ce0802eef8029cab7c1e01790e3e1d516190", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1ac7981e49e0a3cf91f07b12cba6863cd6e01d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1ac7981e49e0a3cf91f07b12cba6863cd6e01d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b1ac7981e49e0a3cf91f07b12cba6863cd6e01d", "patch": "@@ -1,3 +1,11 @@\n+2000-01-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* config/sparc/sparc.c (gen_df_reg): New function.\n+\t* config/sparc/sparc-protos.h (gen_df_reg): Add prototype.\n+\t* config/sparc/sparc.md (movtf_no_e_insn_sp64+1,\n+\tmovtf_no_e_insn_sp64+2, movtf_no_e_insn_sp64+3, movtf_cc_sp64+1,\n+\tmovtf_cc_reg_sp64+1): Use it.\n+\n 2000-01-02  Mark Mitchell  <mark@codesourcery.com>\n \n \t* integrate.c (copy_decl_for_inlining): Clear TREE_ADDRESSABLE on"}, {"sha": "1e78a73fb5f46e19c70854d8e3796068c3bb0cf5", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1ac7981e49e0a3cf91f07b12cba6863cd6e01d/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1ac7981e49e0a3cf91f07b12cba6863cd6e01d/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=7b1ac7981e49e0a3cf91f07b12cba6863cd6e01d", "patch": "@@ -162,6 +162,7 @@ extern int eq_or_neq PARAMS ((rtx, enum machine_mode));\n extern int normal_comp_operator PARAMS ((rtx, enum machine_mode));\n extern int uns_arith_operand PARAMS ((rtx, enum machine_mode));\n extern int clobbered_register PARAMS ((rtx, enum machine_mode));\n+extern rtx gen_df_reg PARAMS ((rtx, int));\n #endif /* RTX_CODE */\n \n #endif /* __SPARC_PROTOS_H__ */"}, {"sha": "cc24f28736496648a645939421f53c780e315d74", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1ac7981e49e0a3cf91f07b12cba6863cd6e01d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1ac7981e49e0a3cf91f07b12cba6863cd6e01d/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=7b1ac7981e49e0a3cf91f07b12cba6863cd6e01d", "patch": "@@ -2264,6 +2264,22 @@ emit_v9_brxx_insn (code, op0, label)\n \t\t\t\t    gen_rtx_LABEL_REF (VOIDmode, label),\n \t\t\t\t    pc_rtx)));\n }\n+\n+/* Generate a DFmode part of a hard TFmode register.\n+   REG is the TFmode hard register, LOW is 1 for the\n+   low 64bit of the register and 0 otherwise.\n+ */\n+rtx\n+gen_df_reg (reg, low)\n+     rtx reg;\n+     int low;\n+{\n+  int regno = REGNO (reg);\n+\n+  if ((WORDS_BIG_ENDIAN == 0) ^ (low != 0))\n+    regno += (regno < 32) ? 1 : 2;\n+  return gen_rtx_REG (DFmode, regno);\n+}\n \f\n /* Return nonzero if a return peephole merging return with\n    setting of output register is ok.  */"}, {"sha": "4c6a5417f314477195ecc51ddd04598a3b02e961", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 21, "deletions": 43, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1ac7981e49e0a3cf91f07b12cba6863cd6e01d/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1ac7981e49e0a3cf91f07b12cba6863cd6e01d/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=7b1ac7981e49e0a3cf91f07b12cba6863cd6e01d", "patch": "@@ -3643,14 +3643,10 @@\n   if (GET_CODE (set_src) == SUBREG)\n     set_src = alter_subreg (set_src);\n \n-  dest1 = gen_rtx_REG (DFmode,\n-                       REGNO (set_dest) + (WORDS_BIG_ENDIAN ? 0 : 2));\n-  dest2 = gen_rtx_REG (DFmode,\n-                       REGNO (set_dest) + (WORDS_BIG_ENDIAN ? 2 : 0));\n-  src1 = gen_rtx_REG (DFmode,\n-                      REGNO (set_src) + (WORDS_BIG_ENDIAN ? 0 : 2));\n-  src2 = gen_rtx_REG (DFmode,\n-                      REGNO (set_src) + (WORDS_BIG_ENDIAN ? 2 : 0));\n+  dest1 = gen_df_reg (set_dest, 0);\n+  dest2 = gen_df_reg (set_dest, 1);\n+  src1 = gen_df_reg (set_src, 0);\n+  src2 = gen_df_reg (set_src, 1);\n \n   /* Now emit using the real source and destination we found, swapping\n      the order if we detect overlap.  */\n@@ -3684,10 +3680,8 @@\n   if (GET_CODE (set_dest) == SUBREG)\n     set_dest = alter_subreg (set_dest);\n \n-  dest1 = gen_rtx_REG (DFmode,\n-                       REGNO (set_dest) + (WORDS_BIG_ENDIAN ? 0 : 2));\n-  dest2 = gen_rtx_REG (DFmode,\n-                       REGNO (set_dest) + (WORDS_BIG_ENDIAN ? 2 : 0));\n+  dest1 = gen_df_reg (set_dest, 0);\n+  dest2 = gen_df_reg (set_dest, 1);\n \n   /* Now output, ordering such that we don't clobber any registers\n      mentioned in the address.  */\n@@ -3716,18 +3710,14 @@\n   rtx word1 = change_address (operands[0], DFmode, NULL_RTX);\n   rtx word2 = change_address (operands[0], DFmode,\n \t\t\t      plus_constant_for_output (XEXP (word1, 0), 8));\n-  rtx set_src, src1, src2;\n+  rtx set_src;\n \n   set_src = operands[1];\n   if (GET_CODE (set_src) == SUBREG)\n     set_src = alter_subreg (set_src);\n \n-  src1 = gen_rtx_REG (DFmode,\n-                      REGNO (set_src) + (WORDS_BIG_ENDIAN ? 0 : 2));\n-  src2 = gen_rtx_REG (DFmode,\n-                      REGNO (set_src) + (WORDS_BIG_ENDIAN ? 2 : 0));\n-  emit_insn (gen_movdf (word1, src1));\n-  emit_insn (gen_movdf (word2, src2));\n+  emit_insn (gen_movdf (word1, gen_df_reg (set_src, 0)));\n+  emit_insn (gen_movdf (word2, gen_df_reg (set_src, 1)));\n   DONE;\n }\")\n \f\n@@ -4095,18 +4085,12 @@\n   if (GET_CODE (set_srcb) == SUBREG)\n     set_srcb = alter_subreg (set_srcb);\n \n-  dest1 = gen_rtx_REG (DFmode,\n-                       REGNO (set_dest) + (WORDS_BIG_ENDIAN ? 0 : 2));\n-  dest2 = gen_rtx_REG (DFmode,\n-                       REGNO (set_dest) + (WORDS_BIG_ENDIAN ? 2 : 0));\n-  srca1 = gen_rtx_REG (DFmode,\n-                       REGNO (set_srca) + (WORDS_BIG_ENDIAN ? 0 : 2));\n-  srca2 = gen_rtx_REG (DFmode,\n-                       REGNO (set_srca) + (WORDS_BIG_ENDIAN ? 2 : 0));\n-  srcb1 = gen_rtx_REG (DFmode,\n-                       REGNO (set_srcb) + (WORDS_BIG_ENDIAN ? 0 : 2));\n-  srcb2 = gen_rtx_REG (DFmode,\n-                       REGNO (set_srcb) + (WORDS_BIG_ENDIAN ? 2 : 0));\n+  dest1 = gen_df_reg (set_dest, 0);\n+  dest2 = gen_df_reg (set_dest, 1);\n+  srca1 = gen_df_reg (set_srca, 0);\n+  srca2 = gen_df_reg (set_srca, 1);\n+  srcb1 = gen_df_reg (set_srcb, 0);\n+  srcb2 = gen_df_reg (set_srcb, 1);\n \n   /* Now emit using the real source and destination we found, swapping\n      the order if we detect overlap.  */\n@@ -4274,18 +4258,12 @@\n   if (GET_CODE (set_srcb) == SUBREG)\n     set_srcb = alter_subreg (set_srcb);\n \n-  dest1 = gen_rtx_REG (DFmode,\n-                       REGNO (set_dest) + (WORDS_BIG_ENDIAN ? 0 : 2));\n-  dest2 = gen_rtx_REG (DFmode,\n-                       REGNO (set_dest) + (WORDS_BIG_ENDIAN ? 2 : 0));\n-  srca1 = gen_rtx_REG (DFmode,\n-                       REGNO (set_srca) + (WORDS_BIG_ENDIAN ? 0 : 2));\n-  srca2 = gen_rtx_REG (DFmode,\n-                       REGNO (set_srca) + (WORDS_BIG_ENDIAN ? 2 : 0));\n-  srcb1 = gen_rtx_REG (DFmode,\n-                       REGNO (set_srcb) + (WORDS_BIG_ENDIAN ? 0 : 2));\n-  srcb2 = gen_rtx_REG (DFmode,\n-                       REGNO (set_srcb) + (WORDS_BIG_ENDIAN ? 2 : 0));\n+  dest1 = gen_df_reg (set_dest, 0);\n+  dest2 = gen_df_reg (set_dest, 1);\n+  srca1 = gen_df_reg (set_srca, 0);\n+  srca2 = gen_df_reg (set_srca, 1);\n+  srcb1 = gen_df_reg (set_srcb, 0);\n+  srcb2 = gen_df_reg (set_srcb, 1);\n \n   /* Now emit using the real source and destination we found, swapping\n      the order if we detect overlap.  */"}]}