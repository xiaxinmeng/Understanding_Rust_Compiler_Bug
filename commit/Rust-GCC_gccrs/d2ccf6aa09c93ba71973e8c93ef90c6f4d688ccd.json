{"sha": "d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJjY2Y2YWEwOWM5M2JhNzE5NzNlOGM5M2VmOTBjNmY0ZDY4OGNjZA==", "commit": {"author": {"name": "Victor Leikehman", "email": "lei@il.ibm.com", "date": "2004-09-16T13:29:56Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-09-16T13:29:56Z"}, "message": "trans-io.c (transfer_array_component): New function.\n\n2004-09-16  Victor Leikehman  <lei@il.ibm.com>\n\n\tPR/15364\n\t* trans-io.c (transfer_array_component): New function.\n\t(transfer_expr): For array fields, call transfer_array_component.\ntestsuite/\n\t* gfortran.dg/der_array_io_1.f90: New test.\n\t* gfortran.dg/der_array_io_2.f90: New test.\n\t* gfortran.dg/der_array_io_3.f90: New test.\n\nFrom-SVN: r87596", "tree": {"sha": "6ff5388b721d22d994d75b37cf701f76cfea4d5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ff5388b721d22d994d75b37cf701f76cfea4d5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd/comments", "author": null, "committer": null, "parents": [{"sha": "de787a96875989204a8776400dd7b96269bc7823", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de787a96875989204a8776400dd7b96269bc7823", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de787a96875989204a8776400dd7b96269bc7823"}], "stats": {"total": 203, "additions": 190, "deletions": 13}, "files": [{"sha": "abdaa1d4166d28c2b37f25615a6b17e958ef06ff", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd", "patch": "@@ -1,3 +1,9 @@\n+2004-09-16  Victor Leikehman  <lei@il.ibm.com>\n+\n+\tPR/15364\n+\t* trans-io.c (transfer_array_component): New function.\n+\t(transfer_expr): For array fields, call transfer_array_component.\n+\n 2004-09-16  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* gfortran.texi: Fix a typo."}, {"sha": "c67422876de956bcb6929b7b875e259c0358145a", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 111, "deletions": 13, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd", "patch": "@@ -1140,6 +1140,96 @@ gfc_trans_dt_end (gfc_code * code)\n   return gfc_finish_block (&block);\n }\n \n+static void\n+transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr);\n+\n+/* Given an array field in a derived type variable, generate the code\n+   for the loop that iterates over array elements, and the code that\n+   accesses those array elements.  Use transfer_expr to generate code\n+   for transferring that element.  Because elements may also be\n+   derived types, transfer_expr and transfer_array_component are mutually\n+   recursive.  */\n+\n+static tree\n+transfer_array_component (tree expr, gfc_component * cm)\n+{\n+  tree tmp;\n+  stmtblock_t body;\n+  stmtblock_t block;\n+  gfc_loopinfo loop;\n+  int n;\n+  gfc_ss *ss;\n+  gfc_se se;\n+\n+  gfc_start_block (&block);\n+  gfc_init_se (&se, NULL);\n+\n+  /* Create and initialize Scalarization Status.  Unlike in\n+     gfc_trans_transfer, we can't simply use gfc_walk_expr to take\n+     care of this task, because we don't have a gfc_expr at hand.\n+     Build one manually, as in gfc_trans_subarray_assign.  */\n+\n+  ss = gfc_get_ss ();\n+  ss->type = GFC_SS_COMPONENT;\n+  ss->expr = NULL;\n+  ss->shape = gfc_get_shape (cm->as->rank);\n+  ss->next = gfc_ss_terminator;\n+  ss->data.info.dimen = cm->as->rank;\n+  ss->data.info.descriptor = expr;\n+  ss->data.info.data = gfc_conv_array_data (expr);\n+  ss->data.info.offset = gfc_conv_array_offset (expr);\n+  for (n = 0; n < cm->as->rank; n++)\n+    {\n+      ss->data.info.dim[n] = n;\n+      ss->data.info.start[n] = gfc_conv_array_lbound (expr, n);\n+      ss->data.info.stride[n] = gfc_index_one_node;\n+\n+      mpz_init (ss->shape[n]);\n+      mpz_sub (ss->shape[n], cm->as->upper[n]->value.integer,\n+               cm->as->lower[n]->value.integer);\n+      mpz_add_ui (ss->shape[n], ss->shape[n], 1);\n+    }\n+\n+  /* Once we got ss, we use scalarizer to create the loop. */\n+\n+  gfc_init_loopinfo (&loop);\n+  gfc_add_ss_to_loop (&loop, ss);\n+  gfc_conv_ss_startstride (&loop);\n+  gfc_conv_loop_setup (&loop);\n+  gfc_mark_ss_chain_used (ss, 1);\n+  gfc_start_scalarized_body (&loop, &body);\n+\n+  gfc_copy_loopinfo_to_se (&se, &loop);\n+  se.ss = ss;\n+\n+  /* gfc_conv_tmp_array_ref assumes that se.expr contains the array.  */\n+  se.expr = expr;\n+  gfc_conv_tmp_array_ref (&se);\n+\n+  /* Now se.expr contains an element of the array.  Take the address and pass\n+     it to the IO routines.  */\n+  tmp = gfc_build_addr_expr (NULL, se.expr);\n+  transfer_expr (&se, &cm->ts, tmp);\n+\n+  /* We are done now with the loop body.  Wrap up the scalarizer and\n+     return. */\n+\n+  gfc_add_block_to_block (&body, &se.pre);\n+  gfc_add_block_to_block (&body, &se.post);\n+\n+  gfc_trans_scalarizing_loops (&loop, &body);\n+\n+  gfc_add_block_to_block (&block, &loop.pre);\n+  gfc_add_block_to_block (&block, &loop.post);\n+\n+  gfc_cleanup_loop (&loop);\n+\n+  for (n = 0; n < cm->as->rank; n++)\n+    mpz_clear (ss->shape[n]);\n+  gfc_free (ss->shape);\n+\n+  return gfc_finish_block (&block);\n+}\n \n /* Generate the call for a scalar transfer node.  */\n \n@@ -1177,11 +1267,19 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr)\n       break;\n \n     case BT_CHARACTER:\n-      arg2 = se->string_length;\n+      if (se->string_length)\n+\targ2 = se->string_length;\n+      else\n+\t{\n+\t  tmp = gfc_build_indirect_ref (addr_expr);\n+\t  gcc_assert (TREE_CODE (TREE_TYPE (tmp)) == ARRAY_TYPE);\n+\t  arg2 = TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (tmp)));\n+\t}\n       function = iocall_x_character;\n       break;\n \n     case BT_DERIVED:\n+      /* Recurse into the elements of the derived type.  */\n       expr = gfc_evaluate_now (addr_expr, &se->pre);\n       expr = gfc_build_indirect_ref (expr);\n \n@@ -1193,17 +1291,17 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr)\n \t  tmp = build3 (COMPONENT_REF, TREE_TYPE (field), expr, field,\n \t\t\tNULL_TREE);\n \n-\t  if (c->ts.type == BT_CHARACTER)\n-\t    {\n-\t      gcc_assert (TREE_CODE (TREE_TYPE (tmp)) == ARRAY_TYPE);\n-\t      se->string_length =\n-\t\tTYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (tmp)));\n-\t    }\n-\t  if (c->dimension)\n-\t    gfc_todo_error (\"IO of arrays in derived types\");\n-\t  if (!c->pointer)\n-\t    tmp = gfc_build_addr_expr (NULL, tmp);\n-\t  transfer_expr (se, &c->ts, tmp);\n+          if (c->dimension)\n+            {\n+              tmp = transfer_array_component (tmp, c);\n+              gfc_add_expr_to_block (&se->pre, tmp);\n+            }\n+          else\n+            {\n+              if (!c->pointer)\n+                tmp = gfc_build_addr_expr (NULL, tmp);\n+              transfer_expr (se, &c->ts, tmp);\n+            }\n \t}\n       return;\n \n@@ -1281,7 +1379,7 @@ gfc_trans_transfer (gfc_code * code)\n \n   gfc_add_expr_to_block (&block, tmp);\n \n-  return gfc_finish_block (&block);;\n+  return gfc_finish_block (&block);\n }\n \n #include \"gt-fortran-trans-io.h\""}, {"sha": "e36b90e48783d196d04ca098411bb43146951ce6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd", "patch": "@@ -1,3 +1,10 @@\n+2004-09-16  Victor Leikehman  <lei@il.ibm.com>\n+\n+\tPR/15364\n+\t* gfortran.dg/der_array_io_1.f90: New test.\n+\t* gfortran.dg/der_array_io_2.f90: New test.\n+\t* gfortran.dg/der_array_io_3.f90: New test.\n+\n 2004-09-15  Mark Mitchell  <mark@codesourcery.com>\n \n \t* testsuite/g++.old-deja/g++.abi/cxa_vec.C: Adjust for ARM"}, {"sha": "5bfd0c64547c91d5d36b3a297b7c7d555439fdd2", "filename": "gcc/testsuite/gfortran.dg/der_array_io_1.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd/gcc%2Ftestsuite%2Fgfortran.dg%2Fder_array_io_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd/gcc%2Ftestsuite%2Fgfortran.dg%2Fder_array_io_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fder_array_io_1.f90?ref=d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd", "patch": "@@ -0,0 +1,24 @@\n+! Test IO of arrays of integers in derived types\n+! { dg-do run }\n+program main\n+\n+  character* 10000 :: buf1, buf2\n+  type xyz\n+     integer :: x, y(3), z\n+  end type xyz\n+\n+  type (xyz) :: foo(4)\n+\n+  do i=1,ubound(foo,1)\n+     foo(i)%x = 100*i\n+     do j=1,3\n+        foo(i)%y(j) = 100*i + 10*j \n+     enddo\n+     foo(i)%z = 100*i+40\n+  enddo\n+\n+  print (buf1, '(20i4)'), foo\n+  print (buf2, '(20i4)'), (foo(i)%x, (foo(i)%y(j), j=1,3), foo(i)%z, i=1,4)\n+\n+  if (buf1.ne.buf2) call abort\n+end program main"}, {"sha": "5d4a7ce01e3c43ba54838b57e992a7a92eb5de0f", "filename": "gcc/testsuite/gfortran.dg/der_array_io_2.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd/gcc%2Ftestsuite%2Fgfortran.dg%2Fder_array_io_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd/gcc%2Ftestsuite%2Fgfortran.dg%2Fder_array_io_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fder_array_io_2.f90?ref=d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd", "patch": "@@ -0,0 +1,29 @@\n+! Test IO of arrays in derived type arrays\n+! { dg-do run }\n+program main\n+\n+  character *1000 buf1, buf2\n+\n+  type :: foo_type                                             \n+     integer x(3)\n+     integer y(4)\n+     integer z(5)\n+     character*11 a(3)\n+  end type foo_type\n+                                                                        \n+  type (foo_type) :: foo(2)\n+  \n+  foo(1)%x = 3\n+  foo(1)%y = 4\n+  foo(1)%z = 5\n+  foo(1)%a = \"hello world\"\n+\n+  foo(2)%x = 30\n+  foo(2)%y = 40\n+  foo(2)%z = 50\n+  foo(2)%a = \"HELLO WORLD\"\n+\n+  print (buf1,*), foo\n+  print (buf2,*), ((foo(i)%x(j),j=1,3), (foo(i)%y(j),j=1,4), (foo(i)%z(j),j=1,5), (foo(i)%a(j),j=1,3), i=1,2)\n+  if (buf1.ne.buf2) call abort\n+end program main"}, {"sha": "7898a1e8c5c879c040632712c3ebfc66366d8a1c", "filename": "gcc/testsuite/gfortran.dg/der_array_io_3.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd/gcc%2Ftestsuite%2Fgfortran.dg%2Fder_array_io_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd/gcc%2Ftestsuite%2Fgfortran.dg%2Fder_array_io_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fder_array_io_3.f90?ref=d2ccf6aa09c93ba71973e8c93ef90c6f4d688ccd", "patch": "@@ -0,0 +1,13 @@\n+! Test IO of character arrays in derived types.\n+! { dg-do run }\n+program main\n+ character*1000 buf1, buf2\n+ type :: foo_type\n+     character(12), dimension(13) :: name = \"hello world \"\n+  end type foo_type\n+  type (foo_type) :: foo\n+!  foo = foo_type(\"hello world \")\n+  print (buf1,*), foo\n+  print (buf2,*), (foo%name(i), i=1,13)\n+  if (buf1.ne.buf2) call abort\n+end program main"}]}