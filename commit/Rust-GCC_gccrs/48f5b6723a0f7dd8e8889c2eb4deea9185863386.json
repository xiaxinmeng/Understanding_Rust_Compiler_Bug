{"sha": "48f5b6723a0f7dd8e8889c2eb4deea9185863386", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhmNWI2NzIzYTBmN2RkOGU4ODg5YzJlYjRkZWVhOTE4NTg2MzM4Ng==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2002-11-18T13:56:59Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2002-11-18T13:56:59Z"}, "message": "ByteBufferImpl.java, [...]: New files.\n\n2002-11-18  Michael Koch <konqueror@gmx.de>\n\n\t* gnu/java/nio/ByteBufferImpl.java,\n\tgnu/java/nio/CharBufferImpl.java,\n\tgnu/java/nio/DatagramChannelImpl.java,\n\tgnu/java/nio/DoubleBufferImpl.java,\n\tgnu/java/nio/FileChannelImpl.java,\n\tgnu/java/nio/FloatBufferImpl.java,\n\tgnu/java/nio/IntBufferImpl.java,\n\tgnu/java/nio/LongBufferImpl.java,\n\tgnu/java/nio/PipeImpl.java,\n\tgnu/java/nio/SelectionKeyImpl.java,\n\tgnu/java/nio/SelectorImpl.java,\n\tgnu/java/nio/SelectorProviderImpl.java,\n\tgnu/java/nio/ServerSocketChannelImpl.java,\n\tgnu/java/nio/ShortBufferImpl.java,\n\tgnu/java/nio/SocketChannelImpl.java,\n\tjava/nio/DoubleBuffer.java,\n\tjava/nio/FloatBuffer.java,\n\tjava/nio/IntBuffer.java,\n\tjava/nio/LongBuffer.java,\n\tjava/nio/ShortBuffer.java,\n\tjava/nio/channels/FileChannel.java: New files.\n\nFrom-SVN: r59216", "tree": {"sha": "dc11eac332267abf0e840035b2c7a0117e161f8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc11eac332267abf0e840035b2c7a0117e161f8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48f5b6723a0f7dd8e8889c2eb4deea9185863386", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48f5b6723a0f7dd8e8889c2eb4deea9185863386", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48f5b6723a0f7dd8e8889c2eb4deea9185863386", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48f5b6723a0f7dd8e8889c2eb4deea9185863386/comments", "author": null, "committer": null, "parents": [{"sha": "d812d8211c5bbed77cc3f1ea842b9e74ade15f81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d812d8211c5bbed77cc3f1ea842b9e74ade15f81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d812d8211c5bbed77cc3f1ea842b9e74ade15f81"}], "stats": {"total": 3899, "additions": 3899, "deletions": 0}, "files": [{"sha": "85215d574658dda7271c4afe6668161f0ebc061e", "filename": "libjava/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=48f5b6723a0f7dd8e8889c2eb4deea9185863386", "patch": "@@ -1,3 +1,27 @@\n+2002-11-18  Michael Koch <konqueror@gmx.de>\n+\n+\t* gnu/java/nio/ByteBufferImpl.java,\n+\tgnu/java/nio/CharBufferImpl.java,\n+\tgnu/java/nio/DatagramChannelImpl.java,\n+\tgnu/java/nio/DoubleBufferImpl.java,\n+\tgnu/java/nio/FileChannelImpl.java,\n+\tgnu/java/nio/FloatBufferImpl.java,\n+\tgnu/java/nio/IntBufferImpl.java,\n+\tgnu/java/nio/LongBufferImpl.java,\n+\tgnu/java/nio/PipeImpl.java,\n+\tgnu/java/nio/SelectionKeyImpl.java,\n+\tgnu/java/nio/SelectorImpl.java,\n+\tgnu/java/nio/SelectorProviderImpl.java,\n+\tgnu/java/nio/ServerSocketChannelImpl.java,\n+\tgnu/java/nio/ShortBufferImpl.java,\n+\tgnu/java/nio/SocketChannelImpl.java,\n+\tjava/nio/DoubleBuffer.java,\n+\tjava/nio/FloatBuffer.java,\n+\tjava/nio/IntBuffer.java,\n+\tjava/nio/LongBuffer.java,\n+\tjava/nio/ShortBuffer.java,\n+\tjava/nio/channels/FileChannel.java: New files.\n+\n 2002-11-18  Michael Koch <konqueror@gmx.de>\n \n \t* Makefile.am (ordinary_java_source_files):"}, {"sha": "e27207ef55c7bfbbdfcc313ddb4fe3739a83d01a", "filename": "libjava/gnu/java/nio/ByteBufferImpl.java", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FByteBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FByteBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FByteBufferImpl.java?ref=48f5b6723a0f7dd8e8889c2eb4deea9185863386", "patch": "@@ -0,0 +1,214 @@\n+/* ByteBufferImpl.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.DoubleBuffer;\n+import java.nio.FloatBuffer;\n+import java.nio.IntBuffer;\n+import java.nio.LongBuffer;\n+import java.nio.ShortBuffer;\n+\n+public final class ByteBufferImpl extends ByteBuffer\n+{\n+  private byte[] backing_buffer;\n+  private int array_offset;\n+  private boolean ro;\n+\n+  public ByteBufferImpl (int cap, int off, int lim)\n+  {\n+    this.cap = cap;\n+    position (off);\n+    limit (lim);\n+    this.backing_buffer = new byte[cap];\n+  }\n+\n+  public ByteBufferImpl (byte[] array, int off, int lim)\n+  {\n+    this.cap = array.length;\n+    position (off);\n+    limit (lim);\n+    this.backing_buffer = array;\n+  }\n+\n+  public ByteBufferImpl (ByteBufferImpl copy)\n+  {\n+    this.cap = copy.capacity ();\n+    position (copy.position ());\n+    limit (copy.limit ());\n+    ro = copy.ro;\n+    backing_buffer = copy.backing_buffer;\n+  }\n+\n+  void inc_pos (int toAdd)\n+  {\n+    position (position () + toAdd);\n+  }\n+\n+//   private static native byte[] nio_cast(byte[]copy);\n+//   private static native byte[] nio_cast(char[]copy);\n+//   private static native byte[] nio_cast(short[]copy);\n+//   private static native byte[] nio_cast(long[]copy);\n+//   private static native byte[] nio_cast(int[]copy);\n+//   private static native byte[] nio_cast(float[]copy);\n+//   private static native byte[] nio_cast(double[]copy);\n+\n+  private static byte[] nio_cast(byte[]copy) { return null; };\n+  private static byte[] nio_cast(char[]copy) { return null; };\n+  private static byte[] nio_cast(short[]copy) { return null; };\n+  private static byte[] nio_cast(long[]copy) { return null; };\n+  private static byte[] nio_cast(int[]copy) { return null; };\n+  private static byte[] nio_cast(float[]copy) { return null; };\n+  private static byte[] nio_cast(double[]copy) { return null; };\n+\n+  ByteBufferImpl(byte[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native byte nio_get_Byte(ByteBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Byte(ByteBufferImpl b, int index, int limit, byte value);\n+  private static byte nio_get_Byte(ByteBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Byte(ByteBufferImpl b, int index, int limit, byte value) { };\n+  public ByteBuffer asByteBuffer() { ByteBufferImpl res = new ByteBufferImpl(backing_buffer); res.limit((limit()*1)/1); return res; }\n+\n+  ByteBufferImpl(char[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native char nio_get_Char(ByteBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Char(ByteBufferImpl b, int index, int limit, char value);\n+  private static char nio_get_Char(ByteBufferImpl b, int index, int limit) { return ' '; };\n+  private static void nio_put_Char(ByteBufferImpl b, int index, int limit, char value) { };\n+  public CharBuffer asCharBuffer() { CharBufferImpl res = new CharBufferImpl(backing_buffer); res.limit((limit()*2)/1); return res; }\n+\n+  ByteBufferImpl(short[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native short nio_get_Short(ByteBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Short(ByteBufferImpl b, int index, int limit, short value);\n+  private static short nio_get_Short(ByteBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Short(ByteBufferImpl b, int index, int limit, short value) { };\n+  public ShortBuffer asShortBuffer() { ShortBufferImpl res = new ShortBufferImpl(backing_buffer); res.limit((limit()*2)/1); return res; }\n+\n+  ByteBufferImpl(int[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native int nio_get_Int(ByteBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Int(ByteBufferImpl b, int index, int limit, int value);\n+  private static int nio_get_Int(ByteBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Int(ByteBufferImpl b, int index, int limit, int value) { };\n+  public IntBuffer asIntBuffer() { IntBufferImpl res = new IntBufferImpl(backing_buffer); res.limit((limit()*4)/1); return res; }\n+\n+  ByteBufferImpl(long[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native long nio_get_Long(ByteBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Long(ByteBufferImpl b, int index, int limit, long value);\n+  private static long nio_get_Long(ByteBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Long(ByteBufferImpl b, int index, int limit, long value) { };\n+  public LongBuffer asLongBuffer() { LongBufferImpl res = new LongBufferImpl(backing_buffer); res.limit((limit()*8)/1); return res; }\n+\n+  ByteBufferImpl(float[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native float nio_get_Float(ByteBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Float(ByteBufferImpl b, int index, int limit, float value);\n+  private static float nio_get_Float(ByteBufferImpl b, int index, int limit) { return 0.0f; };\n+  private static void nio_put_Float(ByteBufferImpl b, int index, int limit, float value) { };\n+  public FloatBuffer asFloatBuffer() { FloatBufferImpl res = new FloatBufferImpl(backing_buffer); res.limit((limit()*4)/1); return res; }\n+\n+  ByteBufferImpl(double[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native double nio_get_Double(ByteBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Double(ByteBufferImpl b, int index, int limit, double value);\n+  private static double nio_get_Double(ByteBufferImpl b, int index, int limit) { return 0.0d; };\n+  private static void nio_put_Double(ByteBufferImpl b, int index, int limit, double value) { };\n+  public DoubleBuffer asDoubleBuffer() { DoubleBufferImpl res = new DoubleBufferImpl(backing_buffer); res.limit((limit()*8)/1); return res; }\n+  \n+  public boolean isReadOnly()\n+  {\n+    return ro;\n+  }\n+  \n+  public ByteBuffer slice()\n+  {\n+    ByteBufferImpl A = new ByteBufferImpl(this);\n+    A.array_offset = position();\n+    return A;\n+  }\n+  \n+  public ByteBuffer duplicate()\n+  {\n+    return new ByteBufferImpl(this);\n+  }\n+  \n+  public ByteBuffer asReadOnlyBuffer()\n+  {\n+    ByteBufferImpl a = new ByteBufferImpl(this);\n+    a.ro = true;\n+    return a;\n+  }\n+  \n+  public ByteBuffer compact()\n+  {\n+    return this;\n+  }\n+\n+  public boolean isDirect()\n+  {\n+    return backing_buffer != null;\n+  }\n+\n+  final public byte get()\n+  {\n+    byte e = backing_buffer[position()];\n+    position(position()+1);\n+    return e;\n+  }\n+  \n+  final public ByteBuffer put(byte b)\n+  {\n+    backing_buffer[position()] = b;\n+    position(position()+1);\n+    return this;\n+  }\n+  \n+  final public byte get(int index)\n+  {\n+    return backing_buffer[index];\n+  }\n+\n+  final public ByteBuffer put(int index, byte b)\n+  {\n+    backing_buffer[index] = b;\n+    return this;\n+  }\n+  \n+  final public char getChar() { char a = nio_get_Char(this, position(), limit()); inc_pos(2); return a; } final public ByteBuffer putChar(char value) { nio_put_Char(this, position(), limit(), value); inc_pos(2); return this; } final public char getChar(int index) { char a = nio_get_Char(this, index, limit()); return a; } final public ByteBuffer putChar(int index, char value) { nio_put_Char(this, index, limit(), value); return this; };\n+  final public short getShort() { short a = nio_get_Short(this, position(), limit()); inc_pos(2); return a; } final public ByteBuffer putShort(short value) { nio_put_Short(this, position(), limit(), value); inc_pos(2); return this; } final public short getShort(int index) { short a = nio_get_Short(this, index, limit()); return a; } final public ByteBuffer putShort(int index, short value) { nio_put_Short(this, index, limit(), value); return this; };\n+  final public int getInt() { int a = nio_get_Int(this, position(), limit()); inc_pos(4); return a; } final public ByteBuffer putInt(int value) { nio_put_Int(this, position(), limit(), value); inc_pos(4); return this; } final public int getInt(int index) { int a = nio_get_Int(this, index, limit()); return a; } final public ByteBuffer putInt(int index, int value) { nio_put_Int(this, index, limit(), value); return this; };\n+  final public long getLong() { long a = nio_get_Long(this, position(), limit()); inc_pos(8); return a; } final public ByteBuffer putLong(long value) { nio_put_Long(this, position(), limit(), value); inc_pos(8); return this; } final public long getLong(int index) { long a = nio_get_Long(this, index, limit()); return a; } final public ByteBuffer putLong(int index, long value) { nio_put_Long(this, index, limit(), value); return this; };\n+  final public float getFloat() { float a = nio_get_Float(this, position(), limit()); inc_pos(4); return a; } final public ByteBuffer putFloat(float value) { nio_put_Float(this, position(), limit(), value); inc_pos(4); return this; } final public float getFloat(int index) { float a = nio_get_Float(this, index, limit()); return a; } final public ByteBuffer putFloat(int index, float value) { nio_put_Float(this, index, limit(), value); return this; };\n+  final public double getDouble() { double a = nio_get_Double(this, position(), limit()); inc_pos(8); return a; } final public ByteBuffer putDouble(double value) { nio_put_Double(this, position(), limit(), value); inc_pos(8); return this; } final public double getDouble(int index) { double a = nio_get_Double(this, index, limit()); return a; } final public ByteBuffer putDouble(int index, double value) { nio_put_Double(this, index, limit(), value); return this; };\n+}"}, {"sha": "5253646cc8c561677b71673005970ce7554a054c", "filename": "libjava/gnu/java/nio/CharBufferImpl.java", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FCharBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FCharBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FCharBufferImpl.java?ref=48f5b6723a0f7dd8e8889c2eb4deea9185863386", "patch": "@@ -0,0 +1,223 @@\n+/* CharBufferImpl.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.CharBuffer;\n+import java.nio.DoubleBuffer;\n+import java.nio.FloatBuffer;\n+import java.nio.IntBuffer;\n+import java.nio.LongBuffer;\n+import java.nio.ShortBuffer;\n+\n+public final class CharBufferImpl extends CharBuffer\n+{\n+  private int array_offset;\n+  private boolean ro;\n+  \n+  public CharBufferImpl(int cap, int off, int lim)\n+  {\n+    this.backing_buffer = new char[cap];\n+    this.cap = cap;\n+    this.position(off);\n+    this.limit(lim);\n+  }\n+  \n+  public CharBufferImpl(char[] array, int off, int lim)\n+  {\n+    this.backing_buffer = array;\n+    this.cap = array.length;\n+    this.position(off);\n+    this.limit(lim);\n+  }\n+  \n+  public CharBufferImpl (CharBufferImpl copy)\n+  {\n+    backing_buffer = copy.backing_buffer;\n+    ro = copy.ro;\n+    position (copy.position ());\n+    limit (copy.limit());\n+  }\n+  \n+  void inc_pos (int a)\n+  {\n+    position (position () + a);\n+  }\n+ \n+//   private static native char[] nio_cast(byte[]copy);\n+//   private static native char[] nio_cast(char[]copy);\n+//   private static native char[] nio_cast(short[]copy);\n+//   private static native char[] nio_cast(long[]copy);\n+//   private static native char[] nio_cast(int[]copy);\n+//   private static native char[] nio_cast(float[]copy);\n+//   private static native char[] nio_cast(double[]copy);\n+\n+  private static char[] nio_cast(byte[]copy) { return null; };\n+  private static char[] nio_cast(char[]copy) { return null; };\n+  private static char[] nio_cast(short[]copy) { return null; };\n+  private static char[] nio_cast(long[]copy) { return null; };\n+  private static char[] nio_cast(int[]copy) { return null; };\n+  private static char[] nio_cast(float[]copy) { return null; };\n+  private static char[] nio_cast(double[]copy) { return null; };\n+\n+  CharBufferImpl(byte[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native byte nio_get_Byte(CharBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Byte(CharBufferImpl b, int index, int limit, byte value);\n+  private static byte nio_get_Byte(CharBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Byte(CharBufferImpl b, int index, int limit, byte value) { };\n+  public java.nio. ByteBuffer asByteBuffer() { gnu.java.nio. ByteBufferImpl res = new gnu.java.nio. ByteBufferImpl(backing_buffer); res.limit((limit()*1)/2); return res; }\n+\n+  CharBufferImpl(char[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native char nio_get_Char(CharBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Char(CharBufferImpl b, int index, int limit, char value);\n+  private static char nio_get_Char(CharBufferImpl b, int index, int limit) { return ' '; };\n+  private static void nio_put_Char(CharBufferImpl b, int index, int limit, char value) { };\n+  public java.nio. CharBuffer asCharBuffer() { gnu.java.nio. CharBufferImpl res = new gnu.java.nio. CharBufferImpl(backing_buffer); res.limit((limit()*2)/2); return res; }\n+\n+  CharBufferImpl(short[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native short nio_get_Short(CharBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Short(CharBufferImpl b, int index, int limit, short value);\n+  private static short nio_get_Short(CharBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Short(CharBufferImpl b, int index, int limit, short value) { };\n+  public java.nio. ShortBuffer asShortBuffer() { gnu.java.nio. ShortBufferImpl res = new gnu.java.nio. ShortBufferImpl(backing_buffer); res.limit((limit()*2)/2); return res; }\n+\n+  CharBufferImpl(int[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native int nio_get_Int(CharBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Int(CharBufferImpl b, int index, int limit, int value);\n+  private static int nio_get_Int(CharBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Int(CharBufferImpl b, int index, int limit, int value) { };\n+  public java.nio. IntBuffer asIntBuffer() { gnu.java.nio. IntBufferImpl res = new gnu.java.nio. IntBufferImpl(backing_buffer); res.limit((limit()*4)/2); return res; }\n+\n+  CharBufferImpl(long[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native long nio_get_Long(CharBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Long(CharBufferImpl b, int index, int limit, long value);\n+  private static long nio_get_Long(CharBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Long(CharBufferImpl b, int index, int limit, long value) { };\n+  public java.nio. LongBuffer asLongBuffer() { gnu.java.nio. LongBufferImpl res = new gnu.java.nio. LongBufferImpl(backing_buffer); res.limit((limit()*8)/2); return res; }\n+\n+  CharBufferImpl(float[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native float nio_get_Float(CharBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Float(CharBufferImpl b, int index, int limit, float value);\n+  private static float nio_get_Float(CharBufferImpl b, int index, int limit) { return 0.0f; };\n+  private static void nio_put_Float(CharBufferImpl b, int index, int limit, float value) { };\n+  public java.nio. FloatBuffer asFloatBuffer() { gnu.java.nio. FloatBufferImpl res = new gnu.java.nio. FloatBufferImpl(backing_buffer); res.limit((limit()*4)/2); return res; }\n+\n+  CharBufferImpl(double[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native double nio_get_Double(CharBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Double(CharBufferImpl b, int index, int limit, double value);\n+  private static double nio_get_Double(CharBufferImpl b, int index, int limit) { return 0.0d; };\n+  private static void nio_put_Double(CharBufferImpl b, int index, int limit, double value) { };\n+  public java.nio. DoubleBuffer asDoubleBuffer() { gnu.java.nio. DoubleBufferImpl res = new gnu.java.nio. DoubleBufferImpl(backing_buffer); res.limit((limit()*8)/2); return res; }\n+  \n+  public boolean isReadOnly()\n+    {\n+        return ro;\n+    }\n+    public CharBuffer slice()\n+    {\n+        CharBufferImpl A = new CharBufferImpl(this);\n+        A.array_offset = position();\n+        return A;\n+    }\n+    public CharBuffer duplicate()\n+    {\n+        return new CharBufferImpl(this);\n+    }\n+    public CharBuffer asReadOnlyBuffer()\n+    {\n+        CharBufferImpl a = new CharBufferImpl(this);\n+        a.ro = true;\n+        return a;\n+    }\n+    public CharBuffer compact()\n+    {\n+        return this;\n+    }\n+    public boolean isDirect()\n+    {\n+        return backing_buffer != null;\n+    }\n+  final public char get()\n+    {\n+        char e = backing_buffer[position()];\n+        position(position()+1);\n+        return e;\n+    }\n+  final public CharBuffer put(char b)\n+    {\n+        backing_buffer[position()] = b;\n+        position(position()+1);\n+        return this;\n+    }\n+  final public char get(int index)\n+    {\n+        return backing_buffer[index];\n+    }\n+   final public java.nio. CharBuffer put(int index, char b)\n+    {\n+      backing_buffer[index] = b;\n+      return this;\n+    }\n+\n+  final public char getChar() { return get(); } final public java.nio. CharBuffer putChar(char value) { return put(value); } final public char getChar(int index) { return get(index); } final public java.nio. CharBuffer putChar(int index, char value) { return put(index, value); };\n+  final public short getShort() { short a = nio_get_Short(this, position(), limit()); inc_pos(2); return a; } final public java.nio. CharBuffer putShort(short value) { nio_put_Short(this, position(), limit(), value); inc_pos(2); return this; } final public short getShort(int index) { short a = nio_get_Short(this, index, limit()); return a; } final public java.nio. CharBuffer putShort(int index, short value) { nio_put_Short(this, index, limit(), value); return this; };\n+  final public int getInt() { int a = nio_get_Int(this, position(), limit()); inc_pos(4); return a; } final public java.nio. CharBuffer putInt(int value) { nio_put_Int(this, position(), limit(), value); inc_pos(4); return this; } final public int getInt(int index) { int a = nio_get_Int(this, index, limit()); return a; } final public java.nio. CharBuffer putInt(int index, int value) { nio_put_Int(this, index, limit(), value); return this; };\n+  final public long getLong() { long a = nio_get_Long(this, position(), limit()); inc_pos(8); return a; } final public java.nio. CharBuffer putLong(long value) { nio_put_Long(this, position(), limit(), value); inc_pos(8); return this; } final public long getLong(int index) { long a = nio_get_Long(this, index, limit()); return a; } final public java.nio. CharBuffer putLong(int index, long value) { nio_put_Long(this, index, limit(), value); return this; };\n+  final public float getFloat() { float a = nio_get_Float(this, position(), limit()); inc_pos(4); return a; } final public java.nio. CharBuffer putFloat(float value) { nio_put_Float(this, position(), limit(), value); inc_pos(4); return this; } final public float getFloat(int index) { float a = nio_get_Float(this, index, limit()); return a; } final public java.nio. CharBuffer putFloat(int index, float value) { nio_put_Float(this, index, limit(), value); return this; };\n+  final public double getDouble() { double a = nio_get_Double(this, position(), limit()); inc_pos(8); return a; } final public java.nio. CharBuffer putDouble(double value) { nio_put_Double(this, position(), limit(), value); inc_pos(8); return this; } final public double getDouble(int index) { double a = nio_get_Double(this, index, limit()); return a; } final public java.nio. CharBuffer putDouble(int index, double value) { nio_put_Double(this, index, limit(), value); return this; };\n+\n+    public String toString()\n+    {\n+      if (backing_buffer != null)\n+        {\n+          return new String(backing_buffer, position(), limit());\n+        }\n+      return super.toString();\n+    }\n+\n+  public final ByteOrder order()\n+  {\n+    return endian;\n+  }\n+\n+  public CharSequence subSequence(int a, int b)\n+  {\n+    return null;\n+  }\n+}"}, {"sha": "b192ef2367d54b7f09316876ffd425de41148505", "filename": "libjava/gnu/java/nio/DatagramChannelImpl.java", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FDatagramChannelImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FDatagramChannelImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FDatagramChannelImpl.java?ref=48f5b6723a0f7dd8e8889c2eb4deea9185863386", "patch": "@@ -0,0 +1,110 @@\n+/* DatagramChannelImpl.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio;\n+\n+import java.net.DatagramSocket;\n+import java.net.SocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.DatagramChannel;\n+import java.nio.channels.spi.SelectorProvider;\n+\n+public class DatagramChannelImpl extends DatagramChannel\n+{\n+  protected DatagramChannelImpl (SelectorProvider provider)\n+  {\n+    super (provider);\n+  }\n+    \n+  protected void implCloseSelectableChannel ()\n+  {\n+  }\n+    \n+  protected void implConfigureBlocking (boolean block)\n+  {\n+  }\n+\n+  public int write (ByteBuffer src)\n+  {\n+    return 0;\n+  }\n+\n+  public long write (ByteBuffer[] srcs, int offset, int length)\n+  {\n+    return 0;\n+  }\n+\n+  public int read (ByteBuffer dst)\n+  {\n+    return 0;\n+  }\n+    \n+  public DatagramChannel connect (SocketAddress remote)\n+  {\n+    return null;\n+  }\n+    \n+  public DatagramChannel disconnect ()\n+  {\n+    return null;\n+  }\n+    \n+  public boolean isConnected ()\n+  {\n+    return false;\n+  }\n+    \n+  public long read (ByteBuffer[] dsts, int offset, int length)\n+  {\n+    return 0;\n+  }\n+    \n+  public SocketAddress receive (ByteBuffer dst)\n+  {\n+    return null;\n+  }\n+    \n+  public int send (ByteBuffer src, SocketAddress target)\n+  {\n+    return 0;\n+  }\n+    \n+  public DatagramSocket socket ()\n+  {\n+    return null;\n+  }\n+}"}, {"sha": "40628679ef03b812f2150cc6ab21e36f0b4600fe", "filename": "libjava/gnu/java/nio/DoubleBufferImpl.java", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FDoubleBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FDoubleBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FDoubleBufferImpl.java?ref=48f5b6723a0f7dd8e8889c2eb4deea9185863386", "patch": "@@ -0,0 +1,212 @@\n+/* DoubleBufferImpl.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.DoubleBuffer;\n+import java.nio.FloatBuffer;\n+import java.nio.IntBuffer;\n+import java.nio.LongBuffer;\n+import java.nio.ShortBuffer;\n+\n+public final class DoubleBufferImpl extends DoubleBuffer\n+{\n+  private int array_offset;\n+  private boolean ro;\n+  \n+  public DoubleBufferImpl(int cap, int off, int lim)\n+  {\n+    this.backing_buffer = new double[cap];\n+    this.cap = cap;\n+    this.position(off);\n+    this.limit(lim);\n+  }\n+  \n+  public DoubleBufferImpl(double[] array, int off, int lim)\n+  {\n+    this.backing_buffer = array;\n+    this.cap = array.length;\n+    this.position(off);\n+    this.limit(lim);\n+  }\n+\n+  public DoubleBufferImpl(DoubleBufferImpl copy)\n+  {\n+    backing_buffer = copy.backing_buffer;\n+    ro = copy.ro;\n+    position(copy.position());\n+    limit(copy.limit());\n+  }\n+  \n+  void inc_pos(int a)\n+  {\n+    position(position() + a);\n+  }\n+  \n+//   private static native double[] nio_cast(byte[]copy);\n+//   private static native double[] nio_cast(char[]copy);\n+//   private static native double[] nio_cast(short[]copy);\n+//   private static native double[] nio_cast(long[]copy);\n+//   private static native double[] nio_cast(int[]copy);\n+//   private static native double[] nio_cast(float[]copy);\n+//   private static native double[] nio_cast(double[]copy);\n+\n+  private static double[] nio_cast(byte[]copy) { return null; };\n+  private static double[] nio_cast(char[]copy) { return null; };\n+  private static double[] nio_cast(short[]copy) { return null; };\n+  private static double[] nio_cast(long[]copy) { return null; };\n+  private static double[] nio_cast(int[]copy) { return null; };\n+  private static double[] nio_cast(float[]copy) { return null; };\n+  private static double[] nio_cast(double[]copy) { return null; };\n+\n+  DoubleBufferImpl(byte[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native byte nio_get_Byte(DoubleBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Byte(DoubleBufferImpl b, int index, int limit, byte value);\n+  private static byte nio_get_Byte(DoubleBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Byte(DoubleBufferImpl b, int index, int limit, byte value) { };\n+  public ByteBuffer asByteBuffer() { ByteBufferImpl res = new ByteBufferImpl(backing_buffer); res.limit((limit()*1)/8); return res; }\n+\n+  DoubleBufferImpl(char[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native char nio_get_Char(DoubleBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Char(DoubleBufferImpl b, int index, int limit, char value);\n+  private static char nio_get_Char(DoubleBufferImpl b, int index, int limit) { return ' '; };\n+  private static void nio_put_Char(DoubleBufferImpl b, int index, int limit, char value) { };\n+  public CharBuffer asCharBuffer() { CharBufferImpl res = new CharBufferImpl(backing_buffer); res.limit((limit()*2)/8); return res; }\n+\n+  DoubleBufferImpl(short[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native short nio_get_Short(DoubleBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Short(DoubleBufferImpl b, int index, int limit, short value);\n+  private static short nio_get_Short(DoubleBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Short(DoubleBufferImpl b, int index, int limit, short value) { };\n+  public ShortBuffer asShortBuffer() { ShortBufferImpl res = new ShortBufferImpl(backing_buffer); res.limit((limit()*2)/8); return res; }\n+\n+  DoubleBufferImpl(int[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native int nio_get_Int(DoubleBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Int(DoubleBufferImpl b, int index, int limit, int value);\n+  private static int nio_get_Int(DoubleBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Int(DoubleBufferImpl b, int index, int limit, int value) { };\n+  public IntBuffer asIntBuffer() { IntBufferImpl res = new IntBufferImpl(backing_buffer); res.limit((limit()*4)/8); return res; }\n+\n+  DoubleBufferImpl(long[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native long nio_get_Long(DoubleBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Long(DoubleBufferImpl b, int index, int limit, long value);\n+  private static long nio_get_Long(DoubleBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Long(DoubleBufferImpl b, int index, int limit, long value) { };\n+  public LongBuffer asLongBuffer() { LongBufferImpl res = new LongBufferImpl(backing_buffer); res.limit((limit()*8)/8); return res; }\n+\n+  DoubleBufferImpl(float[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native float nio_get_Float(DoubleBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Float(DoubleBufferImpl b, int index, int limit, float value);\n+  private static float nio_get_Float(DoubleBufferImpl b, int index, int limit) { return 0.0f; };\n+  private static void nio_put_Float(DoubleBufferImpl b, int index, int limit, float value) { };\n+  public FloatBuffer asFloatBuffer() { FloatBufferImpl res = new FloatBufferImpl(backing_buffer); res.limit((limit()*4)/8); return res; }\n+\n+  DoubleBufferImpl(double[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native double nio_get_Double(DoubleBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Double(DoubleBufferImpl b, int index, int limit, double value);\n+  private static double nio_get_Double(DoubleBufferImpl b, int index, int limit) { return 0.0d; };\n+  private static void nio_put_Double(DoubleBufferImpl b, int index, int limit, double value) { };\n+  public DoubleBuffer asDoubleBuffer() { DoubleBufferImpl res = new DoubleBufferImpl(backing_buffer); res.limit((limit()*8)/8); return res; }\n+\n+  public boolean isReadOnly()\n+  {\n+    return ro;\n+  }\n+\n+  public DoubleBuffer slice()\n+  {\n+    DoubleBufferImpl A = new DoubleBufferImpl(this);\n+    A.array_offset = position();\n+    return A;\n+  }\n+\n+  public DoubleBuffer duplicate()\n+  {\n+    return new DoubleBufferImpl(this);\n+  }\n+\n+  public DoubleBuffer asReadOnlyBuffer()\n+  {\n+    DoubleBufferImpl a = new DoubleBufferImpl(this);\n+    a.ro = true;\n+    return a;\n+  }\n+\n+  public DoubleBuffer compact()\n+  {\n+    return this;\n+  }\n+\n+  public boolean isDirect()\n+  {\n+    return backing_buffer != null;\n+  }\n+\n+  final public double get()\n+  {\n+    double e = backing_buffer[position()];\n+    position(position()+1);\n+    return e;\n+  }\n+\n+  final public DoubleBuffer put(double b)\n+  {\n+    backing_buffer[position()] = b;\n+    position(position()+1);\n+    return this;\n+  }\n+\n+  final public double get(int index)\n+  {\n+    return backing_buffer[index];\n+  }\n+\n+  final public DoubleBuffer put(int index, double b)\n+  {\n+    backing_buffer[index] = b;\n+    return this;\n+  }\n+\n+  final public char getChar() { char a = nio_get_Char(this, position(), limit()); inc_pos(2); return a; } final public DoubleBuffer putChar(char value) { nio_put_Char(this, position(), limit(), value); inc_pos(2); return this; } final public char getChar(int index) { char a = nio_get_Char(this, index, limit()); return a; } final public DoubleBuffer putChar(int index, char value) { nio_put_Char(this, index, limit(), value); return this; };\n+  final public short getShort() { short a = nio_get_Short(this, position(), limit()); inc_pos(2); return a; } final public DoubleBuffer putShort(short value) { nio_put_Short(this, position(), limit(), value); inc_pos(2); return this; } final public short getShort(int index) { short a = nio_get_Short(this, index, limit()); return a; } final public DoubleBuffer putShort(int index, short value) { nio_put_Short(this, index, limit(), value); return this; };\n+  final public int getInt() { int a = nio_get_Int(this, position(), limit()); inc_pos(4); return a; } final public DoubleBuffer putInt(int value) { nio_put_Int(this, position(), limit(), value); inc_pos(4); return this; } final public int getInt(int index) { int a = nio_get_Int(this, index, limit()); return a; } final public DoubleBuffer putInt(int index, int value) { nio_put_Int(this, index, limit(), value); return this; };\n+  final public long getLong() { long a = nio_get_Long(this, position(), limit()); inc_pos(8); return a; } final public DoubleBuffer putLong(long value) { nio_put_Long(this, position(), limit(), value); inc_pos(8); return this; } final public long getLong(int index) { long a = nio_get_Long(this, index, limit()); return a; } final public DoubleBuffer putLong(int index, long value) { nio_put_Long(this, index, limit(), value); return this; };\n+  final public float getFloat() { float a = nio_get_Float(this, position(), limit()); inc_pos(4); return a; } final public DoubleBuffer putFloat(float value) { nio_put_Float(this, position(), limit(), value); inc_pos(4); return this; } final public float getFloat(int index) { float a = nio_get_Float(this, index, limit()); return a; } final public DoubleBuffer putFloat(int index, float value) { nio_put_Float(this, index, limit(), value); return this; };\n+  final public double getDouble() { return get(); } final public DoubleBuffer putDouble(double value) { return put(value); } final public double getDouble(int index) { return get(index); } final public DoubleBuffer putDouble(int index, double value) { return put(index, value); };\n+}"}, {"sha": "26b48e5e51cf43ee25501c0e13984a5da89b7076", "filename": "libjava/gnu/java/nio/FileChannelImpl.java", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FFileChannelImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FFileChannelImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FFileChannelImpl.java?ref=48f5b6723a0f7dd8e8889c2eb4deea9185863386", "patch": "@@ -0,0 +1,234 @@\n+/* FileChannelImpl.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio;\n+\n+import java.io.EOFException;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.FileChannel;\n+\n+/**\n+ * This file is not user visible !\n+ * But alas, Java does not have a concept of friendly packages\n+ * so this class is public. \n+ * Instances of this class are created by invoking getChannel\n+ * Upon a Input/Output/RandomAccessFile object.\n+ */\n+\n+public class FileChannelImpl extends FileChannel\n+{\n+  public long address;\n+  public int length;\n+  public int fd;\n+  public MappedByteBuffer buf;\n+  public Object file_obj; // just to keep it live...\n+\n+  /**\n+   * This method came from java.io.RandomAccessFile\n+   * It is private there so we will repeat it here.\n+   */\n+//   private native long lengthInternal (int native_fd) throws IOException;\n+  private long lengthInternal (int native_fd) throws IOException\n+  {\n+    return 0;\n+  };\n+\n+  public FileChannelImpl (int fd, Object obj)\n+  {\n+    this.fd = fd;\n+    this.file_obj = obj;\n+  }\n+\n+  public long size () throws IOException\n+  {\n+    return lengthInternal (fd);\n+  }\n+    \n+  protected void implCloseChannel()  throws IOException\n+  {\n+    if (address != 0)\n+\t    {\n+        nio_unmmap_file (fd, address, (int) length);\n+\t    }\n+\n+    // FIXME\n+    fd = 0;\n+\n+    if (file_obj instanceof RandomAccessFile)\n+\t    {\n+        RandomAccessFile o = (RandomAccessFile) file_obj;\n+        o.close();\n+\t    }\n+    else if (file_obj instanceof FileInputStream)\n+\t    {\n+        FileInputStream o = (FileInputStream) file_obj;\n+        o.close();\n+\t    }\n+    else if (file_obj instanceof FileOutputStream)\n+\t    {\n+        FileOutputStream o = (FileOutputStream) file_obj;\n+        o.close();\n+\t    }\n+  }\n+\n+  public int read (ByteBuffer dst) throws IOException\n+  {\n+    int w = 0;\n+    int s = (int)size();\n+\n+    if (buf == null)\n+\t    {\n+        throw new EOFException(\"file not mapped\");\n+\t    }\n+\n+    for (int i=0; i<s; i++)\n+\t    {\n+        dst.put( buf.get() );\n+\t    }\n+\n+    return s;\n+  }\n+\n+  public long read (ByteBuffer[] dsts) throws IOException\n+  {\n+    return read (dsts, 0, dsts.length);\n+  }\n+\n+  public long read (ByteBuffer[] dsts, int offset, int length)\n+    throws IOException\n+  {\n+    long result = 0;\n+\n+    for (int i = offset; i < offset + length; i++)\n+\t    {\n+        result += write (dsts[i]);\n+\t    }\n+\n+    return result;\n+  }\n+\n+  public int write (ByteBuffer src) throws IOException\n+  {\n+    int w = 0;\n+\n+    if (buf == null)\n+\t    {\n+        throw new EOFException (\"file not mapped\");\n+\t    }\n+\n+    while (src.hasRemaining ())\n+\t    {\n+        buf.put (src.get ());\n+        w++;\n+\t    }\n+\n+    return w;\n+  }\n+    \n+  public long write(ByteBuffer[] srcs, int offset, int length)\n+    throws IOException\n+  {\n+    long res = 0;\n+\n+    for (int i = offset;i < offset + length;i++)\n+\t    {\n+        res += write (srcs[i]);\n+\t    }\n+\treturn res;\n+    }\n+\t\t\t\t   \n+  public MappedByteBuffer map (FileChannel.MapMode mode, long position,\n+                               long size)\n+    throws IOException\n+  {\n+//     int cmode = mode.m;\n+//     address = nio_mmap_file (fd, position, size, cmode);\n+//     length = size;\n+//     buf = new MappedByteFileBuffer (this);\n+//     return buf;\n+    return null;\n+  }\n+\n+  static MappedByteBuffer create_direct_mapped_buffer (long address,\n+                                                       long length)\n+  {\n+//     FileChannelImpl ch = new FileChannelImpl (-1, null);\n+//     ch.address = address;\n+//     ch.length = (int) length;\n+//     ch.buf = new MappedByteFileBuffer (ch);\n+//     return ch.buf;\t\t\t \n+    return null;\n+  }\n+\n+  public long write (ByteBuffer[] srcs)\n+    throws IOException\n+  {\n+    return write (srcs, 0, srcs.length);\n+  }\n+\t\t\t\t   \n+  /**\n+   * msync with the disk\n+   */\n+  public void force (boolean metaData)\n+  {\n+    nio_msync (fd, address, length);\n+  }\n+\n+//   static native long nio_mmap_file (int fd, long pos, int size, int mode);\n+\n+//   static native void nio_unmmap_file (int fd, long address, int size);\n+\n+//   static native void nio_msync (int fd, long address, int length);\n+\n+  static long nio_mmap_file (int fd, long pos, int size, int mode)\n+  {\n+    return 0;\n+  }\n+\n+  static void nio_unmmap_file (int fd, long address, int size)\n+  {\n+  };\n+\n+  static void nio_msync (int fd, long address, int length)\n+  {\n+  };\n+}"}, {"sha": "0df0f72bd080f8b20a15515adb647daef3b7abdd", "filename": "libjava/gnu/java/nio/FloatBufferImpl.java", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FFloatBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FFloatBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FFloatBufferImpl.java?ref=48f5b6723a0f7dd8e8889c2eb4deea9185863386", "patch": "@@ -0,0 +1,218 @@\n+/* FloatBufferImpl.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.DoubleBuffer;\n+import java.nio.FloatBuffer;\n+import java.nio.IntBuffer;\n+import java.nio.LongBuffer;\n+import java.nio.ShortBuffer;\n+\n+public final class FloatBufferImpl extends FloatBuffer\n+{\n+  private int array_offset;\n+  private boolean ro;\n+  \n+  public FloatBufferImpl(int cap, int off, int lim)\n+  {\n+    this.backing_buffer = new float[cap];\n+    this.cap = cap;\n+    this.position(off);\n+    this.limit(lim);\n+  }\n+  \n+  public FloatBufferImpl(float[] array, int off, int lim)\n+  {\n+    this.backing_buffer = array;\n+    this.cap = array.length;\n+    this.position(off);\n+    this.limit(lim);\n+  }\n+  \n+  public FloatBufferImpl(FloatBufferImpl copy)\n+  {\n+    backing_buffer = copy.backing_buffer;\n+    ro = copy.ro;\n+    position(copy.position());\n+    limit(copy.limit());\n+  }\n+  \n+  void inc_pos(int a)\n+  {\n+    position(position() + a);\n+  }\n+  \n+//   private static native float[] nio_cast(byte[]copy);\n+//   private static native float[] nio_cast(char[]copy);\n+//   private static native float[] nio_cast(short[]copy);\n+//   private static native float[] nio_cast(long[]copy);\n+//   private static native float[] nio_cast(int[]copy);\n+//   private static native float[] nio_cast(float[]copy);\n+//   private static native float[] nio_cast(double[]copy);\n+  \n+  private static float[] nio_cast(byte[]copy) { return null; };\n+  private static float[] nio_cast(char[]copy) { return null; };\n+  private static float[] nio_cast(short[]copy) { return null; };\n+  private static float[] nio_cast(long[]copy) { return null; };\n+  private static float[] nio_cast(int[]copy) { return null; };\n+  private static float[] nio_cast(float[]copy) { return null; };\n+  private static float[] nio_cast(double[]copy) { return null; };\n+  \n+  FloatBufferImpl(byte[] copy) { this.backing_buffer = copy != null ? nio_cast (copy) : null; }\n+//   private static native byte nio_get_Byte (FloatBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Byte (FloatBufferImpl b, int index, int limit, byte value);\n+  private static byte nio_get_Byte (FloatBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Byte (FloatBufferImpl b, int index, int limit, byte value) { };\n+\n+  public ByteBuffer asByteBuffer()\n+  {\n+    ByteBufferImpl res = new ByteBufferImpl (backing_buffer);\n+    res.limit ((limit () * 1) / 4);\n+    return res;\n+  }\n+  \n+  FloatBufferImpl(char[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native char nio_get_Char(FloatBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Char(FloatBufferImpl b, int index, int limit, char value);\n+  private static char nio_get_Char(FloatBufferImpl b, int index, int limit) { return ' '; };\n+  private static void nio_put_Char(FloatBufferImpl b, int index, int limit, char value) { };\n+  public CharBuffer asCharBuffer() { CharBufferImpl res = new CharBufferImpl(backing_buffer); res.limit((limit()*2)/4); return res; }\n+\n+  FloatBufferImpl(short[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native short nio_get_Short(FloatBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Short(FloatBufferImpl b, int index, int limit, short value);\n+  private static short nio_get_Short(FloatBufferImpl b, int index, int limit) { return 0;};\n+  private static void nio_put_Short(FloatBufferImpl b, int index, int limit, short value) { };\n+  public ShortBuffer asShortBuffer() { ShortBufferImpl res = new ShortBufferImpl(backing_buffer); res.limit((limit()*2)/4); return res; }\n+  \n+  FloatBufferImpl(int[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native int nio_get_Int(FloatBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Int(FloatBufferImpl b, int index, int limit, int value);\n+  private static int nio_get_Int(FloatBufferImpl b, int index, int limit) { return 0;};\n+  private static void nio_put_Int(FloatBufferImpl b, int index, int limit, int value) { };\n+  public IntBuffer asIntBuffer() { IntBufferImpl res = new IntBufferImpl(backing_buffer); res.limit((limit()*4)/4); return res; }\n+  \n+  FloatBufferImpl(long[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native long nio_get_Long(FloatBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Long(FloatBufferImpl b, int index, int limit, long value);\n+  private static long nio_get_Long(FloatBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Long(FloatBufferImpl b, int index, int limit, long value) { };\n+  public LongBuffer asLongBuffer() { LongBufferImpl res = new LongBufferImpl(backing_buffer); res.limit((limit()*8)/4); return res; }\n+\n+  FloatBufferImpl(float[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native float nio_get_Float(FloatBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Float(FloatBufferImpl b, int index, int limit, float value);\n+  private static float nio_get_Float(FloatBufferImpl b, int index, int limit) { return 0.0f; };\n+  private static void nio_put_Float(FloatBufferImpl b, int index, int limit, float value) { };\n+  public FloatBuffer asFloatBuffer() { FloatBufferImpl res = new FloatBufferImpl(backing_buffer); res.limit((limit()*4)/4); return res; }\n+\n+  FloatBufferImpl(double[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native double nio_get_Double(FloatBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Double(FloatBufferImpl b, int index, int limit, double value);\n+  private static double nio_get_Double(FloatBufferImpl b, int index, int limit) { return 0.0d; };\n+  private static void nio_put_Double(FloatBufferImpl b, int index, int limit, double value) { };\n+  public DoubleBuffer asDoubleBuffer() { DoubleBufferImpl res = new DoubleBufferImpl(backing_buffer); res.limit((limit()*8)/4); return res; }\n+  \n+  public boolean isReadOnly()\n+  {\n+    return ro;\n+  }\n+  \n+  public java.nio. FloatBuffer slice()\n+  {\n+    FloatBufferImpl A = new FloatBufferImpl(this);\n+    A.array_offset = position();\n+    return A;\n+  }\n+  \n+  public java.nio. FloatBuffer duplicate()\n+  {\n+    return new FloatBufferImpl(this);\n+  }\n+  \n+  public java.nio. FloatBuffer asReadOnlyBuffer()\n+  {\n+    FloatBufferImpl a = new FloatBufferImpl(this);\n+    a.ro = true;\n+    return a;\n+  }\n+  \n+  public java.nio. FloatBuffer compact()\n+  {\n+    return this;\n+  }\n+  \n+  public boolean isDirect()\n+  {\n+    return backing_buffer != null;\n+  }\n+  \n+  final public float get()\n+  {\n+    float e = backing_buffer[position()];\n+    position(position()+1);\n+    return e;\n+  }\n+  \n+  final public java.nio. FloatBuffer put(float b)\n+  {\n+    backing_buffer[position()] = b;\n+    position(position()+1);\n+    return this;\n+  }\n+  \n+  final public float get(int index)\n+  {\n+    return backing_buffer[index];\n+  }\n+  \n+  final public java.nio. FloatBuffer put(int index, float b)\n+  {\n+    backing_buffer[index] = b;\n+    return this;\n+  }\n+  \n+  final public char getChar() { char a = nio_get_Char(this, position(), limit()); inc_pos(2); return a; } final public java.nio. FloatBuffer putChar(char value) { nio_put_Char(this, position(), limit(), value); inc_pos(2); return this; } final public char getChar(int index) { char a = nio_get_Char(this, index, limit()); return a; } final public java.nio. FloatBuffer putChar(int index, char value) { nio_put_Char(this, index, limit(), value); return this; };\n+  final public short getShort() { short a = nio_get_Short(this, position(), limit()); inc_pos(2); return a; } final public java.nio. FloatBuffer putShort(short value) { nio_put_Short(this, position(), limit(), value); inc_pos(2); return this; } final public short getShort(int index) { short a = nio_get_Short(this, index, limit()); return a; } final public java.nio. FloatBuffer putShort(int index, short value) { nio_put_Short(this, index, limit(), value); return this; };\n+  final public int getInt() { int a = nio_get_Int(this, position(), limit()); inc_pos(4); return a; } final public java.nio. FloatBuffer putInt(int value) { nio_put_Int(this, position(), limit(), value); inc_pos(4); return this; } final public int getInt(int index) { int a = nio_get_Int(this, index, limit()); return a; } final public java.nio. FloatBuffer putInt(int index, int value) { nio_put_Int(this, index, limit(), value); return this; };\n+  final public long getLong() { long a = nio_get_Long(this, position(), limit()); inc_pos(8); return a; } final public java.nio. FloatBuffer putLong(long value) { nio_put_Long(this, position(), limit(), value); inc_pos(8); return this; } final public long getLong(int index) { long a = nio_get_Long(this, index, limit()); return a; } final public java.nio. FloatBuffer putLong(int index, long value) { nio_put_Long(this, index, limit(), value); return this; };\n+  final public float getFloat() { return get(); } final public java.nio. FloatBuffer putFloat(float value) { return put(value); } final public float getFloat(int index) { return get(index); } final public java.nio. FloatBuffer putFloat(int index, float value) { return put(index, value); };\n+  final public double getDouble() { double a = nio_get_Double(this, position(), limit()); inc_pos(8); return a; } final public java.nio. FloatBuffer putDouble(double value) { nio_put_Double(this, position(), limit(), value); inc_pos(8); return this; } final public double getDouble(int index) { double a = nio_get_Double(this, index, limit()); return a; } final public java.nio. FloatBuffer putDouble(int index, double value) { nio_put_Double(this, index, limit(), value); return this; };\n+}"}, {"sha": "db1754da2f7352c6a04fcb137e02b9f4b7fa42c2", "filename": "libjava/gnu/java/nio/IntBufferImpl.java", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FIntBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FIntBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FIntBufferImpl.java?ref=48f5b6723a0f7dd8e8889c2eb4deea9185863386", "patch": "@@ -0,0 +1,206 @@\n+/* IntBufferImpl.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio;\n+\n+import java.nio.IntBuffer;\n+\n+public final class IntBufferImpl extends IntBuffer\n+{\n+  private int array_offset;\n+  private boolean ro;\n+  \n+  public IntBufferImpl(int cap, int off, int lim)\n+  {\n+    this.backing_buffer = new int[cap];\n+    this.cap = cap;\n+    this.position(off);\n+    this.limit(lim);\n+  }\n+\n+  public IntBufferImpl(int[] array, int off, int lim)\n+  {\n+    this.backing_buffer = array;\n+    this.cap = array.length;\n+    this.position(off);\n+    this.limit(lim);\n+  }\n+\n+  public IntBufferImpl(IntBufferImpl copy)\n+  {\n+    backing_buffer = copy.backing_buffer;\n+    ro = copy.ro;\n+    position(copy.position());\n+    limit(copy.limit());\n+  }\n+\n+  void inc_pos(int a)\n+  {\n+    position(position() + a);\n+  }\n+\n+//   private static native int[] nio_cast(byte[]copy);\n+//   private static native int[] nio_cast(char[]copy);\n+//   private static native int[] nio_cast(short[]copy);\n+//   private static native int[] nio_cast(long[]copy);\n+//   private static native int[] nio_cast(int[]copy);\n+//   private static native int[] nio_cast(float[]copy);\n+//   private static native int[] nio_cast(double[]copy);\n+\n+  private static int[] nio_cast(byte[]copy) { return null; };\n+  private static int[] nio_cast(char[]copy) { return null; };\n+  private static int[] nio_cast(short[]copy) { return null; };\n+  private static int[] nio_cast(long[]copy) { return null; };\n+  private static int[] nio_cast(int[]copy) { return null; };\n+  private static int[] nio_cast(float[]copy) { return null; };\n+  private static int[] nio_cast(double[]copy) { return null; };\n+\n+  IntBufferImpl(byte[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native byte nio_get_Byte(IntBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Byte(IntBufferImpl b, int index, int limit, byte value);\n+  private static byte nio_get_Byte(IntBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Byte(IntBufferImpl b, int index, int limit, byte value) { };\n+  public java.nio. ByteBuffer asByteBuffer() { gnu.java.nio. ByteBufferImpl res = new gnu.java.nio. ByteBufferImpl(backing_buffer); res.limit((limit()*1)/4); return res; }\n+\n+  IntBufferImpl(char[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native char nio_get_Char(IntBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Char(IntBufferImpl b, int index, int limit, char value);\n+  private static char nio_get_Char(IntBufferImpl b, int index, int limit) { return ' '; };\n+  private static void nio_put_Char(IntBufferImpl b, int index, int limit, char value) { };\n+  public java.nio. CharBuffer asCharBuffer() { gnu.java.nio. CharBufferImpl res = new gnu.java.nio. CharBufferImpl(backing_buffer); res.limit((limit()*2)/4); return res; }\n+\n+  IntBufferImpl(short[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native short nio_get_Short(IntBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Short(IntBufferImpl b, int index, int limit, short value);\n+  private static short nio_get_Short(IntBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Short(IntBufferImpl b, int index, int limit, short value) { };\n+  public java.nio. ShortBuffer asShortBuffer() { gnu.java.nio. ShortBufferImpl res = new gnu.java.nio. ShortBufferImpl(backing_buffer); res.limit((limit()*2)/4); return res; }\n+\n+  IntBufferImpl(int[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native int nio_get_Int(IntBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Int(IntBufferImpl b, int index, int limit, int value);\n+  private static int nio_get_Int(IntBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Int(IntBufferImpl b, int index, int limit, int value) { };\n+  public java.nio. IntBuffer asIntBuffer() { gnu.java.nio. IntBufferImpl res = new gnu.java.nio. IntBufferImpl(backing_buffer); res.limit((limit()*4)/4); return res; }\n+\n+  IntBufferImpl(long[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native long nio_get_Long(IntBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Long(IntBufferImpl b, int index, int limit, long value);\n+  private static long nio_get_Long(IntBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Long(IntBufferImpl b, int index, int limit, long value) { };\n+  public java.nio. LongBuffer asLongBuffer() { gnu.java.nio. LongBufferImpl res = new gnu.java.nio. LongBufferImpl(backing_buffer); res.limit((limit()*8)/4); return res; }\n+\n+  IntBufferImpl(float[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native float nio_get_Float(IntBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Float(IntBufferImpl b, int index, int limit, float value);\n+  private static float nio_get_Float(IntBufferImpl b, int index, int limit) { return 0.0f; };\n+  private static void nio_put_Float(IntBufferImpl b, int index, int limit, float value) { };\n+  public java.nio. FloatBuffer asFloatBuffer() { gnu.java.nio. FloatBufferImpl res = new gnu.java.nio. FloatBufferImpl(backing_buffer); res.limit((limit()*4)/4); return res; }\n+\n+  IntBufferImpl(double[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native double nio_get_Double(IntBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Double(IntBufferImpl b, int index, int limit, double value);\n+  private static double nio_get_Double(IntBufferImpl b, int index, int limit) { return 0.0d; };\n+  private static void nio_put_Double(IntBufferImpl b, int index, int limit, double value) { };\n+  public java.nio. DoubleBuffer asDoubleBuffer() { gnu.java.nio. DoubleBufferImpl res = new gnu.java.nio. DoubleBufferImpl(backing_buffer); res.limit((limit()*8)/4); return res; }\n+\n+  public boolean isReadOnly()\n+  {\n+    return ro;\n+  }\n+\n+  public java.nio. IntBuffer slice()\n+  {\n+    IntBufferImpl A = new IntBufferImpl(this);\n+    A.array_offset = position();\n+    return A;\n+  }\n+\n+  public java.nio. IntBuffer duplicate()\n+  {\n+    return new IntBufferImpl(this);\n+  }\n+\n+  public java.nio. IntBuffer asReadOnlyBuffer()\n+  {\n+    IntBufferImpl a = new IntBufferImpl(this);\n+    a.ro = true;\n+    return a;\n+  }\n+\n+  public java.nio. IntBuffer compact()\n+  {\n+    return this;\n+  }\n+\n+  public boolean isDirect()\n+  {\n+    return backing_buffer != null;\n+  }\n+\n+  final public int get()\n+  {\n+    int e = backing_buffer[position()];\n+    position(position()+1);\n+    return e;\n+  }\n+\n+  final public java.nio. IntBuffer put(int b)\n+  {\n+    backing_buffer[position()] = b;\n+    position(position()+1);\n+    return this;\n+  }\n+\n+  final public int get(int index)\n+  {\n+    return backing_buffer[index];\n+  }\n+\n+  final public java.nio. IntBuffer put(int index, int b)\n+  {\n+    backing_buffer[index] = b;\n+    return this;\n+  }\n+\n+  final public char getChar() { char a = nio_get_Char(this, position(), limit()); inc_pos(2); return a; } final public java.nio. IntBuffer putChar(char value) { nio_put_Char(this, position(), limit(), value); inc_pos(2); return this; } final public char getChar(int index) { char a = nio_get_Char(this, index, limit()); return a; } final public java.nio. IntBuffer putChar(int index, char value) { nio_put_Char(this, index, limit(), value); return this; };\n+  final public short getShort() { short a = nio_get_Short(this, position(), limit()); inc_pos(2); return a; } final public java.nio. IntBuffer putShort(short value) { nio_put_Short(this, position(), limit(), value); inc_pos(2); return this; } final public short getShort(int index) { short a = nio_get_Short(this, index, limit()); return a; } final public java.nio. IntBuffer putShort(int index, short value) { nio_put_Short(this, index, limit(), value); return this; };\n+  final public int getInt() { return get(); } final public java.nio. IntBuffer putInt(int value) { return put(value); } final public int getInt(int index) { return get(index); } final public java.nio. IntBuffer putInt(int index, int value) { return put(index, value); };\n+  final public long getLong() { long a = nio_get_Long(this, position(), limit()); inc_pos(8); return a; } final public java.nio. IntBuffer putLong(long value) { nio_put_Long(this, position(), limit(), value); inc_pos(8); return this; } final public long getLong(int index) { long a = nio_get_Long(this, index, limit()); return a; } final public java.nio. IntBuffer putLong(int index, long value) { nio_put_Long(this, index, limit(), value); return this; };\n+  final public float getFloat() { float a = nio_get_Float(this, position(), limit()); inc_pos(4); return a; } final public java.nio. IntBuffer putFloat(float value) { nio_put_Float(this, position(), limit(), value); inc_pos(4); return this; } final public float getFloat(int index) { float a = nio_get_Float(this, index, limit()); return a; } final public java.nio. IntBuffer putFloat(int index, float value) { nio_put_Float(this, index, limit(), value); return this; };\n+  final public double getDouble() { double a = nio_get_Double(this, position(), limit()); inc_pos(8); return a; } final public java.nio. IntBuffer putDouble(double value) { nio_put_Double(this, position(), limit(), value); inc_pos(8); return this; } final public double getDouble(int index) { double a = nio_get_Double(this, index, limit()); return a; } final public java.nio. IntBuffer putDouble(int index, double value) { nio_put_Double(this, index, limit(), value); return this; };\n+}"}, {"sha": "096481f4b8dfbcc9f017acdef2f8f6230fed8aab", "filename": "libjava/gnu/java/nio/LongBufferImpl.java", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FLongBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FLongBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FLongBufferImpl.java?ref=48f5b6723a0f7dd8e8889c2eb4deea9185863386", "patch": "@@ -0,0 +1,212 @@\n+/* LongBufferImpl.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.DoubleBuffer;\n+import java.nio.FloatBuffer;\n+import java.nio.IntBuffer;\n+import java.nio.LongBuffer;\n+import java.nio.ShortBuffer;\n+\n+public final class LongBufferImpl extends LongBuffer\n+{\n+  private int array_offset;\n+  private boolean ro;\n+\n+  public LongBufferImpl(int cap, int off, int lim)\n+  {\n+    this.backing_buffer = new long[cap];\n+    this.cap = cap ;\n+    this.position(off);\n+    this.limit(lim);\n+  }\n+\n+  public LongBufferImpl(long[] array, int off, int lim)\n+  {\n+    this.backing_buffer = array;\n+    this.cap = array.length;\n+    this.position(off);\n+    this.limit(lim);\n+  }\n+\n+  public LongBufferImpl(LongBufferImpl copy)\n+  {\n+    backing_buffer = copy.backing_buffer;\n+    ro = copy.ro;\n+    position(copy.position());\n+    limit(copy.limit());\n+  }\n+\n+  void inc_pos(int a)\n+  {\n+    position(position() + a);\n+  }\n+\n+//   private static native long[] nio_cast(byte[]copy);\n+//   private static native long[] nio_cast(char[]copy);\n+//   private static native long[] nio_cast(short[]copy);\n+//   private static native long[] nio_cast(long[]copy);\n+//   private static native long[] nio_cast(int[]copy);\n+//   private static native long[] nio_cast(float[]copy);\n+//   private static native long[] nio_cast(double[]copy);\n+\n+  private static long[] nio_cast(byte[]copy) { return null; };\n+  private static long[] nio_cast(char[]copy) { return null; };\n+  private static long[] nio_cast(short[]copy) { return null; };\n+  private static long[] nio_cast(long[]copy) { return null; };\n+  private static long[] nio_cast(int[]copy) { return null; };\n+  private static long[] nio_cast(float[]copy) { return null; };\n+  private static long[] nio_cast(double[]copy) { return null; };\n+\n+  LongBufferImpl(byte[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native byte nio_get_Byte(LongBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Byte(LongBufferImpl b, int index, int limit, byte value);\n+  private static byte nio_get_Byte(LongBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Byte(LongBufferImpl b, int index, int limit, byte value) { };\n+  public java.nio. ByteBuffer asByteBuffer() { gnu.java.nio. ByteBufferImpl res = new gnu.java.nio. ByteBufferImpl(backing_buffer); res.limit((limit()*1)/8); return res; }\n+\n+  LongBufferImpl(char[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native char nio_get_Char(LongBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Char(LongBufferImpl b, int index, int limit, char value);\n+  private static char nio_get_Char(LongBufferImpl b, int index, int limit) { return ' '; };\n+  private static void nio_put_Char(LongBufferImpl b, int index, int limit, char value) { };\n+  public java.nio. CharBuffer asCharBuffer() { gnu.java.nio. CharBufferImpl res = new gnu.java.nio. CharBufferImpl(backing_buffer); res.limit((limit()*2)/8); return res; }\n+\n+  LongBufferImpl(short[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native short nio_get_Short(LongBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Short(LongBufferImpl b, int index, int limit, short value);\n+  private static short nio_get_Short(LongBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Short(LongBufferImpl b, int index, int limit, short value) { };\n+  public java.nio. ShortBuffer asShortBuffer() { gnu.java.nio. ShortBufferImpl res = new gnu.java.nio. ShortBufferImpl(backing_buffer); res.limit((limit()*2)/8); return res; }\n+\n+  LongBufferImpl(int[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native int nio_get_Int(LongBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Int(LongBufferImpl b, int index, int limit, int value);\n+  private static int nio_get_Int(LongBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Int(LongBufferImpl b, int index, int limit, int value) { };\n+  public java.nio. IntBuffer asIntBuffer() { gnu.java.nio. IntBufferImpl res = new gnu.java.nio. IntBufferImpl(backing_buffer); res.limit((limit()*4)/8); return res; }\n+\n+  LongBufferImpl(long[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native long nio_get_Long(LongBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Long(LongBufferImpl b, int index, int limit, long value);\n+  private static long nio_get_Long(LongBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Long(LongBufferImpl b, int index, int limit, long value) { };\n+  public java.nio. LongBuffer asLongBuffer() { gnu.java.nio. LongBufferImpl res = new gnu.java.nio. LongBufferImpl(backing_buffer); res.limit((limit()*8)/8); return res; }\n+\n+  LongBufferImpl(float[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native float nio_get_Float(LongBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Float(LongBufferImpl b, int index, int limit, float value);\n+  private static float nio_get_Float(LongBufferImpl b, int index, int limit) { return 0.0f; };\n+  private static void nio_put_Float(LongBufferImpl b, int index, int limit, float value) { };\n+  public java.nio. FloatBuffer asFloatBuffer() { gnu.java.nio. FloatBufferImpl res = new gnu.java.nio. FloatBufferImpl(backing_buffer); res.limit((limit()*4)/8); return res; }\n+\n+  LongBufferImpl(double[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native double nio_get_Double(LongBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Double(LongBufferImpl b, int index, int limit, double value);\n+  private static double nio_get_Double(LongBufferImpl b, int index, int limit) { return 0.0d; };\n+  private static void nio_put_Double(LongBufferImpl b, int index, int limit, double value) { };\n+  public java.nio. DoubleBuffer asDoubleBuffer() { gnu.java.nio. DoubleBufferImpl res = new gnu.java.nio. DoubleBufferImpl(backing_buffer); res.limit((limit()*8)/8); return res; }\n+\n+  public boolean isReadOnly()\n+  {\n+    return ro;\n+  }\n+\n+  public java.nio. LongBuffer slice()\n+  {\n+    LongBufferImpl A = new LongBufferImpl(this);\n+    A.array_offset = position();\n+    return A;\n+  }\n+\n+  public java.nio. LongBuffer duplicate()\n+  {\n+    return new LongBufferImpl(this);\n+  }\n+\n+  public java.nio. LongBuffer asReadOnlyBuffer()\n+  {\n+    LongBufferImpl a = new LongBufferImpl(this);\n+    a.ro = true;\n+    return a;\n+  }\n+\n+  public java.nio. LongBuffer compact()\n+  {\n+    return this;\n+  }\n+\n+  public boolean isDirect()\n+  {\n+    return backing_buffer != null;\n+  }\n+\n+  final public long get()\n+  {\n+    long e = backing_buffer[position()];\n+    position(position()+1);\n+    return e;\n+  }\n+\n+  final public java.nio. LongBuffer put(long b)\n+  {\n+    backing_buffer[position()] = b;\n+    position(position()+1);\n+    return this;\n+  }\n+\n+  final public long get(int index)\n+  {\n+    return backing_buffer[index];\n+  }\n+\n+  final public java.nio. LongBuffer put(int index, long b)\n+  {\n+    backing_buffer[index] = b;\n+    return this;\n+  }\n+\n+  final public char getChar() { char a = nio_get_Char(this, position(), limit()); inc_pos(2); return a; } final public java.nio. LongBuffer putChar(char value) { nio_put_Char(this, position(), limit(), value); inc_pos(2); return this; } final public char getChar(int index) { char a = nio_get_Char(this, index, limit()); return a; } final public java.nio. LongBuffer putChar(int index, char value) { nio_put_Char(this, index, limit(), value); return this; };\n+  final public short getShort() { short a = nio_get_Short(this, position(), limit()); inc_pos(2); return a; } final public java.nio. LongBuffer putShort(short value) { nio_put_Short(this, position(), limit(), value); inc_pos(2); return this; } final public short getShort(int index) { short a = nio_get_Short(this, index, limit()); return a; } final public java.nio. LongBuffer putShort(int index, short value) { nio_put_Short(this, index, limit(), value); return this; };\n+  final public int getInt() { int a = nio_get_Int(this, position(), limit()); inc_pos(4); return a; } final public java.nio. LongBuffer putInt(int value) { nio_put_Int(this, position(), limit(), value); inc_pos(4); return this; } final public int getInt(int index) { int a = nio_get_Int(this, index, limit()); return a; } final public java.nio. LongBuffer putInt(int index, int value) { nio_put_Int(this, index, limit(), value); return this; };\n+  final public long getLong() { return get(); } final public java.nio. LongBuffer putLong(long value) { return put(value); } final public long getLong(int index) { return get(index); } final public java.nio. LongBuffer putLong(int index, long value) { return put(index, value); };\n+  final public float getFloat() { float a = nio_get_Float(this, position(), limit()); inc_pos(4); return a; } final public java.nio. LongBuffer putFloat(float value) { nio_put_Float(this, position(), limit(), value); inc_pos(4); return this; } final public float getFloat(int index) { float a = nio_get_Float(this, index, limit()); return a; } final public java.nio. LongBuffer putFloat(int index, float value) { nio_put_Float(this, index, limit(), value); return this; };\n+  final public double getDouble() { double a = nio_get_Double(this, position(), limit()); inc_pos(8); return a; } final public java.nio. LongBuffer putDouble(double value) { nio_put_Double(this, position(), limit(), value); inc_pos(8); return this; } final public double getDouble(int index) { double a = nio_get_Double(this, index, limit()); return a; } final public java.nio. LongBuffer putDouble(int index, double value) { nio_put_Double(this, index, limit(), value); return this; };\n+}"}, {"sha": "77341e7f4a08077de5ff2f98fe5fee99f3966918", "filename": "libjava/gnu/java/nio/PipeImpl.java", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FPipeImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FPipeImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FPipeImpl.java?ref=48f5b6723a0f7dd8e8889c2eb4deea9185863386", "patch": "@@ -0,0 +1,57 @@\n+/* PipeImpl.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio;\n+\n+import java.nio.channels.Pipe;\n+\n+class PipeImpl extends Pipe\n+{\n+  public PipeImpl()\n+  {\n+  }\n+    \n+  public Pipe.SinkChannel sink()\n+  {\n+    return null;\n+  }\n+\n+  public Pipe.SourceChannel source()\n+  {\n+    return null;\n+  }\n+}"}, {"sha": "8ef6f7f27cb82bbb90935326d26933f530419693", "filename": "libjava/gnu/java/nio/SelectionKeyImpl.java", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FSelectionKeyImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FSelectionKeyImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FSelectionKeyImpl.java?ref=48f5b6723a0f7dd8e8889c2eb4deea9185863386", "patch": "@@ -0,0 +1,83 @@\n+/* SelectionKeyImpl.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio;\n+\n+import java.nio.channels.SelectableChannel;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.spi.AbstractSelectionKey;\n+\n+public class SelectionKeyImpl extends AbstractSelectionKey\n+{\n+  int fd, ops;\n+  SelectorImpl impl;\n+  SelectableChannel ch;\n+\n+  public SelectionKeyImpl(SelectableChannel ch, SelectorImpl impl, int fd)\n+  {\n+    this.ch  = ch;\n+    this.impl = impl;\n+    this.fd  = fd;\n+  }\n+\n+  public SelectableChannel channel ()\n+  {\n+    return ch;\n+  }\n+\n+  public int readyOps ()\n+  {\n+    return 0;\n+  }\n+\n+  public int interestOps ()\n+  {\n+    return ops;    \n+  }\n+\n+  public SelectionKey interestOps (int ops)\n+  {\n+    this.ops = ops;\n+    return this;\n+  }\n+    \n+  public Selector selector ()\n+  {\n+    return impl;\n+  }\n+}"}, {"sha": "7d3d88c75f45387350d7c18e36183d6fe38597a3", "filename": "libjava/gnu/java/nio/SelectorImpl.java", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FSelectorImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FSelectorImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FSelectorImpl.java?ref=48f5b6723a0f7dd8e8889c2eb4deea9185863386", "patch": "@@ -0,0 +1,204 @@\n+/* SelectorImpl.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio;\n+\n+import java.nio.channels.ClosedSelectorException;\n+import java.nio.channels.SelectableChannel;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.spi.AbstractSelectableChannel;\n+import java.nio.channels.spi.AbstractSelector;\n+import java.nio.channels.spi.SelectorProvider;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+public class SelectorImpl extends AbstractSelector\n+{\n+  boolean closed = false;\n+  Set keys, selected, canceled;\n+\n+  public SelectorImpl (SelectorProvider provider)\n+  {\n+    super (provider);\n+  }\n+\n+  public Set keys ()\n+  {\n+    return keys;\n+  }\n+    \n+  public int selectNow ()\n+  {\n+    return select (1);\n+  }\n+\n+  public int select ()\n+  {\n+    return select (Long.MAX_VALUE);\n+  }\n+\n+//   private static native int java_do_select(int[] read, int[] write,\n+//                                            int[] except, long timeout);\n+\n+  private static int java_do_select(int[] read, int[] write,\n+                                    int[] except, long timeout)\n+  {\n+    return 0;\n+  }\n+\n+  public int select (long timeout)\n+  {\n+    if (closed)\n+      {\n+        throw new ClosedSelectorException ();\n+      }\n+\n+    if (keys == null)\n+\t    {\n+        return 0;\n+\t    }\n+\n+    int[] read = new int[keys.size ()];\n+    int[] write = new int[keys.size ()];\n+    int[] except = new int[keys.size ()];\n+    int i = 0;\n+    Iterator it = keys.iterator ();\n+\n+    while (it.hasNext ())\n+\t    {\n+        SelectionKeyImpl k = (SelectionKeyImpl) it.next ();\n+        read[i] = k.fd;\n+        write[i] = k.fd;\n+        except[i] = k.fd;\n+        i++;\n+\t    }\n+\n+    int ret = java_do_select (read, write, except, timeout);\n+\n+    i = 0;\n+    it = keys.iterator ();\n+\n+    while (it.hasNext ())\n+\t    {\n+        SelectionKeyImpl k = (SelectionKeyImpl) it.next ();\n+\n+        if (read[i] != -1 ||\n+            write[i] != -1 ||\n+            except[i] != -1)\n+          {\n+            add_selected (k);\n+          }\n+\n+        i++;\n+\t    }\n+\n+    return ret;\n+  }\n+    \n+  public Set selectedKeys ()\n+  {\n+    return selected;\n+  }\n+\n+  public Selector wakeup ()\n+  {\n+    return null;\n+  }\n+\n+  public void add (SelectionKeyImpl k)\n+  {\n+    if (keys == null)\n+\t    keys = new HashSet ();\n+\n+    keys.add (k);\n+  }\n+\n+  void add_selected (SelectionKeyImpl k)\n+  {\n+    if (selected == null)\n+\t    selected = new HashSet ();\n+\n+    selected.add(k);\n+  }\n+\n+  protected void implCloseSelector ()\n+  {\n+    closed = true;\n+  }\n+    \n+  protected SelectionKey register (SelectableChannel ch, int ops, Object att)\n+  {\n+    return register ((AbstractSelectableChannel) ch, ops, att);\n+  }\n+\n+  protected SelectionKey register (AbstractSelectableChannel ch, int ops,\n+                                   Object att)\n+  {\n+// \t  // filechannel is not selectable ?\n+//     if (ch instanceof FileChannelImpl)\n+//       {\n+//         FileChannelImpl fc = (FileChannelImpl) ch;\n+//         SelectionKeyImpl impl = new SelectionKeyImpl (ch, this, fc.fd);\n+//         keys.add (impl);\n+//         return impl;\n+//       }\n+//     else\n+\t\n+    if (ch instanceof SocketChannelImpl)\n+\t    {\n+        SocketChannelImpl sc = (SocketChannelImpl) ch;\n+        SelectionKeyImpl impl = new SelectionKeyImpl (ch, this, sc.fd);\n+        add (impl);\n+        return impl;\n+\t    }\n+    else if (ch instanceof ServerSocketChannelImpl)\n+      {\n+        ServerSocketChannelImpl ssc = (ServerSocketChannelImpl) ch;\n+        SelectionKeyImpl impl = new SelectionKeyImpl (ch, this, ssc.fd);\n+        add (impl);\n+        return impl;\n+      }\n+    else\n+\t    {\n+        System.err.println (\"INTERNAL ERROR, no known channel type\");\n+\t    }\n+\n+    return null;\n+  }\n+}"}, {"sha": "3fedfc735469904f32465dc55c13cd50690057d5", "filename": "libjava/gnu/java/nio/SelectorProviderImpl.java", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FSelectorProviderImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FSelectorProviderImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FSelectorProviderImpl.java?ref=48f5b6723a0f7dd8e8889c2eb4deea9185863386", "patch": "@@ -0,0 +1,77 @@\n+/* SelectorProviderImpl.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio;\n+\n+import java.nio.channels.DatagramChannel;\n+import java.nio.channels.Pipe;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.channels.spi.SelectorProvider;\n+import java.nio.channels.spi.AbstractSelector;\n+\n+public class SelectorProviderImpl extends SelectorProvider\n+{\n+  public SelectorProviderImpl ()\n+  {\n+  }\n+\n+  public DatagramChannel openDatagramChannel ()\n+  {\n+    return new DatagramChannelImpl (this);\n+  }\n+\n+  public Pipe openPipe ()\n+  {\n+    return new PipeImpl ();\n+  }\n+    \n+  public AbstractSelector openSelector ()\n+  {\n+    return new SelectorImpl (this);\n+  }\n+\n+  public ServerSocketChannel openServerSocketChannel ()\n+  {\n+    return new ServerSocketChannelImpl (this);\n+  }\n+\n+  public SocketChannel openSocketChannel ()\n+  {\n+    return new SocketChannelImpl (this);\n+  }\n+}"}, {"sha": "e75c68d81668083b538601faf0f43d8163171f40", "filename": "libjava/gnu/java/nio/ServerSocketChannelImpl.java", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FServerSocketChannelImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FServerSocketChannelImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FServerSocketChannelImpl.java?ref=48f5b6723a0f7dd8e8889c2eb4deea9185863386", "patch": "@@ -0,0 +1,118 @@\n+/* ServerSocketChannelImpl.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.SocketAddress;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.channels.spi.SelectorProvider;\n+\n+class ServerSocketChannelImpl extends ServerSocketChannel\n+{\n+  ServerSocket sock_object;\n+  int fd;\n+//   int local_port;\n+  boolean blocking = true;\n+  boolean connected = false;\n+//   InetSocketAddress sa;\n+\n+//   private static native int NioSocketAccept (ServerSocketChannelImpl server, \n+//                                              SocketChannelImpl s);\n+\n+  private static int NioSocketAccept (ServerSocketChannelImpl server, \n+                                      SocketChannelImpl s)\n+  {\n+    return 0;\n+  }\n+\n+  protected ServerSocketChannelImpl (SelectorProvider provider)\n+  {\n+    super (provider);\n+    fd = SocketChannelImpl.SocketCreate ();\n+\n+    try\n+      {\n+        sock_object = new ServerSocket ();\n+      }\n+    catch (IOException e)\n+      {\n+        System.err.println (\"ServerSocket could not be created.\");\n+      }\n+  }\n+ \n+  public void finalizer()\n+  {\n+    if (connected)\n+\t    {\n+        try\n+          {\n+            close();\n+          }\n+        catch (Exception e)\n+          {\n+          }\n+\t    }\n+  }\n+\n+  protected void implCloseSelectableChannel ()\n+  {\n+    connected = false;\n+    SocketChannelImpl.SocketClose (fd);\n+    fd = SocketChannelImpl.SocketCreate ();\n+  }\n+\n+  protected void implConfigureBlocking (boolean block)\n+  {\n+  }\n+\n+  public SocketChannel accept ()\n+  {\n+    SocketChannelImpl result = new SocketChannelImpl (provider ());\n+    result.sa = new InetSocketAddress (0);\n+    int res = NioSocketAccept (this, result);\n+    return result;\n+  }\n+\n+  public ServerSocket socket ()\n+  {\n+    return sock_object;\n+  }\n+}"}, {"sha": "15a0cd667f3d5aab6daf6a727b3592f1fc690556", "filename": "libjava/gnu/java/nio/ShortBufferImpl.java", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FShortBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FShortBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FShortBufferImpl.java?ref=48f5b6723a0f7dd8e8889c2eb4deea9185863386", "patch": "@@ -0,0 +1,212 @@\n+/* ShortBufferImpl.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.DoubleBuffer;\n+import java.nio.FloatBuffer;\n+import java.nio.IntBuffer;\n+import java.nio.LongBuffer;\n+import java.nio.ShortBuffer;\n+\n+public final class ShortBufferImpl extends ShortBuffer\n+{\n+  private int array_offset;\n+  private boolean ro;\n+\n+  public ShortBufferImpl(int cap, int off, int lim)\n+  {\n+    this.backing_buffer = new short[cap];\n+    this.cap = cap ;\n+    this.position(off);\n+    this.limit(lim);\n+  }\n+\n+  public ShortBufferImpl(short[] array, int off, int lim)\n+  {\n+    this.backing_buffer = array;\n+    this.cap = array.length;\n+    this.position(off);\n+    this.limit(lim);\n+  }\n+\n+  public ShortBufferImpl(ShortBufferImpl copy)\n+  {\n+    backing_buffer = copy.backing_buffer;\n+    ro = copy.ro;\n+    position(copy.position());\n+    limit(copy.limit());\n+  }\n+\n+  void inc_pos(int a)\n+  {\n+    position(position() + a);\n+  }\n+\n+//   private static native short[] nio_cast(byte[]copy);\n+//   private static native short[] nio_cast(char[]copy);\n+//   private static native short[] nio_cast(short[]copy);\n+//   private static native short[] nio_cast(long[]copy);\n+//   private static native short[] nio_cast(int[]copy);\n+//   private static native short[] nio_cast(float[]copy);\n+//   private static native short[] nio_cast(double[]copy);\n+\n+  private static short[] nio_cast(byte[]copy) { return null; };\n+  private static short[] nio_cast(char[]copy) { return null; };\n+  private static short[] nio_cast(short[]copy) { return null; };\n+  private static short[] nio_cast(long[]copy) { return null; };\n+  private static short[] nio_cast(int[]copy) { return null; };\n+  private static short[] nio_cast(float[]copy) { return null; };\n+  private static short[] nio_cast(double[]copy) { return null; };\n+\n+  ShortBufferImpl(byte[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native byte nio_get_Byte(ShortBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Byte(ShortBufferImpl b, int index, int limit, byte value);\n+  private static byte nio_get_Byte(ShortBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Byte(ShortBufferImpl b, int index, int limit, byte value) { };\n+  public java.nio. ByteBuffer asByteBuffer() { gnu.java.nio. ByteBufferImpl res = new gnu.java.nio. ByteBufferImpl(backing_buffer); res.limit((limit()*1)/2); return res; }\n+\n+  ShortBufferImpl(char[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native char nio_get_Char(ShortBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Char(ShortBufferImpl b, int index, int limit, char value);\n+  private static char nio_get_Char(ShortBufferImpl b, int index, int limit) { return ' '; };\n+  private static void nio_put_Char(ShortBufferImpl b, int index, int limit, char value) { };\n+  public java.nio. CharBuffer asCharBuffer() { gnu.java.nio. CharBufferImpl res = new gnu.java.nio. CharBufferImpl(backing_buffer); res.limit((limit()*2)/2); return res; }\n+\n+  ShortBufferImpl(short[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native short nio_get_Short(ShortBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Short(ShortBufferImpl b, int index, int limit, short value);\n+  private static short nio_get_Short(ShortBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Short(ShortBufferImpl b, int index, int limit, short value) { };\n+  public java.nio. ShortBuffer asShortBuffer() { gnu.java.nio. ShortBufferImpl res = new gnu.java.nio. ShortBufferImpl(backing_buffer); res.limit((limit()*2)/2); return res; }\n+\n+  ShortBufferImpl(int[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native int nio_get_Int(ShortBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Int(ShortBufferImpl b, int index, int limit, int value);\n+  private static int nio_get_Int(ShortBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Int(ShortBufferImpl b, int index, int limit, int value) { };\n+  public java.nio. IntBuffer asIntBuffer() { gnu.java.nio. IntBufferImpl res = new gnu.java.nio. IntBufferImpl(backing_buffer); res.limit((limit()*4)/2); return res; }\n+\n+  ShortBufferImpl(long[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native long nio_get_Long(ShortBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Long(ShortBufferImpl b, int index, int limit, long value);\n+  private static long nio_get_Long(ShortBufferImpl b, int index, int limit) { return 0; };\n+  private static void nio_put_Long(ShortBufferImpl b, int index, int limit, long value) { };\n+  public java.nio. LongBuffer asLongBuffer() { gnu.java.nio. LongBufferImpl res = new gnu.java.nio. LongBufferImpl(backing_buffer); res.limit((limit()*8)/2); return res; }\n+\n+  ShortBufferImpl(float[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native float nio_get_Float(ShortBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Float(ShortBufferImpl b, int index, int limit, float value);\n+  private static float nio_get_Float(ShortBufferImpl b, int index, int limit) { return 0.0f; };\n+  private static void nio_put_Float(ShortBufferImpl b, int index, int limit, float value) { };\n+  public java.nio. FloatBuffer asFloatBuffer() { gnu.java.nio. FloatBufferImpl res = new gnu.java.nio. FloatBufferImpl(backing_buffer); res.limit((limit()*4)/2); return res; }\n+\n+  ShortBufferImpl(double[] copy) { this.backing_buffer = copy != null ? nio_cast(copy) : null; }\n+//   private static native double nio_get_Double(ShortBufferImpl b, int index, int limit);\n+//   private static native void nio_put_Double(ShortBufferImpl b, int index, int limit, double value);\n+  private static double nio_get_Double(ShortBufferImpl b, int index, int limit) { return 0.0d; };\n+  private static void nio_put_Double(ShortBufferImpl b, int index, int limit, double value) { };\n+  public java.nio. DoubleBuffer asDoubleBuffer() { gnu.java.nio. DoubleBufferImpl res = new gnu.java.nio. DoubleBufferImpl(backing_buffer); res.limit((limit()*8)/2); return res; }\n+\n+  public boolean isReadOnly()\n+  {\n+    return ro;\n+  }\n+\n+  public ShortBuffer slice()\n+  {\n+    ShortBufferImpl a = new ShortBufferImpl(this);\n+    a.array_offset = position();\n+    return a;\n+  }\n+\n+  public ShortBuffer duplicate()\n+  {\n+    return new ShortBufferImpl(this);\n+  }\n+\n+  public ShortBuffer asReadOnlyBuffer()\n+  {\n+    ShortBufferImpl a = new ShortBufferImpl(this);\n+    a.ro = true;\n+    return a;\n+  }\n+\n+  public ShortBuffer compact()\n+  {\n+    return this;\n+  }\n+\n+  public boolean isDirect()\n+  {\n+    return backing_buffer != null;\n+  }\n+\n+  final public short get()\n+  {\n+    short e = backing_buffer[position()];\n+    position(position()+1);\n+    return e;\n+  }\n+\n+  final public ShortBuffer put(short b)\n+  {\n+    backing_buffer[position()] = b;\n+    position(position()+1);\n+    return this;\n+  }\n+\n+  final public short get(int index)\n+  {\n+    return backing_buffer[index];\n+  }\n+\n+  final public ShortBuffer put(int index, short b)\n+  {\n+    backing_buffer[index] = b;\n+    return this;\n+  }\n+\n+  final public char getChar() { char a = nio_get_Char(this, position(), limit()); inc_pos(2); return a; } final public java.nio. ShortBuffer putChar(char value) { nio_put_Char(this, position(), limit(), value); inc_pos(2); return this; } final public char getChar(int index) { char a = nio_get_Char(this, index, limit()); return a; } final public java.nio. ShortBuffer putChar(int index, char value) { nio_put_Char(this, index, limit(), value); return this; };\n+  final public short getShort() { return get(); } final public java.nio. ShortBuffer putShort(short value) { return put(value); } final public short getShort(int index) { return get(index); } final public java.nio. ShortBuffer putShort(int index, short value) { return put(index, value); };\n+  final public int getInt() { int a = nio_get_Int(this, position(), limit()); inc_pos(4); return a; } final public java.nio. ShortBuffer putInt(int value) { nio_put_Int(this, position(), limit(), value); inc_pos(4); return this; } final public int getInt(int index) { int a = nio_get_Int(this, index, limit()); return a; } final public java.nio. ShortBuffer putInt(int index, int value) { nio_put_Int(this, index, limit(), value); return this; };\n+  final public long getLong() { long a = nio_get_Long(this, position(), limit()); inc_pos(8); return a; } final public java.nio. ShortBuffer putLong(long value) { nio_put_Long(this, position(), limit(), value); inc_pos(8); return this; } final public long getLong(int index) { long a = nio_get_Long(this, index, limit()); return a; } final public java.nio. ShortBuffer putLong(int index, long value) { nio_put_Long(this, index, limit(), value); return this; };\n+  final public float getFloat() { float a = nio_get_Float(this, position(), limit()); inc_pos(4); return a; } final public java.nio. ShortBuffer putFloat(float value) { nio_put_Float(this, position(), limit(), value); inc_pos(4); return this; } final public float getFloat(int index) { float a = nio_get_Float(this, index, limit()); return a; } final public java.nio. ShortBuffer putFloat(int index, float value) { nio_put_Float(this, index, limit(), value); return this; };\n+  final public double getDouble() { double a = nio_get_Double(this, position(), limit()); inc_pos(8); return a; } final public java.nio. ShortBuffer putDouble(double value) { nio_put_Double(this, position(), limit(), value); inc_pos(8); return this; } final public double getDouble(int index) { double a = nio_get_Double(this, index, limit()); return a; } final public java.nio. ShortBuffer putDouble(int index, double value) { nio_put_Double(this, index, limit(), value); return this; };\n+}"}, {"sha": "b43108ba4739e5736187bcdb60d922b35a739be1", "filename": "libjava/gnu/java/nio/SocketChannelImpl.java", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FSocketChannelImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fgnu%2Fjava%2Fnio%2FSocketChannelImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FSocketChannelImpl.java?ref=48f5b6723a0f7dd8e8889c2eb4deea9185863386", "patch": "@@ -0,0 +1,234 @@\n+/* SocketChannelImpl.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.nio;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.AlreadyConnectedException;\n+import java.nio.channels.SocketChannel;\n+import java.nio.channels.spi.SelectorProvider;\n+import gnu.classpath.Configuration;\n+\n+public class SocketChannelImpl extends SocketChannel\n+{\n+  Socket sock_object;\n+  int fd;\n+  int local_port;\n+  boolean blocking = true;\n+  boolean connected = false;\n+  InetSocketAddress sa;\n+\n+/*    \n+  static native int SocketCreate();\n+  static native int SocketConnect(int fd, InetAddress a, int port);\n+  static native int SocketBind(int fd, InetAddress host, int port);\n+  static native int SocketListen(int fd, int backlog);\n+  static native int SocketAvailable(int fd);\n+  static native int SocketClose(int fd);\n+  static native int SocketRead(int fd, byte b[], int off, int len);\n+  static native int SocketWrite(int fd, byte b[], int off, int len);\n+*/\n+\n+  static int SocketCreate() { return 0; };\n+  static int SocketConnect(int fd, InetAddress a, int port) { return 0; };\n+  static int SocketBind(int fd, InetAddress host, int port) { return 0; };\n+  static int SocketListen(int fd, int backlog) { return 0; };\n+  static int SocketAvailable(int fd) { return 0; };\n+  static int SocketClose(int fd) { return 0; };\n+  static int SocketRead(int fd, byte b[], int off, int len) { return 0; };\n+  static int SocketWrite(int fd, byte b[], int off, int len) { return 0; };\n+\n+  public SocketChannelImpl(SelectorProvider provider)\t\t      \n+  {\n+    super(provider);\n+    fd = SocketCreate();\n+\t\n+    if (fd == -1)\n+\t    {\n+        System.err.println(\"failed to create socket:\"+fd);\n+\t    }\n+  }\n+    \n+  public void finalizer()\n+  {\n+    if (connected)\n+\t    {\n+        try\n+          {\n+            close();\n+          }\n+        catch (Exception e)\n+          {\n+          }\n+\t    }\n+  }\n+\n+  protected void implCloseSelectableChannel()\n+  {\n+    connected = false;\n+    SocketClose(fd);\n+    fd = SocketCreate();\n+  }\n+\n+  protected void implConfigureBlocking(boolean  block)\n+  {\n+    if (blocking == block)\n+\t    return;\n+  }   \n+\n+  public boolean connect(SocketAddress remote)\n+    throws IOException\n+  {\n+    if (connected)\n+\t    {\n+        throw new AlreadyConnectedException();\n+\t    }\n+\n+    // ok, lets connect !\n+\t\n+    sa = (InetSocketAddress) remote;\n+\t\n+    InetAddress addr = sa.getAddress();\n+    int port = sa.getPort();\n+    int err = SocketConnect(fd, addr, port);\n+\t\n+    if (err < 0) \n+\t    {\n+        throw new IOException(\"Connection refused:\"+err + \", connect=\"+err);\n+\t    }\n+\n+    local_port = err;\n+    connected = true;\n+    return blocking;\n+  }\n+    \n+  public boolean finishConnect()\n+  {\n+    return false;\n+  }\n+\n+  public boolean isConnected()\n+  {\n+    return connected;\n+  }\n+    \n+  public boolean isConnectionPending()\n+  {\n+    if (blocking)\n+\t    return true;\n+\n+    return false;\n+  }\n+    \n+  public Socket socket()\n+  {\n+    if (sock_object != null)\n+\t    {\n+        //sock_object.ch = this;\n+\t    }\n+\n+    return sock_object;\n+  }\n+\n+  public int read(ByteBuffer dst)\n+  {\n+    int bytes = 0;\n+    int len = 1024;\n+    byte[]b = new byte[len];\n+\t\n+    bytes = SocketRead(fd, b, 0, len);\n+    dst.put(b, 0, bytes);\n+\n+    if (bytes == 0)\n+\t    {\n+        // we've hit eof ?\n+        return -1;\n+\t    }\n+\n+    return bytes;\n+  }\n+    \n+  public long read(ByteBuffer[] dsts, int offset, int length)\n+  {\n+    long bytes = 0;\n+\n+    for (int i=offset; i<length; i++)\n+\t    {\n+        bytes += read(dsts[i]);\n+\t    }\n+\n+    return bytes;\n+  }\n+     \n+  public int write(ByteBuffer src)\n+  {\n+    int bytes = 0;\n+    int len = src.position();\n+\n+    if (src instanceof ByteBufferImpl)\n+\t    {\n+        ByteBufferImpl bi = (ByteBufferImpl) src;\n+        byte[]b = bi.array();\n+        bytes = SocketWrite(fd, b, 0, len);\n+\t    }\n+    else\n+\t    {\n+        byte[]b = new byte[len];\n+        src.get(b, 0, len);\n+        bytes = SocketWrite(fd, b, 0, len);\n+\t    }\n+\t\t\n+\t  return bytes;\n+  }\n+\n+  public long write (ByteBuffer[] srcs, int offset, int length)\n+  {\n+    long bytes = 0;\n+\n+    for (int i=offset; i<length; i++)\n+\t    {\n+        bytes += write(srcs[i]);\n+\t    }\n+\n+    return bytes;\n+  }\n+}"}, {"sha": "7059b6e243060aa639dbcd6c64e3cff1751b856f", "filename": "libjava/java/nio/DoubleBuffer.java", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fjava%2Fnio%2FDoubleBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fjava%2Fnio%2FDoubleBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FDoubleBuffer.java?ref=48f5b6723a0f7dd8e8889c2eb4deea9185863386", "patch": "@@ -0,0 +1,225 @@\n+/* DoubleBuffer.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.nio;\n+\n+import gnu.java.nio.DoubleBufferImpl;\n+\n+public abstract class DoubleBuffer extends Buffer\n+{\n+  private ByteOrder endian = ByteOrder.BIG_ENDIAN;\n+  protected double [] backing_buffer;\n+\n+  public static DoubleBuffer allocateDirect(int capacity)\n+  {\n+    return new DoubleBufferImpl(capacity, 0, capacity);\n+  }\n+\n+  public static DoubleBuffer allocate(int capacity)\n+  {\n+    return new DoubleBufferImpl(capacity, 0, capacity);\n+  }\n+\n+  final public static DoubleBuffer wrap (double[] array, int offset, int length)\n+  {\n+    return new DoubleBufferImpl(array, offset, length);\n+  }\n+\n+  final public static DoubleBuffer wrap(String a)\n+  {\n+    int len = a.length();\n+    double[] buffer = new double[len];\n+\n+    for (int i=0;i<len;i++)\n+      {\n+        buffer[i] = (double) a.charAt(i);\n+      }\n+\n+    return wrap(buffer, 0, len);\n+  }\n+\n+  final public static DoubleBuffer wrap(double[] array)\n+  {\n+    return wrap(array, 0, array.length);\n+  }\n+\n+  final public DoubleBuffer get (double[] dst, int offset, int length)\n+  {\n+    for (int i = offset; i < offset + length; i++)\n+      {\n+        dst[i] = get();\n+      }\n+\n+    return this;\n+  }\n+\n+  final public DoubleBuffer get(double[] dst)\n+  {\n+    return get(dst, 0, dst.length);\n+  }\n+\n+  final public DoubleBuffer put(DoubleBuffer src)\n+  {\n+    while (src.hasRemaining())\n+      put(src.get());\n+\n+    return this;\n+  }\n+\n+  final public DoubleBuffer put (double[] src, int offset, int length)\n+  {\n+    for (int i = offset; i < offset + length; i++)\n+      put(src[i]);\n+\n+    return this;\n+  }\n+\n+  public final DoubleBuffer put(double[] src)\n+  {\n+    return put(src, 0, src.length);\n+  }\n+\n+  public final boolean hasArray()\n+  {\n+    return (backing_buffer != null);\n+  }\n+\n+  public final double[] array()\n+  {\n+    return backing_buffer;\n+  }\n+\n+  public final int arrayOffset()\n+  {\n+    return 0;\n+  }\n+\n+  public int hashCode()\n+  {\n+    return super.hashCode();\n+  }\n+\n+  public boolean equals(Object obj)\n+  {\n+    if (obj instanceof DoubleBuffer)\n+      {\n+        return compareTo(obj) == 0;\n+      }\n+\n+    return false;\n+  }\n+\n+  public int compareTo(Object ob)\n+  {\n+    DoubleBuffer a = (DoubleBuffer) ob;\n+\n+    if (a.remaining() != remaining())\n+      return 1;\n+\n+    if (! hasArray() ||\n+        ! a.hasArray())\n+      {\n+        return 1;\n+      }\n+\n+    int r = remaining();\n+    int i1 = position ();\n+    int i2 = a.position ();\n+\n+    for (int i=0;i<r;i++)\n+      {\n+        int t = (int) (get(i1)- a.get(i2));\n+        if (t != 0)\n+          {\n+            return (int) t;\n+          }\n+      }\n+\n+    return 0;\n+  }\n+\n+  public final ByteOrder order()\n+  {\n+    return endian;\n+  }\n+\n+  public final DoubleBuffer order(ByteOrder bo)\n+  {\n+    endian = bo;\n+    return this;\n+  }\n+\n+  public abstract double get();\n+  public abstract DoubleBuffer put (double b);\n+  public abstract double get(int index);\n+  public abstract DoubleBuffer put(int index, double b);\n+  public abstract DoubleBuffer compact();\n+  public abstract boolean isDirect();\n+  public abstract DoubleBuffer slice();\n+  public abstract DoubleBuffer duplicate();\n+  public abstract DoubleBuffer asReadOnlyBuffer();\n+  public abstract ShortBuffer asShortBuffer();\n+  public abstract CharBuffer asCharBuffer();\n+  public abstract IntBuffer asIntBuffer();\n+  public abstract LongBuffer asLongBuffer();\n+  public abstract FloatBuffer asFloatBuffer();\n+  public abstract DoubleBuffer asDoubleBuffer();\n+  public abstract char getChar();\n+  public abstract DoubleBuffer putChar(char value);\n+  public abstract char getChar(int index);\n+  public abstract DoubleBuffer putChar(int index, char value);\n+  public abstract short getShort();\n+  public abstract DoubleBuffer putShort(short value);\n+  public abstract short getShort(int index);\n+  public abstract DoubleBuffer putShort(int index, short value);\n+  public abstract int getInt();\n+  public abstract DoubleBuffer putInt(int value);\n+  public abstract int getInt(int index);\n+  public abstract DoubleBuffer putInt(int index, int value);\n+  public abstract long getLong();\n+  public abstract DoubleBuffer putLong(long value);\n+  public abstract long getLong(int index);\n+  public abstract DoubleBuffer putLong(int index, long value);\n+  public abstract float getFloat();\n+  public abstract DoubleBuffer putFloat(float value);\n+  public abstract float getFloat(int index);\n+  public abstract DoubleBuffer putFloat(int index, float value);\n+  public abstract double getDouble();\n+  public abstract DoubleBuffer putDouble(double value);\n+  public abstract double getDouble(int index);\n+  public abstract DoubleBuffer putDouble(int index, double value);\n+}"}, {"sha": "f06ef1877919f64478eab0b89d53642fc966d043", "filename": "libjava/java/nio/FloatBuffer.java", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fjava%2Fnio%2FFloatBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fjava%2Fnio%2FFloatBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FFloatBuffer.java?ref=48f5b6723a0f7dd8e8889c2eb4deea9185863386", "patch": "@@ -0,0 +1,224 @@\n+/* FloatBuffer.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.nio;\n+\n+import gnu.java.nio.FloatBufferImpl;\n+\n+public abstract class FloatBuffer extends Buffer\n+{\n+  private ByteOrder endian = ByteOrder.BIG_ENDIAN;\n+  protected float [] backing_buffer;\n+\n+  public static FloatBuffer allocateDirect(int capacity)\n+  {\n+    return new FloatBufferImpl (capacity, 0, capacity);\n+  }\n+\n+  public static FloatBuffer allocate(int capacity)\n+  {\n+    return new FloatBufferImpl (capacity, 0, capacity);\n+  }\n+\n+  final public static FloatBuffer wrap(float[] array, int offset, int length)\n+  {\n+    return new FloatBufferImpl(array, offset, length);\n+  }\n+\n+  final public static FloatBuffer wrap(String a)\n+  {\n+    int len = a.length();\n+    float[] buffer = new float[len];\n+\n+    for (int i=0;i<len;i++)\n+      {\n+        buffer[i] = (float) a.charAt(i);\n+      }\n+\n+    return wrap(buffer, 0, len);\n+  }\n+\n+  final public static FloatBuffer wrap(float[] array)\n+  {\n+    return wrap(array, 0, array.length);\n+  }\n+\n+  final public FloatBuffer get(float[] dst, int offset, int length)\n+  {\n+    for (int i = offset; i < offset + length; i++)\n+      {\n+        dst[i] = get();\n+      }\n+\n+    return this;\n+  }\n+\n+  final public FloatBuffer get(float[] dst)\n+  {\n+    return get(dst, 0, dst.length);\n+  }\n+\n+  final public FloatBuffer put(FloatBuffer src)\n+  {\n+    while (src.hasRemaining())\n+      put(src.get());\n+\n+    return this;\n+  }\n+\n+  final public FloatBuffer put(float[] src, int offset, int length)\n+  {\n+    for (int i = offset; i < offset + length; i++)\n+      put(src[i]);\n+\n+    return this;\n+  }\n+\n+  public final FloatBuffer put(float[] src)\n+  {\n+    return put(src, 0, src.length);\n+  }\n+\n+  public final boolean hasArray()\n+  {\n+    return (backing_buffer != null);\n+  }\n+\n+  public final float[] array()\n+  {\n+    return backing_buffer;\n+  }\n+\n+  public final int arrayOffset()\n+  {\n+    return 0;\n+  }\n+\n+  public int hashCode()\n+  {\n+    return super.hashCode();\n+  }\n+\n+  public boolean equals(Object obj)\n+  {\n+    if (obj instanceof FloatBuffer)\n+      {\n+        return compareTo(obj) == 0;\n+      }\n+    return false;\n+  }\n+\n+  public int compareTo(Object ob)\n+  {\n+    FloatBuffer a = (FloatBuffer) ob;\n+\n+    if (a.remaining() != remaining())\n+      return 1;\n+\n+    if (! hasArray() ||\n+        ! a.hasArray())\n+      {\n+        return 1;\n+      }\n+\n+    int r = remaining();\n+    int i1 = position ();\n+    int i2 = a.position ();\n+\n+    for (int i=0;i<r;i++)\n+      {\n+        int t = (int) (get(i1)- a.get(i2));\n+        if (t != 0)\n+          {\n+            return (int) t;\n+          }\n+      }\n+\n+    return 0;\n+  }\n+\n+  public final ByteOrder order()\n+  {\n+    return endian;\n+  }\n+\n+  public final FloatBuffer order(ByteOrder bo)\n+  {\n+    endian = bo;\n+    return this;\n+  }\n+\n+  public abstract float get();\n+  public abstract java.nio. FloatBuffer put(float b);\n+  public abstract float get(int index);\n+  public abstract java.nio. FloatBuffer put(int index, float b);\n+  public abstract FloatBuffer compact();\n+  public abstract boolean isDirect();\n+  public abstract FloatBuffer slice();\n+  public abstract FloatBuffer duplicate();\n+  public abstract FloatBuffer asReadOnlyBuffer();\n+  public abstract ShortBuffer asShortBuffer();\n+  public abstract CharBuffer asCharBuffer();\n+  public abstract IntBuffer asIntBuffer();\n+  public abstract LongBuffer asLongBuffer();\n+  public abstract FloatBuffer asFloatBuffer();\n+  public abstract DoubleBuffer asDoubleBuffer();\n+  public abstract char getChar();\n+  public abstract FloatBuffer putChar(char value);\n+  public abstract char getChar(int index);\n+  public abstract FloatBuffer putChar(int index, char value);\n+  public abstract short getShort();\n+  public abstract FloatBuffer putShort(short value);\n+  public abstract short getShort(int index);\n+  public abstract FloatBuffer putShort(int index, short value);\n+  public abstract int getInt();\n+  public abstract FloatBuffer putInt(int value);\n+  public abstract int getInt(int index);\n+  public abstract FloatBuffer putInt(int index, int value);\n+  public abstract long getLong();\n+  public abstract FloatBuffer putLong(long value);\n+  public abstract long getLong(int index);\n+  public abstract FloatBuffer putLong(int index, long value);\n+  public abstract float getFloat();\n+  public abstract FloatBuffer putFloat(float value);\n+  public abstract float getFloat(int index);\n+  public abstract FloatBuffer putFloat(int index, float value);\n+  public abstract double getDouble();\n+  public abstract FloatBuffer putDouble(double value);\n+  public abstract double getDouble(int index);\n+  public abstract FloatBuffer putDouble(int index, double value);\n+}"}, {"sha": "d2d28d36b10ff5b8f7b475a29e914bad3430913d", "filename": "libjava/java/nio/IntBuffer.java", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fjava%2Fnio%2FIntBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fjava%2Fnio%2FIntBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FIntBuffer.java?ref=48f5b6723a0f7dd8e8889c2eb4deea9185863386", "patch": "@@ -0,0 +1,225 @@\n+/* IntBuffer.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.nio;\n+\n+import gnu.java.nio.IntBufferImpl;\n+\n+public abstract class IntBuffer extends Buffer\n+{\n+  private ByteOrder endian = ByteOrder.BIG_ENDIAN;\n+  protected int [] backing_buffer;\n+\n+  public static IntBuffer allocateDirect(int capacity)\n+  {\n+    return new IntBufferImpl (capacity, 0, capacity);\n+  }\n+\n+  public static IntBuffer allocate(int capacity)\n+  {\n+    return new IntBufferImpl (capacity, 0, capacity);\n+  }\n+\n+  final public static IntBuffer wrap(int[] array, int offset, int length)\n+  {\n+    return new IntBufferImpl(array, offset, length);\n+  }\n+\n+  final public static IntBuffer wrap(String a)\n+  {\n+    int len = a.length();\n+    int[] buffer = new int[len];\n+\n+    for (int i=0;i<len;i++)\n+      {\n+        buffer[i] = (int) a.charAt(i);\n+      }\n+\n+    return wrap(buffer, 0, len);\n+  }\n+\n+  final public static IntBuffer wrap(int[] array)\n+  {\n+    return wrap(array, 0, array.length);\n+  }\n+\n+  final public IntBuffer get(int[] dst, int offset, int length)\n+  {\n+    for (int i = offset; i < offset + length; i++)\n+      {\n+        dst[i] = get();\n+      }\n+\n+    return this;\n+  }\n+\n+  final public IntBuffer get(int[] dst)\n+  {\n+    return get(dst, 0, dst.length);\n+  }\n+\n+  final public IntBuffer put(IntBuffer src)\n+  {\n+    while (src.hasRemaining())\n+      put(src.get());\n+\n+    return this;\n+  }\n+\n+  final public IntBuffer put(int[] src, int offset, int length)\n+  {\n+    for (int i = offset; i < offset + length; i++)\n+      put(src[i]);\n+\n+    return this;\n+  }\n+\n+  public final IntBuffer put(int[] src)\n+  {\n+    return put(src, 0, src.length);\n+  }\n+\n+  public final boolean hasArray()\n+  {\n+    return (backing_buffer != null);\n+  }\n+\n+  public final int[] array()\n+  {\n+    return backing_buffer;\n+  }\n+\n+  public final int arrayOffset()\n+  {\n+    return 0;\n+  }\n+\n+  public int hashCode()\n+  {\n+    return super.hashCode();\n+  }\n+\n+  public boolean equals(Object obj)\n+  {\n+    if (obj instanceof IntBuffer)\n+      {\n+        return compareTo(obj) == 0;\n+      }\n+\n+    return false;\n+  }\n+\n+  public int compareTo(Object ob)\n+  {\n+    IntBuffer a = (IntBuffer) ob;\n+\n+    if (a.remaining() != remaining())\n+      return 1;\n+\n+    if (! hasArray() ||\n+        ! a.hasArray())\n+      {\n+        return 1;\n+      }\n+\n+    int r = remaining();\n+    int i1 = position ();\n+    int i2 = a.position ();\n+\n+    for (int i=0;i<r;i++)\n+      {\n+        int t = (int) (get(i1)- a.get(i2));\n+        if (t != 0)\n+          {\n+            return (int) t;\n+          }\n+      }\n+\n+    return 0;\n+  }\n+\n+  public final ByteOrder order()\n+  {\n+    return endian;\n+  }\n+\n+  public final IntBuffer order(ByteOrder bo)\n+  {\n+    endian = bo;\n+    return this;\n+  }\n+\n+  public abstract int get();\n+  public abstract IntBuffer put(int b);\n+  public abstract int get(int index);\n+  public abstract IntBuffer put(int index, int b);\n+  public abstract IntBuffer compact();\n+  public abstract boolean isDirect();\n+  public abstract IntBuffer slice();\n+  public abstract IntBuffer duplicate();\n+  public abstract IntBuffer asReadOnlyBuffer();\n+  public abstract ShortBuffer asShortBuffer();\n+  public abstract CharBuffer asCharBuffer();\n+  public abstract IntBuffer asIntBuffer();\n+  public abstract LongBuffer asLongBuffer();\n+  public abstract FloatBuffer asFloatBuffer();\n+  public abstract DoubleBuffer asDoubleBuffer();\n+  public abstract char getChar();\n+  public abstract IntBuffer putChar(char value);\n+  public abstract char getChar(int index);\n+  public abstract IntBuffer putChar(int index, char value);\n+  public abstract short getShort();\n+  public abstract IntBuffer putShort(short value);\n+  public abstract short getShort(int index);\n+  public abstract IntBuffer putShort(int index, short value);\n+  public abstract int getInt();\n+  public abstract IntBuffer putInt(int value);\n+  public abstract int getInt(int index);\n+  public abstract IntBuffer putInt(int index, int value);\n+  public abstract long getLong();\n+  public abstract IntBuffer putLong(long value);\n+  public abstract long getLong(int index);\n+  public abstract IntBuffer putLong(int index, long value);\n+  public abstract float getFloat();\n+  public abstract IntBuffer putFloat(float value);\n+  public abstract float getFloat(int index);\n+  public abstract IntBuffer putFloat(int index, float value);\n+  public abstract double getDouble();\n+  public abstract IntBuffer putDouble(double value);\n+  public abstract double getDouble(int index);\n+  public abstract IntBuffer putDouble(int index, double value);\n+}"}, {"sha": "5bca6d53b70683cb72ad92a3c250a5375f9de454", "filename": "libjava/java/nio/LongBuffer.java", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fjava%2Fnio%2FLongBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fjava%2Fnio%2FLongBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FLongBuffer.java?ref=48f5b6723a0f7dd8e8889c2eb4deea9185863386", "patch": "@@ -0,0 +1,226 @@\n+/* LongBuffer.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.nio;\n+\n+import gnu.java.nio.LongBufferImpl;\n+\n+public abstract class LongBuffer extends Buffer\n+{\n+  private ByteOrder endian = ByteOrder.BIG_ENDIAN;\n+  protected long [] backing_buffer;\n+\n+  public static LongBuffer allocateDirect(int capacity)\n+  {\n+    return new LongBufferImpl(capacity, 0, capacity);\n+  }\n+\n+  public static LongBuffer allocate(int capacity)\n+  {\n+    return new LongBufferImpl(capacity, 0, capacity);\n+  }\n+\n+  final public static LongBuffer wrap(long[] array, int offset, int length)\n+  {\n+    return new LongBufferImpl (array, offset, length);\n+  }\n+\n+  final public static LongBuffer wrap(String a)\n+  {\n+    int len = a.length();\n+    long[] buffer = new long[len];\n+\n+    for (int i=0;i<len;i++)\n+      {\n+        buffer[i] = (long) a.charAt(i);\n+      }\n+\n+    return wrap(buffer, 0, len);\n+  }\n+\n+  final public static LongBuffer wrap(long[] array)\n+  {\n+    return wrap(array, 0, array.length);\n+  }\n+\n+  final public LongBuffer get(long[] dst, int offset, int length)\n+  {\n+    for (int i = offset; i < offset + length; i++)\n+      {\n+        dst[i] = get();\n+      }\n+\n+    return this;\n+  }\n+\n+  final public LongBuffer get(long[] dst)\n+  {\n+    return get(dst, 0, dst.length);\n+  }\n+\n+  final public LongBuffer put(LongBuffer src)\n+  {\n+    while (src.hasRemaining())\n+      put(src.get());\n+\n+    return this;\n+  }\n+\n+  final public LongBuffer put(long[] src, int offset, int length)\n+  {\n+    for (int i = offset; i < offset + length; i++)\n+      put(src[i]);\n+\n+    return this;\n+  }\n+\n+  public final LongBuffer put(long[] src)\n+  {\n+    return put(src, 0, src.length);\n+  }\n+\n+  public final boolean hasArray()\n+  {\n+    return (backing_buffer != null);\n+  }\n+\n+  public final long[] array()\n+  {\n+    return backing_buffer;\n+  }\n+\n+  public final int arrayOffset()\n+  {\n+    return 0;\n+  }\n+\n+  public int hashCode()\n+  {\n+    return super.hashCode();\n+  }\n+\n+  public boolean equals(Object obj)\n+  {\n+    if (obj instanceof LongBuffer)\n+      {\n+        return compareTo(obj) == 0;\n+      }\n+\n+    return false;\n+  }\n+\n+  public int compareTo(Object ob)\n+  {\n+    LongBuffer a = (LongBuffer) ob;\n+\n+    if (a.remaining() != remaining())\n+      return 1;\n+\n+    if (! hasArray() ||\n+        ! a.hasArray())\n+      {\n+        return 1;\n+      }\n+\n+    int r = remaining();\n+    int i1 = position ();\n+    int i2 = a.position ();\n+\n+    for (int i=0;i<r;i++)\n+      {\n+        int t = (int) (get(i1)- a.get(i2));\n+\n+        if (t != 0)\n+          {\n+            return (int) t;\n+          }\n+      }\n+\n+    return 0;\n+  }\n+\n+  public final ByteOrder order()\n+  {\n+    return endian;\n+  }\n+\n+  public final LongBuffer order(ByteOrder bo)\n+  {\n+    endian = bo;\n+    return this;\n+  }\n+\n+  public abstract long get();\n+  public abstract java.nio. LongBuffer put(long b);\n+  public abstract long get(int index);\n+  public abstract java.nio. LongBuffer put(int index, long b);\n+  public abstract LongBuffer compact();\n+  public abstract boolean isDirect();\n+  public abstract LongBuffer slice();\n+  public abstract LongBuffer duplicate();\n+  public abstract LongBuffer asReadOnlyBuffer();\n+  public abstract ShortBuffer asShortBuffer();\n+  public abstract CharBuffer asCharBuffer();\n+  public abstract IntBuffer asIntBuffer();\n+  public abstract LongBuffer asLongBuffer();\n+  public abstract FloatBuffer asFloatBuffer();\n+  public abstract DoubleBuffer asDoubleBuffer();\n+  public abstract char getChar();\n+  public abstract LongBuffer putChar(char value);\n+  public abstract char getChar(int index);\n+  public abstract LongBuffer putChar(int index, char value);\n+  public abstract short getShort();\n+  public abstract LongBuffer putShort(short value);\n+  public abstract short getShort(int index);\n+  public abstract LongBuffer putShort(int index, short value);\n+  public abstract int getInt();\n+  public abstract LongBuffer putInt(int value);\n+  public abstract int getInt(int index);\n+  public abstract LongBuffer putInt(int index, int value);\n+  public abstract long getLong();\n+  public abstract LongBuffer putLong(long value);\n+  public abstract long getLong(int index);\n+  public abstract LongBuffer putLong(int index, long value);\n+  public abstract float getFloat();\n+  public abstract LongBuffer putFloat(float value);\n+  public abstract float getFloat(int index);\n+  public abstract LongBuffer putFloat(int index, float value);\n+  public abstract double getDouble();\n+  public abstract LongBuffer putDouble(double value);\n+  public abstract double getDouble(int index);\n+  public abstract LongBuffer putDouble(int index, double value);\n+}"}, {"sha": "5301366ceeeef551b7b5d369b0461a45873290c3", "filename": "libjava/java/nio/ShortBuffer.java", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fjava%2Fnio%2FShortBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fjava%2Fnio%2FShortBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2FShortBuffer.java?ref=48f5b6723a0f7dd8e8889c2eb4deea9185863386", "patch": "@@ -0,0 +1,226 @@\n+/* ShortBuffer.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.nio;\n+\n+import gnu.java.nio.ShortBufferImpl;\n+\n+public abstract class ShortBuffer extends Buffer\n+{\n+  private ByteOrder endian = ByteOrder.BIG_ENDIAN;\n+  protected short [] backing_buffer;\n+\n+  public static ShortBuffer allocateDirect(int capacity)\n+  {\n+    return new ShortBufferImpl(capacity, 0, capacity);\n+  }\n+\n+  public static ShortBuffer allocate(int capacity)\n+  {\n+    return new ShortBufferImpl(capacity, 0, capacity);\n+  }\n+\n+  final public static ShortBuffer wrap(short[] array, int offset, int length)\n+  {\n+    return new ShortBufferImpl(array, offset, length);\n+  }\n+\n+  final public static ShortBuffer wrap(String a)\n+  {\n+    int len = a.length();\n+    short[] buffer = new short[len];\n+\n+    for (int i=0;i<len;i++)\n+      {\n+        buffer[i] = (short) a.charAt(i);\n+      }\n+\n+    return wrap(buffer, 0, len);\n+  }\n+\n+  final public static ShortBuffer wrap(short[] array)\n+  {\n+    return wrap(array, 0, array.length);\n+  }\n+\n+  final public ShortBuffer get(short[] dst, int offset, int length)\n+  {\n+    for (int i = offset; i < offset + length; i++)\n+      {\n+        dst[i] = get();\n+      }\n+\n+    return this;\n+  }\n+\n+  final public ShortBuffer get(short[] dst)\n+  {\n+    return get(dst, 0, dst.length);\n+  }\n+\n+  final public ShortBuffer put(ShortBuffer src)\n+  {\n+    while (src.hasRemaining())\n+      put(src.get());\n+\n+    return this;\n+  }\n+\n+  final public ShortBuffer put(short[] src, int offset, int length)\n+  {\n+    for (int i = offset; i < offset + length; i++)\n+      put(src[i]);\n+\n+    return this;\n+  }\n+\n+  public final ShortBuffer put(short[] src)\n+  {\n+    return put(src, 0, src.length);\n+  }\n+\n+  public final boolean hasArray()\n+  {\n+    return (backing_buffer != null);\n+  }\n+\n+  public final short[] array()\n+  {\n+    return backing_buffer;\n+  }\n+\n+  public final int arrayOffset()\n+  {\n+    return 0;\n+  }\n+\n+  public int hashCode()\n+  {\n+    return super.hashCode();\n+  }\n+\n+  public boolean equals(Object obj)\n+  {\n+    if (obj instanceof ShortBuffer)\n+      {\n+        return compareTo(obj) == 0;\n+      }\n+\n+    return false;\n+  }\n+\n+  public int compareTo(Object ob)\n+  {\n+    ShortBuffer a = (ShortBuffer) ob;\n+\n+    if (a.remaining() != remaining())\n+      return 1;\n+\n+    if (! hasArray() ||\n+        ! a.hasArray())\n+      {\n+        return 1;\n+      }\n+\n+    int r = remaining();\n+    int i1 = position ();\n+    int i2 = a.position ();\n+\n+    for (int i=0;i<r;i++)\n+      {\n+        int t = (int) (get(i1)- a.get(i2));\n+\n+        if (t != 0)\n+          {\n+            return (int) t;\n+          }\n+      }\n+\n+    return 0;\n+  }\n+\n+  public final ByteOrder order()\n+  {\n+    return endian;\n+  }\n+\n+  public final ShortBuffer order(ByteOrder bo)\n+  {\n+    endian = bo;\n+    return this;\n+  }\n+\n+  public abstract short get();\n+  public abstract java.nio. ShortBuffer put(short b);\n+  public abstract short get(int index);\n+  public abstract java.nio. ShortBuffer put(int index, short b);\n+  public abstract ShortBuffer compact();\n+  public abstract boolean isDirect();\n+  public abstract ShortBuffer slice();\n+  public abstract ShortBuffer duplicate();\n+  public abstract ShortBuffer asReadOnlyBuffer();\n+  public abstract ShortBuffer asShortBuffer();\n+  public abstract CharBuffer asCharBuffer();\n+  public abstract IntBuffer asIntBuffer();\n+  public abstract LongBuffer asLongBuffer();\n+  public abstract FloatBuffer asFloatBuffer();\n+  public abstract DoubleBuffer asDoubleBuffer();\n+  public abstract char getChar();\n+  public abstract ShortBuffer putChar(char value);\n+  public abstract char getChar(int index);\n+  public abstract ShortBuffer putChar(int index, char value);\n+  public abstract short getShort();\n+  public abstract ShortBuffer putShort(short value);\n+  public abstract short getShort(int index);\n+  public abstract ShortBuffer putShort(int index, short value);\n+  public abstract int getInt();\n+  public abstract ShortBuffer putInt(int value);\n+  public abstract int getInt(int index);\n+  public abstract ShortBuffer putInt(int index, int value);\n+  public abstract long getLong();\n+  public abstract ShortBuffer putLong(long value);\n+  public abstract long getLong(int index);\n+  public abstract ShortBuffer putLong(int index, long value);\n+  public abstract float getFloat();\n+  public abstract ShortBuffer putFloat(float value);\n+  public abstract float getFloat(int index);\n+  public abstract ShortBuffer putFloat(int index, float value);\n+  public abstract double getDouble();\n+  public abstract ShortBuffer putDouble(double value);\n+  public abstract double getDouble(int index);\n+  public abstract ShortBuffer putDouble(int index, double value);\n+}"}, {"sha": "8970b983923049368cd5c5e9cca8cc2fec2dda7d", "filename": "libjava/java/nio/channels/FileChannel.java", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fjava%2Fnio%2Fchannels%2FFileChannel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f5b6723a0f7dd8e8889c2eb4deea9185863386/libjava%2Fjava%2Fnio%2Fchannels%2FFileChannel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnio%2Fchannels%2FFileChannel.java?ref=48f5b6723a0f7dd8e8889c2eb4deea9185863386", "patch": "@@ -0,0 +1,135 @@\n+/* FileChannel.java -- \n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.nio.channels;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.spi.AbstractInterruptibleChannel;\n+\n+/**\n+ * @author Michael Koch\n+ * @since 1.4\n+ */\n+public abstract class FileChannel extends AbstractInterruptibleChannel\n+  implements ByteChannel, GatheringByteChannel, ScatteringByteChannel\n+{\n+  public static class MapMode\n+  {\n+    public int m;\n+\n+    public static MapMode READ_ONLY  = new MapMode(0);\n+    public static MapMode READ_WRITE = new MapMode(1);\n+    public static MapMode PRIVATE    = new MapMode(2);\n+\n+    /**\n+     * Initializes the MapMode.\n+     */\n+    MapMode(int a)\n+    {\n+      m = a;\n+    }\n+\n+    public String toString() \n+    {\n+      return \"\" + m;\n+    }\n+  }\n+\n+  /**\n+   * Initializes the channel.\n+   */\n+  protected FileChannel ()\n+  {\n+  }\n+\n+  /**\n+   * Maps the file into the memory.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n+  public abstract MappedByteBuffer map(MapMode mode, long position, long size)\n+    throws IOException;\n+\n+  /**\n+   * Return the size of the file thus far\n+   */\n+  public abstract long size() throws IOException;\n+  \n+  /**\n+   * Writes data to the channel.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n+  public long write (ByteBuffer[] srcs) throws IOException\n+  {\n+    long result = 0;\n+    \n+    for (int i = 0; i < srcs.length; i++)\n+      {\n+        result += write (srcs[i]);\n+      }\n+    \n+    return result;\n+  }\n+  \n+  /**\n+   * Writes data to the channel.\n+   */\n+  public abstract long write(ByteBuffer[] srcs, int offset, int length)\n+    throws IOException;\n+  \n+  /**\n+   * Reads data from the channel.\n+   */\n+  public abstract int read(ByteBuffer dst) throws IOException;\n+  \n+  /**\n+   * Closes the channel.\n+   *\n+   * This is called from @see close.\n+   *\n+   * @exception IOException If an error occurs.\n+   */\n+  protected abstract void implCloseChannel() throws IOException;\n+\n+  /**\n+   * msync with the disk\n+   */\n+  public abstract void force(boolean metaData);    \n+}"}]}