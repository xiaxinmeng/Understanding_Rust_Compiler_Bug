{"sha": "5d5a519f6a939407a4934604293a7131a8d8b5ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ1YTUxOWY2YTkzOTQwN2E0OTM0NjA0MjkzYTcxMzFhOGQ4YjVlZg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-10-08T09:33:55Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-10-08T09:33:55Z"}, "message": "cp-tree.h (dfs_walk, [...]): Remove.\n\n\t* cp-tree.h (dfs_walk, dfs_walk_real, dfs_unmark, markedp,\n\tunmarkedp): Remove.\n\t(dfs_skip_bases, dfs_walk_all, dfs_walk_once): New.\n\t* class.c (struct find_final_overrider_data): Remove most_derived,\n\tvpath_list and vpath fields.  Add path field.\n\t(dfs_find_final_ocerrider_1): Add DEPTH parameter. Adjust.\n\t(dfs_find_final_overrider): Rename to ...\n\t(dfs_find_final_overrider_pre): ... here. Adjust.\n\t(dfs_find_final_overrider_post): Adjust.\n\t(dfs_find_final_overrider_q): Fold into\n\tdfs_find_final_overrider_pre.\n\t(find_final_overrider): Adjust dfs searching.\n\t(dfs_modify_vtables): Don't mark binfo here.\n\t(modify_all_vtables): Use dfs_walk_once.\n\t(build_vtt_inits): Likwise. Use dfs_walk_all.\n\t(dfs_build_secondary_vptr_vtt_inits): Don't mark binfo here.\n\tReturn dfs_skip_bases as appropriate.\n\t(dfs_fixup_binfo_vtbls): Return dfs_skip_bases as appropriate.\n\t* init.c (dfs_initialized_vtbl_ptrs): Return dfs_skip_bases as\n\tappropriate. Don't mark binfo here.\n\t(initialize_vtbl_ptrs): Use dfs_walk_once.\n\t* search.c (struct vbase_info): Remove unused struct.\n\t(access_in_type): Use dfs_walk_once.\n\t(dfs_access_in_type): Don't mark binfo here.\n\t(dfs_accessible_queue_p, dfs_accessible_p) Remove.\n\tFold into ...\n\t(accessible_r): ... here. New. Specialize dfs_walk_once.\n\t(accessible_p): Use accessible_r.\n\t(lookup_field_queue_p): Remove. Fold into ...\n\t(lookup_field_r): ... here. Adjust.\n\t(lookup_member): Use dfs_walk_all.\n\t(dfs_walk_real, dfs_walk): Replace with ...\n\t(dfs_walk_all, dfs_walk_once): ... these.\n\t(dfs_walk_once_r, dfs_unmark_r): Workers for dfs_walk_once.\n\t(dfs_unmark, unmarkedp, markedp): Remove.\n\t(dfs_get_pure_virtuals): Don't mark binfo here.\n\t(get_pure_virtuals): Use dfs_walk_once.\n\t(dfs_debug_unmarked_p): Remove. Fold into ...\n\t(dfs_debug_mark): ... here.\n\t(note_debug_info_needed): Use dfs_walk_all.\n\nFrom-SVN: r88738", "tree": {"sha": "788c086498884f0d4d0b84c27c99cb6582b7f4b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/788c086498884f0d4d0b84c27c99cb6582b7f4b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d5a519f6a939407a4934604293a7131a8d8b5ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d5a519f6a939407a4934604293a7131a8d8b5ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d5a519f6a939407a4934604293a7131a8d8b5ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d5a519f6a939407a4934604293a7131a8d8b5ef/comments", "author": null, "committer": null, "parents": [{"sha": "69a53ee8f01b64ab6f03b63cc1cd89735032f3d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69a53ee8f01b64ab6f03b63cc1cd89735032f3d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69a53ee8f01b64ab6f03b63cc1cd89735032f3d7"}], "stats": {"total": 581, "additions": 312, "deletions": 269}, "files": [{"sha": "427a1e49ef8a9852ef3e6c9cb9e6adadbf67a213", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5a519f6a939407a4934604293a7131a8d8b5ef/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5a519f6a939407a4934604293a7131a8d8b5ef/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5d5a519f6a939407a4934604293a7131a8d8b5ef", "patch": "@@ -1,3 +1,46 @@\n+2004-10-08  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cp-tree.h (dfs_walk, dfs_walk_real, dfs_unmark, markedp,\n+\tunmarkedp): Remove.\n+\t(dfs_skip_bases, dfs_walk_all, dfs_walk_once): New.\n+\t* class.c (struct find_final_overrider_data): Remove most_derived,\n+\tvpath_list and vpath fields.  Add path field.\n+\t(dfs_find_final_ocerrider_1): Add DEPTH parameter. Adjust.\n+\t(dfs_find_final_overrider): Rename to ...\n+\t(dfs_find_final_overrider_pre): ... here. Adjust.\n+\t(dfs_find_final_overrider_post): Adjust.\n+\t(dfs_find_final_overrider_q): Fold into\n+\tdfs_find_final_overrider_pre.\n+\t(find_final_overrider): Adjust dfs searching.\n+\t(dfs_modify_vtables): Don't mark binfo here.\n+\t(modify_all_vtables): Use dfs_walk_once.\n+\t(build_vtt_inits): Likwise. Use dfs_walk_all.\n+\t(dfs_build_secondary_vptr_vtt_inits): Don't mark binfo here.\n+\tReturn dfs_skip_bases as appropriate.\n+\t(dfs_fixup_binfo_vtbls): Return dfs_skip_bases as appropriate.\n+\t* init.c (dfs_initialized_vtbl_ptrs): Return dfs_skip_bases as\n+\tappropriate. Don't mark binfo here.\n+\t(initialize_vtbl_ptrs): Use dfs_walk_once.\n+\t* search.c (struct vbase_info): Remove unused struct.\n+\t(access_in_type): Use dfs_walk_once.\n+\t(dfs_access_in_type): Don't mark binfo here.\n+\t(dfs_accessible_queue_p, dfs_accessible_p) Remove.\n+\tFold into ...\n+\t(accessible_r): ... here. New. Specialize dfs_walk_once.\n+\t(accessible_p): Use accessible_r.\n+\t(lookup_field_queue_p): Remove. Fold into ...\n+\t(lookup_field_r): ... here. Adjust.\n+\t(lookup_member): Use dfs_walk_all.\n+\t(dfs_walk_real, dfs_walk): Replace with ...\n+\t(dfs_walk_all, dfs_walk_once): ... these.\n+\t(dfs_walk_once_r, dfs_unmark_r): Workers for dfs_walk_once.\n+\t(dfs_unmark, unmarkedp, markedp): Remove.\n+\t(dfs_get_pure_virtuals): Don't mark binfo here.\n+\t(get_pure_virtuals): Use dfs_walk_once.\n+\t(dfs_debug_unmarked_p): Remove. Fold into ...\n+\t(dfs_debug_mark): ... here.\n+\t(note_debug_info_needed): Use dfs_walk_all.\n+\n 2004-10-07  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* pt.c (tsubst_expr) <case ASM_EXPR>: Look passed the"}, {"sha": "d93ee22879657b7c5363a55de3682f3f460ca274", "filename": "gcc/cp/class.c", "status": "modified", "additions": 45, "deletions": 76, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5a519f6a939407a4934604293a7131a8d8b5ef/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5a519f6a939407a4934604293a7131a8d8b5ef/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=5d5a519f6a939407a4934604293a7131a8d8b5ef", "patch": "@@ -155,9 +155,8 @@ static void add_vcall_offset_vtbl_entries_1 (tree, vtbl_init_data *);\n static void build_vcall_offset_vtbl_entries (tree, vtbl_init_data *);\n static void add_vcall_offset (tree, tree, vtbl_init_data *);\n static void layout_vtable_decl (tree, int);\n-static tree dfs_find_final_overrider (tree, void *);\n+static tree dfs_find_final_overrider_pre (tree, void *);\n static tree dfs_find_final_overrider_post (tree, void *);\n-static tree dfs_find_final_overrider_q (tree, int, void *);\n static tree find_final_overrider (tree, tree, tree);\n static int make_new_vtable (tree, tree);\n static int maybe_indent_hierarchy (FILE *, int, int);\n@@ -171,15 +170,14 @@ static void dump_thunk (FILE *, int, tree);\n static tree build_vtable (tree, tree, tree);\n static void initialize_vtable (tree, tree);\n static void layout_nonempty_base_or_field (record_layout_info,\n-\t\t\t\t\t\t   tree, tree, splay_tree);\n+\t\t\t\t\t   tree, tree, splay_tree);\n static tree end_of_class (tree, int);\n static bool layout_empty_base (tree, tree, splay_tree);\n static void accumulate_vtbl_inits (tree, tree, tree, tree, tree);\n static tree dfs_accumulate_vtbl_inits (tree, tree, tree, tree,\n \t\t\t\t\t       tree);\n static void build_rtti_vtbl_entries (tree, vtbl_init_data *);\n-static void build_vcall_and_vbase_vtbl_entries (tree, \n-\t\t\t\t\t\t\tvtbl_init_data *);\n+static void build_vcall_and_vbase_vtbl_entries (tree, vtbl_init_data *);\n static void clone_constructors_and_destructors (tree);\n static tree build_clone (tree, tree);\n static void update_vtable_entry_for_fn (tree, tree, tree, tree *, unsigned);\n@@ -192,11 +190,11 @@ static tree dfs_fixup_binfo_vtbls (tree, void *);\n static int record_subobject_offset (tree, tree, splay_tree);\n static int check_subobject_offset (tree, tree, splay_tree);\n static int walk_subobject_offsets (tree, subobject_offset_fn,\n-\t\t\t\t\t   tree, splay_tree, tree, int);\n+\t\t\t\t   tree, splay_tree, tree, int);\n static void record_subobject_offsets (tree, tree, splay_tree, int);\n static int layout_conflict_p (tree, tree, splay_tree, int);\n static int splay_tree_compare_integer_csts (splay_tree_key k1,\n-\t\t\t\t\t\t    splay_tree_key k2);\n+\t\t\t\t\t    splay_tree_key k2);\n static void warn_about_ambiguous_bases (tree);\n static bool type_requires_array_cookie (tree);\n static bool contains_empty_class_p (tree);\n@@ -1788,38 +1786,29 @@ typedef struct find_final_overrider_data_s {\n   tree fn;\n   /* The base class in which the function was declared.  */\n   tree declaring_base;\n-  /* The most derived class in the hierarchy.  */\n-  tree most_derived_type;\n   /* The candidate overriders.  */\n   tree candidates;\n-  /* Each entry in this array is the next-most-derived class for a\n-     virtual base class along the current path.  */\n-  tree *vpath_list;\n-  /* A pointer one past the top of the VPATH_LIST.  */\n-  tree *vpath;\n+  /* Path to most derived.  */\n+  VEC (tree) *path;\n } find_final_overrider_data;\n \n /* Add the overrider along the current path to FFOD->CANDIDATES.\n    Returns true if an overrider was found; false otherwise.  */\n \n static bool\n dfs_find_final_overrider_1 (tree binfo, \n-\t\t\t    tree *vpath, \n-\t\t\t    find_final_overrider_data *ffod)\n+\t\t\t    find_final_overrider_data *ffod,\n+\t\t\t    unsigned depth)\n {\n   tree method;\n \n   /* If BINFO is not the most derived type, try a more derived class.\n      A definition there will overrider a definition here.  */\n-  if (!same_type_p (BINFO_TYPE (binfo), ffod->most_derived_type))\n+  if (depth)\n     {\n-      tree derived;\n-\n-      if (BINFO_VIRTUAL_P (binfo))\n-\tderived = *--vpath;\n-      else\n-\tderived = BINFO_INHERITANCE_CHAIN (binfo);\n-      if (dfs_find_final_overrider_1 (derived, vpath, ffod))\n+      depth--;\n+      if (dfs_find_final_overrider_1\n+\t  (VEC_index (tree, ffod->path, depth), ffod, depth))\n \treturn true;\n     }\n \n@@ -1853,36 +1842,23 @@ dfs_find_final_overrider_1 (tree binfo,\n /* Called from find_final_overrider via dfs_walk.  */\n \n static tree\n-dfs_find_final_overrider (tree binfo, void* data)\n+dfs_find_final_overrider_pre (tree binfo, void *data)\n {\n   find_final_overrider_data *ffod = (find_final_overrider_data *) data;\n \n   if (binfo == ffod->declaring_base)\n-    dfs_find_final_overrider_1 (binfo, ffod->vpath, ffod);\n+    dfs_find_final_overrider_1 (binfo, ffod, VEC_length (tree, ffod->path));\n+  VEC_safe_push (tree, ffod->path, binfo);\n \n   return NULL_TREE;\n }\n \n static tree\n-dfs_find_final_overrider_q (tree derived, int ix, void *data)\n-{\n-  tree binfo = BINFO_BASE_BINFO (derived, ix);\n-  find_final_overrider_data *ffod = (find_final_overrider_data *) data;\n-\n-  if (BINFO_VIRTUAL_P (binfo))\n-    *ffod->vpath++ = derived;\n-  \n-  return binfo;\n-}\n-\n-static tree\n-dfs_find_final_overrider_post (tree binfo, void *data)\n+dfs_find_final_overrider_post (tree binfo ATTRIBUTE_UNUSED, void *data)\n {\n   find_final_overrider_data *ffod = (find_final_overrider_data *) data;\n+  VEC_pop (tree, ffod->path);\n \n-  if (BINFO_VIRTUAL_P (binfo))\n-    ffod->vpath--;\n-  \n   return NULL_TREE;\n }\n \n@@ -1920,23 +1896,14 @@ find_final_overrider (tree derived, tree binfo, tree fn)\n   /* Determine the depth of the hierarchy.  */\n   ffod.fn = fn;\n   ffod.declaring_base = binfo;\n-  ffod.most_derived_type = BINFO_TYPE (derived);\n   ffod.candidates = NULL_TREE;\n-  /* The virtual depth cannot be greater than the number of virtual\n-     bases.  */\n-  ffod.vpath_list = (tree *) xcalloc\n-    (VEC_length (tree, CLASSTYPE_VBASECLASSES (BINFO_TYPE (derived))),\n-     sizeof (tree));\n-  ffod.vpath = ffod.vpath_list;\n-\n-  dfs_walk_real (derived,\n-\t\t dfs_find_final_overrider,\n-\t\t dfs_find_final_overrider_post,\n-\t\t dfs_find_final_overrider_q,\n-\t\t &ffod);\n+  ffod.path = VEC_alloc (tree, 30);\n \n-  free (ffod.vpath_list);\n+  dfs_walk_all (derived, dfs_find_final_overrider_pre,\n+\t\tdfs_find_final_overrider_post, &ffod);\n \n+  VEC_free (tree, ffod.path);\n+  \n   /* If there was no winner, issue an error message.  */\n   if (!ffod.candidates || TREE_CHAIN (ffod.candidates))\n     {\n@@ -2208,8 +2175,6 @@ dfs_modify_vtables (tree binfo, void* data)\n \t\t\t\t    &virtuals, ix);\n     }\n \n-  BINFO_MARKED (binfo) = 1;\n-\n   return NULL_TREE;\n }\n \n@@ -2229,8 +2194,7 @@ modify_all_vtables (tree t, tree virtuals)\n   tree *fnsp;\n \n   /* Update all of the vtables.  */\n-  dfs_walk (binfo, dfs_modify_vtables, unmarkedp, t);\n-  dfs_walk (binfo, dfs_unmark, markedp, t);\n+  dfs_walk_once (binfo, NULL, dfs_modify_vtables, t);\n \n   /* Add virtual functions not already in our primary vtable. These\n      will be both those introduced by this class, and those overridden\n@@ -6763,7 +6727,7 @@ build_vtt_inits (tree binfo, tree t, tree *inits, tree *index)\n   /* Recursively add the secondary VTTs for non-virtual bases.  */\n   for (i = 0; BINFO_BASE_ITERATE (binfo, i, b); ++i)\n     if (!BINFO_VIRTUAL_P (b))\n-      inits = build_vtt_inits (BINFO_BASE_BINFO (binfo, i), t, inits, index);\n+      inits = build_vtt_inits (b, t, inits, index);\n       \n   /* Add secondary virtual pointers for all subobjects of BINFO with\n      either virtual bases or reachable along a virtual path, except\n@@ -6773,9 +6737,7 @@ build_vtt_inits (tree binfo, tree t, tree *inits, tree *index)\n   data.inits = NULL;\n   data.type_being_constructed = BINFO_TYPE (binfo);\n   \n-  dfs_walk_real (binfo, dfs_build_secondary_vptr_vtt_inits,\n-\t\t NULL, unmarkedp, &data);\n-  dfs_walk (binfo, dfs_unmark, markedp, 0);\n+  dfs_walk_once (binfo, dfs_build_secondary_vptr_vtt_inits, NULL, &data);\n \n   *index = data.index;\n \n@@ -6802,7 +6764,7 @@ build_vtt_inits (tree binfo, tree t, tree *inits, tree *index)\n       }\n   else\n     /* Remove the ctor vtables we created.  */\n-    dfs_walk (binfo, dfs_fixup_binfo_vtbls, 0, binfo);\n+    dfs_walk_all (binfo, dfs_fixup_binfo_vtbls, NULL, binfo);\n \n   return inits;\n }\n@@ -6815,27 +6777,25 @@ dfs_build_secondary_vptr_vtt_inits (tree binfo, void *data_)\n {\n   secondary_vptr_vtt_init_data *data = (secondary_vptr_vtt_init_data *)data_;\n \n-  BINFO_MARKED (binfo) = 1;\n-\n   /* We don't care about bases that don't have vtables.  */\n   if (!TYPE_VFIELD (BINFO_TYPE (binfo)))\n-    return NULL_TREE;\n+    return dfs_skip_bases;\n \n   /* We're only interested in proper subobjects of the type being\n      constructed.  */\n   if (same_type_p (BINFO_TYPE (binfo), data->type_being_constructed))\n     return NULL_TREE;\n \n-  /* We're not interested in non-virtual primary bases.  */\n-  if (!BINFO_VIRTUAL_P (binfo) && BINFO_PRIMARY_P (binfo))\n-    return NULL_TREE;\n-\n   /* We're only interested in bases with virtual bases or reachable\n      via a virtual path from the type being constructed.  */\n-  if (!CLASSTYPE_VBASECLASSES (BINFO_TYPE (binfo))\n-      && !binfo_via_virtual (binfo, data->type_being_constructed))\n+  if (!(CLASSTYPE_VBASECLASSES (BINFO_TYPE (binfo))\n+\t|| binfo_via_virtual (binfo, data->type_being_constructed)))\n+    return dfs_skip_bases;\n+  \n+  /* We're not interested in non-virtual primary bases.  */\n+  if (!BINFO_VIRTUAL_P (binfo) && BINFO_PRIMARY_P (binfo))\n     return NULL_TREE;\n-\n+  \n   /* Record the index where this secondary vptr can be found.  */\n   if (data->top_level_p)\n     {\n@@ -6873,9 +6833,18 @@ dfs_fixup_binfo_vtbls (tree binfo, void* data)\n {\n   tree vtable = BINFO_VTABLE (binfo);\n \n+  if (!TYPE_CONTAINS_VPTR_P (BINFO_TYPE (binfo)))\n+    /* If this class has no vtable, none of its bases do.  */\n+    return dfs_skip_bases;\n+  \n+  if (!vtable)\n+    /* This might be a primary base, so have no vtable in this\n+       hierarchy.  */\n+    return NULL_TREE;\n+  \n   /* If we scribbled the construction vtable vptr into BINFO, clear it\n      out now.  */\n-  if (vtable && TREE_CODE (vtable) == TREE_LIST\n+  if (TREE_CODE (vtable) == TREE_LIST\n       && (TREE_PURPOSE (vtable) == (tree) data))\n     BINFO_VTABLE (binfo) = TREE_CHAIN (vtable);\n "}, {"sha": "826bd51cf2914728ceed842ffde85d5e7d91ad06", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5a519f6a939407a4934604293a7131a8d8b5ef/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5a519f6a939407a4934604293a7131a8d8b5ef/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5d5a519f6a939407a4934604293a7131a8d8b5ef", "patch": "@@ -4014,18 +4014,11 @@ extern tree binfo_from_vbase\t\t\t(tree);\n extern tree binfo_for_vbase\t\t\t(tree, tree);\n extern tree look_for_overrides_here\t\t(tree, tree);\n extern int check_final_overrider\t\t(tree, tree);\n-extern tree dfs_walk                            (tree,\n-\t\t\t\t\t\t tree (*) (tree, void *),\n-\t\t\t\t\t\t tree (*) (tree, int, void *),\n-\t\t\t\t\t\t void *);\n-extern tree dfs_walk_real                      (tree,\n-\t\t\t\t\t\ttree (*) (tree, void *),\n-\t\t\t\t\t\ttree (*) (tree, void *),\n-\t\t\t\t\t\ttree (*) (tree, int, void *),\n-\t\t\t\t\t\tvoid *);\n-extern tree dfs_unmark                          (tree, void *);\n-extern tree markedp                             (tree, int, void *);\n-extern tree unmarkedp                           (tree, int, void *);\n+#define dfs_skip_bases ((tree)1)\n+extern tree dfs_walk_all (tree, tree (*) (tree, void *),\n+\t\t\t  tree (*) (tree, void *), void *);\n+extern tree dfs_walk_once (tree, tree (*) (tree, void *),\n+\t\t\t   tree (*) (tree, void *), void *);\n extern tree binfo_via_virtual                   (tree, tree);\n extern tree build_baselink                      (tree, tree, tree, tree);\n extern tree adjust_result_of_qualified_name_lookup"}, {"sha": "ceb6d690a6a3a903599743004c9c011182ce5f9c", "filename": "gcc/cp/init.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5a519f6a939407a4934604293a7131a8d8b5ef/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5a519f6a939407a4934604293a7131a8d8b5ef/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=5d5a519f6a939407a4934604293a7131a8d8b5ef", "patch": "@@ -101,8 +101,10 @@ finish_init_stmts (bool is_global, tree stmt_expr, tree compound_stmt)\n static tree\n dfs_initialize_vtbl_ptrs (tree binfo, void *data)\n {\n-  if ((!BINFO_PRIMARY_P (binfo) || BINFO_VIRTUAL_P (binfo))\n-      && TYPE_CONTAINS_VPTR_P (BINFO_TYPE (binfo)))\n+  if (!TYPE_CONTAINS_VPTR_P (BINFO_TYPE (binfo)))\n+    return dfs_skip_bases;\n+  \n+  if (!BINFO_PRIMARY_P (binfo) || BINFO_VIRTUAL_P (binfo))\n     {\n       tree base_ptr = TREE_VALUE ((tree) data);\n \n@@ -111,8 +113,6 @@ dfs_initialize_vtbl_ptrs (tree binfo, void *data)\n       expand_virtual_init (binfo, base_ptr);\n     }\n \n-  BINFO_MARKED (binfo) = 1;\n-\n   return NULL_TREE;\n }\n \n@@ -132,9 +132,7 @@ initialize_vtbl_ptrs (tree addr)\n      class.  We do these in pre-order because we can't find the virtual\n      bases for a class until we've initialized the vtbl for that\n      class.  */\n-  dfs_walk_real (TYPE_BINFO (type), dfs_initialize_vtbl_ptrs,\n-\t\t NULL, unmarkedp, list);\n-  dfs_walk (TYPE_BINFO (type), dfs_unmark, markedp, type);\n+  dfs_walk_once (TYPE_BINFO (type), dfs_initialize_vtbl_ptrs, NULL, list);\n }\n \n /* Return an expression for the zero-initialization of an object with"}, {"sha": "79c6839fdec833ca10219d490a77d1eed9406c74", "filename": "gcc/cp/search.c", "status": "modified", "additions": 214, "deletions": 174, "changes": 388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5a519f6a939407a4934604293a7131a8d8b5ef/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5a519f6a939407a4934604293a7131a8d8b5ef/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=5d5a519f6a939407a4934604293a7131a8d8b5ef", "patch": "@@ -36,29 +36,20 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"stack.h\"\n \n-struct vbase_info \n-{\n-  /* The class dominating the hierarchy.  */\n-  tree type;\n-  /* A pointer to a complete object of the indicated TYPE.  */\n-  tree decl_ptr;\n-  tree inits;\n-};\n-\n static int is_subobject_of_p (tree, tree);\n static base_kind lookup_base_r (tree, tree, base_access, bool, tree *);\n static int dynamic_cast_base_recurse (tree, tree, bool, tree *);\n-static tree dfs_debug_unmarkedp (tree, int, void *);\n static tree dfs_debug_mark (tree, void *);\n+static tree dfs_walk_once_r (tree, tree (*pre_fn) (tree, void *),\n+\t\t\t     tree (*post_fn) (tree, void *), void *data);\n+static void dfs_unmark_r (tree);\n static int check_hidden_convs (tree, int, int, tree, tree, tree);\n static tree split_conversions (tree, tree, tree, tree);\n static int lookup_conversions_r (tree, int, int,\n \t\t\t\t tree, tree, tree, tree, tree *, tree *);\n static int look_for_overrides_r (tree, tree);\n-static tree lookup_field_queue_p (tree, int, void *);\n static tree lookup_field_r (tree, void *);\n-static tree dfs_accessible_queue_p (tree, int, void *);\n-static tree dfs_accessible_p (tree, void *);\n+static tree accessible_r (tree, bool);\n static tree dfs_access_in_type (tree, void *);\n static access_kind access_in_type (tree, tree);\n static int protected_accessible_p (tree, tree, tree);\n@@ -663,10 +654,6 @@ dfs_access_in_type (tree binfo, void *data)\n   /* Note the access to DECL in TYPE.  */\n   SET_BINFO_ACCESS (binfo, access);\n \n-  /* Mark TYPE as visited so that if we reach it again we do not\n-     duplicate our efforts here.  */\n-  BINFO_MARKED (binfo) = 1;\n-\n   return NULL_TREE;\n }\n \n@@ -688,47 +675,11 @@ access_in_type (tree type, tree decl)\n     The algorithm we use is to make a post-order depth-first traversal\n     of the base-class hierarchy.  As we come up the tree, we annotate\n     each node with the most lenient access.  */\n-  dfs_walk_real (binfo, 0, dfs_access_in_type, unmarkedp, decl);\n-  dfs_walk (binfo, dfs_unmark, markedp,  0);\n+  dfs_walk_once (binfo, NULL, dfs_access_in_type, decl);\n \n   return BINFO_ACCESS (binfo);\n }\n \n-/* Called from accessible_p via dfs_walk.  */\n-\n-static tree\n-dfs_accessible_queue_p (tree derived, int ix, void *data ATTRIBUTE_UNUSED)\n-{\n-  tree binfo = BINFO_BASE_BINFO (derived, ix);\n-  \n-  if (BINFO_MARKED (binfo))\n-    return NULL_TREE;\n-\n-  /* If this class is inherited via private or protected inheritance,\n-     then we can't see it, unless we are a friend of the derived class.  */\n-  if (BINFO_BASE_ACCESS (derived, ix) != access_public_node\n-      && !is_friend (BINFO_TYPE (derived), current_scope ()))\n-    return NULL_TREE;\n-\n-  return binfo;\n-}\n-\n-/* Called from accessible_p via dfs_walk.  */\n-\n-static tree\n-dfs_accessible_p (tree binfo, void *data ATTRIBUTE_UNUSED)\n-{\n-  access_kind access;\n-\n-  BINFO_MARKED (binfo) = 1;\n-  access = BINFO_ACCESS (binfo);\n-  if (access != ak_none\n-      && is_friend (BINFO_TYPE (binfo), current_scope ()))\n-    return binfo;\n-\n-  return NULL_TREE;\n-}\n-\n /* Returns nonzero if it is OK to access DECL through an object\n    indicated by BINFO in the context of DERIVED.  */\n \n@@ -855,6 +806,43 @@ friend_accessible_p (tree scope, tree decl, tree binfo)\n   return 0;\n }\n \n+static tree\n+accessible_r (tree binfo, bool once)\n+{\n+  tree rval = NULL_TREE;\n+  unsigned ix;\n+  tree base_binfo;\n+  \n+  /* Find the next child binfo to walk.  */\n+  for (ix = 0; BINFO_BASE_ITERATE (binfo, ix, base_binfo); ix++)\n+    {\n+      bool mark = once && BINFO_VIRTUAL_P (base_binfo);\n+\n+      if (mark && BINFO_MARKED (base_binfo))\n+\tcontinue;\n+  \n+      /* If the base is inherited via private or protected\n+     \t inheritance, then we can't see it, unless we are a friend of\n+     \t the current binfo.  */\n+      if (BINFO_BASE_ACCESS (binfo, ix) != access_public_node\n+\t  && !is_friend (BINFO_TYPE (binfo), current_scope ()))\n+\tcontinue;\n+\n+      if (mark)\n+\tBINFO_MARKED (base_binfo) = 1;\n+\n+      rval = accessible_r (base_binfo, once);\n+      if (rval)\n+\treturn rval;\n+    }\n+  \n+  if (BINFO_ACCESS (binfo) != ak_none\n+      && is_friend (BINFO_TYPE (binfo), current_scope ()))\n+    rval = binfo;\n+  \n+  return rval;\n+}\n+\n /* DECL is a declaration from a base class of TYPE, which was the\n    class used to name DECL.  Return nonzero if, in the current\n    context, DECL is accessible.  If TYPE is actually a BINFO node,\n@@ -941,12 +929,28 @@ accessible_p (tree type, tree decl)\n     {\n       /* Walk the hierarchy again, looking for a base class that allows\n \t access.  */\n-      t = dfs_walk (binfo, dfs_accessible_p, dfs_accessible_queue_p, 0);\n-      /* Clear any mark bits.  Note that we have to walk the whole tree\n-\t here, since we have aborted the previous walk from some point\n-\t deep in the tree.  */\n-      dfs_walk (binfo, dfs_unmark, 0,  0);\n+      t = accessible_r\n+\t(binfo, CLASSTYPE_DIAMOND_SHAPED_P (BINFO_TYPE (binfo)));\n \n+      if (!CLASSTYPE_DIAMOND_SHAPED_P (BINFO_TYPE (binfo)))\n+\t;/* We are not diamond shaped, and therefore cannot\n+\t    encounter the same binfo twice.  */\n+      else if (!BINFO_INHERITANCE_CHAIN (binfo))\n+\t{\n+\t  /* We are at the top of the hierachy, and can use the\n+             CLASSTYPE_VBASECLASSES list for unmarking the virtual\n+             bases.  */\n+\t  VEC (tree) *vbases;\n+\t  unsigned ix;\n+\t  tree base_binfo;\n+\t  \n+\t  for (vbases = CLASSTYPE_VBASECLASSES (BINFO_TYPE (binfo)), ix = 0;\n+\t       VEC_iterate (tree, vbases, ix, base_binfo); ix++)\n+\t    BINFO_MARKED (base_binfo) = 0;\n+\t}\n+      else\n+\tdfs_unmark_r (binfo);\n+      \n       return t != NULL_TREE;\n     }\n }\n@@ -969,33 +973,6 @@ struct lookup_field_info {\n   const char *errstr;\n };\n \n-/* Returns nonzero if BINFO is not hidden by the value found by the\n-   lookup so far.  If BINFO is hidden, then there's no need to look in\n-   it.  DATA is really a struct lookup_field_info.  Called from\n-   lookup_field via breadth_first_search.  */\n-\n-static tree\n-lookup_field_queue_p (tree derived, int ix, void *data)\n-{\n-  tree binfo = BINFO_BASE_BINFO (derived, ix);\n-  struct lookup_field_info *lfi = (struct lookup_field_info *) data;\n-\n-  /* Don't look for constructors or destructors in base classes.  */\n-  if (IDENTIFIER_CTOR_OR_DTOR_P (lfi->name))\n-    return NULL_TREE;\n-\n-  /* If this base class is hidden by the best-known value so far, we\n-     don't need to look.  */\n-  if (lfi->rval_binfo && derived == lfi->rval_binfo)\n-    return NULL_TREE;\n-\n-  /* If this is a dependent base, don't look in it.  */\n-  if (BINFO_DEPENDENT_BASE_P (binfo))\n-    return NULL_TREE;\n-  \n-  return binfo;\n-}\n-\n /* Within the scope of a template class, you can refer to the to the\n    current specialization with the name of the template itself.  For\n    example:\n@@ -1075,6 +1052,16 @@ lookup_field_r (tree binfo, void *data)\n   tree type = BINFO_TYPE (binfo);\n   tree nval = NULL_TREE;\n \n+  /* If this is a dependent base, don't look in it.  */\n+  if (BINFO_DEPENDENT_BASE_P (binfo))\n+    return NULL_TREE;\n+  \n+  /* If this base class is hidden by the best-known value so far, we\n+     don't need to look.  */\n+  if (lfi->rval_binfo && BINFO_INHERITANCE_CHAIN (binfo) == lfi->rval_binfo\n+      && !BINFO_VIRTUAL_P (binfo))\n+    return dfs_skip_bases;\n+\n   /* First, look for a function.  There can't be a function and a data\n      member with the same name, and if there's a function and a type\n      with the same name, the type is hidden by the function.  */\n@@ -1092,7 +1079,7 @@ lookup_field_r (tree binfo, void *data)\n   /* If there is no declaration with the indicated name in this type,\n      then there's nothing to do.  */\n   if (!nval)\n-    return NULL_TREE;\n+    goto done;\n \n   /* If we're looking up a type (as with an elaborated type specifier)\n      we ignore all non-types we find.  */\n@@ -1119,14 +1106,14 @@ lookup_field_r (tree binfo, void *data)\n \t  if (e != NULL)\n \t    nval = TYPE_MAIN_DECL (e->type);\n \t  else \n-\t    return NULL_TREE;\n+\t    goto done;\n \t}\n     }\n \n   /* You must name a template base class with a template-id.  */\n   if (!same_type_p (type, lfi->type) \n       && template_self_reference_p (type, nval))\n-    return NULL_TREE;\n+    goto done;\n \n   /* If the lookup already found a match, and the new value doesn't\n      hide the old one, we might have an ambiguity.  */\n@@ -1165,6 +1152,10 @@ lookup_field_r (tree binfo, void *data)\n       lfi->rval_binfo = binfo;\n     }\n \n+ done:\n+  /* Don't look for constructors or destructors in base classes.  */\n+  if (IDENTIFIER_CTOR_OR_DTOR_P (lfi->name))\n+    return dfs_skip_bases;\n   return NULL_TREE;\n }\n \n@@ -1251,8 +1242,7 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type)\n   lfi.type = type;\n   lfi.name = name;\n   lfi.want_type = want_type;\n-  dfs_walk_real (basetype_path, &lookup_field_r, 0,\n-\t\t &lookup_field_queue_p, &lfi);\n+  dfs_walk_all (basetype_path, &lookup_field_r, NULL, &lfi);\n   rval = lfi.rval;\n   rval_binfo = lfi.rval_binfo;\n   if (rval_binfo)\n@@ -1526,66 +1516,158 @@ adjust_result_of_qualified_name_lookup (tree decl,\n \n \f\n /* Walk the class hierarchy within BINFO, in a depth-first traversal.\n-   PREFN is called in preorder, while POSTFN is called in postorder.\n-   If they ever returns a non-NULL value, that value is immediately\n-   returned and the walk is terminated.  Both PREFN and POSTFN can be\n-   NULL.  At each node, PREFN and POSTFN are passed the binfo to\n-   examine.  Before each base-binfo of BINFO is walked, QFN is called.\n-   If the value returned is nonzero, the base-binfo is walked;\n-   otherwise it is not.  If QFN is NULL, it is treated as a function\n-   which always returns 1.  All callbacks are passed DATA whenever\n-   they are called.  */\n+   PRE_FN is called in preorder, while POST_FN is called in postorder.\n+   If PRE_FN returns DFS_SKIP_BASES, child binfos will not be\n+   walked.  If PRE_FN or POST_FN returns a different non-NULL value,\n+   that value is immediately returned and the walk is terminated.  One\n+   of PRE_FN and POST_FN can be NULL.  At each node, PRE_FN and\n+   POST_FN are passed the binfo to examine and the caller's DATA\n+   value.  All paths are walked, thus virtual and morally virtual\n+   binfos can be multiply walked.  */\n \n tree\n-dfs_walk_real (tree binfo,\n-\t       tree (*prefn) (tree, void *),\n-\t       tree (*postfn) (tree, void *),\n-\t       tree (*qfn) (tree, int, void *),\n-\t       void *data)\n+dfs_walk_all (tree binfo, tree (*pre_fn) (tree, void *),\n+\t      tree (*post_fn) (tree, void *), void *data)\n {\n-  int i;\n+  tree rval;\n+  unsigned ix;\n   tree base_binfo;\n-  tree rval = NULL_TREE;\n-\n+  \n   /* Call the pre-order walking function.  */\n-  if (prefn)\n+  if (pre_fn)\n+    {\n+      rval = pre_fn (binfo, data);\n+      if (rval)\n+\t{\n+\t  if (rval == dfs_skip_bases)\n+\t    goto skip_bases;\n+\t  return rval;\n+\t}\n+    }\n+\n+  /* Find the next child binfo to walk.  */\n+  for (ix = 0; BINFO_BASE_ITERATE (binfo, ix, base_binfo); ix++)\n     {\n-      rval = (*prefn) (binfo, data);\n+      rval = dfs_walk_all (base_binfo, pre_fn, post_fn, data);\n       if (rval)\n \treturn rval;\n     }\n \n-  /* Process the basetypes.  */\n-  for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+ skip_bases:\n+  /* Call the post-order walking function.  */\n+  if (post_fn)\n+    return post_fn (binfo, data);\n+  return NULL_TREE;\n+}\n+\n+/* Worker for dfs_walk_once.  This behaves as dfs_walk_all, except\n+   that binfos are walked at most once.  */\n+\n+static tree\n+dfs_walk_once_r (tree binfo, tree (*pre_fn) (tree, void *),\n+\t\t tree (*post_fn) (tree, void *), void *data)\n+{\n+  tree rval;\n+  unsigned ix;\n+  tree base_binfo;\n+  \n+  /* Call the pre-order walking function.  */\n+  if (pre_fn)\n     {\n-      if (qfn)\n+      rval = pre_fn (binfo, data);\n+      if (rval)\n \t{\n-\t  base_binfo = (*qfn) (binfo, i, data);\n-\t  if (!base_binfo)\n+\t  if (rval == dfs_skip_bases)\n+\t    goto skip_bases;\n+\t  \n+\t  return rval;\n+\t}\n+    }\n+\n+  /* Find the next child binfo to walk.  */\n+  for (ix = 0; BINFO_BASE_ITERATE (binfo, ix, base_binfo); ix++)\n+    {\n+      if (BINFO_VIRTUAL_P (base_binfo))\n+\t{\n+\t  if (BINFO_MARKED (base_binfo))\n \t    continue;\n+\t  BINFO_MARKED (base_binfo) = 1;\n \t}\n-      rval = dfs_walk_real (base_binfo, prefn, postfn, qfn, data);\n+  \n+      rval = dfs_walk_once_r (base_binfo, pre_fn, post_fn, data);\n       if (rval)\n \treturn rval;\n     }\n-\n+  \n+ skip_bases:\n   /* Call the post-order walking function.  */\n-  if (postfn)\n-    rval = (*postfn) (binfo, data);\n+  if (post_fn)\n+    return post_fn (binfo, data);\n   \n-  return rval;\n+  return NULL_TREE;\n }\n \n-/* Exactly like dfs_walk_real, except that there is no pre-order\n-   function call and  FN is called in post-order.  */\n+/* Worker for dfs_walk_once. Recursively unmark the virtual base binfos of\n+   BINFO.  */\n+   \n+static void\n+dfs_unmark_r (tree binfo)\n+{\n+  unsigned ix;\n+  tree base_binfo;\n+  \n+  /* Process the basetypes.  */\n+  for (ix = 0; BINFO_BASE_ITERATE (binfo, ix, base_binfo); ix++)\n+    {\n+      if (BINFO_VIRTUAL_P (base_binfo))\n+\t{\n+\t  if (!BINFO_MARKED (base_binfo))\n+\t    continue;\n+\t  BINFO_MARKED (base_binfo) = 0;\n+\t}\n+      /* Only walk, if it can contain more virtual bases.  */\n+      if (CLASSTYPE_VBASECLASSES (BINFO_TYPE (base_binfo)))\n+\tdfs_unmark_r (base_binfo);\n+    }\n+}\n+\n+/* Like dfs_walk_all, except that binfos are not multiply walked.  For\n+   non-diamond shaped hierarchies this is the same as dfs_walk_all.\n+   For diamond shaped hierarchies we must mark the virtual bases, to\n+   avoid multiple walks.  */\n \n tree\n-dfs_walk (tree binfo,\n-\t  tree (*fn) (tree, void *),\n-\t  tree (*qfn) (tree, int, void *),\n-\t  void *data)\n+dfs_walk_once (tree binfo, tree (*pre_fn) (tree, void *),\n+\t       tree (*post_fn) (tree, void *), void *data)\n {\n-  return dfs_walk_real (binfo, 0, fn, qfn, data);\n+  tree rval;\n+\n+  gcc_assert (pre_fn || post_fn);\n+  \n+  if (!CLASSTYPE_DIAMOND_SHAPED_P (BINFO_TYPE (binfo)))\n+    /* We are not diamond shaped, and therefore cannot encounter the\n+       same binfo twice.  */\n+    rval = dfs_walk_all (binfo, pre_fn, post_fn, data);\n+  else\n+    {\n+      rval = dfs_walk_once_r (binfo, pre_fn, post_fn, data);\n+      if (!BINFO_INHERITANCE_CHAIN (binfo))\n+\t{\n+\t  /* We are at the top of the hierachy, and can use the\n+             CLASSTYPE_VBASECLASSES list for unmarking the virtual\n+             bases.  */\n+\t  VEC (tree) *vbases;\n+\t  unsigned ix;\n+\t  tree base_binfo;\n+\t  \n+\t  for (vbases = CLASSTYPE_VBASECLASSES (BINFO_TYPE (binfo)), ix = 0;\n+\t       VEC_iterate (tree, vbases, ix, base_binfo); ix++)\n+\t    BINFO_MARKED (base_binfo) = 0;\n+\t}\n+      else\n+\tdfs_unmark_r (binfo);\n+    }\n+  return rval;\n }\n \n /* Check that virtual overrider OVERRIDER is acceptable for base function\n@@ -1805,8 +1887,6 @@ dfs_get_pure_virtuals (tree binfo, void *data)\n \t  VEC_safe_push (tree, CLASSTYPE_PURE_VIRTUALS (type),\n \t\t\t BV_FN (virtuals));\n     }\n-  \n-  BINFO_MARKED (binfo) = 1;\n \n   return NULL_TREE;\n }\n@@ -1825,39 +1905,8 @@ get_pure_virtuals (tree type)\n      (A primary base is not interesting because the derived class of\n      which it is a primary base will contain vtable entries for the\n      pure virtuals in the base class.  */\n-  dfs_walk (TYPE_BINFO (type), dfs_get_pure_virtuals, unmarkedp, type);\n-  dfs_walk (TYPE_BINFO (type), dfs_unmark, markedp, type);\n-}\n-\f\n-/* DEPTH-FIRST SEARCH ROUTINES.  */\n-\n-tree \n-markedp (tree derived, int ix, void *data ATTRIBUTE_UNUSED) \n-{\n-  tree binfo = BINFO_BASE_BINFO (derived, ix);\n-  \n-  return BINFO_MARKED (binfo) ? binfo : NULL_TREE; \n-}\n-\n-tree\n-unmarkedp (tree derived, int ix, void *data ATTRIBUTE_UNUSED) \n-{\n-  tree binfo = BINFO_BASE_BINFO (derived, ix);\n-  \n-  return !BINFO_MARKED (binfo) ? binfo : NULL_TREE; \n-}\n-\n-/* The worker functions for `dfs_walk'.  These do not need to\n-   test anything (vis a vis marking) if they are paired with\n-   a predicate function (above).  */\n-\n-tree\n-dfs_unmark (tree binfo, void *data ATTRIBUTE_UNUSED)\n-{\n-  BINFO_MARKED (binfo) = 0;\n-  return NULL_TREE;\n+  dfs_walk_once (TYPE_BINFO (type), NULL, dfs_get_pure_virtuals, type);\n }\n-\n \f\n /* Debug info for C++ classes can get very large; try to avoid\n    emitting it everywhere.\n@@ -1905,23 +1954,14 @@ dfs_debug_mark (tree binfo, void *data ATTRIBUTE_UNUSED)\n {\n   tree t = BINFO_TYPE (binfo);\n \n+  if (CLASSTYPE_DEBUG_REQUESTED (t))\n+    return dfs_skip_bases;\n+\n   CLASSTYPE_DEBUG_REQUESTED (t) = 1;\n \n   return NULL_TREE;\n }\n \n-/* Returns BINFO if we haven't already noted that we want debugging\n-   info for this base class.  */\n-\n-static tree \n-dfs_debug_unmarkedp (tree derived, int ix, void *data ATTRIBUTE_UNUSED)\n-{\n-  tree binfo = BINFO_BASE_BINFO (derived, ix);\n-  \n-  return (!CLASSTYPE_DEBUG_REQUESTED (BINFO_TYPE (binfo)) \n-\t  ? binfo : NULL_TREE);\n-}\n-\n /* Write out the debugging information for TYPE, whose vtable is being\n    emitted.  Also walk through our bases and note that we want to\n    write out information for them.  This avoids the problem of not\n@@ -1938,7 +1978,7 @@ note_debug_info_needed (tree type)\n       rest_of_type_compilation (type, toplevel_bindings_p ());\n     }\n \n-  dfs_walk (TYPE_BINFO (type), dfs_debug_mark, dfs_debug_unmarkedp, 0);\n+  dfs_walk_all (TYPE_BINFO (type), dfs_debug_mark, NULL, 0);\n }\n \f\n void"}]}