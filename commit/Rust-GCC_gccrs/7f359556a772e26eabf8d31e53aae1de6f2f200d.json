{"sha": "7f359556a772e26eabf8d31e53aae1de6f2f200d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2YzNTk1NTZhNzcyZTI2ZWFiZjhkMzFlNTNhYWUxZGU2ZjJmMjAwZA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-12-10T19:59:14Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-12-10T21:35:01Z"}, "message": "Reduce memory requirements for ranger\n\nCalculate block exit info upfront, and then any SSA_NAME which is never\nused in an outgoing range calculation is a pure global and can bypass the\non-entry cache.\n\n\tPR tree-optimization/98174\n\t* gimple-range-cache.cc (ranger_cache::ssa_range_in_bb): Only push\n\tpoor values to be examined if it isn't a pure global.\n\t(ranger_cache::block_range): Don't process pure globals.\n\t(ranger_cache::fill_block_cache): Adjust has_edge_range call.\n\t* gimple-range-gori.cc (gori_map::all_outgoing): New bitmap.\n\t(gori_map::gori_map): Allocate all_outgoing.\n\t(gori_map::is_export_p): No specified BB returns global context.\n\t(gori_map::calculate_gori): Accumulate each block into global.\n\t(gori_compute::gori_compute): Preprocess each block for exports.\n\t(gori_compute::has_edge_range_p): No edge returns global context.\n\t* gimple-range-gori.h (has_edge_range_p): Provide default parameter.", "tree": {"sha": "4d312d4baac672782765ef7cfa91b61d20eeb25a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d312d4baac672782765ef7cfa91b61d20eeb25a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f359556a772e26eabf8d31e53aae1de6f2f200d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f359556a772e26eabf8d31e53aae1de6f2f200d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f359556a772e26eabf8d31e53aae1de6f2f200d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f359556a772e26eabf8d31e53aae1de6f2f200d/comments", "author": null, "committer": null, "parents": [{"sha": "779bf1823ced0814803d2be7f7ded0317e70140c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/779bf1823ced0814803d2be7f7ded0317e70140c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/779bf1823ced0814803d2be7f7ded0317e70140c"}], "stats": {"total": 47, "additions": 39, "deletions": 8}, "files": [{"sha": "edebad45a50a4d82ad4cb292bc7023cbfe5a5734", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f359556a772e26eabf8d31e53aae1de6f2f200d/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f359556a772e26eabf8d31e53aae1de6f2f200d/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=7f359556a772e26eabf8d31e53aae1de6f2f200d", "patch": "@@ -779,8 +779,10 @@ ranger_cache::ssa_range_in_bb (irange &r, tree name, basic_block bb)\n   // Look for the on-entry value of name in BB from the cache.\n   else if (!m_on_entry.get_bb_range (r, name, bb))\n     {\n-      // If it has no entry then mark this as a poor value.\n-      if (push_poor_value (bb, name))\n+      // If it has no entry but should, then mark this as a poor value.\n+      // Its not a poor value if it does not have *any* edge ranges,\n+      // Then global range is as good as it gets.\n+      if (has_edge_range_p (name) && push_poor_value (bb, name))\n \t{\n \t  if (DEBUG_RANGE_CACHE)\n \t    {\n@@ -812,6 +814,11 @@ ranger_cache::block_range (irange &r, basic_block bb, tree name, bool calc)\n {\n   gcc_checking_assert (gimple_range_ssa_p (name));\n \n+  // If there are no range calculations anywhere in the IL, global range\n+  // applies everywhere, so don't bother caching it.\n+  if (!has_edge_range_p (name))\n+    return false;\n+\n   if (calc)\n     {\n       gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n@@ -1072,7 +1079,7 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n \t    {\n \t      if (DEBUG_RANGE_CACHE)\n \t\tfprintf (dump_file, \"has cache, \");\n-\t      if (!r.undefined_p () || has_edge_range_p (e, name))\n+\t      if (!r.undefined_p () || has_edge_range_p (name, e))\n \t\t{\n \t\t  add_to_update (node);\n \t\t  if (DEBUG_RANGE_CACHE)"}, {"sha": "ac13718f7e63d9c4915fe500a38a12c0e3997a2b", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f359556a772e26eabf8d31e53aae1de6f2f200d/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f359556a772e26eabf8d31e53aae1de6f2f200d/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=7f359556a772e26eabf8d31e53aae1de6f2f200d", "patch": "@@ -229,17 +229,18 @@ class gori_map : public range_def_chain\n   gori_map ();\n   ~gori_map ();\n \n-  bool is_export_p (tree name, basic_block bb);\n+  bool is_export_p (tree name, basic_block bb = NULL);\n   bool def_chain_in_export_p (tree name, basic_block bb);\n+  bitmap exports (basic_block bb);\n \n   void dump (FILE *f);\n   void dump (FILE *f, basic_block bb);\n private:\n   bitmap_obstack m_bitmaps;\n   vec<bitmap> m_outgoing;\t// BB: Outgoing ranges calculatable on edges\n+  bitmap all_outgoing;\t\t// All outgoing ranges combined. \n   void maybe_add_gori (tree name, basic_block bb);\n   void calculate_gori (basic_block bb);\n-  bitmap exports (basic_block bb);\n };\n \n \n@@ -250,6 +251,7 @@ gori_map::gori_map ()\n   m_outgoing.create (0);\n   m_outgoing.safe_grow_cleared (last_basic_block_for_fn (cfun));\n   bitmap_obstack_initialize (&m_bitmaps);\n+  all_outgoing = BITMAP_ALLOC (&m_bitmaps);\n }\n \n // Free any memory the GORI map allocated.\n@@ -276,6 +278,9 @@ gori_map::exports (basic_block bb)\n bool\n gori_map::is_export_p (tree name, basic_block bb)\n {\n+  // If no BB is specified, test if it is exported anywhere in the IL.\n+  if (!bb)\n+    return bitmap_bit_p (all_outgoing, SSA_NAME_VERSION (name));\n   return bitmap_bit_p (exports (bb), SSA_NAME_VERSION (name));\n }\n \n@@ -342,6 +347,8 @@ gori_map::calculate_gori (basic_block bb)\n       name = gimple_range_ssa_p (gimple_switch_index (gs));\n       maybe_add_gori (name, gimple_bb (stmt));\n     }\n+  // Add this bitmap to the aggregate list of all outgoing names.\n+  bitmap_ior_into (all_outgoing, m_outgoing[bb->index]);\n }\n \n // Dump the table information for BB to file F.\n@@ -438,6 +445,16 @@ gori_compute::gori_compute ()\n   m_bool_zero = int_range<2> (boolean_false_node, boolean_false_node);\n   m_bool_one = int_range<2> (boolean_true_node, boolean_true_node);\n   m_gori_map = new gori_map;\n+  unsigned x, lim = last_basic_block_for_fn (cfun);\n+  // Calculate outgoing range info upfront.  This will fully populate the\n+  // all_outgoing bitmap which will help eliminate processing of names\n+  // which never have their ranges adjusted.\n+  for (x = 0; x < lim ; x++)\n+    {\n+      basic_block bb = BASIC_BLOCK_FOR_FN (cfun, x);\n+      if (bb)\n+\tm_gori_map->exports (bb);\n+    }\n }\n \n // Destruct a gori_compute_object.\n@@ -969,8 +986,12 @@ gori_compute::compute_operand1_and_operand2_range\n // Return TRUE if a range can be calcalated for NAME on edge E.\n \n bool\n-gori_compute::has_edge_range_p (edge e, tree name)\n+gori_compute::has_edge_range_p (tree name, edge e)\n {\n+  // If no edge is specified, check if NAME is an export on any edge.\n+  if (!e)\n+    return m_gori_map->is_export_p (name);\n+\n   return (m_gori_map->is_export_p (name, e->src)\n \t  || m_gori_map->def_chain_in_export_p (name, e->src));\n }"}, {"sha": "6cbf532c43561cd0b8d20956722e774bb2b18daa", "filename": "gcc/gimple-range-gori.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f359556a772e26eabf8d31e53aae1de6f2f200d/gcc%2Fgimple-range-gori.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f359556a772e26eabf8d31e53aae1de6f2f200d/gcc%2Fgimple-range-gori.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.h?ref=7f359556a772e26eabf8d31e53aae1de6f2f200d", "patch": "@@ -29,10 +29,13 @@ along with GCC; see the file COPYING3.  If not see\n //\n // There are 2 primary entry points:\n //\n-// has_edge_range_p (edge e, tree name)  \n+// has_edge_range_p (tree name, edge e)\n //   returns true if the outgoing edge *may* be able to produce range\n //   information for ssa_name NAME on edge E.\n //   FALSE is returned if this edge does not affect the range of NAME.\n+//   if no edge is specified, return TRUE if name may have a value calculated\n+//   on *ANY* edge that has been seen.  FALSE indicates that the global value\n+//   is applicable everywhere that has been processed.\n //\n // outgoing_edge_range_p (irange &range, edge e, tree name)\n //   Actually does the calculation of RANGE for name on E\n@@ -68,7 +71,7 @@ class gori_compute\n   gori_compute ();\n   ~gori_compute ();\n   bool outgoing_edge_range_p (irange &r, edge e, tree name);\n-  bool has_edge_range_p (edge e, tree name);\n+  bool has_edge_range_p (tree name, edge e = NULL);\n   void dump (FILE *f);\n protected:\n   virtual void ssa_range_in_bb (irange &r, tree name, basic_block bb);"}]}