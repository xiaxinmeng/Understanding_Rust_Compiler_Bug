{"sha": "313465bbbd04019184339161f0e30a46a5c0e4ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzEzNDY1YmJiZDA0MDE5MTg0MzM5MTYxZjBlMzBhNDZhNWMwZTRhYg==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2012-10-12T15:17:17Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2012-10-12T15:17:17Z"}, "message": "Add more C++ support in gengtype.\n\nThis patch combines the changes from\nhttp://gcc.gnu.org/ml/gcc-patches/2012-08/msg02016.html with other\nadditions to support C++ inside GTY'd structures.\n\nThe main changes wrt Aaron's original patch are:\n\n- Support for function declarations inside classes.\n\n- Support scoping in identifiers.  This does not mean that gengtype\n  supports scopes, it just knows that 'Foo::id' is a single entity.\n\n- Explicit non-support for typedef and enum inside class/struct.\n  Since gengtype does not really know about scopes, it cannot\n  understand these types, but it knows enough to recognize and reject\n  them.  GTY'd struct/class that need to typedef their own types\n  should use GTY((user)).\n\n- Documentation on what is and is not supported.\n\nThere is one check I needed to remove that gave me some trouble.\nWhen a ctor is detected, we have already parsed the name of the\nctor as a type, which is then registered in the list of structures.\n\nWe go on to recognize it as a ctor *after* the type has been\nregistered.  We reject the field in declarator() and it is never\nadded to the list of fields for the class.\n\nHowever, when we reach the end of the class, we find that the\ntype we created while parsing the ctor has line number\ninformation in it (the line where the ctor was) and gengtype\nthinks that it is a duplicate structure definition.\n\nI took out this check for two reasons: (a) It is actually\nunnecessary because if there were really duplicate definitions of\nthis structure, the code would not compile, and (b) all the other\nalternatives required making the parser much more convoluted and\nI'm trying hard not to make gengtype parser too smart.\n\n2012-10-12  Aaron Gray <aaronngray.lists@gmail.com>\n\t    Diego Novillo <dnovillo@google.com>\n\n        * gengtype-lex.l: Support for C++ single line comments.\n        Support for classes.\n\t(CXX_KEYWORD): New.  Support C++ keywords inline, public,\n\tprotected, private, template, operator, friend, &, ~.\n\t(TYPEDEF): New.  Support typedef.\n        * gengtype-parser.c: updated 'token_names[]'\n        (direct_declarator): Add support for parsing functions\n\tand ctors.\n\n2012-10-12  Diego Novillo  <dnovillo@google.com>\n\n\t* doc/gty.texi: Document C++ limitations in gengtype.\n\t* gengtype-lex.l (CID): Rename from ID.\n\t(ID): Include scoping '::' as part of the identifier name.\n\t* gengtype-parse.c (token_names): Update.\n\t(token_value_format): Update.\n\t(consume_until_eos): Rename from consume_until_semi.\n\tRemove unused argument IMMEDIATE.  Update all callers.\n\tAlso consider '}' as a finalizer.\n\t(consume_until_comma_or_eos): Rename from\n\tconsume_until_comma_or_semi.\n\tRemove unused argument IMMEDIATE.  Update all callers.\n\tAlso consider '}' as a finalizer.\n\t(direct_declarator): Add documentation on ctor support.\n\tAdd argument IN_STRUCT.\n\tIf the token following ID is a '(', consider ID a\n\tfunction and return NULL.\n\tIf the token following '(' is not a '*', and IN_STRUCT is\n\ttrue, conclude that this is a ctor and return NULL.\n\tIf the token is IGNORABLE_CXX_KEYWORD, return NULL.\n\t(inner_declarator): Add argument IN_STRUCT.\n\tUpdate all callers.\n\t(declarator): Add argument IN_STRUCT with default value\n\tfalse.  Update all callers.\n\t(type): Document argument NESTED.\n\tSkip over C++ inheritance specifiers.\n\tIf a token TYPEDEF is found, emit an error.\n\tIf an enum is found inside a class/structure, emit an\n\terror.\n\t(typedefs, structures, param_structs, variables): Initialize.\n\t(new_structure): Do not complain about duplicate\n\tstructures if S has a line location set.\n\t* gengtype-state.c (write_state_type): Remove default\n\thandler.  Add handler for TYPE_NONE.\n\t(read_state_scalar_char_type):\n\t* gengtype.c: Fix spacing.\n\t* gengtype.h (enum gty_token): Add name.  Add token\n\tIGNORABLE_CXX_KEYWORD.\n\nFrom-SVN: r192405", "tree": {"sha": "3f1c4b6afbebcb24454c2dce4ca0c8c5934987c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f1c4b6afbebcb24454c2dce4ca0c8c5934987c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/313465bbbd04019184339161f0e30a46a5c0e4ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/313465bbbd04019184339161f0e30a46a5c0e4ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/313465bbbd04019184339161f0e30a46a5c0e4ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/313465bbbd04019184339161f0e30a46a5c0e4ab/comments", "author": null, "committer": null, "parents": [{"sha": "b09e6a7074c0ff5ee74dd0735d5fb10ac450976a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b09e6a7074c0ff5ee74dd0735d5fb10ac450976a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b09e6a7074c0ff5ee74dd0735d5fb10ac450976a"}], "stats": {"total": 372, "additions": 279, "deletions": 93}, "files": [{"sha": "c948ab1607a8d0345c96f4f8e9091d4f2b9a33e4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313465bbbd04019184339161f0e30a46a5c0e4ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313465bbbd04019184339161f0e30a46a5c0e4ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=313465bbbd04019184339161f0e30a46a5c0e4ab", "patch": "@@ -1,3 +1,55 @@\n+2012-10-12  Aaron Gray <aaronngray.lists@gmail.com>\n+\t    Diego Novillo <dnovillo@google.com>\n+\n+        * gengtype-lex.l: Support for C++ single line comments.\n+        Support for classes.\n+\t(CXX_KEYWORD): New.  Support C++ keywords inline, public,\n+\tprotected, private, template, operator, friend, &, ~.\n+\t(TYPEDEF): New.  Support typedef.\n+        * gengtype-parser.c: updated 'token_names[]'\n+        (direct_declarator): Add support for parsing functions\n+\tand ctors.\n+\n+2012-10-12  Diego Novillo  <dnovillo@google.com>\n+\n+\t* doc/gty.texi: Document C++ limitations in gengtype.\n+\t* gengtype-lex.l (CID): Rename from ID.\n+\t(ID): Include scoping '::' as part of the identifier name.\n+\t* gengtype-parse.c (token_names): Update.\n+\t(token_value_format): Update.\n+\t(consume_until_eos): Rename from consume_until_semi.\n+\tRemove unused argument IMMEDIATE.  Update all callers.\n+\tAlso consider '}' as a finalizer.\n+\t(consume_until_comma_or_eos): Rename from\n+\tconsume_until_comma_or_semi.\n+\tRemove unused argument IMMEDIATE.  Update all callers.\n+\tAlso consider '}' as a finalizer.\n+\t(direct_declarator): Add documentation on ctor support.\n+\tAdd argument IN_STRUCT.\n+\tIf the token following ID is a '(', consider ID a\n+\tfunction and return NULL.\n+\tIf the token following '(' is not a '*', and IN_STRUCT is\n+\ttrue, conclude that this is a ctor and return NULL.\n+\tIf the token is IGNORABLE_CXX_KEYWORD, return NULL.\n+\t(inner_declarator): Add argument IN_STRUCT.\n+\tUpdate all callers.\n+\t(declarator): Add argument IN_STRUCT with default value\n+\tfalse.  Update all callers.\n+\t(type): Document argument NESTED.\n+\tSkip over C++ inheritance specifiers.\n+\tIf a token TYPEDEF is found, emit an error.\n+\tIf an enum is found inside a class/structure, emit an\n+\terror.\n+\t(typedefs, structures, param_structs, variables): Initialize.\n+\t(new_structure): Do not complain about duplicate\n+\tstructures if S has a line location set.\n+\t* gengtype-state.c (write_state_type): Remove default\n+\thandler.  Add handler for TYPE_NONE.\n+\t(read_state_scalar_char_type):\n+\t* gengtype.c: Fix spacing.\n+\t* gengtype.h (enum gty_token): Add name.  Add token\n+\tIGNORABLE_CXX_KEYWORD.\n+\n 2012-10-12  Chung-Lin Tang  <cltang@codesourcery.com>\n \n \t* config/arm/arm.md (get_thread_pointersi): Moved to place with"}, {"sha": "ea1a928c4ab7f5f45219088353ffd8958ddba1cd", "filename": "gcc/doc/gty.texi", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313465bbbd04019184339161f0e30a46a5c0e4ab/gcc%2Fdoc%2Fgty.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313465bbbd04019184339161f0e30a46a5c0e4ab/gcc%2Fdoc%2Fgty.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgty.texi?ref=313465bbbd04019184339161f0e30a46a5c0e4ab", "patch": "@@ -65,6 +65,27 @@ The parser understands simple typedefs such as\n @code{typedef int @var{name};}.\n These don't need to be marked.\n \n+Since @code{gengtype}'s understanding of C++ is limited, there are\n+several constructs and declarations that are not supported inside\n+classes/structures marked for automatic GC code generation.  The\n+following C++ constructs produce a @code{gengtype} error on\n+structures/classes marked for automatic GC code generation:\n+\n+@itemize @bullet\n+@item\n+Type definitions inside classes/structures are not supported.\n+@item\n+Enumerations inside classes/structures are not supported.\n+@end itemize\n+\n+If you have a class or structure using any of the above constructs,\n+you need to mark that class as @code{GTY ((user))} and provide your\n+own marking routines (see section @ref{User GC} for details).\n+\n+It is always valid to include function definitions inside classes.\n+Those are always ignored by @code{gengtype}, as it only cares about\n+data members.\n+\n @menu\n * GTY Options::         What goes inside a @code{GTY(())}.\n * GGC Roots::           Making global variables GGC roots."}, {"sha": "fd8090606d337eb016e813822f4d91064aef2638", "filename": "gcc/gengtype-lex.l", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313465bbbd04019184339161f0e30a46a5c0e4ab/gcc%2Fgengtype-lex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313465bbbd04019184339161f0e30a46a5c0e4ab/gcc%2Fgengtype-lex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-lex.l?ref=313465bbbd04019184339161f0e30a46a5c0e4ab", "patch": "@@ -50,12 +50,15 @@ update_lineno (const char *l, size_t len)\n \n %}\n \n-ID\t[[:alpha:]_][[:alnum:]_]*\n+CID\t[[:alpha:]_][[:alnum:]_]*\n WS\t[[:space:]]+\n HWS\t[ \\t\\r\\v\\f]*\n IWORD\tshort|long|(un)?signed|char|int|HOST_WIDE_INT|HOST_WIDEST_INT|bool|size_t|BOOL_BITFIELD|CPPCHAR_SIGNED_T|ino_t|dev_t|HARD_REG_SET\n ITYPE\t{IWORD}({WS}{IWORD})*\n+    /* Include '::' in identifiers to capture C++ scope qualifiers.  */\n+ID\t{CID}({HWS}::{HWS}{CID})*\n EOID\t[^[:alnum:]_]\n+CXX_KEYWORD inline|public:|private:|protected:|template|operator|friend\n \n %x in_struct in_struct_comment in_comment\n %option warn noyywrap nounput nodefault perf-report\n@@ -83,6 +86,10 @@ EOID\t[^[:alnum:]_]\n   BEGIN(in_struct);\n   return UNION;\n }\n+^{HWS}class/{EOID} {\n+  BEGIN(in_struct);\n+  return STRUCT;\n+}\n ^{HWS}extern/{EOID} {\n   BEGIN(in_struct);\n   return EXTERN;\n@@ -93,18 +100,27 @@ EOID\t[^[:alnum:]_]\n }\n }\n \n+    /* Parsing inside a struct, union or class declaration.  */\n <in_struct>{\n-\n \"/*\"\t\t\t\t{ BEGIN(in_struct_comment); }\n+\"//\".*\\n\t\t\t{ lexer_line.line++; }\n \n {WS}\t\t\t\t{ update_lineno (yytext, yyleng); }\n \\\\\\n\t\t\t\t{ lexer_line.line++; }\n \n \"const\"/{EOID}\t\t\t/* don't care */\n+{CXX_KEYWORD}/{EOID}\t\t\t|\n+\"~\"\t\t\t\t\t|\n+\"&\"\t\t\t\t\t{\n+    *yylval = XDUPVAR (const char, yytext, yyleng, yyleng + 1);\n+    return IGNORABLE_CXX_KEYWORD;\n+}\n \"GTY\"/{EOID}\t\t\t{ return GTY_TOKEN; }\n \"VEC\"/{EOID}\t\t\t{ return VEC_TOKEN; }\n \"union\"/{EOID}\t\t\t{ return UNION; }\n \"struct\"/{EOID}\t\t\t{ return STRUCT; }\n+\"class\"/{EOID}\t\t\t{ return STRUCT; }\n+\"typedef\"/{EOID}\t\t{ return TYPEDEF; }\n \"enum\"/{EOID}\t\t\t{ return ENUM; }\n \"ptr_alias\"/{EOID}\t  \t{ return PTR_ALIAS; }\n \"nested_ptr\"/{EOID}\t\t{ return NESTED_PTR; }\n@@ -127,7 +143,6 @@ EOID\t[^[:alnum:]_]\n   return SCALAR;\n }\n \n-\n {ID}/{EOID}\t\t\t{\n   *yylval = XDUPVAR (const char, yytext, yyleng, yyleng+1);\n   return ID;\n@@ -148,7 +163,7 @@ EOID\t[^[:alnum:]_]\n }\n \n \"...\"\t\t\t\t{ return ELLIPSIS; }\n-[(){},*:<>;=%|-]\t\t{ return yytext[0]; }\n+[(){},*:<>;=%|+-]\t\t{ return yytext[0]; }\n \n    /* ignore pp-directives */\n ^{HWS}\"#\"{HWS}[a-z_]+[^\\n]*\\n   {lexer_line.line++;}\n@@ -159,6 +174,7 @@ EOID\t[^[:alnum:]_]\n }\n \n \"/*\"\t\t\t{ BEGIN(in_comment); }\n+\"//\".*\\n\t\t{ lexer_line.line++; }\n \\n\t\t\t{ lexer_line.line++; }\n {ID}\t\t\t|\n \"'\"(\"\\\\\".|[^\\\\])\"'\"\t|\n@@ -172,6 +188,7 @@ EOID\t[^[:alnum:]_]\n [^*\\n]\t\t/* do nothing */\n \"*\"/[^/]\t/* do nothing */\n }\n+\n <in_comment>\"*/\"\t{ BEGIN(INITIAL); } \n <in_struct_comment>\"*/\"\t{ BEGIN(in_struct); }\n "}, {"sha": "5737a156f70b187f7893a540f8ad7a93e3f51e13", "filename": "gcc/gengtype-parse.c", "status": "modified", "additions": 142, "deletions": 44, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313465bbbd04019184339161f0e30a46a5c0e4ab/gcc%2Fgengtype-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313465bbbd04019184339161f0e30a46a5c0e4ab/gcc%2Fgengtype-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-parse.c?ref=313465bbbd04019184339161f0e30a46a5c0e4ab", "patch": "@@ -87,6 +87,7 @@ static const char *const token_names[] = {\n   \"a string constant\",\n   \"a character constant\",\n   \"an array declarator\",\n+  \"a C++ keyword to ignore\"\n };\n \n /* This array is indexed by token code minus FIRST_TOKEN_WITH_VALUE.  */\n@@ -98,6 +99,7 @@ static const char *const token_value_format[] = {\n   \"'\\\"%s\\\"'\",\n   \"\\\"'%s'\\\"\",\n   \"'[%s]'\",\n+  \"'%s'\",\n };\n \n /* Produce a printable representation for a token defined by CODE and\n@@ -313,78 +315,77 @@ consume_balanced (int opener, int closer)\n }\n \n /* Absorb a sequence of tokens, possibly including ()[]{}-delimited\n-   expressions, until we encounter a semicolon outside any such\n-   delimiters; absorb that too.  If IMMEDIATE is true, it is an error\n-   if the semicolon is not the first token encountered.  */\n+   expressions, until we encounter an end-of-statement marker (a ';' or\n+   a '}') outside any such delimiters; absorb that too.  */\n+\n static void\n-consume_until_semi (bool immediate)\n+consume_until_eos (void)\n {\n-  if (immediate && token () != ';')\n-    require (';');\n   for (;;)\n     switch (token ())\n       {\n       case ';':\n \tadvance ();\n \treturn;\n-      default:\n-\tadvance ();\n-\tbreak;\n+\n+      case '{':\n+\tconsume_balanced ('{', '}');\n+\treturn;\n \n       case '(':\n \tconsume_balanced ('(', ')');\n \tbreak;\n+\n       case '[':\n \tconsume_balanced ('[', ']');\n \tbreak;\n-      case '{':\n-\tconsume_balanced ('{', '}');\n-\tbreak;\n \n       case '}':\n       case ']':\n       case ')':\n \tparse_error (\"unmatched '%c' while scanning for ';'\", token ());\n-      return;\n+\treturn;\n \n       case EOF_TOKEN:\n \tparse_error (\"unexpected end of file while scanning for ';'\");\n \treturn;\n+\n+      default:\n+\tadvance ();\n+\tbreak;\n       }\n }\n \n /* Absorb a sequence of tokens, possibly including ()[]{}-delimited\n    expressions, until we encounter a comma or semicolon outside any\n-   such delimiters; absorb that too.  If IMMEDIATE is true, it is an\n-   error if the comma or semicolon is not the first token encountered.\n-   Returns true if the loop ended with a comma.  */\n+   such delimiters; absorb that too.  Returns true if the loop ended\n+   with a comma.  */\n+\n static bool\n-consume_until_comma_or_semi (bool immediate)\n+consume_until_comma_or_eos ()\n {\n-  if (immediate && token () != ',' && token () != ';')\n-    require2 (',', ';');\n   for (;;)\n     switch (token ())\n       {\n       case ',':\n \tadvance ();\n \treturn true;\n+\n       case ';':\n \tadvance ();\n \treturn false;\n-      default:\n-\tadvance ();\n-\tbreak;\n+\n+      case '{':\n+\tconsume_balanced ('{', '}');\n+\treturn false;\n \n       case '(':\n \tconsume_balanced ('(', ')');\n \tbreak;\n+\n       case '[':\n \tconsume_balanced ('[', ']');\n \tbreak;\n-      case '{':\n-\tconsume_balanced ('{', '}');\n-\tbreak;\n \n       case '}':\n       case ']':\n@@ -396,6 +397,10 @@ consume_until_comma_or_semi (bool immediate)\n       case EOF_TOKEN:\n \tparse_error (\"unexpected end of file while scanning for ',' or ';'\");\n \treturn false;\n+\n+      default:\n+\tadvance ();\n+\tbreak;\n       }\n }\n \f\n@@ -548,6 +553,8 @@ gtymarker_opt (void)\n     return 0;\n   return gtymarker ();\n }\n+\n+\n \f\n /* Declarators. The logic here is largely lifted from c-parser.c.\n    Note that we do not have to process abstract declarators, which can\n@@ -584,16 +591,21 @@ array_and_function_declarators_opt (type_p ty)\n     return ty;\n }\n \n-static type_p inner_declarator (type_p, const char **, options_p *);\n+static type_p inner_declarator (type_p, const char **, options_p *, bool);\n \n /* direct_declarator:\n    '(' inner_declarator ')'\n+   '(' \\epsilon ')'\t<-- C++ ctors/dtors\n    gtymarker_opt ID array_and_function_declarators_opt\n \n    Subroutine of declarator, mutually recursive with inner_declarator;\n-   do not use elsewhere.  */\n+   do not use elsewhere.\n+\n+   IN_STRUCT is true if we are called while parsing structures or classes.  */\n+\n static type_p\n-direct_declarator (type_p ty, const char **namep, options_p *optsp)\n+direct_declarator (type_p ty, const char **namep, options_p *optsp,\n+\t\t   bool in_struct)\n {\n   /* The first token in a direct-declarator must be an ID, a\n      GTY marker, or an open parenthesis.  */\n@@ -602,18 +614,45 @@ direct_declarator (type_p ty, const char **namep, options_p *optsp)\n     case GTY_TOKEN:\n       *optsp = gtymarker ();\n       /* fall through */\n+\n     case ID:\n       *namep = require (ID);\n+      /* If the next token is '(', we are parsing a function declaration.\n+\t Functions are ignored by gengtype, so we return NULL.  */\n+      if (token () == '(')\n+\treturn NULL;\n       break;\n \n     case '(':\n+      /* If the declarator starts with a '(', we have three options.  We\n+\t are either parsing 'TYPE (*ID)' (i.e., a function pointer)\n+\t or 'TYPE(...)'.\n+\n+\t The latter will be a constructor iff we are inside a\n+\t structure or class.  Otherwise, it could be a typedef, but\n+\t since we explicitly reject typedefs inside structures, we can\n+\t assume that we found a ctor and return NULL.  */\n       advance ();\n-      ty = inner_declarator (ty, namep, optsp);\n+      if (in_struct && token () != '*')\n+\t{\n+\t  /* Found a constructor.  Find and consume the closing ')'.  */\n+\t  while (token () != ')')\n+\t    advance ();\n+\t  advance ();\n+\t  /* Tell the caller to ignore this.  */\n+\t  return NULL;\n+\t}\n+      ty = inner_declarator (ty, namep, optsp, in_struct);\n       require (')');\n       break;\n \n+    case IGNORABLE_CXX_KEYWORD:\n+      /* Any C++ keyword like 'operator' means that we are not looking\n+\t at a regular data declarator.  */\n+      return NULL;\n+\n     default:\n-      parse_error (\"expected '(', 'GTY', or an identifier, have %s\",\n+      parse_error (\"expected '(', ')', 'GTY', or an identifier, have %s\",\n \t\t   print_cur_token ());\n       /* Do _not_ advance if what we have is a close squiggle brace, as\n \t we will get much better error recovery that way.  */\n@@ -643,34 +682,42 @@ direct_declarator (type_p ty, const char **namep, options_p *optsp)\n    direct_declarator\n \n    Mutually recursive subroutine of direct_declarator; do not use\n-   elsewhere.  */\n+   elsewhere.\n+\n+   IN_STRUCT is true if we are called while parsing structures or classes.  */\n \n static type_p\n-inner_declarator (type_p ty, const char **namep, options_p *optsp)\n+inner_declarator (type_p ty, const char **namep, options_p *optsp,\n+\t\t  bool in_struct)\n {\n   if (token () == '*')\n     {\n       type_p inner;\n       advance ();\n-      inner = inner_declarator (ty, namep, optsp);\n+      inner = inner_declarator (ty, namep, optsp, in_struct);\n       if (inner == 0)\n \treturn 0;\n       else\n \treturn create_pointer (ty);\n     }\n   else\n-    return direct_declarator (ty, namep, optsp);\n+    return direct_declarator (ty, namep, optsp, in_struct);\n }\n \n /* declarator: '*'+ direct_declarator\n \n    This is the sole public interface to this part of the grammar.\n    Arguments are the type known so far, a pointer to where the name\n    may be stored, and a pointer to where GTY options may be stored.\n-   Returns the final type. */\n+\n+   IN_STRUCT is true when we are called to parse declarators inside\n+   a structure or class.\n+\n+   Returns the final type.  */\n \n static type_p\n-declarator (type_p ty, const char **namep, options_p *optsp)\n+declarator (type_p ty, const char **namep, options_p *optsp,\n+\t    bool in_struct = false)\n {\n   *namep = 0;\n   *optsp = 0;\n@@ -679,7 +726,7 @@ declarator (type_p ty, const char **namep, options_p *optsp)\n       advance ();\n       ty = create_pointer (ty);\n     }\n-  return direct_declarator (ty, namep, optsp);\n+  return direct_declarator (ty, namep, optsp, in_struct);\n }\n \f\n /* Types and declarations.  */\n@@ -708,18 +755,19 @@ struct_field_seq (void)\n \n       if (!ty || token () == ':')\n \t{\n-\t  consume_until_semi (false);\n+\t  consume_until_eos ();\n \t  continue;\n \t}\n \n       do\n \t{\n-\t  dty = declarator (ty, &name, &dopts);\n+\t  dty = declarator (ty, &name, &dopts, true);\n+\n \t  /* There could be any number of weird things after the declarator,\n \t     notably bitfield declarations and __attribute__s.  If this\n \t     function returns true, the last thing was a comma, so we have\n \t     more than one declarator paired with the current type.  */\n-\t  another = consume_until_comma_or_semi (false);\n+\t  another = consume_until_comma_or_eos ();\n \n \t  if (!dty)\n \t    continue;\n@@ -760,7 +808,12 @@ opts_have (options_p opts, const char *str)\n    Returns a partial type; under some conditions (notably\n    \"struct foo GTY((...)) thing;\") it may write an options\n    structure to *OPTSP.\n-*/\n+\n+   NESTED is true when parsing a declaration already known to have a\n+   GTY marker. In these cases, typedef and enum declarations are not\n+   allowed because gengtype only understands types at the global\n+   scope.  */\n+\n static type_p\n type (options_p *optsp, bool nested)\n {\n@@ -777,6 +830,12 @@ type (options_p *optsp, bool nested)\n       s = typedef_name ();\n       return resolve_typedef (s, &lexer_line);\n \n+    case IGNORABLE_CXX_KEYWORD:\n+      /* By returning NULL here, we indicate to the caller that they\n+\t should ignore everything following this keyword up to the\n+\t next ';' or '}'.  */\n+      return NULL;\n+\n     case STRUCT:\n     case UNION:\n       {\n@@ -796,8 +855,8 @@ type (options_p *optsp, bool nested)\n \t/* Top-level structures that are not explicitly tagged GTY(())\n \t   are treated as mere forward declarations.  This is because\n \t   there are a lot of structures that we don't need to know\n-\t   about, and some of those have weird macro stuff in them\n-\t   that we can't handle.  */\n+\t   about, and some of those have C++ and macro constructs that\n+\t   we cannot handle.  */\n \tif (nested || token () == GTY_TOKEN)\n \t  {\n \t    is_gty = GTY_BEFORE_ID;\n@@ -819,6 +878,13 @@ type (options_p *optsp, bool nested)\n \t    opts = gtymarker_opt ();\n \t  }\n \n+\tif (token () == ':')\n+\t  {\n+\t    /* Skip over C++ inheritance specification.  */\n+\t    while (token () != '{')\n+\t      advance ();\n+\t  }\n+\n \tif (is_gty)\n \t  {\n \t    bool is_user_gty = opts_have (opts, \"user\");\n@@ -853,6 +919,21 @@ type (options_p *optsp, bool nested)\n \treturn find_structure (s, kind);\n       }\n \n+    case TYPEDEF:\n+      /* In C++, a typedef inside a struct/class/union defines a new\n+\t type for that inner scope.  We cannot support this in\n+\t gengtype because we have no concept of scoping.\n+\n+\t We handle typedefs in the global scope separately (see\n+\t parse_file), so if we find a 'typedef', we must be inside\n+\t a struct.  */\n+      gcc_assert (nested);\n+      parse_error (\"typedefs not supported in structures marked with \"\n+\t\t   \"automatic GTY markers.  Use GTY((user)) to mark \"\n+\t\t   \"this structure.\");\n+      advance ();\n+      return NULL;\n+\n     case ENUM:\n       advance ();\n       if (token () == ID)\n@@ -864,6 +945,23 @@ type (options_p *optsp, bool nested)\n \n       if (token () == '{')\n \tconsume_balanced ('{', '}');\n+\n+      /* If after parsing the enum we are at the end of the statement,\n+\t and we are currently inside a structure, then this was an\n+\t enum declaration inside this scope.\n+\n+\t We cannot support this for the same reason we cannot support\n+\t 'typedef' inside structures (see the TYPEDEF handler above).\n+\t If this happens, emit an error and return NULL.  */\n+      if (nested && token () == ';')\n+\t{\n+\t  parse_error (\"enum definitions not supported in structures marked \"\n+\t\t       \"with automatic GTY markers.  Use GTY((user)) to mark \"\n+\t               \"this structure.\");\n+\t  advance ();\n+\t  return NULL;\n+\t}\n+\n       return create_scalar_type (s);\n \n     default:\n@@ -901,7 +999,7 @@ typedef_decl (void)\n \n       /* Yet another place where we could have junk (notably attributes)\n \t after the declarator.  */\n-      another = consume_until_comma_or_semi (false);\n+      another = consume_until_comma_or_eos ();\n       if (dty)\n \tdo_typedef (name, dty, &lexer_line);\n     }"}, {"sha": "e3317ec36a43787e61e3d5356dc7c40a9319e78b", "filename": "gcc/gengtype-state.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313465bbbd04019184339161f0e30a46a5c0e4ab/gcc%2Fgengtype-state.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313465bbbd04019184339161f0e30a46a5c0e4ab/gcc%2Fgengtype-state.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-state.c?ref=313465bbbd04019184339161f0e30a46a5c0e4ab", "patch": "@@ -961,6 +961,8 @@ write_state_type (type_p current)\n       current->state_number = state_written_type_count;\n       switch (current->kind)\n \t{\n+\tcase TYPE_NONE:\n+\t  gcc_unreachable ();\n \tcase TYPE_STRUCT:\n \t  write_state_struct_type (current);\n \t  break;\n@@ -988,9 +990,6 @@ write_state_type (type_p current)\n \tcase TYPE_STRING:\n \t  write_state_string_type (current);\n \t  break;\n-\n-\tdefault:\n-\t  fatal (\"Unexpected type...\");\n \t}\n     }\n \n@@ -1318,7 +1317,6 @@ read_state_scalar_char_type (type_p *type)\n   read_state_common_type_content (*type);\n }\n \n-\n /* Read the string_type.  */\n static void\n read_state_string_type (type_p *type)"}, {"sha": "b9fbd96fcbf5757ecce0a84b9bcaa4631347c8e8", "filename": "gcc/gengtype.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313465bbbd04019184339161f0e30a46a5c0e4ab/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313465bbbd04019184339161f0e30a46a5c0e4ab/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=313465bbbd04019184339161f0e30a46a5c0e4ab", "patch": "@@ -497,10 +497,10 @@ struct type scalar_char = {\n \n /* Lists of various things.  */\n \n-pair_p typedefs;\n-type_p structures;\n-type_p param_structs;\n-pair_p variables;\n+pair_p typedefs = NULL;\n+type_p structures = NULL;\n+type_p param_structs = NULL;\n+pair_p variables = NULL;\n \n static type_p find_param_structure (type_p t, type_p param[NUM_PARAM]);\n static type_p adjust_field_tree_exp (type_p t, options_p opt);\n@@ -611,6 +611,7 @@ resolve_typedef (const char *s, struct fileloc *pos)\n   return create_user_defined_type (s, pos);\n }\n \n+\n /* Create and return a new structure with tag NAME at POS with fields\n    FIELDS and options O.  The KIND of structure must be one of\n    TYPE_STRUCT, TYPE_UNION or TYPE_USER_STRUCT.  */\n@@ -676,8 +677,7 @@ new_structure (const char *name, enum typekind kind, struct fileloc *pos,\n       structures = s;\n     }\n \n-  if (s->u.s.line.file != NULL\n-      || (s->u.s.lang_struct && (s->u.s.lang_struct->u.s.bitmap & bitmap)))\n+  if (s->u.s.lang_struct && (s->u.s.lang_struct->u.s.bitmap & bitmap))\n     {\n       error_at_line (pos, \"duplicate definition of '%s %s'\",\n \t\t     isunion ? \"union\" : \"struct\", s->u.s.tag);\n@@ -763,6 +763,7 @@ create_scalar_type (const char *name)\n     return &scalar_nonchar;\n }\n \n+\n /* Return a pointer to T.  */\n \n type_p\n@@ -2636,7 +2637,7 @@ walk_type (type_p t, struct walk_type_data *d)\n \n \t/* If a pointer type is marked as \"atomic\", we process the\n \t   field itself, but we don't walk the data that they point to.\n-\t   \n+\n \t   There are two main cases where we walk types: to mark\n \t   pointers that are reachable, and to relocate pointers when\n \t   writing a PCH file.  In both cases, an atomic pointer is\n@@ -3514,7 +3515,7 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n     {\n       oprintf (d.of, \"      %s (x);\\n\", mark_hook_name);\n     }\n-  \n+\n   d.prev_val[2] = \"*x\";\n   d.indent = 6;\n   if (orig_s->kind != TYPE_USER_STRUCT)"}, {"sha": "e687e488567db156bc865011c2af7406943844f0", "filename": "gcc/gengtype.h", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313465bbbd04019184339161f0e30a46a5c0e4ab/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313465bbbd04019184339161f0e30a46a5c0e4ab/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=313465bbbd04019184339161f0e30a46a5c0e4ab", "patch": "@@ -308,7 +308,6 @@ struct type {\n       type_p param[NUM_PARAM];  /* The actual parameter types.  */\n       struct fileloc line;      /* The source location.  */\n     } param_struct;\n-\n   } u;\n };\n \n@@ -444,38 +443,38 @@ extern void parse_file (const char *name);\n extern bool hit_error;\n \n /* Token codes.  */\n-enum\n-  {\n-    EOF_TOKEN = 0,\n-\n-    /* Per standard convention, codes in the range (0, UCHAR_MAX]\n-       represent single characters with those character codes.  */\n-\n-    CHAR_TOKEN_OFFSET = UCHAR_MAX + 1,\n-    GTY_TOKEN = CHAR_TOKEN_OFFSET,\n-    TYPEDEF,\n-    EXTERN,\n-    STATIC,\n-    UNION,\n-    STRUCT,\n-    ENUM,\n-    VEC_TOKEN,\n-    ELLIPSIS,\n-    PTR_ALIAS,\n-    NESTED_PTR,\n-    USER_GTY,\n-    PARAM_IS,\n-    NUM,\n-    SCALAR,\n-    ID,\n-    STRING,\n-    CHAR,\n-    ARRAY,\n-\n-    /* print_token assumes that any token >= FIRST_TOKEN_WITH_VALUE may have\n-       a meaningful value to be printed.  */\n-    FIRST_TOKEN_WITH_VALUE = PARAM_IS\n-  };\n+enum gty_token\n+{\n+  EOF_TOKEN = 0,\n+\n+  /* Per standard convention, codes in the range (0, UCHAR_MAX]\n+     represent single characters with those character codes.  */\n+  CHAR_TOKEN_OFFSET = UCHAR_MAX + 1,\n+  GTY_TOKEN = CHAR_TOKEN_OFFSET,\n+  TYPEDEF,\n+  EXTERN,\n+  STATIC,\n+  UNION,\n+  STRUCT,\n+  ENUM,\n+  VEC_TOKEN,\n+  ELLIPSIS,\n+  PTR_ALIAS,\n+  NESTED_PTR,\n+  USER_GTY,\n+  PARAM_IS,\n+  NUM,\n+  SCALAR,\n+  ID,\n+  STRING,\n+  CHAR,\n+  ARRAY,\n+  IGNORABLE_CXX_KEYWORD,\n+\n+  /* print_token assumes that any token >= FIRST_TOKEN_WITH_VALUE may have\n+     a meaningful value to be printed.  */\n+  FIRST_TOKEN_WITH_VALUE = PARAM_IS\n+};\n \n \n /* Level for verbose messages, e.g. output file generation...  */"}]}