{"sha": "9583b26f3701ea0456405d84f9a898451a2f7452", "node_id": "C_kwDOANBUbNoAKDk1ODNiMjZmMzcwMWVhMDQ1NjQwNWQ4NGY5YTg5ODQ1MWEyZjc0NTI", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-10-10T10:13:22Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-10-10T10:16:41Z"}, "message": "var-tracking: Fix a wrong-debug issue caused by my r10-7665 var-tracking change [PR102441]\n\nSince my r10-7665-g33c45e51b4914008064d9b77f2c1fc0eea1ad060 change, we get\nwrong-debug on e.g. the following testcase at -O2 -g on x86_64-linux for the\nx parameter:\nvoid bar (int *r);\nint\nfoo (int x)\n{\n  int r = 0;\n  bar (&r);\n  return r;\n}\nAt the start of function, we have\n        subq    $24, %rsp\n        leaq    12(%rsp), %rdi\ninstructions.  The x parameter is passed in %rdi, but isn't used in the\nfunction and so the leaq instruction overwrites %rdi without remembering\n%rdi anywhere.  Before the r10-7665 change (which was trying to fix a large\n(3% for 32-bit, 1% for 64-bit x86-64) debug info/loc growth introduced with\nr10-7515), the leaq insn above resulted in a MO_VAL_SET micro-operation that\nsaid that the value of sp + 12, a cselib_sp_derived_value_p, is stored into\nthe %rdi register.  The r10-7665 change added a change to add_stores that\nadded no micro-operation for the leaq store, with the rationale that the sp\nbased values can be and will be always computable some other more compact\nand primarily more stable way (cfa based expression like DW_OP_fbreg, that\nis the same in the whole function).  That is true.  But by throwing the\nmicro-operation on the floor, we miss another important part of the\nMO_VAL_SET, in particular that the destination of the store, %rdi in this\ncase, now has a different value from what it had before, so the vt_*\ndataflow code thinks that even after the leaq instruction %rdi still holds\nthe x argument value (and changes it to DW_OP_entry_value (%rdi) only in the\nmiddle of the call to bar).  Previously and with the patches below,\nthe location for x changes already at the end of leaq instruction to\nDW_OP_entry_value (%rdi).\n\nMy first attempt to fix this was instead of dropping the MO_VAL_SET add\na MO_CLOBBER operation:\n--- gcc/var-tracking.c.jj       2021-05-04 21:02:24.196799586 +0200\n+++ gcc/var-tracking.c  2021-09-24 19:23:16.420154828 +0200\n@@ -6133,7 +6133,9 @@ add_stores (rtx loc, const_rtx expr, voi\n     {\n       if (preserve)\n        preserve_value (v);\n-      return;\n+      mo.type = MO_CLOBBER;\n+      mo.u.loc = loc;\n+      goto log_and_return;\n     }\n\n   nloc = replace_expr_with_values (oloc);\nso don't track that the value lives in the loc destination, but track\nthat the previous value doesn't live there anymore.  That failed bootstrap\nmiserably, the vt_* code isn't prepared to see MO_CLOBBER of a MEM that\nisn't tracked (e.g. has MEM_EXPR on it that the var-tracking code wants\nto track, i.e. track_p in add_stores).  On the other side, thinking about\nit more, in the most common case where a cselib_sp_derived_value_p value\nis stored into the sp register (and which is the reason why PR94495\ntestcase got larger), dropping the micro-operation on the floor is the\nright thing, because we have that cselib_sp_derived_value_p tracking, any\nreads from the sp hard register will be treated as\ncselib_sp_derived_value_p.\nThen I've tried 3 different patches described below and in the end\nwhat is committed is patch2.\nAdditionally, I've gathered statistics from cc1plus by always reverting the\nvar-tracking.c change after finished bootstrap/regtest and rebuilding the\nstage3 var-tracking.o and cc1plus, such that it would be comparable.\ndwlocstat and .debug_{info,loclists} section sizes detailed below.\npatch3 uses MO_VAL_SET (i.e. essentially reversion of the r10-7665\nchange) when destination is not a REG_P and !track_p, otherwise if\ndestination is sp drops the micro-operation on the floor (i.e. no change),\notherwise adds a MO_CLOBBER.\npatch1 is similar, except it checks for destination not equal to sp and\n!track_p, i.e. for !track_p REG_P destinations other than sp it will use\nMO_VAL_SET rather than MO_CLOBBER.\nFinally, patch2, the shortest patch, uses MO_VAL_SET whenever destination\nis not sp and otherwise drops the micro-operation on the floor.\nAll the 3 patches don't affect the PR94495 testcase, all the changes\nthere were caused by stores of sp based values into %rsp.\n\nWhile the patch2 (and patch1 which results in exactly the same sizes)\ncauses the largest debug loclists/info growth from the 3, it is still quite\nminor (0.651% on 64-bit and 0.114% on 32-bit) compared\nto the 1% and 3% PR94495 was trying to solve, and I actually think it is the\nbest thing to do.  Because, if we have say\n  int q[10];\n  int *p = &q[0];\nor similar and we load the &q[0] sp based value into some hard register,\nby noting in the debug info that p lives in some hard reg for some part\nof the function and a user is trying to change the p var in the debugger,\nif we say it lives in some register or memory, there is some chance that\nthe changing of the value could work successfully (of course, nothing\nis guaranteed, we don't have tracking of where each var lives at which\nmoment for changing purposes (i.e. what register, memory or else you need\nto change in order to change behavior of the code)), while if we just say\nthat p's location is DW_OP_fbreg 16 DW_OP_stack_value, that is a read-only\nvalue one can just print but not change.  Now, for stores of variable\nvalues into the sp register, I don't think we have such an issue, you don't\nwant debugger to change your stack pointer when user asks to change value\nof some variable whose value lives in the stack pointer, that would pretty\nmuch always result in misbehavior of the program.\nSo, my preference from these 3 is patch2 and that is being committed.\n\n64-bit cc1plus\n==============\nvanilla\ncov%    samples cumul\n0..10   1064665/37%     1064665/37%\n11..20  35972/1%        1100637/38%\n21..30  47969/1%        1148606/40%\n31..40  45787/1%        1194393/42%\n41..50  57529/2%        1251922/44%\n51..60  53974/1%        1305896/46%\n61..70  112055/3%       1417951/50%\n71..80  79420/2%        1497371/52%\n81..90  126225/4%       1623596/57%\n91..100 1206682/42%     2830278/100%\n  [34] .debug_info       PROGBITS        0000000000000000 2f1c74c a44949f 00      0   0  1\n  [38] .debug_loclists   PROGBITS        0000000000000000 ff5d046 506e947 00      0   0  1\npatch1 (same as patch2)\ncov%    samples cumul\n0..10   1064685/37%     1064685/37%\n11..20  36011/1%        1100696/38%\n21..30  47975/1%        1148671/40%\n31..40  45799/1%        1194470/42%\n41..50  57566/2%        1252036/44%\n51..60  54011/1%        1306047/46%\n61..70  112068/3%       1418115/50%\n71..80  79421/2%        1497536/52%\n81..90  126171/4%       1623707/57%\n91..100 1206571/42%     2830278/100%\n  [34] .debug_info       PROGBITS        0000000000000000 2f1c74c a448f27 00      0   0  1\n  [38] .debug_loclists   PROGBITS        0000000000000000 ff608bc 52070dd 00      0   0  1\npatch3\ncov%    samples cumul\n0..10   1064698/37%     1064698/37%\n11..20  36018/1%        1100716/38%\n21..30  47977/1%        1148693/40%\n31..40  45804/1%        1194497/42%\n41..50  57562/2%        1252059/44%\n51..60  54018/1%        1306077/46%\n61..70  112071/3%       1418148/50%\n71..80  79424/2%        1497572/52%\n81..90  126172/4%       1623744/57%\n91..100 1206534/42%     2830278/100%\n  [34] .debug_info       PROGBITS        0000000000000000 2f1c74c a449548 00      0   0  1\n  [38] .debug_loclists   PROGBITS        0000000000000000 ff5df39 507acd8 00      0   0  1\nSo, size of .debug_info+.debug_loclists grows for vanilla -> patch1 (or patch2) by\n0.651% and for vanilla -> patch3 by 0.020%.\n\n32-bit cc1plus\n==============\nvanilla\ncov%    samples cumul\n0..10   1061892/37%     1061892/37%\n11..20  34002/1%        1095894/39%\n21..30  43513/1%        1139407/40%\n31..40  41667/1%        1181074/42%\n41..50  59144/2%        1240218/44%\n51..60  47009/1%        1287227/45%\n61..70  105069/3%       1392296/49%\n71..80  72990/2%        1465286/52%\n81..90  125988/4%       1591274/56%\n91..100 1208726/43%     2800000/100%\n  [33] .debug_info       PROGBITS        00000000 351ab10 8b1c83d 00      0   0  1\n  [37] .debug_loclists   PROGBITS        00000000 ebc816e 3fe44fd 00      0   0  1\npatch1 (same as patch2)\ncov%    samples cumul\n0..10   1061999/37%     1061999/37%\n11..20  34065/1%        1096064/39%\n21..30  43557/1%        1139621/40%\n31..40  41690/1%        1181311/42%\n41..50  59191/2%        1240502/44%\n51..60  47143/1%        1287645/45%\n61..70  105045/3%       1392690/49%\n71..80  73021/2%        1465711/52%\n81..90  125885/4%       1591596/56%\n91..100 1208404/43%     2800000/100%\n  [33] .debug_info       PROGBITS        00000000 351ab10 8b1c597 00      0   0  1\n  [37] .debug_loclists   PROGBITS        00000000 ebca915 401ffad 00      0   0  1\npatch3\ncov%    samples cumul\n0..10   1062006/37%     1062006/37%\n11..20  34073/1%        1096079/39%\n21..30  43559/1%        1139638/40%\n31..40  41693/1%        1181331/42%\n41..50  59189/2%        1240520/44%\n51..60  47142/1%        1287662/45%\n61..70  105054/3%       1392716/49%\n71..80  73027/2%        1465743/52%\n81..90  125874/4%       1591617/56%\n91..100 1208383/43%     2800000/100%\n  [33] .debug_info       PROGBITS        00000000 351ab10 8b1c690 00      0   0  1\n  [37] .debug_loclists   PROGBITS        00000000 ebca40a 4020a6e 00      0   0  1\nSo, size of .debug_info+.debug_loclists grows for vanilla -> patch1 (or patch2) by\n0.114% and for vanilla -> patch3 by 0.116%.\n\n2021-10-10  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR debug/102441\n\t* var-tracking.c (add_stores): For cselib_sp_derived_value_p values\n\tuse MO_VAL_SET if loc is not sp.", "tree": {"sha": "84f989100dccf1bce3d8124d3060492795762abc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84f989100dccf1bce3d8124d3060492795762abc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9583b26f3701ea0456405d84f9a898451a2f7452", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9583b26f3701ea0456405d84f9a898451a2f7452", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9583b26f3701ea0456405d84f9a898451a2f7452", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9583b26f3701ea0456405d84f9a898451a2f7452/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "882d806c1a8f9d2d2ade1133de88d63e5d4fe40c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/882d806c1a8f9d2d2ade1133de88d63e5d4fe40c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/882d806c1a8f9d2d2ade1133de88d63e5d4fe40c"}], "stats": {"total": 3, "additions": 2, "deletions": 1}, "files": [{"sha": "638a96cb411f3eabfbc6abf5ce9eafdb79d14f23", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9583b26f3701ea0456405d84f9a898451a2f7452/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9583b26f3701ea0456405d84f9a898451a2f7452/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=9583b26f3701ea0456405d84f9a898451a2f7452", "patch": "@@ -6129,7 +6129,8 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n      on which register holds that VALUE in some instruction.  */\n   if (!frame_pointer_needed\n       && cfa_base_rtx\n-      && cselib_sp_derived_value_p (v))\n+      && cselib_sp_derived_value_p (v)\n+      && loc == stack_pointer_rtx)\n     {\n       if (preserve)\n \tpreserve_value (v);"}]}