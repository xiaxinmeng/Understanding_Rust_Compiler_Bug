{"sha": "fa74b47a8c825cbdde6f97591befb474b739006f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE3NGI0N2E4YzgyNWNiZGRlNmY5NzU5MWJlZmI0NzRiNzM5MDA2Zg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-11-17T18:48:23Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-11-17T18:48:23Z"}, "message": "Add null identifiers to genmatch\n\nThis patch adds a null identifier that can never match anything and\ncan never be generated.  It is only valid in operator lists and fors.\nLater patches will add uses of it.\n\nThe idea is to allow operator lists for maths functions that have\nfour entries:\n\n- float built-in\n- double built-in\n- long double built-in\n- internal function\n\nNot all maths functions have an associated internal function,\nand for those the final operator will be \"null\".  Any simplification\nthat tries to use a null substitution will be skipped.\n\nTested on x86_64-linux-gnu, aarch64-linux-gnu and arm-linux-gnueabi.\n\ngcc/\n\t* doc/match-and-simplify.texi: Document the \"null\" identifier.\n\t* genmatch.c (id_base::NULL_ID): New kind.\n\t(null_id): New variable.\n\t(get_operator): Add a parameter that says whether null identifiers\n\tare allowed.\n\t(contains_id): New function.\n\t(lower_for): Skip substitutions that would have a null_id in\n\teither the match or the result.\n\t(parser::parse_for): Allow the null identifier to be used.\n\t(parser::parse_operator_list): Likewise.\n\t(main): Initialize null_id.\n\nFrom-SVN: r230485", "tree": {"sha": "bdc10567de14ef2c88576714c0c54d848ad98243", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdc10567de14ef2c88576714c0c54d848ad98243"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa74b47a8c825cbdde6f97591befb474b739006f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa74b47a8c825cbdde6f97591befb474b739006f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa74b47a8c825cbdde6f97591befb474b739006f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa74b47a8c825cbdde6f97591befb474b739006f/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c9e926ce2bdc8bdce5fd9892443cf6147868e7f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9e926ce2bdc8bdce5fd9892443cf6147868e7f6"}], "stats": {"total": 88, "additions": 81, "deletions": 7}, "files": [{"sha": "bd233a67393dc809b58c1b64a4238038c98bfe96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa74b47a8c825cbdde6f97591befb474b739006f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa74b47a8c825cbdde6f97591befb474b739006f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa74b47a8c825cbdde6f97591befb474b739006f", "patch": "@@ -1,3 +1,17 @@\n+2015-11-17  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* doc/match-and-simplify.texi: Document the \"null\" identifier.\n+\t* genmatch.c (id_base::NULL_ID): New kind.\n+\t(null_id): New variable.\n+\t(get_operator): Add a parameter that says whether null identifiers\n+\tare allowed.\n+\t(contains_id): New function.\n+\t(lower_for): Skip substitutions that would have a null_id in\n+\teither the match or the result.\n+\t(parser::parse_for): Allow the null identifier to be used.\n+\t(parser::parse_operator_list): Likewise.\n+\t(main): Initialize null_id.\n+\n 2015-11-17  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* match.pd: Use HYPOT and COS rather than hypot and cos."}, {"sha": "db6519dcee07369f2acdca1ca501a19479deea26", "filename": "gcc/doc/match-and-simplify.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa74b47a8c825cbdde6f97591befb474b739006f/gcc%2Fdoc%2Fmatch-and-simplify.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa74b47a8c825cbdde6f97591befb474b739006f/gcc%2Fdoc%2Fmatch-and-simplify.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmatch-and-simplify.texi?ref=fa74b47a8c825cbdde6f97591befb474b739006f", "patch": "@@ -323,6 +323,11 @@ is the same as\n   (POW (abs @@0) (mult @@1 @{ built_real (TREE_TYPE (@@1), dconsthalf); @}))))\n @end smallexample\n \n+@code{for}s and operator lists can include the special identifier\n+@code{null} that matches nothing and can never be generated.  This can\n+be used to pad an operator list so that it has a standard form,\n+even if there isn't a suitable operator for every form.\n+\n Another building block are @code{with} expressions in the\n result expression which nest the generated code in a new C block\n followed by its argument:"}, {"sha": "4df5689c860d4acb114953ec12549c3d272b1a97", "filename": "gcc/genmatch.c", "status": "modified", "additions": 62, "deletions": 7, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa74b47a8c825cbdde6f97591befb474b739006f/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa74b47a8c825cbdde6f97591befb474b739006f/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=fa74b47a8c825cbdde6f97591befb474b739006f", "patch": "@@ -297,7 +297,7 @@ commutative_ternary_tree_code (enum tree_code code)\n \n struct id_base : nofree_ptr_hash<id_base>\n {\n-  enum id_kind { CODE, FN, PREDICATE, USER } kind;\n+  enum id_kind { CODE, FN, PREDICATE, USER, NULL_ID } kind;\n \n   id_base (id_kind, const char *, int = -1);\n \n@@ -324,6 +324,9 @@ id_base::equal (const id_base *op1,\n \t  && strcmp (op1->id, op2->id) == 0);\n }\n \n+/* The special id \"null\", which matches nothing.  */\n+static id_base *null_id;\n+\n /* Hashtable of known pattern operators.  This is pre-seeded from\n    all known tree codes and all known builtin function ids.  */\n static hash_table<id_base> *operators;\n@@ -479,11 +482,14 @@ operator==(id_base &id, enum tree_code code)\n   return false;\n }\n \n-/* Lookup the identifier ID.  */\n+/* Lookup the identifier ID.  Allow \"null\" if ALLOW_NULL.  */\n \n id_base *\n-get_operator (const char *id)\n+get_operator (const char *id, bool allow_null = false)\n {\n+  if (allow_null && strcmp (id, \"null\") == 0)\n+    return null_id;\n+\n   id_base tem (id_base::CODE, id);\n \n   id_base *op = operators->find_with_hash (&tem, tem.hashval);\n@@ -1115,6 +1121,40 @@ lower_cond (simplify *s, vec<simplify *>& simplifiers)\n     }\n }\n \n+/* Return true if O refers to ID.  */\n+\n+bool\n+contains_id (operand *o, user_id *id)\n+{\n+  if (capture *c = dyn_cast<capture *> (o))\n+    return c->what && contains_id (c->what, id);\n+\n+  if (expr *e = dyn_cast<expr *> (o))\n+    {\n+      if (e->operation == id)\n+\treturn true;\n+      for (unsigned i = 0; i < e->ops.length (); ++i)\n+\tif (contains_id (e->ops[i], id))\n+\t  return true;\n+      return false;\n+    }\n+\n+  if (with_expr *w = dyn_cast <with_expr *> (o))\n+    return (contains_id (w->with, id)\n+\t    || contains_id (w->subexpr, id));\n+\n+  if (if_expr *ife = dyn_cast <if_expr *> (o))\n+    return (contains_id (ife->cond, id)\n+\t    || contains_id (ife->trueexpr, id)\n+\t    || (ife->falseexpr && contains_id (ife->falseexpr, id)));\n+\n+  if (c_expr *ce = dyn_cast<c_expr *> (o))\n+    return ce->capture_ids && ce->capture_ids->get (id->id);\n+\n+  return false;\n+}\n+\n+\n /* In AST operand O replace operator ID with operator WITH.  */\n \n operand *\n@@ -1270,16 +1310,29 @@ lower_for (simplify *sin, vec<simplify *>& simplifiers)\n \t      operand *result_op = s->result;\n \t      vec<std::pair<user_id *, id_base *> > subst;\n \t      subst.create (n_ids);\n+\t      bool skip = false;\n \t      for (unsigned i = 0; i < n_ids; ++i)\n \t\t{\n \t\t  user_id *id = ids[i];\n \t\t  id_base *oper = id->substitutes[j % id->substitutes.length ()];\n+\t\t  if (oper == null_id\n+\t\t      && (contains_id (match_op, id)\n+\t\t\t  || contains_id (result_op, id)))\n+\t\t    {\n+\t\t      skip = true;\n+\t\t      break;\n+\t\t    }\n \t\t  subst.quick_push (std::make_pair (id, oper));\n \t\t  match_op = replace_id (match_op, id, oper);\n \t\t  if (result_op\n \t\t      && !can_delay_subst)\n \t\t    result_op = replace_id (result_op, id, oper);\n \t\t}\n+\t      if (skip)\n+\t\t{\n+\t\t  subst.release ();\n+\t\t  continue;\n+\t\t}\n \t      simplify *ns = new simplify (s->kind, match_op, result_op,\n \t\t\t\t\t   vNULL, s->capture_ids);\n \t      ns->for_subst_vec.safe_splice (s->for_subst_vec);\n@@ -4242,7 +4295,7 @@ parser::parse_for (source_location)\n \n       /* Insert the user defined operators into the operator hash.  */\n       const char *id = get_ident ();\n-      if (get_operator (id) != NULL)\n+      if (get_operator (id, true) != NULL)\n \tfatal_at (token, \"operator already defined\");\n       user_id *op = new user_id (id);\n       id_base **slot = operators->find_slot_with_hash (op, op->hashval, INSERT);\n@@ -4256,7 +4309,7 @@ parser::parse_for (source_location)\n       while ((token = peek_ident ()) != 0)\n \t{\n \t  const char *oper = get_ident ();\n-\t  id_base *idb = get_operator (oper);\n+\t  id_base *idb = get_operator (oper, true);\n \t  if (idb == NULL)\n \t    fatal_at (token, \"no such operator '%s'\", oper);\n \t  if (*idb == CONVERT0 || *idb == CONVERT1 || *idb == CONVERT2\n@@ -4346,7 +4399,7 @@ parser::parse_operator_list (source_location)\n   const cpp_token *token = peek (); \n   const char *id = get_ident ();\n \n-  if (get_operator (id) != 0)\n+  if (get_operator (id, true) != 0)\n     fatal_at (token, \"operator %s already defined\", id);\n \n   user_id *op = new user_id (id, true);\n@@ -4356,7 +4409,7 @@ parser::parse_operator_list (source_location)\n     {\n       token = peek (); \n       const char *oper = get_ident ();\n-      id_base *idb = get_operator (oper);\n+      id_base *idb = get_operator (oper, true);\n       \n       if (idb == 0)\n \tfatal_at (token, \"no such operator '%s'\", oper);\n@@ -4590,6 +4643,8 @@ main (int argc, char **argv)\n   cpp_define (r, gimple ? \"GIMPLE=1\": \"GENERIC=1\");\n   cpp_define (r, gimple ? \"GENERIC=0\": \"GIMPLE=0\");\n \n+  null_id = new id_base (id_base::NULL_ID, \"null\");\n+\n   /* Pre-seed operators.  */\n   operators = new hash_table<id_base> (1024);\n #define DEFTREECODE(SYM, STRING, TYPE, NARGS) \\"}]}