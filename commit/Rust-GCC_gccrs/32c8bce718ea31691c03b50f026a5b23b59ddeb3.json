{"sha": "32c8bce718ea31691c03b50f026a5b23b59ddeb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJjOGJjZTcxOGVhMzE2OTFjMDNiNTBmMDI2YTViMjNiNTlkZGViMw==", "commit": {"author": {"name": "Duncan Sands", "email": "baldrick@free.fr", "date": "2006-11-29T16:00:07Z"}, "committer": {"name": "Duncan Sands", "email": "baldrick@gcc.gnu.org", "date": "2006-11-29T16:00:07Z"}, "message": "re PR tree-optimization/23744 (VRP does not merge discontinuous ranges of PHIs)\n\n\tPR tree-optimization/23744\n\t* tree-vrp.c (vrp_meet): do not require ranges to intersect.\n\t* testsuite/gcc.dg/tree-ssa/pr23744.c: new test.\n\t* testsuite/gcc.dg/tree-ssa/update-threading.c: xfail.\n\nFrom-SVN: r119320", "tree": {"sha": "79077c165b5fa64d656ddc1ba77c96e3ccb5d22b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79077c165b5fa64d656ddc1ba77c96e3ccb5d22b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32c8bce718ea31691c03b50f026a5b23b59ddeb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32c8bce718ea31691c03b50f026a5b23b59ddeb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32c8bce718ea31691c03b50f026a5b23b59ddeb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32c8bce718ea31691c03b50f026a5b23b59ddeb3/comments", "author": {"login": "CunningBaldrick", "id": 1713707, "node_id": "MDQ6VXNlcjE3MTM3MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/1713707?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CunningBaldrick", "html_url": "https://github.com/CunningBaldrick", "followers_url": "https://api.github.com/users/CunningBaldrick/followers", "following_url": "https://api.github.com/users/CunningBaldrick/following{/other_user}", "gists_url": "https://api.github.com/users/CunningBaldrick/gists{/gist_id}", "starred_url": "https://api.github.com/users/CunningBaldrick/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CunningBaldrick/subscriptions", "organizations_url": "https://api.github.com/users/CunningBaldrick/orgs", "repos_url": "https://api.github.com/users/CunningBaldrick/repos", "events_url": "https://api.github.com/users/CunningBaldrick/events{/privacy}", "received_events_url": "https://api.github.com/users/CunningBaldrick/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7f9faf5e703dcc04ddf7dd8136095f3d1fbbed33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f9faf5e703dcc04ddf7dd8136095f3d1fbbed33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f9faf5e703dcc04ddf7dd8136095f3d1fbbed33"}], "stats": {"total": 142, "additions": 79, "deletions": 63}, "files": [{"sha": "5bb4362523e89de34c88a62ff75fbaff7939cfdc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c8bce718ea31691c03b50f026a5b23b59ddeb3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c8bce718ea31691c03b50f026a5b23b59ddeb3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32c8bce718ea31691c03b50f026a5b23b59ddeb3", "patch": "@@ -1,3 +1,18 @@\n+2006-11-29  Duncan Sands  <baldrick@free.fr>\n+\n+\tPR tree-optimization/23744\n+\t* tree-vrp.c (vrp_meet): do not require ranges to intersect.\n+\n+2006-11-29  Duncan Sands  <baldrick@free.fr>\n+\n+\tPR tree-optimization/23744\n+\t* testsuite/gcc.dg/tree-ssa/pr23744.c: new test.\n+\n+2006-11-29  Duncan Sands  <baldrick@free.fr>\n+\n+\tPR tree-optimization/23744\n+\t* testsuite/gcc.dg/tree-ssa/update-threading.c: xfail.\n+\n 2006-11-29  Jie Zhang  <jie.zhang@analog.com>\n \n \t* doc/tm.texi (NO_PROFILE_COUNTERS): Document more accurately."}, {"sha": "8ba238c745bf4f10ef8bf6686f0b314a7a70b7b7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr23744.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c8bce718ea31691c03b50f026a5b23b59ddeb3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23744.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c8bce718ea31691c03b50f026a5b23b59ddeb3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23744.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23744.c?ref=32c8bce718ea31691c03b50f026a5b23b59ddeb3", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+\n+int g (int i, int j)\n+{\n+  int t = 0;\n+  int i1;\n+\n+  if (i == j)\n+    t = 3;\n+  for (i1 = 0; i1 < 10000; i1++) h();\n+  if (t != 5)\n+    return 0;\n+  else\n+    return 1;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Folding predicate.*to 1\" 1 \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "e0e33b6869a2a20013a772ce43ea7030c7a7c4f2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/update-threading.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c8bce718ea31691c03b50f026a5b23b59ddeb3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fupdate-threading.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c8bce718ea31691c03b50f026a5b23b59ddeb3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fupdate-threading.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fupdate-threading.c?ref=32c8bce718ea31691c03b50f026a5b23b59ddeb3", "patch": "@@ -20,5 +20,5 @@ main (int argc, char **argv)\n     foo (((A) { ((!(i >> 4) ? 8 : 64 + (i >> 4)) << 8) + (i << 4) } ).a);\n   exit (0);\n }\n-/* { dg-final { scan-tree-dump-times \"Invalid sum\" 0 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"Invalid sum\" 0 \"optimized\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "b55480ee8cd22f4bea5733f529498f50e39a994d", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 44, "deletions": 62, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32c8bce718ea31691c03b50f026a5b23b59ddeb3/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32c8bce718ea31691c03b50f026a5b23b59ddeb3/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=32c8bce718ea31691c03b50f026a5b23b59ddeb3", "patch": "@@ -3978,14 +3978,8 @@ vrp_visit_stmt (tree stmt, edge *taken_edge_p, tree *output_p)\n \n \n /* Meet operation for value ranges.  Given two value ranges VR0 and\n-   VR1, store in VR0 the result of meeting VR0 and VR1.\n-   \n-   The meeting rules are as follows:\n-\n-   1- If VR0 and VR1 have an empty intersection, set VR0 to VR_VARYING.\n-\n-   2- If VR0 and VR1 have a non-empty intersection, set VR0 to the\n-      union of VR0 and VR1.  */\n+   VR1, store in VR0 a range that contains both VR0 and VR1.  This\n+   may not be the smallest possible such range.  */\n \n static void\n vrp_meet (value_range_t *vr0, value_range_t *vr1)\n@@ -4016,56 +4010,44 @@ vrp_meet (value_range_t *vr0, value_range_t *vr1)\n \n   if (vr0->type == VR_RANGE && vr1->type == VR_RANGE)\n     {\n-      /* If VR0 and VR1 have a non-empty intersection, compute the\n-\t union of both ranges.  */\n-      if (value_ranges_intersect_p (vr0, vr1))\n-\t{\n-\t  int cmp;\n-\t  tree min, max;\n-\n-\t  /* The lower limit of the new range is the minimum of the\n-\t     two ranges.  If they cannot be compared, the result is\n-\t     VARYING.  */\n-\t  cmp = compare_values (vr0->min, vr1->min);\n-\t  if (cmp == 0 || cmp == 1)\n-\t    min = vr1->min;\n-\t  else if (cmp == -1)\n-\t    min = vr0->min;\n-\t  else\n-\t    {\n-\t      set_value_range_to_varying (vr0);\n-\t      return;\n-\t    }\n-\n-\t  /* Similarly, the upper limit of the new range is the\n-\t     maximum of the two ranges.  If they cannot be compared,\n-\t     the result is VARYING.  */\n-\t  cmp = compare_values (vr0->max, vr1->max);\n-\t  if (cmp == 0 || cmp == -1)\n-\t    max = vr1->max;\n-\t  else if (cmp == 1)\n-\t    max = vr0->max;\n-\t  else\n-\t    {\n-\t      set_value_range_to_varying (vr0);\n-\t      return;\n-\t    }\n+      int cmp;\n+      tree min, max;\n+\n+      /* Compute the convex hull of the ranges.  The lower limit of\n+         the new range is the minimum of the two ranges.  If they\n+\t cannot be compared, then give up.  */\n+      cmp = compare_values (vr0->min, vr1->min);\n+      if (cmp == 0 || cmp == 1)\n+        min = vr1->min;\n+      else if (cmp == -1)\n+        min = vr0->min;\n+      else\n+\tgoto give_up;\n+\n+      /* Similarly, the upper limit of the new range is the maximum\n+         of the two ranges.  If they cannot be compared, then\n+\t give up.  */\n+      cmp = compare_values (vr0->max, vr1->max);\n+      if (cmp == 0 || cmp == -1)\n+        max = vr1->max;\n+      else if (cmp == 1)\n+        max = vr0->max;\n+      else\n+\tgoto give_up;\n \n-\t  /* The resulting set of equivalences is the intersection of\n-\t     the two sets.  */\n-\t  if (vr0->equiv && vr1->equiv && vr0->equiv != vr1->equiv)\n-\t    bitmap_and_into (vr0->equiv, vr1->equiv);\n-\t  else if (vr0->equiv && !vr1->equiv)\n-\t    bitmap_clear (vr0->equiv);\n+      /* The resulting set of equivalences is the intersection of\n+\t the two sets.  */\n+      if (vr0->equiv && vr1->equiv && vr0->equiv != vr1->equiv)\n+        bitmap_and_into (vr0->equiv, vr1->equiv);\n+      else if (vr0->equiv && !vr1->equiv)\n+        bitmap_clear (vr0->equiv);\n \n-\t  set_value_range (vr0, vr0->type, min, max, vr0->equiv);\n-\t}\n-      else\n-\tgoto no_meet;\n+      set_value_range (vr0, vr0->type, min, max, vr0->equiv);\n     }\n   else if (vr0->type == VR_ANTI_RANGE && vr1->type == VR_ANTI_RANGE)\n     {\n-      /* Two anti-ranges meet only if they are both identical.  */\n+      /* Two anti-ranges meet only if their complements intersect.\n+         Only handle the case of identical ranges.  */\n       if (compare_values (vr0->min, vr1->min) == 0\n \t  && compare_values (vr0->max, vr1->max) == 0\n \t  && compare_values (vr0->min, vr0->max) == 0)\n@@ -4078,13 +4060,13 @@ vrp_meet (value_range_t *vr0, value_range_t *vr1)\n \t    bitmap_clear (vr0->equiv);\n \t}\n       else\n-\tgoto no_meet;\n+\tgoto give_up;\n     }\n   else if (vr0->type == VR_ANTI_RANGE || vr1->type == VR_ANTI_RANGE)\n     {\n-      /* A numeric range [VAL1, VAL2] and an anti-range ~[VAL3, VAL4]\n-\t meet only if the ranges have an empty intersection.  The\n-\t result of the meet operation is the anti-range.  */\n+      /* For a numeric range [VAL1, VAL2] and an anti-range ~[VAL3, VAL4],\n+         only handle the case where the ranges have an empty intersection.\n+\t The result of the meet operation is the anti-range.  */\n       if (!symbolic_range_p (vr0)\n \t  && !symbolic_range_p (vr1)\n \t  && !value_ranges_intersect_p (vr0, vr1))\n@@ -4103,17 +4085,17 @@ vrp_meet (value_range_t *vr0, value_range_t *vr1)\n \t    bitmap_clear (vr0->equiv);\n \t}\n       else\n-\tgoto no_meet;\n+\tgoto give_up;\n     }\n   else\n     gcc_unreachable ();\n \n   return;\n \n-no_meet:\n-  /* The two range VR0 and VR1 do not meet.  Before giving up and\n-     setting the result to VARYING, see if we can at least derive a\n-     useful anti-range.  FIXME, all this nonsense about distinguishing\n+give_up:\n+  /* Failed to find an efficient meet.  Before giving up and setting\n+     the result to VARYING, see if we can at least derive a useful\n+     anti-range.  FIXME, all this nonsense about distinguishing\n      anti-ranges from ranges is necessary because of the odd\n      semantics of range_includes_zero_p and friends.  */\n   if (!symbolic_range_p (vr0)"}]}