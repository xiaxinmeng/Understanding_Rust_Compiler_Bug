{"sha": "b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjIxNmNkNGFlM2JkMDZhMTcxYjBiMmRiNDFkNzlkNGI2ZjgxODAwOA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-03-23T01:10:56Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-03-23T01:10:56Z"}, "message": "real.h: Don't define REAL_INFINITY or REAL_IS_NOT_DOUBLE.\n\n\t* real.h: Don't define REAL_INFINITY or REAL_IS_NOT_DOUBLE.\n\tAlways make REAL_VALUE_TYPE a struct containing an array of\n\tHOST_WIDE_INT, not a double.  Tidy up the code deciding how\n\tbig it is.  Don't declare or use union real_extract.\n\n\t* emit-rtl.c (init_emit_once), varasm.c (immed_real_const_1,\n\tdecode_rtx_const, output_constant_pool), config/a29k/a29k.c\n\t(print_operand), config/arm/arm.c (output_move_double),\n\tconfig/arm/arm.md (consttable_4, consttable_8),\n\tconfig/romp/romp.c (output_fpops), config/s390/s390.h\n\t(ASM_OUTPUT_SPECIAL_POOL_ENTRY), config/xtensa/xtensa.c\n\t(xtensa_output_literal): Don't use union real_extract.\n\n\t* config/dsp16xx/dsp16xx.c (print_operand), config/i860/i860.c\n\t(sfmode_constant_to_ulong), config/ns32k/merlin.h\n\t(PRINT_OPERAND), config/ns32k/ns32k.c (print_operand),\n\tconfig/pdp11/pdp11.h (PRINT_OPERAND), config/we32k/we32k.h\n\t(PRINT_OPERAND): Don't use local version of union\n\treal_extract.\n\n\t* config/convex/convex.c (check_float_value), config/vax/vax.c\n\t(vax_float_literal), config/m88k/m88k.md (divdf3),\n\tconfig/dsp16xx/dsp16xx.md (fixuns_trunchfhi2),\n\tconfig/pdp11/pdp11.c (output_move_quad): Don't do host\n\tarithmetic on target floating point quantities.\n\n\t* config/a29k/a29k.md, config/dsp16xx/dsp16xx.c\n\t(output_dsp16xx_float_const): Don't test HOST_FLOAT_FORMAT.\n\n\t* fold-const.c (fold), simplify-rtx.c (simplify_binary_real):\n\tUse MODE_HAS_INFINITIES rather than #ifdef REAL_INFINITY.\n\n\t* real.c (earith): Test INFINITY rather than REAL_INFINITY;\n\tNANS implies INFINITY, so can drop #ifdef NANS inside #ifndef\n\tINFINITY.\n\t* print-rtl.c (print_rtx): Disable code which needs\n\tfloating-point emulator.\n\t* libgcc2.c: Include float.h and use DBL_MANT_DIG,\n\tFLT_MANT_DIG, to define DF_SIZE and SF_SIZE, rather than\n\tdepending on HOST_FLOAT_FORMAT to be defined properly.\n\n\t* ch/grant.c, cp/error.c: Always use REAL_VALUE_TO_DECIMAL;\n\tdon't test REAL_IS_NOT_DOUBLE.\n\n\t* config/1750a/1750a.c (get_double, float_label): Delete.\n\t(print_operand): Delete huge commented-out chunk.  Use\n\tREAL_VALUE_TO_DECIMAL.\n\t* config/1750a/1750a-protos.h: Delete prototypes of deleted\n\tfunctions.\n\t* config/convex/convex.h: Always set TARGET_FLOAT_FORMAT to\n\tIEEE_FLOAT_FORMAT.\n\t* config/i370/i370.h (PRINT_OPERAND [TARGET_HLASM version]):\n\tUse REAL_VALUE_TO_DECIMAL as ELF version does.\n\t* config/m88k/m88k.c (real_power_of_2_operand,\n\tlegitimize_operand): Take the REAL_VALUE_TYPE and/or union\n\treal_extract out of the union; run the input through\n\tREAL_VALUE_TO_TARGET_DOUBLE, then plug the pair of longwords\n\tfrom that into the union.\n\t* config/pdp11/pdp11.c (output_move_double): Rearrange\n\tparentheses to make automatic indenter happy.\n\n\t* doc/tm.texi (Cross-compilation): Rename node to \"Floating\n\tPoint\" and rewrite to describe current situation.  Also adjust\n\tdocumentation of REAL_VALUE_TO_TARGET_SINGLE and friends to\n\tmatch code.\n\t* doc/rtl.texi: Adjust cross reference.\n\nFrom-SVN: r51210", "tree": {"sha": "3cb5ef5e8709f7285a36ca4c6896bc2b548fdba6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3cb5ef5e8709f7285a36ca4c6896bc2b548fdba6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/comments", "author": null, "committer": null, "parents": [{"sha": "4e9a8e8d6d9fea4d59865dbe7137fcb297d72f6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e9a8e8d6d9fea4d59865dbe7137fcb297d72f6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e9a8e8d6d9fea4d59865dbe7137fcb297d72f6f"}], "stats": {"total": 955, "additions": 415, "deletions": 540}, "files": [{"sha": "287ddeb12d8df80294806b160ade2c75017b4961", "filename": "gcc/ChangeLog", "status": "modified", "additions": 72, "deletions": 6, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -1,3 +1,69 @@\n+2002-03-22  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* real.h: Don't define REAL_INFINITY or REAL_IS_NOT_DOUBLE.\n+\tAlways make REAL_VALUE_TYPE a struct containing an array of\n+\tHOST_WIDE_INT, not a double.  Tidy up the code deciding how\n+\tbig it is.  Don't declare or use union real_extract.\n+\n+\t* emit-rtl.c (init_emit_once), varasm.c (immed_real_const_1,\n+\tdecode_rtx_const, output_constant_pool), config/a29k/a29k.c\n+\t(print_operand), config/arm/arm.c (output_move_double),\n+\tconfig/arm/arm.md (consttable_4, consttable_8),\n+\tconfig/romp/romp.c (output_fpops), config/s390/s390.h\n+\t(ASM_OUTPUT_SPECIAL_POOL_ENTRY), config/xtensa/xtensa.c\n+\t(xtensa_output_literal): Don't use union real_extract.\n+\n+\t* config/dsp16xx/dsp16xx.c (print_operand), config/i860/i860.c\n+\t(sfmode_constant_to_ulong), config/ns32k/merlin.h\n+\t(PRINT_OPERAND), config/ns32k/ns32k.c (print_operand),\n+\tconfig/pdp11/pdp11.h (PRINT_OPERAND), config/we32k/we32k.h\n+\t(PRINT_OPERAND): Don't use local version of union\n+\treal_extract.\n+\n+\t* config/convex/convex.c (check_float_value), config/vax/vax.c\n+\t(vax_float_literal), config/m88k/m88k.md (divdf3),\n+\tconfig/dsp16xx/dsp16xx.md (fixuns_trunchfhi2),\n+\tconfig/pdp11/pdp11.c (output_move_quad): Don't do host\n+\tarithmetic on target floating point quantities.\n+\n+\t* config/a29k/a29k.md, config/dsp16xx/dsp16xx.c\n+\t(output_dsp16xx_float_const): Don't test HOST_FLOAT_FORMAT.\n+\n+\t* fold-const.c (fold), simplify-rtx.c (simplify_binary_real):\n+\tUse MODE_HAS_INFINITIES rather than #ifdef REAL_INFINITY.\n+\n+\t* real.c (earith): Test INFINITY rather than REAL_INFINITY;\n+\tNANS implies INFINITY, so can drop #ifdef NANS inside #ifndef\n+\tINFINITY.\n+\t* print-rtl.c (print_rtx): Disable code which needs\n+\tfloating-point emulator.\n+\t* libgcc2.c: Include float.h and use DBL_MANT_DIG,\n+\tFLT_MANT_DIG, to define DF_SIZE and SF_SIZE, rather than\n+\tdepending on HOST_FLOAT_FORMAT to be defined properly.\n+\n+\t* config/1750a/1750a.c (get_double, float_label): Delete.\n+\t(print_operand): Delete huge commented-out chunk.  Use\n+\tREAL_VALUE_TO_DECIMAL.\n+\t* config/1750a/1750a-protos.h: Delete prototypes of deleted\n+\tfunctions.\n+\t* config/convex/convex.h: Always set TARGET_FLOAT_FORMAT to\n+\tIEEE_FLOAT_FORMAT.\n+\t* config/i370/i370.h (PRINT_OPERAND [TARGET_HLASM version]):\n+\tUse REAL_VALUE_TO_DECIMAL as ELF version does.\n+\t* config/m88k/m88k.c (real_power_of_2_operand,\n+\tlegitimize_operand): Take the REAL_VALUE_TYPE and/or union\n+\treal_extract out of the union; run the input through\n+\tREAL_VALUE_TO_TARGET_DOUBLE, then plug the pair of longwords\n+\tfrom that into the union.\n+\t* config/pdp11/pdp11.c (output_move_double): Rearrange\n+\tparentheses to make automatic indenter happy.\n+\n+\t* doc/tm.texi (Cross-compilation): Rename node to \"Floating\n+\tPoint\" and rewrite to describe current situation.  Also adjust\n+\tdocumentation of REAL_VALUE_TO_TARGET_SINGLE and friends to\n+\tmatch code.\n+\t* doc/rtl.texi: Adjust cross reference.\n+\n 2002-03-22  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config/xtensa/xtensa-protos.h (non_acc_reg_operand): Remove.\n@@ -14,13 +80,13 @@\n \n 2002-03-22  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n-        * cpphash.h (struct cpp_reader): Remove mls_line and mls_col.\n-        * cpplex.c (unterminated): Delete.\n-        (parse_string): No string literal may extend over multiple\n-        lines.  Suppress the error when preprocessing assembly.\n+\t* cpphash.h (struct cpp_reader): Remove mls_line and mls_col.\n+\t* cpplex.c (unterminated): Delete.\n+\t(parse_string): No string literal may extend over multiple\n+\tlines.  Suppress the error when preprocessing assembly.\n \t* cppmain.c (scan_translation_unit): Strings are single-line.\n \n-        * doc/cpp.texi: Update to match.\n+\t* doc/cpp.texi: Update to match.\n \n 2002-03-22  Jakub Jelinek  <jakub@redhat.com>\n \n@@ -495,7 +561,7 @@ Tue Mar 19 14:12:32 2002  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n 2002-03-18  Mark Mitchell  <mark@codesourcery.com>\n \n-\t* calls.c (precompute_arguments): Do not assume that temporaries \n+\t* calls.c (precompute_arguments): Do not assume that temporaries\n \tcan be destroyed after expanding the argument.\n \t(expand_call): Likewise.\n "}, {"sha": "5dafdbb353f7c70f435edf21df44d0e33000bf36", "filename": "gcc/ch/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fch%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fch%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FChangeLog?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -1,3 +1,8 @@\n+2002-03-22  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* grant.c: Always use REAL_VALUE_TO_DECIMAL; don't test\n+\tREAL_IS_NOT_DOUBLE.\n+\n 2002-03-12  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* decl.c (chill_tree_code_type, chill_tree_code_length,"}, {"sha": "48973e0851c42902d2608ce256242877276960c6", "filename": "gcc/ch/grant.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fch%2Fgrant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fch%2Fgrant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fgrant.c?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -1851,11 +1851,7 @@ decode_constant (init)\n       return result;\n \n     case REAL_CST:\n-#ifndef REAL_IS_NOT_DOUBLE\n-      sprintf (wrk, \"%.20g\", TREE_REAL_CST (val));\n-#else\n       REAL_VALUE_TO_DECIMAL (TREE_REAL_CST (val), \"%.20g\", wrk);\n-#endif\n       APPEND (result, wrk);\n       return result;\n "}, {"sha": "c437f00f3e176bdb30df8d715b4115f2b9853b21", "filename": "gcc/config/1750a/1750a-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2F1750a%2F1750a-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2F1750a%2F1750a-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a-protos.h?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -26,7 +26,6 @@ extern struct rtx_def *function_arg PARAMS ((int, enum machine_mode, tree, int))\n extern const char *movcnt_regno_adjust PARAMS ((rtx *));\n extern const char *mod_regno_adjust PARAMS ((const char *, rtx *));\n extern void notice_update_cc PARAMS ((rtx));\n-extern double get_double PARAMS ((rtx));\n extern int memop_valid PARAMS ((rtx));\n extern int mov_memory_operand PARAMS ((rtx, enum machine_mode));\n extern int small_nonneg_const PARAMS ((rtx, enum machine_mode));\n@@ -38,7 +37,6 @@ extern void print_operand PARAMS ((FILE *, rtx, int));\n extern void print_operand_address PARAMS ((FILE *, rtx));\n #endif /* RTX_CODE */\n \n-extern char *float_label PARAMS ((int, double));\n extern const char *branch_or_jump PARAMS ((const char *, int));\n extern int find_jmplbl PARAMS ((int));\n extern int one_bit_set_p PARAMS ((int));"}, {"sha": "c8b6a796efc2db967fe508f255a38501182e3585", "filename": "gcc/config/1750a/1750a.c", "status": "modified", "additions": 7, "deletions": 89, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2F1750a%2F1750a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2F1750a%2F1750a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.c?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -239,44 +239,6 @@ function_arg (cum, mode, type, named)\n     return (rtx) 0;\n }\n \n-\n-double\n-get_double (x)\n-     rtx x;\n-{\n-  union\n-    {\n-      double d;\n-      long i[2];\n-    }\n-  du;\n-\n-  du.i[0] = CONST_DOUBLE_LOW (x);\n-  du.i[1] = CONST_DOUBLE_HIGH (x);\n-  return du.d;\n-}\n-\n-char *\n-float_label (code, value)\n-     int code;\n-     double value;\n-{\n-  static char label[32];\n-  char *p;\n-\n-  label[0] = code;\n-  p = label + 1;\n-  sprintf (p, \"%f\", value);\n-  while (*p)\n-    {\n-      *p = (*p == '+') ? 'p' :\n-\t(*p == '-') ? 'm' : *p;\n-      p++;\n-    }\n-  return xstrdup (label);\n-}\n-\n-\n const char *\n movcnt_regno_adjust (op)\n      rtx *op;\n@@ -588,59 +550,15 @@ print_operand (file, x, letter)\n       break;\n \n     case CONST_DOUBLE:\n-/*    {\n-\tdouble value = get_double (x);\n-\tchar fltstr[32];\n-\tsprintf (fltstr, \"%f\", value);\n+      {\n+\tREAL_VALUE_TYPE r;\n+\tchar buf[30];\n \n-\tif (letter == 'D' || letter == 'E')\n-\t  {\n-\t    int i, found = 0;\n-\t    for (i = 0; i <= datalbl_ndx; i++)\n-\t      if (strcmp (fltstr, datalbl[i].value) == 0)\n-\t\t{\n-\t\t  found = 1;\n-\t\t  break;\n-\t\t}\n-\t    if (!found)\n-\t      {\n-\t\tstrcpy (datalbl[i = ++datalbl_ndx].value, fltstr);\n-\t\tdatalbl[i].name = float_label (letter, value);\n-\t\tdatalbl[i].size = (letter == 'E') ? 3 : 2;\n-\t\tcheck_section (Konst);\n-\t\tfprintf (file, \"K%s \\tdata%s %s ;p_o\\n\", datalbl[i].name,\n-\t\t\t(letter == 'E' ? \"ef\" : \"f\"), fltstr);\n-\t\tcheck_section (Normal);\n-\t      }\n-\t  }\n-\telse if (letter == 'F' || letter == 'G')\n-\t  {\n-\t    int i, found = 0;\n-\t    for (i = 0; i <= datalbl_ndx; i++)\n-\t      if (strcmp (fltstr, datalbl[i].value) == 0)\n-\t\t{\n-\t\t  found = 1;\n-\t\t  break;\n-\t\t}\n-\t    if (!found)\n-\t      {\n-\t\tfprintf (stderr,\n-\t\t   \"float value %f not found upon label reference\\n\", value);\n-\t\tstrcpy (datalbl[i = ++datalbl_ndx].value, fltstr);\n-\t\tdatalbl[i].name = float_label (letter, value);\n-\t\tdatalbl[i].size = (letter == 'G') ? 3 : 2;\n-\t\tcheck_section (Konst);\n-\t\tfprintf (file, \"K%s \\tdata%s %s ;p_o\\n\", datalbl[i].name,\n-\t\t\t(letter == 'G' ? \"ef\" : \"f\"), fltstr);\n-\t\tcheck_section (Normal);\n-\t      }\n-\t    fprintf (file, \"%s ;P_O 'F'\", datalbl[i].name);\n-\t  }\n-\telse\n-\t  fprintf (file, \" %s  ;P_O cst_dbl \", fltstr);\n+\tREAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+\tREAL_VALUE_TO_DECIMAL (r, \"%f\", buf);\n+\n+\tfputs (buf, file);\n       }\n- */\n-      fprintf (file, \"%f\", get_double (x));\n       break;\n \n     case CONST_INT:"}, {"sha": "bd08c38c78697d0764835e141ca3566ac75c9ea7", "filename": "gcc/config/a29k/a29k.c", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fa29k%2Fa29k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fa29k%2Fa29k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.c?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -1143,10 +1143,13 @@ print_operand (file, x, code)\n     case 'L':\n       if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == DFmode)\n \t{\n-\t  union real_extract u;\n+\t  REAL_VALUE_TYPE r;\n+\t  char s[30];\n \n-\t  memcpy ((char *) &u, (char *) &CONST_DOUBLE_LOW (x), sizeof u);\n-\t  fprintf (file, \"$double1(%.20e)\", u.d);\n+\t  REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+\t  REAL_VALUE_TO_DECIMAL (r, \"%.20e\", s);\n+\n+\t  fprintf (file, \"$double1(%s)\", s);\n \t}\n       else if (GET_CODE (x) == REG)\n \tfprintf (file, \"%s\", reg_names[REGNO (x) + 1]);\n@@ -1204,26 +1207,30 @@ print_operand (file, x, code)\n   else if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == SUBREG\n \t   && GET_CODE (SUBREG_REG (XEXP (x, 0))) == CONST_DOUBLE)\n     {\n-      union real_extract u;\n+      REAL_VALUE_TYPE r;\n+      char s[30];\n \n       if (GET_MODE (SUBREG_REG (XEXP (x, 0))) == SFmode)\n \tfprintf (file, \"$float\");\n       else\n \tfprintf (file, \"$double%d\", \n-\t\t (SUBREG_BYTE (XEXP (x, 0)) / GET_MODE_SIZE (GET_MODE (x))));      \n-      memcpy ((char *) &u,\n-\t      (char *) &CONST_DOUBLE_LOW (SUBREG_REG (XEXP (x, 0))), sizeof u);\n-      fprintf (file, \"(%.20e)\", u.d);\n+\t\t (SUBREG_BYTE (XEXP (x, 0)) / GET_MODE_SIZE (GET_MODE (x))));\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+      REAL_VALUE_TO_DECIMAL (r, \"%.20e\", s);\n+      fprintf (file, \"(%s)\", s);\n     }\n \n   else if (GET_CODE (x) == CONST_DOUBLE\n \t   && GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n     {\n-      union real_extract u;\n+      REAL_VALUE_TYPE r;\n+      char s[30];\n \n-      memcpy ((char *) &u, (char *) &CONST_DOUBLE_LOW (x), sizeof u);\n-      fprintf (file, \"$%s(%.20e)\",\n-\t       GET_MODE (x) == SFmode ? \"float\" : \"double0\", u.d);\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+      REAL_VALUE_TO_DECIMAL (r, \"%.20e\", s);\n+      fprintf (file, \"$%s(%s)\",\n+\t       GET_MODE (x) == SFmode ? \"float\" : \"double0\", s);\n     }\n \n   else"}, {"sha": "d4e4f34595f245ef3f306f33f2d5fecf41aa263e", "filename": "gcc/config/a29k/a29k.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fa29k%2Fa29k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fa29k%2Fa29k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.md?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -2005,7 +2005,7 @@\n (define_split\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n \t(match_operand:SF 1 \"float_const_operand\" \"\"))]\n-  \"HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\"\n+  \"\"\n   [(set (match_dup 0)\n \t(match_dup 1))]\n   \""}, {"sha": "814c84d9888d4b2fafd60e694dab14b7c4dc0693", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -6534,11 +6534,11 @@ output_move_double (operands)\n \t{\n \t  if (GET_MODE (operands[1]) == DFmode)\n \t    {\n+\t      REAL_VALUE_TYPE r;\n \t      long l[2];\n-\t      union real_extract u;\n \n-\t      memcpy (&u, &CONST_DOUBLE_LOW (operands[1]), sizeof (u));\n-\t      REAL_VALUE_TO_TARGET_DOUBLE (u.d, l);\n+\t      REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+\t      REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n \t      otherops[1] = GEN_INT (l[1]);\n \t      operands[1] = GEN_INT (l[0]);\n \t    }"}, {"sha": "9ea7d0c8a06d21beb208f5fcc4e624effad42444", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -9079,9 +9079,9 @@\n       {\n       case MODE_FLOAT:\n       {\n-        union real_extract u;\n-        memcpy (&u, &CONST_DOUBLE_LOW (operands[0]), sizeof u);\n-        assemble_real (u.d, GET_MODE (operands[0]), BITS_PER_WORD);\n+        REAL_VALUE_TYPE r;\n+        REAL_VALUE_FROM_CONST_DOUBLE (r, operands[0]);\n+        assemble_real (r, GET_MODE (operands[0]), BITS_PER_WORD);\n         break;\n       }\n       default:\n@@ -9103,9 +9103,9 @@\n       {\n        case MODE_FLOAT:\n         {\n-          union real_extract u;\n-          memcpy (&u, &CONST_DOUBLE_LOW (operands[0]), sizeof u);\n-          assemble_real (u.d, GET_MODE (operands[0]), BITS_PER_WORD);\n+          REAL_VALUE_TYPE r;\n+          REAL_VALUE_FROM_CONST_DOUBLE (r, operands[0]);\n+          assemble_real (r, GET_MODE (operands[0]), BITS_PER_WORD);\n           break;\n         }\n       default:"}, {"sha": "74af45ec2a5754da2755a317417a53ac9b392964", "filename": "gcc/config/convex/convex.c", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fconvex%2Fconvex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fconvex%2Fconvex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.c?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -515,12 +515,12 @@ expand_movstr_call (operands)\n \t\t     TYPE_MODE (sizetype));\n }\n \f\n-#if _IEEE_FLOAT_\n-#define MAX_FLOAT 3.4028234663852886e+38\n-#define MIN_FLOAT 1.1754943508222875e-38\n+#if TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n+#define MAX_FLOAT \"3.4028234663852886e+38\"\n+#define MIN_FLOAT \"1.1754943508222875e-38\"\n #else\n-#define MAX_FLOAT 1.7014117331926443e+38\n-#define MIN_FLOAT 2.9387358770557188e-39\n+#define MAX_FLOAT \"1.7014117331926443e+38\"\n+#define MIN_FLOAT \"2.9387358770557188e-39\"\n #endif\n \n int\n@@ -530,28 +530,35 @@ check_float_value (mode, dp, overflow)\n      int overflow;\n {\n   REAL_VALUE_TYPE d = *dp;\n+  REAL_VALUE_TYPE maxfloat = REAL_VALUE_ATOF (MAX_FLOAT, mode);\n+  REAL_VALUE_TYPE minfloat = REAL_VALUE_ATOF (MIN_FLOAT, mode);\n+  REAL_VALUE_TYPE neg_maxfloat = REAL_VALUE_NEGATE (maxfloat);\n+  REAL_VALUE_TYPE neg_minfloat = REAL_VALUE_NEGATE (minfloat);\n \n   if (overflow)\n     {\n-      *dp = MAX_FLOAT;\n+      *dp = maxfloat;\n       return 1;\n     }\n \n   if (mode == SFmode)\n     {\n-      if (d > MAX_FLOAT)\n+      if (REAL_VALUES_LESS (maxfloat, d))\n \t{\n-\t  *dp = MAX_FLOAT;\n+\t  *dp = maxfloat;\n \t  return 1;\n \t}\n-      else if (d < -MAX_FLOAT)\n+      else if (REAL_VALUES_LESS (d, neg_maxfloat))\n \t{\n-\t  *dp = -MAX_FLOAT;\n+\t  *dp = neg_maxfloat;\n \t  return 1;\n \t}\t\n-      else if ((d > 0 && d < MIN_FLOAT) || (d < 0 && d > -MIN_FLOAT))\n+      else if ((REAL_VALUES_LESS (dconst0, d)\n+\t\t&& REAL_VALUES_LESS (d, minfloat))\n+\t       || (REAL_VALUES_LESS (d, dconst0)\n+\t\t   && REAL_VALUES_LESS (neg_minfloat, d)))\n \t{\n-\t  *dp = 0.0;\n+\t  *dp = dconst0;\n \t  return 1;\n \t}\n     }\n@@ -628,16 +635,7 @@ print_operand (file, x, code)\n       REAL_VALUE_FROM_CONST_DOUBLE (d, x);\n       switch (GET_MODE (x)) {\n       case DFmode:\n-#if 0 /* doesn't work, produces dfloats */\n \tREAL_VALUE_TO_TARGET_DOUBLE (d, u); \n-#else\n-\t{\n-\t  union { double d; int i[2]; } t;\n-\t  t.d = d;\n-\t  u[0] = t.i[0];\n-\t  u[1] = t.i[1];\n-\t}\n-#endif\n \tif (code == 'u')\n \t  fprintf (file, \"#%#lx\", u[0]);\n \telse if (code == 'v')"}, {"sha": "d50f60b0fd2d8ff2624bffe56485ffa269dfad24", "filename": "gcc/config/convex/convex.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fconvex%2Fconvex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fconvex%2Fconvex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.h?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -1073,9 +1073,8 @@ enum reg_class {\n \n #define BRANCH_COST 0\n \n-/* Convex uses VAX or IEEE floats.\n-   Follow the host format.  */\n-#define TARGET_FLOAT_FORMAT HOST_FLOAT_FORMAT\n+/* Convex uses VAX or IEEE floats.  Default to IEEE.  */\n+#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n \n /* Check a `double' value for validity for a particular machine mode.  */\n #define CHECK_FLOAT_VALUE(MODE, D, OVERFLOW) \\"}, {"sha": "7f5cc0b06c42009821637508287e42c7fda69b03", "filename": "gcc/config/dsp16xx/dsp16xx.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -1870,16 +1870,15 @@ print_operand(file, op, letter)\n \t  fprintf (file, HOST_WIDE_INT_PRINT_HEX, (val >> 16) & 0xffff);\n         else\n            output_addr_const(file, op);\n-    }\n+      }\n     else if (code == CONST_DOUBLE && GET_MODE(op) != DImode)\n-    {\n-\t  union { double d; int i[2]; } u;\n-\t  union { float f; int i; } u1;\n-\t  u.i[0] = CONST_DOUBLE_LOW (op);\n-\t  u.i[1] = CONST_DOUBLE_HIGH (op);\n-\t  u1.f = u.d;\n-          fprintf (file, \"0x%x\", u1.i);\n-    }\n+      {\n+\tlong l;\n+\tREAL_VALUE_TYPE r;\n+\tREAL_VALUE_FROM_CONST_DOUBLE (r, op);\n+\tREAL_VALUE_TO_TARGET_SINGLE (r, l);\n+\tfprintf (file, \"0x%x\", l);\n+      }\n     else if (code == CONST)\n       {\n \trtx addr = XEXP (op, 0);\n@@ -1977,7 +1976,6 @@ output_dsp16xx_float_const (operands)\n {\n   rtx src = operands[1];\n   \n-#if HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n   REAL_VALUE_TYPE d;\n   long value;\n   \n@@ -1986,9 +1984,6 @@ output_dsp16xx_float_const (operands)\n   \n   operands[1] = GEN_INT (value);\n   output_asm_insn (\"%u0=%U1\\n\\t%w0=%H1\", operands);\n-#else\n-  fatal_error (\"inline float constants not supported on this host\");\n-#endif\n }\n \n static int"}, {"sha": "31247ba38f81e6d31f03c21b2b54f0ad41124ef0", "filename": "gcc/config/dsp16xx/dsp16xx.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -1935,7 +1935,7 @@\n   rtx reg3 = gen_reg_rtx (HImode);\n   rtx label1 = gen_label_rtx ();\n   rtx label2 = gen_label_rtx ();\n-  REAL_VALUE_TYPE offset = REAL_VALUE_LDEXP (1.0, 31);\n+  REAL_VALUE_TYPE offset = REAL_VALUE_LDEXP (dconst1, 31);\n \n   if (reg1)\t\t\t/* turn off complaints about unreached code */\n     {"}, {"sha": "adcaca675d78b329d6d0df0acd4cb46025c78185", "filename": "gcc/config/i370/i370.h", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fi370%2Fi370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fi370%2Fi370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.h?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -1374,21 +1374,26 @@ enum reg_class\n \t  }\t\t\t\t\t\t\t\t\\\n \telse\t\t\t\t\t\t\t\t\\\n \t  { \t\t\t\t\t\t\t\t\\\n-            /* hack alert -- this prints wildly incorrect values */\t\\\n-            /* when run in cross-compiler mode. See ELF section  */\t\\\n-            /* for suggested fix */\t\t\t\t\t\\\n-\t    union { double d; int i[2]; } u;\t\t\t\t\\\n-\t    u.i[0] = CONST_DOUBLE_LOW (XV);\t\t\t\t\\\n-\t    u.i[1] = CONST_DOUBLE_HIGH (XV);\t\t\t\t\\\n+            char buf[50];\t\t\t\t\t\t\\\n+            REAL_VALUE_TYPE rval;\t\t\t\t\t\\\n+            REAL_VALUE_FROM_CONST_DOUBLE(rval, XV);\t\t\t\\\n+            REAL_VALUE_TO_DECIMAL (rval, HOST_WIDE_INT_PRINT_DEC, buf);\t\\\n \t    if (GET_MODE (XV) == SFmode)\t\t\t\t\\\n \t      {\t\t\t\t\t\t\t\t\\\n \t\tmvs_page_lit += 4;\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=E'%.9G'\", u.d);\t\t\t\\\n+\t\tfprintf (FILE, \"=E'%s'\", buf);\t\t\t\t\\\n \t      }\t\t\t\t\t\t\t\t\\\n \t    else\t\t\t\t\t\t\t\\\n+\t    if (GET_MODE (XV) == DFmode)\t\t\t\t\\\n \t      {\t\t\t\t\t\t\t\t\\\n \t\tmvs_page_lit += 8;\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=D'%.18G'\", u.d);\t\t\t\\\n+\t\tfprintf (FILE, \"=D'%s'\", buf);\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t    else /* VOIDmode !?!? strange but true ...  */\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"=XL8'%08X%08X'\", \t\t\t\\\n+\t\t\tCONST_DOUBLE_HIGH (XV), CONST_DOUBLE_LOW (XV));\t\\\n \t      }\t\t\t\t\t\t\t\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n \tbreak;\t\t\t\t\t\t\t\t\\"}, {"sha": "18493976615d5b935907510fd88ccd1e758a9b2f", "filename": "gcc/config/i860/i860.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -1549,17 +1549,14 @@ sfmode_constant_to_ulong (x)\n      rtx x;\n {\n   REAL_VALUE_TYPE d;\n-  union { float f; unsigned long i; } u2;\n+  unsigned long l;\n \n   if (GET_CODE (x) != CONST_DOUBLE || GET_MODE (x) != SFmode)\n     abort ();\n \n-#if TARGET_FLOAT_FORMAT != HOST_FLOAT_FORMAT\n- error IEEE emulation needed\n-#endif\n   REAL_VALUE_FROM_CONST_DOUBLE (d, x);\n-  u2.f = d;\n-  return u2.i;\n+  REAL_VALUE_TO_TARGET_SINGLE (d, l);\n+  return l;\n }\n \f\n /* This function generates the assembly code for function entry."}, {"sha": "80f3ff44b4792920699eace994b208eb3cfcc116", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -1123,9 +1123,9 @@ real_power_of_2_operand (op, mode)\n      rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n+  REAL_VALUE_TYPE d;\n   union {\n-    REAL_VALUE_TYPE d;\n-    int i[sizeof (REAL_VALUE_TYPE) / sizeof (int)];\n+    long l[2];\n     struct {\t\t\t\t/* IEEE double precision format */\n       unsigned sign\t :  1;\n       unsigned exponent  : 11;\n@@ -1147,8 +1147,8 @@ real_power_of_2_operand (op, mode)\n   if (GET_CODE (op) != CONST_DOUBLE)\n     return 0;\n \n-  u.i[0] = CONST_DOUBLE_LOW  (op);\n-  u.i[1] = CONST_DOUBLE_HIGH (op);\n+  REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n+  REAL_VALUE_TO_TARGET_DOUBLE (d, u.l);\n \n   if (u.s.mantissa1 != 0 || u.s.mantissa2 != 0\t/* not a power of two */\n       || u.s.exponent == 0\t\t\t/* constant 0.0 */\n@@ -1169,8 +1169,9 @@ legitimize_operand (op, mode)\n      enum machine_mode mode;\n {\n   rtx temp;\n+  REAL_VALUE_TYPE r;\n   union {\n-    union real_extract r;\n+    long l[2];\n     struct {\t\t\t\t/* IEEE double precision format */\n       unsigned sign\t :  1;\n       unsigned exponent  : 11;\n@@ -1191,7 +1192,8 @@ legitimize_operand (op, mode)\n \n   if (GET_CODE (op) == CONST_DOUBLE)\n     {\n-      memcpy (&u.r, &CONST_DOUBLE_LOW (op), sizeof u);\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n+      REAL_VALUE_TO_TARGET_DOUBLE (r, u.l);\n       if (u.d.exponent != 0x7ff /* NaN */\n \t  && u.d.mantissa2 == 0 /* Mantissa fits */\n \t  && (u.s.exponent1 == 0x8 || u.s.exponent1 == 0x7) /* Exponent fits */"}, {"sha": "24a66f86ec8ecfb52775a5addcd246f5d6bb5e24", "filename": "gcc/config/m88k/m88k.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fm88k%2Fm88k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fm88k%2Fm88k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.md?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -3053,10 +3053,12 @@\n   operands[1] = legitimize_operand (operands[1], DFmode);\n   if (real_power_of_2_operand (operands[2], DFmode))\n     {\n-      union real_extract u;\n-      memcpy (&u, &CONST_DOUBLE_LOW (operands[2]), sizeof u);\n+      REAL_VALUE_TYPE r;\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, operands[2]);\n+      if (!exact_real_inverse (DFmode, &r))\n+        abort ();\n       emit_insn (gen_muldf3 (operands[0], operands[1],\n-\t\t\t     CONST_DOUBLE_FROM_REAL_VALUE (1.0/u.d, DFmode)));\n+\t\t\t     CONST_DOUBLE_FROM_REAL_VALUE (r, DFmode)));\n       DONE;\n     }\n   else if (! register_operand (operands[2], DFmode))"}, {"sha": "f38870dd3fc6808eba19f2531faea3d582711cef", "filename": "gcc/config/ns32k/merlin.h", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fns32k%2Fmerlin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fns32k%2Fmerlin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fmerlin.h?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -64,8 +64,8 @@ Boston, MA 02111-1307, USA.  */\n \n #ifdef UTEK_ASM\n #undef PRINT_OPERAND\n-#define PRINT_OPERAND(FILE, X, CODE)  \\\n-{ if (CODE == '$') putc('$', FILE);\t\t\t\t\t\\\n+#define PRINT_OPERAND(FILE, X, CODE) do {\t\t\t\t\\\n+  if (CODE == '$') putc('$', FILE);\t\t\t\t\t\\\n   else if (CODE == '?');\t\t\t\t\t\t\\\n   else if (GET_CODE (X) == CONST_INT)\t\t\t\t\t\\\n     fprintf(FILE, \"$%d\", INTVAL(X));\t\t\t\t\t\\\n@@ -116,14 +116,20 @@ Boston, MA 02111-1307, USA.  */\n \t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) != VOIDmode)\t\\\n-    if (GET_MODE (X) == DFmode)\t\t\t\t\t\t\\\n-      { union { double d; int i[2]; } u;\t\t\t\t\\\n-\tu.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n-\tfprintf (FILE, \"$0d%.20e\", u.d); }\t\t\t\t\\\n-    else { union { double d; int i[2]; } u;\t\t\t\t\\\n-\t   u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X); \\\n-\t   fprintf (FILE, \"$0f%.20e\", u.d); }\t\t\t\t\\\n-  else output_addr_const (FILE, X); }\n+    {\t\t\t\t\t\t\t\t\t\\\n+      char buf[50];\t\t\t\t\t\t\t\\\n+      REAL_VALUE_TYPE rval;\t\t\t\t\t\t\\\n+      REAL_VALUE_FROM_CONST_DOUBLE(rval, XV);\t\t\t\t\\\n+      REAL_VALUE_TO_DECIMAL (rval, \"%.20e\", buf);\t\t\t\\\n+      if (GET_MODE (XV) == SFmode)\t\t\t\t\t\\\n+\tfprintf (FILE, \"$0e%s\", buf);\t\t\t\t\t\\\n+      else if (GET_MODE (XV) == DFmode)\t\t\t\t\t\\\n+\tfprintf (FILE, \"$0d%s\", buf);\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tabort();\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else output_addr_const (FILE, X);\t\t\t\t\t\\\n+} while (0)\n \n #endif /* UTEK_ASM */\n "}, {"sha": "8c980c577b3373faa280b4eb50c62c9ccefee788", "filename": "gcc/config/ns32k/ns32k.c", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fns32k%2Fns32k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fns32k%2Fns32k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.c?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -1119,40 +1119,36 @@ print_operand (file, x, code)\n     }\n   else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) != VOIDmode)\n     {\n+      REAL_VALUE_TYPE r;\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+      PUT_IMMEDIATE_PREFIX (file);\n       if (GET_MODE (x) == DFmode)\n \t{ \n-\t  union { double d; int i[2]; } u;\n-\t  u.i[0] = CONST_DOUBLE_LOW (x); u.i[1] = CONST_DOUBLE_HIGH (x);\n-\t  PUT_IMMEDIATE_PREFIX (file);\n #ifdef SEQUENT_ASM\n \t  /* Sequent likes its floating point constants as integers */\n-\t  fprintf (file, \"0Dx%08x%08x\", u.i[1], u.i[0]);\n+\t  fprintf (file, \"0Dx%08x%08x\",\n+\t\t   CONST_DOUBLE_HIGH (x), CONST_DOUBLE_LOW (x));\n #else\n+\t  char s[30];\n+\t  REAL_VALUE_TO_DECIMAL (r, \"%.20e\", s);\n #ifdef ENCORE_ASM\n-\t  fprintf (file, \"0f%.20e\", u.d); \n+\t  fprintf (file, \"0f%s\", s);\n #else\n-\t  fprintf (file, \"0d%.20e\", u.d); \n+\t  fprintf (file, \"0d%s\", s);\n #endif\n #endif\n \t}\n       else\n-\t{ \n-\t  union { double d; int i[2]; } u;\n-\t  u.i[0] = CONST_DOUBLE_LOW (x); u.i[1] = CONST_DOUBLE_HIGH (x);\n-\t  PUT_IMMEDIATE_PREFIX (file);\n+\t{\n #ifdef SEQUENT_ASM\n-\t  /* We have no way of winning if we can't get the bits\n-\t     for a sequent floating point number.  */\n-#if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n-\t  abort ();\n-#endif\n-\t  {\n-\t    union { float f; long l; } uu;\n-\t    uu.f = u.d;\n-\t    fprintf (file, \"0Fx%08lx\", uu.l);\n-\t  }\n+\t  long l;\n+\t  REAL_VALUE_TO_TARGET_SINGLE (r, l);\n+\t  fprintf (file, \"0Fx%08lx\", l);\n #else\n-\t  fprintf (file, \"0f%.20e\", u.d); \n+\t  char s[30];\n+\t  REAL_VALUE_TO_DECIMAL (r, \"%.20e\", s);\n+\t  fprintf (file, \"0f%s\", s);\n #endif\n \t}\n     }"}, {"sha": "3643db6d28154b90a5f82b85c50213a4391d5b4f", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -400,10 +400,11 @@ output_move_double (operands)\n \n   if (REG_P (operands[1]))\n     optype1 = REGOP;\n-  else if (CONSTANT_P (operands[1]))\n+  else if (CONSTANT_P (operands[1])\n #if 0\n-\t   || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t   || GET_CODE (operands[1]) == CONST_DOUBLE\n #endif\n+\t   )\n     optype1 = CNSTOP;\n   else if (offsettable_memref_p (operands[1]))\n     optype1 = OFFSOP;\n@@ -620,11 +621,10 @@ output_move_quad (operands)\n       {\n \t  if (GET_CODE(operands[1]) == CONST_DOUBLE)\n \t  {\n-\t      union { double d; int i[2]; } u;\n-\t      u.i[0] = CONST_DOUBLE_LOW (operands[1]); \n-\t      u.i[1] = CONST_DOUBLE_HIGH (operands[1]); \n-\t      \n-\t      if (u.d == 0.0)\n+\t      REAL_VALUE_TYPE r;\n+\t      REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+\n+\t      if (REAL_VALUES_EQUAL (r, dconst0))\n \t\t  return \"{clrd|clrf} %0\";\n \t  }\n \t      "}, {"sha": "99bb7fe32d529af1240ef7f4f840cf4af46130aa", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -1140,9 +1140,11 @@ fprintf (FILE, \"$help$: . = .+8 ; space for tmp moves!\\n\")\t\\\n   else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n     output_address (XEXP (X, 0));\t\t\t\t\t\\\n   else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) != SImode)\t\\\n-    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n-      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n-      fprintf (FILE, \"#%.20e\", u.d); }\t\t\t\t\t\\\n+    { REAL_VALUE_TYPE r;\t\t\t\t\t\t\\\n+      char buf[30];\t\t\t\t\t\t\t\\\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, X);\t\t\t\t\\\n+      REAL_VALUE_TO_DECIMAL (r, \"%.20e\", buf);\t\t\t\t\\\n+      fprintf (FILE, \"#%s\", buf); }\t\t\t\t\t\\\n   else { putc ('$', FILE); output_addr_const_pdp11 (FILE, X); }}\n \f\n /* Print a memory address as an operand to reference that memory location.  */"}, {"sha": "a4813be29cdb4c73cbcee22ff2a2b409449f4422", "filename": "gcc/config/romp/romp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fromp%2Fromp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fromp%2Fromp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.c?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -1962,10 +1962,9 @@ output_fpops (file)\n \t      size_so_far += 4;\n \t      if (GET_CODE (immed[i]) == CONST_DOUBLE)\n \t\t{\n-\t\t  union real_extract u;\n-\n-\t\t  memcpy (&u, &CONST_DOUBLE_LOW (immed[i]), sizeof u);\n-\t\t  assemble_real (u.d, GET_MODE (immed[i]),\n+\t\t  REAL_VALUE_TYPE r;\n+\t\t  REAL_VALUE_FROM_CONST_DOUBLE (r, immed[i]);\n+\t\t  assemble_real (r, GET_MODE (immed[i]),\n \t\t\t\t GET_MODE_ALIGNMENT (GET_MODE (immed[i])));\n \t\t}\n \t      else"}, {"sha": "1ab431e1f41bf5fc205ce465f35cc4e97e565462", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -1386,8 +1386,8 @@ extern int s390_nr_constants;\n       if (GET_CODE (EXP) != CONST_DOUBLE)\t\t\t\t    \\\n \tabort ();\t\t\t\t\t\t\t    \\\n \t\t\t\t\t\t\t\t\t    \\\n-      memcpy ((char *) &u, (char *) &CONST_DOUBLE_LOW (EXP), sizeof u);\t    \\\n-      assemble_real (u.d, MODE, ALIGN);\t\t\t\t\t    \\\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, EXP);\t\t\t\t    \\\n+      assemble_real (r, MODE, ALIGN);\t\t\t\t\t    \\\n       break;\t\t\t\t\t\t\t\t    \\\n \t\t\t\t\t\t\t\t\t    \\\n     case MODE_INT:\t\t\t\t\t\t\t    \\"}, {"sha": "9665609df2a4c6ce58b93925fd813805222cdcf0", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -374,10 +374,8 @@ vax_float_literal(c)\n     register rtx c;\n {\n   register enum machine_mode mode;\n-#if HOST_FLOAT_FORMAT == VAX_FLOAT_FORMAT\n+  REAL_VALUE_TYPE r, s;\n   int i;\n-  union {double d; int i[2];} val;\n-#endif\n \n   if (GET_CODE (c) != CONST_DOUBLE)\n     return 0;\n@@ -389,15 +387,20 @@ vax_float_literal(c)\n       || c == const_tiny_rtx[(int) mode][2])\n     return 1;\n \n-#if HOST_FLOAT_FORMAT == VAX_FLOAT_FORMAT\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, c);\n \n-  val.i[0] = CONST_DOUBLE_LOW (c);\n-  val.i[1] = CONST_DOUBLE_HIGH (c);\n+  for (i = 0; i < 7; i++)\n+    {\n+      int x = 1 << i;\n+      REAL_VALUE_FROM_INT (s, x, 0, mode);\n \n-  for (i = 0; i < 7; i ++)\n-    if (val.d == 1 << i || val.d == 1 / (1 << i))\n-      return 1;\n-#endif\n+      if (REAL_VALUES_EQUAL (r, s))\n+\treturn 1;\n+      if (!exact_real_inverse (mode, &s))\n+\tabort ();\n+      if (REAL_VALUES_EQUAL (r, s))\n+\treturn 1;\n+    }\n   return 0;\n }\n "}, {"sha": "1bf6805d1e7138cdcb909085bc764b2fdc5ee990", "filename": "gcc/config/we32k/we32k.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fwe32k%2Fwe32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fwe32k%2Fwe32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwe32k%2Fwe32k.h?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -847,13 +847,12 @@ do {\t\t\t\t\t\t\t\\\n     output_address (XEXP (X, 0));\t\t\t\t\t\\\n   else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == SFmode)\t\\\n          {\t\t\t\t\t\t\t\t\\\n-         union { double d; long l[2]; } dtem;\t\t\t\t\\\n-         union { float f; long l; } ftem;\t\t\t\t\\\n+\t   REAL_VALUE_TYPE r;\t\t\t\t\t\t\\\n+\t   long l;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-         dtem.l[0] = CONST_DOUBLE_LOW (X);\t\t\t\t\\\n-         dtem.l[1] = CONST_DOUBLE_HIGH (X);\t\t\t\t\\\n-         ftem.f = dtem.d;\t\t\t\t\t\t\\\n-         fprintf(FILE, \"&0x%lx\", ftem.l);\t\t\t\t\\\n+\t   REAL_VALUE_FROM_CONST_DOUBLE (r, X);\t\t\t\t\\\n+\t   REAL_VALUE_TO_TARGET_SINGLE (r, l);\t\t\t\t\\\n+\t   fprintf (FILE, \"&0x%lx\", l);\t\t\t\t\t\\\n          }\t\t\t\t\t\t\t\t\\\n   else { putc ('&', FILE); output_addr_const (FILE, X); }}\n \f"}, {"sha": "a791da00fb75c529690b97545e5c5193e4312218", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -2078,7 +2078,7 @@ xtensa_output_literal (file, x, mode, labelno)\n      int labelno;\n {\n   long value_long[2];\n-  union real_extract u;\n+  REAL_VALUE_TYPE r;\n   int size;\n \n   fprintf (file, \"\\t.literal .LC%u, \", (unsigned) labelno);\n@@ -2089,18 +2089,18 @@ xtensa_output_literal (file, x, mode, labelno)\n       if (GET_CODE (x) != CONST_DOUBLE)\n \tabort ();\n \n-      memcpy ((char *) &u, (char *) &CONST_DOUBLE_LOW (x), sizeof u);\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n       switch (mode)\n \t{\n \tcase SFmode:\n-\t  REAL_VALUE_TO_TARGET_SINGLE (u.d, value_long[0]);\n-\t  fprintf (file, \"0x%08lx\\t\\t# %.12g (float)\\n\", value_long[0], u.d);\n+\t  REAL_VALUE_TO_TARGET_SINGLE (r, value_long[0]);\n+\t  fprintf (file, \"0x%08lx\\n\", value_long[0]);\n \t  break;\n \n \tcase DFmode:\n-\t  REAL_VALUE_TO_TARGET_DOUBLE (u.d, value_long);\n-\t  fprintf (file, \"0x%08lx, 0x%08lx # %.20g (double)\\n\",\n-\t\t   value_long[0], value_long[1], u.d);\n+\t  REAL_VALUE_TO_TARGET_DOUBLE (r, value_long);\n+\t  fprintf (file, \"0x%08lx, 0x%08lx\\n\",\n+\t\t   value_long[0], value_long[1]);\n \t  break;\n \n \tdefault:"}, {"sha": "01a5f67c83b2e15218e3da4405d119c829758bac", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -1,3 +1,8 @@\n+2002-03-22  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* error.c: Always use REAL_VALUE_TO_DECIMAL; don't test\n+\tREAL_IS_NOT_DOUBLE.\n+\n 2002-03-22  Jeff Knaggs  <jknaggs@redhat.com>\n \n \t* typeck.c (expand_ptrmemfunc_cst): Scale idx down to an index"}, {"sha": "077181f7dd73bd4553ab62f82cfc6d9f9f29c019", "filename": "gcc/cp/error.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -1507,17 +1507,13 @@ dump_expr (t, flags)\n       break;\n \n     case REAL_CST:\n-#ifndef REAL_IS_NOT_DOUBLE\n-      sprintf (digit_buffer, \"%g\", TREE_REAL_CST (t));\n-#else\n       {\n \tconst unsigned char *p = (const unsigned char *) &TREE_REAL_CST (t);\n \tsize_t i;\n \tstrcpy (digit_buffer, \"0x\");\n \tfor (i = 0; i < sizeof TREE_REAL_CST (t); i++)\n \t  sprintf (digit_buffer + 2 + 2*i, \"%02x\", *p++);\n       }\n-#endif\n       output_add_string (scratch_buffer, digit_buffer);\n       break;\n "}, {"sha": "10c81e47d65567ac8ec0fd03d759fcca5014bc68", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -1204,7 +1204,7 @@ If @var{m} is @code{VOIDmode}, the bits of the value are stored in\n \n If the constant is floating point (regardless of its precision), then\n the number of integers used to store the value depends on the size of\n-@code{REAL_VALUE_TYPE} (@pxref{Cross-compilation}).  The integers\n+@code{REAL_VALUE_TYPE} (@pxref{Floating Point}).  The integers\n represent a floating point number, but not precisely in the target\n machine's or host machine's floating point format.  To convert them to\n the precise bit pattern used by the target machine, use the macro"}, {"sha": "ac44ee356406a6d6bd49581e3dcfd215b23ca2e0", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 111, "deletions": 150, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -46,7 +46,7 @@ through the macros defined in the @file{.h} file.\n * PIC::\t\t\tMacros for position independent code.\n * Assembler Format::    Defining how to write insns and pseudo-ops to output.\n * Debugging Info::      Defining the format of debugging output.\n-* Cross-compilation::   Handling floating point for cross-compilers.\n+* Floating Point::      Handling floating point for cross-compilers.\n * Mode Switching::      Insertion of mode-switching instructions.\n * Target Attributes::   Defining target-specific uses of @code{__attribute__}.\n * Misc::                Everything else.\n@@ -6051,12 +6051,14 @@ of @code{ASM_OUTPUT_DOUBLE} and the like:\n @findex REAL_VALUE_TO_TARGET_DOUBLE\n @findex REAL_VALUE_TO_TARGET_LONG_DOUBLE\n These translate @var{x}, of type @code{REAL_VALUE_TYPE}, to the target's\n-floating point representation, and store its bit pattern in the array of\n-@code{long int} whose address is @var{l}.  The number of elements in the\n-output array is determined by the size of the desired target floating\n-point data type: 32 bits of it go in each @code{long int} array\n-element.  Each array element holds 32 bits of the result, even if\n-@code{long int} is wider than 32 bits on the host machine.\n+floating point representation, and store its bit pattern in the variable\n+@var{l}.  For @code{REAL_VALUE_TO_TARGET_SINGLE}, this variable should\n+be a simple @code{long int}.  For the others, it should be an array of\n+@code{long int}.  The number of elements in this array is determined by\n+the size of the desired target floating point data type: 32 bits of it\n+go in each @code{long int} array element.  Each array element holds 32\n+bits of the result, even if @code{long int} is wider than 32 bits on the\n+host machine.\n \n The array element values are designed so that you can print them out\n using @code{fprintf} in the order they should appear in the target\n@@ -7753,167 +7755,126 @@ behavior is controlled by @code{OPTIMIZATION_OPTIONS} and\n @code{OVERRIDE_OPTIONS}.\n @end table\n \n-@node Cross-compilation\n+@node Floating Point\n @section Cross Compilation and Floating Point\n @cindex cross compilation and floating point\n @cindex floating point and cross compilation\n \n-While all modern machines use 2's complement representation for integers,\n+While all modern machines use twos-complement representation for integers,\n there are a variety of representations for floating point numbers.  This\n means that in a cross-compiler the representation of floating point numbers\n in the compiled program may be different from that used in the machine\n doing the compilation.\n \n-@findex atof\n Because different representation systems may offer different amounts of\n-range and precision, the cross compiler cannot safely use the host\n-machine's floating point arithmetic.  Therefore, floating point constants\n-must be represented in the target machine's format.  This means that the\n-cross compiler cannot use @code{atof} to parse a floating point constant;\n-it must have its own special routine to use instead.  Also, constant\n-folding must emulate the target machine's arithmetic (or must not be done\n-at all).\n-\n-The macros in the following table are provided by @file{real.h} for the\n-compiler to use.  All parts of the compiler which generate or optimize\n+range and precision, all floating point constants must be represented in\n+the target machine's format.  Therefore, the cross compiler cannot\n+safely use the host machine's floating point arithmetic; it must emulate\n+the target's arithmetic.  To ensure consistency, GCC always uses\n+emulation to work with floating point values, even when the host and\n+target floating point formats are identical.\n+\n+The following macros are provided by @file{real.h} for the compiler to\n+use.  All parts of the compiler which generate or optimize\n floating-point calculations must use these macros.  They may evaluate\n their operands more than once, so operands must not have side effects.\n \n-@table @code\n-@findex REAL_VALUE_TYPE\n-@item REAL_VALUE_TYPE\n-A macro for the C data type to be used to hold a floating point value\n-in the target machine's format.  Typically this would be a\n-@code{struct} containing an array of @code{int}.\n-\n-@findex REAL_VALUES_EQUAL\n-@item REAL_VALUES_EQUAL (@var{x}, @var{y})\n-A macro for a C expression which compares for equality the two values,\n-@var{x} and @var{y}, both of type @code{REAL_VALUE_TYPE}.\n-\n-@findex REAL_VALUES_LESS\n-@item REAL_VALUES_LESS (@var{x}, @var{y})\n-A macro for a C expression which tests whether @var{x} is less than\n-@var{y}, both values being of type @code{REAL_VALUE_TYPE} and\n-interpreted as floating point numbers in the target machine's\n-representation.\n-\n-@findex REAL_VALUE_LDEXP\n+@defmac REAL_VALUE_TYPE\n+The C data type to be used to hold a floating point value in the target\n+machine's format.  Typically this is a @code{struct} containing an\n+array of @code{HOST_WIDE_INT}, but all code should treat it as an opaque\n+quantity.\n+@end defmac\n+\n+@deftypefn Macro int REAL_VALUES_EQUAL (REAL_VALUE_TYPE @var{x}, REAL_VALUE_TYPE @var{y})\n+Compares for equality the two values, @var{x} and @var{y}.  If the target\n+floating point format supports negative zeroes and/or NaNs,\n+@samp{REAL_VALUES_EQUAL (-0.0, 0.0)} is true, and\n+@samp{REAL_VALUES_EQUAL (NaN, NaN)} is false.\n+@end deftypefn\n+\n+@deftypefn Macro int REAL_VALUES_LESS (REAL_VALUE_TYPE @var{x}, REAL_VALUE_TYPE @var{y})\n+Tests whether @var{x} is less than @var{y}.\n+@end deftypefn\n+\n @findex ldexp\n-@item REAL_VALUE_LDEXP (@var{x}, @var{scale})\n-A macro for a C expression which performs the standard library\n-function @code{ldexp}, but using the target machine's floating point\n-representation.  Both @var{x} and the value of the expression have\n-type @code{REAL_VALUE_TYPE}.  The second argument, @var{scale}, is an\n-integer.\n-\n-@findex REAL_VALUE_FIX\n-@item REAL_VALUE_FIX (@var{x})\n-A macro whose definition is a C expression to convert the target-machine\n-floating point value @var{x} to a signed integer.  @var{x} has type\n-@code{REAL_VALUE_TYPE}.\n-\n-@findex REAL_VALUE_UNSIGNED_FIX\n-@item REAL_VALUE_UNSIGNED_FIX (@var{x})\n-A macro whose definition is a C expression to convert the target-machine\n-floating point value @var{x} to an unsigned integer.  @var{x} has type\n-@code{REAL_VALUE_TYPE}.\n-\n-@findex REAL_VALUE_RNDZINT\n-@item REAL_VALUE_RNDZINT (@var{x})\n-A macro whose definition is a C expression to round the target-machine\n-floating point value @var{x} towards zero to an integer value (but still\n-as a floating point number).  @var{x} has type @code{REAL_VALUE_TYPE},\n-and so does the value.\n-\n-@findex REAL_VALUE_UNSIGNED_RNDZINT\n-@item REAL_VALUE_UNSIGNED_RNDZINT (@var{x})\n-A macro whose definition is a C expression to round the target-machine\n-floating point value @var{x} towards zero to an unsigned integer value\n-(but still represented as a floating point number).  @var{x} has type\n-@code{REAL_VALUE_TYPE}, and so does the value.\n-\n-@findex REAL_VALUE_ATOF\n-@item REAL_VALUE_ATOF (@var{string}, @var{mode})\n-A macro for a C expression which converts @var{string}, an expression of\n-type @code{char *}, into a floating point number in the target machine's\n-representation for mode @var{mode}.  The value has type\n-@code{REAL_VALUE_TYPE}.\n-\n-@findex REAL_INFINITY\n-@item REAL_INFINITY\n-Define this macro if infinity is a possible floating point value, and\n-therefore division by 0 is legitimate.\n-\n-@findex REAL_VALUE_ISINF\n-@findex isinf\n-@item REAL_VALUE_ISINF (@var{x})\n-A macro for a C expression which determines whether @var{x}, a floating\n-point value, is infinity.  The value has type @code{int}.\n-By default, this is defined to call @code{isinf}.\n-\n-@findex REAL_VALUE_ISNAN\n-@findex isnan\n-@item REAL_VALUE_ISNAN (@var{x})\n-A macro for a C expression which determines whether @var{x}, a floating\n-point value, is a ``nan'' (not-a-number).  The value has type\n-@code{int}.  By default, this is defined to call @code{isnan}.\n-\n-@findex REAL_ARITHMETIC\n-@item REAL_ARITHMETIC (@var{output}, @var{code}, @var{x}, @var{y})\n-A macro for a C statement which calculates an arithmetic operation of\n-the two floating point values @var{x} and @var{y}, both of type\n-@code{REAL_VALUE_TYPE} in the target machine's representation, to\n-produce a result of the same type and representation which is stored\n-in @var{output} (which will be a variable).\n-\n-The operation to be performed is specified by @var{code}, a tree code\n-which will always be one of the following: @code{PLUS_EXPR},\n-@code{MINUS_EXPR}, @code{MULT_EXPR}, @code{RDIV_EXPR},\n-@code{MAX_EXPR}, @code{MIN_EXPR}.\n-\n-@cindex overflow while constant folding\n-If overflow happens, the macro expansion executes the statement\n-@code{return 0;}, which indicates the inability to perform the\n-arithmetic operation requested.\n-\n-@findex REAL_VALUE_NEGATE\n-@item REAL_VALUE_NEGATE (@var{x})\n-A macro for a C expression which returns the negative of the floating\n-point value @var{x}.  Both @var{x} and the value of the expression\n-have type @code{REAL_VALUE_TYPE} and are in the target machine's\n-floating point representation.\n-\n-There is no way for this macro to report overflow, since overflow\n-can't happen in the negation operation.\n-\n-@findex REAL_VALUE_TRUNCATE\n-@item REAL_VALUE_TRUNCATE (@var{mode}, @var{x})\n-A macro for a C expression which converts the floating point value\n-@var{x} to mode @var{mode}.\n-\n-Both @var{x} and the value of the expression are in the target machine's\n-floating point representation and have type @code{REAL_VALUE_TYPE}.\n-However, the value should have an appropriate bit pattern to be output\n-properly as a floating constant whose precision accords with mode\n-@var{mode}.\n+@deftypefn Macro REAL_VALUE_TYPE REAL_VALUE_LDEXP (REAL_VALUE_TYPE @var{x}, int @var{scale})\n+Multiplies @var{x} by 2 raised to the power @var{scale}.\n+@end deftypefn\n+\n+@deftypefn Macro HOST_WIDE_INT REAL_VALUE_FIX (REAL_VALUE_TYPE @var{x})\n+Truncates @var{x} to a signed integer, rounding toward zero.\n+@end deftypefn\n+\n+@deftypefn Macro {unsigned HOST_WIDE_INT} REAL_VALUE_UNSIGNED_FIX (REAL_VALUE_TYPE @var{x})\n+Truncates @var{x} to an unsigned integer, rounding toward zero.  If\n+@var{x} is negative, returns zero.\n+@end deftypefn\n+\n+@deftypefn Macro REAL_VALUE_TYPE REAL_VALUE_RNDZINT (REAL_VALUE_TYPE @var{x})\n+Rounds the target-machine floating point value @var{x} towards zero to an\n+integer value, but leaves it represented as a floating point number.\n+@end deftypefn\n \n-There is no way for this macro to report overflow.\n+@deftypefn Macro REAL_VALUE_TYPE REAL_VALUE_UNSIGNED_RNDZINT (REAL_VALUE_TYPE @var{x})\n+Rounds the target-machine floating point value @var{x} towards zero to an\n+unsigned integer value, but leaves it represented as a floating point\n+number.  If @var{x} is negative, returns (positive) zero.\n+@end deftypefn\n \n-@findex REAL_VALUE_TO_INT\n-@item REAL_VALUE_TO_INT (@var{low}, @var{high}, @var{x})\n-A macro for a C expression which converts a floating point value\n-@var{x} into a double-precision integer which is then stored into\n-@var{low} and @var{high}, two variables of type @var{int}.\n+@deftypefn Macro REAL_VALUE_TYPE REAL_VALUE_ATOF (const char *@var{string}, enum machine_mode @var{mode})\n+Converts @var{string} into a floating point number in the target machine's\n+representation for mode @var{mode}.  This routine can handle both\n+decimal and hexadecimal floating point constants, using the syntax\n+defined by the C language for both.\n+@end deftypefn\n \n-@item REAL_VALUE_FROM_INT (@var{x}, @var{low}, @var{high}, @var{mode})\n+@deftypefn Macro int REAL_VALUE_ISINF (REAL_VALUE_TYPE @var{x})\n+Determines whether @var{x} represents infinity (positive or negative).\n+@end deftypefn\n+\n+@deftypefn Macro int REAL_VALUE_ISNAN (REAL_VALUE_TYPE @var{x})\n+Determines whether @var{x} represents a ``NaN'' (not-a-number).\n+@end deftypefn\n+\n+@deftypefn Macro void REAL_ARITHMETIC (REAL_VALUE_TYPE @var{output}, enum tree_code @var{code}, REAL_VALUE_TYPE @var{x}, REAL_VALUE_TYPE @var{y})\n+Calculates an arithmetic operation on the two floating point values\n+@var{x} and @var{y}, storing the result in @var{output} (which must be a\n+variable).\n+\n+The operation to be performed is specified by @var{code}.  Only the\n+following codes are supported: @code{PLUS_EXPR}, @code{MINUS_EXPR},\n+@code{MULT_EXPR}, @code{RDIV_EXPR}, @code{MAX_EXPR}, @code{MIN_EXPR}.\n+\n+If @code{REAL_ARITHMETIC} is asked to evaluate division by zero and the\n+target's floating point format cannot represent infinity, it will call\n+@code{abort}.  Callers should check for this situation first, using\n+@code{MODE_HAS_INFINITIES}.  @xref{Storage Layout}.\n+@end deftypefn\n+\n+@deftypefn Macro REAL_VALUE_TYPE REAL_VALUE_NEGATE (REAL_VALUE_TYPE @var{x})\n+Returns the negative of the floating point value @var{x}.\n+@end deftypefn\n+\n+@deftypefn Macro REAL_VALUE_TYPE REAL_VALUE_TRUNCATE (REAL_VALUE_TYPE @var{mode}, enum machine_mode @var{x})\n+Truncates the floating point value @var{x} to fit in @var{mode}.  The\n+return value is still a full-size @code{REAL_VALUE_TYPE}, but it has an\n+appropriate bit pattern to be output asa floating constant whose\n+precision accords with mode @var{mode}.\n+@end deftypefn\n+\n+@deftypefn Macro void REAL_VALUE_TO_INT (HOST_WIDE_INT @var{low}, HOST_WIDE_INT @var{high}, REAL_VALUE_TYPE @var{x})\n+Converts a floating point value @var{x} into a double-precision integer\n+which is then stored into @var{low} and @var{high}.  If the value is not\n+integral, it is truncated.\n+@end deftypefn\n+\n+@deftypefn Macro void REAL_VALUE_FROM_INT (REAL_VALUE_TYPE @var{x}, HOST_WIDE_INT @var{low}, HOST_WIDE_INT @var{high}, enum machine_mode @var{mode})\n @findex REAL_VALUE_FROM_INT\n-A macro for a C expression which converts a double-precision integer\n-found in @var{low} and @var{high}, two variables of type @var{int},\n-into a floating point value which is then stored into @var{x}.\n-The value is in the target machine's representation for mode @var{mode}\n-and has the type @code{REAL_VALUE_TYPE}.\n-@end table\n+Converts a double-precision integer found in @var{low} and @var{high},\n+into a floating point value which is then stored into @var{x}.  The\n+value is truncated to fit in mode @var{mode}.\n+@end deftypefn\n \n @node Mode Switching\n @section Mode Switching Instructions"}, {"sha": "7f1e92b5f4d7e2c1d7a04d7bb97d21db71e711c4", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -4920,23 +4920,17 @@ init_emit_once (line_numbers)\n \n   for (i = 0; i <= 2; i++)\n     {\n+      REAL_VALUE_TYPE *r =\n+\t(i == 0 ? &dconst0 : i == 1 ? &dconst1 : &dconst2);\n+\n       for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n \t   mode = GET_MODE_WIDER_MODE (mode))\n \t{\n \t  rtx tem = rtx_alloc (CONST_DOUBLE);\n-\t  union real_extract u;\n-\n-\t  /* Zero any holes in a structure.  */\n-\t  memset ((char *) &u, 0, sizeof u);\n-\t  u.d = i == 0 ? dconst0 : i == 1 ? dconst1 : dconst2;\n-\n-\t  /* Avoid trailing garbage in the rtx.  */\n-\t  if (sizeof (u) < sizeof (HOST_WIDE_INT))\n-\t    CONST_DOUBLE_LOW (tem) = 0;\n-\t  if (sizeof (u) < 2 * sizeof (HOST_WIDE_INT))\n-\t    CONST_DOUBLE_HIGH (tem) = 0;\n-\n-\t  memcpy (&CONST_DOUBLE_LOW (tem), &u, sizeof u);\n+ \n+\t  /* Can't use CONST_DOUBLE_FROM_REAL_VALUE here; that uses the\n+\t     tables we're setting up right now.  */\n+\t  memcpy (&CONST_DOUBLE_LOW (tem), r, sizeof (REAL_VALUE_TYPE));\n \t  CONST_DOUBLE_CHAIN (tem) = NULL_RTX;\n \t  PUT_MODE (tem, mode);\n "}, {"sha": "b89b7804cd7604a94091978867a28ba297dba487", "filename": "gcc/fold-const.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -5379,11 +5379,12 @@ fold (expr)\n       goto binary;\n \n     case RDIV_EXPR:\n-      /* In most cases, do nothing with a divide by zero.  */\n-#ifndef REAL_INFINITY\n-      if (TREE_CODE (arg1) == REAL_CST && real_zerop (arg1))\n+      /* Don't touch a floating-point divide by zero unless the mode\n+\t of the constant can represent infinity.  */\n+      if (TREE_CODE (arg1) == REAL_CST\n+\t  && !MODE_HAS_INFINITIES (TYPE_MODE (TREE_TYPE (arg1)))\n+\t  && real_zerop (arg1))\n \treturn t;\n-#endif\n \n       /* (-A) / (-B) -> A / B  */\n       if (TREE_CODE (arg0) == NEGATE_EXPR && TREE_CODE (arg1) == NEGATE_EXPR)"}, {"sha": "cab925665c2d4e774d6c215b5243b1dbc36f3f7e", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 4, "deletions": 26, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -1067,33 +1067,11 @@ __floatdidf (DWtype u)\n #define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)\n #define DI_SIZE (sizeof (DWtype) * BITS_PER_UNIT)\n \n-/* Define codes for all the float formats that we know of.  Note\n-   that this is copied from real.h.  */\n+/* GCC guarantees this header exists at this point.  */\n+#include <float.h>\n \n-#define UNKNOWN_FLOAT_FORMAT 0\n-#define IEEE_FLOAT_FORMAT 1\n-#define VAX_FLOAT_FORMAT 2\n-#define IBM_FLOAT_FORMAT 3\n-\n-/* Default to IEEE float if not specified.  Nearly all machines use it.  */\n-#ifndef HOST_FLOAT_FORMAT\n-#define\tHOST_FLOAT_FORMAT\tIEEE_FLOAT_FORMAT\n-#endif\n-\n-#if HOST_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-#define DF_SIZE 53\n-#define SF_SIZE 24\n-#endif\n-\n-#if HOST_FLOAT_FORMAT == IBM_FLOAT_FORMAT\n-#define DF_SIZE 56\n-#define SF_SIZE 24\n-#endif\n-\n-#if HOST_FLOAT_FORMAT == VAX_FLOAT_FORMAT\n-#define DF_SIZE 56\n-#define SF_SIZE 24\n-#endif\n+#define DF_SIZE DBL_MANT_DIG\n+#define SF_SIZE FLT_MANT_DIG\n \n SFtype\n __floatdisf (DWtype u)"}, {"sha": "496613bf949ae2ad5b50879a7d6a43357bf6b658", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -502,13 +502,19 @@ print_rtx (in_rtx)\n       fputc (']', outfile);\n       break;\n \n-#if HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT && MAX_LONG_DOUBLE_TYPE_SIZE == 64\n+#if 0\n+    /* It would be nice to do this, but it would require real.o to\n+       be linked into the MD-generator programs.  Maybe we should\n+       do that.  -zw 2002-03-03  */\n     case CONST_DOUBLE:\n       if (FLOAT_MODE_P (GET_MODE (in_rtx)))\n \t{\n-\t  double val;\n+\t  REAL_VALUE_TYPE val;\n+\t  char s[30];\n+\n \t  REAL_VALUE_FROM_CONST_DOUBLE (val, in_rtx);\n-\t  fprintf (outfile, \" [%.16g]\", val);\n+\t  REAL_VALUE_TO_DECIMAL (val, \"%.16g\", s);\n+\t  fprintf (outfile, \" [%s]\", s);\n \t}\n       break;\n #endif"}, {"sha": "8674ee897d9a1cc479aa23f9b63bd9ecbbc71faa", "filename": "gcc/real.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -607,16 +607,9 @@ earith (value, icode, r1, r2)\n       break;\n \n     case RDIV_EXPR:\n-#ifndef REAL_INFINITY\n+#ifndef INFINITY\n       if (ecmp (d2, ezero) == 0)\n-\t{\n-#ifdef NANS\n-\tenan (v, eisneg (d1) ^ eisneg (d2));\n-\tbreak;\n-#else\n \tabort ();\n-#endif\n-\t}\n #endif\n       ediv (d2, d1, v);\t/* d1/d2 */\n       break;"}, {"sha": "d3cf780ef33a6e8beb8bd99addd7c5cc62823d4d", "filename": "gcc/real.h", "status": "modified", "additions": 9, "deletions": 52, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -43,10 +43,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define INTEL_EXTENDED_IEEE_FORMAT 0\n #endif\n \n-#if TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-#define REAL_INFINITY\n-#endif\n-\n /* If FLOAT_WORDS_BIG_ENDIAN and HOST_FLOAT_WORDS_BIG_ENDIAN are not defined\n    in the header files, then this implies the word-endianness is the same as\n    for integers.  */\n@@ -79,43 +75,15 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* **** Start of software floating point emulator interface macros **** */\n \n-/* Support 80-bit extended real XFmode if LONG_DOUBLE_TYPE_SIZE\n-   has been defined to be 96 in the tm.h machine file.  */\n-#if (MAX_LONG_DOUBLE_TYPE_SIZE == 96)\n-#define REAL_IS_NOT_DOUBLE\n-typedef struct {\n-  HOST_WIDE_INT r[(11 + sizeof (HOST_WIDE_INT))/(sizeof (HOST_WIDE_INT))];\n-} realvaluetype;\n-#define REAL_VALUE_TYPE realvaluetype\n-\n-#else /* no XFmode support */\n-\n-#if (MAX_LONG_DOUBLE_TYPE_SIZE == 128)\n-\n-#define REAL_IS_NOT_DOUBLE\n-typedef struct {\n-  HOST_WIDE_INT r[(19 + sizeof (HOST_WIDE_INT))/(sizeof (HOST_WIDE_INT))];\n-} realvaluetype;\n-#define REAL_VALUE_TYPE realvaluetype\n-\n-#else /* not TFmode */\n-\n-#if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n-/* If no XFmode support, then a REAL_VALUE_TYPE is 64 bits wide\n-   but it is not necessarily a host machine double.  */\n-#define REAL_IS_NOT_DOUBLE\n+/* REAL_VALUE_TYPE is an array of the minimum number of HOST_WIDE_INTs\n+   required to hold MAX_LONG_DOUBLE_TYPE_SIZE bits.  */\n+#define N (MAX_LONG_DOUBLE_TYPE_SIZE / BITS_PER_UNIT)\n+#define S sizeof (HOST_WIDE_INT)\n typedef struct {\n-  HOST_WIDE_INT r[(7 + sizeof (HOST_WIDE_INT))/(sizeof (HOST_WIDE_INT))];\n-} realvaluetype;\n-#define REAL_VALUE_TYPE realvaluetype\n-#else\n-/* If host and target formats are compatible, then a REAL_VALUE_TYPE\n-   is actually a host machine double.  */\n-#define REAL_VALUE_TYPE double\n-#endif\n-\n-#endif /* no TFmode support */\n-#endif /* no XFmode support */\n+  HOST_WIDE_INT r[N/S + (N%S ? 1 : 0)]; /* round up */\n+} REAL_VALUE_TYPE;\n+#undef N\n+#undef S\n \n extern unsigned int significand_size\tPARAMS ((enum machine_mode));\n \n@@ -246,15 +214,6 @@ extern REAL_VALUE_TYPE dconst1;\n extern REAL_VALUE_TYPE dconst2;\n extern REAL_VALUE_TYPE dconstm1;\n \n-/* Union type used for extracting real values from CONST_DOUBLEs\n-   or putting them in.  */\n-\n-union real_extract \n-{\n-  REAL_VALUE_TYPE d;\n-  HOST_WIDE_INT i[sizeof (REAL_VALUE_TYPE) / sizeof (HOST_WIDE_INT)];\n-};\n-\n /* Given a CONST_DOUBLE in FROM, store into TO the value it represents.  */\n /* Function to return a real value (not a tree node)\n    from a given integer constant.  */\n@@ -263,9 +222,7 @@ REAL_VALUE_TYPE real_value_from_int_cst\tPARAMS ((union tree_node *,\n \t\t\t\t\t\tunion tree_node *));\n \n #define REAL_VALUE_FROM_CONST_DOUBLE(to, from)\t\t\\\n-do { union real_extract u;\t\t\t\t\\\n-     memcpy (&u, &CONST_DOUBLE_LOW ((from)), sizeof u); \\\n-     to = u.d; } while (0)\n+  memcpy (&(to), &CONST_DOUBLE_LOW ((from)), sizeof (REAL_VALUE_TYPE))\n \n /* Return a CONST_DOUBLE with value R and mode M.  */\n "}, {"sha": "53f8293078e92a24019044f4f33cdc751cab6a1c", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -763,13 +763,13 @@ simplify_binary_real (p)\n   f0 = real_value_truncate (args->mode, f0);\n   f1 = real_value_truncate (args->mode, f1);\n \n-#ifndef REAL_INFINITY\n-  if (args->code == DIV && REAL_VALUES_EQUAL (f1, dconst0))\n+  if (args->code == DIV\n+      && !MODE_HAS_INFINITIES (args->mode)\n+      && REAL_VALUES_EQUAL (f1, dconst0))\n     {\n       args->result = 0;\n       return;\n     }\n-#endif\n   REAL_ARITHMETIC (value, rtx_to_tree_code (args->code), f0, f1);\n \n   value = real_value_truncate (args->mode, value);"}, {"sha": "ef9e87242cd4428e5241b45d9a30056c2ecdbfd7", "filename": "gcc/varasm.c", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b216cd4ae3bd06a171b0b2db41d79d4b6f818008/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=b216cd4ae3bd06a171b0b2db41d79d4b6f818008", "patch": "@@ -2215,14 +2215,8 @@ immed_real_const_1 (d, mode)\n      REAL_VALUE_TYPE d;\n      enum machine_mode mode;\n {\n-  union real_extract u;\n   rtx r;\n \n-  /* Get the desired `double' value as a sequence of ints\n-     since that is how they are stored in a CONST_DOUBLE.  */\n-\n-  u.d = d;\n-\n   /* Detect special cases.  Check for NaN first, because some ports\n      (specifically the i386) do not emit correct ieee-fp code by default, and\n      thus will generate a core dump here if we pass a NaN to REAL_VALUES_EQUAL\n@@ -2234,10 +2228,10 @@ immed_real_const_1 (d, mode)\n   else if (! REAL_VALUE_ISNAN (d) && REAL_VALUES_EQUAL (dconst2, d))\n     return CONST2_RTX (mode);\n \n-  if (sizeof u == sizeof (HOST_WIDE_INT))\n-    return immed_double_const (u.i[0], 0, mode);\n-  if (sizeof u == 2 * sizeof (HOST_WIDE_INT))\n-    return immed_double_const (u.i[0], u.i[1], mode);\n+  if (sizeof (REAL_VALUE_TYPE) == sizeof (HOST_WIDE_INT))\n+    return immed_double_const (d.r[0], 0, mode);\n+  if (sizeof (REAL_VALUE_TYPE) == 2 * sizeof (HOST_WIDE_INT))\n+    return immed_double_const (d.r[0], d.r[1], mode);\n \n   /* The rest of this function handles the case where\n      a float value requires more than 2 ints of space.\n@@ -2247,7 +2241,7 @@ immed_real_const_1 (d, mode)\n      If one is found, return it.  */\n   if (cfun != 0)\n     for (r = const_double_chain; r; r = CONST_DOUBLE_CHAIN (r))\n-      if (! memcmp ((char *) &CONST_DOUBLE_LOW (r), (char *) &u, sizeof u)\n+      if (! memcmp ((char *) &CONST_DOUBLE_LOW (r), (char *) &d, sizeof d)\n \t  && GET_MODE (r) == mode)\n \treturn r;\n \n@@ -2259,7 +2253,7 @@ immed_real_const_1 (d, mode)\n      freed memory.  */\n   r = rtx_alloc (CONST_DOUBLE);\n   PUT_MODE (r, mode);\n-  memcpy ((char *) &CONST_DOUBLE_LOW (r), (char *) &u, sizeof u);\n+  memcpy ((char *) &CONST_DOUBLE_LOW (r), (char *) &d, sizeof d);\n \n   /* If we aren't inside a function, don't put r on the\n      const_double_chain.  */\n@@ -2383,7 +2377,7 @@ struct rtx_const\n   ENUM_BITFIELD(kind) kind : 16;\n   ENUM_BITFIELD(machine_mode) mode : 16;\n   union {\n-    union real_extract du;\n+    REAL_VALUE_TYPE du;\n     struct addr_const addr;\n     struct {HOST_WIDE_INT high, low;} di;\n \n@@ -3571,8 +3565,7 @@ decode_rtx_const (mode, x, value)\n       if (GET_MODE (x) != VOIDmode)\n \t{\n \t  value->mode = GET_MODE (x);\n-\t  memcpy ((char *) &value->un.du,\n-\t\t  (char *) &CONST_DOUBLE_LOW (x), sizeof value->un.du);\n+\t  REAL_VALUE_FROM_CONST_DOUBLE (value->un.du, x);\n \t}\n       else\n \t{\n@@ -3962,7 +3955,7 @@ output_constant_pool (fnname, fndecl)\n {\n   struct pool_constant *pool;\n   rtx x;\n-  union real_extract u;\n+  REAL_VALUE_TYPE r;\n \n   /* It is possible for gcc to call force_const_mem and then to later\n      discard the instructions which refer to the constant.  In such a\n@@ -4040,8 +4033,8 @@ output_constant_pool (fnname, fndecl)\n \t  if (GET_CODE (x) != CONST_DOUBLE)\n \t    abort ();\n \n-\t  memcpy ((char *) &u, (char *) &CONST_DOUBLE_LOW (x), sizeof u);\n-\t  assemble_real (u.d, pool->mode, pool->align);\n+\t  REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+\t  assemble_real (r, pool->mode, pool->align);\n \t  break;\n \n \tcase MODE_INT:\n@@ -4062,10 +4055,8 @@ output_constant_pool (fnname, fndecl)\n \t    for (i = 0; i < units; i++)\n \t      {\n \t\telt = CONST_VECTOR_ELT (x, i);\n-\t\tmemcpy ((char *) &u,\n-\t\t\t(char *) &CONST_DOUBLE_LOW (elt),\n-\t\t\tsizeof u);\n-\t\tassemble_real (u.d, GET_MODE_INNER (pool->mode), pool->align);\n+\t\tREAL_VALUE_FROM_CONST_DOUBLE (r, elt);\n+\t\tassemble_real (r, GET_MODE_INNER (pool->mode), pool->align);\n \t      }\n \t  }\n \t  break;"}]}