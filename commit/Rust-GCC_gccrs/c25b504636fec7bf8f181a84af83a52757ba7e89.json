{"sha": "c25b504636fec7bf8f181a84af83a52757ba7e89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI1YjUwNDYzNmZlYzdiZjhmMTgxYTg0YWY4M2E1Mjc1N2JhN2U4OQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-12-17T14:24:11Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-12-17T14:38:31Z"}, "message": "Fix trap in pointer conversion in op1_range.\n\nProcessing op1_range for conversion between a non-pointer and pointer\nshouldnt do any fancy math.\n\n\tgcc/\n\tPR tree-optimization/97750\n\t* range-op.cc (operator_cast::op1_range): Handle pointers better.\n\tgcc/testsuite/\n\t* gcc.dg/pr97750.c: New.", "tree": {"sha": "90aad777bbcc9ba96b68e7cd67db802a9bc30f7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90aad777bbcc9ba96b68e7cd67db802a9bc30f7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c25b504636fec7bf8f181a84af83a52757ba7e89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c25b504636fec7bf8f181a84af83a52757ba7e89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c25b504636fec7bf8f181a84af83a52757ba7e89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c25b504636fec7bf8f181a84af83a52757ba7e89/comments", "author": null, "committer": null, "parents": [{"sha": "d592ee3ada825fe8c022e1d5fa30562b17fc3221", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d592ee3ada825fe8c022e1d5fa30562b17fc3221", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d592ee3ada825fe8c022e1d5fa30562b17fc3221"}], "stats": {"total": 46, "additions": 46, "deletions": 0}, "files": [{"sha": "a473f33169def6b11e99584de7bebe16108ab4a9", "filename": "gcc/range-op.cc", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c25b504636fec7bf8f181a84af83a52757ba7e89/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c25b504636fec7bf8f181a84af83a52757ba7e89/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=c25b504636fec7bf8f181a84af83a52757ba7e89", "patch": "@@ -1850,6 +1850,31 @@ operator_cast::op1_range (irange &r, tree type,\n   tree lhs_type = lhs.type ();\n   gcc_checking_assert (types_compatible_p (op2.type(), type));\n \n+  // If we are calculating a pointer, shortcut to what we really care about.\n+  if (POINTER_TYPE_P (type))\n+    {\n+      // Conversion from other pointers or a constant (including 0/NULL)\n+      // are straightforward.\n+      if (POINTER_TYPE_P (lhs.type ())\n+\t  || (lhs.singleton_p ()\n+\t      && TYPE_PRECISION (lhs.type ()) >= TYPE_PRECISION (type)))\n+\t{\n+\t  r = lhs;\n+\t  range_cast (r, type);\n+\t}\n+      else\n+\t{\n+\t  // If the LHS is not a pointer nor a singleton, then it is\n+\t  // either VARYING or non-zero.\n+\t  if (!lhs.contains_p (build_zero_cst (lhs.type ())))\n+\t    r.set_nonzero (type);\n+\t  else\n+\t    r.set_varying (type);\n+\t}\n+      r.intersect (op2);\n+      return true;\n+    }\n+\n   if (truncating_cast_p (op2, lhs))\n     {\n       if (lhs.varying_p ())"}, {"sha": "822b53abcff03fb530079f7282f3c155ce513fca", "filename": "gcc/testsuite/gcc.dg/pr97750.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c25b504636fec7bf8f181a84af83a52757ba7e89/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97750.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c25b504636fec7bf8f181a84af83a52757ba7e89/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97750.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97750.c?ref=c25b504636fec7bf8f181a84af83a52757ba7e89", "patch": "@@ -0,0 +1,21 @@\n+/* PR tree-optimization/97750 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wall -Wextra\" } */\n+\n+char CopyPlane_src;\n+long CopyPlane_copy_pitch;\n+char *CopyFromUswc_src;\n+int CopyFromUswc_height;\n+void CopyPlane(char *dst) {\n+  __builtin_memcpy(dst, &CopyPlane_src, CopyPlane_copy_pitch);\n+}\n+void CopyFromUswc(long src_pitch) {\n+  char *dst;\n+  for (; CopyFromUswc_height;) {\n+    unsigned unaligned = (long)CopyFromUswc_src;\n+    if (unaligned)\n+      CopyPlane(&dst[unaligned]);  /* { dg-warning \"may be used uninitialized\" } */\n+    CopyFromUswc_src += src_pitch;\n+  }\n+}\n+"}]}