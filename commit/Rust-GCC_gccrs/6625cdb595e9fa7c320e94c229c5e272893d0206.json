{"sha": "6625cdb595e9fa7c320e94c229c5e272893d0206", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjYyNWNkYjU5NWU5ZmE3YzMyMGU5NGMyMjljNWUyNzI4OTNkMDIwNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@casey.soma.redhat.com", "date": "2000-05-26T21:05:05Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-05-26T21:05:05Z"}, "message": "Fix goto checking.\n\n        * cp-tree.h (struct language_function): x_named_labels is now\n        a struct named_label_list*.\n        * decl.c (struct named_label_use_list): Renamed from...\n        (struct named_label_list): ...this.  New struct.\n        (push_binding_level): Don't set eh_region.\n        (note_level_for_eh): New fn.\n        (pop_label): Take label and old value directly.\n        (pop_labels): Adjust for new named_labels format.\n        (lookup_label): Likewise.\n        (poplevel): Note characteristics of a binding level containing a\n        named label.  Mess with named label lists earlier.\n        (mark_named_label_lists): New fn.\n        (mark_lang_function): Call it.\n        (use_label): New fn, split out from...\n        (make_label_decl): ...here.  Don't call it.\n        (decl_jump_unsafe, check_previous_goto, check_previous_goto_1,\n        check_previous_gotos): New fns, split out from...\n        (define_label): ...here.\n        (check_switch_goto): New fn.\n        (define_case_label): Call it.\n        (check_goto): New fn.\n        * semantics.c (finish_goto_stmt): Call it and use_label.\n        (begin_compound_stmt): If we're a try block, call note_level_for_eh.\n        (expand_stmt): Never pass 1 as DONT_JUMP_IN to expand_end_bindings.\n\nFrom-SVN: r34198", "tree": {"sha": "9959d4042ddd7272bf7d0408e17421eae99253b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9959d4042ddd7272bf7d0408e17421eae99253b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6625cdb595e9fa7c320e94c229c5e272893d0206", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6625cdb595e9fa7c320e94c229c5e272893d0206", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6625cdb595e9fa7c320e94c229c5e272893d0206", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6625cdb595e9fa7c320e94c229c5e272893d0206/comments", "author": null, "committer": null, "parents": [{"sha": "0137be2dcab07fad0774f03e17086de8620dc3c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0137be2dcab07fad0774f03e17086de8620dc3c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0137be2dcab07fad0774f03e17086de8620dc3c5"}], "stats": {"total": 565, "additions": 377, "deletions": 188}, "files": [{"sha": "0b087f88f84a4a31e3b26cd1b263f36b266adb7f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6625cdb595e9fa7c320e94c229c5e272893d0206/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6625cdb595e9fa7c320e94c229c5e272893d0206/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6625cdb595e9fa7c320e94c229c5e272893d0206", "patch": "@@ -1,3 +1,31 @@\n+2000-05-26  Jason Merrill  <jason@casey.soma.redhat.com>\n+\n+\tFix goto checking.\n+\t* cp-tree.h (struct language_function): x_named_labels is now\n+\ta struct named_label_list*.\n+\t* decl.c (struct named_label_use_list): Renamed from...\n+\t(struct named_label_list): ...this.  New struct.\n+\t(push_binding_level): Don't set eh_region.\n+\t(note_level_for_eh): New fn.\n+\t(pop_label): Take label and old value directly.\n+\t(pop_labels): Adjust for new named_labels format.\n+\t(lookup_label): Likewise.\n+\t(poplevel): Note characteristics of a binding level containing a\n+\tnamed label.  Mess with named label lists earlier.\n+\t(mark_named_label_lists): New fn.\n+\t(mark_lang_function): Call it.\n+\t(use_label): New fn, split out from...\n+\t(make_label_decl): ...here.  Don't call it.\n+\t(decl_jump_unsafe, check_previous_goto, check_previous_goto_1, \n+\tcheck_previous_gotos): New fns,\tsplit out from...\n+\t(define_label): ...here.\n+\t(check_switch_goto): New fn.\n+\t(define_case_label): Call it.\n+\t(check_goto): New fn.\n+\t* semantics.c (finish_goto_stmt): Call it and use_label.\n+\t(begin_compound_stmt): If we're a try block, call note_level_for_eh.\n+\t(expand_stmt): Never pass 1 as DONT_JUMP_IN to expand_end_bindings.\n+\n 2000-05-26  Mark Mitchell  <mark@codesourcery.com>\n \n \t* class.c (build_vtable_entry_ref): Correct usage of"}, {"sha": "810d17469017ac2716b1acce8a9a9b38efc00e6d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6625cdb595e9fa7c320e94c229c5e272893d0206/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6625cdb595e9fa7c320e94c229c5e272893d0206/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6625cdb595e9fa7c320e94c229c5e272893d0206", "patch": "@@ -841,7 +841,6 @@ extern struct saved_scope *scope_chain;\n \n struct language_function\n {\n-  tree x_named_labels;\n   tree x_ctor_label;\n   tree x_dtor_label;\n   tree x_base_init_list;\n@@ -867,7 +866,8 @@ struct language_function\n \n   struct stmt_tree x_stmt_tree;\n \n-  struct named_label_list *x_named_label_uses;\n+  struct named_label_use_list *x_named_label_uses;\n+  struct named_label_list *x_named_labels;\n   struct binding_level *bindings;\n \n   const char *cannot_inline;\n@@ -3892,6 +3892,7 @@ extern void set_class_shadows\t\t\tPARAMS ((tree));\n extern void begin_scope                         PARAMS ((scope_kind));\n extern void finish_scope                        PARAMS ((void));\n extern void note_level_for_for\t\t\tPARAMS ((void));\n+extern void note_level_for_eh\t\t\tPARAMS ((void));\n extern void resume_level\t\t\tPARAMS ((struct binding_level *));\n extern void delete_block\t\t\tPARAMS ((tree));\n extern void insert_block\t\t\tPARAMS ((tree));\n@@ -3930,6 +3931,7 @@ extern tree implicitly_declare\t\t\tPARAMS ((tree));\n extern tree lookup_label\t\t\tPARAMS ((tree));\n extern tree declare_local_label                 PARAMS ((tree));\n extern tree define_label\t\t\tPARAMS ((const char *, int, tree));\n+extern void check_goto\t\t\t\tPARAMS ((tree));\n extern void push_switch\t\t\t\tPARAMS ((void));\n extern void pop_switch\t\t\t\tPARAMS ((void));\n extern void define_case_label\t\t\tPARAMS ((void));"}, {"sha": "eecf36da082b49759e884ebe3484c6e31ec05c80", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 332, "deletions": 183, "changes": 515, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6625cdb595e9fa7c320e94c229c5e272893d0206/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6625cdb595e9fa7c320e94c229c5e272893d0206/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6625cdb595e9fa7c320e94c229c5e272893d0206", "patch": "@@ -105,6 +105,7 @@ static void resume_binding_level PARAMS ((struct binding_level *));\n static struct binding_level *make_binding_level PARAMS ((void));\n static void declare_namespace_level PARAMS ((void));\n static void signal_catch PARAMS ((int)) ATTRIBUTE_NORETURN;\n+static int decl_jump_unsafe PARAMS ((tree));\n static void storedecls PARAMS ((tree));\n static void require_complete_types_for_parms PARAMS ((tree));\n static int ambi_op_p PARAMS ((tree));\n@@ -151,7 +152,13 @@ static int walk_namespaces_r PARAMS ((tree, walk_namespaces_fn, void *));\n static int walk_globals_r PARAMS ((tree, void *));\n static void add_decl_to_level PARAMS ((tree, struct binding_level *));\n static tree make_label_decl PARAMS ((tree, int));\n-static void pop_label PARAMS ((tree));\n+static void use_label PARAMS ((tree));\n+static void check_previous_goto_1 PARAMS ((tree, struct binding_level *, tree,\n+\t\t\t\t\t   const char *, int));\n+static void check_previous_goto PARAMS ((struct named_label_use_list *));\n+static void check_switch_goto PARAMS ((struct binding_level *));\n+static void check_previous_gotos PARAMS ((tree));\n+static void pop_label PARAMS ((tree, tree));\n static void pop_labels PARAMS ((tree));\n static void maybe_deduce_size_from_array_init PARAMS ((tree, tree));\n static void layout_var_decl PARAMS ((tree));\n@@ -268,19 +275,19 @@ static int only_namespace_names;\n \n #define original_result_rtx cp_function_chain->x_result_rtx\n \n-struct named_label_list\n+/* Used only for jumps to as-yet undefined labels, since jumps to\n+   defined labels can have their validity checked immediately.  */\n+\n+struct named_label_use_list\n {\n   struct binding_level *binding_level;\n   tree names_in_scope;\n   tree label_decl;\n   const char *filename_o_goto;\n   int lineno_o_goto;\n-  struct named_label_list *next;\n+  struct named_label_use_list *next;\n };\n \n-/* Used only for jumps to as-yet undefined labels, since jumps to\n-   defined labels can have their validity checked by stmt.c.  */\n-\n #define named_label_uses cp_function_chain->x_named_label_uses\n \n /* A list of objects which have constructors or destructors\n@@ -304,10 +311,20 @@ static tree last_function_parm_tags;\n tree last_function_parms;\n static tree current_function_parm_tags;\n \n-/* A list (chain of TREE_LIST nodes) of all LABEL_DECLs in the function\n-   that have names.  Here so we can clear out their names' definitions\n-   at the end of the function.  The TREE_VALUE is a LABEL_DECL; the\n-   TREE_PURPOSE is the previous binding of the label.  */\n+/* A list of all LABEL_DECLs in the function that have names.  Here so\n+   we can clear out their names' definitions at the end of the\n+   function, and so we can check the validity of jumps to these labels.  */\n+\n+struct named_label_list\n+{\n+  struct binding_level *binding_level;\n+  tree names_in_scope;\n+  tree old_value;\n+  tree label_decl;\n+  tree bad_decls;\n+  int eh_region;\n+  struct named_label_list *next;\n+};\n \n #define named_labels cp_function_chain->x_named_labels\n \n@@ -481,7 +498,9 @@ struct binding_level\n        worry about ambiguous (ARM or ISO) scope rules.  */\n     unsigned is_for_scope : 1;\n \n-    /* True if this level corresponds to an EH region, as for a try block.  */\n+    /* True if this level corresponds to an EH region, as for a try block.\n+       Currently this information is only available while building the\n+       tree structure.  */\n     unsigned eh_region : 1;\n \n     /* Four bits left for this word.  */\n@@ -548,11 +567,6 @@ push_binding_level (newlevel, tag_transparent, keep)\n   newlevel->tag_transparent = tag_transparent;\n   newlevel->more_cleanups_ok = 1;\n \n-  /* We are called before expand_start_bindings, but after\n-     expand_eh_region_start for a try block; so we check this now,\n-     before the EH block is covered up.  */\n-  newlevel->eh_region = is_eh_region ();\n-\n   newlevel->keep = keep;\n #if defined(DEBUG_CP_BINDING_LEVELS)\n   newlevel->binding_depth = binding_depth;\n@@ -927,6 +941,14 @@ note_level_for_for ()\n   current_binding_level->is_for_scope = 1;\n }\n \n+/* Record that the current binding level represents a try block.  */\n+\n+void\n+note_level_for_eh ()\n+{\n+  current_binding_level->eh_region = 1;\n+}\n+\n /* For a binding between a name and an entity at a block scope,\n    this is the `struct binding_level' for the block.  */\n #define BINDING_LEVEL(NODE) \\\n@@ -1180,11 +1202,10 @@ pop_binding (id, decl)\n    in a valid manner, and issue any appropriate warnings or errors.  */\n \n static void\n-pop_label (link)\n-     tree link;\n+pop_label (label, old_value)\n+     tree label;\n+     tree old_value;\n {\n-  tree label = TREE_VALUE (link);\n-\n   if (!processing_template_decl && doing_semantic_analysis_p ())\n     {\n       if (DECL_INITIAL (label) == NULL_TREE)\n@@ -1197,7 +1218,7 @@ pop_label (link)\n \tcp_warning_at (\"label `%D' defined but not used\", label);\n     }\n \n-  SET_IDENTIFIER_LABEL_VALUE (DECL_NAME (label), TREE_PURPOSE (link));\n+  SET_IDENTIFIER_LABEL_VALUE (DECL_NAME (label), old_value);\n }\n \n /* At the end of a function, all labels declared within the fucntion\n@@ -1208,20 +1229,20 @@ static void\n pop_labels (block)\n      tree block;\n {\n-  tree link;\n+  struct named_label_list *link;\n \n   /* Clear out the definitions of all label names, since their scopes\n      end here.  */\n-  for (link = named_labels; link; link = TREE_CHAIN (link))\n+  for (link = named_labels; link; link = link->next)\n     {\n-      pop_label (link);\n+      pop_label (link->label_decl, link->old_value);\n       /* Put the labels into the \"variables\" of the top-level block,\n \t so debugger can see them.  */\n-      TREE_CHAIN (TREE_VALUE (link)) = BLOCK_VARS (block);\n-      BLOCK_VARS (block) = TREE_VALUE (link);\n+      TREE_CHAIN (link->label_decl) = BLOCK_VARS (block);\n+      BLOCK_VARS (block) = link->label_decl;\n     }\n \n-  named_labels = NULL_TREE;\n+  named_labels = NULL;\n }\n \n /* Exit a binding level.\n@@ -1285,6 +1306,40 @@ poplevel (keep, reverse, functionbody)\n   if (current_binding_level->keep == 1)\n     keep = 1;\n \n+  /* Any uses of undefined labels, and any defined labels, now operate\n+     under constraints of next binding contour.  */\n+  if (cfun && !functionbody)\n+    {\n+      struct binding_level *level_chain;\n+      level_chain = current_binding_level->level_chain;\n+      if (level_chain)\n+\t{\n+\t  struct named_label_use_list *uses;\n+\t  struct named_label_list *labels;\n+\t  for (labels = named_labels; labels; labels = labels->next)\n+\t    if (labels->binding_level == current_binding_level)\n+\t      {\n+\t\ttree decl;\n+\t\tif (current_binding_level->eh_region)\n+\t\t  labels->eh_region = 1;\n+\t\tfor (decl = labels->names_in_scope; decl;\n+\t\t     decl = TREE_CHAIN (decl))\n+\t\t  if (decl_jump_unsafe (decl))\n+\t\t    labels->bad_decls = tree_cons (NULL_TREE, decl,\n+\t\t\t\t\t\t   labels->bad_decls);\n+\t\tlabels->binding_level = level_chain;\n+\t\tlabels->names_in_scope = level_chain->names;\n+\t      }\n+\n+\t  for (uses = named_label_uses; uses; uses = uses->next)\n+\t    if (uses->binding_level == current_binding_level)\n+\t      {\n+\t\tuses->binding_level = level_chain;\n+\t\tuses->names_in_scope = level_chain->names;\n+\t      }\n+\t}\n+    }\n+\n   /* Get the decls in the order they were written.\n      Usually current_binding_level->names is in reverse order.\n      But parameter decls were previously put in forward order.  */\n@@ -1468,7 +1523,7 @@ poplevel (keep, reverse, functionbody)\n   for (link = current_binding_level->shadowed_labels;\n        link;\n        link = TREE_CHAIN (link))\n-    pop_label (link);\n+    pop_label (TREE_VALUE (link), TREE_PURPOSE (link));\n \n   /* There may be OVERLOADs (wrapped in TREE_LISTs) on the BLOCK_VARs\n      list if a `using' declaration put them there.  The debugging\n@@ -1500,24 +1555,6 @@ poplevel (keep, reverse, functionbody)\n       pop_labels (block);\n     }\n \n-  /* Any uses of undefined labels now operate under constraints\n-     of next binding contour.  */\n-  if (cfun)\n-    {\n-      struct binding_level *level_chain;\n-      level_chain = current_binding_level->level_chain;\n-      if (level_chain)\n-\t{\n-\t  struct named_label_list *labels;\n-\t  for (labels = named_label_uses; labels; labels = labels->next)\n-\t    if (labels->binding_level == current_binding_level)\n-\t      {\n-\t\tlabels->binding_level = level_chain;\n-\t\tlabels->names_in_scope = level_chain->names;\n-\t      }\n-\t}\n-    }\n-\n   tmp = current_binding_level->keep;\n \n   pop_binding_level ();\n@@ -1951,7 +1988,7 @@ mark_binding_level (arg)\n {\n   struct binding_level *lvl = *(struct binding_level **)arg;\n \n-  while (lvl)\n+  for (; lvl; lvl = lvl->level_chain)\n     {\n       ggc_mark_tree (lvl->names);\n       ggc_mark_tree (lvl->tags);\n@@ -1965,9 +2002,28 @@ mark_binding_level (arg)\n       ggc_mark_tree (lvl->this_class);\n       ggc_mark_tree (lvl->incomplete);\n       ggc_mark_tree (lvl->dead_vars_from_for);\n+    }\n+}\n+\n+static void\n+mark_named_label_lists (labs, uses)\n+     void *labs;\n+     void *uses;\n+{\n+  struct named_label_list *l = *(struct named_label_list **)labs;\n+  struct named_label_use_list *u = *(struct named_label_use_list **)uses;\n \n-      lvl = lvl->level_chain;\n+  for (; l; l = l->next)\n+    {\n+      ggc_mark (l);\n+      mark_binding_level (l->binding_level);\n+      ggc_mark_tree (l->old_value);\n+      ggc_mark_tree (l->label_decl);\n+      ggc_mark_tree (l->bad_decls);\n     }\n+\n+  for (; u; u = u->next)\n+    ggc_mark (u);\n }\n \f\n /* For debugging.  */\n@@ -4708,17 +4764,25 @@ make_label_decl (id, local_p)\n   /* Record the fact that this identifier is bound to this label.  */\n   SET_IDENTIFIER_LABEL_VALUE (id, decl);\n \n-  /* Record this label on the list of used labels so that we can check\n-     at the end of the function to see whether or not the label was\n-     actually defined.  */\n-  if ((named_label_uses == NULL || named_label_uses->label_decl != decl)\n-      && (named_label_uses == NULL\n-\t  || named_label_uses->names_in_scope != current_binding_level->names\n-\t  || named_label_uses->label_decl != decl))\n-    {\n-      struct named_label_list *new_ent;\n-      new_ent\n-\t= (struct named_label_list*)oballoc (sizeof (struct named_label_list));\n+  return decl;\n+}\n+\n+/* Record this label on the list of used labels so that we can check\n+   at the end of the function to see whether or not the label was\n+   actually defined, and so we can check when the label is defined whether\n+   this use is valid.  */\n+\n+static void\n+use_label (decl)\n+     tree decl;\n+{\n+  if (named_label_uses == NULL\n+      || named_label_uses->names_in_scope != current_binding_level->names\n+      || named_label_uses->label_decl != decl)\n+    {\n+      struct named_label_use_list *new_ent;\n+      new_ent = ((struct named_label_use_list *)\n+\t\t ggc_alloc (sizeof (struct named_label_use_list)));\n       new_ent->label_decl = decl;\n       new_ent->names_in_scope = current_binding_level->names;\n       new_ent->binding_level = current_binding_level;\n@@ -4727,8 +4791,6 @@ make_label_decl (id, local_p)\n       new_ent->next = named_label_uses;\n       named_label_uses = new_ent;\n     }\n-\n-  return decl;\n }\n \n /* Look for a label named ID in the current function.  If one cannot\n@@ -4740,6 +4802,7 @@ lookup_label (id)\n      tree id;\n {\n   tree decl;\n+  struct named_label_list *ent;\n \n   /* You can't use labels at global scope.  */\n   if (current_function_decl == NULL_TREE)\n@@ -4757,12 +4820,17 @@ lookup_label (id)\n   /* Record this label on the list of labels used in this function.\n      We do this before calling make_label_decl so that we get the\n      IDENTIFIER_LABEL_VALUE before the new label is declared.  */\n-  named_labels = tree_cons (IDENTIFIER_LABEL_VALUE (id), NULL_TREE,\n-\t\t\t    named_labels);\n+  ent = ((struct named_label_list *)\n+\t ggc_alloc_obj (sizeof (struct named_label_list), 1));\n+  ent->old_value = IDENTIFIER_LABEL_VALUE (id);\n+  ent->next = named_labels;\n+  named_labels = ent;\n+\n   /* We need a new label.  */\n   decl = make_label_decl (id, /*local_p=*/0);\n+\n   /* Now fill in the information we didn't have before.  */\n-  TREE_VALUE (named_labels) = decl;\n+  ent->label_decl = decl;\n \n   return decl;\n }\n@@ -4789,6 +4857,193 @@ declare_local_label (id)\n   return decl;\n }\n \n+/* Returns nonzero if it is ill-formed to jump past the declaration of\n+   DECL.  Returns 2 if it's also a real problem.  */\n+\n+static int\n+decl_jump_unsafe (decl)\n+     tree decl;\n+{\n+  if (TREE_CODE (decl) != VAR_DECL || TREE_STATIC (decl))\n+    return 0;\n+\n+  if (DECL_INITIAL (decl) == NULL_TREE\n+      && pod_type_p (TREE_TYPE (decl)))\n+    return 0;\n+\n+  /* This is really only important if we're crossing an initialization.\n+     The POD stuff is just pedantry; why should it matter if the class\n+     contains a field of pointer to member type?  */\n+  if (DECL_INITIAL (decl)\n+      || (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl))))\n+    return 2;\n+  return 1;\n+}\n+\n+/* Check that a single previously seen jump to a newly defined label\n+   is OK.  DECL is the LABEL_DECL or 0; LEVEL is the binding_level for\n+   the jump context; NAMES are the names in scope in LEVEL at the jump\n+   context; FILE and LINE are the source position of the jump or 0.  */\n+\n+static void\n+check_previous_goto_1 (decl, level, names, file, line)\n+     tree decl;\n+     struct binding_level *level;\n+     tree names;\n+     const char *file;\n+     int line;\n+{\n+  int identified = 0;\n+  int saw_eh = 0;\n+  struct binding_level *b = current_binding_level;\n+  for (; b; b = b->level_chain)\n+    {\n+      tree new_decls = b->names;\n+      tree old_decls = (b == level ? names : NULL_TREE);\n+      for (; new_decls != old_decls;\n+\t   new_decls = TREE_CHAIN (new_decls))\n+\t{\n+\t  int problem = decl_jump_unsafe (new_decls);\n+\t  if (! problem)\n+\t    continue;\n+\n+\t  if (! identified)\n+\t    {\n+\t      if (decl)\n+\t\tcp_pedwarn (\"jump to label `%D'\", decl);\n+\t      else\n+\t\tpedwarn (\"jump to case label\");\n+\n+\t      if (file)\n+\t\tpedwarn_with_file_and_line (file, line, \"  from here\");\n+\t      identified = 1;\n+\t    }\n+\n+\t  if (problem > 1 && DECL_ARTIFICIAL (new_decls))\n+\t    /* Can't skip init of __exception_info.  */\n+\t    cp_error_at (\"  enters catch block\", new_decls);\n+\t  else if (problem > 1)\n+\t    cp_error_at (\"  crosses initialization of `%#D'\",\n+\t\t\t new_decls);\n+\t  else\n+\t    cp_pedwarn_at (\"  enters scope of non-POD `%#D'\",\n+\t\t\t   new_decls);\n+\t}\n+\n+      if (b == level)\n+\tbreak;\n+      if (b->eh_region && ! saw_eh)\n+\t{\n+\t  if (! identified)\n+\t    {\n+\t      if (decl)\n+\t\tcp_pedwarn (\"jump to label `%D'\", decl);\n+\t      else\n+\t\tpedwarn (\"jump to case label\");\n+\n+\t      if (file)\n+\t\tpedwarn_with_file_and_line (file, line, \"  from here\");\n+\t      identified = 1;\n+\t    }\n+\t  error (\"  enters try block\");\n+\t  saw_eh = 1;\n+\t}\n+    }\n+}\n+\n+static void\n+check_previous_goto (use)\n+     struct named_label_use_list *use;\n+{\n+  check_previous_goto_1 (use->label_decl, use->binding_level,\n+\t\t\t use->names_in_scope, use->filename_o_goto,\n+\t\t\t use->lineno_o_goto);\n+}\n+\n+static void\n+check_switch_goto (level)\n+     struct binding_level *level;\n+{\n+  check_previous_goto_1 (NULL_TREE, level, level->names, NULL, 0);\n+}\n+\n+/* Check that any previously seen jumps to a newly defined label DECL\n+   are OK.  Called by define_label.  */\n+\n+static void\n+check_previous_gotos (decl)\n+     tree decl;\n+{\n+  struct named_label_use_list **usep;\n+\n+  if (! TREE_USED (decl))\n+    return;\n+\n+  for (usep = &named_label_uses; *usep; )\n+    {\n+      struct named_label_use_list *use = *usep;\n+      if (use->label_decl == decl)\n+\t{\n+\t  check_previous_goto (use);\n+\t  *usep = use->next;\n+\t}\n+      else\n+\tusep = &(use->next);\n+    }\n+}\n+\n+/* Check that a new jump to a label DECL is OK.  Called by\n+   finish_goto_stmt.  */\n+\n+void\n+check_goto (decl)\n+     tree decl;\n+{\n+  int identified = 0;\n+  tree bad;\n+  struct named_label_list *lab;\n+\n+  /* If the label hasn't been defined yet, defer checking.  */\n+  if (! DECL_INITIAL (decl))\n+    {\n+      use_label (decl);\n+      return;\n+    }\n+\n+  for (lab = named_labels; lab; lab = lab->next)\n+    if (decl == lab->label_decl)\n+      break;\n+\n+  /* If the label is not on named_labels it's a gcc local label, so\n+     it must be in an outer scope, so jumping to it is always OK.  */\n+  if (lab == 0)\n+    return;\n+\n+  if ((lab->eh_region || lab->bad_decls) && !identified)\n+    {\n+      cp_pedwarn_at (\"jump to label `%D'\", decl);\n+      pedwarn (\"  from here\");\n+      identified = 1;\n+    }\n+\n+  for (bad = lab->bad_decls; bad; bad = TREE_CHAIN (bad))\n+    {\n+      tree b = TREE_VALUE (bad);\n+      int u = decl_jump_unsafe (b);\n+\n+      if (u > 1 && DECL_ARTIFICIAL (b))\n+\t/* Can't skip init of __exception_info.  */\n+\tcp_error_at (\"  enters catch block\", b);\n+      else if (u > 1)\n+\tcp_error_at (\"  skips initialization of `%#D'\", b);\n+      else\n+\tcp_pedwarn_at (\"  enters scope of non-POD `%#D'\", b);\n+    }\n+\n+  if (lab->eh_region)\n+    error (\"  enters try block\");\n+}\n+\n /* Define a label, specifying the location in the source file.\n    Return the LABEL_DECL node for the label, if the definition is valid.\n    Otherwise return 0.  */\n@@ -4800,6 +5055,11 @@ define_label (filename, line, name)\n      tree name;\n {\n   tree decl = lookup_label (name);\n+  struct named_label_list *ent;\n+\n+  for (ent = named_labels; ent; ent = ent->next)\n+    if (ent->label_decl == decl)\n+      break;\n \n   /* After labels, make any new cleanups go into their\n      own new (temporary) binding contour.  */\n@@ -4815,104 +5075,17 @@ define_label (filename, line, name)\n     }\n   else\n     {\n-      struct named_label_list *uses, *prev;\n-      int identified = 0;\n-      int saw_eh = 0;\n-\n       /* Mark label as having been defined.  */\n       DECL_INITIAL (decl) = error_mark_node;\n       /* Say where in the source.  */\n       DECL_SOURCE_FILE (decl) = filename;\n       DECL_SOURCE_LINE (decl) = line;\n-\n-      prev = NULL;\n-      uses = named_label_uses;\n-      while (uses != NULL)\n-\tif (uses->label_decl == decl)\n-\t  {\n-\t    struct binding_level *b = current_binding_level;\n-\t    while (b)\n-\t      {\n-\t\ttree new_decls = b->names;\n-\t\ttree old_decls = (b == uses->binding_level)\n-\t\t\t\t  ? uses->names_in_scope : NULL_TREE;\n-\t\twhile (new_decls != old_decls)\n-\t\t  {\n-\t\t    if (TREE_CODE (new_decls) == VAR_DECL\n-\t\t\t/* Don't complain about crossing initialization\n-\t\t\t   of internal entities.  They can't be accessed,\n-\t\t\t   and they should be cleaned up\n-\t\t\t   by the time we get to the label.  */\n-\t\t\t&& ! DECL_ARTIFICIAL (new_decls)\n-\t\t\t&& !(DECL_INITIAL (new_decls) == NULL_TREE\n-\t\t\t     && pod_type_p (TREE_TYPE (new_decls))))\n-\t\t      {\n-\t\t\t/* This is really only important if we're crossing\n-\t\t\t   an initialization.  The POD stuff is just\n-\t\t\t   pedantry; why should it matter if the class\n-\t\t\t   contains a field of pointer to member type?  */\n-\t\t\tint problem = (DECL_INITIAL (new_decls)\n-\t\t\t\t       || (TYPE_NEEDS_CONSTRUCTING\n-\t\t\t\t\t   (TREE_TYPE (new_decls))));\n-\n-\t\t\tif (! identified)\n-\t\t\t  {\n-\t\t\t    if (problem)\n-\t\t\t      {\n-\t\t\t\tcp_error (\"jump to label `%D'\", decl);\n-\t\t\t\terror_with_file_and_line\n-\t\t\t\t  (uses->filename_o_goto,\n-\t\t\t\t   uses->lineno_o_goto, \"  from here\");\n-\t\t\t      }\n-\t\t\t    else\n-\t\t\t      {\n-\t\t\t\tcp_pedwarn (\"jump to label `%D'\", decl);\n-\t\t\t\tpedwarn_with_file_and_line\n-\t\t\t\t  (uses->filename_o_goto,\n-\t\t\t\t   uses->lineno_o_goto, \"  from here\");\n-\t\t\t      }\n-\t\t\t    identified = 1;\n-\t\t\t  }\n-\n-\t\t\tif (problem)\n-\t\t\t  cp_error_at (\"  crosses initialization of `%#D'\",\n-\t\t\t\t       new_decls);\n-\t\t\telse\n-\t\t\t  cp_pedwarn_at (\"  enters scope of non-POD `%#D'\",\n-\t\t\t\t\t new_decls);\n-\t\t      }\n-\t\t    new_decls = TREE_CHAIN (new_decls);\n-\t\t  }\n-\t\tif (b == uses->binding_level)\n-\t\t  break;\n-\t\tif (b->eh_region && ! saw_eh)\n-\t\t  {\n-\t\t    if (! identified)\n-\t\t      {\n-\t\t\tcp_error (\"jump to label `%D'\", decl);\n-\t\t\terror_with_file_and_line\n-\t\t\t  (uses->filename_o_goto,\n-\t\t\t   uses->lineno_o_goto, \"  from here\");\n-\t\t\tidentified = 1;\n-\t\t      }\n-\t\t    error (\"  enters exception handling block\");\n-\t\t    saw_eh = 1;\n-\t\t  }\n-\t\tb = b->level_chain;\n-\t      }\n-\n-\t    if (prev != NULL)\n-\t      prev->next = uses->next;\n-\t    else\n-\t      named_label_uses = uses->next;\n-\n-\t    uses = uses->next;\n-\t  }\n-\telse\n-\t  {\n-\t    prev = uses;\n-\t    uses = uses->next;\n-\t  }\n+      if (ent)\n+\t{\n+\t  ent->names_in_scope = current_binding_level->names;\n+\t  ent->binding_level = current_binding_level;\n+\t}\n+      check_previous_gotos (decl);\n       current_function_return_value = NULL_TREE;\n       return decl;\n     }\n@@ -4953,8 +5126,6 @@ void\n define_case_label ()\n {\n   tree cleanup = last_cleanup_this_contour ();\n-  struct binding_level *b = current_binding_level;\n-  int identified = 0;\n \n   if (! switch_stack)\n     /* Don't crash; we'll complain in do_case.  */\n@@ -4973,29 +5144,7 @@ define_case_label ()\n \t}\n     }\n \n-  for (; b && b != switch_stack->level; b = b->level_chain)\n-    {\n-      tree new_decls = b->names;\n-      for (; new_decls; new_decls = TREE_CHAIN (new_decls))\n-\t{\n-\t  if (TREE_CODE (new_decls) == VAR_DECL\n-\t      /* Don't complain about crossing initialization\n-\t\t of internal entities.  They can't be accessed,\n-\t\t and they should be cleaned up\n-\t\t by the time we get to the label.  */\n-\t      && ! DECL_ARTIFICIAL (new_decls)\n-\t      && ((DECL_INITIAL (new_decls) != NULL_TREE\n-\t\t   && DECL_INITIAL (new_decls) != error_mark_node)\n-\t\t  || TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (new_decls))))\n-\t    {\n-\t      if (! identified)\n-\t\terror (\"jump to case label\");\n-\t      identified = 1;\n-\t      cp_error_at (\"  crosses initialization of `%#D'\",\n-\t\t\t   new_decls);\n-\t    }\n-\t}\n-    }\n+  check_switch_goto (switch_stack->level);\n \n   /* After labels, make any new cleanups go into their\n      own new (temporary) binding contour.  */\n@@ -14660,7 +14809,6 @@ mark_lang_function (p)\n   if (!p)\n     return;\n \n-  ggc_mark_tree (p->x_named_labels);\n   ggc_mark_tree (p->x_ctor_label);\n   ggc_mark_tree (p->x_dtor_label);\n   ggc_mark_tree (p->x_base_init_list);\n@@ -14672,6 +14820,7 @@ mark_lang_function (p)\n \n   ggc_mark_rtx (p->x_result_rtx);\n \n+  mark_named_label_lists (&p->x_named_labels, &p->x_named_label_uses);\n   mark_stmt_tree (&p->x_stmt_tree);\n   mark_binding_level (&p->bindings);\n }"}, {"sha": "505c487f2a8b3c603358cd615fb16d8851494864", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6625cdb595e9fa7c320e94c229c5e272893d0206/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6625cdb595e9fa7c320e94c229c5e272893d0206/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=6625cdb595e9fa7c320e94c229c5e272893d0206", "patch": "@@ -703,6 +703,8 @@ finish_goto_stmt (destination)\n \t   addresses, or some such.  */\n \tDECL_UNINLINABLE (current_function_decl) = 1;\n \n+      check_goto (destination);\n+\n       add_tree (build_min_nt (GOTO_STMT, destination));\n     }\n   else\n@@ -965,10 +967,15 @@ begin_compound_stmt (has_no_scope)\n      int has_no_scope;\n {\n   tree r; \n+  int is_try = 0;\n \n   if (building_stmt_tree ())\n     {\n       r = build_min_nt (COMPOUND_STMT, NULL_TREE);\n+      /* Mark that this block is for a try so that we can yell at\n+         people trying to jump in.  */\n+      if (last_tree && TREE_CODE (last_tree) == TRY_BLOCK)\n+\tis_try = 1;\n       add_tree (r);\n       if (has_no_scope)\n \tCOMPOUND_STMT_NO_SCOPE (r) = 1;\n@@ -979,7 +986,11 @@ begin_compound_stmt (has_no_scope)\n   last_expr_type = NULL_TREE;\n \n   if (!has_no_scope)\n-    do_pushlevel ();\n+    {\n+      do_pushlevel ();\n+      if (is_try)\n+\tnote_level_for_eh ();\n+    }\n   else\n     /* Normally, we try hard to keep the BLOCK for a\n        statement-expression.  But, if it's a statement-expression with\n@@ -2581,8 +2592,7 @@ expand_stmt (t)\n \t\texpand_start_bindings_and_block (2 * SCOPE_NULLIFIED_P (t),\n \t\t\t\t\t\t SCOPE_STMT_BLOCK (t));\n \t      else if (SCOPE_END_P (t))\n-\t\texpand_end_bindings (NULL_TREE, !SCOPE_NULLIFIED_P (t), \n-\t\t\t\t     SCOPE_PARTIAL_P (t));\n+\t\texpand_end_bindings (NULL_TREE, !SCOPE_NULLIFIED_P (t), 0);\n \t    }\n \t  else if (!SCOPE_NULLIFIED_P (t))\n \t    {"}]}