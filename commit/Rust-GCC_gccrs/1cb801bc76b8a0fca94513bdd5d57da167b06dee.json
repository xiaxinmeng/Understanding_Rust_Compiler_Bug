{"sha": "1cb801bc76b8a0fca94513bdd5d57da167b06dee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNiODAxYmM3NmI4YTBmY2E5NDUxM2JkZDVkNTdkYTE2N2IwNmRlZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-03-04T18:42:17Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-03-04T18:42:17Z"}, "message": "re PR c++/9634 ([DR224] Injected class name as qualifier should not make the name dependent)\n\n        PR c++/9634\n        PR c++/29469\n        PR c++/29607\n        * decl.c (make_typename_type): Do look inside currently open classes.\n        * parser.c (cp_parser_lookup_name): Likewise.\n        (cp_parser_template_name): Likewise.\n        * pt.c (dependent_scope_p): New function.\n        * cp-tree.h: Declare it.\n        * class.c (currently_open_class): Return fast if T isn't a class.\n\nCo-Authored-By: Giovanni Bajo <giovannibajo@gcc.gnu.org>\n\nFrom-SVN: r144618", "tree": {"sha": "4b043a137dad400926339308b7bbd08a4d533f53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b043a137dad400926339308b7bbd08a4d533f53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1cb801bc76b8a0fca94513bdd5d57da167b06dee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cb801bc76b8a0fca94513bdd5d57da167b06dee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cb801bc76b8a0fca94513bdd5d57da167b06dee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cb801bc76b8a0fca94513bdd5d57da167b06dee/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f017bf5e2d08214435620cd9644a2679782cba47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f017bf5e2d08214435620cd9644a2679782cba47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f017bf5e2d08214435620cd9644a2679782cba47"}], "stats": {"total": 171, "additions": 130, "deletions": 41}, "files": [{"sha": "30034b1e575d2e8155a5712b04efe98106c752d7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb801bc76b8a0fca94513bdd5d57da167b06dee/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb801bc76b8a0fca94513bdd5d57da167b06dee/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1cb801bc76b8a0fca94513bdd5d57da167b06dee", "patch": "@@ -1,3 +1,15 @@\n+2009-03-04  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/9634\n+\tPR c++/29469\n+\tPR c++/29607\n+\t* decl.c (make_typename_type): Do look inside currently open classes.\n+\t* parser.c (cp_parser_lookup_name): Likewise.\n+\t(cp_parser_template_name): Likewise.\n+\t* pt.c (dependent_scope_p): New function.\n+\t* cp-tree.h: Declare it.\n+\t* class.c (currently_open_class): Return fast if T isn't a class.\n+\n 2009-02-26  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR c++/37789"}, {"sha": "ae89218a700d0a5001c9de2a2f0df3bace65241a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb801bc76b8a0fca94513bdd5d57da167b06dee/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb801bc76b8a0fca94513bdd5d57da167b06dee/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=1cb801bc76b8a0fca94513bdd5d57da167b06dee", "patch": "@@ -5787,6 +5787,9 @@ currently_open_class (tree t)\n {\n   int i;\n \n+  if (!CLASS_TYPE_P (t))\n+    return false;\n+\n   /* We start looking from 1 because entry 0 is from global scope,\n      and has no type.  */\n   for (i = current_class_depth; i > 0; --i)"}, {"sha": "b6bf7d40da0939c5ff87ddc4b4afdd0d4fe5ed37", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb801bc76b8a0fca94513bdd5d57da167b06dee/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb801bc76b8a0fca94513bdd5d57da167b06dee/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1cb801bc76b8a0fca94513bdd5d57da167b06dee", "patch": "@@ -4594,6 +4594,7 @@ extern struct tinst_level *current_instantiation(void);\n extern tree maybe_get_template_decl_from_type_decl (tree);\n extern int processing_template_parmlist;\n extern bool dependent_type_p\t\t\t(tree);\n+extern bool dependent_scope_p\t\t\t(tree);\n extern bool any_dependent_template_arguments_p  (const_tree);\n extern bool dependent_template_p\t\t(tree);\n extern bool dependent_template_id_p\t\t(tree, tree);"}, {"sha": "ddd133ae2ea68085f630edb2ede2c74f40945d86", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb801bc76b8a0fca94513bdd5d57da167b06dee/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb801bc76b8a0fca94513bdd5d57da167b06dee/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=1cb801bc76b8a0fca94513bdd5d57da167b06dee", "patch": "@@ -2977,24 +2977,30 @@ make_typename_type (tree context, tree name, enum tag_types tag_type,\n   gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n   gcc_assert (TYPE_P (context));\n \n-  /* When the CONTEXT is a dependent type,  NAME could refer to a\n-     dependent base class of CONTEXT.  So we cannot peek inside it,\n-     even if CONTEXT is a currently open scope.  */\n-  if (dependent_type_p (context))\n-    return build_typename_type (context, name, fullname, tag_type);\n-\n   if (!MAYBE_CLASS_TYPE_P (context))\n     {\n       if (complain & tf_error)\n \terror (\"%q#T is not a class\", context);\n       return error_mark_node;\n     }\n   \n+  /* When the CONTEXT is a dependent type,  NAME could refer to a\n+     dependent base class of CONTEXT.  But look inside it anyway\n+     if CONTEXT is a currently open scope, in case it refers to a\n+     member of the current instantiation or a non-dependent base;\n+     lookup will stop when we hit a dependent base.  */\n+  if (!dependent_scope_p (context))\n+    /* We should only set WANT_TYPE when we're a nested typename type.\n+       Then we can give better diagnostics if we find a non-type.  */\n+    t = lookup_field (context, name, 0, /*want_type=*/true);\n+  else\n+    t = NULL_TREE;\n+\n+  if (!t && dependent_type_p (context)) \n+    return build_typename_type (context, name, fullname, tag_type);\n+\n   want_template = TREE_CODE (fullname) == TEMPLATE_ID_EXPR;\n   \n-  /* We should only set WANT_TYPE when we're a nested typename type.\n-     Then we can give better diagnostics if we find a non-type.  */\n-  t = lookup_field (context, name, 0, /*want_type=*/true);\n   if (!t)\n     {\n       if (complain & tf_error)"}, {"sha": "f07df913447f82fa66fa1bc03012fb55f3e2ae85", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 35, "deletions": 31, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb801bc76b8a0fca94513bdd5d57da167b06dee/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb801bc76b8a0fca94513bdd5d57da167b06dee/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=1cb801bc76b8a0fca94513bdd5d57da167b06dee", "patch": "@@ -10323,7 +10323,7 @@ cp_parser_template_name (cp_parser* parser,\n \t  && !template_keyword_p\n \t  && parser->scope && TYPE_P (parser->scope)\n \t  && check_dependency_p\n-\t  && dependent_type_p (parser->scope)\n+\t  && dependent_scope_p (parser->scope)\n \t  /* Do not do this for dtors (or ctors), since they never\n \t     need the template keyword before their name.  */\n \t  && !constructor_name_p (identifier, parser->scope))\n@@ -17023,35 +17023,11 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t cannot look up the name if the scope is not a class type; it\n \t might, for example, be a template type parameter.  */\n       dependent_p = (TYPE_P (parser->scope)\n-\t\t     && !(parser->in_declarator_p\n-\t\t\t  && currently_open_class (parser->scope))\n-\t\t     && dependent_type_p (parser->scope));\n+\t\t     && dependent_scope_p (parser->scope));\n       if ((check_dependency || !CLASS_TYPE_P (parser->scope))\n-\t   && dependent_p)\n-\t{\n-\t  if (tag_type)\n-\t    {\n-\t      tree type;\n-\n-\t      /* The resolution to Core Issue 180 says that `struct\n-\t\t A::B' should be considered a type-name, even if `A'\n-\t\t is dependent.  */\n-\t      type = make_typename_type (parser->scope, name, tag_type,\n-\t\t\t\t\t /*complain=*/tf_error);\n-\t      decl = TYPE_NAME (type);\n-\t    }\n-\t  else if (is_template\n-\t\t   && (cp_parser_next_token_ends_template_argument_p (parser)\n-\t\t       || cp_lexer_next_token_is (parser->lexer,\n-\t\t\t\t\t\t  CPP_CLOSE_PAREN)))\n-\t    decl = make_unbound_class_template (parser->scope,\n-\t\t\t\t\t\tname, NULL_TREE,\n-\t\t\t\t\t\t/*complain=*/tf_error);\n-\t  else\n-\t    decl = build_qualified_name (/*type=*/NULL_TREE,\n-\t\t\t\t\t parser->scope, name,\n-\t\t\t\t\t is_template);\n-\t}\n+\t  && dependent_p)\n+\t/* Defer lookup.  */\n+\tdecl = error_mark_node;\n       else\n \t{\n \t  tree pushed_scope = NULL_TREE;\n@@ -17072,14 +17048,42 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t\t\t\t\t/*complain=*/true);\n \n \t  /* If we have a single function from a using decl, pull it out.  */\n-\t  if (decl\n-\t      && TREE_CODE (decl) == OVERLOAD\n+\t  if (TREE_CODE (decl) == OVERLOAD\n \t      && !really_overloaded_fn (decl))\n \t    decl = OVL_FUNCTION (decl);\n \n \t  if (pushed_scope)\n \t    pop_scope (pushed_scope);\n \t}\n+\n+      /* If the scope is a dependent type and either we deferred lookup or\n+\t we did lookup but didn't find the name, rememeber the name.  */\n+      if (decl == error_mark_node && TYPE_P (parser->scope)\n+\t  && dependent_type_p (parser->scope))\n+\t{\n+\t  if (tag_type)\n+\t    {\n+\t      tree type;\n+\n+\t      /* The resolution to Core Issue 180 says that `struct\n+\t\t A::B' should be considered a type-name, even if `A'\n+\t\t is dependent.  */\n+\t      type = make_typename_type (parser->scope, name, tag_type,\n+\t\t\t\t\t /*complain=*/tf_error);\n+\t      decl = TYPE_NAME (type);\n+\t    }\n+\t  else if (is_template\n+\t\t   && (cp_parser_next_token_ends_template_argument_p (parser)\n+\t\t       || cp_lexer_next_token_is (parser->lexer,\n+\t\t\t\t\t\t  CPP_CLOSE_PAREN)))\n+\t    decl = make_unbound_class_template (parser->scope,\n+\t\t\t\t\t\tname, NULL_TREE,\n+\t\t\t\t\t\t/*complain=*/tf_error);\n+\t  else\n+\t    decl = build_qualified_name (/*type=*/NULL_TREE,\n+\t\t\t\t\t parser->scope, name,\n+\t\t\t\t\t is_template);\n+\t}\n       parser->qualifying_scope = parser->scope;\n       parser->object_scope = NULL_TREE;\n     }"}, {"sha": "8ae4ed511cc4260d6e8bc54aed69a39eead12cc5", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb801bc76b8a0fca94513bdd5d57da167b06dee/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb801bc76b8a0fca94513bdd5d57da167b06dee/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=1cb801bc76b8a0fca94513bdd5d57da167b06dee", "patch": "@@ -16067,6 +16067,16 @@ dependent_type_p (tree type)\n   return TYPE_DEPENDENT_P (type);\n }\n \n+/* Returns TRUE if SCOPE is a dependent scope, in which we can't do any\n+   lookup.  In other words, a dependent type that is not the current\n+   instantiation.  */\n+\n+bool\n+dependent_scope_p (tree scope)\n+{\n+  return dependent_type_p (scope) && !currently_open_class (scope);\n+}\n+\n /* Returns TRUE if EXPRESSION is dependent, according to CRITERION.  */\n \n static bool\n@@ -16088,7 +16098,7 @@ dependent_scope_ref_p (tree expression, bool criterion (tree))\n      An id-expression is type-dependent if it contains a\n      nested-name-specifier that contains a class-name that names a\n      dependent type.  */\n-  /* The suggested resolution to Core Issue 2 implies that if the\n+  /* The suggested resolution to Core Issue 224 implies that if the\n      qualifying type is the current class, then we must peek\n      inside it.  */\n   if (DECL_P (name)"}, {"sha": "97668fd82dfdfd798028983b942f4947c10e9beb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb801bc76b8a0fca94513bdd5d57da167b06dee/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb801bc76b8a0fca94513bdd5d57da167b06dee/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1cb801bc76b8a0fca94513bdd5d57da167b06dee", "patch": "@@ -1,3 +1,11 @@\n+2009-03-04  Jason Merrill  <jason@redhat.com>\n+\t    Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n+\n+\tPR c++/9634\n+\tPR c++/29469\n+\tPR c++/29607\n+\t* g++.dg/template/dependent-name5.C: New test.\n+\n 2009-03-04  Steve Ellcey  <sje@cup.hp.com>\n \n \tPR testsuite/39357"}, {"sha": "681060c7002e93e7a2288321118c86f3cab6fb66", "filename": "gcc/testsuite/g++.dg/template/dependent-name5.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cb801bc76b8a0fca94513bdd5d57da167b06dee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-name5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cb801bc76b8a0fca94513bdd5d57da167b06dee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-name5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-name5.C?ref=1cb801bc76b8a0fca94513bdd5d57da167b06dee", "patch": "@@ -0,0 +1,45 @@\n+// PR c++/9634, c++/29469, c++/29607\n+// Contributed by: Giovanni Bajo <giovannibajo at gcc dot gnu dot org>\n+// DR224: Make sure that a name is *truly* semantically dependent.\n+\n+struct D {\n+  typedef int K;\n+};\n+\n+template <typename T>\n+struct A\n+{\n+  typedef int Bar;\n+\n+  template <typename>\n+  struct N {};\n+\n+  typedef Bar          type1;\n+  typedef A::Bar       type2;\n+  typedef A<T>::Bar    type3;\n+  typedef A<T*>::Bar    type4;  // { dg-error \"\" }\n+  typedef typename A<T*>::Bar type5;\n+\n+  typedef N<int>       type6;\n+  typedef A::N<int>    type7;\n+  typedef A<T>::N<int> type8;\n+  typedef A<T*>::template N<int> type9;  // { dg-error \"\" }\n+  typedef typename A<T*>::template N<int> type10;\n+\n+  typedef D Bar2;\n+  struct N2 { typedef int K; };\n+\n+  // Check that A::N2 is still considered dependent (because it\n+  //  could be specialized), while A::Bar2 (being just ::D) is not.\n+  typedef A::Bar2 type11;\n+  typedef type11::K k3;\n+\n+  typedef A::N2 type12;\n+  typedef typename type12::K k2;\n+  typedef type12::K k1;  // { dg-error \"\" }\n+\n+  // Check that A::Bar2 is not considered dependent even if we use\n+  // the typename keyword.\n+  typedef typename A::Bar2 type13;\n+  typedef type13::K k4;\n+};"}]}