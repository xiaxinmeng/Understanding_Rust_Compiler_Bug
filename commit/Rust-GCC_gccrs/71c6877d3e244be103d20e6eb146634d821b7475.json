{"sha": "71c6877d3e244be103d20e6eb146634d821b7475", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFjNjg3N2QzZTI0NGJlMTAzZDIwZTZlYjE0NjYzNGQ4MjFiNzQ3NQ==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@cambridge.redhat.com", "date": "2002-03-18T17:11:43Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2002-03-18T17:11:43Z"}, "message": "i386-signal.h (old_i386_kernel_sigaction): New.\n\n2002-03-18  Andrew Haley  <aph@cambridge.redhat.com>\n\n        * include/i386-signal.h (old_i386_kernel_sigaction): New.\n        INIT_SEGV: Use old_i386_kernel_sigaction.\n        INIT_FP: Likewise.\n\nFrom-SVN: r50980", "tree": {"sha": "b4ea6ec4bfafe8f19d533783d33047ad1c37074d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4ea6ec4bfafe8f19d533783d33047ad1c37074d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71c6877d3e244be103d20e6eb146634d821b7475", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71c6877d3e244be103d20e6eb146634d821b7475", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71c6877d3e244be103d20e6eb146634d821b7475", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71c6877d3e244be103d20e6eb146634d821b7475/comments", "author": null, "committer": null, "parents": [{"sha": "b663bcf33f3ea2b7b6a4cf60da9c9c76b1a82255", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b663bcf33f3ea2b7b6a4cf60da9c9c76b1a82255", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b663bcf33f3ea2b7b6a4cf60da9c9c76b1a82255"}], "stats": {"total": 73, "additions": 47, "deletions": 26}, "files": [{"sha": "352e2d1201540486723735e4fc31a2550fac5b7e", "filename": "libjava/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71c6877d3e244be103d20e6eb146634d821b7475/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71c6877d3e244be103d20e6eb146634d821b7475/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=71c6877d3e244be103d20e6eb146634d821b7475", "patch": "@@ -1,3 +1,9 @@\n+2002-03-18  Andrew Haley  <aph@cambridge.redhat.com>\n+\n+\t* include/i386-signal.h (old_i386_kernel_sigaction): New.\n+\tINIT_SEGV: Use old_i386_kernel_sigaction.\n+\tINIT_FP: Likewise.\n+\n 2002-03-18  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n \n \t* java/lang/natSystem.cc (init_properties): Update VM version"}, {"sha": "6ad496c47a4d247c13194e59ae44ea9115c33889", "filename": "libjava/include/i386-signal.h", "status": "modified", "additions": 41, "deletions": 26, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71c6877d3e244be103d20e6eb146634d821b7475/libjava%2Finclude%2Fi386-signal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71c6877d3e244be103d20e6eb146634d821b7475/libjava%2Finclude%2Fi386-signal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fi386-signal.h?ref=71c6877d3e244be103d20e6eb146634d821b7475", "patch": "@@ -1,17 +1,14 @@\n-// i386-signal.h - Catch runtime signals and turn them into exceptions.\n+// i386-signal.h - Catch runtime signals and turn them into exceptions\n+// on an i386 based Linux system.\n \n-/* Copyright (C) 1998, 1999, 2001  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2001, 2002  Free Software Foundation\n \n    This file is part of libgcj.\n \n This software is copyrighted work licensed under the terms of the\n Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n details.  */\n \n-/* This technique should work for all i386 based Unices which conform\n- * to iBCS2.  This includes all versions of Linux more recent than 1.3 \n- */\n-\n \n #ifndef JAVA_SIGNAL_H\n #define JAVA_SIGNAL_H 1\n@@ -99,28 +96,40 @@ do\t\t\t\t\t\t\t\t\t\\\n }\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n-#define INIT_SEGV\t\t\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\\\n-    nullp = new java::lang::NullPointerException ();    \t\\\n-    struct sigaction act;\t\t\t\t\t\\\n-    act.sa_handler = catch_segv;\t\t\t\t\\\n-    sigemptyset (&act.sa_mask);\t\t\t\t\t\\\n-    act.sa_flags = 0;\t\t\t\t\t\t\\\n-    syscall (SYS_sigaction, SIGSEGV, &act, NULL);\t\t\\\n-  }\t\t\t\t\t\t\t\t\\\n+/* We use old_kernel_sigaction here because we're calling the kernel\n+   directly rather than via glibc.  The sigaction structure that the\n+   syscall uses is a different shape from the one in userland and not\n+   visible to us in a header file so we define it here.  */\n+\n+struct old_i386_kernel_sigaction {\n+\tvoid (*k_sa_handler) (int);\n+\tunsigned long k_sa_mask;\n+\tunsigned long k_sa_flags;\n+\tvoid (*sa_restorer) (void);\n+};\n+\n+#define INIT_SEGV\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    nullp = new java::lang::NullPointerException ();\t\\\n+    struct old_i386_kernel_sigaction kact;\t\t\\\n+    kact.k_sa_handler = catch_segv;\t\t\t\\\n+    kact.k_sa_mask = 0;\t\t\t\t\t\\\n+    kact.k_sa_flags = 0;\t\t\t\t\\\n+    syscall (SYS_sigaction, SIGSEGV, &kact, NULL);\t\\\n+  }\t\t\t\t\t\t\t\\\n while (0)  \n \n #define INIT_FPE\t\t\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\\\n-  { \t\t\t\t\t\t\t\t\\\n-    arithexception = new java::lang::ArithmeticException \t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    arithexception = new java::lang::ArithmeticException\t\\\n       (JvNewStringLatin1 (\"/ by zero\"));\t\t\t\\\n-    struct sigaction act;\t\t\t\t\t\\\n-    act.sa_handler = catch_fpe;\t\t\t\t\t\\\n-    sigemptyset (&act.sa_mask);\t\t\t\t\t\\\n-    act.sa_flags = 0;\t\t\t\t\t\t\\\n-    syscall (SYS_sigaction, SIGFPE, &act, NULL);\t\t\\\n+    struct old_i386_kernel_sigaction kact;\t\t\t\\\n+    kact.k_sa_handler = catch_fpe;\t\t\t\t\\\n+    kact.k_sa_mask = 0;\t\t\t\t\t\t\\\n+    kact.k_sa_flags = 0;\t\t\t\t\t\\\n+    syscall (SYS_sigaction, SIGFPE, &kact, NULL);\t\t\\\n   }\t\t\t\t\t\t\t\t\\\n while (0)  \n \n@@ -133,9 +142,15 @@ while (0)\n  * when returning from a signal handler.  If we return from our divide\n  * handler to a linuxthreads wrapper, we will lose the PC adjustment\n  * we made and return to the faulting instruction again.  Using\n- * syscall(SYS_sigaction) causes our handler to be called directly by\n- * the kernel, bypassing any wrappers.  This is a kludge, and a future\n- * version of this handler will do something better.  */\n+ * syscall(SYS_sigaction) causes our handler to be called directly\n+ * by the kernel, bypassing any wrappers.\n+\n+ * Also, there is at the present time no unwind info in the\n+ * linuxthreads library's signal handlers and so we can't unwind\n+ * through them anyway.  \n+\n+ * Finally, the code that glibc uses to return from a signal handler\n+ * is subject to change.  */\n \n #endif /* JAVA_SIGNAL_H */\n   "}]}