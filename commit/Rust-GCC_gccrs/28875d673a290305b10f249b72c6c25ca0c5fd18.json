{"sha": "28875d673a290305b10f249b72c6c25ca0c5fd18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg4NzVkNjczYTI5MDMwNWIxMGYyNDliNzJjNmMyNWNhMGM1ZmQxOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-11-22T23:13:48Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-11-22T23:13:48Z"}, "message": "ia64: Update to atomic optabs\n\n        * config/ia64/ia64.c (ia64_expand_atomic_op): Add model parameter.\n        Generate the barrier required for the memory model.\n        (rtx_needs_barrier): Handle UNSPEC_FETCHADD_REL, UNSPEC_CMPXCHG_REL.\n        * config/ia64/ia64-protos.h: Update.\n        * config/ia64/ia64.md (UNSPEC_FETCHADD_REL): New.\n        (UNSPEC_CMPXCHG_REL): New.\n        * config/ia64/sync.md (mem_thread_fence): New.\n        (atomic_load<IMODE>, atomic_store<IMODE>): New.\n        (atomic_compare_and_swap<IMODE>): New.\n        (cmpxchg_acq_<I124MODE>, cmpxchg_acq_di): New.\n        (atomic_exchange<IMODE>): New.\n        (xchg_acq_<IMODE>): Rename from sync_lock_test_and_set<IMODE>.\n        (atomic_<FETCHOP><IMODE>, atomic_nand<IMODE>): New.\n        (atomic_fetch_<FETCHOP><IMODE>, atomic_fetch_nand<IMODE>): New.\n        (atomic_<FETCHOP>_fetch<IMODE>, atomic_nand_fetch<IMODE>): New.\n        (fetchadd_rel_<I48MODE>): New.\n        (sync_<FETCHOP><IMODE>, sync_nand<IMODE>): Remove.\n        (sync_old_<FETCHOP><IMODE>, sync_old_nand<IMODE>): Remove.\n        (sync_new_<FETCHOP><IMODE>, sync_new_nand<IMODE>): Remove.\n        (sync_compare_and_swap<IMODE>): Remove.\n        (sync_lock_release<IMODE>): Remove.\n\nFrom-SVN: r181643", "tree": {"sha": "de0d7f6e93913bbb6d43c880707e4fe1118e3452", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de0d7f6e93913bbb6d43c880707e4fe1118e3452"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28875d673a290305b10f249b72c6c25ca0c5fd18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28875d673a290305b10f249b72c6c25ca0c5fd18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28875d673a290305b10f249b72c6c25ca0c5fd18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28875d673a290305b10f249b72c6c25ca0c5fd18/comments", "author": null, "committer": null, "parents": [{"sha": "127e44c868bd2bc9416781d212a293760ea413f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/127e44c868bd2bc9416781d212a293760ea413f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/127e44c868bd2bc9416781d212a293760ea413f6"}], "stats": {"total": 412, "additions": 315, "deletions": 97}, "files": [{"sha": "abd83806d004c3e30d22b3817d775c9389a30d54", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28875d673a290305b10f249b72c6c25ca0c5fd18/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28875d673a290305b10f249b72c6c25ca0c5fd18/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28875d673a290305b10f249b72c6c25ca0c5fd18", "patch": "@@ -1,5 +1,27 @@\n 2011-11-22  Richard Henderson  <rth@redhat.com>\n \n+\t* config/ia64/ia64.c (ia64_expand_atomic_op): Add model parameter.\n+\tGenerate the barrier required for the memory model.\n+\t(rtx_needs_barrier): Handle UNSPEC_FETCHADD_REL, UNSPEC_CMPXCHG_REL.\n+\t* config/ia64/ia64-protos.h: Update.\n+\t* config/ia64/ia64.md (UNSPEC_FETCHADD_REL): New.\n+\t(UNSPEC_CMPXCHG_REL): New.\n+\t* config/ia64/sync.md (mem_thread_fence): New.\n+\t(atomic_load<IMODE>, atomic_store<IMODE>): New.\n+\t(atomic_compare_and_swap<IMODE>): New.\n+\t(cmpxchg_acq_<I124MODE>, cmpxchg_acq_di): New.\n+\t(atomic_exchange<IMODE>): New.\n+\t(xchg_acq_<IMODE>): Rename from sync_lock_test_and_set<IMODE>.\n+\t(atomic_<FETCHOP><IMODE>, atomic_nand<IMODE>): New.\n+\t(atomic_fetch_<FETCHOP><IMODE>, atomic_fetch_nand<IMODE>): New.\n+\t(atomic_<FETCHOP>_fetch<IMODE>, atomic_nand_fetch<IMODE>): New.\n+\t(fetchadd_rel_<I48MODE>): New.\n+\t(sync_<FETCHOP><IMODE>, sync_nand<IMODE>): Remove.\n+\t(sync_old_<FETCHOP><IMODE>, sync_old_nand<IMODE>): Remove.\n+\t(sync_new_<FETCHOP><IMODE>, sync_new_nand<IMODE>): Remove.\n+\t(sync_compare_and_swap<IMODE>): Remove.\n+\t(sync_lock_release<IMODE>): Remove.\n+\n \t* config/ia64/ia64.md: Use define_e_enum for UNSPEC_*\n \tand UNSPECV_* constants.\n "}, {"sha": "c24f831601c0bc43fbf2c44703f4ec92d9a86bf3", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28875d673a290305b10f249b72c6c25ca0c5fd18/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28875d673a290305b10f249b72c6c25ca0c5fd18/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=28875d673a290305b10f249b72c6c25ca0c5fd18", "patch": "@@ -47,7 +47,8 @@ extern void ia64_expand_dot_prod_v8qi (rtx[], bool);\n extern void ia64_expand_call (rtx, rtx, rtx, int);\n extern void ia64_split_call (rtx, rtx, rtx, rtx, rtx, int, int);\n extern void ia64_reload_gp (void);\n-extern void ia64_expand_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx);\n+extern void ia64_expand_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx,\n+\t\t\t\t   enum memmodel);\n \n extern HOST_WIDE_INT ia64_initial_elimination_offset (int, int);\n extern void ia64_expand_prologue (void);"}, {"sha": "14993676ccc92837be56d7864d2b971477510b6f", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 62, "deletions": 13, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28875d673a290305b10f249b72c6c25ca0c5fd18/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28875d673a290305b10f249b72c6c25ca0c5fd18/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=28875d673a290305b10f249b72c6c25ca0c5fd18", "patch": "@@ -2266,7 +2266,7 @@ ia64_split_call (rtx retval, rtx addr, rtx retaddr, rtx scratch_r,\n \n void\n ia64_expand_atomic_op (enum rtx_code code, rtx mem, rtx val,\n-\t\t       rtx old_dst, rtx new_dst)\n+\t\t       rtx old_dst, rtx new_dst, enum memmodel model)\n {\n   enum machine_mode mode = GET_MODE (mem);\n   rtx old_reg, new_reg, cmp_reg, ar_ccv, label;\n@@ -2283,12 +2283,31 @@ ia64_expand_atomic_op (enum rtx_code code, rtx mem, rtx val,\n       if (!old_dst)\n         old_dst = gen_reg_rtx (mode);\n \n-      emit_insn (gen_memory_barrier ());\n+      switch (model)\n+\t{\n+\tcase MEMMODEL_ACQ_REL:\n+\tcase MEMMODEL_SEQ_CST:\n+\t  emit_insn (gen_memory_barrier ());\n+\t  /* FALLTHRU */\n+\tcase MEMMODEL_RELAXED:\n+\tcase MEMMODEL_ACQUIRE:\n+\tcase MEMMODEL_CONSUME:\n+\t  if (mode == SImode)\n+\t    icode = CODE_FOR_fetchadd_acq_si;\n+\t  else\n+\t    icode = CODE_FOR_fetchadd_acq_di;\n+\t  break;\n+\tcase MEMMODEL_RELEASE:\n+\t  if (mode == SImode)\n+\t    icode = CODE_FOR_fetchadd_rel_si;\n+\t  else\n+\t    icode = CODE_FOR_fetchadd_rel_di;\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n \n-      if (mode == SImode)\n-\ticode = CODE_FOR_fetchadd_acq_si;\n-      else\n-\ticode = CODE_FOR_fetchadd_acq_di;\n       emit_insn (GEN_FCN (icode) (old_dst, mem, val));\n \n       if (new_dst)\n@@ -2302,8 +2321,12 @@ ia64_expand_atomic_op (enum rtx_code code, rtx mem, rtx val,\n     }\n \n   /* Because of the volatile mem read, we get an ld.acq, which is the\n-     front half of the full barrier.  The end half is the cmpxchg.rel.  */\n-  gcc_assert (MEM_VOLATILE_P (mem));\n+     front half of the full barrier.  The end half is the cmpxchg.rel.\n+     For relaxed and release memory models, we don't need this.  But we\n+     also don't bother trying to prevent it either.  */\n+  gcc_assert (model == MEMMODEL_RELAXED\n+\t      || model == MEMMODEL_RELEASE\n+\t      || MEM_VOLATILE_P (mem));\n \n   old_reg = gen_reg_rtx (DImode);\n   cmp_reg = gen_reg_rtx (DImode);\n@@ -2342,12 +2365,36 @@ ia64_expand_atomic_op (enum rtx_code code, rtx mem, rtx val,\n   if (new_dst)\n     emit_move_insn (new_dst, new_reg);\n \n-  switch (mode)\n+  switch (model)\n     {\n-    case QImode:  icode = CODE_FOR_cmpxchg_rel_qi;  break;\n-    case HImode:  icode = CODE_FOR_cmpxchg_rel_hi;  break;\n-    case SImode:  icode = CODE_FOR_cmpxchg_rel_si;  break;\n-    case DImode:  icode = CODE_FOR_cmpxchg_rel_di;  break;\n+    case MEMMODEL_RELAXED:\n+    case MEMMODEL_ACQUIRE:\n+    case MEMMODEL_CONSUME:\n+      switch (mode)\n+\t{\n+\tcase QImode: icode = CODE_FOR_cmpxchg_acq_qi;  break;\n+\tcase HImode: icode = CODE_FOR_cmpxchg_acq_hi;  break;\n+\tcase SImode: icode = CODE_FOR_cmpxchg_acq_si;  break;\n+\tcase DImode: icode = CODE_FOR_cmpxchg_acq_di;  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n+\n+    case MEMMODEL_RELEASE:\n+    case MEMMODEL_ACQ_REL:\n+    case MEMMODEL_SEQ_CST:\n+      switch (mode)\n+\t{\n+\tcase QImode: icode = CODE_FOR_cmpxchg_rel_qi;  break;\n+\tcase HImode: icode = CODE_FOR_cmpxchg_rel_hi;  break;\n+\tcase SImode: icode = CODE_FOR_cmpxchg_rel_si;  break;\n+\tcase DImode: icode = CODE_FOR_cmpxchg_rel_di;  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -6342,6 +6389,7 @@ rtx_needs_barrier (rtx x, struct reg_flags flags, int pred)\n \tcase UNSPEC_PIC_CALL:\n         case UNSPEC_MF:\n         case UNSPEC_FETCHADD_ACQ:\n+        case UNSPEC_FETCHADD_REL:\n \tcase UNSPEC_BSP_VALUE:\n \tcase UNSPEC_FLUSHRS:\n \tcase UNSPEC_BUNDLE_SELECTOR:\n@@ -6385,6 +6433,7 @@ rtx_needs_barrier (rtx x, struct reg_flags flags, int pred)\n \t  break;\n \n         case UNSPEC_CMPXCHG_ACQ:\n+        case UNSPEC_CMPXCHG_REL:\n \t  need_barrier = rtx_needs_barrier (XVECEXP (x, 0, 1), flags, pred);\n \t  need_barrier |= rtx_needs_barrier (XVECEXP (x, 0, 2), flags, pred);\n \t  break;"}, {"sha": "129cec80fcf69f4d115abe48b2c4e56e6d11ca89", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28875d673a290305b10f249b72c6c25ca0c5fd18/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28875d673a290305b10f249b72c6c25ca0c5fd18/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=28875d673a290305b10f249b72c6c25ca0c5fd18", "patch": "@@ -68,7 +68,9 @@\n    UNSPEC_PIC_CALL\n    UNSPEC_MF\n    UNSPEC_CMPXCHG_ACQ\n+   UNSPEC_CMPXCHG_REL\n    UNSPEC_FETCHADD_ACQ\n+   UNSPEC_FETCHADD_REL\n    UNSPEC_BSP_VALUE\n    UNSPEC_FLUSHRS\n    UNSPEC_BUNDLE_SELECTOR"}, {"sha": "152e4f5a8a07e2c581d9340c641b3547b795d8b2", "filename": "gcc/config/ia64/sync.md", "status": "modified", "additions": 227, "deletions": 83, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28875d673a290305b10f249b72c6c25ca0c5fd18/gcc%2Fconfig%2Fia64%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28875d673a290305b10f249b72c6c25ca0c5fd18/gcc%2Fconfig%2Fia64%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fsync.md?ref=28875d673a290305b10f249b72c6c25ca0c5fd18", "patch": "@@ -18,6 +18,9 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n+;; Conversion to C++11 memory model based on\n+;; http://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html\n+\n (define_mode_iterator IMODE [QI HI SI DI])\n (define_mode_iterator I124MODE [QI HI SI])\n (define_mode_iterator I48MODE [SI DI])\n@@ -27,6 +30,15 @@\n (define_code_attr fetchop_name\n   [(plus \"add\") (minus \"sub\") (ior \"ior\") (xor \"xor\") (and \"and\")])\n \n+(define_expand \"mem_thread_fence\"\n+  [(match_operand:SI 0 \"const_int_operand\" \"\")]\t\t;; model\n+  \"\"\n+{\n+  if (INTVAL (operands[0]) == MEMMODEL_SEQ_CST)\n+    emit_insn (gen_memory_barrier ());\n+  DONE;\n+})\n+\n (define_expand \"memory_barrier\"\n   [(set (match_dup 0)\n \t(unspec:BLK [(match_dup 0)] UNSPEC_MF))]\n@@ -43,107 +55,94 @@\n   \"mf\"\n   [(set_attr \"itanium_class\" \"syst_m\")])\n \n-(define_insn \"fetchadd_acq_<mode>\"\n-  [(set (match_operand:I48MODE 0 \"gr_register_operand\" \"=r\")\n-\t(match_operand:I48MODE 1 \"not_postinc_memory_operand\" \"+S\"))\n-   (set (match_dup 1)\n-\t(unspec:I48MODE [(match_dup 1)\n-\t\t\t (match_operand:I48MODE 2 \"fetchadd_operand\" \"n\")]\n-\t\t        UNSPEC_FETCHADD_ACQ))]\n-  \"\"\n-  \"fetchadd<modesuffix>.acq %0 = %1, %2\"\n-  [(set_attr \"itanium_class\" \"sem\")])\n-\n-(define_expand \"sync_<fetchop_name><mode>\"\n-  [(set (match_operand:IMODE 0 \"memory_operand\" \"\")\n-\t(FETCHOP:IMODE (match_dup 0)\n-\t  (match_operand:IMODE 1 \"general_operand\" \"\")))]\n-  \"\"\n-{\n-  ia64_expand_atomic_op (<CODE>, operands[0], operands[1], NULL, NULL);\n-  DONE;\n-})\n-\n-(define_expand \"sync_nand<mode>\"\n-  [(set (match_operand:IMODE 0 \"memory_operand\" \"\")\n-\t(not:IMODE\n-\t  (and:IMODE (match_dup 0)\n-\t\t     (match_operand:IMODE 1 \"general_operand\" \"\"))))]\n+(define_expand \"atomic_load<mode>\"\n+  [(match_operand:IMODE 0 \"gr_register_operand\" \"\")\t\t;; output\n+   (match_operand:IMODE 1 \"memory_operand\" \"\")\t\t\t;; memory\n+   (match_operand:SI 2 \"const_int_operand\" \"\")]\t\t\t;; model\n   \"\"\n {\n-  ia64_expand_atomic_op (NOT, operands[0], operands[1], NULL, NULL);\n-  DONE;\n-})\n+  enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n \n-(define_expand \"sync_old_<fetchop_name><mode>\"\n-  [(set (match_operand:IMODE 0 \"gr_register_operand\" \"\")\n-\t(FETCHOP:IMODE \n-\t  (match_operand:IMODE 1 \"memory_operand\" \"\")\n-\t  (match_operand:IMODE 2 \"general_operand\" \"\")))]\n-  \"\"\n-{\n-  ia64_expand_atomic_op (<CODE>, operands[1], operands[2], operands[0], NULL);\n+  /* Unless the memory model is relaxed, we want to emit ld.acq, which\n+     will happen automatically for volatile memories.  */\n+  gcc_assert (model == MEMMODEL_RELAXED || MEM_VOLATILE_P (operands[1]));\n+  emit_move_insn (operands[0], operands[1]);\n   DONE;\n })\n \n-(define_expand \"sync_old_nand<mode>\"\n-  [(set (match_operand:IMODE 0 \"gr_register_operand\" \"\")\n-\t(not:IMODE \n-\t  (and:IMODE (match_operand:IMODE 1 \"memory_operand\" \"\")\n-\t\t     (match_operand:IMODE 2 \"general_operand\" \"\"))))]\n+(define_expand \"atomic_store<mode>\"\n+  [(match_operand:IMODE 0 \"memory_operand\" \"\")\t\t\t;; memory\n+   (match_operand:IMODE 1 \"gr_reg_or_0_operand\" \"\")\t\t;; input\n+   (match_operand:SI 2 \"const_int_operand\" \"\")]\t\t\t;; model\n   \"\"\n {\n-  ia64_expand_atomic_op (NOT, operands[1], operands[2], operands[0], NULL);\n-  DONE;\n-})\n+  enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n \n-(define_expand \"sync_new_<fetchop_name><mode>\"\n-  [(set (match_operand:IMODE 0 \"gr_register_operand\" \"\")\n-\t(FETCHOP:IMODE \n-\t  (match_operand:IMODE 1 \"memory_operand\" \"\")\n-\t  (match_operand:IMODE 2 \"general_operand\" \"\")))]\n-  \"\"\n-{\n-  ia64_expand_atomic_op (<CODE>, operands[1], operands[2], NULL, operands[0]);\n-  DONE;\n-})\n+  /* Unless the memory model is relaxed, we want to emit st.rel, which\n+     will happen automatically for volatile memories.  */\n+  gcc_assert (model == MEMMODEL_RELAXED || MEM_VOLATILE_P (operands[0]));\n+  emit_move_insn (operands[0], operands[1]);\n \n-(define_expand \"sync_new_nand<mode>\"\n-  [(set (match_operand:IMODE 0 \"gr_register_operand\" \"\")\n-\t(not:IMODE \n-\t  (and:IMODE (match_operand:IMODE 1 \"memory_operand\" \"\")\n-\t\t     (match_operand:IMODE 2 \"general_operand\" \"\"))))]\n-  \"\"\n-{\n-  ia64_expand_atomic_op (NOT, operands[1], operands[2], NULL, operands[0]);\n+  /* Sequentially consistent stores need a subsequent MF.  See\n+     http://www.decadent.org.uk/pipermail/cpp-threads/2008-December/001952.html\n+     for a discussion of why a MF is needed here, but not for atomic_load.  */\n+  if (model == MEMMODEL_SEQ_CST)\n+    emit_insn (gen_memory_barrier ());\n   DONE;\n })\n \n-(define_expand \"sync_compare_and_swap<mode>\"\n-  [(match_operand:IMODE 0 \"gr_register_operand\" \"\")\n-   (match_operand:IMODE 1 \"memory_operand\" \"\")\n-   (match_operand:IMODE 2 \"gr_register_operand\" \"\")\n-   (match_operand:IMODE 3 \"gr_register_operand\" \"\")]\n+(define_expand \"atomic_compare_and_swap<mode>\"\n+  [(match_operand:DI 0 \"gr_register_operand\" \"\")\t\t;; bool out\n+   (match_operand:IMODE 1 \"gr_register_operand\" \"\")\t\t;; val out\n+   (match_operand:IMODE 2 \"not_postinc_memory_operand\" \"\")\t;; memory\n+   (match_operand:IMODE 3 \"gr_register_operand\" \"\")\t\t;; expected\n+   (match_operand:IMODE 4 \"gr_reg_or_0_operand\" \"\")\t\t;; desired\n+   (match_operand:SI 5 \"const_int_operand\" \"\")\t\t\t;; is_weak\n+   (match_operand:SI 6 \"const_int_operand\" \"\")\t\t\t;; succ model\n+   (match_operand:SI 7 \"const_int_operand\" \"\")]\t\t\t;; fail model\n   \"\"\n {\n+  enum memmodel model = (enum memmodel) INTVAL (operands[6]);\n   rtx ccv = gen_rtx_REG (DImode, AR_CCV_REGNUM);\n-  rtx dst;\n+  rtx dval, eval;\n+\n+  eval = gen_reg_rtx (DImode);\n+  convert_move (eval, operands[3], 1);\n+  emit_move_insn (ccv, eval);\n \n-  convert_move (ccv, operands[2], 1);\n+  if (<MODE>mode == DImode)\n+    dval = operands[1];\n+  else\n+    dval = gen_reg_rtx (DImode);\n \n-  dst = operands[0];\n-  if (GET_MODE (dst) != DImode)\n-    dst = gen_reg_rtx (DImode);\n+  switch (model)\n+    {\n+    case MEMMODEL_RELAXED:\n+    case MEMMODEL_ACQUIRE:\n+    case MEMMODEL_CONSUME:\n+      emit_insn (gen_cmpxchg_acq_<mode> (dval, operands[2], ccv, operands[4]));\n+      break;\n+    case MEMMODEL_RELEASE:\n+      emit_insn (gen_cmpxchg_rel_<mode> (dval, operands[2], ccv, operands[4]));\n+      break;\n+    case MEMMODEL_ACQ_REL:\n+    case MEMMODEL_SEQ_CST:\n+      emit_insn (gen_cmpxchg_rel_<mode> (dval, operands[2], ccv, operands[4]));\n+      emit_insn (gen_memory_barrier ());\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n \n-  emit_insn (gen_cmpxchg_rel_<mode> (dst, operands[1], ccv, operands[3]));\n-  emit_insn (gen_memory_barrier ());\n+  if (<MODE>mode != DImode)\n+    emit_move_insn (operands[1], gen_lowpart (<MODE>mode, dval));\n \n-  if (dst != operands[0])\n-    emit_move_insn (operands[0], gen_lowpart (<MODE>mode, dst));\n+  emit_insn (gen_cstoredi4 (operands[0], gen_rtx_EQ (DImode, dval, eval),\n+\t\t\t    dval, eval));\n   DONE;\n })\n \n-(define_insn \"cmpxchg_rel_<mode>\"\n+(define_insn \"cmpxchg_acq_<mode>\"\n   [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n \t(zero_extend:DI\n \t  (match_operand:I124MODE 1 \"not_postinc_memory_operand\" \"+S\")))\n@@ -154,10 +153,24 @@\n \t   (match_operand:I124MODE 3 \"gr_reg_or_0_operand\" \"rO\")]\n \t  UNSPEC_CMPXCHG_ACQ))]\n   \"\"\n+  \"cmpxchg<modesuffix>.acq %0 = %1, %r3, %2\"\n+  [(set_attr \"itanium_class\" \"sem\")])\n+\n+(define_insn \"cmpxchg_rel_<mode>\"\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t  (match_operand:I124MODE 1 \"not_postinc_memory_operand\" \"+S\")))\n+   (set (match_dup 1)\n+        (unspec:I124MODE\n+\t  [(match_dup 1)\n+\t   (match_operand:DI 2 \"ar_ccv_reg_operand\" \"\")\n+\t   (match_operand:I124MODE 3 \"gr_reg_or_0_operand\" \"rO\")]\n+\t  UNSPEC_CMPXCHG_REL))]\n+  \"\"\n   \"cmpxchg<modesuffix>.rel %0 = %1, %r3, %2\"\n   [(set_attr \"itanium_class\" \"sem\")])\n \n-(define_insn \"cmpxchg_rel_di\"\n+(define_insn \"cmpxchg_acq_di\"\n   [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n \t(match_operand:DI 1 \"not_postinc_memory_operand\" \"+S\"))\n    (set (match_dup 1)\n@@ -166,10 +179,50 @@\n \t\t    (match_operand:DI 3 \"gr_reg_or_0_operand\" \"rO\")]\n \t\t   UNSPEC_CMPXCHG_ACQ))]\n   \"\"\n+  \"cmpxchg8.acq %0 = %1, %r3, %2\"\n+  [(set_attr \"itanium_class\" \"sem\")])\n+\n+(define_insn \"cmpxchg_rel_di\"\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n+\t(match_operand:DI 1 \"not_postinc_memory_operand\" \"+S\"))\n+   (set (match_dup 1)\n+        (unspec:DI [(match_dup 1)\n+\t\t    (match_operand:DI 2 \"ar_ccv_reg_operand\" \"\")\n+\t\t    (match_operand:DI 3 \"gr_reg_or_0_operand\" \"rO\")]\n+\t\t   UNSPEC_CMPXCHG_REL))]\n+  \"\"\n   \"cmpxchg8.rel %0 = %1, %r3, %2\"\n   [(set_attr \"itanium_class\" \"sem\")])\n \n-(define_insn \"sync_lock_test_and_set<mode>\"\n+(define_expand \"atomic_exchange<mode>\"\n+  [(match_operand:IMODE 0 \"gr_register_operand\" \"\")\t\t;; output\n+   (match_operand:IMODE 1 \"not_postinc_memory_operand\" \"\")\t;; memory\n+   (match_operand:IMODE 2 \"gr_reg_or_0_operand\" \"\")\t\t;; input\n+   (match_operand:SI 3 \"const_int_operand\" \"\")]\t\t\t;; succ model\n+  \"\"\n+{\n+  enum memmodel model = (enum memmodel) INTVAL (operands[3]);\n+\n+  switch (model)\n+    {\n+    case MEMMODEL_RELAXED:\n+    case MEMMODEL_ACQUIRE:\n+    case MEMMODEL_CONSUME:\n+      break;\n+    case MEMMODEL_RELEASE:\n+    case MEMMODEL_ACQ_REL:\n+    case MEMMODEL_SEQ_CST:\n+      emit_insn (gen_memory_barrier ());\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  emit_insn (gen_xchg_acq_<mode> (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+;; Note that XCHG is always memory model acquire.\n+(define_insn \"xchg_acq_<mode>\"\n   [(set (match_operand:IMODE 0 \"gr_register_operand\" \"=r\")\n         (match_operand:IMODE 1 \"not_postinc_memory_operand\" \"+S\"))\n    (set (match_dup 1)\n@@ -178,10 +231,101 @@\n   \"xchg<modesuffix> %0 = %1, %r2\"\n   [(set_attr \"itanium_class\" \"sem\")])\n \n-(define_expand \"sync_lock_release<mode>\"\n+(define_expand \"atomic_<fetchop_name><mode>\"\n   [(set (match_operand:IMODE 0 \"memory_operand\" \"\")\n-\t(match_operand:IMODE 1 \"gr_reg_or_0_operand\" \"\"))]\n+\t(FETCHOP:IMODE (match_dup 0)\n+\t  (match_operand:IMODE 1 \"nonmemory_operand\" \"\")))\n+   (use (match_operand:SI 2 \"const_int_operand\" \"\"))]\n+  \"\"\n+{\n+  ia64_expand_atomic_op (<CODE>, operands[0], operands[1], NULL, NULL,\n+\t\t\t (enum memmodel) INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"atomic_nand<mode>\"\n+  [(set (match_operand:IMODE 0 \"memory_operand\" \"\")\n+\t(not:IMODE\n+\t  (and:IMODE (match_dup 0)\n+\t\t     (match_operand:IMODE 1 \"nonmemory_operand\" \"\"))))\n+   (use (match_operand:SI 2 \"const_int_operand\" \"\"))]\n+  \"\"\n+{\n+  ia64_expand_atomic_op (NOT, operands[0], operands[1], NULL, NULL,\n+\t\t\t (enum memmodel) INTVAL (operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"atomic_fetch_<fetchop_name><mode>\"\n+  [(set (match_operand:IMODE 0 \"gr_register_operand\" \"\")\n+\t(FETCHOP:IMODE \n+\t  (match_operand:IMODE 1 \"memory_operand\" \"\")\n+\t  (match_operand:IMODE 2 \"nonmemory_operand\" \"\")))\n+   (use (match_operand:SI 3 \"const_int_operand\" \"\"))]\n   \"\"\n {\n-  gcc_assert (MEM_VOLATILE_P (operands[0]));\n+  ia64_expand_atomic_op (<CODE>, operands[1], operands[2], operands[0], NULL,\n+\t\t\t (enum memmodel) INTVAL (operands[3]));\n+  DONE;\n+})\n+\n+(define_expand \"atomic_fetch_nand<mode>\"\n+  [(set (match_operand:IMODE 0 \"gr_register_operand\" \"\")\n+\t(not:IMODE \n+\t  (and:IMODE (match_operand:IMODE 1 \"memory_operand\" \"\")\n+\t\t     (match_operand:IMODE 2 \"nonmemory_operand\" \"\"))))\n+   (use (match_operand:SI 3 \"const_int_operand\" \"\"))]\n+  \"\"\n+{\n+  ia64_expand_atomic_op (NOT, operands[1], operands[2], operands[0], NULL,\n+\t\t\t (enum memmodel) INTVAL (operands[3]));\n+  DONE;\n })\n+\n+(define_expand \"atomic_<fetchop_name>_fetch<mode>\"\n+  [(set (match_operand:IMODE 0 \"gr_register_operand\" \"\")\n+\t(FETCHOP:IMODE \n+\t  (match_operand:IMODE 1 \"memory_operand\" \"\")\n+\t  (match_operand:IMODE 2 \"nonmemory_operand\" \"\")))\n+   (use (match_operand:SI 3 \"const_int_operand\" \"\"))]\n+  \"\"\n+{\n+  ia64_expand_atomic_op (<CODE>, operands[1], operands[2], NULL, operands[0],\n+\t\t\t (enum memmodel) INTVAL (operands[3]));\n+  DONE;\n+})\n+\n+(define_expand \"atomic_nand_fetch<mode>\"\n+  [(set (match_operand:IMODE 0 \"gr_register_operand\" \"\")\n+\t(not:IMODE \n+\t  (and:IMODE (match_operand:IMODE 1 \"memory_operand\" \"\")\n+\t\t     (match_operand:IMODE 2 \"nonmemory_operand\" \"\"))))\n+   (use (match_operand:SI 3 \"const_int_operand\" \"\"))]\n+  \"\"\n+{\n+  ia64_expand_atomic_op (NOT, operands[1], operands[2], NULL, operands[0],\n+\t\t\t (enum memmodel) INTVAL (operands[3]));\n+  DONE;\n+})\n+\n+(define_insn \"fetchadd_acq_<mode>\"\n+  [(set (match_operand:I48MODE 0 \"gr_register_operand\" \"=r\")\n+\t(match_operand:I48MODE 1 \"not_postinc_memory_operand\" \"+S\"))\n+   (set (match_dup 1)\n+\t(unspec:I48MODE [(match_dup 1)\n+\t\t\t (match_operand:I48MODE 2 \"fetchadd_operand\" \"n\")]\n+\t\t        UNSPEC_FETCHADD_ACQ))]\n+  \"\"\n+  \"fetchadd<modesuffix>.acq %0 = %1, %2\"\n+  [(set_attr \"itanium_class\" \"sem\")])\n+\n+(define_insn \"fetchadd_rel_<mode>\"\n+  [(set (match_operand:I48MODE 0 \"gr_register_operand\" \"=r\")\n+\t(match_operand:I48MODE 1 \"not_postinc_memory_operand\" \"+S\"))\n+   (set (match_dup 1)\n+\t(unspec:I48MODE [(match_dup 1)\n+\t\t\t (match_operand:I48MODE 2 \"fetchadd_operand\" \"n\")]\n+\t\t        UNSPEC_FETCHADD_REL))]\n+  \"\"\n+  \"fetchadd<modesuffix>.rel %0 = %1, %2\"\n+  [(set_attr \"itanium_class\" \"sem\")])"}]}