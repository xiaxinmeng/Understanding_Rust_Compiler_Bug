{"sha": "b8c9f7afb7965379109982bffeaf647b7a8c4a47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhjOWY3YWZiNzk2NTM3OTEwOTk4MmJmZmVhZjY0N2I3YThjNGE0Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-11-13T11:28:27Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-11-13T11:28:27Z"}, "message": "[multiple changes]\n\n2015-11-13  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* init.c [Darwin/arm64]: Move __gnat_sigtramp implementation to...\n\t(__gnat_map_signal): New function.\n\t(__gnat_error_handler):\n\tAdjust the context and call above function.\n\t* sigtramp-armios.c: ...here.  New file.\n\n2015-11-13  Arnaud Charlet  <charlet@adacore.com>\n\n\t* bcheck.adb (Check_Consistent_Restrictions): Do not check\n\tconsistency of No_Dependence for runtime units.\n\n2015-11-13  Tristan Gingold  <gingold@adacore.com>\n\n\t* s-rident.ads (Restriction_Id): Add Pure_Barriers.\n\t* restrict.ads (Implementation_Restriction): Add Pure_Barriers.\n\t* exp_ch9.adb (Expand_Entry_Barrier): Create\n\tIs_Simple_Barrier_Name function, add Is_Pure_Barrier and\n\tCheck_Pure_Barriers.\n\n2015-11-13  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_util.adb (Get_Cursor_Type): To determine whether a function\n\tFirst is the proper Iterable primitive, use the base type of the\n\tfirst formal rather than the type. This is needed in the unusual\n\tcase where the Iterable aspect is specified for an integer type.\n\nFrom-SVN: r230305", "tree": {"sha": "0a27b82784988f776338e7130979657280e83f4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a27b82784988f776338e7130979657280e83f4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8c9f7afb7965379109982bffeaf647b7a8c4a47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8c9f7afb7965379109982bffeaf647b7a8c4a47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8c9f7afb7965379109982bffeaf647b7a8c4a47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8c9f7afb7965379109982bffeaf647b7a8c4a47/comments", "author": null, "committer": null, "parents": [{"sha": "4e9ee5951c4be406f440245583ee8770a5807e2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e9ee5951c4be406f440245583ee8770a5807e2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e9ee5951c4be406f440245583ee8770a5807e2a"}], "stats": {"total": 355, "additions": 265, "deletions": 90}, "files": [{"sha": "324d4dcda5a605c24eff625879f1858e4ff3c21a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c9f7afb7965379109982bffeaf647b7a8c4a47/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c9f7afb7965379109982bffeaf647b7a8c4a47/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b8c9f7afb7965379109982bffeaf647b7a8c4a47", "patch": "@@ -1,3 +1,31 @@\n+2015-11-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* init.c [Darwin/arm64]: Move __gnat_sigtramp implementation to...\n+\t(__gnat_map_signal): New function.\n+\t(__gnat_error_handler):\n+\tAdjust the context and call above function.\n+\t* sigtramp-armios.c: ...here.  New file.\n+\n+2015-11-13  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* bcheck.adb (Check_Consistent_Restrictions): Do not check\n+\tconsistency of No_Dependence for runtime units.\n+\n+2015-11-13  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* s-rident.ads (Restriction_Id): Add Pure_Barriers.\n+\t* restrict.ads (Implementation_Restriction): Add Pure_Barriers.\n+\t* exp_ch9.adb (Expand_Entry_Barrier): Create\n+\tIs_Simple_Barrier_Name function, add Is_Pure_Barrier and\n+\tCheck_Pure_Barriers.\n+\n+2015-11-13  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_util.adb (Get_Cursor_Type): To determine whether a function\n+\tFirst is the proper Iterable primitive, use the base type of the\n+\tfirst formal rather than the type. This is needed in the unusual\n+\tcase where the Iterable aspect is specified for an integer type.\n+\n 2015-11-13  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch4.adb (Constant_Indexing_OK): If the indexing is the"}, {"sha": "4170b0e8e0e0bdecc915d4a9cd32767a734c5404", "filename": "gcc/ada/bcheck.adb", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c9f7afb7965379109982bffeaf647b7a8c4a47/gcc%2Fada%2Fbcheck.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c9f7afb7965379109982bffeaf647b7a8c4a47/gcc%2Fada%2Fbcheck.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbcheck.adb?ref=b8c9f7afb7965379109982bffeaf647b7a8c4a47", "patch": "@@ -979,23 +979,27 @@ package body Bcheck is\n             for J in ALIs.First .. ALIs.Last loop\n                declare\n                   A : ALIs_Record renames ALIs.Table (J);\n-\n                begin\n                   for K in A.First_Unit .. A.Last_Unit loop\n                      declare\n                         U : Unit_Record renames Units.Table (K);\n                      begin\n-                        for L in U.First_With .. U.Last_With loop\n-                           if Same_Unit\n-                             (Withs.Table (L).Uname, ND_Unit)\n-                           then\n-                              Error_Msg_File_1 := U.Sfile;\n-                              Error_Msg_Name_1 := ND_Unit;\n-                              Consistency_Error_Msg\n-                                (\"file { violates restriction \" &\n-                                 \"No_Dependence => %\");\n-                           end if;\n-                        end loop;\n+                        --  Exclude runtime units from this check since the\n+                        --  user does not care how a runtime unit is\n+                        --  implemented.\n+\n+                        if not Is_Internal_File_Name (U.Sfile) then\n+                           for L in U.First_With .. U.Last_With loop\n+                              if Same_Unit (Withs.Table (L).Uname, ND_Unit)\n+                              then\n+                                 Error_Msg_File_1 := U.Sfile;\n+                                 Error_Msg_Name_1 := ND_Unit;\n+                                 Consistency_Error_Msg\n+                                   (\"file { violates restriction \" &\n+                                    \"No_Dependence => %\");\n+                              end if;\n+                           end loop;\n+                        end if;\n                      end;\n                   end loop;\n                end;"}, {"sha": "f985019d76fdfc66967d075ea6107cf9feea58f9", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 90, "deletions": 16, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c9f7afb7965379109982bffeaf647b7a8c4a47/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c9f7afb7965379109982bffeaf647b7a8c4a47/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=b8c9f7afb7965379109982bffeaf647b7a8c4a47", "patch": "@@ -6306,6 +6306,14 @@ package body Exp_Ch9 is\n       --  Check whether entity in Barrier is external to protected type.\n       --  If so, barrier may not be properly synchronized.\n \n+      function Is_Pure_Barrier (N : Node_Id) return Traverse_Result;\n+      --  Check whether N follow the Pure_Barriers restriction. Return OK if\n+      --  so.\n+\n+      function Is_Simple_Barrier_Name (N : Node_Id) return Boolean;\n+      --  Check wether entity name N denotes a component of the protected\n+      --  object. This is used to check the Simple_Barrier restriction.\n+\n       ----------------------\n       -- Is_Global_Entity --\n       ----------------------\n@@ -6356,6 +6364,81 @@ package body Exp_Ch9 is\n       procedure Check_Unprotected_Barrier is\n         new Traverse_Proc (Is_Global_Entity);\n \n+      ----------------------------\n+      -- Is_Simple_Barrier_Name --\n+      ----------------------------\n+\n+      function Is_Simple_Barrier_Name (N : Node_Id) return Boolean is\n+         Renamed : Node_Id;\n+      begin\n+         if not Expander_Active then\n+            return Scope (Entity (N)) = Current_Scope;\n+\n+         --  Check for case of _object.all.field (note that the explicit\n+         --  dereference gets inserted by analyze/expand of _object.field)\n+\n+         else\n+            Renamed := Renamed_Object (Entity (N));\n+            return Present (Renamed)\n+              and then Nkind (Renamed) = N_Selected_Component\n+              and then Chars (Prefix (Prefix (Renamed))) = Name_uObject;\n+         end if;\n+      end Is_Simple_Barrier_Name;\n+\n+      ---------------------\n+      -- Is_Pure_Barrier --\n+      ---------------------\n+\n+      function Is_Pure_Barrier (N : Node_Id) return Traverse_Result is\n+      begin\n+         case Nkind (N) is\n+            when N_Identifier\n+              | N_Expanded_Name =>\n+\n+               if No (Entity (N)) then\n+                  return Abandon;\n+               end if;\n+\n+               case Ekind (Entity (N)) is\n+                  when E_Constant\n+                    | E_Discriminant\n+                    | E_Named_Integer\n+                    | E_Named_Real\n+                    | E_Enumeration_Literal =>\n+                     return OK;\n+\n+                  when E_Variable =>\n+                     if Is_Simple_Barrier_Name (N) then\n+                        return OK;\n+                     end if;\n+\n+                  when others =>\n+                     null;\n+               end case;\n+\n+            when N_Integer_Literal\n+              | N_Real_Literal\n+              | N_Character_Literal =>\n+               return OK;\n+\n+            when N_Op_Boolean\n+              | N_Op_Not =>\n+               if Ekind (Entity (N)) = E_Operator then\n+                  return OK;\n+               end if;\n+\n+            when N_Short_Circuit =>\n+               return OK;\n+\n+            when others =>\n+               null;\n+         end case;\n+\n+         return Abandon;\n+      end Is_Pure_Barrier;\n+\n+      function Check_Pure_Barriers is new Traverse_Func (Is_Pure_Barrier);\n+\n    --  Start of processing for Expand_Entry_Barrier\n \n    begin\n@@ -6393,6 +6476,12 @@ package body Exp_Ch9 is\n          Analyze_And_Resolve (Cond, Any_Boolean);\n       end if;\n \n+      --  Check Pure_Barriers restriction\n+\n+      if Check_Pure_Barriers (Cond) = Abandon then\n+         Check_Restriction (Pure_Barriers, Cond);\n+      end if;\n+\n       --  The Ravenscar profile restricts barriers to simple variables declared\n       --  within the protected object. We also allow Boolean constants, since\n       --  these appear in several published examples and are also allowed by\n@@ -6421,22 +6510,7 @@ package body Exp_Ch9 is\n          then\n             return;\n \n-         elsif not Expander_Active\n-           and then Scope (Entity (Cond)) = Current_Scope\n-         then\n-            return;\n-\n-         --  Check for case of _object.all.field (note that the explicit\n-         --  dereference gets inserted by analyze/expand of _object.field)\n-\n-         elsif Present (Renamed_Object (Entity (Cond)))\n-           and then\n-             Nkind (Renamed_Object (Entity (Cond))) = N_Selected_Component\n-           and then\n-             Chars\n-               (Prefix\n-                 (Prefix (Renamed_Object (Entity (Cond))))) = Name_uObject\n-         then\n+         elsif Is_Simple_Barrier_Name (Cond) then\n             return;\n          end if;\n       end if;"}, {"sha": "dcd5c3d0642c103cdd0f6ba452e8573f5a69e622", "filename": "gcc/ada/init.c", "status": "modified", "additions": 27, "deletions": 61, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c9f7afb7965379109982bffeaf647b7a8c4a47/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c9f7afb7965379109982bffeaf647b7a8c4a47/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=b8c9f7afb7965379109982bffeaf647b7a8c4a47", "patch": "@@ -2299,45 +2299,7 @@ char __gnat_alternate_stack[32 * 1024]; /* 1 * MINSIGSTKSZ */\n \n #ifdef __arm64__\n #include <sys/ucontext.h>\n-\n-/* Trampoline inserted before raising the exception.  It modifies the\n-   stack so that it looks to be called directly from the fault point.\n-   Note that LR may be incorrectly restored by unwinding.  */\n-void __gnat_sigtramp (struct Exception_Data *d, const char *m,\n-\t\t      mcontext_t ctxt,\n-\t\t      void (*proc)(struct Exception_Data *, const char *));\n-\n-asm(\"\\n\"\n-\"\t.section\t__TEXT,__text,regular,pure_instructions\\n\"\n-\"\t.align  2\\n\"\n-\"___gnat_sigtramp:\\n\"\n-\"\t.cfi_startproc\\n\"\n-\t/* Restore callee saved registers.  */\n-\"\tldp\tx19, x20, [x2, #168]\\n\"\n-\"\tldp\tx21, x22, [x2, #184]\\n\"\n-\"\tldp\tx23, x24, [x2, #200]\\n\"\n-\"\tldp\tx25, x26, [x2, #216]\\n\"\n-\"\tldp\tx27, x28, [x2, #232]\\n\"\n-\"\tldp\tq8, q9, [x2, #416]\\n\"\n-\"\tldp\tq10, q11, [x2, #448]\\n\"\n-\"\tldp\tq12, q13, [x2, #480]\\n\"\n-\"\tldp\tq14, q15, [x2, #512]\\n\"\n-\t/* Read FP from mcontext.  */\n-\"\tldr\tfp, [x2, #248]\\n\"\n-\t/* Read SP and PC from mcontext.  */\n-\"\tldp\tx6, lr, [x2, #264]\\n\"\n-\"\tmov\tsp, x6\\n\"\n-\t/* Create a minimal frame.  */\n-\"\tstp\tfp, lr, [sp, #-16]!\\n\"\n-\"\t.cfi_def_cfa_offset 16\\n\"\n-\"\t.cfi_offset\t30, -8\\n\"\n-\"\t.cfi_offset\t29, -16\\n\"\n-\"\tblr\tx3\\n\"\n-\t/* Release our frame and return (should never get here!).  */\n-\"\tldp\tfp, lr, [sp, #16]\\n\"\n-\"\tret\\n\"\n-\"\t.cfi_endproc\\n\"\n-);\n+#include \"sigtramp.h\"\n #endif\n \n /* Return true if ADDR is within a stack guard area.  */\n@@ -2425,13 +2387,11 @@ __gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED,\n }\n \n static void\n-__gnat_error_handler (int sig, siginfo_t *si, void *ucontext)\n+__gnat_map_signal (int sig, siginfo_t *si, void *ucontext ATTRIBUTE_UNUSED)\n {\n   struct Exception_Data *exception;\n   const char *msg;\n \n-  __gnat_adjust_context_for_raise (sig, ucontext);\n-\n   switch (sig)\n     {\n     case SIGSEGV:\n@@ -2446,29 +2406,11 @@ __gnat_error_handler (int sig, siginfo_t *si, void *ucontext)\n \t  exception = &constraint_error;\n \t  msg = \"erroneous memory access\";\n \t}\n+\n       /* Reset the use of alt stack, so that the alt stack will be used\n \t for the next signal delivery.\n          The stack can't be used in case of stack checking.  */\n       syscall (SYS_sigreturn, NULL, UC_RESET_ALT_STACK);\n-\n-#ifdef __arm64__\n-      /* ??? Temporary kludge to make stack checking work.  The problem is\n-\t that the trampoline doesn't restore LR and, consequently, doesn't\n-\t make it possible to unwind past an interrupted frame which hasn\"t\n-\t saved LR on the stack yet.  */\n-      if (__gnat_is_stack_guard ((unsigned long)si->si_addr))\n-\t{\n-\t  ucontext_t *uc = (ucontext_t *)ucontext;\n-\t  uc->uc_mcontext->__ss.__pc = uc->uc_mcontext->__ss.__lr;\n-\t}\n-\n-      /* On arm64, use a trampoline so that the unwinder won't see the\n-\t signal frame.  */\n-      __gnat_sigtramp (exception, msg,\n-\t\t       ((ucontext_t *)ucontext)->uc_mcontext,\n-\t\t       Raise_From_Signal_Handler);\n-      return;\n-#endif\n       break;\n \n     case SIGFPE:\n@@ -2484,6 +2426,30 @@ __gnat_error_handler (int sig, siginfo_t *si, void *ucontext)\n   Raise_From_Signal_Handler (exception, msg);\n }\n \n+static void\n+__gnat_error_handler (int sig, siginfo_t *si, void *ucontext)\n+{\n+  __gnat_adjust_context_for_raise (sig, ucontext);\n+\n+#ifdef __arm64__\n+  /* ??? Temporary kludge to make stack checking work.  The problem is\n+     that the trampoline doesn't restore LR and, consequently, doesn't\n+     make it possible to unwind past an interrupted frame which hasn\"t\n+     saved LR on the stack yet.  */\n+  if (__gnat_is_stack_guard ((unsigned long)si->si_addr))\n+    {\n+      ucontext_t *uc = (ucontext_t *)ucontext;\n+      uc->uc_mcontext->__ss.__pc = uc->uc_mcontext->__ss.__lr;\n+    }\n+\n+    /* Use a trampoline so that the unwinder won't see the signal frame.  */\n+  __gnat_sigtramp (sig, (void *)si, ucontext,\n+\t\t   (__sigtramphandler_t *)&__gnat_map_signal);\n+#else\n+  __gnat_map_signal (sig, si, ucontext);\n+#endif\n+}\n+\n void\n __gnat_install_handler (void)\n {"}, {"sha": "c8c050c20a658218a87104bdc60357be9be06c8d", "filename": "gcc/ada/restrict.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c9f7afb7965379109982bffeaf647b7a8c4a47/gcc%2Fada%2Frestrict.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c9f7afb7965379109982bffeaf647b7a8c4a47/gcc%2Fada%2Frestrict.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.ads?ref=b8c9f7afb7965379109982bffeaf647b7a8c4a47", "patch": "@@ -147,6 +147,7 @@ package Restrict is\n       No_Wide_Characters                 => True,\n       Static_Priorities                  => True,\n       Static_Storage_Size                => True,\n+      Pure_Barriers                      => True,\n       SPARK_05                           => True,\n       others                             => False);\n "}, {"sha": "66aa10e90387382c774b836a13649604475fec1e", "filename": "gcc/ada/s-rident.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c9f7afb7965379109982bffeaf647b7a8c4a47/gcc%2Fada%2Fs-rident.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c9f7afb7965379109982bffeaf647b7a8c4a47/gcc%2Fada%2Fs-rident.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-rident.ads?ref=b8c9f7afb7965379109982bffeaf647b7a8c4a47", "patch": "@@ -182,6 +182,7 @@ package System.Rident is\n       No_Elaboration_Code,                       -- GNAT\n       No_Obsolescent_Features,                   -- Ada 2005 AI-368\n       No_Wide_Characters,                        -- GNAT\n+      Pure_Barriers,                             -- GNAT\n       SPARK_05,                                  -- GNAT\n \n       --  The following cases require a parameter value"}, {"sha": "36dfc4df22f5afef893de1feba575e44735901fd", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c9f7afb7965379109982bffeaf647b7a8c4a47/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c9f7afb7965379109982bffeaf647b7a8c4a47/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=b8c9f7afb7965379109982bffeaf647b7a8c4a47", "patch": "@@ -7553,13 +7553,16 @@ package body Sem_Util is\n       Cursor := Any_Type;\n \n       --  Locate function with desired name and profile in scope of type\n+      --  In the rare case where the type is an integer type, a base type\n+      --  is created for it, check that the base type of the first formal\n+      --  of First matches the base type of the domain.\n \n       Func := First_Entity (Scope (Typ));\n       while Present (Func) loop\n          if Chars (Func) = Chars (First_Op)\n            and then Ekind (Func) = E_Function\n            and then Present (First_Formal (Func))\n-           and then Etype (First_Formal (Func)) = Typ\n+           and then Base_Type (Etype (First_Formal (Func))) = Base_Type (Typ)\n            and then No (Next_Formal (First_Formal (Func)))\n          then\n             if Cursor /= Any_Type then"}, {"sha": "3206256ac595f20da85b24411d8debb7ef617e77", "filename": "gcc/ada/sigtramp-armios.c", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8c9f7afb7965379109982bffeaf647b7a8c4a47/gcc%2Fada%2Fsigtramp-armios.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8c9f7afb7965379109982bffeaf647b7a8c4a47/gcc%2Fada%2Fsigtramp-armios.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp-armios.c?ref=b8c9f7afb7965379109982bffeaf647b7a8c4a47", "patch": "@@ -0,0 +1,98 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                             S I G T R A M P                              *\n+ *                                                                          *\n+ *                         Asm Implementation File                          *\n+ *                                                                          *\n+ *           Copyright (C) 2015, Free Software Foundation, Inc.             *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.                                     *\n+ *                                                                          *\n+ * As a special exception under Section 7 of GPL version 3, you are granted *\n+ * additional permissions described in the GCC Runtime Library Exception,   *\n+ * version 3.1, as published by the Free Software Foundation.               *\n+ *                                                                          *\n+ * In particular,  you can freely  distribute your programs  built with the *\n+ * GNAT Pro compiler, including any required library run-time units,  using *\n+ * any licensing terms  of your choosing.  See the AdaCore Software License *\n+ * for full details.                                                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/**************************************************\n+ * ARM-IOS version of the __gnat_sigtramp service *\n+ **************************************************/\n+\n+#include <sys/ucontext.h>\n+\n+#include \"sigtramp.h\"\n+/* See sigtramp.h for a general explanation of functionality.  */\n+\n+/* -----------------------------------------\n+   -- Protypes for our internal asm stubs --\n+   -----------------------------------------\n+\n+   The registers are expected to be at SIGCONTEXT + OFFSET (reference to the\n+   machine context structure).  Even though our symbols will remain local, the\n+   prototype claims \"extern\" and not \"static\" to prevent compiler complaints\n+   about a symbol used but never defined.  */\n+\n+/* sigtramp stub providing unwind info for common registers.  */\n+\n+extern void __gnat_sigtramp_common\n+  (int signo, void *siginfo, void *sigcontext,\n+   __sigtramphandler_t * handler);\n+\n+void __gnat_sigtramp (int signo, void *si, void *ucontext,\n+                      __sigtramphandler_t * handler)\n+     __attribute__((optimize(2)));\n+\n+void __gnat_sigtramp (int signo, void *si, void *ucontext,\n+                      __sigtramphandler_t * handler)\n+{\n+  mcontext_t mcontext = ((ucontext_t *) ucontext)->uc_mcontext;\n+\n+  __gnat_sigtramp_common (signo, si, mcontext, handler);\n+}\n+\n+asm(\"\\n\"\n+\"\t.section\t__TEXT,__text,regular,pure_instructions\\n\"\n+\"\t.align  2\\n\"\n+\"___gnat_sigtramp_common:\\n\"\n+\"\t.cfi_startproc\\n\"\n+\t/* Restore callee saved registers.  */\n+\"\tldp\tx19, x20, [x2, #168]\\n\"\n+\"\tldp\tx21, x22, [x2, #184]\\n\"\n+\"\tldp\tx23, x24, [x2, #200]\\n\"\n+\"\tldp\tx25, x26, [x2, #216]\\n\"\n+\"\tldp\tx27, x28, [x2, #232]\\n\"\n+\"\tldp\tq8, q9, [x2, #416]\\n\"\n+\"\tldp\tq10, q11, [x2, #448]\\n\"\n+\"\tldp\tq12, q13, [x2, #480]\\n\"\n+\"\tldp\tq14, q15, [x2, #512]\\n\"\n+\t/* Read FP from mcontext.  */\n+\"\tldr\tfp, [x2, #248]\\n\"\n+\t/* Read SP and PC from mcontext.  */\n+\"\tldp\tx6, lr, [x2, #264]\\n\"\n+\"\tmov\tsp, x6\\n\"\n+\t/* Create a minimal frame.  */\n+\"\tstp\tfp, lr, [sp, #-16]!\\n\"\n+\"\t.cfi_def_cfa_offset 16\\n\"\n+\"\t.cfi_offset\t30, -8\\n\"\n+\"\t.cfi_offset\t29, -16\\n\"\n+\"\tblr\tx3\\n\"\n+\t/* Release our frame and return (should never get here!).  */\n+\"\tldp\tfp, lr, [sp, #16]\\n\"\n+\"\tret\\n\"\n+\"\t.cfi_endproc\\n\"\n+);"}]}