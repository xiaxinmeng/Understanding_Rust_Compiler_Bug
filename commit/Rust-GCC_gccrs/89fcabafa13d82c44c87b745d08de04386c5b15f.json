{"sha": "89fcabafa13d82c44c87b745d08de04386c5b15f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODlmY2FiYWZhMTNkODJjNDRjODdiNzQ1ZDA4ZGUwNDM4NmM1YjE1Zg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2012-04-18T10:21:43Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2012-04-18T10:21:43Z"}, "message": "re PR c++/52422 ([C++11][SFINAE] Hard errors with void or arithmetic expressions)\n\n/cp\n2012-04-18  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/52422\n\t* cp-tree.h (build_addr_func, decay_conversion,\n\tget_member_function_from_ptrfunc,\n\tbuild_m_component_ref, convert_member_func_to_ptr):\n\tAdd tsubst_flags_t parameter.\n\t* typeck.c (cp_default_conversion): Add.\n\t(decay_conversion, default_conversion,\n\tget_member_function_from_ptrfunc, convert_member_func_to_ptr):\n\tAdd tsubst_flags_t parameter and use it throughout.\n\t(cp_build_indirect_ref, cp_build_array_ref,\n\tcp_build_function_call_vec, convert_arguments, build_x_binary_op,\n\tcp_build_binary_op, cp_build_unary_op, build_reinterpret_cast_1,\n\tbuild_const_cast_1, expand_ptrmemfunc_cst,\n\tconvert_for_initialization): Adjust.\n\t* init.c (build_vec_init): Adjust.\n\t* decl.c (grok_reference_init, get_atexit_node): Likewise.\n\t* rtti.c (build_dynamic_cast_1, tinfo_base_init): Likewise.\n\t* except.c (build_throw): Likewise.\n\t* typeck2.c (build_x_arrow): Likewise.\n\t(build_m_component_ref): Add tsubst_flags_t parameter and\n\tuse it throughout.\n\t* pt.c (convert_nontype_argument): Adjust.\n\t* semantics.c (finish_asm_stmt, maybe_add_lambda_conv_op): Likewise.\n\t* decl2.c (build_offset_ref_call_from_tree): Likewise.\n\t* call.c (build_addr_func): Add tsubst_flags_t parameter and\n\tuse it throughout.\n\t(build_call_a, build_conditional_expr_1, build_new_op_1,\n\tconvert_like_real, convert_arg_to_ellipsis, build_over_call,\n\tbuild_special_member_call): Adjust.\n\t* cvt.c (cp_convert_to_pointer, force_rvalue,\n\tbuild_expr_type_conversion): Likewise.\n\n/testsuite\n2012-04-18  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/52422\n\t* g++.dg/cpp0x/sfinae33.C: New.\n\t* g++.dg/cpp0x/sfinae34.C: Likewise.\n\nFrom-SVN: r186565", "tree": {"sha": "dd9019ca2a1fa34c934ecc6915019c675d4e0b66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd9019ca2a1fa34c934ecc6915019c675d4e0b66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89fcabafa13d82c44c87b745d08de04386c5b15f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89fcabafa13d82c44c87b745d08de04386c5b15f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89fcabafa13d82c44c87b745d08de04386c5b15f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89fcabafa13d82c44c87b745d08de04386c5b15f/comments", "author": null, "committer": null, "parents": [{"sha": "5932a4d411f30d1a07789f28528a2c57fb8e33e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5932a4d411f30d1a07789f28528a2c57fb8e33e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5932a4d411f30d1a07789f28528a2c57fb8e33e4"}], "stats": {"total": 396, "additions": 288, "deletions": 108}, "files": [{"sha": "0be0be4b6a1021162dcd53a682057848bcb715c4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=89fcabafa13d82c44c87b745d08de04386c5b15f", "patch": "@@ -1,3 +1,37 @@\n+2012-04-18  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/52422\n+\t* cp-tree.h (build_addr_func, decay_conversion,\n+\tget_member_function_from_ptrfunc,\n+\tbuild_m_component_ref, convert_member_func_to_ptr):\n+\tAdd tsubst_flags_t parameter.\n+\t* typeck.c (cp_default_conversion): Add.\n+\t(decay_conversion, default_conversion,\n+\tget_member_function_from_ptrfunc, convert_member_func_to_ptr):\n+\tAdd tsubst_flags_t parameter and use it throughout.\n+\t(cp_build_indirect_ref, cp_build_array_ref,\n+\tcp_build_function_call_vec, convert_arguments, build_x_binary_op,\n+\tcp_build_binary_op, cp_build_unary_op, build_reinterpret_cast_1,\n+\tbuild_const_cast_1, expand_ptrmemfunc_cst,\n+\tconvert_for_initialization): Adjust.\n+\t* init.c (build_vec_init): Adjust.\n+\t* decl.c (grok_reference_init, get_atexit_node): Likewise.\n+\t* rtti.c (build_dynamic_cast_1, tinfo_base_init): Likewise.\n+\t* except.c (build_throw): Likewise.\n+\t* typeck2.c (build_x_arrow): Likewise.\n+\t(build_m_component_ref): Add tsubst_flags_t parameter and\n+\tuse it throughout.\n+\t* pt.c (convert_nontype_argument): Adjust.\n+\t* semantics.c (finish_asm_stmt, maybe_add_lambda_conv_op): Likewise.\n+\t* decl2.c (build_offset_ref_call_from_tree): Likewise.\n+\t* call.c (build_addr_func): Add tsubst_flags_t parameter and\n+\tuse it throughout.\n+\t(build_call_a, build_conditional_expr_1, build_new_op_1,\n+\tconvert_like_real, convert_arg_to_ellipsis, build_over_call,\n+\tbuild_special_member_call): Adjust.\n+\t* cvt.c (cp_convert_to_pointer, force_rvalue,\n+\tbuild_expr_type_conversion): Likewise.\n+\n 2012-04-17  Tom de Vries  <tom@codesourcery.com>\n \n \t* cp-gimplify.c (begin_bc_block): Add location parameter and use as"}, {"sha": "6adf654278ff6f53d1c0d01d021978cb08b0129f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=89fcabafa13d82c44c87b745d08de04386c5b15f", "patch": "@@ -263,7 +263,7 @@ check_dtor_name (tree basetype, tree name)\n    pointer-to-member function.  */\n \n tree\n-build_addr_func (tree function)\n+build_addr_func (tree function, tsubst_flags_t complain)\n {\n   tree type = TREE_TYPE (function);\n \n@@ -275,12 +275,13 @@ build_addr_func (tree function)\n \t{\n \t  tree object = build_address (TREE_OPERAND (function, 0));\n \t  return get_member_function_from_ptrfunc (&object,\n-\t\t\t\t\t\t   TREE_OPERAND (function, 1));\n+\t\t\t\t\t\t   TREE_OPERAND (function, 1),\n+\t\t\t\t\t\t   complain);\n \t}\n       function = build_address (function);\n     }\n   else\n-    function = decay_conversion (function);\n+    function = decay_conversion (function, complain);\n \n   return function;\n }\n@@ -341,7 +342,7 @@ build_call_a (tree function, int n, tree *argarray)\n   tree fntype;\n   int i;\n \n-  function = build_addr_func (function);\n+  function = build_addr_func (function, tf_warning_or_error);\n \n   gcc_assert (TYPE_PTR_P (TREE_TYPE (function)));\n   fntype = TREE_TYPE (TREE_TYPE (function));\n@@ -4373,9 +4374,9 @@ build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n \t since it can't have any effect and since decay_conversion\n \t does not handle that case gracefully.  */\n       if (!VOID_TYPE_P (arg2_type))\n-\targ2 = decay_conversion (arg2);\n+\targ2 = decay_conversion (arg2, complain);\n       if (!VOID_TYPE_P (arg3_type))\n-\targ3 = decay_conversion (arg3);\n+\targ3 = decay_conversion (arg3, complain);\n       arg2_type = TREE_TYPE (arg2);\n       arg3_type = TREE_TYPE (arg3);\n \n@@ -5263,7 +5264,7 @@ build_new_op_1 (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n     case MEMBER_REF:\n       return build_m_component_ref (cp_build_indirect_ref (arg1, RO_NULL, \n                                                            complain), \n-                                    arg2);\n+                                    arg2, complain);\n \n       /* The caller will deal with these.  */\n     case ADDR_EXPR:\n@@ -5807,7 +5808,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t/* Build up the initializer_list object.  */\n \ttotype = complete_type (totype);\n \tfield = next_initializable_field (TYPE_FIELDS (totype));\n-\tCONSTRUCTOR_APPEND_ELT (vec, field, decay_conversion (array));\n+\tCONSTRUCTOR_APPEND_ELT (vec, field, decay_conversion (array, complain));\n \tfield = next_initializable_field (DECL_CHAIN (field));\n \tCONSTRUCTOR_APPEND_ELT (vec, field, size_int (len));\n \tnew_ctor = build_constructor (totype, vec);\n@@ -5844,7 +5845,10 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n   switch (convs->kind)\n     {\n     case ck_rvalue:\n-      expr = decay_conversion (expr);\n+      expr = decay_conversion (expr, complain);\n+      if (expr == error_mark_node)\n+\treturn error_mark_node;\n+\n       if (! MAYBE_CLASS_TYPE_P (totype))\n \treturn expr;\n       /* Else fall through.  */\n@@ -5970,7 +5974,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n       }\n \n     case ck_lvalue:\n-      return decay_conversion (expr);\n+      return decay_conversion (expr, complain);\n \n     case ck_qual:\n       /* Warn about deprecated conversion if appropriate.  */\n@@ -6014,7 +6018,7 @@ convert_arg_to_ellipsis (tree arg)\n \n      The lvalue-to-rvalue, array-to-pointer, and function-to-pointer\n      standard conversions are performed.  */\n-  arg = decay_conversion (arg);\n+  arg = decay_conversion (arg, tf_warning_or_error);\n   arg_type = TREE_TYPE (arg);\n   /* [expr.call]\n \n@@ -6341,7 +6345,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n      errors will be deferred until the template is instantiated.  */\n   if (processing_template_decl)\n     {\n-      tree expr;\n+      tree expr, addr;\n       tree return_type;\n       const tree *argarray;\n       unsigned int nargs;\n@@ -6363,9 +6367,12 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t    alcarray[ix + 1] = arg;\n \t  argarray = alcarray;\n \t}\n-      expr = build_call_array_loc (input_location,\n-\t\t\t\t   return_type, build_addr_func (fn), nargs,\n-\t\t\t\t   argarray);\n+\n+      addr = build_addr_func (fn, complain);\n+      if (addr == error_mark_node)\n+\treturn error_mark_node;\n+      expr = build_call_array_loc (input_location, return_type,\n+\t\t\t\t   addr, nargs, argarray);\n       if (TREE_THIS_VOLATILE (fn) && cfun)\n \tcurrent_function_returns_abnormally = 1;\n       return convert_from_reference (expr);\n@@ -6782,7 +6789,11 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       TREE_TYPE (fn) = t;\n     }\n   else\n-    fn = build_addr_func (fn);\n+    {\n+      fn = build_addr_func (fn, complain);\n+      if (fn == error_mark_node)\n+\treturn error_mark_node;\n+    }\n \n   return build_cxx_call (fn, nargs, argarray);\n }\n@@ -7003,7 +7014,9 @@ build_special_member_call (tree instance, tree name, VEC(tree,gc) **args,\n \t or destructor, then we fetch the VTT directly.\n \t Otherwise, we look it up using the VTT we were given.  */\n       vtt = DECL_CHAIN (CLASSTYPE_VTABLES (current_class_type));\n-      vtt = decay_conversion (vtt);\n+      vtt = decay_conversion (vtt, complain);\n+      if (vtt == error_mark_node)\n+\treturn error_mark_node;\n       vtt = build3 (COND_EXPR, TREE_TYPE (vtt),\n \t\t    build2 (EQ_EXPR, boolean_type_node,\n \t\t\t    current_in_charge_parm, integer_zero_node),"}, {"sha": "284a634c9062707274024facd811007828221918", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=89fcabafa13d82c44c87b745d08de04386c5b15f", "patch": "@@ -4854,7 +4854,7 @@ extern bool check_dtor_name\t\t\t(tree, tree);\n \n extern tree build_conditional_expr\t\t(tree, tree, tree, \n                                                  tsubst_flags_t);\n-extern tree build_addr_func\t\t\t(tree);\n+extern tree build_addr_func\t\t\t(tree, tsubst_flags_t);\n extern void set_flags_from_callee\t\t(tree);\n extern tree build_call_a\t\t\t(tree, int, tree*);\n extern tree build_call_n\t\t\t(tree, int, ...);\n@@ -5782,7 +5782,7 @@ extern tree cxx_sizeof_or_alignof_type\t\t(tree, enum tree_code, bool);\n extern tree cxx_sizeof_nowarn                   (tree);\n extern tree is_bitfield_expr_with_lowered_type  (const_tree);\n extern tree unlowered_expr_type                 (const_tree);\n-extern tree decay_conversion\t\t\t(tree);\n+extern tree decay_conversion\t\t\t(tree, tsubst_flags_t);\n extern tree build_class_member_access_expr      (tree, tree, tree, bool,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree finish_class_member_access_expr     (tree, tree, bool, \n@@ -5794,7 +5794,7 @@ extern tree cp_build_indirect_ref\t\t(tree, ref_operator,\n extern tree build_array_ref\t\t\t(location_t, tree, tree);\n extern tree cp_build_array_ref\t\t\t(location_t, tree, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n-extern tree get_member_function_from_ptrfunc\t(tree *, tree);\n+extern tree get_member_function_from_ptrfunc\t(tree *, tree, tsubst_flags_t);\n extern tree cp_build_function_call              (tree, tree, tsubst_flags_t);\n extern tree cp_build_function_call_nary         (tree, tsubst_flags_t, ...)\n \t\t\t\t\t\tATTRIBUTE_SENTINEL;\n@@ -5865,7 +5865,7 @@ extern tree build_nop\t\t\t\t(tree, tree);\n extern tree non_reference\t\t\t(tree);\n extern tree lookup_anon_field\t\t\t(tree, tree);\n extern bool invalid_nonstatic_memfn_p\t\t(const_tree, tsubst_flags_t);\n-extern tree convert_member_func_to_ptr\t\t(tree, tree);\n+extern tree convert_member_func_to_ptr\t\t(tree, tree, tsubst_flags_t);\n extern tree convert_ptrmem\t\t\t(tree, tree, bool, bool,\n \t\t\t\t\t\t tsubst_flags_t);\n extern int lvalue_or_else\t\t\t(tree, enum lvalue_use,\n@@ -5895,7 +5895,7 @@ extern tree digest_init\t\t\t\t(tree, tree, tsubst_flags_t);\n extern tree digest_init_flags\t\t\t(tree, tree, int);\n extern tree build_scoped_ref\t\t\t(tree, tree, tree *);\n extern tree build_x_arrow\t\t\t(tree, tsubst_flags_t);\n-extern tree build_m_component_ref\t\t(tree, tree);\n+extern tree build_m_component_ref\t\t(tree, tree, tsubst_flags_t);\n extern tree build_functional_cast\t\t(tree, tree, tsubst_flags_t);\n extern tree add_exception_specifier\t\t(tree, tree, int);\n extern tree merge_exception_specifiers\t\t(tree, tree, tree);"}, {"sha": "09a589efd02e9ab008dc398d8c0808131b7802c0", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=89fcabafa13d82c44c87b745d08de04386c5b15f", "patch": "@@ -1,7 +1,7 @@\n /* Language-level data type conversion for GNU C++.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n-   2011 Free Software Foundation, Inc.\n+   2011, 2012 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GCC.\n@@ -109,7 +109,7 @@ cp_convert_to_pointer (tree type, tree expr)\n     {\n       if (TYPE_PTRMEMFUNC_P (intype)\n \t  || TREE_CODE (intype) == METHOD_TYPE)\n-\treturn convert_member_func_to_ptr (type, expr);\n+\treturn convert_member_func_to_ptr (type, expr, tf_warning_or_error);\n       if (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n \treturn build_nop (type, expr);\n       intype = TREE_TYPE (expr);\n@@ -188,7 +188,8 @@ cp_convert_to_pointer (tree type, tree expr)\n \t    {\n \t      tree object = TREE_OPERAND (expr, 0);\n \t      return get_member_function_from_ptrfunc (&object,\n-\t\t\t\t\t\t       TREE_OPERAND (expr, 1));\n+\t\t\t\t\t\t       TREE_OPERAND (expr, 1),\n+\t\t\t\t\t\t       tf_warning_or_error);\n \t    }\n \t}\n       error (\"cannot convert %qE from type %qT to type %qT\",\n@@ -550,7 +551,7 @@ force_rvalue (tree expr, tsubst_flags_t complain)\n       expr = build_cplus_new (type, expr, complain);\n     }\n   else\n-    expr = decay_conversion (expr);\n+    expr = decay_conversion (expr, complain);\n \n   return expr;\n }\n@@ -1495,7 +1496,8 @@ build_expr_type_conversion (int desires, tree expr, bool complain)\n \n       case FUNCTION_TYPE:\n       case ARRAY_TYPE:\n-\treturn (desires & WANT_POINTER) ? decay_conversion (expr)\n+\treturn (desires & WANT_POINTER) ? decay_conversion (expr,\n+\t\t\t\t\t\t\t    tf_warning_or_error)\n \t\t\t\t\t: NULL_TREE;\n \n       case COMPLEX_TYPE:"}, {"sha": "cfab4e206628fe05381884e97bd7e059f463e154", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=89fcabafa13d82c44c87b745d08de04386c5b15f", "patch": "@@ -4668,7 +4668,7 @@ grok_reference_init (tree decl, tree type, tree init, int flags)\n   if (TREE_CODE (TREE_TYPE (type)) != ARRAY_TYPE\n       && TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE)\n     /* Note: default conversion is only called in very special cases.  */\n-    init = decay_conversion (init);\n+    init = decay_conversion (init, tf_warning_or_error);\n \n   /* Convert INIT to the reference type TYPE.  This may involve the\n      creation of a temporary, whose lifetime must be the same as that\n@@ -6535,7 +6535,7 @@ get_atexit_node (void)\n   atexit_fndecl = build_library_fn_ptr (name, fn_type);\n   mark_used (atexit_fndecl);\n   pop_lang_context ();\n-  atexit_node = decay_conversion (atexit_fndecl);\n+  atexit_node = decay_conversion (atexit_fndecl, tf_warning_or_error);\n \n   return atexit_node;\n }"}, {"sha": "a190aee5d5789e00de79ce94968252bbff357efd", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=89fcabafa13d82c44c87b745d08de04386c5b15f", "patch": "@@ -1,7 +1,7 @@\n /* Process declarations and variables for C++ compiler.\n    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010,\n-   2011 Free Software Foundation, Inc.\n+   2011, 2012 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GCC.\n@@ -4175,7 +4175,8 @@ build_offset_ref_call_from_tree (tree fn, VEC(tree,gc) **args)\n     {\n       tree object_addr = cp_build_addr_expr (object, tf_warning_or_error);\n       fn = TREE_OPERAND (fn, 1);\n-      fn = get_member_function_from_ptrfunc (&object_addr, fn);\n+      fn = get_member_function_from_ptrfunc (&object_addr, fn,\n+\t\t\t\t\t     tf_warning_or_error);\n       VEC_safe_insert (tree, gc, *args, 0, object_addr);\n     }\n "}, {"sha": "d39cfa6abd335bb9402f544f2e16a66d3024f63c", "filename": "gcc/cp/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=89fcabafa13d82c44c87b745d08de04386c5b15f", "patch": "@@ -1,6 +1,6 @@\n /* Handle exceptional things in C++.\n    Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010\n+   2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2012\n    Free Software Foundation, Inc.\n    Contributed by Michael Tiemann <tiemann@cygnus.com>\n    Rewritten by Mike Stump <mrs@cygnus.com>, based upon an\n@@ -850,7 +850,7 @@ build_throw (tree exp)\n \t}\n       else\n \t{\n-\t  tmp = decay_conversion (exp);\n+\t  tmp = decay_conversion (exp, tf_warning_or_error);\n \t  if (tmp == error_mark_node)\n \t    return error_mark_node;\n \t  exp = build2 (INIT_EXPR, temp_type, object, tmp);"}, {"sha": "d4c357facd728b33df2556e452761a27e3ccec44", "filename": "gcc/cp/init.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=89fcabafa13d82c44c87b745d08de04386c5b15f", "patch": "@@ -1,7 +1,7 @@\n /* Handle initialization things in C++.\n    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n-   2011 Free Software Foundation, Inc.\n+   2011, 2012 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GCC.\n@@ -3194,7 +3194,10 @@ build_vec_init (tree base, tree maxindex, tree init,\n   if (TREE_CODE (atype) == ARRAY_TYPE)\n     {\n       ptype = build_pointer_type (type);\n-      base = cp_convert (ptype, decay_conversion (base));\n+      base = decay_conversion (base, complain);\n+      if (base == error_mark_node)\n+\treturn error_mark_node;\n+      base = cp_convert (ptype, base);\n     }\n   else\n     ptype = atype;\n@@ -3243,7 +3246,9 @@ build_vec_init (tree base, tree maxindex, tree init,\n     {\n       if (lvalue_kind (init) & clk_rvalueref)\n \txvalue = true;\n-      base2 = decay_conversion (init);\n+      base2 = decay_conversion (init, complain);\n+      if (base2 == error_mark_node)\n+\treturn error_mark_node;\n       itype = TREE_TYPE (base2);\n       base2 = get_temp_regvar (itype, base2);\n       itype = TREE_TYPE (itype);"}, {"sha": "907e0c5fecd6bc8bafc00f5b775876561fdb7f3b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=89fcabafa13d82c44c87b745d08de04386c5b15f", "patch": "@@ -5692,7 +5692,11 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n      value_dependent_expression_p.  */\n   if (TYPE_PTROBV_P (type)\n       && TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE)\n-    expr = decay_conversion (expr);\n+    {\n+      expr = decay_conversion (expr, complain);\n+      if (expr == error_mark_node)\n+\treturn error_mark_node;\n+    }\n \n   /* If we are in a template, EXPR may be non-dependent, but still\n      have a syntactic, rather than semantic, form.  For example, EXPR\n@@ -5900,7 +5904,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t    }\n \t}\n \n-      expr = decay_conversion (expr);\n+      expr = decay_conversion (expr, complain);\n       if (expr == error_mark_node)\n \treturn error_mark_node;\n \n@@ -5985,7 +5989,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t context information to decay the pointer.  */\n       if (!type_unknown_p (expr_type))\n \t{\n-\t  expr = decay_conversion (expr);\n+\t  expr = decay_conversion (expr, complain);\n \t  if (expr == error_mark_node)\n \t    return error_mark_node;\n \t}"}, {"sha": "9242764849783be19ea6081ee5960abcd5766c8e", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=89fcabafa13d82c44c87b745d08de04386c5b15f", "patch": "@@ -551,7 +551,7 @@ build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n \n   if (tc == POINTER_TYPE)\n     {\n-      expr = decay_conversion (expr);\n+      expr = decay_conversion (expr, complain);\n       exprtype = TREE_TYPE (expr);\n \n       /* If T is a pointer type, v shall be an rvalue of a pointer to\n@@ -936,7 +936,8 @@ tinfo_base_init (tinfo_s *ti, tree target)\n \n   v = VEC_alloc (constructor_elt, gc, 2);\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, vtable_ptr);\n-  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, decay_conversion (name_decl));\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n+\t\t\t  decay_conversion (name_decl, tf_warning_or_error));\n \n   init = build_constructor (init_list_type_node, v);\n   TREE_CONSTANT (init) = 1;"}, {"sha": "a621f25a4f48709ef27bf280fced4309047305e5", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=89fcabafa13d82c44c87b745d08de04386c5b15f", "patch": "@@ -1382,7 +1382,7 @@ finish_asm_stmt (int volatile_p, tree string, tree output_operands,\n       for (i = 0, t = input_operands; t; ++i, t = TREE_CHAIN (t))\n \t{\n \t  constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));\n-\t  operand = decay_conversion (TREE_VALUE (t));\n+\t  operand = decay_conversion (TREE_VALUE (t), tf_warning_or_error);\n \n \t  /* If the type of the operand hasn't been determined (e.g.,\n \t     because it involves an overloaded function), then issue\n@@ -9365,7 +9365,7 @@ maybe_add_lambda_conv_op (tree type)\n   body = begin_function_body ();\n   compound_stmt = begin_compound_stmt (0);\n \n-  finish_return_stmt (decay_conversion (statfn));\n+  finish_return_stmt (decay_conversion (statfn, tf_warning_or_error));\n \n   finish_compound_stmt (compound_stmt);\n   finish_function_body (body);"}, {"sha": "01fea6f930c837aa5110ff108c8634a4ac8c8b5f", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 103, "deletions": 50, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=89fcabafa13d82c44c87b745d08de04386c5b15f", "patch": "@@ -1818,7 +1818,7 @@ unlowered_expr_type (const_tree exp)\n    that the return value is no longer an lvalue.  */\n \n tree\n-decay_conversion (tree exp)\n+decay_conversion (tree exp, tsubst_flags_t complain)\n {\n   tree type;\n   enum tree_code code;\n@@ -1832,7 +1832,8 @@ decay_conversion (tree exp)\n   exp = resolve_nondeduced_context (exp);\n   if (type_unknown_p (exp))\n     {\n-      cxx_incomplete_type_error (exp, TREE_TYPE (exp));\n+      if (complain & tf_error)\n+\tcxx_incomplete_type_error (exp, TREE_TYPE (exp));\n       return error_mark_node;\n     }\n \n@@ -1851,13 +1852,14 @@ decay_conversion (tree exp)\n   code = TREE_CODE (type);\n   if (code == VOID_TYPE)\n     {\n-      error (\"void value not ignored as it ought to be\");\n+      if (complain & tf_error)\n+\terror (\"void value not ignored as it ought to be\");\n       return error_mark_node;\n     }\n-  if (invalid_nonstatic_memfn_p (exp, tf_warning_or_error))\n+  if (invalid_nonstatic_memfn_p (exp, complain))\n     return error_mark_node;\n   if (code == FUNCTION_TYPE || is_overloaded_fn (exp))\n-    return cp_build_addr_expr (exp, tf_warning_or_error);\n+    return cp_build_addr_expr (exp, complain);\n   if (code == ARRAY_TYPE)\n     {\n       tree adr;\n@@ -1869,15 +1871,18 @@ decay_conversion (tree exp)\n \n       if (TREE_CODE (exp) == COMPOUND_EXPR)\n \t{\n-\t  tree op1 = decay_conversion (TREE_OPERAND (exp, 1));\n+\t  tree op1 = decay_conversion (TREE_OPERAND (exp, 1), complain);\n+\t  if (op1 == error_mark_node)\n+            return error_mark_node;\n \t  return build2 (COMPOUND_EXPR, TREE_TYPE (op1),\n \t\t\t TREE_OPERAND (exp, 0), op1);\n \t}\n \n       if (!lvalue_p (exp)\n \t  && ! (TREE_CODE (exp) == CONSTRUCTOR && TREE_STATIC (exp)))\n \t{\n-\t  error (\"invalid use of non-lvalue array\");\n+\t  if (complain & tf_error)\n+\t    error (\"invalid use of non-lvalue array\");\n \t  return error_mark_node;\n \t}\n \n@@ -1892,7 +1897,7 @@ decay_conversion (tree exp)\n \t}\n       /* This way is better for a COMPONENT_REF since it can\n \t simplify the offset for a component.  */\n-      adr = cp_build_addr_expr (exp, tf_warning_or_error);\n+      adr = cp_build_addr_expr (exp, complain);\n       return cp_convert (ptrtype, adr);\n     }\n \n@@ -1931,8 +1936,8 @@ decay_conversion (tree exp)\n    applied to both operands to a binary operator before determining\n    what additional conversions should apply.  */\n \n-tree\n-default_conversion (tree exp)\n+static tree\n+cp_default_conversion (tree exp, tsubst_flags_t complain)\n {\n   /* Check for target-specific promotions.  */\n   tree promoted_type = targetm.promoted_type (TREE_TYPE (exp));\n@@ -1944,11 +1949,19 @@ default_conversion (tree exp)\n   else if (INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (TREE_TYPE (exp)))\n     exp = perform_integral_promotions (exp);\n   /* Perform the other conversions.  */\n-  exp = decay_conversion (exp);\n+  exp = decay_conversion (exp, complain);\n \n   return exp;\n }\n \n+/* C version.  */\n+\n+tree\n+default_conversion (tree exp)\n+{\n+  return cp_default_conversion (exp, tf_warning_or_error);\n+}\n+\n /* EXPR is an expression with an integral or enumeration type.\n    Perform the integral promotions in [conv.prom], and return the\n    converted value.  */\n@@ -2758,14 +2771,14 @@ cp_build_indirect_ref (tree ptr, ref_operator errorstring,\n {\n   tree pointer, type;\n \n-  if (ptr == error_mark_node)\n-    return error_mark_node;\n-\n   if (ptr == current_class_ptr)\n     return current_class_ref;\n \n   pointer = (TREE_CODE (TREE_TYPE (ptr)) == REFERENCE_TYPE\n-\t     ? ptr : decay_conversion (ptr));\n+\t     ? ptr : decay_conversion (ptr, complain));\n+  if (pointer == error_mark_node)\n+    return error_mark_node;\n+\n   type = TREE_TYPE (pointer);\n \n   if (POINTER_TYPE_P (type))\n@@ -2982,8 +2995,8 @@ cp_build_array_ref (location_t loc, tree array, tree idx,\n     }\n \n   {\n-    tree ar = default_conversion (array);\n-    tree ind = default_conversion (idx);\n+    tree ar = cp_default_conversion (array, complain);\n+    tree ind = cp_default_conversion (idx, complain);\n \n     /* Put the integer in IND to simplify error checking.  */\n     if (TREE_CODE (TREE_TYPE (ar)) == INTEGER_TYPE)\n@@ -2993,8 +3006,8 @@ cp_build_array_ref (location_t loc, tree array, tree idx,\n \tind = temp;\n       }\n \n-    if (ar == error_mark_node)\n-      return ar;\n+    if (ar == error_mark_node || ind == error_mark_node)\n+      return error_mark_node;\n \n     if (TREE_CODE (TREE_TYPE (ar)) != POINTER_TYPE)\n       {\n@@ -3040,7 +3053,8 @@ build_array_ref (location_t loc, tree array, tree idx)\n    later has the right member.  */\n \n tree\n-get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n+get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function,\n+\t\t\t\t  tsubst_flags_t complain)\n {\n   if (TREE_CODE (function) == OFFSET_REF)\n     function = TREE_OPERAND (function, 1);\n@@ -3059,13 +3073,14 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n \t      /* Extracting the function address from a pmf is only\n \t\t allowed with -Wno-pmf-conversions. It only works for\n \t\t pmf constants.  */\n-\t      e1 = build_addr_func (PTRMEM_CST_MEMBER (function));\n+\t      e1 = build_addr_func (PTRMEM_CST_MEMBER (function), complain);\n \t      e1 = convert (fntype, e1);\n \t      return e1;\n \t    }\n \t  else\n \t    {\n-\t      error (\"object missing in use of %qE\", function);\n+\t      if (complain & tf_error)\n+\t\terror (\"object missing in use of %qE\", function);\n \t      return error_mark_node;\n \t    }\n \t}\n@@ -3085,25 +3100,32 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n \tcase ptrmemfunc_vbit_in_pfn:\n \t  e1 = cp_build_binary_op (input_location,\n \t\t\t\t   BIT_AND_EXPR, idx, integer_one_node,\n-\t\t\t\t   tf_warning_or_error);\n+\t\t\t\t   complain);\n \t  idx = cp_build_binary_op (input_location,\n \t\t\t\t    MINUS_EXPR, idx, integer_one_node,\n-\t\t\t\t    tf_warning_or_error);\n+\t\t\t\t    complain);\n+\t  if (idx == error_mark_node)\n+\t    return error_mark_node;\n \t  break;\n \n \tcase ptrmemfunc_vbit_in_delta:\n \t  e1 = cp_build_binary_op (input_location,\n \t\t\t\t   BIT_AND_EXPR, delta, integer_one_node,\n-\t\t\t\t   tf_warning_or_error);\n+\t\t\t\t   complain);\n \t  delta = cp_build_binary_op (input_location,\n \t\t\t\t      RSHIFT_EXPR, delta, integer_one_node,\n-\t\t\t\t      tf_warning_or_error);\n+\t\t\t\t      complain);\n+\t  if (delta == error_mark_node)\n+\t    return error_mark_node;\n \t  break;\n \n \tdefault:\n \t  gcc_unreachable ();\n \t}\n \n+      if (e1 == error_mark_node)\n+\treturn error_mark_node;\n+\n       /* Convert down to the right base before using the instance.  A\n \t special case is that in a pointer to member of class C, C may\n \t be incomplete.  In that case, the function will of course be\n@@ -3117,7 +3139,7 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n \t  basetype = lookup_base (TREE_TYPE (TREE_TYPE (instance_ptr)),\n \t\t\t\t  basetype, ba_check, NULL);\n \t  instance_ptr = build_base_path (PLUS_EXPR, instance_ptr, basetype,\n-\t\t\t\t\t  1, tf_warning_or_error);\n+\t\t\t\t\t  1, complain);\n \t  if (instance_ptr == error_mark_node)\n \t    return error_mark_node;\n \t}\n@@ -3130,25 +3152,32 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n       /* Next extract the vtable pointer from the object.  */\n       vtbl = build1 (NOP_EXPR, build_pointer_type (vtbl_ptr_type_node),\n \t\t     instance_ptr);\n-      vtbl = cp_build_indirect_ref (vtbl, RO_NULL, tf_warning_or_error);\n+      vtbl = cp_build_indirect_ref (vtbl, RO_NULL, complain);\n+      if (vtbl == error_mark_node)\n+\treturn error_mark_node;\n+\n       /* If the object is not dynamic the access invokes undefined\n \t behavior.  As it is not executed in this case silence the\n \t spurious warnings it may provoke.  */\n       TREE_NO_WARNING (vtbl) = 1;\n \n       /* Finally, extract the function pointer from the vtable.  */\n       e2 = fold_build_pointer_plus_loc (input_location, vtbl, idx);\n-      e2 = cp_build_indirect_ref (e2, RO_NULL, tf_warning_or_error);\n+      e2 = cp_build_indirect_ref (e2, RO_NULL, complain);\n+      if (e2 == error_mark_node)\n+\treturn error_mark_node;\n       TREE_CONSTANT (e2) = 1;\n \n       /* When using function descriptors, the address of the\n \t vtable entry is treated as a function pointer.  */\n       if (TARGET_VTABLE_USES_DESCRIPTORS)\n \te2 = build1 (NOP_EXPR, TREE_TYPE (e2),\n-\t\t     cp_build_addr_expr (e2, tf_warning_or_error));\n+\t\t     cp_build_addr_expr (e2, complain));\n \n       e2 = fold_convert (TREE_TYPE (e3), e2);\n-      e1 = build_conditional_expr (e1, e2, e3, tf_warning_or_error);\n+      e1 = build_conditional_expr (e1, e2, e3, complain);\n+      if (e1 == error_mark_node)\n+\treturn error_mark_node;\n \n       /* Make sure this doesn't get evaluated first inside one of the\n \t branches of the COND_EXPR.  */\n@@ -3261,13 +3290,13 @@ cp_build_function_call_vec (tree function, VEC(tree,gc) **params,\n \tpedwarn (input_location, OPT_pedantic, \n \t\t \"ISO C++ forbids calling %<::main%> from within program\");\n \n-      function = build_addr_func (function);\n+      function = build_addr_func (function, complain);\n     }\n   else\n     {\n       fndecl = NULL_TREE;\n \n-      function = build_addr_func (function);\n+      function = build_addr_func (function, complain);\n     }\n \n   if (function == error_mark_node)\n@@ -3432,7 +3461,7 @@ convert_arguments (tree typelist, VEC(tree,gc) **values, tree fndecl,\n \t  if (TREE_CODE (TREE_TYPE (val)) == ARRAY_TYPE\n \t      || TREE_CODE (TREE_TYPE (val)) == FUNCTION_TYPE\n \t      || TREE_CODE (TREE_TYPE (val)) == METHOD_TYPE)\n-\t    val = decay_conversion (val);\n+\t    val = decay_conversion (val, complain);\n \t}\n \n       if (val == error_mark_node)\n@@ -3559,7 +3588,7 @@ build_x_binary_op (enum tree_code code, tree arg1, enum tree_code arg1_code,\n     }\n \n   if (code == DOTSTAR_EXPR)\n-    expr = build_m_component_ref (arg1, arg2);\n+    expr = build_m_component_ref (arg1, arg2, complain);\n   else\n     expr = build_new_op (code, LOOKUP_NORMAL, arg1, arg2, NULL_TREE,\n \t\t\t overload, complain);\n@@ -3723,16 +3752,16 @@ cp_build_binary_op (location_t location,\n       || code == TRUTH_XOR_EXPR)\n     {\n       if (!really_overloaded_fn (op0) && !VOID_TYPE_P (TREE_TYPE (op0)))\n-\top0 = decay_conversion (op0);\n+\top0 = decay_conversion (op0, complain);\n       if (!really_overloaded_fn (op1) && !VOID_TYPE_P (TREE_TYPE (op1)))\n-\top1 = decay_conversion (op1);\n+\top1 = decay_conversion (op1, complain);\n     }\n   else\n     {\n       if (!really_overloaded_fn (op0) && !VOID_TYPE_P (TREE_TYPE (op0)))\n-\top0 = default_conversion (op0);\n+\top0 = cp_default_conversion (op0, complain);\n       if (!really_overloaded_fn (op1) && !VOID_TYPE_P (TREE_TYPE (op1)))\n-\top1 = default_conversion (op1);\n+\top1 = cp_default_conversion (op1, complain);\n     }\n \n   /* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */\n@@ -5129,7 +5158,11 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n \t{\n \t  code = CONJ_EXPR;\n \t  if (!noconvert)\n-\t    arg = default_conversion (arg);\n+\t    {\n+\t      arg = cp_default_conversion (arg, complain);\n+\t      if (arg == error_mark_node)\n+\t\treturn error_mark_node;\n+\t    }\n \t}\n       else if (!(arg = build_expr_type_conversion (WANT_INT | WANT_ENUM\n \t\t\t\t\t\t   | WANT_VECTOR_OR_COMPLEX,\n@@ -5143,15 +5176,23 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n       if (!(arg = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, arg, true)))\n \terrstring = _(\"wrong type argument to abs\");\n       else if (!noconvert)\n-\targ = default_conversion (arg);\n+\t{\n+\t  arg = cp_default_conversion (arg, complain);\n+\t  if (arg == error_mark_node)\n+\t    return error_mark_node;\n+\t}\n       break;\n \n     case CONJ_EXPR:\n       /* Conjugating a real value is a no-op, but allow it anyway.  */\n       if (!(arg = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, arg, true)))\n \terrstring = _(\"wrong type argument to conjugation\");\n       else if (!noconvert)\n-\targ = default_conversion (arg);\n+\t{\n+\t  arg = cp_default_conversion (arg, complain);\n+\t  if (arg == error_mark_node)\n+\t    return error_mark_node;\n+\t}\n       break;\n \n     case TRUTH_NOT_EXPR:\n@@ -6129,7 +6170,7 @@ build_static_cast (tree type, tree expr, tsubst_flags_t complain)\n    converted expression.  */\n \n tree\n-convert_member_func_to_ptr (tree type, tree expr)\n+convert_member_func_to_ptr (tree type, tree expr, tsubst_flags_t complain)\n {\n   tree intype;\n   tree decl;\n@@ -6138,21 +6179,27 @@ convert_member_func_to_ptr (tree type, tree expr)\n   gcc_assert (TYPE_PTRMEMFUNC_P (intype)\n \t      || TREE_CODE (intype) == METHOD_TYPE);\n \n+  if (!(complain & tf_warning_or_error))\n+    return error_mark_node;\n+\n   if (pedantic || warn_pmf2ptr)\n     pedwarn (input_location, pedantic ? OPT_pedantic : OPT_Wpmf_conversions,\n \t     \"converting from %qT to %qT\", intype, type);\n \n   if (TREE_CODE (intype) == METHOD_TYPE)\n-    expr = build_addr_func (expr);\n+    expr = build_addr_func (expr, complain);\n   else if (TREE_CODE (expr) == PTRMEM_CST)\n     expr = build_address (PTRMEM_CST_MEMBER (expr));\n   else\n     {\n       decl = maybe_dummy_object (TYPE_PTRMEM_CLASS_TYPE (intype), 0);\n       decl = build_address (decl);\n-      expr = get_member_function_from_ptrfunc (&decl, expr);\n+      expr = get_member_function_from_ptrfunc (&decl, expr, complain);\n     }\n \n+  if (expr == error_mark_node)\n+    return error_mark_node;\n+\n   return build_nop (type, expr);\n }\n \n@@ -6230,12 +6277,12 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n       && TYPE_PTR_P (type)\n       && (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n \t  || VOID_TYPE_P (TREE_TYPE (type))))\n-    return convert_member_func_to_ptr (type, expr);\n+    return convert_member_func_to_ptr (type, expr, complain);\n \n   /* If the cast is not to a reference type, the lvalue-to-rvalue,\n      array-to-pointer, and function-to-pointer conversions are\n      performed.  */\n-  expr = decay_conversion (expr);\n+  expr = decay_conversion (expr, complain);\n \n   /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n      Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */\n@@ -6474,12 +6521,17 @@ build_const_cast_1 (tree dst_type, tree expr, tsubst_flags_t complain,\n \t  if (reference_type)\n \t    {\n \t      expr = cp_build_addr_expr (expr, complain);\n+\t      if (expr == error_mark_node)\n+\t\treturn error_mark_node;\n \t      expr = build_nop (reference_type, expr);\n \t      return convert_from_reference (expr);\n \t    }\n \t  else\n \t    {\n-\t      expr = decay_conversion (expr);\n+\t      expr = decay_conversion (expr, complain);\n+\t      if (expr == error_mark_node)\n+\t\treturn error_mark_node;\n+\n \t      /* build_c_cast puts on a NOP_EXPR to make the result not an\n \t\t lvalue.  Strip such NOP_EXPRs if VALUE is being used in\n \t\t non-lvalue context.  */\n@@ -7333,7 +7385,8 @@ expand_ptrmemfunc_cst (tree cst, tree *delta, tree *pfn)\n \t\t\t\t /*c_cast_p=*/0, tf_warning_or_error);\n \n   if (!DECL_VIRTUAL_P (fn))\n-    *pfn = convert (TYPE_PTRMEMFUNC_FN_TYPE (type), build_addr_func (fn));\n+    *pfn = convert (TYPE_PTRMEMFUNC_FN_TYPE (type),\n+\t\t    build_addr_func (fn, tf_warning_or_error));\n   else\n     {\n       /* If we're dealing with a virtual function, we have to adjust 'this'\n@@ -7667,7 +7720,7 @@ convert_for_initialization (tree exp, tree type, tree rhs, int flags,\n \t  && (TREE_CODE (type) != REFERENCE_TYPE\n \t      || TREE_CODE (TREE_TYPE (type)) != FUNCTION_TYPE))\n       || TREE_CODE (TREE_TYPE (rhs)) == METHOD_TYPE)\n-    rhs = decay_conversion (rhs);\n+    rhs = decay_conversion (rhs, complain);\n \n   rhstype = TREE_TYPE (rhs);\n   coder = TREE_CODE (rhstype);"}, {"sha": "af72851a2efd51d7e52215efd3c56a074ce1b500", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=89fcabafa13d82c44c87b745d08de04386c5b15f", "patch": "@@ -1,7 +1,8 @@\n /* Report error messages, build initializers, and perform\n    some front-end optimizations for C++ compiler.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n+   1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011,\n+   2012\n    Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n@@ -1528,7 +1529,7 @@ build_x_arrow (tree expr, tsubst_flags_t complain)\n \tlast_rval = convert_from_reference (last_rval);\n     }\n   else\n-    last_rval = decay_conversion (expr);\n+    last_rval = decay_conversion (expr, complain);\n \n   if (TREE_CODE (TREE_TYPE (last_rval)) == POINTER_TYPE)\n     {\n@@ -1557,7 +1558,7 @@ build_x_arrow (tree expr, tsubst_flags_t complain)\n    already been checked out to be of aggregate type.  */\n \n tree\n-build_m_component_ref (tree datum, tree component)\n+build_m_component_ref (tree datum, tree component, tsubst_flags_t complain)\n {\n   tree ptrmem_type;\n   tree objtype;\n@@ -1574,18 +1575,18 @@ build_m_component_ref (tree datum, tree component)\n   ptrmem_type = TREE_TYPE (component);\n   if (!TYPE_PTR_TO_MEMBER_P (ptrmem_type))\n     {\n-      error (\"%qE cannot be used as a member pointer, since it is of \"\n-\t     \"type %qT\",\n-\t     component, ptrmem_type);\n+      if (complain & tf_error)\n+\terror (\"%qE cannot be used as a member pointer, since it is of \"\n+\t       \"type %qT\", component, ptrmem_type);\n       return error_mark_node;\n     }\n \n   objtype = TYPE_MAIN_VARIANT (TREE_TYPE (datum));\n   if (! MAYBE_CLASS_TYPE_P (objtype))\n     {\n-      error (\"cannot apply member pointer %qE to %qE, which is of \"\n-\t     \"non-class type %qT\",\n-\t     component, datum, objtype);\n+      if (complain & tf_error)\n+\terror (\"cannot apply member pointer %qE to %qE, which is of \"\n+\t       \"non-class type %qT\", component, datum, objtype);\n       return error_mark_node;\n     }\n \n@@ -1605,9 +1606,9 @@ build_m_component_ref (tree datum, tree component)\n       if (!binfo)\n \t{\n \tmismatch:\n-\t  error (\"pointer to member type %qT incompatible with object \"\n-\t\t \"type %qT\",\n-\t\t type, objtype);\n+\t  if (complain & tf_error)\n+\t    error (\"pointer to member type %qT incompatible with object \"\n+\t\t   \"type %qT\", type, objtype);\n \t  return error_mark_node;\n \t}\n       else if (binfo == error_mark_node)\n@@ -1631,14 +1632,20 @@ build_m_component_ref (tree datum, tree component)\n \n       /* Convert object to the correct base.  */\n       if (binfo)\n-\tdatum = build_base_path (PLUS_EXPR, datum, binfo, 1,\n-\t\t\t\t tf_warning_or_error);\n+\t{\n+\t  datum = build_base_path (PLUS_EXPR, datum, binfo, 1, complain);\n+\t  if (datum == error_mark_node)\n+\t    return error_mark_node;\n+\t}\n \n       /* Build an expression for \"object + offset\" where offset is the\n \t value stored in the pointer-to-data-member.  */\n       ptype = build_pointer_type (type);\n       datum = fold_build_pointer_plus (fold_convert (ptype, datum), component);\n-      datum = cp_build_indirect_ref (datum, RO_NULL, tf_warning_or_error);\n+      datum = cp_build_indirect_ref (datum, RO_NULL, complain);\n+      if (datum == error_mark_node)\n+\treturn error_mark_node;\n+\n       /* If the object expression was an rvalue, return an rvalue.  */\n       if (!is_lval)\n \tdatum = move (datum);"}, {"sha": "fba4c22ee6a4b7ba31f5ca9a185025d2e83a463f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=89fcabafa13d82c44c87b745d08de04386c5b15f", "patch": "@@ -1,3 +1,9 @@\n+2012-04-18  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/52422\n+\t* g++.dg/cpp0x/sfinae33.C: New.\n+\t* g++.dg/cpp0x/sfinae34.C: Likewise.\n+\n 2012-04-18  Joey Ye  <joey.ye@arm.com>\n \n \t* gcc.target/arm/thumb1-imm.c: Skip it in non-thumb1 target."}, {"sha": "3a5e6f77dfb5589a52dcc5f4edbb88a5f6de8138", "filename": "gcc/testsuite/g++.dg/cpp0x/sfinae33.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae33.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae33.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae33.C?ref=89fcabafa13d82c44c87b745d08de04386c5b15f", "patch": "@@ -0,0 +1,27 @@\n+// PR c++/52422\n+// { dg-options -std=c++11 }\n+\n+template<class T>\n+struct add_rval_ref\n+{\n+  typedef T&& type;\n+};\n+\n+template<>\n+struct add_rval_ref<void>\n+{\n+  typedef void type;\n+};\n+\n+template<class T>\n+typename add_rval_ref<T>::type create();\n+\n+template<class T, \n+  class = decltype(create<T>()())\n+>\n+auto f(int) -> char(&)[1];\n+\n+template<class>\n+auto f(...) -> char(&)[2];\n+\n+static_assert(sizeof(f<void>(0)) != 1, \"\");"}, {"sha": "d5d1ca4646bfaf83ad59e0cf8ee3ac033a4de0e8", "filename": "gcc/testsuite/g++.dg/cpp0x/sfinae34.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae34.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89fcabafa13d82c44c87b745d08de04386c5b15f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae34.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae34.C?ref=89fcabafa13d82c44c87b745d08de04386c5b15f", "patch": "@@ -0,0 +1,27 @@\n+// PR c++/52422\n+// { dg-options -std=c++11 }\n+\n+template<class T>\n+struct add_rval_ref\n+{\n+  typedef T&& type;\n+};\n+\n+template<>\n+struct add_rval_ref<void>\n+{\n+  typedef void type;\n+};\n+\n+template<class T>\n+typename add_rval_ref<T>::type create();\n+\n+template<class T, class U,\n+  class = decltype( (create<T>().*create<U>())() )\n+>\n+auto f(int) -> char(&)[1];\n+\n+template<class, class>\n+auto f(...) -> char(&)[2];\n+\n+static_assert(sizeof(f<void, void>(0)) != 1, \"\");"}]}