{"sha": "28e99c6271f33c9f03eb2fda746b40ab1241e3aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhlOTljNjI3MWYzM2M5ZjAzZWIyZmRhNzQ2YjQwYWIxMjQxZTNhYQ==", "commit": {"author": {"name": "Hans Boehm", "email": "Hans_Boehm@hp.com", "date": "2004-08-12T17:56:32Z"}, "committer": {"name": "Hans Boehm", "email": "hboehm@gcc.gnu.org", "date": "2004-08-12T17:56:32Z"}, "message": "re PR libgcj/16662 (IllegalMonitorStateException in EventQueue.getNextEvent(): possible hash synchronization bug?)\n\n\tPR libgcj/16662\n\t* java/lang/natObject.cc (LOCK_LOG, LOG): Add debug tracing.\n\t(Almost everywhere): add LOG calls, fix, add comments.\n\t(_Jv_MonitorEnter): Replace masking of LOCKED bit with assertion.\n\tAdd explicit check for LOCKED bit in slow case (PR 16662).\n\t(_Jv_MonitorExit): Add casts in debug-only code.\n\tAlways release LOCKED bit before throwing exception.\n\t(_Jv_ObjectCheckMonitor): Lock may be held if lightweight lock\n\tisn't.  Handle easy cases without lock acquisition.\n\t(Object::wait): Use NotifyAll for lock inflation.\n\nFrom-SVN: r85884", "tree": {"sha": "3a7461936a6778ca24c934e4e01f866aaf0a8c78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a7461936a6778ca24c934e4e01f866aaf0a8c78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28e99c6271f33c9f03eb2fda746b40ab1241e3aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28e99c6271f33c9f03eb2fda746b40ab1241e3aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28e99c6271f33c9f03eb2fda746b40ab1241e3aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28e99c6271f33c9f03eb2fda746b40ab1241e3aa/comments", "author": null, "committer": null, "parents": [{"sha": "adf39f8f5f2e1c877fe6b02654e673875c34ddac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adf39f8f5f2e1c877fe6b02654e673875c34ddac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adf39f8f5f2e1c877fe6b02654e673875c34ddac"}], "stats": {"total": 160, "additions": 139, "deletions": 21}, "files": [{"sha": "053ffef084a9863ca954f0ea44bf983a990f1906", "filename": "libjava/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28e99c6271f33c9f03eb2fda746b40ab1241e3aa/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28e99c6271f33c9f03eb2fda746b40ab1241e3aa/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=28e99c6271f33c9f03eb2fda746b40ab1241e3aa", "patch": "@@ -1,3 +1,16 @@\n+2004-08-10  Hans Boehm <Hans.Boehm@hp.com>\n+\n+\tPR libgcj/16662\n+\t* java/lang/natObject.cc (LOCK_LOG, LOG): Add debug tracing.\n+\t(Almost everywhere): add LOG calls, fix, add comments.\n+\t(_Jv_MonitorEnter): Replace masking of LOCKED bit with assertion.\n+\tAdd explicit check for LOCKED bit in slow case (PR 16662).\n+\t(_Jv_MonitorExit): Add casts in debug-only code.\n+\tAlways release LOCKED bit before throwing exception.\n+\t(_Jv_ObjectCheckMonitor): Lock may be held if lightweight lock\n+\tisn't.  Handle easy cases without lock acquisition.\n+\t(Object::wait): Use NotifyAll for lock inflation.\n+\n 2004-08-12  David Daney  <ddaney@avtrex.com>\n \n \t* testsuite/libjava.lang/Process_1.java: New test."}, {"sha": "cb03db97cc0da4fb1ec61e39a1f95840c4fc8c4b", "filename": "libjava/java/lang/natObject.cc", "status": "modified", "additions": 126, "deletions": 21, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28e99c6271f33c9f03eb2fda746b40ab1241e3aa/libjava%2Fjava%2Flang%2FnatObject.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28e99c6271f33c9f03eb2fda746b40ab1241e3aa/libjava%2Fjava%2Flang%2FnatObject.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatObject.cc?ref=28e99c6271f33c9f03eb2fda746b40ab1241e3aa", "patch": "@@ -423,18 +423,31 @@ struct hash_entry {\n   \t\t\t\t// are protected by the lightweight\n   \t\t\t\t// lock itself), and any heavy_monitor\n   \t\t\t\t// structures attached to it.\n-#   define HEAVY\t2\t// There may be heavyweight locks\n-\t\t\t\t// associated with this cache entry.\n+#   define HEAVY\t2\t// Heavyweight locks associated with this\n+  \t\t\t\t// hash entry may be held.\n \t\t\t\t// The lightweight entry is still valid,\n   \t\t\t\t// if the leading bits of the address\n   \t\t\t\t// field are nonzero.\n- \t\t\t\t// Set if heavy_count is > 0 .\n+  \t\t\t\t// If the LOCKED bit is clear, then this is\n+ \t\t\t\t// set exactly when heavy_count is > 0 .\n   \t\t\t\t// Stored redundantly so a single\n   \t\t\t\t// compare-and-swap works in the easy case.\n+  \t\t\t\t// If HEAVY is not set, it is safe to use\n+  \t\t\t\t// an available lightweight lock entry\n+  \t\t\t\t// without checking if there is an existing\n+  \t\t\t\t// heavyweight lock for the same object.\n+  \t\t\t\t// (There may be one, but it won't be held\n+  \t\t\t\t// or waited for.)\n #   define REQUEST_CONVERSION 4 // The lightweight lock is held.  But\n   \t\t\t\t// one or more other threads have tried\n   \t\t\t\t// to acquire the lock, and hence request\n   \t\t\t\t// conversion to heavyweight status.\n+  \t\t\t\t// The heavyweight lock is already allocated.\n+  \t\t\t\t// Threads requesting conversion are\n+  \t\t\t\t// waiting on the condition variable associated\n+  \t\t\t\t// with the heavyweight lock.\n+  \t\t\t\t// Not used for conversion due to\n+  \t\t\t\t// Object.wait() calls.\n #   define FLAGS (LOCKED | HEAVY | REQUEST_CONVERSION)\n   volatile _Jv_ThreadId_t light_thr_id;\n \t\t\t\t// Thr_id of holder of lightweight lock.\n@@ -447,12 +460,19 @@ struct hash_entry {\n   volatile unsigned short light_count;\n \t\t\t\t// Number of times the lightweight lock\n   \t\t\t\t// is held minus one.  Zero if lightweight\n-  \t\t\t\t// lock is not held.\n+  \t\t\t\t// lock is not held.  Only updated by\n+  \t\t\t\t// lightweight lock holder or, in one\n+  \t\t\t\t// case, while holding the LOCKED bit in\n+  \t\t\t\t// a state in which there can be no\n+  \t\t\t\t// lightweight lock holder.\n   unsigned short heavy_count; \t// Total number of times heavyweight locks\n   \t\t\t\t// associated with this hash entry are held\n   \t\t\t\t// or waiting to be acquired.\n   \t\t\t\t// Threads in wait() are included eventhough\n   \t\t\t\t// they have temporarily released the lock.\n+  \t\t\t\t// Protected by LOCKED bit.\n+  \t\t\t\t// Threads requesting conversion to heavyweight\n+  \t\t\t\t// status are also included.\n   struct heavy_lock * heavy_locks;\n   \t\t\t\t// Chain of heavy locks.  Protected\n   \t\t\t\t// by lockbit for he.  Locks may\n@@ -492,13 +512,63 @@ hash_entry light_locks[JV_SYNC_TABLE_SZ];\n      fprintf(stderr, \"lock hash entry = %p, index = %d, address = 0x%lx\\n\"\n \t\t     \"\\tlight_thr_id = 0x%lx, light_count = %d, \"\n \t\t     \"heavy_count = %d\\n\\theavy_locks:\", he,\n-\t\t     he - light_locks, he -> address, he -> light_thr_id,\n+\t\t     he - light_locks, (unsigned long)(he -> address),\n+\t\t     (unsigned long)(he -> light_thr_id),\n \t\t     he -> light_count, he -> heavy_count);\n      print_hl_list(he -> heavy_locks);\n      fprintf(stderr, \"\\n\");\n   }\n #endif /* LOCK_DEBUG */\n \n+#ifdef LOCK_LOG\n+  // Log locking operations.  For debugging only.\n+  // Logging is intended to be as unintrusive as possible.\n+  // Log calls are made after an operation completes, and hence\n+  // may not completely reflect actual synchronization ordering.\n+  // The choice of events to log is currently a bit haphazard.\n+  // The intent is that if we have to track down any other bugs\n+  // inthis code, we extend the logging as appropriate.\n+  typedef enum\n+  {\n+    ACQ_LIGHT, ACQ_LIGHT2, ACQ_HEAVY, ACQ_HEAVY2, PROMOTE, REL_LIGHT,\n+    REL_HEAVY, REQ_CONV, PROMOTE2, WAIT_START, WAIT_END, NOTIFY, NOTIFY_ALL\n+  } event_type;\n+\n+  struct lock_history\n+  {\n+    event_type tp;\n+    obj_addr_t addr;  // Often includes flags.\n+    _Jv_ThreadId_t thr;\n+  };\n+     \n+  const int LOG_SIZE = 128;\t// Power of 2.\n+\n+  lock_history lock_log[LOG_SIZE];\n+\n+  volatile obj_addr_t log_next = 0;\n+  \t\t\t   // Next location in lock_log.\n+  \t\t\t   // Really an int, but we need compare_and_swap.\n+\n+  static void add_log_entry(event_type t, obj_addr_t a, _Jv_ThreadId_t th)\n+  {\n+    obj_addr_t my_entry;\n+    obj_addr_t next_entry;\n+    do\n+      {\n+\tmy_entry = log_next;\n+\tnext_entry = ((my_entry + 1) & (LOG_SIZE - 1));\n+      }\n+    while (!compare_and_swap(&log_next, my_entry, next_entry));\n+    lock_log[my_entry].tp = t;\n+    lock_log[my_entry].addr = a;\n+    lock_log[my_entry].thr = th;\n+  }\n+\n+# define LOG(t, a, th) add_log_entry(t, a, th)\n+#else /* !LOCK_LOG */\n+# define LOG(t, a, th)\n+#endif\n+\n static bool mp = false; // Known multiprocesssor.\n \n // Wait for roughly 2^n units, touching as little memory as possible.\n@@ -656,6 +726,8 @@ heavy_lock_obj_finalization_proc (void *obj, void *cd)\n // Remove all heavy locks on the list.  Note that the only possible way\n // in which a lock may still be in use is if it's in the process of\n // being unlocked.\n+// FIXME:  Why does this unlock the hash entry?  I think that\n+// could now be done more cleanly in MonitorExit.\n static void\n remove_all_heavy (hash_entry *he, obj_addr_t new_address_val)\n {\n@@ -799,6 +871,7 @@ _Jv_MonitorEnter (jobject obj)\n       // Count fields are set correctly.  Heavy_count was also zero,\n       // but can change asynchronously.\n       // This path is hopefully both fast and the most common.\n+      LOG(ACQ_LIGHT, addr, self);\n       return;\n     }\n   address = he -> address;\n@@ -822,15 +895,17 @@ _Jv_MonitorEnter (jobject obj)\n \t}\n       else\n \t{\n+\t  JvAssert(!(address & LOCKED));\n \t  // Lightweight lock is held, but by somone else.\n           // Spin a few times.  This avoids turning this into a heavyweight\n     \t  // lock if the current holder is about to release it.\n+\t  // FIXME: Does this make sense on a uniprocessor, where\n+\t  // it actually yields?  It's probably cheaper to convert.\n           for (unsigned int i = 0; i < N_SPINS; ++i)\n \t    {\n-\t      if ((he -> address & ~LOCKED) != (address & ~LOCKED)) goto retry;\n+\t      if ((he -> address & ~LOCKED) != address) goto retry;\n \t      spin(i);\n             }\n-\t  address &= ~LOCKED;\n \t  if (!compare_and_swap(&(he -> address), address, address | LOCKED ))\n \t    {\n \t      wait_unlocked(he);      \n@@ -845,6 +920,7 @@ _Jv_MonitorEnter (jobject obj)\n \t  JvAssert(he -> address == address | LOCKED );\n \t  release_set(&(he -> address), (address | REQUEST_CONVERSION | HEAVY));\n \t\t\t\t// release lock on he\n+\t  LOG(REQ_CONV, (address | REQUEST_CONVERSION | HEAVY), self);\n \t  while ((he -> address & ~FLAGS) == (address & ~FLAGS))\n \t    {\n \t      // Once converted, the lock has to retain heavyweight\n@@ -862,8 +938,8 @@ _Jv_MonitorEnter (jobject obj)\n         }\n     }\n   obj_addr_t was_heavy = (address & HEAVY);\n-  address &= ~LOCKED;\n-  if (!compare_and_swap(&(he -> address), address, (address | LOCKED )))\n+  if ((address & LOCKED) ||\n+      !compare_and_swap(&(he -> address), address, (address | LOCKED )))\n     {\n       wait_unlocked(he);\n       goto retry;\n@@ -876,25 +952,28 @@ _Jv_MonitorEnter (jobject obj)\n \t// Can't convert a nonexistent lightweight lock.\n       heavy_lock *hl;\n       hl = (was_heavy? find_heavy(addr, he) : 0);\n+        // The CAS succeeded, so was_heavy is still accurate.\n       if (0 == hl)\n         {\n \t  // It is OK to use the lighweight lock, since either the\n \t  // heavyweight lock does not exist, or none of the\n-\t  // heavyweight locks currently exist.  Future threads\n+\t  // heavyweight locks are currently in use.  Future threads\n \t  // trying to acquire the lock will see the lightweight\n \t  // one first and use that.\n \t  he -> light_thr_id = self;  // OK, since nobody else can hold\n \t\t\t\t      // light lock or do this at the same time.\n \t  JvAssert(he -> light_count == 0);\n \t  JvAssert(was_heavy == (he -> address & HEAVY));\n \t  release_set(&(he -> address), (addr | was_heavy));\n+\t  LOG(ACQ_LIGHT2, addr | was_heavy, self);\n         }\n       else\n \t{\n \t  // Must use heavy lock.\n \t  ++ (he -> heavy_count);\n \t  JvAssert(0 == (address & ~HEAVY));\n           release_set(&(he -> address), HEAVY);\n+\t  LOG(ACQ_HEAVY, addr | was_heavy, self);\n           _Jv_MutexLock(&(hl->si.mutex));\n \t  keep_live(addr);\n         }\n@@ -908,6 +987,7 @@ _Jv_MonitorEnter (jobject obj)\n       heavy_lock *hl = get_heavy(addr, he);\n       ++ (he -> heavy_count);\n       release_set(&(he -> address), address | HEAVY);\n+      LOG(ACQ_HEAVY2, address | HEAVY, self);\n       _Jv_MutexLock(&(hl->si.mutex));\n       keep_live(addr);\n     }\n@@ -956,7 +1036,10 @@ _Jv_MonitorExit (jobject obj)\n \t      he -> light_thr_id = INVALID_THREAD_ID;\n               if (compare_and_swap_release(&(he -> address), address,\n \t\t\t\t\t   address & HEAVY))\n-\t        return;\n+\t\t{\n+\t\t  LOG(REL_LIGHT, address & HEAVY, self);\n+\t          return;\n+\t\t}\n \t      else\n \t\t{\n \t          he -> light_thr_id = light_thr_id; // Undo prior damage.\n@@ -976,8 +1059,9 @@ _Jv_MonitorExit (jobject obj)\n #\t  ifdef LOCK_DEBUG\n \t    fprintf(stderr, \"Lightweight lock held by other thread\\n\\t\"\n \t\t\t    \"light_thr_id = 0x%lx, self = 0x%lx, \"\n-\t\t\t    \"address = 0x%lx, pid = %d\\n\",\n-\t\t\t    light_thr_id, self, address, getpid());\n+\t\t\t    \"address = 0x%lx, heavy_count = %d, pid = %d\\n\",\n+\t\t\t    light_thr_id, self, (unsigned long)address,\n+\t\t\t    he -> heavy_count, getpid());\n \t    print_he(he);\n \t    for(;;) {}\n #\t  endif\n@@ -1031,6 +1115,7 @@ _Jv_MonitorExit (jobject obj)\n \t// lock.\n       he -> light_thr_id = INVALID_THREAD_ID;\n       release_set(&(he -> address), HEAVY);\n+      LOG(PROMOTE, address, self);\n \t  \t// lightweight lock now unused.\n       _Jv_CondNotifyAll(&(hl->si.condition), &(hl->si.mutex));\n       _Jv_MutexUnlock(&(hl->si.mutex));\n@@ -1052,6 +1137,7 @@ _Jv_MonitorExit (jobject obj)\n \tprint_he(he);\n \tfor(;;) {}\n #     endif\n+      release_set(&(he -> address), address);\n       throw new java::lang::IllegalMonitorStateException(\n \t\t\tJvNewStringLatin1(\"current thread not owner\"));\n     }\n@@ -1091,6 +1177,7 @@ _Jv_MonitorExit (jobject obj)\n       release_set(&(he -> address), address);\n       _Jv_MutexUnlock(&(hl->si.mutex));\n     }\n+  LOG(REL_HEAVY, addr, self);\n   keep_live(addr);\n }     \n \n@@ -1106,12 +1193,19 @@ _Jv_ObjectCheckMonitor (jobject obj)\n   obj_addr_t address;\n   unsigned hash = JV_SYNC_HASH(addr);\n   hash_entry * he = light_locks + hash;\n-  _Jv_ThreadId_t self = _Jv_ThreadSelf();\n \n   JvAssert(!(addr & FLAGS));\n+  address = he -> address;\n+  // Try it the easy way first:\n+    if (address == 0) return true;\n+    _Jv_ThreadId_t self = _Jv_ThreadSelf();\n+    if ((address & ~(HEAVY | REQUEST_CONVERSION)) == addr)\n+\t// Fails if entry is LOCKED.\n+\t// I can't asynchronously become or stop being the holder.\n+\treturn he -> light_thr_id != self;\n retry:\n   // Acquire the hash table entry lock\n-  address = ((he -> address) & ~LOCKED);\n+  address &= ~LOCKED;\n   if (!compare_and_swap(&(he -> address), address, address | LOCKED))\n     {\n       wait_unlocked(he);\n@@ -1120,9 +1214,7 @@ _Jv_ObjectCheckMonitor (jobject obj)\n \n   bool not_mine;\n \n-  if (!(address & ~FLAGS))\n-    not_mine = true;\n-  else if ((address & ~FLAGS) == addr)\n+  if ((address & ~FLAGS) == addr)\n     not_mine = (he -> light_thr_id != self);\n   else\n     {\n@@ -1163,7 +1255,7 @@ java::lang::Object::wait (jlong timeout, jint nanos)\n       wait_unlocked(he);\n       goto retry;\n     }\n-  // address does not have the lock bit set.  We hold the lock on he.\n+  // address did not have the lock bit set.  We now hold the lock on he.\n   if ((address & ~FLAGS) == addr)\n     {\n       // Convert to heavyweight.\n@@ -1188,8 +1280,15 @@ java::lang::Object::wait (jlong timeout, jint nanos)\n \t// Again release the he lock after acquiring the mutex.\n         he -> light_thr_id = INVALID_THREAD_ID;\n \trelease_set(&(he -> address), HEAVY);  // lightweight lock now unused.\n+\tLOG(PROMOTE2, addr, self);\n \tif (address & REQUEST_CONVERSION)\n-\t  _Jv_CondNotify (&(hl->si.condition), &(hl->si.mutex));\n+\t  _Jv_CondNotifyAll (&(hl->si.condition), &(hl->si.mutex));\n+\t  // Since we do this before we do a CondWait, we guarantee that\n+\t  // threads waiting on requested conversion are awoken before\n+\t  // a real wait on the same condition variable.\n+\t  // No other notification can occur in the interim, since\n+\t  // we hold the heavy lock, and notifications are made\n+\t  // without acquiring it.\n     }\n   else /* We should hold the heavyweight lock. */\n     {\n@@ -1208,6 +1307,7 @@ java::lang::Object::wait (jlong timeout, jint nanos)\n \t}\n       JvAssert(address & HEAVY);\n     }\n+  LOG(WAIT_START, addr, self);\n   switch (_Jv_CondWait (&(hl->si.condition), &(hl->si.mutex), timeout, nanos))\n     {\n       case _JV_NOT_OWNER:\n@@ -1217,6 +1317,7 @@ java::lang::Object::wait (jlong timeout, jint nanos)\n \tif (Thread::interrupted ())\n \t  throw new InterruptedException;        \n     }\n+  LOG(WAIT_END, addr, self);\n }\n \n void\n@@ -1251,7 +1352,7 @@ java::lang::Object::notify (void)\n   hl = find_heavy(addr, he);\n   // Hl can't disappear since we point to the underlying object.\n   // It's important that we release the lock bit before the notify, since\n-  // otherwise we will try to wake up thee target while we still hold the\n+  // otherwise we will try to wake up the target while we still hold the\n   // bit.  This results in lock bit contention, which we don't handle\n   // terribly well.\n   release_set(&(he -> address), address); // unlock\n@@ -1261,7 +1362,10 @@ java::lang::Object::notify (void)\n                                               (\"current thread not owner\"));\n       return;\n     }\n+  // We know that we hold the heavyweight lock at this point,\n+  // and the lightweight lock is not in use.\n   result = _Jv_CondNotify(&(hl->si.condition), &(hl->si.mutex));\n+  LOG(NOTIFY, addr, self);\n   keep_live(addr);\n   if (__builtin_expect (result, 0))\n     throw new IllegalMonitorStateException(JvNewStringLatin1 \n@@ -1305,6 +1409,7 @@ java::lang::Object::notifyAll (void)\n                                               (\"current thread not owner\"));\n     }\n   result = _Jv_CondNotifyAll(&(hl->si.condition), &(hl->si.mutex));\n+  LOG(NOTIFY_ALL, addr, self);\n   if (__builtin_expect (result, 0))\n     throw new IllegalMonitorStateException(JvNewStringLatin1 \n                                               (\"current thread not owner\"));"}]}