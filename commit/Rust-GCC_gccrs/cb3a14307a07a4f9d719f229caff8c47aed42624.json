{"sha": "cb3a14307a07a4f9d719f229caff8c47aed42624", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2IzYTE0MzA3YTA3YTRmOWQ3MTlmMjI5Y2FmZjhjNDdhZWQ0MjYyNA==", "commit": {"author": {"name": "Per Bothner", "email": "per@bothner.com", "date": "2004-09-30T23:25:27Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2004-09-30T23:25:27Z"}, "message": "java-tree.h (JAVA_FILE_P, ZIP_FILE_P): Remove unused macros.\n\n\n\t* java-tree.h (JAVA_FILE_P, ZIP_FILE_P):  Remove unused macros.\n\t* jcf-parse.c (java_parse_file): Don't set input_filename.\n\tUse IS_A_COMMAND_LINE_FILENAME_P to check for duplicate filenames.\n\tCreate a list of TRANSLATION_UNIT_DECL.\n\t(current_file_list):  Is now a TRANSLATION_UNIT_DECL chain.  The\n\treason is so we can set a DECL_SOURCE_LOCATION for each file.\n\t(java_parse_file):  Don't set unused ZIP_FILE_P, JAVA_FILE_P..\n\tCreate line-map LC_ENTER/LC_LEAVE entries for archive itself.\n\t(file_start_location):  New static.\n\t(set_source_filename):  Avoid extra access to input_filename macro.\n\tConcatenate new name with class's package prefix.\n\t(set_source_filename, give_name_to_class): Update.\n\t(give_name_to_class):  Set class's \"line 0\" input_location here.\n\t(parse_class_file):  Set input_location as a unit.\n\n\t* jcf-parse.c (load_class): Sanity test if missing inner class file.\n\nFrom-SVN: r88366", "tree": {"sha": "0b4854ccef6da28990a8faf1935840149a357ba1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b4854ccef6da28990a8faf1935840149a357ba1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb3a14307a07a4f9d719f229caff8c47aed42624", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb3a14307a07a4f9d719f229caff8c47aed42624", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb3a14307a07a4f9d719f229caff8c47aed42624", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb3a14307a07a4f9d719f229caff8c47aed42624/comments", "author": {"login": "PerBothner", "id": 10293361, "node_id": "MDQ6VXNlcjEwMjkzMzYx", "avatar_url": "https://avatars.githubusercontent.com/u/10293361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PerBothner", "html_url": "https://github.com/PerBothner", "followers_url": "https://api.github.com/users/PerBothner/followers", "following_url": "https://api.github.com/users/PerBothner/following{/other_user}", "gists_url": "https://api.github.com/users/PerBothner/gists{/gist_id}", "starred_url": "https://api.github.com/users/PerBothner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PerBothner/subscriptions", "organizations_url": "https://api.github.com/users/PerBothner/orgs", "repos_url": "https://api.github.com/users/PerBothner/repos", "events_url": "https://api.github.com/users/PerBothner/events{/privacy}", "received_events_url": "https://api.github.com/users/PerBothner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6744f40032f27c47186a71c87342efbb07663f5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6744f40032f27c47186a71c87342efbb07663f5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6744f40032f27c47186a71c87342efbb07663f5b"}], "stats": {"total": 188, "additions": 118, "deletions": 70}, "files": [{"sha": "0935ecd1a74e12bd32cd87d603e61875d0dfa59b", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3a14307a07a4f9d719f229caff8c47aed42624/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3a14307a07a4f9d719f229caff8c47aed42624/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=cb3a14307a07a4f9d719f229caff8c47aed42624", "patch": "@@ -11,6 +11,23 @@\n \t* class.c (maybe_layout_super_class):  Adjust build_expr_wfl call\n \tto USE_MAPPED_LOCATION case.\n \n+\t* java-tree.h (JAVA_FILE_P, ZIP_FILE_P):  Remove unused macros.\n+\t* jcf-parse.c (java_parse_file): Don't set input_filename.\n+\tUse IS_A_COMMAND_LINE_FILENAME_P to check for duplicate filenames.\n+\tCreate a list of TRANSLATION_UNIT_DECL.\n+\t(current_file_list):  Is now a TRANSLATION_UNIT_DECL chain.  The\n+\treason is so we can set a DECL_SOURCE_LOCATION for each file.\n+\t(java_parse_file):  Don't set unused ZIP_FILE_P, JAVA_FILE_P..\n+\tCreate line-map LC_ENTER/LC_LEAVE entries for archive itself.\n+\t(file_start_location):  New static.\n+\t(set_source_filename):  Avoid extra access to input_filename macro.\n+\tConcatenate new name with class's package prefix.\n+\t(set_source_filename, give_name_to_class): Update.\n+\t(give_name_to_class):  Set class's \"line 0\" input_location here.\n+\t(parse_class_file):  Set input_location as a unit.\n+\n+\t* jcf-parse.c (load_class): Sanity test if missing inner class file.\n+\n 2004-09-29  Per Bothner  <per@bothner.com>\n \n \t* java-tree.h:  Redefine some macros and add soem declaration"}, {"sha": "4147b2970a3b1ff23d8eb58560864b20a8161553", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3a14307a07a4f9d719f229caff8c47aed42624/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3a14307a07a4f9d719f229caff8c47aed42624/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=cb3a14307a07a4f9d719f229caff8c47aed42624", "patch": "@@ -52,17 +52,15 @@ struct JCF;\n       COMPOUND_ASSIGN_P (in EXPR (binop_*))\n       LOCAL_CLASS_P (in RECORD_TYPE)\n       BLOCK_IS_IMPLICIT (in BLOCK)\n-      JAVA_FILE_P (in TREE_LIST in current_file_list)\n    2: RETURN_MAP_ADJUSTED (in TREE_VEC).\n       QUALIFIED_P (in IDENTIFIER_NODE)\n       PRIMARY_P (in EXPR_WITH_FILE_LOCATION)\n       MODIFY_EXPR_FROM_INITIALIZATION_P (in MODIFY_EXPR)\n       CLASS_METHOD_CHECKED_P (in RECORD_TYPE) \n-      CLASS_FILE_P (in TREE_LIST in current_file_list)\n+      CLASS_FILE_P (in a TRANSLATION_UNIT_DECL in current_file_list)\n    3: IS_AN_IMPORT_ON_DEMAND_P (in IDENTIFIER_NODE)\n       RESOLVE_PACKAGE_NAME_P (in EXPR_WITH_FILE_LOCATION)\n       SWITCH_HAS_DEFAULT (in SWITCH_EXPR)\n-      ZIP_FILE_P (in TREE_LIST in current_file_list)\n       HAS_FINALIZER (in RECORD_TYPE)\n    4: IS_A_COMMAND_LINE_FILENAME_P (in IDENTIFIER_NODE)\n       RESOLVE_TYPE_NAME_P (in EXPR_WITH_FILE_LOCATION)\n@@ -756,7 +754,7 @@ union lang_tree_node\n /* Number of local variable slots needed for the arguments of this function. */\n #define DECL_ARG_SLOT_COUNT(DECL) \\\n   (DECL_LANG_SPECIFIC(DECL)->u.f.arg_slot_count)\n-/* Line number of end of function. */\n+/* Source location of end of function. */\n #define DECL_FUNCTION_LAST_LINE(DECL) (DECL_LANG_SPECIFIC(DECL)->u.f.last_line)\n /* Information on declaration location */\n #define DECL_FUNCTION_WFL(DECL)  (DECL_LANG_SPECIFIC(DECL)->u.f.wfl)\n@@ -958,7 +956,9 @@ struct lang_decl_func GTY(())\n   int max_locals;\n   int max_stack;\n   int arg_slot_count;\n-  int last_line; \t\t/* End line number for a function decl */\n+  /* A temportary lie for the sake of ggc.  Actually, last_line is\n+  * only a source_location if USE_MAPPED_LOCATION.  FIXME. */\n+  source_location last_line;\t/* End line number for a function decl */\n   tree wfl;\t\t\t/* Information on the original location */\n   tree throws_list;\t\t/* Exception specified by `throws' */\n   tree function_decl_body;\t/* Hold all function's statements */\n@@ -1378,9 +1378,7 @@ extern tree builtin_function (const char *, tree, int, enum built_in_class,\n #define METHOD_INVISIBLE(DECL) \\\n   (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (DECL))->u.f.invisible)\n \n-#define JAVA_FILE_P(NODE) TREE_LANG_FLAG_2 (NODE)\n #define CLASS_FILE_P(NODE) TREE_LANG_FLAG_3 (NODE)\n-#define ZIP_FILE_P(NODE) TREE_LANG_FLAG_4 (NODE)\n \n /* Other predicates on method decls  */\n "}, {"sha": "031cedc8a1394334cd3f038d2c365899d5608639", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 96, "deletions": 63, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb3a14307a07a4f9d719f229caff8c47aed42624/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb3a14307a07a4f9d719f229caff8c47aed42624/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=cb3a14307a07a4f9d719f229caff8c47aed42624", "patch": "@@ -80,9 +80,12 @@ static GTY(()) tree parse_roots[3];\n /* The METHOD_DECL for the current method.  */\n #define current_method parse_roots[1]\n \n-/* A list of file names.  */\n+/* A list of TRANSLATION_UNIT_DECLs for the files to be compiled.  */\n #define current_file_list parse_roots[2]\n \n+/* Line 0 in current file, if compiling from bytecode. */\n+static location_t file_start_location;\n+\n /* The Java archive that provides main_class;  the main input file. */\n static GTY(()) struct JCF * main_jcf;\n \n@@ -128,21 +131,48 @@ set_source_filename (JCF *jcf, int index)\n {\n   tree sfname_id = get_name_constant (jcf, index);\n   const char *sfname = IDENTIFIER_POINTER (sfname_id);\n-  if (input_filename != NULL)\n+  const char *old_filename = input_filename;\n+  int new_len = IDENTIFIER_LENGTH (sfname_id);\n+  if (old_filename != NULL)\n     {\n-      int old_len = strlen (input_filename);\n-      int new_len = IDENTIFIER_LENGTH (sfname_id);\n+      int old_len = strlen (old_filename);\n       /* Use the current input_filename (derived from the class name)\n \t if it has a directory prefix, but otherwise matches sfname. */\n       if (old_len > new_len\n-\t  && strcmp (sfname, input_filename + old_len - new_len) == 0\n-\t  && (input_filename[old_len - new_len - 1] == '/'\n-\t      || input_filename[old_len - new_len - 1] == '\\\\'))\n+\t  && strcmp (sfname, old_filename + old_len - new_len) == 0\n+\t  && (old_filename[old_len - new_len - 1] == '/'\n+\t      || old_filename[old_len - new_len - 1] == '\\\\'))\n \treturn;\n     }\n+  if (strchr (sfname, '/') == NULL && strchr (sfname, '\\\\') == NULL)\n+    {\n+      const char *class_name\n+\t= IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class)));\n+      char *dot = strrchr (class_name, '.');\n+      if (dot != NULL)\n+\t{\n+\t  int i = dot - class_name;\n+\t  /* Concatenate current package prefix with new sfname. */\n+\t  char *buf = xmalloc (i+new_len+3);\n+\t  /* Replace '.' by DIR_SEPARATOR. */\n+\t  for (; i >= 0;  i--)\n+\t    {\n+\t      if (buf[i] == '.')\n+\t\tbuf[i] = DIR_SEPARATOR;\n+\t    }\n+\t  sfname_id = get_identifier (buf);\n+\t  sfname = IDENTIFIER_POINTER (sfname_id);\n+\t}\n+    }\n+      \n+#ifdef USE_MAPPED_LOCATION\n+  line_table.maps[line_table.used-1].to_file = sfname;\n+#else\n   input_filename = sfname;\n-  DECL_SOURCE_FILE (TYPE_NAME (current_class)) = sfname;\n-  if (current_class == main_class) main_input_filename = input_filename;\n+  DECL_SOURCE_LOCATION (TYPE_NAME (current_class)) = input_location;\n+  file_start_location = input_location;\n+#endif\n+  if (current_class == main_class) main_input_filename = sfname;\n }\n \n #define HANDLE_SOURCEFILE(INDEX) set_source_filename (jcf, INDEX)\n@@ -414,10 +444,22 @@ give_name_to_class (JCF *jcf, int i)\n       tree class_name = unmangle_classname ((const char *) JPOOL_UTF_DATA (jcf, j),\n \t\t\t\t\t    JPOOL_UTF_LENGTH (jcf, j));\n       this_class = lookup_class (class_name);\n-      input_filename = DECL_SOURCE_FILE (TYPE_NAME (this_class));\n-      input_line = 0;\n+#ifdef USE_MAPPED_LOCATION\n+      {\n+      tree source_name = identifier_subst (class_name, \"\", '.', '/', \".java\");\n+      const char *sfname = IDENTIFIER_POINTER (source_name);\n+      linemap_add (&line_table, LC_ENTER, false, sfname, 0);\n+      input_location = linemap_line_start (&line_table, 0, 1);\n+      file_start_location = input_location;\n+      DECL_SOURCE_LOCATION (TYPE_NAME (this_class)) = input_location;\n+      if (main_input_filename == NULL && jcf == main_jcf)\n+\tmain_input_filename = sfname;\n+      }\n+#else\n+      input_location = DECL_SOURCE_LOCATION (TYPE_NAME (this_class));\n       if (main_input_filename == NULL && jcf == main_jcf)\n \tmain_input_filename = input_filename;\n+#endif\n \n       jcf->cpool.data[i].t = this_class;\n       JPOOL_TAG (jcf, i) = CONSTANT_ResolvedClass;\n@@ -602,6 +644,11 @@ load_class (tree class_or_name, int verbose)\n \t  *separator = '\\0';\n \t  name = get_identifier (IDENTIFIER_POINTER (name));\n \t  *separator = c;\n+\n+\t  /* Otherwise we might get infinite recursion, if say we have\n+\t     String.class but not String$CaseInsensitiveComparator.class. */\n+\t  if (current_jcf && current_jcf->java_source == 0)\n+\t    break;\n \t}\n       /* Otherwise, we failed, we bail. */\n       else\n@@ -707,8 +754,7 @@ parse_class_file (void)\n \n   java_layout_seen_class_methods ();\n \n-  input_filename = DECL_SOURCE_FILE (TYPE_NAME (current_class));\n-  input_line = 0;\n+  input_location = DECL_SOURCE_LOCATION (TYPE_NAME (current_class));\n   (*debug_hooks->start_source_file) (input_line, input_filename);\n \n   /* Currently we always have to emit calls to _Jv_InitClass when\n@@ -895,6 +941,7 @@ void\n java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n {\n   int filename_count = 0;\n+  location_t save_location = input_location;\n   char *list, *next;\n   tree node;\n   FILE *finput = NULL;\n@@ -903,7 +950,7 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n   if (flag_filelist_file)\n     {\n       int avail = 2000;\n-      finput = fopen (input_filename, \"r\");\n+      finput = fopen (main_input_filename, \"r\");\n       if (finput == NULL)\n \tfatal_error (\"can't open %s: %m\", input_filename);\n       list = xmalloc(avail);\n@@ -935,7 +982,7 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n       finput = NULL;\n     }\n   else\n-    list = input_filename ? xstrdup (input_filename) : 0;\n+    list = (char *) main_input_filename;\n \n   while (list)\n     {\n@@ -977,51 +1024,32 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n \n       if (list[0]) \n \t{\n-\t  char *value;\n-\t  tree id;\n-\t  int twice = 0;\n-\n-\t  int len = strlen (list);\n-\n-\t  obstack_grow0 (&temporary_obstack, list, len);\n-\t  value = obstack_finish (&temporary_obstack);\n+\t  node = get_identifier (list);\n \n \t  filename_count++;\n \n-\t  /* Exclude file that we see twice on the command line. For\n-\t     all files except {Class,Error,Object,RuntimeException,String,\n-\t     Throwable}.java we can rely on maybe_get_identifier. For\n-\t     these files, we need to do a linear search of\n-\t     current_file_list. This search happens only for these\n-\t     files, presumably only when we're recompiling libgcj. */\n+\t  /* Exclude file that we see twice on the command line. */\n \t     \n-\t  if ((id = maybe_get_identifier (value)))\n-\t    {\n-\t      if (predefined_filename_p (id))\n-\t\t{\n-\t\t  tree c;\n-\t\t  for (c = current_file_list; c; c = TREE_CHAIN (c))\n-\t\t    if (TREE_VALUE (c) == id)\n-\t\t      twice = 1;\n-\t\t}\n-\t      else\n-\t\ttwice = 1;\n-\t    }\n-\n-\t  if (twice)\n+\t  if (IS_A_COMMAND_LINE_FILENAME_P (node))\n \t    {\n \t      location_t warn_loc;\n-\t      warn_loc.file = value;\n+#ifdef USE_MAPPED_LOCATION\n+\t      linemap_add (&line_table, LC_RENAME, 0,\n+\t\t\t   IDENTIFIER_POINTER (node), 0);\n+\t      warn_loc = linemap_line_start (&line_table, 0, 1);\n+#else\n+\t      warn_loc.file = IDENTIFIER_POINTER (node);\n \t      warn_loc.line = 0;\n+#endif\n \t      warning (\"%Hsource file seen twice on command line and \"\n \t\t       \"will be compiled only once\", &warn_loc);\n \t    }\n \t  else\n \t    {\n-\t      node = get_identifier (value);\n+\t      tree file_decl = build_decl (TRANSLATION_UNIT_DECL, node, NULL);\n+\t      TREE_CHAIN (file_decl) = current_file_list;\n+\t      current_file_list = file_decl;\n \t      IS_A_COMMAND_LINE_FILENAME_P (node) = 1;\n-\t      current_file_list = tree_cons (NULL_TREE, node, \n-\t\t\t\t\t     current_file_list);\n \t    }\n \t}\n       list = next;\n@@ -1037,7 +1065,7 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n       /* Only one resource file may be compiled at a time.  */\n       assert (TREE_CHAIN (current_file_list) == NULL);\n \n-      resource_filename = IDENTIFIER_POINTER (TREE_VALUE (current_file_list));\n+      resource_filename = IDENTIFIER_POINTER (DECL_NAME (current_file_list));\n       compile_resource_file (resource_name, resource_filename);\n \n       goto finish;\n@@ -1049,27 +1077,27 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n     {\n       unsigned char magic_string[4];\n       uint32 magic = 0;\n-      tree name = TREE_VALUE (node);\n+      tree name = DECL_NAME (node);\n       tree real_file;\n+      const char *filename = IDENTIFIER_POINTER (name);\n \n       /* Skip already parsed files */\n-      real_file = get_identifier (lrealpath (IDENTIFIER_POINTER (name)));\n+      real_file = get_identifier (lrealpath (filename));\n       if (HAS_BEEN_ALREADY_PARSED_P (real_file))\n \tcontinue;\n-      \n+\n       /* Close previous descriptor, if any */\n       if (finput && fclose (finput))\n \tfatal_error (\"can't close input file %s: %m\", main_input_filename);\n       \n-      finput = fopen (IDENTIFIER_POINTER (name), \"rb\");\n+      finput = fopen (filename, \"rb\");\n       if (finput == NULL)\n-\tfatal_error (\"can't open %s: %m\", IDENTIFIER_POINTER (name));\n+\tfatal_error (\"can't open %s: %m\", filename);\n \n #ifdef IO_BUFFER_SIZE\n       setvbuf (finput, xmalloc (IO_BUFFER_SIZE),\n \t       _IOFBF, IO_BUFFER_SIZE);\n #endif\n-      input_filename = IDENTIFIER_POINTER (name);\n \n       /* Figure what kind of file we're dealing with */\n       if (fread (magic_string, 1, 4, finput) == 4)\n@@ -1085,22 +1113,29 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n \t  current_jcf->read_state = finput;\n \t  current_jcf->filbuf = jcf_filbuf_from_stdio;\n \t  jcf_parse (current_jcf);\n+\t  DECL_SOURCE_LOCATION (node) = file_start_location;\n \t  TYPE_JCF (current_class) = current_jcf;\n \t  CLASS_FROM_CURRENTLY_COMPILED_P (current_class) = 1;\n-\t  TREE_PURPOSE (node) = current_class;\n+\t  TREE_TYPE (node) = current_class;\n \t}\n       else if (magic == (JCF_u4)ZIPMAGIC)\n \t{\n-\t  ZIP_FILE_P (node) = 1;\n \t  main_jcf = ggc_alloc (sizeof (JCF));\n \t  JCF_ZERO (main_jcf);\n \t  main_jcf->read_state = finput;\n \t  main_jcf->filbuf = jcf_filbuf_from_stdio;\n-\t  if (open_in_zip (main_jcf, input_filename, NULL, 0) <  0)\n-\t    fatal_error (\"bad zip/jar file %s\", IDENTIFIER_POINTER (name));\n+#ifdef USE_MAPPED_LOCATION\n+\t  linemap_add (&line_table, LC_ENTER, false, filename, 0);\n+\t  input_location = linemap_line_start (&line_table, 0, 1);\n+#endif\n+\t  if (open_in_zip (main_jcf, filename, NULL, 0) <  0)\n+\t    fatal_error (\"bad zip/jar file %s\", filename);\n \t  localToFile = SeenZipFiles;\n \t  /* Register all the classes defined there.  */\n \t  process_zip_dir (main_jcf->read_state);\n+#ifdef USE_MAPPED_LOCATION\n+\t  linemap_add (&line_table, LC_LEAVE, false, NULL, 0);\n+#endif\n \t  parse_zip_file_entries ();\n \t  /*\n \t  for (each entry)\n@@ -1109,7 +1144,6 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n \t}\n       else\n \t{\n-\t  JAVA_FILE_P (node) = 1;\n \t  java_push_parser_context ();\n \t  java_parser_context_save_global ();\n \n@@ -1133,18 +1167,18 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n \n   for (node = current_file_list; node; node = TREE_CHAIN (node))\n     {\n-      input_filename = IDENTIFIER_POINTER (TREE_VALUE (node));\n+      input_location = DECL_SOURCE_LOCATION (node);\n       if (CLASS_FILE_P (node))\n \t{\n-\t  output_class = current_class = TREE_PURPOSE (node);\n+\t  output_class = current_class = TREE_TYPE (node);\n \t  current_jcf = TYPE_JCF (current_class);\n \t  layout_class (current_class);\n \t  load_inner_classes (current_class);\n \t  parse_class_file ();\n \t  JCF_FINISH (current_jcf);\n \t}\n     }\n-  input_filename = main_input_filename;\n+  input_location = save_location;\n \n   java_expand_classes ();\n   if (java_report_errors () || flag_syntax_only)\n@@ -1244,7 +1278,6 @@ parse_zip_file_entries (void)\n \n \t    if (TYPE_SIZE (current_class) != error_mark_node)\n \t      {\n-\t\tinput_filename = current_jcf->filename;\n \t\tparse_class_file ();\n \t\tFREE (current_jcf->buffer); /* No longer necessary */\n \t\t/* Note: there is a way to free this buffer right after a"}]}