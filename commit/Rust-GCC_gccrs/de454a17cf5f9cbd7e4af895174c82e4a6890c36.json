{"sha": "de454a17cf5f9cbd7e4af895174c82e4a6890c36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU0NTRhMTdjZjVmOWNiZDdlNGFmODk1MTc0YzgyZTRhNjg5MGMzNg==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-06-14T15:11:33Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-06-14T15:31:46Z"}, "message": "Fix PathExpression type resolution\n\nThere are cases where the name resolver can fully resolve a path such as:\n\n```rust\nstruct Foo(i32);\n\nimpl Foo{\n  fn new() { ... }\n}\n\nfn main() {\n  let a;\n  a = Foo::new();\n}\n```\n\nThis case does not require a PathProbe. This enhances the Path resolution\nto iterate each segment untill we are unable to resolve the root segment\nat that point we can fall back to a PathProbe and lookup any impl item that\nmight satisfy the path instead.\n\nAddresses #432", "tree": {"sha": "2668b0790ca07ad86723b4c08320a16bfcf9bf1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2668b0790ca07ad86723b4c08320a16bfcf9bf1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de454a17cf5f9cbd7e4af895174c82e4a6890c36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de454a17cf5f9cbd7e4af895174c82e4a6890c36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de454a17cf5f9cbd7e4af895174c82e4a6890c36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de454a17cf5f9cbd7e4af895174c82e4a6890c36/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75c44883dbe84682beabc92db7c89bc6db491db8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75c44883dbe84682beabc92db7c89bc6db491db8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75c44883dbe84682beabc92db7c89bc6db491db8"}], "stats": {"total": 159, "additions": 103, "deletions": 56}, "files": [{"sha": "1838e35b63978b359ff81482036c9b7977316ba0", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 103, "deletions": 56, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de454a17cf5f9cbd7e4af895174c82e4a6890c36/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de454a17cf5f9cbd7e4af895174c82e4a6890c36/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=de454a17cf5f9cbd7e4af895174c82e4a6890c36", "patch": "@@ -864,11 +864,15 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::PathInExpression &expr) override\n   {\n-    // resolve root_segment\n-    TyTy::BaseType *tyseg = resolve_root_path (expr);\n+    NodeId resolved_node_id = UNKNOWN_NODEID;\n+\n+    size_t offset = -1;\n+    TyTy::BaseType *tyseg\n+      = resolve_root_path (expr, &offset, &resolved_node_id);\n     if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n       return;\n-    else if (expr.get_num_segments () == 1)\n+\n+    if (expr.get_num_segments () == 1)\n       {\n \tLocation locus = expr.get_segments ().back ().get_locus ();\n \n@@ -886,8 +890,7 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n \n     TyTy::BaseType *prev_segment = tyseg;\n-    NodeId resolved_node_id = UNKNOWN_NODEID;\n-    for (size_t i = 1; i < expr.get_num_segments (); i++)\n+    for (size_t i = offset; i < expr.get_num_segments (); i++)\n       {\n \tHIR::PathExprSegment &seg = expr.get_segments ().at (i);\n \n@@ -1088,69 +1091,113 @@ class TypeCheckExpr : public TypeCheckBase\n       folded_array_capacity (nullptr), inside_loop (inside_loop)\n   {}\n \n-  TyTy::BaseType *resolve_root_path (HIR::PathInExpression &expr)\n+  TyTy::BaseType *resolve_root_path (HIR::PathInExpression &expr,\n+\t\t\t\t     size_t *offset,\n+\t\t\t\t     NodeId *root_resolved_node_id)\n   {\n-    HIR::PathExprSegment &root = expr.get_root_seg ();\n-    NodeId ast_node_id = root.get_mappings ().get_nodeid ();\n-\n-    // then lookup the reference_node_id\n-    NodeId ref_node_id = UNKNOWN_NODEID;\n-    if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+    TyTy::BaseType *root_tyty = nullptr;\n+    *offset = 0;\n+    for (auto &seg : expr.get_segments ())\n       {\n-\t// these ref_node_ids will resolve to a pattern declaration but we are\n-\t// interested in the definition that this refers to get the parent id\n-\tDefinition def;\n-\tif (!resolver->lookup_definition (ref_node_id, &def))\n+\tbool is_root = *offset == 0;\n+\tNodeId ast_node_id = seg.get_mappings ().get_nodeid ();\n+\n+\t// then lookup the reference_node_id\n+\tNodeId ref_node_id = UNKNOWN_NODEID;\n+\tif (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n \t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"unknown reference for resolved name\");\n-\t    return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t    // these ref_node_ids will resolve to a pattern declaration but we\n+\t    // are interested in the definition that this refers to get the\n+\t    // parent id\n+\t    Definition def;\n+\t    if (!resolver->lookup_definition (ref_node_id, &def))\n+\t      {\n+\t\trust_error_at (expr.get_locus (),\n+\t\t\t       \"unknown reference for resolved name\");\n+\t\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t      }\n+\t    ref_node_id = def.parent;\n+\t  }\n+\telse\n+\t  {\n+\t    resolver->lookup_resolved_type (ast_node_id, &ref_node_id);\n \t  }\n-\tref_node_id = def.parent;\n-      }\n-    else\n-      {\n-\tresolver->lookup_resolved_type (ast_node_id, &ref_node_id);\n-      }\n \n-    if (ref_node_id == UNKNOWN_NODEID)\n-      {\n-\trust_error_at (root.get_locus (),\n-\t\t       \"failed to type resolve root segment\");\n-\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-      }\n+\tif (ref_node_id == UNKNOWN_NODEID)\n+\t  {\n+\t    if (is_root)\n+\t      {\n+\t\trust_error_at (seg.get_locus (),\n+\t\t\t       \"failed to type resolve root segment\");\n+\t\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t      }\n+\t    return root_tyty;\n+\t  }\n \n-    // node back to HIR\n-    HirId ref;\n-    if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n-\t\t\t\t       ref_node_id, &ref))\n-      {\n-\trust_error_at (expr.get_locus (), \"reverse lookup failure\");\n-\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-      }\n+\t// node back to HIR\n+\tHirId ref;\n+\tif (!mappings->lookup_node_to_hir (\n+\t      expr.get_mappings ().get_crate_num (), ref_node_id, &ref))\n+\t  {\n+\t    if (is_root)\n+\t      {\n+\t\trust_error_at (seg.get_locus (), \"reverse lookup failure\");\n+\t\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t      }\n+\t    return root_tyty;\n+\t  }\n \n-    TyTy::BaseType *lookup = nullptr;\n-    if (!context->lookup_type (ref, &lookup))\n-      {\n-\trust_error_at (expr.get_locus (), \"failed to resolve root segment\");\n-\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-      }\n+\tTyTy::BaseType *lookup = nullptr;\n+\tif (!context->lookup_type (ref, &lookup))\n+\t  {\n+\t    if (is_root)\n+\t      {\n+\t\trust_error_at (seg.get_locus (),\n+\t\t\t       \"failed to resolve root segment\");\n+\t\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t      }\n+\t    return root_tyty;\n+\t  }\n \n-    // turbo-fish segment path::<ty>\n-    if (root.has_generic_args ())\n-      {\n-\tif (!lookup->can_substitute ())\n+\t// if we have a previous segment type\n+\tif (root_tyty != nullptr)\n \t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"substitutions not supported for %s\",\n-\t\t\t   lookup->as_string ().c_str ());\n-\t    return new TyTy::ErrorType (lookup->get_ref ());\n+\t    // if this next segment needs substitution we must apply the\n+\t    // previous type arguments\n+\t    //\n+\t    // such as: GenericStruct::<_>::new(123, 456)\n+\t    if (lookup->needs_generic_substitutions ())\n+\t      {\n+\t\tif (!root_tyty->needs_generic_substitutions ())\n+\t\t  {\n+\t\t    auto used_args_in_prev_segment\n+\t\t      = GetUsedSubstArgs::From (root_tyty);\n+\t\t    lookup = SubstMapperInternal::Resolve (\n+\t\t      lookup, used_args_in_prev_segment);\n+\t\t  }\n+\t      }\n \t  }\n-\tlookup = SubstMapper::Resolve (lookup, expr.get_locus (),\n-\t\t\t\t       &root.get_generic_args ());\n+\n+\t// turbo-fish segment path::<ty>\n+\tif (seg.has_generic_args ())\n+\t  {\n+\t    if (!lookup->can_substitute ())\n+\t      {\n+\t\trust_error_at (seg.get_locus (),\n+\t\t\t       \"substitutions not supported for %s\",\n+\t\t\t       lookup->as_string ().c_str ());\n+\t\treturn new TyTy::ErrorType (lookup->get_ref ());\n+\t      }\n+\t    lookup = SubstMapper::Resolve (lookup, expr.get_locus (),\n+\t\t\t\t\t   &seg.get_generic_args ());\n+\t  }\n+\n+\t*root_resolved_node_id = ref_node_id;\n+\t*offset = *offset + 1;\n+\troot_tyty = lookup;\n       }\n \n-    return lookup;\n+    return root_tyty;\n   }\n \n   bool"}]}