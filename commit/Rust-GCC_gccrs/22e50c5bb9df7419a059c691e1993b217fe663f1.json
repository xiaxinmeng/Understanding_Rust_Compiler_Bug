{"sha": "22e50c5bb9df7419a059c691e1993b217fe663f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJlNTBjNWJiOWRmNzQxOWEwNTljNjkxZTE5OTNiMjE3ZmU2NjNmMQ==", "commit": {"author": {"name": "Bruce Korb", "email": "bkorb@gnu.org", "date": "2000-05-30T20:24:44Z"}, "committer": {"name": "Bruce Korb", "email": "korbb@gcc.gnu.org", "date": "2000-05-30T20:24:44Z"}, "message": "restore old algorighm for char_macro_*_fix routines\n\nFrom-SVN: r34271", "tree": {"sha": "fe7389db30709c255edba5407eb42802eeb317b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe7389db30709c255edba5407eb42802eeb317b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22e50c5bb9df7419a059c691e1993b217fe663f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22e50c5bb9df7419a059c691e1993b217fe663f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22e50c5bb9df7419a059c691e1993b217fe663f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22e50c5bb9df7419a059c691e1993b217fe663f1/comments", "author": {"login": "brkorb", "id": 1242936, "node_id": "MDQ6VXNlcjEyNDI5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1242936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brkorb", "html_url": "https://github.com/brkorb", "followers_url": "https://api.github.com/users/brkorb/followers", "following_url": "https://api.github.com/users/brkorb/following{/other_user}", "gists_url": "https://api.github.com/users/brkorb/gists{/gist_id}", "starred_url": "https://api.github.com/users/brkorb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brkorb/subscriptions", "organizations_url": "https://api.github.com/users/brkorb/orgs", "repos_url": "https://api.github.com/users/brkorb/repos", "events_url": "https://api.github.com/users/brkorb/events{/privacy}", "received_events_url": "https://api.github.com/users/brkorb/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "26e903eefb735b09d75c3701eb44538e6beabbc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26e903eefb735b09d75c3701eb44538e6beabbc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26e903eefb735b09d75c3701eb44538e6beabbc1"}], "stats": {"total": 323, "additions": 148, "deletions": 175}, "files": [{"sha": "775db9991bf45c35a8ac977d17fdc330f861f1d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e50c5bb9df7419a059c691e1993b217fe663f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e50c5bb9df7419a059c691e1993b217fe663f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22e50c5bb9df7419a059c691e1993b217fe663f1", "patch": "@@ -1,6 +1,7 @@\n 2000-05-30  Bruce Korb  <bkorb@gnu.org>\n \n \t* fixinc/tests/*:  Added expected result files for fixinc's make check\n+\t* fixinc/fixfixes(char_macro_*_fix): Restore original algorithm\n \n 2000-05-30  Richard Henderson  <rth@cygnus.com>\n "}, {"sha": "4719a51ab615e6b85aae9ef232bfe993763e0905", "filename": "gcc/fixinc/fixfixes.c", "status": "modified", "additions": 138, "deletions": 153, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e50c5bb9df7419a059c691e1993b217fe663f1/gcc%2Ffixinc%2Ffixfixes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e50c5bb9df7419a059c691e1993b217fe663f1/gcc%2Ffixinc%2Ffixfixes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixfixes.c?ref=22e50c5bb9df7419a059c691e1993b217fe663f1", "patch": "@@ -24,7 +24,7 @@ Here are the rules:\n 4.  Do not read anything from stdin.  It is closed.\n \n 5.  Write to stderr only in the event of a reportable error\n-    In such an event, call \"exit(1)\".\n+    In such an event, call \"exit (EXIT_FAILURE)\".\n \n 6.  You have access to the fixDescList entry for the fix in question.\n     This may be useful, for example, if there are interesting strings\n@@ -59,6 +59,10 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"fixlib.h\"\n \n+tSCC zNeedsArg[] = \"fixincl error:  `%s' needs %s argument (c_fix_arg[%d])\\n\";\n+\n+#define EXIT_BROKEN  3\n+\n typedef struct {\n     const char*  fix_name;\n     void (*fix_proc)();\n@@ -192,7 +196,6 @@ format_write (format, text, av)\n  */\n FIX_PROC_HEAD( format_fix )\n {\n-  tSCC  zBad[] = \"fixincl error:  `%s' needs %s c_fix_arg\\n\";\n   tCC*  pz_pat = p_fixd->patch_args[2];\n   tCC*  pz_fmt = p_fixd->patch_args[1];\n   const char *p;\n@@ -204,8 +207,8 @@ FIX_PROC_HEAD( format_fix )\n    */\n   if (pz_fmt == (tCC*)NULL)\n     {\n-      fprintf( stderr, zBad, p_fixd->fix_name, \"replacement-format\" );\n-      exit( 3 );\n+      fprintf( stderr, zNeedsArg, p_fixd->fix_name, \"replacement format\", 0 );\n+      exit (EXIT_BROKEN);\n     }\n \n   /*\n@@ -220,8 +223,8 @@ FIX_PROC_HEAD( format_fix )\n         {\n           if (ct-- <= 0)\n             {\n-              fprintf( stderr, zBad, p_fixd->fix_name, \"search-text\" );\n-              exit( 3 );\n+              fprintf( stderr, zNeedsArg, p_fixd->fix_name, \"search text\", 1 );\n+              exit (EXIT_BROKEN);\n             }\n \n           if (pTD->type == TT_EGREP)\n@@ -271,71 +274,72 @@ FIX_PROC_HEAD( char_macro_use_fix )\n {\n   /* This regexp looks for a traditional-syntax #define (# in column 1)\n      of an object-like macro.  */\n-  static const char zPatFmt[] =\n-#ifdef __STDC__\n-    /*\n-     *  Match up to the replacement text\n-     */\n-    \"^#[ \\t]*define[ \\t]+[_A-Za-z][_A-Za-z0-9]*[ \\t]+\"\n-    /*\n-     *  Match the replacement macro name and openening parenthesis\n-     */\n-    \"[_A-Z][_A-Z0-9]*%s[A-Z]*\\\\(\"\n-    /*\n-     *  Match the single character that must be single-quoted,\n-     *  plus some other non-name type character\n-     */\n-    \"([A-Za-z])[^a-zA-Z0-9_]\"\n-#else\n-    /*\n-     *  Indecipherable gobbeldygook:\n-     */\n-\n-    \"^#[ \\t]*define[ \\t]+[_A-Za-z][_A-Za-z0-9]*[ \\t]+[_A-Z][_A-Z0-9]*\\\n-%s[A-Z]*\\\\(([A-Za-z])[^a-zA-Z0-9_]\"\n-#endif\n-    ;\n-\n-# define SUB_PAT_CT 1\n-  char *pz_pat;\n-\n+  static const char pat[] =\n+    \"^#[ \\t]*define[ \\t]+[_A-Za-z][_A-Za-z0-9]*[ \\t]+\";\n   static regex_t re;\n \n-  regmatch_t rm[SUB_PAT_CT+1];\n-\n-  if (p_fixd->patch_args[1] == NULL)\n-    {\n-      fprintf (stderr, \"%s needs macro-name-string argument\",\n-              p_fixd->fix_name);\n-      exit(3);\n-    }\n+  const char* str = p_fixd->patch_args[1];\n+  regmatch_t rm[1];\n+  const char *p, *limit;\n+  size_t len;\n \n-  asprintf (&pz_pat, zPatFmt, p_fixd->patch_args[1]);\n-  if (!pz_pat)\n+  if (str == NULL)\n     {\n-      fprintf( stderr, \"Virtual memory exhausted\\n\" );\n-      exit(3);\n+      fprintf (stderr, zNeedsArg, p_fixd->fix_name, \"ioctl type\", 0);\n+      exit (EXIT_BROKEN);\n     }\n \n-  compile_re (pz_pat, &re, 1, \"macro pattern\", \"char_macro_use_fix\");\n-  free (pz_pat);\n+  len = strlen (str);\n+  compile_re (pat, &re, 1, \"macro pattern\", \"char_macro_use_fix\");\n \n-  while (regexec (&re, text, SUB_PAT_CT+1, rm, 0) == 0)\n+  for (p = text;\n+       regexec (&re, p, 1, rm, 0) == 0;\n+       p = limit + 1)\n     {\n-      const char* pz = text + rm[1].rm_so;\n-\n-      /*\n-       *  Write up to, but not including, the character we must quote\n-       */\n-      fwrite( text, 1, rm[1].rm_so, stdout );\n-      fputc( '\\'', stdout );\n-      fputc( *(pz++), stdout );\n-      fputc( '\\'', stdout );\n-      text = pz;\n-    }\n+      /* p + rm[0].rm_eo is the first character of the macro replacement.\n+\t Find the end of the macro replacement, and the STR we were\n+\t sent to look for within the replacement.  */\n+      p += rm[0].rm_eo;\n+      limit = p - 1;\n+      do\n+\t{\n+\t  limit = strchr (limit + 1, '\\n');\n+\t  if (!limit)\n+\t    goto done;\n+\t}\n+      while (limit[-1] == '\\\\');\n \n+      do\n+\t{\n+\t  if (*p == str[0] && !strncmp (p+1, str+1, len-1))\n+\t    goto found;\n+\t}\n+      while (++p < limit - len);\n+      /* Hit end of line.  */\n+      continue;\n+\n+    found:\n+      /* Found STR on this line.  If the macro needs fixing,\n+\t the next few chars will be whitespace or uppercase,\n+\t then an open paren, then a single letter.  */\n+      while ((isspace (*p) || isupper (*p)) && p < limit) p++;\n+      if (*p++ != '(')\n+\tcontinue;\n+      if (!isalpha (*p))\n+\tcontinue;\n+      if (isalnum (p[1]) || p[1] == '_')\n+\tcontinue;\n+\n+      /* Splat all preceding text into the output buffer,\n+\t quote the character at p, then proceed.  */\n+      fwrite (text, 1, p - text, stdout);\n+      putchar ('\\'');\n+      putchar (*p);\n+      putchar ('\\'');\n+      text = p + 1;\n+    }\n+ done:\n   fputs (text, stdout);\n-# undef SUB_PAT_CT\n }\n \n \n@@ -352,107 +356,88 @@ FIX_PROC_HEAD( char_macro_use_fix )\n    you provide as the `c_fix_arg' argument.  */\n FIX_PROC_HEAD( char_macro_def_fix )\n {\n-  static const char zPatFmt[] =\n-#ifdef __STDC__\n-    /*\n-     *  Find a #define name and opening parenthesis\n-     */\n-    \"^#[ \\t]*define[ \\t]+[_A-Z][A-Z0-9_]*%s[A-Z]*\\\\(\"\n-    /*\n-     *  The next character must match a later one\n-     */\n-    \"([a-zA-Z])\"  /* rm[1] */\n-    /*\n-     *  now match over a comma, the argument list, intervening white space\n-     *  an opening parenthesis, and on through a single quote character\n-     */\n-    \"[ \\t]*,[^)]*\\\\)[ \\t]+\\\\([^']*'\"\n-    /*\n-     *  Match the character that must match the remembered char above\n-     */\n-    \"([a-zA-Z])'\"  /* rm[2] */\n-#else\n-    /*\n-     *  Indecipherable gobbeldygook:\n-     */\n-\n-    \"^#[ \\t]*define[ \\t]+[_A-Z][A-Z0-9_]*%s[A-Z]*\\\\(\\\n-([a-zA-Z])[ \\t]*,[^)]*\\\\)[ \\t]+\\\\([^']*'([a-zA-Z])'\"\n-#endif\n-    ;\n-\n-  char *pz_pat;\n-\n+  /* This regexp looks for any traditional-syntax #define (# in column 1).  */\n+  static const char pat[] =\n+    \"^#[ \\t]*define[ \\t]+\";\n   static regex_t re;\n-# define SUB_PAT_CT 2\n-  regmatch_t rm[SUB_PAT_CT+1];\n-  const char *p;\n-  int  rerr;\n \n-  if (p_fixd->patch_args[1] == NULL)\n-    {\n-      fprintf (stderr, \"%s needs macro-name-string argument\",\n-              p_fixd->fix_name);\n-      exit(3);\n-    }\n+  const char* str = p_fixd->patch_args[1];\n+  regmatch_t rm[1];\n+  const char *p, *limit;\n+  char arg;\n+  size_t len;\n \n-  asprintf (&pz_pat, zPatFmt, p_fixd->patch_args[1]);\n-  if (!pz_pat)\n+  if (str == NULL)\n     {\n-      fprintf (stderr, \"Virtual memory exhausted\\n\");\n-      exit(3);\n+      fprintf (stderr, zNeedsArg, p_fixd->fix_name, \"ioctl type\", 0);\n+      exit (EXIT_BROKEN);\n     }\n \n-  compile_re (pz_pat, &re, 1, \"macro pattern\", \"char_macro_def_fix\");\n+  len = strlen (str);\n+  compile_re (pat, &re, 1, \"macro pattern\", \"fix_char_macro_defines\");\n \n-#ifdef DEBUG\n-  if ((rerr = regexec (&re, text, SUB_PAT_CT+1, rm, 0)) != 0)\n+  for (p = text;\n+       regexec (&re, p, 1, rm, 0) == 0;\n+       p = limit + 1)\n     {\n-      fprintf( stderr, \"Match error %d:\\n%s\\n\", rerr, pz_pat );\n-      exit(3);\n-    }\n-#endif\n-\n-  free (pz_pat);\n-  \n-  while ((rerr = regexec (&re, text, SUB_PAT_CT+1, rm, 0)) == 0)\n-    {\n-      const char* pz = text + rm[2].rm_so;\n-\n-      /*\n-       *  Write up to, but not including, the opening single quote.\n-       */\n-      fwrite( text, 1, rm[2].rm_so-1, stdout );\n-\n-      /*\n-       *  The character inside the single quotes must match the\n-       *  first single-character macro argument\n-       */\n-      if (text[ rm[1].rm_so ] != *pz)\n-        {\n-          /*\n-           *  Advance text past what we have written out and continue\n-           */\n-          text = pz-1;\n-          continue;\n-        }\n-\n-      /*\n-       *  emit the now unquoted character\n-       */\n-      putchar( *pz );\n+      /* p + rm[0].rm_eo is the first character of the macro name.\n+\t Find the end of the macro replacement, and the STR we were\n+\t sent to look for within the name.  */\n+      p += rm[0].rm_eo;\n+      limit = p - 1;\n+      do\n+\t{\n+\t  limit = strchr (limit + 1, '\\n');\n+\t  if (!limit)\n+\t    goto done;\n+\t}\n+      while (limit[-1] == '\\\\');\n \n-      /*\n-       *  Point text to the character after the closing single quote\n-       */\n-      text = pz+2;\n+      do\n+\t{\n+\t  if (*p == str[0] && !strncmp (p+1, str+1, len-1))\n+\t    goto found;\n+\t  p++;\n+\t}\n+      while (isalpha (*p) || isalnum (*p) || *p == '_');\n+      /* Hit end of macro name without finding the string.  */\n+      continue;\n+\n+    found:\n+      /* Found STR in this macro name.  If the macro needs fixing,\n+\t there may be a few uppercase letters, then there will be an\n+\t open paren with _no_ intervening whitespace, and then a\n+\t single letter.  */\n+      while (isupper (*p) && p < limit) p++;\n+      if (*p++ != '(')\n+\tcontinue;\n+      if (!isalpha (*p))\n+\tcontinue;\n+      if (isalnum (p[1]) || p[1] == '_')\n+\tcontinue;\n+\n+      /* The character at P is the one to look for in the following\n+\t text.  */\n+      arg = *p;\n+      p += 2;\n+\n+      while (p < limit)\n+\t{\n+\t  if (p[-1] == '\\'' && p[0] == arg && p[1] == '\\'')\n+\t    {\n+\t      /* Remove the quotes from this use of ARG.  */\n+\t      p--;\n+\t      fwrite (text, 1, p - text, stdout);\n+\t      putchar (arg);\n+\t      p += 3;\n+\t      text = p;\n+\t    }\n+\t  else\n+\t    p++;\n+\t}\n     }\n-\n-  /*\n-   *  Emit the rest of the text\n-   */\n+ done:\n   fputs (text, stdout);\n-# undef SUB_PAT_CT\n }\n \n /* Fix for machine name #ifdefs that are not in the namespace reserved\n@@ -636,9 +621,9 @@ apply_fix( p_fixd, filname )\n         break;\n       if (--ct <= 0)\n         {\n-          fprintf (stderr, \"fixincludes error:  the `%s' fix is unknown\\n\",\n+          fprintf (stderr, \"fixincl error:  the `%s' fix is unknown\\n\",\n                    fixname );\n-          exit (3);\n+          exit (EXIT_BROKEN);\n         }\n       pfe++;\n     }"}, {"sha": "93698b3e87531b4b9601ae161e9ad7919d6be1b4", "filename": "gcc/fixinc/inclhack.def", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22e50c5bb9df7419a059c691e1993b217fe663f1/gcc%2Ffixinc%2Finclhack.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22e50c5bb9df7419a059c691e1993b217fe663f1/gcc%2Ffixinc%2Finclhack.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Finclhack.def?ref=22e50c5bb9df7419a059c691e1993b217fe663f1", "patch": "@@ -832,15 +832,16 @@ fix = {\n     select    = \"define[ \\t]+[A-Z0-9_]+CTRL\\\\([a-zA-Z],\";\n     c_fix     = char_macro_def;\n     c_fix_arg = \"CTRL\";\n-    test_text = \"#define BSD43_CTRL(n, x) (('n'<<8)+x)\";\n+    test_text = \"#define BSD43_CTRL(n, x) (('n'<<8)+x)\\n\"\n+                \"#define _CTRL(c) ('c'&037)\";\n };\n \n fix = {\n     hackname  = ctrl_quotes_use;\n     select    = \"define[ \\t]+[A-Z0-9_]+[ \\t]+[A-Z0-9_]+CTRL[ \\t]*\\\\( *[^,']\";\n     c_fix     = char_macro_use;\n     c_fix_arg = \"CTRL\";\n-    test_text = \"#define TIOCFOO BSD43_CTRL(T, 1)\";\n+    test_text = \"#define TCTRLFOO BSD43_CTRL(T, 1)\";\n };\n \n \n@@ -1097,7 +1098,9 @@ fix = {\n                 \"\\\\( *[^,']\";\n     c_fix     = char_macro_use;\n     c_fix_arg = \"IO\";\n-    test_text = \"#define TIOCFOO BSD43__IOWR(T, 1)\";\n+    test_text = \"#define TIOCFOO BSD43__IOWR(T, 1)\\n\"\n+                \"#define TIOCFOO \\\\\\\\\\n\"\n+                \"BSD43__IOWR(T, 1) /* Some are multi-line */\";\n };\n \n \n@@ -1796,22 +1799,6 @@ fix = {\n #endif\n \n \n-/*\n- *  Sony NEWSOS 5.0 does not support the complete ANSI C standard.\n- */\n-#ifdef SONY\n-fix = {\n-    hackname = sony_stdio;\n-    files    = stdio.h;\n-    test     = \" -x /bin/sony\";\n-    test     = \" ! -z \\\"`if /bin/sony ; then echo true ; fi`\\\"\";\n-    sed      = \"s/__filbuf/_filbuf/g\\n\"\n-               \"s/__flsbuf/_flsbuf/g\\n\"\n-               \"s/__iob/_iob/g\";\n-};\n-#endif\n-\n-\n /*\n  *  Incorrect #include in Sony News-OS 3.2.\n  */\n@@ -2719,9 +2706,9 @@ fix = {\n     select   = \"in_port_t\";\n #ifndef SVR5\n \tmach = \"*-*-sysv4*\";\n-\tmach = \"i[34567]86-*-sysv5*\";\n-\tmach = \"i[34567]86-*-udk*\";\n-\tmach = \"i[34567]86-*-solaris2.[0-4]\";\n+\tmach = \"i?86-*-sysv5*\";\n+\tmach = \"i?86-*-udk*\";\n+\tmach = \"i?86-*-solaris2.[0-4]\";\n \tmach = \"powerpcle-*-solaris2.[0-4]\";\n \tmach = \"sparc-*-solaris2.[0-4]\";\n #endif /* SVR5 */"}]}