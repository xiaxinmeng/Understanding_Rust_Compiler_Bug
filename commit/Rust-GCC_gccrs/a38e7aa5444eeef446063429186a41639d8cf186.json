{"sha": "a38e7aa5444eeef446063429186a41639d8cf186", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM4ZTdhYTU0NDRlZWVmNDQ2MDYzNDI5MTg2YTQxNjM5ZDhjZjE4Ng==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-05-21T06:19:50Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-05-21T06:19:50Z"}, "message": "gengtype.c (adjust_field_rtx_def): Use NOTE_KIND instead of NOTE_LINE_NUMBER...\n\n\n\t* gengtype.c (adjust_field_rtx_def): Use NOTE_KIND instead of\n\tNOTE_LINE_NUMBER; use NOTE_INSN_BASIC_BLOCK_P when possible.\n\t* ddg.c (create_ddg): LIkewise.\n\t* final.c (final): Remove hunk moving line numbernotes around since\n\tthey are no longer present at this stage.\n\t(final_scan_insn): Use NOTE_KIND instead of\n\tNOTE_LINE_NUMBER; use NOTE_INSN_BASIC_BLOCK_P when possible.\n\t(output_asm_label): Likewise.\n\t* reorg.c (dbr_schedule): Likewise.\n\t* haifa-sched.c (unlink_other_notes): Likewise.\n\t* mode-switching.c (optimize_mode_switching): Likewise.\n\t* graph.c (start_bb): Likewise.\n\t* rtl.def (NOTE): Update description.\n\t* jump.c (squeeze_notes): Delete.\n\t(mark_jump_label): Use NOTE_KIND instead of NOTE_LINE_NUMBER; use\n\tNOTE_INSN_BASIC_BLOCK_P when possible.\n\t* ifcvt.c (dead_or_predicable): Remove call of squeeze_notes.\n\t* dwarf2out.c (gen_label_die): Use NOTE_KIND instead of\n        NOTE_LINE_NUMBER; use NOTE_INSN_BASIC_BLOCK_P when possible.\n\t(dwarf2out_var_location): Likewise.\n\t* cfgbuild.c (make_edges): Likewise.\n\t(find_basic_blocks_1): Likewise.\n\t* function.c (reorder_blocks_1): Likewise.\n\t(epilogue_done): Likewise.\n\t(reposition_prologue_and_epilogue_notes): Likewise.\n\t* print-rtl.c (print_rtx): Likewise; drop code for printing line number\n\tnotes.\n\t(print_rtl): Likewise.\n\t(print_rtl_single): Likewise.\n\t* gcse.c (insert_insn_start_bb): Likewise.\n\t* alias.c (init_alias_analysis): Likewise.\n\t* calls.c (fixup_tail_calls): Likewise.\n\t* except.c (sjlj_emit_function_enter): Likewise.\n\t* emit-rtl.c (add_insn_after): Likeiwse.\n\t(emit_label_before): Likewise.\n\t(emit_label_after): Likewise.\n\t(emit_note_before, emit_note_after, emit_note): Update\n\tparameter to be enum insn_note; do not deal with source\n\tfiles.\n\t* cfgcleanup.c (merge_blocks_move_predecessor_nojumps):\n\tUse NOTE_KIND instead of NOTE_LINE_NUMBER; use NOTE_INSN_BASIC_BLOCK_P\n\twhen possible.\n\t(merge_blocks_move_successor_nojumps): Simplify now when\n\twe don't have BLOCK notes.\n\t(try_optimize_cfg): Likewise.\n\t* cfglayout.c (skip_insns_after_block): Likewise.\n\t(record_effective_endpoints): Likewise.\n\t(duplicate_insn_chain): Likewise.\n\t* varasm.c (output_constant_pool_1): Likewise.\n\t* sched-deps.c (sched_analyze): Likewise.\n\t* rtl.c (NOTE_INSN_MAX_isnt_negative_adjust_NOTE_INSN_BIAS):\n\tExterminate.\n\t(note_insn_name): Simplify now when NOTE_INSN_BIAS is gone.\n\t* rtl.h (NOTE_SOURCE_LOCATION, NOTE_EXPANDED_LOCATION): Exterminate.\n\t(SET_INSN_DELETED): Simplify.\n\t(NOTE_LINE_NUMBER): Exterminate.\n\t(NOTE_LINE_KIND): New.\n\t(NOTE_INSN_BASIC_BLOCK_P): Update.\n\t(enum insn_note): Simplify.\n\t(GET_NOTE_INSN_NAME) Simplify.\n\t(emit_note_before, emit_note_after, emit_note): Update prototype.\n\t(squeeze_notes): Remove.\n\t* sched-int.h (NOTE_NOT_BB_P): Update.\n\t* resource.c (mark_target_live_regs): Update.\n\t* sched-rgn.c (debug_dependencies): Update.\n\t* sched-vis.c (print_insn): Update.\n\t* config/alpha/alpha.c (alpha_handle_trap_shadows): Update.\n\t* config/i386/i386.c (ix86_output_function_epilogue): Update.\n\t* config/sh/sh.c (sh_adjust_unroll_max): Function dead since gcc 4.0.0.\n\t(TARGET_ADJUST_UNROLL_MAX): Likewise.\n\t(split_branches): Update.\n\t(sh_optimize_target_register_callee_saved): Remove hunk dead since gcc\n\t4.0.0.\n\t(sh_adjust_unroll_max): Exterminate.\n\t* config/c4x/c4x.c (c4x_reorg): Use SET_INSN_DELETED.\n\t* config/m68hc11/m68hc11.c (m68hc11_check_z_replacement): Likewise.\n\t(m68hc11_reorg): Likewise.\n\t* config/ia64/ia64.c (emit_insn_group_barriers): Update.\n\t(emit_predicate_relation_info): Update.\n\t(process_for_unwind_directive): Update.\n\t* config/rs6000/rs6000.c (rs6000_output_function_epilogue): Update.\n\t(output_call): Update.\n\t* config/pa/pa.c (output_lbranch): Update.\n\t(output_millicode_call): Update.\n\t(output_call): Update.\n\t(pa_combine_instructions): Update.\n\t* config/mips/mips.c (mips16_gp_pseudo_reg): Update.\n\t* config/bfin/bfin.c (gen_one_bundle): Update.\n\t* cfgrtl.c (can_delete_note_p): Update.\n\t(delete_insn): Update.\n\t(rtl_merge_blocks): Update.\n\t(commit_one_edge_insertion): Update.\n\t(rtl_verify_flow_info): Update.\n\t* stmt.c (expand_case): Do not call squeeze_notes.\n\nFrom-SVN: r124895", "tree": {"sha": "601cf2b2d4492c2b59d658e7f28b8058b1931c7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/601cf2b2d4492c2b59d658e7f28b8058b1931c7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a38e7aa5444eeef446063429186a41639d8cf186", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a38e7aa5444eeef446063429186a41639d8cf186", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a38e7aa5444eeef446063429186a41639d8cf186", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a38e7aa5444eeef446063429186a41639d8cf186/comments", "author": null, "committer": null, "parents": [{"sha": "631abdb20f4477e9e24160042d72b13b0ca2faa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/631abdb20f4477e9e24160042d72b13b0ca2faa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/631abdb20f4477e9e24160042d72b13b0ca2faa8"}], "stats": {"total": 877, "additions": 226, "deletions": 651}, "files": [{"sha": "3d358c23d53b6bc9617fafe0cd838994a4dd88f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -1,3 +1,100 @@\n+2007-05-20  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gengtype.c (adjust_field_rtx_def): Use NOTE_KIND instead of\n+\tNOTE_LINE_NUMBER; use NOTE_INSN_BASIC_BLOCK_P when possible.\n+\t* ddg.c (create_ddg): LIkewise.\n+\t* final.c (final): Remove hunk moving line numbernotes around since\n+\tthey are no longer present at this stage.\n+\t(final_scan_insn): Use NOTE_KIND instead of\n+\tNOTE_LINE_NUMBER; use NOTE_INSN_BASIC_BLOCK_P when possible.\n+\t(output_asm_label): Likewise.\n+\t* reorg.c (dbr_schedule): Likewise.\n+\t* haifa-sched.c (unlink_other_notes): Likewise.\n+\t* mode-switching.c (optimize_mode_switching): Likewise.\n+\t* graph.c (start_bb): Likewise.\n+\t* rtl.def (NOTE): Update description.\n+\t* jump.c (squeeze_notes): Delete.\n+\t(mark_jump_label): Use NOTE_KIND instead of NOTE_LINE_NUMBER; use\n+\tNOTE_INSN_BASIC_BLOCK_P when possible.\n+\t* ifcvt.c (dead_or_predicable): Remove call of squeeze_notes.\n+\t* dwarf2out.c (gen_label_die): Use NOTE_KIND instead of\n+        NOTE_LINE_NUMBER; use NOTE_INSN_BASIC_BLOCK_P when possible.\n+\t(dwarf2out_var_location): Likewise.\n+\t* cfgbuild.c (make_edges): Likewise.\n+\t(find_basic_blocks_1): Likewise.\n+\t* function.c (reorder_blocks_1): Likewise.\n+\t(epilogue_done): Likewise.\n+\t(reposition_prologue_and_epilogue_notes): Likewise.\n+\t* print-rtl.c (print_rtx): Likewise; drop code for printing line number\n+\tnotes.\n+\t(print_rtl): Likewise.\n+\t(print_rtl_single): Likewise.\n+\t* gcse.c (insert_insn_start_bb): Likewise.\n+\t* alias.c (init_alias_analysis): Likewise.\n+\t* calls.c (fixup_tail_calls): Likewise.\n+\t* except.c (sjlj_emit_function_enter): Likewise.\n+\t* emit-rtl.c (add_insn_after): Likeiwse.\n+\t(emit_label_before): Likewise.\n+\t(emit_label_after): Likewise.\n+\t(emit_note_before, emit_note_after, emit_note): Update\n+\tparameter to be enum insn_note; do not deal with source\n+\tfiles.\n+\t* cfgcleanup.c (merge_blocks_move_predecessor_nojumps):\n+\tUse NOTE_KIND instead of NOTE_LINE_NUMBER; use NOTE_INSN_BASIC_BLOCK_P\n+\twhen possible.\n+\t(merge_blocks_move_successor_nojumps): Simplify now when\n+\twe don't have BLOCK notes.\n+\t(try_optimize_cfg): Likewise.\n+\t* cfglayout.c (skip_insns_after_block): Likewise.\n+\t(record_effective_endpoints): Likewise.\n+\t(duplicate_insn_chain): Likewise.\n+\t* varasm.c (output_constant_pool_1): Likewise.\n+\t* sched-deps.c (sched_analyze): Likewise.\n+\t* rtl.c (NOTE_INSN_MAX_isnt_negative_adjust_NOTE_INSN_BIAS):\n+\tExterminate.\n+\t(note_insn_name): Simplify now when NOTE_INSN_BIAS is gone.\n+\t* rtl.h (NOTE_SOURCE_LOCATION, NOTE_EXPANDED_LOCATION): Exterminate.\n+\t(SET_INSN_DELETED): Simplify.\n+\t(NOTE_LINE_NUMBER): Exterminate.\n+\t(NOTE_LINE_KIND): New.\n+\t(NOTE_INSN_BASIC_BLOCK_P): Update.\n+\t(enum insn_note): Simplify.\n+\t(GET_NOTE_INSN_NAME) Simplify.\n+\t(emit_note_before, emit_note_after, emit_note): Update prototype.\n+\t(squeeze_notes): Remove.\n+\t* sched-int.h (NOTE_NOT_BB_P): Update.\n+\t* resource.c (mark_target_live_regs): Update.\n+\t* sched-rgn.c (debug_dependencies): Update.\n+\t* sched-vis.c (print_insn): Update.\n+\t* config/alpha/alpha.c (alpha_handle_trap_shadows): Update.\n+\t* config/i386/i386.c (ix86_output_function_epilogue): Update.\n+\t* config/sh/sh.c (sh_adjust_unroll_max): Function dead since gcc 4.0.0.\n+\t(TARGET_ADJUST_UNROLL_MAX): Likewise.\n+\t(split_branches): Update.\n+\t(sh_optimize_target_register_callee_saved): Remove hunk dead since gcc\n+\t4.0.0.\n+\t(sh_adjust_unroll_max): Exterminate.\n+\t* config/c4x/c4x.c (c4x_reorg): Use SET_INSN_DELETED.\n+\t* config/m68hc11/m68hc11.c (m68hc11_check_z_replacement): Likewise.\n+\t(m68hc11_reorg): Likewise.\n+\t* config/ia64/ia64.c (emit_insn_group_barriers): Update.\n+\t(emit_predicate_relation_info): Update.\n+\t(process_for_unwind_directive): Update.\n+\t* config/rs6000/rs6000.c (rs6000_output_function_epilogue): Update.\n+\t(output_call): Update.\n+\t* config/pa/pa.c (output_lbranch): Update.\n+\t(output_millicode_call): Update.\n+\t(output_call): Update.\n+\t(pa_combine_instructions): Update.\n+\t* config/mips/mips.c (mips16_gp_pseudo_reg): Update.\n+\t* config/bfin/bfin.c (gen_one_bundle): Update.\n+\t* cfgrtl.c (can_delete_note_p): Update.\n+\t(delete_insn): Update.\n+\t(rtl_merge_blocks): Update.\n+\t(commit_one_edge_insertion): Update.\n+\t(rtl_verify_flow_info): Update.\n+\t* stmt.c (expand_case): Do not call squeeze_notes.\n+\n 2007-05-20  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \t\n \tPR middle-end/7651"}, {"sha": "d003de92b3fad119ac18c81a755123aa41649bad", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -2546,7 +2546,7 @@ init_alias_analysis (void)\n \t\t}\n \t    }\n \t  else if (NOTE_P (insn)\n-\t\t   && NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG)\n+\t\t   && NOTE_KIND (insn) == NOTE_INSN_FUNCTION_BEG)\n \t    copying_arguments = false;\n \t}\n "}, {"sha": "4089bb14ea13b86a7738170d7904140506700380", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -3173,7 +3173,7 @@ fixup_tail_calls (void)\n       /* There are never REG_EQUIV notes for the incoming arguments\n \t after the NOTE_INSN_FUNCTION_BEG note, so stop if we see it.  */\n       if (NOTE_P (insn)\n-\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG)\n+\t  && NOTE_KIND (insn) == NOTE_INSN_FUNCTION_BEG)\n \tbreak;\n \n       note = find_reg_note (insn, REG_EQUIV, 0);"}, {"sha": "e564e8b89e3782b64fa09f04e474294c3a59045b", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -402,7 +402,7 @@ make_edges (basic_block min, basic_block max, int update_p)\n \n       while (insn\n \t     && NOTE_P (insn)\n-\t     && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK)\n+\t     && NOTE_KIND (insn) != NOTE_INSN_BASIC_BLOCK)\n \tinsn = NEXT_INSN (insn);\n \n       if (!insn)\n@@ -469,22 +469,18 @@ find_basic_blocks_1 (rtx f)\n       switch (code)\n \t{\n \tcase NOTE:\n-\t  {\n-\t    int kind = NOTE_LINE_NUMBER (insn);\n-\n-\t    /* Look for basic block notes with which to keep the\n-\t       basic_block_info pointers stable.  Unthread the note now;\n-\t       we'll put it back at the right place in create_basic_block.\n-\t       Or not at all if we've already found a note in this block.  */\n-\t    if (kind == NOTE_INSN_BASIC_BLOCK)\n-\t      {\n-\t\tif (bb_note == NULL_RTX)\n-\t\t  bb_note = insn;\n-\t\telse\n-\t\t  next = delete_insn (insn);\n-\t      }\n-\t    break;\n-\t  }\n+\t  /* Look for basic block notes with which to keep the\n+\t     basic_block_info pointers stable.  Unthread the note now;\n+\t     we'll put it back at the right place in create_basic_block.\n+\t     Or not at all if we've already found a note in this block.  */\n+\t  if (NOTE_INSN_BASIC_BLOCK_P (insn))\n+\t    {\n+\t      if (bb_note == NULL_RTX)\n+\t\tbb_note = insn;\n+\t      else\n+\t\tnext = delete_insn (insn);\n+\t    }\n+\t  break;\n \n \tcase CODE_LABEL:\n \tcase JUMP_INSN:"}, {"sha": "1a337841572700209ba555669049fbb801947132", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -623,7 +623,6 @@ static void\n merge_blocks_move_predecessor_nojumps (basic_block a, basic_block b)\n {\n   rtx barrier;\n-  bool only_notes;\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n@@ -642,16 +641,6 @@ merge_blocks_move_predecessor_nojumps (basic_block a, basic_block b)\n   gcc_assert (BARRIER_P (barrier));\n   delete_insn (barrier);\n \n-  /* Move block and loop notes out of the chain so that we do not\n-     disturb their order.\n-\n-     ??? A better solution would be to squeeze out all the non-nested notes\n-     and adjust the block trees appropriately.   Even better would be to have\n-     a tighter connection between block trees and rtl so that this is not\n-     necessary.  */\n-  only_notes = squeeze_notes (&BB_HEAD (a), &BB_END (a));\n-  gcc_assert (!only_notes);\n-\n   /* Scramble the insn chain.  */\n   if (BB_END (a) != PREV_INSN (BB_HEAD (b)))\n     reorder_insns_nobb (BB_HEAD (a), BB_END (a), PREV_INSN (BB_HEAD (b)));\n@@ -679,7 +668,6 @@ merge_blocks_move_successor_nojumps (basic_block a, basic_block b)\n {\n   rtx barrier, real_b_end;\n   rtx label, table;\n-  bool only_notes;\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n@@ -709,16 +697,6 @@ merge_blocks_move_successor_nojumps (basic_block a, basic_block b)\n   if (barrier && BARRIER_P (barrier))\n     delete_insn (barrier);\n \n-  /* Move block and loop notes out of the chain so that we do not\n-     disturb their order.\n-\n-     ??? A better solution would be to squeeze out all the non-nested notes\n-     and adjust the block trees appropriately.   Even better would be to have\n-     a tighter connection between block trees and rtl so that this is not\n-     necessary.  */\n-  only_notes = squeeze_notes (&BB_HEAD (b), &BB_END (b));\n-  gcc_assert (!only_notes);\n-\n \n   /* Scramble the insn chain.  */\n   reorder_insns_nobb (BB_HEAD (b), BB_END (b), BB_END (a));\n@@ -2028,7 +2006,7 @@ try_optimize_cfg (int mode)\n \t\t  delete_insn_chain (label, label);\n \t\t  /* In the case label is undeletable, move it after the\n \t\t     BASIC_BLOCK note.  */\n-\t\t  if (NOTE_LINE_NUMBER (BB_HEAD (b)) == NOTE_INSN_DELETED_LABEL)\n+\t\t  if (NOTE_KIND (BB_HEAD (b)) == NOTE_INSN_DELETED_LABEL)\n \t\t    {\n \t\t      rtx bb_note = NEXT_INSN (BB_HEAD (b));\n "}, {"sha": "7e309c149e222989d2353ec2e5816687b65b1af0", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -98,15 +98,11 @@ skip_insns_after_block (basic_block bb)\n \t  continue;\n \n \tcase NOTE:\n-\t  switch (NOTE_LINE_NUMBER (insn))\n+\t  switch (NOTE_KIND (insn))\n \t    {\n \t    case NOTE_INSN_BLOCK_END:\n-\t      last_insn = insn;\n-\t      continue;\n-\t    case NOTE_INSN_DELETED:\n-\t    case NOTE_INSN_DELETED_LABEL:\n+\t      gcc_unreachable ();\n \t      continue;\n-\n \t    default:\n \t      continue;\n \t      break;\n@@ -146,9 +142,11 @@ skip_insns_after_block (basic_block bb)\n     {\n       prev = PREV_INSN (insn);\n       if (NOTE_P (insn))\n-\tswitch (NOTE_LINE_NUMBER (insn))\n+\tswitch (NOTE_KIND (insn))\n \t  {\n \t  case NOTE_INSN_BLOCK_END:\n+\t    gcc_unreachable ();\n+\t    break;\n \t  case NOTE_INSN_DELETED:\n \t  case NOTE_INSN_DELETED_LABEL:\n \t    continue;\n@@ -191,7 +189,7 @@ record_effective_endpoints (void)\n   for (insn = get_insns ();\n        insn\n        && NOTE_P (insn)\n-       && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK;\n+       && NOTE_KIND (insn) != NOTE_INSN_BASIC_BLOCK;\n        insn = NEXT_INSN (insn))\n     continue;\n   /* No basic blocks at all?  */\n@@ -1033,7 +1031,7 @@ duplicate_insn_chain (rtx from, rtx to)\n \t  break;\n \n \tcase NOTE:\n-\t  switch (NOTE_LINE_NUMBER (insn))\n+\t  switch (NOTE_KIND (insn))\n \t    {\n \t      /* In case prologue is empty and function contain label\n \t\t in first BB, we may want to copy the block.  */\n@@ -1059,11 +1057,7 @@ duplicate_insn_chain (rtx from, rtx to)\n \t    default:\n \t      /* All other notes should have already been eliminated.\n \t       */\n-\t      gcc_assert (NOTE_LINE_NUMBER (insn) >= 0);\n-\n-\t      /* It is possible that no_line_number is set and the note\n-\t\t won't be emitted.  */\n-\t      emit_note_copy (insn);\n+\t      gcc_unreachable ();\n \t    }\n \t  break;\n \tdefault:"}, {"sha": "4abb8a1766f349ce103c36e835099ba99ad988ce", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -85,8 +85,8 @@ static void rtl_make_forwarder_block (edge);\n static int\n can_delete_note_p (rtx note)\n {\n-  return (NOTE_LINE_NUMBER (note) == NOTE_INSN_DELETED\n-\t  || NOTE_LINE_NUMBER (note) == NOTE_INSN_BASIC_BLOCK);\n+  return (NOTE_KIND (note) == NOTE_INSN_DELETED\n+\t  || NOTE_KIND (note) == NOTE_INSN_BASIC_BLOCK);\n }\n \n /* True if a given label can be deleted.  */\n@@ -120,7 +120,7 @@ delete_insn (rtx insn)\n \n \t  really_delete = false;\n \t  PUT_CODE (insn, NOTE);\n-\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED_LABEL;\n+\t  NOTE_KIND (insn) = NOTE_INSN_DELETED_LABEL;\n \t  NOTE_DELETED_LABEL_NAME (insn) = name;\n \t}\n \n@@ -580,7 +580,7 @@ rtl_merge_blocks (basic_block a, basic_block b)\n \n       for (prev = PREV_INSN (a_end); ; prev = PREV_INSN (prev))\n \tif (!NOTE_P (prev)\n-\t    || NOTE_LINE_NUMBER (prev) == NOTE_INSN_BASIC_BLOCK\n+\t    || NOTE_INSN_BASIC_BLOCK_P (prev)\n \t    || prev == BB_HEAD (a))\n \t  break;\n \n@@ -1408,8 +1408,7 @@ commit_one_edge_insertion (edge e)\n \t      bb_note = NULL_RTX;\n \t      for (cur_insn = BB_HEAD (bb); cur_insn != NEXT_INSN (BB_END (bb));\n \t\t   cur_insn = NEXT_INSN (cur_insn))\n-\t\tif (NOTE_P (cur_insn)\n-\t\t    && NOTE_LINE_NUMBER (cur_insn) == NOTE_INSN_BASIC_BLOCK)\n+\t\tif (NOTE_INSN_BASIC_BLOCK_P (cur_insn))\n \t\t  {\n \t\t    bb_note = cur_insn;\n \t\t    break;\n@@ -1969,8 +1968,7 @@ rtl_verify_flow_info (void)\n \t  for (insn = BB_END (bb); !insn || !BARRIER_P (insn);\n \t       insn = NEXT_INSN (insn))\n \t    if (!insn\n-\t\t|| (NOTE_P (insn)\n-\t\t    && NOTE_LINE_NUMBER (insn) == NOTE_INSN_BASIC_BLOCK))\n+\t\t|| NOTE_INSN_BASIC_BLOCK_P (insn))\n \t\t{\n \t\t  error (\"missing barrier after block %i\", bb->index);\n \t\t  err = 1;"}, {"sha": "bc2e8046911e26e16215701603996530c0900930", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -8593,7 +8593,7 @@ alpha_handle_trap_shadows (void)\n     {\n       if (GET_CODE (i) == NOTE)\n \t{\n-\t  switch (NOTE_LINE_NUMBER (i))\n+\t  switch (NOTE_KIND (i))\n \t    {\n \t    case NOTE_INSN_EH_REGION_BEG:\n \t      exception_nesting++;"}, {"sha": "60fe51d8645daabd3e7c11bd6e6762ce2f8fc597", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -4111,7 +4111,7 @@ gen_one_bundle (rtx slot[3])\n       while (t != slot[1])\n \t{\n \t  if (GET_CODE (t) != NOTE\n-\t      || NOTE_LINE_NUMBER (t) != NOTE_INSN_DELETED)\n+\t      || NOTE_KIND (t) != NOTE_INSN_DELETED)\n \t    return false;\n \t  t = NEXT_INSN (t);\n \t}\n@@ -4122,7 +4122,7 @@ gen_one_bundle (rtx slot[3])\n       while (t != slot[2])\n \t{\n \t  if (GET_CODE (t) != NOTE\n-\t      || NOTE_LINE_NUMBER (t) != NOTE_INSN_DELETED)\n+\t      || NOTE_KIND (t) != NOTE_INSN_DELETED)\n \t    return false;\n \t  t = NEXT_INSN (t);\n \t}"}, {"sha": "0f42accf596805a57ef8e184805988eb91821741", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -2443,11 +2443,7 @@ c4x_reorg (void)\n \t     with only the 'deleted' bit set.  Transform it into a note\n \t     to avoid confusion of subsequent processing.  */\n \t  if (INSN_DELETED_P (old))\n-\t    {\n-\t      PUT_CODE (old, NOTE);\n-\t      NOTE_LINE_NUMBER (old) = NOTE_INSN_DELETED;\n-\t      NOTE_SOURCE_FILE (old) = 0;\n-\t    }\n+\t    SET_INSN_DELETED (old);\n \t}\n     }\n }"}, {"sha": "13d0b9eba528fe5c197916f23376be05916a6348", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -6256,12 +6256,12 @@ ix86_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n     rtx insn = get_last_insn ();\n     while (insn\n \t   && NOTE_P (insn)\n-\t   && NOTE_LINE_NUMBER (insn) != NOTE_INSN_DELETED_LABEL)\n+\t   && NOTE_KIND (insn) != NOTE_INSN_DELETED_LABEL)\n       insn = PREV_INSN (insn);\n     if (insn\n \t&& (LABEL_P (insn)\n \t    || (NOTE_P (insn)\n-\t\t&& NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED_LABEL)))\n+\t\t&& NOTE_KIND (insn) == NOTE_INSN_DELETED_LABEL)))\n       fputs (\"\\tnop\\n\", file);\n   }\n #endif"}, {"sha": "52179d9f5b6eea3f5ea40c9aa5db677461a5c5c5", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -5960,7 +5960,7 @@ emit_insn_group_barriers (FILE *dump)\n \t  insns_since_last_label = 0;\n \t}\n       else if (GET_CODE (insn) == NOTE\n-\t       && NOTE_LINE_NUMBER (insn) == NOTE_INSN_BASIC_BLOCK)\n+\t       && NOTE_KIND (insn) == NOTE_INSN_BASIC_BLOCK)\n \t{\n \t  if (insns_since_last_label)\n \t    last_label = insn;\n@@ -8332,8 +8332,7 @@ emit_predicate_relation_info (void)\n       /* We only need such notes at code labels.  */\n       if (GET_CODE (head) != CODE_LABEL)\n \tcontinue;\n-      if (GET_CODE (NEXT_INSN (head)) == NOTE\n-\t  && NOTE_LINE_NUMBER (NEXT_INSN (head)) == NOTE_INSN_BASIC_BLOCK)\n+      if (NOTE_INSN_BASIC_BLOCK_P (NEXT_INSN (head)) == NOTE_INSN_BASIC_BLOCK)\n \thead = NEXT_INSN (head);\n \n       /* Skip p0, which may be thought to be live due to (reg:DI p0)\n@@ -8969,8 +8968,7 @@ process_for_unwind_directive (FILE *asm_out_file, rtx insn)\n     {\n       rtx pat;\n \n-      if (GET_CODE (insn) == NOTE\n-\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_BASIC_BLOCK)\n+      if (NOTE_INSN_BASIC_BLOCK_P (insn) == NOTE_INSN_BASIC_BLOCK)\n \t{\n \t  last_block = NOTE_BASIC_BLOCK (insn)->next_bb == EXIT_BLOCK_PTR;\n "}, {"sha": "655816e49d66f1a106500de11f1217bbe21788f7", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -4247,9 +4247,7 @@ m68hc11_check_z_replacement (rtx insn, struct replace_info *info)\n \t\t  info->must_restore_reg = 0;\n \t\t  info->found_call = 1;\n \t\t  info->can_use_d = 0;\n-\t\t  PUT_CODE (insn, NOTE);\n-\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t\t  NOTE_SOURCE_FILE (insn) = 0;\n+\t\t  SET_INSN_DELETED (insn);\n \t\t  info->last = NEXT_INSN (insn);\n \t\t  return 0;\n \t\t}\n@@ -4330,9 +4328,7 @@ m68hc11_check_z_replacement (rtx insn, struct replace_info *info)\n \t\t  info->must_restore_reg = 0;\n \t\t  info->found_call = 1;\n \t\t  info->can_use_d = 0;\n-\t\t  PUT_CODE (insn, NOTE);\n-\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t\t  NOTE_SOURCE_FILE (insn) = 0;\n+\t\t  SET_INSN_DELETED (insn);\n \t\t  info->last = NEXT_INSN (insn);\n \t\t  return 0;\n \t\t}\n@@ -5098,9 +5094,7 @@ m68hc11_reorg (void)\n \tif (GET_CODE (body) == SET\n \t    && rtx_equal_p (SET_SRC (body), SET_DEST (body)))\n \t  {\n-\t    PUT_CODE (insn, NOTE);\n-\t    NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t    NOTE_SOURCE_FILE (insn) = 0;\n+\t    SET_INSN_DELETED  (insn);\n \t    continue;\n \t  }\n       }"}, {"sha": "37ff3c522c2b99f68d327db1430f4f7a1b6cda04", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -7955,7 +7955,7 @@ mips16_gp_pseudo_reg (void)\n          note, so that it will be integrated.  */\n       for (scan = get_insns (); scan != NULL_RTX; scan = NEXT_INSN (scan))\n \tif (NOTE_P (scan)\n-\t    && NOTE_LINE_NUMBER (scan) == NOTE_INSN_FUNCTION_BEG)\n+\t    && NOTE_KIND (scan) == NOTE_INSN_FUNCTION_BEG)\n \t  break;\n       if (scan == NULL_RTX)\n \tscan = get_insns ();"}, {"sha": "82951d614638bfd3337ce23a95525c79b4fa4bd3", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -6201,9 +6201,7 @@ output_lbranch (rtx dest, rtx insn, int xdelay)\n \t\t       optimize, 0, NULL);\n \n       /* Now delete the delay insn.  */\n-      PUT_CODE (NEXT_INSN (insn), NOTE);\n-      NOTE_LINE_NUMBER (NEXT_INSN (insn)) = NOTE_INSN_DELETED;\n-      NOTE_SOURCE_FILE (NEXT_INSN (insn)) = 0;\n+      SET_INSN_DELETED (NEXT_INSN (insn));\n     }\n \n   /* Output an insn to save %r1.  The runtime documentation doesn't\n@@ -7219,9 +7217,7 @@ output_millicode_call (rtx insn, rtx call_dest)\n     output_asm_insn (\"nop\\n\\tb,n %0\", xoperands);\n \n   /* Delete the jump.  */\n-  PUT_CODE (NEXT_INSN (insn), NOTE);\n-  NOTE_LINE_NUMBER (NEXT_INSN (insn)) = NOTE_INSN_DELETED;\n-  NOTE_SOURCE_FILE (NEXT_INSN (insn)) = 0;\n+  SET_INSN_DELETED (NEXT_INSN (insn));\n \n   return \"\";\n }\n@@ -7364,9 +7360,7 @@ output_call (rtx insn, rtx call_dest, int sibcall)\n \t\t\t       optimize, 0, NULL);\n \n \t      /* Now delete the delay insn.  */\n-\t      PUT_CODE (NEXT_INSN (insn), NOTE);\n-\t      NOTE_LINE_NUMBER (NEXT_INSN (insn)) = NOTE_INSN_DELETED;\n-\t      NOTE_SOURCE_FILE (NEXT_INSN (insn)) = 0;\n+\t      SET_INSN_DELETED (NEXT_INSN (insn));\n \t      delay_insn_deleted = 1;\n \t    }\n \n@@ -7414,9 +7408,7 @@ output_call (rtx insn, rtx call_dest, int sibcall)\n \t\t\t       NULL);\n \n \t      /* Now delete the delay insn.  */\n-\t      PUT_CODE (NEXT_INSN (insn), NOTE);\n-\t      NOTE_LINE_NUMBER (NEXT_INSN (insn)) = NOTE_INSN_DELETED;\n-\t      NOTE_SOURCE_FILE (NEXT_INSN (insn)) = 0;\n+\t      SET_INSN_DELETED (NEXT_INSN (insn));\n \t      delay_insn_deleted = 1;\n \t    }\n \n@@ -7601,9 +7593,7 @@ output_call (rtx insn, rtx call_dest, int sibcall)\n     output_asm_insn (\"b,n %0\", xoperands);\n \n   /* Delete the jump.  */\n-  PUT_CODE (NEXT_INSN (insn), NOTE);\n-  NOTE_LINE_NUMBER (NEXT_INSN (insn)) = NOTE_INSN_DELETED;\n-  NOTE_SOURCE_FILE (NEXT_INSN (insn)) = 0;\n+  SET_INSN_DELETED (NEXT_INSN (insn));\n \n   return \"\";\n }\n@@ -8854,9 +8844,7 @@ pa_combine_instructions (void)\n \t\t\t\t\t    PATTERN (floater))),\n \t\t\t\tanchor);\n \n-\t      PUT_CODE (anchor, NOTE);\n-\t      NOTE_LINE_NUMBER (anchor) = NOTE_INSN_DELETED;\n-\t      NOTE_SOURCE_FILE (anchor) = 0;\n+\t      SET_INSN_DELETED (anchor);\n \n \t      /* Emit a special USE insn for FLOATER, then delete\n \t\t the floating insn.  */\n@@ -8878,9 +8866,7 @@ pa_combine_instructions (void)\n \t\t\t\t\t anchor);\n \n \t      JUMP_LABEL (temp) = JUMP_LABEL (anchor);\n-\t      PUT_CODE (anchor, NOTE);\n-\t      NOTE_LINE_NUMBER (anchor) = NOTE_INSN_DELETED;\n-\t      NOTE_SOURCE_FILE (anchor) = 0;\n+\t      SET_INSN_DELETED (anchor);\n \n \t      /* Emit a special USE insn for FLOATER, then delete\n \t\t the floating insn.  */"}, {"sha": "2d7b2f2a2ec212a10429e2f79978fef68aea15f3", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -15763,12 +15763,12 @@ rs6000_output_function_epilogue (FILE *file,\n     rtx insn = get_last_insn ();\n     while (insn\n \t   && NOTE_P (insn)\n-\t   && NOTE_LINE_NUMBER (insn) != NOTE_INSN_DELETED_LABEL)\n+\t   && NOTE_KIND (insn) != NOTE_INSN_DELETED_LABEL)\n       insn = PREV_INSN (insn);\n     if (insn\n \t&& (LABEL_P (insn)\n \t    || (NOTE_P (insn)\n-\t\t&& NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED_LABEL)))\n+\t\t&& NOTE_KIND (insn) == NOTE_INSN_DELETED_LABEL)))\n       fputs (\"\\tnop\\n\", file);\n   }\n #endif\n@@ -19215,17 +19215,13 @@ output_call (rtx insn, rtx *operands, int dest_operand_number,\n \n       if (no_previous_def (funname))\n \t{\n-\t  int line_number = 0;\n \t  rtx label_rtx = gen_label_rtx ();\n \t  char *label_buf, temp_buf[256];\n \t  ASM_GENERATE_INTERNAL_LABEL (temp_buf, \"L\",\n \t\t\t\t       CODE_LABEL_NUMBER (label_rtx));\n \t  label_buf = temp_buf[0] == '*' ? temp_buf + 1 : temp_buf;\n \t  labelname = get_identifier (label_buf);\n-\t  for (; insn && GET_CODE (insn) != NOTE; insn = PREV_INSN (insn));\n-\t  if (insn)\n-\t    line_number = NOTE_LINE_NUMBER (insn);\n-\t  add_compiler_branch_island (labelname, funname, line_number);\n+\t  add_compiler_branch_island (labelname, funname, insn_line (insn));\n \t}\n       else\n \tlabelname = get_prev_label (funname);"}, {"sha": "261ea7e56a6fecfdc2f875d79e58017b47257e19", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 304, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -242,9 +242,6 @@ static bool unspec_caller_rtx_p (rtx);\n static bool sh_cannot_copy_insn_p (rtx);\n static bool sh_rtx_costs (rtx, int, int, int *);\n static int sh_address_cost (rtx);\n-#ifdef TARGET_ADJUST_UNROLL_MAX\n-static int sh_adjust_unroll_max (struct loop *, int, int, int, int);\n-#endif\n static int sh_pr_n_sets (void);\n static rtx sh_allocate_initial_value (rtx);\n static int shmedia_target_regs_stack_space (HARD_REG_SET *);\n@@ -469,11 +466,6 @@ static int hard_regs_intersect_p (HARD_REG_SET *, HARD_REG_SET *);\n \n #endif /* SYMBIAN */\n \n-#ifdef TARGET_ADJUST_UNROLL_MAX\n-#undef TARGET_ADJUST_UNROLL_MAX\n-#define TARGET_ADJUST_UNROLL_MAX sh_adjust_unroll_max\n-#endif\n-\n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD sh_secondary_reload\n \n@@ -5240,9 +5232,7 @@ split_branches (rtx first)\n       {\n \t/* Shorten_branches would split this instruction again,\n \t   so transform it into a note.  */\n-\tPUT_CODE (insn, NOTE);\n-\tNOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\tNOTE_SOURCE_FILE (insn) = 0;\n+\tSET_INSN_DELETED (insn);\n       }\n     else if (GET_CODE (insn) == JUMP_INSN\n \t     /* Don't mess with ADDR_DIFF_VEC */\n@@ -9432,30 +9422,6 @@ sh_optimize_target_register_callee_saved (bool after_prologue_epilogue_gen)\n     return 0;\n   if (calc_live_regs (&dummy) >= 6 * 8)\n     return 1;\n-#if 0\n-  /* This is a borderline case.  See if we got a nested loop, or a loop\n-     with a call, or with more than 4 labels inside.  */\n-  for (insn = get_insns(); insn; insn = NEXT_INSN (insn))\n-    {\n-      if (GET_CODE (insn) == NOTE\n-\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\t{\n-\t  int labels = 0;\n-\n-\t  do\n-\t    {\n-\t      insn = NEXT_INSN (insn);\n-\t      if ((GET_CODE (insn) == NOTE\n-\t\t   && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\t\t  || GET_CODE (insn) == CALL_INSN\n-\t\t  || (GET_CODE (insn) == CODE_LABEL && ++labels > 4))\n-\t\treturn 1;\n-\t    }\n-\t  while (GET_CODE (insn) != NOTE\n-\t\t || NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_END);\n-\t}\n-    }\n-#endif\n   return 0;\n }\n \n@@ -10692,275 +10658,6 @@ hard_regs_intersect_p (HARD_REG_SET *a, HARD_REG_SET *b)\n   return 0;\n }\n \n-#ifdef TARGET_ADJUST_UNROLL_MAX\n-static int\n-sh_adjust_unroll_max (struct loop * loop, int insn_count,\n-\t\t      int max_unrolled_insns, int strength_reduce_p,\n-\t\t      int unroll_type)\n-{\n-/* This doesn't work in 4.0 because the old unroller & loop.h  is gone.  */\n-  if (TARGET_ADJUST_UNROLL && TARGET_SHMEDIA)\n-    {\n-      /* Throttle back loop unrolling so that the costs of using more\n-\t targets than the eight target register we have don't outweigh\n-\t the benefits of unrolling.  */\n-      rtx insn;\n-      int n_labels = 0, n_calls = 0, n_exit_dest = 0, n_inner_loops = -1;\n-      int n_barriers = 0;\n-      rtx dest;\n-      int i;\n-      rtx exit_dest[8];\n-      int threshold;\n-      int unroll_benefit = 0, mem_latency = 0;\n-      int base_cost, best_cost, cost;\n-      int factor, best_factor;\n-      int n_dest;\n-      unsigned max_iterations = 32767;\n-      int n_iterations;\n-      int need_precond = 0, precond = 0;\n-      basic_block * bbs = get_loop_body (loop);\n-      struct niter_desc *desc;\n-\n-      /* Assume that all labels inside the loop are used from inside the\n-\t loop.  If the loop has multiple entry points, it is unlikely to\n-\t be unrolled anyways.\n-\t Also assume that all calls are to different functions.  That is\n-\t somewhat pessimistic, but if you have lots of calls, unrolling the\n-\t loop is not likely to gain you much in the first place.  */\n-      i = loop->num_nodes - 1;\n-      for (insn = BB_HEAD (bbs[i]); ; )\n-\t{\n-\t  if (GET_CODE (insn) == CODE_LABEL)\n-\t    n_labels++;\n-\t  else if (GET_CODE (insn) == CALL_INSN)\n-\t    n_calls++;\n-\t  else if (GET_CODE (insn) == NOTE\n-\t\t   && NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\t    n_inner_loops++;\n-\t  else if (GET_CODE (insn) == BARRIER)\n-\t    n_barriers++;\n-\t  if (insn != BB_END (bbs[i]))\n-\t    insn = NEXT_INSN (insn);\n-\t  else if (--i >= 0)\n-\t    insn = BB_HEAD (bbs[i]);\n-\t   else\n-\t    break;\n-\t}\n-      free (bbs);\n-      /* One label for the loop top is normal, and it won't be duplicated by\n-\t unrolling.  */\n-      if (n_labels <= 1)\n-\treturn max_unrolled_insns;\n-      if (n_inner_loops > 0)\n-\treturn 0;\n-      for (dest = loop->exit_labels; dest && n_exit_dest < 8;\n-\t   dest = LABEL_NEXTREF (dest))\n-\t{\n-\t  for (i = n_exit_dest - 1;\n-\t       i >= 0 && XEXP (dest, 0) != XEXP (exit_dest[i], 0); i--);\n-\t  if (i < 0)\n-\t    exit_dest[n_exit_dest++] = dest;\n-\t}\n-      /* If the loop top and call and exit destinations are enough to fill up\n-\t the target registers, we're unlikely to do any more damage by\n-\t unrolling.  */\n-      if (n_calls + n_exit_dest >= 7)\n-\treturn max_unrolled_insns;\n-\n-      /* ??? In the new loop unroller, there is no longer any strength\n-         reduction information available.  Thus, when it comes to unrolling,\n-         we know the cost of everything, but we know the value of nothing.  */\n-#if 0\n-      if (strength_reduce_p\n-\t  && (unroll_type == LPT_UNROLL_RUNTIME\n-\t      || unroll_type == LPT_UNROLL_CONSTANT\n-\t      || unroll_type == LPT_PEEL_COMPLETELY))\n-\t{\n-\t  struct loop_ivs *ivs = LOOP_IVS (loop);\n-\t  struct iv_class *bl;\n-\n-\t  /* We'll save one compare-and-branch in each loop body copy\n-\t     but the last one.  */\n-\t  unroll_benefit = 1;\n-\t  /* Assess the benefit of removing biv & giv updates.  */\n-\t  for (bl = ivs->list; bl; bl = bl->next)\n-\t    {\n-\t      rtx increment = biv_total_increment (bl);\n-\t      struct induction *v;\n-\n-\t      if (increment && GET_CODE (increment) == CONST_INT)\n-\t\t{\n-\t\t  unroll_benefit++;\n-\t\t  for (v = bl->giv; v; v = v->next_iv)\n-\t\t    {\n-\t\t      if (! v->ignore && v->same == 0\n-\t\t\t  && GET_CODE (v->mult_val) == CONST_INT)\n-\t\t\tunroll_benefit++;\n-\t\t      /* If this giv uses an array, try to determine\n-\t\t\t a maximum iteration count from the size of the\n-\t\t\t array.  This need not be correct all the time,\n-\t\t\t but should not be too far off the mark too often.  */\n-\t\t      while (v->giv_type == DEST_ADDR)\n-\t\t\t{\n-\t\t\t  rtx mem = PATTERN (v->insn);\n-\t\t\t  tree mem_expr, type, size_tree;\n-\n-\t\t\t  if (GET_CODE (SET_SRC (mem)) == MEM)\n-\t\t\t    mem = SET_SRC (mem);\n-\t\t\t  else if (GET_CODE (SET_DEST (mem)) == MEM)\n-\t\t\t    mem = SET_DEST (mem);\n-\t\t\t  else\n-\t\t\t    break;\n-\t\t\t  mem_expr = MEM_EXPR (mem);\n-\t\t\t  if (! mem_expr)\n-\t\t\t    break;\n-\t\t\t  type = TREE_TYPE (mem_expr);\n-\t\t\t  if (TREE_CODE (type) != ARRAY_TYPE\n-\t\t\t      || ! TYPE_SIZE (type) || ! TYPE_SIZE_UNIT (type))\n-\t\t\t    break;\n-\t\t\t  size_tree = fold_build2 (TRUNC_DIV_EXPR,\n-\t\t\t\t\t\t   bitsizetype,\n-\t\t\t\t\t\t   TYPE_SIZE (type),\n-\t\t\t\t\t\t   TYPE_SIZE_UNIT (type));\n-\t\t\t  if (TREE_CODE (size_tree) == INTEGER_CST\n-\t\t\t      && ! TREE_INT_CST_HIGH (size_tree)\n-\t\t\t      && TREE_INT_CST_LOW  (size_tree) < max_iterations)\n-\t\t\t    max_iterations = TREE_INT_CST_LOW  (size_tree);\n-\t\t\t  break;\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-#else /* 0 */\n-      /* Assume there is at least some benefit.  */\n-      unroll_benefit = 1;\n-#endif /* 0 */\n-\n-      desc = get_simple_loop_desc (loop);\n-      n_iterations = desc->const_iter ? desc->niter : 0;\n-      max_iterations\n-\t= max_iterations < desc->niter_max ? max_iterations : desc->niter_max;\n-\n-      if (! strength_reduce_p || ! n_iterations)\n-\tneed_precond = 1;\n-      if (! n_iterations)\n-\t{\n-\t  n_iterations\n-\t    = max_iterations < 3 ? max_iterations : max_iterations * 3 / 4;\n-\t  if (! n_iterations)\n-\t    return 0;\n-\t}\n-#if 0 /* ??? See above - missing induction variable information.  */\n-      while (unroll_benefit > 1) /* no loop */\n-\t{\n-\t  /* We include the benefit of biv/ giv updates.  Check if some or\n-\t     all of these updates are likely to fit into a scheduling\n-\t     bubble of a load.\n-\t     We check for the following case:\n-\t     - All the insns leading to the first JUMP_INSN are in a strict\n-\t       dependency chain.\n-\t     - there is at least one memory reference in them.\n-\n-\t     When we find such a pattern, we assume that we can hide as many\n-\t     updates as the total of the load latency is, if we have an\n-\t     unroll factor of at least two.  We might or might not also do\n-\t     this without unrolling, so rather than considering this as an\n-\t     extra unroll benefit, discount it in the unroll benefits of unroll\n-\t     factors higher than two.  */\n-\t\t\n-\t  rtx set, last_set;\n-\n-\t  insn = next_active_insn (loop->start);\n-\t  last_set = single_set (insn);\n-\t  if (! last_set)\n-\t    break;\n-\t  if (GET_CODE (SET_SRC (last_set)) == MEM)\n-\t    mem_latency += 2;\n-\t  for (insn = NEXT_INSN (insn); insn != end; insn = NEXT_INSN (insn))\n-\t    {\n-\t      if (! INSN_P (insn))\n-\t\tcontinue;\n-\t      if (GET_CODE (insn) == JUMP_INSN)\n-\t\tbreak;\n-\t      if (! reg_referenced_p (SET_DEST (last_set), PATTERN (insn)))\n-\t\t{\n-\t\t  /* Check if this is a to-be-reduced giv insn.  */\n-\t\t  struct loop_ivs *ivs = LOOP_IVS (loop);\n-\t\t  struct iv_class *bl;\n-\t\t  struct induction *v;\n-\t\t  for (bl = ivs->list; bl; bl = bl->next)\n-\t\t    {\n-\t\t      if (bl->biv->insn == insn)\n-\t\t\tgoto is_biv;\n-\t\t      for (v = bl->giv; v; v = v->next_iv)\n-\t\t\tif (v->insn == insn)\n-\t\t\t  goto is_giv;\n-\t\t    }\n-\t\t  mem_latency--;\n-\t\tis_biv:\n-\t\tis_giv:\n-\t\t  continue;\n-\t\t}\n-\t      set = single_set (insn);\n-\t      if (! set)\n-\t\tcontinue;\n-\t      if (GET_CODE (SET_SRC (set)) == MEM)\n-\t\tmem_latency += 2;\n-\t      last_set = set;\n-\t    }\n-\t  if (mem_latency < 0)\n-\t    mem_latency = 0;\n-\t  else if (mem_latency > unroll_benefit - 1)\n-\t    mem_latency = unroll_benefit - 1;\n-\t  break;\n-\t}\n-#endif /* 0 */\n-      if (n_labels + (unroll_benefit + n_labels * 8) / n_iterations\n-\t  <= unroll_benefit)\n-\treturn max_unrolled_insns;\n-\n-      n_dest = n_labels + n_calls + n_exit_dest;\n-      base_cost = n_dest <= 8 ? 0 : n_dest - 7;\n-      best_cost = 0;\n-      best_factor = 1;\n-      if (n_barriers * 2 > n_labels - 1)\n-\tn_barriers = (n_labels - 1) / 2;\n-      for (factor = 2; factor <= 8; factor++)\n-\t{\n-\t  /* Bump up preconditioning cost for each power of two.  */\n-\t  if (! (factor & (factor-1)))\n-\t    precond += 4;\n-\t  /* When preconditioning, only powers of two will be considered.  */\n-\t  else if (need_precond)\n-\t    continue;\n-\t  n_dest = ((unroll_type != LPT_PEEL_COMPLETELY)\n-\t\t    + (n_labels - 1) * factor + n_calls + n_exit_dest\n-\t\t    - (n_barriers * factor >> 1)\n-\t\t    + need_precond);\n-\t  cost\n-\t    = ((n_dest <= 8 ? 0 : n_dest - 7)\n-\t       - base_cost * factor\n-\t       - ((factor > 2 ? unroll_benefit - mem_latency : unroll_benefit)\n-\t\t  * (factor - (unroll_type != LPT_PEEL_COMPLETELY)))\n-\t       + ((unroll_benefit + 1 + (n_labels - 1) * factor)\n-\t\t  / n_iterations));\n-\t  if (need_precond)\n-\t    cost += (precond + unroll_benefit * factor / 2) / n_iterations;\n-\t  if (cost < best_cost)\n-\t    {\n-\t      best_cost = cost;\n-\t      best_factor = factor;\n-\t    }\n-\t}\n-      threshold = best_factor * insn_count;\n-      if (max_unrolled_insns > threshold)\n-\tmax_unrolled_insns = threshold;\n-    }\n-  return max_unrolled_insns;\n-}\n-#endif /* TARGET_ADJUST_UNROLL_MAX */\n-\n /* Replace any occurrence of FROM(n) in X with TO(n).  The function does\n    not enter into CONST_DOUBLE for the replace.\n "}, {"sha": "bf0f67d8d8e549ceb3202632ec26cf70eacccc0b", "filename": "gcc/ddg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -488,7 +488,7 @@ create_ddg (basic_block bb, struct df *df, int closing_branch_deps)\n       if (! INSN_P (insn))\n \t{\n \t  if (! first_note && NOTE_P (insn)\n-\t      && NOTE_LINE_NUMBER (insn) !=  NOTE_INSN_BASIC_BLOCK)\n+\t      && NOTE_KIND (insn) !=  NOTE_INSN_BASIC_BLOCK)\n \t    first_note = insn;\n \t  continue;\n \t}"}, {"sha": "22cac4f6d3bd37b1df2c5584300295f5908fcf6b", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -12234,7 +12234,7 @@ gen_label_die (tree decl, dw_die_ref context_die)\n       if (insn\n \t  && (LABEL_P (insn)\n \t      || ((NOTE_P (insn)\n-\t           && NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED_LABEL))))\n+\t           && NOTE_KIND (insn) == NOTE_INSN_DELETED_LABEL))))\n \t{\n \t  /* When optimization is enabled (via -O) some parts of the compiler\n \t     (e.g. jump.c and cse.c) may try to delete CODE_LABEL insns which\n@@ -13850,7 +13850,7 @@ dwarf2out_var_location (rtx loc_note)\n   if (last_insn != NULL_RTX\n       && last_insn == prev_insn\n       && NOTE_P (prev_insn)\n-      && NOTE_LINE_NUMBER (prev_insn) == NOTE_INSN_VAR_LOCATION)\n+      && NOTE_KIND (prev_insn) == NOTE_INSN_VAR_LOCATION)\n     {\n       newloc->label = last_label;\n     }"}, {"sha": "afd3a401a25f7502a5af19172f8b220627b27e19", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -3437,8 +3437,7 @@ add_insn_after (rtx insn, rtx after)\n       if (BB_END (bb) == after\n \t  /* Avoid clobbering of structure when creating new BB.  */\n \t  && !BARRIER_P (insn)\n-\t  && (!NOTE_P (insn)\n-\t      || NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK))\n+\t  && !NOTE_INSN_BASIC_BLOCK_P (insn))\n \tBB_END (bb) = insn;\n     }\n \n@@ -3503,8 +3502,7 @@ add_insn_before (rtx insn, rtx before)\n       gcc_assert (BB_HEAD (bb) != insn\n \t\t  /* Avoid clobbering of structure when creating new BB.  */\n \t\t  || BARRIER_P (insn)\n-\t\t  || (NOTE_P (insn)\n-\t\t      && NOTE_LINE_NUMBER (insn) == NOTE_INSN_BASIC_BLOCK));\n+\t\t  || NOTE_INSN_BASIC_BLOCK_P (insn));\n     }\n \n   PREV_INSN (before) = insn;\n@@ -3877,14 +3875,11 @@ emit_label_before (rtx label, rtx before)\n /* Emit a note of subtype SUBTYPE before the insn BEFORE.  */\n \n rtx\n-emit_note_before (int subtype, rtx before)\n+emit_note_before (enum insn_note subtype, rtx before)\n {\n   rtx note = rtx_alloc (NOTE);\n   INSN_UID (note) = cur_insn_uid++;\n-#ifndef USE_MAPPED_LOCATION\n-  NOTE_SOURCE_FILE (note) = 0;\n-#endif\n-  NOTE_LINE_NUMBER (note) = subtype;\n+  NOTE_KIND (note) = subtype;\n   BLOCK_FOR_INSN (note) = NULL;\n \n   add_insn_before (note, before);\n@@ -4077,14 +4072,11 @@ emit_label_after (rtx label, rtx after)\n /* Emit a note of subtype SUBTYPE after the insn AFTER.  */\n \n rtx\n-emit_note_after (int subtype, rtx after)\n+emit_note_after (enum insn_note subtype, rtx after)\n {\n   rtx note = rtx_alloc (NOTE);\n   INSN_UID (note) = cur_insn_uid++;\n-#ifndef USE_MAPPED_LOCATION\n-  NOTE_SOURCE_FILE (note) = 0;\n-#endif\n-  NOTE_LINE_NUMBER (note) = subtype;\n+  NOTE_KIND (note) = subtype;\n   BLOCK_FOR_INSN (note) = NULL;\n   add_insn_after (note, after);\n   return note;\n@@ -4444,7 +4436,7 @@ emit_note_copy (rtx orig)\n   \n   INSN_UID (note) = cur_insn_uid++;\n   NOTE_DATA (note) = NOTE_DATA (orig);\n-  NOTE_LINE_NUMBER (note) = NOTE_LINE_NUMBER (orig);\n+  NOTE_KIND (note) = NOTE_KIND (orig);\n   BLOCK_FOR_INSN (note) = NULL;\n   add_insn (note);\n   \n@@ -4455,13 +4447,13 @@ emit_note_copy (rtx orig)\n    and add it to the end of the doubly-linked list.  */\n \n rtx\n-emit_note (int note_no)\n+emit_note (enum insn_note kind)\n {\n   rtx note;\n \n   note = rtx_alloc (NOTE);\n   INSN_UID (note) = cur_insn_uid++;\n-  NOTE_LINE_NUMBER (note) = note_no;\n+  NOTE_KIND (note) = kind;\n   memset (&NOTE_DATA (note), 0, sizeof (NOTE_DATA (note)));\n   BLOCK_FOR_INSN (note) = NULL;\n   add_insn (note);"}, {"sha": "832d9eae2a9c95e87e06ee5de6f07bec6c815a60", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -1898,9 +1898,9 @@ sjlj_emit_function_enter (rtx dispatch_label)\n   for (fn_begin = get_insns (); ; fn_begin = NEXT_INSN (fn_begin))\n     if (NOTE_P (fn_begin))\n       {\n-\tif (NOTE_LINE_NUMBER (fn_begin) == NOTE_INSN_FUNCTION_BEG)\n+\tif (NOTE_KIND (fn_begin) == NOTE_INSN_FUNCTION_BEG)\n \t  break;\n-\telse if (NOTE_LINE_NUMBER (fn_begin) == NOTE_INSN_BASIC_BLOCK)\n+\telse if (NOTE_INSN_BASIC_BLOCK_P (fn_begin))\n \t  fn_begin_outside_block = false;\n       }\n "}, {"sha": "e3a27647527afc2ae51e7cdd0b8fc6c5544f2846", "filename": "gcc/final.c", "status": "modified", "additions": 3, "deletions": 33, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -1545,33 +1545,6 @@ final (rtx first, FILE *file, int optimize)\n \n   last_ignored_compare = 0;\n \n-#ifdef SDB_DEBUGGING_INFO\n-  /* When producing SDB debugging info, delete troublesome line number\n-     notes from inlined functions in other files as well as duplicate\n-     line number notes.  */\n-  if (write_symbols == SDB_DEBUG)\n-    {\n-      rtx last = 0;\n-      for (insn = first; insn; insn = NEXT_INSN (insn))\n-\tif (NOTE_P (insn) && NOTE_LINE_NUMBER (insn) > 0)\n-\t  {\n-\t    if (last != 0\n-#ifdef USE_MAPPED_LOCATION\n-\t\t&& NOTE_SOURCE_LOCATION (insn) == NOTE_SOURCE_LOCATION (last)\n-#else\n-\t\t&& NOTE_LINE_NUMBER (insn) == NOTE_LINE_NUMBER (last)\n-\t\t&& NOTE_SOURCE_FILE (insn) == NOTE_SOURCE_FILE (last)\n-#endif\n-\t      )\n-\t      {\n-\t\tdelete_insn (insn);\t/* Use delete_note.  */\n-\t\tcontinue;\n-\t      }\n-\t    last = insn;\n-\t  }\n-    }\n-#endif\n-\n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n       if (INSN_UID (insn) > max_uid)       /* Find largest UID.  */\n@@ -1695,7 +1668,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n   switch (GET_CODE (insn))\n     {\n     case NOTE:\n-      switch (NOTE_LINE_NUMBER (insn))\n+      switch (NOTE_KIND (insn))\n \t{\n \tcase NOTE_INSN_DELETED:\n \t  break;\n@@ -1818,11 +1791,8 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t  (*debug_hooks->var_location) (insn);\n \t  break;\n \n-\tcase 0:\n-\t  break;\n-\n \tdefault:\n-\t  gcc_assert (NOTE_LINE_NUMBER (insn) > 0);\n+\t  gcc_unreachable ();\n \t  break;\n \t}\n       break;\n@@ -3235,7 +3205,7 @@ output_asm_label (rtx x)\n     x = XEXP (x, 0);\n   if (LABEL_P (x)\n       || (NOTE_P (x)\n-\t  && NOTE_LINE_NUMBER (x) == NOTE_INSN_DELETED_LABEL))\n+\t  && NOTE_KIND (x) == NOTE_INSN_DELETED_LABEL))\n     ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", CODE_LABEL_NUMBER (x));\n   else\n     output_operand_lossage (\"'%%l' operand isn't a label\");"}, {"sha": "996d0ab65321c7c3e2c0aea8ab419856c3ddc5ae", "filename": "gcc/function.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -3567,7 +3567,7 @@ reorder_blocks_1 (rtx insns, tree current_block, VEC(tree,heap) **p_block_stack)\n     {\n       if (NOTE_P (insn))\n \t{\n-\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG)\n+\t  if (NOTE_KIND (insn) == NOTE_INSN_BLOCK_BEG)\n \t    {\n \t      tree block = NOTE_BLOCK (insn);\n \t      tree origin;\n@@ -3608,7 +3608,7 @@ reorder_blocks_1 (rtx insns, tree current_block, VEC(tree,heap) **p_block_stack)\n \t\t}\n \t      VEC_safe_push (tree, heap, *p_block_stack, block);\n \t    }\n-\t  else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n+\t  else if (NOTE_KIND (insn) == NOTE_INSN_BLOCK_END)\n \t    {\n \t      NOTE_BLOCK (insn) = VEC_pop (tree, *p_block_stack);\n \t      BLOCK_SUBBLOCKS (current_block)\n@@ -5237,7 +5237,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n \t{\n \t  next = NEXT_INSN (insn);\n \t  if (NOTE_P (insn) \n-\t      && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG))\n+\t      && (NOTE_KIND (insn) == NOTE_INSN_FUNCTION_BEG))\n \t    reorder_insns (insn, insn, PREV_INSN (epilogue_end));\n \t}\n     }\n@@ -5265,7 +5265,7 @@ reposition_prologue_and_epilogue_notes (rtx f ATTRIBUTE_UNUSED)\n \t{\n \t  if (NOTE_P (insn))\n \t    {\n-\t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_PROLOGUE_END)\n+\t      if (NOTE_KIND (insn) == NOTE_INSN_PROLOGUE_END)\n \t\tnote = insn;\n \t    }\n \t  else if (contains (insn, &prologue))\n@@ -5284,7 +5284,7 @@ reposition_prologue_and_epilogue_notes (rtx f ATTRIBUTE_UNUSED)\n \t    {\n \t      for (note = last; (note = NEXT_INSN (note));)\n \t\tif (NOTE_P (note)\n-\t\t    && NOTE_LINE_NUMBER (note) == NOTE_INSN_PROLOGUE_END)\n+\t\t    && NOTE_KIND (note) == NOTE_INSN_PROLOGUE_END)\n \t\t  break;\n \t    }\n \n@@ -5306,7 +5306,7 @@ reposition_prologue_and_epilogue_notes (rtx f ATTRIBUTE_UNUSED)\n \t{\n \t  if (NOTE_P (insn))\n \t    {\n-\t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EPILOGUE_BEG)\n+\t      if (NOTE_KIND (insn) == NOTE_INSN_EPILOGUE_BEG)\n \t\tnote = insn;\n \t    }\n \t  else if (contains (insn, &epilogue))\n@@ -5325,7 +5325,7 @@ reposition_prologue_and_epilogue_notes (rtx f ATTRIBUTE_UNUSED)\n \t    {\n \t      for (note = insn; (note = PREV_INSN (note));)\n \t\tif (NOTE_P (note)\n-\t\t    && NOTE_LINE_NUMBER (note) == NOTE_INSN_EPILOGUE_BEG)\n+\t\t    && NOTE_KIND (note) == NOTE_INSN_EPILOGUE_BEG)\n \t\t  break;\n \t    }\n "}, {"sha": "dd80e754454fd8f9f621197bce456091a9500bec", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -6159,8 +6159,7 @@ insert_insn_start_bb (rtx insn, basic_block bb)\n   while (before != 0)\n     {\n       if (! LABEL_P (before)\n-\t  && (! NOTE_P (before)\n-\t      || NOTE_LINE_NUMBER (before) != NOTE_INSN_BASIC_BLOCK))\n+\t  && !NOTE_INSN_BASIC_BLOCK_P (before))\n \tbreak;\n       prev = before;\n       if (prev == BB_END (bb))"}, {"sha": "ae1f93deb386fac809f3b333d8fc5810bc737526", "filename": "gcc/gengtype.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -1088,6 +1088,8 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n \t\tt = rtx_tp, subname = \"rt_rtx\";\n \t      else if (i == NOTE && aindex == 4)\n \t\tt = note_union_tp, subname = \"\";\n+\t      else if (i == NOTE && aindex == 5)\n+\t\tt = scalar_tp, subname = \"rt_int\";\n \t      else if (i == NOTE && aindex >= 7)\n \t\tt = scalar_tp, subname = \"rt_int\";\n \t      else if (i == ADDR_DIFF_VEC && aindex == 4)\n@@ -1167,7 +1169,7 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n \t  subfields->opt = nodot;\n \t  if (t == note_union_tp)\n \t    subfields->opt = create_option (subfields->opt, \"desc\",\n-\t\t\t\t\t    \"NOTE_LINE_NUMBER (&%0)\");\n+\t\t\t\t\t    \"NOTE_KIND (&%0)\");\n \t  if (t == symbol_union_tp)\n \t    subfields->opt = create_option (subfields->opt, \"desc\",\n \t\t\t\t\t    \"CONSTANT_POOL_ADDRESS_P (&%0)\");"}, {"sha": "b0e9cbaf395a7a956cdcf97d99649c2d25a7e76f", "filename": "gcc/graph.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -146,9 +146,8 @@ darkgrey\\n  shape: ellipse\" : \"white\",\n   /* Print the RTL.  */\n   if (NOTE_P (tmp_rtx))\n     {\n-      const char *name = \"\";\n-      if (NOTE_LINE_NUMBER (tmp_rtx) < 0)\n-\tname =  GET_NOTE_INSN_NAME (NOTE_LINE_NUMBER (tmp_rtx));\n+      const char *name;\n+      name =  GET_NOTE_INSN_NAME (NOTE_KIND (tmp_rtx));\n       fprintf (fp, \" %s\", name);\n     }\n   else if (INSN_P (tmp_rtx))"}, {"sha": "3149fb040b61bebd335f277035e257150e1c959d", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -1305,8 +1305,8 @@ unlink_other_notes (rtx insn, rtx tail)\n         }\n \n       /* See sched_analyze to see how these are handled.  */\n-      if (NOTE_LINE_NUMBER (insn) != NOTE_INSN_EH_REGION_BEG\n-\t  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_EH_REGION_END)\n+      if (NOTE_KIND (insn) != NOTE_INSN_EH_REGION_BEG\n+\t  && NOTE_KIND (insn) != NOTE_INSN_EH_REGION_END)\n \t{\n \t  /* Insert the note at the end of the notes list.  */\n \t  PREV_INSN (insn) = note_list;"}, {"sha": "6fca205a4ef659486f24051a77716cc9590c05f1", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -3899,9 +3899,6 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n       if (end == BB_END (merge_bb))\n \tBB_END (merge_bb) = PREV_INSN (head);\n \n-      if (squeeze_notes (&head, &end))\n-\treturn TRUE;\n-\n       /* PR 21767: When moving insns above a conditional branch, REG_EQUAL\n \t notes might become invalid.  */\n       insn = head;"}, {"sha": "20430c9b50c9ce7fcd5b1c7b359e674f8b38ca2c", "filename": "gcc/jump.c", "status": "modified", "additions": 1, "deletions": 57, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -227,62 +227,6 @@ mark_all_labels (rtx f)\n     }\n }\n \f\n-/* Move all block-beg, block-end and loop-beg notes between START and END out\n-   before START.  START and END may be such notes.  Returns the values of the\n-   new starting and ending insns, which may be different if the original ones\n-   were such notes.  Return true if there were only such notes and no real\n-   instructions.  */\n-\n-bool\n-squeeze_notes (rtx* startp, rtx* endp)\n-{\n-  rtx start = *startp;\n-  rtx end = *endp;\n-\n-  rtx insn;\n-  rtx next;\n-  rtx last = NULL;\n-  rtx past_end = NEXT_INSN (end);\n-\n-  for (insn = start; insn != past_end; insn = next)\n-    {\n-      next = NEXT_INSN (insn);\n-      if (NOTE_P (insn)\n-\t  && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END\n-\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG))\n-\t{\n-\t  /* BLOCK_BEG or BLOCK_END notes only exist in the `final' pass.  */\n-\t  gcc_assert (NOTE_LINE_NUMBER (insn) != NOTE_INSN_BLOCK_BEG\n-\t\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BLOCK_END);\n-\n-\t  if (insn == start)\n-\t    start = next;\n-\t  else\n-\t    {\n-\t      rtx prev = PREV_INSN (insn);\n-\t      PREV_INSN (insn) = PREV_INSN (start);\n-\t      NEXT_INSN (insn) = start;\n-\t      NEXT_INSN (PREV_INSN (insn)) = insn;\n-\t      PREV_INSN (NEXT_INSN (insn)) = insn;\n-\t      NEXT_INSN (prev) = next;\n-\t      PREV_INSN (next) = prev;\n-\t    }\n-\t}\n-      else\n-\tlast = insn;\n-    }\n-\n-  /* There were no real instructions.  */\n-  if (start == past_end)\n-    return true;\n-\n-  end = last;\n-\n-  *startp = start;\n-  *endp = end;\n-  return false;\n-}\n-\f\n /* Given a comparison (CODE ARG0 ARG1), inside an insn, INSN, return a code\n    of reversed comparison if it is possible to do so.  Otherwise return UNKNOWN.\n    UNKNOWN may be returned in case we are having CC_MODE compare and we don't\n@@ -1014,7 +958,7 @@ mark_jump_label (rtx x, rtx insn, int in_mem)\n \t/* Ignore remaining references to unreachable labels that\n \t   have been deleted.  */\n \tif (NOTE_P (label)\n-\t    && NOTE_LINE_NUMBER (label) == NOTE_INSN_DELETED_LABEL)\n+\t    && NOTE_KIND (label) == NOTE_INSN_DELETED_LABEL)\n \t  break;\n \n \tgcc_assert (LABEL_P (label));"}, {"sha": "3470ba7cb1ad8f9e8e740298c6cbe6236b9385e1", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -664,9 +664,7 @@ optimize_mode_switching (void)\n \t\t  if (mode_set != NULL_RTX)\n \t\t    {\n \t\t      emited = true;\n-\t\t      if (NOTE_P (ptr->insn_ptr)\n-\t\t\t  && (NOTE_LINE_NUMBER (ptr->insn_ptr)\n-\t\t\t      == NOTE_INSN_BASIC_BLOCK))\n+\t\t      if (NOTE_INSN_BASIC_BLOCK_P (ptr->insn_ptr))\n \t\t\temit_insn_after (mode_set, ptr->insn_ptr);\n \t\t      else\n \t\t\temit_insn_before (mode_set, ptr->insn_ptr);"}, {"sha": "7301b08d03e8d02c43d20e26d29c95e89a2fcb17", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -270,7 +270,7 @@ print_rtx (rtx in_rtx)\n #endif\n \telse if (i == 4 && NOTE_P (in_rtx))\n \t  {\n-\t    switch (NOTE_LINE_NUMBER (in_rtx))\n+\t    switch (NOTE_KIND (in_rtx))\n \t      {\n \t      case NOTE_INSN_EH_REGION_BEG:\n \t      case NOTE_INSN_EH_REGION_END:\n@@ -330,22 +330,7 @@ print_rtx (rtx in_rtx)\n \t\tbreak;\n \n \t      default:\n-\t\t{\n-\t\t  const char * const str = X0STR (in_rtx, i);\n-\n-\t\t  if (NOTE_LINE_NUMBER (in_rtx) < 0)\n-\t\t    ;\n-\t\t  else if (str == 0)\n-\t\t    fputs (dump_for_graph ? \" \\\\\\\"\\\\\\\"\" : \" \\\"\\\"\", outfile);\n-\t\t  else\n-\t\t    {\n-\t\t      if (dump_for_graph)\n-\t\t        fprintf (outfile, \" (\\\\\\\"%s\\\\\\\")\", str);\n-\t\t      else\n-\t\t        fprintf (outfile, \" (\\\"%s\\\")\", str);\n-\t\t    }\n-\t\t  break;\n-\t\t}\n+\t\tbreak;\n \t      }\n \t  }\n \tbreak;\n@@ -412,7 +397,7 @@ print_rtx (rtx in_rtx)\n \t  {\n \t    /* This field is only used for NOTE_INSN_DELETED_LABEL, and\n \t       other times often contains garbage from INSN->NOTE death.  */\n-\t    if (NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_DELETED_LABEL)\n+\t    if (NOTE_KIND (in_rtx) == NOTE_INSN_DELETED_LABEL)\n \t      fprintf (outfile, \" %d\",  XINT (in_rtx, i));\n \t  }\n \telse\n@@ -476,11 +461,7 @@ print_rtx (rtx in_rtx)\n       /* Print NOTE_INSN names rather than integer codes.  */\n \n       case 'n':\n-\tif (XINT (in_rtx, i) >= (int) NOTE_INSN_BIAS\n-\t    && XINT (in_rtx, i) < (int) NOTE_INSN_MAX)\n-\t  fprintf (outfile, \" %s\", GET_NOTE_INSN_NAME (XINT (in_rtx, i)));\n-\telse\n-\t  fprintf (outfile, \" %d\", XINT (in_rtx, i));\n+\tfprintf (outfile, \" %s\", GET_NOTE_INSN_NAME (XINT (in_rtx, i)));\n \tsawclose = 0;\n \tbreak;\n \n@@ -493,7 +474,7 @@ print_rtx (rtx in_rtx)\n \t    if (GET_CODE (in_rtx) == LABEL_REF)\n \t      {\n \t\tif (subc == NOTE\n-\t\t    && NOTE_LINE_NUMBER (sub) == NOTE_INSN_DELETED_LABEL)\n+\t\t    && NOTE_KIND (sub) == NOTE_INSN_DELETED_LABEL)\n \t\t  {\n \t\t    if (flag_dump_unnumbered)\n \t\t      fprintf (outfile, \" [# deleted]\");\n@@ -724,8 +705,6 @@ debug_rtx_find (rtx x, int uid)\n void\n print_rtl (FILE *outf, rtx rtx_first)\n {\n-  rtx tmp_rtx;\n-\n   outfile = outf;\n   sawclose = 0;\n \n@@ -743,14 +722,6 @@ print_rtl (FILE *outf, rtx rtx_first)\n       case NOTE:\n       case CODE_LABEL:\n       case BARRIER:\n-\tfor (tmp_rtx = rtx_first; tmp_rtx != 0; tmp_rtx = NEXT_INSN (tmp_rtx))\n-\t  if (! flag_dump_unnumbered\n-\t      || !NOTE_P (tmp_rtx) || NOTE_LINE_NUMBER (tmp_rtx) < 0)\n-\t    {\n-\t      fputs (print_rtx_head, outfile);\n-\t      print_rtx (tmp_rtx);\n-\t      fprintf (outfile, \"\\n\");\n-\t    }\n \tbreak;\n \n       default:\n@@ -767,8 +738,7 @@ print_rtl_single (FILE *outf, rtx x)\n {\n   outfile = outf;\n   sawclose = 0;\n-  if (! flag_dump_unnumbered\n-      || !NOTE_P (x) || NOTE_LINE_NUMBER (x) < 0)\n+  if (! flag_dump_unnumbered)\n     {\n       fputs (print_rtx_head, outfile);\n       print_rtx (x);"}, {"sha": "9908d490caed16933a5a7dbf893a402dd124a850", "filename": "gcc/profile.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -1005,6 +1005,15 @@ branch_prob (void)\n \t      if (EXPR_HAS_LOCATION (stmt))\n \t\toutput_location (EXPR_FILENAME (stmt), EXPR_LINENO (stmt),\n \t\t\t\t &offset, bb);\n+\t      /* Take into account modify statements nested in return\n+\t\t produced by C++ NRV transformation.  */\n+\t      if (TREE_CODE (stmt) == RETURN_EXPR\n+\t\t  && TREE_OPERAND (stmt, 0)\n+\t\t  && TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR\n+\t\t  && EXPR_HAS_LOCATION (TREE_OPERAND (stmt, 0)))\n+\t\toutput_location (EXPR_FILENAME (TREE_OPERAND (stmt, 0)),\n+\t\t\t\t EXPR_LINENO (TREE_OPERAND (stmt, 0)),\n+\t\t\t\t &offset, bb);\n \t    }\n \n \t  /* Notice GOTO expressions we eliminated while constructing the"}, {"sha": "de3219d8df9bd5c0c0dfb46272969ca1b98501a4", "filename": "gcc/reorg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -3807,7 +3807,7 @@ dbr_schedule (rtx first)\n       if (INSN_UID (insn) > max_uid)\n \tmax_uid = INSN_UID (insn);\n       if (NOTE_P (insn)\n-\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_EPILOGUE_BEG)\n+\t  && NOTE_KIND (insn) == NOTE_INSN_EPILOGUE_BEG)\n \tepilogue_insn = insn;\n     }\n "}, {"sha": "5222d187f6f9bffe23a6eb1ba3cbf8b614f945df", "filename": "gcc/resource.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -1099,7 +1099,7 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n \t     RTL chain when there are no epilogue insns.  Certain resources\n \t     are implicitly required at that point.  */\n \t  else if (NOTE_P (real_insn)\n-\t\t   && NOTE_LINE_NUMBER (real_insn) == NOTE_INSN_EPILOGUE_BEG)\n+\t\t   && NOTE_KIND (real_insn) == NOTE_INSN_EPILOGUE_BEG)\n \t    IOR_HARD_REG_SET (current_live_regs, start_of_epilogue_needs.regs);\n \t}\n "}, {"sha": "08b34e5f1cd6d6ebfa28b872fb45d0b39114e8bc", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -119,15 +119,10 @@ const unsigned char rtx_code_size[NUM_RTX_CODE] = {\n #undef DEF_RTL_EXPR\n };\n \n-/* Make sure all NOTE_INSN_* values are negative.  */\n-extern char NOTE_INSN_MAX_isnt_negative_adjust_NOTE_INSN_BIAS\n-[NOTE_INSN_MAX < 0 ? 1 : -1];\n-\n /* Names for kinds of NOTEs and REG_NOTEs.  */\n \n-const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS] =\n+const char * const note_insn_name[NOTE_INSN_MAX] =\n {\n-  \"\",\n #define DEF_INSN_NOTE(NAME) #NAME,\n #include \"insn-notes.def\"\n #undef DEF_INSN_NOTE"}, {"sha": "711cf75bba3697d290c242c3633931c3aac3c641", "filename": "gcc/rtl.def", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -137,20 +137,12 @@ DEF_RTL_EXPR(BARRIER, \"barrier\", \"iuu000000\", RTX_EXTRA)\n    7: is the user-given name of the label, if any.  */\n DEF_RTL_EXPR(CODE_LABEL, \"code_label\", \"iuuB00is\", RTX_EXTRA)\n \n-#ifdef USE_MAPPED_LOCATION\n /* Say where in the code a source line starts, for symbol table's sake.\n    Operand:\n-   4: unused if line number > 0, note-specific data otherwise.\n-   5: line number if > 0, enum note_insn otherwise.\n-   6: CODE_LABEL_NUMBER if line number == NOTE_INSN_DELETED_LABEL.  */\n-#else\n-/* Say where in the code a source line starts, for symbol table's sake.\n-   Operand:\n-   4: filename, if line number > 0, note-specific data otherwise.\n-   5: line number if > 0, enum note_insn otherwise.\n+   4: note-specific data\n+   5: unused (memory layout has to match code_label above)\n    6: unique number if line number == note_insn_deleted_label.  */\n-#endif\n-DEF_RTL_EXPR(NOTE, \"note\", \"iuuB0ni\", RTX_EXTRA)\n+DEF_RTL_EXPR(NOTE, \"note\", \"iuuB00i\", RTX_EXTRA)\n \n /* ----------------------------------------------------------------------\n    Top level constituents of INSN, JUMP_INSN and CALL_INSN."}, {"sha": "61c40f5e3737f3f7c55953e4dd80970136ea6497", "filename": "gcc/rtl.h", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -834,19 +834,12 @@ extern const char * const reg_note_name[];\n #define NOTE_DATA(INSN)\t        RTL_CHECKC1 (INSN, 4, NOTE)\n #define NOTE_DELETED_LABEL_NAME(INSN) XCSTR (INSN, 4, NOTE)\n #ifdef USE_MAPPED_LOCATION\n-#define NOTE_SOURCE_LOCATION(INSN) XCUINT (INSN, 5, NOTE)\n-#define NOTE_EXPANDED_LOCATION(XLOC, INSN)\t\\\n-  (XLOC) = expand_location (NOTE_SOURCE_LOCATION (INSN))\n #define SET_INSN_DELETED(INSN) \\\n-  (PUT_CODE (INSN, NOTE), NOTE_LINE_NUMBER (INSN) = NOTE_INSN_DELETED)\n+  (PUT_CODE (INSN, NOTE), NOTE_KIND (INSN) = NOTE_INSN_DELETED)\n #else\n-#define NOTE_EXPANDED_LOCATION(XLOC, INSN)\t\\\n-  ((XLOC).file = NOTE_SOURCE_FILE (INSN),\t\\\n-   (XLOC).line = NOTE_LINE_NUMBER (INSN))\n-#define NOTE_SOURCE_FILE(INSN)\tXCSTR (INSN, 4, NOTE)\n #define SET_INSN_DELETED(INSN) \\\n-  (PUT_CODE (INSN, NOTE),  NOTE_SOURCE_FILE (INSN) = 0, \\\n-   NOTE_LINE_NUMBER (INSN) = NOTE_INSN_DELETED)\n+  (PUT_CODE (INSN, NOTE), \\\n+   NOTE_KIND (INSN) = NOTE_INSN_DELETED)\n #endif\n #define NOTE_BLOCK(INSN)\tXCTREE (INSN, 4, NOTE)\n #define NOTE_EH_HANDLER(INSN)\tXCINT (INSN, 4, NOTE)\n@@ -855,20 +848,20 @@ extern const char * const reg_note_name[];\n \n /* In a NOTE that is a line number, this is the line number.\n    Other kinds of NOTEs are identified by negative numbers here.  */\n-#define NOTE_LINE_NUMBER(INSN) XCINT (INSN, 5, NOTE)\n+#define NOTE_KIND(INSN) XCINT (INSN, 5, NOTE)\n \n /* Nonzero if INSN is a note marking the beginning of a basic block.  */\n #define NOTE_INSN_BASIC_BLOCK_P(INSN)\t\t\t\\\n   (GET_CODE (INSN) == NOTE\t\t\t\t\\\n-   && NOTE_LINE_NUMBER (INSN) == NOTE_INSN_BASIC_BLOCK)\n+   && NOTE_KIND (INSN) == NOTE_INSN_BASIC_BLOCK)\n \n /* Variable declaration and the location of a variable.  */\n #define NOTE_VAR_LOCATION_DECL(INSN)\t(XCTREE (XCEXP (INSN, 4, NOTE), \\\n \t\t\t\t\t\t 0, VAR_LOCATION))\n #define NOTE_VAR_LOCATION_LOC(INSN)\t(XCEXP (XCEXP (INSN, 4, NOTE),  \\\n \t\t\t\t\t\t1, VAR_LOCATION))\n \n-/* Codes that appear in the NOTE_LINE_NUMBER field for kinds of notes\n+/* Codes that appear in the NOTE_KIND field for kinds of notes\n    that are not line numbers.  These codes are all negative.\n    \n    Notice that we do not try to use zero here for any of\n@@ -879,9 +872,6 @@ extern const char * const reg_note_name[];\n \n enum insn_note\n {\n-  /* Keep all of these numbers negative.  Adjust as needed.  */\n-  NOTE_INSN_BIAS = -100,\n-\n #define DEF_INSN_NOTE(NAME) NAME,\n #include \"insn-notes.def\"\n #undef DEF_INSN_NOTE\n@@ -891,9 +881,9 @@ enum insn_note\n \n /* Names for NOTE insn's other than line numbers.  */\n \n-extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n+extern const char * const note_insn_name[NOTE_INSN_MAX];\n #define GET_NOTE_INSN_NAME(NOTE_CODE) \\\n-  (note_insn_name[(NOTE_CODE) - (int) NOTE_INSN_BIAS])\n+  (note_insn_name[(NOTE_CODE)])\n \n /* The name of a label, in case it corresponds to an explicit label\n    in the input source code.  */\n@@ -1542,7 +1532,7 @@ extern rtx emit_call_insn_before_noloc (rtx, rtx);\n extern rtx emit_call_insn_before_setloc (rtx, rtx, int);\n extern rtx emit_barrier_before (rtx);\n extern rtx emit_label_before (rtx, rtx);\n-extern rtx emit_note_before (int, rtx);\n+extern rtx emit_note_before (enum insn_note, rtx);\n extern rtx emit_insn_after (rtx, rtx);\n extern rtx emit_insn_after_noloc (rtx, rtx);\n extern rtx emit_insn_after_setloc (rtx, rtx, int);\n@@ -1554,13 +1544,13 @@ extern rtx emit_call_insn_after_noloc (rtx, rtx);\n extern rtx emit_call_insn_after_setloc (rtx, rtx, int);\n extern rtx emit_barrier_after (rtx);\n extern rtx emit_label_after (rtx, rtx);\n-extern rtx emit_note_after (int, rtx);\n+extern rtx emit_note_after (enum insn_note, rtx);\n extern rtx emit_insn (rtx);\n extern rtx emit_jump_insn (rtx);\n extern rtx emit_call_insn (rtx);\n extern rtx emit_label (rtx);\n extern rtx emit_barrier (void);\n-extern rtx emit_note (int);\n+extern rtx emit_note (enum insn_note);\n extern rtx emit_note_copy (rtx);\n extern rtx make_insn_raw (rtx);\n extern rtx make_jump_insn_raw (rtx);\n@@ -1598,7 +1588,6 @@ extern void mark_jump_label (rtx, rtx, int);\n extern unsigned int cleanup_barriers (void);\n \n /* In jump.c */\n-extern bool squeeze_notes (rtx *, rtx *);\n extern rtx delete_related_insns (rtx);\n \n /* In recog.c  */"}, {"sha": "0fd497c780a8b209c896784720eaa1df460889c9", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -1937,8 +1937,8 @@ sched_analyze (struct deps *deps, rtx head, rtx tail)\n       /* EH_REGION insn notes can not appear until well after we complete\n \t scheduling.  */\n       if (NOTE_P (insn))\n-\tgcc_assert (NOTE_LINE_NUMBER (insn) != NOTE_INSN_EH_REGION_BEG\n-\t\t    && NOTE_LINE_NUMBER (insn) != NOTE_INSN_EH_REGION_END);\n+\tgcc_assert (NOTE_KIND (insn) != NOTE_INSN_EH_REGION_BEG\n+\t\t    && NOTE_KIND (insn) != NOTE_INSN_EH_REGION_END);\n \n       if (current_sched_info->use_cselib)\n \tcselib_process_insn (insn);"}, {"sha": "8926ac1aece477f7832c17ad37f4a610443d7db3", "filename": "gcc/sched-int.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -745,7 +745,7 @@ enum SPEC_SCHED_FLAGS {\n   PREFER_NON_CONTROL_SPEC = PREFER_NON_DATA_SPEC << 1\n };\n \n-#define NOTE_NOT_BB_P(NOTE) (NOTE_P (NOTE) && (NOTE_LINE_NUMBER (NOTE)\t\\\n+#define NOTE_NOT_BB_P(NOTE) (NOTE_P (NOTE) && (NOTE_KIND (NOTE)\t\\\n \t\t\t\t\t       != NOTE_INSN_BASIC_BLOCK))\n \n extern FILE *sched_dump;"}, {"sha": "47842c57a40ce92a5ef4c0232589db5ca7474f41", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -2598,9 +2598,8 @@ void debug_dependencies (rtx head, rtx tail)\n \t  fprintf (sched_dump, \";;   %6d \", INSN_UID (insn));\n \t  if (NOTE_P (insn))\n \t    {\n-\t      n = NOTE_LINE_NUMBER (insn);\n-\t      if (n < 0)\n-\t\tfprintf (sched_dump, \"%s\\n\", GET_NOTE_INSN_NAME (n));\n+\t      n = NOTE_KIND (insn);\n+\t      fprintf (sched_dump, \"%s\\n\", GET_NOTE_INSN_NAME (n));\n \t    }\n \t  else\n \t    fprintf (sched_dump, \" {%s}\\n\", GET_RTX_NAME (GET_CODE (insn)));"}, {"sha": "6c975705ac5958d64e39c66a921afeebd552f01b", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -677,16 +677,8 @@ print_insn (char *buf, rtx x, int verbose)\n       sprintf (buf, \"i%4d: barrier\", INSN_UID (x));\n       break;\n     case NOTE:\n-      if (NOTE_LINE_NUMBER (x) > 0)\n-\t{\n-\t  expanded_location xloc;\n-\t  NOTE_EXPANDED_LOCATION (xloc, x);\n-\t  sprintf (buf, \" %4d note \\\"%s\\\" %d\", INSN_UID (x),\n-\t\t   xloc.file, xloc.line);\n-\t}\n-      else\n-\tsprintf (buf, \" %4d %s\", INSN_UID (x),\n-\t\t GET_NOTE_INSN_NAME (NOTE_LINE_NUMBER (x)));\n+      sprintf (buf, \" %4d %s\", INSN_UID (x),\n+\t       GET_NOTE_INSN_NAME (NOTE_KIND (x)));\n       break;\n     default:\n       sprintf (buf, \"i%4d  <What %s?>\", INSN_UID (x),"}, {"sha": "b2b23bc24131d9519bc27371b3a1f508f2e0de7a", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -2317,7 +2317,7 @@ expand_case (tree exp)\n   rtx table_label;\n   int ncases;\n   rtx *labelvec;\n-  int i, fail;\n+  int i;\n   rtx before_case, end, lab;\n \n   tree vec = SWITCH_LABELS (exp);\n@@ -2591,8 +2591,6 @@ expand_case (tree exp)\n \n       before_case = NEXT_INSN (before_case);\n       end = get_last_insn ();\n-      fail = squeeze_notes (&before_case, &end);\n-      gcc_assert (!fail);\n       reorder_insns (before_case, end, start);\n     }\n "}, {"sha": "ec7fc00e8356a35e512e1ba2602d79d44515d9f3", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e7aa5444eeef446063429186a41639d8cf186/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=a38e7aa5444eeef446063429186a41639d8cf186", "patch": "@@ -3695,7 +3695,7 @@ output_constant_pool_1 (struct constant_descriptor_rtx *desc,\n       tmp = XEXP (x, 0);\n       gcc_assert (!INSN_DELETED_P (tmp));\n       gcc_assert (!NOTE_P (tmp)\n-\t\t  || NOTE_LINE_NUMBER (tmp) != NOTE_INSN_DELETED);\n+\t\t  || NOTE_KIND (tmp) != NOTE_INSN_DELETED);\n       break;\n \n     default:"}]}