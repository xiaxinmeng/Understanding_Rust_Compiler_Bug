{"sha": "00aeceec1bc100e29ff283e272fbad99f0f35e67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBhZWNlZWMxYmMxMDBlMjlmZjI4M2UyNzJmYmFkOTlmMGYzNWU2Nw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-02-10T10:46:30Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-02-10T10:46:30Z"}, "message": "cp-tree.h (get_template_base): Don't declare.\n\n\t* cp-tree.h (get_template_base): Don't declare.\n\t(dfs_walk): Declare.\n\t(dfs_unmark): Likewise.\n\t(markedp): Likewise.\n\t* pt.c (unify): Remove duplicate declaration.  Pass tparms and\n\ttargs to get_template_base.\n\t(get_template_base_recursive): Move here from search.c.  Check to\n\tsee that the base found can be instantiated to form the desired\n\ttype.\n\t(get_template_base): Likewise.\n\t(get_class_bindings): Simplify.\n\t* search.c (get_template_base_recursive): Move to pt.c.\n\t(get_template_base): Likewise.\n\t(markedp): Make it global.\n\t(dfs_walk): Likewise.\n\t(dfs_unmark): Likewise.\n\nFrom-SVN: r25128", "tree": {"sha": "ad56214e9d365964146cf9af69cc9592a2c9bcbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad56214e9d365964146cf9af69cc9592a2c9bcbe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00aeceec1bc100e29ff283e272fbad99f0f35e67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00aeceec1bc100e29ff283e272fbad99f0f35e67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00aeceec1bc100e29ff283e272fbad99f0f35e67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00aeceec1bc100e29ff283e272fbad99f0f35e67/comments", "author": null, "committer": null, "parents": [{"sha": "a3b3fa5eb7b2cdef52ac142819484a97951b08e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3b3fa5eb7b2cdef52ac142819484a97951b08e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3b3fa5eb7b2cdef52ac142819484a97951b08e3"}], "stats": {"total": 34, "additions": 12, "deletions": 22}, "files": [{"sha": "2af40a8601864864ead997ab9b02ce87d86400ef", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00aeceec1bc100e29ff283e272fbad99f0f35e67/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00aeceec1bc100e29ff283e272fbad99f0f35e67/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=00aeceec1bc100e29ff283e272fbad99f0f35e67", "patch": "@@ -136,9 +136,9 @@ static tree process_partial_specialization PROTO((tree));\n static void set_current_access_from_decl PROTO((tree));\n static void check_default_tmpl_args PROTO((tree, tree, int, int));\n static tree tsubst_call_declarator_parms PROTO((tree, tree, tree));\n-static tree get_template_base_recursive PROTO((tree, tree, int *, tree, tree,\n+static tree get_template_base_recursive PROTO((tree, tree, tree, tree,\n \t\t\t\t\t       tree, int)); \n-static tree get_template_base PROTO((tree, tree, int *, tree, tree));\n+static tree get_template_base PROTO((tree, tree, tree, tree));\n \n /* We use TREE_VECs to hold template arguments.  If there is only one\n    level of template arguments, then the TREE_VEC contains the\n@@ -7365,12 +7365,11 @@ try_one_overload (tparms, orig_targs, targs, parm, arg, strict,\n /* Subroutine of get_template_base.  */\n \n static tree\n-get_template_base_recursive (tparms, targs, explicit_mask,\n+get_template_base_recursive (tparms, targs,\n \t\t\t     binfo, rval, template,\n \t\t\t     via_virtual)\n      tree tparms;\n      tree targs;\n-     int *explicit_mask;\n      tree binfo;\n      tree rval;\n      tree template;\n@@ -7384,22 +7383,15 @@ get_template_base_recursive (tparms, targs, explicit_mask,\n   if (CLASSTYPE_TEMPLATE_INFO (type)\n       && CLASSTYPE_TI_TEMPLATE (type) == tmpl)\n     {\n-      /* Copy the TPARMS and TARGS since we're only doing a\n-\t speculative unification here.  */\n-      tree copy_of_tparms;\n-      tree copy_of_targs;\n-      \n       push_momentary ();\n-      push_expression_obstack ();\n-      copy_of_tparms = copy_node (tparms);\n-      copy_of_targs = copy_node (targs);\n-      pop_obstacks ();\n       \n-      i = unify (copy_of_tparms,\n-\t\t copy_of_targs,\n+      i = unify (tparms, \n+\t\t /* Use a temporary vector since we're doing\n+\t\t    speculative unification here.  */\n+\t\t make_temp_vec (TREE_VEC_LENGTH (targs)),\n \t\t CLASSTYPE_TI_ARGS (template),\n \t\t CLASSTYPE_TI_ARGS (type),\n-\t\t UNIFY_ALLOW_NONE, explicit_mask);\n+\t\t UNIFY_ALLOW_NONE, 0);\n \n       pop_momentary ();\n \n@@ -7431,7 +7423,7 @@ get_template_base_recursive (tparms, targs, explicit_mask,\n \t  if (! this_virtual)\n \t    SET_BINFO_MARKED (base_binfo);\n \n-\t  rval = get_template_base_recursive (tparms, targs, explicit_mask,\n+\t  rval = get_template_base_recursive (tparms, targs,\n \t\t\t\t\t      base_binfo, rval,\n \t\t\t\t\t      template, this_virtual);\n \t  if (rval == error_mark_node)\n@@ -7449,10 +7441,9 @@ get_template_base_recursive (tparms, targs, explicit_mask,\n    template type.  Used by unify.  */\n \n static tree\n-get_template_base (tparms, targs, explicit_mask, template, binfo)\n+get_template_base (tparms, targs, template, binfo)\n      tree tparms;\n      tree targs;\n-     int *explicit_mask;\n      tree template;\n      tree binfo;\n {\n@@ -7468,7 +7459,7 @@ get_template_base (tparms, targs, explicit_mask, template, binfo)\n   else\n     my_friendly_abort (92);\n \n-  rval = get_template_base_recursive (tparms, targs, explicit_mask,\n+  rval = get_template_base_recursive (tparms, targs, \n \t\t\t\t      binfo, NULL_TREE,\n \t\t\t\t      template, 0); \n   dfs_walk (binfo, dfs_unmark, markedp);\n@@ -7882,8 +7873,7 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \t       The call to get_template_base also handles the case\n \t       where PARM and ARG are the same type, i.e., where no\n \t       derivation is involved.  */\n-\t    t = get_template_base (tparms, targs, explicit_mask,\n-\t\t\t\t   parm, arg);\n+\t    t = get_template_base (tparms, targs, parm, arg);\n \t  else if (CLASSTYPE_TEMPLATE_INFO (arg) \n \t\t   && (CLASSTYPE_TI_TEMPLATE (parm) \n \t\t       == CLASSTYPE_TI_TEMPLATE (arg)))"}]}