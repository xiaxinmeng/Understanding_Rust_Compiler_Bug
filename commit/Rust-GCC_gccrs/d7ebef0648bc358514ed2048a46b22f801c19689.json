{"sha": "d7ebef0648bc358514ed2048a46b22f801c19689", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdlYmVmMDY0OGJjMzU4NTE0ZWQyMDQ4YTQ2YjIyZjgwMWMxOTY4OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-11-17T18:42:48Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-11-17T18:42:48Z"}, "message": "Extend fold_const_call to combined_fn\n\nThis patch extends fold_const_call so that it can handle internal\nas well as built-in functions.\n\nTested on x86_64-linux-gnu, aarch64-linux-gnu and arm-linux-gnueabi.\n\ngcc/\n\t* fold-const-call.h (fold_const_call): Replace built_in_function\n\targuments with combined_fn arguments.\n\t* fold-const-call.c: Include case-cfn-macros.h.\n\t(fold_const_call_ss, fold_const_call_cs, fold_const_call_sc)\n\t(fold_const_call_cc, fold_const_call_sss, fold_const_call_ccc)\n\t(fold_const_call_ssss, fold_const_call_1, fold_const_call): Replace\n\tbuilt_in_function arguments with combined_fn arguments.\n\t* builtins.c (fold_builtin_sincos, fold_builtin_1, fold_builtin_2)\n\t(fold_builtin_3): Update calls to fold_const_call.\n\nFrom-SVN: r230477", "tree": {"sha": "a16899561921af923a2765fbaea65fd54a54b63b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a16899561921af923a2765fbaea65fd54a54b63b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7ebef0648bc358514ed2048a46b22f801c19689", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7ebef0648bc358514ed2048a46b22f801c19689", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7ebef0648bc358514ed2048a46b22f801c19689", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7ebef0648bc358514ed2048a46b22f801c19689/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6bac43d760cdced2775cb17add346f757ee6f045", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bac43d760cdced2775cb17add346f757ee6f045", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bac43d760cdced2775cb17add346f757ee6f045"}], "stats": {"total": 305, "additions": 158, "deletions": 147}, "files": [{"sha": "93e3c520521fb45b59807d0ea8f5da2e01c13987", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7ebef0648bc358514ed2048a46b22f801c19689/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7ebef0648bc358514ed2048a46b22f801c19689/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7ebef0648bc358514ed2048a46b22f801c19689", "patch": "@@ -1,3 +1,15 @@\n+2015-11-17  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* fold-const-call.h (fold_const_call): Replace built_in_function\n+\targuments with combined_fn arguments.\n+\t* fold-const-call.c: Include case-cfn-macros.h.\n+\t(fold_const_call_ss, fold_const_call_cs, fold_const_call_sc)\n+\t(fold_const_call_cc, fold_const_call_sss, fold_const_call_ccc)\n+\t(fold_const_call_ssss, fold_const_call_1, fold_const_call): Replace\n+\tbuilt_in_function arguments with combined_fn arguments.\n+\t* builtins.c (fold_builtin_sincos, fold_builtin_1, fold_builtin_2)\n+\t(fold_builtin_3): Update calls to fold_const_call.\n+\n 2015-11-17  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* Makefile.in (HASH_TABLE_H): Add GGC_H."}, {"sha": "fc038cda461545b355f4bdc1ff9fe34e48d1f0ae", "filename": "gcc/builtins.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7ebef0648bc358514ed2048a46b22f801c19689/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7ebef0648bc358514ed2048a46b22f801c19689/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=d7ebef0648bc358514ed2048a46b22f801c19689", "patch": "@@ -7348,7 +7348,7 @@ fold_builtin_sincos (location_t loc,\n   if (TREE_CODE (arg0) == REAL_CST)\n     {\n       tree complex_type = build_complex_type (type);\n-      call = fold_const_call (fn, complex_type, arg0);\n+      call = fold_const_call (as_combined_fn (fn), complex_type, arg0);\n     }\n   if (!call)\n     {\n@@ -8193,7 +8193,7 @@ fold_builtin_1 (location_t loc, tree fndecl, tree arg0)\n   if (TREE_CODE (arg0) == ERROR_MARK)\n     return NULL_TREE;\n \n-  if (tree ret = fold_const_call (fcode, type, arg0))\n+  if (tree ret = fold_const_call (as_combined_fn (fcode), type, arg0))\n     return ret;\n \n   switch (fcode)\n@@ -8320,7 +8320,7 @@ fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1)\n       || TREE_CODE (arg1) == ERROR_MARK)\n     return NULL_TREE;\n \n-  if (tree ret = fold_const_call (fcode, type, arg0, arg1))\n+  if (tree ret = fold_const_call (as_combined_fn (fcode), type, arg0, arg1))\n     return ret;\n \n   switch (fcode)\n@@ -8419,7 +8419,8 @@ fold_builtin_3 (location_t loc, tree fndecl,\n       || TREE_CODE (arg2) == ERROR_MARK)\n     return NULL_TREE;\n \n-  if (tree ret = fold_const_call (fcode, type, arg0, arg1, arg2))\n+  if (tree ret = fold_const_call (as_combined_fn (fcode), type,\n+\t\t\t\t  arg0, arg1, arg2))\n     return ret;\n \n   switch (fcode)"}, {"sha": "94801d23fde99d5626832f235de099081e7797bc", "filename": "gcc/fold-const-call.c", "status": "modified", "additions": 138, "deletions": 140, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7ebef0648bc358514ed2048a46b22f801c19689/gcc%2Ffold-const-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7ebef0648bc358514ed2048a46b22f801c19689/gcc%2Ffold-const-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const-call.c?ref=d7ebef0648bc358514ed2048a46b22f801c19689", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"options.h\"\n #include \"fold-const.h\"\n #include \"fold-const-call.h\"\n+#include \"case-cfn-macros.h\"\n #include \"tm.h\" /* For C[LT]Z_DEFINED_AT_ZERO.  */\n \n /* Functions that test for certain constant types, abstracting away the\n@@ -574,145 +575,145 @@ fold_const_builtin_nan (tree type, tree arg, bool quiet)\n    in format FORMAT.  Return true on success.  */\n \n static bool\n-fold_const_call_ss (real_value *result, built_in_function fn,\n+fold_const_call_ss (real_value *result, combined_fn fn,\n \t\t    const real_value *arg, const real_format *format)\n {\n   switch (fn)\n     {\n-    CASE_FLT_FN (BUILT_IN_SQRT):\n+    CASE_CFN_SQRT:\n       return (real_compare (GE_EXPR, arg, &dconst0)\n \t      && do_mpfr_arg1 (result, mpfr_sqrt, arg, format));\n \n-    CASE_FLT_FN (BUILT_IN_CBRT):\n+    CASE_CFN_CBRT:\n       return do_mpfr_arg1 (result, mpfr_cbrt, arg, format);\n \n-    CASE_FLT_FN (BUILT_IN_ASIN):\n+    CASE_CFN_ASIN:\n       return (real_compare (GE_EXPR, arg, &dconstm1)\n \t      && real_compare (LE_EXPR, arg, &dconst1)\n \t      && do_mpfr_arg1 (result, mpfr_asin, arg, format));\n \n-    CASE_FLT_FN (BUILT_IN_ACOS):\n+    CASE_CFN_ACOS:\n       return (real_compare (GE_EXPR, arg, &dconstm1)\n \t      && real_compare (LE_EXPR, arg, &dconst1)\n \t      && do_mpfr_arg1 (result, mpfr_acos, arg, format));\n \n-    CASE_FLT_FN (BUILT_IN_ATAN):\n+    CASE_CFN_ATAN:\n       return do_mpfr_arg1 (result, mpfr_atan, arg, format);\n \n-    CASE_FLT_FN (BUILT_IN_ASINH):\n+    CASE_CFN_ASINH:\n       return do_mpfr_arg1 (result, mpfr_asinh, arg, format);\n \n-    CASE_FLT_FN (BUILT_IN_ACOSH):\n+    CASE_CFN_ACOSH:\n       return (real_compare (GE_EXPR, arg, &dconst1)\n \t      && do_mpfr_arg1 (result, mpfr_acosh, arg, format));\n \n-    CASE_FLT_FN (BUILT_IN_ATANH):\n+    CASE_CFN_ATANH:\n       return (real_compare (GE_EXPR, arg, &dconstm1)\n \t      && real_compare (LE_EXPR, arg, &dconst1)\n \t      && do_mpfr_arg1 (result, mpfr_atanh, arg, format));\n \n-    CASE_FLT_FN (BUILT_IN_SIN):\n+    CASE_CFN_SIN:\n       return do_mpfr_arg1 (result, mpfr_sin, arg, format);\n \n-    CASE_FLT_FN (BUILT_IN_COS):\n+    CASE_CFN_COS:\n       return do_mpfr_arg1 (result, mpfr_cos, arg, format);\n \n-    CASE_FLT_FN (BUILT_IN_TAN):\n+    CASE_CFN_TAN:\n       return do_mpfr_arg1 (result, mpfr_tan, arg, format);\n \n-    CASE_FLT_FN (BUILT_IN_SINH):\n+    CASE_CFN_SINH:\n       return do_mpfr_arg1 (result, mpfr_sinh, arg, format);\n \n-    CASE_FLT_FN (BUILT_IN_COSH):\n+    CASE_CFN_COSH:\n       return do_mpfr_arg1 (result, mpfr_cosh, arg, format);\n \n-    CASE_FLT_FN (BUILT_IN_TANH):\n+    CASE_CFN_TANH:\n       return do_mpfr_arg1 (result, mpfr_tanh, arg, format);\n \n-    CASE_FLT_FN (BUILT_IN_ERF):\n+    CASE_CFN_ERF:\n       return do_mpfr_arg1 (result, mpfr_erf, arg, format);\n \n-    CASE_FLT_FN (BUILT_IN_ERFC):\n+    CASE_CFN_ERFC:\n       return do_mpfr_arg1 (result, mpfr_erfc, arg, format);\n \n-    CASE_FLT_FN (BUILT_IN_TGAMMA):\n+    CASE_CFN_TGAMMA:\n       return do_mpfr_arg1 (result, mpfr_gamma, arg, format);\n \n-    CASE_FLT_FN (BUILT_IN_EXP):\n+    CASE_CFN_EXP:\n       return do_mpfr_arg1 (result, mpfr_exp, arg, format);\n \n-    CASE_FLT_FN (BUILT_IN_EXP2):\n+    CASE_CFN_EXP2:\n       return do_mpfr_arg1 (result, mpfr_exp2, arg, format);\n \n-    CASE_FLT_FN (BUILT_IN_EXP10):\n-    CASE_FLT_FN (BUILT_IN_POW10):\n+    CASE_CFN_EXP10:\n+    CASE_CFN_POW10:\n       return do_mpfr_arg1 (result, mpfr_exp10, arg, format);\n \n-    CASE_FLT_FN (BUILT_IN_EXPM1):\n+    CASE_CFN_EXPM1:\n       return do_mpfr_arg1 (result, mpfr_expm1, arg, format);\n \n-    CASE_FLT_FN (BUILT_IN_LOG):\n+    CASE_CFN_LOG:\n       return (real_compare (GT_EXPR, arg, &dconst0)\n \t      && do_mpfr_arg1 (result, mpfr_log, arg, format));\n \n-    CASE_FLT_FN (BUILT_IN_LOG2):\n+    CASE_CFN_LOG2:\n       return (real_compare (GT_EXPR, arg, &dconst0)\n \t      && do_mpfr_arg1 (result, mpfr_log2, arg, format));\n \n-    CASE_FLT_FN (BUILT_IN_LOG10):\n+    CASE_CFN_LOG10:\n       return (real_compare (GT_EXPR, arg, &dconst0)\n \t      && do_mpfr_arg1 (result, mpfr_log10, arg, format));\n \n-    CASE_FLT_FN (BUILT_IN_LOG1P):\n+    CASE_CFN_LOG1P:\n       return (real_compare (GT_EXPR, arg, &dconstm1)\n \t      && do_mpfr_arg1 (result, mpfr_log1p, arg, format));\n \n-    CASE_FLT_FN (BUILT_IN_J0):\n+    CASE_CFN_J0:\n       return do_mpfr_arg1 (result, mpfr_j0, arg, format);\n \n-    CASE_FLT_FN (BUILT_IN_J1):\n+    CASE_CFN_J1:\n       return do_mpfr_arg1 (result, mpfr_j1, arg, format);\n \n-    CASE_FLT_FN (BUILT_IN_Y0):\n+    CASE_CFN_Y0:\n       return (real_compare (GT_EXPR, arg, &dconst0)\n \t      && do_mpfr_arg1 (result, mpfr_y0, arg, format));\n \n-    CASE_FLT_FN (BUILT_IN_Y1):\n+    CASE_CFN_Y1:\n       return (real_compare (GT_EXPR, arg, &dconst0)\n \t      && do_mpfr_arg1 (result, mpfr_y1, arg, format));\n \n-    CASE_FLT_FN (BUILT_IN_FLOOR):\n+    CASE_CFN_FLOOR:\n       if (!REAL_VALUE_ISNAN (*arg) || !flag_errno_math)\n \t{\n \t  real_floor (result, format, arg);\n \t  return true;\n \t}\n       return false;\n \n-    CASE_FLT_FN (BUILT_IN_CEIL):\n+    CASE_CFN_CEIL:\n       if (!REAL_VALUE_ISNAN (*arg) || !flag_errno_math)\n \t{\n \t  real_ceil (result, format, arg);\n \t  return true;\n \t}\n       return false;\n \n-    CASE_FLT_FN (BUILT_IN_TRUNC):\n+    CASE_CFN_TRUNC:\n       real_trunc (result, format, arg);\n       return true;\n \n-    CASE_FLT_FN (BUILT_IN_ROUND):\n+    CASE_CFN_ROUND:\n       if (!REAL_VALUE_ISNAN (*arg) || !flag_errno_math)\n \t{\n \t  real_round (result, format, arg);\n \t  return true;\n \t}\n       return false;\n \n-    CASE_FLT_FN (BUILT_IN_LOGB):\n+    CASE_CFN_LOGB:\n       return fold_const_logb (result, arg, format);\n \n-    CASE_FLT_FN (BUILT_IN_SIGNIFICAND):\n+    CASE_CFN_SIGNIFICAND:\n       return fold_const_significand (result, arg, format);\n \n     default:\n@@ -728,20 +729,20 @@ fold_const_call_ss (real_value *result, built_in_function fn,\n    significant bits in the result.  Return true on success.  */\n \n static bool\n-fold_const_call_ss (wide_int *result, built_in_function fn,\n+fold_const_call_ss (wide_int *result, combined_fn fn,\n \t\t    const real_value *arg, unsigned int precision,\n \t\t    const real_format *format)\n {\n   switch (fn)\n     {\n-    CASE_FLT_FN (BUILT_IN_SIGNBIT):\n+    CASE_CFN_SIGNBIT:\n       if (real_isneg (arg))\n \t*result = wi::one (precision);\n       else\n \t*result = wi::zero (precision);\n       return true;\n \n-    CASE_FLT_FN (BUILT_IN_ILOGB):\n+    CASE_CFN_ILOGB:\n       /* For ilogb we don't know FP_ILOGB0, so only handle normal values.\n \t Proceed iff radix == 2.  In GCC, normalized significands are in\n \t the range [0.5, 1.0).  We want the exponent as if they were\n@@ -753,52 +754,52 @@ fold_const_call_ss (wide_int *result, built_in_function fn,\n \t}\n       return false;\n \n-    CASE_FLT_FN (BUILT_IN_ICEIL):\n-    CASE_FLT_FN (BUILT_IN_LCEIL):\n-    CASE_FLT_FN (BUILT_IN_LLCEIL):\n+    CASE_CFN_ICEIL:\n+    CASE_CFN_LCEIL:\n+    CASE_CFN_LLCEIL:\n       return fold_const_conversion (result, real_ceil, arg,\n \t\t\t\t    precision, format);\n \n-    CASE_FLT_FN (BUILT_IN_LFLOOR):\n-    CASE_FLT_FN (BUILT_IN_IFLOOR):\n-    CASE_FLT_FN (BUILT_IN_LLFLOOR):\n+    CASE_CFN_LFLOOR:\n+    CASE_CFN_IFLOOR:\n+    CASE_CFN_LLFLOOR:\n       return fold_const_conversion (result, real_floor, arg,\n \t\t\t\t    precision, format);\n \n-    CASE_FLT_FN (BUILT_IN_IROUND):\n-    CASE_FLT_FN (BUILT_IN_LROUND):\n-    CASE_FLT_FN (BUILT_IN_LLROUND):\n+    CASE_CFN_IROUND:\n+    CASE_CFN_LROUND:\n+    CASE_CFN_LLROUND:\n       return fold_const_conversion (result, real_round, arg,\n \t\t\t\t    precision, format);\n \n-    CASE_FLT_FN (BUILT_IN_IRINT):\n-    CASE_FLT_FN (BUILT_IN_LRINT):\n-    CASE_FLT_FN (BUILT_IN_LLRINT):\n+    CASE_CFN_IRINT:\n+    CASE_CFN_LRINT:\n+    CASE_CFN_LLRINT:\n       /* Not yet folded to a constant.  */\n       return false;\n \n-    CASE_FLT_FN (BUILT_IN_FINITE):\n-    case BUILT_IN_FINITED32:\n-    case BUILT_IN_FINITED64:\n-    case BUILT_IN_FINITED128:\n-    case BUILT_IN_ISFINITE:\n+    CASE_CFN_FINITE:\n+    case CFN_BUILT_IN_FINITED32:\n+    case CFN_BUILT_IN_FINITED64:\n+    case CFN_BUILT_IN_FINITED128:\n+    case CFN_BUILT_IN_ISFINITE:\n       *result = wi::shwi (real_isfinite (arg) ? 1 : 0, precision);\n       return true;\n \n-    CASE_FLT_FN (BUILT_IN_ISINF):\n-    case BUILT_IN_ISINFD32:\n-    case BUILT_IN_ISINFD64:\n-    case BUILT_IN_ISINFD128:\n+    CASE_CFN_ISINF:\n+    case CFN_BUILT_IN_ISINFD32:\n+    case CFN_BUILT_IN_ISINFD64:\n+    case CFN_BUILT_IN_ISINFD128:\n       if (real_isinf (arg))\n \t*result = wi::shwi (arg->sign ? -1 : 1, precision);\n       else\n \t*result = wi::shwi (0, precision);\n       return true;\n \n-    CASE_FLT_FN (BUILT_IN_ISNAN):\n-    case BUILT_IN_ISNAND32:\n-    case BUILT_IN_ISNAND64:\n-    case BUILT_IN_ISNAND128:\n+    CASE_CFN_ISNAN:\n+    case CFN_BUILT_IN_ISNAND32:\n+    case CFN_BUILT_IN_ISNAND64:\n+    case CFN_BUILT_IN_ISNAND128:\n       *result = wi::shwi (real_isnan (arg) ? 1 : 0, precision);\n       return true;\n \n@@ -815,17 +816,16 @@ fold_const_call_ss (wide_int *result, built_in_function fn,\n    in the result.  Return true on success.  */\n \n static bool\n-fold_const_call_ss (wide_int *result, built_in_function fn,\n-\t\t    const wide_int_ref &arg, unsigned int precision,\n-\t\t    tree arg_type)\n+fold_const_call_ss (wide_int *result, combined_fn fn, const wide_int_ref &arg,\n+\t\t    unsigned int precision, tree arg_type)\n {\n   switch (fn)\n     {\n-    CASE_INT_FN (BUILT_IN_FFS):\n+    CASE_CFN_FFS:\n       *result = wi::shwi (wi::ffs (arg), precision);\n       return true;\n \n-    CASE_INT_FN (BUILT_IN_CLZ):\n+    CASE_CFN_CLZ:\n       {\n \tint tmp;\n \tif (wi::ne_p (arg, 0))\n@@ -836,7 +836,7 @@ fold_const_call_ss (wide_int *result, built_in_function fn,\n \treturn true;\n       }\n \n-    CASE_INT_FN (BUILT_IN_CTZ):\n+    CASE_CFN_CTZ:\n       {\n \tint tmp;\n \tif (wi::ne_p (arg, 0))\n@@ -847,21 +847,21 @@ fold_const_call_ss (wide_int *result, built_in_function fn,\n \treturn true;\n       }\n \n-    CASE_INT_FN (BUILT_IN_CLRSB):\n+    CASE_CFN_CLRSB:\n       *result = wi::shwi (wi::clrsb (arg), precision);\n       return true;\n \n-    CASE_INT_FN (BUILT_IN_POPCOUNT):\n+    CASE_CFN_POPCOUNT:\n       *result = wi::shwi (wi::popcount (arg), precision);\n       return true;\n \n-    CASE_INT_FN (BUILT_IN_PARITY):\n+    CASE_CFN_PARITY:\n       *result = wi::shwi (wi::parity (arg), precision);\n       return true;\n \n-    case BUILT_IN_BSWAP16:\n-    case BUILT_IN_BSWAP32:\n-    case BUILT_IN_BSWAP64:\n+    case CFN_BUILT_IN_BSWAP16:\n+    case CFN_BUILT_IN_BSWAP32:\n+    case CFN_BUILT_IN_BSWAP64:\n       *result = wide_int::from (arg, precision, TYPE_SIGN (arg_type)).bswap ();\n       return true;\n \n@@ -880,12 +880,12 @@ fold_const_call_ss (wide_int *result, built_in_function fn,\n \n static bool\n fold_const_call_cs (real_value *result_real, real_value *result_imag,\n-\t\t    built_in_function fn, const real_value *arg,\n+\t\t    combined_fn fn, const real_value *arg,\n \t\t    const real_format *format)\n {\n   switch (fn)\n     {\n-    CASE_FLT_FN (BUILT_IN_CEXPI):\n+    CASE_CFN_CEXPI:\n       /* cexpi(x+yi) = cos(x)+sin(y)*i.  */\n       return do_mpfr_sincos (result_imag, result_real, arg, format);\n \n@@ -903,13 +903,13 @@ fold_const_call_cs (real_value *result_real, real_value *result_imag,\n    success.  */\n \n static bool\n-fold_const_call_sc (real_value *result, built_in_function fn,\n+fold_const_call_sc (real_value *result, combined_fn fn,\n \t\t    const real_value *arg_real, const real_value *arg_imag,\n \t\t    const real_format *format)\n {\n   switch (fn)\n     {\n-    CASE_FLT_FN (BUILT_IN_CABS):\n+    CASE_CFN_CABS:\n       return do_mpfr_arg2 (result, mpfr_hypot, arg_real, arg_imag, format);\n \n     default:\n@@ -927,20 +927,20 @@ fold_const_call_sc (real_value *result, built_in_function fn,\n \n static bool\n fold_const_call_cc (real_value *result_real, real_value *result_imag,\n-\t\t    built_in_function fn, const real_value *arg_real,\n+\t\t    combined_fn fn, const real_value *arg_real,\n \t\t    const real_value *arg_imag, const real_format *format)\n {\n   switch (fn)\n     {\n-    CASE_FLT_FN (BUILT_IN_CCOS):\n+    CASE_CFN_CCOS:\n       return do_mpc_arg1 (result_real, result_imag, mpc_cos,\n \t\t\t  arg_real, arg_imag, format);\n \n-    CASE_FLT_FN (BUILT_IN_CCOSH):\n+    CASE_CFN_CCOSH:\n       return do_mpc_arg1 (result_real, result_imag, mpc_cosh,\n \t\t\t  arg_real, arg_imag, format);\n \n-    CASE_FLT_FN (BUILT_IN_CPROJ):\n+    CASE_CFN_CPROJ:\n       if (real_isinf (arg_real) || real_isinf (arg_imag))\n \t{\n \t  real_inf (result_real);\n@@ -954,55 +954,55 @@ fold_const_call_cc (real_value *result_real, real_value *result_imag,\n \t}\n       return true;\n \n-    CASE_FLT_FN (BUILT_IN_CSIN):\n+    CASE_CFN_CSIN:\n       return do_mpc_arg1 (result_real, result_imag, mpc_sin,\n \t\t\t  arg_real, arg_imag, format);\n \n-    CASE_FLT_FN (BUILT_IN_CSINH):\n+    CASE_CFN_CSINH:\n       return do_mpc_arg1 (result_real, result_imag, mpc_sinh,\n \t\t\t  arg_real, arg_imag, format);\n \n-    CASE_FLT_FN (BUILT_IN_CTAN):\n+    CASE_CFN_CTAN:\n       return do_mpc_arg1 (result_real, result_imag, mpc_tan,\n \t\t\t  arg_real, arg_imag, format);\n \n-    CASE_FLT_FN (BUILT_IN_CTANH):\n+    CASE_CFN_CTANH:\n       return do_mpc_arg1 (result_real, result_imag, mpc_tanh,\n \t\t\t  arg_real, arg_imag, format);\n \n-    CASE_FLT_FN (BUILT_IN_CLOG):\n+    CASE_CFN_CLOG:\n       return do_mpc_arg1 (result_real, result_imag, mpc_log,\n \t\t\t  arg_real, arg_imag, format);\n \n-    CASE_FLT_FN (BUILT_IN_CSQRT):\n+    CASE_CFN_CSQRT:\n       return do_mpc_arg1 (result_real, result_imag, mpc_sqrt,\n \t\t\t  arg_real, arg_imag, format);\n \n-    CASE_FLT_FN (BUILT_IN_CASIN):\n+    CASE_CFN_CASIN:\n       return do_mpc_arg1 (result_real, result_imag, mpc_asin,\n \t\t\t  arg_real, arg_imag, format);\n \n-    CASE_FLT_FN (BUILT_IN_CACOS):\n+    CASE_CFN_CACOS:\n       return do_mpc_arg1 (result_real, result_imag, mpc_acos,\n \t\t\t  arg_real, arg_imag, format);\n \n-    CASE_FLT_FN (BUILT_IN_CATAN):\n+    CASE_CFN_CATAN:\n       return do_mpc_arg1 (result_real, result_imag, mpc_atan,\n \t\t\t  arg_real, arg_imag, format);\n \n-    CASE_FLT_FN (BUILT_IN_CASINH):\n+    CASE_CFN_CASINH:\n       return do_mpc_arg1 (result_real, result_imag, mpc_asinh,\n \t\t\t  arg_real, arg_imag, format);\n \n-    CASE_FLT_FN (BUILT_IN_CACOSH):\n+    CASE_CFN_CACOSH:\n       return do_mpc_arg1 (result_real, result_imag, mpc_acosh,\n \t\t\t  arg_real, arg_imag, format);\n \n-    CASE_FLT_FN (BUILT_IN_CATANH):\n+    CASE_CFN_CATANH:\n       return do_mpc_arg1 (result_real, result_imag, mpc_atanh,\n \t\t\t  arg_real, arg_imag, format);\n \n-    CASE_FLT_FN (BUILT_IN_CEXP):\n+    CASE_CFN_CEXP:\n       return do_mpc_arg1 (result_real, result_imag, mpc_exp,\n \t\t\t  arg_real, arg_imag, format);\n \n@@ -1015,7 +1015,7 @@ fold_const_call_cc (real_value *result_real, real_value *result_imag,\n    where the arguments and result are numerical.  */\n \n static tree\n-fold_const_call_1 (built_in_function fn, tree type, tree arg)\n+fold_const_call_1 (combined_fn fn, tree type, tree arg)\n {\n   machine_mode mode = TYPE_MODE (type);\n   machine_mode arg_mode = TYPE_MODE (TREE_TYPE (arg));\n@@ -1110,22 +1110,22 @@ fold_const_call_1 (built_in_function fn, tree type, tree arg)\n    otherwise return null.  TYPE is the type of the return value.  */\n \n tree\n-fold_const_call (built_in_function fn, tree type, tree arg)\n+fold_const_call (combined_fn fn, tree type, tree arg)\n {\n   switch (fn)\n     {\n-    case BUILT_IN_STRLEN:\n+    case CFN_BUILT_IN_STRLEN:\n       if (const char *str = c_getstr (arg))\n \treturn build_int_cst (type, strlen (str));\n       return NULL_TREE;\n \n-    CASE_FLT_FN (BUILT_IN_NAN):\n-    case BUILT_IN_NAND32:\n-    case BUILT_IN_NAND64:\n-    case BUILT_IN_NAND128:\n+    CASE_CFN_NAN:\n+    case CFN_BUILT_IN_NAND32:\n+    case CFN_BUILT_IN_NAND64:\n+    case CFN_BUILT_IN_NAND128:\n       return fold_const_builtin_nan (type, arg, true);\n \n-    CASE_FLT_FN (BUILT_IN_NANS):\n+    CASE_CFN_NANS:\n       return fold_const_builtin_nan (type, arg, false);\n \n     default:\n@@ -1140,37 +1140,37 @@ fold_const_call (built_in_function fn, tree type, tree arg)\n    in format FORMAT.  Return true on success.  */\n \n static bool\n-fold_const_call_sss (real_value *result, built_in_function fn,\n+fold_const_call_sss (real_value *result, combined_fn fn,\n \t\t     const real_value *arg0, const real_value *arg1,\n \t\t     const real_format *format)\n {\n   switch (fn)\n     {\n-    CASE_FLT_FN (BUILT_IN_DREM):\n-    CASE_FLT_FN (BUILT_IN_REMAINDER):\n+    CASE_CFN_DREM:\n+    CASE_CFN_REMAINDER:\n       return do_mpfr_arg2 (result, mpfr_remainder, arg0, arg1, format);\n \n-    CASE_FLT_FN (BUILT_IN_ATAN2):\n+    CASE_CFN_ATAN2:\n       return do_mpfr_arg2 (result, mpfr_atan2, arg0, arg1, format);\n \n-    CASE_FLT_FN (BUILT_IN_FDIM):\n+    CASE_CFN_FDIM:\n       return do_mpfr_arg2 (result, mpfr_dim, arg0, arg1, format);\n \n-    CASE_FLT_FN (BUILT_IN_HYPOT):\n+    CASE_CFN_HYPOT:\n       return do_mpfr_arg2 (result, mpfr_hypot, arg0, arg1, format);\n \n-    CASE_FLT_FN (BUILT_IN_COPYSIGN):\n+    CASE_CFN_COPYSIGN:\n       *result = *arg0;\n       real_copysign (result, arg1);\n       return true;\n \n-    CASE_FLT_FN (BUILT_IN_FMIN):\n+    CASE_CFN_FMIN:\n       return do_mpfr_arg2 (result, mpfr_min, arg0, arg1, format);\n \n-    CASE_FLT_FN (BUILT_IN_FMAX):\n+    CASE_CFN_FMAX:\n       return do_mpfr_arg2 (result, mpfr_max, arg0, arg1, format);\n \n-    CASE_FLT_FN (BUILT_IN_POW):\n+    CASE_CFN_POW:\n       return fold_const_pow (result, arg0, arg1, format);\n \n     default:\n@@ -1186,22 +1186,22 @@ fold_const_call_sss (real_value *result, built_in_function fn,\n    success.  */\n \n static bool\n-fold_const_call_sss (real_value *result, built_in_function fn,\n+fold_const_call_sss (real_value *result, combined_fn fn,\n \t\t     const real_value *arg0, const wide_int_ref &arg1,\n \t\t     const real_format *format)\n {\n   switch (fn)\n     {\n-    CASE_FLT_FN (BUILT_IN_LDEXP):\n+    CASE_CFN_LDEXP:\n       return fold_const_builtin_load_exponent (result, arg0, arg1, format);\n \n-    CASE_FLT_FN (BUILT_IN_SCALBN):\n-    CASE_FLT_FN (BUILT_IN_SCALBLN):\n+    CASE_CFN_SCALBN:\n+    CASE_CFN_SCALBLN:\n       return (format->b == 2\n \t      && fold_const_builtin_load_exponent (result, arg0, arg1,\n \t\t\t\t\t\t   format));\n \n-    CASE_FLT_FN (BUILT_IN_POWI):\n+    CASE_CFN_POWI:\n       real_powi (result, format, arg0, arg1.to_shwi ());\n       return true;\n \n@@ -1218,16 +1218,16 @@ fold_const_call_sss (real_value *result, built_in_function fn,\n    success.  */\n \n static bool\n-fold_const_call_sss (real_value *result, built_in_function fn,\n+fold_const_call_sss (real_value *result, combined_fn fn,\n \t\t     const wide_int_ref &arg0, const real_value *arg1,\n \t\t     const real_format *format)\n {\n   switch (fn)\n     {\n-    CASE_FLT_FN (BUILT_IN_JN):\n+    CASE_CFN_JN:\n       return do_mpfr_arg2 (result, mpfr_jn, arg0, arg1, format);\n \n-    CASE_FLT_FN (BUILT_IN_YN):\n+    CASE_CFN_YN:\n       return (real_compare (GT_EXPR, arg1, &dconst0)\n \t      && do_mpfr_arg2 (result, mpfr_yn, arg0, arg1, format));\n \n@@ -1246,13 +1246,13 @@ fold_const_call_sss (real_value *result, built_in_function fn,\n \n static bool\n fold_const_call_ccc (real_value *result_real, real_value *result_imag,\n-\t\t     built_in_function fn, const real_value *arg0_real,\n+\t\t     combined_fn fn, const real_value *arg0_real,\n \t\t     const real_value *arg0_imag, const real_value *arg1_real,\n \t\t     const real_value *arg1_imag, const real_format *format)\n {\n   switch (fn)\n     {\n-    CASE_FLT_FN (BUILT_IN_CPOW):\n+    CASE_CFN_CPOW:\n       return do_mpc_arg2 (result_real, result_imag, mpc_pow,\n \t\t\t  arg0_real, arg0_imag, arg1_real, arg1_imag, format);\n \n@@ -1265,7 +1265,7 @@ fold_const_call_ccc (real_value *result_real, real_value *result_imag,\n    where the arguments and result are numerical.  */\n \n static tree\n-fold_const_call_1 (built_in_function fn, tree type, tree arg0, tree arg1)\n+fold_const_call_1 (combined_fn fn, tree type, tree arg0, tree arg1)\n {\n   machine_mode mode = TYPE_MODE (type);\n   machine_mode arg0_mode = TYPE_MODE (TREE_TYPE (arg0));\n@@ -1357,22 +1357,22 @@ fold_const_call_1 (built_in_function fn, tree type, tree arg0, tree arg1)\n    otherwise return null.  TYPE is the type of the return value.  */\n \n tree\n-fold_const_call (built_in_function fn, tree type, tree arg0, tree arg1)\n+fold_const_call (combined_fn fn, tree type, tree arg0, tree arg1)\n {\n   const char *p0, *p1;\n   switch (fn)\n     {\n-    case BUILT_IN_STRSPN:\n+    case CFN_BUILT_IN_STRSPN:\n       if ((p0 = c_getstr (arg0)) && (p1 = c_getstr (arg1)))\n \treturn build_int_cst (type, strspn (p0, p1));\n       return NULL_TREE;\n \n-    case BUILT_IN_STRCSPN:\n+    case CFN_BUILT_IN_STRCSPN:\n       if ((p0 = c_getstr (arg0)) && (p1 = c_getstr (arg1)))\n \treturn build_int_cst (type, strcspn (p0, p1));\n       return NULL_TREE;\n \n-    case BUILT_IN_STRCMP:\n+    case CFN_BUILT_IN_STRCMP:\n       if ((p0 = c_getstr (arg0)) && (p1 = c_getstr (arg1)))\n \treturn build_cmp_result (type, strcmp (p0, p1));\n       return NULL_TREE;\n@@ -1389,13 +1389,13 @@ fold_const_call (built_in_function fn, tree type, tree arg0, tree arg1)\n    in format FORMAT.  Return true on success.  */\n \n static bool\n-fold_const_call_ssss (real_value *result, built_in_function fn,\n+fold_const_call_ssss (real_value *result, combined_fn fn,\n \t\t      const real_value *arg0, const real_value *arg1,\n \t\t      const real_value *arg2, const real_format *format)\n {\n   switch (fn)\n     {\n-    CASE_FLT_FN (BUILT_IN_FMA):\n+    CASE_CFN_FMA:\n       return do_mpfr_arg3 (result, mpfr_fma, arg0, arg1, arg2, format);\n \n     default:\n@@ -1407,8 +1407,7 @@ fold_const_call_ssss (real_value *result, built_in_function fn,\n    where the arguments and result are numerical.  */\n \n static tree\n-fold_const_call_1 (built_in_function fn, tree type, tree arg0, tree arg1,\n-\t\t   tree arg2)\n+fold_const_call_1 (combined_fn fn, tree type, tree arg0, tree arg1, tree arg2)\n {\n   machine_mode mode = TYPE_MODE (type);\n   machine_mode arg0_mode = TYPE_MODE (TREE_TYPE (arg0));\n@@ -1442,22 +1441,21 @@ fold_const_call_1 (built_in_function fn, tree type, tree arg0, tree arg1,\n    success, otherwise return null.  TYPE is the type of the return value.  */\n \n tree\n-fold_const_call (built_in_function fn, tree type, tree arg0, tree arg1,\n-\t\t tree arg2)\n+fold_const_call (combined_fn fn, tree type, tree arg0, tree arg1, tree arg2)\n {\n   const char *p0, *p1;\n   size_t s2;\n   switch (fn)\n     {\n-    case BUILT_IN_STRNCMP:\n+    case CFN_BUILT_IN_STRNCMP:\n       if ((p0 = c_getstr (arg0))\n \t  && (p1 = c_getstr (arg1))\n \t  && host_size_t_cst_p (arg2, &s2))\n \treturn build_int_cst (type, strncmp (p0, p1, s2));\n       return NULL_TREE;\n \n-    case BUILT_IN_BCMP:\n-    case BUILT_IN_MEMCMP:\n+    case CFN_BUILT_IN_BCMP:\n+    case CFN_BUILT_IN_MEMCMP:\n       if ((p0 = c_getstr (arg0))\n \t  && (p1 = c_getstr (arg1))\n \t  && host_size_t_cst_p (arg2, &s2)"}, {"sha": "2cb2c5b3d2fe2571e1181af445381e94665de42b", "filename": "gcc/fold-const-call.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7ebef0648bc358514ed2048a46b22f801c19689/gcc%2Ffold-const-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7ebef0648bc358514ed2048a46b22f801c19689/gcc%2Ffold-const-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const-call.h?ref=d7ebef0648bc358514ed2048a46b22f801c19689", "patch": "@@ -20,9 +20,9 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_FOLD_CONST_CALL_H\n #define GCC_FOLD_CONST_CALL_H\n \n-tree fold_const_call (built_in_function, tree, tree);\n-tree fold_const_call (built_in_function, tree, tree, tree);\n-tree fold_const_call (built_in_function, tree, tree, tree, tree);\n+tree fold_const_call (combined_fn, tree, tree);\n+tree fold_const_call (combined_fn, tree, tree, tree);\n+tree fold_const_call (combined_fn, tree, tree, tree, tree);\n tree fold_fma (location_t, tree, tree, tree, tree);\n \n #endif"}]}