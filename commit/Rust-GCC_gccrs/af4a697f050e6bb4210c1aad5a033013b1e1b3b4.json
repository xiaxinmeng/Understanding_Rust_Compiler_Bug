{"sha": "af4a697f050e6bb4210c1aad5a033013b1e1b3b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY0YTY5N2YwNTBlNmJiNDIxMGMxYWFkNWEwMzMwMTNiMWUxYjNiNA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-04-08T02:49:42Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-04-08T02:49:42Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r702", "tree": {"sha": "d714b29f6715cdffdd04d81b23c6ab2e50a29720", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d714b29f6715cdffdd04d81b23c6ab2e50a29720"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af4a697f050e6bb4210c1aad5a033013b1e1b3b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af4a697f050e6bb4210c1aad5a033013b1e1b3b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af4a697f050e6bb4210c1aad5a033013b1e1b3b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af4a697f050e6bb4210c1aad5a033013b1e1b3b4/comments", "author": null, "committer": null, "parents": [{"sha": "0ea674bc2db8b819a0679619e6414f1d5107f2a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ea674bc2db8b819a0679619e6414f1d5107f2a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ea674bc2db8b819a0679619e6414f1d5107f2a2"}], "stats": {"total": 59, "additions": 19, "deletions": 40}, "files": [{"sha": "821caaf80d1434115512a4729920eea680fdf72a", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4a697f050e6bb4210c1aad5a033013b1e1b3b4/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4a697f050e6bb4210c1aad5a033013b1e1b3b4/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=af4a697f050e6bb4210c1aad5a033013b1e1b3b4", "patch": "@@ -590,34 +590,6 @@ simple_memory_operand (op, mode)\n   return FALSE;\n }\n \n-/* Return true if the address is suitable for function call.  */\n-\n-int\n-call_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  rtx addr;\n-  enum rtx_code code;\n-\n-  if (GET_CODE (op) != MEM)\n-    return FALSE;\n-\n-  addr = XEXP (op, 0);\n-  code = GET_CODE (addr);\n-\n-  if (GET_MODE (addr) != FUNCTION_MODE)\n-    return FALSE;\n-\n-  if (code == REG || code == SUBREG)\n-    return TRUE;\n-\n-  if (CONSTANT_ADDRESS_P (addr))\n-    return TRUE;\n-\n-  return FALSE;\n-}\n-\n /* Return true if the code of this rtx pattern is EQ or NE.  */\n \n int"}, {"sha": "2d05266397bd2006262b0b6b6f381bbc980aa319", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4a697f050e6bb4210c1aad5a033013b1e1b3b4/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4a697f050e6bb4210c1aad5a033013b1e1b3b4/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=af4a697f050e6bb4210c1aad5a033013b1e1b3b4", "patch": "@@ -105,7 +105,6 @@ extern struct rtx_def *mips_load_reg4;\t/* 4th reg to check for load delay */\n extern void\t\tabort_with_insn ();\n extern int\t\tarith32_operand ();\n extern int\t\tarith_operand ();\n-extern int\t\tcall_memory_operand ();\n extern int\t\tcmp_op ();\n extern int\t\tcmp2_op ();\n extern unsigned long\tcompute_frame_size ();\n@@ -1992,7 +1991,7 @@ __enable_execute_stack (addr)\t\t\t\t\t\t\\\n    addition to `const_int' and `const_double' expressions.  */\n \n #define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\t\\\n-  (CONSTANT_P (X) && (!HALF_PIC_P () || HALF_PIC_ADDRESS_P (X)))\n+  (CONSTANT_P (X) && (!HALF_PIC_P () || !HALF_PIC_ADDRESS_P (X)))\n \n \n /* Nonzero if the constant value X is a legitimate general operand.\n@@ -2449,7 +2448,6 @@ while (0)\n   {\"md_register_operand\",\t{ REG }},\t\t\t\t\\\n   {\"mips_const_double_ok\",\t{ CONST_DOUBLE }},\t\t\t\\\n   {\"simple_memory_operand\",\t{ MEM, SUBREG }},\t\t\t\\\n-  {\"call_memory_operand\",\t{ MEM, SUBREG }},\t\t\t\\\n   {\"equality_op\",\t\t{ EQ, NE }},\t\t\t\t\\\n   {\"cmp_op\",\t\t\t{ EQ, NE, GT, GE, GTU, GEU, LT, LE,\t\\\n \t\t\t\t  LTU, LEU }},\t\t\t\t\\"}, {"sha": "97b571e984ccd1968715128d864bfe55d14257fe", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4a697f050e6bb4210c1aad5a033013b1e1b3b4/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4a697f050e6bb4210c1aad5a033013b1e1b3b4/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=af4a697f050e6bb4210c1aad5a033013b1e1b3b4", "patch": "@@ -3540,7 +3540,7 @@ move\\\\t%0,%z4\\\\n\\\\\n ;; calls.c now passes a third argument, make saber happy\n \n (define_expand \"call\"\n-  [(parallel [(call (match_operand 0 \"call_memory_operand\" \"m\")\n+  [(parallel [(call (match_operand 0 \"memory_operand\" \"m\")\n \t\t    (match_operand 1 \"\" \"i\"))\n \t      (clobber (match_operand 2 \"\" \"\"))])]\t;; overwrite op2 with $31\n   \"\"\n@@ -3551,12 +3551,12 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[2] = gen_rtx (REG, SImode, GP_REG_FIRST + 31);\n \n   addr = XEXP (operands[0], 0);\n-  if (! call_memory_operand (addr, VOIDmode))\n+  if (GET_CODE (addr) != REG && !CONSTANT_ADDRESS_P (addr))\n     XEXP (operands[0], 0) = force_reg (FUNCTION_MODE, addr);\n }\")\n \n (define_insn \"call_internal\"\n-  [(call (match_operand 0 \"call_memory_operand\" \"m\")\n+  [(call (match_operand 0 \"memory_operand\" \"m\")\n \t (match_operand 1 \"\" \"i\"))\n    (clobber (match_operand:SI 2 \"register_operand\" \"=d\"))]\n   \"\"\n@@ -3582,7 +3582,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_expand \"call_value\"\n   [(parallel [(set (match_operand 0 \"register_operand\" \"=df\")\n-\t\t   (call (match_operand 1 \"call_memory_operand\" \"m\")\n+\t\t   (call (match_operand 1 \"memory_operand\" \"m\")\n \t\t\t (match_operand 2 \"\" \"i\")))\n \t      (clobber (match_operand 3 \"\" \"\"))])]\t;; overwrite op3 with $31\n   \"\"\n@@ -3593,13 +3593,13 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[3] = gen_rtx (REG, SImode, GP_REG_FIRST + 31);\n \n   addr = XEXP (operands[1], 0);\n-  if (! call_memory_operand (addr, VOIDmode))\n+  if (GET_CODE (addr) != REG && !CONSTANT_ADDRESS_P (addr))\n     XEXP (operands[1], 0) = force_reg (FUNCTION_MODE, addr);\n }\")\n \n (define_insn \"call_value_internal\"\n   [(set (match_operand 0 \"register_operand\" \"=df\")\n-        (call (match_operand 1 \"call_memory_operand\" \"m\")\n+        (call (match_operand 1 \"memory_operand\" \"m\")\n               (match_operand 2 \"\" \"i\")))\n    (clobber (match_operand:SI 3 \"register_operand\" \"=d\"))]\n   \"\""}, {"sha": "0b8a61c76d86da6d04613e63f5f78da38208326a", "filename": "gcc/halfpic.h", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4a697f050e6bb4210c1aad5a033013b1e1b3b4/gcc%2Fhalfpic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4a697f050e6bb4210c1aad5a033013b1e1b3b4/gcc%2Fhalfpic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhalfpic.h?ref=af4a697f050e6bb4210c1aad5a033013b1e1b3b4", "patch": "@@ -17,15 +17,24 @@ You should have received a copy of the GNU General Public License\n along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n-extern int flag_half_pic;\t\t/* Global half-pic flag.  */\n+extern int  flag_half_pic;\t\t/* Global half-pic flag.  */\n extern void half_pic_encode ();\t\t/* encode whether half-pic */\n extern void half_pic_init ();\t\t/* half_pic initialization */\n-extern int half_pic_address_p ();\t/* true if an address is half-pic */\n+extern void half_pic_finish ();\t\t/* half_pic termination */\n+extern int  half_pic_address_p ();\t/* true if an address is half-pic */\n+extern struct rtx_def *half_pic_ptr ();\t/* return RTX for half-pic pointer */\n \n /* Macros to provide access to the half-pic stuff (so they can easily\n    be stubbed out.  */\n \n #define HALF_PIC_P()\t\t(flag_half_pic)\n #define HALF_PIC_ENCODE(DECL)\thalf_pic_encode (DECL)\n #define HALF_PIC_INIT()\t\thalf_pic_init ()\n-#define HALF_PIC_ADDRESS_P(X)\t(flag_half_pic && half_pic_address_p (X))\n+#define HALF_PIC_FINISH(STREAM)\thalf_pic_finish (STREAM)\n+#define HALF_PIC_ADDRESS_P(X)\thalf_pic_address_p (X)\n+#define HALF_PIC_PTR(X)\t\thalf_pic_ptr (X)\n+\n+/* Prefix for half-pic names */\n+#ifndef HALF_PIC_PREFIX\n+#define\tHALF_PIC_PREFIX\t\"__pic_\"\n+#endif"}]}