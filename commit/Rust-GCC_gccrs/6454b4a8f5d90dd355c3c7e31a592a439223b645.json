{"sha": "6454b4a8f5d90dd355c3c7e31a592a439223b645", "node_id": "C_kwDOANBUbNoAKDY0NTRiNGE4ZjVkOTBkZDM1NWMzYzdlMzFhNTkyYTQzOTIyM2I2NDU", "commit": {"author": {"name": "Takayuki 'January June' Suwa", "email": "jjsuwa_sys3175@yahoo.co.jp", "date": "2022-05-23T15:52:44Z"}, "committer": {"name": "Max Filippov", "email": "jcmvbkbc@gmail.com", "date": "2022-05-27T04:54:40Z"}, "message": "xtensa: Add setmemsi insn pattern\n\nThis patch introduces setmemsi insn pattern of two kinds, unrolled loop and\nsmall loop, for fixed small length and constant initialization value.\n\ngcc/ChangeLog:\n\n\t* config/xtensa/xtensa-protos.h\n\t(xtensa_expand_block_set_unrolled_loop,\n\txtensa_expand_block_set_small_loop): New prototypes.\n\t* config/xtensa/xtensa.cc (xtensa_sizeof_MOVI,\n\txtensa_expand_block_set_unrolled_loop,\n\txtensa_expand_block_set_small_loop): New functions.\n\t* config/xtensa/xtensa.md (setmemsi): New expansion pattern.\n\t* config/xtensa/xtensa.opt (mlongcalls): Add target mask.", "tree": {"sha": "70625a755a800666695950116cc7dc939421d2cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70625a755a800666695950116cc7dc939421d2cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6454b4a8f5d90dd355c3c7e31a592a439223b645", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6454b4a8f5d90dd355c3c7e31a592a439223b645", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6454b4a8f5d90dd355c3c7e31a592a439223b645", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6454b4a8f5d90dd355c3c7e31a592a439223b645/comments", "author": {"login": "jjsuwa-sys3175", "id": 73290592, "node_id": "MDQ6VXNlcjczMjkwNTky", "avatar_url": "https://avatars.githubusercontent.com/u/73290592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jjsuwa-sys3175", "html_url": "https://github.com/jjsuwa-sys3175", "followers_url": "https://api.github.com/users/jjsuwa-sys3175/followers", "following_url": "https://api.github.com/users/jjsuwa-sys3175/following{/other_user}", "gists_url": "https://api.github.com/users/jjsuwa-sys3175/gists{/gist_id}", "starred_url": "https://api.github.com/users/jjsuwa-sys3175/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jjsuwa-sys3175/subscriptions", "organizations_url": "https://api.github.com/users/jjsuwa-sys3175/orgs", "repos_url": "https://api.github.com/users/jjsuwa-sys3175/repos", "events_url": "https://api.github.com/users/jjsuwa-sys3175/events{/privacy}", "received_events_url": "https://api.github.com/users/jjsuwa-sys3175/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jcmvbkbc", "id": 166731, "node_id": "MDQ6VXNlcjE2NjczMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/166731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jcmvbkbc", "html_url": "https://github.com/jcmvbkbc", "followers_url": "https://api.github.com/users/jcmvbkbc/followers", "following_url": "https://api.github.com/users/jcmvbkbc/following{/other_user}", "gists_url": "https://api.github.com/users/jcmvbkbc/gists{/gist_id}", "starred_url": "https://api.github.com/users/jcmvbkbc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jcmvbkbc/subscriptions", "organizations_url": "https://api.github.com/users/jcmvbkbc/orgs", "repos_url": "https://api.github.com/users/jcmvbkbc/repos", "events_url": "https://api.github.com/users/jcmvbkbc/events{/privacy}", "received_events_url": "https://api.github.com/users/jcmvbkbc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2cb88fb45a68fc91bda1c69d9486e824c4a559e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2cb88fb45a68fc91bda1c69d9486e824c4a559e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2cb88fb45a68fc91bda1c69d9486e824c4a559e"}], "stats": {"total": 231, "additions": 230, "deletions": 1}, "files": [{"sha": "30e4b54394a9a899dd65621f75a3b1cbf98b1ac5", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6454b4a8f5d90dd355c3c7e31a592a439223b645/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6454b4a8f5d90dd355c3c7e31a592a439223b645/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=6454b4a8f5d90dd355c3c7e31a592a439223b645", "patch": "@@ -41,6 +41,8 @@ extern void xtensa_expand_conditional_branch (rtx *, machine_mode);\n extern int xtensa_expand_conditional_move (rtx *, int);\n extern int xtensa_expand_scc (rtx *, machine_mode);\n extern int xtensa_expand_block_move (rtx *);\n+extern int xtensa_expand_block_set_unrolled_loop (rtx *);\n+extern int xtensa_expand_block_set_small_loop (rtx *);\n extern void xtensa_split_operand_pair (rtx *, machine_mode);\n extern int xtensa_emit_move_sequence (rtx *, machine_mode);\n extern rtx xtensa_copy_incoming_a7 (rtx);"}, {"sha": "c7b54babc3704c3ed637daa9e2862c3df6019673", "filename": "gcc/config/xtensa/xtensa.cc", "status": "modified", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6454b4a8f5d90dd355c3c7e31a592a439223b645/gcc%2Fconfig%2Fxtensa%2Fxtensa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6454b4a8f5d90dd355c3c7e31a592a439223b645/gcc%2Fconfig%2Fxtensa%2Fxtensa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.cc?ref=6454b4a8f5d90dd355c3c7e31a592a439223b645", "patch": "@@ -1373,6 +1373,217 @@ xtensa_expand_block_move (rtx *operands)\n }\n \n \n+/* Try to expand a block set operation to a sequence of RTL move\n+   instructions.  If not optimizing, or if the block size is not a\n+   constant, or if the block is too large, or if the value to\n+   initialize the block with is not a constant, the expansion\n+   fails and GCC falls back to calling memset().\n+\n+   operands[0] is the destination\n+   operands[1] is the length\n+   operands[2] is the initialization value\n+   operands[3] is the alignment */\n+\n+static int\n+xtensa_sizeof_MOVI (HOST_WIDE_INT imm)\n+{\n+  return (TARGET_DENSITY && IN_RANGE (imm, -32, 95)) ? 2 : 3;\n+}\n+\n+int\n+xtensa_expand_block_set_unrolled_loop (rtx *operands)\n+{\n+  rtx dst_mem = operands[0];\n+  HOST_WIDE_INT bytes, value, align;\n+  int expand_len, funccall_len;\n+  rtx x, reg;\n+  int offset;\n+\n+  if (!CONST_INT_P (operands[1]) || !CONST_INT_P (operands[2]))\n+    return 0;\n+\n+  bytes = INTVAL (operands[1]);\n+  if (bytes <= 0)\n+    return 0;\n+  value = (int8_t)INTVAL (operands[2]);\n+  align = INTVAL (operands[3]);\n+  if (align > MOVE_MAX)\n+    align = MOVE_MAX;\n+\n+  /* Insn expansion: holding the init value.\n+     Either MOV(.N) or L32R w/litpool.  */\n+  if (align == 1)\n+    expand_len = xtensa_sizeof_MOVI (value);\n+  else if (value == 0 || value == -1)\n+    expand_len = TARGET_DENSITY ? 2 : 3;\n+  else\n+    expand_len = 3 + 4;\n+  /* Insn expansion: a series of aligned memory stores.\n+     Consist of S8I, S16I or S32I(.N).  */\n+  expand_len += (bytes / align) * (TARGET_DENSITY\n+\t\t\t\t   && align == 4 ? 2 : 3);\n+  /* Insn expansion: the remainder, sub-aligned memory stores.\n+     A combination of S8I and S16I as needed.  */\n+  expand_len += ((bytes % align + 1) / 2) * 3;\n+\n+  /* Function call: preparing two arguments.  */\n+  funccall_len = xtensa_sizeof_MOVI (value);\n+  funccall_len += xtensa_sizeof_MOVI (bytes);\n+  /* Function call: calling memset().  */\n+  funccall_len += TARGET_LONGCALLS ? (3 + 4 + 3) : 3;\n+\n+  /* Apply expansion bonus (2x) if optimizing for speed.  */\n+  if (optimize > 1 && !optimize_size)\n+    funccall_len *= 2;\n+\n+  /* Decide whether to expand or not, based on the sum of the length\n+     of instructions.  */\n+  if (expand_len > funccall_len)\n+    return 0;\n+\n+  x = XEXP (dst_mem, 0);\n+  if (!REG_P (x))\n+    dst_mem = replace_equiv_address (dst_mem, force_reg (Pmode, x));\n+  switch (align)\n+    {\n+    case 1:\n+      break;\n+    case 2:\n+      value = (int16_t)((uint8_t)value * 0x0101U);\n+      break;\n+    case 4:\n+      value = (int32_t)((uint8_t)value * 0x01010101U);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  reg = force_reg (SImode, GEN_INT (value));\n+\n+  offset = 0;\n+  do\n+    {\n+      int unit_size = MIN (bytes, align);\n+      machine_mode unit_mode = (unit_size >= 4 ? SImode :\n+\t\t\t       (unit_size >= 2 ? HImode :\n+\t\t\t\t\t\t QImode));\n+      unit_size = GET_MODE_SIZE (unit_mode);\n+\n+      emit_move_insn (adjust_address (dst_mem, unit_mode, offset),\n+\t\t      unit_mode == SImode ? reg\n+\t\t      : convert_to_mode (unit_mode, reg, true));\n+\n+      offset += unit_size;\n+      bytes -= unit_size;\n+    }\n+  while (bytes > 0);\n+\n+  return 1;\n+}\n+\n+int\n+xtensa_expand_block_set_small_loop (rtx *operands)\n+{\n+  HOST_WIDE_INT bytes, value, align;\n+  int expand_len, funccall_len;\n+  rtx x, dst, end, reg;\n+  machine_mode unit_mode;\n+  rtx_code_label *label;\n+\n+  if (!CONST_INT_P (operands[1]) || !CONST_INT_P (operands[2]))\n+    return 0;\n+\n+  bytes = INTVAL (operands[1]);\n+  if (bytes <= 0)\n+    return 0;\n+  value = (int8_t)INTVAL (operands[2]);\n+  align = INTVAL (operands[3]);\n+  if (align > MOVE_MAX)\n+    align = MOVE_MAX;\n+\n+  /* Totally-aligned block only.  */\n+  if (bytes % align != 0)\n+    return 0;\n+\n+  /* If 4-byte aligned, small loop substitution is almost optimal, thus\n+     limited to only offset to the end address for ADDI/ADDMI instruction.  */\n+  if (align == 4\n+      && ! (bytes <= 127 || (bytes <= 32512 && bytes % 256 == 0)))\n+    return 0;\n+\n+  /* If no 4-byte aligned, loop count should be treated as the constraint.  */\n+  if (align != 4\n+      && bytes / align > ((optimize > 1 && !optimize_size) ? 8 : 15))\n+    return 0;\n+\n+  /* Insn expansion: holding the init value.\n+     Either MOV(.N) or L32R w/litpool.  */\n+  if (align == 1)\n+    expand_len = xtensa_sizeof_MOVI (value);\n+  else if (value == 0 || value == -1)\n+    expand_len = TARGET_DENSITY ? 2 : 3;\n+  else\n+    expand_len = 3 + 4;\n+  /* Insn expansion: Either ADDI(.N) or ADDMI for the end address.  */\n+  expand_len += bytes > 127 ? 3\n+\t\t\t    : (TARGET_DENSITY && bytes <= 15) ? 2 : 3;\n+\n+  /* Insn expansion: the loop body and branch instruction.\n+     For store, one of S8I, S16I or S32I(.N).\n+     For advance, ADDI(.N).\n+     For branch, BNE.  */\n+  expand_len += (TARGET_DENSITY && align == 4 ? 2 : 3)\n+\t\t+ (TARGET_DENSITY ? 2 : 3) + 3;\n+\n+  /* Function call: preparing two arguments.  */\n+  funccall_len = xtensa_sizeof_MOVI (value);\n+  funccall_len += xtensa_sizeof_MOVI (bytes);\n+  /* Function call: calling memset().  */\n+  funccall_len += TARGET_LONGCALLS ? (3 + 4 + 3) : 3;\n+\n+  /* Apply expansion bonus (2x) if optimizing for speed.  */\n+  if (optimize > 1 && !optimize_size)\n+    funccall_len *= 2;\n+\n+  /* Decide whether to expand or not, based on the sum of the length\n+     of instructions.  */\n+  if (expand_len > funccall_len)\n+    return 0;\n+\n+  x = XEXP (operands[0], 0);\n+  if (!REG_P (x))\n+    x = XEXP (replace_equiv_address (operands[0], force_reg (Pmode, x)), 0);\n+  dst = gen_reg_rtx (SImode);\n+  emit_move_insn (dst, x);\n+  end = gen_reg_rtx (SImode);\n+  emit_insn (gen_addsi3 (end, dst, operands[1] /* the length */));\n+  switch (align)\n+    {\n+    case 1:\n+      unit_mode = QImode;\n+      break;\n+    case 2:\n+      value = (int16_t)((uint8_t)value * 0x0101U);\n+      unit_mode = HImode;\n+      break;\n+    case 4:\n+      value = (int32_t)((uint8_t)value * 0x01010101U);\n+      unit_mode = SImode;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  reg = force_reg (unit_mode, GEN_INT (value));\n+\n+  label = gen_label_rtx ();\n+  emit_label (label);\n+  emit_move_insn (gen_rtx_MEM (unit_mode, dst), reg);\n+  emit_insn (gen_addsi3 (dst, dst, GEN_INT (align)));\n+  emit_cmp_and_jump_insns (dst, end, NE, const0_rtx, SImode, true, label);\n+\n+  return 1;\n+}\n+\n+\n void\n xtensa_expand_nonlocal_goto (rtx *operands)\n {"}, {"sha": "2d146b7995c91238d97c540c72b9f5f9173503e9", "filename": "gcc/config/xtensa/xtensa.md", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6454b4a8f5d90dd355c3c7e31a592a439223b645/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6454b4a8f5d90dd355c3c7e31a592a439223b645/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.md?ref=6454b4a8f5d90dd355c3c7e31a592a439223b645", "patch": "@@ -1080,6 +1080,22 @@\n   DONE;\n })\n \n+;; Block sets\n+\n+(define_expand \"setmemsi\"\n+  [(match_operand:BLK 0 \"memory_operand\")\n+   (match_operand:SI 1 \"\")\n+   (match_operand:SI 2 \"\")\n+   (match_operand:SI 3 \"const_int_operand\")]\n+  \"!optimize_debug && optimize\"\n+{\n+  if (xtensa_expand_block_set_unrolled_loop (operands))\n+    DONE;\n+  if (xtensa_expand_block_set_small_loop (operands))\n+    DONE;\n+  FAIL;\n+})\n+\n \f\n ;; Shift instructions.\n "}, {"sha": "1fc68a3d994d39a2fe6db5cfd320f15db684750a", "filename": "gcc/config/xtensa/xtensa.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6454b4a8f5d90dd355c3c7e31a592a439223b645/gcc%2Fconfig%2Fxtensa%2Fxtensa.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6454b4a8f5d90dd355c3c7e31a592a439223b645/gcc%2Fconfig%2Fxtensa%2Fxtensa.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.opt?ref=6454b4a8f5d90dd355c3c7e31a592a439223b645", "patch": "@@ -27,7 +27,7 @@ Target Mask(FORCE_NO_PIC)\n Disable position-independent code (PIC) for use in OS kernel code.\n \n mlongcalls\n-Target\n+Target Mask(LONGCALLS)\n Use indirect CALLXn instructions for large programs.\n \n mtarget-align"}]}