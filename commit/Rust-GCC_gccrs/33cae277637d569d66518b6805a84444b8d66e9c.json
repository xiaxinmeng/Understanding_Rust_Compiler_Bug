{"sha": "33cae277637d569d66518b6805a84444b8d66e9c", "node_id": "C_kwDOANBUbNoAKDMzY2FlMjc3NjM3ZDU2OWQ2NjUxOGI2ODA1YTg0NDQ0YjhkNjZlOWM", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-08-20T10:41:53Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-08-26T18:45:30Z"}, "message": "Add set/get functions for negative infinity in real.*\n\nFor the frange implementation with endpoints I'm about to contribute,\nwe need to set REAL_VALUE_TYPEs with negative infinity.  The support\nis already there in real.cc, but it is awkward to get at.  One could\ncall real_inf() and then negate the value, but I've added the ability\nto pass the sign argument like many of the existing real.* functions.\n\nI've declared the functions in such a way to avoid changes to the\nexisting code base:\n\n// Unchanged function returning true for either +-INF.\nbool real_isinf (const REAL_VALUE_TYPE *r);\n// New overload to be able to specify the sign.\nbool real_isinf (const REAL_VALUE_TYPE *r, int sign);\n// Replacement function for setting INF, defaults to +INF.\nvoid real_inf (REAL_VALUE_TYPE *, int sign = 0);\n\ngcc/ChangeLog:\n\n\t* real.cc (real_isinf): New overload.\n\t(real_inf): Add sign argument.\n\t* real.h (real_isinf): New overload.\n\t(real_inf): Add sign argument.", "tree": {"sha": "d42ce9f13b3e3be9f35d73776a7fd5eb2d38bfed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d42ce9f13b3e3be9f35d73776a7fd5eb2d38bfed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33cae277637d569d66518b6805a84444b8d66e9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33cae277637d569d66518b6805a84444b8d66e9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33cae277637d569d66518b6805a84444b8d66e9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33cae277637d569d66518b6805a84444b8d66e9c/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0abb78dda084a14b3d955757c6431fff71c263f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0abb78dda084a14b3d955757c6431fff71c263f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0abb78dda084a14b3d955757c6431fff71c263f3"}], "stats": {"total": 19, "additions": 15, "deletions": 4}, "files": [{"sha": "dcf41b79f608d50bf5d112ce2823bf2d16463e02", "filename": "gcc/real.cc", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33cae277637d569d66518b6805a84444b8d66e9c/gcc%2Freal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33cae277637d569d66518b6805a84444b8d66e9c/gcc%2Freal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.cc?ref=33cae277637d569d66518b6805a84444b8d66e9c", "patch": "@@ -1234,6 +1234,14 @@ real_isinf (const REAL_VALUE_TYPE *r)\n   return (r->cl == rvc_inf);\n }\n \n+/* Determine whether a floating-point value X is infinite with SIGN.  */\n+\n+bool\n+real_isinf (const REAL_VALUE_TYPE *r, bool sign)\n+{\n+  return real_isinf (r) && r->sign == sign;\n+}\n+\n /* Determine whether a floating-point value X is a NaN.  */\n \n bool\n@@ -2484,12 +2492,12 @@ dconst_sqrt2_ptr (void)\n   return &value;\n }\n \n-/* Fills R with +Inf.  */\n+/* Fills R with Inf with SIGN.  */\n \n void\n-real_inf (REAL_VALUE_TYPE *r)\n+real_inf (REAL_VALUE_TYPE *r, bool sign)\n {\n-  get_inf (r, 0);\n+  get_inf (r, sign);\n }\n \n /* Fills R with a NaN whose significand is described by STR.  If QUIET,"}, {"sha": "e01f9ed728273ccb0a8eb49e91413f4d363202e8", "filename": "gcc/real.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33cae277637d569d66518b6805a84444b8d66e9c/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33cae277637d569d66518b6805a84444b8d66e9c/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=33cae277637d569d66518b6805a84444b8d66e9c", "patch": "@@ -277,6 +277,9 @@ extern bool real_compare (int, const REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *)\n /* Determine whether a floating-point value X is infinite.  */\n extern bool real_isinf (const REAL_VALUE_TYPE *);\n \n+/* Determine whether a floating-point value X is infinite with SIGN.  */\n+extern bool real_isinf (const REAL_VALUE_TYPE *, bool sign);\n+\n /* Determine whether a floating-point value X is a NaN.  */\n extern bool real_isnan (const REAL_VALUE_TYPE *);\n \n@@ -331,7 +334,7 @@ extern long real_to_target (long *, const REAL_VALUE_TYPE *, format_helper);\n extern void real_from_target (REAL_VALUE_TYPE *, const long *,\n \t\t\t      format_helper);\n \n-extern void real_inf (REAL_VALUE_TYPE *);\n+extern void real_inf (REAL_VALUE_TYPE *, bool sign = false);\n \n extern bool real_nan (REAL_VALUE_TYPE *, const char *, int, format_helper);\n "}]}