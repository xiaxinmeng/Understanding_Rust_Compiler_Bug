{"sha": "b4e2cd5b9a995e9154b1169e83a0347d257a938c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRlMmNkNWI5YTk5NWU5MTU0YjExNjllODNhMDM0N2QyNTdhOTM4Yw==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2018-05-17T09:39:02Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2018-05-17T09:39:02Z"}, "message": "[patch AArch64] Do not perform a vector splat for vector initialisation if it is not useful\n\nIn the testcase in this patch we create an SLP vector with only two\nelements. Our current vector initialisation code will first duplicate\nthe first element to both lanes, then overwrite the top lane with a new\nvalue.\n\nThis duplication can be clunky and wasteful.\n\nBetter would be to simply use the fact that we will always be\noverwriting the remaining bits, and simply move the first element to the corrcet\nplace (implicitly zeroing all other bits).\n\nThis reduces the code generation for this case, and can allow more\nefficient addressing modes, and other second order benefits for AArch64\ncode which has been vectorized to V2DI mode.\n\nNote that the change is generic enough to catch the case for any vector\nmode, but is expected to be most useful for 2x64-bit vectorization.\n\nUnfortunately, on its own, this would cause failures in\ngcc.target/aarch64/load_v2vec_lanes_1.c and\ngcc.target/aarch64/store_v2vec_lanes.c , which expect to see many more\nvec_merge and vec_duplicate for their simplifications to apply. To fix\nthis,\nadd a special case to the AArch64 code if we are loading from two memory\naddresses, and use the load_pair_lanes patterns directly.\n\nWe also need a new pattern in simplify-rtx.c:simplify_ternary_operation\nto catch:\n\n  (vec_merge:OUTER\n     (vec_duplicate:OUTER x:INNER)\n     (subreg:OUTER y:INNER 0)\n     (const_int N))\n\nAnd simplify it to:\n\n  (vec_concat:OUTER x:INNER y:INNER) or (vec_concat y x)\n\nThis is similar to the existing patterns which are tested in this\nfunction, without requiring the second operand to also be a vec_duplicate. \n\n\t* config/aarch64/aarch64.c (aarch64_expand_vector_init): Modify\n\tcode generation for cases where splatting a value is not useful.\n\t* simplify-rtx.c (simplify_ternary_operation): Simplify\n\tvec_merge across a vec_duplicate and a paradoxical subreg forming a vector\n\tmode to a vec_concat.\n\n\t* gcc.target/aarch64/vect-slp-dup.c: New.\n\n\nCo-Authored-By: Kyrylo Tkachov <kyrylo.tkachov@arm.com>\n\nFrom-SVN: r260309", "tree": {"sha": "ca2f8a4b6cb074541d291d4278a624dc6bebad49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca2f8a4b6cb074541d291d4278a624dc6bebad49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4e2cd5b9a995e9154b1169e83a0347d257a938c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4e2cd5b9a995e9154b1169e83a0347d257a938c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4e2cd5b9a995e9154b1169e83a0347d257a938c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4e2cd5b9a995e9154b1169e83a0347d257a938c/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9b4ef22db8686405929f0ae039683c535fd79c22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b4ef22db8686405929f0ae039683c535fd79c22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b4ef22db8686405929f0ae039683c535fd79c22"}], "stats": {"total": 139, "additions": 136, "deletions": 3}, "files": [{"sha": "1a245f78fa40951ea3798a22ff4a2cd244823954", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e2cd5b9a995e9154b1169e83a0347d257a938c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e2cd5b9a995e9154b1169e83a0347d257a938c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4e2cd5b9a995e9154b1169e83a0347d257a938c", "patch": "@@ -1,3 +1,13 @@\n+2018-05-17  James Greenhalgh  <james.greenhalgh@arm.com>\n+            Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_expand_vector_init): Modify\n+\tcode generation for cases where splatting a value is not useful.\n+\t* simplify-rtx.c (simplify_ternary_operation): Simplify\n+\tvec_merge across a vec_duplicate and a paradoxical subreg forming a vector\n+\tmode to a vec_concat.\n+\n+\n 2018-05-17  Olga Makhotina  <olga.makhotina@intel.com>\n \n \t* config.gcc: Support \"goldmont-plus\"."}, {"sha": "6bf6c05535b61eef1021d46bcd8448fb3a0b25f4", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 48, "deletions": 3, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e2cd5b9a995e9154b1169e83a0347d257a938c/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e2cd5b9a995e9154b1169e83a0347d257a938c/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=b4e2cd5b9a995e9154b1169e83a0347d257a938c", "patch": "@@ -13916,9 +13916,54 @@ aarch64_expand_vector_init (rtx target, rtx vals)\n \t    maxv = matches[i][1];\n \t  }\n \n-      /* Create a duplicate of the most common element.  */\n-      rtx x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, maxelement));\n-      aarch64_emit_move (target, gen_vec_duplicate (mode, x));\n+      /* Create a duplicate of the most common element, unless all elements\n+\t are equally useless to us, in which case just immediately set the\n+\t vector register using the first element.  */\n+\n+      if (maxv == 1)\n+\t{\n+\t  /* For vectors of two 64-bit elements, we can do even better.  */\n+\t  if (n_elts == 2\n+\t      && (inner_mode == E_DImode\n+\t\t  || inner_mode == E_DFmode))\n+\n+\t    {\n+\t      rtx x0 = XVECEXP (vals, 0, 0);\n+\t      rtx x1 = XVECEXP (vals, 0, 1);\n+\t      /* Combine can pick up this case, but handling it directly\n+\t\t here leaves clearer RTL.\n+\n+\t\t This is load_pair_lanes<mode>, and also gives us a clean-up\n+\t\t for store_pair_lanes<mode>.  */\n+\t      if (memory_operand (x0, inner_mode)\n+\t\t  && memory_operand (x1, inner_mode)\n+\t\t  && !STRICT_ALIGNMENT\n+\t\t  && rtx_equal_p (XEXP (x1, 0),\n+\t\t\t\t  plus_constant (Pmode,\n+\t\t\t\t\t\t XEXP (x0, 0),\n+\t\t\t\t\t\t GET_MODE_SIZE (inner_mode))))\n+\t\t{\n+\t\t  rtx t;\n+\t\t  if (inner_mode == DFmode)\n+\t\t    t = gen_load_pair_lanesdf (target, x0, x1);\n+\t\t  else\n+\t\t    t = gen_load_pair_lanesdi (target, x0, x1);\n+\t\t  emit_insn (t);\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t  /* The subreg-move sequence below will move into lane zero of the\n+\t     vector register.  For big-endian we want that position to hold\n+\t     the last element of VALS.  */\n+\t  maxelement = BYTES_BIG_ENDIAN ? n_elts - 1 : 0;\n+\t  rtx x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, maxelement));\n+\t  aarch64_emit_move (target, lowpart_subreg (mode, x, inner_mode));\n+\t}\n+      else\n+\t{\n+\t  rtx x = copy_to_mode_reg (inner_mode, XVECEXP (vals, 0, maxelement));\n+\t  aarch64_emit_move (target, gen_vec_duplicate (mode, x));\n+\t}\n \n       /* Insert the rest.  */\n       for (int i = 0; i < n_elts; i++)"}, {"sha": "d2714db7ae8ef946a6ce035bea59ddbec890e905", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e2cd5b9a995e9154b1169e83a0347d257a938c/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e2cd5b9a995e9154b1169e83a0347d257a938c/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=b4e2cd5b9a995e9154b1169e83a0347d257a938c", "patch": "@@ -5891,6 +5891,60 @@ simplify_ternary_operation (enum rtx_code code, machine_mode mode,\n \t\treturn simplify_gen_binary (VEC_CONCAT, mode, newop0, newop1);\n \t    }\n \n+\t  /* Replace:\n+\n+\t      (vec_merge:outer (vec_duplicate:outer x:inner)\n+\t\t\t       (subreg:outer y:inner 0)\n+\t\t\t       (const_int N))\n+\n+\t     with (vec_concat:outer x:inner y:inner) if N == 1,\n+\t     or (vec_concat:outer y:inner x:inner) if N == 2.\n+\n+\t     Implicitly, this means we have a paradoxical subreg, but such\n+\t     a check is cheap, so make it anyway.\n+\n+\t     Only applies for vectors of two elements.  */\n+\t  if (GET_CODE (op0) == VEC_DUPLICATE\n+\t      && GET_CODE (op1) == SUBREG\n+\t      && GET_MODE (op1) == GET_MODE (op0)\n+\t      && GET_MODE (SUBREG_REG (op1)) == GET_MODE (XEXP (op0, 0))\n+\t      && paradoxical_subreg_p (op1)\n+\t      && subreg_lowpart_p (op1)\n+\t      && known_eq (GET_MODE_NUNITS (GET_MODE (op0)), 2)\n+\t      && known_eq (GET_MODE_NUNITS (GET_MODE (op1)), 2)\n+\t      && IN_RANGE (sel, 1, 2))\n+\t    {\n+\t      rtx newop0 = XEXP (op0, 0);\n+\t      rtx newop1 = SUBREG_REG (op1);\n+\t      if (sel == 2)\n+\t\tstd::swap (newop0, newop1);\n+\t      return simplify_gen_binary (VEC_CONCAT, mode, newop0, newop1);\n+\t    }\n+\n+\t  /* Same as above but with switched operands:\n+\t\tReplace (vec_merge:outer (subreg:outer x:inner 0)\n+\t\t\t\t\t (vec_duplicate:outer y:inner)\n+\t\t\t       (const_int N))\n+\n+\t     with (vec_concat:outer x:inner y:inner) if N == 1,\n+\t     or (vec_concat:outer y:inner x:inner) if N == 2.  */\n+\t  if (GET_CODE (op1) == VEC_DUPLICATE\n+\t      && GET_CODE (op0) == SUBREG\n+\t      && GET_MODE (op0) == GET_MODE (op1)\n+\t      && GET_MODE (SUBREG_REG (op0)) == GET_MODE (XEXP (op1, 0))\n+\t      && paradoxical_subreg_p (op0)\n+\t      && subreg_lowpart_p (op0)\n+\t      && known_eq (GET_MODE_NUNITS (GET_MODE (op1)), 2)\n+\t      && known_eq (GET_MODE_NUNITS (GET_MODE (op0)), 2)\n+\t      && IN_RANGE (sel, 1, 2))\n+\t    {\n+\t      rtx newop0 = SUBREG_REG (op0);\n+\t      rtx newop1 = XEXP (op1, 0);\n+\t      if (sel == 2)\n+\t\tstd::swap (newop0, newop1);\n+\t      return simplify_gen_binary (VEC_CONCAT, mode, newop0, newop1);\n+\t    }\n+\n \t  /* Replace (vec_merge (vec_duplicate x) (vec_duplicate y)\n \t\t\t\t (const_int n))\n \t     with (vec_concat x y) or (vec_concat y x) depending on value"}, {"sha": "fe495f8be7e3024f9b264168baa107c95ec5fb73", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e2cd5b9a995e9154b1169e83a0347d257a938c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e2cd5b9a995e9154b1169e83a0347d257a938c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b4e2cd5b9a995e9154b1169e83a0347d257a938c", "patch": "@@ -1,3 +1,7 @@\n+2018-05-17  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* gcc.target/aarch64/vect-slp-dup.c: New.\n+\n 2018-05-17  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/85713"}, {"sha": "0541e480d1f8561dbd9b2a56926c8df60d667a54", "filename": "gcc/testsuite/gcc.target/aarch64/vect-slp-dup.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e2cd5b9a995e9154b1169e83a0347d257a938c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect-slp-dup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e2cd5b9a995e9154b1169e83a0347d257a938c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect-slp-dup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvect-slp-dup.c?ref=b4e2cd5b9a995e9154b1169e83a0347d257a938c", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+\n+/* { dg-options \"-O3 -ftree-vectorize -fno-vect-cost-model\" } */\n+\n+void bar (double);\n+\n+void\n+foo (double *restrict in, double *restrict in2,\n+     double *restrict out1, double *restrict out2)\n+{\n+  for (int i = 0; i < 1024; i++)\n+    {\n+      out1[i] = in[i] + 2.0 * in[i+128];\n+      out1[i+1] = in[i+1] + 2.0 * in2[i];\n+      bar (in[i]);\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-not \"dup\\tv\\[0-9\\]+.2d, v\\[0-9\\]+\" } } */\n+"}]}