{"sha": "325f5379f113d8ee0a709dc51394ba959245b2a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI1ZjUzNzlmMTEzZDhlZTBhNzA5ZGM1MTM5NGJhOTU5MjQ1YjJhNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-03-16T08:36:42Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-03-16T08:36:42Z"}, "message": "calls.c (emit_call_1): Set MEM_EXPR on call's MEM.\n\n\t* calls.c (emit_call_1): Set MEM_EXPR on call's MEM.\n\t* var-tracking.c (prepare_call_arguments): Use MEM_EXPR on\n\tcall's MEM.  Handle functions returning aggregate through a hidden\n\tfirst pointer.  For virtual calls add clobbered pc to call arguments\n\tchain.\n\t* dwarf2out.c (gen_subprogram_die): Emit\n\tDW_AT_GNU_call_site_target_clobbered if DW_AT_GNU_call_site_target\n\tcan't be emitted.\n\nFrom-SVN: r171036", "tree": {"sha": "571bb55553f825fe13eceac8ef3b5424ac7c7d27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/571bb55553f825fe13eceac8ef3b5424ac7c7d27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/325f5379f113d8ee0a709dc51394ba959245b2a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/325f5379f113d8ee0a709dc51394ba959245b2a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/325f5379f113d8ee0a709dc51394ba959245b2a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/325f5379f113d8ee0a709dc51394ba959245b2a6/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a58a8e4b1f724fdb5edfd09660963404439428f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a58a8e4b1f724fdb5edfd09660963404439428f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a58a8e4b1f724fdb5edfd09660963404439428f7"}], "stats": {"total": 200, "additions": 159, "deletions": 41}, "files": [{"sha": "e3934df4e22c8b0f552254e2bda0425461fa5ac4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325f5379f113d8ee0a709dc51394ba959245b2a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325f5379f113d8ee0a709dc51394ba959245b2a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=325f5379f113d8ee0a709dc51394ba959245b2a6", "patch": "@@ -1,5 +1,14 @@\n 2011-03-16  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* calls.c (emit_call_1): Set MEM_EXPR on call's MEM.\n+\t* var-tracking.c (prepare_call_arguments): Use MEM_EXPR on\n+\tcall's MEM.  Handle functions returning aggregate through a hidden\n+\tfirst pointer.  For virtual calls add clobbered pc to call arguments\n+\tchain.\n+\t* dwarf2out.c (gen_subprogram_die): Emit\n+\tDW_AT_GNU_call_site_target_clobbered if DW_AT_GNU_call_site_target\n+\tcan't be emitted.\n+\n \tPR debug/45882\n \t* rtl.def (ENTRY_VALUE): Change format from \"e\" to \"0\".\n \t* rtl.h (ENTRY_VALUE_EXP): Define."}, {"sha": "fe99bc065e354bc463ad10081d698a1470b83b79", "filename": "gcc/calls.c", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325f5379f113d8ee0a709dc51394ba959245b2a6/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325f5379f113d8ee0a709dc51394ba959245b2a6/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=325f5379f113d8ee0a709dc51394ba959245b2a6", "patch": "@@ -256,7 +256,7 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n \t     CUMULATIVE_ARGS *args_so_far ATTRIBUTE_UNUSED)\n {\n   rtx rounded_stack_size_rtx = GEN_INT (rounded_stack_size);\n-  rtx call_insn;\n+  rtx call_insn, call, funmem;\n   int already_popped = 0;\n   HOST_WIDE_INT n_popped\n     = targetm.calls.return_pops_args (fndecl, funtype, stack_size);\n@@ -271,6 +271,12 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n   if (GET_CODE (funexp) != SYMBOL_REF)\n     funexp = memory_address (FUNCTION_MODE, funexp);\n \n+  funmem = gen_rtx_MEM (FUNCTION_MODE, funexp);\n+  if (fndecl && TREE_CODE (fndecl) == FUNCTION_DECL)\n+    set_mem_expr (funmem, fndecl);\n+  else if (fntree)\n+    set_mem_expr (funmem, build_fold_indirect_ref (CALL_EXPR_FN (fntree)));\n+\n #if defined (HAVE_sibcall_pop) && defined (HAVE_sibcall_value_pop)\n   if ((ecf_flags & ECF_SIBCALL)\n       && HAVE_sibcall_pop && HAVE_sibcall_value_pop\n@@ -283,13 +289,11 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n \t if possible, for the sake of frame pointer elimination.  */\n \n       if (valreg)\n-\tpat = GEN_SIBCALL_VALUE_POP (valreg,\n-\t\t\t\t     gen_rtx_MEM (FUNCTION_MODE, funexp),\n-\t\t\t\t     rounded_stack_size_rtx, next_arg_reg,\n-\t\t\t\t     n_pop);\n+\tpat = GEN_SIBCALL_VALUE_POP (valreg, funmem, rounded_stack_size_rtx,\n+\t\t\t\t     next_arg_reg, n_pop);\n       else\n-\tpat = GEN_SIBCALL_POP (gen_rtx_MEM (FUNCTION_MODE, funexp),\n-\t\t\t       rounded_stack_size_rtx, next_arg_reg, n_pop);\n+\tpat = GEN_SIBCALL_POP (funmem, rounded_stack_size_rtx, next_arg_reg,\n+\t\t\t       n_pop);\n \n       emit_call_insn (pat);\n       already_popped = 1;\n@@ -316,12 +320,11 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n \t if possible, for the sake of frame pointer elimination.  */\n \n       if (valreg)\n-\tpat = GEN_CALL_VALUE_POP (valreg,\n-\t\t\t\t  gen_rtx_MEM (FUNCTION_MODE, funexp),\n-\t\t\t\t  rounded_stack_size_rtx, next_arg_reg, n_pop);\n+\tpat = GEN_CALL_VALUE_POP (valreg, funmem, rounded_stack_size_rtx,\n+\t\t\t\t  next_arg_reg, n_pop);\n       else\n-\tpat = GEN_CALL_POP (gen_rtx_MEM (FUNCTION_MODE, funexp),\n-\t\t\t    rounded_stack_size_rtx, next_arg_reg, n_pop);\n+\tpat = GEN_CALL_POP (funmem, rounded_stack_size_rtx, next_arg_reg,\n+\t\t\t    n_pop);\n \n       emit_call_insn (pat);\n       already_popped = 1;\n@@ -334,13 +337,12 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n       && HAVE_sibcall && HAVE_sibcall_value)\n     {\n       if (valreg)\n-\temit_call_insn (GEN_SIBCALL_VALUE (valreg,\n-\t\t\t\t\t   gen_rtx_MEM (FUNCTION_MODE, funexp),\n+\temit_call_insn (GEN_SIBCALL_VALUE (valreg, funmem,\n \t\t\t\t\t   rounded_stack_size_rtx,\n \t\t\t\t\t   next_arg_reg, NULL_RTX));\n       else\n-\temit_call_insn (GEN_SIBCALL (gen_rtx_MEM (FUNCTION_MODE, funexp),\n-\t\t\t\t     rounded_stack_size_rtx, next_arg_reg,\n+\temit_call_insn (GEN_SIBCALL (funmem, rounded_stack_size_rtx,\n+\t\t\t\t     next_arg_reg,\n \t\t\t\t     GEN_INT (struct_value_size)));\n     }\n   else\n@@ -350,13 +352,10 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n   if (HAVE_call && HAVE_call_value)\n     {\n       if (valreg)\n-\temit_call_insn (GEN_CALL_VALUE (valreg,\n-\t\t\t\t\tgen_rtx_MEM (FUNCTION_MODE, funexp),\n-\t\t\t\t\trounded_stack_size_rtx, next_arg_reg,\n-\t\t\t\t\tNULL_RTX));\n+\temit_call_insn (GEN_CALL_VALUE (valreg, funmem, rounded_stack_size_rtx,\n+\t\t\t\t\tnext_arg_reg, NULL_RTX));\n       else\n-\temit_call_insn (GEN_CALL (gen_rtx_MEM (FUNCTION_MODE, funexp),\n-\t\t\t\t  rounded_stack_size_rtx, next_arg_reg,\n+\temit_call_insn (GEN_CALL (funmem, rounded_stack_size_rtx, next_arg_reg,\n \t\t\t\t  GEN_INT (struct_value_size)));\n     }\n   else\n@@ -366,6 +365,19 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n   /* Find the call we just emitted.  */\n   call_insn = last_call_insn ();\n \n+  /* Some target create a fresh MEM instead of reusing the one provided\n+     above.  Set its MEM_EXPR.  */\n+  call = PATTERN (call_insn);\n+  if (GET_CODE (call) == PARALLEL)\n+    call = XVECEXP (call, 0, 0);\n+  if (GET_CODE (call) == SET)\n+    call = SET_SRC (call);\n+  if (GET_CODE (call) == CALL\n+      && MEM_P (XEXP (call, 0))\n+      && MEM_EXPR (XEXP (call, 0)) == NULL_TREE\n+      && MEM_EXPR (funmem) != NULL_TREE)\n+    set_mem_expr (XEXP (call, 0), MEM_EXPR (funmem));\n+\n   /* Put the register usage information there.  */\n   add_function_usage_to (call_insn, call_fusage);\n "}, {"sha": "38b1422d40f403cba37f921b7df5802b1a51dad0", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325f5379f113d8ee0a709dc51394ba959245b2a6/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325f5379f113d8ee0a709dc51394ba959245b2a6/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=325f5379f113d8ee0a709dc51394ba959245b2a6", "patch": "@@ -19615,7 +19615,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t  for (ca_loc = call_arg_locations; ca_loc; ca_loc = ca_loc->next)\n \t    {\n \t      dw_die_ref die = NULL;\n-\t      rtx tloc = NULL_RTX;\n+\t      rtx tloc = NULL_RTX, tlocc = NULL_RTX;\n \t      rtx arg, next_arg;\n \n \t      for (arg = NOTE_VAR_LOCATION (ca_loc->call_arg_loc_note);\n@@ -19644,6 +19644,13 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t\t      tloc = XEXP (XEXP (arg, 0), 1);\n \t\t      continue;\n \t\t    }\n+\t\t  else if (GET_CODE (XEXP (XEXP (arg, 0), 0)) == CLOBBER\n+\t\t\t   && XEXP (XEXP (XEXP (arg, 0), 0), 0) == pc_rtx)\n+\t\t    {\n+\t\t      gcc_assert (ca_loc->symbol_ref == NULL_RTX);\n+\t\t      tlocc = XEXP (XEXP (arg, 0), 1);\n+\t\t      continue;\n+\t\t    }\n \t\t  if (REG_P (XEXP (XEXP (arg, 0), 0)))\n \t\t    reg = reg_loc_descriptor (XEXP (XEXP (arg, 0), 0),\n \t\t\t\t\t      VAR_INIT_STATUS_INITIALIZED);\n@@ -19677,13 +19684,23 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t      if (die == NULL\n \t\t  && (ca_loc->symbol_ref || tloc))\n \t\tdie = gen_call_site_die (decl, subr_die, ca_loc);\n-\t      if (die != NULL && tloc != NULL_RTX)\n+\t      if (die != NULL && (tloc != NULL_RTX || tlocc != NULL_RTX))\n \t\t{\n-\t\t  dw_loc_descr_ref tval\n-\t\t    = mem_loc_descriptor (tloc, VOIDmode,\n-\t\t\t\t\t  VAR_INIT_STATUS_INITIALIZED);\n+\t\t  dw_loc_descr_ref tval = NULL;\n+\n+\t\t  if (tloc != NULL_RTX)\n+\t\t    tval = mem_loc_descriptor (tloc, VOIDmode,\n+\t\t\t\t\t       VAR_INIT_STATUS_INITIALIZED);\n \t\t  if (tval)\n \t\t    add_AT_loc (die, DW_AT_GNU_call_site_target, tval);\n+\t\t  else if (tlocc != NULL_RTX)\n+\t\t    {\n+\t\t      tval = mem_loc_descriptor (tlocc, VOIDmode,\n+\t\t\t\t\t\t VAR_INIT_STATUS_INITIALIZED);\n+\t\t      if (tval)\n+\t\t\tadd_AT_loc (die, DW_AT_GNU_call_site_target_clobbered,\n+\t\t\t\t    tval);\n+\t\t    }\n \t\t}\n \t      if (die != NULL)\n \t\t{"}, {"sha": "ee180f13f622d95404705cbc1e73719780af716e", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 94, "deletions": 14, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/325f5379f113d8ee0a709dc51394ba959245b2a6/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/325f5379f113d8ee0a709dc51394ba959245b2a6/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=325f5379f113d8ee0a709dc51394ba959245b2a6", "patch": "@@ -5576,35 +5576,101 @@ prepare_call_arguments (basic_block bb, rtx insn)\n   rtx link, x;\n   rtx prev, cur, next;\n   rtx call = PATTERN (insn);\n-  tree type = NULL_TREE, t;\n+  rtx this_arg = NULL_RTX;\n+  tree type = NULL_TREE, t, fndecl = NULL_TREE;\n+  tree obj_type_ref = NULL_TREE;\n   CUMULATIVE_ARGS args_so_far;\n \n   memset (&args_so_far, 0, sizeof (args_so_far));\n   if (GET_CODE (call) == PARALLEL)\n     call = XVECEXP (call, 0, 0);\n   if (GET_CODE (call) == SET)\n     call = SET_SRC (call);\n-  if (GET_CODE (call) == CALL\n-      && MEM_P (XEXP (call, 0))\n-      && GET_CODE (XEXP (XEXP (call, 0), 0)) == SYMBOL_REF)\n-    {\n-      rtx symbol = XEXP (XEXP (call, 0), 0);\n-      if (SYMBOL_REF_DECL (symbol)\n-\t  && TREE_CODE (SYMBOL_REF_DECL (symbol)) == FUNCTION_DECL\n-\t  && TYPE_ARG_TYPES (TREE_TYPE (SYMBOL_REF_DECL (symbol))))\n+  if (GET_CODE (call) == CALL && MEM_P (XEXP (call, 0)))\n+    {\n+      if (GET_CODE (XEXP (XEXP (call, 0), 0)) == SYMBOL_REF)\n+\t{\n+\t  rtx symbol = XEXP (XEXP (call, 0), 0);\n+\t  if (SYMBOL_REF_DECL (symbol))\n+\t    fndecl = SYMBOL_REF_DECL (symbol);\n+\t}\n+      if (fndecl == NULL_TREE)\n+\tfndecl = MEM_EXPR (XEXP (call, 0));\n+      if (fndecl\n+\t  && TREE_CODE (TREE_TYPE (fndecl)) != FUNCTION_TYPE\n+\t  && TREE_CODE (TREE_TYPE (fndecl)) != METHOD_TYPE)\n+\tfndecl = NULL_TREE;\n+      if (fndecl && TYPE_ARG_TYPES (TREE_TYPE (fndecl)))\n+\ttype = TREE_TYPE (fndecl);\n+      if (fndecl && TREE_CODE (fndecl) != FUNCTION_DECL)\n+\t{\n+\t  if (TREE_CODE (fndecl) == INDIRECT_REF\n+\t      && TREE_CODE (TREE_OPERAND (fndecl, 0)) == OBJ_TYPE_REF)\n+\t    obj_type_ref = TREE_OPERAND (fndecl, 0);\n+\t  fndecl = NULL_TREE;\n+\t}\n+      if (type)\n \t{\n-\t  type = TREE_TYPE (SYMBOL_REF_DECL (symbol));\n \t  for (t = TYPE_ARG_TYPES (type); t && t != void_list_node;\n \t       t = TREE_CHAIN (t))\n \t    if (TREE_CODE (TREE_VALUE (t)) == REFERENCE_TYPE\n \t\t&& INTEGRAL_TYPE_P (TREE_TYPE (TREE_VALUE (t))))\n \t      break;\n-\t  if (t == NULL || t == void_list_node)\n+\t  if ((t == NULL || t == void_list_node) && obj_type_ref == NULL_TREE)\n \t    type = NULL;\n \t  else\n-\t    INIT_CUMULATIVE_ARGS (args_so_far, type, NULL_RTX,\n-\t\t\t\t  SYMBOL_REF_DECL (symbol),\n-\t\t\t\t  list_length (TYPE_ARG_TYPES (type)));\n+\t    {\n+\t      int nargs = list_length (TYPE_ARG_TYPES (type));\n+\t      link = CALL_INSN_FUNCTION_USAGE (insn);\n+#ifndef PCC_STATIC_STRUCT_RETURN\n+\t      if (aggregate_value_p (TREE_TYPE (type), type)\n+\t\t  && targetm.calls.struct_value_rtx (type, 0) == 0)\n+\t\t{\n+\t\t  tree struct_addr = build_pointer_type (TREE_TYPE (type));\n+\t\t  enum machine_mode mode = TYPE_MODE (struct_addr);\n+\t\t  rtx reg;\n+\t\t  INIT_CUMULATIVE_ARGS (args_so_far, type, NULL_RTX, fndecl,\n+\t\t\t\t\tnargs + 1);\n+\t\t  reg = targetm.calls.function_arg (&args_so_far, mode,\n+\t\t\t\t\t\t    struct_addr, true);\n+\t\t  targetm.calls.function_arg_advance (&args_so_far, mode,\n+\t\t\t\t\t\t      struct_addr, true);\n+\t\t  if (reg == NULL_RTX)\n+\t\t    {\n+\t\t      for (; link; link = XEXP (link, 1))\n+\t\t\tif (GET_CODE (XEXP (link, 0)) == USE\n+\t\t\t    && MEM_P (XEXP (XEXP (link, 0), 0)))\n+\t\t\t  {\n+\t\t\t    link = XEXP (link, 1);\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t    }\n+\t\t}\n+#endif\n+\t      else\n+\t\tINIT_CUMULATIVE_ARGS (args_so_far, type, NULL_RTX, fndecl,\n+\t\t\t\t      nargs);\n+\t      if (obj_type_ref && TYPE_ARG_TYPES (type) != void_list_node)\n+\t\t{\n+\t\t  enum machine_mode mode;\n+\t\t  t = TYPE_ARG_TYPES (type);\n+\t\t  mode = TYPE_MODE (TREE_VALUE (t));\n+\t\t  this_arg = targetm.calls.function_arg (&args_so_far, mode,\n+\t\t\t\t\t\t\t TREE_VALUE (t), true);\n+\t\t  if (this_arg && !REG_P (this_arg))\n+\t\t    this_arg = NULL_RTX;\n+\t\t  else if (this_arg == NULL_RTX)\n+\t\t    {\n+\t\t      for (; link; link = XEXP (link, 1))\n+\t\t\tif (GET_CODE (XEXP (link, 0)) == USE\n+\t\t\t    && MEM_P (XEXP (XEXP (link, 0), 0)))\n+\t\t\t  {\n+\t\t\t    this_arg = XEXP (XEXP (link, 0), 0);\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t    }\n+\t\t}\n+\t    }\n \t}\n     }\n   t = type ? TYPE_ARG_TYPES (type) : NULL_TREE;\n@@ -5752,6 +5818,20 @@ prepare_call_arguments (basic_block bb, rtx insn)\n \t    }\n \t}\n     }\n+  if (this_arg)\n+    {\n+      enum machine_mode mode\n+\t= TYPE_MODE (TREE_TYPE (OBJ_TYPE_REF_EXPR (obj_type_ref)));\n+      rtx clobbered = gen_rtx_MEM (mode, this_arg);\n+      HOST_WIDE_INT token\n+\t= tree_low_cst (OBJ_TYPE_REF_TOKEN (obj_type_ref), 0);\n+      if (token)\n+\tclobbered = plus_constant (clobbered, token * GET_MODE_SIZE (mode));\n+      clobbered = gen_rtx_MEM (mode, clobbered);\n+      x = gen_rtx_CONCAT (mode, gen_rtx_CLOBBER (VOIDmode, pc_rtx), clobbered);\n+      call_arguments\n+\t= gen_rtx_EXPR_LIST (VOIDmode, x, call_arguments);\n+    }\n }\n \n /* Callback for cselib_record_sets_hook, that records as micro"}]}