{"sha": "355e99758bceb3ffed95a0c4fc41fb348e0109d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU1ZTk5NzU4YmNlYjNmZmVkOTVhMGM0ZmM0MWZiMzQ4ZTAxMDlkMw==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2014-11-22T15:06:34Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2014-11-22T15:06:34Z"}, "message": "re PR target/63986 ([SH] gcc.target/sh/pr51244-15.c failures)\n\ngcc/\n\tPR target/63986\n\tPR target/51244\n\t* config/sh/sh.c (sh_is_logical_t_store_expr,\n\tsh_try_omit_signzero_extend): Use rtx_insn* for insn argument.\n\t(sh_split_movrt_negc_to_movt_xor): New function.\n\t(sh_find_set_of_reg): Move to ...\n\t* config/sh/sh-protos.h (sh_find_set_of_reg): ... here and convert\n\tto template function.\n\t(set_of_reg): Use rtx_insn* for insn member.\n\t(sh_is_logical_t_store_expr, sh_try_omit_signzero_extend): Use\n\trtx_insn* for insn argument.\n\t* config/sh/sh.md (movrt_negc, *movrt_negc): Split into movt-xor\n\tsequence using new sh_split_movrt_negc_to_movt_xor function.\n\t(movrt_xor): Allow also for SH2A.\n\t(*movt_movrt): Delete insns and splits.\n\nFrom-SVN: r217968", "tree": {"sha": "a124a99e1ec7b525dc213a2adf31d53765f0f129", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a124a99e1ec7b525dc213a2adf31d53765f0f129"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/355e99758bceb3ffed95a0c4fc41fb348e0109d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/355e99758bceb3ffed95a0c4fc41fb348e0109d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/355e99758bceb3ffed95a0c4fc41fb348e0109d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/355e99758bceb3ffed95a0c4fc41fb348e0109d3/comments", "author": null, "committer": null, "parents": [{"sha": "9ce85efc60a2089ee2aa950d5d05bc9ab73e9c58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ce85efc60a2089ee2aa950d5d05bc9ab73e9c58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ce85efc60a2089ee2aa950d5d05bc9ab73e9c58"}], "stats": {"total": 210, "additions": 124, "deletions": 86}, "files": [{"sha": "bbab5022ffd5e4f45641503adf8c13b76a1232fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355e99758bceb3ffed95a0c4fc41fb348e0109d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355e99758bceb3ffed95a0c4fc41fb348e0109d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=355e99758bceb3ffed95a0c4fc41fb348e0109d3", "patch": "@@ -1,3 +1,21 @@\n+2014-11-22  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/63986\n+\tPR target/51244\n+\t* config/sh/sh.c (sh_is_logical_t_store_expr,\n+\tsh_try_omit_signzero_extend): Use rtx_insn* for insn argument.\n+\t(sh_split_movrt_negc_to_movt_xor): New function.\n+\t(sh_find_set_of_reg): Move to ...\n+\t* config/sh/sh-protos.h (sh_find_set_of_reg): ... here and convert\n+\tto template function.\n+\t(set_of_reg): Use rtx_insn* for insn member.\n+\t(sh_is_logical_t_store_expr, sh_try_omit_signzero_extend): Use\n+\trtx_insn* for insn argument.\n+\t* config/sh/sh.md (movrt_negc, *movrt_negc): Split into movt-xor\n+\tsequence using new sh_split_movrt_negc_to_movt_xor function.\n+\t(movrt_xor): Allow also for SH2A.\n+\t(*movt_movrt): Delete insns and splits.\n+\n 2014-11-22  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR tree-optimization/60770"}, {"sha": "262c4fb556add67ceb36079f32b022a7476ff686", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355e99758bceb3ffed95a0c4fc41fb348e0109d3/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355e99758bceb3ffed95a0c4fc41fb348e0109d3/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=355e99758bceb3ffed95a0c4fc41fb348e0109d3", "patch": "@@ -165,7 +165,7 @@ struct set_of_reg\n {\n   /* The insn where sh_find_set_of_reg stopped looking.\n      Can be NULL_RTX if the end of the insn list was reached.  */\n-  rtx insn;\n+  rtx_insn* insn;\n \n   /* The set rtx of the specified reg if found, NULL_RTX otherwise.  */\n   const_rtx set_rtx;\n@@ -175,9 +175,47 @@ struct set_of_reg\n   rtx set_src;\n };\n \n-extern set_of_reg sh_find_set_of_reg (rtx reg, rtx insn, rtx_insn *(*stepfunc)(rtx));\n-extern bool sh_is_logical_t_store_expr (rtx op, rtx insn);\n-extern rtx sh_try_omit_signzero_extend (rtx extended_op, rtx insn);\n+/* Given a reg rtx and a start insn, try to find the insn that sets the\n+   specified reg by using the specified insn stepping function, such as \n+   'prev_nonnote_insn_bb'.  When the insn is found, try to extract the rtx\n+   of the reg set.  */\n+template <typename F> inline set_of_reg\n+sh_find_set_of_reg (rtx reg, rtx_insn* insn, F stepfunc)\n+{\n+  set_of_reg result;\n+  result.insn = insn;\n+  result.set_rtx = NULL_RTX;\n+  result.set_src = NULL_RTX;\n+\n+  if (!REG_P (reg) || insn == NULL_RTX)\n+    return result;\n+\n+  for (result.insn = stepfunc (insn); result.insn != NULL_RTX;\n+       result.insn = stepfunc (result.insn))\n+    {\n+      if (BARRIER_P (result.insn))\n+\treturn result;\n+      if (!NONJUMP_INSN_P (result.insn))\n+\tcontinue;\n+      if (reg_set_p (reg, result.insn))\n+\t{\n+\t  result.set_rtx = set_of (reg, result.insn);\n+\n+\t  if (result.set_rtx == NULL_RTX || GET_CODE (result.set_rtx) != SET)\n+\t    return result;\n+\n+\t  result.set_src = XEXP (result.set_rtx, 1);\n+\t  return result;\n+\t}\n+    }\n+\n+  return result;\n+}\n+\n+extern bool sh_is_logical_t_store_expr (rtx op, rtx_insn* insn);\n+extern rtx sh_try_omit_signzero_extend (rtx extended_op, rtx_insn* insn);\n+extern bool sh_split_movrt_negc_to_movt_xor (rtx_insn* curr_insn,\n+\t\t\t\t\t     rtx operands[]);\n #endif /* RTX_CODE */\n \n extern void sh_cpu_cpp_builtins (cpp_reader* pfile);"}, {"sha": "f578b43976b13bebb5334ec70ec9dae271003c51", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355e99758bceb3ffed95a0c4fc41fb348e0109d3/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355e99758bceb3ffed95a0c4fc41fb348e0109d3/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=355e99758bceb3ffed95a0c4fc41fb348e0109d3", "patch": "@@ -13503,47 +13503,10 @@ sh_find_equiv_gbr_addr (rtx_insn* insn, rtx mem)\n   Manual insn combine support code.\n */\n \n-/* Given a reg rtx and a start insn, try to find the insn that sets the\n-   specified reg by using the specified insn stepping function, such as \n-   'prev_nonnote_insn_bb'.  When the insn is found, try to extract the rtx\n-   of the reg set.  */\n-set_of_reg\n-sh_find_set_of_reg (rtx reg, rtx insn, rtx_insn *(*stepfunc)(rtx))\n-{\n-  set_of_reg result;\n-  result.insn = insn;\n-  result.set_rtx = NULL_RTX;\n-  result.set_src = NULL_RTX;\n-\n-  if (!REG_P (reg) || insn == NULL_RTX)\n-    return result;\n-\n-  for (result.insn = stepfunc (insn); result.insn != NULL_RTX;\n-       result.insn = stepfunc (result.insn))\n-    {\n-      if (BARRIER_P (result.insn))\n-\treturn result;\n-      if (!NONJUMP_INSN_P (result.insn))\n-\tcontinue;\n-      if (reg_set_p (reg, result.insn))\n-\t{\n-\t  result.set_rtx = set_of (reg, result.insn);\n-\n-\t  if (result.set_rtx == NULL_RTX || GET_CODE (result.set_rtx) != SET)\n-\t    return result;\n-\n-\t  result.set_src = XEXP (result.set_rtx, 1);\n-\t  return result;\n-\t}\n-    }\n-\n-  return result;\n-}\n-\n /* Given an op rtx and an insn, try to find out whether the result of the\n    specified op consists only of logical operations on T bit stores.  */\n bool\n-sh_is_logical_t_store_expr (rtx op, rtx insn)\n+sh_is_logical_t_store_expr (rtx op, rtx_insn* insn)\n {\n   if (!logical_operator (op, SImode))\n     return false;\n@@ -13579,7 +13542,7 @@ sh_is_logical_t_store_expr (rtx op, rtx insn)\n    by a simple reg-reg copy.  If so, the replacement reg rtx is returned,\n    NULL_RTX otherwise.  */\n rtx\n-sh_try_omit_signzero_extend (rtx extended_op, rtx insn)\n+sh_try_omit_signzero_extend (rtx extended_op, rtx_insn* insn)\n {\n   if (REG_P (extended_op))\n     extended_op = extended_op;\n@@ -13609,6 +13572,42 @@ sh_try_omit_signzero_extend (rtx extended_op, rtx insn)\n   return NULL_RTX;\n }\n \n+/* Given the current insn, which is assumed to be a movrt_negc insn, try to\n+   figure out whether it should be converted into a movt-xor sequence in\n+   the movrt_negc splitter.\n+   Returns true if insns have been modified and the splitter has succeeded.  */\n+bool\n+sh_split_movrt_negc_to_movt_xor (rtx_insn* curr_insn, rtx operands[])\n+{\n+  /* In cases such as\n+\ttst\tr4,r4\n+\tmov\t#-1,r1\n+\tnegc\tr1,r1\n+\ttst\tr4,r4\n+     we can replace the T bit clobbering negc with a movt-xor sequence and\n+     eliminate the redundant comparison.\n+     Because the xor insn depends on register allocation results, allow this\n+     only before reload.  */\n+  if (!can_create_pseudo_p ())\n+    return false;\n+\n+  set_of_reg t_before_negc = sh_find_set_of_reg (get_t_reg_rtx (), curr_insn,\n+\t\t\t\t\t\t prev_nonnote_insn_bb);\n+  set_of_reg t_after_negc = sh_find_set_of_reg (get_t_reg_rtx (), curr_insn,\n+\t\t\t\t\t\tnext_nonnote_insn_bb);\n+\n+  if (t_before_negc.set_rtx != NULL_RTX && t_after_negc.set_rtx != NULL_RTX\n+      && rtx_equal_p (t_before_negc.set_rtx, t_after_negc.set_rtx)\n+      && !reg_used_between_p (get_t_reg_rtx (), curr_insn, t_after_negc.insn))\n+    {\n+      emit_insn (gen_movrt_xor (operands[0], get_t_reg_rtx ()));\n+      set_insn_deleted (t_after_negc.insn);\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n static void\n sh_emit_mode_set (int entity ATTRIBUTE_UNUSED, int mode,\n \t\t  int prev_mode, HARD_REG_SET regs_live ATTRIBUTE_UNUSED)"}, {"sha": "085a806e9f5a46c431f3a7449b210a688b925c52", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 26, "deletions": 43, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355e99758bceb3ffed95a0c4fc41fb348e0109d3/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355e99758bceb3ffed95a0c4fc41fb348e0109d3/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=355e99758bceb3ffed95a0c4fc41fb348e0109d3", "patch": "@@ -11445,13 +11445,21 @@ label:\n   DONE;\n })\n \n-(define_insn \"movrt_negc\"\n+(define_insn_and_split \"movrt_negc\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n-\t(xor:SI (match_operand:SI 1 \"t_reg_operand\" \"\") (const_int 1)))\n+\t(xor:SI (match_operand:SI 1 \"t_reg_operand\") (const_int 1)))\n    (set (reg:SI T_REG) (const_int 1))\n    (use (match_operand:SI 2 \"arith_reg_operand\" \"r\"))]\n   \"TARGET_SH1\"\n   \"negc\t%2,%0\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  if (sh_split_movrt_negc_to_movt_xor (curr_insn, operands))\n+    DONE;\n+  else\n+    FAIL;\n+}\n   [(set_attr \"type\" \"arith\")])\n \n ;; The -1 constant will not be CSE-ed for the *movrt_negc pattern, but the\n@@ -11460,17 +11468,25 @@ label:\n ;; generating a pseudo reg before reload.\n (define_insn_and_split \"*movrt_negc\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n-\t(xor:SI (match_operand:SI 1 \"t_reg_operand\" \"\") (const_int 1)))\n+\t(xor:SI (match_operand:SI 1 \"t_reg_operand\") (const_int 1)))\n    (clobber (match_scratch:SI 2 \"=r\"))\n    (clobber (reg:SI T_REG))]\n   \"TARGET_SH1 && ! TARGET_SH2A\"\n   \"#\"\n-  \"&& reload_completed\"\n-  [(set (match_dup 2) (const_int -1))\n-   (parallel\n-       [(set (match_dup 0) (xor:SI (match_dup 1) (const_int 1)))\n-\t(set (reg:SI T_REG) (const_int 1))\n-\t(use (match_dup 2))])])\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  if (sh_split_movrt_negc_to_movt_xor (curr_insn, operands))\n+    DONE;\n+  else if (reload_completed)\n+    {\n+      emit_move_insn (operands[2], gen_int_mode (-1, SImode));\n+      emit_insn (gen_movrt_negc (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+  else\n+    FAIL;\n+})\n \n ;; Store the negated T bit in a reg using r0 and xor.  This one doesn't\n ;; clobber the T bit, which is useful when storing the T bit and the\n@@ -11481,45 +11497,12 @@ label:\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=z\")\n \t(xor:SI (match_operand:SI 1 \"t_reg_operand\") (const_int 1)))\n    (use (reg:SI T_REG))]\n-  \"TARGET_SH1 && !TARGET_SH2A\"\n+  \"TARGET_SH1\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0) (reg:SI T_REG))\n    (set (match_dup 0) (xor:SI (match_dup 0) (const_int 1)))])\n \n-;; Store the T bit and the negated T bit in two regs in parallel.  There is\n-;; no real insn to do that, but specifying this pattern will give combine\n-;; some opportunities.\n-(define_insn_and_split \"*movt_movrt\"\n-  [(parallel [(set (match_operand:SI 0 \"arith_reg_dest\")\n-\t\t   (match_operand:SI 1 \"negt_reg_operand\"))\n-\t      (set (match_operand:SI 2 \"arith_reg_dest\")\n-\t\t   (match_operand:SI 3 \"t_reg_operand\"))])]\n-  \"TARGET_SH1\"\n-  \"#\"\n-  \"&& 1\"\n-  [(const_int 0)]\n-{\n-  rtx i = TARGET_SH2A\n-\t  ? gen_movrt (operands[0], get_t_reg_rtx ())\n-\t  : gen_movrt_xor (operands[0], get_t_reg_rtx ());\n-  \n-  emit_insn (i);\n-  emit_insn (gen_movt (operands[2], get_t_reg_rtx ()));\n-  DONE;\n-})\n-\n-(define_insn_and_split \"*movt_movrt\"\n-  [(parallel [(set (match_operand:SI 0 \"arith_reg_dest\")\n-\t\t   (match_operand:SI 1 \"t_reg_operand\"))\n-\t      (set (match_operand:SI 2 \"arith_reg_dest\")\n-\t\t   (match_operand:SI 3 \"negt_reg_operand\"))])]\n-  \"TARGET_SH1\"\n-  \"#\"\n-  \"&& 1\"\n-  [(parallel [(set (match_dup 2) (match_dup 3))\n-\t      (set (match_dup 0) (match_dup 1))])])\n-\n ;; Use negc to store the T bit in a MSB of a reg in the following way:\n ;;\tT = 1: 0x80000000 -> reg\n ;;\tT = 0: 0x7FFFFFFF -> reg"}]}