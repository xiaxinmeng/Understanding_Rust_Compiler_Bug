{"sha": "dbea5bf947c6e39016869dc382636345c1aa02b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJlYTViZjk0N2M2ZTM5MDE2ODY5ZGMzODI2MzYzNDVjMWFhMDJiNw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-06-08T12:28:20Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-06-08T12:28:20Z"}, "message": "Add call_summary::get method and m_initialize_when_cloning.\n\n2018-06-08  Martin Liska  <mliska@suse.cz>\n\n\t* symbol-summary.h (get): New function.\n\t(call_summary::m_initialize_when_cloning): New class member.\n\nFrom-SVN: r261316", "tree": {"sha": "a967737f98af04ccdd889fd6114a0fe087a7501b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a967737f98af04ccdd889fd6114a0fe087a7501b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbea5bf947c6e39016869dc382636345c1aa02b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbea5bf947c6e39016869dc382636345c1aa02b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbea5bf947c6e39016869dc382636345c1aa02b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbea5bf947c6e39016869dc382636345c1aa02b7/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "746447567a82ce2987f579770fd296ace60f87b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/746447567a82ce2987f579770fd296ace60f87b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/746447567a82ce2987f579770fd296ace60f87b1"}], "stats": {"total": 71, "additions": 55, "deletions": 16}, "files": [{"sha": "70c9a1115d5437b26796f19cd9bbf484b809b1fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbea5bf947c6e39016869dc382636345c1aa02b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbea5bf947c6e39016869dc382636345c1aa02b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dbea5bf947c6e39016869dc382636345c1aa02b7", "patch": "@@ -1,3 +1,8 @@\n+2018-06-08  Martin Liska  <mliska@suse.cz>\n+\n+\t* symbol-summary.h (get): New function.\n+\t(call_summary::m_initialize_when_cloning): New class member.\n+\n 2018-06-08  Martin Liska  <mliska@suse.cz>\n \n \t* cgraph.c (cgraph_node::remove): Do not recycle uid."}, {"sha": "4896c97a1cd4e9092943ce7e620556e394c25880", "filename": "gcc/symbol-summary.h", "status": "modified", "additions": 50, "deletions": 16, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbea5bf947c6e39016869dc382636345c1aa02b7/gcc%2Fsymbol-summary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbea5bf947c6e39016869dc382636345c1aa02b7/gcc%2Fsymbol-summary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymbol-summary.h?ref=dbea5bf947c6e39016869dc382636345c1aa02b7", "patch": "@@ -326,7 +326,8 @@ class GTY((user)) call_summary <T *>\n public:\n   /* Default construction takes SYMTAB as an argument.  */\n   call_summary (symbol_table *symtab, bool ggc = false): m_ggc (ggc),\n-    m_map (13, ggc), m_released (false), m_symtab (symtab)\n+    m_initialize_when_cloning (false), m_map (13, ggc), m_released (false),\n+    m_symtab (symtab)\n   {\n     m_symtab_removal_hook =\n       symtab->add_edge_removal_hook\n@@ -374,7 +375,13 @@ class GTY((user)) call_summary <T *>\n      If a summary for an edge does not exist, it will be created.  */\n   T* get_create (cgraph_edge *edge)\n   {\n-    return get_create (hashable_uid (edge));\n+    return get (hashable_uid (edge), true);\n+  }\n+\n+  /* Getter for summary callgraph edge pointer.  */\n+  T* get (cgraph_edge *edge)\n+  {\n+    return get (hashable_uid (edge), false);\n   }\n \n   /* Return number of elements handled by data structure.  */\n@@ -400,19 +407,14 @@ class GTY((user)) call_summary <T *>\n   /* Indication if we use ggc summary.  */\n   bool m_ggc;\n \n+  /* Initialize summary for an edge that is cloned.  */\n+  bool m_initialize_when_cloning;\n+\n private:\n   typedef int_hash <int, 0, -1> map_hash;\n \n   /* Getter for summary callgraph ID.  */\n-  T* get_create (int uid)\n-  {\n-    bool existed;\n-    T **v = &m_map.get_or_insert (uid, &existed);\n-    if (!existed)\n-      *v = allocate_new ();\n-\n-    return *v;\n-  }\n+  T *get (int uid, bool lazy_insert);\n \n   /* Get a hashable uid of EDGE.  */\n   int hashable_uid (cgraph_edge *edge)\n@@ -438,6 +440,28 @@ class GTY((user)) call_summary <T *>\n       gt_pointer_operator, void *);\n };\n \n+template <typename T>\n+T*\n+call_summary<T *>::get (int uid, bool lazy_insert)\n+{\n+  gcc_checking_assert (uid > 0);\n+\n+  if (lazy_insert)\n+    {\n+      bool existed;\n+      T **v = &m_map.get_or_insert (uid, &existed);\n+      if (!existed)\n+\t*v = allocate_new ();\n+\n+      return *v;\n+    }\n+  else\n+    {\n+      T **v = m_map.get (uid);\n+      return v == NULL ? NULL : *v;\n+    }\n+}\n+\n template <typename T>\n void\n call_summary<T *>::release ()\n@@ -492,15 +516,25 @@ call_summary<T *>::symtab_duplication (cgraph_edge *edge1,\n \t\t\t\t       cgraph_edge *edge2, void *data)\n {\n   call_summary *summary = (call_summary <T *> *) (data);\n-  T **v = summary->m_map.get (summary->hashable_uid (edge1));\n+  T *edge1_summary = NULL;\n \n-  if (v)\n+  if (summary->m_initialize_when_cloning)\n+    edge1_summary = summary->get_create (edge1);\n+  else\n+    {\n+      T **v = summary->m_map.get (summary->hashable_uid (edge1));\n+      if (v)\n+\t{\n+\t  /* This load is necessary, because we insert a new value!  */\n+\t  edge1_summary = *v;\n+\t}\n+    }\n+\n+  if (edge1_summary)\n     {\n-      /* This load is necessary, because we insert a new value!  */\n-      T *data = *v;\n       T *duplicate = summary->allocate_new ();\n       summary->m_map.put (summary->hashable_uid (edge2), duplicate);\n-      summary->duplicate (edge1, edge2, data, duplicate);\n+      summary->duplicate (edge1, edge2, edge1_summary, duplicate);\n     }\n }\n "}]}