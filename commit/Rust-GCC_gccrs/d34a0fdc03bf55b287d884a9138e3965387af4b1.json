{"sha": "d34a0fdc03bf55b287d884a9138e3965387af4b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM0YTBmZGMwM2JmNTViMjg3ZDg4NGE5MTM4ZTM5NjUzODdhZjRiMQ==", "commit": {"author": {"name": "Claudiu Zissulescu", "email": "claziss@synopsys.com", "date": "2016-01-25T11:15:58Z"}, "committer": {"name": "Claudiu Zissulescu", "email": "claziss@gcc.gnu.org", "date": "2016-01-25T11:15:58Z"}, "message": "[ARC] Add basic support for double load and store instructions\n\ngcc/\n2016-01-25  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* config/arc/arc.c (TARGET_DWARF_REGISTER_SPAN): Define.\n\t(arc_init): Check validity mll64 option.\n\t(arc_save_restore): Use double load/store instruction.\n\t(arc_expand_movmem): Likewise.\n\t(arc_split_move): Don't split if we have double load/store\n\tinstructions. Returns a boolean.\n\t(arc_process_double_reg_moves): Change function to return boolean\n\tinstead of a sequence of instructions.\n\t(arc_dwarf_register_span): New function.\n\t* config/arc/arc-protos.h (arc_split_move): Change prototype.\n\t* config/arc/arc.h (TARGET_CPU_CPP_BUILTINS): Define __ARC_LL64__.\n\t* config/arc/arc.md (*movdi_insn): Emit ldd/std instructions.\n\t(*movdf_insn): Likewise.\n\t* config/arc/arc.opt (mll64): New option.\n\t* config/arc/predicates.md (even_register_operand): New predicate.\n\t* doc/invoke.texi (ARC Options): Add mll64 documentation.\n\nFrom-SVN: r232788", "tree": {"sha": "a518e7e353c9e58626c676f4a558352d9ee4df96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a518e7e353c9e58626c676f4a558352d9ee4df96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d34a0fdc03bf55b287d884a9138e3965387af4b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d34a0fdc03bf55b287d884a9138e3965387af4b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d34a0fdc03bf55b287d884a9138e3965387af4b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d34a0fdc03bf55b287d884a9138e3965387af4b1/comments", "author": {"login": "claziss", "id": 2761368, "node_id": "MDQ6VXNlcjI3NjEzNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/claziss", "html_url": "https://github.com/claziss", "followers_url": "https://api.github.com/users/claziss/followers", "following_url": "https://api.github.com/users/claziss/following{/other_user}", "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}", "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/claziss/subscriptions", "organizations_url": "https://api.github.com/users/claziss/orgs", "repos_url": "https://api.github.com/users/claziss/repos", "events_url": "https://api.github.com/users/claziss/events{/privacy}", "received_events_url": "https://api.github.com/users/claziss/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "02ef53f28854628ee15784bf860e7db24427a18f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02ef53f28854628ee15784bf860e7db24427a18f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02ef53f28854628ee15784bf860e7db24427a18f"}], "stats": {"total": 277, "additions": 191, "deletions": 86}, "files": [{"sha": "03ac502b3afd308c3a42ebe1355073e0bacd7f7e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d34a0fdc03bf55b287d884a9138e3965387af4b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d34a0fdc03bf55b287d884a9138e3965387af4b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d34a0fdc03bf55b287d884a9138e3965387af4b1", "patch": "@@ -1,3 +1,22 @@\n+2016-01-25  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* config/arc/arc.c (TARGET_DWARF_REGISTER_SPAN): Define.\n+\t(arc_init): Check validity mll64 option.\n+\t(arc_save_restore): Use double load/store instruction.\n+\t(arc_expand_movmem): Likewise.\n+\t(arc_split_move): Don't split if we have double load/store\n+\tinstructions. Returns a boolean.\n+\t(arc_process_double_reg_moves): Change function to return boolean\n+\tinstead of a sequence of instructions.\n+\t(arc_dwarf_register_span): New function.\n+\t* config/arc/arc-protos.h (arc_split_move): Change prototype.\n+\t* config/arc/arc.h (TARGET_CPU_CPP_BUILTINS): Define __ARC_LL64__.\n+\t* config/arc/arc.md (*movdi_insn): Emit ldd/std instructions.\n+\t(*movdf_insn): Likewise.\n+\t* config/arc/arc.opt (mll64): New option.\n+\t* config/arc/predicates.md (even_register_operand): New predicate.\n+\t* doc/invoke.texi (ARC Options): Add mll64 documentation.\n+\n 2016-01-25  Richard Biener  <rguenther@suse.de>\n \n \tPR lto/69393"}, {"sha": "f487291d35d7e509cd57b4a83d850c78e71099da", "filename": "gcc/config/arc/arc-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d34a0fdc03bf55b287d884a9138e3965387af4b1/gcc%2Fconfig%2Farc%2Farc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d34a0fdc03bf55b287d884a9138e3965387af4b1/gcc%2Fconfig%2Farc%2Farc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-protos.h?ref=d34a0fdc03bf55b287d884a9138e3965387af4b1", "patch": "@@ -104,7 +104,7 @@ extern void arc_toggle_unalign (void);\n extern void split_addsi (rtx *);\n extern void split_subsi (rtx *);\n extern void arc_pad_return (void);\n-extern rtx arc_split_move (rtx *);\n+extern void arc_split_move (rtx *);\n extern int arc_verify_short (rtx_insn *insn, int unalign, int);\n extern const char *arc_short_long (rtx_insn *insn, const char *, const char *);\n extern rtx arc_regno_use_in (unsigned int, rtx);"}, {"sha": "b9799a016cbedcbbd73ae3065bdd78f2053c1446", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 87, "deletions": 33, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d34a0fdc03bf55b287d884a9138e3965387af4b1/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d34a0fdc03bf55b287d884a9138e3965387af4b1/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=d34a0fdc03bf55b287d884a9138e3965387af4b1", "patch": "@@ -420,6 +420,9 @@ static void arc_finalize_pic (void);\n #undef TARGET_ASM_ALIGNED_SI_OP\n #define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n \n+#undef TARGET_DWARF_REGISTER_SPAN\n+#define TARGET_DWARF_REGISTER_SPAN arc_dwarf_register_span\n+\n /* Try to keep the (mov:DF _, reg) as early as possible so\n    that the d<add/sub/mul>h-lr insns appear together and can\n    use the peephole2 pattern.  */\n@@ -736,6 +739,10 @@ arc_init (void)\n   if (TARGET_ATOMIC && !(TARGET_ARC700 || TARGET_HS))\n     error (\"-matomic is only supported for ARC700 or ARC HS cores\");\n \n+  /* ll64 ops only available for HS.  */\n+  if (TARGET_LL64 && !TARGET_HS)\n+    error (\"-mll64 is only supported for ARC HS cores\");\n+\n   arc_init_reg_tables ();\n \n   /* Initialize array for PRINT_OPERAND_PUNCT_VALID_P.  */\n@@ -2175,9 +2182,26 @@ arc_save_restore (rtx base_reg,\n \n       for (regno = 0; regno <= 31; regno++)\n \t{\n-\t  if ((gmask & (1L << regno)) != 0)\n+\t  enum machine_mode mode = SImode;\n+\t  bool found = false;\n+\n+\t  if (TARGET_LL64\n+\t      && (regno % 2 == 0)\n+\t      && ((gmask & (1L << regno)) != 0)\n+\t      && ((gmask & (1L << (regno+1))) != 0))\n+\t    {\n+\t      found = true;\n+\t      mode  = DImode;\n+\t    }\n+\t  else if ((gmask & (1L << regno)) != 0)\n \t    {\n-\t      rtx reg = gen_rtx_REG (SImode, regno);\n+\t      found = true;\n+\t      mode  = SImode;\n+\t    }\n+\n+\t  if (found)\n+\t    {\n+\t      rtx reg = gen_rtx_REG (mode, regno);\n \t      rtx addr, mem;\n \t      int cfa_adjust = *first_offset;\n \n@@ -2193,7 +2217,7 @@ arc_save_restore (rtx base_reg,\n \t\t  gcc_assert (SMALL_INT (offset));\n \t\t  addr = plus_constant (Pmode, base_reg, offset);\n \t\t}\n-\t      mem = gen_frame_mem (SImode, addr);\n+\t      mem = gen_frame_mem (mode, addr);\n \t      if (epilogue_p)\n \t\t{\n \t\t  rtx insn =\n@@ -2212,6 +2236,11 @@ arc_save_restore (rtx base_reg,\n \t      else\n \t\tframe_move_inc (mem, reg, base_reg, addr);\n \t      offset += UNITS_PER_WORD;\n+\t      if (mode == DImode)\n+\t\t{\n+\t\t  offset += UNITS_PER_WORD;\n+\t\t  ++regno;\n+\t\t}\n \t    } /* if */\n \t} /* for */\n     }/* if */\n@@ -6986,9 +7015,8 @@ force_offsettable (rtx addr, HOST_WIDE_INT size, bool reuse)\n   return addr;\n }\n \n-/* Like move_by_pieces, but take account of load latency,\n-   and actual offset ranges.\n-   Return true on success.  */\n+/* Like move_by_pieces, but take account of load latency, and actual\n+   offset ranges.  Return true on success.  */\n \n bool\n arc_expand_movmem (rtx *operands)\n@@ -7009,14 +7037,23 @@ arc_expand_movmem (rtx *operands)\n   size = INTVAL (operands[2]);\n   /* move_by_pieces_ninsns is static, so we can't use it.  */\n   if (align >= 4)\n-    n_pieces = (size + 2) / 4U + (size & 1);\n+    {\n+      if (TARGET_LL64)\n+\tn_pieces = (size + 4) / 8U + ((size >> 1) & 1) + (size & 1);\n+      else\n+\tn_pieces = (size + 2) / 4U + (size & 1);\n+    }\n   else if (align == 2)\n     n_pieces = (size + 1) / 2U;\n   else\n     n_pieces = size;\n   if (n_pieces >= (unsigned int) (optimize_size ? 3 : 15))\n     return false;\n-  if (piece > 4)\n+  /* Force 32 bit aligned and larger datum to use 64 bit transfers, if\n+     possible.  */\n+  if (TARGET_LL64 && (piece >= 4) && (size >= 8))\n+    piece = 8;\n+  else if (piece > 4)\n     piece = 4;\n   dst_addr = force_offsettable (XEXP (operands[0], 0), size, 0);\n   src_addr = force_offsettable (XEXP (operands[1], 0), size, 0);\n@@ -7027,8 +7064,8 @@ arc_expand_movmem (rtx *operands)\n       rtx tmp;\n       machine_mode mode;\n \n-      if (piece > size)\n-\tpiece = size & -size;\n+      while (piece > size)\n+\tpiece >>= 1;\n       mode = smallest_mode_for_size (piece * BITS_PER_UNIT, MODE_INT);\n       /* If we don't re-use temporaries, the scheduler gets carried away,\n \t and the register pressure gets unnecessarily high.  */\n@@ -8463,12 +8500,11 @@ split_subsi (rtx *operands)\n    Operand 0: destination register\n    Operand 1: source register  */\n \n-static rtx\n+static bool\n arc_process_double_reg_moves (rtx *operands)\n {\n   rtx dest = operands[0];\n   rtx src  = operands[1];\n-  rtx val;\n \n   enum usesDxState { none, srcDx, destDx, maxDx };\n   enum usesDxState state = none;\n@@ -8483,9 +8519,7 @@ arc_process_double_reg_moves (rtx *operands)\n     }\n \n   if (state == none)\n-    return NULL_RTX;\n-\n-  start_sequence ();\n+    return false;\n \n   if (state == srcDx)\n     {\n@@ -8532,30 +8566,36 @@ arc_process_double_reg_moves (rtx *operands)\n   else\n     gcc_unreachable ();\n \n-  val = get_insns ();\n-  end_sequence ();\n-  return val;\n+  return true;\n }\n \n /* operands 0..1 are the operands of a 64 bit move instruction.\n    split it into two moves with operands 2/3 and 4/5.  */\n \n-rtx\n+void\n arc_split_move (rtx *operands)\n {\n   machine_mode mode = GET_MODE (operands[0]);\n   int i;\n   int swap = 0;\n   rtx xop[4];\n-  rtx val;\n \n   if (TARGET_DPFP)\n   {\n-    val = arc_process_double_reg_moves (operands);\n-    if (val)\n-      return val;\n+    if (arc_process_double_reg_moves (operands))\n+      return;\n   }\n \n+  if (TARGET_LL64\n+      && ((memory_operand (operands[0], mode)\n+\t   && even_register_operand (operands[1], mode))\n+\t  || (memory_operand (operands[1], mode)\n+\t      && even_register_operand (operands[0], mode))))\n+    {\n+      emit_move_insn (operands[0], operands[1]);\n+      return;\n+    }\n+\n   for (i = 0; i < 2; i++)\n     {\n       if (MEM_P (operands[i]) && auto_inc_p (XEXP (operands[i], 0)))\n@@ -8603,18 +8643,10 @@ arc_split_move (rtx *operands)\n       swap = 2;\n       gcc_assert (!reg_overlap_mentioned_p (xop[2], xop[1]));\n     }\n-  operands[2+swap] = xop[0];\n-  operands[3+swap] = xop[1];\n-  operands[4-swap] = xop[2];\n-  operands[5-swap] = xop[3];\n \n-  start_sequence ();\n-  emit_insn (gen_rtx_SET (operands[2], operands[3]));\n-  emit_insn (gen_rtx_SET (operands[4], operands[5]));\n-  val = get_insns ();\n-  end_sequence ();\n+  emit_move_insn (xop[0 + swap], xop[1 + swap]);\n+  emit_move_insn (xop[2 - swap], xop[3 - swap]);\n \n-  return val;\n }\n \n /* Select between the instruction output templates s_tmpl (for short INSNs)\n@@ -9329,6 +9361,28 @@ arc_no_speculation_in_delay_slots_p ()\n   return true;\n }\n \n+/* Return a parallel of registers to represent where to find the\n+   register pieces if required, otherwise NULL_RTX.  */\n+\n+static rtx\n+arc_dwarf_register_span (rtx rtl)\n+{\n+   enum machine_mode mode = GET_MODE (rtl);\n+   unsigned regno;\n+   rtx p;\n+\n+   if (GET_MODE_SIZE (mode) != 8)\n+     return NULL_RTX;\n+\n+   p = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));\n+   regno = REGNO (rtl);\n+   XVECEXP (p, 0, 0) = gen_rtx_REG (SImode, regno);\n+   XVECEXP (p, 0, 1) = gen_rtx_REG (SImode, regno + 1);\n+\n+   return p;\n+}\n+\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-arc.h\""}, {"sha": "27665b0caa7920242fb9460ff103abab580f4165", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d34a0fdc03bf55b287d884a9138e3965387af4b1/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d34a0fdc03bf55b287d884a9138e3965387af4b1/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=d34a0fdc03bf55b287d884a9138e3965387af4b1", "patch": "@@ -97,6 +97,10 @@ along with GCC; see the file COPYING3.  If not see\n \tbuiltin_define (\"__ARC_NORM__\");\\\n \tbuiltin_define (\"__Xnorm\");\t\\\n       }\t\t\t\t\t\\\n+    if (TARGET_LL64)\t\t\t\\\n+      {\t\t\t\t\t\\\n+\tbuiltin_define (\"__ARC_LL64__\");\\\n+      }\t\t\t\t\t\\\n     if (TARGET_MUL64_SET)\t\t\\\n       builtin_define (\"__ARC_MUL64__\");\\\n     if (TARGET_MULMAC_32BY16_SET)\t\\"}, {"sha": "222a468fc1b2bf974c75ef4f25d27eb74a1c4dde", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 59, "deletions": 50, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d34a0fdc03bf55b287d884a9138e3965387af4b1/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d34a0fdc03bf55b287d884a9138e3965387af4b1/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=d34a0fdc03bf55b287d884a9138e3965387af4b1", "patch": "@@ -984,7 +984,7 @@\n }\")\n \n (define_insn_and_split \"*movdi_insn\"\n-  [(set (match_operand:DI 0 \"move_dest_operand\" \"=w,w,r,m\")\n+  [(set (match_operand:DI 0 \"move_dest_operand\"      \"=w, w,r,m\")\n \t(match_operand:DI 1 \"move_double_src_operand\" \"c,Hi,m,c\"))]\n   \"register_operand (operands[0], DImode)\n    || register_operand (operands[1], DImode)\"\n@@ -993,50 +993,36 @@\n   switch (which_alternative)\n     {\n     default:\n-    case 0 :\n-      /* We normally copy the low-numbered register first.  However, if\n-\t the first register operand 0 is the same as the second register of\n-\t operand 1, we must copy in the opposite order.  */\n-      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n-\treturn \\\"mov%? %R0,%R1\\;mov%? %0,%1\\\";\n-      else\n-      return \\\"mov%? %0,%1\\;mov%? %R0,%R1\\\";\n-    case 1 :\n-      return \\\"mov%? %L0,%L1\\;mov%? %H0,%H1\\\";\n-    case 2 :\n-      /* If the low-address word is used in the address, we must load it\n-\t last.  Otherwise, load it first.  Note that we cannot have\n-\t auto-increment in that case since the address register is known to be\n-\t dead.  */\n-      if (refers_to_regno_p (REGNO (operands[0]), operands[1]))\n-\treturn \\\"ld%V1 %R0,%R1\\;ld%V1 %0,%1\\\";\n-      else switch (GET_CODE (XEXP(operands[1], 0)))\n-\t{\n-\tcase POST_MODIFY: case POST_INC: case POST_DEC:\n-\t  return \\\"ld%V1 %R0,%R1\\;ld%U1%V1 %0,%1\\\";\n-\tcase PRE_MODIFY: case PRE_INC: case PRE_DEC:\n-\t  return \\\"ld%U1%V1 %0,%1\\;ld%V1 %R0,%R1\\\";\n-\tdefault:\n-\t  return \\\"ld%U1%V1 %0,%1\\;ld%U1%V1 %R0,%R1\\\";\n-\t}\n-    case 3 :\n-      switch (GET_CODE (XEXP(operands[0], 0)))\n-\t{\n-\tcase POST_MODIFY: case POST_INC: case POST_DEC:\n-     \t  return \\\"st%V0 %R1,%R0\\;st%U0%V0 %1,%0\\\";\n-\tcase PRE_MODIFY: case PRE_INC: case PRE_DEC:\n-     \t  return \\\"st%U0%V0 %1,%0\\;st%V0 %R1,%R0\\\";\n-\tdefault:\n-     \t  return \\\"st%U0%V0 %1,%0\\;st%U0%V0 %R1,%R0\\\";\n-\t}\n+      return \\\"#\\\";\n+\n+    case 2:\n+    if (TARGET_LL64\n+\t&& ((even_register_operand (operands[0], DImode)\n+\t     && memory_operand (operands[1], DImode))\n+\t    || (memory_operand (operands[0], DImode)\n+\t        && even_register_operand (operands[1], DImode))))\n+      return \\\"ldd%U1%V1 %0,%1%&\\\";\n+    return \\\"#\\\";\n+\n+    case 3:\n+    if (TARGET_LL64\n+\t&& ((even_register_operand (operands[0], DImode)\n+\t     && memory_operand (operands[1], DImode))\n+\t    || (memory_operand (operands[0], DImode)\n+\t        && even_register_operand (operands[1], DImode))))\n+     return \\\"std%U0%V0 %1,%0\\\";\n+    return \\\"#\\\";\n     }\n }\"\n-  \"&& reload_completed && optimize\"\n-  [(set (match_dup 2) (match_dup 3)) (set (match_dup 4) (match_dup 5))]\n-  \"arc_split_move (operands);\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+  {\n+   arc_split_move (operands);\n+   DONE;\n+  }\n   [(set_attr \"type\" \"move,move,load,store\")\n    ;; ??? The ld/st values could be 4 if it's [reg,bignum].\n-   (set_attr \"length\" \"8,16,16,16\")])\n+   (set_attr \"length\" \"8,16,*,*\")])\n \n \n ;; Floating point move insns.\n@@ -1066,23 +1052,46 @@\n   \"\"\n   \"if (prepare_move_operands (operands, DFmode)) DONE;\")\n \n-(define_insn \"*movdf_insn\"\n+(define_insn_and_split \"*movdf_insn\"\n   [(set (match_operand:DF 0 \"move_dest_operand\"      \"=D,r,c,c,r,m\")\n \t(match_operand:DF 1 \"move_double_src_operand\" \"r,D,c,E,m,c\"))]\n   \"register_operand (operands[0], DFmode) || register_operand (operands[1], DFmode)\"\n-  \"#\"\n+  \"*\n+{\n+ switch (which_alternative)\n+   {\n+    default:\n+      return \\\"#\\\";\n+    case 4:\n+    if (TARGET_LL64\n+\t&& ((even_register_operand (operands[0], DFmode)\n+\t     && memory_operand (operands[1], DFmode))\n+\t    || (memory_operand (operands[0], DFmode)\n+\t        && even_register_operand (operands[1], DFmode))))\n+      return \\\"ldd%U1%V1 %0,%1%&\\\";\n+    return \\\"#\\\";\n+\n+    case 5:\n+    if (TARGET_LL64\n+\t&& ((even_register_operand (operands[0], DFmode)\n+\t     && memory_operand (operands[1], DFmode))\n+\t    || (memory_operand (operands[0], DFmode)\n+\t\t&& even_register_operand (operands[1], DFmode))))\n+     return \\\"std%U0%V0 %1,%0\\\";\n+    return \\\"#\\\";\n+   }\n+}\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+  {\n+   arc_split_move (operands);\n+   DONE;\n+  }\n   [(set_attr \"type\" \"move,move,move,move,load,store\")\n    (set_attr \"predicable\" \"no,no,yes,yes,no,no\")\n    ;; ??? The ld/st values could be 16 if it's [reg,bignum].\n    (set_attr \"length\" \"4,16,8,16,16,16\")])\n \n-(define_split\n-  [(set (match_operand:DF 0 \"move_dest_operand\" \"\")\n-\t(match_operand:DF 1 \"move_double_src_operand\" \"\"))]\n-  \"reload_completed\"\n-  [(match_dup 2)]\n-  \"operands[2] = arc_split_move (operands);\")\n-\n (define_insn_and_split \"*movdf_insn_nolrsr\"\n   [(set (match_operand:DF 0 \"register_operand\"       \"=r\")\n \t(match_operand:DF 1 \"arc_double_register_operand\" \"D\"))"}, {"sha": "00b98d58f5431b87bde76bef24822eb699646e86", "filename": "gcc/config/arc/arc.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d34a0fdc03bf55b287d884a9138e3965387af4b1/gcc%2Fconfig%2Farc%2Farc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d34a0fdc03bf55b287d884a9138e3965387af4b1/gcc%2Fconfig%2Farc%2Farc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.opt?ref=d34a0fdc03bf55b287d884a9138e3965387af4b1", "patch": "@@ -409,3 +409,7 @@ Target Joined\n matomic\n Target Report Mask(ATOMIC)\n Enable atomic instructions.\n+\n+mll64\n+Target Report Mask(LL64)\n+Enable double load/store instructions for ARC HS."}, {"sha": "52ac2ac5517a8d4c73e534fac33aaba6fffa97ea", "filename": "gcc/config/arc/predicates.md", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d34a0fdc03bf55b287d884a9138e3965387af4b1/gcc%2Fconfig%2Farc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d34a0fdc03bf55b287d884a9138e3965387af4b1/gcc%2Fconfig%2Farc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fpredicates.md?ref=d34a0fdc03bf55b287d884a9138e3965387af4b1", "patch": "@@ -783,4 +783,15 @@\n        (match_code \"reg\" \"0\")))\n \n (define_predicate \"any_mem_operand\"\n-  (match_code \"mem\"))\n\\ No newline at end of file\n+  (match_code \"mem\"))\n+\n+; Special predicate to match even-odd double register pair\n+(define_predicate \"even_register_operand\"\n+  (match_code \"reg\")\n+  {\n+   if ((GET_MODE (op) != mode) && (mode != VOIDmode))\n+      return 0;\n+\n+   return (REG_P (op) && ((REGNO (op) >= FIRST_PSEUDO_REGISTER)\n+\t\t\t  || ((REGNO (op) & 1) == 0)));\n+  })"}, {"sha": "ba0b4b2cd564c60329c170f64723ce3e0b81a046", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d34a0fdc03bf55b287d884a9138e3965387af4b1/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d34a0fdc03bf55b287d884a9138e3965387af4b1/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d34a0fdc03bf55b287d884a9138e3965387af4b1", "patch": "@@ -599,7 +599,7 @@ Objective-C and Objective-C++ Dialects}.\n -mmixed-code -mq-class -mRcq -mRcw -msize-level=@var{level} @gol\n -mtune=@var{cpu} -mmultcost=@var{num} @gol\n -munalign-prob-threshold=@var{probability} -mmpy-option=@var{multo} @gol\n--mdiv-rem -mcode-density}\n+-mdiv-rem -mcode-density -mll64}\n \n @emph{ARM Options}\n @gccoptlist{-mapcs-frame  -mno-apcs-frame @gol\n@@ -13259,6 +13259,10 @@ Enable DIV/REM instructions for ARCv2 cores.\n @opindex mcode-density\n Enable code density instructions for ARC EM, default on for ARC HS.\n \n+@item -mll64\n+@opindex mll64\n+Enable double load/store operations for ARC HS cores.\n+\n @item -mmpy-option=@var{multo}\n @opindex mmpy-option\n Compile ARCv2 code with a multiplier design option.  @samp{wlh1} is"}]}