{"sha": "dbcb3c7446c4c9f8f491db6a71bbab318918c874", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJjYjNjNzQ0NmM0YzlmOGY0OTFkYjZhNzFiYmFiMzE4OTE4Yzg3NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-05-18T14:18:08Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-05-18T14:18:08Z"}, "message": "ipa-inline-analysis.c (predicate_conditions): Move to ipa-inline.h (true_predicate...\n\n\n\t* ipa-inline-analysis.c (predicate_conditions): Move to ipa-inline.h\n\t(true_predicate, false_predicate, true_predicate_p,\n\tfalse_predicate_p): Remove.\n\t(single_cond_predicate, not_inlined_predicate): Turn to member function\n\tin ipa-inline.h\n\t(add_condition): Update.\n\t(add_clause): Turn to...\n\t(predicate::add_clause): ... this one; update; allow passing NULL\n\tas parameter.\n\t(and_predicates): Turn to ...\n\t(predicate::operator &=): ... this one.\n\t(predicates_equal_p): Move to predicate::operator == in ipa-inline.h\n\t(or_predicates): Turn to ...\n\t(predicate::or_with): ... this one.\n\t(evaluate_predicate): Turn to ...\n\t(predicate::evaluate): ... this one.\n\t(predicate_probability): Turn to ...\n\t(predicate::probability): ... this one.\n\t(dump_condition): Update.\n\t(dump_predicate): Turn to ...\n\t(predicate::dump): ... this one.\n\t(account_size_time): Update.\n\t(edge_set_predicate): Update.\n\t(set_hint_predicate): UPdate.\n\t(evaluate_conditions_for_known_args): Update.\n\t(evaluate_properties_for_edge): Update.\n\t(remap_predicate_after_duplication): Turn to...\n\t(predicate::remap_after_duplication): ... this one.\n\t(remap_hint_predicate_after_duplication): Update.\n\t(inline_summary_t::duplicate): UPdate.\n\t(dump_inline_edge_summary): Update.\n\t(dump_inline_summary): Update.\n\t(set_cond_stmt_execution_predicate): Update.\n\t(set_switch_stmt_execution_predicate): Update.\n\t(compute_bb_predicates): Update.\n\t(will_be_nonconstant_expr_predicate): Update.\n\t(will_be_nonconstant_predicate): Update.\n\t(phi_result_unknown_predicate): Update.\n\t(predicate_for_phi_result): Update.\n\t(array_index_predicate): Update.\n\t(estimate_function_body_sizes): Update.\n\t(estimate_node_size_and_time): Update.\n\t(estimate_ipcp_clone_size_and_time): Update.\n\t(remap_predicate): Rename to ...\n\t(predicate::remap_after_inlining): ... this one.\n\t(remap_hint_predicate): Update.\n\t(inline_merge_summary): Update.\n\t(inline_update_overall_summary): Update.\n\t(estimate_size_after_inlining): Update.\n\t(read_predicate): Rename to ...\n\t(predicate::stream_in): ... this one.\n\t(read_inline_edge_summary): Update.\n\t(write_predicate): Rename to ...\n\t(predicate::stream_out): ... this one.\n\t(write_inline_edge_summary): Update.\n\t* ipa-inline.h (MAX_CLAUSES): Turn to predicate::max_clauses.\n\t(clause_t): Turn to uint32_t\n\t(predicate): Turn to class; implement constructor and operators\n\t==, !=, &\n\t(size_time_entry): Update.\n\t(inline_summary): Update.\n\t(inline_edge_summary): Update.\n\nFrom-SVN: r248204", "tree": {"sha": "38c71e457572cc8584269d51e53b108f2e587367", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38c71e457572cc8584269d51e53b108f2e587367"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbcb3c7446c4c9f8f491db6a71bbab318918c874", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbcb3c7446c4c9f8f491db6a71bbab318918c874", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbcb3c7446c4c9f8f491db6a71bbab318918c874", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbcb3c7446c4c9f8f491db6a71bbab318918c874/comments", "author": null, "committer": null, "parents": [{"sha": "cdefeea2e6b4fc847fd23ff4d438b3c9db00d5a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdefeea2e6b4fc847fd23ff4d438b3c9db00d5a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdefeea2e6b4fc847fd23ff4d438b3c9db00d5a7"}], "stats": {"total": 1183, "additions": 626, "deletions": 557}, "files": [{"sha": "3ced7226cc9a7e3f391b1a228b7c9b3c95d30ad9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbcb3c7446c4c9f8f491db6a71bbab318918c874/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbcb3c7446c4c9f8f491db6a71bbab318918c874/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dbcb3c7446c4c9f8f491db6a71bbab318918c874", "patch": "@@ -1,3 +1,68 @@\n+2017-05-18  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-inline-analysis.c (predicate_conditions): Move to ipa-inline.h\n+\t(true_predicate, false_predicate, true_predicate_p,\n+\tfalse_predicate_p): Remove.\n+\t(single_cond_predicate, not_inlined_predicate): Turn to member function\n+\tin ipa-inline.h\n+\t(add_condition): Update.\n+\t(add_clause): Turn to...\n+\t(predicate::add_clause): ... this one; update; allow passing NULL\n+\tas parameter.\n+\t(and_predicates): Turn to ...\n+\t(predicate::operator &=): ... this one.\n+\t(predicates_equal_p): Move to predicate::operator == in ipa-inline.h\n+\t(or_predicates): Turn to ...\n+\t(predicate::or_with): ... this one.\n+\t(evaluate_predicate): Turn to ...\n+\t(predicate::evaluate): ... this one.\n+\t(predicate_probability): Turn to ...\n+\t(predicate::probability): ... this one.\n+\t(dump_condition): Update.\n+\t(dump_predicate): Turn to ...\n+\t(predicate::dump): ... this one.\n+\t(account_size_time): Update.\n+\t(edge_set_predicate): Update.\n+\t(set_hint_predicate): UPdate.\n+\t(evaluate_conditions_for_known_args): Update.\n+\t(evaluate_properties_for_edge): Update.\n+\t(remap_predicate_after_duplication): Turn to...\n+\t(predicate::remap_after_duplication): ... this one.\n+\t(remap_hint_predicate_after_duplication): Update.\n+\t(inline_summary_t::duplicate): UPdate.\n+\t(dump_inline_edge_summary): Update.\n+\t(dump_inline_summary): Update.\n+\t(set_cond_stmt_execution_predicate): Update.\n+\t(set_switch_stmt_execution_predicate): Update.\n+\t(compute_bb_predicates): Update.\n+\t(will_be_nonconstant_expr_predicate): Update.\n+\t(will_be_nonconstant_predicate): Update.\n+\t(phi_result_unknown_predicate): Update.\n+\t(predicate_for_phi_result): Update.\n+\t(array_index_predicate): Update.\n+\t(estimate_function_body_sizes): Update.\n+\t(estimate_node_size_and_time): Update.\n+\t(estimate_ipcp_clone_size_and_time): Update.\n+\t(remap_predicate): Rename to ...\n+\t(predicate::remap_after_inlining): ... this one.\n+\t(remap_hint_predicate): Update.\n+\t(inline_merge_summary): Update.\n+\t(inline_update_overall_summary): Update.\n+\t(estimate_size_after_inlining): Update.\n+\t(read_predicate): Rename to ...\n+\t(predicate::stream_in): ... this one.\n+\t(read_inline_edge_summary): Update.\n+\t(write_predicate): Rename to ...\n+\t(predicate::stream_out): ... this one.\n+\t(write_inline_edge_summary): Update.\n+\t* ipa-inline.h (MAX_CLAUSES): Turn to predicate::max_clauses.\n+\t(clause_t): Turn to uint32_t\n+\t(predicate): Turn to class; implement constructor and operators\n+\t==, !=, &\n+\t(size_time_entry): Update.\n+\t(inline_summary): Update.\n+\t(inline_edge_summary): Update.\n+\n 2017-05-18  Marc Glisse  <marc.glisse@inria.fr>\n \n \t* fold-const.c (fold_binary_loc): Move transformation..."}, {"sha": "ee8744449a07cd288a4ebe01ccad6670b062b959", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 398, "deletions": 527, "changes": 925, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbcb3c7446c4c9f8f491db6a71bbab318918c874/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbcb3c7446c4c9f8f491db6a71bbab318918c874/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=dbcb3c7446c4c9f8f491db6a71bbab318918c874", "patch": "@@ -44,17 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n    It is easy to add more variants.  To represent function size and time\n    that depends on context (i.e. it is known to be optimized away when\n    context is known either by inlining or from IP-CP and cloning),\n-   we use predicates. Predicates are logical formulas in\n-   conjunctive-disjunctive form consisting of clauses. Clauses are bitmaps\n-   specifying what conditions must be true. Conditions are simple test\n-   of the form described above.\n-\n-   In order to make predicate (possibly) true, all of its clauses must\n-   be (possibly) true. To make clause (possibly) true, one of conditions\n-   it mentions must be (possibly) true.  There are fixed bounds on\n-   number of clauses and conditions and all the manipulation functions\n-   are conservative in positive direction. I.e. we may lose precision\n-   by thinking that predicate may be true even when it is not.\n+   we use predicates.\n \n    estimate_edge_size and estimate_edge_growth can be used to query\n    function size/time in the given context.  inline_merge_summary merges\n@@ -100,13 +90,6 @@ along with GCC; see the file COPYING3.  If not see\n    hosts.  */\n #define NUM_CONDITIONS 32\n \n-enum predicate_conditions\n-{\n-  predicate_false_condition = 0,\n-  predicate_not_inlined_condition = 1,\n-  predicate_first_dynamic_condition = 2\n-};\n-\n /* Special condition code we use to represent test that operand is compile time\n    constant.  */\n #define IS_NOT_CONSTANT ERROR_MARK\n@@ -134,71 +117,6 @@ vec<edge_growth_cache_entry> edge_growth_cache;\n /* Edge predicates goes here.  */\n static object_allocator<predicate> edge_predicate_pool (\"edge predicates\");\n \n-/* Return true predicate (tautology).\n-   We represent it by empty list of clauses.  */\n-\n-static inline struct predicate\n-true_predicate (void)\n-{\n-  struct predicate p;\n-  p.clause[0] = 0;\n-  return p;\n-}\n-\n-\n-/* Return predicate testing single condition number COND.  */\n-\n-static inline struct predicate\n-single_cond_predicate (int cond)\n-{\n-  struct predicate p;\n-  p.clause[0] = 1 << cond;\n-  p.clause[1] = 0;\n-  return p;\n-}\n-\n-\n-/* Return false predicate.  First clause require false condition.  */\n-\n-static inline struct predicate\n-false_predicate (void)\n-{\n-  return single_cond_predicate (predicate_false_condition);\n-}\n-\n-\n-/* Return true if P is (true).  */\n-\n-static inline bool\n-true_predicate_p (struct predicate *p)\n-{\n-  return !p->clause[0];\n-}\n-\n-\n-/* Return true if P is (false).  */\n-\n-static inline bool\n-false_predicate_p (struct predicate *p)\n-{\n-  if (p->clause[0] == (1 << predicate_false_condition))\n-    {\n-      gcc_checking_assert (!p->clause[1]\n-\t\t\t   && p->clause[0] == 1 << predicate_false_condition);\n-      return true;\n-    }\n-  return false;\n-}\n-\n-\n-/* Return predicate that is set true when function is not inlined.  */\n-\n-static inline struct predicate\n-not_inlined_predicate (void)\n-{\n-  return single_cond_predicate (predicate_not_inlined_condition);\n-}\n-\n /* Simple description of whether a memory load or a condition refers to a load\n    from an aggregate and if so, how and where from in the aggregate.\n    Individual fields have the same meaning like fields with the same name in\n@@ -216,7 +134,7 @@ struct agg_position_info\n    used operand is loaded from an aggregate and where in the aggregate it is.\n    It can be NULL, which means this not a load from an aggregate.  */\n \n-static struct predicate\n+static predicate\n add_condition (struct inline_summary *summary, int operand_num,\n \t       HOST_WIDE_INT size, struct agg_position_info *aggpos,\n \t       enum tree_code code, tree val)\n@@ -249,11 +167,11 @@ add_condition (struct inline_summary *summary, int operand_num,\n \t  && c->val == val\n \t  && c->agg_contents == agg_contents\n \t  && (!agg_contents || (c->offset == offset && c->by_ref == by_ref)))\n-\treturn single_cond_predicate (i + predicate_first_dynamic_condition);\n+\treturn predicate::predicate_testing_cond (i);\n     }\n   /* Too many conditions.  Give up and return constant true.  */\n-  if (i == NUM_CONDITIONS - predicate_first_dynamic_condition)\n-    return true_predicate ();\n+  if (i == NUM_CONDITIONS - predicate::first_dynamic_condition)\n+    return true;\n \n   new_cond.operand_num = operand_num;\n   new_cond.code = code;\n@@ -263,182 +181,166 @@ add_condition (struct inline_summary *summary, int operand_num,\n   new_cond.offset = offset;\n   new_cond.size = size;\n   vec_safe_push (summary->conds, new_cond);\n-  return single_cond_predicate (i + predicate_first_dynamic_condition);\n+\n+  return predicate::predicate_testing_cond (i);\n }\n \n \n-/* Add clause CLAUSE into the predicate P.  */\n+/* Add clause CLAUSE into the predicate P.\n+   When CONDITIONS is NULL do not perform checking whether NEW_CLAUSE\n+   is obviously true.  This is useful only when NEW_CLAUSE is known to be\n+   sane.  */\n \n-static inline void\n-add_clause (conditions conditions, struct predicate *p, clause_t clause)\n+void\n+predicate::add_clause (conditions conditions, clause_t new_clause)\n {\n   int i;\n   int i2;\n   int insert_here = -1;\n   int c1, c2;\n \n   /* True clause.  */\n-  if (!clause)\n+  if (!new_clause)\n     return;\n \n   /* False clause makes the whole predicate false.  Kill the other variants.  */\n-  if (clause == (1 << predicate_false_condition))\n+  if (new_clause == (1 << predicate::false_condition))\n     {\n-      p->clause[0] = (1 << predicate_false_condition);\n-      p->clause[1] = 0;\n+      *this = false;\n       return;\n     }\n-  if (false_predicate_p (p))\n+  if (*this == false)\n     return;\n \n   /* No one should be silly enough to add false into nontrivial clauses.  */\n-  gcc_checking_assert (!(clause & (1 << predicate_false_condition)));\n+  gcc_checking_assert (!(new_clause & (1 << predicate::false_condition)));\n \n-  /* Look where to insert the clause.  At the same time prune out\n-     clauses of P that are implied by the new clause and thus\n+  /* Look where to insert the new_clause.  At the same time prune out\n+     new_clauses of P that are implied by the new new_clause and thus\n      redundant.  */\n-  for (i = 0, i2 = 0; i <= MAX_CLAUSES; i++)\n+  for (i = 0, i2 = 0; i <= max_clauses; i++)\n     {\n-      p->clause[i2] = p->clause[i];\n+      m_clause[i2] = m_clause[i];\n \n-      if (!p->clause[i])\n+      if (!m_clause[i])\n \tbreak;\n \n-      /* If p->clause[i] implies clause, there is nothing to add.  */\n-      if ((p->clause[i] & clause) == p->clause[i])\n+      /* If m_clause[i] implies new_clause, there is nothing to add.  */\n+      if ((m_clause[i] & new_clause) == m_clause[i])\n \t{\n \t  /* We had nothing to add, none of clauses should've become\n \t     redundant.  */\n \t  gcc_checking_assert (i == i2);\n \t  return;\n \t}\n \n-      if (p->clause[i] < clause && insert_here < 0)\n+      if (m_clause[i] < new_clause && insert_here < 0)\n \tinsert_here = i2;\n \n-      /* If clause implies p->clause[i], then p->clause[i] becomes redundant.\n-         Otherwise the p->clause[i] has to stay.  */\n-      if ((p->clause[i] & clause) != clause)\n+      /* If new_clause implies clause[i], then clause[i] becomes redundant.\n+         Otherwise the clause[i] has to stay.  */\n+      if ((m_clause[i] & new_clause) != new_clause)\n \ti2++;\n     }\n \n   /* Look for clauses that are obviously true.  I.e.\n      op0 == 5 || op0 != 5.  */\n-  for (c1 = predicate_first_dynamic_condition; c1 < NUM_CONDITIONS; c1++)\n-    {\n-      condition *cc1;\n-      if (!(clause & (1 << c1)))\n-\tcontinue;\n-      cc1 = &(*conditions)[c1 - predicate_first_dynamic_condition];\n-      /* We have no way to represent !CHANGED and !IS_NOT_CONSTANT\n-         and thus there is no point for looking for them.  */\n-      if (cc1->code == CHANGED || cc1->code == IS_NOT_CONSTANT)\n-\tcontinue;\n-      for (c2 = c1 + 1; c2 < NUM_CONDITIONS; c2++)\n-\tif (clause & (1 << c2))\n-\t  {\n-\t    condition *cc1 =\n-\t      &(*conditions)[c1 - predicate_first_dynamic_condition];\n-\t    condition *cc2 =\n-\t      &(*conditions)[c2 - predicate_first_dynamic_condition];\n-\t    if (cc1->operand_num == cc2->operand_num\n-\t\t&& cc1->val == cc2->val\n-\t\t&& cc2->code != IS_NOT_CONSTANT\n-\t\t&& cc2->code != CHANGED\n-\t\t&& cc1->code == invert_tree_comparison (cc2->code,\n-\t\t\t\t\t\t\tHONOR_NANS (cc1->val)))\n-\t      return;\n-\t  }\n-    }\n+  if (conditions)\n+    for (c1 = predicate::first_dynamic_condition; c1 < NUM_CONDITIONS; c1++)\n+      {\n+\tcondition *cc1;\n+\tif (!(new_clause & (1 << c1)))\n+\t  continue;\n+\tcc1 = &(*conditions)[c1 - predicate::first_dynamic_condition];\n+\t/* We have no way to represent !CHANGED and !IS_NOT_CONSTANT\n+\t   and thus there is no point for looking for them.  */\n+\tif (cc1->code == CHANGED || cc1->code == IS_NOT_CONSTANT)\n+\t  continue;\n+\tfor (c2 = c1 + 1; c2 < NUM_CONDITIONS; c2++)\n+\t  if (new_clause & (1 << c2))\n+\t    {\n+\t      condition *cc1 =\n+\t\t&(*conditions)[c1 - predicate::first_dynamic_condition];\n+\t      condition *cc2 =\n+\t\t&(*conditions)[c2 - predicate::first_dynamic_condition];\n+\t      if (cc1->operand_num == cc2->operand_num\n+\t\t  && cc1->val == cc2->val\n+\t\t  && cc2->code != IS_NOT_CONSTANT\n+\t\t  && cc2->code != CHANGED\n+\t\t  && cc1->code == invert_tree_comparison (cc2->code,\n+\t\t\t\t\t\t\t  HONOR_NANS (cc1->val)))\n+\t\treturn;\n+\t    }\n+      }\n \n \n   /* We run out of variants.  Be conservative in positive direction.  */\n-  if (i2 == MAX_CLAUSES)\n+  if (i2 == max_clauses)\n     return;\n   /* Keep clauses in decreasing order. This makes equivalence testing easy.  */\n-  p->clause[i2 + 1] = 0;\n+  m_clause[i2 + 1] = 0;\n   if (insert_here >= 0)\n     for (; i2 > insert_here; i2--)\n-      p->clause[i2] = p->clause[i2 - 1];\n+      m_clause[i2] = m_clause[i2 - 1];\n   else\n     insert_here = i2;\n-  p->clause[insert_here] = clause;\n+  m_clause[insert_here] = new_clause;\n }\n \n \n-/* Return P & P2.  */\n+/* Do THIS &= P.  */\n \n-static struct predicate\n-and_predicates (conditions conditions,\n-\t\tstruct predicate *p, struct predicate *p2)\n+predicate &\n+predicate::operator &= (const predicate &p)\n {\n-  struct predicate out = *p;\n-  int i;\n-\n   /* Avoid busy work.  */\n-  if (false_predicate_p (p2) || true_predicate_p (p))\n-    return *p2;\n-  if (false_predicate_p (p) || true_predicate_p (p2))\n-    return *p;\n+  if (p == false || *this == true)\n+    {\n+      *this = p;\n+      return *this;\n+    }\n+  if (*this == false || p == true || this == &p)\n+    return *this;\n+\n+  int i;\n \n   /* See how far predicates match.  */\n-  for (i = 0; p->clause[i] && p->clause[i] == p2->clause[i]; i++)\n+  for (i = 0; m_clause[i] && m_clause[i] == p.m_clause[i]; i++)\n     {\n-      gcc_checking_assert (i < MAX_CLAUSES);\n+      gcc_checking_assert (i < max_clauses);\n     }\n \n   /* Combine the predicates rest.  */\n-  for (; p2->clause[i]; i++)\n+  for (; p.m_clause[i]; i++)\n     {\n-      gcc_checking_assert (i < MAX_CLAUSES);\n-      add_clause (conditions, &out, p2->clause[i]);\n+      gcc_checking_assert (i < max_clauses);\n+      add_clause (NULL, p.m_clause[i]);\n     }\n-  return out;\n+  return *this;\n }\n \n \n-/* Return true if predicates are obviously equal.  */\n-\n-static inline bool\n-predicates_equal_p (struct predicate *p, struct predicate *p2)\n-{\n-  int i;\n-  for (i = 0; p->clause[i]; i++)\n-    {\n-      gcc_checking_assert (i < MAX_CLAUSES);\n-      gcc_checking_assert (p->clause[i] > p->clause[i + 1]);\n-      gcc_checking_assert (!p2->clause[i]\n-\t\t\t   || p2->clause[i] > p2->clause[i + 1]);\n-      if (p->clause[i] != p2->clause[i])\n-\treturn false;\n-    }\n-  return !p2->clause[i];\n-}\n-\n \n-/* Return P | P2.  */\n+/* Return THIS | P2.  */\n \n-static struct predicate\n-or_predicates (conditions conditions,\n-\t       struct predicate *p, struct predicate *p2)\n+predicate\n+predicate::or_with (conditions conditions,\n+\t            const predicate &p) const\n {\n-  struct predicate out = true_predicate ();\n-  int i, j;\n-\n   /* Avoid busy work.  */\n-  if (false_predicate_p (p2) || true_predicate_p (p))\n-    return *p;\n-  if (false_predicate_p (p) || true_predicate_p (p2))\n-    return *p2;\n-  if (predicates_equal_p (p, p2))\n-    return *p;\n+  if (p == false || *this == true || *this == p)\n+    return *this;\n+  if (*this == false || p == true)\n+    return p;\n \n   /* OK, combine the predicates.  */\n-  for (i = 0; p->clause[i]; i++)\n-    for (j = 0; p2->clause[j]; j++)\n+  predicate out = true;\n+\n+  for (int i = 0; m_clause[i]; i++)\n+    for (int j = 0; p.m_clause[j]; j++)\n       {\n-\tgcc_checking_assert (i < MAX_CLAUSES && j < MAX_CLAUSES);\n-\tadd_clause (conditions, &out, p->clause[i] | p2->clause[j]);\n+\tgcc_checking_assert (i < max_clauses && j < max_clauses);\n+\tout.add_clause (conditions, m_clause[i] | p.m_clause[j]);\n       }\n   return out;\n }\n@@ -447,22 +349,22 @@ or_predicates (conditions conditions,\n /* Having partial truth assignment in POSSIBLE_TRUTHS, return false\n    if predicate P is known to be false.  */\n \n-static bool\n-evaluate_predicate (struct predicate *p, clause_t possible_truths)\n+bool\n+predicate::evaluate (clause_t possible_truths) const\n {\n   int i;\n \n   /* True remains true.  */\n-  if (true_predicate_p (p))\n+  if (*this == true)\n     return true;\n \n-  gcc_assert (!(possible_truths & (1 << predicate_false_condition)));\n+  gcc_assert (!(possible_truths & (1 << predicate::false_condition)));\n \n   /* See if we can find clause we can disprove.  */\n-  for (i = 0; p->clause[i]; i++)\n+  for (i = 0; m_clause[i]; i++)\n     {\n-      gcc_checking_assert (i < MAX_CLAUSES);\n-      if (!(p->clause[i] & possible_truths))\n+      gcc_checking_assert (i < max_clauses);\n+      if (!(m_clause[i] & possible_truths))\n \treturn false;\n     }\n   return true;\n@@ -471,28 +373,28 @@ evaluate_predicate (struct predicate *p, clause_t possible_truths)\n /* Return the probability in range 0...REG_BR_PROB_BASE that the predicated\n    instruction will be recomputed per invocation of the inlined call.  */\n \n-static int\n-predicate_probability (conditions conds,\n-\t\t       struct predicate *p, clause_t possible_truths,\n-\t\t       vec<inline_param_summary> inline_param_summary)\n+int\n+predicate::probability (conditions conds,\n+\t                clause_t possible_truths,\n+\t                vec<inline_param_summary> inline_param_summary) const\n {\n   int i;\n   int combined_prob = REG_BR_PROB_BASE;\n \n   /* True remains true.  */\n-  if (true_predicate_p (p))\n+  if (*this == true)\n     return REG_BR_PROB_BASE;\n \n-  if (false_predicate_p (p))\n+  if (*this == false)\n     return 0;\n \n-  gcc_assert (!(possible_truths & (1 << predicate_false_condition)));\n+  gcc_assert (!(possible_truths & (1 << predicate::false_condition)));\n \n   /* See if we can find clause we can disprove.  */\n-  for (i = 0; p->clause[i]; i++)\n+  for (i = 0; m_clause[i]; i++)\n     {\n-      gcc_checking_assert (i < MAX_CLAUSES);\n-      if (!(p->clause[i] & possible_truths))\n+      gcc_checking_assert (i < max_clauses);\n+      if (!(m_clause[i] & possible_truths))\n \treturn 0;\n       else\n \t{\n@@ -501,12 +403,12 @@ predicate_probability (conditions conds,\n \t  if (!inline_param_summary.exists ())\n \t    return REG_BR_PROB_BASE;\n \t  for (i2 = 0; i2 < NUM_CONDITIONS; i2++)\n-\t    if ((p->clause[i] & possible_truths) & (1 << i2))\n+\t    if ((m_clause[i] & possible_truths) & (1 << i2))\n \t      {\n-\t\tif (i2 >= predicate_first_dynamic_condition)\n+\t\tif (i2 >= predicate::first_dynamic_condition)\n \t\t  {\n \t\t    condition *c =\n-\t\t      &(*conds)[i2 - predicate_first_dynamic_condition];\n+\t\t      &(*conds)[i2 - predicate::first_dynamic_condition];\n \t\t    if (c->code == CHANGED\n \t\t\t&& (c->operand_num <\n \t\t\t    (int) inline_param_summary.length ()))\n@@ -536,13 +438,13 @@ static void\n dump_condition (FILE *f, conditions conditions, int cond)\n {\n   condition *c;\n-  if (cond == predicate_false_condition)\n+  if (cond == predicate::false_condition)\n     fprintf (f, \"false\");\n-  else if (cond == predicate_not_inlined_condition)\n+  else if (cond == predicate::not_inlined_condition)\n     fprintf (f, \"not inlined\");\n   else\n     {\n-      c = &(*conditions)[cond - predicate_first_dynamic_condition];\n+      c = &(*conditions)[cond - predicate::first_dynamic_condition];\n       fprintf (f, \"op%i\", c->operand_num);\n       if (c->agg_contents)\n \tfprintf (f, \"[%soffset: \" HOST_WIDE_INT_PRINT_DEC \"]\",\n@@ -585,22 +487,21 @@ dump_clause (FILE *f, conditions conds, clause_t clause)\n }\n \n \n-/* Dump PREDICATE to F. CONDS a vector of conditions used when evauating\n+/* Dump THIS to F. CONDS a vector of conditions used when evauating\n    predicats. When NL is true new line is output at the end of dump.  */\n \n-static void\n-dump_predicate (FILE *f, conditions conds, struct predicate *pred,\n-\t\tbool nl = true)\n+void\n+predicate::dump (FILE *f, conditions conds, bool nl) const\n {\n   int i;\n-  if (true_predicate_p (pred))\n+  if (*this == true)\n     dump_clause (f, conds, 0);\n   else\n-    for (i = 0; pred->clause[i]; i++)\n+    for (i = 0; m_clause[i]; i++)\n       {\n \tif (i)\n \t  fprintf (f, \" && \");\n-\tdump_clause (f, conds, pred->clause[i]);\n+\tdump_clause (f, conds, m_clause[i]);\n       }\n   if (nl)\n     fprintf (f, \"\\n\");\n@@ -670,20 +571,20 @@ dump_inline_hints (FILE *f, inline_hints hints)\n \n static void\n account_size_time (struct inline_summary *summary, int size, sreal time,\n-\t\t   struct predicate *exec_pred,\n-\t\t   struct predicate *nonconst_pred_ptr)\n+\t\t   predicate *exec_pred,\n+\t\t   predicate *nonconst_pred_ptr)\n {\n   size_time_entry *e;\n   bool found = false;\n   int i;\n-  struct predicate nonconst_pred;\n+  predicate nonconst_pred;\n \n-  if (false_predicate_p (exec_pred))\n+  if (*exec_pred == false)\n     return;\n \n-  nonconst_pred = and_predicates (summary->conds, nonconst_pred_ptr, exec_pred);\n+  nonconst_pred = *nonconst_pred_ptr & *exec_pred;\n \n-  if (false_predicate_p (&nonconst_pred))\n+  if (nonconst_pred == false)\n     return;\n \n   /* We need to create initial empty unconitional clause, but otherwie\n@@ -694,8 +595,8 @@ account_size_time (struct inline_summary *summary, int size, sreal time,\n   gcc_assert (time >= 0);\n \n   for (i = 0; vec_safe_iterate (summary->entry, i, &e); i++)\n-    if (predicates_equal_p (&e->exec_predicate, exec_pred)\n-\t&& predicates_equal_p (&e->nonconst_predicate, &nonconst_pred))\n+    if (e->exec_predicate == *exec_pred\n+\t&& e->nonconst_predicate == nonconst_pred)\n       {\n \tfound = true;\n \tbreak;\n@@ -705,7 +606,6 @@ account_size_time (struct inline_summary *summary, int size, sreal time,\n       i = 0;\n       found = true;\n       e = &(*summary->entry)[0];\n-      gcc_assert (!e->exec_predicate.clause[0]);\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n \t\t \"\\t\\tReached limit on number of entries, \"\n@@ -717,11 +617,11 @@ account_size_time (struct inline_summary *summary, int size, sreal time,\n \t       \"\\t\\tAccounting size:%3.2f, time:%3.2f on %spredicate exec:\",\n \t       ((double) size) / INLINE_SIZE_SCALE,\n \t       (time.to_double ()), found ? \"\" : \"new \");\n-      dump_predicate (dump_file, summary->conds, exec_pred, 0);\n-      if (!predicates_equal_p (exec_pred, &nonconst_pred))\n+      exec_pred->dump (dump_file, summary->conds, 0);\n+      if (*exec_pred != nonconst_pred)\n \t{\n           fprintf (dump_file, \" nonconst:\");\n-          dump_predicate (dump_file, summary->conds, &nonconst_pred);\n+          nonconst_pred.dump (dump_file, summary->conds);\n \t}\n       else\n         fprintf (dump_file, \"\\n\");\n@@ -771,19 +671,19 @@ redirect_to_unreachable (struct cgraph_edge *e)\n /* Set predicate for edge E.  */\n \n static void\n-edge_set_predicate (struct cgraph_edge *e, struct predicate *predicate)\n+edge_set_predicate (struct cgraph_edge *e, predicate *predicate)\n {\n   /* If the edge is determined to be never executed, redirect it\n      to BUILTIN_UNREACHABLE to save inliner from inlining into it.  */\n-  if (predicate && false_predicate_p (predicate)\n+  if (predicate && *predicate == false\n       /* When handling speculative edges, we need to do the redirection\n          just once.  Do it always on the direct edge, so we do not\n \t attempt to resolve speculation while duplicating the edge.  */\n       && (!e->speculative || e->callee))\n     e = redirect_to_unreachable (e);\n \n   struct inline_edge_summary *es = inline_edge_summary (e);\n-  if (predicate && !true_predicate_p (predicate))\n+  if (predicate && *predicate != true)\n     {\n       if (!es->predicate)\n \tes->predicate = edge_predicate_pool.allocate ();\n@@ -800,9 +700,9 @@ edge_set_predicate (struct cgraph_edge *e, struct predicate *predicate)\n /* Set predicate for hint *P.  */\n \n static void\n-set_hint_predicate (struct predicate **p, struct predicate new_predicate)\n+set_hint_predicate (predicate **p, predicate new_predicate)\n {\n-  if (false_predicate_p (&new_predicate) || true_predicate_p (&new_predicate))\n+  if (new_predicate == false || new_predicate == true)\n     {\n       if (*p)\n \tedge_predicate_pool.remove (*p);\n@@ -842,8 +742,8 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t\t\t\t    clause_t *ret_clause,\n \t\t\t\t    clause_t *ret_nonspec_clause)\n {\n-  clause_t clause = inline_p ? 0 : 1 << predicate_not_inlined_condition;\n-  clause_t nonspec_clause = 1 << predicate_not_inlined_condition;\n+  clause_t clause = inline_p ? 0 : 1 << predicate::not_inlined_condition;\n+  clause_t nonspec_clause = 1 << predicate::not_inlined_condition;\n   struct inline_summary *info = inline_summaries->get (node);\n   int i;\n   struct condition *c;\n@@ -861,8 +761,8 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t\t\t   || (known_vals.length () == known_aggs.length ()));\n       if (c->operand_num >= (int) known_vals.length ())\n \t{\n-\t  clause |= 1 << (i + predicate_first_dynamic_condition);\n-\t  nonspec_clause |= 1 << (i + predicate_first_dynamic_condition);\n+\t  clause |= 1 << (i + predicate::first_dynamic_condition);\n+\t  nonspec_clause |= 1 << (i + predicate::first_dynamic_condition);\n \t  continue;\n \t}\n \n@@ -893,25 +793,25 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \n       if (!val)\n \t{\n-\t  clause |= 1 << (i + predicate_first_dynamic_condition);\n-\t  nonspec_clause |= 1 << (i + predicate_first_dynamic_condition);\n+\t  clause |= 1 << (i + predicate::first_dynamic_condition);\n+\t  nonspec_clause |= 1 << (i + predicate::first_dynamic_condition);\n \t  continue;\n \t}\n       if (c->code == CHANGED)\n \t{\n-\t  nonspec_clause |= 1 << (i + predicate_first_dynamic_condition);\n+\t  nonspec_clause |= 1 << (i + predicate::first_dynamic_condition);\n \t  continue;\n \t}\n \n       if (tree_to_shwi (TYPE_SIZE (TREE_TYPE (val))) != c->size)\n \t{\n-\t  clause |= 1 << (i + predicate_first_dynamic_condition);\n-\t  nonspec_clause |= 1 << (i + predicate_first_dynamic_condition);\n+\t  clause |= 1 << (i + predicate::first_dynamic_condition);\n+\t  nonspec_clause |= 1 << (i + predicate::first_dynamic_condition);\n \t  continue;\n \t}\n       if (c->code == IS_NOT_CONSTANT)\n \t{\n-\t  nonspec_clause |= 1 << (i + predicate_first_dynamic_condition);\n+\t  nonspec_clause |= 1 << (i + predicate::first_dynamic_condition);\n \t  continue;\n \t}\n \n@@ -923,8 +823,8 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n       if (res && integer_zerop (res))\n \tcontinue;\n \n-      clause |= 1 << (i + predicate_first_dynamic_condition);\n-      nonspec_clause |= 1 << (i + predicate_first_dynamic_condition);\n+      clause |= 1 << (i + predicate::first_dynamic_condition);\n+      nonspec_clause |= 1 << (i + predicate::first_dynamic_condition);\n     }\n   *ret_clause = clause;\n   if (ret_nonspec_clause)\n@@ -948,7 +848,7 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n   vec<ipa_agg_jump_function_p> known_aggs = vNULL;\n \n   if (clause_ptr)\n-    *clause_ptr = inline_p ? 0 : 1 << predicate_not_inlined_condition;\n+    *clause_ptr = inline_p ? 0 : 1 << predicate::not_inlined_condition;\n   if (known_vals_ptr)\n     known_vals_ptr->create (0);\n   if (known_contexts_ptr)\n@@ -1125,27 +1025,21 @@ inline_summary_t::remove (cgraph_node *node, inline_summary *info)\n   reset_inline_summary (node, info);\n }\n \n-/* Remap predicate P of former function to be predicate of duplicated function.\n+/* Remap predicate THIS of former function to be predicate of duplicated function.\n    POSSIBLE_TRUTHS is clause of possible truths in the duplicated node,\n    INFO is inline summary of the duplicated node.  */\n \n-static struct predicate\n-remap_predicate_after_duplication (struct predicate *p,\n-\t\t\t\t   clause_t possible_truths,\n-\t\t\t\t   struct inline_summary *info)\n+predicate\n+predicate::remap_after_duplication (clause_t possible_truths)\n {\n-  struct predicate new_predicate = true_predicate ();\n   int j;\n-  for (j = 0; p->clause[j]; j++)\n-    if (!(possible_truths & p->clause[j]))\n-      {\n-\tnew_predicate = false_predicate ();\n-\tbreak;\n-      }\n+  predicate out = true;\n+  for (j = 0; m_clause[j]; j++)\n+    if (!(possible_truths & m_clause[j]))\n+      return false;\n     else\n-      add_clause (info->conds, &new_predicate,\n-\t\t  possible_truths & p->clause[j]);\n-  return new_predicate;\n+      out.add_clause (NULL, possible_truths & m_clause[j]);\n+  return out;\n }\n \n /* Same as remap_predicate_after_duplication but handle hint predicate *P.\n@@ -1154,17 +1048,15 @@ remap_predicate_after_duplication (struct predicate *p,\n  */\n \n static void\n-remap_hint_predicate_after_duplication (struct predicate **p,\n-\t\t\t\t\tclause_t possible_truths,\n-\t\t\t\t\tstruct inline_summary *info)\n+remap_hint_predicate_after_duplication (predicate **p,\n+\t\t\t\t\tclause_t possible_truths)\n {\n-  struct predicate new_predicate;\n+  predicate new_predicate;\n \n   if (!*p)\n     return;\n \n-  new_predicate = remap_predicate_after_duplication (*p,\n-\t\t\t\t\t\t     possible_truths, info);\n+  new_predicate = (*p)->remap_after_duplication (possible_truths);\n   /* We do not want to free previous predicate; it is used by node origin.  */\n   *p = NULL;\n   set_hint_predicate (p, new_predicate);\n@@ -1195,7 +1087,7 @@ inline_summary_t::duplicate (cgraph_node *src,\n       int count = ipa_get_param_count (parms_info);\n       int i, j;\n       clause_t possible_truths;\n-      struct predicate true_pred = true_predicate ();\n+      predicate true_pred = true;\n       size_time_entry *e;\n       int optimized_out_size = 0;\n       bool inlined_to_p = false;\n@@ -1236,17 +1128,13 @@ inline_summary_t::duplicate (cgraph_node *src,\n          to be true.  */\n       for (i = 0; vec_safe_iterate (entry, i, &e); i++)\n \t{\n-\t  struct predicate new_exec_pred;\n-\t  struct predicate new_nonconst_pred;\n-\t  new_exec_pred = remap_predicate_after_duplication (&e->exec_predicate,\n-\t\t\t\t\t\t\t     possible_truths,\n-\t\t\t\t\t\t\t     info);\n-\t  new_nonconst_pred\n-\t\t = remap_predicate_after_duplication (&e->nonconst_predicate,\n-\t\t\t\t\t\t     possible_truths,\n-\t\t\t\t\t\t     info);\n-\t  if (false_predicate_p (&new_exec_pred)\n-\t      || false_predicate_p (&new_nonconst_pred))\n+\t  predicate new_exec_pred;\n+\t  predicate new_nonconst_pred;\n+\t  new_exec_pred = e->exec_predicate.remap_after_duplication\n+\t\t\t\t (possible_truths);\n+\t  new_nonconst_pred = e->nonconst_predicate.remap_after_duplication\n+\t\t  \t\t (possible_truths);\n+\t  if (new_exec_pred == false || new_nonconst_pred == false)\n \t    optimized_out_size += e->size;\n \t  else\n \t    account_size_time (info, e->size, e->time, &new_exec_pred,\n@@ -1257,19 +1145,17 @@ inline_summary_t::duplicate (cgraph_node *src,\n          Also copy constantness arrays.   */\n       for (edge = dst->callees; edge; edge = next)\n \t{\n-\t  struct predicate new_predicate;\n+\t  predicate new_predicate;\n \t  struct inline_edge_summary *es = inline_edge_summary (edge);\n \t  next = edge->next_callee;\n \n \t  if (!edge->inline_failed)\n \t    inlined_to_p = true;\n \t  if (!es->predicate)\n \t    continue;\n-\t  new_predicate = remap_predicate_after_duplication (es->predicate,\n-\t\t\t\t\t\t\t     possible_truths,\n-\t\t\t\t\t\t\t     info);\n-\t  if (false_predicate_p (&new_predicate)\n-\t      && !false_predicate_p (es->predicate))\n+\t  new_predicate = es->predicate->remap_after_duplication\n+\t    (possible_truths);\n+\t  if (new_predicate == false && *es->predicate != false)\n \t    optimized_out_size += es->call_stmt_size * INLINE_SIZE_SCALE;\n \t  edge_set_predicate (edge, &new_predicate);\n \t}\n@@ -1278,27 +1164,25 @@ inline_summary_t::duplicate (cgraph_node *src,\n          Also copy constantness arrays.   */\n       for (edge = dst->indirect_calls; edge; edge = next)\n \t{\n-\t  struct predicate new_predicate;\n+\t  predicate new_predicate;\n \t  struct inline_edge_summary *es = inline_edge_summary (edge);\n \t  next = edge->next_callee;\n \n \t  gcc_checking_assert (edge->inline_failed);\n \t  if (!es->predicate)\n \t    continue;\n-\t  new_predicate = remap_predicate_after_duplication (es->predicate,\n-\t\t\t\t\t\t\t     possible_truths,\n-\t\t\t\t\t\t\t     info);\n-\t  if (false_predicate_p (&new_predicate)\n-\t      && !false_predicate_p (es->predicate))\n+\t  new_predicate = es->predicate->remap_after_duplication\n+\t\t\t\t (possible_truths);\n+\t  if (new_predicate == false && *es->predicate != false)\n \t    optimized_out_size += es->call_stmt_size * INLINE_SIZE_SCALE;\n \t  edge_set_predicate (edge, &new_predicate);\n \t}\n       remap_hint_predicate_after_duplication (&info->loop_iterations,\n-\t\t\t\t\t      possible_truths, info);\n+\t\t\t\t\t      possible_truths);\n       remap_hint_predicate_after_duplication (&info->loop_stride,\n-\t\t\t\t\t      possible_truths, info);\n+\t\t\t\t\t      possible_truths);\n       remap_hint_predicate_after_duplication (&info->array_index,\n-\t\t\t\t\t      possible_truths, info);\n+\t\t\t\t\t      possible_truths);\n \n       /* If inliner or someone after inliner will ever start producing\n          non-trivial clones, we will get trouble with lack of information\n@@ -1418,7 +1302,7 @@ dump_inline_edge_summary (FILE *f, int indent, struct cgraph_node *node,\n       if (es->predicate)\n \t{\n \t  fprintf (f, \" predicate: \");\n-\t  dump_predicate (f, info->conds, es->predicate);\n+\t  es->predicate->dump (f, info->conds);\n \t}\n       else\n \tfprintf (f, \"\\n\");\n@@ -1456,7 +1340,7 @@ dump_inline_edge_summary (FILE *f, int indent, struct cgraph_node *node,\n       if (es->predicate)\n \t{\n \t  fprintf (f, \"predicate: \");\n-\t  dump_predicate (f, info->conds, es->predicate);\n+\t  es->predicate->dump (f, info->conds);\n \t}\n       else\n \tfprintf (f, \"\\n\");\n@@ -1499,33 +1383,32 @@ dump_inline_summary (FILE *f, struct cgraph_node *node)\n \t  fprintf (f, \"    size:%f, time:%f\",\n \t\t   (double) e->size / INLINE_SIZE_SCALE,\n \t\t   e->time.to_double ());\n-\t  if (!true_predicate_p (&e->exec_predicate))\n+\t  if (e->exec_predicate != true)\n \t    {\n \t      fprintf (f, \",  executed if:\");\n-\t      dump_predicate (f, s->conds, &e->exec_predicate, 0);\n+\t      e->exec_predicate.dump (f, s->conds, 0);\n \t    }\n-\t  if (!predicates_equal_p (&e->exec_predicate,\n-\t\t\t\t   &e->nonconst_predicate))\n+\t  if (e->exec_predicate != e->nonconst_predicate)\n \t    {\n \t      fprintf (f, \",  nonconst if:\");\n-\t      dump_predicate (f, s->conds, &e->nonconst_predicate, 0);\n+\t      e->nonconst_predicate.dump (f, s->conds, 0);\n \t    }\n \t  fprintf (f, \"\\n\");\n \t}\n       if (s->loop_iterations)\n \t{\n \t  fprintf (f, \"  loop iterations:\");\n-\t  dump_predicate (f, s->conds, s->loop_iterations);\n+\t  s->loop_iterations->dump (f, s->conds);\n \t}\n       if (s->loop_stride)\n \t{\n \t  fprintf (f, \"  loop stride:\");\n-\t  dump_predicate (f, s->conds, s->loop_stride);\n+\t  s->loop_stride->dump (f, s->conds);\n \t}\n       if (s->array_index)\n \t{\n \t  fprintf (f, \"  array index:\");\n-\t  dump_predicate (f, s->conds, s->array_index);\n+\t  s->array_index->dump (f, s->conds);\n \t}\n       fprintf (f, \"  calls:\\n\");\n       dump_inline_edge_summary (f, 4, node, s);\n@@ -1859,12 +1742,12 @@ set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \t     unordered one.  Be sure it is not confused with NON_CONSTANT.  */\n \t  if (this_code != ERROR_MARK)\n \t    {\n-\t      struct predicate p\n+\t      predicate p\n \t\t= add_condition (summary, index, size, &aggpos, this_code,\n \t\t\t\t unshare_expr_without_location\n \t\t\t\t (gimple_cond_rhs (last)));\n \t      e->aux = edge_predicate_pool.allocate ();\n-\t      *(struct predicate *) e->aux = p;\n+\t      *(predicate *) e->aux = p;\n \t    }\n \t}\n     }\n@@ -1894,10 +1777,10 @@ set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n     return;\n   FOR_EACH_EDGE (e, ei, bb->succs) if (e->flags & EDGE_FALSE_VALUE)\n     {\n-      struct predicate p = add_condition (summary, index, size, &aggpos,\n+      predicate p = add_condition (summary, index, size, &aggpos,\n \t\t\t\t\t  IS_NOT_CONSTANT, NULL_TREE);\n       e->aux = edge_predicate_pool.allocate ();\n-      *(struct predicate *) e->aux = p;\n+      *(predicate *) e->aux = p;\n     }\n }\n \n@@ -1931,14 +1814,14 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n       e->aux = edge_predicate_pool.allocate ();\n-      *(struct predicate *) e->aux = false_predicate ();\n+      *(predicate *) e->aux = false;\n     }\n   n = gimple_switch_num_labels (last);\n   for (case_idx = 0; case_idx < n; ++case_idx)\n     {\n       tree cl = gimple_switch_label (last, case_idx);\n       tree min, max;\n-      struct predicate p;\n+      predicate p;\n \n       e = find_edge (bb, label_to_block (CASE_LABEL (cl)));\n       min = CASE_LOW (cl);\n@@ -1948,21 +1831,21 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n          of cases is met, but it is bit hard to do not having negations\n          of conditionals handy.  */\n       if (!min && !max)\n-\tp = true_predicate ();\n+\tp = true;\n       else if (!max)\n \tp = add_condition (summary, index, size, &aggpos, EQ_EXPR,\n \t\t\t   unshare_expr_without_location (min));\n       else\n \t{\n-\t  struct predicate p1, p2;\n+\t  predicate p1, p2;\n \t  p1 = add_condition (summary, index, size, &aggpos, GE_EXPR,\n \t\t\t      unshare_expr_without_location (min));\n \t  p2 = add_condition (summary, index, size, &aggpos, LE_EXPR,\n \t\t\t      unshare_expr_without_location (max));\n-\t  p = and_predicates (summary->conds, &p1, &p2);\n+\t  p = p1 & p2;\n \t}\n       *(struct predicate *) e->aux\n-\t= or_predicates (summary->conds, &p, (struct predicate *) e->aux);\n+\t= p.or_with (summary->conds, *(struct predicate *) e->aux);\n     }\n }\n \n@@ -1988,8 +1871,7 @@ compute_bb_predicates (struct ipa_func_body_info *fbi,\n   /* Entry block is always executable.  */\n   ENTRY_BLOCK_PTR_FOR_FN (my_function)->aux\n     = edge_predicate_pool.allocate ();\n-  *(struct predicate *) ENTRY_BLOCK_PTR_FOR_FN (my_function)->aux\n-    = true_predicate ();\n+  *(predicate *) ENTRY_BLOCK_PTR_FOR_FN (my_function)->aux = true;\n \n   /* A simple dataflow propagation of predicates forward in the CFG.\n      TODO: work in reverse postorder.  */\n@@ -1998,44 +1880,42 @@ compute_bb_predicates (struct ipa_func_body_info *fbi,\n       done = true;\n       FOR_EACH_BB_FN (bb, my_function)\n \t{\n-\t  struct predicate p = false_predicate ();\n+\t  predicate p = false;\n \t  edge e;\n \t  edge_iterator ei;\n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    {\n \t      if (e->src->aux)\n \t\t{\n-\t\t  struct predicate this_bb_predicate\n-\t\t    = *(struct predicate *) e->src->aux;\n+\t\t  predicate this_bb_predicate\n+\t\t    = *(predicate *) e->src->aux;\n \t\t  if (e->aux)\n-\t\t    this_bb_predicate\n-\t\t      = and_predicates (summary->conds, &this_bb_predicate,\n-\t\t\t\t\t(struct predicate *) e->aux);\n-\t\t  p = or_predicates (summary->conds, &p, &this_bb_predicate);\n-\t\t  if (true_predicate_p (&p))\n+\t\t    this_bb_predicate &= (*(struct predicate *) e->aux);\n+\t\t  p = p.or_with (summary->conds, this_bb_predicate);\n+\t\t  if (p == true)\n \t\t    break;\n \t\t}\n \t    }\n-\t  if (false_predicate_p (&p))\n-\t    gcc_assert (!bb->aux);\n+\t  if (p == false)\n+\t    gcc_checking_assert (!bb->aux);\n \t  else\n \t    {\n \t      if (!bb->aux)\n \t\t{\n \t\t  done = false;\n \t\t  bb->aux = edge_predicate_pool.allocate ();\n-\t\t  *((struct predicate *) bb->aux) = p;\n+\t\t  *((predicate *) bb->aux) = p;\n \t\t}\n-\t      else if (!predicates_equal_p (&p, (struct predicate *) bb->aux))\n+\t      else if (p != *(predicate *) bb->aux)\n \t\t{\n \t\t  /* This OR operation is needed to ensure monotonous data flow\n \t\t     in the case we hit the limit on number of clauses and the\n \t\t     and/or operations above give approximate answers.  */\n-\t\t  p = or_predicates (summary->conds, &p, (struct predicate *)bb->aux);\n-\t          if (!predicates_equal_p (&p, (struct predicate *) bb->aux))\n+\t\t  p = p.or_with (summary->conds, *(predicate *)bb->aux);\n+\t          if (p != *(predicate *) bb->aux)\n \t\t    {\n \t\t      done = false;\n-\t\t      *((struct predicate *) bb->aux) = p;\n+\t\t      *((predicate *) bb->aux) = p;\n \t\t    }\n \t\t}\n \t    }\n@@ -2046,11 +1926,11 @@ compute_bb_predicates (struct ipa_func_body_info *fbi,\n \n /* We keep info about constantness of SSA names.  */\n \n-typedef struct predicate predicate_t;\n+typedef predicate predicate_t;\n /* Return predicate specifying when the STMT might have result that is not\n    a compile time constant.  */\n \n-static struct predicate\n+static predicate\n will_be_nonconstant_expr_predicate (struct ipa_node_params *info,\n \t\t\t\t    struct inline_summary *summary,\n \t\t\t\t    tree expr,\n@@ -2067,63 +1947,65 @@ will_be_nonconstant_expr_predicate (struct ipa_node_params *info,\n   if (parm && (index = ipa_get_param_decl_index (info, parm)) >= 0)\n     return add_condition (summary, index, size, NULL, CHANGED, NULL_TREE);\n   if (is_gimple_min_invariant (expr))\n-    return false_predicate ();\n+    return false;\n   if (TREE_CODE (expr) == SSA_NAME)\n     return nonconstant_names[SSA_NAME_VERSION (expr)];\n   if (BINARY_CLASS_P (expr) || COMPARISON_CLASS_P (expr))\n     {\n-      struct predicate p1 = will_be_nonconstant_expr_predicate\n+      predicate p1 = will_be_nonconstant_expr_predicate\n \t(info, summary, TREE_OPERAND (expr, 0),\n \t nonconstant_names);\n-      struct predicate p2;\n-      if (true_predicate_p (&p1))\n+      if (p1 == true)\n \treturn p1;\n+\n+      predicate p2;\n       p2 = will_be_nonconstant_expr_predicate (info, summary,\n \t\t\t\t\t       TREE_OPERAND (expr, 1),\n \t\t\t\t\t       nonconstant_names);\n-      return or_predicates (summary->conds, &p1, &p2);\n+      return p1.or_with (summary->conds, p2);\n     }\n   else if (TREE_CODE (expr) == COND_EXPR)\n     {\n-      struct predicate p1 = will_be_nonconstant_expr_predicate\n+      predicate p1 = will_be_nonconstant_expr_predicate\n \t(info, summary, TREE_OPERAND (expr, 0),\n \t nonconstant_names);\n-      struct predicate p2;\n-      if (true_predicate_p (&p1))\n+      if (p1 == true)\n \treturn p1;\n+\n+      predicate p2;\n       p2 = will_be_nonconstant_expr_predicate (info, summary,\n \t\t\t\t\t       TREE_OPERAND (expr, 1),\n \t\t\t\t\t       nonconstant_names);\n-      if (true_predicate_p (&p2))\n+      if (p2 == true)\n \treturn p2;\n-      p1 = or_predicates (summary->conds, &p1, &p2);\n+      p1 = p1.or_with (summary->conds, p2);\n       p2 = will_be_nonconstant_expr_predicate (info, summary,\n \t\t\t\t\t       TREE_OPERAND (expr, 2),\n \t\t\t\t\t       nonconstant_names);\n-      return or_predicates (summary->conds, &p1, &p2);\n+      return p2.or_with (summary->conds, p1);\n     }\n   else\n     {\n       debug_tree (expr);\n       gcc_unreachable ();\n     }\n-  return false_predicate ();\n+  return false;\n }\n \n \n /* Return predicate specifying when the STMT might have result that is not\n    a compile time constant.  */\n \n-static struct predicate\n+static predicate\n will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n \t\t\t       struct inline_summary *summary,\n \t\t\t       gimple *stmt,\n \t\t\t       vec<predicate_t> nonconstant_names)\n {\n-  struct predicate p = true_predicate ();\n+  predicate p = true;\n   ssa_op_iter iter;\n   tree use;\n-  struct predicate op_non_const;\n+  predicate op_non_const;\n   bool is_load;\n   int base_index;\n   HOST_WIDE_INT size;\n@@ -2169,7 +2051,7 @@ will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n \treturn p;\n       /* If we know when operand is constant,\n \t we still can say something useful.  */\n-      if (!true_predicate_p (&nonconstant_names[SSA_NAME_VERSION (use)]))\n+      if (nonconstant_names[SSA_NAME_VERSION (use)] != true)\n \tcontinue;\n       return p;\n     }\n@@ -2178,7 +2060,7 @@ will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n     op_non_const =\n       add_condition (summary, base_index, size, &aggpos, CHANGED, NULL);\n   else\n-    op_non_const = false_predicate ();\n+    op_non_const = false;\n   FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n       HOST_WIDE_INT size;\n@@ -2194,7 +2076,7 @@ will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n \t}\n       else\n \tp = nonconstant_names[SSA_NAME_VERSION (use)];\n-      op_non_const = or_predicates (summary->conds, &p, &op_non_const);\n+      op_non_const = p.or_with (summary->conds, op_non_const);\n     }\n   if ((gimple_code (stmt) == GIMPLE_ASSIGN || gimple_code (stmt) == GIMPLE_CALL)\n       && gimple_op (stmt, 0)\n@@ -2345,7 +2227,7 @@ param_change_prob (gimple *stmt, int i)\n static bool\n phi_result_unknown_predicate (struct ipa_node_params *info,\n \t\t\t      inline_summary *summary, basic_block bb,\n-\t\t\t      struct predicate *p,\n+\t\t\t      predicate *p,\n \t\t\t      vec<predicate_t> nonconstant_names)\n {\n   edge e;\n@@ -2355,7 +2237,7 @@ phi_result_unknown_predicate (struct ipa_node_params *info,\n \n   if (single_pred_p (bb))\n     {\n-      *p = false_predicate ();\n+      *p = false;\n       return true;\n     }\n \n@@ -2391,7 +2273,7 @@ phi_result_unknown_predicate (struct ipa_node_params *info,\n   *p = will_be_nonconstant_expr_predicate (info, summary,\n \t\t\t\t\t   gimple_cond_lhs (stmt),\n \t\t\t\t\t   nonconstant_names);\n-  if (true_predicate_p (p))\n+  if (*p == true)\n     return false;\n   else\n     return true;\n@@ -2404,7 +2286,7 @@ phi_result_unknown_predicate (struct ipa_node_params *info,\n \n static void\n predicate_for_phi_result (struct inline_summary *summary, gphi *phi,\n-\t\t\t  struct predicate *p,\n+\t\t\t  predicate *p,\n \t\t\t  vec<predicate_t> nonconstant_names)\n {\n   unsigned i;\n@@ -2415,35 +2297,35 @@ predicate_for_phi_result (struct inline_summary *summary, gphi *phi,\n       if (!is_gimple_min_invariant (arg))\n \t{\n \t  gcc_assert (TREE_CODE (arg) == SSA_NAME);\n-\t  *p = or_predicates (summary->conds, p,\n-\t\t\t      &nonconstant_names[SSA_NAME_VERSION (arg)]);\n-\t  if (true_predicate_p (p))\n+\t  *p = p->or_with (summary->conds,\n+\t\t\t   nonconstant_names[SSA_NAME_VERSION (arg)]);\n+\t  if (*p == true)\n \t    return;\n \t}\n     }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"\\t\\tphi predicate: \");\n-      dump_predicate (dump_file, summary->conds, p);\n+      p->dump (dump_file, summary->conds);\n     }\n   nonconstant_names[SSA_NAME_VERSION (gimple_phi_result (phi))] = *p;\n }\n \n /* Return predicate specifying when array index in access OP becomes non-constant.  */\n \n-static struct predicate\n+static predicate\n array_index_predicate (inline_summary *info,\n \t\t       vec< predicate_t> nonconstant_names, tree op)\n {\n-  struct predicate p = false_predicate ();\n+  predicate p = false;\n   while (handled_component_p (op))\n     {\n       if (TREE_CODE (op) == ARRAY_REF || TREE_CODE (op) == ARRAY_RANGE_REF)\n \t{\n \t  if (TREE_CODE (TREE_OPERAND (op, 1)) == SSA_NAME)\n-\t    p = or_predicates (info->conds, &p,\n-\t\t\t       &nonconstant_names[SSA_NAME_VERSION\n+\t    p = p.or_with (info->conds, \n+\t\t\t   nonconstant_names[SSA_NAME_VERSION\n \t\t\t\t\t\t  (TREE_OPERAND (op, 1))]);\n \t}\n       op = TREE_OPERAND (op, 0);\n@@ -2602,12 +2484,12 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   struct function *my_function = DECL_STRUCT_FUNCTION (node->decl);\n   int freq;\n   struct inline_summary *info = inline_summaries->get (node);\n-  struct predicate bb_predicate;\n+  predicate bb_predicate;\n   struct ipa_func_body_info fbi;\n   vec<predicate_t> nonconstant_names = vNULL;\n   int nblocks, n;\n   int *order;\n-  predicate array_index = true_predicate ();\n+  predicate array_index = true;\n   gimple *fix_builtin_expect_stmt;\n \n   gcc_assert (my_function && my_function->cfg);\n@@ -2652,10 +2534,10 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \n   /* When we run into maximal number of entries, we assign everything to the\n      constant truth case.  Be sure to have it in list. */\n-  bb_predicate = true_predicate ();\n+  bb_predicate = true;\n   account_size_time (info, 0, 0, &bb_predicate, &bb_predicate);\n \n-  bb_predicate = not_inlined_predicate ();\n+  bb_predicate = predicate::not_inlined ();\n   account_size_time (info, 2 * INLINE_SIZE_SCALE, 0, &bb_predicate,\n \t\t     &bb_predicate);\n \n@@ -2680,22 +2562,22 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n       if (fbi.info)\n \t{\n \t  if (bb->aux)\n-\t    bb_predicate = *(struct predicate *) bb->aux;\n+\t    bb_predicate = *(predicate *) bb->aux;\n \t  else\n-\t    bb_predicate = false_predicate ();\n+\t    bb_predicate = false;\n \t}\n       else\n-\tbb_predicate = true_predicate ();\n+\tbb_predicate = true;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"\\n BB %i predicate:\", bb->index);\n-\t  dump_predicate (dump_file, info->conds, &bb_predicate);\n+\t  bb_predicate.dump (dump_file, info->conds);\n \t}\n \n       if (fbi.info && nonconstant_names.exists ())\n \t{\n-\t  struct predicate phi_predicate;\n+\t  predicate phi_predicate;\n \t  bool first_phi = true;\n \n \t  for (gphi_iterator bsi = gsi_start_phis (bb); !gsi_end_p (bsi);\n@@ -2726,7 +2608,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t  int this_size = estimate_num_insns (stmt, &eni_size_weights);\n \t  int this_time = estimate_num_insns (stmt, &eni_time_weights);\n \t  int prob;\n-\t  struct predicate will_be_nonconstant;\n+\t  predicate will_be_nonconstant;\n \n           /* This relation stmt should be folded after we remove\n              buildin_expect call. Adjust the cost here.  */\n@@ -2747,25 +2629,21 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \n \t  if (gimple_assign_load_p (stmt) && nonconstant_names.exists ())\n \t    {\n-\t      struct predicate this_array_index;\n+\t      predicate this_array_index;\n \t      this_array_index =\n \t\tarray_index_predicate (info, nonconstant_names,\n \t\t\t\t       gimple_assign_rhs1 (stmt));\n-\t      if (!false_predicate_p (&this_array_index))\n-\t\tarray_index =\n-\t\t  and_predicates (info->conds, &array_index,\n-\t\t\t\t  &this_array_index);\n+\t      if (this_array_index != false)\n+\t\tarray_index &= this_array_index;\n \t    }\n \t  if (gimple_store_p (stmt) && nonconstant_names.exists ())\n \t    {\n-\t      struct predicate this_array_index;\n+\t      predicate this_array_index;\n \t      this_array_index =\n \t\tarray_index_predicate (info, nonconstant_names,\n \t\t\t\t       gimple_get_lhs (stmt));\n-\t      if (!false_predicate_p (&this_array_index))\n-\t\tarray_index =\n-\t\t  and_predicates (info->conds, &array_index,\n-\t\t\t\t  &this_array_index);\n+\t      if (this_array_index != false)\n+\t\tarray_index &= this_array_index;\n \t    }\n \n \n@@ -2783,7 +2661,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\t  && gimple_call_lhs (stmt)\n \t\t  && TREE_CODE (gimple_call_lhs (stmt)) == SSA_NAME)\n \t\t{\n-\t\t  struct predicate false_p = false_predicate ();\n+\t\t  predicate false_p = false;\n \t\t  nonconstant_names[SSA_NAME_VERSION (gimple_call_lhs (stmt))]\n \t\t    = false_p;\n \t\t}\n@@ -2816,7 +2694,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t      = will_be_nonconstant_predicate (&fbi, info,\n \t\t\t\t\t       stmt, nonconstant_names);\n \t  else\n-\t    will_be_nonconstant = true_predicate ();\n+\t    will_be_nonconstant = true;\n \t  if (this_time || this_size)\n \t    {\n \t      this_time *= freq;\n@@ -2828,15 +2706,13 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t      if (prob == 2 && dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"\\t\\tWill be eliminated by inlining\\n\");\n \n-\t      struct predicate p = and_predicates (info->conds, &bb_predicate,\n-\t\t\t\t\t\t   &will_be_nonconstant);\n+\t      struct predicate p = bb_predicate & will_be_nonconstant;\n \n \t      /* We can ignore statement when we proved it is never going\n \t\t to happen, but we can not do that for call statements\n \t\t because edges are accounted specially.  */\n \n-\t      if (!false_predicate_p (is_gimple_call (stmt)\n-\t\t\t\t      ? &bb_predicate : &p))\n+\t      if (*(is_gimple_call (stmt) ? &bb_predicate : &p) != false)\n \t\t{\n \t\t  time += this_time;\n \t\t  size += this_size;\n@@ -2849,8 +2725,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\t{\n \t\t  if (prob)\n \t\t    {\n-\t\t      struct predicate ip = not_inlined_predicate ();\n-\t\t      ip = and_predicates (info->conds, &ip, &bb_predicate);\n+\t\t      predicate ip = bb_predicate & predicate::not_inlined ();\n \t\t      account_size_time (info, this_size * prob,\n \t\t\t\t\t (sreal)(this_time * prob)\n \t\t\t\t\t / (CGRAPH_FREQ_BASE * 2), &ip,\n@@ -2883,8 +2758,8 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   if (nonconstant_names.exists () && !early)\n     {\n       struct loop *loop;\n-      predicate loop_iterations = true_predicate ();\n-      predicate loop_stride = true_predicate ();\n+      predicate loop_iterations = true;\n+      predicate loop_stride = true;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tflow_loops_dump (dump_file, NULL, 0);\n@@ -2895,7 +2770,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t  edge ex;\n \t  unsigned int j;\n \t  struct tree_niter_desc niter_desc;\n-\t  bb_predicate = *(struct predicate *) loop->header->aux;\n+\t  bb_predicate = *(predicate *) loop->header->aux;\n \n \t  exits = get_loop_exit_edges (loop);\n \t  FOR_EACH_VEC_ELT (exits, j, ex)\n@@ -2906,17 +2781,13 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\t= will_be_nonconstant_expr_predicate (fbi.info, info,\n \t\t\t\t\t\t      niter_desc.niter,\n \t\t\t\t\t\t      nonconstant_names);\n-\t      if (!true_predicate_p (&will_be_nonconstant))\n-\t\twill_be_nonconstant = and_predicates (info->conds,\n-\t\t\t\t\t\t      &bb_predicate,\n-\t\t\t\t\t\t      &will_be_nonconstant);\n-\t      if (!true_predicate_p (&will_be_nonconstant)\n-\t\t  && !false_predicate_p (&will_be_nonconstant))\n+\t      if (will_be_nonconstant != true)\n+\t\twill_be_nonconstant = bb_predicate & will_be_nonconstant;\n+\t      if (will_be_nonconstant != true\n+\t\t  && will_be_nonconstant != false)\n \t\t/* This is slightly inprecise.  We may want to represent each\n \t\t   loop with independent predicate.  */\n-\t\tloop_iterations =\n-\t\t  and_predicates (info->conds, &loop_iterations,\n-\t\t\t\t  &will_be_nonconstant);\n+\t\tloop_iterations &= will_be_nonconstant;\n \t    }\n \t  exits.release ();\n \t}\n@@ -2931,7 +2802,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t  for (unsigned i = 0; i < loop->num_nodes; i++)\n \t    {\n \t      gimple_stmt_iterator gsi;\n-\t      bb_predicate = *(struct predicate *) body[i]->aux;\n+\t      bb_predicate = *(predicate *) body[i]->aux;\n \t      for (gsi = gsi_start_bb (body[i]); !gsi_end_p (gsi);\n \t\t   gsi_next (&gsi))\n \t\t{\n@@ -2955,16 +2826,13 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\t    = will_be_nonconstant_expr_predicate (fbi.info, info,\n \t\t\t\t\t\t\t  iv.step,\n \t\t\t\t\t\t\t  nonconstant_names);\n-\t\t  if (!true_predicate_p (&will_be_nonconstant))\n-\t\t    will_be_nonconstant\n-\t\t      = and_predicates (info->conds, &bb_predicate,\n-\t\t\t\t\t&will_be_nonconstant);\n-\t\t  if (!true_predicate_p (&will_be_nonconstant)\n-\t\t      && !false_predicate_p (&will_be_nonconstant))\n+\t\t  if (will_be_nonconstant != true)\n+\t\t    will_be_nonconstant = bb_predicate & will_be_nonconstant;\n+\t\t  if (will_be_nonconstant != true\n+\t\t      && will_be_nonconstant != false)\n \t\t    /* This is slightly inprecise.  We may want to represent\n \t\t       each loop with independent predicate.  */\n-\t\t    loop_stride = and_predicates (info->conds, &loop_stride,\n-\t\t\t\t\t\t  &will_be_nonconstant);\n+\t\t    loop_stride = loop_stride & will_be_nonconstant;\n \t\t}\n \t    }\n \t  free (body);\n@@ -2994,7 +2862,6 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   inline_summaries->get (node)->self_size = size;\n   nonconstant_names.release ();\n   ipa_release_body_info (&fbi);\n-  inline_update_overall_summary (node);\n   if (opt_for_fn (node->decl, optimize))\n     {\n       if (!early)\n@@ -3038,14 +2905,14 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n   if (node->thunk.thunk_p)\n     {\n       struct inline_edge_summary *es = inline_edge_summary (node->callees);\n-      struct predicate t = true_predicate ();\n+      predicate t = true;\n \n       node->local.can_change_signature = false;\n       es->call_stmt_size = eni_size_weights.call_cost;\n       es->call_stmt_time = eni_time_weights.call_cost;\n       account_size_time (info, INLINE_SIZE_SCALE * 2,\n \t\t\t 2, &t, &t);\n-      t = not_inlined_predicate ();\n+      t = predicate::not_inlined ();\n       account_size_time (info, 2 * INLINE_SIZE_SCALE, 0, &t, &t);\n       inline_update_overall_summary (node);\n       info->self_size = info->size;\n@@ -3287,7 +3154,7 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n \t  continue;\n \t}\n       if (!es->predicate\n-\t  || evaluate_predicate (es->predicate, possible_truths))\n+\t  || es->predicate->evaluate (possible_truths))\n \t{\n \t  if (e->inline_failed)\n \t    {\n@@ -3314,7 +3181,7 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n \n       struct inline_edge_summary *es = inline_edge_summary (e);\n       if (!es->predicate\n-\t  || evaluate_predicate (es->predicate, possible_truths))\n+\t  || es->predicate->evaluate (possible_truths))\n \testimate_edge_size_and_time (e, size,\n \t\t\t\t     es->predicate ? NULL : min_size,\n \t\t\t\t     time, REG_BR_PROB_BASE,\n@@ -3362,8 +3229,8 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t       \"   Known to be false: \", node->name (),\n \t       node->order);\n \n-      for (i = predicate_not_inlined_condition;\n-\t   i < (predicate_first_dynamic_condition\n+      for (i = predicate::not_inlined_condition;\n+\t   i < (predicate::first_dynamic_condition\n \t\t+ (int) vec_safe_length (info->conds)); i++)\n \tif (!(possible_truths & (1 << i)))\n \t  {\n@@ -3380,10 +3247,8 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \n   for (i = 0; vec_safe_iterate (info->entry, i, &e); i++)\n     {\n-      bool nonconst = evaluate_predicate (&e->nonconst_predicate,\n-\t\t\t\t\t  possible_truths);\n-      bool exec = evaluate_predicate (&e->exec_predicate,\n-\t\t\t\t      nonspec_possible_truths);\n+      bool nonconst = e->nonconst_predicate.evaluate (possible_truths);\n+      bool exec = e->exec_predicate.evaluate (nonspec_possible_truths);\n       gcc_assert (!nonconst || exec);\n       if (exec)\n         {\n@@ -3408,9 +3273,8 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t    }\n \t  else\n \t    {\n-\t      int prob = predicate_probability (info->conds,\n-\t\t\t\t\t        &e->nonconst_predicate,\n-\t\t\t\t\t        possible_truths,\n+\t      int prob = e->nonconst_predicate.probability \n+\t\t\t\t\t       (info->conds, possible_truths,\n \t\t\t\t\t        inline_param_summary);\n \t      gcc_checking_assert (prob >= 0);\n \t      gcc_checking_assert (prob <= REG_BR_PROB_BASE);\n@@ -3419,8 +3283,8 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t  gcc_checking_assert (time >= 0);\n         }\n      }\n-  gcc_checking_assert (true_predicate_p (&(*info->entry)[0].exec_predicate));\n-  gcc_checking_assert (true_predicate_p (&(*info->entry)[0].nonconst_predicate));\n+  gcc_checking_assert ((*info->entry)[0].exec_predicate == true);\n+  gcc_checking_assert ((*info->entry)[0].nonconst_predicate == true);\n   min_size = (*info->entry)[0].size;\n   gcc_checking_assert (size >= 0);\n   gcc_checking_assert (time >= 0);\n@@ -3435,13 +3299,13 @@ estimate_node_size_and_time (struct cgraph_node *node,\n     time = nonspecialized_time;\n \n   if (info->loop_iterations\n-      && !evaluate_predicate (info->loop_iterations, possible_truths))\n+      && !info->loop_iterations->evaluate (possible_truths))\n     hints |= INLINE_HINT_loop_iterations;\n   if (info->loop_stride\n-      && !evaluate_predicate (info->loop_stride, possible_truths))\n+      && !info->loop_stride->evaluate (possible_truths))\n     hints |= INLINE_HINT_loop_stride;\n   if (info->array_index\n-      && !evaluate_predicate (info->array_index, possible_truths))\n+      && !info->array_index->evaluate (possible_truths))\n     hints |= INLINE_HINT_array_index;\n   if (info->scc_no)\n     hints |= INLINE_HINT_in_scc;\n@@ -3494,7 +3358,7 @@ estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n }\n \n /* Translate all conditions from callee representation into caller\n-   representation and symbolically evaluate predicate P into new predicate.\n+   representation and symbolically evaluate predicate THIS into new predicate.\n \n    INFO is inline_summary of function we are adding predicate into, CALLEE_INFO\n    is summary of function predicate P is from. OPERAND_MAP is array giving\n@@ -3506,42 +3370,42 @@ estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n    because they might not be preserved (and should be considered offset zero\n    for other purposes).  */\n \n-static struct predicate\n-remap_predicate (struct inline_summary *info,\n-\t\t struct inline_summary *callee_info,\n-\t\t struct predicate *p,\n-\t\t vec<int> operand_map,\n-\t\t vec<int> offset_map,\n-\t\t clause_t possible_truths, struct predicate *toplev_predicate)\n+predicate\n+predicate::remap_after_inlining (struct inline_summary *info,\n+\t\t\t\t struct inline_summary *callee_info,\n+\t\t\t\t vec<int> operand_map,\n+\t\t\t\t vec<int> offset_map,\n+\t\t\t\t clause_t possible_truths,\n+\t\t\t\t const predicate &toplev_predicate)\n {\n   int i;\n-  struct predicate out = true_predicate ();\n+  predicate out = true;\n \n   /* True predicate is easy.  */\n-  if (true_predicate_p (p))\n-    return *toplev_predicate;\n-  for (i = 0; p->clause[i]; i++)\n+  if (*this == true)\n+    return toplev_predicate;\n+  for (i = 0; m_clause[i]; i++)\n     {\n-      clause_t clause = p->clause[i];\n+      clause_t clause = m_clause[i];\n       int cond;\n-      struct predicate clause_predicate = false_predicate ();\n+      predicate clause_predicate = false;\n \n-      gcc_assert (i < MAX_CLAUSES);\n+      gcc_assert (i < max_clauses);\n \n       for (cond = 0; cond < NUM_CONDITIONS; cond++)\n \t/* Do we have condition we can't disprove?   */\n \tif (clause & possible_truths & (1 << cond))\n \t  {\n-\t    struct predicate cond_predicate;\n+\t    predicate cond_predicate;\n \t    /* Work out if the condition can translate to predicate in the\n \t       inlined function.  */\n-\t    if (cond >= predicate_first_dynamic_condition)\n+\t    if (cond >= predicate::first_dynamic_condition)\n \t      {\n \t\tstruct condition *c;\n \n \t\tc = &(*callee_info->conds)[cond\n \t\t\t\t\t   -\n-\t\t\t\t\t   predicate_first_dynamic_condition];\n+\t\t\t\t\t   predicate::first_dynamic_condition];\n \t\t/* See if we can remap condition operand to caller's operand.\n \t\t   Otherwise give up.  */\n \t\tif (!operand_map.exists ()\n@@ -3554,7 +3418,7 @@ remap_predicate (struct inline_summary *info,\n \t\t\t&& offset_map[c->operand_num] > 0)\n \t\t    || (c->agg_contents && c->by_ref\n \t\t\t&& offset_map[c->operand_num] < 0))\n-\t\t  cond_predicate = true_predicate ();\n+\t\t  cond_predicate = true;\n \t\telse\n \t\t  {\n \t\t    struct agg_position_info ap;\n@@ -3578,16 +3442,14 @@ remap_predicate (struct inline_summary *info,\n \t    /* Fixed conditions remains same, construct single\n \t       condition predicate.  */\n \t    else\n-\t      {\n-\t\tcond_predicate.clause[0] = 1 << cond;\n-\t\tcond_predicate.clause[1] = 0;\n-\t      }\n-\t    clause_predicate = or_predicates (info->conds, &clause_predicate,\n-\t\t\t\t\t      &cond_predicate);\n+\t      cond_predicate = predicate::predicate_testing_cond (cond);\n+\t    clause_predicate = clause_predicate.or_with (info->conds,\n+\t\t\t\t\t                 cond_predicate);\n \t  }\n-      out = and_predicates (info->conds, &out, &clause_predicate);\n+      out &= clause_predicate;\n     }\n-  return and_predicates (info->conds, &out, toplev_predicate);\n+  out &= toplev_predicate;\n+  return out;\n }\n \n \n@@ -3678,13 +3540,13 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n \t\t      vec<int> operand_map,\n \t\t      vec<int> offset_map,\n \t\t      clause_t possible_truths,\n-\t\t      struct predicate *toplev_predicate)\n+\t\t      predicate *toplev_predicate)\n {\n   struct cgraph_edge *e, *next;\n   for (e = node->callees; e; e = next)\n     {\n       struct inline_edge_summary *es = inline_edge_summary (e);\n-      struct predicate p;\n+      predicate p;\n       next = e->next_callee;\n \n       if (e->inline_failed)\n@@ -3693,9 +3555,10 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n \n \t  if (es->predicate)\n \t    {\n-\t      p = remap_predicate (info, callee_info,\n-\t\t\t\t   es->predicate, operand_map, offset_map,\n-\t\t\t\t   possible_truths, toplev_predicate);\n+\t      p = es->predicate->remap_after_inlining\n+\t\t\t\t     (info, callee_info, operand_map,\n+\t\t\t\t      offset_map, possible_truths,\n+\t\t\t\t      *toplev_predicate);\n \t      edge_set_predicate (e, &p);\n \t    }\n \t  else\n@@ -3709,15 +3572,15 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n   for (e = node->indirect_calls; e; e = next)\n     {\n       struct inline_edge_summary *es = inline_edge_summary (e);\n-      struct predicate p;\n+      predicate p;\n       next = e->next_callee;\n \n       remap_edge_change_prob (inlined_edge, e);\n       if (es->predicate)\n \t{\n-\t  p = remap_predicate (info, callee_info,\n-\t\t\t       es->predicate, operand_map, offset_map,\n-\t\t\t       possible_truths, toplev_predicate);\n+\t  p = es->predicate->remap_after_inlining\n+\t\t\t\t (info, callee_info, operand_map, offset_map,\n+\t\t\t          possible_truths, *toplev_predicate);\n \t  edge_set_predicate (e, &p);\n \t}\n       else\n@@ -3730,26 +3593,26 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n static void\n remap_hint_predicate (struct inline_summary *info,\n \t\t      struct inline_summary *callee_info,\n-\t\t      struct predicate **hint,\n+\t\t      predicate **hint,\n \t\t      vec<int> operand_map,\n \t\t      vec<int> offset_map,\n \t\t      clause_t possible_truths,\n-\t\t      struct predicate *toplev_predicate)\n+\t\t      predicate *toplev_predicate)\n {\n   predicate p;\n \n   if (!*hint)\n     return;\n-  p = remap_predicate (info, callee_info,\n-\t\t       *hint,\n-\t\t       operand_map, offset_map,\n-\t\t       possible_truths, toplev_predicate);\n-  if (!false_predicate_p (&p) && !true_predicate_p (&p))\n+  p = (*hint)->remap_after_inlining\n+\t\t\t (info, callee_info,\n+\t\t\t  operand_map, offset_map,\n+\t\t\t  possible_truths, *toplev_predicate);\n+  if (p != false && p != true)\n     {\n       if (!*hint)\n \tset_hint_predicate (hint, p);\n       else\n-\t**hint = and_predicates (info->conds, *hint, &p);\n+\t**hint &= p;\n     }\n }\n \n@@ -3767,14 +3630,14 @@ inline_merge_summary (struct cgraph_edge *edge)\n   vec<int> operand_map = vNULL;\n   vec<int> offset_map = vNULL;\n   int i;\n-  struct predicate toplev_predicate;\n-  struct predicate true_p = true_predicate ();\n+  predicate toplev_predicate;\n+  predicate true_p = true;\n   struct inline_edge_summary *es = inline_edge_summary (edge);\n \n   if (es->predicate)\n     toplev_predicate = *es->predicate;\n   else\n-    toplev_predicate = true_predicate ();\n+    toplev_predicate = true;\n \n   info->fp_expressions |= callee_info->fp_expressions;\n \n@@ -3821,21 +3684,21 @@ inline_merge_summary (struct cgraph_edge *edge)\n     }\n   for (i = 0; vec_safe_iterate (callee_info->entry, i, &e); i++)\n     {\n-      struct predicate p = remap_predicate (info, callee_info,\n-\t\t\t\t\t    &e->exec_predicate, operand_map,\n-\t\t\t\t\t    offset_map, clause,\n-\t\t\t\t\t    &toplev_predicate);\n-      struct predicate nonconstp\n-\t\t\t = remap_predicate (info, callee_info,\n-\t\t\t\t\t    &e->nonconst_predicate, operand_map,\n-\t\t\t\t\t    offset_map, clause,\n-\t\t\t\t\t    &toplev_predicate);\n-      if (!false_predicate_p (&p) && !false_predicate_p (&nonconstp))\n+      predicate p;\n+      p = e->exec_predicate.remap_after_inlining\n+\t\t\t     (info, callee_info, operand_map,\n+\t\t\t      offset_map, clause,\n+\t\t\t      toplev_predicate);\n+      predicate nonconstp;\n+      nonconstp = e->nonconst_predicate.remap_after_inlining\n+\t\t\t\t     (info, callee_info, operand_map,\n+\t\t\t\t      offset_map, clause,\n+\t\t\t\t      toplev_predicate);\n+      if (p != false && nonconstp != false)\n \t{\n \t  sreal add_time = ((sreal)e->time * edge->frequency) / CGRAPH_FREQ_BASE;\n-\t  int prob = predicate_probability (callee_info->conds,\n-\t\t\t\t\t    &e->nonconst_predicate,\n-\t\t\t\t\t    clause, es->param);\n+\t  int prob = e->nonconst_predicate.probability (callee_info->conds,\n+\t\t\t\t\t\t\tclause, es->param);\n \t  add_time = add_time * prob / REG_BR_PROB_BASE;\n \t  if (prob != REG_BR_PROB_BASE\n \t      && dump_file && (dump_flags & TDF_DETAILS))\n@@ -3888,7 +3751,7 @@ inline_update_overall_summary (struct cgraph_node *node)\n     }\n   estimate_calls_size_and_time (node, &info->size, &info->min_size,\n \t\t\t\t&info->time, NULL,\n-\t\t\t\t~(clause_t) (1 << predicate_false_condition),\n+\t\t\t\t~(clause_t) (1 << predicate::false_condition),\n \t\t\t\tvNULL, vNULL, vNULL);\n   info->size = (info->size + INLINE_SIZE_SCALE / 2) / INLINE_SIZE_SCALE;\n }\n@@ -4069,7 +3932,7 @@ estimate_size_after_inlining (struct cgraph_node *node,\n \t\t\t      struct cgraph_edge *edge)\n {\n   struct inline_edge_summary *es = inline_edge_summary (edge);\n-  if (!es->predicate || !false_predicate_p (es->predicate))\n+  if (!es->predicate || *es->predicate != false)\n     {\n       int size = inline_summaries->get (node)->size + estimate_edge_growth (edge);\n       gcc_assert (size >= 0);\n@@ -4314,25 +4177,22 @@ inline_generate_summary (void)\n \n /* Read predicate from IB.  */\n \n-static struct predicate\n-read_predicate (struct lto_input_block *ib)\n+void\n+predicate::stream_in (struct lto_input_block *ib)\n {\n-  struct predicate out;\n   clause_t clause;\n   int k = 0;\n \n   do\n     {\n-      gcc_assert (k <= MAX_CLAUSES);\n-      clause = out.clause[k++] = streamer_read_uhwi (ib);\n+      gcc_assert (k <= max_clauses);\n+      clause = m_clause[k++] = streamer_read_uhwi (ib);\n     }\n   while (clause);\n \n   /* Zero-initialize the remaining clauses in OUT.  */\n-  while (k <= MAX_CLAUSES)\n-    out.clause[k++] = 0;\n-\n-  return out;\n+  while (k <= max_clauses)\n+    m_clause[k++] = 0;\n }\n \n \n@@ -4342,13 +4202,13 @@ static void\n read_inline_edge_summary (struct lto_input_block *ib, struct cgraph_edge *e)\n {\n   struct inline_edge_summary *es = inline_edge_summary (e);\n-  struct predicate p;\n+  predicate p;\n   int length, i;\n \n   es->call_stmt_size = streamer_read_uhwi (ib);\n   es->call_stmt_time = streamer_read_uhwi (ib);\n   es->loop_depth = streamer_read_uhwi (ib);\n-  p = read_predicate (ib);\n+  p.stream_in (ib);\n   edge_set_predicate (e, &p);\n   length = streamer_read_uhwi (ib);\n   if (length)\n@@ -4432,17 +4292,17 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \n \t  e.size = streamer_read_uhwi (&ib);\n \t  e.time = sreal::stream_in (&ib);\n-\t  e.exec_predicate = read_predicate (&ib);\n-\t  e.nonconst_predicate = read_predicate (&ib);\n+\t  e.exec_predicate.stream_in (&ib);\n+\t  e.nonconst_predicate.stream_in (&ib);\n \n \t  vec_safe_push (info->entry, e);\n \t}\n \n-      p = read_predicate (&ib);\n+      p.stream_in (&ib);\n       set_hint_predicate (&info->loop_iterations, p);\n-      p = read_predicate (&ib);\n+      p.stream_in (&ib);\n       set_hint_predicate (&info->loop_stride, p);\n-      p = read_predicate (&ib);\n+      p.stream_in (&ib);\n       set_hint_predicate (&info->array_index, p);\n       for (e = node->callees; e; e = e->next_callee)\n \tread_inline_edge_summary (&ib, e);\n@@ -4498,16 +4358,15 @@ inline_read_summary (void)\n \n /* Write predicate P to OB.  */\n \n-static void\n-write_predicate (struct output_block *ob, struct predicate *p)\n+void\n+predicate::stream_out (struct output_block *ob)\n {\n   int j;\n-  if (p)\n-    for (j = 0; p->clause[j]; j++)\n-      {\n-\tgcc_assert (j < MAX_CLAUSES);\n-\tstreamer_write_uhwi (ob, p->clause[j]);\n-      }\n+  for (j = 0; m_clause[j]; j++)\n+    {\n+      gcc_assert (j < max_clauses);\n+      streamer_write_uhwi (ob, m_clause[j]);\n+    }\n   streamer_write_uhwi (ob, 0);\n }\n \n@@ -4523,7 +4382,10 @@ write_inline_edge_summary (struct output_block *ob, struct cgraph_edge *e)\n   streamer_write_uhwi (ob, es->call_stmt_size);\n   streamer_write_uhwi (ob, es->call_stmt_time);\n   streamer_write_uhwi (ob, es->loop_depth);\n-  write_predicate (ob, es->predicate);\n+  if (es->predicate)\n+    es->predicate->stream_out (ob);\n+  else\n+    streamer_write_uhwi (ob, 0);\n   streamer_write_uhwi (ob, es->param.length ());\n   for (i = 0; i < (int) es->param.length (); i++)\n     streamer_write_uhwi (ob, es->param[i].change_prob);\n@@ -4592,12 +4454,21 @@ inline_write_summary (void)\n \t    {\n \t      streamer_write_uhwi (ob, e->size);\n \t      e->time.stream_out (ob);\n-\t      write_predicate (ob, &e->exec_predicate);\n-\t      write_predicate (ob, &e->nonconst_predicate);\n+\t      e->exec_predicate.stream_out (ob);\n+\t      e->nonconst_predicate.stream_out (ob);\n \t    }\n-\t  write_predicate (ob, info->loop_iterations);\n-\t  write_predicate (ob, info->loop_stride);\n-\t  write_predicate (ob, info->array_index);\n+\t  if (info->loop_iterations)\n+\t    info->loop_iterations->stream_out (ob);\n+ \t  else\n+\t    streamer_write_uhwi (ob, 0);\n+\t  if (info->loop_stride)\n+\t    info->loop_stride->stream_out (ob);\n+ \t  else\n+\t    streamer_write_uhwi (ob, 0);\n+\t  if (info->array_index)\n+\t    info->array_index->stream_out (ob);\n+\t  else\n+\t    streamer_write_uhwi (ob, 0);\n \t  for (edge = cnode->callees; edge; edge = edge->next_callee)\n \t    write_inline_edge_summary (ob, edge);\n \t  for (edge = cnode->indirect_calls; edge; edge = edge->next_callee)"}, {"sha": "8a162e96898f3ba58e45fc87e8781e5a8aa7f2ba", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 163, "deletions": 30, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbcb3c7446c4c9f8f491db6a71bbab318918c874/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbcb3c7446c4c9f8f491db6a71bbab318918c874/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=dbcb3c7446c4c9f8f491db6a71bbab318918c874", "patch": "@@ -80,23 +80,169 @@ enum inline_hints_vals {\n };\n typedef int inline_hints;\n \n+/* Information kept about parameter of call site.  */\n+struct inline_param_summary\n+{\n+  /* REG_BR_PROB_BASE based probability that parameter will change in between\n+     two invocation of the calls.\n+     I.e. loop invariant parameters\n+     REG_BR_PROB_BASE/estimated_iterations and regular\n+     parameters REG_BR_PROB_BASE.\n+\n+     Value 0 is reserved for compile time invariants. */\n+  int change_prob;\n+};\n \n typedef vec<condition, va_gc> *conditions;\n \n-/* Representation of predicates i.e. formulas using conditions defined\n-   above.  Predicates are simple logical formulas in conjunctive-disjunctive\n-   form.\n+/* Predicates are used to repesent function parameters (such as runtime)\n+   which depend on a context function is called in.\n+\n+   Predicates are logical formulas in conjunctive-disjunctive form consisting\n+   of clauses which are bitmaps specifying a set of condition that must\n+   be true for a clause to be satisfied. Physically they are represented as\n+   array of clauses terminated by 0.\n \n-   Predicate is array of clauses terminated by 0.  Every clause must be true\n-   in order to make predicate true.\n-   Clauses are represented as bitmaps of conditions. One of conditions\n-   must be true in order for clause to be true.  */\n+   In order to make predicate (possibly) true, all of its clauses must\n+   be (possibly) true. To make clause (possibly) true, one of conditions\n+   it mentions must be (possibly) true.\n \n-#define MAX_CLAUSES 8\n-typedef unsigned int clause_t;\n-struct GTY(()) predicate\n+   There are fixed bounds on number of clauses and conditions and all the\n+   manipulation functions are conservative in positive direction. I.e. we\n+   may lose precision by thinking that predicate may be true even when it\n+   is not.  */\n+\n+typedef uint32_t clause_t;\n+class predicate\n {\n-  clause_t clause[MAX_CLAUSES + 1];\n+public:\n+  enum predicate_conditions\n+    {\n+      false_condition = 0,\n+      not_inlined_condition = 1,\n+      first_dynamic_condition = 2\n+    };\n+\n+  /* Initialize predicate either to true of false depending on P.  */\n+  inline predicate (bool p = true)\n+    {\n+      if (p)\n+        /* True predicate.  */\n+        m_clause[0] = 0;\n+      else\n+        /* False predicate. */\n+        set_to_cond (false_condition);\n+    }\n+\n+  /* Sanity check that we do not mix pointers to predicates with predicates.  */\n+  inline predicate (predicate *)\n+    {\n+      gcc_unreachable ();\n+    }\n+\n+  /* Return predicate testing condition I.  */\n+  static inline predicate predicate_testing_cond (int i)\n+    {\n+      class predicate p;\n+      p.set_to_cond (i + first_dynamic_condition);\n+      return p;\n+    }\n+\n+  /* Return predicate testing that function was not inlined.  */\n+  static predicate not_inlined (void)\n+    {\n+      class predicate p;\n+      p.set_to_cond (not_inlined_condition);\n+      return p;\n+    }\n+\n+  /* Compute logical and of predicates.  */\n+  predicate & operator &= (const predicate &);\n+  inline predicate operator &(const predicate &p)\n+    {\n+      predicate ret = *this;\n+      ret &= p;\n+      return ret;\n+    }\n+\n+  /* Compute logical or of predicates.  This is not operator because\n+     extra parameter CONDITIONS is needed  */\n+  predicate or_with (conditions, const predicate &) const;\n+\n+  /* Return true if predicates are known to be equal.  */\n+  inline bool operator==(const predicate &p2) const\n+    {\n+      int i;\n+      for (i = 0; m_clause[i]; i++)\n+\t{\n+\t  gcc_checking_assert (i < max_clauses);\n+\t  gcc_checking_assert (m_clause[i] > m_clause[i + 1]);\n+\t  gcc_checking_assert (!p2.m_clause[i]\n+\t\t\t       || p2.m_clause[i] > p2.m_clause[i + 1]);\n+\t  if (m_clause[i] != p2.m_clause[i])\n+\t    return false;\n+\t}\n+      return !p2.m_clause[i];\n+    }\n+\n+  /* Return true if predicates are known to be true or false depending\n+     on COND.  */\n+  inline bool operator==(const bool cond) const\n+    {\n+      if (cond)\n+        return !m_clause[0];\n+      if (m_clause[0] == (1 << false_condition))\n+\t{\n+\t  gcc_checking_assert (!m_clause[1]\n+\t\t\t       && m_clause[0] == 1\n+\t\t\t\t  << false_condition);\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+\n+  inline bool operator!=(const predicate &p2) const\n+    {\n+      return !(*this == p2);\n+    }\n+\n+  inline bool operator!=(const bool cond) const\n+    {\n+      return !(*this == cond);\n+    }\n+\n+  /* Evaluate if predicate is known to be false given the clause of possible\n+     truths.  */\n+  bool evaluate (clause_t) const;\n+\n+  /* Estimate probability that predicate will be true in a given context.  */\n+  int probability (conditions, clause_t, vec<inline_param_summary>) const;\n+\n+  /* Dump predicate to F. Output newline if nl.  */\n+  void dump (FILE *f, conditions, bool nl=true) const;\n+\n+  /* Return predicate equal to THIS after duplication.  */\n+  predicate remap_after_duplication (clause_t);\n+\n+  /* Return predicate equal to THIS after inlining.  */\n+  predicate remap_after_inlining (struct inline_summary *,\n+\t\t\t          struct inline_summary *,\n+\t\t\t          vec<int>, vec<int>, clause_t, const predicate &);\n+\n+  void stream_in (struct lto_input_block *);\n+  void stream_out (struct output_block *);\n+private:\n+  static const int max_clauses = 8;\n+  clause_t m_clause[max_clauses + 1];\n+\n+  /* Initialize predicate to one testing single condition number COND.  */\n+  inline void set_to_cond (int cond)\n+    {\n+      m_clause[0] = 1 << cond;\n+      m_clause[1] = 0;\n+    }\n+\n+  void add_clause (conditions conditions, clause_t);\n };\n \n /* Represnetation of function body size and time depending on the inline\n@@ -108,11 +254,11 @@ struct GTY(()) predicate\n struct GTY(()) size_time_entry\n {\n   /* Predicate for code to be executed.  */\n-  struct predicate exec_predicate;\n+  predicate exec_predicate;\n   /* Predicate for value to be constant and optimized out in a specialized copy.\n      When deciding on specialization this makes it possible to see how much\n      the executed code paths will simplify.  */\n-  struct predicate nonconst_predicate;\n+  predicate nonconst_predicate;\n   int size;\n   sreal GTY((skip)) time;\n };\n@@ -161,12 +307,12 @@ struct GTY(()) inline_summary\n \n   /* Predicate on when some loop in the function becomes to have known\n      bounds.   */\n-  struct predicate * GTY((skip)) loop_iterations;\n+  predicate * GTY((skip)) loop_iterations;\n   /* Predicate on when some loop in the function becomes to have known\n      stride.   */\n-  struct predicate * GTY((skip)) loop_stride;\n+  predicate * GTY((skip)) loop_stride;\n   /* Predicate on when some array indexes become constants.  */\n-  struct predicate * GTY((skip)) array_index;\n+  predicate * GTY((skip)) array_index;\n   /* Estimated growth for inlining all copies of the function before start\n      of small functions inlining.\n      This value will get out of date as the callers are duplicated, but\n@@ -212,19 +358,6 @@ class GTY((user)) inline_summary_t: public function_summary <inline_summary *>\n \n extern GTY(()) function_summary <inline_summary *> *inline_summaries;\n \n-/* Information kept about parameter of call site.  */\n-struct inline_param_summary\n-{\n-  /* REG_BR_PROB_BASE based probability that parameter will change in between\n-     two invocation of the calls.\n-     I.e. loop invariant parameters\n-     REG_BR_PROB_BASE/estimated_iterations and regular\n-     parameters REG_BR_PROB_BASE.\n-\n-     Value 0 is reserved for compile time invariants. */\n-  int change_prob;\n-};\n-\n /* Information kept about callgraph edges.  */\n struct inline_edge_summary\n {\n@@ -233,7 +366,7 @@ struct inline_edge_summary\n   int call_stmt_time;\n   /* Depth of loop nest, 0 means no nesting.  */\n   unsigned short int loop_depth;\n-  struct predicate *predicate;\n+  class predicate *predicate;\n   /* Array indexed by parameters.\n      0 means that parameter change all the time, REG_BR_PROB_BASE means\n      that parameter is constant.  */"}]}