{"sha": "39acb18f66f7b0ff8c36f5fa96e76168f959d2a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzlhY2IxOGY2NmY3YjBmZjhjMzZmNWZhOTZlNzYxNjhmOTU5ZDJhMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-08-20T21:22:16Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-08-20T21:22:16Z"}, "message": "aix.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.\n\n\t* config/rs6000/aix.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.\n\t* config/rs6000/linux.h (STACK_CHECK_STATIC_BUILTIN): Likewise.\n\t* config/rs6000/linux64.h (STACK_CHECK_STATIC_BUILTIN): Likewise.\n\t(STACK_CHECK_PROTECT): Define.\n\t* config/rs6000/rs6000.c (rs6000_emit_probe_stack_range): New function.\n\t(output_probe_stack_range): Likewise.\n\t(rs6000_emit_prologue): Invoke rs6000_emit_probe_stack_range if static\n\tbuiltin stack checking is enabled.\n\t* config/rs6000/rs6000-protos.h (output_probe_stack_range): Declare.\n\t* config/rs6000/rs6000.md (UNSPECV_PROBE_STACK_RANGE): New constant.\n\t(probe_stack_range): New insn.\n\nFrom-SVN: r163424", "tree": {"sha": "dd5267f9b0b1c4ad1a5238d45877854ea2c254de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd5267f9b0b1c4ad1a5238d45877854ea2c254de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39acb18f66f7b0ff8c36f5fa96e76168f959d2a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39acb18f66f7b0ff8c36f5fa96e76168f959d2a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39acb18f66f7b0ff8c36f5fa96e76168f959d2a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39acb18f66f7b0ff8c36f5fa96e76168f959d2a1/comments", "author": null, "committer": null, "parents": [{"sha": "410841c6d58b3d96245b564d1af8449164543956", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/410841c6d58b3d96245b564d1af8449164543956", "html_url": "https://github.com/Rust-GCC/gccrs/commit/410841c6d58b3d96245b564d1af8449164543956"}], "stats": {"total": 171, "additions": 171, "deletions": 0}, "files": [{"sha": "8a7634749100eaf51c91d149661fa0d6a96d7768", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39acb18f66f7b0ff8c36f5fa96e76168f959d2a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39acb18f66f7b0ff8c36f5fa96e76168f959d2a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39acb18f66f7b0ff8c36f5fa96e76168f959d2a1", "patch": "@@ -1,3 +1,17 @@\n+2010-08-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/rs6000/aix.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.\n+\t* config/rs6000/linux.h (STACK_CHECK_STATIC_BUILTIN): Likewise.\n+\t* config/rs6000/linux64.h (STACK_CHECK_STATIC_BUILTIN): Likewise.\n+\t(STACK_CHECK_PROTECT): Define.\n+\t* config/rs6000/rs6000.c (rs6000_emit_probe_stack_range): New function.\n+\t(output_probe_stack_range): Likewise.\n+\t(rs6000_emit_prologue): Invoke rs6000_emit_probe_stack_range if static\n+\tbuiltin stack checking is enabled.\n+\t* config/rs6000/rs6000-protos.h (output_probe_stack_range): Declare.\n+\t* config/rs6000/rs6000.md (UNSPECV_PROBE_STACK_RANGE): New constant.\n+\t(probe_stack_range): New insn.\n+\n 2010-08-20  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/45336"}, {"sha": "a5eb89da171f9aedd1f68206e429e7c948bdc22f", "filename": "gcc/config/rs6000/aix.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39acb18f66f7b0ff8c36f5fa96e76168f959d2a1/gcc%2Fconfig%2Frs6000%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39acb18f66f7b0ff8c36f5fa96e76168f959d2a1/gcc%2Fconfig%2Frs6000%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix.h?ref=39acb18f66f7b0ff8c36f5fa96e76168f959d2a1", "patch": "@@ -260,3 +260,6 @@\n \n /* WINT_TYPE */\n #define WINT_TYPE \"int\"\n+\n+/* Static stack checking is supported by means of probes.  */\n+#define STACK_CHECK_STATIC_BUILTIN 1"}, {"sha": "c659a3eac4765c4c2dc8d325dd6f837294d9e449", "filename": "gcc/config/rs6000/linux.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39acb18f66f7b0ff8c36f5fa96e76168f959d2a1/gcc%2Fconfig%2Frs6000%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39acb18f66f7b0ff8c36f5fa96e76168f959d2a1/gcc%2Fconfig%2Frs6000%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux.h?ref=39acb18f66f7b0ff8c36f5fa96e76168f959d2a1", "patch": "@@ -130,3 +130,6 @@\n #ifdef TARGET_DEFAULT_LONG_DOUBLE_128\n #define RS6000_DEFAULT_LONG_DOUBLE_SIZE 128\n #endif\n+\n+/* Static stack checking is supported by means of probes.  */\n+#define STACK_CHECK_STATIC_BUILTIN 1"}, {"sha": "0e165ea7199a201529c7677b7a2cae0ad7e7981b", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39acb18f66f7b0ff8c36f5fa96e76168f959d2a1/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39acb18f66f7b0ff8c36f5fa96e76168f959d2a1/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=39acb18f66f7b0ff8c36f5fa96e76168f959d2a1", "patch": "@@ -573,3 +573,9 @@ extern enum rs6000_cmodel cmodel;\n #ifdef TARGET_DEFAULT_LONG_DOUBLE_128\n #define RS6000_DEFAULT_LONG_DOUBLE_SIZE 128\n #endif\n+\n+/* Static stack checking is supported by means of probes.  */\n+#define STACK_CHECK_STATIC_BUILTIN 1\n+\n+/* The default value isn't sufficient in 64-bit mode.  */\n+#define STACK_CHECK_PROTECT (TARGET_64BIT ? 16 * 1024 : 12 * 1024)"}, {"sha": "8708accd7eafc4f0c3effa73ab69a80fe0cab141", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39acb18f66f7b0ff8c36f5fa96e76168f959d2a1/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39acb18f66f7b0ff8c36f5fa96e76168f959d2a1/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=39acb18f66f7b0ff8c36f5fa96e76168f959d2a1", "patch": "@@ -95,6 +95,7 @@ extern void rs6000_emit_sCOND (enum machine_mode, rtx[]);\n extern void rs6000_emit_cbranch (enum machine_mode, rtx[]);\n extern char * output_cbranch (rtx, const char *, int, rtx);\n extern char * output_e500_flip_gt_bit (rtx, rtx);\n+extern const char * output_probe_stack_range (rtx, rtx);\n extern rtx rs6000_emit_set_const (rtx, enum machine_mode, rtx, int);\n extern int rs6000_emit_cmove (rtx, rtx, rtx, rtx);\n extern int rs6000_emit_vector_cond_expr (rtx, rtx, rtx, rtx, rtx, rtx);"}, {"sha": "3928901cdd9af310addd08d1858807f9efccac82", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39acb18f66f7b0ff8c36f5fa96e76168f959d2a1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39acb18f66f7b0ff8c36f5fa96e76168f959d2a1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=39acb18f66f7b0ff8c36f5fa96e76168f959d2a1", "patch": "@@ -18788,6 +18788,137 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, rtx copy_reg)\n \t\t\t\t\t   GEN_INT (-size))));\n }\n \n+#define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)\n+\n+#if PROBE_INTERVAL > 32768\n+#error Cannot use indexed addressing mode for stack probing\n+#endif\n+\n+/* Emit code to probe a range of stack addresses from FIRST to FIRST+SIZE,\n+   inclusive.  These are offsets from the current stack pointer.  */\n+\n+static void\n+rs6000_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n+{\n+  /* See if we have a constant small number of probes to generate.  If so,\n+     that's the easy case.  */\n+  if (first + size <= 32768)\n+    {\n+      HOST_WIDE_INT i;\n+\n+      /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 1 until\n+\t it exceeds SIZE.  If only one probe is needed, this will not\n+\t generate any code.  Then probe at FIRST + SIZE.  */\n+      for (i = PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)\n+\temit_stack_probe (plus_constant (stack_pointer_rtx, -(first + i)));\n+\n+      emit_stack_probe (plus_constant (stack_pointer_rtx, -(first + size)));\n+    }\n+\n+  /* Otherwise, do the same as above, but in a loop.  Note that we must be\n+     extra careful with variables wrapping around because we might be at\n+     the very top (or the very bottom) of the address space and we have\n+     to be able to handle this case properly; in particular, we use an\n+     equality test for the loop condition.  */\n+  else\n+    {\n+      HOST_WIDE_INT rounded_size;\n+      rtx r12 = gen_rtx_REG (Pmode, 12);\n+      rtx r0 = gen_rtx_REG (Pmode, 0);\n+\n+      /* Sanity check for the addressing mode we're going to use.  */\n+      gcc_assert (first <= 32768);\n+\n+      /* Step 1: round SIZE to the previous multiple of the interval.  */\n+\n+      rounded_size = size & -PROBE_INTERVAL;\n+\n+\n+      /* Step 2: compute initial and final value of the loop counter.  */\n+\n+      /* TEST_ADDR = SP + FIRST.  */\n+      emit_insn (gen_rtx_SET (VOIDmode, r12,\n+\t\t\t      plus_constant (stack_pointer_rtx, -first)));\n+\n+      /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */\n+      if (rounded_size > 32768)\n+\t{\n+\t  emit_move_insn (r0, GEN_INT (-rounded_size));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, r0,\n+\t\t\t\t  gen_rtx_PLUS (Pmode, r12, r0)));\n+\t}\n+      else\n+\temit_insn (gen_rtx_SET (VOIDmode, r0,\n+\t\t\t        plus_constant (r12, -rounded_size)));\n+\n+\n+      /* Step 3: the loop\n+\n+\t while (TEST_ADDR != LAST_ADDR)\n+\t   {\n+\t     TEST_ADDR = TEST_ADDR + PROBE_INTERVAL\n+\t     probe at TEST_ADDR\n+\t   }\n+\n+\t probes at FIRST + N * PROBE_INTERVAL for values of N from 1\n+\t until it is equal to ROUNDED_SIZE.  */\n+\n+      if (TARGET_64BIT)\n+\temit_insn (gen_probe_stack_rangedi (r12, r12, r0));\n+      else\n+\temit_insn (gen_probe_stack_rangesi (r12, r12, r0));\n+\n+\n+      /* Step 4: probe at FIRST + SIZE if we cannot assert at compile-time\n+\t that SIZE is equal to ROUNDED_SIZE.  */\n+\n+      if (size != rounded_size)\n+\temit_stack_probe (plus_constant (r12, rounded_size - size));\n+    }\n+}\n+\n+/* Probe a range of stack addresses from REG1 to REG2 inclusive.  These are\n+   absolute addresses.  */\n+\n+const char *\n+output_probe_stack_range (rtx reg1, rtx reg2)\n+{\n+  static int labelno = 0;\n+  char loop_lab[32], end_lab[32];\n+  rtx xops[2];\n+\n+  ASM_GENERATE_INTERNAL_LABEL (loop_lab, \"LPSRL\", labelno);\n+  ASM_GENERATE_INTERNAL_LABEL (end_lab, \"LPSRE\", labelno++);\n+\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, loop_lab);\n+\n+  /* Jump to END_LAB if TEST_ADDR == LAST_ADDR.  */\n+  xops[0] = reg1;\n+  xops[1] = reg2;\n+  if (TARGET_64BIT)\n+    output_asm_insn (\"{cmp|cmpd} 0,%0,%1\", xops);\n+  else\n+    output_asm_insn (\"{cmp|cmpw} 0,%0,%1\", xops);\n+\n+  fputs (\"\\tbeq 0,\", asm_out_file);\n+  assemble_name_raw (asm_out_file, end_lab);\n+  fputc ('\\n', asm_out_file);\n+\n+  /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */\n+  xops[1] = GEN_INT (-PROBE_INTERVAL);\n+  output_asm_insn (\"{cal %0,%1(%0)|addi %0,%0,%1}\", xops);\n+\n+  /* Probe at TEST_ADDR and branch.  */\n+  output_asm_insn (\"{st|stw} 0,0(%0)\", xops);\n+  fprintf (asm_out_file, \"\\tb \");\n+  assemble_name_raw (asm_out_file, loop_lab);\n+  fputc ('\\n', asm_out_file);\n+\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, end_lab);\n+\n+  return \"\";\n+}\n+\n /* Add to 'insn' a note which is PATTERN (INSN) but with REG replaced\n    with (plus:P (reg 1) VAL), and with REG2 replaced with RREG if REG2\n    is not NULL.  It would be nice if dwarf2out_frame_debug_expr could\n@@ -19400,6 +19531,9 @@ rs6000_emit_prologue (void)\n \t\t\t      && call_used_regs[STATIC_CHAIN_REGNUM]);\n   HOST_WIDE_INT sp_offset = 0;\n \n+  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && info->total_size)\n+    rs6000_emit_probe_stack_range (STACK_CHECK_PROTECT, info->total_size);\n+\n   if (TARGET_FIX_AND_CONTINUE)\n     {\n       /* gdb on darwin arranges to forward a function from the old"}, {"sha": "c5e0ba1519b48fcf724036f20df6c332d9c2bab5", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39acb18f66f7b0ff8c36f5fa96e76168f959d2a1/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39acb18f66f7b0ff8c36f5fa96e76168f959d2a1/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=39acb18f66f7b0ff8c36f5fa96e76168f959d2a1", "patch": "@@ -115,6 +115,7 @@\n   [(UNSPECV_BLOCK\t\t0)\n    (UNSPECV_LL\t\t\t1)\t; load-locked\n    (UNSPECV_SC\t\t\t2)\t; store-conditional\n+   (UNSPECV_PROBE_STACK_RANGE\t3)\t; probe range of stack addresses\n    (UNSPECV_EH_RR\t\t9)\t; eh_reg_restore\n   ])\n \f\n@@ -12663,6 +12664,15 @@\n   \"{st%U0%X0|stw%U0%X0} 0,%0\"\n   [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"4\")])\n+\n+(define_insn \"probe_stack_range<P:mode>\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:P [(match_operand:P 1 \"register_operand\" \"0\")\n+\t\t\t    (match_operand:P 2 \"register_operand\" \"r\")]\n+\t\t\t   UNSPECV_PROBE_STACK_RANGE))]\n+  \"\"\n+  \"* return output_probe_stack_range (operands[0], operands[2]);\"\n+  [(set_attr \"type\" \"three\")])\n \f\n ;; Compare insns are next.  Note that the RS/6000 has two types of compares,\n ;; signed & unsigned, and one type of branch."}]}