{"sha": "a1ab4c317abfd045fe0619b455a31e19f910f7e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFhYjRjMzE3YWJmZDA0NWZlMDYxOWI0NTVhMzFlMTlmOTEwZjdlNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-07-29T15:46:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-07-29T15:46:37Z"}, "message": "gcc-interface: New directory.\n\n\t* gcc-interface: New directory.\n\n\t* ada-tree.def, cuintp.c, gigi.h, Makefile.in, targtyps.c, ada.h,\n\tutils.c, ada-tree.h, decl.c, lang.opt, Make-lang.in, trans.c,\n\tconfig-lang.in, deftarg.c, lang-specs.h, misc.c, utils2.c: Moved\n\tto gcc-interface subdirectory.\n\nFrom-SVN: r138246", "tree": {"sha": "288fa3feb4853249f0fa6c2c4034648792cc9d11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/288fa3feb4853249f0fa6c2c4034648792cc9d11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1ab4c317abfd045fe0619b455a31e19f910f7e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ab4c317abfd045fe0619b455a31e19f910f7e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1ab4c317abfd045fe0619b455a31e19f910f7e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ab4c317abfd045fe0619b455a31e19f910f7e7/comments", "author": null, "committer": null, "parents": [{"sha": "468973704f3aa671169a4c2d15cb81be6026f433", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/468973704f3aa671169a4c2d15cb81be6026f433", "html_url": "https://github.com/Rust-GCC/gccrs/commit/468973704f3aa671169a4c2d15cb81be6026f433"}], "stats": {"total": 33657, "additions": 31338, "deletions": 2319}, "files": [{"sha": "9f223c4195c9af19cc4dd5ad50490d4303b6f7fe", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 2, "deletions": 2295, "changes": 2297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=a1ab4c317abfd045fe0619b455a31e19f910f7e7", "patch": "@@ -1,2296 +1,3 @@\n-# Makefile for GNU Ada Compiler (GNAT).\n-#   Copyright (C) 1994-2008 Free Software Foundation, Inc.\n-\n-#This file is part of GCC.\n-\n-#GCC is free software; you can redistribute it and/or modify\n-#it under the terms of the GNU General Public License as published by\n-#the Free Software Foundation; either version 3, or (at your option)\n-#any later version.\n-\n-#GCC is distributed in the hope that it will be useful,\n-#but WITHOUT ANY WARRANTY; without even the implied warranty of\n-#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-#GNU General Public License for more details.\n-\n-#You should have received a copy of the GNU General Public License\n-#along with GCC; see the file COPYING3.  If not see\n-#<http://www.gnu.org/licenses/>.\n-\n-# The makefile built from this file lives in the language subdirectory.\n-# Its purpose is to provide support for:\n-#\n-# 1) recursion where necessary, and only then (building .o's), and\n-# 2) building and debugging cc1 from the language subdirectory, and\n-# 3) nothing else.\n-#\n-# The parent makefile handles all other chores, with help from the\n-# language makefile fragment, of course.\n-#\n-# The targets for external use are:\n-# all, TAGS, ???mostlyclean, ???clean.\n-\n-# This makefile will only work with Gnu make.\n-# The rules are written assuming a minimum subset of tools are available:\n-#\n-# Required:\n-#      MAKE:    Only Gnu make will work.\n-#      MV:      Must accept (at least) one, maybe wildcard, source argument,\n-#               a file or directory destination, and support creation/\n-#               modification date preservation.  Gnu mv -f works.\n-#      RM:      Must accept an arbitrary number of space separated file\n-#               arguments, or one wildcard argument. Gnu rm works.\n-#      RMDIR:   Must delete a directory and all its contents. Gnu rm -rf works.\n-#      ECHO:    Must support command line redirection. Any Unix-like\n-#               shell will typically provide this, otherwise a custom version\n-#               is trivial to write.\n-#      AR:      Gnu ar works.\n-#      MKDIR:   Gnu mkdir works.\n-#      CHMOD:   Gnu chmod works.\n-#      true:    Does nothing and returns a normal successful return code.\n-#      pwd:     Prints the current directory on stdout.\n-#      cd:      Change directory.\n-#\n-# Optional:\n-#      BISON:   Gnu bison works.\n-#      FLEX:    Gnu flex works.\n-#      Other miscellaneous tools for obscure targets.\n-\n-# Suppress smart makes who think they know how to automake Yacc files\n-.y.c:\n-\n-# Variables that exist for you to override.\n-# See below for how to change them for certain systems.\n-\n-# Various ways of specifying flags for compilations:\n-# CFLAGS is for the user to override to, e.g., do a bootstrap with -O2.\n-# BOOT_CFLAGS is the value of CFLAGS to pass\n-# to the stage2 and stage3 compilations\n-# XCFLAGS is used for most compilations but not when using the GCC just built.\n-XCFLAGS =\n-CFLAGS = -g\n-BOOT_CFLAGS = -O $(CFLAGS)\n-# These exists to be overridden by the x-* and t-* files, respectively.\n-X_CFLAGS =\n-T_CFLAGS =\n-\n-X_CPPFLAGS =\n-T_CPPFLAGS =\n-\n-X_ADA_CFLAGS =\n-T_ADA_CFLAGS =\n-\n-X_ADAFLAGS =\n-T_ADAFLAGS =\n-\n-CC = cc\n-BISON = bison\n-BISONFLAGS =\n-ECHO = echo\n-LEX = flex\n-LEXFLAGS =\n-CHMOD = chmod\n-LN = ln\n-LN_S = ln -s\n-CP = cp -p\n-MV = mv -f\n-RM = rm -f\n-RMDIR = rm -rf\n-MKDIR = mkdir -p\n-AR = ar\n-AR_FLAGS = rc\n-LS = ls\n-RANLIB = @RANLIB@\n-RANLIB_FLAGS = @ranlib_flags@\n-\n-SHELL = @SHELL@\n-PWD_COMMAND = $${PWDCMD-pwd}\n-# How to copy preserving the date\n-INSTALL_DATA_DATE = cp -p\n-MAKEINFO = makeinfo\n-TEXI2DVI = texi2dvi\n-TEXI2PDF = texi2pdf\n-GNATBIND_FLAGS = -static -x\n-ADA_CFLAGS =\n-ADAFLAGS = -W -Wall -gnatpg -gnata\n-SOME_ADAFLAGS =-gnata\n-FORCE_DEBUG_ADAFLAGS = -g\n-GNATLIBFLAGS = -gnatpg -nostdinc\n-GNATLIBCFLAGS = -g -O2\n-GNATLIBCFLAGS_FOR_C = $(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS) -fexceptions \\\n-\t-DIN_RTS\n-ALL_ADA_CFLAGS = $(X_ADA_CFLAGS) $(T_ADA_CFLAGS) $(ADA_CFLAGS)\n-ALL_ADAFLAGS = $(CFLAGS) $(ALL_ADA_CFLAGS) $(X_ADAFLAGS) $(T_ADAFLAGS) \\\n-\t$(ADAFLAGS)\n-MOST_ADAFLAGS = $(CFLAGS) $(ALL_ADA_CFLAGS) $(X_ADAFLAGS) $(T_ADAFLAGS) \\\n-\t$(SOME_ADAFLAGS)\n-THREAD_KIND = native\n-THREADSLIB =\n-GMEM_LIB =\n-MISCLIB =\n-SYMDEPS = $(LIBINTL_DEP)\n-OUTPUT_OPTION = @OUTPUT_OPTION@\n-\n-objext = .o\n-exeext =\n-arext  = .a\n-soext  = .so\n-shext  =\n-hyphen = -\n-\n-# Define this as & to perform parallel make on a Sequent.\n-# Note that this has some bugs, and it seems currently necessary\n-# to compile all the gen* files first by hand to avoid erroneous results.\n-P =\n-\n-# This is used instead of ALL_CFLAGS when compiling with GCC_FOR_TARGET.\n-# It omits XCFLAGS, and specifies -B./.\n-# It also specifies -B$(tooldir)/ to find as and ld for a cross compiler.\n-GCC_CFLAGS = $(INTERNAL_CFLAGS) $(X_CFLAGS) $(T_CFLAGS) $(CFLAGS)\n-\n-# Tools to use when building a cross-compiler.\n-# These are used because `configure' appends `cross-make'\n-# to the makefile when making a cross-compiler.\n-\n-# We don't use cross-make.  Instead we use the tools from the build tree,\n-# if they are available.\n-# program_transform_name and objdir are set by configure.in.\n-program_transform_name =\n-objdir = .\n-\n-target_alias=@target_alias@\n-target=@target@\n-xmake_file = @xmake_file@\n-tmake_file = @tmake_file@\n-host_canonical=@host@\n-#version=`sed -e 's/.*\\\"\\([^ \\\"]*\\)[ \\\"].*/\\1/' < $(srcdir)/version.c`\n-#mainversion=`sed -e 's/.*\\\"\\([0-9]*\\.[0-9]*\\).*/\\1/' < $(srcdir)/version.c`\n-\n-# Directory where sources are, from where we are.\n srcdir = @srcdir@\n-VPATH = $(srcdir)\n-\n-fsrcdir := $(shell cd $(srcdir);${PWD_COMMAND})\n-fsrcpfx := $(shell cd $(srcdir);${PWD_COMMAND})/\n-fcurdir := $(shell ${PWD_COMMAND})\n-fcurpfx := $(shell ${PWD_COMMAND})/\n-\n-# Top build directory, relative to here.\n-top_builddir = ../..\n-\n-# Internationalization library.\n-LIBINTL = @LIBINTL@\n-LIBINTL_DEP = @LIBINTL_DEP@\n-\n-# Any system libraries needed just for GNAT.\n-SYSLIBS = @GNAT_LIBEXC@\n-\n-# List of extra object files linked in with various programs.\n-EXTRA_GNATTOOLS_OBJS = ../../prefix.o ../../version.o\n-\n-# List of target dependent sources, overridden below as necessary\n-TARGET_ADA_SRCS =\n-\n-# Type of tools build we are doing; default is not compiling tools.\n-TOOLSCASE =\n-\n-# End of variables for you to override.\n-\n-all: all.indirect\n-\n-# This tells GNU Make version 3 not to put all variables in the environment.\n-.NOEXPORT:\n-\n-# tmake_file and xmake_file expand to lists with entries of the form\n-# $(srcdir)/config/...  but here $(srcdir) is the ada subdirectory so we\n-# need to adjust the paths.  There can't be spaces in the subst arguments\n-# or we get spurious spaces in the actual list of files to include.\n-\n-# target overrides\n-ifneq ($(tmake_file),)\n-include $(subst /config,/../config,$(tmake_file))\n-endif\n-\n-# host overrides\n-ifneq ($(xmake_file),)\n-include $(subst /config,/../config,$(xmake_file))\n-endif\n-\f\n-# Now figure out from those variables how to compile and link.\n-\n-all.indirect: Makefile ../gnat1$(exeext)\n-\n-# IN_GCC distinguishes between code compiled into GCC itself and other\n-# programs built during a bootstrap.\n-# autoconf inserts -DCROSS_DIRECTORY_STRUCTURE if we are building a cross\n-# compiler which does not use the native libraries and headers.\n-INTERNAL_CFLAGS = @CROSS@ -DIN_GCC\n-\n-# This is the variable actually used when we compile.\n-LOOSE_CFLAGS = `echo $(CFLAGS) $(WARN2_CFLAGS)|sed -e 's/-pedantic//g' -e 's/-Wtraditional//g'`\n-ALL_CFLAGS = $(INTERNAL_CFLAGS) $(X_CFLAGS) $(T_CFLAGS) $(LOOSE_CFLAGS) \\\n-\t$(XCFLAGS)\n-\n-# Likewise.\n-ALL_CPPFLAGS = $(CPPFLAGS) $(X_CPPFLAGS) $(T_CPPFLAGS)\n-\n-# This is where we get libiberty.a from.\n-LIBIBERTY = ../../libiberty/libiberty.a\n-\n-# How to link with both our special library facilities\n-# and the system's installed libraries.\n-LIBS = $(LIBINTL) $(LIBIBERTY) $(SYSLIBS)\n-LIBDEPS = $(LIBINTL_DEP) $(LIBIBERTY)\n-# Default is no TGT_LIB; one might be passed down or something\n-TGT_LIB =\n-TOOLS_LIBS = $(EXTRA_GNATTOOLS_OBJS) targext.o link.o $(LIBGNAT) ../../../libiberty/libiberty.a $(SYSLIBS) $(TGT_LIB)\n-\n-# Specify the directories to be searched for header files.\n-# Both . and srcdir are used, in that order,\n-# so that tm.h and config.h will be found in the compilation\n-# subdirectory rather than in the source directory.\n-INCLUDES = -I- -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config \\\n-\t-I$(srcdir)/../../include\n-\n-ADA_INCLUDES = -I- -I. -I$(srcdir)\n-\n-INCLUDES_FOR_SUBDIR = -I. -I.. -I../.. -I$(fsrcdir) -I$(fsrcdir)/../config \\\n-\t-I$(fsrcdir)/../../include -I$(fsrcdir)/..\n-ADA_INCLUDES_FOR_SUBDIR = -I. -I$(fsrcdir)\n-\n-# Avoid a lot of time thinking about remaking Makefile.in and *.def.\n-.SUFFIXES: .in .def\n-\n-# Say how to compile Ada programs.\n-.SUFFIXES: .ada .adb .ads .asm\n-\n-# Always use -I$(srcdir)/config when compiling.\n-.asm.o:\n-\t$(CC) -c -x assembler $< $(OUTPUT_OPTION)\n-\n-.c.o:\n-\t$(CC) -c $(ALL_CFLAGS) $(ADA_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< \\\n-\t  $(OUTPUT_OPTION)\n-\n-.adb.o:\n-\t$(CC) -c $(ALL_ADAFLAGS) $(ADA_INCLUDES) $< $(OUTPUT_OPTION)\n-\n-.ads.o:\n-\t$(CC) -c $(ALL_ADAFLAGS) $(ADA_INCLUDES) $< $(OUTPUT_OPTION)\n-\n-# how to regenerate this file\n-Makefile: ../config.status $(srcdir)/Makefile.in $(srcdir)/../version.c\n-\tcd ..; \\\n-\tLANGUAGES=\"$(CONFIG_LANGUAGES)\" \\\n-\tCONFIG_HEADERS= \\\n-\tCONFIG_FILES=ada/Makefile $(SHELL) config.status\n-\n-# This tells GNU make version 3 not to export all the variables\n-# defined in this file into the environment.\n-.NOEXPORT:\n-\f\n-# Lists of files for various purposes.\n-\n-GNATLINK_OBJS = gnatlink.o \\\n- a-except.o ali.o alloc.o butil.o casing.o csets.o debug.o fmap.o fname.o \\\n- gnatvsn.o hostparm.o indepsw.o interfac.o i-c.o i-cstrin.o namet.o opt.o \\\n- osint.o output.o rident.o s-exctab.o s-secsta.o s-stalib.o s-stoele.o \\\n- sdefault.o snames.o stylesw.o switch.o system.o table.o targparm.o tree_io.o \\\n- types.o validsw.o widechar.o\n-\n-GNATMAKE_OBJS = a-except.o ali.o ali-util.o s-casuti.o \\\n- alloc.o atree.o binderr.o butil.o casing.o csets.o debug.o elists.o einfo.o\\\n- erroutc.o errutil.o err_vars.o fmap.o fname.o fname-uf.o fname-sf.o \\\n- gnatmake.o gnatvsn.o hostparm.o interfac.o i-c.o i-cstrin.o krunch.o lib.o \\\n- make.o makeusg.o makeutl.o mlib.o mlib-fil.o mlib-prj.o mlib-tgt.o \\\n- mlib-tgt-specific.o mlib-utl.o namet.o nlists.o opt.o osint.o osint-m.o output.o \\\n- prj.o prj-attr.o prj-attr-pm.o prj-com.o prj-dect.o prj-env.o prj-err.o prj-ext.o prj-nmsc.o \\\n- prj-pars.o prj-part.o prj-proc.o prj-strt.o prj-tree.o prj-util.o \\\n- rident.o s-exctab.o s-secsta.o s-stalib.o s-stoele.o \\\n- scans.o scng.o sdefault.o sfn_scan.o s-purexc.o s-htable.o \\\n- sinfo.o sinput.o sinput-c.o sinput-p.o \\\n- snames.o stand.o stringt.o styleg.o stylesw.o system.o validsw.o switch.o switch-m.o \\\n- table.o targparm.o tempdir.o tree_io.o types.o \\\n- uintp.o uname.o urealp.o usage.o widechar.o \\\n- $(EXTRA_GNATMAKE_OBJS)\n-\n-# Convert the target variable into a space separated list of architecture,\n-# manufacturer, and operating system and assign each of those to its own\n-# variable.\n-\n-host:=$(subst -, ,$(host_canonical))\n-targ:=$(subst -, ,$(target))\n-arch:=$(word 1,$(targ))\n-ifeq ($(words $(targ)),2)\n-  manu:=\n-  osys:=$(word 2,$(targ))\n-else\n-  manu:=$(word 2,$(targ))\n-  osys:=$(word 3,$(targ))\n-endif\n-\n-# LIBGNAT_TARGET_PAIRS is a list of pairs of filenames.\n-# The members of each pair must be separated by a '<' and no whitespace.\n-# Each pair must be separated by some amount of whitespace from the following\n-# pair.\n-\n-# Non-tasking case:\n-\n-LIBGNAT_TARGET_PAIRS = \\\n-a-intnam.ads<a-intnam-dummy.ads \\\n-s-inmaop.adb<s-inmaop-dummy.adb \\\n-s-intman.adb<s-intman-dummy.adb \\\n-s-osinte.ads<s-osinte-dummy.ads \\\n-s-osprim.adb<s-osprim-posix.adb \\\n-s-taprop.adb<s-taprop-dummy.adb \\\n-s-taspri.ads<s-taspri-dummy.ads\n-\n-# When using the GCC exception handling mechanism, we need to use an\n-# alternate body for a-exexpr.adb (a-exexpr-gcc.adb)\n-\n-EH_MECHANISM=\n-\n-# Default shared object option. Note that we rely on the fact that the \"soname\"\n-# option will always be present and last in this flag, so that we can have\n-# $(SO_OPTS)libgnat-x.xx\n-\n-SO_OPTS = -Wl,-soname,\n-\n-# Default gnatlib-shared target.\n-# By default, equivalent to gnatlib.\n-# Set to gnatlib-shared-default, gnatlib-shared-dual, or a platform specific\n-# target when supported.\n-GNATLIB_SHARED = gnatlib\n-\n-# default value for gnatmake's target dependent file\n-MLIB_TGT = mlib-tgt\n-\n-# By default, do not distribute prefix.o (in libgccprefix), since it is only\n-# needed by external GNAT tools such as gnatdist and Glide.\n-# Override this variable on native platforms when needed.\n-PREFIX_OBJS =\n-\n-# To avoid duplicate code, use this variable to set PREFIX_OBJS when needed:\n-PREFIX_REAL_OBJS = ../prefix.o \\\n-  ../../libiberty/concat.o     \\\n-  ../../libiberty/xmalloc.o    \\\n-  ../../libiberty/xstrdup.o    \\\n-  ../../libiberty/xexit.o\n-\n-LIB_VERSION = $(strip $(shell grep ' Library_Version :' $(fsrcpfx)gnatvsn.ads | sed -e 's/.*\"\\(.*\\)\".*/\\1/'))\n-\n-# $(filter-out PATTERN...,TEXT) removes all PATTERN words from TEXT.\n-# $(strip STRING) removes leading and trailing spaces from STRING.\n-# If what's left is null then it's a match.\n-\n-ifeq ($(strip $(filter-out m68k% wrs vx%,$(targ))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-intnam.ads<a-intnam-vxworks.ads \\\n-  a-numaux.ads<a-numaux-vxworks.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-interr.adb<s-interr-vxworks.adb \\\n-  s-intman.ads<s-intman-vxworks.ads \\\n-  s-intman.adb<s-intman-vxworks.adb \\\n-  s-osinte.adb<s-osinte-vxworks.adb \\\n-  s-osinte.ads<s-osinte-vxworks.ads \\\n-  s-osprim.adb<s-osprim-vxworks.adb \\\n-  s-parame.ads<s-parame-vxworks.ads \\\n-  s-parame.adb<s-parame-vxworks.adb \\\n-  s-stchop.ads<s-stchop-limit.ads \\\n-  s-stchop.adb<s-stchop-vxworks.adb \\\n-  s-taprop.adb<s-taprop-vxworks.adb \\\n-  s-taspri.ads<s-taspri-vxworks.ads \\\n-  s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n-  s-vxwork.ads<s-vxwork-m68k.ads \\\n-  g-soccon.ads<g-soccon-vxworks.ads \\\n-  g-socthi.ads<g-socthi-vxworks.ads \\\n-  g-socthi.adb<g-socthi-vxworks.adb \\\n-  g-stsifd.adb<g-stsifd-sockets.adb \\\n-  g-sttsne.adb<g-sttsne-vxworks.adb \\\n-  g-sttsne.ads<g-sttsne-locking.ads \\\n-  system.ads<system-vxworks-m68k.ads\n-\n-  TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb\n-\n-  EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o\n-  EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n-\n-  EXTRA_LIBGNAT_SRCS+=vx_stack_info.c\n-  EXTRA_LIBGNAT_OBJS+=vx_stack_info.o\n-\n-  ifeq ($(strip $(filter-out yes,$(TRACE))),)\n-    LIBGNAT_TARGET_PAIRS += \\\n-    s-traces.adb<s-traces-default.adb \\\n-    s-tratas.adb<s-tratas-default.adb \\\n-    s-trafor.adb<s-trafor-default.adb \\\n-    s-trafor.ads<s-trafor-default.ads \\\n-    s-tfsetr.adb<s-tfsetr-vxworks.adb\n-  endif\n-endif\n-\n-ifeq ($(strip $(filter-out powerpc% wrs vxworks,$(targ))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-intnam.ads<a-intnam-vxworks.ads \\\n-  a-numaux.ads<a-numaux-vxworks.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.ads<s-intman-vxworks.ads \\\n-  s-intman.adb<s-intman-vxworks.adb \\\n-  s-osprim.adb<s-osprim-vxworks.adb \\\n-  s-parame.ads<s-parame-vxworks.ads \\\n-  s-parame.adb<s-parame-vxworks.adb \\\n-  s-stchop.ads<s-stchop-limit.ads \\\n-  s-stchop.adb<s-stchop-vxworks.adb \\\n-  s-taprop.adb<s-taprop-vxworks.adb \\\n-  s-taspri.ads<s-taspri-vxworks.ads \\\n-  s-vxwork.ads<s-vxwork-ppc.ads \\\n-  g-soccon.ads<g-soccon-vxworks.ads \\\n-  g-socthi.ads<g-socthi-vxworks.ads \\\n-  g-socthi.adb<g-socthi-vxworks.adb \\\n-  g-stsifd.adb<g-stsifd-sockets.adb \\\n-  g-sttsne.adb<g-sttsne-vxworks.adb \\\n-  g-sttsne.ads<g-sttsne-locking.ads\n-\n-  TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb\n-\n-  ifeq ($(strip $(filter-out yes,$(TRACE))),)\n-    LIBGNAT_TARGET_PAIRS += \\\n-    s-traces.adb<s-traces-default.adb \\\n-    s-trafor.adb<s-trafor-default.adb \\\n-    s-trafor.ads<s-trafor-default.ads \\\n-    s-tratas.adb<s-tratas-default.adb \\\n-    s-tfsetr.adb<s-tfsetr-vxworks.adb\n-  endif\n-\n-  ifeq ($(strip $(filter-out rtp,$(THREAD_KIND))),)\n-    LIBGNAT_TARGET_PAIRS += \\\n-    s-osinte.adb<s-osinte-vxworks-rtp.adb \\\n-    s-osinte.ads<s-osinte-vxworks6.ads \\\n-    s-tpopsp.adb<s-tpopsp-vxworks-rtp.adb \\\n-    system.ads<system-vxworks-ppc-rtp.ads\n-\n-    EXTRA_GNATRTL_NONTASKING_OBJS=s-vxwexc.o\n-  else\n-    LIBGNAT_TARGET_PAIRS += \\\n-    s-interr.adb<s-interr-vxworks.adb \\\n-    s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n-    system.ads<system-vxworks-ppc.ads\n-\n-    ifeq ($(strip $(filter-out kernel,$(THREAD_KIND))),)\n-      LIBGNAT_TARGET_PAIRS += \\\n-      s-osinte.ads<s-osinte-vxworks6.ads \\\n-      s-osinte.adb<s-osinte-vxworks-kernel.adb\n-    else\n-      LIBGNAT_TARGET_PAIRS += \\\n-      s-osinte.ads<s-osinte-vxworks.ads \\\n-      s-osinte.adb<s-osinte-vxworks.adb\n-    endif\n-\n-    EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o s-vxwexc.o\n-  endif\n-\n-  EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n-\n-  EXTRA_LIBGNAT_SRCS+=vx_stack_info.c\n-  EXTRA_LIBGNAT_OBJS+=vx_stack_info.o\n-endif\n-\n-# vxworksae / vxworks 653\n-ifeq ($(strip $(filter-out powerpc% wrs vxworksae,$(targ))),)\n-  # target pairs for kernel + vthreads runtime\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-elchha.adb<a-elchha-vxworks-ppc-full.adb \\\n-  a-intnam.ads<a-intnam-vxworks.ads \\\n-  a-numaux.ads<a-numaux-vxworks.ads \\\n-  g-io.adb<g-io-vxworks-ppc-cert.adb \\\n-  g-io.ads<g-io-vxworks-ppc-cert.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-interr.adb<s-interr-vxworks.adb \\\n-  s-intman.ads<s-intman-vxworks.ads \\\n-  s-intman.adb<s-intman-vxworks.adb \\\n-  s-osinte.adb<s-osinte-vxworks.adb \\\n-  s-osinte.ads<s-osinte-vxworks.ads \\\n-  s-osprim.adb<s-osprim-vxworks.adb \\\n-  s-parame.ads<s-parame-ae653.ads \\\n-  s-parame.adb<s-parame-vxworks.adb \\\n-  s-taprop.adb<s-taprop-vxworks.adb \\\n-  s-taspri.ads<s-taspri-vxworks.ads \\\n-  s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n-  s-vxwork.ads<s-vxwork-ppc.ads \\\n-  g-soccon.ads<g-soccon-vxworks.ads \\\n-  g-socthi.ads<g-socthi-vxworks.ads \\\n-  g-socthi.adb<g-socthi-vxworks.adb \\\n-  g-stsifd.adb<g-stsifd-sockets.adb \\\n-  g-sttsne.adb<g-sttsne-vxworks.adb \\\n-  g-sttsne.ads<g-sttsne-locking.ads \\\n-  system.ads<system-vxworks-ppc-vthread.ads\n-\n-  TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb\n-\n-  EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o s-vxwexc.o\n-  EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n-\n-  # Extra pairs for the vthreads runtime\n-  ifeq ($(strip $(filter-out vthreads,$(THREAD_KIND))),)\n-    LIBGNAT_TARGET_PAIRS += \\\n-    s-thread.adb<s-thread-ae653.adb\n-    EXTRA_GNATRTL_NONTASKING_OBJS += s-thread.o\n-  endif\n-\n-  ifeq ($(strip $(filter-out yes,$(TRACE))),)\n-    LIBGNAT_TARGET_PAIRS += \\\n-    s-traces.adb<s-traces-default.adb \\\n-    s-trafor.adb<s-trafor-default.adb \\\n-    s-trafor.ads<s-trafor-default.ads \\\n-    s-tratas.adb<s-tratas-default.adb \\\n-    s-tfsetr.adb<s-tfsetr-vxworks.adb\n-  endif\n-endif\n-\n-ifeq ($(strip $(filter-out sparc% wrs vx%,$(targ))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-intnam.ads<a-intnam-vxworks.ads \\\n-  a-numaux.ads<a-numaux-vxworks.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-interr.adb<s-interr-vxworks.adb \\\n-  s-intman.ads<s-intman-vxworks.ads \\\n-  s-intman.adb<s-intman-vxworks.adb \\\n-  s-osinte.adb<s-osinte-vxworks.adb \\\n-  s-osinte.ads<s-osinte-vxworks.ads \\\n-  s-osprim.adb<s-osprim-vxworks.adb \\\n-  s-parame.ads<s-parame-vxworks.ads \\\n-  s-parame.adb<s-parame-vxworks.adb \\\n-  s-stchop.ads<s-stchop-limit.ads \\\n-  s-stchop.adb<s-stchop-vxworks.adb \\\n-  s-taprop.adb<s-taprop-vxworks.adb \\\n-  s-taspri.ads<s-taspri-vxworks.ads \\\n-  s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n-  s-vxwork.ads<s-vxwork-sparcv9.ads \\\n-  g-soccon.ads<g-soccon-vxworks.ads \\\n-  g-socthi.ads<g-socthi-vxworks.ads \\\n-  g-socthi.adb<g-socthi-vxworks.adb \\\n-  g-stsifd.adb<g-stsifd-sockets.adb \\\n-  g-sttsne.adb<g-sttsne-vxworks.adb \\\n-  g-sttsne.ads<g-sttsne-locking.ads \\\n-  system.ads<system-vxworks-sparcv9.ads   \\\n-\n-  TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb\n-\n-  EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o\n-  EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n-\n-  EXTRA_LIBGNAT_SRCS+=vx_stack_info.c\n-  EXTRA_LIBGNAT_OBJS+=vx_stack_info.o\n-endif\n-\n-ifeq ($(strip $(filter-out %86 wrs vxworks,$(targ))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-intnam.ads<a-intnam-vxworks.ads \\\n-  i-vxwork.ads<i-vxwork-x86.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.ads<s-intman-vxworks.ads \\\n-  s-intman.adb<s-intman-vxworks.adb \\\n-  a-numaux.adb<a-numaux-x86.adb \\\n-  a-numaux.ads<a-numaux-x86.ads \\\n-  s-osprim.adb<s-osprim-vxworks.adb \\\n-  s-parame.ads<s-parame-vxworks.ads \\\n-  s-parame.adb<s-parame-vxworks.adb \\\n-  s-stchop.ads<s-stchop-limit.ads \\\n-  s-stchop.adb<s-stchop-vxworks.adb \\\n-  s-taprop.adb<s-taprop-vxworks.adb \\\n-  s-taspri.ads<s-taspri-vxworks.ads \\\n-  s-vxwork.ads<s-vxwork-x86.ads \\\n-  g-bytswa.adb<g-bytswa-x86.adb \\\n-  g-soccon.ads<g-soccon-vxworks.ads \\\n-  g-socthi.ads<g-socthi-vxworks.ads \\\n-  g-socthi.adb<g-socthi-vxworks.adb \\\n-  g-stsifd.adb<g-stsifd-sockets.adb \\\n-  g-sttsne.adb<g-sttsne-vxworks.adb \\\n-  g-sttsne.ads<g-sttsne-locking.ads\n-\n-  TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb\n-\n-  ifeq ($(strip $(filter-out yes,$(TRACE))),)\n-    LIBGNAT_TARGET_PAIRS += \\\n-    s-traces.adb<s-traces-default.adb \\\n-    s-trafor.adb<s-trafor-default.adb \\\n-    s-trafor.ads<s-trafor-default.ads \\\n-    s-tratas.adb<s-tratas-default.adb \\\n-    s-tfsetr.adb<s-tfsetr-vxworks.adb\n-  endif\n-\n-  ifeq ($(strip $(filter-out rtp,$(THREAD_KIND))),)\n-    LIBGNAT_TARGET_PAIRS += \\\n-    s-osinte.adb<s-osinte-vxworks-rtp.adb \\\n-    s-osinte.ads<s-osinte-vxworks6.ads \\\n-    s-tpopsp.adb<s-tpopsp-vxworks-rtp.adb \\\n-    system.ads<system-vxworks-x86-rtp.ads\n-\n-    EXTRA_GNATRTL_NONTASKING_OBJS=s-vxwexc.o\n-  else\n-    LIBGNAT_TARGET_PAIRS += \\\n-    s-interr.adb<s-interr-vxworks.adb \\\n-    s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n-    system.ads<system-vxworks-x86.ads\n-\n-    ifeq ($(strip $(filter-out kernel,$(THREAD_KIND))),)\n-      LIBGNAT_TARGET_PAIRS += \\\n-      s-osinte.ads<s-osinte-vxworks6.ads \\\n-      s-osinte.adb<s-osinte-vxworks-kernel.adb\n-    else\n-      LIBGNAT_TARGET_PAIRS += \\\n-      s-osinte.ads<s-osinte-vxworks.ads \\\n-      s-osinte.adb<s-osinte-vxworks.adb\n-    endif\n-\n-    EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o s-vxwexc.o\n-  endif\n-\n-  EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n-\n-  EXTRA_LIBGNAT_SRCS+=vx_stack_info.c\n-  EXTRA_LIBGNAT_OBJS+=vx_stack_info.o\n-endif\n-\n-ifeq ($(strip $(filter-out arm% coff wrs vx%,$(targ))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-intnam.ads<a-intnam-vxworks.ads \\\n-  a-numaux.ads<a-numaux-vxworks.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-interr.adb<s-interr-vxworks.adb \\\n-  s-intman.ads<s-intman-vxworks.ads \\\n-  s-intman.adb<s-intman-vxworks.adb \\\n-  s-osinte.adb<s-osinte-vxworks.adb \\\n-  s-osinte.ads<s-osinte-vxworks.ads \\\n-  s-osprim.adb<s-osprim-vxworks.adb \\\n-  s-parame.ads<s-parame-vxworks.ads \\\n-  s-parame.adb<s-parame-vxworks.adb \\\n-  s-stchop.ads<s-stchop-limit.ads \\\n-  s-stchop.adb<s-stchop-vxworks.adb \\\n-  s-taprop.adb<s-taprop-vxworks.adb \\\n-  s-taspri.ads<s-taspri-vxworks.ads \\\n-  s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n-  s-vxwork.ads<s-vxwork-arm.ads \\\n-  g-soccon.ads<g-soccon-vxworks.ads \\\n-  g-socthi.ads<g-socthi-vxworks.ads \\\n-  g-socthi.adb<g-socthi-vxworks.adb \\\n-  g-stsifd.adb<g-stsifd-sockets.adb \\\n-  g-sttsne.adb<g-sttsne-vxworks.adb \\\n-  g-sttsne.ads<g-sttsne-locking.ads \\\n-  system.ads<system-vxworks-arm.ads\n-\n-  TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb\n-\n-  EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o\n-  EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n-\n-  EXTRA_LIBGNAT_SRCS+=vx_stack_info.c\n-  EXTRA_LIBGNAT_OBJS+=vx_stack_info.o\n-endif\n-\n-ifeq ($(strip $(filter-out mips% wrs vx%,$(targ))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-intnam.ads<a-intnam-vxworks.ads \\\n-  a-numaux.ads<a-numaux-vxworks.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-interr.adb<s-interr-vxworks.adb \\\n-  s-intman.ads<s-intman-vxworks.ads \\\n-  s-intman.adb<s-intman-vxworks.adb \\\n-  s-osinte.adb<s-osinte-vxworks.adb \\\n-  s-osinte.ads<s-osinte-vxworks.ads \\\n-  s-osprim.adb<s-osprim-vxworks.adb \\\n-  s-parame.ads<s-parame-vxworks.ads \\\n-  s-parame.adb<s-parame-vxworks.adb \\\n-  s-stchop.ads<s-stchop-limit.ads \\\n-  s-stchop.adb<s-stchop-vxworks.adb \\\n-  s-taprop.adb<s-taprop-vxworks.adb \\\n-  s-taspri.ads<s-taspri-vxworks.ads \\\n-  s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n-  s-vxwork.ads<s-vxwork-mips.ads \\\n-  g-soccon.ads<g-soccon-vxworks.ads \\\n-  g-socthi.ads<g-socthi-vxworks.ads \\\n-  g-socthi.adb<g-socthi-vxworks.adb \\\n-  g-stsifd.adb<g-stsifd-sockets.adb \\\n-  g-sttsne.adb<g-sttsne-vxworks.adb \\\n-  g-sttsne.ads<g-sttsne-locking.ads \\\n-  system.ads<system-vxworks-mips.ads\n-\n-  TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb\n-\n-  EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o\n-  EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n-\n-  EXTRA_LIBGNAT_SRCS+=vx_stack_info.c\n-  EXTRA_LIBGNAT_OBJS+=vx_stack_info.o\n-endif\n-\n-ifeq ($(strip $(filter-out sparc% sun solaris%,$(targ))),)\n-  LIBGNAT_TARGET_PAIRS_32 = \\\n-  a-intnam.ads<a-intnam-solaris.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.adb<s-intman-solaris.adb \\\n-  s-osinte.adb<s-osinte-solaris.adb \\\n-  s-osinte.ads<s-osinte-solaris.ads \\\n-  s-osprim.adb<s-osprim-solaris.adb \\\n-  s-taprop.adb<s-taprop-solaris.adb \\\n-  s-tasinf.adb<s-tasinf-solaris.adb \\\n-  s-tasinf.ads<s-tasinf-solaris.ads \\\n-  s-taspri.ads<s-taspri-solaris.ads \\\n-  s-tpopsp.adb<s-tpopsp-solaris.adb \\\n-  g-soccon.ads<g-soccon-solaris.ads \\\n-  g-soliop.ads<g-soliop-solaris.ads \\\n-  system.ads<system-solaris-sparc.ads\n-\n-  LIBGNAT_TARGET_PAIRS_64 = \\\n-  a-intnam.ads<a-intnam-solaris.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.adb<s-intman-solaris.adb \\\n-  s-osinte.adb<s-osinte-solaris.adb \\\n-  s-osinte.ads<s-osinte-solaris.ads \\\n-  s-osprim.adb<s-osprim-solaris.adb \\\n-  s-taprop.adb<s-taprop-solaris.adb \\\n-  s-tasinf.adb<s-tasinf-solaris.adb \\\n-  s-tasinf.ads<s-tasinf-solaris.ads \\\n-  s-taspri.ads<s-taspri-solaris.ads \\\n-  s-tpopsp.adb<s-tpopsp-solaris.adb \\\n-  g-soccon.ads<g-soccon-solaris-64.ads \\\n-  g-soliop.ads<g-soliop-solaris.ads \\\n-  system.ads<system-solaris-sparcv9.ads\n-\n-  ifeq ($(strip $(filter-out sparc sun solaris%,$(targ))),)\n-    LIBGNAT_TARGET_PAIRS = $(LIBGNAT_TARGET_PAIRS_32)\n-  else\n-    LIBGNAT_TARGET_PAIRS = $(LIBGNAT_TARGET_PAIRS_64)\n-  endif\n-\n-  TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-solaris.adb\n-\n-  EH_MECHANISM=-gcc\n-  THREADSLIB = -lposix4 -lthread\n-  MISCLIB = -lposix4 -lnsl -lsocket\n-  SO_OPTS = -Wl,-h,\n-  GNATLIB_SHARED = gnatlib-shared-dual\n-  GMEM_LIB = gmemlib\n-  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(LIB_VERSION)\n-\n-  ifeq ($(strip $(filter-out pthread PTHREAD,$(THREAD_KIND))),)\n-    LIBGNAT_TARGET_PAIRS = \\\n-    a-intnam.ads<a-intnam-solaris.ads \\\n-    s-inmaop.adb<s-inmaop-posix.adb \\\n-    s-intman.adb<s-intman-posix.adb \\\n-    s-osinte.adb<s-osinte-posix.adb \\\n-    s-osinte.ads<s-osinte-solaris-posix.ads \\\n-    s-osprim.adb<s-osprim-solaris.adb \\\n-    s-taprop.adb<s-taprop-posix.adb \\\n-    s-taspri.ads<s-taspri-posix.ads \\\n-    s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-    g-soccon.ads<g-soccon-solaris.ads \\\n-    g-soliop.ads<g-soliop-solaris.ads \\\n-    system.ads<system-solaris-sparc.ads\n-\n-    THREADSLIB = -lposix4 -lpthread\n-  endif\n-\n-  ifeq ($(strip $(filter-out m64,$(THREAD_KIND))),)\n-    LIBGNAT_TARGET_PAIRS = $(LIBGNAT_TARGET_PAIRS_64)\n-  endif\n-endif\n-\n-ifeq ($(strip $(filter-out %86 solaris2%,$(arch) $(osys))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-numaux.adb<a-numaux-x86.adb \\\n-  a-numaux.ads<a-numaux-x86.ads \\\n-  a-intnam.ads<a-intnam-solaris.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.adb<s-intman-solaris.adb \\\n-  s-osinte.adb<s-osinte-solaris.adb \\\n-  s-osinte.ads<s-osinte-solaris.ads \\\n-  s-osprim.adb<s-osprim-solaris.adb \\\n-  s-taprop.adb<s-taprop-solaris.adb \\\n-  s-tasinf.adb<s-tasinf-solaris.adb \\\n-  s-tasinf.ads<s-tasinf-solaris.ads \\\n-  s-taspri.ads<s-taspri-solaris.ads \\\n-  s-tpopsp.adb<s-tpopsp-solaris.adb \\\n-  g-bytswa.adb<g-bytswa-x86.adb \\\n-  g-soccon.ads<g-soccon-solaris.ads \\\n-  g-soliop.ads<g-soliop-solaris.ads \\\n-  system.ads<system-solaris-x86.ads\n-\n-  TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-solaris.adb\n-\n-  EH_MECHANISM=-gcc\n-  THREADSLIB = -lposix4 -lthread\n-  MISCLIB = -lposix4 -lnsl -lsocket\n-  SO_OPTS = -Wl,-h,\n-  GNATLIB_SHARED = gnatlib-shared-dual\n-  GMEM_LIB = gmemlib\n-  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(LIB_VERSION)\n-endif\n-\n-ifeq ($(strip $(filter-out %86 linux%,$(arch) $(osys))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-intnam.ads<a-intnam-linux.ads \\\n-  a-numaux.adb<a-numaux-x86.adb \\\n-  a-numaux.ads<a-numaux-x86.ads \\\n-  g-bytswa.adb<g-bytswa-x86.adb \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.adb<s-intman-posix.adb \\\n-  s-osprim.adb<s-osprim-posix.adb \\\n-  s-taspri.ads<s-taspri-posix.ads \\\n-  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-  g-sercom.adb<g-sercom-linux.adb \\\n-  system.ads<system-linux-x86.ads\n-\n-  ifeq ($(strip $(filter-out marte,$(THREAD_KIND))),)\n-    LIBGNAT_TARGET_PAIRS += \\\n-    a-exetim.adb<a-exetim-linux-marte.adb \\\n-    a-exetim.ads<a-exetim-linux-marte.ads \\\n-    a-extiti.adb<a-extiti-linux-marte.adb \\\n-    a-extiti.ads<a-extiti-linux-marte.ads \\\n-    a-rttiev.adb<a-rttiev-linux-marte.adb \\\n-    a-rttiev.ads<a-rttiev-linux-marte.ads \\\n-    g-soccon.ads<g-soccon-linux-x86-marte.ads \\\n-    s-osinte.adb<s-osinte-linux-marte.adb \\\n-    s-osinte.ads<s-osinte-linux-marte.ads \\\n-    s-taprop.adb<s-taprop-linux-marte.adb\n-\n-    EXTRA_GNATRTL_TASKING_OBJS=a-exetim.o a-extiti.o\n-\n-    EH_MECHANISM=\n-    THREADSLIB = -lmarte\n-  else\n-    LIBGNAT_TARGET_PAIRS += \\\n-    g-soccon.ads<g-soccon-linux-x86.ads \\\n-    s-linux.ads<s-linux.ads \\\n-    s-osinte.adb<s-osinte-posix.adb \\\n-    s-osinte.ads<s-osinte-linux.ads \\\n-    s-tasinf.ads<s-tasinf-linux.ads \\\n-    s-tasinf.adb<s-tasinf-linux.adb \\\n-    s-taprop.adb<s-taprop-linux.adb\n-\n-    EH_MECHANISM=-gcc\n-    THREADSLIB = -lpthread\n-    EXTRA_GNATRTL_TASKING_OBJS=s-linux.o\n-  endif\n-\n-  TOOLS_TARGET_PAIRS =  \\\n-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \\\n-    indepsw.adb<indepsw-gnu.adb\n-\n-  GNATLIB_SHARED = gnatlib-shared-dual\n-  GMEM_LIB = gmemlib\n-  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(LIB_VERSION)\n-endif\n-\n-ifeq ($(strip $(filter-out %86 kfreebsd%,$(arch) $(osys))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-intnam.ads<a-intnam-freebsd.ads \\\n-  a-numaux.adb<a-numaux-x86.adb \\\n-  a-numaux.ads<a-numaux-x86.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.adb<s-intman-posix.adb \\\n-  g-soccon.ads<g-soccon-freebsd.ads \\\n-  s-osinte.adb<s-osinte-posix.adb \\\n-  s-osinte.ads<s-osinte-kfreebsd-gnu.ads \\\n-  s-osprim.adb<s-osprim-posix.adb \\\n-  s-taprop.adb<s-taprop-linux.adb \\\n-  s-tasinf.ads<s-tasinf-linux.ads \\\n-  s-tasinf.adb<s-tasinf-linux.adb \\\n-  s-taspri.ads<s-taspri-posix.ads \\\n-  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-  system.ads<system-freebsd-x86.ads\n-\n-  TOOLS_TARGET_PAIRS =  \\\n-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \\\n-    indepsw.adb<indepsw-gnu.adb\n-\n-  EH_MECHANISM=-gcc\n-  THREADSLIB = -lpthread\n-  GNATLIB_SHARED = gnatlib-shared-dual\n-  GMEM_LIB = gmemlib\n-  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(LIB_VERSION)\n-endif\n-\n-ifeq ($(strip $(filter-out %86 freebsd%,$(arch) $(osys))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-intnam.ads<a-intnam-freebsd.ads \\\n-  a-numaux.adb<a-numaux-x86.adb \\\n-  a-numaux.ads<a-numaux-x86.ads \\\n-  g-bytswa.adb<g-bytswa-x86.adb \\\n-  g-soccon.ads<g-soccon-freebsd.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.adb<s-intman-posix.adb \\\n-  s-osinte.adb<s-osinte-freebsd.adb \\\n-  s-osinte.ads<s-osinte-freebsd.ads \\\n-  s-osprim.adb<s-osprim-posix.adb \\\n-  s-taprop.adb<s-taprop-posix.adb \\\n-  s-taspri.ads<s-taspri-posix.ads \\\n-  s-tpopsp.adb<s-tpopsp-posix.adb \\\n-  system.ads<system-freebsd-x86.ads\n-\n-  TOOLS_TARGET_PAIRS = \\\n-  mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb\n-  GNATLIB_SHARED = gnatlib-shared-dual\n-\n-  EH_MECHANISM=-gcc\n-  THREADSLIB= -lpthread\n-  GMEM_LIB = gmemlib\n-  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(LIB_VERSION)\n-endif\n-\n-ifeq ($(strip $(filter-out s390% linux%,$(arch) $(osys))),)\n-  ifeq ($(strip $(filter-out s390x,$(arch))),)\n-    LIBGNAT_TARGET_PAIRS = \\\n-    a-intnam.ads<a-intnam-linux.ads \\\n-    s-inmaop.adb<s-inmaop-posix.adb \\\n-    s-intman.adb<s-intman-posix.adb \\\n-    s-linux.ads<s-linux.ads \\\n-    s-osinte.adb<s-osinte-posix.adb \\\n-    s-osinte.ads<s-osinte-linux.ads \\\n-    s-osprim.adb<s-osprim-posix.adb \\\n-    s-taprop.adb<s-taprop-linux.adb \\\n-    s-tasinf.ads<s-tasinf-linux.ads \\\n-    s-tasinf.adb<s-tasinf-linux.adb \\\n-    s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n-    s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-    system.ads<system-linux-s390x.ads\n-  else\n-    LIBGNAT_TARGET_PAIRS = \\\n-    a-intnam.ads<a-intnam-linux.ads \\\n-    s-inmaop.adb<s-inmaop-posix.adb \\\n-    s-intman.adb<s-intman-posix.adb \\\n-    s-linux.ads<s-linux.ads \\\n-    s-osinte.adb<s-osinte-posix.adb \\\n-    s-osinte.ads<s-osinte-linux.ads \\\n-    s-osprim.adb<s-osprim-posix.adb \\\n-    s-taprop.adb<s-taprop-linux.adb \\\n-    s-tasinf.ads<s-tasinf-linux.ads \\\n-    s-tasinf.adb<s-tasinf-linux.adb \\\n-    s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n-    s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-    system.ads<system-linux-s390.ads\n-  endif\n-\n-  TOOLS_TARGET_PAIRS =  \\\n-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb\n-\n-  EXTRA_GNATRTL_TASKING_OBJS=s-linux.o\n-  EH_MECHANISM=-gcc\n-  THREADSLIB = -lpthread\n-  GNATLIB_SHARED = gnatlib-shared-dual\n-  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(LIB_VERSION)\n-endif\n-\n-ifeq ($(strip $(filter-out mips sgi irix%,$(targ))),)\n-  ifeq ($(strip $(filter-out mips sgi irix6%,$(targ))),)\n-    LIBGNAT_TARGET_PAIRS = \\\n-    a-intnam.ads<a-intnam-irix.ads \\\n-    s-inmaop.adb<s-inmaop-posix.adb \\\n-    s-intman.adb<s-intman-irix.adb \\\n-    s-mastop.adb<s-mastop-irix.adb \\\n-    s-osinte.adb<s-osinte-irix.adb \\\n-    s-osinte.ads<s-osinte-irix.ads \\\n-    s-osprim.adb<s-osprim-posix.adb \\\n-    s-proinf.adb<s-proinf-irix-athread.adb \\\n-    s-proinf.ads<s-proinf-irix-athread.ads \\\n-    s-taprop.adb<s-taprop-irix.adb \\\n-    s-tasinf.ads<s-tasinf-irix.ads \\\n-    s-taspri.ads<s-taspri-posix.ads \\\n-    s-tpopsp.adb<s-tpopsp-posix.adb \\\n-    s-traceb.adb<s-traceb-mastop.adb \\\n-    g-soccon.ads<g-soccon-irix.ads \\\n-    system.ads<system-irix-n32.ads\n-\n-    THREADSLIB = -lpthread\n-    GNATLIB_SHARED = gnatlib-shared-default\n-\n-  else\n-    LIBGNAT_TARGET_PAIRS += \\\n-    s-mastop.adb<s-mastop-irix.adb \\\n-    s-osprim.adb<s-osprim-posix.adb \\\n-    s-traceb.adb<s-traceb-mastop.adb \\\n-    g-soccon.ads<g-soccon-irix.ads \\\n-    system.ads<system-irix-o32.ads\n-  endif\n-\n-  EH_MECHANISM=-gcc\n-  TOOLS_TARGET_PAIRS = mlib-tgt-specific.adb<mlib-tgt-specific-irix.adb\n-  TGT_LIB = -lexc\n-  MISCLIB = -lexc\n-  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(LIB_VERSION)\n-  GMEM_LIB = gmemlib\n-endif\n-\n-ifeq ($(strip $(filter-out hppa% hp hpux10%,$(targ))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-excpol.adb<a-excpol-abort.adb \\\n-  a-intnam.ads<a-intnam-hpux.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-interr.adb<s-interr-sigaction.adb \\\n-  s-intman.adb<s-intman-posix.adb \\\n-  s-osinte.adb<s-osinte-hpux-dce.adb \\\n-  s-osinte.ads<s-osinte-hpux-dce.ads \\\n-  s-parame.ads<s-parame-hpux.ads \\\n-  s-osprim.adb<s-osprim-posix.adb \\\n-  s-taprop.adb<s-taprop-hpux-dce.adb \\\n-  s-taspri.ads<s-taspri-hpux-dce.ads \\\n-  s-tpopsp.adb<s-tpopsp-posix.adb \\\n-  g-soccon.ads<g-soccon-hpux.ads \\\n-  system.ads<system-hpux.ads\n-\n-  EH_MECHANISM=-gcc\n-  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n-endif\n-\n-ifeq ($(strip $(filter-out hppa% hp hpux11%,$(targ))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-intnam.ads<a-intnam-hpux.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.adb<s-intman-posix.adb \\\n-  s-osinte.adb<s-osinte-posix.adb \\\n-  s-osinte.ads<s-osinte-hpux.ads \\\n-  s-parame.ads<s-parame-hpux.ads \\\n-  s-osprim.adb<s-osprim-posix.adb \\\n-  s-traceb.adb<s-traceb-hpux.adb \\\n-  s-taprop.adb<s-taprop-posix.adb \\\n-  s-taspri.ads<s-taspri-posix.ads \\\n-  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-  g-soccon.ads<g-soccon-hpux.ads \\\n-  system.ads<system-hpux.ads\n-\n-  TOOLS_TARGET_PAIRS = mlib-tgt-specific.adb<mlib-tgt-specific-hpux.adb\n-  EH_MECHANISM=-gcc\n-  TGT_LIB = /usr/lib/libcl.a\n-  THREADSLIB = -lpthread\n-  GMEM_LIB = gmemlib\n-  soext = .sl\n-  SO_OPTS = -Wl,+h,\n-  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n-  GNATLIB_SHARED = gnatlib-shared-dual\n-  LIBRARY_VERSION := $(LIB_VERSION)\n-endif\n-\n-ifeq ($(strip $(filter-out ibm aix%,$(manu) $(osys))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-intnam.ads<a-intnam-aix.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.adb<s-intman-posix.adb \\\n-  s-osinte.adb<s-osinte-aix.adb \\\n-  s-osinte.ads<s-osinte-aix.ads \\\n-  s-osprim.adb<s-osprim-posix.adb \\\n-  s-taprop.adb<s-taprop-posix.adb \\\n-  s-taspri.ads<s-taspri-posix.ads \\\n-  s-tpopsp.adb<s-tpopsp-posix.adb \\\n-  g-soccon.ads<g-soccon-aix.ads \\\n-  system.ads<system-aix.ads\n-\n-  THREADSLIB = -lpthreads\n-  PREFIX_OBJS=$(PREFIX_REAL_OBJS)\n-\n-  TOOLS_TARGET_PAIRS = \\\n-  mlib-tgt-specific.adb<mlib-tgt-specific-aix.adb \\\n-  indepsw.adb<indepsw-aix.adb\n-\n-  GMEM_LIB = gmemlib\n-endif\n-\n-ifeq ($(strip $(filter-out lynxos,$(osys))),)\n-  TOOLS_TARGET_PAIRS = \\\n-  mlib-tgt-specific.adb<mlib-tgt-specific-lynxos.adb \\\n-  indepsw.adb<indepsw-gnu.adb\n-\n-  ifeq ($(strip $(filter-out %86 lynxos,$(arch) $(osys))),)\n-    LIBGNAT_TARGET_PAIRS = \\\n-    a-numaux.adb<a-numaux-x86.adb \\\n-    a-numaux.ads<a-numaux-x86.ads \\\n-    a-intnam.ads<a-intnam-lynxos.ads \\\n-    g-bytswa.adb<g-bytswa-x86.adb \\\n-    g-soccon.ads<g-soccon-lynxos.ads \\\n-    g-sttsne.adb<g-sttsne-locking.adb \\\n-    g-sttsne.ads<g-sttsne-locking.ads \\\n-    s-inmaop.adb<s-inmaop-posix.adb \\\n-    s-intman.adb<s-intman-posix.adb \\\n-    s-osinte.adb<s-osinte-lynxos.adb \\\n-    s-osinte.ads<s-osinte-lynxos.ads \\\n-    s-osprim.adb<s-osprim-posix.adb \\\n-    s-taprop.adb<s-taprop-lynxos.adb \\\n-    s-taspri.ads<s-taspri-lynxos.ads \\\n-    s-tpopsp.adb<s-tpopsp-lynxos.adb \\\n-    system.ads<system-lynxos-x86.ads\n-\n-    PREFIX_OBJS=$(PREFIX_REAL_OBJS)\n-\n-  else\n-    LIBGNAT_TARGET_PAIRS = \\\n-    a-intnam.ads<a-intnam-lynxos.ads \\\n-    g-soccon.ads<g-soccon-lynxos.ads \\\n-    g-sttsne.adb<g-sttsne-locking.adb \\\n-    g-sttsne.ads<g-sttsne-locking.ads \\\n-    s-inmaop.adb<s-inmaop-posix.adb \\\n-    s-intman.adb<s-intman-posix.adb \\\n-    s-osinte.adb<s-osinte-lynxos.adb \\\n-    s-osinte.ads<s-osinte-lynxos.ads \\\n-    s-osprim.adb<s-osprim-posix.adb \\\n-    s-taprop.adb<s-taprop-lynxos.adb \\\n-    s-taspri.ads<s-taspri-lynxos.ads \\\n-    s-tpopsp.adb<s-tpopsp-lynxos.adb \\\n-    system.ads<system-lynxos-ppc.ads\n-  endif\n-endif\n-\n-ifeq ($(strip $(filter-out rtems%,$(osys))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  system.ads<system-rtems.ads \\\n-  a-intnam.ads<a-intnam-rtems.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.adb<s-intman-posix.adb \\\n-  s-osinte.adb<s-osinte-rtems.adb \\\n-  s-osinte.ads<s-osinte-rtems.ads \\\n-  s-osprim.adb<s-osprim-posix.adb \\\n-  s-parame.adb<s-parame-rtems.adb \\\n-  s-taprop.adb<s-taprop-posix.adb \\\n-  s-taspri.ads<s-taspri-posix.ads \\\n-  s-tpopsp.adb<s-tpopsp-rtems.adb \\\n-  g-soccon.ads<g-soccon-rtems.ads \\\n-  s-stchop.adb<s-stchop-rtems.adb\n-endif\n-\n-ifeq ($(strip $(filter-out alpha% dec osf%,$(targ))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-intnam.ads<a-intnam-tru64.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.adb<s-intman-posix.adb \\\n-  s-mastop.adb<s-mastop-tru64.adb \\\n-  s-osinte.adb<s-osinte-tru64.adb \\\n-  s-osinte.ads<s-osinte-tru64.ads \\\n-  s-osprim.adb<s-osprim-unix.adb \\\n-  s-taprop.adb<s-taprop-tru64.adb \\\n-  s-tasinf.ads<s-tasinf-tru64.ads \\\n-  s-taspri.ads<s-taspri-tru64.ads \\\n-  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-  s-traceb.adb<s-traceb-mastop.adb \\\n-  g-soccon.ads<g-soccon-tru64.ads \\\n-  system.ads<system-tru64.ads\n-\n-  TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-tru64.adb\n-\n-  EH_MECHANISM=-gcc\n-  GMEM_LIB=gmemlib\n-  THREADSLIB = -lpthread -lmach -lexc -lrt\n-  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n-  GNATLIB_SHARED = gnatlib-shared-default\n-  LIBRARY_VERSION := $(LIB_VERSION)\n-endif\n-\n-ifeq ($(strip $(filter-out alpha64 ia64 dec hp vms% openvms% alphavms%,$(host))),)\n-\n-soext  = .exe\n-hyphen = _\n-LN = cp -p\n-LN_S = cp -p\n-\n-.SUFFIXES: .sym\n-\n-.o.sym:\n-\t@ gnu:[bin]vmssymvec $<\n-endif\n-\n-ifeq ($(strip $(filter-out alpha64 ia64 dec hp vms% openvms% alphavms%,$(targ))),)\n-ifeq ($(strip $(filter-out ia64 hp vms% openvms%,$(targ))),)\n-  LIBGNAT_TARGET_PAIRS_AUX1 = \\\n-  g-enblsp.adb<g-enblsp-vms-ia64.adb \\\n-  g-trasym.adb<g-trasym-vms-ia64.adb \\\n-  s-asthan.adb<s-asthan-vms-ia64.adb \\\n-  s-osinte.adb<s-osinte-vms-ia64.adb \\\n-  s-osinte.ads<s-osinte-vms-ia64.ads \\\n-  s-vaflop.adb<s-vaflop-vms-ia64.adb \\\n-  system.ads<system-vms-ia64.ads\n-\n-  LIBGNAT_TARGET_PAIRS_AUX2 = \\\n-  s-parame.ads<s-parame-vms-ia64.ads\n-else\n-ifeq ($(strip $(filter-out alpha64 dec vms% openvms% alphavms%,$(targ))),)\n-  LIBGNAT_TARGET_PAIRS_AUX1 = \\\n-  g-enblsp.adb<g-enblsp-vms-alpha.adb \\\n-  g-trasym.adb<g-trasym-vms-alpha.adb \\\n-  s-traent.adb<s-traent-vms.adb \\\n-  s-traent.ads<s-traent-vms.ads \\\n-  s-asthan.adb<s-asthan-vms-alpha.adb \\\n-  s-osinte.adb<s-osinte-vms.adb \\\n-  s-osinte.ads<s-osinte-vms.ads \\\n-  s-vaflop.adb<s-vaflop-vms-alpha.adb \\\n-  system.ads<system-vms_64.ads\n-\n-ifeq ($(strip $(filter-out express EXPRESS,$(THREAD_KIND))),)\n-  LIBGNAT_TARGET_PAIRS_AUX2 = \\\n-  s-parame.ads<s-parame-vms-restrict.ads\n-else\n-  LIBGNAT_TARGET_PAIRS_AUX2 = \\\n-  s-parame.ads<s-parame-vms-alpha.ads\n-endif\n-endif\n-endif\n-\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-caldel.adb<a-caldel-vms.adb \\\n-  a-calend.adb<a-calend-vms.adb \\\n-  a-calend.ads<a-calend-vms.ads \\\n-  a-dirval.adb<a-dirval-vms.adb \\\n-  a-excpol.adb<a-excpol-abort.adb \\\n-  a-intnam.ads<a-intnam-vms.ads \\\n-  a-numaux.ads<a-numaux-vms.ads \\\n-  g-expect.adb<g-expect-vms.adb \\\n-  g-soccon.ads<g-soccon-vms.ads \\\n-  g-socthi.ads<g-socthi-vms.ads \\\n-  g-socthi.adb<g-socthi-vms.adb \\\n-  g-stsifd.adb<g-stsifd-sockets.adb \\\n-  g-sttsne.adb<g-sttsne-locking.adb \\\n-  g-sttsne.ads<g-sttsne-locking.ads \\\n-  i-c.ads<i-c-vms_64.ads \\\n-  i-cstrin.ads<i-cstrin-vms_64.ads \\\n-  i-cstrin.adb<i-cstrin-vms_64.adb \\\n-  i-cpoint.ads<i-cpoint-vms_64.ads \\\n-  i-cpoint.adb<i-cpoint-vms_64.adb \\\n-  i-cstrea.adb<i-cstrea-vms.adb \\\n-  memtrack.adb<memtrack-vms_64.adb \\\n-  s-auxdec.ads<s-auxdec-vms_64.ads \\\n-  s-crtl.ads<s-crtl-vms_64.ads \\\n-  s-inmaop.adb<s-inmaop-vms.adb \\\n-  s-interr.adb<s-interr-vms.adb \\\n-  s-intman.adb<s-intman-vms.adb \\\n-  s-intman.ads<s-intman-vms.ads \\\n-  s-memory.adb<s-memory-vms_64.adb \\\n-  s-memory.ads<s-memory-vms_64.ads \\\n-  s-osprim.adb<s-osprim-vms.adb \\\n-  s-osprim.ads<s-osprim-vms.ads \\\n-  s-taprop.adb<s-taprop-vms.adb \\\n-  s-taspri.ads<s-taspri-vms.ads \\\n-  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-  s-tpopde.adb<s-tpopde-vms.adb \\\n-  s-tpopde.ads<s-tpopde-vms.ads \\\n-  $(LIBGNAT_TARGET_PAIRS_AUX1) \\\n-  $(LIBGNAT_TARGET_PAIRS_AUX2)\n-\n-ifeq ($(strip $(filter-out ia64 hp vms% openvms%,$(targ))),)\n-  TOOLS_TARGET_PAIRS= \\\n-  mlib-tgt-specific.adb<mlib-tgt-specific-vms-ia64.adb \\\n-  symbols.adb<symbols-vms.adb \\\n-  symbols-processing.adb<symbols-processing-vms-ia64.adb\n-else\n-  TOOLS_TARGET_PAIRS= \\\n-  mlib-tgt-specific.adb<mlib-tgt-specific-vms-alpha.adb \\\n-  symbols.adb<symbols-vms.adb \\\n-  symbols-processing.adb<symbols-processing-vms-alpha.adb\n-endif\n-\n-adamsg.o: adamsg.msg\n-\t-$(DECC) --cc=message adamsg.msg -o adamsg.o\n-\n-  EXTRA_GNATMAKE_OBJS = mlib-tgt-vms_common.o\n-\n-  GMEM_LIB = gmemlib\n-  EH_MECHANISM=-gcc\n-  GNATLIB_SHARED=gnatlib-shared-vms\n-ifeq ($(strip $(filter-out alpha64 dec vms% openvms% alphavms%,$(targ))),)\n-  EXTRA_LIBGNAT_SRCS=vmshandler.asm\n-  EXTRA_LIBGNAT_OBJS=vmshandler.o\n-endif\n-  EXTRA_LIBGNAT_SRCS+=adamsg.msg\n-  EXTRA_LIBGNAT_OBJS+=adamsg.o\n-  EXTRA_GNATRTL_TASKING_OBJS=s-tpopde.o\n-  EXTRA_GNATTOOLS = \\\n-     ../../gnatlbr$(exeext)  \\\n-     ../../gnatsym$(exeext)  \\\n-     ../../vms_help$(exeext) \\\n-     ../../gnat.hlp\n-  # This command transforms (YYYYMMDD) into YY,MMDD\n-  GSMATCH_VERSION := $(shell grep \"^ *Gnat_Static_Version_String\" $(fsrcpfx)gnatvsn.ads | sed -e 's/.*(\\(.*\\)).*/\\1/' -e 's/\\(..\\)\\(..\\)\\(....\\).*/\\2,\\3/')\n-  TOOLS_LIBS_LO := --for-linker=sys\\\\$$\\$$library:trace.exe\n-  LIBRARY_VERSION := $(subst .,_,$(LIB_VERSION))\n-endif\n-\n-ifeq ($(strip $(filter-out cygwin32% mingw32% pe,$(osys))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-dirval.adb<a-dirval-mingw.adb \\\n-  a-excpol.adb<a-excpol-abort.adb \\\n-  a-numaux.adb<a-numaux-x86.adb \\\n-  a-numaux.ads<a-numaux-x86.ads \\\n-  s-gloloc.adb<s-gloloc-mingw.adb \\\n-  s-inmaop.adb<s-inmaop-dummy.adb \\\n-  s-memory.adb<s-memory-mingw.adb \\\n-  s-taspri.ads<s-taspri-mingw.ads \\\n-  s-tasinf.adb<s-tasinf-mingw.adb \\\n-  s-tasinf.ads<s-tasinf-mingw.ads \\\n-  g-bytswa.adb<g-bytswa-x86.adb \\\n-  g-socthi.ads<g-socthi-mingw.ads \\\n-  g-socthi.adb<g-socthi-mingw.adb \\\n-  g-stsifd.adb<g-stsifd-sockets.adb \\\n-  g-soccon.ads<g-soccon-mingw.ads \\\n-  g-soliop.ads<g-soliop-mingw.ads\n-\n-  ifeq ($(strip $(filter-out rtx_w32 rtx_rtss,$(THREAD_KIND))),)\n-    LIBGNAT_TARGET_PAIRS += \\\n-    s-intman.adb<s-intman-dummy.adb \\\n-    s-osinte.ads<s-osinte-rtx.ads \\\n-    s-osprim.adb<s-osprim-rtx.adb \\\n-    s-taprop.adb<s-taprop-rtx.adb \\\n-    system.ads<system-rtx.ads\n-\n-    EXTRA_GNATRTL_NONTASKING_OBJS = s-win32.o\n-\n-    MISCLIB = -lwsock32 -lrtapi_w32\n-    THREADSLIB=-lrtapi_w32\n-  else\n-    LIBGNAT_TARGET_PAIRS += \\\n-    a-exetim.adb<a-exetim-mingw.adb \\\n-    a-exetim.ads<a-exetim-mingw.ads \\\n-    a-intnam.ads<a-intnam-mingw.ads \\\n-    g-sercom.adb<g-sercom-mingw.adb \\\n-    s-interr.adb<s-interr-sigaction.adb \\\n-    s-intman.adb<s-intman-mingw.adb \\\n-    s-osinte.ads<s-osinte-mingw.ads \\\n-    s-osprim.adb<s-osprim-mingw.adb \\\n-    s-taprop.adb<s-taprop-mingw.adb \\\n-    system.ads<system-mingw.ads\n-\n-    EXTRA_GNATRTL_NONTASKING_OBJS = s-win32.o g-regist.o\n-    EXTRA_GNATRTL_TASKING_OBJS = a-exetim.o\n-\n-    MISCLIB = -lwsock32\n-\n-    # ??? This will be replaced by gnatlib-shared-dual-win32 when GNAT\n-    # auto-import support for array/record will be done.\n-    GNATLIB_SHARED = gnatlib-shared-win32\n-  endif\n-\n-  TOOLS_TARGET_PAIRS= \\\n-  mlib-tgt-specific.adb<mlib-tgt-specific-mingw.adb \\\n-  indepsw.adb<indepsw-mingw.adb\n-\n-  EH_MECHANISM=-gcc\n-  GMEM_LIB = gmemlib\n-  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n-  EXTRA_GNATTOOLS = ../../gnatdll$(exeext)\n-  EXTRA_GNATMAKE_OBJS = mdll.o mdll-utl.o mdll-fil.o\n-  soext = .dll\n-  LIBRARY_VERSION := $(LIB_VERSION)\n-endif\n-\n-ifeq ($(strip $(filter-out mips linux%,$(arch) $(osys))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-intnam.ads<a-intnam-linux.ads \\\n-  g-soccon.ads<g-soccon-linux-mips.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.adb<s-intman-posix.adb \\\n-  s-linux.ads<s-linux.ads \\\n-  s-osinte.adb<s-osinte-posix.adb \\\n-  s-osinte.ads<s-osinte-linux.ads \\\n-  s-osprim.adb<s-osprim-posix.adb \\\n-  s-taprop.adb<s-taprop-linux.adb \\\n-  s-tasinf.ads<s-tasinf-linux.ads \\\n-  s-tasinf.adb<s-tasinf-linux.adb \\\n-  s-taspri.ads<s-taspri-posix.ads \\\n-  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-  system.ads<system-linux-mips.ads\n-\n-  EH_MECHANISM=-gcc\n-  THREADSLIB = -lpthread\n-  GNATLIB_SHARED = gnatlib-shared-dual\n-  GMEM_LIB = gmemlib\n-  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(LIB_VERSION)\n-endif\n-\n-ifeq ($(strip $(filter-out mipsel linux%,$(arch) $(osys))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-intnam.ads<a-intnam-linux.ads \\\n-  g-soccon.ads<g-soccon-linux-mips.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.adb<s-intman-posix.adb \\\n-  s-linux.ads<s-linux.ads \\\n-  s-osinte.adb<s-osinte-posix.adb \\\n-  s-osinte.ads<s-osinte-linux.ads \\\n-  s-osprim.adb<s-osprim-posix.adb \\\n-  s-taprop.adb<s-taprop-linux.adb \\\n-  s-tasinf.ads<s-tasinf-linux.ads \\\n-  s-tasinf.adb<s-tasinf-linux.adb \\\n-  s-taspri.ads<s-taspri-posix.ads \\\n-  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-  system.ads<system-linux-mipsel.ads\n-\n-  EH_MECHANISM=-gcc\n-  THREADSLIB = -lpthread\n-  GNATLIB_SHARED = gnatlib-shared-dual\n-  GMEM_LIB = gmemlib\n-  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(LIB_VERSION)\n-endif\n-\n-ifeq ($(strip $(filter-out powerpc% linux%,$(arch) $(osys))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-intnam.ads<a-intnam-linux.ads \\\n-  g-soccon.ads<g-soccon-linux-ppc.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.adb<s-intman-posix.adb \\\n-  s-linux.ads<s-linux.ads \\\n-  s-osinte.adb<s-osinte-posix.adb \\\n-  s-osinte.ads<s-osinte-linux.ads \\\n-  s-osprim.adb<s-osprim-posix.adb \\\n-  s-taprop.adb<s-taprop-linux.adb \\\n-  s-tasinf.ads<s-tasinf-linux.ads \\\n-  s-tasinf.adb<s-tasinf-linux.adb \\\n-  s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n-  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-  g-sercom.adb<g-sercom-linux.adb \\\n-  system.ads<system-linux-ppc.ads\n-\n-  TOOLS_TARGET_PAIRS =  \\\n-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \\\n-    indepsw.adb<indepsw-gnu.adb\n-\n-  EXTRA_GNATRTL_TASKING_OBJS=s-linux.o\n-  EH_MECHANISM=-gcc\n-  THREADSLIB = -lpthread\n-  GNATLIB_SHARED = gnatlib-shared-dual\n-  GMEM_LIB = gmemlib\n-  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(LIB_VERSION)\n-endif\n-\n-ifeq ($(strip $(filter-out sparc% linux%,$(arch) $(osys))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-intnam.ads<a-intnam-linux.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.adb<s-intman-posix.adb \\\n-  s-linux.ads<s-linux.ads \\\n-  s-osinte.adb<s-osinte-posix.adb \\\n-  s-osinte.ads<s-osinte-linux.ads \\\n-  s-osprim.adb<s-osprim-posix.adb \\\n-  s-taprop.adb<s-taprop-linux.adb \\\n-  s-tasinf.ads<s-tasinf-linux.ads \\\n-  s-tasinf.adb<s-tasinf-linux.adb \\\n-  s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n-  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-  system.ads<system-linux-sparc.ads\n-\n-  TOOLS_TARGET_PAIRS =  \\\n-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \\\n-    indepsw.adb<indepsw-gnu.adb\n-\n-  EXTRA_GNATRTL_TASKING_OBJS=s-linux.o\n-  EH_MECHANISM=-gcc\n-  THREADSLIB = -lpthread\n-  GNATLIB_SHARED = gnatlib-shared-dual\n-  GMEM_LIB = gmemlib\n-  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(LIB_VERSION)\n-endif\n-\n-ifeq ($(strip $(filter-out hppa% linux%,$(arch) $(osys))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-intnam.ads<a-intnam-linux.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.adb<s-intman-posix.adb \\\n-  s-linux.ads<s-linux-hppa.ads \\\n-  s-osinte.adb<s-osinte-posix.adb \\\n-  s-osinte.ads<s-osinte-linux.ads \\\n-  s-osprim.adb<s-osprim-posix.adb \\\n-  s-taprop.adb<s-taprop-linux.adb \\\n-  s-tasinf.ads<s-tasinf-linux.ads \\\n-  s-tasinf.adb<s-tasinf-linux.adb \\\n-  s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n-  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-  system.ads<system-linux-hppa.ads\n-\n-  TOOLS_TARGET_PAIRS =  \\\n-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \\\n-    indepsw.adb<indepsw-gnu.adb\n-\n-  EXTRA_GNATRTL_TASKING_OBJS=s-linux.o\n-  EH_MECHANISM=-gcc\n-  THREADSLIB = -lpthread\n-  GNATLIB_SHARED = gnatlib-shared-dual\n-  GMEM_LIB = gmemlib\n-  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(LIB_VERSION)\n-endif\n-\n-ifeq ($(strip $(filter-out sh4% linux%,$(arch) $(osys))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-intnam.ads<a-intnam-linux.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.adb<s-intman-posix.adb \\\n-  s-linux.ads<s-linux.ads \\\n-  s-osinte.adb<s-osinte-posix.adb \\\n-  s-osinte.ads<s-osinte-linux.ads \\\n-  s-osprim.adb<s-osprim-posix.adb \\\n-  s-taprop.adb<s-taprop-linux.adb \\\n-  s-tasinf.ads<s-tasinf-linux.ads \\\n-  s-tasinf.adb<s-tasinf-linux.adb \\\n-  s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n-  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-  system.ads<system-linux-sh4.ads\n-\n-  TOOLS_TARGET_PAIRS =  \\\n-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \\\n-    indepsw.adb<indepsw-linux.adb\n-\n-  EXTRA_GNATRTL_TASKING_OBJS=s-linux.o\n-  EH_MECHANISM=-gcc\n-  MISCLIB=\n-  THREADSLIB = -lpthread\n-  GNATLIB_SHARED = gnatlib-shared-dual\n-  GMEM_LIB = gmemlib\n-  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(LIB_VERSION)\n-endif\n-\n-ifeq ($(strip $(filter-out %ia64 linux%,$(arch) $(osys))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-intnam.ads<a-intnam-linux.ads \\\n-  a-numaux.ads<a-numaux-libc-x86.ads \\\n-  g-soccon.ads<g-soccon-linux-64.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.adb<s-intman-posix.adb \\\n-  s-linux.ads<s-linux.ads \\\n-  s-osinte.ads<s-osinte-linux.ads \\\n-  s-osinte.adb<s-osinte-posix.adb \\\n-  s-osprim.adb<s-osprim-posix.adb \\\n-  s-taprop.adb<s-taprop-linux.adb \\\n-  s-tasinf.ads<s-tasinf-linux.ads \\\n-  s-tasinf.adb<s-tasinf-linux.adb \\\n-  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-  s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n-  g-sercom.adb<g-sercom-linux.adb \\\n-  system.ads<system-linux-ia64.ads\n-\n-  TOOLS_TARGET_PAIRS =  \\\n-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \\\n-    indepsw.adb<indepsw-gnu.adb\n-\n-  EXTRA_GNATRTL_TASKING_OBJS=s-linux.o\n-  EH_MECHANISM=-gcc\n-  MISCLIB=\n-  THREADSLIB=-lpthread\n-  GNATLIB_SHARED=gnatlib-shared-dual\n-  GMEM_LIB = gmemlib\n-  PREFIX_OBJS=$(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(LIB_VERSION)\n-endif\n-\n-ifeq ($(strip $(filter-out alpha% linux%,$(arch) $(osys))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-intnam.ads<a-intnam-linux.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.adb<s-intman-posix.adb \\\n-  s-linux.ads<s-linux-alpha.ads \\\n-  s-osinte.ads<s-osinte-linux.ads \\\n-  s-osinte.adb<s-osinte-posix.adb \\\n-  s-osprim.adb<s-osprim-posix.adb \\\n-  s-taprop.adb<s-taprop-linux.adb \\\n-  s-tasinf.ads<s-tasinf-linux.ads \\\n-  s-tasinf.adb<s-tasinf-linux.adb \\\n-  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-  s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n-  system.ads<system-linux-alpha.ads\n-\n-  TOOLS_TARGET_PAIRS =  \\\n-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \\\n-    indepsw.adb<indepsw-gnu.adb\n-\n-  EXTRA_GNATRTL_TASKING_OBJS=s-linux.o\n-  EH_MECHANISM=-gcc\n-  MISCLIB=\n-  THREADSLIB=-lpthread\n-  GNATLIB_SHARED=gnatlib-shared-dual\n-  PREFIX_OBJS=$(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(LIB_VERSION)\n-endif\n-\n-ifeq ($(strip $(filter-out %x86_64 linux%,$(arch) $(osys))),)\n-  LIBGNAT_TARGET_PAIRS = \\\n-  a-intnam.ads<a-intnam-linux.ads \\\n-  a-numaux.adb<a-numaux-x86.adb \\\n-  a-numaux.ads<a-numaux-x86.ads \\\n-  g-soccon.ads<g-soccon-linux-64.ads \\\n-  s-inmaop.adb<s-inmaop-posix.adb \\\n-  s-intman.adb<s-intman-posix.adb \\\n-  s-linux.ads<s-linux.ads \\\n-  s-osinte.ads<s-osinte-linux.ads \\\n-  s-osinte.adb<s-osinte-posix.adb \\\n-  s-osprim.adb<s-osprim-posix.adb \\\n-  s-taprop.adb<s-taprop-linux.adb \\\n-  s-tasinf.ads<s-tasinf-linux.ads \\\n-  s-tasinf.adb<s-tasinf-linux.adb \\\n-  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-  s-taspri.ads<s-taspri-posix.ads \\\n-  g-sercom.adb<g-sercom-linux.adb \\\n-  system.ads<system-linux-x86_64.ads\n-\n-  TOOLS_TARGET_PAIRS =  \\\n-    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \\\n-    indepsw.adb<indepsw-gnu.adb\n-\n-  EXTRA_GNATRTL_TASKING_OBJS=s-linux.o\n-  EH_MECHANISM=-gcc\n-  THREADSLIB=-lpthread\n-  GNATLIB_SHARED=gnatlib-shared-dual\n-  GMEM_LIB = gmemlib\n-  PREFIX_OBJS=$(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(LIB_VERSION)\n-endif\n-\n-ifeq ($(strip $(filter-out darwin%,$(osys))),)\n-  ifeq ($(strip $(filter-out %86,$(arch))),)\n-    LIBGNAT_TARGET_PAIRS = \\\n-    a-intnam.ads<a-intnam-darwin.ads \\\n-    s-inmaop.adb<s-inmaop-posix.adb \\\n-    s-intman.adb<s-intman-posix.adb \\\n-    s-osinte.adb<s-osinte-darwin.adb \\\n-    s-osinte.ads<s-osinte-darwin.ads \\\n-    s-osprim.adb<s-osprim-posix.adb \\\n-    s-taprop.adb<s-taprop-posix.adb \\\n-    s-taspri.ads<s-taspri-posix.ads \\\n-    s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-    g-soccon.ads<g-soccon-darwin.ads \\\n-    a-numaux.ads<a-numaux-x86.ads \\\n-    a-numaux.adb<a-numaux-x86.adb \\\n-    system.ads<system-darwin-x86.ads\n-  else\n-    LIBGNAT_TARGET_PAIRS = \\\n-    a-intnam.ads<a-intnam-darwin.ads \\\n-    s-inmaop.adb<s-inmaop-posix.adb \\\n-    s-intman.adb<s-intman-posix.adb \\\n-    s-osinte.adb<s-osinte-darwin.adb \\\n-    s-osinte.ads<s-osinte-darwin.ads \\\n-    s-osprim.adb<s-osprim-posix.adb \\\n-    s-taprop.adb<s-taprop-posix.adb \\\n-    s-taspri.ads<s-taspri-posix.ads \\\n-    s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n-    g-soccon.ads<g-soccon-darwin.ads \\\n-    a-numaux.ads<a-numaux-darwin.ads \\\n-    a-numaux.adb<a-numaux-darwin.adb \\\n-    system.ads<system-darwin-ppc.ads\n-  endif\n-\n-  TOOLS_TARGET_PAIRS =  \\\n-    mlib-tgt-specific.adb<mlib-tgt-specific-darwin.adb\n-\n-  EH_MECHANISM=-gcc\n-  GNATLIB_SHARED = gnatlib-shared-darwin\n-  SO_OPTS = -Wl,-flat_namespace -shared-libgcc\n-  RANLIB = ranlib -c\n-  GMEM_LIB = gmemlib\n-  PREFIX_OBJS=$(PREFIX_REAL_OBJS)\n-  LIBRARY_VERSION := $(LIB_VERSION)\n-  soext = .dylib\n-endif\n-\n-ifneq ($(EH_MECHANISM),)\n-  LIBGNAT_TARGET_PAIRS += a-exexpr.adb<a-exexpr$(EH_MECHANISM).adb\n-  EXTRA_LIBGNAT_SRCS+=raise$(EH_MECHANISM).c\n-  EXTRA_LIBGNAT_OBJS+=raise$(EH_MECHANISM).o\n-endif\n-\n-# Use the Ada 2005 version of Ada.Exceptions by default, unless specified\n-# explicitly already. The base files (a-except.ad?) are used only for building\n-# the compiler and other basic tools.\n-# These base versions lack Ada 2005 additions which would cause bootstrap\n-# problems if included in the compiler and other basic tools.\n-\n-ifeq ($(filter-out a-except%,$(LIBGNAT_TARGET_PAIRS)),$(LIBGNAT_TARGET_PAIRS))\n-  LIBGNAT_TARGET_PAIRS += \\\n-    a-except.ads<a-except-2005.ads \\\n-    a-except.adb<a-except-2005.adb\n-endif\n-\n-# The runtime library for gnat comprises two directories.  One contains the\n-# Ada source files that the compiler (gnat1) needs -- these files are listed\n-# by ADA_INCLUDE_SRCS -- and the other contains the object files and their\n-# corresponding .ali files for the parts written in Ada, libgnat.a for\n-# the parts of the runtime written in C, and libgthreads.a for the pthreads\n-# emulation library.  LIBGNAT_OBJS lists the objects that go into libgnat.a,\n-# while GNATRTL_OBJS lists the object files compiled from Ada sources that\n-# go into the directory.  The pthreads emulation is built in the threads\n-# subdirectory and copied.\n-LIBGNAT_SRCS = ada.h adaint.c adaint.h argv.c cio.c cstreams.c \\\n-  errno.c exit.c cal.c ctrl_c.c env.c env.h \\\n-  raise.h raise.c sysdep.c aux-io.c init.c initialize.c seh_init.c \\\n-  final.c tracebak.c tb-alvms.c tb-alvxw.c tb-gcc.c expect.c mkdir.c \\\n-  socket.c gsocket.h targext.c $(EXTRA_LIBGNAT_SRCS)\n-\n-LIBGNAT_OBJS = adaint.o argv.o cio.o cstreams.o ctrl_c.o errno.o exit.o env.o \\\n-  raise.o sysdep.o aux-io.o init.o initialize.o seh_init.o cal.o \\\n-  final.o tracebak.o expect.o mkdir.o socket.o targext.o $(EXTRA_LIBGNAT_OBJS)\n-\n-# NOTE ??? - when the -I option for compiling Ada code is made to work,\n-#  the library installation will change and there will be a\n-#  GNAT_RTL_SRCS.  Right now we count on being able to build GNATRTL_OBJS\n-#  from ADA_INCLUDE_SRCS.\n-\n-# GNATRTL_NONTASKING_OBJS and GNATRTL_TASKING_OBJS can be found in\n-# the following include file:\n-\n-include $(fsrcdir)/Makefile.rtl\n-\n-GNATRTL_LINEARALGEBRA_OBJS = a-nlcoar.o a-nllcar.o a-nllrar.o a-nlrear.o \\\n-  a-nucoar.o a-nurear.o i-forbla.o i-forlap.o s-gearop.o\n-\n-GNATRTL_OBJS = $(GNATRTL_NONTASKING_OBJS) $(GNATRTL_TASKING_OBJS) \\\n-  $(GNATRTL_LINEARALGEBRA_OBJS) g-trasym.o memtrack.o\n-\n-# Default run time files\n-\n-ADA_INCLUDE_SRCS =\\\n- ada.ads calendar.ads directio.ads gnat.ads interfac.ads ioexcept.ads \\\n- machcode.ads text_io.ads unchconv.ads unchdeal.ads \\\n- sequenio.ads system.ads memtrack.adb \\\n- a-[a-o]*.adb a-[p-z]*.adb a-[a-o]*.ads a-[p-z]*.ads g-*.ad? i-*.ad? \\\n- s-[a-o]*.adb s-[p-z]*.adb s-[a-o]*.ads s-[p-z]*.ads\n-\n-LIBGNAT=../rts/libgnat.a\n-\n-GCC_LINK=$(CC) -static-libgcc $(ADA_INCLUDES)\n-\n-# when compiling the tools, the runtime has to be first on the path so that\n-# it hides the runtime files lying with the rest of the sources\n-ifeq ($(TOOLSCASE),native)\n-  vpath %.ads ../rts ../\n-  vpath %.adb ../rts ../\n-  vpath %.c   ../rts ../\n-  vpath %.h   ../rts ../\n-endif\n-\n-# in the cross tools case, everything is compiled with the native\n-# gnatmake/link. Therefore only -I needs to be modified in ADA_INCLUDES\n-ifeq ($(TOOLSCASE),cross)\n-  vpath %.ads ../\n-  vpath %.adb ../\n-  vpath %.c   ../\n-  vpath %.h   ../\n-endif\n-\n-common-tools:\n-\t$(GNATMAKE) -c -b $(ADA_INCLUDES) \\\n-\t  --GNATBIND=\"$(GNATBIND)\" --GCC=\"$(CC) $(ALL_ADAFLAGS)\" \\\n-\t  gnatchop gnatcmd gnatkr gnatls gnatprep gnatxref gnatfind gnatname \\\n-\t  gnatclean -bargs $(ADA_INCLUDES) $(GNATBIND_FLAGS)\n-\t$(GNATLINK) -v gnatcmd -o ../../gnat$(exeext) \\\n-\t\t--GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n-\t$(GNATLINK) -v gnatchop -o ../../gnatchop$(exeext) \\\n-\t\t--GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n-\t$(GNATLINK) -v gnatkr -o ../../gnatkr$(exeext) \\\n-\t\t--GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n-\t$(GNATLINK) -v gnatls -o ../../gnatls$(exeext) \\\n-\t\t--GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n-\t$(GNATLINK) -v gnatprep -o ../../gnatprep$(exeext) \\\n-\t\t--GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n-\t$(GNATLINK) -v gnatxref -o ../../gnatxref$(exeext) \\\n-\t\t--GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n-\t$(GNATLINK) -v gnatfind -o ../../gnatfind$(exeext) \\\n-\t\t--GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n-\t$(GNATLINK) -v gnatname -o ../../gnatname$(exeext) \\\n-\t\t--GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n-\t$(GNATLINK) -v gnatclean -o ../../gnatclean$(exeext) \\\n-\t\t--GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n-\n-../../gnatsym$(exeext): \n-\t$(GNATMAKE) -c $(ADA_INCLUDES) gnatsym --GCC=\"$(CC) $(ALL_ADAFLAGS)\"\n-\t$(GNATBIND) $(ADA_INCLUDES) $(GNATBIND_FLAGS) gnatsym\n-\t$(GNATLINK) -v gnatsym -o $@ --GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n-\n-../../gnatdll$(exeext): \n-\t$(GNATMAKE) -c $(ADA_INCLUDES) gnatdll --GCC=\"$(CC) $(ALL_ADAFLAGS)\"\n-\t$(GNATBIND) $(ADA_INCLUDES) $(GNATBIND_FLAGS) gnatdll\n-\t$(GNATLINK) -v gnatdll -o $@ --GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n-\n-../../vxaddr2line$(exeext): targext.o\n-\t$(GNATMAKE) -c  $(ADA_INCLUDES) vxaddr2line --GCC=\"$(CC) $(ALL_ADAFLAGS)\"\n-\t$(GNATBIND) $(ADA_INCLUDES) $(GNATBIND_FLAGS) vxaddr2line\n-\t$(GNATLINK) -v vxaddr2line -o $@ --GCC=\"$(GCC_LINK)\" targext.o $(CLIB)\n-\n-gnatmake-re:  link.o targext.o\n-\t$(GNATMAKE) $(ADA_INCLUDES) -u sdefault --GCC=\"$(CC) $(MOST_ADA_FLAGS)\"\n-\t$(GNATMAKE) -c $(ADA_INCLUDES) gnatmake --GCC=\"$(CC) $(ALL_ADAFLAGS)\"\n-\t$(GNATBIND) $(ADA_INCLUDES) $(GNATBIND_FLAGS) gnatmake\n-\t$(GNATLINK) -v gnatmake -o ../../gnatmake$(exeext) \\\n-\t\t--GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n-\n-# Note the use of the \"mv\" command in order to allow gnatlink to be linked with\n-# with the former version of gnatlink itself which cannot override itself.\n-gnatlink-re:  link.o targext.o\n-\t$(GNATMAKE) -c $(ADA_INCLUDES) gnatlink --GCC=\"$(CC) $(ALL_ADAFLAGS)\"\n-\t$(GNATBIND) $(ADA_INCLUDES) $(GNATBIND_FLAGS) gnatlink\n-\t$(GNATLINK) -v gnatlink -o ../../gnatlinknew$(exeext) \\\n-\t\t    --GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n-\t$(MV)  ../../gnatlinknew$(exeext)  ../../gnatlink$(exeext)\n-\n-# Needs to be built with CC=gcc\n-# Since the RTL should be built with the latest compiler, remove the\n-#  stamp target in the parent directory whenever gnat1 is rebuilt\n-\n-# Likewise for the tools\n-../../gnatmake$(exeext): $(P) b_gnatm.o link.o targext.o $(GNATMAKE_OBJS)\n-\t$(GCC_LINK) $(ALL_CFLAGS) $(LDFLAGS) -o $@ b_gnatm.o $(GNATMAKE_OBJS) \\\n-\t\t    $(TOOLS_LIBS)\n-\n-../../gnatlink$(exeext): $(P) b_gnatl.o link.o targext.o $(GNATLINK_OBJS)\n-\t$(GCC_LINK) $(ALL_CFLAGS) $(LDFLAGS) -o $@ b_gnatl.o $(GNATLINK_OBJS) \\\n-\t\t    $(TOOLS_LIBS)\n-\n-../stamp-gnatlib:\n-\t@if [ ! -f stamp-gnatlib ] ; \\\n-\tthen \\\n-\t  $(ECHO) You must first build the GNAT library: make gnatlib; \\\n-\t  false; \\\n-\telse \\\n-\t  true; \\\n-\tfi\n-\n-install-gnatlib: ../stamp-gnatlib\n-#\tCreate the directory before deleting it, in case the directory is\n-#\ta list of directories (as it may be on VMS). This ensures we are\n-#\tdeleting the right one.\n-\t-$(MKDIR) $(DESTDIR)$(ADA_RTL_OBJ_DIR)\n-\t-$(MKDIR) $(DESTDIR)$(ADA_INCLUDE_DIR)\n-\t$(RMDIR) $(DESTDIR)$(ADA_RTL_OBJ_DIR)\n-\t$(RMDIR) $(DESTDIR)$(ADA_INCLUDE_DIR)\n-\t-$(MKDIR) $(DESTDIR)$(ADA_RTL_OBJ_DIR)\n-\t-$(MKDIR) $(DESTDIR)$(ADA_INCLUDE_DIR)\n-\tfor file in rts/*.ali; do \\\n-\t    $(INSTALL_DATA_DATE) $$file $(DESTDIR)$(ADA_RTL_OBJ_DIR); \\\n-\tdone\n-\t-$(INSTALL_DATA) rts/g-trasym$(objext) $(DESTDIR)$(ADA_RTL_OBJ_DIR)\n-\t-cd rts; for file in *$(arext);do \\\n-\t    $(INSTALL_DATA) $$file $(DESTDIR)$(ADA_RTL_OBJ_DIR); \\\n-\t    $(RANLIB_FOR_TARGET) $(DESTDIR)$(ADA_RTL_OBJ_DIR)/$$file; \\\n-\tdone\n-\t-$(foreach file, $(EXTRA_ADALIB_FILES), \\\n-\t    $(INSTALL_DATA_DATE) rts/$(file) $(DESTDIR)$(ADA_RTL_OBJ_DIR) && \\\n-\t) true\n-#     Install the shared libraries, if any, using $(INSTALL) instead\n-#     of $(INSTALL_DATA). The latter may force a mode inappropriate\n-#     for shared libraries on some targets, e.g. on HP-UX where the x\n-#     permission is required.\n-\tfor file in gnat gnarl; do \\\n-\t   if [ -f rts/lib$${file}$(hyphen)$(LIBRARY_VERSION)$(soext) ]; then \\\n-\t      $(INSTALL) rts/lib$${file}$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n-\t\t\t $(DESTDIR)$(ADA_RTL_OBJ_DIR); \\\n-\t   fi; \\\n-\t   if [ -f rts/lib$${file}$(soext) ]; then \\\n-\t      $(LN_S) lib$${file}$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n-\t      $(DESTDIR)$(ADA_RTL_OBJ_DIR)/lib$${file}$(soext); \\\n-\t   fi; \\\n-\tdone\n-# This copy must be done preserving the date on the original file.\n-\tfor file in rts/*.ad?; do \\\n-\t    $(INSTALL_DATA_DATE) $$file $(DESTDIR)$(ADA_INCLUDE_DIR); \\\n-\tdone\n-\tcd $(DESTDIR)$(ADA_INCLUDE_DIR); $(CHMOD) a-wx *.adb\n-\tcd $(DESTDIR)$(ADA_INCLUDE_DIR); $(CHMOD) a-wx *.ads\n-\n-../stamp-gnatlib2:\n-\t$(RM) rts/s-*.ali\n-\t$(RM) rts/s-*$(objext)\n-\t$(RM) rts/a-*.ali\n-\t$(RM) rts/a-*$(objext)\n-\t$(RM) rts/*.ali\n-\t$(RM) rts/*$(objext)\n-\t$(RM) rts/*$(arext)\n-\t$(RM) rts/*$(soext)\n-\ttouch ../stamp-gnatlib2\n-\t$(RM) ../stamp-gnatlib\n-\n-# NOTE: The $(foreach ...) commands assume \";\" is the valid separator between\n-#       successive target commands. Although the Gnu make documentation\n-#       implies this is true on all systems, I suspect it may not be, So care\n-#       has been taken to allow a sed script to look for \";)\" and substitue\n-#       for \";\" the appropriate character in the range of lines below\n-#       beginning with \"GNULLI Begin\" and ending with \"GNULLI End\"\n-\n-# GNULLI Begin ###########################################################\n-\n-../stamp-gnatlib1: Makefile ../stamp-gnatlib2\n-\t$(RMDIR) rts\n-\t$(MKDIR) rts\n-\t$(CHMOD) u+w rts\n-# Copy target independent sources\n-\t$(foreach f,$(ADA_INCLUDE_SRCS) $(LIBGNAT_SRCS), \\\n-\t  $(LN_S) $(fsrcpfx)$(f) rts ;) true\n-# Remove files to be replaced by target dependent sources\n-\t$(RM) $(foreach PAIR,$(LIBGNAT_TARGET_PAIRS), \\\n-\t                rts/$(word 1,$(subst <, ,$(PAIR))))\n-\t$(RM) rts/*-*-*.ads rts/*-*-*.adb\n-# Copy new target dependent sources\n-\t$(foreach PAIR,$(LIBGNAT_TARGET_PAIRS), \\\n-\t          $(LN_S) $(fsrcpfx)$(word 2,$(subst <, ,$(PAIR))) \\\n-\t                rts/$(word 1,$(subst <, ,$(PAIR)));)\n-\t$(RM) ../stamp-gnatlib\n-\ttouch ../stamp-gnatlib1\n-\n-# GNULLI End #############################################################\n-\n-# Don't use semicolon separated shell commands that involve list expansions.\n-# The semicolon triggers a call to DCL on VMS and DCL can't handle command\n-# line lengths in excess of 256 characters.\n-# Example: cd rts; ar rc libfoo.a $(LONG_LIST_OF_OBJS)\n-# is guaranteed to overflow the buffer.\n-\n-gnatlib: ../stamp-gnatlib1 ../stamp-gnatlib2\n-\t$(MAKE) -C rts \\\n-\t\tCC=\"`echo \\\"$(GCC_FOR_TARGET)\\\" \\\n-\t\t| sed -e 's,^\\./xgcc,../../xgcc,' -e 's,-B\\./,-B../../,'`\" \\\n-\t        INCLUDES=\"$(INCLUDES_FOR_SUBDIR) -I./../..\" \\\n-                CFLAGS=\"$(GNATLIBCFLAGS_FOR_C)\" \\\n-\t        FORCE_DEBUG_ADAFLAGS=\"$(FORCE_DEBUG_ADAFLAGS)\" \\\n-\t\tsrcdir=$(fsrcdir) \\\n-\t        -f ../Makefile $(LIBGNAT_OBJS)\n-\t$(MAKE) -C rts \\\n-\t\tCC=\"`echo \\\"$(GCC_FOR_TARGET)\\\" \\\n-\t\t| sed -e 's,^\\./xgcc,../../xgcc,' -e 's,-B\\./,-B../../,'`\" \\\n-\t        ADA_INCLUDES=\"\" \\\n-                CFLAGS=\"$(GNATLIBCFLAGS)\" \\\n-\t        ADAFLAGS=\"$(GNATLIBFLAGS)\" \\\n-\t        FORCE_DEBUG_ADAFLAGS=\"$(FORCE_DEBUG_ADAFLAGS)\" \\\n-\t\tsrcdir=$(fsrcdir) \\\n-\t        -f ../Makefile \\\n-\t        $(GNATRTL_OBJS)\n-\t$(RM) rts/libgnat$(arext) rts/libgnarl$(arext)\n-\t$(AR_FOR_TARGET) $(AR_FLAGS) rts/libgnat$(arext) \\\n-\t   $(addprefix rts/,$(GNATRTL_NONTASKING_OBJS) $(LIBGNAT_OBJS))\n-        ifneq ($(PREFIX_OBJS),)\n-\t\t$(AR_FOR_TARGET) $(AR_FLAGS) rts/libgccprefix$(arext) \\\n-\t\t  $(PREFIX_OBJS);\n-\t\t$(RANLIB_FOR_TARGET) rts/libgccprefix$(arext)\n-        endif\n-\t$(RANLIB_FOR_TARGET) rts/libgnat$(arext)\n-\t$(AR_FOR_TARGET) $(AR_FLAGS) rts/libgnarl$(arext) \\\n-\t   $(addprefix rts/,$(GNATRTL_TASKING_OBJS))\n-\t$(RANLIB_FOR_TARGET) rts/libgnarl$(arext)\n-\t$(AR_FOR_TARGET) $(AR_FLAGS) rts/libgnala$(arext) \\\n-\t   $(addprefix rts/,$(GNATRTL_LINEARALGEBRA_OBJS))\n-\t$(RANLIB_FOR_TARGET) rts/libgnala$(arext)\n-        ifeq ($(GMEM_LIB),gmemlib)\n-\t\t$(AR_FOR_TARGET) $(AR_FLAGS) rts/libgmem$(arext) \\\n-\t\t  rts/memtrack.o\n-\t\t$(RANLIB_FOR_TARGET) rts/libgmem$(arext)\n-        endif\n-\t$(CHMOD) a-wx rts/*.ali\n-\ttouch ../stamp-gnatlib\n-\n-# Warning: this target assumes that LIBRARY_VERSION has been set correctly.\n-gnatlib-shared-default:\n-\t$(MAKE) $(FLAGS_TO_PASS) \\\n-             GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n-\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS)\" \\\n-\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n-             gnatlib\n-\t$(RM) rts/libgna*$(soext)\n-\tcd rts; ../../xgcc -B../../ -shared $(GNATLIBCFLAGS) \\\n-\t\t$(TARGET_LIBGCC2_CFLAGS) \\\n-\t\t-o libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n-\t\t$(GNATRTL_NONTASKING_OBJS) $(LIBGNAT_OBJS) \\\n-\t\t$(SO_OPTS)libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n-\t\t$(MISCLIB) -lm\n-\tcd rts; ../../xgcc -B../../ -shared $(GNATLIBCFLAGS) \\\n-\t\t$(TARGET_LIBGCC2_CFLAGS) \\\n-\t\t-o libgnarl$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n-\t\t$(GNATRTL_TASKING_OBJS) \\\n-\t\t$(SO_OPTS)libgnarl$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n-\t\t$(THREADSLIB)\n-\tcd rts; $(LN_S) libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n-\t\tlibgnat$(soext)\n-\tcd rts; $(LN_S) libgnarl$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n-\t\tlibgnarl$(soext)\n-\n-gnatlib-shared-dual:\n-\t$(MAKE) $(FLAGS_TO_PASS) \\\n-             GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n-\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS)\" \\\n-\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n-             gnatlib-shared-default\n-\t$(MV) rts/libgna*$(soext) .\n-\t$(RM) ../stamp-gnatlib2\n-\t$(MAKE) $(FLAGS_TO_PASS) \\\n-             GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n-\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS)\" \\\n-\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n-             gnatlib\n-\t$(MV) libgna*$(soext) rts\n-\n-gnatlib-shared-dual-win32:\n-\t$(MAKE) $(FLAGS_TO_PASS) \\\n-             GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n-\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS)\" \\\n-\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n-             gnatlib-shared-win32\n-\t$(MV) rts/libgna*$(soext) .\n-\t$(RM) ../stamp-gnatlib2\n-\t$(MAKE) $(FLAGS_TO_PASS) \\\n-             GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n-\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS)\" \\\n-\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n-             gnatlib\n-\t$(MV) libgna*$(soext) rts\n-\n-# ??? we need to add the option to support auto-import of arrays/records to\n-# the GNATLIBFLAGS when this will be supported by GNAT. At this point we will\n-# use the gnatlib-shared-dual-win32 target to build the GNAT runtimes on\n-# Windows.\n-gnatlib-shared-win32:\n-\t$(MAKE) $(FLAGS_TO_PASS) \\\n-             GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n-\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS)\" \\\n-\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n-             gnatlib\n-\t$(RM) rts/libgna*$(soext)\n-\tcd rts; ../../xgcc -B../../ -shared $(TARGET_LIBGCC2_CFLAGS) \\\n-\t\t-o libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n-\t\t$(GNATRTL_NONTASKING_OBJS) $(LIBGNAT_OBJS) \\\n-\t\t$(SO_OPTS)libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) $(MISCLIB)\n-\tcd rts; ../../xgcc -B../../ -shared $(TARGET_LIBGCC2_CFLAGS) \\\n-\t\t-o libgnarl$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n-\t\t$(GNATRTL_TASKING_OBJS) \\\n-\t\t$(SO_OPTS)libgnarl$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n-\t\t$(THREADSLIB) -Wl,libgnat$(hyphen)$(LIBRARY_VERSION)$(soext)\n-\n-gnatlib-shared-darwin:\n-\t$(MAKE) $(FLAGS_TO_PASS) \\\n-\t     GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n-\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS) \\\n-\t                    -fno-common\" \\\n-\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n-\t     gnatlib\n-\t$(RM) rts/libgnat$(soext) rts/libgnarl$(soext)\n-\tcd rts; ../../xgcc -B../../ -dynamiclib $(TARGET_LIBGCC2_CFLAGS) \\\n-\t\t-o libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n-\t\t$(GNATRTL_NONTASKING_OBJS) $(LIBGNAT_OBJS) \\\n-\t\t$(SO_OPTS) \\\n-\t\t$(MISCLIB) -lm\n-\tcd rts; ../../xgcc -B../../ -dynamiclib $(TARGET_LIBGCC2_CFLAGS) \\\n-\t\t-o libgnarl$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n-\t\t$(GNATRTL_TASKING_OBJS) \\\n-\t\t$(SO_OPTS) \\\n-\t\t$(THREADSLIB) -Wl,libgnat$(hyphen)$(LIBRARY_VERSION)$(soext)\n-\tcd rts; $(LN_S) libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n-\t\tlibgnat$(soext)\n-\tcd rts; $(LN_S) libgnarl$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n-\t\tlibgnarl$(soext)\n-\n-gnatlib-shared-vms:\n-\t$(MAKE) $(FLAGS_TO_PASS) \\\n-             GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n-\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS)\" \\\n-\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n-             gnatlib\n-\t$(RM) rts/libgna*$(soext)\n-\tcd rts && \\\n-\t../../gnatsym -s SYMVEC_$$$$.opt \\\n-\t$(LIBGNAT_OBJS) $(GNATRTL_NONTASKING_OBJS) && \\\n-\t../../xgcc -g -B../../ -shared -shared-libgcc \\\n-\t   -o libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) libgnat.a \\\n-\t   sys\\$$library:trace.exe \\\n-\t   --for-linker=/noinform \\\n-\t   --for-linker=SYMVEC_$$$$.opt \\\n-\t   --for-linker=gsmatch=equal,$(GSMATCH_VERSION)\n-\tcd rts && \\\n-\t../../gnatsym -s SYMVEC_$$$$.opt \\\n-\t$(GNATRTL_TASKING_OBJS) && \\\n-\t../../xgcc -g -B../../ -shared -shared-libgcc \\\n-\t   -o libgnarl$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n-\t   libgnarl.a libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n-\t   sys\\$$library:trace.exe \\\n-\t   --for-linker=/noinform \\\n-\t   --for-linker=SYMVEC_$$$$.opt \\\n-\t   --for-linker=gsmatch=equal,$(GSMATCH_VERSION)\n-\n-gnatlib-shared:\n-\t$(MAKE) $(FLAGS_TO_PASS) \\\n-             GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n-\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS)\" \\\n-\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n-\t     TARGET_LIBGCC2_CFLAGS=\"$(TARGET_LIBGCC2_CFLAGS)\" \\\n-             $(GNATLIB_SHARED)\n-\n-gnatlib-sjlj:\n-\t$(MAKE) $(FLAGS_TO_PASS) EH_MECHANISM=\"\" ../stamp-gnatlib1\n-\tsed -e 's/ZCX_By_Default.*/ZCX_By_Default            : constant Boolean := False;/' rts/system.ads > rts/s.ads\n-\t$(MV) rts/s.ads rts/system.ads\n-\t$(MAKE) $(FLAGS_TO_PASS) \\\n-\t     EH_MECHANISM=\"\" \\\n-\t     GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n-\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS)\" \\\n-\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n-\t     TARGET_LIBGCC2_CFLAGS=\"$(TARGET_LIBGCC2_CFLAGS)\" gnatlib\n-\n-gnatlib-zcx:\n-\t$(MAKE) $(FLAGS_TO_PASS) EH_MECHANISM=\"-gcc\" ../stamp-gnatlib1\n-\tsed -e 's/ZCX_By_Default.*/ZCX_By_Default            : constant Boolean := True;/' rts/system.ads > rts/s.ads\n-\t$(MV) rts/s.ads rts/system.ads\n-\t$(MAKE) $(FLAGS_TO_PASS) \\\n-\t     EH_MECHANISM=\"-gcc\" \\\n-\t     GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n-\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS)\" \\\n-\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n-\t     TARGET_LIBGCC2_CFLAGS=\"$(TARGET_LIBGCC2_CFLAGS)\" gnatlib\n-\n-# .s files for cross-building\n-gnat-cross: force\n-\tmake $(GNAT1_ADA_OBJS) CC=\"gcc -B../stage1/\" CFLAGS=\"-S -gnatp\"\n-\n-# Compiling object files from source files.\n-\n-# Note that dependencies on obstack.h are not written\n-# because that file is not part of GCC.\n-# Dependencies on gvarargs.h are not written\n-# because all that file does, when not compiling with GCC,\n-# is include the system varargs.h.\n-\n-b_gnatl.c : $(GNATLINK_OBJS)\n-\t$(GNATBIND) -C $(ADA_INCLUDES) -o b_gnatl.c gnatlink.ali\n-b_gnatl.o : b_gnatl.c\n-\n-b_gnatm.c : $(GNATMAKE_OBJS)\n-\t$(GNATBIND) -C $(ADA_INCLUDES) -o b_gnatm.c gnatmake.ali\n-b_gnatm.o : b_gnatm.c\n-\n-ADA_INCLUDE_DIR = $(libsubdir)/adainclude\n-ADA_RTL_OBJ_DIR = $(libsubdir)/adalib\n-\n-# force no sibling call optimization on s-traceb.o so the number of stack\n-# frames to be skipped when computing a call chain is not modified by\n-# optimization. However we can do that only when building the runtime\n-# (not the compiler) because the -fno-optimize-sibling-calls option exists\n-# only in GCC 3 and above.\n-\n-ifneq (,$(findstring xgcc,$(CC)))\n-NO_SIBLING_ADAFLAGS=-fno-optimize-sibling-calls\n-else\n-NO_SIBLING_ADAFLAGS=\n-endif\n-\n-s-traceb.o  : s-traceb.adb\n-\t$(CC) -c $(ALL_ADAFLAGS) $(FORCE_DEBUG_ADAFLAGS) \\\n-\t      $(NO_SIBLING_ADAFLAGS) $(ADA_INCLUDES) \\\n-      $< $(OUTPUT_OPTION)\n-\n-# force debugging information on s-tasdeb.o so that it is always\n-# possible to set conditional breakpoints on tasks.\n-\n-s-tasdeb.o  : s-tasdeb.adb s-tasdeb.ads\n-\t$(CC) -c $(ALL_ADAFLAGS) $(FORCE_DEBUG_ADAFLAGS) -O0 $(ADA_INCLUDES) \\\n-\t      $< $(OUTPUT_OPTION)\n-\n-# force no function reordering on a-except.o because of the exclusion bounds\n-# mechanism (see the source file for more detailed information). However we\n-# can do that only when building the runtime (not the compiler) because the\n-# -fno-toplevel-reorder option exists only in GCC 4.2 and above.\n-\n-ifneq (,$(findstring xgcc,$(CC)))\n-NO_REORDER_ADAFLAGS=-fno-toplevel-reorder\n-else\n-NO_REORDER_ADAFLAGS=\n-endif\n-\n-# force debugging information on a-except.o so that it is always\n-# possible to set conditional breakpoints on exceptions.\n-# use -O1 otherwise gdb isn't able to get a full backtrace on mips targets.\n-\n-a-except.o  : a-except.adb a-except.ads\n-\t$(CC) -c $(ALL_ADAFLAGS) $(FORCE_DEBUG_ADAFLAGS) -O1 -fno-inline \\\n-\t      $(NO_REORDER_ADAFLAGS) $(ADA_INCLUDES) $< $(OUTPUT_OPTION)\n-\n-# compile s-except.o without optimization and with debug info to let the\n-# debugger set breakpoints and inspect subprogram parameters on exception\n-# related events.\n-\n-s-except.o  : s-except.adb s-except.ads\n-\t$(CC) -c $(ALL_ADAFLAGS) $(FORCE_DEBUG_ADAFLAGS) -O0 $(ADA_INCLUDES) \\\n-\t      $< $(OUTPUT_OPTION)\n-\n-# force debugging information on s-assert.o so that it is always\n-# possible to set breakpoint on assert failures.\n-\n-s-assert.o  : s-assert.adb s-assert.ads a-except.ads\n-\t$(CC) -c $(ALL_ADAFLAGS) $(FORCE_DEBUG_ADAFLAGS) -O2 $(ADA_INCLUDES) \\\n-\t      $< $(OUTPUT_OPTION)\n-\n-adadecode.o : adadecode.c adadecode.h\n-aux-io.o  : aux-io.c\n-argv.o    : argv.c\n-cal.o     : cal.c\n-deftarg.o : deftarg.c\n-errno.o   : errno.c\n-exit.o    : adaint.h exit.c\n-expect.o  : expect.c\n-final.o   : final.c\n-gmem.o    : gmem.c\n-link.o    : link.c\n-mkdir.o   : mkdir.c\n-socket.o  : socket.c gsocket.h\n-sysdep.o  : sysdep.c\n-raise-gcc.o : raise-gcc.c raise.h\n-raise.o   : raise.c raise.h\n-vx_stack_info.o : vx_stack_info.c\n-\n-gen-soccon: gen-soccon.c gsocket.h\n-\t$(CC) $(ALL_CFLAGS) $(ADA_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n-\t\t-UIN_GCC -DTARGET=\\\"$(target_alias)\\\" \\\n-\t\t$< $(OUTPUT_OPTION)\n-\n-cio.o     : cio.c\n-\t$(CC) -c $(ALL_CFLAGS) $(ADA_CFLAGS) \\\n-\t         $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n-\n-init.o    : init.c adaint.h raise.h\n-\t$(CC) -c $(ALL_CFLAGS) $(ADA_CFLAGS) \\\n-\t         $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n-\n-initialize.o : initialize.c raise.h\n-\t$(CC) -c $(ALL_CFLAGS) $(ADA_CFLAGS) \\\n-\t         $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n-\n-targext.o : targext.c\n-\t$(CC) -c $(ALL_CFLAGS) $(ADA_CFLAGS) \\\n-\t\t$(ALL_CPPFLAGS) $(INCLUDES_FOR_SUBDIR) \\\n-\t\t$< $(OUTPUT_OPTION)\n-\n-# No optimization to compile this file as optimizations (-O1 or above) breaks\n-# the SEH handling on Windows. The reasons are not clear.\n-seh_init.o : seh_init.c raise.h\n-\t$(CC) -c $(ALL_CFLAGS) $(ADA_CFLAGS) -O0 \\\n-\t         $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n-\n-# Need to keep the frame pointer in this file to pop the stack properly on\n-# some targets.\n-tracebak.o  : tracebak.c tb-alvms.c tb-alvxw.c tb-gcc.c\n-\t$(CC) -c $(ALL_CFLAGS) $(ADA_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n-\t      -fno-omit-frame-pointer $< $(OUTPUT_OPTION)\n-\n-# In GNU Make, ignore whether `stage*' exists.\n-.PHONY: stage1 stage2 stage3 stage4 clean realclean TAGS bootstrap\n-.PHONY: risky-stage1 risky-stage2 risky-stage3 risky-stage4\n-\n-force:\n-\n-# Gnatlbr, Vms_help, and Gnat.hlp are only used on VMS\n-\n-../../gnatlbr$(exeext): ../../prefix.o\n-\t$(GNATMAKE) -c $(ADA_INCLUDES) gnatlbr --GCC=\"$(CC) $(ALL_ADAFLAGS)\"\n-\t$(GNATBIND) $(ADA_INCLUDES) $(GNATBIND_FLAGS) gnatlbr\n-\t$(GNATLINK) -v gnatlbr -o $@ --GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n-\n-../../vms_help$(exeext):\n-\t$(GNATMAKE) -c $(ADA_INCLUDES) vms_help --GCC=\"$(CC) $(ALL_ADAFLAGS)\"\n-\t$(GNATBIND) $(ADA_INCLUDES) $(GNATBIND_FLAGS) vms_help\n-\t$(GNATLINK) -v vms_help -o $@ --GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n-\n-../../gnat.hlp: ../../vms_help$(exeext)\n-\t../../vms_help$(exeext) $(fsrcdir)/gnat.help_in \\\n-\t                        $(fsrcdir)/vms_data.ads ../../gnat.hlp\n+-include ./gcc-interface/Makefile\n+-include ../gcc-interface/Makefile"}, {"sha": "ad76864cd61dfd76aaa1f28ffcd487f7e3021513", "filename": "gcc/ada/config-lang.in", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fconfig-lang.in?ref=a1ab4c317abfd045fe0619b455a31e19f910f7e7", "patch": "@@ -1,11 +1,11 @@\n # Top level configure fragment for GNU Ada (GNAT).\n-#   Copyright (C) 1994-2003, 2007 Free Software Foundation, Inc.\n+#   Copyright (C) 1994-2008 Free Software Foundation, Inc.\n \n #This file is part of GCC.\n \n #GCC is free software; you can redistribute it and/or modify\n #it under the terms of the GNU General Public License as published by\n-#the Free Software Foundation; either version 3, or (at your option)\n+#the Free Software Foundation; either version 2, or (at your option)\n #any later version.\n \n #GCC is distributed in the hope that it will be useful,\n@@ -14,28 +14,15 @@\n #GNU General Public License for more details.\n \n #You should have received a copy of the GNU General Public License\n-#along with GCC; see the file COPYING3.  If not see\n-#<http://www.gnu.org/licenses/>.\n-\n-# Configure looks for the existence of this file to auto-config each language.\n-# We define several parameters used by configure:\n-#\n-# language\t- name of language as it would appear in $(LANGUAGES)\n-# boot_language - \"yes\" if we need to build this language in stage1\n-# compilers\t- value to add to $(COMPILERS)\n+#along with GCC; see the file COPYING.  If not, write to\n+#the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+#Boston, MA 02110-1301, USA.\n \n language=\"ada\"\n-boot_language=yes\n-boot_language_boot_flags='ADAFLAGS=\"$(BOOT_ADAFLAGS)\"'\n-\n-compilers=\"gnat1\\$(exeext)\"\n-\n-gtfiles=\"\\$(srcdir)/ada/ada-tree.h \\$(srcdir)/ada/gigi.h \\$(srcdir)/ada/decl.c \\$(srcdir)/ada/trans.c \\$(srcdir)/ada/utils.c\"\n-\n-outputs=ada/Makefile\n-\n-target_libs=\"target-libada\"\n-lang_dirs=\"gnattools\"\n+gcc_subdir=\"ada/gcc-interface\"\n \n-# Ada will not work until the front end starts emitting GIMPLE trees.\n-build_by_default=no\n+if [ -f ${srcdir}/gcc/ada/gcc-interface/config-lang.in ]; then\n+   . ${srcdir}/gcc/ada/gcc-interface/config-lang.in\n+else\n+   . ${srcdir}/ada/gcc-interface/config-lang.in\n+fi"}, {"sha": "2d21d45c23f469e456b66084f7ed3607e9271862", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "added", "additions": 4309, "deletions": 0, "changes": 4309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=a1ab4c317abfd045fe0619b455a31e19f910f7e7"}, {"sha": "fc96dcb18572692b890c34386b668acc007b9eb9", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "added", "additions": 2295, "deletions": 0, "changes": 2295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=a1ab4c317abfd045fe0619b455a31e19f910f7e7", "patch": "@@ -0,0 +1,2295 @@\n+# Makefile for GNU Ada Compiler (GNAT).\n+#   Copyright (C) 1994-2008 Free Software Foundation, Inc.\n+\n+#This file is part of GCC.\n+\n+#GCC is free software; you can redistribute it and/or modify\n+#it under the terms of the GNU General Public License as published by\n+#the Free Software Foundation; either version 3, or (at your option)\n+#any later version.\n+\n+#GCC is distributed in the hope that it will be useful,\n+#but WITHOUT ANY WARRANTY; without even the implied warranty of\n+#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+#GNU General Public License for more details.\n+\n+#You should have received a copy of the GNU General Public License\n+#along with GCC; see the file COPYING3.  If not see\n+#<http://www.gnu.org/licenses/>.\n+\n+# The makefile built from this file lives in the language subdirectory.\n+# Its purpose is to provide support for:\n+#\n+# 1) recursion where necessary, and only then (building .o's), and\n+# 2) building and debugging cc1 from the language subdirectory, and\n+# 3) nothing else.\n+#\n+# The parent makefile handles all other chores, with help from the\n+# language makefile fragment, of course.\n+#\n+# The targets for external use are:\n+# all, TAGS, ???mostlyclean, ???clean.\n+\n+# This makefile will only work with Gnu make.\n+# The rules are written assuming a minimum subset of tools are available:\n+#\n+# Required:\n+#      MAKE:    Only Gnu make will work.\n+#      MV:      Must accept (at least) one, maybe wildcard, source argument,\n+#               a file or directory destination, and support creation/\n+#               modification date preservation.  Gnu mv -f works.\n+#      RM:      Must accept an arbitrary number of space separated file\n+#               arguments, or one wildcard argument. Gnu rm works.\n+#      RMDIR:   Must delete a directory and all its contents. Gnu rm -rf works.\n+#      ECHO:    Must support command line redirection. Any Unix-like\n+#               shell will typically provide this, otherwise a custom version\n+#               is trivial to write.\n+#      AR:      Gnu ar works.\n+#      MKDIR:   Gnu mkdir works.\n+#      CHMOD:   Gnu chmod works.\n+#      true:    Does nothing and returns a normal successful return code.\n+#      pwd:     Prints the current directory on stdout.\n+#      cd:      Change directory.\n+#\n+# Optional:\n+#      BISON:   Gnu bison works.\n+#      FLEX:    Gnu flex works.\n+#      Other miscellaneous tools for obscure targets.\n+\n+# Suppress smart makes who think they know how to automake Yacc files\n+.y.c:\n+\n+# Variables that exist for you to override.\n+# See below for how to change them for certain systems.\n+\n+# Various ways of specifying flags for compilations:\n+# CFLAGS is for the user to override to, e.g., do a bootstrap with -O2.\n+# BOOT_CFLAGS is the value of CFLAGS to pass\n+# to the stage2 and stage3 compilations\n+# XCFLAGS is used for most compilations but not when using the GCC just built.\n+XCFLAGS =\n+CFLAGS = -g\n+BOOT_CFLAGS = -O $(CFLAGS)\n+# These exists to be overridden by the x-* and t-* files, respectively.\n+X_CFLAGS =\n+T_CFLAGS =\n+\n+X_CPPFLAGS =\n+T_CPPFLAGS =\n+\n+X_ADA_CFLAGS =\n+T_ADA_CFLAGS =\n+\n+X_ADAFLAGS =\n+T_ADAFLAGS =\n+\n+CC = cc\n+BISON = bison\n+BISONFLAGS =\n+ECHO = echo\n+LEX = flex\n+LEXFLAGS =\n+CHMOD = chmod\n+LN = ln\n+LN_S = ln -s\n+CP = cp -p\n+MV = mv -f\n+RM = rm -f\n+RMDIR = rm -rf\n+MKDIR = mkdir -p\n+AR = ar\n+AR_FLAGS = rc\n+LS = ls\n+RANLIB = @RANLIB@\n+RANLIB_FLAGS = @ranlib_flags@\n+\n+SHELL = @SHELL@\n+PWD_COMMAND = $${PWDCMD-pwd}\n+# How to copy preserving the date\n+INSTALL_DATA_DATE = cp -p\n+MAKEINFO = makeinfo\n+TEXI2DVI = texi2dvi\n+TEXI2PDF = texi2pdf\n+GNATBIND_FLAGS = -static -x\n+ADA_CFLAGS =\n+ADAFLAGS = -W -Wall -gnatpg -gnata\n+SOME_ADAFLAGS =-gnata\n+FORCE_DEBUG_ADAFLAGS = -g\n+GNATLIBFLAGS = -gnatpg -nostdinc\n+GNATLIBCFLAGS = -g -O2\n+GNATLIBCFLAGS_FOR_C = $(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS) -fexceptions \\\n+\t-DIN_RTS\n+ALL_ADA_CFLAGS = $(X_ADA_CFLAGS) $(T_ADA_CFLAGS) $(ADA_CFLAGS)\n+ALL_ADAFLAGS = $(CFLAGS) $(ALL_ADA_CFLAGS) $(X_ADAFLAGS) $(T_ADAFLAGS) \\\n+\t$(ADAFLAGS)\n+MOST_ADAFLAGS = $(CFLAGS) $(ALL_ADA_CFLAGS) $(X_ADAFLAGS) $(T_ADAFLAGS) \\\n+\t$(SOME_ADAFLAGS)\n+THREAD_KIND = native\n+THREADSLIB =\n+GMEM_LIB =\n+MISCLIB =\n+SYMDEPS = $(LIBINTL_DEP)\n+OUTPUT_OPTION = @OUTPUT_OPTION@\n+\n+objext = .o\n+exeext =\n+arext  = .a\n+soext  = .so\n+shext  =\n+hyphen = -\n+\n+# Define this as & to perform parallel make on a Sequent.\n+# Note that this has some bugs, and it seems currently necessary\n+# to compile all the gen* files first by hand to avoid erroneous results.\n+P =\n+\n+# This is used instead of ALL_CFLAGS when compiling with GCC_FOR_TARGET.\n+# It omits XCFLAGS, and specifies -B./.\n+# It also specifies -B$(tooldir)/ to find as and ld for a cross compiler.\n+GCC_CFLAGS = $(INTERNAL_CFLAGS) $(X_CFLAGS) $(T_CFLAGS) $(CFLAGS)\n+\n+# Tools to use when building a cross-compiler.\n+# These are used because `configure' appends `cross-make'\n+# to the makefile when making a cross-compiler.\n+\n+# We don't use cross-make.  Instead we use the tools from the build tree,\n+# if they are available.\n+# program_transform_name and objdir are set by configure.in.\n+program_transform_name =\n+objdir = .\n+\n+target_alias=@target_alias@\n+target=@target@\n+xmake_file = @xmake_file@\n+tmake_file = @tmake_file@\n+host_canonical=@host@\n+#version=`sed -e 's/.*\\\"\\([^ \\\"]*\\)[ \\\"].*/\\1/' < $(srcdir)/version.c`\n+#mainversion=`sed -e 's/.*\\\"\\([0-9]*\\.[0-9]*\\).*/\\1/' < $(srcdir)/version.c`\n+\n+# Directory where sources are, from where we are.\n+VPATH = $(srcdir)\n+\n+fsrcdir := $(shell cd $(srcdir);${PWD_COMMAND})\n+fsrcpfx := $(shell cd $(srcdir);${PWD_COMMAND})/\n+fcurdir := $(shell ${PWD_COMMAND})\n+fcurpfx := $(shell ${PWD_COMMAND})/\n+\n+# Top build directory, relative to here.\n+top_builddir = ../..\n+\n+# Internationalization library.\n+LIBINTL = @LIBINTL@\n+LIBINTL_DEP = @LIBINTL_DEP@\n+\n+# Any system libraries needed just for GNAT.\n+SYSLIBS = @GNAT_LIBEXC@\n+\n+# List of extra object files linked in with various programs.\n+EXTRA_GNATTOOLS_OBJS = ../../prefix.o ../../version.o\n+\n+# List of target dependent sources, overridden below as necessary\n+TARGET_ADA_SRCS =\n+\n+# Type of tools build we are doing; default is not compiling tools.\n+TOOLSCASE =\n+\n+# End of variables for you to override.\n+\n+all: all.indirect\n+\n+# This tells GNU Make version 3 not to put all variables in the environment.\n+.NOEXPORT:\n+\n+# tmake_file and xmake_file expand to lists with entries of the form\n+# $(srcdir)/config/...  but here $(srcdir) is the ada subdirectory so we\n+# need to adjust the paths.  There can't be spaces in the subst arguments\n+# or we get spurious spaces in the actual list of files to include.\n+\n+# target overrides\n+ifneq ($(tmake_file),)\n+include $(subst /config,/../config,$(tmake_file))\n+endif\n+\n+# host overrides\n+ifneq ($(xmake_file),)\n+include $(subst /config,/../config,$(xmake_file))\n+endif\n+\f\n+# Now figure out from those variables how to compile and link.\n+\n+all.indirect: Makefile ../gnat1$(exeext)\n+\n+# IN_GCC distinguishes between code compiled into GCC itself and other\n+# programs built during a bootstrap.\n+# autoconf inserts -DCROSS_DIRECTORY_STRUCTURE if we are building a cross\n+# compiler which does not use the native libraries and headers.\n+INTERNAL_CFLAGS = @CROSS@ -DIN_GCC\n+\n+# This is the variable actually used when we compile.\n+LOOSE_CFLAGS = `echo $(CFLAGS) $(WARN2_CFLAGS)|sed -e 's/-pedantic//g' -e 's/-Wtraditional//g'`\n+ALL_CFLAGS = $(INTERNAL_CFLAGS) $(X_CFLAGS) $(T_CFLAGS) $(LOOSE_CFLAGS) \\\n+\t$(XCFLAGS)\n+\n+# Likewise.\n+ALL_CPPFLAGS = $(CPPFLAGS) $(X_CPPFLAGS) $(T_CPPFLAGS)\n+\n+# This is where we get libiberty.a from.\n+LIBIBERTY = ../../libiberty/libiberty.a\n+\n+# How to link with both our special library facilities\n+# and the system's installed libraries.\n+LIBS = $(LIBINTL) $(LIBIBERTY) $(SYSLIBS)\n+LIBDEPS = $(LIBINTL_DEP) $(LIBIBERTY)\n+# Default is no TGT_LIB; one might be passed down or something\n+TGT_LIB =\n+TOOLS_LIBS = $(EXTRA_GNATTOOLS_OBJS) targext.o link.o $(LIBGNAT) ../../../libiberty/libiberty.a $(SYSLIBS) $(TGT_LIB)\n+\n+# Specify the directories to be searched for header files.\n+# Both . and srcdir are used, in that order,\n+# so that tm.h and config.h will be found in the compilation\n+# subdirectory rather than in the source directory.\n+INCLUDES = -I- -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config \\\n+\t-I$(srcdir)/../../include\n+\n+ADA_INCLUDES = -I- -I. -I$(srcdir)\n+\n+INCLUDES_FOR_SUBDIR = -I. -I.. -I../.. -I$(fsrcdir) -I$(fsrcdir)/../config \\\n+\t-I$(fsrcdir)/../../include -I$(fsrcdir)/..\n+ADA_INCLUDES_FOR_SUBDIR = -I. -I$(fsrcdir) -I$(fsrcdir)/gcc\n+\n+# Avoid a lot of time thinking about remaking Makefile.in and *.def.\n+.SUFFIXES: .in .def\n+\n+# Say how to compile Ada programs.\n+.SUFFIXES: .ada .adb .ads .asm\n+\n+# Always use -I$(srcdir)/config when compiling.\n+.asm.o:\n+\t$(CC) -c -x assembler $< $(OUTPUT_OPTION)\n+\n+.c.o:\n+\t$(CC) -c $(ALL_CFLAGS) $(ADA_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< \\\n+\t  $(OUTPUT_OPTION)\n+\n+.adb.o:\n+\t$(CC) -c $(ALL_ADAFLAGS) $(ADA_INCLUDES) $< $(OUTPUT_OPTION)\n+\n+.ads.o:\n+\t$(CC) -c $(ALL_ADAFLAGS) $(ADA_INCLUDES) $< $(OUTPUT_OPTION)\n+\n+# how to regenerate this file\n+Makefile: ../config.status $(srcdir)/gcc-interface/Makefile.in $(srcdir)/Makefile.in $(srcdir)/../version.c\n+\tcd ..; \\\n+\tLANGUAGES=\"$(CONFIG_LANGUAGES)\" \\\n+\tCONFIG_HEADERS= \\\n+\tCONFIG_FILES=\"ada/gcc-interface/Makefile ada/Makefile\" $(SHELL) config.status\n+\n+# This tells GNU make version 3 not to export all the variables\n+# defined in this file into the environment.\n+.NOEXPORT:\n+\f\n+# Lists of files for various purposes.\n+\n+GNATLINK_OBJS = gnatlink.o \\\n+ a-except.o ali.o alloc.o butil.o casing.o csets.o debug.o fmap.o fname.o \\\n+ gnatvsn.o hostparm.o indepsw.o interfac.o i-c.o i-cstrin.o namet.o opt.o \\\n+ osint.o output.o rident.o s-exctab.o s-secsta.o s-stalib.o s-stoele.o \\\n+ sdefault.o snames.o stylesw.o switch.o system.o table.o targparm.o tree_io.o \\\n+ types.o validsw.o widechar.o\n+\n+GNATMAKE_OBJS = a-except.o ali.o ali-util.o s-casuti.o \\\n+ alloc.o atree.o binderr.o butil.o casing.o csets.o debug.o elists.o einfo.o\\\n+ erroutc.o errutil.o err_vars.o fmap.o fname.o fname-uf.o fname-sf.o \\\n+ gnatmake.o gnatvsn.o hostparm.o interfac.o i-c.o i-cstrin.o krunch.o lib.o \\\n+ make.o makeusg.o makeutl.o mlib.o mlib-fil.o mlib-prj.o mlib-tgt.o \\\n+ mlib-tgt-specific.o mlib-utl.o namet.o nlists.o opt.o osint.o osint-m.o output.o \\\n+ prj.o prj-attr.o prj-attr-pm.o prj-com.o prj-dect.o prj-env.o prj-err.o prj-ext.o prj-nmsc.o \\\n+ prj-pars.o prj-part.o prj-proc.o prj-strt.o prj-tree.o prj-util.o \\\n+ rident.o s-exctab.o s-secsta.o s-stalib.o s-stoele.o \\\n+ scans.o scng.o sdefault.o sfn_scan.o s-purexc.o s-htable.o \\\n+ sinfo.o sinput.o sinput-c.o sinput-p.o \\\n+ snames.o stand.o stringt.o styleg.o stylesw.o system.o validsw.o switch.o switch-m.o \\\n+ table.o targparm.o tempdir.o tree_io.o types.o \\\n+ uintp.o uname.o urealp.o usage.o widechar.o \\\n+ $(EXTRA_GNATMAKE_OBJS)\n+\n+# Convert the target variable into a space separated list of architecture,\n+# manufacturer, and operating system and assign each of those to its own\n+# variable.\n+\n+host:=$(subst -, ,$(host_canonical))\n+targ:=$(subst -, ,$(target))\n+arch:=$(word 1,$(targ))\n+ifeq ($(words $(targ)),2)\n+  manu:=\n+  osys:=$(word 2,$(targ))\n+else\n+  manu:=$(word 2,$(targ))\n+  osys:=$(word 3,$(targ))\n+endif\n+\n+# LIBGNAT_TARGET_PAIRS is a list of pairs of filenames.\n+# The members of each pair must be separated by a '<' and no whitespace.\n+# Each pair must be separated by some amount of whitespace from the following\n+# pair.\n+\n+# Non-tasking case:\n+\n+LIBGNAT_TARGET_PAIRS = \\\n+a-intnam.ads<a-intnam-dummy.ads \\\n+s-inmaop.adb<s-inmaop-dummy.adb \\\n+s-intman.adb<s-intman-dummy.adb \\\n+s-osinte.ads<s-osinte-dummy.ads \\\n+s-osprim.adb<s-osprim-posix.adb \\\n+s-taprop.adb<s-taprop-dummy.adb \\\n+s-taspri.ads<s-taspri-dummy.ads\n+\n+# When using the GCC exception handling mechanism, we need to use an\n+# alternate body for a-exexpr.adb (a-exexpr-gcc.adb)\n+\n+EH_MECHANISM=\n+\n+# Default shared object option. Note that we rely on the fact that the \"soname\"\n+# option will always be present and last in this flag, so that we can have\n+# $(SO_OPTS)libgnat-x.xx\n+\n+SO_OPTS = -Wl,-soname,\n+\n+# Default gnatlib-shared target.\n+# By default, equivalent to gnatlib.\n+# Set to gnatlib-shared-default, gnatlib-shared-dual, or a platform specific\n+# target when supported.\n+GNATLIB_SHARED = gnatlib\n+\n+# default value for gnatmake's target dependent file\n+MLIB_TGT = mlib-tgt\n+\n+# By default, do not distribute prefix.o (in libgccprefix), since it is only\n+# needed by external GNAT tools such as gnatdist and Glide.\n+# Override this variable on native platforms when needed.\n+PREFIX_OBJS =\n+\n+# To avoid duplicate code, use this variable to set PREFIX_OBJS when needed:\n+PREFIX_REAL_OBJS = ../prefix.o \\\n+  ../../libiberty/concat.o     \\\n+  ../../libiberty/xmalloc.o    \\\n+  ../../libiberty/xstrdup.o    \\\n+  ../../libiberty/xexit.o\n+\n+LIB_VERSION = $(strip $(shell grep ' Library_Version :' $(fsrcpfx)gnatvsn.ads | sed -e 's/.*\"\\(.*\\)\".*/\\1/'))\n+\n+# $(filter-out PATTERN...,TEXT) removes all PATTERN words from TEXT.\n+# $(strip STRING) removes leading and trailing spaces from STRING.\n+# If what's left is null then it's a match.\n+\n+ifeq ($(strip $(filter-out m68k% wrs vx%,$(targ))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-intnam.ads<a-intnam-vxworks.ads \\\n+  a-numaux.ads<a-numaux-vxworks.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-interr.adb<s-interr-vxworks.adb \\\n+  s-intman.ads<s-intman-vxworks.ads \\\n+  s-intman.adb<s-intman-vxworks.adb \\\n+  s-osinte.adb<s-osinte-vxworks.adb \\\n+  s-osinte.ads<s-osinte-vxworks.ads \\\n+  s-osprim.adb<s-osprim-vxworks.adb \\\n+  s-parame.ads<s-parame-vxworks.ads \\\n+  s-parame.adb<s-parame-vxworks.adb \\\n+  s-stchop.ads<s-stchop-limit.ads \\\n+  s-stchop.adb<s-stchop-vxworks.adb \\\n+  s-taprop.adb<s-taprop-vxworks.adb \\\n+  s-taspri.ads<s-taspri-vxworks.ads \\\n+  s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n+  s-vxwork.ads<s-vxwork-m68k.ads \\\n+  g-soccon.ads<g-soccon-vxworks.ads \\\n+  g-socthi.ads<g-socthi-vxworks.ads \\\n+  g-socthi.adb<g-socthi-vxworks.adb \\\n+  g-stsifd.adb<g-stsifd-sockets.adb \\\n+  g-sttsne.adb<g-sttsne-vxworks.adb \\\n+  g-sttsne.ads<g-sttsne-locking.ads \\\n+  system.ads<system-vxworks-m68k.ads\n+\n+  TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb\n+\n+  EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o\n+  EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n+\n+  EXTRA_LIBGNAT_SRCS+=vx_stack_info.c\n+  EXTRA_LIBGNAT_OBJS+=vx_stack_info.o\n+\n+  ifeq ($(strip $(filter-out yes,$(TRACE))),)\n+    LIBGNAT_TARGET_PAIRS += \\\n+    s-traces.adb<s-traces-default.adb \\\n+    s-tratas.adb<s-tratas-default.adb \\\n+    s-trafor.adb<s-trafor-default.adb \\\n+    s-trafor.ads<s-trafor-default.ads \\\n+    s-tfsetr.adb<s-tfsetr-vxworks.adb\n+  endif\n+endif\n+\n+ifeq ($(strip $(filter-out powerpc% wrs vxworks,$(targ))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-intnam.ads<a-intnam-vxworks.ads \\\n+  a-numaux.ads<a-numaux-vxworks.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-intman.ads<s-intman-vxworks.ads \\\n+  s-intman.adb<s-intman-vxworks.adb \\\n+  s-osprim.adb<s-osprim-vxworks.adb \\\n+  s-parame.ads<s-parame-vxworks.ads \\\n+  s-parame.adb<s-parame-vxworks.adb \\\n+  s-stchop.ads<s-stchop-limit.ads \\\n+  s-stchop.adb<s-stchop-vxworks.adb \\\n+  s-taprop.adb<s-taprop-vxworks.adb \\\n+  s-taspri.ads<s-taspri-vxworks.ads \\\n+  s-vxwork.ads<s-vxwork-ppc.ads \\\n+  g-soccon.ads<g-soccon-vxworks.ads \\\n+  g-socthi.ads<g-socthi-vxworks.ads \\\n+  g-socthi.adb<g-socthi-vxworks.adb \\\n+  g-stsifd.adb<g-stsifd-sockets.adb \\\n+  g-sttsne.adb<g-sttsne-vxworks.adb \\\n+  g-sttsne.ads<g-sttsne-locking.ads\n+\n+  TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb\n+\n+  ifeq ($(strip $(filter-out yes,$(TRACE))),)\n+    LIBGNAT_TARGET_PAIRS += \\\n+    s-traces.adb<s-traces-default.adb \\\n+    s-trafor.adb<s-trafor-default.adb \\\n+    s-trafor.ads<s-trafor-default.ads \\\n+    s-tratas.adb<s-tratas-default.adb \\\n+    s-tfsetr.adb<s-tfsetr-vxworks.adb\n+  endif\n+\n+  ifeq ($(strip $(filter-out rtp,$(THREAD_KIND))),)\n+    LIBGNAT_TARGET_PAIRS += \\\n+    s-osinte.adb<s-osinte-vxworks-rtp.adb \\\n+    s-osinte.ads<s-osinte-vxworks6.ads \\\n+    s-tpopsp.adb<s-tpopsp-vxworks-rtp.adb \\\n+    system.ads<system-vxworks-ppc-rtp.ads\n+\n+    EXTRA_GNATRTL_NONTASKING_OBJS=s-vxwexc.o\n+  else\n+    LIBGNAT_TARGET_PAIRS += \\\n+    s-interr.adb<s-interr-vxworks.adb \\\n+    s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n+    system.ads<system-vxworks-ppc.ads\n+\n+    ifeq ($(strip $(filter-out kernel,$(THREAD_KIND))),)\n+      LIBGNAT_TARGET_PAIRS += \\\n+      s-osinte.ads<s-osinte-vxworks6.ads \\\n+      s-osinte.adb<s-osinte-vxworks-kernel.adb\n+    else\n+      LIBGNAT_TARGET_PAIRS += \\\n+      s-osinte.ads<s-osinte-vxworks.ads \\\n+      s-osinte.adb<s-osinte-vxworks.adb\n+    endif\n+\n+    EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o s-vxwexc.o\n+  endif\n+\n+  EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n+\n+  EXTRA_LIBGNAT_SRCS+=vx_stack_info.c\n+  EXTRA_LIBGNAT_OBJS+=vx_stack_info.o\n+endif\n+\n+# vxworksae / vxworks 653\n+ifeq ($(strip $(filter-out powerpc% wrs vxworksae,$(targ))),)\n+  # target pairs for kernel + vthreads runtime\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-elchha.adb<a-elchha-vxworks-ppc-full.adb \\\n+  a-intnam.ads<a-intnam-vxworks.ads \\\n+  a-numaux.ads<a-numaux-vxworks.ads \\\n+  g-io.adb<g-io-vxworks-ppc-cert.adb \\\n+  g-io.ads<g-io-vxworks-ppc-cert.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-interr.adb<s-interr-vxworks.adb \\\n+  s-intman.ads<s-intman-vxworks.ads \\\n+  s-intman.adb<s-intman-vxworks.adb \\\n+  s-osinte.adb<s-osinte-vxworks.adb \\\n+  s-osinte.ads<s-osinte-vxworks.ads \\\n+  s-osprim.adb<s-osprim-vxworks.adb \\\n+  s-parame.ads<s-parame-ae653.ads \\\n+  s-parame.adb<s-parame-vxworks.adb \\\n+  s-taprop.adb<s-taprop-vxworks.adb \\\n+  s-taspri.ads<s-taspri-vxworks.ads \\\n+  s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n+  s-vxwork.ads<s-vxwork-ppc.ads \\\n+  g-soccon.ads<g-soccon-vxworks.ads \\\n+  g-socthi.ads<g-socthi-vxworks.ads \\\n+  g-socthi.adb<g-socthi-vxworks.adb \\\n+  g-stsifd.adb<g-stsifd-sockets.adb \\\n+  g-sttsne.adb<g-sttsne-vxworks.adb \\\n+  g-sttsne.ads<g-sttsne-locking.ads \\\n+  system.ads<system-vxworks-ppc-vthread.ads\n+\n+  TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb\n+\n+  EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o s-vxwexc.o\n+  EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n+\n+  # Extra pairs for the vthreads runtime\n+  ifeq ($(strip $(filter-out vthreads,$(THREAD_KIND))),)\n+    LIBGNAT_TARGET_PAIRS += \\\n+    s-thread.adb<s-thread-ae653.adb\n+    EXTRA_GNATRTL_NONTASKING_OBJS += s-thread.o\n+  endif\n+\n+  ifeq ($(strip $(filter-out yes,$(TRACE))),)\n+    LIBGNAT_TARGET_PAIRS += \\\n+    s-traces.adb<s-traces-default.adb \\\n+    s-trafor.adb<s-trafor-default.adb \\\n+    s-trafor.ads<s-trafor-default.ads \\\n+    s-tratas.adb<s-tratas-default.adb \\\n+    s-tfsetr.adb<s-tfsetr-vxworks.adb\n+  endif\n+endif\n+\n+ifeq ($(strip $(filter-out sparc% wrs vx%,$(targ))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-intnam.ads<a-intnam-vxworks.ads \\\n+  a-numaux.ads<a-numaux-vxworks.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-interr.adb<s-interr-vxworks.adb \\\n+  s-intman.ads<s-intman-vxworks.ads \\\n+  s-intman.adb<s-intman-vxworks.adb \\\n+  s-osinte.adb<s-osinte-vxworks.adb \\\n+  s-osinte.ads<s-osinte-vxworks.ads \\\n+  s-osprim.adb<s-osprim-vxworks.adb \\\n+  s-parame.ads<s-parame-vxworks.ads \\\n+  s-parame.adb<s-parame-vxworks.adb \\\n+  s-stchop.ads<s-stchop-limit.ads \\\n+  s-stchop.adb<s-stchop-vxworks.adb \\\n+  s-taprop.adb<s-taprop-vxworks.adb \\\n+  s-taspri.ads<s-taspri-vxworks.ads \\\n+  s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n+  s-vxwork.ads<s-vxwork-sparcv9.ads \\\n+  g-soccon.ads<g-soccon-vxworks.ads \\\n+  g-socthi.ads<g-socthi-vxworks.ads \\\n+  g-socthi.adb<g-socthi-vxworks.adb \\\n+  g-stsifd.adb<g-stsifd-sockets.adb \\\n+  g-sttsne.adb<g-sttsne-vxworks.adb \\\n+  g-sttsne.ads<g-sttsne-locking.ads \\\n+  system.ads<system-vxworks-sparcv9.ads   \\\n+\n+  TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb\n+\n+  EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o\n+  EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n+\n+  EXTRA_LIBGNAT_SRCS+=vx_stack_info.c\n+  EXTRA_LIBGNAT_OBJS+=vx_stack_info.o\n+endif\n+\n+ifeq ($(strip $(filter-out %86 wrs vxworks,$(targ))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-intnam.ads<a-intnam-vxworks.ads \\\n+  i-vxwork.ads<i-vxwork-x86.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-intman.ads<s-intman-vxworks.ads \\\n+  s-intman.adb<s-intman-vxworks.adb \\\n+  a-numaux.adb<a-numaux-x86.adb \\\n+  a-numaux.ads<a-numaux-x86.ads \\\n+  s-osprim.adb<s-osprim-vxworks.adb \\\n+  s-parame.ads<s-parame-vxworks.ads \\\n+  s-parame.adb<s-parame-vxworks.adb \\\n+  s-stchop.ads<s-stchop-limit.ads \\\n+  s-stchop.adb<s-stchop-vxworks.adb \\\n+  s-taprop.adb<s-taprop-vxworks.adb \\\n+  s-taspri.ads<s-taspri-vxworks.ads \\\n+  s-vxwork.ads<s-vxwork-x86.ads \\\n+  g-bytswa.adb<g-bytswa-x86.adb \\\n+  g-soccon.ads<g-soccon-vxworks.ads \\\n+  g-socthi.ads<g-socthi-vxworks.ads \\\n+  g-socthi.adb<g-socthi-vxworks.adb \\\n+  g-stsifd.adb<g-stsifd-sockets.adb \\\n+  g-sttsne.adb<g-sttsne-vxworks.adb \\\n+  g-sttsne.ads<g-sttsne-locking.ads\n+\n+  TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb\n+\n+  ifeq ($(strip $(filter-out yes,$(TRACE))),)\n+    LIBGNAT_TARGET_PAIRS += \\\n+    s-traces.adb<s-traces-default.adb \\\n+    s-trafor.adb<s-trafor-default.adb \\\n+    s-trafor.ads<s-trafor-default.ads \\\n+    s-tratas.adb<s-tratas-default.adb \\\n+    s-tfsetr.adb<s-tfsetr-vxworks.adb\n+  endif\n+\n+  ifeq ($(strip $(filter-out rtp,$(THREAD_KIND))),)\n+    LIBGNAT_TARGET_PAIRS += \\\n+    s-osinte.adb<s-osinte-vxworks-rtp.adb \\\n+    s-osinte.ads<s-osinte-vxworks6.ads \\\n+    s-tpopsp.adb<s-tpopsp-vxworks-rtp.adb \\\n+    system.ads<system-vxworks-x86-rtp.ads\n+\n+    EXTRA_GNATRTL_NONTASKING_OBJS=s-vxwexc.o\n+  else\n+    LIBGNAT_TARGET_PAIRS += \\\n+    s-interr.adb<s-interr-vxworks.adb \\\n+    s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n+    system.ads<system-vxworks-x86.ads\n+\n+    ifeq ($(strip $(filter-out kernel,$(THREAD_KIND))),)\n+      LIBGNAT_TARGET_PAIRS += \\\n+      s-osinte.ads<s-osinte-vxworks6.ads \\\n+      s-osinte.adb<s-osinte-vxworks-kernel.adb\n+    else\n+      LIBGNAT_TARGET_PAIRS += \\\n+      s-osinte.ads<s-osinte-vxworks.ads \\\n+      s-osinte.adb<s-osinte-vxworks.adb\n+    endif\n+\n+    EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o s-vxwexc.o\n+  endif\n+\n+  EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n+\n+  EXTRA_LIBGNAT_SRCS+=vx_stack_info.c\n+  EXTRA_LIBGNAT_OBJS+=vx_stack_info.o\n+endif\n+\n+ifeq ($(strip $(filter-out arm% coff wrs vx%,$(targ))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-intnam.ads<a-intnam-vxworks.ads \\\n+  a-numaux.ads<a-numaux-vxworks.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-interr.adb<s-interr-vxworks.adb \\\n+  s-intman.ads<s-intman-vxworks.ads \\\n+  s-intman.adb<s-intman-vxworks.adb \\\n+  s-osinte.adb<s-osinte-vxworks.adb \\\n+  s-osinte.ads<s-osinte-vxworks.ads \\\n+  s-osprim.adb<s-osprim-vxworks.adb \\\n+  s-parame.ads<s-parame-vxworks.ads \\\n+  s-parame.adb<s-parame-vxworks.adb \\\n+  s-stchop.ads<s-stchop-limit.ads \\\n+  s-stchop.adb<s-stchop-vxworks.adb \\\n+  s-taprop.adb<s-taprop-vxworks.adb \\\n+  s-taspri.ads<s-taspri-vxworks.ads \\\n+  s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n+  s-vxwork.ads<s-vxwork-arm.ads \\\n+  g-soccon.ads<g-soccon-vxworks.ads \\\n+  g-socthi.ads<g-socthi-vxworks.ads \\\n+  g-socthi.adb<g-socthi-vxworks.adb \\\n+  g-stsifd.adb<g-stsifd-sockets.adb \\\n+  g-sttsne.adb<g-sttsne-vxworks.adb \\\n+  g-sttsne.ads<g-sttsne-locking.ads \\\n+  system.ads<system-vxworks-arm.ads\n+\n+  TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb\n+\n+  EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o\n+  EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n+\n+  EXTRA_LIBGNAT_SRCS+=vx_stack_info.c\n+  EXTRA_LIBGNAT_OBJS+=vx_stack_info.o\n+endif\n+\n+ifeq ($(strip $(filter-out mips% wrs vx%,$(targ))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-intnam.ads<a-intnam-vxworks.ads \\\n+  a-numaux.ads<a-numaux-vxworks.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-interr.adb<s-interr-vxworks.adb \\\n+  s-intman.ads<s-intman-vxworks.ads \\\n+  s-intman.adb<s-intman-vxworks.adb \\\n+  s-osinte.adb<s-osinte-vxworks.adb \\\n+  s-osinte.ads<s-osinte-vxworks.ads \\\n+  s-osprim.adb<s-osprim-vxworks.adb \\\n+  s-parame.ads<s-parame-vxworks.ads \\\n+  s-parame.adb<s-parame-vxworks.adb \\\n+  s-stchop.ads<s-stchop-limit.ads \\\n+  s-stchop.adb<s-stchop-vxworks.adb \\\n+  s-taprop.adb<s-taprop-vxworks.adb \\\n+  s-taspri.ads<s-taspri-vxworks.ads \\\n+  s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n+  s-vxwork.ads<s-vxwork-mips.ads \\\n+  g-soccon.ads<g-soccon-vxworks.ads \\\n+  g-socthi.ads<g-socthi-vxworks.ads \\\n+  g-socthi.adb<g-socthi-vxworks.adb \\\n+  g-stsifd.adb<g-stsifd-sockets.adb \\\n+  g-sttsne.adb<g-sttsne-vxworks.adb \\\n+  g-sttsne.ads<g-sttsne-locking.ads \\\n+  system.ads<system-vxworks-mips.ads\n+\n+  TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb\n+\n+  EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o\n+  EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n+\n+  EXTRA_LIBGNAT_SRCS+=vx_stack_info.c\n+  EXTRA_LIBGNAT_OBJS+=vx_stack_info.o\n+endif\n+\n+ifeq ($(strip $(filter-out sparc% sun solaris%,$(targ))),)\n+  LIBGNAT_TARGET_PAIRS_32 = \\\n+  a-intnam.ads<a-intnam-solaris.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-intman.adb<s-intman-solaris.adb \\\n+  s-osinte.adb<s-osinte-solaris.adb \\\n+  s-osinte.ads<s-osinte-solaris.ads \\\n+  s-osprim.adb<s-osprim-solaris.adb \\\n+  s-taprop.adb<s-taprop-solaris.adb \\\n+  s-tasinf.adb<s-tasinf-solaris.adb \\\n+  s-tasinf.ads<s-tasinf-solaris.ads \\\n+  s-taspri.ads<s-taspri-solaris.ads \\\n+  s-tpopsp.adb<s-tpopsp-solaris.adb \\\n+  g-soccon.ads<g-soccon-solaris.ads \\\n+  g-soliop.ads<g-soliop-solaris.ads \\\n+  system.ads<system-solaris-sparc.ads\n+\n+  LIBGNAT_TARGET_PAIRS_64 = \\\n+  a-intnam.ads<a-intnam-solaris.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-intman.adb<s-intman-solaris.adb \\\n+  s-osinte.adb<s-osinte-solaris.adb \\\n+  s-osinte.ads<s-osinte-solaris.ads \\\n+  s-osprim.adb<s-osprim-solaris.adb \\\n+  s-taprop.adb<s-taprop-solaris.adb \\\n+  s-tasinf.adb<s-tasinf-solaris.adb \\\n+  s-tasinf.ads<s-tasinf-solaris.ads \\\n+  s-taspri.ads<s-taspri-solaris.ads \\\n+  s-tpopsp.adb<s-tpopsp-solaris.adb \\\n+  g-soccon.ads<g-soccon-solaris-64.ads \\\n+  g-soliop.ads<g-soliop-solaris.ads \\\n+  system.ads<system-solaris-sparcv9.ads\n+\n+  ifeq ($(strip $(filter-out sparc sun solaris%,$(targ))),)\n+    LIBGNAT_TARGET_PAIRS = $(LIBGNAT_TARGET_PAIRS_32)\n+  else\n+    LIBGNAT_TARGET_PAIRS = $(LIBGNAT_TARGET_PAIRS_64)\n+  endif\n+\n+  TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-solaris.adb\n+\n+  EH_MECHANISM=-gcc\n+  THREADSLIB = -lposix4 -lthread\n+  MISCLIB = -lposix4 -lnsl -lsocket\n+  SO_OPTS = -Wl,-h,\n+  GNATLIB_SHARED = gnatlib-shared-dual\n+  GMEM_LIB = gmemlib\n+  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n+  LIBRARY_VERSION := $(LIB_VERSION)\n+\n+  ifeq ($(strip $(filter-out pthread PTHREAD,$(THREAD_KIND))),)\n+    LIBGNAT_TARGET_PAIRS = \\\n+    a-intnam.ads<a-intnam-solaris.ads \\\n+    s-inmaop.adb<s-inmaop-posix.adb \\\n+    s-intman.adb<s-intman-posix.adb \\\n+    s-osinte.adb<s-osinte-posix.adb \\\n+    s-osinte.ads<s-osinte-solaris-posix.ads \\\n+    s-osprim.adb<s-osprim-solaris.adb \\\n+    s-taprop.adb<s-taprop-posix.adb \\\n+    s-taspri.ads<s-taspri-posix.ads \\\n+    s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+    g-soccon.ads<g-soccon-solaris.ads \\\n+    g-soliop.ads<g-soliop-solaris.ads \\\n+    system.ads<system-solaris-sparc.ads\n+\n+    THREADSLIB = -lposix4 -lpthread\n+  endif\n+\n+  ifeq ($(strip $(filter-out m64,$(THREAD_KIND))),)\n+    LIBGNAT_TARGET_PAIRS = $(LIBGNAT_TARGET_PAIRS_64)\n+  endif\n+endif\n+\n+ifeq ($(strip $(filter-out %86 solaris2%,$(arch) $(osys))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-numaux.adb<a-numaux-x86.adb \\\n+  a-numaux.ads<a-numaux-x86.ads \\\n+  a-intnam.ads<a-intnam-solaris.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-intman.adb<s-intman-solaris.adb \\\n+  s-osinte.adb<s-osinte-solaris.adb \\\n+  s-osinte.ads<s-osinte-solaris.ads \\\n+  s-osprim.adb<s-osprim-solaris.adb \\\n+  s-taprop.adb<s-taprop-solaris.adb \\\n+  s-tasinf.adb<s-tasinf-solaris.adb \\\n+  s-tasinf.ads<s-tasinf-solaris.ads \\\n+  s-taspri.ads<s-taspri-solaris.ads \\\n+  s-tpopsp.adb<s-tpopsp-solaris.adb \\\n+  g-bytswa.adb<g-bytswa-x86.adb \\\n+  g-soccon.ads<g-soccon-solaris.ads \\\n+  g-soliop.ads<g-soliop-solaris.ads \\\n+  system.ads<system-solaris-x86.ads\n+\n+  TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-solaris.adb\n+\n+  EH_MECHANISM=-gcc\n+  THREADSLIB = -lposix4 -lthread\n+  MISCLIB = -lposix4 -lnsl -lsocket\n+  SO_OPTS = -Wl,-h,\n+  GNATLIB_SHARED = gnatlib-shared-dual\n+  GMEM_LIB = gmemlib\n+  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n+  LIBRARY_VERSION := $(LIB_VERSION)\n+endif\n+\n+ifeq ($(strip $(filter-out %86 linux%,$(arch) $(osys))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-intnam.ads<a-intnam-linux.ads \\\n+  a-numaux.adb<a-numaux-x86.adb \\\n+  a-numaux.ads<a-numaux-x86.ads \\\n+  g-bytswa.adb<g-bytswa-x86.adb \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-intman.adb<s-intman-posix.adb \\\n+  s-osprim.adb<s-osprim-posix.adb \\\n+  s-taspri.ads<s-taspri-posix.ads \\\n+  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+  g-sercom.adb<g-sercom-linux.adb \\\n+  system.ads<system-linux-x86.ads\n+\n+  ifeq ($(strip $(filter-out marte,$(THREAD_KIND))),)\n+    LIBGNAT_TARGET_PAIRS += \\\n+    a-exetim.adb<a-exetim-linux-marte.adb \\\n+    a-exetim.ads<a-exetim-linux-marte.ads \\\n+    a-extiti.adb<a-extiti-linux-marte.adb \\\n+    a-extiti.ads<a-extiti-linux-marte.ads \\\n+    a-rttiev.adb<a-rttiev-linux-marte.adb \\\n+    a-rttiev.ads<a-rttiev-linux-marte.ads \\\n+    g-soccon.ads<g-soccon-linux-x86-marte.ads \\\n+    s-osinte.adb<s-osinte-linux-marte.adb \\\n+    s-osinte.ads<s-osinte-linux-marte.ads \\\n+    s-taprop.adb<s-taprop-linux-marte.adb\n+\n+    EXTRA_GNATRTL_TASKING_OBJS=a-exetim.o a-extiti.o\n+\n+    EH_MECHANISM=\n+    THREADSLIB = -lmarte\n+  else\n+    LIBGNAT_TARGET_PAIRS += \\\n+    g-soccon.ads<g-soccon-linux-x86.ads \\\n+    s-linux.ads<s-linux.ads \\\n+    s-osinte.adb<s-osinte-posix.adb \\\n+    s-osinte.ads<s-osinte-linux.ads \\\n+    s-tasinf.ads<s-tasinf-linux.ads \\\n+    s-tasinf.adb<s-tasinf-linux.adb \\\n+    s-taprop.adb<s-taprop-linux.adb\n+\n+    EH_MECHANISM=-gcc\n+    THREADSLIB = -lpthread\n+    EXTRA_GNATRTL_TASKING_OBJS=s-linux.o\n+  endif\n+\n+  TOOLS_TARGET_PAIRS =  \\\n+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \\\n+    indepsw.adb<indepsw-gnu.adb\n+\n+  GNATLIB_SHARED = gnatlib-shared-dual\n+  GMEM_LIB = gmemlib\n+  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n+  LIBRARY_VERSION := $(LIB_VERSION)\n+endif\n+\n+ifeq ($(strip $(filter-out %86 kfreebsd%,$(arch) $(osys))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-intnam.ads<a-intnam-freebsd.ads \\\n+  a-numaux.adb<a-numaux-x86.adb \\\n+  a-numaux.ads<a-numaux-x86.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-intman.adb<s-intman-posix.adb \\\n+  g-soccon.ads<g-soccon-freebsd.ads \\\n+  s-osinte.adb<s-osinte-posix.adb \\\n+  s-osinte.ads<s-osinte-kfreebsd-gnu.ads \\\n+  s-osprim.adb<s-osprim-posix.adb \\\n+  s-taprop.adb<s-taprop-linux.adb \\\n+  s-tasinf.ads<s-tasinf-linux.ads \\\n+  s-tasinf.adb<s-tasinf-linux.adb \\\n+  s-taspri.ads<s-taspri-posix.ads \\\n+  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+  system.ads<system-freebsd-x86.ads\n+\n+  TOOLS_TARGET_PAIRS =  \\\n+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \\\n+    indepsw.adb<indepsw-gnu.adb\n+\n+  EH_MECHANISM=-gcc\n+  THREADSLIB = -lpthread\n+  GNATLIB_SHARED = gnatlib-shared-dual\n+  GMEM_LIB = gmemlib\n+  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n+  LIBRARY_VERSION := $(LIB_VERSION)\n+endif\n+\n+ifeq ($(strip $(filter-out %86 freebsd%,$(arch) $(osys))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-intnam.ads<a-intnam-freebsd.ads \\\n+  a-numaux.adb<a-numaux-x86.adb \\\n+  a-numaux.ads<a-numaux-x86.ads \\\n+  g-bytswa.adb<g-bytswa-x86.adb \\\n+  g-soccon.ads<g-soccon-freebsd.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-intman.adb<s-intman-posix.adb \\\n+  s-osinte.adb<s-osinte-freebsd.adb \\\n+  s-osinte.ads<s-osinte-freebsd.ads \\\n+  s-osprim.adb<s-osprim-posix.adb \\\n+  s-taprop.adb<s-taprop-posix.adb \\\n+  s-taspri.ads<s-taspri-posix.ads \\\n+  s-tpopsp.adb<s-tpopsp-posix.adb \\\n+  system.ads<system-freebsd-x86.ads\n+\n+  TOOLS_TARGET_PAIRS = \\\n+  mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb\n+  GNATLIB_SHARED = gnatlib-shared-dual\n+\n+  EH_MECHANISM=-gcc\n+  THREADSLIB= -lpthread\n+  GMEM_LIB = gmemlib\n+  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n+  LIBRARY_VERSION := $(LIB_VERSION)\n+endif\n+\n+ifeq ($(strip $(filter-out s390% linux%,$(arch) $(osys))),)\n+  ifeq ($(strip $(filter-out s390x,$(arch))),)\n+    LIBGNAT_TARGET_PAIRS = \\\n+    a-intnam.ads<a-intnam-linux.ads \\\n+    s-inmaop.adb<s-inmaop-posix.adb \\\n+    s-intman.adb<s-intman-posix.adb \\\n+    s-linux.ads<s-linux.ads \\\n+    s-osinte.adb<s-osinte-posix.adb \\\n+    s-osinte.ads<s-osinte-linux.ads \\\n+    s-osprim.adb<s-osprim-posix.adb \\\n+    s-taprop.adb<s-taprop-linux.adb \\\n+    s-tasinf.ads<s-tasinf-linux.ads \\\n+    s-tasinf.adb<s-tasinf-linux.adb \\\n+    s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n+    s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+    system.ads<system-linux-s390x.ads\n+  else\n+    LIBGNAT_TARGET_PAIRS = \\\n+    a-intnam.ads<a-intnam-linux.ads \\\n+    s-inmaop.adb<s-inmaop-posix.adb \\\n+    s-intman.adb<s-intman-posix.adb \\\n+    s-linux.ads<s-linux.ads \\\n+    s-osinte.adb<s-osinte-posix.adb \\\n+    s-osinte.ads<s-osinte-linux.ads \\\n+    s-osprim.adb<s-osprim-posix.adb \\\n+    s-taprop.adb<s-taprop-linux.adb \\\n+    s-tasinf.ads<s-tasinf-linux.ads \\\n+    s-tasinf.adb<s-tasinf-linux.adb \\\n+    s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n+    s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+    system.ads<system-linux-s390.ads\n+  endif\n+\n+  TOOLS_TARGET_PAIRS =  \\\n+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb\n+\n+  EXTRA_GNATRTL_TASKING_OBJS=s-linux.o\n+  EH_MECHANISM=-gcc\n+  THREADSLIB = -lpthread\n+  GNATLIB_SHARED = gnatlib-shared-dual\n+  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n+  LIBRARY_VERSION := $(LIB_VERSION)\n+endif\n+\n+ifeq ($(strip $(filter-out mips sgi irix%,$(targ))),)\n+  ifeq ($(strip $(filter-out mips sgi irix6%,$(targ))),)\n+    LIBGNAT_TARGET_PAIRS = \\\n+    a-intnam.ads<a-intnam-irix.ads \\\n+    s-inmaop.adb<s-inmaop-posix.adb \\\n+    s-intman.adb<s-intman-irix.adb \\\n+    s-mastop.adb<s-mastop-irix.adb \\\n+    s-osinte.adb<s-osinte-irix.adb \\\n+    s-osinte.ads<s-osinte-irix.ads \\\n+    s-osprim.adb<s-osprim-posix.adb \\\n+    s-proinf.adb<s-proinf-irix-athread.adb \\\n+    s-proinf.ads<s-proinf-irix-athread.ads \\\n+    s-taprop.adb<s-taprop-irix.adb \\\n+    s-tasinf.ads<s-tasinf-irix.ads \\\n+    s-taspri.ads<s-taspri-posix.ads \\\n+    s-tpopsp.adb<s-tpopsp-posix.adb \\\n+    s-traceb.adb<s-traceb-mastop.adb \\\n+    g-soccon.ads<g-soccon-irix.ads \\\n+    system.ads<system-irix-n32.ads\n+\n+    THREADSLIB = -lpthread\n+    GNATLIB_SHARED = gnatlib-shared-default\n+\n+  else\n+    LIBGNAT_TARGET_PAIRS += \\\n+    s-mastop.adb<s-mastop-irix.adb \\\n+    s-osprim.adb<s-osprim-posix.adb \\\n+    s-traceb.adb<s-traceb-mastop.adb \\\n+    g-soccon.ads<g-soccon-irix.ads \\\n+    system.ads<system-irix-o32.ads\n+  endif\n+\n+  EH_MECHANISM=-gcc\n+  TOOLS_TARGET_PAIRS = mlib-tgt-specific.adb<mlib-tgt-specific-irix.adb\n+  TGT_LIB = -lexc\n+  MISCLIB = -lexc\n+  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n+  LIBRARY_VERSION := $(LIB_VERSION)\n+  GMEM_LIB = gmemlib\n+endif\n+\n+ifeq ($(strip $(filter-out hppa% hp hpux10%,$(targ))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-excpol.adb<a-excpol-abort.adb \\\n+  a-intnam.ads<a-intnam-hpux.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-interr.adb<s-interr-sigaction.adb \\\n+  s-intman.adb<s-intman-posix.adb \\\n+  s-osinte.adb<s-osinte-hpux-dce.adb \\\n+  s-osinte.ads<s-osinte-hpux-dce.ads \\\n+  s-parame.ads<s-parame-hpux.ads \\\n+  s-osprim.adb<s-osprim-posix.adb \\\n+  s-taprop.adb<s-taprop-hpux-dce.adb \\\n+  s-taspri.ads<s-taspri-hpux-dce.ads \\\n+  s-tpopsp.adb<s-tpopsp-posix.adb \\\n+  g-soccon.ads<g-soccon-hpux.ads \\\n+  system.ads<system-hpux.ads\n+\n+  EH_MECHANISM=-gcc\n+  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n+endif\n+\n+ifeq ($(strip $(filter-out hppa% hp hpux11%,$(targ))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-intnam.ads<a-intnam-hpux.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-intman.adb<s-intman-posix.adb \\\n+  s-osinte.adb<s-osinte-posix.adb \\\n+  s-osinte.ads<s-osinte-hpux.ads \\\n+  s-parame.ads<s-parame-hpux.ads \\\n+  s-osprim.adb<s-osprim-posix.adb \\\n+  s-traceb.adb<s-traceb-hpux.adb \\\n+  s-taprop.adb<s-taprop-posix.adb \\\n+  s-taspri.ads<s-taspri-posix.ads \\\n+  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+  g-soccon.ads<g-soccon-hpux.ads \\\n+  system.ads<system-hpux.ads\n+\n+  TOOLS_TARGET_PAIRS = mlib-tgt-specific.adb<mlib-tgt-specific-hpux.adb\n+  EH_MECHANISM=-gcc\n+  TGT_LIB = /usr/lib/libcl.a\n+  THREADSLIB = -lpthread\n+  GMEM_LIB = gmemlib\n+  soext = .sl\n+  SO_OPTS = -Wl,+h,\n+  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n+  GNATLIB_SHARED = gnatlib-shared-dual\n+  LIBRARY_VERSION := $(LIB_VERSION)\n+endif\n+\n+ifeq ($(strip $(filter-out ibm aix%,$(manu) $(osys))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-intnam.ads<a-intnam-aix.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-intman.adb<s-intman-posix.adb \\\n+  s-osinte.adb<s-osinte-aix.adb \\\n+  s-osinte.ads<s-osinte-aix.ads \\\n+  s-osprim.adb<s-osprim-posix.adb \\\n+  s-taprop.adb<s-taprop-posix.adb \\\n+  s-taspri.ads<s-taspri-posix.ads \\\n+  s-tpopsp.adb<s-tpopsp-posix.adb \\\n+  g-soccon.ads<g-soccon-aix.ads \\\n+  system.ads<system-aix.ads\n+\n+  THREADSLIB = -lpthreads\n+  PREFIX_OBJS=$(PREFIX_REAL_OBJS)\n+\n+  TOOLS_TARGET_PAIRS = \\\n+  mlib-tgt-specific.adb<mlib-tgt-specific-aix.adb \\\n+  indepsw.adb<indepsw-aix.adb\n+\n+  GMEM_LIB = gmemlib\n+endif\n+\n+ifeq ($(strip $(filter-out lynxos,$(osys))),)\n+  TOOLS_TARGET_PAIRS = \\\n+  mlib-tgt-specific.adb<mlib-tgt-specific-lynxos.adb \\\n+  indepsw.adb<indepsw-gnu.adb\n+\n+  ifeq ($(strip $(filter-out %86 lynxos,$(arch) $(osys))),)\n+    LIBGNAT_TARGET_PAIRS = \\\n+    a-numaux.adb<a-numaux-x86.adb \\\n+    a-numaux.ads<a-numaux-x86.ads \\\n+    a-intnam.ads<a-intnam-lynxos.ads \\\n+    g-bytswa.adb<g-bytswa-x86.adb \\\n+    g-soccon.ads<g-soccon-lynxos.ads \\\n+    g-sttsne.adb<g-sttsne-locking.adb \\\n+    g-sttsne.ads<g-sttsne-locking.ads \\\n+    s-inmaop.adb<s-inmaop-posix.adb \\\n+    s-intman.adb<s-intman-posix.adb \\\n+    s-osinte.adb<s-osinte-lynxos.adb \\\n+    s-osinte.ads<s-osinte-lynxos.ads \\\n+    s-osprim.adb<s-osprim-posix.adb \\\n+    s-taprop.adb<s-taprop-lynxos.adb \\\n+    s-taspri.ads<s-taspri-lynxos.ads \\\n+    s-tpopsp.adb<s-tpopsp-lynxos.adb \\\n+    system.ads<system-lynxos-x86.ads\n+\n+    PREFIX_OBJS=$(PREFIX_REAL_OBJS)\n+\n+  else\n+    LIBGNAT_TARGET_PAIRS = \\\n+    a-intnam.ads<a-intnam-lynxos.ads \\\n+    g-soccon.ads<g-soccon-lynxos.ads \\\n+    g-sttsne.adb<g-sttsne-locking.adb \\\n+    g-sttsne.ads<g-sttsne-locking.ads \\\n+    s-inmaop.adb<s-inmaop-posix.adb \\\n+    s-intman.adb<s-intman-posix.adb \\\n+    s-osinte.adb<s-osinte-lynxos.adb \\\n+    s-osinte.ads<s-osinte-lynxos.ads \\\n+    s-osprim.adb<s-osprim-posix.adb \\\n+    s-taprop.adb<s-taprop-lynxos.adb \\\n+    s-taspri.ads<s-taspri-lynxos.ads \\\n+    s-tpopsp.adb<s-tpopsp-lynxos.adb \\\n+    system.ads<system-lynxos-ppc.ads\n+  endif\n+endif\n+\n+ifeq ($(strip $(filter-out rtems%,$(osys))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  system.ads<system-rtems.ads \\\n+  a-intnam.ads<a-intnam-rtems.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-intman.adb<s-intman-posix.adb \\\n+  s-osinte.adb<s-osinte-rtems.adb \\\n+  s-osinte.ads<s-osinte-rtems.ads \\\n+  s-osprim.adb<s-osprim-posix.adb \\\n+  s-parame.adb<s-parame-rtems.adb \\\n+  s-taprop.adb<s-taprop-posix.adb \\\n+  s-taspri.ads<s-taspri-posix.ads \\\n+  s-tpopsp.adb<s-tpopsp-rtems.adb \\\n+  g-soccon.ads<g-soccon-rtems.ads \\\n+  s-stchop.adb<s-stchop-rtems.adb\n+endif\n+\n+ifeq ($(strip $(filter-out alpha% dec osf%,$(targ))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-intnam.ads<a-intnam-tru64.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-intman.adb<s-intman-posix.adb \\\n+  s-mastop.adb<s-mastop-tru64.adb \\\n+  s-osinte.adb<s-osinte-tru64.adb \\\n+  s-osinte.ads<s-osinte-tru64.ads \\\n+  s-osprim.adb<s-osprim-unix.adb \\\n+  s-taprop.adb<s-taprop-tru64.adb \\\n+  s-tasinf.ads<s-tasinf-tru64.ads \\\n+  s-taspri.ads<s-taspri-tru64.ads \\\n+  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+  s-traceb.adb<s-traceb-mastop.adb \\\n+  g-soccon.ads<g-soccon-tru64.ads \\\n+  system.ads<system-tru64.ads\n+\n+  TOOLS_TARGET_PAIRS=mlib-tgt-specific.adb<mlib-tgt-specific-tru64.adb\n+\n+  EH_MECHANISM=-gcc\n+  GMEM_LIB=gmemlib\n+  THREADSLIB = -lpthread -lmach -lexc -lrt\n+  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n+  GNATLIB_SHARED = gnatlib-shared-default\n+  LIBRARY_VERSION := $(LIB_VERSION)\n+endif\n+\n+ifeq ($(strip $(filter-out alpha64 ia64 dec hp vms% openvms% alphavms%,$(host))),)\n+\n+soext  = .exe\n+hyphen = _\n+LN = cp -p\n+LN_S = cp -p\n+\n+.SUFFIXES: .sym\n+\n+.o.sym:\n+\t@ gnu:[bin]vmssymvec $<\n+endif\n+\n+ifeq ($(strip $(filter-out alpha64 ia64 dec hp vms% openvms% alphavms%,$(targ))),)\n+ifeq ($(strip $(filter-out ia64 hp vms% openvms%,$(targ))),)\n+  LIBGNAT_TARGET_PAIRS_AUX1 = \\\n+  g-enblsp.adb<g-enblsp-vms-ia64.adb \\\n+  g-trasym.adb<g-trasym-vms-ia64.adb \\\n+  s-asthan.adb<s-asthan-vms-ia64.adb \\\n+  s-osinte.adb<s-osinte-vms-ia64.adb \\\n+  s-osinte.ads<s-osinte-vms-ia64.ads \\\n+  s-vaflop.adb<s-vaflop-vms-ia64.adb \\\n+  system.ads<system-vms-ia64.ads\n+\n+  LIBGNAT_TARGET_PAIRS_AUX2 = \\\n+  s-parame.ads<s-parame-vms-ia64.ads\n+else\n+ifeq ($(strip $(filter-out alpha64 dec vms% openvms% alphavms%,$(targ))),)\n+  LIBGNAT_TARGET_PAIRS_AUX1 = \\\n+  g-enblsp.adb<g-enblsp-vms-alpha.adb \\\n+  g-trasym.adb<g-trasym-vms-alpha.adb \\\n+  s-traent.adb<s-traent-vms.adb \\\n+  s-traent.ads<s-traent-vms.ads \\\n+  s-asthan.adb<s-asthan-vms-alpha.adb \\\n+  s-osinte.adb<s-osinte-vms.adb \\\n+  s-osinte.ads<s-osinte-vms.ads \\\n+  s-vaflop.adb<s-vaflop-vms-alpha.adb \\\n+  system.ads<system-vms_64.ads\n+\n+ifeq ($(strip $(filter-out express EXPRESS,$(THREAD_KIND))),)\n+  LIBGNAT_TARGET_PAIRS_AUX2 = \\\n+  s-parame.ads<s-parame-vms-restrict.ads\n+else\n+  LIBGNAT_TARGET_PAIRS_AUX2 = \\\n+  s-parame.ads<s-parame-vms-alpha.ads\n+endif\n+endif\n+endif\n+\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-caldel.adb<a-caldel-vms.adb \\\n+  a-calend.adb<a-calend-vms.adb \\\n+  a-calend.ads<a-calend-vms.ads \\\n+  a-dirval.adb<a-dirval-vms.adb \\\n+  a-excpol.adb<a-excpol-abort.adb \\\n+  a-intnam.ads<a-intnam-vms.ads \\\n+  a-numaux.ads<a-numaux-vms.ads \\\n+  g-expect.adb<g-expect-vms.adb \\\n+  g-soccon.ads<g-soccon-vms.ads \\\n+  g-socthi.ads<g-socthi-vms.ads \\\n+  g-socthi.adb<g-socthi-vms.adb \\\n+  g-stsifd.adb<g-stsifd-sockets.adb \\\n+  g-sttsne.adb<g-sttsne-locking.adb \\\n+  g-sttsne.ads<g-sttsne-locking.ads \\\n+  i-c.ads<i-c-vms_64.ads \\\n+  i-cstrin.ads<i-cstrin-vms_64.ads \\\n+  i-cstrin.adb<i-cstrin-vms_64.adb \\\n+  i-cpoint.ads<i-cpoint-vms_64.ads \\\n+  i-cpoint.adb<i-cpoint-vms_64.adb \\\n+  i-cstrea.adb<i-cstrea-vms.adb \\\n+  memtrack.adb<memtrack-vms_64.adb \\\n+  s-auxdec.ads<s-auxdec-vms_64.ads \\\n+  s-crtl.ads<s-crtl-vms_64.ads \\\n+  s-inmaop.adb<s-inmaop-vms.adb \\\n+  s-interr.adb<s-interr-vms.adb \\\n+  s-intman.adb<s-intman-vms.adb \\\n+  s-intman.ads<s-intman-vms.ads \\\n+  s-memory.adb<s-memory-vms_64.adb \\\n+  s-memory.ads<s-memory-vms_64.ads \\\n+  s-osprim.adb<s-osprim-vms.adb \\\n+  s-osprim.ads<s-osprim-vms.ads \\\n+  s-taprop.adb<s-taprop-vms.adb \\\n+  s-taspri.ads<s-taspri-vms.ads \\\n+  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+  s-tpopde.adb<s-tpopde-vms.adb \\\n+  s-tpopde.ads<s-tpopde-vms.ads \\\n+  $(LIBGNAT_TARGET_PAIRS_AUX1) \\\n+  $(LIBGNAT_TARGET_PAIRS_AUX2)\n+\n+ifeq ($(strip $(filter-out ia64 hp vms% openvms%,$(targ))),)\n+  TOOLS_TARGET_PAIRS= \\\n+  mlib-tgt-specific.adb<mlib-tgt-specific-vms-ia64.adb \\\n+  symbols.adb<symbols-vms.adb \\\n+  symbols-processing.adb<symbols-processing-vms-ia64.adb\n+else\n+  TOOLS_TARGET_PAIRS= \\\n+  mlib-tgt-specific.adb<mlib-tgt-specific-vms-alpha.adb \\\n+  symbols.adb<symbols-vms.adb \\\n+  symbols-processing.adb<symbols-processing-vms-alpha.adb\n+endif\n+\n+adamsg.o: adamsg.msg\n+\t-$(DECC) --cc=message adamsg.msg -o adamsg.o\n+\n+  EXTRA_GNATMAKE_OBJS = mlib-tgt-vms_common.o\n+\n+  GMEM_LIB = gmemlib\n+  EH_MECHANISM=-gcc\n+  GNATLIB_SHARED=gnatlib-shared-vms\n+ifeq ($(strip $(filter-out alpha64 dec vms% openvms% alphavms%,$(targ))),)\n+  EXTRA_LIBGNAT_SRCS=vmshandler.asm\n+  EXTRA_LIBGNAT_OBJS=vmshandler.o\n+endif\n+  EXTRA_LIBGNAT_SRCS+=adamsg.msg\n+  EXTRA_LIBGNAT_OBJS+=adamsg.o\n+  EXTRA_GNATRTL_TASKING_OBJS=s-tpopde.o\n+  EXTRA_GNATTOOLS = \\\n+     ../../gnatlbr$(exeext)  \\\n+     ../../gnatsym$(exeext)  \\\n+     ../../vms_help$(exeext) \\\n+     ../../gnat.hlp\n+  # This command transforms (YYYYMMDD) into YY,MMDD\n+  GSMATCH_VERSION := $(shell grep \"^ *Gnat_Static_Version_String\" $(fsrcpfx)gnatvsn.ads | sed -e 's/.*(\\(.*\\)).*/\\1/' -e 's/\\(..\\)\\(..\\)\\(....\\).*/\\2,\\3/')\n+  TOOLS_LIBS_LO := --for-linker=sys\\\\$$\\$$library:trace.exe\n+  LIBRARY_VERSION := $(subst .,_,$(LIB_VERSION))\n+endif\n+\n+ifeq ($(strip $(filter-out cygwin32% mingw32% pe,$(osys))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-dirval.adb<a-dirval-mingw.adb \\\n+  a-excpol.adb<a-excpol-abort.adb \\\n+  a-numaux.adb<a-numaux-x86.adb \\\n+  a-numaux.ads<a-numaux-x86.ads \\\n+  s-gloloc.adb<s-gloloc-mingw.adb \\\n+  s-inmaop.adb<s-inmaop-dummy.adb \\\n+  s-memory.adb<s-memory-mingw.adb \\\n+  s-taspri.ads<s-taspri-mingw.ads \\\n+  s-tasinf.adb<s-tasinf-mingw.adb \\\n+  s-tasinf.ads<s-tasinf-mingw.ads \\\n+  g-bytswa.adb<g-bytswa-x86.adb \\\n+  g-socthi.ads<g-socthi-mingw.ads \\\n+  g-socthi.adb<g-socthi-mingw.adb \\\n+  g-stsifd.adb<g-stsifd-sockets.adb \\\n+  g-soccon.ads<g-soccon-mingw.ads \\\n+  g-soliop.ads<g-soliop-mingw.ads\n+\n+  ifeq ($(strip $(filter-out rtx_w32 rtx_rtss,$(THREAD_KIND))),)\n+    LIBGNAT_TARGET_PAIRS += \\\n+    s-intman.adb<s-intman-dummy.adb \\\n+    s-osinte.ads<s-osinte-rtx.ads \\\n+    s-osprim.adb<s-osprim-rtx.adb \\\n+    s-taprop.adb<s-taprop-rtx.adb \\\n+    system.ads<system-rtx.ads\n+\n+    EXTRA_GNATRTL_NONTASKING_OBJS = s-win32.o\n+\n+    MISCLIB = -lwsock32 -lrtapi_w32\n+    THREADSLIB=-lrtapi_w32\n+  else\n+    LIBGNAT_TARGET_PAIRS += \\\n+    a-exetim.adb<a-exetim-mingw.adb \\\n+    a-exetim.ads<a-exetim-mingw.ads \\\n+    a-intnam.ads<a-intnam-mingw.ads \\\n+    g-sercom.adb<g-sercom-mingw.adb \\\n+    s-interr.adb<s-interr-sigaction.adb \\\n+    s-intman.adb<s-intman-mingw.adb \\\n+    s-osinte.ads<s-osinte-mingw.ads \\\n+    s-osprim.adb<s-osprim-mingw.adb \\\n+    s-taprop.adb<s-taprop-mingw.adb \\\n+    system.ads<system-mingw.ads\n+\n+    EXTRA_GNATRTL_NONTASKING_OBJS = s-win32.o g-regist.o\n+    EXTRA_GNATRTL_TASKING_OBJS = a-exetim.o\n+\n+    MISCLIB = -lwsock32\n+\n+    # ??? This will be replaced by gnatlib-shared-dual-win32 when GNAT\n+    # auto-import support for array/record will be done.\n+    GNATLIB_SHARED = gnatlib-shared-win32\n+  endif\n+\n+  TOOLS_TARGET_PAIRS= \\\n+  mlib-tgt-specific.adb<mlib-tgt-specific-mingw.adb \\\n+  indepsw.adb<indepsw-mingw.adb\n+\n+  EH_MECHANISM=-gcc\n+  GMEM_LIB = gmemlib\n+  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n+  EXTRA_GNATTOOLS = ../../gnatdll$(exeext)\n+  EXTRA_GNATMAKE_OBJS = mdll.o mdll-utl.o mdll-fil.o\n+  soext = .dll\n+  LIBRARY_VERSION := $(LIB_VERSION)\n+endif\n+\n+ifeq ($(strip $(filter-out mips linux%,$(arch) $(osys))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-intnam.ads<a-intnam-linux.ads \\\n+  g-soccon.ads<g-soccon-linux-mips.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-intman.adb<s-intman-posix.adb \\\n+  s-linux.ads<s-linux.ads \\\n+  s-osinte.adb<s-osinte-posix.adb \\\n+  s-osinte.ads<s-osinte-linux.ads \\\n+  s-osprim.adb<s-osprim-posix.adb \\\n+  s-taprop.adb<s-taprop-linux.adb \\\n+  s-tasinf.ads<s-tasinf-linux.ads \\\n+  s-tasinf.adb<s-tasinf-linux.adb \\\n+  s-taspri.ads<s-taspri-posix.ads \\\n+  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+  system.ads<system-linux-mips.ads\n+\n+  EH_MECHANISM=-gcc\n+  THREADSLIB = -lpthread\n+  GNATLIB_SHARED = gnatlib-shared-dual\n+  GMEM_LIB = gmemlib\n+  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n+  LIBRARY_VERSION := $(LIB_VERSION)\n+endif\n+\n+ifeq ($(strip $(filter-out mipsel linux%,$(arch) $(osys))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-intnam.ads<a-intnam-linux.ads \\\n+  g-soccon.ads<g-soccon-linux-mips.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-intman.adb<s-intman-posix.adb \\\n+  s-linux.ads<s-linux.ads \\\n+  s-osinte.adb<s-osinte-posix.adb \\\n+  s-osinte.ads<s-osinte-linux.ads \\\n+  s-osprim.adb<s-osprim-posix.adb \\\n+  s-taprop.adb<s-taprop-linux.adb \\\n+  s-tasinf.ads<s-tasinf-linux.ads \\\n+  s-tasinf.adb<s-tasinf-linux.adb \\\n+  s-taspri.ads<s-taspri-posix.ads \\\n+  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+  system.ads<system-linux-mipsel.ads\n+\n+  EH_MECHANISM=-gcc\n+  THREADSLIB = -lpthread\n+  GNATLIB_SHARED = gnatlib-shared-dual\n+  GMEM_LIB = gmemlib\n+  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n+  LIBRARY_VERSION := $(LIB_VERSION)\n+endif\n+\n+ifeq ($(strip $(filter-out powerpc% linux%,$(arch) $(osys))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-intnam.ads<a-intnam-linux.ads \\\n+  g-soccon.ads<g-soccon-linux-ppc.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-intman.adb<s-intman-posix.adb \\\n+  s-linux.ads<s-linux.ads \\\n+  s-osinte.adb<s-osinte-posix.adb \\\n+  s-osinte.ads<s-osinte-linux.ads \\\n+  s-osprim.adb<s-osprim-posix.adb \\\n+  s-taprop.adb<s-taprop-linux.adb \\\n+  s-tasinf.ads<s-tasinf-linux.ads \\\n+  s-tasinf.adb<s-tasinf-linux.adb \\\n+  s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n+  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+  g-sercom.adb<g-sercom-linux.adb \\\n+  system.ads<system-linux-ppc.ads\n+\n+  TOOLS_TARGET_PAIRS =  \\\n+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \\\n+    indepsw.adb<indepsw-gnu.adb\n+\n+  EXTRA_GNATRTL_TASKING_OBJS=s-linux.o\n+  EH_MECHANISM=-gcc\n+  THREADSLIB = -lpthread\n+  GNATLIB_SHARED = gnatlib-shared-dual\n+  GMEM_LIB = gmemlib\n+  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n+  LIBRARY_VERSION := $(LIB_VERSION)\n+endif\n+\n+ifeq ($(strip $(filter-out sparc% linux%,$(arch) $(osys))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-intnam.ads<a-intnam-linux.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-intman.adb<s-intman-posix.adb \\\n+  s-linux.ads<s-linux.ads \\\n+  s-osinte.adb<s-osinte-posix.adb \\\n+  s-osinte.ads<s-osinte-linux.ads \\\n+  s-osprim.adb<s-osprim-posix.adb \\\n+  s-taprop.adb<s-taprop-linux.adb \\\n+  s-tasinf.ads<s-tasinf-linux.ads \\\n+  s-tasinf.adb<s-tasinf-linux.adb \\\n+  s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n+  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+  system.ads<system-linux-sparc.ads\n+\n+  TOOLS_TARGET_PAIRS =  \\\n+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \\\n+    indepsw.adb<indepsw-gnu.adb\n+\n+  EXTRA_GNATRTL_TASKING_OBJS=s-linux.o\n+  EH_MECHANISM=-gcc\n+  THREADSLIB = -lpthread\n+  GNATLIB_SHARED = gnatlib-shared-dual\n+  GMEM_LIB = gmemlib\n+  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n+  LIBRARY_VERSION := $(LIB_VERSION)\n+endif\n+\n+ifeq ($(strip $(filter-out hppa% linux%,$(arch) $(osys))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-intnam.ads<a-intnam-linux.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-intman.adb<s-intman-posix.adb \\\n+  s-linux.ads<s-linux-hppa.ads \\\n+  s-osinte.adb<s-osinte-posix.adb \\\n+  s-osinte.ads<s-osinte-linux.ads \\\n+  s-osprim.adb<s-osprim-posix.adb \\\n+  s-taprop.adb<s-taprop-linux.adb \\\n+  s-tasinf.ads<s-tasinf-linux.ads \\\n+  s-tasinf.adb<s-tasinf-linux.adb \\\n+  s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n+  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+  system.ads<system-linux-hppa.ads\n+\n+  TOOLS_TARGET_PAIRS =  \\\n+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \\\n+    indepsw.adb<indepsw-gnu.adb\n+\n+  EXTRA_GNATRTL_TASKING_OBJS=s-linux.o\n+  EH_MECHANISM=-gcc\n+  THREADSLIB = -lpthread\n+  GNATLIB_SHARED = gnatlib-shared-dual\n+  GMEM_LIB = gmemlib\n+  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n+  LIBRARY_VERSION := $(LIB_VERSION)\n+endif\n+\n+ifeq ($(strip $(filter-out sh4% linux%,$(arch) $(osys))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-intnam.ads<a-intnam-linux.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-intman.adb<s-intman-posix.adb \\\n+  s-linux.ads<s-linux.ads \\\n+  s-osinte.adb<s-osinte-posix.adb \\\n+  s-osinte.ads<s-osinte-linux.ads \\\n+  s-osprim.adb<s-osprim-posix.adb \\\n+  s-taprop.adb<s-taprop-linux.adb \\\n+  s-tasinf.ads<s-tasinf-linux.ads \\\n+  s-tasinf.adb<s-tasinf-linux.adb \\\n+  s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n+  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+  system.ads<system-linux-sh4.ads\n+\n+  TOOLS_TARGET_PAIRS =  \\\n+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \\\n+    indepsw.adb<indepsw-linux.adb\n+\n+  EXTRA_GNATRTL_TASKING_OBJS=s-linux.o\n+  EH_MECHANISM=-gcc\n+  MISCLIB=\n+  THREADSLIB = -lpthread\n+  GNATLIB_SHARED = gnatlib-shared-dual\n+  GMEM_LIB = gmemlib\n+  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n+  LIBRARY_VERSION := $(LIB_VERSION)\n+endif\n+\n+ifeq ($(strip $(filter-out %ia64 linux%,$(arch) $(osys))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-intnam.ads<a-intnam-linux.ads \\\n+  a-numaux.ads<a-numaux-libc-x86.ads \\\n+  g-soccon.ads<g-soccon-linux-64.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-intman.adb<s-intman-posix.adb \\\n+  s-linux.ads<s-linux.ads \\\n+  s-osinte.ads<s-osinte-linux.ads \\\n+  s-osinte.adb<s-osinte-posix.adb \\\n+  s-osprim.adb<s-osprim-posix.adb \\\n+  s-taprop.adb<s-taprop-linux.adb \\\n+  s-tasinf.ads<s-tasinf-linux.ads \\\n+  s-tasinf.adb<s-tasinf-linux.adb \\\n+  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+  s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n+  g-sercom.adb<g-sercom-linux.adb \\\n+  system.ads<system-linux-ia64.ads\n+\n+  TOOLS_TARGET_PAIRS =  \\\n+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \\\n+    indepsw.adb<indepsw-gnu.adb\n+\n+  EXTRA_GNATRTL_TASKING_OBJS=s-linux.o\n+  EH_MECHANISM=-gcc\n+  MISCLIB=\n+  THREADSLIB=-lpthread\n+  GNATLIB_SHARED=gnatlib-shared-dual\n+  GMEM_LIB = gmemlib\n+  PREFIX_OBJS=$(PREFIX_REAL_OBJS)\n+  LIBRARY_VERSION := $(LIB_VERSION)\n+endif\n+\n+ifeq ($(strip $(filter-out alpha% linux%,$(arch) $(osys))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-intnam.ads<a-intnam-linux.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-intman.adb<s-intman-posix.adb \\\n+  s-linux.ads<s-linux-alpha.ads \\\n+  s-osinte.ads<s-osinte-linux.ads \\\n+  s-osinte.adb<s-osinte-posix.adb \\\n+  s-osprim.adb<s-osprim-posix.adb \\\n+  s-taprop.adb<s-taprop-linux.adb \\\n+  s-tasinf.ads<s-tasinf-linux.ads \\\n+  s-tasinf.adb<s-tasinf-linux.adb \\\n+  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+  s-taspri.ads<s-taspri-posix-noaltstack.ads \\\n+  system.ads<system-linux-alpha.ads\n+\n+  TOOLS_TARGET_PAIRS =  \\\n+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \\\n+    indepsw.adb<indepsw-gnu.adb\n+\n+  EXTRA_GNATRTL_TASKING_OBJS=s-linux.o\n+  EH_MECHANISM=-gcc\n+  MISCLIB=\n+  THREADSLIB=-lpthread\n+  GNATLIB_SHARED=gnatlib-shared-dual\n+  PREFIX_OBJS=$(PREFIX_REAL_OBJS)\n+  LIBRARY_VERSION := $(LIB_VERSION)\n+endif\n+\n+ifeq ($(strip $(filter-out %x86_64 linux%,$(arch) $(osys))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-intnam.ads<a-intnam-linux.ads \\\n+  a-numaux.adb<a-numaux-x86.adb \\\n+  a-numaux.ads<a-numaux-x86.ads \\\n+  g-soccon.ads<g-soccon-linux-64.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-intman.adb<s-intman-posix.adb \\\n+  s-linux.ads<s-linux.ads \\\n+  s-osinte.ads<s-osinte-linux.ads \\\n+  s-osinte.adb<s-osinte-posix.adb \\\n+  s-osprim.adb<s-osprim-posix.adb \\\n+  s-taprop.adb<s-taprop-linux.adb \\\n+  s-tasinf.ads<s-tasinf-linux.ads \\\n+  s-tasinf.adb<s-tasinf-linux.adb \\\n+  s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+  s-taspri.ads<s-taspri-posix.ads \\\n+  g-sercom.adb<g-sercom-linux.adb \\\n+  system.ads<system-linux-x86_64.ads\n+\n+  TOOLS_TARGET_PAIRS =  \\\n+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \\\n+    indepsw.adb<indepsw-gnu.adb\n+\n+  EXTRA_GNATRTL_TASKING_OBJS=s-linux.o\n+  EH_MECHANISM=-gcc\n+  THREADSLIB=-lpthread\n+  GNATLIB_SHARED=gnatlib-shared-dual\n+  GMEM_LIB = gmemlib\n+  PREFIX_OBJS=$(PREFIX_REAL_OBJS)\n+  LIBRARY_VERSION := $(LIB_VERSION)\n+endif\n+\n+ifeq ($(strip $(filter-out darwin%,$(osys))),)\n+  ifeq ($(strip $(filter-out %86,$(arch))),)\n+    LIBGNAT_TARGET_PAIRS = \\\n+    a-intnam.ads<a-intnam-darwin.ads \\\n+    s-inmaop.adb<s-inmaop-posix.adb \\\n+    s-intman.adb<s-intman-posix.adb \\\n+    s-osinte.adb<s-osinte-darwin.adb \\\n+    s-osinte.ads<s-osinte-darwin.ads \\\n+    s-osprim.adb<s-osprim-posix.adb \\\n+    s-taprop.adb<s-taprop-posix.adb \\\n+    s-taspri.ads<s-taspri-posix.ads \\\n+    s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+    g-soccon.ads<g-soccon-darwin.ads \\\n+    a-numaux.ads<a-numaux-x86.ads \\\n+    a-numaux.adb<a-numaux-x86.adb \\\n+    system.ads<system-darwin-x86.ads\n+  else\n+    LIBGNAT_TARGET_PAIRS = \\\n+    a-intnam.ads<a-intnam-darwin.ads \\\n+    s-inmaop.adb<s-inmaop-posix.adb \\\n+    s-intman.adb<s-intman-posix.adb \\\n+    s-osinte.adb<s-osinte-darwin.adb \\\n+    s-osinte.ads<s-osinte-darwin.ads \\\n+    s-osprim.adb<s-osprim-posix.adb \\\n+    s-taprop.adb<s-taprop-posix.adb \\\n+    s-taspri.ads<s-taspri-posix.ads \\\n+    s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n+    g-soccon.ads<g-soccon-darwin.ads \\\n+    a-numaux.ads<a-numaux-darwin.ads \\\n+    a-numaux.adb<a-numaux-darwin.adb \\\n+    system.ads<system-darwin-ppc.ads\n+  endif\n+\n+  TOOLS_TARGET_PAIRS =  \\\n+    mlib-tgt-specific.adb<mlib-tgt-specific-darwin.adb\n+\n+  EH_MECHANISM=-gcc\n+  GNATLIB_SHARED = gnatlib-shared-darwin\n+  SO_OPTS = -Wl,-flat_namespace -shared-libgcc\n+  RANLIB = ranlib -c\n+  GMEM_LIB = gmemlib\n+  PREFIX_OBJS=$(PREFIX_REAL_OBJS)\n+  LIBRARY_VERSION := $(LIB_VERSION)\n+  soext = .dylib\n+endif\n+\n+ifneq ($(EH_MECHANISM),)\n+  LIBGNAT_TARGET_PAIRS += a-exexpr.adb<a-exexpr$(EH_MECHANISM).adb\n+  EXTRA_LIBGNAT_SRCS+=raise$(EH_MECHANISM).c\n+  EXTRA_LIBGNAT_OBJS+=raise$(EH_MECHANISM).o\n+endif\n+\n+# Use the Ada 2005 version of Ada.Exceptions by default, unless specified\n+# explicitly already. The base files (a-except.ad?) are used only for building\n+# the compiler and other basic tools.\n+# These base versions lack Ada 2005 additions which would cause bootstrap\n+# problems if included in the compiler and other basic tools.\n+\n+ifeq ($(filter-out a-except%,$(LIBGNAT_TARGET_PAIRS)),$(LIBGNAT_TARGET_PAIRS))\n+  LIBGNAT_TARGET_PAIRS += \\\n+    a-except.ads<a-except-2005.ads \\\n+    a-except.adb<a-except-2005.adb\n+endif\n+\n+# The runtime library for gnat comprises two directories.  One contains the\n+# Ada source files that the compiler (gnat1) needs -- these files are listed\n+# by ADA_INCLUDE_SRCS -- and the other contains the object files and their\n+# corresponding .ali files for the parts written in Ada, libgnat.a for\n+# the parts of the runtime written in C, and libgthreads.a for the pthreads\n+# emulation library.  LIBGNAT_OBJS lists the objects that go into libgnat.a,\n+# while GNATRTL_OBJS lists the object files compiled from Ada sources that\n+# go into the directory.  The pthreads emulation is built in the threads\n+# subdirectory and copied.\n+LIBGNAT_SRCS = ada.h adaint.c adaint.h argv.c cio.c cstreams.c \\\n+  errno.c exit.c cal.c ctrl_c.c env.c env.h \\\n+  raise.h raise.c sysdep.c aux-io.c init.c initialize.c seh_init.c \\\n+  final.c tracebak.c tb-alvms.c tb-alvxw.c tb-gcc.c expect.c mkdir.c \\\n+  socket.c gsocket.h targext.c $(EXTRA_LIBGNAT_SRCS)\n+\n+LIBGNAT_OBJS = adaint.o argv.o cio.o cstreams.o ctrl_c.o errno.o exit.o env.o \\\n+  raise.o sysdep.o aux-io.o init.o initialize.o seh_init.o cal.o \\\n+  final.o tracebak.o expect.o mkdir.o socket.o targext.o $(EXTRA_LIBGNAT_OBJS)\n+\n+# NOTE ??? - when the -I option for compiling Ada code is made to work,\n+#  the library installation will change and there will be a\n+#  GNAT_RTL_SRCS.  Right now we count on being able to build GNATRTL_OBJS\n+#  from ADA_INCLUDE_SRCS.\n+\n+# GNATRTL_NONTASKING_OBJS and GNATRTL_TASKING_OBJS can be found in\n+# the following include file:\n+\n+include $(fsrcdir)/Makefile.rtl\n+\n+GNATRTL_LINEARALGEBRA_OBJS = a-nlcoar.o a-nllcar.o a-nllrar.o a-nlrear.o \\\n+  a-nucoar.o a-nurear.o i-forbla.o i-forlap.o s-gearop.o\n+\n+GNATRTL_OBJS = $(GNATRTL_NONTASKING_OBJS) $(GNATRTL_TASKING_OBJS) \\\n+  $(GNATRTL_LINEARALGEBRA_OBJS) g-trasym.o memtrack.o\n+\n+# Default run time files\n+\n+ADA_INCLUDE_SRCS =\\\n+ ada.ads calendar.ads directio.ads gnat.ads interfac.ads ioexcept.ads \\\n+ machcode.ads text_io.ads unchconv.ads unchdeal.ads \\\n+ sequenio.ads system.ads memtrack.adb \\\n+ a-[a-o]*.adb a-[p-z]*.adb a-[a-o]*.ads a-[p-z]*.ads g-*.ad? i-*.ad? \\\n+ s-[a-o]*.adb s-[p-z]*.adb s-[a-o]*.ads s-[p-z]*.ads\n+\n+LIBGNAT=../rts/libgnat.a\n+\n+GCC_LINK=$(CC) -static-libgcc $(ADA_INCLUDES)\n+\n+# when compiling the tools, the runtime has to be first on the path so that\n+# it hides the runtime files lying with the rest of the sources\n+ifeq ($(TOOLSCASE),native)\n+  vpath %.ads ../rts ../\n+  vpath %.adb ../rts ../\n+  vpath %.c   ../rts ../\n+  vpath %.h   ../rts ../\n+endif\n+\n+# in the cross tools case, everything is compiled with the native\n+# gnatmake/link. Therefore only -I needs to be modified in ADA_INCLUDES\n+ifeq ($(TOOLSCASE),cross)\n+  vpath %.ads ../\n+  vpath %.adb ../\n+  vpath %.c   ../\n+  vpath %.h   ../\n+endif\n+\n+common-tools:\n+\t$(GNATMAKE) -c -b $(ADA_INCLUDES) \\\n+\t  --GNATBIND=\"$(GNATBIND)\" --GCC=\"$(CC) $(ALL_ADAFLAGS)\" \\\n+\t  gnatchop gnatcmd gnatkr gnatls gnatprep gnatxref gnatfind gnatname \\\n+\t  gnatclean -bargs $(ADA_INCLUDES) $(GNATBIND_FLAGS)\n+\t$(GNATLINK) -v gnatcmd -o ../../gnat$(exeext) \\\n+\t\t--GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n+\t$(GNATLINK) -v gnatchop -o ../../gnatchop$(exeext) \\\n+\t\t--GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n+\t$(GNATLINK) -v gnatkr -o ../../gnatkr$(exeext) \\\n+\t\t--GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n+\t$(GNATLINK) -v gnatls -o ../../gnatls$(exeext) \\\n+\t\t--GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n+\t$(GNATLINK) -v gnatprep -o ../../gnatprep$(exeext) \\\n+\t\t--GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n+\t$(GNATLINK) -v gnatxref -o ../../gnatxref$(exeext) \\\n+\t\t--GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n+\t$(GNATLINK) -v gnatfind -o ../../gnatfind$(exeext) \\\n+\t\t--GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n+\t$(GNATLINK) -v gnatname -o ../../gnatname$(exeext) \\\n+\t\t--GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n+\t$(GNATLINK) -v gnatclean -o ../../gnatclean$(exeext) \\\n+\t\t--GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n+\n+../../gnatsym$(exeext): \n+\t$(GNATMAKE) -c $(ADA_INCLUDES) gnatsym --GCC=\"$(CC) $(ALL_ADAFLAGS)\"\n+\t$(GNATBIND) $(ADA_INCLUDES) $(GNATBIND_FLAGS) gnatsym\n+\t$(GNATLINK) -v gnatsym -o $@ --GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n+\n+../../gnatdll$(exeext): \n+\t$(GNATMAKE) -c $(ADA_INCLUDES) gnatdll --GCC=\"$(CC) $(ALL_ADAFLAGS)\"\n+\t$(GNATBIND) $(ADA_INCLUDES) $(GNATBIND_FLAGS) gnatdll\n+\t$(GNATLINK) -v gnatdll -o $@ --GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n+\n+../../vxaddr2line$(exeext): targext.o\n+\t$(GNATMAKE) -c  $(ADA_INCLUDES) vxaddr2line --GCC=\"$(CC) $(ALL_ADAFLAGS)\"\n+\t$(GNATBIND) $(ADA_INCLUDES) $(GNATBIND_FLAGS) vxaddr2line\n+\t$(GNATLINK) -v vxaddr2line -o $@ --GCC=\"$(GCC_LINK)\" targext.o $(CLIB)\n+\n+gnatmake-re:  link.o targext.o\n+\t$(GNATMAKE) $(ADA_INCLUDES) -u sdefault --GCC=\"$(CC) $(MOST_ADA_FLAGS)\"\n+\t$(GNATMAKE) -c $(ADA_INCLUDES) gnatmake --GCC=\"$(CC) $(ALL_ADAFLAGS)\"\n+\t$(GNATBIND) $(ADA_INCLUDES) $(GNATBIND_FLAGS) gnatmake\n+\t$(GNATLINK) -v gnatmake -o ../../gnatmake$(exeext) \\\n+\t\t--GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n+\n+# Note the use of the \"mv\" command in order to allow gnatlink to be linked with\n+# with the former version of gnatlink itself which cannot override itself.\n+gnatlink-re:  link.o targext.o\n+\t$(GNATMAKE) -c $(ADA_INCLUDES) gnatlink --GCC=\"$(CC) $(ALL_ADAFLAGS)\"\n+\t$(GNATBIND) $(ADA_INCLUDES) $(GNATBIND_FLAGS) gnatlink\n+\t$(GNATLINK) -v gnatlink -o ../../gnatlinknew$(exeext) \\\n+\t\t    --GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n+\t$(MV)  ../../gnatlinknew$(exeext)  ../../gnatlink$(exeext)\n+\n+# Needs to be built with CC=gcc\n+# Since the RTL should be built with the latest compiler, remove the\n+#  stamp target in the parent directory whenever gnat1 is rebuilt\n+\n+# Likewise for the tools\n+../../gnatmake$(exeext): $(P) b_gnatm.o link.o targext.o $(GNATMAKE_OBJS)\n+\t$(GCC_LINK) $(ALL_CFLAGS) $(LDFLAGS) -o $@ b_gnatm.o $(GNATMAKE_OBJS) \\\n+\t\t    $(TOOLS_LIBS)\n+\n+../../gnatlink$(exeext): $(P) b_gnatl.o link.o targext.o $(GNATLINK_OBJS)\n+\t$(GCC_LINK) $(ALL_CFLAGS) $(LDFLAGS) -o $@ b_gnatl.o $(GNATLINK_OBJS) \\\n+\t\t    $(TOOLS_LIBS)\n+\n+../stamp-gnatlib:\n+\t@if [ ! -f stamp-gnatlib ] ; \\\n+\tthen \\\n+\t  $(ECHO) You must first build the GNAT library: make gnatlib; \\\n+\t  false; \\\n+\telse \\\n+\t  true; \\\n+\tfi\n+\n+install-gnatlib: ../stamp-gnatlib\n+#\tCreate the directory before deleting it, in case the directory is\n+#\ta list of directories (as it may be on VMS). This ensures we are\n+#\tdeleting the right one.\n+\t-$(MKDIR) $(DESTDIR)$(ADA_RTL_OBJ_DIR)\n+\t-$(MKDIR) $(DESTDIR)$(ADA_INCLUDE_DIR)\n+\t$(RMDIR) $(DESTDIR)$(ADA_RTL_OBJ_DIR)\n+\t$(RMDIR) $(DESTDIR)$(ADA_INCLUDE_DIR)\n+\t-$(MKDIR) $(DESTDIR)$(ADA_RTL_OBJ_DIR)\n+\t-$(MKDIR) $(DESTDIR)$(ADA_INCLUDE_DIR)\n+\tfor file in rts/*.ali; do \\\n+\t    $(INSTALL_DATA_DATE) $$file $(DESTDIR)$(ADA_RTL_OBJ_DIR); \\\n+\tdone\n+\t-$(INSTALL_DATA) rts/g-trasym$(objext) $(DESTDIR)$(ADA_RTL_OBJ_DIR)\n+\t-cd rts; for file in *$(arext);do \\\n+\t    $(INSTALL_DATA) $$file $(DESTDIR)$(ADA_RTL_OBJ_DIR); \\\n+\t    $(RANLIB_FOR_TARGET) $(DESTDIR)$(ADA_RTL_OBJ_DIR)/$$file; \\\n+\tdone\n+\t-$(foreach file, $(EXTRA_ADALIB_FILES), \\\n+\t    $(INSTALL_DATA_DATE) rts/$(file) $(DESTDIR)$(ADA_RTL_OBJ_DIR) && \\\n+\t) true\n+#     Install the shared libraries, if any, using $(INSTALL) instead\n+#     of $(INSTALL_DATA). The latter may force a mode inappropriate\n+#     for shared libraries on some targets, e.g. on HP-UX where the x\n+#     permission is required.\n+\tfor file in gnat gnarl; do \\\n+\t   if [ -f rts/lib$${file}$(hyphen)$(LIBRARY_VERSION)$(soext) ]; then \\\n+\t      $(INSTALL) rts/lib$${file}$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n+\t\t\t $(DESTDIR)$(ADA_RTL_OBJ_DIR); \\\n+\t   fi; \\\n+\t   if [ -f rts/lib$${file}$(soext) ]; then \\\n+\t      $(LN_S) lib$${file}$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n+\t      $(DESTDIR)$(ADA_RTL_OBJ_DIR)/lib$${file}$(soext); \\\n+\t   fi; \\\n+\tdone\n+# This copy must be done preserving the date on the original file.\n+\tfor file in rts/*.ad?; do \\\n+\t    $(INSTALL_DATA_DATE) $$file $(DESTDIR)$(ADA_INCLUDE_DIR); \\\n+\tdone\n+\tcd $(DESTDIR)$(ADA_INCLUDE_DIR); $(CHMOD) a-wx *.adb\n+\tcd $(DESTDIR)$(ADA_INCLUDE_DIR); $(CHMOD) a-wx *.ads\n+\n+../stamp-gnatlib2:\n+\t$(RM) rts/s-*.ali\n+\t$(RM) rts/s-*$(objext)\n+\t$(RM) rts/a-*.ali\n+\t$(RM) rts/a-*$(objext)\n+\t$(RM) rts/*.ali\n+\t$(RM) rts/*$(objext)\n+\t$(RM) rts/*$(arext)\n+\t$(RM) rts/*$(soext)\n+\ttouch ../stamp-gnatlib2\n+\t$(RM) ../stamp-gnatlib\n+\n+# NOTE: The $(foreach ...) commands assume \";\" is the valid separator between\n+#       successive target commands. Although the Gnu make documentation\n+#       implies this is true on all systems, I suspect it may not be, So care\n+#       has been taken to allow a sed script to look for \";)\" and substitue\n+#       for \";\" the appropriate character in the range of lines below\n+#       beginning with \"GNULLI Begin\" and ending with \"GNULLI End\"\n+\n+# GNULLI Begin ###########################################################\n+\n+../stamp-gnatlib1: Makefile ../stamp-gnatlib2\n+\t$(RMDIR) rts\n+\t$(MKDIR) rts\n+\t$(CHMOD) u+w rts\n+# Copy target independent sources\n+\t$(foreach f,$(ADA_INCLUDE_SRCS) $(LIBGNAT_SRCS), \\\n+\t  $(LN_S) $(fsrcpfx)$(f) rts ;) true\n+# Remove files to be replaced by target dependent sources\n+\t$(RM) $(foreach PAIR,$(LIBGNAT_TARGET_PAIRS), \\\n+\t                rts/$(word 1,$(subst <, ,$(PAIR))))\n+\t$(RM) rts/*-*-*.ads rts/*-*-*.adb\n+# Copy new target dependent sources\n+\t$(foreach PAIR,$(LIBGNAT_TARGET_PAIRS), \\\n+\t          $(LN_S) $(fsrcpfx)$(word 2,$(subst <, ,$(PAIR))) \\\n+\t                rts/$(word 1,$(subst <, ,$(PAIR)));)\n+\t$(RM) ../stamp-gnatlib\n+\ttouch ../stamp-gnatlib1\n+\n+# GNULLI End #############################################################\n+\n+# Don't use semicolon separated shell commands that involve list expansions.\n+# The semicolon triggers a call to DCL on VMS and DCL can't handle command\n+# line lengths in excess of 256 characters.\n+# Example: cd rts; ar rc libfoo.a $(LONG_LIST_OF_OBJS)\n+# is guaranteed to overflow the buffer.\n+\n+gnatlib: ../stamp-gnatlib1 ../stamp-gnatlib2\n+\t$(MAKE) -C rts \\\n+\t\tCC=\"`echo \\\"$(GCC_FOR_TARGET)\\\" \\\n+\t\t| sed -e 's,^\\./xgcc,../../xgcc,' -e 's,-B\\./,-B../../,'`\" \\\n+\t        INCLUDES=\"$(INCLUDES_FOR_SUBDIR) -I./../..\" \\\n+                CFLAGS=\"$(GNATLIBCFLAGS_FOR_C)\" \\\n+\t        FORCE_DEBUG_ADAFLAGS=\"$(FORCE_DEBUG_ADAFLAGS)\" \\\n+\t\tsrcdir=$(fsrcdir) \\\n+\t        -f ../Makefile $(LIBGNAT_OBJS)\n+\t$(MAKE) -C rts \\\n+\t\tCC=\"`echo \\\"$(GCC_FOR_TARGET)\\\" \\\n+\t\t| sed -e 's,^\\./xgcc,../../xgcc,' -e 's,-B\\./,-B../../,'`\" \\\n+\t        ADA_INCLUDES=\"\" \\\n+                CFLAGS=\"$(GNATLIBCFLAGS)\" \\\n+\t        ADAFLAGS=\"$(GNATLIBFLAGS)\" \\\n+\t        FORCE_DEBUG_ADAFLAGS=\"$(FORCE_DEBUG_ADAFLAGS)\" \\\n+\t\tsrcdir=$(fsrcdir) \\\n+\t        -f ../Makefile \\\n+\t        $(GNATRTL_OBJS)\n+\t$(RM) rts/libgnat$(arext) rts/libgnarl$(arext)\n+\t$(AR_FOR_TARGET) $(AR_FLAGS) rts/libgnat$(arext) \\\n+\t   $(addprefix rts/,$(GNATRTL_NONTASKING_OBJS) $(LIBGNAT_OBJS))\n+        ifneq ($(PREFIX_OBJS),)\n+\t\t$(AR_FOR_TARGET) $(AR_FLAGS) rts/libgccprefix$(arext) \\\n+\t\t  $(PREFIX_OBJS);\n+\t\t$(RANLIB_FOR_TARGET) rts/libgccprefix$(arext)\n+        endif\n+\t$(RANLIB_FOR_TARGET) rts/libgnat$(arext)\n+\t$(AR_FOR_TARGET) $(AR_FLAGS) rts/libgnarl$(arext) \\\n+\t   $(addprefix rts/,$(GNATRTL_TASKING_OBJS))\n+\t$(RANLIB_FOR_TARGET) rts/libgnarl$(arext)\n+\t$(AR_FOR_TARGET) $(AR_FLAGS) rts/libgnala$(arext) \\\n+\t   $(addprefix rts/,$(GNATRTL_LINEARALGEBRA_OBJS))\n+\t$(RANLIB_FOR_TARGET) rts/libgnala$(arext)\n+        ifeq ($(GMEM_LIB),gmemlib)\n+\t\t$(AR_FOR_TARGET) $(AR_FLAGS) rts/libgmem$(arext) \\\n+\t\t  rts/memtrack.o\n+\t\t$(RANLIB_FOR_TARGET) rts/libgmem$(arext)\n+        endif\n+\t$(CHMOD) a-wx rts/*.ali\n+\ttouch ../stamp-gnatlib\n+\n+# Warning: this target assumes that LIBRARY_VERSION has been set correctly.\n+gnatlib-shared-default:\n+\t$(MAKE) $(FLAGS_TO_PASS) \\\n+             GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n+\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS)\" \\\n+\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n+             gnatlib\n+\t$(RM) rts/libgna*$(soext)\n+\tcd rts; ../../xgcc -B../../ -shared $(GNATLIBCFLAGS) \\\n+\t\t$(TARGET_LIBGCC2_CFLAGS) \\\n+\t\t-o libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n+\t\t$(GNATRTL_NONTASKING_OBJS) $(LIBGNAT_OBJS) \\\n+\t\t$(SO_OPTS)libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n+\t\t$(MISCLIB) -lm\n+\tcd rts; ../../xgcc -B../../ -shared $(GNATLIBCFLAGS) \\\n+\t\t$(TARGET_LIBGCC2_CFLAGS) \\\n+\t\t-o libgnarl$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n+\t\t$(GNATRTL_TASKING_OBJS) \\\n+\t\t$(SO_OPTS)libgnarl$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n+\t\t$(THREADSLIB)\n+\tcd rts; $(LN_S) libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n+\t\tlibgnat$(soext)\n+\tcd rts; $(LN_S) libgnarl$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n+\t\tlibgnarl$(soext)\n+\n+gnatlib-shared-dual:\n+\t$(MAKE) $(FLAGS_TO_PASS) \\\n+             GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n+\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS)\" \\\n+\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n+             gnatlib-shared-default\n+\t$(MV) rts/libgna*$(soext) .\n+\t$(RM) ../stamp-gnatlib2\n+\t$(MAKE) $(FLAGS_TO_PASS) \\\n+             GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n+\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS)\" \\\n+\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n+             gnatlib\n+\t$(MV) libgna*$(soext) rts\n+\n+gnatlib-shared-dual-win32:\n+\t$(MAKE) $(FLAGS_TO_PASS) \\\n+             GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n+\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS)\" \\\n+\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n+             gnatlib-shared-win32\n+\t$(MV) rts/libgna*$(soext) .\n+\t$(RM) ../stamp-gnatlib2\n+\t$(MAKE) $(FLAGS_TO_PASS) \\\n+             GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n+\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS)\" \\\n+\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n+             gnatlib\n+\t$(MV) libgna*$(soext) rts\n+\n+# ??? we need to add the option to support auto-import of arrays/records to\n+# the GNATLIBFLAGS when this will be supported by GNAT. At this point we will\n+# use the gnatlib-shared-dual-win32 target to build the GNAT runtimes on\n+# Windows.\n+gnatlib-shared-win32:\n+\t$(MAKE) $(FLAGS_TO_PASS) \\\n+             GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n+\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS)\" \\\n+\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n+             gnatlib\n+\t$(RM) rts/libgna*$(soext)\n+\tcd rts; ../../xgcc -B../../ -shared $(TARGET_LIBGCC2_CFLAGS) \\\n+\t\t-o libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n+\t\t$(GNATRTL_NONTASKING_OBJS) $(LIBGNAT_OBJS) \\\n+\t\t$(SO_OPTS)libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) $(MISCLIB)\n+\tcd rts; ../../xgcc -B../../ -shared $(TARGET_LIBGCC2_CFLAGS) \\\n+\t\t-o libgnarl$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n+\t\t$(GNATRTL_TASKING_OBJS) \\\n+\t\t$(SO_OPTS)libgnarl$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n+\t\t$(THREADSLIB) -Wl,libgnat$(hyphen)$(LIBRARY_VERSION)$(soext)\n+\n+gnatlib-shared-darwin:\n+\t$(MAKE) $(FLAGS_TO_PASS) \\\n+\t     GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n+\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS) \\\n+\t                    -fno-common\" \\\n+\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n+\t     gnatlib\n+\t$(RM) rts/libgnat$(soext) rts/libgnarl$(soext)\n+\tcd rts; ../../xgcc -B../../ -dynamiclib $(TARGET_LIBGCC2_CFLAGS) \\\n+\t\t-o libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n+\t\t$(GNATRTL_NONTASKING_OBJS) $(LIBGNAT_OBJS) \\\n+\t\t$(SO_OPTS) \\\n+\t\t$(MISCLIB) -lm\n+\tcd rts; ../../xgcc -B../../ -dynamiclib $(TARGET_LIBGCC2_CFLAGS) \\\n+\t\t-o libgnarl$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n+\t\t$(GNATRTL_TASKING_OBJS) \\\n+\t\t$(SO_OPTS) \\\n+\t\t$(THREADSLIB) -Wl,libgnat$(hyphen)$(LIBRARY_VERSION)$(soext)\n+\tcd rts; $(LN_S) libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n+\t\tlibgnat$(soext)\n+\tcd rts; $(LN_S) libgnarl$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n+\t\tlibgnarl$(soext)\n+\n+gnatlib-shared-vms:\n+\t$(MAKE) $(FLAGS_TO_PASS) \\\n+             GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n+\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS)\" \\\n+\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n+             gnatlib\n+\t$(RM) rts/libgna*$(soext)\n+\tcd rts && \\\n+\t../../gnatsym -s SYMVEC_$$$$.opt \\\n+\t$(LIBGNAT_OBJS) $(GNATRTL_NONTASKING_OBJS) && \\\n+\t../../xgcc -g -B../../ -shared -shared-libgcc \\\n+\t   -o libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) libgnat.a \\\n+\t   sys\\$$library:trace.exe \\\n+\t   --for-linker=/noinform \\\n+\t   --for-linker=SYMVEC_$$$$.opt \\\n+\t   --for-linker=gsmatch=equal,$(GSMATCH_VERSION)\n+\tcd rts && \\\n+\t../../gnatsym -s SYMVEC_$$$$.opt \\\n+\t$(GNATRTL_TASKING_OBJS) && \\\n+\t../../xgcc -g -B../../ -shared -shared-libgcc \\\n+\t   -o libgnarl$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n+\t   libgnarl.a libgnat$(hyphen)$(LIBRARY_VERSION)$(soext) \\\n+\t   sys\\$$library:trace.exe \\\n+\t   --for-linker=/noinform \\\n+\t   --for-linker=SYMVEC_$$$$.opt \\\n+\t   --for-linker=gsmatch=equal,$(GSMATCH_VERSION)\n+\n+gnatlib-shared:\n+\t$(MAKE) $(FLAGS_TO_PASS) \\\n+             GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n+\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS)\" \\\n+\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n+\t     TARGET_LIBGCC2_CFLAGS=\"$(TARGET_LIBGCC2_CFLAGS)\" \\\n+             $(GNATLIB_SHARED)\n+\n+gnatlib-sjlj:\n+\t$(MAKE) $(FLAGS_TO_PASS) EH_MECHANISM=\"\" ../stamp-gnatlib1\n+\tsed -e 's/ZCX_By_Default.*/ZCX_By_Default            : constant Boolean := False;/' rts/system.ads > rts/s.ads\n+\t$(MV) rts/s.ads rts/system.ads\n+\t$(MAKE) $(FLAGS_TO_PASS) \\\n+\t     EH_MECHANISM=\"\" \\\n+\t     GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n+\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS)\" \\\n+\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n+\t     TARGET_LIBGCC2_CFLAGS=\"$(TARGET_LIBGCC2_CFLAGS)\" gnatlib\n+\n+gnatlib-zcx:\n+\t$(MAKE) $(FLAGS_TO_PASS) EH_MECHANISM=\"-gcc\" ../stamp-gnatlib1\n+\tsed -e 's/ZCX_By_Default.*/ZCX_By_Default            : constant Boolean := True;/' rts/system.ads > rts/s.ads\n+\t$(MV) rts/s.ads rts/system.ads\n+\t$(MAKE) $(FLAGS_TO_PASS) \\\n+\t     EH_MECHANISM=\"-gcc\" \\\n+\t     GNATLIBFLAGS=\"$(GNATLIBFLAGS)\" \\\n+\t     GNATLIBCFLAGS=\"$(GNATLIBCFLAGS)\" \\\n+\t     THREAD_KIND=\"$(THREAD_KIND)\" \\\n+\t     TARGET_LIBGCC2_CFLAGS=\"$(TARGET_LIBGCC2_CFLAGS)\" gnatlib\n+\n+# .s files for cross-building\n+gnat-cross: force\n+\tmake $(GNAT1_ADA_OBJS) CC=\"gcc -B../stage1/\" CFLAGS=\"-S -gnatp\"\n+\n+# Compiling object files from source files.\n+\n+# Note that dependencies on obstack.h are not written\n+# because that file is not part of GCC.\n+# Dependencies on gvarargs.h are not written\n+# because all that file does, when not compiling with GCC,\n+# is include the system varargs.h.\n+\n+b_gnatl.c : $(GNATLINK_OBJS)\n+\t$(GNATBIND) -C $(ADA_INCLUDES) -o b_gnatl.c gnatlink.ali\n+b_gnatl.o : b_gnatl.c\n+\n+b_gnatm.c : $(GNATMAKE_OBJS)\n+\t$(GNATBIND) -C $(ADA_INCLUDES) -o b_gnatm.c gnatmake.ali\n+b_gnatm.o : b_gnatm.c\n+\n+ADA_INCLUDE_DIR = $(libsubdir)/adainclude\n+ADA_RTL_OBJ_DIR = $(libsubdir)/adalib\n+\n+# force no sibling call optimization on s-traceb.o so the number of stack\n+# frames to be skipped when computing a call chain is not modified by\n+# optimization. However we can do that only when building the runtime\n+# (not the compiler) because the -fno-optimize-sibling-calls option exists\n+# only in GCC 3 and above.\n+\n+ifneq (,$(findstring xgcc,$(CC)))\n+NO_SIBLING_ADAFLAGS=-fno-optimize-sibling-calls\n+else\n+NO_SIBLING_ADAFLAGS=\n+endif\n+\n+s-traceb.o  : s-traceb.adb\n+\t$(CC) -c $(ALL_ADAFLAGS) $(FORCE_DEBUG_ADAFLAGS) \\\n+\t      $(NO_SIBLING_ADAFLAGS) $(ADA_INCLUDES) \\\n+      $< $(OUTPUT_OPTION)\n+\n+# force debugging information on s-tasdeb.o so that it is always\n+# possible to set conditional breakpoints on tasks.\n+\n+s-tasdeb.o  : s-tasdeb.adb s-tasdeb.ads\n+\t$(CC) -c $(ALL_ADAFLAGS) $(FORCE_DEBUG_ADAFLAGS) -O0 $(ADA_INCLUDES) \\\n+\t      $< $(OUTPUT_OPTION)\n+\n+# force no function reordering on a-except.o because of the exclusion bounds\n+# mechanism (see the source file for more detailed information). However we\n+# can do that only when building the runtime (not the compiler) because the\n+# -fno-toplevel-reorder option exists only in GCC 4.2 and above.\n+\n+ifneq (,$(findstring xgcc,$(CC)))\n+NO_REORDER_ADAFLAGS=-fno-toplevel-reorder\n+else\n+NO_REORDER_ADAFLAGS=\n+endif\n+\n+# force debugging information on a-except.o so that it is always\n+# possible to set conditional breakpoints on exceptions.\n+# use -O1 otherwise gdb isn't able to get a full backtrace on mips targets.\n+\n+a-except.o  : a-except.adb a-except.ads\n+\t$(CC) -c $(ALL_ADAFLAGS) $(FORCE_DEBUG_ADAFLAGS) -O1 -fno-inline \\\n+\t      $(NO_REORDER_ADAFLAGS) $(ADA_INCLUDES) $< $(OUTPUT_OPTION)\n+\n+# compile s-except.o without optimization and with debug info to let the\n+# debugger set breakpoints and inspect subprogram parameters on exception\n+# related events.\n+\n+s-except.o  : s-except.adb s-except.ads\n+\t$(CC) -c $(ALL_ADAFLAGS) $(FORCE_DEBUG_ADAFLAGS) -O0 $(ADA_INCLUDES) \\\n+\t      $< $(OUTPUT_OPTION)\n+\n+# force debugging information on s-assert.o so that it is always\n+# possible to set breakpoint on assert failures.\n+\n+s-assert.o  : s-assert.adb s-assert.ads a-except.ads\n+\t$(CC) -c $(ALL_ADAFLAGS) $(FORCE_DEBUG_ADAFLAGS) -O2 $(ADA_INCLUDES) \\\n+\t      $< $(OUTPUT_OPTION)\n+\n+adadecode.o : adadecode.c adadecode.h\n+aux-io.o  : aux-io.c\n+argv.o    : argv.c\n+cal.o     : cal.c\n+deftarg.o : deftarg.c\n+errno.o   : errno.c\n+exit.o    : adaint.h exit.c\n+expect.o  : expect.c\n+final.o   : final.c\n+gmem.o    : gmem.c\n+link.o    : link.c\n+mkdir.o   : mkdir.c\n+socket.o  : socket.c gsocket.h\n+sysdep.o  : sysdep.c\n+raise-gcc.o : raise-gcc.c raise.h\n+raise.o   : raise.c raise.h\n+vx_stack_info.o : vx_stack_info.c\n+\n+gen-soccon: gen-soccon.c gsocket.h\n+\t$(CC) $(ALL_CFLAGS) $(ADA_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t\t-UIN_GCC -DTARGET=\\\"$(target_alias)\\\" \\\n+\t\t$< $(OUTPUT_OPTION)\n+\n+cio.o     : cio.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ADA_CFLAGS) \\\n+\t         $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n+\n+init.o    : init.c adaint.h raise.h\n+\t$(CC) -c $(ALL_CFLAGS) $(ADA_CFLAGS) \\\n+\t         $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n+\n+initialize.o : initialize.c raise.h\n+\t$(CC) -c $(ALL_CFLAGS) $(ADA_CFLAGS) \\\n+\t         $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n+\n+targext.o : targext.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ADA_CFLAGS) \\\n+\t\t$(ALL_CPPFLAGS) $(INCLUDES_FOR_SUBDIR) \\\n+\t\t$< $(OUTPUT_OPTION)\n+\n+# No optimization to compile this file as optimizations (-O1 or above) breaks\n+# the SEH handling on Windows. The reasons are not clear.\n+seh_init.o : seh_init.c raise.h\n+\t$(CC) -c $(ALL_CFLAGS) $(ADA_CFLAGS) -O0 \\\n+\t         $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n+\n+# Need to keep the frame pointer in this file to pop the stack properly on\n+# some targets.\n+tracebak.o  : tracebak.c tb-alvms.c tb-alvxw.c tb-gcc.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ADA_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t      -fno-omit-frame-pointer $< $(OUTPUT_OPTION)\n+\n+# In GNU Make, ignore whether `stage*' exists.\n+.PHONY: stage1 stage2 stage3 stage4 clean realclean TAGS bootstrap\n+.PHONY: risky-stage1 risky-stage2 risky-stage3 risky-stage4\n+\n+force:\n+\n+# Gnatlbr, Vms_help, and Gnat.hlp are only used on VMS\n+\n+../../gnatlbr$(exeext): ../../prefix.o\n+\t$(GNATMAKE) -c $(ADA_INCLUDES) gnatlbr --GCC=\"$(CC) $(ALL_ADAFLAGS)\"\n+\t$(GNATBIND) $(ADA_INCLUDES) $(GNATBIND_FLAGS) gnatlbr\n+\t$(GNATLINK) -v gnatlbr -o $@ --GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n+\n+../../vms_help$(exeext):\n+\t$(GNATMAKE) -c $(ADA_INCLUDES) vms_help --GCC=\"$(CC) $(ALL_ADAFLAGS)\"\n+\t$(GNATBIND) $(ADA_INCLUDES) $(GNATBIND_FLAGS) vms_help\n+\t$(GNATLINK) -v vms_help -o $@ --GCC=\"$(GCC_LINK)\" $(TOOLS_LIBS)\n+\n+../../gnat.hlp: ../../vms_help$(exeext)\n+\t../../vms_help$(exeext) $(fsrcdir)/gnat.help_in \\\n+\t                        $(fsrcdir)/vms_data.ads ../../gnat.hlp"}, {"sha": "0a1949f6710ce097b564bfb7a5c0560cdbd14bee", "filename": "gcc/ada/gcc-interface/ada-tree.def", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Fada-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Fada-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.def?ref=a1ab4c317abfd045fe0619b455a31e19f910f7e7", "patch": "@@ -0,0 +1,81 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                       GNAT-SPECIFIC GCC TREE CODES                       *\n+ *                                                                          *\n+ *                              Specification                               *\n+ *                                                                          *\n+ *            Copyright (C) 1992-2007, Free Software Foundation, Inc.       *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have received a copy of the GNU General   *\n+ * Public License along with GCC; see the file COPYING3.  If not see        *\n+ * <http://www.gnu.org/licenses/>.                                          *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* A type that is an unconstrained array itself.  This node is never passed\n+   to GCC. TREE_TYPE is the type of the fat pointer and TYPE_OBJECT_RECORD_TYPE\n+   is the type of a record containing the template and data.  */\n+\n+DEFTREECODE (UNCONSTRAINED_ARRAY_TYPE, \"unconstrained_array_type\", tcc_type, 0)\n+\n+/* A reference to an unconstrained array.  This node only exists as an\n+   intermediate node during the translation of a GNAT tree to a GCC tree;\n+   it is never passed to GCC.  The only field used is operand 0, which\n+   is the fat pointer object.  */\n+\n+DEFTREECODE (UNCONSTRAINED_ARRAY_REF, \"unconstrained_array_ref\",\n+\t    tcc_reference, 1)\n+\n+/* An expression that returns an RTL suitable for its type.  Operand 0\n+   is an expression to be evaluated for side effects only.  */\n+DEFTREECODE (NULL_EXPR, \"null_expr\", tcc_expression, 1)\n+\n+/* Same as ADDR_EXPR, except that if the operand represents a bit field,\n+   return the address of the byte containing the bit.  This is used\n+   for the 'Address attribute and never shows up in the tree.  */\n+DEFTREECODE (ATTR_ADDR_EXPR, \"attr_addr_expr\", tcc_reference, 1)\n+\n+/* Here are the tree codes for the statement types known to Ada.  These\n+   must be at the end of this file to allow IS_ADA_STMT to work.  */\n+\n+/* This is how record_code_position and insert_code_for work.  The former\n+   makes this tree node, whose operand is a statement.  The latter inserts\n+   the actual statements into this node.  Gimplification consists of\n+   just returning the inner statement.  */\n+DEFTREECODE (STMT_STMT, \"stmt_stmt\", tcc_statement, 1)\n+\n+/* A loop.  LOOP_STMT_TOP_COND and LOOP_STMT_BOT_COND are the tests to exit a\n+   loop at the top and bottom, respectively.  LOOP_STMT_UPDATE is the statement\n+   to update the loop iterator at the continue point.  LOOP_STMT_BODY are the\n+   statements in the body of the loop.  LOOP_STMT_LABEL points to the LABEL_DECL\n+   of the end label of the loop.  */\n+DEFTREECODE (LOOP_STMT, \"loop_stmt\", tcc_statement, 5)\n+\n+/* Conditionally exit a loop.  EXIT_STMT_COND is the condition, which, if\n+   true, will cause the loop to be exited.  If no condition is specified,\n+   the loop is unconditionally exited.  EXIT_STMT_LABEL is the end label\n+   corresponding to the loop to exit.  */\n+DEFTREECODE (EXIT_STMT, \"exit_stmt\", tcc_statement, 2)\n+\n+/* A exception region.  REGION_STMT_BODY is the statement to be executed\n+   inside the region.  REGION_STMT_HANDLE is a statement that represents\n+   the exception handlers (usually a BLOCK_STMT of HANDLE_STMTs).\n+   REGION_STMT_BLOCK is the BLOCK node for the declarative region, if any.  */\n+DEFTREECODE (REGION_STMT, \"region_stmt\", tcc_statement, 3)\n+\n+/* An exception handler.  HANDLER_STMT_ARG is the value to pass to \n+   expand_start_catch, HANDLER_STMT_LIST is the list of statements for the\n+   handler itself, and HANDLER_STMT_BLOCK is the BLOCK node for this\n+   binding. */\n+DEFTREECODE (HANDLER_STMT, \"handler_stmt\", tcc_statement, 3)"}, {"sha": "9c31e46f2672a7e36baba2e99269f57f5a5488c4", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "added", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=a1ab4c317abfd045fe0619b455a31e19f910f7e7", "patch": "@@ -0,0 +1,321 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                             A D A - T R E E                              *\n+ *                                                                          *\n+ *                              C Header File                               *\n+ *                                                                          *\n+ *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have received a copy of the GNU General   *\n+ * Public License along with GCC; see the file COPYING3.  If not see        *\n+ * <http://www.gnu.org/licenses/>.                                          *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* Ada uses the lang_decl and lang_type fields to hold a tree.  */\n+union lang_tree_node\n+  GTY((desc (\"0\"),\n+       chain_next (\"(union lang_tree_node *)TREE_CHAIN (&%h.t)\")))\n+{\n+  union tree_node GTY((tag (\"0\"))) t;\n+};\n+struct lang_decl GTY(()) {tree t; };\n+struct lang_type GTY(()) {tree t; };\n+\n+/* Define macros to get and set the tree in TYPE_ and DECL_LANG_SPECIFIC.  */\n+#define GET_TYPE_LANG_SPECIFIC(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE) ? TYPE_LANG_SPECIFIC (NODE)->t : NULL_TREE)\n+#define SET_TYPE_LANG_SPECIFIC(NODE, X)\t\\\n+ (TYPE_LANG_SPECIFIC (NODE)\t\t\t\\\n+  = (TYPE_LANG_SPECIFIC (NODE)\t\t\t\\\n+     ? TYPE_LANG_SPECIFIC (NODE) : GGC_NEW (struct lang_type)))   \\\n+ ->t = X;\n+\n+#define GET_DECL_LANG_SPECIFIC(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE) ? DECL_LANG_SPECIFIC (NODE)->t : NULL_TREE)\n+#define SET_DECL_LANG_SPECIFIC(NODE, VALUE)\t\\\n+ (DECL_LANG_SPECIFIC (NODE)\t\t\t\\\n+  = (DECL_LANG_SPECIFIC (NODE)\t\t\t\\\n+     ? DECL_LANG_SPECIFIC (NODE) : GGC_NEW (struct lang_decl)))   \\\n+ ->t = VALUE;\n+\n+/* Flags added to GCC type nodes.  */\n+\n+/* For RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE, nonzero if this is a\n+   record being used as a fat pointer (only true for RECORD_TYPE).  */\n+#define TYPE_IS_FAT_POINTER_P(NODE) \\\n+  TYPE_LANG_FLAG_0 (RECORD_OR_UNION_CHECK (NODE))\n+\n+#define TYPE_FAT_POINTER_P(NODE)  \\\n+  (TREE_CODE (NODE) == RECORD_TYPE && TYPE_IS_FAT_POINTER_P (NODE))\n+\n+/* For integral types and array types, nonzero if this is a packed array type\n+   used for bit-packed types.  Such types should not be extended to a larger\n+   size or validated against a specified size.  */\n+#define TYPE_PACKED_ARRAY_TYPE_P(NODE) TYPE_LANG_FLAG_0 (NODE)\n+\n+#define TYPE_IS_PACKED_ARRAY_TYPE_P(NODE) \\\n+  ((TREE_CODE (NODE) == INTEGER_TYPE || TREE_CODE (NODE) == ARRAY_TYPE) \\\n+   && TYPE_PACKED_ARRAY_TYPE_P (NODE))\n+\n+/* For INTEGER_TYPE, nonzero if this is a modular type with a modulus that\n+   is not equal to two to the power of its mode's size.  */\n+#define TYPE_MODULAR_P(NODE) TYPE_LANG_FLAG_1 (INTEGER_TYPE_CHECK (NODE))\n+\n+/* For ARRAY_TYPE, nonzero if this type corresponds to a dimension of\n+   an Ada array other than the first.  */\n+#define TYPE_MULTI_ARRAY_P(NODE)  TYPE_LANG_FLAG_1 (ARRAY_TYPE_CHECK (NODE))\n+\n+/* For FUNCTION_TYPE, nonzero if this denotes a function returning an\n+   unconstrained array or record.  */\n+#define TYPE_RETURNS_UNCONSTRAINED_P(NODE) \\\n+  TYPE_LANG_FLAG_1 (FUNCTION_TYPE_CHECK (NODE))\n+\n+/* For RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE, nonzero if this denotes\n+   a justified modular type (will only be true for RECORD_TYPE).  */\n+#define TYPE_JUSTIFIED_MODULAR_P(NODE) \\\n+  TYPE_LANG_FLAG_1 (RECORD_OR_UNION_CHECK (NODE))\n+\n+/* Nonzero in an arithmetic subtype if this is a subtype not known to the\n+   front-end.  */\n+#define TYPE_EXTRA_SUBTYPE_P(NODE) TYPE_LANG_FLAG_2 (NODE)\n+\n+/* Nonzero for composite types if this is a by-reference type.  */\n+#define TYPE_BY_REFERENCE_P(NODE) TYPE_LANG_FLAG_2 (NODE)\n+\n+/* For RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE, nonzero if this is the\n+   type for an object whose type includes its template in addition to\n+   its value (only true for RECORD_TYPE).  */\n+#define TYPE_CONTAINS_TEMPLATE_P(NODE) \\\n+  TYPE_LANG_FLAG_3 (RECORD_OR_UNION_CHECK (NODE))\n+\n+/* For INTEGER_TYPE, nonzero if this really represents a VAX\n+   floating-point type.  */\n+#define TYPE_VAX_FLOATING_POINT_P(NODE)  \\\n+  TYPE_LANG_FLAG_3 (INTEGER_TYPE_CHECK (NODE))\n+\n+/* True if NODE is a thin pointer.  */\n+#define TYPE_THIN_POINTER_P(NODE)\t\t\t\\\n+  (POINTER_TYPE_P (NODE)\t\t\t\t\\\n+   && TREE_CODE (TREE_TYPE (NODE)) == RECORD_TYPE\t\\\n+   && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (NODE)))\n+\n+/* True if TYPE is either a fat or thin pointer to an unconstrained\n+   array.  */\n+#define TYPE_FAT_OR_THIN_POINTER_P(NODE) \\\n+  (TYPE_FAT_POINTER_P (NODE) || TYPE_THIN_POINTER_P (NODE))\n+\n+/* For INTEGER_TYPEs, nonzero if the type has a biased representation.  */\n+#define TYPE_BIASED_REPRESENTATION_P(NODE) \\\n+  TYPE_LANG_FLAG_4 (INTEGER_TYPE_CHECK (NODE))\n+\n+/* For ARRAY_TYPEs, nonzero if the array type has Convention_Fortran.  */\n+#define TYPE_CONVENTION_FORTRAN_P(NODE) \\\n+  TYPE_LANG_FLAG_4 (ARRAY_TYPE_CHECK (NODE))\n+\n+/* For FUNCTION_TYPEs, nonzero if the function returns by reference.  */\n+#define TYPE_RETURNS_BY_REF_P(NODE) \\\n+  TYPE_LANG_FLAG_4 (FUNCTION_TYPE_CHECK (NODE))\n+\n+/* For VOID_TYPE, ENUMERAL_TYPE, UNION_TYPE, and RECORD_TYPE, nonzero if this\n+   is a dummy type, made to correspond to a private or incomplete type.  */\n+#define TYPE_DUMMY_P(NODE) TYPE_LANG_FLAG_4 (NODE)\n+\n+/* True if TYPE is such a dummy type.  */\n+#define TYPE_IS_DUMMY_P(NODE) \\\n+  ((TREE_CODE (NODE) == VOID_TYPE || TREE_CODE (NODE) == RECORD_TYPE\t\\\n+    || TREE_CODE (NODE) == UNION_TYPE || TREE_CODE (NODE) == ENUMERAL_TYPE) \\\n+   && TYPE_DUMMY_P (NODE))\n+\n+/* For FUNCTION_TYPEs, nonzero if function returns by being passed a pointer\n+   to a place to store its result.  */\n+#define TYPE_RETURNS_BY_TARGET_PTR_P(NODE) \\\n+  TYPE_LANG_FLAG_5 (FUNCTION_TYPE_CHECK (NODE))\n+\n+/* For an INTEGER_TYPE, nonzero if TYPE_ACTUAL_BOUNDS is present.  */\n+#define TYPE_HAS_ACTUAL_BOUNDS_P(NODE) \\\n+  TYPE_LANG_FLAG_5 (INTEGER_TYPE_CHECK (NODE))\n+\n+/* For a RECORD_TYPE, nonzero if this was made just to supply needed\n+   padding or alignment.  */\n+#define TYPE_IS_PADDING_P(NODE) TYPE_LANG_FLAG_5 (RECORD_TYPE_CHECK (NODE))\n+\n+/* True if TYPE can alias any other types.  */\n+#define TYPE_UNIVERSAL_ALIASING_P(NODE) TYPE_LANG_FLAG_6 (NODE)\n+\n+/* This field is only defined for FUNCTION_TYPE nodes. If the Ada\n+   subprogram contains no parameters passed by copy in/copy out then this\n+   field is 0. Otherwise it points to a list of nodes used to specify the\n+   return values of the out (or in out) parameters that qualify to be passed\n+   by copy in copy out.  It is a CONSTRUCTOR.  For a full description of the\n+   cico parameter passing mechanism refer to the routine gnat_to_gnu_entity. */\n+#define TYPE_CI_CO_LIST(NODE)  TYPE_LANG_SLOT_1 (FUNCTION_TYPE_CHECK (NODE))\n+\n+/* For an INTEGER_TYPE with TYPE_MODULAR_P, this is the value of the\n+   modulus. */\n+#define TYPE_MODULUS(NODE) GET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n+#define SET_TYPE_MODULUS(NODE, X)  \\\n+  SET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE), X)\n+\n+/* For an INTEGER_TYPE that is the TYPE_DOMAIN of some ARRAY_TYPE, points to\n+   the type corresponding to the Ada index type.  */\n+#define TYPE_INDEX_TYPE(NODE) \\\n+  GET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n+#define SET_TYPE_INDEX_TYPE(NODE, X) \\\n+  SET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE), X)\n+\n+/* For an INTEGER_TYPE with TYPE_VAX_FLOATING_POINT_P, stores the\n+   Digits_Value.  */\n+#define TYPE_DIGITS_VALUE(NODE) \\\n+  GET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE))\n+#define SET_TYPE_DIGITS_VALUE(NODE, X)  \\\n+  SET_TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE), X)\n+\n+/* For numeric types, stores the RM_Size of the type.  */\n+#define TYPE_RM_SIZE_NUM(NODE)\tTYPE_LANG_SLOT_1 (NUMERICAL_TYPE_CHECK (NODE))\n+\n+#define TYPE_RM_SIZE(NODE)\t\t\t\t\t\\\n+  (INTEGRAL_TYPE_P (NODE) || TREE_CODE (NODE) == REAL_TYPE\t\\\n+   ? TYPE_RM_SIZE_NUM (NODE) : 0)\n+\n+/* For a RECORD_TYPE that is a fat pointer, point to the type for the\n+   unconstrained object.  Likewise for a RECORD_TYPE that is pointed\n+   to by a thin pointer.  */\n+#define TYPE_UNCONSTRAINED_ARRAY(NODE)  \\\n+  GET_TYPE_LANG_SPECIFIC (RECORD_TYPE_CHECK (NODE))\n+#define SET_TYPE_UNCONSTRAINED_ARRAY(NODE, X)  \\\n+  SET_TYPE_LANG_SPECIFIC (RECORD_TYPE_CHECK (NODE), X)\n+\n+/* For other RECORD_TYPEs and all UNION_TYPEs and QUAL_UNION_TYPEs, the Ada\n+   size of the object.  This differs from the GCC size in that it does not\n+   include any rounding up to the alignment of the type.  */\n+#define TYPE_ADA_SIZE(NODE)   \\\n+  GET_TYPE_LANG_SPECIFIC (RECORD_OR_UNION_CHECK (NODE))\n+#define SET_TYPE_ADA_SIZE(NODE, X) \\\n+  SET_TYPE_LANG_SPECIFIC (RECORD_OR_UNION_CHECK (NODE), X)\n+\n+/* For an INTEGER_TYPE with TYPE_HAS_ACTUAL_BOUNDS_P or an ARRAY_TYPE, this is\n+   the index type that should be used when the actual bounds are required for\n+   a template.  This is used in the case of packed arrays.  */\n+#define TYPE_ACTUAL_BOUNDS(NODE)   \\\n+  GET_TYPE_LANG_SPECIFIC (TREE_CHECK2 (NODE, INTEGER_TYPE, ARRAY_TYPE))\n+#define SET_TYPE_ACTUAL_BOUNDS(NODE, X) \\\n+  SET_TYPE_LANG_SPECIFIC (TREE_CHECK2 (NODE, INTEGER_TYPE, ARRAY_TYPE), X)\n+\n+/* In an UNCONSTRAINED_ARRAY_TYPE, points to the record containing both\n+   the template and object.\n+\n+   ??? We also put this on an ENUMERAL_TYPE that's dummy.  Technically,\n+   this is a conflict on the minval field, but there doesn't seem to be\n+   simple fix, so we'll live with this kludge for now.  */\n+#define TYPE_OBJECT_RECORD_TYPE(NODE) \\\n+  (TREE_CHECK2 ((NODE), UNCONSTRAINED_ARRAY_TYPE, ENUMERAL_TYPE)->type.minval)\n+\n+/* Nonzero in a FUNCTION_DECL that represents a stubbed function\n+   discriminant.  */\n+#define DECL_STUBBED_P(NODE) DECL_LANG_FLAG_0 (FUNCTION_DECL_CHECK (NODE))\n+\n+/* Nonzero in a VAR_DECL if it is guaranteed to be constant after having\n+   been elaborated and TREE_READONLY is not set on it.  */\n+#define DECL_READONLY_ONCE_ELAB(NODE) DECL_LANG_FLAG_0 (VAR_DECL_CHECK (NODE))\n+\n+/* Nonzero if this decl is always used by reference; i.e., an INDIRECT_REF\n+   is needed to access the object.  */\n+#define DECL_BY_REF_P(NODE) DECL_LANG_FLAG_1 (NODE)\n+\n+/* Nonzero in a FIELD_DECL that is a dummy built for some internal reason.  */\n+#define DECL_INTERNAL_P(NODE) DECL_LANG_FLAG_3 (FIELD_DECL_CHECK (NODE))\n+\n+/* Nonzero if this decl is a PARM_DECL for an Ada array being passed to a\n+   foreign convention subprogram.  */\n+#define DECL_BY_COMPONENT_PTR_P(NODE) DECL_LANG_FLAG_3 (PARM_DECL_CHECK (NODE))\n+\n+/* Nonzero in a FUNCTION_DECL that corresponds to an elaboration procedure.  */\n+#define DECL_ELABORATION_PROC_P(NODE) \\\n+  DECL_LANG_FLAG_3 (FUNCTION_DECL_CHECK (NODE))\n+\n+/* Nonzero if this is a decl for a pointer that points to something which\n+   is readonly.  Used mostly for fat pointers.  */\n+#define DECL_POINTS_TO_READONLY_P(NODE) DECL_LANG_FLAG_4 (NODE)\n+\n+/* Nonzero in a FIELD_DECL if there was a record rep clause.  */\n+#define DECL_HAS_REP_P(NODE) DECL_LANG_FLAG_5 (FIELD_DECL_CHECK (NODE))\n+\n+/* Nonzero in a PARM_DECL if we are to pass by descriptor.  */\n+#define DECL_BY_DESCRIPTOR_P(NODE) DECL_LANG_FLAG_5 (PARM_DECL_CHECK (NODE))\n+\n+/* Nonzero in a VAR_DECL if it is a pointer renaming a global object.  */\n+#define DECL_RENAMING_GLOBAL_P(NODE) DECL_LANG_FLAG_5 (VAR_DECL_CHECK (NODE))\n+\n+/* In a CONST_DECL, points to a VAR_DECL that is allocatable to\n+   memory.  Used when a scalar constant is aliased or has its\n+   address taken.  */\n+#define DECL_CONST_CORRESPONDING_VAR(NODE) \\\n+  GET_DECL_LANG_SPECIFIC (CONST_DECL_CHECK (NODE))\n+#define SET_DECL_CONST_CORRESPONDING_VAR(NODE, X) \\\n+  SET_DECL_LANG_SPECIFIC (CONST_DECL_CHECK (NODE), X)\n+\n+/* In a FIELD_DECL, points to the FIELD_DECL that was the ultimate\n+   source of the decl.  */\n+#define DECL_ORIGINAL_FIELD(NODE) \\\n+  GET_DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE))\n+#define SET_DECL_ORIGINAL_FIELD(NODE, X) \\\n+  SET_DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE), X)\n+\n+/* In a VAR_DECL, points to the object being renamed if the VAR_DECL is a\n+   renaming pointer, otherwise 0.  Note that this object is guaranteed to\n+   be protected against multiple evaluations.  */\n+#define DECL_RENAMED_OBJECT(NODE) \\\n+  GET_DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE))\n+#define SET_DECL_RENAMED_OBJECT(NODE, X) \\\n+  SET_DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE), X)\n+\n+/* In a TYPE_DECL, points to the parallel type if any, otherwise 0.  */\n+#define DECL_PARALLEL_TYPE(NODE) \\\n+  GET_DECL_LANG_SPECIFIC (TYPE_DECL_CHECK (NODE))\n+#define SET_DECL_PARALLEL_TYPE(NODE, X) \\\n+  SET_DECL_LANG_SPECIFIC (TYPE_DECL_CHECK (NODE), X)\n+\n+/* In a FUNCTION_DECL, points to the stub associated with the function\n+   if any, otherwise 0.  */\n+#define DECL_FUNCTION_STUB(NODE) \\\n+  GET_DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE))\n+#define SET_DECL_FUNCTION_STUB(NODE, X) \\\n+  SET_DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE), X)\n+\n+/* In a FIELD_DECL corresponding to a discriminant, contains the\n+   discriminant number.  */\n+#define DECL_DISCRIMINANT_NUMBER(NODE) DECL_INITIAL (FIELD_DECL_CHECK (NODE))\n+\n+/* Define fields and macros for statements.\n+\n+   Start by defining which tree codes are used for statements.  */\n+#define IS_STMT(NODE)\t\t(STATEMENT_CLASS_P (NODE))\n+#define IS_ADA_STMT(NODE)\t(IS_STMT (NODE)\t\t\t\t\\\n+\t\t\t\t && TREE_CODE (NODE) >= STMT_STMT)\n+\n+#define STMT_STMT_STMT(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, STMT_STMT, 0)\n+#define LOOP_STMT_TOP_COND(NODE) TREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 0)\n+#define LOOP_STMT_BOT_COND(NODE) TREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 1)\n+#define LOOP_STMT_UPDATE(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 2)\n+#define LOOP_STMT_BODY(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 3)\n+#define LOOP_STMT_LABEL(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 4)\n+#define EXIT_STMT_COND(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, EXIT_STMT, 0)\n+#define EXIT_STMT_LABEL(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, EXIT_STMT, 1)\n+#define REGION_STMT_BODY(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, REGION_STMT, 0)\n+#define REGION_STMT_HANDLE(NODE) TREE_OPERAND_CHECK_CODE (NODE, REGION_STMT, 1)\n+#define REGION_STMT_BLOCK(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, REGION_STMT, 2)\n+#define HANDLER_STMT_ARG(NODE) TREE_OPERAND_CHECK_CODE (NODE, HANDLER_STMT, 0)\n+#define HANDLER_STMT_LIST(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, HANDLER_STMT, 1)\n+#define HANDLER_STMT_BLOCK(NODE) TREE_OPERAND_CHECK_CODE(NODE, HANDLER_STMT, 2)"}, {"sha": "5f2191fdec959d4849bfbc7d4666f03515d3c5ae", "filename": "gcc/ada/gcc-interface/ada.h", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Fada.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Fada.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada.h?ref=a1ab4c317abfd045fe0619b455a31e19f910f7e7", "patch": "@@ -0,0 +1,80 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                                  A D A                                   *\n+ *                                                                          *\n+ *                              C Header File                               *\n+ *                                                                          *\n+ *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, *\n+ * Boston, MA 02110-1301, USA.                                              *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* This file contains some standard macros for performing Ada-like\n+   operations. These are used to aid in the translation of other headers. */\n+\n+#ifndef GCC_ADA_H\n+#define GCC_ADA_H\n+\n+/* Inlined functions in header are preceded by INLINE, which is normally set\n+   to extern inline for GCC, but may be set to static for use in standard\n+   ANSI-C.  */\n+\n+#ifndef INLINE\n+#ifdef __GNUC__\n+#define INLINE static inline\n+#else\n+#define INLINE static\n+#endif\n+#endif\n+\n+/* Define a macro to concatenate two strings.  Write it for ANSI C and\n+   for traditional C.  */\n+\n+#ifdef __STDC__\n+#define CAT(A,B) A##B\n+#else\n+#define _ECHO(A) A\n+#define CAT(A,B) ECHO(A)B\n+#endif\n+\n+/* The following macro definition simulates the effect of a declaration of\n+   a subtype, where the first two parameters give the name of the type and\n+   subtype, and the third and fourth parameters give the subtype range. The\n+   effect is to compile a typedef defining the subtype as a synonym for the\n+   type, together with two constants defining the end points.  */\n+\n+#define SUBTYPE(SUBTYPE,TYPE,FIRST,LAST)\t\\\n+  typedef TYPE SUBTYPE;\t\t\t\t\\\n+  enum { CAT (SUBTYPE,__First) = FIRST,\t\t\\\n+         CAT (SUBTYPE,__Last) = LAST };\n+\n+/* The following definitions provide the equivalent of the Ada IN and NOT IN\n+   operators, assuming that the subtype involved has been defined using the\n+   SUBTYPE macro defined above.  */\n+\n+#define IN(VALUE,SUBTYPE) \\\n+  (((VALUE) >= (SUBTYPE) CAT (SUBTYPE,__First)) \\\n+   && ((VALUE) <= (SUBTYPE) CAT (SUBTYPE,__Last)))\n+\n+#endif"}, {"sha": "4eb979034a22b48d69f864ee6c2de5e3db45f27e", "filename": "gcc/ada/gcc-interface/config-lang.in", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fconfig-lang.in?ref=a1ab4c317abfd045fe0619b455a31e19f910f7e7", "patch": "@@ -0,0 +1,43 @@\n+# Top level configure fragment for GNU Ada (GNAT).\n+#   Copyright (C) 1994-2008 Free Software Foundation, Inc.\n+\n+#This file is part of GCC.\n+\n+#GCC is free software; you can redistribute it and/or modify\n+#it under the terms of the GNU General Public License as published by\n+#the Free Software Foundation; either version 3, or (at your option)\n+#any later version.\n+\n+#GCC is distributed in the hope that it will be useful,\n+#but WITHOUT ANY WARRANTY; without even the implied warranty of\n+#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+#GNU General Public License for more details.\n+\n+#You should have received a copy of the GNU General Public License\n+#along with GCC; see the file COPYING3.  If not see\n+#<http://www.gnu.org/licenses/>.\n+\n+# Configure looks for the existence of this file to auto-config each language.\n+# We define several parameters used by configure:\n+#\n+# language\t- name of language as it would appear in $(LANGUAGES)\n+# boot_language - \"yes\" if we need to build this language in stage1\n+# compilers\t- value to add to $(COMPILERS)\n+\n+language=\"ada\"\n+gcc_subdir=\"ada/gcc-interface\"\n+\n+boot_language=yes\n+boot_language_boot_flags='ADAFLAGS=\"$(BOOT_ADAFLAGS)\"'\n+\n+compilers=\"gnat1\\$(exeext)\"\n+\n+gtfiles=\"\\$(srcdir)/ada/gcc-interface/ada-tree.h \\$(srcdir)/ada/gcc-interface/gigi.h \\$(srcdir)/ada/gcc-interface/decl.c \\$(srcdir)/ada/gcc-interface/trans.c \\$(srcdir)/ada/gcc-interface/utils.c\"\n+\n+outputs=\"ada/gcc-interface/Makefile ada/Makefile\"\n+\n+target_libs=\"target-libada\"\n+lang_dirs=\"gnattools\"\n+\n+# Ada will not work until the front end starts emitting GIMPLE trees.\n+build_by_default=no"}, {"sha": "90ea342f6b5fd7e1c5c6a22833a85142ca2c50aa", "filename": "gcc/ada/gcc-interface/cuintp.c", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Fcuintp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Fcuintp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fcuintp.c?ref=a1ab4c317abfd045fe0619b455a31e19f910f7e7", "patch": "@@ -0,0 +1,142 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                        GNAT COMPILER COMPONENTS                          *\n+ *                                                                          *\n+ *                               C U I N T P                                *\n+ *                                                                          *\n+ *                          C Implementation File                           *\n+ *                                                                          *\n+ *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have received a copy of the GNU General   *\n+ * Public License along with GCC; see the file COPYING3.  If not see        *\n+ * <http://www.gnu.org/licenses/>.                                          *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* This file corresponds to the Ada package body Uintp. It was created\n+   manually from the files uintp.ads and uintp.adb. */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"ada.h\"\n+#include \"types.h\"\n+#include \"uintp.h\"\n+#include \"atree.h\"\n+#include \"elists.h\"\n+#include \"nlists.h\"\n+#include \"stringt.h\"\n+#include \"fe.h\"\n+#include \"gigi.h\"\n+#include \"ada-tree.h\"\n+\n+/* Universal integers are represented by the Uint type which is an index into\n+   the Uints_Ptr table containing Uint_Entry values.  A Uint_Entry contains an\n+   index and length for getting the \"digits\" of the universal integer from the\n+   Udigits_Ptr table.\n+\n+   For efficiency, this method is used only for integer values larger than the\n+   constant Uint_Bias.  If a Uint is less than this constant, then it contains\n+   the integer value itself.  The origin of the Uints_Ptr table is adjusted so\n+   that a Uint value of Uint_Bias indexes the first element.\n+\n+   First define a utility function that operates like build_int_cst for\n+   integral types and does a conversion to floating-point for real types.  */\n+\n+static tree\n+build_cst_from_int (tree type, HOST_WIDE_INT low)\n+{\n+  if (TREE_CODE (type) == REAL_TYPE)\n+    return convert (type, build_int_cst (NULL_TREE, low));\n+  else\n+    return build_int_cst_type (type, low);\n+}\n+\n+/* Similar to UI_To_Int, but return a GCC INTEGER_CST or REAL_CST node,\n+   depending on whether TYPE is an integral or real type.  Overflow is tested\n+   by the constant-folding used to build the node.  TYPE is the GCC type of\n+   the resulting node.  */\n+\n+tree\n+UI_To_gnu (Uint Input, tree type)\n+{\n+  tree gnu_ret;\n+\n+  /* We might have a TYPE with biased representation and be passed an\n+     unbiased value that doesn't fit.  We always use an unbiased type able\n+     to hold any such possible value for intermediate computations, and\n+     then rely on a conversion back to TYPE to perform the bias adjustment\n+     when need be.  */\n+\n+  int biased_type_p\n+    = (TREE_CODE (type) == INTEGER_TYPE\n+       && TYPE_BIASED_REPRESENTATION_P (type));\n+\n+  tree comp_type = biased_type_p ? get_base_type (type) : type;\n+\n+  if (Input <= Uint_Direct_Last)\n+    gnu_ret = build_cst_from_int (comp_type, Input - Uint_Direct_Bias);\n+  else\n+    {\n+      Int Idx = Uints_Ptr[Input].Loc;\n+      Pos Length = Uints_Ptr[Input].Length;\n+      Int First = Udigits_Ptr[Idx];\n+      tree gnu_base;\n+\n+      gcc_assert (Length > 0);\n+\n+      /* The computations we perform below always require a type at least as\n+\t large as an integer not to overflow.  REAL types are always fine, but\n+\t INTEGER or ENUMERAL types we are handed may be too short.  We use a\n+\t base integer type node for the computations in this case and will\n+\t convert the final result back to the incoming type later on.\n+\t The base integer precision must be superior than 16.  */\n+\n+      if (TREE_CODE (comp_type) != REAL_TYPE\n+\t  && TYPE_PRECISION (comp_type) < TYPE_PRECISION (long_integer_type_node))\n+\t{\n+\t  comp_type = long_integer_type_node;\n+\t  gcc_assert (TYPE_PRECISION (comp_type) > 16);\n+\t}\n+\n+      gnu_base = build_cst_from_int (comp_type, Base);\n+\n+      gnu_ret = build_cst_from_int (comp_type, First);\n+      if (First < 0)\n+\tfor (Idx++, Length--; Length; Idx++, Length--)\n+\t  gnu_ret = fold_build2 (MINUS_EXPR, comp_type,\n+\t\t\t\t fold_build2 (MULT_EXPR, comp_type,\n+\t\t\t\t\t      gnu_ret, gnu_base),\n+\t\t\t\t build_cst_from_int (comp_type,\n+\t\t\t\t\t\t     Udigits_Ptr[Idx]));\n+      else\n+\tfor (Idx++, Length--; Length; Idx++, Length--)\n+\t  gnu_ret = fold_build2 (PLUS_EXPR, comp_type,\n+\t\t\t\t fold_build2 (MULT_EXPR, comp_type,\n+\t\t\t\t\t      gnu_ret, gnu_base),\n+\t\t\t\t build_cst_from_int (comp_type,\n+\t\t\t\t\t\t     Udigits_Ptr[Idx]));\n+    }\n+\n+  gnu_ret = convert (type, gnu_ret);\n+\n+  /* We don't need any NOP_EXPR or NON_LVALUE_EXPR on GNU_RET.  */\n+  while ((TREE_CODE (gnu_ret) == NOP_EXPR\n+\t  || TREE_CODE (gnu_ret) == NON_LVALUE_EXPR)\n+\t && TREE_TYPE (TREE_OPERAND (gnu_ret, 0)) == TREE_TYPE (gnu_ret))\n+    gnu_ret = TREE_OPERAND (gnu_ret, 0);\n+\n+  return gnu_ret;\n+}"}, {"sha": "ebc2e5edd1409bf414fddc0083c13ae7d5b29404", "filename": "gcc/ada/gcc-interface/decl.c", "status": "added", "additions": 7648, "deletions": 0, "changes": 7648, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=a1ab4c317abfd045fe0619b455a31e19f910f7e7"}, {"sha": "28c7db5f70227ca186b216b8d49dac790ff3bb79", "filename": "gcc/ada/gcc-interface/deftarg.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Fdeftarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Fdeftarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdeftarg.c?ref=a1ab4c317abfd045fe0619b455a31e19f910f7e7", "patch": "@@ -0,0 +1,40 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                             D E F T A R G                                *\n+ *                                                                          *\n+ *                                  Body                                    *\n+ *                                                                          *\n+ *          Copyright (C) 1992-2003 Free Software Foundation, Inc.          *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, *\n+ * Boston, MA 02110-1301, USA.                                              *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* Include a default definition for TARGET_FLAGS for gnatpsta.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+\n+int target_flags = TARGET_DEFAULT;"}, {"sha": "aaf5e7f8d8f433207d869e4cffdb5ea2a4ff5c4d", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "added", "additions": 905, "deletions": 0, "changes": 905, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=a1ab4c317abfd045fe0619b455a31e19f910f7e7", "patch": "@@ -0,0 +1,905 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                                 G I G I                                  *\n+ *                                                                          *\n+ *                              C Header File                               *\n+ *                                                                          *\n+ *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, *\n+ * Boston, MA 02110-1301, USA.                                              *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* Declare all functions and types used by gigi.  */\n+\n+/* The largest alignment, in bits, that is needed for using the widest\n+   move instruction.  */\n+extern unsigned int largest_move_alignment;\n+\n+/* Compute the alignment of the largest mode that can be used for copying\n+   objects.  */\n+extern void gnat_compute_largest_alignment (void);\n+\n+/* GNU_TYPE is a type. Determine if it should be passed by reference by\n+   default.  */\n+extern bool default_pass_by_ref (tree gnu_type);\n+\n+/* GNU_TYPE is the type of a subprogram parameter.  Determine from the type\n+   if it should be passed by reference.  */\n+extern bool must_pass_by_ref (tree gnu_type);\n+\n+/* Initialize DUMMY_NODE_TABLE.  */\n+extern void init_dummy_type (void);\n+\n+/* Given GNAT_ENTITY, an entity in the incoming GNAT tree, return a\n+   GCC type corresponding to that entity.  GNAT_ENTITY is assumed to\n+   refer to an Ada type.  */\n+extern tree gnat_to_gnu_type (Entity_Id gnat_entity);\n+\n+/* Given GNAT_ENTITY, a GNAT defining identifier node, which denotes some Ada\n+   entity, this routine returns the equivalent GCC tree for that entity\n+   (an ..._DECL node) and associates the ..._DECL node with the input GNAT\n+   defining identifier.\n+\n+   If GNAT_ENTITY is a variable or a constant declaration, GNU_EXPR gives its\n+   initial value (in GCC tree form). This is optional for variables.\n+   For renamed entities, GNU_EXPR gives the object being renamed.\n+\n+   DEFINITION is nonzero if this call is intended for a definition.  This is\n+   used for separate compilation where it necessary to know whether an\n+   external declaration or a definition should be created if the GCC equivalent\n+   was not created previously.  The value of 1 is normally used for a nonzero\n+   DEFINITION, but a value of 2 is used in special circumstances, defined in\n+   the code.  */\n+extern tree gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr,\n+                                int definition);\n+\n+/* Similar, but if the returned value is a COMPONENT_REF, return the\n+   FIELD_DECL.  */\n+extern tree gnat_to_gnu_field_decl (Entity_Id gnat_entity);\n+\n+/* Wrap up compilation of T, a TYPE_DECL, possibly deferring it.  */\n+extern void rest_of_type_decl_compilation (tree t);\n+\n+/* Start a new statement group chained to the previous group.  */\n+extern void start_stmt_group (void);\n+\n+/* Add GNU_STMT to the current BLOCK_STMT node.  */\n+extern void add_stmt (tree gnu_stmt);\n+\n+/* Similar, but set the location of GNU_STMT to that of GNAT_NODE.  */\n+extern void add_stmt_with_node (tree gnu_stmt, Node_Id gnat_node);\n+\n+/* Return code corresponding to the current code group.  It is normally\n+   a STATEMENT_LIST, but may also be a BIND_EXPR or TRY_FINALLY_EXPR if\n+   BLOCK or cleanups were set.  */\n+extern tree end_stmt_group (void);\n+\n+/* Set the BLOCK node corresponding to the current code group to GNU_BLOCK.  */\n+extern void set_block_for_group (tree);\n+\n+/* Add a declaration statement for GNU_DECL to the current BLOCK_STMT node.\n+   Get SLOC from GNAT_ENTITY.  */\n+extern void add_decl_expr (tree gnu_decl, Entity_Id gnat_entity);\n+\n+/* Mark nodes rooted at *TP with TREE_VISITED and types as having their\n+   sized gimplified.  We use this to indicate all variable sizes and\n+   positions in global types may not be shared by any subprogram.  */\n+extern void mark_visited (tree *);\n+\n+/* Finalize any From_With_Type incomplete types.  We do this after processing\n+   our compilation unit and after processing its spec, if this is a body.  */\n+extern void finalize_from_with_types (void);\n+\n+/* Return the equivalent type to be used for GNAT_ENTITY, if it's a\n+   kind of type (such E_Task_Type) that has a different type which Gigi\n+   uses for its representation.  If the type does not have a special type\n+   for its representation, return GNAT_ENTITY.  If a type is supposed to\n+   exist, but does not, abort unless annotating types, in which case\n+   return Empty.   If GNAT_ENTITY is Empty, return Empty.  */\n+extern Entity_Id Gigi_Equivalent_Type (Entity_Id);\n+\n+/* Given GNAT_ENTITY, elaborate all expressions that are required to\n+   be elaborated at the point of its definition, but do nothing else.  */\n+extern void elaborate_entity (Entity_Id gnat_entity);\n+\n+/* Mark GNAT_ENTITY as going out of scope at this point.  Recursively mark\n+   any entities on its entity chain similarly.  */\n+extern void mark_out_of_scope (Entity_Id gnat_entity);\n+\n+/* Make a dummy type corresponding to GNAT_TYPE.  */\n+extern tree make_dummy_type (Entity_Id gnat_type);\n+\n+/* Get the unpadded version of a GNAT type.  */\n+extern tree get_unpadded_type (Entity_Id gnat_entity);\n+\n+/* Called when we need to protect a variable object using a save_expr.  */\n+extern tree maybe_variable (tree gnu_operand);\n+\n+/* Create a record type that contains a SIZE bytes long field of TYPE with a\n+    starting bit position so that it is aligned to ALIGN bits, and leaving at\n+    least ROOM bytes free before the field.  BASE_ALIGN is the alignment the\n+    record is guaranteed to get.  */\n+extern tree make_aligning_type (tree type, unsigned int align, tree size,\n+\t\t\t\tunsigned int base_align, int room);\n+\n+/* Ensure that TYPE has SIZE and ALIGN.  Make and return a new padded type\n+   if needed.  We have already verified that SIZE and TYPE are large enough.\n+\n+   GNAT_ENTITY and NAME_TRAILER are used to name the resulting record and\n+   to issue a warning.\n+\n+   IS_USER_TYPE is true if we must be sure we complete the original type.\n+\n+   DEFINITION is true if this type is being defined.\n+\n+   SAME_RM_SIZE is true if the RM_Size of the resulting type is to be\n+   set to its TYPE_SIZE; otherwise, it's set to the RM_Size of the original\n+   type.  */\n+extern tree maybe_pad_type (tree type, tree size, unsigned int align,\n+                            Entity_Id gnat_entity, const char *name_trailer,\n+\t\t\t    bool is_user_type, bool definition,\n+                            bool same_rm_size);\n+\n+/* Given a GNU tree and a GNAT list of choices, generate an expression to test\n+   the value passed against the list of choices.  */\n+extern tree choices_to_gnu (tree operand, Node_Id choices);\n+\n+/* Given a type T, a FIELD_DECL F, and a replacement value R, return a new\n+   type with all size expressions that contain F updated by replacing F\n+   with R.  If F is NULL_TREE, always make a new RECORD_TYPE, even if\n+   nothing has changed.  */\n+extern tree substitute_in_type (tree t, tree f, tree r);\n+\n+/* Return the \"RM size\" of GNU_TYPE.  This is the actual number of bits\n+   needed to represent the object.  */\n+extern tree rm_size (tree gnu_type);\n+\n+/* Given GNU_ID, an IDENTIFIER_NODE containing a name, and SUFFIX, a\n+   string, return a new IDENTIFIER_NODE that is the concatenation of\n+   the name in GNU_ID and SUFFIX.  */\n+extern tree concat_id_with_name (tree gnu_id, const char *suffix);\n+\n+/* Return the name to be used for GNAT_ENTITY.  If a type, create a\n+   fully-qualified name, possibly with type information encoding.\n+   Otherwise, return the name.  */\n+extern tree get_entity_name (Entity_Id gnat_entity);\n+\n+/* Return a name for GNAT_ENTITY concatenated with two underscores and\n+   SUFFIX.  */\n+extern tree create_concat_name (Entity_Id gnat_entity, const char *suffix);\n+\n+/* If true, then gigi is being called on an analyzed but unexpanded tree, and\n+   the only purpose of the call is to properly annotate types with\n+   representation information.  */\n+extern bool type_annotate_only;\n+\n+/* Current file name without path */\n+extern const char *ref_filename;\n+\n+/* This structure must be kept synchronized with Call_Back_End.  */\n+struct File_Info_Type\n+{\n+  File_Name_Type File_Name;\n+  Nat Num_Source_Lines;\n+};\n+\n+/* This is the main program of the back-end.  It sets up all the table\n+   structures and then generates code.\n+\n+   ??? Needs parameter descriptions  */\n+\n+extern void gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n+                  struct Node *nodes_ptr, Node_Id *next_node_ptr,\n+                  Node_Id *prev_node_ptr, struct Elist_Header *elists_ptr,\n+                  struct Elmt_Item *elmts_ptr,\n+                  struct String_Entry *strings_ptr,\n+                  Char_Code *strings_chars_ptr,\n+                  struct List_Header *list_headers_ptr,\n+                  Nat number_file,\n+                  struct File_Info_Type *file_info_ptr,\n+                  Entity_Id standard_integer,\n+                  Entity_Id standard_long_long_float,\n+                  Entity_Id standard_exception_type,\n+                  Int gigi_operating_mode);\n+\n+/* GNAT_NODE is the root of some GNAT tree.  Return the root of the\n+   GCC tree corresponding to that GNAT tree.  Normally, no code is generated;\n+   we just return an equivalent tree which is used elsewhere to generate\n+   code.  */\n+extern tree gnat_to_gnu (Node_Id gnat_node);\n+\n+/* GNU_STMT is a statement.  We generate code for that statement.  */\n+extern void gnat_expand_stmt (tree gnu_stmt);\n+\n+/* ??? missing documentation */\n+extern int gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n+                               gimple_seq *post_p ATTRIBUTE_UNUSED);\n+\n+/* Do the processing for the declaration of a GNAT_ENTITY, a type.  If\n+   a separate Freeze node exists, delay the bulk of the processing.  Otherwise\n+   make a GCC type for GNAT_ENTITY and set up the correspondence.  */\n+extern void process_type (Entity_Id gnat_entity);\n+\n+/* Convert SLOC into LOCUS.  Return true if SLOC corresponds to a source code\n+   location and false if it doesn't.  In the former case, set the Gigi global\n+   variable REF_FILENAME to the simple debug file name as given by sinput.  */\n+extern bool Sloc_to_locus (Source_Ptr Sloc, location_t *locus);\n+\n+/* Post an error message.  MSG is the error message, properly annotated.\n+   NODE is the node at which to post the error and the node to use for the\n+   \"&\" substitution.  */\n+extern void post_error (const char *, Node_Id);\n+\n+/* Similar, but NODE is the node at which to post the error and ENT\n+   is the node to use for the \"&\" substitution.  */\n+extern void post_error_ne (const char *msg, Node_Id node, Entity_Id ent);\n+\n+/* Similar, but NODE is the node at which to post the error, ENT is the node\n+   to use for the \"&\" substitution, and N is the number to use for the ^.  */\n+extern void post_error_ne_num (const char *msg, Node_Id node, Entity_Id ent,\n+                               int n);\n+\n+/* Similar to post_error_ne_num, but T is a GCC tree representing the number\n+   to write.  If the tree represents a constant that fits within a\n+   host integer, the text inside curly brackets in MSG will be output\n+   (presumably including a '^').  Otherwise that text will not be output\n+   and the text inside square brackets will be output instead.  */\n+extern void post_error_ne_tree (const char *msg, Node_Id node, Entity_Id ent,\n+                                tree t);\n+\n+/* Similar to post_error_ne_tree, except that NUM is a second\n+   integer to write in the message.  */\n+extern void post_error_ne_tree_2 (const char *msg, Node_Id node, Entity_Id ent,\n+                                  tree t, int num);\n+\n+/* Protect EXP from multiple evaluation.  This may make a SAVE_EXPR.  */\n+extern tree protect_multiple_eval (tree exp);\n+\n+/* Return a label to branch to for the exception type in KIND or NULL_TREE\n+   if none.  */\n+extern tree get_exception_label (char);\n+\n+/* Current node being treated, in case gigi_abort or Check_Elaboration_Code\n+   called.  */\n+extern Node_Id error_gnat_node;\n+\n+/* This is equivalent to stabilize_reference in tree.c, but we know how to\n+   handle our own nodes and we take extra arguments.  FORCE says whether to\n+   force evaluation of everything.  We set SUCCESS to true unless we walk\n+   through something we don't know how to stabilize.  */\n+extern tree maybe_stabilize_reference (tree ref, bool force, bool *success);\n+\n+/* Highest number in the front-end node table.  */\n+extern int max_gnat_nodes;\n+\n+/* If nonzero, pretend we are allocating at global level.  */\n+extern int force_global;\n+\n+/* Standard data type sizes.  Most of these are not used.  */\n+\n+#ifndef CHAR_TYPE_SIZE\n+#define CHAR_TYPE_SIZE BITS_PER_UNIT\n+#endif\n+\n+#ifndef SHORT_TYPE_SIZE\n+#define SHORT_TYPE_SIZE (BITS_PER_UNIT * MIN ((UNITS_PER_WORD + 1) / 2, 2))\n+#endif\n+\n+#ifndef INT_TYPE_SIZE\n+#define INT_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n+#ifndef LONG_TYPE_SIZE\n+#define LONG_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n+#ifndef LONG_LONG_TYPE_SIZE\n+#define LONG_LONG_TYPE_SIZE (BITS_PER_WORD * 2)\n+#endif\n+\n+#ifndef FLOAT_TYPE_SIZE\n+#define FLOAT_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n+#ifndef DOUBLE_TYPE_SIZE\n+#define DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n+#endif\n+\n+#ifndef LONG_DOUBLE_TYPE_SIZE\n+#define LONG_DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n+#endif\n+\n+/* The choice of SIZE_TYPE here is very problematic.  We need a signed\n+   type whose bit width is Pmode.  Assume \"long\" is such a type here.  */\n+#undef SIZE_TYPE\n+#define SIZE_TYPE \"long int\"\n+\f\n+/* Data structures used to represent attributes.  */\n+\n+enum attr_type\n+{\n+  ATTR_MACHINE_ATTRIBUTE,\n+  ATTR_LINK_ALIAS,\n+  ATTR_LINK_SECTION,\n+  ATTR_LINK_CONSTRUCTOR,\n+  ATTR_LINK_DESTRUCTOR,\n+  ATTR_WEAK_EXTERNAL\n+};\n+\n+struct attrib\n+{\n+  struct attrib *next;\n+  enum attr_type type;\n+  tree name;\n+  tree args;\n+  Node_Id error_point;\n+};\n+\n+/* Table of machine-independent internal attributes.  */\n+extern const struct attribute_spec gnat_internal_attribute_table[];\n+\n+/* Define the entries in the standard data array.  */\n+enum standard_datatypes\n+{\n+/* Various standard data types and nodes.  */\n+  ADT_longest_float_type,\n+  ADT_void_type_decl,\n+\n+  /* The type of an exception.  */\n+  ADT_except_type,\n+\n+  /* Type declaration node  <==> typedef void *T */\n+  ADT_ptr_void_type,\n+\n+  /* Function type declaration -- void T() */\n+  ADT_void_ftype,\n+\n+  /* Type declaration node  <==> typedef void *T() */\n+  ADT_ptr_void_ftype,\n+\n+  /* Type declaration node  <==> typedef virtual void *T() */\n+  ADT_fdesc_type,\n+\n+  /* Null pointer for above type */\n+  ADT_null_fdesc,\n+\n+  /* Function declaration nodes for run-time functions for allocating memory.\n+     Ada allocators cause calls to these functions to be generated.  Malloc32\n+     is used only on 64bit systems needing to allocate 32bit memory. */\n+  ADT_malloc_decl,\n+  ADT_malloc32_decl,\n+\n+  /* Likewise for freeing memory.  */\n+  ADT_free_decl,\n+\n+  /* Types and decls used by our temporary exception mechanism.  See\n+     init_gigi_decls for details.  */\n+  ADT_jmpbuf_type,\n+  ADT_jmpbuf_ptr_type,\n+  ADT_get_jmpbuf_decl,\n+  ADT_set_jmpbuf_decl,\n+  ADT_get_excptr_decl,\n+  ADT_setjmp_decl,\n+  ADT_longjmp_decl,\n+  ADT_update_setjmp_buf_decl,\n+  ADT_raise_nodefer_decl,\n+  ADT_begin_handler_decl,\n+  ADT_end_handler_decl,\n+  ADT_others_decl,\n+  ADT_all_others_decl,\n+  ADT_LAST};\n+\n+extern GTY(()) tree gnat_std_decls[(int) ADT_LAST];\n+extern GTY(()) tree gnat_raise_decls[(int) LAST_REASON_CODE + 1];\n+\n+#define longest_float_type_node gnat_std_decls[(int) ADT_longest_float_type]\n+#define void_type_decl_node gnat_std_decls[(int) ADT_void_type_decl]\n+#define except_type_node gnat_std_decls[(int) ADT_except_type]\n+#define ptr_void_type_node gnat_std_decls[(int) ADT_ptr_void_type]\n+#define void_ftype gnat_std_decls[(int) ADT_void_ftype]\n+#define ptr_void_ftype gnat_std_decls[(int) ADT_ptr_void_ftype]\n+#define fdesc_type_node gnat_std_decls[(int) ADT_fdesc_type]\n+#define null_fdesc_node gnat_std_decls[(int) ADT_null_fdesc]\n+#define malloc_decl gnat_std_decls[(int) ADT_malloc_decl]\n+#define malloc32_decl gnat_std_decls[(int) ADT_malloc32_decl]\n+#define free_decl gnat_std_decls[(int) ADT_free_decl]\n+#define jmpbuf_type gnat_std_decls[(int) ADT_jmpbuf_type]\n+#define jmpbuf_ptr_type gnat_std_decls[(int) ADT_jmpbuf_ptr_type]\n+#define get_jmpbuf_decl gnat_std_decls[(int) ADT_get_jmpbuf_decl]\n+#define set_jmpbuf_decl gnat_std_decls[(int) ADT_set_jmpbuf_decl]\n+#define get_excptr_decl gnat_std_decls[(int) ADT_get_excptr_decl]\n+#define setjmp_decl gnat_std_decls[(int) ADT_setjmp_decl]\n+#define longjmp_decl gnat_std_decls[(int) ADT_longjmp_decl]\n+#define update_setjmp_buf_decl gnat_std_decls[(int) ADT_update_setjmp_buf_decl]\n+#define raise_nodefer_decl gnat_std_decls[(int) ADT_raise_nodefer_decl]\n+#define begin_handler_decl gnat_std_decls[(int) ADT_begin_handler_decl]\n+#define others_decl gnat_std_decls[(int) ADT_others_decl]\n+#define all_others_decl gnat_std_decls[(int) ADT_all_others_decl]\n+#define end_handler_decl gnat_std_decls[(int) ADT_end_handler_decl]\n+\n+/* Routines expected by the gcc back-end. They must have exactly the same\n+   prototype and names as below.  */\n+\n+/* Returns nonzero if we are currently in the global binding level.  */\n+extern int global_bindings_p (void);\n+\n+/* Enter and exit a new binding level. */\n+extern void gnat_pushlevel (void);\n+extern void gnat_poplevel (void);\n+\n+/* Set SUPERCONTEXT of the BLOCK for the current binding level to FNDECL\n+   and point FNDECL to this BLOCK.  */\n+extern void set_current_block_context (tree fndecl);\n+\n+/* Set the jmpbuf_decl for the current binding level to DECL.  */\n+extern void set_block_jmpbuf_decl (tree decl);\n+\n+/* Get the setjmp_decl, if any, for the current binding level.  */\n+extern tree get_block_jmpbuf_decl (void);\n+\n+/* Records a ..._DECL node DECL as belonging to the current lexical scope\n+   and uses GNAT_NODE for location information.  */\n+extern void gnat_pushdecl (tree decl, Node_Id gnat_node);\n+\n+extern void gnat_init_decl_processing (void);\n+extern void init_gigi_decls (tree long_long_float_type, tree exception_type);\n+extern void gnat_init_gcc_eh (void);\n+\n+/* Return an integer type with the number of bits of precision given by\n+   PRECISION.  UNSIGNEDP is nonzero if the type is unsigned; otherwise\n+   it is a signed type.  */\n+extern tree gnat_type_for_size (unsigned precision, int unsignedp);\n+\n+/* Return a data type that has machine mode MODE.  UNSIGNEDP selects\n+   an unsigned type; otherwise a signed type is returned.  */\n+extern tree gnat_type_for_mode (enum machine_mode mode, int unsignedp);\n+\n+/* Emit debug info for all global variable declarations.  */\n+extern void gnat_write_global_declarations (void);\n+\n+/* Return the unsigned version of a TYPE_NODE, a scalar type.  */\n+extern tree gnat_unsigned_type (tree type_node);\n+\n+/* Return the signed version of a TYPE_NODE, a scalar type.  */\n+extern tree gnat_signed_type (tree type_node);\n+\n+/* Return 1 if the types T1 and T2 are compatible, i.e. if they can be\n+   transparently converted to each other.  */\n+extern int gnat_types_compatible_p (tree t1, tree t2);\n+\n+/* Create an expression whose value is that of EXPR,\n+   converted to type TYPE.  The TREE_TYPE of the value\n+   is always TYPE.  This function implements all reasonable\n+   conversions; callers should filter out those that are\n+   not permitted by the language being compiled.  */\n+extern tree convert (tree type, tree expr);\n+\n+/* Routines created solely for the tree translator's sake. Their prototypes\n+   can be changed as desired.  */\n+\n+/* GNAT_ENTITY is a GNAT tree node for a defining identifier.\n+   GNU_DECL is the GCC tree which is to be associated with\n+   GNAT_ENTITY. Such gnu tree node is always an ..._DECL node.\n+   If NO_CHECK is nonzero, the latter check is suppressed.\n+   If GNU_DECL is zero, a previous association is to be reset.  */\n+extern void save_gnu_tree (Entity_Id gnat_entity, tree gnu_decl,\n+                           bool no_check);\n+\n+/* GNAT_ENTITY is a GNAT tree node for a defining identifier.\n+   Return the ..._DECL node that was associated with it.  If there is no tree\n+   node associated with GNAT_ENTITY, abort.  */\n+extern tree get_gnu_tree (Entity_Id gnat_entity);\n+\n+/* Return nonzero if a GCC tree has been associated with GNAT_ENTITY.  */\n+extern bool present_gnu_tree (Entity_Id gnat_entity);\n+\n+/* Initialize tables for above routines.  */\n+extern void init_gnat_to_gnu (void);\n+\n+/* Given a record type RECORD_TYPE and a chain of FIELD_DECL nodes FIELDLIST,\n+   finish constructing the record or union type.  If REP_LEVEL is zero, this\n+   record has no representation clause and so will be entirely laid out here.\n+   If REP_LEVEL is one, this record has a representation clause and has been\n+   laid out already; only set the sizes and alignment.  If REP_LEVEL is two,\n+   this record is derived from a parent record and thus inherits its layout;\n+   only make a pass on the fields to finalize them.  If DO_NOT_FINALIZE is\n+   true, the record type is expected to be modified afterwards so it will\n+   not be sent to the back-end for finalization.  */\n+extern void finish_record_type (tree record_type, tree fieldlist,\n+                                int rep_level, bool do_not_finalize);\n+\n+/* Wrap up compilation of RECORD_TYPE, i.e. most notably output all\n+   the debug information associated with it.  It need not be invoked\n+   directly in most cases since finish_record_type takes care of doing\n+   so, unless explicitly requested not to through DO_NOT_FINALIZE.  */\n+extern void rest_of_record_type_compilation (tree record_type);\n+\n+/* Append PARALLEL_TYPE on the chain of parallel types for decl.  */\n+extern void add_parallel_type (tree decl, tree parallel_type);\n+\n+/* Return the parallel type associated to a type, if any.  */\n+extern tree get_parallel_type (tree type);\n+\n+/* Returns a FUNCTION_TYPE node. RETURN_TYPE is the type returned by the\n+   subprogram. If it is void_type_node, then we are dealing with a procedure,\n+   otherwise we are dealing with a function. PARAM_DECL_LIST is a list of\n+   PARM_DECL nodes that are the subprogram arguments.  CICO_LIST is the\n+   copy-in/copy-out list to be stored into TYPE_CI_CO_LIST.\n+   RETURNS_UNCONSTRAINED is true if the function returns an unconstrained\n+   object.  RETURNS_BY_REF is true if the function returns by reference.\n+   RETURNS_BY_TARGET_PTR is true if the function is to be passed (as its\n+   first parameter) the address of the place to copy its result.  */\n+extern tree create_subprog_type (tree return_type, tree param_decl_list,\n+                                 tree cico_list, bool returns_unconstrained,\n+                                 bool returns_by_ref,\n+                                 bool returns_by_target_ptr);\n+\n+/* Return a copy of TYPE, but safe to modify in any way.  */\n+extern tree copy_type (tree type);\n+\n+/* Return an INTEGER_TYPE of SIZETYPE with range MIN to MAX and whose\n+   TYPE_INDEX_TYPE is INDEX.  GNAT_NODE is used for the position of\n+   the decl.  */\n+extern tree create_index_type (tree min, tree max, tree index,\n+\t\t\t       Node_Id gnat_node);\n+\n+/* Return a TYPE_DECL node. TYPE_NAME gives the name of the type (a character\n+   string) and TYPE is a ..._TYPE node giving its data type.\n+   ARTIFICIAL_P is true if this is a declaration that was generated\n+   by the compiler.  DEBUG_INFO_P is true if we need to write debugging\n+   information about this type.  GNAT_NODE is used for the position of\n+   the decl.  */\n+extern tree create_type_decl (tree type_name, tree type,\n+                              struct attrib *attr_list,\n+                              bool artificial_p, bool debug_info_p,\n+\t\t\t      Node_Id gnat_node);\n+\n+/* Return a VAR_DECL or CONST_DECL node.\n+\n+   VAR_NAME gives the name of the variable.  ASM_NAME is its assembler name\n+   (if provided).  TYPE is its data type (a GCC ..._TYPE node).  VAR_INIT is\n+   the GCC tree for an optional initial expression; NULL_TREE if none.\n+\n+   CONST_FLAG is true if this variable is constant, in which case we might\n+   return a CONST_DECL node unless CONST_DECL_ALLOWED_P is false.\n+\n+   PUBLIC_FLAG is true if this definition is to be made visible outside of\n+   the current compilation unit. This flag should be set when processing the\n+   variable definitions in a package specification.\n+\n+   EXTERN_FLAG is nonzero when processing an external variable declaration (as\n+   opposed to a definition: no storage is to be allocated for the variable).\n+\n+   STATIC_FLAG is only relevant when not at top level.  In that case\n+   it indicates whether to always allocate storage to the variable.\n+\n+   GNAT_NODE is used for the position of the decl.  */\n+tree\n+create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n+\t\t   bool const_flag, bool public_flag, bool extern_flag,\n+\t\t   bool static_flag, bool const_decl_allowed_p,\n+\t\t   struct attrib *attr_list, Node_Id gnat_node);\n+\n+/* Wrapper around create_var_decl_1 for cases where we don't care whether\n+   a VAR or a CONST decl node is created.  */\n+#define create_var_decl(var_name, asm_name, type, var_init,\t\\\n+\t\t\tconst_flag, public_flag, extern_flag,\t\\\n+\t\t\tstatic_flag, attr_list, gnat_node)\t\\\n+  create_var_decl_1 (var_name, asm_name, type, var_init,\t\\\n+\t\t     const_flag, public_flag, extern_flag,\t\\\n+\t\t     static_flag, true, attr_list, gnat_node)\n+\n+/* Wrapper around create_var_decl_1 for cases where a VAR_DECL node is\n+   required.  The primary intent is for DECL_CONST_CORRESPONDING_VARs, which\n+   must be VAR_DECLs and on which we want TREE_READONLY set to have them\n+   possibly assigned to a readonly data section.  */\n+#define create_true_var_decl(var_name, asm_name, type, var_init,\t\\\n+\t\t\t     const_flag, public_flag, extern_flag,\t\\\n+\t\t\t     static_flag, attr_list, gnat_node)\t\t\\\n+  create_var_decl_1 (var_name, asm_name, type, var_init,\t\t\\\n+\t\t     const_flag, public_flag, extern_flag,\t\t\\\n+\t\t     static_flag, false, attr_list, gnat_node)\n+\n+/* Given a DECL and ATTR_LIST, apply the listed attributes.  */\n+extern void process_attributes (tree decl, struct attrib *attr_list);\n+\n+/* Record a global renaming pointer.  */\n+void record_global_renaming_pointer (tree);\n+\n+/* Invalidate the global renaming pointers.   */\n+void invalidate_global_renaming_pointers (void);\n+\n+/* Returns a FIELD_DECL node. FIELD_NAME the field name, FIELD_TYPE is its\n+   type, and RECORD_TYPE is the type of the parent.  PACKED is nonzero if\n+   this field is in a record type with a \"pragma pack\".  If SIZE is nonzero\n+   it is the specified size for this field.  If POS is nonzero, it is the bit\n+   position.  If ADDRESSABLE is nonzero, it means we are allowed to take\n+   the address of this field for aliasing purposes.  */\n+extern tree create_field_decl (tree field_name, tree field_type,\n+                               tree record_type, int packed, tree size,\n+                               tree pos, int addressable);\n+\n+/* Returns a PARM_DECL node. PARAM_NAME is the name of the parameter,\n+   PARAM_TYPE is its type.  READONLY is true if the parameter is\n+   readonly (either an In parameter or an address of a pass-by-ref\n+   parameter). */\n+extern tree create_param_decl (tree param_name, tree param_type,\n+                               bool readonly);\n+\n+/* Returns a FUNCTION_DECL node.  SUBPROG_NAME is the name of the subprogram,\n+   ASM_NAME is its assembler name, SUBPROG_TYPE is its type (a FUNCTION_TYPE\n+   node), PARAM_DECL_LIST is the list of the subprogram arguments (a list of\n+   PARM_DECL nodes chained through the TREE_CHAIN field).\n+\n+   INLINE_FLAG, PUBLIC_FLAG, EXTERN_FLAG, and ATTR_LIST are used to set the\n+   appropriate fields in the FUNCTION_DECL.  GNAT_NODE gives the location.  */\n+extern tree create_subprog_decl (tree subprog_name, tree asm_name,\n+                                 tree subprog_type, tree param_decl_list,\n+                                 bool inlinee_flag, bool public_flag,\n+                                 bool extern_flag,\n+\t\t\t\t struct attrib *attr_list, Node_Id gnat_node);\n+\n+/* Returns a LABEL_DECL node for LABEL_NAME.  */\n+extern tree create_label_decl (tree label_name);\n+\n+/* Set up the framework for generating code for SUBPROG_DECL, a subprogram\n+   body. This routine needs to be invoked before processing the declarations\n+   appearing in the subprogram.  */\n+extern void begin_subprog_body (tree subprog_decl);\n+\n+/* Finish the definition of the current subprogram BODY and compile it all the\n+   way to assembler language output.  ELAB_P tells if this is called for an\n+   elaboration routine, to be entirely discarded if empty.  */\n+extern void end_subprog_body (tree body, bool elab_p);\n+\n+/* Build a template of type TEMPLATE_TYPE from the array bounds of ARRAY_TYPE.\n+   EXPR is an expression that we can use to locate any PLACEHOLDER_EXPRs.\n+   Return a constructor for the template.  */\n+extern tree build_template (tree template_type, tree array_type, tree expr);\n+\n+/* Build a VMS descriptor from a Mechanism_Type, which must specify\n+   a descriptor type, and the GCC type of an object.  Each FIELD_DECL\n+   in the type contains in its DECL_INITIAL the expression to use when\n+   a constructor is made for the type.  GNAT_ENTITY is a gnat node used\n+   to print out an error message if the mechanism cannot be applied to\n+   an object of that type and also for the name.  */\n+extern tree build_vms_descriptor (tree type, Mechanism_Type mech,\n+                                  Entity_Id gnat_entity);\n+\n+/* Build a stub for the subprogram specified by the GCC tree GNU_SUBPROG\n+   and the GNAT node GNAT_SUBPROG.  */\n+extern void build_function_stub (tree gnu_subprog, Entity_Id gnat_subprog);\n+\n+/* Build a type to be used to represent an aliased object whose nominal\n+   type is an unconstrained array.  This consists of a RECORD_TYPE containing\n+   a field of TEMPLATE_TYPE and a field of OBJECT_TYPE, which is an\n+   ARRAY_TYPE.  If ARRAY_TYPE is that of the unconstrained array, this\n+   is used to represent an arbitrary unconstrained object.  Use NAME\n+   as the name of the record.  */\n+extern tree build_unc_object_type (tree template_type, tree object_type,\n+                                   tree name);\n+\n+/* Same as build_unc_object_type, but taking a thin or fat pointer type\n+   instead of the template type. */\n+extern tree build_unc_object_type_from_ptr (tree thin_fat_ptr_type,\n+\t\t\t\t\t    tree object_type, tree name);\n+\n+/* Shift the component offsets within an unconstrained object TYPE to make it\n+   suitable for use as a designated type for thin pointers.  */\n+extern void shift_unc_components_for_thin_pointers (tree type);\n+\n+/* Update anything previously pointing to OLD_TYPE to point to NEW_TYPE.  In\n+   the normal case this is just two adjustments, but we have more to do\n+   if NEW is an UNCONSTRAINED_ARRAY_TYPE.  */\n+extern void update_pointer_to (tree old_type, tree new_type);\n+\n+/* EXP is an expression for the size of an object.  If this size contains\n+   discriminant references, replace them with the maximum (if MAX_P) or\n+   minimum (if !MAX_P) possible value of the discriminant.  */\n+extern tree max_size (tree exp, bool max_p);\n+\n+/* Remove all conversions that are done in EXP.  This includes converting\n+   from a padded type or to a left-justified modular type.  If TRUE_ADDRESS\n+   is true, always return the address of the containing object even if\n+   the address is not bit-aligned.  */\n+extern tree remove_conversions (tree exp, bool true_address);\n+\n+/* If EXP's type is an UNCONSTRAINED_ARRAY_TYPE, return an expression that\n+   refers to the underlying array.  If its type has TYPE_CONTAINS_TEMPLATE_P,\n+   likewise return an expression pointing to the underlying array.  */\n+extern tree maybe_unconstrained_array (tree exp);\n+\n+/* Return an expression that does an unchecked conversion of EXPR to TYPE.\n+   If NOTRUNC_P is true, truncation operations should be suppressed.  */\n+extern tree unchecked_convert (tree type, tree expr, bool notrunc_p);\n+\n+/* Return the appropriate GCC tree code for the specified GNAT type,\n+   the latter being a record type as predicated by Is_Record_Type.  */\n+extern enum tree_code tree_code_for_record_type (Entity_Id);\n+\n+/* Return true if GNU_TYPE is suitable as the type of a non-aliased\n+   component of an aggregate type.  */\n+extern bool type_for_nonaliased_component_p (tree);\n+\n+/* Prepare expr to be an argument of a TRUTH_NOT_EXPR or other logical\n+   operation.\n+\n+   This preparation consists of taking the ordinary\n+   representation of an expression EXPR and producing a valid tree\n+   boolean expression describing whether EXPR is nonzero.  We could\n+   simply always do build_binary_op (NE_EXPR, expr, integer_zero_node, 1),\n+   but we optimize comparisons, &&, ||, and !.\n+\n+   The resulting type should always be the same as the input type.\n+   This function is simpler than the corresponding C version since\n+   the only possible operands will be things of Boolean type.  */\n+extern tree gnat_truthvalue_conversion (tree expr);\n+\n+/* Return the base type of TYPE.  */\n+extern tree get_base_type (tree type);\n+\n+/* EXP is a GCC tree representing an address.  See if we can find how\n+   strictly the object at that address is aligned.   Return that alignment\n+   strictly the object at that address is aligned.   Return that alignment\n+   in bits.  If we don't know anything about the alignment, return 0.  */\n+extern unsigned int known_alignment (tree exp);\n+\n+/* Return true if VALUE is a multiple of FACTOR. FACTOR must be a power\n+   of 2. */\n+extern bool value_factor_p (tree value, HOST_WIDE_INT factor);\n+\n+/* Make a binary operation of kind OP_CODE.  RESULT_TYPE is the type\n+   desired for the result.  Usually the operation is to be performed\n+   in that type.  For MODIFY_EXPR and ARRAY_REF, RESULT_TYPE may be 0\n+   in which case the type to be used will be derived from the operands.  */\n+extern tree build_binary_op (enum tree_code op_code, tree retult_type,\n+                             tree left_operand, tree right_operand);\n+\n+/* Similar, but make unary operation.   */\n+extern tree build_unary_op (enum tree_code op_code, tree result_type,\n+                            tree operand);\n+\n+/* Similar, but for COND_EXPR.  */\n+extern tree build_cond_expr (tree result_type, tree condition_operand,\n+                             tree true_operand, tree false_operand);\n+\n+/* Similar, but for RETURN_EXPR.  */\n+extern tree build_return_expr (tree result_decl, tree ret_val);\n+\n+/* Build a CALL_EXPR to call FUNDECL with one argument, ARG.  Return\n+   the CALL_EXPR.  */\n+extern tree build_call_1_expr (tree fundecl, tree arg);\n+\n+/* Build a CALL_EXPR to call FUNDECL with two argument, ARG1 & ARG2.  Return\n+   the CALL_EXPR.  */\n+extern tree build_call_2_expr (tree fundecl, tree arg1, tree arg2);\n+\n+/* Likewise to call FUNDECL with no arguments.  */\n+extern tree build_call_0_expr (tree fundecl);\n+\n+/* Call a function that raises an exception and pass the line number and file\n+   name, if requested.  MSG says which exception function to call.\n+\n+   GNAT_NODE is the gnat node conveying the source location for which the\n+   error should be signaled, or Empty in which case the error is signaled on\n+   the current ref_file_name/input_line.\n+\n+   KIND says which kind of exception this is for\n+    (N_Raise_{Constraint,Storage,Program}_Error).  */\n+extern tree build_call_raise (int msg, Node_Id gnat_node, char kind);\n+\n+/* Return a CONSTRUCTOR of TYPE whose list is LIST.  This is not the\n+   same as build_constructor in the language-independent tree.c.  */\n+extern tree gnat_build_constructor (tree type, tree list);\n+\n+/* Return a COMPONENT_REF to access a field that is given by COMPONENT,\n+   an IDENTIFIER_NODE giving the name of the field, FIELD, a FIELD_DECL,\n+   for the field, or both.  Don't fold the result if NO_FOLD_P.  */\n+extern tree build_component_ref (tree record_variable, tree component,\n+                                 tree field, bool no_fold_p);\n+\n+/* Build a GCC tree to call an allocation or deallocation function.\n+   If GNU_OBJ is nonzero, it is an object to deallocate.  Otherwise,\n+   generate an allocator.\n+\n+   GNU_SIZE is the size of the object and ALIGN is the alignment.\n+   GNAT_PROC, if present is a procedure to call and GNAT_POOL is the\n+   storage pool to use.  If not preset, malloc and free will be used.  */\n+extern tree build_call_alloc_dealloc (tree gnu_obj, tree gnu_size,\n+                                      unsigned align, Entity_Id gnat_proc,\n+\t\t\t\t      Entity_Id gnat_pool, Node_Id gnat_node);\n+\n+/* Build a GCC tree to correspond to allocating an object of TYPE whose\n+   initial value if INIT, if INIT is nonzero.  Convert the expression to\n+   RESULT_TYPE, which must be some type of pointer.  Return the tree.\n+   GNAT_PROC and GNAT_POOL optionally give the procedure to call and\n+   the storage pool to use.  GNAT_NODE is used to provide an error\n+   location for restriction violations messages.  If IGNORE_INIT_TYPE is\n+   true, ignore the type of INIT for the purpose of determining the size;\n+   this will cause the maximum size to be allocated if TYPE is of\n+   self-referential size.  */\n+extern tree build_allocator (tree type, tree init, tree result_type,\n+                             Entity_Id gnat_proc, Entity_Id gnat_pool,\n+                             Node_Id gnat_node, bool);\n+\n+/* Fill in a VMS descriptor for EXPR and return a constructor for it.\n+   GNAT_FORMAL is how we find the descriptor record.  */\n+\n+extern tree fill_vms_descriptor (tree expr, Entity_Id gnat_formal);\n+\n+/* Indicate that we need to make the address of EXPR_NODE and it therefore\n+   should not be allocated in a register.  Return true if successful.  */\n+extern bool gnat_mark_addressable (tree expr_node);\n+\n+/* Implementation of the builtin_function langhook.  */\n+extern tree gnat_builtin_function (tree decl);\n+\n+/* Search the chain of currently reachable declarations for a builtin\n+   FUNCTION_DECL node corresponding to function NAME (an IDENTIFIER_NODE).\n+   Return the first node found, if any, or NULL_TREE otherwise.  */\n+extern tree builtin_decl_for (tree name);\n+\n+/* This function is called by the front end to enumerate all the supported\n+   modes for the machine.  We pass a function which is called back with\n+   the following integer parameters:\n+\n+   FLOAT_P\tnonzero if this represents a floating-point mode\n+   COMPLEX_P\tnonzero is this represents a complex mode\n+   COUNT\tcount of number of items, nonzero for vector mode\n+   PRECISION\tnumber of bits in data representation\n+   MANTISSA\tnumber of bits in mantissa, if FP and known, else zero.\n+   SIZE\t\tnumber of bits used to store data\n+   ALIGN\tnumber of bits to which mode is aligned.  */\n+extern void enumerate_modes (void (*f) (int, int, int, int, int, int,\n+\t\t\t\t\tunsigned int));\n+\n+/* These are temporary function to deal with recent GCC changes related to\n+   FP type sizes and precisions.  */\n+extern int fp_prec_to_size (int prec);\n+extern int fp_size_to_prec (int size);\n+\n+/* These functions return the basic data type sizes and related parameters\n+   about the target machine.  */\n+\n+extern Pos get_target_bits_per_unit (void);\n+extern Pos get_target_bits_per_word (void);\n+extern Pos get_target_char_size (void);\n+extern Pos get_target_wchar_t_size (void);\n+extern Pos get_target_short_size (void);\n+extern Pos get_target_int_size (void);\n+extern Pos get_target_long_size (void);\n+extern Pos get_target_long_long_size (void);\n+extern Pos get_target_float_size (void);\n+extern Pos get_target_double_size (void);\n+extern Pos get_target_long_double_size (void);\n+extern Pos get_target_pointer_size (void);\n+extern Pos get_target_maximum_alignment (void);\n+extern Pos get_target_default_allocator_alignment (void);\n+extern Pos get_target_maximum_default_alignment (void);\n+extern Pos get_target_maximum_allowed_alignment (void);\n+extern Nat get_float_words_be (void);\n+extern Nat get_words_be (void);\n+extern Nat get_bytes_be (void);\n+extern Nat get_bits_be (void);\n+extern Nat get_strict_alignment (void);"}, {"sha": "65326d4c5b2d95b30debe5aaf4fa762ca5f2e27e", "filename": "gcc/ada/gcc-interface/lang-specs.h", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Flang-specs.h?ref=a1ab4c317abfd045fe0619b455a31e19f910f7e7", "patch": "@@ -0,0 +1,48 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                            L A N G - S P E C S                           *\n+ *                                                                          *\n+ *                              C Header File                               *\n+ *                                                                          *\n+ *           Copyright (C) 1992-2008, Free Software Foundation, Inc.        *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have received a copy of the GNU General   *\n+ * Public License along with GCC; see the file COPYING3.  If not see        *\n+ * <http://www.gnu.org/licenses/>.                                          *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* This is the contribution to the `default_compilers' array in gcc.c for\n+   GNAT.  */\n+\n+  {\".ads\", \"@ada\", 0, 0, 0},\n+  {\".adb\", \"@ada\", 0, 0, 0},\n+  {\"@ada\",\n+   \"\\\n+ %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\\n+ %{!S:%{!c:%e-c or -S required for Ada}}\\\n+ gnat1 %{I*} %{k8:-gnatk8} %{Wall:-gnatwa} %{w:-gnatws} %{!Q:-quiet}\\\n+    %{nostdinc*} %{nostdlib*}\\\n+    -dumpbase %{.adb:%b.adb}%{.ads:%b.ads}%{!.adb:%{!.ads:%b.ada}}\\\n+    %{O*} %{W*} %{w} %{p} %{pg:-p} %{a} %{f*} %{d*} %{g*&m*} \"\n+#if defined(TARGET_VXWORKS_RTP)\n+   \"%{fRTS=rtp:-mrtp} \"\n+#endif\n+#if CONFIG_DUAL_EXCEPTIONS\n+   \"%{fRTS=sjlj:-fsjlj} \"\n+#endif\n+   \"%1 %{!S:%{o*:%w%*-gnatO}} \\\n+    %i %{S:%W{o*}%{!o*:-o %b.s}} \\\n+    %{gnatc*|gnats*: -o %j} %{-param*} \\\n+    %{!gnatc*:%{!gnats*:%(invoke_as)}}\", 0, 0, 0},"}, {"sha": "d10fc3ac08748776065f68d0b92e8805b43c70ee", "filename": "gcc/ada/gcc-interface/lang.opt", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Flang.opt?ref=a1ab4c317abfd045fe0619b455a31e19f910f7e7", "patch": "@@ -0,0 +1,102 @@\n+; Options for the Ada front end.\n+; Copyright (C) 2003, 2007 Free Software Foundation, Inc.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 3, or (at your option) any later\n+; version.\n+; \n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+; \n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.\n+\n+\n+; See the GCC internals manual for a description of this file's format.\n+\n+; Please try to keep this file in ASCII collating order.\n+\n+Language\n+Ada\n+\n+I\n+Ada Joined Separate\n+; Documented for C\n+\n+Wall\n+Ada\n+; Documented for C\n+\n+Wmissing-prototypes\n+Ada\n+; Documented for C\n+\n+Wstrict-prototypes\n+Ada\n+; Documented for C\n+\n+Wwrite-strings\n+Ada\n+; Documented for C\n+\n+Wlong-long\n+Ada\n+; Documented for C\n+\n+Wvariadic-macros\n+Ada\n+; Documented for C\n+\n+Wold-style-definition\n+Ada\n+; Documented for C\n+\n+Wmissing-format-attribute\n+Ada\n+; Documented for C\n+\n+Woverlength-strings\n+Ada\n+; Documented for C\n+\n+nostdinc\n+Ada RejectNegative\n+; Don't look for source files\n+\n+nostdlib\n+Ada\n+; Don't look for object files\n+\n+feliminate-unused-debug-types\n+Ada\n+; Effect documented for C - intercepted for Ada to force the associated flag\n+; not to be set by default, as it currently eliminates unreferenced parallel\n+; types we need for encoding descriptions to the debugger.\n+\n+fRTS=\n+Ada Joined RejectNegative\n+; Selects the runtime\n+\n+gdwarf+\n+Ada\n+; Explicit request for dwarf debug info with GNAT specific extensions.\n+\n+gant\n+Ada Joined Undocumented\n+; Catches typos\n+\n+gnatO\n+Ada Separate\n+; Sets name of output ALI file (internal switch)\n+\n+gnat\n+Ada Joined\n+-gnat<options>\tSpecify options to GNAT\n+\n+; This comment is to ensure we retain the blank line above."}, {"sha": "02397d7f44532dd7e4dcd7a5e4e15fa9e48a2009", "filename": "gcc/ada/gcc-interface/misc.c", "status": "added", "additions": 876, "deletions": 0, "changes": 876, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=a1ab4c317abfd045fe0619b455a31e19f910f7e7", "patch": "@@ -0,0 +1,876 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                                 M I S C                                  *\n+ *                                                                          *\n+ *                           C Implementation File                          *\n+ *                                                                          *\n+ *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, *\n+ * Boston, MA 02110-1301, USA.                                              *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* This file contains parts of the compiler that are required for interfacing\n+   with GCC but otherwise do nothing and parts of Gigi that need to know\n+   about RTL.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"real.h\"\n+#include \"rtl.h\"\n+#include \"diagnostic.h\"\n+#include \"expr.h\"\n+#include \"libfuncs.h\"\n+#include \"ggc.h\"\n+#include \"flags.h\"\n+#include \"debug.h\"\n+#include \"cgraph.h\"\n+#include \"tree-inline.h\"\n+#include \"insn-codes.h\"\n+#include \"insn-flags.h\"\n+#include \"insn-config.h\"\n+#include \"optabs.h\"\n+#include \"recog.h\"\n+#include \"toplev.h\"\n+#include \"output.h\"\n+#include \"except.h\"\n+#include \"tm_p.h\"\n+#include \"langhooks.h\"\n+#include \"langhooks-def.h\"\n+#include \"target.h\"\n+\n+#include \"ada.h\"\n+#include \"types.h\"\n+#include \"atree.h\"\n+#include \"elists.h\"\n+#include \"namet.h\"\n+#include \"nlists.h\"\n+#include \"stringt.h\"\n+#include \"uintp.h\"\n+#include \"fe.h\"\n+#include \"sinfo.h\"\n+#include \"einfo.h\"\n+#include \"ada-tree.h\"\n+#include \"gigi.h\"\n+#include \"adadecode.h\"\n+#include \"opts.h\"\n+#include \"options.h\"\n+\n+extern FILE *asm_out_file;\n+\n+/* The largest alignment, in bits, that is needed for using the widest\n+   move instruction.  */\n+unsigned int largest_move_alignment;\n+\n+static bool gnat_init\t\t\t(void);\n+static void gnat_finish_incomplete_decl\t(tree);\n+static unsigned int gnat_init_options\t(unsigned int, const char **);\n+static int gnat_handle_option\t\t(size_t, const char *, int);\n+static bool gnat_post_options\t\t(const char **);\n+static alias_set_type gnat_get_alias_set (tree);\n+static void gnat_print_decl\t\t(FILE *, tree, int);\n+static void gnat_print_type\t\t(FILE *, tree, int);\n+static const char *gnat_printable_name\t(tree, int);\n+static const char *gnat_dwarf_name\t(tree, int);\n+static tree gnat_return_tree\t\t(tree);\n+static int gnat_eh_type_covers\t\t(tree, tree);\n+static void gnat_parse_file\t\t(int);\n+static rtx gnat_expand_expr\t\t(tree, rtx, enum machine_mode, int,\n+\t\t\t\t\t rtx *);\n+static void internal_error_function\t(const char *, va_list *);\n+static tree gnat_type_max_size\t\t(const_tree);\n+\n+/* Definitions for our language-specific hooks.  */\n+\n+#undef  LANG_HOOKS_NAME\n+#define LANG_HOOKS_NAME\t\t\t\"GNU Ada\"\n+#undef  LANG_HOOKS_IDENTIFIER_SIZE\n+#define LANG_HOOKS_IDENTIFIER_SIZE\tsizeof (struct tree_identifier)\n+#undef  LANG_HOOKS_INIT\n+#define LANG_HOOKS_INIT\t\t\tgnat_init\n+#undef  LANG_HOOKS_INIT_OPTIONS\n+#define LANG_HOOKS_INIT_OPTIONS\t\tgnat_init_options\n+#undef  LANG_HOOKS_HANDLE_OPTION\n+#define LANG_HOOKS_HANDLE_OPTION\tgnat_handle_option\n+#undef  LANG_HOOKS_POST_OPTIONS\n+#define LANG_HOOKS_POST_OPTIONS\t\tgnat_post_options\n+#undef  LANG_HOOKS_PARSE_FILE\n+#define LANG_HOOKS_PARSE_FILE\t\tgnat_parse_file\n+#undef  LANG_HOOKS_HASH_TYPES\n+#define LANG_HOOKS_HASH_TYPES\t\tfalse\n+#undef  LANG_HOOKS_GETDECLS\n+#define LANG_HOOKS_GETDECLS\t\tlhd_return_null_tree_v\n+#undef  LANG_HOOKS_PUSHDECL\n+#define LANG_HOOKS_PUSHDECL\t\tgnat_return_tree\n+#undef  LANG_HOOKS_WRITE_GLOBALS\n+#define LANG_HOOKS_WRITE_GLOBALS\tgnat_write_global_declarations\n+#undef  LANG_HOOKS_FINISH_INCOMPLETE_DECL\n+#define LANG_HOOKS_FINISH_INCOMPLETE_DECL gnat_finish_incomplete_decl\n+#undef  LANG_HOOKS_GET_ALIAS_SET\n+#define LANG_HOOKS_GET_ALIAS_SET\tgnat_get_alias_set\n+#undef  LANG_HOOKS_EXPAND_EXPR\n+#define LANG_HOOKS_EXPAND_EXPR\t\tgnat_expand_expr\n+#undef  LANG_HOOKS_MARK_ADDRESSABLE\n+#define LANG_HOOKS_MARK_ADDRESSABLE\tgnat_mark_addressable\n+#undef  LANG_HOOKS_PRINT_DECL\n+#define LANG_HOOKS_PRINT_DECL\t\tgnat_print_decl\n+#undef  LANG_HOOKS_PRINT_TYPE\n+#define LANG_HOOKS_PRINT_TYPE\t\tgnat_print_type\n+#undef  LANG_HOOKS_TYPE_MAX_SIZE\n+#define LANG_HOOKS_TYPE_MAX_SIZE\tgnat_type_max_size\n+#undef  LANG_HOOKS_DECL_PRINTABLE_NAME\n+#define LANG_HOOKS_DECL_PRINTABLE_NAME\tgnat_printable_name\n+#undef  LANG_HOOKS_DWARF_NAME\n+#define LANG_HOOKS_DWARF_NAME\t\tgnat_dwarf_name\n+#undef  LANG_HOOKS_GIMPLIFY_EXPR\n+#define LANG_HOOKS_GIMPLIFY_EXPR\tgnat_gimplify_expr\n+#undef  LANG_HOOKS_TYPE_FOR_MODE\n+#define LANG_HOOKS_TYPE_FOR_MODE\tgnat_type_for_mode\n+#undef  LANG_HOOKS_TYPE_FOR_SIZE\n+#define LANG_HOOKS_TYPE_FOR_SIZE\tgnat_type_for_size\n+#undef  LANG_HOOKS_TYPES_COMPATIBLE_P\n+#define LANG_HOOKS_TYPES_COMPATIBLE_P\tgnat_types_compatible_p\n+#undef  LANG_HOOKS_ATTRIBUTE_TABLE\n+#define LANG_HOOKS_ATTRIBUTE_TABLE\tgnat_internal_attribute_table\n+#undef  LANG_HOOKS_BUILTIN_FUNCTION\n+#define LANG_HOOKS_BUILTIN_FUNCTION        gnat_builtin_function\n+\n+const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n+\n+/* How much we want of our DWARF extensions.  Some of our dwarf+ extensions\n+   are incompatible with regular GDB versions, so we must make sure to only\n+   produce them on explicit request.  This is eventually reflected into the\n+   use_gnu_debug_info_extensions common flag for later processing.  */\n+\n+static int gnat_dwarf_extensions = 0;\n+\n+/* Command-line argc and argv.\n+   These variables are global, since they are imported and used in\n+   back_end.adb  */\n+\n+unsigned int save_argc;\n+const char **save_argv;\n+\n+/* gnat standard argc argv */\n+\n+extern int gnat_argc;\n+extern char **gnat_argv;\n+\n+\f\n+/* Declare functions we use as part of startup.  */\n+extern void __gnat_initialize           (void *);\n+extern void __gnat_install_SEH_handler  (void *);\n+extern void adainit\t\t        (void);\n+extern void _ada_gnat1drv\t        (void);\n+\n+/* The parser for the language.  For us, we process the GNAT tree.  */\n+\n+static void\n+gnat_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n+{\n+  int seh[2];\n+\n+  /* Call the target specific initializations.  */\n+  __gnat_initialize (NULL);\n+\n+  /* ??? Call the SEH initialization routine.  This is to workaround\n+  a bootstrap path problem.  The call below should be removed at some\n+  point and the SEH pointer passed to __gnat_initialize() above.  */\n+  __gnat_install_SEH_handler((void *)seh);\n+\n+  /* Call the front-end elaboration procedures.  */\n+  adainit ();\n+\n+  /* Call the front end.  */\n+  _ada_gnat1drv ();\n+\n+  /* We always have a single compilation unit in Ada.  */\n+  cgraph_finalize_compilation_unit ();\n+}\n+\n+/* Decode all the language specific options that cannot be decoded by GCC.\n+   The option decoding phase of GCC calls this routine on the flags that\n+   it cannot decode.  This routine returns the number of consecutive arguments\n+   from ARGV that it successfully decoded; 0 indicates failure.  */\n+\n+static int\n+gnat_handle_option (size_t scode, const char *arg, int value)\n+{\n+  const struct cl_option *option = &cl_options[scode];\n+  enum opt_code code = (enum opt_code) scode;\n+  char *q;\n+\n+  if (arg == NULL && (option->flags & (CL_JOINED | CL_SEPARATE)))\n+    {\n+      error (\"missing argument to \\\"-%s\\\"\", option->opt_text);\n+      return 1;\n+    }\n+\n+  switch (code)\n+    {\n+    case OPT_I:\n+      q = XNEWVEC (char, sizeof(\"-I\") + strlen (arg));\n+      strcpy (q, \"-I\");\n+      strcat (q, arg);\n+      gnat_argv[gnat_argc] = q;\n+      gnat_argc++;\n+      break;\n+\n+    case OPT_Wall:\n+      set_Wunused (value);\n+\n+      /* We save the value of warn_uninitialized, since if they put\n+\t -Wuninitialized on the command line, we need to generate a\n+\t warning about not using it without also specifying -O.  */\n+      if (warn_uninitialized != 1)\n+\twarn_uninitialized = (value ? 2 : 0);\n+      break;\n+\n+      /* These are used in the GCC Makefile.  */\n+    case OPT_Wmissing_prototypes:\n+    case OPT_Wstrict_prototypes:\n+    case OPT_Wwrite_strings:\n+    case OPT_Wlong_long:\n+    case OPT_Wvariadic_macros:\n+    case OPT_Wold_style_definition:\n+    case OPT_Wmissing_format_attribute:\n+    case OPT_Woverlength_strings:\n+      break;\n+\n+      /* This is handled by the front-end.  */\n+    case OPT_nostdinc:\n+      break;\n+\n+    case OPT_nostdlib:\n+      gnat_argv[gnat_argc] = xstrdup (\"-nostdlib\");\n+      gnat_argc++;\n+      break;\n+\n+    case OPT_feliminate_unused_debug_types:\n+      /* We arrange for post_option to be able to only set the corresponding\n+\t flag to 1 when explicitly requested by the user.  We expect the\n+\t default flag value to be either 0 or positive, and expose a positive\n+\t -f as a negative value to post_option.  */\n+      flag_eliminate_unused_debug_types = -value;\n+      break;\n+\n+    case OPT_fRTS_:\n+      gnat_argv[gnat_argc] = xstrdup (\"-fRTS\");\n+      gnat_argc++;\n+      break;\n+\n+    case OPT_gant:\n+      warning (0, \"%<-gnat%> misspelled as %<-gant%>\");\n+\n+      /* ... fall through ... */\n+\n+    case OPT_gnat:\n+      /* Recopy the switches without the 'gnat' prefix.  */\n+      gnat_argv[gnat_argc] = XNEWVEC (char, strlen (arg) + 2);\n+      gnat_argv[gnat_argc][0] = '-';\n+      strcpy (gnat_argv[gnat_argc] + 1, arg);\n+      gnat_argc++;\n+      break;\n+\n+    case OPT_gnatO:\n+      gnat_argv[gnat_argc] = xstrdup (\"-O\");\n+      gnat_argc++;\n+      gnat_argv[gnat_argc] = xstrdup (arg);\n+      gnat_argc++;\n+      break;\n+\n+    case OPT_gdwarf_:\n+      gnat_dwarf_extensions ++;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return 1;\n+}\n+\n+/* Initialize for option processing.  */\n+\n+static unsigned int\n+gnat_init_options (unsigned int argc, const char **argv)\n+{\n+  /* Initialize gnat_argv with save_argv size.  */\n+  gnat_argv = (char **) xmalloc ((argc + 1) * sizeof (argv[0]));\n+  gnat_argv[0] = xstrdup (argv[0]);     /* name of the command */\n+  gnat_argc = 1;\n+\n+  save_argc = argc;\n+  save_argv = argv;\n+\n+  /* Uninitialized really means uninitialized in Ada.  */\n+  flag_zero_initialized_in_bss = 0;\n+\n+  return CL_Ada;\n+}\n+\n+/* Post-switch processing.  */\n+\n+bool\n+gnat_post_options (const char **pfilename ATTRIBUTE_UNUSED)\n+{\n+  /* ??? The warning machinery is outsmarted by Ada.  */\n+  warn_unused_parameter = 0;\n+\n+  /* Force eliminate_unused_debug_types to 0 unless an explicit positive\n+     -f has been passed.  This forces the default to 0 for Ada, which might\n+     differ from the common default.  */\n+  if (flag_eliminate_unused_debug_types < 0)\n+    flag_eliminate_unused_debug_types = 1;\n+  else\n+    flag_eliminate_unused_debug_types = 0;\n+\n+  /* Reflect the explicit request of DWARF extensions into the common\n+     flag for use by later passes.  */\n+  if (write_symbols == DWARF2_DEBUG)\n+    use_gnu_debug_info_extensions = gnat_dwarf_extensions > 0;\n+\n+  return false;\n+}\n+\n+/* Here is the function to handle the compiler error processing in GCC.  */\n+\n+static void\n+internal_error_function (const char *msgid, va_list *ap)\n+{\n+  text_info tinfo;\n+  char *buffer, *p, *loc;\n+  String_Template temp, temp_loc;\n+  Fat_Pointer fp, fp_loc;\n+  expanded_location s;\n+\n+  /* Reset the pretty-printer.  */\n+  pp_clear_output_area (global_dc->printer);\n+\n+  /* Format the message into the pretty-printer.  */\n+  tinfo.format_spec = msgid;\n+  tinfo.args_ptr = ap;\n+  tinfo.err_no = errno;\n+  pp_format_verbatim (global_dc->printer, &tinfo);\n+\n+  /* Extract a (writable) pointer to the formatted text.  */\n+  buffer = (char*) pp_formatted_text (global_dc->printer);\n+\n+  /* Go up to the first newline.  */\n+  for (p = buffer; *p; p++)\n+    if (*p == '\\n')\n+      {\n+\t*p = '\\0';\n+\tbreak;\n+      }\n+\n+  temp.Low_Bound = 1;\n+  temp.High_Bound = p - buffer;\n+  fp.Bounds = &temp;\n+  fp.Array = buffer;\n+\n+  s = expand_location (input_location);\n+  if (flag_show_column && s.column != 0)\n+    asprintf (&loc, \"%s:%d:%d\", s.file, s.line, s.column);\n+  else\n+    asprintf (&loc, \"%s:%d\", s.file, s.line);\n+  temp_loc.Low_Bound = 1;\n+  temp_loc.High_Bound = strlen (loc);\n+  fp_loc.Bounds = &temp_loc;\n+  fp_loc.Array = loc;\n+\n+  Current_Error_Node = error_gnat_node;\n+  Compiler_Abort (fp, -1, fp_loc);\n+}\n+\n+/* Perform all the initialization steps that are language-specific.  */\n+\n+static bool\n+gnat_init (void)\n+{\n+  /* Performs whatever initialization steps needed by the language-dependent\n+     lexical analyzer.  */\n+  gnat_init_decl_processing ();\n+\n+  /* Add the input filename as the last argument.  */\n+  gnat_argv[gnat_argc] = (char *) main_input_filename;\n+  gnat_argc++;\n+  gnat_argv[gnat_argc] = 0;\n+\n+  global_dc->internal_error = &internal_error_function;\n+\n+  /* Show that REFERENCE_TYPEs are internal and should be Pmode.  */\n+  internal_reference_types ();\n+\n+  return true;\n+}\n+\n+/* This function is called indirectly from toplev.c to handle incomplete\n+   declarations, i.e. VAR_DECL nodes whose DECL_SIZE is zero.  To be precise,\n+   compile_file in toplev.c makes an indirect call through the function pointer\n+   incomplete_decl_finalize_hook which is initialized to this routine in\n+   init_decl_processing.  */\n+\n+static void\n+gnat_finish_incomplete_decl (tree dont_care ATTRIBUTE_UNUSED)\n+{\n+  gcc_unreachable ();\n+}\n+\f\n+/* Compute the alignment of the largest mode that can be used for copying\n+   objects.  */\n+\n+void\n+gnat_compute_largest_alignment (void)\n+{\n+  enum machine_mode mode;\n+\n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    if (optab_handler (mov_optab, mode)->insn_code != CODE_FOR_nothing)\n+      largest_move_alignment = MIN (BIGGEST_ALIGNMENT,\n+\t\t\t\t    MAX (largest_move_alignment,\n+\t\t\t\t\t GET_MODE_ALIGNMENT (mode)));\n+}\n+\n+/* If we are using the GCC mechanism to process exception handling, we\n+   have to register the personality routine for Ada and to initialize\n+   various language dependent hooks.  */\n+\n+void\n+gnat_init_gcc_eh (void)\n+{\n+#ifdef DWARF2_UNWIND_INFO\n+  /* lang_dependent_init already called dwarf2out_frame_init if true.  */\n+  int dwarf2out_frame_initialized = dwarf2out_do_frame ();\n+#endif\n+\n+  /* We shouldn't do anything if the No_Exceptions_Handler pragma is set,\n+     though. This could for instance lead to the emission of tables with\n+     references to symbols (such as the Ada eh personality routine) within\n+     libraries we won't link against.  */\n+  if (No_Exception_Handlers_Set ())\n+    return;\n+\n+  /* Tell GCC we are handling cleanup actions through exception propagation.\n+     This opens possibilities that we don't take advantage of yet, but is\n+     nonetheless necessary to ensure that fixup code gets assigned to the\n+     right exception regions.  */\n+  using_eh_for_cleanups ();\n+\n+  eh_personality_libfunc = init_one_libfunc (USING_SJLJ_EXCEPTIONS\n+\t\t\t\t\t     ? \"__gnat_eh_personality_sj\"\n+\t\t\t\t\t     : \"__gnat_eh_personality\");\n+  lang_eh_type_covers = gnat_eh_type_covers;\n+  lang_eh_runtime_type = gnat_return_tree;\n+  default_init_unwind_resume_libfunc ();\n+\n+  /* Turn on -fexceptions and -fnon-call-exceptions. The first one triggers\n+     the generation of the necessary exception runtime tables. The second one\n+     is useful for two reasons: 1/ we map some asynchronous signals like SEGV\n+     to exceptions, so we need to ensure that the insns which can lead to such\n+     signals are correctly attached to the exception region they pertain to,\n+     2/ Some calls to pure subprograms are handled as libcall blocks and then\n+     marked as \"cannot trap\" if the flag is not set (see emit_libcall_block).\n+     We should not let this be since it is possible for such calls to actually\n+     raise in Ada.  */\n+  flag_exceptions = 1;\n+  flag_non_call_exceptions = 1;\n+\n+  init_eh ();\n+#ifdef DWARF2_UNWIND_INFO\n+  if (!dwarf2out_frame_initialized && dwarf2out_do_frame ())\n+    dwarf2out_frame_init ();\n+#endif\n+}\n+\n+/* Language hooks, first one to print language-specific items in a DECL.  */\n+\n+static void\n+gnat_print_decl (FILE *file, tree node, int indent)\n+{\n+  switch (TREE_CODE (node))\n+    {\n+    case CONST_DECL:\n+      print_node (file, \"const_corresponding_var\",\n+\t\t  DECL_CONST_CORRESPONDING_VAR (node), indent + 4);\n+      break;\n+\n+    case FIELD_DECL:\n+      print_node (file, \"original_field\", DECL_ORIGINAL_FIELD (node),\n+\t\t  indent + 4);\n+      break;\n+\n+    case VAR_DECL:\n+      print_node (file, \"renamed_object\", DECL_RENAMED_OBJECT (node),\n+\t\t  indent + 4);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+static void\n+gnat_print_type (FILE *file, tree node, int indent)\n+{\n+  switch (TREE_CODE (node))\n+    {\n+    case FUNCTION_TYPE:\n+      print_node (file, \"ci_co_list\", TYPE_CI_CO_LIST (node), indent + 4);\n+      break;\n+\n+    case ENUMERAL_TYPE:\n+      print_node (file, \"RM size\", TYPE_RM_SIZE_NUM (node), indent + 4);\n+      break;\n+\n+    case INTEGER_TYPE:\n+      if (TYPE_MODULAR_P (node))\n+\tprint_node (file, \"modulus\", TYPE_MODULUS (node), indent + 4);\n+      else if (TYPE_HAS_ACTUAL_BOUNDS_P (node))\n+\tprint_node (file, \"actual bounds\", TYPE_ACTUAL_BOUNDS (node),\n+\t\t    indent + 4);\n+      else if (TYPE_VAX_FLOATING_POINT_P (node))\n+\t;\n+      else\n+\tprint_node (file, \"index type\", TYPE_INDEX_TYPE (node), indent + 4);\n+\n+      print_node (file, \"RM size\", TYPE_RM_SIZE_NUM (node), indent + 4);\n+      break;\n+\n+    case ARRAY_TYPE:\n+      print_node (file,\"actual bounds\", TYPE_ACTUAL_BOUNDS (node), indent + 4);\n+      break;\n+\n+    case RECORD_TYPE:\n+      if (TYPE_IS_FAT_POINTER_P (node) || TYPE_CONTAINS_TEMPLATE_P (node))\n+\tprint_node (file, \"unconstrained array\",\n+\t\t    TYPE_UNCONSTRAINED_ARRAY (node), indent + 4);\n+      else\n+\tprint_node (file, \"Ada size\", TYPE_ADA_SIZE (node), indent + 4);\n+      break;\n+\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n+      print_node (file, \"Ada size\", TYPE_ADA_SIZE (node), indent + 4);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+static const char *\n+gnat_dwarf_name (tree t, int verbosity ATTRIBUTE_UNUSED)\n+{\n+  gcc_assert (DECL_P (t));\n+\n+  return (const char *) IDENTIFIER_POINTER (DECL_NAME (t));\n+}\n+\n+static const char *\n+gnat_printable_name (tree decl, int verbosity)\n+{\n+  const char *coded_name = IDENTIFIER_POINTER (DECL_NAME (decl));\n+  char *ada_name = (char *) ggc_alloc (strlen (coded_name) * 2 + 60);\n+\n+  __gnat_decode (coded_name, ada_name, 0);\n+\n+  if (verbosity == 2)\n+    {\n+      Set_Identifier_Casing (ada_name, (char *) DECL_SOURCE_FILE (decl));\n+      ada_name = Name_Buffer;\n+    }\n+\n+  return (const char *) ada_name;\n+}\n+\n+/* Expands GNAT-specific GCC tree nodes.  The only ones we support\n+   here are  and NULL_EXPR.  */\n+\n+static rtx\n+gnat_expand_expr (tree exp, rtx target, enum machine_mode tmode,\n+\t\t  int modifier, rtx *alt_rtl)\n+{\n+  tree type = TREE_TYPE (exp);\n+  tree new;\n+\n+  /* Update EXP to be the new expression to expand.  */\n+  switch (TREE_CODE (exp))\n+    {\n+#if 0\n+    case ALLOCATE_EXPR:\n+      return\n+\tallocate_dynamic_stack_space\n+\t  (expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, TYPE_MODE (sizetype),\n+\t\t\tEXPAND_NORMAL),\n+\t   NULL_RTX, tree_low_cst (TREE_OPERAND (exp, 1), 1));\n+#endif\n+\n+    case UNCONSTRAINED_ARRAY_REF:\n+      /* If we are evaluating just for side-effects, just evaluate our\n+\t operand.  Otherwise, abort since this code should never appear\n+\t in a tree to be evaluated (objects aren't unconstrained).  */\n+      if (target == const0_rtx || TREE_CODE (type) == VOID_TYPE)\n+\treturn expand_expr (TREE_OPERAND (exp, 0), const0_rtx,\n+\t\t\t    VOIDmode, modifier);\n+\n+      /* ... fall through ... */\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return expand_expr_real (new, target, tmode, modifier, alt_rtl);\n+}\n+\n+/* Do nothing (return the tree node passed).  */\n+\n+static tree\n+gnat_return_tree (tree t)\n+{\n+  return t;\n+}\n+\n+/* Return true if type A catches type B. Callback for flow analysis from\n+   the exception handling part of the back-end.  */\n+\n+static int\n+gnat_eh_type_covers (tree a, tree b)\n+{\n+  /* a catches b if they represent the same exception id or if a\n+     is an \"others\".\n+\n+     ??? integer_zero_node for \"others\" is hardwired in too many places\n+     currently.  */\n+  return (a == b || a == integer_zero_node);\n+}\n+\f\n+/* Get the alias set corresponding to a type or expression.  */\n+\n+static alias_set_type\n+gnat_get_alias_set (tree type)\n+{\n+  /* If this is a padding type, use the type of the first field.  */\n+  if (TREE_CODE (type) == RECORD_TYPE\n+      && TYPE_IS_PADDING_P (type))\n+    return get_alias_set (TREE_TYPE (TYPE_FIELDS (type)));\n+\n+  /* If the type is an unconstrained array, use the type of the\n+     self-referential array we make.  */\n+  else if (TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)\n+    return\n+      get_alias_set (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (type)))));\n+\n+  /* If the type can alias any other types, return the alias set 0.  */\n+  else if (TYPE_P (type)\n+\t   && TYPE_UNIVERSAL_ALIASING_P (TYPE_MAIN_VARIANT (type)))\n+    return 0;\n+\n+  return -1;\n+}\n+\n+/* GNU_TYPE is a type.  Return its maximum size in bytes, if known,\n+   as a constant when possible.  */\n+\n+static tree\n+gnat_type_max_size (const_tree gnu_type)\n+{\n+  /* First see what we can get from TYPE_SIZE_UNIT, which might not\n+     be constant even for simple expressions if it has already been\n+     elaborated and possibly replaced by a VAR_DECL.  */\n+  tree max_unitsize = max_size (TYPE_SIZE_UNIT (gnu_type), true);\n+\n+  /* If we don't have a constant, see what we can get from TYPE_ADA_SIZE,\n+     which should stay untouched.  */\n+  if (!host_integerp (max_unitsize, 1)\n+      && (TREE_CODE (gnu_type) == RECORD_TYPE\n+\t  || TREE_CODE (gnu_type) == UNION_TYPE\n+\t  || TREE_CODE (gnu_type) == QUAL_UNION_TYPE)\n+      && TYPE_ADA_SIZE (gnu_type))\n+    {\n+      tree max_adasize = max_size (TYPE_ADA_SIZE (gnu_type), true);\n+\n+      /* If we have succeeded in finding a constant, round it up to the\n+\t type's alignment and return the result in units.  */\n+      if (host_integerp (max_adasize, 1))\n+\tmax_unitsize\n+\t  = size_binop (CEIL_DIV_EXPR,\n+\t\t\tround_up (max_adasize, TYPE_ALIGN (gnu_type)),\n+\t\t\tbitsize_unit_node);\n+    }\n+\n+  return max_unitsize;\n+}\n+\n+/* GNU_TYPE is a type. Determine if it should be passed by reference by\n+   default.  */\n+\n+bool\n+default_pass_by_ref (tree gnu_type)\n+{\n+  /* We pass aggregates by reference if they are sufficiently large.  The\n+     choice of constant here is somewhat arbitrary.  We also pass by\n+     reference if the target machine would either pass or return by\n+     reference.  Strictly speaking, we need only check the return if this\n+     is an In Out parameter, but it's probably best to err on the side of\n+     passing more things by reference.  */\n+\n+  if (pass_by_reference (NULL, TYPE_MODE (gnu_type), gnu_type, 1))\n+    return true;\n+\n+  if (targetm.calls.return_in_memory (gnu_type, NULL_TREE))\n+    return true;\n+\n+  if (AGGREGATE_TYPE_P (gnu_type)\n+      && (!host_integerp (TYPE_SIZE (gnu_type), 1)\n+\t  || 0 < compare_tree_int (TYPE_SIZE (gnu_type),\n+\t\t\t\t   8 * TYPE_ALIGN (gnu_type))))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* GNU_TYPE is the type of a subprogram parameter.  Determine from the type if\n+   it should be passed by reference. */\n+\n+bool\n+must_pass_by_ref (tree gnu_type)\n+{\n+  /* We pass only unconstrained objects, those required by the language\n+     to be passed by reference, and objects of variable size.  The latter\n+     is more efficient, avoids problems with variable size temporaries,\n+     and does not produce compatibility problems with C, since C does\n+     not have such objects.  */\n+  return (TREE_CODE (gnu_type) == UNCONSTRAINED_ARRAY_TYPE\n+\t  || (AGGREGATE_TYPE_P (gnu_type) && TYPE_BY_REFERENCE_P (gnu_type))\n+\t  || (TYPE_SIZE (gnu_type)\n+\t      && TREE_CODE (TYPE_SIZE (gnu_type)) != INTEGER_CST));\n+}\n+\n+/* This function is called by the front end to enumerate all the supported\n+   modes for the machine.  We pass a function which is called back with\n+   the following integer parameters:\n+\n+   FLOAT_P\tnonzero if this represents a floating-point mode\n+   COMPLEX_P\tnonzero is this represents a complex mode\n+   COUNT\tcount of number of items, nonzero for vector mode\n+   PRECISION\tnumber of bits in data representation\n+   MANTISSA\tnumber of bits in mantissa, if FP and known, else zero.\n+   SIZE\t\tnumber of bits used to store data\n+   ALIGN\tnumber of bits to which mode is aligned.  */\n+\n+void\n+enumerate_modes (void (*f) (int, int, int, int, int, int, unsigned int))\n+{\n+  enum machine_mode i;\n+\n+  for (i = 0; i < NUM_MACHINE_MODES; i++)\n+    {\n+      enum machine_mode j;\n+      bool float_p = 0;\n+      bool complex_p = 0;\n+      bool vector_p = 0;\n+      bool skip_p = 0;\n+      int mantissa = 0;\n+      enum machine_mode inner_mode = i;\n+\n+      switch (GET_MODE_CLASS (i))\n+\t{\n+\tcase MODE_INT:\n+\t  break;\n+\tcase MODE_FLOAT:\n+\t  float_p = 1;\n+\t  break;\n+\tcase MODE_COMPLEX_INT:\n+\t  complex_p = 1;\n+\t  inner_mode = GET_MODE_INNER (i);\n+\t  break;\n+\tcase MODE_COMPLEX_FLOAT:\n+\t  float_p = 1;\n+\t  complex_p = 1;\n+\t  inner_mode = GET_MODE_INNER (i);\n+\t  break;\n+\tcase MODE_VECTOR_INT:\n+\t  vector_p = 1;\n+\t  inner_mode = GET_MODE_INNER (i);\n+\t  break;\n+\tcase MODE_VECTOR_FLOAT:\n+\t  float_p = 1;\n+\t  vector_p = 1;\n+\t  inner_mode = GET_MODE_INNER (i);\n+\t  break;\n+\tdefault:\n+\t  skip_p = 1;\n+\t}\n+\n+      /* Skip this mode if it's one the front end doesn't need to know about\n+\t (e.g., the CC modes) or if there is no add insn for that mode (or\n+\t any wider mode), meaning it is not supported by the hardware.  If\n+\t this a complex or vector mode, we care about the inner mode.  */\n+      for (j = inner_mode; j != VOIDmode; j = GET_MODE_WIDER_MODE (j))\n+\tif (optab_handler (add_optab, j)->insn_code != CODE_FOR_nothing)\n+\t  break;\n+\n+      if (float_p)\n+\t{\n+\t  const struct real_format *fmt = REAL_MODE_FORMAT (inner_mode);\n+\n+\t  mantissa = fmt->p;\n+\t}\n+\n+      if (!skip_p && j != VOIDmode)\n+\t(*f) (float_p, complex_p, vector_p ? GET_MODE_NUNITS (i) : 0,\n+\t      GET_MODE_BITSIZE (i), mantissa,\n+\t      GET_MODE_SIZE (i) * BITS_PER_UNIT, GET_MODE_ALIGNMENT (i));\n+    }\n+}\n+\n+int\n+fp_prec_to_size (int prec)\n+{\n+  enum machine_mode mode;\n+\n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    if (GET_MODE_PRECISION (mode) == prec)\n+      return GET_MODE_BITSIZE (mode);\n+\n+  gcc_unreachable ();\n+}\n+\n+int\n+fp_size_to_prec (int size)\n+{\n+  enum machine_mode mode;\n+\n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    if (GET_MODE_BITSIZE (mode) == size)\n+      return GET_MODE_PRECISION (mode);\n+\n+  gcc_unreachable ();\n+}"}, {"sha": "c4e3299667dabe533c0bda7758ff471dfc3de1cf", "filename": "gcc/ada/gcc-interface/targtyps.c", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Ftargtyps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Ftargtyps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftargtyps.c?ref=a1ab4c317abfd045fe0619b455a31e19f910f7e7", "patch": "@@ -0,0 +1,230 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                            T A R G T Y P S                               *\n+ *                                                                          *\n+ *                                  Body                                    *\n+ *                                                                          *\n+ *          Copyright (C) 1992-2007, Free Software Foundation, Inc.         *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, *\n+ * Boston, MA 02110-1301, USA.                                              *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* Functions for retrieving target types. See Ada package Get_Targ */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"real.h\"\n+#include \"rtl.h\"\n+#include \"ada.h\"\n+#include \"types.h\"\n+#include \"atree.h\"\n+#include \"elists.h\"\n+#include \"namet.h\"\n+#include \"nlists.h\"\n+#include \"snames.h\"\n+#include \"stringt.h\"\n+#include \"uintp.h\"\n+#include \"urealp.h\"\n+#include \"fe.h\"\n+#include \"sinfo.h\"\n+#include \"einfo.h\"\n+#include \"ada-tree.h\"\n+#include \"gigi.h\"\n+\n+/* If we don't have a specific size for Ada's equivalent of `long', use that\n+   of C.  */\n+#ifndef ADA_LONG_TYPE_SIZE\n+#define ADA_LONG_TYPE_SIZE LONG_TYPE_SIZE\n+#endif\n+\n+#ifndef WIDEST_HARDWARE_FP_SIZE\n+#define WIDEST_HARDWARE_FP_SIZE LONG_DOUBLE_TYPE_SIZE\n+#endif\n+\n+/* The following provide a functional interface for the front end Ada code\n+   to determine the sizes that are used for various C types. */\n+\n+Pos\n+get_target_bits_per_unit (void)\n+{\n+  return BITS_PER_UNIT;\n+}\n+\n+Pos\n+get_target_bits_per_word (void)\n+{\n+  return BITS_PER_WORD;\n+}\n+\n+Pos\n+get_target_char_size (void)\n+{\n+  return CHAR_TYPE_SIZE;\n+}\n+\n+Pos\n+get_target_wchar_t_size (void)\n+{\n+  /* We never want wide characters less than \"short\" in Ada.  */\n+  return MAX (SHORT_TYPE_SIZE, WCHAR_TYPE_SIZE);\n+}\n+\n+Pos\n+get_target_short_size (void)\n+{\n+  return SHORT_TYPE_SIZE;\n+}\n+\n+Pos\n+get_target_int_size (void)\n+{\n+  return INT_TYPE_SIZE;\n+}\n+\n+Pos\n+get_target_long_size (void)\n+{\n+  return ADA_LONG_TYPE_SIZE;\n+}\n+\n+Pos\n+get_target_long_long_size (void)\n+{\n+  return LONG_LONG_TYPE_SIZE;\n+}\n+\n+Pos\n+get_target_float_size (void)\n+{\n+  return fp_prec_to_size (FLOAT_TYPE_SIZE);\n+}\n+\n+Pos\n+get_target_double_size (void)\n+{\n+  return fp_prec_to_size (DOUBLE_TYPE_SIZE);\n+}\n+\n+Pos\n+get_target_long_double_size (void)\n+{\n+  return fp_prec_to_size (WIDEST_HARDWARE_FP_SIZE);\n+}\n+\n+\n+Pos\n+get_target_pointer_size (void)\n+{\n+  return POINTER_SIZE;\n+}\n+\n+/* Alignment related values, mapped to attributes for functional and\n+   documentation purposes.  */\n+\n+/* Standard'Maximum_Default_Alignment.  Maximum alignment that the compiler\n+   might choose by default for a type or object.\n+\n+   Stricter alignment requests trigger gigi's aligning_type circuitry for\n+   stack objects or objects allocated by the default allocator.  */\n+\n+Pos\n+get_target_maximum_default_alignment (void)\n+{\n+  return BIGGEST_ALIGNMENT / BITS_PER_UNIT;\n+}\n+\n+/* Standard'Default_Allocator_Alignment.  Alignment guaranteed to be honored\n+   by the default allocator (System.Memory.Alloc or malloc if we have no\n+   run-time library at hand).\n+\n+   Stricter alignment requests trigger gigi's aligning_type circuitry for\n+   objects allocated by the default allocator.  */\n+\n+Pos\n+get_target_default_allocator_alignment (void)\n+{\n+  /* ??? Need a way to get info about __gnat_malloc from here (whether\n+     it is handy and what alignment it honors).  */\n+\n+  return MALLOC_ABI_ALIGNMENT / BITS_PER_UNIT;\n+}\n+\n+/* Standard'Maximum_Allowed_Alignment.  Maximum alignment that we may\n+   accept for any type or object.  */\n+\n+#ifndef MAX_OFILE_ALIGNMENT\n+#define MAX_OFILE_ALIGNMENT BIGGEST_ALIGNMENT\n+#endif\n+\n+Pos\n+get_target_maximum_allowed_alignment (void)\n+{\n+  return MAX_OFILE_ALIGNMENT / BITS_PER_UNIT;\n+}\n+\n+/* Standard'Maximum_Alignment.  The single attribute initially made\n+   available, now a synonym of Standard'Maximum_Default_Alignment.  */\n+\n+Pos\n+get_target_maximum_alignment (void)\n+{\n+  return get_target_maximum_default_alignment ();\n+}\n+\n+#ifndef FLOAT_WORDS_BIG_ENDIAN\n+#define FLOAT_WORDS_BIG_ENDIAN WORDS_BIG_ENDIAN\n+#endif\n+\n+Nat\n+get_float_words_be (void)\n+{\n+  return FLOAT_WORDS_BIG_ENDIAN;\n+}\n+\n+Nat\n+get_words_be (void)\n+{\n+  return WORDS_BIG_ENDIAN;\n+}\n+\n+Nat\n+get_bytes_be (void)\n+{\n+  return BYTES_BIG_ENDIAN;\n+}\n+\n+Nat\n+get_bits_be (void)\n+{\n+  return BITS_BIG_ENDIAN;\n+}\n+\n+Nat\n+get_strict_alignment (void)\n+{\n+  return STRICT_ALIGNMENT;\n+}"}, {"sha": "abc71f5e53ef45326e6463e9c1c21d04c097d4de", "filename": "gcc/ada/gcc-interface/trans.c", "status": "added", "additions": 7091, "deletions": 0, "changes": 7091, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=a1ab4c317abfd045fe0619b455a31e19f910f7e7"}, {"sha": "4188d38831e06f587df02c045e3c90e1b70bb24a", "filename": "gcc/ada/gcc-interface/utils.c", "status": "added", "additions": 4895, "deletions": 0, "changes": 4895, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=a1ab4c317abfd045fe0619b455a31e19f910f7e7"}, {"sha": "300fbd37d01d21517512d2a89f0365cc2a27f708", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "added", "additions": 2219, "deletions": 0, "changes": 2219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ab4c317abfd045fe0619b455a31e19f910f7e7/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=a1ab4c317abfd045fe0619b455a31e19f910f7e7", "patch": "@@ -0,0 +1,2219 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                               U T I L S 2                                *\n+ *                                                                          *\n+ *                          C Implementation File                           *\n+ *                                                                          *\n+ *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have received a copy of the GNU General   *\n+ * Public License along with GCC; see the file COPYING3.  If not see        *\n+ * <http://www.gnu.org/licenses/>.                                          *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"ggc.h\"\n+#include \"flags.h\"\n+#include \"output.h\"\n+#include \"ada.h\"\n+#include \"types.h\"\n+#include \"atree.h\"\n+#include \"stringt.h\"\n+#include \"namet.h\"\n+#include \"uintp.h\"\n+#include \"fe.h\"\n+#include \"elists.h\"\n+#include \"nlists.h\"\n+#include \"sinfo.h\"\n+#include \"einfo.h\"\n+#include \"ada-tree.h\"\n+#include \"gigi.h\"\n+\n+static tree find_common_type (tree, tree);\n+static bool contains_save_expr_p (tree);\n+static tree contains_null_expr (tree);\n+static tree compare_arrays (tree, tree, tree);\n+static tree nonbinary_modular_operation (enum tree_code, tree, tree, tree);\n+static tree build_simple_component_ref (tree, tree, tree, bool);\n+\f\n+/* Prepare expr to be an argument of a TRUTH_NOT_EXPR or other logical\n+   operation.\n+\n+   This preparation consists of taking the ordinary representation of\n+   an expression expr and producing a valid tree boolean expression\n+   describing whether expr is nonzero. We could simply always do\n+\n+      build_binary_op (NE_EXPR, expr, integer_zero_node, 1),\n+\n+   but we optimize comparisons, &&, ||, and !.\n+\n+   The resulting type should always be the same as the input type.\n+   This function is simpler than the corresponding C version since\n+   the only possible operands will be things of Boolean type.  */\n+\n+tree\n+gnat_truthvalue_conversion (tree expr)\n+{\n+  tree type = TREE_TYPE (expr);\n+\n+  switch (TREE_CODE (expr))\n+    {\n+    case EQ_EXPR:  case NE_EXPR: case LE_EXPR: case GE_EXPR:\n+    case LT_EXPR:  case GT_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_OR_EXPR:\n+    case TRUTH_XOR_EXPR:\n+    case ERROR_MARK:\n+      return expr;\n+\n+    case INTEGER_CST:\n+      return (integer_zerop (expr)\n+\t      ? build_int_cst (type, 0)\n+\t      : build_int_cst (type, 1));\n+\n+    case REAL_CST:\n+      return (real_zerop (expr)\n+\t      ? fold_convert (type, integer_zero_node)\n+\t      : fold_convert (type, integer_one_node));\n+\n+    case COND_EXPR:\n+      /* Distribute the conversion into the arms of a COND_EXPR.  */\n+      {\n+\ttree arg1 = gnat_truthvalue_conversion (TREE_OPERAND (expr, 1));\n+\ttree arg2 = gnat_truthvalue_conversion (TREE_OPERAND (expr, 2));\n+\treturn fold_build3 (COND_EXPR, type, TREE_OPERAND (expr, 0),\n+\t\t\t    arg1, arg2);\n+      }\n+\n+    default:\n+      return build_binary_op (NE_EXPR, type, expr,\n+\t\t\t      fold_convert (type, integer_zero_node));\n+    }\n+}\n+\f\n+/* Return the base type of TYPE.  */\n+\n+tree\n+get_base_type (tree type)\n+{\n+  if (TREE_CODE (type) == RECORD_TYPE\n+      && TYPE_JUSTIFIED_MODULAR_P (type))\n+    type = TREE_TYPE (TYPE_FIELDS (type));\n+\n+  while (TREE_TYPE (type)\n+\t && (TREE_CODE (type) == INTEGER_TYPE\n+\t     || TREE_CODE (type) == REAL_TYPE))\n+    type = TREE_TYPE (type);\n+\n+  return type;\n+}\n+\f\n+/* EXP is a GCC tree representing an address.  See if we can find how\n+   strictly the object at that address is aligned.   Return that alignment\n+   in bits.  If we don't know anything about the alignment, return 0.  */\n+\n+unsigned int\n+known_alignment (tree exp)\n+{\n+  unsigned int this_alignment;\n+  unsigned int lhs, rhs;\n+\n+  switch (TREE_CODE (exp))\n+    {\n+    CASE_CONVERT:\n+    case VIEW_CONVERT_EXPR:\n+    case NON_LVALUE_EXPR:\n+      /* Conversions between pointers and integers don't change the alignment\n+\t of the underlying object.  */\n+      this_alignment = known_alignment (TREE_OPERAND (exp, 0));\n+      break;\n+\n+    case COMPOUND_EXPR:\n+      /* The value of a COMPOUND_EXPR is that of it's second operand.  */\n+      this_alignment = known_alignment (TREE_OPERAND (exp, 1));\n+      break;\n+\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      /* If two address are added, the alignment of the result is the\n+\t minimum of the two alignments.  */\n+      lhs = known_alignment (TREE_OPERAND (exp, 0));\n+      rhs = known_alignment (TREE_OPERAND (exp, 1));\n+      this_alignment = MIN (lhs, rhs);\n+      break;\n+\n+    case POINTER_PLUS_EXPR:\n+      lhs = known_alignment (TREE_OPERAND (exp, 0));\n+      rhs = known_alignment (TREE_OPERAND (exp, 1));\n+      /* If we don't know the alignment of the offset, we assume that\n+\t of the base.  */\n+      if (rhs == 0)\n+\tthis_alignment = lhs;\n+      else\n+\tthis_alignment = MIN (lhs, rhs);\n+      break;\n+\n+    case COND_EXPR:\n+      /* If there is a choice between two values, use the smallest one.  */\n+      lhs = known_alignment (TREE_OPERAND (exp, 1));\n+      rhs = known_alignment (TREE_OPERAND (exp, 2));\n+      this_alignment = MIN (lhs, rhs);\n+      break;\n+\n+    case INTEGER_CST:\n+      {\n+\tunsigned HOST_WIDE_INT c = TREE_INT_CST_LOW (exp);\n+\t/* The first part of this represents the lowest bit in the constant,\n+\t   but it is originally in bytes, not bits.  */\n+\tthis_alignment = MIN (BITS_PER_UNIT * (c & -c), BIGGEST_ALIGNMENT);\n+      }\n+      break;\n+\n+    case MULT_EXPR:\n+      /* If we know the alignment of just one side, use it.  Otherwise,\n+\t use the product of the alignments.  */\n+      lhs = known_alignment (TREE_OPERAND (exp, 0));\n+      rhs = known_alignment (TREE_OPERAND (exp, 1));\n+\n+      if (lhs == 0)\n+\tthis_alignment = rhs;\n+      else if (rhs == 0)\n+\tthis_alignment = lhs;\n+      else\n+\tthis_alignment = MIN (lhs * rhs, BIGGEST_ALIGNMENT);\n+      break;\n+\n+    case BIT_AND_EXPR:\n+      /* A bit-and expression is as aligned as the maximum alignment of the\n+\t operands.  We typically get here for a complex lhs and a constant\n+\t negative power of two on the rhs to force an explicit alignment, so\n+\t don't bother looking at the lhs.  */\n+      this_alignment = known_alignment (TREE_OPERAND (exp, 1));\n+      break;\n+\n+    case ADDR_EXPR:\n+      this_alignment = expr_align (TREE_OPERAND (exp, 0));\n+      break;\n+\n+    default:\n+      /* For other pointer expressions, we assume that the pointed-to object\n+\t is at least as aligned as the pointed-to type.  Beware that we can\n+\t have a dummy type here (e.g. a Taft Amendment type), for which the\n+\t alignment is meaningless and should be ignored.  */\n+      if (POINTER_TYPE_P (TREE_TYPE (exp))\n+\t  && !TYPE_IS_DUMMY_P (TREE_TYPE (TREE_TYPE (exp))))\n+\tthis_alignment = TYPE_ALIGN (TREE_TYPE (TREE_TYPE (exp)));\n+      else\n+\tthis_alignment = 0;\n+      break;\n+    }\n+\n+  return this_alignment;\n+}\n+\f\n+/* We have a comparison or assignment operation on two types, T1 and T2, which\n+   are either both array types or both record types.  T1 is assumed to be for\n+   the left hand side operand, and T2 for the right hand side.  Return the\n+   type that both operands should be converted to for the operation, if any.\n+   Otherwise return zero.  */\n+\n+static tree\n+find_common_type (tree t1, tree t2)\n+{\n+  /* ??? As of today, various constructs lead here with types of different\n+     sizes even when both constants (e.g. tagged types, packable vs regular\n+     component types, padded vs unpadded types, ...).  While some of these\n+     would better be handled upstream (types should be made consistent before\n+     calling into build_binary_op), some others are really expected and we\n+     have to be careful.  */\n+\n+  /* We must prevent writing more than what the target may hold if this is for\n+     an assignment and the case of tagged types is handled in build_binary_op\n+     so use the lhs type if it is known to be smaller, or of constant size and\n+     the rhs type is not, whatever the modes.  We also force t1 in case of\n+     constant size equality to minimize occurrences of view conversions on the\n+     lhs of assignments.  */\n+  if (TREE_CONSTANT (TYPE_SIZE (t1))\n+      && (!TREE_CONSTANT (TYPE_SIZE (t2))\n+          || !tree_int_cst_lt (TYPE_SIZE (t2), TYPE_SIZE (t1))))\n+    return t1;\n+\n+  /* Otherwise, if the lhs type is non-BLKmode, use it.  Note that we know\n+     that we will not have any alignment problems since, if we did, the\n+     non-BLKmode type could not have been used.  */\n+  if (TYPE_MODE (t1) != BLKmode)\n+    return t1;\n+\n+  /* If the rhs type is of constant size, use it whatever the modes.  At\n+     this point it is known to be smaller, or of constant size and the\n+     lhs type is not.  */\n+  if (TREE_CONSTANT (TYPE_SIZE (t2)))\n+    return t2;\n+\n+  /* Otherwise, if the rhs type is non-BLKmode, use it.  */\n+  if (TYPE_MODE (t2) != BLKmode)\n+    return t2;\n+\n+  /* In this case, both types have variable size and BLKmode.  It's\n+     probably best to leave the \"type mismatch\" because changing it\n+     could cause a bad self-referential reference.  */\n+  return NULL_TREE;\n+}\n+\f\n+/* See if EXP contains a SAVE_EXPR in a position where we would\n+   normally put it.\n+\n+   ??? This is a real kludge, but is probably the best approach short\n+   of some very general solution.  */\n+\n+static bool\n+contains_save_expr_p (tree exp)\n+{\n+  switch (TREE_CODE (exp))\n+    {\n+    case SAVE_EXPR:\n+      return true;\n+\n+    case ADDR_EXPR:  case INDIRECT_REF:\n+    case COMPONENT_REF:\n+    CASE_CONVERT: case VIEW_CONVERT_EXPR:\n+      return contains_save_expr_p (TREE_OPERAND (exp, 0));\n+\n+    case CONSTRUCTOR:\n+      {\n+\ttree value;\n+\tunsigned HOST_WIDE_INT ix;\n+\n+\tFOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (exp), ix, value)\n+\t  if (contains_save_expr_p (value))\n+\t    return true;\n+\treturn false;\n+      }\n+\n+    default:\n+      return false;\n+    }\n+}\n+\f\n+/* See if EXP contains a NULL_EXPR in an expression we use for sizes. Return\n+   it if so.  This is used to detect types whose sizes involve computations\n+   that are known to raise Constraint_Error.  */\n+\n+static tree\n+contains_null_expr (tree exp)\n+{\n+  tree tem;\n+\n+  if (TREE_CODE (exp) == NULL_EXPR)\n+    return exp;\n+\n+  switch (TREE_CODE_CLASS (TREE_CODE (exp)))\n+    {\n+    case tcc_unary:\n+      return contains_null_expr (TREE_OPERAND (exp, 0));\n+\n+    case tcc_comparison:\n+    case tcc_binary:\n+      tem = contains_null_expr (TREE_OPERAND (exp, 0));\n+      if (tem)\n+\treturn tem;\n+\n+      return contains_null_expr (TREE_OPERAND (exp, 1));\n+\n+    case tcc_expression:\n+      switch (TREE_CODE (exp))\n+\t{\n+\tcase SAVE_EXPR:\n+\t  return contains_null_expr (TREE_OPERAND (exp, 0));\n+\n+\tcase COND_EXPR:\n+\t  tem = contains_null_expr (TREE_OPERAND (exp, 0));\n+\t  if (tem)\n+\t    return tem;\n+\n+\t  tem = contains_null_expr (TREE_OPERAND (exp, 1));\n+\t  if (tem)\n+\t    return tem;\n+\n+\t  return contains_null_expr (TREE_OPERAND (exp, 2));\n+\n+\tdefault:\n+\t  return 0;\n+\t}\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\f\n+/* Return an expression tree representing an equality comparison of\n+   A1 and A2, two objects of ARRAY_TYPE.  The returned expression should\n+   be of type RESULT_TYPE\n+\n+   Two arrays are equal in one of two ways: (1) if both have zero length\n+   in some dimension (not necessarily the same dimension) or (2) if the\n+   lengths in each dimension are equal and the data is equal.  We perform the\n+   length tests in as efficient a manner as possible.  */\n+\n+static tree\n+compare_arrays (tree result_type, tree a1, tree a2)\n+{\n+  tree t1 = TREE_TYPE (a1);\n+  tree t2 = TREE_TYPE (a2);\n+  tree result = convert (result_type, integer_one_node);\n+  tree a1_is_null = convert (result_type, integer_zero_node);\n+  tree a2_is_null = convert (result_type, integer_zero_node);\n+  bool length_zero_p = false;\n+\n+  /* Process each dimension separately and compare the lengths.  If any\n+     dimension has a size known to be zero, set SIZE_ZERO_P to 1 to\n+     suppress the comparison of the data.  */\n+  while (TREE_CODE (t1) == ARRAY_TYPE && TREE_CODE (t2) == ARRAY_TYPE)\n+    {\n+      tree lb1 = TYPE_MIN_VALUE (TYPE_DOMAIN (t1));\n+      tree ub1 = TYPE_MAX_VALUE (TYPE_DOMAIN (t1));\n+      tree lb2 = TYPE_MIN_VALUE (TYPE_DOMAIN (t2));\n+      tree ub2 = TYPE_MAX_VALUE (TYPE_DOMAIN (t2));\n+      tree bt = get_base_type (TREE_TYPE (lb1));\n+      tree length1 = fold_build2 (MINUS_EXPR, bt, ub1, lb1);\n+      tree length2 = fold_build2 (MINUS_EXPR, bt, ub2, lb2);\n+      tree nbt;\n+      tree tem;\n+      tree comparison, this_a1_is_null, this_a2_is_null;\n+\n+      /* If the length of the first array is a constant, swap our operands\n+\t unless the length of the second array is the constant zero.\n+\t Note that we have set the `length' values to the length - 1.  */\n+      if (TREE_CODE (length1) == INTEGER_CST\n+\t  && !integer_zerop (fold_build2 (PLUS_EXPR, bt, length2,\n+\t\t\t\t\t  convert (bt, integer_one_node))))\n+\t{\n+\t  tem = a1, a1 = a2, a2 = tem;\n+\t  tem = t1, t1 = t2, t2 = tem;\n+\t  tem = lb1, lb1 = lb2, lb2 = tem;\n+\t  tem = ub1, ub1 = ub2, ub2 = tem;\n+\t  tem = length1, length1 = length2, length2 = tem;\n+\t  tem = a1_is_null, a1_is_null = a2_is_null, a2_is_null = tem;\n+\t}\n+\n+      /* If the length of this dimension in the second array is the constant\n+\t zero, we can just go inside the original bounds for the first\n+\t array and see if last < first.  */\n+      if (integer_zerop (fold_build2 (PLUS_EXPR, bt, length2,\n+\t\t\t\t      convert (bt, integer_one_node))))\n+\t{\n+\t  tree ub = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n+\t  tree lb = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n+\n+\t  comparison = build_binary_op (LT_EXPR, result_type, ub, lb);\n+\t  comparison = SUBSTITUTE_PLACEHOLDER_IN_EXPR (comparison, a1);\n+\t  length1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (length1, a1);\n+\n+\t  length_zero_p = true;\n+\t  this_a1_is_null = comparison;\n+\t  this_a2_is_null = convert (result_type, integer_one_node);\n+\t}\n+\n+      /* If the length is some other constant value, we know that the\n+\t this dimension in the first array cannot be superflat, so we\n+\t can just use its length from the actual stored bounds.  */\n+      else if (TREE_CODE (length2) == INTEGER_CST)\n+\t{\n+\t  ub1 = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n+\t  lb1 = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t1)));\n+\t  ub2 = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t2)));\n+\t  lb2 = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (t2)));\n+\t  nbt = get_base_type (TREE_TYPE (ub1));\n+\n+\t  comparison\n+\t    = build_binary_op (EQ_EXPR, result_type,\n+\t\t\t       build_binary_op (MINUS_EXPR, nbt, ub1, lb1),\n+\t\t\t       build_binary_op (MINUS_EXPR, nbt, ub2, lb2));\n+\n+\t  /* Note that we know that UB2 and LB2 are constant and hence\n+\t     cannot contain a PLACEHOLDER_EXPR.  */\n+\n+\t  comparison = SUBSTITUTE_PLACEHOLDER_IN_EXPR (comparison, a1);\n+\t  length1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (length1, a1);\n+\n+\t  this_a1_is_null = build_binary_op (LT_EXPR, result_type, ub1, lb1);\n+\t  this_a2_is_null = convert (result_type, integer_zero_node);\n+\t}\n+\n+      /* Otherwise compare the computed lengths.  */\n+      else\n+\t{\n+\t  length1 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (length1, a1);\n+\t  length2 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (length2, a2);\n+\n+\t  comparison\n+\t    = build_binary_op (EQ_EXPR, result_type, length1, length2);\n+\n+\t  this_a1_is_null\n+\t    = build_binary_op (LT_EXPR, result_type, length1,\n+\t\t\t       convert (bt, integer_zero_node));\n+\t  this_a2_is_null\n+\t    = build_binary_op (LT_EXPR, result_type, length2,\n+\t\t\t       convert (bt, integer_zero_node));\n+\t}\n+\n+      result = build_binary_op (TRUTH_ANDIF_EXPR, result_type,\n+\t\t\t\tresult, comparison);\n+\n+      a1_is_null = build_binary_op (TRUTH_ORIF_EXPR, result_type,\n+\t\t\t\t    this_a1_is_null, a1_is_null);\n+      a2_is_null = build_binary_op (TRUTH_ORIF_EXPR, result_type,\n+\t\t\t\t    this_a2_is_null, a2_is_null);\n+\n+      t1 = TREE_TYPE (t1);\n+      t2 = TREE_TYPE (t2);\n+    }\n+\n+  /* Unless the size of some bound is known to be zero, compare the\n+     data in the array.  */\n+  if (!length_zero_p)\n+    {\n+      tree type = find_common_type (TREE_TYPE (a1), TREE_TYPE (a2));\n+\n+      if (type)\n+\ta1 = convert (type, a1), a2 = convert (type, a2);\n+\n+      result = build_binary_op (TRUTH_ANDIF_EXPR, result_type, result,\n+\t\t\t\tfold_build2 (EQ_EXPR, result_type, a1, a2));\n+\n+    }\n+\n+  /* The result is also true if both sizes are zero.  */\n+  result = build_binary_op (TRUTH_ORIF_EXPR, result_type,\n+\t\t\t    build_binary_op (TRUTH_ANDIF_EXPR, result_type,\n+\t\t\t\t\t     a1_is_null, a2_is_null),\n+\t\t\t    result);\n+\n+  /* If either operand contains SAVE_EXPRs, they have to be evaluated before\n+     starting the comparison above since the place it would be otherwise\n+     evaluated would be wrong.  */\n+\n+  if (contains_save_expr_p (a1))\n+    result = build2 (COMPOUND_EXPR, result_type, a1, result);\n+\n+  if (contains_save_expr_p (a2))\n+    result = build2 (COMPOUND_EXPR, result_type, a2, result);\n+\n+  return result;\n+}\n+\f\n+/* Compute the result of applying OP_CODE to LHS and RHS, where both are of\n+   type TYPE.  We know that TYPE is a modular type with a nonbinary\n+   modulus.  */\n+\n+static tree\n+nonbinary_modular_operation (enum tree_code op_code, tree type, tree lhs,\n+                             tree rhs)\n+{\n+  tree modulus = TYPE_MODULUS (type);\n+  unsigned int needed_precision = tree_floor_log2 (modulus) + 1;\n+  unsigned int precision;\n+  bool unsignedp = true;\n+  tree op_type = type;\n+  tree result;\n+\n+  /* If this is an addition of a constant, convert it to a subtraction\n+     of a constant since we can do that faster.  */\n+  if (op_code == PLUS_EXPR && TREE_CODE (rhs) == INTEGER_CST)\n+    {\n+      rhs = fold_build2 (MINUS_EXPR, type, modulus, rhs);\n+      op_code = MINUS_EXPR;\n+    }\n+\n+  /* For the logical operations, we only need PRECISION bits.  For\n+     addition and subtraction, we need one more and for multiplication we\n+     need twice as many.  But we never want to make a size smaller than\n+     our size. */\n+  if (op_code == PLUS_EXPR || op_code == MINUS_EXPR)\n+    needed_precision += 1;\n+  else if (op_code == MULT_EXPR)\n+    needed_precision *= 2;\n+\n+  precision = MAX (needed_precision, TYPE_PRECISION (op_type));\n+\n+  /* Unsigned will do for everything but subtraction.  */\n+  if (op_code == MINUS_EXPR)\n+    unsignedp = false;\n+\n+  /* If our type is the wrong signedness or isn't wide enough, make a new\n+     type and convert both our operands to it.  */\n+  if (TYPE_PRECISION (op_type) < precision\n+      || TYPE_UNSIGNED (op_type) != unsignedp)\n+    {\n+      /* Copy the node so we ensure it can be modified to make it modular.  */\n+      op_type = copy_node (gnat_type_for_size (precision, unsignedp));\n+      modulus = convert (op_type, modulus);\n+      SET_TYPE_MODULUS (op_type, modulus);\n+      TYPE_MODULAR_P (op_type) = 1;\n+      lhs = convert (op_type, lhs);\n+      rhs = convert (op_type, rhs);\n+    }\n+\n+  /* Do the operation, then we'll fix it up.  */\n+  result = fold_build2 (op_code, op_type, lhs, rhs);\n+\n+  /* For multiplication, we have no choice but to do a full modulus\n+     operation.  However, we want to do this in the narrowest\n+     possible size.  */\n+  if (op_code == MULT_EXPR)\n+    {\n+      tree div_type = copy_node (gnat_type_for_size (needed_precision, 1));\n+      modulus = convert (div_type, modulus);\n+      SET_TYPE_MODULUS (div_type, modulus);\n+      TYPE_MODULAR_P (div_type) = 1;\n+      result = convert (op_type,\n+\t\t\tfold_build2 (TRUNC_MOD_EXPR, div_type,\n+\t\t\t\t     convert (div_type, result), modulus));\n+    }\n+\n+  /* For subtraction, add the modulus back if we are negative.  */\n+  else if (op_code == MINUS_EXPR)\n+    {\n+      result = save_expr (result);\n+      result = fold_build3 (COND_EXPR, op_type,\n+\t\t\t    fold_build2 (LT_EXPR, integer_type_node, result,\n+\t\t\t\t\t convert (op_type, integer_zero_node)),\n+\t\t\t    fold_build2 (PLUS_EXPR, op_type, result, modulus),\n+\t\t\t    result);\n+    }\n+\n+  /* For the other operations, subtract the modulus if we are >= it.  */\n+  else\n+    {\n+      result = save_expr (result);\n+      result = fold_build3 (COND_EXPR, op_type,\n+\t\t\t    fold_build2 (GE_EXPR, integer_type_node,\n+\t\t\t\t\t result, modulus),\n+\t\t\t    fold_build2 (MINUS_EXPR, op_type,\n+\t\t\t\t\t result, modulus),\n+\t\t\t    result);\n+    }\n+\n+  return convert (type, result);\n+}\n+\f\n+/* Make a binary operation of kind OP_CODE.  RESULT_TYPE is the type\n+   desired for the result.  Usually the operation is to be performed\n+   in that type.  For MODIFY_EXPR and ARRAY_REF, RESULT_TYPE may be 0\n+   in which case the type to be used will be derived from the operands.\n+\n+   This function is very much unlike the ones for C and C++ since we\n+   have already done any type conversion and matching required.  All we\n+   have to do here is validate the work done by SEM and handle subtypes.  */\n+\n+tree\n+build_binary_op (enum tree_code op_code, tree result_type,\n+                 tree left_operand, tree right_operand)\n+{\n+  tree left_type  = TREE_TYPE (left_operand);\n+  tree right_type = TREE_TYPE (right_operand);\n+  tree left_base_type = get_base_type (left_type);\n+  tree right_base_type = get_base_type (right_type);\n+  tree operation_type = result_type;\n+  tree best_type = NULL_TREE;\n+  tree modulus, result;\n+  bool has_side_effects = false;\n+\n+  if (operation_type\n+      && TREE_CODE (operation_type) == RECORD_TYPE\n+      && TYPE_JUSTIFIED_MODULAR_P (operation_type))\n+    operation_type = TREE_TYPE (TYPE_FIELDS (operation_type));\n+\n+  if (operation_type\n+      && !AGGREGATE_TYPE_P (operation_type)\n+      && TYPE_EXTRA_SUBTYPE_P (operation_type))\n+    operation_type = get_base_type (operation_type);\n+\n+  modulus = (operation_type\n+\t     && TREE_CODE (operation_type) == INTEGER_TYPE\n+\t     && TYPE_MODULAR_P (operation_type)\n+\t     ? TYPE_MODULUS (operation_type) : NULL_TREE);\n+\n+  switch (op_code)\n+    {\n+    case MODIFY_EXPR:\n+      /* If there were integral or pointer conversions on the LHS, remove\n+\t them; we'll be putting them back below if needed.  Likewise for\n+\t conversions between array and record types, except for justified\n+\t modular types.  But don't do this if the right operand is not\n+\t BLKmode (for packed arrays) unless we are not changing the mode.  */\n+      while ((CONVERT_EXPR_P (left_operand)\n+\t      || TREE_CODE (left_operand) == VIEW_CONVERT_EXPR)\n+\t     && (((INTEGRAL_TYPE_P (left_type)\n+\t\t   || POINTER_TYPE_P (left_type))\n+\t\t  && (INTEGRAL_TYPE_P (TREE_TYPE\n+\t\t\t\t       (TREE_OPERAND (left_operand, 0)))\n+\t\t      || POINTER_TYPE_P (TREE_TYPE\n+\t\t\t\t\t (TREE_OPERAND (left_operand, 0)))))\n+\t\t || (((TREE_CODE (left_type) == RECORD_TYPE\n+\t\t       && !TYPE_JUSTIFIED_MODULAR_P (left_type))\n+\t\t      || TREE_CODE (left_type) == ARRAY_TYPE)\n+\t\t     && ((TREE_CODE (TREE_TYPE\n+\t\t\t\t     (TREE_OPERAND (left_operand, 0)))\n+\t\t\t  == RECORD_TYPE)\n+\t\t\t || (TREE_CODE (TREE_TYPE\n+\t\t\t\t\t(TREE_OPERAND (left_operand, 0)))\n+\t\t\t     == ARRAY_TYPE))\n+\t\t     && (TYPE_MODE (right_type) == BLKmode\n+\t\t\t || (TYPE_MODE (left_type)\n+\t\t\t     == TYPE_MODE (TREE_TYPE\n+\t\t\t\t\t   (TREE_OPERAND\n+\t\t\t\t\t    (left_operand, 0))))))))\n+\t{\n+\t  left_operand = TREE_OPERAND (left_operand, 0);\n+\t  left_type = TREE_TYPE (left_operand);\n+\t}\n+\n+      /* If a class-wide type may be involved, force use of the RHS type.  */\n+      if ((TREE_CODE (right_type) == RECORD_TYPE\n+\t   || TREE_CODE (right_type) == UNION_TYPE)\n+\t  && TYPE_ALIGN_OK (right_type))\n+\toperation_type = right_type;\n+\n+      /* If we are copying between padded objects with compatible types, use\n+\t the padded view of the objects, this is very likely more efficient.\n+\t Likewise for a padded that is assigned a constructor, in order to\n+\t avoid putting a VIEW_CONVERT_EXPR on the LHS.  But don't do this if\n+\t we wouldn't have actually copied anything.  */\n+      else if (TREE_CODE (left_type) == RECORD_TYPE\n+\t       && TYPE_IS_PADDING_P (left_type)\n+\t       && TREE_CONSTANT (TYPE_SIZE (left_type))\n+\t       && ((TREE_CODE (right_operand) == COMPONENT_REF\n+\t\t    && TREE_CODE (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n+\t\t       == RECORD_TYPE\n+\t\t    && TYPE_IS_PADDING_P\n+\t\t       (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n+\t\t    && gnat_types_compatible_p\n+\t\t\t(left_type,\n+\t\t\t TREE_TYPE (TREE_OPERAND (right_operand, 0))))\n+\t\t   || TREE_CODE (right_operand) == CONSTRUCTOR)\n+\t       && !integer_zerop (TYPE_SIZE (right_type)))\n+\toperation_type = left_type;\n+\n+      /* Find the best type to use for copying between aggregate types.  */\n+      else if (((TREE_CODE (left_type) == ARRAY_TYPE\n+\t\t && TREE_CODE (right_type) == ARRAY_TYPE)\n+\t\t|| (TREE_CODE (left_type) == RECORD_TYPE\n+\t\t    && TREE_CODE (right_type) == RECORD_TYPE))\n+\t       && (best_type = find_common_type (left_type, right_type)))\n+\toperation_type = best_type;\n+\n+      /* Otherwise use the LHS type.  */\n+      else if (!operation_type)\n+\toperation_type = left_type;\n+\n+      /* Ensure everything on the LHS is valid.  If we have a field reference,\n+\t strip anything that get_inner_reference can handle.  Then remove any\n+\t conversions between types having the same code and mode.  And mark\n+\t VIEW_CONVERT_EXPRs with TREE_ADDRESSABLE.  When done, we must have\n+\t either an INDIRECT_REF, a NULL_EXPR or a DECL node.  */\n+      result = left_operand;\n+      while (true)\n+\t{\n+\t  tree restype = TREE_TYPE (result);\n+\n+\t  if (TREE_CODE (result) == COMPONENT_REF\n+\t      || TREE_CODE (result) == ARRAY_REF\n+\t      || TREE_CODE (result) == ARRAY_RANGE_REF)\n+\t    while (handled_component_p (result))\n+\t      result = TREE_OPERAND (result, 0);\n+\t  else if (TREE_CODE (result) == REALPART_EXPR\n+\t\t   || TREE_CODE (result) == IMAGPART_EXPR\n+\t\t   || (CONVERT_EXPR_P (result)\n+\t\t       && (((TREE_CODE (restype)\n+\t\t\t     == TREE_CODE (TREE_TYPE\n+\t\t\t\t\t   (TREE_OPERAND (result, 0))))\n+\t\t\t     && (TYPE_MODE (TREE_TYPE\n+\t\t\t\t\t    (TREE_OPERAND (result, 0)))\n+\t\t\t\t == TYPE_MODE (restype)))\n+\t\t\t   || TYPE_ALIGN_OK (restype))))\n+\t    result = TREE_OPERAND (result, 0);\n+\t  else if (TREE_CODE (result) == VIEW_CONVERT_EXPR)\n+\t    {\n+\t      TREE_ADDRESSABLE (result) = 1;\n+\t      result = TREE_OPERAND (result, 0);\n+\t    }\n+\t  else\n+\t    break;\n+\t}\n+\n+      gcc_assert (TREE_CODE (result) == INDIRECT_REF\n+\t\t  || TREE_CODE (result) == NULL_EXPR\n+\t\t  || DECL_P (result));\n+\n+      /* Convert the right operand to the operation type unless it is\n+\t either already of the correct type or if the type involves a\n+\t placeholder, since the RHS may not have the same record type.  */\n+      if (operation_type != right_type\n+\t  && !CONTAINS_PLACEHOLDER_P (TYPE_SIZE (operation_type)))\n+\t{\n+\t  right_operand = convert (operation_type, right_operand);\n+\t  right_type = operation_type;\n+\t}\n+\n+      /* If the left operand is not of the same type as the operation\n+\t type, wrap it up in a VIEW_CONVERT_EXPR.  */\n+      if (left_type != operation_type)\n+\tleft_operand = unchecked_convert (operation_type, left_operand, false);\n+\n+      has_side_effects = true;\n+      modulus = NULL_TREE;\n+      break;\n+\n+    case ARRAY_REF:\n+      if (!operation_type)\n+\toperation_type = TREE_TYPE (left_type);\n+\n+      /* ... fall through ... */\n+\n+    case ARRAY_RANGE_REF:\n+      /* First look through conversion between type variants.  Note that\n+\t this changes neither the operation type nor the type domain.  */\n+      if (TREE_CODE (left_operand) == VIEW_CONVERT_EXPR\n+\t  && TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (left_operand, 0)))\n+\t     == TYPE_MAIN_VARIANT (left_type))\n+\t{\n+\t  left_operand = TREE_OPERAND (left_operand, 0);\n+\t  left_type = TREE_TYPE (left_operand);\n+\t}\n+\n+      /* Then convert the right operand to its base type.  This will\n+\t prevent unneeded signedness conversions when sizetype is wider than\n+\t integer.  */\n+      right_operand = convert (right_base_type, right_operand);\n+      right_operand = convert (TYPE_DOMAIN (left_type), right_operand);\n+\n+      if (!TREE_CONSTANT (right_operand)\n+\t  || !TREE_CONSTANT (TYPE_MIN_VALUE (right_type)))\n+\tgnat_mark_addressable (left_operand);\n+\n+      modulus = NULL_TREE;\n+      break;\n+\n+    case GE_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case LT_EXPR:\n+      gcc_assert (!POINTER_TYPE_P (left_type));\n+\n+      /* ... fall through ... */\n+\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+      /* If either operand is a NULL_EXPR, just return a new one.  */\n+      if (TREE_CODE (left_operand) == NULL_EXPR)\n+\treturn build2 (op_code, result_type,\n+\t\t       build1 (NULL_EXPR, integer_type_node,\n+\t\t\t       TREE_OPERAND (left_operand, 0)),\n+\t\t       integer_zero_node);\n+\n+      else if (TREE_CODE (right_operand) == NULL_EXPR)\n+\treturn build2 (op_code, result_type,\n+\t\t       build1 (NULL_EXPR, integer_type_node,\n+\t\t\t       TREE_OPERAND (right_operand, 0)),\n+\t\t       integer_zero_node);\n+\n+      /* If either object is a justified modular types, get the\n+\t fields from within.  */\n+      if (TREE_CODE (left_type) == RECORD_TYPE\n+\t  && TYPE_JUSTIFIED_MODULAR_P (left_type))\n+\t{\n+\t  left_operand = convert (TREE_TYPE (TYPE_FIELDS (left_type)),\n+\t\t\t\t  left_operand);\n+\t  left_type = TREE_TYPE (left_operand);\n+\t  left_base_type = get_base_type (left_type);\n+\t}\n+\n+      if (TREE_CODE (right_type) == RECORD_TYPE\n+\t  && TYPE_JUSTIFIED_MODULAR_P (right_type))\n+\t{\n+\t  right_operand = convert (TREE_TYPE (TYPE_FIELDS (right_type)),\n+\t\t\t\t  right_operand);\n+\t  right_type = TREE_TYPE (right_operand);\n+\t  right_base_type = get_base_type (right_type);\n+\t}\n+\n+      /* If both objects are arrays, compare them specially.  */\n+      if ((TREE_CODE (left_type) == ARRAY_TYPE\n+\t   || (TREE_CODE (left_type) == INTEGER_TYPE\n+\t       && TYPE_HAS_ACTUAL_BOUNDS_P (left_type)))\n+\t  && (TREE_CODE (right_type) == ARRAY_TYPE\n+\t      || (TREE_CODE (right_type) == INTEGER_TYPE\n+\t\t  && TYPE_HAS_ACTUAL_BOUNDS_P (right_type))))\n+\t{\n+\t  result = compare_arrays (result_type, left_operand, right_operand);\n+\n+\t  if (op_code == NE_EXPR)\n+\t    result = invert_truthvalue (result);\n+\t  else\n+\t    gcc_assert (op_code == EQ_EXPR);\n+\n+\t  return result;\n+\t}\n+\n+      /* Otherwise, the base types must be the same unless the objects are\n+\t fat pointers or records.  If we have records, use the best type and\n+\t convert both operands to that type.  */\n+      if (left_base_type != right_base_type)\n+\t{\n+\t  if (TYPE_FAT_POINTER_P (left_base_type)\n+\t      && TYPE_FAT_POINTER_P (right_base_type)\n+\t      && TYPE_MAIN_VARIANT (left_base_type)\n+\t\t == TYPE_MAIN_VARIANT (right_base_type))\n+\t    best_type = left_base_type;\n+\t  else if (TREE_CODE (left_base_type) == RECORD_TYPE\n+\t\t   && TREE_CODE (right_base_type) == RECORD_TYPE)\n+\t    {\n+\t      /* The only way these are permitted to be the same is if both\n+\t\t types have the same name.  In that case, one of them must\n+\t\t not be self-referential.  Use that one as the best type.\n+\t\t Even better is if one is of fixed size.  */\n+\t      gcc_assert (TYPE_NAME (left_base_type)\n+\t\t\t  && (TYPE_NAME (left_base_type)\n+\t\t\t      == TYPE_NAME (right_base_type)));\n+\n+\t      if (TREE_CONSTANT (TYPE_SIZE (left_base_type)))\n+\t\tbest_type = left_base_type;\n+\t      else if (TREE_CONSTANT (TYPE_SIZE (right_base_type)))\n+\t\tbest_type = right_base_type;\n+\t      else if (!CONTAINS_PLACEHOLDER_P (TYPE_SIZE (left_base_type)))\n+\t\tbest_type = left_base_type;\n+\t      else if (!CONTAINS_PLACEHOLDER_P (TYPE_SIZE (right_base_type)))\n+\t\tbest_type = right_base_type;\n+\t      else\n+\t\tgcc_unreachable ();\n+\t    }\n+\t  else\n+\t    gcc_unreachable ();\n+\n+\t  left_operand = convert (best_type, left_operand);\n+\t  right_operand = convert (best_type, right_operand);\n+\t}\n+\n+      /* If we are comparing a fat pointer against zero, we need to\n+\t just compare the data pointer.  */\n+      else if (TYPE_FAT_POINTER_P (left_base_type)\n+\t       && TREE_CODE (right_operand) == CONSTRUCTOR\n+\t       && integer_zerop (VEC_index (constructor_elt,\n+\t\t\t\t\t    CONSTRUCTOR_ELTS (right_operand),\n+\t\t\t\t\t    0)\n+\t\t\t\t ->value))\n+\t{\n+\t  right_operand = build_component_ref (left_operand, NULL_TREE,\n+\t\t\t\t\t       TYPE_FIELDS (left_base_type),\n+\t\t\t\t\t       false);\n+\t  left_operand = convert (TREE_TYPE (right_operand),\n+\t\t\t\t  integer_zero_node);\n+\t}\n+      else\n+\t{\n+\t  left_operand = convert (left_base_type, left_operand);\n+\t  right_operand = convert (right_base_type, right_operand);\n+\t}\n+\n+      modulus = NULL_TREE;\n+      break;\n+\n+    case PREINCREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+      /* In these, the result type and the left operand type should be the\n+\t same.  Do the operation in the base type of those and convert the\n+\t right operand (which is an integer) to that type.\n+\n+\t Note that these operations are only used in loop control where\n+\t we guarantee that no overflow can occur.  So nothing special need\n+\t be done for modular types.  */\n+\n+      gcc_assert (left_type == result_type);\n+      operation_type = get_base_type (result_type);\n+      left_operand = convert (operation_type, left_operand);\n+      right_operand = convert (operation_type, right_operand);\n+      has_side_effects = true;\n+      modulus = NULL_TREE;\n+      break;\n+\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case LROTATE_EXPR:\n+    case RROTATE_EXPR:\n+       /* The RHS of a shift can be any type.  Also, ignore any modulus\n+\t (we used to abort, but this is needed for unchecked conversion\n+\t to modular types).  Otherwise, processing is the same as normal.  */\n+      gcc_assert (operation_type == left_base_type);\n+      modulus = NULL_TREE;\n+      left_operand = convert (operation_type, left_operand);\n+      break;\n+\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_OR_EXPR:\n+    case TRUTH_XOR_EXPR:\n+      left_operand = gnat_truthvalue_conversion (left_operand);\n+      right_operand = gnat_truthvalue_conversion (right_operand);\n+      goto common;\n+\n+    case BIT_AND_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+      /* For binary modulus, if the inputs are in range, so are the\n+\t outputs.  */\n+      if (modulus && integer_pow2p (modulus))\n+\tmodulus = NULL_TREE;\n+\n+      goto common;\n+\n+    case COMPLEX_EXPR:\n+      gcc_assert (TREE_TYPE (result_type) == left_base_type\n+\t\t  && TREE_TYPE (result_type) == right_base_type);\n+      left_operand = convert (left_base_type, left_operand);\n+      right_operand = convert (right_base_type, right_operand);\n+      break;\n+\n+    case TRUNC_DIV_EXPR:   case TRUNC_MOD_EXPR:\n+    case CEIL_DIV_EXPR:    case CEIL_MOD_EXPR:\n+    case FLOOR_DIV_EXPR:   case FLOOR_MOD_EXPR:\n+    case ROUND_DIV_EXPR:   case ROUND_MOD_EXPR:\n+      /* These always produce results lower than either operand.  */\n+      modulus = NULL_TREE;\n+      goto common;\n+\n+    case POINTER_PLUS_EXPR:\n+      gcc_assert (operation_type == left_base_type\n+\t\t  && sizetype == right_base_type);\n+      left_operand = convert (operation_type, left_operand);\n+      right_operand = convert (sizetype, right_operand);\n+      break;\n+\n+    default:\n+    common:\n+      /* The result type should be the same as the base types of the\n+\t both operands (and they should be the same).  Convert\n+\t everything to the result type.  */\n+\n+      gcc_assert (operation_type == left_base_type\n+\t\t  && left_base_type == right_base_type);\n+      left_operand = convert (operation_type, left_operand);\n+      right_operand = convert (operation_type, right_operand);\n+    }\n+\n+  if (modulus && !integer_pow2p (modulus))\n+    {\n+      result = nonbinary_modular_operation (op_code, operation_type,\n+\t\t\t\t\t    left_operand, right_operand);\n+      modulus = NULL_TREE;\n+    }\n+  /* If either operand is a NULL_EXPR, just return a new one.  */\n+  else if (TREE_CODE (left_operand) == NULL_EXPR)\n+    return build1 (NULL_EXPR, operation_type, TREE_OPERAND (left_operand, 0));\n+  else if (TREE_CODE (right_operand) == NULL_EXPR)\n+    return build1 (NULL_EXPR, operation_type, TREE_OPERAND (right_operand, 0));\n+  else if (op_code == ARRAY_REF || op_code == ARRAY_RANGE_REF)\n+    result = fold (build4 (op_code, operation_type, left_operand,\n+\t\t\t   right_operand, NULL_TREE, NULL_TREE));\n+  else\n+    result\n+      = fold_build2 (op_code, operation_type, left_operand, right_operand);\n+\n+  TREE_SIDE_EFFECTS (result) |= has_side_effects;\n+  TREE_CONSTANT (result)\n+    |= (TREE_CONSTANT (left_operand) & TREE_CONSTANT (right_operand)\n+\t&& op_code != ARRAY_REF && op_code != ARRAY_RANGE_REF);\n+\n+  if ((op_code == ARRAY_REF || op_code == ARRAY_RANGE_REF)\n+      && TYPE_VOLATILE (operation_type))\n+    TREE_THIS_VOLATILE (result) = 1;\n+\n+  /* If we are working with modular types, perform the MOD operation\n+     if something above hasn't eliminated the need for it.  */\n+  if (modulus)\n+    result = fold_build2 (FLOOR_MOD_EXPR, operation_type, result,\n+\t\t\t  convert (operation_type, modulus));\n+\n+  if (result_type && result_type != operation_type)\n+    result = convert (result_type, result);\n+\n+  return result;\n+}\n+\f\n+/* Similar, but for unary operations.  */\n+\n+tree\n+build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n+{\n+  tree type = TREE_TYPE (operand);\n+  tree base_type = get_base_type (type);\n+  tree operation_type = result_type;\n+  tree result;\n+  bool side_effects = false;\n+\n+  if (operation_type\n+      && TREE_CODE (operation_type) == RECORD_TYPE\n+      && TYPE_JUSTIFIED_MODULAR_P (operation_type))\n+    operation_type = TREE_TYPE (TYPE_FIELDS (operation_type));\n+\n+  if (operation_type\n+      && !AGGREGATE_TYPE_P (operation_type)\n+      && TYPE_EXTRA_SUBTYPE_P (operation_type))\n+    operation_type = get_base_type (operation_type);\n+\n+  switch (op_code)\n+    {\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+      if (!operation_type)\n+\tresult_type = operation_type = TREE_TYPE (type);\n+      else\n+\tgcc_assert (result_type == TREE_TYPE (type));\n+\n+      result = fold_build1 (op_code, operation_type, operand);\n+      break;\n+\n+    case TRUTH_NOT_EXPR:\n+      gcc_assert (result_type == base_type);\n+      result = invert_truthvalue (gnat_truthvalue_conversion (operand));\n+      break;\n+\n+    case ATTR_ADDR_EXPR:\n+    case ADDR_EXPR:\n+      switch (TREE_CODE (operand))\n+\t{\n+\tcase INDIRECT_REF:\n+\tcase UNCONSTRAINED_ARRAY_REF:\n+\t  result = TREE_OPERAND (operand, 0);\n+\n+\t  /* Make sure the type here is a pointer, not a reference.\n+\t     GCC wants pointer types for function addresses.  */\n+\t  if (!result_type)\n+\t    result_type = build_pointer_type (type);\n+\n+\t  /* If the underlying object can alias everything, propagate the\n+\t     property since we are effectively retrieving the object.  */\n+\t  if (POINTER_TYPE_P (TREE_TYPE (result))\n+\t      && TYPE_REF_CAN_ALIAS_ALL (TREE_TYPE (result)))\n+\t    {\n+\t      if (TREE_CODE (result_type) == POINTER_TYPE\n+\t\t  && !TYPE_REF_CAN_ALIAS_ALL (result_type))\n+\t\tresult_type\n+\t\t  = build_pointer_type_for_mode (TREE_TYPE (result_type),\n+\t\t\t\t\t\t TYPE_MODE (result_type),\n+\t\t\t\t\t\t true);\n+\t      else if (TREE_CODE (result_type) == REFERENCE_TYPE\n+\t\t       && !TYPE_REF_CAN_ALIAS_ALL (result_type))\n+\t        result_type\n+\t\t  = build_reference_type_for_mode (TREE_TYPE (result_type),\n+\t\t\t\t\t\t   TYPE_MODE (result_type),\n+\t\t\t\t\t\t   true);\n+\t    }\n+\t  break;\n+\n+\tcase NULL_EXPR:\n+\t  result = operand;\n+\t  TREE_TYPE (result) = type = build_pointer_type (type);\n+\t  break;\n+\n+\tcase ARRAY_REF:\n+\tcase ARRAY_RANGE_REF:\n+\tcase COMPONENT_REF:\n+\tcase BIT_FIELD_REF:\n+\t    /* If this is for 'Address, find the address of the prefix and\n+\t       add the offset to the field.  Otherwise, do this the normal\n+\t       way.  */\n+\t  if (op_code == ATTR_ADDR_EXPR)\n+\t    {\n+\t      HOST_WIDE_INT bitsize;\n+\t      HOST_WIDE_INT bitpos;\n+\t      tree offset, inner;\n+\t      enum machine_mode mode;\n+\t      int unsignedp, volatilep;\n+\n+\t      inner = get_inner_reference (operand, &bitsize, &bitpos, &offset,\n+\t\t\t\t\t   &mode, &unsignedp, &volatilep,\n+\t\t\t\t\t   false);\n+\n+\t      /* If INNER is a padding type whose field has a self-referential\n+\t\t size, convert to that inner type.  We know the offset is zero\n+\t\t and we need to have that type visible.  */\n+\t      if (TREE_CODE (TREE_TYPE (inner)) == RECORD_TYPE\n+\t\t  && TYPE_IS_PADDING_P (TREE_TYPE (inner))\n+\t\t  && (CONTAINS_PLACEHOLDER_P\n+\t\t      (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS\n+\t\t\t\t\t     (TREE_TYPE (inner)))))))\n+\t\tinner = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (inner))),\n+\t\t\t\t inner);\n+\n+\t      /* Compute the offset as a byte offset from INNER.  */\n+\t      if (!offset)\n+\t\toffset = size_zero_node;\n+\n+\t      if (bitpos % BITS_PER_UNIT != 0)\n+\t\tpost_error\n+\t\t  (\"taking address of object not aligned on storage unit?\",\n+\t\t   error_gnat_node);\n+\n+\t      offset = size_binop (PLUS_EXPR, offset,\n+\t\t\t\t   size_int (bitpos / BITS_PER_UNIT));\n+\n+\t      /* Take the address of INNER, convert the offset to void *, and\n+\t\t add then.  It will later be converted to the desired result\n+\t\t type, if any.  */\n+\t      inner = build_unary_op (ADDR_EXPR, NULL_TREE, inner);\n+\t      inner = convert (ptr_void_type_node, inner);\n+\t      result = build_binary_op (POINTER_PLUS_EXPR, ptr_void_type_node,\n+\t\t\t\t\tinner, offset);\n+\t      result = convert (build_pointer_type (TREE_TYPE (operand)),\n+\t\t\t\tresult);\n+\t      break;\n+\t    }\n+\t  goto common;\n+\n+\tcase CONSTRUCTOR:\n+\t  /* If this is just a constructor for a padded record, we can\n+\t     just take the address of the single field and convert it to\n+\t     a pointer to our type.  */\n+\t  if (TREE_CODE (type) == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n+\t    {\n+\t      result = (VEC_index (constructor_elt,\n+\t\t\t\t   CONSTRUCTOR_ELTS (operand),\n+\t\t\t\t   0)\n+\t\t\t->value);\n+\n+\t      result = convert (build_pointer_type (TREE_TYPE (operand)),\n+\t\t\t\tbuild_unary_op (ADDR_EXPR, NULL_TREE, result));\n+\t      break;\n+\t    }\n+\n+\t  goto common;\n+\n+\tcase NOP_EXPR:\n+\t  if (AGGREGATE_TYPE_P (type)\n+\t      && AGGREGATE_TYPE_P (TREE_TYPE (TREE_OPERAND (operand, 0))))\n+\t    return build_unary_op (ADDR_EXPR, result_type,\n+\t\t\t\t   TREE_OPERAND (operand, 0));\n+\n+\t  /* ... fallthru ... */\n+\n+\tcase VIEW_CONVERT_EXPR:\n+\t  /* If this just a variant conversion or if the conversion doesn't\n+\t     change the mode, get the result type from this type and go down.\n+\t     This is needed for conversions of CONST_DECLs, to eventually get\n+\t     to the address of their CORRESPONDING_VARs.  */\n+\t  if ((TYPE_MAIN_VARIANT (type)\n+\t       == TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (operand, 0))))\n+\t      || (TYPE_MODE (type) != BLKmode\n+\t\t  && (TYPE_MODE (type)\n+\t\t      == TYPE_MODE (TREE_TYPE (TREE_OPERAND (operand, 0))))))\n+\t    return build_unary_op (ADDR_EXPR,\n+\t\t\t\t   (result_type ? result_type\n+\t\t\t\t    : build_pointer_type (type)),\n+\t\t\t\t   TREE_OPERAND (operand, 0));\n+\t  goto common;\n+\n+\tcase CONST_DECL:\n+\t  operand = DECL_CONST_CORRESPONDING_VAR (operand);\n+\n+\t  /* ... fall through ... */\n+\n+\tdefault:\n+\tcommon:\n+\n+\t  /* If we are taking the address of a padded record whose field is\n+\t     contains a template, take the address of the template.  */\n+\t  if (TREE_CODE (type) == RECORD_TYPE\n+\t      && TYPE_IS_PADDING_P (type)\n+\t      && TREE_CODE (TREE_TYPE (TYPE_FIELDS (type))) == RECORD_TYPE\n+\t      && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (TYPE_FIELDS (type))))\n+\t    {\n+\t      type = TREE_TYPE (TYPE_FIELDS (type));\n+\t      operand = convert (type, operand);\n+\t    }\n+\n+\t  if (type != error_mark_node)\n+\t    operation_type = build_pointer_type (type);\n+\n+\t  gnat_mark_addressable (operand);\n+\t  result = fold_build1 (ADDR_EXPR, operation_type, operand);\n+\t}\n+\n+      TREE_CONSTANT (result) = staticp (operand) || TREE_CONSTANT (operand);\n+      break;\n+\n+    case INDIRECT_REF:\n+      /* If we want to refer to an entire unconstrained array,\n+\t make up an expression to do so.  This will never survive to\n+\t the backend.  If TYPE is a thin pointer, first convert the\n+\t operand to a fat pointer.  */\n+      if (TYPE_THIN_POINTER_P (type)\n+\t  && TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type)))\n+\t{\n+\t  operand\n+\t    = convert (TREE_TYPE (TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type))),\n+\t\t       operand);\n+\t  type = TREE_TYPE (operand);\n+\t}\n+\n+      if (TYPE_FAT_POINTER_P (type))\n+\t{\n+\t  result = build1 (UNCONSTRAINED_ARRAY_REF,\n+\t\t\t   TYPE_UNCONSTRAINED_ARRAY (type), operand);\n+\t  TREE_READONLY (result) = TREE_STATIC (result)\n+\t    = TYPE_READONLY (TYPE_UNCONSTRAINED_ARRAY (type));\n+\t}\n+      else if (TREE_CODE (operand) == ADDR_EXPR)\n+\tresult = TREE_OPERAND (operand, 0);\n+\n+      else\n+\t{\n+\t  result = fold_build1 (op_code, TREE_TYPE (type), operand);\n+\t  TREE_READONLY (result) = TYPE_READONLY (TREE_TYPE (type));\n+\t}\n+\n+      side_effects\n+\t=  (!TYPE_FAT_POINTER_P (type) && TYPE_VOLATILE (TREE_TYPE (type)));\n+      break;\n+\n+    case NEGATE_EXPR:\n+    case BIT_NOT_EXPR:\n+      {\n+\ttree modulus = ((operation_type\n+\t\t\t && TREE_CODE (operation_type) == INTEGER_TYPE\n+\t\t\t && TYPE_MODULAR_P (operation_type))\n+\t\t\t? TYPE_MODULUS (operation_type) : NULL_TREE);\n+\tint mod_pow2 = modulus && integer_pow2p (modulus);\n+\n+\t/* If this is a modular type, there are various possibilities\n+\t   depending on the operation and whether the modulus is a\n+\t   power of two or not.  */\n+\n+\tif (modulus)\n+\t  {\n+\t    gcc_assert (operation_type == base_type);\n+\t    operand = convert (operation_type, operand);\n+\n+\t    /* The fastest in the negate case for binary modulus is\n+\t       the straightforward code; the TRUNC_MOD_EXPR below\n+\t       is an AND operation.  */\n+\t    if (op_code == NEGATE_EXPR && mod_pow2)\n+\t      result = fold_build2 (TRUNC_MOD_EXPR, operation_type,\n+\t\t\t\t    fold_build1 (NEGATE_EXPR, operation_type,\n+\t\t\t\t\t\t operand),\n+\t\t\t\t    modulus);\n+\n+\t    /* For nonbinary negate case, return zero for zero operand,\n+\t       else return the modulus minus the operand.  If the modulus\n+\t       is a power of two minus one, we can do the subtraction\n+\t       as an XOR since it is equivalent and faster on most machines. */\n+\t    else if (op_code == NEGATE_EXPR && !mod_pow2)\n+\t      {\n+\t\tif (integer_pow2p (fold_build2 (PLUS_EXPR, operation_type,\n+\t\t\t\t\t\tmodulus,\n+\t\t\t\t\t\tconvert (operation_type,\n+\t\t\t\t\t\t\t integer_one_node))))\n+\t\t  result = fold_build2 (BIT_XOR_EXPR, operation_type,\n+\t\t\t\t\toperand, modulus);\n+\t\telse\n+\t\t  result = fold_build2 (MINUS_EXPR, operation_type,\n+\t\t\t\t\tmodulus, operand);\n+\n+\t\tresult = fold_build3 (COND_EXPR, operation_type,\n+\t\t\t\t      fold_build2 (NE_EXPR,\n+\t\t\t\t\t\t   integer_type_node,\n+\t\t\t\t\t\t   operand,\n+\t\t\t\t\t\t   convert\n+\t\t\t\t\t\t     (operation_type,\n+\t\t\t\t\t\t      integer_zero_node)),\n+\t\t\t\t      result, operand);\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* For the NOT cases, we need a constant equal to\n+\t\t   the modulus minus one.  For a binary modulus, we\n+\t\t   XOR against the constant and subtract the operand from\n+\t\t   that constant for nonbinary modulus.  */\n+\n+\t\ttree cnst = fold_build2 (MINUS_EXPR, operation_type, modulus,\n+\t\t\t\t\t convert (operation_type,\n+\t\t\t\t\t\t  integer_one_node));\n+\n+\t\tif (mod_pow2)\n+\t\t  result = fold_build2 (BIT_XOR_EXPR, operation_type,\n+\t\t\t\t\toperand, cnst);\n+\t\telse\n+\t\t  result = fold_build2 (MINUS_EXPR, operation_type,\n+\t\t\t\t\tcnst, operand);\n+\t      }\n+\n+\t    break;\n+\t  }\n+      }\n+\n+      /* ... fall through ... */\n+\n+    default:\n+      gcc_assert (operation_type == base_type);\n+      result = fold_build1 (op_code, operation_type,\n+\t\t\t    convert (operation_type, operand));\n+    }\n+\n+  if (side_effects)\n+    {\n+      TREE_SIDE_EFFECTS (result) = 1;\n+      if (TREE_CODE (result) == INDIRECT_REF)\n+\tTREE_THIS_VOLATILE (result) = TYPE_VOLATILE (TREE_TYPE (result));\n+    }\n+\n+  if (result_type && TREE_TYPE (result) != result_type)\n+    result = convert (result_type, result);\n+\n+  return result;\n+}\n+\f\n+/* Similar, but for COND_EXPR.  */\n+\n+tree\n+build_cond_expr (tree result_type, tree condition_operand,\n+                 tree true_operand, tree false_operand)\n+{\n+  tree result;\n+  bool addr_p = false;\n+\n+  /* The front-end verifies that result, true and false operands have same base\n+     type.  Convert everything to the result type.  */\n+\n+  true_operand  = convert (result_type, true_operand);\n+  false_operand = convert (result_type, false_operand);\n+\n+  /* If the result type is unconstrained, take the address of\n+     the operands and then dereference our result.  */\n+  if (TREE_CODE (result_type) == UNCONSTRAINED_ARRAY_TYPE\n+      || CONTAINS_PLACEHOLDER_P (TYPE_SIZE (result_type)))\n+    {\n+      addr_p = true;\n+      result_type = build_pointer_type (result_type);\n+      true_operand = build_unary_op (ADDR_EXPR, result_type, true_operand);\n+      false_operand = build_unary_op (ADDR_EXPR, result_type, false_operand);\n+    }\n+\n+  result = fold_build3 (COND_EXPR, result_type, condition_operand,\n+\t\t\ttrue_operand, false_operand);\n+\n+  /* If either operand is a SAVE_EXPR (possibly surrounded by\n+     arithmetic, make sure it gets done.  */\n+  true_operand  = skip_simple_arithmetic (true_operand);\n+  false_operand = skip_simple_arithmetic (false_operand);\n+\n+  if (TREE_CODE (true_operand) == SAVE_EXPR)\n+    result = build2 (COMPOUND_EXPR, result_type, true_operand, result);\n+\n+  if (TREE_CODE (false_operand) == SAVE_EXPR)\n+    result = build2 (COMPOUND_EXPR, result_type, false_operand, result);\n+\n+  /* ??? Seems the code above is wrong, as it may move ahead of the COND\n+     SAVE_EXPRs with side effects and not shared by both arms.  */\n+\n+ if (addr_p)\n+    result = build_unary_op (INDIRECT_REF, NULL_TREE, result);\n+\n+  return result;\n+}\n+\n+/* Similar, but for RETURN_EXPR.  If RESULT_DECL is non-zero, build\n+   a RETURN_EXPR around the assignment of RET_VAL to RESULT_DECL.\n+   If RESULT_DECL is zero, build a bare RETURN_EXPR.  */\n+\n+tree\n+build_return_expr (tree result_decl, tree ret_val)\n+{\n+  tree result_expr;\n+\n+  if (result_decl)\n+    {\n+      /* The gimplifier explicitly enforces the following invariant:\n+\n+           RETURN_EXPR\n+               |\n+           MODIFY_EXPR\n+           /        \\\n+          /          \\\n+      RESULT_DECL    ...\n+\n+      As a consequence, type-homogeneity dictates that we use the type\n+      of the RESULT_DECL as the operation type.  */\n+\n+      tree operation_type = TREE_TYPE (result_decl);\n+\n+      /* Convert the right operand to the operation type.  Note that\n+         it's the same transformation as in the MODIFY_EXPR case of\n+         build_binary_op with the additional guarantee that the type\n+         cannot involve a placeholder, since otherwise the function\n+         would use the \"target pointer\" return mechanism.  */\n+\n+      if (operation_type != TREE_TYPE (ret_val))\n+\tret_val = convert (operation_type, ret_val);\n+\n+      result_expr\n+\t= build2 (MODIFY_EXPR, operation_type, result_decl, ret_val);\n+    }\n+  else\n+    result_expr = NULL_TREE;\n+\n+  return build1 (RETURN_EXPR, void_type_node, result_expr);\n+}\n+\f\n+/* Build a CALL_EXPR to call FUNDECL with one argument, ARG.  Return\n+   the CALL_EXPR.  */\n+\n+tree\n+build_call_1_expr (tree fundecl, tree arg)\n+{\n+  tree call = build_call_nary (TREE_TYPE (TREE_TYPE (fundecl)),\n+\t\t\t       build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n+\t\t\t       1, arg);\n+  TREE_SIDE_EFFECTS (call) = 1;\n+  return call;\n+}\n+\n+/* Build a CALL_EXPR to call FUNDECL with two arguments, ARG1 & ARG2.  Return\n+   the CALL_EXPR.  */\n+\n+tree\n+build_call_2_expr (tree fundecl, tree arg1, tree arg2)\n+{\n+  tree call = build_call_nary (TREE_TYPE (TREE_TYPE (fundecl)),\n+\t\t\t       build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n+\t\t\t       2, arg1, arg2);\n+  TREE_SIDE_EFFECTS (call) = 1;\n+  return call;\n+}\n+\n+/* Likewise to call FUNDECL with no arguments.  */\n+\n+tree\n+build_call_0_expr (tree fundecl)\n+{\n+  /* We rely on build_call_nary to compute TREE_SIDE_EFFECTS.  This makes\n+     it possible to propagate DECL_IS_PURE on parameterless functions.  */\n+  tree call = build_call_nary (TREE_TYPE (TREE_TYPE (fundecl)),\n+\t\t\t       build_unary_op (ADDR_EXPR, NULL_TREE, fundecl),\n+\t\t\t       0);\n+  return call;\n+}\n+\f\n+/* Call a function that raises an exception and pass the line number and file\n+   name, if requested.  MSG says which exception function to call.\n+\n+   GNAT_NODE is the gnat node conveying the source location for which the\n+   error should be signaled, or Empty in which case the error is signaled on\n+   the current ref_file_name/input_line.\n+\n+   KIND says which kind of exception this is for\n+   (N_Raise_{Constraint,Storage,Program}_Error).  */\n+\n+tree\n+build_call_raise (int msg, Node_Id gnat_node, char kind)\n+{\n+  tree fndecl = gnat_raise_decls[msg];\n+  tree label = get_exception_label (kind);\n+  tree filename;\n+  int line_number;\n+  const char *str;\n+  int len;\n+\n+  /* If this is to be done as a goto, handle that case.  */\n+  if (label)\n+    {\n+      Entity_Id local_raise = Get_Local_Raise_Call_Entity ();\n+      tree gnu_result = build1 (GOTO_EXPR, void_type_node, label);\n+\n+      /* If Local_Raise is present, generate\n+\t Local_Raise (exception'Identity);  */\n+      if (Present (local_raise))\n+\t{\n+\t  tree gnu_local_raise\n+\t    = gnat_to_gnu_entity (local_raise, NULL_TREE, 0);\n+\t  tree gnu_exception_entity\n+\t    = gnat_to_gnu_entity (Get_RT_Exception_Entity (msg), NULL_TREE, 0);\n+\t  tree gnu_call\n+\t    = build_call_1_expr (gnu_local_raise,\n+\t\t\t\t build_unary_op (ADDR_EXPR, NULL_TREE,\n+\t\t\t\t\t\t gnu_exception_entity));\n+\n+\t  gnu_result = build2 (COMPOUND_EXPR, void_type_node,\n+\t\t\t       gnu_call, gnu_result);}\n+\n+      return gnu_result;\n+    }\n+\n+  str\n+    = (Debug_Flag_NN || Exception_Locations_Suppressed)\n+      ? \"\"\n+      : (gnat_node != Empty && Sloc (gnat_node) != No_Location)\n+        ? IDENTIFIER_POINTER\n+          (get_identifier (Get_Name_String\n+\t\t\t   (Debug_Source_Name\n+\t\t\t    (Get_Source_File_Index (Sloc (gnat_node))))))\n+        : ref_filename;\n+\n+  len = strlen (str) + 1;\n+  filename = build_string (len, str);\n+  line_number\n+    = (gnat_node != Empty && Sloc (gnat_node) != No_Location)\n+      ? Get_Logical_Line_Number (Sloc(gnat_node)) : input_line;\n+\n+  TREE_TYPE (filename)\n+    = build_array_type (char_type_node,\n+\t\t\tbuild_index_type (build_int_cst (NULL_TREE, len)));\n+\n+  return\n+    build_call_2_expr (fndecl,\n+\t\t       build1 (ADDR_EXPR, build_pointer_type (char_type_node),\n+\t\t\t       filename),\n+\t\t       build_int_cst (NULL_TREE, line_number));\n+}\n+\f\n+/* qsort comparer for the bit positions of two constructor elements\n+   for record components.  */\n+\n+static int\n+compare_elmt_bitpos (const PTR rt1, const PTR rt2)\n+{\n+  const_tree const elmt1 = * (const_tree const *) rt1;\n+  const_tree const elmt2 = * (const_tree const *) rt2;\n+  const_tree const field1 = TREE_PURPOSE (elmt1);\n+  const_tree const field2 = TREE_PURPOSE (elmt2);\n+  const int ret\n+    = tree_int_cst_compare (bit_position (field1), bit_position (field2));\n+\n+  return ret ? ret : (int) (DECL_UID (field1) - DECL_UID (field2));\n+}\n+\n+/* Return a CONSTRUCTOR of TYPE whose list is LIST.  */\n+\n+tree\n+gnat_build_constructor (tree type, tree list)\n+{\n+  tree elmt;\n+  int n_elmts;\n+  bool allconstant = (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST);\n+  bool side_effects = false;\n+  tree result;\n+\n+  /* Scan the elements to see if they are all constant or if any has side\n+     effects, to let us set global flags on the resulting constructor.  Count\n+     the elements along the way for possible sorting purposes below.  */\n+  for (n_elmts = 0, elmt = list; elmt; elmt = TREE_CHAIN (elmt), n_elmts ++)\n+    {\n+      if (!TREE_CONSTANT (TREE_VALUE (elmt))\n+\t  || (TREE_CODE (type) == RECORD_TYPE\n+\t      && DECL_BIT_FIELD (TREE_PURPOSE (elmt))\n+\t      && TREE_CODE (TREE_VALUE (elmt)) != INTEGER_CST)\n+\t  || !initializer_constant_valid_p (TREE_VALUE (elmt),\n+\t\t\t\t\t    TREE_TYPE (TREE_VALUE (elmt))))\n+\tallconstant = false;\n+\n+      if (TREE_SIDE_EFFECTS (TREE_VALUE (elmt)))\n+\tside_effects = true;\n+\n+      /* Propagate an NULL_EXPR from the size of the type.  We won't ever\n+\t be executing the code we generate here in that case, but handle it\n+\t specially to avoid the compiler blowing up.  */\n+      if (TREE_CODE (type) == RECORD_TYPE\n+\t  && (0 != (result\n+\t\t    = contains_null_expr (DECL_SIZE (TREE_PURPOSE (elmt))))))\n+\treturn build1 (NULL_EXPR, type, TREE_OPERAND (result, 0));\n+    }\n+\n+  /* For record types with constant components only, sort field list\n+     by increasing bit position.  This is necessary to ensure the\n+     constructor can be output as static data.  */\n+  if (allconstant && TREE_CODE (type) == RECORD_TYPE && n_elmts > 1)\n+    {\n+      /* Fill an array with an element tree per index, and ask qsort to order\n+\t them according to what a bitpos comparison function says.  */\n+      tree *gnu_arr = (tree *) alloca (sizeof (tree) * n_elmts);\n+      int i;\n+\n+      for (i = 0, elmt = list; elmt; elmt = TREE_CHAIN (elmt), i++)\n+\tgnu_arr[i] = elmt;\n+\n+      qsort (gnu_arr, n_elmts, sizeof (tree), compare_elmt_bitpos);\n+\n+      /* Then reconstruct the list from the sorted array contents.  */\n+      list = NULL_TREE;\n+      for (i = n_elmts - 1; i >= 0; i--)\n+\t{\n+\t  TREE_CHAIN (gnu_arr[i]) = list;\n+\t  list = gnu_arr[i];\n+\t}\n+    }\n+\n+  result = build_constructor_from_list (type, list);\n+  TREE_CONSTANT (result) = TREE_STATIC (result) = allconstant;\n+  TREE_SIDE_EFFECTS (result) = side_effects;\n+  TREE_READONLY (result) = TYPE_READONLY (type) || allconstant;\n+  return result;\n+}\n+\f\n+/* Return a COMPONENT_REF to access a field that is given by COMPONENT,\n+   an IDENTIFIER_NODE giving the name of the field, or FIELD, a FIELD_DECL,\n+   for the field.  Don't fold the result if NO_FOLD_P is true.\n+\n+   We also handle the fact that we might have been passed a pointer to the\n+   actual record and know how to look for fields in variant parts.  */\n+\n+static tree\n+build_simple_component_ref (tree record_variable, tree component,\n+                            tree field, bool no_fold_p)\n+{\n+  tree record_type = TYPE_MAIN_VARIANT (TREE_TYPE (record_variable));\n+  tree ref, inner_variable;\n+\n+  gcc_assert ((TREE_CODE (record_type) == RECORD_TYPE\n+\t       || TREE_CODE (record_type) == UNION_TYPE\n+\t       || TREE_CODE (record_type) == QUAL_UNION_TYPE)\n+\t      && TYPE_SIZE (record_type)\n+\t      && (component != 0) != (field != 0));\n+\n+  /* If no field was specified, look for a field with the specified name\n+     in the current record only.  */\n+  if (!field)\n+    for (field = TYPE_FIELDS (record_type); field;\n+\t field = TREE_CHAIN (field))\n+      if (DECL_NAME (field) == component)\n+\tbreak;\n+\n+  if (!field)\n+    return NULL_TREE;\n+\n+  /* If this field is not in the specified record, see if we can find\n+     something in the record whose original field is the same as this one. */\n+  if (DECL_CONTEXT (field) != record_type)\n+    /* Check if there is a field with name COMPONENT in the record.  */\n+    {\n+      tree new_field;\n+\n+      /* First loop thru normal components.  */\n+\n+      for (new_field = TYPE_FIELDS (record_type); new_field;\n+\t   new_field = TREE_CHAIN (new_field))\n+\tif (field == new_field\n+\t    || DECL_ORIGINAL_FIELD (new_field) == field\n+\t    || new_field == DECL_ORIGINAL_FIELD (field)\n+\t    || (DECL_ORIGINAL_FIELD (field)\n+\t\t&& (DECL_ORIGINAL_FIELD (field)\n+\t\t    == DECL_ORIGINAL_FIELD (new_field))))\n+\t  break;\n+\n+      /* Next, loop thru DECL_INTERNAL_P components if we haven't found\n+         the component in the first search. Doing this search in 2 steps\n+         is required to avoiding hidden homonymous fields in the\n+         _Parent field.  */\n+\n+      if (!new_field)\n+\tfor (new_field = TYPE_FIELDS (record_type); new_field;\n+\t     new_field = TREE_CHAIN (new_field))\n+\t  if (DECL_INTERNAL_P (new_field))\n+\t    {\n+\t      tree field_ref\n+\t\t= build_simple_component_ref (record_variable,\n+\t\t\t\t\t      NULL_TREE, new_field, no_fold_p);\n+\t      ref = build_simple_component_ref (field_ref, NULL_TREE, field,\n+\t\t\t\t\t\tno_fold_p);\n+\n+\t      if (ref)\n+\t\treturn ref;\n+\t    }\n+\n+      field = new_field;\n+    }\n+\n+  if (!field)\n+    return NULL_TREE;\n+\n+  /* If the field's offset has overflowed, do not attempt to access it\n+     as doing so may trigger sanity checks deeper in the back-end.\n+     Note that we don't need to warn since this will be done on trying\n+     to declare the object.  */\n+  if (TREE_CODE (DECL_FIELD_OFFSET (field)) == INTEGER_CST\n+      && TREE_OVERFLOW (DECL_FIELD_OFFSET (field)))\n+    return NULL_TREE;\n+\n+  /* Look through conversion between type variants.  Note that this\n+     is transparent as far as the field is concerned.  */\n+  if (TREE_CODE (record_variable) == VIEW_CONVERT_EXPR\n+      && TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (record_variable, 0)))\n+\t == record_type)\n+    inner_variable = TREE_OPERAND (record_variable, 0);\n+  else\n+    inner_variable = record_variable;\n+\n+  ref = build3 (COMPONENT_REF, TREE_TYPE (field), inner_variable, field,\n+\t\tNULL_TREE);\n+\n+  if (TREE_READONLY (record_variable) || TREE_READONLY (field))\n+    TREE_READONLY (ref) = 1;\n+  if (TREE_THIS_VOLATILE (record_variable) || TREE_THIS_VOLATILE (field)\n+      || TYPE_VOLATILE (record_type))\n+    TREE_THIS_VOLATILE (ref) = 1;\n+\n+  if (no_fold_p)\n+    return ref;\n+\n+  /* The generic folder may punt in this case because the inner array type\n+     can be self-referential, but folding is in fact not problematic.  */\n+  else if (TREE_CODE (record_variable) == CONSTRUCTOR\n+\t   && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (record_variable)))\n+    {\n+      VEC(constructor_elt,gc) *elts = CONSTRUCTOR_ELTS (record_variable);\n+      unsigned HOST_WIDE_INT idx;\n+      tree index, value;\n+      FOR_EACH_CONSTRUCTOR_ELT (elts, idx, index, value)\n+\tif (index == field)\n+\t  return value;\n+      return ref;\n+    }\n+\n+  else\n+    return fold (ref);\n+}\n+\f\n+/* Like build_simple_component_ref, except that we give an error if the\n+   reference could not be found.  */\n+\n+tree\n+build_component_ref (tree record_variable, tree component,\n+                     tree field, bool no_fold_p)\n+{\n+  tree ref = build_simple_component_ref (record_variable, component, field,\n+\t\t\t\t\t no_fold_p);\n+\n+  if (ref)\n+    return ref;\n+\n+  /* If FIELD was specified, assume this is an invalid user field so\n+     raise constraint error.  Otherwise, we can't find the type to return, so\n+     abort.  */\n+  gcc_assert (field);\n+  return build1 (NULL_EXPR, TREE_TYPE (field),\n+\t\t build_call_raise (CE_Discriminant_Check_Failed, Empty,\n+\t\t\t\t   N_Raise_Constraint_Error));\n+}\n+\f\n+/* Build a GCC tree to call an allocation or deallocation function.\n+   If GNU_OBJ is nonzero, it is an object to deallocate.  Otherwise,\n+   generate an allocator.\n+\n+   GNU_SIZE is the size of the object in bytes and ALIGN is the alignment in\n+   bits.  GNAT_PROC, if present, is a procedure to call and GNAT_POOL is the\n+   storage pool to use.  If not preset, malloc and free will be used except\n+   if GNAT_PROC is the \"fake\" value of -1, in which case we allocate the\n+   object dynamically on the stack frame.  */\n+\n+tree\n+build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n+                          Entity_Id gnat_proc, Entity_Id gnat_pool,\n+                          Node_Id gnat_node)\n+{\n+  tree gnu_align = size_int (align / BITS_PER_UNIT);\n+\n+  gnu_size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_size, gnu_obj);\n+\n+  if (Present (gnat_proc))\n+    {\n+      /* The storage pools are obviously always tagged types, but the\n+\t secondary stack uses the same mechanism and is not tagged */\n+      if (Is_Tagged_Type (Etype (gnat_pool)))\n+\t{\n+\t  /* The size is the third parameter; the alignment is the\n+             same type.  */\n+\t  Entity_Id gnat_size_type\n+\t    = Etype (Next_Formal (Next_Formal (First_Formal (gnat_proc))));\n+\t  tree gnu_size_type = gnat_to_gnu_type (gnat_size_type);\n+\t  tree gnu_proc = gnat_to_gnu (gnat_proc);\n+\t  tree gnu_proc_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_proc);\n+\t  tree gnu_pool = gnat_to_gnu (gnat_pool);\n+\t  tree gnu_pool_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_pool);\n+\t  tree gnu_call;\n+\n+\t  gnu_size = convert (gnu_size_type, gnu_size);\n+\t  gnu_align = convert (gnu_size_type, gnu_align);\n+\n+\t  /* The first arg is always the address of the storage pool; next\n+\t     comes the address of the object, for a deallocator, then the\n+\t     size and alignment.  */\n+\t  if (gnu_obj)\n+\t    gnu_call = build_call_nary (TREE_TYPE (TREE_TYPE (gnu_proc)),\n+\t\t\t\t\tgnu_proc_addr, 4, gnu_pool_addr,\n+\t\t\t\t\tgnu_obj, gnu_size, gnu_align);\n+\t  else\n+\t    gnu_call = build_call_nary (TREE_TYPE (TREE_TYPE (gnu_proc)),\n+\t\t\t\t\tgnu_proc_addr, 3, gnu_pool_addr,\n+\t\t\t\t\tgnu_size, gnu_align);\n+\t  TREE_SIDE_EFFECTS (gnu_call) = 1;\n+\t  return gnu_call;\n+\t}\n+\n+      /* Secondary stack case.  */\n+      else\n+\t{\n+\t  /* The size is the second parameter */\n+\t  Entity_Id gnat_size_type\n+\t    = Etype (Next_Formal (First_Formal (gnat_proc)));\n+\t  tree gnu_size_type = gnat_to_gnu_type (gnat_size_type);\n+\t  tree gnu_proc = gnat_to_gnu (gnat_proc);\n+\t  tree gnu_proc_addr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_proc);\n+\t  tree gnu_call;\n+\n+\t  gnu_size = convert (gnu_size_type, gnu_size);\n+\n+\t  /* The first arg is the address of the object, for a\n+\t     deallocator, then the size */\n+\t  if (gnu_obj)\n+\t    gnu_call = build_call_nary (TREE_TYPE (TREE_TYPE (gnu_proc)),\n+\t\t\t\t\tgnu_proc_addr, 2, gnu_obj, gnu_size);\n+\t  else\n+\t    gnu_call = build_call_nary (TREE_TYPE (TREE_TYPE (gnu_proc)),\n+\t\t\t\t\tgnu_proc_addr, 1, gnu_size);\n+\t  TREE_SIDE_EFFECTS (gnu_call) = 1;\n+\t  return gnu_call;\n+\t}\n+    }\n+\n+  else if (gnu_obj)\n+    return build_call_1_expr (free_decl, gnu_obj);\n+\n+  /* ??? For now, disable variable-sized allocators in the stack since\n+     we can't yet gimplify an ALLOCATE_EXPR.  */\n+  else if (gnat_pool == -1\n+\t   && TREE_CODE (gnu_size) == INTEGER_CST && !flag_stack_check)\n+    {\n+      /* If the size is a constant, we can put it in the fixed portion of\n+\t the stack frame to avoid the need to adjust the stack pointer.  */\n+      if (TREE_CODE (gnu_size) == INTEGER_CST && !flag_stack_check)\n+\t{\n+\t  tree gnu_range\n+\t    = build_range_type (NULL_TREE, size_one_node, gnu_size);\n+\t  tree gnu_array_type = build_array_type (char_type_node, gnu_range);\n+\t  tree gnu_decl\n+\t    = create_var_decl (get_identifier (\"RETVAL\"), NULL_TREE,\n+\t\t\t       gnu_array_type, NULL_TREE, false, false, false,\n+\t\t\t       false, NULL, gnat_node);\n+\n+\t  return convert (ptr_void_type_node,\n+\t\t\t  build_unary_op (ADDR_EXPR, NULL_TREE, gnu_decl));\n+\t}\n+      else\n+\tgcc_unreachable ();\n+#if 0\n+\treturn build2 (ALLOCATE_EXPR, ptr_void_type_node, gnu_size, gnu_align);\n+#endif\n+    }\n+  else\n+    {\n+      if (Nkind (gnat_node) != N_Allocator || !Comes_From_Source (gnat_node))\n+        Check_No_Implicit_Heap_Alloc (gnat_node);\n+\n+      /* If the allocator size is 32bits but the pointer size is 64bits then\n+\t allocate 32bit memory (sometimes necessary on 64bit VMS). Otherwise\n+\t default to standard malloc. */\n+      if (UI_To_Int (Esize (Etype (gnat_node))) == 32 && POINTER_SIZE == 64)\n+        return build_call_1_expr (malloc32_decl, gnu_size);\n+      else\n+        return build_call_1_expr (malloc_decl, gnu_size);\n+    }\n+}\n+\f\n+/* Build a GCC tree to correspond to allocating an object of TYPE whose\n+   initial value is INIT, if INIT is nonzero.  Convert the expression to\n+   RESULT_TYPE, which must be some type of pointer.  Return the tree.\n+   GNAT_PROC and GNAT_POOL optionally give the procedure to call and\n+   the storage pool to use.  GNAT_NODE is used to provide an error\n+   location for restriction violations messages.  If IGNORE_INIT_TYPE is\n+   true, ignore the type of INIT for the purpose of determining the size;\n+   this will cause the maximum size to be allocated if TYPE is of\n+   self-referential size.  */\n+\n+tree\n+build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n+                 Entity_Id gnat_pool, Node_Id gnat_node, bool ignore_init_type)\n+{\n+  tree size = TYPE_SIZE_UNIT (type);\n+  tree result;\n+  unsigned int default_allocator_alignment\n+    = get_target_default_allocator_alignment () * BITS_PER_UNIT;\n+\n+  /* If the initializer, if present, is a NULL_EXPR, just return a new one.  */\n+  if (init && TREE_CODE (init) == NULL_EXPR)\n+    return build1 (NULL_EXPR, result_type, TREE_OPERAND (init, 0));\n+\n+  /* If RESULT_TYPE is a fat or thin pointer, set SIZE to be the sum of the\n+     sizes of the object and its template.  Allocate the whole thing and\n+     fill in the parts that are known.  */\n+  else if (TYPE_FAT_OR_THIN_POINTER_P (result_type))\n+    {\n+      tree storage_type\n+\t= build_unc_object_type_from_ptr (result_type, type,\n+\t\t\t\t\t  get_identifier (\"ALLOC\"));\n+      tree template_type = TREE_TYPE (TYPE_FIELDS (storage_type));\n+      tree storage_ptr_type = build_pointer_type (storage_type);\n+      tree storage;\n+      tree template_cons = NULL_TREE;\n+\n+      size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_SIZE_UNIT (storage_type),\n+\t\t\t\t\t     init);\n+\n+      /* If the size overflows, pass -1 so the allocator will raise\n+\t storage error.  */\n+      if (TREE_CODE (size) == INTEGER_CST && TREE_OVERFLOW (size))\n+\tsize = ssize_int (-1);\n+\n+      storage = build_call_alloc_dealloc (NULL_TREE, size,\n+\t\t\t\t\t  TYPE_ALIGN (storage_type),\n+\t\t\t\t\t  gnat_proc, gnat_pool, gnat_node);\n+      storage = convert (storage_ptr_type, protect_multiple_eval (storage));\n+\n+      if (TREE_CODE (type) == RECORD_TYPE && TYPE_IS_PADDING_P (type))\n+\t{\n+\t  type = TREE_TYPE (TYPE_FIELDS (type));\n+\n+\t  if (init)\n+\t    init = convert (type, init);\n+\t}\n+\n+      /* If there is an initializing expression, make a constructor for\n+\t the entire object including the bounds and copy it into the\n+\t object.  If there is no initializing expression, just set the\n+\t bounds.  */\n+      if (init)\n+\t{\n+\t  template_cons = tree_cons (TREE_CHAIN (TYPE_FIELDS (storage_type)),\n+\t\t\t\t     init, NULL_TREE);\n+\t  template_cons = tree_cons (TYPE_FIELDS (storage_type),\n+\t\t\t\t     build_template (template_type, type,\n+\t\t\t\t\t\t     init),\n+\t\t\t\t     template_cons);\n+\n+\t  return convert\n+\t    (result_type,\n+\t     build2 (COMPOUND_EXPR, storage_ptr_type,\n+\t\t     build_binary_op\n+\t\t     (MODIFY_EXPR, storage_type,\n+\t\t      build_unary_op (INDIRECT_REF, NULL_TREE,\n+\t\t\t\t      convert (storage_ptr_type, storage)),\n+\t\t      gnat_build_constructor (storage_type, template_cons)),\n+\t\t     convert (storage_ptr_type, storage)));\n+\t}\n+      else\n+\treturn build2\n+\t  (COMPOUND_EXPR, result_type,\n+\t   build_binary_op\n+\t   (MODIFY_EXPR, template_type,\n+\t    build_component_ref\n+\t    (build_unary_op (INDIRECT_REF, NULL_TREE,\n+\t\t\t     convert (storage_ptr_type, storage)),\n+\t     NULL_TREE, TYPE_FIELDS (storage_type), 0),\n+\t    build_template (template_type, type, NULL_TREE)),\n+\t   convert (result_type, convert (storage_ptr_type, storage)));\n+    }\n+\n+  /* If we have an initializing expression, see if its size is simpler\n+     than the size from the type.  */\n+  if (!ignore_init_type && init && TYPE_SIZE_UNIT (TREE_TYPE (init))\n+      && (TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (init))) == INTEGER_CST\n+\t  || CONTAINS_PLACEHOLDER_P (size)))\n+    size = TYPE_SIZE_UNIT (TREE_TYPE (init));\n+\n+  /* If the size is still self-referential, reference the initializing\n+     expression, if it is present.  If not, this must have been a\n+     call to allocate a library-level object, in which case we use\n+     the maximum size.  */\n+  if (CONTAINS_PLACEHOLDER_P (size))\n+    {\n+      if (!ignore_init_type && init)\n+\tsize = substitute_placeholder_in_expr (size, init);\n+      else\n+\tsize = max_size (size, true);\n+    }\n+\n+  /* If the size overflows, pass -1 so the allocator will raise\n+     storage error.  */\n+  if (TREE_CODE (size) == INTEGER_CST && TREE_OVERFLOW (size))\n+    size = ssize_int (-1);\n+\n+  /* If this is in the default storage pool and the type alignment is larger\n+     than what the default allocator supports, make an \"aligning\" record type\n+     with room to store a pointer before the field, allocate an object of that\n+     type, store the system's allocator return value just in front of the\n+     field and return the field's address.  */\n+\n+  if (No (gnat_proc) && TYPE_ALIGN (type) > default_allocator_alignment)\n+    {\n+      /* Construct the aligning type with enough room for a pointer ahead\n+\t of the field, then allocate.  */\n+      tree record_type\n+\t= make_aligning_type (type, TYPE_ALIGN (type), size,\n+\t\t\t      default_allocator_alignment,\n+\t\t\t      POINTER_SIZE / BITS_PER_UNIT);\n+\n+      tree record, record_addr;\n+\n+      record_addr\n+\t= build_call_alloc_dealloc (NULL_TREE, TYPE_SIZE_UNIT (record_type),\n+\t\t\t\t    default_allocator_alignment, Empty, Empty,\n+\t\t\t\t    gnat_node);\n+\n+      record_addr\n+\t= convert (build_pointer_type (record_type),\n+\t\t   save_expr (record_addr));\n+\n+      record = build_unary_op (INDIRECT_REF, NULL_TREE, record_addr);\n+\n+      /* Our RESULT (the Ada allocator's value) is the super-aligned address\n+\t of the internal record field ... */\n+      result\n+\t= build_unary_op (ADDR_EXPR, NULL_TREE,\n+\t\t\t  build_component_ref\n+\t\t\t  (record, NULL_TREE, TYPE_FIELDS (record_type), 0));\n+      result = convert (result_type, result);\n+\n+      /* ... with the system allocator's return value stored just in\n+\t front.  */\n+      {\n+\ttree ptr_addr\n+\t  = build_binary_op (POINTER_PLUS_EXPR, ptr_void_type_node,\n+\t\t\t     convert (ptr_void_type_node, result),\n+\t\t\t     size_int (-POINTER_SIZE/BITS_PER_UNIT));\n+\n+\ttree ptr_ref\n+\t  = convert (build_pointer_type (ptr_void_type_node), ptr_addr);\n+\n+\tresult\n+\t  = build2 (COMPOUND_EXPR, TREE_TYPE (result),\n+\t\t    build_binary_op (MODIFY_EXPR, NULL_TREE,\n+\t\t\t\t     build_unary_op (INDIRECT_REF, NULL_TREE,\n+\t\t\t\t\t\t     ptr_ref),\n+\t\t\t\t     convert (ptr_void_type_node,\n+\t\t\t\t\t      record_addr)),\n+\t\t    result);\n+      }\n+    }\n+  else\n+    result = convert (result_type,\n+\t\t      build_call_alloc_dealloc (NULL_TREE, size,\n+\t\t\t\t\t\tTYPE_ALIGN (type),\n+\t\t\t\t\t\tgnat_proc,\n+\t\t\t\t\t\tgnat_pool,\n+\t\t\t\t\t\tgnat_node));\n+\n+  /* If we have an initial value, put the new address into a SAVE_EXPR, assign\n+     the value, and return the address.  Do this with a COMPOUND_EXPR.  */\n+\n+  if (init)\n+    {\n+      result = save_expr (result);\n+      result\n+\t= build2 (COMPOUND_EXPR, TREE_TYPE (result),\n+\t\t  build_binary_op\n+\t\t  (MODIFY_EXPR, NULL_TREE,\n+\t\t   build_unary_op (INDIRECT_REF,\n+\t\t\t\t   TREE_TYPE (TREE_TYPE (result)), result),\n+\t\t   init),\n+\t\t  result);\n+    }\n+\n+  return convert (result_type, result);\n+}\n+\f\n+/* Fill in a VMS descriptor for EXPR and return a constructor for it.\n+   GNAT_FORMAL is how we find the descriptor record.  */\n+\n+tree\n+fill_vms_descriptor (tree expr, Entity_Id gnat_formal)\n+{\n+  tree record_type = TREE_TYPE (TREE_TYPE (get_gnu_tree (gnat_formal)));\n+  tree field;\n+  tree const_list = NULL_TREE;\n+\n+  expr = maybe_unconstrained_array (expr);\n+  gnat_mark_addressable (expr);\n+\n+  for (field = TYPE_FIELDS (record_type); field; field = TREE_CHAIN (field))\n+    const_list\n+      = tree_cons (field,\n+\t\t   convert (TREE_TYPE (field),\n+\t\t\t    SUBSTITUTE_PLACEHOLDER_IN_EXPR\n+\t\t\t    (DECL_INITIAL (field), expr)),\n+\t\t   const_list);\n+\n+  return gnat_build_constructor (record_type, nreverse (const_list));\n+}\n+\n+/* Indicate that we need to make the address of EXPR_NODE and it therefore\n+   should not be allocated in a register.  Returns true if successful.  */\n+\n+bool\n+gnat_mark_addressable (tree expr_node)\n+{\n+  while (1)\n+    switch (TREE_CODE (expr_node))\n+      {\n+      case ADDR_EXPR:\n+      case COMPONENT_REF:\n+      case ARRAY_REF:\n+      case ARRAY_RANGE_REF:\n+      case REALPART_EXPR:\n+      case IMAGPART_EXPR:\n+      case VIEW_CONVERT_EXPR:\n+      case NON_LVALUE_EXPR:\n+      CASE_CONVERT:\n+\texpr_node = TREE_OPERAND (expr_node, 0);\n+\tbreak;\n+\n+      case CONSTRUCTOR:\n+\tTREE_ADDRESSABLE (expr_node) = 1;\n+\treturn true;\n+\n+      case VAR_DECL:\n+      case PARM_DECL:\n+      case RESULT_DECL:\n+\tTREE_ADDRESSABLE (expr_node) = 1;\n+\treturn true;\n+\n+      case FUNCTION_DECL:\n+\tTREE_ADDRESSABLE (expr_node) = 1;\n+\treturn true;\n+\n+      case CONST_DECL:\n+\treturn (DECL_CONST_CORRESPONDING_VAR (expr_node)\n+\t\t&& (gnat_mark_addressable\n+\t\t    (DECL_CONST_CORRESPONDING_VAR (expr_node))));\n+      default:\n+\treturn true;\n+    }\n+}"}]}