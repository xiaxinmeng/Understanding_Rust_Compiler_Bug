{"sha": "d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBhNGE2MWMzZGU3YWMxMzFhZmMwMDE0YzZhODk3MGNhNmRjZGVjYQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2010-04-06T16:26:02Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2010-04-06T16:26:02Z"}, "message": "re PR fortran/39997 (Procedure(), pointer  & implicit typing: rejects-valid / accepts-invalid?)\n\n2010-04-06  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/39997\n        * intrinsic.c (add_functions): Add num_images.\n        * decl.c (gfc_match_end): Handle END CRITICAL.\n        * intrinsic.h (gfc_simplify_num_images): Add prototype.\n        * dump-parse-tree.c (show_code_node): Dump CRITICAL, ERROR STOP,\n        and SYNC.\n        * gfortran.h (gfc_statement): Add enum items for those.\n        (gfc_exec_op) Ditto.\n        (gfc_isym_id): Add num_images.\n        * trans-stmt.c (gfc_trans_stop): Handle ERROR STOP.\n        (gfc_trans_sync,gfc_trans_critical): New functions.\n        * trans-stmt.h (gfc_trans_stop,gfc_trans_sync,\n        gfc_trans_critical): Add/update prototypes.\n        * trans.c (gfc_trans_code): Handle CRITICAL, ERROR STOP,\n        and SYNC statements.\n        * trans.h (gfor_fndecl_error_stop_string) Add variable.\n        * resolve.c (resolve_sync): Add function.\n        (gfc_resolve_blocks): Handle CRITICAL.\n        (resolve_code): Handle CRITICAL, ERROR STOP,\n        (resolve_branch): Add CRITICAL constraint check.\n        and SYNC statements.\n        * st.c (gfc_free_statement): Add new statements.\n        * trans-decl.c (gfor_fndecl_error_stop_string): Global variable.\n        (gfc_build_builtin_function_decls): Initialize it.\n        * match.c (gfc_match_if): Handle ERROR STOP and SYNC.\n        (gfc_match_critical, gfc_match_error_stop, sync_statement,\n        gfc_match_sync_all, gfc_match_sync_images,\ngfc_match_sync_memory):\n        New functions.\n        (match_exit_cycle): Handle CRITICAL constraint.\n        (gfc_match_stopcode): Handle ERROR STOP.\n        * match.h (gfc_match_critical, gfc_match_error_stop,\n        gfc_match_sync_all, gfc_match_sync_images,\n        gfc_match_sync_memory): Add prototype.\n        * parse.c (decode_statement, gfc_ascii_statement,\n        parse_executable): Handle new statements.\n        (parse_critical_block): New function.\n        * parse.h (gfc_compile_state): Add COMP_CRITICAL.\n        * intrinsic.texi (num_images): Document new function.\n        * simplify.c (gfc_simplify_num_images): Add function.\n\n2010-04-06  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/39997\n        * gfortran.dg/coarray_1.f90: New test.\n        * gfortran.dg/coarray_2.f90: New test.\n        * gfortran.dg/coarray_3.f90: New test.\n\n2010-04-06  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/39997\n        * runtime/stop.c (error_stop_string): New function.\n        * gfortran.map (_gfortran_error_stop_string): Add.\n\nFrom-SVN: r158008", "tree": {"sha": "6b20ae56f767cd6edf0d68afa82cbb77738f5cfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b20ae56f767cd6edf0d68afa82cbb77738f5cfc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/comments", "author": null, "committer": null, "parents": [{"sha": "62daa13984dac4fbe37f94755978ad886925939d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62daa13984dac4fbe37f94755978ad886925939d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62daa13984dac4fbe37f94755978ad886925939d"}], "stats": {"total": 957, "additions": 922, "deletions": 35}, "files": [{"sha": "8af36683afa30ba2163ce7d4b0ce92fe4f99bff5", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -1,3 +1,45 @@\n+2010-04-06  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/39997\n+\t* intrinsic.c (add_functions): Add num_images.\n+\t* decl.c (gfc_match_end): Handle END CRITICAL.\n+\t* intrinsic.h (gfc_simplify_num_images): Add prototype.\n+\t* dump-parse-tree.c (show_code_node): Dump CRITICAL, ERROR STOP,\n+\tand SYNC.\n+\t* gfortran.h (gfc_statement): Add enum items for those.\n+\t(gfc_exec_op) Ditto.\n+\t(gfc_isym_id): Add num_images.\n+\t* trans-stmt.c (gfc_trans_stop): Handle ERROR STOP.\n+\t(gfc_trans_sync,gfc_trans_critical): New functions.\n+\t* trans-stmt.h (gfc_trans_stop,gfc_trans_sync,\n+\tgfc_trans_critical): Add/update prototypes.\n+\t* trans.c (gfc_trans_code): Handle CRITICAL, ERROR STOP,\n+\tand SYNC statements.\n+\t* trans.h (gfor_fndecl_error_stop_string) Add variable.\n+\t* resolve.c (resolve_sync): Add function.\n+\t(gfc_resolve_blocks): Handle CRITICAL.\n+\t(resolve_code): Handle CRITICAL, ERROR STOP,\n+\t(resolve_branch): Add CRITICAL constraint check.\n+\tand SYNC statements.\n+\t* st.c (gfc_free_statement): Add new statements.\n+\t* trans-decl.c (gfor_fndecl_error_stop_string): Global variable.\n+\t(gfc_build_builtin_function_decls): Initialize it.\n+\t* match.c (gfc_match_if): Handle ERROR STOP and SYNC.\n+\t(gfc_match_critical, gfc_match_error_stop, sync_statement,\n+\tgfc_match_sync_all, gfc_match_sync_images, gfc_match_sync_memory):\n+\tNew functions.\n+\t(match_exit_cycle): Handle CRITICAL constraint.\n+\t(gfc_match_stopcode): Handle ERROR STOP.\n+\t* match.h (gfc_match_critical, gfc_match_error_stop,\n+\tgfc_match_sync_all, gfc_match_sync_images,\n+\tgfc_match_sync_memory): Add prototype.\n+\t* parse.c (decode_statement, gfc_ascii_statement,\n+\tparse_executable): Handle new statements.\n+\t(parse_critical_block): New function.\n+\t* parse.h (gfc_compile_state): Add COMP_CRITICAL.\n+\t* intrinsic.texi (num_images): Document new function.\n+\t* simplify.c (gfc_simplify_num_images): Add function.\n+\n 2010-04-06  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/43178"}, {"sha": "923750388afcfabb2f2d115aa5873e9cd4b10fbc", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -5476,6 +5476,12 @@ gfc_match_end (gfc_statement *st)\n       eos_ok = 0;\n       break;\n \n+    case COMP_CRITICAL:\n+      *st = ST_END_CRITICAL;\n+      target = \" critical\";\n+      eos_ok = 0;\n+      break;\n+\n     case COMP_SELECT:\n     case COMP_SELECT_TYPE:\n       *st = ST_END_SELECT;\n@@ -5534,7 +5540,8 @@ gfc_match_end (gfc_statement *st)\n     {\n \n       if (*st != ST_ENDDO && *st != ST_ENDIF && *st != ST_END_SELECT\n-\t  && *st != ST_END_FORALL && *st != ST_END_WHERE && *st != ST_END_BLOCK)\n+\t  && *st != ST_END_FORALL && *st != ST_END_WHERE && *st != ST_END_BLOCK\n+\t  && *st != ST_END_CRITICAL)\n \treturn MATCH_YES;\n \n       if (!block_name)"}, {"sha": "6c67e7dedf3b6c405e77df01fed120b47259eacb", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -1,5 +1,5 @@\n /* Parse tree dumper\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Steven Bosscher\n \n@@ -1273,6 +1273,10 @@ show_code_node (int level, gfc_code *c)\n \n       break;\n \n+    case EXEC_ERROR_STOP:\n+      fputs (\"ERROR \", dumpfile);\n+      /* Fall through.  */\n+\n     case EXEC_STOP:\n       fputs (\"STOP \", dumpfile);\n \n@@ -1283,6 +1287,52 @@ show_code_node (int level, gfc_code *c)\n \n       break;\n \n+    case EXEC_SYNC_ALL:\n+      fputs (\"SYNC ALL \", dumpfile);\n+      if (c->expr2 != NULL)\n+\t{\n+\t  fputs (\" stat=\", dumpfile);\n+\t  show_expr (c->expr2);\n+\t}\n+      if (c->expr3 != NULL)\n+\t{\n+\t  fputs (\" errmsg=\", dumpfile);\n+\t  show_expr (c->expr3);\n+\t}\n+      break;\n+\n+    case EXEC_SYNC_MEMORY:\n+      fputs (\"SYNC MEMORY \", dumpfile);\n+      if (c->expr2 != NULL)\n+ \t{\n+\t  fputs (\" stat=\", dumpfile);\n+\t  show_expr (c->expr2);\n+\t}\n+      if (c->expr3 != NULL)\n+\t{\n+\t  fputs (\" errmsg=\", dumpfile);\n+\t  show_expr (c->expr3);\n+\t}\n+      break;\n+\n+    case EXEC_SYNC_IMAGES:\n+      fputs (\"SYNC IMAGES  image-set=\", dumpfile);\n+      if (c->expr1 != NULL)\n+\tshow_expr (c->expr1);\n+      else\n+\tfputs (\"* \", dumpfile);\n+      if (c->expr2 != NULL)\n+\t{\n+\t  fputs (\" stat=\", dumpfile);\n+\t  show_expr (c->expr2);\n+\t}\n+      if (c->expr3 != NULL)\n+\t{\n+\t  fputs (\" errmsg=\", dumpfile);\n+\t  show_expr (c->expr3);\n+\t}\n+      break;\n+\n     case EXEC_ARITHMETIC_IF:\n       fputs (\"IF \", dumpfile);\n       show_expr (c->expr1);\n@@ -1400,6 +1450,13 @@ show_code_node (int level, gfc_code *c)\n       fputs (\"END FORALL\", dumpfile);\n       break;\n \n+    case EXEC_CRITICAL:\n+      fputs (\"CRITICAL\\n\", dumpfile);\n+      show_code (level + 1, c->block->next);\n+      code_indent (level, 0);\n+      fputs (\"END CRITICAL\", dumpfile);\n+      break;\n+\n     case EXEC_DO:\n       fputs (\"DO \", dumpfile);\n "}, {"sha": "1f98824de75bef1cf80fc4c48910903063633deb", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -214,9 +214,9 @@ typedef enum\n   ST_END_FILE, ST_FINAL, ST_FLUSH, ST_END_FORALL, ST_END_FUNCTION, ST_ENDIF,\n   ST_END_INTERFACE, ST_END_MODULE, ST_END_PROGRAM, ST_END_SELECT,\n   ST_END_SUBROUTINE, ST_END_WHERE, ST_END_TYPE, ST_ENTRY, ST_EQUIVALENCE,\n-  ST_EXIT, ST_FORALL, ST_FORALL_BLOCK, ST_FORMAT, ST_FUNCTION, ST_GOTO,\n-  ST_IF_BLOCK, ST_IMPLICIT, ST_IMPLICIT_NONE, ST_IMPORT,\n-  ST_INQUIRE, ST_INTERFACE,\n+  ST_ERROR_STOP, ST_EXIT, ST_FORALL, ST_FORALL_BLOCK, ST_FORMAT, ST_FUNCTION,\n+  ST_GOTO, ST_IF_BLOCK, ST_IMPLICIT, ST_IMPLICIT_NONE, ST_IMPORT,\n+  ST_INQUIRE, ST_INTERFACE, ST_SYNC_ALL, ST_SYNC_MEMORY, ST_SYNC_IMAGES,\n   ST_PARAMETER, ST_MODULE, ST_MODULE_PROC, ST_NAMELIST, ST_NULLIFY, ST_OPEN,\n   ST_PAUSE, ST_PRIVATE, ST_PROGRAM, ST_PUBLIC, ST_READ, ST_RETURN, ST_REWIND,\n   ST_STOP, ST_SUBROUTINE, ST_TYPE, ST_USE, ST_WHERE_BLOCK, ST_WHERE, ST_WAIT, \n@@ -231,7 +231,7 @@ typedef enum\n   ST_OMP_PARALLEL, ST_OMP_PARALLEL_DO, ST_OMP_PARALLEL_SECTIONS,\n   ST_OMP_PARALLEL_WORKSHARE, ST_OMP_SECTIONS, ST_OMP_SECTION, ST_OMP_SINGLE,\n   ST_OMP_THREADPRIVATE, ST_OMP_WORKSHARE, ST_OMP_TASK, ST_OMP_END_TASK,\n-  ST_OMP_TASKWAIT, ST_PROCEDURE, ST_GENERIC,\n+  ST_OMP_TASKWAIT, ST_PROCEDURE, ST_GENERIC, ST_CRITICAL, ST_END_CRITICAL,\n   ST_GET_FCN_CHARACTERISTICS, ST_NONE\n }\n gfc_statement;\n@@ -462,6 +462,7 @@ enum gfc_isym_id\n   GFC_ISYM_NINT,\n   GFC_ISYM_NOT,\n   GFC_ISYM_NULL,\n+  GFC_ISYM_NUMIMAGES,\n   GFC_ISYM_OR,\n   GFC_ISYM_PACK,\n   GFC_ISYM_PERROR,\n@@ -1976,12 +1977,13 @@ gfc_forall_iterator;\n typedef enum\n {\n   EXEC_NOP = 1, EXEC_END_BLOCK, EXEC_ASSIGN, EXEC_LABEL_ASSIGN,\n-  EXEC_POINTER_ASSIGN,\n+  EXEC_POINTER_ASSIGN, EXEC_CRITICAL, EXEC_ERROR_STOP,\n   EXEC_GOTO, EXEC_CALL, EXEC_COMPCALL, EXEC_ASSIGN_CALL, EXEC_RETURN,\n   EXEC_ENTRY, EXEC_PAUSE, EXEC_STOP, EXEC_CONTINUE, EXEC_INIT_ASSIGN,\n   EXEC_IF, EXEC_ARITHMETIC_IF, EXEC_DO, EXEC_DO_WHILE, EXEC_SELECT, EXEC_BLOCK,\n   EXEC_FORALL, EXEC_WHERE, EXEC_CYCLE, EXEC_EXIT, EXEC_CALL_PPC,\n   EXEC_ALLOCATE, EXEC_DEALLOCATE, EXEC_END_PROCEDURE, EXEC_SELECT_TYPE,\n+  EXEC_SYNC_ALL, EXEC_SYNC_MEMORY, EXEC_SYNC_IMAGES,\n   EXEC_OPEN, EXEC_CLOSE, EXEC_WAIT,\n   EXEC_READ, EXEC_WRITE, EXEC_IOLENGTH, EXEC_TRANSFER, EXEC_DT_END,\n   EXEC_BACKSPACE, EXEC_ENDFILE, EXEC_INQUIRE, EXEC_REWIND, EXEC_FLUSH,"}, {"sha": "fbfc47af12c313bd6677a101ae454c13cd4aa9fe", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -2221,6 +2221,9 @@ add_functions (void)\n \n   make_generic (\"null\", GFC_ISYM_NULL, GFC_STD_F95);\n \n+  add_sym_0 (\"num_images\", GFC_ISYM_NUMIMAGES, CLASS_INQUIRY, ACTUAL_NO, BT_INTEGER, di, GFC_STD_F2008,\n+\t     NULL, gfc_simplify_num_images, NULL);\n+\n   add_sym_3 (\"pack\", GFC_ISYM_PACK, CLASS_TRANSFORMATIONAL, ACTUAL_NO, BT_REAL, dr, GFC_STD_F95,\n \t     gfc_check_pack, gfc_simplify_pack, gfc_resolve_pack,\n \t     ar, BT_REAL, dr, REQUIRED, msk, BT_LOGICAL, dl, REQUIRED,"}, {"sha": "b675de2509147a8d111227cc9701928f9b4eaf2d", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -1,7 +1,7 @@\n /* Header file for intrinsics check, resolve and simplify function\n    prototypes.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n-   Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n+   2010 Free Software Foundation, Inc.\n    Contributed by Andy Vaught & Katherine Holcomb\n \n This file is part of GCC.\n@@ -297,6 +297,7 @@ gfc_expr *gfc_simplify_nearest (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_new_line (gfc_expr *);\n gfc_expr *gfc_simplify_nint (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_null (gfc_expr *);\n+gfc_expr *gfc_simplify_num_images (void);\n gfc_expr *gfc_simplify_idnint (gfc_expr *);\n gfc_expr *gfc_simplify_not (gfc_expr *);\n gfc_expr *gfc_simplify_or (gfc_expr *, gfc_expr *);"}, {"sha": "52992ba0c41f264247b7e33b50843debd054bf6d", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -204,6 +204,7 @@ Some basic guidelines for editing this document:\n * @code{NINT}:          NINT,      Nearest whole number\n * @code{NOT}:           NOT,       Logical negation\n * @code{NULL}:          NULL,      Function that returns an disassociated pointer\n+* @code{NUM_IMAGES}:    NUM_IMAGES, Number of images\n * @code{OR}:            OR,        Bitwise logical OR\n * @code{PACK}:          PACK,      Pack an array into an array of rank one\n * @code{PERROR}:        PERROR,    Print system error message\n@@ -8375,6 +8376,49 @@ REAL, POINTER, DIMENSION(:) :: VEC => NULL ()\n \n \n \n+@node NUM_IMAGES\n+@section @code{NUM_IMAGES} --- Function that returns the number of images\n+@fnindex NUM_IMAGES\n+@cindex coarray, NUM_IMAGES\n+@cindex images, number of\n+\n+@table @asis\n+@item @emph{Description}:\n+Returns the number of images.\n+\n+@item @emph{Standard}:\n+Fortran 2008 and later\n+\n+@item @emph{Class}:\n+Transformational function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = NUM_IMAGES()}\n+\n+@item @emph{Arguments}: None.\n+\n+@item @emph{Return value}:\n+Scalar default-kind integer.\n+\n+@item @emph{Example}:\n+@smallexample\n+INTEGER :: value[*]\n+INTEGER :: i\n+value = THIS_IMAGE()\n+SYNC ALL\n+IF (THIS_IMAGE() == 1) THEN\n+  DO i = 1, NUM_IMAGES()\n+    WRITE(*,'(2(a,i0))') 'value[', i, '] is ', value[i]\n+  END DO\n+END IF\n+@end smallexample\n+\n+@item @emph{See also}:\n+@c FIXME: ref{THIS_IMAGE}\n+@end table\n+\n+\n+\n @node OR\n @section @code{OR} --- Bitwise logical OR\n @fnindex OR"}, {"sha": "48bb733b940190553c36a96d7599c6bef6b7170c", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 275, "deletions": 4, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -1,6 +1,6 @@\n /* Matching subroutines in all sizes, shapes and colors.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n-   Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n+   2010 Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of GCC.\n@@ -1547,6 +1547,7 @@ gfc_match_if (gfc_statement *if_type)\n   match (\"cycle\", gfc_match_cycle, ST_CYCLE)\n   match (\"deallocate\", gfc_match_deallocate, ST_DEALLOCATE)\n   match (\"end file\", gfc_match_endfile, ST_END_FILE)\n+  match (\"error stop\", gfc_match_error_stop, ST_ERROR_STOP)\n   match (\"exit\", gfc_match_exit, ST_EXIT)\n   match (\"flush\", gfc_match_flush, ST_FLUSH)\n   match (\"forall\", match_simple_forall, ST_FORALL)\n@@ -1562,6 +1563,9 @@ gfc_match_if (gfc_statement *if_type)\n   match (\"rewind\", gfc_match_rewind, ST_REWIND)\n   match (\"stop\", gfc_match_stop, ST_STOP)\n   match (\"wait\", gfc_match_wait, ST_WAIT)\n+  match (\"sync all\", gfc_match_sync_all, ST_SYNC_CALL);\n+  match (\"sync images\", gfc_match_sync_images, ST_SYNC_IMAGES);\n+  match (\"sync memory\", gfc_match_sync_memory, ST_SYNC_MEMORY);\n   match (\"where\", match_simple_where, ST_WHERE)\n   match (\"write\", gfc_match_write, ST_WRITE)\n \n@@ -1708,6 +1712,53 @@ gfc_free_iterator (gfc_iterator *iter, int flag)\n }\n \n \n+/* Match a CRITICAL statement.  */\n+match\n+gfc_match_critical (void)\n+{\n+  gfc_st_label *label = NULL;\n+\n+  if (gfc_match_label () == MATCH_ERROR)\n+    return MATCH_ERROR;\n+\n+  if (gfc_match (\" critical\") != MATCH_YES)\n+    return MATCH_NO;\n+\n+  if (gfc_match_st_label (&label) == MATCH_ERROR)\n+    return MATCH_ERROR;\n+\n+  if (gfc_match_eos () != MATCH_YES)\n+    {\n+      gfc_syntax_error (ST_CRITICAL);\n+      return MATCH_ERROR;\n+    }\n+\n+  if (gfc_pure (NULL))\n+    {\n+      gfc_error (\"Image control statement CRITICAL at %C in PURE procedure\");\n+      return MATCH_ERROR;\n+    }\n+\n+  if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: CRITICAL statement at %C\")\n+      == FAILURE)\n+    return MATCH_ERROR;\n+\n+  if (gfc_find_state (COMP_CRITICAL) == SUCCESS)\n+    {\n+      gfc_error (\"Nested CRITICAL block at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  new_st.op = EXEC_CRITICAL;\n+\n+  if (label != NULL\n+      && gfc_reference_st_label (label, ST_LABEL_TARGET) == FAILURE)\n+    return MATCH_ERROR;\n+\n+  return MATCH_YES;\n+}\n+\n+\n /* Match a BLOCK statement.  */\n \n match\n@@ -1871,6 +1922,12 @@ match_exit_cycle (gfc_statement st, gfc_exec_op op)\n       break;\n     else if (o == NULL && p->state == COMP_OMP_STRUCTURED_BLOCK)\n       o = p;\n+    else if (p->state == COMP_CRITICAL)\n+      {\n+\tgfc_error(\"%s statement at %C leaves CRITICAL construct\",\n+\t\t  gfc_ascii_statement (st));\n+\treturn MATCH_ERROR;\n+      }\n \n   if (p == NULL)\n     {\n@@ -1930,7 +1987,7 @@ gfc_match_cycle (void)\n }\n \n \n-/* Match a number or character constant after a STOP or PAUSE statement.  */\n+/* Match a number or character constant after an (ALL) STOP or PAUSE statement.  */\n \n static match\n gfc_match_stopcode (gfc_statement st)\n@@ -1978,7 +2035,27 @@ gfc_match_stopcode (gfc_statement st)\n       goto cleanup;\n     }\n \n-  new_st.op = st == ST_STOP ? EXEC_STOP : EXEC_PAUSE;\n+  if (st == ST_STOP && gfc_find_state (COMP_CRITICAL) == SUCCESS)\n+    {\n+      gfc_error (\"Image control statement STOP at %C in CRITICAL block\");\n+      return MATCH_ERROR;\n+    }\n+\n+  switch (st)\n+    {\n+    case ST_STOP:\n+      new_st.op = EXEC_STOP;\n+      break;\n+    case ST_ERROR_STOP:\n+      new_st.op = EXEC_ERROR_STOP;\n+      break;\n+    case ST_PAUSE:\n+      new_st.op = EXEC_PAUSE;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n   new_st.expr1 = e;\n   new_st.ext.stop_code = stop_code;\n \n@@ -2022,6 +2099,193 @@ gfc_match_stop (void)\n }\n \n \n+/* Match the ERROR STOP statement.  */\n+\n+match\n+gfc_match_error_stop (void)\n+{\n+  if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: ERROR STOP statement at %C\")\n+      == FAILURE)\n+    return MATCH_ERROR;\n+\n+  return gfc_match_stopcode (ST_ERROR_STOP);\n+}\n+\n+\n+/* Match SYNC ALL/IMAGES/MEMORY statement. Syntax:\n+     SYNC ALL [(sync-stat-list)]\n+     SYNC MEMORY [(sync-stat-list)]\n+     SYNC IMAGES (image-set [, sync-stat-list] )\n+   with sync-stat is int-expr or *.  */\n+\n+static match\n+sync_statement (gfc_statement st)\n+{\n+  match m;\n+  gfc_expr *tmp, *imageset, *stat, *errmsg;\n+  bool saw_stat, saw_errmsg;\n+\n+  tmp = imageset = stat = errmsg = NULL;\n+  saw_stat = saw_errmsg = false;\n+\n+  if (gfc_pure (NULL))\n+    {\n+      gfc_error (\"Image control statement SYNC at %C in PURE procedure\");\n+      return MATCH_ERROR;\n+    }\n+\n+  if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: SYNC statement at %C\")\n+      == FAILURE)\n+    return MATCH_ERROR;\n+\n+  if (gfc_find_state (COMP_CRITICAL) == SUCCESS)\n+    {\n+      gfc_error (\"Image control statement SYNC at %C in CRITICAL block\");\n+      return MATCH_ERROR;\n+    }\n+\t\n+  if (gfc_match_eos () == MATCH_YES)\n+    {\n+      if (st == ST_SYNC_IMAGES)\n+\tgoto syntax;\n+      goto done;\n+    }\n+\n+  if (gfc_match_char ('(') != MATCH_YES)\n+    goto syntax;\n+\n+  if (st == ST_SYNC_IMAGES)\n+    {\n+      /* Denote '*' as imageset == NULL.  */\n+      m = gfc_match_char ('*');\n+      if (m == MATCH_ERROR)\n+\tgoto syntax;\n+      if (m == MATCH_NO)\n+\t{\n+\t  if (gfc_match (\"%e\", &imageset) != MATCH_YES)\n+\t    goto syntax;\n+\t}\n+      m = gfc_match_char (',');\n+      if (m == MATCH_ERROR)\n+\tgoto syntax;\n+      if (m == MATCH_NO)\n+\t{\n+\t  m = gfc_match_char (')');\n+\t  if (m == MATCH_YES)\n+\t    goto done;\n+\t  goto syntax;\n+\t}\n+    }\n+\n+  for (;;)\n+    {\n+      m = gfc_match (\" stat = %v\", &tmp);\n+      if (m == MATCH_ERROR)\n+\tgoto syntax;\n+      if (m == MATCH_YES)\n+\t{\n+\t  if (saw_stat)\n+\t    {\n+\t      gfc_error (\"Redundant STAT tag found at %L \", &tmp->where);\n+\t      goto cleanup;\n+\t    }\n+\t  stat = tmp;\n+\t  saw_stat = true;\n+\n+\t  if (gfc_match_char (',') == MATCH_YES)\n+\t    continue;\n+\t}\n+\n+      m = gfc_match (\" errmsg = %v\", &tmp);\n+      if (m == MATCH_ERROR)\n+\tgoto syntax;\n+      if (m == MATCH_YES)\n+\t{\n+\t  if (saw_errmsg)\n+\t    {\n+\t      gfc_error (\"Redundant ERRMSG tag found at %L \", &tmp->where);\n+\t      goto cleanup;\n+\t    }\n+\t  errmsg = tmp;\n+\t  saw_errmsg = true;\n+\n+\t  if (gfc_match_char (',') == MATCH_YES)\n+\t    continue;\n+\t}\n+\n+      gfc_gobble_whitespace ();\n+\n+      if (gfc_peek_char () == ')')\n+\tbreak;\n+\n+      goto syntax;\n+    }\n+\n+  if (gfc_match (\" )%t\") != MATCH_YES)\n+    goto syntax;\n+\n+done:\n+  switch (st)\n+    {\n+    case ST_SYNC_ALL:\n+      new_st.op = EXEC_SYNC_ALL;\n+      break;\n+    case ST_SYNC_IMAGES:\n+      new_st.op = EXEC_SYNC_IMAGES;\n+      break;\n+    case ST_SYNC_MEMORY:\n+      new_st.op = EXEC_SYNC_MEMORY;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  new_st.expr1 = imageset;\n+  new_st.expr2 = stat;\n+  new_st.expr3 = errmsg;\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_syntax_error (st);\n+\n+cleanup:\n+  gfc_free_expr (tmp);\n+  gfc_free_expr (imageset);\n+  gfc_free_expr (stat);\n+  gfc_free_expr (errmsg);\n+\n+  return MATCH_ERROR;\n+}\n+\n+\n+/* Match SYNC ALL statement.  */\n+\n+match\n+gfc_match_sync_all (void)\n+{\n+  return sync_statement (ST_SYNC_ALL);\n+}\n+\n+\n+/* Match SYNC IMAGES statement.  */\n+\n+match\n+gfc_match_sync_images (void)\n+{\n+  return sync_statement (ST_SYNC_IMAGES);\n+}\n+\n+\n+/* Match SYNC MEMORY statement.  */\n+\n+match\n+gfc_match_sync_memory (void)\n+{\n+  return sync_statement (ST_SYNC_MEMORY);\n+}\n+\n+\n /* Match a CONTINUE statement.  */\n \n match\n@@ -2850,6 +3114,13 @@ gfc_match_return (void)\n   gfc_compile_state s;\n \n   e = NULL;\n+\n+  if (gfc_find_state (COMP_CRITICAL) == SUCCESS)\n+    {\n+      gfc_error (\"Image control statement RETURN at %C in CRITICAL block\");\n+      return MATCH_ERROR;\n+    }\n+\n   if (gfc_match_eos () == MATCH_YES)\n     goto done;\n "}, {"sha": "b03ee541819614b3dd689f73e00c9dfe427f57ba", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -69,15 +69,20 @@ match gfc_match_assignment (void);\n match gfc_match_if (gfc_statement *);\n match gfc_match_else (void);\n match gfc_match_elseif (void);\n+match gfc_match_critical (void);\n match gfc_match_block (void);\n match gfc_match_do (void);\n match gfc_match_cycle (void);\n match gfc_match_exit (void);\n match gfc_match_pause (void);\n match gfc_match_stop (void);\n+match gfc_match_error_stop (void);\n match gfc_match_continue (void);\n match gfc_match_assign (void);\n match gfc_match_goto (void);\n+match gfc_match_sync_all (void);\n+match gfc_match_sync_images (void);\n+match gfc_match_sync_memory (void);\n \n match gfc_match_allocate (void);\n match gfc_match_nullify (void);"}, {"sha": "7d935c33655bb0aabb44a6daa21e9004886ed100", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 94, "deletions": 6, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -291,9 +291,9 @@ decode_statement (void)\n   gfc_undo_symbols ();\n   gfc_current_locus = old_locus;\n \n-  /* Check for the IF, DO, SELECT, WHERE, FORALL and BLOCK statements, which\n-     might begin with a block label.  The match functions for these\n-     statements are unusual in that their keyword is not seen before\n+  /* Check for the IF, DO, SELECT, WHERE, FORALL, CRITICAL, and BLOCK\n+     statements, which might begin with a block label.  The match functions for\n+     these statements are unusual in that their keyword is not seen before\n      the matcher is called.  */\n \n   if (gfc_match_if (&st) == MATCH_YES)\n@@ -311,8 +311,9 @@ decode_statement (void)\n   gfc_undo_symbols ();\n   gfc_current_locus = old_locus;\n \n-  match (NULL, gfc_match_block, ST_BLOCK);\n   match (NULL, gfc_match_do, ST_DO);\n+  match (NULL, gfc_match_block, ST_BLOCK);\n+  match (NULL, gfc_match_critical, ST_CRITICAL);\n   match (NULL, gfc_match_select, ST_SELECT_CASE);\n   match (NULL, gfc_match_select_type, ST_SELECT_TYPE);\n \n@@ -362,6 +363,7 @@ decode_statement (void)\n       match (\"else\", gfc_match_else, ST_ELSE);\n       match (\"else where\", gfc_match_elsewhere, ST_ELSEWHERE);\n       match (\"else if\", gfc_match_elseif, ST_ELSEIF);\n+      match (\"error stop\", gfc_match_error_stop, ST_ERROR_STOP);\n       match (\"enum , bind ( c )\", gfc_match_enum, ST_ENUM);\n \n       if (gfc_match_end (&st) == MATCH_YES)\n@@ -432,6 +434,9 @@ decode_statement (void)\n       match (\"sequence\", gfc_match_eos, ST_SEQUENCE);\n       match (\"stop\", gfc_match_stop, ST_STOP);\n       match (\"save\", gfc_match_save, ST_ATTR_DECL);\n+      match (\"sync all\", gfc_match_sync_all, ST_SYNC_ALL);\n+      match (\"sync images\", gfc_match_sync_images, ST_SYNC_IMAGES);\n+      match (\"sync memory\", gfc_match_sync_memory, ST_SYNC_MEMORY);\n       break;\n \n     case 't':\n@@ -936,7 +941,8 @@ next_statement (void)\n   case ST_POINTER_ASSIGNMENT: case ST_EXIT: case ST_CYCLE: \\\n   case ST_ASSIGNMENT: case ST_ARITHMETIC_IF: case ST_WHERE: case ST_FORALL: \\\n   case ST_LABEL_ASSIGNMENT: case ST_FLUSH: case ST_OMP_FLUSH: \\\n-  case ST_OMP_BARRIER: case ST_OMP_TASKWAIT\n+  case ST_OMP_BARRIER: case ST_OMP_TASKWAIT: case ST_ERROR_STOP: \\\n+  case ST_SYNC_ALL: case ST_SYNC_IMAGES: case ST_SYNC_MEMORY\n \n /* Statements that mark other executable statements.  */\n \n@@ -948,7 +954,7 @@ next_statement (void)\n   case ST_OMP_CRITICAL: case ST_OMP_MASTER: case ST_OMP_SINGLE: \\\n   case ST_OMP_DO: case ST_OMP_PARALLEL_DO: case ST_OMP_ATOMIC: \\\n   case ST_OMP_WORKSHARE: case ST_OMP_PARALLEL_WORKSHARE: \\\n-  case ST_OMP_TASK\n+  case ST_OMP_TASK: case ST_CRITICAL\n \n /* Declaration statements */\n \n@@ -1082,6 +1088,7 @@ check_statement_label (gfc_statement st)\n     case ST_ENDDO:\n     case ST_ENDIF:\n     case ST_END_SELECT:\n+    case ST_END_CRITICAL:\n     case_executable:\n     case_exec_markers:\n       type = ST_LABEL_TARGET;\n@@ -1176,6 +1183,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_CONTAINS:\n       p = \"CONTAINS\";\n       break;\n+    case ST_CRITICAL:\n+      p = \"CRITICAL\";\n+      break;\n     case ST_CYCLE:\n       p = \"CYCLE\";\n       break;\n@@ -1209,6 +1219,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_END_BLOCK_DATA:\n       p = \"END BLOCK DATA\";\n       break;\n+    case ST_END_CRITICAL:\n+      p = \"END CRITICAL\";\n+      break;\n     case ST_ENDDO:\n       p = \"END DO\";\n       break;\n@@ -1251,6 +1264,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_EQUIVALENCE:\n       p = \"EQUIVALENCE\";\n       break;\n+    case ST_ERROR_STOP:\n+      p = \"ERROR STOP\";\n+      break;\n     case ST_EXIT:\n       p = \"EXIT\";\n       break;\n@@ -1339,6 +1355,15 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_STOP:\n       p = \"STOP\";\n       break;\n+    case ST_SYNC_ALL:\n+      p = \"SYNC ALL\";\n+      break;\n+    case ST_SYNC_IMAGES:\n+      p = \"SYNC IMAGES\";\n+      break;\n+    case ST_SYNC_MEMORY:\n+      p = \"SYNC MEMORY\";\n+      break;\n     case ST_SUBROUTINE:\n       p = \"SUBROUTINE\";\n       break;\n@@ -1555,6 +1580,7 @@ accept_statement (gfc_statement st)\n \n     case ST_ENDIF:\n     case ST_END_SELECT:\n+    case ST_END_CRITICAL:\n       if (gfc_statement_label != NULL)\n \t{\n \t  new_st.op = EXEC_END_BLOCK;\n@@ -3047,6 +3073,61 @@ check_do_closure (void)\n static void parse_progunit (gfc_statement);\n \n \n+/* Parse a CRITICAL block.  */\n+\n+static void\n+parse_critical_block (void)\n+{\n+  gfc_code *top, *d;\n+  gfc_state_data s;\n+  gfc_statement st;\n+\n+  s.ext.end_do_label = new_st.label1;\n+\n+  accept_statement (ST_CRITICAL);\n+  top = gfc_state_stack->tail;\n+\n+  push_state (&s, COMP_CRITICAL, gfc_new_block);\n+\n+  d = add_statement ();\n+  d->op = EXEC_CRITICAL;\n+  top->block = d;\n+\n+  do\n+    {\n+      st = parse_executable (ST_NONE);\n+\n+      switch (st)\n+\t{\n+\t  case ST_NONE:\n+\t    unexpected_eof ();\n+\t    break;\n+\n+\t  case ST_END_CRITICAL:\n+\t    if (s.ext.end_do_label != NULL\n+\t\t&& s.ext.end_do_label != gfc_statement_label)\n+\t      gfc_error_now (\"Statement label in END CRITICAL at %C does not \"\n+\t\t\t     \"match CRITIAL label\");\n+\n+\t    if (gfc_statement_label != NULL)\n+\t      {\n+\t\tnew_st.op = EXEC_NOP;\n+\t\tadd_statement ();\n+\t      }\n+\t    break;\n+\n+\t  default:\n+\t    unexpected_statement (st);\n+\t    break;\n+\t}\n+    }\n+  while (st != ST_END_CRITICAL);\n+\n+  pop_state ();\n+  accept_statement (st);\n+}\n+\n+\n /* Set up the local namespace for a BLOCK construct.  */\n \n gfc_namespace*\n@@ -3472,9 +3553,12 @@ parse_executable (gfc_statement st)\n \t  case ST_CYCLE:\n \t  case ST_PAUSE:\n \t  case ST_STOP:\n+\t  case ST_ERROR_STOP:\n \t  case ST_END_SUBROUTINE:\n \n \t  case ST_DO:\n+\t  case ST_CRITICAL:\n+\t  case ST_BLOCK:\n \t  case ST_FORALL:\n \t  case ST_WHERE:\n \t  case ST_SELECT_CASE:\n@@ -3522,6 +3606,10 @@ parse_executable (gfc_statement st)\n \t    return ST_IMPLIED_ENDDO;\n \t  break;\n \n+\tcase ST_CRITICAL:\n+\t  parse_critical_block ();\n+\t  break;\n+\n \tcase ST_WHERE_BLOCK:\n \t  parse_where_block ();\n \t  break;"}, {"sha": "649e54dac829f1c3fd9e6628eb4d3a8cf8dba259", "filename": "gcc/fortran/parse.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -1,5 +1,5 @@\n /* Parser header\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Steven Bosscher\n \n@@ -32,7 +32,7 @@ typedef enum\n   COMP_BLOCK_DATA, COMP_INTERFACE, COMP_DERIVED, COMP_DERIVED_CONTAINS,\n   COMP_BLOCK, COMP_IF,\n   COMP_DO, COMP_SELECT, COMP_FORALL, COMP_WHERE, COMP_CONTAINS, COMP_ENUM,\n-  COMP_SELECT_TYPE, COMP_OMP_STRUCTURED_BLOCK\n+  COMP_SELECT_TYPE, COMP_OMP_STRUCTURED_BLOCK, COMP_CRITICAL\n }\n gfc_compile_state;\n "}, {"sha": "8ef347d1ac8abbb474980c02897a173395d2ce5e", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 75, "deletions": 3, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -7315,6 +7315,48 @@ find_reachable_labels (gfc_code *block)\n     }\n }\n \n+\n+static void\n+resolve_sync (gfc_code *code)\n+{\n+  /* Check imageset. The * case matches expr1 == NULL.  */\n+  if (code->expr1)\n+    {\n+      if (code->expr1->ts.type != BT_INTEGER || code->expr1->rank > 1)\n+\tgfc_error (\"Imageset argument at %L must be a scalar or rank-1 \"\n+\t\t   \"INTEGER expression\", &code->expr1->where);\n+      if (code->expr1->expr_type == EXPR_CONSTANT && code->expr1->rank == 0\n+\t  && mpz_cmp_si (code->expr1->value.integer, 1) < 0)\n+\tgfc_error (\"Imageset argument at %L must between 1 and num_images()\",\n+\t\t   &code->expr1->where);\n+      else if (code->expr1->expr_type == EXPR_ARRAY\n+\t       && gfc_simplify_expr (code->expr1, 0) == SUCCESS)\n+\t{\n+\t   gfc_constructor *cons;\n+\t   for (cons = code->expr1->value.constructor; cons; cons = cons->next)\n+\t     if (cons->expr->expr_type == EXPR_CONSTANT\n+\t\t &&  mpz_cmp_si (cons->expr->value.integer, 1) < 0)\n+\t       gfc_error (\"Imageset argument at %L must between 1 and \"\n+\t\t\t  \"num_images()\", &cons->expr->where);\n+\t}\n+    }\n+\n+  /* Check STAT.  */\n+  if (code->expr2\n+      && (code->expr2->ts.type != BT_INTEGER || code->expr2->rank != 0\n+\t  || code->expr2->expr_type != EXPR_VARIABLE))\n+    gfc_error (\"STAT= argument at %L must be a scalar INTEGER variable\",\n+\t       &code->expr2->where);\n+\n+  /* Check ERRMSG.  */\n+  if (code->expr3\n+      && (code->expr3->ts.type != BT_CHARACTER || code->expr3->rank != 0\n+\t  || code->expr3->expr_type != EXPR_VARIABLE))\n+    gfc_error (\"ERRMSG= argument at %L must be a scalar CHARACTER variable\",\n+\t       &code->expr3->where);\n+}\n+\n+\n /* Given a branch to a label, see if the branch is conforming.\n    The code node describes where the branch is located.  */\n \n@@ -7355,15 +7397,36 @@ resolve_branch (gfc_st_label *label, gfc_code *code)\n      the bitmap reachable_labels.  */\n \n   if (bitmap_bit_p (cs_base->reachable_labels, label->value))\n-    return;\n+    {\n+      /* Check now whether there is a CRITICAL construct; if so, check\n+\t whether the label is still visible outside of the CRITICAL block,\n+\t which is invalid.  */\n+      for (stack = cs_base; stack; stack = stack->prev)\n+\tif (stack->current->op == EXEC_CRITICAL\n+\t    && bitmap_bit_p (stack->reachable_labels, label->value))\n+\t  gfc_error (\"GOTO statement at %L leaves CRITICAL construct for label\"\n+\t\t      \" at %L\", &code->loc, &label->where);\n+\n+      return;\n+    }\n \n   /* Step four:  If we haven't found the label in the bitmap, it may\n     still be the label of the END of the enclosing block, in which\n     case we find it by going up the code_stack.  */\n \n   for (stack = cs_base; stack; stack = stack->prev)\n-    if (stack->current->next && stack->current->next->here == label)\n-      break;\n+    {\n+      if (stack->current->next && stack->current->next->here == label)\n+\tbreak;\n+      if (stack->current->op == EXEC_CRITICAL)\n+\t{\n+\t  /* Note: A label at END CRITICAL does not leave the CRITICAL\n+\t     construct as END CRITICAL is still part of it.  */\n+\t  gfc_error (\"GOTO statement at %L leaves CRITICAL construct for label\"\n+\t\t      \" at %L\", &code->loc, &label->where);\n+\t  return;\n+\t}\n+    }\n \n   if (stack)\n     {\n@@ -7788,6 +7851,7 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n \tcase EXEC_FORALL:\n \tcase EXEC_DO:\n \tcase EXEC_DO_WHILE:\n+\tcase EXEC_CRITICAL:\n \tcase EXEC_READ:\n \tcase EXEC_WRITE:\n \tcase EXEC_IOLENGTH:\n@@ -8068,10 +8132,18 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \tcase EXEC_CYCLE:\n \tcase EXEC_PAUSE:\n \tcase EXEC_STOP:\n+\tcase EXEC_ERROR_STOP:\n \tcase EXEC_EXIT:\n \tcase EXEC_CONTINUE:\n \tcase EXEC_DT_END:\n \tcase EXEC_ASSIGN_CALL:\n+\tcase EXEC_CRITICAL:\n+\t  break;\n+\n+\tcase EXEC_SYNC_ALL:\n+\tcase EXEC_SYNC_IMAGES:\n+\tcase EXEC_SYNC_MEMORY:\n+\t  resolve_sync (code);\n \t  break;\n \n \tcase EXEC_ENTRY:"}, {"sha": "50cd6da7591fd31ec5b9db75d1d2b6cfcf49bff3", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -1,6 +1,6 @@\n /* Simplify intrinsic functions at compile-time.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n-   Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n+   2010 Free Software Foundation, Inc.\n    Contributed by Andy Vaught & Katherine Holcomb\n \n This file is part of GCC.\n@@ -1928,6 +1928,7 @@ gfc_simplify_exp (gfc_expr *x)\n   return range_check (result, \"EXP\");\n }\n \n+\n gfc_expr *\n gfc_simplify_exponent (gfc_expr *x)\n {\n@@ -3934,6 +3935,17 @@ gfc_simplify_null (gfc_expr *mold)\n }\n \n \n+gfc_expr *\n+gfc_simplify_num_images (void)\n+{\n+  gfc_expr *result;\n+  /* FIXME: gfc_current_locus is wrong.  */\n+  result = gfc_constant_result (BT_INTEGER, gfc_default_integer_kind, &gfc_current_locus);\n+  mpz_set_si (result->value.integer, 1);\n+  return result;\n+}\n+\n+\n gfc_expr *\n gfc_simplify_or (gfc_expr *x, gfc_expr *y)\n {"}, {"sha": "ffef22d11409ef2519d96b9fa430ba148e7def3b", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -1,5 +1,5 @@\n /* Build executable statement trees.\n-   Copyright (C) 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2009\n+   Copyright (C) 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -98,6 +98,7 @@ gfc_free_statement (gfc_code *p)\n     case EXEC_IF:\n     case EXEC_PAUSE:\n     case EXEC_STOP:\n+    case EXEC_ERROR_STOP:\n     case EXEC_EXIT:\n     case EXEC_WHERE:\n     case EXEC_IOLENGTH:\n@@ -108,6 +109,10 @@ gfc_free_statement (gfc_code *p)\n     case EXEC_LABEL_ASSIGN:\n     case EXEC_ENTRY:\n     case EXEC_ARITHMETIC_IF:\n+    case EXEC_CRITICAL:\n+    case EXEC_SYNC_ALL:\n+    case EXEC_SYNC_IMAGES:\n+    case EXEC_SYNC_MEMORY:\n       break;\n \n     case EXEC_BLOCK:"}, {"sha": "53c4b475add94aa23b3ae370200c942b1430bd03", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -85,6 +85,7 @@ tree gfor_fndecl_pause_numeric;\n tree gfor_fndecl_pause_string;\n tree gfor_fndecl_stop_numeric;\n tree gfor_fndecl_stop_string;\n+tree gfor_fndecl_error_stop_string;\n tree gfor_fndecl_runtime_error;\n tree gfor_fndecl_runtime_error_at;\n tree gfor_fndecl_runtime_warning_at;\n@@ -2725,6 +2726,13 @@ gfc_build_builtin_function_decls (void)\n   /* Stop doesn't return.  */\n   TREE_THIS_VOLATILE (gfor_fndecl_stop_string) = 1;\n \n+  gfor_fndecl_error_stop_string =\n+    gfc_build_library_function_decl (get_identifier (PREFIX(\"error_stop_string\")),\n+\t\t\t\t     void_type_node, 2, pchar_type_node,\n+                                     gfc_int4_type_node);\n+  /* ERROR STOP doesn't return.  */\n+  TREE_THIS_VOLATILE (gfor_fndecl_error_stop_string) = 1;\n+\n   gfor_fndecl_pause_numeric =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"pause_numeric\")),\n \t\t\t\t     void_type_node, 1, gfc_int4_type_node);"}, {"sha": "0b215f2395d5ea03c28c145b852b04cf6e5a3378", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -576,7 +576,7 @@ gfc_trans_pause (gfc_code * code)\n    to a runtime library call.  */\n \n tree\n-gfc_trans_stop (gfc_code * code)\n+gfc_trans_stop (gfc_code *code, bool error_stop)\n {\n   tree gfc_int4_type_node = gfc_get_int_type (4);\n   gfc_se se;\n@@ -586,7 +586,6 @@ gfc_trans_stop (gfc_code * code)\n   gfc_init_se (&se, NULL);\n   gfc_start_block (&se.pre);\n \n-\n   if (code->expr1 == NULL)\n     {\n       tmp = build_int_cst (gfc_int4_type_node, code->ext.stop_code);\n@@ -597,8 +596,9 @@ gfc_trans_stop (gfc_code * code)\n     {\n       gfc_conv_expr_reference (&se, code->expr1);\n       tmp = build_call_expr_loc (input_location,\n-\t\t\t     gfor_fndecl_stop_string, 2,\n-\t\t\t     se.expr, se.string_length);\n+\t\t\t     error_stop ? gfor_fndecl_error_stop_string\n+\t\t\t\t      : gfor_fndecl_stop_string,\n+\t\t\t     2, se.expr, se.string_length);\n     }\n \n   gfc_add_expr_to_block (&se.pre, tmp);\n@@ -609,6 +609,47 @@ gfc_trans_stop (gfc_code * code)\n }\n \n \n+tree\n+gfc_trans_sync (gfc_code *code, gfc_exec_op type __attribute__ ((unused)))\n+{\n+  gfc_se se;\n+\n+  if ((code->expr1 && (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)) || code->expr2)\n+    {\n+      gfc_init_se (&se, NULL);\n+      gfc_start_block (&se.pre);\n+    }\n+\n+  /* Check SYNC IMAGES(imageset) for valid image index.\n+     FIXME: Add a check for image-set arrays. */\n+  if (code->expr1 && (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n+      && code->expr1->rank == 0)\n+    {\n+      tree cond;\n+      gfc_conv_expr (&se, code->expr1);\n+      cond = fold_build2 (NE_EXPR, boolean_type_node, se.expr,\n+\t\t\t  build_int_cst (TREE_TYPE (se.expr), 1));\n+      gfc_trans_runtime_check (true, false, cond, &se.pre,\n+\t\t\t       &code->expr1->where, \"Invalid image number \"\n+\t\t\t       \"%d in SYNC IMAGES\",\n+\t\t\t       fold_convert (integer_type_node, se.expr));\n+    }\n+\n+  /* If STAT is present, set it to zero.  */\n+  if (code->expr2)\n+    {\n+      gcc_assert (code->expr2->expr_type == EXPR_VARIABLE);\n+      gfc_conv_expr (&se, code->expr2);\n+      gfc_add_modify (&se.pre, se.expr, build_int_cst (TREE_TYPE (se.expr), 0));\n+    }\n+\n+  if ((code->expr1 && (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)) || code->expr2)\n+    return gfc_finish_block (&se.pre);\n+ \n+  return NULL_TREE;\n+}\n+\n+\n /* Generate GENERIC for the IF construct. This function also deals with\n    the simple IF statement, because the front end translates the IF\n    statement into an IF construct.\n@@ -769,6 +810,21 @@ gfc_trans_arithmetic_if (gfc_code * code)\n }\n \n \n+/* Translate a CRITICAL block. */\n+tree\n+gfc_trans_critical (gfc_code *code)\n+{\n+  stmtblock_t block;\n+  tree tmp;\n+\n+  gfc_start_block (&block);\n+  tmp = gfc_trans_code (code->block->next);\n+  gfc_add_expr_to_block (&block, tmp);\n+\n+  return gfc_finish_block (&block);\n+}\n+\n+\n /* Translate a BLOCK construct.  This is basically what we would do for a\n    procedure body.  */\n "}, {"sha": "b34954564623b101fa7140cd3f4464adf11648bc", "filename": "gcc/fortran/trans-stmt.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Ftrans-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Ftrans-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.h?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -36,13 +36,14 @@ tree gfc_trans_class_assign (gfc_code *code);\n \n /* trans-stmt.c */\n tree gfc_trans_cycle (gfc_code *);\n+tree gfc_trans_critical (gfc_code *);\n tree gfc_trans_exit (gfc_code *);\n tree gfc_trans_label_assign (gfc_code *);\n tree gfc_trans_label_here (gfc_code *);\n tree gfc_trans_goto (gfc_code *);\n tree gfc_trans_entry (gfc_code *);\n tree gfc_trans_pause (gfc_code *);\n-tree gfc_trans_stop (gfc_code *);\n+tree gfc_trans_stop (gfc_code *, bool);\n tree gfc_trans_call (gfc_code *, bool, tree, tree, bool);\n tree gfc_trans_return (gfc_code *);\n tree gfc_trans_if (gfc_code *);\n@@ -51,6 +52,7 @@ tree gfc_trans_block_construct (gfc_code *);\n tree gfc_trans_do (gfc_code *, tree);\n tree gfc_trans_do_while (gfc_code *);\n tree gfc_trans_select (gfc_code *);\n+tree gfc_trans_sync (gfc_code *, gfc_exec_op);\n tree gfc_trans_forall (gfc_code *);\n tree gfc_trans_where (gfc_code *);\n tree gfc_trans_allocate (gfc_code *);"}, {"sha": "c1993f90ddd0e46bcea5451dd739c2578d59f159", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -1105,6 +1105,10 @@ trans_code (gfc_code * code, tree cond)\n \t  res = NULL_TREE;\n \t  break;\n \n+\tcase EXEC_CRITICAL:\n+\t  res = gfc_trans_critical (code);\n+\t  break;\n+\n \tcase EXEC_CYCLE:\n \t  res = gfc_trans_cycle (code);\n \t  break;\n@@ -1126,7 +1130,8 @@ trans_code (gfc_code * code, tree cond)\n \t  break;\n \n \tcase EXEC_STOP:\n-\t  res = gfc_trans_stop (code);\n+\tcase EXEC_ERROR_STOP:\n+\t  res = gfc_trans_stop (code, code->op == EXEC_ERROR_STOP);\n \t  break;\n \n \tcase EXEC_CALL:\n@@ -1191,6 +1196,12 @@ trans_code (gfc_code * code, tree cond)\n \t  res = gfc_trans_flush (code);\n \t  break;\n \n+\tcase EXEC_SYNC_ALL:\n+\tcase EXEC_SYNC_IMAGES:\n+\tcase EXEC_SYNC_MEMORY:\n+\t  res = gfc_trans_sync (code, code->op);\n+\t  break;\n+\n \tcase EXEC_FORALL:\n \t  res = gfc_trans_forall (code);\n \t  break;"}, {"sha": "fe34f6911274a2c0589c56d7b67eb7242a3774e6", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -534,6 +534,7 @@ extern GTY(()) tree gfor_fndecl_pause_numeric;\n extern GTY(()) tree gfor_fndecl_pause_string;\n extern GTY(()) tree gfor_fndecl_stop_numeric;\n extern GTY(()) tree gfor_fndecl_stop_string;\n+extern GTY(()) tree gfor_fndecl_error_stop_string;\n extern GTY(()) tree gfor_fndecl_runtime_error;\n extern GTY(()) tree gfor_fndecl_runtime_error_at;\n extern GTY(()) tree gfor_fndecl_runtime_warning_at;"}, {"sha": "a65ba45835b79851dc17ceeb9c33e1043806c597", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -1,3 +1,10 @@\n+2010-04-06  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/39997\n+\t* gfortran.dg/coarray_1.f90: New test.\n+\t* gfortran.dg/coarray_2.f90: New test.\n+\t* gfortran.dg/coarray_3.f90: New test.\n+\n 2010-04-06  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/43648"}, {"sha": "ba10d64a3ef7fab7e5badbd80df9bb994263281b", "filename": "gcc/testsuite/gfortran.dg/coarray_1.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_1.f90?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+!\n+! Coarray support\n+! PR fortran/18918\n+!\n+implicit none\n+integer :: n\n+critical  ! { dg-error \"Fortran 2008:\" }\n+  sync all()  ! { dg-error \"Fortran 2008:\" }\n+end critical ! { dg-error \"Expecting END PROGRAM\" }\n+sync memory  ! { dg-error \"Fortran 2008:\" }\n+sync images(*)  ! { dg-error \"Fortran 2008:\" }\n+\n+! num_images is implicitly defined:\n+n = num_images()  ! { dg-error \"convert UNKNOWN to INTEGER\" }\n+error stop 'stop'  ! { dg-error \"Fortran 2008:\" }\n+end"}, {"sha": "1fcb9b8b714ac96dc8e5888ed6e236f15f74fcdd", "filename": "gcc/testsuite/gfortran.dg/coarray_2.f90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_2.f90?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -0,0 +1,46 @@\n+! { dg-do run }\n+! { dg-shouldfail \"error stop\" }\n+! \n+! Coarray support\n+! PR fortran/18918\n+\n+implicit none\n+integer :: n\n+character(len=30) :: str\n+critical\n+end critical\n+myCr: critical\n+end critical myCr\n+  sync all\n+  sync all ( )\n+  n = 5\n+  sync all (stat=n)\n+  if (n /= 0) call abort()\n+  n = 5\n+  sync all (stat=n,errmsg=str)\n+  if (n /= 0) call abort()\n+  sync all (errmsg=str)\n+\n+  sync memory\n+  sync memory ( )\n+  n = 5\n+  sync memory (stat=n)\n+  if (n /= 0) call abort()\n+  n = 5\n+  sync memory (errmsg=str,stat=n)\n+  if (n /= 0) call abort()\n+  sync memory (errmsg=str)\n+\n+sync images (*, stat=n)\n+sync images (1, errmsg=str)\n+sync images ([1],errmsg=str,stat=n)\n+\n+sync images (*)\n+sync images (1)\n+sync images ([1])\n+\n+if (num_images() /= 1) call abort()\n+error stop 'stop'\n+end\n+\n+! { dg-output \"ERROR STOP stop\" }"}, {"sha": "648f2fa9b39994d9a24fdebb3f5ea38fe76b6863", "filename": "gcc/testsuite/gfortran.dg/coarray_3.f90", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_3.f90?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -0,0 +1,99 @@\n+! { dg-do compile }\n+! \n+! Coarray support\n+! PR fortran/18918\n+\n+implicit none\n+integer :: n, m(1), k\n+character(len=30) :: str(2)\n+\n+critical fkl ! { dg-error \"Syntax error in CRITICAL\" }\n+end critical fkl ! { dg-error \"Expecting END PROGRAM\" }\n+\n+sync all (stat=1) ! { dg-error \"Syntax error in SYNC ALL\" }\n+sync all ( stat = n,stat=k) ! { dg-error \"Redundant STAT\" }\n+sync memory (errmsg=str)\n+sync memory (errmsg=n) ! { dg-error \"must be a scalar CHARACTER variable\" }\n+sync images (*, stat=1.0) ! { dg-error \"Syntax error in SYNC IMAGES\" }\n+sync images (-1) ! { dg-error \"must between 1 and num_images\" }\n+sync images (1)\n+sync images ( [ 1 ])\n+sync images ( m(1:0) ) \n+sync images ( reshape([1],[1,1])) ! { dg-error \"must be a scalar or rank-1\" }\n+end\n+\n+subroutine foo\n+critical\n+  stop 'error' ! { dg-error \"Image control statement STOP\" }\n+  sync all     ! { dg-error \"Image control statement SYNC\" }\n+  return 1     ! { dg-error \"Image control statement RETURN\" }\n+  critical     ! { dg-error \"Nested CRITICAL block\" }\n+  end critical \n+end critical   ! { dg-error \"Expecting END SUBROUTINE\" }\n+end\n+\n+subroutine bar()\n+do\n+  critical\n+    cycle ! { dg-error \"leaves CRITICAL construct\" }\n+  end critical\n+end do\n+\n+outer: do\n+  critical\n+    do\n+      exit\n+      exit outer ! { dg-error \"leaves CRITICAL construct\" }\n+    end do\n+  end critical\n+end do outer\n+end subroutine bar\n+\n+\n+subroutine sub()\n+333 continue ! { dg-error \"leaves CRITICAL construct\" }\n+do\n+  critical\n+    if (.false.) then\n+      goto 333 ! { dg-error \"leaves CRITICAL construct\" }\n+      goto 777\n+777 end if\n+  end critical\n+end do\n+\n+if (.true.) then\n+outer: do\n+  critical\n+    do\n+      goto 444\n+      goto 555 ! { dg-error \"leaves CRITICAL construct\" }\n+    end do\n+444 continue\n+  end critical\n+ end do outer\n+555 end if ! { dg-error \"leaves CRITICAL construct\" }\n+end subroutine sub\n+\n+pure subroutine pureSub()\n+  critical ! { dg-error \"Image control statement CRITICAL\" }\n+  end critical ! { dg-error \"Expecting END SUBROUTINE statement\" }\n+  sync all ! { dg-error \"Image control statement SYNC\" }\n+  error stop ! { dg-error \"not allowed in PURE procedure\" }\n+end subroutine pureSub\n+\n+\n+SUBROUTINE TEST\n+   goto 10 ! { dg-warning \"is not in the same block\" }\n+   CRITICAL\n+     goto 5  ! OK\n+5    continue ! { dg-warning \"is not in the same block\" }\n+     goto 10 ! OK\n+     goto 20 ! { dg-error \"leaves CRITICAL construct\" }\n+     goto 30 ! { dg-error \"leaves CRITICAL construct\" }\n+10 END CRITICAL ! { dg-warning \"is not in the same block\" }\n+   goto 5 ! { dg-warning \"is not in the same block\" }\n+20 continue ! { dg-error \"leaves CRITICAL construct\" }\n+   BLOCK\n+30   continue ! { dg-error \"leaves CRITICAL construct\" }\n+   END BLOCK\n+end SUBROUTINE TEST"}, {"sha": "78c6b04e9c9a86c2361a7108d93e58a7385ac2cc", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -1,3 +1,9 @@\n+2010-04-06  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/39997\n+\t* runtime/stop.c (error_stop_string): New function.\n+\t* gfortran.map (_gfortran_error_stop_string): Add.\n+\n 2010-04-02  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* Makefile.in: Regenerate.\n@@ -7,7 +13,7 @@\n \n \tPR libfortran/43605\n \t* io/intrinsics.c (gf_ftell): New function, seek to correct offset.\n-        (ftell): Call gf_ftell.\n+\t(ftell): Call gf_ftell.\n \t(FTELL_SUB): Likewise.\n \n 2010-04-01  Paul Thomas  <pault@gcc.gnu.org>"}, {"sha": "bcca95788f396dd10d2b10013efc4a42063be0ed", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -1098,6 +1098,11 @@ GFORTRAN_1.2 {\n     _gfortran_is_extension_of;\n } GFORTRAN_1.1; \n \n+GFORTRAN_1.3 {\n+  global:\n+    _gfortran_error_stop_string;\n+} GFORTRAN_1.2; \n+\n F2C_1.0 {\n   global:\n     _gfortran_f2c_specific__abs_c4;"}, {"sha": "14a88c418cd395af94caef925f152bcf173f05e3", "filename": "libgfortran/runtime/stop.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/libgfortran%2Fruntime%2Fstop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca/libgfortran%2Fruntime%2Fstop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fstop.c?ref=d0a4a61c3de7ac131afc0014c6a8970ca6dcdeca", "patch": "@@ -1,5 +1,5 @@\n /* Implementation of the STOP statement.\n-   Copyright 2002, 2005, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright 2002, 2005, 2007, 2009, 2010 Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n This file is part of the GNU Fortran 95 runtime library (libgfortran).\n@@ -53,3 +53,22 @@ stop_string (const char *string, GFC_INTEGER_4 len)\n \n   sys_exit (0);\n }\n+\n+extern void error_stop_string (const char *, GFC_INTEGER_4);\n+export_proto(error_stop_string);\n+\n+\n+/* Per Fortran 2008, section 8.4:  \"Execution of a STOP statement initiates\n+   normal termination of execution. Execution of an ERROR STOP statement\n+   initiates error termination of execution.\"  Thus, error_stop_string returns\n+   a nonzero exit status code.  */\n+void\n+error_stop_string (const char *string, GFC_INTEGER_4 len)\n+{\n+  st_printf (\"ERROR STOP \");\n+  while (len--)\n+    st_printf (\"%c\", *(string++));\n+  st_printf (\"\\n\");\n+\n+  sys_exit (1);\n+}"}]}