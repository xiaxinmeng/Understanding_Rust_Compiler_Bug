{"sha": "e0966a17a3b06d6f6b2810f6aef41d9ae41538fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA5NjZhMTdhM2IwNmQ2ZjZiMjgxMGY2YWVmNDFkOWFlNDE1MzhmYw==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2004-11-25T11:50:45Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2004-11-25T11:50:45Z"}, "message": "Add missing file from gcj-abi-2-dev-branch merge.\n\nFrom-SVN: r91284", "tree": {"sha": "9b8eee3a90bd61127411ca65fffc10743dce2026", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b8eee3a90bd61127411ca65fffc10743dce2026"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0966a17a3b06d6f6b2810f6aef41d9ae41538fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0966a17a3b06d6f6b2810f6aef41d9ae41538fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0966a17a3b06d6f6b2810f6aef41d9ae41538fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0966a17a3b06d6f6b2810f6aef41d9ae41538fc/comments", "author": null, "committer": null, "parents": [{"sha": "b1df6376dc54486b3edd234c883e279623fdf89f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1df6376dc54486b3edd234c883e279623fdf89f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1df6376dc54486b3edd234c883e279623fdf89f"}], "stats": {"total": 226, "additions": 226, "deletions": 0}, "files": [{"sha": "d19ab694d803142b330656e75a323d5678d94c54", "filename": "libjava/gnu/gcj/util/Debug.java", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0966a17a3b06d6f6b2810f6aef41d9ae41538fc/libjava%2Fgnu%2Fgcj%2Futil%2FDebug.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0966a17a3b06d6f6b2810f6aef41d9ae41538fc/libjava%2Fgnu%2Fgcj%2Futil%2FDebug.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Futil%2FDebug.java?ref=e0966a17a3b06d6f6b2810f6aef41d9ae41538fc", "patch": "@@ -0,0 +1,226 @@\n+/*  Copyright (C) 2004  Free Software Foundation\n+\n+This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+/* Utility methods that allow an object to be converted to a textual\n+   representation on an OutputStream.  The intention here is that this\n+   class be used for debugging, so we provide information about all\n+   fields, public or otherwise. */\n+\n+package gnu.gcj.util;\n+\n+import java.lang.reflect.*;\n+import java.io.*;\n+import java.util.*;\n+\n+class Debug \n+{\n+  private final PrintStream p;\n+  private final int maxdepth;\n+  private final int maxArrayLength;\n+  private final boolean printStaticFields;\n+  private int depth; \n+\n+  Debug(PrintStream writer, int maxdepth, int maxArrayLength, boolean printStaticFields)\n+  {\n+    p = writer;\n+    this.maxdepth = maxdepth;\n+    this.maxArrayLength = maxArrayLength;\n+    this.printStaticFields = printStaticFields;\n+  }\n+\n+  Debug(PrintStream writer)\n+  {\n+    this(writer, 0, 10, false);\n+  }\n+\n+  Debug(int maxdepth, boolean printStaticFields)\n+  {\n+    this(new PrintStream\n+\t (new FileOutputStream(FileDescriptor.err), true), \n+\t maxdepth, \n+\t maxdepth > 0 ? 1000 : 10, printStaticFields);\n+  }\n+\n+  Debug(int maxdepth)\n+  {\n+    this(maxdepth, false);\n+  }\n+\n+  Debug()\n+  {\n+    this(0, false);\n+  }\n+  \n+  private final void indent()\n+  {\n+    for (int i = 0; i < depth; i++)\n+      p.print(\"  \");\n+  }\n+\n+  private final java.util.IdentityHashMap h = \n+  new java.util.IdentityHashMap();\n+\n+  private static native Field[] getDeclaredFields(Class c);\n+  private static native Object getField(Object o, Field f);\n+  private static native long getAddr(Object o);\n+\n+  // Return an array containing all the fields of a class and its\n+  // superclasses.\n+  private Field[] internalGetFields(Class c)\n+  {\n+    HashSet set = new HashSet();\n+    set.addAll(Arrays.asList(getDeclaredFields(c)));\n+    Class[] interfaces = c.getInterfaces();\n+    for (int i = 0; i < interfaces.length; i++)\n+      set.addAll(Arrays.asList(internalGetFields(interfaces[i])));\n+    Class superClass = c.getSuperclass();\n+    if (superClass != null)\n+      set.addAll(Arrays.asList(internalGetFields(superClass)));\n+    return (Field[])set.toArray(new Field[set.size()]);\n+  }\n+\n+  // FIXME: We could just use getClass() here, but this is a\n+  // workaround for a C++ bug that is causing getClass() to be\n+  // miscompiled.\n+  static private Class getItsClass(Object O)\n+  {\n+    return O.getClass();\n+  }\n+\n+  // Print a reasonably readable textual representation of an object\n+  // on our OutputStream.  Objects are only printed once, no matter\n+  // how many references point to them.\n+  private void print(Object O)\n+  {\n+    int savedDepth = depth;\n+    h.put(O, O);\n+    try\n+      {\n+\tClass C = getItsClass(O);\n+\tp.print(C.getName() + \"@\");\n+\tp.println(Long.toHexString(getAddr(O)));\n+\n+\tif (C.isArray())\n+\t  {\n+\t    indent(); p.println(\"{\");\n+\t    depth++;\n+\t    indent();\n+\t    C = C.getComponentType();\n+\n+\t    int len = Array.getLength(O);\n+\t    for (int i = 0; i < len; i++)\n+\t      {\n+\t\tObject thing = Array.get(O, i);\n+\t\tprint0(thing, C);\n+\t\tp.print(\", \");\n+\t\tif (i > maxArrayLength)\n+\t\t  {\n+\t\t    p.print(\"...\");\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    depth--;\n+\t    p.println();\n+\t    indent(); p.print(\"}\");\n+\t    return;\n+\t  }\n+\n+\tindent(); p.println(\"{\");\n+\tdepth++;\n+\tif (C == java.lang.Class.class)\n+\t  {\n+\t    indent();\n+\t    p.println (\"class = \" + O.toString() + \",\");\n+\t  }\n+\telse if (C == java.lang.reflect.Field.class)\n+\t  {\n+\t    indent();\n+\t    p.println (\"<field> = \\\"\" + O.toString() + \"\\\",\");\n+\t  }\n+\telse if (C == java.lang.String.class)\n+\t  {\n+\t    indent();\n+\t    p.println (\"<string> = \\\"\" + O.toString() + \"\\\",\");\n+\t  }\n+\tField[] f = internalGetFields(C);\n+\tfor (int i = 0; i < f.length; i++)\n+\t  {\n+\t    Class type = f[i].getType();\n+\t    boolean isStatic = (f[i].getModifiers() & Modifier.STATIC) != 0;\n+ \n+\t    if (isStatic && ! printStaticFields)\n+\t      continue;\n+\n+\t    indent();\n+\t    if (isStatic)\n+\t      p.print(\"static \");\n+\t    p.print(type.getName() +\" \" +f[i].getName() + \" = \");\n+\t    Object thing = getField(O, f[i]);\n+\t    print0(thing, type);\n+\t    p.println(\",\");\n+\t  }\n+\tdepth--;\n+\tindent(); p.print(\"}\");\n+      }\n+    catch (Throwable t)\n+      {\n+\tp.print(\"error: 0x\" + Long.toHexString(getAddr(O)) + \";\");\n+\tdepth = savedDepth;\n+      }\n+  }\n+\n+  private void print0(Object thing, Class C)\n+  {\n+    try\n+      {\n+\tif (thing == null)\n+\t  {\n+\t    p.print(\"null\");\n+\t    return;\n+\t  }\n+\telse if (C == gnu.gcj.RawData.class || \n+\t\t C == gnu.gcj.RawDataManaged.class)\n+\t  {\n+\t  }\n+\telse if (C.isPrimitive())\n+\t  {\n+\t    if (getItsClass(thing) == Character.class)\t\t\t\t\n+\t      p.print(\"'\" + thing + \"'\");\n+\t    else\n+\t      p.print(thing);\n+\t    return;\n+\t  }\n+\telse if (getItsClass(thing) == String.class)\n+\t  {\t\t\t  \n+\t    p.print(\"\\\"\" + thing + \"\\\"\");\n+\t    return;\n+\t  }\n+\telse if (depth < maxdepth && h.get(thing) == null)\n+\t  {\n+\t    depth++;\n+\t    print(thing);\n+\t    depth--;\n+\t    return;\n+\t  }\n+      }\n+    catch (Throwable t)\n+      {\n+      }\n+    \n+    // The default action: just print the address.\n+    p.print(\"0x\"+ Long.toHexString(getAddr(thing)));    \n+  }\n+\n+  // Print the textual representation of an object on System.err.\n+  public void write(Object O)\n+  {\n+    depth = 0;\n+    print(O);\n+    p.flush();\n+  }\n+}"}]}