{"sha": "5a82ecd9994682d76eba3c2c6460b3566fc5654c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE4MmVjZDk5OTQ2ODJkNzZlYmEzYzJjNjQ2MGIzNTY2ZmM1NjU0Yw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2009-06-25T06:16:11Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2009-06-25T06:16:11Z"}, "message": "arc.c: Include \"df.h\".\n\n\t* config/arc/arc.c: Include \"df.h\".\n\t(arc_attribute_table): Make static.  Move higher in file.\n\t(arc_address_cost): Call SMALL_INT on INTVAL, not rtx.\n\t(output_shift): Initialize n later to avoid warning.\n\t* config/arm/arm.c (arm_attribute_table): Make static.  Move\n\thigher in file.\n\t* config/avr/avr.c (avr_attribute_table): Make static.  Move\n\thigher in file.\n\t(reg_class_tab): Change array type from int to enum reg_class.\n\t(avr_jump_mode): Change GET_MODE to GET_CODE when checking for\n\tLABEL_REF.\n\t(out_tsthi, ashlhi3_out): Don't use AS2 with \"or\" or \"and\".\n\t(lshrhi3_out): Likewise.\n\t(class_likely_spilled_p): Change return type to bool.\n\t(avr_rtx_costs): Use local code variable with enum type.\n\t* config/avr/avr.md (movmemhi): Use add_reg_note.\n\t(andhi3, andsi3): Don't use AS2 with \"and\".\n\t(iorhi3, iorsi3): Don't use AS2 with \"or\".\n\t* config/avr/avr-protos.h (class_likely_spilled_p): Update\n\tdeclaration.\n\t* config/crx/crx.c: Include \"df.h\".\n\t(crx_attribute_table): Make static.\n\t* config/m32r/m32r.c: Include \"df.h\".\n\t(m32r_attribute_table): Make static.  Move higher in file.\n\t(pop): Use add_reg_note.\n\t(block_move_call): Change 0 to LCT_NORMAL in function call.\n\t* config/m32r/m32r.md (movsi_insn): Remove unused local value.\n\t* config/m32r/m32r.h (INITIALIZE_TRAMPOLINE): Likewise.\n\t* config/m32r/m32r-protos.h (m32r_compute_function_type): Always\n\tdeclare, not just when TREE_CODE is defined.\n\t* config/m68hc11/m68hc11.c: Include \"expr.h\".\n\t(m68hc11_attribute_table): Make static.  Move higher in file.\n\t(m68hc11_small_indexed_indirect_p): Change 0 to VOIDmode in\n\tfunction call.\n\t(m68hc11_register_indirect_p): Likewise.\n\t(m68hc11_function_arg_padding): Change return type to enum\n\tdirection.\n\t(emit_move_after_reload): Use add_reg_note.\n\t(m68hc11_emit_logical): Change code parameter to enum rtx_code.\n\t(m68hc11_split_logical): Likewise.\n\t(m68hc11_rtx_costs): Add local code_and outer_code variables with\n\tenum type.\n\t* config/m68hc11/predicates.md (reg_or_some_mem_operand): Change 0\n\tto VOIDmode in function call.\n\t* config/m68hc11/m68hc11-protos.h: Don't check TREE_CODE to see if\n\ttree is defined.\n\t(m68hc11_split_logical): Update declaration.\n\t(m68hc11_function_arg_padding): Update declaration.\n\t* config/mcore/mcore.c (regno_reg_class): Change form array of int\n\tto array of enum reg_class.\n\t(mcore_attribute_table): Make static.  Move higher in file.\n\t(mcore_rtx_costs): Add cast to enum type.\n\t* config/mcore/mcore.h (regno_reg_class): Update declaration.\n\t(GO_IF_LEGITIMATE_INDEX): Add cast to avoid warning.\n\t* config/sh/sh.c (sh_attribute_table): Make static.  Move higher\n\tin file.\n\t* config/sh/predicates.md (trapping_target_operand): Rename and to\n\tand_expr.\n\t* config/sparc/sparc.c (sparc_attribute_table): Make static.  Move\n\thigher in file.\n\t* config/spu/spu.c (spu_attribute_table): Make static.  Move\n\thigher in file.\n\t* config/v850/v850.c (v850_attribute_table): Make static.  Move\n\thigher in file.\n\t(v850_rtx_costs): Use local code with enum type.\n\t(expand_epilogue): Add cast.\n\t* config/v850/v850-c.c (ghs_pragma_section): Initialize repeat.\n\nFrom-SVN: r148927", "tree": {"sha": "eb40ba24b9ba6cd915e72178183c60d3f3dd4700", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb40ba24b9ba6cd915e72178183c60d3f3dd4700"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a82ecd9994682d76eba3c2c6460b3566fc5654c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a82ecd9994682d76eba3c2c6460b3566fc5654c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a82ecd9994682d76eba3c2c6460b3566fc5654c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a82ecd9994682d76eba3c2c6460b3566fc5654c/comments", "author": null, "committer": null, "parents": [{"sha": "b4589acca420c16a7d67c77b8e36afa9a0a8d8ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4589acca420c16a7d67c77b8e36afa9a0a8d8ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4589acca420c16a7d67c77b8e36afa9a0a8d8ce"}], "stats": {"total": 589, "additions": 321, "deletions": 268}, "files": [{"sha": "b6cba29bbd6f4ccba6c42ec6fdc6013040a400b9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a82ecd9994682d76eba3c2c6460b3566fc5654c", "patch": "@@ -1,3 +1,73 @@\n+2009-06-24  Ian Lance Taylor  <iant@google.com>\n+\n+\t* config/arc/arc.c: Include \"df.h\".\n+\t(arc_attribute_table): Make static.  Move higher in file.\n+\t(arc_address_cost): Call SMALL_INT on INTVAL, not rtx.\n+\t(output_shift): Initialize n later to avoid warning.\n+\t* config/arm/arm.c (arm_attribute_table): Make static.  Move\n+\thigher in file.\n+\t* config/avr/avr.c (avr_attribute_table): Make static.  Move\n+\thigher in file.\n+\t(reg_class_tab): Change array type from int to enum reg_class.\n+\t(avr_jump_mode): Change GET_MODE to GET_CODE when checking for\n+\tLABEL_REF.\n+\t(out_tsthi, ashlhi3_out): Don't use AS2 with \"or\" or \"and\".\n+\t(lshrhi3_out): Likewise.\n+\t(class_likely_spilled_p): Change return type to bool.\n+\t(avr_rtx_costs): Use local code variable with enum type.\n+\t* config/avr/avr.md (movmemhi): Use add_reg_note.\n+\t(andhi3, andsi3): Don't use AS2 with \"and\".\n+\t(iorhi3, iorsi3): Don't use AS2 with \"or\".\n+\t* config/avr/avr-protos.h (class_likely_spilled_p): Update\n+\tdeclaration.\n+\t* config/crx/crx.c: Include \"df.h\".\n+\t(crx_attribute_table): Make static.\n+\t* config/m32r/m32r.c: Include \"df.h\".\n+\t(m32r_attribute_table): Make static.  Move higher in file.\n+\t(pop): Use add_reg_note.\n+\t(block_move_call): Change 0 to LCT_NORMAL in function call.\n+\t* config/m32r/m32r.md (movsi_insn): Remove unused local value.\n+\t* config/m32r/m32r.h (INITIALIZE_TRAMPOLINE): Likewise.\n+\t* config/m32r/m32r-protos.h (m32r_compute_function_type): Always\n+\tdeclare, not just when TREE_CODE is defined.\n+\t* config/m68hc11/m68hc11.c: Include \"expr.h\".\n+\t(m68hc11_attribute_table): Make static.  Move higher in file.\n+\t(m68hc11_small_indexed_indirect_p): Change 0 to VOIDmode in\n+\tfunction call.\n+\t(m68hc11_register_indirect_p): Likewise.\n+\t(m68hc11_function_arg_padding): Change return type to enum\n+\tdirection.\n+\t(emit_move_after_reload): Use add_reg_note.\n+\t(m68hc11_emit_logical): Change code parameter to enum rtx_code.\n+\t(m68hc11_split_logical): Likewise.\n+\t(m68hc11_rtx_costs): Add local code_and outer_code variables with\n+\tenum type.\n+\t* config/m68hc11/predicates.md (reg_or_some_mem_operand): Change 0\n+\tto VOIDmode in function call.\n+\t* config/m68hc11/m68hc11-protos.h: Don't check TREE_CODE to see if\n+\ttree is defined.\n+\t(m68hc11_split_logical): Update declaration.\n+\t(m68hc11_function_arg_padding): Update declaration.\n+\t* config/mcore/mcore.c (regno_reg_class): Change form array of int\n+\tto array of enum reg_class.\n+\t(mcore_attribute_table): Make static.  Move higher in file.\n+\t(mcore_rtx_costs): Add cast to enum type.\n+\t* config/mcore/mcore.h (regno_reg_class): Update declaration.\n+\t(GO_IF_LEGITIMATE_INDEX): Add cast to avoid warning.\n+\t* config/sh/sh.c (sh_attribute_table): Make static.  Move higher\n+\tin file.\n+\t* config/sh/predicates.md (trapping_target_operand): Rename and to\n+\tand_expr.\n+\t* config/sparc/sparc.c (sparc_attribute_table): Make static.  Move\n+\thigher in file.\n+\t* config/spu/spu.c (spu_attribute_table): Make static.  Move\n+\thigher in file.\n+\t* config/v850/v850.c (v850_attribute_table): Make static.  Move\n+\thigher in file.\n+\t(v850_rtx_costs): Use local code with enum type.\n+\t(expand_epilogue): Add cast.\n+\t* config/v850/v850-c.c (ghs_pragma_section): Initialize repeat.\n+\n 2009-06-23  Takashi YOSHII  <yoshii.takashi@renesas.com>\n \n \tPR target/40515"}, {"sha": "66709c7f31c9966ee96ec639183666159ac6901a", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=5a82ecd9994682d76eba3c2c6460b3566fc5654c", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"recog.h\"\n #include \"toplev.h\"\n+#include \"df.h\"\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n@@ -78,7 +79,6 @@ static bool arc_handle_option (size_t, const char *, int);\n static void record_cc_ref (rtx);\n static void arc_init_reg_tables (void);\n static int get_arc_condition_code (rtx);\n-EXPORTED_CONST struct attribute_spec arc_attribute_table[];\n static tree arc_handle_interrupt_attribute (tree *, tree, tree, int, bool *);\n static bool arc_assemble_integer (rtx, unsigned int, int);\n static void arc_output_function_prologue (FILE *, HOST_WIDE_INT);\n@@ -95,6 +95,15 @@ static bool arc_return_in_memory (const_tree, const_tree);\n static bool arc_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t   const_tree, bool);\n \f\n+/* ARC specific attributs.  */\n+\n+static const struct attribute_spec arc_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"interrupt\", 1, 1, true,  false, false, arc_handle_interrupt_attribute },\n+  { NULL,        0, 0, false, false, false, NULL }\n+};\n+\f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n@@ -364,13 +373,6 @@ arc_init_reg_tables (void)\n    interrupt - for interrupt functions\n */\n \n-const struct attribute_spec arc_attribute_table[] =\n-{\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n-  { \"interrupt\", 1, 1, true,  false, false, arc_handle_interrupt_attribute },\n-  { NULL,        0, 0, false, false, false, NULL }\n-};\n-\n /* Handle an \"interrupt\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n@@ -897,7 +899,7 @@ arc_address_cost (rtx addr, bool speed ATTRIBUTE_UNUSED)\n \tswitch (GET_CODE (plus1))\n \t  {\n \t  case CONST_INT :\n-\t    return SMALL_INT (plus1) ? 1 : 2;\n+\t    return SMALL_INT (INTVAL (plus1)) ? 1 : 2;\n \t  case CONST :\n \t  case SYMBOL_REF :\n \t  case LABEL_REF :\n@@ -1502,9 +1504,10 @@ output_shift (rtx *operands)\n     }\n   else\n     {\n-      int n = INTVAL (operands[2]);\n+      int n;\n \n       /* If the count is negative, make it 0.  */\n+      n = INTVAL (operands[2]);\n       if (n < 0)\n \tn = 0;\n       /* If the count is too big, truncate it."}, {"sha": "50b11c0941ac42b333e83d0461f4a3fd33ed60de", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 35, "deletions": 38, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=5a82ecd9994682d76eba3c2c6460b3566fc5654c", "patch": "@@ -59,8 +59,6 @@\n typedef struct minipool_node    Mnode;\n typedef struct minipool_fixup   Mfix;\n \n-EXPORTED_CONST struct attribute_spec arm_attribute_table[];\n-\n void (*arm_lang_output_object_attributes_hook)(void);\n \n /* Forward function declarations.  */\n@@ -206,7 +204,42 @@ static const char *arm_invalid_return_type (const_tree t);\n static tree arm_promoted_type (const_tree t);\n static tree arm_convert_to_type (tree type, tree expr);\n static bool arm_scalar_mode_supported_p (enum machine_mode);\n+\f\n+/* Table of machine attributes.  */\n+static const struct attribute_spec arm_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  /* Function calls made to this symbol must be done indirectly, because\n+     it may lie outside of the 26 bit addressing range of a normal function\n+     call.  */\n+  { \"long_call\",    0, 0, false, true,  true,  NULL },\n+  /* Whereas these functions are always known to reside within the 26 bit\n+     addressing range.  */\n+  { \"short_call\",   0, 0, false, true,  true,  NULL },\n+  /* Interrupt Service Routines have special prologue and epilogue requirements.  */\n+  { \"isr\",          0, 1, false, false, false, arm_handle_isr_attribute },\n+  { \"interrupt\",    0, 1, false, false, false, arm_handle_isr_attribute },\n+  { \"naked\",        0, 0, true,  false, false, arm_handle_fndecl_attribute },\n+#ifdef ARM_PE\n+  /* ARM/PE has three new attributes:\n+     interfacearm - ?\n+     dllexport - for exporting a function/variable that will live in a dll\n+     dllimport - for importing a function/variable from a dll\n \n+     Microsoft allows multiple declspecs in one __declspec, separating\n+     them with spaces.  We do NOT support this.  Instead, use __declspec\n+     multiple times.\n+  */\n+  { \"dllimport\",    0, 0, true,  false, false, NULL },\n+  { \"dllexport\",    0, 0, true,  false, false, NULL },\n+  { \"interfacearm\", 0, 0, true,  false, false, arm_handle_fndecl_attribute },\n+#elif TARGET_DLLIMPORT_DECL_ATTRIBUTES\n+  { \"dllimport\",    0, 0, false, false, false, handle_dll_attribute },\n+  { \"dllexport\",    0, 0, false, false, false, handle_dll_attribute },\n+  { \"notshared\",    0, 0, false, true, false, arm_handle_notshared_attribute },\n+#endif\n+  { NULL,           0, 0, false, false, false, NULL }\n+};\n \f\n /* Initialize the GCC target structure.  */\n #if TARGET_DLLIMPORT_DECL_ATTRIBUTES\n@@ -3375,42 +3408,6 @@ arm_pr_long_calls_off (struct cpp_reader * pfile ATTRIBUTE_UNUSED)\n   arm_pragma_long_calls = OFF;\n }\n \f\n-/* Table of machine attributes.  */\n-const struct attribute_spec arm_attribute_table[] =\n-{\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n-  /* Function calls made to this symbol must be done indirectly, because\n-     it may lie outside of the 26 bit addressing range of a normal function\n-     call.  */\n-  { \"long_call\",    0, 0, false, true,  true,  NULL },\n-  /* Whereas these functions are always known to reside within the 26 bit\n-     addressing range.  */\n-  { \"short_call\",   0, 0, false, true,  true,  NULL },\n-  /* Interrupt Service Routines have special prologue and epilogue requirements.  */\n-  { \"isr\",          0, 1, false, false, false, arm_handle_isr_attribute },\n-  { \"interrupt\",    0, 1, false, false, false, arm_handle_isr_attribute },\n-  { \"naked\",        0, 0, true,  false, false, arm_handle_fndecl_attribute },\n-#ifdef ARM_PE\n-  /* ARM/PE has three new attributes:\n-     interfacearm - ?\n-     dllexport - for exporting a function/variable that will live in a dll\n-     dllimport - for importing a function/variable from a dll\n-\n-     Microsoft allows multiple declspecs in one __declspec, separating\n-     them with spaces.  We do NOT support this.  Instead, use __declspec\n-     multiple times.\n-  */\n-  { \"dllimport\",    0, 0, true,  false, false, NULL },\n-  { \"dllexport\",    0, 0, true,  false, false, NULL },\n-  { \"interfacearm\", 0, 0, true,  false, false, arm_handle_fndecl_attribute },\n-#elif TARGET_DLLIMPORT_DECL_ATTRIBUTES\n-  { \"dllimport\",    0, 0, false, false, false, handle_dll_attribute },\n-  { \"dllexport\",    0, 0, false, false, false, handle_dll_attribute },\n-  { \"notshared\",    0, 0, false, true, false, arm_handle_notshared_attribute },\n-#endif\n-  { NULL,           0, 0, false, false, false, NULL }\n-};\n-\n /* Handle an attribute requiring a FUNCTION_DECL;\n    arguments as in struct attribute_spec.handler.  */\n static tree"}, {"sha": "6a0e26d3462891cb97957d8052fa24c441ba9240", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=5a82ecd9994682d76eba3c2c6460b3566fc5654c", "patch": "@@ -27,7 +27,7 @@ extern void avr_override_options (void);\n extern void avr_optimization_options (int level, int size);\n extern char *avr_change_section (char *sect_name);\n extern int avr_ret_register (void);\n-extern enum reg_class class_likely_spilled_p (int c);\n+extern bool class_likely_spilled_p (int c);\n extern enum reg_class avr_regno_reg_class (int r);\n extern enum reg_class avr_reg_class_from_letter (int c);\n extern bool avr_frame_pointer_required_p (void);"}, {"sha": "0ed978812166b63610ed0caa2e36dccfbe4fb453", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=5a82ecd9994682d76eba3c2c6460b3566fc5654c", "patch": "@@ -67,7 +67,6 @@ static int compare_sign_p (rtx insn);\n static tree avr_handle_progmem_attribute (tree *, tree, tree, int, bool *);\n static tree avr_handle_fndecl_attribute (tree *, tree, tree, int, bool *);\n static tree avr_handle_fntype_attribute (tree *, tree, tree, int, bool *);\n-EXPORTED_CONST struct attribute_spec avr_attribute_table[];\n static bool avr_assemble_integer (rtx, unsigned int, int);\n static void avr_file_start (void);\n static void avr_file_end (void);\n@@ -117,6 +116,18 @@ const struct mcu_type_s *avr_current_device;\n \n section *progmem_section;\n \n+/* AVR attributes.  */\n+static const struct attribute_spec avr_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"progmem\",   0, 0, false, false, false,  avr_handle_progmem_attribute },\n+  { \"signal\",    0, 0, true,  false, false,  avr_handle_fndecl_attribute },\n+  { \"interrupt\", 0, 0, true,  false, false,  avr_handle_fndecl_attribute },\n+  { \"naked\",     0, 0, false, true,  true,   avr_handle_fntype_attribute },\n+  { \"OS_task\",   0, 0, false, true,  true,   avr_handle_fntype_attribute },\n+  { \"OS_main\",   0, 0, false, true,  true,   avr_handle_fntype_attribute },\n+  { NULL,        0, 0, false, false, false, NULL }\n+};\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_ALIGNED_HI_OP\n@@ -209,7 +220,7 @@ avr_override_options (void)\n \n /*  return register class from register number.  */\n \n-static const int reg_class_tab[]={\n+static const enum reg_class reg_class_tab[]={\n   GENERAL_REGS,GENERAL_REGS,GENERAL_REGS,GENERAL_REGS,GENERAL_REGS,\n   GENERAL_REGS,GENERAL_REGS,GENERAL_REGS,GENERAL_REGS,GENERAL_REGS,\n   GENERAL_REGS,GENERAL_REGS,GENERAL_REGS,GENERAL_REGS,GENERAL_REGS,\n@@ -1264,7 +1275,7 @@ class_max_nregs (enum reg_class rclass ATTRIBUTE_UNUSED,enum machine_mode mode)\n int\n avr_jump_mode (rtx x, rtx insn)\n {\n-  int dest_addr = INSN_ADDRESSES (INSN_UID (GET_MODE (x) == LABEL_REF\n+  int dest_addr = INSN_ADDRESSES (INSN_UID (GET_CODE (x) == LABEL_REF\n \t\t\t\t\t    ? XEXP (x, 0) : x));\n   int cur_addr = INSN_ADDRESSES (INSN_UID (insn));\n   int jump_distance = cur_addr - dest_addr;\n@@ -2734,7 +2745,7 @@ out_tsthi (rtx insn, rtx op, int *l)\n     {\n       /* Faster than sbiw if we can clobber the operand.  */\n       if (l) *l = 1;\n-      return AS2 (or,%A0,%B0);\n+      return \"or %A0,%B0\";\n     }\n   if (test_hard_reg_class (ADDW_REGS, op))\n     {\n@@ -3057,9 +3068,9 @@ ashlhi3_out (rtx insn, rtx operands[], int *len)\n \t      return (AS1 (swap,%A0)    CR_TAB\n \t\t      AS1 (swap,%B0)    CR_TAB\n \t\t      AS2 (ldi,%3,0xf0) CR_TAB\n-\t\t      AS2 (and,%B0,%3)  CR_TAB\n+\t\t      \"and %B0,%3\"      CR_TAB\n \t\t      AS2 (eor,%B0,%A0) CR_TAB\n-\t\t      AS2 (and,%A0,%3)  CR_TAB\n+\t\t      \"and %A0,%3\"      CR_TAB\n \t\t      AS2 (eor,%B0,%A0));\n \t    }\n \t  break;  /* optimize_size ? 6 : 8 */\n@@ -3087,9 +3098,9 @@ ashlhi3_out (rtx insn, rtx operands[], int *len)\n \t\t      AS1 (swap,%A0)    CR_TAB\n \t\t      AS1 (swap,%B0)    CR_TAB\n \t\t      AS2 (ldi,%3,0xf0) CR_TAB\n-\t\t      AS2 (and,%B0,%3)  CR_TAB\n+\t\t      \"and %B0,%3\"      CR_TAB\n \t\t      AS2 (eor,%B0,%A0) CR_TAB\n-\t\t      AS2 (and,%A0,%3)  CR_TAB\n+\t\t      \"and %A0,%3\"      CR_TAB\n \t\t      AS2 (eor,%B0,%A0));\n \t    }\n \t  break;  /* 10 */\n@@ -3157,7 +3168,7 @@ ashlhi3_out (rtx insn, rtx operands[], int *len)\n \t\t      AS1 (clr,%A0)     CR_TAB\n \t\t      AS1 (swap,%B0)    CR_TAB\n \t\t      AS2 (ldi,%3,0xf0) CR_TAB\n-\t\t      AS2 (and,%B0,%3));\n+\t\t      \"and %B0,%3\");\n \t    }\n \t  *len = 6;\n \t  return (AS2 (mov,%B0,%A0) CR_TAB\n@@ -3196,7 +3207,7 @@ ashlhi3_out (rtx insn, rtx operands[], int *len)\n \t\t      AS1 (swap,%B0)    CR_TAB\n \t\t      AS1 (lsl,%B0)     CR_TAB\n \t\t      AS2 (ldi,%3,0xe0) CR_TAB\n-\t\t      AS2 (and,%B0,%3));\n+\t\t      \"and %B0,%3\");\n \t    }\n \t  if (AVR_HAVE_MUL)\n \t    {\n@@ -3834,9 +3845,9 @@ lshrhi3_out (rtx insn, rtx operands[], int *len)\n \t      return (AS1 (swap,%B0)    CR_TAB\n \t\t      AS1 (swap,%A0)    CR_TAB\n \t\t      AS2 (ldi,%3,0x0f) CR_TAB\n-\t\t      AS2 (and,%A0,%3)  CR_TAB\n+\t\t      \"and %A0,%3\"      CR_TAB\n \t\t      AS2 (eor,%A0,%B0) CR_TAB\n-\t\t      AS2 (and,%B0,%3)  CR_TAB\n+\t\t      \"and %B0,%3\"      CR_TAB\n \t\t      AS2 (eor,%A0,%B0));\n \t    }\n \t  break;  /* optimize_size ? 6 : 8 */\n@@ -3864,9 +3875,9 @@ lshrhi3_out (rtx insn, rtx operands[], int *len)\n \t\t      AS1 (swap,%B0)    CR_TAB\n \t\t      AS1 (swap,%A0)    CR_TAB\n \t\t      AS2 (ldi,%3,0x0f) CR_TAB\n-\t\t      AS2 (and,%A0,%3)  CR_TAB\n+\t\t      \"and %A0,%3\"      CR_TAB\n \t\t      AS2 (eor,%A0,%B0) CR_TAB\n-\t\t      AS2 (and,%B0,%3)  CR_TAB\n+\t\t      \"and %B0,%3\"      CR_TAB\n \t\t      AS2 (eor,%A0,%B0));\n \t    }\n \t  break;  /* 10 */\n@@ -3934,7 +3945,7 @@ lshrhi3_out (rtx insn, rtx operands[], int *len)\n \t\t      AS1 (clr,%B0)     CR_TAB\n \t\t      AS1 (swap,%A0)    CR_TAB\n \t\t      AS2 (ldi,%3,0x0f) CR_TAB\n-\t\t      AS2 (and,%A0,%3));\n+\t\t      \"and %A0,%3\");\n \t    }\n \t  *len = 6;\n \t  return (AS2 (mov,%A0,%B0) CR_TAB\n@@ -3973,7 +3984,7 @@ lshrhi3_out (rtx insn, rtx operands[], int *len)\n \t\t      AS1 (swap,%A0)    CR_TAB\n \t\t      AS1 (lsr,%A0)     CR_TAB\n \t\t      AS2 (ldi,%3,0x07) CR_TAB\n-\t\t      AS2 (and,%A0,%3));\n+\t\t      \"and %A0,%3\");\n \t    }\n \t  if (AVR_HAVE_MUL)\n \t    {\n@@ -4549,7 +4560,7 @@ gas_output_ascii(FILE *file, const char *str, size_t length)\n    assigned to registers of class CLASS would likely be spilled\n    because registers of CLASS are needed for spill registers.  */\n \n-enum reg_class\n+bool\n class_likely_spilled_p (int c)\n {\n   return (c != ALL_REGS && c != ADDW_REGS);\n@@ -4565,18 +4576,6 @@ class_likely_spilled_p (int c)\n \n    Only `progmem' attribute valid for type.  */\n \n-const struct attribute_spec avr_attribute_table[] =\n-{\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n-  { \"progmem\",   0, 0, false, false, false,  avr_handle_progmem_attribute },\n-  { \"signal\",    0, 0, true,  false, false,  avr_handle_fndecl_attribute },\n-  { \"interrupt\", 0, 0, true,  false, false,  avr_handle_fndecl_attribute },\n-  { \"naked\",     0, 0, false, true,  true,   avr_handle_fntype_attribute },\n-  { \"OS_task\",   0, 0, false, true,  true,   avr_handle_fntype_attribute },\n-  { \"OS_main\",   0, 0, false, true,  true,   avr_handle_fntype_attribute },\n-  { NULL,        0, 0, false, false, false, NULL }\n-};\n-\n /* Handle a \"progmem\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n@@ -4873,9 +4872,10 @@ avr_operand_rtx_cost (rtx x, enum machine_mode mode, enum rtx_code outer,\n    case, *TOTAL contains the cost result.  */\n \n static bool\n-avr_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total,\n+avr_rtx_costs (rtx x, int codearg, int outer_code ATTRIBUTE_UNUSED, int *total,\n \t       bool speed)\n {\n+  enum rtx_code code = (enum rtx_code) codearg;\n   enum machine_mode mode = GET_MODE (x);\n   HOST_WIDE_INT val;\n "}, {"sha": "5a15200ffe3bffb508762c0c9f81f94c54a55f93", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=5a82ecd9994682d76eba3c2c6460b3566fc5654c", "patch": "@@ -1,8 +1,8 @@\n ;; -*- Mode: Scheme -*-\n ;;   Machine description for GNU compiler,\n ;;   for ATMEL AVR micro controllers.\n-;;   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008\n-;;   Free Software Foundation, Inc.\n+;;   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007, 2008,\n+;;   2009 Free Software Foundation, Inc.\n ;;   Contributed by Denis Chertykov (chertykov@gmail.com)\n \n ;; This file is part of GCC.\n@@ -507,9 +507,7 @@\n                            label);\n   /* Set jump probability based on loop count.  */\n   jump = get_last_insn ();\n-  REG_NOTES (jump) = gen_rtx_EXPR_LIST (REG_BR_PROB,\n-                    GEN_INT (prob),\n-                    REG_NOTES (jump));\n+  add_reg_note (jump, REG_BR_PROB, GEN_INT (prob));\n   DONE;\n }\")\n \n@@ -1204,10 +1202,10 @@\n \t\t  (match_operand:HI 2 \"nonmemory_operand\" \"r,i,M\")))\n    (clobber (match_scratch:QI 3 \"=X,X,&d\"))]\n   \"\"\n-  \"*{\n+{\n   if (which_alternative==0)\n-    return (AS2 (and,%A0,%A2) CR_TAB\n-\t    AS2 (and,%B0,%B2));\n+    return (\"and %A0,%A2\" CR_TAB\n+\t    \"and %B0,%B2\");\n   else if (which_alternative==1)\n     {\n       if (GET_CODE (operands[2]) == CONST_INT)\n@@ -1217,15 +1215,15 @@\n \t    output_asm_insn (AS2 (andi,%A0,lo8(%2)), operands);\n \t  if ((mask & 0xff00) != 0xff00)\n \t    output_asm_insn (AS2 (andi,%B0,hi8(%2)), operands);\n-\t  return \\\"\\\";\n+\t  return \"\";\n         }\n         return (AS2 (andi,%A0,lo8(%2)) CR_TAB\n \t        AS2 (andi,%B0,hi8(%2)));\n      }\n   return (AS2 (ldi,%3,lo8(%2)) CR_TAB\n-          AS2 (and,%A0,%3)     CR_TAB\n+          \"and %A0,%3\"         CR_TAB\n           AS1 (clr,%B0));\n-}\"\n+}\n   [(set_attr \"length\" \"2,2,3\")\n    (set_attr \"cc\" \"set_n,clobber,set_n\")])\n \n@@ -1234,12 +1232,12 @@\n \t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n \t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,i\")))]\n   \"\"\n-  \"*{\n+{\n   if (which_alternative==0)\n-    return (AS2 (and, %0,%2)   CR_TAB\n-\t    AS2 (and, %B0,%B2) CR_TAB\n-\t    AS2 (and, %C0,%C2) CR_TAB\n-\t    AS2 (and, %D0,%D2));\n+    return (\"and %0,%2\"   CR_TAB\n+            \"and %B0,%B2\" CR_TAB\n+            \"and %C0,%C2\" CR_TAB\n+            \"and %D0,%D2\");\n   else if (which_alternative==1)\n     {\n       if (GET_CODE (operands[2]) == CONST_INT)\n@@ -1253,15 +1251,15 @@\n \t    output_asm_insn (AS2 (andi,%C0,hlo8(%2)), operands);\n \t  if ((mask & 0xff000000L) != 0xff000000L)\n \t    output_asm_insn (AS2 (andi,%D0,hhi8(%2)), operands);\n-\t  return \\\"\\\";\n+\t  return \"\";\n         }\n       return (AS2 (andi, %A0,lo8(%2))  CR_TAB\n               AS2 (andi, %B0,hi8(%2)) CR_TAB\n \t      AS2 (andi, %C0,hlo8(%2)) CR_TAB\n \t      AS2 (andi, %D0,hhi8(%2)));\n     }\n-  return \\\"bug\\\";\n-}\"\n+  return \"bug\";\n+}\n   [(set_attr \"length\" \"4,4\")\n    (set_attr \"cc\" \"set_n,clobber\")])\n \n@@ -1297,22 +1295,22 @@\n \t(ior:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n \t\t(match_operand:HI 2 \"nonmemory_operand\" \"r,i\")))]\n   \"\"\n-  \"*{\n+{\n   if (which_alternative==0)\n-    return (AS2 (or,%A0,%A2) CR_TAB\n-\t    AS2 (or,%B0,%B2));\n+    return (\"or %A0,%A2\" CR_TAB\n+\t    \"or %B0,%B2\");\n   if (GET_CODE (operands[2]) == CONST_INT)\n      {\n \tint mask = INTVAL (operands[2]);\n \tif (mask & 0xff)\n \t  output_asm_insn (AS2 (ori,%A0,lo8(%2)), operands);\n \tif (mask & 0xff00)\n \t  output_asm_insn (AS2 (ori,%B0,hi8(%2)), operands);\n-\treturn \\\"\\\";\n+\treturn \"\";\n       }\n    return (AS2 (ori,%0,lo8(%2)) CR_TAB\n \t   AS2 (ori,%B0,hi8(%2)));\n-}\"  \n+}\n   [(set_attr \"length\" \"2,2\")\n    (set_attr \"cc\" \"set_n,clobber\")])\n \n@@ -1333,12 +1331,12 @@\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n \t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,i\")))]\n   \"\"\n-  \"*{\n+{\n   if (which_alternative==0)\n-    return (AS2 (or, %0,%2)   CR_TAB\n-\t    AS2 (or, %B0,%B2) CR_TAB\n-\t    AS2 (or, %C0,%C2) CR_TAB\n-\t    AS2 (or, %D0,%D2));\n+    return (\"or %0,%2\"   CR_TAB\n+\t    \"or %B0,%B2\" CR_TAB\n+\t    \"or %C0,%C2\" CR_TAB\n+\t    \"or %D0,%D2\");\n   if (GET_CODE (operands[2]) == CONST_INT)\n      {\n \tHOST_WIDE_INT mask = INTVAL (operands[2]);\n@@ -1350,13 +1348,13 @@\n \t  output_asm_insn (AS2 (ori,%C0,hlo8(%2)), operands);\n \tif (mask & 0xff000000L)\n \t  output_asm_insn (AS2 (ori,%D0,hhi8(%2)), operands);\n-\treturn \\\"\\\";\n+\treturn \"\";\n       }\n   return (AS2 (ori, %A0,lo8(%2))  CR_TAB\n \t  AS2 (ori, %B0,hi8(%2)) CR_TAB\n \t  AS2 (ori, %C0,hlo8(%2)) CR_TAB\n \t  AS2 (ori, %D0,hhi8(%2)));\n-}\"\n+}\n   [(set_attr \"length\" \"4,4\")\n    (set_attr \"cc\" \"set_n,clobber\")])\n "}, {"sha": "4aa617fa28e0fe478d5b80778458f1d04c4863d8", "filename": "gcc/config/crx/crx.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fcrx%2Fcrx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fcrx%2Fcrx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.c?ref=5a82ecd9994682d76eba3c2c6460b3566fc5654c", "patch": "@@ -46,6 +46,7 @@\n #include \"optabs.h\"\n #include \"toplev.h\"\n #include \"basic-block.h\"\n+#include \"df.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n \n@@ -118,13 +119,6 @@ static int size_for_adjusting_sp;\n  * of the memory reference from PRINT_OPERAND to PRINT_OPERAND_ADDRESS. */\n static enum machine_mode output_memory_reference_mode;\n \n-/*****************************************************************************/\n-/* GLOBAL VARIABLES\t\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-/* Table of machine attributes.  */\n-EXPORTED_CONST struct attribute_spec crx_attribute_table[];\n-\n /*****************************************************************************/\n /* TARGETM FUNCTION PROTOTYPES\t\t\t\t\t\t     */\n /*****************************************************************************/\n@@ -170,7 +164,7 @@ static bool crx_legitimate_address_p (enum machine_mode, rtx, bool);\n #undef  TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE\t\tcrx_attribute_table\n \n-const struct attribute_spec crx_attribute_table[] = {\n+static const struct attribute_spec crx_attribute_table[] = {\n   /* ISRs have special prologue and epilogue requirements. */\n   {\"interrupt\", 0, 0, false, true, true, NULL},\n   {NULL, 0, 0, false, false, false, NULL}"}, {"sha": "2b7d09afeb54d4283c5a7c2a5ec7547ab582153d", "filename": "gcc/config/m32r/m32r-protos.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r-protos.h?ref=5a82ecd9994682d76eba3c2c6460b3566fc5654c", "patch": "@@ -1,5 +1,5 @@\n /* Prototypes for m32r.c functions used in the md file & elsewhere.\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009\n    Free Software Foundation, Inc.\n \n    This file is part of GCC.\n@@ -29,10 +29,7 @@ extern void   m32r_expand_prologue (void);\n extern void   m32r_expand_epilogue (void);\n extern int    direct_return (void);\n extern void   m32r_load_pic_register (void);\n-\n-#ifdef TREE_CODE\n extern enum m32r_function_type m32r_compute_function_type (tree);\n-#endif /* TREE_CODE */\n \n #ifdef RTX_CODE\n extern int    easy_di_const (rtx);"}, {"sha": "372ede596c0ae30dc5ff131f9ab7477aee0eadb5", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=5a82ecd9994682d76eba3c2c6460b3566fc5654c", "patch": "@@ -38,6 +38,7 @@\n #include \"toplev.h\"\n #include \"ggc.h\"\n #include \"integrate.h\"\n+#include \"df.h\"\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n@@ -65,7 +66,6 @@ static bool  m32r_handle_option (size_t, const char *, int);\n static void  init_reg_tables (void);\n static void  block_move_call (rtx, rtx, rtx);\n static int   m32r_is_insn (rtx);\n-EXPORTED_CONST struct attribute_spec m32r_attribute_table[];\n static rtx   m32r_legitimize_address (rtx, rtx, enum machine_mode);\n static tree  m32r_handle_model_attribute (tree *, tree, tree, int, bool *);\n static void  m32r_output_function_prologue (FILE *, HOST_WIDE_INT);\n@@ -88,6 +88,16 @@ static bool m32r_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n static int m32r_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t   tree, bool);\n \f\n+/* M32R specific attributes.  */\n+\n+static const struct attribute_spec m32r_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"interrupt\", 0, 0, true,  false, false, NULL },\n+  { \"model\",     1, 1, true,  false, false, m32r_handle_model_attribute },\n+  { NULL,        0, 0, false, false, false, NULL }\n+};\n+\f\n /* Initialize the GCC target structure.  */\n #undef  TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE m32r_attribute_table\n@@ -342,15 +352,6 @@ init_idents (void)\n     }\n }\n \n-const struct attribute_spec m32r_attribute_table[] =\n-{\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n-  { \"interrupt\", 0, 0, true,  false, false, NULL },\n-  { \"model\",     1, 1, true,  false, false, m32r_handle_model_attribute },\n-  { NULL,        0, 0, false, false, false, NULL }\n-};\n-\n-\n /* Handle an \"model\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n@@ -1632,8 +1633,7 @@ pop (int regno)\n \n   x = emit_insn (gen_movsi_pop (gen_rtx_REG (Pmode, regno),\n \t\t\t\tstack_pointer_rtx));\n-  REG_NOTES (x)\n-    = gen_rtx_EXPR_LIST (REG_INC, stack_pointer_rtx, 0);\n+  add_reg_note (x, REG_INC, stack_pointer_rtx);\n }\n \n /* Expand the m32r epilogue as a series of insns.  */\n@@ -2338,7 +2338,7 @@ block_move_call (rtx dest_reg, rtx src_reg, rtx bytes_rtx)\n       && GET_MODE (bytes_rtx) != Pmode)\n     bytes_rtx = convert_to_mode (Pmode, bytes_rtx, 1);\n \n-  emit_library_call (m32r_function_symbol (\"memcpy\"), 0,\n+  emit_library_call (m32r_function_symbol (\"memcpy\"), LCT_NORMAL,\n \t\t     VOIDmode, 3, dest_reg, Pmode, src_reg, Pmode,\n \t\t     convert_to_mode (TYPE_MODE (sizetype), bytes_rtx,\n \t\t\t\t      TYPE_UNSIGNED (sizetype)),"}, {"sha": "d06452d46ca48ef6c89684dd6ddeb77df24ca755", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=5a82ecd9994682d76eba3c2c6460b3566fc5654c", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler, Renesas M32R cpu.\n    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-   2005, 2006, 2007, 2008  Free Software Foundation, Inc.\n+   2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -1034,7 +1034,7 @@ L2:     .word STATIC\n \t\t\t\t     gen_int_mode (m32r_cache_flush_trap, SImode))); \\\n       else if (m32r_cache_flush_func && m32r_cache_flush_func[0])\t\t\\\n \temit_library_call (m32r_function_symbol (m32r_cache_flush_func),\t\\\n-\t\t\t   0, VOIDmode, 3, TRAMP, Pmode,\t\t\t\\\n+\t\t\t   LCT_NORMAL, VOIDmode, 3, TRAMP, Pmode,\t\t\\\n \t\t\t   gen_int_mode (TRAMPOLINE_SIZE, SImode), SImode,\t\\\n \t\t\t   GEN_INT (3), SImode);\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\t\\"}, {"sha": "0719357350ee1d12bdeaaecf6812487d278fd569", "filename": "gcc/config/m32r/m32r.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=5a82ecd9994682d76eba3c2c6460b3566fc5654c", "patch": "@@ -1,6 +1,6 @@\n ;; Machine description of the Renesas M32R cpu for GNU C compiler\n ;; Copyright (C) 1996, 1997, 1998, 1999, 2001, 2003, 2004, 2005,\n-;  2007, 2008 Free Software Foundation, Inc.\n+;  2007, 2008, 2009 Free Software Foundation, Inc.\n \n ;; This file is part of GCC.\n \n@@ -371,8 +371,6 @@\n     {\n       switch (GET_CODE (operands[1]))\n \t{\n-\t  HOST_WIDE_INT value;\n-\n \t  default:\n \t    break;\n "}, {"sha": "e4f8ba7ae805378829efb99e9ffbd4b04cd8d9fb", "filename": "gcc/config/m68hc11/m68hc11-protos.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h?ref=5a82ecd9994682d76eba3c2c6460b3566fc5654c", "patch": "@@ -1,5 +1,5 @@\n /* Prototypes for exported functions defined in m68hc11.c\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009\n    Free Software Foundation, Inc.\n    Contributed by Stephane Carrez (stcarrez@nerim.fr)\n \n@@ -90,7 +90,9 @@ extern int go_if_legitimate_address2 (rtx, enum machine_mode, int);\n extern int reg_or_indexed_operand (rtx,enum machine_mode);\n extern int memory_indexed_operand (rtx, enum machine_mode);\n \n-extern void m68hc11_split_logical (enum machine_mode, int, rtx*);\n+#ifdef RTX_CODE\n+extern void m68hc11_split_logical (enum machine_mode, enum rtx_code, rtx*);\n+#endif\n \n extern int m68hc11_register_indirect_p (rtx, enum machine_mode);\n extern int m68hc11_valid_addressing_p (rtx, enum machine_mode, int);\n@@ -101,26 +103,25 @@ extern int memory_reload_operand (rtx, enum machine_mode);\n extern int arith_src_operand (rtx, enum machine_mode);\n extern int soft_reg_operand (rtx, enum machine_mode);\n \n-#if defined TREE_CODE\n extern void m68hc11_init_cumulative_args (CUMULATIVE_ARGS*, tree, rtx);\n \n extern rtx m68hc11_function_arg (const CUMULATIVE_ARGS* ,\n                                  enum machine_mode,\n                                  tree, int);\n-extern int m68hc11_function_arg_padding (enum machine_mode, const_tree);\n+#ifdef ARGS_SIZE_RTX\n+extern enum direction m68hc11_function_arg_padding (enum machine_mode,\n+\t\t\t\t\t\t    const_tree);\n+#endif\n \n extern void m68hc11_function_epilogue (FILE*,int);\n \n extern int m68hc11_is_far_symbol (rtx);\n extern int m68hc11_is_trap_symbol (rtx);\n extern int m68hc11_page0_symbol_p (rtx x);\n \n-#endif /* TREE_CODE */\n-\n extern HOST_WIDE_INT m68hc11_min_offset;\n extern HOST_WIDE_INT m68hc11_max_offset;\n extern int m68hc11_addr_mode;\n \n #endif /* HAVE_MACHINE_MODES */\n #endif /* RTX_CODE */\n-"}, {"sha": "6cb0ed5f321c3ef9b180c13eb16f274e716bc49e", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 29, "deletions": 34, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=5a82ecd9994682d76eba3c2c6460b3566fc5654c", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n+#include \"expr.h\"\n #include \"tm_p.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -62,7 +63,7 @@ along with GCC; see the file COPYING3.  If not see\n \n static void emit_move_after_reload (rtx, rtx, rtx);\n static rtx simplify_logical (enum machine_mode, int, rtx, rtx *);\n-static void m68hc11_emit_logical (enum machine_mode, int, rtx *);\n+static void m68hc11_emit_logical (enum machine_mode, enum rtx_code, rtx *);\n static void m68hc11_reorg (void);\n static bool m68hc11_legitimate_address_p_1 (enum machine_mode, rtx, bool);\n static bool m68hc11_legitimate_address_p (enum machine_mode, rtx, bool);\n@@ -73,7 +74,7 @@ static int m68hc11_shift_cost (enum machine_mode, rtx, int);\n static int m68hc11_rtx_costs_1 (rtx, enum rtx_code, enum rtx_code);\n static bool m68hc11_rtx_costs (rtx, int, int, int *, bool);\n static tree m68hc11_handle_fntype_attribute (tree *, tree, tree, int, bool *);\n-EXPORTED_CONST struct attribute_spec m68hc11_attribute_table[];\n+static tree m68hc11_handle_page0_attribute (tree *, tree, tree, int, bool *);\n \n void create_regs_rtx (void);\n \n@@ -216,6 +217,19 @@ static const struct processor_costs m6812_cost = {\n   COSTS_N_INSNS (100)\n };\n \f\n+/* M68HC11 specific attributes.  */\n+\n+static const struct attribute_spec m68hc11_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"interrupt\", 0, 0, false, true,  true,  m68hc11_handle_fntype_attribute },\n+  { \"trap\",      0, 0, false, true,  true,  m68hc11_handle_fntype_attribute },\n+  { \"far\",       0, 0, false, true,  true,  m68hc11_handle_fntype_attribute },\n+  { \"near\",      0, 0, false, true,  true,  m68hc11_handle_fntype_attribute },\n+  { \"page0\",     0, 0, false, false, false, m68hc11_handle_page0_attribute },\n+  { NULL,        0, 0, false, false, false, NULL }\n+};\n+\f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE m68hc11_attribute_table\n@@ -653,7 +667,7 @@ m68hc11_small_indexed_indirect_p (rtx operand, enum machine_mode mode)\n       && reg_equiv_memory_loc[REGNO (operand)])\n     {\n       operand = reg_equiv_memory_loc[REGNO (operand)];\n-      operand = eliminate_regs (operand, 0, NULL_RTX);\n+      operand = eliminate_regs (operand, VOIDmode, NULL_RTX);\n     }\n \n   if (GET_CODE (operand) != MEM)\n@@ -715,7 +729,7 @@ m68hc11_register_indirect_p (rtx operand, enum machine_mode mode)\n       && reg_equiv_memory_loc[REGNO (operand)])\n     {\n       operand = reg_equiv_memory_loc[REGNO (operand)];\n-      operand = eliminate_regs (operand, 0, NULL_RTX);\n+      operand = eliminate_regs (operand, VOIDmode, NULL_RTX);\n     }\n   if (GET_CODE (operand) != MEM)\n     return 0;\n@@ -1115,17 +1129,6 @@ m68hc11_handle_page0_attribute (tree *node, tree name,\n   return NULL_TREE;\n }\n \n-const struct attribute_spec m68hc11_attribute_table[] =\n-{\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n-  { \"interrupt\", 0, 0, false, true,  true,  m68hc11_handle_fntype_attribute },\n-  { \"trap\",      0, 0, false, true,  true,  m68hc11_handle_fntype_attribute },\n-  { \"far\",       0, 0, false, true,  true,  m68hc11_handle_fntype_attribute },\n-  { \"near\",      0, 0, false, true,  true,  m68hc11_handle_fntype_attribute },\n-  { \"page0\",     0, 0, false, false, false, m68hc11_handle_page0_attribute },\n-  { NULL,        0, 0, false, false, false, NULL }\n-};\n-\n /* Keep track of the symbol which has a `trap' attribute and which uses\n    the `swi' calling convention.  Since there is only one trap, we only\n    record one such symbol.  If there are several, a warning is reported.  */\n@@ -1470,7 +1473,7 @@ m68hc11_function_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    `downward' to pad below, or `none' to inhibit padding.\n \n    Structures are stored left shifted in their argument slot.  */\n-int\n+enum direction\n m68hc11_function_arg_padding (enum machine_mode mode, const_tree type)\n {\n   if (type != 0 && AGGREGATE_TYPE_P (type))\n@@ -1503,28 +1506,16 @@ emit_move_after_reload (rtx to, rtx from, rtx scratch)\n   /* Put a REG_INC note to tell the flow analysis that the instruction\n      is necessary.  */\n   if (IS_STACK_PUSH (to))\n-    {\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC,\n-\t\t\t\t\t    XEXP (XEXP (to, 0), 0),\n-\t\t\t\t\t    REG_NOTES (insn));\n-    }\n+    add_reg_note (insn, REG_INC, XEXP (XEXP (to, 0), 0));\n   else if (IS_STACK_POP (from))\n-    {\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC,\n-\t\t\t\t\t    XEXP (XEXP (from, 0), 0),\n-\t\t\t\t\t    REG_NOTES (insn));\n-    }\n+    add_reg_note (insn, REG_INC, XEXP (XEXP (from, 0), 0));\n \n   /* For 68HC11, put a REG_INC note on `sts _.frame' to prevent the cse-reg\n      to think that sp == _.frame and later replace a x = sp with x = _.frame.\n      The problem is that we are lying to gcc and use `txs' for x = sp\n      (which is not really true because txs is really x = sp + 1).  */\n   else if (TARGET_M6811 && SP_REG_P (from))\n-    {\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC,\n-\t\t\t\t\t    from,\n-\t\t\t\t\t    REG_NOTES (insn));\n-    }\n+    add_reg_note (insn, REG_INC, from);\n }\n \n int\n@@ -2868,7 +2859,7 @@ simplify_logical (enum machine_mode mode, int code, rtx operand, rtx *result)\n }\n \n static void\n-m68hc11_emit_logical (enum machine_mode mode, int code, rtx *operands)\n+m68hc11_emit_logical (enum machine_mode mode, enum rtx_code code, rtx *operands)\n {\n   rtx result;\n   int need_copy;\n@@ -2938,7 +2929,8 @@ m68hc11_emit_logical (enum machine_mode mode, int code, rtx *operands)\n }\n \n void\n-m68hc11_split_logical (enum machine_mode mode, int code, rtx *operands)\n+m68hc11_split_logical (enum machine_mode mode, enum rtx_code code,\n+\t\t       rtx *operands)\n {\n   rtx low[4];\n   rtx high[4];\n@@ -5387,9 +5379,12 @@ m68hc11_rtx_costs_1 (rtx x, enum rtx_code code,\n }\n \n static bool\n-m68hc11_rtx_costs (rtx x, int code, int outer_code, int *total,\n+m68hc11_rtx_costs (rtx x, int codearg, int outer_code_arg, int *total,\n \t\t   bool speed ATTRIBUTE_UNUSED)\n {\n+  enum rtx_code code = (enum rtx_code) codearg;\n+  enum rtx_code outer_code = (enum rtx_code) outer_code_arg;\n+\n   switch (code)\n     {\n       /* Constants are cheap.  Moving them in registers must be avoided"}, {"sha": "77a524a0e1e02730fec39e8dee5c4c88d9b1db5f", "filename": "gcc/config/m68hc11/predicates.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fm68hc11%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fm68hc11%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fpredicates.md?ref=5a82ecd9994682d76eba3c2c6460b3566fc5654c", "patch": "@@ -1,5 +1,5 @@\n ;; Predicate definitions for Motorola 68HC11 and 68HC12.\n-;; Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n+;; Copyright (C) 2005, 2007, 2009 Free Software Foundation, Inc.\n ;;\n ;; This file is part of GCC.\n ;;\n@@ -185,7 +185,7 @@\n           && reg_equiv_memory_loc[REGNO (op)])\n          {\n             op = reg_equiv_memory_loc[REGNO (op)];\n-            op = eliminate_regs (op, 0, NULL_RTX);\n+            op = eliminate_regs (op, VOIDmode, NULL_RTX);\n          }\n       if (GET_CODE (op) != MEM)\n          return 0;"}, {"sha": "3b0adef1074a0daba4a4820da0a96e4b2fa59dc2", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=5a82ecd9994682d76eba3c2c6460b3566fc5654c", "patch": "@@ -59,7 +59,7 @@ long   mcore_current_compilation_timestamp = 0;\n \n /* Provides the class number of the smallest class containing\n    reg number.  */\n-const int regno_reg_class[FIRST_PSEUDO_REGISTER] =\n+const enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER] =\n {\n   GENERAL_REGS,\tONLYR1_REGS,  LRW_REGS,\t    LRW_REGS,\n   LRW_REGS,\tLRW_REGS,     LRW_REGS,\t    LRW_REGS,\n@@ -127,7 +127,6 @@ static void       mcore_mark_dllexport          (tree);\n static void       mcore_mark_dllimport          (tree);\n static int        mcore_dllexport_p             (tree);\n static int        mcore_dllimport_p             (tree);\n-EXPORTED_CONST struct attribute_spec mcore_attribute_table[];\n static tree       mcore_handle_naked_attribute  (tree *, tree, tree, int, bool *);\n #ifdef OBJECT_FORMAT_ELF\n static void\t  mcore_asm_named_section       (const char *,\n@@ -146,6 +145,17 @@ static int        mcore_arg_partial_bytes       (CUMULATIVE_ARGS *,\n \t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t tree, bool);\n \n+\f\n+/* MCore specific attributes.  */\n+\n+static const struct attribute_spec mcore_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"dllexport\", 0, 0, true,  false, false, NULL },\n+  { \"dllimport\", 0, 0, true,  false, false, NULL },\n+  { \"naked\",     0, 0, true,  false, false, mcore_handle_naked_attribute },\n+  { NULL,        0, 0, false, false, false, NULL }\n+};\n \f\n /* Initialize the GCC target structure.  */\n #undef  TARGET_ASM_EXTERNAL_LIBCALL\n@@ -481,7 +491,7 @@ mcore_rtx_costs (rtx x, int code, int outer_code, int * total,\n   switch (code)\n     {\n     case CONST_INT:\n-      *total = mcore_const_costs (x, outer_code);\n+      *total = mcore_const_costs (x, (enum rtx_code) outer_code);\n       return true;\n     case CONST:\n     case LABEL_REF:\n@@ -2991,15 +3001,6 @@ mcore_strip_name_encoding (const char * str)\n    dllimport - for importing a function/variable from a dll\n    naked     - do not create a function prologue/epilogue.  */\n \n-const struct attribute_spec mcore_attribute_table[] =\n-{\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n-  { \"dllexport\", 0, 0, true,  false, false, NULL },\n-  { \"dllimport\", 0, 0, true,  false, false, NULL },\n-  { \"naked\",     0, 0, true,  false, false, mcore_handle_naked_attribute },\n-  { NULL,        0, 0, false, false, false, NULL }\n-};\n-\n /* Handle a \"naked\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "9b33a1aba077b3ccd722e31862626b5aa2eee68c", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=5a82ecd9994682d76eba3c2c6460b3566fc5654c", "patch": "@@ -1,7 +1,7 @@\n /* Definitions of target machine for GNU compiler,\n    for Motorola M*CORE Processor.\n    Copyright (C) 1993, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007,\n-   2008  Free Software Foundation, Inc.\n+   2008, 2009 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -408,7 +408,7 @@ enum reg_class\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n \n-extern const int regno_reg_class[FIRST_PSEUDO_REGISTER];\n+extern const enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n #define REGNO_REG_CLASS(REGNO) regno_reg_class[REGNO]\n \n /* When defined, the compiler allows registers explicitly used in the\n@@ -754,7 +754,8 @@ extern const enum reg_class reg_class_from_letter[];\n         {\t\t\t\t\t\t\t\t\\\n \t  if (GET_MODE_SIZE (MODE) >= 4\t\t\t\t\t\\\n \t      && (((unsigned HOST_WIDE_INT) INTVAL (OP)) % 4) == 0\t\\\n-\t      &&  ((unsigned HOST_WIDE_INT) INTVAL (OP)) <= 64 - GET_MODE_SIZE (MODE))\t\\\n+\t      &&  ((unsigned HOST_WIDE_INT) INTVAL (OP))\t\t\\\n+\t      <= (unsigned HOST_WIDE_INT) 64 - GET_MODE_SIZE (MODE))\t\\\n \t    goto LABEL;\t\t\t\t\t\t\t\\\n \t  if (GET_MODE_SIZE (MODE) == 2 \t\t\t\t\\\n \t      && (((unsigned HOST_WIDE_INT) INTVAL (OP)) % 2) == 0\t\\"}, {"sha": "909b4a457689e4c445aca057779800122f34bbe0", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=5a82ecd9994682d76eba3c2c6460b3566fc5654c", "patch": "@@ -22,7 +22,7 @@\n (define_predicate \"trapping_target_operand\"\n   (match_code \"if_then_else\")\n {\n-  rtx cond, mem, res, tar, and;\n+  rtx cond, mem, res, tar, and_expr;\n \n   if (GET_MODE (op) != PDImode)\n     return 0;\n@@ -49,12 +49,12 @@\n     return 0;\n   if (GET_CODE (cond) != EQ)\n     return 0;\n-  and = XEXP (cond, 0);\n-  return (GET_CODE (and) == AND\n-\t  && rtx_equal_p (XEXP (and, 0), tar)\n-\t  && CONST_INT_P (XEXP (and, 1))\n+  and_expr = XEXP (cond, 0);\n+  return (GET_CODE (and_expr) == AND\n+\t  && rtx_equal_p (XEXP (and_expr, 0), tar)\n+\t  && CONST_INT_P (XEXP (and_expr, 1))\n \t  && CONST_INT_P (XEXP (cond, 1))\n-\t  && INTVAL (XEXP (and, 1)) == 3\n+\t  && INTVAL (XEXP (and_expr, 1)) == 3\n \t  && INTVAL (XEXP (cond, 1)) == 3);\n })\n "}, {"sha": "7c72f0098f15a041ff1f7af97d9fc714ae663b5e", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=5a82ecd9994682d76eba3c2c6460b3566fc5654c", "patch": "@@ -185,7 +185,6 @@ static void push_regs (HARD_REG_SET *, int);\n static int calc_live_regs (HARD_REG_SET *);\n static HOST_WIDE_INT rounded_frame_size (int);\n static rtx mark_constant_pool_use (rtx);\n-EXPORTED_CONST struct attribute_spec sh_attribute_table[];\n static tree sh_handle_interrupt_handler_attribute (tree *, tree, tree, int, bool *);\n static tree sh_handle_resbank_handler_attribute (tree *, tree,\n \t\t\t\t\t\t tree, int, bool *);\n@@ -268,7 +267,31 @@ static bool sh_scalar_mode_supported_p (enum machine_mode);\n static int sh_dwarf_calling_convention (const_tree);\n static void sh_encode_section_info (tree, rtx, int);\n static int sh2a_function_vector_p (tree);\n+\f\n+static const struct attribute_spec sh_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"interrupt_handler\", 0, 0, true,  false, false, sh_handle_interrupt_handler_attribute },\n+  { \"sp_switch\",         1, 1, true,  false, false, sh_handle_sp_switch_attribute },\n+  { \"trap_exit\",         1, 1, true,  false, false, sh_handle_trap_exit_attribute },\n+  { \"renesas\",           0, 0, false, true, false, sh_handle_renesas_attribute },\n+  { \"trapa_handler\",     0, 0, true,  false, false, sh_handle_interrupt_handler_attribute },\n+  { \"nosave_low_regs\",   0, 0, true,  false, false, sh_handle_interrupt_handler_attribute },\n+  { \"resbank\",           0, 0, true,  false, false, sh_handle_resbank_handler_attribute },\n+  { \"function_vector\",   1, 1, true,  false, false, sh2a_handle_function_vector_handler_attribute },\n+#ifdef SYMBIAN\n+  /* Symbian support adds three new attributes:\n+     dllexport - for exporting a function/variable that will live in a dll\n+     dllimport - for importing a function/variable from a dll\n \n+     Microsoft allows multiple declspecs in one __declspec, separating\n+     them with spaces.  We do NOT support this.  Instead, use __declspec\n+     multiple times.  */\n+  { \"dllimport\",         0, 0, true,  false, false, sh_symbian_handle_dll_attribute },\n+  { \"dllexport\",         0, 0, true,  false, false, sh_symbian_handle_dll_attribute },\n+#endif\n+  { NULL,                0, 0, false, false, false, NULL }\n+};\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ATTRIBUTE_TABLE\n@@ -8532,31 +8555,6 @@ sh_insert_attributes (tree node, tree *attributes)\n    R0-R14, MACH, MACL, GBR and PR.  This is useful only on SH2A targets.\n */\n \n-const struct attribute_spec sh_attribute_table[] =\n-{\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n-  { \"interrupt_handler\", 0, 0, true,  false, false, sh_handle_interrupt_handler_attribute },\n-  { \"sp_switch\",         1, 1, true,  false, false, sh_handle_sp_switch_attribute },\n-  { \"trap_exit\",         1, 1, true,  false, false, sh_handle_trap_exit_attribute },\n-  { \"renesas\",           0, 0, false, true, false, sh_handle_renesas_attribute },\n-  { \"trapa_handler\",     0, 0, true,  false, false, sh_handle_interrupt_handler_attribute },\n-  { \"nosave_low_regs\",   0, 0, true,  false, false, sh_handle_interrupt_handler_attribute },\n-  { \"resbank\",           0, 0, true,  false, false, sh_handle_resbank_handler_attribute },\n-  { \"function_vector\",   1, 1, true,  false, false, sh2a_handle_function_vector_handler_attribute },\n-#ifdef SYMBIAN\n-  /* Symbian support adds three new attributes:\n-     dllexport - for exporting a function/variable that will live in a dll\n-     dllimport - for importing a function/variable from a dll\n-\n-     Microsoft allows multiple declspecs in one __declspec, separating\n-     them with spaces.  We do NOT support this.  Instead, use __declspec\n-     multiple times.  */\n-  { \"dllimport\",         0, 0, true,  false, false, sh_symbian_handle_dll_attribute },\n-  { \"dllexport\",         0, 0, true,  false, false, sh_symbian_handle_dll_attribute },\n-#endif\n-  { NULL,                0, 0, false, false, false, NULL }\n-};\n-\n /* Handle a 'resbank' attribute.  */\n static tree\n sh_handle_resbank_handler_attribute (tree * node, tree name,"}, {"sha": "af67a46eaf798ab52a2f626774a0d444036555e6", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=5a82ecd9994682d76eba3c2c6460b3566fc5654c", "patch": "@@ -420,8 +420,15 @@ static void sparc_file_end (void);\n #ifdef TARGET_ALTERNATE_LONG_DOUBLE_MANGLING\n static const char *sparc_mangle_type (const_tree);\n #endif\n+\f\n #ifdef SUBTARGET_ATTRIBUTE_TABLE\n-EXPORTED_CONST struct attribute_spec sparc_attribute_table[];\n+/* Table of valid machine attributes.  */\n+static const struct attribute_spec sparc_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  SUBTARGET_ATTRIBUTE_TABLE,\n+  { NULL,        0, 0, false, false, false, NULL }\n+};\n #endif\n \f\n /* Option handling.  */\n@@ -883,16 +890,6 @@ sparc_override_options (void)\n \t\t      ? 64 : 32));\n }\n \f\n-#ifdef SUBTARGET_ATTRIBUTE_TABLE\n-/* Table of valid machine attributes.  */\n-const struct attribute_spec sparc_attribute_table[] =\n-{\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n-  SUBTARGET_ATTRIBUTE_TABLE,\n-  { NULL,        0, 0, false, false, false, NULL }\n-};\n-#endif\n-\f\n /* Miscellaneous utilities.  */\n \n /* Nonzero if CODE, a comparison, is suitable for use in v9 conditional move"}, {"sha": "07e22655b6c8e24cc8ee7691d87179f3837ad837", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=5a82ecd9994682d76eba3c2c6460b3566fc5654c", "patch": "@@ -268,7 +268,15 @@ spu_libgcc_cmp_return_mode (void);\n \n static enum machine_mode\n spu_libgcc_shift_count_mode (void);\n-\n+\f\n+/*  Table of machine attributes.  */\n+static const struct attribute_spec spu_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"naked\",          0, 0, true,  false, false, spu_handle_fndecl_attribute },\n+  { \"spu_vector\",     0, 0, false, true,  false, spu_handle_vector_attribute },\n+  { NULL,             0, 0, false, false, false, NULL }\n+};\n \f\n /*  TARGET overrides.  */\n \n@@ -316,7 +324,6 @@ spu_libgcc_shift_count_mode (void);\n #undef TARGET_SCHED_ADJUST_COST\n #define TARGET_SCHED_ADJUST_COST spu_sched_adjust_cost\n \n-EXPORTED_CONST struct attribute_spec spu_attribute_table[];\n #undef  TARGET_ATTRIBUTE_TABLE\n #define TARGET_ATTRIBUTE_TABLE spu_attribute_table\n \n@@ -481,15 +488,6 @@ spu_override_options (void)\n /* Handle an attribute requiring a FUNCTION_DECL; arguments as in\n    struct attribute_spec.handler.  */\n \n-/*  Table of machine attributes.  */\n-const struct attribute_spec spu_attribute_table[] =\n-{\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n-  { \"naked\",          0, 0, true,  false, false, spu_handle_fndecl_attribute },\n-  { \"spu_vector\",     0, 0, false, true,  false, spu_handle_vector_attribute },\n-  { NULL,             0, 0, false, false, false, NULL }\n-};\n-\n /* True if MODE is valid for the target.  By \"valid\", we mean able to\n    be manipulated in non-trivial ways.  In particular, this means all\n    the arithmetic is supported.  */"}, {"sha": "0d53a72db5cc88a7f18ef043be4bf2acb6bd3e39", "filename": "gcc/config/v850/v850-c.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fv850%2Fv850-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fv850%2Fv850-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850-c.c?ref=5a82ecd9994682d76eba3c2c6460b3566fc5654c", "patch": "@@ -1,5 +1,6 @@\n /* v850 specific, C compiler specific functions.\n-   Copyright (C) 2000, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2005, 2007, 2009\n+   Free Software Foundation, Inc.\n    Contributed by Jeff Law (law@cygnus.com).\n \n This file is part of GCC.\n@@ -114,7 +115,7 @@ mark_current_function_as_interrupt (void)\n void\n ghs_pragma_section (cpp_reader * pfile ATTRIBUTE_UNUSED)\n {\n-  int repeat;\n+  int repeat = 0;\n \n   /* #pragma ghs section [name = alias [, name = alias [, ...]]] */\n   do"}, {"sha": "bd62d1e9efd2820642eeacf54b745401e65a0de5", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a82ecd9994682d76eba3c2c6460b3566fc5654c/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=5a82ecd9994682d76eba3c2c6460b3566fc5654c", "patch": "@@ -58,7 +58,6 @@ static void substitute_ep_register   (rtx, rtx, int, int, rtx *, rtx *);\n static void v850_reorg\t\t     (void);\n static int  ep_memory_offset         (enum machine_mode, int);\n static void v850_set_data_area       (tree, v850_data_area);\n-EXPORTED_CONST struct attribute_spec v850_attribute_table[];\n static tree v850_handle_interrupt_attribute (tree *, tree, tree, int, bool *);\n static tree v850_handle_data_area_attribute (tree *, tree, tree, int, bool *);\n static void v850_insert_attributes   (tree, tree *);\n@@ -103,6 +102,20 @@ static GTY(()) section *rozdata_section;\n static GTY(()) section *tdata_section;\n static GTY(()) section *zdata_section;\n static GTY(()) section *zbss_section;\n+\f\n+/* V850 specific attributes.  */\n+\n+static const struct attribute_spec v850_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"interrupt_handler\", 0, 0, true,  false, false, v850_handle_interrupt_attribute },\n+  { \"interrupt\",         0, 0, true,  false, false, v850_handle_interrupt_attribute },\n+  { \"sda\",               0, 0, true,  false, false, v850_handle_data_area_attribute },\n+  { \"tda\",               0, 0, true,  false, false, v850_handle_data_area_attribute },\n+  { \"zda\",               0, 0, true,  false, false, v850_handle_data_area_attribute },\n+  { NULL,                0, 0, false, false, false, NULL }\n+};\n+\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_ALIGNED_HI_OP\n@@ -420,10 +433,12 @@ const_costs (rtx r, enum rtx_code c)\n \n static bool\n v850_rtx_costs (rtx x,\n-                int code,\n+                int codearg,\n                 int outer_code ATTRIBUTE_UNUSED,\n                 int * total, bool speed)\n {\n+  enum rtx_code code = (enum rtx_code) codearg;\n+\n   switch (code)\n     {\n     case CONST_INT:\n@@ -1862,7 +1877,7 @@ Saved %d bytes via epilogue function (%d vs. %d) in function %s\\n\",\n \tinit_stack_free = (signed) actual_fsize;\n \n       /* Deallocate the rest of the stack if it is > 32K.  */\n-      if (actual_fsize > init_stack_free)\n+      if ((unsigned int) actual_fsize > init_stack_free)\n \t{\n \t  int diff;\n \n@@ -2028,17 +2043,6 @@ v850_set_data_area (tree decl, v850_data_area data_area)\n     (name, NULL, DECL_ATTRIBUTES (decl));\n }\n \f\n-const struct attribute_spec v850_attribute_table[] =\n-{\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n-  { \"interrupt_handler\", 0, 0, true,  false, false, v850_handle_interrupt_attribute },\n-  { \"interrupt\",         0, 0, true,  false, false, v850_handle_interrupt_attribute },\n-  { \"sda\",               0, 0, true,  false, false, v850_handle_data_area_attribute },\n-  { \"tda\",               0, 0, true,  false, false, v850_handle_data_area_attribute },\n-  { \"zda\",               0, 0, true,  false, false, v850_handle_data_area_attribute },\n-  { NULL,                0, 0, false, false, false, NULL }\n-};\n-\n /* Handle an \"interrupt\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree"}]}