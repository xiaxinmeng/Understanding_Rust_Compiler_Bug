{"sha": "842fbaaafeb551c99d19c4be4b3c070edc8247af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQyZmJhYWFmZWI1NTFjOTlkMTljNGJlNGIzYzA3MGVkYzgyNDdhZg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-08-13T18:28:49Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-08-13T18:28:49Z"}, "message": "(GET_REAL, PUT_REAL): Add TFmode versions.\n\n(MAXDECEXP, MINDECEXP): New decimal exponent limits\nthat vary with definition of LONG_DOUBLE_TYPE_SIZE.\n(endian, ereal_atof, real_value_truncate, einfin, emdnorm, asctoeg):\nAdd cases for TFmode.\n(etartdouble): New function converts REAL_VALUE_TYPE to TFmode\nfor use by ASM_OUTPUT_LONG_DOUBLE.\n(edivm, emulm): Ifdef out, replace by faster multiply and divide.\n(etoe113, toe113, e113toe): New type conversions for TFmode.\n(asctoe113, e113toasc): New TFmode binary <-> decimal conversions.\n(at top level): Define constants ezero, eone, emtens, etens, ...\nin a new 20-byte format when LONG_DOUBLE_TYPE_SIZE = 128 and\nset NE to 10.  Otherwise, the internal format remains 12 bytes wide.\n(etoudi, etodi, ditoe, uditoe): New functions, signed and unsigned\nDImode float and fix, for real.c used in a libgcc-of-last-resort.\n(esqrt): New function, correctly rounded square root for libgcc.\n(etodec): Delete ifdef'd version.\n(eroundi, eroundui): Rename to efixi, efixui and always\nround towards zero.\nFrom frank@atom.ansto.gov.au (Frank Crawford):\n(etoibm, toibm, ibmtoe): New conversions for IBM 370 float format.\n(e53toe, e64toe, toe64, etoe53, toe53, etoe24, toe24, asctoe53,\nasctoeg, make_nan): Ifdef for IBM.\n\nFrom-SVN: r5153", "tree": {"sha": "087a633f2aa621b9040d18d6c34a9726edf986dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/087a633f2aa621b9040d18d6c34a9726edf986dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/842fbaaafeb551c99d19c4be4b3c070edc8247af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/842fbaaafeb551c99d19c4be4b3c070edc8247af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/842fbaaafeb551c99d19c4be4b3c070edc8247af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/842fbaaafeb551c99d19c4be4b3c070edc8247af/comments", "author": null, "committer": null, "parents": [{"sha": "7bb5d01e327bcb3699659786309b4a7210972950", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bb5d01e327bcb3699659786309b4a7210972950", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bb5d01e327bcb3699659786309b4a7210972950"}], "stats": {"total": 1519, "additions": 1240, "deletions": 279}, "files": [{"sha": "f610a8eb54c7bae670241cc3f167bd8e28cea39a", "filename": "gcc/real.c", "status": "modified", "additions": 1240, "deletions": 279, "changes": 1519, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842fbaaafeb551c99d19c4be4b3c070edc8247af/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842fbaaafeb551c99d19c4be4b3c070edc8247af/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=842fbaaafeb551c99d19c4be4b3c070edc8247af", "patch": "@@ -32,7 +32,7 @@ extern int errno;\n /* To enable support of XFmode extended real floating point, define\n LONG_DOUBLE_TYPE_SIZE 96 in the tm.h file (m68k.h or i386.h).\n \n-To support cross compilation between IEEE and VAX floating\n+To support cross compilation between IEEE, VAX and IBM floating\n point formats, define REAL_ARITHMETIC in the tm.h file.\n \n In either case the machine files (tm.h) must not contain any code\n@@ -59,7 +59,7 @@ transcendental functions can be obtained by ftp from\n research.att.com: netlib/cephes/ldouble.shar.Z  */\n \n /* Type of computer arithmetic.\n- * Only one of DEC, MIEEE, IBMPC, or UNK should get defined.\n+ * Only one of DEC, IBM, MIEEE, IBMPC, or UNK should get defined.\n  */\n \n /* `MIEEE' refers generically to big-endian IEEE floating-point data\n@@ -78,6 +78,11 @@ research.att.com: netlib/cephes/ldouble.shar.Z  */\n    and VAX floating point data structure.  This model currently\n    supports no type wider than DFmode.\n \n+   `IBM' refers specifically to the IBM System/370 and compatible\n+   floating point data structure.  This model currently supports\n+   no type wider than DFmode.  The IBM conversions were contributed by\n+   frank@atom.ansto.gov.au (Frank Crawford).\n+\n    If LONG_DOUBLE_TYPE_SIZE = 64 (the default, unless tm.h defines it)\n    then `long double' and `double' are both implemented, but they\n    both mean DFmode.  In this case, the software floating-point\n@@ -86,8 +91,8 @@ research.att.com: netlib/cephes/ldouble.shar.Z  */\n    in tm.h. \n \n    The case LONG_DOUBLE_TYPE_SIZE = 128 activates TFmode support\n-   (Not Yet Implemented) and may deactivate XFmode since\n-   `long double' is used to refer to both modes.    */\n+   and may deactivate XFmode since `long double' is used to refer\n+   to both modes.    */\n \n /* The following converts gcc macros into the ones used by this file.  */\n \n@@ -99,6 +104,10 @@ research.att.com: netlib/cephes/ldouble.shar.Z  */\n /* PDP-11, Pro350, VAX: */\n #define DEC 1\n #else /* it's not VAX */\n+#if TARGET_FLOAT_FORMAT == IBM_FLOAT_FORMAT\n+/* IBM System/370 style */\n+#define IBM 1\n+#else /* it's also not an IBM */\n #if TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n #if WORDS_BIG_ENDIAN\n /* Motorola IEEE, high order words come first (Sun workstation): */\n@@ -113,6 +122,7 @@ research.att.com: netlib/cephes/ldouble.shar.Z  */\n unknown arithmetic type\n #define UNK 1\n #endif /* not IEEE */\n+#endif /* not IBM */\n #endif /* not VAX */\n \n #else\n@@ -124,6 +134,10 @@ unknown arithmetic type\n #if HOST_FLOAT_FORMAT == VAX_FLOAT_FORMAT\n #define DEC 1\n #else /* it's not VAX */\n+#if HOST_FLOAT_FORMAT == IBM_FLOAT_FORMAT\n+/* IBM System/370 style */\n+#define IBM 1\n+#else /* it's also not an IBM */\n #if HOST_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n #ifdef HOST_WORDS_BIG_ENDIAN\n #define MIEEE 1\n@@ -134,13 +148,14 @@ unknown arithmetic type\n unknown arithmetic type\n #define UNK 1\n #endif /* not IEEE */\n+#endif /* not IBM */\n #endif /* not VAX */\n \n #endif /* REAL_ARITHMETIC not defined */\n \n /* Define INFINITY for support of infinity.\n    Define NANS for support of Not-a-Number's (NaN's).  */\n-#ifndef DEC\n+#if !defined(DEC) && !defined(IBM)\n #define INFINITY\n #define NANS\n #endif\n@@ -152,34 +167,6 @@ unknown arithmetic type\n #endif\n #endif\n \n-/* ehead.h\n- *\n- * Include file for extended precision arithmetic programs.\n- */\n-\n-/* Number of 16 bit words in external e type format */\n-#define NE 6\n-\n-/* Number of 16 bit words in internal format */\n-#define NI (NE+3)\n-\n-/* Array offset to exponent */\n-#define E 1\n-\n-/* Array offset to high guard word */\n-#define M 2\n-\n-/* Number of bits of precision */\n-#define NBITS ((NI-4)*16)\n-\n-/* Maximum number of decimal digits in ASCII conversion\n- * = NBITS*log10(2)\n- */\n-#define NDEC (NBITS*8/27)\n-\n-/* The exponent of 1.0 */\n-#define EXONE (0x3fff)\n-\n /* Find a host integer type that is at least 16 bits wide,\n    and another type at least twice whatever that size is. */\n \n@@ -244,10 +231,23 @@ unknown arithmetic type\n    in memory, with no holes.  */\n \n #if LONG_DOUBLE_TYPE_SIZE == 96\n+/* Number of 16 bit words in external e type format */\n+#define NE 6\n+#define MAXDECEXP 4932\n+#define MINDECEXP -4956\n #define GET_REAL(r,e) bcopy (r, e, 2*NE)\n #define PUT_REAL(e,r) bcopy (e, r, 2*NE)\n #else /* no XFmode */\n-\n+#if LONG_DOUBLE_TYPE_SIZE == 128\n+#define NE 10\n+#define MAXDECEXP 4932\n+#define MINDECEXP -4977\n+#define GET_REAL(r,e) bcopy (r, e, 2*NE)\n+#define PUT_REAL(e,r) bcopy (e, r, 2*NE)\n+#else\n+#define NE 6\n+#define MAXDECEXP 4932\n+#define MINDECEXP -4956\n #ifdef REAL_ARITHMETIC\n /* Emulator uses target format internally\n    but host stores it in host endian-ness. */\n@@ -283,8 +283,30 @@ do { EMUSHORT w[4];\t\t\\\n #define PUT_REAL(e,r) etoe53 ((e), (r))\n \n #endif /* not REAL_ARITHMETIC */\n+#endif /* not TFmode */\n #endif /* no XFmode */\n \n+\n+/* Number of 16 bit words in internal format */\n+#define NI (NE+3)\n+\n+/* Array offset to exponent */\n+#define E 1\n+\n+/* Array offset to high guard word */\n+#define M 2\n+\n+/* Number of bits of precision */\n+#define NBITS ((NI-4)*16)\n+\n+/* Maximum number of decimal digits in ASCII conversion\n+ * = NBITS*log10(2)\n+ */\n+#define NDEC (NBITS*8/27)\n+\n+/* The exponent of 1.0 */\n+#define EXONE (0x3fff)\n+\n void warning ();\n extern int extra_warnings;\n int ecmp (), enormlz (), eshift ();\n@@ -293,11 +315,12 @@ void eadd (), esub (), emul (), ediv ();\n void eshup1 (), eshup8 (), eshup6 (), eshdn1 (), eshdn8 (), eshdn6 ();\n void eabs (), eneg (), emov (), eclear (), einfin (), efloor ();\n void eldexp (), efrexp (), eifrac (), euifrac (), ltoe (), ultoe ();\n-void eround (), ereal_to_decimal (), eiinfin (), einan ();\n+void ereal_to_decimal (), eiinfin (), einan ();\n void esqrt (), elog (), eexp (), etanh (), epow ();\n-void asctoe (), asctoe24 (), asctoe53 (), asctoe64 ();\n-void etoasc (), e24toasc (), e53toasc (), e64toasc ();\n+void asctoe (), asctoe24 (), asctoe53 (), asctoe64 (), asctoe113 ();\n+void etoasc (), e24toasc (), e53toasc (), e64toasc (), e113toasc ();\n void etoe64 (), etoe53 (), etoe24 (), e64toe (), e53toe (), e24toe ();\n+void etoe113 (), e113toe ();\n void mtherr (), make_nan ();\n void enan ();\n extern unsigned EMUSHORT ezero[], ehalf[], eone[], etwo[];\n@@ -317,6 +340,13 @@ endian (e, x, mode)\n   switch (mode)\n     {\n \n+    case TFmode:\n+      /* Swap halfwords in the fourth long. */\n+      th = (unsigned long) e[6] & 0xffff;\n+      t = (unsigned long) e[7] & 0xffff;\n+      t |= th << 16;\n+      x[3] = (long) t;\n+\n     case XFmode:\n \n       /* Swap halfwords in the third long. */\n@@ -355,10 +385,18 @@ endian (e, x, mode)\n   switch (mode)\n     {\n \n+    case TFmode:\n+\n+      /* Pack the fourth long. */\n+      th = (unsigned long) e[7] & 0xffff;\n+      t = (unsigned long) e[6] & 0xffff;\n+      t |= th << 16;\n+      x[3] = (long) t;\n+\n     case XFmode:\n \n       /* Pack the third long.\n-\t Each element of the input REAL_VALUE_TYPE array has 16 bit useful bits\n+\t Each element of the input REAL_VALUE_TYPE array has 16 useful bits\n \t in it.  */\n       th = (unsigned long) e[5] & 0xffff;\n       t = (unsigned long) e[4] & 0xffff;\n@@ -543,6 +581,10 @@ ereal_atof (s, t)\n       asctoe64 (s, tem);\n       e64toe (tem, e);\n       break;\n+    case TFmode:\n+      asctoe113 (s, tem);\n+      e113toe (tem, e);\n+      break;\n     default:\n       asctoe (s, e);\n     }\n@@ -571,17 +613,15 @@ ereal_negate (x)\n }\n \n \n-/* Round real to int\n- * implements REAL_VALUE_FIX (x) (eroundi (x))\n- * The type of rounding is left unspecified by real.h.\n- * It is implemented here as round to nearest (add .5 and chop).\n+/* Round real toward zero to HOST_WIDE_INT\n+ * implements REAL_VALUE_FIX (x).\n  */\n-int \n-eroundi (x)\n+long\n+efixi (x)\n      REAL_VALUE_TYPE x;\n {\n   unsigned EMUSHORT f[NE], g[NE];\n-  EMULONG l;\n+  long l;\n \n   GET_REAL (&x, f);\n #ifdef NANS\n@@ -591,23 +631,20 @@ eroundi (x)\n       return (-1);\n     }\n #endif\n-  eround (f, g);\n-  eifrac (g, &l, f);\n-  return ((int) l);\n+  eifrac (f, &l, g);\n+  return l;\n }\n \n-/* Round real to nearest unsigned int\n- * implements  REAL_VALUE_UNSIGNED_FIX (x) ((unsigned int) eroundi (x))\n+/* Round real toward zero to unsigned HOST_WIDE_INT\n+ * implements  REAL_VALUE_UNSIGNED_FIX (x).\n  * Negative input returns zero.\n- * The type of rounding is left unspecified by real.h.\n- * It is implemented here as round to nearest (add .5 and chop).\n  */\n-unsigned int \n-eroundui (x)\n+unsigned long\n+efixui (x)\n      REAL_VALUE_TYPE x;\n {\n   unsigned EMUSHORT f[NE], g[NE];\n-  unsigned EMULONG l;\n+  unsigned long l;\n \n   GET_REAL (&x, f);\n #ifdef NANS\n@@ -617,9 +654,8 @@ eroundui (x)\n       return (-1);\n     }\n #endif\n-  eround (f, g);\n-  euifrac (g, &l, f);\n-  return ((unsigned int)l);\n+  euifrac (f, &l, g);\n+  return l;\n }\n \n \n@@ -814,6 +850,11 @@ real_value_truncate (mode, arg)\n   eclear (t);\n   switch (mode)\n     {\n+    case TFmode:\n+      etoe113 (e, t);\n+      e113toe (t, t);\n+      break;\n+\n     case XFmode:\n       etoe64 (e, t);\n       e64toe (t, t);\n@@ -844,6 +885,21 @@ real_value_truncate (mode, arg)\n \n /* Target values are arrays of host longs. A long is guaranteed\n    to be at least 32 bits wide. */\n+\n+/* 128-bit long double */\n+void \n+etartdouble (r, l)\n+     REAL_VALUE_TYPE r;\n+     long l[];\n+{\n+  unsigned EMUSHORT e[NE];\n+\n+  GET_REAL (&r, e);\n+  etoe113 (e, e);\n+  endian (e, l, TFmode);\n+}\n+\n+/* 80-bit long double */\n void \n etarldouble (r, l)\n      REAL_VALUE_TYPE r;\n@@ -956,6 +1012,7 @@ ereal_isneg (x)\n  *\te24toe (&f, e)\t\tIEEE single precision to e type\n  *\te53toe (&d, e)\t\tIEEE double precision to e type\n  *\te64toe (&d, e)\t\tIEEE long double precision to e type\n+ *\te113toe (&d, e)\t\t128-bit long double precision to e type\n  *\teabs (e)\t\t\tabsolute value\n  *\teadd (a, b, c)\t\tc = b + a\n  *\teclear (e)\t\te = 0\n@@ -975,7 +1032,8 @@ ereal_isneg (x)\n  *\tesub (a, b, c)\t\tc = b - a\n  *\te24toasc (&f, str, n)\tsingle to ASCII string, n digits after decimal\n  *\te53toasc (&d, str, n)\tdouble to ASCII string, n digits after decimal\n- *\te64toasc (&d, str, n)\tlong double to ASCII string\n+ *\te64toasc (&d, str, n)\t80-bit long double to ASCII string\n+ *\te113toasc (&d, str, n)\t128-bit long double to ASCII string\n  *\tetoasc (e, str, n)\te to ASCII string, n digits after decimal\n  *\tetoe24 (e, &f)\t\tconvert e type to IEEE single precision\n  *\tetoe53 (e, &d)\t\tconvert e type to IEEE double precision\n@@ -1104,89 +1162,94 @@ ereal_isneg (x)\n \n /*  e type constants used by high precision check routines */\n \n-/*include \"ehead.h\"*/\n+#if LONG_DOUBLE_TYPE_SIZE == 128\n /* 0.0 */\n unsigned EMUSHORT ezero[NE] =\n-{\n-  0, 0000000, 0000000, 0000000, 0000000, 0000000,};\n+ {0x0000, 0x0000, 0x0000, 0x0000,\n+  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,};\n extern unsigned EMUSHORT ezero[];\n \n /* 5.0E-1 */\n unsigned EMUSHORT ehalf[NE] =\n-{\n-  0, 0000000, 0000000, 0000000, 0100000, 0x3ffe,};\n+ {0x0000, 0x0000, 0x0000, 0x0000,\n+  0x0000, 0x0000, 0x0000, 0x0000, 0x8000, 0x3ffe,};\n extern unsigned EMUSHORT ehalf[];\n \n /* 1.0E0 */\n unsigned EMUSHORT eone[NE] =\n-{\n-  0, 0000000, 0000000, 0000000, 0100000, 0x3fff,};\n+ {0x0000, 0x0000, 0x0000, 0x0000,\n+  0x0000, 0x0000, 0x0000, 0x0000, 0x8000, 0x3fff,};\n extern unsigned EMUSHORT eone[];\n \n /* 2.0E0 */\n unsigned EMUSHORT etwo[NE] =\n-{\n-  0, 0000000, 0000000, 0000000, 0100000, 0040000,};\n+ {0x0000, 0x0000, 0x0000, 0x0000,\n+  0x0000, 0x0000, 0x0000, 0x0000, 0x8000, 0x4000,};\n extern unsigned EMUSHORT etwo[];\n \n /* 3.2E1 */\n unsigned EMUSHORT e32[NE] =\n-{\n-  0, 0000000, 0000000, 0000000, 0100000, 0040004,};\n+ {0x0000, 0x0000, 0x0000, 0x0000,\n+  0x0000, 0x0000, 0x0000, 0x0000, 0x8000, 0x4004,};\n extern unsigned EMUSHORT e32[];\n \n /* 6.93147180559945309417232121458176568075500134360255E-1 */\n unsigned EMUSHORT elog2[NE] =\n-{\n-  0xc9e4, 0x79ab, 0150717, 0013767, 0130562, 0x3ffe,};\n+ {0x40f3, 0xf6af, 0x03f2, 0xb398,\n+  0xc9e3, 0x79ab, 0150717, 0013767, 0130562, 0x3ffe,};\n extern unsigned EMUSHORT elog2[];\n \n /* 1.41421356237309504880168872420969807856967187537695E0 */\n unsigned EMUSHORT esqrt2[NE] =\n-{\n-  0x597e, 0x6484, 0174736, 0171463, 0132404, 0x3fff,};\n+ {0x1d6f, 0xbe9f, 0x754a, 0x89b3,\n+  0x597d, 0x6484, 0174736, 0171463, 0132404, 0x3fff,};\n extern unsigned EMUSHORT esqrt2[];\n \n-/* 2/sqrt (PI) =\n- * 1.12837916709551257389615890312154517168810125865800E0 */\n-unsigned EMUSHORT eoneopi[NE] =\n-{\n-  0x71d5, 0x688d, 0012333, 0135202, 0110156, 0x3fff,};\n-extern unsigned EMUSHORT eoneopi[];\n-\n /* 3.14159265358979323846264338327950288419716939937511E0 */\n unsigned EMUSHORT epi[NE] =\n-{\n+ {0x2902, 0x1cd1, 0x80dc, 0x628b,\n   0xc4c6, 0xc234, 0020550, 0155242, 0144417, 0040000,};\n extern unsigned EMUSHORT epi[];\n \n-/* 5.7721566490153286060651209008240243104215933593992E-1 */\n-unsigned EMUSHORT eeul[NE] =\n-{\n-  0xd1be, 0xc7a4, 0076660, 0063743, 0111704, 0x3ffe,};\n-extern unsigned EMUSHORT eeul[];\n-\n-/*\n-include \"ehead.h\"\n-include \"mconf.h\"\n-*/\n+#else\n+/* LONG_DOUBLE_TYPE_SIZE is other than 128 */\n+unsigned EMUSHORT ezero[NE] =\n+ {0, 0000000, 0000000, 0000000, 0000000, 0000000,};\n+unsigned EMUSHORT ehalf[NE] =\n+ {0, 0000000, 0000000, 0000000, 0100000, 0x3ffe,};\n+unsigned EMUSHORT eone[NE] =\n+ {0, 0000000, 0000000, 0000000, 0100000, 0x3fff,};\n+unsigned EMUSHORT etwo[NE] =\n+ {0, 0000000, 0000000, 0000000, 0100000, 0040000,};\n+unsigned EMUSHORT e32[NE] =\n+ {0, 0000000, 0000000, 0000000, 0100000, 0040004,};\n+unsigned EMUSHORT elog2[NE] =\n+ {0xc9e4, 0x79ab, 0150717, 0013767, 0130562, 0x3ffe,};\n+unsigned EMUSHORT esqrt2[NE] =\n+ {0x597e, 0x6484, 0174736, 0171463, 0132404, 0x3fff,};\n+unsigned EMUSHORT epi[NE] =\n+ {0xc4c6, 0xc234, 0020550, 0155242, 0144417, 0040000,};\n+#endif\n \n \n \n /* Control register for rounding precision.\n- * This can be set to 80 (if NE=6), 64, 56, 53, or 24 bits.\n+ * This can be set to 113 (if NE=10), 80 (if NE=6), 64, 56, 53, or 24 bits.\n  */\n int rndprc = NBITS;\n extern int rndprc;\n \n void eaddm (), esubm (), emdnorm (), asctoeg ();\n-static void toe24 (), toe53 (), toe64 ();\n+static void toe24 (), toe53 (), toe64 (), toe113 ();\n void eremain (), einit (), eiremain ();\n int ecmpm (), edivm (), emulm ();\n void emovi (), emovo (), emovz (), ecleaz (), ecleazs (), eadd1 ();\n+#ifdef DEC\n void etodec (), todec (), dectoe ();\n-\n-\n+#endif\n+#ifdef IBM\n+void etoibm (), toibm (), ibmtoe ();\n+#endif\n \n \n void \n@@ -1331,9 +1394,7 @@ eisnan (x)\n }\n \n /*  Fill external format number with infinity pattern (IEEE)\n-    or largest possible number (non-IEEE).\n-    Before calling einfin, you should either call eclear \n-    or set up the sign bit by hand.  */\n+    or largest possible number (non-IEEE). */\n \n void \n einfin (x)\n@@ -1351,6 +1412,11 @@ einfin (x)\n   *x |= 32766;\n   if (rndprc < NBITS)\n     {\n+      if (rndprc == 113)\n+\t{\n+\t  *(x - 9) = 0;\n+\t  *(x - 8) = 0;\n+\t}\n       if (rndprc == 64)\n \t{\n \t  *(x - 5) = 0;\n@@ -1463,7 +1529,7 @@ emovo (a, b)\n \t}\n #endif\n       einfin (b);\n-      return;\n+\treturn;\n     }\n #endif\n   /* skip over guard word */\n@@ -1818,10 +1884,15 @@ esubm (x, y)\n }\n \n \n-/* Divide significands */\n-\n static unsigned EMUSHORT equot[NI];\n \n+\n+#if 0\n+/* Radix 2 shift-and-add versions of multiply and divide  */\n+\n+\n+/* Divide significands */\n+\n int \n edivm (den, num)\n      unsigned EMUSHORT den[], num[];\n@@ -1964,6 +2035,161 @@ emulm (a, b)\n   return (j);\n }\n \n+#else\n+\n+/* Radix 65536 versions of multiply and divide  */\n+\n+\n+/* Multiply significand of e-type number b\n+by 16-bit quantity a, e-type result to c. */\n+\n+void m16m( a, b, c )\n+unsigned short a;\n+unsigned short b[], c[];\n+{\n+register unsigned short *pp;\n+register unsigned long carry;\n+unsigned short *ps;\n+unsigned short p[NI];\n+unsigned long aa, m;\n+int i;\n+\n+aa = a;\n+pp = &p[NI-2];\n+*pp++ = 0;\n+*pp = 0;\n+ps = &b[NI-1];\n+\n+for( i=M+1; i<NI; i++ )\n+\t{\n+\tif( *ps == 0 )\n+\t\t{\n+\t\t--ps;\n+\t\t--pp;\n+\t\t*(pp-1) = 0;\n+\t\t}\n+\telse\n+\t\t{\n+\t\tm = (unsigned long) aa * *ps--;\n+\t\tcarry = (m & 0xffff) + *pp;\n+\t\t*pp-- = (unsigned short )carry;\n+\t\tcarry = (carry >> 16) + (m >> 16) + *pp;\n+\t\t*pp = (unsigned short )carry;\n+\t\t*(pp-1) = carry >> 16;\n+\t\t}\n+\t}\n+for( i=M; i<NI; i++ )\n+\tc[i] = p[i];\n+}\n+\n+\n+/* Divide significands. Neither the numerator nor the denominator\n+is permitted to have its high guard word nonzero.  */\n+\n+\n+int edivm( den, num )\n+unsigned short den[], num[];\n+{\n+int i;\n+register unsigned short *p;\n+unsigned long tnum;\n+unsigned short j, tdenm, tquot;\n+unsigned short tprod[NI+1];\n+\n+p = &equot[0];\n+*p++ = num[0];\n+*p++ = num[1];\n+\n+for( i=M; i<NI; i++ )\n+\t{\n+\t*p++ = 0;\n+\t}\n+eshdn1( num );\n+tdenm = den[M+1];\n+for( i=M; i<NI; i++ )\n+\t{\n+\t/* Find trial quotient digit (the radix is 65536). */\n+\ttnum = (((unsigned long) num[M]) << 16) + num[M+1];\n+\n+\t/* Do not execute the divide instruction if it will overflow. */\n+        if( (tdenm * 0xffffL) < tnum )\n+\t\ttquot = 0xffff;\n+\telse\n+\t\ttquot = tnum / tdenm;\n+\t/* Multiply denominator by trial quotient digit. */\n+\tm16m( tquot, den, tprod );\n+\t/* The quotient digit may have been overestimated. */\n+\tif( ecmpm( tprod, num ) > 0 )\n+\t\t{\n+\t\ttquot -= 1;\n+\t\tesubm( den, tprod );\n+\t\tif( ecmpm( tprod, num ) > 0 )\n+\t\t\t{\n+\t\t\ttquot -= 1;\n+\t\t\tesubm( den, tprod );\n+\t\t\t}\n+\t\t}\n+\tesubm( tprod, num );\n+\tequot[i] = tquot;\n+\teshup6(num);\n+\t}\n+/* test for nonzero remainder after roundoff bit */\n+p = &num[M];\n+j = 0;\n+for( i=M; i<NI; i++ )\n+\t{\n+\tj |= *p++;\n+\t}\n+if( j )\n+\tj = 1;\n+\n+for( i=0; i<NI; i++ )\n+\tnum[i] = equot[i];\n+\n+return( (int )j );\n+}\n+\n+\n+\n+/* Multiply significands */\n+int emulm( a, b )\n+unsigned short a[], b[];\n+{\n+unsigned short *p, *q;\n+unsigned short pprod[NI];\n+unsigned short j;\n+int i;\n+\n+equot[0] = b[0];\n+equot[1] = b[1];\n+for( i=M; i<NI; i++ )\n+\tequot[i] = 0;\n+\n+j = 0;\n+p = &a[NI-1];\n+q = &equot[NI-1];\n+for( i=M+1; i<NI; i++ )\n+\t{\n+\tif( *p == 0 )\n+\t\t{\n+\t\t--p;\n+\t\t}\n+\telse\n+\t\t{\n+\t\tm16m( *p--, b, pprod );\n+\t\teaddm(pprod, equot);\n+\t\t}\n+\tj |= *q;\n+\teshdn6(equot);\n+\t}\n+\n+for( i=0; i<NI; i++ )\n+\tb[i] = equot[i];\n+\n+/* return flag for lost nonzero bits */\n+return( (int)j );\n+}\n+#endif\n \n \n /*\n@@ -1984,6 +2210,17 @@ emulm (a, b)\n  * Input \"rcntrl\" is the rounding control.\n  */\n \n+/* For future reference:  In order for emdnorm to round off denormal\n+   significands at the right point, the input exponent must be\n+   adjusted to be the actual value it would have after conversion to\n+   the final floating point type.  This adjustment has been\n+   implemented for all type conversions (etoe53, etc.) and decimal\n+   conversions, but not for the arithmetic functions (eadd, etc.). \n+   Data types having standard 15-bit exponents are not affected by\n+   this, but SFmode and DFmode are affected. For example, ediv with\n+   rndprc = 24 will not round correctly to 24-bit precision if the\n+   result is denormal.   */\n+\n static int rlast = -1;\n static int rw = 0;\n static unsigned EMUSHORT rmsk = 0;\n@@ -2054,68 +2291,62 @@ emdnorm (s, lost, subflg, exp, rcntrl)\n \t  rw = NI - 1;\t\t/* low guard word */\n \t  rmsk = 0xffff;\n \t  rmbit = 0x8000;\n-\t  rbit[rw - 1] = 1;\n-\t  re = NI - 2;\n+\t  re = rw - 1;\n \t  rebit = 1;\n \t  break;\n+\tcase 113:\n+\t  rw = 10;\n+\t  rmsk = 0x7fff;\n+\t  rmbit = 0x4000;\n+\t  rebit = 0x8000;\n+\t  re = rw;\n+\t  break;\n \tcase 64:\n \t  rw = 7;\n \t  rmsk = 0xffff;\n \t  rmbit = 0x8000;\n-\t  rbit[rw - 1] = 1;\n \t  re = rw - 1;\n \t  rebit = 1;\n \t  break;\n-\t  /* For DEC arithmetic */\n+\t  /* For DEC or IBM arithmetic */\n \tcase 56:\n \t  rw = 6;\n \t  rmsk = 0xff;\n \t  rmbit = 0x80;\n-\t  rbit[rw] = 0x100;\n-\t  re = rw;\n \t  rebit = 0x100;\n+\t  re = rw;\n \t  break;\n \tcase 53:\n \t  rw = 6;\n \t  rmsk = 0x7ff;\n \t  rmbit = 0x0400;\n-\t  rbit[rw] = 0x800;\n-\t  re = rw;\n \t  rebit = 0x800;\n+\t  re = rw;\n \t  break;\n \tcase 24:\n \t  rw = 4;\n \t  rmsk = 0xff;\n \t  rmbit = 0x80;\n-\t  rbit[rw] = 0x100;\n-\t  re = rw;\n \t  rebit = 0x100;\n+\t  re = rw;\n \t  break;\n \t}\n+      rbit[re] = rebit;\n       rlast = rndprc;\n     }\n \n-  if (rndprc >= 64)\n+  /* Shift down 1 temporarily if the data structure has an implied\n+     most significant bit and the number is denormal.  */\n+  if ((exp <= 0) && (rndprc != 64) && (rndprc != NBITS))\n     {\n-      r = s[rw] & rmsk;\n-      if (rndprc == 64)\n-\t{\n-\t  i = rw + 1;\n-\t  while (i < NI)\n-\t    {\n-\t      if (s[i])\n-\t\tr |= 1;\n-\t      s[i] = 0;\n-\t      ++i;\n-\t    }\n-\t}\n+      lost |= s[NI - 1] & 1;\n+      eshdn1 (s);\n     }\n-  else\n+  /* Clear out all bits below the rounding bit,\n+     remembering in r if any were nonzero.  */\n+  r = s[rw] & rmsk;\n+  if (rndprc < NBITS)\n     {\n-      if (exp <= 0)\n-\teshdn1 (s);\n-      r = s[rw] & rmsk;\n-      /* These tests assume NI = 8 */\n       i = rw + 1;\n       while (i < NI)\n \t{\n@@ -2124,15 +2355,6 @@ emdnorm (s, lost, subflg, exp, rcntrl)\n \t  s[i] = 0;\n \t  ++i;\n \t}\n-      /*\n-\t if (rndprc == 24)\n-\t {\n-\t if (s[5] || s[6])\n-\t r |= 1;\n-\t s[5] = 0;\n-\t s[6] = 0;\n-\t }\n-\t */\n     }\n   s[rw] &= ~rmsk;\n   if ((r & rmbit) != 0)\n@@ -2153,7 +2375,7 @@ emdnorm (s, lost, subflg, exp, rcntrl)\n       eaddm (rbit, s);\n     }\n  mddone:\n-  if ((rndprc < 64) && (exp <= 0))\n+  if ((exp <= 0) && (rndprc != 64) && (rndprc != NBITS))\n     {\n       eshup1 (s);\n     }\n@@ -2181,7 +2403,7 @@ emdnorm (s, lost, subflg, exp, rcntrl)\n       for (i = M + 1; i < NI - 1; i++)\n \ts[i] = 0xffff;\n       s[NI - 1] = 0;\n-      if (rndprc < 64)\n+      if ((rndprc < 64) || (rndprc == 113))\n \t{\n \t  s[rw] &= ~rmsk;\n \t  if (rndprc == 24)\n@@ -2602,7 +2824,11 @@ e53toe (pe, y)\n   dectoe (pe, y);\t\t/* see etodec.c */\n \n #else\n+#ifdef IBM\n+\n+  ibmtoe (pe, y, DFmode);\n \n+#else\n   register unsigned EMUSHORT r;\n   register unsigned EMUSHORT *e, *p;\n   unsigned EMUSHORT yy[NI];\n@@ -2678,6 +2904,7 @@ e53toe (pe, y)\n \tyy[E] -= (unsigned EMUSHORT) (k - 1);\n     }\n   emovo (yy, y);\n+#endif /* not IBM */\n #endif /* not DEC */\n }\n \n@@ -2697,10 +2924,18 @@ e64toe (pe, y)\n   for (i = 0; i < 5; i++)\n     *p++ = *e++;\n #endif\n+/* This precision is not ordinarily supported on DEC or IBM. */\n #ifdef DEC\n   for (i = 0; i < 5; i++)\n     *p++ = *e++;\n #endif\n+#ifdef IBM\n+  p = &yy[0] + (NE - 1);\n+  *p-- = *e++;\n+  ++e;\n+  for (i = 0; i < 5; i++)\n+    *p-- = *e++;\n+#endif\n #ifdef MIEEE\n   p = &yy[0] + (NE - 1);\n   *p-- = *e++;\n@@ -2746,93 +2981,257 @@ e64toe (pe, y)\n }\n \n \n-/*\n-; Convert IEEE single precision to e type\n-;\tfloat d;\n-;\tunsigned EMUSHORT x[N+2];\n-;\tdtox (&d, x);\n-*/\n void \n-e24toe (pe, y)\n+e113toe (pe, y)\n      unsigned EMUSHORT *pe, *y;\n {\n   register unsigned EMUSHORT r;\n-  register unsigned EMUSHORT *e, *p;\n+  unsigned EMUSHORT *e, *p;\n   unsigned EMUSHORT yy[NI];\n-  int denorm, k;\n+  int denorm, i;\n \n   e = pe;\n-  denorm = 0;\t\t\t/* flag if denormalized number */\n+  denorm = 0;\n   ecleaz (yy);\n #ifdef IBMPC\n-  e += 1;\n-#endif\n-#ifdef DEC\n-  e += 1;\n+  e += 7;\n #endif\n   r = *e;\n   yy[0] = 0;\n   if (r & 0x8000)\n     yy[0] = 0xffff;\n-  yy[M] = (r & 0x7f) | 0200;\n-  r &= ~0x807f;\t\t\t/* strip sign and 7 significand bits */\n+  r &= 0x7fff;\n #ifdef INFINITY\n-  if (r == 0x7f80)\n+  if (r == 0x7fff)\n     {\n #ifdef NANS\n-#ifdef MIEEE\n-      if (((pe[0] & 0x7f) != 0) || (pe[1] != 0))\n+#ifdef IBMPC\n+      for (i = 0; i < 7; i++)\n \t{\n-\t  enan (y);\n-\t  return;\n+\t  if (pe[i] != 0)\n+\t    {\n+\t      enan (y);\n+\t      return;\n+\t    }\n \t}\n #else\n-      if (((pe[1] & 0x7f) != 0) || (pe[0] != 0))\n+      for (i = 1; i < 8; i++)\n \t{\n-\t  enan (y);\n-\t  return;\n+\t  if (pe[i] != 0)\n+\t    {\n+\t      enan (y);\n+\t      return;\n+\t    }\n \t}\n #endif\n-#endif  /* NANS */\n+#endif /* NANS */\n       eclear (y);\n       einfin (y);\n       if (yy[0])\n \teneg (y);\n       return;\n     }\n #endif  /* INFINITY */\n-  r >>= 7;\n-  /* If zero exponent, then the significand is denormalized.\n-   * So, take back the understood high significand bit. */\n-  if (r == 0)\n-    {\n-      denorm = 1;\n-      yy[M] &= ~0200;\n-    }\n-  r += EXONE - 0177;\n   yy[E] = r;\n   p = &yy[M + 1];\n #ifdef IBMPC\n-  *p++ = *(--e);\n-#endif\n-#ifdef DEC\n-  *p++ = *(--e);\n+  for (i = 0; i < 7; i++)\n+    *p++ = *(--e);\n #endif\n #ifdef MIEEE\n   ++e;\n-  *p++ = *e++;\n+  for (i = 0; i < 7; i++)\n+    *p++ = *e++;\n #endif\n-  eshift (yy, -8);\n-  if (denorm)\n-    {\t\t\t\t/* if zero exponent, then normalize the significand */\n-      if ((k = enormlz (yy)) > NBITS)\n-\tecleazs (yy);\n-      else\n-\tyy[E] -= (unsigned EMUSHORT) (k - 1);\n+/* If denormal, remove the implied bit; else shift down 1. */\n+  if (r == 0)\n+    {\n+      yy[M] = 0;\n+    }\n+  else\n+    {\n+      yy[M] = 1;\n+      eshift (yy, -1);\n+    }\n+  emovo (yy, y);\n+}\n+\n+\n+/*\n+; Convert IEEE single precision to e type\n+;\tfloat d;\n+;\tunsigned EMUSHORT x[N+2];\n+;\tdtox (&d, x);\n+*/\n+void \n+e24toe (pe, y)\n+     unsigned EMUSHORT *pe, *y;\n+{\n+#ifdef IBM\n+\n+  ibmtoe (pe, y, SFmode);\n+\n+#else\n+  register unsigned EMUSHORT r;\n+  register unsigned EMUSHORT *e, *p;\n+  unsigned EMUSHORT yy[NI];\n+  int denorm, k;\n+\n+  e = pe;\n+  denorm = 0;\t\t\t/* flag if denormalized number */\n+  ecleaz (yy);\n+#ifdef IBMPC\n+  e += 1;\n+#endif\n+#ifdef DEC\n+  e += 1;\n+#endif\n+  r = *e;\n+  yy[0] = 0;\n+  if (r & 0x8000)\n+    yy[0] = 0xffff;\n+  yy[M] = (r & 0x7f) | 0200;\n+  r &= ~0x807f;\t\t\t/* strip sign and 7 significand bits */\n+#ifdef INFINITY\n+  if (r == 0x7f80)\n+    {\n+#ifdef NANS\n+#ifdef MIEEE\n+      if (((pe[0] & 0x7f) != 0) || (pe[1] != 0))\n+\t{\n+\t  enan (y);\n+\t  return;\n+\t}\n+#else\n+      if (((pe[1] & 0x7f) != 0) || (pe[0] != 0))\n+\t{\n+\t  enan (y);\n+\t  return;\n+\t}\n+#endif\n+#endif  /* NANS */\n+      eclear (y);\n+      einfin (y);\n+      if (yy[0])\n+\teneg (y);\n+      return;\n+    }\n+#endif  /* INFINITY */\n+  r >>= 7;\n+  /* If zero exponent, then the significand is denormalized.\n+   * So, take back the understood high significand bit. */\n+  if (r == 0)\n+    {\n+      denorm = 1;\n+      yy[M] &= ~0200;\n+    }\n+  r += EXONE - 0177;\n+  yy[E] = r;\n+  p = &yy[M + 1];\n+#ifdef IBMPC\n+  *p++ = *(--e);\n+#endif\n+#ifdef DEC\n+  *p++ = *(--e);\n+#endif\n+#ifdef MIEEE\n+  ++e;\n+  *p++ = *e++;\n+#endif\n+  eshift (yy, -8);\n+  if (denorm)\n+    {\t\t\t\t/* if zero exponent, then normalize the significand */\n+      if ((k = enormlz (yy)) > NBITS)\n+\tecleazs (yy);\n+      else\n+\tyy[E] -= (unsigned EMUSHORT) (k - 1);\n     }\n   emovo (yy, y);\n+#endif /* not IBM */\n+}\n+\n+\n+void \n+etoe113 (x, e)\n+     unsigned EMUSHORT *x, *e;\n+{\n+  unsigned EMUSHORT xi[NI];\n+  EMULONG exp;\n+  int rndsav;\n+\n+#ifdef NANS\n+  if (eisnan (x))\n+    {\n+      make_nan (e, TFmode);\n+      return;\n+    }\n+#endif\n+  emovi (x, xi);\n+  exp = (EMULONG) xi[E];\n+#ifdef INFINITY\n+  if (eisinf (x))\n+    goto nonorm;\n+#endif\n+  /* round off to nearest or even */\n+  rndsav = rndprc;\n+  rndprc = 113;\n+  emdnorm (xi, 0, 0, exp, 64);\n+  rndprc = rndsav;\n+ nonorm:\n+  toe113 (xi, e);\n }\n \n+/* move out internal format to ieee long double */\n+static void \n+toe113 (a, b)\n+     unsigned EMUSHORT *a, *b;\n+{\n+  register unsigned EMUSHORT *p, *q;\n+  unsigned EMUSHORT i;\n+\n+#ifdef NANS\n+  if (eiisnan (a))\n+    {\n+      make_nan (b, TFmode);\n+      return;\n+    }\n+#endif\n+  p = a;\n+#ifdef MIEEE\n+  q = b;\n+#else\n+  q = b + 7;\t\t\t/* point to output exponent */\n+#endif\n+\n+  /* If not denormal, delete the implied bit. */\n+  if (a[E] != 0)\n+    {\n+      eshup1 (a);\n+    }\n+  /* combine sign and exponent */\n+  i = *p++;\n+#ifdef MIEEE\n+  if (i)\n+    *q++ = *p++ | 0x8000;\n+  else\n+    *q++ = *p++;\n+#else\n+  if (i)\n+    *q-- = *p++ | 0x8000;\n+  else\n+    *q-- = *p++;\n+#endif\n+  /* skip over guard word */\n+  ++p;\n+  /* move the significand */\n+#ifdef MIEEE\n+  for (i = 0; i < 7; i++)\n+    *q++ = *p++;\n+#else\n+  for (i = 0; i < 7; i++)\n+    *q-- = *p++;\n+#endif\n+}\n \n void \n etoe64 (x, e)\n@@ -2881,7 +3280,7 @@ toe64 (a, b)\n     }\n #endif\n   p = a;\n-#ifdef MIEEE\n+#if defined(MIEEE) || defined(IBM)\n   q = b;\n #else\n   q = b + 4;\t\t\t/* point to output exponent */\n@@ -2893,7 +3292,7 @@ toe64 (a, b)\n \n   /* combine sign and exponent */\n   i = *p++;\n-#ifdef MIEEE\n+#if defined(MIEEE) || defined(IBM)\n   if (i)\n     *q++ = *p++ | 0x8000;\n   else\n@@ -2908,7 +3307,7 @@ toe64 (a, b)\n   /* skip over guard word */\n   ++p;\n   /* move the significand */\n-#ifdef MIEEE\n+#if defined(MIEEE) || defined(IBM)\n   for (i = 0; i < 4; i++)\n     *q++ = *p++;\n #else\n@@ -2942,6 +3341,23 @@ toe53 (x, y)\n }\n \n #else\n+#ifdef IBM\n+\n+void \n+etoe53 (x, e)\n+     unsigned EMUSHORT *x, *e;\n+{\n+  etoibm (x, e, DFmode);\n+}\n+\n+static void \n+toe53 (x, y)\n+     unsigned EMUSHORT *x, *y;\n+{\n+  toibm (x, y, DFmode);\n+}\n+\n+#else  /* it's neither DEC nor IBM */\n \n void \n etoe53 (x, e)\n@@ -3053,6 +3469,7 @@ toe53 (x, y)\n #endif\n }\n \n+#endif /* not IBM */\n #endif /* not DEC */\n \n \n@@ -3063,6 +3480,24 @@ toe53 (x, y)\n ;\tunsigned EMUSHORT x[N+2];\n ;\txtod (x, &d);\n */\n+#ifdef IBM\n+\n+void \n+etoe24 (x, e)\n+     unsigned EMUSHORT *x, *e;\n+{\n+  etoibm (x, e, SFmode);\n+}\n+\n+static void \n+toe24 (x, y)\n+     unsigned EMUSHORT *x, *y;\n+{\n+  toibm (x, y, SFmode);\n+}\n+\n+#else\n+\n void \n etoe24 (x, e)\n      unsigned EMUSHORT *x, *e;\n@@ -3175,7 +3610,7 @@ toe24 (x, y)\n   *y = *p;\n #endif\n }\n-\n+#endif  /* not IBM */\n \n /* Compare two e type numbers.\n  *\n@@ -3417,13 +3852,13 @@ eifrac (x, i, frac)\n \t*i = -(*i);\n     }\n   else\n-    {\n-      /* shift not more than 16 bits */\n-      eshift (xi, k);\n-      *i = (long) xi[M] & 0xffff;\n-      if (xi[0])\n-\t*i = -(*i);\n-    }\n+      {\n+        /* shift not more than 16 bits */\n+          eshift (xi, k);\n+        *i = (long) xi[M] & 0xffff;\n+        if (xi[0])\n+\t  *i = -(*i);\n+      }\n   xi[0] = 0;\n   xi[E] = EXONE - 1;\n   xi[M] = 0;\n@@ -3495,6 +3930,7 @@ euifrac (x, i, frac)\n \n   if (xi[0])  /* A negative value yields unsigned integer 0. */\n     *i = 0L;\n+\n   xi[0] = 0;\n   xi[E] = EXONE - 1;\n   xi[M] = 0;\n@@ -3661,6 +4097,68 @@ enormlz (x)\n #define NTEN 12\n #define MAXP 4096\n \n+#if LONG_DOUBLE_TYPE_SIZE == 128\n+static unsigned EMUSHORT etens[NTEN + 1][NE] =\n+{\n+  {0x6576, 0x4a92, 0x804a, 0x153f,\n+   0xc94c, 0x979a, 0x8a20, 0x5202, 0xc460, 0x7525,},\t/* 10**4096 */\n+  {0x6a32, 0xce52, 0x329a, 0x28ce,\n+   0xa74d, 0x5de4, 0xc53d, 0x3b5d, 0x9e8b, 0x5a92,},\t/* 10**2048 */\n+  {0x526c, 0x50ce, 0xf18b, 0x3d28,\n+   0x650d, 0x0c17, 0x8175, 0x7586, 0xc976, 0x4d48,},\n+  {0x9c66, 0x58f8, 0xbc50, 0x5c54,\n+   0xcc65, 0x91c6, 0xa60e, 0xa0ae, 0xe319, 0x46a3,},\n+  {0x851e, 0xeab7, 0x98fe, 0x901b,\n+   0xddbb, 0xde8d, 0x9df9, 0xebfb, 0xaa7e, 0x4351,},\n+  {0x0235, 0x0137, 0x36b1, 0x336c,\n+   0xc66f, 0x8cdf, 0x80e9, 0x47c9, 0x93ba, 0x41a8,},\n+  {0x50f8, 0x25fb, 0xc76b, 0x6b71,\n+   0x3cbf, 0xa6d5, 0xffcf, 0x1f49, 0xc278, 0x40d3,},\n+  {0x0000, 0x0000, 0x0000, 0x0000,\n+   0xf020, 0xb59d, 0x2b70, 0xada8, 0x9dc5, 0x4069,},\n+  {0x0000, 0x0000, 0x0000, 0x0000,\n+   0x0000, 0x0000, 0x0400, 0xc9bf, 0x8e1b, 0x4034,},\n+  {0x0000, 0x0000, 0x0000, 0x0000,\n+   0x0000, 0x0000, 0x0000, 0x2000, 0xbebc, 0x4019,},\n+  {0x0000, 0x0000, 0x0000, 0x0000,\n+   0x0000, 0x0000, 0x0000, 0x0000, 0x9c40, 0x400c,},\n+  {0x0000, 0x0000, 0x0000, 0x0000,\n+   0x0000, 0x0000, 0x0000, 0x0000, 0xc800, 0x4005,},\n+  {0x0000, 0x0000, 0x0000, 0x0000,\n+   0x0000, 0x0000, 0x0000, 0x0000, 0xa000, 0x4002,},\t/* 10**1 */\n+};\n+\n+static unsigned EMUSHORT emtens[NTEN + 1][NE] =\n+{\n+  {0x2030, 0xcffc, 0xa1c3, 0x8123,\n+   0x2de3, 0x9fde, 0xd2ce, 0x04c8, 0xa6dd, 0x0ad8,},\t/* 10**-4096 */\n+  {0x8264, 0xd2cb, 0xf2ea, 0x12d4,\n+   0x4925, 0x2de4, 0x3436, 0x534f, 0xceae, 0x256b,},\t/* 10**-2048 */\n+  {0xf53f, 0xf698, 0x6bd3, 0x0158,\n+   0x87a6, 0xc0bd, 0xda57, 0x82a5, 0xa2a6, 0x32b5,},\n+  {0xe731, 0x04d4, 0xe3f2, 0xd332,\n+   0x7132, 0xd21c, 0xdb23, 0xee32, 0x9049, 0x395a,},\n+  {0xa23e, 0x5308, 0xfefb, 0x1155,\n+   0xfa91, 0x1939, 0x637a, 0x4325, 0xc031, 0x3cac,},\n+  {0xe26d, 0xdbde, 0xd05d, 0xb3f6,\n+   0xac7c, 0xe4a0, 0x64bc, 0x467c, 0xddd0, 0x3e55,},\n+  {0x2a20, 0x6224, 0x47b3, 0x98d7,\n+   0x3f23, 0xe9a5, 0xa539, 0xea27, 0xa87f, 0x3f2a,},\n+  {0x0b5b, 0x4af2, 0xa581, 0x18ed,\n+   0x67de, 0x94ba, 0x4539, 0x1ead, 0xcfb1, 0x3f94,},\n+  {0xbf71, 0xa9b3, 0x7989, 0xbe68,\n+   0x4c2e, 0xe15b, 0xc44d, 0x94be, 0xe695, 0x3fc9,},\n+  {0x3d4d, 0x7c3d, 0x36ba, 0x0d2b,\n+   0xfdc2, 0xcefc, 0x8461, 0x7711, 0xabcc, 0x3fe4,},\n+  {0xc155, 0xa4a8, 0x404e, 0x6113,\n+   0xd3c3, 0x652b, 0xe219, 0x1758, 0xd1b7, 0x3ff1,},\n+  {0xd70a, 0x70a3, 0x0a3d, 0xa3d7,\n+   0x3d70, 0xd70a, 0x70a3, 0x0a3d, 0xa3d7, 0x3ff8,},\n+  {0xcccd, 0xcccc, 0xcccc, 0xcccc,\n+   0xcccc, 0xcccc, 0xcccc, 0xcccc, 0xcccc, 0x3ffb,},\t/* 10**-1 */\n+};\n+#else\n+/* LONG_DOUBLE_TYPE_SIZE is other than 128 */\n static unsigned EMUSHORT etens[NTEN + 1][NE] =\n {\n   {0xc94c, 0x979a, 0x8a20, 0x5202, 0xc460, 0x7525,},\t/* 10**4096 */\n@@ -3694,6 +4192,7 @@ static unsigned EMUSHORT emtens[NTEN + 1][NE] =\n   {0x3d71, 0xd70a, 0x70a3, 0x0a3d, 0xa3d7, 0x3ff8,},\n   {0xcccd, 0xcccc, 0xcccc, 0xcccc, 0xcccc, 0x3ffb,},\t/* 10**-1 */\n };\n+#endif\n \n void \n e24toasc (x, string, ndigs)\n@@ -3733,6 +4232,18 @@ e64toasc (x, string, ndigs)\n   etoasc (w, string, ndigs);\n }\n \n+void \n+e113toasc (x, string, ndigs)\n+     unsigned EMUSHORT x[];\n+     char *string;\n+     int ndigs;\n+{\n+  unsigned EMUSHORT w[NI];\n+\n+  e113toe (x, w);\n+  etoasc (w, string, ndigs);\n+}\n+\n \n static char wstring[80];\t/* working storage for ASCII output */\n \n@@ -4080,7 +4591,7 @@ asctoe53 (s, y)\n      char *s;\n      unsigned EMUSHORT *y;\n {\n-#ifdef DEC\n+#if defined(DEC) || defined(IBM)\n   asctoeg (s, y, 56);\n #else\n   asctoeg (s, y, 53);\n@@ -4097,6 +4608,15 @@ asctoe64 (s, y)\n   asctoeg (s, y, 64);\n }\n \n+/* ASCII to 128-bit long double */\n+void \n+asctoe113 (s, y)\n+     char *s;\n+     unsigned EMUSHORT *y;\n+{\n+  asctoeg (s, y, 113);\n+}\n+\n /* ASCII to super double */\n void \n asctoe (s, y)\n@@ -4263,7 +4783,7 @@ asctoeg (ss, y, oprec)\n     {\n       exp *= 10;\n       exp += *s++ - '0';\n-      if (exp > 4956)\n+      if (exp > -(MINDECEXP))\n \t{\n \t  if (esign < 0)\n \t    goto zero;\n@@ -4273,14 +4793,14 @@ asctoeg (ss, y, oprec)\n     }\n   if (esign < 0)\n     exp = -exp;\n-  if (exp > 4932)\n+  if (exp > MAXDECEXP)\n     {\n  infinite:\n       ecleaz (yy);\n       yy[E] = 0x7fff;\t\t/* infinity */\n       goto aexit;\n     }\n-  if (exp < -4956)\n+  if (exp < MINDECEXP)\n     {\n  zero:\n       ecleaz (yy);\n@@ -4369,8 +4889,13 @@ asctoeg (ss, y, oprec)\n   /* Round and convert directly to the destination type */\n   if (oprec == 53)\n     lexp -= EXONE - 0x3ff;\n+#ifdef IBM\n+  else if (oprec == 24 || oprec == 56)\n+    lexp -= EXONE - (0x41 << 2);\n+#else\n   else if (oprec == 24)\n     lexp -= EXONE - 0177;\n+#endif\n #ifdef DEC\n   else if (oprec == 56)\n     lexp -= EXONE - 0201;\n@@ -4388,6 +4913,11 @@ asctoeg (ss, y, oprec)\n     case 56:\n       todec (yy, y);\t\t/* see etodec.c */\n       break;\n+#endif\n+#ifdef IBM\n+    case 56:\n+      toibm (yy, y, DFmode);\n+      break;\n #endif\n     case 53:\n       toe53 (yy, y);\n@@ -4398,6 +4928,9 @@ asctoeg (ss, y, oprec)\n     case 64:\n       toe64 (yy, y);\n       break;\n+    case 113:\n+      toe113 (yy, y);\n+      break;\n     case NBITS:\n       emovo (yy, y);\n       break;\n@@ -4713,6 +5246,7 @@ mtherr (name, code)\n    */\n }\n \n+#ifdef DEC\n /* Here is etodec.c .\n  *\n  */\n@@ -4769,86 +5303,14 @@ dectoe (d, e)\n ;\tEMUSHORT e[NE];\n ;\tetodec (e, &d);\n */\n-#if 0\n-static unsigned EMUSHORT decbit[NI] = {0, 0, 0, 0, 0, 0, 0200, 0};\n \n void \n etodec (x, d)\n      unsigned EMUSHORT *x, *d;\n {\n   unsigned EMUSHORT xi[NI];\n-  register unsigned EMUSHORT r;\n-  int i, j;\n-\n-  emovi (x, xi);\n-  *d = 0;\n-  if (xi[0] != 0)\n-    *d = 0100000;\n-  r = xi[E];\n-  if (r < (EXONE - 128))\n-    goto zout;\n-  i = xi[M + 4];\n-  if ((i & 0200) != 0)\n-    {\n-      if ((i & 0377) == 0200)\n-\t{\n-\t  if ((i & 0400) != 0)\n-\t    {\n-\t      /* check all less significant bits */\n-\t      for (j = M + 5; j < NI; j++)\n-\t\t{\n-\t\t  if (xi[j] != 0)\n-\t\t    goto yesrnd;\n-\t\t}\n-\t    }\n-\t  goto nornd;\n-\t}\n-    yesrnd:\n-      eaddm (decbit, xi);\n-      r -= enormlz (xi);\n-    }\n-\n- nornd:\n-\n-  r -= EXONE;\n-  r += 0201;\n-  if (r < 0)\n-    {\n-    zout:\n-      *d++ = 0;\n-      *d++ = 0;\n-      *d++ = 0;\n-      *d++ = 0;\n-      return;\n-    }\n-  if (r >= 0377)\n-    {\n-      *d++ = 077777;\n-      *d++ = -1;\n-      *d++ = -1;\n-      *d++ = -1;\n-      return;\n-    }\n-  r &= 0377;\n-  r <<= 7;\n-  eshup8 (xi);\n-  xi[M] &= 0177;\n-  r |= xi[M];\n-  *d++ |= r;\n-  *d++ = xi[M + 1];\n-  *d++ = xi[M + 2];\n-  *d++ = xi[M + 3];\n-}\n-\n-#else\n-\n-void \n-etodec (x, d)\n-     unsigned EMUSHORT *x, *d;\n-{\n-  unsigned EMUSHORT xi[NI];\n-  EMULONG exp;\n-  int rndsav;\n+  EMULONG exp;\n+  int rndsav;\n \n   emovi (x, xi);\n   exp = (EMULONG) xi[E] - (EXONE - 0201);\t/* adjust exponent for offsets */\n@@ -4901,9 +5363,142 @@ todec (x, y)\n   *y++ = x[M + 2];\n   *y++ = x[M + 3];\n }\n+#endif /* DEC */\n+\n+#ifdef IBM\n+/* Here is etoibm\n+ *\n+ */\n+\n+/*\n+;\tconvert IBM single/double precision to e type\n+;\tsingle/double d;\n+;\tEMUSHORT e[NE];\n+;\tenum machine_mode mode;\tSFmode/DFmode\n+;\tibmtoe (&d, e, mode);\n+*/\n+void \n+ibmtoe (d, e, mode)\n+     unsigned EMUSHORT *d;\n+     unsigned EMUSHORT *e;\n+     enum machine_mode mode;\n+{\n+  unsigned EMUSHORT y[NI];\n+  register unsigned EMUSHORT r, *p;\n+  int rndsav;\n+\n+  ecleaz (y);\t\t\t/* start with a zero */\n+  p = y;\t\t\t/* point to our number */\n+  r = *d;\t\t\t/* get IBM exponent word */\n+  if (*d & (unsigned int) 0x8000)\n+    *p = 0xffff;\t\t/* fill in our sign */\n+  ++p;\t\t\t\t/* bump pointer to our exponent word */\n+  r &= 0x7f00;\t\t\t/* strip the sign bit */\n+  r >>= 6;\t\t\t/* shift exponent word down 6 bits */\n+\t\t\t\t/* in fact shift by 8 right and 2 left */\n+  r += EXONE - (0x41 << 2);\t/* subtract IBM exponent offset */\n+  \t\t\t\t/* add our e type exponent offset */\n+  *p++ = r;\t\t\t/* to form our exponent */\n+\n+  *p++ = *d++ & 0xff;\t\t/* now do the high order mantissa */\n+\t\t\t\t/* strip off the IBM exponent and sign bits */\n+  if (mode != SFmode)\t\t/* there are only 2 words in SFmode */\n+    {\n+      *p++ = *d++;\t\t/* fill in the rest of our mantissa */\n+      *p++ = *d++;\n+    }\n+  *p = *d;\n+\n+  if (y[M] == 0 && y[M+1] == 0 && y[M+2] == 0 && y[M+3] == 0)\n+    y[0] = y[E] = 0;\n+  else\n+    y[E] -= 5 + enormlz (y);\t/* now normalise the mantissa */\n+\t\t\t      /* handle change in RADIX */\n+  emovo (y, e);\n+}\n+\n \n-#endif /* not 0 */\n \n+/*\n+;\tconvert e type to IBM single/double precision\n+;\tsingle/double d;\n+;\tEMUSHORT e[NE];\n+;\tenum machine_mode mode;\tSFmode/DFmode\n+;\tetoibm (e, &d, mode);\n+*/\n+\n+void \n+etoibm (x, d, mode)\n+     unsigned EMUSHORT *x, *d;\n+     enum machine_mode mode;\n+{\n+  unsigned EMUSHORT xi[NI];\n+  EMULONG exp;\n+  int rndsav;\n+\n+  emovi (x, xi);\n+  exp = (EMULONG) xi[E] - (EXONE - (0x41 << 2));\t/* adjust exponent for offsets */\n+\t\t\t\t\t\t\t/* round off to nearest or even */\n+  rndsav = rndprc;\n+  rndprc = 56;\n+  emdnorm (xi, 0, 0, exp, 64);\n+  rndprc = rndsav;\n+  toibm (xi, d, mode);\n+}\n+\n+void \n+toibm (x, y, mode)\n+     unsigned EMUSHORT *x, *y;\n+     enum machine_mode mode;\n+{\n+  unsigned EMUSHORT i;\n+  unsigned EMUSHORT *p;\n+  int r;\n+\n+  p = x;\n+  *y = 0;\n+  if (*p++)\n+    *y = 0x8000;\n+  i = *p++;\n+  if (i == 0)\n+    {\n+      *y++ = 0;\n+      *y++ = 0;\n+      if (mode != SFmode)\n+\t{\n+\t  *y++ = 0;\n+\t  *y++ = 0;\n+\t}\n+      return;\n+    }\n+  r = i & 0x3;\n+  i >>= 2;\n+  if (i > 0x7f)\n+    {\n+      *y++ |= 0x7fff;\n+      *y++ = 0xffff;\n+      if (mode != SFmode)\n+\t{\n+\t  *y++ = 0xffff;\n+\t  *y++ = 0xffff;\n+\t}\n+#ifdef ERANGE\n+      errno = ERANGE;\n+#endif\n+      return;\n+    }\n+  i &= 0x7f;\n+  *y |= (i << 8);\n+  eshift (x, r + 5);\n+  *y++ |= x[M];\n+  *y++ = x[M + 1];\n+  if (mode != SFmode)\n+    {\n+      *y++ = x[M + 2];\n+      *y++ = x[M + 3];\n+    }\n+}\n+#endif /* IBM */\n \n /* Output a binary NaN bit pattern in the target machine's format.  */\n \n@@ -4964,11 +5559,12 @@ enum machine_mode mode;\n   int i, n;\n   unsigned EMUSHORT *p;\n \n+  n = 0;\n   switch (mode)\n     {\n /* Possibly the `reserved operand' patterns on a VAX can be\n    used like NaN's, but probably not in the same way as IEEE. */\n-#ifndef DEC\n+#if !defined(DEC) && !defined(IBM)\n     case TFmode:\n       n = 8;\n       p = TFnan;\n@@ -5021,6 +5617,7 @@ ereal_from_float (f)\n   return r;\n }\n \n+\n /* Convert a DFmode target `double' value to a REAL_VALUE_TYPE.\n    This is the inverse of the function `etardouble' invoked by\n    REAL_VALUE_TO_TARGET_DOUBLE.\n@@ -5039,7 +5636,7 @@ ereal_from_double (d)\n   unsigned EMUSHORT e[NE];\n \n   /* Convert array of 32 bit pieces to equivalent array of 16 bit pieces.\n-     This is the inverse of `endian'.   */\n+   This is the inverse of `endian'.   */\n #if WORDS_BIG_ENDIAN\n   s[0] = (unsigned EMUSHORT) (d[0] >> 16);\n   s[1] = (unsigned EMUSHORT) d[0];\n@@ -5057,4 +5654,368 @@ ereal_from_double (d)\n   PUT_REAL (e, &r);\n   return r;\n }\n+\n+\n+/* Convert target computer unsigned 64-bit integer to e-type. */\n+\n+void\n+uditoe (di, e)\n+     unsigned EMUSHORT *di;  /* Address of the 64-bit int. */\n+     unsigned EMUSHORT *e;\n+{\n+  unsigned EMUSHORT yi[NI];\n+  int k;\n+\n+  ecleaz (yi);\n+#if WORDS_BIG_ENDIAN\n+  for (k = M; k < M + 4; k++)\n+    yi[k] = *di++;\n+#else\n+  for (k = M + 3; k >= M; k--)\n+    yi[k] = *di++;\n+#endif\n+  yi[E] = EXONE + 47;\t/* exponent if normalize shift count were 0 */\n+  if ((k = enormlz (yi)) > NBITS)/* normalize the significand */\n+    ecleaz (yi);\t\t/* it was zero */\n+  else\n+    yi[E] -= (unsigned EMUSHORT) k;/* subtract shift count from exponent */\n+  emovo (yi, e);\n+}\n+\n+/* Convert target computer signed 64-bit integer to e-type. */\n+\n+void\n+ditoe (di, e)\n+     unsigned EMUSHORT *di;  /* Address of the 64-bit int. */\n+     unsigned EMUSHORT *e;\n+{\n+  unsigned EMULONG acc;\n+  unsigned EMUSHORT yi[NI];\n+  unsigned EMUSHORT carry;\n+  int k, sign;\n+\n+  ecleaz (yi);\n+#if WORDS_BIG_ENDIAN\n+  for (k = M; k < M + 4; k++)\n+    yi[k] = *di++;\n+#else\n+  for (k = M + 3; k >= M; k--)\n+    yi[k] = *di++;\n+#endif\n+  /* Take absolute value */\n+  sign = 0;\n+  if (yi[M] & 0x8000)\n+    {\n+      sign = 1;\n+      carry = 0;\n+      for (k = M + 3; k >= M; k--)\n+\t{\n+\t  acc = (unsigned EMULONG) (~yi[k] & 0xffff) + carry;\n+\t  yi[k] = acc;\n+\t  carry = 0;\n+\t  if (acc & 0x10000)\n+\t    carry = 1;\n+\t}\n+    }\n+  yi[E] = EXONE + 47;\t/* exponent if normalize shift count were 0 */\n+  if ((k = enormlz (yi)) > NBITS)/* normalize the significand */\n+    ecleaz (yi);\t\t/* it was zero */\n+  else\n+    yi[E] -= (unsigned EMUSHORT) k;/* subtract shift count from exponent */\n+  emovo (yi, e);\n+  if (sign)\n+\teneg (e);\n+}\n+\n+\n+/* Convert e-type to unsigned 64-bit int. */\n+\n+void \n+etoudi (x, i)\n+     unsigned EMUSHORT *x;\n+     unsigned EMUSHORT *i;\n+{\n+  unsigned EMUSHORT xi[NI];\n+  int j, k;\n+\n+  emovi (x, xi);\n+  if (xi[0])\n+    {\n+      xi[M] = 0;\n+      goto noshift;\n+    }\n+  k = (int) xi[E] - (EXONE - 1);\n+  if (k <= 0)\n+    {\n+      for (j = 0; j < 4; j++)\n+\t*i++ = 0;\n+      return;\n+    }\n+  if (k > 64)\n+    {\n+      for (j = 0; j < 4; j++)\n+\t*i++ = 0xffff;\n+      if (extra_warnings)\n+\twarning (\"overflow on truncation to integer\");\n+      return;\n+    }\n+  if (k > 16)\n+    {\n+      /* Shift more than 16 bits: first shift up k-16 mod 16,\n+\t then shift up by 16's.  */\n+      j = k - ((k >> 4) << 4);\n+      if (j == 0)\n+\tj = 16;\n+      eshift (xi, j);\n+#if WORDS_BIG_ENDIAN\n+      *i++ = xi[M];\n+#else\n+      i += 3;\n+      *i-- = xi[M];\n+#endif\n+      k -= j;\n+      do\n+\t{\n+\t  eshup6 (xi);\n+#if WORDS_BIG_ENDIAN\n+\t  *i++ = xi[M];\n+#else\n+\t  *i-- = xi[M];\n+#endif\n+\t}\n+      while ((k -= 16) > 0);\n+    }\n+  else\n+    {\n+        /* shift not more than 16 bits */\n+      eshift (xi, k);\n+\n+noshift:\n+\n+#if WORDS_BIG_ENDIAN\n+      i += 3;\n+      *i-- = xi[M];\n+      *i-- = 0;\n+      *i-- = 0;\n+      *i = 0;\n+#else\n+      *i++ = xi[M];\n+      *i++ = 0;\n+      *i++ = 0;\n+      *i = 0;\n+#endif\n+    }\n+}\n+\n+\n+/* Convert e-type to signed 64-bit int. */\n+\n+void \n+etodi (x, i)\n+     unsigned EMUSHORT *x;\n+     unsigned EMUSHORT *i;\n+{\n+  unsigned EMULONG acc;\n+  unsigned EMUSHORT xi[NI];\n+  unsigned EMUSHORT carry;\n+  unsigned EMUSHORT *isave;\n+  int j, k;\n+\n+  emovi (x, xi);\n+  k = (int) xi[E] - (EXONE - 1);\n+  if (k <= 0)\n+    {\n+      for (j = 0; j < 4; j++)\n+\t*i++ = 0;\n+      return;\n+    }\n+  if (k > 64)\n+    {\n+      for (j = 0; j < 4; j++)\n+\t*i++ = 0xffff;\n+      if (extra_warnings)\n+\twarning (\"overflow on truncation to integer\");\n+      return;\n+    }\n+  isave = i;\n+  if (k > 16)\n+    {\n+      /* Shift more than 16 bits: first shift up k-16 mod 16,\n+\t then shift up by 16's.  */\n+      j = k - ((k >> 4) << 4);\n+      if (j == 0)\n+\tj = 16;\n+      eshift (xi, j);\n+#if WORDS_BIG_ENDIAN\n+      *i++ = xi[M];\n+#else\n+      i += 3;\n+      *i-- = xi[M];\n+#endif\n+      k -= j;\n+      do\n+\t{\n+\t  eshup6 (xi);\n+#if WORDS_BIG_ENDIAN\n+\t  *i++ = xi[M];\n+#else\n+\t  *i-- = xi[M];\n+#endif\n+\t}\n+      while ((k -= 16) > 0);\n+    }\n+  else\n+    {\n+        /* shift not more than 16 bits */\n+      eshift (xi, k);\n+\n+#if WORDS_BIG_ENDIAN\n+      i += 3;\n+      *i = xi[M];\n+      *i-- = 0;\n+      *i-- = 0;\n+      *i = 0;\n+#else\n+      *i++ = xi[M];\n+      *i++ = 0;\n+      *i++ = 0;\n+      *i = 0;\n+#endif\n+    }\n+  /* Negate if negative */\n+  if (xi[0])\n+    {\n+      carry = 0;\n+#if WORDS_BIG_ENDIAN\n+      isave += 3;\n+#endif\n+      for (k = 0; k < 4; k++)\n+\t{\n+\t  acc = (unsigned EMULONG) (~(*isave) & 0xffff) + carry;\n+#if WORDS_BIG_ENDIAN\n+\t  *isave-- = acc;\n+#else\n+\t  *isave++ = acc;\n+#endif\n+\t  carry = 0;\n+\t  if (acc & 0x10000)\n+\t    carry = 1;\n+\t}\n+    }\n+}\n+\n+\n+/* Longhand square root routine. */\n+\n+\n+static int esqinited = 0;\n+static unsigned short sqrndbit[NI];\n+\n+void \n+esqrt (x, y)\n+     unsigned EMUSHORT *x, *y;\n+{\n+  unsigned EMUSHORT temp[NI], num[NI], sq[NI], xx[NI];\n+  EMULONG m, exp;\n+  int i, j, k, n, nlups;\n+\n+  if (esqinited == 0)\n+    {\n+      ecleaz (sqrndbit);\n+      sqrndbit[NI - 2] = 1;\n+      esqinited = 1;\n+    }\n+  /* Check for arg <= 0 */\n+  i = ecmp (x, ezero);\n+  if (i <= 0)\n+    {\n+#ifdef NANS\n+      if (i == -2)\n+\t{\n+\t  enan (y);\n+\t  return;\n+\t}\n+#endif\n+      eclear (y);\n+      if (i < 0)\n+\tmtherr (\"esqrt\", DOMAIN);\n+      return;\n+    }\n+\n+#ifdef INFINITY\n+  if (eisinf (x))\n+    {\n+      eclear (y);\n+      einfin (y);\n+      return;\n+    }\n+#endif\n+  /* Bring in the arg and renormalize if it is denormal. */\n+  emovi (x, xx);\n+  m = (EMULONG) xx[1];\t\t/* local long word exponent */\n+  if (m == 0)\n+    m -= enormlz (xx);\n+\n+  /* Divide exponent by 2 */\n+  m -= 0x3ffe;\n+  exp = (unsigned short) ((m / 2) + 0x3ffe);\n+\n+  /* Adjust if exponent odd */\n+  if ((m & 1) != 0)\n+    {\n+      if (m > 0)\n+\texp += 1;\n+      eshdn1 (xx);\n+    }\n+\n+  ecleaz (sq);\n+  ecleaz (num);\n+  n = 8;\t\t\t/* get 8 bits of result per inner loop */\n+  nlups = rndprc;\n+  j = 0;\n+\n+  while (nlups > 0)\n+    {\n+      /* bring in next word of arg */\n+      if (j < NE)\n+\tnum[NI - 1] = xx[j + 3];\n+      /* Do additional bit on last outer loop, for roundoff. */\n+      if (nlups <= 8)\n+\tn = nlups + 1;\n+      for (i = 0; i < n; i++)\n+\t{\n+\t  /* Next 2 bits of arg */\n+\t  eshup1 (num);\n+\t  eshup1 (num);\n+\t  /* Shift up answer */\n+\t  eshup1 (sq);\n+\t  /* Make trial divisor */\n+\t  for (k = 0; k < NI; k++)\n+\t    temp[k] = sq[k];\n+\t  eshup1 (temp);\n+\t  eaddm (sqrndbit, temp);\n+\t  /* Subtract and insert answer bit if it goes in */\n+\t  if (ecmpm (temp, num) <= 0)\n+\t    {\n+\t      esubm (temp, num);\n+\t      sq[NI - 2] |= 1;\n+\t    }\n+\t}\n+      nlups -= n;\n+      j += 1;\n+    }\n+\n+  /* Adjust for extra, roundoff loop done. */\n+  exp += (NBITS - 1) - rndprc;\n+\n+  /* Sticky bit = 1 if the remainder is nonzero. */\n+  k = 0;\n+  for (i = 3; i < NI; i++)\n+    k |= (int) num[i];\n+\n+  /* Renormalize and round off. */\n+  emdnorm (sq, k, 0, exp, 64);\n+  emovo (sq, y);\n+}\n+\n #endif /* EMU_NON_COMPILE not defined */"}]}