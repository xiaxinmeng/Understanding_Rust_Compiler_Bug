{"sha": "57d08392f638bae0e0051a6ea55779b9da124d81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdkMDgzOTJmNjM4YmFlMGUwMDUxYTZlYTU1Nzc5YjlkYTEyNGQ4MQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-03-13T13:47:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-03-13T13:47:24Z"}, "message": "[multiple changes]\n\n2015-03-13  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_unst.adb (Note_Uplevel_Reference): Eliminate duplicate\n\treferences.\n\t(Actual_Ref): New function.\n\t(AREC_String): Minor reformatting.\n\t(Unnest_Subprogram): Use Actual_Ref.\n\t* frontend.adb (Frontend): Turn off Unnest_Subprogram_Mode\n\tbefore call to Instantiate_Bodies.\n\n2015-03-13  Ed Schonberg  <schonberg@adacore.com>\n\n\t* freeze.adb (Freeze_Profile): If the return type of a function\n\tbeing frozen is an untagged limited view and the function is\n\tabstract, mark the type as frozen because there is no later\n\tpoint at which the profile of the subprogram will be elaborated.\n\n2015-03-13  Robert Dewar  <dewar@adacore.com>\n\n\t* einfo.adb, einfo.ads, atree.adb, atree.ads, atree.h: Add seventh\n\tcomponent to entities. Add new fields Field36-41 and Node36-41.\n\n2015-03-13  Claire Dross  <dross@adacore.com>\n\n\t* inline.adb (Can_Be_Inlined_In_GNATprove_Mode): Rewrite after review.\n\n2015-03-13  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_util.adb (Is_Volatile_Reference): Compile time known\n\tvalue is never considered to be a volatile reference.\n\n2015-03-13  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Object_Contract): Suppress \"constant\n\tcannot be volatile\" for internally generated object (such as\n\tFIRST and LAST constants).\n\n2015-03-13  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Validate_Access_Subprogram_Instance): If a\n\tconvention is specified for the formal parameter, verify that\n\tthe actual has the same convention.\n\t* sem_prag.adb (Set_Convention_From_Pragma): Allow convention\n\tpragma to be set on a generic formal type.\n\t* sem_util.adb (Set_Convention): Ignore within an instance,\n\tas it has already been verified in the generic unit.\n\nFrom-SVN: r221422", "tree": {"sha": "902c618eea139e0d1edce4e424c2c1d1dcedc6cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/902c618eea139e0d1edce4e424c2c1d1dcedc6cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57d08392f638bae0e0051a6ea55779b9da124d81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57d08392f638bae0e0051a6ea55779b9da124d81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57d08392f638bae0e0051a6ea55779b9da124d81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57d08392f638bae0e0051a6ea55779b9da124d81/comments", "author": null, "committer": null, "parents": [{"sha": "db397e2e5a10965e953ce1801511c55fe8042295", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db397e2e5a10965e953ce1801511c55fe8042295", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db397e2e5a10965e953ce1801511c55fe8042295"}], "stats": {"total": 661, "additions": 563, "deletions": 98}, "files": [{"sha": "42f91b7bbea838ffc04b7506347d965004804c5a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=57d08392f638bae0e0051a6ea55779b9da124d81", "patch": "@@ -1,3 +1,50 @@\n+2015-03-13  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_unst.adb (Note_Uplevel_Reference): Eliminate duplicate\n+\treferences.\n+\t(Actual_Ref): New function.\n+\t(AREC_String): Minor reformatting.\n+\t(Unnest_Subprogram): Use Actual_Ref.\n+\t* frontend.adb (Frontend): Turn off Unnest_Subprogram_Mode\n+\tbefore call to Instantiate_Bodies.\n+\n+2015-03-13  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* freeze.adb (Freeze_Profile): If the return type of a function\n+\tbeing frozen is an untagged limited view and the function is\n+\tabstract, mark the type as frozen because there is no later\n+\tpoint at which the profile of the subprogram will be elaborated.\n+\n+2015-03-13  Robert Dewar  <dewar@adacore.com>\n+\n+\t* einfo.adb, einfo.ads, atree.adb, atree.ads, atree.h: Add seventh\n+\tcomponent to entities. Add new fields Field36-41 and Node36-41.\n+\n+2015-03-13  Claire Dross  <dross@adacore.com>\n+\n+\t* inline.adb (Can_Be_Inlined_In_GNATprove_Mode): Rewrite after review.\n+\n+2015-03-13  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_util.adb (Is_Volatile_Reference): Compile time known\n+\tvalue is never considered to be a volatile reference.\n+\n+2015-03-13  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Object_Contract): Suppress \"constant\n+\tcannot be volatile\" for internally generated object (such as\n+\tFIRST and LAST constants).\n+\n+2015-03-13  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Validate_Access_Subprogram_Instance): If a\n+\tconvention is specified for the formal parameter, verify that\n+\tthe actual has the same convention.\n+\t* sem_prag.adb (Set_Convention_From_Pragma): Allow convention\n+\tpragma to be set on a generic formal type.\n+\t* sem_util.adb (Set_Convention): Ignore within an instance,\n+\tas it has already been verified in the generic unit.\n+\n 2015-03-13  Claire Dross  <dross@adacore.com>\n \n \t* inline.adb (Can_Be_Inlined_In_GNATprove_Mode): Do not inline"}, {"sha": "9375087299729cff4b83b27338861483c64c4865", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=57d08392f638bae0e0051a6ea55779b9da124d81", "patch": "@@ -2553,6 +2553,42 @@ package body Atree is\n          return Nodes.Table (N + 5).Field11;\n       end Field35;\n \n+      function Field36 (N : Node_Id) return Union_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 6).Field6;\n+      end Field36;\n+\n+      function Field37 (N : Node_Id) return Union_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 6).Field7;\n+      end Field37;\n+\n+      function Field38 (N : Node_Id) return Union_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 6).Field8;\n+      end Field38;\n+\n+      function Field39 (N : Node_Id) return Union_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 6).Field9;\n+      end Field39;\n+\n+      function Field40 (N : Node_Id) return Union_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 6).Field10;\n+      end Field40;\n+\n+      function Field41 (N : Node_Id) return Union_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Nodes.Table (N + 6).Field11;\n+      end Field41;\n+\n       function Node1 (N : Node_Id) return Node_Id is\n       begin\n          pragma Assert (N <= Nodes.Last);\n@@ -2763,6 +2799,42 @@ package body Atree is\n          return Node_Id (Nodes.Table (N + 5).Field11);\n       end Node35;\n \n+      function Node36 (N : Node_Id) return Node_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Node_Id (Nodes.Table (N + 6).Field6);\n+      end Node36;\n+\n+      function Node37 (N : Node_Id) return Node_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Node_Id (Nodes.Table (N + 6).Field7);\n+      end Node37;\n+\n+      function Node38 (N : Node_Id) return Node_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Node_Id (Nodes.Table (N + 6).Field8);\n+      end Node38;\n+\n+      function Node39 (N : Node_Id) return Node_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Node_Id (Nodes.Table (N + 6).Field9);\n+      end Node39;\n+\n+      function Node40 (N : Node_Id) return Node_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Node_Id (Nodes.Table (N + 6).Field10);\n+      end Node40;\n+\n+      function Node41 (N : Node_Id) return Node_Id is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return Node_Id (Nodes.Table (N + 6).Field11);\n+      end Node41;\n+\n       function List1 (N : Node_Id) return List_Id is\n       begin\n          pragma Assert (N <= Nodes.Last);\n@@ -5334,6 +5406,42 @@ package body Atree is\n          Nodes.Table (N + 5).Field11 := Val;\n       end Set_Field35;\n \n+      procedure Set_Field36 (N : Node_Id; Val : Union_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 6).Field6 := Val;\n+      end Set_Field36;\n+\n+      procedure Set_Field37 (N : Node_Id; Val : Union_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 6).Field7 := Val;\n+      end Set_Field37;\n+\n+      procedure Set_Field38 (N : Node_Id; Val : Union_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 6).Field8 := Val;\n+      end Set_Field38;\n+\n+      procedure Set_Field39 (N : Node_Id; Val : Union_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 6).Field9 := Val;\n+      end Set_Field39;\n+\n+      procedure Set_Field40 (N : Node_Id; Val : Union_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 6).Field10 := Val;\n+      end Set_Field40;\n+\n+      procedure Set_Field41 (N : Node_Id; Val : Union_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 6).Field11 := Val;\n+      end Set_Field41;\n+\n       procedure Set_Node1 (N : Node_Id; Val : Node_Id) is\n       begin\n          pragma Assert (N <= Nodes.Last);\n@@ -5544,6 +5652,42 @@ package body Atree is\n          Nodes.Table (N + 5).Field11 := Union_Id (Val);\n       end Set_Node35;\n \n+      procedure Set_Node36 (N : Node_Id; Val : Node_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 6).Field6 := Union_Id (Val);\n+      end Set_Node36;\n+\n+      procedure Set_Node37 (N : Node_Id; Val : Node_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 6).Field7 := Union_Id (Val);\n+      end Set_Node37;\n+\n+      procedure Set_Node38 (N : Node_Id; Val : Node_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 6).Field8 := Union_Id (Val);\n+      end Set_Node38;\n+\n+      procedure Set_Node39 (N : Node_Id; Val : Node_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 6).Field9 := Union_Id (Val);\n+      end Set_Node39;\n+\n+      procedure Set_Node40 (N : Node_Id; Val : Node_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 6).Field10 := Union_Id (Val);\n+      end Set_Node40;\n+\n+      procedure Set_Node41 (N : Node_Id; Val : Node_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 6).Field11 := Union_Id (Val);\n+      end Set_Node41;\n+\n       procedure Set_List1 (N : Node_Id; Val : List_Id) is\n       begin\n          pragma Assert (N <= Nodes.Last);"}, {"sha": "c1c330cdc63617a71603fe1fa4daf4902528fd89", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 97, "deletions": 15, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=57d08392f638bae0e0051a6ea55779b9da124d81", "patch": "@@ -68,11 +68,11 @@ package Atree is\n    -- Size of Entities --\n    ----------------------\n \n-   --  Currently entities are composed of 6 sequentially allocated 32-byte\n+   --  Currently entities are composed of 7 sequentially allocated 32-byte\n    --  nodes, considered as a single record. The following definition gives\n    --  the number of extension nodes.\n \n-   Num_Extension_Nodes : Node_Id := 5;\n+   Num_Extension_Nodes : Node_Id := 6;\n    --  This value is increased by one if debug flag -gnatd.N is set. This is\n    --  for testing performance impact of adding a new extension node. We make\n    --  this of type Node_Id for easy reference in loops using this value.\n@@ -213,8 +213,8 @@ package Atree is\n    --   Elist6        Synonym for Field6 typed as Elist_Id (Empty = No_Elist)\n    --   Uint6         Synonym for Field6 typed as Uint (Empty = Uint_0)\n \n-   --   Similar definitions for Field7 to Field35 (and also Node7-Node35,\n-   --   Elist7-Elist35, Uint7-Uint35, Ureal7-Ureal35). Note that not all\n+   --   Similar definitions for Field7 to Field41 (and also Node7-Node41,\n+   --   Elist7-Elist41, Uint7-Uint41, Ureal7-Ureal41). Note that not all\n    --   these functions are defined, only the ones that are actually used.\n \n    function Last_Node_Id return Node_Id;\n@@ -355,13 +355,13 @@ package Atree is\n \n    --  Field1-5 fields are set to Empty\n \n-   --  Field6-35 fields in extended nodes are set to Empty\n+   --  Field6-41 fields in extended nodes are set to Empty\n \n    --  Parent is set to Empty\n \n    --  All Boolean flag fields are set to False\n \n-   --  Note: the value Empty is used in Field1-Field35 to indicate a null node.\n+   --  Note: the value Empty is used in Field1-Field41 to indicate a null node.\n    --  The usage varies. The common uses are to indicate absence of an optional\n    --  clause or a completely unused Field1-35 field.\n \n@@ -1185,6 +1185,24 @@ package Atree is\n       function Field35 (N : Node_Id) return Union_Id;\n       pragma Inline (Field35);\n \n+      function Field36 (N : Node_Id) return Union_Id;\n+      pragma Inline (Field36);\n+\n+      function Field37 (N : Node_Id) return Union_Id;\n+      pragma Inline (Field37);\n+\n+      function Field38 (N : Node_Id) return Union_Id;\n+      pragma Inline (Field38);\n+\n+      function Field39 (N : Node_Id) return Union_Id;\n+      pragma Inline (Field39);\n+\n+      function Field40 (N : Node_Id) return Union_Id;\n+      pragma Inline (Field40);\n+\n+      function Field41 (N : Node_Id) return Union_Id;\n+      pragma Inline (Field41);\n+\n       function Node1 (N : Node_Id) return Node_Id;\n       pragma Inline (Node1);\n \n@@ -1290,6 +1308,24 @@ package Atree is\n       function Node35 (N : Node_Id) return Node_Id;\n       pragma Inline (Node35);\n \n+      function Node36 (N : Node_Id) return Node_Id;\n+      pragma Inline (Node36);\n+\n+      function Node37 (N : Node_Id) return Node_Id;\n+      pragma Inline (Node37);\n+\n+      function Node38 (N : Node_Id) return Node_Id;\n+      pragma Inline (Node38);\n+\n+      function Node39 (N : Node_Id) return Node_Id;\n+      pragma Inline (Node39);\n+\n+      function Node40 (N : Node_Id) return Node_Id;\n+      pragma Inline (Node40);\n+\n+      function Node41 (N : Node_Id) return Node_Id;\n+      pragma Inline (Node41);\n+\n       function List1 (N : Node_Id) return List_Id;\n       pragma Inline (List1);\n \n@@ -2500,6 +2536,24 @@ package Atree is\n       procedure Set_Field35 (N : Node_Id; Val : Union_Id);\n       pragma Inline (Set_Field35);\n \n+      procedure Set_Field36 (N : Node_Id; Val : Union_Id);\n+      pragma Inline (Set_Field36);\n+\n+      procedure Set_Field37 (N : Node_Id; Val : Union_Id);\n+      pragma Inline (Set_Field37);\n+\n+      procedure Set_Field38 (N : Node_Id; Val : Union_Id);\n+      pragma Inline (Set_Field38);\n+\n+      procedure Set_Field39 (N : Node_Id; Val : Union_Id);\n+      pragma Inline (Set_Field39);\n+\n+      procedure Set_Field40 (N : Node_Id; Val : Union_Id);\n+      pragma Inline (Set_Field40);\n+\n+      procedure Set_Field41 (N : Node_Id; Val : Union_Id);\n+      pragma Inline (Set_Field41);\n+\n       procedure Set_Node1 (N : Node_Id; Val : Node_Id);\n       pragma Inline (Set_Node1);\n \n@@ -2605,6 +2659,24 @@ package Atree is\n       procedure Set_Node35 (N : Node_Id; Val : Node_Id);\n       pragma Inline (Set_Node35);\n \n+      procedure Set_Node36 (N : Node_Id; Val : Node_Id);\n+      pragma Inline (Set_Node36);\n+\n+      procedure Set_Node37 (N : Node_Id; Val : Node_Id);\n+      pragma Inline (Set_Node37);\n+\n+      procedure Set_Node38 (N : Node_Id; Val : Node_Id);\n+      pragma Inline (Set_Node38);\n+\n+      procedure Set_Node39 (N : Node_Id; Val : Node_Id);\n+      pragma Inline (Set_Node39);\n+\n+      procedure Set_Node40 (N : Node_Id; Val : Node_Id);\n+      pragma Inline (Set_Node40);\n+\n+      procedure Set_Node41 (N : Node_Id; Val : Node_Id);\n+      pragma Inline (Set_Node41);\n+\n       procedure Set_List1 (N : Node_Id; Val : List_Id);\n       pragma Inline (Set_List1);\n \n@@ -3817,8 +3889,10 @@ package Atree is\n          --  Flags 4-18 for a normal node. Note that Flags 0-3 are stored\n          --  separately in the Flags array.\n \n-         --  The above fields are used as follows in components 2-6 of\n-         --  an extended node entry.\n+         --  The above fields are used as follows in components 2-6 of an\n+         --  extended node entry. Currently they are not used in component 7,\n+         --  since for now we have all the flags we need, but of course they\n+         --  can be used for additional flags when needed in component 7.\n \n          --    In_List           used as Flag19,Flag40,Flag129,Flag216,Flag287\n          --    Has_Aspects       used as Flag20,Flag41,Flag130,Flag217,Flag288\n@@ -3849,11 +3923,12 @@ package Atree is\n          --  node, this field holds the Node_Kind value. For an extended node,\n          --  The Nkind field is used as follows:\n          --\n-         --     Second entry: holds the Ekind field of the entity\n-         --     Third entry:  holds 8 additional flags (Flag65-Flag72)\n-         --     Fourth entry: holds 8 additional flags (Flag239-246)\n-         --     Fifth entry:  holds 8 additional flags (Flag247-254)\n-         --     Sixth entry:  holds 8 additional flags (Flag310-317)\n+         --     Second entry:  holds the Ekind field of the entity\n+         --     Third entry:   holds 8 additional flags (Flag65-Flag72)\n+         --     Fourth entry:  holds 8 additional flags (Flag239-246)\n+         --     Fifth entry:   holds 8 additional flags (Flag247-254)\n+         --     Sixth entry:   holds 8 additional flags (Flag310-317)\n+         --     Seventh entry: currently unused\n \n          --  Now finally (on an 32-bit boundary) comes the variant part\n \n@@ -3926,6 +4001,13 @@ package Atree is\n             --    Field6-11      Holds Field30-Field35\n             --    Field12        Holds Flag255-Flag286\n \n+            --  In the seventh component, the extension format as described\n+            --  above is used to hold additional general fields as follows.\n+            --  Flags are also available potentially, but not used now, as\n+            --  we are not short of entity flags.\n+\n+            --    Field6-11     Holds Field36-Field41\n+\n          end case;\n       end record;\n \n@@ -3979,8 +4061,8 @@ package Atree is\n          Field5            => Empty_List_Or_Node);\n \n       --  Default value used to initialize node extensions (i.e. the second\n-      --  through sixth components of an extended node). Note we are cheating\n-      --  a bit here when it comes to Node12, which really holds flags and (for\n+      --  through seventh components of an extended node). Note we are cheating\n+      --  a bit here when it comes to Node12, which often holds flags and (for\n       --  the third component), the convention. But it works because Empty,\n       --  False, Convention_Ada, all happen to be all zero bits.\n "}, {"sha": "093b3663a7c021d0ad33d0cd374179b7580593a2", "filename": "gcc/ada/atree.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Fatree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Fatree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.h?ref=57d08392f638bae0e0051a6ea55779b9da124d81", "patch": "@@ -448,6 +448,12 @@ extern Node_Id Current_Error_Node;\n #define Field33(N)    (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.field9)\n #define Field34(N)    (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.field10)\n #define Field35(N)    (Nodes_Ptr[(N) - First_Node_Id + 5].V.EX.X.field11)\n+#define Field36(N)    (Nodes_Ptr[(N) - First_Node_Id + 6].V.EX.field6)\n+#define Field37(N)    (Nodes_Ptr[(N) - First_Node_Id + 6].V.EX.field7)\n+#define Field38(N)    (Nodes_Ptr[(N) - First_Node_Id + 6].V.EX.field8)\n+#define Field39(N)    (Nodes_Ptr[(N) - First_Node_Id + 6].V.EX.field9)\n+#define Field41(N)    (Nodes_Ptr[(N) - First_Node_Id + 6].V.EX.field10)\n+#define Field41(N)    (Nodes_Ptr[(N) - First_Node_Id + 6].V.EX.X.field11)\n \n #define Node1(N)      Field1  (N)\n #define Node2(N)      Field2  (N)\n@@ -485,6 +491,11 @@ extern Node_Id Current_Error_Node;\n #define Node34(N)     Field34 (N)\n #define Node35(N)     Field35 (N)\n #define Node36(N)     Field36 (N)\n+#define Node37(N)     Field37 (N)\n+#define Node38(N)     Field38 (N)\n+#define Node39(N)     Field39 (N)\n+#define Node40(N)     Field40 (N)\n+#define Node41(N)     Field41 (N)\n \n #define List1(N)      Field1  (N)\n #define List2(N)      Field2  (N)"}, {"sha": "511ba3a0a33c10ca48c6007b38edb1913ff56c8f", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=57d08392f638bae0e0051a6ea55779b9da124d81", "patch": "@@ -264,6 +264,13 @@ package body Einfo is\n \n    --    Import_Pragma                   Node35\n \n+   --    (unused)                        Node36\n+   --    (unused)                        Node37\n+   --    (unused)                        Node38\n+   --    (unused)                        Node39\n+   --    (unused)                        Node40\n+   --    (unused)                        Node41\n+\n    ---------------------------------------------\n    -- Usage of Flags in Defining Entity Nodes --\n    ---------------------------------------------\n@@ -10063,6 +10070,78 @@ package body Einfo is\n       end case;\n    end Write_Field35_Name;\n \n+   ------------------------\n+   -- Write_Field36_Name --\n+   ------------------------\n+\n+   procedure Write_Field36_Name (Id : Entity_Id) is\n+   begin\n+      case Ekind (Id) is\n+         when others                                       =>\n+            Write_Str (\"Field36??\");\n+      end case;\n+   end Write_Field36_Name;\n+\n+   ------------------------\n+   -- Write_Field37_Name --\n+   ------------------------\n+\n+   procedure Write_Field37_Name (Id : Entity_Id) is\n+   begin\n+      case Ekind (Id) is\n+         when others                                       =>\n+            Write_Str (\"Field37??\");\n+      end case;\n+   end Write_Field37_Name;\n+\n+   ------------------------\n+   -- Write_Field38_Name --\n+   ------------------------\n+\n+   procedure Write_Field38_Name (Id : Entity_Id) is\n+   begin\n+      case Ekind (Id) is\n+         when others                                       =>\n+            Write_Str (\"Field38??\");\n+      end case;\n+   end Write_Field38_Name;\n+\n+   ------------------------\n+   -- Write_Field39_Name --\n+   ------------------------\n+\n+   procedure Write_Field39_Name (Id : Entity_Id) is\n+   begin\n+      case Ekind (Id) is\n+         when others                                       =>\n+            Write_Str (\"Field39??\");\n+      end case;\n+   end Write_Field39_Name;\n+\n+   ------------------------\n+   -- Write_Field40_Name --\n+   ------------------------\n+\n+   procedure Write_Field40_Name (Id : Entity_Id) is\n+   begin\n+      case Ekind (Id) is\n+         when others                                       =>\n+            Write_Str (\"Field40??\");\n+      end case;\n+   end Write_Field40_Name;\n+\n+   ------------------------\n+   -- Write_Field41_Name --\n+   ------------------------\n+\n+   procedure Write_Field41_Name (Id : Entity_Id) is\n+   begin\n+      case Ekind (Id) is\n+         when others                                       =>\n+            Write_Str (\"Field41??\");\n+      end case;\n+   end Write_Field41_Name;\n+\n    -------------------------\n    -- Iterator Procedures --\n    -------------------------"}, {"sha": "178fc7e3a5cf0a186730651d166eca1df7e52449", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=57d08392f638bae0e0051a6ea55779b9da124d81", "patch": "@@ -8001,6 +8001,12 @@ package Einfo is\n    procedure Write_Field33_Name (Id : Entity_Id);\n    procedure Write_Field34_Name (Id : Entity_Id);\n    procedure Write_Field35_Name (Id : Entity_Id);\n+   procedure Write_Field36_Name (Id : Entity_Id);\n+   procedure Write_Field37_Name (Id : Entity_Id);\n+   procedure Write_Field38_Name (Id : Entity_Id);\n+   procedure Write_Field39_Name (Id : Entity_Id);\n+   procedure Write_Field40_Name (Id : Entity_Id);\n+   procedure Write_Field41_Name (Id : Entity_Id);\n    --  These routines are used in Treepr to output a nice symbolic name for\n    --  the given field, depending on the Ekind. No blanks or end of lines are\n    --  output, just the characters of the field name."}, {"sha": "40b09e2816d3a81a7106ba95ac83b6884c3295bd", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 59, "deletions": 18, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=57d08392f638bae0e0051a6ea55779b9da124d81", "patch": "@@ -281,6 +281,8 @@ package body Exp_Unst is\n    ----------------------------\n \n    procedure Note_Uplevel_Reference (N : Node_Id; Subp : Entity_Id) is\n+      Elmt : Elmt_Id;\n+\n    begin\n       --  Nothing to do inside a generic (all processing is for instance)\n \n@@ -300,6 +302,18 @@ package body Exp_Unst is\n          Set_Uplevel_References (Subp, New_Elmt_List);\n       end if;\n \n+      --  Ignore if node is already in the list. This is a bit inefficient,\n+      --  but we can definitely get duplicates that cause trouble!\n+\n+      Elmt := First_Elmt (Uplevel_References (Subp));\n+      while Present (Elmt) loop\n+         if N = Node (Elmt) then\n+            return;\n+         else\n+            Next_Elmt (Elmt);\n+         end if;\n+      end loop;\n+\n       --  Add new entry to Uplevel_References. Each entry is two elements of\n       --  the list. The first is the actual reference, the second is the\n       --  enclosing subprogram at the point of reference\n@@ -322,6 +336,12 @@ package body Exp_Unst is\n    -----------------------\n \n    procedure Unnest_Subprogram (Subp : Entity_Id; Subp_Body : Node_Id) is\n+      function Actual_Ref (N : Node_Id) return Node_Id;\n+      --  This function is applied to an element in the Uplevel_References\n+      --  list, and it finds the actual reference. Often this is just N itself,\n+      --  but in some cases it gets rewritten, e.g. as a Type_Conversion, and\n+      --  this function digs out the actual reference\n+\n       function AREC_String (Lev : Pos) return String;\n       --  Given a level value, 1, 2, ... returns the string AREC, AREC2, ...\n \n@@ -338,18 +358,46 @@ package body Exp_Unst is\n       function Subp_Index (Sub : Entity_Id) return SI_Type;\n       --  Given the entity for a subprogram, return corresponding Subps index\n \n+      ----------------\n+      -- Actual_Ref --\n+      ----------------\n+\n+      function Actual_Ref (N : Node_Id) return Node_Id is\n+      begin\n+         case Nkind (N) is\n+\n+            --  If we have an entity reference, then this is the actual ref\n+\n+            when N_Has_Entity =>\n+               return N;\n+\n+            --  For a type conversion, go get the expression\n+\n+            when N_Type_Conversion =>\n+               return Expression (N);\n+\n+            --  For an explicit dereference, get the prefix\n+\n+            when N_Explicit_Dereference =>\n+               return Prefix (N);\n+\n+            --  No other possibilities should exist\n+\n+            when others =>\n+               raise Program_Error;\n+         end case;\n+      end Actual_Ref;\n+\n       -----------------\n       -- AREC_String --\n       -----------------\n \n       function AREC_String (Lev : Pos) return String is\n       begin\n          if Lev > 9 then\n-            return\n-              AREC_String (Lev / 10) & Character'Val (Lev mod 10 + 48);\n+            return AREC_String (Lev / 10) & Character'Val (Lev mod 10 + 48);\n          else\n-            return\n-              \"AREC\" & Character'Val (Lev + 48);\n+            return \"AREC\" & Character'Val (Lev + 48);\n          end if;\n       end AREC_String;\n \n@@ -789,6 +837,7 @@ package body Exp_Unst is\n                   declare\n                      Loc   : constant Source_Ptr := Sloc (STJ.Bod);\n                      Elmt  : Elmt_Id;\n+                     Nod   : Node_Id;\n                      Ent   : Entity_Id;\n                      Clist : List_Id;\n                      Comp  : Entity_Id;\n@@ -817,7 +866,8 @@ package body Exp_Unst is\n                      if Present (STJ.Urefs) then\n                         Elmt := First_Elmt (STJ.Urefs);\n                         while Present (Elmt) loop\n-                           Ent := Entity (Node (Elmt));\n+                           Nod := Actual_Ref (Node (Elmt));\n+                           Ent := Entity (Nod);\n \n                            if not Uplevel_Reference_Noted (Ent) then\n                               Set_Uplevel_Reference_Noted (Ent, True);\n@@ -1049,19 +1099,11 @@ package body Exp_Unst is\n                   Elmt := First_Elmt (STJ.Urefs);\n                   while Present (Elmt) loop\n \n-                     --  Skip if we have an explicit dereference. This means\n-                     --  that we already did the expansion. There can be\n-                     --  duplicates in ths STJ.Urefs list.\n-\n-                     if Nkind (Node (Elmt)) = N_Explicit_Dereference then\n-                        goto Continue;\n-                     end if;\n-\n-                     --  Otherwise, rewrite this reference\n+                     --  Rewrite one reference\n \n                      declare\n-                        Ref : constant Node_Id := Node (Elmt);\n-                        --  The uplevel reference itself\n+                        Ref : constant Node_Id := Actual_Ref (Node (Elmt));\n+                        --  The reference to be rewritten\n \n                         Loc : constant Source_Ptr := Sloc (Ref);\n                         --  Source location for the reference\n@@ -1103,7 +1145,7 @@ package body Exp_Unst is\n \n                         --    type Tnn is access all typ;\n \n-                        Insert_Action (Ref,\n+                        Insert_Action (Node (Elmt),\n                           Make_Full_Type_Declaration (Loc,\n                             Defining_Identifier => Tnn,\n                             Type_Definition     =>\n@@ -1191,7 +1233,6 @@ package body Exp_Unst is\n                         Pop_Scope;\n                      end;\n \n-                  <<Continue>>\n                      Next_Elmt (Elmt);\n                      Next_Elmt (Elmt);\n                   end loop;"}, {"sha": "5ae0a2113f53514cbfdf8204965e8e044a17e82e", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=57d08392f638bae0e0051a6ea55779b9da124d81", "patch": "@@ -5710,6 +5710,11 @@ package body Exp_Util is\n       elsif Is_Entity_Name (N) and then Is_Type (Entity (N)) then\n          return False;\n \n+      --  Never true for a compile time known constant\n+\n+      elsif Compile_Time_Known_Value (N) then\n+         return False;\n+\n       --  True if object reference with volatile type\n \n       elsif Is_Volatile_Object (N) then"}, {"sha": "bfee6559088db7649fb48e22f532638a35bf4213", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=57d08392f638bae0e0051a6ea55779b9da124d81", "patch": "@@ -3026,18 +3026,23 @@ package body Freeze is\n                R_Type := Full_View (R_Type);\n                Set_Etype (E, R_Type);\n \n-            --  If the return type is a limited view and the non-\n-            --  limited view is still incomplete, the function has\n-            --  to be frozen at a later time.\n+            --  If the return type is a limited view and the non-limited\n+            --  view is still incomplete, the function has to be frozen at a\n+            --  later time. If the function is abstract there is no place at\n+            --  which the full view will become available, and no code to be\n+            --  generated for it, so mark type as frozen.\n \n             elsif Ekind (R_Type) = E_Incomplete_Type\n               and then From_Limited_With (R_Type)\n-              and then\n-                Ekind (Non_Limited_View (R_Type)) = E_Incomplete_Type\n+              and then Ekind (Non_Limited_View (R_Type)) = E_Incomplete_Type\n             then\n-               Set_Is_Frozen (E, False);\n-               Set_Returns_Limited_View (E);\n-               return False;\n+               if Is_Abstract_Subprogram (E) then\n+                  null;\n+               else\n+                  Set_Is_Frozen (E, False);\n+                  Set_Returns_Limited_View (E);\n+                  return False;\n+               end if;\n             end if;\n \n             Freeze_And_Append (R_Type, N, Result);"}, {"sha": "bab0b46abfa407e89db0310c0577f9e87c90b036", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=57d08392f638bae0e0051a6ea55779b9da124d81", "patch": "@@ -408,6 +408,13 @@ begin\n \n          --  Cleanup processing after completing main analysis\n \n+         --  Turn off unnesting of subprograms mode. This is not right\n+         --  with respect to instantiations. What needs to happen is that\n+         --  we do the unnesting AFTER the call to Instantiate_Bodies. We\n+         --  will take care of that later ???\n+\n+         Opt.Unnest_Subprogram_Mode := False;\n+\n          --  Comment needed for ASIS mode test and GNATprove mode test???\n \n          if Operating_Mode = Generate_Code"}, {"sha": "936b056d6da3a4052617081779b5c385157b0146", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 57, "deletions": 55, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=57d08392f638bae0e0051a6ea55779b9da124d81", "patch": "@@ -1335,10 +1335,11 @@ package body Inline is\n      (Spec_Id : Entity_Id;\n       Body_Id : Entity_Id) return Boolean\n    is\n-      function Has_Parameter_With_Discriminant_Dependent_Fields\n+      function Has_Formal_With_Discriminant_Dependent_Fields\n         (Id : Entity_Id) return Boolean;\n-      --  Returns true if the subprogram as parameters of an unconstrained\n-      --  record types with fields whose types depend on a discriminant.\n+      --  Returns true if the subprogram has at least one formal parameters of\n+      --  an unconstrained record type with per-object constraints on component\n+      --  types.\n \n       function Has_Some_Contract (Id : Entity_Id) return Boolean;\n       --  Returns True if subprogram Id has any contract (Pre, Post, Global,\n@@ -1356,72 +1357,73 @@ package body Inline is\n       --  Returns True if subprogram Id was defined originally as an expression\n       --  function.\n \n-      ------------------------------------------------------\n-      -- Has_Parameter_With_Discriminant_Dependent_Fields --\n-      ------------------------------------------------------\n+      ---------------------------------------------------\n+      -- Has_Formal_With_Discriminant_Dependent_Fields --\n+      ---------------------------------------------------\n \n-      function Has_Parameter_With_Discriminant_Dependent_Fields\n-        (Id : Entity_Id) return Boolean\n-      is\n-         E    : Entity_Id := Id;\n-         Spec : Node_Id   := Parent (E);\n+      function Has_Formal_With_Discriminant_Dependent_Fields\n+        (Id : Entity_Id) return Boolean is\n \n-      begin\n-         --  Get the specification of the subprogram. Go through alias if\n-         --  needed.\n+         function Has_Discriminant_Dependent_Component\n+           (Typ : Entity_Id) return Boolean;\n+         --  Determine whether unconstrained record type Typ has at least\n+         --  one component that depends on a discriminant.\n \n-         if Nkind (Spec) = N_Defining_Program_Unit_Name then\n-            Spec := Parent (Spec);\n-         end if;\n+         ------------------------------------------\n+         -- Has_Discriminant_Dependent_Component --\n+         ------------------------------------------\n \n-         while Nkind (Spec) not in N_Subprogram_Specification loop\n-            pragma Assert (Present (Alias (E)));\n-            E := Alias (E);\n-            Spec := Parent (E);\n+         function Has_Discriminant_Dependent_Component\n+           (Typ : Entity_Id) return Boolean\n+         is\n+            Comp : Entity_Id;\n \n-            if Nkind (Spec) = N_Defining_Program_Unit_Name then\n-               Spec := Parent (Spec);\n-            end if;\n-         end loop;\n+         begin\n+            --  Inspect all components of the record type looking for one\n+            --  that depends on a discriminant.\n \n-         declare\n-            Params   : constant List_Id := Parameter_Specifications (Spec);\n-            Param    : Node_Id;\n-            Param_Ty : Entity_Id;\n+            Comp := First_Component (Typ);\n+            while Present (Comp) loop\n+               if Has_Discriminant_Dependent_Constraint (Comp) then\n+                  return True;\n+               end if;\n \n-         begin\n-            if Is_Non_Empty_List (Params) then\n-               Param := First (Params);\n-               while Present (Param) loop\n-                  Param_Ty := Etype (Defining_Identifier (Param));\n+               Next_Component (Comp);\n+            end loop;\n \n-                  --  If the parameter is an unconstrained record, check if\n-                  --  it has components whose types depend on a discriminant.\n+            return False;\n+         end Has_Discriminant_Dependent_Component;\n \n-                  if Is_Record_Type (Param_Ty)\n-                    and then not Is_Constrained (Param_Ty)\n-                  then\n-                     declare\n-                        Comp : Node_Id := First_Component (Param_Ty);\n+         --  Local variables\n \n-                     begin\n-                        while Present (Comp) loop\n-                           if Has_Discriminant_Dependent_Constraint (Comp) then\n-                              return True;\n-                           end if;\n+         Subp_Id    : constant Entity_Id := Ultimate_Alias (Id);\n+         Formal     : Entity_Id;\n+         Formal_Typ : Entity_Id;\n \n-                           Comp := Next_Component (Comp);\n-                        end loop;\n-                     end;\n-                  end if;\n+         --  Start of processing for\n+         --  Has_Formal_With_Discriminant_Dependent_Component\n \n-                  Param := Next (Param);\n-               end loop;\n+      begin\n+         --  Inspect all parameters of the subprogram looking for a formal\n+         --  of an unconstrained record type with at least one discriminant\n+         --  dependent component.\n+\n+         Formal := First_Formal (Subp_Id);\n+         while Present (Formal) loop\n+            Formal_Typ := Etype (Formal);\n+\n+            if Is_Record_Type (Formal_Typ)\n+              and then not Is_Constrained (Formal_Typ)\n+              and then Has_Discriminant_Dependent_Component (Formal_Typ)\n+            then\n+               return True;\n             end if;\n-         end;\n+\n+            Next_Formal (Formal);\n+         end loop;\n \n          return False;\n-      end Has_Parameter_With_Discriminant_Dependent_Fields;\n+      end Has_Formal_With_Discriminant_Dependent_Fields;\n \n       -----------------------\n       -- Has_Some_Contract --\n@@ -1580,7 +1582,7 @@ package body Inline is\n       --  in record component accesses (in particular with records containing\n       --  packed arrays).\n \n-      elsif Has_Parameter_With_Discriminant_Dependent_Fields (Id) then\n+      elsif Has_Formal_With_Discriminant_Dependent_Fields (Id) then\n          return False;\n \n       --  Otherwise, this is a subprogram declared inside the private part of a"}, {"sha": "b362362e70da584238fc5f4ebb9bfd6e8880d557", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=57d08392f638bae0e0051a6ea55779b9da124d81", "patch": "@@ -11204,6 +11204,17 @@ package body Sem_Ch12 is\n               (\"expect protected access type for formal &\",\n                Actual, Gen_T);\n          end if;\n+\n+         --  If the formal has a specified convention (which in most cases\n+         --  will be StdCall) verify that the actual has the same convention.\n+\n+         if Has_Convention_Pragma (A_Gen_T)\n+           and then Convention (A_Gen_T) /= Convention (Act_T)\n+         then\n+            Error_Msg_Name_1 := Get_Convention_Name (Convention (A_Gen_T));\n+            Error_Msg_NE\n+              (\"actual for formal & must have convention %\", Actual, Gen_T);\n+         end if;\n       end Validate_Access_Subprogram_Instance;\n \n       -----------------------------------"}, {"sha": "8a1e132078382fee65e202b0293bd8f2e80984b7", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=57d08392f638bae0e0051a6ea55779b9da124d81", "patch": "@@ -3159,6 +3159,11 @@ package body Sem_Ch3 is\n          if SPARK_Mode = On\n            and then Is_Effectively_Volatile (Obj_Id)\n            and then No (Corresponding_Generic_Association (Parent (Obj_Id)))\n+\n+           --  Don't give this for internally generated entities (such as the\n+           --  FIRST and LAST temporaries generated for bounds.\n+\n+           and then Comes_From_Source (Obj_Id)\n          then\n             Error_Msg_N (\"constant cannot be volatile\", Obj_Id);\n          end if;"}, {"sha": "4fe9007aacbe8473a4512432f907bb2ed72ab01c", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=57d08392f638bae0e0051a6ea55779b9da124d81", "patch": "@@ -6591,7 +6591,17 @@ package body Sem_Prag is\n             Set_Convention_From_Pragma (E);\n \n             if Is_Type (E) then\n-               Check_First_Subtype (Arg2);\n+\n+               --  The pragma must apply to a first subtype, but it can also\n+               --  apply to a generic type in a generic formal part, in which\n+               --  case it will also appear in the corresponding instance.\n+\n+               if Is_Generic_Type (E) or else In_Instance then\n+                  null;\n+               else\n+                  Check_First_Subtype (Arg2);\n+               end if;\n+\n                Set_Convention_From_Pragma (Base_Type (E));\n \n                --  For access subprograms, we must set the convention on the"}, {"sha": "48d9e52b752d7d9af90cbdc1ec49e9ab3e7df533", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57d08392f638bae0e0051a6ea55779b9da124d81/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=57d08392f638bae0e0051a6ea55779b9da124d81", "patch": "@@ -16854,7 +16854,17 @@ package body Sem_Util is\n         and then Is_Access_Subprogram_Type (Base_Type (E))\n         and then Has_Foreign_Convention (E)\n       then\n-         Set_Can_Use_Internal_Rep (E, False);\n+\n+         --  A convention pragma in an instance may apply to the subtype\n+         --  created for a formal, in which case we have already verified\n+         --  that conventions of actual and formal match and there is nothing\n+         --  to flag on the subtype.\n+\n+         if In_Instance then\n+            null;\n+         else\n+            Set_Can_Use_Internal_Rep (E, False);\n+         end if;\n       end if;\n \n       --  If E is an object or component, and the type of E is an anonymous"}]}