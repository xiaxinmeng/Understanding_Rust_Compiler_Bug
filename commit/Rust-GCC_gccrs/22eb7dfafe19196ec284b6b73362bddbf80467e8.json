{"sha": "22eb7dfafe19196ec284b6b73362bddbf80467e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJlYjdkZmFmZTE5MTk2ZWMyODRiNmI3MzM2MmJkZGJmODA0NjdlOA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "2000-03-16T17:13:49Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "2000-03-16T17:13:49Z"}, "message": "Some cselib bug fixes\n\nFrom-SVN: r32589", "tree": {"sha": "cc33e0646cb85e4d0811aaee858a5418364477a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc33e0646cb85e4d0811aaee858a5418364477a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22eb7dfafe19196ec284b6b73362bddbf80467e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22eb7dfafe19196ec284b6b73362bddbf80467e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22eb7dfafe19196ec284b6b73362bddbf80467e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22eb7dfafe19196ec284b6b73362bddbf80467e8/comments", "author": null, "committer": null, "parents": [{"sha": "d9f324226541553d4ac2852d1e467f9238304eba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9f324226541553d4ac2852d1e467f9238304eba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9f324226541553d4ac2852d1e467f9238304eba"}], "stats": {"total": 24, "additions": 18, "deletions": 6}, "files": [{"sha": "1650a80a0f1740c93fd6a5e8b65c79aaa34e83d4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22eb7dfafe19196ec284b6b73362bddbf80467e8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22eb7dfafe19196ec284b6b73362bddbf80467e8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22eb7dfafe19196ec284b6b73362bddbf80467e8", "patch": "@@ -1,3 +1,11 @@\n+2000-03-16  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* simplify-rtx.c (hash_rtx, case MEM/REG): Take into account that\n+\tHASH may already be nonzero.  Add code/mode into hash value\n+\timmediately after repeat label.\n+\t(cselib_lookup): Don't leave the hash table in an inconsistent\n+\tstate before a hash lookup operation.\n+\n Thu Mar 16 17:03:10 MET 2000  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.md (all HI and QI mode non-move patterns):  Conditionize"}, {"sha": "08abf69975758e139ec8f4f36faebe43a446dca9", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22eb7dfafe19196ec284b6b73362bddbf80467e8/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22eb7dfafe19196ec284b6b73362bddbf80467e8/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=22eb7dfafe19196ec284b6b73362bddbf80467e8", "patch": "@@ -2435,22 +2435,24 @@ hash_rtx (x, mode, create)\n {\n   cselib_val *e;\n   int i, j;\n+  enum rtx_code code;\n+  const char *fmt;\n   unsigned int hash = 0;\n-  enum rtx_code code = GET_CODE (x);\n-  const char *fmt = GET_RTX_FORMAT (code);\n \n   /* repeat is used to turn tail-recursion into iteration.  */\n  repeat:\n-\n   code = GET_CODE (x);\n+  hash += (unsigned) code + (unsigned) GET_MODE (x);\n+\n   switch (code)\n     {\n     case MEM:\n     case REG:\n       e = cselib_lookup (x, GET_MODE (x), create);\n       if (! e)\n \treturn 0;\n-      return e->value;\n+      hash += e->value;\n+      return hash;\n \n     case CONST_INT:\n       {\n@@ -2506,7 +2508,6 @@ hash_rtx (x, mode, create)\n     }\n \n   i = GET_RTX_LENGTH (code) - 1;\n-  hash += (unsigned) code + (unsigned) GET_MODE (x);\n   fmt = GET_RTX_FORMAT (code);\n   for (; i >= 0; i--)\n     {\n@@ -2765,8 +2766,11 @@ cselib_lookup (x, mode, create)\n     return e;\n \n   e = new_cselib_val (hashval, mode);\n-  e->locs = new_elt_loc_list (e->locs, cselib_subst_to_values (x));\n+  /* We have to fill the slot before calling cselib_subst_to_values:\n+     the hash table is inconsistent until we do so, and\n+     cselib_subst_to_values will need to do lookups.  */\n   *slot = (void *) e;\n+  e->locs = new_elt_loc_list (e->locs, cselib_subst_to_values (x));\n   return e;\n }\n "}]}