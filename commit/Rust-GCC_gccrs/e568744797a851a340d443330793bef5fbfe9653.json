{"sha": "e568744797a851a340d443330793bef5fbfe9653", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU2ODc0NDc5N2E4NTFhMzQwZDQ0MzMzMDc5M2JlZjVmYmZlOTY1Mw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-09-28T23:03:39Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-09-28T23:03:39Z"}, "message": "(eliminate_regs): All recursive calls now pass INSN instead of NULL_RTX.\n\n(eliminate_regs): All recursive calls now pass INSN\ninstead of NULL_RTX.  Second assignment to ref_outside_mem changed\nto be same as first assignment.\n\nFrom-SVN: r5517", "tree": {"sha": "ec2684474172e63865ad3997250673018ef6682e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec2684474172e63865ad3997250673018ef6682e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e568744797a851a340d443330793bef5fbfe9653", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e568744797a851a340d443330793bef5fbfe9653", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e568744797a851a340d443330793bef5fbfe9653", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e568744797a851a340d443330793bef5fbfe9653/comments", "author": null, "committer": null, "parents": [{"sha": "1347292b885d50b86ca6eb5abe9583eac53911e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1347292b885d50b86ca6eb5abe9583eac53911e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1347292b885d50b86ca6eb5abe9583eac53911e5"}], "stats": {"total": 37, "additions": 20, "deletions": 17}, "files": [{"sha": "c9992a87c642a779bba5ec07786f467120055201", "filename": "gcc/reload1.c", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e568744797a851a340d443330793bef5fbfe9653/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e568744797a851a340d443330793bef5fbfe9653/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=e568744797a851a340d443330793bef5fbfe9653", "patch": "@@ -2676,7 +2676,7 @@ eliminate_regs (x, mem_mode, insn)\n \t     reference to the pseudo.  Ensure we make a copy of the\n \t     address in case it is shared.  */\n \t  new = eliminate_regs (reg_equiv_memory_loc[regno],\n-\t\t\t\tmem_mode, NULL_RTX);\n+\t\t\t\tmem_mode, insn);\n \t  if (new != reg_equiv_memory_loc[regno])\n \t    {\n \t      cannot_omit_stores[regno] = 1;\n@@ -2696,7 +2696,10 @@ eliminate_regs (x, mem_mode, insn)\n \t       ep++)\n \t    if (ep->from_rtx == XEXP (x, 0) && ep->can_eliminate)\n \t      {\n-\t\tif (! mem_mode)\n+\t\tif (! mem_mode\n+\t\t    /* Refs inside notes don't count for this purpose.  */\n+\t\t    && ! (insn != 0 && (GET_CODE (insn) == EXPR_LIST\n+\t\t\t\t\t|| GET_CODE (insn) == INSN_LIST)))\n \t\t  ep->ref_outside_mem = 1;\n \n \t\t/* The only time we want to replace a PLUS with a REG (this\n@@ -2735,8 +2738,8 @@ eliminate_regs (x, mem_mode, insn)\n \t reload.  This is the desired action.  */\n \n       {\n-\trtx new0 = eliminate_regs (XEXP (x, 0), mem_mode, NULL_RTX);\n-\trtx new1 = eliminate_regs (XEXP (x, 1), mem_mode, NULL_RTX);\n+\trtx new0 = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n+\trtx new1 = eliminate_regs (XEXP (x, 1), mem_mode, insn);\n \n \tif (new0 != XEXP (x, 0) || new1 != XEXP (x, 1))\n \t  {\n@@ -2773,7 +2776,7 @@ eliminate_regs (x, mem_mode, insn)\n       /* If we have something in XEXP (x, 0), the usual case, eliminate it.  */\n       if (XEXP (x, 0))\n \t{\n-\t  new = eliminate_regs (XEXP (x, 0), mem_mode, NULL_RTX);\n+\t  new = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n \t  if (new != XEXP (x, 0))\n \t    x = gen_rtx (EXPR_LIST, REG_NOTE_KIND (x), new, XEXP (x, 1));\n \t}\n@@ -2786,7 +2789,7 @@ eliminate_regs (x, mem_mode, insn)\n \t strictly needed, but it simplifies the code.  */\n       if (XEXP (x, 1))\n \t{\n-\t  new = eliminate_regs (XEXP (x, 1), mem_mode, NULL_RTX);\n+\t  new = eliminate_regs (XEXP (x, 1), mem_mode, insn);\n \t  if (new != XEXP (x, 1))\n \t    return gen_rtx (INSN_LIST, GET_MODE (x), XEXP (x, 0), new);\n \t}\n@@ -2805,9 +2808,9 @@ eliminate_regs (x, mem_mode, insn)\n     case GE:       case GT:       case GEU:    case GTU:\n     case LE:       case LT:       case LEU:    case LTU:\n       {\n-\trtx new0 = eliminate_regs (XEXP (x, 0), mem_mode, NULL_RTX);\n+\trtx new0 = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n \trtx new1\n-\t  = XEXP (x, 1) ? eliminate_regs (XEXP (x, 1), mem_mode, NULL_RTX) : 0;\n+\t  = XEXP (x, 1) ? eliminate_regs (XEXP (x, 1), mem_mode, insn) : 0;\n \n \tif (new0 != XEXP (x, 0) || new1 != XEXP (x, 1))\n \t  return gen_rtx (code, GET_MODE (x), new0, new1);\n@@ -2845,7 +2848,7 @@ eliminate_regs (x, mem_mode, insn)\n     case ABS:\n     case SQRT:\n     case FFS:\n-      new = eliminate_regs (XEXP (x, 0), mem_mode, NULL_RTX);\n+      new = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n       if (new != XEXP (x, 0))\n \treturn gen_rtx (code, GET_MODE (x), new);\n       return x;\n@@ -2864,7 +2867,7 @@ eliminate_regs (x, mem_mode, insn)\n \t  && reg_equiv_memory_loc[REGNO (SUBREG_REG (x))] != 0)\n \t{\n \t  new = eliminate_regs (reg_equiv_memory_loc[REGNO (SUBREG_REG (x))],\n-\t\t\t\tmem_mode, NULL_RTX);\n+\t\t\t\tmem_mode, insn);\n \n \t  /* If we didn't change anything, we must retain the pseudo.  */\n \t  if (new == reg_equiv_memory_loc[REGNO (SUBREG_REG (x))])\n@@ -2875,7 +2878,7 @@ eliminate_regs (x, mem_mode, insn)\n \t    new = copy_rtx (new);\n \t}\n       else\n-\tnew = eliminate_regs (SUBREG_REG (x), mem_mode, NULL_RTX);\n+\tnew = eliminate_regs (SUBREG_REG (x), mem_mode, insn);\n \n       if (new != XEXP (x, 0))\n \t{\n@@ -2920,7 +2923,7 @@ eliminate_regs (x, mem_mode, insn)\n \tif (ep->to_rtx == XEXP (x, 0))\n \t  ep->can_eliminate = 0;\n \n-      new = eliminate_regs (XEXP (x, 0), mem_mode, NULL_RTX);\n+      new = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n       if (new != XEXP (x, 0))\n \treturn gen_rtx (code, GET_MODE (x), new);\n       return x;\n@@ -2938,7 +2941,7 @@ eliminate_regs (x, mem_mode, insn)\n \t    temp_vec = (rtx *) alloca (XVECLEN (x, 3) * sizeof (rtx));\n \t    for (i = 0; i < ASM_OPERANDS_INPUT_LENGTH (x); i++)\n \t      temp_vec[i] = eliminate_regs (ASM_OPERANDS_INPUT (x, i),\n-\t\t\t\t\t    mem_mode, NULL_RTX);\n+\t\t\t\t\t    mem_mode, insn);\n \n \t    for (i = 0; i < ASM_OPERANDS_INPUT_LENGTH (x); i++)\n \t      if (temp_vec[i] != ASM_OPERANDS_INPUT (x, i))\n@@ -3009,8 +3012,8 @@ eliminate_regs (x, mem_mode, insn)\n \n       /* Now avoid the loop below in this common case.  */\n       {\n-\trtx new0 = eliminate_regs (SET_DEST (x), 0, NULL_RTX);\n-\trtx new1 = eliminate_regs (SET_SRC (x), 0, NULL_RTX);\n+\trtx new0 = eliminate_regs (SET_DEST (x), 0, insn);\n+\trtx new1 = eliminate_regs (SET_SRC (x), 0, insn);\n \n \t/* If SET_DEST changed from a REG to a MEM and INSN is an insn,\n \t   write a CLOBBER insn.  */\n@@ -3029,7 +3032,7 @@ eliminate_regs (x, mem_mode, insn)\n       /* Our only special processing is to pass the mode of the MEM to our\n \t recursive call and copy the flags.  While we are here, handle this\n \t case more efficiently.  */\n-      new = eliminate_regs (XEXP (x, 0), GET_MODE (x), NULL_RTX);\n+      new = eliminate_regs (XEXP (x, 0), GET_MODE (x), insn);\n       if (new != XEXP (x, 0))\n \t{\n \t  new = gen_rtx (MEM, GET_MODE (x), new);\n@@ -3049,7 +3052,7 @@ eliminate_regs (x, mem_mode, insn)\n     {\n       if (*fmt == 'e')\n \t{\n-\t  new = eliminate_regs (XEXP (x, i), mem_mode, NULL_RTX);\n+\t  new = eliminate_regs (XEXP (x, i), mem_mode, insn);\n \t  if (new != XEXP (x, i) && ! copied)\n \t    {\n \t      rtx new_x = rtx_alloc (code);"}]}