{"sha": "d592920c89973acd8d9f5b1f6b0526036ce63ccb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU5MjkyMGM4OTk3M2FjZDhkOWY1YjFmNmIwNTI2MDM2Y2U2M2NjYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-07-13T09:17:39Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-07-13T09:17:39Z"}, "message": "vect: Add a vect_phi_initial_value helper function\n\nThis patch adds a helper function called vect_phi_initial_value\nfor returning the incoming value of a given loop phi.  The main\nreason for adding it is to ensure that the right preheader edge\nis used when vectorising nested loops.  (PHI_ARG_DEF_FROM_EDGE\nitself doesn't assert that the given edge is for the right block,\nalthough I guess that would be good to add separately.)\n\ngcc/\n\t* tree-vectorizer.h: Include tree-ssa-operands.h.\n\t(vect_phi_initial_value): New function.\n\t* tree-vect-loop.c (neutral_op_for_slp_reduction): Use it.\n\t(get_initial_defs_for_reduction, info_for_reduction): Likewise.\n\t(vect_create_epilog_for_reduction, vectorizable_reduction): Likewise.\n\t(vect_transform_cycle_phi, vectorizable_induction): Likewise.", "tree": {"sha": "992d08b8f6db47ceaf02944b80b06748081898a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/992d08b8f6db47ceaf02944b80b06748081898a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d592920c89973acd8d9f5b1f6b0526036ce63ccb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d592920c89973acd8d9f5b1f6b0526036ce63ccb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d592920c89973acd8d9f5b1f6b0526036ce63ccb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d592920c89973acd8d9f5b1f6b0526036ce63ccb/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32b8edd5297c9193b81122fdd55316fcbf0959dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32b8edd5297c9193b81122fdd55316fcbf0959dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32b8edd5297c9193b81122fdd55316fcbf0959dc"}], "stats": {"total": 50, "additions": 29, "deletions": 21}, "files": [{"sha": "a31d7621c3b82ca489b2e54dea666415613f3c53", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d592920c89973acd8d9f5b1f6b0526036ce63ccb/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d592920c89973acd8d9f5b1f6b0526036ce63ccb/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=d592920c89973acd8d9f5b1f6b0526036ce63ccb", "patch": "@@ -3288,8 +3288,7 @@ neutral_op_for_slp_reduction (slp_tree slp_node, tree vector_type,\n \t has only a single initial value, so that value is neutral for\n \t all statements.  */\n       if (reduc_chain)\n-\treturn PHI_ARG_DEF_FROM_EDGE (stmt_vinfo->stmt,\n-\t\t\t\t      loop_preheader_edge (loop));\n+\treturn vect_phi_initial_value (stmt_vinfo);\n       return NULL_TREE;\n \n     default:\n@@ -4829,13 +4828,13 @@ get_initial_defs_for_reduction (vec_info *vinfo,\n       /* Get the def before the loop.  In reduction chain we have only\n \t one initial value.  Else we have as many as PHIs in the group.  */\n       if (reduc_chain)\n-\top = j != 0 ? neutral_op : PHI_ARG_DEF_FROM_EDGE (stmt_vinfo->stmt, pe);\n+\top = j != 0 ? neutral_op : vect_phi_initial_value (stmt_vinfo);\n       else if (((vec_oprnds->length () + 1) * nunits\n \t\t- number_of_places_left_in_vector >= group_size)\n \t       && neutral_op)\n \top = neutral_op;\n       else\n-\top = PHI_ARG_DEF_FROM_EDGE (stmt_vinfo->stmt, pe);\n+\top = vect_phi_initial_value (stmt_vinfo);\n \n       /* Create 'vect_ = {op0,op1,...,opn}'.  */\n       number_of_places_left_in_vector--;\n@@ -4906,9 +4905,7 @@ info_for_reduction (vec_info *vinfo, stmt_vec_info stmt_info)\n     }\n   else if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_nested_cycle)\n     {\n-      edge pe = loop_preheader_edge (gimple_bb (phi)->loop_father);\n-      stmt_vec_info info\n-\t  = vinfo->lookup_def (PHI_ARG_DEF_FROM_EDGE (phi, pe));\n+      stmt_vec_info info = vinfo->lookup_def (vect_phi_initial_value (phi));\n       if (info && STMT_VINFO_DEF_TYPE (info) == vect_double_reduction_def)\n \tstmt_info = info;\n     }\n@@ -5042,8 +5039,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n     {\n       /* Get at the scalar def before the loop, that defines the initial value\n \t of the reduction variable.  */\n-      initial_def = PHI_ARG_DEF_FROM_EDGE (reduc_def_stmt,\n-\t\t\t\t\t   loop_preheader_edge (loop));\n+      initial_def = vect_phi_initial_value (reduc_def_stmt);\n       /* Optimize: for induction condition reduction, if we can't use zero\n          for induc_val, use initial_def.  */\n       if (STMT_VINFO_REDUC_TYPE (reduc_info) == INTEGER_INDUC_COND_REDUCTION)\n@@ -5558,9 +5554,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \t     for MIN and MAX reduction, for example.  */\n \t  if (!neutral_op)\n \t    {\n-\t      tree scalar_value\n-\t\t= PHI_ARG_DEF_FROM_EDGE (orig_phis[i]->stmt,\n-\t\t\t\t\t loop_preheader_edge (loop));\n+\t      tree scalar_value = vect_phi_initial_value (orig_phis[i]);\n \t      scalar_value = gimple_convert (&seq, TREE_TYPE (vectype),\n \t\t\t\t\t     scalar_value);\n \t      vector_identity = gimple_build_vector_from_val (&seq, vectype,\n@@ -6752,10 +6746,7 @@ vectorizable_reduction (loop_vec_info loop_vinfo,\n       else if (cond_reduc_dt == vect_constant_def)\n \t{\n \t  enum vect_def_type cond_initial_dt;\n-\t  tree cond_initial_val\n-\t    = PHI_ARG_DEF_FROM_EDGE (reduc_def_phi, loop_preheader_edge (loop));\n-\n-\t  gcc_assert (cond_reduc_val != NULL_TREE);\n+\t  tree cond_initial_val = vect_phi_initial_value (reduc_def_phi);\n \t  vect_is_simple_use (cond_initial_val, loop_vinfo, &cond_initial_dt);\n \t  if (cond_initial_dt == vect_constant_def\n \t      && types_compatible_p (TREE_TYPE (cond_initial_val),\n@@ -7528,8 +7519,7 @@ vect_transform_cycle_phi (loop_vec_info loop_vinfo,\n     {\n       /* Get at the scalar def before the loop, that defines the initial\n \t value of the reduction variable.  */\n-      tree initial_def = PHI_ARG_DEF_FROM_EDGE (phi,\n-\t\t\t\t\t\tloop_preheader_edge (loop));\n+      tree initial_def = vect_phi_initial_value (phi);\n       /* Optimize: if initial_def is for REDUC_MAX smaller than the base\n \t and we can't use zero for induc_val, use initial_def.  Similarly\n \t for REDUC_MIN and initial_def larger than the base.  */\n@@ -8175,8 +8165,7 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n       return true;\n     }\n \n-  init_expr = PHI_ARG_DEF_FROM_EDGE (phi,\n-\t\t\t\t     loop_preheader_edge (iv_loop));\n+  init_expr = vect_phi_initial_value (phi);\n \n   gimple_seq stmts = NULL;\n   if (!nested_in_vect_loop)"}, {"sha": "e2fd3609fee8fe4c1684d92673f39a06d9d1aa5a", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d592920c89973acd8d9f5b1f6b0526036ce63ccb/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d592920c89973acd8d9f5b1f6b0526036ce63ccb/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=d592920c89973acd8d9f5b1f6b0526036ce63ccb", "patch": "@@ -27,7 +27,7 @@ typedef class _stmt_vec_info *stmt_vec_info;\n #include \"tree-hash-traits.h\"\n #include \"target.h\"\n #include \"internal-fn.h\"\n-\n+#include \"tree-ssa-operands.h\"\n \n /* Used for naming of new temporaries.  */\n enum vect_var_kind {\n@@ -1369,6 +1369,25 @@ nested_in_vect_loop_p (class loop *loop, stmt_vec_info stmt_info)\n \t  && (loop->inner == (gimple_bb (stmt_info->stmt))->loop_father));\n }\n \n+/* PHI is either a scalar reduction phi or a scalar induction phi.\n+   Return the initial value of the variable on entry to the containing\n+   loop.  */\n+\n+static inline tree\n+vect_phi_initial_value (gphi *phi)\n+{\n+  basic_block bb = gimple_bb (phi);\n+  edge pe = loop_preheader_edge (bb->loop_father);\n+  gcc_assert (pe->dest == bb);\n+  return PHI_ARG_DEF_FROM_EDGE (phi, pe);\n+}\n+\n+static inline tree\n+vect_phi_initial_value (stmt_vec_info stmt_info)\n+{\n+  return vect_phi_initial_value (as_a <gphi *> (stmt_info->stmt));\n+}\n+\n /* Return true if STMT_INFO should produce a vector mask type rather than\n    a normal nonmask type.  */\n "}]}