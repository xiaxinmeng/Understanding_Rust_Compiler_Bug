{"sha": "94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6", "node_id": "C_kwDOANBUbNoAKDk0ZTUzZjhlNTVlOTNkYThkYjNkOTQ4YzNmMTZkMjNiN2M0YmE3YTY", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-03T10:54:54Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-04T14:48:37Z"}, "message": "Refactor indirect_expression from the gcc-backend wrapper\n\nThis brings out the indirect expression out of our gcc wrapper, it also\njust simplifies down to the normal build_indirect_expr_loc calls. Which\ndoes not require specifiying the type since we can reuse TREE_TYPE. This\nalso simplifies the address_expression to just address_expr_with_loc and\ngrabs the type from TREE_TYPE as well.", "tree": {"sha": "6a7063460808979f86fa0e4f799bb3c915615a03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a7063460808979f86fa0e4f799bb3c915615a03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2dc902baa1388841096e16e660082a8e79fce17e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dc902baa1388841096e16e660082a8e79fce17e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dc902baa1388841096e16e660082a8e79fce17e"}], "stats": {"total": 207, "additions": 44, "deletions": 163}, "files": [{"sha": "a640a48d7d85ca0aef43f99e9062066ff13e5260", "filename": "gcc/rust/backend/rust-compile-base.cc", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.cc?ref=94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6", "patch": "@@ -411,16 +411,24 @@ HIRCompileBase::mark_addressable (tree exp, Location locus)\n }\n \n tree\n-HIRCompileBase::address_expression (tree expr, tree ptrtype, Location location)\n+HIRCompileBase::address_expression (tree expr, Location location)\n {\n   if (expr == error_mark_node)\n     return error_mark_node;\n \n   if (!mark_addressable (expr, location))\n     return error_mark_node;\n \n-  return build_fold_addr_expr_with_type_loc (location.gcc_location (), expr,\n-\t\t\t\t\t     ptrtype);\n+  return build_fold_addr_expr_loc (location.gcc_location (), expr);\n+}\n+\n+tree\n+HIRCompileBase::indirect_expression (tree expr, Location locus)\n+{\n+  if (expr == error_mark_node)\n+    return error_mark_node;\n+\n+  return build_fold_indirect_ref_loc (locus.gcc_location (), expr);\n }\n \n std::vector<Bvariable *>"}, {"sha": "aad0da385354ae18a75e4dbd77e7052a2198213a", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6", "patch": "@@ -101,7 +101,9 @@ class HIRCompileBase\n \n   static void setup_abi_options (tree fndecl, ABI abi);\n \n-  static tree address_expression (tree expr, tree ptrtype, Location locus);\n+  static tree address_expression (tree expr, Location locus);\n+\n+  static tree indirect_expression (tree expr, Location locus);\n \n   static bool mark_addressable (tree, Location);\n "}, {"sha": "92c224c68c93adf283afeac3e20159eddcdcf071", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 14, "deletions": 68, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6", "patch": "@@ -134,8 +134,7 @@ CompileExpr::visit (HIR::BorrowExpr &expr)\n \t\t\t\t       &tyty))\n     return;\n \n-  tree ptrtype = TyTyResolveCompile::compile (ctx, tyty);\n-  translated = address_expression (main_expr, ptrtype, expr.get_locus ());\n+  translated = address_expression (main_expr, expr.get_locus ());\n }\n \n void\n@@ -175,10 +174,7 @@ CompileExpr::visit (HIR::DereferenceExpr &expr)\n       return;\n     }\n \n-  bool known_valid = true;\n-  translated\n-    = ctx->get_backend ()->indirect_expression (expected_type, main_expr,\n-\t\t\t\t\t\tknown_valid, expr.get_locus ());\n+  translated = indirect_expression (main_expr, expr.get_locus ());\n }\n \n // Helper for sort_tuple_patterns.\n@@ -1111,15 +1107,7 @@ CompileExpr::get_fn_addr_from_dyn (const TyTy::DynamicObjectType *dyn,\n   // get any indirection sorted out\n   if (receiver->get_kind () == TyTy::TypeKind::REF)\n     {\n-      TyTy::ReferenceType *r = static_cast<TyTy::ReferenceType *> (receiver);\n-      auto indirect_ty = r->get_base ();\n-      tree indrect_compiled_tyty\n-\t= TyTyResolveCompile::compile (ctx, indirect_ty);\n-\n-      tree indirect\n-\t= ctx->get_backend ()->indirect_expression (indrect_compiled_tyty,\n-\t\t\t\t\t\t    receiver_ref, true,\n-\t\t\t\t\t\t    expr_locus);\n+      tree indirect = indirect_expression (receiver_ref, expr_locus);\n       receiver_ref = indirect;\n     }\n \n@@ -1149,17 +1137,8 @@ CompileExpr::get_receiver_from_dyn (const TyTy::DynamicObjectType *dyn,\n {\n   // get any indirection sorted out\n   if (receiver->get_kind () == TyTy::TypeKind::REF)\n-\n     {\n-      TyTy::ReferenceType *r = static_cast<TyTy::ReferenceType *> (receiver);\n-      auto indirect_ty = r->get_base ();\n-      tree indrect_compiled_tyty\n-\t= TyTyResolveCompile::compile (ctx, indirect_ty);\n-\n-      tree indirect\n-\t= ctx->get_backend ()->indirect_expression (indrect_compiled_tyty,\n-\t\t\t\t\t\t    receiver_ref, true,\n-\t\t\t\t\t\t    expr_locus);\n+      tree indirect = indirect_expression (receiver_ref, expr_locus);\n       receiver_ref = indirect;\n     }\n \n@@ -1179,8 +1158,7 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n   tree fn = NULL_TREE;\n   if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n     {\n-      return address_expression (fn, build_pointer_type (TREE_TYPE (fn)),\n-\t\t\t\t expr_locus);\n+      return address_expression (fn, expr_locus);\n     }\n \n   // Now we can try and resolve the address since this might be a forward\n@@ -1440,8 +1418,7 @@ CompileExpr::compile_string_literal (const HIR::LiteralExpr &expr,\n \n   auto base = ctx->get_backend ()->string_constant_expression (\n     literal_value.as_string ());\n-  tree data = address_expression (base, build_pointer_type (TREE_TYPE (base)),\n-\t\t\t\t  expr.get_locus ());\n+  tree data = address_expression (base, expr.get_locus ());\n \n   TyTy::BaseType *usize = nullptr;\n   bool ok = ctx->get_tyctx ()->lookup_builtin (\"usize\", &usize);\n@@ -1487,8 +1464,7 @@ CompileExpr::compile_byte_string_literal (const HIR::LiteralExpr &expr,\n \t\t\t\t\t\t\t vals,\n \t\t\t\t\t\t\t expr.get_locus ());\n \n-  return address_expression (constructed, build_pointer_type (array_type),\n-\t\t\t     expr.get_locus ());\n+  return address_expression (constructed, expr.get_locus ());\n }\n \n tree\n@@ -1734,10 +1710,7 @@ HIRCompileBase::resolve_adjustements (\n \t  case Resolver::Adjustment::AdjustmentType::MUT_REF: {\n \t    if (!SLICE_TYPE_P (TREE_TYPE (e)))\n \t      {\n-\t\ttree ptrtype\n-\t\t  = TyTyResolveCompile::compile (ctx,\n-\t\t\t\t\t\t adjustment.get_expected ());\n-\t\te = address_expression (e, ptrtype, locus);\n+\t\te = address_expression (e, locus);\n \t      }\n \t  }\n \t  break;\n@@ -1785,10 +1758,7 @@ HIRCompileBase::resolve_deref_adjustment (Resolver::Adjustment &adjustment,\n \t\t      != Resolver::Adjustment::AdjustmentType::ERROR;\n   if (needs_borrow)\n     {\n-      adjusted_argument\n-\t= address_expression (expression,\n-\t\t\t      build_reference_type (TREE_TYPE (expression)),\n-\t\t\t      locus);\n+      adjusted_argument = address_expression (expression, locus);\n     }\n \n   // make the call\n@@ -1800,12 +1770,7 @@ tree\n HIRCompileBase::resolve_indirection_adjustment (\n   Resolver::Adjustment &adjustment, tree expression, Location locus)\n {\n-  tree expected_type\n-    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n-\n-  return ctx->get_backend ()->indirect_expression (expected_type, expression,\n-\t\t\t\t\t\t   true, /* known_valid*/\n-\t\t\t\t\t\t   locus);\n+  return indirect_expression (expression, locus);\n }\n \n tree\n@@ -1824,9 +1789,7 @@ HIRCompileBase::resolve_unsized_adjustment (Resolver::Adjustment &adjustment,\n     = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n \n   // make a constructor for this\n-  tree data\n-    = address_expression (expression,\n-\t\t\t  build_reference_type (TREE_TYPE (expression)), locus);\n+  tree data = address_expression (expression, locus);\n \n   // fetch the size from the domain\n   tree domain = TYPE_DOMAIN (expr_type);\n@@ -1919,8 +1882,7 @@ CompileExpr::visit (HIR::IdentifierExpr &expr)\n   else if (ctx->lookup_function_decl (ref, &fn))\n     {\n       TREE_USED (fn) = 1;\n-      translated = address_expression (fn, build_pointer_type (TREE_TYPE (fn)),\n-\t\t\t\t       expr.get_locus ());\n+      translated = address_expression (fn, expr.get_locus ());\n     }\n   else if (ctx->lookup_var_decl (ref, &var))\n     {\n@@ -2091,20 +2053,10 @@ CompileExpr::visit (HIR::ArrayIndexExpr &expr)\n \t  return;\n \t}\n \n-      // lookup the expected type for this expression\n-      TyTy::BaseType *tyty = nullptr;\n-      bool ok\n-\t= ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t  &tyty);\n-      rust_assert (ok);\n-      tree expected_type = TyTyResolveCompile::compile (ctx, tyty);\n-\n       // rust deref always returns a reference from this overload then we can\n       // actually do the indirection\n       translated\n-\t= ctx->get_backend ()->indirect_expression (expected_type,\n-\t\t\t\t\t\t    operator_overload_call,\n-\t\t\t\t\t\t    true, expr.get_locus ());\n+\t= indirect_expression (operator_overload_call, expr.get_locus ());\n       return;\n     }\n \n@@ -2118,14 +2070,8 @@ CompileExpr::visit (HIR::ArrayIndexExpr &expr)\n   // do we need to add an indirect reference\n   if (array_expr_ty->get_kind () == TyTy::TypeKind::REF)\n     {\n-      TyTy::ReferenceType *r\n-\t= static_cast<TyTy::ReferenceType *> (array_expr_ty);\n-      TyTy::BaseType *tuple_type = r->get_base ();\n-      tree array_tyty = TyTyResolveCompile::compile (ctx, tuple_type);\n-\n       array_reference\n-\t= ctx->get_backend ()->indirect_expression (array_tyty, array_reference,\n-\t\t\t\t\t\t    true, expr.get_locus ());\n+\t= indirect_expression (array_reference, expr.get_locus ());\n     }\n \n   translated"}, {"sha": "bc1423991ac559679647a4962afadcbb10e54f70", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6", "patch": "@@ -53,14 +53,7 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n     // do we need to add an indirect reference\n     if (tuple_expr_ty->get_kind () == TyTy::TypeKind::REF)\n       {\n-\tTyTy::ReferenceType *r\n-\t  = static_cast<TyTy::ReferenceType *> (tuple_expr_ty);\n-\tTyTy::BaseType *tuple_type = r->get_base ();\n-\ttree tuple_tyty = TyTyResolveCompile::compile (ctx, tuple_type);\n-\n-\ttree indirect\n-\t  = ctx->get_backend ()->indirect_expression (tuple_tyty, receiver_ref,\n-\t\t\t\t\t\t      true, expr.get_locus ());\n+\ttree indirect = indirect_expression (receiver_ref, expr.get_locus ());\n \treceiver_ref = indirect;\n       }\n \n@@ -552,10 +545,7 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n \t\t\t\t\t &field_index);\n \trust_assert (ok);\n \n-\ttree adt_tyty = TyTyResolveCompile::compile (ctx, adt);\n-\ttree indirect\n-\t  = ctx->get_backend ()->indirect_expression (adt_tyty, receiver_ref,\n-\t\t\t\t\t\t      true, expr.get_locus ());\n+\ttree indirect = indirect_expression (receiver_ref, expr.get_locus ());\n \treceiver_ref = indirect;\n       }\n "}, {"sha": "45a507e03be654e848b3b5639d86b99aa6613982", "filename": "gcc/rust/backend/rust-compile-extern.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-extern.h?ref=94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6", "patch": "@@ -110,10 +110,7 @@ class CompileExternItem : public HIRCompileBase,\n     if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n \t\t\t\t   fntype->get_id (), fntype))\n       {\n-\treference\n-\t  = address_expression (lookup, build_pointer_type (TREE_TYPE (lookup)),\n-\t\t\t\tref_locus);\n-\n+\treference = address_expression (lookup, ref_locus);\n \treturn;\n       }\n \n@@ -155,9 +152,7 @@ class CompileExternItem : public HIRCompileBase,\n \n     ctx->insert_function_decl (fntype, fndecl);\n \n-    reference\n-      = address_expression (fndecl, build_pointer_type (TREE_TYPE (fndecl)),\n-\t\t\t    ref_locus);\n+    reference = address_expression (fndecl, ref_locus);\n   }\n \n private:"}, {"sha": "d0f70a702282dbf03cec1ba312166e5e1521a5d5", "filename": "gcc/rust/backend/rust-compile-implitem.cc", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc?ref=94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6", "patch": "@@ -67,10 +67,8 @@ CompileTraitItem::visit (HIR::TraitItemFunc &func)\n \t    {\n \t      ctx->insert_function_decl (fntype, lookup);\n \t    }\n-\t  reference\n-\t    = address_expression (lookup,\n-\t\t\t\t  build_pointer_type (TREE_TYPE (lookup)),\n-\t\t\t\t  ref_locus);\n+\n+\t  reference = address_expression (lookup, ref_locus);\n \t  return;\n \t}\n     }\n@@ -96,9 +94,7 @@ CompileTraitItem::visit (HIR::TraitItemFunc &func)\n \t\t\tfunc.get_outer_attrs (), func.get_locus (),\n \t\t\tfunc.get_block_expr ().get (), canonical_path, fntype,\n \t\t\tfunction.has_return_type ());\n-  reference\n-    = address_expression (fndecl, build_pointer_type (TREE_TYPE (fndecl)),\n-\t\t\t  ref_locus);\n+  reference = address_expression (fndecl, ref_locus);\n }\n \n } // namespace Compile"}, {"sha": "ceba51c2d27f5bd3a57b3a7acd9b1621cae88354", "filename": "gcc/rust/backend/rust-compile-item.cc", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.cc?ref=94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6", "patch": "@@ -144,10 +144,7 @@ CompileItem::visit (HIR::Function &function)\n \t      ctx->insert_function_decl (fntype, lookup);\n \t    }\n \n-\t  reference\n-\t    = address_expression (lookup,\n-\t\t\t\t  build_pointer_type (TREE_TYPE (lookup)),\n-\t\t\t\t  ref_locus);\n+\t  reference = address_expression (lookup, ref_locus);\n \t  return;\n \t}\n     }\n@@ -171,9 +168,7 @@ CompileItem::visit (HIR::Function &function)\n \t\t\tfunction.get_outer_attrs (), function.get_locus (),\n \t\t\tfunction.get_definition ().get (), canonical_path,\n \t\t\tfntype, function.has_function_return_type ());\n-  reference\n-    = address_expression (fndecl, build_pointer_type (TREE_TYPE (fndecl)),\n-\t\t\t  ref_locus);\n+  reference = address_expression (fndecl, ref_locus);\n }\n \n void"}, {"sha": "8c1b7ef1f2b8d118c5aac49d74e26126698d2d73", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6", "patch": "@@ -129,16 +129,14 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n       if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n \t{\n \t  TREE_USED (fn) = 1;\n-\t  return address_expression (fn, build_pointer_type (TREE_TYPE (fn)),\n-\t\t\t\t     expr_locus);\n+\t  return address_expression (fn, expr_locus);\n \t}\n       else if (fntype->get_abi () == ABI::INTRINSIC)\n \t{\n \t  Intrinsics compile (ctx);\n \t  fn = compile.compile (fntype);\n \t  TREE_USED (fn) = 1;\n-\t  return address_expression (fn, build_pointer_type (TREE_TYPE (fn)),\n-\t\t\t\t     expr_locus);\n+\t  return address_expression (fn, expr_locus);\n \t}\n     }\n "}, {"sha": "4f17fa6286eb2804a72f94e46bdd83b8542bcc0d", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6", "patch": "@@ -225,20 +225,14 @@ HIRCompileBase::coercion_site (tree rvalue, const TyTy::BaseType *rval,\n       const TyTy::ReferenceType *act\n \t= static_cast<const TyTy::ReferenceType *> (actual);\n \n-      tree expected_type = TyTyResolveCompile::compile (ctx, act->get_base ());\n-      tree deref_rvalue\n-\t= ctx->get_backend ()->indirect_expression (expected_type, rvalue,\n-\t\t\t\t\t\t    false /*known_valid*/,\n-\t\t\t\t\t\t    rvalue_locus);\n+      tree deref_rvalue = indirect_expression (rvalue, rvalue_locus);\n       tree coerced\n \t= coercion_site (deref_rvalue, act->get_base (), exp->get_base (),\n \t\t\t lvalue_locus, rvalue_locus);\n       if (exp->is_dyn_object () && SLICE_TYPE_P (TREE_TYPE (coerced)))\n \treturn coerced;\n \n-      return address_expression (coerced,\n-\t\t\t\t build_reference_type (TREE_TYPE (coerced)),\n-\t\t\t\t rvalue_locus);\n+      return address_expression (coerced, rvalue_locus);\n     }\n   else if (expected->get_kind () == TyTy::TypeKind::POINTER)\n     {\n@@ -258,37 +252,29 @@ HIRCompileBase::coercion_site (tree rvalue, const TyTy::BaseType *rval,\n \t= static_cast<const TyTy::ReferenceType *> (expected);\n \n       TyTy::BaseType *actual_base = nullptr;\n-      tree expected_type = error_mark_node;\n       if (actual->get_kind () == TyTy::TypeKind::REF)\n \t{\n \t  const TyTy::ReferenceType *act\n \t    = static_cast<const TyTy::ReferenceType *> (actual);\n \n \t  actual_base = act->get_base ();\n-\t  expected_type = TyTyResolveCompile::compile (ctx, act->get_base ());\n \t}\n       else if (actual->get_kind () == TyTy::TypeKind::POINTER)\n \t{\n \t  const TyTy::PointerType *act\n \t    = static_cast<const TyTy::PointerType *> (actual);\n \n \t  actual_base = act->get_base ();\n-\t  expected_type = TyTyResolveCompile::compile (ctx, act->get_base ());\n \t}\n       rust_assert (actual_base != nullptr);\n \n-      tree deref_rvalue\n-\t= ctx->get_backend ()->indirect_expression (expected_type, rvalue,\n-\t\t\t\t\t\t    false /*known_valid*/,\n-\t\t\t\t\t\t    rvalue_locus);\n+      tree deref_rvalue = indirect_expression (rvalue, rvalue_locus);\n       tree coerced = coercion_site (deref_rvalue, actual_base, exp->get_base (),\n \t\t\t\t    lvalue_locus, rvalue_locus);\n       if (exp->is_dyn_object () && SLICE_TYPE_P (TREE_TYPE (coerced)))\n \treturn coerced;\n \n-      return address_expression (coerced,\n-\t\t\t\t build_pointer_type (TREE_TYPE (coerced)),\n-\t\t\t\t rvalue_locus);\n+      return address_expression (coerced, rvalue_locus);\n     }\n   else if (expected->get_kind () == TyTy::TypeKind::ARRAY)\n     {\n@@ -350,10 +336,7 @@ HIRCompileBase::coerce_to_dyn_object (tree compiled_ref,\n \n   tree address_of_compiled_ref = null_pointer_node;\n   if (!actual->is_unit ())\n-    address_of_compiled_ref\n-      = address_expression (compiled_ref,\n-\t\t\t    build_pointer_type (TREE_TYPE (compiled_ref)),\n-\t\t\t    locus);\n+    address_of_compiled_ref = address_expression (compiled_ref, locus);\n \n   std::vector<tree> vtable_ctor_elems;\n   std::vector<unsigned long> vtable_ctor_idx;"}, {"sha": "f7c0b0833708cf9b9f6e2cb27cb4f8aba9072f63", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6", "patch": "@@ -178,14 +178,6 @@ class Backend\n   // Create a reference to a variable.\n   virtual tree var_expression (Bvariable *var, Location) = 0;\n \n-  // Create an expression that indirects through the pointer expression EXPR\n-  // (i.e., return the expression for *EXPR). KNOWN_VALID is true if the pointer\n-  // is known to point to a valid memory location.  BTYPE is the expected type\n-  // of the indirected EXPR.\n-  virtual tree indirect_expression (tree btype, tree expr, bool known_valid,\n-\t\t\t\t    Location)\n-    = 0;\n-\n   // Return an expression for the multi-precision integer VAL in BTYPE.\n   virtual tree integer_constant_expression (tree btype, mpz_t val) = 0;\n "}, {"sha": "27196e88593f281b984e4964b17c28f2490cb15b", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=94e53f8e55e93da8db3d948c3f16d23b7c4ba7a6", "patch": "@@ -201,8 +201,6 @@ class Gcc_backend : public Backend\n \n   tree var_expression (Bvariable *var, Location);\n \n-  tree indirect_expression (tree, tree expr, bool known_valid, Location);\n-\n   tree integer_constant_expression (tree type, mpz_t val);\n \n   tree float_constant_expression (tree type, mpfr_t val);\n@@ -1053,28 +1051,6 @@ Gcc_backend::var_expression (Bvariable *var, Location location)\n   return var->get_tree (location);\n }\n \n-// An expression that indirectly references an expression.\n-\n-tree\n-Gcc_backend::indirect_expression (tree type_tree, tree expr_tree,\n-\t\t\t\t  bool known_valid, Location location)\n-{\n-  if (expr_tree == error_mark_node || type_tree == error_mark_node)\n-    return error_mark_node;\n-\n-  // If the type of EXPR is a recursive pointer type, then we\n-  // need to insert a cast before indirecting.\n-  tree target_type_tree = TREE_TYPE (TREE_TYPE (expr_tree));\n-  if (VOID_TYPE_P (target_type_tree))\n-    expr_tree = fold_convert_loc (location.gcc_location (),\n-\t\t\t\t  build_pointer_type (type_tree), expr_tree);\n-\n-  tree ret = build_fold_indirect_ref_loc (location.gcc_location (), expr_tree);\n-  if (known_valid)\n-    TREE_THIS_NOTRAP (ret) = 1;\n-  return ret;\n-}\n-\n // Return a typed value as a constant integer.\n \n tree"}]}