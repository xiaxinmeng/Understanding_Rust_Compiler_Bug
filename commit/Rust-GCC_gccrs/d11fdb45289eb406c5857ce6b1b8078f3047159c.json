{"sha": "d11fdb45289eb406c5857ce6b1b8078f3047159c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDExZmRiNDUyODllYjQwNmM1ODU3Y2U2YjFiODA3OGYzMDQ3MTU5Yw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-08-06T01:07:18Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-08-06T01:07:18Z"}, "message": "(output_init_element): Call digest_init before calling output_constant.\n\n(output_init_element): Call digest_init before\ncalling output_constant.  Always pass 0, 0 for last 2 args\nto digest_init.\n\n(build_binary_op): Warn about ordered comparison\nbetween pointers to complete and incomplete types.\n\n(digest_init): No error for a STRING_CST that already\nwent through digest_init.\n(parser_build_binary_op): Generate a NON_LVALUE_EXPR, not NOP_EXPR,\naround a constant value.\n\nFrom-SVN: r5081", "tree": {"sha": "aa820ed2ae4778a1163bb384d51e1f9f5472d515", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa820ed2ae4778a1163bb384d51e1f9f5472d515"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d11fdb45289eb406c5857ce6b1b8078f3047159c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d11fdb45289eb406c5857ce6b1b8078f3047159c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d11fdb45289eb406c5857ce6b1b8078f3047159c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d11fdb45289eb406c5857ce6b1b8078f3047159c/comments", "author": null, "committer": null, "parents": [{"sha": "5f11ca4c7eb5d7b352b0f3a557d14b6933154ca1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f11ca4c7eb5d7b352b0f3a557d14b6933154ca1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f11ca4c7eb5d7b352b0f3a557d14b6933154ca1"}], "stats": {"total": 54, "additions": 34, "deletions": 20}, "files": [{"sha": "a08b72317e8abab7f812b93c215e396ef712fcf6", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 34, "deletions": 20, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d11fdb45289eb406c5857ce6b1b8078f3047159c/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d11fdb45289eb406c5857ce6b1b8078f3047159c/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=d11fdb45289eb406c5857ce6b1b8078f3047159c", "patch": "@@ -974,6 +974,21 @@ default_conversion (exp)\n       register tree adr;\n       tree restype = TREE_TYPE (type);\n       tree ptrtype;\n+      int constp = 0;\n+      int volatilep = 0;\n+\n+      if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'r'\n+\t  || TREE_CODE_CLASS (TREE_CODE (exp)) == 'd')\n+\t{\n+\t  constp = TREE_READONLY (exp);\n+\t  volatilep = TREE_THIS_VOLATILE (exp);\n+\t}\n+\n+      if (TYPE_READONLY (type) || TYPE_VOLATILE (type)\n+\t  || constp || volatilep)\n+\trestype = c_build_type_variant (restype,\n+\t\t\t\t\tTYPE_READONLY (type) || constp,\n+\t\t\t\t\tTYPE_VOLATILE (type) || volatilep);\n \n       if (TREE_CODE (exp) == INDIRECT_REF)\n \treturn convert (TYPE_POINTER_TO (restype),\n@@ -993,10 +1008,6 @@ default_conversion (exp)\n \t  return error_mark_node;\n \t}\n \n-      if (TYPE_READONLY (type) || TYPE_VOLATILE (type))\n-\trestype = c_build_type_variant (restype, TYPE_READONLY (type),\n-\t\t\t\t\tTYPE_VOLATILE (type));\n-\n       ptrtype = build_pointer_type (restype);\n \n       if (TREE_CODE (exp) == VAR_DECL)\n@@ -2230,10 +2241,11 @@ parser_build_binary_op (code, arg1, arg2)\n   else\n     {\n       int flag = TREE_CONSTANT (result);\n-      /* We use NOP_EXPR rather than NON_LVALUE_EXPR\n-\t so that convert_for_assignment won't strip it.\n-\t That way, we get warnings for things like p = (1 - 1).  */\n-      result = build1 (NOP_EXPR, TREE_TYPE (result), result);\n+      /* We used to use NOP_EXPR rather than NON_LVALUE_EXPR\n+\t so that convert_for_assignment wouldn't strip it.\n+\t That way, we got warnings for things like p = (1 - 1).\n+\t But it turns out we should not get those warnings.  */\n+      result = build1 (NON_LVALUE_EXPR, TREE_TYPE (result), result);\n       C_SET_EXP_ORIGINAL_CODE (result, code);\n       TREE_CONSTANT (result) = flag;\n     }\n@@ -2546,7 +2558,8 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t  register tree tt0 = TREE_TYPE (type0);\n \t  register tree tt1 = TREE_TYPE (type1);\n \t  /* Anything compares with void *.  void * compares with anything.\n-\t     Otherwise, the targets must be the same.  */\n+\t     Otherwise, the targets must be compatible\n+\t     and both must be object or both incomplete.  */\n \t  if (comp_target_types (type0, type1))\n \t    ;\n \t  else if (TYPE_MAIN_VARIANT (tt0) == void_type_node)\n@@ -2619,6 +2632,9 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t{\n \t  if (! comp_target_types (type0, type1))\n \t    pedwarn (\"comparison of distinct pointer types lacks a cast\");\n+\t  else if ((TYPE_SIZE (TREE_TYPE (type0)) != 0)\n+\t\t   != (TYPE_SIZE (TREE_TYPE (type1)) != 0))\n+\t    pedwarn (\"comparison of complete and incomplete pointers\");\n \t  else if (pedantic \n \t\t   && TREE_CODE (TREE_TYPE (type0)) == FUNCTION_TYPE)\n \t    pedwarn (\"ANSI C forbids ordered comparisons of pointers to functions\");\n@@ -4855,6 +4871,9 @@ digest_init (type, init, require_constant, constructor_constant)\n \t{\n \t  tree string = element ? element : inside_init;\n \n+\t  if (TREE_TYPE (string) == type)\n+\t    return string;\n+\n \t  if ((TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (string)))\n \t       != char_type_node)\n \t      && TYPE_PRECISION (typ1) == TYPE_PRECISION (char_type_node))\n@@ -5496,7 +5515,7 @@ pop_init_level (implicit)\n \t just pass out the element between them.  */\n       constructor = p->replacement_value;\n       /* If this is the top level thing within the initializer,\n-\t and it's for a variable, then since we already calle\n+\t and it's for a variable, then since we already called\n \t assemble_variable, we must output the value now.  */\n       if (p->next == 0 && constructor_decl != 0\n \t  && constructor_incremental)\n@@ -5770,9 +5789,7 @@ output_init_element (value, type, field, pending)\n       if (! duplicate)\n \tconstructor_pending_elts\n \t  = tree_cons (field,\n-\t\t       digest_init (type, value,\n-\t\t\t\t    require_constant_value,\n-\t\t\t\t    require_constant_elements),\n+\t\t       digest_init (type, value, 0, 0),\n \t\t       constructor_pending_elts);\n     }\n   else if ((TREE_CODE (constructor_type) == RECORD_TYPE\n@@ -5782,9 +5799,7 @@ output_init_element (value, type, field, pending)\n       if (!duplicate)\n \tconstructor_pending_elts\n \t  = tree_cons (field,\n-\t\t       digest_init (type, value,\n-\t\t\t\t    require_constant_value,\n-\t\t\t\t    require_constant_elements),\n+\t\t       digest_init (type, value, 0, 0),\n \t\t       constructor_pending_elts);\n     }\n   else\n@@ -5798,9 +5813,7 @@ output_init_element (value, type, field, pending)\n \t    constructor_elements\n \t      = tree_cons ((TREE_CODE (constructor_type) != ARRAY_TYPE\n \t\t\t    ? field : NULL),\n-\t\t\t   digest_init (type, value,\n-\t\t\t\t\trequire_constant_value,\n-\t\t\t\t\trequire_constant_elements),\n+\t\t\t   digest_init (type, value, 0, 0),\n \t\t\t   constructor_elements);\n \t  else\n \t    {\n@@ -5820,7 +5833,8 @@ output_init_element (value, type, field, pending)\n \t\t      assemble_zeros (next - here);\n \t\t    }\n \t\t}\n-\t      output_constant (value, int_size_in_bytes (type));\n+\t      output_constant (digest_init (type, value, 0, 0),\n+\t\t\t       int_size_in_bytes (type));\n \n \t      /* For a record, keep track of end position of last field.  */\n \t      if (TREE_CODE (constructor_type) == RECORD_TYPE)"}]}