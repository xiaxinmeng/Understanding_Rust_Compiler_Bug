{"sha": "5d93da1d112c93b38b6c68e3c51e20daefc01423", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ5M2RhMWQxMTJjOTNiMzhiNmM2OGUzYzUxZTIwZGFlZmMwMTQyMw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-01-26T21:14:18Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-01-26T21:14:18Z"}, "message": "PR middle-end/78703 -fprintf-return-value floating point handling incorrect in locales with a mulltibyte decimal point\n\ngcc/ChangeLog:\n\tPR middle-end/78703\n\t* gimple-ssa-sprintf.c (struct result_range): Add likely and\n\tunlikely counters.\n\t(struct format_result): Replace number_chars, number_chars_min,\n\tand number_chars_max with a single member of struct result_range.\n\tRemove bounded.\n\t(format_result::operator+=): Adjust.\n\t(struct fmtresult): Remove bounded.  Handle likely and unlikely\n\tcounters.\n\t(fmtresult::adjust_for_width_or_precision): New function.\n\t(fmtresult:type_max_digits): New function.\n\t(bytes_remaining): Handle likely and unlikely counters.\n\t(min_bytes_remaining): Remove.\n\t(format_percent): Simplify.\n\t(format_integer, format_floating): Set likely and unlikely counters.\n\t(get_string_length, format_character, format_string): Same.\n\t(format_plain, should_warn_p): New function.\n\t(maybe_warn): Call should_warn_p.  Update diagnostic messages\n\tand handle those for all directives, including plain strings.\n\t(format_directive): Handle likely and unlikely counters.\n\tRemove unnecessary quoting from diagnostics.  Add an informational\n\tnote.\n\t(add_bytes): Remove.\n\t(pass_sprintf_length::compute_format_length): Simplify.\n\t(try_substitute_return_value): Handle likely and unlikely counters.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/78703\n\t* gcc.dg/format/pr78569.c: Adjust.\n\t* gcc.dg/tree-ssa/builtin-snprintf-warn-2.c: Same.\n\t* gcc.dg/tree-ssa/builtin-sprintf-2.c: Same.\n\t* gcc.dg/tree-ssa/builtin-sprintf-5.c: Same.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-1.c: Same.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-2.c: Same.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-3.c: Same.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-4.c: Same.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-6.c: Same.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-7.c: Same.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-9.c: Same.\n\t* gcc.dg/tree-ssa/builtin-sprintf.c: Same.\n\nFrom-SVN: r244953", "tree": {"sha": "8ffb711a698c635dac9a4bda3e672fa8a950f45e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ffb711a698c635dac9a4bda3e672fa8a950f45e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d93da1d112c93b38b6c68e3c51e20daefc01423", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d93da1d112c93b38b6c68e3c51e20daefc01423", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d93da1d112c93b38b6c68e3c51e20daefc01423", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d93da1d112c93b38b6c68e3c51e20daefc01423/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c86996727f9c4ea4e2aed092d631a2cf99110c5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c86996727f9c4ea4e2aed092d631a2cf99110c5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c86996727f9c4ea4e2aed092d631a2cf99110c5d"}], "stats": {"total": 2736, "additions": 1516, "deletions": 1220}, "files": [{"sha": "311e064c3ea54a48b432abfea95c2e0a1b56df05", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d93da1d112c93b38b6c68e3c51e20daefc01423", "patch": "@@ -1,3 +1,31 @@\n+2017-01-26  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/78703\n+\t* gimple-ssa-sprintf.c (struct result_range): Add likely and\n+\tunlikely counters.\n+\t(struct format_result): Replace number_chars, number_chars_min,\n+\tand number_chars_max with a single member of struct result_range.\n+\tRemove bounded.\n+\t(format_result::operator+=): Adjust.\n+\t(struct fmtresult): Remove bounded.  Handle likely and unlikely\n+\tcounters.\n+\t(fmtresult::adjust_for_width_or_precision): New function.\n+\t(fmtresult:type_max_digits): New function.\n+\t(bytes_remaining): Handle likely and unlikely counters.\n+\t(min_bytes_remaining): Remove.\n+\t(format_percent): Simplify.\n+\t(format_integer, format_floating): Set likely and unlikely counters.\n+\t(get_string_length, format_character, format_string): Same.\n+\t(format_plain, should_warn_p): New function.\n+\t(maybe_warn): Call should_warn_p.  Update diagnostic messages\n+\tand handle those for all directives, including plain strings.\n+\t(format_directive): Handle likely and unlikely counters.\n+\tRemove unnecessary quoting from diagnostics.  Add an informational\n+\tnote.\n+\t(add_bytes): Remove.\n+\t(pass_sprintf_length::compute_format_length): Simplify.\n+\t(try_substitute_return_value): Handle likely and unlikely counters.\n+\n 2017-01-26  Carl Love  <cel@us.ibm.com>\n \n \t* config/rs6000/rs6000-c (altivec_overloaded_builtins): Remove"}, {"sha": "db1c72223aaaf4cb0ce9b7a29831a3df1e09d324", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 945, "deletions": 759, "changes": 1704, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=5d93da1d112c93b38b6c68e3c51e20daefc01423", "patch": "@@ -153,44 +153,53 @@ pass_sprintf_length::gate (function *)\n \t  && (optimize > 0) == fold_return_value);\n }\n \n+/* The minimum, maximum, likely, and unlikely maximum number of bytes\n+   of output either a formatting function or an individual directive\n+   can result in.  */\n+\n+struct result_range\n+{\n+  /* The absolute minimum number of bytes.  The result of a successful\n+     conversion is guaranteed to be no less than this.  (An erroneous\n+     conversion can be indicated by MIN > HOST_WIDE_INT_MAX.)  */\n+  unsigned HOST_WIDE_INT min;\n+  /* The likely maximum result that is used in diagnostics.  In most\n+     cases MAX is the same as the worst case UNLIKELY result.  */\n+  unsigned HOST_WIDE_INT max;\n+  /* The likely result used to trigger diagnostics.  For conversions\n+     that result in a range of bytes [MIN, MAX], LIKELY is somewhere\n+     in that range.  */\n+  unsigned HOST_WIDE_INT likely;\n+  /* In rare cases (e.g., for nultibyte characters) UNLIKELY gives\n+     the worst cases maximum result of a directive.  In most cases\n+     UNLIKELY == MAX.  UNLIKELY is used to control the return value\n+     optimization but not in diagnostics.  */\n+  unsigned HOST_WIDE_INT unlikely;\n+};\n+\n /* The result of a call to a formatted function.  */\n \n struct format_result\n {\n-  /* Number of characters written by the formatted function, exact,\n-     minimum and maximum when an exact number cannot be determined.\n-     Setting the minimum to HOST_WIDE_INT_MAX disables all length\n-     tracking for the remainder of the format string.\n-     Setting either of the other two members to HOST_WIDE_INT_MAX\n-     disables the exact or maximum length tracking, respectively,\n-     but continues to track the maximum.  */\n-  unsigned HOST_WIDE_INT number_chars;\n-  unsigned HOST_WIDE_INT number_chars_min;\n-  unsigned HOST_WIDE_INT number_chars_max;\n-\n-  /* True when the range given by NUMBER_CHARS_MIN and NUMBER_CHARS_MAX\n-     can be relied on for value range propagation, false otherwise.\n-     This means that BOUNDED must not be set if the number of bytes\n-     produced by any directive is unspecified or implementation-\n-     defined (unless the implementation's behavior is known and\n-     determined via a target hook).\n-     Note that BOUNDED only implies that the length of a function's\n-     output is known to be within some range, not that it's constant\n-     and a candidate for string folding.  BOUNDED is a stronger\n-     guarantee than KNOWNRANGE.  */\n-  bool bounded;\n+  /* Range of characters written by the formatted function.\n+     Setting the minimum to HOST_WIDE_INT_MAX disables all\n+     length tracking for the remainder of the format string.  */\n+  result_range range;\n \n   /* True when the range above is obtained from known values of\n-     directive arguments or their bounds and not the result of\n-     heuristics that depend on warning levels.  It is used to\n-     issue stricter diagnostics in cases where strings of unknown\n-     lengths are bounded by the arrays they are determined to\n-     refer to.  KNOWNRANGE must not be used to set the range of\n-     the return value of a call.  */\n+     directive arguments, or bounds on the amount of output such\n+     as width and precision, and not the result of  heuristics that\n+     depend on warning levels.  It's used to issue stricter diagnostics\n+     in cases where strings of unknown lengths are bounded by the arrays\n+     they are determined to refer to.  KNOWNRANGE must not be used for\n+     the return value optimization.  */\n   bool knownrange;\n \n   /* True if no individual directive resulted in more than 4095 bytes\n-     of output (the total NUMBER_CHARS might be greater).  */\n+     of output (the total NUMBER_CHARS_{MIN,MAX} might be greater).\n+     Implementations are not required to handle directives that produce\n+     more than 4K bytes (leading to undefined behavior) and so when one\n+     is found it disables the return value optimization.  */\n   bool under4k;\n \n   /* True when a floating point directive has been seen in the format\n@@ -199,7 +208,7 @@ struct format_result\n \n   /* True when an intermediate result has caused a warning.  Used to\n      avoid issuing duplicate warnings while finishing the processing\n-     of a call.  */\n+     of a call.  WARNED also disables the return value optimization.  */\n   bool warned;\n \n   /* Preincrement the number of output characters by 1.  */\n@@ -225,14 +234,17 @@ format_result::operator+= (unsigned HOST_WIDE_INT n)\n {\n   gcc_assert (n < HOST_WIDE_INT_MAX);\n \n-  if (number_chars < HOST_WIDE_INT_MAX)\n-    number_chars += n;\n+  if (range.min < HOST_WIDE_INT_MAX)\n+    range.min += n;\n+\n+  if (range.max < HOST_WIDE_INT_MAX)\n+    range.max += n;\n \n-  if (number_chars_min < HOST_WIDE_INT_MAX)\n-    number_chars_min += n;\n+  if (range.likely < HOST_WIDE_INT_MAX)\n+    range.likely += n;\n \n-  if (number_chars_max < HOST_WIDE_INT_MAX)\n-    number_chars_max += n;\n+  if (range.unlikely < HOST_WIDE_INT_MAX)\n+    range.unlikely += n;\n \n   return *this;\n }\n@@ -434,13 +446,6 @@ enum format_lengths\n };\n \n \n-/* A minimum and maximum number of bytes.  */\n-\n-struct result_range\n-{\n-  unsigned HOST_WIDE_INT min, max;\n-};\n-\n /* Description of the result of conversion either of a single directive\n    or the whole format string.  */\n \n@@ -451,25 +456,38 @@ struct fmtresult\n   fmtresult (unsigned HOST_WIDE_INT min = HOST_WIDE_INT_MAX)\n   : argmin (), argmax (),\n     knownrange (min < HOST_WIDE_INT_MAX),\n-    bounded (),\n     nullp ()\n   {\n     range.min = min;\n     range.max = min;\n+    range.likely = min;\n+    range.unlikely = min;\n   }\n \n-  /* Construct a FMTRESULT object with all counters initialized\n-     to MIN.  KNOWNRANGE is set when MIN is valid.  */\n-  fmtresult (unsigned HOST_WIDE_INT min, unsigned HOST_WIDE_INT max)\n+  /* Construct a FMTRESULT object with MIN, MAX, and LIKELY counters.\n+     KNOWNRANGE is set when both MIN and MAX are valid.   */\n+  fmtresult (unsigned HOST_WIDE_INT min, unsigned HOST_WIDE_INT max,\n+\t     unsigned HOST_WIDE_INT likely = HOST_WIDE_INT_MAX)\n   : argmin (), argmax (),\n     knownrange (min < HOST_WIDE_INT_MAX && max < HOST_WIDE_INT_MAX),\n-    bounded (),\n     nullp ()\n   {\n     range.min = min;\n     range.max = max;\n+    range.likely = max < likely ? min : likely;\n+    range.unlikely = max;\n   }\n \n+  /* Adjust result upward to reflect the value the specified width\n+     or precision is known to have.  */\n+  fmtresult& adjust_for_width_or_precision (HOST_WIDE_INT,\n+\t\t\t\t\t    tree = NULL_TREE,\n+\t\t\t\t\t    unsigned = 0, unsigned = 0);\n+\n+  /* Return the maximum number of decimal digits a value of TYPE\n+     formats as on output.  */\n+  static unsigned type_max_digits (tree type, int base);\n+\n   /* The range a directive's argument is in.  */\n   tree argmin, argmax;\n \n@@ -482,17 +500,116 @@ struct fmtresult\n      heuristics that depend on warning levels.  */\n   bool knownrange;\n \n-  /* True when the range is the result of an argument determined\n-     to be bounded to a subrange of its type or value (such as by\n-     value range propagation or the width of the formt directive),\n-     false otherwise.  */\n-  bool bounded;\n-\n   /* True when the argument is a null pointer.  */\n   bool nullp;\n };\n \n-/* Description of a conversion specification.  */\n+/* Adjust result upward to reflect the value SCALAR_ADJUST the specified\n+   width or precision is known to have.  When non-null, TYPE denotes the\n+   type of the directive whose result is being adjusted, BASE gives the\n+   base of the directive (octal, decimal, or hex), and ADJ denotes\n+   the additional adjustment to the LIKELY counter that may need to be\n+   added when SCALAR_ADJUST represents a range.  */\n+\n+fmtresult&\n+fmtresult::adjust_for_width_or_precision (HOST_WIDE_INT scalar_adjust,\n+\t\t\t\t\t  tree type /* = NULL_TREE */,\n+\t\t\t\t\t  unsigned base /* = 0 */,\n+\t\t\t\t\t  unsigned adj /* = 0 */)\n+{\n+  bool minadjusted = false;\n+\n+  /* Translate SCALAR_ADJUST to a \"fake\" range until width and precision\n+     ranges are handled.  */\n+  HOST_WIDE_INT adjust[2];\n+  if (scalar_adjust == HOST_WIDE_INT_MIN)\n+    {\n+      adjust[0] = -1;\n+      adjust[1] = target_int_max () + 1;\n+    }\n+  else\n+    adjust[0] = adjust[1] = scalar_adjust;\n+\n+  /* Adjust the minimum and likely counters.  */\n+  if (0 <= adjust[0])\n+    {\n+      if (range.min < (unsigned HOST_WIDE_INT)adjust[0])\n+\t{\n+\t  range.min = adjust[0];\n+\t  minadjusted = true;\n+\t}\n+\n+      /* Adjust the likely counter.  */\n+      if (range.likely < range.min)\n+\trange.likely = range.min;\n+    }\n+  else if (adjust[0] == target_int_min ()\n+\t   && (unsigned HOST_WIDE_INT)adjust[1] == target_int_max ())\n+    knownrange = false;\n+\n+  /* Adjust the maximum counter.  */\n+  if (0 < adjust[1])\n+    {\n+      if (range.max < (unsigned HOST_WIDE_INT)adjust[1])\n+\t{\n+\t  range.max = adjust[1];\n+\n+\t  /* Set KNOWNRANGE if both the minimum and maximum have been\n+\t     adjusted.  Otherwise leave it at what it was before.  */\n+\t  knownrange = minadjusted;\n+\t}\n+    }\n+\n+  if (warn_level > 1 && type)\n+    {\n+      /* For large non-constant width or precision whose range spans\n+\t the maximum number of digits produced by the directive for\n+\t any argument, set the likely number of bytes to be at most\n+\t the number digits plus other adjustment determined by the\n+\t caller (one for sign or two for the hexadecimal \"0x\"\n+\t prefix).  */\n+      unsigned dirdigs = type_max_digits (type, base);\n+      if (adjust[0] < dirdigs && dirdigs < adjust[1]\n+\t  && range.likely < dirdigs)\n+\trange.likely = dirdigs + adj;\n+    }\n+  else if (range.likely < (range.min ? range.min : 1))\n+    {\n+      /* Conservatively, set LIKELY to at least MIN but no less than\n+\t 1 unless MAX is zero.  */\n+      range.likely = (range.min\n+\t\t      ? range.min\n+\t\t      : range.max && (range.max < HOST_WIDE_INT_MAX\n+\t\t\t\t      || warn_level > 1) ? 1 : 0);\n+    }\n+\n+  /* Finally adjust the unlikely counter to be at least as large as\n+     the maximum.  */\n+  if (range.unlikely < range.max)\n+    range.unlikely = range.max;\n+\n+  return *this;\n+}\n+\n+/* Return the maximum number of digits a value of TYPE formats in\n+   BASE on output, not counting base prefix .  */\n+\n+unsigned\n+fmtresult::type_max_digits (tree type, int base)\n+{\n+  unsigned prec = TYPE_PRECISION (type);\n+  if (base == 8)\n+    return (prec + 2) / 3;\n+\n+  if (base == 16)\n+    return prec / 4;\n+\n+  /* Decimal approximation: yields 3, 5, 10, and 20 for precision\n+     of 8, 16, 32, and 64 bits.  */\n+  return prec * 301 / 1000 + 1;\n+}\n+\n+/* Description of a format directive.  */\n \n struct directive\n {\n@@ -521,8 +638,8 @@ struct directive\n      take one or when none is available (such as for vararg functions).  */\n   tree arg;\n \n-  /* Format conversion function that given a conversion specification\n-     and an argument returns the formatting result.  */\n+  /* Format conversion function that given a directive and an argument\n+     returns the formatting result.  */\n   fmtresult (*fmtfunc) (const directive &, tree);\n \n   /* Return True when a the format flag CHR has been used.  */\n@@ -690,68 +807,29 @@ bytes_remaining (unsigned HOST_WIDE_INT navail, const format_result &res)\n \n   if (HOST_WIDE_INT_MAX <= navail)\n     {\n-      range.min = range.max = navail;\n+      range.min = range.max = range.likely = range.unlikely = navail;\n       return range;\n     }\n \n-  if (res.number_chars < navail)\n-    {\n-      range.min = range.max = navail - res.number_chars;\n-    }\n-  else if (res.number_chars_min < navail)\n-    {\n-      range.max = navail - res.number_chars_min;\n-    }\n-  else\n-    range.max = 0;\n-\n-  if (res.number_chars_max < navail)\n-    range.min = navail - res.number_chars_max;\n-  else\n-    range.min = 0;\n+  /* The lower bound of the available range is the available size\n+     minus the maximum output size, and the upper bound is the size\n+     minus the minimum.  */\n+  range.max = res.range.min < navail ? navail - res.range.min : 0;\n \n-  return range;\n-}\n-\n-/* Given the formatting result described by RES and NAVAIL, the number\n-   of available in the destination, return the minimum number of bytes\n-   remaining in the destination.  */\n+  /* Given the formatting result described by RES and NAVAIL, the number\n+     of available in the destination, return the minimum number of bytes\n+     remaining in the destination.  */\n+  range.likely = res.range.likely < navail ? navail - res.range.likely : 0;\n \n-static inline unsigned HOST_WIDE_INT\n-min_bytes_remaining (unsigned HOST_WIDE_INT navail, const format_result &res)\n-{\n-  if (HOST_WIDE_INT_MAX <= navail)\n-    return navail;\n-\n-  if (warn_format_overflow > 1 || res.knownrange)\n-    {\n-      /* At level 2, or when all directives output an exact number\n-\t of bytes or when their arguments were bounded by known\n-\t ranges, use the greater of the two byte counters if it's\n-\t valid to compute the result.  */\n-      if (res.number_chars_max < HOST_WIDE_INT_MAX)\n-\tnavail -= res.number_chars_max;\n-      else if (res.number_chars < HOST_WIDE_INT_MAX)\n-\tnavail -= res.number_chars;\n-      else if (res.number_chars_min < HOST_WIDE_INT_MAX)\n-\tnavail -= res.number_chars_min;\n-    }\n+  if (res.range.max < HOST_WIDE_INT_MAX)\n+    range.min = res.range.max < navail ? navail - res.range.max : 0;\n   else\n-    {\n-      /* At level 1 use the smaller of the byte counters to compute\n-\t the result.  */\n-      if (res.number_chars < HOST_WIDE_INT_MAX)\n-\tnavail -= res.number_chars;\n-      else if (res.number_chars_min < HOST_WIDE_INT_MAX)\n-\tnavail -= res.number_chars_min;\n-      else if (res.number_chars_max < HOST_WIDE_INT_MAX)\n-\tnavail -= res.number_chars_max;\n-    }\n+    range.min = range.likely;\n \n-  if (navail > HOST_WIDE_INT_MAX)\n-    navail = 0;\n+  range.unlikely = (res.range.unlikely < navail\n+\t\t    ? navail - res.range.unlikely : 0);\n \n-  return navail;\n+  return range;\n }\n \n /* Description of a call to a formatted function.  */\n@@ -810,7 +888,6 @@ static fmtresult\n format_none (const directive &, tree)\n {\n   fmtresult res (0);\n-  res.bounded = true;\n   return res;\n }\n \n@@ -820,7 +897,6 @@ static fmtresult\n format_percent (const directive &, tree)\n {\n   fmtresult res (1);\n-  res.bounded = true;\n   return res;\n }\n \n@@ -929,23 +1005,22 @@ adjust_range_for_overflow (tree dirtype, tree *argmin, tree *argmax)\n }\n \n /* Return a range representing the minimum and maximum number of bytes\n-   that the conversion specification DIR will write on output for the\n-   integer argument ARG when non-null.  ARG may be null (for vararg\n-   functions).  */\n+   that the directive DIR will write on output for the integer argument\n+   ARG when non-null.  ARG may be null (for vararg functions).  */\n \n static fmtresult\n format_integer (const directive &dir, tree arg)\n {\n   tree intmax_type_node;\n   tree uintmax_type_node;\n \n-  /* Set WIDTH and PRECISION based on the specification.  */\n-  HOST_WIDE_INT width = dir.width;\n-  HOST_WIDE_INT prec = dir.prec;\n-\n   /* Base to format the number in.  */\n   int base;\n \n+  /* True when a conversion is preceded by a prefix indicating the base\n+     of the argument (octal or hexadecimal).  */\n+  bool maybebase = dir.get_flag ('#');\n+\n   /* True when a signed conversion is preceded by a sign or space.  */\n   bool maybesign = false;\n \n@@ -1044,9 +1119,10 @@ format_integer (const directive &dir, tree arg)\n       /* When a constant argument has been provided use its value\n \t rather than type to determine the length of the output.  */\n \n-      HOST_WIDE_INT len;\n+      fmtresult res;\n \n-      if ((prec == HOST_WIDE_INT_MIN || prec == 0) && integer_zerop (arg))\n+      if ((dir.prec == HOST_WIDE_INT_MIN || dir.prec == 0)\n+\t  && integer_zerop (arg))\n \t{\n \t  /* As a special case, a precision of zero with a zero argument\n \t     results in zero bytes except in base 8 when the '#' flag is\n@@ -1055,44 +1131,45 @@ format_integer (const directive &dir, tree arg)\n \t     when it results in just one byte (with width having the normal\n \t     effect).  This must extend to the case of a specified precision\n \t     with an unknown value because it can be zero.  */\n-\t  len = ((base == 8 && dir.get_flag ('#')) || maybesign);\n+\t  res.range.min = ((base == 8 && dir.get_flag ('#')) || maybesign);\n+\t  if (res.range.min == 0 && dir.prec == HOST_WIDE_INT_MIN)\n+\t    {\n+\t      res.range.max = 1;\n+\t      res.range.likely = 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      res.range.max = res.range.min;\n+\t      res.range.likely = res.range.min;\n+\t    }\n \t}\n       else\n \t{\n \t  /* Convert the argument to the type of the directive.  */\n \t  arg = fold_convert (dirtype, arg);\n \n-\t  /* True when a conversion is preceded by a prefix indicating the base\n-\t     of the argument (octal or hexadecimal).  */\n-\t  bool maybebase = dir.get_flag ('#');\n-\t  len = tree_digits (arg, base, prec, maybesign, maybebase);\n-\t  if (len < 1)\n-\t    len = HOST_WIDE_INT_MAX;\n-\t}\n-\n-      if (len < width)\n-\tlen = width;\n+\t  res.range.min = tree_digits (arg, base, dir.prec,\n+\t\t\t\t       maybesign, maybebase);\n \n-      /* The minimum and maximum number of bytes produced by the directive.  */\n-      fmtresult res;\n-\n-      res.range.min = len;\n+\t  /* Set the maximum to INT_MAX when precision is specified\n+\t     but unknown (because it can be as large as that) otherwise\n+\t     to the minimum and have it adjusted below.  */\n+\t  if (dir.prec == HOST_WIDE_INT_MIN)\n+\t    res.range.max = target_int_max ();\n+\t  else\n+\t    res.range.max = res.range.min;\n \n-      /* The upper bound of the number of bytes is unlimited when either\n-\t width or precision is specified but its value is unknown, and\n-\t the same as the lower bound otherwise.  */\n-      if (width == HOST_WIDE_INT_MIN || prec == HOST_WIDE_INT_MIN)\n-\t{\n-\t  res.range.max = HOST_WIDE_INT_MAX;\n-\t}\n-      else\n-\t{\n-\t  res.range.max = len;\n-\t  res.bounded = true;\n-\t  res.knownrange = true;\n-\t  res.bounded = true;\n+\t  res.range.likely = res.range.min;\n \t}\n \n+      res.range.unlikely = res.range.max;\n+\n+      /* Bump up the counters if WIDTH is greater than LEN.  */\n+      res.adjust_for_width_or_precision (dir.width, dirtype, base,\n+\t\t\t\t\t (sign | maybebase) + (base == 16));\n+      /* Bump up the counters again if PRECision is greater still.  */\n+      res.adjust_for_width_or_precision (dir.prec, dirtype, base,\n+\t\t\t\t\t (sign | maybebase) + (base == 16));\n       return res;\n     }\n   else if (TREE_CODE (TREE_TYPE (arg)) == INTEGER_TYPE\n@@ -1107,10 +1184,6 @@ format_integer (const directive &dir, tree arg)\n \n   fmtresult res;\n \n-  /* The result is bounded unless width or precision has been specified\n-     whose value is unknown.  */\n-  res.bounded = width != HOST_WIDE_INT_MIN && prec != HOST_WIDE_INT_MIN;\n-\n   /* Using either the range the non-constant argument is in, or its\n      type (either \"formal\" or actual), create a range of values that\n      constrain the length of output given the warning level.  */\n@@ -1178,10 +1251,11 @@ format_integer (const directive &dir, tree arg)\n \t or one whose value range cannot be determined, create a T_MIN\n \t constant if the argument's type is signed and T_MAX otherwise,\n \t and use those to compute the range of bytes that the directive\n-\t can output.  When precision is specified but unknown, use zero\n-\t as the minimum since it results in no bytes on output (unless\n-\t width is specified to be greater than 0).  */\n-      argmin = build_int_cst (argtype, prec && prec != HOST_WIDE_INT_MIN);\n+\t can output.  When precision may be zero, use zero as the minimum\n+\t since it results in no bytes on output (unless width is specified\n+\t to be greater than 0).  */\n+      bool zero = dir.prec == 0 || dir.prec == HOST_WIDE_INT_MIN;\n+      argmin = build_int_cst (argtype, !zero);\n \n       int typeprec = TYPE_PRECISION (dirtype);\n       int argprec = TYPE_PRECISION (argtype);\n@@ -1250,20 +1324,20 @@ format_integer (const directive &dir, tree arg)\n       res.range.max = format_integer (dir, argmin).range.max;\n     }\n \n-  /* The result is bounded either when the argument is determined to be\n-     (e.g., when it's within some range) or when the minimum and maximum\n-     are the same.  That can happen here for example when the specified\n-     width is as wide as the greater of MIN and MAX, as would be the case\n-     with sprintf (d, \"%08x\", x) with a 32-bit integer x.  */\n-  res.bounded |= res.range.min == res.range.max;\n-\n   if (res.range.max < res.range.min)\n     {\n       unsigned HOST_WIDE_INT tmp = res.range.max;\n       res.range.max = res.range.min;\n       res.range.min = tmp;\n     }\n \n+  res.range.likely = res.knownrange ? res.range.max : res.range.min;\n+  res.range.unlikely = res.range.max;\n+  res.adjust_for_width_or_precision (dir.width, dirtype, base,\n+\t\t\t\t     (sign | maybebase) + (base == 16));\n+  res.adjust_for_width_or_precision (dir.prec, dirtype, base,\n+\t\t\t\t     (sign | maybebase) + (base == 16));\n+\n   return res;\n }\n \n@@ -1371,9 +1445,9 @@ format_floating_max (tree type, char spec, HOST_WIDE_INT prec)\n }\n \n /* Return a range representing the minimum and maximum number of bytes\n-   that the conversion specification DIR will output for any argument\n-   given the WIDTH and PRECISION (extracted from DIR).  This function\n-   is used when the directive argument or its value isn't known.  */\n+   that the format directive DIR will output for any argument given\n+   the WIDTH and PRECISION (extracted from DIR).  This function is\n+   used when the directive argument or its value isn't known.  */\n \n static fmtresult\n format_floating (const directive &dir)\n@@ -1402,35 +1476,45 @@ format_floating (const directive &dir)\n   /* The minimum and maximum number of bytes produced by the directive.  */\n   fmtresult res;\n \n-  /* The result is always bounded (though the range may be all of int).  */\n-  res.bounded = true;\n-\n-  /* The minimum output as determined by flags.  It's always at least 1.  */\n+  /* The minimum output as determined by flags.  It's always at least 1.\n+     When plus or space are set the output is preceded by either a sign\n+     or a space.  */\n   int flagmin = (1 /* for the first digit */\n-\t\t + (dir.get_flag ('+') | dir.get_flag (' '))\n-\t\t + (dir.prec == 0 && dir.get_flag ('#')));\n+\t\t + (dir.get_flag ('+') | dir.get_flag (' ')));\n \n-  if (dir.width == HOST_WIDE_INT_MIN || dir.prec == HOST_WIDE_INT_MIN)\n-    {\n-      /* When either width or precision is specified but unknown\n-\t the upper bound is the maximum.  Otherwise it will be\n-\t computed for each directive below.  */\n-      res.range.max = HOST_WIDE_INT_MAX;\n-    }\n-  else\n-    res.range.max = HOST_WIDE_INT_M1U;\n+  /* When the pound flag is set the decimal point is included in output\n+     regardless of precision.  Whether or not a decimal point is included\n+     otherwise depends on the specification and precision.  */\n+  bool radix = dir.get_flag ('#');\n \n   switch (dir.specifier)\n     {\n     case 'A':\n     case 'a':\n       {\n-\tres.range.min = flagmin + 5 + (dir.prec > 0 ? dir.prec + 1 : 0);\n-\tif (res.range.max == HOST_WIDE_INT_M1U)\n-\t  {\n-\t    /* Compute the upper bound for -TYPE_MAX.  */\n-\t    res.range.max = format_floating_max (type, 'a', dir.prec);\n-\t  }\n+\tHOST_WIDE_INT minprec = 6 + !radix /* decimal point */;\n+\tif (dir.prec <= 0)\n+\t  minprec = 0;\n+\telse if (dir.prec > 0)\n+\t  minprec = dir.prec + !radix /* decimal point */;\n+\n+\tres.range.min = (2 /* 0x */\n+\t\t\t + flagmin\n+\t\t\t + radix\n+\t\t\t + minprec\n+\t\t\t + 3 /* p+0 */);\n+\n+\tHOST_WIDE_INT maxprec\n+\t  = dir.prec == HOST_WIDE_INT_MIN ? target_int_max () : dir.prec;\n+\tres.range.max = format_floating_max (type, 'a', maxprec);\n+\tres.range.likely = res.range.min;\n+\n+\t/* The unlikely maximum accounts for the longest multibyte\n+\t   decimal point character.  */\n+\tif (dir.prec != 0)\n+\t  res.range.unlikely = res.range.max + target_mb_len_max () - 1;\n+\telse\n+\t  res.range.unlikely = res.range.max;\n \n \tbreak;\n       }\n@@ -1440,18 +1524,32 @@ format_floating (const directive &dir)\n       {\n \t/* The minimum output is \"[-+]1.234567e+00\" regardless\n \t   of the value of the actual argument.  */\n+\tHOST_WIDE_INT minprec = 6 + !radix /* decimal point */;\n+\tif (dir.prec == HOST_WIDE_INT_MIN || dir.prec == 0)\n+\t  minprec = 0;\n+\telse if (dir.prec > 0)\n+\t  minprec = dir.prec + !radix /* decimal point */;\n+\n \tres.range.min = (flagmin\n-\t\t\t + (dir.prec == HOST_WIDE_INT_MIN\n-\t\t\t    ? 0 : dir.prec < 0 ? 7 : dir.prec ? dir.prec + 1 : 0)\n+\t\t\t + radix\n+\t\t\t + minprec\n \t\t\t + 2 /* e+ */ + 2);\n \n-\tif (res.range.max == HOST_WIDE_INT_M1U)\n-\t  {\n-\t    /* MPFR uses a precision of 16 by default for some reason.\n-\t       Set it to the C default of 6.  */\n-\t    res.range.max = format_floating_max (type, 'e',\n-\t\t\t\t\t\t -1 == dir.prec ? 6 : dir.prec);\n-\t  }\n+\t/* MPFR uses a precision of 16 by default for some reason.\n+\t   Set it to the C default of 6.  */\n+\tHOST_WIDE_INT maxprec\n+\t  = (dir.prec == HOST_WIDE_INT_MIN ? target_int_max ()\n+\t     : dir.prec < 0 ? 6 : dir.prec);\n+\tres.range.max = format_floating_max (type, 'e', maxprec);\n+\n+\tres.range.likely = res.range.min;\n+\n+\t/* The unlikely maximum accounts for the longest multibyte\n+\t   decimal point character.  */\n+\tif (dir.prec != 0)\n+\t  res.range.unlikely = res.range.max + target_mb_len_max () -1;\n+\telse\n+\t  res.range.unlikely = res.range.max;\n \tbreak;\n       }\n \n@@ -1463,16 +1561,27 @@ format_floating (const directive &dir)\n \t   is zero, the lower bound is 1 byte (e.g., \"1\").  Otherwise,\n \t   when precision is greater than zero, then the lower bound\n \t   is 2 plus precision (plus flags).  */\n-\tres.range.min = (flagmin\n-\t\t\t + (dir.prec != HOST_WIDE_INT_MIN)   /* decimal point */\n-\t\t\t + (dir.prec == HOST_WIDE_INT_MIN\n-\t\t\t    ? 0 : dir.prec < 0 ? 6 : dir.prec ? dir.prec : -1));\n-\n-\tif (res.range.max == HOST_WIDE_INT_M1U)\n-\t  {\n-\t    /* Compute the upper bound for -TYPE_MAX.  */\n-\t    res.range.max = format_floating_max (type, 'f', dir.prec);\n-\t  }\n+\tHOST_WIDE_INT minprec = 0;\n+\tif (dir.prec == HOST_WIDE_INT_MIN)\n+\t  minprec = 0;\n+\telse if (dir.prec < 0)\n+\t  minprec = 6 + !radix /* decimal point */;\n+\telse if (dir.prec)\n+\t  minprec = dir.prec + !radix /* decimal point */;\n+\n+\tres.range.min = flagmin + radix + minprec;\n+\n+\t/* Compute the upper bound for -TYPE_MAX.  */\n+\tHOST_WIDE_INT maxprec\n+\t  = dir.prec == HOST_WIDE_INT_MIN ? target_int_max () : dir.prec;\n+\tres.range.max = format_floating_max (type, 'f', maxprec);\n+\n+\tres.range.likely = res.range.min;\n+\n+\t/* The unlikely maximum accounts for the longest multibyte\n+\t   decimal point character.  */\n+\tif (dir.prec != 0)\n+\t  res.range.unlikely = res.range.max + target_mb_len_max () - 1;\n \tbreak;\n       }\n \n@@ -1484,27 +1593,24 @@ format_floating (const directive &dir)\n \t   the lower bound on the range of bytes (not counting flags\n \t   or width) is 1.  */\n \tres.range.min = flagmin;\n-\tif (res.range.max == HOST_WIDE_INT_M1U)\n-\t  {\n-\t    /* Compute the upper bound for -TYPE_MAX which should be\n-\t       the lesser of %e and %f.  */\n-\t    res.range.max = format_floating_max (type, 'g', dir.prec);\n-\t  }\n+\n+\tHOST_WIDE_INT maxprec\n+\t  = dir.prec == HOST_WIDE_INT_MIN ? target_int_max () : dir.prec;\n+\tres.range.max = format_floating_max (type, 'g', maxprec);\n+\tres.range.likely = res.range.max;\n+\n+\t/* The unlikely maximum accounts for the longest multibyte\n+\t   decimal point character.  */\n+\tres.range.unlikely = res.range.max + target_mb_len_max () - 1;\n \tbreak;\n       }\n \n     default:\n       return fmtresult ();\n     }\n \n-  if (dir.width > 0)\n-    {\n-      /* If width has been specified use it to adjust the range.  */\n-      if (res.range.min < (unsigned)dir.width)\n-\tres.range.min = dir.width;\n-      if (res.range.max < (unsigned)dir.width)\n-\tres.range.max = dir.width;\n-    }\n+  /* Bump up the byte counters if WIDTH is greater.  */\n+  res.adjust_for_width_or_precision (dir.width);\n \n   return res;\n }\n@@ -1519,13 +1625,29 @@ format_floating (const directive &dir, tree arg)\n   if (!arg || TREE_CODE (arg) != REAL_CST)\n     return format_floating (dir);\n \n-  HOST_WIDE_INT prec = dir.prec;\n+  HOST_WIDE_INT prec[] = { dir.prec, dir.prec };\n \n-  if (prec < 0 && TOUPPER (dir.specifier) != 'A')\n+  if (TOUPPER (dir.specifier) == 'A')\n     {\n-      /* Specify the precision explicitly since mpfr_sprintf defaults\n-\t to zero.  */\n-      prec = 6;\n+      /* For %a, leave the minimum precision unspecified to let\n+\t MFPR trim trailing zeros (as it and many other systems\n+\t including Glibc happen to do) and set the maximum\n+\t precision to reflect what it would be with trailing zeros\n+\t present (as Solaris and derived systems do).  */\n+      if (prec[0] < 0)\n+\tprec[0] = -1;\n+      if (prec[1] < 0)\n+\t{\n+\t  unsigned fmtprec\n+\t    = (dir.modifier == FMT_LEN_L\n+\t       ? REAL_MODE_FORMAT (XFmode)->p\n+\t       : REAL_MODE_FORMAT (DFmode)->p);\n+\n+\t  /* The precision of the IEEE 754 double format is 53.\n+\t     The precision of all other GCC binary double formats\n+\t     is 56 or less.  */\n+\t  prec[1] = fmtprec <= 56 ? 13 : 15;\n+\t}\n     }\n \n   /* The minimum and maximum number of bytes produced by the directive.  */\n@@ -1569,14 +1691,8 @@ format_floating (const directive &dir, tree arg)\n \n \t/* Format it and store the result in the corresponding member\n \t   of the result struct.  */\n-\tunsigned HOST_WIDE_INT len\n-\t  = get_mpfr_format_length (mpfrval, fmtstr, prec,\n-\t\t\t\t    dir.specifier, rndspec);\n-\n-\tif (0 < dir.width && len < (unsigned)dir.width)\n-\t  len = dir.width;\n-\n-\t*minmax[i] = len;\n+\t*minmax[i] = get_mpfr_format_length (mpfrval, fmtstr, prec[i],\n+\t\t\t\t\t     dir.specifier, rndspec);\n       }\n   }\n \n@@ -1589,23 +1705,25 @@ format_floating (const directive &dir, tree arg)\n       res.range.max = tmp;\n     }\n \n-  /* The range of output is known even if the result isn't bounded.  */\n-  if (dir.width == HOST_WIDE_INT_MIN)\n+  res.knownrange = true;\n+\n+  /* For the same floating point constant use the longer output\n+     as the likely maximum since with round to nearest either is\n+     equally likely.  */\n+  res.range.likely = res.range.max;\n+  res.range.unlikely = res.range.max;\n+\n+  if (res.range.max > 2 && (prec[0] != 0 || prec[1] != 0))\n     {\n-      res.knownrange = false;\n-      res.range.max = HOST_WIDE_INT_MAX;\n+      /* Unless the precision is zero output longer than 2 bytes may\n+\t include the decimal point which must be a single character\n+\t up to MB_LEN_MAX in length.  This is overly conservative\n+\t since in some conversions some constants result in no decimal\n+\t point (e.g., in %g).  */\n+      res.range.unlikely += target_mb_len_max () - 1;\n     }\n-  else\n-    res.knownrange = true;\n \n-  /* The output of all directives except \"%a\" is fully specified\n-     and so the result is bounded unless it exceeds INT_MAX.\n-     For \"%a\" the output is fully specified only when precision\n-     is explicitly specified.  */\n-  res.bounded = (res.knownrange\n-\t\t && (TOUPPER (dir.specifier) != 'A'\n-\t\t     || (0 <= dir.prec && (unsigned) dir.prec < target_int_max ()))\n-\t\t && res.range.min < target_int_max ());\n+  res.adjust_for_width_or_precision (dir.width);\n \n   return res;\n }\n@@ -1623,10 +1741,7 @@ get_string_length (tree str)\n   if (tree slen = c_strlen (str, 1))\n     {\n       /* Simply return the length of the string.  */\n-      fmtresult res;\n-      res.range.min = res.range.max = tree_to_shwi (slen);\n-      res.bounded = true;\n-      res.knownrange = true;\n+      fmtresult res (tree_to_shwi (slen));\n       return res;\n     }\n \n@@ -1640,18 +1755,45 @@ get_string_length (tree str)\n \n   if (lenrange [0] || lenrange [1])\n     {\n-      fmtresult res;\n+      HOST_WIDE_INT min\n+\t= (tree_fits_uhwi_p (lenrange[0])\n+\t   ? tree_to_uhwi (lenrange[0])\n+\t   : 0);\n \n-      res.range.min = (tree_fits_uhwi_p (lenrange[0])\n-\t\t       ? tree_to_uhwi (lenrange[0]) : warn_format_overflow > 1);\n-      res.range.max = (tree_fits_uhwi_p (lenrange[1])\n-\t\t       ? tree_to_uhwi (lenrange[1]) : HOST_WIDE_INT_M1U);\n+      HOST_WIDE_INT max\n+\t= (tree_fits_uhwi_p (lenrange[1])\n+\t   ? tree_to_uhwi (lenrange[1])\n+\t   : HOST_WIDE_INT_M1U);\n \n-      /* Set RES.BOUNDED to true if and only if all strings referenced\n+      /* get_range_strlen() returns the target value of SIZE_MAX for\n+\t strings of unknown length.  Bump it up to HOST_WIDE_INT_M1U\n+\t which may be bigger.  */\n+      if ((unsigned HOST_WIDE_INT)min == target_size_max ())\n+\tmin = HOST_WIDE_INT_M1U;\n+      if ((unsigned HOST_WIDE_INT)max == target_size_max ())\n+\tmax = HOST_WIDE_INT_M1U;\n+\n+      fmtresult res (min, max);\n+\n+      /* Set RES.KNOWNRANGE to true if and only if all strings referenced\n \t by STR are known to be bounded (though not necessarily by their\n \t actual length but perhaps by their maximum possible length).  */\n-      res.bounded = res.range.max < target_int_max ();\n-      res.knownrange = res.bounded;\n+      if (res.range.max < target_int_max ())\n+\t{\n+\t  res.knownrange = true;\n+\t  /* When the the length of the longest string is known and not\n+\t     excessive use it as the likely length of the string(s).  */\n+\t  res.range.likely = res.range.max;\n+\t}\n+      else\n+\t{\n+\t  /* When the upper bound is unknown (as assumed to be excessive)\n+\t     set the likely length to the greater of 1 and the length of\n+\t     the shortest string.  */\n+\t  res.range.likely = res.range.min ? res.range.min : warn_level > 1;\n+\t}\n+\n+      res.range.unlikely = res.range.max;\n \n       return res;\n     }\n@@ -1669,58 +1811,54 @@ format_character (const directive &dir, tree arg)\n {\n   fmtresult res;\n \n-  /* The maximum number of bytes for an unknown wide character argument\n-     to a \"%lc\" directive adjusted for precision but not field width.\n-     6 is the longest UTF-8 sequence for a single wide character.  */\n-  const unsigned HOST_WIDE_INT max_bytes_for_unknown_wc\n-    = (0 <= dir.prec ? dir.prec : warn_level > 1 ? 6 : 1);\n-\n-    if (dir.modifier == FMT_LEN_l)\n-    {\n-      /* Positive if the argument is a wide NUL character.  */\n-      int nul = (arg && TREE_CODE (arg) == INTEGER_CST\n-\t\t ? integer_zerop (arg) : -1);\n-\n-      /* A '%lc' directive is the same as '%ls' for a two element\n-\t wide string character with the second element of NUL, so\n-\t when the character is unknown the minimum number of bytes\n-\t is the smaller of either 0 (at level 1) or 1 (at level 2)\n-\t and WIDTH, and the maximum is MB_CUR_MAX in the selected\n-\t locale, which is unfortunately, unknown.  */\n-      res.range.min = warn_level == 1 ? !nul : nul < 1;\n-      res.range.max = max_bytes_for_unknown_wc;\n-      /* The range above is good enough to issue warnings but not\n-\t for value range propagation, so clear BOUNDED.  */\n-      res.bounded = false;\n+  res.knownrange = true;\n+\n+  if (dir.modifier == FMT_LEN_l)\n+    {\n+      unsigned HOST_WIDE_INT val;\n+\n+      if (arg && TREE_CODE (arg) == INTEGER_CST && tree_fits_shwi_p (arg))\n+\tval = tree_to_shwi (arg);\n+      else\n+\tval = HOST_WIDE_INT_MAX;\n+\n+      /* A wide character can result in as few as zero bytes.  */\n+      res.range.min = 0;\n+\n+      if (val == 0)\n+\t{\n+\t  /* The NUL wide character results in no bytes.  */\n+\t  res.range.max = 0;\n+\t  res.range.likely = 0;\n+\t  res.range.unlikely = 0;\n+\t}\n+      else if (0 < val && val < 128)\n+\t{\n+\t  /* A wide character in the ASCII range most likely results\n+\t     in a single byte, and only unlikely in up to MB_LEN_MAX.  */\n+\t  res.range.max = 1;\n+\t  res.range.likely = 1;\n+\t  res.range.unlikely = target_mb_len_max ();\n+\t}\n+      else\n+\t{\n+\t  /* A wide character outside the ASCII range likely results\n+\t     in up to two bytes, and only unlikely in up to MB_LEN_MAX.  */\n+\t  res.range.max = target_mb_len_max ();\n+\t  res.range.likely = 2;\n+\t  res.range.unlikely = res.range.max;\n+\t}\n     }\n   else\n     {\n       /* A plain '%c' directive.  Its ouput is exactly 1.  */\n       res.range.min = res.range.max = 1;\n-      res.bounded = true;\n+      res.range.likely = res.range.unlikely = res.range.min;\n       res.knownrange = true;\n     }\n \n-  /* Adjust the lengths for field width.  */\n-  if (0 < dir.width)\n-    {\n-      if (res.range.min < (unsigned HOST_WIDE_INT)dir.width)\n-\tres.range.min = dir.width;\n-\n-      if (res.range.max < (unsigned HOST_WIDE_INT)dir.width)\n-\tres.range.max = dir.width;\n-\n-      /* Adjust BOUNDED if width happens to make them equal.  */\n-      if (res.range.min == res.range.max && res.range.min < target_int_max ())\n-\tres.bounded = true;\n-    }\n-\n-  /* When precision is specified the range of characters on output\n-     is known to be bounded by it.  */\n-  if (-1 < dir.width && -1 < dir.prec)\n-    res.knownrange = true;\n-\n-  return res;\n+  /* Bump up the byte counters if WIDTH is greater.  */\n+  return res.adjust_for_width_or_precision (dir.width);\n }\n \n /* Return the minimum and maximum number of characters formatted\n@@ -1733,83 +1871,62 @@ format_string (const directive &dir, tree arg)\n {\n   fmtresult res;\n \n-  /* The maximum number of bytes for an unknown string argument to either\n-     a \"%s\" or \"%ls\" directive adjusted for precision but not field width.  */\n-  const unsigned HOST_WIDE_INT max_bytes_for_unknown_str\n-    = (0 <= dir.prec ? dir.prec : warn_format_overflow > 1);\n-\n-  /* The result is bounded unless overriddden for a non-constant string\n-     of an unknown length.  */\n-  bool bounded = true;\n-\n   /* Compute the range the argument's length can be in.  */\n   fmtresult slen = get_string_length (arg);\n   if (slen.range.min == slen.range.max\n       && slen.range.min < HOST_WIDE_INT_MAX)\n     {\n-      gcc_checking_assert (slen.range.min == slen.range.max);\n+      /* The argument is either a string constant or it refers\n+\t to one of a number of strings of the same length.  */\n \n       /* A '%s' directive with a string argument with constant length.  */\n       res.range = slen.range;\n \n-      /* The output of \"%s\" and \"%ls\" directives with a constant\n-\t string is in a known range unless width of an unknown value\n-\t is specified.  For \"%s\" it is the length of the string.  For\n-\t \"%ls\" it is in the range [length, length * MB_LEN_MAX].\n-\t (The final range can be further constrained by width and\n-\t precision but it's always known.)  */\n-      res.knownrange = HOST_WIDE_INT_MIN != dir.width;\n-\n       if (dir.modifier == FMT_LEN_l)\n \t{\n-\t  bounded = false;\n-\n-\t  if (warn_level > 1)\n-\t    {\n-\t      /* Leave the minimum number of bytes the wide string\n-\t\t converts to equal to its length and set the maximum\n-\t\t to the worst case length which is the string length\n-\t\t multiplied by MB_LEN_MAX.  */\n-\n-\t      /* It's possible to be smarter about computing the maximum\n-\t\t by scanning the wide string for any 8-bit characters and\n-\t\t if it contains none, using its length for the maximum.\n-\t\t Even though this would be simple to do it's unlikely to\n-\t\t be worth it when dealing with wide characters.  */\n-\t      res.range.max *= target_mb_len_max();\n-\t    }\n+\t  /* In the worst case the length of output of a wide string S\n+\t     is bounded by MB_LEN_MAX * wcslen (S).  */\n+\t  res.range.max *= target_mb_len_max ();\n+\t  res.range.unlikely = res.range.max;\n+\t  /* It's likely that the the total length is not more that\n+\t     2 * wcslen (S).*/\n+\t  res.range.likely = res.range.min * 2;\n \n \t  /* For a wide character string, use precision as the maximum\n \t     even if precision is greater than the string length since\n \t     the number of bytes the string converts to may be greater\n \t     (due to MB_CUR_MAX).  */\n-\t  if (0 <= dir.prec)\n-\t    res.range.max = dir.prec;\n-\t}\n-      else if (-1 <= dir.width)\n-\t{\n-\t  /* The output of a \"%s\" directive with a constant argument\n-\t     and constant or no width is bounded.  It is constant if\n-\t     precision is either not specified or it is specified and\n-\t     its value is known.  */\n-\t  res.bounded = true;\n-\t}\n-      else if (dir.width == HOST_WIDE_INT_MIN)\n-\t{\n-\t  /* Specified but unknown width makes the output unbounded.  */\n-\t  res.range.max = HOST_WIDE_INT_MAX;\n-\t}\n+\t  if (0 <= dir.prec\n+\t      && (unsigned HOST_WIDE_INT)dir.prec < res.range.max)\n+\t    {\n+\t      res.range.max = dir.prec;\n+\t      res.range.likely = dir.prec;\n+\t      res.range.unlikely = dir.prec;\n+\t    }\n \n-      if (0 <= dir.prec && (unsigned HOST_WIDE_INT)dir.prec < res.range.min)\n-\t{\n-\t  res.range.min = dir.prec;\n-\t  res.range.max = dir.prec;\n+\t  /* Even a non-empty wide character string need not convert into\n+\t     any bytes.  */\n+\t  res.range.min = 0;\n \t}\n-      else if (dir.prec == HOST_WIDE_INT_MIN)\n+      else\n \t{\n-\t  /* When precision is specified but not known the lower\n-\t     bound is assumed to be as low as zero.  */\n-\t  res.range.min = 0;\n+\t  res.knownrange = true;\n+\n+\t  if (dir.prec == HOST_WIDE_INT_MIN)\n+\t    res.range.min = 0;\n+\t  else if ((unsigned HOST_WIDE_INT)dir.prec < res.range.min)\n+\t    {\n+\t      res.range.min = dir.prec;\n+\t      res.range.max = dir.prec;\n+\t      res.range.likely = dir.prec;\n+\t      res.range.unlikely = dir.prec;\n+\t    }\n+\t  else if ((unsigned HOST_WIDE_INT)dir.prec < res.range.max)\n+\t    {\n+\t      res.range.max = dir.prec;\n+\t      res.range.likely = dir.prec;\n+\t      res.range.unlikely = dir.prec;\n+\t    }\n \t}\n     }\n   else if (arg && integer_zerop (arg))\n@@ -1833,49 +1950,110 @@ format_string (const directive &dir, tree arg)\n \t  if (slen.range.min >= target_int_max ())\n \t    slen.range.min = 0;\n \t  else if ((unsigned HOST_WIDE_INT)dir.prec < slen.range.min)\n-\t    slen.range.min = dir.prec;\n+\t    {\n+\t      slen.range.min = dir.prec;\n+\t      slen.range.likely = slen.range.min;\n+\t    }\n \n \t  if ((unsigned HOST_WIDE_INT)dir.prec < slen.range.max\n \t      || slen.range.max >= target_int_max ())\n-\t    slen.range.max = dir.prec;\n+\t    {\n+\t      slen.range.max = dir.prec;\n+\t      slen.range.likely = slen.range.max;\n+\t    }\n \t}\n       else if (slen.range.min >= target_int_max ())\n \t{\n-\t  slen.range.min = max_bytes_for_unknown_str;\n-\t  slen.range.max = max_bytes_for_unknown_str;\n-\t  bounded = false;\n+\t  slen.range.min = 0;\n+\t  slen.range.max = HOST_WIDE_INT_MAX;\n+\t  /* At level one strings of unknown length are assumed to be\n+\t     empty, while at level 1 they are assumed to be one byte\n+\t     long.  */\n+\t  slen.range.likely = warn_level > 1;\n \t}\n \n-      res.range = slen.range;\n+      slen.range.unlikely = slen.range.max;\n \n-      /* The output is considered bounded when a precision has been\n-\t specified to limit the number of bytes or when the number\n-\t of bytes is known or contrained to some range.  */\n-      res.bounded = 0 <= dir.prec || slen.bounded;\n+      res.range = slen.range;\n       res.knownrange = slen.knownrange;\n     }\n \n-  /* Adjust the lengths for field width.  */\n-  if (0 < dir.width)\n+  /* Bump up the byte counters if WIDTH is greater.  */\n+  return res.adjust_for_width_or_precision (dir.width);\n+}\n+\n+/* Format plain string (part of the format string itself).  */\n+\n+static fmtresult\n+format_plain (const directive &dir, tree)\n+{\n+  fmtresult res (dir.len);\n+  return res;\n+}\n+\n+/* Return true if the RESULT of a directive in a call describe by INFO\n+   should be diagnosed given the AVAILable space in the destination.  */\n+\n+static bool\n+should_warn_p (const pass_sprintf_length::call_info &info,\n+\t       const result_range &avail, const result_range &result)\n+{\n+  if (result.max <= avail.min)\n+    {\n+      /* The least amount of space remaining in the destination is big\n+\t enough for the longest output.  */\n+      return false;\n+    }\n+\n+  if (info.bounded)\n     {\n-      if (res.range.min < (unsigned HOST_WIDE_INT)dir.width)\n-\tres.range.min = dir.width;\n+      if (1 == warn_format_trunc && result.min <= avail.max\n+\t  && info.retval_used ())\n+\t{\n+\t  /* The likely amount of space remaining in the destination is big\n+\t     enough for the least output and the return value is used.  */\n+\t  return false;\n+\t}\n \n-      if (res.range.max < (unsigned HOST_WIDE_INT)dir.width)\n-\tres.range.max = dir.width;\n+      if (1 == warn_format_trunc && result.likely <= avail.likely\n+\t  && !info.retval_used ())\n+\t{\n+\t  /* The likely amount of space remaining in the destination is big\n+\t     enough for the likely output and the return value is unused.  */\n+\t  return false;\n+\t}\n \n-      /* Adjust BOUNDED if width happens to make them equal.  */\n-      if (res.range.min == res.range.max && res.range.min < target_int_max ()\n-\t  && bounded)\n-\tres.bounded = true;\n+      if (warn_format_trunc == 2\n+\t  && result.likely <= avail.min\n+\t  && (result.max <= avail.min\n+\t      || result.max > HOST_WIDE_INT_MAX))\n+\t{\n+\t  /* The minimum amount of space remaining in the destination is big\n+\t     enough for the longest output.  */\n+\t  return false;\n+\t}\n     }\n+  else\n+    {\n+      if (1 == warn_level && result.likely <= avail.likely)\n+\t{\n+\t  /* The likely amount of space remaining in the destination is big\n+\t     enough for the likely output.  */\n+\t  return false;\n+\t}\n \n-  /* When precision is specified the range of characters on output\n-     is known to be bounded by it.  */\n-  if (HOST_WIDE_INT_MIN != dir.width && -1 < dir.prec)\n-    res.knownrange = true;\n+      if (warn_level == 2\n+\t  && result.likely <= avail.min\n+\t  && (result.max <= avail.min\n+\t      || result.max > HOST_WIDE_INT_MAX))\n+\t{\n+\t  /* The minimum amount of space remaining in the destination is big\n+\t     enough for the longest output.  */\n+\t  return false;\n+\t}\n+    }\n \n-  return res;\n+  return true;\n }\n \n /* At format string location describe by DIRLOC in a call described\n@@ -1889,132 +2067,294 @@ format_string (const directive &dir, tree arg)\n static bool\n maybe_warn (substring_loc &dirloc, source_range *pargrange,\n \t    const pass_sprintf_length::call_info &info,\n-\t    unsigned HOST_WIDE_INT navail, const result_range &res,\n+\t    const result_range &avail_range, const result_range &res,\n \t    const directive &dir)\n {\n-  bool warned = false;\n+  if (!should_warn_p (info, avail_range, res))\n+    return false;\n \n-  if (res.min < res.max)\n+  /* A warning will definitely be issued below.  */\n+\n+  /* The maximum byte count to reference in the warning.  Larger counts\n+     imply that the upper bound is unknown (and could be anywhere between\n+     RES.MIN + 1 and SIZE_MAX / 2) are printed as \"N or more bytes\" rather\n+     than \"between N and X\" where X is some huge number.  */\n+  unsigned HOST_WIDE_INT maxbytes = target_dir_max ();\n+\n+  /* True when there is enough room in the destination for the least\n+     amount of a directive's output but not enough for its likely or\n+     maximum output.  */\n+  bool maybe = (res.min <= avail_range.max\n+\t\t&& (avail_range.min < res.likely\n+\t\t    || (res.max < HOST_WIDE_INT_MAX\n+\t\t\t&& avail_range.min < res.max)));\n+\n+  if (avail_range.min == avail_range.max)\n     {\n-      /* The result is a range (i.e., it's inexact).  */\n-      if (!warned)\n+      /* The size of the destination region is exact.  */\n+      unsigned HOST_WIDE_INT navail = avail_range.max;\n+\n+      if (*dir.beg != '%')\n \t{\n-\t  if (navail < res.min)\n-\t    {\n-\t      /* The minimum directive output is longer than there is\n-\t\t room in the destination.  */\n-\t      if (res.min == res.max)\n-\t\t{\n-\t\t  const char* fmtstr\n-\t\t    = (info.bounded\n-\t\t       ? G_(\"%<%.*s%> directive output truncated writing \"\n-\t\t\t    \"%wu bytes into a region of size %wu\")\n-\t\t       : G_(\"%<%.*s%> directive writing %wu bytes \"\n-\t\t\t    \"into a region of size %wu\"));\n-\t\t  warned = fmtwarn (dirloc, pargrange, NULL, info.warnopt (),\n-\t\t\t\t    fmtstr,\n-\t\t\t\t    (int)dir.len, dir.beg, res.min,\n-\t\t\t\t    navail);\n-\t\t}\n-\t      else if (res.max < HOST_WIDE_INT_MAX)\n-\t\t{\n-\t\t  const char* fmtstr\n-\t\t    = (info.bounded\n-\t\t       ? G_(\"%<%.*s%> directive output truncated writing \"\n-\t\t\t    \"between %wu and %wu bytes into a region of \"\n-\t\t\t    \"size %wu\")\n-\t\t       : G_(\"%<%.*s%> directive writing between %wu and \"\n-\t\t\t    \"%wu bytes into a region of size %wu\"));\n-\t\t  warned = fmtwarn (dirloc, pargrange, NULL,\n-\t\t\t\t    info.warnopt (), fmtstr,\n-\t\t\t\t    (int)dir.len, dir.beg,\n-\t\t\t\t    res.min, res.max, navail);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  const char* fmtstr\n-\t\t    = (info.bounded\n-\t\t       ? G_(\"%<%.*s%> directive output truncated writing \"\n-\t\t\t    \"%wu or more bytes into a region of size %wu\")\n-\t\t       : G_(\"%<%.*s%> directive writing %wu or more bytes \"\n-\t\t\t    \"into a region of size %wu\"));\n-\t\t  warned = fmtwarn (dirloc, pargrange, NULL,\n-\t\t\t\t    info.warnopt (), fmtstr,\n-\t\t\t\t    (int)dir.len, dir.beg,\n-\t\t\t\t    res.min, navail);\n-\t\t}\n-\t    }\n-\t  else if (navail < res.max\n-\t\t   && (dir.specifier != 's'\n-\t\t       || res.max < HOST_WIDE_INT_MAX)\n-\t\t   && ((info.bounded\n-\t\t\t&& (!info.retval_used ()\n-\t\t\t    || warn_level > 1))\n-\t\t       || (!info.bounded\n-\t\t\t   && (dir.specifier == 's'\n-\t\t\t       || warn_level > 1))))\n-\t    {\n-\t      /* The maximum directive output is longer than there is\n-\t\t room in the destination and the output length is either\n-\t\t explicitly constrained by the precision (for strings)\n-\t\t or the warning level is greater than 1.  */\n-\t      if (res.max >= HOST_WIDE_INT_MAX)\n-\t\t{\n-\t\t  const char* fmtstr\n-\t\t    = (info.bounded\n-\t\t       ? G_(\"%<%.*s%> directive output may be truncated \"\n-\t\t\t    \"writing %wu or more bytes into a region \"\n-\t\t\t    \"of size %wu\")\n-\t\t       : G_(\"%<%.*s%> directive writing %wu or more bytes \"\n-\t\t\t    \"into a region of size %wu\"));\n-\t\t  warned = fmtwarn (dirloc, pargrange, NULL,\n-\t\t\t\t    info.warnopt (), fmtstr,\n-\t\t\t\t    (int)dir.len, dir.beg,\n-\t\t\t\t    res.min, navail);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  const char* fmtstr\n-\t\t    = (info.bounded\n-\t\t       ? G_(\"%<%.*s%> directive output may be truncated \"\n-\t\t\t    \"writing between %wu and %wu bytes into a region \"\n-\t\t\t    \"of size %wu\")\n-\t\t       : G_(\"%<%.*s%> directive writing between %wu and %wu \"\n-\t\t\t    \"bytes into a region of size %wu\"));\n-\t\t  warned = fmtwarn (dirloc, pargrange, NULL,\n-\t\t\t\t    info.warnopt (), fmtstr,\n-\t\t\t\t    (int)dir.len, dir.beg,\n-\t\t\t\t    res.min, res.max,\n-\t\t\t\t    navail);\n-\t\t}\n-\t    }\n+\t  /* For plain character directives (i.e., the format string itself)\n+\t     but not others, point the caret at the first character that's\n+\t     past the end of the destination.  */\n+\t  dirloc.set_caret_index (dirloc.get_caret_idx () + navail);\n \t}\n-    }\n-  else\n-    {\n-      if (!warned && res.min > 0 && navail < res.min)\n+\n+      if (*dir.beg == '\\0')\n \t{\n-\t  const char* fmtstr\n+\t  /* This is the terminating nul.  */\n+\t  gcc_assert (res.min == 1 && res.min == res.max);\n+\n+\t  const char *fmtstr\n \t    = (info.bounded\n-\t       ? (1 < res.min\n-\t\t  ? G_(\"%<%.*s%> directive output truncated while writing \"\n-\t\t       \"%wu bytes into a region of size %wu\")\n-\t\t  : G_(\"%<%.*s%> directive output truncated while writing \"\n-\t\t       \"%wu byte into a region of size %wu\"))\n-\t       : (1 < res.min\n-\t\t  ? G_(\"%<%.*s%> directive writing %wu bytes \"\n-\t\t       \"into a region of size %wu\")\n+\t       ? (maybe\n+\t\t  ? G_(\"%qE output may be truncated before the last format \"\n+\t\t       \"character\")\n+\t\t  : G_(\"%qE output truncated before the last format character\"))\n+\t       : (maybe\n+\t\t  ? G_(\"%qE may write a terminating nul past the end \"\n+\t\t       \"of the destination\")\n+\t\t  : G_(\"%qE writing a terminating nul past the end \"\n+\t\t       \"of the destination\")));\n+\n+\t  return fmtwarn (dirloc, NULL, NULL, info.warnopt (), fmtstr,\n+\t\t\t  info.func);\n+\t}\n+\n+      if (res.min == res.max)\n+\t{\n+\t  const char* fmtstr\n+\t    = (res.min == 1\n+\t       ? (info.bounded\n+\t\t  ? (maybe\n+\t\t     ? G_(\"%<%.*s%> directive output may be truncated writing \"\n+\t\t\t  \"%wu byte into a region of size %wu\")\n+\t\t     : G_(\"%<%.*s%> directive output truncated writing \"\n+\t\t\t  \"%wu byte into a region of size %wu\"))\n \t\t  : G_(\"%<%.*s%> directive writing %wu byte \"\n+\t\t       \"into a region of size %wu\"))\n+\t       : (info.bounded\n+\t\t  ? (maybe\n+\t\t     ? G_(\"%<%.*s%> directive output may be truncated writing \"\n+\t\t\t  \"%wu bytes into a region of size %wu\")\n+\t\t     : G_(\"%<%.*s%> directive output truncated writing \"\n+\t\t\t  \"%wu bytes into a region of size %wu\"))\n+\t\t  : G_(\"%<%.*s%> directive writing %wu bytes \"\n \t\t       \"into a region of size %wu\")));\n+\t  return fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t  info.warnopt (), fmtstr,\n+\t\t\t  dir.len, dir.beg, res.min,\n+\t\t\t  navail);\n+\t}\n \n-\t  warned = fmtwarn (dirloc, pargrange, NULL,\n-\t\t\t    info.warnopt (), fmtstr,\n-\t\t\t    (int)dir.len, dir.beg, res.min,\n-\t\t\t    navail);\n+      if (0 == res.min && res.max < maxbytes)\n+\t{\n+\t  const char* fmtstr\n+\t    = (info.bounded\n+\t       ? (maybe\n+\t\t  ? G_(\"%<%.*s%> directive output may be truncated writing \"\n+\t\t       \"up to %wu bytes into a region of size %wu\")\n+\t\t  : G_(\"%<%.*s%> directive output truncated writing \"\n+\t\t       \"up to %wu bytes into a region of size %wu\"))\n+\t       : G_(\"%<%.*s%> directive writing up to %wu bytes \"\n+\t\t    \"into a region of size %wu\"));\n+\t  return fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t  info.warnopt (), fmtstr,\n+\t\t\t  dir.len, dir.beg,\n+\t\t\t  res.max, navail);\n \t}\n+\n+      if (0 == res.min && maxbytes <= res.max)\n+\t{\n+\t  /* This is a special case to avoid issuing the potentially\n+\t     confusing warning:\n+\t       writing 0 or more bytes into a region of size 0.  */\n+\t  const char* fmtstr\n+\t    = (info.bounded\n+\t       ? (maybe\n+\t\t  ? G_(\"%<%.*s%> directive output may be truncated writing \"\n+\t\t       \"likely %wu or more bytes into a region of size %wu\")\n+\t\t  : G_(\"%<%.*s%> directive output truncated writing \"\n+\t\t       \"likely %wu or more bytes into a region of size %wu\"))\n+\t       : G_(\"%<%.*s%> directive writing likely %wu or more bytes \"\n+\t\t    \"into a region of size %wu\"));\n+\t  return fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t  info.warnopt (), fmtstr,\n+\t\t\t  dir.len, dir.beg,\n+\t\t\t  res.likely, navail);\n+\t}\n+\n+      if (res.max < maxbytes)\n+\t{\n+\t  const char* fmtstr\n+\t    = (info.bounded\n+\t       ? (maybe\n+\t\t  ? G_(\"%<%.*s%> directive output may be truncated writing \"\n+\t\t       \"between %wu and %wu bytes into a region of size %wu\")\n+\t\t  : G_(\"%<%.*s%> directive output truncated writing \"\n+\t\t       \"between %wu and %wu bytes into a region of size %wu\"))\n+\t       : G_(\"%<%.*s%> directive writing between %wu and \"\n+\t\t    \"%wu bytes into a region of size %wu\"));\n+\t  return fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t  info.warnopt (), fmtstr,\n+\t\t\t  dir.len, dir.beg,\n+\t\t\t  res.min, res.max,\n+\t\t\t  navail);\n+\t}\n+\n+      const char* fmtstr\n+\t= (info.bounded\n+\t   ? (maybe\n+\t      ? G_(\"%<%.*s%> directive output may be truncated writing \"\n+\t\t   \"%wu or more bytes into a region of size %wu\")\n+\t      : G_(\"%<%.*s%> directive output truncated writing \"\n+\t\t   \"%wu or more bytes into a region of size %wu\"))\n+\t   : G_(\"%<%.*s%> directive writing %wu or more bytes \"\n+\t\t\"into a region of size %wu\"));\n+      return fmtwarn (dirloc, pargrange, NULL,\n+\t\t      info.warnopt (), fmtstr,\n+\t\t      dir.len, dir.beg,\n+\t\t      res.min, navail);\n     }\n \n-  return warned;\n+  /* The size of the destination region is a range.  */\n+\n+  if (*dir.beg != '%')\n+    {\n+      unsigned HOST_WIDE_INT navail = avail_range.max;\n+\n+      /* For plain character directives (i.e., the format string itself)\n+\t but not others, point the caret at the first character that's\n+\t past the end of the destination.  */\n+      dirloc.set_caret_index (dirloc.get_caret_idx () + navail);\n+    }\n+\n+  if (*dir.beg == '\\0')\n+    {\n+      gcc_assert (res.min == 1 && res.min == res.max);\n+\n+      const char *fmtstr\n+\t= (info.bounded\n+\t   ? (maybe\n+\t      ? G_(\"%qE output may be truncated before the last format \"\n+\t\t   \"character\")\n+\t      : G_(\"%qE output truncated before the last format character\"))\n+\t   : (maybe\n+\t      ? G_(\"%qE may write a terminating nul past the end \"\n+\t\t   \"of the destination\")\n+\t      : G_(\"%qE writing a terminating nul past the end \"\n+\t\t   \"of the destination\")));\n+\n+      return fmtwarn (dirloc, NULL, NULL, info.warnopt (), fmtstr,\n+\t\t      info.func);\n+    }\n+\n+  if (res.min == res.max)\n+    {\n+      const char* fmtstr\n+\t= (res.min == 1\n+\t   ? (info.bounded\n+\t      ? (maybe\n+\t\t ? G_(\"%<%.*s%> directive output may be truncated writing \"\n+\t\t      \"%wu byte into a region of size between %wu and %wu\")\n+\t\t : G_(\"%<%.*s%> directive output truncated writing \"\n+\t\t      \"%wu byte into a region of size between %wu and %wu\"))\n+\t      : G_(\"%<%.*s%> directive writing %wu byte \"\n+\t\t   \"into a region of size between %wu and %wu\"))\n+\t   : (info.bounded\n+\t      ? (maybe\n+\t\t ? G_(\"%<%.*s%> directive output may be truncated writing \"\n+\t\t      \"%wu bytes into a region of size between %wu and %wu\")\n+\t\t : G_(\"%<%.*s%> directive output truncated writing \"\n+\t\t      \"%wu bytes into a region of size between %wu and %wu\"))\n+\t      : G_(\"%<%.*s%> directive writing %wu bytes \"\n+\t\t   \"into a region of size between %wu and %wu\")));\n+\n+      return fmtwarn (dirloc, pargrange, NULL,\n+\t\t      info.warnopt (), fmtstr,\n+\t\t      dir.len, dir.beg, res.min,\n+\t\t      avail_range.min, avail_range.max);\n+    }\n+\n+  if (0 == res.min && res.max < maxbytes)\n+    {\n+      const char* fmtstr\n+\t= (info.bounded\n+\t   ? (maybe\n+\t      ? G_(\"%<%.*s%> directive output may be truncated writing \"\n+\t\t   \"up to %wu bytes into a region of size between \"\n+\t\t   \"%wu and %wu\")\n+\t      : G_(\"%<%.*s%> directive output truncated writing \"\n+\t\t   \"up to %wu bytes into a region of size between \"\n+\t\t   \"%wu and %wu\"))\n+\t   : G_(\"%<%.*s%> directive writing up to %wu bytes \"\n+\t\t\"into a region of size between %wu and %wu\"));\n+      return fmtwarn (dirloc, pargrange, NULL,\n+\t\t      info.warnopt (), fmtstr,\n+\t\t      dir.len, dir.beg, res.max,\n+\t\t      avail_range.min, avail_range.max);\n+    }\n+\n+  if (0 == res.min && maxbytes <= res.max)\n+    {\n+      /* This is a special case to avoid issuing the potentially confusing\n+\t warning:\n+\t   writing 0 or more bytes into a region of size between 0 and N.  */\n+      const char* fmtstr\n+\t= (info.bounded\n+\t   ? (maybe\n+\t      ? G_(\"%<%.*s%> directive output may be truncated writing \"\n+\t\t   \"likely %wu or more bytes into a region of size between \"\n+\t\t   \"%wu and %wu\")\n+\t      : G_(\"%<%.*s%> directive output truncated writing likely \"\n+\t\t   \"%wu or more bytes into a region of size between \"\n+\t\t   \"%wu and %wu\"))\n+\t   : G_(\"%<%.*s%> directive writing likely %wu or more bytes \"\n+\t\t\"into a region of size between %wu and %wu\"));\n+      return fmtwarn (dirloc, pargrange, NULL,\n+\t\t      info.warnopt (), fmtstr,\n+\t\t      dir.len, dir.beg, res.likely,\n+\t\t      avail_range.min, avail_range.max);\n+    }\n+\n+  if (res.max < maxbytes)\n+    {\n+      const char* fmtstr\n+\t= (info.bounded\n+\t   ? (maybe\n+\t      ? G_(\"%<%.*s%> directive output may be truncated writing \"\n+\t\t   \"between %wu and %wu bytes into a region of size \"\n+\t\t   \"between %wu and %wu\")\n+\t      : G_(\"%<%.*s%> directive output truncated writing \"\n+\t\t   \"between %wu and %wu bytes into a region of size \"\n+\t\t   \"between %wu and %wu\"))\n+\t   : G_(\"%<%.*s%> directive writing between %wu and \"\n+\t\t\"%wu bytes into a region of size between %wu and %wu\"));\n+      return fmtwarn (dirloc, pargrange, NULL,\n+\t\t      info.warnopt (), fmtstr,\n+\t\t      dir.len, dir.beg,\n+\t\t      res.min, res.max,\n+\t\t      avail_range.min, avail_range.max);\n+    }\n+\n+  const char* fmtstr\n+    = (info.bounded\n+       ? (maybe\n+\t  ? G_(\"%<%.*s%> directive output may be truncated writing \"\n+\t       \"%wu or more bytes into a region of size between \"\n+\t       \"%wu and %wu\")\n+\t  : G_(\"%<%.*s%> directive output truncated writing \"\n+\t       \"%wu or more bytes into a region of size between \"\n+\t       \"%wu and %wu\"))\n+       : G_(\"%<%.*s%> directive writing %wu or more bytes \"\n+\t    \"into a region of size between %wu and %wu\"));\n+  return fmtwarn (dirloc, pargrange, NULL,\n+\t\t  info.warnopt (), fmtstr,\n+\t\t  dir.len, dir.beg,\n+\t\t  res.min,\n+\t\t  avail_range.min, avail_range.max);\n }\n \n /* Compute the length of the output resulting from the conversion\n@@ -2053,16 +2393,12 @@ format_directive (const pass_sprintf_length::call_info &info,\n \n   /* Bail when there is no function to compute the output length,\n      or when minimum length checking has been disabled.   */\n-  if (!dir.fmtfunc || res->number_chars_min >= HOST_WIDE_INT_MAX)\n+  if (!dir.fmtfunc || res->range.min >= HOST_WIDE_INT_MAX)\n     return false;\n \n   /* Compute the (approximate) length of the formatted output.  */\n   fmtresult fmtres = dir.fmtfunc (dir, arg);\n \n-  /* The overall result is bounded only if the output of every directive\n-     is bounded.  */\n-  res->bounded &= fmtres.bounded;\n-\n   /* Record whether the output of all directives is known to be\n      bounded by some maximum, implying that their arguments are\n      either known exactly or determined to be in a known range\n@@ -2089,8 +2425,7 @@ format_directive (const pass_sprintf_length::call_info &info,\n \t     to determine the maximum number of characters (for example\n \t     for wide characters or wide character strings) but continue\n \t     tracking the minimum number of characters.  */\n-\t  res->number_chars_max = HOST_WIDE_INT_M1U;\n-\t  res->number_chars = HOST_WIDE_INT_M1U;\n+\t  res->range.max = HOST_WIDE_INT_M1U;\n \t}\n \n       if (fmtres.range.min > target_dir_max ())\n@@ -2099,56 +2434,67 @@ format_directive (const pass_sprintf_length::call_info &info,\n \t     even the minimum number of characters (it shouldn't happen\n \t     except in an error) but keep tracking the minimum and maximum\n \t     number of characters.  */\n-\t  res->number_chars = HOST_WIDE_INT_M1U;\n \t  return true;\n \t}\n     }\n \n+  int dirlen = dir.len;\n+\n   if (fmtres.nullp)\n     {\n       fmtwarn (dirloc, pargrange, NULL, info.warnopt (),\n \t       \"%<%.*s%> directive argument is null\",\n-\t       (int)cvtlen, cvtbeg);\n+\t       dirlen, dir.beg);\n \n       /* Don't bother processing the rest of the format string.  */\n       res->warned = true;\n-      res->number_chars = HOST_WIDE_INT_M1U;\n-      res->number_chars_min = res->number_chars_max = res->number_chars;\n+      res->range.min = HOST_WIDE_INT_M1U;\n+      res->range.max = HOST_WIDE_INT_M1U;\n       return false;\n     }\n \n   /* Compute the number of available bytes in the destination.  There\n      must always be at least one byte of space for the terminating\n      NUL that's appended after the format string has been processed.  */\n-  unsigned HOST_WIDE_INT navail = min_bytes_remaining (info.objsize, *res);\n+  result_range avail_range = bytes_remaining (info.objsize, *res);\n \n   bool warned = res->warned;\n \n   if (!warned)\n-    warned = maybe_warn (dirloc, pargrange, info, navail,\n+    warned = maybe_warn (dirloc, pargrange, info, avail_range,\n \t\t\t fmtres.range, dir);\n \n-  if (fmtres.range.min < fmtres.range.max)\n-    {\n-      /* Disable exact length checking but adjust the minimum and maximum.  */\n-      res->number_chars = HOST_WIDE_INT_M1U;\n-      if (res->number_chars_max < HOST_WIDE_INT_MAX\n-\t  && fmtres.range.max < HOST_WIDE_INT_MAX)\n-\tres->number_chars_max += fmtres.range.max;\n+  /* Bump up the total maximum if it isn't too big.  */\n+  if (res->range.max < HOST_WIDE_INT_MAX\n+      && fmtres.range.max < HOST_WIDE_INT_MAX)\n+    res->range.max += fmtres.range.max;\n \n-      res->number_chars_min += fmtres.range.min;\n-    }\n+  /* Raise the total unlikely maximum by the larger of the maximum\n+     and the unlikely maximum.  It doesn't matter if the unlikely\n+     maximum overflows.  */\n+  if (fmtres.range.max < fmtres.range.unlikely)\n+    res->range.unlikely += fmtres.range.unlikely;\n   else\n-      *res += fmtres.range.min;\n+    res->range.unlikely += fmtres.range.max;\n+\n+  res->range.min += fmtres.range.min;\n+  res->range.likely += fmtres.range.likely;\n \n   /* Has the minimum directive output length exceeded the maximum\n      of 4095 bytes required to be supported?  */\n   bool minunder4k = fmtres.range.min < 4096;\n-  if (!minunder4k || fmtres.range.max > 4095)\n+  bool maxunder4k = fmtres.range.max < 4096;\n+  /* Clear UNDER4K in the overall result if the maximum has exceeded\n+     the 4k (this is necessary to avoid the return valuye optimization\n+     that may not be safe in the maximum case).  */\n+  if (!maxunder4k)\n     res->under4k = false;\n \n-  if (!warned && warn_level > 1\n-      && (!minunder4k || fmtres.range.max > 4095))\n+  if (!warned\n+      /* Only warn at level 2.  */\n+      && 1 < warn_level\n+      && (!minunder4k\n+\t  || (!maxunder4k && fmtres.range.max < HOST_WIDE_INT_MAX)))\n     {\n       /* The directive output may be longer than the maximum required\n \t to be handled by an implementation according to 7.21.6.1, p15\n@@ -2162,30 +2508,35 @@ format_directive (const pass_sprintf_length::call_info &info,\n \t\t\t  info.warnopt (),\n \t\t\t  \"%<%.*s%> directive output of %wu bytes exceeds \"\n \t\t\t  \"minimum required size of 4095\",\n-\t\t\t  (int)cvtlen, cvtbeg, fmtres.range.min);\n+\t\t\t  dirlen, dir.beg, fmtres.range.min);\n       else\n \t{\n \t  const char *fmtstr\n \t    = (minunder4k\n-\t       ? G_(\"%<%.*s%> directive output between %qu and %wu \"\n+\t       ? G_(\"%<%.*s%> directive output between %wu and %wu \"\n \t\t    \"bytes may exceed minimum required size of 4095\")\n-\t       : G_(\"%<%.*s%> directive output between %qu and %wu \"\n+\t       : G_(\"%<%.*s%> directive output between %wu and %wu \"\n \t\t    \"bytes exceeds minimum required size of 4095\"));\n \n \t  warned = fmtwarn (dirloc, pargrange, NULL,\n \t\t\t    info.warnopt (), fmtstr,\n-\t\t\t    (int)cvtlen, cvtbeg,\n+\t\t\t    dirlen, dir.beg,\n \t\t\t    fmtres.range.min, fmtres.range.max);\n \t}\n     }\n \n   /* Has the minimum directive output length exceeded INT_MAX?  */\n-  bool exceedmin = res->number_chars_min > target_int_max ();\n+  /* Has the likely and maximum directive output exceeded INT_MAX?  */\n+  bool likelyximax = *dir.beg && res->range.likely > target_int_max ();\n+  bool maxximax = *dir.beg && res->range.max > target_int_max ();\n \n   if (!warned\n-      && (exceedmin\n-\t  || (warn_level > 1\n-\t      && res->number_chars_max > target_int_max ())))\n+      /* Warn for the likely output size at level 1.  */\n+      && (likelyximax\n+\t  /* But only warn for the maximum at level 2.  */\n+\t  || (1 < warn_level\n+\t      && maxximax\n+\t      && fmtres.range.max < HOST_WIDE_INT_MAX)))\n     {\n       /* The directive output causes the total length of output\n \t to exceed INT_MAX bytes.  */\n@@ -2194,22 +2545,32 @@ format_directive (const pass_sprintf_length::call_info &info,\n \twarned = fmtwarn (dirloc, pargrange, NULL, info.warnopt (),\n \t\t\t  \"%<%.*s%> directive output of %wu bytes causes \"\n \t\t\t  \"result to exceed %<INT_MAX%>\",\n-\t\t\t  (int)cvtlen, cvtbeg, fmtres.range.min);\n+\t\t\t  dirlen, dir.beg, fmtres.range.min);\n       else\n \t{\n \t  const char *fmtstr\n-\t    = (exceedmin\n+\t    = (fmtres.range.min > target_int_max ()\n \t       ? G_ (\"%<%.*s%> directive output between %wu and %wu \"\n \t\t     \"bytes causes result to exceed %<INT_MAX%>\")\n \t       : G_ (\"%<%.*s%> directive output between %wu and %wu \"\n \t\t     \"bytes may cause result to exceed %<INT_MAX%>\"));\n \t  warned = fmtwarn (dirloc, pargrange, NULL,\n \t\t\t    info.warnopt (), fmtstr,\n-\t\t\t    (int)cvtlen, cvtbeg,\n+\t\t\t    dirlen, dir.beg,\n \t\t\t    fmtres.range.min, fmtres.range.max);\n \t}\n     }\n \n+  if (warned && fmtres.range.min < fmtres.range.likely\n+      && fmtres.range.likely < fmtres.range.max)\n+    {\n+      inform (info.fmtloc,\n+\t      (1 == fmtres.range.likely\n+\t       ? G_(\"assuming directive output of %wu byte\")\n+\t       : G_(\"assuming directive output of %wu bytes\")),\n+\t      fmtres.range.likely);\n+    }\n+\n   if (warned && fmtres.argmin)\n     {\n       if (fmtres.argmin == fmtres.argmax)\n@@ -2225,217 +2586,54 @@ format_directive (const pass_sprintf_length::call_info &info,\n \n   res->warned |= warned;\n \n-  if (dump_file && *dir.beg)\n-    {\n-      fprintf (dump_file, \"    Result: %lli, %lli \"\n-\t       \"(%lli, %lli, %lli)\\n\",\n-\t       (long long)fmtres.range.min,\n-\t       (long long)fmtres.range.max,\n-\t       (long long)res->number_chars,\n-\t       (long long)res->number_chars_min,\n-\t       (long long)res->number_chars_max);\n-    }\n-\n-  return true;\n-}\n-\n-/* Account for the number of bytes between BEG and END (or between\n-   BEG + strlen (BEG) when END is null) in the format string in a call\n-   to a formatted output function described by INFO.  Reflect the count\n-   in RES and issue warnings as appropriate.  */\n-\n-static void\n-add_bytes (const pass_sprintf_length::call_info &info,\n-\t   const char *beg, const char *end, format_result *res)\n-{\n-  if (res->number_chars_min >= HOST_WIDE_INT_MAX)\n-    return;\n-\n-  /* The number of bytes to output is the number of bytes between\n-     the end of the last directive and the beginning of the next\n-     one if it exists, otherwise the number of characters remaining\n-     in the format string plus 1 for the terminating NUL.  */\n-  size_t nbytes = end ? end - beg : strlen (beg) + 1;\n-\n-  /* Return if there are no bytes to add at this time but there are\n-     directives remaining in the format string.  */\n-  if (!nbytes)\n-    return;\n-\n-  /* Compute the range of available bytes in the destination.  There\n-     must always be at least one byte left for the terminating NUL\n-     that's appended after the format string has been processed.  */\n-  result_range avail_range = bytes_remaining (info.objsize, *res);\n-\n-  /* If issuing a diagnostic (only when one hasn't already been issued),\n-     distinguish between a possible overflow (\"may write\") and a certain\n-     overflow somewhere \"past the end.\"  (Ditto for truncation.)\n-     KNOWNRANGE is used to warn even at level 1 about possibly writing\n-     past the end or truncation due to strings of unknown lengths that\n-     are bounded by the arrays they are known to refer to.  */\n-  if (!res->warned\n-      && (avail_range.max < nbytes\n-\t  || ((res->knownrange || warn_level > 1)\n-\t      && avail_range.min < nbytes)))\n-    {\n-      /* Set NAVAIL to the number of available bytes used to decide\n-\t whether or not to issue a warning below.  The exact kind of\n-\t warning will depend on AVAIL_RANGE.  */\n-      unsigned HOST_WIDE_INT navail = avail_range.max;\n-      if (nbytes <= navail && avail_range.min < HOST_WIDE_INT_MAX\n-\t  && (res->knownrange || warn_level > 1))\n-\tnavail = avail_range.min;\n-\n-      /* Compute the offset of the first format character that is beyond\n-\t the end of the destination region and the length of the rest of\n-\t the format string from that point on.  */\n-      unsigned HOST_WIDE_INT off\n-\t= (unsigned HOST_WIDE_INT)(beg - info.fmtstr) + navail;\n-\n-      size_t len = strlen (info.fmtstr + off);\n-\n-      /* Create a location that underscores the substring of the format\n-\t string that is or may be written past the end (or is or may be\n-\t truncated), pointing the caret at the first character of the\n-\t substring.  */\n-      substring_loc loc\n-\t(info.fmtloc, TREE_TYPE (info.format), off, len ? off : 0,\n-\t off + len - !!len);\n-\n-      /* Is the output of the last directive the result of the argument\n-\t being within a range whose lower bound would fit in the buffer\n-\t but the upper bound would not?  If so, use the word \"may\" to\n-\t indicate that the overflow/truncation may (but need not) happen.  */\n-      bool boundrange\n-\t= (res->number_chars_min < res->number_chars_max\n-\t   && res->number_chars_min + nbytes <= info.objsize);\n-\n-      if (!end && ((nbytes - navail) == 1 || boundrange))\n-\t{\n-\t  /* There is room for the rest of the format string but none\n-\t     for the terminating nul.  */\n-\t  const char *text\n-\t    = (info.bounded   // Snprintf and the like.\n-\t       ? (boundrange\n-\t\t  ? G_(\"output may be truncated before the last format character\"\n-\t\t       : \"output truncated before the last format character\"))\n-\t       : (boundrange\n-\t\t  ? G_(\"may write a terminating nul past the end \"\n-\t\t       \"of the destination\")\n-\t\t  : G_(\"writing a terminating nul past the end \"\n-\t\t       \"of the destination\")));\n-\n-\t  if (!info.bounded\n-\t      || !boundrange\n-\t      || !info.retval_used ()\n-\t      || warn_level > 1)\n-\t    res->warned = fmtwarn (loc, NULL, NULL, info.warnopt (), text);\n-\t}\n-      else\n-\t{\n-\t  /* There isn't enough room for 1 or more characters that remain\n-\t     to copy from the format string.  */\n-\t  const char *text\n-\t    = (info.bounded   // Snprintf and the like.\n-\t       ? (boundrange\n-\t\t  ? G_(\"output may be truncated at or before format character \"\n-\t\t       \"%qc at offset %wu\")\n-\t\t  : G_(\"output truncated at format character %qc at offset %wu\"))\n-\t       : (res->number_chars >= HOST_WIDE_INT_MAX\n-\t\t  ? G_(\"may write format character %#qc at offset %wu past \"\n-\t\t       \"the end of the destination\")\n-\t\t  : G_(\"writing format character %#qc at offset %wu past \"\n-\t\t       \"the end of the destination\")));\n-\n-\t  if (!info.bounded\n-\t      || !boundrange\n-\t      || !info.retval_used ()\n-\t      || warn_level > 1)\n-\t    res->warned = fmtwarn (loc, NULL, NULL, info.warnopt (),\n-\t\t\t\t   text, info.fmtstr[off], off);\n-\t}\n-    }\n-\n-  if (res->warned && !end && info.objsize < HOST_WIDE_INT_MAX)\n+  if (!dir.beg[0] && res->warned && info.objsize < HOST_WIDE_INT_MAX)\n     {\n       /* If a warning has been issued for buffer overflow or truncation\n \t (but not otherwise) help the user figure out how big a buffer\n \t they need.  */\n \n       location_t callloc = gimple_location (info.callstmt);\n \n-      unsigned HOST_WIDE_INT min = res->number_chars_min;\n-      unsigned HOST_WIDE_INT max = res->number_chars_max;\n-      unsigned HOST_WIDE_INT exact\n-\t= (res->number_chars < HOST_WIDE_INT_MAX\n-\t   ? res->number_chars : res->number_chars_min);\n+      unsigned HOST_WIDE_INT min = res->range.min;\n+      unsigned HOST_WIDE_INT max = res->range.max;\n \n-      if (min < max && max < HOST_WIDE_INT_MAX)\n+      if (min == max)\n+\tinform (callloc,\n+\t\t(min == 1\n+\t\t ? G_(\"%qE output %wu byte into a destination of size %wu\")\n+\t\t : G_(\"%qE output %wu bytes into a destination of size %wu\")),\n+\t\tinfo.func, min, info.objsize);\n+      else if (max < HOST_WIDE_INT_MAX)\n \tinform (callloc,\n-\t\t\"format output between %wu and %wu bytes into \"\n+\t\t\"%qE output between %wu and %wu bytes into \"\n \t\t\"a destination of size %wu\",\n-\t\tmin + nbytes, max + nbytes, info.objsize);\n+\t\tinfo.func, min, max, info.objsize);\n+      else if (min < res->range.likely && res->range.likely < max)\n+\tinform (callloc,\n+\t\t\"%qE output %wu or more bytes (assuming %wu) into \"\n+\t\t\"a destination of size %wu\",\n+\t\tinfo.func, min, res->range.likely, info.objsize);\n       else\n \tinform (callloc,\n-\t\t(nbytes + exact == 1\n-\t\t ? G_(\"format output %wu byte into a destination of size %wu\")\n-\t\t : G_(\"format output %wu bytes into a destination of size %wu\")),\n-\t\tnbytes + exact, info.objsize);\n+\t\t\"%qE output %wu or more bytes into a destination of size %wu\",\n+\t\tinfo.func, min, info.objsize);\n     }\n \n-  /* Add the number of bytes and then check for INT_MAX overflow.  */\n-  *res += nbytes;\n-\n-  /* Has the minimum output length minus the terminating nul exceeded\n-     INT_MAX?  */\n-  bool exceedmin = (res->number_chars_min - !end) > target_int_max ();\n-\n-  if (!res->warned\n-      && (exceedmin\n-\t  || (warn_level > 1\n-\t      && (res->number_chars_max - !end) > target_int_max ())))\n+  if (dump_file && *dir.beg)\n     {\n-      /* The function's output exceeds INT_MAX bytes.  */\n-\n-      /* Set NAVAIL to the number of available bytes used to decide\n-\t whether or not to issue a warning below.  The exact kind of\n-\t warning will depend on AVAIL_RANGE.  */\n-      unsigned HOST_WIDE_INT navail = avail_range.max;\n-      if (nbytes <= navail && avail_range.min < HOST_WIDE_INT_MAX\n-\t  && (res->bounded || warn_level > 1))\n-\tnavail = avail_range.min;\n-\n-      /* Compute the offset of the first format character that is beyond\n-\t the end of the destination region and the length of the rest of\n-\t the format string from that point on.  */\n-      unsigned HOST_WIDE_INT off = (unsigned HOST_WIDE_INT)(beg - info.fmtstr);\n-      if (navail < HOST_WIDE_INT_MAX)\n-\toff += navail;\n-\n-      size_t len = strlen (info.fmtstr + off);\n-\n-      substring_loc loc\n-\t(info.fmtloc, TREE_TYPE (info.format), off - !len, len ? off : 0,\n-\t off + len - !!len);\n-\n-      if (res->number_chars_min == res->number_chars_max)\n-\tres->warned = fmtwarn (loc, NULL, NULL, info.warnopt (),\n-\t\t\t       \"output of %wu bytes causes \"\n-\t\t\t       \"result to exceed %<INT_MAX%>\",\n-\t\t\t       res->number_chars_min - !end);\n-      else\n-\t{\n-\t  const char *text\n-\t    = (exceedmin\n-\t       ? G_ (\"output between %wu and %wu bytes causes \"\n-\t\t     \"result to exceed %<INT_MAX%>\")\n-\t       : G_ (\"output between %wu and %wu bytes may cause \"\n-\t\t     \"result to exceed %<INT_MAX%>\"));\n-\t  res->warned = fmtwarn (loc, NULL, NULL, info.warnopt (), text,\n-\t\t\t\t res->number_chars_min - !end,\n-\t\t\t\t res->number_chars_max - !end);\n-\t}\n+      fprintf (dump_file, \"    Result: %lli, %lli, %lli, %lli \"\n+\t       \"(%lli, %lli, %lli, %lli)\\n\",\n+\t       (long long)fmtres.range.min,\n+\t       (long long)fmtres.range.likely,\n+\t       (long long)fmtres.range.max,\n+\t       (long long)fmtres.range.unlikely,\n+\t       (long long)res->range.min,\n+\t       (long long)res->range.likely,\n+\t       (long long)res->range.max,\n+\t       (long long)res->range.unlikely);\n     }\n+\n+  return true;\n }\n \n #pragma GCC diagnostic pop\n@@ -2459,7 +2657,7 @@ parse_directive (pass_sprintf_length::call_info &info,\n \t (which isn't really a directive but it simplifies things to\n \t handle it as if it were).  */\n       dir.len = len;\n-      dir.fmtfunc = NULL;\n+      dir.fmtfunc = format_plain;\n \n       if (dump_file)\n \t{\n@@ -2686,7 +2884,7 @@ parse_directive (pass_sprintf_length::call_info &info,\n \t undefined prevent the result from being folded.  */\n     case '\\0':\n       --pf;\n-      res->bounded = false;\n+      res->range.min = res->range.max = HOST_WIDE_INT_M1U;\n       /* FALLTHRU */\n     case '%':\n       dir.fmtfunc = format_percent;\n@@ -2821,13 +3019,12 @@ pass_sprintf_length::compute_format_length (call_info &info,\n \t       (unsigned long long)info.objsize, info.fmtstr);\n     }\n \n-  /* Reset exact, minimum, and maximum character counters.  */\n-  res->number_chars = res->number_chars_min = res->number_chars_max = 0;\n+  /* Reset the minimum and maximum bytes counters.  */\n+  res->range.min = res->range.max = 0;\n \n   /* No directive has been seen yet so the length of output is bounded\n      by the known range [0, 0] (with no conversion producing more than\n      4K bytes) until determined otherwise.  */\n-  res->bounded = true;\n   res->knownrange = true;\n   res->under4k = true;\n   res->floating = false;\n@@ -2846,19 +3043,9 @@ pass_sprintf_length::compute_format_length (call_info &info,\n \n       size_t n = parse_directive (info, dir, res, pf, &argno);\n \n-      if (dir.fmtfunc)\n-\t{\n-\t  /* Return failure if the format function fails.  */\n-\t  if (!format_directive (info, res, dir))\n-\t    return false;\n-\t}\n-      else\n-\t{\n-\t  /* Add the number of bytes between the end of the last directive\n-\t     and either the next if one exists, or the end of the format\n-\t     string.  */\n-\t  add_bytes (info, pf, n ? pf + n : NULL, res);\n-\t}\n+      /* Return failure if the format function fails.  */\n+      if (!format_directive (info, res, dir))\n+\treturn false;\n \n       /* Return success the directive is zero bytes long and it's\n \t the last think in the format string (i.e., it's the terminating\n@@ -2870,7 +3057,7 @@ pass_sprintf_length::compute_format_length (call_info &info,\n       pf += n;\n     }\n \n-  /* Complete format string was processed (with or without warnings).  */\n+  /* The complete format string was processed (with or without warnings).  */\n   return true;\n }\n \n@@ -2888,7 +3075,6 @@ get_destination_size (tree dest)\n      a member array as opposed to the whole enclosing object), otherwise\n      use type-zero object size to determine the size of the enclosing\n      object (the function fails without optimization in this type).  */\n-\n   int ost = optimize > 0;\n   unsigned HOST_WIDE_INT size;\n   if (compute_builtin_object_size (dest, ost, &size))\n@@ -2910,19 +3096,19 @@ try_substitute_return_value (gimple_stmt_iterator *gsi,\n \t\t\t     const pass_sprintf_length::call_info &info,\n \t\t\t     const format_result &res)\n {\n-  if (!res.bounded)\n-    return false;\n-\n   tree lhs = gimple_get_lhs (info.callstmt);\n \n   /* Set to true when the entire call has been removed.  */\n   bool removed = false;\n \n-  /* The minumum return value.  */\n-  unsigned HOST_WIDE_INT minretval = res.number_chars_min;\n+  /* The minimum return value.  */\n+  unsigned HOST_WIDE_INT minretval = res.range.min;\n \n-  /* The maximum return value.  */\n-  unsigned HOST_WIDE_INT maxretval = res.number_chars_max;\n+  /* The maximum return value is in most cases bounded by RES.RANGE.MAX\n+     but in cases involving multibyte characters could be as large as\n+     RES.RANGE.UNLIKELY.  */\n+  unsigned HOST_WIDE_INT maxretval\n+    = res.range.unlikely < res.range.max ? res.range.max : res.range.unlikely;\n \n   /* Adjust the number of bytes which includes the terminating nul\n      to reflect the return value of the function which does not."}, {"sha": "a96fb1daa27ec0185a3429e0ee1cbbf666a5070c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5d93da1d112c93b38b6c68e3c51e20daefc01423", "patch": "@@ -1,3 +1,19 @@\n+2017-01-26  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/78703\n+\t* gcc.dg/format/pr78569.c: Adjust.\n+\t* gcc.dg/tree-ssa/builtin-snprintf-warn-2.c: Same.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-2.c: Same.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-5.c: Same.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-1.c: Same.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-2.c: Same.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-3.c: Same.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-4.c: Same.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-6.c: Same.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-7.c: Same.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-9.c: Same.\n+\t* gcc.dg/tree-ssa/builtin-sprintf.c: Same.\n+\n 2017-01-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/68727"}, {"sha": "db2e95497f19dcc8262a1d5417aa39077df4a0e7", "filename": "gcc/testsuite/gcc.dg/format/pr78569.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fpr78569.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fpr78569.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fpr78569.c?ref=5d93da1d112c93b38b6c68e3c51e20daefc01423", "patch": "@@ -20,5 +20,5 @@ void test (void)\n \t\t      \"channel uplink (see section 7.6.1).\");\n \n   /* { dg-warning \"output truncated\" \"\" { target *-*-* } 7 } */\n-  /* { dg-message \"format output\" \"\" { target *-*-* } 6 } */\n+  /* { dg-message \"output\" \"\" { target *-*-* } 6 } */\n }"}, {"sha": "54f3198257f6e1119d5d5438679bc7cc992f2169", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-snprintf-warn-2.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-warn-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-warn-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-warn-2.c?ref=5d93da1d112c93b38b6c68e3c51e20daefc01423", "patch": "@@ -4,6 +4,9 @@\n typedef struct\n {\n   char a0[0];\n+  /* Separate a0 from a1 to prevent the former from being substituted\n+     for the latter and causing false positives.  */\n+  int: 8;\n   char a1[1];\n   char a2[2];\n   char a3[3];\n@@ -39,7 +42,9 @@ void test_int_retval_unused (void)\n \n void test_string_retval_unused (const Arrays *ar)\n {\n-  T (1, \"%-s\", ar->a0);\n+  /* At level 2 strings of unknown length are assumed to be 1 character\n+     long, so the following is diagnosed.  */\n+  T (1, \"%-s\", ar->a0);   /* { dg-warning \"output may be truncated\" } */\n   T (1, \"%-s\", ar->a1);\n   T (1, \"%-s\", ar->a2);   /* { dg-warning \"output may be truncated\" } */\n }\n@@ -64,7 +69,7 @@ void test_int_retval_used (void)\n \n void test_string_retval_used (const Arrays *ar)\n {\n-  T (1, \"%-s\", ar->a0);\n+  T (1, \"%-s\", ar->a0);   /* { dg-warning \"output may be truncated\" } */\n   T (1, \"%-s\", ar->a1);\n   T (1, \"%-s\", ar->a2);   /* { dg-warning \"output may be truncated\" } */\n }"}, {"sha": "b873a0c443c52ca1b533c3f5577d1e03ad7eaf2a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-2.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-2.c?ref=5d93da1d112c93b38b6c68e3c51e20daefc01423", "patch": "@@ -59,15 +59,15 @@ void must_not_eliminate (void);\n \n typedef __SIZE_TYPE__ size_t;\n \n-extern int i;\n-extern unsigned u;\n-extern long li;\n-extern unsigned long lu;\n-extern size_t sz;\n-extern char *str;\n+volatile int i;\n+volatile unsigned u;\n+volatile long li;\n+volatile unsigned long lu;\n+volatile size_t sz;\n+volatile char *str;\n \n-extern double d;\n-extern long double ld;\n+volatile double d;\n+volatile long double ld;\n \n /* Verify that overflowing the destination object disables the return\n    value optimization.  */\n@@ -280,7 +280,8 @@ RNG (0,  6,   8, \"%s%ls\", \"1\", L\"2\");\n \n */\n \n-/*  Only conditional calls to abort should be made (with any probability):\n+/*  Only conditional calls to must_not_eliminate must be made (with\n+    any probability):\n     { dg-final { scan-tree-dump-times \"> \\\\\\[\\[0-9.\\]+%\\\\\\]:\\n *must_not_eliminate\" 124 \"optimized\" { target { ilp32 || lp64 } } } }\n     { dg-final { scan-tree-dump-times \"> \\\\\\[\\[0-9.\\]+%\\\\\\]:\\n *must_not_eliminate\" 93 \"optimized\" { target { { ! ilp32 } && { ! lp64 } } } } }\n     No unconditional calls to abort should be made:"}, {"sha": "e12aa2caa9a9ec7eb7452e4db9194817c71437a8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-5.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-5.c?ref=5d93da1d112c93b38b6c68e3c51e20daefc01423", "patch": "@@ -136,7 +136,6 @@ void test_arg_string (const char *s)\n \n void test_arg_multiarg (int i, double d)\n {\n-  EQL (16, \"%i %f %s\", 123, 3.14, \"abc\");\n   EQL (16, \"%12i %s\", i, \"abc\");\n   EQL (16, \"%*i %s\", 12, i, \"abc\");\n }"}, {"sha": "0f3d423d46e5aa5097a671ba3574f310d5728a12", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-1.c", "status": "modified", "additions": 173, "deletions": 129, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c?ref=5d93da1d112c93b38b6c68e3c51e20daefc01423", "patch": "@@ -11,21 +11,19 @@\n \n #define INT_MAX __INT_MAX__\n \n+typedef __builtin_va_list va_list;\n+\n+\n char buffer [256];\n extern char *ptr;\n \n-/* Evaluate to an array of SIZE characters when non-negative and LINE\n-   is not set or set to the line the macro is on, or to a pointer to\n-   an unknown object otherwise.  */\n-#define buffer(size)\t\t\t\t\t\t\t\\\n-  (0 <= size && (!LINE || __LINE__ == LINE)\t\t\t\t\\\n-   ? buffer + sizeof buffer - size : ptr)\n+/* Evaluate to an array of SIZE characters when non-negative, or to\n+   a pointer to an unknown object otherwise.  */\n+#define buffer(size)\t\t\t\t\t\\\n+  ((0 <= size) ? buffer + sizeof buffer - (size) : ptr)\n \n-/* Evaluate to SIZE when non-negative and LINE is not set or set to\n-   the line the macro is on, or to SIZE_MAX otherise.  */\n-#define objsize(size)\t\t\t\t\t\t\t\\\n-  (0 <= size && (!LINE || __LINE__ == LINE)\t\t\t\t\\\n-   ? size : __SIZE_MAX__)\n+/* Evaluate to SIZE when non-negative, or to SIZE_MAX otherise.  */\n+#define objsize(size) ((0 <= size) ? (size) : __SIZE_MAX__)\n \n typedef __SIZE_TYPE__ size_t;\n \n@@ -61,12 +59,26 @@ const char s8[] = \"12345678\";\n \n void sink (void*, ...);\n \n+int dummy_sprintf (char*, const char*, ...);\n+int dummy_snprintf (char*, size_t, const char*, ...);\n+int dummy_vsprintf (char*, const char*, va_list);\n+int dummy_vsnprintf (char*, size_t, const char*, va_list);\n+int dummy___sprintf_chk (char*, int, size_t, const char*, ...);\n+int dummy___snprintf_chk (char*, size_t, int, size_t, const char*, ...);\n+int dummy___vsprintf_chk (char*, int, size_t, const char*, va_list);\n+int dummy___vsnprintf_chk (char*, size_t, int, size_t, const char*, va_list);\n+\n+/* Helper to expand function to either __builtin_f or dummy_f to\n+   make debugging GCC easy.  */\n+#define FUNC(f)\t\t\t\t\t\t\t\\\n+  ((!LINE || LINE == __LINE__) ? __builtin_ ## f : dummy_ ## f)\n+\n /* Macro to verify that calls to __builtin_sprintf (i.e., with no size\n    argument) issue diagnostics by correctly determining the size of\n    the destination buffer.  */\n #define T(size, fmt, ...)\t\t\t\t\t\t\\\n-  __builtin_sprintf (buffer (size), fmt, __VA_ARGS__),\t\t\t\\\n-    sink (buffer, ptr);\n+  (FUNC (sprintf) (buffer (size), fmt, __VA_ARGS__),\t\t\t\\\n+   sink (buffer, ptr))\n \n /* Exercise the \"%c\" and \"%lc\" directive with constant arguments.  */\n \n@@ -109,19 +121,21 @@ void test_sprintf_flexarray (void *p, int i)\n   struct S\n   {\n     int n;\n-    char a [];\n+    char a[];\n   } *s = p;\n \n-  __builtin_sprintf (s->a, \"%c\",       'x');\n+  FUNC (sprintf)(s->a, \"%c\",       'x');\n \n-  __builtin_sprintf (s->a, \"%s\",       \"\");\n-  __builtin_sprintf (s->a, \"%s\",       \"abc\");\n-  __builtin_sprintf (s->a, \"abc%sghi\", \"def\");\n+  FUNC (sprintf)(s->a, \"%-s\",      \"\");\n+  FUNC (sprintf)(s->a, \"%-s\",      \"abc\");\n+  FUNC (sprintf)(s->a, \"abc%sghi\", \"def\");\n \n-  __builtin_sprintf (s->a, \"%i\",       1234);\n+  FUNC (sprintf)(s->a, \"%i\",       1234);\n \n-  __builtin_sprintf (buffer (1), \"%s\",  s->a);\n-  __builtin_sprintf (buffer (1), \"%s\",  s [i].a);\n+  FUNC (sprintf)(buffer (1), \"%-s\", s->a);\n+  FUNC (sprintf)(buffer (1), \"%-s\", s [i].a);\n+  FUNC (sprintf)(buffer (2), \"%-s\", s->a);\n+  FUNC (sprintf)(buffer (2), \"%-s\", s [i].a);\n }\n \n /* Same as above but for zero-length arrays.  */\n@@ -134,22 +148,22 @@ void test_sprintf_zero_length_array (void *p, int i)\n     char a [0];\n   } *s = p;\n \n-  __builtin_sprintf (s->a, \"%c\",       'x');\n+  FUNC (sprintf)(s->a, \"%c\",       'x');\n \n-  __builtin_sprintf (s->a, \"%s\",       \"\");\n-  __builtin_sprintf (s->a, \"%s\",       \"abc\");\n-  __builtin_sprintf (s->a, \"abc%sghi\", \"def\");\n+  FUNC (sprintf)(s->a, \"%s\",       \"\");\n+  FUNC (sprintf)(s->a, \"%s\",       \"abc\");\n+  FUNC (sprintf)(s->a, \"abc%sghi\", \"def\");\n \n-  __builtin_sprintf (s->a, \"%i\",       1234);\n+  FUNC (sprintf)(s->a, \"%i\",       1234);\n \n-  __builtin_sprintf (buffer (1), \"%s\",  s->a);\n-  __builtin_sprintf (buffer (1), \"%s\",  s [i].a);\n+  FUNC (sprintf)(buffer (1), \"%s\",  s->a);\n+  FUNC (sprintf)(buffer (1), \"%s\",  s [i].a);\n }\n \n #undef T\n-#define T(size, fmt, ...)\t\t\t\t\t  \\\n-  __builtin___sprintf_chk (buffer (size), 0, objsize (size), fmt, \\\n-\t\t\t   __VA_ARGS__), sink (buffer, ptr)\n+#define T(size, fmt, ...)\t\t\t\t\t\t\\\n+  (FUNC (__sprintf_chk) (buffer (size), 0, objsize (size), fmt, __VA_ARGS__), \\\n+   sink (buffer, ptr))\n \n /* Exercise the \"%c\" and \"%lc\" directive with constant arguments.  */\n \n@@ -286,6 +300,7 @@ void test_sprintf_chk_s_const (void)\n \n   T (2, \"_%s\",   \"\");\n   T (2, \"%%%s\",  \"\");\n+  T (2, \"%%%%%s\",  \"\");         /* { dg-warning \"nul past the end\" } */\n   T (2, \"%s%%\",  \"\");\n   T (2, \"_%s\",   \"1\");          /* { dg-warning \"nul past the end\" } */\n   T (2, \"%%%s\",  \"1\");          /* { dg-warning \"nul past the end\" } */\n@@ -317,7 +332,10 @@ void test_sprintf_chk_s_const (void)\n   T (1, \"%*ls\",  0, L\"\\0\");\n   T (1, \"%*ls\",  1, L\"\");       /* { dg-warning \"nul past the end\" } */\n \n-  T (1, \"%ls\",      L\"1\");      /* { dg-warning \"nul past the end\" } */\n+  /* A wide character string need not convert into any bytes (although\n+     individual ASCII characters are assumed to convert into 1 bt %lc\n+     so this could be made smarter.  */\n+  T (1, \"%ls\",      L\"1\");      /* { dg-warning \"directive writing up to 6 bytes into a region of size 1\" } */\n   T (1, \"%.0ls\",    L\"1\");\n   T (2, \"%.0ls\",    L\"1\");\n   T (2, \"%.1ls\",    L\"1\");\n@@ -333,9 +351,9 @@ void test_sprintf_chk_s_const (void)\n   T (3, \"%.0ls\",    L\"1\");\n   T (3, \"%.1ls\",    L\"1\");\n   T (3, \"%.2ls\",    L\"1\");\n-  T (3, \"%ls\",      L\"12\");\n+  T (3, \"%ls\",      L\"12\");     /* { dg-warning \"directive writing up to 12 bytes\" } */\n \n-  T (3, \"%ls\",      L\"123\");    /* { dg-warning \"nul past the end\" } */\n+  T (3, \"%ls\",      L\"123\");    /* { dg-warning \"directive writing up to 18 bytes\" } */\n   T (3, \"%.0ls\",    L\"123\");\n   T (3, \"%.1ls\",    L\"123\");\n   T (3, \"%.2ls\",    L\"123\");\n@@ -579,7 +597,7 @@ void test_sprintf_chk_integer_const (void)\n   T ( 1, \"%i\",          0);         /* { dg-warning \"nul past the end\" } */\n   T ( 1, \"%i\",          1);         /* { dg-warning \"nul past the end\" } */\n   T ( 1, \"%i\",         -1);         /* { dg-warning \"into a region\" } */\n-  T ( 1, \"%i_\",         1);         /* { dg-warning \"character ._. at offset 2 past the end\" } */\n+  T ( 1, \"%i_\",         1);         /* { dg-warning \" 1 byte into a region of size 0\" } */\n   T ( 1, \"_%i\",         1);         /* { dg-warning \"into a region\" } */\n   T ( 1, \"_%i_\",        1);         /* { dg-warning \"into a region\" } */\n   T ( 1, \"%o\",          0);         /* { dg-warning \"nul past the end\" } */\n@@ -596,7 +614,7 @@ void test_sprintf_chk_integer_const (void)\n   T ( 2, \"%i\",         10);         /* { dg-warning \"nul past the end\" } */\n   T ( 2, \"%i_\",         0);         /* { dg-warning \"nul past the end\" } */\n   T ( 2, \"_%i\",         0);         /* { dg-warning \"nul past the end\" } */\n-  T ( 2, \"_%i_\",        0);         /* { dg-warning \"character ._. at offset 3 past the end\" } */\n+  T ( 2, \"_%i_\",        0);         /* { dg-warning \" 1 byte into a region of size 0\" } */\n   T ( 2, \"%o\",          1);\n   T ( 2, \"%o\",          7);\n   T ( 2, \"%o\",        010);         /* { dg-warning \"nul past the end\" } */\n@@ -678,7 +696,7 @@ void test_sprintf_chk_j_const (void)\n   T ( 1, \"%ji\",  I (    0));      /* { dg-warning \"nul past the end\" } */\n   T ( 1, \"%ji\",  I (    1));      /* { dg-warning \"nul past the end\" } */\n   T ( 1, \"%ji\",  I (   -1));      /* { dg-warning \"into a region\" } */\n-  T ( 1, \"%ji_\", I (    1));      /* { dg-warning \"character ._. at offset 3 past the end\" } */\n+  T ( 1, \"%ji_\", I (    1));      /* { dg-warning \" 1 byte into a region of size 0\" } */\n   T ( 1, \"_%ji\", I (    1));      /* { dg-warning \"into a region\" } */\n   T ( 1, \"_%ji_\",I (    1));      /* { dg-warning \"into a region\" } */\n   T ( 1, \"%jo\",  I (    0));      /* { dg-warning \"nul past the end\" } */\n@@ -695,7 +713,7 @@ void test_sprintf_chk_j_const (void)\n   T ( 2, \"%ji\",  I (   10));      /* { dg-warning \"nul past the end\" } */\n   T ( 2, \"%ji_\", I (    0));      /* { dg-warning \"nul past the end\" } */\n   T ( 2, \"_%ji\", I (    0));      /* { dg-warning \"nul past the end\" } */\n-  T ( 2, \"_%ji_\",I (    0));      /* { dg-warning \"character ._. at offset 4 past the end\" } */\n+  T ( 2, \"_%ji_\",I (    0));      /* { dg-warning \" 1 byte into a region of size 0\" } */\n   T ( 2, \"%jo\",  I (    1));\n   T ( 2, \"%jo\",  I (    7));\n   T ( 2, \"%jo\",  I (  010));      /* { dg-warning \"nul past the end\" } */\n@@ -754,7 +772,7 @@ void test_sprintf_chk_l_const (void)\n   T ( 1, \"%li\",      0L);         /* { dg-warning \"nul past the end\" } */\n   T ( 1, \"%li\",      1L);         /* { dg-warning \"nul past the end\" } */\n   T ( 1, \"%li\",     -1L);         /* { dg-warning \"into a region\" } */\n-  T ( 1, \"%li_\",     1L);         /* { dg-warning \"character ._. at offset 3 past the end\" } */\n+  T ( 1, \"%li_\",     1L);         /* { dg-warning \" 1 byte into a region of size 0\" } */\n   T ( 1, \"_%li\",     1L);         /* { dg-warning \"into a region\" } */\n   T ( 1, \"_%li_\",    1L);         /* { dg-warning \"into a region\" } */\n   T ( 1, \"%lo\",      0L);         /* { dg-warning \"nul past the end\" } */\n@@ -771,7 +789,7 @@ void test_sprintf_chk_l_const (void)\n   T ( 2, \"%li\",     10L);         /* { dg-warning \"nul past the end\" } */\n   T ( 2, \"%li_\",     0L);         /* { dg-warning \"nul past the end\" } */\n   T ( 2, \"_%li\",     0L);         /* { dg-warning \"nul past the end\" } */\n-  T ( 2, \"_%li_\",    0L);         /* { dg-warning \"character ._. at offset 4 past the end\" } */\n+  T ( 2, \"_%li_\",    0L);         /* { dg-warning \" 1 byte into a region of size 0\" } */\n   T ( 2, \"%lo\",      1L);\n   T ( 2, \"%lo\",      7L);\n   T ( 2, \"%lo\",    010L);         /* { dg-warning \"nul past the end\" } */\n@@ -830,7 +848,7 @@ void test_sprintf_chk_ll_const (void)\n   T ( 1, \"%lli\",      0LL);     /* { dg-warning \"nul past the end\" } */\n   T ( 1, \"%lli\",      1LL);     /* { dg-warning \"nul past the end\" } */\n   T ( 1, \"%lli\",     -1LL);     /* { dg-warning \"into a region\" } */\n-  T ( 1, \"%lli_\",     1LL);     /* { dg-warning \"character ._. at offset 4 past the end\" } */\n+  T ( 1, \"%lli_\",     1LL);     /* { dg-warning \" 1 byte into a region of size 0 \" } */\n   T ( 1, \"_%lli\",     1LL);     /* { dg-warning \"into a region\" } */\n   T ( 1, \"_%lli_\",    1LL);     /* { dg-warning \"into a region\" } */\n   T ( 1, \"%llo\",      0LL);     /* { dg-warning \"nul past the end\" } */\n@@ -847,7 +865,7 @@ void test_sprintf_chk_ll_const (void)\n   T ( 2, \"%lli\",     10LL);     /* { dg-warning \"nul past the end\" } */\n   T ( 2, \"%lli_\",     0LL);     /* { dg-warning \"nul past the end\" } */\n   T ( 2, \"_%lli\",     0LL);     /* { dg-warning \"nul past the end\" } */\n-  T ( 2, \"_%lli_\",    0LL);     /* { dg-warning \"character ._. at offset 5 past the end\" } */\n+  T ( 2, \"_%lli_\",    0LL);     /* { dg-warning \" 1 byte into a region of size 0\" } */\n   T ( 2, \"%llo\",      1LL);\n   T ( 2, \"%llo\",      7LL);\n   T ( 2, \"%llo\",    010LL);     /* { dg-warning \"nul past the end\" } */\n@@ -909,7 +927,7 @@ void test_sprintf_chk_L_const (void)\n   T ( 1, \"%Li\",        0LL);         /* { dg-warning \"nul past the end\" } */\n   T ( 1, \"%Li\",        1LL);         /* { dg-warning \"nul past the end\" } */\n   T ( 1, \"%Li\",       -1LL);         /* { dg-warning \"into a region\" } */\n-  T ( 1, \"%Li_\",       1LL);         /* { dg-warning \"character ._. at offset 3 past the end\" } */\n+  T ( 1, \"%Li_\",       1LL);         /* { dg-warning \" 1 byte into a region of size 0\" } */\n   T ( 1, \"_%Li\",       1LL);         /* { dg-warning \"into a region\" } */\n   T ( 1, \"_%Li_\",      1LL);         /* { dg-warning \"into a region\" } */\n }\n@@ -920,7 +938,7 @@ void test_sprintf_chk_z_const (void)\n   T ( 1, \"%zi\",        (size_t)0);  /* { dg-warning \"nul past the end\" } */\n   T ( 1, \"%zi\",        (size_t)1);  /* { dg-warning \"nul past the end\" } */\n   T ( 1, \"%zi\",        (size_t)-1L);/* { dg-warning \"into a region\" } */\n-  T ( 1, \"%zi_\",       (size_t)1);  /* { dg-warning \"character ._. at offset 3 past the end\" } */\n+  T ( 1, \"%zi_\",       (size_t)1);  /* { dg-warning \" 1 byte into a region of size 0\" } */\n   T ( 1, \"_%zi\",       (size_t)1);  /* { dg-warning \"into a region\" } */\n   T ( 1, \"_%zi_\",      (size_t)1);  /* { dg-warning \"into a region\" } */\n \n@@ -942,16 +960,20 @@ void test_sprintf_chk_a_const (void)\n \n   /* The least number of bytes on output is 6 for \"0x0p+0\".  When precision\n      is missing the number of digits after the decimal point isn't fully\n-     specified by C (it seems like a defect).  */\n-  T (0, \"%a\",   0.0);         /* { dg-warning \"into a region\" } */\n-  T (0, \"%la\",  0.0);         /* { dg-warning \"into a region\" } */\n-  T (1, \"%a\",   0.0);         /* { dg-warning \"into a region\" } */\n-  T (2, \"%a\",   0.0);         /* { dg-warning \"into a region\" } */\n-  T (3, \"%a\",   0.0);         /* { dg-warning \"into a region\" } */\n-  T (4, \"%a\",   0.0);         /* { dg-warning \"into a region\" } */\n-  T (5, \"%a\",   0.0);         /* { dg-warning \"into a region\" } */\n-  T (6, \"%a\",   0.0);         /* { dg-warning \"writing a terminating nul\" } */\n-  T (7, \"%a\",   0.0);\n+     specified by C (a defect).  Two sets of implementations are known to\n+     exist: those that trim trailing zeros (e.g., Glibc) and those that\n+     pad output with trailing zeros so that all floating point numbers\n+     result in the same number of bytes on output (e.g., Solaris).  */\n+  T ( 0, \"%a\",   0.0);         /* { dg-warning \"writing between 6 and 20 bytes\" } */\n+  T ( 0, \"%la\",  0.0);         /* { dg-warning \"between 6 and 20 bytes\" } */\n+  T ( 1, \"%a\",   0.0);         /* { dg-warning \"between 6 and 20 bytes\" } */\n+  T ( 2, \"%a\",   0.0);         /* { dg-warning \"between 6 and 20 bytes\" } */\n+  T ( 3, \"%a\",   0.0);         /* { dg-warning \"between 6 and 20 bytes\" } */\n+  T ( 4, \"%a\",   0.0);         /* { dg-warning \"between 6 and 20 bytes\" } */\n+  T ( 5, \"%a\",   0.0);         /* { dg-warning \"between 6 and 20 bytes\" } */\n+  T ( 6, \"%a\",   0.0);         /* { dg-warning \"between 6 and 20 bytes\" } */\n+  T (19, \"%a\",   0.0);         /* { dg-warning \"between 6 and 20 bytes\" } */\n+  T (20, \"%a\",   0.0);         /* { dg-warning \"may write a terminating nul\" } */\n \n   T (0, \"%.a\",    0.0);       /* { dg-warning \"into a region\" } */\n   T (0, \"%.0a\",   0.0);       /* { dg-warning \"into a region\" } */\n@@ -1008,24 +1030,21 @@ void test_sprintf_chk_e_const (void)\n   T ( 6, \"%.e\",  1.0);\n   T ( 6, \"%.0e\", 1.0);\n \n-  /* The actual output of the following directives depends on the rounding\n-     mode.  Verify that the warning correctly reflects that.  At level 1,\n-     since the minimum number of bytes output by the directive fits the\n-     space the directive itself isn't diagnosed but the terminating nul\n-     is.  The directive is diagnosed at level 2.  */\n-  T (12, \"%e\",  9.999999e+99);  /* { dg-warning \"terminating nul\" } */\n-  T (12, \"%e\",  9.9999994e+99); /* { dg-warning \"terminating nul\" } */\n-  T (12, \"%e\",  9.9999995e+99); /* { dg-warning \"terminating nul\" } */\n-  T (12, \"%e\",  9.9999996e+99); /* { dg-warning \"terminating nul\" } */\n-  T (12, \"%e\",  9.9999997e+99); /* { dg-warning \"terminating nul\" } */\n-  T (12, \"%e\",  9.9999998e+99); /* { dg-warning \"terminating nul\" } */\n-\n-  T (12, \"%Le\", 9.9999994e+99L);/* { dg-warning \"terminating nul\" } */\n-  T (12, \"%Le\", 9.9999995e+99L);/* { dg-warning \"terminating nul\" } */\n-  T (12, \"%Le\", 9.9999996e+99L);/* { dg-warning \"terminating nul\" } */\n-  T (12, \"%Le\", 9.9999997e+99L);/* { dg-warning \"terminating nul\" } */\n-  T (12, \"%Le\", 9.9999998e+99L);/* { dg-warning \"terminating nul\" } */\n-  T (12, \"%Le\", 9.9999999e+99L);/* { dg-warning \"terminating nul\" } */\n+  /* The output of the following directives depends on the rounding\n+     mode.  */\n+  T (12, \"%e\",  9.999999e+99);  /* { dg-warning \"between 12 and 13\" } */\n+  T (12, \"%e\",  9.9999994e+99); /* { dg-warning \"between 12 and 13\" } */\n+  T (12, \"%e\",  9.9999995e+99); /* { dg-warning \"between 12 and 13\" } */\n+  T (12, \"%e\",  9.9999996e+99); /* { dg-warning \"between 12 and 13\" } */\n+  T (12, \"%e\",  9.9999997e+99); /* { dg-warning \"between 12 and 13\" } */\n+  T (12, \"%e\",  9.9999998e+99); /* { dg-warning \"between 12 and 13\" } */\n+\n+  T (12, \"%Le\", 9.9999994e+99L);/* { dg-warning \"between 12 and 13\" } */\n+  T (12, \"%Le\", 9.9999995e+99L);/* { dg-warning \"between 12 and 13\" } */\n+  T (12, \"%Le\", 9.9999996e+99L);/* { dg-warning \"between 12 and 13\" } */\n+  T (12, \"%Le\", 9.9999997e+99L);/* { dg-warning \"between 12 and 13\" } */\n+  T (12, \"%Le\", 9.9999998e+99L);/* { dg-warning \"between 12 and 13\" } */\n+  T (12, \"%Le\", 9.9999999e+99L);/* { dg-warning \"between 12 and 13\" } */\n }\n \n /* At -Wformat-overflow level 1 unknown numbers are assumed to have\n@@ -1035,21 +1054,32 @@ void test_sprintf_chk_e_const (void)\n void test_sprintf_chk_s_nonconst (int w, int p, const char *s)\n {\n   T (-1, \"%s\",   s);\n-  T ( 0, \"%s\",   s);            /* { dg-warning \"nul past the end\" } */\n+  T ( 0, \"%s\",   s);            /* { dg-warning \"writing a terminating nul\" } */\n   T ( 1, \"%s\",   s);\n+  T (-1, \"%.0s\", s);\n   T ( 1, \"%.0s\", s);\n-  T ( 1, \"%.1s\", s);            /* { dg-warning \"nul past the end\" } */\n+  T (-1, \"%.1s\", s);\n+  T ( 1, \"%.1s\", s);            /* { dg-warning \"may write a terminating nul past the end\" } */\n+  T (-1, \"%.2s\", s);\n+  T ( 1, \"%.2s\", s);            /* { dg-warning \"directive writing up to 2 bytes\" } */\n+  T ( 2, \"%.2s\", s);            /* { dg-warning \"may write a terminating nul\" } */\n+  T ( 3, \"%.2s\", s);\n \n   /* The string argument is constant but the width and/or precision\n      is not.  */\n-  T ( 1, \"%*s\",  w, \"\");\n-  T ( 1, \"%*s\",  w, \"1\");       /* { dg-warning \"nul past the end\" } */\n+  T (-1, \"%*s\",  w, \"\");\n+  T ( 1, \"%*s\",  w, \"\");        /* { dg-warning \"may write a terminating nul past the end\" } */\n+  T (-1, \"%*s\",  w, \"1\");\n+  T ( 1, \"%*s\",  w, \"1\");       /* { dg-warning \"writing a terminating nul past the end\" } */\n+  T (-1, \"%.*s\", p, \"\");\n   T ( 1, \"%.*s\", p, \"\");\n+  T (-1, \"%.*s\", p, \"1\");\n   T ( 1, \"%.*s\", p, \"1\");       /* { dg-warning \"may write a terminating nul\" } */\n-  T ( 1, \"%.*s\", w, \"123\");     /* { dg-warning \"writing between 0 and 3 bytes into a region of size 1\" } */\n+  T ( 1, \"%.*s\", w, \"123\");     /* { dg-warning \"writing up to 3 bytes into a region of size 1\" } */\n \n-  T ( 1, \"%*s\", w, \"123\");      /* { dg-warning \"writing 3 or more bytes into a region of size 1\" } */\n-  T ( 2, \"%*s\", w, \"123\");      /* { dg-warning \"writing 3 or more bytes into a region of size 2\" } */\n+  /* Either of the messages below is acceptable.  */\n+  T ( 1, \"%*s\", w, \"123\");      /* { dg-warning \"writing 3 or more bytes into a region of size 1|writing between 3 and 2147483648 bytes\" } */\n+  T ( 2, \"%*s\", w, \"123\");      /* { dg-warning \"writing 3 or more bytes into a region of size 2|writing between 3 and 2147483648 bytes\" } */\n   T ( 3, \"%*s\", w, \"123\");      /* { dg-warning \"writing a terminating nul past the end\" } */\n   T ( 4, \"%*s\", w, \"123\");\n \n@@ -1059,6 +1089,10 @@ void test_sprintf_chk_s_nonconst (int w, int p, const char *s)\n      the end (we don't print \"past the end\" when we're not\n      sure which we can't be with an unknown string.  */\n   T (1, \"%1s\",  s);             /* { dg-warning \"writing a terminating nul past the end\" } */\n+\n+  /* Multiple directives.  */\n+  T (1, \"%s%s\",    s, s);\n+  T (1, \"%s%s%s\", s, s, s);\n }\n \n /* Exercise the hh length modifier with all integer specifiers and\n@@ -1167,15 +1201,15 @@ void test_sprintf_chk_hh_nonconst (int w, int p, int a)\n   /* The argument is known but precision isn't.  When the argument\n      is zero only the first call can be diagnosed since a zero\n      precision would result in no bytes on output.  */\n-  T (0, \"%.*hhi\", p,   0);      /* { dg-warning \"nul past the end\" } */\n-  T (1, \"%.*hhi\", p,   0);\n+  T (0, \"%.*hhi\", p,   0);      /* { dg-warning \" writing up to \\[0-9\\]+ bytes\" } */\n+  T (1, \"%.*hhi\", p,   0);      /* { dg-warning \"may write a terminating nul\" }*/\n   T (2, \"%.*hhi\", p,   0);\n   T (2, \"%.*hhi\", p,  12);      /* { dg-warning \"nul past the end\" } */\n   T (2, \"%.*hhi\", p, 123);      /* { dg-warning \"into a region\" } */\n \n   /* The argument is known but neither width nor precision is.  */\n-  T (0, \"%*.*hhi\", w, p,   0);  /* { dg-warning \"nul past the end\" } */\n-  T (1, \"%*.*hhi\", w, p,   0);\n+  T (0, \"%*.*hhi\", w, p,   0);  /* { dg-warning \"writing up to \\[0-9\\]+ bytes\" } */\n+  T (1, \"%*.*hhi\", w, p,   0);  /* { dg-warning \"may write a terminating nul\" } */\n   T (2, \"%*.*hhi\", w, p,   0);\n   T (2, \"%*.*hhi\", w, p,  12);  /* { dg-warning \"nul past the end\" } */\n   T (2, \"%*.*hhi\", w, p, 123);  /* { dg-warning \"into a region\" } */\n@@ -1298,12 +1332,13 @@ void test_sprintf_chk_int_nonconst (int w, int p, int a)\n   T (3, \"%2u\",          a);\n   T (3, \"%2x\",          a);\n \n-  T (1, \"%.*d\",      p, a);\n+  T (1, \"%.*d\",      p, a);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%.*d\",      p, a);\n \n   T (4, \"%i %i\",        a, a);\n   /* The following will definitely be \"writing a terminating nul past the end\"\n      (i.e., not \"may write\".)  */\n-  T (4, \"%i %i \",       a, a);      /* { dg-warning \"writing a terminating nul past the end\" } */\n+  T (4, \"%i %i \",       a, a);      /* { dg-warning \"nul past the end\" } */\n   T (4, \"%i %i %i\",     a, a, a);   /* { dg-warning \"into a region\" }*/\n }\n \n@@ -1347,7 +1382,7 @@ void test_sprintf_chk_e_nonconst (int w, int p, double d)\n   T ( 8, \"%.1e\",        d);\n \n   T ( 0, \"%*e\",      0, d);           /* { dg-warning \"writing between 12 and 14 bytes into a region of size 0\" } */\n-  T ( 0, \"%*e\",      w, d);           /* { dg-warning \"writing 12 or more bytes into a region of size 0\" } */\n+  T ( 0, \"%*e\",      w, d);           /* { dg-warning \"writing 12 or more bytes into a region of size 0|writing between 12 and \\[0-9\\]+ bytes into a region of size 0\" } */\n }\n \n void test_sprintf_chk_f_nonconst (double d)\n@@ -1381,9 +1416,10 @@ void test_sprintf_chk_f_nonconst (double d)\n    __builtin_sprintf_chk with non-constant arguments.  */\n #undef T\n #define T(size, fmt)\t\t\t\t\t\t\t\\\n-  __builtin___vsprintf_chk (buffer (size), 0, objsize (size), fmt, va)\n+  (FUNC (__vsprintf_chk) (buffer (size), 0, objsize (size), fmt, va),\t\\\n+   sink (buffer))\n \n-void test_vsprintf_chk_c (__builtin_va_list va)\n+void test_vsprintf_chk_c (va_list va)\n {\n   T (-1, \"%c\");\n \n@@ -1399,26 +1435,25 @@ void test_vsprintf_chk_c (__builtin_va_list va)\n   T (3, \"%c%c\");\n \n   /* Wide characters.  */\n-  T (0, \"%lc\");             /* { dg-warning \"nul past the end\" } */\n-  T (1, \"%lc\");\n-  T (2, \"%lc\");\n+  T (0, \"%lc\");             /* { dg-warning \"up to 6 bytes \" } */\n+  T (1, \"%lc\");             /* { dg-warning \"up to 6 bytes \" } */\n+  T (2, \"%lc\");             /* { dg-warning \"may write a terminating nul\" } */\n \n   /* The following could result in as few as a single byte and in as many\n      as MB_CUR_MAX, but since the MB_CUR_MAX value is a runtime property\n      the write cannot be reliably diagnosed.  */\n-  T (2, \"%lc\");\n-  T (2, \"%1lc\");\n+  T (2, \"%1lc\");            /* { dg-warning \"may write a terminating nul\" } */\n   /* Writing some unknown number of bytes into a field two characters wide.  */\n   T (2, \"%2lc\");            /* { dg-warning \"nul past the end\" } */\n-  T (2, \"%lc%lc\");\n+  T (2, \"%lc%lc\");          /* { dg-warning \"writing up to 6 bytes into a region of size between 0 and 2\" } */\n \n-  T (3, \"%lc%c\");\n+  T (3, \"%lc%c\");           /* { dg-warning \"may write a terminating nul\" } */\n   /* Here in the best case each argument will format as single character,\n      causing the terminating NUL to be written past the end.  */\n-  T (3, \"%lc%c%c\");\n+  T (3, \"%lc%c%c\");         /* { dg-warning \"writing 1 byte into a region of size between 0 and 2\" } */\n }\n \n-void test_vsprintf_chk_int (__builtin_va_list va)\n+void test_vsprintf_chk_int (va_list va)\n {\n   T (-1, \"%d\");\n \n@@ -1462,8 +1497,9 @@ void test_vsprintf_chk_int (__builtin_va_list va)\n }\n \n #undef T\n-#define T(size, fmt, ...)\t\t\t\t\t\t\\\n-  __builtin_snprintf (buffer (size), objsize (size), fmt, __VA_ARGS__)\n+#define T(size, fmt, ...)\t\t\t\t\t      \\\n+  (FUNC (snprintf) (buffer (size), objsize (size), fmt, __VA_ARGS__), \\\n+   sink (buffer))\n \n void test_snprintf_c_const (char *d)\n {\n@@ -1498,24 +1534,27 @@ void test_snprintf_c_const (char *d)\n   T (2, \"%2lc\", (wint_t)L'1');          /* { dg-warning \"output truncated before the last format character\" } */\n \n   T (3, \"%lc%c\",   (wint_t)'1', '2');\n-  /* Here in the best case each argument will format as single character,\n-     causing the output to be truncated just before the terminating NUL\n-     (i.e., cutting off the '3').  */\n-  T (3, \"%lc%c%c\", (wint_t)'1', '2', '3');   /* { dg-warning \"output truncated\" } */\n-  T (3, \"%lc%lc%c\", (wint_t)'1', (wint_t)'2', '3'); /* { dg-warning \"output truncated\" } */\n+  /* Here %lc may result in anywhere between 0 and MB_CUR_MAX characters\n+     so the minimum number of bytes on output is 2 (plus the terminating\n+     nul), but the likely number is 3 (plus the nul).  */\n+  T (3, \"%lc%c%c\", (wint_t)'\\x80', '2', '3');  /* { dg-warning \".%c. directive output may be truncated writing 1 byte into a region of size between 0 and 2\" } */\n+  /* It's reasonably safe that L'1' converts into the single byte '1'.  */\n+  T (3, \"%lc%c%c\", (wint_t)'1', '2', '3');   /* { dg-warning \"output may be truncated\" } */\n+  T (3, \"%lc%lc%c\", (wint_t)'1', (wint_t)'2', '3'); /* { dg-warning \"output may be truncated\" } */\n }\n \n #undef T\n #define T(size, fmt, ...)\t\t\t\t\t\t\\\n-  __builtin___snprintf_chk (buffer (size), objsize (size),\t\t\\\n-\t\t\t    0, objsize (size), fmt, __VA_ARGS__)\n+  (FUNC (__snprintf_chk) (buffer (size), objsize (size),\t\t\\\n+\t\t\t  0, objsize (size), fmt, __VA_ARGS__),\t\t\\\n+   sink (buffer))\n \n void test_snprintf_chk_c_const (void)\n {\n   /* Verify that specifying a size of the destination buffer that's\n      bigger than its actual size (normally determined and passed to\n      the function by __builtin_object_size) is diagnosed.  */\n-  __builtin___snprintf_chk (buffer, 3, 0, 2, \" \");   /* { dg-warning \"specified bound 3 exceeds the size 2 of the destination\" } */\n+  FUNC (__snprintf_chk)(buffer, 3, 0, 2, \" \");   /* { dg-warning \"specified bound 3 exceeds the size 2 of the destination\" } */\n \n   T (-1, \"%c\",    0);           /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n \n@@ -1547,39 +1586,42 @@ void test_snprintf_chk_c_const (void)\n   T (2, \"%2lc\", (wint_t)'1');          /* { dg-warning \"output truncated before the last format character\" } */\n \n   T (3, \"%lc%c\",   (wint_t)'1', '2');\n-  /* Here in the best case each argument will format as single character,\n-     causing the output to be truncated just before the terminating NUL\n-     (i.e., cutting off the '3').  */\n-  T (3, \"%lc%c%c\", (wint_t)'1', '2', '3');   /* { dg-warning \"output truncated\" } */\n-  T (3, \"%lc%lc%c\", (wint_t)'1', (wint_t)'2', '3'); /* { dg-warning \"output truncated\" } */\n+  /* Here %lc may result in anywhere between 0 and MB_CUR_MAX characters\n+     so the minimum number of bytes on output is 2 (plus the terminating\n+     nul), but the likely number is 3 (plus the nul).  */\n+  T (3, \"%lc%c%c\", (wint_t)'1', '2', '3');   /* { dg-warning \"output may be truncated\" } */\n+  T (3, \"%lc%lc%c\", (wint_t)'1', (wint_t)'2', '3'); /* { dg-warning \"output may be truncated\" } */\n }\n \n /* Macro to verify that calls to __builtin_vsprintf (i.e., with no size\n    argument) issue diagnostics by correctly determining the size of\n    the destination buffer.  */\n #undef T\n #define T(size, fmt)\t\t\t\t\\\n-  __builtin_vsprintf (buffer (size), fmt, va)\n+  (FUNC (vsprintf) (buffer (size), fmt, va),\t\\\n+   sink (buffer))\n \n-void test_vsprintf_s (__builtin_va_list va)\n+void test_vsprintf_s (va_list va)\n {\n   T (-1, \"%s\");\n \n-  T (0, \"%s\");              /* { dg-warning \"writing a terminating nul past the end\" } */\n+  T (0, \"%s\");              /* { dg-warning \"writing a terminating nul\" } */\n   T (1, \"%s\");\n   T (1, \"%1s\");             /* { dg-warning \"writing a terminating nul past the end\" } */\n \n   T (2, \"%s%s\");\n-  T (2, \"%s%s_\");\n+  T (2, \"%s%s1\");\n+  T (2, \"%s%s12\");          /* { dg-warning \"writing a terminating nul\" } */\n+  T (2, \"%s%s123\");         /* { dg-warning \"writing 3 bytes into a region of size 2\" } */\n   T (2, \"%s_%s\");\n   T (2, \"_%s%s\");\n-  T (2, \"_%s_%s\");          /* { dg-warning \"writing a terminating nul past the end\" } */\n+  T (2, \"_%s_%s\");          /* { dg-warning \"writing a terminating nul\" } */\n }\n \n /* Exercise all integer specifiers with no modifier and a non-constant\n    argument.  */\n \n-void test_vsprintf_int (__builtin_va_list va)\n+void test_vsprintf_int (va_list va)\n {\n   T (-1, \"%d\");\n \n@@ -1623,10 +1665,11 @@ void test_vsprintf_int (__builtin_va_list va)\n }\n \n #undef T\n-#define T(size, fmt)\t\t\t\t\t\t\t\\\n-  __builtin_vsnprintf (buffer (size), objsize (size), fmt, va)\n+#define T(size, fmt)\t\t\t\t\t\t\\\n+  (FUNC (vsnprintf) (buffer (size), objsize (size), fmt, va),\t\\\n+   sink (buffer))\n \n-void test_vsnprintf_s (__builtin_va_list va)\n+void test_vsnprintf_s (va_list va)\n {\n   T (-1, \"%s\");             /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n \n@@ -1638,22 +1681,23 @@ void test_vsnprintf_s (__builtin_va_list va)\n   T (2, \"%s%s_\");\n   T (2, \"%s_%s\");\n   T (2, \"_%s%s\");\n-  T (2, \"_%s_%s\");          /* { dg-warning \"output truncated before the last format character\" } */\n+  T (2, \"_%s_%s\");          /* { dg-warning \"output truncated\" } */\n }\n \n #undef T\n-#define T(size, fmt)\t\t\t\t\t\t\t\\\n-  __builtin___vsnprintf_chk (buffer (size), objsize (size),\t\t\\\n-\t\t\t     0, objsize (size), fmt, va)\n+#define T(size, fmt)\t\t\t\t\t\\\n+  (FUNC (__vsnprintf_chk) (buffer (size), objsize (size),\t\\\n+\t\t\t   0, objsize (size), fmt, va),\t\t\\\n+   sink (buffer))\n \n-void test_vsnprintf_chk_s (__builtin_va_list va)\n+void test_vsnprintf_chk_s (va_list va)\n {\n   /* Verify that specifying a size of the destination buffer that's\n      bigger than its actual size (normally determined and passed to\n      the function by __builtin_object_size) is diagnosed.  */\n-  __builtin___vsnprintf_chk (buffer, 123, 0, 122, \"%-s\", va);   /* { dg-warning \"specified bound 123 exceeds the size 122 of the destination\" } */\n+  FUNC (__vsnprintf_chk)(buffer, 123, 0, 122, \"%-s\", va);   /* { dg-warning \"specified bound 123 exceeds the size 122 of the destination\" } */\n \n-  __builtin___vsnprintf_chk (buffer, __SIZE_MAX__, 0, 2, \"%-s\", va);   /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n+  FUNC (__vsnprintf_chk)(buffer, __SIZE_MAX__, 0, 2, \"%-s\", va);   /* { dg-warning \"specified bound \\[0-9\\]+ exceeds maximum object size \\[0-9\\]+\" } */\n \n   T (0, \"%s\");\n   T (1, \"%s\");\n@@ -1663,5 +1707,5 @@ void test_vsnprintf_chk_s (__builtin_va_list va)\n   T (2, \"%s%s_\");\n   T (2, \"%s_%s\");\n   T (2, \"_%s%s\");\n-  T (2, \"_%s_%s\");          /* { dg-warning \"output truncated before the last format character\" } */\n+  T (2, \"_%s_%s\");          /* { dg-warning \"output truncated\" } */\n }"}, {"sha": "f21dae4426a33bc762e4620ad515c41023d52505", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-2.c", "status": "modified", "additions": 45, "deletions": 30, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-2.c?ref=5d93da1d112c93b38b6c68e3c51e20daefc01423", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-std=c99 -Wformat -Wformat-overflow=2 -ftrack-macro-expansion=0\" } */\n+/* { dg-options \"-Wformat -Wformat-overflow=2 -ftrack-macro-expansion=0\" } */\n \n /* When debugging, define LINE to the line number of the test case to exercise\n    and avoid exercising any of the others.  The buffer and objsize macros\n@@ -47,12 +47,16 @@ void test_s_const (void)\n   T (1, \"%*ls\",  0, L\"\\0\");\n   T (1, \"%*ls\",  1, L\"\");       /* { dg-warning \"nul past the end\" } */\n \n-  T (1, \"%ls\",      L\"1\");      /* { dg-warning \"directive writing between 1 and 6 bytes into a region of size 1\" } */\n+  /* A wide character converts into between zero and MB_LEN_MAX bytes\n+     (although individual ASCII characters are assumed to convert into\n+     1 bt %lc so this could be made smarter.  */\n+  T (1, \"%ls\",      L\"1\");      /* { dg-warning \"directive writing up to 6 bytes into a region of size 1\" } */\n   T (1, \"%.0ls\",    L\"1\");\n   T (2, \"%.0ls\",    L\"1\");\n   T (2, \"%.1ls\",    L\"1\");\n   T (2, \"%.2ls\",    L\"1\");      /* { dg-warning \"nul past the end\" } */\n-  T (2, \"%.3ls\",    L\"1\");      /* { dg-warning \"directive writing between 1 and 3 bytes into a region of size 2\" } */\n+  T (2, \"%.3ls\",    L\"1\");      /* { dg-warning \"directive writing up to 3 bytes into a region of size 2\" } */\n+  T (2, \"%.7ls\",    L\"1\");      /* { dg-warning \"directive writing up to 6 bytes into a region of size 2\" } */\n   T (2, \"%.2ls\",    L\"12\");     /* { dg-warning \"nul past the end\" } */\n \n   /* The \"%.2ls\" directive below will write at a minimum 1 byte (because\n@@ -71,8 +75,8 @@ void test_s_const (void)\n   T (3, \"%.3ls\",    L\"12\");     /* { dg-warning \"nul past the end\" } */\n   T (4, \"%.3ls\",    L\"123\");\n   T (4, \"%.4ls\",    L\"123\");    /* { dg-warning \"nul past the end\" } */\n-  T (4, \"%.5ls\",    L\"123\");    /* { dg-warning \"directive writing between 3 and 5 bytes into a region of size 4\" } */\n-  T (4, \"%.6ls\",    L\"123\");    /* { dg-warning \"directive writing between 3 and 6 bytes into a region of size 4\" } */\n+  T (4, \"%.5ls\",    L\"123\");    /* { dg-warning \"directive writing up to 5 bytes into a region of size 4\" } */\n+  T (4, \"%.6ls\",    L\"123\");    /* { dg-warning \"directive writing up to 6 bytes into a region of size 4\" } */\n }\n \n \n@@ -87,37 +91,48 @@ struct Arrays {\n \n /* Exercise buffer overflow detection with non-const string arguments.  */\n \n-void test_s_nonconst (const char *s, const wchar_t *ws, struct Arrays *a)\n+void test_s_nonconst (int w, int p, const char *s, const wchar_t *ws,\n+\t\t      struct Arrays *a)\n {\n   T (0, \"%s\",   s);             /* { dg-warning \"into a region\" \"sprintf transformed into strcpy\" { xfail *-*-* } } */\n   T (1, \"%s\",   s);             /* { dg-warning \"nul past the end\" \"sprintf transformed into strcpy\" { xfail *-*-* } } */\n-  T (1, \"%1s\",  s);             /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%1s\",  s);             /* { dg-warning \"writing a terminating nul\" } */\n   T (1, \"%.0s\", s);\n   T (1, \"%.1s\", s);             /* { dg-warning \"may write a terminating nul\" } */\n+  T (1, \"%*s\", 0, s);           /* { dg-warning \"may write a terminating nul\" } */\n+  T (1, \"%*s\", 1, s);           /* { dg-warning \"writing a terminating nul\" } */\n+  T (1, \"%*s\", 2, s);           /* { dg-warning \"directive writing 2 or more bytes\" } */\n+  T (1, \"%*s\", 3, s);           /* { dg-warning \"directive writing 3 or more bytes\" } */\n+\n+  T (1, \"%.*s\", 1, s);          /* { dg-warning \"may write a terminating nul\" } */\n+  T (1, \"%.*s\", 2, s);          /* { dg-warning \"writing up to 2 bytes\" } */\n+  T (1, \"%.*s\", 3, s);          /* { dg-warning \"writing up to 3 bytes\" } */\n \n   T (1, \"%.0ls\",  ws);\n   T (1, \"%.1ls\",  ws);          /* { dg-warning \"may write a terminating nul\" } */\n-  T (1, \"%ls\",    ws);          /* { dg-warning \"writing a terminating nul\" } */\n+  T (1, \"%ls\",    ws);          /* { dg-warning \"may write a terminating nul\" } */\n \n   /* Verify that the size of the array is used in lieu of its length.\n-     The minus sign disables GCC's sprintf to strcpy transformation.  */\n-  T (1, \"%-s\", a->a1);          /* { dg-warning \"nul past the end\" } */\n+     The minus sign disables GCC's sprintf to strcpy transformation.\n+     In the case below, the length of s->a1 can be at most zero, so\n+     the call should not be diagnosed.  */\n+  T (1, \"%-s\", a->a1);\n \n   /* In the following test, since the length of the strings isn't known,\n      their type (the array) is used to bound the maximum length to 1,\n      which means the \"%-s\" directive would not overflow the buffer,\n      but it would leave no room for the terminating nul.  */\n-  T (1, \"%-s\", a->a2);          /* { dg-warning \"writing a terminating nul\" } */\n+  T (1, \"%-s\", a->a2);          /* { dg-warning \"may write a terminating nul\" } */\n \n   /* Unlike in the test above, since the length of the string is bounded\n      by the array type to at most 2, the \"^-s\" directive is diagnosed firts,\n      preventing the diagnostic about the terminatinb nul.  */\n-  T (1, \"%-s\", a->a3);          /* { dg-warning \"directive writing between 1 and 2 bytes\" } */\n+  T (1, \"%-s\", a->a3);          /* { dg-warning \"directive writing up to 2 bytes\" } */\n \n   /* The length of a zero length array and flexible array member is\n      unknown and at leve 2 assumed to be at least 1.  */\n-  T (1, \"%-s\", a->a0);          /* { dg-warning \"nul past the end\" } */\n-  T (1, \"%-s\", a->ax);          /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%-s\", a->a0);          /* { dg-warning \"may write a terminating nul\" } */\n+  T (1, \"%-s\", a->ax);          /* { dg-warning \"may write a terminating nul\" } */\n \n   T (2, \"%-s\", a->a0);\n   T (2, \"%-s\", a->ax);\n@@ -145,20 +160,20 @@ void test_hh_nonconst (int w, int p, int x, unsigned y)\n \n   /* Zero precision means that zero argument formats as no bytes unless\n      length or flags make it otherwise.  */\n-  T (1, \"%.*hhi\",    0, x);     /* { dg-warning \"between 0 and 4 bytes\" } */\n-  T (2, \"%.*hhi\",    0, x);     /* { dg-warning \"between 0 and 4 bytes\" } */\n-  T (3, \"%.*hhi\",    0, x);     /* { dg-warning \"between 0 and 4 bytes\" } */\n+  T (1, \"%.*hhi\",    0, x);     /* { dg-warning \"writing up to 4 bytes\" } */\n+  T (2, \"%.*hhi\",    0, x);     /* { dg-warning \"writing up to 4 bytes\" } */\n+  T (3, \"%.*hhi\",    0, x);     /* { dg-warning \"writing up to 4 bytes\" } */\n   T (4, \"%.*hhi\",    0, x);     /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n \n-  T (1, \"%.*hhi\",    0, y);     /* { dg-warning \"between 0 and 4 bytes\" } */\n-  T (2, \"%.*hhi\",    0, y);     /* { dg-warning \"between 0 and 4 bytes\" } */\n-  T (3, \"%.*hhi\",    0, y);     /* { dg-warning \"between 0 and 4 bytes\" } */\n+  T (1, \"%.*hhi\",    0, y);     /* { dg-warning \"writing up to 4 bytes\" } */\n+  T (2, \"%.*hhi\",    0, y);     /* { dg-warning \"writing up to 4 bytes\" } */\n+  T (3, \"%.*hhi\",    0, y);     /* { dg-warning \"writing up to 4 bytes\" } */\n   T (4, \"%.*hhi\",    0, y);     /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n \n-  T (1, \"%#.*hhi\",    0, y);    /* { dg-warning \"between 0 and 4 bytes\" } */\n+  T (1, \"%#.*hhi\",    0, y);    /* { dg-warning \"writing up to 4 bytes\" } */\n   /* { dg-warning \".#. flag used\" \"-Wformat\" { target *-*-* } .-1 } */\n   T (1, \"%+.*hhi\",    0, y);    /* { dg-warning \"between 1 and 4 bytes\" } */\n-  T (1, \"%-.*hhi\",    0, y);    /* { dg-warning \"between 0 and 4 bytes\" } */\n+  T (1, \"%-.*hhi\",    0, y);    /* { dg-warning \"writing up to 4 bytes\" } */\n   T (1, \"% .*hhi\",    0, y);    /* { dg-warning \"between 1 and 4 bytes\" } */\n \n   T (1, \"%#.*hhi\",    1, y);    /* { dg-warning \"between 1 and 4 bytes\" } */\n@@ -167,18 +182,18 @@ void test_hh_nonconst (int w, int p, int x, unsigned y)\n   T (1, \"%-.*hhi\",    1, y);    /* { dg-warning \"between 1 and 4 bytes\" } */\n   T (1, \"% .*hhi\",    1, y);    /* { dg-warning \"between 2 and 4 bytes\" } */\n \n-  T (1, \"%#.*hhi\",    p, y);    /* { dg-warning \"writing 0 or more bytes\" } */\n+  T (1, \"%#.*hhi\",    p, y);    /* { dg-warning \"writing up to \\[0-9\\]+ bytes\" } */\n   /* { dg-warning \".#. flag used\" \"-Wformat\" { target *-*-* } .-1 } */\n-  T (1, \"%+.*hhi\",    p, y);    /* { dg-warning \"writing 1 or more bytes\" } */\n-  T (1, \"%-.*hhi\",    p, y);    /* { dg-warning \"writing 0 or more bytes\" } */\n-  T (1, \"% .*hhi\",    p, y);    /* { dg-warning \"writing 1 or more bytes\" } */\n+  T (1, \"%+.*hhi\",    p, y);    /* { dg-warning \"writing 1 or more bytes|writing between 1 and \\[0-9\\]+ bytes\" } */\n+  T (1, \"%-.*hhi\",    p, y);    /* { dg-warning \"writing up to \\[0-9\\]+ bytes\" } */\n+  T (1, \"% .*hhi\",    p, y);    /* { dg-warning \"writing between 1 and \\[0-9\\]+ bytes|writing 1 or more bytes\" } */\n \n-  T (1, \"%#.*hhu\",    0, y);    /* { dg-warning \"between 0 and 3 bytes\" } */\n+  T (1, \"%#.*hhu\",    0, y);    /* { dg-warning \"writing up to 3 bytes\" } */\n   /* { dg-warning \".#. flag used\" \"-Wformat\" { target *-*-* } .-1 } */\n-  T (1, \"%+.*hhu\",    0, y);    /* { dg-warning \"between 0 and 3 bytes\" } */\n+  T (1, \"%+.*hhu\",    0, y);    /* { dg-warning \"writing up to 3 bytes\" } */\n   /* { dg-warning \".\\\\+. flag used\" \"-Wformat\" { target *-*-* } .-1 } */\n-  T (1, \"%-.*hhu\",    0, y);    /* { dg-warning \"between 0 and 3 bytes\" } */\n-  T (1, \"% .*hhu\",    0, y);    /* { dg-warning \"between 0 and 3 bytes\" } */\n+  T (1, \"%-.*hhu\",    0, y);    /* { dg-warning \"writing up to 3 bytes\" } */\n+  T (1, \"% .*hhu\",    0, y);    /* { dg-warning \"writing up to 3 bytes\" } */\n   /* { dg-warning \". . flag used\" \"-Wformat\" { target *-*-* } .-1 } */\n }\n "}, {"sha": "373cb5ef423197b009d1de91959d5bf8fa568839", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-3.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c?ref=5d93da1d112c93b38b6c68e3c51e20daefc01423", "patch": "@@ -60,6 +60,9 @@ void test_sprintf_chk_string (const char *s, const char *t)\n   T (1, \"%s\", x ? \"1\" : \"\");       /* { dg-warning \"nul past the end\" } */\n   T (1, \"%s\", x ? s : \"1\");        /* { dg-warning \"nul past the end\" } */\n   T (1, \"%s\", x ? \"1\" : s);        /* { dg-warning \"nul past the end\" } */\n+\n+  /* When neither string is known no warning should be issued at level 1\n+     since their lenghts are assumed to be zero.  */\n   T (1, \"%s\", x ? s : t);\n \n   T (2, \"%s\", x ? \"\" : \"1\");\n@@ -85,7 +88,7 @@ void test_sprintf_chk_integer_value (void)\n   T ( 1, \"%i\",  i (    0));         /* { dg-warning \"nul past the end\" } */\n   T ( 1, \"%i\",  i (    1));         /* { dg-warning \"nul past the end\" } */\n   T ( 1, \"%i\",  i (   -1));         /* { dg-warning \"into a region\" } */\n-  T ( 1, \"%i_\", i (    1));         /* { dg-warning \"character ._. at offset 2 past the end\" } */\n+  T ( 1, \"%i_\", i (    1));         /* { dg-warning \" 1 byte into a region of size 0\" } */\n   T ( 1, \"_%i\", i (    1));         /* { dg-warning \"into a region\" } */\n   T ( 1, \"_%i_\",i (    1));         /* { dg-warning \"into a region\" } */\n   T ( 1, \"%o\",  i (    0));         /* { dg-warning \"nul past the end\" } */\n@@ -102,7 +105,7 @@ void test_sprintf_chk_integer_value (void)\n   T ( 2, \"%i\",  i (   10));         /* { dg-warning \"nul past the end\" } */\n   T ( 2, \"%i_\", i (    0));         /* { dg-warning \"nul past the end\" } */\n   T ( 2, \"_%i\", i (    0));         /* { dg-warning \"nul past the end\" } */\n-  T ( 2, \"_%i_\",i (    0));         /* { dg-warning \"character ._. at offset 3 past the end\" } */\n+  T ( 2, \"_%i_\",i (    0));         /* { dg-warning \" 1 byte into a region of size 0\" } */\n   T ( 2, \"%o\",  i (    1));\n   T ( 2, \"%o\",  i (    7));\n   T ( 2, \"%o\",  i (  010));         /* { dg-warning \"nul past the end\" } */\n@@ -211,10 +214,10 @@ void test_sprintf_chk_range_schar (void)\n   T ( 3, \"%i\",  R (  0,  99));\n   T ( 3, \"%i\",  R (  0, 100));  /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n \n-  /* The following call may write as few as 3 bytes and as many as 5.\n+  /* The following call may write as few as 2 bytes and as many as 4.\n      It's a judgment call how best to diagnose it to make the potential\n      problem clear.  */\n-  T ( 3, \"%i%i\", R (1, 10), R (9, 10));   /* { dg-warning \"may write a terminating nul past the end|.%i. directive writing between 1 and 2 bytes into a region of size 1\" } */\n+  T ( 3, \"%i%i\", R (1, 10), R (9, 10));   /* { dg-warning \"directive writing between 1 and 2 bytes into a region of size between 1 and 2\" } */\n \n   T ( 4, \"%i%i\", R (10, 11), R (12, 13));   /* { dg-warning \"nul past the end\" } */\n \n@@ -224,7 +227,11 @@ void test_sprintf_chk_range_schar (void)\n   T ( 6, \"%i_%i_%i\", R (0, 9), R (0, 9), R (0, 10));  /* { dg-warning \"may write a terminating nul past the end\" } */\n   T ( 6, \"%i_%i_%i\", R (0, 9), R (0, 10), R (0, 9));  /* { dg-warning \"may write a terminating nul past the end\" } */\n   T ( 6, \"%i_%i_%i\", R (0, 10), R (0, 9), R (0, 9));  /* { dg-warning \"may write a terminating nul past the end\" } */\n-  T ( 6, \"%i_%i_%i\", R (0, 9), R (0, 10), R (0, 10)); /* { dg-warning \"may write a terminating nul past the end|.%i. directive writing between 1 and 2 bytes into a region of size 1\" } */\n+  T ( 6, \"%hhi_%hi_%i\", R (0, 9), R (0, 10), R (0, 10)); /* { dg-warning \".i. directive writing between 1 and 2 bytes into a region of size between 1 and 2\" } */\n+  T ( 6, \"%3i|%2i/%1i\", R (0, 99), R (0, 99), R (0, 99)); /* { dg-warning \"./. directive writing 1 byte into a region of size 0\" } */\n+  T ( 6, \"%.3i|%.2i/%i\", R (0, 99), R (0, 99), R (0, 99)); /* { dg-warning \"./. directive writing 1 byte into a region of size 0\" } */\n+  T ( 6, \"%.3i|%.2i/%i\", R (0, 119), R (0, 99), R (0, 99)); /* { dg-warning \"./. directive writing 1 byte into a region of size 0\" } */\n+  T ( 6, \"%.3i|%.2i/%i\", R (0, 1), R (0, 2), R (0, 3)); /* { dg-warning \"./. directive writing 1 byte into a region of size 0\" } */\n }\n \n void test_sprintf_chk_range_uchar (void)"}, {"sha": "abf6e329dc3ac5a68126970a5006c2359594b708", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-4.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-4.c?ref=5d93da1d112c93b38b6c68e3c51e20daefc01423", "patch": "@@ -12,14 +12,14 @@ void test (void)\n      The redundant argument is there to get around GCC bug 77799.  */\n   sprintf (dst + 2, \"1\", 0);\n   /* { dg-warning \"writing a terminating nul past the end of the destination\" \"nul warning\" { target *-*-* } .-1 }\n-     { dg-message \"format output 2 bytes into a destination of size 1\" \"note\" { target *-*-* } .-2 }\n+     { dg-message \".sprintf. output 2 bytes into a destination of size 1\" \"note\" { target *-*-* } .-2 }\n      { dg-begin-multiline-output \"-Wformat output: redundant argument\" }\n    sprintf (dst + 2, \"1\", 0);\n                      ^~~\n      { dg-end-multiline-output \"\" }\n      { dg-begin-multiline-output \"-Wformat-overflow output\" }\n    sprintf (dst + 2, \"1\", 0);\n-                      ~^\n+                       ^\n      { dg-end-multiline-output \"\" }\n      { dg-begin-multiline-output \"note\" }\n    sprintf (dst + 2, \"1\", 0);\n@@ -29,15 +29,15 @@ void test (void)\n   /* Verify thet the caret points at the first format character written\n      past the end of the destination.  */\n   sprintf (dst, \"1234\", 0);\n-  /* { dg-warning \"writing format character .4. at offset 3 past the end of the destination\" \"nul warning\" { target *-*-* } .-1 }\n-     { dg-message \"format output 5 bytes into a destination of size 3\" \"note\" { target *-*-* } .-2 }\n+  /* { dg-warning \"writing 4 bytes into a region of size 3\" \"overlong format string\" { target *-*-* } .-1 }\n+     { dg-message \".sprintf. output 5 bytes into a destination of size 3\" \"note\" { target *-*-* } .-2 }\n      { dg-begin-multiline-output \"-Wformat output: redundant argument\" }\n    sprintf (dst, \"1234\", 0);\n                  ^~~~~~\n      { dg-end-multiline-output \"\" }\n      { dg-begin-multiline-output \"-Wformat-overflow output\" }\n    sprintf (dst, \"1234\", 0);\n-                     ^\n+                  ~~~^\n      { dg-end-multiline-output \"\" }\n      { dg-begin-multiline-output \"note\" }\n    sprintf (dst, \"1234\", 0);\n@@ -48,15 +48,15 @@ void test (void)\n      past the end of the destination and the rest of the format string\n      is underlined.  */\n   sprintf (dst, \"12345\", 0);\n-  /* { dg-warning \"writing format character .4. at offset 3 past the end of the destination\" \"nul warning\" { target *-*-* } .-1 }\n-     { dg-message \"format output 6 bytes into a destination of size 3\" \"note\" { target *-*-* } .-2 }\n+  /* { dg-warning \"writing 5 bytes into a region of size 3\" \"nul warning\" { target *-*-* } .-1 }\n+     { dg-message \".sprintf. output 6 bytes into a destination of size 3\" \"note\" { target *-*-* } .-2 }\n      { dg-begin-multiline-output \"-Wformat output: redundant argument\" }\n    sprintf (dst, \"12345\", 0);\n                  ^~~~~~~\n      { dg-end-multiline-output \"\" }\n      { dg-begin-multiline-output \"-Wformat-overflow output\" }\n    sprintf (dst, \"12345\", 0);\n-                     ^~\n+                  ~~~^~\n      { dg-end-multiline-output \"\" }\n      { dg-begin-multiline-output \"note\" }\n    sprintf (dst, \"12345\", 0);\n@@ -67,10 +67,10 @@ void test (void)\n      get around GCC bug 77671.  */\n   sprintf (dst + 2, \"%-s\", \"1\");\n   /* { dg-warning \"writing a terminating nul past the end of the destination\" \"warning\" { target *-*-* } .-1 }\n-     { dg-message \"format output 2 bytes into a destination of size 1\" \"note\" { target *-*-* } .-2 }\n+     { dg-message \".sprintf. output 2 bytes into a destination of size 1\" \"note\" { target *-*-* } .-2 }\n      { dg-begin-multiline-output \"-Wformat-overflow output\" }\n    sprintf (dst + 2, \"%-s\", \"1\");\n-                      ~~~^\n+                         ^\n      { dg-end-multiline-output \"\" }\n      { dg-begin-multiline-output \"note\" }\n    sprintf (dst + 2, \"%-s\", \"1\");\n@@ -79,7 +79,7 @@ void test (void)\n \n   sprintf (dst + 2, \"%-s\", \"abcd\");\n   /* { dg-warning \".%-s. directive writing 4 bytes into a region of size 1\" \"warning\" { target *-*-* } .-1 }\n-     { dg-message \"format output 5 bytes into a destination of size 1\" \"note\" { target *-*-* } .-2 }\n+     { dg-message \".sprintf. output 5 bytes into a destination of size 1\" \"note\" { target *-*-* } .-2 }\n      { dg-begin-multiline-output \"-Wformat-overflow output\" }\n    sprintf (dst + 2, \"%-s\", \"abcd\");\n                       ^~~   ~~~~~~\n@@ -105,8 +105,8 @@ extern char *ptr;\n /* Evaluate to an array of SIZE characters when non-negative and LINE\n    is not set or set to the line the macro is on, or to a pointer to\n    an unknown object otherwise.  */\n-#define buffer(size)\t\t\t\t\t\t\t\\\n-  (0 <= size && (!LINE || __LINE__ == LINE)\t\t\t\t\\\n+#define buffer(size)                                                    \\\n+  (0 <= size && (!LINE || __LINE__ == LINE)                             \\\n    ? buffer + sizeof buffer - size : ptr)\n \n /* Verify that the note printed along with the diagnostic mentions\n@@ -124,7 +124,7 @@ void test_sprintf_note (void)\n                                    ^~\n      { dg-end-multiline-output \"\" }\n \n-     { dg-message \"format output 4 bytes into a destination of size 0\" \"\" { target *-*-* } .-7 }\n+     { dg-message \".__builtin_sprintf. output 4 bytes into a destination of size 0\" \"\" { target *-*-* } .-7 }\n      { dg-begin-multiline-output \"\" }\n    __builtin_sprintf (buffer (0), \"%c%s%i\", '1', \"2\", 3);\n    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n@@ -137,7 +137,7 @@ void test_sprintf_note (void)\n                                      ^~          ~~~~\n      { dg-end-multiline-output \"\" }\n \n-     { dg-message \"format output 6 bytes into a destination of size 1\" \"\" { target *-*-* } .-7 }\n+     { dg-message \".__builtin_sprintf. output 6 bytes into a destination of size 1\" \"\" { target *-*-* } .-7 }\n      { dg-begin-multiline-output \"\" }\n    __builtin_sprintf (buffer (1), \"%c%s%i\", '1', \"23\", 45);\n    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n@@ -150,7 +150,7 @@ void test_sprintf_note (void)\n                                        ^~\n      { dg-end-multiline-output \"\" }\n \n-     { dg-message \"format output 6 bytes into a destination of size 2\" \"\" { target *-*-* } .-7 }\n+     { dg-message \".__builtin_sprintf. output 6 bytes into a destination of size 2\" \"\" { target *-*-* } .-7 }\n      { dg-begin-multiline-output \"\" }\n    __builtin_sprintf (buffer (2), \"%c%s%i\", '1', \"2\", 345);\n    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n@@ -160,10 +160,10 @@ void test_sprintf_note (void)\n   /* { dg-warning \"41: writing a terminating nul past the end of the destination\" \"\" { target *-*-* } .-1 }\n      { dg-begin-multiline-output \"\" }\n    __builtin_sprintf (buffer (6), \"%c%s%i\", '1', \"2\", 3456);\n-                                   ~~~~~~^\n+                                         ^\n      { dg-end-multiline-output \"\" }\n \n-     { dg-message \"format output 7 bytes into a destination of size 6\" \"\" { target *-*-* } .-7 }\n+     { dg-message \".__builtin_sprintf. output 7 bytes into a destination of size 6\" \"\" { target *-*-* } .-7 }\n      { dg-begin-multiline-output \"\" }\n    __builtin_sprintf (buffer (6), \"%c%s%i\", '1', \"2\", 3456);\n    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"}, {"sha": "16729798900c494027c4f4c55a8118c84a037206", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-6.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-6.c?ref=5d93da1d112c93b38b6c68e3c51e20daefc01423", "patch": "@@ -52,7 +52,7 @@ void fuint (unsigned j, char *p)\n   if (j > 999)\n     return;\n \n-  snprintf (p, 4, \"%3u\", j);   /* { dg-bogus \"may be truncated\" \"unsigned int\" { xfail *-*-* } } */\n+  snprintf (p, 4, \"%3u\", j);\n }\n \n void fint (int j, char *p)\n@@ -62,15 +62,15 @@ void fint (int j, char *p)\n   if (k > 999)\n     return;\n \n-  snprintf (p, 4, \"%3u\", k);   /* { dg-bogus \"may be truncated\" \"signed int\" { xfail *-*-* } } */\n+  snprintf (p, 4, \"%3u\", k);\n }\n \n void fulong (unsigned long j, char *p)\n {\n   if (j > 999)\n     return;\n \n-  snprintf (p, 4, \"%3lu\", j);   /* { dg-bogus \"may be truncated\" \"unsigned long\" { xfail *-*-* } } */\n+  snprintf (p, 4, \"%3lu\", j);\n }\n \n void flong (long j, char *p)\n@@ -80,15 +80,15 @@ void flong (long j, char *p)\n   if (k > 999)\n     return;\n \n-  snprintf (p, 4, \"%3lu\", k);   /* { dg-bogus \"may be truncated\" \"signed long\" { xfail *-*-* } } */\n+  snprintf (p, 4, \"%3lu\", k);\n }\n \n void fullong (unsigned long long j, char *p)\n {\n   if (j > 999)\n     return;\n \n-  snprintf (p, 4, \"%3llu\", j);   /* { dg-bogus \"may be truncated\" \"signed long\" { xfail *-*-* } } */\n+  snprintf (p, 4, \"%3llu\", j);\n }\n \n void fllong (long long j, char *p)\n@@ -98,7 +98,7 @@ void fllong (long long j, char *p)\n   if (k > 999)\n     return;\n \n-  snprintf (p, 4, \"%3llu\", k);   /* { dg-bogus \"may be truncated\" \"unsigned long long\" { xfail *-*-* } } */\n+  snprintf (p, 4, \"%3llu\", k);\n }\n \n /* { dg-final { scan-tree-dump-not \"abort\" \"optimized\" } } */"}, {"sha": "31f5d4f928a0be1299eea7fa5e6b6159e5965f06", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-7.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-7.c?ref=5d93da1d112c93b38b6c68e3c51e20daefc01423", "patch": "@@ -32,14 +32,16 @@ void test_integer_cst (void)\n void test_integer_var (int i)\n {\n   T (0, \"%*d\",  INT_MIN, i);     /* { dg-warning \"writing 2147483648 bytes\" } */\n-  T (0, \"%*d\",  INT_MAX, i);     /* { dg-warning \"writing 2147483647 bytes\" } */\n-\n-  T (0, \"%.*d\", INT_MIN, i);     /* { dg-warning \"writing between 1 and 11 bytes\" } */\n \n   /* The following writes INT_MAX digits and, when i is negative, a minus\n      sign.  */\n   T (0, \"%.*d\", INT_MAX, i);     /* { dg-warning \"writing between 2147483647 and 2147483648 bytes\" } */\n \n+  T (0, \"%.*d\", INT_MIN, i);     /* { dg-warning \"writing between 1 and 11 bytes\" } */\n+\n+  /* The following writes a range because of the possible minus sign.  */\n+  T (0, \"%.*d\", INT_MAX, i);     /* { dg-warning \"writing between 2147483647 and 2147483648 bytes\" } */\n+\n   T (0, \"%*.*d\", INT_MIN, INT_MIN, i);   /* { dg-warning \"writing 2147483648 bytes\" } */\n \n   /* The following writes INT_MAX digits and, when i is negative, a minus\n@@ -52,7 +54,10 @@ void test_floating_a_cst (void)\n   T (0, \"%*a\",  INT_MIN, 0.);     /* { dg-warning \"writing 2147483648 bytes\" } */\n   T (0, \"%*a\",  INT_MAX, 0.);     /* { dg-warning \"writing 2147483647 bytes\" } */\n \n-  T (0, \"%.*a\", INT_MIN, 0.);     /* { dg-warning \"writing 6 bytes\" } */\n+  /* %a is poorly specified and as a result some implementations trim\n+     redundant trailing zeros (e.g., Glibc) and others don't (e.g.,\n+     Solaris).  */\n+  T (0, \"%.*a\", INT_MIN, 0.);     /* { dg-warning \"writing between 6 and 20 bytes\" } */\n \n   T (0, \"%.*a\", INT_MAX, 0.);     /* { dg-warning \"writing 2147483654 bytes\" } */\n \n@@ -111,7 +116,7 @@ void test_floating_f_cst (void)\n   T (0, \"%*f\",  INT_MIN, 0.);     /* { dg-warning \"writing 2147483648 bytes\" } */\n   T (0, \"%*f\",  INT_MAX, 0.);     /* { dg-warning \"writing 2147483647 bytes\" } */\n \n-  T (0, \"%.*f\", INT_MIN, 0.);     /* { dg-warning \"writing 8 byte\" } */\n+  T (0, \"%.*f\", INT_MIN, 0.);     /* { dg-warning \"writing 8 bytes\" } */\n \n   T (0, \"%.*f\", INT_MAX, 0.);     /* { dg-warning \"writing 2147483649 bytes\" } */\n \n@@ -178,14 +183,14 @@ void test_string_cst (void)\n \n void test_string_var (const char *s)\n {\n-  T (0, \"%*s\",  INT_MIN, s);     /* { dg-warning \"writing 2147483648 bytes\" } */\n-  T (0, \"%*s\",  INT_MAX, s);     /* { dg-warning \"writing 2147483647 bytes\" } */\n+  T (0, \"%*s\",  INT_MIN, s);     /* { dg-warning \"writing 2147483648 or more bytes\" } */\n+  T (0, \"%*s\",  INT_MAX, s);     /* { dg-warning \"writing 2147483647 or more bytes\" } */\n \n   T (0, \"%.*s\", INT_MIN, s);     /* { dg-warning \"writing a terminating nul\" } */\n \n-  T (0, \"%.*s\", INT_MAX, s);     /* { dg-warning \"writing between 0 and 2147483647 bytes\" } */\n+  T (0, \"%.*s\", INT_MAX, s);     /* { dg-warning \"writing up to 2147483647 bytes\" } */\n \n-  T (0, \"%*.*s\", INT_MIN, INT_MIN, s);   /* { dg-warning \"writing 2147483648 bytes\" } */\n+  T (0, \"%*.*s\", INT_MIN, INT_MIN, s);   /* { dg-warning \"writing 2147483648 or more bytes\" } */\n \n   T (0, \"%*.*s\", INT_MAX, INT_MAX, s);   /* { dg-warning \"writing 2147483647 bytes\" } */\n }"}, {"sha": "5523acd7db176ffc6026e4192a641f540dfa2bf5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-9.c", "status": "modified", "additions": 52, "deletions": 58, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-9.c?ref=5d93da1d112c93b38b6c68e3c51e20daefc01423", "patch": "@@ -37,19 +37,17 @@ void test_a (int w, int p, double x)\n   T1 (\"%*.a\", 6);     /* { dg-warning \"between 6 and 10 bytes\" } */\n   T1 (\"%*.a\", 7);     /* { dg-warning \"between 7 and 10 bytes\" } */\n \n-  T1 (\"%*.a\", w);     /* { dg-warning \"writing 6 or more bytes\" } */\n-  T1 (\"%*.0a\", w);    /* { dg-warning \"writing 6 or more bytes\" } */\n-  T1 (\"%*.1a\", w);    /* { dg-warning \"writing 8 or more bytes\" } */\n-  T1 (\"%*.2a\", w);    /* { dg-warning \"writing 9 or more bytes\" } */\n-\n-  T1 (\"%.*a\",  p);    /* { dg-warning \"writing 6 or more bytes\" } */\n-  T1 (\"%1.*a\", p);    /* { dg-warning \"writing 6 or more bytes\" } */\n-  T1 (\"%2.*a\", p);    /* { dg-warning \"writing 6 or more bytes\" } */\n-  T1 (\"%3.*a\", p);    /* { dg-warning \"writing 6 or more bytes\" } */\n-\n-  T2 (\"%*.*a\", w, p); /* { dg-warning \"writing 6 or more bytes\" } */\n-  T2 (\"%*.*a\", w, p); /* { dg-warning \"writing 6 or more bytes\" } */\n-  T2 (\"%*.*a\", w, p); /* { dg-warning \"writing 6 or more bytes\" } */\n+  T1 (\"%*.a\", w);     /* { dg-warning \"writing between 6 and 2147483648 bytes\" } */\n+  T1 (\"%*.0a\", w);    /* { dg-warning \"writing between 6 and 2147483648 bytes\" } */\n+  T1 (\"%*.1a\", w);    /* { dg-warning \"writing between 8 and 2147483648 bytes\" } */\n+  T1 (\"%*.2a\", w);    /* { dg-warning \"writing between 9 and 2147483648 bytes\" } */\n+\n+  T1 (\"%.*a\",  p);    /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n+  T1 (\"%1.*a\", p);    /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n+  T1 (\"%2.*a\", p);    /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n+  T1 (\"%3.*a\", p);    /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n+\n+  T2 (\"%*.*a\", w, p); /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n }\n \n /* Exercise %e.  */\n@@ -69,19 +67,17 @@ void test_e (int w, int p, double x)\n   T1 (\"%*.e\", 6);     /* { dg-warning \"between 6 and 7 bytes\" } */\n   T1 (\"%*.e\", 7);     /* { dg-warning \"writing 7 bytes\" } */\n \n-  T1 (\"%*.e\", w);     /* { dg-warning \"writing 5 or more bytes\" } */\n-  T1 (\"%*.0e\", w);    /* { dg-warning \"writing 5 or more bytes\" } */\n-  T1 (\"%*.1e\", w);    /* { dg-warning \"writing 7 or more bytes\" } */\n-  T1 (\"%*.2e\", w);    /* { dg-warning \"writing 8 or more bytes\" } */\n+  T1 (\"%*.e\", w);     /* { dg-warning \"writing between 5 and 2147483648 bytes\" } */\n+  T1 (\"%*.0e\", w);    /* { dg-warning \"writing between 5 and 2147483648 bytes\" } */\n+  T1 (\"%*.1e\", w);    /* { dg-warning \"writing between 7 and 2147483648 bytes\" } */\n+  T1 (\"%*.2e\", w);    /* { dg-warning \"writing between 8 and 2147483648 bytes\" } */\n \n-  T1 (\"%.*e\",  p);    /* { dg-warning \"writing 5 or more bytes\" } */\n-  T1 (\"%1.*e\", p);    /* { dg-warning \"writing 5 or more bytes\" } */\n-  T1 (\"%2.*e\", p);    /* { dg-warning \"writing 5 or more bytes\" } */\n-  T1 (\"%3.*e\", p);    /* { dg-warning \"writing 5 or more bytes\" } */\n+  T1 (\"%.*e\",  p);    /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n+  T1 (\"%1.*e\", p);    /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n+  T1 (\"%2.*e\", p);    /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n+  T1 (\"%3.*e\", p);    /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n \n-  T2 (\"%*.*e\", w, p); /* { dg-warning \"writing 5 or more bytes\" } */\n-  T2 (\"%*.*e\", w, p); /* { dg-warning \"writing 5 or more bytes\" } */\n-  T2 (\"%*.*e\", w, p); /* { dg-warning \"writing 5 or more bytes\" } */\n+  T2 (\"%*.*e\", w, p); /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n }\n \n /* Exercise %f.  */\n@@ -103,19 +99,17 @@ void test_f (int w, int p, double x)\n   T2 (\"%*.*f\", 312, 312);   /* { dg-warning \"between 314 and 623 bytes\" } */\n   T2 (\"%*.*f\", 312, 313);   /* { dg-warning \"between 315 and 624 bytes\" } */\n \n-  T1 (\"%*.f\", w);           /* { dg-warning \"writing 1 or more bytes\" } */\n-  T1 (\"%*.0f\", w);          /* { dg-warning \"writing 1 or more bytes\" } */\n-  T1 (\"%*.1f\", w);          /* { dg-warning \"writing 3 or more bytes\" } */\n-  T1 (\"%*.2f\", w);          /* { dg-warning \"writing 4 or more bytes\" } */\n+  T1 (\"%*.f\", w);           /* { dg-warning \"writing between 1 and 2147483648 bytes\" } */\n+  T1 (\"%*.0f\", w);          /* { dg-warning \"writing between 1 and 2147483648 bytes\" } */\n+  T1 (\"%*.1f\", w);          /* { dg-warning \"writing between 3 and 2147483648 bytes\" } */\n+  T1 (\"%*.2f\", w);          /* { dg-warning \"writing between 4 and 2147483648 bytes\" } */\n \n-  T1 (\"%.*f\",  p);          /* { dg-warning \"writing 1 or more bytes\" } */\n-  T1 (\"%1.*f\", p);          /* { dg-warning \"writing 1 or more bytes\" } */\n-  T1 (\"%2.*f\", p);          /* { dg-warning \"writing 2 or more bytes\" } */\n-  T1 (\"%3.*f\", p);          /* { dg-warning \"writing 3 or more bytes\" } */\n+  T1 (\"%.*f\",  p);          /* { dg-warning \"writing between 1 and 2147483958 bytes\" } */\n+  T1 (\"%1.*f\", p);          /* { dg-warning \"writing between 1 and 2147483958 bytes\" } */\n+  T1 (\"%2.*f\", p);          /* { dg-warning \"writing between 2 and 2147483958 bytes\" } */\n+  T1 (\"%3.*f\", p);          /* { dg-warning \"writing between 3 and 2147483958 bytes\" } */\n \n-  T2 (\"%*.*f\", w, p);       /* { dg-warning \"writing 1 or more bytes\" } */\n-  T2 (\"%*.*f\", w, p);       /* { dg-warning \"writing 1 or more bytes\" } */\n-  T2 (\"%*.*f\", w, p);       /* { dg-warning \"writing 1 or more bytes\" } */\n+  T2 (\"%*.*f\", w, p);       /* { dg-warning \"writing between 1 and 2147483958 bytes\" } */\n }\n \n /* Exercise %g.  The expected output is the lesser of %e and %f.  */\n@@ -156,18 +150,18 @@ void test_a_va (va_list va)\n   T (\"%6.a\");       /* { dg-warning \"between 6 and 10 bytes\" } */\n   T (\"%7.a\");       /* { dg-warning \"between 7 and 10 bytes\" } */\n \n-  T (\"%*.a\");       /* { dg-warning \"writing 6 or more bytes\" } */\n-  T (\"%*.0a\");      /* { dg-warning \"writing 6 or more bytes\" } */\n-  T (\"%*.1a\");      /* { dg-warning \"writing 8 or more bytes\" } */\n-  T (\"%*.2a\");      /* { dg-warning \"writing 9 or more bytes\" } */\n+  T (\"%*.a\");       /* { dg-warning \"writing between 6 and 2147483648 bytes\" } */\n+  T (\"%*.0a\");      /* { dg-warning \"writing between 6 and 2147483648 bytes\" } */\n+  T (\"%*.1a\");      /* { dg-warning \"writing between 8 and 2147483648 bytes\" } */\n+  T (\"%*.2a\");      /* { dg-warning \"writing between 9 and 2147483648 bytes\" } */\n \n-  T (\"%.*a\");       /* { dg-warning \"writing 6 or more bytes\" } */\n-  T (\"%1.*a\");      /* { dg-warning \"writing 6 or more bytes\" } */\n-  T (\"%2.*a\");      /* { dg-warning \"writing 6 or more bytes\" } */\n-  T (\"%6.*a\");      /* { dg-warning \"writing 6 or more bytes\" } */\n-  T (\"%9.*a\");      /* { dg-warning \"writing 9 or more bytes\" } */\n+  T (\"%.*a\");       /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n+  T (\"%1.*a\");      /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n+  T (\"%2.*a\");      /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n+  T (\"%6.*a\");      /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n+  T (\"%9.*a\");      /* { dg-warning \"writing between 9 and 2147483658 bytes\" } */\n \n-  T (\"%*.*a\");      /* { dg-warning \"writing 6 or more bytes\" } */\n+  T (\"%*.*a\");      /* { dg-warning \"writing between 6 and 2147483658 bytes\" } */\n }\n \n /* Exercise %e.  */\n@@ -195,12 +189,12 @@ void test_e_va (va_list va)\n   T (\"%6.e\");       /* { dg-warning \"between 6 and 7 bytes\" } */\n   T (\"%7.e\");       /* { dg-warning \"writing 7 bytes\" } */\n \n-  T (\"%.*e\");       /* { dg-warning \"writing 5 or more bytes\" } */\n-  T (\"%1.*e\");      /* { dg-warning \"writing 5 or more bytes\" } */\n-  T (\"%6.*e\");      /* { dg-warning \"writing 6 or more bytes\" } */\n-  T (\"%9.*e\");      /* { dg-warning \"writing 9 or more bytes\" } */\n+  T (\"%.*e\");       /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n+  T (\"%1.*e\");      /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n+  T (\"%6.*e\");      /* { dg-warning \"writing between 6 and 2147483655 bytes\" } */\n+  T (\"%9.*e\");      /* { dg-warning \"writing between 9 and 2147483655 bytes\" } */\n \n-  T (\"%*.*e\");      /* { dg-warning \"writing 5 or more bytes\" } */\n+  T (\"%*.*e\");      /* { dg-warning \"writing between 5 and 2147483655 bytes\" } */\n }\n \n /* Exercise %f.  */\n@@ -232,11 +226,11 @@ void test_f_va (va_list va)\n   T (\"%312.312f\");  /* { dg-warning \"between 314 and 623 bytes\" } */\n   T (\"%312.313f\");  /* { dg-warning \"between 315 and 624 bytes\" } */\n \n-  T (\"%.*f\");       /* { dg-warning \"writing 1 or more bytes\" } */\n-  T (\"%1.*f\");      /* { dg-warning \"writing 1 or more bytes\" } */\n-  T (\"%3.*f\");      /* { dg-warning \"writing 3 or more bytes\" } */\n+  T (\"%.*f\");       /* { dg-warning \"writing between 1 and 2147483958 bytes\" } */\n+  T (\"%1.*f\");      /* { dg-warning \"writing between 1 and 2147483958 bytes\" } */\n+  T (\"%3.*f\");      /* { dg-warning \"writing between 3 and 2147483958 bytes\" } */\n \n-  T (\"%*.*f\");      /* { dg-warning \"writing 1 or more bytes\" } */\n+  T (\"%*.*f\");      /* { dg-warning \"writing between 1 and 2147483958 bytes\" } */\n }\n \n /* Exercise %g.  The expected output is the lesser of %e and %f.  */\n@@ -268,9 +262,9 @@ void test_g_va (va_list va)\n   T (\"%312.313g\");  /* { dg-warning \"writing 312 bytes\" } */\n   T (\"%333.999g\");  /* { dg-warning \"writing 333 bytes\" } */\n \n-  T (\"%.*g\");       /* { dg-warning \"writing 1 or more bytes\" } */\n-  T (\"%1.*g\");      /* { dg-warning \"writing 1 or more bytes\" } */\n-  T (\"%4.*g\");      /* { dg-warning \"writing 4 or more bytes\" } */\n+  T (\"%.*g\");       /* { dg-warning \"writing between 1 and 310 bytes\" } */\n+  T (\"%1.*g\");      /* { dg-warning \"writing between 1 and 310 bytes\" } */\n+  T (\"%4.*g\");      /* { dg-warning \"writing between 4 and 310 bytes\" } */\n \n-  T (\"%*.*g\");      /* { dg-warning \"writing 1 or more bytes\" } */\n+  T (\"%*.*g\");      /* { dg-warning \"writing between 1 and 2147483648 bytes\" } */\n }"}, {"sha": "cf6b9ec3dfe53797e4223b35742425339f205fc1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf.c", "status": "modified", "additions": 189, "deletions": 193, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d93da1d112c93b38b6c68e3c51e20daefc01423/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf.c?ref=5d93da1d112c93b38b6c68e3c51e20daefc01423", "patch": "@@ -3,10 +3,8 @@\n    constant folding.  With optimization enabled the test will fail to\n    link if any of the assertions fails.  Without optimization the test\n    aborts at runtime if any of the assertions fails.  */\n-/* { dg-do run }\n-   The h and hh length modifiers are a C99 feature (see PR 78959).\n-   { dg-require-effective-target c99_runtime }\n-   { dg-additional-options \"-O2 -Wall -Wno-pedantic -fprintf-return-value\" } */\n+/* { dg-do run } */\n+/* { dg-additional-options \"-O2 -Wall -Wno-pedantic -fprintf-return-value\" } */\n \n #ifndef LINE\n #  define LINE   0\n@@ -320,15 +318,13 @@ test_d_i (int i, long li)\n #if __SIZEOF_SHORT__ == 2\n   RNG ( 1,  6,  7, \"%hi\",      i);\n   RNG ( 1,  5,  6, \"%hu\",      i);\n-\n   RNG ( 1,  6,  7, \"%.1hi\",    i);\n   RNG ( 2,  6,  7, \"%.2hi\",    i);\n   RNG ( 3,  6,  7, \"%.3hi\",    i);\n   RNG ( 4,  6,  7, \"%.4hi\",    i);\n   RNG ( 5,  6,  7, \"%.5hi\",    i);\n   RNG ( 6,  7,  8, \"%.6hi\",    i);\n   RNG ( 7,  8,  9, \"%.7hi\",    i);\n-\n #elif __SIZEOF_SHORT__ == 4\n   RNG ( 1, 11, 12, \"%hi\",      i);\n   RNG ( 1, 10, 11, \"%hu\",      i);\n@@ -474,16 +470,21 @@ test_a_double (double d)\n   EQL ( 6,  7, \"%.0a\", 0.0);        /* 0x0p+0 */\n   EQL ( 6,  7, \"%.0a\", 1.0);        /* 0x8p-3 */\n   EQL ( 6,  7, \"%.0a\", 2.0);        /* 0x8p-2 */\n-  EQL ( 8,  9, \"%.1a\", 3.0);        /* 0xc.0p-2 */\n-  EQL ( 9, 10, \"%.2a\", 4.0);        /* 0x8.00p-1 */\n-  EQL (10, 11, \"%.3a\", 5.0);        /* 0xa.000p-1 */\n \n-  EQL (11, 12, \"%.*a\", 4, 6.0);     /* 0xc.0000p-1 */\n-  EQL (12, 13, \"%.*a\", 5, 7.0);     /* 0xe.00000p-1 */\n+  /* The decimal point may be up to MB_LEN_MAX long.  */\n+  RNG ( 8, 13, 14, \"%.1a\", 3.0);    /* 0xc.0p-2 */\n+  RNG ( 9, 14, 15, \"%.2a\", 4.0);    /* 0x8.00p-1 */\n+  RNG (10, 15, 16, \"%.3a\", 5.0);    /* 0xa.000p-1 */\n+\n+  RNG (11, 16, 17, \"%.*a\", 4, 6.0); /* 0xc.0000p-1 */\n+  RNG (12, 17, 18, \"%.*a\", 5, 7.0); /* 0xe.00000p-1 */\n \t                            /* d is in [ 0, -DBL_MAX ] */\n   RNG ( 6, 10, 11, \"%.0a\", d);      /* 0x0p+0 ... -0x2p+1023 */\n-  RNG ( 6, 12, 13, \"%.1a\", d);      /* 0x0p+0 ... -0x2.0p+1023 */\n-  RNG ( 6, 13, 14, \"%.2a\", d);      /* 0x0p+0 ... -0x2.00p+1023 */\n+  /* %a is poorly specified and allows for implementations divergence:\n+     some (such as Glibc) trim redundant trailing zeros after decimal\n+     point and others (e.g., Solaris) don't.  */\n+  RNG ( 8, 30, 31, \"%.1a\", d);      /* 0x0.0p+0  ... -0x2.0...0p+1023 */\n+  RNG ( 9, 30, 31, \"%.2a\", d);      /* 0x0.00p+0 ... -0x2.00...0p+1023 */\n }\n \n static void __attribute__ ((noinline, noclone))\n@@ -492,249 +493,244 @@ test_a_long_double (void)\n   EQL ( 6,  7, \"%.0La\", 0.0L);      /* 0x0p+0 */\n   EQL ( 6,  7, \"%.0La\", 1.0L);      /* 0x8p-3 */\n   EQL ( 6,  7, \"%.0La\", 2.0L);      /* 0x8p-2 */\n-  EQL ( 8,  9, \"%.1La\", 3.0L);      /* 0xc.0p-2 */\n-  EQL ( 9, 10, \"%.2La\", 4.0L);      /* 0xa.00p-1 */\n+\n+  RNG ( 8, 13, 14, \"%.1La\", 3.0L);  /* 0xc.0p-2 */\n+  RNG ( 9, 14, 15, \"%.2La\", 4.0L);  /* 0xa.00p-1 */\n }\n \n static void __attribute__ ((noinline, noclone))\n test_e_double (double d)\n {\n-  EQL (12, 13, \"%e\",  1.0e0);\n-  EQL (13, 14, \"%e\", -1.0e0);\n-  EQL (12, 13, \"%e\",  1.0e+1);\n-  EQL (13, 14, \"%e\", -1.0e+1);\n-  EQL (12, 13, \"%e\",  1.0e+12);\n-  EQL (13, 14, \"%e\", -1.0e+12);\n-  EQL (13, 14, \"%e\",  1.0e+123);\n-  EQL (14, 15, \"%e\", -1.0e+123);\n-\n-  EQL (12, 13, \"%e\",  9.999e+99);\n-  EQL (12, 13, \"%e\",  9.9999e+99);\n-  EQL (12, 13, \"%e\",  9.99999e+99);\n+  RNG (12, 17, 18, \"%e\",  1.0e0);\n+  RNG (13, 18, 19, \"%e\", -1.0e0);\n+  RNG (12, 17, 18, \"%e\",  1.0e+1);\n+  RNG (13, 18, 19, \"%e\", -1.0e+1);\n+  RNG (12, 17, 18, \"%e\",  1.0e+12);\n+  RNG (13, 18, 19, \"%e\", -1.0e+12);\n+  RNG (13, 18, 19, \"%e\",  1.0e+123);\n+  RNG (14, 19, 20, \"%e\", -1.0e+123);\n+\n+  RNG (12, 17, 18, \"%e\",  9.999e+99);\n+  RNG (12, 17, 18, \"%e\",  9.9999e+99);\n+  RNG (12, 17, 18, \"%e\",  9.99999e+99);\n \n   /* The actual output of the following directive depends on the rounding\n      mode.  */\n-  /* EQL (12, \"%e\",  9.9999994e+99); */\n+  /* RNG (12, \"%e\",  9.9999994e+99); */\n \n-  EQL (12, 13, \"%e\",  1.0e-1);\n-  EQL (12, 13, \"%e\",  1.0e-12);\n-  EQL (13, 14, \"%e\",  1.0e-123);\n+  RNG (12, 17, 18, \"%e\",  1.0e-1);\n+  RNG (12, 17, 18, \"%e\",  1.0e-12);\n+  RNG (13, 18, 19, \"%e\",  1.0e-123);\n \n-  RNG (12, 14, 15, \"%e\", d);\n-  RNG ( 5,  7,  8, \"%.e\", d);\n-  RNG ( 5,  7,  8, \"%.0e\", d);\n-  RNG ( 7,  9, 10, \"%.1e\", d);\n-  RNG ( 8, 10, 11, \"%.2e\", d);\n-  RNG ( 9, 11, 12, \"%.3e\", d);\n-  RNG (10, 12, 13, \"%.4e\", d);\n-  RNG (11, 13, 14, \"%.5e\", d);\n-  RNG (12, 14, 15, \"%.6e\", d);\n-  RNG (13, 15, 16, \"%.7e\", d);\n+  RNG (12, 19, 20, \"%e\",   d);\n+  RNG ( 5, 11, 12, \"%.e\",  d);\n+  RNG ( 5, 12, 13, \"%.0e\", d);\n+  RNG ( 7, 14, 15, \"%.1e\", d);\n+  RNG ( 8, 15, 16, \"%.2e\", d);\n+  RNG ( 9, 16, 17, \"%.3e\", d);\n+  RNG (10, 17, 18, \"%.4e\", d);\n+  RNG (11, 18, 19, \"%.5e\", d);\n+  RNG (12, 19, 20, \"%.6e\", d);\n+  RNG (13, 20, 21, \"%.7e\", d);\n \n-  RNG (4006, 4008, 4009, \"%.4000e\", d);\n+  RNG (4006, 4013, 4014, \"%.4000e\", d);\n \n   RNG ( 5,  7,  8, \"%.*e\", 0, d);\n-  RNG ( 7,  9, 10, \"%.*e\", 1, d);\n-  RNG ( 8, 10, 11, \"%.*e\", 2, d);\n-  RNG ( 9, 11, 12, \"%.*e\", 3, d);\n-  RNG (10, 12, 13, \"%.*e\", 4, d);\n-  RNG (11, 13, 14, \"%.*e\", 5, d);\n-  RNG (12, 14, 15, \"%.*e\", 6, d);\n-  RNG (13, 15, 16, \"%.*e\", 7, d);\n-\n-  RNG (4006, 4008, 4009, \"%.*e\", 4000, d);\n+  RNG ( 7, 14, 15, \"%.*e\", 1, d);\n+  RNG ( 8, 15, 16, \"%.*e\", 2, d);\n+  RNG ( 9, 16, 17, \"%.*e\", 3, d);\n+  RNG (10, 17, 18, \"%.*e\", 4, d);\n+  RNG (11, 18, 19, \"%.*e\", 5, d);\n+  RNG (12, 19, 20, \"%.*e\", 6, d);\n+  RNG (13, 20, 21, \"%.*e\", 7, d);\n+\n+  RNG (4006, 4013, 4014, \"%.*e\", 4000, d);\n }\n \n static void __attribute__ ((noinline, noclone))\n test_e_long_double (long double d)\n {\n-  EQL (12, 13, \"%Le\",  1.0e0L);\n-  EQL (13, 14, \"%Le\", -1.0e0L);\n-  EQL (12, 13, \"%Le\",  1.0e+1L);\n-  EQL (13, 14, \"%Le\", -1.0e+1L);\n-  EQL (12, 13, \"%Le\",  1.0e+12L);\n-  EQL (13, 14, \"%Le\", -1.0e+12L);\n-  EQL (13, 14, \"%Le\",  1.0e+123L);\n-  EQL (14, 15, \"%Le\", -1.0e+123L);\n-\n-  EQL (12, 13, \"%Le\",  9.999e+99L);\n-  EQL (12, 13, \"%Le\",  9.9999e+99L);\n-  EQL (12, 13, \"%Le\",  9.99999e+99L);\n+  RNG (12, 17, 18, \"%Le\",  1.0e0L);\n+  RNG (13, 18, 19, \"%Le\", -1.0e0L);\n+  RNG (12, 17, 18, \"%Le\",  1.0e+1L);\n+  RNG (13, 18, 19, \"%Le\", -1.0e+1L);\n+  RNG (12, 18, 19, \"%Le\",  1.0e+12L);\n+  RNG (13, 19, 20, \"%Le\", -1.0e+12L);\n+  RNG (13, 19, 20, \"%Le\",  1.0e+123L);\n+  RNG (14, 20, 21, \"%Le\", -1.0e+123L);\n+\n+  RNG (12, 18, 19, \"%Le\",  9.999e+99L);\n+  RNG (12, 18, 19, \"%Le\",  9.9999e+99L);\n+  RNG (12, 18, 19, \"%Le\",  9.99999e+99L);\n \n #if __DBL_DIG__ < __LDBL_DIG__\n-  EQL (12, 13, \"%Le\",  9.999999e+99L);\n+  RNG (12, 17, 18, \"%Le\",  9.999999e+99L);\n #else\n-  RNG (12, 13, 14, \"%Le\",  9.999999e+99L);\n+  RNG (12, 18, 19, \"%Le\",  9.999999e+99L);\n #endif\n \n   /* The actual output of the following directive depends on the rounding\n      mode.  */\n-  /* EQL (12, \"%Le\",  9.9999994e+99L); */\n+  /* RNG (12, \"%Le\",  9.9999994e+99L); */\n \n-  EQL (12, 13, \"%Le\",  1.0e-1L);\n-  EQL (12, 13, \"%Le\",  1.0e-12L);\n-  EQL (13, 14, \"%Le\",  1.0e-123L);\n+  RNG (12, 17, 18, \"%Le\",  1.0e-1L);\n+  RNG (12, 17, 18, \"%Le\",  1.0e-12L);\n+  RNG (13, 18, 19, \"%Le\",  1.0e-123L);\n \n   EQL ( 6,  7, \"%.0Le\",   1.0e-111L);\n-  EQL ( 8,  9, \"%.1Le\",   1.0e-111L);\n-  EQL (19, 20, \"%.12Le\",  1.0e-112L);\n-  EQL (20, 21, \"%.13Le\",  1.0e-113L);\n+\n+  RNG ( 8, 13, 14, \"%.1Le\",   1.0e-111L);\n+  RNG (19, 25, 25, \"%.12Le\",  1.0e-112L);\n+  RNG (20, 26, 27, \"%.13Le\",  1.0e-113L);\n \n   /* The following correspond to the double results plus 1 for the upper\n      bound accounting for the four-digit exponent.  */\n-  RNG (12, 15, 16, \"%Le\", d);    /* 0.000000e+00 ...  -1.189732e+4932 */\n+  RNG (12, 20, 21, \"%Le\", d);    /* 0.000000e+00 ...  -1.189732e+4932 */\n   RNG ( 5,  8,  9, \"%.Le\", d);\n   RNG ( 5,  9, 10, \"%.0Le\", d);\n-  RNG ( 7, 10, 11, \"%.1Le\", d);  /* 0.0e+00      ...  -1.2e+4932 */\n-  RNG ( 8, 11, 12, \"%.2Le\", d);  /* 0.00e+00     ...  -1.19e+4932 */\n-  RNG ( 9, 12, 13, \"%.3Le\", d);\n-  RNG (10, 13, 14, \"%.4Le\", d);\n-  RNG (11, 14, 15, \"%.5Le\", d);\n-  RNG (12, 15, 16, \"%.6Le\", d);  /* same as plain \"%Le\" */\n-  RNG (13, 16, 17, \"%.7Le\", d);  /* 0.0000000e+00 ... -1.1897315e+4932 */\n+  RNG ( 7, 15, 16, \"%.1Le\", d);  /* 0.0e+00      ...  -1.2e+4932 */\n+  RNG ( 8, 16, 17, \"%.2Le\", d);  /* 0.00e+00     ...  -1.19e+4932 */\n+  RNG ( 9, 17, 18, \"%.3Le\", d);\n+  RNG (10, 18, 19, \"%.4Le\", d);\n+  RNG (11, 19, 20, \"%.5Le\", d);\n+  RNG (12, 20, 21, \"%.6Le\", d);  /* same as plain \"%Le\" */\n+  RNG (13, 21, 22, \"%.7Le\", d);  /* 0.0000000e+00 ... -1.1897315e+4932 */\n \n   RNG ( 5,  9, 10, \"%.*Le\", 0, d);\n-  RNG ( 7, 10, 11, \"%.*Le\", 1, d);\n-  RNG ( 8, 11, 12, \"%.*Le\", 2, d);\n-  RNG ( 9, 12, 13, \"%.*Le\", 3, d);\n-  RNG (10, 13, 14, \"%.*Le\", 4, d);\n-  RNG (11, 14, 15, \"%.*Le\", 5, d);\n-  RNG (12, 15, 16, \"%.*Le\", 6, d);\n-  RNG (13, 16, 17, \"%.*Le\", 7, d);\n+  RNG ( 7, 15, 16, \"%.*Le\", 1, d);\n+  RNG ( 8, 16, 17, \"%.*Le\", 2, d);\n+  RNG ( 9, 17, 18, \"%.*Le\", 3, d);\n+  RNG (10, 18, 19, \"%.*Le\", 4, d);\n+  RNG (11, 19, 20, \"%.*Le\", 5, d);\n+  RNG (12, 20, 21, \"%.*Le\", 6, d);\n+  RNG (13, 21, 22, \"%.*Le\", 7, d);\n }\n \n static void __attribute__ ((noinline, noclone))\n test_f_double (double d)\n {\n-  EQL (  8,   9, \"%f\", 0.0e0);\n-  EQL (  8,   9, \"%f\", 0.1e0);\n-  EQL (  8,   9, \"%f\", 0.12e0);\n-  EQL (  8,   9, \"%f\", 0.123e0);\n-  EQL (  8,   9, \"%f\", 0.1234e0);\n-  EQL (  8,   9, \"%f\", 0.12345e0);\n-  EQL (  8,   9, \"%f\", 0.123456e0);\n-  EQL (  8,   9, \"%f\", 1.234567e0);\n-\n-  EQL (  9,  10, \"%f\", 1.0e+1);\n-  EQL ( 20,  21, \"%f\", 1.0e+12);\n-  EQL (130, 131, \"%f\", 1.0e+123);\n-\n-  EQL (  8,   9, \"%f\", 1.0e-1);\n-  EQL (  8,   9, \"%f\", 1.0e-12);\n-  EQL (  8,   9, \"%f\", 1.0e-123);\n-\n-  RNG (  8, 317, 318, \"%f\", d);\n+  RNG (  8,  13,  14, \"%f\", 0.0e0);\n+  RNG (  8,  13,  14, \"%f\", 0.1e0);\n+  RNG (  8,  13,  14, \"%f\", 0.12e0);\n+  RNG (  8,  13,  14, \"%f\", 0.123e0);\n+  RNG (  8,  13,  14, \"%f\", 0.1234e0);\n+  RNG (  8,  13,  14, \"%f\", 0.12345e0);\n+  RNG (  8,  13,  14, \"%f\", 0.123456e0);\n+  RNG (  8,  13,  14, \"%f\", 1.234567e0);\n+\n+  RNG (  9,  14,  15, \"%f\", 1.0e+1);\n+  RNG ( 20,  26,  27, \"%f\", 1.0e+12);\n+  RNG (130, 136, 137, \"%f\", 1.0e+123);\n+\n+  RNG (  8,  13,  14, \"%f\", 1.0e-1);\n+  RNG (  8,  13,  14, \"%f\", 1.0e-12);\n+  RNG (  8,  13,  14, \"%f\", 1.0e-123);\n+\n+  RNG (  8, 322, 323, \"%f\", d);\n }\n \n static void __attribute__ ((noinline, noclone))\n test_f_long_double (void)\n {\n-  EQL (  8,   9, \"%Lf\", 0.0e0L);\n-  EQL (  8,   9, \"%Lf\", 0.1e0L);\n-  EQL (  8,   9, \"%Lf\", 0.12e0L);\n-  EQL (  8,   9, \"%Lf\", 0.123e0L);\n-  EQL (  8,   9, \"%Lf\", 0.1234e0L);\n-  EQL (  8,   9, \"%Lf\", 0.12345e0L);\n-  EQL (  8,   9, \"%Lf\", 0.123456e0L);\n-  EQL (  8,   9, \"%Lf\", 1.234567e0L);\n-\n-  EQL (  9,  10, \"%Lf\", 1.0e+1L);\n-  EQL ( 20,  21, \"%Lf\", 1.0e+12L);\n-  EQL (130, 131, \"%Lf\", 1.0e+123L);\n-\n-  EQL (  8,   9, \"%Lf\", 1.0e-1L);\n-  EQL (  8,   9, \"%Lf\", 1.0e-12L);\n-  EQL (  8,   9, \"%Lf\", 1.0e-123L);\n+  RNG (  8,  15,  16, \"%Lf\", 0.0e0L);\n+  RNG (  8,  14,  15, \"%Lf\", 0.1e0L);\n+  RNG (  8,  14,  15, \"%Lf\", 0.12e0L);\n+  RNG (  8,  14,  15, \"%Lf\", 0.123e0L);\n+  RNG (  8,  14,  15, \"%Lf\", 0.1234e0L);\n+  RNG (  8,  14,  15, \"%Lf\", 0.12345e0L);\n+  RNG (  8,  14,  15, \"%Lf\", 0.123456e0L);\n+  RNG (  8,  14,  15, \"%Lf\", 1.234567e0L);\n+\n+  RNG (  9,  15,  16, \"%Lf\", 1.0e+1L);\n+  RNG ( 20,  26,  27, \"%Lf\", 1.0e+12L);\n+  RNG (130, 136, 137, \"%Lf\", 1.0e+123L);\n+\n+  RNG (  8,  14,  15, \"%Lf\", 1.0e-1L);\n+  RNG (  8,  14,  15, \"%Lf\", 1.0e-12L);\n+  RNG (  8,  14,  15, \"%Lf\", 1.0e-123L);\n }\n \n static void __attribute__ ((noinline, noclone))\n test_g_double (double d)\n {\n   /* Numbers exactly representable in binary floating point.  */\n   EQL (  1,   2, \"%g\", 0.0);\n-  EQL (  3,   4, \"%g\", 1.0 / 2);\n-  EQL (  4,   5, \"%g\", 1.0 / 4);\n-  EQL (  5,   6, \"%g\", 1.0 / 8);\n-  EQL (  6,   7, \"%g\", 1.0 / 16);\n-  EQL (  7,   8, \"%g\", 1.0 / 32);\n-  EQL (  8,   9, \"%g\", 1.0 / 64);\n-  EQL (  9,  10, \"%g\", 1.0 / 128);\n-  EQL ( 10,  11, \"%g\", 1.0 / 256);\n-  EQL ( 10,  11, \"%g\", 1.0 / 512);\n+\n+  RNG (  3,   8,  9, \"%g\", 1.0 / 2);\n+  RNG (  4,   9, 10, \"%g\", 1.0 / 4);\n+  RNG (  5,  10, 11, \"%g\", 1.0 / 8);\n+  RNG (  6,  11, 12, \"%g\", 1.0 / 16);\n+  RNG (  7,  12, 13, \"%g\", 1.0 / 32);\n+  RNG (  8,  13, 14, \"%g\", 1.0 / 64);\n+  RNG (  9,  14, 15, \"%g\", 1.0 / 128);\n+  RNG ( 10,  15, 16, \"%g\", 1.0 / 256);\n+  RNG ( 10,  16, 17, \"%g\", 1.0 / 512);\n \n   /* Numbers that are not exactly representable.  */\n-  RNG ( 3,  8,  9, \"%g\", 0.1);\n-  RNG ( 4,  8,  9, \"%g\", 0.12);\n-  RNG ( 5,  8,  9, \"%g\", 0.123);\n-  RNG ( 6,  8,  9, \"%g\", 0.1234);\n-  RNG ( 7,  8,  9, \"%g\", 0.12345);\n-  RNG ( 8,  8,  9, \"%g\", 0.123456);\n-\n-  RNG ( 4,  7,  8, \"%g\", 0.123e+1);\n-  EQL (     8,  9, \"%g\", 0.123e+12);\n-  RNG ( 9, 12, 13, \"%g\", 0.123e+134);\n-\n-  RNG ( 1, 13, 14, \"%g\", d);\n-  RNG ( 1,  7,  8, \"%.g\", d);\n-  RNG ( 1,  7,  8, \"%.0g\", d);\n-  RNG ( 1,  7,  8, \"%.1g\", d);\n-  RNG ( 1,  9, 10, \"%.2g\", d);\n-  RNG ( 1, 10, 11, \"%.3g\", d);\n-  RNG ( 1, 11, 12, \"%.4g\", d);\n-  RNG ( 1, 12, 13, \"%.5g\", d);\n-  RNG ( 1, 13, 14, \"%.6g\", d);\n-  RNG ( 1, 14, 15, \"%.7g\", d);\n-  RNG ( 1, 15, 16, \"%.8g\", d);\n-\n-  RNG ( 1,310,311, \"%.9999g\", d);\n-\n-  RNG ( 1,  7,  8, \"%.*g\", 0, d);\n-  RNG ( 1,  7,  8, \"%.*g\", 1, d);\n-  RNG ( 1,  9, 10, \"%.*g\", 2, d);\n-  RNG ( 1, 10, 11, \"%.*g\", 3, d);\n-  RNG ( 1, 11, 12, \"%.*g\", 4, d);\n-  RNG ( 1, 12, 13, \"%.*g\", 5, d);\n-  RNG ( 1, 13, 14, \"%.*g\", 6, d);\n-  RNG ( 1, 14, 15, \"%.*g\", 7, d);\n-  RNG ( 1, 15, 16, \"%.*g\", 8, d);\n-  RNG ( 1,310,311, \"%.*g\", 9999, d);\n+  RNG ( 3, 13, 14, \"%g\", 0.1);\n+  RNG ( 4, 13, 14, \"%g\", 0.12);\n+  RNG ( 5, 13, 14, \"%g\", 0.123);\n+  RNG ( 6, 13, 14, \"%g\", 0.1234);\n+  RNG ( 7, 13, 14, \"%g\", 0.12345);\n+  RNG ( 8, 13, 14, \"%g\", 0.123456);\n+\n+  RNG ( 4, 17, 18, \"%g\", 0.123e+1);\n+  RNG ( 8, 18, 19, \"%g\", 0.123e+12);\n+  RNG ( 9, 19, 20, \"%g\", 0.123e+134);\n+\n+  RNG ( 1, 18, 19, \"%g\", d);\n+  RNG ( 1, 12, 13, \"%.g\", d);\n+  RNG ( 1, 12, 13, \"%.0g\", d);\n+  RNG ( 1, 12, 13, \"%.1g\", d);\n+  RNG ( 1, 14, 15, \"%.2g\", d);\n+  RNG ( 1, 15, 16, \"%.3g\", d);\n+  RNG ( 1, 16, 17, \"%.4g\", d);\n+  RNG ( 1, 17, 18, \"%.5g\", d);\n+  RNG ( 1, 18, 19, \"%.6g\", d);\n+  RNG ( 1, 19, 20, \"%.7g\", d);\n+  RNG ( 1, 20, 21, \"%.8g\", d);\n+\n+  RNG ( 1, 315, 316, \"%.9999g\", d);\n+\n+  RNG ( 1, 12, 13, \"%.*g\", 0, d);\n+  RNG ( 1, 12, 13, \"%.*g\", 1, d);\n+  RNG ( 1, 14, 15, \"%.*g\", 2, d);\n+  RNG ( 1, 15, 16, \"%.*g\", 3, d);\n+  RNG ( 1, 16, 17, \"%.*g\", 4, d);\n+  RNG ( 1, 17, 18, \"%.*g\", 5, d);\n+  RNG ( 1, 18, 19, \"%.*g\", 6, d);\n+  RNG ( 1, 19, 20, \"%.*g\", 7, d);\n+  RNG ( 1, 20, 21, \"%.*g\", 8, d);\n+\n+  RNG ( 1, 315, 316, \"%.*g\", 9999, d);\n }\n \n static void __attribute__ ((noinline, noclone))\n test_g_long_double (void)\n {\n   /* Numbers exactly representable in binary floating point.  */\n   EQL (  1,   2, \"%Lg\", 0.0L);\n-  EQL (  3,   4, \"%Lg\", 1.0L / 2);\n-  EQL (  4,   5, \"%Lg\", 1.0L / 4);\n-  EQL (  5,   6, \"%Lg\", 1.0L / 8);\n-  EQL (  6,   7, \"%Lg\", 1.0L / 16);\n-  EQL (  7,   8, \"%Lg\", 1.0L / 32);\n-  EQL (  8,   9, \"%Lg\", 1.0L / 64);\n-  EQL (  9,  10, \"%Lg\", 1.0L / 128);\n-  EQL ( 10,  11, \"%Lg\", 1.0L / 256);\n-  EQL ( 10,  11, \"%Lg\", 1.0L / 512);\n+  RNG (  3,   8, 9, \"%Lg\", 1.0L / 2);\n+  RNG (  4,   9, 10, \"%Lg\", 1.0L / 4);\n+  RNG (  5,  10, 11, \"%Lg\", 1.0L / 8);\n+  RNG (  6,  11, 12, \"%Lg\", 1.0L / 16);\n+  RNG (  7,  12, 13, \"%Lg\", 1.0L / 32);\n+  RNG (  8,  13, 14, \"%Lg\", 1.0L / 64);\n+  RNG (  9,  14, 15, \"%Lg\", 1.0L / 128);\n+  RNG ( 10,  15, 16, \"%Lg\", 1.0L / 256);\n+  RNG ( 10,  15, 16, \"%Lg\", 1.0L / 512);\n \n   /* Numbers that are not exactly representable.  */\n-#if __LDBL_DIG__ < 31\n-  /* x86_64, for example, represents 0.1 as 1.000000...1...e-1\n-     and formats it as either \"0.1\" (when rounded down) or \"0.100001\"\n-     (rounded up).  */\n-  RNG ( 3,  8,  9, \"%Lg\", 0.1L);\n-#else\n-  /* powerpc64 represents 0.1 as 9.999999...6e-2 and formats it\n-   as \"0.0999999\" (rounded down) or \"0.1\" (rounded up).  */\n-  RNG ( 3,  9, 10, \"%Lg\", 0.1L);\n-#endif\n-  RNG ( 4,  8,  9, \"%Lg\", 0.12L);\n-  RNG ( 5,  8,  9, \"%Lg\", 0.123L);\n-  RNG ( 6,  8,  9, \"%Lg\", 0.1234L);\n-  RNG ( 7,  8,  9, \"%Lg\", 0.12345L);\n-  RNG ( 8,  8,  9, \"%Lg\", 0.123456L);\n-\n-  RNG ( 4,  7,  8, \"%Lg\", 0.123e+1L);\n-  EQL (     8,  9, \"%Lg\", 0.123e+12L);\n-  RNG ( 9, 12, 13, \"%Lg\", 0.123e+134L);\n+  RNG ( 3, 13, 14, \"%Lg\", 0.1L);\n+  RNG ( 4, 13, 14, \"%Lg\", 0.12L);\n+  RNG ( 5, 13, 14, \"%Lg\", 0.123L);\n+  RNG ( 6, 13, 14, \"%Lg\", 0.1234L);\n+  RNG ( 7, 13, 14, \"%Lg\", 0.12345L);\n+  RNG ( 8, 13, 14, \"%Lg\", 0.123456L);\n+\n+  RNG ( 4, 12, 13, \"%Lg\", 0.123e+1L);\n+  RNG ( 8, 13, 14, \"%Lg\", 0.123e+12L);\n+  RNG ( 9, 17, 18, \"%Lg\", 0.123e+134L);\n }\n \n static void __attribute__ ((noinline, noclone))"}]}