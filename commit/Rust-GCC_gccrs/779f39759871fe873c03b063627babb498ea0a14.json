{"sha": "779f39759871fe873c03b063627babb498ea0a14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc5ZjM5NzU5ODcxZmU4NzNjMDNiMDYzNjI3YmFiYjQ5OGVhMGExNA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2007-01-06T00:14:38Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2007-01-06T00:14:38Z"}, "message": "re PR libfortran/30162 (Document when sequential I/O with named pipes works)\n\n2007-01-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/30162\n\t* io/unix.c (fd_flush): Don't seek if file is not seekable, defined as\n\ts->file_length == -1.\n\t(fd_alloc_w_at): Do not adjust file_length if file is not seekable.\n\t(fd_seek): If not seekable, just return success.\n\t(fd_truncate): If not seekable, no need to truncate.  Return failure if\n\tseek fails and the stream is not a pipe.\n\t(fd_to_stream): Make test for non-seekable file more robust.\n\nFrom-SVN: r120512", "tree": {"sha": "a8a46189a39b897342e7ac0bada35eb7b4ad16ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8a46189a39b897342e7ac0bada35eb7b4ad16ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/779f39759871fe873c03b063627babb498ea0a14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/779f39759871fe873c03b063627babb498ea0a14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/779f39759871fe873c03b063627babb498ea0a14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/779f39759871fe873c03b063627babb498ea0a14/comments", "author": null, "committer": null, "parents": [{"sha": "59c0753dd31ebc72074a9650182896e0c6f5647a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59c0753dd31ebc72074a9650182896e0c6f5647a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59c0753dd31ebc72074a9650182896e0c6f5647a"}], "stats": {"total": 50, "additions": 39, "deletions": 11}, "files": [{"sha": "5053e04e8a27a5df30658e8f956f26c621d27ed1", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/779f39759871fe873c03b063627babb498ea0a14/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/779f39759871fe873c03b063627babb498ea0a14/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=779f39759871fe873c03b063627babb498ea0a14", "patch": "@@ -1,3 +1,14 @@\n+2007-01-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/30162\n+\t* io/unix.c (fd_flush): Don't seek if file is not seekable, defined as\n+\ts->file_length == -1.\n+\t(fd_alloc_w_at): Do not adjust file_length if file is not seekable.\n+\t(fd_seek): If not seekable, just return success.\n+\t(fd_truncate): If not seekable, no need to truncate.  Return failure if\n+\tseek fails and the stream is not a pipe.\n+\t(fd_to_stream): Make test for non-seekable file more robust.\n+\n 2007-01-01  Steven G. Kargl  <kargls@comcast.net>\n \n \t* ChangeLog: Copied to ..."}, {"sha": "3419d72d75a3f4be6339b9fbb6131348a7c7bd8f", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/779f39759871fe873c03b063627babb498ea0a14/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/779f39759871fe873c03b063627babb498ea0a14/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=779f39759871fe873c03b063627babb498ea0a14", "patch": "@@ -349,9 +349,9 @@ fd_flush (unix_stream * s)\n   size_t writelen;\n \n   if (s->ndirty == 0)\n-    return SUCCESS;;\n-\n-  if (s->physical_offset != s->dirty_offset &&\n+    return SUCCESS;\n+  \n+  if (s->file_length != -1 && s->physical_offset != s->dirty_offset &&\n       lseek (s->fd, s->dirty_offset, SEEK_SET) < 0)\n     return FAILURE;\n \n@@ -536,8 +536,10 @@ fd_alloc_w_at (unix_stream * s, int *len, gfc_offset where)\n \n   s->logical_offset = where + *len;\n \n-  if (where + *len > s->file_length)\n-    s->file_length = where + *len;\n+  /* Don't increment file_length if the file is non-seekable.  */\n+\n+  if (s->file_length != -1 && s->logical_offset > s->file_length)\n+     s->file_length = s->logical_offset;\n \n   n = s->logical_offset - s->buffer_offset;\n   if (n > s->active)\n@@ -562,6 +564,10 @@ fd_sfree (unix_stream * s)\n static try\n fd_seek (unix_stream * s, gfc_offset offset)\n {\n+\n+  if (s->file_length == -1)\n+    return SUCCESS;\n+\n   if (s->physical_offset == offset) /* Are we lucky and avoid syscall?  */\n     {\n       s->logical_offset = offset;\n@@ -582,13 +588,19 @@ fd_seek (unix_stream * s, gfc_offset offset)\n static try\n fd_truncate (unix_stream * s)\n {\n+  /* Non-seekable files, like terminals and fifo's fail the lseek so just\n+     return success, there is nothing to truncate.  If its not a pipe there\n+     is a real problem.  */\n   if (lseek (s->fd, s->logical_offset, SEEK_SET) == -1)\n-    return FAILURE;\n+    {\n+      if (errno == ESPIPE)\n+\treturn SUCCESS;\n+      else\n+\treturn FAILURE;\n+    }\n \n-  /* non-seekable files, like terminals and fifo's fail the lseek.\n-     Using ftruncate on a seekable special file (like /dev/null)\n-     is undefined, so we treat it as if the ftruncate succeeded.\n-  */\n+  /* Using ftruncate on a seekable special file (like /dev/null)\n+     is undefined, so we treat it as if the ftruncate succeeded.  */\n #ifdef HAVE_FTRUNCATE\n   if (s->special_file || ftruncate (s->fd, s->logical_offset))\n #else\n@@ -1009,7 +1021,12 @@ fd_to_stream (int fd, int prot)\n   /* Get the current length of the file. */\n \n   fstat (fd, &statbuf);\n-  s->file_length = S_ISREG (statbuf.st_mode) ? statbuf.st_size : -1;\n+\n+  if (lseek (fd, 0, SEEK_CUR) == (off_t) -1)\n+    s->file_length = -1;\n+  else\n+    s->file_length = S_ISREG (statbuf.st_mode) ? statbuf.st_size : -1;\n+\n   s->special_file = !S_ISREG (statbuf.st_mode);\n \n   fd_open (s);"}]}