{"sha": "3e02b1c3e85584cb8d944fe4cd3c94eea723c77b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2UwMmIxYzNlODU1ODRjYjhkOTQ0ZmU0Y2QzYzk0ZWVhNzIzYzc3Yg==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2001-03-23T17:31:42Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2001-03-23T17:31:42Z"}, "message": "gcj.texi (Configure-time Options): Add -fcheck-references.\n\n2001-02-07  Andrew Haley  <aph@redhat.com>\n\n\t* gcj.texi (Configure-time Options): Add -fcheck-references.\n\t* expr.c (build_java_indirect_ref): New function.\n\t(java_check_reference): New function.\n\t(build_java_array_length_access): Use build_java_indirect_ref to\n\tcheck for null references.\n\t(build_java_arrayaccess): Likewise.\n\t(build_get_class): Likewise.\n\t(build_field_ref): Likewise.\n\t(invoke_build_dtable): Likewise.\n\t(build_invokeinterface): Likewise.\n\t* lang.c (lang_f_options): Add flag_check_references.\n\t* jvspec.c (jvgenmain_spec): Add flag_check_references.\n\t* java-tree.h (flag_check_references): New variable.\n\t* lang.c (flag_check_references): Likewise.\n\t* parse.y (patch_invoke): Use java_check_reference.\n\t(patch_assignment): Allow for extra nesting in\n\t_Jv_CheckArrayStore.\n\nFrom-SVN: r40782", "tree": {"sha": "503104ab7465171bd52a6ef2b4bb97773e704bff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/503104ab7465171bd52a6ef2b4bb97773e704bff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e02b1c3e85584cb8d944fe4cd3c94eea723c77b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e02b1c3e85584cb8d944fe4cd3c94eea723c77b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e02b1c3e85584cb8d944fe4cd3c94eea723c77b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e02b1c3e85584cb8d944fe4cd3c94eea723c77b/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "25caaba84b328d4db7c8e23b73f0aa575876b53b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25caaba84b328d4db7c8e23b73f0aa575876b53b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25caaba84b328d4db7c8e23b73f0aa575876b53b"}], "stats": {"total": 46, "additions": 21, "deletions": 25}, "files": [{"sha": "18d3b5c71e82c3d535c51b6d4fa89c4337eb9ede", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e02b1c3e85584cb8d944fe4cd3c94eea723c77b/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e02b1c3e85584cb8d944fe4cd3c94eea723c77b/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=3e02b1c3e85584cb8d944fe4cd3c94eea723c77b", "patch": "@@ -2,6 +2,7 @@\n \n \t* gcj.texi (Configure-time Options): Add -fcheck-references.\n \t* expr.c (build_java_indirect_ref): New function.\n+\t(java_check_reference): New function.\n \t(build_java_array_length_access): Use build_java_indirect_ref to\n \tcheck for null references.\n \t(build_java_arrayaccess): Likewise.\n@@ -13,6 +14,9 @@\n \t* jvspec.c (jvgenmain_spec): Add flag_check_references.\n \t* java-tree.h (flag_check_references): New variable.\n \t* lang.c (flag_check_references): Likewise.\n+\t* parse.y (patch_invoke): Use java_check_reference.\t\n+\t(patch_assignment): Allow for extra nesting in\n+\t_Jv_CheckArrayStore.\n \n 2001-03-23  Bryce McKinlay  <bryce@albatross.co.nz>\n "}, {"sha": "bc7da303bf6d52b8034bd2d412a7e4ff493b9695", "filename": "gcc/java/parse.y", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e02b1c3e85584cb8d944fe4cd3c94eea723c77b/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e02b1c3e85584cb8d944fe4cd3c94eea723c77b/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=3e02b1c3e85584cb8d944fe4cd3c94eea723c77b", "patch": "@@ -8922,8 +8922,7 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n       && ! flag_emit_class_files && ! flag_emit_xref)\n     {\n       tree length = build_java_array_length_access (where_found);\n-      field_ref =\n-\tbuild_java_arraynull_check (type_found, length, int_type_node);\n+      field_ref = length;\n \n       /* In case we're dealing with a static array, we need to\n \t initialize its class before the array length can be fetched.\n@@ -10196,7 +10195,7 @@ patch_invoke (patch, method, args)\n {\n   tree dtable, func;\n   tree original_call, t, ta;\n-  tree cond = NULL_TREE;\n+  tree check = NULL_TREE;\n \n   /* Last step for args: convert build-in types. If we're dealing with\n      a new TYPE() type call, the first argument to the constructor\n@@ -10235,12 +10234,11 @@ patch_invoke (patch, method, args)\n \t     optimization pass to eliminate redundant checks.  */\n \t  if (TREE_VALUE (args) != current_this)\n \t    {\n-\t      /* We use a SAVE_EXPR here to make sure we only evaluate\n+\t      /* We use a save_expr here to make sure we only evaluate\n \t\t the new `self' expression once.  */\n \t      tree save_arg = save_expr (TREE_VALUE (args));\n \t      TREE_VALUE (args) = save_arg;\n-\t      cond = build (EQ_EXPR, boolean_type_node, save_arg,\n-\t\t\t    null_pointer_node);\n+\t      check = java_check_reference (save_arg, 1);\n \t    }\n \t  /* Fall through.  */\n \n@@ -10300,22 +10298,11 @@ patch_invoke (patch, method, args)\n       patch = build (COMPOUND_EXPR, TREE_TYPE (new), patch, saved_new);\n     }\n \n-  /* If COND is set, then we are building a check to see if the object\n+  /* If CHECK is set, then we are building a check to see if the object\n      is NULL.  */\n-  if (cond != NULL_TREE)\n-    {\n-      /* We have to make the `then' branch a compound expression to\n-\t make the types turn out right.  This seems bizarre.  */\n-      patch = build (COND_EXPR, TREE_TYPE (patch), cond,\n-\t\t     build (COMPOUND_EXPR, TREE_TYPE (patch),\n-\t\t\t    build (CALL_EXPR, void_type_node,\n-\t\t\t\t   build_address_of (soft_nullpointer_node),\n-\t\t\t\t   NULL_TREE, NULL_TREE),\n-\t\t\t    (FLOAT_TYPE_P (TREE_TYPE (patch))\n-\t\t\t     ? build_real (TREE_TYPE (patch), dconst0)\n-\t\t\t     : build1 (CONVERT_EXPR, TREE_TYPE (patch),\n-\t\t\t\t       integer_zero_node))),\n-\t\t     patch);\n+  if (check != NULL_TREE)\n+    {\n+      patch = build (COMPOUND_EXPR, TREE_TYPE (patch), check, patch);\n       TREE_SIDE_EFFECTS (patch) = 1;\n     }\n \n@@ -12525,15 +12512,20 @@ patch_assignment (node, wfl_op1, wfl_op2)\n       tree check;\n       tree base = lvalue;\n \n-      /* We need to retrieve the right argument for _Jv_CheckArrayStore */\n+      /* We need to retrieve the right argument for\n+         _Jv_CheckArrayStore.  This is somewhat complicated by bounds\n+         and null pointer checks, both of which wrap the operand in\n+         one layer of COMPOUND_EXPR.  */\n       if (TREE_CODE (lvalue) == COMPOUND_EXPR)\n \tbase = TREE_OPERAND (lvalue, 0);\n       else\n \t{\n+\t  base = TREE_OPERAND (base, 0);\n \t  if (flag_bounds_check)\n-\t    base = TREE_OPERAND (TREE_OPERAND (TREE_OPERAND (base, 0), 1), 0);\n-\t  else\n-\t    base = TREE_OPERAND (TREE_OPERAND (base, 0), 0);\n+\t    base = TREE_OPERAND (base, 1);\n+\t  if (flag_check_references)\n+\t    base = TREE_OPERAND (base, 1);\n+\t  base = TREE_OPERAND (base, 0);\t\n \t}\n \n       /* Build the invocation of _Jv_CheckArrayStore */"}]}