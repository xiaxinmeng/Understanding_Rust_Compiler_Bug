{"sha": "c51b04ec33fea61e89363fd5c94e38b4df8b12c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzUxYjA0ZWMzM2ZlYTYxZTg5MzYzZmQ1Yzk0ZTM4YjRkZjhiMTJjMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-04-03T12:30:16Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-04-03T12:30:16Z"}, "message": "re PR rtl-optimization/84101 (-O3 and -ftree-vectorize trying too hard for function returning trivial pair-of-uint64_t-structure)\n\n2019-04-03  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/84101\n\t* tree-vect-stmts.c: Include explow.h for hard_function_value,\n\tregs.h for hard_regno_nregs.\n\t(cfun_returns): New helper.\n\t(vect_model_store_cost): When vectorizing a store to a decl\n\twe return and the function ABI returns in a multi-reg location\n\taccount for the possible spilling that will happen.\n\n\t* gcc.target/i386/pr84101.c: New testcase.\n\nFrom-SVN: r270123", "tree": {"sha": "e7440e6cfa50fa3d5c54a54a830a3e63472e22b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7440e6cfa50fa3d5c54a54a830a3e63472e22b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c51b04ec33fea61e89363fd5c94e38b4df8b12c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c51b04ec33fea61e89363fd5c94e38b4df8b12c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c51b04ec33fea61e89363fd5c94e38b4df8b12c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c51b04ec33fea61e89363fd5c94e38b4df8b12c1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "615792b72e34b084e4aa69aad7789f2ee30e2eed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/615792b72e34b084e4aa69aad7789f2ee30e2eed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/615792b72e34b084e4aa69aad7789f2ee30e2eed"}], "stats": {"total": 100, "additions": 100, "deletions": 0}, "files": [{"sha": "9149d9c9a9eeeabb604979ba8dd64f9e4118fcb1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c51b04ec33fea61e89363fd5c94e38b4df8b12c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c51b04ec33fea61e89363fd5c94e38b4df8b12c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c51b04ec33fea61e89363fd5c94e38b4df8b12c1", "patch": "@@ -1,3 +1,13 @@\n+2019-04-03  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/84101\n+\t* tree-vect-stmts.c: Include explow.h for hard_function_value,\n+\tregs.h for hard_regno_nregs.\n+\t(cfun_returns): New helper.\n+\t(vect_model_store_cost): When vectorizing a store to a decl\n+\twe return and the function ABI returns in a multi-reg location\n+\taccount for the possible spilling that will happen.\n+\n 2019-04-03  Andreas Krebbel  <krebbel@linux.ibm.com>\n \n \t* config/s390/s390.c (s390_legitimate_address_p): Reject long"}, {"sha": "94729eed46caebf3530b88b3c85a2797034611b8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c51b04ec33fea61e89363fd5c94e38b4df8b12c1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c51b04ec33fea61e89363fd5c94e38b4df8b12c1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c51b04ec33fea61e89363fd5c94e38b4df8b12c1", "patch": "@@ -1,3 +1,8 @@\n+2019-04-03  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/84101\n+\t* gcc.target/i386/pr84101.c: New testcase.\n+\n 2019-04-02  Jeff Law  <law@redhat.com>\n \n \t* gcc.target/visium/bit_shift.c: xfail."}, {"sha": "006e6a455d9ba49d23aa6502ec13f1f040e09106", "filename": "gcc/testsuite/gcc.target/i386/pr84101.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c51b04ec33fea61e89363fd5c94e38b4df8b12c1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr84101.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c51b04ec33fea61e89363fd5c94e38b4df8b12c1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr84101.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr84101.c?ref=c51b04ec33fea61e89363fd5c94e38b4df8b12c1", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-slp2-details\" } */\n+\n+typedef struct uint64_pair uint64_pair_t ;\n+struct uint64_pair\n+{\n+  unsigned long w0 ;\n+  unsigned long w1 ;\n+} ;\n+\n+uint64_pair_t pair(int num)\n+{\n+  uint64_pair_t p ;\n+\n+  p.w0 = num << 1 ;\n+  p.w1 = num >> 1 ;\n+\n+  return p ;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"basic block vectorized\" \"slp2\" } } */"}, {"sha": "2388c93af34dc85fef4424289279682d2af0141d", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c51b04ec33fea61e89363fd5c94e38b4df8b12c1/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c51b04ec33fea61e89363fd5c94e38b4df8b12c1/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=c51b04ec33fea61e89363fd5c94e38b4df8b12c1", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-cfg.h\"\n #include \"tree-ssa-loop-manip.h\"\n #include \"cfgloop.h\"\n+#include \"explow.h\"\n #include \"tree-ssa-loop.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"tree-vectorizer.h\"\n@@ -52,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vec-perm-indices.h\"\n #include \"tree-ssa-loop-niter.h\"\n #include \"gimple-fold.h\"\n+#include \"regs.h\"\n \n /* For lang_hooks.types.type_for_mode.  */\n #include \"langhooks.h\"\n@@ -948,6 +950,37 @@ vect_model_promotion_demotion_cost (stmt_vec_info stmt_info,\n                      \"prologue_cost = %d .\\n\", inside_cost, prologue_cost);\n }\n \n+/* Returns true if the current function returns DECL.  */\n+\n+static bool\n+cfun_returns (tree decl)\n+{\n+  edge_iterator ei;\n+  edge e;\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n+    {\n+      greturn *ret = safe_dyn_cast <greturn *> (last_stmt (e->src));\n+      if (!ret)\n+\tcontinue;\n+      if (gimple_return_retval (ret) == decl)\n+\treturn true;\n+      /* We often end up with an aggregate copy to the result decl,\n+         handle that case as well.  First skip intermediate clobbers\n+\t though.  */\n+      gimple *def = ret;\n+      do\n+\t{\n+\t  def = SSA_NAME_DEF_STMT (gimple_vuse (def));\n+\t}\n+      while (gimple_clobber_p (def));\n+      if (is_a <gassign *> (def)\n+\t  && gimple_assign_lhs (def) == gimple_return_retval (ret)\n+\t  && gimple_assign_rhs1 (def) == decl)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Function vect_model_store_cost\n \n    Models cost for stores.  In the case of grouped accesses, one access\n@@ -1032,6 +1065,37 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n \t\t\t\t       vec_to_scalar, stmt_info, 0, vect_body);\n     }\n \n+  /* When vectorizing a store into the function result assign\n+     a penalty if the function returns in a multi-register location.\n+     In this case we assume we'll end up with having to spill the\n+     vector result and do piecewise loads as a conservative estimate.  */\n+  tree base = get_base_address (STMT_VINFO_DATA_REF (stmt_info)->ref);\n+  if (base\n+      && (TREE_CODE (base) == RESULT_DECL\n+\t  || (DECL_P (base) && cfun_returns (base)))\n+      && !aggregate_value_p (base, cfun->decl))\n+    {\n+      rtx reg = hard_function_value (TREE_TYPE (base), cfun->decl, 0, 1);\n+      /* ???  Handle PARALLEL in some way.  */\n+      if (REG_P (reg))\n+\t{\n+\t  int nregs = hard_regno_nregs (REGNO (reg), GET_MODE (reg));\n+\t  /* Assume that a single reg-reg move is possible and cheap,\n+\t     do not account for vector to gp register move cost.  */\n+\t  if (nregs > 1)\n+\t    {\n+\t      /* Spill.  */\n+\t      prologue_cost += record_stmt_cost (cost_vec, ncopies,\n+\t\t\t\t\t\t vector_store,\n+\t\t\t\t\t\t stmt_info, 0, vect_epilogue);\n+\t      /* Loads.  */\n+\t      prologue_cost += record_stmt_cost (cost_vec, ncopies * nregs,\n+\t\t\t\t\t\t scalar_load,\n+\t\t\t\t\t\t stmt_info, 0, vect_epilogue);\n+\t    }\n+\t}\n+    }\n+\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"vect_model_store_cost: inside_cost = %d, \""}]}