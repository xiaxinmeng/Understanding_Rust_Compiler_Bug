{"sha": "11cf25c40e3f586d19474108c78a2dfad7925902", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTFjZjI1YzQwZTNmNTg2ZDE5NDc0MTA4Yzc4YTJkZmFkNzkyNTkwMg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-03-18T12:16:28Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-03-18T12:16:28Z"}, "message": "PR c++/94147 - mangling of lambdas assigned to globals\n\nThis patch implements Jason's suggestion of pushing a lambda scope\nwhen parsing a global variable initializer.  That bit worked fine, but\nhappened to cause g++.dg/opt/dump1.C to not give any\nused-but-not-defined warnings.\n\nThe reason was no_linkage_check, which considers any lambda that has\nan extra-scope to have linkage.  Which is technically correct.  Except\nthat we think that all types that have linkage have external linkage.\n\nOur representation of linkage and visibility is somewhat inaccurate,\nparticularly when it comes to types.  We have TREE_PUBLIC,\nDECL_EXTERNAL, DECL_VISIBILITY, DECL_COMDAT, DECL_NOT_REALLY_EXTERN.\nIt could really do with a through cleanup, but that won't be a simple\ntask.\n\nThe best I could come up with was seeing if the extra scope was a\nVAR_DECL, and if that was TREE_PUBLIC and the var was inline (its\nCOMDATness is sadly not set at that point) or a template\ninstantiation, then the lambda had linkage.  Otherwise it's as-if it\nhas no-linkage from the POV of compiler internals.\n\nThis is an ABI change (so we should document it), but it's changing\nmangling from an unpredictable (in practice) counter, to something the\nABI defines.  So I'm not concerned about mangling-changed warnings, or\npreserving the broken mangling under some ABI selection flag.  Code\nthat did this worked by accident within a single TU.  It'll continue\nto work by design there, and across TUs.\n\n\t* parser.c (cp_parser_init_declarator): Namespace-scope variables\n\tprovide a lambda scope.\n\t* tree.c (no_linkage_check): Lambdas with a variable for extra\n\tscope have a linkage from the variable.", "tree": {"sha": "26063674dc76d9ded651520bc6f5b2b16139a3f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26063674dc76d9ded651520bc6f5b2b16139a3f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11cf25c40e3f586d19474108c78a2dfad7925902", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11cf25c40e3f586d19474108c78a2dfad7925902", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11cf25c40e3f586d19474108c78a2dfad7925902", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11cf25c40e3f586d19474108c78a2dfad7925902/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ba9acb11e3589b96ed945ed2a3af6acd6377018", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ba9acb11e3589b96ed945ed2a3af6acd6377018", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ba9acb11e3589b96ed945ed2a3af6acd6377018"}], "stats": {"total": 101, "additions": 92, "deletions": 9}, "files": [{"sha": "bb5f77f4db16e43603a5830f8e9ed1cac7b2d914", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11cf25c40e3f586d19474108c78a2dfad7925902/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11cf25c40e3f586d19474108c78a2dfad7925902/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=11cf25c40e3f586d19474108c78a2dfad7925902", "patch": "@@ -1,3 +1,11 @@\n+2020-03-18  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/94147 - mangling of lambdas assigned to globals\n+\t* parser.c (cp_parser_init_declarator): Namespace-scope variables\n+\tprovide a lambda scope.\n+\t* tree.c (no_linkage_check): Lambdas with a variable for extra\n+\tscope have a linkage from the variable.\n+\n 2020-03-18  Jakub Jelinek  <jakub@redhat.com>\n \n \t* constraint.cc (resolve_function_concept_check, subsumes_constraints,"}, {"sha": "198ab975e562fa1a36e72dd84cec648d6189c94c", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11cf25c40e3f586d19474108c78a2dfad7925902/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11cf25c40e3f586d19474108c78a2dfad7925902/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=11cf25c40e3f586d19474108c78a2dfad7925902", "patch": "@@ -20761,16 +20761,24 @@ cp_parser_init_declarator (cp_parser* parser,\n       else\n \t{\n \t  /* We want to record the extra mangling scope for in-class\n-\t     initializers of class members and initializers of static data\n-\t     member templates.  The former involves deferring\n-\t     parsing of the initializer until end of class as with default\n-\t     arguments.  So right here we only handle the latter.  */\n-\t  if (!member_p && processing_template_decl && decl != error_mark_node)\n+\t     initializers of class members and initializers of static\n+\t     data member templates and namespace-scope initializers.\n+\t     The former involves deferring parsing of the initializer\n+\t     until end of class as with default arguments.  So right\n+\t     here we only handle the latter two.  */\n+\t  bool has_lambda_scope = false;\n+\n+\t  if (decl != error_mark_node\n+\t      && !member_p\n+\t      && (processing_template_decl || DECL_NAMESPACE_SCOPE_P (decl)))\n+\t    has_lambda_scope = true;\n+\n+\t  if (has_lambda_scope)\n \t    start_lambda_scope (decl);\n \t  initializer = cp_parser_initializer (parser,\n \t\t\t\t\t       &is_direct_init,\n \t\t\t\t\t       &is_non_constant_init);\n-\t  if (!member_p && processing_template_decl && decl != error_mark_node)\n+\t  if (has_lambda_scope)\n \t    finish_lambda_scope ();\n \t  if (initializer == error_mark_node)\n \t    cp_parser_skip_to_end_of_statement (parser);"}, {"sha": "da2e7fdcca3031f052b0415f80f77352f47c1bea", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11cf25c40e3f586d19474108c78a2dfad7925902/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11cf25c40e3f586d19474108c78a2dfad7925902/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=11cf25c40e3f586d19474108c78a2dfad7925902", "patch": "@@ -2794,9 +2794,23 @@ no_linkage_check (tree t, bool relaxed_p)\n      fix it up later if not.  We need to check this even in templates so\n      that we properly handle a lambda-expression in the signature.  */\n   if (LAMBDA_TYPE_P (t)\n-      && CLASSTYPE_LAMBDA_EXPR (t) != error_mark_node\n-      && LAMBDA_TYPE_EXTRA_SCOPE (t) == NULL_TREE)\n-    return t;\n+      && CLASSTYPE_LAMBDA_EXPR (t) != error_mark_node)\n+    {\n+      tree extra = LAMBDA_TYPE_EXTRA_SCOPE (t);\n+      if (!extra)\n+\treturn t;\n+\n+      /* If the mangling scope is internal-linkage or not repeatable\n+\t elsewhere, the lambda effectively has no linkage.  (Sadly\n+\t we're not very careful with the linkages of types.)  */\n+      if (TREE_CODE (extra) == VAR_DECL\n+\t  && !(TREE_PUBLIC (extra)\n+\t       && (processing_template_decl\n+\t\t   || (DECL_LANG_SPECIFIC (extra) && DECL_USE_TEMPLATE (extra))\n+\t\t   /* DECL_COMDAT is set too late for us to check.  */\n+\t\t   || DECL_VAR_DECLARED_INLINE_P (extra))))\n+\treturn t;\n+    }\n \n   /* Otherwise there's no point in checking linkage on template functions; we\n      can't know their complete types.  */"}, {"sha": "c3eb157dc20889e22f89d42dc4f88499abbd01a9", "filename": "gcc/testsuite/g++.dg/abi/lambda-vis.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11cf25c40e3f586d19474108c78a2dfad7925902/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flambda-vis.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11cf25c40e3f586d19474108c78a2dfad7925902/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flambda-vis.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flambda-vis.C?ref=11cf25c40e3f586d19474108c78a2dfad7925902", "patch": "@@ -0,0 +1,23 @@\n+// { dg-do compile { target c++17 } }\n+// { dg-options \"-fno-inline\" }\n+\n+template<typename T> int sfoo (T); // { dg-warning \"used but never defined\" }\n+template<typename T> int gfoo (T); // { dg-warning \"used but never defined\" }\n+template<typename T> int ifoo (T); // OK\n+template<typename T> struct Wrapper {};\n+template<typename T> Wrapper<T> capture (T &&) {return Wrapper<T> ();}\n+\n+static int svar = sfoo (capture ([]{}));\n+\n+int gvar = gfoo (capture ([]{}));\n+\n+inline int ivar = ifoo (capture ([]{}));\n+\n+// { dg-final { scan-assembler {_Z7captureINL4svarMUlvE_EE7WrapperIT_EOS2_:} } }\n+// { dg-final { scan-assembler {_Z7captureIN4gvarMUlvE_EE7WrapperIT_EOS2_:} } }\n+// { dg-final { scan-assembler {_Z7captureIN4ivarMUlvE_EE7WrapperIT_EOS2_:} } }\n+\n+// Calls to the foos are emitted.\n+// { dg-final { scan-assembler {call[ \\t]*_Z4sfooI7WrapperINL4svarMUlvE_EEEiT_} { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler {call[ \\t]*_Z4gfooI7WrapperIN4gvarMUlvE_EEEiT_} { target { i?86-*-* x86_64-*-* } } } }\n+// { dg-final { scan-assembler {call[ \\t]*_Z4ifooI7WrapperIN4ivarMUlvE_EEEiT_} { target { i?86-*-* x86_64-*-* } } } }"}, {"sha": "4e1c63290396d5daad66d178e69252880284b4ff", "filename": "gcc/testsuite/g++.dg/abi/mangle74.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11cf25c40e3f586d19474108c78a2dfad7925902/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle74.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11cf25c40e3f586d19474108c78a2dfad7925902/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle74.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle74.C?ref=11cf25c40e3f586d19474108c78a2dfad7925902", "patch": "@@ -0,0 +1,30 @@\n+// { dg-do compile { target c++17 } }\n+// { dg-options \"-fno-inline -O0\" }\n+\n+inline auto var = [] () {return 2;};\n+\n+int bob ()\n+{\n+return var ();\n+}\n+\n+struct Foo\n+{\n+  static inline auto bar = [] () {return 4;};\n+};\n+\n+int bill ()\n+{\n+  return Foo::bar ();\n+}\n+\n+// this one should have internal linkage (from svar)\n+static auto svar = [] () {return 8;};\n+int thorn ()\n+{\n+  return svar ();\n+}\n+\n+// { dg-final { scan-assembler \"_ZNK3varMUlvE_clEv:\" } }\n+// { dg-final { scan-assembler \"_ZNK3Foo3barMUlvE_clEv:\" { xfail *-*-* } } }\n+// { dg-final { scan-assembler-not \"_ZNK3FooUlvE_clEv:\" { xfail *-*-* } } }"}]}