{"sha": "7c1dab0d8b4eef485b57813e1bb68542980db377", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2MxZGFiMGQ4YjRlZWY0ODViNTc4MTNlMWJiNjg1NDI5ODBkYjM3Nw==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2009-11-30T20:43:06Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2009-11-30T20:43:06Z"}, "message": "backport: re PR fortran/42053 ([OOP] SELECT TYPE: reject duplicate CLASS IS blocks)\n\nmerge from fortran-dev branch:\n\n\ngcc/fortran/\n\n2009-11-30  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/42053\n\t* resolve.c (resolve_select_type): Check for duplicate CLASS IS blocks.\n\n2009-11-30  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/41631\n\t* decl.c (gfc_match_derived_decl): Set extension level.\n\t* gfortran.h (symbol_attribute): Expand 'extension' bit field to 8 bit.\n\t* iresolve.c (gfc_resolve_extends_type_of): Return value of\n\t'is_extension_of' has kind=4.\n\t* match.c (select_type_set_tmp,gfc_match_class_is): Create temporary\n\tfor CLASS IS blocks.\n\t* module.c (MOD_VERSION): Bump module version.\n\t(ab_attribute,attr_bits): Remove AB_EXTENSION.\n\t(mio_symbol_attribute): Handle expanded 'extension' field.\n\t* resolve.c (resolve_select_type): Implement CLASS IS blocks.\n\t(resolve_fl_variable_derived): Show correct type name.\n\t* symbol.c (gfc_build_class_symbol): Set extension level.\n\n2009-11-30  Janus Weil  <janus@gcc.gnu.org>\n\n\t* intrinsic.h (gfc_resolve_extends_type_of): Add prototype.\n\t* intrinsic.c (add_functions): Use 'gfc_resolve_extends_type_of'.\n\t* iresolve.c (gfc_resolve_extends_type_of): New function, which\n\treplaces the call to EXTENDS_TYPE_OF by the library function\n\t'is_extension_of' and modifies the arguments.\n\t* trans-intrinsic.c (gfc_conv_extends_type_of): Removed.\n\t(gfc_conv_intrinsic_function): FOR EXTENDS_TYPE_OF, don't call\n\tgfc_conv_extends_type_of but gfc_conv_intrinsic_funcall.\n\n2009-11-30  Paul Thomas  <pault@gcc.gnu.org>\n\t    Janus Weil  <janus@gcc.gnu.org>\n\n\t* decl.c (encapsulate_class_symbol): Replaced by\n\t'gfc_build_class_symbol'.\n\t(build_sym,build_struct): Call 'gfc_build_class_symbol'.\n\t(gfc_match_derived_decl): Replace vindex by hash_value.\n\t* dump-parse-tree.c (show_symbol): Replace vindex by hash_value.\n\t* gfortran.h (symbol_attribute): Add field 'vtab'.\n\t(gfc_symbol): Replace vindex by hash_value.\n\t(gfc_class_esym_list): Ditto.\n\t(gfc_get_derived_type,gfc_build_class_symbol,gfc_find_derived_vtab):\n\tNew prototypes.\n\t* module.c (mio_symbol): Replace vindex by hash_value.\n\t* resolve.c (vindex_expr): Rename to 'hash_value_expr'.\n\t(resolve_class_compcall,resolve_class_typebound_call): Renamed\n\t'vindex_expr'.\n\t(resolve_select_type): Replace $vindex by $vptr->$hash.\n\t* symbol.c (gfc_add_save): Handle vtab symbols.\n\t(gfc_type_compatible): Rewrite.\n\t(gfc_build_class_symbol): New function which replaces\n\t'encapsulate_class_symbol'.\n\t(gfc_find_derived_vtab): New function to set up a vtab symbol for a\n\tderived type.\n\t* trans-decl.c (gfc_create_module_variable): Handle vtab symbols.\n\t* trans-expr.c (select_class_proc): Replace vindex by hash_value.\n\t(gfc_conv_derived_to_class): New function to construct a temporary\n\tCLASS variable from a derived type expression.\n\t(gfc_conv_procedure_call): Call 'gfc_conv_derived_to_class'.\n\t(gfc_conv_structure): Initialize the $extends and $size fields of\n\tvtab symbols.\n\t(gfc_trans_class_assign): Replace $vindex by $vptr. Remove the $size\n\tassignment.\n\t* trans-intrinsic.c (gfc_conv_same_type_as): Replace $vindex by\n\t$vptr->$hash, and replace vindex by hash_value.\n\t* trans-stmt.c (gfc_trans_allocate): Insert $vptr references, replace\n\t$vindex by $vptr. Remove the $size assignment.\n\t* trans-types.c (gfc_get_derived_type): Make it non-static.\n\n\ngcc/testsuite/\n\n2009-11-30  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/42053\n\t* gfortran.dg/select_type_9.f03: New.\n\n2009-11-30  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/41631\n\t* gfortran.dg/extends_type_of_1.f03: Fix invalid test case.\n\t* gfortran.dg/module_md5_1.f90: Adjusted MD5 sum.\n\t* gfortran.dg/select_type_1.f03: Remove FIXMEs.\n\t* gfortran.dg/select_type_2.f03: Ditto.\n\t* gfortran.dg/select_type_8.f03: New test.\n\n2009-11-30  Janus Weil  <janus@gcc.gnu.org>\n\n\t* gfortran.dg/extends_type_of_1.f03: New test.\n\t* gfortran.dg/same_type_as_1.f03: Extended.\n\n2009-11-30  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* gfortran.dg/class_4c.f03: Add dg-additional-sources.\n\t* gfortran.dg/class_4d.f03: Rename module. Cleanup modules.\n\n\nlibgfortran/\n\n2009-11-30  Janus Weil  <janus@gcc.gnu.org>\n\n\t* gfortran.map: Add _gfortran_is_extension_of.\n\t* Makefile.am: Add intrinsics/extends_type_of.c.\n\t* Makefile.in: Regenerated.\n\t* intrinsics/extends_type_of.c: New file.\n\nFrom-SVN: r154840", "tree": {"sha": "eb3f94ac7e5dce3bab07de0ef89ed721495219c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb3f94ac7e5dce3bab07de0ef89ed721495219c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c1dab0d8b4eef485b57813e1bb68542980db377", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c1dab0d8b4eef485b57813e1bb68542980db377", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c1dab0d8b4eef485b57813e1bb68542980db377", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c1dab0d8b4eef485b57813e1bb68542980db377/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8146bb588770d63c8f4a2ca2a1eb31d3643b71bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8146bb588770d63c8f4a2ca2a1eb31d3643b71bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8146bb588770d63c8f4a2ca2a1eb31d3643b71bc"}], "stats": {"total": 1372, "additions": 1017, "deletions": 355}, "files": [{"sha": "976061a6151f897b4e24035c2d943852d913d159", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -1,3 +1,74 @@\n+2009-11-30  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/42053\n+\t* resolve.c (resolve_select_type): Check for duplicate CLASS IS blocks.\n+\n+2009-11-30  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/41631\n+\t* decl.c (gfc_match_derived_decl): Set extension level.\n+\t* gfortran.h (symbol_attribute): Expand 'extension' bit field to 8 bit.\n+\t* iresolve.c (gfc_resolve_extends_type_of): Return value of\n+\t'is_extension_of' has kind=4.\n+\t* match.c (select_type_set_tmp,gfc_match_class_is): Create temporary\n+\tfor CLASS IS blocks.\n+\t* module.c (MOD_VERSION): Bump module version.\n+\t(ab_attribute,attr_bits): Remove AB_EXTENSION.\n+\t(mio_symbol_attribute): Handle expanded 'extension' field.\n+\t* resolve.c (resolve_select_type): Implement CLASS IS blocks.\n+\t(resolve_fl_variable_derived): Show correct type name.\n+\t* symbol.c (gfc_build_class_symbol): Set extension level.\n+\n+2009-11-30  Janus Weil  <janus@gcc.gnu.org>\n+\n+\t* intrinsic.h (gfc_resolve_extends_type_of): Add prototype.\n+\t* intrinsic.c (add_functions): Use 'gfc_resolve_extends_type_of'.\n+\t* iresolve.c (gfc_resolve_extends_type_of): New function, which\n+\treplaces the call to EXTENDS_TYPE_OF by the library function\n+\t'is_extension_of' and modifies the arguments.\n+\t* trans-intrinsic.c (gfc_conv_extends_type_of): Removed.\n+\t(gfc_conv_intrinsic_function): FOR EXTENDS_TYPE_OF, don't call\n+\tgfc_conv_extends_type_of but gfc_conv_intrinsic_funcall.\n+\n+2009-11-30  Paul Thomas  <pault@gcc.gnu.org>\n+\t    Janus Weil  <janus@gcc.gnu.org>\n+\n+\t* decl.c (encapsulate_class_symbol): Replaced by\n+\t'gfc_build_class_symbol'.\n+\t(build_sym,build_struct): Call 'gfc_build_class_symbol'.\n+\t(gfc_match_derived_decl): Replace vindex by hash_value.\n+\t* dump-parse-tree.c (show_symbol): Replace vindex by hash_value.\n+\t* gfortran.h (symbol_attribute): Add field 'vtab'.\n+\t(gfc_symbol): Replace vindex by hash_value.\n+\t(gfc_class_esym_list): Ditto.\n+\t(gfc_get_derived_type,gfc_build_class_symbol,gfc_find_derived_vtab):\n+\tNew prototypes.\n+\t* module.c (mio_symbol): Replace vindex by hash_value.\n+\t* resolve.c (vindex_expr): Rename to 'hash_value_expr'.\n+\t(resolve_class_compcall,resolve_class_typebound_call): Renamed\n+\t'vindex_expr'.\n+\t(resolve_select_type): Replace $vindex by $vptr->$hash.\n+\t* symbol.c (gfc_add_save): Handle vtab symbols.\n+\t(gfc_type_compatible): Rewrite.\n+\t(gfc_build_class_symbol): New function which replaces\n+\t'encapsulate_class_symbol'.\n+\t(gfc_find_derived_vtab): New function to set up a vtab symbol for a\n+\tderived type.\n+\t* trans-decl.c (gfc_create_module_variable): Handle vtab symbols.\n+\t* trans-expr.c (select_class_proc): Replace vindex by hash_value.\n+\t(gfc_conv_derived_to_class): New function to construct a temporary\n+\tCLASS variable from a derived type expression.\n+\t(gfc_conv_procedure_call): Call 'gfc_conv_derived_to_class'.\n+\t(gfc_conv_structure): Initialize the $extends and $size fields of\n+\tvtab symbols.\n+\t(gfc_trans_class_assign): Replace $vindex by $vptr. Remove the $size\n+\tassignment.\n+\t* trans-intrinsic.c (gfc_conv_same_type_as): Replace $vindex by\n+\t$vptr->$hash, and replace vindex by hash_value.\n+\t* trans-stmt.c (gfc_trans_allocate): Insert $vptr references, replace\n+\t$vindex by $vptr. Remove the $size assignment.\n+\t* trans-types.c (gfc_get_derived_type): Make it non-static.\n+\n 2009-11-30  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/42131"}, {"sha": "90f30b321753719cfb1ea029281a3c42e7fcd600", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 16, "deletions": 88, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -1025,88 +1025,6 @@ verify_c_interop_param (gfc_symbol *sym)\n }\n \n \n-/* Build a polymorphic CLASS entity, using the symbol that comes from build_sym.\n-   A CLASS entity is represented by an encapsulating type, which contains the\n-   declared type as '$data' component, plus an integer component '$vindex'\n-   which determines the dynamic type, and another integer '$size', which\n-   contains the size of the dynamic type structure.  */\n-\n-static gfc_try\n-encapsulate_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n-\t\t\t  gfc_array_spec **as)\n-{\n-  char name[GFC_MAX_SYMBOL_LEN + 5];\n-  gfc_symbol *fclass;\n-  gfc_component *c;\n-\n-  /* Determine the name of the encapsulating type.  */\n-  if ((*as) && (*as)->rank && attr->allocatable)\n-    sprintf (name, \".class.%s.%d.a\", ts->u.derived->name, (*as)->rank);\n-  else if ((*as) && (*as)->rank)\n-    sprintf (name, \".class.%s.%d\", ts->u.derived->name, (*as)->rank);\n-  else if (attr->allocatable)\n-    sprintf (name, \".class.%s.a\", ts->u.derived->name);\n-  else\n-    sprintf (name, \".class.%s\", ts->u.derived->name);\n-\n-  gfc_find_symbol (name, ts->u.derived->ns, 0, &fclass);\n-  if (fclass == NULL)\n-    {\n-      gfc_symtree *st;\n-      /* If not there, create a new symbol.  */\n-      fclass = gfc_new_symbol (name, ts->u.derived->ns);\n-      st = gfc_new_symtree (&ts->u.derived->ns->sym_root, name);\n-      st->n.sym = fclass;\n-      gfc_set_sym_referenced (fclass);\n-      fclass->refs++;\n-      fclass->ts.type = BT_UNKNOWN;\n-      fclass->vindex = ts->u.derived->vindex;\n-      fclass->attr.abstract = ts->u.derived->attr.abstract;\n-      if (ts->u.derived->f2k_derived)\n-\tfclass->f2k_derived = gfc_get_namespace (NULL, 0);\n-      if (gfc_add_flavor (&fclass->attr, FL_DERIVED,\n-\t  NULL, &gfc_current_locus) == FAILURE)\n-\treturn FAILURE;\n-\n-      /* Add component '$data'.  */\n-      if (gfc_add_component (fclass, \"$data\", &c) == FAILURE)\n-   \treturn FAILURE;\n-      c->ts = *ts;\n-      c->ts.type = BT_DERIVED;\n-      c->attr.access = ACCESS_PRIVATE;\n-      c->ts.u.derived = ts->u.derived;\n-      c->attr.pointer = attr->pointer || attr->dummy;\n-      c->attr.allocatable = attr->allocatable;\n-      c->attr.dimension = attr->dimension;\n-      c->attr.abstract = ts->u.derived->attr.abstract;\n-      c->as = (*as);\n-      c->initializer = gfc_get_expr ();\n-      c->initializer->expr_type = EXPR_NULL;\n-\n-      /* Add component '$vindex'.  */\n-      if (gfc_add_component (fclass, \"$vindex\", &c) == FAILURE)\n-   \treturn FAILURE;\n-      c->ts.type = BT_INTEGER;\n-      c->ts.kind = 4;\n-      c->attr.access = ACCESS_PRIVATE;\n-      c->initializer = gfc_int_expr (0);\n-\n-      /* Add component '$size'.  */\n-      if (gfc_add_component (fclass, \"$size\", &c) == FAILURE)\n-   \treturn FAILURE;\n-      c->ts.type = BT_INTEGER;\n-      c->ts.kind = 4;\n-      c->attr.access = ACCESS_PRIVATE;\n-      c->initializer = gfc_int_expr (0);\n-    }\n-\n-  fclass->attr.extension = 1;\n-  fclass->attr.is_class = 1;\n-  ts->u.derived = fclass;\n-  attr->allocatable = attr->pointer = attr->dimension = 0;\n-  (*as) = NULL;  /* XXX */\n-  return SUCCESS;\n-}\n \n /* Function called by variable_decl() that adds a name to the symbol table.  */\n \n@@ -1185,7 +1103,7 @@ build_sym (const char *name, gfc_charlen *cl,\n       sym->attr.class_ok = (sym->attr.dummy\n \t\t\t      || sym->attr.pointer\n \t\t\t      || sym->attr.allocatable) ? 1 : 0;\n-      encapsulate_class_symbol (&sym->ts, &sym->attr, &sym->as);\n+      gfc_build_class_symbol (&sym->ts, &sym->attr, &sym->as);\n     }\n \n   return SUCCESS;\n@@ -1594,7 +1512,7 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n \n scalar:\n   if (c->ts.type == BT_CLASS)\n-    encapsulate_class_symbol (&c->ts, &c->attr, &c->as);\n+    gfc_build_class_symbol (&c->ts, &c->attr, &c->as);\n \n   return t;\n }\n@@ -6926,13 +6844,23 @@ gfc_match_derived_decl (void)\n \n       /* Add the extended derived type as the first component.  */\n       gfc_add_component (sym, parent, &p);\n-      sym->attr.extension = attr.extension;\n       extended->refs++;\n       gfc_set_sym_referenced (extended);\n \n       p->ts.type = BT_DERIVED;\n       p->ts.u.derived = extended;\n       p->initializer = gfc_default_initializer (&p->ts);\n+      \n+      /* Set extension level.  */\n+      if (extended->attr.extension == 255)\n+\t{\n+\t  /* Since the extension field is 8 bit wide, we can only have\n+\t     up to 255 extension levels.  */\n+\t  gfc_error (\"Maximum extension level reached with type '%s' at %L\",\n+\t\t     extended->name, &extended->declared_at);\n+\t  return MATCH_ERROR;\n+\t}\n+      sym->attr.extension = extended->attr.extension + 1;\n \n       /* Provide the links between the extended type and its extension.  */\n       if (!extended->f2k_derived)\n@@ -6941,9 +6869,9 @@ gfc_match_derived_decl (void)\n       st->n.sym = sym;\n     }\n \n-  if (!sym->vindex)\n-    /* Set the vindex for this type.  */\n-    sym->vindex = hash_value (sym);\n+  if (!sym->hash_value)\n+    /* Set the hash for the compound name for this type.  */\n+    sym->hash_value = hash_value (sym);\n \n   /* Take over the ABSTRACT attribute.  */\n   sym->attr.abstract = attr.abstract;"}, {"sha": "97289c26aa5926e215ded72d59f08c43c738c10b", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -827,8 +827,8 @@ show_symbol (gfc_symbol *sym)\n   if (sym->f2k_derived)\n     {\n       show_indent ();\n-      if (sym->vindex)\n-\tfprintf (dumpfile, \"vindex: %d\", sym->vindex);\n+      if (sym->hash_value)\n+\tfprintf (dumpfile, \"hash: %d\", sym->hash_value);\n       show_f2k_derived (sym->f2k_derived);\n     }\n "}, {"sha": "e552203cb915849119bcda83fac2c0575ff81766", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -670,9 +670,10 @@ typedef struct\n   unsigned untyped:1;\t\t/* No implicit type could be found.  */\n \n   unsigned is_bind_c:1;\t\t/* say if is bound to C.  */\n-  unsigned extension:1;\t\t/* extends a derived type.  */\n+  unsigned extension:8;\t\t/* extension level of a derived type.  */\n   unsigned is_class:1;\t\t/* is a CLASS container.  */\n   unsigned class_ok:1;\t\t/* is a CLASS object with correct attributes.  */\n+  unsigned vtab:1;\t\t/* is a derived type vtab.  */\n \n   /* These flags are both in the typespec and attribute.  The attribute\n      list is what gets read from/written to a module file.  The typespec\n@@ -1137,8 +1138,8 @@ typedef struct gfc_symbol\n \n   int entry_id;\t\t\t/* Used in resolve.c for entries.  */\n \n-  /* CLASS vindex for declared and dynamic types in the class.  */\n-  int vindex;\n+  /* CLASS hashed name for declared and dynamic types in the class.  */\n+  int hash_value;\n \n   struct gfc_symbol *common_next;\t/* Links for COMMON syms */\n \n@@ -1599,7 +1600,7 @@ typedef struct gfc_class_esym_list\n {\n   gfc_symbol *derived;\n   gfc_symbol *esym;\n-  struct gfc_expr *vindex;\n+  struct gfc_expr *hash_value;\n   struct gfc_class_esym_list *next;\n }\n gfc_class_esym_list;\n@@ -2380,6 +2381,7 @@ gfc_try gfc_check_any_c_kind (gfc_typespec *);\n int gfc_validate_kind (bt, int, bool);\n int gfc_get_int_kind_from_width_isofortranenv (int size);\n int gfc_get_real_kind_from_width_isofortranenv (int size);\n+tree gfc_get_derived_type (gfc_symbol * derived);\n extern int gfc_index_integer_kind;\n extern int gfc_default_integer_kind;\n extern int gfc_max_integer_kind;\n@@ -2517,6 +2519,9 @@ void gfc_free_dt_list (void);\n gfc_gsymbol *gfc_get_gsymbol (const char *);\n gfc_gsymbol *gfc_find_gsymbol (gfc_gsymbol *, const char *);\n \n+gfc_try gfc_build_class_symbol (gfc_typespec *, symbol_attribute *,\n+\t\t\t\tgfc_array_spec **);\n+gfc_symbol *gfc_find_derived_vtab (gfc_symbol *);\n gfc_typebound_proc* gfc_get_typebound_proc (void);\n gfc_symbol* gfc_get_derived_super_type (gfc_symbol*);\n gfc_symbol* gfc_get_ultimate_derived_super_type (gfc_symbol*);"}, {"sha": "859fd4b7abf697a197d2483a3ccc8fbcb4918969", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -1601,7 +1601,7 @@ add_functions (void)\n \n   add_sym_2 (\"extends_type_of\", GFC_ISYM_EXTENDS_TYPE_OF, CLASS_INQUIRY,\n \t     ACTUAL_NO, BT_LOGICAL, dl, GFC_STD_F2003,\n-\t     gfc_check_same_type_as, NULL, NULL,\n+\t     gfc_check_same_type_as, NULL, gfc_resolve_extends_type_of,\n \t     a, BT_UNKNOWN, 0, REQUIRED,\n \t     mo, BT_UNKNOWN, 0, REQUIRED);\n "}, {"sha": "cf436db37fd124106eb5ade0e4788d2cfabf0ed4", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -390,6 +390,7 @@ void gfc_resolve_eoshift (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n void gfc_resolve_etime_sub (gfc_code *);\n void gfc_resolve_exp (gfc_expr *, gfc_expr *);\n void gfc_resolve_exponent (gfc_expr *, gfc_expr *);\n+void gfc_resolve_extends_type_of (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_fdate (gfc_expr *);\n void gfc_resolve_floor (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_fnum (gfc_expr *, gfc_expr *);"}, {"sha": "7e8bdfb0cea4d006a9b6f8951546f6b96127c7e8", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -806,6 +806,57 @@ gfc_resolve_exponent (gfc_expr *f, gfc_expr *x)\n }\n \n \n+/* Resolve the EXTENDS_TYPE_OF intrinsic function.  */\n+\n+void\n+gfc_resolve_extends_type_of (gfc_expr *f, gfc_expr *a, gfc_expr *mo)\n+{\n+  gfc_symbol *vtab;\n+  gfc_symtree *st;\n+\n+  /* Prevent double resolution.  */\n+  if (f->ts.type == BT_LOGICAL)\n+    return;\n+\n+  /* Replace the first argument with the corresponding vtab.  */\n+  if (a->ts.type == BT_CLASS)\n+    gfc_add_component_ref (a, \"$vptr\");\n+  else if (a->ts.type == BT_DERIVED)\n+    {\n+      vtab = gfc_find_derived_vtab (a->ts.u.derived);\n+      /* Clear the old expr.  */\n+      gfc_free_ref_list (a->ref);\n+      memset (a, '\\0', sizeof (gfc_expr));\n+      /* Construct a new one.  */\n+      a->expr_type = EXPR_VARIABLE;\n+      st = gfc_find_symtree (vtab->ns->sym_root, vtab->name);\n+      a->symtree = st;\n+      a->ts = vtab->ts;\n+    }\n+\n+  /* Replace the second argument with the corresponding vtab.  */\n+  if (mo->ts.type == BT_CLASS)\n+    gfc_add_component_ref (mo, \"$vptr\");\n+  else if (mo->ts.type == BT_DERIVED)\n+    {\n+      vtab = gfc_find_derived_vtab (mo->ts.u.derived);\n+      /* Clear the old expr.  */\n+      gfc_free_ref_list (mo->ref);\n+      memset (mo, '\\0', sizeof (gfc_expr));\n+      /* Construct a new one.  */\n+      mo->expr_type = EXPR_VARIABLE;\n+      st = gfc_find_symtree (vtab->ns->sym_root, vtab->name);\n+      mo->symtree = st;\n+      mo->ts = vtab->ts;\n+    }\n+\n+  f->ts.type = BT_LOGICAL;\n+  f->ts.kind = 4;\n+  /* Call library function.  */\n+  f->value.function.name = gfc_get_string (PREFIX (\"is_extension_of\"));\n+}\n+\n+\n void\n gfc_resolve_fdate (gfc_expr *f)\n {"}, {"sha": "9e76818badcae8ae73969d59c16bf4029c2da963", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -3968,13 +3968,25 @@ select_type_set_tmp (gfc_typespec *ts)\n {\n   char name[GFC_MAX_SYMBOL_LEN];\n   gfc_symtree *tmp;\n+  \n+  if (!gfc_type_is_extensible (ts->u.derived))\n+    return;\n \n-  sprintf (name, \"tmp$%s\", ts->u.derived->name);\n+  if (ts->type == BT_CLASS)\n+    sprintf (name, \"tmp$class$%s\", ts->u.derived->name);\n+  else\n+    sprintf (name, \"tmp$type$%s\", ts->u.derived->name);\n   gfc_get_sym_tree (name, gfc_current_ns, &tmp, false);\n   gfc_add_type (tmp->n.sym, ts, NULL);\n   gfc_set_sym_referenced (tmp->n.sym);\n   gfc_add_pointer (&tmp->n.sym->attr, NULL);\n   gfc_add_flavor (&tmp->n.sym->attr, FL_VARIABLE, name, NULL);\n+  if (ts->type == BT_CLASS)\n+    {\n+      gfc_build_class_symbol (&tmp->n.sym->ts, &tmp->n.sym->attr,\n+\t\t\t      &tmp->n.sym->as);\n+      tmp->n.sym->attr.class_ok = 1;\n+    }\n \n   select_type_stack->tmp = tmp;\n }\n@@ -4228,8 +4240,9 @@ gfc_match_class_is (void)\n \n   new_st.op = EXEC_SELECT_TYPE;\n   new_st.ext.case_list = c;\n-\n-  gfc_error_now (\"CLASS IS specification at %C is not yet supported\");\n+  \n+  /* Create temporary variable.  */\n+  select_type_set_tmp (&c->ts);\n \n   return MATCH_YES;\n "}, {"sha": "d732b66da58d5b10e3dd9098489540a202bcbcd7", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -77,7 +77,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Don't put any single quote (') in MOD_VERSION, \n    if yout want it to be recognized.  */\n-#define MOD_VERSION \"3\"\n+#define MOD_VERSION \"4\"\n \n \n /* Structure that describes a position within a module file.  */\n@@ -1671,7 +1671,7 @@ typedef enum\n   AB_CRAY_POINTER, AB_CRAY_POINTEE, AB_THREADPRIVATE, AB_ALLOC_COMP,\n   AB_POINTER_COMP, AB_PRIVATE_COMP, AB_VALUE, AB_VOLATILE, AB_PROTECTED,\n   AB_IS_BIND_C, AB_IS_C_INTEROP, AB_IS_ISO_C, AB_ABSTRACT, AB_ZERO_COMP,\n-  AB_EXTENSION, AB_IS_CLASS, AB_PROCEDURE, AB_PROC_POINTER\n+  AB_IS_CLASS, AB_PROCEDURE, AB_PROC_POINTER\n }\n ab_attribute;\n \n@@ -1711,7 +1711,6 @@ static const mstring attr_bits[] =\n     minit (\"ZERO_COMP\", AB_ZERO_COMP),\n     minit (\"PROTECTED\", AB_PROTECTED),\n     minit (\"ABSTRACT\", AB_ABSTRACT),\n-    minit (\"EXTENSION\", AB_EXTENSION),\n     minit (\"IS_CLASS\", AB_IS_CLASS),\n     minit (\"PROCEDURE\", AB_PROCEDURE),\n     minit (\"PROC_POINTER\", AB_PROC_POINTER),\n@@ -1771,7 +1770,7 @@ static void\n mio_symbol_attribute (symbol_attribute *attr)\n {\n   atom_type t;\n-  unsigned ext_attr;\n+  unsigned ext_attr,extension_level;\n \n   mio_lparen ();\n \n@@ -1780,10 +1779,15 @@ mio_symbol_attribute (symbol_attribute *attr)\n   attr->proc = MIO_NAME (procedure_type) (attr->proc, procedures);\n   attr->if_source = MIO_NAME (ifsrc) (attr->if_source, ifsrc_types);\n   attr->save = MIO_NAME (save_state) (attr->save, save_status);\n+  \n   ext_attr = attr->ext_attr;\n   mio_integer ((int *) &ext_attr);\n   attr->ext_attr = ext_attr;\n \n+  extension_level = attr->extension;\n+  mio_integer ((int *) &extension_level);\n+  attr->extension = extension_level;\n+\n   if (iomode == IO_OUTPUT)\n     {\n       if (attr->allocatable)\n@@ -1858,8 +1862,6 @@ mio_symbol_attribute (symbol_attribute *attr)\n \tMIO_NAME (ab_attribute) (AB_PRIVATE_COMP, attr_bits);\n       if (attr->zero_comp)\n \tMIO_NAME (ab_attribute) (AB_ZERO_COMP, attr_bits);\n-      if (attr->extension)\n-\tMIO_NAME (ab_attribute) (AB_EXTENSION, attr_bits);\n       if (attr->is_class)\n \tMIO_NAME (ab_attribute) (AB_IS_CLASS, attr_bits);\n       if (attr->procedure)\n@@ -1984,9 +1986,6 @@ mio_symbol_attribute (symbol_attribute *attr)\n \t    case AB_ZERO_COMP:\n \t      attr->zero_comp = 1;\n \t      break;\n-\t    case AB_EXTENSION:\n-\t      attr->extension = 1;\n-\t      break;\n \t    case AB_IS_CLASS:\n \t      attr->is_class = 1;\n \t      break;\n@@ -3574,7 +3573,7 @@ mio_symbol (gfc_symbol *sym)\n   mio_integer (&(sym->intmod_sym_id));\n \n   if (sym->attr.flavor == FL_DERIVED)\n-    mio_integer (&(sym->vindex));\n+    mio_integer (&(sym->hash_value));\n \n   mio_rparen ();\n }"}, {"sha": "bf705c6a09a9253e5739f0eb75bb98f81f98f7f2", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 168, "deletions": 58, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -5218,41 +5218,35 @@ resolve_class_esym (gfc_expr *e)\n }\n \n \n-/* Generate an expression for the vindex, given the reference to\n+/* Generate an expression for the hash value, given the reference to\n    the class of the final expression (class_ref), the base of the\n    full reference list (new_ref), the declared type and the class\n    object (st).  */\n static gfc_expr*\n-vindex_expr (gfc_ref *class_ref, gfc_ref *new_ref,\n-\t     gfc_symbol *declared, gfc_symtree *st)\n+hash_value_expr (gfc_ref *class_ref, gfc_ref *new_ref, gfc_symtree *st)\n {\n-  gfc_expr *vindex;\n-  gfc_ref *ref;\n+  gfc_expr *hash_value;\n \n-  /* Build an expression for the correct vindex; ie. that of the last\n+  /* Build an expression for the correct hash_value; ie. that of the last\n      CLASS reference.  */\n-  ref = gfc_get_ref();\n-  ref->type = REF_COMPONENT;\n-  ref->u.c.component = declared->components->next;\n-  ref->u.c.sym = declared;\n-  ref->next = NULL;\n   if (class_ref)\n     {\n-      class_ref->next = ref;\n+      class_ref->next = NULL;\n     }\n   else\n     {\n       gfc_free_ref_list (new_ref);\n-      new_ref = ref;\n+      new_ref = NULL;\n     }\n-  vindex = gfc_get_expr ();\n-  vindex->expr_type = EXPR_VARIABLE;\n-  vindex->symtree = st;\n-  vindex->symtree->n.sym->refs++;\n-  vindex->ts = ref->u.c.component->ts;\n-  vindex->ref = new_ref;\n+  hash_value = gfc_get_expr ();\n+  hash_value->expr_type = EXPR_VARIABLE;\n+  hash_value->symtree = st;\n+  hash_value->symtree->n.sym->refs++;\n+  hash_value->ref = new_ref;\n+  gfc_add_component_ref (hash_value, \"$vptr\");\n+  gfc_add_component_ref (hash_value, \"$hash\");\n \n-  return vindex;\n+  return hash_value;\n }\n \n \n@@ -5352,10 +5346,10 @@ resolve_class_compcall (gfc_expr* e)\n   resolve_class_esym (e);\n \n   /* More than one typebound procedure so transmit an expression for\n-     the vindex as the selector.  */\n+     the hash_value as the selector.  */\n   if (e->value.function.class_esym != NULL)\n-    e->value.function.class_esym->vindex\n-\t\t= vindex_expr (class_ref, new_ref, declared, st);\n+    e->value.function.class_esym->hash_value\n+\t\t= hash_value_expr (class_ref, new_ref, st);\n \n   return class_try;\n }\n@@ -5407,10 +5401,10 @@ resolve_class_typebound_call (gfc_code *code)\n   resolve_class_esym (code->expr1);\n \n   /* More than one typebound procedure so transmit an expression for\n-     the vindex as the selector.  */\n+     the hash_value as the selector.  */\n   if (code->expr1->value.function.class_esym != NULL)\n-    code->expr1->value.function.class_esym->vindex\n-\t\t= vindex_expr (class_ref, new_ref, declared, st);\n+    code->expr1->value.function.class_esym->hash_value\n+\t\t= hash_value_expr (class_ref, new_ref, st);\n \n   return class_try;\n }\n@@ -6862,11 +6856,13 @@ static void\n resolve_select_type (gfc_code *code)\n {\n   gfc_symbol *selector_type;\n-  gfc_code *body, *new_st;\n-  gfc_case *c, *default_case;\n+  gfc_code *body, *new_st, *if_st, *tail;\n+  gfc_code *class_is = NULL, *default_case = NULL;\n+  gfc_case *c;\n   gfc_symtree *st;\n   char name[GFC_MAX_SYMBOL_LEN];\n   gfc_namespace *ns;\n+  int error = 0;\n \n   ns = code->ext.ns;\n   gfc_resolve (ns);\n@@ -6876,9 +6872,6 @@ resolve_select_type (gfc_code *code)\n   else\n     selector_type = code->expr1->ts.u.derived->components->ts.u.derived;\n \n-  /* Assume there is no DEFAULT case.  */\n-  default_case = NULL;\n-\n   /* Loop over TYPE IS / CLASS IS cases.  */\n   for (body = code->block; body; body = body->block)\n     {\n@@ -6890,6 +6883,7 @@ resolve_select_type (gfc_code *code)\n \t{\n \t  gfc_error (\"Derived type '%s' at %L must be extensible\",\n \t\t     c->ts.u.derived->name, &c->where);\n+\t  error++;\n \t  continue;\n \t}\n \n@@ -6899,22 +6893,29 @@ resolve_select_type (gfc_code *code)\n \t{\n \t  gfc_error (\"Derived type '%s' at %L must be an extension of '%s'\",\n \t\t     c->ts.u.derived->name, &c->where, selector_type->name);\n+\t  error++;\n \t  continue;\n \t}\n \n       /* Intercept the DEFAULT case.  */\n       if (c->ts.type == BT_UNKNOWN)\n \t{\n \t  /* Check F03:C818.  */\n-\t  if (default_case != NULL)\n-\t    gfc_error (\"The DEFAULT CASE at %L cannot be followed \"\n-\t\t       \"by a second DEFAULT CASE at %L\",\n-\t\t       &default_case->where, &c->where);\n+\t  if (default_case)\n+\t    {\n+\t      gfc_error (\"The DEFAULT CASE at %L cannot be followed \"\n+\t\t\t \"by a second DEFAULT CASE at %L\",\n+\t\t\t &default_case->ext.case_list->where, &c->where);\n+\t      error++;\n+\t      continue;\n+\t    }\n \t  else\n-\t    default_case = c;\n-\t  continue;\n+\t    default_case = body;\n \t}\n     }\n+    \n+  if (error>0)\n+    return;\n \n   if (code->expr2)\n     {\n@@ -6944,45 +6945,153 @@ resolve_select_type (gfc_code *code)\n \n   /* Transform to EXEC_SELECT.  */\n   code->op = EXEC_SELECT;\n-  gfc_add_component_ref (code->expr1, \"$vindex\");\n+  gfc_add_component_ref (code->expr1, \"$vptr\");\n+  gfc_add_component_ref (code->expr1, \"$hash\");\n \n   /* Loop over TYPE IS / CLASS IS cases.  */\n   for (body = code->block; body; body = body->block)\n     {\n       c = body->ext.case_list;\n+      \n       if (c->ts.type == BT_DERIVED)\n-\tc->low = c->high = gfc_int_expr (c->ts.u.derived->vindex);\n-      else if (c->ts.type == BT_CLASS)\n-\t/* Currently IS CLASS blocks are simply ignored.\n-\t   TODO: Implement IS CLASS.  */\n-\tc->unreachable = 1;\n-\n-      if (c->ts.type != BT_DERIVED)\n+\tc->low = c->high = gfc_int_expr (c->ts.u.derived->hash_value);\n+      else if (c->ts.type == BT_UNKNOWN)\n \tcontinue;\n+      \n       /* Assign temporary to selector.  */\n-      sprintf (name, \"tmp$%s\", c->ts.u.derived->name);\n+      if (c->ts.type == BT_CLASS)\n+\tsprintf (name, \"tmp$class$%s\", c->ts.u.derived->name);\n+      else\n+\tsprintf (name, \"tmp$type$%s\", c->ts.u.derived->name);\n       st = gfc_find_symtree (ns->sym_root, name);\n       new_st = gfc_get_code ();\n-      new_st->op = EXEC_POINTER_ASSIGN;\n       new_st->expr1 = gfc_get_variable_expr (st);\n       new_st->expr2 = gfc_get_variable_expr (code->expr1->symtree);\n-      gfc_add_component_ref (new_st->expr2, \"$data\");\n+      if (c->ts.type == BT_DERIVED)\n+\t{\n+\t  new_st->op = EXEC_POINTER_ASSIGN;\n+\t  gfc_add_component_ref (new_st->expr2, \"$data\");\n+\t}\n+      else\n+\tnew_st->op = EXEC_POINTER_ASSIGN;\n       new_st->next = body->next;\n       body->next = new_st;\n     }\n+    \n+  /* Take out CLASS IS cases for separate treatment.  */\n+  body = code;\n+  while (body && body->block)\n+    {\n+      if (body->block->ext.case_list->ts.type == BT_CLASS)\n+\t{\n+\t  /* Add to class_is list.  */\n+\t  if (class_is == NULL)\n+\t    { \n+\t      class_is = body->block;\n+\t      tail = class_is;\n+\t    }\n+\t  else\n+\t    {\n+\t      for (tail = class_is; tail->block; tail = tail->block) ;\n+\t      tail->block = body->block;\n+\t      tail = tail->block;\n+\t    }\n+\t  /* Remove from EXEC_SELECT list.  */\n+\t  body->block = body->block->block;\n+\t  tail->block = NULL;\n+\t}\n+      else\n+\tbody = body->block;\n+    }\n \n-  /* Eliminate dead blocks.  */\n-  for (body = code; body && body->block; body = body->block)\n+  if (class_is)\n     {\n-      if (body->block->ext.case_list->unreachable)\n+      gfc_symbol *vtab;\n+      \n+      if (!default_case)\n+\t{\n+\t  /* Add a default case to hold the CLASS IS cases.  */\n+\t  for (tail = code; tail->block; tail = tail->block) ;\n+\t  tail->block = gfc_get_code ();\n+\t  tail = tail->block;\n+\t  tail->op = EXEC_SELECT_TYPE;\n+\t  tail->ext.case_list = gfc_get_case ();\n+\t  tail->ext.case_list->ts.type = BT_UNKNOWN;\n+\t  tail->next = NULL;\n+\t  default_case = tail;\n+\t}\n+      \n+      /* More than one CLASS IS block?  */\n+      if (class_is->block)\n \t{\n-\t  /* Cut the unreachable block from the code chain.  */\n-\t  gfc_code *cd = body->block;\n-\t  body->block = cd->block;\n-\t  /* Kill the dead block, but not the blocks below it.  */\n-\t  cd->block = NULL;\n-\t  gfc_free_statements (cd);\n+\t  gfc_code **c1,*c2;\n+\t  bool swapped;\n+\t  /* Sort CLASS IS blocks by extension level.  */\n+\t  do\n+\t    {\n+\t      swapped = false;\n+\t      for (c1 = &class_is; (*c1) && (*c1)->block; c1 = &((*c1)->block))\n+\t\t{\n+\t\t  c2 = (*c1)->block;\n+\t\t  /* F03:C817 (check for doubles).  */\n+\t\t  if ((*c1)->ext.case_list->ts.u.derived->hash_value\n+\t\t      == c2->ext.case_list->ts.u.derived->hash_value)\n+\t\t    {\n+\t\t      gfc_error (\"Double CLASS IS block in SELECT TYPE \"\n+\t\t\t\t \"statement at %L\", &c2->ext.case_list->where);\n+\t\t      return;\n+\t\t    }\n+\t\t  if ((*c1)->ext.case_list->ts.u.derived->attr.extension\n+\t\t      < c2->ext.case_list->ts.u.derived->attr.extension)\n+\t\t    {\n+\t\t      /* Swap.  */\n+\t\t      (*c1)->block = c2->block;\n+\t\t      c2->block = *c1;\n+\t\t      *c1 = c2;\n+\t\t      swapped = true;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  while (swapped);\n \t}\n+\t\n+      /* Generate IF chain.  */\n+      if_st = gfc_get_code ();\n+      if_st->op = EXEC_IF;\n+      new_st = if_st;\n+      for (body = class_is; body; body = body->block)\n+\t{\n+\t  new_st->block = gfc_get_code ();\n+\t  new_st = new_st->block;\n+\t  new_st->op = EXEC_IF;\n+\t  /* Set up IF condition: Call _gfortran_is_extension_of.  */\n+\t  new_st->expr1 = gfc_get_expr ();\n+\t  new_st->expr1->expr_type = EXPR_FUNCTION;\n+\t  new_st->expr1->ts.type = BT_LOGICAL;\n+\t  new_st->expr1->ts.kind = 4;\n+\t  new_st->expr1->value.function.name = gfc_get_string (PREFIX (\"is_extension_of\"));\n+\t  new_st->expr1->value.function.isym = XCNEW (gfc_intrinsic_sym);\n+\t  new_st->expr1->value.function.isym->id = GFC_ISYM_EXTENDS_TYPE_OF;\n+\t  /* Set up arguments.  */\n+\t  new_st->expr1->value.function.actual = gfc_get_actual_arglist ();\n+\t  new_st->expr1->value.function.actual->expr = gfc_get_variable_expr (code->expr1->symtree);\n+\t  gfc_add_component_ref (new_st->expr1->value.function.actual->expr, \"$vptr\");\n+\t  vtab = gfc_find_derived_vtab (body->ext.case_list->ts.u.derived);\n+\t  st = gfc_find_symtree (vtab->ns->sym_root, vtab->name);\n+\t  new_st->expr1->value.function.actual->next = gfc_get_actual_arglist ();\n+\t  new_st->expr1->value.function.actual->next->expr = gfc_get_variable_expr (st);\n+\t  new_st->next = body->next;\n+\t}\n+\tif (default_case->next)\n+\t  {\n+\t    new_st->block = gfc_get_code ();\n+\t    new_st = new_st->block;\n+\t    new_st->op = EXEC_IF;\n+\t    new_st->next = default_case->next;\n+\t  }\n+\t  \n+\t/* Replace CLASS DEFAULT code by the IF chain.  */\n+\tdefault_case->next = if_st;\n     }\n \n   resolve_select (code);\n@@ -8751,7 +8860,8 @@ resolve_fl_variable_derived (gfc_symbol *sym, int no_init_flag)\n       if (!gfc_type_is_extensible (sym->ts.u.derived->components->ts.u.derived))\n \t{\n \t  gfc_error (\"Type '%s' of CLASS variable '%s' at %L is not extensible\",\n-\t\t     sym->ts.u.derived->name, sym->name, &sym->declared_at);\n+\t\t     sym->ts.u.derived->components->ts.u.derived->name,\n+\t\t     sym->name, &sym->declared_at);\n \t  return FAILURE;\n \t}\n "}, {"sha": "6dd0a8afa0fa5cbb605b44e80a1f2cdb8541d216", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 219, "deletions": 13, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -1045,7 +1045,7 @@ gfc_add_save (symbol_attribute *attr, const char *name, locus *where)\n       return FAILURE;\n     }\n \n-  if (attr->save == SAVE_EXPLICIT)\n+  if (attr->save == SAVE_EXPLICIT && !attr->vtab)\n     {\n \tif (gfc_notify_std (GFC_STD_LEGACY, \n \t\t\t    \"Duplicate SAVE attribute specified at %L\",\n@@ -4592,22 +4592,228 @@ gfc_type_is_extension_of (gfc_symbol *t1, gfc_symbol *t2)\n bool\n gfc_type_compatible (gfc_typespec *ts1, gfc_typespec *ts2)\n {\n-  if ((ts1->type == BT_DERIVED || ts1->type == BT_CLASS)\n-      && (ts2->type == BT_DERIVED || ts2->type == BT_CLASS))\n+  gfc_component *cmp1, *cmp2;\n+\n+  bool is_class1 = (ts1->type == BT_CLASS);\n+  bool is_class2 = (ts2->type == BT_CLASS);\n+  bool is_derived1 = (ts1->type == BT_DERIVED);\n+  bool is_derived2 = (ts2->type == BT_DERIVED);\n+\n+  if (!is_derived1 && !is_derived2 && !is_class1 && !is_class2)\n+    return (ts1->type == ts2->type);\n+\n+  if (is_derived1 && is_derived2)\n+    return gfc_compare_derived_types (ts1->u.derived, ts2->u.derived);\n+\n+  cmp1 = cmp2 = NULL;\n+\n+  if (is_class1)\n     {\n-      if (ts1->type == BT_CLASS && ts2->type == BT_DERIVED)\n-\treturn gfc_type_is_extension_of (ts1->u.derived->components->ts.u.derived,\n-\t\t\t\t\t ts2->u.derived);\n-      else if (ts1->type == BT_CLASS && ts2->type == BT_CLASS)\n-\treturn gfc_type_is_extension_of (ts1->u.derived->components->ts.u.derived,\n-\t\t\t\t\t ts2->u.derived->components->ts.u.derived);\n-      else if (ts2->type != BT_CLASS)\n-\treturn gfc_compare_derived_types (ts1->u.derived, ts2->u.derived);\n-      else\n+      cmp1 = gfc_find_component (ts1->u.derived, \"$data\", true, false);\n+      if (cmp1 == NULL)\n \treturn 0;\n     }\n+\n+  if (is_class2)\n+    {\n+      cmp2 = gfc_find_component (ts2->u.derived, \"$data\", true, false);\n+      if (cmp2 == NULL)\n+\treturn 0;\n+    }\n+\n+  if (is_class1 && is_derived2)\n+    return gfc_type_is_extension_of (cmp1->ts.u.derived, ts2->u.derived);\n+\n+  else if (is_class1 && is_class2)\n+    return gfc_type_is_extension_of (cmp1->ts.u.derived, cmp2->ts.u.derived);\n+\n   else\n-    return (ts1->type == ts2->type);\n+    return 0;\n+}\n+\n+\n+/* Build a polymorphic CLASS entity, using the symbol that comes from\n+   build_sym. A CLASS entity is represented by an encapsulating type,\n+   which contains the declared type as '$data' component, plus a pointer\n+   component '$vptr' which determines the dynamic type.  */\n+\n+gfc_try\n+gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n+\t\t\tgfc_array_spec **as)\n+{\n+  char name[GFC_MAX_SYMBOL_LEN + 5];\n+  gfc_symbol *fclass;\n+  gfc_symbol *vtab;\n+  gfc_component *c;\n+\n+  /* Determine the name of the encapsulating type.  */\n+  if ((*as) && (*as)->rank && attr->allocatable)\n+    sprintf (name, \".class.%s.%d.a\", ts->u.derived->name, (*as)->rank);\n+  else if ((*as) && (*as)->rank)\n+    sprintf (name, \".class.%s.%d\", ts->u.derived->name, (*as)->rank);\n+  else if (attr->allocatable)\n+    sprintf (name, \".class.%s.a\", ts->u.derived->name);\n+  else\n+    sprintf (name, \".class.%s\", ts->u.derived->name);\n+\n+  gfc_find_symbol (name, ts->u.derived->ns, 0, &fclass);\n+  if (fclass == NULL)\n+    {\n+      gfc_symtree *st;\n+      /* If not there, create a new symbol.  */\n+      fclass = gfc_new_symbol (name, ts->u.derived->ns);\n+      st = gfc_new_symtree (&ts->u.derived->ns->sym_root, name);\n+      st->n.sym = fclass;\n+      gfc_set_sym_referenced (fclass);\n+      fclass->refs++;\n+      fclass->ts.type = BT_UNKNOWN;\n+      fclass->attr.abstract = ts->u.derived->attr.abstract;\n+      if (ts->u.derived->f2k_derived)\n+\tfclass->f2k_derived = gfc_get_namespace (NULL, 0);\n+      if (gfc_add_flavor (&fclass->attr, FL_DERIVED,\n+\t  NULL, &gfc_current_locus) == FAILURE)\n+\treturn FAILURE;\n+\n+      /* Add component '$data'.  */\n+      if (gfc_add_component (fclass, \"$data\", &c) == FAILURE)\n+\treturn FAILURE;\n+      c->ts = *ts;\n+      c->ts.type = BT_DERIVED;\n+      c->attr.access = ACCESS_PRIVATE;\n+      c->ts.u.derived = ts->u.derived;\n+      c->attr.pointer = attr->pointer || attr->dummy;\n+      c->attr.allocatable = attr->allocatable;\n+      c->attr.dimension = attr->dimension;\n+      c->attr.abstract = ts->u.derived->attr.abstract;\n+      c->as = (*as);\n+      c->initializer = gfc_get_expr ();\n+      c->initializer->expr_type = EXPR_NULL;\n+\n+      /* Add component '$vptr'.  */\n+      if (gfc_add_component (fclass, \"$vptr\", &c) == FAILURE)\n+\treturn FAILURE;\n+      c->ts.type = BT_DERIVED;\n+      vtab = gfc_find_derived_vtab (ts->u.derived);\n+      gcc_assert (vtab);\n+      c->ts.u.derived = vtab->ts.u.derived;\n+      c->attr.pointer = 1;\n+      c->initializer = gfc_get_expr ();\n+      c->initializer->expr_type = EXPR_NULL;\n+    }\n+\n+  /* Since the extension field is 8 bit wide, we can only have\n+     up to 255 extension levels.  */\n+  if (ts->u.derived->attr.extension == 255)\n+    {\n+      gfc_error (\"Maximum extension level reached with type '%s' at %L\",\n+\t\t ts->u.derived->name, &ts->u.derived->declared_at);\n+      return FAILURE;\n+    }\n+    \n+  fclass->attr.extension = ts->u.derived->attr.extension + 1;\n+  fclass->attr.is_class = 1;\n+  ts->u.derived = fclass;\n+  attr->allocatable = attr->pointer = attr->dimension = 0;\n+  (*as) = NULL;  /* XXX */\n+  return SUCCESS;\n+}\n+\n+\n+/* Find the symbol for a derived type's vtab.  */\n+\n+gfc_symbol *\n+gfc_find_derived_vtab (gfc_symbol *derived)\n+{\n+  gfc_namespace *ns;\n+  gfc_symbol *vtab = NULL, *vtype = NULL;\n+  char name[2 * GFC_MAX_SYMBOL_LEN + 8];\n+\n+  ns = gfc_current_ns;\n+\n+  for (; ns; ns = ns->parent)\n+    if (!ns->parent)\n+      break;\n+\n+  if (ns)\n+    {\n+      sprintf (name, \"vtab$%s\", derived->name);\n+      gfc_find_symbol (name, ns, 0, &vtab);\n+\n+      if (vtab == NULL)\n+\t{\n+\t  gfc_get_symbol (name, ns, &vtab);\n+\t  vtab->ts.type = BT_DERIVED;\n+\t  vtab->attr.flavor = FL_VARIABLE;\n+\t  vtab->attr.target = 1;\n+\t  vtab->attr.save = SAVE_EXPLICIT;\n+\t  vtab->attr.vtab = 1;\n+\t  vtab->refs++;\n+\t  gfc_set_sym_referenced (vtab);\n+\t  sprintf (name, \"vtype$%s\", derived->name);\n+\t  \n+\t  gfc_find_symbol (name, ns, 0, &vtype);\n+\t  if (vtype == NULL)\n+\t    {\n+\t      gfc_component *c;\n+\t      gfc_symbol *parent = NULL, *parent_vtab = NULL;\n+\n+\t      gfc_get_symbol (name, ns, &vtype);\n+\t      if (gfc_add_flavor (&vtype->attr, FL_DERIVED,\n+\t\t\t\t  NULL, &gfc_current_locus) == FAILURE)\n+\t\treturn NULL;\n+\t      vtype->refs++;\n+\t      gfc_set_sym_referenced (vtype);\n+\n+\t      /* Add component '$hash'.  */\n+\t      if (gfc_add_component (vtype, \"$hash\", &c) == FAILURE)\n+\t\treturn NULL;\n+\t      c->ts.type = BT_INTEGER;\n+\t      c->ts.kind = 4;\n+\t      c->attr.access = ACCESS_PRIVATE;\n+\t      c->initializer = gfc_int_expr (derived->hash_value);\n+\n+\t      /* Add component '$size'.  */\n+\t      if (gfc_add_component (vtype, \"$size\", &c) == FAILURE)\n+\t\treturn NULL;\n+\t      c->ts.type = BT_INTEGER;\n+\t      c->ts.kind = 4;\n+\t      c->attr.access = ACCESS_PRIVATE;\n+\t      /* Remember the derived type in ts.u.derived,\n+\t\t so that the correct initializer can be set later on\n+\t\t (in gfc_conv_structure).  */\n+\t      c->ts.u.derived = derived;\n+\t      c->initializer = gfc_int_expr (0);\n+\n+\t      /* Add component $extends.  */\n+\t      if (gfc_add_component (vtype, \"$extends\", &c) == FAILURE)\n+\t\treturn NULL;\n+\t      c->attr.pointer = 1;\n+\t      c->attr.access = ACCESS_PRIVATE;\n+\t      c->initializer = gfc_get_expr ();\n+\t      parent = gfc_get_derived_super_type (derived);\n+\t      if (parent)\n+\t\t{\n+\t\t  parent_vtab = gfc_find_derived_vtab (parent);\n+\t\t  c->ts.type = BT_DERIVED;\n+\t\t  c->ts.u.derived = parent_vtab->ts.u.derived;\n+\t\t  c->initializer->expr_type = EXPR_VARIABLE;\n+\t\t  gfc_find_sym_tree (parent_vtab->name, parent_vtab->ns, 0,\n+\t\t\t\t     &c->initializer->symtree);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  c->ts.type = BT_DERIVED;\n+\t\t  c->ts.u.derived = vtype;\n+\t\t  c->initializer->expr_type = EXPR_NULL;\n+\t\t}\n+\t    }\n+\t  vtab->ts.u.derived = vtype;\n+\n+\t  vtab->value = gfc_default_initializer (&vtab->ts);\n+\t}\n+    }\n+\n+  return vtab;\n }\n \n "}, {"sha": "2e3fedd0ed3f09408b32f8ff73e36da966938181", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -3405,7 +3405,7 @@ gfc_create_module_variable (gfc_symbol * sym)\n       && (sym->equiv_built || sym->attr.in_equivalence))\n     return;\n \n-  if (sym->backend_decl)\n+  if (sym->backend_decl && !sym->attr.vtab)\n     internal_error (\"backend decl for module variable %s already exists\",\n \t\t    sym->name);\n "}, {"sha": "acca306a2ffc333cd3c3273c512c976020f1ca54", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 103, "deletions": 89, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -1530,16 +1530,16 @@ select_class_proc (gfc_se *se, gfc_class_esym_list *elist,\n   tree end_label;\n   tree label;\n   tree tmp;\n-  tree vindex;\n+  tree hash;\n   stmtblock_t body;\n   gfc_class_esym_list *next_elist, *tmp_elist;\n   gfc_se tmpse;\n \n-  /* Convert the vindex expression.  */\n+  /* Convert the hash expression.  */\n   gfc_init_se (&tmpse, NULL);\n-  gfc_conv_expr (&tmpse, elist->vindex);\n+  gfc_conv_expr (&tmpse, elist->hash_value);\n   gfc_add_block_to_block (&se->pre, &tmpse.pre);\n-  vindex = gfc_evaluate_now (tmpse.expr, &se->pre);\n+  hash = gfc_evaluate_now (tmpse.expr, &se->pre);\n   gfc_add_block_to_block (&se->post, &tmpse.post);\n \n   /* Fix the function type to be that of the declared type method.  */\n@@ -1566,9 +1566,9 @@ select_class_proc (gfc_se *se, gfc_class_esym_list *elist,\n \t  if (elist->esym != tmp_elist->esym)\n \t    continue;\n \n-\t  cval = build_int_cst (TREE_TYPE (vindex),\n-\t\t\t\telist->derived->vindex);\n-\t  /* Build a label for the vindex value.  */\n+\t  cval = build_int_cst (TREE_TYPE (hash),\n+\t\t\t\telist->derived->hash_value);\n+\t  /* Build a label for the hash value.  */\n \t  label = gfc_build_label_decl (NULL_TREE);\n \t  tmp = fold_build3 (CASE_LABEL_EXPR, void_type_node,\n \t\t\t     cval, NULL_TREE, label);\n@@ -1601,8 +1601,8 @@ select_class_proc (gfc_se *se, gfc_class_esym_list *elist,\n \t segfaults because it occurs too early and too often.  */\n     free_elist:\n       next_elist = elist->next;\n-      if (elist->vindex)\n-\tgfc_free_expr (elist->vindex);\n+      if (elist->hash_value)\n+\tgfc_free_expr (elist->hash_value);\n       gfc_free (elist);\n       elist = NULL;\n     }\n@@ -1613,12 +1613,12 @@ select_class_proc (gfc_se *se, gfc_class_esym_list *elist,\n \t\t     NULL_TREE, NULL_TREE, label);\n   gfc_add_expr_to_block (&body, tmp);\n   tmp = gfc_trans_runtime_error (true, &expr->where,\n-\t\t\"internal error: bad vindex in dynamic dispatch\");\n+\t\t\"internal error: bad hash value in dynamic dispatch\");\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Write the switch expression.  */\n   tmp = gfc_finish_block (&body);\n-  tmp = build3_v (SWITCH_EXPR, vindex, tmp, NULL_TREE);\n+  tmp = build3_v (SWITCH_EXPR, hash, tmp, NULL_TREE);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   tmp = build1_v (LABEL_EXPR, end_label);\n@@ -2531,6 +2531,60 @@ conv_arglist_function (gfc_se *se, gfc_expr *expr, const char *name)\n }\n \n \n+/* Takes a derived type expression and returns the address of a temporary\n+   class object of the 'declared' type.  */ \n+static void\n+gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n+\t\t\t   gfc_typespec class_ts)\n+{\n+  gfc_component *cmp;\n+  gfc_symbol *vtab;\n+  gfc_symbol *declared = class_ts.u.derived;\n+  gfc_ss *ss;\n+  tree ctree;\n+  tree var;\n+  tree tmp;\n+\n+  /* The derived type needs to be converted to a temporary\n+     CLASS object.  */\n+  tmp = gfc_typenode_for_spec (&class_ts);\n+  var = gfc_create_var (tmp, \"class\");\n+\n+  /* Set the vptr.  */\n+  cmp = gfc_find_component (declared, \"$vptr\", true, true);\n+  ctree = fold_build3 (COMPONENT_REF, TREE_TYPE (cmp->backend_decl),\n+\t\t       var, cmp->backend_decl, NULL_TREE);\n+\n+  /* Remember the vtab corresponds to the derived type\n+    not to the class declared type.  */\n+  vtab = gfc_find_derived_vtab (e->ts.u.derived);\n+  gcc_assert (vtab);\n+  tmp = gfc_build_addr_expr (NULL_TREE, gfc_get_symbol_decl (vtab));\n+  gfc_add_modify (&parmse->pre, ctree,\n+\t\t  fold_convert (TREE_TYPE (ctree), tmp));\n+\n+  /* Now set the data field.  */\n+  cmp = gfc_find_component (declared, \"$data\", true, true);\n+  ctree = fold_build3 (COMPONENT_REF, TREE_TYPE (cmp->backend_decl),\n+\t\t       var, cmp->backend_decl, NULL_TREE);\n+  ss = gfc_walk_expr (e);\n+  if (ss == gfc_ss_terminator)\n+    {\n+      gfc_conv_expr_reference (parmse, e);\n+      tmp = fold_convert (TREE_TYPE (ctree), parmse->expr);\n+      gfc_add_modify (&parmse->pre, ctree, tmp);\n+    }\n+  else\n+    {\n+      gfc_conv_expr (parmse, e);\n+      gfc_add_modify (&parmse->pre, ctree, parmse->expr);\n+    }\n+\n+  /* Pass the address of the class object.  */\n+  parmse->expr = gfc_build_addr_expr (NULL_TREE, var);\n+}\n+\n+\n /* The following routine generates code for the intrinsic\n    procedures from the ISO_C_BINDING module:\n     * C_LOC           (function)\n@@ -2800,53 +2854,10 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       else if (fsym && fsym->ts.type == BT_CLASS\n \t\t && e->ts.type == BT_DERIVED)\n \t{\n-\t  tree data;\n-\t  tree vindex;\n-\t  tree size;\n-\n \t  /* The derived type needs to be converted to a temporary\n \t     CLASS object.  */\n \t  gfc_init_se (&parmse, se);\n-\t  type = gfc_typenode_for_spec (&fsym->ts);\n-\t  var = gfc_create_var (type, \"class\");\n-\n-\t  /* Get the components.  */\n-\t  tmp = fsym->ts.u.derived->components->backend_decl;\n-\t  data = fold_build3 (COMPONENT_REF, TREE_TYPE (tmp),\n-\t\t\t      var, tmp, NULL_TREE);\n-\t  tmp = fsym->ts.u.derived->components->next->backend_decl;\n-\t  vindex = fold_build3 (COMPONENT_REF, TREE_TYPE (tmp),\n-\t\t\t\tvar, tmp, NULL_TREE);\n-\t  tmp = fsym->ts.u.derived->components->next->next->backend_decl;\n-\t  size = fold_build3 (COMPONENT_REF, TREE_TYPE (tmp),\n-\t\t\t      var, tmp, NULL_TREE);\n-\n-\t  /* Set the vindex.  */\n-\t  tmp = build_int_cst (TREE_TYPE (vindex), e->ts.u.derived->vindex);\n-\t  gfc_add_modify (&parmse.pre, vindex, tmp);\n-\n-\t  /* Set the size.  */\n-\t  tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&e->ts));\n-\t  gfc_add_modify (&parmse.pre, size,\n-\t\t\t  fold_convert (TREE_TYPE (size), tmp));\n-\n-\t  /* Now set the data field.  */\n-\t  argss = gfc_walk_expr (e);\n-\t  if (argss == gfc_ss_terminator)\n-            {\n-\t      gfc_conv_expr_reference (&parmse, e);\n-\t      tmp = fold_convert (TREE_TYPE (data),\n-\t\t\t\t  parmse.expr);\n-\t      gfc_add_modify (&parmse.pre, data, tmp);\n-\t    }\n-\t  else\n-\t    {\n-\t      gfc_conv_expr (&parmse, e);\n-\t      gfc_add_modify (&parmse.pre, data, parmse.expr);\n-\t    }\n-\n-\t  /* Pass the address of the class object.  */\n-\t  parmse.expr = gfc_build_addr_expr (NULL_TREE, var);\n+\t  gfc_conv_derived_to_class (&parmse, e, fsym->ts);\n \t}\n       else if (se->ss && se->ss->useflags)\n \t{\n@@ -4240,14 +4251,27 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n \n       if (cm->ts.type == BT_CLASS)\n \t{\n+\t  gfc_component *data;\n+\t  data = gfc_find_component (cm->ts.u.derived, \"$data\", true, true);\n \t  val = gfc_conv_initializer (c->expr, &cm->ts,\n-\t      TREE_TYPE (cm->ts.u.derived->components->backend_decl),\n-\t      cm->ts.u.derived->components->attr.dimension,\n-\t      cm->ts.u.derived->components->attr.pointer);\n+\t\t\t\t      TREE_TYPE (data->backend_decl),\n+\t\t\t\t      data->attr.dimension,\n+\t\t\t\t      data->attr.pointer);\n \n-\t  /* Append it to the constructor list.  */\n-\t  CONSTRUCTOR_APPEND_ELT (v, cm->ts.u.derived->components->backend_decl,\n-\t\t\t\t  val);\n+\t  CONSTRUCTOR_APPEND_ELT (v, data->backend_decl, val);\n+\t}\n+      else if (strcmp (cm->name, \"$size\") == 0)\n+\t{\n+\t  val = TYPE_SIZE_UNIT (gfc_get_derived_type (cm->ts.u.derived));\n+\t  CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, val);\n+\t}\n+      else if (cm->initializer && cm->initializer->expr_type != EXPR_NULL\n+\t       && strcmp (cm->name, \"$extends\") == 0)\n+\t{\n+\t  gfc_symbol *vtabs;\n+\t  vtabs = cm->initializer->symtree->n.sym;\n+\t  val = gfc_build_addr_expr (NULL_TREE, gfc_get_symbol_decl (vtabs));\n+\t  CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl, val);\n \t}\n       else\n \t{\n@@ -5366,47 +5390,37 @@ gfc_trans_class_assign (gfc_code *code)\n {\n   stmtblock_t block;\n   tree tmp;\n+  gfc_expr *lhs;\n+  gfc_expr *rhs;\n \n   gfc_start_block (&block);\n \n   if (code->expr2->ts.type != BT_CLASS)\n     {\n-      /* Insert an additional assignment which sets the '$vindex' field.  */\n-      gfc_expr *lhs,*rhs;\n+      /* Insert an additional assignment which sets the '$vptr' field.  */\n       lhs = gfc_copy_expr (code->expr1);\n-      gfc_add_component_ref (lhs, \"$vindex\");\n-      if (code->expr2->ts.type == BT_DERIVED)\n-\t/* vindex is constant, determined at compile time.  */\n-\trhs = gfc_int_expr (code->expr2->ts.u.derived->vindex);\n-      else if (code->expr2->expr_type == EXPR_NULL)\n-\trhs = gfc_int_expr (0);\n-      else\n-\tgcc_unreachable ();\n-      tmp = gfc_trans_assignment (lhs, rhs, false);\n-      gfc_add_expr_to_block (&block, tmp);\n-\n-      /* Insert another assignment which sets the '$size' field.  */\n-      lhs = gfc_copy_expr (code->expr1);\n-      gfc_add_component_ref (lhs, \"$size\");\n+      gfc_add_component_ref (lhs, \"$vptr\");\n       if (code->expr2->ts.type == BT_DERIVED)\n \t{\n-\t  /* Size is fixed at compile time.  */\n-\t  gfc_se lse;\n-\t  gfc_init_se (&lse, NULL);\n-\t  gfc_conv_expr (&lse, lhs);\n-\t  tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&code->expr2->ts));\n-\t  gfc_add_modify (&block, lse.expr,\n-\t\t\t  fold_convert (TREE_TYPE (lse.expr), tmp));\n+\t  gfc_symbol *vtab;\n+\t  gfc_symtree *st;\n+\t  vtab = gfc_find_derived_vtab (code->expr2->ts.u.derived);\n+\t  gcc_assert (vtab);\n+\n+\t  rhs = gfc_get_expr ();\n+\t  rhs->expr_type = EXPR_VARIABLE;\n+\t  gfc_find_sym_tree (vtab->name, NULL, 1, &st);\n+\t  rhs->symtree = st;\n+\t  rhs->ts = vtab->ts;\n \t}\n       else if (code->expr2->expr_type == EXPR_NULL)\n-\t{\n-\t  rhs = gfc_int_expr (0);\n-\t  tmp = gfc_trans_assignment (lhs, rhs, false);\n-\t  gfc_add_expr_to_block (&block, tmp);\n-\t}\n+\trhs = gfc_int_expr (0);\n       else\n \tgcc_unreachable ();\n \n+      tmp = gfc_trans_pointer_assignment (lhs, rhs);\n+      gfc_add_expr_to_block (&block, tmp);\n+\n       gfc_free_expr (lhs);\n       gfc_free_expr (rhs);\n     }"}, {"sha": "208a3b5a8d750002f6a7e819e1fb63f8df91b406", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -4715,14 +4715,20 @@ gfc_conv_same_type_as (gfc_se *se, gfc_expr *expr)\n   b = expr->value.function.actual->next->expr;\n \n   if (a->ts.type == BT_CLASS)\n-    gfc_add_component_ref (a, \"$vindex\");\n+    {\n+      gfc_add_component_ref (a, \"$vptr\");\n+      gfc_add_component_ref (a, \"$hash\");\n+    }\n   else if (a->ts.type == BT_DERIVED)\n-    a = gfc_int_expr (a->ts.u.derived->vindex);\n+    a = gfc_int_expr (a->ts.u.derived->hash_value);\n \n   if (b->ts.type == BT_CLASS)\n-    gfc_add_component_ref (b, \"$vindex\");\n+    {\n+      gfc_add_component_ref (b, \"$vptr\");\n+      gfc_add_component_ref (b, \"$hash\");\n+    }\n   else if (b->ts.type == BT_DERIVED)\n-    b = gfc_int_expr (b->ts.u.derived->vindex);\n+    b = gfc_int_expr (b->ts.u.derived->hash_value);\n \n   gfc_conv_expr (&se1, a);\n   gfc_conv_expr (&se2, b);\n@@ -4733,21 +4739,6 @@ gfc_conv_same_type_as (gfc_se *se, gfc_expr *expr)\n }\n \n \n-/* Generate code for the EXTENDS_TYPE_OF intrinsic.  */\n-\n-static void\n-gfc_conv_extends_type_of (gfc_se *se, gfc_expr *expr)\n-{\n-  gfc_expr *e;\n-  /* TODO: Implement EXTENDS_TYPE_OF.  */\n-  gfc_error (\"Intrinsic EXTENDS_TYPE_OF at %L not yet implemented\",\n-\t     &expr->where);\n-  /* Just return 'false' for now.  */\n-  e = gfc_logical_expr (false, &expr->where);\n-  gfc_conv_expr (se, e);\n-}\n-\n-\n /* Generate code for SELECTED_CHAR_KIND (NAME) intrinsic function.  */\n \n static void\n@@ -5157,10 +5148,6 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_same_type_as (se, expr);\n       break;\n \n-    case GFC_ISYM_EXTENDS_TYPE_OF:\n-      gfc_conv_extends_type_of (se, expr);\n-      break;\n-\n     case GFC_ISYM_ABS:\n       gfc_conv_intrinsic_abs (se, expr);\n       break;\n@@ -5538,6 +5525,7 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n     case GFC_ISYM_CHMOD:\n     case GFC_ISYM_DTIME:\n     case GFC_ISYM_ETIME:\n+    case GFC_ISYM_EXTENDS_TYPE_OF:\n     case GFC_ISYM_FGET:\n     case GFC_ISYM_FGETC:\n     case GFC_ISYM_FNUM:"}, {"sha": "e9f76a03458f78b5d24097db0e94505c3abe9dcf", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -4046,6 +4046,7 @@ gfc_trans_allocate (gfc_code * code)\n \t      gfc_expr *sz;\n \t      gfc_se se_sz;\n \t      sz = gfc_copy_expr (code->expr3);\n+\t      gfc_add_component_ref (sz, \"$vptr\");\n \t      gfc_add_component_ref (sz, \"$size\");\n \t      gfc_init_se (&se_sz, NULL);\n \t      gfc_conv_expr (&se_sz, sz);\n@@ -4141,42 +4142,49 @@ gfc_trans_allocate (gfc_code * code)\n \t{\n \t  gfc_expr *lhs,*rhs;\n \t  gfc_se lse;\n-\t  /* Initialize VINDEX for CLASS objects.  */\n+\n+\t  /* Initialize VPTR for CLASS objects.  */\n \t  lhs = gfc_expr_to_initialize (expr);\n-\t  gfc_add_component_ref (lhs, \"$vindex\");\n+\t  gfc_add_component_ref (lhs, \"$vptr\");\n+\t  rhs = NULL;\n \t  if (code->expr3 && code->expr3->ts.type == BT_CLASS)\n \t    {\n-\t      /* vindex must be determined at run time.  */\n+\t      /* VPTR must be determined at run time.  */\n \t      rhs = gfc_copy_expr (code->expr3);\n-\t      gfc_add_component_ref (rhs, \"$vindex\");\n+\t      gfc_add_component_ref (rhs, \"$vptr\");\n+\t      tmp = gfc_trans_pointer_assignment (lhs, rhs);\n+\t      gfc_add_expr_to_block (&block, tmp);\n+\t      gfc_free_expr (rhs);\n \t    }\n \t  else\n \t    {\n-\t      /* vindex is fixed at compile time.  */\n-\t      int vindex;\n+\t      /* VPTR is fixed at compile time.  */\n+\t      gfc_symbol *vtab;\n+\t      gfc_typespec *ts;\n \t      if (code->expr3)\n-\t\tvindex = code->expr3->ts.u.derived->vindex;\n+\t\tts = &code->expr3->ts;\n+\t      else if (expr->ts.type == BT_DERIVED)\n+\t\tts = &expr->ts;\n \t      else if (code->ext.alloc.ts.type == BT_DERIVED)\n-\t\tvindex = code->ext.alloc.ts.u.derived->vindex;\n+\t\tts = &code->ext.alloc.ts;\n \t      else if (expr->ts.type == BT_CLASS)\n-\t\tvindex = expr->ts.u.derived->components->ts.u.derived->vindex;\n+\t\tts = &expr->ts.u.derived->components->ts;\n \t      else\n-\t\tvindex = expr->ts.u.derived->vindex;\n-\t      rhs = gfc_int_expr (vindex);\n-\t    }\n-\t  tmp = gfc_trans_assignment (lhs, rhs, false);\n-\t  gfc_free_expr (lhs);\n-\t  gfc_free_expr (rhs);\n-\t  gfc_add_expr_to_block (&block, tmp);\n+\t\tts = &expr->ts;\n \n-\t  /* Initialize SIZE for CLASS objects.  */\n-\t  lhs = gfc_expr_to_initialize (expr);\n-\t  gfc_add_component_ref (lhs, \"$size\");\n-\t  gfc_init_se (&lse, NULL);\n-\t  gfc_conv_expr (&lse, lhs);\n-\t  gfc_add_modify (&block, lse.expr,\n-\t\t\t  fold_convert (TREE_TYPE (lse.expr), memsz));\n-\t  gfc_free_expr (lhs);\n+\t      if (ts->type == BT_DERIVED)\n+\t\t{\n+\t\t  vtab = gfc_find_derived_vtab (ts->u.derived);\n+\t\t  gcc_assert (vtab);\n+\t\t  gfc_init_se (&lse, NULL);\n+\t\t  lse.want_pointer = 1;\n+\t\t  gfc_conv_expr (&lse, lhs);\n+\t\t  tmp = gfc_build_addr_expr (NULL_TREE,\n+\t\t\t\t\t     gfc_get_symbol_decl (vtab));\n+\t\t  gfc_add_modify (&block, lse.expr,\n+\t\t\tfold_convert (TREE_TYPE (lse.expr), tmp));\n+\t\t}\n+\t    }\n \t}\n \n     }"}, {"sha": "278ae27a45827ab0deed92445fdb8321dd81e7ab", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -53,8 +53,6 @@ along with GCC; see the file COPYING3.  If not see\n /* array of structs so we don't have to worry about xmalloc or free */\n CInteropKind_t c_interop_kinds_table[ISOCBINDING_NUMBER];\n \n-static tree gfc_get_derived_type (gfc_symbol * derived);\n-\n tree gfc_array_index_type;\n tree gfc_array_range_type;\n tree gfc_character1_type_node;\n@@ -1941,7 +1939,7 @@ gfc_get_ppc_type (gfc_component* c)\n    at the same time.  If an equal derived type has been built\n    in a parent namespace, this is used.  */\n \n-static tree\n+tree\n gfc_get_derived_type (gfc_symbol * derived)\n {\n   tree typenode = NULL, field = NULL, field_type = NULL, fieldlist = NULL;"}, {"sha": "d9221faf64ec78687715440544b48fba41a971eb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -1,3 +1,27 @@\n+2009-11-30  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/42053\n+\t* gfortran.dg/select_type_9.f03: New.\n+\n+2009-11-30  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/41631\n+\t* gfortran.dg/extends_type_of_1.f03: Fix invalid test case.\n+\t* gfortran.dg/module_md5_1.f90: Adjusted MD5 sum.\n+\t* gfortran.dg/select_type_1.f03: Remove FIXMEs.\n+\t* gfortran.dg/select_type_2.f03: Ditto.\n+\t* gfortran.dg/select_type_8.f03: New test.\n+\n+2009-11-30  Janus Weil  <janus@gcc.gnu.org>\n+\n+\t* gfortran.dg/extends_type_of_1.f03: New test.\n+\t* gfortran.dg/same_type_as_1.f03: Extended.\n+\n+2009-11-30  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* gfortran.dg/class_4c.f03: Add dg-additional-sources.\n+\t* gfortran.dg/class_4d.f03: Rename module. Cleanup modules.\n+\n 2009-11-30  Janis Johnson  <janis187@us.ibm.com>\n \n \tPR testsuite/42212"}, {"sha": "c76b3ab69530a8a6219835a73d73c7cc937fdcde", "filename": "gcc/testsuite/gfortran.dg/class_4c.f03", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_4c.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_4c.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_4c.f03?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -1,4 +1,5 @@\n ! { dg-do run }\n+! { dg-additional-sources class_4a.f03 class_4b.f03 }\n !\n ! Test the fix for PR41583, in which the different source files\n ! would generate the same 'vindex' for different class declared"}, {"sha": "80934b6c125f69ea27e3a5e7c0abe2bd87ee49dc", "filename": "gcc/testsuite/gfortran.dg/class_4d.f03", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_4d.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_4d.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_4d.f03?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -8,8 +8,8 @@\n !\n ! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n !\n-module m\n+module m3\n   type t\n   end type t\n-end module m\n-! { dg-final { cleanup-modules \"m m2\" } }\n+end module m3\n+! { dg-final { cleanup-modules \"m m2 m3\" } }"}, {"sha": "9e983846c90fd2f36525c75b8538daaf7950a023", "filename": "gcc/testsuite/gfortran.dg/extends_type_of_1.f03", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_type_of_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_type_of_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fextends_type_of_1.f03?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -0,0 +1,48 @@\n+! { dg-do run }\n+!\n+! Verifying the runtime behavior of the intrinsic function EXTENDS_TYPE_OF.\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+ implicit none\n+\n+ intrinsic :: extends_type_of\n+\n+ type :: t1\n+   integer :: i = 42\n+ end type\n+\n+ type, extends(t1) :: t2\n+   integer :: j = 43\n+ end type\n+\n+ type, extends(t2) :: t3\n+   class(t1),pointer :: cc\n+ end type\n+\n+ class(t1), pointer :: c1,c2\n+ type(t1), target :: x\n+ type(t2), target :: y\n+ type(t3), target :: z\n+ \n+ c1 => x\n+ c2 => y\n+ z%cc => y\n+\n+ if (.not. extends_type_of (c1, c1)) call abort()\n+ if (      extends_type_of (c1, c2)) call abort()\n+ if (.not. extends_type_of (c2, c1)) call abort()\n+\n+ if (.not. extends_type_of (x, x)) call abort()\n+ if (      extends_type_of (x, y)) call abort()\n+ if (.not. extends_type_of (y, x)) call abort()\n+\n+ if (.not. extends_type_of (c1, x)) call abort()\n+ if (      extends_type_of (c1, y)) call abort()\n+ if (.not. extends_type_of (x, c1)) call abort()\n+ if (.not. extends_type_of (y, c1)) call abort()\n+\n+ if (.not. extends_type_of (z,   c1)) call abort()\n+ if (      extends_type_of (z%cc, z)) call abort()\n+\n+end"}, {"sha": "e725b4b767ea1680d690d485214b8d09eb5c1d11", "filename": "gcc/testsuite/gfortran.dg/module_md5_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_md5_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_md5_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_md5_1.f90?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -10,5 +10,5 @@ program test\n   use foo\n   print *, pi\n end program test\n-! { dg-final { scan-module \"foo\" \"MD5:9c43cf4d713824ec6894b83250720e68\" } }\n+! { dg-final { scan-module \"foo\" \"MD5:5632bcd379cf023bf7e663e91d52fa12\" } }\n ! { dg-final { cleanup-modules \"foo\" } }"}, {"sha": "45b5d26627fa7f761b278d398c2cc6980c27924d", "filename": "gcc/testsuite/gfortran.dg/same_type_as_1.f03", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ftestsuite%2Fgfortran.dg%2Fsame_type_as_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ftestsuite%2Fgfortran.dg%2Fsame_type_as_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsame_type_as_1.f03?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -1,6 +1,6 @@\n ! { dg-do compile }\n !\n-! Error checking for the intrinsic function SAME_TYPE_AS.\n+! Error checking for the intrinsic functions SAME_TYPE_AS and EXTENDS_TYPE_OF.\n !\n ! Contributed by Janus Weil <janus@gcc.gnu.org>\n \n@@ -18,7 +18,10 @@\n \n  integer :: i\n \n- print *, SAME_TYPE_AS (l,x1)   ! { dg-error \"must be of a derived type\" }\n+ print *, SAME_TYPE_AS (i,x1)   ! { dg-error \"must be of a derived type\" }\n  print *, SAME_TYPE_AS (x1,x2)  ! { dg-error \"must be of an extensible type\" }\n \n+ print *, EXTENDS_TYPE_OF (i,x1)   ! { dg-error \"must be of a derived type\" }\n+ print *, EXTENDS_TYPE_OF (x1,x2)  ! { dg-error \"must be of an extensible type\" }\n+\n end"}, {"sha": "0214c51a04f8e768db838c98633cec574f5e8804", "filename": "gcc/testsuite/gfortran.dg/select_type_1.f03", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_1.f03?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -40,16 +40,14 @@\n     print *,\"a is TYPE(t1)\"\n   type is (t2)\n     print *,\"a is TYPE(t2)\"\n-! FIXME: CLASS IS specification is not yet supported\n-!  class is (ts)  ! { FIXME: error \"must be extensible\" }\n-!    print *,\"a is TYPE(ts)\"\n+  class is (ts)  ! { dg-error \"must be extensible\" }\n+    print *,\"a is TYPE(ts)\"\n   type is (t3)   ! { dg-error \"must be an extension of\" }\n     print *,\"a is TYPE(t3)\"\n   type is (t4)   ! { dg-error \"is not an accessible derived type\" }\n     print *,\"a is TYPE(t3)\"\n-! FIXME: CLASS IS specification is not yet supported\n-!  class is (t1)\n-!    print *,\"a is CLASS(t1)\"\n+  class is (t1)\n+    print *,\"a is CLASS(t1)\"\n   class is (t2) label  ! { dg-error \"Syntax error\" }\n     print *,\"a is CLASS(t2)\"\n   class default  ! { dg-error \"cannot be followed by a second DEFAULT CASE\" }"}, {"sha": "d4a5343d7b2111e5457e5b12370fae896e67129d", "filename": "gcc/testsuite/gfortran.dg/select_type_2.f03", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_2.f03?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -30,9 +30,8 @@\n     i = 1\n   type is (t2)\n     i = 2\n-! FIXME: CLASS IS is not yet supported\n-!  class is (t1)\n-!    i = 3\n+  class is (t1)\n+    i = 3\n   end select\n \n   if (i /= 1) call abort()\n@@ -45,9 +44,8 @@\n     i = 1\n   type is (t2)\n     i = 2\n-! FIXME: CLASS IS is not yet supported\n-!  class is (t2)\n-!    i = 3\n+  class is (t2)\n+    i = 3\n   end select\n \n   if (i /= 2) call abort()"}, {"sha": "306f2d18286b31856ec26a47f488eb5737d23443", "filename": "gcc/testsuite/gfortran.dg/select_type_8.f03", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_8.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_8.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_8.f03?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -0,0 +1,98 @@\n+! { dg-do run }\n+!\n+! executing SELECT TYPE statements with CLASS IS blocks\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+  implicit none\n+\n+  type :: t1\n+    integer :: i\n+  end type t1\n+\n+  type, extends(t1) :: t2\n+    integer :: j\n+  end type t2\n+\n+  type, extends(t2) :: t3\n+    real :: r\n+  end type\n+\n+  class(t1), pointer :: cp\n+  type(t1), target :: a\n+  type(t2), target :: b\n+  type(t3), target :: c\n+  integer :: i\n+\n+  cp => c\n+  i = 0\n+  select type (cp)\n+  type is (t1)\n+    i = 1\n+  type is (t2)\n+    i = 2\n+  class is (t1)\n+    i = 3\n+  class default\n+    i = 4\n+  end select\n+  print *,i\n+  if (i /= 3) call abort()\n+\n+  cp => a\n+  select type (cp)\n+  type is (t1)\n+    i = 1\n+  type is (t2)\n+    i = 2\n+  class is (t1)\n+    i = 3\n+  end select\n+  print *,i\n+  if (i /= 1) call abort()\n+\n+  cp => b\n+  select type (cp)\n+  type is (t1)\n+    i = 1\n+  class is (t3)\n+    i = 3\n+  class is (t2)\n+    i = 4\n+  class is (t1)\n+    i = 5\n+  end select\n+  print *,i\n+  if (i /= 4) call abort()\n+\n+  cp => b\n+  select type (cp)\n+  type is (t1)\n+    i = 1\n+  class is (t1)\n+    i = 5\n+  class is (t2)\n+    i = 4\n+  class is (t3)\n+    i = 3\n+  end select\n+  print *,i\n+  if (i /= 4) call abort()\n+\n+  cp => a\n+  select type (cp)\n+  type is (t2)\n+    i = 1\n+  class is (t2)\n+    i = 2\n+  class default\n+    i = 3\n+  class is (t3)\n+    i = 4\n+  type is (t3)\n+    i = 5\n+  end select\n+  print *,i\n+  if (i /= 3) call abort()\n+\n+end"}, {"sha": "62df6700e00eabf67ebfbc24987d618cca6e1f16", "filename": "gcc/testsuite/gfortran.dg/select_type_9.f03", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_9.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_9.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_9.f03?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+!\n+! PR 42053: [OOP] SELECT TYPE: reject duplicate CLASS IS blocks\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+ type :: t\n+  integer :: i\n+ end type\n+\n+ CLASS(t),pointer :: x\n+\n+ select type (x)\n+ class is (t)\n+  print *,\"a\"\n+ class is (t)  ! { dg-error \"Double CLASS IS block\" }\n+  print *,\"b\"\n+ end select\n+\n+end"}, {"sha": "68bf89705d6e01a74154a2a045e06cfe8032020f", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -1,3 +1,10 @@\n+2009-11-30  Janus Weil  <janus@gcc.gnu.org>\n+\n+\t* gfortran.map: Add _gfortran_is_extension_of.\n+\t* Makefile.am: Add intrinsics/extends_type_of.c.\n+\t* Makefile.in: Regenerated.\n+\t* intrinsics/extends_type_of.c: New file. \n+\n 2009-11-30  Kai Tietz  <Kai.Tietz@onevision.com>\n \n \t* io/unix.c (find_file): Add variable id conditionally for"}, {"sha": "bd767a2e679078f309fee350e1e5ac5813ccb7d9", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -85,6 +85,7 @@ intrinsics/eoshift2.c \\\n intrinsics/erfc_scaled.c \\\n intrinsics/etime.c \\\n intrinsics/exit.c \\\n+intrinsics/extends_type_of.c \\\n intrinsics/fnum.c \\\n intrinsics/gerror.c \\\n intrinsics/getcwd.c \\"}, {"sha": "9bc8f11426d5adb157f8a473f1166c385913b39e", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -433,15 +433,15 @@ am__libgfortran_la_SOURCES_DIST = runtime/backtrace.c runtime/bounds.c \\\n \tintrinsics/date_and_time.c intrinsics/dtime.c intrinsics/env.c \\\n \tintrinsics/eoshift0.c intrinsics/eoshift2.c \\\n \tintrinsics/erfc_scaled.c intrinsics/etime.c intrinsics/exit.c \\\n-\tintrinsics/fnum.c intrinsics/gerror.c intrinsics/getcwd.c \\\n-\tintrinsics/getlog.c intrinsics/getXid.c intrinsics/hostnm.c \\\n-\tintrinsics/ierrno.c intrinsics/ishftc.c \\\n-\tintrinsics/iso_c_generated_procs.c intrinsics/iso_c_binding.c \\\n-\tintrinsics/kill.c intrinsics/link.c intrinsics/malloc.c \\\n-\tintrinsics/mvbits.c intrinsics/move_alloc.c \\\n-\tintrinsics/pack_generic.c intrinsics/perror.c \\\n-\tintrinsics/selected_char_kind.c intrinsics/signal.c \\\n-\tintrinsics/size.c intrinsics/sleep.c \\\n+\tintrinsics/extends_type_of.c intrinsics/fnum.c \\\n+\tintrinsics/gerror.c intrinsics/getcwd.c intrinsics/getlog.c \\\n+\tintrinsics/getXid.c intrinsics/hostnm.c intrinsics/ierrno.c \\\n+\tintrinsics/ishftc.c intrinsics/iso_c_generated_procs.c \\\n+\tintrinsics/iso_c_binding.c intrinsics/kill.c intrinsics/link.c \\\n+\tintrinsics/malloc.c intrinsics/mvbits.c \\\n+\tintrinsics/move_alloc.c intrinsics/pack_generic.c \\\n+\tintrinsics/perror.c intrinsics/selected_char_kind.c \\\n+\tintrinsics/signal.c intrinsics/size.c intrinsics/sleep.c \\\n \tintrinsics/spread_generic.c intrinsics/string_intrinsics.c \\\n \tintrinsics/system.c intrinsics/rand.c intrinsics/random.c \\\n \tintrinsics/rename.c intrinsics/reshape_generic.c \\\n@@ -725,15 +725,16 @@ am__objects_36 = associated.lo abort.lo access.lo args.lo \\\n \tbit_intrinsics.lo c99_functions.lo chdir.lo chmod.lo clock.lo \\\n \tcpu_time.lo cshift0.lo ctime.lo date_and_time.lo dtime.lo \\\n \tenv.lo eoshift0.lo eoshift2.lo erfc_scaled.lo etime.lo exit.lo \\\n-\tfnum.lo gerror.lo getcwd.lo getlog.lo getXid.lo hostnm.lo \\\n-\tierrno.lo ishftc.lo iso_c_generated_procs.lo iso_c_binding.lo \\\n-\tkill.lo link.lo malloc.lo mvbits.lo move_alloc.lo \\\n-\tpack_generic.lo perror.lo selected_char_kind.lo signal.lo \\\n-\tsize.lo sleep.lo spread_generic.lo string_intrinsics.lo \\\n-\tsystem.lo rand.lo random.lo rename.lo reshape_generic.lo \\\n-\treshape_packed.lo selected_int_kind.lo selected_real_kind.lo \\\n-\tstat.lo symlnk.lo system_clock.lo time.lo transpose_generic.lo \\\n-\tumask.lo unlink.lo unpack_generic.lo in_pack_generic.lo \\\n+\textends_type_of.lo fnum.lo gerror.lo getcwd.lo getlog.lo \\\n+\tgetXid.lo hostnm.lo ierrno.lo ishftc.lo \\\n+\tiso_c_generated_procs.lo iso_c_binding.lo kill.lo link.lo \\\n+\tmalloc.lo mvbits.lo move_alloc.lo pack_generic.lo perror.lo \\\n+\tselected_char_kind.lo signal.lo size.lo sleep.lo \\\n+\tspread_generic.lo string_intrinsics.lo system.lo rand.lo \\\n+\trandom.lo rename.lo reshape_generic.lo reshape_packed.lo \\\n+\tselected_int_kind.lo selected_real_kind.lo stat.lo symlnk.lo \\\n+\tsystem_clock.lo time.lo transpose_generic.lo umask.lo \\\n+\tunlink.lo unpack_generic.lo in_pack_generic.lo \\\n \tin_unpack_generic.lo\n am__objects_37 =\n am__objects_38 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n@@ -1030,6 +1031,7 @@ intrinsics/eoshift2.c \\\n intrinsics/erfc_scaled.c \\\n intrinsics/etime.c \\\n intrinsics/exit.c \\\n+intrinsics/extends_type_of.c \\\n intrinsics/fnum.c \\\n intrinsics/gerror.c \\\n intrinsics/getcwd.c \\\n@@ -1892,6 +1894,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/exponent_r16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/exponent_r4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/exponent_r8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/extends_type_of.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fbuf.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/file_pos.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fmain.Plo@am__quote@\n@@ -5478,6 +5481,13 @@ exit.lo: intrinsics/exit.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o exit.lo `test -f 'intrinsics/exit.c' || echo '$(srcdir)/'`intrinsics/exit.c\n \n+extends_type_of.lo: intrinsics/extends_type_of.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT extends_type_of.lo -MD -MP -MF $(DEPDIR)/extends_type_of.Tpo -c -o extends_type_of.lo `test -f 'intrinsics/extends_type_of.c' || echo '$(srcdir)/'`intrinsics/extends_type_of.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/extends_type_of.Tpo $(DEPDIR)/extends_type_of.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='intrinsics/extends_type_of.c' object='extends_type_of.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o extends_type_of.lo `test -f 'intrinsics/extends_type_of.c' || echo '$(srcdir)/'`intrinsics/extends_type_of.c\n+\n fnum.lo: intrinsics/fnum.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT fnum.lo -MD -MP -MF $(DEPDIR)/fnum.Tpo -c -o fnum.lo `test -f 'intrinsics/fnum.c' || echo '$(srcdir)/'`intrinsics/fnum.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/fnum.Tpo $(DEPDIR)/fnum.Plo"}, {"sha": "3541d142a7be511d2c18ecb21c9c0065864bd40f", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -1095,6 +1095,7 @@ GFORTRAN_1.2 {\n   global:\n     _gfortran_clz128;\n     _gfortran_ctz128;\n+    _gfortran_is_extension_of;\n } GFORTRAN_1.1; \n \n F2C_1.0 {"}, {"sha": "2fd149c18a543a9bbb504db22dfa185fcc96e81f", "filename": "libgfortran/intrinsics/extends_type_of.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c1dab0d8b4eef485b57813e1bb68542980db377/libgfortran%2Fintrinsics%2Fextends_type_of.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c1dab0d8b4eef485b57813e1bb68542980db377/libgfortran%2Fintrinsics%2Fextends_type_of.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fextends_type_of.c?ref=7c1dab0d8b4eef485b57813e1bb68542980db377", "patch": "@@ -0,0 +1,61 @@\n+/* Implementation of the EXTENDS_TYPE_OF intrinsic.\n+   Copyright (C) 2004, 2007, 2009 Free Software Foundation, Inc.\n+   Contributed by Janus Weil <janus@gcc.gnu.org>.\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */ \n+\n+\n+#include \"libgfortran.h\"\n+\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+\n+\n+typedef struct vtype\n+{\n+  GFC_INTEGER_4 hash;\n+  GFC_INTEGER_4 size;\n+  struct vtype *extends;\n+}\n+vtype;\n+\n+\n+extern GFC_LOGICAL_4 is_extension_of (struct vtype *, struct vtype *);\n+export_proto(is_extension_of);\n+\n+\n+/* This is a helper function for the F2003 intrinsic EXTENDS_TYPE_OF.\n+   While EXTENDS_TYPE_OF accepts CLASS or TYPE arguments, this one here gets\n+   passed the corresponding vtabs. Each call to EXTENDS_TYPE_OF is translated\n+   to a call to is_extension_of.  */\n+\n+GFC_LOGICAL_4\n+is_extension_of (struct vtype *v1, struct vtype *v2)\n+{\n+  while (v1)\n+    {\n+      if (v1->hash == v2->hash) return 1;\n+      v1 = v1->extends;\n+    }\n+  return 0;\n+}"}]}