{"sha": "1c7717c3a8b6e5fab41b071961c8fb00e889dc01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWM3NzE3YzNhOGI2ZTVmYWI0MWIwNzE5NjFjOGZiMDBlODg5ZGMwMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-08-22T13:27:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-08-22T13:27:35Z"}, "message": "2008-08-22  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.adb:\n\t(In_Subrange_Of): New calling sequence\n\t(Determine_Range): Prepare for new processing using base type\n\n\t* exp_ch4.adb:\n\t(Compile_Time_Compare): Use new calling sequence\n\n\t* exp_ch5.adb:\n\t(Compile_Time_Compare): Use new calling sequence\n\n\t* sem_eval.adb:\n\t(Compile_Time_Compare): New calling sequence allows dealing with\n\tinvalid values.\n\t(In_Subrange_Of): Ditto\n\n\t* sem_eval.ads:\n\t(Compile_Time_Compare): New calling sequence allows dealing with\n\tinvalid values.\n\t(In_Subrange_Of): Ditto\n\nFrom-SVN: r139467", "tree": {"sha": "4ee1820bdac7aaddef843304ab402c39277f575a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ee1820bdac7aaddef843304ab402c39277f575a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c7717c3a8b6e5fab41b071961c8fb00e889dc01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c7717c3a8b6e5fab41b071961c8fb00e889dc01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c7717c3a8b6e5fab41b071961c8fb00e889dc01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c7717c3a8b6e5fab41b071961c8fb00e889dc01/comments", "author": null, "committer": null, "parents": [{"sha": "23922a2f6acfcbdf13363db7ddf4fcf3aa4dfc79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23922a2f6acfcbdf13363db7ddf4fcf3aa4dfc79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23922a2f6acfcbdf13363db7ddf4fcf3aa4dfc79"}], "stats": {"total": 205, "additions": 167, "deletions": 38}, "files": [{"sha": "187b1494c07f6390438c0c1849d8ccdcf81443f9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c7717c3a8b6e5fab41b071961c8fb00e889dc01/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c7717c3a8b6e5fab41b071961c8fb00e889dc01/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1c7717c3a8b6e5fab41b071961c8fb00e889dc01", "patch": "@@ -1,3 +1,72 @@\n+2008-08-22  Doug Rupp  <rupp@adacore.com>\n+\n+\t* bindgen.adb [VMS] (Gen_Adainit_Ada, Gen_Adainit_C): Import and call\n+\t__gnat_set_features.\n+\n+\t* init.c\n+\t(__gnat_set_features): New function.\n+\t(__gnat_features_set): New tracking variable.\n+\t(__gl_no_malloc_64): New feature global variable\n+\n+2008-08-22  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch8.adb (Use_One_Type): Do not emit warning message about redundant\n+\tuse_type_clause in an instance.\n+\n+2008-08-22  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch6.ads: Remove pragma Precondition, since it breaks some builds.\n+\n+2008-08-22  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch6.adb: Minor reformatting\n+\n+\t* exp_ch7.adb: Minor reformatting\n+\n+\t* exp_ch7.ads: Put routines in proper alpha order\n+\n+\t* exp_dist.adb: Minor reformatting\n+\n+2008-08-22  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj.ads: Minor comment update\n+\n+2008-08-22  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch5.adb (One_Bound): Fix latent bug involving secondary stack\n+\n+2008-08-22  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_tss.adb:\n+\t(Base_Init_Proc): For a protected subtype, use the base type of the\n+\tcorresponding record to locate the propoer initialization procedure.\n+\n+2008-08-22  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.adb:\n+\t(In_Subrange_Of): New calling sequence\n+\t(Determine_Range): Prepare for new processing using base type\n+\n+\t* exp_ch4.adb:\n+\t(Compile_Time_Compare): Use new calling sequence\n+\n+\t* exp_ch5.adb:\n+\t(Compile_Time_Compare): Use new calling sequence\n+\n+\t* sem_eval.adb:\n+\t(Compile_Time_Compare): New calling sequence allows dealing with\n+\tinvalid values.\n+\t(In_Subrange_Of): Ditto\n+\n+\t* sem_eval.ads:\n+\t(Compile_Time_Compare): New calling sequence allows dealing with\n+\tinvalid values.\n+\t(In_Subrange_Of): Ditto\n+\n+2008-08-22  Pascal Obry  <obry@adacore.com>\n+\n+\t* adaint.c: Fix possible race condition on win32_wait().\n+\n 2008-08-22  Bob Duff  <duff@adacore.com>\n \n \t* exp_ch5.adb, exp_ch7.adb, exp_ch7.ads, exp_util.adb, freeze.adb,"}, {"sha": "5dac9262e038c3eea84af7e1511ce29f6f74c04c", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c7717c3a8b6e5fab41b071961c8fb00e889dc01/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c7717c3a8b6e5fab41b071961c8fb00e889dc01/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=1c7717c3a8b6e5fab41b071961c8fb00e889dc01", "patch": "@@ -2042,7 +2042,9 @@ package body Checks is\n         and then\n            Is_Discrete_Type (S_Typ) = Is_Discrete_Type (Target_Typ)\n         and then\n-          (In_Subrange_Of (S_Typ, Target_Typ, Fixed_Int)\n+          (In_Subrange_Of (S_Typ, Target_Typ,\n+                           Assume_Valid => True,\n+                           Fixed_Int    => Fixed_Int)\n              or else\n            Is_In_Range (Expr, Target_Typ, Fixed_Int, Int_Real))\n       then\n@@ -2349,7 +2351,10 @@ package body Checks is\n \n          begin\n             if not Overflow_Checks_Suppressed (Target_Base)\n-              and then not In_Subrange_Of (Expr_Type, Target_Base, Conv_OK)\n+              and then not\n+                In_Subrange_Of (Expr_Type, Target_Base,\n+                                Assume_Valid => True,\n+                                Fixed_Int    => Conv_OK)\n               and then not Float_To_Int\n             then\n                Activate_Overflow_Check (N);\n@@ -3021,7 +3026,8 @@ package body Checks is\n       Lo : out Uint;\n       Hi : out Uint)\n    is\n-      Typ : constant Entity_Id := Etype (N);\n+      Typ : Entity_Id := Etype (N);\n+      --  Type to use, may get reset to base type for possibly invalid entity\n \n       Lo_Left : Uint;\n       Hi_Left : Uint;\n@@ -3116,6 +3122,17 @@ package body Checks is\n       --  overflow situation, which is a separate check, we are talking here\n       --  only about the expression value).\n \n+      --  First step, change to use base type if the expression is an entity\n+      --  which we do not know is valid.\n+\n+      --  For now, we do not do this\n+\n+      if False and then Is_Entity_Name (N)\n+        and then not Is_Known_Valid (Entity (N))\n+      then\n+         Typ := Base_Type (Typ);\n+      end if;\n+\n       --  We use the actual bound unless it is dynamic, in which case use the\n       --  corresponding base type bound if possible. If we can't get a bound\n       --  then we figure we can't determine the range (a peculiar case, that\n@@ -4561,7 +4578,7 @@ package body Checks is\n       --  case the literal has already been labeled as having the subtype of\n       --  the target.\n \n-      if In_Subrange_Of (Source_Type, Target_Type)\n+      if In_Subrange_Of (Source_Type, Target_Type, Assume_Valid => True)\n         and then not\n           (Nkind (N) = N_Integer_Literal\n              or else\n@@ -4616,7 +4633,9 @@ package body Checks is\n \n       --  The conversions will always work and need no check\n \n-      elsif In_Subrange_Of (Target_Type, Source_Base_Type) then\n+      elsif In_Subrange_Of\n+             (Target_Type, Source_Base_Type, Assume_Valid => True)\n+      then\n          Insert_Action (N,\n            Make_Raise_Constraint_Error (Loc,\n              Condition =>\n@@ -4648,7 +4667,9 @@ package body Checks is\n       --  If that is the case, we can freely convert the source to the target,\n       --  and then test the target result against the bounds.\n \n-      elsif In_Subrange_Of (Source_Type, Target_Base_Type) then\n+      elsif In_Subrange_Of\n+             (Source_Type, Target_Base_Type, Assume_Valid => True)\n+      then\n \n          --  We make a temporary to hold the value of the converted value\n          --  (converted to the base type), and then we will do the test against\n@@ -6811,7 +6832,7 @@ package body Checks is\n          --  range of the target type.\n \n          else\n-            if not In_Subrange_Of (S_Typ, T_Typ) then\n+            if not In_Subrange_Of (S_Typ, T_Typ, Assume_Valid => True) then\n                Cond := Discrete_Expr_Cond (Ck_Node, T_Typ);\n             end if;\n          end if;"}, {"sha": "6e763729a4686dbf20b71b5952651a5e47211a55", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c7717c3a8b6e5fab41b071961c8fb00e889dc01/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c7717c3a8b6e5fab41b071961c8fb00e889dc01/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=1c7717c3a8b6e5fab41b071961c8fb00e889dc01", "patch": "@@ -3826,8 +3826,10 @@ package body Exp_Ch4 is\n             Lo_Orig : constant Node_Id := Original_Node (Lo);\n             Hi_Orig : constant Node_Id := Original_Node (Hi);\n \n-            Lcheck : constant Compare_Result := Compile_Time_Compare (Lop, Lo);\n-            Ucheck : constant Compare_Result := Compile_Time_Compare (Lop, Hi);\n+            Lcheck : constant Compare_Result :=\n+                       Compile_Time_Compare (Lop, Lo, Assume_Valid => True);\n+            Ucheck : constant Compare_Result :=\n+                       Compile_Time_Compare (Lop, Hi, Assume_Valid => True);\n \n             Warn1 : constant Boolean :=\n                       Constant_Condition_Warnings\n@@ -9025,7 +9027,8 @@ package body Exp_Ch4 is\n          Op1 : constant Node_Id   := Left_Opnd (N);\n          Op2 : constant Node_Id   := Right_Opnd (N);\n \n-         Res : constant Compare_Result := Compile_Time_Compare (Op1, Op2);\n+         Res : constant Compare_Result :=\n+                 Compile_Time_Compare (Op1, Op2, Assume_Valid => True);\n          --  Res indicates if compare outcome can be compile time determined\n \n          True_Result  : Boolean;"}, {"sha": "d1c9d884e9523c641c92c2f0710fbbc39cf89726", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c7717c3a8b6e5fab41b071961c8fb00e889dc01/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c7717c3a8b6e5fab41b071961c8fb00e889dc01/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=1c7717c3a8b6e5fab41b071961c8fb00e889dc01", "patch": "@@ -614,10 +614,14 @@ package body Exp_Ch5 is\n             --  or upper bounds at compile time and compare them.\n \n             else\n-               Cresult := Compile_Time_Compare (Left_Lo, Right_Lo);\n+               Cresult :=\n+                 Compile_Time_Compare\n+                   (Left_Lo, Right_Lo, Assume_Valid => True);\n \n                if Cresult = Unknown then\n-                  Cresult := Compile_Time_Compare (Left_Hi, Right_Hi);\n+                  Cresult :=\n+                    Compile_Time_Compare\n+                      (Left_Hi, Right_Hi, Assume_Valid => True);\n                end if;\n \n                case Cresult is"}, {"sha": "b9c1d13313c74168b4eeb53fa259340f2d6d2480", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c7717c3a8b6e5fab41b071961c8fb00e889dc01/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c7717c3a8b6e5fab41b071961c8fb00e889dc01/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=1c7717c3a8b6e5fab41b071961c8fb00e889dc01", "patch": "@@ -378,11 +378,16 @@ package body Sem_Eval is\n    --------------------------\n \n    function Compile_Time_Compare\n-     (L, R : Node_Id;\n-      Rec  : Boolean := False) return Compare_Result\n+     (L, R         : Node_Id;\n+      Assume_Valid : Boolean;\n+      Rec          : Boolean := False) return Compare_Result\n    is\n-      Ltyp : constant Entity_Id := Etype (L);\n-      Rtyp : constant Entity_Id := Etype (R);\n+      Ltyp : Entity_Id := Etype (L);\n+      Rtyp : Entity_Id := Etype (R);\n+      --  These get reset to the base type for the case of entities where\n+      --  Is_Known_Valid is not set. This takes care of handling possible\n+      --  invalid representations using the value of the base type, in\n+      --  accordance with RM 13.9.1(10).\n \n       procedure Compare_Decompose\n         (N : Node_Id;\n@@ -739,6 +744,20 @@ package body Sem_Eval is\n             return Unknown;\n          end if;\n \n+         --  Replace types by base types for the case of entities which are\n+         --  not known to have valid representations. This takes care of\n+         --  properly dealing with invalid representations.\n+\n+         if not Assume_Valid then\n+            if Is_Entity_Name (L) and then not Is_Known_Valid (Entity (L)) then\n+               Ltyp := Base_Type (Ltyp);\n+            end if;\n+\n+            if Is_Entity_Name (R) and then not Is_Known_Valid (Entity (R)) then\n+               Rtyp := Base_Type (Rtyp);\n+            end if;\n+         end if;\n+\n          --  Here is where we check for comparisons against maximum bounds of\n          --  types, where we know that no value can be outside the bounds of\n          --  the subtype. Note that this routine is allowed to assume that all\n@@ -758,28 +777,32 @@ package body Sem_Eval is\n             --  See if we can get a decisive check against one operand and\n             --  a bound of the other operand (four possible tests here).\n \n-            case Compile_Time_Compare (L, Type_Low_Bound (Rtyp), True) is\n+            case Compile_Time_Compare (L, Type_Low_Bound (Rtyp),\n+                                       Assume_Valid, Rec => True) is\n                when LT => return LT;\n                when LE => return LE;\n                when EQ => return LE;\n                when others => null;\n             end case;\n \n-            case Compile_Time_Compare (L, Type_High_Bound (Rtyp), True) is\n+            case Compile_Time_Compare (L, Type_High_Bound (Rtyp),\n+                                       Assume_Valid, Rec => True) is\n                when GT => return GT;\n                when GE => return GE;\n                when EQ => return GE;\n                when others => null;\n             end case;\n \n-            case Compile_Time_Compare (Type_Low_Bound (Ltyp), R, True) is\n+            case Compile_Time_Compare (Type_Low_Bound (Ltyp), R,\n+                                       Assume_Valid, Rec => True) is\n                when GT => return GT;\n                when GE => return GE;\n                when EQ => return GE;\n                when others => null;\n             end case;\n \n-            case Compile_Time_Compare (Type_High_Bound (Ltyp), R, True) is\n+            case Compile_Time_Compare (Type_High_Bound (Ltyp), R,\n+                                       Assume_Valid, Rec => True) is\n                when LT => return LT;\n                when LE => return LE;\n                when EQ => return LE;\n@@ -3485,9 +3508,10 @@ package body Sem_Eval is\n    --------------------\n \n    function In_Subrange_Of\n-     (T1        : Entity_Id;\n-      T2        : Entity_Id;\n-      Fixed_Int : Boolean := False) return Boolean\n+     (T1           : Entity_Id;\n+      T2           : Entity_Id;\n+      Assume_Valid : Boolean;\n+      Fixed_Int    : Boolean := False) return Boolean\n    is\n       L1 : Node_Id;\n       H1 : Node_Id;\n@@ -3514,9 +3538,9 @@ package body Sem_Eval is\n \n          --  Check bounds to see if comparison possible at compile time\n \n-         if Compile_Time_Compare (L1, L2) in Compare_GE\n+         if Compile_Time_Compare (L1, L2, Assume_Valid) in Compare_GE\n               and then\n-            Compile_Time_Compare (H1, H2) in Compare_LE\n+            Compile_Time_Compare (H1, H2, Assume_Valid) in Compare_LE\n          then\n             return True;\n          end if;\n@@ -3766,10 +3790,10 @@ package body Sem_Eval is\n    ---------------------\n \n    function Is_Out_Of_Range\n-     (N         : Node_Id;\n-      Typ       : Entity_Id;\n-      Fixed_Int : Boolean := False;\n-      Int_Real  : Boolean := False) return Boolean\n+     (N            : Node_Id;\n+      Typ          : Entity_Id;\n+      Fixed_Int    : Boolean := False;\n+      Int_Real     : Boolean := False) return Boolean\n    is\n       Val  : Uint;\n       Valr : Ureal;"}, {"sha": "f294ed43337207e95c44fd2a9513c340a780a63f", "filename": "gcc/ada/sem_eval.ads", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c7717c3a8b6e5fab41b071961c8fb00e889dc01/gcc%2Fada%2Fsem_eval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c7717c3a8b6e5fab41b071961c8fb00e889dc01/gcc%2Fada%2Fsem_eval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.ads?ref=1c7717c3a8b6e5fab41b071961c8fb00e889dc01", "patch": "@@ -133,16 +133,21 @@ package Sem_Eval is\n    subtype Compare_GE is Compare_Result range EQ .. GE;\n    subtype Compare_LE is Compare_Result range LT .. EQ;\n    function Compile_Time_Compare\n-     (L, R : Node_Id;\n-      Rec  : Boolean := False) return Compare_Result;\n+     (L, R         : Node_Id;\n+      Assume_Valid : Boolean;\n+      Rec          : Boolean := False) return Compare_Result;\n    --  Given two expression nodes, finds out whether it can be determined at\n    --  compile time how the runtime values will compare. An Unknown result\n    --  means that the result of a comparison cannot be determined at compile\n    --  time, otherwise the returned result indicates the known result of the\n    --  comparison, given as tightly as possible (i.e. EQ or LT is preferred\n-   --  returned value to LE). Rec is a parameter that is set True for a\n-   --  recursive call from within Compile_Time_Compare to avoid some infinite\n-   --  recursion cases. It should never be set by a client.\n+   --  returned value to LE). If Assume_Valid is true, the result reflects\n+   --  the result of assuming that entities involved in the comparison have\n+   --  valid representations. If Assume_Valid is false, then the base type of\n+   --  any involved entity is used so that no assumption of validity is made.\n+   --  Rec is a parameter that is set True for a recursive call from within\n+   --  Compile_Time_Compare to avoid some infinite recursion cases. It should\n+   --  never be set by a client.\n \n    procedure Flag_Non_Static_Expr (Msg : String; Expr : Node_Id);\n    --  This procedure is called after it has been determined that Expr is not\n@@ -357,14 +362,17 @@ package Sem_Eval is\n    --  and Fixed_Int are used as in routine Is_In_Range above.\n \n    function In_Subrange_Of\n-     (T1        : Entity_Id;\n-      T2        : Entity_Id;\n-      Fixed_Int : Boolean := False) return Boolean;\n+     (T1           : Entity_Id;\n+      T2           : Entity_Id;\n+      Assume_Valid : Boolean;\n+      Fixed_Int    : Boolean := False) return Boolean;\n    --  Returns True if it can be guaranteed at compile time that the range of\n    --  values for scalar type T1 are always in the range of scalar type T2. A\n    --  result of False does not mean that T1 is not in T2's subrange, only that\n    --  it cannot be determined at compile time. Flag Fixed_Int is used as in\n-   --  routine Is_In_Range above.\n+   --  routine Is_In_Range above. If Assume_Valid is true, the result reflects\n+   --  the result of assuming that entities involved in the comparison have\n+   --  valid representations.\n \n    function Is_Null_Range (Lo : Node_Id; Hi : Node_Id) return Boolean;\n    --  Returns True if it can guarantee that Lo .. Hi is a null range. If it"}]}