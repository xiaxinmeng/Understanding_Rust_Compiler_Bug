{"sha": "1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZiYTA2MDZiODEzYWIwOTI1ZTdmYzllZTkyYzliNTdjN2MzYjk0Zg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-07-25T10:40:12Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-07-25T10:40:12Z"}, "message": "Move std::unique_lock definition to a separate header\n\nThis will allow std::mutex and std::lock_guard to be used elsewhere in\nthe library without pulling in the whole of <chrono>.\n\nPreviously the whole of <bits/std_mutex.h> was conditional on the\n_GLIBCXX_USE_C99_STDINT_TR1 macro, but only the std::unique_lock members\nthat use <chrono> facilities should depend on that. std::mutex only\nneeds to depend on _GLIBCXX_HAS_GTHREADS and std::lock_guard can be\ndefined unconditionally.\n\nSome parts of <bits/std_mutex.h> and <mutex> are based on code in\n<ext/concurrence.h> which dates from 2003. However, the std::unique_lock\nimplementation was added in 2008 by r135007, without using any earlier\ncode. Therefore the new header file has copyright years 2008-2018.\n\n\t* include/Makefile.am: Add new <bits/unique_lock.h> header.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/std_mutex.h [!_GLIBCXX_USE_C99_STDINT_TR1] (mutex)\n\t(lock_guard): Define independent of _GLIBCXX_USE_C99_STDINT_TR1.\n\t(unique_lock): Move definition to ...\n\t* include/bits/unique_lock.h: New header.\n\t[!_GLIBCXX_USE_C99_STDINT_TR1] (unique_lock): Define unconditionally.\n\t[_GLIBCXX_USE_C99_STDINT_TR1] (unique_lock(mutex_type&, time_point))\n\t(unique_lock(mutex_type&, duration), unique_lock::try_lock_until)\n\t(unique_lock::try_lock_for): Define only when <chrono> is usable.\n\t* include/std/condition_variable: Include <bits/unique_lock.h>.\n\t* include/std/mutex: Likewise.\n\nFrom-SVN: r262963", "tree": {"sha": "533771db472d612b364ad1252a9002ff46e0abdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/533771db472d612b364ad1252a9002ff46e0abdc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1978cc78c86a82055f1981569f8383770c825e70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1978cc78c86a82055f1981569f8383770c825e70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1978cc78c86a82055f1981569f8383770c825e70"}], "stats": {"total": 463, "additions": 268, "deletions": 195}, "files": [{"sha": "76903e3e9abf21faca880797b9e87992eaab4427", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f", "patch": "@@ -1,3 +1,18 @@\n+2018-07-25  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/Makefile.am: Add new <bits/unique_lock.h> header.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/bits/std_mutex.h [!_GLIBCXX_USE_C99_STDINT_TR1] (mutex)\n+\t(lock_guard): Define independent of _GLIBCXX_USE_C99_STDINT_TR1.\n+\t(unique_lock): Move definition to ...\n+\t* include/bits/unique_lock.h: New header.\n+\t[!_GLIBCXX_USE_C99_STDINT_TR1] (unique_lock): Define unconditionally.\n+\t[_GLIBCXX_USE_C99_STDINT_TR1] (unique_lock(mutex_type&, time_point))\n+\t(unique_lock(mutex_type&, duration), unique_lock::try_lock_until)\n+\t(unique_lock::try_lock_for): Define only when <chrono> is usable.\n+\t* include/std/condition_variable: Include <bits/unique_lock.h>.\n+\t* include/std/mutex: Likewise.\n+\n 2018-07-24  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* config/abi/pre/gnu.ver: Export new symbols."}, {"sha": "70db3cb6260172d0e1f8d5ce63f5e5bec167d938", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f", "patch": "@@ -199,6 +199,7 @@ bits_headers = \\\n \t${bits_srcdir}/stringfwd.h \\\n \t${bits_srcdir}/string_view.tcc \\\n \t${bits_srcdir}/uniform_int_dist.h \\\n+\t${bits_srcdir}/unique_lock.h \\\n \t${bits_srcdir}/unique_ptr.h \\\n \t${bits_srcdir}/unordered_map.h \\\n \t${bits_srcdir}/unordered_set.h \\"}, {"sha": "0e1cbe489d7b95ffbc01859d5db8481a707189c6", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f", "patch": "@@ -492,6 +492,7 @@ bits_headers = \\\n \t${bits_srcdir}/stringfwd.h \\\n \t${bits_srcdir}/string_view.tcc \\\n \t${bits_srcdir}/uniform_int_dist.h \\\n+\t${bits_srcdir}/unique_lock.h \\\n \t${bits_srcdir}/unique_ptr.h \\\n \t${bits_srcdir}/unordered_map.h \\\n \t${bits_srcdir}/unordered_set.h \\"}, {"sha": "41a9b30636a7a3d0fbdd046432bdf8dde55f5e9c", "filename": "libstdc++-v3/include/bits/std_mutex.h", "status": "modified", "additions": 0, "deletions": 195, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_mutex.h?ref=1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f", "patch": "@@ -39,9 +39,6 @@\n #include <system_error>\n #include <bits/functexcept.h>\n #include <bits/gthr.h>\n-#include <bits/move.h> // for std::swap\n-\n-#ifdef _GLIBCXX_USE_C99_STDINT_TR1\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -174,200 +171,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       mutex_type&  _M_device;\n     };\n \n-  /** @brief A movable scoped lock type.\n-   *\n-   * A unique_lock controls mutex ownership within a scope. Ownership of the\n-   * mutex can be delayed until after construction and can be transferred\n-   * to another unique_lock by move construction or move assignment. If a\n-   * mutex lock is owned when the destructor runs ownership will be released.\n-   */\n-  template<typename _Mutex>\n-    class unique_lock\n-    {\n-    public:\n-      typedef _Mutex mutex_type;\n-\n-      unique_lock() noexcept\n-      : _M_device(0), _M_owns(false)\n-      { }\n-\n-      explicit unique_lock(mutex_type& __m)\n-      : _M_device(std::__addressof(__m)), _M_owns(false)\n-      {\n-\tlock();\n-\t_M_owns = true;\n-      }\n-\n-      unique_lock(mutex_type& __m, defer_lock_t) noexcept\n-      : _M_device(std::__addressof(__m)), _M_owns(false)\n-      { }\n-\n-      unique_lock(mutex_type& __m, try_to_lock_t)\n-      : _M_device(std::__addressof(__m)), _M_owns(_M_device->try_lock())\n-      { }\n-\n-      unique_lock(mutex_type& __m, adopt_lock_t) noexcept\n-      : _M_device(std::__addressof(__m)), _M_owns(true)\n-      {\n-\t// XXX calling thread owns mutex\n-      }\n-\n-      template<typename _Clock, typename _Duration>\n-\tunique_lock(mutex_type& __m,\n-\t\t    const chrono::time_point<_Clock, _Duration>& __atime)\n-\t: _M_device(std::__addressof(__m)),\n-\t  _M_owns(_M_device->try_lock_until(__atime))\n-\t{ }\n-\n-      template<typename _Rep, typename _Period>\n-\tunique_lock(mutex_type& __m,\n-\t\t    const chrono::duration<_Rep, _Period>& __rtime)\n-\t: _M_device(std::__addressof(__m)),\n-\t  _M_owns(_M_device->try_lock_for(__rtime))\n-\t{ }\n-\n-      ~unique_lock()\n-      {\n-\tif (_M_owns)\n-\t  unlock();\n-      }\n-\n-      unique_lock(const unique_lock&) = delete;\n-      unique_lock& operator=(const unique_lock&) = delete;\n-\n-      unique_lock(unique_lock&& __u) noexcept\n-      : _M_device(__u._M_device), _M_owns(__u._M_owns)\n-      {\n-\t__u._M_device = 0;\n-\t__u._M_owns = false;\n-      }\n-\n-      unique_lock& operator=(unique_lock&& __u) noexcept\n-      {\n-\tif(_M_owns)\n-\t  unlock();\n-\n-\tunique_lock(std::move(__u)).swap(*this);\n-\n-\t__u._M_device = 0;\n-\t__u._M_owns = false;\n-\n-\treturn *this;\n-      }\n-\n-      void\n-      lock()\n-      {\n-\tif (!_M_device)\n-\t  __throw_system_error(int(errc::operation_not_permitted));\n-\telse if (_M_owns)\n-\t  __throw_system_error(int(errc::resource_deadlock_would_occur));\n-\telse\n-\t  {\n-\t    _M_device->lock();\n-\t    _M_owns = true;\n-\t  }\n-      }\n-\n-      bool\n-      try_lock()\n-      {\n-\tif (!_M_device)\n-\t  __throw_system_error(int(errc::operation_not_permitted));\n-\telse if (_M_owns)\n-\t  __throw_system_error(int(errc::resource_deadlock_would_occur));\n-\telse\n-\t  {\n-\t    _M_owns = _M_device->try_lock();\n-\t    return _M_owns;\n-\t  }\n-      }\n-\n-      template<typename _Clock, typename _Duration>\n-\tbool\n-\ttry_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)\n-\t{\n-\t  if (!_M_device)\n-\t    __throw_system_error(int(errc::operation_not_permitted));\n-\t  else if (_M_owns)\n-\t    __throw_system_error(int(errc::resource_deadlock_would_occur));\n-\t  else\n-\t    {\n-\t      _M_owns = _M_device->try_lock_until(__atime);\n-\t      return _M_owns;\n-\t    }\n-\t}\n-\n-      template<typename _Rep, typename _Period>\n-\tbool\n-\ttry_lock_for(const chrono::duration<_Rep, _Period>& __rtime)\n-\t{\n-\t  if (!_M_device)\n-\t    __throw_system_error(int(errc::operation_not_permitted));\n-\t  else if (_M_owns)\n-\t    __throw_system_error(int(errc::resource_deadlock_would_occur));\n-\t  else\n-\t    {\n-\t      _M_owns = _M_device->try_lock_for(__rtime);\n-\t      return _M_owns;\n-\t    }\n-\t }\n-\n-      void\n-      unlock()\n-      {\n-\tif (!_M_owns)\n-\t  __throw_system_error(int(errc::operation_not_permitted));\n-\telse if (_M_device)\n-\t  {\n-\t    _M_device->unlock();\n-\t    _M_owns = false;\n-\t  }\n-      }\n-\n-      void\n-      swap(unique_lock& __u) noexcept\n-      {\n-\tstd::swap(_M_device, __u._M_device);\n-\tstd::swap(_M_owns, __u._M_owns);\n-      }\n-\n-      mutex_type*\n-      release() noexcept\n-      {\n-\tmutex_type* __ret = _M_device;\n-\t_M_device = 0;\n-\t_M_owns = false;\n-\treturn __ret;\n-      }\n-\n-      bool\n-      owns_lock() const noexcept\n-      { return _M_owns; }\n-\n-      explicit operator bool() const noexcept\n-      { return owns_lock(); }\n-\n-      mutex_type*\n-      mutex() const noexcept\n-      { return _M_device; }\n-\n-    private:\n-      mutex_type*\t_M_device;\n-      bool\t\t_M_owns; // XXX use atomic_bool\n-    };\n-\n-  /// Swap overload for unique_lock objects.\n-  template<typename _Mutex>\n-    inline void\n-    swap(unique_lock<_Mutex>& __x, unique_lock<_Mutex>& __y) noexcept\n-    { __x.swap(__y); }\n-\n   // @} group mutexes\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n-#endif // _GLIBCXX_USE_C99_STDINT_TR1\n-\n #endif // C++11\n-\n #endif // _GLIBCXX_MUTEX_H"}, {"sha": "e0e7400b51649b122a05b25cd5849508ee854b47", "filename": "libstdc++-v3/include/bits/unique_lock.h", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_lock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_lock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_lock.h?ref=1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f", "patch": "@@ -0,0 +1,249 @@\n+// std::unique_lock implementation -*- C++ -*-\n+\n+// Copyright (C) 2008-2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/unique_lock.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{mutex}\n+ */\n+\n+#ifndef _GLIBCXX_UNIQUE_LOCK_H\n+#define _GLIBCXX_UNIQUE_LOCK_H 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus < 201103L\n+# include <bits/c++0x_warning.h>\n+#else\n+\n+#include <chrono>\n+#include <bits/move.h> // for std::swap\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   * @ingroup mutexes\n+   * @{\n+   */\n+\n+  /** @brief A movable scoped lock type.\n+   *\n+   * A unique_lock controls mutex ownership within a scope. Ownership of the\n+   * mutex can be delayed until after construction and can be transferred\n+   * to another unique_lock by move construction or move assignment. If a\n+   * mutex lock is owned when the destructor runs ownership will be released.\n+   */\n+  template<typename _Mutex>\n+    class unique_lock\n+    {\n+    public:\n+      typedef _Mutex mutex_type;\n+\n+      unique_lock() noexcept\n+      : _M_device(0), _M_owns(false)\n+      { }\n+\n+      explicit unique_lock(mutex_type& __m)\n+      : _M_device(std::__addressof(__m)), _M_owns(false)\n+      {\n+\tlock();\n+\t_M_owns = true;\n+      }\n+\n+      unique_lock(mutex_type& __m, defer_lock_t) noexcept\n+      : _M_device(std::__addressof(__m)), _M_owns(false)\n+      { }\n+\n+      unique_lock(mutex_type& __m, try_to_lock_t)\n+      : _M_device(std::__addressof(__m)), _M_owns(_M_device->try_lock())\n+      { }\n+\n+      unique_lock(mutex_type& __m, adopt_lock_t) noexcept\n+      : _M_device(std::__addressof(__m)), _M_owns(true)\n+      {\n+\t// XXX calling thread owns mutex\n+      }\n+\n+#ifdef _GLIBCXX_USE_C99_STDINT_TR1\n+      template<typename _Clock, typename _Duration>\n+\tunique_lock(mutex_type& __m,\n+\t\t    const chrono::time_point<_Clock, _Duration>& __atime)\n+\t: _M_device(std::__addressof(__m)),\n+\t  _M_owns(_M_device->try_lock_until(__atime))\n+\t{ }\n+\n+      template<typename _Rep, typename _Period>\n+\tunique_lock(mutex_type& __m,\n+\t\t    const chrono::duration<_Rep, _Period>& __rtime)\n+\t: _M_device(std::__addressof(__m)),\n+\t  _M_owns(_M_device->try_lock_for(__rtime))\n+\t{ }\n+#endif\n+\n+      ~unique_lock()\n+      {\n+\tif (_M_owns)\n+\t  unlock();\n+      }\n+\n+      unique_lock(const unique_lock&) = delete;\n+      unique_lock& operator=(const unique_lock&) = delete;\n+\n+      unique_lock(unique_lock&& __u) noexcept\n+      : _M_device(__u._M_device), _M_owns(__u._M_owns)\n+      {\n+\t__u._M_device = 0;\n+\t__u._M_owns = false;\n+      }\n+\n+      unique_lock& operator=(unique_lock&& __u) noexcept\n+      {\n+\tif(_M_owns)\n+\t  unlock();\n+\n+\tunique_lock(std::move(__u)).swap(*this);\n+\n+\t__u._M_device = 0;\n+\t__u._M_owns = false;\n+\n+\treturn *this;\n+      }\n+\n+      void\n+      lock()\n+      {\n+\tif (!_M_device)\n+\t  __throw_system_error(int(errc::operation_not_permitted));\n+\telse if (_M_owns)\n+\t  __throw_system_error(int(errc::resource_deadlock_would_occur));\n+\telse\n+\t  {\n+\t    _M_device->lock();\n+\t    _M_owns = true;\n+\t  }\n+      }\n+\n+      bool\n+      try_lock()\n+      {\n+\tif (!_M_device)\n+\t  __throw_system_error(int(errc::operation_not_permitted));\n+\telse if (_M_owns)\n+\t  __throw_system_error(int(errc::resource_deadlock_would_occur));\n+\telse\n+\t  {\n+\t    _M_owns = _M_device->try_lock();\n+\t    return _M_owns;\n+\t  }\n+      }\n+\n+#ifdef _GLIBCXX_USE_C99_STDINT_TR1\n+      template<typename _Clock, typename _Duration>\n+\tbool\n+\ttry_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)\n+\t{\n+\t  if (!_M_device)\n+\t    __throw_system_error(int(errc::operation_not_permitted));\n+\t  else if (_M_owns)\n+\t    __throw_system_error(int(errc::resource_deadlock_would_occur));\n+\t  else\n+\t    {\n+\t      _M_owns = _M_device->try_lock_until(__atime);\n+\t      return _M_owns;\n+\t    }\n+\t}\n+\n+      template<typename _Rep, typename _Period>\n+\tbool\n+\ttry_lock_for(const chrono::duration<_Rep, _Period>& __rtime)\n+\t{\n+\t  if (!_M_device)\n+\t    __throw_system_error(int(errc::operation_not_permitted));\n+\t  else if (_M_owns)\n+\t    __throw_system_error(int(errc::resource_deadlock_would_occur));\n+\t  else\n+\t    {\n+\t      _M_owns = _M_device->try_lock_for(__rtime);\n+\t      return _M_owns;\n+\t    }\n+\t }\n+#endif\n+\n+      void\n+      unlock()\n+      {\n+\tif (!_M_owns)\n+\t  __throw_system_error(int(errc::operation_not_permitted));\n+\telse if (_M_device)\n+\t  {\n+\t    _M_device->unlock();\n+\t    _M_owns = false;\n+\t  }\n+      }\n+\n+      void\n+      swap(unique_lock& __u) noexcept\n+      {\n+\tstd::swap(_M_device, __u._M_device);\n+\tstd::swap(_M_owns, __u._M_owns);\n+      }\n+\n+      mutex_type*\n+      release() noexcept\n+      {\n+\tmutex_type* __ret = _M_device;\n+\t_M_device = 0;\n+\t_M_owns = false;\n+\treturn __ret;\n+      }\n+\n+      bool\n+      owns_lock() const noexcept\n+      { return _M_owns; }\n+\n+      explicit operator bool() const noexcept\n+      { return owns_lock(); }\n+\n+      mutex_type*\n+      mutex() const noexcept\n+      { return _M_device; }\n+\n+    private:\n+      mutex_type*\t_M_device;\n+      bool\t\t_M_owns;\n+    };\n+\n+  /// Swap overload for unique_lock objects.\n+  template<typename _Mutex>\n+    inline void\n+    swap(unique_lock<_Mutex>& __x, unique_lock<_Mutex>& __y) noexcept\n+    { __x.swap(__y); }\n+\n+  // @} group mutexes\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace\n+\n+#endif // C++11\n+#endif // _GLIBCXX_UNIQUE_LOCK_H"}, {"sha": "88ab775f771b8fe0427c74a463528ca4fad42b29", "filename": "libstdc++-v3/include/std/condition_variable", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable?ref=1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f", "patch": "@@ -37,6 +37,7 @@\n \n #include <chrono>\n #include <bits/std_mutex.h>\n+#include <bits/unique_lock.h>\n #include <ext/concurrence.h>\n #include <bits/alloc_traits.h>\n #include <bits/allocator.h>"}, {"sha": "9318a8d1a5dabcc06010046e87196a2d62ec40ca", "filename": "libstdc++-v3/include/std/mutex", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex?ref=1fba0606b813ab0925e7fc9ee92c9b57c7c3b94f", "patch": "@@ -41,6 +41,7 @@\n #include <type_traits>\n #include <system_error>\n #include <bits/std_mutex.h>\n+#include <bits/unique_lock.h>\n #if ! _GTHREAD_USE_MUTEX_TIMEDLOCK\n # include <condition_variable>\n # include <thread>"}]}