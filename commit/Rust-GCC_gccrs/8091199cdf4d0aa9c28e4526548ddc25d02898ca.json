{"sha": "8091199cdf4d0aa9c28e4526548ddc25d02898ca", "node_id": "C_kwDOANBUbNoAKDgwOTExOTljZGY0ZDBhYTljMjhlNDUyNjU0OGRkYzI1ZDAyODk4Y2E", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.ibm.com", "date": "2023-02-01T07:59:42Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@linux.ibm.com", "date": "2023-02-01T07:59:42Z"}, "message": "IBM zSystems: Save argument registers to the stack -mpreserve-args\n\nThis adds support for preserving the content of parameter registers to\nthe stack and emit CFI for it. This useful for applications which want\nto implement their own stack unwinding and need access to function\narguments.\n\nWith the -mpreserve-args option GPRs and FPRs are save to the stack\nslots which are reserved for stdargs in the register save area.\n\ngcc/ChangeLog:\n\n\t* config/s390/s390.cc (s390_restore_gpr_p): New function.\n\t(s390_preserve_gpr_arg_in_range_p): New function.\n\t(s390_preserve_gpr_arg_p): New function.\n\t(s390_preserve_fpr_arg_p): New function.\n\t(s390_register_info_stdarg_fpr): Rename to ...\n\t(s390_register_info_arg_fpr): ... this. Add -mpreserve-args handling.\n\t(s390_register_info_stdarg_gpr): Rename to ...\n\t(s390_register_info_arg_gpr): ... this. Add -mpreserve-args handling.\n\t(s390_register_info): Use the renamed functions above.\n\t(s390_optimize_register_info): Likewise.\n\t(save_fpr): Generate CFI for -mpreserve-args.\n\t(save_gprs): Generate CFI for -mpreserve-args. Drop return value.\n\t(s390_emit_prologue): Adjust to changed calling convention of save_gprs.\n\t(s390_optimize_prologue): Likewise.\n\t* config/s390/s390.opt: New option -mpreserve-args\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/s390/preserve-args-1.c: New test.\n\t* gcc.target/s390/preserve-args-2.c: New test.", "tree": {"sha": "b3a7ff9843c9023cf8b4e61abc061472c2fd1cf7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3a7ff9843c9023cf8b4e61abc061472c2fd1cf7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8091199cdf4d0aa9c28e4526548ddc25d02898ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8091199cdf4d0aa9c28e4526548ddc25d02898ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8091199cdf4d0aa9c28e4526548ddc25d02898ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8091199cdf4d0aa9c28e4526548ddc25d02898ca/comments", "author": {"login": "Andreas-Krebbel", "id": 38103320, "node_id": "MDQ6VXNlcjM4MTAzMzIw", "avatar_url": "https://avatars.githubusercontent.com/u/38103320?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Andreas-Krebbel", "html_url": "https://github.com/Andreas-Krebbel", "followers_url": "https://api.github.com/users/Andreas-Krebbel/followers", "following_url": "https://api.github.com/users/Andreas-Krebbel/following{/other_user}", "gists_url": "https://api.github.com/users/Andreas-Krebbel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Andreas-Krebbel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Andreas-Krebbel/subscriptions", "organizations_url": "https://api.github.com/users/Andreas-Krebbel/orgs", "repos_url": "https://api.github.com/users/Andreas-Krebbel/repos", "events_url": "https://api.github.com/users/Andreas-Krebbel/events{/privacy}", "received_events_url": "https://api.github.com/users/Andreas-Krebbel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Andreas-Krebbel", "id": 38103320, "node_id": "MDQ6VXNlcjM4MTAzMzIw", "avatar_url": "https://avatars.githubusercontent.com/u/38103320?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Andreas-Krebbel", "html_url": "https://github.com/Andreas-Krebbel", "followers_url": "https://api.github.com/users/Andreas-Krebbel/followers", "following_url": "https://api.github.com/users/Andreas-Krebbel/following{/other_user}", "gists_url": "https://api.github.com/users/Andreas-Krebbel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Andreas-Krebbel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Andreas-Krebbel/subscriptions", "organizations_url": "https://api.github.com/users/Andreas-Krebbel/orgs", "repos_url": "https://api.github.com/users/Andreas-Krebbel/repos", "events_url": "https://api.github.com/users/Andreas-Krebbel/events{/privacy}", "received_events_url": "https://api.github.com/users/Andreas-Krebbel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36ffb2e0293d1bbef30e3553a431679de00549b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36ffb2e0293d1bbef30e3553a431679de00549b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36ffb2e0293d1bbef30e3553a431679de00549b9"}], "stats": {"total": 313, "additions": 239, "deletions": 74}, "files": [{"sha": "708b48b5ab61e6ce8fee50342bb33ab973ad63b6", "filename": "gcc/config/s390/s390.cc", "status": "modified", "additions": 180, "deletions": 74, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8091199cdf4d0aa9c28e4526548ddc25d02898ca/gcc%2Fconfig%2Fs390%2Fs390.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8091199cdf4d0aa9c28e4526548ddc25d02898ca/gcc%2Fconfig%2Fs390%2Fs390.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.cc?ref=8091199cdf4d0aa9c28e4526548ddc25d02898ca", "patch": "@@ -411,6 +411,45 @@ struct s390_address\n #define FP_ARG_NUM_REG (TARGET_64BIT? 4 : 2)\n #define VEC_ARG_NUM_REG 8\n \n+/* Return TRUE if GPR REGNO is supposed to be restored in the function\n+   epilogue.  */\n+static inline bool\n+s390_restore_gpr_p (int regno)\n+{\n+  return (cfun_frame_layout.first_restore_gpr != -1\n+\t  && regno >= cfun_frame_layout.first_restore_gpr\n+\t  && regno <= cfun_frame_layout.last_restore_gpr);\n+}\n+\n+/* Return TRUE if any of the registers in range [FIRST, LAST] is saved\n+   because of -mpreserve-args.  */\n+static inline bool\n+s390_preserve_gpr_arg_in_range_p (int first, int last)\n+{\n+  int num_arg_regs = MIN (crtl->args.info.gprs + cfun->va_list_gpr_size,\n+\t\t\t  GP_ARG_NUM_REG);\n+  return (num_arg_regs\n+\t  && s390_preserve_args_p\n+\t  && first <= GPR2_REGNUM + num_arg_regs - 1\n+\t  && last >= GPR2_REGNUM);\n+}\n+\n+static inline bool\n+s390_preserve_gpr_arg_p (int regno)\n+{\n+  return s390_preserve_gpr_arg_in_range_p (regno, regno);\n+}\n+\n+static inline bool\n+s390_preserve_fpr_arg_p (int regno)\n+{\n+  int num_arg_regs = MIN (crtl->args.info.fprs + cfun->va_list_fpr_size,\n+\t\t\t  FP_ARG_NUM_REG);\n+  return (s390_preserve_args_p\n+\t  && regno <= FPR0_REGNUM + num_arg_regs - 1\n+\t  && regno >= FPR0_REGNUM);\n+}\n+\n /* A couple of shortcuts.  */\n #define CONST_OK_FOR_J(x) \\\n \tCONST_OK_FOR_CONSTRAINT_P((x), 'J', \"J\")\n@@ -9893,61 +9932,89 @@ s390_register_info_gprtofpr ()\n }\n \n /* Set the bits in fpr_bitmap for FPRs which need to be saved due to\n-   stdarg.\n+   stdarg or -mpreserve-args.\n    This is a helper routine for s390_register_info.  */\n-\n static void\n-s390_register_info_stdarg_fpr ()\n+s390_register_info_arg_fpr ()\n {\n   int i;\n-  int min_fpr;\n-  int max_fpr;\n+  int min_stdarg_fpr = INT_MAX, max_stdarg_fpr = -1;\n+  int min_preserve_fpr = INT_MAX, max_preserve_fpr = -1;\n+  int min_fpr, max_fpr;\n \n   /* Save the FP argument regs for stdarg. f0, f2 for 31 bit and\n      f0-f4 for 64 bit.  */\n-  if (!cfun->stdarg\n-      || !TARGET_HARD_FLOAT\n-      || !cfun->va_list_fpr_size\n-      || crtl->args.info.fprs >= FP_ARG_NUM_REG)\n-    return;\n+  if (cfun->stdarg\n+      && TARGET_HARD_FLOAT\n+      && cfun->va_list_fpr_size\n+      && crtl->args.info.fprs < FP_ARG_NUM_REG)\n+    {\n+      min_stdarg_fpr = crtl->args.info.fprs;\n+      max_stdarg_fpr = min_stdarg_fpr + cfun->va_list_fpr_size - 1;\n+      if (max_stdarg_fpr >= FP_ARG_NUM_REG)\n+\tmax_stdarg_fpr = FP_ARG_NUM_REG - 1;\n+\n+      /* FPR argument regs start at f0.  */\n+      min_stdarg_fpr += FPR0_REGNUM;\n+      max_stdarg_fpr += FPR0_REGNUM;\n+    }\n \n-  min_fpr = crtl->args.info.fprs;\n-  max_fpr = min_fpr + cfun->va_list_fpr_size - 1;\n-  if (max_fpr >= FP_ARG_NUM_REG)\n-    max_fpr = FP_ARG_NUM_REG - 1;\n+  if (s390_preserve_args_p && crtl->args.info.fprs)\n+    {\n+      min_preserve_fpr = FPR0_REGNUM;\n+      max_preserve_fpr = MIN (FPR0_REGNUM + FP_ARG_NUM_REG - 1,\n+\t\t\t      FPR0_REGNUM + crtl->args.info.fprs - 1);\n+    }\n \n-  /* FPR argument regs start at f0.  */\n-  min_fpr += FPR0_REGNUM;\n-  max_fpr += FPR0_REGNUM;\n+  min_fpr = MIN (min_stdarg_fpr, min_preserve_fpr);\n+  max_fpr = MAX (max_stdarg_fpr, max_preserve_fpr);\n+\n+  if (max_fpr == -1)\n+    return;\n \n   for (i = min_fpr; i <= max_fpr; i++)\n     cfun_set_fpr_save (i);\n }\n \n+\n /* Reserve the GPR save slots for GPRs which need to be saved due to\n-   stdarg.\n+   stdarg or -mpreserve-args.\n    This is a helper routine for s390_register_info.  */\n \n static void\n-s390_register_info_stdarg_gpr ()\n+s390_register_info_arg_gpr ()\n {\n   int i;\n-  int min_gpr;\n-  int max_gpr;\n+  int min_stdarg_gpr = INT_MAX, max_stdarg_gpr = -1;\n+  int min_preserve_gpr = INT_MAX, max_preserve_gpr = -1;\n+  int min_gpr, max_gpr;\n \n-  if (!cfun->stdarg\n-      || !cfun->va_list_gpr_size\n-      || crtl->args.info.gprs >= GP_ARG_NUM_REG)\n-    return;\n+  if (cfun->stdarg\n+      && cfun->va_list_gpr_size\n+      && crtl->args.info.gprs < GP_ARG_NUM_REG)\n+    {\n+      min_stdarg_gpr = crtl->args.info.gprs;\n+      max_stdarg_gpr = min_stdarg_gpr + cfun->va_list_gpr_size - 1;\n+      if (max_stdarg_gpr >= GP_ARG_NUM_REG)\n+\tmax_stdarg_gpr = GP_ARG_NUM_REG - 1;\n+\n+      /* GPR argument regs start at r2.  */\n+      min_stdarg_gpr += GPR2_REGNUM;\n+      max_stdarg_gpr += GPR2_REGNUM;\n+    }\n+\n+  if (s390_preserve_args_p && crtl->args.info.gprs)\n+    {\n+      min_preserve_gpr = GPR2_REGNUM;\n+      max_preserve_gpr = MIN (GPR6_REGNUM,\n+\t\t\t      GPR2_REGNUM + crtl->args.info.gprs - 1);\n+    }\n \n-  min_gpr = crtl->args.info.gprs;\n-  max_gpr = min_gpr + cfun->va_list_gpr_size - 1;\n-  if (max_gpr >= GP_ARG_NUM_REG)\n-    max_gpr = GP_ARG_NUM_REG - 1;\n+  min_gpr = MIN (min_stdarg_gpr, min_preserve_gpr);\n+  max_gpr = MAX (max_stdarg_gpr, max_preserve_gpr);\n \n-  /* GPR argument regs start at r2.  */\n-  min_gpr += GPR2_REGNUM;\n-  max_gpr += GPR2_REGNUM;\n+  if (max_gpr == -1)\n+    return;\n \n   /* If r6 was supposed to be saved into an FPR and now needs to go to\n      the stack for vararg we have to adjust the restore range to make\n@@ -10079,14 +10146,14 @@ s390_register_info ()\n     if (clobbered_regs[i] && !call_used_regs[i])\n       cfun_gpr_save_slot (i) = SAVE_SLOT_STACK;\n \n-  s390_register_info_stdarg_fpr ();\n+  s390_register_info_arg_fpr ();\n   s390_register_info_gprtofpr ();\n   s390_register_info_set_ranges ();\n-  /* stdarg functions might need to save GPRs 2 to 6.  This might\n-     override the GPR->FPR save decision made by\n-     s390_register_info_gprtofpr for r6 since vararg regs must go to\n-     the stack.  */\n-  s390_register_info_stdarg_gpr ();\n+\n+  /* Forcing argument registers to be saved on the stack might\n+     override the GPR->FPR save decision for r6 so this must come\n+     last.  */\n+  s390_register_info_arg_gpr ();\n }\n \n /* Return true if REGNO is a global register, but not one\n@@ -10141,7 +10208,7 @@ s390_optimize_register_info ()\n       cfun_gpr_save_slot (i) = SAVE_SLOT_NONE;\n \n   s390_register_info_set_ranges ();\n-  s390_register_info_stdarg_gpr ();\n+  s390_register_info_arg_gpr ();\n }\n \n /* Fill cfun->machine with info about frame of current function.  */\n@@ -10864,14 +10931,28 @@ static rtx\n save_fpr (rtx base, int offset, int regnum)\n {\n   rtx addr;\n+  rtx insn;\n+\n   addr = gen_rtx_MEM (DFmode, plus_constant (Pmode, base, offset));\n \n-  if (regnum >= 16 && regnum <= (16 + FP_ARG_NUM_REG))\n+  if (regnum >= FPR0_REGNUM && regnum <= (FPR0_REGNUM + FP_ARG_NUM_REG))\n     set_mem_alias_set (addr, get_varargs_alias_set ());\n   else\n     set_mem_alias_set (addr, get_frame_alias_set ());\n \n-  return emit_move_insn (addr, gen_rtx_REG (DFmode, regnum));\n+  insn = emit_move_insn (addr, gen_rtx_REG (DFmode, regnum));\n+\n+  if (!call_used_regs[regnum] || s390_preserve_fpr_arg_p (regnum))\n+    RTX_FRAME_RELATED_P (insn) = 1;\n+\n+  if (s390_preserve_fpr_arg_p (regnum) && !cfun_fpr_save_p (regnum))\n+    {\n+      rtx reg = gen_rtx_REG (DFmode, regnum);\n+      add_reg_note (insn, REG_CFA_NO_RESTORE, reg);\n+      add_reg_note (insn, REG_CFA_OFFSET, gen_rtx_SET (addr, reg));\n+    }\n+\n+  return insn;\n }\n \n /* Emit insn to restore fpr REGNUM from offset OFFSET relative\n@@ -10891,10 +10972,11 @@ restore_fpr (rtx base, int offset, int regnum)\n    the register save area located at offset OFFSET\n    relative to register BASE.  */\n \n-static rtx\n-save_gprs (rtx base, int offset, int first, int last)\n+static void\n+save_gprs (rtx base, int offset, int first, int last, rtx_insn *before = NULL)\n {\n   rtx addr, insn, note;\n+  rtx_insn *out_insn;\n   int i;\n \n   addr = plus_constant (Pmode, base, offset);\n@@ -10910,7 +10992,15 @@ save_gprs (rtx base, int offset, int first, int last)\n \n       if (!global_not_special_regno_p (first))\n \tRTX_FRAME_RELATED_P (insn) = 1;\n-      return insn;\n+\n+      if (s390_preserve_gpr_arg_p (first) && !s390_restore_gpr_p (first))\n+\t{\n+\t  rtx reg = gen_rtx_REG (Pmode, first);\n+\t  add_reg_note (insn, REG_CFA_NO_RESTORE, reg);\n+\t  add_reg_note (insn, REG_CFA_OFFSET, gen_rtx_SET (addr, reg));\n+\t}\n+\n+      goto emit;\n     }\n \n \n@@ -10939,7 +11029,12 @@ save_gprs (rtx base, int offset, int first, int last)\n      set, even if it does not.  Therefore we emit a new pattern\n      without those registers as REG_FRAME_RELATED_EXPR note.  */\n \n-  if (first >= 6 && !global_not_special_regno_p (first))\n+  /* In these cases all of the sets are marked as frame related:\n+     1. call-save GPR saved and restored\n+     2. argument GPR saved because of -mpreserve-args */\n+  if ((first >= GPR6_REGNUM && !global_not_special_regno_p (first))\n+      || s390_preserve_gpr_arg_in_range_p (first, last))\n+\n     {\n       rtx pat = PATTERN (insn);\n \n@@ -10950,6 +11045,24 @@ save_gprs (rtx base, int offset, int first, int last)\n \t  RTX_FRAME_RELATED_P (XVECEXP (pat, 0, i)) = 1;\n \n       RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      /* For the -mpreserve-args register saves no restore operations\n+\t will be emitted. CFI checking would complain about this. We\n+\t manually generate the REG_CFA notes here to be able to mark\n+\t those operations with REG_CFA_NO_RESTORE.  */\n+      if (s390_preserve_gpr_arg_in_range_p (first, last))\n+\t{\n+\t  for (int regno = first; regno <= last; regno++)\n+\t    {\n+\t      rtx reg = gen_rtx_REG (Pmode, regno);\n+\t      rtx reg_addr = plus_constant (Pmode, base,\n+\t\t\t\t\t    offset + (regno - first) * UNITS_PER_LONG);\n+\t      if (!s390_restore_gpr_p (regno))\n+\t\tadd_reg_note (insn, REG_CFA_NO_RESTORE, reg);\n+\t      add_reg_note (insn, REG_CFA_OFFSET,\n+\t\t\t    gen_rtx_SET (gen_frame_mem (Pmode, reg_addr), reg));\n+\t    }\n+\t}\n     }\n   else if (last >= 6)\n     {\n@@ -10960,7 +11073,7 @@ save_gprs (rtx base, int offset, int first, int last)\n \t  break;\n \n       if (start > last)\n-\treturn insn;\n+\tgoto emit;\n \n       addr = plus_constant (Pmode, base,\n \t\t\t    offset + (start - first) * UNITS_PER_LONG);\n@@ -10978,7 +11091,7 @@ save_gprs (rtx base, int offset, int first, int last)\n \t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, note);\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \n-\t  return insn;\n+\t  goto emit;\n \t}\n \n       note = gen_store_multiple (gen_rtx_MEM (Pmode, addr),\n@@ -10997,9 +11110,15 @@ save_gprs (rtx base, int offset, int first, int last)\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n-  return insn;\n+ emit:\n+  if (before != NULL_RTX)\n+    out_insn = emit_insn_before (insn, before);\n+  else\n+    out_insn = emit_insn (insn);\n+  INSN_ADDRESSES_NEW (out_insn, -1);\n }\n \n+\n /* Generate insn to restore registers FIRST to LAST from\n    the register save area located at offset OFFSET\n    relative to register BASE.  */\n@@ -11423,21 +11542,19 @@ s390_emit_prologue (void)\n   /* Save call saved gprs.  */\n   if (cfun_frame_layout.first_save_gpr != -1)\n     {\n-      insn = save_gprs (stack_pointer_rtx,\n-\t\t\tcfun_frame_layout.gprs_offset +\n-\t\t\tUNITS_PER_LONG * (cfun_frame_layout.first_save_gpr\n-\t\t\t\t\t  - cfun_frame_layout.first_save_gpr_slot),\n-\t\t\tcfun_frame_layout.first_save_gpr,\n-\t\t\tcfun_frame_layout.last_save_gpr);\n+      save_gprs (stack_pointer_rtx,\n+\t\t cfun_frame_layout.gprs_offset +\n+\t\t UNITS_PER_LONG * (cfun_frame_layout.first_save_gpr\n+\t\t\t\t   - cfun_frame_layout.first_save_gpr_slot),\n+\t\t cfun_frame_layout.first_save_gpr,\n+\t\t cfun_frame_layout.last_save_gpr);\n \n       /* This is not 100% correct.  If we have more than one register saved,\n \t then LAST_PROBE_OFFSET can move even closer to sp.  */\n       last_probe_offset\n \t= (cfun_frame_layout.gprs_offset +\n \t   UNITS_PER_LONG * (cfun_frame_layout.first_save_gpr\n \t\t\t     - cfun_frame_layout.first_save_gpr_slot));\n-\n-      emit_insn (insn);\n     }\n \n   /* Dummy insn to mark literal pool slot.  */\n@@ -11467,15 +11584,10 @@ s390_emit_prologue (void)\n     {\n       if (cfun_fpr_save_p (i))\n \t{\n-\t  insn = save_fpr (stack_pointer_rtx, offset, i);\n+\t  save_fpr (stack_pointer_rtx, offset, i);\n \t  if (offset < last_probe_offset)\n \t    last_probe_offset = offset;\n \t  offset += 8;\n-\n-\t  /* If f4 and f6 are call clobbered they are saved due to\n-\t     stdargs and therefore are not frame related.  */\n-\t  if (!call_used_regs[i])\n-\t    RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n       else if (!TARGET_PACKED_STACK || call_used_regs[i])\n \toffset += 8;\n@@ -11491,11 +11603,10 @@ s390_emit_prologue (void)\n       for (i = FPR15_REGNUM; i >= FPR8_REGNUM && offset >= 0; i--)\n \tif (cfun_fpr_save_p (i))\n \t  {\n-\t    insn = save_fpr (stack_pointer_rtx, offset, i);\n+\t    save_fpr (stack_pointer_rtx, offset, i);\n \t    if (offset < last_probe_offset)\n \t      last_probe_offset = offset;\n \n-\t    RTX_FRAME_RELATED_P (insn) = 1;\n \t    offset -= 8;\n \t  }\n       if (offset >= cfun_frame_layout.f8_offset)\n@@ -11663,7 +11774,6 @@ s390_emit_prologue (void)\n \n \t    insn = save_fpr (temp_reg, offset, i);\n \t    offset += 8;\n-\t    RTX_FRAME_RELATED_P (insn) = 1;\n \t    add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n \t\t\t  gen_rtx_SET (gen_rtx_MEM (DFmode, addr),\n \t\t\t\t       gen_rtx_REG (DFmode, i)));\n@@ -14158,15 +14268,11 @@ s390_optimize_prologue (void)\n \t    continue;\n \n \t  if (cfun_frame_layout.first_save_gpr != -1)\n-\t    {\n-\t      rtx s_pat = save_gprs (base,\n-\t\t\t\t     off + (cfun_frame_layout.first_save_gpr\n-\t\t\t\t\t    - first) * UNITS_PER_LONG,\n-\t\t\t\t     cfun_frame_layout.first_save_gpr,\n-\t\t\t\t     cfun_frame_layout.last_save_gpr);\n-\t      new_insn = emit_insn_before (s_pat, insn);\n-\t      INSN_ADDRESSES_NEW (new_insn, -1);\n-\t    }\n+\t    save_gprs (base,\n+\t\t       off + (cfun_frame_layout.first_save_gpr\n+\t\t\t      - first) * UNITS_PER_LONG,\n+\t\t       cfun_frame_layout.first_save_gpr,\n+\t\t       cfun_frame_layout.last_save_gpr, insn);\n \n \t  remove_insn (insn);\n \t  continue;"}, {"sha": "344aa551f442e7bf4741a09e78651a431b8f247d", "filename": "gcc/config/s390/s390.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8091199cdf4d0aa9c28e4526548ddc25d02898ca/gcc%2Fconfig%2Fs390%2Fs390.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8091199cdf4d0aa9c28e4526548ddc25d02898ca/gcc%2Fconfig%2Fs390%2Fs390.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.opt?ref=8091199cdf4d0aa9c28e4526548ddc25d02898ca", "patch": "@@ -325,3 +325,7 @@ purposes.\n munroll-only-small-loops\n Target Undocumented Var(unroll_only_small_loops) Init(0) Save\n ; Use conservative small loop unrolling.\n+\n+mpreserve-args\n+Target Var(s390_preserve_args_p) Init(0)\n+Store all argument registers on the stack."}, {"sha": "24dcf547432abba3cbd34a2e6341bdd584f035c0", "filename": "gcc/testsuite/gcc.target/s390/preserve-args-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8091199cdf4d0aa9c28e4526548ddc25d02898ca/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fpreserve-args-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8091199cdf4d0aa9c28e4526548ddc25d02898ca/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fpreserve-args-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fpreserve-args-1.c?ref=8091199cdf4d0aa9c28e4526548ddc25d02898ca", "patch": "@@ -0,0 +1,17 @@\n+/* Functional tests for the -mpreserve-args cmdline option.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -march=z900 -mpreserve-args\" } */\n+\n+\n+int\n+foo (int a, int b, int c, double d, double e)\n+{\n+  return a + c + (int)d + (int)e;\n+}\n+\n+/* { dg-final { scan-assembler \"stmg\\t%r2,%r4,\\[0-9\\]*\\\\(%r15\\\\)\" { target lp64 } } } */\n+/* { dg-final { scan-assembler \"stm\\t%r2,%r4,\\[0-9\\]*\\\\(%r15\\\\)\" { target { ! lp64 } } } } */\n+\n+/* { dg-final { scan-assembler \"std\\t%f0,\\[0-9\\]*\\\\(%r15\\\\)\" } } */\n+/* { dg-final { scan-assembler \"std\\t%f2,\\[0-9\\]*\\\\(%r15\\\\)\" } } */"}, {"sha": "006aad9c3716257b0a6398435ca60c3cda0f799e", "filename": "gcc/testsuite/gcc.target/s390/preserve-args-2.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8091199cdf4d0aa9c28e4526548ddc25d02898ca/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fpreserve-args-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8091199cdf4d0aa9c28e4526548ddc25d02898ca/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fpreserve-args-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fpreserve-args-2.c?ref=8091199cdf4d0aa9c28e4526548ddc25d02898ca", "patch": "@@ -0,0 +1,19 @@\n+/* This test requires special handling of a GPR which is saved because\n+   of -mpreserve-args but not restored.  dwarf2cfi used to ICE for\n+   this in maybe_record_trace_start.  The solution was to introduce a\n+   REG_CFA_NORESTORE reg note.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=z900 -mpreserve-args\" } */\n+\n+void *foo (void *);\n+void bar ();\n+int x;\n+void *\n+baz (void *y)\n+{\n+  if (__builtin_expect (x, 0))\n+    return foo (y);\n+  bar ();\n+  return foo (y);\n+}"}, {"sha": "f4b135ab8e66c04272d602ffec1bcd64eae35f47", "filename": "gcc/testsuite/gcc.target/s390/preserve-args-3.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8091199cdf4d0aa9c28e4526548ddc25d02898ca/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fpreserve-args-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8091199cdf4d0aa9c28e4526548ddc25d02898ca/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fpreserve-args-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fpreserve-args-3.c?ref=8091199cdf4d0aa9c28e4526548ddc25d02898ca", "patch": "@@ -0,0 +1,19 @@\n+/* Functional tests for the -mpreserve-args cmdline option.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -march=z900 -mpreserve-args\" } */\n+\n+#include <stdarg.h>\n+int\n+foo (int a, int, int c, double d, ...)\n+{\n+  va_list argp;\n+  va_start(argp, d);\n+  return a + c + va_arg(argp, int) + va_arg(argp, int) + (int)va_arg(argp, double);\n+}\n+\n+/* { dg-final { scan-assembler \"stmg\\t%r2,%r15,\\[0-9\\]*\\\\(%r15\\\\)\" { target lp64 } } } */\n+/* { dg-final { scan-assembler \"stm\\t%r2,%r15,\\[0-9\\]*\\\\(%r15\\\\)\" { target { ! lp64 } } } } */\n+\n+/* { dg-final { scan-assembler \"std\\t%f0,\\[0-9\\]*\\\\(%r15\\\\)\" } } */\n+/* { dg-final { scan-assembler \"std\\t%f2,\\[0-9\\]*\\\\(%r15\\\\)\" } } */"}]}