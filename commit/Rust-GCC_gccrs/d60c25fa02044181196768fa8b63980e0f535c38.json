{"sha": "d60c25fa02044181196768fa8b63980e0f535c38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDYwYzI1ZmEwMjA0NDE4MTE5Njc2OGZhOGI2Mzk4MGUwZjUzNWMzOA==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-02-03T19:15:31Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-02-03T19:48:23Z"}, "message": "coroutines: Fix ICE on invalid (PR93458).\n\nSince coroutine-ness is discovered lazily, we encounter the diagnostics\nduring each keyword parse.  We were not handling the case where a user code\nfailed to include fundamental information (e.g. the traits) in a graceful\nmanner.\n\nOnce we've emitted an error for this level of fail, then we suppress\nadditional copies (otherwise the same thing will be reported for every\ncoroutine keyword seen).\n\ngcc/cp/ChangeLog:\n\n2020-02-03  Iain Sandoe  <iain@sandoe.co.uk>\n\n\t* coroutines.cc (struct coroutine_info): Add a bool flag to note\n\tthat we emitted an error for a bad function return type.\n\t(get_coroutine_info): Tolerate an unset info table in case of\n\tmissing traits.\n\t(find_coro_traits_template_decl): In case of error or if we didn't\n\tfind a type template, note we emitted the error and suppress\n\tduplicates.\n\t(find_coro_handle_template_decl): Likewise.\n\t(instantiate_coro_traits): Only check for error_mark_node in the\n\treturn from lookup_qualified_name.\n\t(coro_promise_type_found_p): Reorder initialization so that we check\n\tfor the traits and their usability before allocation of the info\n\ttable.  Check for a suitable return type and emit a diagnostic for\n\there instead of relying on the lookup machinery.  This allows the\n\terror to have a better location, and means we can suppress multiple\n\tcopies.\n\t(coro_function_valid_p): Re-check for a valid promise (and thus the\n\ttraits) before proceeding.  Tolerate missing info as a fatal error.\n\ngcc/testsuite/ChangeLog:\n\n2020-02-03  Iain Sandoe  <iain@sandoe.co.uk>\n\n\t* g++.dg/coroutines/pr93458-1-missing-traits.C: New test.\n\t* g++.dg/coroutines/pr93458-2-bad-traits.C: New test.\n\t* g++.dg/coroutines/pr93458-3-missing-handle.C: New test.\n\t* g++.dg/coroutines/pr93458-4-bad-coro-handle.C: New test.\n\t* g++.dg/coroutines/pr93458-5-bad-coro-type.C: New test.", "tree": {"sha": "769bfa056316fcdfb207877504778d435dbe30a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/769bfa056316fcdfb207877504778d435dbe30a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d60c25fa02044181196768fa8b63980e0f535c38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d60c25fa02044181196768fa8b63980e0f535c38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d60c25fa02044181196768fa8b63980e0f535c38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d60c25fa02044181196768fa8b63980e0f535c38/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "833f1e66e3a8efdbb941a44ac9e74101d771e0d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/833f1e66e3a8efdbb941a44ac9e74101d771e0d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/833f1e66e3a8efdbb941a44ac9e74101d771e0d5"}], "stats": {"total": 210, "additions": 184, "deletions": 26}, "files": [{"sha": "2429b1f164282171153bcb4cf4b0927b1f41a768", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60c25fa02044181196768fa8b63980e0f535c38/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60c25fa02044181196768fa8b63980e0f535c38/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d60c25fa02044181196768fa8b63980e0f535c38", "patch": "@@ -1,3 +1,25 @@\n+2020-02-03  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR c++/93458\n+\t* coroutines.cc (struct coroutine_info): Add a bool flag to note\n+\tthat we emitted an error for a bad function return type.\n+\t(get_coroutine_info): Tolerate an unset info table in case of\n+\tmissing traits.\n+\t(find_coro_traits_template_decl): In case of error or if we didn't\n+\tfind a type template, note we emitted the error and suppress\n+\tduplicates.\n+\t(find_coro_handle_template_decl): Likewise.\n+\t(instantiate_coro_traits): Only check for error_mark_node in the\n+\treturn from lookup_qualified_name. \n+\t(coro_promise_type_found_p): Reorder initialization so that we check\n+\tfor the traits and their usability before allocation of the info\n+\ttable.  Check for a suitable return type and emit a diagnostic for\n+\there instead of relying on the lookup machinery.  This allows the\n+\terror to have a better location, and means we can suppress multiple\n+\tcopies.\n+\t(coro_function_valid_p): Re-check for a valid promise (and thus the\n+\ttraits) before proceeding.  Tolerate missing info as a fatal error.\n+\n 2020-02-03  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/88256"}, {"sha": "8a0ce384425d08c51eba1da583ea248f0d36d3dd", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 77, "deletions": 26, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60c25fa02044181196768fa8b63980e0f535c38/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60c25fa02044181196768fa8b63980e0f535c38/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=d60c25fa02044181196768fa8b63980e0f535c38", "patch": "@@ -91,6 +91,8 @@ struct GTY((for_user)) coroutine_info\n   tree promise_proxy; /* Likewise, a proxy promise instance.  */\n   location_t first_coro_keyword; /* The location of the keyword that made this\n \t\t\t\t    function into a coroutine.  */\n+  /* Flags to avoid repeated errors for per-function issues.  */\n+  bool coro_ret_type_error_emitted;\n };\n \n struct coroutine_info_hasher : ggc_ptr_hash<coroutine_info>\n@@ -169,7 +171,8 @@ get_or_insert_coroutine_info (tree fn_decl)\n coroutine_info *\n get_coroutine_info (tree fn_decl)\n {\n-  gcc_checking_assert (coroutine_info_table != NULL);\n+  if (coroutine_info_table == NULL)\n+    return NULL;\n \n   coroutine_info **slot = coroutine_info_table->find_slot_with_hash\n     (fn_decl, coroutine_info_hasher::hash (fn_decl), NO_INSERT);\n@@ -255,11 +258,25 @@ static GTY(()) tree void_coro_handle_type;\n static tree\n find_coro_traits_template_decl (location_t kw)\n {\n+  /* If we are missing fundmental information, such as the traits, (or the\n+     declaration found is not a type template), then don't emit an error for\n+     every keyword in a TU, just do it once.  */\n+  static bool traits_error_emitted = false;\n+\n   tree traits_decl = lookup_qualified_name (std_node, coro_traits_identifier,\n-\t\t\t\t\t    0, true);\n-  if (traits_decl == NULL_TREE || traits_decl == error_mark_node)\n+\t\t\t\t\t    0,\n+\t\t\t\t\t    /*complain=*/!traits_error_emitted);\n+  if (traits_decl == error_mark_node\n+      || !DECL_TYPE_TEMPLATE_P (traits_decl))\n     {\n-      error_at (kw, \"cannot find %<coroutine traits%> template\");\n+      if (!traits_error_emitted)\n+\t{\n+\t  gcc_rich_location richloc (kw);\n+\t  error_at (&richloc, \"coroutines require a traits template; cannot\"\n+\t\t    \" find %<%E::%E%>\", std_node, coro_traits_identifier);\n+\t  inform (&richloc, \"perhaps %<#include <coroutine>%> is missing\");\n+\t  traits_error_emitted = true;\n+\t}\n       return NULL_TREE;\n     }\n   else\n@@ -299,7 +316,7 @@ instantiate_coro_traits (tree fndecl, location_t kw)\n \t\t\t     /*in_decl=*/NULL_TREE, /*context=*/NULL_TREE,\n \t\t\t     /*entering scope=*/false, tf_warning_or_error);\n \n-  if (traits_class == error_mark_node || traits_class == NULL_TREE)\n+  if (traits_class == error_mark_node)\n     {\n       error_at (kw, \"cannot instantiate %<coroutine traits%>\");\n       return NULL_TREE;\n@@ -313,11 +330,18 @@ instantiate_coro_traits (tree fndecl, location_t kw)\n static tree\n find_coro_handle_template_decl (location_t kw)\n {\n+  /* As for the coroutine traits, this error is per TU, so only emit\n+    it once.  */\n+  static bool coro_handle_error_emitted = false;\n   tree handle_decl = lookup_qualified_name (std_node, coro_handle_identifier,\n-\t\t\t\t\t    0, true);\n-  if (handle_decl == NULL_TREE || handle_decl == error_mark_node)\n-    {\n-      error_at (kw, \"cannot find %<coroutine handle%> template\");\n+\t\t\t\t\t    0, !coro_handle_error_emitted);\n+  if (handle_decl == error_mark_node\n+      || !DECL_CLASS_TEMPLATE_P (handle_decl))\n+    {\n+      if (!coro_handle_error_emitted)\n+\terror_at (kw, \"coroutines require a handle class template;\"\n+\t\t  \" cannot find %<%E::%E%>\", std_node, coro_handle_identifier);\n+      coro_handle_error_emitted = true;\n       return NULL_TREE;\n     }\n   else\n@@ -370,34 +394,42 @@ coro_promise_type_found_p (tree fndecl, location_t loc)\n {\n   gcc_assert (fndecl != NULL_TREE);\n \n-  /* Save the coroutine data on the side to avoid the overhead on every\n-     function decl.  */\n-\n-  /* We only need one entry per coroutine in a TU, the assumption here is that\n-     there are typically not 1000s.  */\n   if (!coro_initialized)\n     {\n-      gcc_checking_assert (coroutine_info_table == NULL);\n-      /* A table to hold the state, per coroutine decl.  */\n-      coroutine_info_table =\n-\thash_table<coroutine_info_hasher>::create_ggc (11);\n-      /* Set up the identifiers we will use.  */\n-      gcc_checking_assert (coro_traits_identifier == NULL);\n+      /* Trees we only need to create once.\n+\t Set up the identifiers we will use.  */\n       coro_init_identifiers ();\n-      /* Trees we only need to create once.  */\n+\n       /* Coroutine traits template.  */\n       coro_traits_templ = find_coro_traits_template_decl (loc);\n-      gcc_checking_assert (coro_traits_templ != NULL);\n+      if (coro_traits_templ == NULL_TREE)\n+\treturn false;\n+\n       /*  coroutine_handle<> template.  */\n       coro_handle_templ = find_coro_handle_template_decl (loc);\n-      gcc_checking_assert (coro_handle_templ != NULL);\n+      if (coro_handle_templ == NULL_TREE)\n+\treturn false;\n+\n       /*  We can also instantiate the void coroutine_handle<>  */\n       void_coro_handle_type =\n \tinstantiate_coro_handle_for_promise_type (loc, NULL_TREE);\n-      gcc_checking_assert (void_coro_handle_type != NULL);\n+      if (void_coro_handle_type == NULL_TREE)\n+\treturn false;\n+\n+      /* A table to hold the state, per coroutine decl.  */\n+      gcc_checking_assert (coroutine_info_table == NULL);\n+      coroutine_info_table =\n+\thash_table<coroutine_info_hasher>::create_ggc (11);\n+\n+      if (coroutine_info_table == NULL)\n+\treturn false;\n+\n       coro_initialized = true;\n     }\n \n+  /* Save the coroutine data on the side to avoid the overhead on every\n+     function decl tree.  */\n+\n   coroutine_info *coro_info = get_or_insert_coroutine_info (fndecl);\n   /* Without this, we cannot really proceed.  */\n   gcc_checking_assert (coro_info);\n@@ -407,6 +439,19 @@ coro_promise_type_found_p (tree fndecl, location_t loc)\n     {\n       /* Get the coroutine traits template class instance for the function\n \t signature we have - coroutine_traits <R, ...>  */\n+      tree return_type = TREE_TYPE (TREE_TYPE (fndecl));\n+      if (!CLASS_TYPE_P (return_type))\n+\t{\n+\t  /* It makes more sense to show the function header for this, even\n+\t     though we will have encountered it when processing a keyword.\n+\t     Only emit the error once, not for every keyword we encounter.  */\n+\t  if (!coro_info->coro_ret_type_error_emitted)\n+\t    error_at (DECL_SOURCE_LOCATION (fndecl), \"coroutine return type\"\n+\t\t      \" %qT is not a class\", return_type);\n+\t  coro_info->coro_ret_type_error_emitted = true;\n+\t  return false;\n+\t}\n+\n       tree templ_class = instantiate_coro_traits (fndecl, loc);\n \n       /* Find the promise type for that.  */\n@@ -597,11 +642,17 @@ coro_function_valid_p (tree fndecl)\n {\n   location_t f_loc = DECL_SOURCE_LOCATION (fndecl);\n \n+  /* For cases where fundamental information cannot be found, e.g. the\n+     coroutine traits are missing, we need to punt early.  */\n+  if (!coro_promise_type_found_p (fndecl, f_loc))\n+    return false;\n+\n   /* Since we think the function is a coroutine, that implies we parsed\n      a keyword that triggered this.  Keywords check promise validity for\n      their context and thus the promise type should be known at this point.  */\n-  gcc_checking_assert (get_coroutine_handle_type (fndecl) != NULL_TREE\n-\t\t       && get_coroutine_promise_type (fndecl) != NULL_TREE);\n+  if (get_coroutine_handle_type (fndecl) == NULL_TREE\n+      || get_coroutine_promise_type (fndecl) == NULL_TREE)\n+    return false;\n \n   if (current_function_returns_value || current_function_returns_null)\n     {"}, {"sha": "28ecbe1472ebbd90a4d36b2c3e4c8e031a2ccc10", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60c25fa02044181196768fa8b63980e0f535c38/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60c25fa02044181196768fa8b63980e0f535c38/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d60c25fa02044181196768fa8b63980e0f535c38", "patch": "@@ -1,3 +1,12 @@\n+2020-02-03  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR c++/93458\n+\t* g++.dg/coroutines/pr93458-1-missing-traits.C: New test.\n+\t* g++.dg/coroutines/pr93458-2-bad-traits.C: New test.\n+\t* g++.dg/coroutines/pr93458-3-missing-handle.C: New test.\n+\t* g++.dg/coroutines/pr93458-4-bad-coro-handle.C: New test.\n+\t* g++.dg/coroutines/pr93458-5-bad-coro-type.C: New test.\n+\n 2020-02-03  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR analyzer/93544"}, {"sha": "638a10606f3d26601bba363aa294ca107063db91", "filename": "gcc/testsuite/g++.dg/coroutines/pr93458-1-missing-traits.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60c25fa02044181196768fa8b63980e0f535c38/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr93458-1-missing-traits.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60c25fa02044181196768fa8b63980e0f535c38/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr93458-1-missing-traits.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr93458-1-missing-traits.C?ref=d60c25fa02044181196768fa8b63980e0f535c38", "patch": "@@ -0,0 +1,10 @@\n+//  { dg-additional-options \"-fsyntax-only -fexceptions -w\" }\n+\n+// Diagose missing traits (e.g. fail to include <coroutine>).\n+\n+int\n+bad_coroutine (void)\n+{\n+  co_yield 5; // { dg-error {coroutines require a traits template; cannot find 'std::coroutine_traits'} }\n+  co_return;\n+}"}, {"sha": "0466af8e15a37cc6aae1ab219a02fe3b65a77d1c", "filename": "gcc/testsuite/g++.dg/coroutines/pr93458-2-bad-traits.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60c25fa02044181196768fa8b63980e0f535c38/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr93458-2-bad-traits.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60c25fa02044181196768fa8b63980e0f535c38/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr93458-2-bad-traits.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr93458-2-bad-traits.C?ref=d60c25fa02044181196768fa8b63980e0f535c38", "patch": "@@ -0,0 +1,16 @@\n+//  { dg-additional-options \"-fsyntax-only -fexceptions -w\" }\n+\n+// Diagose bad traits traits : fake something faulty.\n+\n+namespace std {\n+  // name is present, but not a template.\n+  struct coroutine_traits {\n+  };\n+}\n+\n+int\n+bad_coroutine (void)\n+{\n+  co_yield 5; // { dg-error {coroutines require a traits template; cannot find 'std::coroutine_traits'} }\n+  co_return;\n+}"}, {"sha": "766f740fcbde4c625a6253ff24fcb99b4cb09cc9", "filename": "gcc/testsuite/g++.dg/coroutines/pr93458-3-missing-handle.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60c25fa02044181196768fa8b63980e0f535c38/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr93458-3-missing-handle.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60c25fa02044181196768fa8b63980e0f535c38/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr93458-3-missing-handle.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr93458-3-missing-handle.C?ref=d60c25fa02044181196768fa8b63980e0f535c38", "patch": "@@ -0,0 +1,17 @@\n+//  { dg-additional-options \"-fsyntax-only -fexceptions -w\" }\n+\n+// Diagose missing coroutine handle class template.\n+\n+namespace std {\n+  //  coroutine traits\n+  template<typename _R, typename...> struct coroutine_traits {\n+    using promise_type = typename _R::promise_type;\n+  };\n+}\n+\n+int\n+bad_coroutine (void)\n+{\n+  co_yield 5; // { dg-error {coroutines require a handle class template; cannot find 'std::coroutine_handle'} }\n+  co_return;\n+}"}, {"sha": "5d212ace8d4593633dc4358caa9805e00fe040b5", "filename": "gcc/testsuite/g++.dg/coroutines/pr93458-4-bad-coro-handle.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60c25fa02044181196768fa8b63980e0f535c38/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr93458-4-bad-coro-handle.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60c25fa02044181196768fa8b63980e0f535c38/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr93458-4-bad-coro-handle.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr93458-4-bad-coro-handle.C?ref=d60c25fa02044181196768fa8b63980e0f535c38", "patch": "@@ -0,0 +1,21 @@\n+//  { dg-additional-options \"-fsyntax-only -fexceptions -w\" }\n+\n+// Diagose missing coroutine handle class template.\n+\n+namespace std {\n+  //  coroutine traits\n+  template<typename _R, typename...> struct coroutine_traits {\n+    using promise_type = typename _R::promise_type;\n+  };\n+\n+  // name is present, but not a template.\n+  struct coroutine_handle {\n+  };\n+}\n+\n+int\n+bad_coroutine (void)\n+{\n+  co_yield 5; // { dg-error {coroutines require a handle class template; cannot find 'std::coroutine_handle'} }\n+  co_return;\n+}"}, {"sha": "8bb58cc0a78d8ecb31668461eb3173a0639d60ed", "filename": "gcc/testsuite/g++.dg/coroutines/pr93458-5-bad-coro-type.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60c25fa02044181196768fa8b63980e0f535c38/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr93458-5-bad-coro-type.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60c25fa02044181196768fa8b63980e0f535c38/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr93458-5-bad-coro-type.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr93458-5-bad-coro-type.C?ref=d60c25fa02044181196768fa8b63980e0f535c38", "patch": "@@ -0,0 +1,12 @@\n+//  { dg-additional-options \"-fsyntax-only -fexceptions -w\" }\n+\n+// Diagose bad coroutine function type.\n+\n+#include \"coro.h\"\n+\n+int\n+bad_coroutine (void) // { dg-error {coroutine return type 'int' is not a class} }\n+{\n+  co_yield 5;\n+  co_return;\n+}"}]}