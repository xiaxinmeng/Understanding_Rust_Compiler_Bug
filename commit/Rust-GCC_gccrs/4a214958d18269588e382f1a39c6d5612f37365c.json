{"sha": "4a214958d18269588e382f1a39c6d5612f37365c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGEyMTQ5NThkMTgyNjk1ODhlMzgyZjFhMzljNmQ1NjEyZjM3MzY1Yw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-14T12:39:55Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-14T12:39:55Z"}, "message": "[multiple changes]\n\n2010-06-14  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch8.adb (End_Use_Type): Before indicating that an operator is not\n\tuse-visible, check whether it is a primitive for more than one type.\n\n2010-06-14  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch3.adb (Copy_And_Swap): Copy Has_Pragma_Unmodified flag.\n\n\t* sem_ch7.adb (Preserve_Full_Attributes): Preserve\n\tHas_Pragma_Unmodified flag.\n\n2010-06-14  Thomas Quinot  <quinot@adacore.com>\n\n\t* g-sttsne-locking.adb, g-sttsne-locking.ads, g-sttsne.ads,\n\tg-sttsne-vxworks.adb, g-sttsne-dummy.ads: Removed. Mutual exclusion is\n\tnow done in GNAT.Sockets if necessary.\n\t* gsocket.h, g-socket.adb, g-sothco.ads (GNAT.Sockets.Get_XXX_By_YYY):\n\tEnsure mutual exclusion for netdb operations if the target platform\n\trequires it.\n\t(GNAT.Sockets.Thin_Common): New binding for getXXXbyYYY, treating struct\n\thostent as an opaque type to improve portability.\n\t* s-oscons-tmplt.c, socket.c: For the case of Vxworks, emulate\n\tgethostbyYYY using proprietary VxWorks API so that a uniform interface\n\tis available for the Ada side.\n\t* gcc-interface/Makefile.in: Remove g-sttsne-*\n\t* gcc-interface/Make-lang.in: Update dependencies.\n\n2010-06-14  Vincent Celier  <celier@adacore.com>\n\n\t* gnatcmd.adb (Mapping_File): New function.\n\nFrom-SVN: r160731", "tree": {"sha": "a0154a432838c9ab26b6f1434eabfeddc95a92d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0154a432838c9ab26b6f1434eabfeddc95a92d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a214958d18269588e382f1a39c6d5612f37365c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a214958d18269588e382f1a39c6d5612f37365c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a214958d18269588e382f1a39c6d5612f37365c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a214958d18269588e382f1a39c6d5612f37365c/comments", "author": null, "committer": null, "parents": [{"sha": "5bca794b0df69689d0bcc6d03697f169e543dd2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bca794b0df69689d0bcc6d03697f169e543dd2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bca794b0df69689d0bcc6d03697f169e543dd2c"}], "stats": {"total": 1782, "additions": 587, "deletions": 1195}, "files": [{"sha": "484541e9d6ec793b4aa989d781b23da78a9ed3c4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4a214958d18269588e382f1a39c6d5612f37365c", "patch": "@@ -1,3 +1,35 @@\n+2010-06-14  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch8.adb (End_Use_Type): Before indicating that an operator is not\n+\tuse-visible, check whether it is a primitive for more than one type.\n+\n+2010-06-14  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch3.adb (Copy_And_Swap): Copy Has_Pragma_Unmodified flag.\n+\n+\t* sem_ch7.adb (Preserve_Full_Attributes): Preserve\n+\tHas_Pragma_Unmodified flag.\n+\n+2010-06-14  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* g-sttsne-locking.adb, g-sttsne-locking.ads, g-sttsne.ads,\n+\tg-sttsne-vxworks.adb, g-sttsne-dummy.ads: Removed. Mutual exclusion is\n+\tnow done in GNAT.Sockets if necessary.\n+\t* gsocket.h, g-socket.adb, g-sothco.ads (GNAT.Sockets.Get_XXX_By_YYY):\n+\tEnsure mutual exclusion for netdb operations if the target platform\n+\trequires it.\n+\t(GNAT.Sockets.Thin_Common): New binding for getXXXbyYYY, treating struct\n+\thostent as an opaque type to improve portability.\n+\t* s-oscons-tmplt.c, socket.c: For the case of Vxworks, emulate\n+\tgethostbyYYY using proprietary VxWorks API so that a uniform interface\n+\tis available for the Ada side.\n+\t* gcc-interface/Makefile.in: Remove g-sttsne-*\n+\t* gcc-interface/Make-lang.in: Update dependencies.\n+\n+2010-06-14  Vincent Celier  <celier@adacore.com>\n+\n+\t* gnatcmd.adb (Mapping_File): New function.\n+\n 2010-06-14  Javier Miranda  <miranda@adacore.com>\n \n \t* sem_ch3.adb (Derive_Subprograms): Remove over-restrictive assertion."}, {"sha": "0122c5a7e8cfcc9e2b56cd7bc1774e9b521ed83e", "filename": "gcc/ada/g-socket.adb", "status": "modified", "additions": 117, "deletions": 75, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2Fg-socket.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2Fg-socket.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.adb?ref=4a214958d18269588e382f1a39c6d5612f37365c", "patch": "@@ -40,7 +40,6 @@ with Interfaces.C.Strings;\n \n with GNAT.Sockets.Thin_Common;          use GNAT.Sockets.Thin_Common;\n with GNAT.Sockets.Thin;                 use GNAT.Sockets.Thin;\n-with GNAT.Sockets.Thin.Task_Safe_NetDB; use GNAT.Sockets.Thin.Task_Safe_NetDB;\n \n with GNAT.Sockets.Linker_Options;\n pragma Warnings (Off, GNAT.Sockets.Linker_Options);\n@@ -49,6 +48,7 @@ pragma Warnings (Off, GNAT.Sockets.Linker_Options);\n with System;               use System;\n with System.Communication; use System.Communication;\n with System.CRTL;          use System.CRTL;\n+with System.Task_Lock;\n \n package body GNAT.Sockets is\n \n@@ -59,6 +59,7 @@ package body GNAT.Sockets is\n    ENOERROR : constant := 0;\n \n    Netdb_Buffer_Size : constant := SOSC.Need_Netdb_Buffer * 1024;\n+   Need_Netdb_Lock   : constant Boolean := SOSC.Need_Netdb_Lock /= 0;\n    --  The network database functions gethostbyname, gethostbyaddr,\n    --  getservbyname and getservbyport can either be guaranteed task safe by\n    --  the operating system, or else return data through a user-provided buffer\n@@ -155,13 +156,20 @@ package body GNAT.Sockets is\n    function Is_IP_Address (Name : String) return Boolean;\n    --  Return true when Name is an IP address in standard dot notation\n \n+   procedure Netdb_Lock;\n+   pragma Inline (Netdb_Lock);\n+   procedure Netdb_Unlock;\n+   pragma Inline (Netdb_Unlock);\n+   --  Lock/unlock operation used to protect netdb access for platforms that\n+   --  require such protection.\n+\n    function To_In_Addr (Addr : Inet_Addr_Type) return In_Addr;\n    procedure To_Inet_Addr\n      (Addr   : In_Addr;\n       Result : out Inet_Addr_Type);\n    --  Conversion functions\n \n-   function To_Host_Entry (E : Hostent) return Host_Entry_Type;\n+   function To_Host_Entry (E : Hostent_Access) return Host_Entry_Type;\n    --  Conversion function\n \n    function To_Service_Entry (E : Servent_Access) return Service_Entry_Type;\n@@ -891,13 +899,19 @@ package body GNAT.Sockets is\n       Err    : aliased C.int;\n \n    begin\n-      if Safe_Gethostbyaddr (HA'Address, HA'Size / 8, SOSC.AF_INET,\n+      Netdb_Lock;\n+      if C_Gethostbyaddr (HA'Address, HA'Size / 8, SOSC.AF_INET,\n                              Res'Access, Buf'Address, Buflen, Err'Access) /= 0\n       then\n+         Netdb_Unlock;\n          Raise_Host_Error (Integer (Err));\n       end if;\n \n-      return To_Host_Entry (Res);\n+      return H : constant Host_Entry_Type :=\n+                   To_Host_Entry (Res'Unchecked_Access)\n+      do\n+         Netdb_Unlock;\n+      end return;\n    end Get_Host_By_Address;\n \n    ----------------------\n@@ -920,13 +934,19 @@ package body GNAT.Sockets is\n          Err    : aliased C.int;\n \n       begin\n-         if Safe_Gethostbyname\n+         Netdb_Lock;\n+         if C_Gethostbyname\n            (HN, Res'Access, Buf'Address, Buflen, Err'Access) /= 0\n          then\n+            Netdb_Unlock;\n             Raise_Host_Error (Integer (Err));\n          end if;\n \n-         return To_Host_Entry (Res);\n+         return H : constant Host_Entry_Type :=\n+                      To_Host_Entry (Res'Unchecked_Access)\n+         do\n+            Netdb_Unlock;\n+         end return;\n       end;\n    end Get_Host_By_Name;\n \n@@ -965,13 +985,19 @@ package body GNAT.Sockets is\n       Res    : aliased Servent;\n \n    begin\n-      if Safe_Getservbyname (SN, SP, Res'Access, Buf'Address, Buflen) /= 0 then\n+      Netdb_Lock;\n+      if C_Getservbyname (SN, SP, Res'Access, Buf'Address, Buflen) /= 0 then\n+         Netdb_Unlock;\n          raise Service_Error with \"Service not found\";\n       end if;\n \n       --  Translate from the C format to the API format\n \n-      return To_Service_Entry (Res'Unchecked_Access);\n+      return S : constant Service_Entry_Type :=\n+                   To_Service_Entry (Res'Unchecked_Access)\n+      do\n+         Netdb_Unlock;\n+      end return;\n    end Get_Service_By_Name;\n \n    -------------------------\n@@ -988,16 +1014,22 @@ package body GNAT.Sockets is\n       Res    : aliased Servent;\n \n    begin\n-      if Safe_Getservbyport\n+      Netdb_Lock;\n+      if C_Getservbyport\n         (C.int (Short_To_Network (C.unsigned_short (Port))), SP,\n          Res'Access, Buf'Address, Buflen) /= 0\n       then\n+         Netdb_Unlock;\n          raise Service_Error with \"Service not found\";\n       end if;\n \n       --  Translate from the C format to the API format\n \n-      return To_Service_Entry (Res'Unchecked_Access);\n+      return S : constant Service_Entry_Type :=\n+                   To_Service_Entry (Res'Unchecked_Access)\n+      do\n+         Netdb_Unlock;\n+      end return;\n    end Get_Service_By_Port;\n \n    ---------------------\n@@ -1438,6 +1470,28 @@ package body GNAT.Sockets is\n       end if;\n    end Narrow;\n \n+   ----------------\n+   -- Netdb_Lock --\n+   ----------------\n+\n+   procedure Netdb_Lock is\n+   begin\n+      if Need_Netdb_Lock then\n+         System.Task_Lock.Lock;\n+      end if;\n+   end Netdb_Lock;\n+\n+   ------------------\n+   -- Netdb_Unlock --\n+   ------------------\n+\n+   procedure Netdb_Unlock is\n+   begin\n+      if Need_Netdb_Lock then\n+         System.Task_Lock.Unlock;\n+      end if;\n+   end Netdb_Unlock;\n+\n    --------------------------------\n    -- Normalize_Empty_Socket_Set --\n    --------------------------------\n@@ -2273,54 +2327,52 @@ package body GNAT.Sockets is\n    -- To_Host_Entry --\n    -------------------\n \n-   function To_Host_Entry (E : Hostent) return Host_Entry_Type is\n+   function To_Host_Entry (E : Hostent_Access) return Host_Entry_Type is\n       use type C.size_t;\n+      use C.Strings;\n \n-      Official : constant String :=\n-                  C.Strings.Value (E.H_Name);\n+      Aliases_Count, Addresses_Count : Natural;\n \n-      Aliases : constant Chars_Ptr_Array :=\n-                  Chars_Ptr_Pointers.Value (E.H_Aliases);\n-      --  H_Aliases points to a list of name aliases. The list is terminated by\n-      --  a NULL pointer.\n-\n-      Addresses : constant In_Addr_Access_Array :=\n-                    In_Addr_Access_Pointers.Value (E.H_Addr_List);\n-      --  H_Addr_List points to a list of binary addresses (in network byte\n-      --  order). The list is terminated by a NULL pointer.\n-      --\n-      --  H_Length is not used because it is currently only set to 4.\n+      --  H_Length is not used because it is currently only set to 4\n       --  H_Addrtype is always AF_INET\n \n-      Result : Host_Entry_Type\n-                 (Aliases_Length   => Aliases'Length - 1,\n-                  Addresses_Length => Addresses'Length - 1);\n-      --  The last element is a null pointer\n-\n-      Source : C.size_t;\n-      Target : Natural;\n-\n    begin\n-      Result.Official := To_Name (Official);\n-\n-      Source := Aliases'First;\n-      Target := Result.Aliases'First;\n-      while Target <= Result.Aliases_Length loop\n-         Result.Aliases (Target) :=\n-           To_Name (C.Strings.Value (Aliases (Source)));\n-         Source := Source + 1;\n-         Target := Target + 1;\n+      Aliases_Count := 0;\n+      while Hostent_H_Alias (E, C.int (Aliases_Count)) /= Null_Ptr loop\n+         Aliases_Count := Aliases_Count + 1;\n       end loop;\n \n-      Source := Addresses'First;\n-      Target := Result.Addresses'First;\n-      while Target <= Result.Addresses_Length loop\n-         To_Inet_Addr (Addresses (Source).all, Result.Addresses (Target));\n-         Source := Source + 1;\n-         Target := Target + 1;\n+      Addresses_Count := 0;\n+      while Hostent_H_Addr (E, C.int (Addresses_Count)) /= Null_Ptr loop\n+         Addresses_Count := Addresses_Count + 1;\n       end loop;\n \n-      return Result;\n+      return Result : Host_Entry_Type\n+                        (Aliases_Length   => Aliases_Count,\n+                         Addresses_Length => Addresses_Count)\n+      do\n+         Result.Official := To_Name (Value (Hostent_H_Name (E)));\n+\n+         for J in Result.Aliases'Range loop\n+            Result.Aliases (J) :=\n+              To_Name (Value (Hostent_H_Alias\n+                                (E, C.int (J - Result.Aliases'First))));\n+         end loop;\n+\n+         for J in Result.Addresses'Range loop\n+            declare\n+               Addr : In_Addr;\n+               function To_Address is\n+                 new Ada.Unchecked_Conversion (chars_ptr, System.Address);\n+               for Addr'Address use\n+                 To_Address (Hostent_H_Addr\n+                               (E, C.int (J - Result.Addresses'First)));\n+               pragma Import (Ada, Addr);\n+            begin\n+               To_Inet_Addr (Addr, Result.Addresses (J));\n+            end;\n+         end loop;\n+      end return;\n    end To_Host_Entry;\n \n    ----------------\n@@ -2394,40 +2446,30 @@ package body GNAT.Sockets is\n    ----------------------\n \n    function To_Service_Entry (E : Servent_Access) return Service_Entry_Type is\n+      use C.Strings;\n       use type C.size_t;\n \n-      Official : constant String := C.Strings.Value (Servent_S_Name (E));\n-\n-      Aliases : constant Chars_Ptr_Array :=\n-                  Chars_Ptr_Pointers.Value (Servent_S_Aliases (E));\n-      --  S_Aliases points to a list of name aliases. The list is\n-      --  terminated by a NULL pointer.\n-\n-      Protocol : constant String := C.Strings.Value (Servent_S_Proto (E));\n-\n-      Result : Service_Entry_Type (Aliases_Length => Aliases'Length - 1);\n-      --  The last element is a null pointer\n-\n-      Source : C.size_t;\n-      Target : Natural;\n+      Aliases_Count : Natural;\n \n    begin\n-      Result.Official := To_Name (Official);\n-\n-      Source := Aliases'First;\n-      Target := Result.Aliases'First;\n-      while Target <= Result.Aliases_Length loop\n-         Result.Aliases (Target) :=\n-           To_Name (C.Strings.Value (Aliases (Source)));\n-         Source := Source + 1;\n-         Target := Target + 1;\n+      Aliases_Count := 0;\n+      while Servent_S_Alias (E, C.int (Aliases_Count)) /= Null_Ptr loop\n+         Aliases_Count := Aliases_Count + 1;\n       end loop;\n \n-      Result.Port :=\n-        Port_Type (Network_To_Short (C.unsigned_short (Servent_S_Port (E))));\n+      return Result : Service_Entry_Type (Aliases_Length   => Aliases_Count) do\n+         Result.Official := To_Name (Value (Servent_S_Name (E)));\n \n-      Result.Protocol := To_Name (Protocol);\n-      return Result;\n+         for J in Result.Aliases'Range loop\n+            Result.Aliases (J) :=\n+              To_Name (Value (Servent_S_Alias\n+                                (E, C.int (J - Result.Aliases'First))));\n+         end loop;\n+\n+         Result.Protocol := To_Name (Value (Servent_S_Proto (E)));\n+         Result.Port :=\n+           Port_Type (Network_To_Short (Servent_S_Port (E)));\n+      end return;\n    end To_Service_Entry;\n \n    ---------------"}, {"sha": "168061d482cdbd1322d109097f56d91dd58662e9", "filename": "gcc/ada/g-sothco.ads", "status": "modified", "additions": 90, "deletions": 48, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2Fg-sothco.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2Fg-sothco.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sothco.ads?ref=4a214958d18269588e382f1a39c6d5612f37365c", "patch": "@@ -200,18 +200,40 @@ package GNAT.Sockets.Thin_Common is\n    pragma Inline (Set_Address);\n    --  Set Sin.Sin_Addr to Address\n \n+   ------------------\n+   -- Host entries --\n+   ------------------\n+\n+   type Hostent is new\n+     System.Storage_Elements.Storage_Array (1 .. SOSC.SIZEOF_struct_hostent);\n+   for Hostent'Alignment use 8;\n+   --  Host entry. This is an opaque type used only via the following\n+   --  accessor functions, because 'struct hostent' has different layouts on\n+   --  different platforms.\n+\n+   type Hostent_Access is access all Hostent;\n+   pragma Convention (C, Hostent_Access);\n+   --  Access to host entry\n+\n+   function Hostent_H_Name\n+     (E : Hostent_Access) return C.Strings.chars_ptr;\n+\n+   function Hostent_H_Alias\n+     (E : Hostent_Access; I : C.int) return C.Strings.chars_ptr;\n+\n+   function Hostent_H_Addrtype\n+     (E : Hostent_Access) return C.int;\n+\n+   function Hostent_H_Length\n+     (E : Hostent_Access) return C.int;\n+\n+   function Hostent_H_Addr\n+     (E : Hostent_Access; Index : C.int) return C.Strings.chars_ptr;\n+\n    ---------------------\n    -- Service entries --\n    ---------------------\n \n-   type Chars_Ptr_Array is array (C.size_t range <>) of\n-     aliased C.Strings.chars_ptr;\n-\n-   package Chars_Ptr_Pointers is\n-      new C.Pointers (C.size_t, C.Strings.chars_ptr, Chars_Ptr_Array,\n-                      C.Strings.Null_Ptr);\n-   --  Arrays of C (char *)\n-\n    type Servent is new\n      System.Storage_Elements.Storage_Array (1 .. SOSC.SIZEOF_struct_servent);\n    for Servent'Alignment use 8;\n@@ -226,48 +248,60 @@ package GNAT.Sockets.Thin_Common is\n    function Servent_S_Name\n      (E : Servent_Access) return C.Strings.chars_ptr;\n \n-   function Servent_S_Aliases\n-     (E : Servent_Access) return Chars_Ptr_Pointers.Pointer;\n+   function Servent_S_Alias\n+     (E : Servent_Access; Index : C.int) return C.Strings.chars_ptr;\n \n    function Servent_S_Port\n-     (E : Servent_Access) return C.int;\n+     (E : Servent_Access) return C.unsigned_short;\n \n    function Servent_S_Proto\n      (E : Servent_Access) return C.Strings.chars_ptr;\n \n-   procedure Servent_Set_S_Name\n-     (E      : Servent_Access;\n-      S_Name : C.Strings.chars_ptr);\n-\n-   procedure Servent_Set_S_Aliases\n-     (E         : Servent_Access;\n-      S_Aliases : Chars_Ptr_Pointers.Pointer);\n-\n-   procedure Servent_Set_S_Port\n-     (E      : Servent_Access;\n-      S_Port : C.int);\n-\n-   procedure Servent_Set_S_Proto\n-     (E       : Servent_Access;\n-      S_Proto : C.Strings.chars_ptr);\n-\n    ------------------\n-   -- Host entries --\n+   -- NetDB access --\n    ------------------\n \n-   type Hostent is record\n-      H_Name      : C.Strings.chars_ptr;\n-      H_Aliases   : Chars_Ptr_Pointers.Pointer;\n-      H_Addrtype  : SOSC.H_Addrtype_T;\n-      H_Length    : SOSC.H_Length_T;\n-      H_Addr_List : In_Addr_Access_Pointers.Pointer;\n-   end record;\n-   pragma Convention (C, Hostent);\n-   --  Host entry\n-\n-   type Hostent_Access is access all Hostent;\n-   pragma Convention (C, Hostent_Access);\n-   --  Access to host entry\n+   --  There are three possible situations for the following NetDB access\n+   --  functions:\n+   --    - inherently thread safe (case of data returned in a thread specific\n+   --      buffer);\n+   --    - thread safe using user-provided buffer;\n+   --    - thread unsafe.\n+   --\n+   --  In the first and third cases, the Buf and Buflen are ignored. In the\n+   --  second case, the caller must provide a buffer large enough to accomodate\n+   --  the returned data. In the third case, the caller must ensure that these\n+   --  functions are called within a critical section.\n+\n+   function C_Gethostbyname\n+     (Name     : C.char_array;\n+      Ret      : not null access Hostent;\n+      Buf      : System.Address;\n+      Buflen   : C.int;\n+      H_Errnop : not null access C.int) return C.int;\n+\n+   function C_Gethostbyaddr\n+     (Addr      : System.Address;\n+      Addr_Len  : C.int;\n+      Addr_Type : C.int;\n+      Ret       : not null access Hostent;\n+      Buf       : System.Address;\n+      Buflen    : C.int;\n+      H_Errnop  : not null access C.int) return C.int;\n+\n+   function C_Getservbyname\n+     (Name     : C.char_array;\n+      Proto    : C.char_array;\n+      Ret      : not null access Servent;\n+      Buf      : System.Address;\n+      Buflen   : C.int) return C.int;\n+\n+   function C_Getservbyport\n+     (Port     : C.int;\n+      Proto    : C.char_array;\n+      Ret      : not null access Servent;\n+      Buf      : System.Address;\n+      Buflen   : C.int) return C.int;\n \n    ------------------------------------\n    -- Scatter/gather vector handling --\n@@ -362,12 +396,20 @@ private\n    pragma Import (C, C_Ioctl, \"__gnat_socket_ioctl\");\n    pragma Import (C, Inet_Pton, SOSC.Inet_Pton_Linkname);\n \n-   pragma Import (C, Servent_S_Name, \"__gnat_servent_s_name\");\n-   pragma Import (C, Servent_S_Aliases, \"__gnat_servent_s_aliases\");\n-   pragma Import (C, Servent_S_Port, \"__gnat_servent_s_port\");\n+   pragma Import (C, C_Gethostbyname, \"__gnat_gethostbyname\");\n+   pragma Import (C, C_Gethostbyaddr, \"__gnat_gethostbyaddr\");\n+   pragma Import (C, C_Getservbyname, \"__gnat_getservbyname\");\n+   pragma Import (C, C_Getservbyport, \"__gnat_getservbyport\");\n+\n+   pragma Import (C, Servent_S_Name,  \"__gnat_servent_s_name\");\n+   pragma Import (C, Servent_S_Alias, \"__gnat_servent_s_alias\");\n+   pragma Import (C, Servent_S_Port,  \"__gnat_servent_s_port\");\n    pragma Import (C, Servent_S_Proto, \"__gnat_servent_s_proto\");\n-   pragma Import (C, Servent_Set_S_Name, \"__gnat_servent_set_s_name\");\n-   pragma Import (C, Servent_Set_S_Aliases, \"__gnat_servent_set_s_aliases\");\n-   pragma Import (C, Servent_Set_S_Port, \"__gnat_servent_set_s_port\");\n-   pragma Import (C, Servent_Set_S_Proto, \"__gnat_servent_set_s_proto\");\n+\n+   pragma Import (C, Hostent_H_Name,     \"__gnat_hostent_h_name\");\n+   pragma Import (C, Hostent_H_Alias,    \"__gnat_hostent_h_alias\");\n+   pragma Import (C, Hostent_H_Addrtype, \"__gnat_hostent_h_addrtype\");\n+   pragma Import (C, Hostent_H_Length,   \"__gnat_hostent_h_length\");\n+   pragma Import (C, Hostent_H_Addr,     \"__gnat_hostent_h_addr\");\n+\n end GNAT.Sockets.Thin_Common;"}, {"sha": "9cb25898dfa36ea1d93f4d4b6aefe63daf468cb4", "filename": "gcc/ada/g-sttsne-dummy.ads", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bca794b0df69689d0bcc6d03697f169e543dd2c/gcc%2Fada%2Fg-sttsne-dummy.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bca794b0df69689d0bcc6d03697f169e543dd2c/gcc%2Fada%2Fg-sttsne-dummy.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sttsne-dummy.ads?ref=5bca794b0df69689d0bcc6d03697f169e543dd2c", "patch": "@@ -1,39 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---    G N A T . S O C K E T S . T H I N . T A S K _ S A F E _ N E T D B     --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---                     Copyright (C) 2007-2008, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package is a placeholder for the sockets binding for platforms where\n---  it is not implemented.\n-\n-package GNAT.Sockets.Thin.Task_Safe_NetDB is\n-   pragma Unimplemented_Unit;\n-end GNAT.Sockets.Thin.Task_Safe_NetDB;"}, {"sha": "c5e39b734b90609d1bf3793b93c60fe504a4c526", "filename": "gcc/ada/g-sttsne-locking.adb", "status": "removed", "additions": 0, "deletions": 460, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bca794b0df69689d0bcc6d03697f169e543dd2c/gcc%2Fada%2Fg-sttsne-locking.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bca794b0df69689d0bcc6d03697f169e543dd2c/gcc%2Fada%2Fg-sttsne-locking.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sttsne-locking.adb?ref=5bca794b0df69689d0bcc6d03697f169e543dd2c", "patch": "@@ -1,460 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---    G N A T . S O C K E T S . T H I N . T A S K _ S A F E _ N E T D B     --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---                   Copyright (C) 2007-2009, AdaCore                       --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This version is used on VMS and LynxOS\n-\n-with GNAT.Task_Lock;\n-\n-with Interfaces.C; use Interfaces.C;\n-\n-package body GNAT.Sockets.Thin.Task_Safe_NetDB is\n-\n-   --  The Safe_GetXXXbyYYY routines wrap the Nonreentrant_ versions using the\n-   --  task lock, and copy the relevant data structures (under the lock) into\n-   --  the result. The Nonreentrant_ versions are expected to be in the parent\n-   --  package GNAT.Sockets.Thin (on platforms that use this version of\n-   --  Task_Safe_NetDB).\n-\n-   procedure Copy_Host_Entry\n-     (Source_Hostent       : Hostent;\n-      Target_Hostent       : out Hostent;\n-      Target_Buffer        : System.Address;\n-      Target_Buffer_Length : C.int;\n-      Result               : out C.int);\n-   --  Copy all the information from Source_Hostent into Target_Hostent,\n-   --  using Target_Buffer to store associated data.\n-   --  0 is returned on success, -1 on failure (in case the provided buffer\n-   --  is too small for the associated data).\n-\n-   procedure Copy_Service_Entry\n-     (Source_Servent       : Servent_Access;\n-      Target_Servent       : Servent_Access;\n-      Target_Buffer        : System.Address;\n-      Target_Buffer_Length : C.int;\n-      Result               : out C.int);\n-   --  Copy all the information from Source_Servent into Target_Servent,\n-   --  using Target_Buffer to store associated data.\n-   --  0 is returned on success, -1 on failure (in case the provided buffer\n-   --  is too small for the associated data).\n-\n-   procedure Store_Name\n-     (Name          : char_array;\n-      Storage       : in out char_array;\n-      Storage_Index : in out size_t;\n-      Stored_Name   : out C.Strings.chars_ptr);\n-   --  Store the given Name at the first available location in Storage\n-   --  (indicated by Storage_Index, which is updated afterwards), and return\n-   --  the address of that location in Stored_Name.\n-   --  (Supporting routine for the two below).\n-\n-   ---------------------\n-   -- Copy_Host_Entry --\n-   ---------------------\n-\n-   procedure Copy_Host_Entry\n-     (Source_Hostent       : Hostent;\n-      Target_Hostent       : out Hostent;\n-      Target_Buffer        : System.Address;\n-      Target_Buffer_Length : C.int;\n-      Result               : out C.int)\n-   is\n-      use type C.Strings.chars_ptr;\n-\n-      Names_Length : size_t;\n-\n-      Source_Aliases : Chars_Ptr_Array\n-        renames Chars_Ptr_Pointers.Value\n-          (Source_Hostent.H_Aliases, Terminator => C.Strings.Null_Ptr);\n-      --  Null-terminated list of aliases (last element of this array is\n-      --  Null_Ptr).\n-\n-      Source_Addresses : In_Addr_Access_Array\n-        renames In_Addr_Access_Pointers.Value\n-          (Source_Hostent.H_Addr_List, Terminator => null);\n-\n-   begin\n-      Result := -1;\n-      Names_Length := C.Strings.Strlen (Source_Hostent.H_Name) + 1;\n-\n-      for J in Source_Aliases'Range loop\n-         if Source_Aliases (J) /= C.Strings.Null_Ptr then\n-            Names_Length :=\n-              Names_Length + C.Strings.Strlen (Source_Aliases (J)) + 1;\n-         end if;\n-      end loop;\n-\n-      declare\n-         type In_Addr_Array is array (Source_Addresses'Range)\n-                                 of aliased In_Addr;\n-\n-         type Netdb_Host_Data is record\n-            Aliases_List   : aliased Chars_Ptr_Array (Source_Aliases'Range);\n-            Names          : aliased char_array (1 .. Names_Length);\n-\n-            Addresses_List : aliased In_Addr_Access_Array\n-                                       (In_Addr_Array'Range);\n-            Addresses : In_Addr_Array;\n-            --  ??? This assumes support only for Inet family\n-\n-         end record;\n-\n-         Netdb_Data : Netdb_Host_Data;\n-         pragma Import (Ada, Netdb_Data);\n-         for Netdb_Data'Address use Target_Buffer;\n-\n-         Names_Index : size_t := Netdb_Data.Names'First;\n-         --  Index of first available location in Netdb_Data.Names\n-\n-      begin\n-         if Netdb_Data'Size / 8 > Target_Buffer_Length then\n-            return;\n-         end if;\n-\n-         --  Copy host name\n-\n-         Store_Name\n-           (C.Strings.Value (Source_Hostent.H_Name),\n-            Netdb_Data.Names, Names_Index,\n-            Target_Hostent.H_Name);\n-\n-         --  Copy aliases (null-terminated string pointer array)\n-\n-         Target_Hostent.H_Aliases :=\n-           Netdb_Data.Aliases_List\n-             (Netdb_Data.Aliases_List'First)'Unchecked_Access;\n-         for J in Netdb_Data.Aliases_List'Range loop\n-            if J = Netdb_Data.Aliases_List'Last then\n-               Netdb_Data.Aliases_List (J) := C.Strings.Null_Ptr;\n-            else\n-               Store_Name\n-                 (C.Strings.Value (Source_Aliases (J)),\n-                  Netdb_Data.Names, Names_Index,\n-                  Netdb_Data.Aliases_List (J));\n-            end if;\n-         end loop;\n-\n-         --  Copy address type and length\n-\n-         Target_Hostent.H_Addrtype := Source_Hostent.H_Addrtype;\n-         Target_Hostent.H_Length   := Source_Hostent.H_Length;\n-\n-         --  Copy addresses\n-\n-         Target_Hostent.H_Addr_List :=\n-           Netdb_Data.Addresses_List\n-             (Netdb_Data.Addresses_List'First)'Unchecked_Access;\n-\n-         for J in Netdb_Data.Addresses'Range loop\n-            if J = Netdb_Data.Addresses'Last then\n-               Netdb_Data.Addresses_List (J) := null;\n-            else\n-               Netdb_Data.Addresses_List (J) :=\n-                 Netdb_Data.Addresses (J)'Unchecked_Access;\n-\n-               Netdb_Data.Addresses (J) := Source_Addresses (J).all;\n-            end if;\n-         end loop;\n-      end;\n-\n-      Result := 0;\n-   end Copy_Host_Entry;\n-\n-   ------------------------\n-   -- Copy_Service_Entry --\n-   ------------------------\n-\n-   procedure Copy_Service_Entry\n-     (Source_Servent       : Servent_Access;\n-      Target_Servent       : Servent_Access;\n-      Target_Buffer        : System.Address;\n-      Target_Buffer_Length : C.int;\n-      Result               : out C.int)\n-   is\n-      use type C.Strings.chars_ptr;\n-\n-      Names_Length : size_t;\n-\n-      Source_Aliases : Chars_Ptr_Array\n-        renames Chars_Ptr_Pointers.Value\n-          (Servent_S_Aliases (Source_Servent),\n-           Terminator => C.Strings.Null_Ptr);\n-      --  Null-terminated list of aliases (last element of this array is\n-      --  Null_Ptr).\n-\n-   begin\n-      Result := -1;\n-      Names_Length := C.Strings.Strlen (Servent_S_Name (Source_Servent)) + 1 +\n-                      C.Strings.Strlen (Servent_S_Proto (Source_Servent)) + 1;\n-\n-      for J in Source_Aliases'Range loop\n-         if Source_Aliases (J) /= C.Strings.Null_Ptr then\n-            Names_Length :=\n-              Names_Length + C.Strings.Strlen (Source_Aliases (J)) + 1;\n-         end if;\n-      end loop;\n-\n-      declare\n-         type Netdb_Service_Data is record\n-            Aliases_List : aliased Chars_Ptr_Array (Source_Aliases'Range);\n-            Names        : aliased char_array (1 .. Names_Length);\n-         end record;\n-\n-         Netdb_Data : Netdb_Service_Data;\n-         pragma Import (Ada, Netdb_Data);\n-         for Netdb_Data'Address use Target_Buffer;\n-\n-         Names_Index : size_t := Netdb_Data.Names'First;\n-         --  Index of first available location in Netdb_Data.Names\n-\n-         Stored_Name : C.Strings.chars_ptr;\n-\n-      begin\n-         if Netdb_Data'Size / 8 > Target_Buffer_Length then\n-            return;\n-         end if;\n-\n-         --  Copy service name\n-\n-         Store_Name\n-           (C.Strings.Value (Servent_S_Name (Source_Servent)),\n-            Netdb_Data.Names, Names_Index,\n-            Stored_Name);\n-         Servent_Set_S_Name (Target_Servent, Stored_Name);\n-\n-         --  Copy aliases (null-terminated string pointer array)\n-\n-         Servent_Set_S_Aliases\n-           (Target_Servent,\n-            Netdb_Data.Aliases_List\n-              (Netdb_Data.Aliases_List'First)'Unchecked_Access);\n-\n-         --  Copy port number\n-\n-         Servent_Set_S_Port (Target_Servent, Servent_S_Port (Source_Servent));\n-\n-         --  Copy protocol name\n-\n-         Store_Name\n-           (C.Strings.Value (Servent_S_Proto (Source_Servent)),\n-            Netdb_Data.Names, Names_Index,\n-            Stored_Name);\n-         Servent_Set_S_Proto (Target_Servent, Stored_Name);\n-\n-         for J in Netdb_Data.Aliases_List'Range loop\n-            if J = Netdb_Data.Aliases_List'Last then\n-               Netdb_Data.Aliases_List (J) := C.Strings.Null_Ptr;\n-            else\n-               Store_Name\n-                 (C.Strings.Value (Source_Aliases (J)),\n-                  Netdb_Data.Names, Names_Index,\n-                  Netdb_Data.Aliases_List (J));\n-            end if;\n-         end loop;\n-      end;\n-\n-      Result := 0;\n-   end Copy_Service_Entry;\n-\n-   ------------------------\n-   -- Safe_Gethostbyaddr --\n-   ------------------------\n-\n-   function Safe_Gethostbyaddr\n-     (Addr      : System.Address;\n-      Addr_Len  : C.int;\n-      Addr_Type : C.int;\n-      Ret      : not null access Hostent;\n-      Buf      : System.Address;\n-      Buflen   : C.int;\n-      H_Errnop : not null access C.int) return C.int\n-   is\n-      HE     : Hostent_Access;\n-      Result : C.int;\n-   begin\n-      Result := -1;\n-      GNAT.Task_Lock.Lock;\n-      HE := Nonreentrant_Gethostbyaddr (Addr, Addr_Len, Addr_Type);\n-\n-      if HE = null then\n-         H_Errnop.all := C.int (Host_Errno);\n-         goto Unlock_Return;\n-      end if;\n-\n-      --  Now copy the data to the user-provided buffer\n-\n-      Copy_Host_Entry\n-        (Source_Hostent       => HE.all,\n-         Target_Hostent       => Ret.all,\n-         Target_Buffer        => Buf,\n-         Target_Buffer_Length => Buflen,\n-         Result               => Result);\n-\n-      <<Unlock_Return>>\n-      GNAT.Task_Lock.Unlock;\n-      return Result;\n-   end Safe_Gethostbyaddr;\n-\n-   ------------------------\n-   -- Safe_Gethostbyname --\n-   ------------------------\n-\n-   function Safe_Gethostbyname\n-     (Name     : C.char_array;\n-      Ret      : not null access Hostent;\n-      Buf      : System.Address;\n-      Buflen   : C.int;\n-      H_Errnop : not null access C.int) return C.int\n-   is\n-      HE     : Hostent_Access;\n-      Result : C.int;\n-   begin\n-      Result := -1;\n-      GNAT.Task_Lock.Lock;\n-      HE := Nonreentrant_Gethostbyname (Name);\n-\n-      if HE = null then\n-         H_Errnop.all := C.int (Host_Errno);\n-         goto Unlock_Return;\n-      end if;\n-\n-      --  Now copy the data to the user-provided buffer\n-\n-      Copy_Host_Entry\n-        (Source_Hostent       => HE.all,\n-         Target_Hostent       => Ret.all,\n-         Target_Buffer        => Buf,\n-         Target_Buffer_Length => Buflen,\n-         Result               => Result);\n-\n-      <<Unlock_Return>>\n-      GNAT.Task_Lock.Unlock;\n-      return Result;\n-   end Safe_Gethostbyname;\n-\n-   ------------------------\n-   -- Safe_Getservbyname --\n-   ------------------------\n-\n-   function Safe_Getservbyname\n-     (Name     : C.char_array;\n-      Proto    : C.char_array;\n-      Ret      : not null access Servent;\n-      Buf      : System.Address;\n-      Buflen   : C.int) return C.int\n-   is\n-      SE     : Servent_Access;\n-      Result : C.int;\n-   begin\n-      Result := -1;\n-      GNAT.Task_Lock.Lock;\n-      SE := Nonreentrant_Getservbyname (Name, Proto);\n-\n-      if SE = null then\n-         goto Unlock_Return;\n-      end if;\n-\n-      --  Now copy the data to the user-provided buffer. We convert Ret to\n-      --  type Servent_Access using the .all'Unchecked_Access trick to avoid\n-      --  an accessibility check. Ret could be pointing to a nested variable,\n-      --  and we don't want to raise an exception in that case.\n-\n-      Copy_Service_Entry\n-        (Source_Servent       => SE,\n-         Target_Servent       => Ret.all'Unchecked_Access,\n-         Target_Buffer        => Buf,\n-         Target_Buffer_Length => Buflen,\n-         Result               => Result);\n-\n-      <<Unlock_Return>>\n-      GNAT.Task_Lock.Unlock;\n-      return Result;\n-   end Safe_Getservbyname;\n-\n-   ------------------------\n-   -- Safe_Getservbyport --\n-   ------------------------\n-\n-   function Safe_Getservbyport\n-     (Port     : C.int;\n-      Proto    : C.char_array;\n-      Ret      : not null access Servent;\n-      Buf      : System.Address;\n-      Buflen   : C.int) return C.int\n-   is\n-      SE     : Servent_Access;\n-      Result : C.int;\n-\n-   begin\n-      Result := -1;\n-      GNAT.Task_Lock.Lock;\n-      SE := Nonreentrant_Getservbyport (Port, Proto);\n-\n-      if SE = null then\n-         goto Unlock_Return;\n-      end if;\n-\n-      --  Now copy the data to the user-provided buffer. See Safe_Getservbyname\n-      --  for comment regarding .all'Unchecked_Access.\n-\n-      Copy_Service_Entry\n-        (Source_Servent       => SE,\n-         Target_Servent       => Ret.all'Unchecked_Access,\n-         Target_Buffer        => Buf,\n-         Target_Buffer_Length => Buflen,\n-         Result               => Result);\n-\n-      <<Unlock_Return>>\n-      GNAT.Task_Lock.Unlock;\n-      return Result;\n-   end Safe_Getservbyport;\n-\n-   ----------------\n-   -- Store_Name --\n-   ----------------\n-\n-   procedure Store_Name\n-     (Name          : char_array;\n-      Storage       : in out char_array;\n-      Storage_Index : in out size_t;\n-      Stored_Name   : out C.Strings.chars_ptr)\n-   is\n-      First : constant C.size_t := Storage_Index;\n-      Last  : constant C.size_t := Storage_Index + Name'Length - 1;\n-   begin\n-      Storage (First .. Last) := Name;\n-      Stored_Name := C.Strings.To_Chars_Ptr\n-                       (Storage (First .. Last)'Unrestricted_Access);\n-      Storage_Index := Last + 1;\n-   end Store_Name;\n-\n-end GNAT.Sockets.Thin.Task_Safe_NetDB;"}, {"sha": "0032d8066a1031f8aeb72f20588c6e35e12ad225", "filename": "gcc/ada/g-sttsne-locking.ads", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bca794b0df69689d0bcc6d03697f169e543dd2c/gcc%2Fada%2Fg-sttsne-locking.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bca794b0df69689d0bcc6d03697f169e543dd2c/gcc%2Fada%2Fg-sttsne-locking.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sttsne-locking.ads?ref=5bca794b0df69689d0bcc6d03697f169e543dd2c", "patch": "@@ -1,75 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---    G N A T . S O C K E T S . T H I N . T A S K _ S A F E _ N E T D B     --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---                     Copyright (C) 2007, AdaCore                          --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This version is used on VMS, LynxOS, and VxWorks. There are two versions of\n---  the body: one for VMS and LynxOS, the other for VxWorks.\n-\n---  This package should not be directly with'ed by an application\n-\n-package GNAT.Sockets.Thin.Task_Safe_NetDB is\n-\n-   ----------------------------------------\n-   -- Reentrant network databases access --\n-   ----------------------------------------\n-\n-   function Safe_Gethostbyname\n-     (Name     : C.char_array;\n-      Ret      : not null access Hostent;\n-      Buf      : System.Address;\n-      Buflen   : C.int;\n-      H_Errnop : not null access C.int) return C.int;\n-\n-   function Safe_Gethostbyaddr\n-     (Addr      : System.Address;\n-      Addr_Len  : C.int;\n-      Addr_Type : C.int;\n-      Ret       : not null access Hostent;\n-      Buf       : System.Address;\n-      Buflen    : C.int;\n-      H_Errnop  : not null access C.int) return C.int;\n-\n-   function Safe_Getservbyname\n-     (Name     : C.char_array;\n-      Proto    : C.char_array;\n-      Ret      : not null access Servent;\n-      Buf      : System.Address;\n-      Buflen   : C.int) return C.int;\n-\n-   function Safe_Getservbyport\n-     (Port     : C.int;\n-      Proto    : C.char_array;\n-      Ret      : not null access Servent;\n-      Buf      : System.Address;\n-      Buflen   : C.int) return C.int;\n-\n-end GNAT.Sockets.Thin.Task_Safe_NetDB;"}, {"sha": "a91cd873c3bd516adb4d8a62ef574e2e86eb62dc", "filename": "gcc/ada/g-sttsne-vxworks.adb", "status": "removed", "additions": 0, "deletions": 204, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bca794b0df69689d0bcc6d03697f169e543dd2c/gcc%2Fada%2Fg-sttsne-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bca794b0df69689d0bcc6d03697f169e543dd2c/gcc%2Fada%2Fg-sttsne-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sttsne-vxworks.adb?ref=5bca794b0df69689d0bcc6d03697f169e543dd2c", "patch": "@@ -1,204 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---    G N A T . S O C K E T S . T H I N . T A S K _ S A F E _ N E T D B     --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---                  Copyright (C) 2007-2008, AdaCore                        --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This version is used on VxWorks. Note that the corresponding spec is in\n---  g-sttsne-locking.ads.\n-\n-with Ada.Unchecked_Conversion;\n-with Interfaces.C; use Interfaces.C;\n-\n-package body GNAT.Sockets.Thin.Task_Safe_NetDB is\n-\n-   --  The following additional data is returned by Safe_Gethostbyname\n-   --  and Safe_Getostbyaddr in the user provided buffer.\n-\n-   type Netdb_Host_Data (Name_Length : C.size_t) is record\n-      Address   : aliased In_Addr;\n-      Addr_List : aliased In_Addr_Access_Array (0 .. 1);\n-      Name      : aliased C.char_array (0 .. Name_Length);\n-   end record;\n-\n-   Alias_Access : constant Chars_Ptr_Pointers.Pointer :=\n-                    new C.Strings.chars_ptr'(C.Strings.Null_Ptr);\n-   --  Constant used to create a Hostent record manually\n-\n-   ------------------------\n-   -- Safe_Gethostbyaddr --\n-   ------------------------\n-\n-   function Safe_Gethostbyaddr\n-     (Addr      : System.Address;\n-      Addr_Len  : C.int;\n-      Addr_Type : C.int;\n-      Ret       : not null access Hostent;\n-      Buf       : System.Address;\n-      Buflen    : C.int;\n-      H_Errnop  : not null access C.int) return C.int\n-   is\n-      type int_Access is access int;\n-      function To_Pointer is\n-        new Ada.Unchecked_Conversion (System.Address, int_Access);\n-\n-      function VxWorks_hostGetByAddr\n-        (Addr : C.int; Buf : System.Address) return C.int;\n-      pragma Import (C, VxWorks_hostGetByAddr, \"hostGetByAddr\");\n-\n-      Netdb_Data : Netdb_Host_Data (Name_Length => Max_Name_Length);\n-      pragma Import (Ada, Netdb_Data);\n-      for Netdb_Data'Address use Buf;\n-\n-   begin\n-      pragma Assert (Addr_Type = SOSC.AF_INET);\n-      pragma Assert (Addr_Len = In_Addr'Size / 8);\n-\n-      --  Check that provided buffer is sufficiently large to hold the\n-      --  data we want to return.\n-\n-      if Netdb_Data'Size / 8 > Buflen then\n-         H_Errnop.all := SOSC.ERANGE;\n-         return -1;\n-      end if;\n-\n-      if VxWorks_hostGetByAddr (To_Pointer (Addr).all,\n-                                Netdb_Data.Name'Address)\n-           /= SOSC.OK\n-      then\n-         H_Errnop.all := C.int (Host_Errno);\n-         return -1;\n-      end if;\n-\n-      Netdb_Data.Address   := To_In_Addr (To_Pointer (Addr).all);\n-      Netdb_Data.Addr_List :=\n-        (0 => Netdb_Data.Address'Unchecked_Access,\n-         1 => null);\n-\n-      Ret.H_Name      := C.Strings.To_Chars_Ptr\n-                           (Netdb_Data.Name'Unrestricted_Access);\n-      Ret.H_Aliases   := Alias_Access;\n-      Ret.H_Addrtype  := SOSC.AF_INET;\n-      Ret.H_Length    := 4;\n-      Ret.H_Addr_List :=\n-        Netdb_Data.Addr_List (Netdb_Data.Addr_List'First)'Unchecked_Access;\n-      return 0;\n-   end Safe_Gethostbyaddr;\n-\n-   ------------------------\n-   -- Safe_Gethostbyname --\n-   ------------------------\n-\n-   function Safe_Gethostbyname\n-     (Name     : C.char_array;\n-      Ret      : not null access Hostent;\n-      Buf      : System.Address;\n-      Buflen   : C.int;\n-      H_Errnop : not null access C.int) return C.int\n-   is\n-      function VxWorks_hostGetByName\n-        (Name : C.char_array) return C.int;\n-      pragma Import (C, VxWorks_hostGetByName, \"hostGetByName\");\n-\n-      Addr : C.int;\n-\n-   begin\n-      Addr := VxWorks_hostGetByName (Name);\n-      if Addr = SOSC.ERROR then\n-         H_Errnop.all := C.int (Host_Errno);\n-         return -1;\n-      end if;\n-\n-      declare\n-         Netdb_Data : Netdb_Host_Data (Name_Length => Name'Length);\n-         pragma Import (Ada, Netdb_Data);\n-         for Netdb_Data'Address use Buf;\n-\n-      begin\n-         --  Check that provided buffer is sufficiently large to hold the\n-         --  data we want to return.\n-\n-         if Netdb_Data'Size / 8 > Buflen then\n-            H_Errnop.all := SOSC.ERANGE;\n-            return -1;\n-         end if;\n-\n-         Netdb_Data.Address   := To_In_Addr (Addr);\n-         Netdb_Data.Addr_List :=\n-           (0 => Netdb_Data.Address'Unchecked_Access,\n-            1 => null);\n-         Netdb_Data.Name (Netdb_Data.Name'First .. Name'Length - 1) := Name;\n-\n-         Ret.H_Name      := C.Strings.To_Chars_Ptr\n-                              (Netdb_Data.Name'Unrestricted_Access);\n-         Ret.H_Aliases   := Alias_Access;\n-         Ret.H_Addrtype  := SOSC.AF_INET;\n-         Ret.H_Length    := 4;\n-         Ret.H_Addr_List :=\n-           Netdb_Data.Addr_List (Netdb_Data.Addr_List'First)'Unchecked_Access;\n-      end;\n-      return 0;\n-   end Safe_Gethostbyname;\n-\n-   ------------------------\n-   -- Safe_Getservbyname --\n-   ------------------------\n-\n-   function Safe_Getservbyname\n-     (Name     : C.char_array;\n-      Proto    : C.char_array;\n-      Ret      : not null access Servent;\n-      Buf      : System.Address;\n-      Buflen   : C.int) return C.int\n-   is\n-      pragma Unreferenced (Name, Proto, Ret, Buf, Buflen);\n-   begin\n-      --  Not available under VxWorks\n-      return -1;\n-   end Safe_Getservbyname;\n-\n-   ------------------------\n-   -- Safe_Getservbyport --\n-   ------------------------\n-\n-   function Safe_Getservbyport\n-     (Port     : C.int;\n-      Proto    : C.char_array;\n-      Ret      : not null access Servent;\n-      Buf      : System.Address;\n-      Buflen   : C.int) return C.int\n-   is\n-      pragma Unreferenced (Port, Proto, Ret, Buf, Buflen);\n-   begin\n-      --  Not available under VxWorks\n-      return -1;\n-   end Safe_Getservbyport;\n-\n-end GNAT.Sockets.Thin.Task_Safe_NetDB;"}, {"sha": "f438a0aea47166921ed174994ab49c97b464d577", "filename": "gcc/ada/g-sttsne.ads", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bca794b0df69689d0bcc6d03697f169e543dd2c/gcc%2Fada%2Fg-sttsne.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bca794b0df69689d0bcc6d03697f169e543dd2c/gcc%2Fada%2Fg-sttsne.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sttsne.ads?ref=5bca794b0df69689d0bcc6d03697f169e543dd2c", "patch": "@@ -1,83 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---    G N A T . S O C K E T S . T H I N . T A S K _ S A F E _ N E T D B     --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---                     Copyright (C) 2007, AdaCore                          --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package exports reentrant NetDB subprograms. This is the default\n---  version, used on most platforms. The routines are implemented by importing\n---  from C; see gsocket.h for details. Different versions are provided on\n---  platforms where this functionality is implemented in Ada.\n-\n---  This package should not be directly with'ed by an application\n-\n-package GNAT.Sockets.Thin.Task_Safe_NetDB is\n-\n-   ----------------------------------------\n-   -- Reentrant network databases access --\n-   ----------------------------------------\n-\n-   function Safe_Gethostbyname\n-     (Name     : C.char_array;\n-      Ret      : not null access Hostent;\n-      Buf      : System.Address;\n-      Buflen   : C.int;\n-      H_Errnop : not null access C.int) return C.int;\n-\n-   function Safe_Gethostbyaddr\n-     (Addr      : System.Address;\n-      Addr_Len  : C.int;\n-      Addr_Type : C.int;\n-      Ret       : not null access Hostent;\n-      Buf       : System.Address;\n-      Buflen    : C.int;\n-      H_Errnop  : not null access C.int) return C.int;\n-\n-   function Safe_Getservbyname\n-     (Name     : C.char_array;\n-      Proto    : C.char_array;\n-      Ret      : not null access Servent;\n-      Buf      : System.Address;\n-      Buflen   : C.int) return C.int;\n-\n-   function Safe_Getservbyport\n-     (Port     : C.int;\n-      Proto    : C.char_array;\n-      Ret      : not null access Servent;\n-      Buf      : System.Address;\n-      Buflen   : C.int) return C.int;\n-\n-private\n-   pragma Import (C, Safe_Gethostbyname, \"__gnat_safe_gethostbyname\");\n-   pragma Import (C, Safe_Gethostbyaddr, \"__gnat_safe_gethostbyaddr\");\n-   pragma Import (C, Safe_Getservbyname, \"__gnat_safe_getservbyname\");\n-   pragma Import (C, Safe_Getservbyport, \"__gnat_safe_getservbyport\");\n-\n-end GNAT.Sockets.Thin.Task_Safe_NetDB;"}, {"sha": "fcdb83fc816fff6fd41e8e6a2690eb838d9eff5b", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=4a214958d18269588e382f1a39c6d5612f37365c", "patch": "@@ -3385,18 +3385,19 @@ ada/sem_ch12.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/sem_elab.ads ada/sem_elim.ads ada/sem_eval.ads ada/sem_res.ads \\\n    ada/sem_scil.ads ada/sem_type.ads ada/sem_util.ads ada/sem_util.adb \\\n    ada/sem_warn.ads ada/sinfo.ads ada/sinfo.adb ada/sinfo-cn.ads \\\n-   ada/sinput.ads ada/sinput-l.ads ada/snames.ads ada/stand.ads \\\n-   ada/stringt.ads ada/style.ads ada/styleg.ads ada/styleg.adb \\\n-   ada/stylesw.ads ada/system.ads ada/s-crc32.ads ada/s-exctab.ads \\\n-   ada/s-exctab.adb ada/s-htable.ads ada/s-htable.adb ada/s-imenne.ads \\\n-   ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads \\\n-   ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n-   ada/s-stoele.ads ada/s-stoele.adb ada/s-strhas.ads ada/s-string.ads \\\n-   ada/s-traent.ads ada/s-unstyp.ads ada/s-utf_32.ads ada/s-wchcon.ads \\\n-   ada/table.ads ada/table.adb ada/targparm.ads ada/tbuild.ads \\\n-   ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads ada/types.ads \\\n-   ada/uintp.ads ada/uintp.adb ada/uname.ads ada/unchconv.ads \\\n-   ada/unchdeal.ads ada/urealp.ads ada/urealp.adb ada/widechar.ads \n+   ada/sinput.ads ada/sinput.adb ada/sinput-l.ads ada/snames.ads \\\n+   ada/stand.ads ada/stringt.ads ada/style.ads ada/styleg.ads \\\n+   ada/styleg.adb ada/stylesw.ads ada/system.ads ada/s-crc32.ads \\\n+   ada/s-exctab.ads ada/s-exctab.adb ada/s-htable.ads ada/s-htable.adb \\\n+   ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n+   ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads \\\n+   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-strhas.ads \\\n+   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-utf_32.ads \\\n+   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/targparm.ads \\\n+   ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads \\\n+   ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n+   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/urealp.adb \\\n+   ada/widechar.ads \n \n ada/sem_ch13.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\"}, {"sha": "2740d351dbb1f1cc1b4984292645e3ed61ed4d76", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 4, "deletions": 27, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=4a214958d18269588e382f1a39c6d5612f37365c", "patch": "@@ -380,16 +380,15 @@ MLIB_TGT = mlib-tgt\n # to LIBGNAT_TARGET_PAIRS.\n \n GNATRTL_SOCKETS_OBJS = g-soccon$(objext) g-socket$(objext) g-socthi$(objext) \\\n-  g-soliop$(objext) g-sothco$(objext) g-sttsne$(objext)\n+  g-soliop$(objext) g-sothco$(objext)\n \n DUMMY_SOCKETS_TARGET_PAIRS = \\\n   g-socket.adb<g-socket-dummy.adb \\\n   g-socket.ads<g-socket-dummy.ads \\\n   g-socthi.adb<g-socthi-dummy.adb \\\n   g-socthi.ads<g-socthi-dummy.ads \\\n   g-sothco.adb<g-sothco-dummy.adb \\\n-  g-sothco.ads<g-sothco-dummy.ads \\\n-  g-sttsne.ads<g-sttsne-dummy.ads\n+  g-sothco.ads<g-sothco-dummy.ads\n \n # On platform where atomic increment/decrement operations are supported\n # special version of Ada.Strings.Unbounded package can be used.\n@@ -440,8 +439,6 @@ ifeq ($(strip $(filter-out m68k% wrs vx%,$(targ))),)\n   g-socthi.ads<g-socthi-vxworks.ads \\\n   g-socthi.adb<g-socthi-vxworks.adb \\\n   g-stsifd.adb<g-stsifd-sockets.adb \\\n-  g-sttsne.adb<g-sttsne-vxworks.adb \\\n-  g-sttsne.ads<g-sttsne-locking.ads \\\n   g-trasym.ads<g-trasym-unimplemented.ads \\\n   g-trasym.adb<g-trasym-unimplemented.adb \\\n   system.ads<system-vxworks-m68k.ads\n@@ -485,8 +482,6 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworks,$(targ))),)\n   g-socthi.ads<g-socthi-vxworks.ads \\\n   g-socthi.adb<g-socthi-vxworks.adb \\\n   g-stsifd.adb<g-stsifd-sockets.adb \\\n-  g-sttsne.adb<g-sttsne-vxworks.adb \\\n-  g-sttsne.ads<g-sttsne-locking.ads \\\n   g-trasym.ads<g-trasym-unimplemented.ads \\\n   g-trasym.adb<g-trasym-unimplemented.adb \\\n   $(ATOMICS_TARGET_PAIRS)\n@@ -606,9 +601,7 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworksae,$(targ))),)\n     LIBGNAT_TARGET_PAIRS += \\\n     g-socthi.ads<g-socthi-vxworks.ads \\\n     g-socthi.adb<g-socthi-vxworks.adb \\\n-    g-stsifd.adb<g-stsifd-sockets.adb \\\n-    g-sttsne.adb<g-sttsne-vxworks.adb \\\n-    g-sttsne.ads<g-sttsne-locking.ads\n+    g-stsifd.adb<g-stsifd-sockets.adb\n   endif\n \n   ifeq ($(strip $(filter-out yes,$(TRACE))),)\n@@ -724,9 +717,7 @@ ifeq ($(strip $(filter-out %86 wrs vxworksae vxworksmils,$(targ))),)\n     LIBGNAT_TARGET_PAIRS += \\\n     g-socthi.ads<g-socthi-vxworks.ads \\\n     g-socthi.adb<g-socthi-vxworks.adb \\\n-    g-stsifd.adb<g-stsifd-sockets.adb \\\n-    g-sttsne.adb<g-sttsne-vxworks.adb \\\n-    g-sttsne.ads<g-sttsne-locking.ads\n+    g-stsifd.adb<g-stsifd-sockets.adb\n   endif\n \n   ifeq ($(strip $(filter-out yes,$(TRACE))),)\n@@ -762,8 +753,6 @@ ifeq ($(strip $(filter-out sparc% wrs vx%,$(targ))),)\n   g-socthi.ads<g-socthi-vxworks.ads \\\n   g-socthi.adb<g-socthi-vxworks.adb \\\n   g-stsifd.adb<g-stsifd-sockets.adb \\\n-  g-sttsne.adb<g-sttsne-vxworks.adb \\\n-  g-sttsne.ads<g-sttsne-locking.ads \\\n   g-trasym.ads<g-trasym-unimplemented.ads \\\n   g-trasym.adb<g-trasym-unimplemented.adb \\\n   system.ads<system-vxworks-sparcv9.ads   \\\n@@ -803,8 +792,6 @@ ifeq ($(strip $(filter-out %86 wrs vxworks,$(targ))),)\n   g-socthi.ads<g-socthi-vxworks.ads \\\n   g-socthi.adb<g-socthi-vxworks.adb \\\n   g-stsifd.adb<g-stsifd-sockets.adb \\\n-  g-sttsne.adb<g-sttsne-vxworks.adb \\\n-  g-sttsne.ads<g-sttsne-locking.ads \\\n   g-trasym.ads<g-trasym-unimplemented.ads \\\n   g-trasym.adb<g-trasym-unimplemented.adb\n \n@@ -896,8 +883,6 @@ ifeq ($(strip $(filter-out arm% coff wrs vx%,$(targ))),)\n   g-socthi.ads<g-socthi-vxworks.ads \\\n   g-socthi.adb<g-socthi-vxworks.adb \\\n   g-stsifd.adb<g-stsifd-sockets.adb \\\n-  g-sttsne.adb<g-sttsne-vxworks.adb \\\n-  g-sttsne.ads<g-sttsne-locking.ads \\\n   g-trasym.ads<g-trasym-unimplemented.ads \\\n   g-trasym.adb<g-trasym-unimplemented.adb \\\n   system.ads<system-vxworks-arm.ads\n@@ -936,8 +921,6 @@ ifeq ($(strip $(filter-out mips% wrs vx%,$(targ))),)\n   g-socthi.ads<g-socthi-vxworks.ads \\\n   g-socthi.adb<g-socthi-vxworks.adb \\\n   g-stsifd.adb<g-stsifd-sockets.adb \\\n-  g-sttsne.adb<g-sttsne-vxworks.adb \\\n-  g-sttsne.ads<g-sttsne-locking.ads \\\n   g-trasym.ads<g-trasym-unimplemented.ads \\\n   g-trasym.adb<g-trasym-unimplemented.adb \\\n   system.ads<system-vxworks-mips.ads\n@@ -1398,8 +1381,6 @@ ifeq ($(strip $(filter-out lynxos,$(osys))),)\n     a-numaux.ads<a-numaux-x86.ads \\\n     a-intnam.ads<a-intnam-lynxos.ads \\\n     g-bytswa.adb<g-bytswa-x86.adb \\\n-    g-sttsne.adb<g-sttsne-locking.adb \\\n-    g-sttsne.ads<g-sttsne-locking.ads \\\n     s-inmaop.adb<s-inmaop-posix.adb \\\n     s-intman.adb<s-intman-posix.adb \\\n     s-osinte.adb<s-osinte-lynxos.adb \\\n@@ -1416,8 +1397,6 @@ ifeq ($(strip $(filter-out lynxos,$(osys))),)\n   else\n     LIBGNAT_TARGET_PAIRS = \\\n     a-intnam.ads<a-intnam-lynxos.ads \\\n-    g-sttsne.adb<g-sttsne-locking.adb \\\n-    g-sttsne.ads<g-sttsne-locking.ads \\\n     s-inmaop.adb<s-inmaop-posix.adb \\\n     s-intman.adb<s-intman-posix.adb \\\n     s-osinte.adb<s-osinte-lynxos.adb \\\n@@ -1543,8 +1522,6 @@ ifeq ($(strip $(filter-out alpha64 ia64 dec hp vms% openvms% alphavms%,$(targ)))\n     g-socthi.ads<g-socthi-vms.ads \\\n     g-socthi.adb<g-socthi-vms.adb \\\n     g-stsifd.adb<g-stsifd-sockets.adb \\\n-    g-sttsne.adb<g-sttsne-locking.adb \\\n-    g-sttsne.ads<g-sttsne-locking.ads \\\n     i-c.ads<i-c-vms_64.ads \\\n     i-cstrin.ads<i-cstrin-vms_64.ads \\\n     i-cstrin.adb<i-cstrin-vms_64.adb \\"}, {"sha": "10cf3458ebfa669988bf99da2d0cb07de7bdbe76", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=4a214958d18269588e382f1a39c6d5612f37365c", "patch": "@@ -232,6 +232,11 @@ procedure GNATCmd is\n    --  STUB), gnatpp (GNAT PRETTY), gnatelim (GNAT ELIM), and gnatmetric (GNAT\n    --  METRIC).\n \n+   function Mapping_File return Path_Name_Type;\n+   --  Create and return the path name of a mapping file. Used for gnatstub\n+   --  (GNAT STUB), gnatpp (GNAT PRETTY), gnatelim (GNAT ELIM), and gnatmetric\n+   --  (GNAT METRIC).\n+\n    procedure Delete_Temp_Config_Files;\n    --  Delete all temporary config files. The caller is responsible for\n    --  ensuring that Keep_Temporary_Files is False.\n@@ -889,6 +894,22 @@ procedure GNATCmd is\n       return 0;\n    end Index;\n \n+   ------------------\n+   -- Mapping_File --\n+   ------------------\n+\n+   function Mapping_File return Path_Name_Type is\n+      Result : Path_Name_Type;\n+\n+   begin\n+      Prj.Env.Create_Mapping_File\n+        (Project  => Project,\n+         Language => Name_Ada,\n+         In_Tree  => Project_Tree,\n+         Name     => Result);\n+      return Result;\n+   end Mapping_File;\n+\n    ------------------\n    -- Process_Link --\n    ------------------\n@@ -2156,6 +2177,7 @@ begin\n \n             declare\n                CP_File : constant Path_Name_Type := Configuration_Pragmas_File;\n+               M_File  : constant Path_Name_Type := Mapping_File;\n \n             begin\n                if CP_File /= No_Path then\n@@ -2169,6 +2191,11 @@ begin\n                        (new String'(\"-gnatec=\" & Get_Name_String (CP_File)));\n                   end if;\n                end if;\n+\n+               if M_File /= No_Path then\n+                  Add_To_Carg_Switches\n+                    (new String'(\"-gnatem=\" & Get_Name_String (M_File)));\n+               end if;\n             end;\n          end if;\n "}, {"sha": "7763b1801de5893fb8bf6904a394cb3da49374e0", "filename": "gcc/ada/gsocket.h", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2Fgsocket.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2Fgsocket.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgsocket.h?ref=4a214958d18269588e382f1a39c6d5612f37365c", "patch": "@@ -194,34 +194,37 @@\n #include <netdb.h>\n #endif\n \n-/*\n- * Handling of gethostbyname, gethostbyaddr, getservbyname and getservbyport\n- * =========================================================================\n- *\n- * The default implementation of GNAT.Sockets.Thin requires that these\n- * operations be either thread safe, or that a reentrant version getXXXbyYYY_r\n- * be provided. In both cases, socket.c provides a __gnat_safe_getXXXbyYYY\n- * function with the same signature as getXXXbyYYY_r. If the operating\n- * system version of getXXXbyYYY is thread safe, the provided auxiliary\n- * buffer argument is unused and ignored.\n- *\n- * Target specific versions of GNAT.Sockets.Thin for platforms that can't\n- * fulfill these requirements must provide their own protection mechanism\n- * in Safe_GetXXXbyYYY, and if they require GNAT.Sockets to provide a buffer\n- * to this effect, then we need to set Need_Netdb_Buffer here (case of\n- * VxWorks and VMS).\n- */\n-\n-#if defined (_AIX) || defined (__FreeBSD__) || defined (__hpux__) || defined (__osf__) || defined (_WIN32) || defined (__APPLE__)\n+#if defined (_AIX) || defined (__FreeBSD__) || defined (__hpux__) || \\\n+    defined (__osf__) || defined (_WIN32) || defined (__APPLE__)\n # define HAVE_THREAD_SAFE_GETxxxBYyyy 1\n-#elif defined (sgi) || defined (linux) || defined (__GLIBC__) || (defined (sun) && defined (__SVR4) && !defined (__vxworks)) || defined(__rtems__)\n+\n+#elif defined (sgi) || defined (linux) || defined (__GLIBC__) || \\\n+     (defined (sun) && defined (__SVR4) && !defined (__vxworks)) || \\\n+      defined(__rtems__)\n # define HAVE_GETxxxBYyyy_R 1\n #endif\n \n-#if defined (HAVE_GETxxxBYyyy_R) || !defined (HAVE_THREAD_SAFE_GETxxxBYyyy)\n+/*\n+ * Properties of the unerlying NetDB library:\n+ *   Need_Netdb_Buffer __gnat_getXXXbyYYY expects a caller-supplied buffer\n+ *   Need_Netdb_Lock   __gnat_getXXXbyYYY expects the caller to ensure\n+ *                     mutual exclusion\n+ *\n+ * See \"Handling of gethostbyname, gethostbyaddr, getservbyname and\n+ * getservbyport\" in socket.c for details.\n+ */\n+\n+#if defined (HAVE_GETxxxBYyyy_R)\n # define Need_Netdb_Buffer 1\n+# define Need_Netdb_Lock 0\n+\n #else\n # define Need_Netdb_Buffer 0\n+# if !defined (HAVE_THREAD_SAFE_GETxxxBYyyy)\n+#  define Need_Netdb_Lock 1\n+# else\n+#  define Need_Netdb_Lock 0\n+# endif\n #endif\n \n #if defined (__FreeBSD__) || defined (__vxworks) || defined(__rtems__)"}, {"sha": "7e34a74b611b93154f1cadaa99f52661c6e23be1", "filename": "gcc/ada/s-oscons-tmplt.c", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2Fs-oscons-tmplt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2Fs-oscons-tmplt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-oscons-tmplt.c?ref=4a214958d18269588e382f1a39c6d5612f37365c", "patch": "@@ -1231,24 +1231,11 @@ CND(SIZEOF_sockaddr_in6, \"struct sockaddr_in6\")\n #define SIZEOF_fd_set (sizeof (fd_set))\n CND(SIZEOF_fd_set, \"fd_set\");\n \n+#define SIZEOF_struct_hostent (sizeof (struct hostent))\n+CND(SIZEOF_struct_hostent, \"struct hostent\");\n+\n #define SIZEOF_struct_servent (sizeof (struct servent))\n CND(SIZEOF_struct_servent, \"struct servent\");\n-/*\n-\n-   --  Fields of struct hostent\n-*/\n-\n-#ifdef __MINGW32__\n-# define h_addrtype_t \"short\"\n-# define h_length_t   \"short\"\n-#else\n-# define h_addrtype_t \"int\"\n-# define h_length_t   \"int\"\n-#endif\n-\n-TXT(\"   subtype H_Addrtype_T is Interfaces.C.\" h_addrtype_t \";\")\n-TXT(\"   subtype H_Length_T   is Interfaces.C.\" h_length_t \";\")\n-\n /*\n \n    --  Fields of struct msghdr\n@@ -1271,6 +1258,7 @@ TXT(\"   subtype Msg_Iovlen_T is Interfaces.C.\" msg_iovlen_t \";\")\n */\n \n CND(Need_Netdb_Buffer, \"Need buffer for Netdb ops\")\n+CND(Need_Netdb_Lock,   \"Need lock for Netdb ops\")\n CND(Has_Sockaddr_Len,  \"Sockaddr has sa_len field\")\n \n /**"}, {"sha": "d1a69740379530d88dfda037f8af4b8890eb716a", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=4a214958d18269588e382f1a39c6d5612f37365c", "patch": "@@ -11283,6 +11283,7 @@ package body Sem_Ch3 is\n       Set_Is_Public                  (Full, Is_Public               (Priv));\n       Set_Is_Pure                    (Full, Is_Pure                 (Priv));\n       Set_Is_Tagged_Type             (Full, Is_Tagged_Type          (Priv));\n+      Set_Has_Pragma_Unmodified      (Full, Has_Pragma_Unmodified   (Priv));\n       Set_Has_Pragma_Unreferenced    (Full, Has_Pragma_Unreferenced (Priv));\n       Set_Has_Pragma_Unreferenced_Objects\n                                      (Full, Has_Pragma_Unreferenced_Objects\n@@ -11318,10 +11319,10 @@ package body Sem_Ch3 is\n             Access_Types_To_Process (Freeze_Node (Priv)));\n       end if;\n \n-      --  Swap the two entities. Now Privat is the full type entity and\n-      --  Full is the private one. They will be swapped back at the end\n-      --  of the private part. This swapping ensures that the entity that\n-      --  is visible in the private part is the full declaration.\n+      --  Swap the two entities. Now Privat is the full type entity and Full is\n+      --  the private one. They will be swapped back at the end of the private\n+      --  part. This swapping ensures that the entity that is visible in the\n+      --  private part is the full declaration.\n \n       Exchange_Entities (Priv, Full);\n       Append_Entity (Full, Scope (Full));\n@@ -12810,13 +12811,12 @@ package body Sem_Ch3 is\n             if Need_Search\n               or else\n                 (Present (Generic_Actual)\n-                   and then Present (Act_Subp)\n-                   and then not Primitive_Names_Match (Subp, Act_Subp))\n+                  and then Present (Act_Subp)\n+                  and then not Primitive_Names_Match (Subp, Act_Subp))\n             then\n                pragma Assert (not Is_Ancestor (Parent_Base, Generic_Actual));\n \n-               --  Remember that we need searching for all the pending\n-               --  primitives\n+               --  Remember that we need searching for all pending primitives\n \n                Need_Search := True;\n \n@@ -12840,8 +12840,9 @@ package body Sem_Ch3 is\n                      Act_Subp := Node (Act_Elmt);\n \n                      exit when Primitive_Names_Match (Subp, Act_Subp)\n-                       and then Type_Conformant (Subp, Act_Subp,\n-                                  Skip_Controlling_Formals => True)\n+                       and then Type_Conformant\n+                                  (Subp, Act_Subp,\n+                                   Skip_Controlling_Formals => True)\n                        and then No (Interface_Alias (Act_Subp));\n \n                      Next_Elmt (Act_Elmt);\n@@ -12870,7 +12871,7 @@ package body Sem_Ch3 is\n               and then Is_Interface (Find_Dispatching_Type (Alias_Subp))\n               and then not\n                 (Nkind (Parent (Alias_Subp)) = N_Procedure_Specification\n-                   and then Null_Present (Parent (Alias_Subp)))\n+                  and then Null_Present (Parent (Alias_Subp)))\n             then\n                Derive_Subprogram\n                  (New_Subp     => New_Subp,"}, {"sha": "ca5b18ad77cd0fa86fb99eda3fc9d2ea90181555", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=4a214958d18269588e382f1a39c6d5612f37365c", "patch": "@@ -1954,6 +1954,7 @@ package body Sem_Ch7 is\n          Set_Is_Volatile             (Priv, Is_Volatile                (Full));\n          Set_Treat_As_Volatile       (Priv, Treat_As_Volatile          (Full));\n          Set_Is_Ada_2005_Only        (Priv, Is_Ada_2005_Only           (Full));\n+         Set_Has_Pragma_Unmodified   (Priv, Has_Pragma_Unmodified      (Full));\n          Set_Has_Pragma_Unreferenced (Priv, Has_Pragma_Unreferenced    (Full));\n          Set_Has_Pragma_Unreferenced_Objects\n                                      (Priv, Has_Pragma_Unreferenced_Objects\n@@ -2032,6 +2033,7 @@ package body Sem_Ch7 is\n             end if;\n \n             Set_Has_Discriminants (Priv, Has_Discriminants (Full));\n+\n             if Has_Discriminants (Full) then\n                Set_Discriminant_Constraint (Priv,\n                  Discriminant_Constraint (Full));"}, {"sha": "ad7224308906e374f83508d77fde22aea73ff4d0", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 47, "deletions": 11, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=4a214958d18269588e382f1a39c6d5612f37365c", "patch": "@@ -3426,33 +3426,47 @@ package body Sem_Ch8 is\n    ------------------\n \n    procedure End_Use_Type (N : Node_Id) is\n+      Elmt    : Elmt_Id;\n       Id      : Entity_Id;\n       Op_List : Elist_Id;\n-      Elmt    : Elmt_Id;\n+      Op      : Entity_Id;\n       T       : Entity_Id;\n \n+      function May_Be_Used_Primitive_Of (T : Entity_Id) return Boolean;\n+      --  An operator may be primitive in several types, if they are declared\n+      --  in the same scope as the operator. To determine the use-visiblity of\n+      --  the operator in such cases we must examine all types in the profile.\n+\n+      ------------------------------\n+      -- May_Be_Used_Primitive_Of --\n+      ------------------------------\n+\n+      function May_Be_Used_Primitive_Of (T : Entity_Id) return Boolean is\n+      begin\n+         return Scope (Op) = Scope (T)\n+           and then (In_Use (T) or else Is_Potentially_Use_Visible (T));\n+      end May_Be_Used_Primitive_Of;\n+\n+   --  Start of processing for End_Use_Type\n+\n    begin\n       Id := First (Subtype_Marks (N));\n       while Present (Id) loop\n \n-         --  A call to rtsfind may occur while analyzing a use_type clause,\n+         --  A call to Rtsfind may occur while analyzing a use_type clause,\n          --  in which case the type marks are not resolved yet, and there is\n          --  nothing to remove.\n \n-         if not Is_Entity_Name (Id)\n-           or else No (Entity (Id))\n-         then\n+         if not Is_Entity_Name (Id) or else No (Entity (Id)) then\n             goto Continue;\n          end if;\n \n          T := Entity (Id);\n \n-         if T = Any_Type\n-           or else From_With_Type (T)\n-         then\n+         if T = Any_Type or else From_With_Type (T) then\n             null;\n \n-         --  Note that the use_Type clause may mention a subtype of the type\n+         --  Note that the use_type clause may mention a subtype of the type\n          --  whose primitive operations have been made visible. Here as\n          --  elsewhere, it is the base type that matters for visibility.\n \n@@ -3468,8 +3482,30 @@ package body Sem_Ch8 is\n \n             Elmt := First_Elmt (Op_List);\n             while Present (Elmt) loop\n-               if Nkind (Node (Elmt)) = N_Defining_Operator_Symbol then\n-                  Set_Is_Potentially_Use_Visible (Node (Elmt), False);\n+               Op := Node (Elmt);\n+\n+               if Nkind (Op) = N_Defining_Operator_Symbol then\n+                  declare\n+                     T_First : constant Entity_Id :=\n+                                 Base_Type (Etype (First_Formal (Op)));\n+                     T_Res   : constant Entity_Id := Base_Type (Etype (Op));\n+                     T_Next  : Entity_Id;\n+\n+                  begin\n+                     if Present (Next_Formal (First_Formal (Op))) then\n+                        T_Next :=\n+                          Base_Type (Etype (Next_Formal (First_Formal (Op))));\n+                     else\n+                        T_Next := T_First;\n+                     end if;\n+\n+                     if not May_Be_Used_Primitive_Of (T_First)\n+                       and then not May_Be_Used_Primitive_Of (T_Next)\n+                       and then not May_Be_Used_Primitive_Of (T_Res)\n+                     then\n+                        Set_Is_Potentially_Use_Visible (Op, False);\n+                     end if;\n+                  end;\n                end if;\n \n                Next_Elmt (Elmt);"}, {"sha": "d03ddea8164a6b16d6b93ce6682ffa79057389b1", "filename": "gcc/ada/socket.c", "status": "modified", "additions": 215, "deletions": 113, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2Fsocket.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a214958d18269588e382f1a39c6d5612f37365c/gcc%2Fada%2Fsocket.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsocket.c?ref=4a214958d18269588e382f1a39c6d5612f37365c", "patch": "@@ -32,6 +32,7 @@\n /*  This file provides a portable binding to the sockets API                */\n \n #include \"gsocket.h\"\n+\n #ifdef VMS\n /*\n  * For VMS, gsocket.h can't include sockets-related DEC C header files\n@@ -42,16 +43,41 @@\n # include \"s-oscons.h\"\n \n /*\n- * We also need the declaration of struct servent, which s-oscons can't\n- * provide, so we copy it manually here. This needs to be kept in synch\n+ * We also need the declaration of struct hostent/servent, which s-oscons\n+ * can't provide, so we copy it manually here. This needs to be kept in synch\n  * with the definition of that structure in the DEC C headers, which\n  * hopefully won't change frequently.\n  */\n+typedef char *__netdb_char_ptr __attribute__ (( mode (SI) ));\n+typedef __netdb_char_ptr *__netdb_char_ptr_ptr __attribute__ (( mode (SI) ));\n+# define NEED_STRUCT_xxxENT\n+\n+#elif defined (__vxworks)\n+/*\n+ * For VxWorks we emulate getXXXbyYYY using the proprietary VxWorks API.\n+ */\n+typedef char *__netdb_char_ptr;\n+typedef __netdb_char_ptr *__netdb_char_ptr_ptr;\n+# define NEED_STRUCT_xxxENT\n+\n+#else\n+# undef NEED_STRUCT_xxxENT\n+#endif\n+\n+#ifdef NEED_STRUCT_xxxENT\n+struct hostent {\n+  __netdb_char_ptr     h_name;\n+  __netdb_char_ptr_ptr h_aliases;\n+  int                  h_addrtype;\n+  int                  h_length;\n+  __netdb_char_ptr_ptr h_addr_list;\n+};\n+\n struct servent {\n-  char *s_name;     /* official service name */\n-  char **s_aliases; /* alias list */\n-  int  s_port;      /* port # */\n-  char *s_proto;    /* protocol to use */\n+  __netdb_char_ptr     s_name;\n+  __netdb_char_ptr_ptr s_aliases;\n+  int                  s_port;\n+  __netdb_char_ptr     s_proto;\n };\n #endif\n \n@@ -87,14 +113,18 @@ extern void __gnat_remove_socket_from_set (fd_set *, int);\n extern void __gnat_reset_socket_set (fd_set *);\n extern int  __gnat_get_h_errno (void);\n extern int  __gnat_socket_ioctl (int, int, int *);\n+\n extern char * __gnat_servent_s_name (struct servent *);\n-extern char ** __gnat_servent_s_aliases (struct servent *);\n-extern int __gnat_servent_s_port (struct servent *);\n+extern char * __gnat_servent_s_alias (struct servent *, int index);\n+extern unsigned short __gnat_servent_s_port (struct servent *);\n extern char * __gnat_servent_s_proto (struct servent *);\n-extern void __gnat_servent_set_s_name (struct servent *, char *);\n-extern void __gnat_servent_set_s_aliases (struct servent *, char **);\n-extern void __gnat_servent_set_s_port (struct servent *, int);\n-extern void __gnat_servent_set_s_proto (struct servent *, char *);\n+\n+extern char * __gnat_hostent_h_name (struct hostent *);\n+extern char * __gnat_hostent_h_alias (struct hostent *, int);\n+extern int __gnat_hostent_h_addrtype (struct hostent *);\n+extern int __gnat_hostent_h_length (struct hostent *);\n+extern char * __gnat_hostent_h_addr (struct hostent *, int);\n+\n #if defined (__vxworks) || defined (_WIN32)\n extern int  __gnat_inet_pton (int, const char *, void *);\n #endif\n@@ -164,76 +194,28 @@ __gnat_close_signalling_fd (int sig) {\n #endif\n \f\n /*\n- * GetXXXbyYYY wrappers\n- * These functions are used by the default implementation of g-socthi,\n- * and also by the Windows version.\n+ * Handling of gethostbyname, gethostbyaddr, getservbyname and getservbyport\n+ * =========================================================================\n+ *\n+ * This module exposes __gnat_getXXXbyYYY operations with the same signature\n+ * as the reentrant variant getXXXbyYYY_r.\n+ *\n+ * On platforms where getXXXbyYYY is intrinsically reentrant, the provided user\n+ * buffer argument is ignored.\n  *\n- * They can be used for any platform that either provides an intrinsically\n- * task safe implementation of getXXXbyYYY, or a reentrant variant\n- * getXXXbyYYY_r. Otherwise, a task safe wrapper, including proper mutual\n- * exclusion if appropriate, must be implemented in the target specific\n- * version of g-socthi.\n+ * When getXXXbyYYY is not reentrant but getXXXbyYYY_r exists, the latter is\n+ * used, and the provided buffer argument must point to a valid, thread-local\n+ * buffer (usually on the caller's stack).\n+ *\n+ * When getXXXbyYYY is not reentrant and no reentrant getXXXbyYYY_r variant\n+ * is available, the non-reentrant getXXXbyYYY is called, the provided user\n+ * buffer is ignored, and the caller is expected to take care of mutual\n+ * exclusion.\n  */\n \n-#ifdef HAVE_THREAD_SAFE_GETxxxBYyyy\n-int\n-__gnat_safe_gethostbyname (const char *name,\n-  struct hostent *ret, char *buf, size_t buflen,\n-  int *h_errnop)\n-{\n-  struct hostent *rh;\n-  rh = gethostbyname (name);\n-  if (rh == NULL) {\n-    *h_errnop = h_errno;\n-    return -1;\n-  }\n-  *ret = *rh;\n-  *h_errnop = 0;\n-  return 0;\n-}\n-\n-int\n-__gnat_safe_gethostbyaddr (const char *addr, int len, int type,\n-  struct hostent *ret, char *buf, size_t buflen,\n-  int *h_errnop)\n-{\n-  struct hostent *rh;\n-  rh = gethostbyaddr (addr, len, type);\n-  if (rh == NULL) {\n-    *h_errnop = h_errno;\n-    return -1;\n-  }\n-  *ret = *rh;\n-  *h_errnop = 0;\n-  return 0;\n-}\n-\n-int\n-__gnat_safe_getservbyname (const char *name, const char *proto,\n-  struct servent *ret, char *buf, size_t buflen)\n-{\n-  struct servent *rh;\n-  rh = getservbyname (name, proto);\n-  if (rh == NULL)\n-    return -1;\n-  *ret = *rh;\n-  return 0;\n-}\n-\n+#ifdef HAVE_GETxxxBYyyy_R\n int\n-__gnat_safe_getservbyport (int port, const char *proto,\n-  struct servent *ret, char *buf, size_t buflen)\n-{\n-  struct servent *rh;\n-  rh = getservbyport (port, proto);\n-  if (rh == NULL)\n-    return -1;\n-  *ret = *rh;\n-  return 0;\n-}\n-#elif HAVE_GETxxxBYyyy_R\n-int\n-__gnat_safe_gethostbyname (const char *name,\n+__gnat_gethostbyname (const char *name,\n   struct hostent *ret, char *buf, size_t buflen,\n   int *h_errnop)\n {\n@@ -250,7 +232,7 @@ __gnat_safe_gethostbyname (const char *name,\n }\n \n int\n-__gnat_safe_gethostbyaddr (const char *addr, int len, int type,\n+__gnat_gethostbyaddr (const char *addr, int len, int type,\n   struct hostent *ret, char *buf, size_t buflen,\n   int *h_errnop)\n {\n@@ -267,7 +249,7 @@ __gnat_safe_gethostbyaddr (const char *addr, int len, int type,\n }\n \n int\n-__gnat_safe_getservbyname (const char *name, const char *proto,\n+__gnat_getservbyname (const char *name, const char *proto,\n   struct servent *ret, char *buf, size_t buflen)\n {\n   struct servent *rh;\n@@ -283,7 +265,7 @@ __gnat_safe_getservbyname (const char *name, const char *proto,\n }\n \n int\n-__gnat_safe_getservbyport (int port, const char *proto,\n+__gnat_getservbyport (int port, const char *proto,\n   struct servent *ret, char *buf, size_t buflen)\n {\n   struct servent *rh;\n@@ -297,6 +279,130 @@ __gnat_safe_getservbyport (int port, const char *proto,\n   ri = (rh == NULL) ? -1 : 0;\n   return ri;\n }\n+#elif defined (__vxworks)\n+static char vxw_h_name[MAXHOSTNAMELEN + 1];\n+static char *vxw_h_aliases[1] = { NULL };\n+static int vxw_h_addr;\n+static char *vxw_h_addr_list[2] = { (char*) &vxw_h_addr, NULL };\n+\n+int\n+__gnat_gethostbyname (const char *name,\n+  struct hostent *ret, char *buf, size_t buflen,\n+  int *h_errnop)\n+{\n+  vxw_h_addr = hostGetByName (name);\n+  if (vxw_h_addr == ERROR) {\n+    *h_errnop = __gnat_get_h_errno ();\n+    return -1;\n+  }\n+  ret->h_name      = name;\n+  ret->h_aliases   = &vxw_h_aliases;\n+  ret->h_addrtype  = AF_INET;\n+  ret->h_length    = 4;\n+  ret->h_addr_list = &vxw_h_addr_list;\n+  return 0;\n+}\n+\n+int\n+__gnat_gethostbyaddr (const char *addr, int len, int type,\n+  struct hostent *ret, char *buf, size_t buflen,\n+  int *h_errnop)\n+{\n+  if (type != AF_INET) {\n+    *h_errnop = EAFNOSUPPORT;\n+    return -1;\n+  }\n+\n+  if (addr == NULL || len != 4) {\n+    *h_errnop = EINVAL;\n+    return -1;\n+  }\n+\n+  if (hostGetByAddr (*(int*)addr, &vxw_h_name) != OK) {\n+    *h_errnop = __gnat_get_h_errno ();\n+    return -1;\n+  }\n+\n+  vxw_h_addr       = addr;\n+\n+  ret->h_name      = &vxw_h_name;\n+  ret->h_aliases   = &vxw_h_aliases;\n+  ret->h_addrtype  = AF_INET;\n+  ret->h_length    = 4;\n+  ret->h_addr_list = &vxw_h_addr_list;\n+}\n+\n+int\n+__gnat_getservbyname (const char *name, const char *proto,\n+  struct servent *ret, char *buf, size_t buflen)\n+{\n+  /* Not available under VxWorks */\n+  return -1;\n+}\n+\n+int\n+__gnat_getservbyport (int port, const char *proto,\n+  struct servent *ret, char *buf, size_t buflen)\n+{\n+  /* Not available under VxWorks */\n+  return -1;\n+}\n+#else\n+int\n+__gnat_gethostbyname (const char *name,\n+  struct hostent *ret, char *buf, size_t buflen,\n+  int *h_errnop)\n+{\n+  struct hostent *rh;\n+  rh = gethostbyname (name);\n+  if (rh == NULL) {\n+    *h_errnop = __gnat_get_h_errno ();\n+    return -1;\n+  }\n+  *ret = *rh;\n+  *h_errnop = 0;\n+  return 0;\n+}\n+\n+int\n+__gnat_gethostbyaddr (const char *addr, int len, int type,\n+  struct hostent *ret, char *buf, size_t buflen,\n+  int *h_errnop)\n+{\n+  struct hostent *rh;\n+  rh = gethostbyaddr (addr, len, type);\n+  if (rh == NULL) {\n+    *h_errnop = __gnat_get_h_errno ();\n+    return -1;\n+  }\n+  *ret = *rh;\n+  *h_errnop = 0;\n+  return 0;\n+}\n+\n+int\n+__gnat_getservbyname (const char *name, const char *proto,\n+  struct servent *ret, char *buf, size_t buflen)\n+{\n+  struct servent *rh;\n+  rh = getservbyname (name, proto);\n+  if (rh == NULL)\n+    return -1;\n+  *ret = *rh;\n+  return 0;\n+}\n+\n+int\n+__gnat_getservbyport (int port, const char *proto,\n+  struct servent *ret, char *buf, size_t buflen)\n+{\n+  struct servent *rh;\n+  rh = getservbyport (port, proto);\n+  if (rh == NULL)\n+    return -1;\n+  *ret = *rh;\n+  return 0;\n+}\n #endif\n \f\n /* Find the largest socket in the socket set SET. This is needed for\n@@ -509,6 +615,30 @@ __gnat_inet_pton (int af, const char *src, void *dst) {\n }\n #endif\n \n+/*\n+ * Accessor functions for struct hostent.\n+ */\n+\n+char * __gnat_hostent_h_name (struct hostent * h) {\n+  return h->h_name;\n+}\n+\n+char * __gnat_hostent_h_alias (struct hostent * h, int index) {\n+  return h->h_aliases[index];\n+}\n+\n+int __gnat_hostent_h_addrtype (struct hostent * h) {\n+  return h->h_addrtype;\n+}\n+\n+int __gnat_hostent_h_length (struct hostent * h) {\n+  return h->h_length;\n+}\n+\n+char * __gnat_hostent_h_addr (struct hostent * h, int index) {\n+  return h->h_addr_list[index];\n+}\n+\n /*\n  * Accessor functions for struct servent.\n  *\n@@ -539,21 +669,19 @@ __gnat_inet_pton (int af, const char *src, void *dst) {\n  *   };\n  */\n \n-/* Getters */\n-\n char *\n __gnat_servent_s_name (struct servent * s)\n {\n   return s->s_name;\n }\n \n-char **\n-__gnat_servent_s_aliases (struct servent * s)\n+char *\n+__gnat_servent_s_alias (struct servent * s, int index)\n {\n-  return s->s_aliases;\n+  return s->s_aliases[index];\n }\n \n-int\n+unsigned short\n __gnat_servent_s_port (struct servent * s)\n {\n   return s->s_port;\n@@ -565,32 +693,6 @@ __gnat_servent_s_proto (struct servent * s)\n   return s->s_proto;\n }\n \n-/* Setters */\n-\n-void\n-__gnat_servent_set_s_name (struct servent * s, char * s_name)\n-{\n-  s->s_name = s_name;\n-}\n-\n-void\n-__gnat_servent_set_s_aliases (struct servent * s, char ** s_aliases)\n-{\n-  s->s_aliases = s_aliases;\n-}\n-\n-void\n-__gnat_servent_set_s_port (struct servent * s, int s_port)\n-{\n-  s->s_port = s_port;\n-}\n-\n-void\n-__gnat_servent_set_s_proto (struct servent * s, char * s_proto)\n-{\n-  s->s_proto = s_proto;\n-}\n-\n #else\n # warning Sockets are not supported on this platform\n #endif /* defined(HAVE_SOCKETS) */"}]}