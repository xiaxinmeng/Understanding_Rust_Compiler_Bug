{"sha": "8ea456b94ac356fd36ba7043195a2d6c65eebfa7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGVhNDU2Yjk0YWMzNTZmZDM2YmE3MDQzMTk1YTJkNmM2NWVlYmZhNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-02-29T09:30:09Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-02-29T09:30:09Z"}, "message": "decl.c (gnat_to_gnu_entity): Retrofit handling of unconstrained array types as designated types into common...\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Access_Type>: Retrofit\n\thandling of unconstrained array types as designated types into common\n\tprocessing.  Also handle array types as incomplete designated types.\n\nFrom-SVN: r233807", "tree": {"sha": "481c26d43400bc16ac47441069e21c886bb804a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/481c26d43400bc16ac47441069e21c886bb804a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ea456b94ac356fd36ba7043195a2d6c65eebfa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ea456b94ac356fd36ba7043195a2d6c65eebfa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ea456b94ac356fd36ba7043195a2d6c65eebfa7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ea456b94ac356fd36ba7043195a2d6c65eebfa7/comments", "author": null, "committer": null, "parents": [{"sha": "68ec5613422d80f61d93d493de42397b05f886f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68ec5613422d80f61d93d493de42397b05f886f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68ec5613422d80f61d93d493de42397b05f886f6"}], "stats": {"total": 99, "additions": 48, "deletions": 51}, "files": [{"sha": "cda8be6e122c5fe2c595de9df4ad3c588d46ff3c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ea456b94ac356fd36ba7043195a2d6c65eebfa7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ea456b94ac356fd36ba7043195a2d6c65eebfa7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8ea456b94ac356fd36ba7043195a2d6c65eebfa7", "patch": "@@ -1,3 +1,9 @@\n+2016-02-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Access_Type>: Retrofit\n+\thandling of unconstrained array types as designated types into common\n+\tprocessing.  Also handle array types as incomplete designated types.\n+\n 2016-02-29  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <Concurrent types>: In"}, {"sha": "7ea5ff869e6cde94b8df5da93f51afad2b07e666", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 23, "deletions": 51, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ea456b94ac356fd36ba7043195a2d6c65eebfa7/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ea456b94ac356fd36ba7043195a2d6c65eebfa7/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=8ea456b94ac356fd36ba7043195a2d6c65eebfa7", "patch": "@@ -3855,8 +3855,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* The type actually used to represent the designated type, either\n \t   gnat_desig_full or gnat_desig_equiv.  */\n \tEntity_Id gnat_desig_rep;\n-\t/* True if this is a pointer to an unconstrained array.  */\n-\tbool is_unconstrained_array;\n \t/* We want to know if we'll be seeing the freeze node for any\n \t   incomplete type we may be pointing to.  */\n \tbool in_main_unit\n@@ -3890,62 +3888,26 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    && Ekind (Etype (gnat_desig_full)) == E_Record_Type)))\n \t  gnat_desig_full = Etype (gnat_desig_full);\n \n-\t/* Set the type that's actually the representation of the designated\n-\t   type and also flag whether we have a unconstrained array.  */\n+\t/* Set the type that's the representation of the designated type.  */\n \tgnat_desig_rep\n \t  = Present (gnat_desig_full) ? gnat_desig_full : gnat_desig_equiv;\n-\tis_unconstrained_array\n-\t  = Is_Array_Type (gnat_desig_rep) && !Is_Constrained (gnat_desig_rep);\n-\n-\t/* If we are pointing to an incomplete type whose completion is an\n-\t   unconstrained array, make dummy fat and thin pointer types to it.\n-\t   Likewise if the type itself is dummy or an unconstrained array.  */\n-\tif (is_unconstrained_array\n-\t    && (Present (gnat_desig_full)\n-\t\t|| (present_gnu_tree (gnat_desig_equiv)\n-\t\t    && TYPE_IS_DUMMY_P\n-\t\t       (TREE_TYPE (get_gnu_tree (gnat_desig_equiv))))\n-\t\t|| (!in_main_unit\n-\t\t    && defer_incomplete_level != 0\n-\t\t    && !present_gnu_tree (gnat_desig_equiv))\n-\t\t|| (in_main_unit\n-\t\t    && is_from_limited_with\n-\t\t    && Present (Freeze_Node (gnat_desig_equiv)))))\n-\t  {\n-\t    if (present_gnu_tree (gnat_desig_rep))\n-\t      gnu_desig_type = TREE_TYPE (get_gnu_tree (gnat_desig_rep));\n-\t    else\n-\t      {\n-\t\tgnu_desig_type = make_dummy_type (gnat_desig_rep);\n-\t\tmade_dummy = true;\n-\t      }\n-\n-\t    /* If the call above got something that has a pointer, the pointer\n-\t       is our type.  This could have happened either because the type\n-\t       was elaborated or because somebody else executed the code.  */\n-\t    if (!TYPE_POINTER_TO (gnu_desig_type))\n-\t      build_dummy_unc_pointer_types (gnat_desig_equiv, gnu_desig_type);\n-\t    gnu_type = TYPE_POINTER_TO (gnu_desig_type);\n-\t  }\n \n \t/* If we already know what the full type is, use it.  */\n-\telse if (Present (gnat_desig_full)\n-\t\t && present_gnu_tree (gnat_desig_full))\n+\tif (Present (gnat_desig_full) && present_gnu_tree (gnat_desig_full))\n \t  gnu_desig_type = TREE_TYPE (get_gnu_tree (gnat_desig_full));\n \n \t/* Get the type of the thing we are to point to and build a pointer to\n \t   it.  If it is a reference to an incomplete or private type with a\n-\t   full view that is a record, make a dummy type node and get the\n-\t   actual type later when we have verified it is safe.  */\n+\t   full view that is a record or an array, make a dummy type node and\n+\t   get the actual type later when we have verified it is safe.  */\n \telse if ((!in_main_unit\n \t\t  && !present_gnu_tree (gnat_desig_equiv)\n \t\t  && Present (gnat_desig_full)\n-\t\t  && !present_gnu_tree (gnat_desig_full)\n-\t\t  && Is_Record_Type (gnat_desig_full))\n+\t\t  && (Is_Record_Type (gnat_desig_full)\n+\t\t      || Is_Array_Type (gnat_desig_full)))\n \t\t /* Likewise if we are pointing to a record or array and we are\n \t\t    to defer elaborating incomplete types.  We do this as this\n-\t\t    access type may be the full view of a private type.  Note\n-\t\t    that the unconstrained array case is handled above.  */\n+\t\t    access type may be the full view of a private type.  */\n \t\t || ((!in_main_unit || imported_p)\n \t\t     && defer_incomplete_level != 0\n \t\t     && !present_gnu_tree (gnat_desig_equiv)\n@@ -3958,11 +3920,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    in which case we make the dummy type and it will be reused\n \t\t    when the declaration is finally processed.  In both cases,\n \t\t    the pointer eventually created below will be automatically\n-\t\t    adjusted when the freeze node is processed.  Note that the\n-\t\t    unconstrained array case is handled above.  */\n-\t\t ||  (in_main_unit\n-\t\t      && is_from_limited_with\n-\t\t      && Present (Freeze_Node (gnat_desig_rep))))\n+\t\t    adjusted when the freeze node is processed.  */\n+\t\t || (in_main_unit\n+\t\t     && is_from_limited_with\n+\t\t     && Present (Freeze_Node (gnat_desig_rep))))\n \t  {\n \t    gnu_desig_type = make_dummy_type (gnat_desig_equiv);\n \t    made_dummy = true;\n@@ -3995,8 +3956,19 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    break;\n \t  }\n \n+\t/* For an unconstrained array, make dummy fat & thin pointer types.  */\n+\tif (Is_Array_Type (gnat_desig_rep) && !Is_Constrained (gnat_desig_rep))\n+\t  {\n+\t    /* If the processing above got something that has a pointer, then\n+\t       we are done.  This could have happened either because the type\n+\t       was elaborated or because somebody else executed the code.  */\n+\t    if (!TYPE_POINTER_TO (gnu_desig_type))\n+\t      build_dummy_unc_pointer_types (gnat_desig_equiv, gnu_desig_type);\n+\t    gnu_type = TYPE_POINTER_TO (gnu_desig_type);\n+\t  }\n+\n \t/* If we haven't done it yet, build the pointer type the usual way.  */\n-\tif (!gnu_type)\n+\telse if (!gnu_type)\n \t  {\n \t    /* Modify the designated type if we are pointing only to constant\n \t       objects, but don't do it for unconstrained arrays.  */"}, {"sha": "2191d388a343dfa1169835e6b77c8a7ad5c1a561", "filename": "gcc/testsuite/gnat.dg/incomplete4.adb", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ea456b94ac356fd36ba7043195a2d6c65eebfa7/gcc%2Ftestsuite%2Fgnat.dg%2Fincomplete4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ea456b94ac356fd36ba7043195a2d6c65eebfa7/gcc%2Ftestsuite%2Fgnat.dg%2Fincomplete4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fincomplete4.adb?ref=8ea456b94ac356fd36ba7043195a2d6c65eebfa7", "patch": "@@ -0,0 +1,10 @@\n+-- { dg-do compile }\n+\n+with Incomplete4_Pkg; use Incomplete4_Pkg;\n+with System;\n+\n+procedure Incomplete4 is\n+  L : System.Address := A'Address;\n+begin\n+  null;\n+end;"}, {"sha": "992986ee105d21fc4ad98bf26e81968371781ede", "filename": "gcc/testsuite/gnat.dg/incomplete4_pkg.ads", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ea456b94ac356fd36ba7043195a2d6c65eebfa7/gcc%2Ftestsuite%2Fgnat.dg%2Fincomplete4_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ea456b94ac356fd36ba7043195a2d6c65eebfa7/gcc%2Ftestsuite%2Fgnat.dg%2Fincomplete4_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fincomplete4_pkg.ads?ref=8ea456b94ac356fd36ba7043195a2d6c65eebfa7", "patch": "@@ -0,0 +1,9 @@\n+package Incomplete4_Pkg is\n+\n+   type Circular_Type;\n+   type Ptr is access Circular_Type;\n+   type Circular_Type is array (1..100) of Ptr;\n+\n+   A : Circular_Type;\n+\n+end Incomplete4_Pkg;"}]}