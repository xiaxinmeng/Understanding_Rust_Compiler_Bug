{"sha": "b90e0e3cdb60af9429f1acd99d9e30a65c03752d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjkwZTBlM2NkYjYwYWY5NDI5ZjFhY2Q5OWQ5ZTMwYTY1YzAzNzUyZA==", "commit": {"author": {"name": "Mohan Embar", "email": "gnustuff@thisiscool.com", "date": "2003-09-19T08:28:43Z"}, "committer": {"name": "Mohan Embar", "email": "membar@gcc.gnu.org", "date": "2003-09-19T08:28:43Z"}, "message": "win32-threads.cc: (ensure_interrupt_event_initialized) New function for lazy initialization of an...\n\n\t* win32-threads.cc: (ensure_interrupt_event_initialized) New\n\tfunction for lazy initialization of an auto-reset event.\n\t(_Jv_CondWait) Added thread interrupt support.\n\t(_Jv_ThreadInitData) Added initialization of interrupt support\n\tmembers.\n\t(_Jv_ThreadDestroyData) Added cleanup of interrupt support members.\n\t(_Jv_ThreadStart) Removed unused code.\n\t(_Jv_Win32GetInterruptEvent) New method for returning interrupt event\n\tto an external caller.\n\t(_Jv_ThreadInterrupt) Implemented.\n\t* include/win32-threads.h: (_Jv_Thread_t) Added a Win32 auto-reset\n\tevent for interrupt support as well as a mutex which regulates\n\taccess to this.\n\t(_Jv_Win32GetInterruptEvent) Declared new method for returning interrupt\n\tevent to an external caller.\n\t* java/lang/natWin32Process.cc: (cleanup) Close handle to spawned\n\tprocess.\n\t(waitFor) Added interrupt support.\n\nFrom-SVN: r71562", "tree": {"sha": "d3850b3d1b7ded7bcbfb6b163fc0d2d5a78e5a7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3850b3d1b7ded7bcbfb6b163fc0d2d5a78e5a7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b90e0e3cdb60af9429f1acd99d9e30a65c03752d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b90e0e3cdb60af9429f1acd99d9e30a65c03752d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b90e0e3cdb60af9429f1acd99d9e30a65c03752d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b90e0e3cdb60af9429f1acd99d9e30a65c03752d/comments", "author": null, "committer": null, "parents": [{"sha": "65f070242b4206f88edf3c53000520f3f5c0224a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65f070242b4206f88edf3c53000520f3f5c0224a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65f070242b4206f88edf3c53000520f3f5c0224a"}], "stats": {"total": 163, "additions": 152, "deletions": 11}, "files": [{"sha": "dee9617a4f981204f39b3738d20142e1a2b90b20", "filename": "libjava/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b90e0e3cdb60af9429f1acd99d9e30a65c03752d/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b90e0e3cdb60af9429f1acd99d9e30a65c03752d/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=b90e0e3cdb60af9429f1acd99d9e30a65c03752d", "patch": "@@ -1,3 +1,24 @@\n+2003-09-19  Mohan Embar  <gnustuff@thisiscool.com>\n+\n+\t* win32-threads.cc: (ensure_interrupt_event_initialized) New\n+\tfunction for lazy initialization of an auto-reset event.\n+\t(_Jv_CondWait) Added thread interrupt support.\n+\t(_Jv_ThreadInitData) Added initialization of interrupt support\n+\tmembers.\n+\t(_Jv_ThreadDestroyData) Added cleanup of interrupt support members.\n+\t(_Jv_ThreadStart) Removed unused code.\n+\t(_Jv_Win32GetInterruptEvent) New method for returning interrupt event\n+\tto an external caller.\n+\t(_Jv_ThreadInterrupt) Implemented.\n+\t* include/win32-threads.h: (_Jv_Thread_t) Added a Win32 auto-reset\n+\tevent for interrupt support as well as a mutex which regulates\n+\taccess to this.\n+\t(_Jv_Win32GetInterruptEvent) Declared new method for returning interrupt\n+\tevent to an external caller.\n+\t* java/lang/natWin32Process.cc: (cleanup) Close handle to spawned\n+\tprocess.\n+\t(waitFor) Added interrupt support.\n+\n 2003-09-19  Michael Koch  <konqueror@gmx.de>\n \n \t* java/net/DatagramSocket.java (getLocalAddress):"}, {"sha": "ed5eb0047e01eb27aef473a4e709758b48a998ea", "filename": "libjava/include/win32-threads.h", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b90e0e3cdb60af9429f1acd99d9e30a65c03752d/libjava%2Finclude%2Fwin32-threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b90e0e3cdb60af9429f1acd99d9e30a65c03752d/libjava%2Finclude%2Fwin32-threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fwin32-threads.h?ref=b90e0e3cdb60af9429f1acd99d9e30a65c03752d", "patch": "@@ -50,6 +50,14 @@ typedef struct\n {\n   int flags;            // Flags are defined in implementation.\n   HANDLE handle;        // Actual handle to the thread\n+\n+  // Protects access to the thread's interrupt_flag and\n+  // interrupt_event variables within this module.\n+  CRITICAL_SECTION interrupt_mutex;\n+  \n+  // A Win32 auto-reset event for thread interruption\n+  HANDLE interrupt_event;\n+\n   java::lang::Thread *thread_obj;\n } _Jv_Thread_t;\n \n@@ -150,6 +158,24 @@ void _Jv_ThreadStart (java::lang::Thread *thread, _Jv_Thread_t *data,\n void _Jv_ThreadWait (void);\n void _Jv_ThreadInterrupt (_Jv_Thread_t *data);\n \n+//\n+// Thread interruption support\n+//\n+\n+// Gets the auto-reset event for the current thread which is\n+// signalled by _Jv_ThreadInterrupt. The caller can wait on this\n+// event in addition to other waitable objects.\n+//\n+// NOTE: After waiting on this event with WaitForMultipleObjects,\n+// you should ALWAYS use the return value of WaitForMultipleObjects\n+// to test whether this event was signalled and whether thread\n+// interruption has occurred. You should do this instead of checking\n+// the thread's interrupted_flag, because someone could have reset\n+// this flag in the interval of time between the return of\n+// WaitForMultipleObjects and the time you query interrupted_flag.\n+// See java/lang/natWin32Process.cc (waitFor) for an example.\n+HANDLE _Jv_Win32GetInterruptEvent (void);\n+\n // Remove defines from <windows.h> that conflict with various things in libgcj code\n \n #undef TRUE"}, {"sha": "49fa853a398bf099557fb6e4caec9594b79c0d10", "filename": "libjava/java/lang/natWin32Process.cc", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b90e0e3cdb60af9429f1acd99d9e30a65c03752d/libjava%2Fjava%2Flang%2FnatWin32Process.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b90e0e3cdb60af9429f1acd99d9e30a65c03752d/libjava%2Fjava%2Flang%2FnatWin32Process.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatWin32Process.cc?ref=b90e0e3cdb60af9429f1acd99d9e30a65c03752d", "patch": "@@ -46,6 +46,11 @@ java::lang::ConcreteProcess::cleanup (void)\n       errorStream->close ();\n       errorStream = NULL;\n     }\n+  if (procHandle)\n+    {\n+      CloseHandle((HANDLE) procHandle);\n+      procHandle = (jint) INVALID_HANDLE_VALUE;\n+    }\n }\n \n void\n@@ -92,8 +97,28 @@ java::lang::ConcreteProcess::waitFor (void)\n     {\n       DWORD exitStatus = 0UL;\n \n-      // FIXME: The wait should be interruptible.\n-      WaitForSingleObject ((HANDLE) procHandle, INFINITE);\n+      // Set up our waitable objects array\n+      // - 0: the handle to the process we just launched\n+      // - 1: our thread's interrupt event\n+      HANDLE arh[2];\n+      arh[0] = (HANDLE) procHandle;\n+      arh[1] = _Jv_Win32GetInterruptEvent ();\n+      DWORD rval = WaitForMultipleObjects (2, arh, 0, INFINITE);\n+\n+      // Use the returned value from WaitForMultipleObjects\n+      // instead of our thread's interrupt_flag to test for\n+      // thread interruption. See the comment for\n+      // _Jv_Win32GetInterruptEvent().\n+      bool bInterrupted = rval == (WAIT_OBJECT_0 + 1);\n+      \n+      if (bInterrupted)\n+        {\n+          // Querying this forces a reset our thread's interrupt flag.\n+          Thread::interrupted();\n+          \n+          cleanup ();\n+          throw new InterruptedException ();\n+        }\n \n       GetExitCodeProcess ((HANDLE) procHandle, &exitStatus);\n       exitCode = exitStatus;"}, {"sha": "1f3d0c57b22b515e298555ebbb7202014520b0e5", "filename": "libjava/win32-threads.cc", "status": "modified", "additions": 78, "deletions": 9, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b90e0e3cdb60af9429f1acd99d9e30a65c03752d/libjava%2Fwin32-threads.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b90e0e3cdb60af9429f1acd99d9e30a65c03752d/libjava%2Fwin32-threads.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fwin32-threads.cc?ref=b90e0e3cdb60af9429f1acd99d9e30a65c03752d", "patch": "@@ -81,6 +81,16 @@ ensure_condvar_initialized(_Jv_ConditionVariable_t *cv)\n     }\n }\n \n+inline void\n+ensure_interrupt_event_initialized(HANDLE& rhEvent)\n+{\n+  if (!rhEvent)\n+    {\n+      rhEvent = CreateEvent (NULL, 0, 0, NULL);\n+      if (!rhEvent) JvFail(\"CreateEvent() failed\");\n+    }\n+}\n+\n // Reimplementation of the general algorithm described at\n // http://www.cs.wustl.edu/~schmidt/win32-cv-1.html (isomorphic to\n // 3.2, not a cut-and-paste).\n@@ -91,6 +101,21 @@ _Jv_CondWait(_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu, jlong millis, jint na\n   if (mu->owner != GetCurrentThreadId ( ))\n     return _JV_NOT_OWNER;\n \n+  _Jv_Thread_t *current = _Jv_ThreadCurrentData ();\n+  java::lang::Thread *current_obj = _Jv_ThreadCurrent ();\n+\n+  // Now that we hold the interrupt mutex, check if this thread has been \n+  // interrupted already.\n+  EnterCriticalSection (&current->interrupt_mutex);\n+  ensure_interrupt_event_initialized (current->interrupt_event);\n+  jboolean interrupted = current_obj->interrupt_flag;\n+  LeaveCriticalSection (&current->interrupt_mutex);\n+\n+  if (interrupted)\n+    {\n+      return _JV_INTERRUPTED;\n+    }\n+\n   EnterCriticalSection (&cv->count_mutex);\n   ensure_condvar_initialized (cv);\n   cv->blocked_count++;\n@@ -103,7 +128,31 @@ _Jv_CondWait(_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu, jlong millis, jint na\n \n   _Jv_MutexUnlock (mu);\n \n-  DWORD rval = WaitForMultipleObjects (2, &(cv->ev[0]), 0, time);\n+  // Set up our array of three events:\n+  // - the auto-reset event (for notify())\n+  // - the manual-reset event (for notifyAll())\n+  // - the interrupt event (for interrupt())\n+  // We wait for any one of these to be signaled.\n+  HANDLE arh[3];\n+  arh[0] = cv->ev[0];\n+  arh[1] = cv->ev[1];\n+  arh[2] = current->interrupt_event;\n+  DWORD rval = WaitForMultipleObjects (3, arh, 0, time);\n+\n+  EnterCriticalSection (&current->interrupt_mutex);\n+\n+  // If we were unblocked by the third event (our thread's interrupt\n+  // event), set the thread's interrupt flag. I think this sanity\n+  // check guards against someone resetting our interrupt flag\n+  // in the time between when interrupt_mutex is released in\n+  // _Jv_ThreadInterrupt and the interval of time between the\n+  // WaitForMultipleObjects call we just made and our acquisition\n+  // of interrupt_mutex.\n+  if (rval == (WAIT_OBJECT_0 + 2))\n+    current_obj->interrupt_flag = true;\n+    \n+  interrupted = current_obj->interrupt_flag;\n+  LeaveCriticalSection (&current->interrupt_mutex);\n \n   EnterCriticalSection(&cv->count_mutex);\n   cv->blocked_count--;\n@@ -116,8 +165,8 @@ _Jv_CondWait(_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu, jlong millis, jint na\n     ResetEvent (cv->ev[1]);\n \n   _Jv_MutexLock (mu);\n-\n-  return 0;\n+  \n+  return interrupted ? _JV_INTERRUPTED : 0;\n }\n \n void\n@@ -197,13 +246,18 @@ _Jv_ThreadInitData (java::lang::Thread* obj)\n   _Jv_Thread_t *data = (_Jv_Thread_t*)_Jv_Malloc(sizeof(_Jv_Thread_t));\n   data->flags = 0;\n   data->thread_obj = obj;\n+  data->interrupt_event = 0;\n+  InitializeCriticalSection (&data->interrupt_mutex);\n \n   return data;\n }\n \n void\n _Jv_ThreadDestroyData (_Jv_Thread_t *data)\n {\n+  DeleteCriticalSection (&data->interrupt_mutex);\n+  if (data->interrupt_event)\n+    CloseHandle(data->interrupt_event);\n   _Jv_Free(data);\n }\n \n@@ -308,11 +362,8 @@ _Jv_ThreadStart (java::lang::Thread *thread, _Jv_Thread_t *data, _Jv_ThreadStart\n   else\n     data->flags |= FLAG_DAEMON;\n \n-  HANDLE h = GC_CreateThread(NULL, 0, really_start, info, 0, &id);\n+  GC_CreateThread(NULL, 0, really_start, info, 0, &id);\n   _Jv_ThreadSetPriority(data, thread->getPriority());\n-\n-  //if (!h)\n-    //JvThrow ();\n }\n \n void\n@@ -326,9 +377,27 @@ _Jv_ThreadWait (void)\n     }\n }\n \n+//\n+// Interrupt support\n+//\n+\n+HANDLE\n+_Jv_Win32GetInterruptEvent (void)\n+{\n+  _Jv_Thread_t *current = _Jv_ThreadCurrentData ();\n+  EnterCriticalSection (&current->interrupt_mutex);\n+  ensure_interrupt_event_initialized (current->interrupt_event);\n+  HANDLE hEvent = current->interrupt_event;\n+  LeaveCriticalSection (&current->interrupt_mutex);\n+  return hEvent;\n+}\n+\n void\n _Jv_ThreadInterrupt (_Jv_Thread_t *data)\n {\n-  MessageBox(NULL, \"Unimplemented\", \"win32-threads.cc:_Jv_ThreadInterrupt\", MB_OK);\n-  // FIXME:\n+  EnterCriticalSection (&data->interrupt_mutex);\n+  ensure_interrupt_event_initialized (data->interrupt_event);\n+  data->thread_obj->interrupt_flag = true;\n+  SetEvent (data->interrupt_event);\n+  LeaveCriticalSection (&data->interrupt_mutex);\n }"}]}