{"sha": "c3684b7b86da9b6b01f6fb274227fc6401df053e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM2ODRiN2I4NmRhOWI2YjAxZjZmYjI3NDIyN2ZjNjQwMWRmMDUzZQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-06-16T03:48:59Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-06-16T03:48:59Z"}, "message": "PR c++/80560 - warn on undefined memory operations involving non-trivial types\n\ngcc/c-family/ChangeLog:\n\n\tPR c++/80560\n\t* c.opt (-Wclass-memaccess): New option.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/80560\n\t* call.c (first_non_public_field, maybe_warn_class_memaccess): New\n\tfunctions.\n\t(has_trivial_copy_assign_p, has_trivial_copy_p): Ditto.\n\t(build_cxx_call): Call maybe_warn_class_memaccess.\n\ngcc/ChangeLog:\n\n\tPR c++/80560\n\t* dumpfile.c (dump_register): Avoid calling memset to initialize\n\ta class with a default ctor.\n\t* gcc.c (struct compiler): Remove const qualification.\n\t* genattrtab.c (gen_insn_reserv): Replace memset with initialization.\n\t* hash-table.h: Ditto.\n\t* ipa-cp.c (allocate_and_init_ipcp_value): Replace memset with\n\t  assignment.\n\t* ipa-prop.c (ipa_free_edge_args_substructures): Ditto.\n\t* omp-low.c (lower_omp_ordered_clauses): Replace memset with\n\tdefault ctor.\n\t* params.h (struct param_info): Make struct members non-const.\n\t* tree-switch-conversion.c (emit_case_bit_tests): Replace memset\n\twith default initialization.\n\t* vec.h (vec_copy_construct, vec_default_construct): New helper\n\tfunctions.\n\t(vec<T>::copy, vec<T>::splice, vec<T>::reserve): Replace memcpy\n\twith vec_copy_construct.\n\t(vect<T>::quick_grow_cleared): Replace memset with default ctor.\n\t(vect<T>::vec_safe_grow_cleared, vec_safe_grow_cleared): Same.\n\t* doc/invoke.texi (-Wclass-memaccess): Document.\n\nlibcpp/ChangeLog:\n\n\tPR c++/80560\n\t* line-map.c (line_maps::~line_maps): Avoid calling htab_delete\n\twith a null pointer.\n\t(linemap_init): Avoid calling memset on an object of a non-trivial\n\ttype.\n\nlibitm/ChangeLog:\n\n\tPR c++/80560\n\t* beginend.cc (GTM::gtm_thread::rollback): Avoid calling memset\n\ton an object of a non-trivial type.\n\t(GTM::gtm_transaction_cp::commit): Use assignment instead of memcpy\n\tto copy an object.\n\t* method-ml.cc (orec_iterator::reinit): Avoid -Wclass-memaccess.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/80560\n\t* g++.dg/Wclass-memaccess.C: New test.\n\nFrom-SVN: r249234", "tree": {"sha": "921877ef9f69c6bac6285495a3eec052a4fad2a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/921877ef9f69c6bac6285495a3eec052a4fad2a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3684b7b86da9b6b01f6fb274227fc6401df053e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3684b7b86da9b6b01f6fb274227fc6401df053e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3684b7b86da9b6b01f6fb274227fc6401df053e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3684b7b86da9b6b01f6fb274227fc6401df053e/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6a382041ddccd829db190f7c112ecfff2e7d369a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a382041ddccd829db190f7c112ecfff2e7d369a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a382041ddccd829db190f7c112ecfff2e7d369a"}], "stats": {"total": 2231, "additions": 2196, "deletions": 35}, "files": [{"sha": "df4da476a6c7cfa35a919f39484fe46cc65f7c2b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c3684b7b86da9b6b01f6fb274227fc6401df053e", "patch": "@@ -1,3 +1,27 @@\n+2017-06-15  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/80560\n+\t* dumpfile.c (dump_register): Avoid calling memset to initialize\n+\ta class with a default ctor.\n+\t* gcc.c (struct compiler): Remove const qualification.\n+\t* genattrtab.c (gen_insn_reserv): Replace memset with initialization.\n+\t* hash-table.h: Ditto.\n+\t* ipa-cp.c (allocate_and_init_ipcp_value): Replace memset with\n+\t  assignment.\n+\t* ipa-prop.c (ipa_free_edge_args_substructures): Ditto.\n+\t* omp-low.c (lower_omp_ordered_clauses): Replace memset with\n+\tdefault ctor.\n+\t* params.h (struct param_info): Make struct members non-const.\n+\t* tree-switch-conversion.c (emit_case_bit_tests): Replace memset\n+\twith default initialization.\n+\t* vec.h (vec_copy_construct, vec_default_construct): New helper\n+\tfunctions.\n+\t(vec<T>::copy, vec<T>::splice, vec<T>::reserve): Replace memcpy\n+\twith vec_copy_construct.\n+\t(vect<T>::quick_grow_cleared): Replace memset with default ctor.\n+\t(vect<T>::vec_safe_grow_cleared, vec_safe_grow_cleared): Same.\n+\t* doc/invoke.texi (-Wclass-memaccess): Document.\n+\n 2017-06-15  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \t* emit-rtl.h (is_leaf): Update comment about local"}, {"sha": "e8d1d57ae91d0365b2484b3da71739977897919c", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=c3684b7b86da9b6b01f6fb274227fc6401df053e", "patch": "@@ -1,3 +1,8 @@\n+2017-06-15  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/80560\n+\t* c.opt (-Wclass-memaccess): New option.\n+\n 2017-06-14  Boris Kolpackov  <boris@codesynthesis.com>\n \n \t* c-opts.c (c_common_finish): Handle '-' special value to -MF."}, {"sha": "363d10433971c204acb0e1ca13e96428d8a8e478", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=c3684b7b86da9b6b01f6fb274227fc6401df053e", "patch": "@@ -804,6 +804,10 @@ Wnon-template-friend\n C++ ObjC++ Var(warn_nontemplate_friend) Init(1) Warning\n Warn when non-templatized friend functions are declared within a template.\n \n+Wclass-memaccess\n+C++ ObjC++ Var(warn_class_memaccess) Warning LangEnabledBy(C++ ObjC++, Wall)\n+Warn for unsafe raw memory writes to objects of class types.\n+\n Wnon-virtual-dtor\n C++ ObjC++ Var(warn_nonvdtor) Warning LangEnabledBy(C++ ObjC++,Weffc++)\n Warn about non-virtual destructors."}, {"sha": "ed307b6278e0426257829b35f3cbb971ad36a440", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c3684b7b86da9b6b01f6fb274227fc6401df053e", "patch": "@@ -1,3 +1,11 @@\n+2017-06-15  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/80560\n+\t* call.c (first_non_public_field, maybe_warn_class_memaccess): New\n+\tfunctions.\n+\t(has_trivial_copy_assign_p, has_trivial_copy_p): Ditto.\n+\t(build_cxx_call): Call maybe_warn_class_memaccess.\n+\n 2017-06-14  Jakub Jelinek  <jakub@redhat.com>\n \n \t* cp-gimplify.c (cp_genericize_r): Turn most of the function"}, {"sha": "9c3f1eb2b2bc93d78cda3b510169c3d2a74b462f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 391, "deletions": 0, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=c3684b7b86da9b6b01f6fb274227fc6401df053e", "patch": "@@ -8184,6 +8184,393 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n   return call;\n }\n \n+/* Return the DECL of the first non-public data member of class TYPE\n+   or null if none can be found.  */\n+\n+static tree\n+first_non_public_field (tree type)\n+{\n+  if (!CLASS_TYPE_P (type))\n+    return NULL_TREE;\n+\n+  for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+    {\n+      if (TREE_CODE (field) != FIELD_DECL)\n+\tcontinue;\n+      if (TREE_STATIC (field))\n+\tcontinue;\n+      if (TREE_PRIVATE (field) || TREE_PROTECTED (field))\n+\treturn field;\n+    }\n+\n+  int i = 0;\n+\n+  for (tree base_binfo, binfo = TYPE_BINFO (type);\n+       BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+    {\n+      tree base = TREE_TYPE (base_binfo);\n+\n+      if (tree field = first_non_public_field (base))\n+\treturn field;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Return true if all copy and move assignment operator overloads for\n+   class TYPE are trivial and at least one of them is not deleted and,\n+   when ACCESS is set, accessible.  Return false otherwise.  Set\n+   HASASSIGN to true when the TYPE has a (not necessarily trivial)\n+   copy or move assignment.  */\n+\n+static bool\n+has_trivial_copy_assign_p (tree type, bool access, bool *hasassign)\n+{\n+  tree fns = cp_assignment_operator_id (NOP_EXPR);\n+  fns = lookup_fnfields_slot (type, fns);\n+\n+  bool all_trivial = true;\n+\n+  /* Iterate over overloads of the assignment operator, checking\n+     accessible copy assignments for triviality.  */\n+\n+  for (ovl_iterator oi (fns); oi; ++oi)\n+    {\n+      tree f = *oi;\n+\n+      /* Skip operators that aren't copy assignments.  */\n+      if (!copy_fn_p (f))\n+\tcontinue;\n+\n+      bool accessible = (!access || !(TREE_PRIVATE (f) || TREE_PROTECTED (f))\n+\t\t\t || accessible_p (TYPE_BINFO (type), f, true));\n+\n+      /* Skip template assignment operators and deleted functions.  */\n+      if (TREE_CODE (f) != FUNCTION_DECL || DECL_DELETED_FN (f))\n+\tcontinue;\n+\n+      if (accessible)\n+\t*hasassign = true;\n+\n+      if (!accessible || !trivial_fn_p (f))\n+\tall_trivial = false;\n+\n+      /* Break early when both properties have been determined.  */\n+      if (*hasassign && !all_trivial)\n+\tbreak;\n+    }\n+\n+  /* Return true if they're all trivial and one of the expressions\n+     TYPE() = TYPE() or TYPE() = (TYPE&)() is valid.  */\n+  tree ref = cp_build_reference_type (type, false);\n+  return (all_trivial\n+\t  && (is_trivially_xible (MODIFY_EXPR, type, type)\n+\t      || is_trivially_xible (MODIFY_EXPR, type, ref)));\n+}\n+\n+/* Return true if all copy and move ctor overloads for class TYPE are\n+   trivial and at least one of them is not deleted and, when ACCESS is\n+   set, accessible.  Return false otherwise.  Set each element of HASCTOR[]\n+   to true when the TYPE has a (not necessarily trivial) default and copy\n+   (or move) ctor, respectively.  */\n+\n+static bool\n+has_trivial_copy_p (tree type, bool access, bool hasctor[2])\n+{\n+  tree fns = lookup_fnfields_slot (type, complete_ctor_identifier);\n+\n+  bool all_trivial = true;\n+\n+  for (ovl_iterator oi (fns); oi; ++oi)\n+    {\n+      tree f = *oi;\n+\n+      /* Skip template constructors.  */\n+      if (TREE_CODE (f) != FUNCTION_DECL)\n+\tcontinue;\n+\n+      bool cpy_or_move_ctor_p = copy_fn_p (f);\n+\n+      /* Skip ctors other than default, copy, and move.  */\n+      if (!cpy_or_move_ctor_p && !default_ctor_p (f))\n+\tcontinue;\n+\n+      if (DECL_DELETED_FN (f))\n+\tcontinue;\n+\n+      bool accessible = (!access || !(TREE_PRIVATE (f) || TREE_PROTECTED (f))\n+\t\t\t || accessible_p (TYPE_BINFO (type), f, true));\n+\n+      if (accessible)\n+\thasctor[cpy_or_move_ctor_p] = true;\n+\n+      if (cpy_or_move_ctor_p && (!accessible || !trivial_fn_p (f)))\n+\tall_trivial = false;\n+\n+      /* Break early when both properties have been determined.  */\n+      if (hasctor[0] && hasctor[1] && !all_trivial)\n+\tbreak;\n+    }\n+\n+  return all_trivial;\n+}\n+\n+/* Issue a warning on a call to the built-in function FNDECL if it is\n+   a raw memory write whose destination is not an object of (something\n+   like) trivial or standard layout type with a non-deleted assignment\n+   and copy ctor.  Detects const correctness violations, corrupting\n+   references, virtual table pointers, and bypassing non-trivial\n+   assignments.  */\n+\n+static void\n+maybe_warn_class_memaccess (location_t loc, tree fndecl, tree *args)\n+{\n+  /* Except for bcopy where it's second, the destination pointer is\n+     the first argument for all functions handled here.  Compute\n+     the index of the destination and source arguments.  */\n+  unsigned dstidx = DECL_FUNCTION_CODE (fndecl) == BUILT_IN_BCOPY;\n+  unsigned srcidx = !dstidx;\n+\n+  tree dest = args[dstidx];\n+  if (!dest || !TREE_TYPE (dest) || !POINTER_TYPE_P (TREE_TYPE (dest)))\n+    return;\n+\n+  STRIP_NOPS (dest);\n+\n+  tree srctype = NULL_TREE;\n+\n+  /* Determine the type of the pointed-to object and whether it's\n+     a complete class type.  */\n+  tree desttype = TREE_TYPE (TREE_TYPE (dest));\n+\n+  if (!desttype || !COMPLETE_TYPE_P (desttype) || !CLASS_TYPE_P (desttype))\n+    return;\n+\n+  /* Check to see if the raw memory call is made by a ctor or dtor\n+     with this as the destination argument for the destination type.\n+     If so, be more permissive.  */\n+  if (current_function_decl\n+      && (DECL_CONSTRUCTOR_P (current_function_decl)\n+\t  || DECL_DESTRUCTOR_P (current_function_decl))\n+      && is_this_parameter (dest))\n+    {\n+      tree ctx = DECL_CONTEXT (current_function_decl);\n+      bool special = same_type_ignoring_top_level_qualifiers_p (ctx, desttype);\n+\n+      tree binfo = TYPE_BINFO (ctx);\n+\n+      /* A ctor and dtor for a class with no bases and no virtual functions\n+\t can do whatever they want.  Bail early with no further checking.  */\n+      if (special && !BINFO_VTABLE (binfo) && !BINFO_N_BASE_BINFOS (binfo))\n+\treturn;\n+    }\n+\n+  /* True if the class is trivial.  */\n+  bool trivial = trivial_type_p (desttype);\n+\n+  /* Set to true if DESTYPE has an accessible copy assignment.  */\n+  bool hasassign = false;\n+  /* True if all of the class' overloaded copy assignment operators\n+     are all trivial (and not deleted) and at least one of them is\n+     accessible.  */\n+  bool trivassign = has_trivial_copy_assign_p (desttype, true, &hasassign);\n+\n+  /* Set to true if DESTTYPE has an accessible default and copy ctor,\n+     respectively.  */\n+  bool hasctors[2] = { false, false };\n+\n+  /* True if all of the class' overloaded copy constructors are all\n+     trivial (and not deleted) and at least one of them is accessible.  */\n+  bool trivcopy = has_trivial_copy_p (desttype, true, hasctors);\n+\n+  /* Set FLD to the first private/protected member of the class.  */\n+  tree fld = trivial ? first_non_public_field (desttype) : NULL_TREE;\n+\n+  /* The warning format string.  */\n+  const char *warnfmt = NULL;\n+  /* A suggested alternative to offer instead of the raw memory call.\n+     Empty string when none can be come up with.  */\n+  const char *suggest = \"\";\n+  bool warned = false;\n+\n+  switch (DECL_FUNCTION_CODE (fndecl))\n+    {\n+    case BUILT_IN_MEMSET:\n+      if (!integer_zerop (args[1]))\n+\t{\n+\t  /* Diagnose setting non-copy-assignable or non-trivial types,\n+\t     or types with a private member, to (potentially) non-zero\n+\t     bytes.  Since the value of the bytes being written is unknown,\n+\t     suggest using assignment instead (if one exists).  Also warn\n+\t     for writes into objects for which zero-initialization doesn't\n+\t     mean all bits clear (pointer-to-member data, where null is all\n+\t     bits set).  Since the value being written is (most likely)\n+\t     non-zero, simply suggest assignment (but not copy assignment).  */\n+\t  suggest = \"; use assignment instead\";\n+\t  if (!trivassign)\n+\t    warnfmt = G_(\"%qD writing to an object of type %#qT with \"\n+\t\t\t \"no trivial copy-assignment\");\n+\t  else if (!trivial)\n+\t    warnfmt = G_(\"%qD writing to an object of non-trivial type %#qT%s\");\n+\t  else if (fld)\n+\t    {\n+\t      const char *access = TREE_PRIVATE (fld) ? \"private\" : \"protected\";\n+\t      warned = warning_at (loc, OPT_Wclass_memaccess,\n+\t\t\t\t   \"%qD writing to an object of type %#qT with \"\n+\t\t\t\t   \"%qs member %qD\",\n+\t\t\t\t   fndecl, desttype, access, fld);\n+\t    }\n+\t  else if (!zero_init_p (desttype))\n+\t    warnfmt = G_(\"%qD writing to an object of type %#qT containing \"\n+\t\t\t \"a pointer to data member%s\");\n+\n+\t  break;\n+\t}\n+      /* Fall through.  */\n+\n+    case BUILT_IN_BZERO:\n+      /* Similarly to the above, diagnose clearing non-trivial or non-\n+\t standard layout objects, or objects of types with no assignmenmt.\n+\t Since the value being written is known to be zero, suggest either\n+\t copy assignment, copy ctor, or default ctor as an alternative,\n+\t depending on what's available.  */\n+\n+      if (hasassign && hasctors[0])\n+\tsuggest = G_(\"; use assignment or value-initialization instead\");\n+      else if (hasassign)\n+\tsuggest = G_(\"; use assignment instead\");\n+      else if (hasctors[0])\n+\tsuggest = G_(\"; use value-initialization instead\");\n+\n+      if (!trivassign)\n+\twarnfmt = G_(\"%qD clearing an object of type %#qT with \"\n+\t\t     \"no trivial copy-assignment%s\");\n+      else if (!trivial)\n+\twarnfmt =  G_(\"%qD clearing an object of non-trivial type %#qT%s\");\n+      else if (!zero_init_p (desttype))\n+\twarnfmt = G_(\"%qD clearing an object of type %#qT containing \"\n+\t\t     \"a pointer-to-member%s\");\n+      break;\n+\n+    case BUILT_IN_BCOPY:\n+    case BUILT_IN_MEMCPY:\n+    case BUILT_IN_MEMMOVE:\n+    case BUILT_IN_MEMPCPY:\n+      /* Determine the type of the source object.  */\n+      srctype = STRIP_NOPS (args[srcidx]);\n+      srctype = TREE_TYPE (TREE_TYPE (srctype));\n+\n+      /* Since it's impossible to determine wheter the byte copy is\n+\t being used in place of assignment to an existing object or\n+\t as a substitute for initialization, assume it's the former.\n+\t Determine the best alternative to use instead depending on\n+\t what's not deleted.  */\n+      if (hasassign && hasctors[1])\n+\tsuggest = G_(\"; use copy-assignment or copy-initialization instead\");\n+      else if (hasassign)\n+\tsuggest = G_(\"; use copy-assignment instead\");\n+      else if (hasctors[1])\n+\tsuggest = G_(\"; use copy-initialization instead\");\n+\n+      if (!trivassign)\n+\twarnfmt = G_(\"%qD writing to an object of type %#qT with no trivial \"\n+\t\t     \"copy-assignment%s\");\n+      else if (!trivially_copyable_p (desttype))\n+\twarnfmt = G_(\"%qD writing to an object of non-trivially copyable \"\n+\t\t     \"type %#qT%s\");\n+      else if (!trivcopy)\n+\twarnfmt = G_(\"%qD writing to an object with a deleted copy constructor\");\n+\n+      else if (!trivial\n+\t       && !VOID_TYPE_P (srctype)\n+\t       && !char_type_p (TYPE_MAIN_VARIANT (srctype))\n+\t       && !same_type_ignoring_top_level_qualifiers_p (desttype,\n+\t\t\t\t\t\t\t      srctype))\n+\t{\n+\t  /* Warn when copying into a non-trivial object from an object\n+\t     of a different type other than void or char.  */\n+\t  warned = warning_at (loc, OPT_Wclass_memaccess,\n+\t\t\t       \"%qD copying an object of non-trivial type \"\n+\t\t\t       \"%#qT from an array of %#qT\",\n+\t\t\t       fndecl, desttype, srctype);\n+\t}\n+      else if (fld\n+\t       && !VOID_TYPE_P (srctype)\n+\t       && !char_type_p (TYPE_MAIN_VARIANT (srctype))\n+\t       && !same_type_ignoring_top_level_qualifiers_p (desttype,\n+\t\t\t\t\t\t\t      srctype))\n+\t{\n+\t  const char *access = TREE_PRIVATE (fld) ? \"private\" : \"protected\";\n+\t  warned = warning_at (loc, OPT_Wclass_memaccess,\n+\t\t\t       \"%qD copying an object of type %#qT with \"\n+\t\t\t       \"%qs member %qD from an array of %#qT; use \"\n+\t\t\t       \"assignment or copy-initialization instead\",\n+\t\t\t       fndecl, desttype, access, fld, srctype);\n+\t}\n+      else if (!trivial && TREE_CODE (args[2]) == INTEGER_CST)\n+\t{\n+\t  /* Finally, warn on partial copies.  */\n+\t  unsigned HOST_WIDE_INT typesize\n+\t    = tree_to_uhwi (TYPE_SIZE_UNIT (desttype));\n+\t  if (unsigned HOST_WIDE_INT partial\n+\t      = tree_to_uhwi (args[2]) % typesize)\n+\t    warned = warning_at (loc, OPT_Wclass_memaccess,\n+\t\t\t\t (typesize - partial > 1\n+\t\t\t\t  ? G_(\"%qD writing to an object of \"\n+\t\t\t\t       \"a non-trivial type %#qT leaves %wu \"\n+\t\t\t\t       \"bytes unchanged\")\n+\t\t\t\t  : G_(\"%qD writing to an object of \"\n+\t\t\t\t       \"a non-trivial type %#qT leaves %wu \"\n+\t\t\t\t       \"byte unchanged\")),\n+\t\t\t\t fndecl, desttype, typesize - partial);\n+\t}\n+      break;\n+\n+    case BUILT_IN_REALLOC:\n+\n+      if (!trivially_copyable_p (desttype))\n+\twarnfmt = G_(\"%qD moving an object of non-trivially copyable type \"\n+\t\t     \"%#qT; use %<new%> and %<delete%> instead\");\n+      else if (!trivcopy)\n+\twarnfmt = G_(\"%qD moving an object of type %#qT with deleted copy \"\n+\t\t     \"constructor; use %<new%> and %<delete%> instead\");\n+      else if (!get_dtor (desttype, tf_none))\n+\twarnfmt = G_(\"%qD moving an object of type %#qT with deleted \"\n+\t\t     \"destructor\");\n+      else if (!trivial\n+\t       && TREE_CODE (args[1]) == INTEGER_CST\n+\t       && tree_int_cst_lt (args[1], TYPE_SIZE_UNIT (desttype)))\n+\t{\n+\t  /* Finally, warn on reallocation into insufficient space.  */\n+\t  warned = warning_at (loc, OPT_Wclass_memaccess,\n+\t\t\t       \"%qD moving an object of non-trivial type \"\n+\t\t\t       \"%#qT and size %E into a region of size %E\",\n+\t\t\t       fndecl, desttype, TYPE_SIZE_UNIT (desttype),\n+\t\t\t       args[1]);\n+\t}\n+      break;\n+\n+    default:\n+      return;\n+    }\n+\n+  if (!warned && !warnfmt)\n+    return;\n+\n+  if (warnfmt)\n+    {\n+      if (suggest)\n+\twarned = warning_at (loc, OPT_Wclass_memaccess,\n+\t\t\t     warnfmt, fndecl, desttype, suggest);\n+      else\n+\twarned = warning_at (loc, OPT_Wclass_memaccess,\n+\t\t\t     warnfmt, fndecl, desttype);\n+    }\n+\n+  if (warned)\n+    inform (location_of (desttype), \"%#qT declared here\", desttype);\n+}\n+\n /* Build and return a call to FN, using NARGS arguments in ARGARRAY.\n    This function performs no overload resolution, conversion, or other\n    high-level operations.  */\n@@ -8216,6 +8603,10 @@ build_cxx_call (tree fn, int nargs, tree *argarray,\n       if (!check_builtin_function_arguments (EXPR_LOCATION (fn), vNULL, fndecl,\n \t\t\t\t\t     nargs, argarray))\n \treturn error_mark_node;\n+\n+      /* Warn if the built-in writes to an object of a non-trivial type.  */\n+      if (nargs)\n+\tmaybe_warn_class_memaccess (loc, fndecl, argarray);\n     }\n \n     /* If it is a built-in array notation function, then the return type of"}, {"sha": "d7027aa1b651609a978b073b372ae205a6c0180a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c3684b7b86da9b6b01f6fb274227fc6401df053e", "patch": "@@ -215,7 +215,8 @@ in the following sections.\n -Wabi=@var{n}  -Wabi-tag  -Wconversion-null  -Wctor-dtor-privacy @gol\n -Wdelete-non-virtual-dtor  -Wliteral-suffix  -Wmultiple-inheritance @gol\n -Wnamespaces  -Wnarrowing @gol\n--Wnoexcept  -Wnoexcept-type  -Wnon-virtual-dtor  -Wreorder  -Wregister @gol\n+-Wnoexcept  -Wnoexcept-type  -Wclass-memaccess @gol\n+-Wnon-virtual-dtor  -Wreorder  -Wregister @gol\n -Weffc++  -Wstrict-null-sentinel  -Wtemplates @gol\n -Wno-non-template-friend  -Wold-style-cast @gol\n -Woverloaded-virtual  -Wno-pmf-conversions @gol\n@@ -2920,6 +2921,23 @@ void g() noexcept;\n void h() @{ f(g); @} // in C++14 calls f<void(*)()>, in C++1z calls f<void(*)()noexcept>\n @end smallexample\n \n+@item -Wclass-memaccess @r{(C++ and Objective-C++ only)}\n+@opindex Wclass-memaccess\n+Warn when the destination of a call to a raw memory function such as\n+@code{memset} or @code{memcpy} is an object of class type writing into which\n+might bypass the class non-trivial or deleted constructor or copy assignment,\n+violate const-correctness or encapsulation, or corrupt the virtual table.\n+Modifying the representation of such objects may violate invariants maintained\n+by member functions of the class.  For example, the call to @code{memset}\n+below is undefined becase it modifies a non-trivial class object and is,\n+therefore, diagnosed.  The safe way to either initialize or clear the storage\n+of objects of such types is by using the appropriate constructor or assignment\n+operator, if one is available.\n+@smallexample\n+std::string str = \"abc\";\n+memset (&str, 0, 3);\n+@end smallexample\n+The @option{-Wclass-memaccess} option is enabled by @option{-Wall}.\n \n @item -Wnon-virtual-dtor @r{(C++ and Objective-C++ only)}\n @opindex Wnon-virtual-dtor"}, {"sha": "6c55f05b677350e209f4fa531df932c98a1bdafb", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=c3684b7b86da9b6b01f6fb274227fc6401df053e", "patch": "@@ -187,9 +187,16 @@ dump_register (const char *suffix, const char *swtch, const char *glob,\n       m_extra_dump_files = XRESIZEVEC (struct dump_file_info,\n \t\t\t\t       m_extra_dump_files,\n \t\t\t\t       m_extra_dump_files_alloced);\n+\n+      /* Construct a new object in the space allocated above.  */\n+      new (m_extra_dump_files + count) dump_file_info ();\n+    }\n+  else\n+    {\n+      /* Zero out the already constructed object.  */\n+      m_extra_dump_files[count] = dump_file_info ();\n     }\n \n-  memset (&m_extra_dump_files[count], 0, sizeof (struct dump_file_info));\n   m_extra_dump_files[count].suffix = suffix;\n   m_extra_dump_files[count].swtch = swtch;\n   m_extra_dump_files[count].glob = glob;"}, {"sha": "6d724b25423fa0fba18e65a798293e1216e8a635", "filename": "gcc/gcc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=c3684b7b86da9b6b01f6fb274227fc6401df053e", "patch": "@@ -1259,9 +1259,9 @@ struct compiler\n   const char *cpp_spec;         /* If non-NULL, substitute this spec\n \t\t\t\t   for `%C', rather than the usual\n \t\t\t\t   cpp_spec.  */\n-  const int combinable;          /* If nonzero, compiler can deal with\n+  int combinable;               /* If nonzero, compiler can deal with\n \t\t\t\t    multiple source files at once (IMA).  */\n-  const int needs_preprocessing; /* If nonzero, source files need to\n+  int needs_preprocessing;       /* If nonzero, source files need to\n \t\t\t\t    be run through a preprocessor.  */\n };\n "}, {"sha": "51dfe77401e8eac474b60935ad22063e281ff3b7", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=c3684b7b86da9b6b01f6fb274227fc6401df053e", "patch": "@@ -4703,8 +4703,8 @@ gen_insn_reserv (md_rtx_info *info)\n   struct insn_reserv *decl = oballoc (struct insn_reserv);\n   rtx def = info->def;\n \n-  struct attr_desc attr;\n-  memset (&attr, 0, sizeof (attr));\n+  struct attr_desc attr = { };\n+\n   attr.name = DEF_ATTR_STRING (XSTR (def, 0));\n   attr.loc = info->loc;\n "}, {"sha": "443d16c1837a9b0885a3a209d5be15be34d0717b", "filename": "gcc/hash-table.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=c3684b7b86da9b6b01f6fb274227fc6401df053e", "patch": "@@ -803,7 +803,10 @@ hash_table<Descriptor, Allocator>::empty_slow ()\n       m_size_prime_index = nindex;\n     }\n   else\n-    memset (entries, 0, size * sizeof (value_type));\n+    {\n+      for ( ; size; ++entries, --size)\n+\t*entries = value_type ();\n+    }\n   m_n_deleted = 0;\n   m_n_elements = 0;\n }"}, {"sha": "c7e3c7107ca9d3a0c3aeed263ea7f3087651e926", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=c3684b7b86da9b6b01f6fb274227fc6401df053e", "patch": "@@ -1471,8 +1471,7 @@ allocate_and_init_ipcp_value (tree source)\n {\n   ipcp_value<tree> *val;\n \n-  val = ipcp_cst_values_pool.allocate ();\n-  memset (val, 0, sizeof (*val));\n+  val = new (ipcp_cst_values_pool.allocate ()) ipcp_value<tree>();\n   val->value = source;\n   return val;\n }\n@@ -1486,8 +1485,8 @@ allocate_and_init_ipcp_value (ipa_polymorphic_call_context source)\n   ipcp_value<ipa_polymorphic_call_context> *val;\n \n   // TODO\n-  val = ipcp_poly_ctx_values_pool.allocate ();\n-  memset (val, 0, sizeof (*val));\n+  val = new (ipcp_poly_ctx_values_pool.allocate ())\n+    ipcp_value<ipa_polymorphic_call_context>();\n   val->value = source;\n   return val;\n }"}, {"sha": "292f3e214def342edcdfa4ba5f3f0f858cf3b8e3", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=c3684b7b86da9b6b01f6fb274227fc6401df053e", "patch": "@@ -3711,7 +3711,7 @@ void\n ipa_free_edge_args_substructures (struct ipa_edge_args *args)\n {\n   vec_free (args->jump_functions);\n-  memset (args, 0, sizeof (*args));\n+  *args = ipa_edge_args ();\n }\n \n /* Free all ipa_edge structures.  */"}, {"sha": "dd4a0926c448a729bce204811137df2ec3382f30", "filename": "gcc/omp-low.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=c3684b7b86da9b6b01f6fb274227fc6401df053e", "patch": "@@ -6320,7 +6320,11 @@ lower_omp_ordered_clauses (gimple_stmt_iterator *gsi_p, gomp_ordered *ord_stmt,\n     return;\n \n   wide_int *folded_deps = XALLOCAVEC (wide_int, 2 * len - 1);\n-  memset (folded_deps, 0, sizeof (*folded_deps) * (2 * len - 1));\n+\n+  /* wide_int is not a POD so it must be default-constructed.  */\n+  for (unsigned i = 0; i != 2 * len - 1; ++i)\n+    new (static_cast<void*>(folded_deps + i)) wide_int ();\n+\n   tree folded_dep = NULL_TREE;\n   /* TRUE if the first dimension's offset is negative.  */\n   bool neg_offset_p = false;"}, {"sha": "8b916607f163e3701a167405c8babb55c7ad2fb2", "filename": "gcc/params.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=c3684b7b86da9b6b01f6fb274227fc6401df053e", "patch": "@@ -42,7 +42,7 @@ struct param_info\n {\n   /* The name used with the `--param <name>=<value>' switch to set this\n      value.  */\n-  const char *const option;\n+  const char *option;\n \n   /* The default value.  */\n   int default_value;\n@@ -54,7 +54,7 @@ struct param_info\n   int max_value;\n \n   /* A short description of the option.  */\n-  const char *const help;\n+  const char *help;\n \n   /* The optional names corresponding to the values.  */\n   const char **value_names;"}, {"sha": "7e48992478b1b397d1d68f26456b1cdbde191469", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c3684b7b86da9b6b01f6fb274227fc6401df053e", "patch": "@@ -1,3 +1,8 @@\n+2017-06-15  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/80560\n+\t* g++.dg/Wclass-memaccess.C: New test.\n+\n 2017-06-15  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/80983"}, {"sha": "4783438888e23820dec213ca14dcf369175b4e2f", "filename": "gcc/testsuite/g++.dg/Wclass-memaccess.C", "status": "added", "additions": 1671, "deletions": 0, "changes": 1671, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWclass-memaccess.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWclass-memaccess.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWclass-memaccess.C?ref=c3684b7b86da9b6b01f6fb274227fc6401df053e", "patch": "@@ -0,0 +1,1671 @@\n+/* PR c++/80560 - warn on undefined memory operations involving non-trivial\n+   types\n+   { dg-do compile }\n+   { dg-options \"-Wclass-memaccess -ftrack-macro-expansion=0\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern \"C\"\n+{\n+void* memcpy (void*, const void*, size_t);\n+void* memmove (void*, const void*, size_t);\n+void* mempcpy (void*, const void*, size_t);\n+void* memset (void*, int, size_t);\n+void* realloc (void*, size_t);\n+}\n+\n+/* Ordinary bzcopy and bzero aren't recognized as special.  */\n+#define bcopy __builtin_bcopy\n+#define bzero __builtin_bzero\n+\n+void sink (void*);\n+\n+#define T(fn, arglist) ((fn arglist), sink (p))\n+\n+#if !defined TEST || TEST == TEST_TRIVIAL\n+\n+/* Trivial can be manipulated by raw memory functions.  */\n+struct Trivial\n+{\n+  int i; unsigned bf: 1; char *s; char a[4];\n+\n+  // Non-copy assignment doesn't make the class non-trivial or not\n+  // trivially assignable.\n+  Trivial& operator= (int);\n+\n+  // Likewise, template assignment doesn't make the class non-trivial\n+  // or not trivially assignable.\n+  template <class U>\n+  Trivial& operator= (U);\n+};\n+\n+void test (Trivial *p, void *q, int x)\n+{\n+  const size_t n = x;\n+\n+  T (bzero, (p, 1));\n+  T (bzero, (p, n));\n+  T (bzero, (p, sizeof *p));\n+  T (bzero, (q, 1));\n+  T (bzero, (q, n));\n+  T (bzero, (q, sizeof *p));\n+\n+  T (bcopy, (p, q, 1));\n+  T (bcopy, (p, q, n));\n+  T (bcopy, (p, q, sizeof *p));\n+  T (bcopy, (q, p, 1));\n+  T (bcopy, (q, p, n));\n+  T (bcopy, (q, p, sizeof *p));\n+\n+  T (memcpy, (p, q, 1));\n+  T (memcpy, (p, q, n));\n+  T (memcpy, (p, q, sizeof *p));\n+  T (memcpy, (q, p, 1));\n+  T (memcpy, (q, p, n));\n+  T (memcpy, (q, p, sizeof *p));\n+\n+  T (memset, (p, 0, 1));\n+  T (memset, (p, 0, n));\n+  T (memset, (p, 0, sizeof *p));\n+  T (memset, (q, 0, 1));\n+  T (memset, (q, 0, n));\n+  T (memset, (q, 0, sizeof *p));\n+\n+  T (memset, (p, 1, 1));\n+  T (memset, (p, 1, n));\n+  T (memset, (p, 1, sizeof *p));\n+  T (memset, (q, 1, 1));\n+  T (memset, (q, 1, n));\n+  T (memset, (q, 1, sizeof *p));\n+\n+  T (memset, (p, x, 1));\n+  T (memset, (p, x, n));\n+  T (memset, (p, x, sizeof *p));\n+  T (memset, (q, x, 1));\n+  T (memset, (q, x, n));\n+  T (memset, (q, x, sizeof *p));\n+\n+  T (memmove, (p, q, 1));\n+  T (memmove, (p, q, n));\n+  T (memmove, (p, q, sizeof *p));\n+  T (memmove, (q, p, 1));\n+  T (memmove, (q, p, n));\n+  T (memmove, (q, p, sizeof *p));\n+\n+  T (q = realloc, (p, 1));\n+  T (q = realloc, (p, n));\n+  T (q = realloc, (p, sizeof *p));\n+\n+  T (q = realloc, (q, 1));\n+  T (q = realloc, (q, n));\n+  T (q = realloc, (q, sizeof *p));\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_TRIVIAL_ACCESS\n+\n+/* TrivialAccess can be manipulated by raw memory functions in contexts\n+   that have access to the trivial specia functions.  */\n+struct TrivialAccess\n+{\n+  int i; unsigned bf: 1; char *s; char a[4];\n+\n+private:\n+  TrivialAccess () = default;\n+  TrivialAccess (const TrivialAccess&) = default;\n+protected:\n+  TrivialAccess& operator= (const TrivialAccess&) = default;\n+\n+  void test_member (const TrivialAccess*, int);\n+\n+  friend void test_friend (TrivialAccess*, const TrivialAccess*, int);\n+};\n+\n+void test (TrivialAccess *p, const TrivialAccess *q, int i)\n+{\n+  void *pv;\n+  (void)&pv;\n+\n+  /* Verify that a warning is issued when the copy ctor and copy\n+     assignment are inaccessible.  */\n+  T (bzero, (p, sizeof *p));        // { dg-warning \"bzero\" }\n+  T (bcopy, (q, p, sizeof *p));     // { dg-warning \"bcopy\" }\n+  T (memcpy, (p, q, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memset, (p, i, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memmove, (p, q, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (pv = realloc, (p, sizeof *p)); // { dg-warning \"realloc\" }\n+}\n+\n+void test_friend (TrivialAccess *p, const TrivialAccess *q, int i)\n+{\n+  void *pv;\n+  (void)&pv;\n+\n+  /* Verify that no warning is issued when the otherwise inaccessible\n+     copy ctor and copy assignment can be accessed within the current\n+     context.  */\n+  T (bzero, (p, sizeof *p));\n+  T (bcopy, (q, p, sizeof *p));\n+  T (memcpy, (p, q, sizeof *p));\n+  T (memset, (p, i, sizeof *p));\n+  T (memmove, (p, q, sizeof *p));\n+  T (pv = realloc, (p, sizeof *p));\n+}\n+\n+void TrivialAccess::test_member (const TrivialAccess *q, int i)\n+{\n+  void *pv;\n+  (void)&pv;\n+\n+  TrivialAccess *p = this;\n+\n+  /* Verify that no warning is issued when the otherwise inaccessible\n+     copy ctor and copy assignment can be accessed within the current\n+     context.  */\n+  T (bzero, (p, sizeof *p));\n+  T (bcopy, (q, p, sizeof *p));\n+  T (memcpy, (p, q, sizeof *p));\n+  T (memset, (p, i, sizeof *p));\n+  T (memmove, (p, q, sizeof *p));\n+  T (pv = realloc, (p, sizeof *p));\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_HAS_DEFAULT\n+\n+/* HasDefault is trivially copyable but should be initialized by\n+   the ctor, not bzero or memset.  */\n+struct HasDefault { char a[4]; HasDefault (); };\n+\n+void test (HasDefault *p, const HasDefault &x,\n+\t   void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  // HasDefault is neither trivial nor standard-layout.  The warning\n+  // should mention the former since it's more permissive than the latter\n+  // and so more informative.\n+  T (bzero, (p, sizeof *p));        // { dg-warning \"bzero(\\[^\\n\\r\\]*). clearing an object of non-trivial type .struct HasDefault.; use assignment or value-initialization instead\" }\n+\n+  T (memset, (p, 0, sizeof *p));    // { dg-warning \".void\\\\* memset(\\[^\\n\\r\\]*). clearing an object of non-trivial type .struct HasDefault.; use assignment or value-initialization instead\" }\n+\n+  T (memset, (p, 1, sizeof *p));    // { dg-warning \".void\\\\* memset(\\[^\\n\\r\\]*). writing to an object of non-trivial type .struct HasDefault.; use assignment instead\" }\n+\n+  T (memset, (p, i, sizeof *p));    // { dg-warning \".void\\\\* memset(\\[^\\n\\r\\]*). writing to an object of non-trivial type .struct HasDefault.; use assignment instead\" }\n+\n+  // Copying from another object of the same type is fine.\n+  T (bcopy, (&x, p, sizeof *p));\n+  T (bcopy, (&x, p, n));\n+\n+  T (memcpy, (p, &x, sizeof *p));\n+  T (memcpy, (p, &x, n));\n+\n+  // Copying from a void* or character buffer is also fine.\n+  T (bcopy, (q, p, sizeof *p));\n+  T (bcopy, (q, p, n));\n+  T (bcopy, (s, p, sizeof *p));\n+  T (bcopy, (s, p, n));\n+\n+  T (memcpy, (p, q, sizeof *p));\n+  T (memcpy, (p, q, n));\n+  T (memcpy, (p, s, sizeof *p));\n+  T (memcpy, (p, s, n));\n+\n+  T (memmove, (p, q, sizeof *p));\n+  T (memmove, (p, q, n));\n+  T (memmove, (p, s, sizeof *p));\n+  T (memmove, (p, s, n));\n+\n+  T (mempcpy, (p, q, sizeof *p));\n+  T (mempcpy, (p, q, n));\n+  T (mempcpy, (p, s, sizeof *p));\n+  T (mempcpy, (p, s, n));\n+\n+  // ...but partial copies are diagnosed.\n+  T (memcpy, (p, &x, 1));   // { dg-warning \"writing to an object of a non-trivial type .struct HasDefault. leaves 3 bytes unchanged\" } */\n+  T (memmove, (p, q, 2));   // { dg-warning \"writing to an object of a non-trivial type .struct HasDefault. leaves 2 bytes unchanged\" } */\n+  T (mempcpy, (p, q, 3));   // { dg-warning \"writing to an object of a non-trivial type .struct HasDefault. leaves 1 byte unchanged\" } */\n+\n+  // Otherwise, copying from an object of an unrelated type is diagnosed.\n+  T (memcpy, (p, ia, sizeof *p));  // { dg-warning \".void\\\\* memcpy(\\[^\\n\\r\\]*). copying an object of non-trivial type .struct HasDefault. from an array of .const int.\" }\n+  extern long *ip;\n+  T (memcpy, (p, ip, sizeof *p));  // { dg-warning \".void\\\\* memcpy(\\[^\\n\\r\\]*). copying an object of non-trivial type .struct HasDefault. from an array of .long.\" }\n+\n+  T (memmove, (p, ia, sizeof *p)); // { dg-warning \".void\\\\* memmove(\\[^\\n\\r\\]*). copying an object of non-trivial type .struct HasDefault. from an array of .const int.\" }\n+\n+  T (mempcpy, (p, ia, sizeof *p)); // { dg-warning \".void\\\\* mempcpy(\\[^\\n\\r\\]*). copying an object of non-trivial type .struct HasDefault. from an array of .const int.\" }\n+\n+  // Reallocating is the same as calling memcpy except that only\n+  // shrinking reallocation is diagnosed.\n+  T (q = realloc, (p, 1));   // { dg-warning \"moving an object of non-trivial type .struct HasDefault. and size 4 into a region of size 1\" }\n+  T (q = realloc, (p, n));\n+  T (q = realloc, (p, sizeof *p));\n+  T (q = realloc, (p, sizeof *p + 1));\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_HAS_TEMPLATE_DEFAULT\n+\n+/* HasTemplateDefault should be initialized by means of the ctor,\n+   not zeroed out by bzero/memset.  */\n+struct HasTemplateDefault\n+{\n+  template <class U>\n+  HasTemplateDefault (U);\n+};\n+\n+void test (HasTemplateDefault *p, const HasTemplateDefault &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  // Zeroing out is diagnosed because value initialization is\n+  // invalid (the template ctor makes default ctor unavailable).\n+  T (bzero, (p, sizeof *p));        // { dg-warning \"bzero\" }\n+  T (memset, (p, 0, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, 1, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, i, sizeof *p));    // { dg-warning \"memset\" }\n+\n+  // Copying from an object of any type is okay.\n+  T (bcopy, (&x, p, sizeof *p));\n+  T (bcopy, (q, p, sizeof *p));\n+  T (bcopy, (s, p, sizeof *p));\n+  T (bcopy, (ia, p, sizeof *p));    // { dg-warning \"bcopy\" }\n+\n+  T (memcpy, (p, &x, sizeof *p));\n+  T (memcpy, (p, q, sizeof *p));\n+  T (memcpy, (p, s, sizeof *p));\n+  T (memcpy, (p, ia, sizeof *p));   // { dg-warning \"memcpy\" }\n+\n+  T (memmove, (p, &x, sizeof *p));\n+  T (memmove, (p, q, sizeof *p));\n+  T (memmove, (p, s, sizeof *p));\n+  T (memmove, (p, ia, sizeof *p));  // { dg-warning \"memmove\" }\n+\n+  T (mempcpy, (p, &x, sizeof *p));\n+  T (mempcpy, (p, q, sizeof *p));\n+  T (mempcpy, (p, s, sizeof *p));\n+  T (mempcpy, (p, ia, sizeof *p));  // { dg-warning \"mempcpy\" }\n+\n+  // Reallocating is the same as calling memcpy.\n+  T (q = realloc, (p, 1));\n+  T (q = realloc, (p, n));\n+  T (q = realloc, (p, sizeof *p));\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_HAS_COPY\n+\n+/* HasCopy should be copied using the copy ctor or assignment, not\n+   by memcpy or memmove.  Since it's non-trivial, it should not be zeroed\n+   out by bzero/memset either and should instead use assignment and/or\n+   value initialization.  */\n+struct HasCopy { int i; HasCopy (const HasCopy&); };\n+\n+void test (HasCopy *p, const HasCopy &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  // Zeroing out is diagnosed because value initialization is invalid\n+  // (the copy ctor makes no default ctor unavailable).  Since the type\n+  // has no default ctor verify that the suggested alternative does not\n+  // include value-initialization.\n+  T (bzero, (p, sizeof *p));        // { dg-warning \"clearing an object of non-trivial type .struct HasCopy.; use assignment instead\" }\n+  T (memset, (p, 0, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, 1, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, i, sizeof *p));    // { dg-warning \"memset\" }\n+\n+  // Copying from an object of any type is diagnosed.\n+  T (bcopy, (&x, p, sizeof *p));    // { dg-warning \"bcopy\" }\n+  T (bcopy, (q, p, sizeof *p));     // { dg-warning \"bcopy\" }\n+  T (bcopy, (s, p, sizeof *p));     // { dg-warning \"bcopy\" }\n+  T (bcopy, (ia, p, sizeof *p));    // { dg-warning \"bcopy\" }\n+\n+  T (memcpy, (p, &x, sizeof *p));   // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, q, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, s, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, ia, sizeof *p));   // { dg-warning \"memcpy\" }\n+\n+  T (memmove, (p, &x, sizeof *p));  // { dg-warning \"memmove\" }\n+  T (memmove, (p, q, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, s, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, ia, sizeof *p));  // { dg-warning \"memmove\" }\n+\n+  T (mempcpy, (p, &x, sizeof *p));  // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, q, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, s, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, ia, sizeof *p));  // { dg-warning \"mempcpy\" }\n+\n+  // Reallocating is the same as calling memcpy.\n+  T (q = realloc, (p, 1));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, n));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, sizeof *p));  // { dg-warning \"realloc\" }\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_HAS_DEFAULT_AND_COPY\n+\n+/* HasDefaultAndCopy is like HasCopy above but its default ctor takes\n+   a default argument to verify that the suggested alternative offered\n+   by the warning includes the default ctor (i.e., the test verifies\n+   that the default ctor is recognized as such despite taking an argument.  */\n+\n+struct HasDefaultAndCopy\n+{\n+  HasDefaultAndCopy (int = 0);   // default ctor\n+  HasDefaultAndCopy (const HasDefaultAndCopy&);\n+};\n+\n+void test (HasDefaultAndCopy *p, const HasDefaultAndCopy &x)\n+{\n+  T (bzero, (p, sizeof *p));        // { dg-warning \"clearing an object of non-trivial type .struct HasDefaultAndCopy.; use assignment or value-initialization instead\" }\n+  T (memset, (p, 0, sizeof *p));    // { dg-warning \"clearing an object of non-trivial type .struct HasDefaultAndCopy.; use assignment or value-initialization instead\" }\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_HAS_PRIVATE_COPY\n+\n+/* HasPrivateCopy cannot be copied using memcpy or memmove.  Since it's\n+   non-trivial, it it should not be zeroed out by bzero/memset either\n+   and should instead use assignment and/or value initialization.  */\n+struct HasPrivateCopy {\n+  int i;\n+private:\n+  HasPrivateCopy (const HasPrivateCopy&);\n+};\n+\n+void test (HasPrivateCopy *p, const HasPrivateCopy &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  // Zeroing out is diagnosed because value initialization is\n+  // invalid (the copy ctor makes no default ctor unavailable).\n+  // Verify also that the suggestion offers assignment but not\n+  // value initialization (since the lattare is not available).\n+  T (bzero, (p, sizeof *p));        // { dg-warning \"clearing an object of non-trivial type .struct HasPrivateCopy.; use assignment instead\" }\n+  T (memset, (p, 0, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, 1, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, i, sizeof *p));    // { dg-warning \"memset\" }\n+\n+  // Copying from an object of any type is diagnosed.\n+  T (memcpy, (p, &x, sizeof *p));   // { dg-warning \".void\\\\* memcpy(\\[^\\n\\r\\]*). writing to an object of non-trivially copyable type .struct HasPrivateCopy.; use copy-assignment instead\" }\n+  T (memcpy, (p, q, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, s, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, ia, sizeof *p));   // { dg-warning \"memcpy\" }\n+\n+  T (memmove, (p, &x, sizeof *p));  // { dg-warning \"memmove\" }\n+  T (memmove, (p, q, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, s, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, ia, sizeof *p));  // { dg-warning \"memmove\" }\n+\n+  T (mempcpy, (p, &x, sizeof *p));  // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, q, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, s, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, ia, sizeof *p));  // { dg-warning \"mempcpy\" }\n+\n+  // Reallocating is the same as calling memcpy.\n+  T (q = realloc, (p, 1));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, n));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, sizeof *p));  // { dg-warning \"realloc\" }\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_HAS_DTOR\n+\n+/* HasDtor should be initialized using aggregate or memberwise intialization,\n+   not bzero or memset.  */\n+struct HasDtor { int i; ~HasDtor (); };\n+\n+void test (HasDtor *p, const HasDtor &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  // Zeroing out is diagnosed only because it's difficult not to.\n+  // Otherwise, a class that's non-trivial only because it has\n+  // a non-trivial dtor can be safely zeroed out (that's what\n+  // value-initializing it does).\n+  T (bzero, (p, sizeof *p));        // { dg-warning \"bzero\" }\n+  T (memset, (p, 0, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, 1, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, i, sizeof *p));    // { dg-warning \"memset\" }\n+\n+  // Copying from an object of any type is diagnosed simply because\n+  // a class with a user-defined dtor is not trivially copyable.\n+  T (memcpy, (p, &x, sizeof *p));   // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, q, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, s, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, ia, sizeof *p));   // { dg-warning \"memcpy\" }\n+\n+  T (memmove, (p, &x, sizeof *p));  // { dg-warning \"memmove\" }\n+  T (memmove, (p, q, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, s, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, ia, sizeof *p));  // { dg-warning \"memmove\" }\n+\n+  T (mempcpy, (p, &x, sizeof *p));  // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, q, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, s, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, ia, sizeof *p));  // { dg-warning \"mempcpy\" }\n+\n+  // Reallocating is the same as calling memcpy.\n+  T (q = realloc, (p, 1));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, n));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, sizeof *p));  // { dg-warning \"realloc\" }\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_HAS_DELETED_DTOR\n+\n+// HasDeletedDtor is trivial so clearing and cpying it is okay.\n+// Relocation would bypass the deleted dtor and so it's diagnosed.\n+\n+struct HasDeletedDtor\n+{\n+  int i;\n+  ~HasDeletedDtor () = delete;\n+};\n+\n+void test (HasDeletedDtor *p, const HasDeletedDtor &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  T (bzero, (p, sizeof *p));\n+  T (memset, (p, 0, sizeof *p));\n+  T (memset, (p, 1, sizeof *p));\n+  T (memset, (p, i, sizeof *p));\n+\n+  T (memcpy, (p, &x, sizeof *p));\n+  T (memcpy, (p, q, sizeof *p));\n+  T (memcpy, (p, s, sizeof *p));\n+  T (memcpy, (p, ia, sizeof *p));\n+\n+  T (memmove, (p, &x, sizeof *p));\n+  T (memmove, (p, q, sizeof *p));\n+  T (memmove, (p, s, sizeof *p));\n+  T (memmove, (p, ia, sizeof *p));\n+\n+  T (mempcpy, (p, &x, sizeof *p));\n+  T (mempcpy, (p, q, sizeof *p));\n+  T (mempcpy, (p, s, sizeof *p));\n+  T (mempcpy, (p, ia, sizeof *p));\n+\n+  // Reallocating is diagnosed.\n+  T (q = realloc, (p, 1));          // { dg-warning \"moving an object of type .struct HasDeletedDtor. with deleted destructor\" }\n+  T (q = realloc, (p, n));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, sizeof *p));  // { dg-warning \"realloc\" }\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_HAS_PRIVATE_DTOR\n+\n+// Unlike HasDeletedDtor, HasPrivateDtor is okay to zero-out and copy\n+// but not relocate because doing so would bypass the deleted dtor..\n+\n+struct HasPrivateDtor\n+{\n+  int i;\n+private:\n+  ~HasPrivateDtor ();\n+};\n+\n+void test (HasPrivateDtor *p, const HasPrivateDtor &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  T (bzero, (p, sizeof *p));        // { dg-warning \"clearing an object of non-trivial type .struct HasPrivateDtor.; use assignment or value-initialization instead\" }\n+  T (memset, (p, 0, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, 1, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, i, sizeof *p));    // { dg-warning \"memset\" }\n+\n+  T (memcpy, (p, &x, sizeof *p));   // { dg-warning \"writing to an object of non-trivially copyable type .struct HasPrivateDtor.; use copy-assignment or copy-initialization instead\" }\n+  T (memcpy, (p, q, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, s, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, ia, sizeof *p));   // { dg-warning \"memcpy\" }\n+\n+  T (memmove, (p, &x, sizeof *p));  // { dg-warning \"memmove\" }\n+  T (memmove, (p, q, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, s, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, ia, sizeof *p));  // { dg-warning \"memmove\" }\n+\n+  T (mempcpy, (p, &x, sizeof *p));  // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, q, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, s, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, ia, sizeof *p));  // { dg-warning \"mempcpy\" }\n+\n+  // Reallocating is diagnosed.\n+  T (q = realloc, (p, 1));          // { dg-warning \"moving an object of non-trivially copyable type .struct HasPrivateDtor.\" }\n+  T (q = realloc, (p, n));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, sizeof *p));  // { dg-warning \"realloc\" }\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_HAS_COPY_ASSIGN\n+\n+/* HasCopyAssign should be copied using the copy ctor or assignment, not\n+   by memcpy or memmove.  */\n+struct HasCopyAssign { void operator= (HasCopyAssign&); };\n+\n+void test (HasCopyAssign *p, const HasCopyAssign &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  // Zeroing out is diagnosed because it when used with an existing\n+  // (already constructed) object in lieu of assigning a new value\n+  // to it would bypass the user-defined assignment.\n+  T (bzero, (p, sizeof *p));        // { dg-warning \"bzero\" }\n+  T (memset, (p, 0, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, 1, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, i, sizeof *p));    // { dg-warning \"memset\" }\n+\n+  // Copying from an object of any type is diagnosed.\n+  T (memcpy, (p, &x, sizeof *p));   // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, q, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, s, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, ia, sizeof *p));   // { dg-warning \"memcpy\" }\n+\n+  T (memmove, (p, &x, sizeof *p));  // { dg-warning \"memmove\" }\n+  T (memmove, (p, q, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, s, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, ia, sizeof *p));  // { dg-warning \"memmove\" }\n+\n+  T (mempcpy, (p, &x, sizeof *p));  // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, q, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, s, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, ia, sizeof *p));  // { dg-warning \"mempcpy\" }\n+\n+  // Reallocating is the same as calling memcpy.\n+  T (q = realloc, (p, 1));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, n));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, sizeof *p));  // { dg-warning \"realloc\" }\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_HAS_MOVE_ASSIGN\n+\n+/* Like HasCopyAssign, HasMoveAssign should be copied using the copy\n+   ctor or assignment, not by memcpy or memmove.  */\n+struct HasMoveAssign\n+{\n+#if __cplusplus > 199711L\n+  void operator= (HasMoveAssign&&);\n+#else\n+  // C++ 98 has no reference references.  Simply repeat the HasCopyAssign\n+  // test to avoid having to add a conditional to every dg-warning directive.\n+  void operator= (const HasMoveAssign&);\n+#endif\n+};\n+\n+void test (HasMoveAssign *p, const HasMoveAssign &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  // Zeroing out is diagnosed because it when used with an existing\n+  // (already constructed) object in lieu of assigning a new value\n+  // to it would bypass the user-defined assignment.\n+  T (bzero, (p, sizeof *p));        // { dg-warning \"bzero\" }\n+  T (memset, (p, 0, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, 1, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, i, sizeof *p));    // { dg-warning \"memset\" }\n+\n+  // Copying from an object of any type is diagnosed.\n+  T (memcpy, (p, &x, sizeof *p));   // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, q, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, s, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, ia, sizeof *p));   // { dg-warning \"memcpy\" }\n+\n+  T (memmove, (p, &x, sizeof *p));  // { dg-warning \"memmove\" }\n+  T (memmove, (p, q, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, s, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, ia, sizeof *p));  // { dg-warning \"memmove\" }\n+\n+  T (mempcpy, (p, &x, sizeof *p));  // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, q, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, s, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, ia, sizeof *p));  // { dg-warning \"mempcpy\" }\n+\n+  // Reallocating is the same as calling memcpy.\n+  T (q = realloc, (p, 1));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, n));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, sizeof *p));  // { dg-warning \"realloc\" }\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_TRIVIAL_COPY_HAS_MOVE_ASSIGN\n+\n+/* TrivialCopyHasMoveAssign should be copied using the copy ctor\n+   or assignment, not by memcpy or memmove.  */\n+struct TrivialCopyHasMoveAssign\n+{\n+  typedef TrivialCopyHasMoveAssign Self;\n+\n+  Self& operator= (const Self&) = default;\n+\n+#if __cplusplus > 199711L\n+  Self& operator= (Self&&);\n+#else\n+  // C++ 98 has no reference references.  Fake the test by adding\n+  // a non-const overload of the assignment operator (which should\n+  // have the same effect).\n+  Self& operator= (Self&);\n+#endif\n+};\n+\n+void test (TrivialCopyHasMoveAssign *p, const TrivialCopyHasMoveAssign &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  // Zeroing out is diagnosed because it when used with an existing\n+  // (already constructed) object in lieu of assigning a new value\n+  // to it would bypass the user-defined assignment.\n+  T (bzero, (p, sizeof *p));        // { dg-warning \"bzero\" }\n+  T (memset, (p, 0, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, 1, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, i, sizeof *p));    // { dg-warning \"memset\" }\n+\n+  // Copying from an object of any type is diagnosed.\n+  T (memcpy, (p, &x, sizeof *p));   // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, q, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, s, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, ia, sizeof *p));   // { dg-warning \"memcpy\" }\n+\n+  T (memmove, (p, &x, sizeof *p));  // { dg-warning \"memmove\" }\n+  T (memmove, (p, q, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, s, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, ia, sizeof *p));  // { dg-warning \"memmove\" }\n+\n+  T (mempcpy, (p, &x, sizeof *p));  // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, q, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, s, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, ia, sizeof *p));  // { dg-warning \"mempcpy\" }\n+\n+  // Reallocating is the same as calling memcpy.\n+  T (q = realloc, (p, 1));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, n));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, sizeof *p));  // { dg-warning \"realloc\" }\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_TRIVIAL_MOVE_HAS_COPY_ASSIGN\n+\n+/* TrivialMoveNontrivialCopyAssign should be copied using the copy ctor\n+   or assignment, not by memcpy or memmove.  */\n+struct TrivialMoveNontrivialCopyAssign\n+{\n+  typedef TrivialMoveNontrivialCopyAssign Self;\n+\n+  Self& operator= (const Self&);\n+#if __cplusplus > 199711L\n+  // C++ 98 has no reference references.  Fake the test by simply\n+  // not declaring the move assignment.\n+  Self& operator= (Self&&) = default;\n+#endif\n+};\n+\n+void test (TrivialMoveNontrivialCopyAssign *p,\n+\t   const TrivialMoveNontrivialCopyAssign &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  // Zeroing out is diagnosed because it when used with an existing\n+  // (already constructed) object in lieu of assigning a new value\n+  // to it would bypass the user-defined assignment.\n+  T (bzero, (p, sizeof *p));        // { dg-warning \"bzero\" }\n+  T (memset, (p, 0, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, 1, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, i, sizeof *p));    // { dg-warning \"memset\" }\n+\n+  // Copying from an object of any type is diagnosed.\n+  T (memcpy, (p, &x, sizeof *p));   // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, q, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, s, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, ia, sizeof *p));   // { dg-warning \"memcpy\" }\n+\n+  T (memmove, (p, &x, sizeof *p));  // { dg-warning \"memmove\" }\n+  T (memmove, (p, q, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, s, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, ia, sizeof *p));  // { dg-warning \"memmove\" }\n+\n+  T (mempcpy, (p, &x, sizeof *p));  // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, q, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, s, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, ia, sizeof *p));  // { dg-warning \"mempcpy\" }\n+\n+  // Reallocating is the same as calling memcpy.\n+  T (q = realloc, (p, 1));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, n));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, sizeof *p));  // { dg-warning \"realloc\" }\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_TRIVIAL_ASSIGN_REF_OVERLOAD\n+\n+/* TrivialAssignRefOverload is a trivial type.  */\n+struct TrivialAssignRefOverload {\n+  int i;\n+  typedef TrivialAssignRefOverload Self;\n+\n+  Self& operator= (Self&) = default;\n+  Self& operator= (const Self&) = delete;\n+  Self& operator= (volatile Self&) = delete;\n+  Self& operator= (const volatile Self&) = delete;\n+};\n+\n+void test (TrivialAssignRefOverload *p, const TrivialAssignRefOverload &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  T (bzero, (p, sizeof *p));\n+  T (memset, (p, 0, sizeof *p));\n+  T (memset, (p, 1, sizeof *p));\n+  T (memset, (p, i, sizeof *p));\n+\n+  T (memcpy, (p, &x, sizeof *p));\n+  T (memcpy, (p, q, sizeof *p));\n+  T (memcpy, (p, s, sizeof *p));\n+  T (memcpy, (p, ia, sizeof *p));\n+\n+  T (memmove, (p, &x, sizeof *p));\n+  T (memmove, (p, q, sizeof *p));\n+  T (memmove, (p, s, sizeof *p));\n+  T (memmove, (p, ia, sizeof *p));\n+\n+  T (mempcpy, (p, &x, sizeof *p));\n+  T (mempcpy, (p, q, sizeof *p));\n+  T (mempcpy, (p, s, sizeof *p));\n+  T (mempcpy, (p, ia, sizeof *p));\n+\n+  T (q = realloc, (p, 1));\n+  T (q = realloc, (p, n));\n+  T (q = realloc, (p, sizeof *p));\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_TRIVIAL_ASSIGN_CSTREF_OVERLOAD\n+\n+/* TrivialAssignCstOverload is a trivial type.  */\n+struct TrivialAssignCstRefOverload {\n+  int i;\n+  typedef TrivialAssignCstRefOverload Self;\n+\n+  Self& operator= (Self&) = delete;\n+  Self& operator= (const Self&) = default;\n+  Self& operator= (volatile Self&) = delete;\n+  Self& operator= (const volatile Self&) = delete;\n+};\n+\n+void test (TrivialAssignCstRefOverload *p,\n+\t   const TrivialAssignCstRefOverload &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  T (bzero, (p, sizeof *p));\n+  T (memset, (p, 0, sizeof *p));\n+  T (memset, (p, 1, sizeof *p));\n+  T (memset, (p, i, sizeof *p));\n+\n+  T (memcpy, (p, &x, sizeof *p));\n+  T (memcpy, (p, q, sizeof *p));\n+  T (memcpy, (p, s, sizeof *p));\n+  T (memcpy, (p, ia, sizeof *p));\n+\n+  T (memmove, (p, &x, sizeof *p));\n+  T (memmove, (p, q, sizeof *p));\n+  T (memmove, (p, s, sizeof *p));\n+  T (memmove, (p, ia, sizeof *p));\n+\n+  T (mempcpy, (p, &x, sizeof *p));\n+  T (mempcpy, (p, q, sizeof *p));\n+  T (mempcpy, (p, s, sizeof *p));\n+  T (mempcpy, (p, ia, sizeof *p));\n+\n+  T (q = realloc, (p, 1));\n+  T (q = realloc, (p, n));\n+  T (q = realloc, (p, sizeof *p));\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_TRIVIAL_REF_HAS_VOLREF_ASSIGN\n+\n+struct TrivialRefHasVolRefAssign\n+{\n+  typedef TrivialRefHasVolRefAssign Self;\n+\n+  Self& operator= (Self&) = default;\n+  Self& operator= (volatile Self&);\n+};\n+\n+void test (TrivialRefHasVolRefAssign *p,\n+\t   const TrivialRefHasVolRefAssign &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  // Zeroing out is diagnosed because it when used with an existing\n+  // (already constructed) object in lieu of assigning a new value\n+  // to it would bypass the user-defined assignment.\n+  T (bzero, (p, sizeof *p));        // { dg-warning \"bzero\" }\n+  T (memset, (p, 0, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, 1, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, i, sizeof *p));    // { dg-warning \"memset\" }\n+\n+  // Copying from an object of any type is diagnosed.\n+  T (memcpy, (p, &x, sizeof *p));   // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, q, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, s, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, ia, sizeof *p));   // { dg-warning \"memcpy\" }\n+\n+  T (memmove, (p, &x, sizeof *p));  // { dg-warning \"memmove\" }\n+  T (memmove, (p, q, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, s, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, ia, sizeof *p));  // { dg-warning \"memmove\" }\n+\n+  T (mempcpy, (p, &x, sizeof *p));  // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, q, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, s, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, ia, sizeof *p));  // { dg-warning \"mempcpy\" }\n+\n+  // Reallocating is the same as calling memcpy.\n+  T (q = realloc, (p, 1));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, n));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, sizeof *p));  // { dg-warning \"realloc\" }\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_HAS_VOLREF_ASSIGN\n+\n+struct HasVolRefAssign {\n+  int i;\n+  typedef HasVolRefAssign Self;\n+\n+  Self& operator= (volatile Self&);\n+};\n+\n+void test (HasVolRefAssign *p, const HasVolRefAssign &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  // Zeroing out is diagnosed because it when used with an existing\n+  // (already constructed) object in lieu of assigning a new value\n+  // to it would bypass the user-defined assignment.\n+  T (bzero, (p, sizeof *p));        // { dg-warning \"bzero\" }\n+  T (memset, (p, 0, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, 1, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, i, sizeof *p));    // { dg-warning \"memset\" }\n+\n+  // Copying from an object of any type is diagnosed.\n+  T (memcpy, (p, &x, sizeof *p));   // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, q, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, s, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, ia, sizeof *p));   // { dg-warning \"memcpy\" }\n+\n+  T (memmove, (p, &x, sizeof *p));  // { dg-warning \"memmove\" }\n+  T (memmove, (p, q, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, s, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, ia, sizeof *p));  // { dg-warning \"memmove\" }\n+\n+  T (mempcpy, (p, &x, sizeof *p));  // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, q, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, s, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, ia, sizeof *p));  // { dg-warning \"mempcpy\" }\n+\n+  // Reallocating is the same as calling memcpy.\n+  T (q = realloc, (p, 1));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, n));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, sizeof *p));  // { dg-warning \"realloc\" }\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_HAS_VIRTUALS\n+\n+/* HasVirtuals should only be manipulated by the special member functions\n+   and not by bzero, memcpy, or any other raw memory function. Doing\n+   otherwse might corrupt the the vtable pointer.  */\n+struct HasVirtuals { int i; virtual void foo (); };\n+\n+void test (HasVirtuals *p, const HasVirtuals &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  // Zeroing out is diagnosed because it corrupts the vtable.\n+  T (bzero, (p, sizeof *p));        // { dg-warning \"bzero\" }\n+  T (memset, (p, 0, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, 1, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, i, sizeof *p));    // { dg-warning \"memset\" }\n+\n+  // Copying is diagnosed because when used to initialize an object\n+  // could incorrectly initialize the vtable.\n+  T (memcpy, (p, &x, sizeof *p));   // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, q, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, s, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, ia, sizeof *p));   // { dg-warning \"memcpy\" }\n+\n+  T (memmove, (p, &x, sizeof *p));  // { dg-warning \"memmove\" }\n+  T (memmove, (p, q, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, s, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, ia, sizeof *p));  // { dg-warning \"memmove\" }\n+\n+  T (mempcpy, (p, &x, sizeof *p));  // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, q, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, s, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, ia, sizeof *p));  // { dg-warning \"mempcpy\" }\n+\n+  // Reallocating is the same as calling memcpy.\n+  T (q = realloc, (p, 1));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, n));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, sizeof *p));  // { dg-warning \"realloc\" }\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_HAS_CONST_DATA\n+\n+/* HasConstData should only be initialized using aggregate initializatoon\n+   and not cleared by bzero, or copied into using memcpy.  Since it's not\n+   assignable allowing, raw memory functions to write into it would defeat\n+   const-correctness.  */\n+struct HasConstData { const char a[4]; };\n+\n+void test (HasConstData *p, const HasConstData &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  // The following is ill-formed because HasConstData's cannot\n+  // be assigned (the assignment is implicitly deleted).  For\n+  // that reason all raw memory operations are diagnosed.\n+  // *p = x;\n+\n+  // Zeroing out is diagnosed because if used with an existing\n+  // (already initialized) object could break const correctness.\n+  // Since the default ctor and copy assignment are both deleted,\n+  // verify that they're not suggested as a possible alternative.\n+  T (bzero, (p, sizeof *p));        // { dg-warning \"clearing an object of type .struct HasConstData. with no trivial copy-assignment \\\\\\[\" \"c++ 11 and later\" { target { c++11 } } }\n+  // { dg-warning \"clearing an object of type .struct HasConstData. with no trivial copy-assignment\" \"c++ 98\" { target { c++98_only } } .-1 }\n+  T (memset, (p, 0, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, 1, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, i, sizeof *p));    // { dg-warning \"memset\" }\n+\n+  // Copying is also diagnosed.\n+  T (memcpy, (p, &x, sizeof *p));   // { dg-warning \"writing to an object of type .struct HasConstData. with no trivial copy-assignment; use copy-initialization instead\" \"c++ 11 and later\" { target { c++11 } } }\n+  // { dg-warning \"writing to an object of type .struct HasConstData. with no trivial copy-assignment\" \"c++ 98\" { target { c++98_only } } .-1 }\n+  T (memcpy, (p, q, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, s, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, ia, sizeof *p));   // { dg-warning \"memcpy\" }\n+\n+  T (memmove, (p, &x, sizeof *p));  // { dg-warning \"memmove\" }\n+  T (memmove, (p, q, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, s, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, ia, sizeof *p));  // { dg-warning \"memmove\" }\n+\n+  T (mempcpy, (p, &x, sizeof *p));  // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, q, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, s, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, ia, sizeof *p));  // { dg-warning \"mempcpy\" }\n+\n+  // Reallocating is not diagnosed except in C++ 98 due to a bug.\n+  T (q = realloc, (p, 1));          // { dg-warning \"moving an object of non-trivially copyable type .struct HasConstData.; use .new. and .delete. instead\" \"c++98\" { target { c++98_only } } }\n+  T (q = realloc, (p, n));          // { dg-warning \"realloc\" \"c++98\" { target { c++98_only } } }\n+  T (q = realloc, (p, sizeof *p));  // { dg-warning \"realloc\" \"c++98\" { target { c++98_only } } }\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_HAS_REFERENCE\n+\n+/* HasReference should only be initialized using aggregate initializatoon\n+   and not cleared by bzero, or copied into using memcpy.  Since it's not\n+   assignable, allowing raw memory functions to write into it could\n+   corrupt the reference.  */\n+struct HasReference { int &ci; };\n+\n+void test (HasReference *p, const HasReference &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  // Similarly to HasConstData, the following is ill-formed because\n+  // Hasreference cannot be assigned (the assignment is implicitly\n+  // deleted).  For that reason all raw memory operations are diagnosed.\n+  // *p = x;\n+\n+  // Zeroing out is diagnosed because if used with an existing\n+  // (already initialized) object would invalidate the reference.\n+  // Since copy-assignment is deleted verify it's not suggested\n+  // as an alternative.  (C++ 11 and later only; C++ 98 is broken).\n+  T (bzero, (p, sizeof *p));        // { dg-warning \"clearing an object of type .struct HasReference. with no trivial copy-assignment \\\\\\[\" \"c++ 11 and later\" { target { c++11 } } }\n+  // { dg-warning \"clearing an object of type .struct HasReference. with no trivial copy-assignment\" \"c++ 98\" { target { c++98_only } } .-1 }\n+  T (bzero, (p, n));                // { dg-warning \"bzero\" }\n+  T (memset, (p, 0, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, 0, n));            // { dg-warning \"memset\" }\n+  T (memset, (p, 1, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, 1, n));            // { dg-warning \"memset\" }\n+  T (memset, (p, i, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, i, n));            // { dg-warning \"memset\" }\n+\n+  // Copying is also diagnosed.\n+  T (memcpy, (p, &x, sizeof *p));   // { dg-warning \"writing to an object of type .struct HasReference. with no trivial copy-assignment; use copy-initialization instead\" \"c++ 11 and later\" { target { c++11 } } }\n+  // { dg-warning \"writing to an object of type .struct HasReference. with no trivial copy-assignment\" \"c++ 98\" { target { c++98_only } } .-1 }\n+  T (memcpy, (p, &x, n));           // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, q, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, q, n));            // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, s, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, s, n));            // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, ia, sizeof *p));   // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, ia, n));           // { dg-warning \"memcpy\" }\n+\n+  T (memmove, (p, &x, sizeof *p));  // { dg-warning \"memmove\" }\n+  T (memmove, (p, q, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, s, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, ia, sizeof *p));  // { dg-warning \"memmove\" }\n+\n+  T (mempcpy, (p, &x, sizeof *p));  // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, q, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, s, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, ia, sizeof *p));  // { dg-warning \"mempcpy\" }\n+\n+  // Reallocating is not diagnosed because a type with a reference\n+  // is (perhaps surprisingly) trivially copyable.  It is diagnosed\n+  // in C++ 98 because of a bug, but it seems like it should be\n+  // diagnosed in all modes.\n+  T (q = realloc, (p, 1));          // { dg-warning \"realloc\" \"c++ 98\" { target { c++98_only } } }\n+  T (q = realloc, (p, n));          // { dg-warning \"realloc\" \"c++ 98\" { target { c++98_only } } }\n+  T (q = realloc, (p, sizeof *p));  // { dg-warning \"realloc\" \"c++ 98\" { target { c++98_only } } }\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_HAS_MEM_DATA_PTR\n+\n+/* HasMemDataPtr should only be initialized using aggregate initializatoon\n+   and not cleared by bzero or written into using memset because its\n+   representation is different from ordinary scalars (a null member data\n+   pointer is all ones).  It can be copied into using memcpy from an object\n+   of the same type or from a character buffer.  */\n+struct HasMemDataPtr { int HasMemDataPtr::*p; };\n+\n+void test (HasMemDataPtr *p, const HasMemDataPtr &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  // Zeroing out is diagnosed because a null member data pointer has\n+  // a representation that's all bits set.\n+  T (bzero, (p, sizeof *p));        // { dg-warning \"clearing an object of type .struct HasMemDataPtr. containing a pointer-to-member\" }\n+  T (bzero, (p, n));                // { dg-warning \"bzero\" }\n+  T (memset, (p, 0, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, 0, n));            // { dg-warning \"memset\" }\n+  T (memset, (p, 1, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, 1, n));            // { dg-warning \"memset\" }\n+  T (memset, (p, i, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, i, n));            // { dg-warning \"memset\" }\n+\n+  // Copying is not diagnosed.\n+  T (memcpy, (p, &x, sizeof *p));\n+  T (memcpy, (p, &x, n));\n+  T (memcpy, (p, q, sizeof *p));\n+  T (memcpy, (p, q, n));\n+  T (memcpy, (p, s, sizeof *p));\n+  T (memcpy, (p, s, n));\n+  T (memcpy, (p, ia, sizeof *p));\n+  T (memcpy, (p, ia, n));\n+\n+  T (memmove, (p, &x, sizeof *p));\n+  T (memmove, (p, q, sizeof *p));\n+  T (memmove, (p, s, sizeof *p));\n+  T (memmove, (p, ia, sizeof *p));\n+\n+  T (mempcpy, (p, &x, sizeof *p));\n+  T (mempcpy, (p, q, sizeof *p));\n+  T (mempcpy, (p, s, sizeof *p));\n+  T (mempcpy, (p, ia, sizeof *p));\n+\n+  // Reallocating is the same as calling memcpy.\n+  T (q = realloc, (p, 1));\n+  T (q = realloc, (p, n));\n+  T (q = realloc, (p, sizeof *p));\n+  T (q = realloc, (p, sizeof *p + 1));\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_HAS_SOME_PRIVATE_DATA\n+\n+/* HasSomePrivateData can be initialized using value initialization\n+   and should not be written to using memset with a non-zero argument.\n+   Doing otherwise would break encapsulation.  */\n+struct HasSomePrivateData { char a[2]; private: char b[2]; };\n+\n+void test (HasSomePrivateData *p, const HasSomePrivateData &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  // Zeroing out is not diagnosed because it's equivalent to value\n+  // initialization.\n+  T (bzero, (p, sizeof *p));\n+  T (memset, (p, 0, sizeof *p));\n+  // Calling memset with a (possibly) non-zero argument is diagnosed\n+  // because it breaks encapsulation.\n+  T (memset, (p, 1, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, i, sizeof *p));    // { dg-warning \"memset\" }\n+\n+  // Calling memcpy to copy from an object of the same type or from\n+  // a character or void buffer is not diagnosed because that's what\n+  // copy construction and copy assignment do.\n+  T (memcpy, (p, &x, sizeof *p));\n+  T (memcpy, (p, &x, n));\n+  T (memcpy, (p, q, sizeof *p));\n+  T (memcpy, (p, s, sizeof *p));\n+  T (memcpy, (p, ia, sizeof *p));   // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, ia, n));           // { dg-warning \"memcpy\" }\n+\n+  // Same as memcpy above.\n+  T (memmove, (p, &x, sizeof *p));\n+  T (memmove, (p, &x, n));\n+  T (memmove, (p, q, sizeof *p));\n+  T (memmove, (p, s, sizeof *p));\n+  T (memmove, (p, ia, sizeof *p));  // { dg-warning \"memmove\" }\n+  T (memmove, (p, ia, n));          // { dg-warning \"memmove\" }\n+\n+  // Same as memcpy above.\n+  T (mempcpy, (p, &x, sizeof *p));\n+  T (mempcpy, (p, &x, n));\n+  T (mempcpy, (p, q, sizeof *p));\n+  T (mempcpy, (p, q, n));\n+  T (mempcpy, (p, s, sizeof *p));\n+  T (mempcpy, (p, s, n));\n+  T (mempcpy, (p, ia, sizeof *p));  // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, ia, n));          // { dg-warning \"mempcpy\" }\n+\n+  // Reallocating is the same as calling memcpy except that partial\n+  // copies are not diagnosed.\n+  T (q = realloc, (p, 1));\n+  T (q = realloc, (p, n));\n+  T (q = realloc, (p, sizeof *p));\n+  T (q = realloc, (p, sizeof *p + 1));\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_HAS_SOME_PROTECTED_DATA\n+\n+/* Similarly to HasSomePrivateData, HasSomeProtectedData can be\n+   initialized using value initialization and should not be written\n+   to using memset with a non-zero argument.  Doing otherwise would\n+   break encapsulation.  */\n+struct HasSomeProtectedData { char a[2]; protected: char b[2]; };\n+\n+void test (HasSomeProtectedData *p, const HasSomeProtectedData &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  // Zeroing out is not diagnosed because it's equivalent to value\n+  // initialization.\n+  T (bzero, (p, sizeof *p));\n+  T (memset, (p, 0, sizeof *p));\n+  // Calling memset with a (possibly) non-zero argument is diagnosed\n+  // because it breaks encapsulation.\n+  T (memset, (p, 1, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, i, sizeof *p));    // { dg-warning \"memset\" }\n+\n+  // Calling memcpy to copy from an object of the same type or from\n+  // a character or void buffer is not diagnosed because that's what\n+  // copy construction and copy assignment do.\n+  T (memcpy, (p, &x, sizeof *p));\n+  T (memcpy, (p, &x, n));\n+  T (memcpy, (p, q, sizeof *p));\n+  T (memcpy, (p, s, sizeof *p));\n+  T (memcpy, (p, ia, sizeof *p));   // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, ia, n));           // { dg-warning \"memcpy\" }\n+\n+  // Same as memcpy above.\n+  T (memmove, (p, &x, sizeof *p));\n+  T (memmove, (p, &x, n));\n+  T (memmove, (p, q, sizeof *p));\n+  T (memmove, (p, s, sizeof *p));\n+  T (memmove, (p, ia, sizeof *p));  // { dg-warning \"memmove\" }\n+  T (memmove, (p, ia, n));          // { dg-warning \"memmove\" }\n+\n+  // Same as memcpy above.\n+  T (mempcpy, (p, &x, sizeof *p));\n+  T (mempcpy, (p, &x, n));\n+  T (mempcpy, (p, q, sizeof *p));\n+  T (mempcpy, (p, q, n));\n+  T (mempcpy, (p, s, sizeof *p));\n+  T (mempcpy, (p, s, n));\n+  T (mempcpy, (p, ia, sizeof *p));  // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, ia, n));          // { dg-warning \"mempcpy\" }\n+\n+  // Reallocating is the same as calling memcpy except that partial\n+  // copies are not diagnosed.\n+  T (q = realloc, (p, 1));\n+  T (q = realloc, (p, n));\n+  T (q = realloc, (p, sizeof *p));\n+  T (q = realloc, (p, sizeof *p + 1));\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_HAS_ALL_PRIVATE_DATA\n+\n+/* Similarly to HasSomePrivateData, HasAllPrivateData should only be\n+   initialized using value initializatoon and should not be written\n+   to using memset with non-zero argument.  They are tested separately\n+   because unlike the former classes, these are standard layout.  */\n+struct HasAllPrivateData { private: char a[4]; };\n+\n+void test (HasAllPrivateData *p, const HasAllPrivateData &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  // Zeroing out is not diagnosed because it's equivalent to value\n+  // initialization.\n+  T (bzero, (p, sizeof *p));\n+  T (memset, (p, 0, sizeof *p));\n+  // Calling memset with a (possibly) non-zero argument is diagnosed\n+  // because it breaks encapsulation.\n+  T (memset, (p, 1, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, i, sizeof *p));    // { dg-warning \"memset\" }\n+\n+  // Calling memcpy to copy from an object of the same type or from\n+  // a character or void buffer is not diagnosed because that's what\n+  // copy construction and copy assignment do.\n+  T (memcpy, (p, &x, sizeof *p));\n+  T (memcpy, (p, &x, n));\n+  T (memcpy, (p, q, sizeof *p));\n+  T (memcpy, (p, s, sizeof *p));\n+  T (memcpy, (p, ia, sizeof *p));   // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, ia, n));           // { dg-warning \"memcpy\" }\n+\n+  // Same as memcpy above.\n+  T (memmove, (p, &x, sizeof *p));\n+  T (memmove, (p, &x, n));\n+  T (memmove, (p, q, sizeof *p));\n+  T (memmove, (p, s, sizeof *p));\n+  T (memmove, (p, ia, sizeof *p));  // { dg-warning \"memmove\" }\n+  T (memmove, (p, ia, n));          // { dg-warning \"memmove\" }\n+\n+  // Same as memcpy above.\n+  T (mempcpy, (p, &x, sizeof *p));\n+  T (mempcpy, (p, &x, n));\n+  T (mempcpy, (p, q, sizeof *p));\n+  T (mempcpy, (p, q, n));\n+  T (mempcpy, (p, s, sizeof *p));\n+  T (mempcpy, (p, s, n));\n+  T (mempcpy, (p, ia, sizeof *p));  // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, ia, n));          // { dg-warning \"mempcpy\" }\n+\n+  // Reallocating is the same as calling memcpy except that partial\n+  // copies are not diagnosed.\n+  T (q = realloc, (p, 1));\n+  T (q = realloc, (p, n));\n+  T (q = realloc, (p, sizeof *p));\n+  T (q = realloc, (p, sizeof *p + 1));\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_HAS_ALL_PROTECTED_DATA\n+\n+/* Similarly to HasSomeProtectedData, HasAllProtectedData should only\n+   be initialized using value initializatoon and should not be written\n+   to using memset with non-zero argument.  They are tested separately\n+   because unlike the former classes, these are standard layout.  */\n+struct HasAllProtectedData { protected: char a[4]; };\n+\n+void test (HasAllProtectedData *p, const HasAllProtectedData &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  // Zeroing out is not diagnosed because it's equivalent to value\n+  // initialization.\n+  T (bzero, (p, sizeof *p));\n+  T (memset, (p, 0, sizeof *p));\n+  // Calling memset with a (possibly) non-zero argument is diagnosed\n+  // because it breaks encapsulation.\n+  T (memset, (p, 1, sizeof *p));    // { dg-warning \"memset\" }\n+  T (memset, (p, i, sizeof *p));    // { dg-warning \"memset\" }\n+\n+  // Calling memcpy to copy from an object of the same type or from\n+  // a character or void buffer is not diagnosed because that's what\n+  // copy construction and copy assignment do.\n+  T (memcpy, (p, &x, sizeof *p));\n+  T (memcpy, (p, &x, n));\n+  T (memcpy, (p, q, sizeof *p));\n+  T (memcpy, (p, s, sizeof *p));\n+  T (memcpy, (p, ia, sizeof *p));   // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, ia, n));           // { dg-warning \"memcpy\" }\n+\n+  // Same as memcpy above.\n+  T (memmove, (p, &x, sizeof *p));\n+  T (memmove, (p, &x, n));\n+  T (memmove, (p, q, sizeof *p));\n+  T (memmove, (p, s, sizeof *p));\n+  T (memmove, (p, ia, sizeof *p));  // { dg-warning \"memmove\" }\n+  T (memmove, (p, ia, n));          // { dg-warning \"memmove\" }\n+\n+  // Same as memcpy above.\n+  T (mempcpy, (p, &x, sizeof *p));\n+  T (mempcpy, (p, &x, n));\n+  T (mempcpy, (p, q, sizeof *p));\n+  T (mempcpy, (p, q, n));\n+  T (mempcpy, (p, s, sizeof *p));\n+  T (mempcpy, (p, s, n));\n+  T (mempcpy, (p, ia, sizeof *p));  // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, ia, n));          // { dg-warning \"mempcpy\" }\n+\n+  // Reallocating is the same as calling memcpy except that partial\n+  // copies are not diagnosed.\n+  T (q = realloc, (p, 1));\n+  T (q = realloc, (p, n));\n+  T (q = realloc, (p, sizeof *p));\n+  T (q = realloc, (p, sizeof *p + 1));\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_DEFAULT_CTOR_PRIVATE_ASSIGN\n+\n+/* Used to verify suggested alternatives.  */\n+struct HasDefaultPrivateAssign\n+{\n+  char a[4];\n+  HasDefaultPrivateAssign ();\n+private:\n+  void operator= (HasDefaultPrivateAssign&);\n+};\n+\n+void test (HasDefaultPrivateAssign *p, const HasDefaultPrivateAssign &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  // HasDefaultPrivateAssign isn't trivial or assignable.  Verify\n+  // that the alternative suggested in the warning is to use copy or\n+  // default but not assignment.\n+  T (bzero, (p, sizeof *p));   // { dg-warning \"bzero(\\[^\\n\\r\\]*). clearing an object of type .struct HasDefaultPrivateAssign. with no trivial copy-assignment; use value-initialization instead\" \"c++ 11 and later\" { target { c++11 } } }\n+  // { dg-warning \"bzero(\\[^\\n\\r\\]*). clearing an object of type .struct HasDefaultPrivateAssign. with no trivial copy-assignment; use value-initialization instead\" \"c++ 98\" { target { c++98_only } } .-1 }\n+\n+  T (memset, (p, 0, sizeof *p));   // { dg-warning \".void\\\\* memset(\\[^\\n\\r\\]*). clearing an object of type .struct HasDefaultPrivateAssign. with (deleted|no trivial) copy-assignment; use value-initialization instead\" }\n+\n+  T (memset, (p, 1, sizeof *p));   // { dg-warning \".void\\\\* memset(\\[^\\n\\r\\]*). writing to an object of type .struct HasDefaultPrivateAssign. with (deleted|no trivial) copy-assignment\" }\n+\n+  T (memset, (p, i, sizeof *p));   // { dg-warning \".void\\\\* memset(\\[^\\n\\r\\]*). writing to an object of type .struct HasDefaultPrivateAssign. with (deleted|no trivial) copy-assignment\" }\n+\n+  // Copying from another object of the same type is diagnosed because\n+  // the copy assignment is inaccessible.  Verify that the suggested\n+  // alternative is not copy assignment (C++ 98 is busted).\n+  T (memcpy, (p, &x, sizeof *p));   // { dg-warning \".void\\\\* memcpy(\\[^\\n\\r\\]*). writing to an object of type .struct HasDefaultPrivateAssign. with no trivial copy-assignment; use copy-initialization instead\" \"c++11 and later\" { target c++11 } }\n+  // { dg-warning \".void\\\\* memcpy(\\[^\\n\\r\\]*). writing to an object of type .struct HasDefaultPrivateAssign. with no trivial copy-assignment\" \"c++98\" { target c++98_only } .-1 }\n+  T (memcpy, (p, &x, n));           // { dg-warning \"memcpy\" }\n+\n+  // Similarly for copying from a void* or character buffer.\n+  T (memcpy, (p, q, sizeof *p));    // { dg-warning \".void\\\\* memcpy(\\[^\\n\\r\\]*). writing to an object of type .struct HasDefaultPrivateAssign. with no trivial copy-assignment; use copy-initialization instead\" \"c++11 and later\" { target c++11 } }\n+  // { dg-warning \".void\\\\* memcpy(\\[^\\n\\r\\]*). writing to an object of type .struct HasDefaultPrivateAssign. with no trivial copy-assignment\" \"c++98\" { target c++98_only } ,-1 }\n+  T (memcpy, (p, q, n));            // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, s, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, s, n));            // { dg-warning \"memcpy\" }\n+\n+  T (memmove, (p, q, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, q, n));           // { dg-warning \"memmove\" }\n+  T (memmove, (p, s, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, s, n));           // { dg-warning \"memmove\" }\n+\n+  T (mempcpy, (p, q, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, q, n));           // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, s, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, s, n));           // { dg-warning \"mempcpy\" }\n+\n+  // Same for partial copies are diagnosed.\n+  T (memcpy, (p, &x, 1));   // { dg-warning \"writing to an object of type .struct HasDefaultPrivateAssign. with (deleted|no trivial) copy-assignment\" } */\n+  T (memmove, (p, q, 2));   // { dg-warning \"memmove\" } */\n+  T (mempcpy, (p, q, 3));   // { dg-warning \"mempcpy\" } */\n+\n+  // Otherwise, copying from an object of an unrelated type is diagnosed.\n+  T (memcpy, (p, ia, sizeof *p));  // { dg-warning \"writing to an object of type .struct HasDefaultPrivateAssign. with (deleted|no trivial) copy-assignment.\" }\n+  T (memmove, (p, ia, sizeof *p)); // { dg-warning \"memmove\" }\n+  T (mempcpy, (p, ia, sizeof *p)); // { dg-warning \"mempcpy\" }\n+\n+  // Reallocating is the same as calling memcpy.\n+  T (q = realloc, (p, 1));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, n));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, sizeof *p));  // { dg-warning \"realloc\" }\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_DEFAULT_CTOR_DELETED_ASSIGN\n+\n+/* Used to verify suggested alternatives.  */\n+struct HasDefaultDeletedAssign\n+{\n+  char a[4];\n+  HasDefaultDeletedAssign ();\n+private:\n+  void operator= (HasDefaultDeletedAssign&);\n+};\n+\n+void test (HasDefaultDeletedAssign *p, const HasDefaultDeletedAssign &x,\n+\t   const void *q, const unsigned char *s, const int ia[])\n+{\n+  const int i = *ia;\n+  const size_t n = *ia;\n+\n+  // HasDefaultDeletedAssign isn't trivial or assignable.  Verify\n+  // that the alternative suggested in the warning is to use copy or\n+  // default but not assignment.\n+  T (bzero, (p, sizeof *p));   // { dg-warning \"bzero(\\[^\\n\\r\\]*). clearing an object of type .struct HasDefaultDeletedAssign. with no trivial copy-assignment; use value-initialization instead\" \"c++ 11 and later\" { target { c++11 } } }\n+  // { dg-warning \"bzero(\\[^\\n\\r\\]*). clearing an object of type .struct HasDefaultDeletedAssign. with no trivial copy-assignment; use value-initialization instead\" \"c++ 98\" { target { c++98_only } } .-1 }\n+\n+  T (memset, (p, 0, sizeof *p));   // { dg-warning \".void\\\\* memset(\\[^\\n\\r\\]*). clearing an object of type .struct HasDefaultDeletedAssign. with (deleted|no trivial) copy-assignment; use value-initialization instead\" }\n+\n+  T (memset, (p, 1, sizeof *p));   // { dg-warning \".void\\\\* memset(\\[^\\n\\r\\]*). writing to an object of type .struct HasDefaultDeletedAssign. with (deleted|no trivial) copy-assignment\" }\n+\n+  T (memset, (p, i, sizeof *p));   // { dg-warning \".void\\\\* memset(\\[^\\n\\r\\]*). writing to an object of type .struct HasDefaultDeletedAssign. with (deleted|no trivial) copy-assignment\" }\n+\n+  // Copying from another object of the same type is diagnosed because\n+  // the copy assignment is inaccessible.  Verify that the suggested\n+  // alternative is not copy assignment (C++ 98 is busted).\n+  T (memcpy, (p, &x, sizeof *p));   // { dg-warning \".void\\\\* memcpy(\\[^\\n\\r\\]*). writing to an object of type .struct HasDefaultDeletedAssign. with no trivial copy-assignment; use copy-initialization instead\" \"c++11 and later\" { target c++11 } }\n+  // { dg-warning \".void\\\\* memcpy(\\[^\\n\\r\\]*). writing to an object of type .struct HasDefaultDeletedAssign. with no trivial copy-assignment\" \"c++98\" { target c++98_only } .-1 }\n+  T (memcpy, (p, &x, n));           // { dg-warning \"memcpy\" }\n+\n+  // Similarly for copying from a void* or character buffer.\n+  T (memcpy, (p, q, sizeof *p));    // { dg-warning \".void\\\\* memcpy(\\[^\\n\\r\\]*). writing to an object of type .struct HasDefaultDeletedAssign. with no trivial copy-assignment; use copy-initialization instead\" \"c++11 and later\" { target c++11 } }\n+  // { dg-warning \".void\\\\* memcpy(\\[^\\n\\r\\]*). writing to an object of type .struct HasDefaultDeletedAssign. with no trivial copy-assignment\" \"c++98\" { target c++98_only } ,-1 }\n+  T (memcpy, (p, q, n));            // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, s, sizeof *p));    // { dg-warning \"memcpy\" }\n+  T (memcpy, (p, s, n));            // { dg-warning \"memcpy\" }\n+\n+  T (memmove, (p, q, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, q, n));           // { dg-warning \"memmove\" }\n+  T (memmove, (p, s, sizeof *p));   // { dg-warning \"memmove\" }\n+  T (memmove, (p, s, n));           // { dg-warning \"memmove\" }\n+\n+  T (mempcpy, (p, q, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, q, n));           // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, s, sizeof *p));   // { dg-warning \"mempcpy\" }\n+  T (mempcpy, (p, s, n));           // { dg-warning \"mempcpy\" }\n+\n+  // Same for partial copies are diagnosed.\n+  T (memcpy, (p, &x, 1));   // { dg-warning \"writing to an object of type .struct HasDefaultDeletedAssign. with (deleted|no trivial) copy-assignment\" } */\n+  T (memmove, (p, q, 2));   // { dg-warning \"memmove\" } */\n+  T (mempcpy, (p, q, 3));   // { dg-warning \"mempcpy\" } */\n+\n+  // Otherwise, copying from an object of an unrelated type is diagnosed.\n+  T (memcpy, (p, ia, sizeof *p));  // { dg-warning \"writing to an object of type .struct HasDefaultDeletedAssign. with (deleted|no trivial) copy-assignment.\" }\n+  T (memmove, (p, ia, sizeof *p)); // { dg-warning \"memmove\" }\n+  T (mempcpy, (p, ia, sizeof *p)); // { dg-warning \"mempcpy\" }\n+\n+  // Reallocating is the same as calling memcpy.\n+  T (q = realloc, (p, 1));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, n));          // { dg-warning \"realloc\" }\n+  T (q = realloc, (p, sizeof *p));  // { dg-warning \"realloc\" }\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_EXPRESSION\n+\n+void test_expr (int i)\n+{\n+  struct TestClass { TestClass () { } };\n+  TestClass a, b;\n+\n+  static void *p;\n+\n+  T (bzero, (i < 0 ? &a : &b, 1));  // { dg-warning \"bzero\" }\n+}\n+\n+#endif\n+\n+#if !defined TEST || TEST == TEST_CTOR\n+\n+void test_ctor ()\n+{\n+#undef T\n+#define T(fn, arglist) (fn arglist, sink (this))\n+\n+  static void *p;\n+\n+  struct TestBase\n+  {\n+    TestBase ()\n+    {\n+      /* A ctor of a base class with no virtual function can do whatever\n+\t it wants.  */\n+      T (bzero, (this, sizeof *this));\n+      T (memset, (this, 0, sizeof *this));\n+      T (memcpy, (this, p, sizeof *this));\n+      T (memmove, (this, p, sizeof *this));\n+      T (mempcpy, (this, p, sizeof *this));\n+    }\n+\n+    ~TestBase ()\n+    {\n+      /* A dtor of a base class with no virtual function can do whatever\n+\t it wants.  */\n+      T (bzero, (this, sizeof *this));\n+      T (memset, (this, 0, sizeof *this));\n+      T (memcpy, (this, p, sizeof *this));\n+      T (memmove, (this, p, sizeof *this));\n+      T (mempcpy, (this, p, sizeof *this));\n+    }\n+  };\n+\n+  struct TestBaseVtable\n+  {\n+    TestBaseVtable ()\n+    {\n+      /* A ctor of a base class with virtual function is treated\n+\t as an ordinary function.  */\n+      T (bzero, (this, sizeof *this));      // { dg-warning \"bzero\" }\n+      T (memset, (this, 0, sizeof *this));  // { dg-warning \"memset\" }\n+      T (memcpy, (this, p, sizeof *this));  // { dg-warning \"memcpy\" }\n+      T (memmove, (this, p, sizeof *this)); // { dg-warning \"memmove\" }\n+      T (mempcpy, (this, p, sizeof *this)); // { dg-warning \"mempcpy\" }\n+    }\n+\n+    ~TestBaseVtable ()\n+    {\n+      /* A dtor of a base class with virtual function is treated\n+\t as an ordinary function.  */\n+      T (bzero, (this, sizeof *this));      // { dg-warning \"bzero\" }\n+      T (memset, (this, 0, sizeof *this));  // { dg-warning \"memset\" }\n+      T (memcpy, (this, p, sizeof *this));  // { dg-warning \"memcpy\" }\n+      T (memmove, (this, p, sizeof *this)); // { dg-warning \"memmove\" }\n+      T (mempcpy, (this, p, sizeof *this)); // { dg-warning \"mempcpy\" }\n+    }\n+\n+    virtual void foo ();\n+  };\n+\n+  struct TestDerived: HasDefault\n+  {\n+    TestDerived ()\n+    {\n+      /* A derived class ctor is treated as an ordinary function.  */\n+      T (bzero, (this, sizeof *this));      // { dg-warning \"bzero\" }\n+      T (memset, (this, 0, sizeof *this));  // { dg-warning \"memset\" }\n+      T (memcpy, (this, p, sizeof *this));\n+      T (memmove, (this, p, sizeof *this));\n+      T (mempcpy, (this, p, sizeof *this));\n+    }\n+  };\n+\n+  struct TestDerivedDtor: HasDefault\n+  {\n+    ~TestDerivedDtor ()\n+    {\n+      /* A derived class dtor is treated as an ordinary function though\n+\t it probably shouldn't be unless the base dtor is trivial.  But\n+\t it doesn't seem worth the trouble.  */\n+      T (bzero, (this, sizeof *this));      // { dg-warning \"bzero\" }\n+      T (memset, (this, 0, sizeof *this));  // { dg-warning \"memset\" }\n+      T (memcpy, (this, p, sizeof *this));  // { dg-warning \"memcpy\" }\n+      T (memmove, (this, p, sizeof *this)); // { dg-warning \"memmove\" }\n+      T (mempcpy, (this, p, sizeof *this)); // { dg-warning \"mempcpy\" }\n+    }\n+  };\n+}\n+\n+#endif\n+\n+// { dg-prune-output \"defaulted and deleted functions\" }"}, {"sha": "72927bf0c340b691bd126c7fddfb3cc1c10e30ac", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=c3684b7b86da9b6b01f6fb274227fc6401df053e", "patch": "@@ -268,7 +268,7 @@ static void\n emit_case_bit_tests (gswitch *swtch, tree index_expr,\n \t\t     tree minval, tree range, tree maxval)\n {\n-  struct case_bit_test test[MAX_CASE_BIT_TESTS];\n+  struct case_bit_test test[MAX_CASE_BIT_TESTS] = { };\n   unsigned int i, j, k;\n   unsigned int count;\n \n@@ -293,8 +293,6 @@ emit_case_bit_tests (gswitch *swtch, tree index_expr,\n   int prec = TYPE_PRECISION (word_type_node);\n   wide_int wone = wi::one (prec);\n \n-  memset (&test, 0, sizeof (test));\n-\n   /* Get the edge for the default case.  */\n   tmp = gimple_switch_default_label (swtch);\n   default_bb = label_to_block (CASE_LABEL (tmp));"}, {"sha": "cbdd439571b97fe920d121332514557c72e4852c", "filename": "gcc/vec.h", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3684b7b86da9b6b01f6fb274227fc6401df053e/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=c3684b7b86da9b6b01f6fb274227fc6401df053e", "patch": "@@ -407,6 +407,26 @@ struct GTY((user)) vec\n {\n };\n \n+/* Default-construct N elements in DST.  */\n+\n+template <typename T>\n+inline void\n+vec_default_construct (T *dst, unsigned n)\n+{\n+  for ( ; n; ++dst, --n)\n+    ::new (static_cast<void*>(dst)) T ();\n+}\n+\n+/* Copy-construct N elements in DST from *SRC.  */\n+\n+template <typename T>\n+inline void\n+vec_copy_construct (T *dst, const T *src, unsigned n)\n+{\n+  for ( ; n; ++dst, ++src, --n)\n+    ::new (static_cast<void*>(dst)) T (*src);\n+}\n+\n /* Type to provide NULL values for vec<T, A, L>.  This is used to\n    provide nil initializers for vec instances.  Since vec must be\n    a POD, we cannot have proper ctor/dtor for it.  To initialize\n@@ -612,7 +632,7 @@ vec_safe_grow_cleared (vec<T, A, vl_embed> *&v, unsigned len CXX_MEM_STAT_INFO)\n {\n   unsigned oldlen = vec_safe_length (v);\n   vec_safe_grow (v, len PASS_MEM_STAT);\n-  memset (&(v->address ()[oldlen]), 0, sizeof (T) * (len - oldlen));\n+  vec_default_construct (v->address () + oldlen, len - oldlen);\n }\n \n \n@@ -818,7 +838,7 @@ vec<T, A, vl_embed>::copy (ALONE_MEM_STAT_DECL) const\n     {\n       vec_alloc (new_vec, len PASS_MEM_STAT);\n       new_vec->embedded_init (len, len);\n-      memcpy (new_vec->address (), m_vecdata, sizeof (T) * len);\n+      vec_copy_construct (new_vec->address (), m_vecdata, len);\n     }\n   return new_vec;\n }\n@@ -835,7 +855,7 @@ vec<T, A, vl_embed>::splice (const vec<T, A, vl_embed> &src)\n   if (len)\n     {\n       gcc_checking_assert (space (len));\n-      memcpy (address () + length (), src.address (), len * sizeof (T));\n+      vec_copy_construct (end (), src.address (), len);\n       m_vecpfx.m_num += len;\n     }\n }\n@@ -1089,13 +1109,12 @@ inline void\n vec<T, A, vl_embed>::quick_grow_cleared (unsigned len)\n {\n   unsigned oldlen = length ();\n-  size_t sz = sizeof (T) * (len - oldlen);\n+  size_t growby = len - oldlen;\n   quick_grow (len);\n-  if (sz != 0)\n-    memset (&(address ()[oldlen]), 0, sz);\n+  if (growby != 0)\n+    vec_default_construct (address () + oldlen, growby);\n }\n \n-\n /* Garbage collection support for vec<T, A, vl_embed>.  */\n \n template<typename T>\n@@ -1454,7 +1473,7 @@ vec<T, va_heap, vl_ptr>::reserve (unsigned nelems, bool exact MEM_STAT_DECL)\n   va_heap::reserve (m_vec, nelems, exact PASS_MEM_STAT);\n   if (handle_auto_vec)\n     {\n-      memcpy (m_vec->address (), oldvec->address (), sizeof (T) * oldsize);\n+      vec_copy_construct (m_vec->address (), oldvec->address (), oldsize);\n       m_vec->m_vecpfx.m_num = oldsize;\n     }\n \n@@ -1616,10 +1635,10 @@ inline void\n vec<T, va_heap, vl_ptr>::safe_grow_cleared (unsigned len MEM_STAT_DECL)\n {\n   unsigned oldlen = length ();\n-  size_t sz = sizeof (T) * (len - oldlen);\n+  size_t growby = len - oldlen;\n   safe_grow (len PASS_MEM_STAT);\n-  if (sz != 0)\n-    memset (&(address ()[oldlen]), 0, sz);\n+  if (growby != 0)\n+    vec_default_construct (address () + oldlen, growby);\n }\n \n "}, {"sha": "694137a736043b4029dd3be8fcb2d47beb0035cd", "filename": "libcpp/line-map.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3684b7b86da9b6b01f6fb274227fc6401df053e/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3684b7b86da9b6b01f6fb274227fc6401df053e/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=c3684b7b86da9b6b01f6fb274227fc6401df053e", "patch": "@@ -62,7 +62,8 @@ extern unsigned num_macro_tokens_counter;\n \n line_maps::~line_maps ()\n {\n-  htab_delete (location_adhoc_data_map.htab);\n+  if (location_adhoc_data_map.htab)\n+    htab_delete (location_adhoc_data_map.htab);\n }\n \n /* Hash function for location_adhoc_data hashtable.  */\n@@ -347,7 +348,7 @@ void\n linemap_init (struct line_maps *set,\n \t      source_location builtin_location)\n {\n-  memset (set, 0, sizeof (struct line_maps));\n+  *set = line_maps ();\n   set->highest_location = RESERVED_LOCATION_COUNT - 1;\n   set->highest_line = RESERVED_LOCATION_COUNT - 1;\n   set->location_adhoc_data_map.htab ="}, {"sha": "c6550a38627b4c3ed1e8620a2ccd71f9920943e3", "filename": "libitm/beginend.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3684b7b86da9b6b01f6fb274227fc6401df053e/libitm%2Fbeginend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3684b7b86da9b6b01f6fb274227fc6401df053e/libitm%2Fbeginend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fbeginend.cc?ref=c3684b7b86da9b6b01f6fb274227fc6401df053e", "patch": "@@ -431,7 +431,7 @@ GTM::gtm_transaction_cp::save(gtm_thread* tx)\n   // Save everything that we might have to restore on restarts or aborts.\n   jb = tx->jb;\n   undolog_size = tx->undolog.size();\n-  memcpy(&alloc_actions, &tx->alloc_actions, sizeof(alloc_actions));\n+  alloc_actions = tx->alloc_actions;\n   user_actions_size = tx->user_actions.size();\n   id = tx->id;\n   prop = tx->prop;\n@@ -449,7 +449,7 @@ GTM::gtm_transaction_cp::commit(gtm_thread* tx)\n   // commits of nested transactions. Allocation actions must be committed\n   // before committing the snapshot.\n   tx->jb = jb;\n-  memcpy(&tx->alloc_actions, &alloc_actions, sizeof(alloc_actions));\n+  tx->alloc_actions = alloc_actions;\n   tx->id = id;\n   tx->prop = prop;\n }\n@@ -485,7 +485,7 @@ GTM::gtm_thread::rollback (gtm_transaction_cp *cp, bool aborting)\n       prop = cp->prop;\n       if (cp->disp != abi_disp())\n \tset_abi_disp(cp->disp);\n-      memcpy(&alloc_actions, &cp->alloc_actions, sizeof(alloc_actions));\n+      alloc_actions = cp->alloc_actions;\n       nesting = cp->nesting;\n     }\n   else"}, {"sha": "b857bff59fe593d276981b722d95f196a34bc84c", "filename": "libitm/method-ml.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3684b7b86da9b6b01f6fb274227fc6401df053e/libitm%2Fmethod-ml.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3684b7b86da9b6b01f6fb274227fc6401df053e/libitm%2Fmethod-ml.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fmethod-ml.cc?ref=c3684b7b86da9b6b01f6fb274227fc6401df053e", "patch": "@@ -138,7 +138,11 @@ struct ml_mg : public method_group\n     // This store is only executed while holding the serial lock, so relaxed\n     // memory order is sufficient here.  Same holds for the memset.\n     time.store(0, memory_order_relaxed);\n-    memset(orecs, 0, sizeof(atomic<gtm_word>) * L2O_ORECS);\n+    // The memset below isn't strictly kosher because it bypasses\n+    // the non-trivial assignment operator defined by std::atomic.  Using\n+    // a local void* is enough to prevent GCC from warning for this.\n+    void *p = orecs;\n+    memset(p, 0, sizeof(atomic<gtm_word>) * L2O_ORECS);\n   }\n };\n "}]}