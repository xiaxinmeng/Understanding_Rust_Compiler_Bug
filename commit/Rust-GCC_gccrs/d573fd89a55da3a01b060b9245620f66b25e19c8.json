{"sha": "d573fd89a55da3a01b060b9245620f66b25e19c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU3M2ZkODlhNTVkYTNhMDFiMDYwYjkyNDU2MjBmNjZiMjVlMTljOA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2014-05-09T05:01:08Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-05-09T05:01:08Z"}, "message": "mmap.c (backtrace_free): If freeing a large aligned block of memory, call munmap rather than holding onto it.\n\n\t* mmap.c (backtrace_free): If freeing a large aligned block of\n\tmemory, call munmap rather than holding onto it.\n\t(backtrace_vector_grow): When growing a vector, double the number\n\tof pages requested.  When releasing the old version of a grown\n\tvector, pass the correct size to backtrace_free.\n\nFrom-SVN: r210256", "tree": {"sha": "28483b89cea2278d730597de17a15c749c38766e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28483b89cea2278d730597de17a15c749c38766e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d573fd89a55da3a01b060b9245620f66b25e19c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d573fd89a55da3a01b060b9245620f66b25e19c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d573fd89a55da3a01b060b9245620f66b25e19c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d573fd89a55da3a01b060b9245620f66b25e19c8/comments", "author": null, "committer": null, "parents": [{"sha": "0600049c866d8e77bde895cb15024314f6a825a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0600049c866d8e77bde895cb15024314f6a825a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0600049c866d8e77bde895cb15024314f6a825a0"}], "stats": {"total": 36, "additions": 34, "deletions": 2}, "files": [{"sha": "adb54d8f5c3f8f86a923bbec9e0ee61c1faddefd", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d573fd89a55da3a01b060b9245620f66b25e19c8/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d573fd89a55da3a01b060b9245620f66b25e19c8/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=d573fd89a55da3a01b060b9245620f66b25e19c8", "patch": "@@ -1,3 +1,11 @@\n+2014-05-08  Ian Lance Taylor  <iant@google.com>\n+\n+\t* mmap.c (backtrace_free): If freeing a large aligned block of\n+\tmemory, call munmap rather than holding onto it.\n+\t(backtrace_vector_grow): When growing a vector, double the number\n+\tof pages requested.  When releasing the old version of a grown\n+\tvector, pass the correct size to backtrace_free.\n+\n 2014-03-07  Ian Lance Taylor  <iant@google.com>\n \n \t* sort.c (backtrace_qsort): Use middle element as pivot."}, {"sha": "5a9f6299bc026e74dd72aa5f8bd41c141fc859d3", "filename": "libbacktrace/mmap.c", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d573fd89a55da3a01b060b9245620f66b25e19c8/libbacktrace%2Fmmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d573fd89a55da3a01b060b9245620f66b25e19c8/libbacktrace%2Fmmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fmmap.c?ref=d573fd89a55da3a01b060b9245620f66b25e19c8", "patch": "@@ -164,6 +164,26 @@ backtrace_free (struct backtrace_state *state, void *addr, size_t size,\n {\n   int locked;\n \n+  /* If we are freeing a large aligned block, just release it back to\n+     the system.  This case arises when growing a vector for a large\n+     binary with lots of debug info.  Calling munmap here may cause us\n+     to call mmap again if there is also a large shared library; we\n+     just live with that.  */\n+  if (size >= 16 * 4096)\n+    {\n+      size_t pagesize;\n+\n+      pagesize = getpagesize ();\n+      if (((uintptr_t) addr & (pagesize - 1)) == 0\n+\t  && (size & (pagesize - 1)) == 0)\n+\t{\n+\t  /* If munmap fails for some reason, just add the block to\n+\t     the freelist.  */\n+\t  if (munmap (addr, size) == 0)\n+\t    return;\n+\t}\n+    }\n+\n   /* If we can acquire the lock, add the new space to the free list.\n      If we can't acquire the lock, just leak the memory.\n      __sync_lock_test_and_set returns the old state of the lock, so we\n@@ -209,14 +229,18 @@ backtrace_vector_grow (struct backtrace_state *state,size_t size,\n \t    alc = pagesize;\n \t}\n       else\n-\talc = (alc + pagesize - 1) & ~ (pagesize - 1);\n+\t{\n+\t  alc *= 2;\n+\t  alc = (alc + pagesize - 1) & ~ (pagesize - 1);\n+\t}\n       base = backtrace_alloc (state, alc, error_callback, data);\n       if (base == NULL)\n \treturn NULL;\n       if (vec->base != NULL)\n \t{\n \t  memcpy (base, vec->base, vec->size);\n-\t  backtrace_free (state, vec->base, vec->alc, error_callback, data);\n+\t  backtrace_free (state, vec->base, vec->size + vec->alc,\n+\t\t\t  error_callback, data);\n \t}\n       vec->base = base;\n       vec->alc = alc - vec->size;"}]}