{"sha": "3c9b5053e065cabfd67d38ffcf9496903fe0c0a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M5YjUwNTNlMDY1Y2FiZmQ2N2QzOGZmY2Y5NDk2OTAzZmUwYzBhOA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2005-10-09T10:34:47Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2005-10-09T10:34:47Z"}, "message": "PR libstdc++/24061 (issue 6.19)\n\n2005-10-09  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/24061 (issue 6.19)\n\t* include/tr1/hashtable (struct node_const_iterator, struct\n\thashtable_const_iterator): New, add const variants to enable separate\n\toverloadings for iterator and const_iterator in unordered_set and\n\tunordered_multiset (as required by issue 6.19).\n\t(class hashtable): Change the mutable_iterators template parameter\n\tto constant_iterators and adjust throughout the logic.\n\t(hashtable::insert(iterator, const value_type&), erase(iterator)\n\terase(iterator, iterator)): New, as per issue 6.19.\n\t(hashtable::m_erase(node*, node**)): New, called by erase(iterator)\n\tand erase(const_iterator).\n\t(hashtable::Insert_Conv_Type): New, used by insert(iterator,\n\tconst value_type&) and insert(const_iterator, const value_type&)\n\tto delegate the work to insert(const value_type&).\n\t* include/tr1/unordered_map (class unordered_map, unordered_multimap):\n\tAdjust typedefs.\n\t* include/tr1/unordered_set (class unordered_set, unordered_multiset):\n\tLikewise.\n\t* testsuite/tr1/6_containers/unordered/erase/24061-map.cc: New.\n\t* testsuite/tr1/6_containers/unordered/erase/24061-multimap.cc: New.\n\t* testsuite/tr1/6_containers/unordered/erase/24061-multiset.cc: New.\n\t* testsuite/tr1/6_containers/unordered/erase/24061-set.cc: New.\n\t* testsuite/tr1/6_containers/unordered/insert/24061-map.cc: New.\n\t* testsuite/tr1/6_containers/unordered/insert/24061-multimap.cc: New.\n\t* testsuite/tr1/6_containers/unordered/insert/24061-multiset.cc: New.\n\t* testsuite/tr1/6_containers/unordered/insert/24061-set.cc: New.\n\nFrom-SVN: r105138", "tree": {"sha": "fe8764bbbf341678abdaf5189481a6bde5585d09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe8764bbbf341678abdaf5189481a6bde5585d09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/comments", "author": null, "committer": null, "parents": [{"sha": "d8aa859602ccb350684455d54fd54e5c6f42d000", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8aa859602ccb350684455d54fd54e5c6f42d000", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8aa859602ccb350684455d54fd54e5c6f42d000"}], "stats": {"total": 1123, "additions": 977, "deletions": 146}, "files": [{"sha": "653b0de58df4f84e08c82c9c533363042542febe", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=3c9b5053e065cabfd67d38ffcf9496903fe0c0a8", "patch": "@@ -1,3 +1,32 @@\n+2005-10-09  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/24061 (issue 6.19)\n+\t* include/tr1/hashtable (struct node_const_iterator, struct\n+\thashtable_const_iterator): New, add const variants to enable separate\n+\toverloadings for iterator and const_iterator in unordered_set and\n+\tunordered_multiset (as required by issue 6.19).\n+\t(class hashtable): Change the mutable_iterators template parameter\n+\tto constant_iterators and adjust throughout the logic.\n+\t(hashtable::insert(iterator, const value_type&), erase(iterator)\n+\terase(iterator, iterator)): New, as per issue 6.19.\n+\t(hashtable::m_erase(node*, node**)): New, called by erase(iterator)\n+\tand erase(const_iterator).\n+\t(hashtable::Insert_Conv_Type): New, used by insert(iterator,\n+\tconst value_type&) and insert(const_iterator, const value_type&)\n+\tto delegate the work to insert(const value_type&).\n+\t* include/tr1/unordered_map (class unordered_map, unordered_multimap):\n+\tAdjust typedefs.\n+\t* include/tr1/unordered_set (class unordered_set, unordered_multiset):\n+\tLikewise.\n+\t* testsuite/tr1/6_containers/unordered/erase/24061-map.cc: New.\n+\t* testsuite/tr1/6_containers/unordered/erase/24061-multimap.cc: New.\n+\t* testsuite/tr1/6_containers/unordered/erase/24061-multiset.cc: New.\n+\t* testsuite/tr1/6_containers/unordered/erase/24061-set.cc: New.\n+\t* testsuite/tr1/6_containers/unordered/insert/24061-map.cc: New.\n+\t* testsuite/tr1/6_containers/unordered/insert/24061-multimap.cc: New.\n+\t* testsuite/tr1/6_containers/unordered/insert/24061-multiset.cc: New.\n+\t* testsuite/tr1/6_containers/unordered/insert/24061-set.cc: New.\n+\n 2005-10-08  Kazu Hirata  <kazu@codesourcery.com>\n \n \tMerge from csl-arm-branch:"}, {"sha": "36e33b0f418f366db2e146c49acd89adca92fc83", "filename": "libstdc++-v3/include/tr1/hashtable", "status": "modified", "additions": 274, "deletions": 138, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable?ref=3c9b5053e065cabfd67d38ffcf9496903fe0c0a8", "patch": "@@ -157,23 +157,22 @@ namespace Internal\n \t       const node_iterator_base<Value, cache>& y)\n     { return x.m_cur != y.m_cur; }\n \n-  template<typename Value, bool is_const, bool cache>\n+  template<typename Value, bool constant_iterators, bool cache>\n     struct node_iterator\n     : public node_iterator_base<Value, cache>\n     {\n-      typedef Value                                             value_type;\n-      typedef typename IF<is_const, const Value*, Value*>::type pointer;\n-      typedef typename IF<is_const, const Value&, Value&>::type reference;\n-      typedef std::ptrdiff_t                                    difference_type;\n-      typedef std::forward_iterator_tag                       iterator_category;\n+      typedef Value                                    value_type;\n+      typedef typename IF<constant_iterators, const Value*, Value*>::type\n+                                                       pointer;\n+      typedef typename IF<constant_iterators, const Value&, Value&>::type\n+                                                       reference;\n+      typedef std::ptrdiff_t                           difference_type;\n+      typedef std::forward_iterator_tag                iterator_category;\n \n       explicit\n       node_iterator(hash_node<Value, cache>* p = 0)\n       : node_iterator_base<Value, cache>(p) { }\n \n-      node_iterator(const node_iterator<Value, false, cache>& x)\n-      : node_iterator_base<Value, cache>(x.m_cur) { }\n-\n       reference\n       operator*() const\n       { return this->m_cur->m_v; }\n@@ -198,6 +197,48 @@ namespace Internal\n       }\n     };\n \n+  template<typename Value, bool constant_iterators, bool cache>\n+    struct node_const_iterator\n+    : public node_iterator_base<Value, cache>\n+    {\n+      typedef Value                                    value_type;\n+      typedef const Value*                             pointer;\n+      typedef const Value&                             reference;\n+      typedef std::ptrdiff_t                           difference_type;\n+      typedef std::forward_iterator_tag                iterator_category;\n+\n+      explicit\n+      node_const_iterator(hash_node<Value, cache>* p = 0)\n+      : node_iterator_base<Value, cache>(p) { }\n+\n+      node_const_iterator(const node_iterator<Value, constant_iterators,\n+\t\t\t  cache>& x)\n+      : node_iterator_base<Value, cache>(x.m_cur) { }\n+\n+      reference\n+      operator*() const\n+      { return this->m_cur->m_v; }\n+  \n+      pointer\n+      operator->() const\n+      { return &this->m_cur->m_v; }\n+\n+      node_const_iterator&\n+      operator++()\n+      { \n+\tthis->incr(); \n+\treturn *this; \n+      }\n+  \n+      node_const_iterator\n+      operator++(int)\n+      { \n+\tnode_const_iterator tmp(*this);\n+\tthis->incr();\n+\treturn tmp;\n+      }\n+    };\n+\n   template<typename Value, bool cache>\n     struct hashtable_iterator_base\n     {\n@@ -248,15 +289,17 @@ namespace Internal\n \t       const hashtable_iterator_base<Value, cache>& y)\n     { return x.m_cur_node != y.m_cur_node; }\n \n-  template<typename Value, bool is_const, bool cache>\n+  template<typename Value, bool constant_iterators, bool cache>\n     struct hashtable_iterator\n     : public hashtable_iterator_base<Value, cache>\n     {\n-      typedef Value                                             value_type;\n-      typedef typename IF<is_const, const Value*, Value*>::type pointer;\n-      typedef typename IF<is_const, const Value&, Value&>::type reference;\n-      typedef std::ptrdiff_t                                    difference_type;\n-      typedef std::forward_iterator_tag                       iterator_category;\n+      typedef Value                                    value_type;\n+      typedef typename IF<constant_iterators, const Value*, Value*>::type\n+                                                       pointer;\n+      typedef typename IF<constant_iterators, const Value&, Value&>::type\n+                                                       reference;\n+      typedef std::ptrdiff_t                           difference_type;\n+      typedef std::forward_iterator_tag                iterator_category;\n \n       hashtable_iterator(hash_node<Value, cache>* p,\n \t\t\t hash_node<Value, cache>** b)\n@@ -266,9 +309,6 @@ namespace Internal\n       hashtable_iterator(hash_node<Value, cache>** b)\n       : hashtable_iterator_base<Value, cache>(*b, b) { }\n   \n-      hashtable_iterator(const hashtable_iterator<Value, false, cache>& x)\n-      : hashtable_iterator_base<Value, cache>(x.m_cur_node, x.m_cur_bucket) { }\n-\n       reference\n       operator*() const\n       { return this->m_cur_node->m_v; }\n@@ -292,6 +332,50 @@ namespace Internal\n \treturn tmp; }\n     };\n \n+  template<typename Value, bool constant_iterators, bool cache>\n+    struct hashtable_const_iterator\n+    : public hashtable_iterator_base<Value, cache>\n+    {\n+      typedef Value                                    value_type;\n+      typedef const Value*                             pointer;\n+      typedef const Value&                             reference;\n+      typedef std::ptrdiff_t                           difference_type;\n+      typedef std::forward_iterator_tag                iterator_category;\n+\n+      hashtable_const_iterator(hash_node<Value, cache>* p,\n+\t\t\t       hash_node<Value, cache>** b)\n+      : hashtable_iterator_base<Value, cache>(p, b) { }\n+\n+      explicit\n+      hashtable_const_iterator(hash_node<Value, cache>** b)\n+      : hashtable_iterator_base<Value, cache>(*b, b) { }\n+  \n+      hashtable_const_iterator(const hashtable_iterator<Value,\n+\t\t\t       constant_iterators, cache>& x)\n+      : hashtable_iterator_base<Value, cache>(x.m_cur_node, x.m_cur_bucket) { }\n+\n+      reference\n+      operator*() const\n+      { return this->m_cur_node->m_v; }\n+  \n+      pointer\n+      operator->() const\n+      { return &this->m_cur_node->m_v; }\n+\n+      hashtable_const_iterator&\n+      operator++()\n+      { \n+\tthis->incr();\n+\treturn *this;\n+      }\n+  \n+      hashtable_const_iterator\n+      operator++(int)\n+      { \n+\thashtable_const_iterator tmp(*this);\n+\tthis->incr();\n+\treturn tmp; }\n+    };\n } // namespace Internal\n \n // ----------------------------------------------------------------------\n@@ -843,10 +927,9 @@ namespace tr1\n   // Storing it may improve lookup speed by reducing the number of times\n   // we need to call the Equal function.\n   \n-  // mutable_iterators: bool.  true if hashtable::iterator is a mutable\n-  // iterator, false if iterator and const_iterator are both const \n-  // iterators.  This is true for unordered_map and unordered_multimap,\n-  // false for unordered_set and unordered_multiset.\n+  // constant_iterators: bool.  true if iterator and const_iterator are\n+  // both constant iterator types.  This is true for unordered_set and\n+  // unordered_multiset, false for unordered_map and unordered_multimap.\n   \n   // unique_keys: bool.  true if the return value of hashtable::count(k)\n   // is always at most one, false if it may be an arbitrary number.  This\n@@ -859,20 +942,20 @@ namespace tr1\n \t   typename H1, typename H2,\n \t   typename H, typename RehashPolicy,\n \t   bool cache_hash_code,\n-\t   bool mutable_iterators,\n+\t   bool constant_iterators,\n \t   bool unique_keys>\n     class hashtable\n     : public Internal::rehash_base<RehashPolicy,\n \t\t\t\t   hashtable<Key, Value, Allocator, ExtractKey,\n \t\t\t\t\t     Equal, H1, H2, H, RehashPolicy,\n-\t\t\t\t\t     cache_hash_code, mutable_iterators,\n+\t\t\t\t\t     cache_hash_code, constant_iterators,\n \t\t\t\t\t     unique_keys> >,\n       public Internal::hash_code_base<Key, Value, ExtractKey, Equal, H1, H2, H,\n \t\t\t\t      cache_hash_code>,\n       public Internal::map_base<Key, Value, ExtractKey, unique_keys,\n \t\t\t\thashtable<Key, Value, Allocator, ExtractKey,\n \t\t\t\t\t  Equal, H1, H2, H, RehashPolicy,\n-\t\t\t\t\t  cache_hash_code, mutable_iterators,\n+\t\t\t\t\t  cache_hash_code, constant_iterators,\n \t\t\t\t\t  unique_keys> >\n     {\n     public:\n@@ -887,16 +970,18 @@ namespace tr1\n       typedef typename Allocator::reference                  reference;\n       typedef typename Allocator::const_reference            const_reference;\n       \n-      typedef Internal::node_iterator<value_type, !mutable_iterators,\n+      typedef Internal::node_iterator<value_type, constant_iterators,\n \t\t\t\t      cache_hash_code>\n         local_iterator;\n-      typedef Internal::node_iterator<value_type, true, cache_hash_code>\n+      typedef Internal::node_const_iterator<value_type, constant_iterators,\n+\t\t\t\t\t    cache_hash_code>\n         const_local_iterator;\n \n-      typedef Internal::hashtable_iterator<value_type, !mutable_iterators,\n+      typedef Internal::hashtable_iterator<value_type, constant_iterators,\n \t\t\t\t\t   cache_hash_code>\n         iterator;\n-      typedef Internal::hashtable_iterator<value_type, true, cache_hash_code>\n+      typedef Internal::hashtable_const_iterator<value_type, constant_iterators,\n+\t\t\t\t\t\t cache_hash_code>\n         const_iterator;\n \n     private:\n@@ -1068,6 +1153,12 @@ namespace tr1\n \t\t\t\t    std::pair<iterator, bool>, iterator>::type\n         Insert_Return_Type;\n \n+      typedef typename Internal::IF<unique_keys,\n+\t\t\t\t    Internal::extract1st<Insert_Return_Type>,\n+\t\t\t\t    Internal::identity<Insert_Return_Type>\n+                                   >::type\n+        Insert_Conv_Type;\n+\n       node*\n       find_node(node* p, const key_type& k,\n \t\ttypename hashtable::hash_code_t c) const;\n@@ -1085,34 +1176,48 @@ namespace tr1\n \treturn this->insert(v, std::tr1::integral_constant<bool,\n \t\t\t    unique_keys>());\n       }\n-  \n-      Insert_Return_Type\n+\n+      iterator\n+      insert(iterator, const value_type& v)\n+      { return iterator(Insert_Conv_Type()(this->insert(v))); }\n+      \n+      const_iterator\n       insert(const_iterator, const value_type& v)\n-      { return this->insert(v); }\n+      { return const_iterator(Insert_Conv_Type()(this->insert(v))); }\n \n       template<typename InIter>\n         void\n         insert(InIter first, InIter last);\n \n-      void\n-      erase(const_iterator);\n+      iterator\n+      erase(iterator);\n   \n+      const_iterator\n+      erase(const_iterator);\n+ \n       size_type\n       erase(const key_type&);\n-  \n-      void\n+\n+      iterator\n+      erase(iterator, iterator);\n+\t\n+      const_iterator\n       erase(const_iterator, const_iterator);\n-  \n+\n       void\n       clear();\n+      \n+    private:\n+      // For erase(iterator) and erase(const_iterator).\n+      void m_erase(node*, node**);\n \n     public:\n       // Set number of buckets to be apropriate for container of n element.\n-      void rehash (size_type n);\n+      void rehash(size_type n);\n       \n     private:\n       // Unconditionally change size of bucket array to n.\n-      void m_rehash (size_type n);\n+      void m_rehash(size_type n);\n     };\n \n   //----------------------------------------------------------------------\n@@ -1121,9 +1226,9 @@ namespace tr1\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n-    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::node*\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+\t   bool c, bool ci, bool u>\n+    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::node*\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     m_allocate_node(const value_type& v)\n     {\n       node* n = m_node_allocator.allocate(1);\n@@ -1143,9 +1248,9 @@ namespace tr1\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n+\t   bool c, bool ci, bool u>\n     void\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     m_deallocate_node(node* n)\n     {\n       get_allocator().destroy(&n->m_v);\n@@ -1155,9 +1260,9 @@ namespace tr1\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n+\t   bool c, bool ci, bool u>\n     void\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     m_deallocate_nodes(node** array, size_type n)\n     {\n       for (size_type i = 0; i < n; ++i)\n@@ -1176,9 +1281,9 @@ namespace tr1\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n-    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::node**\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+\t   bool c, bool ci, bool u>\n+    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::node**\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     m_allocate_buckets(size_type n)\n     {\n       bucket_allocator_t alloc(m_node_allocator);\n@@ -1194,9 +1299,9 @@ namespace tr1\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n+\t   bool c, bool ci, bool u>\n     void\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     m_deallocate_buckets(node** p, size_type n)\n     {\n       bucket_allocator_t alloc(m_node_allocator);\n@@ -1206,8 +1311,8 @@ namespace tr1\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+\t   bool c, bool ci, bool u>\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     hashtable(size_type bucket_hint,\n \t      const H1& h1, const H2& h2, const H& h,\n \t      const Eq& eq, const Ex& exk,\n@@ -1227,9 +1332,9 @@ namespace tr1\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n+\t   bool c, bool ci, bool u>\n     template<typename InIter>\n-      hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+      hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n       hashtable(InIter f, InIter l,\n \t\tsize_type bucket_hint,\n \t\tconst H1& h1, const H2& h2, const H& h,\n@@ -1265,8 +1370,8 @@ namespace tr1\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+\t   bool c, bool ci, bool u>\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     hashtable(const hashtable& ht)\n     : Internal::rehash_base<RP, hashtable>(ht),\n       Internal::hash_code_base<K, V, Ex, Eq, H1, H2, H, c>(ht),\n@@ -1303,9 +1408,9 @@ namespace tr1\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>&\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+\t   bool c, bool ci, bool u>\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>&\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     operator=(const hashtable& ht)\n     {\n       hashtable tmp(ht);\n@@ -1316,8 +1421,8 @@ namespace tr1\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+\t   bool c, bool ci, bool u>\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     ~hashtable()\n     {\n       clear();\n@@ -1327,9 +1432,9 @@ namespace tr1\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n+\t   bool c, bool ci, bool u>\n     void\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     swap(hashtable& x)\n     {\n       // The only base class with member variables is hash_code_base.  We\n@@ -1348,9 +1453,9 @@ namespace tr1\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n+\t   bool c, bool ci, bool u>\n     void\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     rehash_policy(const RP& pol)\n     {\n       m_rehash_policy = pol;\n@@ -1362,9 +1467,9 @@ namespace tr1\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n-    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::iterator\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+\t   bool c, bool ci, bool u>\n+    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::iterator\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     find(const key_type& k)\n     {\n       typename hashtable::hash_code_t code = this->m_hash_code (k);\n@@ -1376,9 +1481,9 @@ namespace tr1\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n-    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::const_iterator\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+\t   bool c, bool ci, bool u>\n+    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::const_iterator\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     find(const key_type& k) const\n     {\n       typename hashtable::hash_code_t code = this->m_hash_code (k);\n@@ -1390,9 +1495,9 @@ namespace tr1\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n-    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::size_type\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+\t   bool c, bool ci, bool u>\n+    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::size_type\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     count(const key_type& k) const\n     {\n       typename hashtable::hash_code_t code = this->m_hash_code (k);\n@@ -1407,12 +1512,12 @@ namespace tr1\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n+\t   bool c, bool ci, bool u>\n     std::pair<typename hashtable<K, V, A, Ex, Eq, H1,\n-\t\t\t\t H2, H, RP, c, m, u>::iterator,\n+\t\t\t\t H2, H, RP, c, ci, u>::iterator,\n \t      typename hashtable<K, V, A, Ex, Eq, H1,\n-\t\t\t\t H2, H, RP, c, m, u>::iterator>\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+\t\t\t\t H2, H, RP, c, ci, u>::iterator>\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     equal_range(const key_type& k)\n     {\n       typename hashtable::hash_code_t code = this->m_hash_code (k);\n@@ -1440,12 +1545,12 @@ namespace tr1\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n+\t   bool c, bool ci, bool u>\n     std::pair<typename hashtable<K, V, A, Ex, Eq, H1,\n-\t\t\t\t H2, H, RP, c, m, u>::const_iterator,\n+\t\t\t\t H2, H, RP, c, ci, u>::const_iterator,\n \t      typename hashtable<K, V, A, Ex, Eq, H1,\n-\t\t\t\t H2, H, RP, c, m, u>::const_iterator>\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+\t\t\t\t H2, H, RP, c, ci, u>::const_iterator>\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     equal_range(const key_type& k) const\n     {\n       typename hashtable::hash_code_t code = this->m_hash_code (k);\n@@ -1475,9 +1580,9 @@ namespace tr1\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n-    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::node* \n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+\t   bool c, bool ci, bool u>\n+    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::node* \n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     find_node(node* p, const key_type& k,\n \t      typename hashtable::hash_code_t code) const\n     {\n@@ -1491,10 +1596,10 @@ namespace tr1\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n+\t   bool c, bool ci, bool u>\n     std::pair<typename hashtable<K, V, A, Ex, Eq, H1,\n-\t\t\t\t H2, H, RP, c, m, u>::iterator, bool>\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+\t\t\t\t H2, H, RP, c, ci, u>::iterator, bool>\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     insert(const value_type& v, std::tr1::true_type)\n     {\n       const key_type& k = this->m_extract(v);\n@@ -1536,9 +1641,9 @@ namespace tr1\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n-    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::iterator\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+\t   bool c, bool ci, bool u>\n+    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::iterator\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     insert(const value_type& v, std::tr1::false_type)\n     {\n       std::pair<bool, std::size_t> do_rehash\n@@ -1571,10 +1676,10 @@ namespace tr1\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n+\t   bool c, bool ci, bool u>\n     template<typename InIter>\n       void \n-      hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+      hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n       insert(InIter first, InIter last)\n       {\n \tsize_type n_elt = Internal::distance_fw (first, last);\n@@ -1587,43 +1692,40 @@ namespace tr1\n \t  this->insert (*first);\n       }\n \n-  // XXX We're following the TR in giving this a return type of void,\n-  // but that ought to change.  The return type should be const_iterator,\n-  // and it should return the iterator following the one we've erased.\n-  // That would simplify range erase.\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n-    void\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+\t   bool c, bool ci, bool u>\n+    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::iterator\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n+    erase(iterator i)\n+    {\n+      iterator result = i;\n+      ++result;\n+      m_erase(i.m_cur_node, i.m_cur_bucket);\n+      return result;\n+    }\n+  \n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool ci, bool u>\n+    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::const_iterator\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     erase(const_iterator i)\n     {\n-      node* p = i.m_cur_node;\n-      node* cur = *i.m_cur_bucket;\n-      if (cur == p)\n-\t*i.m_cur_bucket = cur->m_next;\n-      else\n-\t{\n-\t  node* next = cur->m_next;\n-\t  while (next != p)\n-\t    {\n-\t      cur = next;\n-\t      next = cur->m_next;\n-\t    }\n-\t  cur->m_next = next->m_next;\n-\t}\n-\n-      m_deallocate_node (p);\n-      --m_element_count;\n+      const_iterator result = i;\n+      ++result;\n+      m_erase(i.m_cur_node, i.m_cur_bucket);\n+      return result;\n     }\n \n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n-    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::size_type\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+\t   bool c, bool ci, bool u>\n+    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::size_type\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     erase(const key_type& k)\n     {\n       typename hashtable::hash_code_t code = this->m_hash_code (k);\n@@ -1649,29 +1751,38 @@ namespace tr1\n   // ??? This could be optimized by taking advantage of the bucket\n   // structure, but it's not clear that it's worth doing.  It probably\n   // wouldn't even be an optimization unless the load factor is large.\n-  template <typename K, typename V,\n-\t    typename A, typename Ex, typename Eq,\n-\t    typename H1, typename H2, typename H, typename RP,\n-\t    bool c, bool m, bool u>\n-    void\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool ci, bool u>\n+    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::iterator\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n+    erase(iterator first, iterator last)\n+    {\n+      while (first != last)\n+\tfirst = this->erase(first);\n+      return last;\n+    }\n+  \n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool ci, bool u>\n+    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::const_iterator\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     erase(const_iterator first, const_iterator last)\n     {\n       while (first != last)\n-\t{\n-\t  const_iterator next = first;\n-\t  ++next;\n-\t  this->erase(first);\n-\t  first = next;\n-\t}\n+\tfirst = this->erase(first);\n+      return last;\n     }\n \n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n+\t   bool c, bool ci, bool u>\n     void\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     clear()\n     {\n       m_deallocate_nodes(m_buckets, m_bucket_count);\n@@ -1681,9 +1792,9 @@ namespace tr1\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool m, bool u>\n+\t   bool c, bool ci, bool u>\n     void\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, m, u>::\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     m_rehash(size_type N)\n     {\n       node** new_array = m_allocate_buckets (N);\n@@ -1714,7 +1825,32 @@ namespace tr1\n \t  __throw_exception_again;\n \t}\n     }\n-  \n+\n+  template<typename K, typename V, \n+\t   typename A, typename Ex, typename Eq,\n+\t   typename H1, typename H2, typename H, typename RP,\n+\t   bool c, bool ci, bool u>\n+    void\n+    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n+    m_erase(node* p, node** b)\n+    {\n+      node* cur = *b;\n+      if (cur == p)\n+\t*b = cur->m_next;\n+      else\n+\t{\n+\t  node* next = cur->m_next;\n+\t  while (next != p)\n+\t    {\n+\t      cur = next;\n+\t      next = cur->m_next;\n+\t    }\n+\t  cur->m_next = next->m_next;\n+\t}\n+\n+      m_deallocate_node (p);\n+      --m_element_count;\n+    }\n }\n }\t\t\t\t// Namespace std::tr1\n "}, {"sha": "2f789c80e8f5eda05e0df598792ae9968d27a211", "filename": "libstdc++-v3/include/tr1/unordered_map", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map?ref=3c9b5053e065cabfd67d38ffcf9496903fe0c0a8", "patch": "@@ -59,15 +59,15 @@ namespace tr1\n \t\t\tHash, Internal::mod_range_hashing,\n \t\t\tInternal::default_ranged_hash,\n \t\t\tInternal::prime_rehash_policy,\n-\t\t\tcache_hash_code, true, true>\n+\t\t\tcache_hash_code, false, true>\n     {\n       typedef hashtable <Key, std::pair<const Key, T>,\n \t\t\t Alloc,\n \t\t\t Internal::extract1st<std::pair<const Key, T> >, Pred,\n \t\t\t Hash, Internal::mod_range_hashing,\n \t\t\t Internal::default_ranged_hash,\n \t\t\t Internal::prime_rehash_policy,\n-\t\t\t cache_hash_code, true, true>\n+\t\t\t cache_hash_code, false, true>\n         Base;\n \n     public:\n@@ -110,15 +110,15 @@ namespace tr1\n \t\t\tHash, Internal::mod_range_hashing,\n \t\t\tInternal::default_ranged_hash,\n \t\t\tInternal::prime_rehash_policy,\n-\t\t\tcache_hash_code, true, false>\n+\t\t\tcache_hash_code, false, false>\n     {\n       typedef hashtable <Key, std::pair<const Key, T>,\n \t\t\t Alloc,\n \t\t\t Internal::extract1st<std::pair<const Key, T> >, Pred,\n \t\t\t Hash, Internal::mod_range_hashing,\n \t\t\t Internal::default_ranged_hash,\n \t\t\t Internal::prime_rehash_policy,\n-\t\t\t cache_hash_code, true, false>\n+\t\t\t cache_hash_code, false, false>\n         Base;\n \n     public:"}, {"sha": "6a4881a3d1d98838ee1934226ba31ad5ce5033eb", "filename": "libstdc++-v3/include/tr1/unordered_set", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set?ref=3c9b5053e065cabfd67d38ffcf9496903fe0c0a8", "patch": "@@ -57,14 +57,14 @@ namespace tr1\n \t\t       Hash, Internal::mod_range_hashing,\n \t\t       Internal::default_ranged_hash,\n \t\t       Internal::prime_rehash_policy,\n-\t\t       cache_hash_code, false, true>\n+\t\t       cache_hash_code, true, true>\n     {\n       typedef hashtable<Value, Value, Alloc,\n \t\t\tInternal::identity<Value>, Pred,\n \t\t\tHash, Internal::mod_range_hashing,\n \t\t\tInternal::default_ranged_hash,\n \t\t\tInternal::prime_rehash_policy,\n-\t\t\tcache_hash_code, false, true>\n+\t\t\tcache_hash_code, true, true>\n         Base;\n \n     public:\n@@ -106,14 +106,14 @@ namespace tr1\n \t\t\tHash, Internal::mod_range_hashing,\n \t\t\tInternal::default_ranged_hash,\n \t\t\tInternal::prime_rehash_policy,\n-\t\t\tcache_hash_code, false, false>\n+\t\t\tcache_hash_code, true, false>\n     {\n       typedef hashtable<Value, Value, Alloc,\n \t\t\tInternal::identity<Value>, Pred,\n \t\t\tHash, Internal::mod_range_hashing,\n \t\t\tInternal::default_ranged_hash,\n \t\t\tInternal::prime_rehash_policy,\n-\t\t\tcache_hash_code, false, false>\n+\t\t\tcache_hash_code, true, false>\n         Base;\n \n     public:"}, {"sha": "9289b65859cdc2973eef06029f971aa6e6c8c5a4", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/erase/24061-map.cc", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Ferase%2F24061-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Ferase%2F24061-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Ferase%2F24061-map.cc?ref=3c9b5053e065cabfd67d38ffcf9496903fe0c0a8", "patch": "@@ -0,0 +1,106 @@\n+// 2005-10-08  Paolo Carlini  <pcarlini@suse.de> \n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 6.3.4.4  Class template unordered_map\n+\n+#include <tr1/unordered_map>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/24061\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef std::tr1::unordered_map<std::string, int> Map;\n+  typedef Map::iterator       iterator;\n+  typedef Map::const_iterator const_iterator;\n+  typedef Map::value_type     value_type;\n+  \n+  Map m1;\n+\n+  m1.insert(value_type(\"all the love in the world\", 1));\n+  m1.insert(value_type(\"you know what you are?\", 2));\n+  m1.insert(value_type(\"the collector\", 3));\n+  m1.insert(value_type(\"the hand that feeds\", 4));\n+  m1.insert(value_type(\"love is not enough\", 5));\n+  m1.insert(value_type(\"every day is exactly the same\", 6));\n+  m1.insert(value_type(\"with teeth\", 7));\n+  m1.insert(value_type(\"only\", 8));\n+  m1.insert(value_type(\"getting smaller\", 9));\n+  m1.insert(value_type(\"sunspots\", 10)); \n+  VERIFY( m1.size() == 10 );\n+\n+  iterator it1 = m1.begin();\n+  ++it1;\n+  iterator it2 = it1;\n+  ++it2;\n+  iterator it3 = m1.erase(it1);\n+  VERIFY( m1.size() == 9 );\n+  VERIFY( it3 == it2 );\n+  VERIFY( *it3 == *it2 );\n+\n+  iterator it4 = m1.begin();\n+  ++it4;\n+  ++it4;\n+  ++it4;\n+  iterator it5 = it4;\n+  ++it5;\n+  ++it5;\n+  iterator it6 = m1.erase(it4, it5);\n+  VERIFY( m1.size() == 7 );\n+  VERIFY( it6 == it5 );\n+  VERIFY( *it6 == *it5 );\n+\n+  const_iterator it7 = m1.begin();\n+  ++it7;\n+  ++it7;\n+  ++it7;\n+  const_iterator it8 = it7;\n+  ++it8;\n+  const_iterator it9 = m1.erase(it7);\n+  VERIFY( m1.size() == 6 );\n+  VERIFY( it9 == it8 );\n+  VERIFY( *it9 == *it8 );\n+\n+  const_iterator it10 = m1.begin();\n+  ++it10;\n+  const_iterator it11 = it10;\n+  ++it11;\n+  ++it11;\n+  ++it11;\n+  ++it11;\n+  const_iterator it12 = m1.erase(it10, it11);\n+  VERIFY( m1.size() == 2 );\n+  VERIFY( it12 == it11 );\n+  VERIFY( *it12 == *it11 );\n+  VERIFY( ++it12 == m1.end() );\n+\n+  iterator it13 = m1.erase(m1.begin(), m1.end());\n+  VERIFY( m1.size() == 0 );\n+  VERIFY( it13 == it12 );\n+  VERIFY( it13 == m1.begin() );\n+}\n+  \n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "b9980b73136f486408cd9b4e004034c8f50d2866", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/erase/24061-multimap.cc", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Ferase%2F24061-multimap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Ferase%2F24061-multimap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Ferase%2F24061-multimap.cc?ref=3c9b5053e065cabfd67d38ffcf9496903fe0c0a8", "patch": "@@ -0,0 +1,109 @@\n+// 2005-10-08  Paolo Carlini  <pcarlini@suse.de> \n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 6.3.4.6  Class template unordered_multimap\n+\n+#include <tr1/unordered_map>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/24061\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef std::tr1::unordered_multimap<std::string, int> Mmap;\n+  typedef Mmap::iterator       iterator;\n+  typedef Mmap::const_iterator const_iterator;\n+  typedef Mmap::value_type     value_type;\n+  \n+  Mmap mm1;\n+\n+  mm1.insert(value_type(\"all the love in the world\", 1));\n+  mm1.insert(value_type(\"you know what you are?\", 2));\n+  mm1.insert(value_type(\"the collector\", 3));\n+  mm1.insert(value_type(\"the hand that feeds\", 4));\n+  mm1.insert(value_type(\"love is not enough\", 5));\n+  mm1.insert(value_type(\"every day is exactly the same\", 6));\n+  mm1.insert(value_type(\"with teeth\", 7));\n+  mm1.insert(value_type(\"only\", 8));\n+  mm1.insert(value_type(\"getting smaller\", 9));\n+  mm1.insert(value_type(\"sunspots\", 10));\n+\n+  mm1.insert(value_type(\"you know what you are?\", 5));\n+  mm1.insert(value_type(\"the collector\", 6));\n+  mm1.insert(value_type(\"the hand that feeds\", 7));\n+  VERIFY( mm1.size() == 13 );\n+\n+  iterator it1 = mm1.begin();\n+  ++it1;\n+  iterator it2 = it1;\n+  ++it2;\n+  iterator it3 = mm1.erase(it1);\n+  VERIFY( mm1.size() == 12 );\n+  VERIFY( it3 == it2 );\n+  VERIFY( *it3 == *it2 );\n+\n+  iterator it4 = mm1.begin();\n+  ++it4;\n+  ++it4;\n+  ++it4;\n+  iterator it5 = it4;\n+  ++it5;\n+  ++it5;\n+  iterator it6 = mm1.erase(it4, it5);\n+  VERIFY( mm1.size() == 10 );\n+  VERIFY( it6 == it5 );\n+  VERIFY( *it6 == *it5 );\n+\n+  const_iterator it7 = mm1.begin();\n+  ++it7;\n+  ++it7;\n+  ++it7;\n+  const_iterator it8 = it7;\n+  ++it8;\n+  const_iterator it9 = mm1.erase(it7);\n+  VERIFY( mm1.size() == 9 );\n+  VERIFY( it9 == it8 );\n+  VERIFY( *it9 == *it8 );\n+\n+  const_iterator it10 = mm1.begin();\n+  ++it10;\n+  const_iterator it11 = it10;\n+  ++it11;\n+  ++it11;\n+  ++it11;\n+  ++it11;\n+  const_iterator it12 = mm1.erase(it10, it11);\n+  VERIFY( mm1.size() == 5 );\n+  VERIFY( it12 == it11 );\n+  VERIFY( *it12 == *it11 );\n+\n+  iterator it13 = mm1.erase(mm1.begin(), mm1.end());\n+  VERIFY( mm1.size() == 0 );\n+  VERIFY( it13 == mm1.end() );\n+  VERIFY( it13 == mm1.begin() );\n+}\n+  \n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "a00beab49435986f5970a90442d6c741911df794", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/erase/24061-multiset.cc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Ferase%2F24061-multiset.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Ferase%2F24061-multiset.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Ferase%2F24061-multiset.cc?ref=3c9b5053e065cabfd67d38ffcf9496903fe0c0a8", "patch": "@@ -0,0 +1,108 @@\n+// 2005-10-08  Paolo Carlini  <pcarlini@suse.de> \n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 6.3.4.5  Class template unordered_multiset\n+\n+#include <tr1/unordered_set>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/24061\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef std::tr1::unordered_multiset<std::string> Mset;\n+  typedef Mset::iterator       iterator;\n+  typedef Mset::const_iterator const_iterator;\n+\n+  Mset ms1;\n+  \n+  ms1.insert(\"all the love in the world\");\n+  ms1.insert(\"you know what you are?\");\n+  ms1.insert(\"the collector\");\n+  ms1.insert(\"the hand that feeds\");\n+  ms1.insert(\"love is not enough\");\n+  ms1.insert(\"every day is exactly the same\");\n+  ms1.insert(\"with teeth\");\n+  ms1.insert(\"only\");\n+  ms1.insert(\"getting smaller\");\n+  ms1.insert(\"sunspots\");\n+\n+  ms1.insert(\"the hand that feeds\");\n+  ms1.insert(\"love is not enough\");\n+  ms1.insert(\"every day is exactly the same\");\n+  VERIFY( ms1.size() == 13 );\n+\n+  iterator it1 = ms1.begin();\n+  ++it1;\n+  iterator it2 = it1;\n+  ++it2;\n+  iterator it3 = ms1.erase(it1);\n+  VERIFY( ms1.size() == 12 );\n+  VERIFY( it3 == it2 );\n+  VERIFY( *it3 == *it2 );\n+\n+  iterator it4 = ms1.begin();\n+  ++it4;\n+  ++it4;\n+  ++it4;\n+  iterator it5 = it4;\n+  ++it5;\n+  ++it5;\n+  iterator it6 = ms1.erase(it4, it5);\n+  VERIFY( ms1.size() == 10 );\n+  VERIFY( it6 == it5 );\n+  VERIFY( *it6 == *it5 );\n+\n+  const_iterator it7 = ms1.begin();\n+  ++it7;\n+  ++it7;\n+  ++it7;\n+  const_iterator it8 = it7;\n+  ++it8;\n+  const_iterator it9 = ms1.erase(it7);\n+  VERIFY( ms1.size() == 9 );\n+  VERIFY( it9 == it8 );\n+  VERIFY( *it9 == *it8 );\n+\n+  const_iterator it10 = ms1.begin();\n+  ++it10;\n+  const_iterator it11 = it10;\n+  ++it11;\n+  ++it11;\n+  ++it11;\n+  ++it11;\n+  const_iterator it12 = ms1.erase(it10, it11);\n+  VERIFY( ms1.size() == 5 );\n+  VERIFY( it12 == it11 );\n+  VERIFY( *it12 == *it11 );\n+\n+  iterator it13 = ms1.erase(ms1.begin(), ms1.end());\n+  VERIFY( ms1.size() == 0 );\n+  VERIFY( it13 == ms1.end() );\n+  VERIFY( it13 == ms1.begin() );\n+}\n+  \n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "202a21d1dddb7d95e19b64f5470ec0262058dbab", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/erase/24061-set.cc", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Ferase%2F24061-set.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Ferase%2F24061-set.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Ferase%2F24061-set.cc?ref=3c9b5053e065cabfd67d38ffcf9496903fe0c0a8", "patch": "@@ -0,0 +1,105 @@\n+// 2005-10-08  Paolo Carlini  <pcarlini@suse.de> \n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 6.3.4.3  Class template unordered_set\n+\n+#include <tr1/unordered_set>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/24061\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef std::tr1::unordered_set<std::string> Set;\n+  typedef Set::iterator       iterator;\n+  typedef Set::const_iterator const_iterator;\n+\n+  Set s1;\n+  \n+  s1.insert(\"all the love in the world\");\n+  s1.insert(\"you know what you are?\");\n+  s1.insert(\"the collector\");\n+  s1.insert(\"the hand that feeds\");\n+  s1.insert(\"love is not enough\");\n+  s1.insert(\"every day is exactly the same\");\n+  s1.insert(\"with teeth\");\n+  s1.insert(\"only\");\n+  s1.insert(\"getting smaller\");\n+  s1.insert(\"sunspots\");\n+  VERIFY( s1.size() == 10 );\n+\n+  iterator it1 = s1.begin();\n+  ++it1;\n+  iterator it2 = it1;\n+  ++it2;\n+  iterator it3 = s1.erase(it1);\n+  VERIFY( s1.size() == 9 );\n+  VERIFY( it3 == it2 );\n+  VERIFY( *it3 == *it2 );\n+\n+  iterator it4 = s1.begin();\n+  ++it4;\n+  ++it4;\n+  ++it4;\n+  iterator it5 = it4;\n+  ++it5;\n+  ++it5;\n+  iterator it6 = s1.erase(it4, it5);\n+  VERIFY( s1.size() == 7 );\n+  VERIFY( it6 == it5 );\n+  VERIFY( *it6 == *it5 );\n+\n+  const_iterator it7 = s1.begin();\n+  ++it7;\n+  ++it7;\n+  ++it7;\n+  const_iterator it8 = it7;\n+  ++it8;\n+  const_iterator it9 = s1.erase(it7);\n+  VERIFY( s1.size() == 6 );\n+  VERIFY( it9 == it8 );\n+  VERIFY( *it9 == *it8 );\n+\n+  const_iterator it10 = s1.begin();\n+  ++it10;\n+  const_iterator it11 = it10;\n+  ++it11;\n+  ++it11;\n+  ++it11;\n+  ++it11;\n+  const_iterator it12 = s1.erase(it10, it11);\n+  VERIFY( s1.size() == 2 );\n+  VERIFY( it12 == it11 );\n+  VERIFY( *it12 == *it11 );\n+  VERIFY( ++it12 == s1.end() );\n+\n+  iterator it13 = s1.erase(s1.begin(), s1.end());\n+  VERIFY( s1.size() == 0 );\n+  VERIFY( it13 == s1.end() );\n+  VERIFY( it13 == s1.begin() );\n+}\n+  \n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "8e290afd7f75f3dabd76e7d6eebb6ca3b1f76261", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/insert/24061-map.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2F24061-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2F24061-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2F24061-map.cc?ref=3c9b5053e065cabfd67d38ffcf9496903fe0c0a8", "patch": "@@ -0,0 +1,61 @@\n+// 2005-10-08  Paolo Carlini  <pcarlini@suse.de> \n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 6.3.4.4  Class template unordered_map\n+\n+#include <tr1/unordered_map>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/24061\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef std::tr1::unordered_map<std::string, int> Map;\n+  typedef Map::iterator       iterator;\n+  typedef Map::const_iterator const_iterator;\n+  typedef Map::value_type     value_type;\n+\n+  Map m1;\n+  \n+  iterator it1 = m1.insert(m1.begin(),\n+\t\t\t   value_type(\"all the love in the world\", 1));\n+  VERIFY( m1.size() == 1 );\n+  VERIFY( *it1 == value_type(\"all the love in the world\", 1) );\n+  \n+  const_iterator cit1(it1);\n+  const_iterator cit2 = m1.insert(cit1,\n+\t\t\t\t  value_type(\"you know what you are?\", 2));\n+  VERIFY( m1.size() == 2 );\n+  VERIFY( cit2 != cit1 );\n+  VERIFY( *cit2 == value_type(\"you know what you are?\", 2) );\n+\n+  iterator it2 = m1.insert(it1, value_type(\"all the love in the world\", 3));\n+  VERIFY( m1.size() == 2 );\n+  VERIFY( it2 == it1 );\n+  VERIFY( *it2 == value_type(\"all the love in the world\", 1) );\n+}\n+  \n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "a744c8bb38111ad91448b3ff272dcc9f51a9b8b7", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/insert/24061-multimap.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2F24061-multimap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2F24061-multimap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2F24061-multimap.cc?ref=3c9b5053e065cabfd67d38ffcf9496903fe0c0a8", "patch": "@@ -0,0 +1,61 @@\n+// 2005-10-08  Paolo Carlini  <pcarlini@suse.de> \n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 6.3.4.6  Class template unordered_multimap\n+\n+#include <tr1/unordered_map>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/24061\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef std::tr1::unordered_multimap<std::string, int> Mmap;\n+  typedef Mmap::iterator       iterator;\n+  typedef Mmap::const_iterator const_iterator;\n+  typedef Mmap::value_type     value_type;\n+\n+  Mmap mm1;\n+  \n+  iterator it1 = mm1.insert(mm1.begin(),\n+\t\t\t    value_type(\"all the love in the world\", 1));\n+  VERIFY( mm1.size() == 1 );\n+  VERIFY( *it1 == value_type(\"all the love in the world\", 1) );\n+  \n+  const_iterator cit1(it1);\n+  const_iterator cit2 = mm1.insert(cit1,\n+\t\t\t\t   value_type(\"you know what you are?\", 2));\n+  VERIFY( mm1.size() == 2 );\n+  VERIFY( cit2 != cit1 );\n+  VERIFY( *cit2 == value_type(\"you know what you are?\", 2) );\n+\n+  iterator it2 = mm1.insert(it1, value_type(\"all the love in the world\", 3));\n+  VERIFY( mm1.size() == 3 );\n+  VERIFY( it2 != it1 );\n+  VERIFY( *it2 == value_type(\"all the love in the world\", 3) );\n+}\n+  \n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "9467f418ef3921aad073ef29e8fd31de641a58da", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/insert/24061-multiset.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2F24061-multiset.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2F24061-multiset.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2F24061-multiset.cc?ref=3c9b5053e065cabfd67d38ffcf9496903fe0c0a8", "patch": "@@ -0,0 +1,58 @@\n+// 2005-10-08  Paolo Carlini  <pcarlini@suse.de> \n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 6.3.4.5  Class template unordered_multiset\n+\n+#include <tr1/unordered_set>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/24061\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef std::tr1::unordered_multiset<std::string> Mset;\n+  typedef Mset::iterator       iterator;\n+  typedef Mset::const_iterator const_iterator;\n+\n+  Mset ms1;\n+  \n+  iterator it1 = ms1.insert(ms1.begin(), \"all the love in the world\");\n+  VERIFY( ms1.size() == 1 );\n+  VERIFY( *it1 == \"all the love in the world\" );\n+  \n+  const_iterator cit1(it1);\n+  const_iterator cit2 = ms1.insert(cit1, \"you know what you are?\");\n+  VERIFY( ms1.size() == 2 );\n+  VERIFY( cit2 != cit1 );\n+  VERIFY( *cit2 == \"you know what you are?\" );\n+\n+  iterator it2 = ms1.insert(it1, \"all the love in the world\");\n+  VERIFY( ms1.size() == 3 );\n+  VERIFY( it2 != it1 );\n+  VERIFY( *it2 == \"all the love in the world\" );\n+}\n+  \n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "c7d670c9f491bfd3289d408d587c317e536909fe", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/insert/24061-set.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2F24061-set.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c9b5053e065cabfd67d38ffcf9496903fe0c0a8/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2F24061-set.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Finsert%2F24061-set.cc?ref=3c9b5053e065cabfd67d38ffcf9496903fe0c0a8", "patch": "@@ -0,0 +1,58 @@\n+// 2005-10-08  Paolo Carlini  <pcarlini@suse.de> \n+//\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 6.3.4.3  Class template unordered_set\n+\n+#include <tr1/unordered_set>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/24061\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef std::tr1::unordered_set<std::string> Set;\n+  typedef Set::iterator       iterator;\n+  typedef Set::const_iterator const_iterator;\n+\n+  Set s1;\n+  \n+  iterator it1 = s1.insert(s1.begin(), \"all the love in the world\");\n+  VERIFY( s1.size() == 1 );\n+  VERIFY( *it1 == \"all the love in the world\" );\n+  \n+  const_iterator cit1(it1);\n+  const_iterator cit2 = s1.insert(cit1, \"you know what you are?\");\n+  VERIFY( s1.size() == 2 );\n+  VERIFY( cit2 != cit1 );\n+  VERIFY( *cit2 == \"you know what you are?\" );\n+\n+  iterator it2 = s1.insert(it1, \"all the love in the world\");\n+  VERIFY( s1.size() == 2 );\n+  VERIFY( it2 == it1 );\n+  VERIFY( *it2 == \"all the love in the world\" );\n+}\n+  \n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}