{"sha": "b88cf82e9f9cbbb1851fa71e5845152ba5feada0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg4Y2Y4MmU5ZjljYmJiMTg1MWZhNzFlNTg0NTE1MmJhNWZlYWRhMA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-01-29T15:59:24Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-01-29T15:59:24Z"}, "message": "frv.c: Don't mention deprecated macros in comments.\n\n\t* config/frv/frv.c: Don't mention deprecated macros in\n\tcomments.  Remove some target-independent comments about\n\ttarget macros.\n\t* config/frv/frv.h: Likewise.\n\nFrom-SVN: r76864", "tree": {"sha": "45327ea20300d8ad04903530e60d36c5a624aad7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45327ea20300d8ad04903530e60d36c5a624aad7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b88cf82e9f9cbbb1851fa71e5845152ba5feada0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b88cf82e9f9cbbb1851fa71e5845152ba5feada0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b88cf82e9f9cbbb1851fa71e5845152ba5feada0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b88cf82e9f9cbbb1851fa71e5845152ba5feada0/comments", "author": null, "committer": null, "parents": [{"sha": "5efa76401ef16e8708ed5c3944e0918f738065d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5efa76401ef16e8708ed5c3944e0918f738065d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5efa76401ef16e8708ed5c3944e0918f738065d9"}], "stats": {"total": 122, "additions": 20, "deletions": 102}, "files": [{"sha": "b01814b5388289bc0ef158ab984742a07467662f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b88cf82e9f9cbbb1851fa71e5845152ba5feada0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b88cf82e9f9cbbb1851fa71e5845152ba5feada0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b88cf82e9f9cbbb1851fa71e5845152ba5feada0", "patch": "@@ -1,3 +1,10 @@\n+2004-01-29  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/frv/frv.c: Don't mention deprecated macros in\n+\tcomments.  Remove some target-independent comments about\n+\ttarget macros.\n+\t* config/frv/frv.h: Likewise.\n+\n 2004-01-29  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* cfghooks.c (split_block): Set probability and count of the"}, {"sha": "2e0891846f3770923f38df4c81c8df903e7453c6", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 13, "deletions": 73, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b88cf82e9f9cbbb1851fa71e5845152ba5feada0/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b88cf82e9f9cbbb1851fa71e5845152ba5feada0/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=b88cf82e9f9cbbb1851fa71e5845152ba5feada0", "patch": "@@ -1536,10 +1536,11 @@ frv_frame_access_standard_regs (enum frv_stack_op op, frv_stack_t *info)\n \n /* Called after register allocation to add any instructions needed for the\n    prologue.  Using a prologue insn is favored compared to putting all of the\n-   instructions in the FUNCTION_PROLOGUE macro, since it allows the scheduler\n-   to intermix instructions with the saves of the caller saved registers.  In\n-   some cases, it might be necessary to emit a barrier instruction as the last\n-   insn to prevent such scheduling.\n+   instructions in the TARGET_ASM_FUNCTION_PROLOGUE target hook, since\n+   it allows the scheduler to intermix instructions with the saves of\n+   the caller saved registers.  In some cases, it might be necessary\n+   to emit a barrier instruction as the last insn to prevent such\n+   scheduling.\n \n    Also any insns generated here should have RTX_FRAME_RELATED_P(insn) = 1\n    so that the debug info generation code can handle them properly.  */\n@@ -1672,10 +1673,11 @@ frv_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n \f\n /* Called after register allocation to add any instructions needed for the\n    epilogue.  Using an epilogue insn is favored compared to putting all of the\n-   instructions in the FUNCTION_PROLOGUE macro, since it allows the scheduler\n-   to intermix instructions with the saves of the caller saved registers.  In\n-   some cases, it might be necessary to emit a barrier instruction as the last\n-   insn to prevent such scheduling.\n+   instructions in the TARGET_ASM_FUNCTION_PROLOGUE target hook, since\n+   it allows the scheduler to intermix instructions with the saves of\n+   the caller saved registers.  In some cases, it might be necessary\n+   to emit a barrier instruction as the last insn to prevent such\n+   scheduling.\n \n    If SIBCALL_P is true, the final branch back to the calling function is\n    omitted, and is used for sibling call (aka tail call) sites.  For sibcalls,\n@@ -1753,35 +1755,7 @@ frv_expand_epilogue (int sibcall_p)\n }\n \n \f\n-/* A C compound statement that outputs the assembler code for a thunk function,\n-   used to implement C++ virtual function calls with multiple inheritance.  The\n-   thunk acts as a wrapper around a virtual function, adjusting the implicit\n-   object parameter before handing control off to the real function.\n-\n-   First, emit code to add the integer DELTA to the location that contains the\n-   incoming first argument.  Assume that this argument contains a pointer, and\n-   is the one used to pass the `this' pointer in C++.  This is the incoming\n-   argument *before* the function prologue, e.g. `%o0' on a sparc.  The\n-   addition must preserve the values of all other incoming arguments.\n-\n-   After the addition, emit code to jump to FUNCTION, which is a\n-   `FUNCTION_DECL'.  This is a direct pure jump, not a call, and does not touch\n-   the return address.  Hence returning from FUNCTION will return to whoever\n-   called the current `thunk'.\n-\n-   The effect must be as if FUNCTION had been called directly with the adjusted\n-   first argument.  This macro is responsible for emitting all of the code for\n-   a thunk function; `FUNCTION_PROLOGUE' and `FUNCTION_EPILOGUE' are not\n-   invoked.\n-\n-   The THUNK_FNDECL is redundant.  (DELTA and FUNCTION have already been\n-   extracted from it.)  It might possibly be useful on some targets, but\n-   probably not.\n-\n-   If you do not define this macro, the target-independent code in the C++\n-   frontend will generate a less efficient heavyweight thunk that calls\n-   FUNCTION instead of jumping to it.  The generic approach does not support\n-   varargs.  */\n+/* Worker function for TARGET_ASM_OUTPUT_MI_THUNK.  */\n \n static void\n frv_asm_output_mi_thunk (FILE *file,\n@@ -1932,34 +1906,7 @@ frv_initial_elimination_offset (int from, int to)\n }\n \n \f\n-/* This macro offers an alternative to using `__builtin_saveregs' and defining\n-   the macro `EXPAND_BUILTIN_SAVEREGS'.  Use it to store the anonymous register\n-   arguments into the stack so that all the arguments appear to have been\n-   passed consecutively on the stack.  Once this is done, you can use the\n-   standard implementation of varargs that works for machines that pass all\n-   their arguments on the stack.\n-\n-   The argument ARGS_SO_FAR is the `CUMULATIVE_ARGS' data structure, containing\n-   the values that obtain after processing of the named arguments.  The\n-   arguments MODE and TYPE describe the last named argument--its machine mode\n-   and its data type as a tree node.\n-\n-   The macro implementation should do two things: first, push onto the stack\n-   all the argument registers *not* used for the named arguments, and second,\n-   store the size of the data thus pushed into the `int'-valued variable whose\n-   name is supplied as the argument PRETEND_ARGS_SIZE.  The value that you\n-   store here will serve as additional offset for setting up the stack frame.\n-\n-   Because you must generate code to push the anonymous arguments at compile\n-   time without knowing their data types, `SETUP_INCOMING_VARARGS' is only\n-   useful on machines that have just a single category of argument register and\n-   use it uniformly for all data types.\n-\n-   If the argument SECOND_TIME is nonzero, it means that the arguments of the\n-   function are being analyzed for the second time.  This happens for an inline\n-   function, which is not actually compiled until the end of the source file.\n-   The macro `SETUP_INCOMING_VARARGS' should not generate any instructions in\n-   this case.  */\n+/* Worker function for SETUP_INCOMING_VARARGS.  */\n \n void\n frv_setup_incoming_varargs (CUMULATIVE_ARGS *cum,\n@@ -1975,14 +1922,7 @@ frv_setup_incoming_varargs (CUMULATIVE_ARGS *cum,\n }\n \n \f\n-/* If defined, is a C expression that produces the machine-specific code for a\n-   call to `__builtin_saveregs'.  This code will be moved to the very beginning\n-   of the function, before any parameter access are made.  The return value of\n-   this function should be an RTX that contains the value to use as the return\n-   of `__builtin_saveregs'.\n-\n-   If this macro is not defined, the compiler will output an ordinary call to\n-   the library function `__builtin_saveregs'.  */\n+/* Worker function for TARGET_EXPAND_BUILTIN_SAVEREGS.  */\n \n static rtx\n frv_expand_builtin_saveregs (void)"}, {"sha": "e68041de3ed2dea6c2b9f1625778b5fde0677a9a", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b88cf82e9f9cbbb1851fa71e5845152ba5feada0/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b88cf82e9f9cbbb1851fa71e5845152ba5feada0/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=b88cf82e9f9cbbb1851fa71e5845152ba5feada0", "patch": "@@ -2083,35 +2083,6 @@ struct machine_function GTY(())\n \f\n /* Implementing the Varargs Macros.  */\n \n-/* This macro offers an alternative to using `__builtin_saveregs' and defining\n-   the target hook `TARGET_EXPAND_BUILTIN_SAVEREGS'.  Use it to store\n-   the anonymous register arguments into the stack so that all the\n-   arguments appear to have been passed consecutively on the stack.\n-   Once this is done, you can use the standard implementation of\n-   varargs that works for machines that pass all their arguments on\n-   the stack.\n-\n-   The argument ARGS_SO_FAR is the `CUMULATIVE_ARGS' data structure, containing\n-   the values that obtain after processing of the named arguments.  The\n-   arguments MODE and TYPE describe the last named argument--its machine mode\n-   and its data type as a tree node.\n-\n-   The macro implementation should do two things: first, push onto the stack\n-   all the argument registers *not* used for the named arguments, and second,\n-   store the size of the data thus pushed into the `int'-valued variable whose\n-   name is supplied as the argument PRETEND_ARGS_SIZE.  The value that you\n-   store here will serve as additional offset for setting up the stack frame.\n-\n-   Because you must generate code to push the anonymous arguments at compile\n-   time without knowing their data types, `SETUP_INCOMING_VARARGS' is only\n-   useful on machines that have just a single category of argument register and\n-   use it uniformly for all data types.\n-\n-   If the argument SECOND_TIME is nonzero, it means that the arguments of the\n-   function are being analyzed for the second time.  This happens for an inline\n-   function, which is not actually compiled until the end of the source file.\n-   The macro `SETUP_INCOMING_VARARGS' should not generate any instructions in\n-   this case.  */\n #define SETUP_INCOMING_VARARGS(ARGS_SO_FAR, MODE, TYPE, PRETEND_ARGS_SIZE, SECOND_TIME) \\\n   frv_setup_incoming_varargs (& ARGS_SO_FAR, (int) MODE, TYPE, \t\\\n \t\t\t      & PRETEND_ARGS_SIZE, SECOND_TIME)"}]}