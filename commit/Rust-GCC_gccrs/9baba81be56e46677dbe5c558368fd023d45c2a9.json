{"sha": "9baba81be56e46677dbe5c558368fd023d45c2a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJhYmE4MWJlNTZlNDY2NzdkYmU1YzU1ODM2OGZkMDIzZDQ1YzJhOQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "pop@cri.ensmp.fr", "date": "2004-07-12T19:31:16Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2004-07-12T19:31:16Z"}, "message": "cfgloop.h (struct loop): Add nb_iterations field.\n\n\t* cfgloop.h (struct loop): Add nb_iterations field.\n\t(current_loops): Declare.\n\t* tree-chrec.c (chrec_not_analyzed_yet,\n\tchrec_dont_know, chrec_known, count_ev_in_wider_type,\n\tchrec_contains_symbols_defined_in_loop): Remove the temporary\n\thooks.\n\t* tree-flow-inline.h (loop_containing_stmt): New function.\n\t* tree-scalar-evolution.c: Add implementation.\n\t* tree-scalar-evolution.h: Add declarations.\n\nFrom-SVN: r84573", "tree": {"sha": "3c802a37a69533f1e5eac9a5138ce105450e9411", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c802a37a69533f1e5eac9a5138ce105450e9411"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9baba81be56e46677dbe5c558368fd023d45c2a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9baba81be56e46677dbe5c558368fd023d45c2a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9baba81be56e46677dbe5c558368fd023d45c2a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9baba81be56e46677dbe5c558368fd023d45c2a9/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98ca843cfb0e860bf72ad2eafc34e255f633f26c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98ca843cfb0e860bf72ad2eafc34e255f633f26c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98ca843cfb0e860bf72ad2eafc34e255f633f26c"}], "stats": {"total": 2596, "additions": 2547, "deletions": 49}, "files": [{"sha": "489ca19a8a5ba7963688d4252bb9067df89e0653", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9baba81be56e46677dbe5c558368fd023d45c2a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9baba81be56e46677dbe5c558368fd023d45c2a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9baba81be56e46677dbe5c558368fd023d45c2a9", "patch": "@@ -1,3 +1,15 @@\n+2004-07-12  Sebastian Pop  <pop@cri.ensmp.fr>\n+\n+\t* cfgloop.h (struct loop): Add nb_iterations field.\n+\t(current_loops): Declare.  \n+\t* tree-chrec.c (chrec_not_analyzed_yet,\n+\tchrec_dont_know, chrec_known, count_ev_in_wider_type,\n+\tchrec_contains_symbols_defined_in_loop): Remove the temporary\n+\thooks. \n+\t* tree-flow-inline.h (loop_containing_stmt): New function.\n+\t* tree-scalar-evolution.c: Add implementation.\n+\t* tree-scalar-evolution.h: Add declarations.\n+\n 2004-07-12 Vladimir Makarov <vmakarov@redhat.com>\n \n \tPR rtl-optimization/15921"}, {"sha": "8ccffd3e84b1125d6700b214f71b49dbf814fb34", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9baba81be56e46677dbe5c558368fd023d45c2a9/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9baba81be56e46677dbe5c558368fd023d45c2a9/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=9baba81be56e46677dbe5c558368fd023d45c2a9", "patch": "@@ -176,6 +176,13 @@ struct loop\n      loops nested inside it.  */\n   int exit_count;\n \n+  /* The probable number of times the loop is executed at runtime.\n+     This is an INTEGER_CST or an expression containing symbolic\n+     names.  Don't access this field directly:\n+     number_of_iterations_in_loop computes and caches the computed\n+     information in this field.  */\n+  tree nb_iterations;\n+\n   /* Upper bound on number of iterations of a loop.  */\n   struct nb_iter_bound *bounds;\n };\n@@ -227,6 +234,10 @@ struct loops\n   int state;\n };\n \n+/* The loop tree currently optimized.  */\n+\n+extern struct loops *current_loops;\n+\n /* Flags for loop discovery.  */\n \n #define LOOP_TREE\t\t1\t/* Build loop hierarchy tree.  */"}, {"sha": "0e34048be5036c3c68c6bc44aaff7919275afac1", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9baba81be56e46677dbe5c558368fd023d45c2a9/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9baba81be56e46677dbe5c558368fd023d45c2a9/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=9baba81be56e46677dbe5c558368fd023d45c2a9", "patch": "@@ -36,47 +36,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree-chrec.h\"\n #include \"tree-pass.h\"\n \n-\f\n-/* This part will be removed once the merging is finished.  */\n-\n-\n-\n-/* The following trees are unique elements.  Thus the comparison of\n-   another element to these elements should be done on the pointer to\n-   these trees, and not on their value.  */\n-\n-/* The SSA_NAMEs that are not yet analyzed are qualified with NULL_TREE.  */\n-tree chrec_not_analyzed_yet;\n-\n-/* Reserved to the cases where the analyzer has detected an\n-   undecidable property at compile time.  */\n-tree chrec_dont_know;\n-\n-/* When the analyzer has detected that a property will never\n-   happen, then it qualifies it with chrec_known.  */\n-tree chrec_known;\n-\n-/* Empty hook.  Will be replaced by the main function from\n-   tree-scalar-evolution.c.  */\n-\n-tree\n-count_ev_in_wider_type (tree foo ATTRIBUTE_UNUSED, \n-\t\t\ttree bar ATTRIBUTE_UNUSED)\n-{\n-  return NULL_TREE;\n-}\n-\n-/* Empty hook.  Will be replaced by the main function from\n-   tree-scalar-evolution.c.  */\n-\n-bool \n-chrec_contains_symbols_defined_in_loop (tree chrec ATTRIBUTE_UNUSED, \n-\t\t\t\t\tunsigned loop_nb ATTRIBUTE_UNUSED)\n-{\n-  return true;\n-}\n-\n-\n \f\n \n /* Extended folder for chrecs.  */"}, {"sha": "b6f81bc60196bed2467269ddf874d5faa414ecfa", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9baba81be56e46677dbe5c558368fd023d45c2a9/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9baba81be56e46677dbe5c558368fd023d45c2a9/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=9baba81be56e46677dbe5c558368fd023d45c2a9", "patch": "@@ -633,6 +633,18 @@ bsi_stmt_ptr (block_stmt_iterator i)\n   return tsi_stmt_ptr (i.tsi);\n }\n \n+/* Returns the loop of the statement STMT.  */\n+\n+static inline struct loop *\n+loop_containing_stmt (tree stmt)\n+{\n+  basic_block bb = bb_for_stmt (stmt);\n+  if (!bb)\n+    return NULL;\n+\n+  return bb->loop_father;\n+}\n+\n /* Return true if VAR may be aliased.  */\n static inline bool\n may_be_aliased (tree var)"}, {"sha": "d56b672274bf3f3cf008106ea9ac804f9fc0b959", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 2502, "deletions": 8, "changes": 2510, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9baba81be56e46677dbe5c558368fd023d45c2a9/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9baba81be56e46677dbe5c558368fd023d45c2a9/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=9baba81be56e46677dbe5c558368fd023d45c2a9", "patch": "@@ -19,13 +19,227 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n+/* \n+   Description: \n+   \n+   This pass analyzes the evolution of scalar variables in loop\n+   structures.  The algorithm is based on the SSA representation,\n+   and on the loop hierarchy tree.  This algorithm is not based on\n+   the notion of versions of a variable, as it was the case for the\n+   previous implementations of the scalar evolution algorithm, but\n+   it assumes that each defined name is unique.\n+\n+   The notation used in this file is called \"chains of recurrences\",\n+   and has been proposed by Eugene Zima, Robert Van Engelen, and\n+   others for describing induction variables in programs.  For example\n+   \"b -> {0, +, 2}_1\" means that the scalar variable \"b\" is equal to 0\n+   when entering in the loop_1 and has a step 2 in this loop, in other\n+   words \"for (b = 0; b < N; b+=2);\".  Note that the coefficients of\n+   this chain of recurrence (or chrec [shrek]) can contain the name of\n+   other variables, in which case they are called parametric chrecs.\n+   For example, \"b -> {a, +, 2}_1\" means that the initial value of \"b\"\n+   is the value of \"a\".  In most of the cases these parametric chrecs\n+   are fully instantiated before their use because symbolic names can\n+   hide some difficult cases such as self-references described later\n+   (see the Fibonacci example).\n+   \n+   A short sketch of the algorithm is:\n+     \n+   Given a scalar variable to be analyzed, follow the SSA edge to\n+   its definition:\n+     \n+   - When the definition is a MODIFY_EXPR: if the right hand side\n+   (RHS) of the definition cannot be statically analyzed, the answer\n+   of the analyzer is: \"don't know\".  \n+   Otherwise, for all the variables that are not yet analyzed in the\n+   RHS, try to determine their evolution, and finally try to\n+   evaluate the operation of the RHS that gives the evolution\n+   function of the analyzed variable.\n+\n+   - When the definition is a condition-phi-node: determine the\n+   evolution function for all the branches of the phi node, and\n+   finally merge these evolutions (see chrec_merge).\n+\n+   - When the definition is a loop-phi-node: determine its initial\n+   condition, that is the SSA edge defined in an outer loop, and\n+   keep it symbolic.  Then determine the SSA edges that are defined\n+   in the body of the loop.  Follow the inner edges until ending on\n+   another loop-phi-node of the same analyzed loop.  If the reached\n+   loop-phi-node is not the starting loop-phi-node, then we keep\n+   this definition under a symbolic form.  If the reached\n+   loop-phi-node is the same as the starting one, then we compute a\n+   symbolic stride on the return path.  The result is then the\n+   symbolic chrec {initial_condition, +, symbolic_stride}_loop.\n+\n+   Examples:\n+   \n+   Example 1: Illustration of the basic algorithm.\n+   \n+   | a = 3\n+   | loop_1\n+   |   b = phi (a, c)\n+   |   c = b + 1\n+   |   if (c > 10) exit_loop\n+   | endloop\n+   \n+   Suppose that we want to know the number of iterations of the\n+   loop_1.  The exit_loop is controlled by a COND_EXPR (c > 10).  We\n+   ask the scalar evolution analyzer two questions: what's the\n+   scalar evolution (scev) of \"c\", and what's the scev of \"10\".  For\n+   \"10\" the answer is \"10\" since it is a scalar constant.  For the\n+   scalar variable \"c\", it follows the SSA edge to its definition,\n+   \"c = b + 1\", and then asks again what's the scev of \"b\".\n+   Following the SSA edge, we end on a loop-phi-node \"b = phi (a,\n+   c)\", where the initial condition is \"a\", and the inner loop edge\n+   is \"c\".  The initial condition is kept under a symbolic form (it\n+   may be the case that the copy constant propagation has done its\n+   work and we end with the constant \"3\" as one of the edges of the\n+   loop-phi-node).  The update edge is followed to the end of the\n+   loop, and until reaching again the starting loop-phi-node: b -> c\n+   -> b.  At this point we have drawn a path from \"b\" to \"b\" from\n+   which we compute the stride in the loop: in this example it is\n+   \"+1\".  The resulting scev for \"b\" is \"b -> {a, +, 1}_1\".  Now\n+   that the scev for \"b\" is known, it is possible to compute the\n+   scev for \"c\", that is \"c -> {a + 1, +, 1}_1\".  In order to\n+   determine the number of iterations in the loop_1, we have to\n+   instantiate_parameters ({a + 1, +, 1}_1), that gives after some\n+   more analysis the scev {4, +, 1}_1, or in other words, this is\n+   the function \"f (x) = x + 4\", where x is the iteration count of\n+   the loop_1.  Now we have to solve the inequality \"x + 4 > 10\",\n+   and take the smallest iteration number for which the loop is\n+   exited: x = 7.  This loop runs from x = 0 to x = 7, and in total\n+   there are 8 iterations.  In terms of loop normalization, we have\n+   created a variable that is implicitly defined, \"x\" or just \"_1\",\n+   and all the other analyzed scalars of the loop are defined in\n+   function of this variable:\n+   \n+   a -> 3\n+   b -> {3, +, 1}_1\n+   c -> {4, +, 1}_1\n+     \n+   or in terms of a C program: \n+     \n+   | a = 3\n+   | for (x = 0; x <= 7; x++)\n+   |   {\n+   |     b = x + 3\n+   |     c = x + 4\n+   |   }\n+     \n+   Example 2: Illustration of the algorithm on nested loops.\n+     \n+   | loop_1\n+   |   a = phi (1, b)\n+   |   c = a + 2\n+   |   loop_2  10 times\n+   |     b = phi (c, d)\n+   |     d = b + 3\n+   |   endloop\n+   | endloop\n+     \n+   For analyzing the scalar evolution of \"a\", the algorithm follows\n+   the SSA edge into the loop's body: \"a -> b\".  \"b\" is an inner\n+   loop-phi-node, and its analysis as in Example 1, gives: \n+     \n+   b -> {c, +, 3}_2\n+   d -> {c + 3, +, 3}_2\n+     \n+   Following the SSA edge for the initial condition, we end on \"c = a\n+   + 2\", and then on the starting loop-phi-node \"a\".  From this point,\n+   the loop stride is computed: back on \"c = a + 2\" we get a \"+2\" in\n+   the loop_1, then on the loop-phi-node \"b\" we compute the overall\n+   effect of the inner loop that is \"b = c + 30\", and we get a \"+30\"\n+   in the loop_1.  That means that the overall stride in loop_1 is\n+   equal to \"+32\", and the result is: \n+     \n+   a -> {1, +, 32}_1\n+   c -> {3, +, 32}_1\n+     \n+   Example 3: Higher degree polynomials.\n+     \n+   | loop_1\n+   |   a = phi (2, b)\n+   |   c = phi (5, d)\n+   |   b = a + 1\n+   |   d = c + a\n+   | endloop\n+     \n+   a -> {2, +, 1}_1\n+   b -> {3, +, 1}_1\n+   c -> {5, +, a}_1\n+   d -> {5 + a, +, a}_1\n+     \n+   instantiate_parameters ({5, +, a}_1) -> {5, +, 2, +, 1}_1\n+   instantiate_parameters ({5 + a, +, a}_1) -> {7, +, 3, +, 1}_1\n+     \n+   Example 4: Lucas, Fibonacci, or mixers in general.\n+     \n+   | loop_1\n+   |   a = phi (1, b)\n+   |   c = phi (3, d)\n+   |   b = c\n+   |   d = c + a\n+   | endloop\n+     \n+   a -> (1, c)_1\n+   c -> {3, +, a}_1\n+     \n+   The syntax \"(1, c)_1\" stands for a PEELED_CHREC that has the\n+   following semantics: during the first iteration of the loop_1, the\n+   variable contains the value 1, and then it contains the value \"c\".\n+   Note that this syntax is close to the syntax of the loop-phi-node:\n+   \"a -> (1, c)_1\" vs. \"a = phi (1, c)\".\n+     \n+   The symbolic chrec representation contains all the semantics of the\n+   original code.  What is more difficult is to use this information.\n+     \n+   Example 5: Flip-flops, or exchangers.\n+     \n+   | loop_1\n+   |   a = phi (1, b)\n+   |   c = phi (3, d)\n+   |   b = c\n+   |   d = a\n+   | endloop\n+     \n+   a -> (1, c)_1\n+   c -> (3, a)_1\n+     \n+   Based on these symbolic chrecs, it is possible to refine this\n+   information into the more precise PERIODIC_CHRECs: \n+     \n+   a -> |1, 3|_1\n+   c -> |3, 1|_1\n+     \n+   This transformation is not yet implemented.\n+     \n+   Further readings:\n+   \n+   You can find a more detailed description of the algorithm in:\n+   http://icps.u-strasbg.fr/~pop/DEA_03_Pop.pdf\n+   http://icps.u-strasbg.fr/~pop/DEA_03_Pop.ps.gz.  But note that\n+   this is a preliminary report and some of the details of the\n+   algorithm have changed.  I'm working on a research report that\n+   updates the description of the algorithms to reflect the design\n+   choices used in this implementation.\n+     \n+   A set of slides show a high level overview of the algorithm and run\n+   an example through the scalar evolution analyzer:\n+   http://cri.ensmp.fr/~pop/gcc/mar04/slides.pdf\n+\n+   The slides that I have presented at the GCC Summit'04 are available\n+   at: http://cri.ensmp.fr/~pop/gcc/20040604/gccsummit-lno-spop.pdf\n+*/\n+\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"errors.h\"\n #include \"ggc.h\"\n #include \"tree.h\"\n+\n+/* These RTL headers are needed for basic-block.h.  */\n #include \"rtl.h\"\n #include \"basic-block.h\"\n #include \"diagnostic.h\"\n@@ -35,27 +249,2307 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"cfgloop.h\"\n #include \"tree-chrec.h\"\n #include \"tree-scalar-evolution.h\"\n+#include \"tree-pass.h\"\n+#include \"flags.h\"\n+\n+static tree analyze_scalar_evolution_1 (struct loop *, tree, tree);\n+static tree resolve_mixers (struct loop *, tree);\n+\n+/* The cached information about a ssa name VAR, claiming that inside LOOP,\n+   the value of VAR can be expressed as CHREC.  */\n+\n+struct scev_info_str\n+{\n+  tree var;\n+  tree chrec;\n+};\n+\n+/* Counters for the scev database.  */\n+static unsigned nb_set_scev = 0;\n+static unsigned nb_get_scev = 0;\n+\n+/* The following trees are unique elements.  Thus the comparison of\n+   another element to these elements should be done on the pointer to\n+   these trees, and not on their value.  */\n+\n+/* The SSA_NAMEs that are not yet analyzed are qualified with NULL_TREE.  */\n+tree chrec_not_analyzed_yet;\n+\n+/* Reserved to the cases where the analyzer has detected an\n+   undecidable property at compile time.  */\n+tree chrec_dont_know;\n+\n+/* When the analyzer has detected that a property will never\n+   happen, then it qualifies it with chrec_known.  */\n+tree chrec_known;\n+\n+static bitmap already_instantiated;\n+\n+static htab_t scalar_evolution_info;\n+\n+\f\n+/* Constructs a new SCEV_INFO_STR structure.  */\n+\n+static inline struct scev_info_str *\n+new_scev_info_str (tree var)\n+{\n+  struct scev_info_str *res;\n+  \n+  res = xmalloc (sizeof (struct scev_info_str));\n+  res->var = var;\n+  res->chrec = chrec_not_analyzed_yet;\n+  \n+  return res;\n+}\n+\n+/* Computes a hash function for database element ELT.  */\n+\n+static hashval_t\n+hash_scev_info (const void *elt)\n+{\n+  return SSA_NAME_VERSION (((struct scev_info_str *) elt)->var);\n+}\n+\n+/* Compares database elements E1 and E2.  */\n+\n+static int\n+eq_scev_info (const void *e1, const void *e2)\n+{\n+  const struct scev_info_str *elt1 = e1;\n+  const struct scev_info_str *elt2 = e2;\n+\n+  return elt1->var == elt2->var;\n+}\n+\n+/* Deletes database element E.  */\n+\n+static void\n+del_scev_info (void *e)\n+{\n+  free (e);\n+}\n+\n+/* Get the index corresponding to VAR in the current LOOP.  If\n+   it's the first time we ask for this VAR, then we return\n+   chrec_not_analysed_yet for this VAR and return its index.  */\n+\n+static tree *\n+find_var_scev_info (tree var)\n+{\n+  struct scev_info_str *res;\n+  struct scev_info_str tmp;\n+  PTR *slot;\n+\n+  tmp.var = var;\n+  slot = htab_find_slot (scalar_evolution_info, &tmp, INSERT);\n+\n+  if (!*slot)\n+    *slot = new_scev_info_str (var);\n+  res = *slot;\n+\n+  return &res->chrec;\n+}\n+\n+/* Tries to express CHREC in wider type TYPE.  */\n+\n+tree\n+count_ev_in_wider_type (tree type, tree chrec)\n+{\n+  tree base, step;\n+  struct loop *loop;\n+\n+  if (!evolution_function_is_affine_p (chrec))\n+    return fold_convert (type, chrec);\n+\n+  base = CHREC_LEFT (chrec);\n+  step = CHREC_RIGHT (chrec);\n+  loop = current_loops->parray[CHREC_VARIABLE (chrec)];\n+\n+  /* TODO -- if we knew the statement at that the conversion occurs,\n+     we could pass it to can_count_iv_in_wider_type and get a better\n+     result.  */\n+  step = can_count_iv_in_wider_type (loop, type, base, step, NULL_TREE);\n+  if (!step)\n+    return fold_convert (type, chrec);\n+  base = chrec_convert (type, base);\n+\n+  return build_polynomial_chrec (CHREC_VARIABLE (chrec),\n+\t\t\t\t base, step);\n+}\n+\n+/* Return true when CHREC contains symbolic names defined in\n+   LOOP_NB.  */\n+\n+bool \n+chrec_contains_symbols_defined_in_loop (tree chrec, unsigned loop_nb)\n+{\n+  if (chrec == NULL_TREE)\n+    return false;\n+\n+  if (TREE_INVARIANT (chrec))\n+    return false;\n+\n+  if (TREE_CODE (chrec) == VAR_DECL\n+      || TREE_CODE (chrec) == PARM_DECL\n+      || TREE_CODE (chrec) == FUNCTION_DECL\n+      || TREE_CODE (chrec) == LABEL_DECL\n+      || TREE_CODE (chrec) == RESULT_DECL\n+      || TREE_CODE (chrec) == FIELD_DECL)\n+    return true;\n+\n+  if (TREE_CODE (chrec) == SSA_NAME)\n+    {\n+      tree def = SSA_NAME_DEF_STMT (chrec);\n+      struct loop *def_loop = loop_containing_stmt (def);\n+      struct loop *loop = current_loops->parray[loop_nb];\n+\n+      if (def_loop == NULL)\n+\treturn false;\n+\n+      if (loop == def_loop || flow_loop_nested_p (loop, def_loop))\n+\treturn true;\n+\n+      return false;\n+    }\n+\n+  switch (TREE_CODE_LENGTH (TREE_CODE (chrec)))\n+    {\n+    case 3:\n+      if (chrec_contains_symbols_defined_in_loop (TREE_OPERAND (chrec, 2), \n+\t\t\t\t\t\t  loop_nb))\n+\treturn true;\n+\n+    case 2:\n+      if (chrec_contains_symbols_defined_in_loop (TREE_OPERAND (chrec, 1), \n+\t\t\t\t\t\t  loop_nb))\n+\treturn true;\n+\n+    case 1:\n+      if (chrec_contains_symbols_defined_in_loop (TREE_OPERAND (chrec, 0), \n+\t\t\t\t\t\t  loop_nb))\n+\treturn true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Return true when PHI is a loop-phi-node.  */\n+\n+static bool\n+loop_phi_node_p (tree phi)\n+{\n+  /* The implementation of this function is based on the following\n+     property: \"all the loop-phi-nodes of a loop are contained in the\n+     loop's header basic block\".  */\n+\n+  return loop_containing_stmt (phi)->header == bb_for_stmt (phi);\n+}\n+\n+/* Compute the scalar evolution for EVOLUTION_FN after crossing LOOP.\n+   In general, in the case of multivariate evolutions we want to get\n+   the evolution in different loops.  LOOP specifies the level for\n+   which to get the evolution.\n+   \n+   Example:\n+   \n+   | for (j = 0; j < 100; j++)\n+   |   {\n+   |     for (k = 0; k < 100; k++)\n+   |       {\n+   |         i = k + j;   - Here the value of i is a function of j, k. \n+   |       }\n+   |      ... = i         - Here the value of i is a function of j. \n+   |   }\n+   | ... = i              - Here the value of i is a scalar.  \n+   \n+   Example:  \n+   \n+   | i_0 = ...\n+   | loop_1 10 times\n+   |   i_1 = phi (i_0, i_2)\n+   |   i_2 = i_1 + 2\n+   | endloop\n+    \n+   This loop has the same effect as:\n+   LOOP_1 has the same effect as:\n+    \n+   | i_1 = i_0 + 20\n+   \n+   The overall effect of the loop, \"i_0 + 20\" in the previous example, \n+   is obtained by passing in the parameters: LOOP = 1, \n+   EVOLUTION_FN = {i_0, +, 2}_1.\n+*/\n+ \n+static tree \n+compute_overall_effect_of_inner_loop (struct loop *loop, tree evolution_fn)\n+{\n+  bool val = false;\n+\n+  if (evolution_fn == chrec_dont_know)\n+    return chrec_dont_know;\n+\n+  else if (TREE_CODE (evolution_fn) == POLYNOMIAL_CHREC)\n+    {\n+      if (CHREC_VARIABLE (evolution_fn) >= (unsigned) loop->num)\n+\t{\n+\t  struct loop *inner_loop = \n+\t    current_loops->parray[CHREC_VARIABLE (evolution_fn)];\n+\t  tree nb_iter = number_of_iterations_in_loop (inner_loop);\n+\n+\t  if (nb_iter == chrec_dont_know)\n+\t    return chrec_dont_know;\n+\t  else\n+\t    {\n+\t      tree res;\n+\n+\t      /* Number of iterations is off by one (the ssa name we\n+\t\t analyze must be defined before the exit).  */\n+\t      nb_iter = chrec_fold_minus (chrec_type (nb_iter),\n+\t\t\t\t\t  nb_iter,\n+\t\t\t\t\t  fold_convert (chrec_type (nb_iter),\n+\t\t\t\t\t\t        integer_one_node));\n+\t      \n+\t      /* evolution_fn is the evolution function in LOOP.  Get\n+\t\t its value in the nb_iter-th iteration.  */\n+\t      res = chrec_apply (inner_loop->num, evolution_fn, nb_iter);\n+\t      \n+\t      /* Continue the computation until ending on a parent of LOOP. */\n+\t      return compute_overall_effect_of_inner_loop (loop, res);\n+\t    }\n+\t}\n+      else\n+\treturn evolution_fn;\n+     }\n+  \n+  /* If the evolution function is an invariant, there is nothing to do.  */\n+  else if (no_evolution_in_loop_p (evolution_fn, loop->num, &val) && val)\n+    return evolution_fn;\n+  \n+  else\n+    return chrec_dont_know;\n+}\n+\n+/* Determine whether the CHREC is always positive/negative.  If the expression\n+   cannot be statically analyzed, return false, otherwise set the answer into\n+   VALUE.  */\n+\n+bool\n+chrec_is_positive (tree chrec, bool *value)\n+{\n+  bool value0, value1;\n+  bool value2;\n+  tree end_value;\n+  tree nb_iter;\n+  \n+  switch (TREE_CODE (chrec))\n+    {\n+    case POLYNOMIAL_CHREC:\n+      if (!chrec_is_positive (CHREC_LEFT (chrec), &value0)\n+\t  || !chrec_is_positive (CHREC_RIGHT (chrec), &value1))\n+\treturn false;\n+     \n+      /* FIXME -- overflows.  */\n+      if (value0 == value1)\n+\t{\n+\t  *value = value0;\n+\t  return true;\n+\t}\n+\n+      /* Otherwise the chrec is under the form: \"{-197, +, 2}_1\",\n+\t and the proof consists in showing that the sign never\n+\t changes during the execution of the loop, from 0 to\n+\t loop->nb_iterations.  */\n+      if (!evolution_function_is_affine_p (chrec))\n+\treturn false;\n+\n+      nb_iter = number_of_iterations_in_loop\n+\t(current_loops->parray[CHREC_VARIABLE (chrec)]);\n+\n+      if (chrec_contains_undetermined (nb_iter))\n+\treturn false;\n+\n+      nb_iter = chrec_fold_minus \n+\t(chrec_type (nb_iter), nb_iter,\n+\t fold_convert (chrec_type (nb_iter), integer_one_node));\n+\n+#if 0\n+      /* TODO -- If the test is after the exit, we may decrease the number of\n+\t iterations by one.  */\n+      if (after_exit)\n+\tnb_iter = chrec_fold_minus \n+\t\t(chrec_type (nb_iter), nb_iter,\n+\t\t fold_convert (chrec_type (nb_iter), integer_one_node));\n+#endif\n+\n+      end_value = chrec_apply (CHREC_VARIABLE (chrec), chrec, nb_iter);\n+\t      \n+      if (!chrec_is_positive (end_value, &value2))\n+\treturn false;\n+\t\n+      *value = value0;\n+      return value0 == value1;\n+      \n+    case INTEGER_CST:\n+      *value = (tree_int_cst_sgn (chrec) == 1);\n+      return true;\n+      \n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Associate CHREC to SCALAR.  */\n+\n+static void\n+set_scalar_evolution (tree scalar, tree chrec)\n+{\n+  tree *scalar_info;\n+ \n+  if (TREE_CODE (scalar) != SSA_NAME)\n+    return;\n+\n+  scalar_info = find_var_scev_info (scalar);\n+  \n+  if (dump_file)\n+    {\n+      if (dump_flags & TDF_DETAILS)\n+\t{\n+\t  fprintf (dump_file, \"(set_scalar_evolution \\n\");\n+\t  fprintf (dump_file, \"  (scalar = \");\n+\t  print_generic_expr (dump_file, scalar, 0);\n+\t  fprintf (dump_file, \")\\n  (scalar_evolution = \");\n+\t  print_generic_expr (dump_file, chrec, 0);\n+\t  fprintf (dump_file, \"))\\n\");\n+\t}\n+      if (dump_flags & TDF_STATS)\n+\tnb_set_scev++;\n+    }\n+  \n+  *scalar_info = chrec;\n+}\n+\n+/* Retrieve the chrec associated to SCALAR in the LOOP.  */\n+\n+static tree\n+get_scalar_evolution (tree scalar)\n+{\n+  tree res;\n+  \n+  if (dump_file)\n+    {\n+      if (dump_flags & TDF_DETAILS)\n+\t{\n+\t  fprintf (dump_file, \"(get_scalar_evolution \\n\");\n+\t  fprintf (dump_file, \"  (scalar = \");\n+\t  print_generic_expr (dump_file, scalar, 0);\n+\t  fprintf (dump_file, \")\\n\");\n+\t}\n+      if (dump_flags & TDF_STATS)\n+\tnb_get_scev++;\n+    }\n+  \n+  switch (TREE_CODE (scalar))\n+    {\n+    case SSA_NAME:\n+      res = *find_var_scev_info (scalar);\n+      break;\n+\n+    case REAL_CST:\n+    case INTEGER_CST:\n+      res = scalar;\n+      break;\n+\n+    default:\n+      res = chrec_not_analyzed_yet;\n+      break;\n+    }\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"  (scalar_evolution = \");\n+      print_generic_expr (dump_file, res, 0);\n+      fprintf (dump_file, \"))\\n\");\n+    }\n+  \n+  return res;\n+}\n+\n+/* Helper function for add_to_evolution.  Returns the evolution\n+   function for an assignment of the form \"a = b + c\", where \"a\" and\n+   \"b\" are on the strongly connected component.  CHREC_BEFORE is the\n+   information that we already have collected up to this point.\n+   TO_ADD is the evolution of \"c\".  \n+   \n+   When CHREC_BEFORE has an evolution part in LOOP_NB, add to this\n+   evolution the expression TO_ADD, otherwise construct an evolution\n+   part for this loop.  */\n+\n+static tree\n+add_to_evolution_1 (unsigned loop_nb, \n+\t\t    tree chrec_before, \n+\t\t    tree to_add)\n+{\n+  switch (TREE_CODE (chrec_before))\n+    {\n+    case POLYNOMIAL_CHREC:\n+      if (CHREC_VARIABLE (chrec_before) <= loop_nb)\n+\t{\n+\t  unsigned var;\n+\t  tree left, right;\n+\t  tree type = chrec_type (chrec_before);\n+\t  \n+\t  /* When there is no evolution part in this loop, build it.  */\n+\t  if (CHREC_VARIABLE (chrec_before) < loop_nb)\n+\t    {\n+\t      var = loop_nb;\n+\t      left = chrec_before;\n+\t      right = fold_convert (type, integer_zero_node);\n+\t    }\n+\t  else\n+\t    {\n+\t      var = CHREC_VARIABLE (chrec_before);\n+\t      left = CHREC_LEFT (chrec_before);\n+\t      right = CHREC_RIGHT (chrec_before);\n+\t    }\n+\n+\t  return build_polynomial_chrec \n+\t    (var, left, chrec_fold_plus (type, right, to_add));\n+\t}\n+      else\n+\t/* Search the evolution in LOOP_NB.  */\n+\treturn build_polynomial_chrec \n+\t  (CHREC_VARIABLE (chrec_before),\n+\t   add_to_evolution_1 (loop_nb, CHREC_LEFT (chrec_before), to_add),\n+\t   CHREC_RIGHT (chrec_before));\n+      \n+    default:\n+      /* These nodes do not depend on a loop.  */\n+      if (chrec_before == chrec_dont_know)\n+\treturn chrec_dont_know;\n+      return build_polynomial_chrec (loop_nb, chrec_before, to_add);\n+    }\n+}\n+\n+/* Add TO_ADD to the evolution part of CHREC_BEFORE in the dimension\n+   of LOOP_NB.  \n+   \n+   Description (provided for completeness, for those who read code in\n+   a plane, and for my poor 62 bytes brain that would have forgotten\n+   all this in the next two or three months):\n+   \n+   The algorithm of translation of programs from the SSA representation\n+   into the chrecs syntax is based on a pattern matching.  After having\n+   reconstructed the overall tree expression for a loop, there are only\n+   two cases that can arise:\n+   \n+   1. a = loop-phi (init, a + expr)\n+   2. a = loop-phi (init, expr)\n+   \n+   where EXPR is either a scalar constant with respect to the analyzed\n+   loop (this is a degree 0 polynomial), or an expression containing\n+   other loop-phi definitions (these are higher degree polynomials).\n+   \n+   Examples:\n+   \n+   1. \n+   | init = ...\n+   | loop_1\n+   |   a = phi (init, a + 5)\n+   | endloop\n+   \n+   2. \n+   | inita = ...\n+   | initb = ...\n+   | loop_1\n+   |   a = phi (inita, 2 * b + 3)\n+   |   b = phi (initb, b + 1)\n+   | endloop\n+   \n+   For the first case, the semantics of the SSA representation is: \n+   \n+   | a (x) = init + \\sum_{j = 0}^{x - 1} expr (j)\n+   \n+   that is, there is a loop index \"x\" that determines the scalar value\n+   of the variable during the loop execution.  During the first\n+   iteration, the value is that of the initial condition INIT, while\n+   during the subsequent iterations, it is the sum of the initial\n+   condition with the sum of all the values of EXPR from the initial\n+   iteration to the before last considered iteration.  \n+   \n+   For the second case, the semantics of the SSA program is:\n+   \n+   | a (x) = init, if x = 0;\n+   |         expr (x - 1), otherwise.\n+   \n+   The second case corresponds to the PEELED_CHREC, whose syntax is\n+   close to the syntax of a loop-phi-node: \n+   \n+   | phi (init, expr)  vs.  (init, expr)_x\n+   \n+   The proof of the translation algorithm for the first case is a\n+   proof by structural induction based on the degree of EXPR.  \n+   \n+   Degree 0:\n+   When EXPR is a constant with respect to the analyzed loop, or in\n+   other words when EXPR is a polynomial of degree 0, the evolution of\n+   the variable A in the loop is an affine function with an initial\n+   condition INIT, and a step EXPR.  In order to show this, we start\n+   from the semantics of the SSA representation:\n+   \n+   f (x) = init + \\sum_{j = 0}^{x - 1} expr (j)\n+   \n+   and since \"expr (j)\" is a constant with respect to \"j\",\n+   \n+   f (x) = init + x * expr \n+   \n+   Finally, based on the semantics of the pure sum chrecs, by\n+   identification we get the corresponding chrecs syntax:\n+   \n+   f (x) = init * \\binom{x}{0} + expr * \\binom{x}{1} \n+   f (x) -> {init, +, expr}_x\n+   \n+   Higher degree:\n+   Suppose that EXPR is a polynomial of degree N with respect to the\n+   analyzed loop_x for which we have already determined that it is\n+   written under the chrecs syntax:\n+   \n+   | expr (x)  ->  {b_0, +, b_1, +, ..., +, b_{n-1}} (x)\n+   \n+   We start from the semantics of the SSA program:\n+   \n+   | f (x) = init + \\sum_{j = 0}^{x - 1} expr (j)\n+   |\n+   | f (x) = init + \\sum_{j = 0}^{x - 1} \n+   |                (b_0 * \\binom{j}{0} + ... + b_{n-1} * \\binom{j}{n-1})\n+   |\n+   | f (x) = init + \\sum_{j = 0}^{x - 1} \n+   |                \\sum_{k = 0}^{n - 1} (b_k * \\binom{j}{k}) \n+   |\n+   | f (x) = init + \\sum_{k = 0}^{n - 1} \n+   |                (b_k * \\sum_{j = 0}^{x - 1} \\binom{j}{k}) \n+   |\n+   | f (x) = init + \\sum_{k = 0}^{n - 1} \n+   |                (b_k * \\binom{x}{k + 1}) \n+   |\n+   | f (x) = init + b_0 * \\binom{x}{1} + ... \n+   |              + b_{n-1} * \\binom{x}{n} \n+   |\n+   | f (x) = init * \\binom{x}{0} + b_0 * \\binom{x}{1} + ... \n+   |                             + b_{n-1} * \\binom{x}{n} \n+   |\n+   \n+   And finally from the definition of the chrecs syntax, we identify:\n+   | f (x)  ->  {init, +, b_0, +, ..., +, b_{n-1}}_x \n+   \n+   This shows the mechanism that stands behind the add_to_evolution\n+   function.  An important point is that the use of symbolic\n+   parameters avoids the need of an analysis schedule.\n+   \n+   Example:\n+   \n+   | inita = ...\n+   | initb = ...\n+   | loop_1 \n+   |   a = phi (inita, a + 2 + b)\n+   |   b = phi (initb, b + 1)\n+   | endloop\n+   \n+   When analyzing \"a\", the algorithm keeps \"b\" symbolically:\n+   \n+   | a  ->  {inita, +, 2 + b}_1\n+   \n+   Then, after instantiation, the analyzer ends on the evolution:\n+   \n+   | a  ->  {inita, +, 2 + initb, +, 1}_1\n+\n+*/\n+\n+static tree \n+add_to_evolution (unsigned loop_nb, \n+\t\t  tree chrec_before,\n+\t\t  enum tree_code code,\n+\t\t  tree to_add)\n+{\n+  tree type = chrec_type (to_add);\n+  tree res = NULL_TREE;\n+  \n+  if (to_add == NULL_TREE)\n+    return chrec_before;\n+  \n+  /* TO_ADD is either a scalar, or a parameter.  TO_ADD is not\n+     instantiated at this point.  */\n+  if (TREE_CODE (to_add) == POLYNOMIAL_CHREC)\n+    /* This should not happen.  */\n+    return chrec_dont_know;\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"(add_to_evolution \\n\");\n+      fprintf (dump_file, \"  (loop_nb = %d)\\n\", loop_nb);\n+      fprintf (dump_file, \"  (chrec_before = \");\n+      print_generic_expr (dump_file, chrec_before, 0);\n+      fprintf (dump_file, \")\\n  (to_add = \");\n+      print_generic_expr (dump_file, to_add, 0);\n+      fprintf (dump_file, \")\\n\");\n+    }\n+\n+  if (code == MINUS_EXPR)\n+    to_add = chrec_fold_multiply (type, to_add, \n+\t\t\t\t  fold_convert (type, integer_minus_one_node));\n+\n+  res = add_to_evolution_1 (loop_nb, chrec_before, to_add);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"  (res = \");\n+      print_generic_expr (dump_file, res, 0);\n+      fprintf (dump_file, \"))\\n\");\n+    }\n+\n+  return res;\n+}\n+\n+/* Helper function.  */\n+\n+static inline tree\n+set_nb_iterations_in_loop (struct loop *loop, \n+\t\t\t   tree res)\n+{\n+  res = chrec_fold_plus (chrec_type (res), res, integer_one_node);\n+  /* FIXME HWI: However we want to store one iteration less than the\n+     count of the loop in order to be compatible with the other\n+     nb_iter computations in loop-iv.  This also allows the\n+     representation of nb_iters that are equal to MAX_INT.  */\n+  if ((TREE_CODE (res) == INTEGER_CST && TREE_INT_CST_LOW (res) == 0)\n+      || TREE_OVERFLOW (res))\n+    res = chrec_dont_know;\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"  (set_nb_iterations_in_loop = \");\n+      print_generic_expr (dump_file, res, 0);\n+      fprintf (dump_file, \"))\\n\");\n+    }\n+  \n+  loop->nb_iterations = res;\n+  return res;\n+}\n+\n+\f\n+\n+/* This section selects the loops that will be good candidates for the\n+   scalar evolution analysis.  For the moment, greedily select all the\n+   loop nests we could analyze.  */\n+\n+/* Return true when it is possible to analyze the condition expression\n+   EXPR.  */\n+\n+static bool\n+analyzable_condition (tree expr)\n+{\n+  tree condition;\n+  \n+  if (TREE_CODE (expr) != COND_EXPR)\n+    return false;\n+  \n+  condition = TREE_OPERAND (expr, 0);\n+  \n+  switch (TREE_CODE (condition))\n+    {\n+    case SSA_NAME:\n+      /* Volatile expressions are not analyzable.  */\n+      if (TREE_THIS_VOLATILE (SSA_NAME_VAR (condition)))\n+\treturn false;\n+      return true;\n+      \n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+      {\n+\ttree opnd0, opnd1;\n+\t\n+\topnd0 = TREE_OPERAND (condition, 0);\n+\topnd1 = TREE_OPERAND (condition, 1);\n+\t\n+\tif (TREE_CODE (opnd0) == SSA_NAME\n+\t    && TREE_THIS_VOLATILE (SSA_NAME_VAR (opnd0)))\n+\t  return false;\n+\t\n+\tif (TREE_CODE (opnd1) == SSA_NAME\n+\t    && TREE_THIS_VOLATILE (SSA_NAME_VAR (opnd1)))\n+\t  return false;\n+\t\n+\treturn true;\n+      }\n+      \n+    default:\n+      return false;\n+    }\n+  \n+  return false;\n+}\n+\n+/* For a loop with a single exit edge, return the COND_EXPR that\n+   guards the exit edge.  If the expression is too difficult to\n+   analyze, then give up.  */\n+\n+tree \n+get_loop_exit_condition (struct loop *loop)\n+{\n+  tree res = NULL_TREE;\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"(get_loop_exit_condition \\n  \");\n+  \n+  if (loop->exit_edges)\n+    {\n+      edge exit_edge;\n+      tree expr;\n+      \n+      exit_edge = loop->exit_edges[0];\n+      expr = last_stmt (exit_edge->src);\n+      \n+      if (analyzable_condition (expr))\n+\tres = expr;\n+    }\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      print_generic_expr (dump_file, res, 0);\n+      fprintf (dump_file, \")\\n\");\n+    }\n+  \n+  return res;\n+}\n+\n+/* Recursively determine and enqueue the exit conditions for a loop.  */\n+\n+static void \n+get_exit_conditions_rec (struct loop *loop, \n+\t\t\t varray_type *exit_conditions)\n+{\n+  if (!loop)\n+    return;\n+  \n+  /* Recurse on the inner loops, then on the next (sibling) loops.  */\n+  get_exit_conditions_rec (loop->inner, exit_conditions);\n+  get_exit_conditions_rec (loop->next, exit_conditions);\n+  \n+  flow_loop_scan (loop, LOOP_EXIT_EDGES);\n+  if (loop->num_exits == 1)\n+    {\n+      tree loop_condition = get_loop_exit_condition (loop);\n+      \n+      if (loop_condition)\n+\tVARRAY_PUSH_TREE (*exit_conditions, loop_condition);\n+    }\n+}\n+\n+/* Select the candidate loop nests for the analysis.  This function\n+   initializes the EXIT_CONDITIONS array.   */\n+\n+static void\n+select_loops_exit_conditions (struct loops *loops, \n+\t\t\t      varray_type *exit_conditions)\n+{\n+  struct loop *function_body = loops->parray[0];\n+  \n+  get_exit_conditions_rec (function_body->inner, exit_conditions);\n+}\n+\n+\f\n+/* Depth first search algorithm.  */\n+\n+static bool follow_ssa_edge (struct loop *loop, tree, tree, tree *);\n+\n+/* Follow the ssa edge into the right hand side RHS of an assignment.\n+   Return true if the strongly connected component has been found.  */\n+\n+static bool\n+follow_ssa_edge_in_rhs (struct loop *loop,\n+\t\t\ttree rhs, \n+\t\t\ttree halting_phi, \n+\t\t\ttree *evolution_of_loop)\n+{\n+  bool res = false;\n+  tree rhs0, rhs1;\n+  tree type_rhs = TREE_TYPE (rhs);\n+  \n+  /* The RHS is one of the following cases:\n+     - an SSA_NAME, \n+     - an INTEGER_CST,\n+     - a PLUS_EXPR, \n+     - a MINUS_EXPR,\n+     - other cases are not yet handled. \n+  */\n+  switch (TREE_CODE (rhs))\n+    {\n+    case NOP_EXPR:\n+      /* This assignment is under the form \"a_1 = (cast) rhs.  */\n+      res = follow_ssa_edge_in_rhs (loop, TREE_OPERAND (rhs, 0), halting_phi, \n+\t\t\t\t    evolution_of_loop);\n+      *evolution_of_loop = chrec_convert (TREE_TYPE (rhs), *evolution_of_loop);\n+      break;\n+\n+    case INTEGER_CST:\n+      /* This assignment is under the form \"a_1 = 7\".  */\n+      res = false;\n+      break;\n+      \n+    case SSA_NAME:\n+      /* This assignment is under the form: \"a_1 = b_2\".  */\n+      res = follow_ssa_edge \n+\t(loop, SSA_NAME_DEF_STMT (rhs), halting_phi, evolution_of_loop);\n+      break;\n+      \n+    case PLUS_EXPR:\n+      /* This case is under the form \"rhs0 + rhs1\".  */\n+      rhs0 = TREE_OPERAND (rhs, 0);\n+      rhs1 = TREE_OPERAND (rhs, 1);\n+      STRIP_TYPE_NOPS (rhs0);\n+      STRIP_TYPE_NOPS (rhs1);\n+\n+      if (TREE_CODE (rhs0) == SSA_NAME)\n+\t{\n+\t  if (TREE_CODE (rhs1) == SSA_NAME)\n+\t    {\n+\t      /* Match an assignment under the form: \n+\t\t \"a = b + c\".  */\n+\t      res = follow_ssa_edge \n+\t\t(loop, SSA_NAME_DEF_STMT (rhs0), halting_phi, \n+\t\t evolution_of_loop);\n+\t      \n+\t      if (res)\n+\t\t*evolution_of_loop = add_to_evolution \n+\t\t  (loop->num, \n+\t\t   chrec_convert (type_rhs, *evolution_of_loop), \n+\t\t   PLUS_EXPR, rhs1);\n+\t      \n+\t      else\n+\t\t{\n+\t\t  res = follow_ssa_edge \n+\t\t    (loop, SSA_NAME_DEF_STMT (rhs1), halting_phi, \n+\t\t     evolution_of_loop);\n+\t\t  \n+\t\t  if (res)\n+\t\t    *evolution_of_loop = add_to_evolution \n+\t\t      (loop->num, \n+\t\t       chrec_convert (type_rhs, *evolution_of_loop), \n+\t\t       PLUS_EXPR, rhs0);\n+\t\t}\n+\t    }\n+\t  \n+\t  else\n+\t    {\n+\t      /* Match an assignment under the form: \n+\t\t \"a = b + ...\".  */\n+\t      res = follow_ssa_edge \n+\t\t(loop, SSA_NAME_DEF_STMT (rhs0), halting_phi, \n+\t\t evolution_of_loop);\n+\t      if (res)\n+\t\t*evolution_of_loop = add_to_evolution \n+\t\t  (loop->num, chrec_convert (type_rhs, *evolution_of_loop), \n+\t\t   PLUS_EXPR, rhs1);\n+\t    }\n+\t}\n+      \n+      else if (TREE_CODE (rhs1) == SSA_NAME)\n+\t{\n+\t  /* Match an assignment under the form: \n+\t     \"a = ... + c\".  */\n+\t  res = follow_ssa_edge \n+\t    (loop, SSA_NAME_DEF_STMT (rhs1), halting_phi, \n+\t     evolution_of_loop);\n+\t  if (res)\n+\t    *evolution_of_loop = add_to_evolution \n+\t      (loop->num, chrec_convert (type_rhs, *evolution_of_loop), \n+\t       PLUS_EXPR, rhs0);\n+\t}\n+\n+      else\n+\t/* Otherwise, match an assignment under the form: \n+\t   \"a = ... + ...\".  */\n+\t/* And there is nothing to do.  */\n+\tres = false;\n+      \n+      break;\n+      \n+    case MINUS_EXPR:\n+      /* This case is under the form \"opnd0 = rhs0 - rhs1\".  */\n+      rhs0 = TREE_OPERAND (rhs, 0);\n+      rhs1 = TREE_OPERAND (rhs, 1);\n+      STRIP_TYPE_NOPS (rhs0);\n+      STRIP_TYPE_NOPS (rhs1);\n+\n+      if (TREE_CODE (rhs0) == SSA_NAME)\n+\t{\n+\t  if (TREE_CODE (rhs1) == SSA_NAME)\n+\t    {\n+\t      /* Match an assignment under the form: \n+\t\t \"a = b - c\".  */\n+\t      res = follow_ssa_edge \n+\t\t(loop, SSA_NAME_DEF_STMT (rhs0), halting_phi, \n+\t\t evolution_of_loop);\n+\t      \n+\t      if (res)\n+\t\t*evolution_of_loop = add_to_evolution \n+\t\t  (loop->num, chrec_convert (type_rhs, *evolution_of_loop), \n+\t\t   MINUS_EXPR, rhs1);\n+\t      \n+\t      else\n+\t\t{\n+\t\t  res = follow_ssa_edge \n+\t\t    (loop, SSA_NAME_DEF_STMT (rhs1), halting_phi, \n+\t\t     evolution_of_loop);\n+\t\t  \n+\t\t  if (res)\n+\t\t    *evolution_of_loop = add_to_evolution \n+\t\t      (loop->num, \n+\t\t       chrec_fold_multiply (type_rhs, \n+\t\t\t\t\t    *evolution_of_loop, \n+\t\t\t\t\t    fold_convert (type_rhs,\n+\t\t\t\t\t\t          integer_minus_one_node)),\n+\t\t       PLUS_EXPR, rhs0);\n+\t\t}\n+\t    }\n+\t  \n+\t  else\n+\t    {\n+\t      /* Match an assignment under the form: \n+\t\t \"a = b - ...\".  */\n+\t      res = follow_ssa_edge \n+\t\t(loop, SSA_NAME_DEF_STMT (rhs0), halting_phi, \n+\t\t evolution_of_loop);\n+\t      if (res)\n+\t\t*evolution_of_loop = add_to_evolution \n+\t\t  (loop->num, chrec_convert (type_rhs, *evolution_of_loop), \n+\t\t   MINUS_EXPR, rhs1);\n+\t    }\n+\t}\n+      \n+      else if (TREE_CODE (rhs1) == SSA_NAME)\n+\t{\n+\t  /* Match an assignment under the form: \n+\t     \"a = ... - c\".  */\n+\t  res = follow_ssa_edge \n+\t    (loop, SSA_NAME_DEF_STMT (rhs1), halting_phi, \n+\t     evolution_of_loop);\n+\t  if (res)\n+\t    *evolution_of_loop = add_to_evolution \n+\t      (loop->num, \n+\t       chrec_fold_multiply (type_rhs, \n+\t\t\t\t    *evolution_of_loop, \n+\t\t\t\t    fold_convert (type_rhs, integer_minus_one_node)),\n+\t       PLUS_EXPR, rhs0);\n+\t}\n+      \n+      else\n+\t/* Otherwise, match an assignment under the form: \n+\t   \"a = ... - ...\".  */\n+\t/* And there is nothing to do.  */\n+\tres = false;\n+      \n+      break;\n+    \n+    case MULT_EXPR:\n+      /* This case is under the form \"opnd0 = rhs0 * rhs1\".  */\n+      rhs0 = TREE_OPERAND (rhs, 0);\n+      rhs1 = TREE_OPERAND (rhs, 1);\n+      STRIP_TYPE_NOPS (rhs0);\n+      STRIP_TYPE_NOPS (rhs1);\n+\n+      if (TREE_CODE (rhs0) == SSA_NAME)\n+\t{\n+\t  if (TREE_CODE (rhs1) == SSA_NAME)\n+\t    {\n+\t      /* Match an assignment under the form: \n+\t\t \"a = b * c\".  */\n+\t      res = follow_ssa_edge \n+\t\t(loop, SSA_NAME_DEF_STMT (rhs0), halting_phi, \n+\t\t evolution_of_loop);\n+\t      \n+\t      if (res)\n+\t\t*evolution_of_loop = chrec_dont_know;\n+\t      \n+\t      else\n+\t\t{\n+\t\t  res = follow_ssa_edge \n+\t\t    (loop, SSA_NAME_DEF_STMT (rhs1), halting_phi, \n+\t\t     evolution_of_loop);\n+\t\t  \n+\t\t  if (res)\n+\t\t    *evolution_of_loop = chrec_dont_know;\n+\t\t}\n+\t    }\n+\t  \n+\t  else\n+\t    {\n+\t      /* Match an assignment under the form: \n+\t\t \"a = b * ...\".  */\n+\t      res = follow_ssa_edge \n+\t\t(loop, SSA_NAME_DEF_STMT (rhs0), halting_phi, \n+\t\t evolution_of_loop);\n+\t      if (res)\n+\t\t*evolution_of_loop = chrec_dont_know;\n+\t    }\n+\t}\n+      \n+      else if (TREE_CODE (rhs1) == SSA_NAME)\n+\t{\n+\t  /* Match an assignment under the form: \n+\t     \"a = ... * c\".  */\n+\t  res = follow_ssa_edge \n+\t    (loop, SSA_NAME_DEF_STMT (rhs1), halting_phi, \n+\t     evolution_of_loop);\n+\t  if (res)\n+\t    *evolution_of_loop = chrec_dont_know;\n+\t}\n+      \n+      else\n+\t/* Otherwise, match an assignment under the form: \n+\t   \"a = ... * ...\".  */\n+\t/* And there is nothing to do.  */\n+\tres = false;\n+      \n+      break;\n+\n+    default:\n+      res = false;\n+      break;\n+    }\n+  \n+  return res;\n+}\n+\n+/* Checks whether the I-th argument of a PHI comes from a backedge.  */\n+\n+static bool\n+backedge_phi_arg_p (tree phi, int i)\n+{\n+  edge e = PHI_ARG_EDGE (phi, i);\n+\n+  /* We would in fact like to test EDGE_DFS_BACK here, but we do not care\n+     about updating it anywhere, and this should work as well most of the\n+     time.  */\n+  if (e->flags & EDGE_IRREDUCIBLE_LOOP)\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Helper function for one branch of the condition-phi-node.  Return\n+   true if the strongly connected component has been found following\n+   this path.  */\n+\n+static inline bool\n+follow_ssa_edge_in_condition_phi_branch (int i,\n+\t\t\t\t\t struct loop *loop, \n+\t\t\t\t\t tree condition_phi, \n+\t\t\t\t\t tree halting_phi,\n+\t\t\t\t\t tree *evolution_of_branch,\n+\t\t\t\t\t tree init_cond)\n+{\n+  tree branch = PHI_ARG_DEF (condition_phi, i);\n+  *evolution_of_branch = chrec_dont_know;\n+\n+  /* Do not follow back edges (they must belong to an irreducible loop, which\n+     we really do not want to worry about).  */\n+  if (backedge_phi_arg_p (condition_phi, i))\n+    return false;\n+\n+  if (TREE_CODE (branch) == SSA_NAME)\n+    {\n+      *evolution_of_branch = init_cond;\n+      return follow_ssa_edge (loop, SSA_NAME_DEF_STMT (branch), halting_phi, \n+\t\t\t      evolution_of_branch);\n+    }\n+\n+  /* This case occurs when one of the condition branches sets \n+     the variable to a constant: ie. a phi-node like\n+     \"a_2 = PHI <a_7(5), 2(6)>;\".  \n+\t \n+     FIXME:  This case have to be refined correctly: \n+     in some cases it is possible to say something better than\n+     chrec_dont_know, for example using a wrap-around notation.  */\n+  return false;\n+}\n+\n+/* This function merges the branches of a condition-phi-node in a\n+   loop.  */\n+\n+static bool\n+follow_ssa_edge_in_condition_phi (struct loop *loop,\n+\t\t\t\t  tree condition_phi, \n+\t\t\t\t  tree halting_phi, \n+\t\t\t\t  tree *evolution_of_loop)\n+{\n+  int i;\n+  tree init = *evolution_of_loop;\n+  tree evolution_of_branch;\n+\n+  if (!follow_ssa_edge_in_condition_phi_branch (0, loop, condition_phi,\n+\t\t\t\t\t\thalting_phi,\n+\t\t\t\t\t\t&evolution_of_branch,\n+\t\t\t\t\t\tinit))\n+    return false;\n+  *evolution_of_loop = evolution_of_branch;\n+\n+  for (i = 1; i < PHI_NUM_ARGS (condition_phi); i++)\n+    {\n+      if (!follow_ssa_edge_in_condition_phi_branch (i, loop, condition_phi,\n+\t\t\t\t\t\t    halting_phi,\n+\t\t\t\t\t\t    &evolution_of_branch,\n+\t\t\t\t\t\t    init))\n+\treturn false;\n+\n+      *evolution_of_loop = chrec_merge (*evolution_of_loop,\n+\t\t\t\t\tevolution_of_branch);\n+    }\n+  \n+  return true;\n+}\n+\n+/* Follow an SSA edge in an inner loop.  It computes the overall\n+   effect of the loop, and following the symbolic initial conditions,\n+   it follows the edges in the parent loop.  The inner loop is\n+   considered as a single statement.  */\n+\n+static bool\n+follow_ssa_edge_inner_loop_phi (struct loop *outer_loop,\n+\t\t\t\ttree loop_phi_node, \n+\t\t\t\ttree halting_phi,\n+\t\t\t\ttree *evolution_of_loop)\n+{\n+  struct loop *loop = loop_containing_stmt (loop_phi_node);\n+  tree ev = analyze_scalar_evolution (loop, PHI_RESULT (loop_phi_node));\n+\n+  /* Sometimes, the inner loop is too difficult to analyze, and the\n+     result of the analysis is a symbolic parameter.  */\n+  if (ev == PHI_RESULT (loop_phi_node))\n+    {\n+      bool res = false;\n+      int i;\n+\n+      for (i = 0; i < PHI_NUM_ARGS (loop_phi_node); i++)\n+\t{\n+\t  tree arg = PHI_ARG_DEF (loop_phi_node, i);\n+\t  basic_block bb;\n+\n+\t  /* Follow the edges that exit the inner loop.  */\n+\t  bb = PHI_ARG_EDGE (loop_phi_node, i)->src;\n+\t  if (!flow_bb_inside_loop_p (loop, bb))\n+\t    res = res || follow_ssa_edge_in_rhs (outer_loop, arg, halting_phi,\n+\t\t\t\t\t\t evolution_of_loop);\n+\t}\n+\n+      /* If the path crosses this loop-phi, give up.  */\n+      if (res == true)\n+\t*evolution_of_loop = chrec_dont_know;\n+\n+      return res;\n+    }\n+\n+  /* Otherwise, compute the overall effect of the inner loop.  */\n+  ev = compute_overall_effect_of_inner_loop (loop, ev);\n+  return follow_ssa_edge_in_rhs (outer_loop, ev, halting_phi,\n+\t\t\t\t evolution_of_loop);\n+}\n+\n+/* Follow an SSA edge from a loop-phi-node to itself, constructing a\n+   path that is analyzed on the return walk.  */\n+\n+static bool\n+follow_ssa_edge (struct loop *loop, \n+\t\t tree def, \n+\t\t tree halting_phi,\n+\t\t tree *evolution_of_loop)\n+{\n+  struct loop *def_loop;\n+  \n+  if (TREE_CODE (def) == NOP_EXPR)\n+    return false;\n+  \n+  def_loop = loop_containing_stmt (def);\n+  \n+  switch (TREE_CODE (def))\n+    {\n+    case PHI_NODE:\n+      if (!loop_phi_node_p (def))\n+\t/* DEF is a condition-phi-node.  Follow the branches, and\n+\t   record their evolutions.  Finally, merge the collected\n+\t   information and set the approximation to the main\n+\t   variable.  */\n+\treturn follow_ssa_edge_in_condition_phi \n+\t  (loop, def, halting_phi, evolution_of_loop);\n+\n+      /* When the analyzed phi is the halting_phi, the\n+\t depth-first search is over: we have found a path from\n+\t the halting_phi to itself in the loop.  */\n+      if (def == halting_phi)\n+\treturn true;\n+\t  \n+      /* Otherwise, the evolution of the HALTING_PHI depends\n+\t on the evolution of another loop-phi-node, ie. the\n+\t evolution function is a higher degree polynomial.  */\n+      if (def_loop == loop)\n+\treturn false;\n+\t  \n+      /* Inner loop.  */\n+      if (flow_loop_nested_p (loop, def_loop))\n+\treturn follow_ssa_edge_inner_loop_phi \n+\t  (loop, def, halting_phi, evolution_of_loop);\n+\n+      /* Outer loop.  */\n+      return false;\n+\n+    case MODIFY_EXPR:\n+      return follow_ssa_edge_in_rhs (loop,\n+\t\t\t\t     TREE_OPERAND (def, 1), \n+\t\t\t\t     halting_phi, \n+\t\t\t\t     evolution_of_loop);\n+      \n+    default:\n+      /* At this level of abstraction, the program is just a set\n+\t of MODIFY_EXPRs and PHI_NODEs.  In principle there is no\n+\t other node to be handled.  */\n+      return false;\n+    }\n+}\n+\n+\f\n+\n+/* Given a LOOP_PHI_NODE, this function determines the evolution\n+   function from LOOP_PHI_NODE to LOOP_PHI_NODE in the loop.  */\n+\n+static tree\n+analyze_evolution_in_loop (tree loop_phi_node, \n+\t\t\t   tree init_cond)\n+{\n+  int i;\n+  tree evolution_function = chrec_not_analyzed_yet;\n+  struct loop *loop = loop_containing_stmt (loop_phi_node);\n+  basic_block bb;\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"(analyze_evolution_in_loop \\n\");\n+      fprintf (dump_file, \"  (loop_phi_node = \");\n+      print_generic_expr (dump_file, loop_phi_node, 0);\n+      fprintf (dump_file, \")\\n\");\n+    }\n+  \n+  for (i = 0; i < PHI_NUM_ARGS (loop_phi_node); i++)\n+    {\n+      tree arg = PHI_ARG_DEF (loop_phi_node, i);\n+      tree ssa_chain, ev_fn;\n+      bool res;\n+\n+      /* Select the edges that enter the loop body.  */\n+      bb = PHI_ARG_EDGE (loop_phi_node, i)->src;\n+      if (!flow_bb_inside_loop_p (loop, bb))\n+\tcontinue;\n+      \n+      if (TREE_CODE (arg) == SSA_NAME)\n+\t{\n+\t  ssa_chain = SSA_NAME_DEF_STMT (arg);\n+\n+\t  /* Pass in the initial condition to the follow edge function.  */\n+\t  ev_fn = init_cond;\n+\t  res = follow_ssa_edge (loop, ssa_chain, loop_phi_node, &ev_fn);\n+\t}\n+      else\n+\tres = false;\n+\t      \n+      /* When it is impossible to go back on the same\n+\t loop_phi_node by following the ssa edges, the\n+\t evolution is represented by a peeled chrec, ie. the\n+\t first iteration, EV_FN has the value INIT_COND, then\n+\t all the other iterations it has the value of ARG.  \n+\t For the moment, PEELED_CHREC nodes are not built.  */\n+      if (!res)\n+\tev_fn = chrec_dont_know;\n+      \n+      /* When there are multiple back edges of the loop (which in fact never\n+\t happens currently, but nevertheless), merge their evolutions. */\n+      evolution_function = chrec_merge (evolution_function, ev_fn);\n+    }\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"  (evolution_function = \");\n+      print_generic_expr (dump_file, evolution_function, 0);\n+      fprintf (dump_file, \"))\\n\");\n+    }\n+  \n+  return evolution_function;\n+}\n+\n+/* Given a loop-phi-node, return the initial conditions of the\n+   variable on entry of the loop.  When the CCP has propagated\n+   constants into the loop-phi-node, the initial condition is\n+   instantiated, otherwise the initial condition is kept symbolic.\n+   This analyzer does not analyze the evolution outside the current\n+   loop, and leaves this task to the on-demand tree reconstructor.  */\n+\n+static tree \n+analyze_initial_condition (tree loop_phi_node)\n+{\n+  int i;\n+  tree init_cond = chrec_not_analyzed_yet;\n+  struct loop *loop = bb_for_stmt (loop_phi_node)->loop_father;\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"(analyze_initial_condition \\n\");\n+      fprintf (dump_file, \"  (loop_phi_node = \\n\");\n+      print_generic_expr (dump_file, loop_phi_node, 0);\n+      fprintf (dump_file, \")\\n\");\n+    }\n+  \n+  for (i = 0; i < PHI_NUM_ARGS (loop_phi_node); i++)\n+    {\n+      tree branch = PHI_ARG_DEF (loop_phi_node, i);\n+      basic_block bb = PHI_ARG_EDGE (loop_phi_node, i)->src;\n+      \n+      /* When the branch is oriented to the loop's body, it does\n+     \t not contribute to the initial condition.  */\n+      if (flow_bb_inside_loop_p (loop, bb))\n+       \tcontinue;\n+\n+      if (init_cond == chrec_not_analyzed_yet)\n+\t{\n+\t  init_cond = branch;\n+\t  continue;\n+\t}\n+\n+      if (TREE_CODE (branch) == SSA_NAME)\n+\t{\n+\t  init_cond = chrec_dont_know;\n+      \t  break;\n+\t}\n+\n+      init_cond = chrec_merge (init_cond, branch);\n+    }\n+\n+  /* Ooops -- a loop without an entry???  */\n+  if (init_cond == chrec_not_analyzed_yet)\n+    init_cond = chrec_dont_know;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"  (init_cond = \");\n+      print_generic_expr (dump_file, init_cond, 0);\n+      fprintf (dump_file, \"))\\n\");\n+    }\n+  \n+  return init_cond;\n+}\n+\n+/* Analyze the scalar evolution for LOOP_PHI_NODE.  */\n+\n+static tree \n+interpret_loop_phi (struct loop *loop, tree loop_phi_node)\n+{\n+  tree res;\n+  struct loop *phi_loop = loop_containing_stmt (loop_phi_node);\n+  tree init_cond;\n+  \n+  if (phi_loop != loop)\n+    {\n+      struct loop *subloop;\n+      tree evolution_fn = analyze_scalar_evolution\n+\t(phi_loop, PHI_RESULT (loop_phi_node));\n+\n+      /* Dive one level deeper.  */\n+      subloop = superloop_at_depth (phi_loop, loop->depth + 1);\n+\n+      /* Interpret the subloop.  */\n+      res = compute_overall_effect_of_inner_loop (subloop, evolution_fn);\n+      return res;\n+    }\n+\n+  /* Otherwise really interpret the loop phi.  */\n+  init_cond = analyze_initial_condition (loop_phi_node);\n+  res = analyze_evolution_in_loop (loop_phi_node, init_cond);\n+\n+  return res;\n+}\n+\n+/* This function merges the branches of a condition-phi-node,\n+   contained in the outermost loop, and whose arguments are already\n+   analyzed.  */\n+\n+static tree\n+interpret_condition_phi (struct loop *loop, tree condition_phi)\n+{\n+  int i;\n+  tree res = chrec_not_analyzed_yet;\n+  \n+  for (i = 0; i < PHI_NUM_ARGS (condition_phi); i++)\n+    {\n+      tree branch_chrec;\n+      \n+      if (backedge_phi_arg_p (condition_phi, i))\n+\t{\n+\t  res = chrec_dont_know;\n+\t  break;\n+\t}\n+\n+      branch_chrec = analyze_scalar_evolution\n+\t(loop, PHI_ARG_DEF (condition_phi, i));\n+      \n+      res = chrec_merge (res, branch_chrec);\n+    }\n+\n+  return res;\n+}\n+\n+/* Interpret the right hand side of a modify_expr OPND1.  If we didn't\n+   analyzed this node before, follow the definitions until ending\n+   either on an analyzed modify_expr, or on a loop-phi-node.  On the\n+   return path, this function propagates evolutions (ala constant copy\n+   propagation).  OPND1 is not a GIMPLE expression because we could\n+   analyze the effect of an inner loop: see interpret_loop_phi.  */\n+\n+static tree\n+interpret_rhs_modify_expr (struct loop *loop,\n+\t\t\t   tree opnd1, tree type)\n+{\n+  tree res, opnd10, opnd11, chrec10, chrec11;\n+  \n+  if (is_gimple_min_invariant (opnd1))\n+    return chrec_convert (type, opnd1);\n+  \n+  switch (TREE_CODE (opnd1))\n+    {\n+    case PLUS_EXPR:\n+      opnd10 = TREE_OPERAND (opnd1, 0);\n+      opnd11 = TREE_OPERAND (opnd1, 1);\n+      chrec10 = analyze_scalar_evolution (loop, opnd10);\n+      chrec11 = analyze_scalar_evolution (loop, opnd11);\n+      chrec10 = chrec_convert (type, chrec10);\n+      chrec11 = chrec_convert (type, chrec11);\n+      res = chrec_fold_plus (type, chrec10, chrec11);\n+      break;\n+      \n+    case MINUS_EXPR:\n+      opnd10 = TREE_OPERAND (opnd1, 0);\n+      opnd11 = TREE_OPERAND (opnd1, 1);\n+      chrec10 = analyze_scalar_evolution (loop, opnd10);\n+      chrec11 = analyze_scalar_evolution (loop, opnd11);\n+      chrec10 = chrec_convert (type, chrec10);\n+      chrec11 = chrec_convert (type, chrec11);\n+      res = chrec_fold_minus (type, chrec10, chrec11);\n+      break;\n+\n+    case NEGATE_EXPR:\n+      opnd10 = TREE_OPERAND (opnd1, 0);\n+      chrec10 = analyze_scalar_evolution (loop, opnd10);\n+      chrec10 = chrec_convert (type, chrec10);\n+      res = chrec_fold_minus (type, fold_convert (type, integer_zero_node), \n+\t\t\t      chrec10);\n+      break;\n+\n+    case MULT_EXPR:\n+      opnd10 = TREE_OPERAND (opnd1, 0);\n+      opnd11 = TREE_OPERAND (opnd1, 1);\n+      chrec10 = analyze_scalar_evolution (loop, opnd10);\n+      chrec11 = analyze_scalar_evolution (loop, opnd11);\n+      chrec10 = chrec_convert (type, chrec10);\n+      chrec11 = chrec_convert (type, chrec11);\n+      res = chrec_fold_multiply (type, chrec10, chrec11);\n+      break;\n+      \n+    case SSA_NAME:\n+      res = chrec_convert (type, analyze_scalar_evolution (loop, opnd1));\n+      break;\n+      \n+    case NOP_EXPR:\n+    case CONVERT_EXPR:\n+      opnd10 = TREE_OPERAND (opnd1, 0);\n+      chrec10 = analyze_scalar_evolution (loop, opnd10);\n+      res = chrec_convert (type, chrec10);\n+      break;\n+      \n+    default:\n+      res = chrec_dont_know;\n+      break;\n+    }\n+  \n+  return res;\n+}\n+\n+\f\n+\n+/* This section contains all the entry points: \n+   - number_of_iterations_in_loop,\n+   - analyze_scalar_evolution,\n+   - instantiate_parameters.\n+*/\n+\n+/* Compute and return the evolution function in WRTO_LOOP, the nearest\n+   common ancestor of DEF_LOOP and USE_LOOP.  */\n+\n+static tree \n+compute_scalar_evolution_in_loop (struct loop *wrto_loop, \n+\t\t\t\t  struct loop *def_loop, \n+\t\t\t\t  tree ev)\n+{\n+  tree res;\n+  if (def_loop == wrto_loop)\n+    return ev;\n+\n+  def_loop = superloop_at_depth (def_loop, wrto_loop->depth + 1);\n+  res = compute_overall_effect_of_inner_loop (def_loop, ev);\n+\n+  return analyze_scalar_evolution_1 (wrto_loop, res, chrec_not_analyzed_yet);\n+}\n+\n+/* Helper recursive function.  */\n+\n+static tree\n+analyze_scalar_evolution_1 (struct loop *loop, tree var, tree res)\n+{\n+  tree def, type = TREE_TYPE (var);\n+  basic_block bb;\n+  struct loop *def_loop;\n+\n+  if (loop == NULL)\n+    return chrec_dont_know;\n+\n+  if (TREE_CODE (var) != SSA_NAME)\n+    return interpret_rhs_modify_expr (loop, var, type);\n+\n+  def = SSA_NAME_DEF_STMT (var);\n+  bb = bb_for_stmt (def);\n+  def_loop = bb ? bb->loop_father : NULL;\n+\n+  if (bb == NULL\n+      || !flow_bb_inside_loop_p (loop, bb))\n+    {\n+      /* Keep the symbolic form.  */\n+      res = var;\n+      goto set_and_end;\n+    }\n+\n+  if (res != chrec_not_analyzed_yet)\n+    {\n+      if (loop != bb->loop_father)\n+\tres = compute_scalar_evolution_in_loop \n+\t    (find_common_loop (loop, bb->loop_father), bb->loop_father, res);\n+\n+      goto set_and_end;\n+    }\n+\n+  if (loop != def_loop)\n+    {\n+      res = analyze_scalar_evolution_1 (def_loop, var, chrec_not_analyzed_yet);\n+      res = compute_scalar_evolution_in_loop (loop, def_loop, res);\n+\n+      goto set_and_end;\n+    }\n+\n+  switch (TREE_CODE (def))\n+    {\n+    case MODIFY_EXPR:\n+      res = interpret_rhs_modify_expr (loop, TREE_OPERAND (def, 1), type);\n+      break;\n+\n+    case PHI_NODE:\n+      if (loop_phi_node_p (def))\n+\tres = interpret_loop_phi (loop, def);\n+      else\n+\tres = interpret_condition_phi (loop, def);\n+      break;\n+\n+    default:\n+      res = chrec_dont_know;\n+      break;\n+    }\n+\n+ set_and_end:\n+\n+  /* Keep the symbolic form.  */\n+  if (res == chrec_dont_know)\n+    res = var;\n+\n+  if (loop == def_loop)\n+    set_scalar_evolution (var, res);\n+\n+  return res;\n+}\n+\n+/* Entry point for the scalar evolution analyzer.\n+   Analyzes and returns the scalar evolution of the ssa_name VAR.\n+   LOOP_NB is the identifier number of the loop in which the variable\n+   is used.\n+   \n+   Example of use: having a pointer VAR to a SSA_NAME node, STMT a\n+   pointer to the statement that uses this variable, in order to\n+   determine the evolution function of the variable, use the following\n+   calls:\n+   \n+   unsigned loop_nb = loop_containing_stmt (stmt)->num;\n+   tree chrec_with_symbols = analyze_scalar_evolution (loop_nb, var);\n+   tree chrec_instantiated = instantiate_parameters \n+   (loop_nb, chrec_with_symbols);\n+*/\n+\n+tree \n+analyze_scalar_evolution (struct loop *loop, tree var)\n+{\n+  tree res;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"(analyze_scalar_evolution \\n\");\n+      fprintf (dump_file, \"  (loop_nb = %d)\\n\", loop->num);\n+      fprintf (dump_file, \"  (scalar = \");\n+      print_generic_expr (dump_file, var, 0);\n+      fprintf (dump_file, \")\\n\");\n+    }\n+\n+  res = analyze_scalar_evolution_1 (loop, var, get_scalar_evolution (var));\n+\n+  if (TREE_CODE (var) == SSA_NAME && res == chrec_dont_know)\n+    res = var;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \")\\n\");\n+\n+  return res;\n+}\n+\n+/* Analyze scalar evolution of use of VERSION in USE_LOOP with respect to\n+   WRTO_LOOP (which should be a superloop of both USE_LOOP and definition\n+   of VERSION).  */\n+\n+static tree\n+analyze_scalar_evolution_in_loop (struct loop *wrto_loop, struct loop *use_loop,\n+\t\t\t\t  tree version)\n+{\n+  bool val = false;\n+  tree ev = version;\n+\n+  while (1)\n+    {\n+      ev = analyze_scalar_evolution (use_loop, ev);\n+      ev = resolve_mixers (use_loop, ev);\n+\n+      if (use_loop == wrto_loop)\n+\treturn ev;\n+\n+      /* If the value of the use changes in the inner loop, we cannot express\n+\t its value in the outer loop (we might try to return interval chrec,\n+\t but we do not have a user for it anyway)  */\n+      if (!no_evolution_in_loop_p (ev, use_loop->num, &val)\n+\t  || !val)\n+\treturn chrec_dont_know;\n+\n+      use_loop = use_loop->outer;\n+    }\n+}\n+\n+/* Analyze all the parameters of the chrec that were left under a symbolic form,\n+   with respect to LOOP.  CHREC is the chrec to instantiate.  If\n+   ALLOW_SUPERLOOP_CHRECS is true, replacing loop invariants with\n+   outer loop chrecs is done.  */\n+\n+static tree\n+instantiate_parameters_1 (struct loop *loop, tree chrec,\n+\t\t\t  bool allow_superloop_chrecs)\n+{\n+  tree res, op0, op1, op2;\n+  basic_block def_bb;\n+  struct loop *def_loop;\n+  \n+  if (chrec == NULL_TREE\n+      || automatically_generated_chrec_p (chrec))\n+    return chrec;\n+ \n+  if (is_gimple_min_invariant (chrec))\n+    return chrec;\n+\n+  switch (TREE_CODE (chrec))\n+    {\n+    case SSA_NAME:\n+      def_bb = bb_for_stmt (SSA_NAME_DEF_STMT (chrec));\n+\n+      /* A parameter (or loop invariant and we do not want to include\n+\t evolutions in outer loops), nothing to do.  */\n+      if (!def_bb\n+\t  || (!allow_superloop_chrecs\n+\t      && !flow_bb_inside_loop_p (loop, def_bb)))\n+\treturn chrec;\n+\n+      /* Don't instantiate the SSA_NAME if it is in a mixer\n+\t structure.  This is used for avoiding the instantiation of\n+\t recursively defined functions, such as: \n+\n+\t | a_2 -> {0, +, 1, +, a_2}_1  */\n+\t   \n+      if (bitmap_bit_p (already_instantiated, SSA_NAME_VERSION (chrec)))\n+\t{\n+\t  if (!flow_bb_inside_loop_p (loop, def_bb))\n+\t    {\n+\t      /* We may keep the loop invariant in symbolic form.  */\n+\t      return chrec;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Something with unknown behavior in LOOP.  */\n+\t      return chrec_dont_know;\n+\t    }\n+\t}\n+\n+      def_loop = find_common_loop (loop, def_bb->loop_father);\n+\n+      /* If the analysis yields a parametric chrec, instantiate the\n+\t result again.  Avoid the cyclic instantiation in mixers.  */\n+      bitmap_set_bit (already_instantiated, SSA_NAME_VERSION (chrec));\n+      res = analyze_scalar_evolution (def_loop, chrec);\n+      res = instantiate_parameters_1 (loop, res, allow_superloop_chrecs);\n+      bitmap_clear_bit (already_instantiated, SSA_NAME_VERSION (chrec));\n+      return res;\n+\n+    case POLYNOMIAL_CHREC:\n+      op0 = instantiate_parameters_1 (loop, CHREC_LEFT (chrec),\n+\t\t\t\t      allow_superloop_chrecs);\n+      op1 = instantiate_parameters_1 (loop, CHREC_RIGHT (chrec),\n+\t\t\t\t      allow_superloop_chrecs);\n+      return build_polynomial_chrec (CHREC_VARIABLE (chrec), op0, op1);\n+\n+    case PLUS_EXPR:\n+      op0 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 0),\n+\t\t\t\t      allow_superloop_chrecs);\n+      op1 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 1),\n+\t\t\t\t      allow_superloop_chrecs);\n+      return chrec_fold_plus (TREE_TYPE (chrec), op0, op1);\n+\n+    case MINUS_EXPR:\n+      op0 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 0),\n+\t\t\t\t      allow_superloop_chrecs);\n+      op1 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 1),\n+\t\t\t\t      allow_superloop_chrecs);\n+      return chrec_fold_minus (TREE_TYPE (chrec), op0, op1);\n+\n+    case MULT_EXPR:\n+      op0 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 0),\n+\t\t\t\t      allow_superloop_chrecs);\n+      op1 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 1),\n+\t\t\t\t      allow_superloop_chrecs);\n+      return chrec_fold_multiply (TREE_TYPE (chrec), op0, op1);\n+\n+    case NOP_EXPR:\n+    case CONVERT_EXPR:\n+    case NON_LVALUE_EXPR:\n+      op0 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 0),\n+\t\t\t\t      allow_superloop_chrecs);\n+      if (op0 == chrec_dont_know)\n+        return chrec_dont_know;\n+\n+      return chrec_convert (TREE_TYPE (chrec), op0);\n+\n+    case SCEV_NOT_KNOWN:\n+      return chrec_dont_know;\n+\n+    case SCEV_KNOWN:\n+      return chrec_known;\n+                                     \n+    default:\n+      break;\n+    }\n+\n+  switch (TREE_CODE_LENGTH (TREE_CODE (chrec)))\n+    {\n+    case 3:\n+      op0 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 0),\n+\t\t\t\t      allow_superloop_chrecs);\n+      op1 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 1),\n+\t\t\t\t      allow_superloop_chrecs);\n+      op2 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 2),\n+\t\t\t\t      allow_superloop_chrecs);\n+      if (op0 == chrec_dont_know\n+\t  || op1 == chrec_dont_know\n+\t  || op2 == chrec_dont_know)\n+        return chrec_dont_know;\n+      return fold (build (TREE_CODE (chrec),\n+\t\t\t  TREE_TYPE (chrec), op0, op1, op2));\n+\n+    case 2:\n+      op0 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 0),\n+\t\t\t\t      allow_superloop_chrecs);\n+      op1 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 1),\n+\t\t\t\t      allow_superloop_chrecs);\n+      if (op0 == chrec_dont_know\n+\t  || op1 == chrec_dont_know)\n+        return chrec_dont_know;\n+      return fold (build (TREE_CODE (chrec), TREE_TYPE (chrec), op0, op1));\n+\t    \n+    case 1:\n+      op0 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 0),\n+\t\t\t\t      allow_superloop_chrecs);\n+      if (op0 == chrec_dont_know)\n+        return chrec_dont_know;\n+      return fold (build1 (TREE_CODE (chrec), TREE_TYPE (chrec), op0));\n+\n+    case 0:\n+      return chrec;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Too complicated to handle.  */\n+  return chrec_dont_know;\n+}\n \n /* Analyze all the parameters of the chrec that were left under a\n    symbolic form.  LOOP is the loop in which symbolic names have to\n    be analyzed and instantiated.  */\n \n tree\n-instantiate_parameters (struct loop *loop ATTRIBUTE_UNUSED,\n+instantiate_parameters (struct loop *loop,\n \t\t\ttree chrec)\n {\n-  /* Just a dummy definition for now.  */\n-  return chrec;\n+  tree res;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"(instantiate_parameters \\n\");\n+      fprintf (dump_file, \"  (loop_nb = %d)\\n\", loop->num);\n+      fprintf (dump_file, \"  (chrec = \");\n+      print_generic_expr (dump_file, chrec, 0);\n+      fprintf (dump_file, \")\\n\");\n+    }\n+ \n+  res = instantiate_parameters_1 (loop, chrec, true);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"  (res = \");\n+      print_generic_expr (dump_file, res, 0);\n+      fprintf (dump_file, \"))\\n\");\n+    }\n+  \n+  return res;\n+}\n+\n+/* Similar to instantiate_parameters, but does not introduce the\n+   evolutions in outer loops for LOOP invariants in CHREC.  */\n+\n+static tree\n+resolve_mixers (struct loop *loop, tree chrec)\n+{\n+  return instantiate_parameters_1 (loop, chrec, false);\n+}\n+\n+/* Entry point for the analysis of the number of iterations pass.  \n+   This function tries to safely approximate the number of iterations\n+   the loop will run.  When this property is not decidable at compile\n+   time, the result is chrec_dont_know.  Otherwise the result is\n+   a scalar or a symbolic parameter.\n+   \n+   Example of analysis: suppose that the loop has an exit condition:\n+   \n+   \"if (b > 49) goto end_loop;\"\n+   \n+   and that in a previous analysis we have determined that the\n+   variable 'b' has an evolution function:\n+   \n+   \"EF = {23, +, 5}_2\".  \n+   \n+   When we evaluate the function at the point 5, i.e. the value of the\n+   variable 'b' after 5 iterations in the loop, we have EF (5) = 48,\n+   and EF (6) = 53.  In this case the value of 'b' on exit is '53' and\n+   the loop body has been executed 6 times.  */\n+\n+tree \n+number_of_iterations_in_loop (struct loop *loop)\n+{\n+  tree res, type;\n+  edge exit;\n+  struct tree_niter_desc niter_desc;\n+\n+  /* Determine whether the number_of_iterations_in_loop has already\n+     been computed.  */\n+  res = loop->nb_iterations;\n+  if (res)\n+    return res;\n+  res = chrec_dont_know;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"(number_of_iterations_in_loop\\n\");\n+  \n+  if (!loop->exit_edges)\n+    goto end;\n+  exit = loop->exit_edges[0];\n+\n+  if (!number_of_iterations_exit (loop, exit, &niter_desc))\n+    goto end;\n+\n+  type = TREE_TYPE (niter_desc.niter);\n+  if (integer_nonzerop (niter_desc.may_be_zero))\n+    res = fold_convert (type, integer_zero_node);\n+  else if (integer_zerop (niter_desc.may_be_zero))\n+    res = niter_desc.niter;\n+  else\n+    res = chrec_dont_know;\n+\n+end:\n+  return set_nb_iterations_in_loop (loop, res);\n+}\n+\n+/* One of the drivers for testing the scalar evolutions analysis.\n+   This function computes the number of iterations for all the loops\n+   from the EXIT_CONDITIONS array.  */\n+\n+static void \n+number_of_iterations_for_all_loops (varray_type exit_conditions)\n+{\n+  unsigned int i;\n+  unsigned nb_chrec_dont_know_loops = 0;\n+  unsigned nb_static_loops = 0;\n+  \n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (exit_conditions); i++)\n+    {\n+      tree res = number_of_iterations_in_loop \n+\t(loop_containing_stmt (VARRAY_TREE (exit_conditions, i)));\n+      if (chrec_contains_undetermined (res))\n+\tnb_chrec_dont_know_loops++;\n+      else\n+\tnb_static_loops++;\n+    }\n+  \n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\n(\\n\");\n+      fprintf (dump_file, \"-----------------------------------------\\n\");\n+      fprintf (dump_file, \"%d\\tnb_chrec_dont_know_loops\\n\", nb_chrec_dont_know_loops);\n+      fprintf (dump_file, \"%d\\tnb_static_loops\\n\", nb_static_loops);\n+      fprintf (dump_file, \"%d\\tnb_total_loops\\n\", current_loops->num);\n+      fprintf (dump_file, \"-----------------------------------------\\n\");\n+      fprintf (dump_file, \")\\n\\n\");\n+      \n+      print_loop_ir (dump_file);\n+    }\n+}\n+\n+\f\n+\n+/* Counters for the stats.  */\n+\n+struct chrec_stats \n+{\n+  unsigned nb_chrecs;\n+  unsigned nb_affine;\n+  unsigned nb_affine_multivar;\n+  unsigned nb_higher_poly;\n+  unsigned nb_chrec_dont_know;\n+  unsigned nb_undetermined;\n+};\n+\n+/* Reset the counters.  */\n+\n+static inline void\n+reset_chrecs_counters (struct chrec_stats *stats)\n+{\n+  stats->nb_chrecs = 0;\n+  stats->nb_affine = 0;\n+  stats->nb_affine_multivar = 0;\n+  stats->nb_higher_poly = 0;\n+  stats->nb_chrec_dont_know = 0;\n+  stats->nb_undetermined = 0;\n+}\n+\n+/* Dump the contents of a CHREC_STATS structure.  */\n+\n+static void\n+dump_chrecs_stats (FILE *file, struct chrec_stats *stats)\n+{\n+  fprintf (file, \"\\n(\\n\");\n+  fprintf (file, \"-----------------------------------------\\n\");\n+  fprintf (file, \"%d\\taffine univariate chrecs\\n\", stats->nb_affine);\n+  fprintf (file, \"%d\\taffine multivariate chrecs\\n\", stats->nb_affine_multivar);\n+  fprintf (file, \"%d\\tdegree greater than 2 polynomials\\n\", \n+\t   stats->nb_higher_poly);\n+  fprintf (file, \"%d\\tchrec_dont_know chrecs\\n\", stats->nb_chrec_dont_know);\n+  fprintf (file, \"-----------------------------------------\\n\");\n+  fprintf (file, \"%d\\ttotal chrecs\\n\", stats->nb_chrecs);\n+  fprintf (file, \"%d\\twith undetermined coefficients\\n\", \n+\t   stats->nb_undetermined);\n+  fprintf (file, \"-----------------------------------------\\n\");\n+  fprintf (file, \"%d\\tchrecs in the scev database\\n\", \n+\t   (int) htab_elements (scalar_evolution_info));\n+  fprintf (file, \"%d\\tsets in the scev database\\n\", nb_set_scev);\n+  fprintf (file, \"%d\\tgets in the scev database\\n\", nb_get_scev);\n+  fprintf (file, \"-----------------------------------------\\n\");\n+  fprintf (file, \")\\n\\n\");\n+}\n+\n+/* Gather statistics about CHREC.  */\n+\n+static void\n+gather_chrec_stats (tree chrec, struct chrec_stats *stats)\n+{\n+  if (dump_file && (dump_flags & TDF_STATS))\n+    {\n+      fprintf (dump_file, \"(classify_chrec \");\n+      print_generic_expr (dump_file, chrec, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  \n+  stats->nb_chrecs++;\n+  \n+  if (chrec == NULL_TREE)\n+    {\n+      stats->nb_undetermined++;\n+      return;\n+    }\n+  \n+  switch (TREE_CODE (chrec))\n+    {\n+    case POLYNOMIAL_CHREC:\n+      if (evolution_function_is_affine_p (chrec))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_STATS))\n+\t    fprintf (dump_file, \"  affine_univariate\\n\");\n+\t  stats->nb_affine++;\n+\t}\n+      else if (evolution_function_is_affine_multivariate_p (chrec))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_STATS))\n+\t    fprintf (dump_file, \"  affine_multivariate\\n\");\n+\t  stats->nb_affine_multivar++;\n+\t}\n+      else\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_STATS))\n+\t    fprintf (dump_file, \"  higher_degree_polynomial\\n\");\n+\t  stats->nb_higher_poly++;\n+\t}\n+      \n+      break;\n+\n+    default:\n+      break;\n+    }\n+  \n+  if (chrec_contains_undetermined (chrec))\n+    {\n+      if (dump_file && (dump_flags & TDF_STATS))\n+\tfprintf (dump_file, \"  undetermined\\n\");\n+      stats->nb_undetermined++;\n+    }\n+  \n+  if (dump_file && (dump_flags & TDF_STATS))\n+    fprintf (dump_file, \")\\n\");\n+}\n+\n+/* One of the drivers for testing the scalar evolutions analysis.\n+   This function analyzes the scalar evolution of all the scalars\n+   defined as loop phi nodes in one of the loops from the\n+   EXIT_CONDITIONS array.  \n+   \n+   TODO Optimization: A loop is in canonical form if it contains only\n+   a single scalar loop phi node.  All the other scalars that have an\n+   evolution in the loop are rewritten in function of this single\n+   index.  This allows the parallelization of the loop.  */\n+\n+static void \n+analyze_scalar_evolution_for_all_loop_phi_nodes (varray_type exit_conditions)\n+{\n+  unsigned int i;\n+  struct chrec_stats stats;\n+  \n+  reset_chrecs_counters (&stats);\n+  \n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (exit_conditions); i++)\n+    {\n+      struct loop *loop;\n+      basic_block bb;\n+      tree phi, chrec;\n+      \n+      loop = loop_containing_stmt (VARRAY_TREE (exit_conditions, i));\n+      bb = loop->header;\n+      \n+      for (phi = phi_nodes (bb); phi; phi = TREE_CHAIN (phi))\n+\tif (is_gimple_reg (PHI_RESULT (phi)))\n+\t  {\n+\t    chrec = instantiate_parameters \n+\t      (loop, \n+\t       analyze_scalar_evolution (loop, PHI_RESULT (phi)));\n+\t    \n+\t    if (dump_file && (dump_flags & TDF_STATS))\n+\t      gather_chrec_stats (chrec, &stats);\n+\t  }\n+    }\n+  \n+  if (dump_file && (dump_flags & TDF_STATS))\n+    dump_chrecs_stats (dump_file, &stats);\n+}\n+\n+/* Callback for htab_traverse, gathers information on chrecs in the\n+   hashtable.  */\n+\n+static int\n+gather_stats_on_scev_database_1 (void **slot, void *stats)\n+{\n+  struct scev_info_str *entry = *slot;\n+\n+  gather_chrec_stats (entry->chrec, stats);\n+\n+  return 1;\n+}\n+\n+/* Classify the chrecs of the whole database.  */\n+\n+void \n+gather_stats_on_scev_database (void)\n+{\n+  struct chrec_stats stats;\n+  \n+  if (!dump_file)\n+    return;\n+  \n+  reset_chrecs_counters (&stats);\n+ \n+  htab_traverse (scalar_evolution_info, gather_stats_on_scev_database_1,\n+\t\t &stats);\n+\n+  dump_chrecs_stats (dump_file, &stats);\n+}\n+\n+\f\n+\n+/* Initializer.  */\n+\n+static void\n+initialize_scalar_evolutions_analyzer (void)\n+{\n+  /* The elements below are unique.  */\n+  if (chrec_dont_know == NULL_TREE)\n+    {\n+      chrec_not_analyzed_yet = NULL_TREE;\n+      chrec_dont_know = make_node (SCEV_NOT_KNOWN);\n+      chrec_known = make_node (SCEV_KNOWN);\n+      TREE_TYPE (chrec_dont_know) = NULL_TREE;\n+      TREE_TYPE (chrec_known) = NULL_TREE;\n+    }\n+}\n+\n+/* Initialize the analysis of scalar evolutions for LOOPS.  */\n+\n+void\n+scev_initialize (struct loops *loops)\n+{\n+  unsigned i;\n+  current_loops = loops;\n+\n+  scalar_evolution_info = htab_create (100, hash_scev_info,\n+\t\t\t\t       eq_scev_info, del_scev_info);\n+  already_instantiated = BITMAP_XMALLOC ();\n+  \n+  initialize_scalar_evolutions_analyzer ();\n+\n+  for (i = 1; i < loops->num; i++)\n+    if (loops->parray[i])\n+      {\n+\tflow_loop_scan (loops->parray[i], LOOP_EXIT_EDGES);\n+\tloops->parray[i]->nb_iterations = NULL_TREE;\n+      }\n+}\n+\n+/* Cleans up the information cached by the scalar evolutions analysis.  */\n+\n+void\n+scev_reset (void)\n+{\n+  unsigned i;\n+  struct loop *loop;\n+\n+  if (!scalar_evolution_info || !current_loops)\n+    return;\n+\n+  htab_empty (scalar_evolution_info);\n+  for (i = 1; i < current_loops->num; i++)\n+    {\n+      loop = current_loops->parray[i];\n+      if (loop)\n+\tloop->nb_iterations = NULL_TREE;\n+    }\n }\n \n /* Checks whether OP behaves as a simple affine iv of LOOP in STMT and returns\n    its BASE and STEP if possible.  */\n \n bool\n-simple_iv (struct loop *loop ATTRIBUTE_UNUSED, tree stmt ATTRIBUTE_UNUSED,\n-\t   tree op ATTRIBUTE_UNUSED, tree *base ATTRIBUTE_UNUSED,\n-\t   tree *step ATTRIBUTE_UNUSED)\n+simple_iv (struct loop *loop, tree stmt, tree op, tree *base, tree *step)\n {\n-  /* Just a dummy definition for now.  */\n-  return false;\n+  basic_block bb = bb_for_stmt (stmt);\n+  tree type, ev;\n+\n+  *base = NULL_TREE;\n+  *step = NULL_TREE;\n+\n+  type = TREE_TYPE (op);\n+  if (TREE_CODE (type) != INTEGER_TYPE\n+      && TREE_CODE (type) != POINTER_TYPE)\n+    return false;\n+\n+  ev = analyze_scalar_evolution_in_loop (loop, bb->loop_father, op);\n+  if (chrec_contains_undetermined (ev))\n+    return false;\n+\n+  if (tree_does_not_contain_chrecs (ev)\n+      && !chrec_contains_symbols_defined_in_loop (ev, loop->num))\n+    {\n+      *base = ev;\n+      return true;\n+    }\n+\n+  if (TREE_CODE (ev) != POLYNOMIAL_CHREC\n+      || CHREC_VARIABLE (ev) != (unsigned) loop->num)\n+    return false;\n+\n+  *step = CHREC_RIGHT (ev);\n+  if (TREE_CODE (*step) != INTEGER_CST)\n+    return false;\n+  *base = CHREC_LEFT (ev);\n+  if (tree_contains_chrecs (*base)\n+      || chrec_contains_symbols_defined_in_loop (*base, loop->num))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Runs the analysis of scalar evolutions.  */\n+\n+void\n+scev_analysis (void)\n+{\n+  varray_type exit_conditions;\n+  \n+  VARRAY_GENERIC_PTR_INIT (exit_conditions, 37, \"exit_conditions\");\n+  select_loops_exit_conditions (current_loops, &exit_conditions);\n+\n+  if (dump_file && (dump_flags & TDF_STATS))\n+    analyze_scalar_evolution_for_all_loop_phi_nodes (exit_conditions);\n+  \n+  number_of_iterations_for_all_loops (exit_conditions);\n+  VARRAY_CLEAR (exit_conditions);\n }\n+\n+/* Finalize the scalar evolution analysis.  */\n+\n+void\n+scev_finalize (void)\n+{\n+  htab_delete (scalar_evolution_info);\n+  BITMAP_XFREE (already_instantiated);\n+}\n+"}, {"sha": "e8d2eb453fbd9065d20e2f13b984fbab159df63e", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9baba81be56e46677dbe5c558368fd023d45c2a9/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9baba81be56e46677dbe5c558368fd023d45c2a9/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=9baba81be56e46677dbe5c558368fd023d45c2a9", "patch": "@@ -22,7 +22,17 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifndef GCC_TREE_SCALAR_EVOLUTION_H\n #define GCC_TREE_SCALAR_EVOLUTION_H\n \n+extern tree number_of_iterations_in_loop (struct loop *);\n+extern tree get_loop_exit_condition (struct loop *);\n+\n+extern void scev_initialize (struct loops *loops);\n+extern void scev_reset (void);\n+extern void scev_finalize (void);\n+extern tree analyze_scalar_evolution (struct loop *, tree);\n extern tree instantiate_parameters (struct loop *, tree);\n+extern void eliminate_redundant_checks (void);\n+extern void gather_stats_on_scev_database (void);\n+extern void scev_analysis (void);\n extern bool simple_iv (struct loop *, tree, tree, tree *, tree *);\n \n #endif  /* GCC_TREE_SCALAR_EVOLUTION_H  */"}]}