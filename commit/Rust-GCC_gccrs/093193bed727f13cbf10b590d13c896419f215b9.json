{"sha": "093193bed727f13cbf10b590d13c896419f215b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDkzMTkzYmVkNzI3ZjEzY2JmMTBiNTkwZDEzYzg5NjQxOWYyMTViOQ==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "maxim@codesourcery.com", "date": "2012-03-02T20:32:20Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2012-03-02T20:32:20Z"}, "message": "invoke.texi (floop-flatten): Declare obsolete.\n\n\tgcc/\n\t* doc/invoke.texi (floop-flatten): Declare obsolete.\n\t* toplev.c (process_options): Remove references to flag_loop_flatten.\n\t* tree-ssa-loop.c (gate_graphite_transform): Same.\n\t* common.opt (floop-flatten): Obsolete.\n\t* graphite-poly.c (apply_poly_transforms): Remove reference to\n\tflag_loop_flatten.\n\t* Makefile.in (graphite-flattening.o): Remove.\n\t* graphite-flattening.c: Remove.\n\n\tgcc/testsuite/\n\t* gcc.dg/graphite/pr50561.c: Update.\n\nFrom-SVN: r184820", "tree": {"sha": "ad317a1431c55993729264a04f7e4d8d57e5f951", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad317a1431c55993729264a04f7e4d8d57e5f951"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/093193bed727f13cbf10b590d13c896419f215b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/093193bed727f13cbf10b590d13c896419f215b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/093193bed727f13cbf10b590d13c896419f215b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/093193bed727f13cbf10b590d13c896419f215b9/comments", "author": null, "committer": null, "parents": [{"sha": "501699af1603287b1b47ac450fd6eeb826aa76b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/501699af1603287b1b47ac450fd6eeb826aa76b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/501699af1603287b1b47ac450fd6eeb826aa76b1"}], "stats": {"total": 506, "additions": 21, "deletions": 485}, "files": [{"sha": "e3038fb0701c729853fd25db2bccc0d4558c2cb4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093193bed727f13cbf10b590d13c896419f215b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093193bed727f13cbf10b590d13c896419f215b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=093193bed727f13cbf10b590d13c896419f215b9", "patch": "@@ -1,3 +1,14 @@\n+2012-03-02  Maxim Kuvyrkov  <maxim@codesourcery.com>\n+\n+\t* doc/invoke.texi (floop-flatten): Remove.\n+\t* toplev.c (process_options): Remove references to flag_loop_flatten.\n+\t* tree-ssa-loop.c (gate_graphite_transform): Same.\n+\t* common.opt (floop-flatten): Obsolete.\n+\t* graphite-poly.c (apply_poly_transforms): Remove reference to\n+\tflag_loop_flatten.\n+\t* Makefile.in (graphite-flattening.o): Remove.\n+\t* graphite-flattening.c: Remove.\n+\n 2012-03-02  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* compare-elim.c (find_comparisons_in_bb): Eliminate only compares"}, {"sha": "9a35295e626ffd6ecbd544633679fcec36b622f9", "filename": "gcc/Makefile.in", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093193bed727f13cbf10b590d13c896419f215b9/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093193bed727f13cbf10b590d13c896419f215b9/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=093193bed727f13cbf10b590d13c896419f215b9", "patch": "@@ -1241,7 +1241,6 @@ OBJS = \\\n \tgraphite-clast-to-gimple.o \\\n \tgraphite-cloog-util.o \\\n \tgraphite-dependences.o \\\n-\tgraphite-flattening.o \\\n \tgraphite-interchange.o \\\n \tgraphite-poly.o \\\n \tgraphite-ppl.o \\\n@@ -2619,9 +2618,6 @@ graphite-dependences.o : graphite-dependences.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) \\\n    sese.h graphite-ppl.h graphite-poly.h graphite-dependences.h \\\n    graphite-cloog-util.h\n-graphite-flattening.o : graphite-flattening.c $(CONFIG_H) $(SYSTEM_H)\t\\\n-   coretypes.h $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) \\\n-   sese.h graphite-ppl.h graphite-poly.h\n graphite-interchange.o : graphite-interchange.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) \\\n    sese.h graphite-ppl.h graphite-poly.h"}, {"sha": "98fa2bb6cca017b28a6e02611101fe74476e3ee1", "filename": "gcc/common.opt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093193bed727f13cbf10b590d13c896419f215b9/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093193bed727f13cbf10b590d13c896419f215b9/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=093193bed727f13cbf10b590d13c896419f215b9", "patch": "@@ -1198,8 +1198,8 @@ Common Report Var(flag_tm)\n Enable support for GNU transactional memory\n \n floop-flatten\n-Common Report Var(flag_loop_flatten) Optimization\n-Enable Loop Flattening transformation\n+Common Ignore\n+Does nothing. Preserved for backward compatibility.\n \n fstrict-volatile-bitfields\n Common Report Var(flag_strict_volatile_bitfields) Init(-1)"}, {"sha": "29630450f8d10f922f991a04604b86dedba5c24c", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093193bed727f13cbf10b590d13c896419f215b9/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093193bed727f13cbf10b590d13c896419f215b9/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=093193bed727f13cbf10b590d13c896419f215b9", "patch": "@@ -371,7 +371,7 @@ Objective-C and Objective-C++ Dialects}.\n -fira-loop-pressure -fno-ira-share-save-slots @gol\n -fno-ira-share-spill-slots -fira-verbose=@var{n} @gol\n -fivopts -fkeep-inline-functions -fkeep-static-consts @gol\n--floop-block -floop-flatten -floop-interchange -floop-strip-mine @gol\n+-floop-block -floop-interchange -floop-strip-mine @gol\n -floop-parallelize-all -flto -flto-compression-level @gol\n -flto-partition=@var{alg} -flto-report -fmerge-all-constants @gol\n -fmerge-constants -fmodulo-sched -fmodulo-sched-allow-regmoves @gol\n@@ -7287,16 +7287,6 @@ GIMPLE -> GRAPHITE -> GIMPLE transformation.  Some minimal optimizations\n are also performed by the code generator CLooG, like index splitting and\n dead code elimination in loops.\n \n-@item -floop-flatten\n-@opindex floop-flatten\n-Removes the loop nesting structure: transforms the loop nest into a\n-single loop.  This transformation can be useful as an enablement\n-transform for vectorization and parallelization.  This feature\n-is experimental.\n-To use this code transformation, GCC has to be configured\n-with @option{--with-ppl} and @option{--with-cloog} to enable the\n-Graphite loop transformation infrastructure.\n-\n @item -floop-parallelize-all\n @opindex floop-parallelize-all\n Use the Graphite data dependence analysis to identify loops that can"}, {"sha": "33f25e01b03f680493f0b396a81cc8e421598a8c", "filename": "gcc/graphite-flattening.c", "status": "removed", "additions": 0, "deletions": 460, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/501699af1603287b1b47ac450fd6eeb826aa76b1/gcc%2Fgraphite-flattening.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/501699af1603287b1b47ac450fd6eeb826aa76b1/gcc%2Fgraphite-flattening.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-flattening.c?ref=501699af1603287b1b47ac450fd6eeb826aa76b1", "patch": "@@ -1,460 +0,0 @@\n-/* Loop flattening for Graphite.\n-   Copyright (C) 2010 Free Software Foundation, Inc.\n-   Contributed by Sebastian Pop <sebastian.pop@amd.com>.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tree-flow.h\"\n-#include \"tree-dump.h\"\n-#include \"cfgloop.h\"\n-#include \"tree-chrec.h\"\n-#include \"tree-data-ref.h\"\n-#include \"tree-scalar-evolution.h\"\n-#include \"sese.h\"\n-\n-#ifdef HAVE_cloog\n-#include \"ppl_c.h\"\n-#include \"graphite-ppl.h\"\n-#include \"graphite-poly.h\"\n-\n-/* The loop flattening pass transforms loop nests into a single loop,\n-   removing the loop nesting structure.  The auto-vectorization can\n-   then apply on the full loop body, without needing the outer-loop\n-   vectorization.\n-\n-   The loop flattening pass that has been described in a very Fortran\n-   specific way in the 1992 paper by Reinhard von Hanxleden and Ken\n-   Kennedy: \"Relaxing SIMD Control Flow Constraints using Loop\n-   Transformations\" available from\n-   http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.54.5033\n-\n-   The canonical example is as follows: suppose that we have a loop\n-   nest with known iteration counts\n-\n-   | for (i = 1; i <= 6; i++)\n-   |   for (j = 1; j <= 6; j++)\n-   |     S1(i,j);\n-\n-   The loop flattening is performed by linearizing the iteration space\n-   using the function \"f (x) = 6 * i + j\".  In this case, CLooG would\n-   produce this code:\n-\n-   | for (c1=7;c1<=42;c1++) {\n-   |   i = floord(c1-1,6);\n-   |   S1(i,c1-6*i);\n-   | }\n-\n-   There are several limitations for loop flattening that are linked\n-   to the expressivity of the polyhedral model.  One has to take an\n-   upper bound approximation to deal with the parametric case of loop\n-   flattening.  For example, in the loop nest:\n-\n-   | for (i = 1; i <= N; i++)\n-   |   for (j = 1; j <= M; j++)\n-   |     S1(i,j);\n-\n-   One would like to flatten this loop using a linearization function\n-   like this \"f (x) = M * i + j\".  However CLooG's schedules are not\n-   expressive enough to deal with this case, and so the parameter M\n-   has to be replaced by an integer upper bound approximation.  If we\n-   further know in the context of the scop that \"M <= 6\", then it is\n-   possible to linearize the loop with \"f (x) = 6 * i + j\".  In this\n-   case, CLooG would produce this code:\n-\n-   | for (c1=7;c1<=6*M+N;c1++) {\n-   |   i = ceild(c1-N,6);\n-   |   if (i <= floord(c1-1,6)) {\n-   |     S1(i,c1-6*i);\n-   |   }\n-   | }\n-\n-   For an arbitrarily complex loop nest the algorithm proceeds in two\n-   steps.  First, the LST is flattened by removing the loops structure\n-   and by inserting the statements in the order they appear in\n-   depth-first order.  Then, the scattering of each statement is\n-   transformed accordingly.\n-\n-   Supposing that the original program is represented by the following\n-   LST:\n-\n-   | (loop_1\n-   |  stmt_1\n-   |  (loop_2 stmt_3\n-   |   (loop_3 stmt_4)\n-   |   (loop_4 stmt_5 stmt_6)\n-   |   stmt_7\n-   |  )\n-   |  stmt_2\n-   | )\n-\n-   Loop flattening traverses the LST in depth-first order, and\n-   flattens pairs of loops successively by projecting the inner loops\n-   in the iteration domain of the outer loops:\n-\n-   lst_project_loop (loop_2, loop_3, stride)\n-\n-   | (loop_1\n-   |  stmt_1\n-   |  (loop_2 stmt_3 stmt_4\n-   |   (loop_4 stmt_5 stmt_6)\n-   |   stmt_7\n-   |  )\n-   |  stmt_2\n-   | )\n-\n-   lst_project_loop (loop_2, loop_4, stride)\n-\n-   | (loop_1\n-   |  stmt_1\n-   |  (loop_2 stmt_3 stmt_4 stmt_5 stmt_6 stmt_7)\n-   |  stmt_2\n-   | )\n-\n-   lst_project_loop (loop_1, loop_2, stride)\n-\n-   | (loop_1\n-   |  stmt_1 stmt_3 stmt_4 stmt_5 stmt_6 stmt_7 stmt_2\n-   | )\n-\n-   At each step, the iteration domain of the outer loop is enlarged to\n-   contain enough points to iterate over the inner loop domain.  */\n-\n-/* Initializes RES to the number of iterations of the linearized loop\n-   LST.  RES is the cardinal of the iteration domain of LST.  */\n-\n-static void\n-lst_linearized_niter (lst_p lst, mpz_t res)\n-{\n-  int i;\n-  lst_p l;\n-  mpz_t n;\n-\n-  mpz_init (n);\n-  mpz_set_si (res, 0);\n-\n-  FOR_EACH_VEC_ELT (lst_p, LST_SEQ (lst), i, l)\n-    if (LST_LOOP_P (l))\n-      {\n-\tlst_linearized_niter (l, n);\n-\tmpz_add (res, res, n);\n-      }\n-\n-  if (LST_LOOP_P (lst))\n-    {\n-      lst_niter_for_loop (lst, n);\n-\n-      if (mpz_cmp_si (res, 0) != 0)\n-\tmpz_mul (res, res, n);\n-      else\n-\tmpz_set (res, n);\n-    }\n-\n-  mpz_clear (n);\n-}\n-\n-/* Applies the translation \"f (x) = x + OFFSET\" to the loop containing\n-   STMT.  */\n-\n-static void\n-lst_offset (lst_p stmt, mpz_t offset)\n-{\n-  lst_p inner = LST_LOOP_FATHER (stmt);\n-  poly_bb_p pbb = LST_PBB (stmt);\n-  ppl_Polyhedron_t poly = PBB_TRANSFORMED_SCATTERING (pbb);\n-  int inner_depth = lst_depth (inner);\n-  ppl_dimension_type inner_dim = psct_dynamic_dim (pbb, inner_depth);\n-  ppl_Linear_Expression_t expr;\n-  ppl_dimension_type dim;\n-  ppl_Coefficient_t one;\n-  mpz_t x;\n-\n-  mpz_init (x);\n-  mpz_set_si (x, 1);\n-  ppl_new_Coefficient (&one);\n-  ppl_assign_Coefficient_from_mpz_t (one, x);\n-\n-  ppl_Polyhedron_space_dimension (poly, &dim);\n-  ppl_new_Linear_Expression_with_dimension (&expr, dim);\n-\n-  ppl_set_coef (expr, inner_dim, 1);\n-  ppl_set_inhomogeneous_gmp (expr, offset);\n-  ppl_Polyhedron_affine_image (poly, inner_dim, expr, one);\n-  ppl_delete_Linear_Expression (expr);\n-  ppl_delete_Coefficient (one);\n-}\n-\n-/* Scale by FACTOR the loop LST containing STMT.  */\n-\n-static void\n-lst_scale (lst_p lst, lst_p stmt, mpz_t factor)\n-{\n-  mpz_t x;\n-  ppl_Coefficient_t one;\n-  int outer_depth = lst_depth (lst);\n-  poly_bb_p pbb = LST_PBB (stmt);\n-  ppl_Polyhedron_t poly = PBB_TRANSFORMED_SCATTERING (pbb);\n-  ppl_dimension_type outer_dim = psct_dynamic_dim (pbb, outer_depth);\n-  ppl_Linear_Expression_t expr;\n-  ppl_dimension_type dim;\n-\n-  mpz_init (x);\n-  mpz_set_si (x, 1);\n-  ppl_new_Coefficient (&one);\n-  ppl_assign_Coefficient_from_mpz_t (one, x);\n-\n-  ppl_Polyhedron_space_dimension (poly, &dim);\n-  ppl_new_Linear_Expression_with_dimension (&expr, dim);\n-\n-  /* outer_dim = factor * outer_dim.  */\n-  ppl_set_coef_gmp (expr, outer_dim, factor);\n-  ppl_Polyhedron_affine_image (poly, outer_dim, expr, one);\n-  ppl_delete_Linear_Expression (expr);\n-\n-  mpz_clear (x);\n-  ppl_delete_Coefficient (one);\n-}\n-\n-/* Project the INNER loop into the iteration domain of the OUTER loop.\n-   STRIDE is the number of iterations between two iterations of the\n-   outer loop.  */\n-\n-static void\n-lst_project_loop (lst_p outer, lst_p inner, mpz_t stride)\n-{\n-  int i;\n-  lst_p stmt;\n-  mpz_t x;\n-  ppl_Coefficient_t one;\n-  int outer_depth = lst_depth (outer);\n-  int inner_depth = lst_depth (inner);\n-\n-  mpz_init (x);\n-  mpz_set_si (x, 1);\n-  ppl_new_Coefficient (&one);\n-  ppl_assign_Coefficient_from_mpz_t (one, x);\n-\n-  FOR_EACH_VEC_ELT (lst_p, LST_SEQ (inner), i, stmt)\n-    {\n-      poly_bb_p pbb = LST_PBB (stmt);\n-      ppl_Polyhedron_t poly = PBB_TRANSFORMED_SCATTERING (pbb);\n-      ppl_dimension_type outer_dim = psct_dynamic_dim (pbb, outer_depth);\n-      ppl_dimension_type inner_dim = psct_dynamic_dim (pbb, inner_depth);\n-      ppl_Linear_Expression_t expr;\n-      ppl_dimension_type dim;\n-      ppl_dimension_type *ds;\n-\n-      /* There should be no loops under INNER.  */\n-      gcc_assert (!LST_LOOP_P (stmt));\n-      ppl_Polyhedron_space_dimension (poly, &dim);\n-      ppl_new_Linear_Expression_with_dimension (&expr, dim);\n-\n-      /* outer_dim = outer_dim * stride + inner_dim.  */\n-      ppl_set_coef (expr, inner_dim, 1);\n-      ppl_set_coef_gmp (expr, outer_dim, stride);\n-      ppl_Polyhedron_affine_image (poly, outer_dim, expr, one);\n-      ppl_delete_Linear_Expression (expr);\n-\n-      /* Project on inner_dim.  */\n-      ppl_new_Linear_Expression_with_dimension (&expr, dim - 1);\n-      ppl_Polyhedron_affine_image (poly, inner_dim, expr, one);\n-      ppl_delete_Linear_Expression (expr);\n-\n-      /* Remove inner loop and the static schedule of its body.  */\n-      /* FIXME: As long as we use PPL we are not able to remove the old\n-\t scattering dimensions.  The reason is that these dimensions are not\n-\t entirely unused.  They are not necessary as part of the scheduling\n-\t vector, as the earlier dimensions already unambiguously define the\n-\t execution time, however they may still be needed to carry modulo\n-\t constraints as introduced e.g. by strip mining.  The correct solution\n-\t would be to project these dimensions out of the scattering polyhedra.\n-\t In case they are still required to carry modulo constraints they should be kept\n-\t internally as existentially quantified dimensions.  PPL does only support\n-         projection of rational polyhedra, however in this case we need an integer\n-\t projection. With isl this will be trivial to implement.  For now we just\n-\t leave the dimensions. This is a little ugly, but should be correct.  */\n-      if (0) {\n-\tds = XNEWVEC (ppl_dimension_type, 2);\n-\tds[0] = inner_dim;\n-\tds[1] = inner_dim + 1;\n-\tppl_Polyhedron_remove_space_dimensions (poly, ds, 2);\n-\tPBB_NB_SCATTERING_TRANSFORM (pbb) -= 2;\n-\tfree (ds);\n-      }\n-    }\n-\n-  mpz_clear (x);\n-  ppl_delete_Coefficient (one);\n-}\n-\n-/* Flattens the loop nest LST.  Return true when something changed.\n-   OFFSET is used to compute the number of iterations of the outermost\n-   loop before the current LST is executed.  */\n-\n-static bool\n-lst_flatten_loop (lst_p lst, mpz_t init_offset)\n-{\n-  int i;\n-  lst_p l;\n-  bool res = false;\n-  mpz_t n, one, offset, stride;\n-\n-  mpz_init (n);\n-  mpz_init (one);\n-  mpz_init (offset);\n-  mpz_init (stride);\n-  mpz_set (offset, init_offset);\n-  mpz_set_si (one, 1);\n-\n-  lst_linearized_niter (lst, stride);\n-  lst_niter_for_loop (lst, n);\n-  mpz_tdiv_q (stride, stride, n);\n-\n-  FOR_EACH_VEC_ELT (lst_p, LST_SEQ (lst), i, l)\n-    if (LST_LOOP_P (l))\n-      {\n-\tres = true;\n-\n-\tlst_flatten_loop (l, offset);\n-\tlst_niter_for_loop (l, n);\n-\n-\tlst_project_loop (lst, l, stride);\n-\n-\t/* The offset is the number of iterations minus 1, as we want\n-\t   to execute the next statements at the same iteration as the\n-\t   last iteration of the loop.  */\n-\tmpz_sub (n, n, one);\n-\tmpz_add (offset, offset, n);\n-      }\n-    else\n-      {\n-\tlst_scale (lst, l, stride);\n-\tif (mpz_cmp_si (offset, 0) != 0)\n-\t  lst_offset (l, offset);\n-      }\n-\n-  FOR_EACH_VEC_ELT (lst_p, LST_SEQ (lst), i, l)\n-    if (LST_LOOP_P (l))\n-      lst_remove_loop_and_inline_stmts_in_loop_father (l);\n-\n-  mpz_clear (n);\n-  mpz_clear (one);\n-  mpz_clear (offset);\n-  mpz_clear (stride);\n-  return res;\n-}\n-\n-/* Remove all but the first 3 dimensions of the scattering:\n-   - dim0: the static schedule for the loop\n-   - dim1: the dynamic schedule of the loop\n-   - dim2: the static schedule for the loop body.  */\n-\n-static void\n-remove_unused_scattering_dimensions (lst_p lst)\n-{\n-  int i;\n-  lst_p stmt;\n-  mpz_t x;\n-  ppl_Coefficient_t one;\n-\n-  mpz_init (x);\n-  mpz_set_si (x, 1);\n-  ppl_new_Coefficient (&one);\n-  ppl_assign_Coefficient_from_mpz_t (one, x);\n-\n-  FOR_EACH_VEC_ELT (lst_p, LST_SEQ (lst), i, stmt)\n-    {\n-      poly_bb_p pbb = LST_PBB (stmt);\n-      ppl_Polyhedron_t poly = PBB_TRANSFORMED_SCATTERING (pbb);\n-      int j, nb_dims_to_remove = PBB_NB_SCATTERING_TRANSFORM (pbb) - 3;\n-      ppl_dimension_type *ds;\n-\n-      /* There should be no loops inside LST after flattening.  */\n-      gcc_assert (!LST_LOOP_P (stmt));\n-\n-      if (!nb_dims_to_remove)\n-\tcontinue;\n-\n-      ds = XNEWVEC (ppl_dimension_type, nb_dims_to_remove);\n-      for (j = 0; j < nb_dims_to_remove; j++)\n-\tds[j] = j + 3;\n-\n-      ppl_Polyhedron_remove_space_dimensions (poly, ds, nb_dims_to_remove);\n-      PBB_NB_SCATTERING_TRANSFORM (pbb) -= nb_dims_to_remove;\n-      free (ds);\n-    }\n-\n-  mpz_clear (x);\n-  ppl_delete_Coefficient (one);\n-}\n-\n-/* Flattens all the loop nests of LST.  Return true when something\n-   changed.  */\n-\n-static bool\n-lst_do_flatten (lst_p lst)\n-{\n-  int i;\n-  lst_p l;\n-  bool res = false;\n-  mpz_t zero;\n-\n-  if (!lst\n-      || !LST_LOOP_P (lst))\n-    return false;\n-\n-  mpz_init (zero);\n-  mpz_set_si (zero, 0);\n-\n-  FOR_EACH_VEC_ELT (lst_p, LST_SEQ (lst), i, l)\n-    if (LST_LOOP_P (l))\n-      {\n-\tres |= lst_flatten_loop (l, zero);\n-\n-\t/* FIXME: As long as we use PPL we are not able to remove the old\n-\t   scattering dimensions.  The reason is that these dimensions are not\n-\t   entirely unused.  They are not necessary as part of the scheduling\n-\t   vector, as the earlier dimensions already unambiguously define the\n-\t   execution time, however they may still be needed to carry modulo\n-\t   constraints as introduced e.g. by strip mining.  The correct solution\n-\t   would be to project these dimensions out of the scattering polyhedra.\n-\t   In case they are still required to carry modulo constraints they should be kept\n-\t   internally as existentially quantified dimensions.  PPL does only support\n-           projection of rational polyhedra, however in this case we need an integer\n-\t   projection. With isl this will be trivial to implement.  For now we just\n-\t   leave the dimensions. This is a little ugly, but should be correct.  */\n-\tif (0)\n-\t  remove_unused_scattering_dimensions (l);\n-      }\n-\n-  lst_update_scattering (lst);\n-  mpz_clear (zero);\n-  return res;\n-}\n-\n-/* Flatten all the loop nests in SCOP.  Returns true when something\n-   changed.  */\n-\n-bool\n-flatten_all_loops (scop_p scop)\n-{\n-  return lst_do_flatten (SCOP_TRANSFORMED_SCHEDULE (scop));\n-}\n-\n-#endif"}, {"sha": "9f3ba1db34706ac1870d35f57bf945fd167662c3", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093193bed727f13cbf10b590d13c896419f215b9/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093193bed727f13cbf10b590d13c896419f215b9/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=093193bed727f13cbf10b590d13c896419f215b9", "patch": "@@ -771,9 +771,6 @@ apply_poly_transforms (scop_p scop)\n \ttransform_done |= scop_do_interchange (scop);\n     }\n \n-  if (flag_loop_flatten)\n-    transform_done |= flatten_all_loops (scop);\n-\n   /* This feature is only enabled in the Graphite branch.  */\n   if (0)\n     {"}, {"sha": "4868f338558f494651e91d96940ddb76ed9cb5a4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093193bed727f13cbf10b590d13c896419f215b9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093193bed727f13cbf10b590d13c896419f215b9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=093193bed727f13cbf10b590d13c896419f215b9", "patch": "@@ -1,3 +1,7 @@\n+2012-03-02  Maxim Kuvyrkov  <maxim@codesourcery.com>\n+\n+\t* gcc.dg/graphite/pr50561.c: Update.\n+\n 2012-03-02  Peter Bergner  <bergner@vnet.ibm.com>\n \n \t* gcc.target/powerpc/pr52457.c: New test."}, {"sha": "5fbad4a732906546b8cdc30264e9a1696018e304", "filename": "gcc/testsuite/gcc.dg/graphite/pr50561.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093193bed727f13cbf10b590d13c896419f215b9/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr50561.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093193bed727f13cbf10b590d13c896419f215b9/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr50561.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr50561.c?ref=093193bed727f13cbf10b590d13c896419f215b9", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -floop-flatten -floop-strip-mine\" } */\n+/* { dg-options \"-O2 -floop-strip-mine\" } */\n \n void f (unsigned *s)\n {"}, {"sha": "665664041b197d0f14a8c8a719de938dcd81bb7e", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093193bed727f13cbf10b590d13c896419f215b9/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093193bed727f13cbf10b590d13c896419f215b9/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=093193bed727f13cbf10b590d13c896419f215b9", "patch": "@@ -1315,12 +1315,11 @@ process_options (void)\n   if (flag_graphite\n       || flag_graphite_identity\n       || flag_loop_block\n-      || flag_loop_flatten\n       || flag_loop_interchange\n       || flag_loop_strip_mine\n       || flag_loop_parallelize_all)\n     sorry (\"Graphite loop optimizations cannot be used (-fgraphite, \"\n-\t   \"-fgraphite-identity, -floop-block, -floop-flatten, \"\n+\t   \"-fgraphite-identity, -floop-block, \"\n \t   \"-floop-interchange, -floop-strip-mine, -floop-parallelize-all, \"\n \t   \"and -ftree-loop-linear)\");\n #endif"}, {"sha": "91eeb16cec9b9993a0e906b83786320c9e7335f9", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/093193bed727f13cbf10b590d13c896419f215b9/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/093193bed727f13cbf10b590d13c896419f215b9/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=093193bed727f13cbf10b590d13c896419f215b9", "patch": "@@ -266,8 +266,7 @@ gate_graphite_transforms (void)\n       || flag_loop_interchange\n       || flag_loop_strip_mine\n       || flag_graphite_identity\n-      || flag_loop_parallelize_all\n-      || flag_loop_flatten)\n+      || flag_loop_parallelize_all)\n     flag_graphite = 1;\n \n   return flag_graphite != 0;"}]}