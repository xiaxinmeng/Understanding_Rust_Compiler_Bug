{"sha": "e42c64cb6dca35a4979db08706033d89b94f196f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQyYzY0Y2I2ZGNhMzVhNDk3OWRiMDg3MDYwMzNkODliOTRmMTk2Zg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2013-08-20T00:54:49Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2013-08-20T00:54:49Z"}, "message": "Make opt_pass and gcc::pass_manager be GC-managed\n\n2013-08-20  David Malcolm  <dmalcolm@redhat.com>\n\n\tMake opt_pass and gcc::pass_manager be GC-managed, so that pass\n\tinstances can own GC refs.\n\n\t* Makefile.in (GTFILES): Add pass_manager.h and tree-pass.h.\n\t* context.c (gcc::context::gt_ggc_mx): Traverse passes_.\n\t(gcc::context::gt_pch_nx): Likewise.\n\t(gcc::context::gt_pch_nx):  Likewise.\n\t* ggc.h (gt_ggc_mx <T>): New.\n\t(gt_pch_nx_with_op <T>): New.\n\t(gt_pch_nx <T>): New.\n\t* passes.c (opt_pass::gt_ggc_mx): New.\n\t(opt_pass::gt_pch_nx): New.\n\t(opt_pass::gt_pch_nx_with_op): New.\n\t(pass_manager::gt_ggc_mx): New.\n\t(pass_manager::gt_pch_nx): New.\n\t(pass_manager::gt_pch_nx_with_op): New.\n\t(pass_manager::operator new): Use\n\tggc_internal_cleared_alloc_stat rather than xcalloc.\n\t* pass_manager.h (class pass_manager): Add GTY((user)) marking.\n\t(pass_manager::gt_ggc_mx): New.\n\t(pass_manager::gt_pch_nx): New.\n\t(pass_manager::gt_pch_nx_with_op): New.\n\t* tree-pass.h (class opt_pass): Add GTY((user)) marking.\n\t(opt_pass::operator new): New.\n\t(opt_pass::gt_ggc_mx): New.\n\t(opt_pass::gt_pch_nx): New.\n\t(opt_pass::gt_pch_nx_with_op): New.\n\nFrom-SVN: r201865", "tree": {"sha": "05efba88a6ac6bfe88226db36b3f7150d78b74bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05efba88a6ac6bfe88226db36b3f7150d78b74bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e42c64cb6dca35a4979db08706033d89b94f196f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e42c64cb6dca35a4979db08706033d89b94f196f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e42c64cb6dca35a4979db08706033d89b94f196f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e42c64cb6dca35a4979db08706033d89b94f196f/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "910c02a071adeae2000fedcfeba2172154f52c0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/910c02a071adeae2000fedcfeba2172154f52c0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/910c02a071adeae2000fedcfeba2172154f52c0d"}], "stats": {"total": 246, "additions": 239, "deletions": 7}, "files": [{"sha": "1c95d9a2388e7346a5ad9da622500908fe32b68e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e42c64cb6dca35a4979db08706033d89b94f196f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e42c64cb6dca35a4979db08706033d89b94f196f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e42c64cb6dca35a4979db08706033d89b94f196f", "patch": "@@ -1,3 +1,33 @@\n+2013-08-20  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tMake opt_pass and gcc::pass_manager be GC-managed, so that pass\n+\tinstances can own GC refs.\n+\n+\t* Makefile.in (GTFILES): Add pass_manager.h and tree-pass.h.\n+\t* context.c (gcc::context::gt_ggc_mx): Traverse passes_.\n+\t(gcc::context::gt_pch_nx): Likewise.\n+\t(gcc::context::gt_pch_nx):  Likewise.\n+\t* ggc.h (gt_ggc_mx <T>): New.\n+\t(gt_pch_nx_with_op <T>): New.\n+\t(gt_pch_nx <T>): New.\n+\t* passes.c (opt_pass::gt_ggc_mx): New.\n+\t(opt_pass::gt_pch_nx): New.\n+\t(opt_pass::gt_pch_nx_with_op): New.\n+\t(pass_manager::gt_ggc_mx): New.\n+\t(pass_manager::gt_pch_nx): New.\n+\t(pass_manager::gt_pch_nx_with_op): New.\n+\t(pass_manager::operator new): Use\n+\tggc_internal_cleared_alloc_stat rather than xcalloc.\n+\t* pass_manager.h (class pass_manager): Add GTY((user)) marking.\n+\t(pass_manager::gt_ggc_mx): New.\n+\t(pass_manager::gt_pch_nx): New.\n+\t(pass_manager::gt_pch_nx_with_op): New.\n+\t* tree-pass.h (class opt_pass): Add GTY((user)) marking.\n+\t(opt_pass::operator new): New.\n+\t(opt_pass::gt_ggc_mx): New.\n+\t(opt_pass::gt_pch_nx): New.\n+\t(opt_pass::gt_pch_nx_with_op): New.\n+\n 2013-08-20  David Malcolm  <dmalcolm@redhat.com>\n \n \t* Makefile.in (GTFILES): Add context.h."}, {"sha": "704ca1083117d326537c4334ffecf566827dfa3f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e42c64cb6dca35a4979db08706033d89b94f196f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e42c64cb6dca35a4979db08706033d89b94f196f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e42c64cb6dca35a4979db08706033d89b94f196f", "patch": "@@ -3832,6 +3832,8 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/asan.c \\\n   $(srcdir)/tsan.c $(srcdir)/ipa-devirt.c \\\n   $(srcdir)/context.h \\\n+  $(srcdir)/pass_manager.h \\\n+  $(srcdir)/tree-pass.h \\\n   @all_gtfiles@\n \n # Compute the list of GT header files from the corresponding C sources,"}, {"sha": "698cc579518fd3760d7f23eb9f8b2707b56ea265", "filename": "gcc/context.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e42c64cb6dca35a4979db08706033d89b94f196f/gcc%2Fcontext.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e42c64cb6dca35a4979db08706033d89b94f196f/gcc%2Fcontext.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcontext.c?ref=e42c64cb6dca35a4979db08706033d89b94f196f", "patch": "@@ -42,18 +42,18 @@ gcc::context::context()\n void\n gcc::context::gt_ggc_mx ()\n {\n-  /* Currently a no-op.  */\n+  ::gt_ggc_mx (passes_);\n }\n \n void\n gcc::context::gt_pch_nx ()\n {\n-  /* Currently a no-op.  */\n+  ::gt_pch_nx (passes_);\n }\n \n void\n gcc::context::gt_pch_nx (gt_pointer_operator op ATTRIBUTE_UNUSED,\n \t\t\t void *cookie ATTRIBUTE_UNUSED)\n {\n-  /* Currently a no-op.  */\n+  op (&passes_, cookie);\n }"}, {"sha": "e2a1aaf3334c1e630993b3b2f242be1e540a2e19", "filename": "gcc/ggc.h", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e42c64cb6dca35a4979db08706033d89b94f196f/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e42c64cb6dca35a4979db08706033d89b94f196f/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=e42c64cb6dca35a4979db08706033d89b94f196f", "patch": "@@ -276,4 +276,50 @@ ggc_alloc_cleared_gimple_statement_d_stat (size_t s MEM_STAT_DECL)\n     ggc_internal_cleared_alloc_stat (s PASS_MEM_STAT);\n }\n \n+/* gengtype will autogenerate traversal functions (in gtype-desc.c) for\n+   all GTY-marked types that it sees are referenced by a GTY marker.\n+\n+   Unfortunately, it will not generate traveral functions for types that\n+   are only referenced by GTY((user)) types.\n+\n+   The following templates are a substitute, providing equivalent\n+   traversal functions for such types.  They are instantiated for\n+   types whose objects that are traversed during GC/PCH, and are\n+   called *every time* that an instance of type T is traversed during\n+   GC/PCH.\n+\n+   They require the presence of the following member functions\n+\n+     void gt_ggc_mx ();\n+     void gt_pch_nx ();\n+     void gt_pch_nx_with_op (gt_pointer_operator op, void *cookie);\n+\n+   within class T, which are called *once* per object - the first\n+   time the object is visited during the traversal.  */\n+\n+template<class T>\n+inline void gt_ggc_mx (T *p)\n+{\n+  if (ggc_test_and_set_mark (p))\n+    p->gt_ggc_mx ();\n+}\n+\n+template<class T>\n+void gt_pch_nx_with_op (void *this_obj, void *p,\n+\t\t\tgt_pointer_operator op, void *cookie)\n+{\n+  if (p == this_obj)\n+    {\n+      T *t = static_cast<T *>(p);\n+      t->gt_pch_nx_with_op (op, cookie);\n+    }\n+}\n+\n+template<class T>\n+inline void gt_pch_nx (T *p)\n+{\n+  if (gt_pch_note_object (p, p, gt_pch_nx_with_op<T>))\n+    p->gt_pch_nx ();\n+}\n+\n #endif"}, {"sha": "a442bf1868a5e110c5d29224efe9ef7a29405e2a", "filename": "gcc/pass_manager.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e42c64cb6dca35a4979db08706033d89b94f196f/gcc%2Fpass_manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e42c64cb6dca35a4979db08706033d89b94f196f/gcc%2Fpass_manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpass_manager.h?ref=e42c64cb6dca35a4979db08706033d89b94f196f", "patch": "@@ -44,13 +44,19 @@ namespace gcc {\n \n class context;\n \n-class pass_manager\n+class GTY((user)) pass_manager\n {\n public:\n+  /* Ensure that instances are allocated in the GC-managed heap.  */\n   void *operator new (size_t sz);\n \n   pass_manager(context *ctxt);\n \n+  /* GTY((user)) methods.  */\n+  void gt_ggc_mx ();\n+  void gt_pch_nx ();\n+  void gt_pch_nx_with_op (gt_pointer_operator op, void *cookie);\n+\n   void register_pass (struct register_pass_info *pass_info);\n   void register_one_dump_file (struct opt_pass *pass);\n \n@@ -134,4 +140,3 @@ class pass_manager\n } // namespace gcc\n \n #endif /* ! GCC_PASS_MANAGER_H */\n-"}, {"sha": "3fa43931f059a6966767770453f447081645de5e", "filename": "gcc/passes.c", "status": "modified", "additions": 139, "deletions": 1, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e42c64cb6dca35a4979db08706033d89b94f196f/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e42c64cb6dca35a4979db08706033d89b94f196f/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=e42c64cb6dca35a4979db08706033d89b94f196f", "patch": "@@ -82,6 +82,58 @@ struct opt_pass *current_pass;\n \n static void register_pass_name (struct opt_pass *, const char *);\n \n+void*\n+opt_pass::operator new (size_t sz)\n+{\n+  return ggc_internal_cleared_alloc_stat (sz MEM_STAT_INFO);\n+}\n+\n+void opt_pass::gt_ggc_mx ()\n+{\n+  ::gt_ggc_mx (ctxt_);\n+  ::gt_ggc_mx (sub);\n+\n+  /* Avoid deep stack usage by iteratively walking the chain of \"next\"\n+     passes, rather than recursing (analogous to the chain_next/chain_prev\n+     GTY options).  */\n+\n+  /* \"this\" has already been marked.\n+     Mark a chain of as-yet-unmarked passes.  */\n+  opt_pass *limit = this->next;\n+  while (ggc_test_and_set_mark (limit))\n+    limit = limit->next;\n+\n+  /* \"limit\" is the first in the chain that wasn't just marked, either\n+     because it is NULL, or because it was already marked.\n+     Hence all of the passes in the half-open interval:\n+\t[this->next...limit)\n+     have just been marked: visit them.  */\n+  for (opt_pass *iter = this->next; iter != limit; iter = iter->next)\n+    iter->gt_ggc_mx ();\n+}\n+\n+void opt_pass::gt_pch_nx ()\n+{\n+  ::gt_pch_nx (ctxt_);\n+  ::gt_pch_nx (sub);\n+\n+  /* Analogous to opt_pass::gt_ggc_mx.  */\n+  opt_pass *limit = this->next;\n+  while (gt_pch_note_object (limit, limit, ::gt_pch_nx_with_op<opt_pass>))\n+    limit = limit->next;\n+\n+ for (opt_pass *iter = this->next; iter != limit; iter = iter->next)\n+    iter->gt_pch_nx ();\n+\n+}\n+\n+void opt_pass::gt_pch_nx_with_op (gt_pointer_operator op, void *cookie)\n+{\n+  op (&(ctxt_), cookie);\n+  op (&(sub), cookie);\n+  op (&(next), cookie);\n+}\n+\n /* Most passes are single-instance (within their context) and thus don't\n    need to implement cloning, but passes that support multiple instances\n    *must* provide their own implementation of the clone method.\n@@ -116,6 +168,92 @@ opt_pass::opt_pass(const pass_data &data, context *ctxt)\n {\n }\n \n+void\n+pass_manager::gt_ggc_mx ()\n+{\n+  /* We want to efficiently visit all pass objects without incurring deep\n+     call chains that could blow the stack.\n+\n+     Although there are multiple fields referencing passes within the\n+     pass_manager, *almost* all of the underlying pass instances are\n+     referenced by the passes_by_id array.\n+\n+     Specifically, passes are in the passes_by_id array if they have\n+     register_one_dump_file called on them, which requires them to have\n+     a name, and for that name to *not* begin with \"*\".  Currently\n+     there are 25 passes with a \"*\" prefix and thus not in the array.\n+\n+     Each pass holds references to its sub and next, so visiting a pass\n+     will potentially trigger a recursive traversal through these\n+     neighbours - if these passes haven't been visited yet.\n+\n+     By walking the passes_by_id array *backwards*, in the common case\n+     this leads to us walking the pass tree from the leaf passes first,\n+     eventually reaching the trunk passes, and hence none of the calls\n+     should recurse, given that at each point in the iteration pass->sub\n+     and pass->next will already have been marked.\n+\n+     Having walked the array, we then walk the higher-level fields,\n+     again in bottom-up order, which will ensure that we visit all\n+     remaining passes.  Most of the passes will have already been\n+     visited, which should minimize further recursion.  */\n+  for (int i = passes_by_id_size ; i > 0; )\n+    ::gt_ggc_mx (passes_by_id[--i]);\n+\n+  ::gt_ggc_mx (all_late_ipa_passes);\n+  ::gt_ggc_mx (all_lto_gen_passes);\n+  ::gt_ggc_mx (all_regular_ipa_passes);\n+  ::gt_ggc_mx (all_lowering_passes);\n+  ::gt_ggc_mx (all_small_ipa_passes);\n+  ::gt_ggc_mx (all_passes);\n+}\n+\n+void\n+pass_manager::gt_pch_nx ()\n+{\n+  /* Analogous to pass_manager::gt_ggc_mx */\n+  for (int i = passes_by_id_size ; i > 0; )\n+    ::gt_pch_nx (passes_by_id[--i]);\n+\n+  ::gt_pch_nx (all_late_ipa_passes);\n+  ::gt_pch_nx (all_lto_gen_passes);\n+  ::gt_pch_nx (all_regular_ipa_passes);\n+  ::gt_pch_nx (all_lowering_passes);\n+  ::gt_pch_nx (all_small_ipa_passes);\n+  ::gt_pch_nx (all_passes);\n+}\n+\n+void\n+pass_manager::gt_pch_nx_with_op (gt_pointer_operator op, void *cookie)\n+{\n+  /* Unlike the _mx and _nx hooks, we must visit *every* field, since\n+     they must each be reconstructed when reading the data back from\n+     disk.  */\n+  op (&(all_passes), cookie);\n+  op (&(all_small_ipa_passes), cookie);\n+  op (&(all_lowering_passes), cookie);\n+  op (&(all_regular_ipa_passes), cookie);\n+  op (&(all_lto_gen_passes), cookie);\n+  op (&(all_late_ipa_passes), cookie);\n+\n+  for (int i = 0; i < passes_by_id_size; i++)\n+    op (&(passes_by_id[i]), cookie);\n+\n+#define INSERT_PASSES_AFTER(PASS)\n+#define PUSH_INSERT_PASSES_WITHIN(PASS)\n+#define POP_INSERT_PASSES()\n+#define NEXT_PASS(PASS, NUM) op (&(PASS ## _ ## NUM), cookie);\n+#define TERMINATE_PASS_LIST()\n+\n+#include \"pass-instances.def\"\n+\n+#undef INSERT_PASSES_AFTER\n+#undef PUSH_INSERT_PASSES_WITHIN\n+#undef POP_INSERT_PASSES\n+#undef NEXT_PASS\n+#undef TERMINATE_PASS_LIST\n+\n+}\n \n void\n pass_manager::execute_early_local_passes ()\n@@ -1464,7 +1602,7 @@ void *\n pass_manager::operator new (size_t sz)\n {\n   /* Ensure that all fields of the pass manager are zero-initialized.  */\n-  return xcalloc (1, sz);\n+  return ggc_internal_cleared_alloc_stat (sz MEM_STAT_INFO);\n }\n \n pass_manager::pass_manager (context *ctxt)"}, {"sha": "b2182c5ec288cdc7598d0f87d39ce6f8a18131a4", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e42c64cb6dca35a4979db08706033d89b94f196f/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e42c64cb6dca35a4979db08706033d89b94f196f/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=e42c64cb6dca35a4979db08706033d89b94f196f", "patch": "@@ -76,11 +76,22 @@ namespace gcc\n \n /* An instance of a pass.  This is also \"pass_data\" to minimize the\n    changes in existing code.  */\n-class opt_pass : public pass_data\n+class GTY((user)) opt_pass : public pass_data\n {\n public:\n+  /* Ensure that instances are allocated in the GC-managed heap.  */\n+  void *operator new (size_t sz);\n+\n   virtual ~opt_pass () { }\n \n+  /* GTY((user)) methods, to be called once per traversal.\n+     opt_pass subclasses with additional GC-managed data should override\n+     these, chain up to the base class implementation, then walk their\n+     extra fields.  */\n+  virtual void gt_ggc_mx ();\n+  virtual void gt_pch_nx ();\n+  virtual void gt_pch_nx_with_op (gt_pointer_operator op, void *cookie);\n+\n   /* Create a copy of this pass.\n \n      Passes that can have multiple instances must provide their own"}]}