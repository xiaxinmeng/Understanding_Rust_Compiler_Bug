{"sha": "d7e5b287a07ee0615c5c8f27ac2e5f27bbb1467c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdlNWIyODdhMDdlZTA2MTVjNWM4ZjI3YWMyZTVmMjdiYmIxNDY3Yw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-06T14:19:45Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-06T14:19:45Z"}, "message": "fold-const.c (optimize_minmax_comparison): Take decomposed arguments code, type, op0, and op1 instead of t.\n\n\t* fold-const.c (optimize_minmax_comparison): Take decomposed\n\targuments code, type, op0, and op1 instead of t.\n\t(fold_binary): Update a call to optimize_minmax_comparison.\n\nFrom-SVN: r95971", "tree": {"sha": "219caf65938492613e3650bb0a6b6835080502c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/219caf65938492613e3650bb0a6b6835080502c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7e5b287a07ee0615c5c8f27ac2e5f27bbb1467c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7e5b287a07ee0615c5c8f27ac2e5f27bbb1467c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7e5b287a07ee0615c5c8f27ac2e5f27bbb1467c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7e5b287a07ee0615c5c8f27ac2e5f27bbb1467c/comments", "author": null, "committer": null, "parents": [{"sha": "c933f71e3d23b794c70aa88f5641b1368a958167", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c933f71e3d23b794c70aa88f5641b1368a958167", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c933f71e3d23b794c70aa88f5641b1368a958167"}], "stats": {"total": 44, "additions": 31, "deletions": 13}, "files": [{"sha": "95005a4c0773576044620c186a01561049ead1c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e5b287a07ee0615c5c8f27ac2e5f27bbb1467c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e5b287a07ee0615c5c8f27ac2e5f27bbb1467c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7e5b287a07ee0615c5c8f27ac2e5f27bbb1467c", "patch": "@@ -6,6 +6,10 @@\n \n \t* fold-const.c (fold_binary): Use code instead of t.\n \n+\t* fold-const.c (optimize_minmax_comparison): Take decomposed\n+\targuments code, type, op0, and op1 instead of t.\n+\t(fold_binary): Update a call to optimize_minmax_comparison.\n+\n 2005-03-06  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* fold-const.c (fold_binary): Avoid directly using the original"}, {"sha": "86b94f1f33d96b360440e78483fb571fdfc2d05d", "filename": "gcc/fold-const.c", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e5b287a07ee0615c5c8f27ac2e5f27bbb1467c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e5b287a07ee0615c5c8f27ac2e5f27bbb1467c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=d7e5b287a07ee0615c5c8f27ac2e5f27bbb1467c", "patch": "@@ -117,7 +117,7 @@ static tree fold_range_test (tree);\n static tree fold_cond_expr_with_comparison (tree, tree, tree, tree);\n static tree unextend (tree, int, int, tree);\n static tree fold_truthop (enum tree_code, tree, tree, tree);\n-static tree optimize_minmax_comparison (tree);\n+static tree optimize_minmax_comparison (enum tree_code, tree, tree, tree);\n static tree extract_muldiv (tree, tree, enum tree_code, tree);\n static tree extract_muldiv_1 (tree, tree, enum tree_code, tree);\n static int multiple_of_p (tree, tree, tree);\n@@ -4959,12 +4959,11 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n    constant.  */\n \n static tree\n-optimize_minmax_comparison (tree t)\n+optimize_minmax_comparison (enum tree_code code, tree type, tree op0, tree op1)\n {\n-  tree type = TREE_TYPE (t);\n-  tree arg0 = TREE_OPERAND (t, 0);\n+  tree arg0 = op0;\n   enum tree_code op_code;\n-  tree comp_const = TREE_OPERAND (t, 1);\n+  tree comp_const = op1;\n   tree minmax_const;\n   int consts_equal, consts_lt;\n   tree inner;\n@@ -4983,24 +4982,33 @@ optimize_minmax_comparison (tree t)\n       || TREE_CONSTANT_OVERFLOW (comp_const)\n       || TREE_CODE (minmax_const) != INTEGER_CST\n       || TREE_CONSTANT_OVERFLOW (minmax_const))\n-    return t;\n+    return NULL_TREE;\n \n   /* Now handle all the various comparison codes.  We only handle EQ_EXPR\n      and GT_EXPR, doing the rest with recursive calls using logical\n      simplifications.  */\n-  switch (TREE_CODE (t))\n+  switch (code)\n     {\n     case NE_EXPR:  case LT_EXPR:  case LE_EXPR:\n-      return\n-\tinvert_truthvalue (optimize_minmax_comparison (invert_truthvalue (t)));\n+      {\n+\t/* FIXME: We should be able to invert code without building a\n+\t   scratch tree node, but doing so would require us to\n+\t   duplicate a part of invert_truthvalue here.  */\n+\ttree tem = invert_truthvalue (build2 (code, type, op0, op1));\n+\ttem = optimize_minmax_comparison (TREE_CODE (tem),\n+\t\t\t\t\t  TREE_TYPE (tem),\n+\t\t\t\t\t  TREE_OPERAND (tem, 0),\n+\t\t\t\t\t  TREE_OPERAND (tem, 1));\n+\treturn invert_truthvalue (tem);\n+      }\n \n     case GE_EXPR:\n       return\n \tfold (build2 (TRUTH_ORIF_EXPR, type,\n \t\t      optimize_minmax_comparison\n-\t\t      (build2 (EQ_EXPR, type, arg0, comp_const)),\n+\t\t      (EQ_EXPR, type, arg0, comp_const),\n \t\t      optimize_minmax_comparison\n-\t\t      (build2 (GT_EXPR, type, arg0, comp_const))));\n+\t\t      (GT_EXPR, type, arg0, comp_const)));\n \n     case EQ_EXPR:\n       if (op_code == MAX_EXPR && consts_equal)\n@@ -5047,7 +5055,7 @@ optimize_minmax_comparison (tree t)\n \treturn fold (build2 (GT_EXPR, type, inner, comp_const));\n \n     default:\n-      return t;\n+      return NULL_TREE;\n     }\n }\n \f\n@@ -9142,7 +9150,13 @@ fold_binary (tree expr)\n \t       && (TREE_CODE (arg0) == MIN_EXPR\n \t\t   || TREE_CODE (arg0) == MAX_EXPR)\n \t       && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n-\treturn optimize_minmax_comparison (t);\n+\t{\n+\t  tem = optimize_minmax_comparison (code, type, op0, op1);\n+\t  if (tem)\n+\t    return tem;\n+\n+\t  return t;\n+\t}\n \n       /* If we are comparing an ABS_EXPR with a constant, we can\n \t convert all the cases into explicit comparisons, but they may"}]}