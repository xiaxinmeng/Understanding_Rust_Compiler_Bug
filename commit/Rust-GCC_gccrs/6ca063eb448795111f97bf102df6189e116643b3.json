{"sha": "6ca063eb448795111f97bf102df6189e116643b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNhMDYzZWI0NDg3OTUxMTFmOTdiZjEwMmRmNjE4OWUxMTY2NDNiMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-20T10:18:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-20T10:18:00Z"}, "message": "[multiple changes]\n\n2009-06-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem.adb (Walk_Library_Units): Check instantiations first.\n\n\t* sem_ch6.adb (Analyze_Subprogram_Declaration): Mark a subprogram as a\n\tprivate primitive if it is a function with a controlling result that is\n\ta type extension with progenitors.\n\n\t* exp_ch9.adb (Build_Wrapper_Spec, Build_Wrapper_Body): Handle properly\n\ta primitive operation of a synchronized tagged type that has a\n\tcontrolling result.\n\n2009-06-20  Thomas Quinot  <quinot@adacore.com>\n\n\t* einfo.ads: Fix typo.\n\n2009-06-20  Ed Falis  <falis@adacore.com>\n\n\t* s-vxwext.ads, s-vxwext-kernel.adb: Complete previous change.\n\nFrom-SVN: r148743", "tree": {"sha": "2e35a5c020bdbd241e21cc8385d6b296866e998d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e35a5c020bdbd241e21cc8385d6b296866e998d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ca063eb448795111f97bf102df6189e116643b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ca063eb448795111f97bf102df6189e116643b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ca063eb448795111f97bf102df6189e116643b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ca063eb448795111f97bf102df6189e116643b3/comments", "author": null, "committer": null, "parents": [{"sha": "b14e938878d174357be5cfc81aef83e0d7261452", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b14e938878d174357be5cfc81aef83e0d7261452", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b14e938878d174357be5cfc81aef83e0d7261452"}], "stats": {"total": 244, "additions": 167, "deletions": 77}, "files": [{"sha": "a9176b5a228aa3f53c599d1fd9de30dd6a67b8e0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca063eb448795111f97bf102df6189e116643b3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca063eb448795111f97bf102df6189e116643b3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6ca063eb448795111f97bf102df6189e116643b3", "patch": "@@ -1,3 +1,23 @@\n+2009-06-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem.adb (Walk_Library_Units): Check instantiations first.\n+\n+\t* sem_ch6.adb (Analyze_Subprogram_Declaration): Mark a subprogram as a\n+\tprivate primitive if it is a function with a controlling result that is\n+\ta type extension with progenitors.\n+\n+\t* exp_ch9.adb (Build_Wrapper_Spec, Build_Wrapper_Body): Handle properly\n+\ta primitive operation of a synchronized tagged type that has a\n+\tcontrolling result.\n+\n+2009-06-20  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* einfo.ads: Fix typo.\n+\n+2009-06-20  Ed Falis  <falis@adacore.com>\n+\n+\t* s-vxwext.ads, s-vxwext-kernel.adb: Complete previous change.\n+\n 2009-06-19  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (emit_check): Do not wrap up the result"}, {"sha": "049faab5a2b37c01833f34b6ad7d2fa50c369814", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca063eb448795111f97bf102df6189e116643b3/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca063eb448795111f97bf102df6189e116643b3/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=6ca063eb448795111f97bf102df6189e116643b3", "patch": "@@ -3647,7 +3647,7 @@ package Einfo is\n \n --    Wrapped_Entity (Node27)\n --       Present in functions and procedures which have been classified as\n---       Is_Primitive_Wrapper. Set to the entity being wrapper.\n+--       Is_Primitive_Wrapper. Set to the entity being wrapped.\n \n    ------------------\n    -- Access Kinds --"}, {"sha": "cc58d9f4fa49c0b0dbe544503b6cc5d708ba1363", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 101, "deletions": 39, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca063eb448795111f97bf102df6189e116643b3/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca063eb448795111f97bf102df6189e116643b3/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=6ca063eb448795111f97bf102df6189e116643b3", "patch": "@@ -1611,17 +1611,17 @@ package body Exp_Ch9 is\n          declare\n             Actuals      : List_Id := No_List;\n             Conv_Id      : Node_Id;\n-            First_Formal : Node_Id;\n+            First_Form   : Node_Id;\n             Formal       : Node_Id;\n             Nam          : Node_Id;\n \n          begin\n             --  Map formals to actuals. Use the list built for the wrapper\n             --  spec, skipping the object notation parameter.\n \n-            First_Formal := First (Parameter_Specifications (Body_Spec));\n+            First_Form := First (Parameter_Specifications (Body_Spec));\n \n-            Formal := First_Formal;\n+            Formal := First_Form;\n             Next (Formal);\n \n             if Present (Formal) then\n@@ -1637,20 +1637,29 @@ package body Exp_Ch9 is\n             end if;\n \n             --  Special processing for primitives declared between a private\n-            --  type and its completion.\n+            --  type and its completion: the wrapper needs a properly typed\n+            --  parameter if the wrapped operation has a controlling first\n+            --  parameter. Note that this might not be the case for a function\n+            --  with a controlling result.\n \n             if Is_Private_Primitive_Subprogram (Subp_Id) then\n                if No (Actuals) then\n                   Actuals := New_List;\n                end if;\n \n-               Prepend_To (Actuals,\n-                 Unchecked_Convert_To (\n-                   Corresponding_Concurrent_Type (Obj_Typ),\n-                   Make_Identifier (Loc, Name_uO)));\n+               if Is_Controlling_Formal (First_Formal (Subp_Id)) then\n+                  Prepend_To (Actuals,\n+                    Unchecked_Convert_To (\n+                      Corresponding_Concurrent_Type (Obj_Typ),\n+                      Make_Identifier (Loc, Name_uO)));\n \n-               Nam := New_Reference_To (Subp_Id, Loc);\n+               else\n+                  Prepend_To (Actuals,\n+                    Make_Identifier (Loc, Chars =>\n+                      Chars (Defining_Identifier (First_Form))));\n+               end if;\n \n+               Nam := New_Reference_To (Subp_Id, Loc);\n             else\n                --  An access-to-variable object parameter requires an explicit\n                --  dereference in the unchecked conversion. This case occurs\n@@ -1659,7 +1668,7 @@ package body Exp_Ch9 is\n \n                --     O.all.Subp_Id (Formal_1, ..., Formal_N)\n \n-               if Nkind (Parameter_Type (First_Formal)) =\n+               if Nkind (Parameter_Type (First_Form)) =\n                     N_Access_Definition\n                then\n                   Conv_Id :=\n@@ -1679,20 +1688,35 @@ package body Exp_Ch9 is\n                      New_Reference_To (Subp_Id, Loc));\n             end if;\n \n-            --  Create the subprogram body\n+            --  Create the subprogram body. For a function, the call to the\n+            --  actual subprogram has to be converted to the corresponding\n+            --  record if it is a controlling result.\n \n             if Ekind (Subp_Id) = E_Function then\n-               return\n-                 Make_Subprogram_Body (Loc,\n-                   Specification              => Body_Spec,\n-                   Declarations               => Empty_List,\n-                   Handled_Statement_Sequence =>\n-                     Make_Handled_Sequence_Of_Statements (Loc,\n-                       Statements => New_List (\n-                         Make_Simple_Return_Statement (Loc,\n-                           Make_Function_Call (Loc,\n-                             Name                   => Nam,\n-                             Parameter_Associations => Actuals)))));\n+               declare\n+                  Res : Node_Id;\n+\n+               begin\n+                  Res :=\n+                     Make_Function_Call (Loc,\n+                       Name                   => Nam,\n+                       Parameter_Associations => Actuals);\n+\n+                  if Has_Controlling_Result (Subp_Id) then\n+                     Res :=\n+                       Unchecked_Convert_To\n+                         (Corresponding_Record_Type (Etype (Subp_Id)), Res);\n+                  end if;\n+\n+                  return\n+                    Make_Subprogram_Body (Loc,\n+                      Specification              => Body_Spec,\n+                      Declarations               => Empty_List,\n+                      Handled_Statement_Sequence =>\n+                        Make_Handled_Sequence_Of_Statements (Loc,\n+                          Statements => New_List (\n+                            Make_Simple_Return_Statement (Loc, Res))));\n+               end;\n \n             else\n                return\n@@ -1819,7 +1843,8 @@ package body Exp_Ch9 is\n          --  Determine whether the parameters of the generated entry wrapper\n          --  and those of a primitive operation are type conformant. During\n          --  this check, the first parameter of the primitive operation is\n-         --  always skipped.\n+         --  skipped if it is a controlling argument: protected functions\n+         --  may have a controlling result.\n \n          --------------------------------\n          -- Type_Conformant_Parameters --\n@@ -1835,9 +1860,16 @@ package body Exp_Ch9 is\n             Wrapper_Typ    : Entity_Id;\n \n          begin\n-            --  Skip the first parameter of the primitive operation\n+            --  Skip the first (controlling) parameter of primitive operation\n+\n+            Iface_Op_Param := First (Iface_Op_Params);\n+\n+            if Present (First_Formal (Iface_Op))\n+              and then Is_Controlling_Formal (First_Formal (Iface_Op))\n+            then\n+               Iface_Op_Param := Next (Iface_Op_Param);\n+            end if;\n \n-            Iface_Op_Param := Next (First (Iface_Op_Params));\n             Wrapper_Param  := First (Wrapper_Params);\n             while Present (Iface_Op_Param)\n               and then Present (Wrapper_Param)\n@@ -1917,7 +1949,9 @@ package body Exp_Ch9 is\n          --  Skip the object parameter when dealing with primitives declared\n          --  between two views.\n \n-         if Is_Private_Primitive_Subprogram (Subp_Id) then\n+         if Is_Private_Primitive_Subprogram (Subp_Id)\n+           and then not Has_Controlling_Result (Subp_Id)\n+         then\n             Formal := Next (Formal);\n          end if;\n \n@@ -2046,11 +2080,21 @@ package body Exp_Ch9 is\n \n          New_Formals := Replicate_Formals (Loc, Formals);\n \n+         --  A function with a controlling result and no first controlling\n+         --  formal needs no additional parameter.\n+\n+         if Has_Controlling_Result (Subp_Id)\n+           and then\n+             (No (First_Formal (Subp_Id))\n+               or else not Is_Controlling_Formal (First_Formal (Subp_Id)))\n+         then\n+            null;\n+\n          --  Routine Subp_Id has been found to override an interface primitive.\n          --  If the interface operation has an access parameter, create a copy\n          --  of it, with the same null exclusion indicator if present.\n \n-         if Present (First_Param) then\n+         elsif Present (First_Param) then\n             if Nkind (Parameter_Type (First_Param)) = N_Access_Definition then\n                Obj_Param_Typ :=\n                  Make_Access_Definition (Loc,\n@@ -2072,31 +2116,49 @@ package body Exp_Ch9 is\n                 Out_Present         => Out_Present (First_Param),\n                 Parameter_Type      => Obj_Param_Typ);\n \n+            Prepend_To (New_Formals, Obj_Param);\n+\n          --  If we are dealing with a primitive declared between two views,\n-         --  create a default parameter. The mode of the parameter must\n-         --  match that of the primitive operation.\n+         --  implemented by a synchronized operation, we need to create\n+         --  a default parameter. The mode of the parameter must match that\n+         --  of the primitive operation.\n \n-         else pragma Assert (Is_Private_Primitive_Subprogram (Subp_Id));\n+         else\n+            pragma Assert (Is_Private_Primitive_Subprogram (Subp_Id));\n             Obj_Param :=\n               Make_Parameter_Specification (Loc,\n                 Defining_Identifier =>\n                   Make_Defining_Identifier (Loc, Name_uO),\n                 In_Present  => In_Present (Parent (First_Entity (Subp_Id))),\n                 Out_Present => Ekind (Subp_Id) /= E_Function,\n                   Parameter_Type => New_Reference_To (Obj_Typ, Loc));\n+            Prepend_To (New_Formals, Obj_Param);\n          end if;\n \n-         Prepend_To (New_Formals, Obj_Param);\n-\n-         --  Build the final spec\n+         --  Build the final spec. If it is a function with a controlling\n+         --  result, it is a primitive operation of the corresponding\n+         --  record type, so mark the spec accordingly.\n \n          if Ekind (Subp_Id) = E_Function then\n-            return\n-              Make_Function_Specification (Loc,\n-                Defining_Unit_Name       => Wrapper_Id,\n-                Parameter_Specifications => New_Formals,\n-                Result_Definition        =>\n-                  New_Copy (Result_Definition (Parent (Subp_Id))));\n+\n+            declare\n+               Res_Def : Node_Id;\n+\n+            begin\n+               if Has_Controlling_Result (Subp_Id) then\n+                  Res_Def :=\n+                    New_Occurrence_Of\n+                      (Corresponding_Record_Type (Etype (Subp_Id)), Loc);\n+               else\n+                  Res_Def := New_Copy (Result_Definition (Parent (Subp_Id)));\n+               end if;\n+\n+               return\n+                 Make_Function_Specification (Loc,\n+                   Defining_Unit_Name       => Wrapper_Id,\n+                   Parameter_Specifications => New_Formals,\n+                   Result_Definition        => Res_Def);\n+            end;\n          else\n             return\n               Make_Procedure_Specification (Loc,"}, {"sha": "ad609f3cf81ba3adbd03fcbccbc3cbe85c14dd99", "filename": "gcc/ada/s-vxwext-kernel.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca063eb448795111f97bf102df6189e116643b3/gcc%2Fada%2Fs-vxwext-kernel.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca063eb448795111f97bf102df6189e116643b3/gcc%2Fada%2Fs-vxwext-kernel.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vxwext-kernel.adb?ref=6ca063eb448795111f97bf102df6189e116643b3", "patch": "@@ -56,7 +56,11 @@ package body System.VxWorks.Ext is\n    -- semDelete --\n    ---------------\n \n-   function semDelete (Sem : SEM_ID) return int;\n-   pragma Import (C, semDelete, \"semDelete\");\n+   function semDelete (Sem : SEM_ID) return int is\n+      function Os_Sem_Delete (Sem : SEM_ID) return int;\n+      pragma Import (C, Os_Sem_Delete, \"semDelete\");\n+   begin\n+      return Os_Sem_Delete (Sem);\n+   end semDelete;\n \n end System.VxWorks.Ext;"}, {"sha": "bc458395c8b2e532537db79469a008cf5d60d2b4", "filename": "gcc/ada/s-vxwext.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca063eb448795111f97bf102df6189e116643b3/gcc%2Fada%2Fs-vxwext.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca063eb448795111f97bf102df6189e116643b3/gcc%2Fada%2Fs-vxwext.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vxwext.ads?ref=6ca063eb448795111f97bf102df6189e116643b3", "patch": "@@ -36,7 +36,7 @@ with Interfaces.C;\n package System.VxWorks.Ext is\n    pragma Preelaborate;\n \n-   type SEM_ID is new Long_Integer;\n+   subtype SEM_ID is Long_Integer;\n    --  typedef struct semaphore *SEM_ID;\n \n    type t_id is new Long_Integer;"}, {"sha": "dad352b03d433372cb2b43137ad8ba6743f6cca1", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca063eb448795111f97bf102df6189e116643b3/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca063eb448795111f97bf102df6189e116643b3/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=6ca063eb448795111f97bf102df6189e116643b3", "patch": "@@ -1766,50 +1766,47 @@ package body Sem is\n \n       Do_Action (Empty, Standard_Package_Node);\n \n+      --  First place the context of all instance bodies on the corresponding\n+      --  spec, because it may be needed to analyze the code at the place of\n+      --  the instantiation.\n+\n       Cur := First_Elmt (Comp_Unit_List);\n       while Present (Cur) loop\n          declare\n             CU : constant Node_Id := Node (Cur);\n             N  : constant Node_Id := Unit (CU);\n \n          begin\n-            pragma Assert (Nkind (CU) = N_Compilation_Unit);\n-\n-            case Nkind (N) is\n+            if Nkind (N) = N_Package_Body\n+              and then Is_Generic_Instance (Defining_Entity (N))\n+            then\n+               Append_List\n+                 (Context_Items (CU), Context_Items (Library_Unit (CU)));\n+            end if;\n \n-               --  If it's a body, then ignore it, unless it's an instance (in\n-               --  which case we do the spec), or it's the main unit (in which\n-               --  case we do it). Note that it could be both, in which case we\n-               --  do the with_clauses of spec and body first,\n+            Next_Elmt (Cur);\n+         end;\n+      end loop;\n \n-               when N_Package_Body | N_Subprogram_Body =>\n-                  declare\n-                     Entity : Node_Id := N;\n+      --  Now traverse compilation units in order.\n \n-                  begin\n-                     if Nkind (Entity) = N_Subprogram_Body then\n-                        Entity := Specification (Entity);\n-                     end if;\n+      Cur := First_Elmt (Comp_Unit_List);\n+      while Present (Cur) loop\n+         declare\n+            CU : constant Node_Id := Node (Cur);\n+            N  : constant Node_Id := Unit (CU);\n \n-                     Entity := Defining_Entity (Entity);\n+         begin\n+            pragma Assert (Nkind (CU) = N_Compilation_Unit);\n \n-                     if Is_Generic_Instance (Entity) then\n-                        declare\n-                           Spec_Unit : constant Node_Id := Library_Unit (CU);\n+            case Nkind (N) is\n \n-                        begin\n-                           --  Move context of body to that of spec, so it\n-                           --  appears before the spec itself, in case it\n-                           --  contains nested instances that generate late\n-                           --  with_clauses that got attached to the body.\n+               --  If it's a body, then ignore it, unless it's the main unit\n+               --  Otherwise bodies appear in the list because of inlining or\n+               --  instantiations, and they are processed immediately after\n+               --  the corresponding specs.\n \n-                           Append_List\n-                             (Context_Items (CU), Context_Items (Spec_Unit));\n-                           Do_Unit_And_Dependents\n-                             (Spec_Unit, Unit (Spec_Unit));\n-                        end;\n-                     end if;\n-                  end;\n+               when N_Package_Body | N_Subprogram_Body =>\n \n                   if CU = Cunit (Main_Unit) then\n                      Do_Unit_And_Dependents (CU, N);"}, {"sha": "b1f202c3652e02da807497f36ce9b5e45f3e30d3", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca063eb448795111f97bf102df6189e116643b3/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca063eb448795111f97bf102df6189e116643b3/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=6ca063eb448795111f97bf102df6189e116643b3", "patch": "@@ -2685,11 +2685,18 @@ package body Sem_Ch6 is\n       New_Overloaded_Entity (Designator);\n       Check_Delayed_Subprogram (Designator);\n \n-      --  If the type of the first formal of the current subprogram is a non\n-      --  generic tagged private type , mark the subprogram as being a private\n-      --  primitive.\n+      --  If the type of the first formal of the current subprogram is a\n+      --  nongeneric tagged private type, mark the subprogram as being a\n+      --  private primitive. Ditto if this is a function with controlling\n+      --  result, and the return type is currently private.\n+\n+      if Has_Controlling_Result (Designator)\n+        and then Is_Private_Type (Etype (Designator))\n+        and then not Is_Generic_Actual_Type (Etype (Designator))\n+      then\n+         Set_Is_Private_Primitive (Designator);\n \n-      if Present (First_Formal (Designator)) then\n+      elsif Present (First_Formal (Designator)) then\n          declare\n             Formal_Typ : constant Entity_Id :=\n                            Etype (First_Formal (Designator));"}]}