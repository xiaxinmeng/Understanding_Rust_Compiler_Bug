{"sha": "e0c556d31f58b412eeab4098d728494d6db2b21e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBjNTU2ZDMxZjU4YjQxMmVlYWI0MDk4ZDcyODQ5NGQ2ZGIyYjIxZQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@one.net.au", "date": "2001-04-13T05:48:20Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2001-04-13T05:48:20Z"}, "message": "pa.c (uint32_operand): Don't use long constant >= 2^32.\n\n\t* pa.c (uint32_operand): Don't use long constant >= 2^32.\n\t(emit_move_sequence): Use HOST_WIDE_INT constants.  Don't worry\n\tabout 32->64 bit sign extension if 32 bit HOST_WIDE_INTs.\n\t(compute_movstrsi_length): Make `align' unsigned to avoid warning.\n\t(output_64bit_and): Use plain `int's for shift counts.\n\t(output_64bit_ior): Likewise.\n\t(function_arg_partial_nregs): Use unsigned vars to avoid warnings.\n\t* pa.h (CONST_OK_FOR_LETTER_P): Use HOST_WIDE_INT constants for case\n\t`N', and simplify.\n\nFrom-SVN: r41328", "tree": {"sha": "7f1bef9501244fefc73f20a8608cc9a2123dbf9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f1bef9501244fefc73f20a8608cc9a2123dbf9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0c556d31f58b412eeab4098d728494d6db2b21e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0c556d31f58b412eeab4098d728494d6db2b21e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0c556d31f58b412eeab4098d728494d6db2b21e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0c556d31f58b412eeab4098d728494d6db2b21e/comments", "author": null, "committer": null, "parents": [{"sha": "cdbff0ab8ca8fa27b96d4843a46044b595e237a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdbff0ab8ca8fa27b96d4843a46044b595e237a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdbff0ab8ca8fa27b96d4843a46044b595e237a8"}], "stats": {"total": 66, "additions": 39, "deletions": 27}, "files": [{"sha": "b4c43f570ce8b2998355de6f9cba09d8b3e21956", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c556d31f58b412eeab4098d728494d6db2b21e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c556d31f58b412eeab4098d728494d6db2b21e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0c556d31f58b412eeab4098d728494d6db2b21e", "patch": "@@ -1,5 +1,15 @@\n 2001-04-13  Alan Modra  <amodra@one.net.au>\n \n+\t* pa.c (uint32_operand): Don't use long constant >= 2^32.\n+\t(emit_move_sequence): Use HOST_WIDE_INT constants.  Don't worry\n+\tabout 32->64 bit sign extension if 32 bit HOST_WIDE_INTs.\n+\t(compute_movstrsi_length): Make `align' unsigned to avoid warning.\n+\t(output_64bit_and): Use plain `int's for shift counts.\n+\t(output_64bit_ior): Likewise.\n+\t(function_arg_partial_nregs): Use unsigned vars to avoid warnings.\n+\t* pa.h (CONST_OK_FOR_LETTER_P): Use HOST_WIDE_INT constants for case\n+\t`N', and simplify.\n+\n \t* pa-hpux10.h (NEW_HP_ASSEMBLER): Define to 1.\n \t* pa-hpux11.h (NEW_HP_ASSEMBLER): Likewise.\n \t* pa.h (LEGITIMATE_CONSTANT_P) Collapse two defines depending on"}, {"sha": "7afcaab4da6762920de2b49198c16ceaac21aead", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c556d31f58b412eeab4098d728494d6db2b21e/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c556d31f58b412eeab4098d728494d6db2b21e/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=e0c556d31f58b412eeab4098d728494d6db2b21e", "patch": "@@ -568,7 +568,7 @@ uint32_operand (op, mode)\n #if HOST_BITS_PER_WIDE_INT > 32\n   /* All allowed constants will fit a CONST_INT.  */\n   return (GET_CODE (op) == CONST_INT\n-\t  && (INTVAL (op) >= 0 && INTVAL (op) < 0x100000000L));\n+\t  && (INTVAL (op) >= 0 && INTVAL (op) < (HOST_WIDE_INT) 1 << 32));\n #else\n   return (GET_CODE (op) == CONST_INT\n \t  || (GET_CODE (op) == CONST_DOUBLE\n@@ -1595,16 +1595,18 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t  int need_zero_extend = 0;\n \n \t  if (TARGET_64BIT && GET_CODE (operand1) == CONST_INT\n+\t      && HOST_BITS_PER_WIDE_INT > 32\n \t      && GET_MODE_BITSIZE (GET_MODE (operand0)) > 32)\n \t    {\n \t      HOST_WIDE_INT val = INTVAL (operand1);\n-\t      HOST_WIDE_INT nval = INTVAL (operand1);\n+\t      HOST_WIDE_INT nval;\n \n \t      /* If the value is the same after a 32->64bit sign\n \t\t extension, then we can use it as-is.  Else we will\n \t\t need to sign extend the constant from 32->64bits\n \t\t then zero extend the result from 32->64bits.  */\n-\t      nval = ((val & 0xffffffff) ^ (~0x7fffffff)) + 0x80000000;\n+\t      nval = ((val & (((HOST_WIDE_INT) 2 << 31) - 1))\n+\t\t      ^ ((HOST_WIDE_INT) 1 << 31)) - ((HOST_WIDE_INT) 1 << 31);\n \t      if (val != nval)\n \t\t{\n \t\t  need_zero_extend = 1;\n@@ -2285,7 +2287,7 @@ compute_movstrsi_length (insn)\n      rtx insn;\n {\n   rtx pat = PATTERN (insn);\n-  int align = INTVAL (XEXP (XVECEXP (pat, 0, 6), 0));\n+  unsigned int align = INTVAL (XEXP (XVECEXP (pat, 0, 6), 0));\n   unsigned long n_bytes = INTVAL (XEXP (XVECEXP (pat, 0, 5), 0));\n   unsigned int n_insns = 0;\n \n@@ -2372,22 +2374,22 @@ output_64bit_and (operands)\n   if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) != 0)\n     {\n       unsigned HOST_WIDE_INT mask = INTVAL (operands[2]);\n-      unsigned HOST_WIDE_INT ls0, ls1, ms0, p, len;\n+      int ls0, ls1, ms0, p, len;\n \n       for (ls0 = 0; ls0 < HOST_BITS_PER_WIDE_INT; ls0++)\n-\tif ((mask & ((unsigned HOST_WIDE_INT)1 << ls0)) == 0)\n+\tif ((mask & ((unsigned HOST_WIDE_INT) 1 << ls0)) == 0)\n \t  break;\n \n       for (ls1 = ls0; ls1 < HOST_BITS_PER_WIDE_INT; ls1++)\n-\tif ((mask & ((unsigned HOST_WIDE_INT)1 << ls1)) != 0)\n+\tif ((mask & ((unsigned HOST_WIDE_INT) 1 << ls1)) != 0)\n \t  break;\n \n       for (ms0 = ls1; ms0 < HOST_BITS_PER_WIDE_INT; ms0++)\n-\tif ((mask & ((unsigned HOST_WIDE_INT)1 << ms0)) == 0)\n+\tif ((mask & ((unsigned HOST_WIDE_INT) 1 << ms0)) == 0)\n \t  break;\n \n       if (ms0 != HOST_BITS_PER_WIDE_INT)\n-\tabort();\n+\tabort ();\n \n       if (ls1 == HOST_BITS_PER_WIDE_INT)\n \t{\n@@ -2452,22 +2454,22 @@ output_64bit_ior (operands)\n      rtx *operands;\n {\n   unsigned HOST_WIDE_INT mask = INTVAL (operands[2]);\n-  unsigned HOST_WIDE_INT bs0, bs1, p, len;\n+  int bs0, bs1, p, len;\n \n   if (INTVAL (operands[2]) == 0)\n     return \"copy %1,%0\";\n \n   for (bs0 = 0; bs0 < HOST_BITS_PER_WIDE_INT; bs0++)\n-    if ((mask & ((unsigned HOST_WIDE_INT)1 << bs0)) != 0)\n+    if ((mask & ((unsigned HOST_WIDE_INT) 1 << bs0)) != 0)\n       break;\n \n   for (bs1 = bs0; bs1 < HOST_BITS_PER_WIDE_INT; bs1++)\n-    if ((mask & ((unsigned HOST_WIDE_INT)1 << bs1)) == 0)\n+    if ((mask & ((unsigned HOST_WIDE_INT) 1 << bs1)) == 0)\n       break;\n \n   if (bs1 != HOST_BITS_PER_WIDE_INT\n       && ((unsigned HOST_WIDE_INT) 1 << bs1) <= mask)\n-    abort();\n+    abort ();\n \n   p = 63 - bs0;\n   len = bs1 - bs0;\n@@ -7113,13 +7115,13 @@ function_arg_partial_nregs (cum, mode, type, named)\n      tree type;\n      int named ATTRIBUTE_UNUSED;\n {\n-  int max_arg_words = 8;\n-  int offset = 0;\n+  unsigned int max_arg_words = 8;\n+  unsigned int offset = 0;\n \n-  if (FUNCTION_ARG_SIZE(mode, type) > 1 && (cum->words & 1))\n+  if (FUNCTION_ARG_SIZE (mode, type) > 1 && (cum->words & 1))\n     offset = 1;\n \n-  if (cum->words + offset + FUNCTION_ARG_SIZE(mode, type) <= max_arg_words)\n+  if (cum->words + offset + FUNCTION_ARG_SIZE (mode, type) <= max_arg_words)\n     /* Arg fits fully into registers. */\n     return 0;\n   else if (cum->words + offset >= max_arg_words) "}, {"sha": "3b9eaf027b7703d5c296982505ef260ef2159416", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c556d31f58b412eeab4098d728494d6db2b21e/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c556d31f58b412eeab4098d728494d6db2b21e/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=e0c556d31f58b412eeab4098d728494d6db2b21e", "patch": "@@ -546,16 +546,16 @@ extern void hppa_init_pic_save PARAMS ((void));\n    */\n \n #define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n-  ((C) == 'I' ? VAL_11_BITS_P (VALUE)\t\t\t\t\\\n-   : (C) == 'J' ? VAL_14_BITS_P (VALUE)\t\t\t\t\\\n-   : (C) == 'K' ? zdepi_cint_p (VALUE)\t\t\t\t\\\n-   : (C) == 'L' ? VAL_5_BITS_P (VALUE)\t\t\t\t\\\n-   : (C) == 'M' ? (VALUE) == 0\t\t\t\t\t\\\n-   : (C) == 'N' ? (((VALUE) & (unsigned long)0x7ff) == 0\t\\\n-\t\t   && (VALUE) == ((((VALUE) & 0xffffffff) ^ (~0x7fffffff)) \\\n-\t\t\t\t  + 0x80000000))\t\t\\\n-   : (C) == 'O' ? (((VALUE) & ((VALUE) + (long)1)) == 0)\t\\\n-   : (C) == 'P' ? and_mask_p (VALUE)\t\t\t\t\\\n+  ((C) == 'I' ? VAL_11_BITS_P (VALUE)\t\t\t\t\t\\\n+   : (C) == 'J' ? VAL_14_BITS_P (VALUE)\t\t\t\t\t\\\n+   : (C) == 'K' ? zdepi_cint_p (VALUE)\t\t\t\t\t\\\n+   : (C) == 'L' ? VAL_5_BITS_P (VALUE)\t\t\t\t\t\\\n+   : (C) == 'M' ? (VALUE) == 0\t\t\t\t\t\t\\\n+   : (C) == 'N' ? (((VALUE) & (((HOST_WIDE_INT) -1 << 31) | 0x7ff)) == 0 \\\n+\t\t   || (((VALUE) & (((HOST_WIDE_INT) -1 << 31) | 0x7ff))\t\\\n+\t\t       == (HOST_WIDE_INT) -1 << 31))\t\t\t\\\n+   : (C) == 'O' ? (((VALUE) & ((VALUE) + 1)) == 0)\t\t\t\\\n+   : (C) == 'P' ? and_mask_p (VALUE)\t\t\t\t\t\\\n    : 0)\n \n /* Similar, but for floating or large integer constants, and defining letters"}]}