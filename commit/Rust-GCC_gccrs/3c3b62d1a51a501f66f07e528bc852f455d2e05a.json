{"sha": "3c3b62d1a51a501f66f07e528bc852f455d2e05a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2MzYjYyZDFhNTFhNTAxZjY2ZjA3ZTUyOGJjODUyZjQ1NWQyZTA1YQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-01-21T20:38:51Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-01-21T20:38:51Z"}, "message": "re PR fortran/42736 (Wrong-code with allocatable or pointer components in elemental functions)\n\n2010-01-21  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/42736\n\t* trans-stmt.c (gfc_conv_elemental_dependencies): If temporary\n\tis required, turn any trailing array elements after a range\n\tinto ranges so that offsets can be calculated.\n\n2010-01-21  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/42736\n\t* gfortran.dg/dependency_25.f90 : New test.\n\nFrom-SVN: r156161", "tree": {"sha": "c27ef460ab03c34c131ea5e04a2f4c542223707b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c27ef460ab03c34c131ea5e04a2f4c542223707b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c3b62d1a51a501f66f07e528bc852f455d2e05a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c3b62d1a51a501f66f07e528bc852f455d2e05a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c3b62d1a51a501f66f07e528bc852f455d2e05a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c3b62d1a51a501f66f07e528bc852f455d2e05a/comments", "author": null, "committer": null, "parents": [{"sha": "7744b697eb20d316840182e2439503920e4ecc1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7744b697eb20d316840182e2439503920e4ecc1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7744b697eb20d316840182e2439503920e4ecc1d"}], "stats": {"total": 136, "additions": 136, "deletions": 0}, "files": [{"sha": "84dcaae64d8228d29d63b583e6aae6e1023603ee", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c3b62d1a51a501f66f07e528bc852f455d2e05a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c3b62d1a51a501f66f07e528bc852f455d2e05a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3c3b62d1a51a501f66f07e528bc852f455d2e05a", "patch": "@@ -1,3 +1,10 @@\n+2010-01-21  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/42736\n+\t* trans-stmt.c (gfc_conv_elemental_dependencies): If temporary\n+\tis required, turn any trailing array elements after a range\n+\tinto ranges so that offsets can be calculated.\n+\n 2010-01-20  Joern Rennecke  <amylaar@spamcop.net>\n \n \t* module.c (mio_f2k_derived): Use enumerator as initializer of"}, {"sha": "010d86f2acb8c159856ef59527be0fa3653e0027", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c3b62d1a51a501f66f07e528bc852f455d2e05a/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c3b62d1a51a501f66f07e528bc852f455d2e05a/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=3c3b62d1a51a501f66f07e528bc852f455d2e05a", "patch": "@@ -196,6 +196,7 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n   gfc_ss *ss;\n   gfc_ss_info *info;\n   gfc_symbol *fsym;\n+  gfc_ref *ref;\n   int n;\n   tree data;\n   tree offset;\n@@ -251,6 +252,34 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n \t  /* Obtain the argument descriptor for unpacking.  */\n \t  gfc_init_se (&parmse, NULL);\n \t  parmse.want_pointer = 1;\n+\n+\t  /* The scalarizer introduces some specific peculiarities when\n+\t     handling elemental subroutines; the stride can be needed up to\n+\t     the dim_array - 1, rather than dim_loop - 1 to calculate\n+\t     offsets outside the loop.  For this reason, we make sure that\n+\t     the descriptor has the dimensionality of the array by converting\n+\t     trailing elements into ranges with end = start.  */\n+\t  for (ref = e->ref; ref; ref = ref->next)\n+\t    if (ref->type == REF_ARRAY && ref->u.ar.type == AR_SECTION)\n+\t      break;\n+\n+\t  if (ref)\n+\t    {\n+\t      bool seen_range = false;\n+\t      for (n = 0; n < ref->u.ar.dimen; n++)\n+\t\t{\n+\t\t  if (ref->u.ar.dimen_type[n] == DIMEN_RANGE)\n+\t\t    seen_range = true;\n+\n+\t\t  if (!seen_range\n+\t\t\t|| ref->u.ar.dimen_type[n] != DIMEN_ELEMENT)\n+\t\t    continue;\n+\n+\t\t  ref->u.ar.end[n] = gfc_copy_expr (ref->u.ar.start[n]);\n+\t\t  ref->u.ar.dimen_type[n] = DIMEN_RANGE;\n+\t\t}\n+\t    }\n+\n \t  gfc_conv_expr_descriptor (&parmse, e, gfc_walk_expr (e));\n \t  gfc_add_block_to_block (&se->pre, &parmse.pre);\n "}, {"sha": "5f749784af044356b6aeea87a27d4c1de4a78369", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c3b62d1a51a501f66f07e528bc852f455d2e05a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c3b62d1a51a501f66f07e528bc852f455d2e05a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3c3b62d1a51a501f66f07e528bc852f455d2e05a", "patch": "@@ -1,3 +1,8 @@\n+2010-01-21  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/42736\n+\t* gfortran.dg/dependency_25.f90 : New test.\n+\n 2010-01-21  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/42585"}, {"sha": "25769857d767226445e2b5843c9e49a88c574513", "filename": "gcc/testsuite/gfortran.dg/dependency_25.f90", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c3b62d1a51a501f66f07e528bc852f455d2e05a/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_25.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c3b62d1a51a501f66f07e528bc852f455d2e05a/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_25.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_25.f90?ref=3c3b62d1a51a501f66f07e528bc852f455d2e05a", "patch": "@@ -0,0 +1,95 @@\n+! { dg-do run }\n+! Test the fix for PR42736, in which an excessively rigorous dependency\n+! checking for the assignment generated an unnecessary temporary, whose\n+! rank was wrong.  When accessed by the scalarizer, a segfault ensued.\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+! Reported by Armelius Cameron <armeliusc@gmail.com>\n+!\n+module UnitValue_Module\n+\n+  implicit none\n+  private\n+\n+  public :: &\n+    operator(*), &\n+    assignment(=)\n+\n+  type, public :: UnitValue\n+    real :: &\n+      Value = 1.0\n+    character(31) :: &\n+      Label\n+  end type UnitValue\n+\n+  interface operator(*)\n+    module procedure ProductReal_LV\n+  end interface operator(*)\n+\n+  interface assignment(=)\n+    module procedure Assign_LV_Real\n+  end interface assignment(=)\n+\n+contains\n+\n+  elemental function ProductReal_LV(Multiplier, Multiplicand) result(P_R_LV)\n+\n+    real, intent(in) :: &\n+      Multiplier\n+    type(UnitValue), intent(in) :: &\n+      Multiplicand\n+    type(UnitValue) :: &\n+      P_R_LV\n+\n+    P_R_LV%Value = Multiplier * Multiplicand%Value\n+    P_R_LV%Label = Multiplicand%Label\n+\n+  end function ProductReal_LV\n+\n+\n+  elemental subroutine Assign_LV_Real(LeftHandSide, RightHandSide)\n+\n+    real, intent(inout) :: &\n+      LeftHandSide\n+    type(UnitValue), intent(in) :: &\n+      RightHandSide\n+\n+    LeftHandSide = RightHandSide%Value\n+\n+  end subroutine Assign_LV_Real\n+\n+end module UnitValue_Module\n+\n+program TestProgram\n+\n+  use UnitValue_Module\n+\n+  implicit none\n+\n+  type :: TableForm\n+    real, dimension(:,:), allocatable :: &\n+      RealData\n+  end type TableForm\n+\n+  type(UnitValue) :: &\n+    CENTIMETER\n+\n+  type(TableForm), pointer :: &\n+    Table\n+\n+  allocate(Table)\n+  allocate(Table%RealData(10,5))\n+\n+  CENTIMETER%value = 42\n+  Table%RealData = 1\n+  Table%RealData(:,1) = Table%RealData(:,1) * CENTIMETER\n+  Table%RealData(:,2) = Table%RealData(:,2) * CENTIMETER\n+  Table%RealData(:,3) = Table%RealData(:,3) * CENTIMETER\n+  Table%RealData(:,5) = Table%RealData(:,5) * CENTIMETER\n+\n+!  print *, Table%RealData\n+  if (any (abs(Table%RealData(:,4) - 1) > epsilon(1.0))) call abort ()\n+  if (any (abs(Table%RealData(:,[1,2,3,5]) - 42) > epsilon(1.0))) call abort ()\n+end program TestProgram\n+\n+! { dg-final { cleanup-modules \"UnitValue_Module\" } }"}]}