{"sha": "7cacf53e505b9143b7ae0e646dc83a4e5cf9f643", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NhY2Y1M2U1MDViOTE0M2I3YWUwZTY0NmRjODNhNGU1Y2Y5ZjY0Mw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-12-14T22:45:28Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-12-14T22:45:28Z"}, "message": "re PR target/17990 (sse used for negate without -mfpmath=sse)\n\n        PR target/17990\n        * config/i386/i386.c (x86_use_bt): New.\n        (ix86_expand_unary_operator): Use MEM_P.\n        (ix86_expand_fp_absneg_operator): New.\n        * config/i386/i386.h (x86_use_bt): Declare.\n        (TARGET_USE_BT): New.\n        * config/i386/i386-protos.h: Update.\n        * config/i386/i386.md (negsf2): Use ix86_expand_fp_absneg_operator.\n        (negdf2, negxf2, abssf2, absdf2, absxf2): Likewise.\n        (negsf2_memory, negsf2_ifs, negsf2_if, negdf2_memory, negdf2_ifs,\n        negdf2_ifs_rex64, negdf2_if, negdf2_if_rex64, negxf2_if,\n        abssf2_memory, abssf2_ifs, abssf2_if, absdf2_memory, absdf2_ifs,\n        absdf2_ifs_rex64, absdf2_if, absxf2_if): Remove.\n        (absnegsf2_mixed, absnegsf2_sse, absnegsf2_i387, absnegdf2_mixed,\n        absnegdf2_sse, absnegdf2_i387, absnegxf2_i387): New.  Merge all\n        neg and abs splitters.  Handle DFmode in general regs in 64-bit mode.\n        (negextendsfdf2, absextendsfdf2): Disable for non-mixed sse math.\n        (btsq, btrq, btcq): New.  Add peepholes as well.\n        (movv4sf_internal splitter): Postpone til after reload.\n        (movv2di_internal splitter): Likewise.\n        * config/i386/predicates.md (const_0_to_63_operand): New.\n        (absneg_operator): New.\n\nFrom-SVN: r92165", "tree": {"sha": "a1448e77e5b0e918746edc64a1731327039582f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1448e77e5b0e918746edc64a1731327039582f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cacf53e505b9143b7ae0e646dc83a4e5cf9f643", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cacf53e505b9143b7ae0e646dc83a4e5cf9f643", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cacf53e505b9143b7ae0e646dc83a4e5cf9f643", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cacf53e505b9143b7ae0e646dc83a4e5cf9f643/comments", "author": null, "committer": null, "parents": [{"sha": "6af713e46c072179890ac797ed7fa80801460165", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6af713e46c072179890ac797ed7fa80801460165", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6af713e46c072179890ac797ed7fa80801460165"}], "stats": {"total": 1170, "additions": 507, "deletions": 663}, "files": [{"sha": "c6a5746cae0ec7a451bf3f3fcc7a973014a95b0f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cacf53e505b9143b7ae0e646dc83a4e5cf9f643/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cacf53e505b9143b7ae0e646dc83a4e5cf9f643/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7cacf53e505b9143b7ae0e646dc83a4e5cf9f643", "patch": "@@ -1,3 +1,28 @@\n+2004-12-14  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/17990\n+\t* config/i386/i386.c (x86_use_bt): New.\n+\t(ix86_expand_unary_operator): Use MEM_P.\n+\t(ix86_expand_fp_absneg_operator): New.\n+\t* config/i386/i386.h (x86_use_bt): Declare.\n+\t(TARGET_USE_BT): New.\n+\t* config/i386/i386-protos.h: Update.\n+\t* config/i386/i386.md (negsf2): Use ix86_expand_fp_absneg_operator.\n+\t(negdf2, negxf2, abssf2, absdf2, absxf2): Likewise.\n+\t(negsf2_memory, negsf2_ifs, negsf2_if, negdf2_memory, negdf2_ifs,\n+\tnegdf2_ifs_rex64, negdf2_if, negdf2_if_rex64, negxf2_if,\n+\tabssf2_memory, abssf2_ifs, abssf2_if, absdf2_memory, absdf2_ifs,\n+\tabsdf2_ifs_rex64, absdf2_if, absxf2_if): Remove.\n+\t(absnegsf2_mixed, absnegsf2_sse, absnegsf2_i387, absnegdf2_mixed,\n+\tabsnegdf2_sse, absnegdf2_i387, absnegxf2_i387): New.  Merge all\n+\tneg and abs splitters.  Handle DFmode in general regs in 64-bit mode.\n+\t(negextendsfdf2, absextendsfdf2): Disable for non-mixed sse math.\n+\t(btsq, btrq, btcq): New.  Add peepholes as well.\n+\t(movv4sf_internal splitter): Postpone til after reload.\n+\t(movv2di_internal splitter): Likewise.\n+\t* config/i386/predicates.md (const_0_to_63_operand): New.\n+\t(absneg_operator): New.\n+\n 2004-12-14  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* pa.h (REGNO_OK_FOR_INDEX_P, REGNO_OK_FOR_BASE_P, REGNO_OK_FOR_FP_P):\n@@ -53,8 +78,8 @@\n 2004-12-13  Richard Henderson  <rth@redhat.com>\n \n \tPR middle-end/17930\n-        * passes.c (rest_of_clean_state): Fix computation of\n-        preferred_incoming_stack_boundary.\n+\t* passes.c (rest_of_clean_state): Fix computation of\n+\tpreferred_incoming_stack_boundary.\n \n 2004-12-13  Wolfgang Bangerth <bangerth@dealii.org>\n "}, {"sha": "3ee9b2278c837b74a505de3510e92159f493ca10", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cacf53e505b9143b7ae0e646dc83a4e5cf9f643/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cacf53e505b9143b7ae0e646dc83a4e5cf9f643/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=7cacf53e505b9143b7ae0e646dc83a4e5cf9f643", "patch": "@@ -130,6 +130,8 @@ extern void ix86_expand_binary_operator (enum rtx_code,\n extern int ix86_binary_operator_ok (enum rtx_code, enum machine_mode, rtx[]);\n extern void ix86_expand_unary_operator (enum rtx_code, enum machine_mode,\n \t\t\t\t\trtx[]);\n+extern void ix86_expand_fp_absneg_operator (enum rtx_code, enum machine_mode,\n+\t\t\t\t\t    rtx[]);\n extern int ix86_unary_operator_ok (enum rtx_code, enum machine_mode, rtx[]);\n extern int ix86_match_ccmode (rtx, enum machine_mode);\n extern rtx ix86_expand_compare (enum rtx_code, rtx *, rtx *);"}, {"sha": "8819ba84bb0b6fa599a435fc4440c3c986ffb968", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 89, "deletions": 3, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cacf53e505b9143b7ae0e646dc83a4e5cf9f643/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cacf53e505b9143b7ae0e646dc83a4e5cf9f643/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7cacf53e505b9143b7ae0e646dc83a4e5cf9f643", "patch": "@@ -579,6 +579,7 @@ const int x86_ext_80387_constants = m_K6 | m_ATHLON | m_PENT4 | m_NOCONA | m_PPR\n    the 16 byte window.  */\n const int x86_four_jump_limit = m_PPRO | m_ATHLON_K8 | m_PENT4 | m_NOCONA;\n const int x86_schedule = m_PPRO | m_ATHLON_K8 | m_K6 | m_PENT;\n+const int x86_use_bt = m_ATHLON_K8;\n \n /* In case the average insn count for single function invocation is\n    lower than this constant, emit fast (but longer) prologue and\n@@ -7636,7 +7637,7 @@ ix86_expand_unary_operator (enum rtx_code code, enum machine_mode mode,\n   /* If the destination is memory, and we do not have matching source\n      operands, do things in registers.  */\n   matching_memory = 0;\n-  if (GET_CODE (dst) == MEM)\n+  if (MEM_P (dst))\n     {\n       if (rtx_equal_p (dst, src))\n \tmatching_memory = 1;\n@@ -7645,10 +7646,10 @@ ix86_expand_unary_operator (enum rtx_code code, enum machine_mode mode,\n     }\n \n   /* When source operand is memory, destination must match.  */\n-  if (!matching_memory && GET_CODE (src) == MEM)\n+  if (MEM_P (src) && !matching_memory)\n     src = force_reg (mode, src);\n \n-  /* If optimizing, copy to regs to improve CSE */\n+  /* If optimizing, copy to regs to improve CSE.  */\n   if (optimize && ! no_new_pseudos)\n     {\n       if (GET_CODE (dst) == MEM)\n@@ -7695,6 +7696,91 @@ ix86_unary_operator_ok (enum rtx_code code ATTRIBUTE_UNUSED,\n   return TRUE;\n }\n \n+/* Generate code for floating point ABS or NEG.  */\n+\n+void\n+ix86_expand_fp_absneg_operator (enum rtx_code code, enum machine_mode mode,\n+\t\t\t\trtx operands[])\n+{\n+  rtx mask, set, use, clob, dst, src;\n+  bool matching_memory;\n+  bool use_sse = false;\n+\n+  if (TARGET_SSE_MATH)\n+    {\n+      if (mode == SFmode)\n+\tuse_sse = true;\n+      else if (mode == DFmode && TARGET_SSE2)\n+\tuse_sse = true;\n+    }\n+\n+  /* NEG and ABS performed with SSE use bitwise mask operations.\n+     Create the appropriate mask now.  */\n+  if (use_sse)\n+    {\n+      HOST_WIDE_INT hi, lo;\n+      int shift = 63;\n+\n+      /* Find the sign bit, sign extended to 2*HWI.  */\n+      if (mode == SFmode)\n+        lo = 0x80000000, hi = lo < 0;\n+      else if (HOST_BITS_PER_WIDE_INT >= 64)\n+        lo = (HOST_WIDE_INT)1 << shift, hi = -1;\n+      else\n+        lo = 0, hi = (HOST_WIDE_INT)1 << (shift - HOST_BITS_PER_WIDE_INT);\n+\n+      /* If we're looking for the absolute value, then we want\n+\t the compliment.  */\n+      if (code == ABS)\n+        lo = ~lo, hi = ~hi;\n+\n+      /* Force this value into the low part of a fp vector constant.  */\n+      mask = immed_double_const (lo, hi, mode == SFmode ? SImode : DImode);\n+      mask = gen_lowpart (mode, mask);\n+      if (mode == SFmode)\n+        mask = gen_rtx_CONST_VECTOR (V4SFmode,\n+\t\t\t\t     gen_rtvec (4, mask, CONST0_RTX (SFmode),\n+\t\t\t\t\t\tCONST0_RTX (SFmode),\n+\t\t\t\t\t\tCONST0_RTX (SFmode)));\n+      else\n+        mask = gen_rtx_CONST_VECTOR (V2DFmode,\n+\t\t\t\t     gen_rtvec (2, mask, CONST0_RTX (DFmode)));\n+      mask = force_reg (GET_MODE (mask), mask);\n+    }\n+  else\n+    {\n+      /* When not using SSE, we don't use the mask, but prefer to keep the\n+\t same general form of the insn pattern to reduce duplication when\n+\t it comes time to split.  */\n+      mask = const0_rtx;\n+    }\n+\n+  dst = operands[0];\n+  src = operands[1];\n+\n+  /* If the destination is memory, and we don't have matching source\n+     operands, do things in registers.  */\n+  matching_memory = false;\n+  if (MEM_P (dst))\n+    {\n+      if (rtx_equal_p (dst, src) && (!optimize || no_new_pseudos))\n+\tmatching_memory = true;\n+      else\n+\tdst = gen_reg_rtx (mode);\n+    }\n+  if (MEM_P (src) && !matching_memory)\n+    src = force_reg (mode, src);\n+\n+  set = gen_rtx_fmt_e (code, mode, src);\n+  set = gen_rtx_SET (VOIDmode, dst, set);\n+  use = gen_rtx_USE (VOIDmode, mask);\n+  clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n+  emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (3, set, use, clob)));\n+\n+  if (dst != operands[0])\n+    emit_move_insn (operands[0], dst);\n+}\n+\n /* Return TRUE or FALSE depending on whether the first SET in INSN\n    has source and destination with matching CC modes, and that the\n    CC mode is at least as constrained as REQ_MODE.  */"}, {"sha": "a16f3084268938dfed5237de0a3b00aac9f89b6f", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cacf53e505b9143b7ae0e646dc83a4e5cf9f643/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cacf53e505b9143b7ae0e646dc83a4e5cf9f643/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=7cacf53e505b9143b7ae0e646dc83a4e5cf9f643", "patch": "@@ -247,6 +247,7 @@ extern const int x86_sse_partial_reg_dependency, x86_sse_partial_regs;\n extern const int x86_sse_typeless_stores, x86_sse_load0_by_pxor;\n extern const int x86_use_ffreep, x86_sse_partial_regs_for_cvtsd2ss;\n extern const int x86_inter_unit_moves, x86_schedule;\n+extern const int x86_use_bt;\n extern int x86_prefetch_sse;\n \n #define TARGET_USE_LEAVE (x86_use_leave & TUNEMASK)\n@@ -302,6 +303,7 @@ extern int x86_prefetch_sse;\n #define TARGET_INTER_UNIT_MOVES (x86_inter_unit_moves & TUNEMASK)\n #define TARGET_FOUR_JUMP_LIMIT (x86_four_jump_limit & TUNEMASK)\n #define TARGET_SCHEDULE (x86_schedule & TUNEMASK)\n+#define TARGET_USE_BT (x86_use_bt & TUNEMASK)\n \n #define TARGET_STACK_PROBE (target_flags & MASK_STACK_PROBE)\n "}, {"sha": "9b4b490fc91baceb661953b768b7620ac5c31a87", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 379, "deletions": 658, "changes": 1037, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cacf53e505b9143b7ae0e646dc83a4e5cf9f643/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cacf53e505b9143b7ae0e646dc83a4e5cf9f643/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=7cacf53e505b9143b7ae0e646dc83a4e5cf9f643", "patch": "@@ -9560,350 +9560,265 @@\n ;; Changing of sign for FP values is doable using integer unit too.\n \n (define_expand \"negsf2\"\n-  [(parallel [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n-\t\t   (neg:SF (match_operand:SF 1 \"nonimmediate_operand\" \"\")))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_80387\"\n-  \"if (TARGET_SSE)\n-     {\n-       /* In case operand is in memory,  we will not use SSE.  */\n-       if (memory_operand (operands[0], VOIDmode)\n-\t   && rtx_equal_p (operands[0], operands[1]))\n-\t emit_insn (gen_negsf2_memory (operands[0], operands[1]));\n-       else\n-\t{\n-\t  /* Using SSE is tricky, since we need bitwise negation of -0\n-\t     in register.  */\n-\t  rtx reg = gen_reg_rtx (SFmode);\n-\t  rtx dest = operands[0];\n-\t  rtx imm = gen_lowpart (SFmode, gen_int_mode (0x80000000, SImode));\n-\n-\t  operands[1] = force_reg (SFmode, operands[1]);\n-\t  operands[0] = force_reg (SFmode, operands[0]);\n-\t  reg = force_reg (V4SFmode,\n-\t\t\t   gen_rtx_CONST_VECTOR (V4SFmode,\n-\t\t\t     gen_rtvec (4, imm, CONST0_RTX (SFmode),\n-\t\t\t\t\tCONST0_RTX (SFmode),\n-\t\t\t\t\tCONST0_RTX (SFmode))));\n-\t  emit_insn (gen_negsf2_ifs (operands[0], operands[1], reg));\n-\t  if (dest != operands[0])\n-\t    emit_move_insn (dest, operands[0]);\n-\t}\n-       DONE;\n-     }\n-   ix86_expand_unary_operator (NEG, SFmode, operands); DONE;\")\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n+\t(neg:SF (match_operand:SF 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_80387 || TARGET_SSE_MATH\"\n+  \"ix86_expand_fp_absneg_operator (NEG, SFmode, operands); DONE;\")\n \n-(define_insn \"negsf2_memory\"\n-  [(set (match_operand:SF 0 \"memory_operand\" \"=m\")\n-\t(neg:SF (match_operand:SF 1 \"memory_operand\" \"0\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_unary_operator_ok (NEG, SFmode, operands)\"\n-  \"#\")\n+(define_expand \"abssf2\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n+\t(abs:SF (match_operand:SF 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_80387 || TARGET_SSE_MATH\"\n+  \"ix86_expand_fp_absneg_operator (ABS, SFmode, operands); DONE;\")\n \n-(define_insn \"negsf2_ifs\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=x#fr,x#fr,f#xr,rm#xf\")\n-\t(neg:SF (match_operand:SF 1 \"nonimmediate_operand\" \"0,x#fr,0,0\")))\n-   (use (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm,0,xm*r,xm*r\"))\n+(define_insn \"*absnegsf2_mixed\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\"    \"=x#fr,x#fr,f#xr,rm#xf\")\n+\t(match_operator:SF 3 \"absneg_operator\"\n+\t  [(match_operand:SF 1 \"nonimmediate_operand\" \"0    ,x#fr,0   ,0\")]))\n+   (use (match_operand:V4SF 2 \"nonimmediate_operand\"  \"xm   ,0   ,X   ,X\"))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_SSE\n-   && (reload_in_progress || reload_completed\n-       || (register_operand (operands[0], VOIDmode)\n-\t   && register_operand (operands[1], VOIDmode)))\"\n+  \"TARGET_SSE_MATH && TARGET_MIX_SSE_I387\n+   && ix86_unary_operator_ok (GET_CODE (operands[3]), SFmode, operands)\"\n   \"#\")\n \n-(define_split\n-  [(set (match_operand:SF 0 \"memory_operand\" \"\")\n-\t(neg:SF (match_operand:SF 1 \"memory_operand\" \"\")))\n-   (use (match_operand:SF 2 \"\" \"\"))\n+(define_insn \"*absnegsf2_sse\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\"    \"=x#r,x#r,rm#x\")\n+\t(match_operator:SF 3 \"absneg_operator\"\n+\t  [(match_operand:SF 1 \"nonimmediate_operand\" \"0   ,x#r,0\")]))\n+   (use (match_operand:V4SF 2 \"nonimmediate_operand\"  \"xm  ,0  ,X\"))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (neg:SF (match_dup 1)))\n-\t      (clobber (reg:CC FLAGS_REG))])])\n-\n-(define_split\n-  [(set (match_operand:SF 0 \"register_operand\" \"\")\n-\t(neg:SF (match_operand:SF 1 \"register_operand\" \"\")))\n-   (use (match_operand:V4SF 2 \"\" \"\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed && !SSE_REG_P (operands[0])\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (neg:SF (match_dup 1)))\n-\t      (clobber (reg:CC FLAGS_REG))])])\n-\n-(define_split\n-  [(set (match_operand:SF 0 \"register_operand\" \"\")\n-\t(neg:SF (match_operand:SF 1 \"register_operand\" \"\")))\n-   (use (match_operand:V4SF 2 \"nonimmediate_operand\" \"\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed && SSE_REG_P (operands[0])\"\n-  [(set (match_dup 0)\n-\t(xor:V4SF (match_dup 1)\n-\t\t  (match_dup 2)))]\n-{\n-  operands[0] = simplify_gen_subreg (V4SFmode, operands[0], SFmode, 0);\n-  operands[1] = simplify_gen_subreg (V4SFmode, operands[1], SFmode, 0);\n-  if (operands_match_p (operands[0], operands[2]))\n-    {\n-      rtx tmp;\n-      tmp = operands[1];\n-      operands[1] = operands[2];\n-      operands[2] = tmp;\n-    }\n-})\n-\n+  \"TARGET_SSE_MATH\n+   && ix86_unary_operator_ok (GET_CODE (operands[3]), SFmode, operands)\"\n+  \"#\")\n \n-;; Keep 'f' and 'r' in separate alternatives to avoid reload problems\n-;; because of secondary memory needed to reload from class FLOAT_INT_REGS\n-;; to itself.\n-(define_insn \"*negsf2_if\"\n+(define_insn \"*absnegsf2_i387\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f#r,rm#f\")\n-\t(neg:SF (match_operand:SF 1 \"nonimmediate_operand\" \"0,0\")))\n+\t(match_operator:SF 3 \"absneg_operator\"\n+\t  [(match_operand:SF 1 \"nonimmediate_operand\" \"0,0\")]))\n+   (use (match_operand 2 \"\" \"\"))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_80387 && !TARGET_SSE\n-   && ix86_unary_operator_ok (NEG, SFmode, operands)\"\n+  \"TARGET_80387 && !TARGET_SSE_MATH\n+   && ix86_unary_operator_ok (GET_CODE (operands[3]), SFmode, operands)\"\n   \"#\")\n \n-(define_split\n-  [(set (match_operand:SF 0 \"fp_register_operand\" \"\")\n-\t(neg:SF (match_operand:SF 1 \"register_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_80387 && reload_completed\"\n-  [(set (match_dup 0)\n-\t(neg:SF (match_dup 1)))]\n-  \"\")\n-\n-(define_split\n-  [(set (match_operand:SF 0 \"register_and_not_fp_reg_operand\" \"\")\n-\t(neg:SF (match_operand:SF 1 \"register_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_80387 && reload_completed\"\n-  [(parallel [(set (match_dup 0) (xor:SI (match_dup 0) (match_dup 1)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[1] = gen_int_mode (0x80000000, SImode);\n-   operands[0] = gen_lowpart (SImode, operands[0]);\")\n-\n-(define_split\n-  [(set (match_operand 0 \"memory_operand\" \"\")\n-\t(neg (match_operand 1 \"memory_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_80387 && reload_completed && FLOAT_MODE_P (GET_MODE (operands[0]))\"\n-  [(parallel [(set (match_dup 0) (xor:QI (match_dup 0) (match_dup 1)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-{\n-  int size = GET_MODE_SIZE (GET_MODE (operands[1]));\n-\n-  if (GET_MODE (operands[1]) == XFmode)\n-    size = 10;\n-  operands[0] = adjust_address (operands[0], QImode, size - 1);\n-  operands[1] = gen_int_mode (0x80, QImode);\n-})\n-\n (define_expand \"negdf2\"\n-  [(parallel [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n-\t\t   (neg:DF (match_operand:DF 1 \"nonimmediate_operand\" \"\")))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_80387\"\n-  \"if (TARGET_SSE2)\n-     {\n-       /* In case operand is in memory,  we will not use SSE.  */\n-       if (memory_operand (operands[0], VOIDmode)\n-\t   && rtx_equal_p (operands[0], operands[1]))\n-\t emit_insn (gen_negdf2_memory (operands[0], operands[1]));\n-       else\n-\t{\n-\t  /* Using SSE is tricky, since we need bitwise negation of -0\n-\t     in register.  */\n-\t  rtx reg;\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-\t  rtx imm = gen_int_mode (((HOST_WIDE_INT)1) << 63, DImode);\n-#else\n-\t  rtx imm = immed_double_const (0, 0x80000000, DImode);\n-#endif\n-\t  rtx dest = operands[0];\n-\n-\t  operands[1] = force_reg (DFmode, operands[1]);\n-\t  operands[0] = force_reg (DFmode, operands[0]);\n-\t  imm = gen_lowpart (DFmode, imm);\n-\t  reg = force_reg (V2DFmode,\n-\t\t\t   gen_rtx_CONST_VECTOR (V2DFmode,\n-\t\t\t     gen_rtvec (2, imm, CONST0_RTX (DFmode))));\n-\t  emit_insn (gen_negdf2_ifs (operands[0], operands[1], reg));\n-\t  if (dest != operands[0])\n-\t    emit_move_insn (dest, operands[0]);\n-\t}\n-       DONE;\n-     }\n-   ix86_expand_unary_operator (NEG, DFmode, operands); DONE;\")\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n+\t(neg:DF (match_operand:DF 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_80387 || (TARGET_SSE2 && TARGET_SSE_MATH)\"\n+  \"ix86_expand_fp_absneg_operator (NEG, DFmode, operands); DONE;\")\n \n-(define_insn \"negdf2_memory\"\n-  [(set (match_operand:DF 0 \"memory_operand\" \"=m\")\n-\t(neg:DF (match_operand:DF 1 \"memory_operand\" \"0\")))\n+(define_expand \"absdf2\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n+\t(abs:DF (match_operand:DF 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_80387 || (TARGET_SSE2 && TARGET_SSE_MATH)\"\n+  \"ix86_expand_fp_absneg_operator (ABS, DFmode, operands); DONE;\")\n+\n+(define_insn \"*absnegdf2_mixed\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\"    \"=Y#fr,Y#fr,f#Yr,rm#Yf\")\n+\t(match_operator:DF 3 \"absneg_operator\"\n+\t  [(match_operand:DF 1 \"nonimmediate_operand\" \"0    ,Y#fr,0   ,0\")]))\n+   (use (match_operand:V2DF 2 \"nonimmediate_operand\"  \"Ym   ,0   ,X   ,X\"))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_unary_operator_ok (NEG, DFmode, operands)\"\n+  \"TARGET_SSE2 && TARGET_SSE_MATH && TARGET_MIX_SSE_I387\n+   && ix86_unary_operator_ok (GET_CODE (operands[3]), DFmode, operands)\"\n   \"#\")\n \n-(define_insn \"negdf2_ifs\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=Y#fr,Y#fr,f#Yr,rm#Yf\")\n-\t(neg:DF (match_operand:DF 1 \"nonimmediate_operand\" \"0,Y#fr,0,0\")))\n-   (use (match_operand:V2DF 2 \"nonimmediate_operand\" \"Ym,0,Ym*r,Ym*r\"))\n+(define_insn \"*absnegdf2_sse\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\"    \"=Y#r,Y#r,rm#Y\")\n+\t(match_operator:DF 3 \"absneg_operator\"\n+\t  [(match_operand:DF 1 \"nonimmediate_operand\" \"0   ,Y#r,0\")]))\n+   (use (match_operand:V2DF 2 \"nonimmediate_operand\"  \"Ym  ,0  ,X\"))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && TARGET_SSE2\n-   && (reload_in_progress || reload_completed\n-       || (register_operand (operands[0], VOIDmode)\n-\t   && register_operand (operands[1], VOIDmode)))\"\n+  \"TARGET_SSE2 && TARGET_SSE_MATH\n+   && ix86_unary_operator_ok (GET_CODE (operands[3]), DFmode, operands)\"\n   \"#\")\n \n-(define_insn \"*negdf2_ifs_rex64\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=Y#f,Y#f,fm#Y\")\n-\t(neg:DF (match_operand:DF 1 \"nonimmediate_operand\" \"0,Y#fr,0\")))\n-   (use (match_operand:V2DF 2 \"nonimmediate_operand\" \"Ym,0,Ym*r\"))\n+(define_insn \"*absnegdf2_i387\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f#r,rm#f\")\n+\t(match_operator:DF 3 \"absneg_operator\"\n+\t  [(match_operand:DF 1 \"nonimmediate_operand\" \"0,0\")]))\n+   (use (match_operand 2 \"\" \"\"))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && TARGET_SSE2\n-   && (reload_in_progress || reload_completed\n-       || (register_operand (operands[0], VOIDmode)\n-\t   && register_operand (operands[1], VOIDmode)))\"\n+  \"TARGET_80387 && !(TARGET_SSE2 && TARGET_SSE_MATH)\n+   && ix86_unary_operator_ok (GET_CODE (operands[3]), DFmode, operands)\"\n   \"#\")\n \n-(define_split\n-  [(set (match_operand:DF 0 \"memory_operand\" \"\")\n-\t(neg:DF (match_operand:DF 1 \"memory_operand\" \"\")))\n-   (use (match_operand:V2DF 2 \"\" \"\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (neg:DF (match_dup 1)))\n-\t      (clobber (reg:CC FLAGS_REG))])])\n+(define_expand \"negxf2\"\n+  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"\")\n+\t(neg:XF (match_operand:XF 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_80387\"\n+  \"ix86_expand_fp_absneg_operator (NEG, XFmode, operands); DONE;\")\n \n-(define_split\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-\t(neg:DF (match_operand:DF 1 \"register_operand\" \"\")))\n-   (use (match_operand:V2DF 2 \"\" \"\"))\n+(define_expand \"absxf2\"\n+  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"\")\n+\t(neg:XF (match_operand:XF 1 \"nonimmediate_operand\" \"\")))]\n+  \"TARGET_80387\"\n+  \"ix86_expand_fp_absneg_operator (ABS, XFmode, operands); DONE;\")\n+\n+(define_insn \"*absnegxf2_i387\"\n+  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f#r,rm#f\")\n+\t(match_operator:XF 3 \"absneg_operator\"\n+\t  [(match_operand:XF 1 \"nonimmediate_operand\" \"0,0\")]))\n+   (use (match_operand 2 \"\" \"\"))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed && !SSE_REG_P (operands[0])\n-   && (!TARGET_64BIT || FP_REG_P (operands[0]))\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (neg:DF (match_dup 1)))\n-\t      (clobber (reg:CC FLAGS_REG))])])\n+  \"TARGET_80387\n+   && ix86_unary_operator_ok (GET_CODE (operands[3]), XFmode, operands)\"\n+  \"#\")\n+\n+;; Splitters for fp abs and neg.\n \n (define_split\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-\t(neg:DF (match_operand:DF 1 \"register_operand\" \"\")))\n-   (use (match_operand:V2DF 2 \"\" \"\"))\n+  [(set (match_operand 0 \"fp_register_operand\" \"\")\n+\t(match_operator 1 \"absneg_operator\" [(match_dup 0)]))\n+   (use (match_operand 2 \"\" \"\"))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && reload_completed && GENERAL_REG_P (operands[0])\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (xor:DI (match_dup 1) (match_dup 2)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-   \"operands[0] = gen_lowpart (DImode, operands[0]);\n-    operands[1] = gen_lowpart (DImode, operands[1]);\n-    operands[2] = gen_lowpart (DImode, operands[2]);\")\n+  \"reload_completed\"\n+  [(set (match_dup 0) (match_op_dup 1 [(match_dup 0)]))])\n \n (define_split\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-\t(neg:DF (match_operand:DF 1 \"register_operand\" \"\")))\n-   (use (match_operand:V2DF 2 \"nonimmediate_operand\" \"\"))\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(match_operator 3 \"absneg_operator\"\n+\t  [(match_operand 1 \"register_operand\" \"\")]))\n+   (use (match_operand 2 \"nonimmediate_operand\" \"\"))\n    (clobber (reg:CC FLAGS_REG))]\n   \"reload_completed && SSE_REG_P (operands[0])\"\n-  [(set (match_dup 0)\n-\t(xor:V2DF (match_dup 1)\n-\t\t  (match_dup 2)))]\n+  [(set (match_dup 0) (match_dup 3))]\n {\n-  operands[0] = simplify_gen_subreg (V2DFmode, operands[0], DFmode, 0);\n-  operands[1] = simplify_gen_subreg (V2DFmode, operands[1], DFmode, 0);\n-  /* Avoid possible reformatting on the operands.  */\n-  if (TARGET_SSE_PARTIAL_REGS && !optimize_size)\n-    emit_insn (gen_sse2_unpcklpd (operands[0], operands[0], operands[0]));\n+  enum machine_mode mode = GET_MODE (operands[0]);\n+  enum machine_mode vmode = GET_MODE (operands[2]);\n+  rtx tmp;\n+  \n+  operands[0] = simplify_gen_subreg (vmode, operands[0], mode, 0);\n+  operands[1] = simplify_gen_subreg (vmode, operands[1], mode, 0);\n   if (operands_match_p (operands[0], operands[2]))\n     {\n-      rtx tmp;\n       tmp = operands[1];\n       operands[1] = operands[2];\n       operands[2] = tmp;\n     }\n+  if (GET_CODE (operands[3]) == ABS)\n+    tmp = gen_rtx_AND (vmode, operands[1], operands[2]);\n+  else\n+    tmp = gen_rtx_XOR (vmode, operands[1], operands[2]);\n+  operands[3] = tmp;\n })\n \n-;; Keep 'f' and 'r' in separate alternatives to avoid reload problems\n-;; because of secondary memory needed to reload from class FLOAT_INT_REGS\n-;; to itself.\n-(define_insn \"*negdf2_if\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f#r,rm#f\")\n-\t(neg:DF (match_operand:DF 1 \"nonimmediate_operand\" \"0,0\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && TARGET_80387\n-   && ix86_unary_operator_ok (NEG, DFmode, operands)\"\n-  \"#\")\n-\n-;; FIXME: We should to allow integer registers here.  Problem is that\n-;; we need another scratch register to get constant from.\n-;; Forcing constant to mem if no register available in peep2 should be\n-;; safe even for PIC mode, because of RIP relative addressing.\n-(define_insn \"*negdf2_if_rex64\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,mf\")\n-\t(neg:DF (match_operand:DF 1 \"nonimmediate_operand\" \"0,0\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && TARGET_80387\n-   && ix86_unary_operator_ok (NEG, DFmode, operands)\"\n-  \"#\")\n-\n (define_split\n-  [(set (match_operand:DF 0 \"fp_register_operand\" \"\")\n-\t(neg:DF (match_operand:DF 1 \"register_operand\" \"\")))\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(match_operator:SF 1 \"absneg_operator\" [(match_dup 0)]))\n+   (use (match_operand:V4SF 2 \"\" \"\"))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_80387 && reload_completed\"\n-  [(set (match_dup 0)\n-\t(neg:DF (match_dup 1)))]\n-  \"\")\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (match_dup 1))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+{ \n+  rtx tmp;\n+  operands[0] = gen_lowpart (SImode, operands[0]);\n+  if (GET_CODE (operands[1]) == ABS)\n+    {\n+      tmp = gen_int_mode (0x7fffffff, SImode);\n+      tmp = gen_rtx_AND (SImode, operands[0], tmp);\n+    }\n+  else\n+    {\n+      tmp = gen_int_mode (0x80000000, SImode);\n+      tmp = gen_rtx_XOR (SImode, operands[0], tmp);\n+    }\n+  operands[1] = tmp;\n+})\n \n (define_split\n-  [(set (match_operand:DF 0 \"register_and_not_fp_reg_operand\" \"\")\n-\t(neg:DF (match_operand:DF 1 \"register_operand\" \"\")))\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(match_operator:DF 1 \"absneg_operator\" [(match_dup 0)]))\n+   (use (match_operand 2 \"\" \"\"))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && TARGET_80387 && reload_completed\"\n-  [(parallel [(set (match_dup 3) (xor:SI (match_dup 3) (match_dup 4)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[4] = gen_int_mode (0x80000000, SImode);\n-   split_di (operands+0, 1, operands+2, operands+3);\")\n-\n-(define_expand \"negxf2\"\n-  [(parallel [(set (match_operand:XF 0 \"nonimmediate_operand\" \"\")\n-\t\t   (neg:XF (match_operand:XF 1 \"nonimmediate_operand\" \"\")))\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (match_dup 1))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_80387\"\n-  \"ix86_expand_unary_operator (NEG, XFmode, operands); DONE;\")\n+{\n+  rtx tmp;\n+  if (TARGET_64BIT)\n+    {\n+      tmp = gen_lowpart (DImode, operands[0]);\n+      tmp = gen_rtx_ZERO_EXTRACT (DImode, tmp, const1_rtx, GEN_INT (63));\n+      operands[0] = tmp;\n \n-;; Keep 'f' and 'r' in separate alternatives to avoid reload problems\n-;; because of secondary memory needed to reload from class FLOAT_INT_REGS\n-;; to itself.\n-(define_insn \"*negxf2_if\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f#r,rm#f\")\n-\t(neg:XF (match_operand:XF 1 \"nonimmediate_operand\" \"0,0\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_80387\n-   && ix86_unary_operator_ok (NEG, XFmode, operands)\"\n-  \"#\")\n+      if (GET_CODE (operands[1]) == ABS)\n+\ttmp = const0_rtx;\n+      else\n+\ttmp = gen_rtx_NOT (DImode, tmp);\n+    }\n+  else\n+    {\n+      operands[0] = gen_highpart (SImode, operands[0]);\n+      if (GET_CODE (operands[1]) == ABS)\n+\t{\n+\t  tmp = gen_int_mode (0x7fffffff, SImode);\n+\t  tmp = gen_rtx_AND (SImode, operands[0], tmp);\n+\t}\n+      else\n+\t{\n+\t  tmp = gen_int_mode (0x80000000, SImode);\n+\t  tmp = gen_rtx_XOR (SImode, operands[0], tmp);\n+\t}\n+    }\n+  operands[1] = tmp;\n+})\n \n (define_split\n-  [(set (match_operand:XF 0 \"fp_register_operand\" \"\")\n-\t(neg:XF (match_operand:XF 1 \"register_operand\" \"\")))\n+  [(set (match_operand:XF 0 \"register_operand\" \"\")\n+\t(match_operator:XF 1 \"absneg_operator\" [(match_dup 0)]))\n+   (use (match_operand 2 \"\" \"\"))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_80387 && reload_completed\"\n-  [(set (match_dup 0)\n-\t(neg:XF (match_dup 1)))]\n-  \"\")\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (match_dup 1))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+{\n+  rtx tmp;\n+  operands[0] = gen_rtx_REG (SImode,\n+\t\t\t     true_regnum (operands[0])\n+\t\t\t     + (TARGET_64BIT ? 1 : 2));\n+  if (GET_CODE (operands[1]) == ABS)\n+    {\n+      tmp = GEN_INT (0x7fff);\n+      tmp = gen_rtx_AND (SImode, operands[0], tmp);\n+    }\n+  else\n+    {\n+      tmp = GEN_INT (0x8000);\n+      tmp = gen_rtx_XOR (SImode, operands[0], tmp);\n+    }\n+  operands[1] = tmp;\n+})\n \n (define_split\n-  [(set (match_operand:XF 0 \"register_and_not_fp_reg_operand\" \"\")\n-\t(neg:XF (match_operand:XF 1 \"register_operand\" \"\")))\n+  [(set (match_operand 0 \"memory_operand\" \"\")\n+\t(match_operator 1 \"absneg_operator\" [(match_dup 0)]))\n+   (use (match_operand 2 \"\" \"\"))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_80387 && reload_completed\"\n-  [(parallel [(set (match_dup 0) (xor:SI (match_dup 0) (match_dup 1)))\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (match_dup 1))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[1] = GEN_INT (0x8000);\n-   operands[0] = gen_rtx_REG (SImode,\n-\t\t\t      true_regnum (operands[0]) + (TARGET_64BIT ? 1 : 2));\")\n+{\n+  enum machine_mode mode = GET_MODE (operands[0]);\n+  int size = mode == XFmode ? 10 : GET_MODE_SIZE (mode);\n+  rtx tmp;\n+\n+  operands[0] = adjust_address (operands[0], QImode, size - 1);\n+  if (GET_CODE (operands[1]) == ABS)\n+    {\n+      tmp = gen_int_mode (0x7f, QImode);\n+      tmp = gen_rtx_AND (QImode, operands[0], tmp);\n+    }\n+  else\n+    {\n+      tmp = gen_int_mode (0x80, QImode);\n+      tmp = gen_rtx_XOR (QImode, operands[0], tmp);\n+    }\n+  operands[1] = tmp;\n+})\n \n-;; Conditionalize these after reload. If they matches before reload, we \n+;; Conditionalize these after reload. If they match before reload, we \n ;; lose the clobber and ability to use integer instructions.\n \n (define_insn \"*negsf2_1\"\n@@ -9922,22 +9837,46 @@\n   [(set_attr \"type\" \"fsgn\")\n    (set_attr \"mode\" \"DF\")])\n \n-(define_insn \"*negextendsfdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(neg:DF (float_extend:DF\n-\t\t  (match_operand:SF 1 \"register_operand\" \"0\"))))]\n-  \"TARGET_80387\"\n+(define_insn \"*negxf2_1\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n+\t(neg:XF (match_operand:XF 1 \"register_operand\" \"0\")))]\n+  \"TARGET_80387 && reload_completed\"\n   \"fchs\"\n+  [(set_attr \"type\" \"fsgn\")\n+   (set_attr \"mode\" \"XF\")])\n+\n+(define_insn \"*abssf2_1\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(abs:SF (match_operand:SF 1 \"register_operand\" \"0\")))]\n+  \"TARGET_80387 && reload_completed\"\n+  \"fabs\"\n+  [(set_attr \"type\" \"fsgn\")\n+   (set_attr \"mode\" \"SF\")])\n+\n+(define_insn \"*absdf2_1\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(abs:DF (match_operand:DF 1 \"register_operand\" \"0\")))]\n+  \"TARGET_80387 && reload_completed\"\n+  \"fabs\"\n   [(set_attr \"type\" \"fsgn\")\n    (set_attr \"mode\" \"DF\")])\n \n-(define_insn \"*negxf2_1\"\n+(define_insn \"*absxf2_1\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n-\t(neg:XF (match_operand:XF 1 \"register_operand\" \"0\")))]\n+\t(abs:XF (match_operand:XF 1 \"register_operand\" \"0\")))]\n   \"TARGET_80387 && reload_completed\"\n+  \"fabs\"\n+  [(set_attr \"type\" \"fsgn\")\n+   (set_attr \"mode\" \"DF\")])\n+\n+(define_insn \"*negextendsfdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(neg:DF (float_extend:DF\n+\t\t  (match_operand:SF 1 \"register_operand\" \"0\"))))]\n+  \"TARGET_80387 && (!TARGET_SSE_MATH || TARGET_MIX_SSE_I387)\"\n   \"fchs\"\n   [(set_attr \"type\" \"fsgn\")\n-   (set_attr \"mode\" \"XF\")])\n+   (set_attr \"mode\" \"DF\")])\n \n (define_insn \"*negextenddfxf2\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n@@ -9956,370 +9895,12 @@\n   \"fchs\"\n   [(set_attr \"type\" \"fsgn\")\n    (set_attr \"mode\" \"XF\")])\n-\f\n-;; Absolute value instructions\n-\n-(define_expand \"abssf2\"\n-  [(parallel [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n-\t\t   (neg:SF (match_operand:SF 1 \"nonimmediate_operand\" \"\")))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_80387\"\n-  \"if (TARGET_SSE)\n-     {\n-       /* In case operand is in memory,  we will not use SSE.  */\n-       if (memory_operand (operands[0], VOIDmode)\n-\t   && rtx_equal_p (operands[0], operands[1]))\n-\t emit_insn (gen_abssf2_memory (operands[0], operands[1]));\n-       else\n-\t{\n-\t  /* Using SSE is tricky, since we need bitwise negation of -0\n-\t     in register.  */\n-\t  rtx reg = gen_reg_rtx (V4SFmode);\n-\t  rtx dest = operands[0];\n-\t  rtx imm;\n-\n-\t  operands[1] = force_reg (SFmode, operands[1]);\n-\t  operands[0] = force_reg (SFmode, operands[0]);\n-\t  imm = gen_lowpart (SFmode, gen_int_mode(~0x80000000, SImode));\n-\t  reg = force_reg (V4SFmode,\n-\t\t\t   gen_rtx_CONST_VECTOR (V4SFmode,\n-\t\t\t   gen_rtvec (4, imm, CONST0_RTX (SFmode),\n-\t\t\t\t      CONST0_RTX (SFmode),\n-\t\t\t\t      CONST0_RTX (SFmode))));\n-\t  emit_insn (gen_abssf2_ifs (operands[0], operands[1], reg));\n-\t  if (dest != operands[0])\n-\t    emit_move_insn (dest, operands[0]);\n-\t}\n-       DONE;\n-     }\n-   ix86_expand_unary_operator (ABS, SFmode, operands); DONE;\")\n-\n-(define_insn \"abssf2_memory\"\n-  [(set (match_operand:SF 0 \"memory_operand\" \"=m\")\n-\t(abs:SF (match_operand:SF 1 \"memory_operand\" \"0\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_unary_operator_ok (ABS, SFmode, operands)\"\n-  \"#\")\n-\n-(define_insn \"abssf2_ifs\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=x#fr,x#fr,f#xr,rm#xf\")\n-\t(abs:SF (match_operand:SF 1 \"nonimmediate_operand\" \"0,x#fr,0,0\")))\n-   (use (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm,0,xm*r,xm*r\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_SSE\n-   && (reload_in_progress || reload_completed\n-       || (register_operand (operands[0], VOIDmode)\n-\t    && register_operand (operands[1], VOIDmode)))\"\n-  \"#\")\n-\n-(define_split\n-  [(set (match_operand:SF 0 \"memory_operand\" \"\")\n-\t(abs:SF (match_operand:SF 1 \"memory_operand\" \"\")))\n-   (use (match_operand:V4SF 2 \"\" \"\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (abs:SF (match_dup 1)))\n-\t      (clobber (reg:CC FLAGS_REG))])])\n-\n-(define_split\n-  [(set (match_operand:SF 0 \"register_operand\" \"\")\n-\t(abs:SF (match_operand:SF 1 \"register_operand\" \"\")))\n-   (use (match_operand:V4SF 2 \"\" \"\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed && !SSE_REG_P (operands[0])\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (abs:SF (match_dup 1)))\n-\t      (clobber (reg:CC FLAGS_REG))])])\n-\n-(define_split\n-  [(set (match_operand:SF 0 \"register_operand\" \"\")\n-\t(abs:SF (match_operand:SF 1 \"register_operand\" \"\")))\n-   (use (match_operand:V4SF 2 \"nonimmediate_operand\" \"\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed && SSE_REG_P (operands[0])\"\n-  [(set (match_dup 0)\n-\t(and:V4SF (match_dup 1)\n-\t\t  (match_dup 2)))]\n-{\n-  operands[0] = simplify_gen_subreg (V4SFmode, operands[0], SFmode, 0);\n-  operands[1] = simplify_gen_subreg (V4SFmode, operands[1], SFmode, 0);\n-  if (operands_match_p (operands[0], operands[2]))\n-    {\n-      rtx tmp;\n-      tmp = operands[1];\n-      operands[1] = operands[2];\n-      operands[2] = tmp;\n-    }\n-})\n-\n-;; Keep 'f' and 'r' in separate alternatives to avoid reload problems\n-;; because of secondary memory needed to reload from class FLOAT_INT_REGS\n-;; to itself.\n-(define_insn \"*abssf2_if\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f#r,rm#f\")\n-\t(abs:SF (match_operand:SF 1 \"nonimmediate_operand\" \"0,0\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_80387 && ix86_unary_operator_ok (ABS, SFmode, operands) && !TARGET_SSE\"\n-  \"#\")\n-\n-(define_split\n-  [(set (match_operand:SF 0 \"fp_register_operand\" \"\")\n-\t(abs:SF (match_operand:SF 1 \"register_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_80387 && reload_completed\"\n-  [(set (match_dup 0)\n-\t(abs:SF (match_dup 1)))]\n-  \"\")\n-\n-(define_split\n-  [(set (match_operand:SF 0 \"register_and_not_fp_reg_operand\" \"\")\n-\t(abs:SF (match_operand:SF 1 \"register_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_80387 && reload_completed\"\n-  [(parallel [(set (match_dup 0) (and:SI (match_dup 0) (match_dup 1)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[1] = gen_int_mode (~0x80000000, SImode);\n-   operands[0] = gen_lowpart (SImode, operands[0]);\")\n-\n-(define_split\n-  [(set (match_operand 0 \"memory_operand\" \"\")\n-\t(abs (match_operand 1 \"memory_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_80387 && reload_completed && FLOAT_MODE_P (GET_MODE (operands[0]))\"\n-  [(parallel [(set (match_dup 0) (and:QI (match_dup 0) (match_dup 1)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-{\n-  int size = GET_MODE_SIZE (GET_MODE (operands[1]));\n-\n-  if (GET_MODE (operands[1]) == XFmode)\n-    size = 10;\n-  operands[0] = adjust_address (operands[0], QImode, size - 1);\n-  operands[1] = gen_int_mode (~0x80, QImode);\n-})\n-\n-(define_expand \"absdf2\"\n-  [(parallel [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n-\t\t   (neg:DF (match_operand:DF 1 \"nonimmediate_operand\" \"\")))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_80387\"\n-  \"if (TARGET_SSE2)\n-     {\n-       /* In case operand is in memory,  we will not use SSE.  */\n-       if (memory_operand (operands[0], VOIDmode)\n-\t   && rtx_equal_p (operands[0], operands[1]))\n-\t emit_insn (gen_absdf2_memory (operands[0], operands[1]));\n-       else\n-\t{\n-\t  /* Using SSE is tricky, since we need bitwise negation of -0\n-\t     in register.  */\n-\t  rtx reg = gen_reg_rtx (V2DFmode);\n-#if HOST_BITS_PER_WIDE_INT >= 64\n-\t  rtx imm = gen_int_mode (~(((HOST_WIDE_INT)1) << 63), DImode);\n-#else\n-\t  rtx imm = immed_double_const (~0, ~0x80000000, DImode);\n-#endif\n-\t  rtx dest = operands[0];\n-\n-\t  operands[1] = force_reg (DFmode, operands[1]);\n-\t  operands[0] = force_reg (DFmode, operands[0]);\n-\n-\t  /* Produce LONG_DOUBLE with the proper immediate argument.  */\n-\t  imm = gen_lowpart (DFmode, imm);\n-\t  reg = force_reg (V2DFmode,\n-\t\t\t   gen_rtx_CONST_VECTOR (V2DFmode,\n-\t\t\t   gen_rtvec (2, imm, CONST0_RTX (DFmode))));\n-\t  emit_insn (gen_absdf2_ifs (operands[0], operands[1], reg));\n-\t  if (dest != operands[0])\n-\t    emit_move_insn (dest, operands[0]);\n-\t}\n-       DONE;\n-     }\n-   ix86_expand_unary_operator (ABS, DFmode, operands); DONE;\")\n-\n-(define_insn \"absdf2_memory\"\n-  [(set (match_operand:DF 0 \"memory_operand\" \"=m\")\n-\t(abs:DF (match_operand:DF 1 \"memory_operand\" \"0\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_unary_operator_ok (ABS, DFmode, operands)\"\n-  \"#\")\n-\n-(define_insn \"absdf2_ifs\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=Y#fr,Y#fr,mf#Yr,mr#Yf\")\n-\t(abs:DF (match_operand:DF 1 \"nonimmediate_operand\" \"0,Y#fr,0,0\")))\n-   (use (match_operand:V2DF 2 \"nonimmediate_operand\" \"Ym,0,Ym*r,Ym*r\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && TARGET_SSE2\n-   && (reload_in_progress || reload_completed\n-       || (register_operand (operands[0], VOIDmode)\n-\t   && register_operand (operands[1], VOIDmode)))\"\n-  \"#\")\n-\n-(define_insn \"*absdf2_ifs_rex64\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=Y#fr,Y#fr,mf#Yr\")\n-\t(abs:DF (match_operand:DF 1 \"nonimmediate_operand\" \"0,Y#fr,0\")))\n-   (use (match_operand:V2DF 2 \"nonimmediate_operand\" \"Ym,0,Ym*r\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && TARGET_SSE2\n-   && (reload_in_progress || reload_completed\n-       || (register_operand (operands[0], VOIDmode)\n-\t   && register_operand (operands[1], VOIDmode)))\"\n-  \"#\")\n-\n-(define_split\n-  [(set (match_operand:DF 0 \"memory_operand\" \"\")\n-\t(abs:DF (match_operand:DF 1 \"memory_operand\" \"\")))\n-   (use (match_operand:V2DF 2 \"\" \"\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (abs:DF (match_dup 1)))\n-\t      (clobber (reg:CC FLAGS_REG))])])\n-\n-(define_split\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-\t(abs:DF (match_operand:DF 1 \"register_operand\" \"\")))\n-   (use (match_operand:V2DF 2 \"\" \"\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed && !SSE_REG_P (operands[0])\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (abs:DF (match_dup 1)))\n-\t      (clobber (reg:CC FLAGS_REG))])])\n-\n-(define_split\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-\t(abs:DF (match_operand:DF 1 \"register_operand\" \"\")))\n-   (use (match_operand:V2DF 2 \"nonimmediate_operand\" \"\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"reload_completed && SSE_REG_P (operands[0])\"\n-  [(set (match_dup 0)\n-\t(and:V2DF (match_dup 1)\n-\t\t  (match_dup 2)))]\n-{\n-  operands[0] = simplify_gen_subreg (V2DFmode, operands[0], DFmode, 0);\n-  operands[1] = simplify_gen_subreg (V2DFmode, operands[1], DFmode, 0);\n-  /* Avoid possible reformatting on the operands.  */\n-  if (TARGET_SSE_PARTIAL_REGS && !optimize_size)\n-    emit_insn (gen_sse2_unpcklpd (operands[0], operands[0], operands[0]));\n-  if (operands_match_p (operands[0], operands[2]))\n-    {\n-      rtx tmp;\n-      tmp = operands[1];\n-      operands[1] = operands[2];\n-      operands[2] = tmp;\n-    }\n-})\n-\n-\n-;; Keep 'f' and 'r' in separate alternatives to avoid reload problems\n-;; because of secondary memory needed to reload from class FLOAT_INT_REGS\n-;; to itself.\n-(define_insn \"*absdf2_if\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f#r,rm#f\")\n-\t(abs:DF (match_operand:DF 1 \"nonimmediate_operand\" \"0,0\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && TARGET_80387\n-   && ix86_unary_operator_ok (ABS, DFmode, operands)\"\n-  \"#\")\n-\n-;; FIXME: We should to allow integer registers here.  Problem is that\n-;; we need another scratch register to get constant from.\n-;; Forcing constant to mem if no register available in peep2 should be\n-;; safe even for PIC mode, because of RIP relative addressing.\n-(define_insn \"*absdf2_if_rex64\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,mf\")\n-\t(abs:DF (match_operand:DF 1 \"nonimmediate_operand\" \"0,0\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && TARGET_80387\n-   && ix86_unary_operator_ok (ABS, DFmode, operands)\"\n-  \"#\")\n-\n-(define_split\n-  [(set (match_operand:DF 0 \"fp_register_operand\" \"\")\n-\t(abs:DF (match_operand:DF 1 \"register_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_80387 && reload_completed\"\n-  [(set (match_dup 0)\n-\t(abs:DF (match_dup 1)))]\n-  \"\")\n-\n-(define_split\n-  [(set (match_operand:DF 0 \"register_and_not_fp_reg_operand\" \"\")\n-\t(abs:DF (match_operand:DF 1 \"register_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && TARGET_80387 && reload_completed\"\n-  [(parallel [(set (match_dup 3) (and:SI (match_dup 3) (match_dup 4)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[4] = gen_int_mode (~0x80000000, SImode);\n-   split_di (operands+0, 1, operands+2, operands+3);\")\n-\n-(define_expand \"absxf2\"\n-  [(parallel [(set (match_operand:XF 0 \"nonimmediate_operand\" \"\")\n-\t\t   (neg:XF (match_operand:XF 1 \"nonimmediate_operand\" \"\")))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_80387\"\n-  \"ix86_expand_unary_operator (ABS, XFmode, operands); DONE;\")\n-\n-;; Keep 'f' and 'r' in separate alternatives to avoid reload problems\n-;; because of secondary memory needed to reload from class FLOAT_INT_REGS\n-;; to itself.\n-(define_insn \"*absxf2_if\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f#r,rm#f\")\n-\t(abs:XF (match_operand:XF 1 \"nonimmediate_operand\" \"0,0\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_80387\n-   && ix86_unary_operator_ok (ABS, XFmode, operands)\"\n-  \"#\")\n-\n-(define_split\n-  [(set (match_operand:XF 0 \"fp_register_operand\" \"\")\n-\t(abs:XF (match_operand:XF 1 \"register_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_80387 && reload_completed\"\n-  [(set (match_dup 0)\n-\t(abs:XF (match_dup 1)))]\n-  \"\")\n-\n-(define_split\n-  [(set (match_operand:XF 0 \"register_and_not_fp_reg_operand\" \"\")\n-\t(abs:XF (match_operand:XF 1 \"register_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_80387 && reload_completed\"\n-  [(parallel [(set (match_dup 0) (and:SI (match_dup 0) (match_dup 1)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[1] = GEN_INT (~0x8000);\n-   operands[0] = gen_rtx_REG (SImode,\n-\t\t\t      true_regnum (operands[0]) + (TARGET_64BIT ? 1 : 2));\")\n-\n-(define_insn \"*abssf2_1\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(abs:SF (match_operand:SF 1 \"register_operand\" \"0\")))]\n-  \"TARGET_80387 && reload_completed\"\n-  \"fabs\"\n-  [(set_attr \"type\" \"fsgn\")\n-   (set_attr \"mode\" \"SF\")])\n-\n-(define_insn \"*absdf2_1\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(abs:DF (match_operand:DF 1 \"register_operand\" \"0\")))]\n-  \"TARGET_80387 && reload_completed\"\n-  \"fabs\"\n-  [(set_attr \"type\" \"fsgn\")\n-   (set_attr \"mode\" \"DF\")])\n \n (define_insn \"*absextendsfdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(abs:DF (float_extend:DF\n \t\t  (match_operand:SF 1 \"register_operand\" \"0\"))))]\n-  \"TARGET_80387\"\n-  \"fabs\"\n-  [(set_attr \"type\" \"fsgn\")\n-   (set_attr \"mode\" \"DF\")])\n-\n-(define_insn \"*absxf2_1\"\n-  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n-\t(abs:XF (match_operand:XF 1 \"register_operand\" \"0\")))]\n-  \"TARGET_80387 && reload_completed\"\n+  \"TARGET_80387 && (!TARGET_SSE_MATH || TARGET_MIX_SSE_I387)\"\n   \"fabs\"\n   [(set_attr \"type\" \"fsgn\")\n    (set_attr \"mode\" \"DF\")])\n@@ -12625,6 +12206,146 @@\n })\n \n ;; %%% bts, btr, btc, bt.\n+;; In general these instructions are *slow* when applied to memory,\n+;; since they enforce atomic operation.  When applied to registers,\n+;; it depends on the cpu implementation.  They're never faster than\n+;; the corresponding and/ior/xor operations, so with 32-bit there's\n+;; no point.  But in 64-bit, we can't hold the relevant immediates\n+;; within the instruction itself, so operating on bits in the high\n+;; 32-bits of a register becomes easier.\n+;;\n+;; These are slow on Nocona, but fast on Athlon64.  We do require the use\n+;; of btrq and btcq for corner cases of post-reload expansion of absdf and\n+;; negdf respectively, so they can never be disabled entirely.\n+\n+(define_insn \"*btsq\"\n+  [(set (zero_extract:DI (match_operand 0 \"register_operand\" \"+r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand 1 \"const_0_to_63_operand\" \"\"))\n+\t(const_int 1))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && (TARGET_USE_BT || reload_completed)\"\n+  \"bts{q} %1,%0\"\n+  [(set_attr \"type\" \"alu1\")])\n+\n+(define_insn \"*btrq\"\n+  [(set (zero_extract:DI (match_operand 0 \"register_operand\" \"+r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand 1 \"const_0_to_63_operand\" \"\"))\n+\t(const_int 0))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && (TARGET_USE_BT || reload_completed)\"\n+  \"btr{q} %1,%0\"\n+  [(set_attr \"type\" \"alu1\")])\n+\n+(define_insn \"*btcq\"\n+  [(set (zero_extract:DI (match_operand 0 \"register_operand\" \"+r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand 1 \"const_0_to_63_operand\" \"\"))\n+\t(not:DI (zero_extract:DI (match_dup 0) (const_int 1) (match_dup 1))))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && (TARGET_USE_BT || reload_completed)\"\n+  \"btc{q} %1,%0\"\n+  [(set_attr \"type\" \"alu1\")])\n+\n+;; Allow Nocona to avoid these instructions if a register is available.\n+\n+(define_peephole2\n+  [(match_scratch:DI 2 \"r\")\n+   (parallel [(set (zero_extract:DI\n+\t\t     (match_operand 0 \"register_operand\" \"\")\n+\t\t     (const_int 1)\n+\t\t     (match_operand 1 \"const_0_to_63_operand\" \"\"))\n+\t\t   (const_int 1))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"TARGET_64BIT && !TARGET_USE_BT\"\n+  [(const_int 0)]\n+{\n+  HOST_WIDE_INT i = INTVAL (operands[1]), hi, lo;\n+  rtx op1;\n+\n+  if (HOST_BITS_PER_WIDE_INT >= 64)\n+    lo = (HOST_WIDE_INT)1 << i, hi = 0;\n+  else if (i < HOST_BITS_PER_WIDE_INT)\n+    lo = (HOST_WIDE_INT)1 << i, hi = 0;\n+  else\n+    lo = 0, hi = (HOST_WIDE_INT)1 << (i - HOST_BITS_PER_WIDE_INT);\n+\n+  op1 = immed_double_const (lo, hi, DImode);\n+  if (i >= 31)\n+    {\n+      emit_move_insn (operands[2], op1);\n+      op1 = operands[2];\n+    }\n+\n+  emit_insn (gen_iordi3 (operands[0], operands[0], op1));\n+  DONE;\n+})\n+\n+(define_peephole2\n+  [(match_scratch:DI 2 \"r\")\n+   (parallel [(set (zero_extract:DI\n+\t\t     (match_operand 0 \"register_operand\" \"\")\n+\t\t     (const_int 1)\n+\t\t     (match_operand 1 \"const_0_to_63_operand\" \"\"))\n+\t\t   (const_int 0))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"TARGET_64BIT && !TARGET_USE_BT\"\n+  [(const_int 0)]\n+{\n+  HOST_WIDE_INT i = INTVAL (operands[1]), hi, lo;\n+  rtx op1;\n+\n+  if (HOST_BITS_PER_WIDE_INT >= 64)\n+    lo = (HOST_WIDE_INT)1 << i, hi = 0;\n+  else if (i < HOST_BITS_PER_WIDE_INT)\n+    lo = (HOST_WIDE_INT)1 << i, hi = 0;\n+  else\n+    lo = 0, hi = (HOST_WIDE_INT)1 << (i - HOST_BITS_PER_WIDE_INT);\n+\n+  op1 = immed_double_const (~lo, ~hi, DImode);\n+  if (i >= 32)\n+    {\n+      emit_move_insn (operands[2], op1);\n+      op1 = operands[2];\n+    }\n+\n+  emit_insn (gen_anddi3 (operands[0], operands[0], op1));\n+  DONE;\n+})\n+\n+(define_peephole2\n+  [(match_scratch:DI 2 \"r\")\n+   (parallel [(set (zero_extract:DI\n+\t\t     (match_operand 0 \"register_operand\" \"\")\n+\t\t     (const_int 1)\n+\t\t     (match_operand 1 \"const_0_to_63_operand\" \"\"))\n+\t      (not:DI (zero_extract:DI\n+\t\t\t(match_dup 0) (const_int 1) (match_dup 1))))\n+\t      (clobber (reg:CC FLAGS_REG))])]\n+  \"TARGET_64BIT && !TARGET_USE_BT\"\n+  [(const_int 0)]\n+{\n+  HOST_WIDE_INT i = INTVAL (operands[1]), hi, lo;\n+  rtx op1;\n+\n+  if (HOST_BITS_PER_WIDE_INT >= 64)\n+    lo = (HOST_WIDE_INT)1 << i, hi = 0;\n+  else if (i < HOST_BITS_PER_WIDE_INT)\n+    lo = (HOST_WIDE_INT)1 << i, hi = 0;\n+  else\n+    lo = 0, hi = (HOST_WIDE_INT)1 << (i - HOST_BITS_PER_WIDE_INT);\n+\n+  op1 = immed_double_const (lo, hi, DImode);\n+  if (i >= 31)\n+    {\n+      emit_move_insn (operands[2], op1);\n+      op1 = operands[2];\n+    }\n+\n+  emit_insn (gen_xordi3 (operands[0], operands[0], op1));\n+  DONE;\n+})\n \f\n ;; Store-flag instructions.\n \n@@ -19995,7 +19716,7 @@\n (define_split\n   [(set (match_operand:V4SF 0 \"register_operand\" \"\")\n \t(match_operand:V4SF 1 \"zero_extended_scalar_load_operand\" \"\"))]\n-  \"TARGET_SSE\"\n+  \"TARGET_SSE && reload_completed\"\n   [(set (match_dup 0)\n \t(vec_merge:V4SF\n \t (vec_duplicate:V4SF (match_dup 1))\n@@ -20089,7 +19810,7 @@\n (define_split\n   [(set (match_operand:V2DF 0 \"register_operand\" \"\")\n \t(match_operand:V2DF 1 \"zero_extended_scalar_load_operand\" \"\"))]\n-  \"TARGET_SSE2\"\n+  \"TARGET_SSE2 && reload_completed\"\n   [(set (match_dup 0)\n \t(vec_merge:V2DF\n \t (vec_duplicate:V2DF (match_dup 1))"}, {"sha": "3340a2a93bf98dec47fbcad3b43aeb07e2ace8ee", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cacf53e505b9143b7ae0e646dc83a4e5cf9f643/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cacf53e505b9143b7ae0e646dc83a4e5cf9f643/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=7cacf53e505b9143b7ae0e646dc83a4e5cf9f643", "patch": "@@ -536,6 +536,11 @@\n   (and (match_code \"const_int\")\n        (match_test \"INTVAL (op) >= 0 && INTVAL (op) <= 15\")))\n \n+;; Match 0 to 63.\n+(define_predicate \"const_0_to_63_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) >= 0 && INTVAL (op) <= 63\")))\n+\n ;; Match 0 to 255.\n (define_predicate \"const_0_to_255_operand\"\n   (and (match_code \"const_int\")\n@@ -835,3 +840,6 @@\n \n (define_predicate \"compare_operator\"\n   (match_code \"compare\"))\n+\n+(define_predicate \"absneg_operator\"\n+  (match_code \"abs,neg\"))"}]}