{"sha": "6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQyZjg4ODczNTVlMmQyMWVjYzJlYzQyMDFmN2I1ZmI4NmUyOWY4MQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2001-10-10T11:33:39Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2001-10-10T11:33:39Z"}, "message": "calls.c: Fix formatting.\n\n\t* calls.c: Fix formatting.\n\t* c-decl.c: Likewise.\n\t* cfgcleanup.c: Likewise.\n\t* combine.c: Likewise.\n\t* cppfiles.c: Likewise.\n\t* cpplib.c: Likewise.\n\t* cppmacro.c: Likewise.\n\t* crtstuff.c: Likewise.\n\t* cse.c: Likewise.\n\t* dwarf2out.c: Likewise.\n\t* expmed.c: Likewise.\n\t* expr.c: Likewise.\n\t* fold-const.c: Likewise.\n\t* function.c: Likewise.\n\t* gcse.c: Likewise.\n\t* genattrtab.c: Likewise.\n\t* ggc-page.c: Likewise.\n\t* integrate.c: Likewise.\n\t* libgcc2.c: Likewise.\n\t* loop.c: Likewise.\n\t* optabs.c: Likewise.\n\t* profile.c: Likewise.\n\t* protoize.c: Likewise.\n\t* real.c: Likewise.\n\t* recog.c: Likewise.\n\t* reload1.c: Likewise.\n\t* reload.c: Likewise.\n\t* reorg.c: Likewise.\n\t* resource.c: Likewise.\n\t* sched-rgn.c: Likewise.\n\t* sdbout.c: Likewise.\n\t* stmt.c: Likewise.\n\t* toplev.c: Likewise.\n\t* varasm.c: Likewise.\n\nFrom-SVN: r46145", "tree": {"sha": "1354eff221b576ada39ccb796806717a4dcf6fdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1354eff221b576ada39ccb796806717a4dcf6fdb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/comments", "author": null, "committer": null, "parents": [{"sha": "3717a9799293e47e4bbc18f7cda76b88e886e22e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3717a9799293e47e4bbc18f7cda76b88e886e22e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3717a9799293e47e4bbc18f7cda76b88e886e22e"}], "stats": {"total": 169, "additions": 103, "deletions": 66}, "files": [{"sha": "14bde64b1492e75c4a6def64cbb6082c8b0323c7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -1,3 +1,40 @@\n+2001-10-10  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* calls.c: Fix formatting.\n+\t* c-decl.c: Likewise.\n+\t* cfgcleanup.c: Likewise.\n+\t* combine.c: Likewise.\n+\t* cppfiles.c: Likewise.\n+\t* cpplib.c: Likewise.\n+\t* cppmacro.c: Likewise.\n+\t* crtstuff.c: Likewise.\n+\t* cse.c: Likewise.\n+\t* dwarf2out.c: Likewise.\n+\t* expmed.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* fold-const.c: Likewise.\n+\t* function.c: Likewise.\n+\t* gcse.c: Likewise.\n+\t* genattrtab.c: Likewise.\n+\t* ggc-page.c: Likewise.\n+\t* integrate.c: Likewise.\n+\t* libgcc2.c: Likewise.\n+\t* loop.c: Likewise.\n+\t* optabs.c: Likewise.\n+\t* profile.c: Likewise.\n+\t* protoize.c: Likewise.\n+\t* real.c: Likewise.\n+\t* recog.c: Likewise.\n+\t* reload1.c: Likewise.\n+\t* reload.c: Likewise.\n+\t* reorg.c: Likewise.\n+\t* resource.c: Likewise.\n+\t* sched-rgn.c: Likewise.\n+\t* sdbout.c: Likewise.\n+\t* stmt.c: Likewise.\n+\t* toplev.c: Likewise.\n+\t* varasm.c: Likewise.\n+\n 2001-10-10  Janis Johnson  <janis187@us.ibm.com>, Alexandre Oliva  <aoliva@redhat.com>\n \n \t* langhooks.c: Include rtl.h, insn-config.h and integrate.h."}, {"sha": "79530d77db9a010a7e9a5d9a08e186ad84f230f4", "filename": "gcc/c-decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -283,7 +283,7 @@ static void c_expand_body               PARAMS ((tree, int));\n /* C-specific option variables.  */\n \n /* Nonzero means allow type mismatches in conditional expressions;\n-   just make their values `void'.   */\n+   just make their values `void'.  */\n \n int flag_cond_mismatch;\n \n@@ -3520,7 +3520,7 @@ finish_decl (decl, init, asmspec_tree)\n   int was_incomplete = (DECL_SIZE (decl) == 0);\n   const char *asmspec = 0;\n \n-  /* If a name was specified, get the string.   */\n+  /* If a name was specified, get the string.  */\n   if (asmspec_tree)\n     asmspec = TREE_STRING_POINTER (asmspec_tree);\n \n@@ -6393,7 +6393,7 @@ store_parm_decls ()\n \t      }\n \n \t  /* If declaration already marked, we have a duplicate name.\n-\t     Complain, and don't use this decl twice.   */\n+\t     Complain, and don't use this decl twice.  */\n \t  if (found && DECL_WEAK (found))\n \t    {\n \t      error_with_decl (found, \"multiple parameters named `%s'\");"}, {"sha": "b2229168b196cbd285f7462291a0d9a067e66032", "filename": "gcc/calls.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -437,7 +437,7 @@ prepare_call_address (funexp, fndecl, call_fusage, reg_parm_seen, sibcallp)\n    We restore `inhibit_defer_pop' to that value.\n \n    CALL_FUSAGE is either empty or an EXPR_LIST of USE expressions that\n-   denote registers used by the called function.   */\n+   denote registers used by the called function.  */\n \n static void\n emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n@@ -2387,7 +2387,7 @@ expand_call (exp, target, ignore)\n       /* If this function requires a variable-sized argument list, don't\n \t try to make a cse'able block for this call.  We may be able to\n \t do this eventually, but it is too complicated to keep track of\n-\t what insns go in the cse'able block and which don't.   */\n+\t what insns go in the cse'able block and which don't.  */\n \n       flags &= ~(ECF_CONST | ECF_PURE);\n       must_preallocate = 1;\n@@ -4405,7 +4405,7 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n \n   if (reg != 0 && partial == 0)\n     /* Being passed entirely in a register.  We shouldn't be called in\n-       this case.   */\n+       this case.  */\n     abort ();\n \n   /* If this arg needs special alignment, don't load the registers"}, {"sha": "e6cf366e17f6e88f1c74da35534cfbdb502b6cb4", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -916,7 +916,7 @@ try_crossjump_to_edge (mode, e1, e2)\n     newpos1 = NEXT_INSN (newpos1);\n   last = src1->end;\n \n-  /* Emit the jump insn.   */\n+  /* Emit the jump insn.  */\n   label = block_label (redirect_to);\n   emit_jump_insn_after (gen_jump (label), src1->end);\n   JUMP_LABEL (src1->end) = label;\n@@ -1189,7 +1189,7 @@ try_optimize_cfg (mode)\n   return changed_overall;\n }\n \f\n-/* Delete all unreachable basic blocks.   */\n+/* Delete all unreachable basic blocks.  */\n \n static bool\n delete_unreachable_blocks ()"}, {"sha": "de80e8d64b50b404ab8113fae64ab900a500ffb3", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -6839,7 +6839,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n \n     binop:\n       /* For most binary operations, just propagate into the operation and\n-\t change the mode if we have an operation of that mode.   */\n+\t change the mode if we have an operation of that mode.  */\n \n       op0 = gen_lowpart_for_combine (op_mode,\n \t\t\t\t     force_to_mode (XEXP (x, 0), mode, mask,"}, {"sha": "61a53d6809cd59b4bc4437c287917a8e85631e88", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -597,7 +597,7 @@ report_missing_guard (n, b)\n   return 0;\n }\n \n-/* Create a dependency, or issue an error message as appropriate.   */\n+/* Create a dependency, or issue an error message as appropriate.  */\n static void\n handle_missing_header (pfile, fname, angle_brackets)\n      cpp_reader *pfile;"}, {"sha": "3138b7ee63b4092dad6d7d5d5bc867b4dde87584", "filename": "gcc/cpplib.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -261,7 +261,7 @@ directive_diagnostics (pfile, dir, indented)\n     }\n   else\n     {\n-      /* Issue -pedantic warnings for extensions.   */\n+      /* Issue -pedantic warnings for extensions.  */\n       if (CPP_PEDANTIC (pfile)\n \t  && ! pfile->state.skipping\n \t  && dir->origin == EXTENSION)"}, {"sha": "5e094c2fcc40940fa78fc75b3cab5ebaaa383a0f", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -32,7 +32,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n struct cpp_macro\n {\n   cpp_hashnode **params;\t/* Parameters, if any.  */\n-  cpp_token *expansion;\t\t/* First token of replacement list.   */\n+  cpp_token *expansion;\t\t/* First token of replacement list.  */\n   unsigned int line;\t\t/* Starting line number.  */\n   unsigned int count;\t\t/* Number of tokens in expansion.  */\n   unsigned short paramc;\t/* Number of parameters.  */\n@@ -45,7 +45,7 @@ typedef struct macro_arg macro_arg;\n struct macro_arg\n {\n   const cpp_token **first;\t/* First token in unexpanded argument.  */\n-  const cpp_token **expanded;\t/* Macro-expanded argument.   */\n+  const cpp_token **expanded;\t/* Macro-expanded argument.  */\n   const cpp_token *stringified;\t/* Stringified argument.  */\n   unsigned int count;\t\t/* # of tokens in argument.  */\n   unsigned int expanded_count;\t/* # of tokens in expanded argument.  */"}, {"sha": "e62f0c0a8c2e75f9e18c86311efdf0bd37d748ce", "filename": "gcc/crtstuff.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fcrtstuff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fcrtstuff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcrtstuff.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -358,7 +358,7 @@ asm (INIT_SECTION_ASM_OP);\t/* cc1 doesn't know that we are switching! */\n /* A routine to invoke all of the global constructors upon entry to the\n    program.  We put this into the .init section (for systems that have\n    such a thing) so that we can properly perform the construction of\n-   file-scope static-storage C++ objects within shared libraries.   */\n+   file-scope static-storage C++ objects within shared libraries.  */\n \n static void\n __do_global_ctors_aux (void)\t/* prologue goes in .init section */"}, {"sha": "e18f7530accb9577f20164d8a800fc2eaf6846f0", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -7605,7 +7605,7 @@ delete_trivially_dead_insns (insns, nreg, preserve_basic_blocks)\n \n      The first jump optimization pass may leave a real insn as the last\n      insn in the function.   We must not skip that insn or we may end\n-     up deleting code that is not really dead.   */\n+     up deleting code that is not really dead.  */\n   insn = get_last_insn ();\n   if (! INSN_P (insn))\n     insn = prev_real_insn (insn);"}, {"sha": "31aae4e4c10ddbedfb3e7c6dda2408d2ae9866eb", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -171,7 +171,7 @@ typedef struct dw_fde_struct\n }\n dw_fde_node;\n \n-/* Maximum size (in bytes) of an artificially generated label.   */\n+/* Maximum size (in bytes) of an artificially generated label.  */\n #define MAX_ARTIFICIAL_LABEL_BYTES\t30\n \n /* The size of the target's pointer type.  */\n@@ -6268,7 +6268,7 @@ output_comp_unit (die)\n \n   build_abbrev_table (die);\n \n-  /* Initialize the beginning DIE offset - and calculate sizes/offsets.   */\n+  /* Initialize the beginning DIE offset - and calculate sizes/offsets.  */\n   next_die_offset = DWARF_COMPILE_UNIT_HEADER_SIZE;\n   calc_die_sizes (die);\n \n@@ -7410,7 +7410,7 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n }\n \n /* Given a pointer to an arbitrary ..._TYPE tree node, return true if it is\n-   an enumerated type.   */\n+   an enumerated type.  */\n \n static inline int\n type_is_enum (type)"}, {"sha": "f7f3728fd2e863da8ca4c730e04826af746ee91a", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -4050,7 +4050,7 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n /* Return a tree node with data type TYPE, describing the value of X.\n    Usually this is an RTL_EXPR, if there is no obvious better choice.\n    X may be an expression, however we only support those expressions\n-   generated by loop.c.   */\n+   generated by loop.c.  */\n \n tree\n make_tree (type, x)"}, {"sha": "a45042fe83207f869305b1a82f3cdd72ca3c3df8", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -5384,7 +5384,7 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n \n    If the field describes a variable-sized object, *PMODE is set to\n    VOIDmode and *PBITSIZE is set to -1.  An access cannot be made in\n-   this case, but the address of the object can be found.   */\n+   this case, but the address of the object can be found.  */\n \n tree\n get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n@@ -9197,7 +9197,7 @@ expand_increment (exp, post, ignore)\n   /* Compute the operands as RTX.\n      Note whether OP0 is the actual lvalue or a copy of it:\n      I believe it is a copy iff it is a register or subreg\n-     and insns were generated in computing it.   */\n+     and insns were generated in computing it.  */\n \n   temp = get_last_insn ();\n   op0 = expand_expr (incremented, NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_RW);"}, {"sha": "2aa26f317b1734cd95d87484c77f80ba5bcfe0b7", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -660,7 +660,7 @@ div_and_round_double (code, uns,\n \t  else\n \t    quo_est = BASE - 1;\n \n-\t  /* Refine quo_est so it's usually correct, and at most one high.   */\n+\t  /* Refine quo_est so it's usually correct, and at most one high.  */\n \t  tmp = work - quo_est * den[den_hi_sig];\n \t  if (tmp < BASE\n \t      && (den[den_hi_sig - 1] * quo_est\n@@ -3004,7 +3004,7 @@ optimize_bit_field_compare (code, compare_type, lhs, rhs)\n  if (!const_p)\n    {\n      /* If this is not a constant, we can only do something if bit positions,\n-\tsizes, and signedness are the same.   */\n+\tsizes, and signedness are the same.  */\n      rinner = get_inner_reference (rhs, &rbitsize, &rbitpos, &offset, &rmode,\n \t\t\t\t   &runsignedp, &rvolatilep, &alignment);\n "}, {"sha": "2e510dc66f2a96018276c4b38ea43b148123b899", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -1194,7 +1194,7 @@ free_temps_for_rtl_expr (t)\n \t/* If this slot is below the current TEMP_SLOT_LEVEL, then it\n \t   needs to be preserved.  This can happen if a temporary in\n \t   the RTL_EXPR was addressed; preserve_temp_slots will move\n-\t   the temporary into a higher level.   */\n+\t   the temporary into a higher level.  */\n \tif (temp_slot_level <= p->level)\n \t  p->in_use = 0;\n \telse\n@@ -4956,7 +4956,7 @@ assign_parms (fndecl)\n \n \t  if (promoted_mode != nominal_mode)\n \t    {\n-\t      /* Conversion is required.   */\n+\t      /* Conversion is required.  */\n \t      rtx tempreg = gen_reg_rtx (GET_MODE (entry_parm));\n \n \t      emit_move_insn (tempreg, validize_mem (entry_parm));"}, {"sha": "2e0e7ed7a3596a98ef14a69a21ebf6f39f3efa7f", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -2948,7 +2948,7 @@ compute_kill_rd ()\n \t Look at the linked list starting at reg_set_table[regx]\n \t For each setting of regx in the linked list, which is not in\n \t     this block\n-\t   Set the bit in `kill' corresponding to that insn.   */\n+\t   Set the bit in `kill' corresponding to that insn.  */\n   for (bb = 0; bb < n_basic_blocks; bb++)\n     for (cuid = 0; cuid < max_cuid; cuid++)\n       if (TEST_BIT (rd_gen[bb], cuid))\n@@ -4931,7 +4931,7 @@ pre_delete ()\n \t\t   However, on the x86 some of the movXX patterns actually\n \t\t   contain clobbers of scratch regs.  This may cause the\n \t\t   insn created by validate_change to not match any pattern\n-\t\t   and thus cause validate_change to fail.   */\n+\t\t   and thus cause validate_change to fail.  */\n \t\tif (validate_change (insn, &SET_SRC (set),\n \t\t\t\t     expr->reaching_reg, 0))\n \t\t  {"}, {"sha": "33cd0d85d03606d11b55d635f76c4df1db6ccd60", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -920,7 +920,7 @@ attr_copy_rtx (orig)\n    in the attribute (or `alternative_name') to speed up subsequent\n    `find_attr' calls and eliminate most `strcmp' calls.\n \n-   Return the new expression, if any.   */\n+   Return the new expression, if any.  */\n \n static rtx\n check_attr_test (exp, is_const, lineno)\n@@ -3474,7 +3474,7 @@ simplify_test_exp (exp, insn_code, insn_index)\n \n       /* Look at the value for this insn code in the specified attribute.\n \t We normally can replace this comparison with the condition that\n-\t would give this insn the values being tested for.   */\n+\t would give this insn the values being tested for.  */\n       if (XSTR (exp, 0) != alternative_name\n \t  && (attr = find_attr (XSTR (exp, 0), 0)) != NULL)\n \tfor (av = attr->first_value; av; av = av->next)"}, {"sha": "7f4ac873beed078ef9cf0b28ae7df4ddc4eadb26", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -110,7 +110,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n      1: GC statistics only.\n      2: Page-entry allocations/deallocations as well.\n      3: Object allocations as well.\n-     4: Object marks as well.   */\n+     4: Object marks as well.  */\n #define GGC_DEBUG_LEVEL (0)\n \f\n #ifndef HOST_BITS_PER_PTR"}, {"sha": "b4aee8383afd77d21655d0036ab654bb36764006", "filename": "gcc/integrate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -1077,7 +1077,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n       /* The function returns an object in a register and we use the return\n \t value.  Set up our target for remapping.  */\n \n-      /* Machine mode function was declared to return.   */\n+      /* Machine mode function was declared to return.  */\n       enum machine_mode departing_mode = TYPE_MODE (type);\n       /* (Possibly wider) machine mode it actually computes\n \t (for the sake of callers that fail to declare it right)."}, {"sha": "c86456732b83c71d0c3ca0ab2c215e997d3215e1", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -2605,7 +2605,7 @@ __enable_execute_stack (void)\n   unsigned long current = (unsigned long) &save_errno & -NBPC;\n \n   /* Ignore errno being set. memctl sets errno to EINVAL whenever the\n-     address is seen as 'negative'. That is the case with the stack.   */\n+     address is seen as 'negative'. That is the case with the stack.  */\n \n   save_errno=errno;\n   if (lowest > current)"}, {"sha": "ec465c7b6c5aa170a2950e1c5008c157367657c3", "filename": "gcc/loop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -3775,7 +3775,7 @@ loop_givs_find (loop)\n \n /* For each giv for which we still don't know whether or not it is\n    replaceable, check to see if it is replaceable because its final value\n-   can be calculated.   */\n+   can be calculated.  */\n \n static void\n loop_givs_check (loop)\n@@ -4757,7 +4757,7 @@ find_mem_givs (loop, x, insn, not_every_iteration, maybe_multiple)\n \t/* This code used to disable creating GIVs with mult_val == 1 and\n \t   add_val == 0.  However, this leads to lost optimizations when\n \t   it comes time to combine a set of related DEST_ADDR GIVs, since\n-\t   this one would not be seen.   */\n+\t   this one would not be seen.  */\n \n \tif (general_induction_var (loop, XEXP (x, 0), &src_reg, &add_val,\n \t\t\t\t   &mult_val, &ext_val, 1, &benefit,"}, {"sha": "ad21e8db60374f9519fde1c0316aebcc97a163a7", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -853,7 +853,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n \t    /* For certain integer operations, we need not actually extend\n \t       the narrow operands, as long as we will truncate\n-\t       the results to the same narrowness.   */\n+\t       the results to the same narrowness.  */\n \n \t    if ((binoptab == ior_optab || binoptab == and_optab\n \t\t || binoptab == xor_optab"}, {"sha": "63c49f687be471d613874907c991f7dc1df0117c", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -68,7 +68,7 @@ struct bb_info\n #define BB_INFO(b)  ((struct bb_info *) (b)->aux)\n \n /* Keep all basic block indexes nonnegative in the gcov output.  Index 0\n-   is used for entry block, last block exit block.   */\n+   is used for entry block, last block exit block.  */\n #define GCOV_INDEX_TO_BB(i)  ((i) == 0 ? ENTRY_BLOCK_PTR\t\t\\\n \t\t\t      : (((i) == n_basic_blocks + 1)\t\t\\\n \t\t\t         ? EXIT_BLOCK_PTR : BASIC_BLOCK ((i)-1)))"}, {"sha": "8ed53af2c4ffa4fccafc5c36def94d6b548dc2c2", "filename": "gcc/protoize.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -2538,7 +2538,7 @@ find_extern_def (head, user)\n      code being converted contains its own definition of a function which\n      could have been supplied by libc.a.  In such cases, we should avoid\n      issuing the normal warning, and defer to the definition given in the\n-     user's own code.   */\n+     user's own code.  */\n \n   for (dd_p = head; dd_p; dd_p = dd_p->next_for_func)\n     if (dd_p->is_func_def && !dd_p->is_static)\n@@ -3645,7 +3645,7 @@ add_global_decls (file_p, clean_text_p)\n   /* Now write out full prototypes for all of the things that had been\n      implicitly declared in this file (but only those for which we were\n      actually able to find unique matching definitions).  Avoid duplicates\n-     by marking things that we write out as we go.   */\n+     by marking things that we write out as we go.  */\n \n   {\n     int some_decls_added = 0;"}, {"sha": "4978548475924bffd87a9767a39d4414cce3950b", "filename": "gcc/real.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -50,7 +50,7 @@ test programs available.  A special version of the PARANOIA floating\n point arithmetic tester, modified for this purpose, can be found on\n usc.edu: /pub/C-numanal/ieeetest.zoo.  Other tests, and libraries of\n XFmode and TFmode transcendental functions, can be obtained by ftp from\n-netlib.att.com: netlib/cephes.   */\n+netlib.att.com: netlib/cephes.  */\n \f\n /* Type of computer arithmetic.\n    Only one of DEC, IBM, IEEE, C4X, or UNK should get defined.\n@@ -108,7 +108,7 @@ netlib.att.com: netlib/cephes.   */\n    These optional macros may be defined in tm.h.  In real.h, they\n    default to WORDS_BIG_ENDIAN, etc., so there is no need to define\n    them for any normal host or target machine on which the floats\n-   and the integers have the same endian-ness.   */\n+   and the integers have the same endian-ness.  */\n \n \n /* The following converts gcc macros into the ones used by this file.  */\n@@ -503,7 +503,7 @@ static void esqrt\tPARAMS ((UEMUSHORT *, UEMUSHORT *));\n \f\n /* Copy 32-bit numbers obtained from array containing 16-bit numbers,\n    swapping ends if required, into output array of longs.  The\n-   result is normally passed to fprintf by the ASM_OUTPUT_ macros.   */\n+   result is normally passed to fprintf by the ASM_OUTPUT_ macros.  */\n \n static void\n endian (e, x, mode)\n@@ -917,7 +917,7 @@ ereal_from_int (d, i, j, mode)\n }\n \n \n-/* REAL_VALUE_FROM_UNSIGNED_INT macro.   */\n+/* REAL_VALUE_FROM_UNSIGNED_INT macro.  */\n \n void\n ereal_from_uint (d, i, j, mode)\n@@ -1324,7 +1324,7 @@ ereal_to_decimal (x, s)\n }\n \n /* Compare X and Y.  Return 1 if X > Y, 0 if X == Y, -1 if X < Y,\n-   or -2 if either is a NaN.   */\n+   or -2 if either is a NaN.  */\n \n int\n ereal_cmp (x, y)\n@@ -2514,7 +2514,7 @@ emulm (a, b)\n    Data types having standard 15-bit exponents are not affected by\n    this, but SFmode and DFmode are affected. For example, ediv with\n    rndprc = 24 will not round correctly to 24-bit precision if the\n-   result is denormal.   */\n+   result is denormal.  */\n \n static int rlast = -1;\n static int rw = 0;\n@@ -3018,7 +3018,7 @@ ediv (a, b, c)\n      *(c+(NE-1)) &= ~0x8000;\n }\n \n-/* Multiply e-types A and B, return e-type product C.   */\n+/* Multiply e-types A and B, return e-type product C.  */\n \n static void\n emul (a, b, c)"}, {"sha": "71ecfd8eb95ebc30de597d71610201584e64c361", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -402,7 +402,7 @@ apply_change_group ()\n     }\n }\n \n-/* Return the number of changes so far in the current group.   */\n+/* Return the number of changes so far in the current group.  */\n \n int\n num_validated_changes ()"}, {"sha": "0b497aa6f96611224063a5feece2abe46a4552aa", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -2686,7 +2686,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t     When we find a pseudo always equivalent to a constant,\n \t     we replace it by the constant.  We must be sure, however,\n \t     that we don't try to replace it in the insn in which it\n-\t     is being set.   */\n+\t     is being set.  */\n \t  register int regno = REGNO (recog_data.operand[i]);\n \t  if (reg_equiv_constant[regno] != 0\n \t      && (set == 0 || &SET_DEST (set) != recog_data.operand_loc[i]))"}, {"sha": "0bdfcb8e6d021fe2d61f58b10f920145acf0d361", "filename": "gcc/reload1.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -225,7 +225,7 @@ static char spill_indirect_levels;\n \n /* Nonzero if indirect addressing is supported when the innermost MEM is\n    of the form (MEM (SYMBOL_REF sym)).  It is assumed that the level to\n-   which these are valid is the same as spill_indirect_levels, above.   */\n+   which these are valid is the same as spill_indirect_levels, above.  */\n char indirect_symref_ok;\n \n /* Nonzero if an address (plus (reg frame_pointer) (reg ...)) is valid.  */\n@@ -916,7 +916,7 @@ reload (first, global)\n       /* Round size of stack frame to stack_alignment_needed.  This must be done\n \t here because the stack size may be a part of the offset computation\n \t for register elimination, and there might have been new stack slots\n-\t created in the last iteration of this loop.   */\n+\t created in the last iteration of this loop.  */\n       if (cfun->stack_alignment_needed)\n         assign_stack_local (BLKmode, 0, cfun->stack_alignment_needed);\n \n@@ -2041,7 +2041,7 @@ alter_reg (i, from_reg)\n       if (adjust != 0 || GET_MODE (x) != GET_MODE (regno_reg_rtx[i]))\n \tx = adjust_address_nv (x, GET_MODE (regno_reg_rtx[i]), adjust);\n \n-      /* Save the stack slot for later.   */\n+      /* Save the stack slot for later.  */\n       reg_equiv_memory_loc[i] = x;\n     }\n }\n@@ -2316,7 +2316,7 @@ eliminate_regs (x, mem_mode, insn)\n        whole instead of this little section as well as the backend issues.  */\n     case PLUS:\n       /* If this is the sum of an eliminable register and a constant, rework\n-\t the sum.   */\n+\t the sum.  */\n       if (GET_CODE (XEXP (x, 0)) == REG\n \t  && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER\n \t  && CONSTANT_P (XEXP (x, 1)))\n@@ -6192,7 +6192,7 @@ emit_input_reload_insns (chain, rl, old, j)\n       /* If it is no cheaper to copy from OLDEQUIV into the\n \t reload register than it would be to move from memory,\n \t don't use it. Likewise, if we need a secondary register\n-\t or memory.   */\n+\t or memory.  */\n \n       if (oldequiv != 0\n \t  && ((REGNO_REG_CLASS (regno) != rl->class"}, {"sha": "7ef9e1160fc406317217f766134f9f174a70b684", "filename": "gcc/reorg.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -118,7 +118,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    based on the condition code of the previous insn.\n \n    The HP-PA can conditionally nullify insns, providing a similar\n-   effect to the ARM, differing mostly in which insn is \"in charge\".   */\n+   effect to the ARM, differing mostly in which insn is \"in charge\".  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -2123,7 +2123,7 @@ fill_simple_delay_slots (non_jumps_p)\n \t    tmp++;\n \n \t  /* Remove the unconditional jump from consideration for delay slot\n-\t     filling and unthread it.   */\n+\t     filling and unthread it.  */\n \t  if (*tmp == trial)\n \t    *tmp = 0;\n \t  {\n@@ -2309,7 +2309,7 @@ fill_simple_delay_slots (non_jumps_p)\n \t\t  break;\n \n \t\t/* See if we have a resource problem before we try to\n-\t\t   split.   */\n+\t\t   split.  */\n \t\tif (GET_CODE (pat) != SEQUENCE\n \t\t    && ! insn_references_resource_p (trial, &set, 1)\n \t\t    && ! insn_sets_resource_p (trial, &set, 1)"}, {"sha": "8a27855e7f4f293c57a4b56d98fc32c2b4ec62bc", "filename": "gcc/resource.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -619,7 +619,7 @@ find_dead_or_set_registers (target, res, jump_target, jump_count, set, needed)\n    SETs CC0 even though this is not totally correct.  The reason for this is\n    that we require a SET of CC0 to immediately precede the reference to CC0.\n    So if some other insn sets CC0 as a side-effect, we know it cannot affect\n-   our computation and thus may be placed in a delay slot.   */\n+   our computation and thus may be placed in a delay slot.  */\n \n void\n mark_set_resources (x, res, in_dest, mark_type)"}, {"sha": "8426b4317abf354d9f40b16f2ac3a859abc49873", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -2201,7 +2201,7 @@ can_schedule_ready_p (insn)\n       while (SCHED_GROUP_P (temp))\n \ttemp = PREV_INSN (temp);\n \n-      /* Update source block boundaries.   */\n+      /* Update source block boundaries.  */\n       b1 = BLOCK_FOR_INSN (temp);\n       if (temp == b1->head && insn == b1->end)\n \t{\n@@ -3017,7 +3017,7 @@ schedule_insns (dump_file)\n \n   /* Update life analysis for the subroutine.  Do single block regions\n      first so that we can verify that live_at_start didn't change.  Then\n-     do all other blocks.   */\n+     do all other blocks.  */\n   /* ??? There is an outside possibility that update_life_info, or more\n      to the point propagate_block, could get called with non-zero flags\n      more than once for one basic block.  This would be kinda bad if it"}, {"sha": "becc4e3fa48b4c054ab8ee9af4bd7387130777f1", "filename": "gcc/sdbout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -244,7 +244,7 @@ do { fprintf (asm_out_file, \"\\t.tag\\t\");\t\\\n #endif\n \n /* Return the sdb tag identifier string for TYPE\n-   if TYPE has already been defined; otherwise return a null pointer.   */\n+   if TYPE has already been defined; otherwise return a null pointer.  */\n \n #define KNOWN_TYPE_TAG(type)  TYPE_SYMTAB_POINTER (type)\n "}, {"sha": "ace1490cd3dccc9804e86b3c3f1aa3ed40934524", "filename": "gcc/stmt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -1229,7 +1229,7 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n \t/* Label has still not appeared.  If we are exiting a block with\n \t   a stack level to restore, that started before the fixup,\n \t   mark this stack level as needing restoration\n-\t   when the fixup is later finalized.   */\n+\t   when the fixup is later finalized.  */\n \t&& thisblock != 0\n \t/* Note: if THISBLOCK == 0 and we have a label that hasn't appeared, it\n \t   means the label is undefined.  That's erroneous, but possible.  */\n@@ -3089,7 +3089,7 @@ expand_return (retval)\n \n       /* Find the smallest integer mode large enough to hold the\n \t entire structure and use that mode instead of BLKmode\n-\t on the USE insn for the return register.   */\n+\t on the USE insn for the return register.  */\n       for (tmpmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n \t   tmpmode != VOIDmode;\n \t   tmpmode = GET_MODE_WIDER_MODE (tmpmode))\n@@ -3983,7 +3983,7 @@ expand_decl_init (decl)\n    leave the current scope.\n \n    If CLEANUP is nonzero and DECL is zero, we record a cleanup\n-   that is not associated with any particular variable.   */\n+   that is not associated with any particular variable.  */\n \n int\n expand_decl_cleanup (decl, cleanup)"}, {"sha": "473decb911151547a1a05765ed06d08e464bc1ef", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -1449,7 +1449,7 @@ int warn_notreached;\n \n int warn_uninitialized;\n \n-/* Nonzero means warn about all declarations which shadow others.   */\n+/* Nonzero means warn about all declarations which shadow others.  */\n \n int warn_shadow;\n "}, {"sha": "80c665f3326b21c4725c702eaba30dd09f2a27b9", "filename": "gcc/varasm.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=6d2f8887355e2d21ecc2ec4201f7b5fb86e29f81", "patch": "@@ -977,7 +977,7 @@ make_decl_rtl (decl, asmspec)\n     }\n \n   /* If this variable is to be treated as volatile, show its\n-     tree node has side effects.   */\n+     tree node has side effects.  */\n   if ((flag_volatile_global && TREE_CODE (decl) == VAR_DECL\n        && TREE_PUBLIC (decl))\n       || ((flag_volatile_static && TREE_CODE (decl) == VAR_DECL\n@@ -1070,7 +1070,7 @@ default_named_section_asm_out_destructor (symbol, priority)\n   const char *section = \".dtors\";\n   char buf[16];\n \n-  /* ??? This only works reliably with the GNU linker.   */\n+  /* ??? This only works reliably with the GNU linker.  */\n   if (priority != DEFAULT_INIT_PRIORITY)\n     {\n       sprintf (buf, \".dtors.%.5u\",\n@@ -1132,7 +1132,7 @@ default_named_section_asm_out_constructor (symbol, priority)\n   const char *section = \".ctors\";\n   char buf[16];\n \n-  /* ??? This only works reliably with the GNU linker.   */\n+  /* ??? This only works reliably with the GNU linker.  */\n   if (priority != DEFAULT_INIT_PRIORITY)\n     {\n       sprintf (buf, \".ctors.%.5u\","}]}