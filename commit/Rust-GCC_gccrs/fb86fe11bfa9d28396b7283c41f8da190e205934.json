{"sha": "fb86fe11bfa9d28396b7283c41f8da190e205934", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI4NmZlMTFiZmE5ZDI4Mzk2YjcyODNjNDFmOGRhMTkwZTIwNTkzNA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2011-08-02T12:24:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T12:24:07Z"}, "message": "sem_ch5.adb (Pre_Analyze_Range): new procedure extracted from Process_Bounds...\n\n2011-08-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch5.adb (Pre_Analyze_Range): new procedure extracted from\n\tProcess_Bounds, to perform analysis with expansion of a range or an\n\texpression that is the iteration scheme for a loop.\n\t(Analyze_Iterator_Specification): If domain of iteration is given by a\n\tfunction call with a controlled result, as is the case if call returns\n\ta predefined container, ensure that finalization actions are properly\n\tgenerated.\n\t* par-ch3.adb: accept Ada2012 iterator form in P_Discrete_Range.\n\nFrom-SVN: r177134", "tree": {"sha": "5342945941c5c45f59dd2ef3e30c1a0cd6d53b1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5342945941c5c45f59dd2ef3e30c1a0cd6d53b1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb86fe11bfa9d28396b7283c41f8da190e205934", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb86fe11bfa9d28396b7283c41f8da190e205934", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb86fe11bfa9d28396b7283c41f8da190e205934", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb86fe11bfa9d28396b7283c41f8da190e205934/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7ea56b2382568eec303549248a2c1986f2385fd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ea56b2382568eec303549248a2c1986f2385fd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ea56b2382568eec303549248a2c1986f2385fd2"}], "stats": {"total": 234, "additions": 163, "deletions": 71}, "files": [{"sha": "858a947a124a3f26cbf9d73eaa6b07b37eb76e2f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb86fe11bfa9d28396b7283c41f8da190e205934/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb86fe11bfa9d28396b7283c41f8da190e205934/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fb86fe11bfa9d28396b7283c41f8da190e205934", "patch": "@@ -1,3 +1,14 @@\n+2011-08-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch5.adb (Pre_Analyze_Range): new procedure extracted from\n+\tProcess_Bounds, to perform analysis with expansion of a range or an\n+\texpression that is the iteration scheme for a loop.\n+\t(Analyze_Iterator_Specification): If domain of iteration is given by a\n+\tfunction call with a controlled result, as is the case if call returns\n+\ta predefined container, ensure that finalization actions are properly\n+\tgenerated.\n+\t* par-ch3.adb: accept Ada2012 iterator form in P_Discrete_Range.\n+\n 2011-08-02  Javier Miranda  <miranda@adacore.com>\n \n \t* sem_ch5.adb (Analyze_Iteration_Scheme): Fix typo."}, {"sha": "a9cc8c95dda88bd699da1fdc9da7956428203521", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb86fe11bfa9d28396b7283c41f8da190e205934/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb86fe11bfa9d28396b7283c41f8da190e205934/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=fb86fe11bfa9d28396b7283c41f8da190e205934", "patch": "@@ -2783,11 +2783,17 @@ package body Ch3 is\n          Set_High_Bound (Range_Node, Expr_Node);\n          return Range_Node;\n \n-      --  Otherwise we must have a subtype mark\n+      --  Otherwise we must have a subtype mark, or an Ada 2012 iterator\n \n       elsif Expr_Form = EF_Simple_Name then\n          return Expr_Node;\n \n+      --  The domain of iteration must be a name. Semantics will determine that\n+      --  the expression has the proper form.\n+\n+      elsif Ada_Version >= Ada_2012 then\n+         return Expr_Node;\n+\n       --  If incorrect, complain that we expect ..\n \n       else"}, {"sha": "6e218d26c42f73df00867d8e09c3691baa55dc47", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 145, "deletions": 70, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb86fe11bfa9d28396b7283c41f8da190e205934/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb86fe11bfa9d28396b7283c41f8da190e205934/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=fb86fe11bfa9d28396b7283c41f8da190e205934", "patch": "@@ -1537,6 +1537,90 @@ package body Sem_Ch5 is\n       --  calls that use the secondary stack, returning True if any such call\n       --  is found, and False otherwise.\n \n+      procedure Pre_Analyze_Range (R_Copy : Node_Id);\n+      --  Determine expected type of range or domain of iteration of Ada 2012\n+      --  loop by analyzing separate copy. Do the analysis and resolution of\n+      --  the copy of the bound(s) with expansion disabled, to prevent the\n+      --  generation of finalization actions. This prevents memory leaks when\n+      --  the bounds contain calls to functions returning controlled arrays or\n+      --  when the domain of iteration is a container.\n+\n+      -----------------------\n+      -- Pre_Analyze_Range --\n+      -----------------------\n+\n+      procedure Pre_Analyze_Range (R_Copy : Node_Id) is\n+         Save_Analysis : Boolean;\n+      begin\n+         Save_Analysis := Full_Analysis;\n+         Full_Analysis := False;\n+         Expander_Mode_Save_And_Set (False);\n+\n+         Analyze (R_Copy);\n+\n+         if Nkind (R_Copy) in N_Subexpr\n+           and then Is_Overloaded (R_Copy)\n+         then\n+\n+            --  Apply preference rules for range of predefined integer types,\n+            --  or diagnose true ambiguity.\n+\n+            declare\n+               I     : Interp_Index;\n+               It    : Interp;\n+               Found : Entity_Id := Empty;\n+\n+            begin\n+               Get_First_Interp (R_Copy, I, It);\n+               while Present (It.Typ) loop\n+                  if Is_Discrete_Type (It.Typ) then\n+                     if No (Found) then\n+                        Found := It.Typ;\n+                     else\n+                        if Scope (Found) = Standard_Standard then\n+                           null;\n+\n+                        elsif Scope (It.Typ) = Standard_Standard then\n+                           Found := It.Typ;\n+\n+                        else\n+                           --  Both of them are user-defined\n+\n+                           Error_Msg_N\n+                             (\"ambiguous bounds in range of iteration\",\n+                               R_Copy);\n+                           Error_Msg_N (\"\\possible interpretations:\", R_Copy);\n+                           Error_Msg_NE (\"\\\\} \", R_Copy, Found);\n+                           Error_Msg_NE (\"\\\\} \", R_Copy, It.Typ);\n+                           exit;\n+                        end if;\n+                     end if;\n+                  end if;\n+\n+                  Get_Next_Interp (I, It);\n+               end loop;\n+            end;\n+         end if;\n+\n+         if  Is_Entity_Name (R_Copy)\n+           and then Is_Type (Entity (R_Copy))\n+         then\n+\n+            --  Subtype mark in iteration scheme\n+\n+            null;\n+\n+         elsif Nkind (R_Copy) in N_Subexpr then\n+\n+            --  Expression in range, or Ada 2012 iterator\n+\n+            Resolve (R_Copy);\n+         end if;\n+\n+         Expander_Mode_Restore;\n+         Full_Analysis := Save_Analysis;\n+      end Pre_Analyze_Range;\n+\n       --------------------\n       -- Process_Bounds --\n       --------------------\n@@ -1549,7 +1633,6 @@ package body Sem_Ch5 is\n          New_Lo_Bound : Node_Id;\n          New_Hi_Bound : Node_Id;\n          Typ          : Entity_Id;\n-         Save_Analysis : Boolean;\n \n          function One_Bound\n            (Original_Bound : Node_Id;\n@@ -1653,65 +1736,8 @@ package body Sem_Ch5 is\n       --  Start of processing for Process_Bounds\n \n       begin\n-         --  Determine expected type of range by analyzing separate copy Do the\n-         --  analysis and resolution of the copy of the bounds with expansion\n-         --  disabled, to prevent the generation of finalization actions on\n-         --  each bound. This prevents memory leaks when the bounds contain\n-         --  calls to functions returning controlled arrays.\n-\n          Set_Parent (R_Copy, Parent (R));\n-         Save_Analysis := Full_Analysis;\n-         Full_Analysis := False;\n-         Expander_Mode_Save_And_Set (False);\n-\n-         Analyze (R_Copy);\n-\n-         if Is_Overloaded (R_Copy) then\n-\n-            --  Apply preference rules for range of predefined integer types,\n-            --  or diagnose true ambiguity.\n-\n-            declare\n-               I     : Interp_Index;\n-               It    : Interp;\n-               Found : Entity_Id := Empty;\n-\n-            begin\n-               Get_First_Interp (R_Copy, I, It);\n-               while Present (It.Typ) loop\n-                  if Is_Discrete_Type (It.Typ) then\n-                     if No (Found) then\n-                        Found := It.Typ;\n-                     else\n-                        if Scope (Found) = Standard_Standard then\n-                           null;\n-\n-                        elsif Scope (It.Typ) = Standard_Standard then\n-                           Found := It.Typ;\n-\n-                        else\n-                           --  Both of them are user-defined\n-\n-                           Error_Msg_N\n-                             (\"ambiguous bounds in range of iteration\",\n-                               R_Copy);\n-                           Error_Msg_N (\"\\possible interpretations:\", R_Copy);\n-                           Error_Msg_NE (\"\\\\} \", R_Copy, Found);\n-                           Error_Msg_NE (\"\\\\} \", R_Copy, It.Typ);\n-                           exit;\n-                        end if;\n-                     end if;\n-                  end if;\n-\n-                  Get_Next_Interp (I, It);\n-               end loop;\n-            end;\n-         end if;\n-\n-         Resolve (R_Copy);\n-         Expander_Mode_Restore;\n-         Full_Analysis := Save_Analysis;\n-\n+         Pre_Analyze_Range (R_Copy);\n          Typ := Etype (R_Copy);\n \n          --  If the type of the discrete range is Universal_Integer, then the\n@@ -1904,6 +1930,8 @@ package body Sem_Ch5 is\n                Id : constant Entity_Id := Defining_Identifier (LP);\n                DS : constant Node_Id   := Discrete_Subtype_Definition (LP);\n \n+               D_Copy : Node_Id;\n+\n             begin\n                Enter_Name (Id);\n \n@@ -1946,15 +1974,19 @@ package body Sem_Ch5 is\n                then\n                   Process_Bounds (DS);\n \n-               --  Not a range or expander not active (is that right???)\n+               --  Expander not active or else domain of iteration is a subtype\n+               --  indication, an entity, or a function call that yields an\n+               --  aggregate or a container.\n \n                else\n-                  Analyze (DS);\n+                  D_Copy := New_Copy_Tree (DS);\n+                  Set_Parent (D_Copy, Parent (DS));\n+                  Pre_Analyze_Range (D_Copy);\n \n-                  if Nkind (DS) = N_Function_Call\n+                  if Nkind (D_Copy) = N_Function_Call\n                     or else\n-                      (Is_Entity_Name (DS)\n-                        and then not Is_Type (Entity (DS)))\n+                      (Is_Entity_Name (D_Copy)\n+                        and then not Is_Type (Entity (D_Copy)))\n                   then\n                      --  This is an iterator specification. Rewrite as such\n                      --  and analyze.\n@@ -1964,8 +1996,7 @@ package body Sem_Ch5 is\n                                    Make_Iterator_Specification (Sloc (LP),\n                                      Defining_Identifier =>\n                                        Relocate_Node (Id),\n-                                     Name                =>\n-                                       Relocate_Node (DS),\n+                                     Name                => D_Copy,\n                                      Subtype_Indication  =>\n                                        Empty,\n                                      Reverse_Present     =>\n@@ -1976,6 +2007,13 @@ package body Sem_Ch5 is\n                         Analyze_Iterator_Specification (I_Spec);\n                         return;\n                      end;\n+\n+                  else\n+\n+                     --  Domain of iteration is not a function call, and is\n+                     --  side-effect free.\n+\n+                     Analyze (DS);\n                   end if;\n                end if;\n \n@@ -2145,9 +2183,10 @@ package body Sem_Ch5 is\n    -------------------------------------\n \n    procedure Analyze_Iterator_Specification (N : Node_Id) is\n-      Def_Id    : constant Node_Id := Defining_Identifier (N);\n-      Subt      : constant Node_Id := Subtype_Indication (N);\n-      Container : constant Node_Id := Name (N);\n+      Loc       : constant Source_Ptr := Sloc (N);\n+      Def_Id    : constant Node_Id    := Defining_Identifier (N);\n+      Subt      : constant Node_Id    := Subtype_Indication (N);\n+      Container : constant Node_Id    := Name (N);\n \n       Ent : Entity_Id;\n       Typ : Entity_Id;\n@@ -2160,7 +2199,43 @@ package body Sem_Ch5 is\n          Analyze (Subt);\n       end if;\n \n-      Analyze_And_Resolve (Container);\n+      --  If it is an expression, the container is pre-analyzed in the caller.\n+      --  If it it of a controlled type we need a block for the finalization\n+      --  actions. As for loop bounds that need finalization, we create a\n+      --  declaration and an assignment to trigger these actions.\n+\n+      if Present (Etype (Container))\n+        and then Is_Controlled (Etype (Container))\n+        and then not Is_Entity_Name (Container)\n+      then\n+         declare\n+            Id : constant Entity_Id := Make_Temporary (Loc, 'R', Container);\n+            Decl   : Node_Id;\n+            Assign : Node_Id;\n+\n+         begin\n+            Typ := Etype (Container);\n+\n+            Decl :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Id,\n+                Object_Definition   => New_Occurrence_Of (Typ, Loc));\n+\n+            Assign :=\n+              Make_Assignment_Statement (Loc,\n+                 Name        => New_Occurrence_Of (Id, Loc),\n+                 Expression  => Relocate_Node (Container));\n+\n+            Insert_Actions (Parent (N), New_List (Decl, Assign));\n+         end;\n+\n+      else\n+\n+         --  Container is an entity or an array with uncontrolled components\n+\n+         Analyze_And_Resolve (Container);\n+      end if;\n+\n       Typ := Etype (Container);\n \n       if Is_Array_Type (Typ) then"}]}