{"sha": "eea50aa0ab1e891b39116177f7f6eaded47ef176", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWVhNTBhYTBhYjFlODkxYjM5MTE2MTc3ZjdmNmVhZGVkNDdlZjE3Ng==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-05-17T15:00:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-05-17T15:00:35Z"}, "message": "simplify-rtx.c (simplify_subreg): Break out from ...\n\n\t* simplify-rtx.c (simplify_subreg): Break out from ...\n\t* combine.c (combine_splify_rtx) ... here and ...\n\t* recog.c (validate_replace_rtx_1): ... here;\n\t* rtl.h (subreg_lowpart_parts_p, simplify_subreg): Declare.\n\t* emit-rtl.c (subreg_lowpart_parts_p): Break out from ...\n\t(subreg_lowpart_p): ... here.\n\nFrom-SVN: r42199", "tree": {"sha": "83f417361746b3974c92d8656cd3a83d068dd204", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83f417361746b3974c92d8656cd3a83d068dd204"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eea50aa0ab1e891b39116177f7f6eaded47ef176", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eea50aa0ab1e891b39116177f7f6eaded47ef176", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eea50aa0ab1e891b39116177f7f6eaded47ef176", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eea50aa0ab1e891b39116177f7f6eaded47ef176/comments", "author": null, "committer": null, "parents": [{"sha": "5d7ef82a5dcfba9ab3d4080fd229449a9b7f2207", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d7ef82a5dcfba9ab3d4080fd229449a9b7f2207", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d7ef82a5dcfba9ab3d4080fd229449a9b7f2207"}], "stats": {"total": 551, "additions": 258, "deletions": 293}, "files": [{"sha": "d74a923d201328df38701a54b1b6de2b7dd1188c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea50aa0ab1e891b39116177f7f6eaded47ef176/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea50aa0ab1e891b39116177f7f6eaded47ef176/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eea50aa0ab1e891b39116177f7f6eaded47ef176", "patch": "@@ -1,3 +1,12 @@\n+Thu May 17 16:59:41 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* simplify-rtx.c (simplify_subreg): Break out from ...\n+\t* combine.c (combine_splify_rtx) ... here and ...\n+\t* recog.c (validate_replace_rtx_1): ... here;\n+\t* rtl.h (subreg_lowpart_parts_p, simplify_subreg): Declare.\n+\t* emit-rtl.c (subreg_lowpart_parts_p): Break out from ...\n+\t(subreg_lowpart_p): ... here.\n+\n 2001-05-17  Bernd Schmidt  <bernds@redhat.com>\n \n \t* stmt.c (expand_asm_operands): For inout operands, make sure"}, {"sha": "53df2f58c86f1f8886bfe0bc43f237ddeff48779", "filename": "gcc/combine.c", "status": "modified", "additions": 11, "deletions": 151, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea50aa0ab1e891b39116177f7f6eaded47ef176/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea50aa0ab1e891b39116177f7f6eaded47ef176/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=eea50aa0ab1e891b39116177f7f6eaded47ef176", "patch": "@@ -3765,161 +3765,21 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n       break;\n \n     case SUBREG:\n-      /* (subreg:A (mem:B X) N) becomes a modified MEM unless the SUBREG\n-\t is paradoxical.  If we can't do that safely, then it becomes\n-\t something nonsensical so that this combination won't take place.  */\n-\n-      if (GET_CODE (SUBREG_REG (x)) == MEM\n-\t  && (GET_MODE_SIZE (mode)\n-\t      <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))))\n-\t{\n-\t  rtx inner = SUBREG_REG (x);\n-\t  int offset = SUBREG_BYTE (x);\n-\t  /* Don't change the mode of the MEM\n-\t     if that would change the meaning of the address.  */\n-\t  if (MEM_VOLATILE_P (SUBREG_REG (x))\n-\t      || mode_dependent_address_p (XEXP (inner, 0)))\n-\t    return gen_rtx_CLOBBER (mode, const0_rtx);\n-\n-\t  /* Note if the plus_constant doesn't make a valid address\n-\t     then this combination won't be accepted.  */\n-\t  x = gen_rtx_MEM (mode,\n-\t\t\t   plus_constant (XEXP (inner, 0), offset));\n-\t  MEM_COPY_ATTRIBUTES (x, inner);\n-\t  return x;\n-\t}\n-\n-      /* If we are in a SET_DEST, these other cases can't apply.  */\n-      if (in_dest)\n-\treturn x;\n-\n-      /* Changing mode twice with SUBREG => just change it once,\n-\t or not at all if changing back to starting mode.  */\n-      if (GET_CODE (SUBREG_REG (x)) == SUBREG)\n-\t{\n-\t  int final_offset;\n-\t  enum machine_mode outer_mode, inner_mode;\n-\n-\t  /* If the innermost mode is the same as the goal mode,\n-\t     and the low word is being referenced in both SUBREGs,\n-\t     return the innermost element.  */\n-\t  if (mode == GET_MODE (SUBREG_REG (SUBREG_REG (x))))\n-\t    {\n-\t      int inner_word = SUBREG_BYTE (SUBREG_REG (x));\n-\t      int outer_word = SUBREG_BYTE (x);\n-\n-\t      inner_word = (inner_word / UNITS_PER_WORD) * UNITS_PER_WORD;\n-\t      outer_word = (outer_word / UNITS_PER_WORD) * UNITS_PER_WORD;\n-\t      if (inner_word == 0\n-\t\t  && outer_word == 0)\n-\t\treturn SUBREG_REG (SUBREG_REG (x));\n-\t    }\n-\n-\t  outer_mode = GET_MODE (SUBREG_REG (x));\n-\t  inner_mode = GET_MODE (SUBREG_REG (SUBREG_REG (x)));\n-\t  final_offset = SUBREG_BYTE (x) + SUBREG_BYTE (SUBREG_REG(x));\n-\n-\t  if ((WORDS_BIG_ENDIAN || BYTES_BIG_ENDIAN)\n-\t      && GET_MODE_SIZE (outer_mode) > GET_MODE_SIZE (mode)\n-\t      && GET_MODE_SIZE (outer_mode) > GET_MODE_SIZE (inner_mode))\n-\t    {\n-\t      /* Inner SUBREG is paradoxical, outer is not.  On big endian\n-\t\t we have to special case this.  */\n-\t      if (SUBREG_BYTE (SUBREG_REG (x)))\n-\t\tabort(); /* Can a paradoxical subreg have nonzero offset? */\n-\t      if (WORDS_BIG_ENDIAN && BYTES_BIG_ENDIAN)\n-\t        final_offset = SUBREG_BYTE (x) - GET_MODE_SIZE (outer_mode)\n-\t\t\t       + GET_MODE_SIZE (inner_mode);\n-\t      else if (WORDS_BIG_ENDIAN)\n-\t\tfinal_offset = (final_offset % UNITS_PER_WORD)\n-\t\t\t       + ((SUBREG_BYTE (x) - GET_MODE_SIZE (outer_mode)\n-\t\t\t\t   + GET_MODE_SIZE (inner_mode))\n-\t\t\t\t  * UNITS_PER_WORD) / UNITS_PER_WORD;\n-\t      else\n-\t\tfinal_offset = ((final_offset * UNITS_PER_WORD)\n-\t\t\t\t/ UNITS_PER_WORD)\n-\t\t\t       + ((SUBREG_BYTE (x) - GET_MODE_SIZE (outer_mode)\n-\t\t\t\t   + GET_MODE_SIZE (inner_mode))\n-\t\t\t\t  % UNITS_PER_WORD);\n-\t    }\n-\n-\t  /* The SUBREG rules are that the byte offset must be\n-\t     some multiple of the toplevel SUBREG's mode.  */\n-\t  final_offset = (final_offset / GET_MODE_SIZE (mode));\n-\t  final_offset = (final_offset * GET_MODE_SIZE (mode));\n-\n-\t  SUBST_INT (SUBREG_BYTE (x), final_offset);\n-\t  SUBST (SUBREG_REG (x), SUBREG_REG (SUBREG_REG (x)));\n-\t}\n-\n-      /* SUBREG of a hard register => just change the register number\n-\t and/or mode.  If the hard register is not valid in that mode,\n-\t suppress this combination.  If the hard register is the stack,\n-\t frame, or argument pointer, leave this as a SUBREG.  */\n-\n-      if (GET_CODE (SUBREG_REG (x)) == REG\n-\t  && REGNO (SUBREG_REG (x)) < FIRST_PSEUDO_REGISTER\n-\t  && REGNO (SUBREG_REG (x)) != FRAME_POINTER_REGNUM\n-#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-\t  && REGNO (SUBREG_REG (x)) != HARD_FRAME_POINTER_REGNUM\n-#endif\n-#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n-\t  && REGNO (SUBREG_REG (x)) != ARG_POINTER_REGNUM\n-#endif\n-\t  && REGNO (SUBREG_REG (x)) != STACK_POINTER_REGNUM)\n-\t{\n-\t  int final_regno = subreg_hard_regno (x, 0);\n+      if (op0_mode == VOIDmode)\n+\top0_mode = GET_MODE (SUBREG_REG (x));\n \n-\t  if (HARD_REGNO_MODE_OK (final_regno, mode))\n-\t    return gen_rtx_REG (mode, final_regno);\n-\t  else\n-\t    return gen_rtx_CLOBBER (mode, const0_rtx);\n-\t}\n-\n-      /* For a constant, try to pick up the part we want.  Handle a full\n-\t word and low-order part.  Only do this if we are narrowing\n-\t the constant; if it is being widened, we have no idea what\n-\t the extra bits will have been set to.  */\n-\n-      if (CONSTANT_P (SUBREG_REG (x)) && op0_mode != VOIDmode\n-\t  && GET_MODE_SIZE (mode) == UNITS_PER_WORD\n-\t  && GET_MODE_SIZE (op0_mode) > UNITS_PER_WORD\n-\t  && GET_MODE_CLASS (mode) == MODE_INT)\n-\t{\n-\t  temp = operand_subword (SUBREG_REG (x),\n-\t\t\t\t  (SUBREG_BYTE (x) / UNITS_PER_WORD),\n-\t\t\t\t  0, op0_mode);\n-\t  if (temp)\n-\t    return temp;\n-\t}\n-\n-      /* If we want a subreg of a constant, at offset 0,\n-\t take the low bits.  On a little-endian machine, that's\n-\t always valid.  On a big-endian machine, it's valid\n-\t only if the constant's mode fits in one word.   Note that we\n-\t cannot use subreg_lowpart_p since SUBREG_REG may be VOIDmode.  */\n+      /* simplify_subreg can't use gen_lowpart_for_combine.  */\n       if (CONSTANT_P (SUBREG_REG (x))\n-\t  && ((GET_MODE_SIZE (op0_mode) <= UNITS_PER_WORD\n-\t      || ! WORDS_BIG_ENDIAN)\n-\t      ? SUBREG_BYTE (x) == 0\n-\t      : (SUBREG_BYTE (x)\n-\t\t == (GET_MODE_SIZE (op0_mode) - GET_MODE_SIZE (mode))))\n-\t  && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (op0_mode)\n-\t  && (! WORDS_BIG_ENDIAN\n-\t      || GET_MODE_BITSIZE (op0_mode) <= BITS_PER_WORD))\n+\t  && subreg_lowpart_parts_p (mode, op0_mode, SUBREG_BYTE (x)))\n \treturn gen_lowpart_for_combine (mode, SUBREG_REG (x));\n \n-      /* A paradoxical SUBREG of a VOIDmode constant is the same constant,\n-\t since we are saying that the high bits don't matter.  */\n-      if (CONSTANT_P (SUBREG_REG (x)) && GET_MODE (SUBREG_REG (x)) == VOIDmode\n-\t  && GET_MODE_SIZE (mode) > GET_MODE_SIZE (op0_mode))\n-\t{\n-\t  if (GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))) > UNITS_PER_WORD\n-\t      && (WORDS_BIG_ENDIAN || SUBREG_BYTE (x) != 0))\n-\t    return constant_subword (SUBREG_REG (x), \n-\t\t\t\t     SUBREG_BYTE (x) / UNITS_PER_WORD, mode);\n-\t  return SUBREG_REG (x);\n-\t}\n+      {\n+\trtx temp;\n+\ttemp = simplify_subreg (mode, SUBREG_REG (x), op0_mode,\n+\t\t       \t\tSUBREG_BYTE (x));\n+\tif (temp)\n+\t  return temp;\n+      }\n \n       /* Note that we cannot do any narrowing for non-constants since\n \t we might have been counting on using the fact that some bits were"}, {"sha": "b22e3467380956ae23ec1934bb953454e3765044", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea50aa0ab1e891b39116177f7f6eaded47ef176/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea50aa0ab1e891b39116177f7f6eaded47ef176/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=eea50aa0ab1e891b39116177f7f6eaded47ef176", "patch": "@@ -1278,6 +1278,27 @@ gen_highpart (mode, x)\n   else\n     abort ();\n }\n+/* Return 1 iff (SUBREG:outermode (OP:innermode) byte)\n+   refers to the least significant part of its containing reg.  */\n+\n+int\n+subreg_lowpart_parts_p (outermode, innermode, byte)\n+     enum machine_mode outermode, innermode;\n+     unsigned int byte;\n+{\n+  unsigned int offset = 0;\n+  int difference = (GET_MODE_SIZE (innermode) - GET_MODE_SIZE (outermode));\n+\n+  if (difference > 0)\n+    {\n+      if (WORDS_BIG_ENDIAN)\n+\toffset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n+      if (BYTES_BIG_ENDIAN)\n+\toffset += difference % UNITS_PER_WORD;\n+    }\n+\n+  return byte == offset;\n+}\n \n /* Return 1 iff X, assumed to be a SUBREG,\n    refers to the least significant part of its containing reg.\n@@ -1296,15 +1317,8 @@ subreg_lowpart_p (x)\n   else if (GET_MODE (SUBREG_REG (x)) == VOIDmode)\n     return 0;\n \n-  if (difference > 0)\n-    {\n-      if (WORDS_BIG_ENDIAN)\n-\toffset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n-      if (BYTES_BIG_ENDIAN)\n-\toffset += difference % UNITS_PER_WORD;\n-    }\n-\n-  return SUBREG_BYTE (x) == offset;\n+  return subreg_lowpart_parts_p (GET_MODE (x), GET_MODE (SUBREG_REG (x)),\n+\t\t \t\t SUBREG_BYTE (x));\n }\n \f\n "}, {"sha": "d858394c4cdf4b75b969b1555106265adfe03200", "filename": "gcc/recog.c", "status": "modified", "additions": 14, "deletions": 133, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea50aa0ab1e891b39116177f7f6eaded47ef176/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea50aa0ab1e891b39116177f7f6eaded47ef176/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=eea50aa0ab1e891b39116177f7f6eaded47ef176", "patch": "@@ -579,145 +579,26 @@ validate_replace_rtx_1 (loc, from, to, object)\n       /* In case we are replacing by constant, attempt to simplify it to\n \t non-SUBREG expression.  We can't do this later, since the information\n \t about inner mode may be lost.  */\n-      if (CONSTANT_P (to) && rtx_equal_p (SUBREG_REG (x), from))\n+      if (rtx_equal_p (SUBREG_REG (x), from))\n         {\n-\t  int offset, part;\n-\t  unsigned HOST_WIDE_INT val;\n-\n-\t  /* A paradoxical SUBREG of a VOIDmode constant is the same constant,\n-\t     since we are saying that the high bits don't matter.  */\n-\t  if (GET_MODE (to) == VOIDmode\n-\t      && (GET_MODE_SIZE (GET_MODE (x))\n-\t\t  >= GET_MODE_SIZE (GET_MODE (from))))\n+\t  rtx temp;\n+\t  temp = simplify_subreg (GET_MODE (x), to, GET_MODE (SUBREG_REG (x)),\n+\t\t\t\t  SUBREG_BYTE (x));\n+\t  if (temp)\n \t    {\n-\t      rtx new = gen_lowpart_if_possible (GET_MODE (x), to);\n-\t      if (new)\n-\t\t{\n-\t\t  validate_change (object, loc, new, 1);\n-\t\t  return;\n-\t\t}\n-\t    }\n-\n-\t  offset = SUBREG_BYTE (x) * BITS_PER_UNIT;\n-\t  switch (GET_CODE (to))\n-\t    {\n-\t    case CONST_DOUBLE:\n-\t      if (GET_MODE (to) != VOIDmode)\n-\t\tbreak;\n-\n-\t      part = offset >= HOST_BITS_PER_WIDE_INT;\n-\t      if ((BITS_PER_WORD > HOST_BITS_PER_WIDE_INT\n-\t\t   && BYTES_BIG_ENDIAN)\n-\t\t  || (BITS_PER_WORD <= HOST_BITS_PER_WIDE_INT\n-\t\t      && WORDS_BIG_ENDIAN))\n-\t\tpart = !part;\n-\t      val = part ? CONST_DOUBLE_HIGH (to) : CONST_DOUBLE_LOW (to);\n-\t      offset %= HOST_BITS_PER_WIDE_INT;\n-\n-\t      /* FALLTHROUGH */\n-\t    case CONST_INT:\n-\t      if (GET_CODE (to) == CONST_INT)\n-\t\tval = INTVAL (to);\n-\n-\t      {\n-\t\t/* Avoid creating bogus SUBREGs */\n-\t\tenum machine_mode mode = GET_MODE (x);\n-\t\tenum machine_mode inner_mode = GET_MODE (from);\n-\n-\t\t/* We've already picked the word we want from a double, so \n-\t\t   pretend this is actually an integer.  */\n-\t\tif (GET_CODE (to) == CONST_DOUBLE)\n-\t\t  inner_mode = SImode;\n-\n-\t\tif (GET_MODE_CLASS (mode) != MODE_INT)\n-\t\t  {\n-\t\t    /* Substitute in something that we know won't be\n-\t\t       recognized.  */\n-\t\t    to = gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n-\t\t    validate_change (object, loc, to, 1);\n-\t\t    return;\n-\t\t  }\n-\n-\t\tif (BYTES_BIG_ENDIAN || WORDS_BIG_ENDIAN)\n-\t\t  {\n-\t\t    if (WORDS_BIG_ENDIAN)\n-\t\t      offset = GET_MODE_BITSIZE (inner_mode)\n-\t\t\t       - GET_MODE_BITSIZE (mode) - offset;\n-\t\t    if (BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN\n-\t\t\t&& GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n-\t\t      offset = offset + BITS_PER_WORD - GET_MODE_BITSIZE (mode)\n-\t\t\t       - 2 * (offset % BITS_PER_WORD);\n-\t\t  }\n-\n-\t\tif (offset >= HOST_BITS_PER_WIDE_INT)\n-\t\t  to = ((HOST_WIDE_INT) val < 0) ? constm1_rtx : const0_rtx;\n-\t\telse\n-\t\t  {\n-\t\t    val >>= offset;\n-\t\t    if (GET_MODE_BITSIZE (mode) < HOST_BITS_PER_WIDE_INT)\n-\t\t      val = trunc_int_for_mode (val, mode);\n-\t\t    to = GEN_INT (val);\n-\t\t  }\n-\n-\t\tvalidate_change (object, loc, to, 1);\n-\t\treturn;\n-\t      }\n-\n-\t    default:\n-\t      break;\n+\t      validate_change (object, loc, temp, 1);\n+\t      return;\n \t    }\n-        }\n-\n-      /* Changing mode twice with SUBREG => just change it once,\n-\t or not at all if changing back to starting mode.  */\n-      if (GET_CODE (to) == SUBREG\n-\t  && rtx_equal_p (SUBREG_REG (x), from))\n-\t{\n-\t  if (GET_MODE (x) == GET_MODE (SUBREG_REG (to))\n-\t      && SUBREG_BYTE (x) == 0 && SUBREG_BYTE (to) == 0)\n+\t  /* Avoid creating of invalid SUBREGS.  */\n+\t  if (GET_MODE (from) == VOIDmode)\n \t    {\n-\t      validate_change (object, loc, SUBREG_REG (to), 1);\n+\t      /* Substitute in something that we know won't be\n+\t\t recognized.  */\n+\t      to = gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n+\t      validate_change (object, loc, to, 1);\n \t      return;\n \t    }\n-\n-\t  /* Make sure the 2 byte counts added together are an even unit\n-\t     of x's mode, and combine them if so. Otherwise we run\n-\t     into problems with something like:\n-\t\t(subreg:HI (subreg:QI (SI:55) 3) 0)\n-\t     we end up with an odd offset into a HI which is invalid.  */\n-\n-\t  if (SUBREG_BYTE (to) % GET_MODE_SIZE (GET_MODE (x)) == 0)\n-\t    validate_change (object, loc,\n-\t\t\t     gen_rtx_SUBREG (GET_MODE (x), SUBREG_REG (to),\n-\t\t\t\t\t     SUBREG_BYTE(x) + SUBREG_BYTE (to)),\n-\t\t\t     1);\n-\t  else\n-\t    validate_change (object, loc, to, 1);\t\n-\n-\t  return;\n-\t}\n-\n-      /* If we have a SUBREG of a register that we are replacing and we are\n-\t replacing it with a MEM, make a new MEM and try replacing the\n-\t SUBREG with it.  Don't do this if the MEM has a mode-dependent address\n-\t or if we would be widening it.  */\n-\n-      if (GET_CODE (from) == REG\n-\t  && GET_CODE (to) == MEM\n-\t  && rtx_equal_p (SUBREG_REG (x), from)\n-\t  && ! mode_dependent_address_p (XEXP (to, 0))\n-\t  && ! MEM_VOLATILE_P (to)\n-\t  && GET_MODE_SIZE (GET_MODE (x)) <= GET_MODE_SIZE (GET_MODE (to)))\n-\t{\n-\t  int offset = SUBREG_BYTE (x);\n-\t  enum machine_mode mode = GET_MODE (x);\n-\t  rtx new;\n-\n-\t  new = gen_rtx_MEM (mode, plus_constant (XEXP (to, 0), offset));\n-\t  MEM_COPY_ATTRIBUTES (new, to);\n-\t  validate_change (object, loc, new, 1);\n-\t  return;\n-\t}\n+        }\n       break;\n \n     case ZERO_EXTRACT:"}, {"sha": "6aa86136b6f1cc877ded2d3c0a6c5c3890ffd3de", "filename": "gcc/rtl.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea50aa0ab1e891b39116177f7f6eaded47ef176/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea50aa0ab1e891b39116177f7f6eaded47ef176/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=eea50aa0ab1e891b39116177f7f6eaded47ef176", "patch": "@@ -1198,6 +1198,9 @@ extern rtx constant_subword\t\tPARAMS ((rtx, int,\n extern rtx operand_subword_force\tPARAMS ((rtx, unsigned int,\n \t\t\t\t\t\t enum machine_mode));\n extern int subreg_lowpart_p\t\tPARAMS ((rtx));\n+extern int subreg_lowpart_parts_p\tPARAMS ((enum machine_mode,\n+\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t unsigned int));\n extern rtx make_safe_from\t\tPARAMS ((rtx, rtx));\n extern rtx convert_memory_address\tPARAMS ((enum machine_mode, rtx));\n extern rtx get_insns\t\t\tPARAMS ((void));\n@@ -1324,6 +1327,10 @@ extern rtx simplify_gen_relational\tPARAMS ((enum rtx_code,\n \t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t rtx, rtx));\n+extern rtx simplify_subreg\t\tPARAMS ((enum machine_mode,\n+\t\t\t\t\t\t rtx,\n+\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t unsigned int));\n extern rtx simplify_replace_rtx\t\tPARAMS ((rtx, rtx, rtx));\n extern rtx simplify_rtx\t\t\tPARAMS ((rtx));\n "}, {"sha": "c4dee23c9a928dbade952b7bbb7fdb0aeaf5ac2a", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eea50aa0ab1e891b39116177f7f6eaded47ef176/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eea50aa0ab1e891b39116177f7f6eaded47ef176/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=eea50aa0ab1e891b39116177f7f6eaded47ef176", "patch": "@@ -2186,6 +2186,200 @@ simplify_ternary_operation (code, mode, op0_mode, op0, op1, op2)\n   return 0;\n }\n \n+/* Simplify SUBREG:OUTERMODE(OP:INNERMODE, BYTE)\n+   Return 0 if no simplifications is possible.  */\n+rtx\n+simplify_subreg (outermode, op, innermode, byte)\n+     rtx op;\n+     unsigned int byte;\n+     enum machine_mode outermode, innermode;\n+{\n+  /* Little bit of sanity checking.  */\n+  if (innermode == VOIDmode || outermode == VOIDmode\n+      || innermode == BLKmode || outermode == BLKmode)\n+    abort ();\n+\n+  if (GET_MODE (op) != innermode\n+      && GET_MODE (op) != VOIDmode)\n+    abort ();\n+\n+  if (byte % GET_MODE_SIZE (outermode)\n+      || byte >= GET_MODE_SIZE (innermode))\n+    abort ();\n+\n+  /* Attempt to simplify constant to non-SUBREG expression.  */\n+  if (CONSTANT_P (op))\n+    {\n+      int offset, part;\n+      unsigned HOST_WIDE_INT val;\n+\n+      /* ??? This code is partly redundant with code bellow, but can handle\n+\t the subregs of floats and similar corner cases.\n+\t Later it we should move all simplification code here and rewrite\n+\t GEN_LOWPART_IF_POSSIBLE, GEN_HIGHPART, OPERAND_SUBWORD and friends\n+\t using SIMPLIFY_SUBREG.  */\n+      if (subreg_lowpart_parts_p (outermode, innermode, byte))\n+\t{\n+\t  rtx new = gen_lowpart_if_possible (outermode, op);\n+\t  if (new)\n+\t    return new;\n+\t}\n+\n+      /* Similar comment as above apply here.  */\n+      if (GET_MODE_SIZE (outermode) == UNITS_PER_WORD\n+\t  && GET_MODE_SIZE (innermode) > UNITS_PER_WORD\n+\t  && GET_MODE_CLASS (outermode) == MODE_INT)\n+\t{\n+\t  rtx new = operand_subword (op,\n+\t\t\t\t     (byte / UNITS_PER_WORD),\n+\t\t\t\t     0, innermode);\n+\t  if (new)\n+\t    return new;\n+\t}\n+\n+      offset = byte * BITS_PER_UNIT;\n+      switch (GET_CODE (op))\n+\t{\n+\tcase CONST_DOUBLE:\n+\t  if (GET_MODE (op) != VOIDmode)\n+\t    break;\n+\n+\t  /* We can't handle this case yet.  */\n+\t  if (GET_MODE_BITSIZE (outermode) >= HOST_BITS_PER_WIDE_INT)\n+\t    return NULL;\n+\n+\t  part = offset >= HOST_BITS_PER_WIDE_INT;\n+\t  if ((BITS_PER_WORD > HOST_BITS_PER_WIDE_INT\n+\t       && BYTES_BIG_ENDIAN)\n+\t      || (BITS_PER_WORD <= HOST_BITS_PER_WIDE_INT\n+\t\t  && WORDS_BIG_ENDIAN))\n+\t    part = !part;\n+\t  val = part ? CONST_DOUBLE_HIGH (op) : CONST_DOUBLE_LOW (op);\n+\t  offset %= HOST_BITS_PER_WIDE_INT;\n+\n+\t  /* We've already picked the word we want from a double, so \n+\t     pretend this is actually an integer.  */\n+\t  innermode = mode_for_size (HOST_BITS_PER_WIDE_INT, MODE_INT, 0);\n+\n+\t  /* FALLTHROUGH */\n+\tcase CONST_INT:\n+\t  if (GET_CODE (op) == CONST_INT)\n+\t    val = INTVAL (op);\n+\n+\t  /* We don't handle synthetizing of non-integral constants yet.  */\n+\t  if (GET_MODE_CLASS (outermode) != MODE_INT)\n+\t    return NULL;\n+\n+\t  if (BYTES_BIG_ENDIAN || WORDS_BIG_ENDIAN)\n+\t    {\n+\t      if (WORDS_BIG_ENDIAN)\n+\t\toffset = (GET_MODE_BITSIZE (innermode)\n+\t\t\t  - GET_MODE_BITSIZE (outermode) - offset);\n+\t      if (BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN\n+\t\t  && GET_MODE_SIZE (outermode) < UNITS_PER_WORD)\n+\t\toffset = (offset + BITS_PER_WORD - GET_MODE_BITSIZE (outermode)\n+\t\t\t  - 2 * (offset % BITS_PER_WORD));\n+\t    }\n+\n+\t  if (offset >= HOST_BITS_PER_WIDE_INT)\n+\t    return ((HOST_WIDE_INT) val < 0) ? constm1_rtx : const0_rtx;\n+\t  else\n+\t    {\n+\t      val >>= offset;\n+\t      if (GET_MODE_BITSIZE (outermode) < HOST_BITS_PER_WIDE_INT)\n+\t\tval = trunc_int_for_mode (val, outermode);\n+\t      return GEN_INT (val);\n+\t    }\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  /* Changing mode twice with SUBREG => just change it once,\n+     or not at all if changing back op starting mode.  */\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      enum machine_mode innermostmode = GET_MODE (SUBREG_REG (op));\n+      unsigned int final_offset = byte + SUBREG_BYTE (op);\n+      rtx new;\n+\n+      if (outermode == innermostmode\n+\t  && byte == 0 && SUBREG_BYTE (op) == 0)\n+\treturn SUBREG_REG (op);\n+\n+      if ((WORDS_BIG_ENDIAN || BYTES_BIG_ENDIAN)\n+\t  && GET_MODE_SIZE (innermode) > GET_MODE_SIZE (outermode)\n+\t  && GET_MODE_SIZE (innermode) > GET_MODE_SIZE (innermostmode))\n+\t{\n+\t  /* Inner SUBREG is paradoxical, outer is not.  On big endian\n+\t     we have to special case this.  */\n+\t  if (SUBREG_BYTE (op))\n+\t    abort(); /* Can a paradoxical subreg have nonzero offset? */\n+\t  if (WORDS_BIG_ENDIAN && BYTES_BIG_ENDIAN)\n+\t    final_offset = (byte - GET_MODE_SIZE (innermode)\n+\t\t\t    + GET_MODE_SIZE (innermostmode));\n+\t  else if (WORDS_BIG_ENDIAN)\n+\t    final_offset = ((final_offset % UNITS_PER_WORD)\n+\t\t\t    + ((byte - GET_MODE_SIZE (innermode)\n+\t\t\t        + GET_MODE_SIZE (innermostmode))\n+\t\t\t       * UNITS_PER_WORD) / UNITS_PER_WORD);\n+\t  else\n+\t    final_offset = (((final_offset * UNITS_PER_WORD)\n+\t\t\t     / UNITS_PER_WORD)\n+\t\t\t    + ((byte - GET_MODE_SIZE (innermode)\n+\t\t\t        + GET_MODE_SIZE (innermostmode))\n+\t\t\t       % UNITS_PER_WORD));\n+\t}\n+\n+      /* Recurse for futher possible simplifications.  */\n+      new = simplify_subreg (outermode, op, GET_MODE (op),\n+\t\t\t     final_offset);\n+      if (new)\n+\treturn new;\n+      return gen_rtx_SUBREG (outermode, op, final_offset);\n+    }\n+\n+  /* SUBREG of a hard register => just change the register number\n+     and/or mode.  If the hard register is not valid in that mode,\n+     suppress this simplification.  If the hard register is the stack,\n+     frame, or argument pointer, leave this as a SUBREG.  */\n+\n+  if (REG_P (op) == REG\n+      && REGNO (op) < FIRST_PSEUDO_REGISTER\n+      && REGNO (op) != FRAME_POINTER_REGNUM\n+#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n+      && REGNO (op) != HARD_FRAME_POINTER_REGNUM\n+#endif\n+#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n+      && REGNO (op) != ARG_POINTER_REGNUM\n+#endif\n+      && REGNO (op) != STACK_POINTER_REGNUM)\n+    {\n+      int final_regno = subreg_hard_regno (gen_rtx_SUBREG (outermode, op, byte),\n+\t\t\t\t\t   0);\n+\n+      if (HARD_REGNO_MODE_OK (final_regno, outermode))\n+\treturn gen_rtx_REG (outermode, final_regno);\n+    }\n+\n+  /* If we have a SUBREG of a register that we are replacing and we are\n+     replacing it with a MEM, make a new MEM and try replacing the\n+     SUBREG with it.  Don't do this if the MEM has a mode-dependent address\n+     or if we would be widening it.  */\n+\n+  if (GET_CODE (op) == MEM\n+      && ! mode_dependent_address_p (XEXP (op, 0))\n+      && ! MEM_VOLATILE_P (op)\n+      && GET_MODE_SIZE (outermode) <= GET_MODE_SIZE (GET_MODE (op)))\n+    {\n+      rtx new;\n+\n+      new = gen_rtx_MEM (outermode, plus_constant (XEXP (op, 0), byte));\n+      MEM_COPY_ATTRIBUTES (new, op);\n+      return new;\n+    }\n+  return NULL_RTX;\n+}\n /* Simplify X, an rtx expression.\n \n    Return the simplified expression or NULL if no simplifications"}]}