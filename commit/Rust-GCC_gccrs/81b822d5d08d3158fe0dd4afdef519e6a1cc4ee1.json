{"sha": "81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFiODIyZDVkMDhkMzE1OGZlMGRkNGFmZGVmNTE5ZTZhMWNjNGVlMQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2008-12-11T07:23:02Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2008-12-11T07:23:02Z"}, "message": "Fix testsuite/gfortran.dg/graphite/id-4.f90.\n\n2008-12-11  Sebastian Pop  <sebastian.pop@amd.com>\n\n\tFix testsuite/gfortran.dg/graphite/id-4.f90.\n\t* graphite.c (scan_tree_for_params): Do not compute the multiplicand\n\twhen not needed.\n\n2008-12-11  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* graphite.c (build_scops_1): Initialize open_scop.exit\n\tand sinfo.last.\n\n2008-12-11  Sebastian Pop  <sebastian.pop@amd.com>\n\t    Jan Sjodin  <jan.sjodin@amd.com>\n            Harsha Jagasia  <harsha.jagasia@amd.com>\n\n\tPR middle-end/37852\n\tPR middle-end/37883\n\tPR middle-end/37928\n\tPR middle-end/37980\n\tPR middle-end/38038\n\tPR middle-end/38039\n\tPR middle-end/38073\n\tPR middle-end/38083\n\tPR middle-end/38125\n\n\t* tree-phinodes.c (remove_phi_nodes): New, extracted from...\n\t* tree-cfg.c (remove_phi_nodes_and_edges_for_unreachable_block): ...here.\n\t* tree-flow.h (remove_phi_nodes, canonicalize_loop_ivs): Declared.\n\t* Makefile.in (graphite.o): Depend on value-prof.h.\n\t(graphite.o-warn): Removed -Wno-error.\n\t* tree-parloops.c (canonicalize_loop_ivs): Allow reduction_list \n\tto be a NULL pointer.  Call update_stmt.  Return the newly created \n\tcannonical induction variable.\n\n\t* graphite.h (debug_rename_map): Declared.  Fix some comments.\n\n\t* graphite.c: Reimplement the code generation from graphite to gimple.\n\tInclude value-prof.h.\n\t(loop_iv_stack_get_iv): Do not return NULL for constant substitutions.\n\t(get_old_iv_from_ssa_name): Removed.\n\t(graphite_stmt_p): New.\n\t(new_graphite_bb): Test for useful statements before building a\n\tgraphite statement for the basic block.\n\t(free_graphite_bb): Do not free GBB_DATA_REFS: this is a bug\n\tin free_data_ref that calls BITMAP_FREE (DR_VOPS (dr)) without \n\treason.\n\t(recompute_all_dominators, graphite_verify,\n\tnb_reductions_in_loop, graphite_loop_normal_form): New.\n\t(scop_record_loop): Call graphite_loop_normal_form.\n\t(build_scop_loop_nests): Iterate over all the blocks of the\n\tfunction instead of relying on the incomplete information from\n\tSCOP_BBS.  Return the success of the operation.\n\t(find_params_in_bb): Use the data from GBB_DATA_REFS.\n\t(add_bb_domains): Removed.\n\t(build_loop_iteration_domains): Don't call add_bb_domains.\n\tAdd the iteration domain only to the basic blocks that have been\n\ttranslated to graphite.\n\t(build_scop_conditions_1): Add constraints only if the basic\n\tblock have been translated to graphite.\n\t(build_scop_data_accesses): Completely disabled until data\n\tdependence is correctly implemented.\n\t(debug_rename_elt, debug_rename_map_1, debug_rename_map): New.\n\t(remove_all_edges_1, remove_all_edges): Removed.\n\t(get_new_name_from_old_name): New.\n\t(graphite_rename_variables_in_stmt): Renamed \n\trename_variables_in_stmt.  Call get_new_name_from_old_name.\n\tUse replace_exp\tand update_stmt.\n\t(is_old_iv): Renamed is_iv.\n\t(expand_scalar_variables_stmt): Extra parameter for renaming map.\n\tUse replace_exp\tand update_stmt.\n\t(expand_scalar_variables_expr): Same.  Use the map to get the\n\tnew names for the renaming of induction variables and for the\n\trenaming of variables after a basic block has been copied.\n\t(expand_scalar_variables): Same.\n\t(graphite_rename_variables): Renamed rename_variables.\n\t(move_phi_nodes): Removed.\n\t(get_false_edge_from_guard_bb): New.\n\t(build_iv_mapping): Do not insert the induction variable of a\n\tloop in the renaming iv map if the basic block does not belong\n\tto that loop.\n\t(register_old_new_names, graphite_copy_stmts_from_block,\n\tcopy_bb_and_scalar_dependences): New.\n\t(translate_clast): Heavily reimplemented: copy basic blocks,\n\tdo not move them.  Finally, in call cleanup_tree_cfg in gloog.\n\tAt each translation step call graphite_verify ensuring the \n\tconsistency of the SSA, loops and dominators information.\n\t(collect_virtual_phis, find_vdef_for_var_in_bb,\n\tfind_vdef_for_var_1, find_vdef_for_var,\n\tpatch_phis_for_virtual_defs): Removed huge hack.\n\t(mark_old_loops, remove_dead_loops, skip_phi_defs,\n\tcollect_scop_exit_phi_args, patch_scop_exit_phi_args,\n\tgbb_can_be_ignored, scop_remove_ignoreable_gbbs, ): Removed.\n\t(remove_sese_region, ifsese, if_region_entry, if_region_exit,\n\tif_region_get_condition_block, if_region_set_false_region,\n\tcreate_if_region_on_edge, move_sese_in_condition, bb_in_sese_p,\n\tsese_find_uses_to_rename_use, sese_find_uses_to_rename_bb, \n\tsese_add_exit_phis_edge, sese_add_exit_phis_var,\n\trewrite_into_sese_closed_ssa): New.\n\t(gloog): Remove dead code.  Early return if code cannot be\n\tgenerated.  Call cleanup_tree_cfg once the scop has been code\n\tgenerated.\n\t(graphite_trans_scop_block, graphite_trans_loop_block): Do not \n\tblock loops with less than two loops.\n\t(graphite_apply_transformations): Remove the call to\n\tscop_remove_ignoreable_gbbs.\n\t(limit_scops): When build_scop_loop_nests fails, continue on next scop.\n\tFix open_scop.entry.\n\t(graphite_transform_loops): Call recompute_all_dominators: force the\n\trecomputation of correct CDI_DOMINATORS and CDI_POST_DOMINATORS.\n\tCall initialize_original_copy_tables and free_original_copy_tables\n\tto be able to copy basic blocks during code generation.\n\tWhen build_scop_loop_nests fails, continue on next scop.\n\t(value_clast): New union.\n\t(clast_to_gcc_expression): Fix type cast warning.\n\n2008-12-11  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* gcc.dg/graphite/pr37928.c: New.\n\t* gcc.dg/graphite/pr37883.c: New.\n\t* gcc.dg/graphite/pr38073.c: New.\n\t* gcc.dg/graphite/pr38125.c: New.\n\t* gfortran.dg/graphite/pr38083.f90: New.\n\t* gfortran.dg/graphite/pr37852.f90: New.\n\t* gfortran.dg/graphite/pr37980.f90: New.\n\t* gfortran.dg/graphite/id-2.f90: New.\n\t* gfortran.dg/graphite/id-4.f90: New.\n\n\t* gcc.dg/graphite/scop-18.c: Remove reduction, test for\n\tthe number of detected scops.  Copy exact same test for loop blocking...\n\t* gcc.dg/graphite/block-1.c: Fix the number of expected loops\n\tto be blocked as reductions are not handled.\n\t* gcc.dg/graphite/block-4.c: ...here.  New.\n\nFrom-SVN: r142673", "tree": {"sha": "a02cd497cb9f8579437709e693e9974ce83ae3de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a02cd497cb9f8579437709e693e9974ce83ae3de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/comments", "author": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "564a6431e96e1cc68ccd106dcfe88f9299e56af1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/564a6431e96e1cc68ccd106dcfe88f9299e56af1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/564a6431e96e1cc68ccd106dcfe88f9299e56af1"}], "stats": {"total": 2114, "additions": 1329, "deletions": 785}, "files": [{"sha": "f51730a1f4b4cf36a9f5c14eb744a333a324b97f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 115, "deletions": 2, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "patch": "@@ -1,3 +1,118 @@\n+2008-12-11  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tFix testsuite/gfortran.dg/graphite/id-4.f90.\n+\t* graphite.c (scan_tree_for_params): Do not compute the multiplicand\n+\twhen not needed.\n+\n+2008-12-11  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* graphite.c (build_scops_1): Initialize open_scop.exit\n+\tand sinfo.last.\n+\n+2008-12-11  Sebastian Pop  <sebastian.pop@amd.com>\n+\t    Jan Sjodin  <jan.sjodin@amd.com>\n+            Harsha Jagasia  <harsha.jagasia@amd.com>\n+\n+\tPR middle-end/37852\n+\tPR middle-end/37883\n+\tPR middle-end/37928\n+\tPR middle-end/37980\n+\tPR middle-end/38038\n+\tPR middle-end/38039\n+\tPR middle-end/38073\n+\tPR middle-end/38083\n+\tPR middle-end/38125\n+\n+\t* tree-phinodes.c (remove_phi_nodes): New, extracted from...\n+\t* tree-cfg.c (remove_phi_nodes_and_edges_for_unreachable_block): ...here.\n+\t* tree-flow.h (remove_phi_nodes, canonicalize_loop_ivs): Declared.\n+\t* Makefile.in (graphite.o): Depend on value-prof.h.\n+\t(graphite.o-warn): Removed -Wno-error.\n+\t* tree-parloops.c (canonicalize_loop_ivs): Allow reduction_list \n+\tto be a NULL pointer.  Call update_stmt.  Return the newly created \n+\tcannonical induction variable.\n+\n+\t* graphite.h (debug_rename_map): Declared.  Fix some comments.\n+\n+\t* graphite.c: Reimplement the code generation from graphite to gimple.\n+\tInclude value-prof.h.\n+\t(loop_iv_stack_get_iv): Do not return NULL for constant substitutions.\n+\t(get_old_iv_from_ssa_name): Removed.\n+\t(graphite_stmt_p): New.\n+\t(new_graphite_bb): Test for useful statements before building a\n+\tgraphite statement for the basic block.\n+\t(free_graphite_bb): Do not free GBB_DATA_REFS: this is a bug\n+\tin free_data_ref that calls BITMAP_FREE (DR_VOPS (dr)) without \n+\treason.\n+\t(recompute_all_dominators, graphite_verify,\n+\tnb_reductions_in_loop, graphite_loop_normal_form): New.\n+\t(scop_record_loop): Call graphite_loop_normal_form.\n+\t(build_scop_loop_nests): Iterate over all the blocks of the\n+\tfunction instead of relying on the incomplete information from\n+\tSCOP_BBS.  Return the success of the operation.\n+\t(find_params_in_bb): Use the data from GBB_DATA_REFS.\n+\t(add_bb_domains): Removed.\n+\t(build_loop_iteration_domains): Don't call add_bb_domains.\n+\tAdd the iteration domain only to the basic blocks that have been\n+\ttranslated to graphite.\n+\t(build_scop_conditions_1): Add constraints only if the basic\n+\tblock have been translated to graphite.\n+\t(build_scop_data_accesses): Completely disabled until data\n+\tdependence is correctly implemented.\n+\t(debug_rename_elt, debug_rename_map_1, debug_rename_map): New.\n+\t(remove_all_edges_1, remove_all_edges): Removed.\n+\t(get_new_name_from_old_name): New.\n+\t(graphite_rename_variables_in_stmt): Renamed \n+\trename_variables_in_stmt.  Call get_new_name_from_old_name.\n+\tUse replace_exp\tand update_stmt.\n+\t(is_old_iv): Renamed is_iv.\n+\t(expand_scalar_variables_stmt): Extra parameter for renaming map.\n+\tUse replace_exp\tand update_stmt.\n+\t(expand_scalar_variables_expr): Same.  Use the map to get the\n+\tnew names for the renaming of induction variables and for the\n+\trenaming of variables after a basic block has been copied.\n+\t(expand_scalar_variables): Same.\n+\t(graphite_rename_variables): Renamed rename_variables.\n+\t(move_phi_nodes): Removed.\n+\t(get_false_edge_from_guard_bb): New.\n+\t(build_iv_mapping): Do not insert the induction variable of a\n+\tloop in the renaming iv map if the basic block does not belong\n+\tto that loop.\n+\t(register_old_new_names, graphite_copy_stmts_from_block,\n+\tcopy_bb_and_scalar_dependences): New.\n+\t(translate_clast): Heavily reimplemented: copy basic blocks,\n+\tdo not move them.  Finally, in call cleanup_tree_cfg in gloog.\n+\tAt each translation step call graphite_verify ensuring the \n+\tconsistency of the SSA, loops and dominators information.\n+\t(collect_virtual_phis, find_vdef_for_var_in_bb,\n+\tfind_vdef_for_var_1, find_vdef_for_var,\n+\tpatch_phis_for_virtual_defs): Removed huge hack.\n+\t(mark_old_loops, remove_dead_loops, skip_phi_defs,\n+\tcollect_scop_exit_phi_args, patch_scop_exit_phi_args,\n+\tgbb_can_be_ignored, scop_remove_ignoreable_gbbs, ): Removed.\n+\t(remove_sese_region, ifsese, if_region_entry, if_region_exit,\n+\tif_region_get_condition_block, if_region_set_false_region,\n+\tcreate_if_region_on_edge, move_sese_in_condition, bb_in_sese_p,\n+\tsese_find_uses_to_rename_use, sese_find_uses_to_rename_bb, \n+\tsese_add_exit_phis_edge, sese_add_exit_phis_var,\n+\trewrite_into_sese_closed_ssa): New.\n+\t(gloog): Remove dead code.  Early return if code cannot be\n+\tgenerated.  Call cleanup_tree_cfg once the scop has been code\n+\tgenerated.\n+\t(graphite_trans_scop_block, graphite_trans_loop_block): Do not \n+\tblock loops with less than two loops.\n+\t(graphite_apply_transformations): Remove the call to\n+\tscop_remove_ignoreable_gbbs.\n+\t(limit_scops): When build_scop_loop_nests fails, continue on next scop.\n+\tFix open_scop.entry.\n+\t(graphite_transform_loops): Call recompute_all_dominators: force the\n+\trecomputation of correct CDI_DOMINATORS and CDI_POST_DOMINATORS.\n+\tCall initialize_original_copy_tables and free_original_copy_tables\n+\tto be able to copy basic blocks during code generation.\n+\tWhen build_scop_loop_nests fails, continue on next scop.\n+\t(value_clast): New union.\n+\t(clast_to_gcc_expression): Fix type cast warning.\n+\n 2008-12-10  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/36792\n@@ -261,8 +376,6 @@\n \tFix testsuite/gfortran.dg/graphite/id-3.f90.\n \t* graphite.c (scopdet_basic_block_info): Fix bug that found some\n \tregions more than once.\n-\t* testsuite/gfortran.dg/graphite/id-3.f90: New.\n-\t* gcc/testsuite/gcc.dg/graphite/pr38084.c: New.\n \n 2008-12-09  Ben Elliston  <bje@au.ibm.com>\n "}, {"sha": "644694b6adbf1607df98afc20b4050e7428f6be6", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "patch": "@@ -183,8 +183,6 @@ dfp.o-warn = -Wno-error\n bitmap.o-warn = -Wno-error\n # dominance.c contains a -Wc++compat warning.\n dominance.o-warn = -Wno-error\n-# graphite.c contains code calling cloog that has problems.\n-graphite.o-warn = -Wno-error\n # mips-tfile.c contains -Wcast-qual warnings.\n mips-tfile.o-warn = -Wno-error\n \n@@ -2368,7 +2366,8 @@ tree-data-ref.o: tree-data-ref.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n graphite.o: graphite.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TOPLEV_H) \\\n    $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) $(GIMPLE_H) domwalk.h \\\n-   $(TREE_DATA_REF_H) $(SCEV_H) tree-pass.h tree-chrec.h graphite.h pointer-set.h\n+   $(TREE_DATA_REF_H) $(SCEV_H) tree-pass.h tree-chrec.h graphite.h pointer-set.h \\\n+   value-prof.h\n tree-vect-analyze.o: tree-vect-analyze.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(OPTABS_H) $(TREE_H) $(RECOG_H) $(BASIC_BLOCK_H) \\\n    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\"}, {"sha": "7c2b8da90b97187451154177322a4373d8d85bb7", "filename": "gcc/graphite.c", "status": "modified", "additions": 866, "deletions": 730, "changes": 1596, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "patch": "@@ -51,6 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"tree-pass.h\"\n #include \"domwalk.h\"\n+#include \"value-prof.h\"\n #include \"pointer-set.h\"\n #include \"gimple.h\"\n \n@@ -167,13 +168,9 @@ static tree\n loop_iv_stack_get_iv (loop_iv_stack stack, int index)\n {\n   iv_stack_entry_p entry = VEC_index (iv_stack_entry_p, *stack, index);\n+  iv_stack_entry_data data = entry->data;\n \n-  tree result = NULL;\n-\n-  if (entry->kind != iv_stack_entry_const)\n-    result = entry->data.iv->t;\n-\n-  return result;\n+  return iv_stack_entry_is_iv (entry) ? data.iv->t : data.constant;\n }\n \n /* Get the IV from its NAME in STACK.  */\n@@ -293,33 +290,6 @@ loop_iv_stack_remove_constants (loop_iv_stack stack)\n     }\n }\n \n-/* In SCOP, get the induction variable from NAME.  OLD is the original\n-   loop that contained the definition of NAME.  */\n-\n-static name_tree\n-get_old_iv_from_ssa_name (scop_p scop, loop_p old, tree name)\n-{\n-  tree var = SSA_NAME_VAR (name);\n-  int i;\n-  name_tree oldiv;\n-  \n-  for (i = 0; VEC_iterate (name_tree, SCOP_OLDIVS (scop), i, oldiv); i++)\n-    {\n-      loop_p current = old;\n-\n-      while (current)\n-\t{\n-\t  if (var == oldiv->t\n-\t      && oldiv->loop == current)\n-\t    return oldiv;\n-\n-\t  current = loop_outer (current);\n-\t}\n-    }\n-  return NULL;\n-\n-}\n-\n /* Returns a new loop_to_cloog_loop_str structure.  */\n \n static inline struct loop_to_cloog_loop_str *\n@@ -610,14 +580,6 @@ debug_scops (int verbosity)\n   print_scops (stderr, verbosity);\n }\n \n-/* Return true when BB is contained in SCOP.  */\n-\n-static inline bool\n-bb_in_scop_p (basic_block bb, scop_p scop)\n-{\n-  return bitmap_bit_p (SCOP_BBS_B (scop), bb->index);\n-}\n-\n /* Pretty print to FILE the SCOP in DOT format.  */\n \n static void \n@@ -818,15 +780,6 @@ dot_all_scops (void)\n #endif\n }\n \n-/* Returns true when LOOP is in SCOP.  */\n-\n-static inline bool \n-loop_in_scop_p (struct loop *loop, scop_p scop)\n-{\n-  return (bb_in_scop_p (loop->header, scop)\n-\t  && bb_in_scop_p (loop->latch, scop));\n-}\n-\n /* Returns the outermost loop in SCOP that contains BB.  */\n \n static struct loop *\n@@ -1025,23 +978,85 @@ harmful_stmt_in_bb (basic_block scop_entry, basic_block bb)\n   return NULL;\n }\n \n+/* Returns true when BB will be represented in graphite.  Return false\n+   for the basic blocks that contain code eliminated in the code\n+   generation pass: i.e. induction variables and exit conditions.  */\n+\n+static bool\n+graphite_stmt_p (scop_p scop, basic_block bb,\n+\t\t VEC (data_reference_p, heap) *drs)\n+{\n+  gimple_stmt_iterator gsi;\n+  loop_p loop = bb->loop_father;\n+\n+  if (VEC_length (data_reference_p, drs) > 0)\n+    return true;\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n+\n+      switch (gimple_code (stmt))\n+        {\n+          /* Control flow expressions can be ignored, as they are\n+             represented in the iteration domains and will be\n+             regenerated by graphite.  */\n+\tcase GIMPLE_COND:\n+\tcase GIMPLE_GOTO:\n+\tcase GIMPLE_SWITCH:\n+\t  break;\n+\n+\tcase GIMPLE_ASSIGN:\n+\t  {\n+\t    tree var = gimple_assign_lhs (stmt);\n+\t    var = analyze_scalar_evolution (loop, var);\n+\t    var = instantiate_scev (block_before_scop (scop), loop, var);\n+\n+\t    if (chrec_contains_undetermined (var))\n+\t      return true;\n+\n+\t    break;\n+\t  }\n+\n+\tdefault:\n+\t  return true;\n+        }\n+    }\n+\n+  return false;\n+}\n+\n /* Store the GRAPHITE representation of BB.  */\n \n static void\n new_graphite_bb (scop_p scop, basic_block bb)\n {\n-  struct graphite_bb *gbb = XNEW (struct graphite_bb);\n+  struct graphite_bb *gbb;\n+  VEC (data_reference_p, heap) *drs = VEC_alloc (data_reference_p, heap, 5);\n+  struct loop *nest = outermost_loop_in_scop (scop, bb);\n+  gimple_stmt_iterator gsi;\n+\n+  bitmap_set_bit (SCOP_BBS_B (scop), bb->index);\n \n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    find_data_references_in_stmt (nest, gsi_stmt (gsi), &drs);\n+\n+  if (!graphite_stmt_p (scop, bb, drs))\n+    {\n+      free_data_refs (drs);\n+      return;\n+    }\n+\n+  gbb = XNEW (struct graphite_bb);\n   bb->aux = gbb;\n   GBB_BB (gbb) = bb;\n   GBB_SCOP (gbb) = scop;\n-  GBB_DATA_REFS (gbb) = NULL; \n+  GBB_DATA_REFS (gbb) = drs;\n   GBB_DOMAIN (gbb) = NULL;\n   GBB_CONDITIONS (gbb) = NULL;\n   GBB_CONDITION_CASES (gbb) = NULL;\n   GBB_LOOPS (gbb) = NULL;\n   VEC_safe_push (graphite_bb_p, heap, SCOP_BBS (scop), gbb);\n-  bitmap_set_bit (SCOP_BBS_B (scop), bb->index);\n }\n \n /* Frees GBB.  */\n@@ -1052,11 +1067,9 @@ free_graphite_bb (struct graphite_bb *gbb)\n   if (GBB_DOMAIN (gbb))\n     cloog_matrix_free (GBB_DOMAIN (gbb));\n \n-  free_data_refs (GBB_DATA_REFS (gbb));\n   VEC_free (gimple, heap, GBB_CONDITIONS (gbb));\n   VEC_free (gimple, heap, GBB_CONDITION_CASES (gbb));\n   VEC_free (loop_p, heap, GBB_LOOPS (gbb));\n-\n   GBB_BB (gbb)->aux = 0;\n   XDELETE (gbb);\n }\n@@ -1078,6 +1091,7 @@ new_scop (edge entry, edge exit)\n   SCOP_BBS_B (scop) = BITMAP_ALLOC (NULL);\n   SCOP_LOOPS (scop) = BITMAP_ALLOC (NULL);\n   SCOP_LOOP_NEST (scop) = VEC_alloc (loop_p, heap, 3);\n+  SCOP_ADD_PARAMS (scop) = true;\n   SCOP_PARAMS (scop) = VEC_alloc (name_tree, heap, 3);\n   SCOP_PROG (scop) = cloog_program_malloc ();\n   cloog_program_set_names (SCOP_PROG (scop), cloog_names_malloc ());\n@@ -1511,6 +1525,8 @@ build_scops_1 (basic_block current, VEC (sd_region, heap) **scops, loop_p loop)\n   result.next = NULL;\n   result.last = NULL;\n   open_scop.entry = NULL;\n+  open_scop.exit = NULL;\n+  sinfo.last = NULL;\n \n   /* Loop over the dominance tree.  If we meet a difficult bb, close\n      the current SCoP.  Loop and condition header start a new layer,\n@@ -1799,6 +1815,29 @@ mark_exit_edges (VEC (sd_region, heap) *regions)\n \te->aux = s;\n }\n \n+/* Free and compute again all the dominators information.  */\n+\n+static inline void\n+recompute_all_dominators (void)\n+{\n+  free_dominance_info (CDI_DOMINATORS);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n+}\n+\n+/* Verifies properties that GRAPHITE should maintain during translation.  */\n+\n+static inline void\n+graphite_verify (void)\n+{\n+#ifdef ENABLE_CHECKING\n+  verify_loop_structure ();\n+  verify_dominators (CDI_DOMINATORS);\n+  verify_dominators (CDI_POST_DOMINATORS);\n+  verify_ssa (false);\n+#endif\n+}\n \n /* Create for all scop regions a single entry and a single exit edge.  */\n \n@@ -1937,64 +1976,108 @@ build_scop_bbs (scop_p scop)\n   sbitmap_free (visited);\n }\n \n+/* Returns the number of reduction phi nodes in LOOP.  */\n+\n+static int\n+nb_reductions_in_loop (loop_p loop)\n+{\n+  int res = 0;\n+  gimple_stmt_iterator gsi;\n \n-/* Record LOOP as occuring in SCOP.  */\n+  for (gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple phi = gsi_stmt (gsi);\n+      tree scev;\n \n-static void\n-scop_record_loop (scop_p scop, struct loop *loop)\n+      if (!is_gimple_reg (PHI_RESULT (phi)))\n+\tcontinue;\n+\n+      scev = analyze_scalar_evolution (loop, PHI_RESULT (phi));\n+      scev = instantiate_parameters (loop, scev);\n+      if (chrec_contains_undetermined (scev))\n+\tres++;\n+    }\n+\n+  return res;\n+}\n+\n+/* A LOOP is in normal form when it contains only one scalar phi node\n+   that defines the main induction variable of the loop, only one\n+   increment of the IV, and only one exit condition. */\n+\n+static tree\n+graphite_loop_normal_form (loop_p loop)\n {\n-  loop_p parent;\n-  tree induction_var;\n+  struct tree_niter_desc niter;\n+  tree nit;\n+  gimple_seq stmts;\n+  edge exit = single_dom_exit (loop);\n \n-  if (bitmap_bit_p (SCOP_LOOPS (scop), loop->num))\n-    return;\n+  if (!number_of_iterations_exit (loop, exit, &niter, false))\n+    gcc_unreachable ();\n \n-  parent = loop_outer (loop);\n-  induction_var = find_induction_var_from_exit_cond (loop);\n+  nit = force_gimple_operand (unshare_expr (niter.niter), &stmts, true,\n+\t\t\t      NULL_TREE);\n+  if (stmts)\n+    gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);\n \n-  if (!bb_in_scop_p (parent->latch, scop))\n-    parent = NULL;\n+  /* One IV per loop.  */\n+  if (nb_reductions_in_loop (loop) > 0)\n+    return NULL_TREE;\n \n-  if (induction_var != NULL_TREE)\n-    {\n-      name_tree oldiv = XNEW (struct name_tree);\n-      oldiv->t = SSA_NAME_VAR (induction_var);\n-      if (DECL_NAME (oldiv->t))\n-\toldiv->name = IDENTIFIER_POINTER (DECL_NAME (oldiv->t));\n-      else\n-\t{\n-\t  int len = 2 + 16;\n-\t  char *n = XNEWVEC (char, len);\n-\t  snprintf (n, len, \"D.%u\", DECL_UID (oldiv->t));\n-\t  oldiv->name = n;\n-\t}\n-      oldiv->loop = loop;\n+  return canonicalize_loop_ivs (loop, NULL, nit);\n+}\n \n-      VEC_safe_push (name_tree, heap, SCOP_OLDIVS (scop), oldiv);\n-    }\n+/* Record LOOP as occuring in SCOP.  Returns true when the operation\n+   was successful.  */\n+\n+static bool\n+scop_record_loop (scop_p scop, loop_p loop)\n+{\n+  tree induction_var;\n+  name_tree oldiv;\n+\n+  if (bitmap_bit_p (SCOP_LOOPS (scop), loop->num))\n+    return true;\n \n   bitmap_set_bit (SCOP_LOOPS (scop), loop->num);\n   VEC_safe_push (loop_p, heap, SCOP_LOOP_NEST (scop), loop);\n+\n+  induction_var = graphite_loop_normal_form (loop);\n+  if (!induction_var)\n+    return false;\n+\n+  oldiv = XNEW (struct name_tree);\n+  oldiv->t = induction_var;\n+  oldiv->name = get_name (SSA_NAME_VAR (oldiv->t));\n+  oldiv->loop = loop;\n+  VEC_safe_push (name_tree, heap, SCOP_OLDIVS (scop), oldiv);\n+  return true;\n }\n \n-/* Build the loop nests contained in SCOP.  */\n+/* Build the loop nests contained in SCOP.  Returns true when the\n+   operation was successful.  */\n \n-static void\n+static bool\n build_scop_loop_nests (scop_p scop)\n {\n   unsigned i;\n-  graphite_bb_p gb;\n+  basic_block bb;\n   struct loop *loop0, *loop1;\n \n-  for (i = 0; VEC_iterate (graphite_bb_p, SCOP_BBS (scop), i, gb); i++)\n-    {\n-      struct loop *loop = gbb_loop (gb);\n+  FOR_EACH_BB (bb)\n+    if (bb_in_scop_p (bb, scop))\n+      {\n+\tstruct loop *loop = bb->loop_father;\n \n-      /* Only add loops, if they are completely contained in the SCoP.  */\n-      if (loop->header == GBB_BB (gb)\n-\t  && bb_in_scop_p (loop->latch, scop))\n-        scop_record_loop (scop, gbb_loop (gb));\n-    }\n+\t/* Only add loops if they are completely contained in the SCoP.  */\n+\tif (loop->header == bb\n+\t    && bb_in_scop_p (loop->latch, scop))\n+\t  {\n+\t    if (!scop_record_loop (scop, loop))\n+\t      return false;\n+\t  }\n+      }\n \n   /* Make sure that the loops in the SCOP_LOOP_NEST are ordered.  It\n      can be the case that an inner loop is inserted before an outer\n@@ -2011,20 +2094,37 @@ build_scop_loop_nests (scop_p scop)\n \t  VEC_replace (loop_p, SCOP_LOOP_NEST (scop), i + 1, loop0);\n \t}\n     }\n+\n+  return true;\n }\n \n-/* Calculate the number of loops around GB in the current SCOP.  */\n+/* Build dynamic schedules for all the BBs. */\n \n-static inline int\n-nb_loops_around_gb (graphite_bb_p gb)\n+static void\n+build_scop_dynamic_schedules (scop_p scop)\n {\n-  scop_p scop = GBB_SCOP (gb);\n-  struct loop *l = gbb_loop (gb);\n-  int d = 0;\n+  int i, dim, loop_num, row, col;\n+  graphite_bb_p gb;\n \n-  for (; loop_in_scop_p (l, scop); d++, l = loop_outer (l));\n+  for (i = 0; VEC_iterate (graphite_bb_p, SCOP_BBS (scop), i, gb); i++)\n+    {\n+      loop_num = GBB_BB (gb)->loop_father->num;\n \n-  return d;\n+      if (loop_num != 0)\n+        {\n+          dim = nb_loops_around_gb (gb);\n+          GBB_DYNAMIC_SCHEDULE (gb) = cloog_matrix_alloc (dim, dim);\n+\n+          for (row = 0; row < GBB_DYNAMIC_SCHEDULE (gb)->NbRows; row++)\n+            for (col = 0; col < GBB_DYNAMIC_SCHEDULE (gb)->NbColumns; col++)\n+              if (row == col)\n+                value_set_si (GBB_DYNAMIC_SCHEDULE (gb)->p[row][col], 1);\n+              else\n+                value_set_si (GBB_DYNAMIC_SCHEDULE (gb)->p[row][col], 0);\n+        }\n+      else\n+        GBB_DYNAMIC_SCHEDULE (gb) = NULL;\n+    }\n }\n \n /* Build for BB the static schedule.\n@@ -2138,6 +2238,8 @@ param_index (tree var, scop_p scop)\n     if (p->t == var)\n       return i;\n \n+  gcc_assert (SCOP_ADD_PARAMS (scop));\n+\n   nvar = XNEW (struct name_tree);\n   nvar->t = var;\n   nvar->name = NULL;\n@@ -2217,26 +2319,28 @@ scan_tree_for_params (scop_p s, tree e, CloogMatrix *c, int r, Value k,\n     case MULT_EXPR:\n       if (chrec_contains_symbols (TREE_OPERAND (e, 0)))\n \t{\n-\t  Value val;\n-\n-\t  gcc_assert (host_integerp (TREE_OPERAND (e, 1), 0));\n-\n-\t  value_init (val);\n-\t  value_set_si (val, int_cst_value (TREE_OPERAND (e, 1)));\n-\t  value_multiply (k, k, val);\n-\t  value_clear (val);\n+\t  if (c)\n+\t    {\n+\t      Value val;\n+\t      gcc_assert (host_integerp (TREE_OPERAND (e, 1), 0));\n+\t      value_init (val);\n+\t      value_set_si (val, int_cst_value (TREE_OPERAND (e, 1)));\n+\t      value_multiply (k, k, val);\n+\t      value_clear (val);\n+\t    }\n \t  scan_tree_for_params (s, TREE_OPERAND (e, 0), c, r, k, subtract);\n \t}\n       else\n \t{\n-\t  Value val;\n-\n-\t  gcc_assert (host_integerp (TREE_OPERAND (e, 0), 0));\n-\n-\t  value_init (val);\n-\t  value_set_si (val, int_cst_value (TREE_OPERAND (e, 0)));\n-\t  value_multiply (k, k, val);\n-\t  value_clear (val);\n+\t  if (c)\n+\t    {\n+\t      Value val;\n+\t      gcc_assert (host_integerp (TREE_OPERAND (e, 0), 0));\n+\t      value_init (val);\n+\t      value_set_si (val, int_cst_value (TREE_OPERAND (e, 0)));\n+\t      value_multiply (k, k, val);\n+\t      value_clear (val);\n+\t    }\n \t  scan_tree_for_params (s, TREE_OPERAND (e, 1), c, r, k, subtract);\n \t}\n       break;\n@@ -2347,58 +2451,44 @@ idx_record_params (tree base, tree *idx, void *dta)\n    access functions, conditions and loop bounds.  */\n \n static void\n-find_params_in_bb (scop_p scop, basic_block bb)\n+find_params_in_bb (scop_p scop, graphite_bb_p gb)\n {\n   int i;\n   data_reference_p dr;\n-  VEC (data_reference_p, heap) *drs;\n-  gimple_stmt_iterator gsi;\n-  struct loop *nest = outermost_loop_in_scop (scop, bb);\n-\n-  /* Find the parameters used in the memory access functions.  */\n-  drs = VEC_alloc (data_reference_p, heap, 5);\n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    find_data_references_in_stmt (nest, gsi_stmt (gsi), &drs);\n+  gimple stmt;\n+  loop_p father = GBB_BB (gb)->loop_father;\n \n-  for (i = 0; VEC_iterate (data_reference_p, drs, i, dr); i++)\n+  for (i = 0; VEC_iterate (data_reference_p, GBB_DATA_REFS (gb), i, dr); i++)\n     {\n       struct irp_data irp;\n \n-      irp.loop = bb->loop_father;\n+      irp.loop = father;\n       irp.scop = scop;\n       for_each_index (&dr->ref, idx_record_params, &irp);\n       free_data_ref (dr);\n     }\n \n-  VEC_free (data_reference_p, heap, drs);\n-\n   /* Find parameters in conditional statements.  */ \n-  gsi = gsi_last_bb (bb);\n-  if (!gsi_end_p (gsi))\n+  for (i = 0; VEC_iterate (gimple, GBB_CONDITIONS (gb), i, stmt); i++)\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      Value one;\n+      loop_p loop = father;\n \n-      if (gimple_code (stmt) == GIMPLE_COND)\n-        {\n-          Value one;\n-          loop_p loop = bb->loop_father;\n-\n-          tree lhs, rhs;\n-          \n-          lhs = gimple_cond_lhs (stmt);\n-          lhs = analyze_scalar_evolution (loop, lhs);\n-          lhs = instantiate_scev (block_before_scop (scop), loop, lhs);\n-\n-          rhs = gimple_cond_rhs (stmt);\n-          rhs = analyze_scalar_evolution (loop, rhs);\n-          rhs = instantiate_scev (block_before_scop (scop), loop, rhs);\n-\n-          value_init (one);\n-          scan_tree_for_params (scop, lhs, NULL, 0, one, false);\n-          value_set_si (one, 1);\n-          scan_tree_for_params (scop, rhs, NULL, 0, one, false);\n-          value_clear (one);\n-       }\n+      tree lhs, rhs;\n+\n+      lhs = gimple_cond_lhs (stmt);\n+      lhs = analyze_scalar_evolution (loop, lhs);\n+      lhs = instantiate_scev (block_before_scop (scop), loop, lhs);\n+\n+      rhs = gimple_cond_rhs (stmt);\n+      rhs = analyze_scalar_evolution (loop, rhs);\n+      rhs = instantiate_scev (block_before_scop (scop), loop, rhs);\n+\n+      value_init (one);\n+      scan_tree_for_params (scop, lhs, NULL, 0, one, false);\n+      value_set_si (one, 1);\n+      scan_tree_for_params (scop, rhs, NULL, 0, one, false);\n+      value_clear (one);\n     }\n }\n \n@@ -2522,7 +2612,9 @@ find_scop_parameters (scop_p scop)\n \n   /* Find the parameters used in data accesses.  */\n   for (i = 0; VEC_iterate (graphite_bb_p, SCOP_BBS (scop), i, gb); i++)\n-    find_params_in_bb (scop, GBB_BB (gb));\n+    find_params_in_bb (scop, gb);\n+\n+  SCOP_ADD_PARAMS (scop) = false;\n }\n \n /* Build the context constraints for SCOP: constraints and relations\n@@ -2554,24 +2646,6 @@ gbb_from_bb (basic_block bb)\n   return (graphite_bb_p) bb->aux;\n }\n \n-/* Add DOMAIN to all the basic blocks in LOOP.  */\n-\n-static void\n-add_bb_domains (struct loop *loop, CloogMatrix *domain)\n-{\n-  basic_block *bbs = get_loop_body (loop);\n-  unsigned i;\n-\n-  for (i = 0; i < loop->num_nodes; i++)\n-    if (bbs[i]->loop_father == loop)\n-      {\n-        graphite_bb_p gbb = gbb_from_bb (bbs[i]);\n-        GBB_DOMAIN (gbb) = cloog_matrix_copy (domain);\n-      }\n-\n-  free (bbs);\n-}\n-\n /* Builds the constraint matrix for LOOP in SCOP.  NB_OUTER_LOOPS is the\n    number of loops surrounding LOOP in SCOP.  OUTER_CSTR gives the\n    constraints matrix for the surrounding loops.  */\n@@ -2582,6 +2656,7 @@ build_loop_iteration_domains (scop_p scop, struct loop *loop,\n {\n   int i, j, row;\n   CloogMatrix *cstr;\n+  graphite_bb_p gb;\n \n   int nb_rows = outer_cstr->NbRows + 1;\n   int nb_cols = outer_cstr->NbColumns + 1;\n@@ -2662,7 +2737,9 @@ build_loop_iteration_domains (scop_p scop, struct loop *loop,\n   if (nb_outer_loops != 0 && loop->next && loop_in_scop_p (loop->next, scop))\n     build_loop_iteration_domains (scop, loop->next, outer_cstr, nb_outer_loops);\n \n-  add_bb_domains (loop, cstr);\n+  for (i = 0; VEC_iterate (graphite_bb_p, SCOP_BBS (scop), i, gb); i++)\n+    if (gbb_loop (gb) == loop)\n+      GBB_DOMAIN (gb) = cloog_matrix_copy (cstr);\n \n   cloog_matrix_free (cstr);\n }\n@@ -2884,10 +2961,12 @@ build_scop_conditions_1 (VEC (gimple, heap) **conditions,\n \n   /* Record conditions in graphite_bb.  */\n   gbb = gbb_from_bb (bb);\n-  GBB_CONDITIONS (gbb) = VEC_copy (gimple, heap, *conditions);\n-  GBB_CONDITION_CASES (gbb) = VEC_copy (gimple, heap, *cases);\n-\n-  add_conditions_to_domain (gbb);\n+  if (gbb)\n+    {\n+      GBB_CONDITIONS (gbb) = VEC_copy (gimple, heap, *conditions);\n+      GBB_CONDITION_CASES (gbb) = VEC_copy (gimple, heap, *cases);\n+      add_conditions_to_domain (gbb);\n+    }\n \n   dom = get_dominated_by (CDI_DOMINATORS, bb);\n \n@@ -3049,27 +3128,31 @@ build_scop_iteration_domain (scop_p scop)\n }\n \n /* Initializes an equation CY of the access matrix using the\n-   information for a subscript from ACCESS_FUN, relatively to the loop\n+   information for a subscript from AF, relatively to the loop\n    indexes from LOOP_NEST and parameter indexes from PARAMS.  NDIM is\n    the dimension of the array access, i.e. the number of\n    subscripts.  Returns true when the operation succeeds.  */\n \n static bool\n-build_access_matrix_with_af (tree access_fun, lambda_vector cy,\n+build_access_matrix_with_af (tree af, lambda_vector cy,\n \t\t\t     scop_p scop, int ndim)\n {\n-  switch (TREE_CODE (access_fun))\n+  int param_col;\n+\n+  switch (TREE_CODE (af))\n     {\n     case POLYNOMIAL_CHREC:\n       {\n-\ttree left = CHREC_LEFT (access_fun);\n-\ttree right = CHREC_RIGHT (access_fun);\n+        struct loop *outer_loop;\n+\ttree left = CHREC_LEFT (af);\n+\ttree right = CHREC_RIGHT (af);\n \tint var;\n \n \tif (TREE_CODE (right) != INTEGER_CST)\n \t  return false;\n-        \n-\tvar = loop_iteration_vector_dim (CHREC_VARIABLE (access_fun), scop);\n+\n+        outer_loop = get_loop (CHREC_VARIABLE (af));\n+        var = nb_loops_around_loop_in_scop (outer_loop, scop);\n \tcy[var] = int_cst_value (right);\n \n \tswitch (TREE_CODE (left))\n@@ -3082,12 +3165,27 @@ build_access_matrix_with_af (tree access_fun, lambda_vector cy,\n \t    return true;\n \n \t  default:\n-\t    /* FIXME: access_fn can have parameters.  */\n-\t    return false;\n+\t    return build_access_matrix_with_af (left, cy, scop, ndim);\n \t  }\n       }\n+\n+    case PLUS_EXPR:\n+      build_access_matrix_with_af (TREE_OPERAND (af, 0), cy, scop, ndim);\n+      build_access_matrix_with_af (TREE_OPERAND (af, 1), cy, scop, ndim);\n+      return true;\n+      \n+    case MINUS_EXPR:\n+      build_access_matrix_with_af (TREE_OPERAND (af, 0), cy, scop, ndim);\n+      build_access_matrix_with_af (TREE_OPERAND (af, 1), cy, scop, ndim);\n+      return true;\n+\n     case INTEGER_CST:\n-      cy[ndim - 1] = int_cst_value (access_fun);\n+      cy[ndim - 1] = int_cst_value (af);\n+      return true;\n+\n+    case SSA_NAME:\n+      param_col = param_index (af, scop);      \n+      cy [ndim - scop_nb_params (scop) + param_col - 1] = 1; \n       return true;\n \n     default:\n@@ -3133,23 +3231,14 @@ build_scop_data_accesses (scop_p scop)\n   int i;\n   graphite_bb_p gb;\n \n+  /* FIXME: Construction of access matrix is disabled until some\n+     pass, like the data dependence analysis, is using it.  */\n+  return;\n+\n   for (i = 0; VEC_iterate (graphite_bb_p, SCOP_BBS (scop), i, gb); i++)\n     {\n       int j;\n-      gimple_stmt_iterator gsi;\n       data_reference_p dr;\n-      struct loop *nest = outermost_loop_in_scop (scop, GBB_BB (gb));\n-\n-      /* On each statement of the basic block, gather all the occurences\n-\t to read/write memory.  */\n-      GBB_DATA_REFS (gb) = VEC_alloc (data_reference_p, heap, 5);\n-      for (gsi = gsi_start_bb (GBB_BB (gb)); !gsi_end_p (gsi); gsi_next (&gsi))\n-\tfind_data_references_in_stmt (nest, gsi_stmt (gsi),\n-\t\t\t\t      &GBB_DATA_REFS (gb));\n-\n-      /* FIXME: Construction of access matrix is disabled until some\n-\t pass, like the data dependence analysis, is using it.  */\n-      continue;\n \n       /* Construct the access matrix for each data ref, with respect to\n \t the loop nest of the current BB in the considered SCOP.  */\n@@ -3199,6 +3288,13 @@ clast_name_to_gcc (const char *name, VEC (name_tree, heap) *params,\n   gcc_unreachable ();\n }\n \n+/* A union needed to convert from CLAST expressions to GMP values.  */\n+\n+typedef union {\n+  struct clast_expr *c;\n+  Value v;\n+} value_clast;\n+\n /* Converts a Cloog AST expression E back to a GCC expression tree.   */\n \n static tree\n@@ -3299,15 +3395,12 @@ clast_to_gcc_expression (struct clast_expr *e,\n       {\n \tstruct clast_binary *b = (struct clast_binary *) e;\n \tstruct clast_expr *lhs = (struct clast_expr *) b->LHS;\n-\tstruct clast_expr *rhs = (struct clast_expr *) b->RHS;\n \ttree tl = clast_to_gcc_expression (lhs, params, ivstack);\n+\tvalue_clast r;\n+\ttree tr;\n \n-\t/* FIXME: The next statement produces a warning: Cloog assumes\n-\t   that the RHS is a constant, but this is a \"void *\" pointer\n-\t   that should be casted into a Value, but this cast cannot be\n-\t   done as Value is a GMP type, that is an array.  Cloog must\n-\t   be fixed for removing this warning.  */\n-\ttree tr = gmp_cst_to_tree (rhs);\n+\tr.c = (struct clast_expr *) b->RHS;\n+\ttr = gmp_cst_to_tree (r.v);\n \n \tswitch (b->type)\n \t  {\n@@ -3426,97 +3519,149 @@ graphite_create_new_loop (scop_p scop, edge entry_edge,\n   return loop;\n }\n \n-/* Remove all the edges from EDGES except the edge KEEP.  */\n-\n-static void\n-remove_all_edges_1 (VEC (edge, gc) *edges, edge keep)\n+/* Structure containing the mapping between the old names and the new\n+   names used after block copy in the new loop context.  */\n+typedef struct rename_map_elt\n {\n-  edge e;\n-  edge_iterator ei;\n+  tree old_name, new_name;\n+} *rename_map_elt;\n \n-  for (ei = ei_start (edges); (e = ei_safe_edge (ei)); )\n-    {\n-      if (e != keep)\n-\t{\n-\t  remove_edge (e);\n-\t  e = ei_safe_edge (ei);\n-\t}\n-      else\n-\tei_next (&ei);\n-    }\n-}\n \n-/* Remove all the edges from BB except the edge KEEP.  */\n+/* Print to stderr the element ELT.  */\n \n static void\n-remove_all_edges (basic_block bb, edge keep)\n+debug_rename_elt (rename_map_elt elt)\n {\n-  remove_all_edges_1 (bb->succs, keep);\n-  remove_all_edges_1 (bb->preds, keep);\n+  fprintf (stderr, \"(\");\n+  print_generic_expr (stderr, elt->old_name, 0);\n+  fprintf (stderr, \", \");\n+  print_generic_expr (stderr, elt->new_name, 0);\n+  fprintf (stderr, \")\\n\");\n }\n \n-/* Rename the SSA_NAMEs used in STMT and that appear in IVSTACK.  */\n+/* Helper function for debug_rename_map.  */\n \n-static void \n-graphite_rename_ivs_stmt (gimple stmt, graphite_bb_p gbb, scop_p scop,\n-\t\t\t  loop_p old, loop_iv_stack ivstack)\n+static int\n+debug_rename_map_1 (void **slot, void *s ATTRIBUTE_UNUSED)\n {\n-  ssa_op_iter iter;\n-  use_operand_p use_p;\n+  struct rename_map_elt *entry = (struct rename_map_elt *) *slot;\n+  debug_rename_elt (entry);\n+  return 1;\n+}\n \n-  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n-    {\n-      tree use = USE_FROM_PTR (use_p);\n-      tree new_iv = NULL;\n-      name_tree old_iv = get_old_iv_from_ssa_name (scop, old, use);\n-      \n-      if (old_iv)\n-\tnew_iv = loop_iv_stack_get_iv (ivstack,\n-\t\t\t\t       gbb_loop_index (gbb, old_iv->loop));\n+/* Print to stderr all the elements of MAP.  */\n \n-      if (new_iv)\n-\tSET_USE (use_p, new_iv);\n-    }\n+void\n+debug_rename_map (htab_t map)\n+{\n+  htab_traverse (map, debug_rename_map_1, NULL);\n }\n \n-/* Returns true if SSA_NAME is a parameter of SCOP.  */\n+/* Constructs a new SCEV_INFO_STR structure for VAR and INSTANTIATED_BELOW.  */\n \n-static bool\n-is_parameter (scop_p scop, tree ssa_name)\n+static inline rename_map_elt\n+new_rename_map_elt (tree old_name, tree new_name)\n {\n-  int i;\n-  VEC (name_tree, heap) *params = SCOP_PARAMS (scop);\n-  name_tree param;\n+  rename_map_elt res;\n+  \n+  res = XNEW (struct rename_map_elt);\n+  res->old_name = old_name;\n+  res->new_name = new_name;\n \n-  for (i = 0; VEC_iterate (name_tree, params, i, param); i++)\n-    if (param->t == ssa_name)\n-      return true;\n+  return res;\n+}\n \n-  return false;\n+/* Computes a hash function for database element ELT.  */\n+\n+static hashval_t\n+rename_map_elt_info (const void *elt)\n+{\n+  return htab_hash_pointer (((const struct rename_map_elt *) elt)->old_name);\n }\n \n-/* Returns true if NAME is an old induction variable in SCOP.  OLD is\n-   the original loop that contained the definition of NAME.  */\n+/* Compares database elements E1 and E2.  */\n \n-static bool\n-is_old_iv (scop_p scop, loop_p old, tree name)\n+static int\n+eq_rename_map_elts (const void *e1, const void *e2)\n {\n-  return get_old_iv_from_ssa_name (scop, old, name) != NULL;\n+  const struct rename_map_elt *elt1 = (const struct rename_map_elt *) e1;\n+  const struct rename_map_elt *elt2 = (const struct rename_map_elt *) e2;\n \n+  return (elt1->old_name == elt2->old_name);\n }\n \n-static void expand_scalar_variables_stmt (gimple, graphite_bb_p, scop_p, loop_p,\n-\t\t\t\t\t  loop_iv_stack);\n+/* Returns the new name associated to OLD_NAME in MAP.  */\n \n-/* Constructs a tree which only contains old_ivs and parameters.  Any\n-   other variables that are defined outside GBB will be eliminated by\n-   using their definitions in the constructed tree.  OLD_LOOP_FATHER\n-   is the original loop that contained GBB.  */\n+static tree\n+get_new_name_from_old_name (htab_t map, tree old_name)\n+{\n+  struct rename_map_elt tmp;\n+  PTR *slot;\n+\n+  tmp.old_name = old_name;\n+  slot = htab_find_slot (map, &tmp, NO_INSERT);\n+\n+  if (slot && *slot)\n+    return ((rename_map_elt) *slot)->new_name;\n+\n+  return old_name;\n+}\n+\n+/* Rename the SSA_NAMEs used in STMT and that appear in IVSTACK.  */\n+\n+static void \n+rename_variables_in_stmt (gimple stmt, htab_t map)\n+{\n+  ssa_op_iter iter;\n+  use_operand_p use_p;\n+\n+  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n+    {\n+      tree use = USE_FROM_PTR (use_p);\n+      tree new_name = get_new_name_from_old_name (map, use);\n+\n+      replace_exp (use_p, new_name);\n+    }\n+\n+  update_stmt (stmt);\n+}\n+\n+/* Returns true if SSA_NAME is a parameter of SCOP.  */\n+\n+static bool\n+is_parameter (scop_p scop, tree ssa_name)\n+{\n+  int i;\n+  VEC (name_tree, heap) *params = SCOP_PARAMS (scop);\n+  name_tree param;\n+\n+  for (i = 0; VEC_iterate (name_tree, params, i, param); i++)\n+    if (param->t == ssa_name)\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Returns true if NAME is an induction variable.  */\n+\n+static bool\n+is_iv (tree name)\n+{\n+  return gimple_code (SSA_NAME_DEF_STMT (name)) == GIMPLE_PHI;\n+}\n+\n+static void expand_scalar_variables_stmt (gimple, basic_block, scop_p,\n+\t\t\t\t\t  loop_p, htab_t);\n+\n+/* Constructs a tree which only contains old_ivs and parameters.  Any\n+   other variables that are defined outside BB will be eliminated by\n+   using their definitions in the constructed tree.  OLD_LOOP_FATHER\n+   is the original loop that contained BB.  */\n \n static tree\n expand_scalar_variables_expr (tree type, tree op0, enum tree_code code, \n-\t\t\t      tree op1, graphite_bb_p gbb, scop_p scop, \n-\t\t\t      loop_p old_loop_father, loop_iv_stack ivstack)\n+\t\t\t      tree op1, basic_block bb, scop_p scop, \n+\t\t\t      loop_p old_loop_father, htab_t map)\n {\n   if ((TREE_CODE_CLASS (code) == tcc_constant\n        && code == INTEGER_CST)\n@@ -3529,8 +3674,7 @@ expand_scalar_variables_expr (tree type, tree op0, enum tree_code code,\n       enum tree_code op0_code = TREE_CODE (op0);\n       tree op0_expr = \n \texpand_scalar_variables_expr (op0_type, op0, op0_code,\n-\t\t\t\t      NULL, gbb, scop, old_loop_father,\n-\t\t\t\t      ivstack);\n+\t\t\t\t      NULL, bb, scop, old_loop_father, map);\n \n       return fold_build1 (code, type, op0_expr);\n     }\n@@ -3541,14 +3685,12 @@ expand_scalar_variables_expr (tree type, tree op0, enum tree_code code,\n       enum tree_code op0_code = TREE_CODE (op0);\n       tree op0_expr = \n \texpand_scalar_variables_expr (op0_type, op0, op0_code,\n-\t\t\t\t      NULL, gbb, scop, old_loop_father,\n-\t\t\t\t      ivstack);\n+\t\t\t\t      NULL, bb, scop, old_loop_father, map);\n       tree op1_type = TREE_TYPE (op1);\n       enum tree_code op1_code = TREE_CODE (op1);\n       tree op1_expr = \n \texpand_scalar_variables_expr (op1_type, op1, op1_code,\n-\t\t\t\t      NULL, gbb, scop, old_loop_father,\n-\t\t\t\t      ivstack);\n+\t\t\t\t      NULL, bb, scop, old_loop_father, map);\n \n       return fold_build2 (code, type, op0_expr, op1_expr);\n     }\n@@ -3559,34 +3701,34 @@ expand_scalar_variables_expr (tree type, tree op0, enum tree_code code,\n       gimple def_stmt;\n       enum tree_code subcode;\n       \n-      if(is_parameter (scop, op0) ||\n-\t is_old_iv (scop, old_loop_father, op0))\n-\treturn op0;\n+      if (is_parameter (scop, op0)\n+\t  || is_iv (op0))\n+\treturn get_new_name_from_old_name (map, op0);\n       \n       def_stmt = SSA_NAME_DEF_STMT (op0);\n       \n-      if (gimple_bb (def_stmt) == GBB_BB (gbb))\n+      if (gimple_bb (def_stmt) == bb)\n \t{\n \t  /* If the defining statement is in the basic block already\n \t     we do not need to create a new expression for it, we\n \t     only need to ensure its operands are expanded.  */\n-\t  expand_scalar_variables_stmt (def_stmt, gbb, scop,\n-\t\t\t\t\told_loop_father, ivstack);\n-\t  return op0;\n+\t  expand_scalar_variables_stmt (def_stmt, bb, scop,\n+\t\t\t\t\told_loop_father, map);\n+\t  return get_new_name_from_old_name (map, op0);\n \t  \n \t}\n       else\n \t{\n-\t  if (gimple_code (def_stmt) != GIMPLE_ASSIGN)\n-\t    return op0;\n+\t  if (gimple_code (def_stmt) != GIMPLE_ASSIGN\n+\t      || !bb_in_scop_p (gimple_bb (def_stmt), scop))\n+\t    return get_new_name_from_old_name (map, op0);\n \t  \n \t  var0 = gimple_assign_rhs1 (def_stmt);\n \t  subcode = gimple_assign_rhs_code (def_stmt);\n \t  var1 = gimple_assign_rhs2 (def_stmt);\n \t  \n-\t  return expand_scalar_variables_expr (type, var0, subcode, var1, \n-\t\t\t\t\t       gbb, scop, old_loop_father, \n-\t\t\t\t\t       ivstack);\n+\t  return expand_scalar_variables_expr (type, var0, subcode, var1,\n+\t\t\t\t\t       bb, scop, old_loop_father, map);\n \t}\n     }\n \n@@ -3595,106 +3737,66 @@ expand_scalar_variables_expr (tree type, tree op0, enum tree_code code,\n }\n \n /* Replicates any uses of non-parameters and non-old-ivs variablesthat\n-   are defind outside GBB with code that is inserted in GBB.\n+   are defind outside BB with code that is inserted in BB.\n    OLD_LOOP_FATHER is the original loop that contained STMT.  */\n  \n static void\n-expand_scalar_variables_stmt (gimple stmt, graphite_bb_p gbb, scop_p scop,\n-\t\t\t      loop_p old_loop_father, loop_iv_stack ivstack)\n+expand_scalar_variables_stmt (gimple stmt, basic_block bb, scop_p scop,\n+\t\t\t      loop_p old_loop_father, htab_t map)\n {\n   ssa_op_iter iter;\n   use_operand_p use_p;\n-  basic_block bb = GBB_BB (gbb);\n \n   FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n     {\n       tree use = USE_FROM_PTR (use_p);\n       tree type = TREE_TYPE (use);\n       enum tree_code code  = TREE_CODE (use);\n-      tree use_expr = expand_scalar_variables_expr (type, use, code, NULL,\n-\t\t\t\t\t\t    gbb, scop, old_loop_father, \n-\t\t\t\t\t\t    ivstack);\n+      tree use_expr = expand_scalar_variables_expr (type, use, code, NULL, bb,\n+\t\t\t\t\t\t    scop, old_loop_father, map);\n       if (use_expr != use)\n \t{\n \t  gimple_stmt_iterator gsi = gsi_after_labels (bb);\n \t  tree new_use =\n \t    force_gimple_operand_gsi (&gsi, use_expr, true, NULL,\n \t\t\t\t      true, GSI_NEW_STMT);\n-\t  SET_USE (use_p, new_use);\n+\t  replace_exp (use_p, new_use);\n \t}\n     }\n+\n+  update_stmt (stmt);\n }\n \n-/* Copies the definitions outside of GBB of variables that are not\n-   induction variables nor parameters. GBB must only contain\n+/* Copies the definitions outside of BB of variables that are not\n+   induction variables nor parameters.  BB must only contain\n    \"external\" references to these types of variables.  OLD_LOOP_FATHER\n-   is the original loop that contained GBB.  */\n+   is the original loop that contained BB.  */\n \n static void \n-expand_scalar_variables (graphite_bb_p gbb, scop_p scop, \n-\t\t\t loop_p old_loop_father, loop_iv_stack ivstack)\n+expand_scalar_variables (basic_block bb, scop_p scop, \n+\t\t\t loop_p old_loop_father, htab_t map)\n {\n-  basic_block bb = GBB_BB (gbb);\n   gimple_stmt_iterator gsi;\n   \n   for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi);)\n     {\n       gimple stmt = gsi_stmt (gsi);\n-      expand_scalar_variables_stmt (stmt, gbb, scop, old_loop_father, \n-\t\t\t\t    ivstack); \n+      expand_scalar_variables_stmt (stmt, bb, scop, old_loop_father, map);\n       gsi_next (&gsi);\n     }\n }\n \n-/* Rename all the SSA_NAMEs from block GBB that appear in IVSTACK in\n-   terms of new induction variables.  OLD_LOOP_FATHER is the original\n-   loop that contained GBB.  */\n+/* Rename all the SSA_NAMEs from block BB that appear in IVSTACK in\n+   terms of new induction variables.  OLD is the original loop that\n+   contained BB.  */\n \n static void \n-graphite_rename_ivs (graphite_bb_p gbb, scop_p scop, loop_p old_loop_father,\n-\t\t     loop_iv_stack ivstack)\n+rename_variables (basic_block bb, htab_t map)\n {\n-  basic_block bb = GBB_BB (gbb);\n   gimple_stmt_iterator gsi;\n   \n-  for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi);)\n-    {\n-      gimple stmt = gsi_stmt (gsi);\n-\n-      if (gimple_get_lhs (stmt)\n-\t  && TREE_CODE (gimple_get_lhs (stmt)) == SSA_NAME\n-\t  && get_old_iv_from_ssa_name (scop, old_loop_father,\n-\t\t\t\t       gimple_get_lhs (stmt)))\n-\tgsi_remove (&gsi, false);\n-      else\n-\t{\n-\t  graphite_rename_ivs_stmt (stmt, gbb, scop, old_loop_father, ivstack); \n-\t  gsi_next (&gsi);\n-\t}\n-    }\n-}\n-\n-/* Move all the PHI nodes from block FROM to block TO.\n-   OLD_LOOP_FATHER is the original loop that contained FROM.  */\n-\n-static void\n-move_phi_nodes (scop_p scop, loop_p old_loop_father, basic_block from,\n-\t\tbasic_block to)\n-{\n-  gimple_stmt_iterator gsi;\n-\n-  for (gsi = gsi_start_phis (from); !gsi_end_p (gsi);)\n-    {\n-      gimple phi = gsi_stmt (gsi);\n-      tree op = gimple_phi_result (phi);\n-\n-      if (get_old_iv_from_ssa_name (scop, old_loop_father, op) == NULL)\n-\t{\n-\t  gimple new_phi = make_phi_node (op, 0);\n-\t  add_phi_node_to_bb (new_phi, to);\n-\t}\n-      remove_phi_node (&gsi, false);\n-    }\n+  for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    rename_variables_in_stmt (gsi_stmt (gsi), map);\n }\n \n /* Remove condition from BB.  */\n@@ -3727,6 +3829,131 @@ get_true_edge_from_guard_bb (basic_block bb)\n   return NULL;\n }\n \n+/* Returns the first successor edge of BB with EDGE_TRUE_VALUE flag cleared.  */\n+\n+static edge\n+get_false_edge_from_guard_bb (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (!(e->flags & EDGE_TRUE_VALUE)) \n+      return e;\n+\n+  gcc_unreachable ();\n+  return NULL;\n+}\n+\n+/* Inserts in MAP a tuple (OLD_NAME, NEW_NAME) for the induction\n+   variables of the loops around GBB in SCOP, i.e. GBB_LOOPS.\n+   NEW_NAME is obtained from IVSTACK.  IVSTACK has the same stack\n+   ordering as GBB_LOOPS.  */\n+\n+static void\n+build_iv_mapping (loop_iv_stack ivstack, htab_t map, gbb_p gbb, scop_p scop)\n+{\n+  int i;\n+  name_tree iv;\n+  PTR *slot;\n+\n+  for (i = 0; VEC_iterate (name_tree, SCOP_OLDIVS (scop), i, iv); i++)\n+    {\n+      struct rename_map_elt tmp;\n+\n+      if (!flow_bb_inside_loop_p (iv->loop, GBB_BB (gbb)))\n+\tcontinue;\n+\n+      tmp.old_name = iv->t;\n+      slot = htab_find_slot (map, &tmp, INSERT);\n+\n+      if (!*slot)\n+\t{\n+\t  tree new_name = loop_iv_stack_get_iv (ivstack, \n+\t\t\t\t\t\tgbb_loop_index (gbb, iv->loop));\n+\t  *slot = new_rename_map_elt (iv->t, new_name);\n+\t}\n+    }\n+}\n+\n+/* Register in MAP the tuple (old_name, new_name).  */\n+\n+static void\n+register_old_new_names (htab_t map, tree old_name, tree new_name)\n+{\n+  struct rename_map_elt tmp;\n+  PTR *slot;\n+\n+  tmp.old_name = old_name;\n+  slot = htab_find_slot (map, &tmp, INSERT);\n+\n+  if (!*slot)\n+    *slot = new_rename_map_elt (old_name, new_name);\n+}\n+\n+/* Create a duplicate of the basic block BB.  NOTE: This does not\n+   preserve SSA form.  */\n+\n+static void\n+graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb, htab_t map)\n+{\n+  gimple_stmt_iterator gsi, gsi_tgt;\n+\n+  gsi_tgt = gsi_start_bb (new_bb);\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      def_operand_p def_p;\n+      ssa_op_iter op_iter;\n+      int region;\n+      gimple stmt = gsi_stmt (gsi);\n+      gimple copy;\n+\n+      if (gimple_code (stmt) == GIMPLE_LABEL)\n+\tcontinue;\n+\n+      /* Create a new copy of STMT and duplicate STMT's virtual\n+\t operands.  */\n+      copy = gimple_copy (stmt);\n+      gsi_insert_after (&gsi_tgt, copy, GSI_NEW_STMT);\n+      mark_symbols_for_renaming (copy);\n+\n+      region = lookup_stmt_eh_region (stmt);\n+      if (region >= 0)\n+\tadd_stmt_to_eh_region (copy, region);\n+      gimple_duplicate_stmt_histograms (cfun, copy, cfun, stmt);\n+\n+      /* Create new names for all the definitions created by COPY and\n+\t add replacement mappings for each new name.  */\n+      FOR_EACH_SSA_DEF_OPERAND (def_p, copy, op_iter, SSA_OP_DEF)\n+\t{\n+\t  tree old_name = DEF_FROM_PTR (def_p);\n+\t  tree new_name = create_new_def_for (old_name, copy, def_p);\n+\t  register_old_new_names (map, old_name, new_name);\n+\t}\n+    }\n+}\n+\n+/* Copies BB and includes in the copied BB all the statements that can\n+   be reached following the use-def chains from the memory accesses,\n+   and returns the next edge following this new block.  */\n+ \n+static edge\n+copy_bb_and_scalar_dependences (basic_block bb, scop_p scop,\n+\t\t\t\tloop_p context_loop,\n+\t\t\t\tedge next_e, htab_t map)\n+{\n+  basic_block new_bb = split_edge (next_e);\n+\n+  next_e = single_succ_edge (new_bb);\n+  graphite_copy_stmts_from_block (bb, new_bb, map);\n+  remove_condition (new_bb);\n+  rename_variables (new_bb, map);\n+  remove_phi_nodes (new_bb);\n+  expand_scalar_variables (new_bb, scop, context_loop, map);\n+\n+  return next_e;\n+}\n+\n /* Translates a CLAST statement STMT to GCC representation.  NEXT_E is\n    the edge where new generated code should be attached.  BB_EXIT is the last\n    basic block that defines the scope of code generation.  CONTEXT_LOOP is the\n@@ -3744,35 +3971,23 @@ translate_clast (scop_p scop, struct loop *context_loop,\n \n   if (CLAST_STMT_IS_A (stmt, stmt_user))\n     {\n+      htab_t map;\n       CloogStatement *cs = ((struct clast_user_stmt *) stmt)->statement;\n       graphite_bb_p gbb = (graphite_bb_p) cloog_statement_usr (cs);\n-      basic_block bb = gbb->bb;\n-      loop_p old_loop_father = bb->loop_father;\n \n-      if (bb == ENTRY_BLOCK_PTR)\n+      if (GBB_BB (gbb) == ENTRY_BLOCK_PTR)\n \treturn next_e;\n \n-      remove_condition (bb);\n-      expand_scalar_variables (gbb, scop, old_loop_father, ivstack);\n-      remove_all_edges (bb, next_e);\n-      move_phi_nodes (scop, old_loop_father, bb, next_e->src);\t\n-      redirect_edge_succ_nodup (next_e, bb);\n-\n-      if (context_loop)\n-\t{\n-\t  remove_bb_from_loops (bb);\n-\t  add_bb_to_loop (bb, context_loop);\n-\t}\n-\n-      set_immediate_dominator (CDI_DOMINATORS, next_e->dest, next_e->src); \n-      mark_virtual_ops_in_bb (bb);\n-      next_e = make_edge (bb,\n-\t\t\t  context_loop ? context_loop->latch : EXIT_BLOCK_PTR,\n-\t\t\t  EDGE_FALLTHRU);\n-      loop_iv_stack_patch_for_consts (ivstack,\n-\t\t\t\t      (struct clast_user_stmt *) stmt);\n-      graphite_rename_ivs (gbb, scop, old_loop_father, ivstack);\n+      map = htab_create (10, rename_map_elt_info, eq_rename_map_elts, free);\n+      loop_iv_stack_patch_for_consts (ivstack, (struct clast_user_stmt *) stmt);\n+      build_iv_mapping (ivstack, map, gbb, scop);\n+      next_e = copy_bb_and_scalar_dependences (GBB_BB (gbb), scop,\n+\t\t\t\t\t       context_loop, next_e, map);\n+      htab_delete (map);\n       loop_iv_stack_remove_constants (ivstack);\n+      update_ssa (TODO_update_ssa);\n+      recompute_all_dominators ();\n+      graphite_verify ();\n       return translate_clast (scop, context_loop, stmt->next, next_e, ivstack);\n     }\n \n@@ -3790,7 +4005,9 @@ translate_clast (scop_p scop, struct loop *context_loop,\n \t\n       set_immediate_dominator (CDI_DOMINATORS, next_e->dest, next_e->src);\n       loop_iv_stack_pop (ivstack);\n-\n+      last_e = single_succ_edge (split_edge (last_e));\n+      recompute_all_dominators ();\n+      graphite_verify ();\n       return translate_clast (scop, context_loop, stmt->next, last_e, ivstack);\n     }\n \n@@ -3803,7 +4020,7 @@ translate_clast (scop_p scop, struct loop *context_loop,\n       next_e = translate_clast (scop, context_loop, \n \t\t\t\t((struct clast_guard *) stmt)->then,\n \t\t\t\ttrue_e, ivstack);\n-      redirect_edge_succ_nodup (next_e, last_e->src);\n+      graphite_verify ();\n       return translate_clast (scop, context_loop, stmt->next, last_e, ivstack);\n     }\n \n@@ -3812,6 +4029,7 @@ translate_clast (scop_p scop, struct loop *context_loop,\n       next_e = translate_clast (scop, context_loop,\n \t\t\t\t((struct clast_block *) stmt)->body,\n \t\t\t\tnext_e, ivstack);\n+      graphite_verify ();\n       return translate_clast (scop, context_loop, stmt->next, next_e, ivstack);\n     }\n \n@@ -4026,183 +4244,6 @@ find_transform (scop_p scop)\n   return stmt;\n }\n \n-/* Return a vector of all the virtual phi nodes in the current\n-   function.  */\n- \n-static VEC (gimple, heap) *\n-collect_virtual_phis (void)     \n-{\n-  gimple_stmt_iterator si;\n-  gimple_vec phis = VEC_alloc (gimple, heap, 3);\n-  basic_block bb;\n-\n-  FOR_EACH_BB (bb) \n-    for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n-      /* The phis we moved will have 0 arguments because the\n-\t original edges were removed.  */\n-      if (gimple_phi_num_args (gsi_stmt (si)) == 0)\n-\tVEC_safe_push (gimple, heap, phis, gsi_stmt (si));\n-\n-  /* Deallocate if we did not find any.  */\n-  if (VEC_length (gimple, phis) == 0)\n-    {\n-      VEC_free (gimple, heap, phis);\n-      phis = NULL;\n-    }\n-\n-  return phis;\n-}\n-\n-/* Find a virtual definition for variable VAR in BB.  */\n-\n-static tree\n-find_vdef_for_var_in_bb (basic_block bb, tree var)\n-{\n-  gimple_stmt_iterator gsi;\n-  gimple phi;\n-  def_operand_p def_var;\n-  vuse_vec_p vv;\n-  ssa_op_iter op_iter;\n-\n-  for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi_prev (&gsi))\n-    FOR_EACH_SSA_VDEF_OPERAND (def_var, vv, gsi_stmt (gsi), op_iter)\n-      if (SSA_NAME_VAR (*def_var) == var)\n-\treturn *def_var;\n-\n-  for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi_prev (&gsi))\n-    FOR_EACH_SSA_DEF_OPERAND (def_var, gsi_stmt (gsi), op_iter, SSA_OP_DEF)\n-      if (SSA_NAME_VAR (*def_var) == var)\n-\treturn *def_var;\n-\n-  for (gsi = gsi_start_phis (bb); !gsi_end_p(gsi); gsi_next (&gsi))\n-    {\n-      phi = gsi_stmt (gsi);\n-      if (SSA_NAME_VAR (PHI_RESULT (phi)) == var)\n-\treturn PHI_RESULT (phi);\n-    }\n-\n-  return NULL;\n-}\n-\n-/* Recursive helper.  */\n-\n-static tree\n-find_vdef_for_var_1 (basic_block bb, struct pointer_set_t *visited, tree var)\n-{\n-  tree result = NULL;\n-  edge_iterator ei;\n-  edge pred_edge;\n-\n-  if (pointer_set_contains (visited, bb))\n-    return NULL;\n-\n-  pointer_set_insert (visited, bb);\n-  result = find_vdef_for_var_in_bb (bb, var);\n-\n-  if (!result)\n-    FOR_EACH_EDGE (pred_edge, ei, bb->preds)\n-      if (!result)\n-\tresult = find_vdef_for_var_1 (pred_edge->src, visited, var);\n-\n-  return result;\n-}\n-\n-/* Finds a virtual definition for variable VAR.  */\n-\n-static tree\n-find_vdef_for_var (basic_block bb, tree var)\n-{\n-  struct pointer_set_t *visited = pointer_set_create ();\n-  tree def = find_vdef_for_var_1 (bb, visited, var);\n-\n-  pointer_set_destroy (visited);\n-  return def;\n-}\n-\n-/* Update the virtual phis after loop bodies are moved to new\n-   loops.  */\n-\n-static void\n-patch_phis_for_virtual_defs (void)\n-{\n-  int i;\n-  gimple phi;\n-  VEC (gimple, heap) *virtual_phis = collect_virtual_phis ();\n-  \n-  for (i = 0; VEC_iterate (gimple, virtual_phis, i, phi); i++)\n-    {\n-      basic_block bb = gimple_bb (phi);\n-      edge_iterator ei;\n-      edge pred_edge;\n-      gimple_stmt_iterator gsi;\n-      gimple new_phi;\n-      tree phi_result = PHI_RESULT (phi);\n-      tree var = SSA_NAME_VAR (phi_result);\n-\n-      new_phi = create_phi_node (phi_result, bb);\n-      SSA_NAME_DEF_STMT (phi_result) = new_phi;\n-\n-      FOR_EACH_EDGE (pred_edge, ei, bb->preds)\n-\t{\n-\t  tree def = find_vdef_for_var (pred_edge->src, var);\n-\n-\t  if (def)\n-\t    add_phi_arg (new_phi, def, pred_edge);\n-\t  else\n-\t    add_phi_arg (new_phi, gimple_default_def (cfun, var), pred_edge);\n-\t}\n-\n-      gsi = gsi_for_stmt (phi);\n-      remove_phi_node (&gsi, false);\n-    }\n-\n-  VEC_free (gimple, heap, virtual_phis);\n-}\n-\n-/* Mark the original loops of SCOP for removal, replacing their header\n-   field with NULL.  */\n-\n-static void\n-mark_old_loops (scop_p scop)\n-{\n-  int i;\n-  struct loop *loop;\n-\n-  for (i = 0; VEC_iterate (loop_p, SCOP_LOOP_NEST (scop), i, loop); i++)\n-    {\n-      loop->header = NULL;\n-      loop->latch = NULL;\n-    }\n-}\n-\n-/* Scan the loops and remove the ones that have been marked for\n-   removal.  */\n-\n-static void\n-remove_dead_loops (void)\n-{\n-  struct loop *loop, *ploop;\n-  loop_iterator li;\n-\n-  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n-    {\n-      /* Remove only those loops that we marked to be removed with\n-\t mark_old_loops.  */\n-      if (loop->header)\n-\tcontinue;\n-\n-      while (loop->inner)\n-\t{\n-\t  ploop = loop->inner;\n-\t  flow_loop_tree_node_remove (ploop);\n-\t  flow_loop_tree_node_add (loop_outer (loop), ploop);\n-\t}\n-\n-      /* Remove the loop and free its data.  */\n-      delete_loop (loop);\n-    }\n-}\n-\n /* Returns true when it is possible to generate code for this STMT.\n    For the moment we cannot generate code when Cloog decides to\n    duplicate a statement, as we do not do a copy, but a move.\n@@ -4261,230 +4302,326 @@ can_generate_code (struct clast_stmt *stmt)\n   return result;\n }\n \n-/* Skip any definition that is a phi node with a single phi def.  */\n+/* Remove from the CFG the REGION.  */\n \n-static tree \n-skip_phi_defs (tree ssa_name)\n+static inline void\n+remove_sese_region (sese region)\n {\n-  tree result = ssa_name;\n-  gimple def_stmt = SSA_NAME_DEF_STMT (ssa_name);\n+  VEC (basic_block, heap) *bbs = NULL;\n+  basic_block entry_bb = SESE_ENTRY (region)->dest;\n+  basic_block exit_bb = SESE_EXIT (region)->dest;\n+  basic_block bb;\n+  int i;\n \n-  if (gimple_code (def_stmt) == GIMPLE_PHI \n-      && gimple_phi_num_args (def_stmt) == 1)\n-    result = skip_phi_defs (gimple_phi_arg(def_stmt,0)->def);\n+  VEC_safe_push (basic_block, heap, bbs, entry_bb);\n+  gather_blocks_in_sese_region (entry_bb, exit_bb, &bbs);\n \n-  return result;\n+  for (i = 0; VEC_iterate (basic_block, bbs, i, bb); i++)\n+    delete_basic_block (bb);\n+\n+  VEC_free (basic_block, heap, bbs);\n }\n \n-/* Returns a VEC containing the phi-arg defs coming from SCOP_EXIT in\n-   the destination block of SCOP_EXIT.  */\n+typedef struct ifsese {\n+  sese region;\n+  sese true_region;\n+  sese false_region;\n+} *ifsese;\n \n-static VEC (tree, heap) *\n-collect_scop_exit_phi_args (edge scop_exit)\n+static inline edge\n+if_region_entry (ifsese if_region)\n {\n-  VEC (tree, heap) *phi_args = VEC_alloc (tree, heap, 1);\n-  gimple_stmt_iterator gsi;\n-\n-  for (gsi = gsi_start_phis (scop_exit->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple phi = gsi_stmt (gsi);\n-      tree phi_arg = skip_phi_defs(PHI_ARG_DEF_FROM_EDGE (phi, scop_exit));\n-\n-      VEC_safe_push (tree, heap, phi_args, phi_arg);\n-    }\n+  return SESE_ENTRY (if_region->region);\n+}\n \n-  return phi_args;\n+static inline edge\n+if_region_exit (ifsese if_region)\n+{\n+  return SESE_EXIT (if_region->region);\n }\n \n-/* Patches (adds) PHI_ARGS to the phi nodes in SCOP_EXIT destination.  */\n+static inline basic_block\n+if_region_get_condition_block (ifsese if_region)\n+{\n+  return if_region_entry (if_region)->dest;\n+}\n \n-static void\n-patch_scop_exit_phi_args (edge scop_exit,\n-\t\t\t  VEC (tree, heap) *phi_args)\n+static inline void\n+if_region_set_false_region (ifsese if_region, sese region)\n {\n-  int i = 0;\n-  gimple_stmt_iterator gsi;\n+  basic_block condition = if_region_get_condition_block (if_region);\n+  edge false_edge = get_false_edge_from_guard_bb (condition);\n+  edge entry_region = SESE_ENTRY (region);\n+  edge exit_region = SESE_EXIT (region);\n+  basic_block before_region = entry_region->src;\n+  basic_block last_in_region = exit_region->src;\n+  void **slot = htab_find_slot_with_hash (current_loops->exits, exit_region,\n+\t\t\t\t\t  htab_hash_pointer (exit_region),\n+\t\t\t\t\t  NO_INSERT);\n+\n+  entry_region->flags = false_edge->flags;\n+  false_edge->flags = exit_region->flags;\n+\n+  redirect_edge_pred (entry_region, condition);\n+  redirect_edge_pred (exit_region, before_region);\n+  redirect_edge_pred (false_edge, last_in_region);\n+\n+  exit_region->flags = EDGE_FALLTHRU;\n+  recompute_all_dominators ();\n \n-  for (gsi = gsi_start_phis (scop_exit->dest); !gsi_end_p (gsi);\n-       gsi_next (&gsi), i++)\n+  SESE_EXIT (region) = single_succ_edge (false_edge->dest);\n+  if_region->false_region = region;\n+\n+  if (slot)\n     {\n-      tree def = VEC_index (tree, phi_args, i);\n-      gimple phi = gsi_stmt (gsi);\n+      struct loop_exit *loop_exit = GGC_CNEW (struct loop_exit);\n \n-      gcc_assert (PHI_ARG_DEF_FROM_EDGE (phi, scop_exit) == NULL);\n+      memcpy (loop_exit, *((struct loop_exit **) slot), sizeof (struct loop_exit));\n+      htab_clear_slot (current_loops->exits, slot);\n \n-      add_phi_arg (phi, def, scop_exit);\n+      slot = htab_find_slot_with_hash (current_loops->exits, false_edge,\n+\t\t\t\t       htab_hash_pointer (false_edge),\n+\t\t\t\t       INSERT);\n+      loop_exit->e = false_edge;\n+      *slot = loop_exit;\n+      false_edge->src->loop_father->exits->next = loop_exit;\n     }\n }\n \n-/* GIMPLE Loop Generator: generates loops from STMT in GIMPLE form for\n-   the given SCOP.  */\n-\n-static void\n-gloog (scop_p scop, struct clast_stmt *stmt)\n+static ifsese\n+create_if_region_on_edge (edge entry, tree condition)\n {\n-  edge new_scop_exit_edge = NULL;\n-  basic_block scop_exit = SCOP_EXIT (scop);\n-  VEC (tree, heap) *phi_args =\n-    collect_scop_exit_phi_args (SESE_EXIT (SCOP_REGION (scop)));\n-  VEC (iv_stack_entry_p, heap) *ivstack = \n-    VEC_alloc (iv_stack_entry_p, heap, 10);\n-  edge construction_edge = SESE_ENTRY (SCOP_REGION (scop));\n-  basic_block old_scop_exit_idom = get_immediate_dominator (CDI_DOMINATORS,\n-\t\t\t\t\t\t\t    scop_exit);\n+  edge e;\n+  edge_iterator ei;\n+  sese sese_region = GGC_NEW (struct sese);\n+  sese true_region = GGC_NEW (struct sese);\n+  sese false_region = GGC_NEW (struct sese);\n+  ifsese if_region = GGC_NEW (struct ifsese);\n+  edge exit = create_empty_if_region_on_edge (entry, condition);\n \n-  if (!can_generate_code (stmt))\n+  if_region->region = sese_region;\n+  if_region->region->entry = entry;\n+  if_region->region->exit = exit;\n+\n+  FOR_EACH_EDGE (e, ei, entry->dest->succs)\n     {\n-      cloog_clast_free (stmt);\n-      return;\n+      if (e->flags & EDGE_TRUE_VALUE)\n+\t{\n+\t  true_region->entry = e;\n+\t  true_region->exit = single_succ_edge (e->dest);\n+\t  if_region->true_region = true_region;\n+\t}\n+      else if (e->flags & EDGE_FALSE_VALUE)\n+\t{\n+\t  false_region->entry = e;\n+\t  false_region->exit = single_succ_edge (e->dest);\n+\t  if_region->false_region = false_region;\n+\t}\n     }\n \n-  redirect_edge_succ_nodup (construction_edge, EXIT_BLOCK_PTR);\n-  new_scop_exit_edge = translate_clast (scop, \n-\t\t\t\t\tconstruction_edge->src->loop_father,\n-\t\t\t\t\tstmt, construction_edge, &ivstack);\n-  free_loop_iv_stack (&ivstack);\n-  redirect_edge_succ (new_scop_exit_edge, scop_exit);\n+  return if_region;\n+}\n \n-  if (!old_scop_exit_idom\n-      || !dominated_by_p (CDI_DOMINATORS, SCOP_ENTRY (scop),\n-\t\t\t  old_scop_exit_idom)\n-      || SCOP_ENTRY (scop) == old_scop_exit_idom)\n-    set_immediate_dominator (CDI_DOMINATORS,\n-\t\t\t     new_scop_exit_edge->dest,\n-\t\t\t     new_scop_exit_edge->src);\n+/* Moves REGION in a condition expression:\n+   | if (1)\n+   |   ;\n+   | else\n+   |   REGION;\n+*/\n \n-  cloog_clast_free (stmt);\n+static ifsese\n+move_sese_in_condition (sese region)\n+{\n+  basic_block pred_block = split_edge (SESE_ENTRY (region));\n+  ifsese if_region = NULL;\n \n-  if (new_scop_exit_edge->dest == EXIT_BLOCK_PTR)\n-    new_scop_exit_edge->flags = 0;\n- \n-  delete_unreachable_blocks ();\n-  patch_phis_for_virtual_defs ();\n-  patch_scop_exit_phi_args (new_scop_exit_edge, phi_args);\n-  VEC_free (tree, heap, phi_args);\n-  mark_old_loops (scop);\n-  remove_dead_loops ();\n-  rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa); \n+  SESE_ENTRY (region) = single_succ_edge (pred_block);\n+  if_region = create_if_region_on_edge (single_pred_edge (pred_block), integer_one_node);\n+  if_region_set_false_region (if_region, region);\n \n-#ifdef ENABLE_CHECKING\n-  verify_loop_structure ();\n-  verify_dominators (CDI_DOMINATORS);\n-  verify_ssa (false);\n-#endif\n+  return if_region;\n }\n \n-/* Returns the number of data references in SCOP.  */\n+/* Returns true when BB is in REGION.  */\n \n-static int\n-nb_data_refs_in_scop (scop_p scop)\n+static bool\n+bb_in_sese_p (basic_block bb, sese region)\n {\n-  int i;\n-  graphite_bb_p gbb;\n-  int res = 0;\n+  return (dominated_by_p (CDI_DOMINATORS, bb, SESE_ENTRY (region)->src)\n+\t  && dominated_by_p (CDI_POST_DOMINATORS, bb, SESE_EXIT (region)->dest));\n+}\n \n-  for (i = 0; VEC_iterate (graphite_bb_p, SCOP_BBS (scop), i, gbb); i++)\n-    res += VEC_length (data_reference_p, GBB_DATA_REFS (gbb));\n+/* For USE in BB, if it is used outside of the REGION it is defined in,\n+   mark it for rewrite.  Record basic block BB where it is used\n+   to USE_BLOCKS.  Record the ssa name index to NEED_PHIS bitmap.  */\n \n-  return res;\n+static void\n+sese_find_uses_to_rename_use (sese region, basic_block bb, tree use,\n+\t\t\t      bitmap *use_blocks, bitmap need_phis)\n+{\n+  unsigned ver;\n+  basic_block def_bb;\n+\n+  if (TREE_CODE (use) != SSA_NAME)\n+    return;\n+\n+  ver = SSA_NAME_VERSION (use);\n+  def_bb = gimple_bb (SSA_NAME_DEF_STMT (use));\n+  if (!def_bb\n+      || !bb_in_sese_p (def_bb, region)\n+      || bb_in_sese_p (bb, region))\n+    return;\n+\n+  if (!use_blocks[ver])\n+    use_blocks[ver] = BITMAP_ALLOC (NULL);\n+  bitmap_set_bit (use_blocks[ver], bb->index);\n+\n+  bitmap_set_bit (need_phis, ver);\n }\n \n-/* Check if a graphite bb can be ignored in graphite.  We ignore all\n-   bbs, that only contain code, that will be eliminated later.\n+/* Marks names that are used in BB and outside of the loop they are\n+   defined in for rewrite.  Records the set of blocks in that the ssa\n+   names are defined to USE_BLOCKS.  Record the SSA names that will\n+   need exit PHIs in NEED_PHIS.  */\n+\n+static void\n+sese_find_uses_to_rename_bb (sese region, basic_block bb,\n+\t\t\t     bitmap *use_blocks, bitmap need_phis)\n+{\n+  gimple_stmt_iterator bsi;\n+  edge e;\n+  edge_iterator ei;\n+  ssa_op_iter iter;\n+  tree var;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    for (bsi = gsi_start_phis (e->dest); !gsi_end_p (bsi); gsi_next (&bsi))\n+      sese_find_uses_to_rename_use (region, bb,\n+\t\t\t\t    PHI_ARG_DEF_FROM_EDGE (gsi_stmt (bsi), e),\n+\t\t\t\t    use_blocks, need_phis);\n \n-   TODO: - Move PHI nodes and scalar variables out of these bbs, that only\n-           remain conditions and induction variables.  */\n+  for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+    FOR_EACH_SSA_TREE_OPERAND (var, gsi_stmt (bsi), iter, SSA_OP_ALL_USES)\n+      sese_find_uses_to_rename_use (region, bb, var, use_blocks, need_phis);\n+}\n \n-static bool\n-gbb_can_be_ignored (graphite_bb_p gb)\n+/* Add exit phis for the USE on EXIT.  */\n+\n+static void\n+sese_add_exit_phis_edge (basic_block exit, tree use, edge false_e, edge true_e)\n {\n-  gimple_stmt_iterator gsi;\n-  scop_p scop = GBB_SCOP (gb);\n-  loop_p loop = GBB_BB (gb)->loop_father;\n+  gimple phi = create_phi_node (use, exit);\n \n-  if (VEC_length (data_reference_p, GBB_DATA_REFS(gb)))\n-    return false;\n+  create_new_def_for (gimple_phi_result (phi), phi,\n+\t\t      gimple_phi_result_ptr (phi));\n+  add_phi_arg (phi, use, false_e);\n+  add_phi_arg (phi, integer_zero_node, true_e);\n+}\n \n-  /* Check statements.  */\n-  for (gsi = gsi_start_bb (GBB_BB (gb)); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple stmt = gsi_stmt (gsi);\n-      switch (gimple_code (stmt))\n-        {\n-          /* Control flow expressions can be ignored, as they are\n-             represented in the iteration domains and will be\n-             regenerated by graphite.  */\n-          case GIMPLE_COND:\n-\t  case GIMPLE_GOTO:\n-\t  case GIMPLE_SWITCH:\n-            break;\n+/* Add phi nodes for VAR that is used in LIVEIN.  Phi nodes are\n+   inserted in block WHERE.  */\n \n-          /* Scalar variables can be ignored, if we can regenerate\n-             them later using their scalar evolution function.\n-             XXX: Just a heuristic, that needs further investigation.  */\n-          case GIMPLE_ASSIGN:\n-\t    {\n-\t      tree var = gimple_assign_lhs (stmt);\n-\t      var = analyze_scalar_evolution (loop, var);\n-\t      var = instantiate_scev (block_before_scop (scop), loop, var);\n+static void\n+sese_add_exit_phis_var (basic_block where, tree var, bitmap livein,\n+\t\t\tedge false_e, edge true_e)\n+{\n+  bitmap def;\n+  basic_block def_bb = gimple_bb (SSA_NAME_DEF_STMT (var));\n \n-\t      if (TREE_CODE (var) == SCEV_NOT_KNOWN)\n-\t\treturn false;\n+  if (is_gimple_reg (var))\n+    bitmap_clear_bit (livein, def_bb->index);\n+  else\n+    bitmap_set_bit (livein, def_bb->index);\n \n-\t      break;\n-\t    }\n-          /* Otherwise not ignoreable.  */\n-          default:\n-            return false;\n-        }\n-    }\n+  def = BITMAP_ALLOC (NULL);\n+  bitmap_set_bit (def, def_bb->index);\n+  compute_global_livein (livein, def);\n+  BITMAP_FREE (def);\n \n-  return true;\n+  sese_add_exit_phis_edge (where, var, false_e, true_e);\n }\n \n-/* Remove all ignoreable gbbs from SCOP.  */\n+/* Insert in the block WHERE phi nodes for variables defined in REGION\n+   and used outside the REGION.  */\n \n static void\n-scop_remove_ignoreable_gbbs (scop_p scop)\n+rewrite_into_sese_closed_ssa (sese region, basic_block where,\n+\t\t\t      edge false_e, edge true_e)\n {\n-  graphite_bb_p gb;\n-  int i;\n+  unsigned i;\n+  basic_block bb;\n+  bitmap_iterator bi;\n+  bitmap names_to_rename = BITMAP_ALLOC (NULL);\n+  unsigned old_num_ssa_names = num_ssa_names;\n+  bitmap *use_blocks = XCNEWVEC (bitmap, old_num_ssa_names);\n \n-  int max_schedule = scop_max_loop_depth (scop) + 1;\n-  lambda_vector last_schedule = lambda_vector_new (max_schedule);\n-  lambda_vector_clear (last_schedule, max_schedule);\n+  update_ssa (TODO_update_ssa);\n \n-  /* Update schedules.  */\n-  for (i = 0; VEC_iterate (graphite_bb_p, SCOP_BBS (scop), i, gb); i++)\n-    {\n-      int nb_loops = gbb_nb_loops (gb);\n+  FOR_EACH_BB (bb)\n+    sese_find_uses_to_rename_bb (region, bb, use_blocks, names_to_rename);\n \n-      if (GBB_STATIC_SCHEDULE (gb) [nb_loops] == 0)\n-        last_schedule [nb_loops] = 0;\n+  EXECUTE_IF_SET_IN_BITMAP (names_to_rename, 0, i, bi)\n+    sese_add_exit_phis_var (where, ssa_name (i), use_blocks[i],\n+\t\t\t    false_e, true_e);\n \n-      if (gbb_can_be_ignored (gb))\n-        {\n-          /* Mark gbb for remove.  */\n-          bitmap_clear_bit (SCOP_BBS_B (scop), gb->bb->index);\n-          GBB_SCOP (gb) = NULL;\n-          last_schedule [nb_loops]--;\n-        }\n-      else\n-        lambda_vector_add (GBB_STATIC_SCHEDULE (gb), last_schedule,\n-                           GBB_STATIC_SCHEDULE (gb), nb_loops + 1);\n+  update_ssa (TODO_update_ssa);\n+\n+  for (i = 0; i < old_num_ssa_names; i++)\n+    BITMAP_FREE (use_blocks[i]);\n+\n+  free (use_blocks);\n+  BITMAP_FREE (names_to_rename);\n+}\n+\n+/* GIMPLE Loop Generator: generates loops from STMT in GIMPLE form for\n+   the given SCOP.  */\n+\n+static void\n+gloog (scop_p scop, struct clast_stmt *stmt)\n+{\n+  edge new_scop_exit_edge = NULL;\n+  VEC (iv_stack_entry_p, heap) *ivstack = VEC_alloc (iv_stack_entry_p, heap,\n+\t\t\t\t\t\t     10);\n+  loop_p context_loop;\n+  ifsese if_region = NULL;\n+\n+  if (!can_generate_code (stmt))\n+    {\n+      cloog_clast_free (stmt);\n+      return;\n     }\n \n-  /* Remove gbbs.  */\n-  for (i = 0; VEC_iterate (graphite_bb_p, SCOP_BBS (scop), i, gb); i++)\n-    if (GBB_SCOP (gb) == NULL)\n-      {\n-        VEC_unordered_remove (graphite_bb_p, SCOP_BBS (scop), i);\n-        free_graphite_bb (gb);\n-        /* XXX: Hackish? But working.  */\n-        i--;\n-      }  \n+  if_region = move_sese_in_condition (SCOP_REGION (scop));\n+  rewrite_into_sese_closed_ssa (SCOP_REGION (scop),\n+\t\t\t\tif_region->region->exit->src,\n+\t\t\t\tif_region->false_region->exit,\n+\t\t\t\tif_region->true_region->exit);\n+  graphite_verify ();\n+  context_loop = SESE_ENTRY (SCOP_REGION (scop))->src->loop_father;\n+  new_scop_exit_edge = translate_clast (scop, context_loop,\n+\t\t\t\t\tstmt, if_region->true_region->entry,\n+\t\t\t\t\t&ivstack);\n+  graphite_verify ();\n+  cleanup_tree_cfg ();\n+  recompute_all_dominators ();\n+  graphite_verify ();\n+  free_loop_iv_stack (&ivstack);\n+  cloog_clast_free (stmt);\n+}\n \n-  graphite_sort_gbbs (scop);\n+/* Returns the number of data references in SCOP.  */\n+\n+static int\n+nb_data_refs_in_scop (scop_p scop)\n+{\n+  int i;\n+  graphite_bb_p gbb;\n+  int res = 0;\n+\n+  for (i = 0; VEC_iterate (graphite_bb_p, SCOP_BBS (scop), i, gbb); i++)\n+    res += VEC_length (data_reference_p, GBB_DATA_REFS (gbb));\n+\n+  return res;\n }\n \n /* Move the loop at index LOOP and insert it before index NEW_LOOP_POS.\n@@ -4962,11 +5099,6 @@ graphite_trans_loop_block (VEC (graphite_bb_p, heap) *bbs, int loops)\n   /* TODO: - Calculate the stride size automatically.  */\n   int stride_size = 64;\n \n-  /* It makes no sense to block a single loop.  */\n-  for (i = 0; VEC_iterate (graphite_bb_p, bbs, i, gb); i++)\n-    if (gbb_nb_loops (gb) < 2)\n-      return false;\n-\n   for (i = 0; VEC_iterate (graphite_bb_p, bbs, i, gb); i++)\n     transform_done |= graphite_trans_bb_block (gb, stride_size, loops);\n \n@@ -5049,7 +5181,7 @@ graphite_trans_scop_block (scop_p scop)\n       j++;\n \n       /* Found perfect loop nest.  */\n-      if (perfect && last_nb_loops - j > 0)\n+      if (perfect && last_nb_loops - j >= 2)\n         transform_done |= graphite_trans_loop_block (bbs, last_nb_loops - j);\n  \n       /* Check if we start with a new loop.\n@@ -5108,7 +5240,6 @@ graphite_apply_transformations (scop_p scop)\n \n   /* Sort the list of bbs.  Keep them always sorted.  */\n   graphite_sort_gbbs (scop);\n-  scop_remove_ignoreable_gbbs (scop);\n \n   if (flag_loop_block)\n     transform_done = graphite_trans_scop_block (scop);\n@@ -5157,13 +5288,15 @@ limit_scops (void)\n       int j;\n       loop_p loop;\n       build_scop_bbs (scop);\n-      build_scop_loop_nests (scop);\n+\n+      if (!build_scop_loop_nests (scop))\n+\tcontinue;\n \n       for (j = 0; VEC_iterate (loop_p, SCOP_LOOP_NEST (scop), j, loop); j++) \n         if (!loop_in_scop_p (loop_outer (loop), scop))\n           {\n \t    sd_region open_scop;\n-\t    open_scop.entry = loop_preheader_edge (loop)->dest;\n+\t    open_scop.entry = loop->header;\n \t    open_scop.exit = single_exit (loop)->dest;\n \t    VEC_safe_push (sd_region, heap, tmp_scops, &open_scop);\n \t  }\n@@ -5190,13 +5323,12 @@ graphite_transform_loops (void)\n     return;\n \n   current_scops = VEC_alloc (scop_p, heap, 3);\n-\n-  calculate_dominance_info (CDI_DOMINATORS);\n-  calculate_dominance_info (CDI_POST_DOMINATORS);\n+  recompute_all_dominators ();\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Graphite loop transformations \\n\");\n \n+  initialize_original_copy_tables ();\n   cloog_initialize ();\n   build_scops ();\n   limit_scops ();\n@@ -5208,9 +5340,12 @@ graphite_transform_loops (void)\n   for (i = 0; VEC_iterate (scop_p, current_scops, i, scop); i++)\n     {\n       build_scop_bbs (scop);\n-      build_scop_loop_nests (scop);\n+      if (!build_scop_loop_nests (scop))\n+\tcontinue;\n+\n       build_scop_canonical_schedules (scop);\n       build_bb_loops (scop);\n+      build_scop_conditions (scop);\n       find_scop_parameters (scop);\n       build_scop_context (scop);\n \n@@ -5226,8 +5361,8 @@ graphite_transform_loops (void)\n       if (!build_scop_iteration_domain (scop))\n \tcontinue;\n \n-      build_scop_conditions (scop);\n       build_scop_data_accesses (scop);\n+      build_scop_dynamic_schedules (scop);\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n@@ -5249,6 +5384,7 @@ graphite_transform_loops (void)\n   /* Cleanup.  */\n   free_scops (current_scops);\n   cloog_finalize ();\n+  free_original_copy_tables ();\n }\n \n #else /* If Cloog is not available: #ifndef HAVE_cloog.  */"}, {"sha": "faae00950d66d3cdde94eacc359a9f2875137c35", "filename": "gcc/graphite.h", "status": "modified", "additions": 71, "deletions": 36, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Fgraphite.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Fgraphite.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.h?ref=81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "patch": "@@ -18,6 +18,9 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+#ifndef GCC_GRAPHITE_H\n+#define GCC_GRAPHITE_H\n+\n #include \"tree-data-ref.h\"\n \n typedef struct graphite_bb *graphite_bb_p;\n@@ -31,7 +34,7 @@ static inline int scop_nb_loops (scop_p scop);\n static inline unsigned scop_nb_params (scop_p scop);\n static inline bool scop_contains_loop (scop_p scop, struct loop *loop);\n \n-struct graphite_bb\n+typedef struct graphite_bb\n {\n   basic_block bb;\n   scop_p scop;\n@@ -116,7 +119,7 @@ struct graphite_bb\n    CloogMatrix *domain;\n \n   /* Lists containing the restrictions of the conditional statements\n-     dominating this bb. This bb can only be executed, if all conditions\n+     dominating this bb.  This bb can only be executed, if all conditions\n      are true.\n  \n      Example:\n@@ -129,13 +132,13 @@ struct graphite_bb\n          B\n      }\n  \n-     So for B there is a additional condition (2i <= 8).\n+     So for B there is an additional condition (2i <= 8).\n  \n-     TODO: Add this restrictions to the domain matrix.\n+     TODO: Add these restrictions to the domain matrix.\n       \n-     List of COND_EXPR and SWITCH_EXPR. A COND_EXPR is true only if the \n-     corresponding element in CONDITION_CASES is not NULL_TREE. For a \n-     SWITCH_EXPR the corresponding element in CONDITION_CASES is a \n+     List of COND_EXPR and SWITCH_EXPR.  A COND_EXPR is true only if the\n+     corresponding element in CONDITION_CASES is not NULL_TREE.  For a\n+     SWITCH_EXPR the corresponding element in CONDITION_CASES is a\n      CASE_LABEL_EXPR.  */\n   VEC (gimple, heap) *conditions;\n   VEC (gimple, heap) *condition_cases;\n@@ -190,7 +193,7 @@ struct graphite_bb\n   lambda_vector compressed_alpha_matrix;\n   CloogMatrix *dynamic_schedule;\n   VEC (data_reference_p, heap) *data_refs;\n-};\n+} *gbb_p;\n \n #define GBB_BB(GBB) GBB->bb\n #define GBB_SCOP(GBB) GBB->scop\n@@ -234,7 +237,7 @@ gbb_loop_at_index (graphite_bb_p gb, int index)\n   return VEC_index (loop_p, GBB_LOOPS (gb), index);\n }\n \n-/* Returns the corresponding loop iterator index for a gimple loop.  */\n+/* Returns the index of LOOP in the loop nest around GB.  */\n \n static inline int\n gbb_loop_index (graphite_bb_p gb, loop_p loop)\n@@ -305,8 +308,13 @@ struct scop\n   /* ???  It looks like a global mapping loop_id -> cloog_loop would work.  */\n   htab_t loop2cloog_loop;\n \n-  /* CLooG representation of this SCOP.  */\n+  /* Cloog representation of this scop.  */\n   CloogProgram *program;\n+\n+  /* Are we allowed to add more params?  This is for debugging purpose.  We\n+     can only add new params before generating the bb domains, otherwise they\n+     become invalid.  */\n+  bool add_params;\n };\n \n #define SCOP_BBS(S) S->bbs\n@@ -322,6 +330,7 @@ struct scop\n #define SCOP_STATIC_SCHEDULE(S) S->static_schedule\n #define SCOP_LOOPS(S) S->loops\n #define SCOP_LOOP_NEST(S) S->loop_nest\n+#define SCOP_ADD_PARAMS(S) S->add_params\n #define SCOP_PARAMS(S) S->params\n #define SCOP_OLDIVS(S) S->old_ivs\n #define SCOP_PROG(S) S->program\n@@ -335,8 +344,7 @@ extern void debug_gbb (graphite_bb_p, int);\n extern void dot_scop (scop_p);\n extern void dot_all_scops (void);\n extern void debug_clast_stmt (struct clast_stmt *);\n-\n-\n+extern void debug_rename_map (htab_t);\n extern void debug_loop_vec (graphite_bb_p gb);\n extern void debug_oldivs (scop_p);\n \n@@ -369,7 +377,6 @@ DEF_VEC_ALLOC_P(iv_stack_entry_p,heap);\n typedef VEC(iv_stack_entry_p, heap) **loop_iv_stack;\n extern void debug_loop_iv_stack (loop_iv_stack);\n \n-\n /* Return the number of gimple loops contained in SCOP.  */\n \n static inline int\n@@ -422,15 +429,6 @@ loop_domain_dim (unsigned int loop_num, scop_p scop)\n   return cloog_domain_dim (cloog_loop_domain (slot->cloog_loop)) + 2;\n }\n \n-/* Returns the dimensionality of an enclosing loop iteration domain\n-   with respect to enclosing SCoP for a given data reference REF.  */\n-\n-static inline int\n-ref_nb_loops (data_reference_p ref)\n-{\n-  return loop_domain_dim (loop_containing_stmt (DR_STMT (ref))->num, DR_SCOP (ref));\n-}\n-\n /* Returns the dimensionality of a loop iteration vector in a loop\n    iteration domain for a given loop (identified by LOOP_NUM) with\n    respect to SCOP.  */\n@@ -521,22 +519,59 @@ scop_gimple_loop_depth (scop_p scop, loop_p loop)\n   return depth;\n }\n \n-/* Associate a POLYHEDRON dependence description to two data\n-   references A and B.  */\n-struct data_dependence_polyhedron\n+/* Static inline function prototypes.  */\n+\n+static inline unsigned scop_nb_params (scop_p scop);\n+\n+/* Returns true when BB is in SCOP.  */\n+\n+static inline bool\n+bb_in_scop_p (basic_block bb, scop_p scop)\n {\n-  struct data_reference *a;\n-  struct data_reference *b;\n-  bool reversed_p;\n-  bool loop_carried; /*TODO:konrad get rid of this, make level signed */\n-  signed level;\n-  CloogDomain *polyhedron;  \n-};\n+  return bitmap_bit_p (SCOP_BBS_B (scop), bb->index);\n+}\n \n-#define RDGE_DDP(E)   ((struct data_dependence_polyhedron*) ((E)->data))\n+/* Returns true when LOOP is in SCOP.  */\n \n-typedef struct data_dependence_polyhedron *ddp_p;\n+static inline bool \n+loop_in_scop_p (struct loop *loop, scop_p scop)\n+{\n+  return (bb_in_scop_p (loop->header, scop)\n+\t  && bb_in_scop_p (loop->latch, scop));\n+}\n+\n+/* Calculate the number of loops around LOOP in the SCOP.  */\n+\n+static inline int\n+nb_loops_around_loop_in_scop (struct loop *l, scop_p scop)\n+{\n+  int d = 0;\n+\n+  for (; loop_in_scop_p (l, scop); d++, l = loop_outer (l));\n+\n+  return d;\n+}\n+\n+/* Calculate the number of loops around GB in the current SCOP.  */\n+\n+static inline int\n+nb_loops_around_gb (graphite_bb_p gb)\n+{\n+  return nb_loops_around_loop_in_scop (gbb_loop (gb), GBB_SCOP (gb));\n+}\n+\n+/* Returns the dimensionality of an enclosing loop iteration domain\n+   with respect to enclosing SCoP for a given data reference REF.  The\n+   returned dimensionality is homogeneous (depth of loop nest + number\n+   of SCoP parameters + const).  */\n \n-DEF_VEC_P(ddp_p);\n-DEF_VEC_ALLOC_P(ddp_p,heap);\n+static inline int\n+ref_nb_loops (data_reference_p ref)\n+{\n+  loop_p loop = loop_containing_stmt (DR_STMT (ref));\n+  scop_p scop = DR_SCOP (ref);\n+\n+  return nb_loops_around_loop_in_scop (loop, scop) + scop_nb_params (scop) + 2;\n+}\n \n+#endif  /* GCC_GRAPHITE_H  */"}, {"sha": "207da42eda583cb42cf5820c2a0e6d2b65f6a09c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "patch": "@@ -1,3 +1,30 @@\n+2008-12-11  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR middle-end/37852\n+\tPR middle-end/37883\n+\tPR middle-end/37928\n+\tPR middle-end/37980\n+\tPR middle-end/38038\n+\tPR middle-end/38039\n+\tPR middle-end/38073\n+\tPR middle-end/38083\n+\tPR middle-end/38125\n+\t* gcc.dg/graphite/pr37928.c: New.\n+\t* gcc.dg/graphite/pr37883.c: New.\n+\t* gcc.dg/graphite/pr38073.c: New.\n+\t* gcc.dg/graphite/pr38125.c: New.\n+\t* gfortran.dg/graphite/pr38083.f90: New.\n+\t* gfortran.dg/graphite/pr37852.f90: New.\n+\t* gfortran.dg/graphite/pr37980.f90: New.\n+\t* gfortran.dg/graphite/id-2.f90: New.\n+\t* gfortran.dg/graphite/id-4.f90: New.\n+\n+\t* gcc.dg/graphite/scop-18.c: Remove reduction, test for\n+\tthe number of detected scops.  Copy exact same test for loop blocking...\n+\t* gcc.dg/graphite/block-1.c: Fix the number of expected loops\n+\tto be blocked as reductions are not handled.\n+\t* gcc.dg/graphite/block-4.c: ...here.  New.\n+\n 2008-12-11  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/38464\n@@ -95,6 +122,12 @@\n \tPR c++/38410\n \t* gcc.dg/ctor1.c: New test.\n \n+2008-12-09 Tobias Grosser  <grosser@fim.uni-passau.de>\n+\n+\tPR middle-end/38084\n+\t* gfortran.dg/graphite/id-3.f90: New.\n+\t* gcc.dg/graphite/pr38084.c: New.\n+\n 2008-12-08  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.target/mips/fix-r10000-6.c: Add dg-message to look for"}, {"sha": "857f8d54e8e36b33a6a6f02d40f7f2707b651700", "filename": "gcc/testsuite/gcc.dg/graphite/block-1.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-1.c?ref=81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "patch": "@@ -2,13 +2,17 @@\n \n #define MAX 8192\n \n+void bar (void);\n+\n int main()\n {\n   int i, j;\n   int sum = 0;\n   int A[MAX * MAX];\n   int B[MAX * MAX];\n \n+  bar ();\n+\n   for (i = 0; i < MAX; i++)\n     for (j = 0; j < MAX; j++)\n       {\n@@ -20,12 +24,17 @@ int main()\n     for (j = 0; j < MAX; j++)\n       A[i*MAX + j] += B[j*MAX + i];\n \n+  bar ();\n+\n+  /* FIXME: For now, reductions are not handled by the code generation\n+     of graphite.  We have to bound the scop to the above loops.  */\n+\n   for(i = 0; i < MAX; i++)\n     for(j = 0; j < MAX; j++)\n       sum += A[i*MAX + j];\n \n   return sum;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Loop blocked\" 3 \"graphite\"} } */ \n+/* { dg-final { scan-tree-dump-times \"Loop blocked\" 2 \"graphite\"} } */ \n /* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "4b550b4e472c26b87aca3e22aae5cfa37ffc5310", "filename": "gcc/testsuite/gcc.dg/graphite/block-4.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-4.c?ref=81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-options \"-O2 -floop-block -fdump-tree-graphite-all\" } */\n+\n+#define N 24\n+#define M 1000\n+\n+float A[1000][1000], B[1000][1000], C[1000][1000];\n+\n+void test (void)\n+{\n+  int i, j, k;\n+\n+  /* These loops contain too few iterations for being strip-mined by 64.  */\n+  for (i = 0; i < 24; i++)\n+    for (j = 0; j < 24; j++)\n+      for (k = 0; k < 24; k++)\n+        A[i][j] = B[i][k] * C[k][j];\n+\n+  /* These loops should still be strip mined.  */\n+  for (i = 0; i < 1000; i++)\n+    for (j = 0; j < 1000; j++)\n+      for (k = 0; k < 1000; k++)\n+        A[i][j] = B[i][k] * C[k][j];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Strip Mining is not profitable\" 2 \"graphite\" } } */\n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "2ab043adce1aa1c3190ac4976449fb46ce13d121", "filename": "gcc/testsuite/gcc.dg/graphite/pr37883.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37883.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37883.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37883.c?ref=81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-options \"-O3 -floop-block\" } */\n+\n+void test_sort()\n+{\n+  char *base;\n+  register char c, *i, *hi;\n+\n+  for (i = base; i < hi; i++)\n+    *i++ = c;\n+}\n+"}, {"sha": "47ad5bce0bdc3a7b9eabf8cdb347ade3e1e3b26c", "filename": "gcc/testsuite/gcc.dg/graphite/pr37928.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37928.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37928.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr37928.c?ref=81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-options \"-O3 -floop-block\" } */\n+\n+int get_state(int size, int *node, int *hash)\n+{\n+  int i=0;\n+  while(hash[i])\n+    {\n+     if(node[hash[i]] == 0)\n+           return hash[i]-1;\n+      i++;\n+     if(i==5)\n+       i=0;\n+    }\n+  return -1;\n+}\n+\n+void foo (int);\n+\n+int gate1(int size, int *node, int *hash)\n+{\n+  int i, j ;\n+  int add_size=0;\n+  for(i=0; i<size; i++)\n+  {\n+     j = get_state(size,node, hash);\n+     if(j == -1)\n+     {\n+    \tadd_size++;\n+     }\n+  }\n+\n+  foo (size+add_size);\n+}"}, {"sha": "9c48d8d095f433b280139e91b76e6e7c837a498f", "filename": "gcc/testsuite/gcc.dg/graphite/pr38073.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr38073.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr38073.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr38073.c?ref=81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-options \"-O3 -fgraphite-identity\" } */\n+\n+test_seg(int a, int b)\n+{\n+  int i,r=1;\n+  for(i=0; i<b ;i++)\n+    r*=a;\n+  return r;\n+}"}, {"sha": "780e6f643e65d8c08974bfb4429dc198b9f7ced3", "filename": "gcc/testsuite/gcc.dg/graphite/pr38125.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr38125.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr38125.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr38125.c?ref=81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-options \"-O3 -fgraphite-identity\" } */\n+\n+typedef struct sv TEST_SV;\n+typedef struct av TEST_AV;\n+typedef struct magic TEST_MAGIC;\n+typedef struct xpvav TEST_XPVAV;\n+struct sv \n+{\n+    void* sv_any;\n+};\n+struct av \n+{\n+    TEST_XPVAV* sv_any;\n+};\n+struct xpvav \n+{\n+    char* xav_array;\n+    long int xav_fill;\n+    long int xav_max;\n+};\n+struct magic {\n+    TEST_SV* mg_obj;\n+};\n+extern TEST_SV PL_sv_undef;\n+Perl_av_fill( register TEST_AV *av, int fill)\n+{\n+    TEST_MAGIC *mg;\n+    int key = ((TEST_XPVAV*) (av)->sv_any)->xav_fill;\n+    TEST_SV** ary = ((TEST_SV**)((TEST_XPVAV*) (av)->sv_any)->xav_array);\n+    while (key < fill)\n+          ary[++key] = &PL_sv_undef;\n+}"}, {"sha": "6264116e114178f916a1480937a4f78843c3eb9f", "filename": "gcc/testsuite/gcc.dg/graphite/scop-18.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fscop-18.c?ref=81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-O2 -floop-block -fdump-tree-graphite-all\" } */\n+/* { dg-options \"-O2 -fgraphite -fdump-tree-graphite-all\" } */\n \n #define N 24\n #define M 1000\n@@ -13,14 +13,14 @@ void test (void)\n   for (i = 0; i < 24; i++)\n     for (j = 0; j < 24; j++)\n       for (k = 0; k < 24; k++)\n-        A[i][j] += B[i][k] * C[k][j];\n+        A[i][j] = B[i][k] * C[k][j];\n \n   /* These loops should still be strip mined.  */\n   for (i = 0; i < 1000; i++)\n     for (j = 0; j < 1000; j++)\n       for (k = 0; k < 1000; k++)\n-        A[i][j] += B[i][k] * C[k][j];\n+        A[i][j] = B[i][k] * C[k][j];\n }\n \n-/* { dg-final { scan-tree-dump-times \"Strip Mining is not profitable\" 3 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"number of SCoPs: 2\" 1 \"graphite\"} } */ \n /* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "0c9f54bb97939e6eb588b7ec9cf2ab375f9e2566", "filename": "gcc/testsuite/gfortran.dg/graphite/id-2.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fid-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fid-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fid-2.f90?ref=81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "patch": "@@ -0,0 +1,15 @@\n+! { dg-options \"-O2 -fgraphite-identity\" }\n+\n+module solv_cap\n+  integer, parameter, public :: dp = selected_real_kind(5)\n+contains\n+  subroutine prod0( G, X )\n+    real(kind=dp), intent(in out), dimension(:,:)    :: X\n+    real(kind=dp), dimension(size(X,1),size(X,2)) :: Y\n+    X = Y\n+  end subroutine prod0\n+  function Ginteg(xq1,yq1, xq2,yq2, xp,yp)  result(G)\n+  end function Ginteg\n+  subroutine fourir(A,ntot,kconjg, E,useold)\n+  end subroutine fourir\n+end module solv_cap"}, {"sha": "896d608777eee00b574ffa951fe66248daace3c0", "filename": "gcc/testsuite/gfortran.dg/graphite/id-4.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fid-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fid-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fid-4.f90?ref=81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "patch": "@@ -0,0 +1,34 @@\n+! { dg-options \"-O2 -fgraphite-identity\" }\n+\n+MODULE Vcimage\n+  CHARACTER (LEN=80), SAVE :: CARD, FIELD\n+END MODULE Vcimage\n+MODULE Vimage\n+  LOGICAL, SAVE ::  EOFF\n+END MODULE Vimage\n+SUBROUTINE READIN(PROB, TITLE, CSTOP, FCYCLE, DCYCLE, DHIST, VHIST&\n+     &    , IMAX, PHIST, DEBUG, NSTAT, STATS, MAXSTA, NCORE, PPLOT,     &\n+     &    DPLOT, VPLOT, TPLOT, SLIST, D0, E0, NODES, SHEAT, GAMMA, COLD &\n+     &    , THIST, NVISC, SCREEN, WEIGHT, TSTOP, STABF)\n+  USE Vcimage\n+  USE Vimage\n+  INTEGER, DIMENSION(MAXSTA) :: STATS\n+  IF (.NOT.EOFF) THEN\n+     IF (FIELD=='PROB' .OR. FIELD=='PROBLEM_NUMBER') THEN\n+        CALL QSORT (STATS(1:NSTAT))\n+        WRITE (16,                                                 &\n+             &'(//'' YOU HAVE REQUESTED A PRINTOUT OF THE STATION'',            &\n+             &    '' ABORT''//)')\n+     ENDIF\n+  ENDIF\n+CONTAINS\n+  RECURSIVE SUBROUTINE QSORT (LIST)\n+    INTEGER, DIMENSION(:), INTENT(INOUT) :: LIST\n+    INTEGER, DIMENSION(SIZE(LIST)) :: SMALLER,LARGER\n+    IF (SIZE(LIST) > 1) THEN\n+       LIST(NUMBER_SMALLER+1:NUMBER_SMALLER+NUMBER_EQUAL) = CHOSEN\n+       CALL QSORT (LARGER(1:NUMBER_LARGER))\n+       LIST(NUMBER_SMALLER+NUMBER_EQUAL+1:) = LARGER(1:NUMBER_LARGER)\n+    END IF\n+  END SUBROUTINE QSORT\n+END SUBROUTINE READIN"}, {"sha": "50e23428f82717f4254db28a3f4e7ce0e7c6e11f", "filename": "gcc/testsuite/gfortran.dg/graphite/pr37852.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr37852.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr37852.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr37852.f90?ref=81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "patch": "@@ -0,0 +1,13 @@\n+! { dg-options \"-O2 -floop-block\" }\n+\n+PROGRAM TEST_FPU\n+CHARACTER (LEN=36) :: invert_id(1) = &\n+                      (/ 'Test1 - Gauss 2000 (101x101) inverts'/)\n+END PROGRAM TEST_FPU\n+\n+SUBROUTINE Gauss (a,n)\n+INTEGER, PARAMETER :: RK8 = SELECTED_REAL_KIND(15, 300)\n+REAL(RK8) :: a(n,n)\n+INTEGER ::  ipvt(n)\n+a(:,ipvt) = b\n+END SUBROUTINE Gauss"}, {"sha": "5306aa84c923c233bf5ed400ab001714584f7ef8", "filename": "gcc/testsuite/gfortran.dg/graphite/pr37980.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr37980.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr37980.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr37980.f90?ref=81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "patch": "@@ -0,0 +1,11 @@\n+! { dg-options \"-O2 -floop-block\" }\n+\n+module INT_MODULE\n+contains\n+  pure function spher_cartesians(in1) result(out1)\n+    integer(kind=kind(1)) :: in1 \n+    intent(in) :: in1 \n+    real(kind=kind(1.0d0)), dimension(0:in1,0:in1,0:in1) :: mat0\n+    mat0 = 0.0d0\n+  end function spher_cartesians\n+end module INT_MODULE"}, {"sha": "834d33ab833d415cf76c3d63704c0b06c723e25f", "filename": "gcc/testsuite/gfortran.dg/graphite/pr38083.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr38083.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr38083.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgraphite%2Fpr38083.f90?ref=81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "patch": "@@ -0,0 +1,16 @@\n+! { dg-options \"-O3 -floop-block\" }\n+\n+SUBROUTINE IVSORT (IL,IH,NSEGS,IOUNIT)\n+  INTEGER IOUNIT  \n+\n+  INTEGER, PARAMETER :: MAXGS = 32\n+\n+10 IF (IL .GE. IH) GO TO 80\n+20 NSEGS = (IH + IL) / 2\n+  IF (NSEGS .GT. MAXSGS) THEN\n+     WRITE (IOUNIT),MAXSGS\n+  ENDIF\n+80 NSEGS = NSEGS - 1\n+90 IF (IH - IL .GE. 11) GO TO 20\n+110 IF (IL .EQ. IH) GO TO 80\n+END SUBROUTINE IVSORT"}, {"sha": "89621f0a80ac849d2839077cca62860dd6c5be1e", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "patch": "@@ -2072,14 +2072,9 @@ struct gimple_opt_pass pass_remove_useless_stmts =\n static void\n remove_phi_nodes_and_edges_for_unreachable_block (basic_block bb)\n {\n-  gimple_stmt_iterator gsi;\n-\n   /* Since this block is no longer reachable, we can just delete all\n      of its PHI nodes.  */\n-  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); )\n-    remove_phi_node (&gsi, true);\n-\n-  set_phi_nodes (bb, NULL);\n+  remove_phi_nodes (bb);\n \n   /* Remove edges to BB's successors.  */\n   while (EDGE_COUNT (bb->succs) > 0)"}, {"sha": "d4e0004d834df4dcd8bae752ed9d7fcabf953106", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "patch": "@@ -787,6 +787,7 @@ extern gimple create_phi_node (tree, basic_block);\n extern void add_phi_arg (gimple, tree, edge);\n extern void remove_phi_args (edge);\n extern void remove_phi_node (gimple_stmt_iterator *, bool);\n+extern void remove_phi_nodes (basic_block);\n extern void init_phinodes (void);\n extern void fini_phinodes (void);\n extern void release_phi_node (gimple);\n@@ -988,6 +989,7 @@ unsigned int tree_ssa_prefetch_arrays (void);\n unsigned int remove_empty_loops (void);\n void tree_ssa_iv_optimize (void);\n unsigned tree_predictive_commoning (void);\n+tree canonicalize_loop_ivs (struct loop *, htab_t, tree);\n bool parallelize_loops (void);\n \n bool loop_only_exit_p (const struct loop *, const_edge);"}, {"sha": "91ce890755fd619970e57cdbffbae07b85d715ec", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "patch": "@@ -1325,9 +1325,10 @@ create_loop_fn (void)\n /* Bases all the induction variables in LOOP on a single induction variable\n    (unsigned with base 0 and step 1), whose final value is compared with\n    NIT.  The induction variable is incremented in the loop latch.  \n-   REDUCTION_LIST describes the reductions in LOOP.  */\n+   REDUCTION_LIST describes the reductions in LOOP.  Return the induction \n+   variable that was created.  */\n \n-static void\n+tree\n canonicalize_loop_ivs (struct loop *loop, htab_t reduction_list, tree nit)\n {\n   unsigned precision = TYPE_PRECISION (TREE_TYPE (nit));\n@@ -1368,7 +1369,12 @@ canonicalize_loop_ivs (struct loop *loop, htab_t reduction_list, tree nit)\n \t}\n \n       ok = simple_iv (loop, phi, res, &iv, true);\n-      red = reduction_phi (reduction_list, phi);\n+\n+      if (reduction_list)\n+\tred = reduction_phi (reduction_list, phi);\n+      else\n+\tred = NULL;\n+\n       /* We preserve the reduction phi nodes.  */\n       if (!ok && red)\n \t{\n@@ -1406,6 +1412,9 @@ canonicalize_loop_ivs (struct loop *loop, htab_t reduction_list, tree nit)\n   gimple_cond_set_code (stmt, LT_EXPR);\n   gimple_cond_set_lhs (stmt, var_before);\n   gimple_cond_set_rhs (stmt, nit);\n+  update_stmt (stmt);\n+\n+  return var_before;\n }\n \n /* Moves the exit condition of LOOP to the beginning of its header, and"}, {"sha": "fd6ac3a511bcb48b6091efdd98080a4a4a4effd1", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=81b822d5d08d3158fe0dd4afdef519e6a1cc4ee1", "patch": "@@ -474,4 +474,17 @@ remove_phi_node (gimple_stmt_iterator *gsi, bool release_lhs_p)\n     release_ssa_name (gimple_phi_result (phi));\n }\n \n+/* Remove all the phi nodes from BB.  */\n+\n+void\n+remove_phi_nodes (basic_block bb)\n+{\n+  gimple_stmt_iterator gsi;\n+\n+  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); )\n+    remove_phi_node (&gsi, true);\n+\n+  set_phi_nodes (bb, NULL);\n+}\n+\n #include \"gt-tree-phinodes.h\""}]}