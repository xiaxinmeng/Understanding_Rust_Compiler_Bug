{"sha": "34b43828f840640f8275712867fc52ef6c2714dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRiNDM4MjhmODQwNjQwZjgyNzU3MTI4NjdmYzUyZWY2YzI3MTRkZA==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2019-11-29T01:06:57Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2019-11-29T01:06:57Z"}, "message": "Handle C2x attributes in Objective-C.\n\nWhen adding the initial support for C2x attributes, I deferred the\nunbounded lookahead support required to support such attributes in\nObjective-C (except for the changes to string literal handling, which\nwere the riskier piece of preparation for such lookahead support).\nThis patch adds that remaining ObjC support.\n\nFor C, the parser continues to work exactly as it did before.  For\nObjC, however, when checking for whether '[[' starts attributes, it\nlexes however many tokens are needed to check for a matching ']]', but\nin a raw mode that omits all the context-sensitive processing that\nc_lex_with_flags normally does, so that that processing can be done\nlater when the right context-sensitive flags are set.  Those tokens\nare saved in a separate raw_tokens vector in the parser, and normal\nc_lex_one_token calls will get tokens from there and perform the\nremaining processing on them, if any tokens are found there, so all\nparsing not using the new interfaces gets the same tokens as it did\nbefore.  (For C, this raw lexing never occurs and the vector of raw\ntokens is always NULL.)\n\nBootstrapped with no regressions for x86_64-pc-linux-gnu.\n\ngcc/c:\n\t* c-parser.c (struct c_parser): Add members raw_tokens and\n\traw_tokens_used.\n\t(c_lex_one_token): Add argument raw.  Handle lexing raw tokens and\n\tusing previously-lexed raw tokens.\n\t(c_parser_peek_nth_token_raw)\n\t(c_parser_check_balanced_raw_token_sequence): New functions.\n\t(c_parser_nth_token_starts_std_attributes): Use\n\tc_parser_check_balanced_raw_token_sequence for Objective-C.\n\ngcc/testsuite:\n\t* objc.dg/attributes/gnu2x-attr-syntax-1.m: New test.\n\nFrom-SVN: r278827", "tree": {"sha": "562eed26a9a2096a4c4fd6e2005a1601c1484355", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/562eed26a9a2096a4c4fd6e2005a1601c1484355"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34b43828f840640f8275712867fc52ef6c2714dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34b43828f840640f8275712867fc52ef6c2714dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34b43828f840640f8275712867fc52ef6c2714dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34b43828f840640f8275712867fc52ef6c2714dd/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70ce1ab9fd2e201631b253bb62489d07189d2d50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70ce1ab9fd2e201631b253bb62489d07189d2d50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70ce1ab9fd2e201631b253bb62489d07189d2d50"}], "stats": {"total": 180, "additions": 167, "deletions": 13}, "files": [{"sha": "b69e82d5645f47f5876eba0dbc73b626c013a8db", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34b43828f840640f8275712867fc52ef6c2714dd/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34b43828f840640f8275712867fc52ef6c2714dd/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=34b43828f840640f8275712867fc52ef6c2714dd", "patch": "@@ -1,3 +1,14 @@\n+2019-11-29  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-parser.c (struct c_parser): Add members raw_tokens and\n+\traw_tokens_used.\n+\t(c_lex_one_token): Add argument raw.  Handle lexing raw tokens and\n+\tusing previously-lexed raw tokens.\n+\t(c_parser_peek_nth_token_raw)\n+\t(c_parser_check_balanced_raw_token_sequence): New functions.\n+\t(c_parser_nth_token_starts_std_attributes): Use\n+\tc_parser_check_balanced_raw_token_sequence for Objective-C.\n+\n 2019-11-25  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/91985"}, {"sha": "bfe569989964dbc4d9ba15dbde39d79bb05e0bd4", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 147, "deletions": 13, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34b43828f840640f8275712867fc52ef6c2714dd/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34b43828f840640f8275712867fc52ef6c2714dd/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=34b43828f840640f8275712867fc52ef6c2714dd", "patch": "@@ -176,6 +176,12 @@ struct GTY(()) c_parser {\n   /* How many look-ahead tokens are available (0 - 4, or\n      more if parsing from pre-lexed tokens).  */\n   unsigned int tokens_avail;\n+  /* Raw look-ahead tokens, used only for checking in Objective-C\n+     whether '[[' starts attributes.  */\n+  vec<c_token, va_gc> *raw_tokens;\n+  /* The number of raw look-ahead tokens that have since been fully\n+     lexed.  */\n+  unsigned int raw_tokens_used;\n   /* True if a syntax error is being recovered from; false otherwise.\n      c_parser_error sets this flag.  It should clear this flag when\n      enough tokens have been consumed to recover from the error.  */\n@@ -251,20 +257,39 @@ c_parser_set_error (c_parser *parser, bool err)\n \n static GTY (()) c_parser *the_parser;\n \n-/* Read in and lex a single token, storing it in *TOKEN.  */\n+/* Read in and lex a single token, storing it in *TOKEN.  If RAW,\n+   context-sensitive postprocessing of the token is not done.  */\n \n static void\n-c_lex_one_token (c_parser *parser, c_token *token)\n+c_lex_one_token (c_parser *parser, c_token *token, bool raw = false)\n {\n   timevar_push (TV_LEX);\n \n-  token->type = c_lex_with_flags (&token->value, &token->location,\n-\t\t\t\t  &token->flags,\n-\t\t\t\t  (parser->lex_joined_string\n-\t\t\t\t   ? 0 : C_LEX_STRING_NO_JOIN));\n-  token->id_kind = C_ID_NONE;\n-  token->keyword = RID_MAX;\n-  token->pragma_kind = PRAGMA_NONE;\n+  if (raw || vec_safe_length (parser->raw_tokens) == 0)\n+    {\n+      token->type = c_lex_with_flags (&token->value, &token->location,\n+\t\t\t\t      &token->flags,\n+\t\t\t\t      (parser->lex_joined_string\n+\t\t\t\t       ? 0 : C_LEX_STRING_NO_JOIN));\n+      token->id_kind = C_ID_NONE;\n+      token->keyword = RID_MAX;\n+      token->pragma_kind = PRAGMA_NONE;\n+    }\n+  else\n+    {\n+      /* Use a token previously lexed as a raw look-ahead token, and\n+\t complete the processing on it.  */\n+      *token = (*parser->raw_tokens)[parser->raw_tokens_used];\n+      ++parser->raw_tokens_used;\n+      if (parser->raw_tokens_used == vec_safe_length (parser->raw_tokens))\n+\t{\n+\t  vec_free (parser->raw_tokens);\n+\t  parser->raw_tokens_used = 0;\n+\t}\n+    }\n+\n+  if (raw)\n+    goto out;\n \n   switch (token->type)\n     {\n@@ -434,6 +459,7 @@ c_lex_one_token (c_parser *parser, c_token *token)\n     default:\n       break;\n     }\n+ out:\n   timevar_pop (TV_LEX);\n }\n \n@@ -484,6 +510,32 @@ c_parser_peek_nth_token (c_parser *parser, unsigned int n)\n   return &parser->tokens[n - 1];\n }\n \n+/* Return a pointer to the Nth token from PARSER, reading it in as a\n+   raw look-ahead token if necessary.  The N-1th token is already read\n+   in.  Raw look-ahead tokens remain available for when the non-raw\n+   functions above are called.  */\n+\n+c_token *\n+c_parser_peek_nth_token_raw (c_parser *parser, unsigned int n)\n+{\n+  /* N is 1-based, not zero-based.  */\n+  gcc_assert (n > 0);\n+\n+  if (parser->tokens_avail >= n)\n+    return &parser->tokens[n - 1];\n+  unsigned int raw_len = vec_safe_length (parser->raw_tokens);\n+  unsigned int raw_avail\n+    = parser->tokens_avail + raw_len - parser->raw_tokens_used;\n+  gcc_assert (raw_avail >= n - 1);\n+  if (raw_avail >= n)\n+    return &(*parser->raw_tokens)[parser->raw_tokens_used\n+\t\t\t\t  + n - 1 - parser->tokens_avail];\n+  vec_safe_reserve (parser->raw_tokens, 1);\n+  parser->raw_tokens->quick_grow (raw_len + 1);\n+  c_lex_one_token (parser, &(*parser->raw_tokens)[raw_len], true);\n+  return &(*parser->raw_tokens)[raw_len];\n+}\n+\n bool\n c_keyword_starts_typename (enum rid keyword)\n {\n@@ -4968,6 +5020,80 @@ c_parser_std_attribute_specifier (c_parser *parser, bool for_tm)\n   return nreverse (attributes);\n }\n \n+/* Look past an optional balanced token sequence of raw look-ahead\n+   tokens starting with the *Nth token.  *N is updated to point to the\n+   following token.  Return true if such a sequence was found, false\n+   if the tokens parsed were not balanced.  */\n+\n+static bool\n+c_parser_check_balanced_raw_token_sequence (c_parser *parser, unsigned int *n)\n+{\n+  while (true)\n+    {\n+      c_token *token = c_parser_peek_nth_token_raw (parser, *n);\n+      switch (token->type)\n+\t{\n+\tcase CPP_OPEN_BRACE:\n+\t  {\n+\t    ++*n;\n+\t    if (c_parser_check_balanced_raw_token_sequence (parser, n))\n+\t      {\n+\t\ttoken = c_parser_peek_nth_token_raw (parser, *n);\n+\t\tif (token->type == CPP_CLOSE_BRACE)\n+\t\t  ++*n;\n+\t\telse\n+\t\t  return false;\n+\t      }\n+\t    else\n+\t      return false;\n+\t    break;\n+\t  }\n+\n+\tcase CPP_OPEN_PAREN:\n+\t  {\n+\t    ++*n;\n+\t    if (c_parser_check_balanced_raw_token_sequence (parser, n))\n+\t      {\n+\t\ttoken = c_parser_peek_nth_token_raw (parser, *n);\n+\t\tif (token->type == CPP_CLOSE_PAREN)\n+\t\t  ++*n;\n+\t\telse\n+\t\t  return false;\n+\t      }\n+\t    else\n+\t      return false;\n+\t    break;\n+\t  }\n+\n+\tcase CPP_OPEN_SQUARE:\n+\t  {\n+\t    ++*n;\n+\t    if (c_parser_check_balanced_raw_token_sequence (parser, n))\n+\t      {\n+\t\ttoken = c_parser_peek_nth_token_raw (parser, *n);\n+\t\tif (token->type == CPP_CLOSE_SQUARE)\n+\t\t  ++*n;\n+\t\telse\n+\t\t  return false;\n+\t      }\n+\t    else\n+\t      return false;\n+\t    break;\n+\t  }\n+\n+\tcase CPP_CLOSE_BRACE:\n+\tcase CPP_CLOSE_PAREN:\n+\tcase CPP_CLOSE_SQUARE:\n+\tcase CPP_EOF:\n+\t  return true;\n+\n+\tdefault:\n+\t  ++*n;\n+\t  break;\n+\t}\n+    }\n+}\n+\n /* Return whether standard attributes start with the Nth token.  */\n \n static bool\n@@ -4976,10 +5102,18 @@ c_parser_nth_token_starts_std_attributes (c_parser *parser, unsigned int n)\n   if (!(c_parser_peek_nth_token (parser, n)->type == CPP_OPEN_SQUARE\n \t&& c_parser_peek_nth_token (parser, n + 1)->type == CPP_OPEN_SQUARE))\n     return false;\n-  /* In C, '[[' must start attributes.  In Objective-C, identifying\n-     whether those tokens start attributes requires unbounded\n-     lookahead, which is not yet implemented.  */\n-  return !c_dialect_objc ();\n+  /* In C, '[[' must start attributes.  In Objective-C, we need to\n+     check whether '[[' is matched by ']]'.  */\n+  if (!c_dialect_objc ())\n+    return true;\n+  n += 2;\n+  if (!c_parser_check_balanced_raw_token_sequence (parser, &n))\n+    return false;\n+  c_token *token = c_parser_peek_nth_token_raw (parser, n);\n+  if (token->type != CPP_CLOSE_SQUARE)\n+    return false;\n+  token = c_parser_peek_nth_token_raw (parser, n + 1);\n+  return token->type == CPP_CLOSE_SQUARE;\n }\n \n static tree"}, {"sha": "f5bb0d2113e4f2dfdbe02426acc5fb5ec525323f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34b43828f840640f8275712867fc52ef6c2714dd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34b43828f840640f8275712867fc52ef6c2714dd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=34b43828f840640f8275712867fc52ef6c2714dd", "patch": "@@ -1,3 +1,7 @@\n+2019-11-29  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* objc.dg/attributes/gnu2x-attr-syntax-1.m: New test.\n+\n 2019-11-28  Martin Liska  <mliska@suse.cz>\n \n \tPR lto/92609"}, {"sha": "7c727343075e1d24497a9e75fb90f74bf3a662ac", "filename": "gcc/testsuite/objc.dg/attributes/gnu2x-attr-syntax-1.m", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34b43828f840640f8275712867fc52ef6c2714dd/gcc%2Ftestsuite%2Fobjc.dg%2Fattributes%2Fgnu2x-attr-syntax-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34b43828f840640f8275712867fc52ef6c2714dd/gcc%2Ftestsuite%2Fobjc.dg%2Fattributes%2Fgnu2x-attr-syntax-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fattributes%2Fgnu2x-attr-syntax-1.m?ref=34b43828f840640f8275712867fc52ef6c2714dd", "patch": "@@ -0,0 +1,5 @@\n+/* Test C2x attribute syntax.  Test empty attributes accepted.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu2x\" } */\n+\n+#include \"../../gcc.dg/c2x-attr-syntax-1.c\""}]}