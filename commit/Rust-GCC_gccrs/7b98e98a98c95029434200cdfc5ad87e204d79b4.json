{"sha": "7b98e98a98c95029434200cdfc5ad87e204d79b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I5OGU5OGE5OGM5NTAyOTQzNDIwMGNkZmM1YWQ4N2UyMDRkNzliNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-06-30T12:47:50Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-06-30T12:47:50Z"}, "message": "[10/n] PR85694: Split out check for vectorizable associative reductions\n\nThis patch adds an overload of vect_reassociating_reduction_p\nthat checks for a vectorizable associative reduction,\nsince the check was duplicated in three functions.\n\n2018-06-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-patterns.c (vect_reassociating_reduction_p): New function.\n\t(vect_recog_dot_prod_pattern, vect_recog_sad_pattern)\n\t(vect_recog_widen_sum_pattern): Use it.\n\nFrom-SVN: r262274", "tree": {"sha": "861909cc49f297a0be9d745dec74c388098a21b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/861909cc49f297a0be9d745dec74c388098a21b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b98e98a98c95029434200cdfc5ad87e204d79b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b98e98a98c95029434200cdfc5ad87e204d79b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b98e98a98c95029434200cdfc5ad87e204d79b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b98e98a98c95029434200cdfc5ad87e204d79b4/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0f8c840c28c11b13e630b55ad3dc6e0670b4f817", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f8c840c28c11b13e630b55ad3dc6e0670b4f817", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f8c840c28c11b13e630b55ad3dc6e0670b4f817"}], "stats": {"total": 116, "additions": 47, "deletions": 69}, "files": [{"sha": "2312ed5204d3ed138fda167a622150aed621a0c5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b98e98a98c95029434200cdfc5ad87e204d79b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b98e98a98c95029434200cdfc5ad87e204d79b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b98e98a98c95029434200cdfc5ad87e204d79b4", "patch": "@@ -1,3 +1,9 @@\n+2018-06-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-patterns.c (vect_reassociating_reduction_p): New function.\n+\t(vect_recog_dot_prod_pattern, vect_recog_sad_pattern)\n+\t(vect_recog_widen_sum_pattern): Use it.\n+\n 2018-06-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-loop.c (vectorizable_reduction): Assert that the"}, {"sha": "6be23d0124a448c04b677b2056674e136ac5b6b6", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 41, "deletions": 69, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b98e98a98c95029434200cdfc5ad87e204d79b4/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b98e98a98c95029434200cdfc5ad87e204d79b4/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=7b98e98a98c95029434200cdfc5ad87e204d79b4", "patch": "@@ -239,6 +239,36 @@ vect_reassociating_reduction_p (stmt_vec_info stmt_vinfo)\n \t  : REDUC_GROUP_FIRST_ELEMENT (stmt_vinfo) != NULL);\n }\n \n+/* As above, but also require it to have code CODE and to be a reduction\n+   in the outermost loop.  When returning true, store the operands in\n+   *OP0_OUT and *OP1_OUT.  */\n+\n+static bool\n+vect_reassociating_reduction_p (stmt_vec_info stmt_info, tree_code code,\n+\t\t\t\ttree *op0_out, tree *op1_out)\n+{\n+  loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  if (!loop_info)\n+    return false;\n+\n+  gassign *assign = dyn_cast <gassign *> (stmt_info->stmt);\n+  if (!assign || gimple_assign_rhs_code (assign) != code)\n+    return false;\n+\n+  /* We don't allow changing the order of the computation in the inner-loop\n+     when doing outer-loop vectorization.  */\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_info);\n+  if (loop && nested_in_vect_loop_p (loop, assign))\n+    return false;\n+\n+  if (!vect_reassociating_reduction_p (stmt_info))\n+    return false;\n+\n+  *op0_out = gimple_assign_rhs1 (assign);\n+  *op1_out = gimple_assign_rhs2 (assign);\n+  return true;\n+}\n+\n /* Function vect_recog_dot_prod_pattern\n \n    Try to find the following pattern:\n@@ -293,26 +323,9 @@ vect_recog_dot_prod_pattern (vec<gimple *> *stmts, tree *type_out)\n   tree type, half_type;\n   gimple *pattern_stmt;\n   tree prod_type;\n-  loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  struct loop *loop;\n   tree var;\n   bool promotion;\n \n-  if (!loop_info)\n-    return NULL;\n-\n-  loop = LOOP_VINFO_LOOP (loop_info);\n-\n-  /* We don't allow changing the order of the computation in the inner-loop\n-     when doing outer-loop vectorization.  */\n-  if (loop && nested_in_vect_loop_p (loop, last_stmt))\n-    return NULL;\n-\n-  if (!is_gimple_assign (last_stmt))\n-    return NULL;\n-\n-  type = gimple_expr_type (last_stmt);\n-\n   /* Look for the following pattern\n           DX = (TYPE1) X;\n           DY = (TYPE1) Y;\n@@ -337,17 +350,14 @@ vect_recog_dot_prod_pattern (vec<gimple *> *stmts, tree *type_out)\n   /* Starting from LAST_STMT, follow the defs of its uses in search\n      of the above pattern.  */\n \n-  if (gimple_assign_rhs_code (last_stmt) != PLUS_EXPR)\n-    return NULL;\n-\n   if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n     return NULL;\n \n-  if (!vect_reassociating_reduction_p (stmt_vinfo))\n+  if (!vect_reassociating_reduction_p (stmt_vinfo, PLUS_EXPR,\n+\t\t\t\t       &oprnd0, &oprnd1))\n     return NULL;\n \n-  oprnd0 = gimple_assign_rhs1 (last_stmt);\n-  oprnd1 = gimple_assign_rhs2 (last_stmt);\n+  type = gimple_expr_type (last_stmt);\n   stmt = last_stmt;\n \n   gimple *def_stmt;\n@@ -471,25 +481,8 @@ vect_recog_sad_pattern (vec<gimple *> *stmts, tree *type_out)\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n   vec_info *vinfo = stmt_vinfo->vinfo;\n   tree half_type;\n-  loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  struct loop *loop;\n   bool promotion;\n \n-  if (!loop_info)\n-    return NULL;\n-\n-  loop = LOOP_VINFO_LOOP (loop_info);\n-\n-  /* We don't allow changing the order of the computation in the inner-loop\n-     when doing outer-loop vectorization.  */\n-  if (loop && nested_in_vect_loop_p (loop, last_stmt))\n-    return NULL;\n-\n-  if (!is_gimple_assign (last_stmt))\n-    return NULL;\n-\n-  tree sum_type = gimple_expr_type (last_stmt);\n-\n   /* Look for the following pattern\n           DX = (TYPE1) X;\n           DY = (TYPE1) Y;\n@@ -517,19 +510,15 @@ vect_recog_sad_pattern (vec<gimple *> *stmts, tree *type_out)\n   /* Starting from LAST_STMT, follow the defs of its uses in search\n      of the above pattern.  */\n \n-  if (gimple_assign_rhs_code (last_stmt) != PLUS_EXPR)\n-    return NULL;\n-\n-  tree plus_oprnd0, plus_oprnd1;\n-\n   if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n     return NULL;\n \n-  if (!vect_reassociating_reduction_p (stmt_vinfo))\n+  tree plus_oprnd0, plus_oprnd1;\n+  if (!vect_reassociating_reduction_p (stmt_vinfo, PLUS_EXPR,\n+\t\t\t\t       &plus_oprnd0, &plus_oprnd1))\n     return NULL;\n \n-  plus_oprnd0 = gimple_assign_rhs1 (last_stmt);\n-  plus_oprnd1 = gimple_assign_rhs2 (last_stmt);\n+  tree sum_type = gimple_expr_type (last_stmt);\n \n   /* The type conversion could be promotion, demotion,\n      or just signed -> unsigned.  */\n@@ -1133,26 +1122,12 @@ vect_recog_widen_sum_pattern (vec<gimple *> *stmts, tree *type_out)\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n   tree type, half_type;\n   gimple *pattern_stmt;\n-  loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n-  struct loop *loop;\n   tree var;\n   bool promotion;\n \n-  if (!loop_info)\n-    return NULL;\n-\n-  loop = LOOP_VINFO_LOOP (loop_info);\n-\n-  /* We don't allow changing the order of the computation in the inner-loop\n-     when doing outer-loop vectorization.  */\n-  if (loop && nested_in_vect_loop_p (loop, last_stmt))\n-    return NULL;\n-\n-  if (!is_gimple_assign (last_stmt))\n+  if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n     return NULL;\n \n-  type = gimple_expr_type (last_stmt);\n-\n   /* Look for the following pattern\n           DX = (TYPE) X;\n           sum_1 = DX + sum_0;\n@@ -1163,14 +1138,11 @@ vect_recog_widen_sum_pattern (vec<gimple *> *stmts, tree *type_out)\n   /* Starting from LAST_STMT, follow the defs of its uses in search\n      of the above pattern.  */\n \n-  if (gimple_assign_rhs_code (last_stmt) != PLUS_EXPR)\n+  if (!vect_reassociating_reduction_p (stmt_vinfo, PLUS_EXPR,\n+\t\t\t\t       &oprnd0, &oprnd1))\n     return NULL;\n \n-  if (!vect_reassociating_reduction_p (stmt_vinfo))\n-    return NULL;\n-\n-  oprnd0 = gimple_assign_rhs1 (last_stmt);\n-  oprnd1 = gimple_assign_rhs2 (last_stmt);\n+  type = gimple_expr_type (last_stmt);\n \n   /* So far so good.  Since last_stmt was detected as a (summation) reduction,\n      we know that oprnd1 is the reduction variable (defined by a loop-header"}]}