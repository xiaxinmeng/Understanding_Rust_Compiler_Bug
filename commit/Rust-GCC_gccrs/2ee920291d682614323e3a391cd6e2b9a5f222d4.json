{"sha": "2ee920291d682614323e3a391cd6e2b9a5f222d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVlOTIwMjkxZDY4MjYxNDMyM2UzYTM5MWNkNmUyYjlhNWYyMjJkNA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-03-31T19:47:23Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-03-31T19:47:23Z"}, "message": "Remove some files that were accidentally committed in 2014.\n\nFrom-SVN: r221802", "tree": {"sha": "9a3c405a0cfc0cf7ce1b5504e577ec09f084bd69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a3c405a0cfc0cf7ce1b5504e577ec09f084bd69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ee920291d682614323e3a391cd6e2b9a5f222d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ee920291d682614323e3a391cd6e2b9a5f222d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ee920291d682614323e3a391cd6e2b9a5f222d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ee920291d682614323e3a391cd6e2b9a5f222d4/comments", "author": null, "committer": null, "parents": [{"sha": "d723bc36dd7857b3e01440be634fcb7ce6cd60ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d723bc36dd7857b3e01440be634fcb7ce6cd60ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d723bc36dd7857b3e01440be634fcb7ce6cd60ea"}], "stats": {"total": 1612, "additions": 0, "deletions": 1612}, "files": [{"sha": "4559c0f2d0d28a8d8503a30ecfd70a4a4694d38f", "filename": "libgo/runtime/chan.c", "status": "removed", "additions": 0, "deletions": 1186, "changes": 1186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d723bc36dd7857b3e01440be634fcb7ce6cd60ea/libgo%2Fruntime%2Fchan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d723bc36dd7857b3e01440be634fcb7ce6cd60ea/libgo%2Fruntime%2Fchan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fchan.c?ref=d723bc36dd7857b3e01440be634fcb7ce6cd60ea", "patch": "@@ -1,1186 +0,0 @@\n-// AUTO-GENERATED by autogen.sh; DO NOT EDIT\n-\n-#include \"runtime.h\"\n-#include \"arch.h\"\n-#include \"go-type.h\"\n-#include \"race.h\"\n-#include \"malloc.h\"\n-#include \"chan.h\"\n-\n-#line 13 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-uint32 runtime_Hchansize = sizeof ( Hchan ) ; \n-#line 15 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static void dequeueg ( WaitQ* ) ; \n-static SudoG* dequeue ( WaitQ* ) ; \n-static void enqueue ( WaitQ* , SudoG* ) ; \n-static void racesync ( Hchan* , SudoG* ) ; \n-#line 20 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static Hchan* \n-makechan ( ChanType *t , int64 hint ) \n-{ \n-Hchan *c; \n-uintptr n; \n-const Type *elem; \n-#line 27 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-elem = t->__element_type; \n-#line 30 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( elem->__size >= ( 1<<16 ) ) \n-runtime_throw ( \"makechan: invalid channel element type\" ) ; \n-#line 33 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( hint < 0 || ( intgo ) hint != hint || ( elem->__size > 0 && ( uintptr ) hint > ( MaxMem - sizeof ( *c ) ) / elem->__size ) ) \n-runtime_panicstring ( \"makechan: size out of range\" ) ; \n-#line 36 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-n = sizeof ( *c ) ; \n-n = ROUND ( n , elem->__align ) ; \n-#line 40 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-c = ( Hchan* ) runtime_mallocgc ( sizeof ( *c ) + hint*elem->__size , ( uintptr ) t | TypeInfo_Chan , 0 ) ; \n-c->elemsize = elem->__size; \n-c->elemtype = elem; \n-c->dataqsiz = hint; \n-#line 45 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( debug ) \n-runtime_printf ( \"makechan: chan=%p; elemsize=%D; dataqsiz=%D\\n\" , \n-c , ( int64 ) elem->__size , ( int64 ) c->dataqsiz ) ; \n-#line 49 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-return c; \n-} \n-Hchan* reflect_makechan(ChanType* t, uint64 size) __asm__ (GOSYM_PREFIX \"reflect.makechan\");\n-Hchan* reflect_makechan(ChanType* t, uint64 size)\n-{\n-  Hchan* c;\n-#line 52 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-\n-\tc = makechan(t, size);\n-return c;\n-}\n-\n-#line 56 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-Hchan* \n-__go_new_channel ( ChanType *t , uintptr hint ) \n-{ \n-return makechan ( t , hint ) ; \n-} \n-#line 62 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-Hchan* \n-__go_new_channel_big ( ChanType *t , uint64 hint ) \n-{ \n-return makechan ( t , hint ) ; \n-} \n-#line 82 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static bool \n-chansend ( ChanType *t , Hchan *c , byte *ep , bool block , void *pc ) \n-{ \n-SudoG *sg; \n-SudoG mysg; \n-G* gp; \n-int64 t0; \n-G* g; \n-#line 91 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-g = runtime_g ( ) ; \n-#line 93 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( raceenabled ) \n-runtime_racereadobjectpc ( ep , t->__element_type , runtime_getcallerpc ( &t ) , chansend ) ; \n-#line 96 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( c == nil ) { \n-USED ( t ) ; \n-if ( !block ) \n-return false; \n-runtime_park ( nil , nil , \"chan send (nil chan)\" ) ; \n-return false; \n-} \n-#line 104 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( runtime_gcwaiting ( ) ) \n-runtime_gosched ( ) ; \n-#line 107 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( debug ) { \n-runtime_printf ( \"chansend: chan=%p\\n\" , c ) ; \n-} \n-#line 111 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-t0 = 0; \n-mysg.releasetime = 0; \n-if ( runtime_blockprofilerate > 0 ) { \n-t0 = runtime_cputicks ( ) ; \n-mysg.releasetime = -1; \n-} \n-#line 118 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-runtime_lock ( c ) ; \n-if ( raceenabled ) \n-runtime_racereadpc ( c , pc , chansend ) ; \n-if ( c->closed ) \n-goto closed; \n-#line 124 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( c->dataqsiz > 0 ) \n-goto asynch; \n-#line 127 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-sg = dequeue ( &c->recvq ) ; \n-if ( sg != nil ) { \n-if ( raceenabled ) \n-racesync ( c , sg ) ; \n-runtime_unlock ( c ) ; \n-#line 133 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-gp = sg->g; \n-gp->param = sg; \n-if ( sg->elem != nil ) \n-runtime_memmove ( sg->elem , ep , c->elemsize ) ; \n-if ( sg->releasetime ) \n-sg->releasetime = runtime_cputicks ( ) ; \n-runtime_ready ( gp ) ; \n-return true; \n-} \n-#line 143 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( !block ) { \n-runtime_unlock ( c ) ; \n-return false; \n-} \n-#line 148 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-mysg.elem = ep; \n-mysg.g = g; \n-mysg.selectdone = nil; \n-g->param = nil; \n-enqueue ( &c->sendq , &mysg ) ; \n-runtime_parkunlock ( c , \"chan send\" ) ; \n-#line 155 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( g->param == nil ) { \n-runtime_lock ( c ) ; \n-if ( !c->closed ) \n-runtime_throw ( \"chansend: spurious wakeup\" ) ; \n-goto closed; \n-} \n-#line 162 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( mysg.releasetime > 0 ) \n-runtime_blockevent ( mysg.releasetime - t0 , 2 ) ; \n-#line 165 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-return true; \n-#line 167 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-asynch: \n-if ( c->closed ) \n-goto closed; \n-#line 171 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( c->qcount >= c->dataqsiz ) { \n-if ( !block ) { \n-runtime_unlock ( c ) ; \n-return false; \n-} \n-mysg.g = g; \n-mysg.elem = nil; \n-mysg.selectdone = nil; \n-enqueue ( &c->sendq , &mysg ) ; \n-runtime_parkunlock ( c , \"chan send\" ) ; \n-#line 182 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-runtime_lock ( c ) ; \n-goto asynch; \n-} \n-#line 186 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( raceenabled ) \n-runtime_racerelease ( chanbuf ( c , c->sendx ) ) ; \n-#line 189 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-runtime_memmove ( chanbuf ( c , c->sendx ) , ep , c->elemsize ) ; \n-if ( ++c->sendx == c->dataqsiz ) \n-c->sendx = 0; \n-c->qcount++; \n-#line 194 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-sg = dequeue ( &c->recvq ) ; \n-if ( sg != nil ) { \n-gp = sg->g; \n-runtime_unlock ( c ) ; \n-if ( sg->releasetime ) \n-sg->releasetime = runtime_cputicks ( ) ; \n-runtime_ready ( gp ) ; \n-} else \n-runtime_unlock ( c ) ; \n-if ( mysg.releasetime > 0 ) \n-runtime_blockevent ( mysg.releasetime - t0 , 2 ) ; \n-return true; \n-#line 207 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-closed: \n-runtime_unlock ( c ) ; \n-runtime_panicstring ( \"send on closed channel\" ) ; \n-return false; \n-} \n-#line 214 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static bool \n-chanrecv ( ChanType *t , Hchan* c , byte *ep , bool block , bool *received ) \n-{ \n-SudoG *sg; \n-SudoG mysg; \n-G *gp; \n-int64 t0; \n-G *g; \n-#line 223 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( runtime_gcwaiting ( ) ) \n-runtime_gosched ( ) ; \n-#line 228 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( debug ) \n-runtime_printf ( \"chanrecv: chan=%p\\n\" , c ) ; \n-#line 231 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-g = runtime_g ( ) ; \n-#line 233 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( c == nil ) { \n-USED ( t ) ; \n-if ( !block ) \n-return false; \n-runtime_park ( nil , nil , \"chan receive (nil chan)\" ) ; \n-return false; \n-} \n-#line 241 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-t0 = 0; \n-mysg.releasetime = 0; \n-if ( runtime_blockprofilerate > 0 ) { \n-t0 = runtime_cputicks ( ) ; \n-mysg.releasetime = -1; \n-} \n-#line 248 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-runtime_lock ( c ) ; \n-if ( c->dataqsiz > 0 ) \n-goto asynch; \n-#line 252 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( c->closed ) \n-goto closed; \n-#line 255 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-sg = dequeue ( &c->sendq ) ; \n-if ( sg != nil ) { \n-if ( raceenabled ) \n-racesync ( c , sg ) ; \n-runtime_unlock ( c ) ; \n-#line 261 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( ep != nil ) \n-runtime_memmove ( ep , sg->elem , c->elemsize ) ; \n-gp = sg->g; \n-gp->param = sg; \n-if ( sg->releasetime ) \n-sg->releasetime = runtime_cputicks ( ) ; \n-runtime_ready ( gp ) ; \n-#line 269 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( received != nil ) \n-*received = true; \n-return true; \n-} \n-#line 274 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( !block ) { \n-runtime_unlock ( c ) ; \n-return false; \n-} \n-#line 279 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-mysg.elem = ep; \n-mysg.g = g; \n-mysg.selectdone = nil; \n-g->param = nil; \n-enqueue ( &c->recvq , &mysg ) ; \n-runtime_parkunlock ( c , \"chan receive\" ) ; \n-#line 286 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( g->param == nil ) { \n-runtime_lock ( c ) ; \n-if ( !c->closed ) \n-runtime_throw ( \"chanrecv: spurious wakeup\" ) ; \n-goto closed; \n-} \n-#line 293 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( received != nil ) \n-*received = true; \n-if ( mysg.releasetime > 0 ) \n-runtime_blockevent ( mysg.releasetime - t0 , 2 ) ; \n-return true; \n-#line 299 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-asynch: \n-if ( c->qcount <= 0 ) { \n-if ( c->closed ) \n-goto closed; \n-#line 304 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( !block ) { \n-runtime_unlock ( c ) ; \n-if ( received != nil ) \n-*received = false; \n-return false; \n-} \n-mysg.g = g; \n-mysg.elem = nil; \n-mysg.selectdone = nil; \n-enqueue ( &c->recvq , &mysg ) ; \n-runtime_parkunlock ( c , \"chan receive\" ) ; \n-#line 316 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-runtime_lock ( c ) ; \n-goto asynch; \n-} \n-#line 320 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( raceenabled ) \n-runtime_raceacquire ( chanbuf ( c , c->recvx ) ) ; \n-#line 323 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( ep != nil ) \n-runtime_memmove ( ep , chanbuf ( c , c->recvx ) , c->elemsize ) ; \n-runtime_memclr ( chanbuf ( c , c->recvx ) , c->elemsize ) ; \n-if ( ++c->recvx == c->dataqsiz ) \n-c->recvx = 0; \n-c->qcount--; \n-#line 330 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-sg = dequeue ( &c->sendq ) ; \n-if ( sg != nil ) { \n-gp = sg->g; \n-runtime_unlock ( c ) ; \n-if ( sg->releasetime ) \n-sg->releasetime = runtime_cputicks ( ) ; \n-runtime_ready ( gp ) ; \n-} else \n-runtime_unlock ( c ) ; \n-#line 340 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( received != nil ) \n-*received = true; \n-if ( mysg.releasetime > 0 ) \n-runtime_blockevent ( mysg.releasetime - t0 , 2 ) ; \n-return true; \n-#line 346 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-closed: \n-if ( ep != nil ) \n-runtime_memclr ( ep , c->elemsize ) ; \n-if ( received != nil ) \n-*received = false; \n-if ( raceenabled ) \n-runtime_raceacquire ( c ) ; \n-runtime_unlock ( c ) ; \n-if ( mysg.releasetime > 0 ) \n-runtime_blockevent ( mysg.releasetime - t0 , 2 ) ; \n-return true; \n-} \n-#line 361 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-void \n-__go_send_small ( ChanType *t , Hchan* c , uint64 val ) \n-{ \n-union \n-{ \n-byte b[sizeof ( uint64 ) ]; \n-uint64 v; \n-} u; \n-byte *v; \n-#line 371 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-u.v = val; \n-#ifndef WORDS_BIGENDIAN \n-v = u.b; \n-#else \n-v = u.b + sizeof ( uint64 ) - t->__element_type->__size; \n-#endif \n-chansend ( t , c , v , true , runtime_getcallerpc ( &t ) ) ; \n-} \n-#line 382 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-void \n-__go_send_big ( ChanType *t , Hchan* c , byte* v ) \n-{ \n-chansend ( t , c , v , true , runtime_getcallerpc ( &t ) ) ; \n-} \n-#line 390 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-void \n-__go_receive ( ChanType *t , Hchan* c , byte* v ) \n-{ \n-chanrecv ( t , c , v , true , nil ) ; \n-} \n-#line 396 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-_Bool runtime_chanrecv2 ( ChanType *t , Hchan* c , byte* v ) \n-__asm__ ( GOSYM_PREFIX \"runtime.chanrecv2\" ) ; \n-#line 399 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-_Bool \n-runtime_chanrecv2 ( ChanType *t , Hchan* c , byte* v ) \n-{ \n-bool received = false; \n-#line 404 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-chanrecv ( t , c , v , true , &received ) ; \n-return received; \n-} \n-bool runtime_selectnbsend(ChanType* t, Hchan* c, byte* elem) __asm__ (GOSYM_PREFIX \"runtime.selectnbsend\");\n-bool runtime_selectnbsend(ChanType* t, Hchan* c, byte* elem)\n-{\n-  bool selected;\n-#line 425 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-\n-\tselected = chansend(t, c, elem, false, runtime_getcallerpc(&t));\n-return selected;\n-}\n-bool runtime_selectnbrecv(ChanType* t, byte* elem, Hchan* c) __asm__ (GOSYM_PREFIX \"runtime.selectnbrecv\");\n-bool runtime_selectnbrecv(ChanType* t, byte* elem, Hchan* c)\n-{\n-  bool selected;\n-#line 446 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-\n-\tselected = chanrecv(t, c, elem, false, nil);\n-return selected;\n-}\n-bool runtime_selectnbrecv2(ChanType* t, byte* elem, bool* received, Hchan* c) __asm__ (GOSYM_PREFIX \"runtime.selectnbrecv2\");\n-bool runtime_selectnbrecv2(ChanType* t, byte* elem, bool* received, Hchan* c)\n-{\n-  bool selected;\n-#line 467 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-\n-\tbool r;\n-\n-\tselected = chanrecv(t, c, elem, false, received == nil ? nil : &r);\n-\tif(received != nil)\n-\t\t*received = r;\n-return selected;\n-}\n-bool reflect_chansend(ChanType* t, Hchan* c, byte* elem, bool nb) __asm__ (GOSYM_PREFIX \"reflect.chansend\");\n-bool reflect_chansend(ChanType* t, Hchan* c, byte* elem, bool nb)\n-{\n-  bool selected;\n-#line 475 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-\n-\tselected = chansend(t, c, elem, !nb, runtime_getcallerpc(&t));\n-return selected;\n-}\n-struct reflect_chanrecv_ret {\n-  bool selected;\n-  bool received;\n-};\n-struct reflect_chanrecv_ret reflect_chanrecv(ChanType* t, Hchan* c, bool nb, byte* elem) __asm__ (GOSYM_PREFIX \"reflect.chanrecv\");\n-struct reflect_chanrecv_ret reflect_chanrecv(ChanType* t, Hchan* c, bool nb, byte* elem)\n-{\n-  bool selected;\n-  bool received;\n-#line 479 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-\n-\treceived = false;\n-\tselected = chanrecv(t, c, elem, !nb, &received);\n-  {\n-    struct reflect_chanrecv_ret __ret;\n-    __ret.selected = selected;\n-    __ret.received = received;\n-    return __ret;\n-  }\n-}\n-\n-#line 484 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static Select* newselect ( int32 ) ; \n-byte* runtime_newselect(int32 size) __asm__ (GOSYM_PREFIX \"runtime.newselect\");\n-byte* runtime_newselect(int32 size)\n-{\n-  byte* sel;\n-#line 486 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-\n- \tsel = (byte*)newselect(size);\n-return sel;\n-}\n-\n-#line 490 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static Select* \n-newselect ( int32 size ) \n-{ \n-int32 n; \n-Select *sel; \n-#line 496 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-n = 0; \n-if ( size > 1 ) \n-n = size-1; \n-#line 504 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-sel = runtime_mal ( sizeof ( *sel ) + \n-n*sizeof ( sel->scase[0] ) + \n-size*sizeof ( sel->lockorder[0] ) + \n-size*sizeof ( sel->pollorder[0] ) ) ; \n-#line 509 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-sel->tcase = size; \n-sel->ncase = 0; \n-sel->lockorder = ( void* ) ( sel->scase + size ) ; \n-sel->pollorder = ( void* ) ( sel->lockorder + size ) ; \n-#line 514 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( debug ) \n-runtime_printf ( \"newselect s=%p size=%d\\n\" , sel , size ) ; \n-return sel; \n-} \n-#line 520 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static void selectsend ( Select *sel , Hchan *c , int index , void *elem ) ; \n-void runtime_selectsend(Select* sel, Hchan* c, byte* elem, int32 index) __asm__ (GOSYM_PREFIX \"runtime.selectsend\");\n-void runtime_selectsend(Select* sel, Hchan* c, byte* elem, int32 index)\n-{\n-#line 522 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-\n-\t// nil cases do not compete\n-\tif(c != nil)\n-\t\tselectsend(sel, c, index, elem);\n-}\n-\n-#line 528 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static void \n-selectsend ( Select *sel , Hchan *c , int index , void *elem ) \n-{ \n-int32 i; \n-Scase *cas; \n-#line 534 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-i = sel->ncase; \n-if ( i >= sel->tcase ) \n-runtime_throw ( \"selectsend: too many cases\" ) ; \n-sel->ncase = i+1; \n-cas = &sel->scase[i]; \n-#line 540 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-cas->index = index; \n-cas->chan = c; \n-cas->kind = CaseSend; \n-cas->sg.elem = elem; \n-#line 545 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( debug ) \n-runtime_printf ( \"selectsend s=%p index=%d chan=%p\\n\" , \n-sel , cas->index , cas->chan ) ; \n-} \n-#line 551 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static void selectrecv ( Select *sel , Hchan *c , int index , void *elem , bool* ) ; \n-void runtime_selectrecv(Select* sel, Hchan* c, byte* elem, int32 index) __asm__ (GOSYM_PREFIX \"runtime.selectrecv\");\n-void runtime_selectrecv(Select* sel, Hchan* c, byte* elem, int32 index)\n-{\n-#line 553 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-\n-\t// nil cases do not compete\n-\tif(c != nil)\n-\t\tselectrecv(sel, c, index, elem, nil);\n-}\n-void runtime_selectrecv2(Select* sel, Hchan* c, byte* elem, bool* received, int32 index) __asm__ (GOSYM_PREFIX \"runtime.selectrecv2\");\n-void runtime_selectrecv2(Select* sel, Hchan* c, byte* elem, bool* received, int32 index)\n-{\n-#line 559 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-\n-\t// nil cases do not compete\n-\tif(c != nil)\n-\t\tselectrecv(sel, c, index, elem, received);\n-}\n-\n-#line 565 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static void \n-selectrecv ( Select *sel , Hchan *c , int index , void *elem , bool *received ) \n-{ \n-int32 i; \n-Scase *cas; \n-#line 571 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-i = sel->ncase; \n-if ( i >= sel->tcase ) \n-runtime_throw ( \"selectrecv: too many cases\" ) ; \n-sel->ncase = i+1; \n-cas = &sel->scase[i]; \n-cas->index = index; \n-cas->chan = c; \n-#line 579 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-cas->kind = CaseRecv; \n-cas->sg.elem = elem; \n-cas->receivedp = received; \n-#line 583 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( debug ) \n-runtime_printf ( \"selectrecv s=%p index=%d chan=%p\\n\" , \n-sel , cas->index , cas->chan ) ; \n-} \n-#line 589 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static void selectdefault ( Select* , int ) ; \n-void runtime_selectdefault(Select* sel, int32 index) __asm__ (GOSYM_PREFIX \"runtime.selectdefault\");\n-void runtime_selectdefault(Select* sel, int32 index)\n-{\n-#line 591 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-\n-\tselectdefault(sel, index);\n-}\n-\n-#line 595 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static void \n-selectdefault ( Select *sel , int32 index ) \n-{ \n-int32 i; \n-Scase *cas; \n-#line 601 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-i = sel->ncase; \n-if ( i >= sel->tcase ) \n-runtime_throw ( \"selectdefault: too many cases\" ) ; \n-sel->ncase = i+1; \n-cas = &sel->scase[i]; \n-cas->index = index; \n-cas->chan = nil; \n-#line 609 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-cas->kind = CaseDefault; \n-#line 611 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( debug ) \n-runtime_printf ( \"selectdefault s=%p index=%d\\n\" , \n-sel , cas->index ) ; \n-} \n-#line 616 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static void \n-sellock ( Select *sel ) \n-{ \n-uint32 i; \n-Hchan *c , *c0; \n-#line 622 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-c = nil; \n-for ( i=0; i<sel->ncase; i++ ) { \n-c0 = sel->lockorder[i]; \n-if ( c0 && c0 != c ) { \n-c = sel->lockorder[i]; \n-runtime_lock ( c ) ; \n-} \n-} \n-} \n-#line 632 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static void \n-selunlock ( Select *sel ) \n-{ \n-int32 i , n , r; \n-Hchan *c; \n-#line 646 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-n = ( int32 ) sel->ncase; \n-r = 0; \n-#line 649 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( n>0 && sel->lockorder[0] == nil ) \n-r = 1; \n-for ( i = n-1; i >= r; i-- ) { \n-c = sel->lockorder[i]; \n-if ( i>0 && sel->lockorder[i-1] == c ) \n-continue; \n-runtime_unlock ( c ) ; \n-} \n-} \n-#line 659 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static bool \n-selparkcommit ( G *gp , void *sel ) \n-{ \n-USED ( gp ) ; \n-selunlock ( sel ) ; \n-return true; \n-} \n-void runtime_block() __asm__ (GOSYM_PREFIX \"runtime.block\");\n-void runtime_block()\n-{\n-#line 667 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-\n-\truntime_park(nil, nil, \"select (no cases)\");\t// forever\n-}\n-\n-#line 671 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static int selectgo ( Select** ) ; \n-int32 runtime_selectgo(Select* sel) __asm__ (GOSYM_PREFIX \"runtime.selectgo\");\n-int32 runtime_selectgo(Select* sel)\n-{\n-  int32 ret;\n-#line 675 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-\n-\treturn selectgo(&sel);\n-return ret;\n-}\n-\n-#line 679 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static int \n-selectgo ( Select **selp ) \n-{ \n-Select *sel; \n-uint32 o , i , j , k , done; \n-int64 t0; \n-Scase *cas , *dfl; \n-Hchan *c; \n-SudoG *sg; \n-G *gp; \n-int index; \n-G *g; \n-#line 692 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-sel = *selp; \n-if ( runtime_gcwaiting ( ) ) \n-runtime_gosched ( ) ; \n-#line 696 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( debug ) \n-runtime_printf ( \"select: sel=%p\\n\" , sel ) ; \n-#line 699 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-g = runtime_g ( ) ; \n-#line 701 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-t0 = 0; \n-if ( runtime_blockprofilerate > 0 ) { \n-t0 = runtime_cputicks ( ) ; \n-for ( i=0; i<sel->ncase; i++ ) \n-sel->scase[i].sg.releasetime = -1; \n-} \n-#line 717 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-for ( i=0; i<sel->ncase; i++ ) \n-sel->pollorder[i] = i; \n-for ( i=1; i<sel->ncase; i++ ) { \n-o = sel->pollorder[i]; \n-j = runtime_fastrand1 ( ) % ( i+1 ) ; \n-sel->pollorder[i] = sel->pollorder[j]; \n-sel->pollorder[j] = o; \n-} \n-#line 728 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-for ( i=0; i<sel->ncase; i++ ) { \n-j = i; \n-c = sel->scase[j].chan; \n-while ( j > 0 && sel->lockorder[k= ( j-1 ) /2] < c ) { \n-sel->lockorder[j] = sel->lockorder[k]; \n-j = k; \n-} \n-sel->lockorder[j] = c; \n-} \n-for ( i=sel->ncase; i-->0; ) { \n-c = sel->lockorder[i]; \n-sel->lockorder[i] = sel->lockorder[0]; \n-j = 0; \n-for ( ;; ) { \n-k = j*2+1; \n-if ( k >= i ) \n-break; \n-if ( k+1 < i && sel->lockorder[k] < sel->lockorder[k+1] ) \n-k++; \n-if ( c < sel->lockorder[k] ) { \n-sel->lockorder[j] = sel->lockorder[k]; \n-j = k; \n-continue; \n-} \n-break; \n-} \n-sel->lockorder[j] = c; \n-} \n-#line 763 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-sellock ( sel ) ; \n-#line 765 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-loop: \n-#line 767 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-dfl = nil; \n-for ( i=0; i<sel->ncase; i++ ) { \n-o = sel->pollorder[i]; \n-cas = &sel->scase[o]; \n-c = cas->chan; \n-#line 773 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-switch ( cas->kind ) { \n-case CaseRecv: \n-if ( c->dataqsiz > 0 ) { \n-if ( c->qcount > 0 ) \n-goto asyncrecv; \n-} else { \n-sg = dequeue ( &c->sendq ) ; \n-if ( sg != nil ) \n-goto syncrecv; \n-} \n-if ( c->closed ) \n-goto rclose; \n-break; \n-#line 787 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-case CaseSend: \n-if ( raceenabled ) \n-runtime_racereadpc ( c , runtime_selectgo , chansend ) ; \n-if ( c->closed ) \n-goto sclose; \n-if ( c->dataqsiz > 0 ) { \n-if ( c->qcount < c->dataqsiz ) \n-goto asyncsend; \n-} else { \n-sg = dequeue ( &c->recvq ) ; \n-if ( sg != nil ) \n-goto syncsend; \n-} \n-break; \n-#line 802 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-case CaseDefault: \n-dfl = cas; \n-break; \n-} \n-} \n-#line 808 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( dfl != nil ) { \n-selunlock ( sel ) ; \n-cas = dfl; \n-goto retc; \n-} \n-#line 816 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-done = 0; \n-for ( i=0; i<sel->ncase; i++ ) { \n-o = sel->pollorder[i]; \n-cas = &sel->scase[o]; \n-c = cas->chan; \n-sg = &cas->sg; \n-sg->g = g; \n-sg->selectdone = &done; \n-#line 825 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-switch ( cas->kind ) { \n-case CaseRecv: \n-enqueue ( &c->recvq , sg ) ; \n-break; \n-#line 830 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-case CaseSend: \n-enqueue ( &c->sendq , sg ) ; \n-break; \n-} \n-} \n-#line 836 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-g->param = nil; \n-runtime_park ( selparkcommit , sel , \"select\" ) ; \n-#line 839 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-sellock ( sel ) ; \n-sg = g->param; \n-#line 844 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-for ( i=0; i<sel->ncase; i++ ) { \n-cas = &sel->scase[i]; \n-if ( cas != ( Scase* ) sg ) { \n-c = cas->chan; \n-if ( cas->kind == CaseSend ) \n-dequeueg ( &c->sendq ) ; \n-else \n-dequeueg ( &c->recvq ) ; \n-} \n-} \n-#line 855 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( sg == nil ) \n-goto loop; \n-#line 858 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-cas = ( Scase* ) sg; \n-c = cas->chan; \n-#line 861 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( c->dataqsiz > 0 ) \n-runtime_throw ( \"selectgo: shouldn't happen\" ) ; \n-#line 864 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( debug ) \n-runtime_printf ( \"wait-return: sel=%p c=%p cas=%p kind=%d\\n\" , \n-sel , c , cas , cas->kind ) ; \n-#line 868 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( cas->kind == CaseRecv ) { \n-if ( cas->receivedp != nil ) \n-*cas->receivedp = true; \n-} \n-#line 873 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( raceenabled ) { \n-if ( cas->kind == CaseRecv && cas->sg.elem != nil ) \n-runtime_racewriteobjectpc ( cas->sg.elem , c->elemtype , selectgo , chanrecv ) ; \n-else if ( cas->kind == CaseSend ) \n-runtime_racereadobjectpc ( cas->sg.elem , c->elemtype , selectgo , chansend ) ; \n-} \n-#line 880 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-selunlock ( sel ) ; \n-goto retc; \n-#line 883 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-asyncrecv: \n-#line 885 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( raceenabled ) { \n-if ( cas->sg.elem != nil ) \n-runtime_racewriteobjectpc ( cas->sg.elem , c->elemtype , selectgo , chanrecv ) ; \n-runtime_raceacquire ( chanbuf ( c , c->recvx ) ) ; \n-} \n-if ( cas->receivedp != nil ) \n-*cas->receivedp = true; \n-if ( cas->sg.elem != nil ) \n-runtime_memmove ( cas->sg.elem , chanbuf ( c , c->recvx ) , c->elemsize ) ; \n-runtime_memclr ( chanbuf ( c , c->recvx ) , c->elemsize ) ; \n-if ( ++c->recvx == c->dataqsiz ) \n-c->recvx = 0; \n-c->qcount--; \n-sg = dequeue ( &c->sendq ) ; \n-if ( sg != nil ) { \n-gp = sg->g; \n-selunlock ( sel ) ; \n-if ( sg->releasetime ) \n-sg->releasetime = runtime_cputicks ( ) ; \n-runtime_ready ( gp ) ; \n-} else { \n-selunlock ( sel ) ; \n-} \n-goto retc; \n-#line 910 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-asyncsend: \n-#line 912 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( raceenabled ) { \n-runtime_racerelease ( chanbuf ( c , c->sendx ) ) ; \n-runtime_racereadobjectpc ( cas->sg.elem , c->elemtype , selectgo , chansend ) ; \n-} \n-runtime_memmove ( chanbuf ( c , c->sendx ) , cas->sg.elem , c->elemsize ) ; \n-if ( ++c->sendx == c->dataqsiz ) \n-c->sendx = 0; \n-c->qcount++; \n-sg = dequeue ( &c->recvq ) ; \n-if ( sg != nil ) { \n-gp = sg->g; \n-selunlock ( sel ) ; \n-if ( sg->releasetime ) \n-sg->releasetime = runtime_cputicks ( ) ; \n-runtime_ready ( gp ) ; \n-} else { \n-selunlock ( sel ) ; \n-} \n-goto retc; \n-#line 932 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-syncrecv: \n-#line 934 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( raceenabled ) { \n-if ( cas->sg.elem != nil ) \n-runtime_racewriteobjectpc ( cas->sg.elem , c->elemtype , selectgo , chanrecv ) ; \n-racesync ( c , sg ) ; \n-} \n-selunlock ( sel ) ; \n-if ( debug ) \n-runtime_printf ( \"syncrecv: sel=%p c=%p o=%d\\n\" , sel , c , o ) ; \n-if ( cas->receivedp != nil ) \n-*cas->receivedp = true; \n-if ( cas->sg.elem != nil ) \n-runtime_memmove ( cas->sg.elem , sg->elem , c->elemsize ) ; \n-gp = sg->g; \n-gp->param = sg; \n-if ( sg->releasetime ) \n-sg->releasetime = runtime_cputicks ( ) ; \n-runtime_ready ( gp ) ; \n-goto retc; \n-#line 953 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-rclose: \n-#line 955 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-selunlock ( sel ) ; \n-if ( cas->receivedp != nil ) \n-*cas->receivedp = false; \n-if ( cas->sg.elem != nil ) \n-runtime_memclr ( cas->sg.elem , c->elemsize ) ; \n-if ( raceenabled ) \n-runtime_raceacquire ( c ) ; \n-goto retc; \n-#line 964 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-syncsend: \n-#line 966 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( raceenabled ) { \n-runtime_racereadobjectpc ( cas->sg.elem , c->elemtype , selectgo , chansend ) ; \n-racesync ( c , sg ) ; \n-} \n-selunlock ( sel ) ; \n-if ( debug ) \n-runtime_printf ( \"syncsend: sel=%p c=%p o=%d\\n\" , sel , c , o ) ; \n-if ( sg->elem != nil ) \n-runtime_memmove ( sg->elem , cas->sg.elem , c->elemsize ) ; \n-gp = sg->g; \n-gp->param = sg; \n-if ( sg->releasetime ) \n-sg->releasetime = runtime_cputicks ( ) ; \n-runtime_ready ( gp ) ; \n-#line 981 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-retc: \n-#line 983 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-index = cas->index; \n-if ( cas->sg.releasetime > 0 ) \n-runtime_blockevent ( cas->sg.releasetime - t0 , 2 ) ; \n-runtime_free ( sel ) ; \n-return index; \n-#line 989 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-sclose: \n-#line 991 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-selunlock ( sel ) ; \n-runtime_panicstring ( \"send on closed channel\" ) ; \n-return 0; \n-} \n-#line 997 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-typedef struct runtimeSelect runtimeSelect; \n-struct runtimeSelect \n-{ \n-uintptr dir; \n-ChanType *typ; \n-Hchan *ch; \n-byte *val; \n-} ; \n-#line 1007 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-enum SelectDir { \n-SelectSend = 1 , \n-SelectRecv , \n-SelectDefault , \n-} ; \n-struct reflect_rselect_ret {\n-  intgo chosen;\n-  bool recvOK;\n-};\n-struct reflect_rselect_ret reflect_rselect(Slice cases) __asm__ (GOSYM_PREFIX \"reflect.rselect\");\n-struct reflect_rselect_ret reflect_rselect(Slice cases)\n-{\n-  intgo chosen;\n-  bool recvOK;\n-#line 1013 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-\n-\tint32 i;\n-\tSelect *sel;\n-\truntimeSelect* rcase, *rc;\n-\n-\tchosen = -1;\n-\trecvOK = false;\n-\n-\trcase = (runtimeSelect*)cases.__values;\n-\n-\tsel = newselect(cases.__count);\n-\tfor(i=0; i<cases.__count; i++) {\n-\t\trc = &rcase[i];\n-\t\tswitch(rc->dir) {\n-\t\tcase SelectDefault:\n-\t\t\tselectdefault(sel, i);\n-\t\t\tbreak;\n-\t\tcase SelectSend:\n-\t\t\tif(rc->ch == nil)\n-\t\t\t\tbreak;\n-\t\t\tselectsend(sel, rc->ch, i, rc->val);\n-\t\t\tbreak;\n-\t\tcase SelectRecv:\n-\t\t\tif(rc->ch == nil)\n-\t\t\t\tbreak;\n-\t\t\tselectrecv(sel, rc->ch, i, rc->val, &recvOK);\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-\n-\tchosen = (intgo)(uintptr)selectgo(&sel);\n-  {\n-    struct reflect_rselect_ret __ret;\n-    __ret.chosen = chosen;\n-    __ret.recvOK = recvOK;\n-    return __ret;\n-  }\n-}\n-\n-#line 1046 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static void closechan ( Hchan *c , void *pc ) ; \n-void runtime_closechan(Hchan* c) __asm__ (GOSYM_PREFIX \"runtime.closechan\");\n-void runtime_closechan(Hchan* c)\n-{\n-#line 1048 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-\n-\tclosechan(c, runtime_getcallerpc(&c));\n-}\n-void reflect_chanclose(Hchan* c) __asm__ (GOSYM_PREFIX \"reflect.chanclose\");\n-void reflect_chanclose(Hchan* c)\n-{\n-#line 1052 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-\n-\tclosechan(c, runtime_getcallerpc(&c));\n-}\n-\n-#line 1056 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static void \n-closechan ( Hchan *c , void *pc ) \n-{ \n-SudoG *sg; \n-G* gp; \n-#line 1062 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( c == nil ) \n-runtime_panicstring ( \"close of nil channel\" ) ; \n-#line 1065 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( runtime_gcwaiting ( ) ) \n-runtime_gosched ( ) ; \n-#line 1068 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-runtime_lock ( c ) ; \n-if ( c->closed ) { \n-runtime_unlock ( c ) ; \n-runtime_panicstring ( \"close of closed channel\" ) ; \n-} \n-#line 1074 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( raceenabled ) { \n-runtime_racewritepc ( c , pc , runtime_closechan ) ; \n-runtime_racerelease ( c ) ; \n-} \n-#line 1079 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-c->closed = true; \n-#line 1082 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-for ( ;; ) { \n-sg = dequeue ( &c->recvq ) ; \n-if ( sg == nil ) \n-break; \n-gp = sg->g; \n-gp->param = nil; \n-if ( sg->releasetime ) \n-sg->releasetime = runtime_cputicks ( ) ; \n-runtime_ready ( gp ) ; \n-} \n-#line 1094 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-for ( ;; ) { \n-sg = dequeue ( &c->sendq ) ; \n-if ( sg == nil ) \n-break; \n-gp = sg->g; \n-gp->param = nil; \n-if ( sg->releasetime ) \n-sg->releasetime = runtime_cputicks ( ) ; \n-runtime_ready ( gp ) ; \n-} \n-#line 1105 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-runtime_unlock ( c ) ; \n-} \n-#line 1108 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-void \n-__go_builtin_close ( Hchan *c ) \n-{ \n-runtime_closechan ( c ) ; \n-} \n-intgo reflect_chanlen(Hchan* c) __asm__ (GOSYM_PREFIX \"reflect.chanlen\");\n-intgo reflect_chanlen(Hchan* c)\n-{\n-  intgo len;\n-#line 1114 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-\n-\tif(c == nil)\n-\t\tlen = 0;\n-\telse\n-\t\tlen = c->qcount;\n-return len;\n-}\n-\n-#line 1121 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-intgo \n-__go_chan_len ( Hchan *c ) \n-{ \n-return reflect_chanlen ( c ) ; \n-} \n-intgo reflect_chancap(Hchan* c) __asm__ (GOSYM_PREFIX \"reflect.chancap\");\n-intgo reflect_chancap(Hchan* c)\n-{\n-  intgo cap;\n-#line 1127 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-\n-\tif(c == nil)\n-\t\tcap = 0;\n-\telse\n-\t\tcap = c->dataqsiz;\n-return cap;\n-}\n-\n-#line 1134 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-intgo \n-__go_chan_cap ( Hchan *c ) \n-{ \n-return reflect_chancap ( c ) ; \n-} \n-#line 1140 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static SudoG* \n-dequeue ( WaitQ *q ) \n-{ \n-SudoG *sgp; \n-#line 1145 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-loop: \n-sgp = q->first; \n-if ( sgp == nil ) \n-return nil; \n-q->first = sgp->link; \n-#line 1152 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( sgp->selectdone != nil ) { \n-#line 1154 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-if ( *sgp->selectdone != 0 || !runtime_cas ( sgp->selectdone , 0 , 1 ) ) \n-goto loop; \n-} \n-#line 1158 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-return sgp; \n-} \n-#line 1161 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static void \n-dequeueg ( WaitQ *q ) \n-{ \n-SudoG **l , *sgp , *prevsgp; \n-G *g; \n-#line 1167 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-g = runtime_g ( ) ; \n-prevsgp = nil; \n-for ( l=&q->first; ( sgp=*l ) != nil; l=&sgp->link , prevsgp=sgp ) { \n-if ( sgp->g == g ) { \n-*l = sgp->link; \n-if ( q->last == sgp ) \n-q->last = prevsgp; \n-break; \n-} \n-} \n-} \n-#line 1179 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static void \n-enqueue ( WaitQ *q , SudoG *sgp ) \n-{ \n-sgp->link = nil; \n-if ( q->first == nil ) { \n-q->first = sgp; \n-q->last = sgp; \n-return; \n-} \n-q->last->link = sgp; \n-q->last = sgp; \n-} \n-#line 1192 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/chan.goc\"\n-static void \n-racesync ( Hchan *c , SudoG *sg ) \n-{ \n-runtime_racerelease ( chanbuf ( c , 0 ) ) ; \n-runtime_raceacquireg ( sg->g , chanbuf ( c , 0 ) ) ; \n-runtime_racereleaseg ( sg->g , chanbuf ( c , 0 ) ) ; \n-runtime_raceacquire ( chanbuf ( c , 0 ) ) ; \n-} \n\\ No newline at end of file"}, {"sha": "3398a92ea82583907fa986f3603e94e1b7daa9d1", "filename": "libgo/runtime/cpuprof.c", "status": "removed", "additions": 0, "deletions": 350, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d723bc36dd7857b3e01440be634fcb7ce6cd60ea/libgo%2Fruntime%2Fcpuprof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d723bc36dd7857b3e01440be634fcb7ce6cd60ea/libgo%2Fruntime%2Fcpuprof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fcpuprof.c?ref=d723bc36dd7857b3e01440be634fcb7ce6cd60ea", "patch": "@@ -1,350 +0,0 @@\n-// AUTO-GENERATED by autogen.sh; DO NOT EDIT\n-\n-#include \"runtime.h\"\n-#include \"arch.h\"\n-#include \"malloc.h\"\n-#include \"array.h\"\n-\n-#line 57 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-typedef struct __go_open_array Slice; \n-#define array __values \n-#define len __count \n-#define cap __capacity \n-#line 62 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-enum \n-{ \n-HashSize = 1<<10 , \n-LogSize = 1<<17 , \n-Assoc = 4 , \n-MaxStack = 64 , \n-} ; \n-#line 70 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-typedef struct Profile Profile; \n-typedef struct Bucket Bucket; \n-typedef struct Entry Entry; \n-#line 74 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-struct Entry { \n-uintptr count; \n-uintptr depth; \n-uintptr stack[MaxStack]; \n-} ; \n-#line 80 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-struct Bucket { \n-Entry entry[Assoc]; \n-} ; \n-#line 84 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-struct Profile { \n-bool on; \n-Note wait; \n-uintptr count; \n-uintptr evicts; \n-uintptr lost; \n-uintptr totallost; \n-#line 93 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-Bucket hash[HashSize]; \n-#line 98 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-uintptr log[2][LogSize/2]; \n-uintptr nlog; \n-int32 toggle; \n-uint32 handoff; \n-#line 106 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-uint32 wtoggle; \n-bool wholding; \n-bool flushing; \n-bool eod_sent; \n-} ; \n-#line 112 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-static Lock lk; \n-static Profile *prof; \n-#line 115 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-static void tick ( uintptr* , int32 ) ; \n-static void add ( Profile* , uintptr* , int32 ) ; \n-static bool evict ( Profile* , Entry* ) ; \n-static bool flushlog ( Profile* ) ; \n-#line 120 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-static uintptr eod[3] = { 0 , 1 , 0 } ; \n-#line 125 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-static void \n-LostProfileData ( void ) \n-{ \n-} \n-#line 130 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-extern void runtime_SetCPUProfileRate ( intgo ) \n-__asm__ ( GOSYM_PREFIX \"runtime.SetCPUProfileRate\" ) ; \n-#line 135 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-void \n-runtime_SetCPUProfileRate ( intgo hz ) \n-{ \n-uintptr *p; \n-uintptr n; \n-#line 142 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-if ( hz < 0 ) \n-hz = 0; \n-if ( hz > 1000000 ) \n-hz = 1000000; \n-#line 147 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-runtime_lock ( &lk ) ; \n-if ( hz > 0 ) { \n-if ( prof == nil ) { \n-prof = runtime_SysAlloc ( sizeof *prof , &mstats.other_sys ) ; \n-if ( prof == nil ) { \n-runtime_printf ( \"runtime: cpu profiling cannot allocate memory\\n\" ) ; \n-runtime_unlock ( &lk ) ; \n-return; \n-} \n-} \n-if ( prof->on || prof->handoff != 0 ) { \n-runtime_printf ( \"runtime: cannot set cpu profile rate until previous profile has finished.\\n\" ) ; \n-runtime_unlock ( &lk ) ; \n-return; \n-} \n-#line 163 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-prof->on = true; \n-p = prof->log[0]; \n-#line 167 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-*p++ = 0; \n-*p++ = 3; \n-*p++ = 0; \n-*p++ = 1000000 / hz; \n-*p++ = 0; \n-prof->nlog = p - prof->log[0]; \n-prof->toggle = 0; \n-prof->wholding = false; \n-prof->wtoggle = 0; \n-prof->flushing = false; \n-prof->eod_sent = false; \n-runtime_noteclear ( &prof->wait ) ; \n-#line 180 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-runtime_setcpuprofilerate ( tick , hz ) ; \n-} else if ( prof != nil && prof->on ) { \n-runtime_setcpuprofilerate ( nil , 0 ) ; \n-prof->on = false; \n-#line 187 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-for ( ;; ) { \n-n = prof->handoff; \n-if ( n&0x80000000 ) \n-runtime_printf ( \"runtime: setcpuprofile(off) twice\" ) ; \n-if ( runtime_cas ( &prof->handoff , n , n|0x80000000 ) ) \n-break; \n-} \n-if ( n == 0 ) { \n-#line 196 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-runtime_notewakeup ( &prof->wait ) ; \n-} \n-} \n-runtime_unlock ( &lk ) ; \n-} \n-#line 202 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-static void \n-tick ( uintptr *pc , int32 n ) \n-{ \n-add ( prof , pc , n ) ; \n-} \n-#line 213 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-static void \n-add ( Profile *p , uintptr *pc , int32 n ) \n-{ \n-int32 i , j; \n-uintptr h , x; \n-Bucket *b; \n-Entry *e; \n-#line 221 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-if ( n > MaxStack ) \n-n = MaxStack; \n-#line 225 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-h = 0; \n-for ( i=0; i<n; i++ ) { \n-h = h<<8 | ( h>> ( 8* ( sizeof ( h ) -1 ) ) ) ; \n-x = pc[i]; \n-h += x*31 + x*7 + x*3; \n-} \n-p->count++; \n-#line 234 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-b = &p->hash[h%HashSize]; \n-for ( i=0; i<Assoc; i++ ) { \n-e = &b->entry[i]; \n-if ( e->depth != ( uintptr ) n ) \n-continue; \n-for ( j=0; j<n; j++ ) \n-if ( e->stack[j] != pc[j] ) \n-goto ContinueAssoc; \n-e->count++; \n-return; \n-ContinueAssoc:; \n-} \n-#line 248 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-e = &b->entry[0]; \n-for ( i=1; i<Assoc; i++ ) \n-if ( b->entry[i].count < e->count ) \n-e = &b->entry[i]; \n-if ( e->count > 0 ) { \n-if ( !evict ( p , e ) ) { \n-#line 255 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-p->lost++; \n-p->totallost++; \n-return; \n-} \n-p->evicts++; \n-} \n-#line 263 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-e->depth = n; \n-e->count = 1; \n-for ( i=0; i<n; i++ ) \n-e->stack[i] = pc[i]; \n-} \n-#line 275 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-static bool \n-evict ( Profile *p , Entry *e ) \n-{ \n-int32 i , d , nslot; \n-uintptr *log , *q; \n-#line 281 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-d = e->depth; \n-nslot = d+2; \n-log = p->log[p->toggle]; \n-if ( p->nlog+nslot > nelem ( p->log[0] ) ) { \n-if ( !flushlog ( p ) ) \n-return false; \n-log = p->log[p->toggle]; \n-} \n-#line 290 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-q = log+p->nlog; \n-*q++ = e->count; \n-*q++ = d; \n-for ( i=0; i<d; i++ ) \n-*q++ = e->stack[i]; \n-p->nlog = q - log; \n-e->count = 0; \n-return true; \n-} \n-#line 304 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-static bool \n-flushlog ( Profile *p ) \n-{ \n-uintptr *log , *q; \n-#line 309 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-if ( !runtime_cas ( &p->handoff , 0 , p->nlog ) ) \n-return false; \n-runtime_notewakeup ( &p->wait ) ; \n-#line 313 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-p->toggle = 1 - p->toggle; \n-log = p->log[p->toggle]; \n-q = log; \n-if ( p->lost > 0 ) { \n-*q++ = p->lost; \n-*q++ = 1; \n-*q++ = ( uintptr ) LostProfileData; \n-} \n-p->nlog = q - log; \n-return true; \n-} \n-#line 327 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-Slice \n-getprofile ( Profile *p ) \n-{ \n-uint32 i , j , n; \n-Slice ret; \n-Bucket *b; \n-Entry *e; \n-#line 335 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-ret.array = nil; \n-ret.len = 0; \n-ret.cap = 0; \n-#line 339 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-if ( p == nil ) \n-return ret; \n-#line 342 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-if ( p->wholding ) { \n-#line 345 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-for ( ;; ) { \n-n = p->handoff; \n-if ( n == 0 ) { \n-runtime_printf ( \"runtime: phase error during cpu profile handoff\\n\" ) ; \n-return ret; \n-} \n-if ( n & 0x80000000 ) { \n-p->wtoggle = 1 - p->wtoggle; \n-p->wholding = false; \n-p->flushing = true; \n-goto flush; \n-} \n-if ( runtime_cas ( &p->handoff , n , 0 ) ) \n-break; \n-} \n-p->wtoggle = 1 - p->wtoggle; \n-p->wholding = false; \n-} \n-#line 364 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-if ( p->flushing ) \n-goto flush; \n-#line 367 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-if ( !p->on && p->handoff == 0 ) \n-return ret; \n-#line 371 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-runtime_notetsleepg ( &p->wait , -1 ) ; \n-runtime_noteclear ( &p->wait ) ; \n-#line 374 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-n = p->handoff; \n-if ( n == 0 ) { \n-runtime_printf ( \"runtime: phase error during cpu profile wait\\n\" ) ; \n-return ret; \n-} \n-if ( n == 0x80000000 ) { \n-p->flushing = true; \n-goto flush; \n-} \n-n &= ~0x80000000; \n-#line 386 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-p->wholding = true; \n-#line 388 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-ret.array = ( byte* ) p->log[p->wtoggle]; \n-ret.len = n*sizeof ( uintptr ) ; \n-ret.cap = ret.len; \n-return ret; \n-#line 393 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-flush: \n-#line 398 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-for ( i=0; i<HashSize; i++ ) { \n-b = &p->hash[i]; \n-for ( j=0; j<Assoc; j++ ) { \n-e = &b->entry[j]; \n-if ( e->count > 0 && !evict ( p , e ) ) { \n-#line 404 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-goto breakflush; \n-} \n-} \n-} \n-breakflush: \n-#line 411 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-if ( p->nlog > 0 ) { \n-#line 414 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-ret.array = ( byte* ) p->log[p->toggle]; \n-ret.len = p->nlog*sizeof ( uintptr ) ; \n-ret.cap = ret.len; \n-p->nlog = 0; \n-return ret; \n-} \n-#line 422 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-if ( !p->eod_sent ) { \n-#line 425 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-p->eod_sent = true; \n-ret.array = ( byte* ) eod; \n-ret.len = sizeof eod; \n-ret.cap = ret.len; \n-return ret; \n-} \n-#line 433 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-p->flushing = false; \n-if ( !runtime_cas ( &p->handoff , p->handoff , 0 ) ) \n-runtime_printf ( \"runtime: profile flush racing with something\\n\" ) ; \n-return ret; \n-} \n-Slice runtime_CPUProfile() __asm__ (GOSYM_PREFIX \"runtime.CPUProfile\");\n-Slice runtime_CPUProfile()\n-{\n-  Slice ret;\n-#line 441 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/cpuprof.goc\"\n-\n-\tret = getprofile(prof);\n-return ret;\n-}"}, {"sha": "cefe7b8fb388ac95309b5211da099e6c48347a4b", "filename": "libgo/runtime/lfstack.c", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d723bc36dd7857b3e01440be634fcb7ce6cd60ea/libgo%2Fruntime%2Flfstack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d723bc36dd7857b3e01440be634fcb7ce6cd60ea/libgo%2Fruntime%2Flfstack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Flfstack.c?ref=d723bc36dd7857b3e01440be634fcb7ce6cd60ea", "patch": "@@ -1,76 +0,0 @@\n-// AUTO-GENERATED by autogen.sh; DO NOT EDIT\n-\n-#include \"runtime.h\"\n-#include \"arch.h\"\n-#if __SIZEOF_POINTER__ == 8\n-# define PTR_BITS 47\n-#else\n-# define PTR_BITS 32\n-#endif\n-#define PTR_MASK ((1ull<<PTR_BITS)-1)\n-#define CNT_MASK (0ull-1)\n-#if __SIZEOF_POINTER__ == 8 && (defined(__sparc__) || (defined(__sun__) && defined(__amd64__)))\n-#undef PTR_BITS\n-#undef CNT_MASK\n-#undef PTR_MASK\n-#define PTR_BITS 0\n-#define CNT_MASK 7\n-#define PTR_MASK ((0ull-1)<<3)\n-#endif\n-\n-#line 33 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/lfstack.goc\"\n-void \n-runtime_lfstackpush ( uint64 *head , LFNode *node ) \n-{ \n-uint64 old , new; \n-#line 38 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/lfstack.goc\"\n-if ( ( uintptr ) node != ( ( uintptr ) node&PTR_MASK ) ) { \n-runtime_printf ( \"p=%p\\n\" , node ) ; \n-runtime_throw ( \"runtime_lfstackpush: invalid pointer\" ) ; \n-} \n-#line 43 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/lfstack.goc\"\n-node->pushcnt++; \n-new = ( uint64 ) ( uintptr ) node| ( ( ( uint64 ) node->pushcnt&CNT_MASK ) <<PTR_BITS ) ; \n-for ( ;; ) { \n-old = runtime_atomicload64 ( head ) ; \n-node->next = ( LFNode* ) ( uintptr ) ( old&PTR_MASK ) ; \n-if ( runtime_cas64 ( head , old , new ) ) \n-break; \n-} \n-} \n-#line 53 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/lfstack.goc\"\n-LFNode* \n-runtime_lfstackpop ( uint64 *head ) \n-{ \n-LFNode *node , *node2; \n-uint64 old , new; \n-#line 59 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/lfstack.goc\"\n-for ( ;; ) { \n-old = runtime_atomicload64 ( head ) ; \n-if ( old == 0 ) \n-return nil; \n-node = ( LFNode* ) ( uintptr ) ( old&PTR_MASK ) ; \n-node2 = runtime_atomicloadp ( &node->next ) ; \n-new = 0; \n-if ( node2 != nil ) \n-new = ( uint64 ) ( uintptr ) node2| ( ( ( uint64 ) node2->pushcnt&CNT_MASK ) <<PTR_BITS ) ; \n-if ( runtime_cas64 ( head , old , new ) ) \n-return node; \n-} \n-} \n-void runtime_lfstackpush_go(uint64* head, LFNode* node) __asm__ (GOSYM_PREFIX \"runtime.lfstackpush_go\");\n-void runtime_lfstackpush_go(uint64* head, LFNode* node)\n-{\n-#line 73 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/lfstack.goc\"\n-\n-\truntime_lfstackpush(head, node);\n-}\n-LFNode* runtime_lfstackpop_go(uint64* head) __asm__ (GOSYM_PREFIX \"runtime.lfstackpop_go\");\n-LFNode* runtime_lfstackpop_go(uint64* head)\n-{\n-  LFNode* node;\n-#line 77 \"../../../trunk/libgo/runtime/../../../trunk/libgo/runtime/lfstack.goc\"\n-\n-\tnode = runtime_lfstackpop(head);\n-return node;\n-}"}]}