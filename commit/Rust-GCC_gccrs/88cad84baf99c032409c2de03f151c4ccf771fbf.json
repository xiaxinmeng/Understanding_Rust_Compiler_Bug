{"sha": "88cad84baf99c032409c2de03f151c4ccf771fbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhjYWQ4NGJhZjk5YzAzMjQwOWMyZGUwM2YxNTFjNGNjZjc3MWZiZg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-09-14T13:12:56Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-09-14T13:12:56Z"}, "message": "haifa-sched.c: Follow spelling conventions.\n\n\t* haifa-sched.c: Follow spelling conventions.\n\t* regclass.c: Likewise.\n\t* regrename.c: Likewise.\n\t* config/fp-bit.c: Likewise.\n\t* config/frv/frv.h: Likewise.\n\t* config/m88k/m88k.c: Likewise.\n\t* config/mcore/mcore.c: Likewise.\n\t* config/rs6000/darwin.h: Likewise.\n\t* config/rs6000/gnu.h: Likewise.\n\t* config/rs6000/linux.h: Likewise.\n\t* config/rs6000/linux64.h: Likewise.\n\t* config/rs6000/rs6000.c: Likewise.\n\t* config/rs6000/rs6000.h: Likewise.\n\t* config/sh/sh.c: Likewise.\n\t* config/sparc/sparc.c: Likewise.\n\t* config/sparc/ultra1_2.md: Likewise.\n\nFrom-SVN: r57143", "tree": {"sha": "b297451e696bdde6a8684f9d292350003082fe4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b297451e696bdde6a8684f9d292350003082fe4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88cad84baf99c032409c2de03f151c4ccf771fbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88cad84baf99c032409c2de03f151c4ccf771fbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88cad84baf99c032409c2de03f151c4ccf771fbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88cad84baf99c032409c2de03f151c4ccf771fbf/comments", "author": null, "committer": null, "parents": [{"sha": "958a4e4eeeb96603ee982ee6273ad2a63d450efd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/958a4e4eeeb96603ee982ee6273ad2a63d450efd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/958a4e4eeeb96603ee982ee6273ad2a63d450efd"}], "stats": {"total": 65, "additions": 42, "deletions": 23}, "files": [{"sha": "cbbacfb53683b66a42d26443263fef306a8bd2eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=88cad84baf99c032409c2de03f151c4ccf771fbf", "patch": "@@ -1,3 +1,22 @@\n+2002-09-14  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* haifa-sched.c: Follow spelling conventions.\n+\t* regclass.c: Likewise.\n+\t* regrename.c: Likewise.\n+\t* config/fp-bit.c: Likewise.\n+\t* config/frv/frv.h: Likewise.\n+\t* config/m88k/m88k.c: Likewise.\n+\t* config/mcore/mcore.c: Likewise.\n+\t* config/rs6000/darwin.h: Likewise.\n+\t* config/rs6000/gnu.h: Likewise.\n+\t* config/rs6000/linux.h: Likewise.\n+\t* config/rs6000/linux64.h: Likewise.\n+\t* config/rs6000/rs6000.c: Likewise.\n+\t* config/rs6000/rs6000.h: Likewise.\n+\t* config/sh/sh.c: Likewise.\n+\t* config/sparc/sparc.c: Likewise.\n+\t* config/sparc/ultra1_2.md: Likewise.\n+\n 2002-09-14  Stephane Carrez  <stcarrez@nerim.fr>\n \n \t* config/m68hc11/m68hc11.md (\"movdi_internal\"): Allow any offsetable"}, {"sha": "6f27f5fa1c59dc144594860124fb6d653755b51f", "filename": "gcc/config/fp-bit.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Ffp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Ffp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffp-bit.c?ref=88cad84baf99c032409c2de03f151c4ccf771fbf", "patch": "@@ -373,7 +373,7 @@ unpack_d (FLO_union_type * src, fp_number_type * dst)\n \t}\n       else\n \t{\n-\t  /* Zero exponent with non zero fraction - it's denormalized,\n+\t  /* Zero exponent with nonzero fraction - it's denormalized,\n \t     so there isn't a leading implicit one - we'll shift it so\n \t     it gets one.  */\n \t  dst->normal_exp = exp - EXPBIAS + 1;\n@@ -400,7 +400,7 @@ unpack_d (FLO_union_type * src, fp_number_type * dst)\n \t}\n       else\n \t{\n-\t  /* Non zero fraction, means nan */\n+\t  /* Nonzero fraction, means nan */\n \t  if (fraction & QUIET_NAN)\n \t    {\n \t      dst->class = CLASS_QNAN;\n@@ -940,7 +940,7 @@ __fpcmp_parts (fp_number_type * a, fp_number_type * b)\n        -------+--------+--------\n        -inf(1)| a>b(1) | a==b(0)\n        -------+--------+--------\n-       So since unordered must be non zero, just line up the columns...\n+       So since unordered must be nonzero, just line up the columns...\n        */\n       return b->sign - a->sign;\n     }"}, {"sha": "576b856e2aa99ebbcd866a0d95cccf18a64752d1", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=88cad84baf99c032409c2de03f151c4ccf771fbf", "patch": "@@ -3542,12 +3542,12 @@ frv_ifcvt_modify_multiple_tests (CE_INFO, BB, &TRUE_EXPR, &FALSE_EXPR)\n #define PACKING_FLAG_USED_P() \\\n (optimize && flag_schedule_insns_after_reload && ISSUE_RATE > 1)\n \n-/* If the following macro is defined and non zero and deterministic\n+/* If the following macro is defined and nonzero and deterministic\n    finite state automata are used for pipeline hazard recognition, the\n    code making resource-constrained software pipelining is on.  */\n #define RCSP_SOFTWARE_PIPELINING 1\n \n-/* If the following macro is defined and non zero and deterministic\n+/* If the following macro is defined and nonzero and deterministic\n    finite state automata are used for pipeline hazard recognition, we\n    will try to exchange insns in queue ready to improve the schedule.\n    The more macro value, the more tries will be made.  */"}, {"sha": "a9692e8cf332c6407c805d589d52d3a3a5d574fd", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=88cad84baf99c032409c2de03f151c4ccf771fbf", "patch": "@@ -246,7 +246,7 @@ output_load_const_dimode (operands)\n    do the move.  Otherwise, return 0 and the caller will emit the move\n    normally.\n \n-   SCRATCH if non zero can be used as a scratch register for the move\n+   SCRATCH if nonzero can be used as a scratch register for the move\n    operation.  It is provided by a SECONDARY_RELOAD_* macro if needed.  */\n \n int\n@@ -315,7 +315,7 @@ emit_move_sequence (operands, mode, scratch)\n /* Return a legitimate reference for ORIG (either an address or a MEM)\n    using the register REG.  If PIC and the address is already\n    position-independent, use ORIG.  Newly generated position-independent\n-   addresses go into a reg.  This is REG if non zero, otherwise we\n+   addresses go into a reg.  This is REG if nonzero, otherwise we\n    allocate register(s) as necessary.  If this is called during reload,\n    and we need a second temp register, then we use SCRATCH, which is\n    provided via the SECONDARY_INPUT_RELOAD_CLASS mechanism.  */"}, {"sha": "be68d6606d952bb8943c662af2ccdd08d80941a5", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=88cad84baf99c032409c2de03f151c4ccf771fbf", "patch": "@@ -1437,7 +1437,7 @@ mcore_output_movedouble (operands, mode)\n \n /* Predicates used by the templates.  */\n \n-/* Non zero if OP can be source of a simple move operation.  */\n+/* Nonzero if OP can be source of a simple move operation.  */\n \n int\n mcore_general_movsrc_operand (op, mode)\n@@ -1451,7 +1451,7 @@ mcore_general_movsrc_operand (op, mode)\n   return general_operand (op, mode);\n }\n \n-/* Non zero if OP can be destination of a simple move operation. */\n+/* Nonzero if OP can be destination of a simple move operation. */\n \n int\n mcore_general_movdst_operand (op, mode)\n@@ -1483,7 +1483,7 @@ mcore_arith_reg_operand (op, mode)\n   return 1;\n }\n \n-/* Non zero if OP should be recognized during reload for an ixh/ixw\n+/* Nonzero if OP should be recognized during reload for an ixh/ixw\n    operand.  See the ixh/ixw patterns.  */\n \n int"}, {"sha": "6bfc07ca981cfbdf8a1ff383042ae4ea5a724973", "filename": "gcc/config/rs6000/darwin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Frs6000%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin.h?ref=88cad84baf99c032409c2de03f151c4ccf771fbf", "patch": "@@ -214,7 +214,7 @@ Boston, MA 02111-1307, USA.  */\n    : MAX ((COMPUTED), (SPECIFIED)))\n \n /* XXX: Darwin supports neither .quad, or .llong, but it also doesn't\n-   support 64 bit powerpc either, so this just keeps things happy.  */\n+   support 64 bit PowerPC either, so this just keeps things happy.  */\n #define DOUBLE_INT_ASM_OP \"\\t.quad\\t\"\n \n /* Get HOST_WIDE_INT and CONST_INT to be 32 bits, for compile time"}, {"sha": "9aeb696db2fe9d32494d30df9bcd0506a699da51", "filename": "gcc/config/rs6000/gnu.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Frs6000%2Fgnu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Frs6000%2Fgnu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fgnu.h?ref=88cad84baf99c032409c2de03f151c4ccf771fbf", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler,\n-   for powerpc machines running GNU.\n+   for PowerPC machines running GNU.\n    Copyright (C) 2001 Free Software Foundation, Inc.\n \n This file is part of GNU CC."}, {"sha": "95a4dd5791b93f5d3caad2e55af2ba3eab6d897a", "filename": "gcc/config/rs6000/linux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Frs6000%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Frs6000%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux.h?ref=88cad84baf99c032409c2de03f151c4ccf771fbf", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler,\n-   for powerpc machines running Linux.\n+   for PowerPC machines running Linux.\n    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, \n    Inc.\n    Contributed by Michael Meissner (meissner@cygnus.com)."}, {"sha": "b617a6d0bd49b82ce94c58ca1a89f2d0721e18e3", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=88cad84baf99c032409c2de03f151c4ccf771fbf", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler,\n-   for 64 bit powerpc linux.\n+   for 64 bit PowerPC linux.\n    Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU CC."}, {"sha": "598e64c8029d08c7160b811d2f2ba7dfdcb940ce", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=88cad84baf99c032409c2de03f151c4ccf771fbf", "patch": "@@ -8006,7 +8006,7 @@ print_operand_address (file, x)\n     abort ();\n }\n \f\n-/* Target hook for assembling integer objects.  The powerpc version has\n+/* Target hook for assembling integer objects.  The PowerPC version has\n    to handle fixup entries for relocatable code if RELOCATABLE_NEEDS_FIXUP\n    is defined.  It also needs to handle DI-mode objects on 64-bit\n    targets.  */"}, {"sha": "930bbced084ea91c321f0e3954e85dea48d7a85a", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=88cad84baf99c032409c2de03f151c4ccf771fbf", "patch": "@@ -160,7 +160,7 @@ extern int target_flags;\n /* Disable use of FPRs.  */\n #define MASK_SOFT_FLOAT\t\t0x00000800\n \n-/* Enable load/store multiple, even on powerpc */\n+/* Enable load/store multiple, even on PowerPC */\n #define\tMASK_MULTIPLE\t\t0x00001000\n #define\tMASK_MULTIPLE_SET\t0x00002000\n "}, {"sha": "5921390a2bc620296ec4e7ef8e295f7cd09bddcd", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=88cad84baf99c032409c2de03f151c4ccf771fbf", "patch": "@@ -7137,7 +7137,7 @@ sh_pr_n_sets ()\n   return REG_N_SETS (TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG);\n }\n \n-/* This Function returns non zero if the DFA based scheduler interface\n+/* This Function returns nonzero if the DFA based scheduler interface\n    is to be used.  At present this is supported for the SH4 only.  */\n static int\n sh_use_dfa_interface()"}, {"sha": "37061be610dc3bd317899c947754ea781b65970d", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=88cad84baf99c032409c2de03f151c4ccf771fbf", "patch": "@@ -3158,7 +3158,7 @@ pic_address_needs_scratch (x)\n \n /* Legitimize PIC addresses.  If the address is already position-independent,\n    we return ORIG.  Newly generated position-independent addresses go into a\n-   reg.  This is REG if non zero, otherwise we allocate register(s) as\n+   reg.  This is REG if nonzero, otherwise we allocate register(s) as\n    necessary.  */\n \n rtx"}, {"sha": "2194be7ad7863b1ea905564d206a4f7c5c9fd6c6", "filename": "gcc/config/sparc/ultra1_2.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Fsparc%2Fultra1_2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fconfig%2Fsparc%2Fultra1_2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fultra1_2.md?ref=88cad84baf99c032409c2de03f151c4ccf771fbf", "patch": "@@ -206,7 +206,7 @@\n   \"us1_fpm + us1_fp_double + us1_slotany, nothing*3\")\n \n ;; This is actually in theory dangerous, because it is possible\n-;; for the chip to prematurely dispatch the dependant instruction\n+;; for the chip to prematurely dispatch the dependent instruction\n ;; in the G stage, resulting in a 9 cycle stall.  However I have never\n ;; been able to trigger this case myself even with hand written code,\n ;; so it must require some rare complicated pipeline state."}, {"sha": "c5eb4d6ab9a11d9d29045cb2c439dfa00358d87a", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=88cad84baf99c032409c2de03f151c4ccf771fbf", "patch": "@@ -158,7 +158,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n static int issue_rate;\n \n-/* If the following variable value is non zero, the scheduler inserts\n+/* If the following variable value is nonzero, the scheduler inserts\n    bubbles (nop insns).  The value of variable affects on scheduler\n    behavior only if automaton pipeline interface with multipass\n    scheduling is used and hook dfa_bubble is defined.  */"}, {"sha": "672ee98fdff40b5511d8ec7ef088446a8edc2e77", "filename": "gcc/regclass.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=88cad84baf99c032409c2de03f151c4ccf771fbf", "patch": "@@ -2189,10 +2189,10 @@ static unsigned int reg_n_max;\n \n /* Allocate enough space to hold NUM_REGS registers for the tables used for\n    reg_scan and flow_analysis that are indexed by the register number.  If\n-   NEW_P is non zero, initialize all of the registers, otherwise only\n+   NEW_P is nonzero, initialize all of the registers, otherwise only\n    initialize the new registers allocated.  The same table is kept from\n    function to function, only reallocating it when we need more room.  If\n-   RENUMBER_P is non zero, allocate the reg_renumber array also.  */\n+   RENUMBER_P is nonzero, allocate the reg_renumber array also.  */\n \n void\n allocate_reg_info (num_regs, new_p, renumber_p)"}, {"sha": "923652c422ef4cb0b953e1cdcc04c92ec413debf", "filename": "gcc/regrename.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88cad84baf99c032409c2de03f151c4ccf771fbf/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=88cad84baf99c032409c2de03f151c4ccf771fbf", "patch": "@@ -1243,7 +1243,7 @@ copy_value (dest, src, vd)\n     return;\n \n   /* Do not propagate copies to the stack pointer, as that can leave\n-     memory accesses with no scheduling dependancy on the stack update.  */\n+     memory accesses with no scheduling dependency on the stack update.  */\n   if (dr == STACK_POINTER_REGNUM)\n     return;\n "}]}