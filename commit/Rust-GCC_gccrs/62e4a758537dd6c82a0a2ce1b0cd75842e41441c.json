{"sha": "62e4a758537dd6c82a0a2ce1b0cd75842e41441c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJlNGE3NTg1MzdkZDZjODJhMGEyY2UxYjBjZDc1ODQyZTQxNDQxYw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-01-22T13:51:43Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-01-22T13:51:43Z"}, "message": "cp-tree.h (unification_kind_t): Add DEDUCE_ORDER.\n\ncp:\n\t* cp-tree.h (unification_kind_t): Add DEDUCE_ORDER.\n\t(more_specialized): Add deduction parameter.\n\t* call.c (joust): Adjust more_specialized call.\n\t* pt.c (UNIFY_ALLOW_OUTER_MORE_CV_QUAL,\n\tUNIFY_ALLOW_OUTER_LESS_CV_QUAL): New unify flags.\n\t(get_bindings_order): Remove.\n\t(get_bindings_real): Add DEDUCE parameter.\n\t(maybe_adjust_types_for_deduction): Return extra unify flags. Do\n\tREFERENCE_TYPE jig for DEDUCE_ORDER.\n\t(type_unification_real): Deal with DEDUCE_ORDER. Use result of\n\tmaybe_adjust_types_for_deduction.\n\t(more_specialized): Add DEDUCE parameter. Call get_bindings_real\n\tdirectly.\n\t(try_one_overload): Use result of maybe_adjust_types_for_deduction.\n\t(check_cv_quals_for_unify): Use new unify qualifier flags.\n\t(unify): Clear new unify qualifier flags.\n\t(get_bindings_real): Add DEDUCE parameter.\n\t(get_bindings): Adjust call to get_bindings_real.\n\t(get_bindings_overload): Likewise.\n\t(most_specialized_instantiation): Adjust call to\n\tmore_specialized.\ntestsuite:\n\t* g++.old-deja/g++.martin/sts_partial.C: Remove XFAIL.\n\t* g++.old-deja/g++.pt/spec35.C: New test.\n\t* g++.old-deja/g++.pt/spec36.C: New test.\n\nFrom-SVN: r39182", "tree": {"sha": "8feaf4e16f95f3879323455ce542e7a5e0b35e7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8feaf4e16f95f3879323455ce542e7a5e0b35e7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62e4a758537dd6c82a0a2ce1b0cd75842e41441c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62e4a758537dd6c82a0a2ce1b0cd75842e41441c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62e4a758537dd6c82a0a2ce1b0cd75842e41441c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62e4a758537dd6c82a0a2ce1b0cd75842e41441c/comments", "author": null, "committer": null, "parents": [{"sha": "0bbcfbafc8aa36f62eb4d347301cf80498ac3464", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bbcfbafc8aa36f62eb4d347301cf80498ac3464", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bbcfbafc8aa36f62eb4d347301cf80498ac3464"}], "stats": {"total": 258, "additions": 212, "deletions": 46}, "files": [{"sha": "3374dd2e268f0b2ba7b1a4c027ff53a2c35deea6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e4a758537dd6c82a0a2ce1b0cd75842e41441c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e4a758537dd6c82a0a2ce1b0cd75842e41441c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=62e4a758537dd6c82a0a2ce1b0cd75842e41441c", "patch": "@@ -1,3 +1,27 @@\n+2001-01-22  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cp-tree.h (unification_kind_t): Add DEDUCE_ORDER.\n+\t(more_specialized): Add deduction parameter.\n+\t* call.c (joust): Adjust more_specialized call.\n+\t* pt.c (UNIFY_ALLOW_OUTER_MORE_CV_QUAL,\n+\tUNIFY_ALLOW_OUTER_LESS_CV_QUAL): New unify flags.\n+\t(get_bindings_order): Remove.\n+\t(get_bindings_real): Add DEDUCE parameter.\n+\t(maybe_adjust_types_for_deduction): Return extra unify flags. Do\n+\tREFERENCE_TYPE jig for DEDUCE_ORDER.\n+\t(type_unification_real): Deal with DEDUCE_ORDER. Use result of\n+\tmaybe_adjust_types_for_deduction.\n+\t(more_specialized): Add DEDUCE parameter. Call get_bindings_real\n+\tdirectly.\n+\t(try_one_overload): Use result of maybe_adjust_types_for_deduction.\n+\t(check_cv_quals_for_unify): Use new unify qualifier flags.\n+\t(unify): Clear new unify qualifier flags.\n+\t(get_bindings_real): Add DEDUCE parameter.\n+\t(get_bindings): Adjust call to get_bindings_real.\n+\t(get_bindings_overload): Likewise.\n+\t(most_specialized_instantiation): Adjust call to\n+\tmore_specialized.\n+\n 2001-01-19  Jason Merrill  <jason@redhat.com>\n \n \t* decl2.c (flag_vtable_thunks): Also depend on ENABLE_NEW_GXX_ABI."}, {"sha": "fa5a50803bf0a31215bf9802e21e44d8dfb70492", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e4a758537dd6c82a0a2ce1b0cd75842e41441c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e4a758537dd6c82a0a2ce1b0cd75842e41441c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=62e4a758537dd6c82a0a2ce1b0cd75842e41441c", "patch": "@@ -5196,6 +5196,7 @@ joust (cand1, cand2, warn)\n   else if (cand1->template && cand2->template)\n     winner = more_specialized\n       (TI_TEMPLATE (cand1->template), TI_TEMPLATE (cand2->template),\n+       DEDUCE_ORDER,\n        /* Never do unification on the 'this' parameter.  */\n        TREE_VEC_LENGTH (cand1->convs)\n        - DECL_NONSTATIC_MEMBER_FUNCTION_P (cand1->fn));"}, {"sha": "8122d566697b02e262288faed356a23582a6b1b8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e4a758537dd6c82a0a2ce1b0cd75842e41441c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e4a758537dd6c82a0a2ce1b0cd75842e41441c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=62e4a758537dd6c82a0a2ce1b0cd75842e41441c", "patch": "@@ -3209,14 +3209,15 @@ extern int function_depth;\n \n /* in pt.c  */\n \n-/* These values are used for the `STRICT' parameter to type_unfication and\n+/* These values are used for the `STRICT' parameter to type_unification and\n    fn_type_unification.  Their meanings are described with the\n    documentation for fn_type_unification.  */\n \n typedef enum unification_kind_t {\n   DEDUCE_CALL,\n   DEDUCE_CONV,\n-  DEDUCE_EXACT\n+  DEDUCE_EXACT,\n+  DEDUCE_ORDER\n } unification_kind_t;\n \n /* Macros for operating on a template instantation level node, represented\n@@ -4143,7 +4144,7 @@ extern tree instantiate_template\t\tPARAMS ((tree, tree));\n extern int fn_type_unification                  PARAMS ((tree, tree, tree, tree, tree, unification_kind_t, int));\n extern tree tinst_for_decl\t\t\tPARAMS ((void));\n extern void mark_decl_instantiated\t\tPARAMS ((tree, int));\n-extern int more_specialized\t\t\tPARAMS ((tree, tree, int));\n+extern int more_specialized\t\t\tPARAMS ((tree, tree, int, int));\n extern void mark_class_instantiated\t\tPARAMS ((tree, int));\n extern void do_decl_instantiation\t\tPARAMS ((tree, tree, tree));\n extern void do_type_instantiation\t\tPARAMS ((tree, tree, int));"}, {"sha": "184edf846f9d255e87a13893e6c44962c97feb0f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 100, "deletions": 42, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e4a758537dd6c82a0a2ce1b0cd75842e41441c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e4a758537dd6c82a0a2ce1b0cd75842e41441c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=62e4a758537dd6c82a0a2ce1b0cd75842e41441c", "patch": "@@ -87,6 +87,8 @@ static htab_t local_specializations;\n #define UNIFY_ALLOW_DERIVED 4\n #define UNIFY_ALLOW_INTEGER 8\n #define UNIFY_ALLOW_OUTER_LEVEL 16\n+#define UNIFY_ALLOW_OUTER_MORE_CV_QUAL 32\n+#define UNIFY_ALLOW_OUTER_LESS_CV_QUAL 64\n \n #define GTB_VIA_VIRTUAL 1 /* The base class we are examining is\n \t\t\t     virtual, or a base class of a virtual\n@@ -111,7 +113,7 @@ static tree coerce_template_parms PARAMS ((tree, tree, tree, int, int));\n static void tsubst_enum\tPARAMS ((tree, tree, tree));\n static tree add_to_template_args PARAMS ((tree, tree));\n static tree add_outermost_template_args PARAMS ((tree, tree));\n-static void maybe_adjust_types_for_deduction PARAMS ((unification_kind_t, tree*,\n+static int maybe_adjust_types_for_deduction PARAMS ((unification_kind_t, tree*,\n \t\t\t\t\t\t    tree*)); \n static int  type_unification_real PARAMS ((tree, tree, tree, tree,\n \t\t\t\t\t int, unification_kind_t, int, int));\n@@ -121,7 +123,6 @@ static tree convert_nontype_argument PARAMS ((tree, tree));\n static tree convert_template_argument PARAMS ((tree, tree, tree, int,\n \t\t\t\t\t      int , tree));\n static tree get_bindings_overload PARAMS ((tree, tree, tree));\n-static tree get_bindings_order PARAMS ((tree, tree, int));\n static int for_each_template_parm PARAMS ((tree, tree_fn_t, void*));\n static tree build_template_parm_index PARAMS ((int, int, int, tree, tree));\n static int inline_needs_template_parms PARAMS ((tree));\n@@ -136,7 +137,7 @@ static tree build_template_decl PARAMS ((tree, tree));\n static int mark_template_parm PARAMS ((tree, void *));\n static tree tsubst_friend_function PARAMS ((tree, tree));\n static tree tsubst_friend_class PARAMS ((tree, tree));\n-static tree get_bindings_real PARAMS ((tree, tree, tree, int, int));\n+static tree get_bindings_real PARAMS ((tree, tree, tree, int, int, int));\n static int template_decl_level PARAMS ((tree));\n static tree maybe_get_template_decl_from_type_decl PARAMS ((tree));\n static int check_cv_quals_for_unify PARAMS ((int, tree, tree));\n@@ -7681,13 +7682,15 @@ instantiate_template (tmpl, targ_ptr)\n      [temp.deduct.conv].\n \n    DEDUCE_EXACT:\n+     We are deducing arguments when doing an explicit instantiation\n+     as in [temp.explicit], when determining an explicit specialization\n+     as in [temp.expl.spec], or when taking the address of a function\n+     template, as in [temp.deduct.funcaddr]. \n+\n+   DEDUCE_ORDER:\n      We are deducing arguments when calculating the partial\n      ordering between specializations of function or class\n-     templates, as in [temp.func.order] and [temp.class.order],\n-     when doing an explicit instantiation as in [temp.explicit],\n-     when determining an explicit specialization as in\n-     [temp.expl.spec], or when taking the address of a function\n-     template, as in [temp.deduct.funcaddr]. \n+     templates, as in [temp.func.order] and [temp.class.order].\n \n    LEN is the number of parms to consider before returning success, or -1\n    for all.  This is used in partial ordering to avoid comparing parms for\n@@ -7793,12 +7796,14 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n    the argument passed to the call, or the type of the value\n    initialized with the result of the conversion function.  */\n \n-static void\n+static int\n maybe_adjust_types_for_deduction (strict, parm, arg)\n      unification_kind_t strict;\n      tree* parm;\n      tree* arg;\n {\n+  int result = 0;\n+  \n   switch (strict)\n     {\n     case DEDUCE_CALL:\n@@ -7817,8 +7822,43 @@ maybe_adjust_types_for_deduction (strict, parm, arg)\n \n     case DEDUCE_EXACT:\n       /* There is nothing to do in this case.  */\n-      return;\n+      return 0;\n \n+    case DEDUCE_ORDER:\n+      /* DR 214. [temp.func.order] is underspecified, and leads to no\n+         ordering between things like `T *' and `T const &' for `U *'.\n+         The former has T=U and the latter T=U*. The former looks more\n+         specialized and John Spicer considers it well-formed (the EDG\n+         compiler accepts it).\n+\n+         John also confirms that deduction should proceed as in a function\n+         call. Which implies the usual ARG and PARM bashing as DEDUCE_CALL.\n+         However, in ordering, ARG can have REFERENCE_TYPE, but no argument\n+         to an actual call can have such a type.\n+         \n+         When deducing against a REFERENCE_TYPE, we can either not change\n+         PARM's type, or we can change ARG's type too. The latter, though\n+         seemingly more safe, turns out to give the following quirk. Consider\n+         deducing a call to a `const int *' with the following template \n+         function parameters \n+           #1; T const *const &   ; T = int\n+           #2; T *const &         ; T = const int\n+           #3; T *                ; T = const int\n+         It looks like #1 is the more specialized.  Taken pairwise, #1 is\n+         more specialized than #2 and #2 is more specialized than #3, yet\n+         there is no ordering between #1 and #3.\n+         \n+         So, if ARG is a reference, we look though it when PARM is\n+         not a refence. When both are references we don't change either.  */\n+      if (TREE_CODE (*arg) == REFERENCE_TYPE)\n+        {\n+          if (TREE_CODE (*parm) == REFERENCE_TYPE)\n+            return 0;\n+          *arg = TREE_TYPE (*arg);\n+          result |= UNIFY_ALLOW_OUTER_LESS_CV_QUAL;\n+          goto skip_arg;\n+        }\n+      break;\n     default:\n       my_friendly_abort (0);\n     }\n@@ -7849,6 +7889,7 @@ maybe_adjust_types_for_deduction (strict, parm, arg)\n \t*arg = TYPE_MAIN_VARIANT (*arg);\n     }\n   \n+  skip_arg:;\n   /* [temp.deduct.call]\n      \n      If P is a cv-qualified type, the top level cv-qualifiers\n@@ -7857,7 +7898,11 @@ maybe_adjust_types_for_deduction (strict, parm, arg)\n      type deduction.  */\n   *parm = TYPE_MAIN_VARIANT (*parm);\n   if (TREE_CODE (*parm) == REFERENCE_TYPE)\n-    *parm = TREE_TYPE (*parm);\n+    {\n+      *parm = TREE_TYPE (*parm);\n+      result |= UNIFY_ALLOW_OUTER_MORE_CV_QUAL;\n+    }\n+  return result;\n }\n \n /* Most parms like fn_type_unification.\n@@ -7902,6 +7947,10 @@ type_unification_real (tparms, targs, parms, args, subr,\n     case DEDUCE_EXACT:\n       sub_strict = UNIFY_ALLOW_NONE;\n       break;\n+    \n+    case DEDUCE_ORDER:\n+      sub_strict = UNIFY_ALLOW_NONE;\n+      break;\n       \n     default:\n       my_friendly_abort (0);\n@@ -7943,7 +7992,7 @@ type_unification_real (tparms, targs, parms, args, subr,\n \t      arg = NULL_TREE;\n \t    }\n \n-\t  if (strict == DEDUCE_EXACT)\n+\t  if (strict == DEDUCE_EXACT || strict == DEDUCE_ORDER)\n \t    {\n \t      if (same_type_p (parm, type))\n \t\tcontinue;\n@@ -7976,12 +8025,16 @@ type_unification_real (tparms, targs, parms, args, subr,\n \t    }\n \t  arg = TREE_TYPE (arg);\n \t}\n+      \n+      {\n+        int arg_strict = sub_strict;\n+        \n+        if (!subr)\n+\t  arg_strict |= maybe_adjust_types_for_deduction (strict, &parm, &arg);\n \n-      if (!subr)\n-\tmaybe_adjust_types_for_deduction (strict, &parm, &arg);\n-\n-      if (unify (tparms, targs, parm, arg, sub_strict))\n-        return 1;\n+        if (unify (tparms, targs, parm, arg, arg_strict))\n+          return 1;\n+      }\n \n       /* Are we done with the interesting parms?  */\n       if (--len == 0)\n@@ -8129,7 +8182,7 @@ try_one_overload (tparms, orig_targs, targs, parm, arg, strict,\n   if (uses_template_parms (arg))\n     return 1;\n \n-  maybe_adjust_types_for_deduction (strict, &parm, &arg);\n+  sub_strict |= maybe_adjust_types_for_deduction (strict, &parm, &arg);\n \n   /* We don't copy orig_targs for this because if we have already deduced\n      some template args from previous args, unify would complain when we\n@@ -8413,11 +8466,11 @@ check_cv_quals_for_unify (strict, arg, parm)\n      tree arg;\n      tree parm;\n {\n-  if (!(strict & UNIFY_ALLOW_MORE_CV_QUAL)\n+  if (!(strict & (UNIFY_ALLOW_MORE_CV_QUAL | UNIFY_ALLOW_OUTER_MORE_CV_QUAL))\n       && !at_least_as_qualified_p (arg, parm))\n     return 0;\n \n-  if (!(strict & UNIFY_ALLOW_LESS_CV_QUAL)\n+  if (!(strict & (UNIFY_ALLOW_LESS_CV_QUAL | UNIFY_ALLOW_OUTER_LESS_CV_QUAL))\n       && !at_least_as_qualified_p (parm, arg))\n     return 0;\n \n@@ -8448,7 +8501,13 @@ check_cv_quals_for_unify (strict, arg, parm)\n        have const qualified pointers leading up to the inner type which\n        requires additional CV quals, except at the outer level, where const\n        is not required [conv.qual]. It would be normal to set this flag in\n-       addition to setting UNIFY_ALLOW_MORE_CV_QUAL.  */\n+       addition to setting UNIFY_ALLOW_MORE_CV_QUAL.\n+     UNIFY_ALLOW_OUTER_MORE_CV_QUAL:\n+       This is the outermost level of a deduction, and PARM can be more CV\n+       qualified at this point.\n+     UNIFY_ALLOW_OUTER_LESS_CV_QUAL:\n+       This is the outermost level of a deduction, and PARM can be less CV\n+       qualified at this point.  */\n \n static int\n unify (tparms, targs, parm, arg, strict)\n@@ -8498,6 +8557,8 @@ unify (tparms, targs, parm, arg, strict)\n     strict &= ~UNIFY_ALLOW_MORE_CV_QUAL;\n   strict &= ~UNIFY_ALLOW_OUTER_LEVEL;\n   strict &= ~UNIFY_ALLOW_DERIVED;\n+  strict &= ~UNIFY_ALLOW_OUTER_MORE_CV_QUAL;\n+  strict &= ~UNIFY_ALLOW_OUTER_LESS_CV_QUAL;\n   \n   switch (TREE_CODE (parm))\n     {\n@@ -8963,25 +9024,30 @@ mark_decl_instantiated (result, extern_p)\n \n /* Given two function templates PAT1 and PAT2, return:\n \n+   DEDUCE should be DEDUCE_EXACT or DEDUCE_ORDER.\n+   \n    1 if PAT1 is more specialized than PAT2 as described in [temp.func.order].\n    -1 if PAT2 is more specialized than PAT1.\n    0 if neither is more specialized.\n \n    LEN is passed through to fn_type_unification.  */\n    \n int\n-more_specialized (pat1, pat2, len)\n+more_specialized (pat1, pat2, deduce, len)\n      tree pat1, pat2;\n+     int deduce;\n      int len;\n {\n   tree targs;\n   int winner = 0;\n \n-  targs = get_bindings_order (pat1, DECL_TEMPLATE_RESULT (pat2), len);\n+  targs = get_bindings_real (pat1, DECL_TEMPLATE_RESULT (pat2),\n+                             NULL_TREE, 0, deduce, len);\n   if (targs)\n     --winner;\n \n-  targs = get_bindings_order (pat2, DECL_TEMPLATE_RESULT (pat1), len);\n+  targs = get_bindings_real (pat2, DECL_TEMPLATE_RESULT (pat1),\n+                             NULL_TREE, 0, deduce, len);\n   if (targs)\n     ++winner;\n \n@@ -9018,12 +9084,12 @@ more_specialized_class (pat1, pat2)\n    DECL from the function template FN, with the explicit template\n    arguments EXPLICIT_ARGS.  If CHECK_RETTYPE is 1, the return type must\n    also match.  Return NULL_TREE if no satisfactory arguments could be\n-   found.  LEN is passed through to fn_type_unification.  */\n+   found.  DEDUCE and LEN are passed through to fn_type_unification.  */\n    \n static tree\n-get_bindings_real (fn, decl, explicit_args, check_rettype, len)\n+get_bindings_real (fn, decl, explicit_args, check_rettype, deduce, len)\n      tree fn, decl, explicit_args;\n-     int check_rettype, len;\n+     int check_rettype, deduce, len;\n {\n   int ntparms = DECL_NTPARMS (fn);\n   tree targs = make_tree_vec (ntparms);\n@@ -9069,7 +9135,7 @@ get_bindings_real (fn, decl, explicit_args, check_rettype, len)\n \t\t\t   decl_arg_types,\n \t\t\t   (check_rettype || DECL_CONV_FN_P (fn)\n \t                    ? TREE_TYPE (decl_type) : NULL_TREE),\n-\t\t\t   DEDUCE_EXACT, len);\n+\t\t\t   deduce, len);\n \n   if (i != 0)\n     return NULL_TREE;\n@@ -9083,7 +9149,7 @@ tree\n get_bindings (fn, decl, explicit_args)\n      tree fn, decl, explicit_args;\n {\n-  return get_bindings_real (fn, decl, explicit_args, 1, -1);\n+  return get_bindings_real (fn, decl, explicit_args, 1, DEDUCE_EXACT, -1);\n }\n \n /* But for resolve_overloaded_unification, we only care about the parameter\n@@ -9093,17 +9159,7 @@ static tree\n get_bindings_overload (fn, decl, explicit_args)\n      tree fn, decl, explicit_args;\n {\n-  return get_bindings_real (fn, decl, explicit_args, 0, -1);\n-}\n-\n-/* And for more_specialized, we want to be able to stop partway.  */\n-\n-static tree\n-get_bindings_order (fn, decl, len)\n-     tree fn, decl;\n-     int len;\n-{\n-  return get_bindings_real (fn, decl, NULL_TREE, 0, len);\n+  return get_bindings_real (fn, decl, explicit_args, 0, DEDUCE_EXACT, -1);\n }\n \n /* Return the innermost template arguments that, when applied to a\n@@ -9162,7 +9218,8 @@ most_specialized_instantiation (instantiations)\n   champ = instantiations;\n   for (fn = TREE_CHAIN (instantiations); fn; fn = TREE_CHAIN (fn))\n     {\n-      fate = more_specialized (TREE_VALUE (champ), TREE_VALUE (fn), -1);\n+      fate = more_specialized (TREE_VALUE (champ), TREE_VALUE (fn),\n+                               DEDUCE_EXACT, -1);\n       if (fate == 1)\n \t;\n       else\n@@ -9179,7 +9236,8 @@ most_specialized_instantiation (instantiations)\n \n   for (fn = instantiations; fn && fn != champ; fn = TREE_CHAIN (fn))\n     {\n-      fate = more_specialized (TREE_VALUE (champ), TREE_VALUE (fn), -1);\n+      fate = more_specialized (TREE_VALUE (champ), TREE_VALUE (fn),\n+                               DEDUCE_EXACT, -1);\n       if (fate != 1)\n \treturn error_mark_node;\n     }"}, {"sha": "09f2e134866badb82cd3717736c271fdfd5b3af4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e4a758537dd6c82a0a2ce1b0cd75842e41441c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e4a758537dd6c82a0a2ce1b0cd75842e41441c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=62e4a758537dd6c82a0a2ce1b0cd75842e41441c", "patch": "@@ -1,3 +1,9 @@\n+2001-01-22  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.old-deja/g++.martin/sts_partial.C: Remove XFAIL.\n+\t* g++.old-deja/g++.pt/spec35.C: New test.\n+\t* g++.old-deja/g++.pt/spec36.C: New test.\n+\n 2001-01-20  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.c-torture/compile/20010118-1.c: New test."}, {"sha": "382214c3c76de7d870ea25bd7fe80ab2312b0931", "filename": "gcc/testsuite/g++.old-deja/g++.martin/sts_partial.C", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e4a758537dd6c82a0a2ce1b0cd75842e41441c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.martin%2Fsts_partial.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e4a758537dd6c82a0a2ce1b0cd75842e41441c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.martin%2Fsts_partial.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.martin%2Fsts_partial.C?ref=62e4a758537dd6c82a0a2ce1b0cd75842e41441c", "patch": "@@ -1,4 +1,3 @@\n-// excess errors test - XFAIL \n // ecgs-bugs 1999-02-22 14:26 Stefan Schwarzer\n // sts@ica1.uni-stuttgart.de\n // partial ordering problem in egcs <= 1.1.1"}, {"sha": "e768c9104b3ad53bf3108a332d09f9e91d73b264", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec35.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e4a758537dd6c82a0a2ce1b0cd75842e41441c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec35.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e4a758537dd6c82a0a2ce1b0cd75842e41441c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec35.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec35.C?ref=62e4a758537dd6c82a0a2ce1b0cd75842e41441c", "patch": "@@ -0,0 +1,31 @@\n+// Build don't link:\n+// \n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 18 Jan 2001 <nathan@codesourcery.com>\n+\n+// Bug 1617. We didn't resolve partial ordering properly. The std is rather\n+// vague about it anyway, DR 214 talks about this.\n+\n+extern \"C\" int puts (char const *);\n+\n+template <typename T> int Foo (T);    // ERROR - candidate\n+template <typename T> int Foo (T &);  // ERROR - candidate\n+\n+template <typename T> int Qux (T);    // ERROR - candidate\n+template <typename T> int Qux (T const &);  // ERROR - candidate\n+\n+template <typename T> int Bar (T const *const &); // ERROR - candidate\n+template <typename T> int Bar (T *const &);       // ERROR - candidate\n+template <typename T> int Bar (T *);              // ERROR - candidate\n+\n+template <typename T> int Baz (T *const &);       // ERROR - candidate\n+template <typename T> int Baz (T *);              // ERROR - candidate\n+\n+int Baz (int const *ptr, int *ptr2)\n+{\n+  Baz (ptr2);   // ERROR - ambiguous\n+  Bar (ptr2);   // ERROR - ambiguous\n+  Foo (ptr2);   // ERROR - ambiguous\n+  Qux (ptr2);   // ERROR - ambiguous\n+  return 0;\n+}"}, {"sha": "7581f85e51044db0b5e0212323fdb68f4f0812b6", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec36.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e4a758537dd6c82a0a2ce1b0cd75842e41441c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec36.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e4a758537dd6c82a0a2ce1b0cd75842e41441c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec36.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec36.C?ref=62e4a758537dd6c82a0a2ce1b0cd75842e41441c", "patch": "@@ -0,0 +1,46 @@\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 18 Jan 2001 <nathan@codesourcery.com>\n+\n+// Bug 1617. We didn't resolve partial ordering properly. The std is rather\n+// vague about it anyway, DR 214 talks about this.\n+\n+extern \"C\" int puts (char const *);\n+\n+template <typename T> int Foo (T *) {puts (__PRETTY_FUNCTION__); return 1;}\n+template <typename T> int Foo (T &) {puts (__PRETTY_FUNCTION__); return 2;}\n+template <typename T> int Foo (T const &) {puts (__PRETTY_FUNCTION__); return 3;}\n+\n+template <typename T> int Bar (T const *const &) {puts (__PRETTY_FUNCTION__); return 4;}\n+template <typename T> int Bar (T *const &) {puts (__PRETTY_FUNCTION__); return 5;}\n+template <typename T> int Bar (T *) {puts (__PRETTY_FUNCTION__); return 6;}\n+\n+template <typename T> int Quux (T *const &) {puts (__PRETTY_FUNCTION__); return 7;}\n+template <typename T> int Quux (T const &) {puts (__PRETTY_FUNCTION__); return 8;}\n+\n+\n+int Baz (int const *ptr, int *ptr2)\n+{\n+  if (Foo (ptr) != 1)\n+    return 1;\n+  if (Foo (ptr2) != 1)\n+    return 2;\n+  if (Foo (*ptr) != 3)\n+    return 3;\n+  if (Foo (*ptr2) != 2)\n+    return 4;\n+  \n+  if (Bar (ptr) != 4)\n+    return 5;\n+  \n+  if (Quux (ptr) != 7)\n+    return 5;\n+  if (Quux (ptr2) != 7)\n+    return 6;\n+  \n+  return 0;\n+}\n+\n+int main ()\n+{\n+  return Baz (0, 0);\n+}"}]}