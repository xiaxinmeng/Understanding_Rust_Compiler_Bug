{"sha": "280fedf0677108f96d3c701815bccc182eff9fb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgwZmVkZjA2NzcxMDhmOTZkM2M3MDE4MTViY2NjMTgyZWZmOWZiNA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2010-11-11T12:03:59Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2010-11-11T12:03:59Z"}, "message": "re PR tree-optimization/46383 (ICE: in get_binfo_at_offset, at tree.c:10947)\n\n2010-11-11  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/46383\n\t* ipa-prop.c (compute_complex_assign_jump_func): Ignore negative\n\toffsets.\n\t(compute_complex_ancestor_jump_func): Likewise.\n\t* tree.c (get_binfo_at_offset): Return NULL_TREE if offset is negative.\n\n\t* testsuite/g++.dg/torture/pr46383.C: New test.\n\nFrom-SVN: r166598", "tree": {"sha": "858b06e1bf0775f367e80028c2b76443c1c53791", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/858b06e1bf0775f367e80028c2b76443c1c53791"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/280fedf0677108f96d3c701815bccc182eff9fb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/280fedf0677108f96d3c701815bccc182eff9fb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/280fedf0677108f96d3c701815bccc182eff9fb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/280fedf0677108f96d3c701815bccc182eff9fb4/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "778216a0c8f4c2050e074a4f0b2e0c067e32140c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/778216a0c8f4c2050e074a4f0b2e0c067e32140c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/778216a0c8f4c2050e074a4f0b2e0c067e32140c"}], "stats": {"total": 275, "additions": 271, "deletions": 4}, "files": [{"sha": "db8367dade2bcd5cd40f9f9f46655377ea03da24", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280fedf0677108f96d3c701815bccc182eff9fb4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280fedf0677108f96d3c701815bccc182eff9fb4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=280fedf0677108f96d3c701815bccc182eff9fb4", "patch": "@@ -1,3 +1,11 @@\n+2010-11-11  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/46383\n+\t* ipa-prop.c (compute_complex_assign_jump_func): Ignore negative\n+\toffsets.\n+\t(compute_complex_ancestor_jump_func): Likewise.\n+\t* tree.c (get_binfo_at_offset): Return NULL_TREE if offset is negative.\n+\n 2010-11-11  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/46150"}, {"sha": "d0587b6fb5e36f61f2f012e1399a0ed1cbd422f3", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280fedf0677108f96d3c701815bccc182eff9fb4/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280fedf0677108f96d3c701815bccc182eff9fb4/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=280fedf0677108f96d3c701815bccc182eff9fb4", "patch": "@@ -413,7 +413,8 @@ compute_complex_assign_jump_func (struct ipa_node_params *info,\n   offset += mem_ref_offset (op1).low * BITS_PER_UNIT;\n   op1 = TREE_OPERAND (op1, 0);\n   if (TREE_CODE (op1) != SSA_NAME\n-      || !SSA_NAME_IS_DEFAULT_DEF (op1))\n+      || !SSA_NAME_IS_DEFAULT_DEF (op1)\n+      || offset < 0)\n     return;\n \n   index = ipa_get_param_decl_index (info, SSA_NAME_VAR (op1));\n@@ -490,7 +491,8 @@ compute_complex_ancestor_jump_func (struct ipa_node_params *info,\n   offset += mem_ref_offset (expr).low * BITS_PER_UNIT;\n   parm = TREE_OPERAND (expr, 0);\n   if (TREE_CODE (parm) != SSA_NAME\n-      || !SSA_NAME_IS_DEFAULT_DEF (parm))\n+      || !SSA_NAME_IS_DEFAULT_DEF (parm)\n+      || offset < 0)\n     return;\n \n   index = ipa_get_param_decl_index (info, SSA_NAME_VAR (parm));"}, {"sha": "95c548c1332ccc36ab38e5e5e1fffa78aae5b306", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280fedf0677108f96d3c701815bccc182eff9fb4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280fedf0677108f96d3c701815bccc182eff9fb4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=280fedf0677108f96d3c701815bccc182eff9fb4", "patch": "@@ -1,3 +1,8 @@\n+2010-11-11  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/46383\n+\t* g++.dg/torture/pr46383.C: New test.\n+\n 2010-11-11  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc-target/i386/sse-12.c: Add -msse4a to dg-options."}, {"sha": "2b610394bdeb2faf4b3fa955cf0cf008969e7c84", "filename": "gcc/testsuite/g++.dg/torture/pr46383.C", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280fedf0677108f96d3c701815bccc182eff9fb4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr46383.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280fedf0677108f96d3c701815bccc182eff9fb4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr46383.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr46383.C?ref=280fedf0677108f96d3c701815bccc182eff9fb4", "patch": "@@ -0,0 +1,252 @@\n+// { dg-do compile }\n+\n+namespace std {\n+template<class,class>struct pair{};\n+  template<typename _Tp> struct _Vector_base {\n+      struct _Vector_impl\n+      {\n+\t_Tp* _M_start;\n+\t_Tp* _M_finish;\n+\t_Tp* _M_end_of_storage;\n+      };\n+      _Vector_impl _M_impl;\n+    };\n+  template<typename _Tp >\n+    struct vector : _Vector_base<_Tp>\n+    {\n+      vector(const vector& __x);\n+    };\n+}\n+namespace boost {\n+struct G{};\n+template <class T, class U >\n+struct modable2\n+: G\n+{ };\n+}\n+namespace CGAL {\n+struct Rep { };\n+struct Handle\n+{\n+    Handle() ;\n+    Handle(const Handle& x) ;\n+    Rep* PTR;\n+};\n+template <typename ET_> class Lazy_exact_nt\n+  : Handle\n+  , boost::modable2< Lazy_exact_nt<ET_>, int >\n+  , boost::modable2< Lazy_exact_nt<ET_>, double >\n+{ };\n+  struct CC_iterator { };\n+struct Triangulation_data_structure_3 {\n+  typedef CC_iterator                          Vertex_handle;\n+  typedef CC_iterator                            Cell_handle;\n+  typedef std::pair<Cell_handle, int>              Facet;\n+};\n+template < class GT, class Tds_ > struct Triangulation_3 {\n+  typedef Tds_                                  Tds;\n+  typedef typename GT::Point_3                 Point;\n+  typedef typename Tds::Facet                  Facet;\n+  typedef typename Tds::Vertex_handle          Vertex_handle;\n+  enum Locate_type { VERTEX=0, EDGE, FACET, CELL, OUTSIDE_CONVEX_HULL, OUTSIDE_AFFINE_HULL };\n+  Tds _tds;\n+  bool is_infinite(const Facet & f) const ;\n+};\n+template < class Gt, class Tds_ > struct Delaunay_triangulation_3 : public Triangulation_3<Gt, Tds_> { };\n+  namespace Surface_mesher { enum Verbose_flag { VERBOSE, NOT_VERBOSE }; }\n+enum Mesher_level_conflict_status { NO_CONFLICT = 0, CONFLICT_BUT_ELEMENT_CAN_BE_RECONSIDERED, CONFLICT_AND_ELEMENT_SHOULD_BE_DROPPED };\n+struct Null_mesher_level {\n+  template <typename P, typename Z> Mesher_level_conflict_status test_point_conflict_from_superior(P, Z) ;\n+};\n+template < class Tr, class Derived, class Element, class Previous, class Triangulation_traits > struct Mesher_level {\n+  typedef Tr Triangulation;\n+  typedef typename Triangulation::Point Point;\n+  typedef typename Triangulation::Vertex_handle Vertex_handle;\n+  typedef typename Triangulation_traits::Zone Zone;\n+  typedef Previous Previous_level;\n+  Derived& derived() { return static_cast<Derived&>(*this); }\n+  Previous& previous_level;\n+  Mesher_level(Previous_level& previous)\n+    : previous_level(previous)\n+  { }\n+  Vertex_handle insert(Point p, Zone& z) ;\n+  Zone conflicts_zone(const Point& p, Element e) ;\n+  Element get_next_element() ;\n+  template <class Mesh_visitor> void before_insertion(Element& e, const Point& p, Zone& zone, Mesh_visitor visitor) {\n+    visitor.before_insertion(e, p, zone);\n+  }\n+  template <class Mesh_visitor> void after_insertion(Vertex_handle vh, Mesh_visitor visitor) {\n+    derived().after_insertion_impl(vh);\n+  }\n+  template <class Mesh_visitor> void after_no_insertion(const Element& e, const Point& p, Zone& zone, Mesh_visitor visitor) {\n+    visitor.after_no_insertion(e, p, zone);\n+  }\n+  template <class Mesh_visitor> void refine(Mesh_visitor visitor)\n+  {\n+    Element e = get_next_element();\n+    const Mesher_level_conflict_status result = try_to_refine_element(e, visitor);\n+  }\n+  template <class Mesh_visitor> Mesher_level_conflict_status try_to_refine_element(Element e, Mesh_visitor visitor)\n+  {\n+    Point p ;\n+    Zone zone = conflicts_zone(p, e);\n+    const Mesher_level_conflict_status result = test_point_conflict(p, zone);\n+      before_insertion(e, p, zone, visitor);\n+      Vertex_handle v = insert(p, zone);\n+      after_insertion(v, visitor);\n+      after_no_insertion(e, p, zone, visitor);\n+  }\n+  Mesher_level_conflict_status test_point_conflict(const Point& p, Zone& zone)\n+  {\n+    return previous_level.test_point_conflict_from_superior(p, zone);\n+  }\n+};\n+struct Null_mesh_visitor {\n+  template <typename E, typename P, typename Z> void before_insertion(E, P, Z) const {}\n+  template <typename E, typename P, typename Z> void after_no_insertion(E, P, Z) const {}\n+};\n+template <class Tr> struct Triangulation_ref_impl {\n+  Triangulation_ref_impl(Tr& t);\n+};\n+template <typename Tr> struct Triangulation_mesher_level_traits_3\n+: public Triangulation_ref_impl<Tr>\n+{\n+  typedef typename Tr::Facet Facet;\n+  Triangulation_mesher_level_traits_3(Tr& t)\n+    : Triangulation_ref_impl<Tr>(t)\n+  { }\n+  struct Zone {\n+    typedef std::vector<int*> Cells;\n+    typedef std::vector<Facet> Facets;\n+    typedef typename Tr::Locate_type Locate_type;\n+    Locate_type locate_type;\n+    Cells cells;\n+    Facets boundary_facets;\n+    Facets internal_facets;\n+  };\n+};\n+  namespace Surface_mesher {\n+    namespace details {\n+      template <typename Base> struct Triangulation_generator {\n+        typedef typename Base::Complex_2_in_triangulation_3 C2T3;\n+        typedef typename C2T3::Triangulation Triangulation;\n+\ttypedef Triangulation Type;\n+\ttypedef Type type;\n+      };\n+      template <typename Base> struct Facet_generator {\n+        typedef typename Triangulation_generator<Base>::type Tr;\n+\ttypedef typename Tr::Facet Type;\n+\ttypedef Type type;\n+      };\n+      template <typename Base, typename Self, typename Element, typename PreviousLevel = Null_mesher_level> struct Mesher_level_generator {\n+        typedef typename Base::Complex_2_in_triangulation_3 C2T3;\n+        typedef typename C2T3::Triangulation Triangulation;\n+        typedef Triangulation_mesher_level_traits_3<Triangulation> Tr_m_l_traits_3;\n+        typedef Mesher_level <Triangulation, Self, Element, PreviousLevel, Tr_m_l_traits_3> Type;\n+      };\n+    }\n+  template < class C2T3, class Surface_, class SurfaceMeshTraits, class Criteria_ > struct Surface_mesher_base\n+    : public Triangulation_mesher_level_traits_3<typename C2T3::Triangulation>\n+  {\n+    typedef C2T3 Complex_2_in_triangulation_3;\n+    typedef Surface_ Surface;\n+    typedef SurfaceMeshTraits Surface_mesh_traits;\n+    typedef Criteria_ Criteria;\n+    typedef typename C2T3::Triangulation Tr;\n+    typedef typename Tr::Vertex_handle Vertex_handle;\n+    typedef typename Tr::Facet Facet;\n+    Surface_mesher_base (C2T3& co, const Surface& s, const Surface_mesh_traits& mesh_traits, const Criteria& c)\n+: Triangulation_mesher_level_traits_3<Tr>(co.triangulation()), c2t3(co), tr(co.triangulation()), surf(s), meshtraits(mesh_traits), criteria(c)\n+    { }\n+    C2T3& c2t3;\n+    Tr& tr;\n+    const Surface& surf;\n+    const Surface_mesh_traits& meshtraits;\n+    const Criteria& criteria;\n+    void after_insertion_impl(const Vertex_handle& v) {\n+\tafter_insertion_handle_opposite_facet (Facet ());\n+\tafter_insertion_handle_incident_facet (Facet ());\n+    }\n+    void after_insertion_handle_incident_facet (const Facet& f) {\n+      tr.is_infinite(f) ;\n+      new_facet<false>(f);\n+    }\n+    template <bool remove_from_complex_if_not_in_restricted_Delaunay> void new_facet (const Facet& f) ;\n+    void after_insertion_handle_opposite_facet (const Facet& f) {\n+      after_insertion_handle_incident_facet (f);\n+    }\n+  };\n+  template < typename Base, typename Element = typename details::Facet_generator<Base>::type, typename PreviousLevel = Null_mesher_level, Verbose_flag verbose = NOT_VERBOSE > struct Surface_mesher\n+    : public Base , public details::Mesher_level_generator< Base, Surface_mesher<Base, Element, PreviousLevel, verbose>, Element, PreviousLevel >::Type\n+  {\n+    typedef typename Base::Complex_2_in_triangulation_3 C2T3;\n+    typedef typename Base::Surface Surface;\n+    typedef typename Base::Criteria Criteria;\n+    typedef typename Base::Surface_mesh_traits Surface_mesh_traits;\n+    typedef typename details::Mesher_level_generator< Base, Surface_mesher<Base, Element, PreviousLevel, verbose>, Element, PreviousLevel >::Type Mesher_lvl;\n+    using Mesher_lvl::refine;\n+    Null_mesher_level null_mesher_level;\n+    Null_mesh_visitor null_visitor;\n+    bool initialized;\n+    Surface_mesher(C2T3& c2t3, const Surface& surface, const Surface_mesh_traits& mesh_traits, const Criteria& criteria)\n+      : Base(c2t3, surface, mesh_traits, criteria), Mesher_lvl(null_mesher_level), initialized(false)\n+    { }\n+    void refine_mesh () {\n+      refine(null_visitor);\n+    }\n+  };\n+  }\n+template <typename Surface> struct Surface_mesh_traits_generator_3 {\n+  typedef typename Surface::Surface_mesher_traits_3 Type;\n+  typedef Type type;\n+};\n+template < class Tr, typename Edge_info_ = void > struct Complex_2_in_triangulation_3 {\n+  typedef Tr Triangulation;\n+  Triangulation& triangulation();\n+};\n+template <class Tr> struct Surface_mesh_complex_2_in_triangulation_3\n+: public Complex_2_in_triangulation_3<Tr>\n+{ };\n+  struct Non_manifold_tag {};\n+  template < typename C2T3, typename SurfaceMeshTraits_3, typename Criteria, typename Tag > struct Make_surface_mesh_helper {\n+    typedef Surface_mesher::Surface_mesher_base< C2T3, typename SurfaceMeshTraits_3::Surface_3, SurfaceMeshTraits_3, Criteria> Mesher_base;\n+  };\n+  template <typename C2T3, typename SurfaceMeshTraits_3, typename Criteria, typename Tag, Surface_mesher::Verbose_flag verbosity = Surface_mesher::NOT_VERBOSE > struct Surface_mesher_generator {\n+    typedef typename Make_surface_mesh_helper< C2T3, SurfaceMeshTraits_3, Criteria, Tag>::Mesher_base Mesher_base;\n+    typedef Surface_mesher::Surface_mesher< Mesher_base, typename Surface_mesher::details::Facet_generator<Mesher_base>::type, Null_mesher_level, verbosity> Mesher;\n+    typedef Mesher type;\n+  };\n+template <typename C2T3, typename SurfaceMeshTraits_3, typename Criteria> void make_surface_mesh(C2T3& c2t3, const typename SurfaceMeshTraits_3::Surface_3& surface, const SurfaceMeshTraits_3& surface_mesh_traits, const Criteria& criteria) {\n+  typedef typename Surface_mesher_generator< C2T3, SurfaceMeshTraits_3, Criteria, Non_manifold_tag, Surface_mesher::NOT_VERBOSE >::type Mesher;\n+  Mesher mesher(c2t3, surface, surface_mesh_traits, criteria);\n+  mesher.refine_mesh();\n+}\n+template <class Kernel> struct Surface_mesh_triangulation_generator_3 {\n+  typedef CGAL::Triangulation_data_structure_3 Tds;\n+  typedef CGAL::Delaunay_triangulation_3<Kernel, Tds> Type;\n+};\n+  namespace Surface_mesher {\n+  namespace { struct Return_min { }; }\n+  template < class GT, class Surface, class Unused = Return_min > struct Implicit_surface_oracle_3 {\n+    typedef Surface Surface_3;\n+  };\n+  }\n+  template< typename GT> struct Implicit_surface_3 {\n+    typedef GT Geom_traits;\n+    typedef Implicit_surface_3<Geom_traits > Self;\n+    typedef Surface_mesher::Implicit_surface_oracle_3< Geom_traits, Self> Surface_mesher_traits_3;\n+  };\n+}\n+struct K {\n+struct Point_3 {\n+CGAL::Lazy_exact_nt<double> a[3];\n+};\n+};\n+typedef CGAL::Surface_mesh_triangulation_generator_3<K>::Type Tr;\n+typedef CGAL::Surface_mesh_complex_2_in_triangulation_3<Tr> C2T3;\n+typedef CGAL::Implicit_surface_3<K > Surface;\n+typedef CGAL::Surface_mesh_traits_generator_3<Surface>::type Traits;\n+void f() {\n+\tC2T3 c2t3 ;\n+\tCGAL::make_surface_mesh(c2t3, Surface(), Traits(), 3);\n+}"}, {"sha": "52df2bef72ef7cfce6768fc1f4fe3534c75a04a9", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/280fedf0677108f96d3c701815bccc182eff9fb4/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/280fedf0677108f96d3c701815bccc182eff9fb4/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=280fedf0677108f96d3c701815bccc182eff9fb4", "patch": "@@ -10947,10 +10947,10 @@ get_binfo_at_offset (tree binfo, HOST_WIDE_INT offset, tree expected_type)\n       tree fld;\n       int i;\n \n-      gcc_checking_assert (offset >= 0);\n       if (type == expected_type)\n \t  return binfo;\n-      if (TREE_CODE (type) != RECORD_TYPE)\n+      if (TREE_CODE (type) != RECORD_TYPE\n+\t  || offset < 0)\n \treturn NULL_TREE;\n \n       for (fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))"}]}