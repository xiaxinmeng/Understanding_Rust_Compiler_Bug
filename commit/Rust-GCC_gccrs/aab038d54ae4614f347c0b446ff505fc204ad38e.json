{"sha": "aab038d54ae4614f347c0b446ff505fc204ad38e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFiMDM4ZDU0YWU0NjE0ZjM0N2MwYjQ0NmZmNTA1ZmMyMDRhZDM4ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-03-30T01:35:15Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-03-30T01:35:15Z"}, "message": "re PR c/20519 (completed type not selected properly with typeof)\n\n        PR c/20519\n        * c-decl.c (c_finish_incomplete_decl): Update complete_array_type call.\n        (build_compound_literal): Likewise.  Propagate decl type into the\n        initializer.\n        (finish_decl): Likewise.  Use new return value from complete_array_type\n        for zero sized arrays.\n        (complete_array_type): Move ...\n        * c-common.c (complete_array_type): ... here.  Change first argument\n        to pointer-to-type-node.  Consistently use sizetype for the index\n        except for zero sized arrays.  Detect zero sized arrays for pedantic\n        mode diagnostics.  Create a new type node instead of modifying the\n        old node in place.\n        * c-tree.h (complete_array_type): Move decl ...\n        * c-common.h (complete_array_type): ... here.\ncp/\n        * decl.c (cp_complete_array_type): Rename from complete_array_type.\n        Use the new complete_array_type in c-common.c.  Update all callers.\n        * cp-tree.h (cp_complete_array_type): Update to match.\n\nFrom-SVN: r97223", "tree": {"sha": "c268ffdf655de9176ff5a95683d1e4bfc230ad87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c268ffdf655de9176ff5a95683d1e4bfc230ad87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aab038d54ae4614f347c0b446ff505fc204ad38e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aab038d54ae4614f347c0b446ff505fc204ad38e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aab038d54ae4614f347c0b446ff505fc204ad38e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aab038d54ae4614f347c0b446ff505fc204ad38e/comments", "author": null, "committer": null, "parents": [{"sha": "748e31c32624a6da22db9330601faf19aaf24f05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/748e31c32624a6da22db9330601faf19aaf24f05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/748e31c32624a6da22db9330601faf19aaf24f05"}], "stats": {"total": 311, "additions": 150, "deletions": 161}, "files": [{"sha": "fbd8351723a4084c69b23f83e5fbc7da39369482", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab038d54ae4614f347c0b446ff505fc204ad38e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab038d54ae4614f347c0b446ff505fc204ad38e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aab038d54ae4614f347c0b446ff505fc204ad38e", "patch": "@@ -1,3 +1,20 @@\n+2005-03-29  Richard Henderson  <rth@redhat.com>\n+\n+\tPR c/20519\n+\t* c-decl.c (c_finish_incomplete_decl): Update complete_array_type call.\n+\t(build_compound_literal): Likewise.  Propagate decl type into the\n+\tinitializer.\n+\t(finish_decl): Likewise.  Use new return value from complete_array_type\n+\tfor zero sized arrays.\n+\t(complete_array_type): Move ...\n+\t* c-common.c (complete_array_type): ... here.  Change first argument\n+\tto pointer-to-type-node.  Consistently use sizetype for the index\n+\texcept for zero sized arrays.  Detect zero sized arrays for pedantic\n+\tmode diagnostics.  Create a new type node instead of modifying the\n+\told node in place.\n+\t* c-tree.h (complete_array_type): Move decl ...\n+\t* c-common.h (complete_array_type): ... here.\n+\n 2005-03-29  Richard Henderson  <rth@redhat.com>\n \n \tPR tree-opt/19108"}, {"sha": "5705f4d1eb282f76476d30990a236910fbb51b60", "filename": "gcc/c-common.c", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab038d54ae4614f347c0b446ff505fc204ad38e/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab038d54ae4614f347c0b446ff505fc204ad38e/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=aab038d54ae4614f347c0b446ff505fc204ad38e", "patch": "@@ -5756,5 +5756,94 @@ lvalue_error (enum lvalue_use use)\n       gcc_unreachable ();\n     }\n }\n+\f\n+/* *PTYPE is an incomplete array.  Complete it with a domain based on\n+   INITIAL_VALUE.  If INITIAL_VALUE is not present, use 1 if DO_DEFAULT\n+   is true.  Return 0 if successful, 1 if INITIAL_VALUE can't be deciphered,\n+   2 if INITIAL_VALUE was NULL, and 3 if INITIAL_VALUE was empty.  */\n+\n+int\n+complete_array_type (tree *ptype, tree initial_value, bool do_default)\n+{\n+  tree maxindex, type, main_type, elt, unqual_elt;\n+  int failure = 0, quals;\n+\n+  maxindex = size_zero_node;\n+  if (initial_value)\n+    {\n+      if (TREE_CODE (initial_value) == STRING_CST)\n+\t{\n+\t  int eltsize\n+\t    = int_size_in_bytes (TREE_TYPE (TREE_TYPE (initial_value)));\n+\t  maxindex = size_int (TREE_STRING_LENGTH (initial_value)/eltsize - 1);\n+\t}\n+      else if (TREE_CODE (initial_value) == CONSTRUCTOR)\n+\t{\n+\t  tree elts = CONSTRUCTOR_ELTS (initial_value);\n+\n+\t  if (elts == NULL)\n+\t    {\n+\t      if (pedantic)\n+\t\tfailure = 3;\n+\t      maxindex = integer_minus_one_node;\n+\t    }\n+\t  else\n+\t    {\n+\t      tree curindex;\n+\n+\t      if (TREE_PURPOSE (elts))\n+\t\tmaxindex = fold_convert (sizetype, TREE_PURPOSE (elts));\n+\t      curindex = maxindex;\n+\n+\t      for (elts = TREE_CHAIN (elts); elts; elts = TREE_CHAIN (elts))\n+\t\t{\n+\t\t  if (TREE_PURPOSE (elts))\n+\t\t    curindex = fold_convert (sizetype, TREE_PURPOSE (elts));\n+\t\t  else\n+\t\t    curindex = size_binop (PLUS_EXPR, curindex, size_one_node);\n+\n+\t\t  if (tree_int_cst_lt (maxindex, curindex))\n+\t\t    maxindex = curindex;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Make an error message unless that happened already.  */\n+\t  if (initial_value != error_mark_node)\n+\t    failure = 1;\n+\t}\n+    }\n+  else\n+    {\n+      failure = 2;\n+      if (!do_default)\n+\treturn failure;\n+    }\n+\n+  type = *ptype;\n+  elt = TREE_TYPE (type);\n+  quals = TYPE_QUALS (strip_array_types (elt));\n+  if (quals == 0)\n+    unqual_elt = elt;\n+  else\n+    unqual_elt = c_build_qualified_type (elt, TYPE_UNQUALIFIED);\n+\n+  /* Using build_distinct_type_copy and modifying things afterward instead\n+     of using build_array_type to create a new type preserves all of the\n+     TYPE_LANG_FLAG_? bits that the front end may have set.  */\n+  main_type = build_distinct_type_copy (TYPE_MAIN_VARIANT (type));\n+  TREE_TYPE (main_type) = unqual_elt;\n+  TYPE_DOMAIN (main_type) = build_index_type (maxindex);\n+  layout_type (main_type);\n+\n+  if (quals == 0)\n+    type = main_type;\n+  else\n+    type = c_build_qualified_type (main_type, quals);\n+\n+  *ptype = type;\n+  return failure;\n+}\n \n #include \"gt-c-common.h\""}, {"sha": "7794adedbeb57ab6e0fb2f48e4be9a32794d2ed4", "filename": "gcc/c-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab038d54ae4614f347c0b446ff505fc204ad38e/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab038d54ae4614f347c0b446ff505fc204ad38e/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=aab038d54ae4614f347c0b446ff505fc204ad38e", "patch": "@@ -888,6 +888,8 @@ enum lvalue_use {\n \n extern void lvalue_error (enum lvalue_use);\n \n+extern int complete_array_type (tree *, tree, bool);\n+\n /* In c-gimplify.c  */\n extern void c_genericize (tree);\n extern int c_gimplify_expr (tree *, tree *, tree *);"}, {"sha": "cc45e26c2fd586359880193d1cfd6c2b6981c17d", "filename": "gcc/c-decl.c", "status": "modified", "additions": 14, "deletions": 80, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab038d54ae4614f347c0b446ff505fc204ad38e/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab038d54ae4614f347c0b446ff505fc204ad38e/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=aab038d54ae4614f347c0b446ff505fc204ad38e", "patch": "@@ -529,7 +529,7 @@ c_finish_incomplete_decl (tree decl)\n \t{\n \t  warning (\"%Jarray %qD assumed to have one element\", decl, decl);\n \n-\t  complete_array_type (type, NULL_TREE, 1);\n+\t  complete_array_type (&TREE_TYPE (decl), NULL_TREE, true);\n \n \t  layout_decl (decl, 0);\n \t}\n@@ -3168,14 +3168,15 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n       && TYPE_DOMAIN (type) == 0\n       && TREE_CODE (decl) != TYPE_DECL)\n     {\n-      int do_default\n+      bool do_default\n \t= (TREE_STATIC (decl)\n \t   /* Even if pedantic, an external linkage array\n \t      may have incomplete type at first.  */\n \t   ? pedantic && !TREE_PUBLIC (decl)\n \t   : !DECL_EXTERNAL (decl));\n       int failure\n-\t= complete_array_type (type, DECL_INITIAL (decl), do_default);\n+\t= complete_array_type (&TREE_TYPE (decl), DECL_INITIAL (decl),\n+\t\t\t       do_default);\n \n       /* Get the completed type made by complete_array_type.  */\n       type = TREE_TYPE (decl);\n@@ -3196,14 +3197,12 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t  else if (!pedantic && TREE_STATIC (decl) && !TREE_PUBLIC (decl))\n \t    DECL_EXTERNAL (decl) = 1;\n \t}\n-\n-      /* TYPE_MAX_VALUE is always one less than the number of elements\n-\t in the array, because we start counting at zero.  Therefore,\n-\t warn only if the value is less than zero.  */\n-      else if (pedantic && TYPE_DOMAIN (type) != 0\n-\t       && tree_int_cst_sgn (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) < 0)\n+      else if (failure == 3)\n \terror (\"%Jzero or negative size array %qD\", decl, decl);\n \n+      if (DECL_INITIAL (decl))\n+\tTREE_TYPE (DECL_INITIAL (decl)) = type;\n+\n       layout_decl (decl, 0);\n     }\n \n@@ -3491,17 +3490,19 @@ build_compound_literal (tree type, tree init)\n \n   if (TREE_CODE (type) == ARRAY_TYPE && !COMPLETE_TYPE_P (type))\n     {\n-      int failure = complete_array_type (type, DECL_INITIAL (decl), 1);\n-      \n+      int failure = complete_array_type (&TREE_TYPE (decl),\n+\t\t\t\t\t DECL_INITIAL (decl), true);\n       gcc_assert (!failure);\n+\n+      type = TREE_TYPE (decl);\n+      TREE_TYPE (DECL_INITIAL (decl)) = type;\n     }\n \n-  type = TREE_TYPE (decl);\n   if (type == error_mark_node || !COMPLETE_TYPE_P (type))\n     return error_mark_node;\n \n   stmt = build_stmt (DECL_EXPR, decl);\n-  complit = build1 (COMPOUND_LITERAL_EXPR, TREE_TYPE (decl), stmt);\n+  complit = build1 (COMPOUND_LITERAL_EXPR, type, stmt);\n   TREE_SIDE_EFFECTS (complit) = 1;\n \n   layout_decl (decl, 0);\n@@ -3527,73 +3528,6 @@ build_compound_literal (tree type, tree init)\n   return complit;\n }\n \f\n-/* Make TYPE a complete type based on INITIAL_VALUE.\n-   Return 0 if successful, 1 if INITIAL_VALUE can't be deciphered,\n-   2 if there was no information (in which case assume 1 if DO_DEFAULT).  */\n-\n-int\n-complete_array_type (tree type, tree initial_value, int do_default)\n-{\n-  tree maxindex = NULL_TREE;\n-  int value = 0;\n-\n-  if (initial_value)\n-    {\n-      /* Note MAXINDEX  is really the maximum index,\n-\t one less than the size.  */\n-      if (TREE_CODE (initial_value) == STRING_CST)\n-\t{\n-\t  int eltsize\n-\t    = int_size_in_bytes (TREE_TYPE (TREE_TYPE (initial_value)));\n-\t  maxindex = build_int_cst (NULL_TREE,\n-\t\t\t\t    (TREE_STRING_LENGTH (initial_value)\n-\t\t\t\t     / eltsize) - 1);\n-\t}\n-      else if (TREE_CODE (initial_value) == CONSTRUCTOR)\n-\t{\n-\t  tree elts = CONSTRUCTOR_ELTS (initial_value);\n-\t  maxindex = build_int_cst (NULL_TREE, -1);\n-\t  for (; elts; elts = TREE_CHAIN (elts))\n-\t    {\n-\t      if (TREE_PURPOSE (elts))\n-\t\tmaxindex = TREE_PURPOSE (elts);\n-\t      else\n-\t\tmaxindex = fold (build2 (PLUS_EXPR, integer_type_node,\n-\t\t\t\t\t maxindex, integer_one_node));\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Make an error message unless that happened already.  */\n-\t  if (initial_value != error_mark_node)\n-\t    value = 1;\n-\n-\t  /* Prevent further error messages.  */\n-\t  maxindex = build_int_cst (NULL_TREE, 0);\n-\t}\n-    }\n-\n-  if (!maxindex)\n-    {\n-      if (do_default)\n-\tmaxindex = build_int_cst (NULL_TREE, 0);\n-      value = 2;\n-    }\n-\n-  if (maxindex)\n-    {\n-      TYPE_DOMAIN (type) = build_index_type (maxindex);\n-      \n-      gcc_assert (TREE_TYPE (maxindex));\n-    }\n-\n-  /* Lay out the type now that we can get the real answer.  */\n-\n-  layout_type (type);\n-\n-  return value;\n-}\n-\f\n /* Determine whether TYPE is a structure with a flexible array member,\n    or a union containing such a structure (possibly recursively).  */\n "}, {"sha": "41b624ec5b777a5b264c88a4c09487f2b5d74eb7", "filename": "gcc/c-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab038d54ae4614f347c0b446ff505fc204ad38e/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab038d54ae4614f347c0b446ff505fc204ad38e/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=aab038d54ae4614f347c0b446ff505fc204ad38e", "patch": "@@ -378,7 +378,6 @@ extern struct c_declarator *build_array_declarator (tree, struct c_declspecs *,\n extern tree build_enumerator (tree, tree);\n extern void check_for_loop_decls (void);\n extern void mark_forward_parm_decls (void);\n-extern int  complete_array_type (tree, tree, int);\n extern void declare_parm_level (void);\n extern void undeclared_variable (tree, location_t);\n extern tree declare_label (tree);"}, {"sha": "859be9d0d39e8cbca6d253620134c0a48e8807d8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab038d54ae4614f347c0b446ff505fc204ad38e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab038d54ae4614f347c0b446ff505fc204ad38e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=aab038d54ae4614f347c0b446ff505fc204ad38e", "patch": "@@ -1,3 +1,10 @@\n+2005-03-29  Richard Henderson  <rth@redhat.com>\n+\n+\tPR c/20519\n+\t* decl.c (cp_complete_array_type): Rename from complete_array_type.\n+\tUse the new complete_array_type in c-common.c.  Update all callers.\n+\t* cp-tree.h (cp_complete_array_type): Update to match.\n+\n 2005-03-24  Geoffrey Keating  <geoffk@apple.com>\n \n \t* typeck.c (build_static_cast_1): Allow scalar_cast between"}, {"sha": "ac025d676749b0ff94d4771bf103419ada13c6d2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab038d54ae4614f347c0b446ff505fc204ad38e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab038d54ae4614f347c0b446ff505fc204ad38e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=aab038d54ae4614f347c0b446ff505fc204ad38e", "patch": "@@ -3787,7 +3787,7 @@ extern tree start_decl\t\t\t\t(const cp_declarator *, cp_decl_specifier_seq *, int,\n extern void start_decl_1\t\t\t(tree);\n extern void cp_finish_decl\t\t\t(tree, tree, tree, int);\n extern void finish_decl\t\t\t\t(tree, tree, tree);\n-extern int complete_array_type\t\t\t(tree, tree, int);\n+extern int cp_complete_array_type\t\t(tree *, tree, bool);\n extern tree build_ptrmemfunc_type\t\t(tree);\n extern tree build_ptrmem_type                   (tree, tree);\n /* the grokdeclarator prototype is in decl.h */"}, {"sha": "eef2cb1744af11051fbedea623d1f5574369faec", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 17, "deletions": 77, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab038d54ae4614f347c0b446ff505fc204ad38e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab038d54ae4614f347c0b446ff505fc204ad38e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=aab038d54ae4614f347c0b446ff505fc204ad38e", "patch": "@@ -3913,7 +3913,8 @@ maybe_deduce_size_from_array_init (tree decl, tree init)\n \t But let's leave it here to ease the eventual merge.  */\n       int do_default = !DECL_EXTERNAL (decl);\n       tree initializer = init ? init : DECL_INITIAL (decl);\n-      int failure = complete_array_type (type, initializer, do_default);\n+      int failure = cp_complete_array_type (&TREE_TYPE (decl), initializer,\n+\t\t\t\t\t    do_default);\n \n       if (failure == 1)\n \terror (\"initializer fails to determine size of %qD\", decl);\n@@ -5331,102 +5332,41 @@ expand_static_init (tree decl, tree init)\n    3 if the initializer list is empty (in pedantic mode). */\n \n int\n-complete_array_type (tree type, tree initial_value, int do_default)\n+cp_complete_array_type (tree *ptype, tree initial_value, bool do_default)\n {\n-  tree maxindex = NULL_TREE;\n-  int value = 0;\n+  int failure;\n+  tree type, elt_type;\n \n   if (initial_value)\n     {\n       /* An array of character type can be initialized from a\n \t brace-enclosed string constant.  */\n-      if (char_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (type)))\n+      if (char_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (*ptype)))\n \t  && TREE_CODE (initial_value) == CONSTRUCTOR\n \t  && CONSTRUCTOR_ELTS (initial_value)\n \t  && (TREE_CODE (TREE_VALUE (CONSTRUCTOR_ELTS (initial_value)))\n \t      == STRING_CST)\n \t  && TREE_CHAIN (CONSTRUCTOR_ELTS (initial_value)) == NULL_TREE)\n \tinitial_value = TREE_VALUE (CONSTRUCTOR_ELTS (initial_value));\n-\n-      /* Note MAXINDEX is really the maximum index, one less than the\n-\t size.  */\n-      if (TREE_CODE (initial_value) == STRING_CST)\n-\t{\n-\t  int eltsize\n-\t    = int_size_in_bytes (TREE_TYPE (TREE_TYPE (initial_value)));\n-\t  maxindex = build_int_cst (NULL_TREE,\n-\t\t\t\t    (TREE_STRING_LENGTH (initial_value)\n-\t\t\t\t     / eltsize) - 1);\n-\t}\n-      else if (TREE_CODE (initial_value) == CONSTRUCTOR)\n-\t{\n-\t  tree elts = CONSTRUCTOR_ELTS (initial_value);\n-\n-\t  maxindex = ssize_int (-1);\n-\t  for (; elts; elts = TREE_CHAIN (elts))\n-\t    {\n-\t      if (TREE_PURPOSE (elts))\n-\t\tmaxindex = TREE_PURPOSE (elts);\n-\t      else\n-\t\tmaxindex = size_binop (PLUS_EXPR, maxindex, ssize_int (1));\n-\t    }\n-\n-\t  if (pedantic && tree_int_cst_equal (maxindex, ssize_int (-1)))\n-\t    value = 3;\n-\t}\n-      else\n-\t{\n-\t  /* Make an error message unless that happened already.  */\n-\t  if (initial_value != error_mark_node)\n-\t    value = 1;\n-\t  else\n-\t    initial_value = NULL_TREE;\n-\n-\t  /* Prevent further error messages.  */\n-\t  maxindex = build_int_cst (NULL_TREE, 0);\n-\t}\n     }\n \n-  if (!maxindex)\n-    {\n-      if (do_default)\n-\tmaxindex = build_int_cst (NULL_TREE, 0);\n-      value = 2;\n-    }\n+  failure = complete_array_type (ptype, initial_value, do_default);\n \n-  if (maxindex)\n+  /* We can create the array before the element type is complete, which\n+     means that we didn't have these two bits set in the original type\n+     either.  In completing the type, we are expected to propagate these\n+     bits.  See also complete_type which does the same thing for arrays\n+     of fixed size.  */\n+  type = *ptype;\n+  if (TYPE_DOMAIN (type))\n     {\n-      tree itype;\n-      tree domain;\n-      tree elt_type;\n-\n-      domain = build_index_type (maxindex);\n-      TYPE_DOMAIN (type) = domain;\n-\n-      if (initial_value)\n-        itype = TREE_TYPE (initial_value);\n-      else\n-\titype = NULL;\n-      if (itype && !TYPE_DOMAIN (itype))\n-\tTYPE_DOMAIN (itype) = domain;\n-      /* The type of the main variant should never be used for arrays\n-\t of different sizes.  It should only ever be completed with the\n-\t size of the array.  */\n-      if (! TYPE_DOMAIN (TYPE_MAIN_VARIANT (type)))\n-\tTYPE_DOMAIN (TYPE_MAIN_VARIANT (type)) = domain;\n-\n       elt_type = TREE_TYPE (type);\n-      TYPE_NEEDS_CONSTRUCTING (type)\n-\t= TYPE_NEEDS_CONSTRUCTING (TYPE_MAIN_VARIANT (elt_type));\n+      TYPE_NEEDS_CONSTRUCTING (type) = TYPE_NEEDS_CONSTRUCTING (elt_type);\n       TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type)\n-\t= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TYPE_MAIN_VARIANT (elt_type));\n+\t= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (elt_type);\n     }\n \n-  /* Lay out the type now that we can get the real answer.  */\n-\n-  layout_type (type);\n-\n-  return value;\n+  return failure;\n }\n \f\n /* Return zero if something is declared to be a member of type"}, {"sha": "07f614bedd34fb08408ddb3b056541ac82cd2efe", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab038d54ae4614f347c0b446ff505fc204ad38e/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab038d54ae4614f347c0b446ff505fc204ad38e/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=aab038d54ae4614f347c0b446ff505fc204ad38e", "patch": "@@ -1996,7 +1996,8 @@ finish_compound_literal (tree type, tree initializer_list)\n \n \t implies that the array has two elements.  */\n       if (TREE_CODE (type) == ARRAY_TYPE && !COMPLETE_TYPE_P (type))\n-\tcomplete_array_type (type, compound_literal, 1);\n+\tcp_complete_array_type (&TREE_TYPE (compound_literal),\n+\t\t\t\tcompound_literal, 1);\n     }\n \n   return compound_literal;"}, {"sha": "daa23993425d5259fddf73eaadcd0db2206a46f5", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab038d54ae4614f347c0b446ff505fc204ad38e/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab038d54ae4614f347c0b446ff505fc204ad38e/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=aab038d54ae4614f347c0b446ff505fc204ad38e", "patch": "@@ -1123,7 +1123,7 @@ process_init_constructor (tree type, tree init, tree* elts)\n \n   result = build_constructor (type, nreverse (members));\n   if (TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type) == NULL_TREE)\n-    complete_array_type (type, result, /*do_default=*/0);\n+    cp_complete_array_type (&TREE_TYPE (result), result, /*do_default=*/0);\n   if (init)\n     TREE_HAS_CONSTRUCTOR (result) = TREE_HAS_CONSTRUCTOR (init);\n   if (allconstant)"}]}