{"sha": "e833f686bb246d02dda9096653214ba657f460ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgzM2Y2ODZiYjI0NmQwMmRkYTkwOTY2NTMyMTRiYTY1N2Y0NjBiYQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-10-06T13:15:23Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-10-06T13:15:23Z"}, "message": "[C++ PATCH] use hash-table for namespace contents\n\nhttps://gcc.gnu.org/ml/gcc-patches/2017-10/msg00365.html\n\tUse hash_table for namespace bindings\n\t* cp-tree.h (struct named_decl_hash): New.\n\t(lang_decl_ns): Change type of bindings field.\n\t* lex.c (maybe_add_lang_decl_raw): Adjust.\n\t* name-lookup.c (find_namespace_slot): Adjust.\n\t(do_pushdecl): Push NULL-named namespace.\n\t(do_push_nested_namespace): Adjust.\n\t(push_namespace): Push anonymous namespace as NULL name.\n\nFrom-SVN: r253489", "tree": {"sha": "ec27346a76f573bc6c24d7ac5544092399bac9c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec27346a76f573bc6c24d7ac5544092399bac9c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e833f686bb246d02dda9096653214ba657f460ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e833f686bb246d02dda9096653214ba657f460ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e833f686bb246d02dda9096653214ba657f460ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e833f686bb246d02dda9096653214ba657f460ba/comments", "author": null, "committer": null, "parents": [{"sha": "816f83cfb7a82a48945384942c32c87659d4ad06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/816f83cfb7a82a48945384942c32c87659d4ad06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/816f83cfb7a82a48945384942c32c87659d4ad06"}], "stats": {"total": 91, "additions": 62, "deletions": 29}, "files": [{"sha": "ef053a51cd4dc0276ec0f1ce90f5eda7dc7daa4f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e833f686bb246d02dda9096653214ba657f460ba/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e833f686bb246d02dda9096653214ba657f460ba/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e833f686bb246d02dda9096653214ba657f460ba", "patch": "@@ -1,5 +1,17 @@\n+2017-10-06  Nathan Sidwell  <nathan@acm.org>\n+\n+\tUse hash_table for namespace bindings\n+\t* cp-tree.h (struct named_decl_hash): New.\n+\t(lang_decl_ns): Change type of bindings field.\n+\t* lex.c (maybe_add_lang_decl_raw): Adjust.\n+\t* name-lookup.c (find_namespace_slot): Adjust.\n+\t(do_pushdecl): Push NULL-named namespace.\n+\t(do_push_nested_namespace): Adjust.\n+\t(push_namespace): Push anonymous namespace as NULL name.\n+\n 2017-10-05  Jason Merrill  <jason@redhat.com>\n \n+\tPass variadic class objects exactly like named by-value args.\n \t* call.c (convert_arg_to_ellipsis): Use the result of force_rvalue.\n \n 2017-10-05  Nathan Sidwell  <nathan@acm.org>"}, {"sha": "cac5f3ddc4e3068fb71825e25a867179665aec8b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e833f686bb246d02dda9096653214ba657f460ba/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e833f686bb246d02dda9096653214ba657f460ba/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e833f686bb246d02dda9096653214ba657f460ba", "patch": "@@ -828,6 +828,25 @@ class lkp_iterator : public ovl_iterator\n   }\n };\n \n+/* hash traits for declarations.  Hashes potential overload sets via\n+   DECL_NAME.  */\n+\n+struct named_decl_hash : ggc_remove <tree>\n+{\n+  typedef tree value_type; /* A DECL or OVERLOAD  */\n+  typedef tree compare_type; /* An identifier.  */\n+\n+  inline static hashval_t hash (const value_type decl);\n+  inline static bool equal (const value_type existing, compare_type candidate);\n+\n+  static inline void mark_empty (value_type &p) {p = NULL_TREE;}\n+  static inline bool is_empty (value_type p) {return !p;}\n+\n+  /* Nothing is deletable.  Everything is insertable.  */\n+  static bool is_deleted (value_type) { return false; }\n+  static void mark_deleted (value_type) { gcc_unreachable (); }\n+};\n+\n struct GTY(()) tree_template_decl {\n   struct tree_decl_common common;\n   tree arguments;\n@@ -2548,10 +2567,10 @@ struct GTY(()) lang_decl_ns {\n   vec<tree, va_gc> *usings;\n   vec<tree, va_gc> *inlinees;\n \n-  /* Map from IDENTIFIER nodes to DECLS.  It'd be nice to have this\n-     inline, but as the hash_map has a dtor, we can't then put this\n-     struct into a union (until moving to c++11).  */\n-  hash_map<lang_identifier *, tree> *bindings;\n+  /* Hash table of bound decls. It'd be nice to have this inline, but\n+     as the hash_map has a dtor, we can't then put this struct into a\n+     union (until moving to c++11).  */\n+  hash_table<named_decl_hash> *bindings;\n };\n \n /* DECL_LANG_SPECIFIC for parameters.  */\n@@ -7370,6 +7389,20 @@ type_unknown_p (const_tree expr)\n   return TREE_TYPE (expr) == unknown_type_node;\n }\n \n+inline hashval_t\n+named_decl_hash::hash (const value_type decl)\n+{\n+  tree name = OVL_NAME (decl);\n+  return name ? IDENTIFIER_HASH_VALUE (name) : 0;\n+}\n+\n+inline bool\n+named_decl_hash::equal (const value_type existing, compare_type candidate)\n+{\n+  tree name = OVL_NAME (existing);\n+  return candidate == name;\n+}\n+\n /* -- end of C++ */\n \n #endif /* ! GCC_CP_TREE_H */"}, {"sha": "fd93401f9a672cd329a8792acad0a895e6dc7683", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e833f686bb246d02dda9096653214ba657f460ba/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e833f686bb246d02dda9096653214ba657f460ba/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=e833f686bb246d02dda9096653214ba657f460ba", "patch": "@@ -651,7 +651,7 @@ maybe_add_lang_decl_raw (tree t, bool decomp_p)\n \n   if (sel == lds_ns)\n     /* Who'd create a namespace, only to put nothing in it?  */\n-    ld->u.ns.bindings = hash_map<lang_identifier *, tree>::create_ggc (499);\n+    ld->u.ns.bindings = hash_table<named_decl_hash>::create_ggc (499);\n \n   if (GATHER_STATISTICS)\n     {"}, {"sha": "84f7381cc6f74cb444b97defa086e7305cca82a6", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e833f686bb246d02dda9096653214ba657f460ba/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e833f686bb246d02dda9096653214ba657f460ba/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=e833f686bb246d02dda9096653214ba657f460ba", "patch": "@@ -86,17 +86,9 @@ create_local_binding (cp_binding_level *level, tree name)\n static tree *\n find_namespace_slot (tree ns, tree name, bool create_p = false)\n {\n-  tree *slot;\n-\n-  if (create_p)\n-    {\n-      bool existed;\n-      slot = &DECL_NAMESPACE_BINDINGS (ns)->get_or_insert (name, &existed);\n-      if (!existed)\n-\t*slot = NULL_TREE;\n-    }\n-  else\n-    slot = DECL_NAMESPACE_BINDINGS (ns)->get (name);\n+  tree *slot = DECL_NAMESPACE_BINDINGS (ns)\n+    ->find_slot_with_hash (name, name ? IDENTIFIER_HASH_VALUE (name) : 0,\n+\t\t\t   create_p ? INSERT : NO_INSERT);\n   return slot;\n }\n \n@@ -2950,7 +2942,10 @@ do_pushdecl (tree decl, bool is_friend)\n   while (level->kind == sk_class)\n     level = level->level_chain;\n \n-  if (tree name = DECL_NAME (decl))\n+  /* An anonymous namespace has a NULL DECL_NAME, but we still want to\n+     insert it.  Other NULL-named decls, not so much.  */\n+  tree name = DECL_NAME (decl);\n+  if (name || TREE_CODE (decl) == NAMESPACE_DECL)\n     {\n       cxx_binding *binding = NULL; /* Local scope binding.  */\n       tree ns = NULL_TREE; /* Searched namespace.  */\n@@ -6615,9 +6610,7 @@ do_push_nested_namespace (tree ns)\n     {\n       do_push_nested_namespace (CP_DECL_CONTEXT (ns));\n       gcc_checking_assert\n-\t(find_namespace_value (current_namespace,\n-\t\t\t       DECL_NAME (ns) ? DECL_NAME (ns)\n-\t\t\t       : anon_identifier) == ns);\n+\t(find_namespace_value (current_namespace, DECL_NAME (ns)) == ns);\n       resume_scope (NAMESPACE_LEVEL (ns));\n       current_namespace = ns;\n     }\n@@ -6775,10 +6768,7 @@ push_namespace (tree name, bool make_inline)\n   /* We should not get here if the global_namespace is not yet constructed\n      nor if NAME designates the global namespace:  The global scope is\n      constructed elsewhere.  */\n-  gcc_assert (global_namespace != NULL && name != global_identifier);\n-\n-  if (!name)\n-    name = anon_identifier;\n+  gcc_checking_assert (global_namespace != NULL && name != global_identifier);\n \n   tree ns = NULL_TREE;\n   {\n@@ -6824,11 +6814,9 @@ push_namespace (tree name, bool make_inline)\n \tns = NULL_TREE;\n       else\n \t{\n-\t  if (name == anon_identifier)\n+\t  if (!name)\n \t    {\n-\t      /* Clear DECL_NAME for the benefit of debugging back ends.  */\n-\t      SET_DECL_ASSEMBLER_NAME (ns, name);\n-\t      DECL_NAME (ns) = NULL_TREE;\n+\t      SET_DECL_ASSEMBLER_NAME (ns, anon_identifier);\n \n \t      if (!make_inline)\n \t\tadd_using_namespace (DECL_NAMESPACE_USING (current_namespace),\n@@ -6843,7 +6831,7 @@ push_namespace (tree name, bool make_inline)\n \t      vec_safe_push (DECL_NAMESPACE_INLINEES (current_namespace), ns);\n \t    }\n \n-\t  if (name == anon_identifier || make_inline)\n+\t  if (!name || make_inline)\n \t    emit_debug_info_using_namespace (current_namespace, ns, true);\n \t}\n     }"}]}