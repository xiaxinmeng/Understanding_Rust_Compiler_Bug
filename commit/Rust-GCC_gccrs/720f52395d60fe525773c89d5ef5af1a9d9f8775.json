{"sha": "720f52395d60fe525773c89d5ef5af1a9d9f8775", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzIwZjUyMzk1ZDYwZmU1MjU3NzNjODlkNWVmNWFmMWE5ZDlmODc3NQ==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2010-07-04T08:54:52Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2010-07-04T08:54:52Z"}, "message": "tm.texi.in (TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST): Document new arguments.\n\n\n\t* doc/tm.texi.in (TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST):\n\tDocument new arguments.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.c (default_builtin_vectorization_cost): Add new arguments.\n\tHandle unaligned store.\n\t* targhooks.h (default_builtin_vectorization_cost): Add new arguments.\n\t* target.def (builtin_vectorization_cost): Add new arguments.\n\t* target.h (enum vect_cost_for_stmt): Add unaligned_store.\n\t* tree-vect-loop-manip.c (vect_gen_niters_for_prolog_loop): Take number\n\tof iterations of prolog loop directly from LOOP_PEELING_FOR_ALIGNMENT.\n\t(vect_vfa_segment_size): Fix indentation.\n\t* tree-vectorizer.h (struct _vect_peel_info): New.\n\t(struct _vect_peel_extended_info): New.\n\t(struct _loop_vec_info): Add new field for peeling hash table and a\n\tmacro for its access.\n\t(VECT_MAX_COST): Define.\n\t(vect_get_load_cost): Declare.\n\t(vect_get_store_cost, vect_get_known_peeling_cost, \n\tvect_get_single_scalar_iteraion_cost): Likewise.\n\t(vect_supportable_dr_alignment): Add new argument.\n\t* tree-vect-loop.c (new_loop_vec_info): Initialize peeling hash table\n\tfield.\n\t(destroy_loop_vec_info): Free peeling hash table.\n\t(vect_analyze_loop_form): Update call to builtin_vectorization_cost.\n\t(vect_analyze_loop): Move vect_enhance_data_refs_alignment before\n\tvect_analyze_slp. Fix indentation.\n\t(vect_get_single_scalar_iteraion_cost): New function.\n\t(vect_get_known_peeling_cost): Likewise.\n\t(vect_estimate_min_profitable_iters): Rename byte_misalign to npeel. \n\tCall vect_get_single_scalar_iteraion_cost instead of cost_for_stmt per \n\tstatement. Move outside cost calculation inside unknown peeling case.\n\tCall vect_get_known_peeling_cost for known amount of peeling.\n\t* tree-vect-data-refs.c (vect_compute_data_ref_alignment): Add data\n\treference to the print message of forced alignment.\n\t(vect_verify_datarefs_alignment): Update call to \n\tvect_supportable_dr_alignment.\n\t(vect_get_data_access_cost): New function.\n\t(vect_peeling_hash, vect_peeling_hash_eq, vect_peeling_hash_insert,\n\tvect_peeling_hash_get_most_frequent, vect_peeling_hash_get_lowest_cost,\n\tvect_peeling_hash_choose_best_peeling): Likewise.\n\t(vect_enhance_data_refs_alignment): Fix documentation. Use hash table\n\tto store all the accesses in the loop and find best possible access to\n\talign using peeling for known alignment case. For unknown alignment\n\tcheck if stores are preferred or if peeling is worthy.\n\t(vect_find_same_alignment_drs): Analyze pairs of loads too.\n\t(vect_supportable_dr_alignment): Add new argument and check aligned\n\taccesses according to it. \n\t* tree-vect-stmts.c (vect_get_stmt_cost): New function.\n\t(cost_for_stmt): Call vect_get_stmt_cost. \n\t(vect_model_simple_cost): Likewise.\n\t(vect_model_store_cost): Call vect_get_stmt_cost. Call \n\tvect_get_store_cost to calculate the cost of the statement.\n\t(vect_get_store_cost): New function.\n\t(vect_model_load_cost): Call vect_get_stmt_cost. Call \n\tvect_get_load_cost to calculate the cost of the statement.\n\t(vect_get_load_cost): New function.\n\t(vectorizable_store): Update call to vect_supportable_dr_alignment.\n\t(vectorizable_load): Likewise.\n\t* config/spu/spu.c (spu_builtin_vectorization_cost): Add new\n\targuments. \n\t* config/i386/i386.c (ix86_builtin_vectorization_cost): Add new\n\targuments. Handle unaligned store.\n\t* config/rs6000/rs6000.c (rs6000_builtin_vectorization_cost): New.\n\t(rs6000_builtin_support_vector_misalignment): Return true for word and\n\tdouble word alignments for VSX.\n\t* tree-vect-slp.c (vect_build_slp_tree): Update calls to \n\tvect_supportable_dr_alignment and builtin_vectorization_cost.\n\n\nCo-Authored-By: Revital Eres <eres@il.ibm.com>\n\nFrom-SVN: r161797", "tree": {"sha": "41c5db85c09ecda0974c98361603bea7b34ea3fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41c5db85c09ecda0974c98361603bea7b34ea3fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/720f52395d60fe525773c89d5ef5af1a9d9f8775", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/720f52395d60fe525773c89d5ef5af1a9d9f8775", "html_url": "https://github.com/Rust-GCC/gccrs/commit/720f52395d60fe525773c89d5ef5af1a9d9f8775", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/720f52395d60fe525773c89d5ef5af1a9d9f8775/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "addced2e927eda87577e45f388378cf30bc2d15d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/addced2e927eda87577e45f388378cf30bc2d15d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/addced2e927eda87577e45f388378cf30bc2d15d"}], "stats": {"total": 1372, "additions": 1176, "deletions": 196}, "files": [{"sha": "c69bc6ce812b0b6607a1dbb45acdbc9231617622", "filename": "gcc/ChangeLog", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -1,3 +1,74 @@\n+2010-07-04  Ira Rosen  <irar@il.ibm.com>\n+\t    Revital Eres  <eres@il.ibm.com>\n+\n+\t* doc/tm.texi.in (TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST): \n+\tDocument new arguments.\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.c (default_builtin_vectorization_cost): Add new arguments.\n+\tHandle unaligned store.\n+\t* targhooks.h (default_builtin_vectorization_cost): Add new arguments.\n+\t* target.def (builtin_vectorization_cost): Add new arguments.\n+\t* target.h (enum vect_cost_for_stmt): Add unaligned_store.\n+\t* tree-vect-loop-manip.c (vect_gen_niters_for_prolog_loop): Take number\n+\tof iterations of prolog loop directly from LOOP_PEELING_FOR_ALIGNMENT.\n+\t(vect_vfa_segment_size): Fix indentation.\n+\t* tree-vectorizer.h (struct _vect_peel_info): New.\n+\t(struct _vect_peel_extended_info): New.\n+\t(struct _loop_vec_info): Add new field for peeling hash table and a\n+\tmacro for its access.\n+\t(VECT_MAX_COST): Define.\n+\t(vect_get_load_cost): Declare.\n+\t(vect_get_store_cost, vect_get_known_peeling_cost, \n+\tvect_get_single_scalar_iteraion_cost): Likewise.\n+\t(vect_supportable_dr_alignment): Add new argument.\n+\t* tree-vect-loop.c (new_loop_vec_info): Initialize peeling hash table\n+\tfield.\n+\t(destroy_loop_vec_info): Free peeling hash table.\n+\t(vect_analyze_loop_form): Update call to builtin_vectorization_cost.\n+\t(vect_analyze_loop): Move vect_enhance_data_refs_alignment before\n+\tvect_analyze_slp. Fix indentation.\n+\t(vect_get_single_scalar_iteraion_cost): New function.\n+\t(vect_get_known_peeling_cost): Likewise.\n+\t(vect_estimate_min_profitable_iters): Rename byte_misalign to npeel. \n+\tCall vect_get_single_scalar_iteraion_cost instead of cost_for_stmt per \n+\tstatement. Move outside cost calculation inside unknown peeling case.\n+\tCall vect_get_known_peeling_cost for known amount of peeling.\n+\t* tree-vect-data-refs.c (vect_compute_data_ref_alignment): Add data\n+\treference to the print message of forced alignment.\n+\t(vect_verify_datarefs_alignment): Update call to \n+\tvect_supportable_dr_alignment.\n+\t(vect_get_data_access_cost): New function.\n+\t(vect_peeling_hash, vect_peeling_hash_eq, vect_peeling_hash_insert,\n+\tvect_peeling_hash_get_most_frequent, vect_peeling_hash_get_lowest_cost,\n+\tvect_peeling_hash_choose_best_peeling): Likewise.\n+\t(vect_enhance_data_refs_alignment): Fix documentation. Use hash table\n+\tto store all the accesses in the loop and find best possible access to\n+\talign using peeling for known alignment case. For unknown alignment\n+\tcheck if stores are preferred or if peeling is worthy.\n+\t(vect_find_same_alignment_drs): Analyze pairs of loads too.\n+\t(vect_supportable_dr_alignment): Add new argument and check aligned\n+\taccesses according to it. \n+\t* tree-vect-stmts.c (vect_get_stmt_cost): New function.\n+\t(cost_for_stmt): Call vect_get_stmt_cost. \n+\t(vect_model_simple_cost): Likewise.\n+\t(vect_model_store_cost): Call vect_get_stmt_cost. Call \n+\tvect_get_store_cost to calculate the cost of the statement.\n+\t(vect_get_store_cost): New function.\n+\t(vect_model_load_cost): Call vect_get_stmt_cost. Call \n+\tvect_get_load_cost to calculate the cost of the statement.\n+\t(vect_get_load_cost): New function.\n+\t(vectorizable_store): Update call to vect_supportable_dr_alignment.\n+\t(vectorizable_load): Likewise.\n+\t* config/spu/spu.c (spu_builtin_vectorization_cost): Add new\n+\targuments. \n+\t* config/i386/i386.c (ix86_builtin_vectorization_cost): Add new\n+\targuments. Handle unaligned store.\n+\t* config/rs6000/rs6000.c (rs6000_builtin_vectorization_cost): New.\n+\t(rs6000_builtin_support_vector_misalignment): Return true for word and\n+\tdouble word alignments for VSX.\n+\t* tree-vect-slp.c (vect_build_slp_tree): Update calls to \n+\tvect_supportable_dr_alignment and builtin_vectorization_cost.\n+\n 2010-07-03  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR target/44597"}, {"sha": "711fc166ad4a81d1fa85752ef8ba7d3c12a7ba62", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -29376,7 +29376,9 @@ static const struct attribute_spec ix86_attribute_table[] =\n \n /* Implement targetm.vectorize.builtin_vectorization_cost.  */\n static int\n-ix86_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost)\n+ix86_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n+                                 tree vectype ATTRIBUTE_UNUSED,\n+                                 int misalign ATTRIBUTE_UNUSED)\n {\n   switch (type_of_cost)\n     {\n@@ -29405,6 +29407,7 @@ ix86_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost)\n         return ix86_cost->scalar_to_vec_cost;\n \n       case unaligned_load:\n+      case unaligned_store:\n         return ix86_cost->vec_unalign_load_cost;\n \n       case cond_branch_taken:"}, {"sha": "45bc2306182649329069f4442f182bf6c77b42bd", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 114, "deletions": 2, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -1075,6 +1075,8 @@ static bool rs6000_builtin_support_vector_misalignment (enum\n \t\t\t\t\t\t\tmachine_mode,\n \t\t\t\t\t\t\tconst_tree,\n \t\t\t\t\t\t\tint, bool);\n+static int rs6000_builtin_vectorization_cost (enum vect_cost_for_stmt,\n+                                              tree, int);\n \n static void def_builtin (int, const char *, tree, int);\n static bool rs6000_vector_alignment_reachable (const_tree, bool);\n@@ -1467,6 +1469,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n   rs6000_builtin_support_vector_misalignment\n #undef TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE\n #define TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE rs6000_vector_alignment_reachable\n+#undef TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\n+#define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST \\\n+  rs6000_builtin_vectorization_cost\n \n #undef TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS rs6000_init_builtins\n@@ -3333,12 +3338,19 @@ rs6000_builtin_support_vector_misalignment (enum machine_mode mode,\n \n       if (misalignment == -1)\n \t{\n-\t  /* misalignment factor is unknown at compile time but we know\n+\t  /* Misalignment factor is unknown at compile time but we know\n \t     it's word aligned.  */\n \t  if (rs6000_vector_alignment_reachable (type, is_packed))\n-\t    return true;\n+            {\n+              int element_size = TREE_INT_CST_LOW (TYPE_SIZE (type));\n+\n+              if (element_size == 64 || element_size == 32)\n+               return true;\n+            }\n+\n \t  return false;\n \t}\n+\n       /* VSX supports word-aligned vector.  */\n       if (misalignment % 4 == 0)\n \treturn true;\n@@ -3404,6 +3416,106 @@ rs6000_builtin_vec_perm (tree type, tree *mask_element_type)\n   return d;\n }\n \n+\n+/* Implement targetm.vectorize.builtin_vectorization_cost.  */\n+static int\n+rs6000_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n+                                   tree vectype, int misalign)\n+{\n+  unsigned elements;\n+\n+  switch (type_of_cost)\n+    {\n+      case scalar_stmt:\n+      case scalar_load:\n+      case scalar_store:\n+      case vector_stmt:\n+      case vector_load:\n+      case vector_store:\n+      case vec_to_scalar:\n+      case scalar_to_vec:\n+      case cond_branch_not_taken:\n+      case vec_perm:\n+        return 1;\n+\n+      case cond_branch_taken:\n+        return 3;\n+\n+      case unaligned_load:\n+        if (TARGET_VSX && TARGET_ALLOW_MOVMISALIGN)\n+          {\n+            elements = TYPE_VECTOR_SUBPARTS (vectype);\n+            if (elements == 2)\n+              /* Double word aligned.  */\n+              return 2;\n+\n+            if (elements == 4)\n+              {\n+                switch (misalign)\n+                  {\n+                    case 8:\n+                      /* Double word aligned.  */\n+                      return 2;\n+\n+                    case -1:\n+                      /* Unknown misalignment.  */\n+                    case 4:\n+                    case 12:\n+                      /* Word aligned.  */\n+                      return 22;\n+\n+                    default:\n+                      gcc_unreachable ();\n+                  }\n+              }\n+          }\n+\n+        if (TARGET_ALTIVEC)\n+          /* Misaligned loads are not supported.  */\n+          gcc_unreachable ();\n+\n+        return 2;\n+\n+      case unaligned_store:\n+        if (TARGET_VSX && TARGET_ALLOW_MOVMISALIGN)\n+          {\n+            elements = TYPE_VECTOR_SUBPARTS (vectype);\n+            if (elements == 2)\n+              /* Double word aligned.  */\n+              return 2;\n+\n+            if (elements == 4)\n+              {\n+                switch (misalign)\n+                  {\n+                    case 8:\n+                      /* Double word aligned.  */\n+                      return 2;\n+\n+                    case -1:\n+                      /* Unknown misalignment.  */\n+                    case 4:\n+                    case 12:\n+                      /* Word aligned.  */\n+                      return 23;\n+\n+                    default:\n+                      gcc_unreachable ();\n+                  }\n+              }\n+          }\n+\n+        if (TARGET_ALTIVEC)\n+          /* Misaligned stores are not supported.  */\n+          gcc_unreachable ();\n+\n+        return 2;\n+\n+      default:\n+        gcc_unreachable ();\n+    }\n+}\n+\n /* Handle generic options of the form -mfoo=yes/no.\n    NAME is the option name.\n    VALUE is the option value."}, {"sha": "3d4f58705451456b411bdc8ae9502ffa8a132c21", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -209,7 +209,7 @@ static rtx spu_addr_space_legitimize_address (rtx, rtx, enum machine_mode,\n static tree spu_builtin_mul_widen_even (tree);\n static tree spu_builtin_mul_widen_odd (tree);\n static tree spu_builtin_mask_for_load (void);\n-static int spu_builtin_vectorization_cost (enum vect_cost_for_stmt);\n+static int spu_builtin_vectorization_cost (enum vect_cost_for_stmt, tree, int);\n static bool spu_vector_alignment_reachable (const_tree, bool);\n static tree spu_builtin_vec_perm (tree, tree *);\n static enum machine_mode spu_addr_space_pointer_mode (addr_space_t);\n@@ -6694,7 +6694,9 @@ spu_builtin_mask_for_load (void)\n \n /* Implement targetm.vectorize.builtin_vectorization_cost.  */\n static int \n-spu_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost)\n+spu_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n+                                tree vectype ATTRIBUTE_UNUSED,\n+                                int misalign ATTRIBUTE_UNUSED)\n {\n   switch (type_of_cost)\n     {"}, {"sha": "17b582f77b2311f666fed1619868013c5be1337c", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -5706,8 +5706,10 @@ preserved (e.g.@: used only by a reduction computation). Otherwise, the\n @code{widen_mult_hi/lo} idioms will be used.\n @end deftypefn\n \n-@deftypefn {Target Hook} int TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST (enum vect_cost_for_stmt @var{type_of_cost})\n+@deftypefn {Target Hook} int TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST (enum vect_cost_for_stmt @var{type_of_cost}, tree @var{vectype}, int @var{misalign})\n Returns cost of different scalar or vector statements for vectorization cost model.\n+For vector memory operations the cost may depend on type (@var{vectype}) and \n+misalignment value (@var{misalign}).\n @end deftypefn\n \n @deftypefn {Target Hook} bool TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE (const_tree @var{type}, bool @var{is_packed})"}, {"sha": "e79341d5db52981f476b900fc6ffc97fbed5c61b", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -5708,6 +5708,8 @@ preserved (e.g.@: used only by a reduction computation). Otherwise, the\n \n @hook TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\n Returns cost of different scalar or vector statements for vectorization cost model.\n+For vector memory operations the cost may depend on type (@var{vectype}) and \n+misalignment value (@var{misalign}).\n @end deftypefn\n \n @hook TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE"}, {"sha": "627092537f16ed07b41899f534f23f132281c939", "filename": "gcc/target.def", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -789,11 +789,13 @@ DEFHOOK\n  \"\",\n  tree, (tree x), NULL)\n \n-/* Cost of different vector/scalar statements in vectorization cost model.  */\n+/* Cost of different vector/scalar statements in vectorization cost\n+   model. In case of misaligned vector loads and stores the cost depends\n+   on the data type and misalignment value.  */\n DEFHOOK\n (builtin_vectorization_cost,\n  \"\",\n- int, (enum vect_cost_for_stmt type_of_cost),\n+ int, (enum vect_cost_for_stmt type_of_cost, tree vectype, int misalign),\n  default_builtin_vectorization_cost)\n \n /* Return true if vector alignment is reachable (by peeling N"}, {"sha": "99dd1eea99871eed4ae5194828a05f2f91f42bb1", "filename": "gcc/target.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -119,6 +119,7 @@ enum vect_cost_for_stmt\n   vector_stmt,\n   vector_load,\n   unaligned_load,\n+  unaligned_store,\n   vector_store,\n   vec_to_scalar,\n   scalar_to_vec,"}, {"sha": "1a49f0c1a5e0f04ecb1cfa47c7ff8e2137799e17", "filename": "gcc/targhooks.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -479,7 +479,9 @@ default_builtin_vectorized_conversion (unsigned int code ATTRIBUTE_UNUSED,\n /* Default vectorizer cost model values.  */\n \n int\n-default_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost)\n+default_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n+                                    tree vectype ATTRIBUTE_UNUSED,\n+                                    int misalign ATTRIBUTE_UNUSED)\n {\n   switch (type_of_cost)\n     {\n@@ -496,6 +498,7 @@ default_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost)\n         return 1;\n \n       case unaligned_load:\n+      case unaligned_store:\n         return 2;\n \n       case cond_branch_taken:"}, {"sha": "eb4b547aad0c9114f40cbbfcc80a4db1de5661ee", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -77,7 +77,7 @@ extern tree default_builtin_vectorized_function (tree, tree, tree);\n \n extern tree default_builtin_vectorized_conversion (unsigned int, tree, tree);\n \n-extern int default_builtin_vectorization_cost (enum vect_cost_for_stmt);\n+extern int default_builtin_vectorization_cost (enum vect_cost_for_stmt, tree, int);\n \n extern tree default_builtin_reciprocal (unsigned int, bool, bool);\n "}, {"sha": "5ae6c6ebe4f3e70c51fbc6f50bc0005b2d3a1475", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -1,3 +1,20 @@\n+2010-07-04  Ira Rosen  <irar@il.ibm.com>\n+\t    Revital Eres  <eres@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect-42.c: Don't expect peeling on targets that support\n+\tmisaligned stores.\n+\t* gcc.dg/vect/vect-60.c, gcc.dg/vect/vect-56.c, gcc.dg/vect/vect-93.c,\n+\tgcc.dg/vect/vect-96.c: Likewise.\n+\t* gcc.dg/vect/vect-109.c: Expect vectorization only on targets that\t\n+\tthat support misaligned stores. Change the number of expected \n+\tmisaligned accesses.\n+\t* gcc.dg/vect/vect-peel-1.c: New test.\n+\t* gcc.dg/vect/vect-peel-2.c, gcc.dg/vect/vect-peel-3.c, \n+\tgcc.dg/vect/vect-peel-4.c: Likewise.\n+\t* gcc.dg/vect/vect-multitypes-1.c: Change the test to make it \n+\tvectorizable on all targets that support realignment.\n+\t* gcc.dg/vect/vect-multitypes-4.c: Likewise. \t\n+\n 2010-07-03  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR c/44806"}, {"sha": "ddba2635bffc72c62c30a917c4741f4179ec7a2b", "filename": "gcc/testsuite/gcc.dg/vect/vect-109.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-109.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-109.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-109.c?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -72,8 +72,8 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_hw_misalign } } } */\n /* { dg-final { scan-tree-dump-times \"not vectorized: unsupported unaligned store\" 2 \"vect\" { xfail vect_hw_misalign } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 10 \"vect\" { target vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 3 \"vect\" { target vect_hw_misalign } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "fa8320086983732ce84960f7ccdfe87c1510ea69", "filename": "gcc/testsuite/gcc.dg/vect/vect-42.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-42.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-42.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-42.c?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -65,6 +65,7 @@ int main (void)\n /* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 3 \"vect\" { target vect_no_align } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target { { ! vector_alignment_reachable } && { ! vect_hw_misalign } } } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 4 \"vect\" { xfail { vect_no_align || { ! vector_alignment_reachable } } } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align || { ! vector_alignment_reachable } } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 4 \"vect\" { xfail { vect_no_align || { { !  vector_alignment_reachable } || vect_hw_misalign  } } } } }  */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 3 \"vect\" { target vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align || { { ! vector_alignment_reachable } || vect_hw_misalign } } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "1555d41df6fbdd59a099733840b7d56a990f7b6c", "filename": "gcc/testsuite/gcc.dg/vect/vect-56.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-56.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-56.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-56.c?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -68,6 +68,8 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align } } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { target { vect_hw_misalign } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" { xfail { vect_hw_misalign } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { target { vect_hw_misalign } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ba8ffe65400a3c10e714c26414c473dacfa6e31c", "filename": "gcc/testsuite/gcc.dg/vect/vect-60.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-60.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-60.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-60.c?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -69,6 +69,8 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align } } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { target { vect_hw_misalign } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" { xfail { vect_hw_misalign } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { target { vect_hw_misalign } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "dfb98cfd541519606d2d5d2f4f6d1955ce5198ac", "filename": "gcc/testsuite/gcc.dg/vect/vect-93.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-93.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-93.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-93.c?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -72,7 +72,7 @@ int main (void)\n /* main && main1 together: */\n /* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 2 \"vect\" { target powerpc*-*-* i?86-*-* x86_64-*-* } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { target { vect_no_align && {! vector_alignment_reachable} } } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" { xfail { { vect_no_align } || {! vector_alignment_reachable} } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" { xfail { { vect_no_align } || { { ! vector_alignment_reachable} || vect_hw_misalign } } } } } */\n \n /* in main1: */\n /* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { target !powerpc*-*-* !i?86-*-* !x86_64-*-* } } } */"}, {"sha": "c7dea6123a84e3927bfec593872d9d7016b3c268", "filename": "gcc/testsuite/gcc.dg/vect/vect-96.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-96.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-96.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-96.c?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -44,6 +44,6 @@ int main (void)\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { target { {! vect_no_align} && vector_alignment_reachable } } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { { vect_no_align } || {! vector_alignment_reachable} } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { { vect_no_align } || { { ! vector_alignment_reachable} || vect_hw_misalign } } } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 1 \"vect\" { target { vect_no_align || { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "7981c4a475f4b98e00c1667a0cf4db24e4b3d87c", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-1.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-1.c?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -27,13 +27,13 @@ __attribute__ ((noinline)) int main1 (int n)\n   for (i = 0; i < n; i++)\n     {\n       sa[i+7] = sb[i];\n-      ia[i+3] = ib[i];\n+      ia[i+3] = ib[i+1];\n     }\n \n   /* check results:  */\n   for (i = 0; i < n; i++)\n     {\n-      if (sa[i+7] != sb[i] || ia[i+3] != ib[i])\n+      if (sa[i+7] != sb[i] || ia[i+3] != ib[i+1])\n \tabort ();\n     }\n \n@@ -44,7 +44,9 @@ __attribute__ ((noinline)) int main1 (int n)\n    access for peeling, and therefore will examine the option of\n    using a peeling factor = (V-3)%V = 1 for V=2,4. \n    This will not align the access 'sa[i+3]' (for which we need to\n-   peel 5 iterations), so the loop can not be vectorized.  */\n+   peel 5 iterations). However, 'ia[i+3]' also gets aligned if we peel 5\n+   iterations, so the loop is vectorizable on all targets that support\n+   unaligned loads.  */\n \n __attribute__ ((noinline)) int main2 (int n)\n {\n@@ -55,13 +57,13 @@ __attribute__ ((noinline)) int main2 (int n)\n   for (i = 0; i < n; i++)\n     {\n       ia[i+3] = ib[i];\n-      sa[i+3] = sb[i];\n+      sa[i+3] = sb[i+1];\n     }\n \n   /* check results:  */\n   for (i = 0; i < n; i++)\n     {\n-      if (sa[i+3] != sb[i] || ia[i+3] != ib[i])\n+      if (sa[i+3] != sb[i+1] || ia[i+3] != ib[i])\n         abort ();\n     }\n \n@@ -78,11 +80,8 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail {! vect_hw_misalign} } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail {! vect_hw_misalign} } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 4 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail { vect_no_align } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail { vect_no_align } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 4 \"vect\" { xfail { vect_no_align } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "3a83491065fb685e6b5ac4136d9ed0cab2fcabca", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-4.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-4.c?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -20,7 +20,9 @@ unsigned int ib[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,\n    access for peeling, and therefore will examine the option of\n    using a peeling factor = VF-7%VF. This will result in a peeling factor 1,\n    which will also align the access to 'ia[i+3]', and the loop could be\n-   vectorized on all targets that support unaligned loads.  */\n+   vectorized on all targets that support unaligned loads.\n+   Without cost model on targets that support misaligned stores, no peeling\n+   will be applied since we want to keep the four loads aligned.  */\n \n __attribute__ ((noinline))\n int main1 (int n)\n@@ -50,7 +52,11 @@ int main1 (int n)\n    using a peeling factor = VF-3%VF. This will result in a peeling factor\n    1 if VF=4,2. This will not align the access to 'sa[i+3]', for which we \n    need to peel 5,1 iterations for VF=4,2 respectively, so the loop can not \n-   be vectorized.  */\n+   be vectorized.  However, 'ia[i+3]' also gets aligned if we peel 5\n+   iterations, so the loop is vectorizable on all targets that support\n+   unaligned loads.\n+   Without cost model on targets that support misaligned stores, no peeling\n+   will be applied since we want to keep the four loads aligned.  */\n \n __attribute__ ((noinline))\n int main2 (int n)\n@@ -85,11 +91,10 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail {! vect_hw_misalign} } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail {! vect_hw_misalign}  } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 8 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 4 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail { vect_no_align } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" { target { vect_hw_misalign}  } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 8 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 4 \"vect\" { target { vect_hw_misalign  } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "ae7746389d32cf586c7e22b1587e95147099f1c9", "filename": "gcc/testsuite/gcc.dg/vect/vect-peel-1.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-1.c?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128\n+\n+int ib[N+5];\n+\n+__attribute__ ((noinline))\n+int main1 ()\n+{\n+  int i;\n+  int ia[N+1];\n+\n+  /* All the accesses are misaligned. With cost model disabled, we count the \n+     the number of aligned accesses for each peeling option, and in this case\n+     we align the two loads if possible (i.e., if misaligned stores are \n+     supported).  */\n+  for (i = 1; i <= N; i++)\n+    {\n+      ia[i] = ib[i+2] + ib[i+6];\n+    }\n+\n+  /* check results:  */\n+  for (i = 1; i <= N; i++)\n+    {\n+      if (ia[i] != ib[i+2] + ib[i+6])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N+5; i++)\n+    ib[i] = i;\n+\n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail  vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { target vect_hw_misalign  } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail  vect_no_align } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ee7b8dbe62eb4633726c22f790e4963969d1f632", "filename": "gcc/testsuite/gcc.dg/vect/vect-peel-2.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-2.c?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128\n+\n+/* unaligned store.  */\n+\n+int ib[N+5];\n+\n+__attribute__ ((noinline))\n+int main1 ()\n+{\n+  int i;\n+  int ia[N+1];\n+\n+  /* The store is aligned and the loads are misaligned with the same \n+     misalignment. Cost model is disabled. If misaligned stores are supported,\n+     we peel according to the loads to align them.  */\n+  for (i = 0; i <= N; i++)\n+    {\n+      ia[i] = ib[i+2] + ib[i+6];\n+    }\n+\n+  /* check results:  */\n+  for (i = 1; i <= N; i++)\n+    {\n+      if (ia[i] != ib[i+2] + ib[i+6])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N+5; i++)\n+    ib[i] = i;\n+\n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail  vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { target vect_hw_misalign  } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { target vect_hw_misalign } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "80f03c8d8af8806f4d8fab53becb09b85edd4507", "filename": "gcc/testsuite/gcc.dg/vect/vect-peel-3.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-3.c?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128\n+#define RES 21888 \n+\n+/* unaligned store.  */\n+\n+int ib[N+10];\n+int ia[N+10];\n+int ic[N+10];\n+\n+__attribute__ ((noinline))\n+int main1 ()\n+{\n+  int i, suma = 0, sumb = 0, sumc = 0;\n+\n+  /* ib and ic have same misalignment, we peel to align them.  */\n+  for (i = 1; i <= N; i++)\n+    {\n+      suma += ia[i];\n+      sumb += ib[i+6];\n+      sumc += ic[i+2];\n+    }\n+\n+  /* check results:  */\n+  if (suma + sumb + sumc != RES)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N+10; i++)\n+    {\n+      ib[i] = i;\n+      ic[i] = i+2;\n+      ia[i] = i/2;\n+    } \n+\n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "971d02334acf193e92078ec96662d07a183d9c25", "filename": "gcc/testsuite/gcc.dg/vect/vect-peel-4.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-peel-4.c?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128\n+\n+int ib[N+5];\n+\n+__attribute__ ((noinline))\n+int main1 ()\n+{\n+  int i;\n+  int ia[N+1];\n+\n+  /* Don't peel keeping one load and the store aligned.  */\n+  for (i = 0; i <= N; i++)\n+    {\n+      ia[i] = ib[i] + ib[i+6];\n+    }\n+\n+  /* check results:  */\n+  for (i = 1; i <= N; i++)\n+    {\n+      if (ia[i] != ib[i] + ib[i+6])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N+5; i++)\n+    ib[i] = i;\n+\n+  return main1 ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "cf9fab221a0ad172ee55c5a2d82e0a781a1605c7", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 423, "deletions": 39, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -810,7 +810,11 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \t NOTE: This is the only change to the code we make during\n \t the analysis phase, before deciding to vectorize the loop.  */\n       if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"force alignment\");\n+        {\n+          fprintf (vect_dump, \"force alignment of \");\n+          print_generic_expr (vect_dump, ref, TDF_SLIM);\n+        }\n+\n       DECL_ALIGN (base) = TYPE_ALIGN (vectype);\n       DECL_USER_ALIGN (base) = 1;\n     }\n@@ -967,7 +971,7 @@ vect_verify_datarefs_alignment (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n           || !STMT_VINFO_VECTORIZABLE (stmt_info))\n         continue;\n \n-      supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n+      supportable_dr_alignment = vect_supportable_dr_alignment (dr, false);\n       if (!supportable_dr_alignment)\n         {\n           if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n@@ -1061,6 +1065,189 @@ vector_alignment_reachable_p (struct data_reference *dr)\n   return true;\n }\n \n+\n+/* Calculate the cost of the memory access represented by DR.  */\n+\n+static void\n+vect_get_data_access_cost (struct data_reference *dr,\n+                           unsigned int *inside_cost,\n+                           unsigned int *outside_cost)\n+{\n+  gimple stmt = DR_STMT (dr);\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  int nunits = TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info));\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  int ncopies = vf / nunits;\n+  bool supportable_dr_alignment = vect_supportable_dr_alignment (dr, true);\n+\n+  if (!supportable_dr_alignment)\n+    *inside_cost = VECT_MAX_COST;\n+  else\n+    {\n+      if (DR_IS_READ (dr))\n+        vect_get_load_cost (dr, ncopies, true, inside_cost, outside_cost);\n+      else\n+        vect_get_store_cost (dr, ncopies, inside_cost);\n+    }\n+\n+  if (vect_print_dump_info (REPORT_COST))\n+    fprintf (vect_dump, \"vect_get_data_access_cost: inside_cost = %d, \"\n+             \"outside_cost = %d.\", *inside_cost, *outside_cost);\n+}\n+\n+\n+static hashval_t\n+vect_peeling_hash (const void *elem)\n+{\n+  const struct _vect_peel_info *peel_info;\n+\n+  peel_info = (const struct _vect_peel_info *) elem;\n+  return (hashval_t) peel_info->npeel;\n+}\n+\n+\n+static int\n+vect_peeling_hash_eq (const void *elem1, const void *elem2)\n+{\n+  const struct _vect_peel_info *a, *b;\n+\n+  a = (const struct _vect_peel_info *) elem1;\n+  b = (const struct _vect_peel_info *) elem2;\n+  return (a->npeel == b->npeel);\n+}\n+\n+\n+/* Insert DR into peeling hash table with NPEEL as key.  */\n+\n+static void\n+vect_peeling_hash_insert (loop_vec_info loop_vinfo, struct data_reference *dr,\n+                          int npeel)\n+{\n+  struct _vect_peel_info elem, *slot;\n+  void **new_slot;\n+  bool supportable_dr_alignment = vect_supportable_dr_alignment (dr, true);\n+\n+  elem.npeel = npeel;\n+  slot = (vect_peel_info) htab_find (LOOP_VINFO_PEELING_HTAB (loop_vinfo),\n+                                     &elem);\n+  if (slot)\n+    slot->count++;\n+  else\n+    {\n+      slot = XNEW (struct _vect_peel_info);\n+      slot->npeel = npeel;\n+      slot->dr = dr;\n+      slot->count = 1;\n+      new_slot = htab_find_slot (LOOP_VINFO_PEELING_HTAB (loop_vinfo), slot,\n+                                 INSERT);\n+      *new_slot = slot;\n+    }\n+\n+  if (!supportable_dr_alignment && !flag_vect_cost_model)\n+    slot->count += VECT_MAX_COST;\n+}\n+\n+\n+/* Traverse peeling hash table to find peeling option that aligns maximum\n+   number of data accesses.  */\n+\n+static int\n+vect_peeling_hash_get_most_frequent (void **slot, void *data)\n+{\n+  vect_peel_info elem = (vect_peel_info) *slot;\n+  vect_peel_extended_info max = (vect_peel_extended_info) data;\n+\n+  if (elem->count > max->peel_info.count)\n+    {\n+      max->peel_info.npeel = elem->npeel;\n+      max->peel_info.count = elem->count;\n+      max->peel_info.dr = elem->dr;\n+    }\n+\n+  return 1;\n+}\n+\n+\n+/* Traverse peeling hash table and calculate cost for each peeling option. Find\n+   one with the lowest cost.  */\n+\n+static int\n+vect_peeling_hash_get_lowest_cost (void **slot, void *data)\n+{\n+  vect_peel_info elem = (vect_peel_info) *slot;\n+  vect_peel_extended_info min = (vect_peel_extended_info) data;\n+  int save_misalignment, dummy;\n+  unsigned int inside_cost = 0, outside_cost = 0, i;\n+  gimple stmt = DR_STMT (elem->dr);\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  VEC (data_reference_p, heap) *datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+  struct data_reference *dr;\n+\n+  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+    {\n+      stmt = DR_STMT (dr);\n+      stmt_info = vinfo_for_stmt (stmt);\n+      /* For interleaving, only the alignment of the first access\n+         matters.  */\n+      if (STMT_VINFO_STRIDED_ACCESS (stmt_info)\n+          && DR_GROUP_FIRST_DR (stmt_info) != stmt)\n+        continue;\n+\n+      save_misalignment = DR_MISALIGNMENT (dr);\n+      vect_update_misalignment_for_peel (dr, elem->dr, elem->npeel);\n+      vect_get_data_access_cost (dr, &inside_cost, &outside_cost);\n+      SET_DR_MISALIGNMENT (dr, save_misalignment);\n+    }\n+\n+  outside_cost += vect_get_known_peeling_cost (loop_vinfo, elem->npeel, &dummy,\n+                         vect_get_single_scalar_iteraion_cost (loop_vinfo));\n+\n+  if (inside_cost < min->inside_cost\n+      || (inside_cost == min->inside_cost && outside_cost < min->outside_cost))\n+    {\n+      min->inside_cost = inside_cost;\n+      min->outside_cost = outside_cost;\n+      min->peel_info.dr = elem->dr;\n+      min->peel_info.npeel = elem->npeel;\n+    }\n+\n+  return 1;\n+}\n+\n+\n+/* Choose best peeling option by traversing peeling hash table and either\n+   choosing an option with the lowest cost (if cost model is enabled) or the\n+   option that aligns as many accesses as possible.  */\n+\n+static struct data_reference *\n+vect_peeling_hash_choose_best_peeling (loop_vec_info loop_vinfo,\n+                                       unsigned int *npeel)\n+{\n+   struct _vect_peel_extended_info res;\n+\n+   res.peel_info.dr = NULL;\n+\n+   if (flag_vect_cost_model)\n+     {\n+       res.inside_cost = INT_MAX;\n+       res.outside_cost = INT_MAX;\n+       htab_traverse (LOOP_VINFO_PEELING_HTAB (loop_vinfo),\n+                      vect_peeling_hash_get_lowest_cost, &res);\n+     }\n+   else\n+     {\n+       res.peel_info.count = 0;\n+       htab_traverse (LOOP_VINFO_PEELING_HTAB (loop_vinfo),\n+                      vect_peeling_hash_get_most_frequent, &res);\n+     }\n+\n+   *npeel = res.peel_info.npeel;\n+   return res.peel_info.dr;\n+}\n+\n+\n /* Function vect_enhance_data_refs_alignment\n \n    This pass will use loop versioning and loop peeling in order to enhance\n@@ -1158,15 +1345,21 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   VEC (data_reference_p, heap) *datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   enum dr_alignment_support supportable_dr_alignment;\n-  struct data_reference *dr0 = NULL;\n+  struct data_reference *dr0 = NULL, *first_store = NULL;\n   struct data_reference *dr;\n-  unsigned int i;\n+  unsigned int i, j;\n   bool do_peeling = false;\n   bool do_versioning = false;\n   bool stat;\n   gimple stmt;\n   stmt_vec_info stmt_info;\n   int vect_versioning_for_alias_required;\n+  unsigned int npeel = 0;\n+  bool all_misalignments_unknown = true;\n+  unsigned int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  unsigned possible_npeel_number = 1;\n+  tree vectype;\n+  unsigned int nelements, mis, same_align_drs_max = 0;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_enhance_data_refs_alignment ===\");\n@@ -1201,12 +1394,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n      - How many accesses will become unaligned due to the peeling,\n        and the cost of misaligned accesses.\n      - The cost of peeling (the extra runtime checks, the increase\n-       in code size).\n-\n-     The scheme we use FORNOW: peel to force the alignment of the first\n-     unsupported misaligned access in the loop.\n-\n-     TODO: Use a cost model.  */\n+       in code size).  */\n \n   for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n     {\n@@ -1219,15 +1407,108 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n           && DR_GROUP_FIRST_DR (stmt_info) != stmt)\n         continue;\n \n-      if (!DR_IS_READ (dr) && !aligned_access_p (dr))\n+      supportable_dr_alignment = vect_supportable_dr_alignment (dr, true);\n+      do_peeling = vector_alignment_reachable_p (dr);\n+      if (do_peeling)\n         {\n-\t  do_peeling = vector_alignment_reachable_p (dr);\n-\t  if (do_peeling)\n-\t    dr0 = dr;\n-\t  if (!do_peeling && vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"vector alignment may not be reachable\");\n-\t  break;\n-\t}\n+          if (known_alignment_for_access_p (dr))\n+            {\n+              unsigned int npeel_tmp;\n+\n+              /* Save info about DR in the hash table.  */\n+              if (!LOOP_VINFO_PEELING_HTAB (loop_vinfo))\n+                LOOP_VINFO_PEELING_HTAB (loop_vinfo) =\n+                           htab_create (1, vect_peeling_hash,\n+                                        vect_peeling_hash_eq, free);\n+\n+              vectype = STMT_VINFO_VECTYPE (stmt_info);\n+              nelements = TYPE_VECTOR_SUBPARTS (vectype);\n+              mis = DR_MISALIGNMENT (dr) / GET_MODE_SIZE (TYPE_MODE (\n+                                                TREE_TYPE (DR_REF (dr))));\n+              npeel_tmp = (nelements - mis) % vf;\n+\n+              /* For multiple types, it is possible that the bigger type access\n+                 will have more than one peeling option. E.g., a loop with two\n+                 types: one of size (vector size / 4), and the other one of\n+                 size (vector size / 8). Vectorization factor will 8. If both\n+                 access are misaligned by 3, the first one needs one scalar\n+                 iteration to be aligned, and the second one needs 5. But the\n+                 the first one will be aligned also by peeling 5 scalar\n+                 iterations, and in that case both accesses will be aligned.\n+                 Hence, except for the immediate peeling amount, we also want\n+                 to try to add full vector size, while we don't exceed\n+                 vectorization factor.\n+                 We do this automtically for cost model, since we calculate cost\n+                 for every peeling option.  */\n+              if (!flag_vect_cost_model)\n+                possible_npeel_number = vf /nelements;\n+\n+              /* Handle the aligned case. We may decide to align some other\n+                 access, making DR unaligned.  */\n+              if (DR_MISALIGNMENT (dr) == 0)\n+                {\n+                  npeel_tmp = 0;\n+                  if (!flag_vect_cost_model)\n+                    possible_npeel_number++;\n+                }\n+\n+              for (j = 0; j < possible_npeel_number; j++)\n+                {\n+                  gcc_assert (npeel_tmp <= vf);\n+                  vect_peeling_hash_insert (loop_vinfo, dr, npeel_tmp);\n+                  npeel_tmp += nelements;\n+                }\n+\n+              all_misalignments_unknown = false;\n+              /* Data-ref that was chosen for the case that all the\n+                 misalignments are unknown is not relevant anymore, since we\n+                 have a data-ref with known alignment.  */\n+              dr0 = NULL;\n+            }\n+          else\n+            {\n+              /* If we don't know all the misalignment values, we prefer\n+                 peeling for data-ref that has maximum number of data-refs\n+                 with the same alignment, unless the target prefers to align\n+                 stores over load.  */\n+              if (all_misalignments_unknown)\n+                {\n+                  if (same_align_drs_max  < VEC_length (dr_p,\n+                                       STMT_VINFO_SAME_ALIGN_REFS (stmt_info))\n+                      || !dr0)\n+                    {\n+                      same_align_drs_max = VEC_length (dr_p,\n+                                       STMT_VINFO_SAME_ALIGN_REFS (stmt_info));\n+                      dr0 = dr;\n+                    }\n+\n+                  if (!first_store && !DR_IS_READ (dr))\n+                    first_store = dr;\n+                }\n+\n+              /* If there are both known and unknown misaligned accesses in the\n+                 loop, we choose peeling amount according to the known\n+                 accesses.  */\n+\n+\n+              if (!supportable_dr_alignment)\n+                {\n+                  dr0 = dr;\n+                  if (!first_store && !DR_IS_READ (dr))\n+                    first_store = dr;\n+                }\n+            }\n+        }\n+      else\n+        {\n+          if (!aligned_access_p (dr))\n+            {\n+              if (vect_print_dump_info (REPORT_DETAILS))\n+                fprintf (vect_dump, \"vector alignment may not be reachable\");\n+\n+              break;\n+            }\n+        }\n     }\n \n   vect_versioning_for_alias_required\n@@ -1242,24 +1523,112 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       || !slpeel_can_duplicate_loop_p (loop, single_exit (loop)))\n     do_peeling = false;\n \n+  if (do_peeling && all_misalignments_unknown\n+      && vect_supportable_dr_alignment (dr0, false))\n+    {\n+\n+      /* Check if the target requires to prefer stores over loads, i.e., if\n+         misaligned stores are more expensive than misaligned loads (taking\n+         drs with same alignment into account).  */\n+      if (first_store && DR_IS_READ (dr0))\n+        {\n+          unsigned int load_inside_cost = 0, load_outside_cost = 0;\n+          unsigned int store_inside_cost = 0, store_outside_cost = 0;\n+          unsigned int load_inside_penalty = 0, load_outside_penalty = 0;\n+          unsigned int store_inside_penalty = 0, store_outside_penalty = 0;\n+\n+          vect_get_data_access_cost (dr0, &load_inside_cost,\n+                                     &load_outside_cost);\n+          vect_get_data_access_cost (first_store, &store_inside_cost,\n+                                     &store_outside_cost);\n+\n+          /* Calculate the penalty for leaving FIRST_STORE unaligned (by\n+             aligning the load DR0).  */\n+          load_inside_penalty = store_inside_cost;\n+          load_outside_penalty = store_outside_cost;\n+          for (i = 0; VEC_iterate (dr_p, STMT_VINFO_SAME_ALIGN_REFS\n+                                   (vinfo_for_stmt (DR_STMT (first_store))),\n+                                   i, dr);\n+               i++)\n+            if (DR_IS_READ (dr))\n+              {\n+                load_inside_penalty += load_inside_cost;\n+                load_outside_penalty += load_outside_cost;\n+              }\n+            else\n+              {\n+                load_inside_penalty += store_inside_cost;\n+                load_outside_penalty += store_outside_cost;\n+              }\n+\n+          /* Calculate the penalty for leaving DR0 unaligned (by\n+             aligning the FIRST_STORE).  */\n+          store_inside_penalty = load_inside_cost;\n+          store_outside_penalty = load_outside_cost;\n+          for (i = 0; VEC_iterate (dr_p, STMT_VINFO_SAME_ALIGN_REFS\n+                                   (vinfo_for_stmt (DR_STMT (dr0))),\n+                                   i, dr);\n+               i++)\n+            if (DR_IS_READ (dr))\n+              {\n+                store_inside_penalty += load_inside_cost;\n+                store_outside_penalty += load_outside_cost;\n+              }\n+            else\n+              {\n+                store_inside_penalty += store_inside_cost;\n+                store_outside_penalty += store_outside_cost;\n+              }\n+\n+          if (load_inside_penalty > store_inside_penalty\n+              || (load_inside_penalty == store_inside_penalty\n+                  && load_outside_penalty > store_outside_penalty))\n+            dr0 = first_store;\n+        }\n+\n+      /* In case there are only loads with different unknown misalignments, use\n+         peeling only if it may help to align other accesses in the loop.  */\n+      if (!first_store && !VEC_length (dr_p, STMT_VINFO_SAME_ALIGN_REFS\n+                                            (vinfo_for_stmt (DR_STMT (dr0))))\n+          && vect_supportable_dr_alignment (dr0, false)\n+              != dr_unaligned_supported)\n+        do_peeling = false;\n+    }\n+\n+  if (do_peeling && !dr0)\n+    {\n+      /* Peeling is possible, but there is no data access that is not supported\n+         unless aligned. So we try to choose the best possible peeling.  */\n+\n+      /* We should get here only if there are drs with known misalignment.  */\n+      gcc_assert (!all_misalignments_unknown);\n+\n+      /* Choose the best peeling from the hash table.  */\n+      dr0 = vect_peeling_hash_choose_best_peeling (loop_vinfo, &npeel);\n+      if (!dr0 || !npeel)\n+        do_peeling = false;\n+    }\n+\n   if (do_peeling)\n     {\n-      int mis;\n-      int npeel = 0;\n-      gimple stmt = DR_STMT (dr0);\n-      stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-      tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-      int nelements = TYPE_VECTOR_SUBPARTS (vectype);\n+      stmt = DR_STMT (dr0);\n+      stmt_info = vinfo_for_stmt (stmt);\n+      vectype = STMT_VINFO_VECTYPE (stmt_info);\n+      nelements = TYPE_VECTOR_SUBPARTS (vectype);\n \n       if (known_alignment_for_access_p (dr0))\n         {\n-          /* Since it's known at compile time, compute the number of iterations\n-             in the peeled loop (the peeling factor) for use in updating\n-             DR_MISALIGNMENT values.  The peeling factor is the vectorization\n-             factor minus the misalignment as an element count.  */\n-          mis = DR_MISALIGNMENT (dr0);\n-          mis /= GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr0))));\n-          npeel = nelements - mis;\n+          if (!npeel)\n+            {\n+              /* Since it's known at compile time, compute the number of\n+                 iterations in the peeled loop (the peeling factor) for use in\n+                 updating DR_MISALIGNMENT values.  The peeling factor is the\n+                 vectorization factor minus the misalignment as an element\n+                 count.  */\n+              mis = DR_MISALIGNMENT (dr0);\n+              mis /= GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr0))));\n+              npeel = nelements - mis;\n+            }\n \n \t  /* For interleaved data access every iteration accesses all the\n \t     members of the group, therefore we divide the number of iterations\n@@ -1290,7 +1659,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n \t  save_misalignment = DR_MISALIGNMENT (dr);\n \t  vect_update_misalignment_for_peel (dr, dr0, npeel);\n-\t  supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n+\t  supportable_dr_alignment = vect_supportable_dr_alignment (dr, false);\n \t  SET_DR_MISALIGNMENT (dr, save_misalignment);\n \n \t  if (!supportable_dr_alignment)\n@@ -1300,6 +1669,15 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t    }\n \t}\n \n+      if (do_peeling && known_alignment_for_access_p (dr0) && npeel == 0)\n+        {\n+          stat = vect_verify_datarefs_alignment (loop_vinfo, NULL);\n+          if (!stat)\n+            do_peeling = false;\n+          else\n+            return stat;\n+        }\n+\n       if (do_peeling)\n         {\n           /* (1.2) Update the DR_MISALIGNMENT of each data reference DR_i.\n@@ -1314,7 +1692,10 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t      vect_update_misalignment_for_peel (dr, dr0, npeel);\n \n           LOOP_VINFO_UNALIGNED_DR (loop_vinfo) = dr0;\n-          LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) = DR_MISALIGNMENT (dr0);\n+          if (npeel)\n+            LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) = npeel;\n+          else\n+            LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) = DR_MISALIGNMENT (dr0);\n \t  SET_DR_MISALIGNMENT (dr0, 0);\n \t  if (vect_print_dump_info (REPORT_ALIGNMENT))\n             fprintf (vect_dump, \"Alignment of access forced using peeling.\");\n@@ -1358,7 +1739,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t\t  && DR_GROUP_FIRST_DR (stmt_info) != stmt))\n \t    continue;\n \n-\t  supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n+\t  supportable_dr_alignment = vect_supportable_dr_alignment (dr, false);\n \n           if (!supportable_dr_alignment)\n             {\n@@ -1467,7 +1848,7 @@ vect_find_same_alignment_drs (struct data_dependence_relation *ddr,\n   if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n     return;\n \n-  if ((DR_IS_READ (dra) && DR_IS_READ (drb)) || dra == drb)\n+  if (dra == drb)\n     return;\n \n   if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n@@ -3558,13 +3939,16 @@ vect_can_force_dr_alignment_p (const_tree decl, unsigned int alignment)\n     return (alignment <= MAX_STACK_ALIGNMENT);\n }\n \n-/* Function vect_supportable_dr_alignment\n \n-   Return whether the data reference DR is supported with respect to its\n+/* Return whether the data reference DR is supported with respect to its\n+   alignment.\n+   If CHECK_ALIGNED_ACCESSES is TRUE, check if the access is supported even\n+   it is aligned, i.e., check if it is possible to vectorize it with different\n    alignment.  */\n \n enum dr_alignment_support\n-vect_supportable_dr_alignment (struct data_reference *dr)\n+vect_supportable_dr_alignment (struct data_reference *dr,\n+                               bool check_aligned_accesses)\n {\n   gimple stmt = DR_STMT (dr);\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n@@ -3574,7 +3958,7 @@ vect_supportable_dr_alignment (struct data_reference *dr)\n   struct loop *vect_loop = NULL;\n   bool nested_in_vect_loop = false;\n \n-  if (aligned_access_p (dr))\n+  if (aligned_access_p (dr) && !check_aligned_accesses)\n     return dr_aligned;\n \n   if (!loop_vinfo)"}, {"sha": "38546cf17484223afc0488621688ee12797e9498", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -1976,25 +1976,18 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters,\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   int vectype_align = TYPE_ALIGN (vectype) / BITS_PER_UNIT;\n   tree niters_type = TREE_TYPE (loop_niters);\n-  int step = 1;\n-  int element_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr))));\n   int nelements = TYPE_VECTOR_SUBPARTS (vectype);\n \n-  if (STMT_VINFO_STRIDED_ACCESS (stmt_info))\n-    step = DR_GROUP_SIZE (vinfo_for_stmt (DR_GROUP_FIRST_DR (stmt_info)));\n-\n   pe = loop_preheader_edge (loop);\n \n   if (LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) > 0)\n     {\n-      int byte_misalign = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n-      int elem_misalign = byte_misalign / element_size;\n+      int npeel = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n \n       if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"known alignment = %d.\", byte_misalign);\n+        fprintf (vect_dump, \"known peeling = %d.\", npeel);\n \n-      iters = build_int_cst (niters_type,\n-                     (((nelements - elem_misalign) & (nelements - 1)) / step));\n+      iters = build_int_cst (niters_type, npeel);\n     }\n   else\n     {\n@@ -2017,7 +2010,8 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters,\n \n       /* Create:  byte_misalign = addr & (vectype_size - 1)  */\n       byte_misalign =\n-        fold_build2 (BIT_AND_EXPR, type, fold_convert (type, start_addr), vectype_size_minus_1);\n+        fold_build2 (BIT_AND_EXPR, type, fold_convert (type, start_addr), \n+                     vectype_size_minus_1);\n \n       /* Create:  elem_misalign = byte_misalign / element_size  */\n       elem_misalign =\n@@ -2323,7 +2317,8 @@ vect_vfa_segment_size (struct data_reference *dr, tree vect_factor)\n   tree segment_length = fold_build2 (MULT_EXPR, integer_type_node,\n \t\t\t             DR_STEP (dr), vect_factor);\n \n-  if (vect_supportable_dr_alignment (dr) == dr_explicit_realign_optimized)\n+  if (vect_supportable_dr_alignment (dr, false)\n+        == dr_explicit_realign_optimized)\n     {\n       tree vector_size = TYPE_SIZE_UNIT\n \t\t\t  (STMT_VINFO_VECTYPE (vinfo_for_stmt (DR_STMT (dr))));"}, {"sha": "ef4817355187e7fb66d6afc91497f9610b580e61", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 120, "deletions": 51, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -755,6 +755,7 @@ new_loop_vec_info (struct loop *loop)\n   LOOP_VINFO_REDUCTIONS (res) = VEC_alloc (gimple, heap, 10);\n   LOOP_VINFO_SLP_INSTANCES (res) = VEC_alloc (slp_instance, heap, 10);\n   LOOP_VINFO_SLP_UNROLLING_FACTOR (res) = 1;\n+  LOOP_VINFO_PEELING_HTAB (res) = NULL;\n \n   return res;\n }\n@@ -845,6 +846,9 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo, bool clean_stmts)\n   VEC_free (gimple, heap, LOOP_VINFO_STRIDED_STORES (loop_vinfo));\n   VEC_free (gimple, heap, LOOP_VINFO_REDUCTIONS (loop_vinfo));\n \n+  if (LOOP_VINFO_PEELING_HTAB (loop_vinfo))\n+    htab_delete (LOOP_VINFO_PEELING_HTAB (loop_vinfo));\n+\n   free (loop_vinfo);\n   loop->aux = NULL;\n }\n@@ -1122,7 +1126,11 @@ vect_analyze_loop_form (struct loop *loop)\n static inline \n int vect_get_cost (enum vect_cost_for_stmt type_of_cost)\n {\n-  return targetm.vectorize.builtin_vectorization_cost (type_of_cost); \n+  tree dummy_type = NULL;\n+  int dummy = 0;\n+\n+  return targetm.vectorize.builtin_vectorization_cost (type_of_cost,\n+                                                       dummy_type, dummy);\n }\n \n  \n@@ -1498,29 +1506,29 @@ vect_analyze_loop (struct loop *loop)\n       return NULL;\n     }\n \n-  /* Check the SLP opportunities in the loop, analyze and build SLP trees.  */\n-  ok = vect_analyze_slp (loop_vinfo, NULL);\n-  if (ok)\n-    {\n-      /* Decide which possible SLP instances to SLP.  */\n-      vect_make_slp_decision (loop_vinfo);\n-\n-      /* Find stmts that need to be both vectorized and SLPed.  */\n-      vect_detect_hybrid_slp (loop_vinfo);\n-    }\n-\n   /* This pass will decide on using loop versioning and/or loop peeling in\n      order to enhance the alignment of data references in the loop.  */\n \n   ok = vect_enhance_data_refs_alignment (loop_vinfo);\n   if (!ok)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"bad data alignment.\");\n+        fprintf (vect_dump, \"bad data alignment.\");\n       destroy_loop_vec_info (loop_vinfo, true);\n       return NULL;\n     }\n \n+  /* Check the SLP opportunities in the loop, analyze and build SLP trees.  */\n+  ok = vect_analyze_slp (loop_vinfo, NULL);\n+  if (ok)\n+    {\n+      /* Decide which possible SLP instances to SLP.  */\n+      vect_make_slp_decision (loop_vinfo);\n+\n+      /* Find stmts that need to be both vectorized and SLPed.  */\n+      vect_detect_hybrid_slp (loop_vinfo);\n+    }\n+\n   /* Scan all the operations in the loop and make sure they are\n      vectorizable.  */\n \n@@ -2004,6 +2012,94 @@ vect_force_simple_reduction (loop_vec_info loop_info, gimple phi,\n \t\t\t\t     double_reduc, true);\n }\n \n+/* Calculate the cost of one scalar iteration of the loop.  */\n+int\n+vect_get_single_scalar_iteraion_cost (loop_vec_info loop_vinfo)\n+{\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n+  int nbbs = loop->num_nodes, factor, scalar_single_iter_cost = 0;\n+  int innerloop_iters, i, stmt_cost;\n+\n+  /* Count statements in scalar loop. Using this as scalar cost for a single\n+     iteration for now.\n+\n+     TODO: Add outer loop support.\n+\n+     TODO: Consider assigning different costs to different scalar\n+     statements.  */\n+\n+  /* FORNOW.  */\n+  if (loop->inner)\n+    innerloop_iters = 50; /* FIXME */\n+\n+  for (i = 0; i < nbbs; i++)\n+    {\n+      gimple_stmt_iterator si;\n+      basic_block bb = bbs[i];\n+\n+      if (bb->loop_father == loop->inner)\n+        factor = innerloop_iters;\n+      else\n+        factor = 1;\n+\n+      for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+        {\n+          gimple stmt = gsi_stmt (si);\n+\n+          if (!is_gimple_assign (stmt) && !is_gimple_call (stmt))\n+            continue;\n+\n+          if (STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt)))\n+            {\n+              if (DR_IS_READ (STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt))))\n+               stmt_cost = vect_get_cost (scalar_load);\n+             else\n+               stmt_cost = vect_get_cost (scalar_store);\n+            }\n+          else\n+            stmt_cost = vect_get_cost (scalar_stmt);\n+\n+          scalar_single_iter_cost += stmt_cost * factor;\n+        }\n+    }\n+  return scalar_single_iter_cost;\n+}\n+\n+/* Calculate cost of peeling the loop PEEL_ITERS_PROLOGUE times.  */\n+int\n+vect_get_known_peeling_cost (loop_vec_info loop_vinfo, int peel_iters_prologue,\n+                             int *peel_iters_epilogue,\n+                             int scalar_single_iter_cost)\n+{\n+  int peel_guard_costs = 0;\n+  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+\n+  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n+    {\n+      *peel_iters_epilogue = vf/2;\n+      if (vect_print_dump_info (REPORT_COST))\n+        fprintf (vect_dump, \"cost model: \"\n+                            \"epilogue peel iters set to vf/2 because \"\n+                            \"loop iterations are unknown .\");\n+\n+      /* If peeled iterations are known but number of scalar loop\n+         iterations are unknown, count a taken branch per peeled loop.  */\n+      peel_guard_costs =  2 * vect_get_cost (cond_branch_taken);\n+    }\n+  else\n+    {\n+      int niters = LOOP_VINFO_INT_NITERS (loop_vinfo);\n+      peel_iters_prologue = niters < peel_iters_prologue ?\n+                            niters : peel_iters_prologue;\n+      *peel_iters_epilogue = (niters - peel_iters_prologue) % vf;\n+    }\n+\n+   return (peel_iters_prologue * scalar_single_iter_cost)\n+            + (*peel_iters_epilogue * scalar_single_iter_cost)\n+           + peel_guard_costs;\n+}\n+\n /* Function vect_estimate_min_profitable_iters\n \n    Return the number of iterations required for the vector version of the\n@@ -2028,7 +2124,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n   int nbbs = loop->num_nodes;\n-  int byte_misalign = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n+  int npeel = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n   int peel_guard_costs = 0;\n   int innerloop_iters = 0, factor;\n   VEC (slp_instance, heap) *slp_instances;\n@@ -2099,14 +2195,15 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \t      && (!STMT_VINFO_LIVE_P (stmt_info)\n \t\t  || STMT_VINFO_DEF_TYPE (stmt_info) != vect_reduction_def))\n \t    continue;\n-\t  scalar_single_iter_cost += cost_for_stmt (stmt) * factor;\n \t  vec_inside_cost += STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) * factor;\n \t  /* FIXME: for stmts in the inner-loop in outer-loop vectorization,\n \t     some of the \"outside\" costs are generated inside the outer-loop.  */\n \t  vec_outside_cost += STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info);\n \t}\n     }\n \n+  scalar_single_iter_cost = vect_get_single_scalar_iteraion_cost (loop_vinfo);\n+\n   /* Add additional cost for the peeled instructions in prologue and epilogue\n      loop.\n \n@@ -2116,7 +2213,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n      TODO: Build an expression that represents peel_iters for prologue and\n      epilogue to be used in a run-time test.  */\n \n-  if (byte_misalign < 0)\n+  if (npeel  < 0)\n     {\n       peel_iters_prologue = vf/2;\n       if (vect_print_dump_info (REPORT_COST))\n@@ -2137,46 +2234,18 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n          not known. Hence guards remain the same.  */\n       peel_guard_costs +=  2 * (vect_get_cost (cond_branch_taken)\n                                 + vect_get_cost (cond_branch_not_taken));\n+      vec_outside_cost += (peel_iters_prologue * scalar_single_iter_cost)\n+                           + (peel_iters_epilogue * scalar_single_iter_cost)\n+                           + peel_guard_costs;\n     }\n   else\n     {\n-      if (byte_misalign)\n-\t{\n-\t  struct data_reference *dr = LOOP_VINFO_UNALIGNED_DR (loop_vinfo);\n-\t  int element_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr))));\n-\t  tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (DR_STMT (dr)));\n-\t  int nelements = TYPE_VECTOR_SUBPARTS (vectype);\n-\n-\t  peel_iters_prologue = nelements - (byte_misalign / element_size);\n-\t}\n-      else\n-\tpeel_iters_prologue = 0;\n-\n-      if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n-        {\n-          peel_iters_epilogue = vf/2;\n-          if (vect_print_dump_info (REPORT_COST))\n-            fprintf (vect_dump, \"cost model: \"\n-                     \"epilogue peel iters set to vf/2 because \"\n-                     \"loop iterations are unknown .\");\n-\n-\t  /* If peeled iterations are known but number of scalar loop\n-\t     iterations are unknown, count a taken branch per peeled loop.  */\n-\t  peel_guard_costs +=  2 * vect_get_cost (cond_branch_taken); \n-        }\n-      else\n-\t{\n-\t  int niters = LOOP_VINFO_INT_NITERS (loop_vinfo);\n-\t  peel_iters_prologue = niters < peel_iters_prologue ?\n-\t\t\t\t\tniters : peel_iters_prologue;\n-\t  peel_iters_epilogue = (niters - peel_iters_prologue) % vf;\n-\t}\n+      peel_iters_prologue = npeel;\n+      vec_outside_cost += vect_get_known_peeling_cost (loop_vinfo,\n+                                    peel_iters_prologue, &peel_iters_epilogue,\n+                                    scalar_single_iter_cost);\n     }\n \n-  vec_outside_cost += (peel_iters_prologue * scalar_single_iter_cost)\n-                      + (peel_iters_epilogue * scalar_single_iter_cost)\n-                      + peel_guard_costs;\n-\n   /* FORNOW: The scalar outside cost is incremented in one of the\n      following ways:\n "}, {"sha": "1ae3a652bd9041346822d9d2df74d90d0f990547", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -560,7 +560,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n               if (first_load == stmt)\n                 {\n                   first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt));\n-                  if (vect_supportable_dr_alignment (first_dr)\n+                  if (vect_supportable_dr_alignment (first_dr, false)\n                       == dr_unaligned_unsupported)\n                     {\n                       if (vect_print_dump_info (REPORT_SLP))\n@@ -646,7 +646,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n         {\n           VEC_safe_push (slp_tree, heap, *loads, *node);\n           *inside_cost \n-            += targetm.vectorize.builtin_vectorization_cost (vec_perm) \n+            += targetm.vectorize.builtin_vectorization_cost (vec_perm, NULL, 0) \n                * group_size;\n         }\n "}, {"sha": "89e7c4b0ebd7f5b410bcc070561fca512a203d16", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 128, "deletions": 51, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -545,6 +545,18 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n }\n \n \n+/* Get cost by calling cost target builtin.  */\n+\n+static inline\n+int vect_get_stmt_cost (enum vect_cost_for_stmt type_of_cost)\n+{\n+  tree dummy_type = NULL;\n+  int dummy = 0;\n+\n+  return targetm.vectorize.builtin_vectorization_cost (type_of_cost,\n+                                                       dummy_type, dummy);\n+}\n+\n int\n cost_for_stmt (gimple stmt)\n {\n@@ -553,9 +565,9 @@ cost_for_stmt (gimple stmt)\n   switch (STMT_VINFO_TYPE (stmt_info))\n   {\n   case load_vec_info_type:\n-    return targetm.vectorize.builtin_vectorization_cost (scalar_load);\n+    return vect_get_stmt_cost (scalar_load);\n   case store_vec_info_type:\n-    return targetm.vectorize.builtin_vectorization_cost (scalar_store);\n+    return vect_get_stmt_cost (scalar_store);\n   case op_vec_info_type:\n   case condition_vec_info_type:\n   case assignment_vec_info_type:\n@@ -565,7 +577,7 @@ cost_for_stmt (gimple stmt)\n   case type_demotion_vec_info_type:\n   case type_conversion_vec_info_type:\n   case call_vec_info_type:\n-    return targetm.vectorize.builtin_vectorization_cost (scalar_stmt);\n+    return vect_get_stmt_cost (scalar_stmt);\n   case undef_vec_info_type:\n   default:\n     gcc_unreachable ();\n@@ -589,15 +601,13 @@ vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies,\n   if (PURE_SLP_STMT (stmt_info))\n     return;\n \n-  inside_cost = ncopies \n-    * targetm.vectorize.builtin_vectorization_cost (vector_stmt);\n+  inside_cost = ncopies * vect_get_stmt_cost (vector_stmt); \n \n   /* FORNOW: Assuming maximum 2 args per stmts.  */\n   for (i = 0; i < 2; i++)\n     {\n       if (dt[i] == vect_constant_def || dt[i] == vect_external_def)\n-\toutside_cost \n-          += targetm.vectorize.builtin_vectorization_cost (vector_stmt);\n+\toutside_cost += vect_get_stmt_cost (vector_stmt); \n     }\n \n   if (vect_print_dump_info (REPORT_COST))\n@@ -638,30 +648,47 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n \t\t       enum vect_def_type dt, slp_tree slp_node)\n {\n   int group_size;\n-  int inside_cost = 0, outside_cost = 0;\n+  unsigned int inside_cost = 0, outside_cost = 0;\n+  struct data_reference *first_dr;\n+  gimple first_stmt;\n \n   /* The SLP costs were already calculated during SLP tree build.  */\n   if (PURE_SLP_STMT (stmt_info))\n     return;\n \n   if (dt == vect_constant_def || dt == vect_external_def)\n-    outside_cost \n-      = targetm.vectorize.builtin_vectorization_cost (scalar_to_vec);\n+    outside_cost = vect_get_stmt_cost (scalar_to_vec); \n \n   /* Strided access?  */\n-  if (DR_GROUP_FIRST_DR (stmt_info) && !slp_node)\n-    group_size = vect_cost_strided_group_size (stmt_info);\n+  if (DR_GROUP_FIRST_DR (stmt_info))\n+    {\n+      if (slp_node)\n+        {\n+          first_stmt = VEC_index (gimple, SLP_TREE_SCALAR_STMTS (slp_node), 0);\n+          group_size = 1;\n+        }\n+      else\n+        {\n+          first_stmt = DR_GROUP_FIRST_DR (stmt_info);\n+          group_size = vect_cost_strided_group_size (stmt_info);\n+        }\n+\n+      first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n+    }\n   /* Not a strided access.  */\n   else\n-    group_size = 1;\n+    {\n+      group_size = 1;\n+      first_dr = STMT_VINFO_DATA_REF (stmt_info);\n+    }\n \n   /* Is this an access in a group of stores, which provide strided access?\n      If so, add in the cost of the permutes.  */\n   if (group_size > 1)\n     {\n       /* Uses a high and low interleave operation for each needed permute.  */\n       inside_cost = ncopies * exact_log2(group_size) * group_size\n-             * targetm.vectorize.builtin_vectorization_cost (vector_stmt);\n+        * vect_get_stmt_cost (vector_stmt);\n \n       if (vect_print_dump_info (REPORT_COST))\n         fprintf (vect_dump, \"vect_model_store_cost: strided group_size = %d .\",\n@@ -670,8 +697,7 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n     }\n \n   /* Costs of the stores.  */\n-  inside_cost += ncopies \n-    * targetm.vectorize.builtin_vectorization_cost (vector_store);\n+  vect_get_store_cost (first_dr, ncopies, &inside_cost);\n \n   if (vect_print_dump_info (REPORT_COST))\n     fprintf (vect_dump, \"vect_model_store_cost: inside_cost = %d, \"\n@@ -683,6 +709,49 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n }\n \n \n+/* Calculate cost of DR's memory access.  */\n+void\n+vect_get_store_cost (struct data_reference *dr, int ncopies,\n+                     unsigned int *inside_cost)\n+{\n+  int alignment_support_scheme = vect_supportable_dr_alignment (dr, false);\n+\n+  switch (alignment_support_scheme)\n+    {\n+    case dr_aligned:\n+      {\n+        *inside_cost += ncopies * vect_get_stmt_cost (vector_store);\n+\n+        if (vect_print_dump_info (REPORT_COST))\n+          fprintf (vect_dump, \"vect_model_store_cost: aligned.\");\n+\n+        break;\n+      }\n+\n+    case dr_unaligned_supported:\n+      {\n+        gimple stmt = DR_STMT (dr);\n+        stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+        tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+\n+        /* Here, we assign an additional cost for the unaligned store.  */\n+        *inside_cost += ncopies\n+          * targetm.vectorize.builtin_vectorization_cost (unaligned_store,\n+                                 vectype, DR_MISALIGNMENT (dr));\n+\n+        if (vect_print_dump_info (REPORT_COST))\n+          fprintf (vect_dump, \"vect_model_store_cost: unaligned supported by \"\n+                   \"hardware.\");\n+\n+        break;\n+      }\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+\n /* Function vect_model_load_cost\n \n    Models cost for loads.  In the case of strided accesses, the last access\n@@ -695,10 +764,9 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, slp_tree slp_node)\n \n {\n   int group_size;\n-  int alignment_support_cheme;\n   gimple first_stmt;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info), *first_dr;\n-  int inside_cost = 0, outside_cost = 0;\n+  unsigned int inside_cost = 0, outside_cost = 0;\n \n   /* The SLP costs were already calculated during SLP tree build.  */\n   if (PURE_SLP_STMT (stmt_info))\n@@ -718,29 +786,47 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, slp_tree slp_node)\n       first_dr = dr;\n     }\n \n-  alignment_support_cheme = vect_supportable_dr_alignment (first_dr);\n-\n   /* Is this an access in a group of loads providing strided access?\n      If so, add in the cost of the permutes.  */\n   if (group_size > 1)\n     {\n       /* Uses an even and odd extract operations for each needed permute.  */\n       inside_cost = ncopies * exact_log2(group_size) * group_size\n-\t* targetm.vectorize.builtin_vectorization_cost (vector_stmt);\n+\t* vect_get_stmt_cost (vector_stmt);\n \n       if (vect_print_dump_info (REPORT_COST))\n         fprintf (vect_dump, \"vect_model_load_cost: strided group_size = %d .\",\n                  group_size);\n-\n     }\n \n   /* The loads themselves.  */\n-  switch (alignment_support_cheme)\n+  vect_get_load_cost (first_dr, ncopies,\n+         ((!DR_GROUP_FIRST_DR (stmt_info)) || group_size > 1 || slp_node),\n+         &inside_cost, &outside_cost);\n+\n+  if (vect_print_dump_info (REPORT_COST))\n+    fprintf (vect_dump, \"vect_model_load_cost: inside_cost = %d, \"\n+             \"outside_cost = %d .\", inside_cost, outside_cost);\n+\n+  /* Set the costs either in STMT_INFO or SLP_NODE (if exists).  */\n+  stmt_vinfo_set_inside_of_loop_cost (stmt_info, slp_node, inside_cost);\n+  stmt_vinfo_set_outside_of_loop_cost (stmt_info, slp_node, outside_cost);\n+}\n+\n+\n+/* Calculate cost of DR's memory access.  */\n+void\n+vect_get_load_cost (struct data_reference *dr, int ncopies,\n+                    bool add_realign_cost, unsigned int *inside_cost,\n+                    unsigned int *outside_cost)\n+{\n+  int alignment_support_scheme = vect_supportable_dr_alignment (dr, false);\n+\n+  switch (alignment_support_scheme)\n     {\n     case dr_aligned:\n       {\n-        inside_cost += ncopies \n-          * targetm.vectorize.builtin_vectorization_cost (vector_load);\n+        inside_cost += ncopies * vect_get_stmt_cost (vector_load); \n \n         if (vect_print_dump_info (REPORT_COST))\n           fprintf (vect_dump, \"vect_model_load_cost: aligned.\");\n@@ -749,10 +835,14 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, slp_tree slp_node)\n       }\n     case dr_unaligned_supported:\n       {\n-        /* Here, we assign an additional cost for the unaligned load.  */\n-        inside_cost += ncopies \n-        * targetm.vectorize.builtin_vectorization_cost (unaligned_load);\n+        gimple stmt = DR_STMT (dr);\n+        stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+        tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n \n+        /* Here, we assign an additional cost for the unaligned load.  */\n+        *inside_cost += ncopies\n+          * targetm.vectorize.builtin_vectorization_cost (unaligned_load,\n+                                           vectype, DR_MISALIGNMENT (dr));\n         if (vect_print_dump_info (REPORT_COST))\n           fprintf (vect_dump, \"vect_model_load_cost: unaligned supported by \"\n                    \"hardware.\");\n@@ -761,16 +851,14 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, slp_tree slp_node)\n       }\n     case dr_explicit_realign:\n       {\n-        inside_cost += ncopies * (2 \n-         * targetm.vectorize.builtin_vectorization_cost (vector_load) \n-           + targetm.vectorize.builtin_vectorization_cost (vector_stmt));\n+        *inside_cost += ncopies * (2 * vect_get_stmt_cost (vector_load)\n+           + vect_get_stmt_cost (vector_stmt));\n \n         /* FIXME: If the misalignment remains fixed across the iterations of\n            the containing loop, the following cost should be added to the\n            outside costs.  */\n         if (targetm.vectorize.builtin_mask_for_load)\n-          inside_cost \n-            += targetm.vectorize.builtin_vectorization_cost (vector_stmt);\n+          *inside_cost += vect_get_stmt_cost (vector_stmt);\n \n         break;\n       }\n@@ -787,32 +875,21 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies, slp_tree slp_node)\n            access in the group. Inside the loop, there is a load op\n            and a realignment op.  */\n \n-        if ((!DR_GROUP_FIRST_DR (stmt_info)) || group_size > 1 || slp_node)\n+        if (add_realign_cost)\n           {\n-            outside_cost = 2 \n-              * targetm.vectorize.builtin_vectorization_cost (vector_stmt);\n+            *outside_cost = 2 * vect_get_stmt_cost (vector_stmt);\n             if (targetm.vectorize.builtin_mask_for_load)\n-              outside_cost \n-                += targetm.vectorize.builtin_vectorization_cost (vector_stmt);\n+              *outside_cost += vect_get_stmt_cost (vector_stmt);\n           }\n \n-        inside_cost += ncopies \n-          * (targetm.vectorize.builtin_vectorization_cost (vector_load)\n-             + targetm.vectorize.builtin_vectorization_cost (vector_stmt));\n+        *inside_cost += ncopies * (vect_get_stmt_cost (vector_load)\n+          + vect_get_stmt_cost (vector_stmt));\n         break;\n       }\n \n     default:\n       gcc_unreachable ();\n     }\n-\n-  if (vect_print_dump_info (REPORT_COST))\n-    fprintf (vect_dump, \"vect_model_load_cost: inside_cost = %d, \"\n-             \"outside_cost = %d .\", inside_cost, outside_cost);\n-\n-  /* Set the costs either in STMT_INFO or SLP_NODE (if exists).  */\n-  stmt_vinfo_set_inside_of_loop_cost (stmt_info, slp_node, inside_cost);\n-  stmt_vinfo_set_outside_of_loop_cost (stmt_info, slp_node, outside_cost);\n }\n \n \n@@ -3142,7 +3219,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   dr_chain = VEC_alloc (tree, heap, group_size);\n   oprnds = VEC_alloc (tree, heap, group_size);\n \n-  alignment_support_scheme = vect_supportable_dr_alignment (first_dr);\n+  alignment_support_scheme = vect_supportable_dr_alignment (first_dr, false);\n   gcc_assert (alignment_support_scheme);\n \n   /* In case the vectorization factor (VF) is bigger than the number\n@@ -3507,7 +3584,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       group_size = vec_num = 1;\n     }\n \n-  alignment_support_scheme = vect_supportable_dr_alignment (first_dr);\n+  alignment_support_scheme = vect_supportable_dr_alignment (first_dr, false);\n   gcc_assert (alignment_support_scheme);\n \n   /* In case the vectorization factor (VF) is bigger than the number"}, {"sha": "ed8ff58312aa6849e02dc021c4d2a4741e6d71c9", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/720f52395d60fe525773c89d5ef5af1a9d9f8775/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=720f52395d60fe525773c89d5ef5af1a9d9f8775", "patch": "@@ -170,6 +170,21 @@ DEF_VEC_ALLOC_P(slp_instance, heap);\n #define SLP_TREE_OUTSIDE_OF_LOOP_COST(S)         (S)->cost.outside_of_loop\n #define SLP_TREE_INSIDE_OF_LOOP_COST(S)          (S)->cost.inside_of_loop\n \n+\n+typedef struct _vect_peel_info\n+{\n+  int npeel;\n+  struct data_reference *dr;\n+  unsigned int count;\n+} *vect_peel_info;\n+\n+typedef struct _vect_peel_extended_info\n+{\n+  struct _vect_peel_info peel_info;\n+  unsigned int inside_cost;\n+  unsigned int outside_cost;\n+} *vect_peel_extended_info;\n+\n /*-----------------------------------------------------------------*/\n /* Info on vectorized loops.                                       */\n /*-----------------------------------------------------------------*/\n@@ -245,6 +260,10 @@ typedef struct _loop_vec_info {\n \n   /* Reduction cycles detected in the loop. Used in loop-aware SLP.  */\n   VEC (gimple, heap) *reductions;\n+\n+  /* Hash table used to choose the best peeling option.  */\n+  htab_t peeling_htab;\n+\n } *loop_vec_info;\n \n /* Access Functions.  */\n@@ -270,6 +289,7 @@ typedef struct _loop_vec_info {\n #define LOOP_VINFO_SLP_INSTANCES(L)        (L)->slp_instances\n #define LOOP_VINFO_SLP_UNROLLING_FACTOR(L) (L)->slp_unrolling_factor\n #define LOOP_VINFO_REDUCTIONS(L)           (L)->reductions\n+#define LOOP_VINFO_PEELING_HTAB(L)         (L)->peeling_htab\n \n #define LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT(L) \\\n VEC_length (gimple, (L)->may_misalign_stmts) > 0\n@@ -543,6 +563,8 @@ typedef struct _stmt_vec_info {\n #define PURE_SLP_STMT(S)                  ((S)->slp_type == pure_slp)\n #define STMT_SLP_TYPE(S)                   (S)->slp_type\n \n+#define VECT_MAX_COST 1000\n+\n /* The maximum number of intermediate steps required in multi-step type\n    conversion.  */\n #define MAX_INTERM_CVT_STEPS         3\n@@ -743,11 +765,14 @@ extern void vect_remove_stores (gimple);\n extern bool vect_analyze_stmt (gimple, bool *, slp_tree);\n extern bool vectorizable_condition (gimple, gimple_stmt_iterator *, gimple *,\n                                     tree, int);\n+extern void vect_get_load_cost (struct data_reference *, int, bool,\n+                                unsigned int *, unsigned int *);\n+extern void vect_get_store_cost (struct data_reference *, int, unsigned int *);\n \n /* In tree-vect-data-refs.c.  */\n extern bool vect_can_force_dr_alignment_p (const_tree, unsigned int);\n extern enum dr_alignment_support vect_supportable_dr_alignment\n-                                           (struct data_reference *);\n+                                           (struct data_reference *, bool);\n extern tree vect_get_smallest_scalar_type (gimple, HOST_WIDE_INT *,\n                                            HOST_WIDE_INT *);\n extern bool vect_analyze_data_ref_dependences (loop_vec_info, bb_vec_info,\n@@ -795,7 +820,8 @@ extern bool vectorizable_induction (gimple, gimple_stmt_iterator *, gimple *);\n extern int vect_estimate_min_profitable_iters (loop_vec_info);\n extern tree get_initial_def_for_reduction (gimple, tree, tree *);\n extern int vect_min_worthwhile_factor (enum tree_code);\n-\n+extern int vect_get_known_peeling_cost (loop_vec_info, int, int *, int);\n+extern int vect_get_single_scalar_iteraion_cost (loop_vec_info);\n \n /* In tree-vect-slp.c.  */\n extern void vect_free_slp_instance (slp_instance);"}]}