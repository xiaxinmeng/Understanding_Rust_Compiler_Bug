{"sha": "35704c46616d00f048172abd4311521baa35044d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU3MDRjNDY2MTZkMDBmMDQ4MTcyYWJkNDMxMTUyMWJhYTM1MDQ0ZA==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1998-12-15T20:31:18Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1998-12-15T20:31:18Z"}, "message": "loop.h (loop_info): New field 'vtop'.\n\n\t* loop.h (loop_info): New field 'vtop'.\n\t* loop.c (check_dbra_loop):  Use loop_info->vtop rather than\n\tscanning loop for vtop.\n\t* unroll.c (subtract_reg_term, find_common_reg_term): New functions.\n\t(loop_iterations): Use them to determine if loop has a constant\n \tnumber of iterations.  Set loop_info->vtop.  Don't subtract\n\tcommon reg term from initial_value and final_value if have a\n\tdo-while loop.\n\nFrom-SVN: r24333", "tree": {"sha": "9ef0e744d566ecaef9e587914a1a553ec59e674e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ef0e744d566ecaef9e587914a1a553ec59e674e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35704c46616d00f048172abd4311521baa35044d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35704c46616d00f048172abd4311521baa35044d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35704c46616d00f048172abd4311521baa35044d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35704c46616d00f048172abd4311521baa35044d/comments", "author": null, "committer": null, "parents": [{"sha": "c7dda1e388309a4fffe95c0903b1029c2669b20c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7dda1e388309a4fffe95c0903b1029c2669b20c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7dda1e388309a4fffe95c0903b1029c2669b20c"}], "stats": {"total": 241, "additions": 172, "deletions": 69}, "files": [{"sha": "53ad9dea8443ffdd303edf9c10c56663fe7425be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35704c46616d00f048172abd4311521baa35044d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35704c46616d00f048172abd4311521baa35044d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=35704c46616d00f048172abd4311521baa35044d", "patch": "@@ -1,3 +1,14 @@\n+Wed Dec 16 17:24:07 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* loop.h (loop_info): New field 'vtop'.\n+\t* loop.c (check_dbra_loop):  Use loop_info->vtop rather than\n+\tscanning loop for vtop.\n+\t* unroll.c (subtract_reg_term, find_common_reg_term): New functions.\n+\t(loop_iterations): Use them to determine if loop has a constant\n+ \tnumber of iterations.  Set loop_info->vtop.  Don't subtract\n+\tcommon reg term from initial_value and final_value if have a\n+\tdo-while loop.\n+\n Tue Dec 15 13:49:55 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* mn10300.md (bset, bclr): Operand 0 is a read/write operand."}, {"sha": "2dbad4de8bb9a738b66a890884d9a55c7a21649e", "filename": "gcc/loop.c", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35704c46616d00f048172abd4311521baa35044d/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35704c46616d00f048172abd4311521baa35044d/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=35704c46616d00f048172abd4311521baa35044d", "patch": "@@ -6867,7 +6867,6 @@ check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n \t      enum rtx_code cmp_code;\n \t      int comparison_const_width;\n \t      unsigned HOST_WIDE_INT comparison_sign_mask;\n-\t      rtx vtop;\n \n \t      add_val = INTVAL (bl->biv->add_val);\n \t      comparison_value = XEXP (comparison, 1);\n@@ -6914,25 +6913,6 @@ check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n \t\t  initial_value = const0_rtx;\n \t\t}\n \n-\t      /* Check if there is a NOTE_INSN_LOOP_VTOP note.  If there is,\n-\t\t that means that this is a for or while style loop, with\n-\t\t a loop exit test at the start.  Thus, we can assume that\n-\t\t the loop condition was true when the loop was entered.\n-\t\t This allows us to change the loop exit condition to an\n-\t\t equality test.\n-\t\t We start at the end and search backwards for the previous\n-\t\t NOTE.  If there is no NOTE_INSN_LOOP_VTOP for this loop,\n-\t\t the search will stop at the NOTE_INSN_LOOP_CONT.  */\n-\t      vtop = loop_end;\n-\t      do\n-\t\tvtop = PREV_INSN (vtop);\n-\t      while (GET_CODE (vtop) != NOTE\n-\t\t     || NOTE_LINE_NUMBER (vtop) > 0\n-\t\t     || NOTE_LINE_NUMBER (vtop) == NOTE_REPEATED_LINE_NUMBER\n-\t\t     || NOTE_LINE_NUMBER (vtop) == NOTE_INSN_DELETED);\n-\t      if (NOTE_LINE_NUMBER (vtop) != NOTE_INSN_LOOP_VTOP)\n-\t\tvtop = NULL_RTX;\n-\t\t\n \t      /* First check if we can do a vanilla loop reversal.  */\n \t      if (initial_value == const0_rtx\n \t\t  /* If we have a decrement_and_branch_on_count, prefer\n@@ -6941,7 +6921,7 @@ check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n \t\t     reversal if the biv is used to calculate a giv or has\n \t\t     a non-counting use.  */\n #if ! defined (HAVE_decrement_and_branch_until_zero) && defined (HAVE_decrement_and_branch_on_count)\n-\t\t  && (! (add_val == 1 && vtop\n+\t\t  && (! (add_val == 1 && loop_info->vtop\n \t\t         && (bl->biv_count == 0\n \t\t\t     || no_use_except_counting)))\n #endif\n@@ -6956,7 +6936,7 @@ check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n \t\t  nonneg = 1;\n \t\t  cmp_code = GE;\n \t\t}\n-\t      else if (add_val == 1 && vtop\n+\t      else if (add_val == 1 && loop_info->vtop\n \t\t       && (bl->biv_count == 0\n \t\t\t   || no_use_except_counting))\n \t\t{"}, {"sha": "de6ce2f762eb3eee40f9bab3c9b3b3c584acd0bd", "filename": "gcc/loop.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35704c46616d00f048172abd4311521baa35044d/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35704c46616d00f048172abd4311521baa35044d/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=35704c46616d00f048172abd4311521baa35044d", "patch": "@@ -176,7 +176,9 @@ struct loop_info\n      1: not unrolled.\n      -1: completely unrolled\n      >0: holds the unroll exact factor.  */\n-  int unroll_number;\n+  unsigned int unroll_number;\n+  /* Non-zero if the loop has a NOTE_INSN_LOOP_VTOP.  */\n+  rtx vtop;\n };\n \n /* Definitions used by the basic induction variable discovery code.  */"}, {"sha": "8723c35330faf10bc94ef3387cb08a62adf50f51", "filename": "gcc/unroll.c", "status": "modified", "additions": 156, "deletions": 46, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35704c46616d00f048172abd4311521baa35044d/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35704c46616d00f048172abd4311521baa35044d/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=35704c46616d00f048172abd4311521baa35044d", "patch": "@@ -3394,6 +3394,72 @@ loop_find_equiv_value (loop_start, reg)\n }\n \n \n+/* Return a simplified rtx for the expression OP - REG.\n+\n+   REG must appear in OP, and OP must be a register or the sum of a register\n+   and a second term.\n+\n+   Thus, the return value must be const0_rtx or the second term.\n+\n+   The caller is responsible for verifying that REG appears in OP and OP has\n+   the proper form.  */\n+\n+static rtx\n+subtract_reg_term (op, reg)\n+     rtx op, reg;\n+{\n+  if (op == reg)\n+    return const0_rtx;\n+  if (GET_CODE (op) == PLUS)\n+    {\n+      if (XEXP (op, 0) == reg)\n+\treturn XEXP (op, 1);\n+      else if (XEXP (op, 1) == reg)\n+\treturn XEXP (op, 0);\n+    }\n+  /* OP does not contain REG as a term.  */\n+  abort ();\n+}\n+\n+\n+/* Find and return register term common to both expressions OP0 and\n+   OP1 or NULL_RTX if no such term exists.  Each expression must be a\n+   REG or a PLUS of a REG.  */\n+\n+static rtx\n+find_common_reg_term (op0, op1)\n+     rtx op0, op1;\n+{\n+  if ((GET_CODE (op0) == REG || GET_CODE (op0) == PLUS)\n+      && (GET_CODE (op1) == REG || GET_CODE (op1) == PLUS))\n+    {\n+      rtx op00;\n+      rtx op01;\n+      rtx op10;\n+      rtx op11;\n+\n+      if (GET_CODE (op0) == PLUS)\n+\top01 = XEXP (op0, 1), op00 = XEXP (op0, 0);\n+      else\n+\top01 = const0_rtx, op00 = op0;\n+\n+      if (GET_CODE (op1) == PLUS)\n+\top11 = XEXP (op1, 1), op10 = XEXP (op1, 0);\n+      else\n+\top11 = const0_rtx, op10 = op1;\n+\n+      /* Find and return common register term if present.  */\n+      if (REG_P (op00) && (op00 == op10 || op00 == op11))\n+\treturn op00;\n+      else if (REG_P (op01) && (op01 == op10 || op01 == op11))\n+\treturn op01;\n+    }\n+\n+  /* No common register term found.  */\n+  return NULL_RTX;\n+}\n+\n+\n /* Calculate the number of loop iterations.  Returns the exact number of loop\n    iterations if it can be calculated, otherwise returns zero.  */\n \n@@ -3411,6 +3477,8 @@ loop_iterations (loop_start, loop_end, loop_info)\n   int increment_dir;\n   int unsigned_p, compare_dir, final_larger;\n   rtx last_loop_insn;\n+  rtx vtop;\n+  rtx reg_term;\n \n   loop_info->n_iterations = 0;\n   loop_info->initial_value = 0;\n@@ -3421,6 +3489,7 @@ loop_iterations (loop_start, loop_end, loop_info)\n   loop_info->increment = 0;\n   loop_info->iteration_var = 0;\n   loop_info->unroll_number = 1;\n+  loop_info->vtop = 0;\n \n   /* First find the iteration variable.  If the last insn is a conditional\n      branch, and the insn before tests a register value, make that the\n@@ -3447,6 +3516,25 @@ loop_iterations (loop_start, loop_end, loop_info)\n   comparison_code = GET_CODE (comparison);\n   iteration_var = XEXP (comparison, 0);\n   comparison_value = XEXP (comparison, 1);\n+  \n+  /* Check if there is a NOTE_INSN_LOOP_VTOP note.  If there is,\n+     that means that this is a for or while style loop, with\n+     a loop exit test at the start.  Thus, we can assume that\n+     the loop condition was true when the loop was entered.\n+\n+     We start at the end and search backwards for the previous\n+     NOTE.  If there is no NOTE_INSN_LOOP_VTOP for this loop,\n+     the search will stop at the NOTE_INSN_LOOP_CONT.  */\n+  vtop = loop_end;\n+  do\n+    vtop = PREV_INSN (vtop);\n+  while (GET_CODE (vtop) != NOTE\n+\t || NOTE_LINE_NUMBER (vtop) > 0\n+\t || NOTE_LINE_NUMBER (vtop) == NOTE_REPEATED_LINE_NUMBER\n+\t || NOTE_LINE_NUMBER (vtop) == NOTE_INSN_DELETED);\n+  if (NOTE_LINE_NUMBER (vtop) != NOTE_INSN_LOOP_VTOP)\n+    vtop = NULL_RTX;\n+  loop_info->vtop = vtop;\n \n   if (GET_CODE (iteration_var) != REG)\n     {\n@@ -3545,63 +3633,85 @@ loop_iterations (loop_start, loop_end, loop_info)\n   loop_info->iteration_var = iteration_var;\n   loop_info->comparison_code = comparison_code;\n \n-  if (REG_P (initial_value))\n-    {\n-      rtx temp = final_value;\n+  /* Try to determine the iteration count for loops such\n+     as (for i = init; i < init + const; i++).  When running the\n+     loop optimization twice, the first pass often converts simple\n+     loops into this form.  */\n \n-      /* initial_value = reg1, final_value = reg2 + const, where reg1\n-\t != reg2.  Try to find what reg1 is equivalent to.  Hopefully\n-\t it will either be reg2 or reg2 plus a constant.  */\n-      if (GET_CODE (temp) == PLUS)\n-\ttemp = XEXP (temp, 0);\n-      if (REG_P (temp) && REGNO (temp) != REGNO (initial_value))\n-\tinitial_value = loop_find_equiv_value (loop_start, initial_value);\n-    }\n-\n-  /* If have initial_value = reg + const1 and final_value = reg +\n-     const2, then replace initial_value with const1 and final_value\n-     with const2.  This should be safe since we are protected by the\n-     initial comparison before entering the loop.  */\n-  if ((GET_CODE (initial_value) == REG || GET_CODE (initial_value) == PLUS)\n-      && (GET_CODE (final_value) == REG || GET_CODE (final_value) == PLUS))\n+  if (REG_P (initial_value))\n     {\n-      rtx init_op0;\n-      rtx fini_op0;\n-      rtx init_op1;\n-      rtx fini_op1;\n-\n-      if (GET_CODE (initial_value) == PLUS)\n-\tinit_op1 = XEXP (initial_value, 1), init_op0 = XEXP (initial_value, 0);\n-      else\n-\tinit_op1 = const0_rtx, init_op0 = initial_value;\n+      rtx reg1;\n+      rtx reg2;\n+      rtx const2;\n \n+      reg1 = initial_value;\n       if (GET_CODE (final_value) == PLUS)\n-\tfini_op1 = XEXP (final_value, 1), fini_op0 = XEXP (final_value, 0);\n+\treg2 = XEXP (final_value, 0), const2 = XEXP (final_value, 1);\n       else\n-\tfini_op1 = const0_rtx, fini_op0 = final_value;\n+\treg2 = final_value, const2 = const0_rtx;\n \n-      /* Remove register common factor if present.  */\n-      if (REG_P (init_op0) && init_op0 == fini_op0)\n-\t{\n-\t  initial_value = init_op1;\n-\t  final_value = fini_op1;\n-\t}\n-      else if (REG_P (init_op0) && init_op0 == fini_op1)\n+      /* Check for initial_value = reg1, final_value = reg2 + const2,\n+\t where reg1 != reg2.  */\n+      if (REG_P (reg2) && reg2 != reg1)\n \t{\n-\t  initial_value = init_op1;\n-\t  final_value = fini_op0;\n-\t}\n-      else if (REG_P (init_op1) && init_op1 == fini_op0)\n-\t{\n-\t  initial_value = init_op0;\n-\t  final_value = fini_op1;\n+\t  rtx temp;\n+\n+\t  /* Find what reg1 is equivalent to.  Hopefully it will\n+\t     either be reg2 or reg2 plus a constant.  */\n+\t  temp = loop_find_equiv_value (loop_start, reg1);\n+\t  if (find_common_reg_term (temp, reg2))\n+\t    initial_value = temp;\n+\t  else\n+\t    {\n+\t      /* Find what reg2 is equivalent to.  Hopefully it will\n+\t\t either be reg1 or reg1 plus a constant.  Let's ignore\n+\t\t the latter case for now since it is not so common.  */\n+\t      temp = loop_find_equiv_value (loop_start, reg2);\n+\t      if (temp == loop_info->iteration_var)\n+\t\ttemp = initial_value;\n+\t      if (temp == reg1)\n+\t\tfinal_value = (const2 == const0_rtx)\n+\t\t  ? reg1 : gen_rtx_PLUS (GET_MODE (reg1), reg1, const2);\n+\t    }\n \t}\n-      else if (REG_P (init_op1) && init_op1 == fini_op1)\n+      else if (loop_info->vtop && GET_CODE (reg2) == CONST_INT)\n \t{\n-\t  initial_value = init_op0;\n-\t  final_value = fini_op0;\n+\t  rtx temp;\n+\n+\t  /*  When running the loop optimizer twice, check_dbra_loop\n+\t      further obfuscates reversible loops of the form:\n+\t      for (i = init; i < init + const; i++).  We often end up with\n+\t      final_value = 0, initial_value = temp, temp = temp2 - init,\n+\t      where temp2 = init + const.  If the loop has a vtop we\n+\t      can replace initial_value with const.  */\n+\n+\t  temp = loop_find_equiv_value (loop_start, reg1);\n+\t  if (GET_CODE (temp) == MINUS && REG_P (XEXP (temp, 0)))\n+\t    {\n+\t      rtx temp2 = loop_find_equiv_value (loop_start, XEXP (temp, 0));\n+\t      if (GET_CODE (temp2) == PLUS\n+\t\t  && XEXP (temp2, 0) == XEXP (temp, 1))\n+\t\tinitial_value = XEXP (temp2, 1);\n+\t    }\n \t}\n     }\n+  \n+  /* If have initial_value = reg + const1 and final_value = reg +\n+     const2, then replace initial_value with const1 and final_value\n+     with const2.  This should be safe since we are protected by the\n+     initial comparison before entering the loop if we have a vtop.\n+     For example, a + b < a + c is not equivalent to b < c for all a\n+     when using modulo arithmetic.\n+\n+     ??? Without a vtop we could still perform the optimization if we check\n+     the initial and final values carefully.  */\n+  if (loop_info->vtop \n+      && (reg_term = find_common_reg_term (initial_value, final_value)))\n+    {\n+      initial_value = subtract_reg_term (initial_value, reg_term);\n+      final_value = subtract_reg_term (final_value, reg_term);\n+    }\n+\n   loop_info->initial_equiv_value = initial_value;\n   loop_info->final_equiv_value = final_value;\n   "}]}