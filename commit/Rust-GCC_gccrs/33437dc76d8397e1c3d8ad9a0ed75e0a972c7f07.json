{"sha": "33437dc76d8397e1c3d8ad9a0ed75e0a972c7f07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM0MzdkYzc2ZDgzOTdlMWMzZDhhZDlhMGVkNzVlMGE5NzJjN2YwNw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@stanford.edu", "date": "2001-03-21T07:29:37Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-03-21T07:29:37Z"}, "message": "choose-temp.c: Split off make_temp_file...\n\n        * choose-temp.c: Split off make_temp_file, and the code\n        duplicated between it and choose_temp_base, into...\n        * make-temp-file.c: ... here; new file.\n\n        * Makefile.in (CFILES): Add make-temp-file.c.\n        (REQUIRED_OFILES): Add make-temp-file.o.\n\nFrom-SVN: r40683", "tree": {"sha": "17289a0e11587e6ab70daac5ac8c9156e208c1fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17289a0e11587e6ab70daac5ac8c9156e208c1fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33437dc76d8397e1c3d8ad9a0ed75e0a972c7f07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33437dc76d8397e1c3d8ad9a0ed75e0a972c7f07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33437dc76d8397e1c3d8ad9a0ed75e0a972c7f07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33437dc76d8397e1c3d8ad9a0ed75e0a972c7f07/comments", "author": null, "committer": null, "parents": [{"sha": "fed4dede7e1f3884b14abb3fc6fb9f116f276915", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fed4dede7e1f3884b14abb3fc6fb9f116f276915", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fed4dede7e1f3884b14abb3fc6fb9f116f276915"}], "stats": {"total": 336, "additions": 189, "deletions": 147}, "files": [{"sha": "e83a8208fd447a4f7aaea33cc80b42d99142b446", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33437dc76d8397e1c3d8ad9a0ed75e0a972c7f07/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33437dc76d8397e1c3d8ad9a0ed75e0a972c7f07/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=33437dc76d8397e1c3d8ad9a0ed75e0a972c7f07", "patch": "@@ -1,3 +1,12 @@\n+2001-03-20  Zack Weinberg  <zackw@stanford.edu>\n+\n+\t* choose-temp.c: Split off make_temp_file, and the code\n+\tduplicated between it and choose_temp_base, into...\n+\t* make-temp-file.c: ... here; new file.\n+\n+\t* Makefile.in (CFILES): Add make-temp-file.c.\n+\t(REQUIRED_OFILES): Add make-temp-file.o.\n+\n 2001-03-20  Jason Merrill  <jason@redhat.com>\n \n \t* cplus-dem.c (main): Skip initial $."}, {"sha": "2b95074b5e799fad68ef59cd6a6f0f6d2e36acbf", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33437dc76d8397e1c3d8ad9a0ed75e0a972c7f07/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33437dc76d8397e1c3d8ad9a0ed75e0a972c7f07/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=33437dc76d8397e1c3d8ad9a0ed75e0a972c7f07", "patch": "@@ -125,7 +125,7 @@ CFILES = asprintf.c alloca.c argv.c atexit.c basename.c bcmp.c bcopy.c\t      \\\n         cp-demangle.c dyn-string.c fdmatch.c fnmatch.c getcwd.c\t\t      \\\n \tgetpwd.c getopt.c getopt1.c getpagesize.c getruntime.c\t\t      \\\n \tfloatformat.c hashtab.c hex.c index.c insque.c lbasename.c            \\\n-\tmd5.c memchr.c\t\t\t\t\t\t\t      \\\n+\tmd5.c make-temp-file.c memchr.c\t\t\t\t\t      \\\n \tmemcmp.c memcpy.c memmove.c memset.c mkstemps.c objalloc.c obstack.c  \\\n \tpartition.c pexecute.c putenv.c random.c rename.c rindex.c setenv.c   \\\n \tsigsetmask.c safe-ctype.c sort.c spaces.c splay-tree.c strcasecmp.c   \\\n@@ -138,7 +138,7 @@ CFILES = asprintf.c alloca.c argv.c atexit.c basename.c bcmp.c bcopy.c\t      \\\n REQUIRED_OFILES = argv.o alloca.o choose-temp.o concat.o cplus-dem.o          \\\n \tcp-demangle.o dyn-string.o fdmatch.o fnmatch.o getopt.o getopt1.o     \\\n \tgetpwd.o getruntime.o hashtab.o hex.o floatformat.o lbasename.o       \\\n-        md5.o objalloc.o\t\t\t\t\t\t      \\\n+        md5.o make-temp-file.o objalloc.o\t\t\t\t      \\\n \tobstack.o partition.o pexecute.o safe-ctype.o sort.o spaces.o         \\\n \tsplay-tree.o strerror.o strsignal.o xatexit.o xexit.o xmalloc.o       \\\n \txmemdup.o xstrdup.o xstrerror.o"}, {"sha": "c6df304b5528bc239fe83a9a0c1738c0d50a2e2b", "filename": "libiberty/choose-temp.c", "status": "modified", "additions": 4, "deletions": 145, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33437dc76d8397e1c3d8ad9a0ed75e0a972c7f07/libiberty%2Fchoose-temp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33437dc76d8397e1c3d8ad9a0ed75e0a972c7f07/libiberty%2Fchoose-temp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fchoose-temp.c?ref=33437dc76d8397e1c3d8ad9a0ed75e0a972c7f07", "patch": "@@ -17,81 +17,25 @@ License along with libiberty; see the file COPYING.LIB.  If not,\n write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* This file exports two functions: choose_temp_base and make_temp_file.  */\n-\n #ifdef HAVE_CONFIG_H\n #include \"config.h\"\n #endif\n \n #include <stdio.h>\t/* May get P_tmpdir.  */\n-#include <sys/types.h>\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#endif\n #ifdef HAVE_STDLIB_H\n #include <stdlib.h>\n #endif\n #ifdef HAVE_STRING_H\n #include <string.h>\n #endif\n-#ifdef HAVE_SYS_FILE_H\n-#include <sys/file.h>   /* May get R_OK, etc. on some systems.  */\n-#endif\n-\n-#ifndef R_OK\n-#define R_OK 4\n-#define W_OK 2\n-#define X_OK 1\n-#endif\n \n #include \"libiberty.h\"\n-extern int mkstemps ();\n-\n-#ifndef IN_GCC\n-#if defined (__MSDOS__) || (defined (_WIN32) && ! defined (__CYGWIN__) && ! defined (_UWIN))\n-#define DIR_SEPARATOR '\\\\'\n-#endif\n-#endif\n-\n-#ifndef DIR_SEPARATOR\n-#define DIR_SEPARATOR '/'\n-#endif\n-\n-/* On MSDOS, write temp files in current dir\n-   because there's no place else we can expect to use.  */\n-/* ??? Although the current directory is tried as a last resort,\n-   this is left in so that on MSDOS it is preferred to /tmp on the\n-   off chance that someone requires this, since that was the previous\n-   behaviour.  */\n-#ifdef __MSDOS__\n-#ifndef P_tmpdir\n-#define P_tmpdir \".\"\n-#endif\n-#endif\n+extern char *choose_tmpdir PARAMS ((void));\n \n /* Name of temporary file.\n    mktemp requires 6 trailing X's.  */\n #define TEMP_FILE \"ccXXXXXX\"\n-\n-/* Subroutine of choose_temp_base.\n-   If BASE is non-NULL, return it.\n-   Otherwise it checks if DIR is a usable directory.\n-   If success, DIR is returned.\n-   Otherwise NULL is returned.  */\n-\n-static const char *try PARAMS ((const char *, const char *));\n-\n-static const char *\n-try (dir, base)\n-     const char *dir, *base;\n-{\n-  if (base != 0)\n-    return base;\n-  if (dir != 0\n-      && access (dir, R_OK | W_OK | X_OK) == 0)\n-    return dir;\n-  return 0;\n-}\n+#define TEMP_FILE_LEN (sizeof(TEMP_FILE) - 1)\n \n /* Return a prefix for temporary file names or NULL if unable to find one.\n    The current directory is chosen if all else fails so the program is\n@@ -104,102 +48,17 @@ try (dir, base)\n char *\n choose_temp_base ()\n {\n-  const char *base = 0;\n+  const char *base = choose_tmpdir ();\n   char *temp_filename;\n   int len;\n-  static char tmp[] = { DIR_SEPARATOR, 't', 'm', 'p', 0 };\n-  static char usrtmp[] = { DIR_SEPARATOR, 'u', 's', 'r', DIR_SEPARATOR, 't', 'm', 'p', 0 };\n-\n-  base = try (getenv (\"TMPDIR\"), base);\n-  base = try (getenv (\"TMP\"), base);\n-  base = try (getenv (\"TEMP\"), base);\n-\n-#ifdef P_tmpdir\n-  base = try (P_tmpdir, base);\n-#endif\n-\n-  /* Try /usr/tmp, then /tmp.  */\n-  base = try (usrtmp, base);\n-  base = try (tmp, base);\n- \n-  /* If all else fails, use the current directory!  */\n-  if (base == 0)\n-    base = \".\";\n \n   len = strlen (base);\n-  temp_filename = xmalloc (len + 1 /*DIR_SEPARATOR*/\n-\t\t\t   + strlen (TEMP_FILE) + 1);\n+  temp_filename = xmalloc (len + TEMP_FILE_LEN + 1);\n   strcpy (temp_filename, base);\n-\n-  if (len != 0\n-      && temp_filename[len-1] != '/'\n-      && temp_filename[len-1] != DIR_SEPARATOR)\n-    temp_filename[len++] = DIR_SEPARATOR;\n   strcpy (temp_filename + len, TEMP_FILE);\n \n   mktemp (temp_filename);\n   if (strlen (temp_filename) == 0)\n     abort ();\n   return temp_filename;\n }\n-/* Return a temporary file name (as a string) or NULL if unable to create\n-   one.  */\n-\n-char *\n-make_temp_file (suffix)\n-     const char *suffix;\n-{\n-  const char *base = 0;\n-  char *temp_filename;\n-  int base_len, suffix_len;\n-  int fd;\n-  static char tmp[] = { DIR_SEPARATOR, 't', 'm', 'p', 0 };\n-  static char usrtmp[] = { DIR_SEPARATOR, 'u', 's', 'r', DIR_SEPARATOR, 't', 'm', 'p', 0 };\n-\n-  base = try (getenv (\"TMPDIR\"), base);\n-  base = try (getenv (\"TMP\"), base);\n-  base = try (getenv (\"TEMP\"), base);\n-\n-#ifdef P_tmpdir\n-  base = try (P_tmpdir, base);\n-#endif\n-\n-  /* Try /usr/tmp, then /tmp.  */\n-  base = try (usrtmp, base);\n-  base = try (tmp, base);\n- \n-  /* If all else fails, use the current directory!  */\n-  if (base == 0)\n-    base = \".\";\n-\n-  base_len = strlen (base);\n-\n-  if (suffix)\n-    suffix_len = strlen (suffix);\n-  else\n-    suffix_len = 0;\n-\n-  temp_filename = xmalloc (base_len + 1 /*DIR_SEPARATOR*/\n-\t\t\t   + strlen (TEMP_FILE)\n-\t\t\t   + suffix_len + 1);\n-  strcpy (temp_filename, base);\n-\n-  if (base_len != 0\n-      && temp_filename[base_len-1] != '/'\n-      && temp_filename[base_len-1] != DIR_SEPARATOR)\n-    temp_filename[base_len++] = DIR_SEPARATOR;\n-  strcpy (temp_filename + base_len, TEMP_FILE);\n-\n-  if (suffix)\n-    strcat (temp_filename, suffix);\n-\n-  fd = mkstemps (temp_filename, suffix_len);\n-  /* If mkstemps failed, then something bad is happening.  Maybe we should\n-     issue a message about a possible security attack in progress?  */\n-  if (fd == -1)\n-    abort ();\n-  /* Similarly if we can not close the file.  */\n-  if (close (fd))\n-    abort ();\n-  return temp_filename;\n-}"}, {"sha": "8429624a11f78f4185b6200d6518667e10beff46", "filename": "libiberty/make-temp-file.c", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33437dc76d8397e1c3d8ad9a0ed75e0a972c7f07/libiberty%2Fmake-temp-file.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33437dc76d8397e1c3d8ad9a0ed75e0a972c7f07/libiberty%2Fmake-temp-file.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmake-temp-file.c?ref=33437dc76d8397e1c3d8ad9a0ed75e0a972c7f07", "patch": "@@ -0,0 +1,174 @@\n+/* Utility to pick a temporary filename prefix.\n+   Copyright (C) 1996, 1997, 1998, 2001 Free Software Foundation, Inc.\n+\n+This file is part of the libiberty library.\n+Libiberty is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+Libiberty is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libiberty; see the file COPYING.LIB.  If not,\n+write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifdef HAVE_CONFIG_H\n+#include \"config.h\"\n+#endif\n+\n+#include <stdio.h>\t/* May get P_tmpdir.  */\n+#include <sys/types.h>\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+#ifdef HAVE_STRING_H\n+#include <string.h>\n+#endif\n+#ifdef HAVE_SYS_FILE_H\n+#include <sys/file.h>   /* May get R_OK, etc. on some systems.  */\n+#endif\n+\n+#ifndef R_OK\n+#define R_OK 4\n+#define W_OK 2\n+#define X_OK 1\n+#endif\n+\n+#include \"libiberty.h\"\n+extern int mkstemps PARAMS ((char *, int));\n+\n+#ifndef IN_GCC\n+#if defined (__MSDOS__) || (defined (_WIN32) && ! defined (__CYGWIN__) && ! defined (_UWIN))\n+#define DIR_SEPARATOR '\\\\'\n+#endif\n+#endif\n+\n+#ifndef DIR_SEPARATOR\n+#define DIR_SEPARATOR '/'\n+#endif\n+\n+/* On MSDOS, write temp files in current dir\n+   because there's no place else we can expect to use.  */\n+/* ??? Although the current directory is tried as a last resort,\n+   this is left in so that on MSDOS it is preferred to /tmp on the\n+   off chance that someone requires this, since that was the previous\n+   behaviour.  */\n+#ifdef __MSDOS__\n+#ifndef P_tmpdir\n+#define P_tmpdir \".\"\n+#endif\n+#endif\n+\n+/* Name of temporary file.\n+   mktemp requires 6 trailing X's.  */\n+#define TEMP_FILE \"ccXXXXXX\"\n+#define TEMP_FILE_LEN (sizeof(TEMP_FILE) - 1)\n+\n+/* Subroutine of choose_tmpdir.\n+   If BASE is non-NULL, return it.\n+   Otherwise it checks if DIR is a usable directory.\n+   If success, DIR is returned.\n+   Otherwise NULL is returned.  */\n+\n+static const char *try PARAMS ((const char *, const char *));\n+\n+static const char *\n+try (dir, base)\n+     const char *dir, *base;\n+{\n+  if (base != 0)\n+    return base;\n+  if (dir != 0\n+      && access (dir, R_OK | W_OK | X_OK) == 0)\n+    return dir;\n+  return 0;\n+}\n+\n+static char tmp[] = { DIR_SEPARATOR, 't', 'm', 'p', 0 };\n+static char usrtmp[] =\n+{ DIR_SEPARATOR, 'u', 's', 'r', DIR_SEPARATOR, 't', 'm', 'p', 0 };\n+\n+static char *memoized_tmpdir;\n+\n+char *\n+choose_tmpdir ()\n+{\n+  const char *base = 0;\n+  char *tmpdir;\n+  unsigned int len;\n+\n+  if (memoized_tmpdir)\n+    return memoized_tmpdir;\n+\n+  base = try (getenv (\"TMPDIR\"), base);\n+  base = try (getenv (\"TMP\"), base);\n+  base = try (getenv (\"TEMP\"), base);\n+\n+#ifdef P_tmpdir\n+  base = try (P_tmpdir, base);\n+#endif\n+\n+  /* Try /usr/tmp, then /tmp.  */\n+  base = try (usrtmp, base);\n+  base = try (tmp, base);\n+ \n+  /* If all else fails, use the current directory!  */\n+  if (base == 0)\n+    base = \".\";\n+\n+  /* Append DIR_SEPARATOR to the directory we've chosen\n+     and return it.  */\n+  len = strlen (base);\n+  tmpdir = xmalloc (len + 2);\n+  strcpy (tmpdir, base);\n+  tmpdir[len] = DIR_SEPARATOR;\n+  tmpdir[len+1] = '\\0';\n+\n+  memoized_tmpdir = tmpdir;\n+  return tmpdir;\n+}\n+\n+/* Return a temporary file name (as a string) or NULL if unable to create\n+   one.  SUFFIX is a suffix to append to the file name.  The string is\n+   malloced, and the temporary file has been created.  */\n+\n+char *\n+make_temp_file (suffix)\n+     const char *suffix;\n+{\n+  const char *base = choose_tmpdir ();\n+  char *temp_filename;\n+  int base_len, suffix_len;\n+  int fd;\n+\n+  if (suffix == 0)\n+    suffix = \"\";\n+\n+  base_len = strlen (base);\n+  suffix_len = strlen (suffix);\n+\n+  temp_filename = xmalloc (base_len\n+\t\t\t   + TEMP_FILE_LEN\n+\t\t\t   + suffix_len + 1);\n+  strcpy (temp_filename, base);\n+  strcpy (temp_filename + base_len, TEMP_FILE);\n+  strcpy (temp_filename + base_len + TEMP_FILE_LEN, suffix);\n+\n+  fd = mkstemps (temp_filename, suffix_len);\n+  /* If mkstemps failed, then something bad is happening.  Maybe we should\n+     issue a message about a possible security attack in progress?  */\n+  if (fd == -1)\n+    abort ();\n+  /* Similarly if we can not close the file.  */\n+  if (close (fd))\n+    abort ();\n+  return temp_filename;\n+}"}]}