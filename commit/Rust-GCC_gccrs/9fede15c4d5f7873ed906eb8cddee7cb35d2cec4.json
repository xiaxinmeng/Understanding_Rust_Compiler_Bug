{"sha": "9fede15c4d5f7873ed906eb8cddee7cb35d2cec4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZlZGUxNWM0ZDVmNzg3M2VkOTA2ZWI4Y2RkZWU3Y2IzNWQyY2VjNA==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2018-07-23T11:27:38Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2018-07-23T11:27:38Z"}, "message": "rs6000: Improve vsx_init_v4si\n\nThis changes vsx_init_v4si to be an expander.  That way, no special\ncases are needed anymore for special arguments: the normal RTL passes\ncan deal with it.\n\n\n\t* config/rs6000/rs6000-p8swap.c (rtx_is_swappable_p): Adjust.\n\t* config/rs6000/rs6000-protos.h (rs6000_split_v4si_init): Delete.\n\t* config/rs6000/rs6000.c (rs6000_expand_vector_init): Always force\n\tthe elements into a register.\n\t(rs6000_split_v4si_init_di_reg): Delete.\n\t(rs6000_split_v4si_init): Delete.\n\t* config/rs6000/vsx.md (unspec): Delete UNSPEC_VSX_VEC_INIT.\n\t(vsx_init_v4si): Rewrite as a define_expand.\n\nFrom-SVN: r262930", "tree": {"sha": "4f8dd49a9f0622b8b149e9208bdc828ff65ba1b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f8dd49a9f0622b8b149e9208bdc828ff65ba1b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fede15c4d5f7873ed906eb8cddee7cb35d2cec4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fede15c4d5f7873ed906eb8cddee7cb35d2cec4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fede15c4d5f7873ed906eb8cddee7cb35d2cec4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fede15c4d5f7873ed906eb8cddee7cb35d2cec4/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "268e16e89b2fe7ed6f9f03c877e05714464a704a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/268e16e89b2fe7ed6f9f03c877e05714464a704a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/268e16e89b2fe7ed6f9f03c877e05714464a704a"}], "stats": {"total": 154, "additions": 45, "deletions": 109}, "files": [{"sha": "1bf8b46fb18e1d372873088f97c3757309fabe6e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fede15c4d5f7873ed906eb8cddee7cb35d2cec4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fede15c4d5f7873ed906eb8cddee7cb35d2cec4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9fede15c4d5f7873ed906eb8cddee7cb35d2cec4", "patch": "@@ -1,3 +1,14 @@\n+2018-07-23  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config/rs6000/rs6000-p8swap.c (rtx_is_swappable_p): Adjust.\n+\t* config/rs6000/rs6000-protos.h (rs6000_split_v4si_init): Delete.\n+\t* config/rs6000/rs6000.c (rs6000_expand_vector_init): Always force\n+\tthe elements into a register.\n+\t(rs6000_split_v4si_init_di_reg): Delete.\n+\t(rs6000_split_v4si_init): Delete.\n+\t* config/rs6000/vsx.md (unspec): Delete UNSPEC_VSX_VEC_INIT.\n+\t(vsx_init_v4si): Rewrite as a define_expand.\n+\n 2018-07-23  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* config/rs6000/rs6000.md (splitters for rldimi and rlwimi with the"}, {"sha": "f32db38b3fe244b2d240a19c7998b37698766d5a", "filename": "gcc/config/rs6000/rs6000-p8swap.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fede15c4d5f7873ed906eb8cddee7cb35d2cec4/gcc%2Fconfig%2Frs6000%2Frs6000-p8swap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fede15c4d5f7873ed906eb8cddee7cb35d2cec4/gcc%2Fconfig%2Frs6000%2Frs6000-p8swap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-p8swap.c?ref=9fede15c4d5f7873ed906eb8cddee7cb35d2cec4", "patch": "@@ -772,7 +772,6 @@ rtx_is_swappable_p (rtx op, unsigned int *special)\n \t  case UNSPEC_VSX_EXTRACT:\n \t  case UNSPEC_VSX_SET:\n \t  case UNSPEC_VSX_SLDWI:\n-\t  case UNSPEC_VSX_VEC_INIT:\n \t  case UNSPEC_VSX_VSLO:\n \t  case UNSPEC_VUNPACK_HI_SIGN:\n \t  case UNSPEC_VUNPACK_HI_SIGN_DIRECT:"}, {"sha": "fc45aa51af97f7fd1eb2de1bb085c75bd5b79d5c", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fede15c4d5f7873ed906eb8cddee7cb35d2cec4/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fede15c4d5f7873ed906eb8cddee7cb35d2cec4/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=9fede15c4d5f7873ed906eb8cddee7cb35d2cec4", "patch": "@@ -61,7 +61,6 @@ extern void rs6000_expand_vector_set (rtx, rtx, int);\n extern void rs6000_expand_vector_extract (rtx, rtx, rtx);\n extern void rs6000_split_vec_extract_var (rtx, rtx, rtx, rtx, rtx);\n extern rtx rs6000_adjust_vec_address (rtx, rtx, rtx, rtx, machine_mode);\n-extern void rs6000_split_v4si_init (rtx []);\n extern void altivec_expand_vec_perm_le (rtx op[4]);\n extern void rs6000_expand_extract_even (rtx, rtx, rtx);\n extern void rs6000_expand_interleave (rtx, rtx, rtx, bool);"}, {"sha": "2b736d756c3392745c2b5c1fb6f5ae3b363b29c6", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 91, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fede15c4d5f7873ed906eb8cddee7cb35d2cec4/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fede15c4d5f7873ed906eb8cddee7cb35d2cec4/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=9fede15c4d5f7873ed906eb8cddee7cb35d2cec4", "patch": "@@ -6857,11 +6857,7 @@ rs6000_expand_vector_init (rtx target, rtx vals)\n \t  size_t i;\n \n \t  for (i = 0; i < 4; i++)\n-\t    {\n-\t      elements[i] = XVECEXP (vals, 0, i);\n-\t      if (!CONST_INT_P (elements[i]) && !REG_P (elements[i]))\n-\t\telements[i] = copy_to_mode_reg (SImode, elements[i]);\n-\t    }\n+\t    elements[i] = force_reg (SImode, XVECEXP (vals, 0, i));\n \n \t  emit_insn (gen_vsx_init_v4si (target, elements[0], elements[1],\n \t\t\t\t\telements[2], elements[3]));\n@@ -7568,92 +7564,6 @@ rs6000_split_vec_extract_var (rtx dest, rtx src, rtx element, rtx tmp_gpr,\n     gcc_unreachable ();\n  }\n \n-/* Helper function for rs6000_split_v4si_init to build up a DImode value from\n-   two SImode values.  */\n-\n-static void\n-rs6000_split_v4si_init_di_reg (rtx dest, rtx si1, rtx si2, rtx tmp)\n-{\n-  const unsigned HOST_WIDE_INT mask_32bit = HOST_WIDE_INT_C (0xffffffff);\n-\n-  if (CONST_INT_P (si1) && CONST_INT_P (si2))\n-    {\n-      unsigned HOST_WIDE_INT const1 = (UINTVAL (si1) & mask_32bit) << 32;\n-      unsigned HOST_WIDE_INT const2 = UINTVAL (si2) & mask_32bit;\n-\n-      emit_move_insn (dest, GEN_INT (const1 | const2));\n-      return;\n-    }\n-\n-  /* Put si1 into upper 32-bits of dest.  */\n-  if (CONST_INT_P (si1))\n-    emit_move_insn (dest, GEN_INT ((UINTVAL (si1) & mask_32bit) << 32));\n-  else\n-    {\n-      /* Generate RLDIC.  */\n-      rtx si1_di = gen_rtx_REG (DImode, regno_or_subregno (si1));\n-      rtx shift_rtx = gen_rtx_ASHIFT (DImode, si1_di, GEN_INT (32));\n-      rtx mask_rtx = GEN_INT (mask_32bit << 32);\n-      rtx and_rtx = gen_rtx_AND (DImode, shift_rtx, mask_rtx);\n-      gcc_assert (!reg_overlap_mentioned_p (dest, si1));\n-      emit_insn (gen_rtx_SET (dest, and_rtx));\n-    }\n-\n-  /* Put si2 into the temporary.  */\n-  gcc_assert (!reg_overlap_mentioned_p (dest, tmp));\n-  if (CONST_INT_P (si2))\n-    emit_move_insn (tmp, GEN_INT (UINTVAL (si2) & mask_32bit));\n-  else\n-    emit_insn (gen_zero_extendsidi2 (tmp, si2));\n-\n-  /* Combine the two parts.  */\n-  emit_insn (gen_iordi3 (dest, dest, tmp));\n-  return;\n-}\n-\n-/* Split a V4SI initialization.  */\n-\n-void\n-rs6000_split_v4si_init (rtx operands[])\n-{\n-  rtx dest = operands[0];\n-\n-  /* Destination is a GPR, build up the two DImode parts in place.  */\n-  if (REG_P (dest) || SUBREG_P (dest))\n-    {\n-      int d_regno = regno_or_subregno (dest);\n-      rtx scalar1 = operands[1];\n-      rtx scalar2 = operands[2];\n-      rtx scalar3 = operands[3];\n-      rtx scalar4 = operands[4];\n-      rtx tmp1 = operands[5];\n-      rtx tmp2 = operands[6];\n-\n-      /* Even though we only need one temporary (plus the destination, which\n-\t has an early clobber constraint, try to use two temporaries, one for\n-\t each double word created.  That way the 2nd insn scheduling pass can\n-\t rearrange things so the two parts are done in parallel.  */\n-      if (BYTES_BIG_ENDIAN)\n-\t{\n-\t  rtx di_lo = gen_rtx_REG (DImode, d_regno);\n-\t  rtx di_hi = gen_rtx_REG (DImode, d_regno + 1);\n-\t  rs6000_split_v4si_init_di_reg (di_lo, scalar1, scalar2, tmp1);\n-\t  rs6000_split_v4si_init_di_reg (di_hi, scalar3, scalar4, tmp2);\n-\t}\n-      else\n-\t{\n-\t  rtx di_lo = gen_rtx_REG (DImode, d_regno + 1);\n-\t  rtx di_hi = gen_rtx_REG (DImode, d_regno);\n-\t  rs6000_split_v4si_init_di_reg (di_lo, scalar4, scalar3, tmp1);\n-\t  rs6000_split_v4si_init_di_reg (di_hi, scalar2, scalar1, tmp2);\n-\t}\n-      return;\n-    }\n-\n-  else\n-    gcc_unreachable ();\n-}\n-\n /* Return alignment of TYPE.  Existing alignment is ALIGN.  HOW\n    selects whether the alignment is abi mandated, optional, or\n    both abi and optional alignment.  */"}, {"sha": "de2fa7815a3b18b92ab550e3396e19e805ee2e67", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fede15c4d5f7873ed906eb8cddee7cb35d2cec4/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fede15c4d5f7873ed906eb8cddee7cb35d2cec4/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=9fede15c4d5f7873ed906eb8cddee7cb35d2cec4", "patch": "@@ -388,7 +388,6 @@\n    UNSPEC_VSX_VXSIG\n    UNSPEC_VSX_VIEXP\n    UNSPEC_VSX_VTSTDC\n-   UNSPEC_VSX_VEC_INIT\n    UNSPEC_VSX_VSIGNED2\n \n    UNSPEC_LXVL\n@@ -2946,23 +2945,41 @@\n }\n   [(set_attr \"type\" \"vecperm\")])\n \n-;; V4SImode initialization splitter\n-(define_insn_and_split \"vsx_init_v4si\"\n-  [(set (match_operand:V4SI 0 \"gpc_reg_operand\" \"=&r\")\n-\t(unspec:V4SI\n-\t [(match_operand:SI 1 \"reg_or_cint_operand\" \"rn\")\n-\t  (match_operand:SI 2 \"reg_or_cint_operand\" \"rn\")\n-\t  (match_operand:SI 3 \"reg_or_cint_operand\" \"rn\")\n-\t  (match_operand:SI 4 \"reg_or_cint_operand\" \"rn\")]\n-\t UNSPEC_VSX_VEC_INIT))\n-   (clobber (match_scratch:DI 5 \"=&r\"))\n-   (clobber (match_scratch:DI 6 \"=&r\"))]\n+;; Concatenate 4 SImode elements into a V4SImode reg.\n+(define_expand \"vsx_init_v4si\"\n+  [(use (match_operand:V4SI 0 \"gpc_reg_operand\"))\n+   (use (match_operand:SI 1 \"gpc_reg_operand\"))\n+   (use (match_operand:SI 2 \"gpc_reg_operand\"))\n+   (use (match_operand:SI 3 \"gpc_reg_operand\"))\n+   (use (match_operand:SI 4 \"gpc_reg_operand\"))]\n    \"VECTOR_MEM_VSX_P (V4SImode) && TARGET_DIRECT_MOVE_64BIT\"\n-   \"#\"\n-   \"&& reload_completed\"\n-   [(const_int 0)]\n {\n-  rs6000_split_v4si_init (operands);\n+  rtx a = gen_reg_rtx (DImode);\n+  rtx b = gen_reg_rtx (DImode);\n+  rtx c = gen_reg_rtx (DImode);\n+  rtx d = gen_reg_rtx (DImode);\n+  emit_insn (gen_zero_extendsidi2 (a, operands[1]));\n+  emit_insn (gen_zero_extendsidi2 (b, operands[2]));\n+  emit_insn (gen_zero_extendsidi2 (c, operands[3]));\n+  emit_insn (gen_zero_extendsidi2 (d, operands[4]));\n+  if (!BYTES_BIG_ENDIAN)\n+    {\n+      std::swap (a, b);\n+      std::swap (c, d);\n+    }\n+\n+  rtx aa = gen_reg_rtx (DImode);\n+  rtx ab = gen_reg_rtx (DImode);\n+  rtx cc = gen_reg_rtx (DImode);\n+  rtx cd = gen_reg_rtx (DImode);\n+  emit_insn (gen_ashldi3 (aa, a, GEN_INT (32)));\n+  emit_insn (gen_ashldi3 (cc, c, GEN_INT (32)));\n+  emit_insn (gen_iordi3 (ab, aa, b));\n+  emit_insn (gen_iordi3 (cd, cc, d));\n+\n+  rtx abcd = gen_reg_rtx (V2DImode);\n+  emit_insn (gen_vsx_concat_v2di (abcd, ab, cd));\n+  emit_move_insn (operands[0], gen_lowpart (V4SImode, abcd));\n   DONE;\n })\n "}]}