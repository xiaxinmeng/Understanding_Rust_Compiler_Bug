{"sha": "7c8009267b4fd51593b4aca97b9e958e11f4bcf0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M4MDA5MjY3YjRmZDUxNTkzYjRhY2E5N2I5ZTk1OGUxMWY0YmNmMA==", "commit": {"author": {"name": "Kai Tietz", "email": "kai.tietz@onevision.com", "date": "2008-06-03T08:05:25Z"}, "committer": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2008-06-03T08:05:25Z"}, "message": "tm.texi (OVERRIDE_ABI_FORMAT): New.\n\n2008-06-03  Kai Tietz  <kai.tietz@onevision.com>\n\n\t* doc/tm.texi (OVERRIDE_ABI_FORMAT): New.\n\t* doc/extend.texi (ms_abi,sysv_abi): New attribute description.\n\t* function.c (allocate_struct_function): Use of\n\tOVERRIDE_ABI_FORMAT.\n\t* config/i386/cygming.h (TARGET_64BIT_MS_ABI): Make use\n\tof cfun and DEFAULT_ABI to deceide abi mode.\n\t(DEFAULT_ABI): New.\n\t(REG_PARM_STACK_SPACE): Removed.\n\t(OUTGOING_REG_PARM_STACK_SPACE): Removed.\n\t(STACK_BOUNDARY): Use default target to deceide stack boundary.\n\t* config/i386/i386-protos.h (ix86_cfun_abi): New.\n\t(ix86_function_abi): Likewise.\n\t(ix86_function_type_abi): Likewise.\n\t(ix86_call_abi_override): Likewise.\n\t* confid/i386/i386.md (SSE_REGPARM_MAX): Replaced by abi\n\tspecific define X86_64_SSE_REGPARM_MAX/X64_SSE_REGPARM_MAX.\n\t* config/i386/i386.c (override_options): Replace TARGET_64BIT_MS_ABI.\n\t(X86_64_VARARGS_SIZE): Replace REGPARM_MAX and SSE_REGPARM_MAX by abi\n\tspecific defines.\n\t(X86_64_REGPARM_MAX): New.\n\t(X86_64_SSE_REGPARM_MAX): New.\n\t(X64_REGPARM_MAX): New.\n\t(X64_SSE_REGPARM_MAX): New.\n\t(X86_32_REGPARM_MAX): New.\n\t(X86_32_SSE_REGPARM_MAX): New.\n\t(ix86_handle_cconv_attribute): Replace TARGET_64BIT_MS_ABI.\n\t(ix86_function_regparm): Handle user calling abi.\n\t(ix86_function_arg_regno_p): Replace TARGET_64BIT_MS_ABI\n\tby DEFAULT_ABI versus SYSV_ABI check.\n\t(ix86_reg_parm_stack_space): New.\n\t(ix86_function_type_abi): New.\n\t(ix86_call_abi_override): New.\n\t(ix86_function_abi): New.\n\t(ix86_cfun_abi): New.\n\t(init_cumulative_args): Call abi specific initialization.\n\t(function_arg_advance): Remove TARGET_64BIT_MS_ABI.\n\t(function_arg_64): Extend SSE_REGPARM_MAX check.\n\t(function_arg (): Remove TARGET_64BIT_MS_ABI.\n\t(ix86_pass_by_reference): Likewise.\n\t(ix86_function_value_regno_p): Likewise.\n\t(function_value_64): Replace REGPARM_MAX, and SSE_REGPARM_MAX.\n\t(ix86_function_value_1): Replace TARGET_64BIT_MS_ABI.\n\t(return_in_memory_ms_64): Replace TARGET_64BIT_MS_ABI.\n\t(ix86_build_builtin_va_list): Replace TARGET_64BIT_MS_ABI.\n\t(setup_incoming_varargs_64): Adjust regparm for call abi.\n\t(ix86_setup_incoming_varargs): Replace TARGET_64BIT_MS_ABI.\n\t(ix86_va_start): Likewise.\n\t(ix86_gimplify_va_arg): Likewise.\n\t(ix86_expand_prologue): Likewise.\n\t(output_pic_addr_const): Likewise.\n\t(ix86_init_machine_status): Initialize call_abi by DEFAULT_ABI.\n\t(x86_this_parameter): Replace TARGET_64BIT_MS_ABI.\n\t(x86_output_mi_thunk): Likewise.\n\t(x86_function_profiler): Likewise.\n\t* config/i386/i386.h (TARGET_64BIT_MS_ABI): Use ix64_cfun_abi.\n\t(SYSV_ABI, MS_ABI): New constants.\n\t(DEFAULT_ABI): New.\n\t(init_regs): Add prototype of function in regclass.c file.\n\t(OVERRIDE_ABI_FORMAT): New.\n\t(CONDITIONAL_REGISTER_USAGE): Remove TARGET_64BIT_MS_ABI part.\n\t(REG_PARM_STACK_SPACE): Use ix86_reg_parm_stack_space.\n\t(OUTGOING_REG_PARM_STACK_SPACE): New.\n\t(ix86_reg_parm_stack_space): New prototype.\n\t(CUMULATIVE_ARGS): Add call_abi member.\n\t(machine_function): Add call_abi member.\n\t* config/i386/mingw32.h (EXTRA_OS_CPP_BUILTINS): Replace TARGET_64BIT_MS_ABI\n\tby DEFAULT_ABI compare to MS_ABI.\n\nFrom-SVN: r136311", "tree": {"sha": "46b72aba39009f675c2eb450ebc3d689c165e87a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46b72aba39009f675c2eb450ebc3d689c165e87a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c8009267b4fd51593b4aca97b9e958e11f4bcf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c8009267b4fd51593b4aca97b9e958e11f4bcf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c8009267b4fd51593b4aca97b9e958e11f4bcf0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/comments", "author": null, "committer": null, "parents": [{"sha": "19df69a0d792f6eead0816d6f7b893814dcb5152", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19df69a0d792f6eead0816d6f7b893814dcb5152", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19df69a0d792f6eead0816d6f7b893814dcb5152"}], "stats": {"total": 383, "additions": 320, "deletions": 63}, "files": [{"sha": "7f756464b05421aeb06360bbbb783559175ea8c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7c8009267b4fd51593b4aca97b9e958e11f4bcf0", "patch": "@@ -1,3 +1,73 @@\n+2008-06-03  Kai Tietz  <kai.tietz@onevision.com>\n+\n+\t* doc/tm.texi (OVERRIDE_ABI_FORMAT): New.\n+\t* doc/extend.texi (ms_abi,sysv_abi): New attribute description.\n+\t* function.c (allocate_struct_function): Use of\n+\tOVERRIDE_ABI_FORMAT.\n+\t* config/i386/cygming.h (TARGET_64BIT_MS_ABI): Make use\n+\tof cfun and DEFAULT_ABI to deceide abi mode.\n+\t(DEFAULT_ABI): New.\n+\t(REG_PARM_STACK_SPACE): Removed.\n+\t(OUTGOING_REG_PARM_STACK_SPACE): Removed.\n+\t(STACK_BOUNDARY): Use default target to deceide stack boundary.\n+\t* config/i386/i386-protos.h (ix86_cfun_abi): New.\n+\t(ix86_function_abi): Likewise.\n+\t(ix86_function_type_abi): Likewise.\n+\t(ix86_call_abi_override): Likewise.\n+\t* confid/i386/i386.md (SSE_REGPARM_MAX): Replaced by abi\n+\tspecific define X86_64_SSE_REGPARM_MAX/X64_SSE_REGPARM_MAX.\n+\t* config/i386/i386.c (override_options): Replace TARGET_64BIT_MS_ABI.\n+\t(X86_64_VARARGS_SIZE): Replace REGPARM_MAX and SSE_REGPARM_MAX by abi\n+\tspecific defines.\n+\t(X86_64_REGPARM_MAX): New.\n+\t(X86_64_SSE_REGPARM_MAX): New.\n+\t(X64_REGPARM_MAX): New.\n+\t(X64_SSE_REGPARM_MAX): New.\n+\t(X86_32_REGPARM_MAX): New.\n+\t(X86_32_SSE_REGPARM_MAX): New.\n+\t(ix86_handle_cconv_attribute): Replace TARGET_64BIT_MS_ABI.\n+\t(ix86_function_regparm): Handle user calling abi.\n+\t(ix86_function_arg_regno_p): Replace TARGET_64BIT_MS_ABI\n+\tby DEFAULT_ABI versus SYSV_ABI check.\n+\t(ix86_reg_parm_stack_space): New.\n+\t(ix86_function_type_abi): New.\n+\t(ix86_call_abi_override): New.\n+\t(ix86_function_abi): New.\n+\t(ix86_cfun_abi): New.\n+\t(init_cumulative_args): Call abi specific initialization.\n+\t(function_arg_advance): Remove TARGET_64BIT_MS_ABI.\n+\t(function_arg_64): Extend SSE_REGPARM_MAX check.\n+\t(function_arg (): Remove TARGET_64BIT_MS_ABI.\n+\t(ix86_pass_by_reference): Likewise.\n+\t(ix86_function_value_regno_p): Likewise.\n+\t(function_value_64): Replace REGPARM_MAX, and SSE_REGPARM_MAX.\n+\t(ix86_function_value_1): Replace TARGET_64BIT_MS_ABI.\n+\t(return_in_memory_ms_64): Replace TARGET_64BIT_MS_ABI.\n+\t(ix86_build_builtin_va_list): Replace TARGET_64BIT_MS_ABI.\n+\t(setup_incoming_varargs_64): Adjust regparm for call abi.\n+\t(ix86_setup_incoming_varargs): Replace TARGET_64BIT_MS_ABI.\n+\t(ix86_va_start): Likewise.\n+\t(ix86_gimplify_va_arg): Likewise.\n+\t(ix86_expand_prologue): Likewise.\n+\t(output_pic_addr_const): Likewise.\n+\t(ix86_init_machine_status): Initialize call_abi by DEFAULT_ABI.\n+\t(x86_this_parameter): Replace TARGET_64BIT_MS_ABI.\n+\t(x86_output_mi_thunk): Likewise.\n+\t(x86_function_profiler): Likewise.\n+\t* config/i386/i386.h (TARGET_64BIT_MS_ABI): Use ix64_cfun_abi.\n+\t(SYSV_ABI, MS_ABI): New constants.\n+\t(DEFAULT_ABI): New.\n+\t(init_regs): Add prototype of function in regclass.c file.\n+\t(OVERRIDE_ABI_FORMAT): New.\n+\t(CONDITIONAL_REGISTER_USAGE): Remove TARGET_64BIT_MS_ABI part.\n+\t(REG_PARM_STACK_SPACE): Use ix86_reg_parm_stack_space.\n+\t(OUTGOING_REG_PARM_STACK_SPACE): New.\n+\t(ix86_reg_parm_stack_space): New prototype.\n+\t(CUMULATIVE_ARGS): Add call_abi member.\n+\t(machine_function): Add call_abi member.\n+\t* config/i386/mingw32.h (EXTRA_OS_CPP_BUILTINS): Replace TARGET_64BIT_MS_ABI\n+\tby DEFAULT_ABI compare to MS_ABI.\n+\n 2008-06-02  Andy Hutchinson  <hutchinsonandy@aim.com> \n \n \tPR target/34879"}, {"sha": "1070c85e71d96a73e7853283995bb73bd3eb09e0", "filename": "gcc/config/i386/cygming.h", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/gcc%2Fconfig%2Fi386%2Fcygming.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/gcc%2Fconfig%2Fi386%2Fcygming.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygming.h?ref=7c8009267b4fd51593b4aca97b9e958e11f4bcf0", "patch": "@@ -34,7 +34,10 @@ along with GCC; see the file COPYING3.  If not see\n #endif\n \n #undef TARGET_64BIT_MS_ABI\n-#define TARGET_64BIT_MS_ABI TARGET_64BIT\n+#define TARGET_64BIT_MS_ABI (!cfun ? DEFAULT_ABI == MS_ABI : TARGET_64BIT && cfun->machine->call_abi == MS_ABI)\n+\n+#undef DEFAULT_ABI\n+#define DEFAULT_ABI (TARGET_64BIT ? MS_ABI : SYSV_ABI)\n \n #undef DBX_REGISTER_NUMBER\n #define DBX_REGISTER_NUMBER(n)\t\t\t\t\\\n@@ -123,18 +126,6 @@ along with GCC; see the file COPYING3.  If not see\n #undef LONG_TYPE_SIZE\n #define LONG_TYPE_SIZE 32\n \f\n-#undef REG_PARM_STACK_SPACE\n-#define REG_PARM_STACK_SPACE(FNDECL) (TARGET_64BIT_MS_ABI ? 32 : 0)\n-\n-#undef OUTGOING_REG_PARM_STACK_SPACE\n-#define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) (TARGET_64BIT_MS_ABI ? 1 : 0)\n-\n-#undef REGPARM_MAX\n-#define REGPARM_MAX (TARGET_64BIT_MS_ABI ? 4 : 3)\n-\n-#undef SSE_REGPARM_MAX\n-#define SSE_REGPARM_MAX (TARGET_64BIT_MS_ABI ? 4 : TARGET_SSE ? 3 : 0)\n-\f\n /* Enable parsing of #pragma pack(push,<n>) and #pragma pack(pop).  */\n #define HANDLE_PRAGMA_PACK_PUSH_POP 1\n /* Enable push_macro & pop_macro */\n@@ -214,7 +205,7 @@ do {\t\t\t\t\t\t\\\n #define CHECK_STACK_LIMIT 4000\n \n #undef STACK_BOUNDARY\n-#define STACK_BOUNDARY\t(TARGET_64BIT_MS_ABI ? 128 : BITS_PER_WORD)\n+#define STACK_BOUNDARY\t(DEFAULT_ABI == MS_ABI ? 128 : BITS_PER_WORD)\n \n /* By default, target has a 80387, uses IEEE compatible arithmetic,\n    returns float values in the 387 and needs stack probes."}, {"sha": "a92272bdb388c1ac731c1bd7754ee2b31f8cca6b", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=7c8009267b4fd51593b4aca97b9e958e11f4bcf0", "patch": "@@ -137,6 +137,11 @@ extern int ix86_function_arg_boundary (enum machine_mode, tree);\n extern bool ix86_sol10_return_in_memory (const_tree,const_tree);\n extern rtx ix86_force_to_memory (enum machine_mode, rtx);\n extern void ix86_free_from_memory (enum machine_mode);\n+extern int ix86_cfun_abi (void);\n+extern int ix86_function_abi (const_tree);\n+extern int ix86_function_type_abi (const_tree);\n+extern void ix86_call_abi_override (const_tree);\n+\n extern void ix86_split_fp_branch (enum rtx_code code, rtx, rtx,\n \t\t\t\t  rtx, rtx, rtx, rtx);\n extern bool ix86_hard_regno_mode_ok (int, enum machine_mode);"}, {"sha": "b159ce429283dbaa1d62fb17f8ab8585b12c8b11", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 166, "deletions": 37, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7c8009267b4fd51593b4aca97b9e958e11f4bcf0", "patch": "@@ -1619,7 +1619,7 @@ rtx ix86_compare_op1 = NULL_RTX;\n rtx ix86_compare_emitted = NULL_RTX;\n \n /* Size of the register save area.  */\n-#define X86_64_VARARGS_SIZE (REGPARM_MAX * UNITS_PER_WORD + SSE_REGPARM_MAX * 16)\n+#define X86_64_VARARGS_SIZE (X86_64_REGPARM_MAX * UNITS_PER_WORD + X86_64_SSE_REGPARM_MAX * 16)\n \n /* Define the structure for the machine field in struct function.  */\n \n@@ -2306,11 +2306,11 @@ override_options (void)\n     }\n   else\n     {\n-      /* For TARGET_64BIT_MS_ABI, force pic on, in order to enable the\n+      /* For TARGET_64BIT and MS_ABI, force pic on, in order to enable the\n \t use of rip-relative addressing.  This eliminates fixups that\n \t would otherwise be needed if this object is to be placed in a\n \t DLL, and is essentially just as efficient as direct addressing.  */\n-      if (TARGET_64BIT_MS_ABI)\n+      if (TARGET_64BIT && DEFAULT_ABI == MS_ABI)\n \tix86_cmodel = CM_SMALL_PIC, flag_pic = 1;\n       else if (TARGET_64BIT)\n \tix86_cmodel = flag_pic ? CM_SMALL_PIC : CM_SMALL;\n@@ -2761,8 +2761,9 @@ override_options (void)\n     set_param_value (\"l2-cache-size\", ix86_cost->l2_cache_size);\n \n   /* If using typedef char *va_list, signal that __builtin_va_start (&ap, 0)\n-     can be optimized to ap = __builtin_next_arg (0).  */\n-  if (!TARGET_64BIT || TARGET_64BIT_MS_ABI)\n+     can be optimized to ap = __builtin_next_arg (0).\n+     For abi switching it should be corrected.  */\n+  if (!TARGET_64BIT || DEFAULT_ABI == MS_ABI)\n     targetm.expand_builtin_va_start = NULL;\n \n #ifdef USE_IX86_CLD\n@@ -3166,7 +3167,7 @@ ix86_handle_cconv_attribute (tree *node, tree name,\n   if (TARGET_64BIT)\n     {\n       /* Do not warn when emulating the MS ABI.  */\n-      if (!TARGET_64BIT_MS_ABI)\n+      if (TREE_CODE (*node) != FUNCTION_TYPE || !ix86_function_type_abi (*node))\n \twarning (OPT_Wattributes, \"%qs attribute ignored\",\n \t         IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n@@ -3269,7 +3270,11 @@ ix86_function_regparm (const_tree type, const_tree decl)\n   static bool error_issued;\n \n   if (TARGET_64BIT)\n-    return regparm;\n+    {\n+      if (ix86_function_type_abi (type) == DEFAULT_ABI)\n+        return regparm;\n+      return DEFAULT_ABI != SYSV_ABI ? X86_64_REGPARM_MAX : X64_REGPARM_MAX;\n+    }\n \n   attr = lookup_attribute (\"regparm\", TYPE_ATTRIBUTES (type));\n   if (attr)\n@@ -3500,15 +3505,20 @@ ix86_function_arg_regno_p (int regno)\n         return true;\n     }\n \n+  /* TODO: The function should depend on current function ABI but\n+     builtins.c would need updating then. Therefore we use the\n+     default ABI.  */\n+\n   /* RAX is used as hidden argument to va_arg functions.  */\n-  if (!TARGET_64BIT_MS_ABI && regno == AX_REG)\n+  if (DEFAULT_ABI == SYSV_ABI && regno == AX_REG)\n     return true;\n \n-  if (TARGET_64BIT_MS_ABI)\n+  if (DEFAULT_ABI == MS_ABI)\n     parm_regs = x86_64_ms_abi_int_parameter_registers;\n   else\n     parm_regs = x86_64_int_parameter_registers;\n-  for (i = 0; i < REGPARM_MAX; i++)\n+  for (i = 0; i < (DEFAULT_ABI == MS_ABI ? X64_REGPARM_MAX\n+  \t\t\t\t\t : X86_64_REGPARM_MAX); i++)\n     if (regno == parm_regs[i])\n       return true;\n   return false;\n@@ -3529,6 +3539,98 @@ ix86_must_pass_in_stack (enum machine_mode mode, const_tree type)\n \t  && type && TREE_CODE (type) != VECTOR_TYPE);\n }\n \n+/* It returns the size, in bytes, of the area reserved for arguments passed\n+   in registers for the function represented by fndecl dependent to the used\n+   abi format.  */\n+unsigned int\n+ix86_reg_parm_stack_space (const_tree fndecl)\n+{\n+  int call_abi = 0;\n+  /* For libcalls it is possible that there is no fndecl at hand.\n+     Therefore assume for this case the default abi of the target.  */\n+  if (!fndecl)\n+    call_abi = DEFAULT_ABI;\n+  else\n+    call_abi = ix86_function_abi (fndecl);\n+  if (call_abi == 1)\n+    return 32;\n+  return 0;\n+}\n+\n+/* Returns value SYSV_ABI, MS_ABI dependent on fntype, specifying the\n+   call abi used.  */\n+int\n+ix86_function_type_abi (const_tree fntype)\n+{\n+  if (TARGET_64BIT && fntype != NULL)\n+    {\n+      int abi;\n+      if (DEFAULT_ABI == SYSV_ABI)\n+        abi = lookup_attribute (\"ms_abi\", TYPE_ATTRIBUTES (fntype)) ? MS_ABI : SYSV_ABI;\n+      else\n+        abi = lookup_attribute (\"sysv_abi\", TYPE_ATTRIBUTES (fntype)) ? SYSV_ABI : MS_ABI;\n+\n+      if (DEFAULT_ABI == MS_ABI && abi == SYSV_ABI)\n+        sorry (\"using sysv calling convention on target w64 is not supported\");\n+\n+      return abi;\n+    }\n+  return DEFAULT_ABI;\n+}\n+\n+int\n+ix86_function_abi (const_tree fndecl)\n+{\n+  if (! fndecl)\n+    return DEFAULT_ABI;\n+  return ix86_function_type_abi (TREE_TYPE (fndecl));\n+}\n+\n+/* Returns value SYSV_ABI, MS_ABI dependent on cfun, specifying the\n+   call abi used.  */\n+int\n+ix86_cfun_abi (void)\n+{\n+  if (! cfun || ! TARGET_64BIT)\n+    return DEFAULT_ABI;\n+  return cfun->machine->call_abi;\n+}\n+\n+/* regclass.c  */\n+extern void init_regs (void);\n+\n+/* Implementation of call abi switching target hook. Specific to FNDECL\n+   the specific call register sets are set. See also CONDITIONAL_REGISTER_USAGE\n+   for more details.\n+   To prevent redudant calls of costy function init_regs (), it checks not to\n+   reset register usage for default abi.  */\n+void\n+ix86_call_abi_override (const_tree fndecl)\n+{\n+  if (fndecl == NULL_TREE)\n+    cfun->machine->call_abi = DEFAULT_ABI;\n+  else\n+    cfun->machine->call_abi = ix86_function_type_abi (TREE_TYPE (fndecl));\n+  if (TARGET_64BIT && cfun->machine->call_abi == MS_ABI && call_used_regs)\n+    {\n+      if (call_used_regs[4 /*RSI*/] != 0 || call_used_regs[5 /*RDI*/] != 0)\n+        {\n+          call_used_regs[4 /*RSI*/] = 0;\n+          call_used_regs[5 /*RDI*/] = 0;\n+          init_regs ();\n+        }\n+    }\n+  else if (TARGET_64BIT && call_used_regs)\n+    {\n+      if (call_used_regs[4 /*RSI*/] != 1 || call_used_regs[5 /*RDI*/] != 1)\n+        {\n+          call_used_regs[4 /*RSI*/] = 1;\n+          call_used_regs[5 /*RDI*/] = 1;\n+          init_regs ();\n+        }\n+    }\n+}\n+\n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0.  */\n@@ -3542,10 +3644,25 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n   struct cgraph_local_info *i = fndecl ? cgraph_local_info (fndecl) : NULL;\n   memset (cum, 0, sizeof (*cum));\n \n+  cum->call_abi = ix86_function_type_abi (fntype);\n   /* Set up the number of registers to use for passing arguments.  */\n   cum->nregs = ix86_regparm;\n+  if (TARGET_64BIT)\n+    {\n+      if (cum->call_abi != DEFAULT_ABI)\n+        cum->nregs = DEFAULT_ABI != SYSV_ABI ? X86_64_REGPARM_MAX\n+        \t\t\t\t     : X64_REGPARM_MAX;\n+    }\n   if (TARGET_SSE)\n-    cum->sse_nregs = SSE_REGPARM_MAX;\n+    {\n+      cum->sse_nregs = SSE_REGPARM_MAX;\n+      if (TARGET_64BIT)\n+        {\n+          if (cum->call_abi != DEFAULT_ABI)\n+            cum->sse_nregs = DEFAULT_ABI != SYSV_ABI ? X86_64_SSE_REGPARM_MAX\n+            \t\t\t\t\t     : X64_SSE_REGPARM_MAX;\n+        }\n+    }\n   if (TARGET_MMX)\n     cum->mmx_nregs = MMX_REGPARM_MAX;\n   cum->warn_sse = true;\n@@ -4331,7 +4448,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   if (type)\n     mode = type_natural_mode (type);\n \n-  if (TARGET_64BIT_MS_ABI)\n+  if (TARGET_64BIT && (cum ? cum->call_abi : DEFAULT_ABI) == MS_ABI)\n     function_arg_advance_ms_64 (cum, bytes, words);\n   else if (TARGET_64BIT)\n     function_arg_advance_64 (cum, mode, type, words);\n@@ -4458,8 +4575,11 @@ function_arg_64 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   if (mode == VOIDmode)\n     return GEN_INT (cum->maybe_vaarg\n \t\t    ? (cum->sse_nregs < 0\n-\t\t       ? SSE_REGPARM_MAX\n-\t\t       : cum->sse_regno)\n+\t\t       ? (cum->call_abi == DEFAULT_ABI\n+\t\t          ? SSE_REGPARM_MAX\n+\t\t          : (DEFAULT_ABI != SYSV_ABI ? X86_64_SSE_REGPARM_MAX\n+\t\t          \t\t\t     : X64_SSE_REGPARM_MAX))\n+ \t       : cum->sse_regno)\n \t\t    : -1);\n \n   return construct_container (mode, orig_mode, type, 0, cum->nregs,\n@@ -4533,7 +4653,7 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode omode,\n   if (type && TREE_CODE (type) == VECTOR_TYPE)\n     mode = type_natural_mode (type);\n \n-  if (TARGET_64BIT_MS_ABI)\n+  if (TARGET_64BIT && (cum ? cum->call_abi : DEFAULT_ABI) == MS_ABI)\n     return function_arg_ms_64 (cum, mode, omode, named, bytes);\n   else if (TARGET_64BIT)\n     return function_arg_64 (cum, mode, omode, type);\n@@ -4553,7 +4673,7 @@ ix86_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n \t\t\tconst_tree type, bool named ATTRIBUTE_UNUSED)\n {\n   /* See Windows x64 Software Convention.  */\n-  if (TARGET_64BIT_MS_ABI)\n+  if (TARGET_64BIT && (cum ? cum->call_abi : DEFAULT_ABI) == MS_ABI)\n     {\n       int msize = (int) GET_MODE_SIZE (mode);\n       if (type)\n@@ -4686,7 +4806,10 @@ ix86_function_value_regno_p (int regno)\n       return true;\n \n     case FIRST_FLOAT_REG:\n-      if (TARGET_64BIT_MS_ABI)\n+      /* TODO: The function should depend on current function ABI but\n+       builtins.c would need updating then. Therefore we use the\n+       default ABI.  */\n+      if (TARGET_64BIT && DEFAULT_ABI == MS_ABI)\n \treturn false;\n       return TARGET_FLOAT_RETURNS_IN_80387;\n \n@@ -4777,7 +4900,7 @@ function_value_64 (enum machine_mode orig_mode, enum machine_mode mode,\n     }\n \n   ret = construct_container (mode, orig_mode, valtype, 1,\n-\t\t\t     REGPARM_MAX, SSE_REGPARM_MAX,\n+\t\t\t     X86_64_REGPARM_MAX, X86_64_SSE_REGPARM_MAX,\n \t\t\t     x86_64_int_return_registers, 0);\n \n   /* For zero sized structures, construct_container returns NULL, but we\n@@ -4825,7 +4948,7 @@ ix86_function_value_1 (const_tree valtype, const_tree fntype_or_decl,\n     fn = fntype_or_decl;\n   fntype = fn ? TREE_TYPE (fn) : fntype_or_decl;\n \n-  if (TARGET_64BIT_MS_ABI)\n+  if (TARGET_64BIT && ix86_function_type_abi (fntype) == MS_ABI)\n     return function_value_ms_64 (orig_mode, mode);\n   else if (TARGET_64BIT)\n     return function_value_64 (orig_mode, mode, valtype);\n@@ -5022,7 +5145,7 @@ ix86_build_builtin_va_list (void)\n   tree f_gpr, f_fpr, f_ovf, f_sav, record, type_decl;\n \n   /* For i386 we use plain pointer to argument area.  */\n-  if (!TARGET_64BIT || TARGET_64BIT_MS_ABI)\n+  if (!TARGET_64BIT || ix86_cfun_abi () == MS_ABI)\n     return build_pointer_type (char_type_node);\n \n   record = (*lang_hooks.types.make_type) (RECORD_TYPE);\n@@ -5070,6 +5193,10 @@ setup_incoming_varargs_64 (CUMULATIVE_ARGS *cum)\n   rtx nsse_reg;\n   alias_set_type set;\n   int i;\n+  int regparm = ix86_regparm;\n+\n+  if((cum ? cum->call_abi : ix86_cfun_abi ()) != DEFAULT_ABI)\n+    regparm = DEFAULT_ABI != SYSV_ABI ? X86_64_REGPARM_MAX : X64_REGPARM_MAX;\n \n   if (! cfun->va_list_gpr_size && ! cfun->va_list_fpr_size)\n     return;\n@@ -5089,7 +5216,7 @@ setup_incoming_varargs_64 (CUMULATIVE_ARGS *cum)\n   set = get_varargs_alias_set ();\n \n   for (i = cum->regno;\n-       i < ix86_regparm\n+       i < regparm\n        && i < cum->regno + cfun->va_list_gpr_size / UNITS_PER_WORD;\n        i++)\n     {\n@@ -5136,7 +5263,7 @@ setup_incoming_varargs_64 (CUMULATIVE_ARGS *cum)\n       tmp_reg = gen_reg_rtx (Pmode);\n       emit_insn (gen_rtx_SET (VOIDmode, tmp_reg,\n \t\t\t      plus_constant (save_area,\n-\t\t\t\t\t     8 * REGPARM_MAX + 127)));\n+\t\t\t\t\t     8 * X86_64_REGPARM_MAX + 127)));\n       mem = gen_rtx_MEM (BLKmode, plus_constant (tmp_reg, -127));\n       MEM_NOTRAP_P (mem) = 1;\n       set_mem_alias_set (mem, set);\n@@ -5154,7 +5281,7 @@ setup_incoming_varargs_ms_64 (CUMULATIVE_ARGS *cum)\n   alias_set_type set = get_varargs_alias_set ();\n   int i;\n \n-  for (i = cum->regno; i < REGPARM_MAX; i++)\n+  for (i = cum->regno; i < X64_REGPARM_MAX; i++)\n     {\n       rtx reg, mem;\n \n@@ -5192,7 +5319,7 @@ ix86_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   if (stdarg_p (fntype))\n     function_arg_advance (&next_cum, mode, type, 1);\n \n-  if (TARGET_64BIT_MS_ABI)\n+  if ((cum ? cum->call_abi : DEFAULT_ABI) == MS_ABI)\n     setup_incoming_varargs_ms_64 (&next_cum);\n   else\n     setup_incoming_varargs_64 (&next_cum);\n@@ -5209,7 +5336,7 @@ ix86_va_start (tree valist, rtx nextarg)\n   tree type;\n \n   /* Only 64bit target needs something special.  */\n-  if (!TARGET_64BIT || TARGET_64BIT_MS_ABI)\n+  if (!TARGET_64BIT || cfun->machine->call_abi == MS_ABI)\n     {\n       std_expand_builtin_va_start (valist, nextarg);\n       return;\n@@ -5244,7 +5371,7 @@ ix86_va_start (tree valist, rtx nextarg)\n     {\n       type = TREE_TYPE (fpr);\n       t = build2 (GIMPLE_MODIFY_STMT, type, fpr,\n-\t\t  build_int_cst (type, n_fpr * 16 + 8*REGPARM_MAX));\n+\t\t  build_int_cst (type, n_fpr * 16 + 8*X86_64_REGPARM_MAX));\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n@@ -5288,7 +5415,7 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   enum machine_mode nat_mode;\n \n   /* Only 64bit target needs something special.  */\n-  if (!TARGET_64BIT || TARGET_64BIT_MS_ABI)\n+  if (!TARGET_64BIT || cfun->machine->call_abi == MS_ABI)\n     return std_gimplify_va_arg_expr (valist, type, pre_p, post_p);\n \n   f_gpr = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n@@ -5310,7 +5437,8 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \n   nat_mode = type_natural_mode (type);\n   container = construct_container (nat_mode, TYPE_MODE (type), type, 0,\n-\t\t\t\t   REGPARM_MAX, SSE_REGPARM_MAX, intreg, 0);\n+\t\t\t\t   X86_64_REGPARM_MAX, X86_64_SSE_REGPARM_MAX,\n+\t\t\t\t   intreg, 0);\n \n   /* Pull the value out of the saved registers.  */\n \n@@ -5379,7 +5507,7 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n       if (needed_intregs)\n \t{\n \t  t = build_int_cst (TREE_TYPE (gpr),\n-\t\t\t     (REGPARM_MAX - needed_intregs + 1) * 8);\n+\t\t\t     (X86_64_REGPARM_MAX - needed_intregs + 1) * 8);\n \t  t = build2 (GE_EXPR, boolean_type_node, gpr, t);\n \t  t2 = build1 (GOTO_EXPR, void_type_node, lab_false);\n \t  t = build3 (COND_EXPR, void_type_node, t, t2, NULL_TREE);\n@@ -5388,8 +5516,8 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n       if (needed_sseregs)\n \t{\n \t  t = build_int_cst (TREE_TYPE (fpr),\n-\t\t\t     (SSE_REGPARM_MAX - needed_sseregs + 1) * 16\n-\t\t\t     + REGPARM_MAX * 8);\n+\t\t\t     (X86_64_SSE_REGPARM_MAX - needed_sseregs + 1) * 16\n+\t\t\t     + X86_64_REGPARM_MAX * 8);\n \t  t = build2 (GE_EXPR, boolean_type_node, fpr, t);\n \t  t2 = build1 (GOTO_EXPR, void_type_node, lab_false);\n \t  t = build3 (COND_EXPR, void_type_node, t, t2, NULL_TREE);\n@@ -6515,9 +6643,9 @@ ix86_expand_prologue (void)\n       bool eax_live;\n       rtx t;\n \n-      gcc_assert (!TARGET_64BIT || TARGET_64BIT_MS_ABI);\n+      gcc_assert (!TARGET_64BIT || cfun->machine->call_abi == MS_ABI);\n \n-      if (TARGET_64BIT_MS_ABI)\n+      if (cfun->machine->call_abi == MS_ABI)\n \teax_live = false;\n       else\n \teax_live = ix86_eax_live_at_start_p ();\n@@ -8331,7 +8459,7 @@ output_pic_addr_const (FILE *file, rtx x, int code)\n #endif\n \t  assemble_name (file, name);\n \t}\n-      if (!TARGET_MACHO && !TARGET_64BIT_MS_ABI\n+      if (!TARGET_MACHO && !(TARGET_64BIT && DEFAULT_ABI == MS_ABI)\n \t  && code == 'P' && ! SYMBOL_REF_LOCAL_P (x))\n \tfputs (\"@PLT\", file);\n       break;\n@@ -16422,6 +16550,7 @@ ix86_init_machine_status (void)\n   f = GGC_CNEW (struct machine_function);\n   f->use_fast_prologue_epilogue_nregs = -1;\n   f->tls_descriptor_call_expanded_p = 0;\n+  f->call_abi = DEFAULT_ABI;\n \n   return f;\n }\n@@ -23009,7 +23138,7 @@ x86_this_parameter (tree function)\n     {\n       const int *parm_regs;\n \n-      if (TARGET_64BIT_MS_ABI)\n+      if (ix86_function_type_abi (type) == MS_ABI)\n         parm_regs = x86_64_ms_abi_int_parameter_registers;\n       else\n         parm_regs = x86_64_int_parameter_registers;\n@@ -23177,7 +23306,7 @@ x86_output_mi_thunk (FILE *file ATTRIBUTE_UNUSED,\n \toutput_asm_insn (\"jmp\\t%P0\", xops);\n       /* All thunks should be in the same object as their target,\n \t and thus binds_local_p should be true.  */\n-      else if (TARGET_64BIT_MS_ABI)\n+      else if (TARGET_64BIT && cfun->machine->call_abi == MS_ABI)\n \tgcc_unreachable ();\n       else\n \t{\n@@ -23259,7 +23388,7 @@ x86_function_profiler (FILE *file, int labelno ATTRIBUTE_UNUSED)\n       fprintf (file, \"\\tleaq\\t%sP%d@(%%rip),%%r11\\n\", LPREFIX, labelno);\n #endif\n \n-      if (!TARGET_64BIT_MS_ABI && flag_pic)\n+      if (DEFAULT_ABI == SYSV_ABI && flag_pic)\n \tfprintf (file, \"\\tcall\\t*%s@GOTPCREL(%%rip)\\n\", MCOUNT_NAME);\n       else\n \tfprintf (file, \"\\tcall\\t%s\\n\", MCOUNT_NAME);"}, {"sha": "552515fc6c3b53c5398861dc239654b187f6c924", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=7c8009267b4fd51593b4aca97b9e958e11f4bcf0", "patch": "@@ -446,7 +446,17 @@ extern tree x86_mfence;\n #define TARGET_MACHO 0\n \n /* Likewise, for the Windows 64-bit ABI.  */\n-#define TARGET_64BIT_MS_ABI 0\n+#define TARGET_64BIT_MS_ABI (TARGET_64BIT && ix86_cfun_abi () == MS_ABI)\n+\n+/* Available call abi.  */\n+enum\n+{\n+  SYSV_ABI = 0,\n+  MS_ABI = 1\n+};\n+\n+/* The default abi form used by target.  */\n+#define DEFAULT_ABI SYSV_ABI\n \n /* Subtargets may reset this to 1 in order to enable 96-bit long double\n    with the rounding mode forced to 53 bits.  */\n@@ -804,7 +814,8 @@ enum target_cpu_default\n #define PARM_BOUNDARY BITS_PER_WORD\n \n /* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY BITS_PER_WORD\n+#define STACK_BOUNDARY\t(TARGET_64BIT && DEFAULT_ABI == MS_ABI ? 128 \\\n+\t\t\t\t\t\t\t       : BITS_PER_WORD)\n \n /* Boundary (in *bits*) on which the stack pointer prefers to be\n    aligned; the compiler cannot rely on having this alignment.  */\n@@ -1044,6 +1055,8 @@ enum target_cpu_default\n #define ORDER_REGS_FOR_LOCAL_ALLOC x86_order_regs_for_local_alloc ()\n \n \n+#define OVERRIDE_ABI_FORMAT(FNDECL) ix86_call_abi_override (FNDECL)\n+\n /* Macro to conditionally modify fixed_regs/call_used_regs.  */\n #define CONDITIONAL_REGISTER_USAGE\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n@@ -1094,7 +1107,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \tfor (i = FIRST_REX_SSE_REG; i <= LAST_REX_SSE_REG; i++)\t\t\\\n \t  reg_names[i] = \"\";\t\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n-    if (TARGET_64BIT_MS_ABI)\t\t\t\t\t\t\\\n+    if (TARGET_64BIT && DEFAULT_ABI == MS_ABI)\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n         call_used_regs[4 /*RSI*/] = 0;                                  \\\n         call_used_regs[5 /*RDI*/] = 0;                                  \\\n@@ -1624,7 +1637,11 @@ enum reg_class\n    This space can be allocated by the caller, or be a part of the\n    machine-dependent stack frame: `OUTGOING_REG_PARM_STACK_SPACE' says\n    which.  */\n-#define REG_PARM_STACK_SPACE(FNDECL) 0\n+#define REG_PARM_STACK_SPACE(FNDECL) ix86_reg_parm_stack_space (FNDECL)\n+\n+#define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) (ix86_function_type_abi (FNTYPE) == MS_ABI ? 1 : 0)\n+\n+extern unsigned int ix86_reg_parm_stack_space (const_tree);\n \n /* Value is the number of bytes of arguments automatically\n    popped when returning from a subroutine call.\n@@ -1686,6 +1703,8 @@ typedef struct ix86_args {\n   int maybe_vaarg;\t\t/* true for calls to possibly vardic fncts.  */\n   int float_in_sse;\t\t/* 1 if in 32-bit mode SFmode (2 for DFmode) should\n \t\t\t\t   be passed in SSE registers.  Otherwise 0.  */\n+  int call_abi;\t\t\t/* Set to SYSV_ABI for sysv abi. Otherwise\n+ \t\t\t\t   MS_ABI for ms abi.  */\n } CUMULATIVE_ARGS;\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n@@ -1953,9 +1972,22 @@ do {\t\t\t\t\t\t\t\t\t\\\n    is also used as the pic register in ELF.  So for now, don't allow more than\n    3 registers to be passed in registers.  */\n \n-#define REGPARM_MAX (TARGET_64BIT ? 6 : 3)\n+/* Abi specific values for REGPARM_MAX and SSE_REGPARM_MAX */\n+#define X86_64_REGPARM_MAX 6\n+#define X64_REGPARM_MAX 4\n+#define X86_32_REGPARM_MAX 3\n+\n+#define X86_64_SSE_REGPARM_MAX 8\n+#define X64_SSE_REGPARM_MAX 4\n+#define X86_32_SSE_REGPARM_MAX (TARGET_SSE ? 3 : 0)\n+\n+#define REGPARM_MAX (TARGET_64BIT ? (TARGET_64BIT_MS_ABI ? X64_REGPARM_MAX \\\n+\t\t\t\t\t\t\t : X86_64_REGPARM_MAX) \\\n+\t\t\t\t  : X86_32_REGPARM_MAX)\n \n-#define SSE_REGPARM_MAX (TARGET_64BIT ? 8 : (TARGET_SSE ? 3 : 0))\n+#define SSE_REGPARM_MAX (TARGET_64BIT ? (TARGET_64BIT_MS_ABI ? X64_SSE_REGPARM_MAX \\\n+\t\t\t\t\t\t\t     : X86_64_SSE_REGPARM_MAX) \\\n+\t\t\t\t      : X86_32_SSE_REGPARM_MAX)\n \n #define MMX_REGPARM_MAX (TARGET_64BIT ? 0 : (TARGET_MMX ? 3 : 0))\n \n@@ -2464,6 +2496,9 @@ struct machine_function GTY(())\n      ix86_current_function_calls_tls_descriptor macro for a better\n      approximation.  */\n   int tls_descriptor_call_expanded_p;\n+  /* This value is used for amd64 targets and specifies the current abi\n+     to be used. MS_ABI means ms abi. Otherwise SYSV_ABI means sysv abi.  */\n+  int call_abi;\n };\n \n #define ix86_stack_locals (cfun->machine->stack_locals)"}, {"sha": "ba438fee50f703fff5b0cf3d4a1e72937ffca57b", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=7c8009267b4fd51593b4aca97b9e958e11f4bcf0", "patch": "@@ -14708,7 +14708,10 @@\n \n   ix86_expand_call ((TARGET_FLOAT_RETURNS_IN_80387\n \t\t     ? gen_rtx_REG (XCmode, FIRST_FLOAT_REG) : NULL),\n-\t\t    operands[0], const0_rtx, GEN_INT (SSE_REGPARM_MAX - 1),\n+\t\t    operands[0], const0_rtx,\n+\t\t    GEN_INT ((DEFAULT_ABI == SYSV_ABI ? X86_64_SSE_REGPARM_MAX\n+\t\t    \t\t\t\t      : X64_SSE_REGPARM_MAX)\n+\t\t    \t     - 1),\n \t\t    NULL, 0);\n \n   for (i = 0; i < XVECLEN (operands[2], 0); i++)\n@@ -20846,14 +20849,14 @@\n    (use (match_operand:DI 2 \"const_int_operand\" \"i\"))\n    (use (label_ref:DI (match_operand 3 \"\" \"X\")))]\n   \"TARGET_64BIT\n-   && INTVAL (operands[4]) + SSE_REGPARM_MAX * 16 - 16 < 128\n+   && INTVAL (operands[4]) + X86_64_SSE_REGPARM_MAX * 16 - 16 < 128\n    && INTVAL (operands[4]) + INTVAL (operands[2]) * 16 >= -128\"\n {\n   int i;\n   operands[0] = gen_rtx_MEM (Pmode,\n \t\t\t     gen_rtx_PLUS (Pmode, operands[0], operands[4]));\n   output_asm_insn (\"jmp\\t%A1\", operands);\n-  for (i = SSE_REGPARM_MAX - 1; i >= INTVAL (operands[2]); i--)\n+  for (i = X86_64_SSE_REGPARM_MAX - 1; i >= INTVAL (operands[2]); i--)\n     {\n       operands[4] = adjust_address (operands[0], DImode, i*16);\n       operands[5] = gen_rtx_REG (TImode, SSE_REGNO (i));"}, {"sha": "7628896bc6a443df688bf35cb582c9e070b89926", "filename": "gcc/config/i386/mingw32.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/gcc%2Fconfig%2Fi386%2Fmingw32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/gcc%2Fconfig%2Fi386%2Fmingw32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmingw32.h?ref=7c8009267b4fd51593b4aca97b9e958e11f4bcf0", "patch": "@@ -38,7 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n       builtin_define_std (\"WINNT\");\t\t\t\t\\\n       builtin_define_with_int_value (\"_INTEGRAL_MAX_BITS\",\t\\\n \t\t\t\t     TYPE_PRECISION (intmax_type_node));\\\n-      if (TARGET_64BIT_MS_ABI)\t\t\t\t\t\\\n+      if (TARGET_64BIT && DEFAULT_ABI == MS_ABI)\t\t\t\\\n \t{\t\t\t\t\t\t\t\\\n \t  builtin_define (\"__MINGW64__\");\t\t\t\\\n \t  builtin_define_std (\"WIN64\");\t\t\t\t\\"}, {"sha": "9c025608e64ff4448269133f89acf20997188482", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=7c8009267b4fd51593b4aca97b9e958e11f4bcf0", "patch": "@@ -2508,6 +2508,19 @@ instruction).  Caveat: such addressing is by definition not position\n independent and hence this attribute must not be used for objects\n defined by shared libraries.\n \n+@item ms_abi/sysv_abi\n+@cindex @code[ms_abi} attribute\n+@cindex @code{sysv_abi} attribute\n+\n+On 64-bit x86_65-*-* targets, you can use an ABI attribute to indicate\n+which calling convention should be used for a function.  The @code{ms_abi}\n+attribute tells the compiler to use the Microsoft ABI, while the\n+@code{sysv_abi} attribute tells the compiler to use the ABI used on\n+GNU/Linux and other systems.  The default is to use the Microsoft ABI\n+when targeting Windows.  On all other systems, the default is the AMD ABI.\n+\n+Note, This feature is currently sorried out for Windows targets trying to\n+\n @item naked\n @cindex function without a prologue/epilogue code\n Use this attribute on the ARM, AVR, IP2K and SPU ports to indicate that"}, {"sha": "d18bf2e00e950a075f315b64575892b9a4d72b95", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=7c8009267b4fd51593b4aca97b9e958e11f4bcf0", "patch": "@@ -4055,6 +4055,15 @@ arguments are passed on the stack, there is no need to store anything in\n should not be empty, so use @code{int}.\n @end defmac\n \n+@defmac OVERRIDE_ABI_FORMAT (@var{fndecl})\n+If defined, this macro is called before generating any code for a\n+function, but after the @var{cfun} descriptor for the function has been\n+created.  The back end may use this macro to update @var{cfun} to\n+reflect an ABI other than that which would normally be used by default.\n+If the compiler is generating code for a compiler-generated function,\n+@var{fndecl} may be @code{NULL}.\n+@end defmac\n+\n @defmac INIT_CUMULATIVE_ARGS (@var{cum}, @var{fntype}, @var{libname}, @var{fndecl}, @var{n_named_args})\n A C statement (sans semicolon) for initializing the variable\n @var{cum} for the state at the beginning of the argument list.  The"}, {"sha": "30dd9f302a04d908ef6961088176702685124cd8", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=7c8009267b4fd51593b4aca97b9e958e11f4bcf0", "patch": "@@ -3852,6 +3852,10 @@ allocate_struct_function (tree fndecl, bool abstract_p)\n   if (init_machine_status)\n     cfun->machine = (*init_machine_status) ();\n \n+#ifdef OVERRIDE_ABI_FORMAT\n+  OVERRIDE_ABI_FORMAT (fndecl);\n+#endif\n+\n   if (fndecl != NULL_TREE)\n     {\n       DECL_STRUCT_FUNCTION (fndecl) = cfun;"}, {"sha": "69b6169bf47b25a16e97772aa25abac927576752", "filename": "gcc/target-def.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c8009267b4fd51593b4aca97b9e958e11f4bcf0/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=7c8009267b4fd51593b4aca97b9e958e11f4bcf0", "patch": "@@ -545,9 +545,7 @@\n #define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_false\n \n #define TARGET_STRUCT_VALUE_RTX hook_rtx_tree_int_null\n-#ifndef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY default_return_in_memory\n-#endif\n #define TARGET_RETURN_IN_MSB hook_bool_const_tree_false\n \n #define TARGET_EXPAND_BUILTIN_SAVEREGS default_expand_builtin_saveregs"}]}