{"sha": "997704f18b252a1063f514a716fbf6b636f62620", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk3NzA0ZjE4YjI1MmExMDYzZjUxNGE3MTZmYmY2YjYzNmY2MjYyMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2009-07-01T23:21:17Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2009-07-01T23:21:17Z"}, "message": "re PR bootstrap/40347 (i386-darwin ICEs while building libgcc during stage2)\n\n\tPR bootstrap/40347\n\t* function.c (reposition_prologue_and_epilogue_notes): If epilogue\n\tcontained no insns, reposition note before last insn.\n\nFrom-SVN: r149158", "tree": {"sha": "2863da00a857ad078f33c3cdf9b6b6552c38c036", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2863da00a857ad078f33c3cdf9b6b6552c38c036"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/997704f18b252a1063f514a716fbf6b636f62620", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/997704f18b252a1063f514a716fbf6b636f62620", "html_url": "https://github.com/Rust-GCC/gccrs/commit/997704f18b252a1063f514a716fbf6b636f62620", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/997704f18b252a1063f514a716fbf6b636f62620/comments", "author": null, "committer": null, "parents": [{"sha": "9f2af3cef8463e296639cfaa5811c38b2dabeae5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f2af3cef8463e296639cfaa5811c38b2dabeae5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f2af3cef8463e296639cfaa5811c38b2dabeae5"}], "stats": {"total": 44, "additions": 29, "deletions": 15}, "files": [{"sha": "eecd91b213f008ca50f18ebf092a4bb336fc3053", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997704f18b252a1063f514a716fbf6b636f62620/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997704f18b252a1063f514a716fbf6b636f62620/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=997704f18b252a1063f514a716fbf6b636f62620", "patch": "@@ -1,3 +1,9 @@\n+2009-07-01  Richard Henderson  <rth@redhat.com>\n+\n+\tPR bootstrap/40347\n+\t* function.c (reposition_prologue_and_epilogue_notes): If epilogue\n+\tcontained no insns, reposition note before last insn.\n+\n 2009-07-01  Richard Henderson  <rth@redhat.com>\n \n \tPR debug/40431"}, {"sha": "63fe8353089fa52fe87d86c0a77fdc380f4fd461", "filename": "gcc/function.c", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997704f18b252a1063f514a716fbf6b636f62620/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997704f18b252a1063f514a716fbf6b636f62620/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=997704f18b252a1063f514a716fbf6b636f62620", "patch": "@@ -5283,15 +5283,12 @@ reposition_prologue_and_epilogue_notes (void)\n {\n #if defined (HAVE_prologue) || defined (HAVE_epilogue) \\\n     || defined (HAVE_sibcall_epilogue)\n-  rtx insn, last, note;\n-  basic_block bb;\n-\n   /* Since the hash table is created on demand, the fact that it is\n      non-null is a signal that it is non-empty.  */\n   if (prologue_insn_hash != NULL)\n     {\n       size_t len = htab_elements (prologue_insn_hash);\n-      last = 0, note = 0;\n+      rtx insn, last = NULL, note = NULL;\n \n       /* Scan from the beginning until we reach the last prologue insn.  */\n       /* ??? While we do have the CFG intact, there are two problems:\n@@ -5342,33 +5339,44 @@ reposition_prologue_and_epilogue_notes (void)\n \n       FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n \t{\n-\t  last = 0, note = 0;\n-\t  bb = e->src;\n+\t  rtx insn, first = NULL, note = NULL;\n+\t  basic_block bb = e->src;\n \n-\t  /* Scan from the beginning until we reach the first epilogue insn.\n-\t     Take the cue for whether this is a plain or sibcall epilogue\n-\t     from the kind of note we find first.  */\n+\t  /* Scan from the beginning until we reach the first epilogue insn. */\n \t  FOR_BB_INSNS (bb, insn)\n \t    {\n \t      if (NOTE_P (insn))\n \t\t{\n \t\t  if (NOTE_KIND (insn) == NOTE_INSN_EPILOGUE_BEG)\n \t\t    {\n \t\t      note = insn;\n-\t\t      if (last)\n+\t\t      if (first != NULL)\n \t\t\tbreak;\n \t\t    }\n \t\t}\n-\t      else if (contains (insn, epilogue_insn_hash))\n+\t      else if (first == NULL && contains (insn, epilogue_insn_hash))\n \t\t{\n-\t\t  last = insn;\n+\t\t  first = insn;\n \t\t  if (note != NULL)\n \t\t    break;\n \t\t}\n \t    }\n-\t     \n-\t  if (last && note && PREV_INSN (last) != note)\n-\t    reorder_insns (note, note, PREV_INSN (last));\n+\n+\t  if (note)\n+\t    {\n+\t      /* If the function has a single basic block, and no real\n+\t\t epilogue insns (e.g. sibcall with no cleanup), the \n+\t\t epilogue note can get scheduled before the prologue\n+\t\t note.  If we have frame related prologue insns, having\n+\t\t them scanned during the epilogue will result in a crash.\n+\t\t In this case re-order the epilogue note to just before\n+\t\t the last insn in the block.  */\n+\t      if (first == NULL)\n+\t\tfirst = BB_END (bb);\n+\n+\t      if (PREV_INSN (first) != note)\n+\t\treorder_insns (note, note, PREV_INSN (first));\n+\t    }\n \t}\n     }\n #endif /* HAVE_prologue or HAVE_epilogue */"}]}