{"sha": "f73ad30e011e5fa64e634e576bd6297b667f9364", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjczYWQzMGUwMTFlNWZhNjRlNjM0ZTU3NmJkNjI5N2I2NjdmOTM2NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-03-29T13:10:44Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-03-29T13:10:44Z"}, "message": "Convert ACCUMULATE_OUTGOING_ARGS to an expression.\n\n\t* calls.c (PUSH_ARGS_REVERSED) Change to expression.\n\t(ACCUMULATE_OUTGOING_ARGS, PUSH_ARGS): Provide default value.\n\t(struct arg_data): Remove #ifdef ACCUMULATE_OUTGOING_ARGS.\n\t(save_fixed_argument_area, restore_fixed_argument_area):\n\tconditionize by #ifdef REG_PARM_STACK_SPACE only.\n\t(emit_call): Change #ifdefs on ACCUMULATE_OUTGOING_ARGS\n\tto conditions, handle RETURN_POPS_ARGS on ACCUMULATE_OUTGOING_ARGS.\n\t(precompute_register_parameters): Avoid #ifdefs on\n\tACCUMULATE_OUTGOING_ARGS and PUSH_ARGS_REVERSED.\n\t(stire_one_args): Likewise.\n\t(expand_call): Likewise; conditionize PUSH_ROUNDING code by PUSH_ARGS.\n\t(emit_library_call_value_1): Likewise.\n\t(compute_argument_block_size): Align to STACK_BOUNDARY only for\n\tACCUMULATE_OUTGOING_ARGS.\n\t* combine.c (ACCUMULATE_OUTGOING_ARGS, PUSH_ARGS): Provide default\n\tvalue.\n\t(nonzero_bits): Conditionize PUSH_ROUNDING code by USE_PUSH.\n\t(use_crosses_set_p): Likewise.\n\t* all targets (ACCUMULATE_OUTGOING_ARGS define): Change to\n\t#define ACCUMULATE_OUTGOING_ARGS 1.\n\t* i386.c (ix86_compute_frame_size): Handle ACCUMULATE_OUTGOING_ARGS\n\tframes.\n\t* i386.h (MASK_NO_PUSH_ARGS, MASK_ACCUMULATE_OUTGOING_ARGS): New\n\tconstants.\n\t(TARGET_PUSH_ARGS, TARGET_ACCUMULATE_OUTGOING_ARGS): New macros.\n\t(TARGET_SWITCHES): Add push-args, no-push-args,\n\taccumulate-outgoing-args and no-accumulate-outgoing-args.\n\t(ACCUMULATE_OUTGOING_ARGS, PUSH_ARGS): New macro.\n\t* expr.c (ACCUMULATE_OUTGONG_ARGS, PUSH_ARGS): Provide default.\n\t(push_block): Avoid ifdefs on ACCUMULATE_OUTGONG_ARGS\n\tand PUSH_ROUNDING.\n\t(emit_push_insn): Likewise.\n\t* final.c (ACCUMULATE_OUTGOING_ARGS): Provide default.\n\t(final_scan_insn): Avoid ifdefs on ACCUMULATE_OUTGOING_ARGS.\n\t* function.c (ACCUMULATE_OUTGOING_ARGS): Provide default.\n\t(STACK_DYNAMIC_OFFSET): Define correctly for both\n\tACCUMULATE_OUTGOING_ARGS and normal mode.\n\t* invoke.texi (-mpush_args, -maccumulate-outgoing-args): Document.\n\t* tm.texi (PUSH_ARGS): Document.\n\t(ACCUMULATE_OUTGOING_ARGS, PUSH_ROUNDING): Update documentation.\n\nFrom-SVN: r32803", "tree": {"sha": "f907c433c28df15d0d9341afb54624130db44220", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f907c433c28df15d0d9341afb54624130db44220"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f73ad30e011e5fa64e634e576bd6297b667f9364", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f73ad30e011e5fa64e634e576bd6297b667f9364", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f73ad30e011e5fa64e634e576bd6297b667f9364", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f73ad30e011e5fa64e634e576bd6297b667f9364/comments", "author": null, "committer": null, "parents": [{"sha": "db8cb48e64684efc2956b1229e9b1fbac558229a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db8cb48e64684efc2956b1229e9b1fbac558229a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db8cb48e64684efc2956b1229e9b1fbac558229a"}], "stats": {"total": 1277, "additions": 724, "deletions": 553}, "files": [{"sha": "72b5fe951ff3223579104a7281b2e2bcaa79b9bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -1,3 +1,47 @@\n+Wed Mar 29 15:08:01 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\tConvert ACCUMULATE_OUTGOING_ARGS to an expression.\n+\t* calls.c (PUSH_ARGS_REVERSED) Change to expression.\n+\t(ACCUMULATE_OUTGOING_ARGS, PUSH_ARGS): Provide default value.\n+\t(struct arg_data): Remove #ifdef ACCUMULATE_OUTGOING_ARGS.\n+\t(save_fixed_argument_area, restore_fixed_argument_area):\n+\tconditionize by #ifdef REG_PARM_STACK_SPACE only.\n+\t(emit_call): Change #ifdefs on ACCUMULATE_OUTGOING_ARGS\n+\tto conditions, handle RETURN_POPS_ARGS on ACCUMULATE_OUTGOING_ARGS.\n+\t(precompute_register_parameters): Avoid #ifdefs on\n+\tACCUMULATE_OUTGOING_ARGS and PUSH_ARGS_REVERSED.\n+\t(stire_one_args): Likewise.\n+\t(expand_call): Likewise; conditionize PUSH_ROUNDING code by PUSH_ARGS.\n+\t(emit_library_call_value_1): Likewise.\n+\t(compute_argument_block_size): Align to STACK_BOUNDARY only for\n+\tACCUMULATE_OUTGOING_ARGS.\n+\t* combine.c (ACCUMULATE_OUTGOING_ARGS, PUSH_ARGS): Provide default\n+\tvalue.\n+\t(nonzero_bits): Conditionize PUSH_ROUNDING code by USE_PUSH.\n+\t(use_crosses_set_p): Likewise.\n+\t* all targets (ACCUMULATE_OUTGOING_ARGS define): Change to\n+\t#define ACCUMULATE_OUTGOING_ARGS 1.\n+\t* i386.c (ix86_compute_frame_size): Handle ACCUMULATE_OUTGOING_ARGS\n+\tframes.\n+\t* i386.h (MASK_NO_PUSH_ARGS, MASK_ACCUMULATE_OUTGOING_ARGS): New\n+\tconstants.\n+\t(TARGET_PUSH_ARGS, TARGET_ACCUMULATE_OUTGOING_ARGS): New macros.\n+\t(TARGET_SWITCHES): Add push-args, no-push-args,\n+\taccumulate-outgoing-args and no-accumulate-outgoing-args.\n+\t(ACCUMULATE_OUTGOING_ARGS, PUSH_ARGS): New macro.\n+\t* expr.c (ACCUMULATE_OUTGONG_ARGS, PUSH_ARGS): Provide default.\n+\t(push_block): Avoid ifdefs on ACCUMULATE_OUTGONG_ARGS\n+\tand PUSH_ROUNDING.\n+\t(emit_push_insn): Likewise.\n+\t* final.c (ACCUMULATE_OUTGOING_ARGS): Provide default.\n+\t(final_scan_insn): Avoid ifdefs on ACCUMULATE_OUTGOING_ARGS.\n+\t* function.c (ACCUMULATE_OUTGOING_ARGS): Provide default.\n+\t(STACK_DYNAMIC_OFFSET): Define correctly for both\n+\tACCUMULATE_OUTGOING_ARGS and normal mode.\n+\t* invoke.texi (-mpush_args, -maccumulate-outgoing-args): Document.\n+\t* tm.texi (PUSH_ARGS): Document.\n+\t(ACCUMULATE_OUTGOING_ARGS, PUSH_ROUNDING): Update documentation.\n+\n Wed Mar 29 11:51:13 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \n \t* flags.h (flag_optimize_sibling_calls): Declare."}, {"sha": "b0a65f14ffa75ccf2301f4acb5f6604dec717494", "filename": "gcc/calls.c", "status": "modified", "additions": 483, "deletions": 473, "changes": 956, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -32,6 +32,19 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"tm_p.h\"\n \n+#ifndef ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 0\n+#endif\n+\n+/* Supply a default definition for PUSH_ARGS.  */\n+#ifndef PUSH_ARGS\n+#ifdef PUSH_ROUNDING\n+#define PUSH_ARGS\t!ACCUMULATE_OUTGOING_ARGS\n+#else\n+#define PUSH_ARGS\t0\n+#endif\n+#endif\n+\n #if !defined FUNCTION_OK_FOR_SIBCALL\n #define FUNCTION_OK_FOR_SIBCALL(DECL) 1\n #endif\n@@ -49,11 +62,15 @@ Boston, MA 02111-1307, USA.  */\n #ifdef PUSH_ROUNDING\n \n #if defined (STACK_GROWS_DOWNWARD) != defined (ARGS_GROW_DOWNWARD)\n-#define PUSH_ARGS_REVERSED\t/* If it's last to first */\n+#define PUSH_ARGS_REVERSED  PUSH_ARGS\n #endif\n \n #endif\n \n+#ifndef PUSH_ARGS_REVERSED\n+#define PUSH_ARGS_REVERSED 0\n+#endif\n+\n /* Like PREFERRED_STACK_BOUNDARY but in units of bytes, not bits.  */\n #define STACK_BYTES (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)\n \n@@ -101,10 +118,8 @@ struct arg_data\n      differ from STACK if this arg pads downward.  This location is known\n      to be aligned to FUNCTION_ARG_BOUNDARY.  */\n   rtx stack_slot;\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n   /* Place that this stack area has been saved, if needed.  */\n   rtx save_area;\n-#endif\n   /* If an argument's alignment does not permit direct copying into registers,\n      copy in smaller-sized pieces into pseudos.  These are stored in a\n      block pointed to by this field.  The next field says how many\n@@ -116,7 +131,6 @@ struct arg_data\n   struct args_size alignment_pad;\n };\n \n-#ifdef ACCUMULATE_OUTGOING_ARGS\n /* A vector of one char per byte of stack space.  A byte if non-zero if\n    the corresponding stack location has been used.\n    This vector is used to prevent a function call within an argument from\n@@ -132,7 +146,6 @@ static int highest_outgoing_arg_in_use;\n    to make sure the object being constructed does not overlap the\n    argument list for the constructor call.  */\n int stack_arg_under_construction;\n-#endif\n \n static int calls_function\tPARAMS ((tree, int));\n static int calls_function_1\tPARAMS ((tree, int));\n@@ -176,7 +189,7 @@ static rtx emit_library_call_value_1 \t\tPARAMS ((int, rtx, rtx, int,\n \t\t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t\t int, va_list));\n \n-#if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n+#ifdef REG_PARM_STACK_SPACE\n static rtx save_fixed_argument_area\tPARAMS ((int, rtx, int *, int *));\n static void restore_fixed_argument_area\tPARAMS ((rtx, rtx, int, int));\n #endif\n@@ -413,18 +426,15 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n   rtx struct_value_size_rtx = GEN_INT (struct_value_size);\n #endif\n   rtx call_insn;\n-#ifndef ACCUMULATE_OUTGOING_ARGS\n   int already_popped = 0;\n   HOST_WIDE_INT n_popped = RETURN_POPS_ARGS (fndecl, funtype, stack_size);\n-#endif\n \n   /* Ensure address is valid.  SYMBOL_REF is already valid, so no need,\n      and we don't want to load it into a register as an optimization,\n      because prepare_call_address already did it if it should be done.  */\n   if (GET_CODE (funexp) != SYMBOL_REF)\n     funexp = memory_address (FUNCTION_MODE, funexp);\n \n-#ifndef ACCUMULATE_OUTGOING_ARGS\n #if defined (HAVE_sibcall_pop) && defined (HAVE_sibcall_value_pop)\n   if ((ecf_flags & ECF_SIBCALL)\n       && HAVE_sibcall_pop && HAVE_sibcall_value_pop\n@@ -459,7 +469,7 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n    even if the call has no arguments to pop.  */\n #if defined (HAVE_call) && defined (HAVE_call_value)\n   if (HAVE_call && HAVE_call_value && HAVE_call_pop && HAVE_call_value_pop\n-       && n_popped > 0)\n+      && n_popped > 0)\n #else\n   if (HAVE_call_pop && HAVE_call_value_pop)\n #endif\n@@ -483,7 +493,6 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n     }\n   else\n #endif\n-#endif\n \n #if defined (HAVE_sibcall) && defined (HAVE_sibcall_value)\n   if ((ecf_flags & ECF_SIBCALL)\n@@ -559,18 +568,6 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n      if the context of the call as a whole permits.  */\n   inhibit_defer_pop = old_inhibit_defer_pop;\n \n-#ifndef ACCUMULATE_OUTGOING_ARGS\n-  /* If returning from the subroutine does not automatically pop the args,\n-     we need an instruction to pop them sooner or later.\n-     Perhaps do it now; perhaps just record how much space to pop later.\n-\n-     If returning from the subroutine does pop the args, indicate that the\n-     stack pointer will be changed.  */\n-\n-  /* The space for the args is no longer waiting for the call; either it\n-     was popped by the call, or it'll be popped below.  */\n-  arg_space_so_far -= rounded_stack_size;\n-\n   if (n_popped > 0)\n     {\n       if (!already_popped)\n@@ -582,15 +579,41 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n       rounded_stack_size_rtx = GEN_INT (rounded_stack_size);\n     }\n \n-  if (rounded_stack_size != 0)\n+  if (!ACCUMULATE_OUTGOING_ARGS)\n     {\n-      if (flag_defer_pop && inhibit_defer_pop == 0\n-\t  && !(ecf_flags & ECF_IS_CONST))\n-\tpending_stack_adjust += rounded_stack_size;\n-      else\n-\tadjust_stack (rounded_stack_size_rtx);\n+      /* If returning from the subroutine does not automatically pop the args,\n+\t we need an instruction to pop them sooner or later.\n+\t Perhaps do it now; perhaps just record how much space to pop later.\n+\n+\t If returning from the subroutine does pop the args, indicate that the\n+\t stack pointer will be changed.  */\n+\n+      /* The space for the args is no longer waiting for the call; either it\n+\t was popped by the call, or it'll be popped below.  */\n+      arg_space_so_far -= rounded_stack_size - n_popped;\n+\n+      if (rounded_stack_size != 0)\n+\t{\n+\t  if (flag_defer_pop && inhibit_defer_pop == 0\n+\t      && !(ecf_flags & ECF_IS_CONST))\n+\t    pending_stack_adjust += rounded_stack_size;\n+\t  else\n+\t    adjust_stack (rounded_stack_size_rtx);\n+\t}\n     }\n-#endif\n+  /* When we accumulate outgoing args, we must avoid any stack manipulations.\n+     Restore the stack pointer to its original value now.  Usually\n+     ACCUMULATE_OUTGOING_ARGS targets don't get here, but there are exceptions.\n+     On  i386 ACCUMULATE_OUTGOING_ARGS can be enabled on demand, and\n+     popping variants of functions exist as well.\n+\n+     ??? We may optimize similar to defer_pop above, but it is\n+     probably not worthwhile.\n+   \n+     ??? It will be worthwhile to enable combine_stack_adjustments even for\n+     such machines.  */\n+  else if (n_popped)\n+    anti_adjust_stack (GEN_INT (n_popped));\n }\n \n /* Determine if the function identified by NAME and FNDECL is one with\n@@ -774,7 +797,7 @@ precompute_register_parameters (num_actuals, args, reg_parm_seen)\n       }\n }\n \n-#if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n+#ifdef REG_PARM_STACK_SPACE\n \n   /* The argument list is the property of the called routine and it\n      may clobber it.  If the fixed area has been used for previous\n@@ -1013,13 +1036,16 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n      We fill up ARGS from the front or from the back if necessary\n      so that in any case the first arg to be pushed ends up at the front.  */\n \n-#ifdef PUSH_ARGS_REVERSED\n-  i = num_actuals - 1, inc = -1;\n-  /* In this case, must reverse order of args\n-     so that we compute and push the last arg first.  */\n-#else\n-  i = 0, inc = 1;\n-#endif\n+  if (PUSH_ARGS_REVERSED)\n+    {\n+      i = num_actuals - 1, inc = -1;\n+      /* In this case, must reverse order of args\n+\t so that we compute and push the last arg first.  */\n+    }\n+  else\n+    {\n+      i = 0, inc = 1;\n+    }\n \n   /* I counts args in order (to be) pushed; ARGPOS counts in order written.  */\n   for (p = actparms, argpos = 0; p; p = TREE_CHAIN (p), i += inc, argpos++)\n@@ -1262,6 +1288,14 @@ compute_argument_block_size (reg_parm_stack_space, args_size,\n {\n   int unadjusted_args_size = args_size->constant;\n \n+  /* For accumulate outgoing args mode we don't need to align, since the frame\n+     will be already aligned.  Align to STACK_BOUNDARY in order to prevent\n+     backends from generating missaligned frame sizes.  */\n+#ifdef STACK_BOUNDARY\n+  if (ACCUMULATE_OUTGOING_ARGS && preferred_stack_boundary > STACK_BOUNDARY)\n+    preferred_stack_boundary = STACK_BOUNDARY;\n+#endif\n+\n   /* Compute the actual size of the argument block required.  The variable\n      and constant sizes must be combined, the size may have to be rounded,\n      and there may be a minimum required size.  */\n@@ -1692,9 +1726,7 @@ expand_call (exp, target, ignore)\n      or 0 if the function is computed (not known by name).  */\n   tree fndecl = 0;\n   char *name = 0;\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n   rtx before_call;\n-#endif\n   rtx insn;\n   int try_tail_call;\n   int pass;\n@@ -1744,11 +1776,7 @@ expand_call (exp, target, ignore)\n      So the entire argument block must then be preallocated (i.e., we\n      ignore PUSH_ROUNDING in that case).  */\n \n-#ifdef PUSH_ROUNDING\n-  int must_preallocate = 0;\n-#else\n-  int must_preallocate = 1;\n-#endif\n+  int must_preallocate = !PUSH_ARGS;\n \n   /* Size of the stack reserved for parameter registers.  */\n   int reg_parm_stack_space = 0;\n@@ -1777,18 +1805,16 @@ expand_call (exp, target, ignore)\n   int is_volatile = 0;\n   /* Nonzero if this is a call to a function that won't throw an exception.  */\n   int nothrow = TREE_NOTHROW (exp);\n-#if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n+#ifdef REG_PARM_STACK_SPACE\n   /* Define the boundary of the register parm stack space that needs to be\n      save, if any.  */\n   int low_to_save = -1, high_to_save;\n   rtx save_area = 0;\t\t/* Place that it is saved */\n #endif\n \n-#ifdef ACCUMULATE_OUTGOING_ARGS\n   int initial_highest_arg_in_use = highest_outgoing_arg_in_use;\n   char *initial_stack_usage_map = stack_usage_map;\n   int old_stack_arg_under_construction = 0;\n-#endif\n \n   rtx old_stack_level = 0;\n   int old_pending_adj = 0;\n@@ -1866,8 +1892,8 @@ expand_call (exp, target, ignore)\n #endif\n #endif\n \n-#if defined(PUSH_ROUNDING) && ! defined(OUTGOING_REG_PARM_STACK_SPACE)\n-  if (reg_parm_stack_space > 0)\n+#ifndef OUTGOING_REG_PARM_STACK_SPACE\n+  if (reg_parm_stack_space > 0 && PUSH_ARGS)\n     must_preallocate = 1;\n #endif\n \n@@ -1935,9 +1961,7 @@ expand_call (exp, target, ignore)\n     {\n       rtx temp;\n \n-#ifdef ACCUMULATE_OUTGOING_ARGS\n       before_call = get_last_insn ();\n-#endif\n \n       temp = expand_inline_function (fndecl, actparms, target,\n \t\t\t\t     ignore, TREE_TYPE (exp),\n@@ -1946,64 +1970,65 @@ expand_call (exp, target, ignore)\n       /* If inlining succeeded, return.  */\n       if (temp != (rtx) (HOST_WIDE_INT) -1)\n \t{\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-\t  /* If the outgoing argument list must be preserved, push\n-\t     the stack before executing the inlined function if it\n-\t     makes any calls.  */\n+\t  if (ACCUMULATE_OUTGOING_ARGS)\n+\t    {\n+\t      /* If the outgoing argument list must be preserved, push\n+\t\t the stack before executing the inlined function if it\n+\t\t makes any calls.  */\n \n-\t  for (i = reg_parm_stack_space - 1; i >= 0; i--)\n-\t    if (i < highest_outgoing_arg_in_use && stack_usage_map[i] != 0)\n-\t      break;\n+\t      for (i = reg_parm_stack_space - 1; i >= 0; i--)\n+\t\tif (i < highest_outgoing_arg_in_use && stack_usage_map[i] != 0)\n+\t\t  break;\n \n-\t  if (stack_arg_under_construction || i >= 0)\n-\t    {\n-\t      rtx first_insn\n-\t\t= before_call ? NEXT_INSN (before_call) : get_insns ();\n-\t      rtx insn = NULL_RTX, seq;\n+\t      if (stack_arg_under_construction || i >= 0)\n+\t\t{\n+\t\t  rtx first_insn\n+\t\t    = before_call ? NEXT_INSN (before_call) : get_insns ();\n+\t\t  rtx insn = NULL_RTX, seq;\n \n-\t      /* Look for a call in the inline function code.\n-\t\t If DECL_SAVED_INSNS (fndecl)->outgoing_args_size is\n-\t\t nonzero then there is a call and it is not necessary\n-\t\t to scan the insns.  */\n+\t\t  /* Look for a call in the inline function code.\n+\t\t     If DECL_SAVED_INSNS (fndecl)->outgoing_args_size is\n+\t\t     nonzero then there is a call and it is not necessary\n+\t\t     to scan the insns.  */\n \n-\t      if (DECL_SAVED_INSNS (fndecl)->outgoing_args_size == 0)\n-\t\tfor (insn = first_insn; insn; insn = NEXT_INSN (insn))\n-\t\t  if (GET_CODE (insn) == CALL_INSN)\n-\t\t    break;\n+\t\t  if (DECL_SAVED_INSNS (fndecl)->outgoing_args_size == 0)\n+\t\t    for (insn = first_insn; insn; insn = NEXT_INSN (insn))\n+\t\t      if (GET_CODE (insn) == CALL_INSN)\n+\t\t\tbreak;\n \n-\t      if (insn)\n-\t\t{\n-\t\t  /* Reserve enough stack space so that the largest\n-\t\t     argument list of any function call in the inline\n-\t\t     function does not overlap the argument list being\n-\t\t     evaluated.  This is usually an overestimate because\n-\t\t     allocate_dynamic_stack_space reserves space for an\n-\t\t     outgoing argument list in addition to the requested\n-\t\t     space, but there is no way to ask for stack space such\n-\t\t     that an argument list of a certain length can be\n-\t\t     safely constructed. \n-\n-\t\t     Add the stack space reserved for register arguments, if\n-\t\t     any, in the inline function.  What is really needed is the\n-\t\t     largest value of reg_parm_stack_space in the inline\n-\t\t     function, but that is not available.  Using the current\n-\t\t     value of reg_parm_stack_space is wrong, but gives\n-\t\t     correct results on all supported machines.  */\n-\n-\t\t  int adjust = (DECL_SAVED_INSNS (fndecl)->outgoing_args_size\n-\t\t\t\t+ reg_parm_stack_space);\n-\n-\t\t  start_sequence ();\n-\t\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n-\t\t  allocate_dynamic_stack_space (GEN_INT (adjust),\n-\t\t\t\t\t\tNULL_RTX, BITS_PER_UNIT);\n-\t\t  seq = get_insns ();\n-\t\t  end_sequence ();\n-\t\t  emit_insns_before (seq, first_insn);\n-\t\t  emit_stack_restore (SAVE_BLOCK, old_stack_level, NULL_RTX);\n+\t\t  if (insn)\n+\t\t    {\n+\t\t      /* Reserve enough stack space so that the largest\n+\t\t\t argument list of any function call in the inline\n+\t\t\t function does not overlap the argument list being\n+\t\t\t evaluated.  This is usually an overestimate because\n+\t\t\t allocate_dynamic_stack_space reserves space for an\n+\t\t\t outgoing argument list in addition to the requested\n+\t\t\t space, but there is no way to ask for stack space such\n+\t\t\t that an argument list of a certain length can be\n+\t\t\t safely constructed. \n+\n+\t\t\t Add the stack space reserved for register arguments, if\n+\t\t\t any, in the inline function.  What is really needed is the\n+\t\t\t largest value of reg_parm_stack_space in the inline\n+\t\t\t function, but that is not available.  Using the current\n+\t\t\t value of reg_parm_stack_space is wrong, but gives\n+\t\t\t correct results on all supported machines.  */\n+\n+\t\t      int adjust = (DECL_SAVED_INSNS (fndecl)->outgoing_args_size\n+\t\t\t\t    + reg_parm_stack_space);\n+\n+\t\t      start_sequence ();\n+\t\t      emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n+\t\t      allocate_dynamic_stack_space (GEN_INT (adjust),\n+\t\t\t\t\t\t    NULL_RTX, BITS_PER_UNIT);\n+\t\t      seq = get_insns ();\n+\t\t      end_sequence ();\n+\t\t      emit_insns_before (seq, first_insn);\n+\t\t      emit_stack_restore (SAVE_BLOCK, old_stack_level, NULL_RTX);\n+\t\t    }\n \t\t}\n \t    }\n-#endif\n \n \t  /* If the result is equivalent to TARGET, return TARGET to simplify\n \t     checks in store_expr.  They can be equivalent but not equal in the\n@@ -2260,10 +2285,9 @@ expand_call (exp, target, ignore)\n \t     If it is virtual_outgoing_args_rtx, we must copy it to another\n \t     register in some cases.  */\n \t  rtx temp = (GET_CODE (structure_value_addr) != REG\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-\t\t      || (stack_arg_under_construction\n+\t\t      || (ACCUMULATE_OUTGOING_ARGS\n+\t\t\t  && stack_arg_under_construction\n \t\t\t  && structure_value_addr == virtual_outgoing_args_rtx)\n-#endif\n \t\t      ? copy_addr_to_reg (structure_value_addr)\n \t\t      : structure_value_addr);\n \n@@ -2380,9 +2404,7 @@ expand_call (exp, target, ignore)\n \t      || reg_mentioned_p (virtual_outgoing_args_rtx,\n \t\t\t\t  structure_value_addr))\n \t  && (args_size.var\n-#ifndef ACCUMULATE_OUTGOING_ARGS\n-\t      || args_size.constant\n-#endif\n+\t      || (!ACCUMULATE_OUTGOING_ARGS && args_size.constant)\n \t      ))\n \tstructure_value_addr = copy_to_reg (structure_value_addr);\n \n@@ -2405,13 +2427,11 @@ expand_call (exp, target, ignore)\n \t      emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n \t      old_pending_adj = pending_stack_adjust;\n \t      pending_stack_adjust = 0;\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n \t      /* stack_arg_under_construction says whether a stack arg is\n \t\t being constructed at the old stack level.  Pushing the stack\n \t\t gets a clean outgoing argument block.  */\n \t      old_stack_arg_under_construction = stack_arg_under_construction;\n \t      stack_arg_under_construction = 0;\n-#endif\n \t    }\n \t  argblock = push_block (ARGS_SIZE_RTX (args_size), 0, 0);\n \t}\n@@ -2433,85 +2453,87 @@ expand_call (exp, target, ignore)\n \n \t  if (must_preallocate)\n \t    {\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-\t      /* Since the stack pointer will never be pushed, it is possible\n-\t\t for the evaluation of a parm to clobber something we have\n-\t\t already written to the stack.  Since most function calls on\n-\t\t RISC machines do not use the stack, this is uncommon, but\n-\t\t must work correctly.\n+\t      if (ACCUMULATE_OUTGOING_ARGS)\n+\t\t{\n+\t\t  /* Since the stack pointer will never be pushed, it is possible\n+\t\t     for the evaluation of a parm to clobber something we have\n+\t\t     already written to the stack.  Since most function calls on\n+\t\t     RISC machines do not use the stack, this is uncommon, but\n+\t\t     must work correctly.\n \n-\t\t Therefore, we save any area of the stack that was already\n-\t\t written and that we are using.  Here we set up to do this by\n-\t\t making a new stack usage map from the old one.  The actual\n-\t\t save will be done by store_one_arg. \n+\t\t     Therefore, we save any area of the stack that was already\n+\t\t     written and that we are using.  Here we set up to do this by\n+\t\t     making a new stack usage map from the old one.  The actual\n+\t\t     save will be done by store_one_arg. \n \n-\t\t Another approach might be to try to reorder the argument\n-\t\t evaluations to avoid this conflicting stack usage.  */\n+\t\t     Another approach might be to try to reorder the argument\n+\t\t     evaluations to avoid this conflicting stack usage.  */\n \n #ifndef OUTGOING_REG_PARM_STACK_SPACE\n-\t      /* Since we will be writing into the entire argument area, the\n-\t\t map must be allocated for its entire size, not just the part\n-\t\t that is the responsibility of the caller.  */\n-\t      needed += reg_parm_stack_space;\n+\t\t  /* Since we will be writing into the entire argument area, the\n+\t\t     map must be allocated for its entire size, not just the part\n+\t\t     that is the responsibility of the caller.  */\n+\t\t  needed += reg_parm_stack_space;\n #endif\n \n #ifdef ARGS_GROW_DOWNWARD\n-\t      highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n-\t\t\t\t\t\t needed + 1);\n+\t\t  highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n+\t\t\t\t\t\t     needed + 1);\n #else\n-\t      highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n-\t\t\t\t\t\t needed);\n+\t\t  highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n+\t\t\t\t\t\t     needed);\n #endif\n-\t      stack_usage_map = (char *) alloca (highest_outgoing_arg_in_use);\n+\t\t  stack_usage_map = (char *) alloca (highest_outgoing_arg_in_use);\n \n-\t      if (initial_highest_arg_in_use)\n-\t\tbcopy (initial_stack_usage_map, stack_usage_map,\n-\t\t       initial_highest_arg_in_use);\n+\t\t  if (initial_highest_arg_in_use)\n+\t\t    bcopy (initial_stack_usage_map, stack_usage_map,\n+\t\t\t   initial_highest_arg_in_use);\n \n-\t      if (initial_highest_arg_in_use != highest_outgoing_arg_in_use)\n-\t\tbzero (&stack_usage_map[initial_highest_arg_in_use],\n-\t\t       (highest_outgoing_arg_in_use\n-\t\t\t- initial_highest_arg_in_use));\n-\t      needed = 0;\n+\t\t  if (initial_highest_arg_in_use != highest_outgoing_arg_in_use)\n+\t\t    bzero (&stack_usage_map[initial_highest_arg_in_use],\n+\t\t\t   (highest_outgoing_arg_in_use\n+\t\t\t    - initial_highest_arg_in_use));\n+\t\t  needed = 0;\n \n-\t      /* The address of the outgoing argument list must not be copied\n-\t\t to a register here, because argblock would be left pointing\n-\t\t to the wrong place after the call to\n-\t\t allocate_dynamic_stack_space below. */\n+\t\t  /* The address of the outgoing argument list must not be copied\n+\t\t     to a register here, because argblock would be left pointing\n+\t\t     to the wrong place after the call to\n+\t\t     allocate_dynamic_stack_space below. */\n \n-\t      argblock = virtual_outgoing_args_rtx;\n-\n-#else /* not ACCUMULATE_OUTGOING_ARGS */\n-\t      if (inhibit_defer_pop == 0)\n+\t\t  argblock = virtual_outgoing_args_rtx;\n+\t        }\n+\t      else\n \t\t{\n-\t\t  /* Try to reuse some or all of the pending_stack_adjust\n-\t\t     to get this space.  Maybe we can avoid any pushing.  */\n-\t\t  if (needed > pending_stack_adjust)\n+\t\t  if (inhibit_defer_pop == 0)\n \t\t    {\n-\t\t      needed -= pending_stack_adjust;\n-\t\t      pending_stack_adjust = 0;\n+\t\t      /* Try to reuse some or all of the pending_stack_adjust\n+\t\t\t to get this space.  Maybe we can avoid any pushing.  */\n+\t\t      if (needed > pending_stack_adjust)\n+\t\t\t{\n+\t\t\t  needed -= pending_stack_adjust;\n+\t\t\t  pending_stack_adjust = 0;\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  pending_stack_adjust -= needed;\n+\t\t\t  needed = 0;\n+\t\t\t}\n \t\t    }\n+\t\t  /* Special case this because overhead of `push_block' in this\n+\t\t     case is non-trivial.  */\n+\t\t  if (needed == 0)\n+\t\t    argblock = virtual_outgoing_args_rtx;\n \t\t  else\n-\t\t    {\n-\t\t      pending_stack_adjust -= needed;\n-\t\t      needed = 0;\n-\t\t    }\n+\t\t    argblock = push_block (GEN_INT (needed), 0, 0);\n+\n+\t\t  /* We only really need to call `copy_to_reg' in the case where\n+\t\t     push insns are going to be used to pass ARGBLOCK to a function\n+\t\t     call in ARGS.  In that case, the stack pointer changes value\n+\t\t     from the allocation point to the call point, and hence\n+\t\t     the value of VIRTUAL_OUTGOING_ARGS_RTX changes as well.\n+\t\t     But might as well always do it.  */\n+\t\t  argblock = copy_to_reg (argblock);\n \t\t}\n-\t      /* Special case this because overhead of `push_block' in this\n-\t\t case is non-trivial.  */\n-\t      if (needed == 0)\n-\t\targblock = virtual_outgoing_args_rtx;\n-\t      else\n-\t\targblock = push_block (GEN_INT (needed), 0, 0);\n-\n-\t      /* We only really need to call `copy_to_reg' in the case where\n-\t\t push insns are going to be used to pass ARGBLOCK to a function\n-\t\t call in ARGS.  In that case, the stack pointer changes value\n-\t\t from the allocation point to the call point, and hence\n-\t\t the value of VIRTUAL_OUTGOING_ARGS_RTX changes as well.\n-\t\t But might as well always do it.  */\n-\t      argblock = copy_to_reg (argblock);\n-#endif /* not ACCUMULATE_OUTGOING_ARGS */\n \t    }\n \t}\n \n@@ -2524,51 +2546,52 @@ expand_call (exp, target, ignore)\n \t  argblock = force_reg (Pmode, force_operand (temp, NULL_RTX));\n \t}\n \n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-      /* The save/restore code in store_one_arg handles all cases except one:\n-\t a constructor call (including a C function returning a BLKmode struct)\n-\t to initialize an argument.  */\n-      if (stack_arg_under_construction)\n+      if (ACCUMULATE_OUTGOING_ARGS)\n \t{\n+\t  /* The save/restore code in store_one_arg handles all cases except one:\n+\t     a constructor call (including a C function returning a BLKmode struct)\n+\t     to initialize an argument.  */\n+\t  if (stack_arg_under_construction)\n+\t    {\n #ifndef OUTGOING_REG_PARM_STACK_SPACE\n-\t  rtx push_size = GEN_INT (reg_parm_stack_space + args_size.constant);\n+\t      rtx push_size = GEN_INT (reg_parm_stack_space + args_size.constant);\n #else\n-\t  rtx push_size = GEN_INT (args_size.constant);\n+\t      rtx push_size = GEN_INT (args_size.constant);\n #endif\n-\t  if (old_stack_level == 0)\n-\t    {\n-\t      emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n-\t      old_pending_adj = pending_stack_adjust;\n-\t      pending_stack_adjust = 0;\n-\t      /* stack_arg_under_construction says whether a stack arg is\n-\t\t being constructed at the old stack level.  Pushing the stack\n-\t\t gets a clean outgoing argument block.  */\n-\t      old_stack_arg_under_construction = stack_arg_under_construction;\n-\t      stack_arg_under_construction = 0;\n-\t      /* Make a new map for the new argument list.  */\n-\t      stack_usage_map = (char *)alloca (highest_outgoing_arg_in_use);\n-\t      bzero (stack_usage_map, highest_outgoing_arg_in_use);\n-\t      highest_outgoing_arg_in_use = 0;\n+\t      if (old_stack_level == 0)\n+\t\t{\n+\t\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n+\t\t  old_pending_adj = pending_stack_adjust;\n+\t\t  pending_stack_adjust = 0;\n+\t\t  /* stack_arg_under_construction says whether a stack arg is\n+\t\t     being constructed at the old stack level.  Pushing the stack\n+\t\t     gets a clean outgoing argument block.  */\n+\t\t  old_stack_arg_under_construction = stack_arg_under_construction;\n+\t\t  stack_arg_under_construction = 0;\n+\t\t  /* Make a new map for the new argument list.  */\n+\t\t  stack_usage_map = (char *)alloca (highest_outgoing_arg_in_use);\n+\t\t  bzero (stack_usage_map, highest_outgoing_arg_in_use);\n+\t\t  highest_outgoing_arg_in_use = 0;\n+\t\t}\n+\t      allocate_dynamic_stack_space (push_size, NULL_RTX, BITS_PER_UNIT);\n \t    }\n-\t  allocate_dynamic_stack_space (push_size, NULL_RTX, BITS_PER_UNIT);\n+\t  /* If argument evaluation might modify the stack pointer, copy the\n+\t     address of the argument list to a register.  */\n+\t  for (i = 0; i < num_actuals; i++)\n+\t    if (args[i].pass_on_stack)\n+\t      {\n+\t\targblock = copy_addr_to_reg (argblock);\n+\t\tbreak;\n+\t      }\n \t}\n-      /* If argument evaluation might modify the stack pointer, copy the\n-\t address of the argument list to a register.  */\n-      for (i = 0; i < num_actuals; i++)\n-\tif (args[i].pass_on_stack)\n-\t  {\n-\t    argblock = copy_addr_to_reg (argblock);\n-\t    break;\n-\t  }\n-#endif\n \n       compute_argument_addresses (args, argblock, num_actuals);\n \n-#ifdef PUSH_ARGS_REVERSED\n #ifdef PREFERRED_STACK_BOUNDARY\n       /* If we push args individually in reverse order, perform stack alignment\n \t before the first push (the last arg).  */\n-      if (args_size.constant != unadjusted_args_size)\n+      if (PUSH_ARGS_REVERSED && argblock == 0\n+\t  && args_size.constant != unadjusted_args_size)\n \t{\n \t  /* When the stack adjustment is pending, we get better code\n \t     by combining the adjustments.  */\n@@ -2595,7 +2618,6 @@ expand_call (exp, target, ignore)\n \t     be deferred during the evaluation of the arguments.  */\n \t  NO_DEFER_POP;\n \t}\n-#endif\n #endif\n \n       /* Don't try to defer pops if preallocating, not even from the first arg,\n@@ -2621,11 +2643,12 @@ expand_call (exp, target, ignore)\n \t once we have started filling any specific hard regs.  */\n       precompute_register_parameters (num_actuals, args, &reg_parm_seen);\n \n-#if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n+#ifdef REG_PARM_STACK_SPACE\n       /* Save the fixed argument area if it's part of the caller's frame and\n \t is clobbered by argument setup for this call.  */\n-      save_area = save_fixed_argument_area (reg_parm_stack_space, argblock,\n-\t\t\t\t\t    &low_to_save, &high_to_save);\n+      if (ACCUMULATE_OUTGOING_ARGS)\n+\tsave_area = save_fixed_argument_area (reg_parm_stack_space, argblock,\n+\t\t\t\t\t      &low_to_save, &high_to_save);\n #endif\n \n       /* Now store (and compute if necessary) all non-register parms.\n@@ -2654,22 +2677,21 @@ expand_call (exp, target, ignore)\n \t    store_one_arg (&args[i], argblock, may_be_alloca,\n \t\t\t   args_size.var != 0, reg_parm_stack_space);\n \n-#ifndef PUSH_ARGS_REVERSED\n #ifdef PREFERRED_STACK_BOUNDARY\n       /* If we pushed args in forward order, perform stack alignment\n \t after pushing the last arg.  */\n       /* ??? Fix for arg_space_so_far.  */\n-      if (argblock == 0)\n+      if (!PUSH_ARGS_REVERSED && argblock == 0)\n \tanti_adjust_stack (GEN_INT (args_size.constant\n \t\t\t\t    - unadjusted_args_size));\n-#endif\n #endif\n \n       /* If register arguments require space on the stack and stack space\n \t was not preallocated, allocate stack space here for arguments\n \t passed in registers.  */\n-#if ! defined(ACCUMULATE_OUTGOING_ARGS) && defined(OUTGOING_REG_PARM_STACK_SPACE)\n-      if (must_preallocate == 0 && reg_parm_stack_space > 0)\n+#ifdef OUTGOING_REG_PARM_STACK_SPACE\n+      if (!ACCUMULATE_OUTGOING_ARGS\n+\t  must_preallocate == 0 && reg_parm_stack_space > 0)\n \tanti_adjust_stack (GEN_INT (reg_parm_stack_space));\n #endif\n \n@@ -2749,13 +2771,12 @@ expand_call (exp, target, ignore)\n \n \t  /* Construct an \"equal form\" for the value which mentions all the\n \t     arguments in order as well as the function name.  */\n-#ifdef PUSH_ARGS_REVERSED\n-\t  for (i = 0; i < num_actuals; i++)\n-\t    note = gen_rtx_EXPR_LIST (VOIDmode, args[i].initial_value, note);\n-#else\n-\t  for (i = num_actuals - 1; i >= 0; i--)\n-\t    note = gen_rtx_EXPR_LIST (VOIDmode, args[i].initial_value, note);\n-#endif\n+\t  if (PUSH_ARGS_REVERSED)\n+\t    for (i = 0; i < num_actuals; i++)\n+\t      note = gen_rtx_EXPR_LIST (VOIDmode, args[i].initial_value, note);\n+\t  else\n+\t    for (i = num_actuals - 1; i >= 0; i--)\n+\t      note = gen_rtx_EXPR_LIST (VOIDmode, args[i].initial_value, note);\n \t  note = gen_rtx_EXPR_LIST (VOIDmode, funexp, note);\n \n \t  insns = get_insns ();\n@@ -2939,15 +2960,12 @@ expand_call (exp, target, ignore)\n \t{\n \t  emit_stack_restore (SAVE_BLOCK, old_stack_level, NULL_RTX);\n \t  pending_stack_adjust = old_pending_adj;\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n \t  stack_arg_under_construction = old_stack_arg_under_construction;\n \t  highest_outgoing_arg_in_use = initial_highest_arg_in_use;\n \t  stack_usage_map = initial_stack_usage_map;\n-#endif\n \t  sibcall_failure = 1;\n \t}\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-      else\n+      else if (ACCUMULATE_OUTGOING_ARGS)\n \t{\n #ifdef REG_PARM_STACK_SPACE\n \t  if (save_area)\n@@ -2981,7 +2999,6 @@ expand_call (exp, target, ignore)\n \t  highest_outgoing_arg_in_use = initial_highest_arg_in_use;\n \t  stack_usage_map = initial_stack_usage_map;\n \t}\n-#endif\n \n       /* If this was alloca, record the new stack level for nonlocal gotos.  \n \t Check for the handler slots since we might not have a save area\n@@ -3125,22 +3142,18 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n   int is_const;\n   int reg_parm_stack_space = 0;\n   int nothrow;\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n   int needed;\n-#endif\n \n-#if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n+#ifdef REG_PARM_STACK_SPACE\n   /* Define the boundary of the register parm stack space that needs to be\n      save, if any.  */\n   int low_to_save = -1, high_to_save = 0;\n   rtx save_area = 0;            /* Place that it is saved */\n #endif\n \n-#ifdef ACCUMULATE_OUTGOING_ARGS\n   /* Size of the stack reserved for parameter registers.  */\n   int initial_highest_arg_in_use = highest_outgoing_arg_in_use;\n   char *initial_stack_usage_map = stack_usage_map;\n-#endif\n \n #ifdef REG_PARM_STACK_SPACE\n #ifdef MAYBE_REG_PARM_STACK_SPACE\n@@ -3336,133 +3349,139 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n   if (args_size.constant > current_function_outgoing_args_size)\n     current_function_outgoing_args_size = args_size.constant;\n \n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-  /* Since the stack pointer will never be pushed, it is possible for\n-     the evaluation of a parm to clobber something we have already\n-     written to the stack.  Since most function calls on RISC machines\n-     do not use the stack, this is uncommon, but must work correctly.\n+  if (ACCUMULATE_OUTGOING_ARGS)\n+    {\n+      /* Since the stack pointer will never be pushed, it is possible for\n+\t the evaluation of a parm to clobber something we have already\n+\t written to the stack.  Since most function calls on RISC machines\n+\t do not use the stack, this is uncommon, but must work correctly.\n \n-     Therefore, we save any area of the stack that was already written\n-     and that we are using.  Here we set up to do this by making a new\n-     stack usage map from the old one.\n+\t Therefore, we save any area of the stack that was already written\n+\t and that we are using.  Here we set up to do this by making a new\n+\t stack usage map from the old one.\n \n-     Another approach might be to try to reorder the argument\n-     evaluations to avoid this conflicting stack usage.  */\n+\t Another approach might be to try to reorder the argument\n+\t evaluations to avoid this conflicting stack usage.  */\n \n-  needed = args_size.constant;\n+      needed = args_size.constant;\n \n #ifndef OUTGOING_REG_PARM_STACK_SPACE\n-  /* Since we will be writing into the entire argument area, the\n-     map must be allocated for its entire size, not just the part that\n-     is the responsibility of the caller.  */\n-  needed += reg_parm_stack_space;\n+      /* Since we will be writing into the entire argument area, the\n+\t map must be allocated for its entire size, not just the part that\n+\t is the responsibility of the caller.  */\n+      needed += reg_parm_stack_space;\n #endif\n \n #ifdef ARGS_GROW_DOWNWARD\n-  highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n-\t\t\t\t     needed + 1);\n+      highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n+\t\t\t\t\t needed + 1);\n #else\n-  highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n-\t\t\t\t     needed);\n-#endif\n-  stack_usage_map = (char *) alloca (highest_outgoing_arg_in_use);\n-\n-  if (initial_highest_arg_in_use)\n-    bcopy (initial_stack_usage_map, stack_usage_map,\n-\t   initial_highest_arg_in_use);\n-\n-  if (initial_highest_arg_in_use != highest_outgoing_arg_in_use)\n-    bzero (&stack_usage_map[initial_highest_arg_in_use],\n-\t   highest_outgoing_arg_in_use - initial_highest_arg_in_use);\n-  needed = 0;\n-\n-  /* The address of the outgoing argument list must not be copied to a\n-     register here, because argblock would be left pointing to the\n-     wrong place after the call to allocate_dynamic_stack_space below.\n-     */\n-\n-  argblock = virtual_outgoing_args_rtx;\n-#else /* not ACCUMULATE_OUTGOING_ARGS */\n-#ifndef PUSH_ROUNDING\n-  argblock = push_block (GEN_INT (args_size.constant), 0, 0);\n-#endif\n+      highest_outgoing_arg_in_use = MAX (initial_highest_arg_in_use,\n+\t\t\t\t\t needed);\n #endif\n+      stack_usage_map = (char *) alloca (highest_outgoing_arg_in_use);\n+\n+      if (initial_highest_arg_in_use)\n+\tbcopy (initial_stack_usage_map, stack_usage_map,\n+\t       initial_highest_arg_in_use);\n+\n+      if (initial_highest_arg_in_use != highest_outgoing_arg_in_use)\n+\tbzero (&stack_usage_map[initial_highest_arg_in_use],\n+\t       highest_outgoing_arg_in_use - initial_highest_arg_in_use);\n+      needed = 0;\n+\n+      /* The address of the outgoing argument list must not be copied to a\n+\t register here, because argblock would be left pointing to the\n+\t wrong place after the call to allocate_dynamic_stack_space below.\n+\t */\n+\n+      argblock = virtual_outgoing_args_rtx;\n+    }\n+  else\n+    {\n+      if (!PUSH_ARGS)\n+\targblock = push_block (GEN_INT (args_size.constant), 0, 0);\n+    }\n \n-#ifdef PUSH_ARGS_REVERSED\n #ifdef PREFERRED_STACK_BOUNDARY\n   /* If we push args individually in reverse order, perform stack alignment\n      before the first push (the last arg).  */\n-  if (argblock == 0)\n+  if (argblock == 0 && PUSH_ARGS_REVERSED)\n     anti_adjust_stack (GEN_INT (args_size.constant\n \t\t\t\t- original_args_size.constant));\n #endif\n-#endif\n \n-#ifdef PUSH_ARGS_REVERSED\n-  inc = -1;\n-  argnum = nargs - 1;\n-#else\n-  inc = 1;\n-  argnum = 0;\n-#endif\n+  if (PUSH_ARGS_REVERSED)\n+    {\n+      inc = -1;\n+      argnum = nargs - 1;\n+    }\n+  else\n+    {\n+      inc = 1;\n+      argnum = 0;\n+    }\n \n-#if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n-  /* The argument list is the property of the called routine and it\n-     may clobber it.  If the fixed area has been used for previous\n-     parameters, we must save and restore it.\n+#ifdef REG_PARM_STACK_SPACE\n+  if (ACCUMULATE_OUTGOING_ARGS)\n+    {\n+      /* The argument list is the property of the called routine and it\n+\t may clobber it.  If the fixed area has been used for previous\n+\t parameters, we must save and restore it.\n \n-     Here we compute the boundary of the that needs to be saved, if any.  */\n+\t Here we compute the boundary of the that needs to be saved, if any.  */\n \n #ifdef ARGS_GROW_DOWNWARD\n-  for (count = 0; count < reg_parm_stack_space + 1; count++)\n+      for (count = 0; count < reg_parm_stack_space + 1; count++)\n #else\n-  for (count = 0; count < reg_parm_stack_space; count++)\n+      for (count = 0; count < reg_parm_stack_space; count++)\n #endif\n-    {\n-      if (count >=  highest_outgoing_arg_in_use\n-\t  || stack_usage_map[count] == 0)\n-\tcontinue;\n+\t{\n+\t  if (count >=  highest_outgoing_arg_in_use\n+\t      || stack_usage_map[count] == 0)\n+\t    continue;\n \n-      if (low_to_save == -1)\n-\tlow_to_save = count;\n+\t  if (low_to_save == -1)\n+\t    low_to_save = count;\n \n-      high_to_save = count;\n-    }\n+\t  high_to_save = count;\n+\t}\n \n-  if (low_to_save >= 0)\n-    {\n-      int num_to_save = high_to_save - low_to_save + 1;\n-      enum machine_mode save_mode\n-\t= mode_for_size (num_to_save * BITS_PER_UNIT, MODE_INT, 1);\n-      rtx stack_area;\n+      if (low_to_save >= 0)\n+\t{\n+\t  int num_to_save = high_to_save - low_to_save + 1;\n+\t  enum machine_mode save_mode\n+\t    = mode_for_size (num_to_save * BITS_PER_UNIT, MODE_INT, 1);\n+\t  rtx stack_area;\n \n-      /* If we don't have the required alignment, must do this in BLKmode.  */\n-      if ((low_to_save & (MIN (GET_MODE_SIZE (save_mode),\n-\t\t\t       BIGGEST_ALIGNMENT / UNITS_PER_WORD) - 1)))\n-\tsave_mode = BLKmode;\n+\t  /* If we don't have the required alignment, must do this in BLKmode.  */\n+\t  if ((low_to_save & (MIN (GET_MODE_SIZE (save_mode),\n+\t\t\t\t   BIGGEST_ALIGNMENT / UNITS_PER_WORD) - 1)))\n+\t    save_mode = BLKmode;\n \n #ifdef ARGS_GROW_DOWNWARD\n-      stack_area = gen_rtx_MEM (save_mode,\n-\t\t\t\tmemory_address (save_mode,\n-\t\t\t\t\t\tplus_constant (argblock,\n-\t\t\t\t\t\t\t       - high_to_save)));\n+\t  stack_area = gen_rtx_MEM (save_mode,\n+\t\t\t\t    memory_address (save_mode,\n+\t\t\t\t\t\t    plus_constant (argblock,\n+\t\t\t\t\t\t\t\t   - high_to_save)));\n #else\n-      stack_area = gen_rtx_MEM (save_mode,\n-\t\t\t\tmemory_address (save_mode,\n-\t\t\t\t\t\tplus_constant (argblock,\n-\t\t\t\t\t\t\t       low_to_save)));\n+\t  stack_area = gen_rtx_MEM (save_mode,\n+\t\t\t\t    memory_address (save_mode,\n+\t\t\t\t\t\t    plus_constant (argblock,\n+\t\t\t\t\t\t\t\t   low_to_save)));\n #endif\n-      if (save_mode == BLKmode)\n-\t{\n-\t  save_area = assign_stack_temp (BLKmode, num_to_save, 0);\n-\t  emit_block_move (validize_mem (save_area), stack_area,\n-\t\t\t   GEN_INT (num_to_save),\n-\t\t\t   PARM_BOUNDARY / BITS_PER_UNIT);\n-\t}\n-      else\n-\t{\n-\t  save_area = gen_reg_rtx (save_mode);\n-\t  emit_move_insn (save_area, stack_area);\n+\t  if (save_mode == BLKmode)\n+\t    {\n+\t      save_area = assign_stack_temp (BLKmode, num_to_save, 0);\n+\t      emit_block_move (validize_mem (save_area), stack_area,\n+\t\t\t       GEN_INT (num_to_save),\n+\t\t\t       PARM_BOUNDARY / BITS_PER_UNIT);\n+\t    }\n+\t  else\n+\t    {\n+\t      save_area = gen_reg_rtx (save_mode);\n+\t      emit_move_insn (save_area, stack_area);\n+\t    }\n \t}\n     }\n #endif\n@@ -3477,80 +3496,75 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n       register rtx val = argvec[argnum].value;\n       rtx reg = argvec[argnum].reg;\n       int partial = argvec[argnum].partial;\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-      int lower_bound, upper_bound, i;\n-#endif\n+      int lower_bound = 0, upper_bound = 0, i;\n \n       if (! (reg != 0 && partial == 0))\n \t{\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-\t  /* If this is being stored into a pre-allocated, fixed-size, stack\n-\t     area, save any previous data at that location.  */\n+\t  if (ACCUMULATE_OUTGOING_ARGS)\n+\t    {\n+\t      /* If this is being stored into a pre-allocated, fixed-size, stack\n+\t\t area, save any previous data at that location.  */\n \n #ifdef ARGS_GROW_DOWNWARD\n-\t  /* stack_slot is negative, but we want to index stack_usage_map\n-\t     with positive values.  */\n-\t  upper_bound = -argvec[argnum].offset.constant + 1;\n-\t  lower_bound = upper_bound - argvec[argnum].size.constant;\n+\t      /* stack_slot is negative, but we want to index stack_usage_map\n+\t\t with positive values.  */\n+\t      upper_bound = -argvec[argnum].offset.constant + 1;\n+\t      lower_bound = upper_bound - argvec[argnum].size.constant;\n #else\n-\t  lower_bound = argvec[argnum].offset.constant;\n-\t  upper_bound = lower_bound + argvec[argnum].size.constant;\n+\t      lower_bound = argvec[argnum].offset.constant;\n+\t      upper_bound = lower_bound + argvec[argnum].size.constant;\n #endif\n \n-\t  for (i = lower_bound; i < upper_bound; i++)\n-\t    if (stack_usage_map[i]\n-\t\t/* Don't store things in the fixed argument area at this point;\n-\t\t   it has already been saved.  */\n-\t\t&& i > reg_parm_stack_space)\n-\t      break;\n+\t      for (i = lower_bound; i < upper_bound; i++)\n+\t\tif (stack_usage_map[i]\n+\t\t    /* Don't store things in the fixed argument area at this point;\n+\t\t       it has already been saved.  */\n+\t\t    && i > reg_parm_stack_space)\n+\t\t  break;\n \n-\t  if (i != upper_bound)\n-\t    {\n-\t      /* We need to make a save area.  See what mode we can make it. */\n-\t      enum machine_mode save_mode\n-\t\t= mode_for_size (argvec[argnum].size.constant * BITS_PER_UNIT,\n-\t\t\t\t MODE_INT, 1);\n-\t      rtx stack_area\n-\t\t= gen_rtx_MEM\n-\t\t  (save_mode,\n-\t\t   memory_address\n-\t\t   (save_mode,\n-\t\t    plus_constant (argblock,\n-\t\t\t\t   argvec[argnum].offset.constant)));\n-\t      argvec[argnum].save_area = gen_reg_rtx (save_mode);\n-\n-\t      emit_move_insn (argvec[argnum].save_area, stack_area);\n+\t      if (i != upper_bound)\n+\t\t{\n+\t\t  /* We need to make a save area.  See what mode we can make it. */\n+\t\t  enum machine_mode save_mode\n+\t\t    = mode_for_size (argvec[argnum].size.constant * BITS_PER_UNIT,\n+\t\t\t\t     MODE_INT, 1);\n+\t\t  rtx stack_area\n+\t\t    = gen_rtx_MEM\n+\t\t      (save_mode,\n+\t\t       memory_address\n+\t\t       (save_mode,\n+\t\t\tplus_constant (argblock,\n+\t\t\t\t       argvec[argnum].offset.constant)));\n+\t\t  argvec[argnum].save_area = gen_reg_rtx (save_mode);\n+\n+\t\t  emit_move_insn (argvec[argnum].save_area, stack_area);\n+\t\t}\n \t    }\n-#endif\n \t  emit_push_insn (val, mode, NULL_TREE, NULL_RTX, 0, partial, reg, 0,\n \t\t\t  argblock, GEN_INT (argvec[argnum].offset.constant),\n \t\t\t  reg_parm_stack_space, ARGS_SIZE_RTX (alignment_pad));\n \n-#ifdef ACCUMULATE_OUTGOING_ARGS\n \t  /* Now mark the segment we just used.  */\n-\t  for (i = lower_bound; i < upper_bound; i++)\n-\t    stack_usage_map[i] = 1;\n-#endif\n+\t  if (ACCUMULATE_OUTGOING_ARGS)\n+\t    for (i = lower_bound; i < upper_bound; i++)\n+\t      stack_usage_map[i] = 1;\n \n \t  NO_DEFER_POP;\n \t}\n     }\n \n-#ifndef PUSH_ARGS_REVERSED\n #ifdef PREFERRED_STACK_BOUNDARY\n   /* If we pushed args in forward order, perform stack alignment\n      after pushing the last arg.  */\n-  if (argblock == 0)\n+  if (argblock == 0 && !PUSH_ARGS_REVERSED)\n     anti_adjust_stack (GEN_INT (args_size.constant\n \t\t\t\t- original_args_size.constant));\n #endif\n-#endif\n \n-#ifdef PUSH_ARGS_REVERSED\n-  argnum = nargs - 1;\n-#else\n-  argnum = 0;\n-#endif\n+  if (PUSH_ARGS_REVERSED)\n+    argnum = nargs - 1;\n+  else\n+    argnum = 0;\n \n   fun = prepare_call_address (fun, NULL_TREE, &call_fusage, 0);\n \n@@ -3647,50 +3661,51 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n \tvalue = hard_libcall_value (outmode);\n     }\n \n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-#ifdef REG_PARM_STACK_SPACE\n-  if (save_area)\n+  if (ACCUMULATE_OUTGOING_ARGS)\n     {\n-      enum machine_mode save_mode = GET_MODE (save_area);\n+#ifdef REG_PARM_STACK_SPACE\n+      if (save_area)\n+\t{\n+\t  enum machine_mode save_mode = GET_MODE (save_area);\n #ifdef ARGS_GROW_DOWNWARD\n-      rtx stack_area\n-\t= gen_rtx_MEM (save_mode,\n-\t\t       memory_address (save_mode,\n-\t\t\t\t       plus_constant (argblock,\n-\t\t\t\t\t\t      - high_to_save)));\n+\t  rtx stack_area\n+\t    = gen_rtx_MEM (save_mode,\n+\t\t\t   memory_address (save_mode,\n+\t\t\t\t\t   plus_constant (argblock,\n+\t\t\t\t\t\t\t  - high_to_save)));\n #else\n-      rtx stack_area\n-\t= gen_rtx_MEM (save_mode,\n-\t\t       memory_address (save_mode,\n-\t\t\t\t       plus_constant (argblock, low_to_save)));\n+\t  rtx stack_area\n+\t    = gen_rtx_MEM (save_mode,\n+\t\t\t   memory_address (save_mode,\n+\t\t\t\t\t   plus_constant (argblock, low_to_save)));\n #endif\n-      if (save_mode != BLKmode)\n-\temit_move_insn (stack_area, save_area);\n-      else\n-\temit_block_move (stack_area, validize_mem (save_area),\n-\t\t\t GEN_INT (high_to_save - low_to_save + 1),\n-\t\t\t     PARM_BOUNDARY / BITS_PER_UNIT);\n-    }\n+\t  if (save_mode != BLKmode)\n+\t    emit_move_insn (stack_area, save_area);\n+\t  else\n+\t    emit_block_move (stack_area, validize_mem (save_area),\n+\t\t\t     GEN_INT (high_to_save - low_to_save + 1),\n+\t\t\t\t PARM_BOUNDARY / BITS_PER_UNIT);\n+\t}\n #endif\n-\t  \n-  /* If we saved any argument areas, restore them.  */\n-  for (count = 0; count < nargs; count++)\n-    if (argvec[count].save_area)\n-      {\n-\tenum machine_mode save_mode = GET_MODE (argvec[count].save_area);\n-\trtx stack_area\n-\t  = gen_rtx_MEM (save_mode,\n-\t\t\t memory_address\n-\t\t\t (save_mode,\n-\t\t\t  plus_constant (argblock,\n-\t\t\t\t\t argvec[count].offset.constant)));\n-\n-\temit_move_insn (stack_area, argvec[count].save_area);\n-      }\n+\t      \n+      /* If we saved any argument areas, restore them.  */\n+      for (count = 0; count < nargs; count++)\n+\tif (argvec[count].save_area)\n+\t  {\n+\t    enum machine_mode save_mode = GET_MODE (argvec[count].save_area);\n+\t    rtx stack_area\n+\t      = gen_rtx_MEM (save_mode,\n+\t\t\t     memory_address\n+\t\t\t     (save_mode,\n+\t\t\t      plus_constant (argblock,\n+\t\t\t\t\t     argvec[count].offset.constant)));\n+\n+\t    emit_move_insn (stack_area, argvec[count].save_area);\n+\t  }\n \n-  highest_outgoing_arg_in_use = initial_highest_arg_in_use;\n-  stack_usage_map = initial_stack_usage_map;\n-#endif\n+      highest_outgoing_arg_in_use = initial_highest_arg_in_use;\n+      stack_usage_map = initial_stack_usage_map;\n+    }\n \n   return value;\n \n@@ -3847,9 +3862,7 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size,\n   rtx reg = 0;\n   int partial = 0;\n   int used = 0;\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n   int i, lower_bound = 0, upper_bound = 0;\n-#endif\n \n   if (TREE_CODE (pval) == ERROR_MARK)\n     return;\n@@ -3858,75 +3871,75 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size,\n      this argument.  */\n   push_temp_slots ();\n \n-#ifdef ACCUMULATE_OUTGOING_ARGS\n-  /* If this is being stored into a pre-allocated, fixed-size, stack area,\n-     save any previous data at that location.  */\n-  if (argblock && ! variable_size && arg->stack)\n+  if (ACCUMULATE_OUTGOING_ARGS)\n     {\n+      /* If this is being stored into a pre-allocated, fixed-size, stack area,\n+\t save any previous data at that location.  */\n+      if (argblock && ! variable_size && arg->stack)\n+\t{\n #ifdef ARGS_GROW_DOWNWARD\n-      /* stack_slot is negative, but we want to index stack_usage_map\n-         with positive values.  */\n-      if (GET_CODE (XEXP (arg->stack_slot, 0)) == PLUS)\n-\tupper_bound = -INTVAL (XEXP (XEXP (arg->stack_slot, 0), 1)) + 1;\n-      else\n-\tupper_bound = 0;\n+\t  /* stack_slot is negative, but we want to index stack_usage_map\n+\t     with positive values.  */\n+\t  if (GET_CODE (XEXP (arg->stack_slot, 0)) == PLUS)\n+\t    upper_bound = -INTVAL (XEXP (XEXP (arg->stack_slot, 0), 1)) + 1;\n+\t  else\n+\t    upper_bound = 0;\n \n-      lower_bound = upper_bound - arg->size.constant;\n+\t  lower_bound = upper_bound - arg->size.constant;\n #else\n-      if (GET_CODE (XEXP (arg->stack_slot, 0)) == PLUS)\n-\tlower_bound = INTVAL (XEXP (XEXP (arg->stack_slot, 0), 1));\n-      else\n-\tlower_bound = 0;\n+\t  if (GET_CODE (XEXP (arg->stack_slot, 0)) == PLUS)\n+\t    lower_bound = INTVAL (XEXP (XEXP (arg->stack_slot, 0), 1));\n+\t  else\n+\t    lower_bound = 0;\n \n-      upper_bound = lower_bound + arg->size.constant;\n+\t  upper_bound = lower_bound + arg->size.constant;\n #endif\n \n-      for (i = lower_bound; i < upper_bound; i++)\n-\tif (stack_usage_map[i]\n-\t    /* Don't store things in the fixed argument area at this point;\n-\t       it has already been saved.  */\n-\t    && i > reg_parm_stack_space)\n-\t  break;\n-\n-      if (i != upper_bound)\n-\t{\n-\t  /* We need to make a save area.  See what mode we can make it.  */\n-\t  enum machine_mode save_mode\n-\t    = mode_for_size (arg->size.constant * BITS_PER_UNIT, MODE_INT, 1);\n-\t  rtx stack_area\n-\t    = gen_rtx_MEM (save_mode,\n-\t\t\t   memory_address (save_mode,\n-\t\t\t\t\t   XEXP (arg->stack_slot, 0)));\n+\t  for (i = lower_bound; i < upper_bound; i++)\n+\t    if (stack_usage_map[i]\n+\t\t/* Don't store things in the fixed argument area at this point;\n+\t\t   it has already been saved.  */\n+\t\t&& i > reg_parm_stack_space)\n+\t      break;\n \n-\t  if (save_mode == BLKmode)\n-\t    {\n-\t      arg->save_area = assign_stack_temp (BLKmode,\n-\t\t\t\t\t\t  arg->size.constant, 0);\n-\t      MEM_SET_IN_STRUCT_P (arg->save_area,\n-\t\t\t\t   AGGREGATE_TYPE_P (TREE_TYPE\n-\t\t\t\t\t\t     (arg->tree_value))); \n-\t      preserve_temp_slots (arg->save_area);\n-\t      emit_block_move (validize_mem (arg->save_area), stack_area,\n-\t\t\t       GEN_INT (arg->size.constant),\n-\t\t\t       PARM_BOUNDARY / BITS_PER_UNIT);\n-\t    }\n-\t  else\n+\t  if (i != upper_bound)\n \t    {\n-\t      arg->save_area = gen_reg_rtx (save_mode);\n-\t      emit_move_insn (arg->save_area, stack_area);\n+\t      /* We need to make a save area.  See what mode we can make it.  */\n+\t      enum machine_mode save_mode\n+\t\t= mode_for_size (arg->size.constant * BITS_PER_UNIT, MODE_INT, 1);\n+\t      rtx stack_area\n+\t\t= gen_rtx_MEM (save_mode,\n+\t\t\t       memory_address (save_mode,\n+\t\t\t\t\t       XEXP (arg->stack_slot, 0)));\n+\n+\t      if (save_mode == BLKmode)\n+\t\t{\n+\t\t  arg->save_area = assign_stack_temp (BLKmode,\n+\t\t\t\t\t\t      arg->size.constant, 0);\n+\t\t  MEM_SET_IN_STRUCT_P (arg->save_area,\n+\t\t\t\t       AGGREGATE_TYPE_P (TREE_TYPE\n+\t\t\t\t\t\t\t (arg->tree_value))); \n+\t\t  preserve_temp_slots (arg->save_area);\n+\t\t  emit_block_move (validize_mem (arg->save_area), stack_area,\n+\t\t\t\t   GEN_INT (arg->size.constant),\n+\t\t\t\t   PARM_BOUNDARY / BITS_PER_UNIT);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  arg->save_area = gen_reg_rtx (save_mode);\n+\t\t  emit_move_insn (arg->save_area, stack_area);\n+\t\t}\n \t    }\n \t}\n+      /* Now that we have saved any slots that will be overwritten by this\n+\t store, mark all slots this store will use.  We must do this before\n+\t we actually expand the argument since the expansion itself may\n+\t trigger library calls which might need to use the same stack slot.  */\n+      if (argblock && ! variable_size && arg->stack)\n+\tfor (i = lower_bound; i < upper_bound; i++)\n+\t  stack_usage_map[i] = 1;\n     }\n \n-  /* Now that we have saved any slots that will be overwritten by this\n-     store, mark all slots this store will use.  We must do this before\n-     we actually expand the argument since the expansion itself may\n-     trigger library calls which might need to use the same stack slot.  */\n-  if (argblock && ! variable_size && arg->stack)\n-    for (i = lower_bound; i < upper_bound; i++)\n-      stack_usage_map[i] = 1;\n-#endif\n-\n   /* If this isn't going to be placed on both the stack and in registers,\n      set up the register and number of words.  */\n   if (! arg->pass_on_stack)\n@@ -3946,7 +3959,6 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size,\n      it directly into its stack slot.  Otherwise, we can.  */\n   if (arg->value == 0)\n     {\n-#ifdef ACCUMULATE_OUTGOING_ARGS\n       /* stack_arg_under_construction is nonzero if a function argument is\n \t being evaluated directly into the outgoing argument list and\n \t expand_call must take special action to preserve the argument list\n@@ -3967,7 +3979,7 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size,\n \n       if (arg->pass_on_stack)\n \tstack_arg_under_construction++;\n-#endif\n+\n       arg->value = expand_expr (pval,\n \t\t\t\t(partial\n \t\t\t\t || TYPE_MODE (TREE_TYPE (pval)) != arg->mode)\n@@ -3981,10 +3993,8 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size,\n \targ->value = convert_modes (arg->mode, TYPE_MODE (TREE_TYPE (pval)),\n \t\t\t\t    arg->value, arg->unsignedp);\n \n-#ifdef ACCUMULATE_OUTGOING_ARGS\n       if (arg->pass_on_stack)\n \tstack_arg_under_construction--;\n-#endif\n     }\n \n   /* Don't allow anything left on stack from computation"}, {"sha": "2d46a69b54f2ed46b065912c4913925dde8b11cd", "filename": "gcc/combine.c", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -93,6 +93,20 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"real.h\"\n #include \"toplev.h\"\n+#include \"defaults.h\"\n+\n+#ifndef ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 0\n+#endif\n+\n+/* Supply a default definition for PUSH_ARGS.  */\n+#ifndef PUSH_ARGS\n+#ifdef PUSH_ROUNDING\n+#define PUSH_ARGS\t!ACCUMULATE_OUTGOING_ARGS\n+#else\n+#define PUSH_ARGS\t0\n+#endif\n+#endif\n \n /* It is not safe to use ordinary gen_lowpart in combine.\n    Use gen_lowpart_for_combine instead.  See comments there.  */\n@@ -7883,7 +7897,7 @@ nonzero_bits (x, mode)\n \t  int sp_alignment = STACK_BOUNDARY / BITS_PER_UNIT;\n \n #ifdef PUSH_ROUNDING\n-\t  if (REGNO (x) == STACK_POINTER_REGNUM)\n+\t  if (REGNO (x) == STACK_POINTER_REGNUM && PUSH_ARGS)\n \t    sp_alignment = MIN (PUSH_ROUNDING (1), sp_alignment);\n #endif\n \n@@ -11422,7 +11436,7 @@ use_crosses_set_p (x, from_cuid)\n #ifdef PUSH_ROUNDING\n       /* Don't allow uses of the stack pointer to be moved,\n \t because we don't know whether the move crosses a push insn.  */\n-      if (regno == STACK_POINTER_REGNUM)\n+      if (regno == STACK_POINTER_REGNUM && PUSH_ARGS)\n \treturn 1;\n #endif\n       for (; regno < endreg; regno++)"}, {"sha": "d7a2bd426f45aa24d58005aad010e350830eb815", "filename": "gcc/config/a29k/a29k.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fa29k%2Fa29k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fa29k%2Fa29k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.h?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -716,7 +716,7 @@ enum reg_class { NO_REGS, LR0_REGS, GENERAL_REGS, BP_REGS, FC_REGS, CR_REGS,\n /* Define this if the maximum size of all the outgoing args is to be\n    accumulated and pushed during the prologue.  The amount can be\n    found in the variable current_function_outgoing_args_size.  */\n-#define ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 1\n \n /* Offset of first parameter from the argument pointer register value.  */\n "}, {"sha": "a420543495f4d6e516f67fdf9ca158b32923c7e2", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -919,7 +919,7 @@ extern int alpha_memory_latency;\n /* Define this if the maximum size of all the outgoing args is to be\n    accumulated and pushed during the prologue.  The amount can be\n    found in the variable current_function_outgoing_args_size.  */\n-#define ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 1\n \n /* Offset of first parameter from the argument pointer register value.  */\n "}, {"sha": "b71d76294f713b3f5220f3b6fc28cfeeac3350d7", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -643,7 +643,7 @@ extern enum reg_class arc_regno_reg_class[];\n    `current_function_outgoing_args_size'.  No space will be pushed\n    onto the stack for each call; instead, the function prologue should\n    increase the stack frame size by this amount.  */\n-#define ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 1\n \n /* Value is the number of bytes of arguments automatically\n    popped when returning from a subroutine call."}, {"sha": "93e674dcb8f3f04db22f0c55c666ca8453142c57", "filename": "gcc/config/clipper/clipper.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fclipper%2Fclipper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fclipper%2Fclipper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.h?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -368,7 +368,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS, LIM_REG_CLASSES};\n /* we can't set this for clipper as library calls may have 3 args and we pass\n    only 2 args in regs. */\n \n-/* #define ACCUMULATE_OUTGOING_ARGS */\n+/* #define ACCUMULATE_OUTGOING_ARGS 1*/\n   \n \n /* Offset of first parameter from the argument pointer register value."}, {"sha": "ce2016e2e0ff885200929fb2ba7094a77807197e", "filename": "gcc/config/dsp16xx/dsp16xx.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -1071,7 +1071,7 @@ extern struct dsp16xx_frame_info current_frame_info;\n \n    It is not proper to define both 'PUSH_ROUNDING' and\n    'ACCUMULATE_OUTGOING_ARGS'. */\n-#define ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 1\n \n /* Offset of first parameter from the argument pointer\n    register value. */"}, {"sha": "4d934bab7c03045486561ed20bd4982fef2b14dd", "filename": "gcc/config/fr30/fr30.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Ffr30%2Ffr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Ffr30%2Ffr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.h?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -837,7 +837,7 @@ enum reg_class\n \n    Defining both `PUSH_ROUNDING' and `ACCUMULATE_OUTGOING_ARGS' is not\n    proper.  */\n-#define ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 1\n \n /* A C expression that should indicate the number of bytes of its own arguments\n    that a function pops on returning, or 0 if the function pops no arguments"}, {"sha": "08ac64484ce10b010e89596d87119c2b5c5b6fcc", "filename": "gcc/config/i370/i370.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fi370%2Fi370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fi370%2Fi370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.h?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -520,7 +520,7 @@ enum reg_class\n /* Accumulate the outgoing argument count so we can request the right\n    DSA size and determine stack offset.  */\n \n-#define ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 1\n \n /* Define offset from stack pointer, to location where a parm can be\n    pushed.  */"}, {"sha": "6696b8bff087bf574637f90130b368a7099c890c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -1797,6 +1797,9 @@ ix86_compute_frame_size (size, nregs_on_stack, rpadding1, rpadding2)\n \n   offset += nregs * UNITS_PER_WORD;\n \n+  if (ACCUMULATE_OUTGOING_ARGS)\n+    total_size += current_function_outgoing_args_size;\n+\n   total_size += offset;\n \n   /* Align start of frame for local function.  */\n@@ -1808,6 +1811,9 @@ ix86_compute_frame_size (size, nregs_on_stack, rpadding1, rpadding2)\n   padding2 = ((total_size + preferred_alignment - 1)\n \t      & -preferred_alignment) - total_size;\n \n+  if (ACCUMULATE_OUTGOING_ARGS)\n+    padding2 += current_function_outgoing_args_size;\n+\n   if (nregs_on_stack)\n     *nregs_on_stack = nregs;\n   if (rpadding1)"}, {"sha": "2a4c1cacf4b57c72bba9272c1815b9e335441f1e", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -100,6 +100,8 @@ extern int target_flags;\n #define MASK_STACK_PROBE\t0x00000100\t/* Enable stack probing */\n #define MASK_NO_ALIGN_STROPS\t0x00001000\t/* Enable aligning of string ops. */\n #define MASK_INLINE_ALL_STROPS\t0x00002000\t/* Inline stringops in all cases */\n+#define MASK_NO_PUSH_ARGS\t0x00004000\t/* Use push instructions */\n+#define MASK_ACCUMULATE_OUTGOING_ARGS 0x00008000/* Accumulate outgoing args */\n \n /* Temporary codegen switches */\n #define MASK_INTEL_SYNTAX\t0x00000200\n@@ -119,6 +121,13 @@ extern int target_flags;\n    faster code on the pentium.  */\n #define TARGET_ALIGN_DOUBLE (target_flags & MASK_ALIGN_DOUBLE)\n \n+/* Use push instructions to save outgoing args.  */\n+#define TARGET_PUSH_ARGS (!(target_flags & MASK_NO_PUSH_ARGS))\n+\n+/* Accumulate stack adjustments to prologue/epilogue.  */\n+#define TARGET_ACCUMULATE_OUTGOING_ARGS \\\n+ (target_flags & MASK_ACCUMULATE_OUTGOING_ARGS)\n+\n /* Put uninitialized locals into bss, not data.\n    Meaningful only on svr3.  */\n #define TARGET_SVR3_SHLIB (target_flags & MASK_SVR3_SHLIB)\n@@ -254,6 +263,14 @@ extern const int x86_promote_hi_regs;\n     \"Inline all known string operations\" },\t\t\t\t      \\\n   { \"no-inline-all-stringops\",\t-MASK_INLINE_ALL_STROPS,\t\t      \\\n     \"Do not inline all known string operations\" },\t\t\t      \\\n+  { \"push-args\",\t\t-MASK_NO_PUSH_ARGS,\t\t\t      \\\n+    \"Use push instructions to save outgoing arguments\" },\t\t      \\\n+  { \"no-push-args\",\t\tMASK_NO_PUSH_ARGS, \"\"\t\t\t      \\\n+    \"UDo not use push instructions to save outgoing arguments\" },\t      \\\n+  { \"accumulate-outgoing-args\",\tMASK_ACCUMULATE_OUTGOING_ARGS,\t\t      \\\n+    \"Use push instructions to save outgoing arguments\" },\t\t      \\\n+  { \"no-accumulate-outgoing-args\",-MASK_ACCUMULATE_OUTGOING_ARGS, \"\"\t      \\\n+    \"Do not use push instructions to save outgoing arguments\" },\t      \\\n   SUBTARGET_SWITCHES\t\t\t\t\t\t\t      \\\n   { \"\", TARGET_DEFAULT, 0 }}\n \n@@ -1136,6 +1153,19 @@ enum reg_class\n \n #define PUSH_ROUNDING(BYTES) (((BYTES) + 1) & (-2))\n \n+/* If defined, the maximum amount of space required for outgoing arguments will\n+   be computed and placed into the variable\n+   `current_function_outgoing_args_size'.  No space will be pushed onto the\n+   stack for each call; instead, the function prologue should increase the stack\n+   frame size by this amount.  */\n+\n+#define ACCUMULATE_OUTGOING_ARGS TARGET_ACCUMULATE_OUTGOING_ARGS\n+\n+/* If defined, a C expression whose value is nonzero when we want to use PUSH\n+   instructions to pass outgoing arguments.  */\n+\n+#define PUSH_ARGS (TARGET_PUSH_ARGS && !ACCUMULATE_OUTGOING_ARGS)\n+\n /* Offset of first parameter from the argument pointer register value.  */\n #define FIRST_PARM_OFFSET(FNDECL) 0\n "}, {"sha": "10cc66560adc295d9ac4473c3b2fa56d891ad323", "filename": "gcc/config/i960/i960.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -833,7 +833,7 @@ enum reg_class { NO_REGS, GLOBAL_REGS, LOCAL_REGS, LOCAL_OR_GLOBAL_REGS,\n #define OUTGOING_REG_PARM_STACK_SPACE\n \n /* Keep the stack pointer constant throughout the function.  */\n-#define ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 1\n \n /* Value is 1 if returning from a function call automatically\n    pops the arguments described by the number-of-args field in the call."}, {"sha": "579cdfd5fa205fc1507a2ee075795ee3759de8ec", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -1270,7 +1270,7 @@ extern int ia64_local_regs;\n    be computed and placed into the variable\n    `current_function_outgoing_args_size'.  */\n \n-#define ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 1\n \n /* A C expression that should indicate the number of bytes of its own arguments\n    that a function pops on returning, or 0 if the function pops no arguments"}, {"sha": "4f8645c5792ced118f278bacc640d82fac1b07cd", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -983,7 +983,7 @@ M32R_STACK_ALIGN (current_function_outgoing_args_size)\n    `current_function_outgoing_args_size'.  No space will be pushed\n    onto the stack for each call; instead, the function prologue should\n    increase the stack frame size by this amount.  */\n-#define ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 1\n \n /* Define this macro if functions should assume that stack space has\n    been allocated for arguments even when their values are passed in"}, {"sha": "5cbae71a0770b724d3007cdc1de1cbb21e9c1ddb", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -872,7 +872,7 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n    `current_function_outgoing_args_size'.  No space will be pushed\n    onto the stack for each call; instead, the function prologue should\n    increase the stack frame size by this amount.  */\n-#define ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 1\n \n /* Offset from the stack pointer register to the first location at which\n    outgoing arguments are placed.  Use the default value zero.  */"}, {"sha": "94eeb94cb5ecb0b78c8222e69c8346b1a8c4e033", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -673,7 +673,7 @@ extern enum reg_class reg_class_from_letter[];\n    `current_function_outgoing_args_size'.  No space will be pushed\n    onto the stack for each call; instead, the function prologue should\n    increase the stack frame size by this amount.  */\n-#define ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 1\n \n /* Offset of first parameter from the argument pointer register value.  */\n #define FIRST_PARM_OFFSET(FNDECL)  0"}, {"sha": "e8307e58fd3a0427da3973597c4c200dbc3e2031", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -2260,7 +2260,7 @@ extern struct mips_frame_info current_frame_info;\n \n    It is not proper to define both `PUSH_ROUNDING' and\n    `ACCUMULATE_OUTGOING_ARGS'.  */\n-#define ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 1\n \n /* Offset from the argument pointer register to the first argument's\n    address.  On some machines it may depend on the data type of the"}, {"sha": "bc11832e65f5493195519968c16f2105f935ddbb", "filename": "gcc/config/mn10200/mn10200.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.h?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -401,7 +401,7 @@ enum reg_class {\n \n    We allow frame pointers to be eliminated when not having one will\n    not interfere with debugging.  */\n-#define ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 1\n #define FRAME_POINTER_REQUIRED 0\n #define CAN_DEBUG_WITHOUT_FP\n "}, {"sha": "c1507c0dba14faa1f7318b9c2c184f75acbe40f8", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -447,7 +447,7 @@ enum reg_class {\n    for a register flushback area.  */\n #define REG_PARM_STACK_SPACE(DECL) 8\n #define OUTGOING_REG_PARM_STACK_SPACE\n-#define ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 1\n \n /* So we can allocate space for return pointers once for the function\n    instead of around every call.  */"}, {"sha": "06571c9ec8dcebc8aea18ce5c5767ce58a03a39d", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -556,7 +556,7 @@ extern int target_flags;\n    This is both an optimization and a necessity: longjmp\n    doesn't behave itself when the stack pointer moves within\n    the function!  */\n-#define ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 1\n \n /* The weird HPPA calling conventions require a minimum of 48 bytes on\n    the stack: 16 bytes for register saves, and 32 bytes for magic."}, {"sha": "ec6602f80f78dfcd5d5e048587a8c1a3ef779847", "filename": "gcc/config/romp/romp.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fromp%2Fromp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fromp%2Fromp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.h?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -499,7 +499,7 @@ enum reg_class { NO_REGS, R0_REGS, R15_REGS, BASE_REGS, GENERAL_REGS,\n /* Define this if the maximum size of all the outgoing args is to be\n    accumulated and pushed during the prologue.  The amount can be\n    found in the variable current_function_outgoing_args_size.  */\n-#define ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 1\n \n /* Value is the number of bytes of arguments automatically\n    popped when returning from a subroutine call."}, {"sha": "0e0292a52ddbad0d094a2a0b4f65b0b741af7f4b", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -1283,7 +1283,7 @@ extern int rs6000_sysv_varargs_p;\n /* Define this if the maximum size of all the outgoing args is to be\n    accumulated and pushed during the prologue.  The amount can be\n    found in the variable current_function_outgoing_args_size.  */\n-#define ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 1\n \n /* Value is the number of bytes of arguments automatically\n    popped when returning from a subroutine call."}, {"sha": "12db17ab6724c0d7babadc5d99c58576cd9fdfc8", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -1606,7 +1606,7 @@ extern char leaf_reg_remap[];\n    This is both an optimization and a necessity: longjmp\n    doesn't behave itself when the stack pointer moves within\n    the function!  */\n-#define ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 1\n \n /* Value is the number of bytes of arguments automatically\n    popped when returning from a subroutine call."}, {"sha": "1badc79e103712e7e25af7ff5dc5d69f8d63af2e", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -667,7 +667,7 @@ enum reg_class\n #define PROMOTE_PROTOTYPES 1\n \n /* Keep the stack pointer constant throughout the function.  */\n-#define ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 1\n \n /* Value is the number of bytes of arguments automatically\n    popped when returning from a subroutine call."}, {"sha": "803696329d480e26ec99e228f30881188e4874a8", "filename": "gcc/expr.c", "status": "modified", "additions": 52, "deletions": 28, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -45,6 +45,19 @@ Boston, MA 02111-1307, USA.  */\n #include \"intl.h\"\n #include \"tm_p.h\"\n \n+#ifndef ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 0\n+#endif\n+\n+/* Supply a default definition for PUSH_ARGS.  */\n+#ifndef PUSH_ARGS\n+#ifdef PUSH_ROUNDING\n+#define PUSH_ARGS\t!ACCUMULATE_OUTGOING_ARGS\n+#else\n+#define PUSH_ARGS\t0\n+#endif\n+#endif\n+\n /* Decide whether a function's arguments should be processed\n    from first to last or from last to first.\n \n@@ -2820,27 +2833,36 @@ push_block (size, extra, below)\n       anti_adjust_stack (temp);\n     }\n \n-#if defined (STACK_GROWS_DOWNWARD) \\\n-    || (defined (ARGS_GROW_DOWNWARD) \\\n-\t&& !defined (ACCUMULATE_OUTGOING_ARGS))\n-\n-  /* Return the lowest stack address when STACK or ARGS grow downward and\n-     we are not aaccumulating outgoing arguments (the c4x port uses such\n-     conventions).  */\n-  temp = virtual_outgoing_args_rtx;\n-  if (extra != 0 && below)\n-    temp = plus_constant (temp, extra);\n+#ifndef STACK_GROWS_DOWNWARD\n+#ifdef ARGS_GROW_DOWNWARD\n+  if (!ACCUMULATE_OUTGOING_ARGS)\n #else\n-  if (GET_CODE (size) == CONST_INT)\n-    temp = plus_constant (virtual_outgoing_args_rtx,\n-\t\t\t  - INTVAL (size) - (below ? 0 : extra));\n-  else if (extra != 0 && !below)\n-    temp = gen_rtx_PLUS (Pmode, virtual_outgoing_args_rtx,\n-\t\t    negate_rtx (Pmode, plus_constant (size, extra)));\n-  else\n-    temp = gen_rtx_PLUS (Pmode, virtual_outgoing_args_rtx,\n-\t\t\t negate_rtx (Pmode, size));\n+  if (0)\n #endif\n+#else\n+  if (1)\n+#endif\n+    {\n+\n+      /* Return the lowest stack address when STACK or ARGS grow downward and\n+\t we are not aaccumulating outgoing arguments (the c4x port uses such\n+\t conventions).  */\n+      temp = virtual_outgoing_args_rtx;\n+      if (extra != 0 && below)\n+\ttemp = plus_constant (temp, extra);\n+    }\n+  else\n+    {\n+      if (GET_CODE (size) == CONST_INT)\n+\ttemp = plus_constant (virtual_outgoing_args_rtx,\n+\t\t\t      - INTVAL (size) - (below ? 0 : extra));\n+      else if (extra != 0 && !below)\n+\ttemp = gen_rtx_PLUS (Pmode, virtual_outgoing_args_rtx,\n+\t\t\tnegate_rtx (Pmode, plus_constant (size, extra)));\n+      else\n+\ttemp = gen_rtx_PLUS (Pmode, virtual_outgoing_args_rtx,\n+\t\t\t     negate_rtx (Pmode, size));\n+    }\n \n   return memory_address (GET_CLASS_NARROWEST_MODE (MODE_INT), temp);\n }\n@@ -2971,6 +2993,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t and if there is no difficulty with push insns that skip bytes\n \t on the stack for alignment purposes.  */\n       if (args_addr == 0\n+\t  && PUSH_ARGS\n \t  && GET_CODE (size) == CONST_INT\n \t  && skip == 0\n \t  && (MOVE_BY_PIECES_P ((unsigned) INTVAL (size) - used, align))\n@@ -3123,15 +3146,16 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t\t}\n \t    }\n \n-#ifndef ACCUMULATE_OUTGOING_ARGS\n-\t  /* If the source is referenced relative to the stack pointer,\n-\t     copy it to another register to stabilize it.  We do not need\n-\t     to do this if we know that we won't be changing sp.  */\n+\t  if (!ACCUMULATE_OUTGOING_ARGS)\n+\t    {\n+\t      /* If the source is referenced relative to the stack pointer,\n+\t\t copy it to another register to stabilize it.  We do not need\n+\t\t to do this if we know that we won't be changing sp.  */\n \n-\t  if (reg_mentioned_p (virtual_stack_dynamic_rtx, temp)\n-\t      || reg_mentioned_p (virtual_outgoing_args_rtx, temp))\n-\t    temp = copy_to_reg (temp);\n-#endif\n+\t      if (reg_mentioned_p (virtual_stack_dynamic_rtx, temp)\n+\t\t  || reg_mentioned_p (virtual_outgoing_args_rtx, temp))\n+\t\ttemp = copy_to_reg (temp);\n+\t    }\n \n \t  /* Make inhibit_defer_pop nonzero around the library call\n \t     to force it to pop the bcopy-arguments right away.  */\n@@ -3227,7 +3251,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \tanti_adjust_stack (GEN_INT (extra));\n \n #ifdef PUSH_ROUNDING\n-      if (args_addr == 0)\n+      if (args_addr == 0 && PUSH_ARGS)\n \taddr = gen_push_operand ();\n       else\n #endif"}, {"sha": "34db2aed8458c7a1688f56dc9079535da857c29e", "filename": "gcc/final.c", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -80,6 +80,10 @@ Boston, MA 02111-1307, USA.  */\n \n #endif /* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */\n \n+#ifndef ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 0\n+#endif\n+\n #ifdef XCOFF_DEBUGGING_INFO\n #include \"xcoffout.h\"\n #endif\n@@ -2279,10 +2283,10 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n       break;\n \n     case BARRIER:\n-#if defined (DWARF2_UNWIND_INFO) && !defined (ACCUMULATE_OUTGOING_ARGS)\n+#if defined (DWARF2_UNWIND_INFO)\n \t/* If we push arguments, we need to check all insns for stack\n \t   adjustments.  */\n-\tif (dwarf2out_do_frame ())\n+\tif (!ACCUMULATE_OUTGOING_ARGS && dwarf2out_do_frame ())\n \t  dwarf2out_frame_debug (insn);\n #endif\n       break;\n@@ -2885,9 +2889,10 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \n \tdebug_insn = insn;\n \n-#if defined (DWARF2_UNWIND_INFO) && !defined (ACCUMULATE_OUTGOING_ARGS)\n+#if defined (DWARF2_UNWIND_INFO)\n \t/* If we push arguments, we want to know where the calls are.  */\n-\tif (GET_CODE (insn) == CALL_INSN && dwarf2out_do_frame ())\n+\tif (!ACCUMULATE_OUTGOING_ARGS && GET_CODE (insn) == CALL_INSN\n+\t    && dwarf2out_do_frame ())\n \t  dwarf2out_frame_debug (insn);\n #endif\n \n@@ -2934,19 +2939,22 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \toutput_asm_insn (template, recog_data.operand);\n \n #if defined (DWARF2_UNWIND_INFO)\n-#if !defined (ACCUMULATE_OUTGOING_ARGS)\n \t/* If we push arguments, we need to check all insns for stack\n \t   adjustments.  */\n-\tif (GET_CODE (insn) == INSN && dwarf2out_do_frame ())\n-\t  dwarf2out_frame_debug (insn);\n-#else\n+\tif (!ACCUMULATE_OUTGOING_ARGS)\n+\t  {\n+\t    if (GET_CODE (insn) == INSN && dwarf2out_do_frame ())\n+\t      dwarf2out_frame_debug (insn);\n+\t  }\n+\telse\n+\t  {\n #if defined (HAVE_prologue)\n-\t/* If this insn is part of the prologue, emit DWARF v2\n-\t   call frame info.  */\n-\tif (RTX_FRAME_RELATED_P (insn) && dwarf2out_do_frame ())\n-\t  dwarf2out_frame_debug (insn);\n-#endif\n+\t    /* If this insn is part of the prologue, emit DWARF v2\n+\t       call frame info.  */\n+\t    if (RTX_FRAME_RELATED_P (insn) && dwarf2out_do_frame ())\n+\t      dwarf2out_frame_debug (insn);\n #endif\n+\t  }\n #endif\n \n #if 0"}, {"sha": "0ec9e61a1933478c5c010af29d08f1858446b98c", "filename": "gcc/function.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -61,6 +61,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"ggc.h\"\n #include \"tm_p.h\"\n \n+#ifndef ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 0\n+#endif\n+\n #ifndef TRAMPOLINE_ALIGNMENT\n #define TRAMPOLINE_ALIGNMENT FUNCTION_BOUNDARY\n #endif\n@@ -2738,7 +2742,6 @@ static int cfa_offset;\n \n #ifndef STACK_DYNAMIC_OFFSET\n \n-#ifdef ACCUMULATE_OUTGOING_ARGS\n /* The bottom of the stack points to the actual arguments.  If\n    REG_PARM_STACK_SPACE is defined, this includes the space for the register\n    parameters.  However, if OUTGOING_REG_PARM_STACK space is not defined,\n@@ -2749,16 +2752,14 @@ static int cfa_offset;\n \n #if defined(REG_PARM_STACK_SPACE) && ! defined(OUTGOING_REG_PARM_STACK_SPACE)\n #define STACK_DYNAMIC_OFFSET(FNDECL)\t\\\n-(current_function_outgoing_args_size\t\\\n- + REG_PARM_STACK_SPACE (FNDECL) + (STACK_POINTER_OFFSET))\n+((ACCUMULATE_OUTGOING_ARGS\t\t\t\t\t\t      \\\n+  ? (current_function_outgoing_args_size + REG_PARM_STACK_SPACE (FNDECL)) : 0)\\\n+ + (STACK_POINTER_OFFSET))\t\t\t\t\t\t      \\\n \n #else\n #define STACK_DYNAMIC_OFFSET(FNDECL)\t\\\n-(current_function_outgoing_args_size + (STACK_POINTER_OFFSET))\n-#endif\n-\n-#else\n-#define STACK_DYNAMIC_OFFSET(FNDECL) STACK_POINTER_OFFSET\n+((ACCUMULATE_OUTGOING_ARGS ? current_function_outgoing_args_size : 0)\t      \\\n+ + (STACK_POINTER_OFFSET))\n #endif\n #endif\n "}, {"sha": "946abccd67235a1d6df39783a38ee5fc77654fda", "filename": "gcc/invoke.texi", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -362,6 +362,7 @@ in the following sections.\n -malign-jumps=@var{num}  -malign-loops=@var{num}\n -malign-functions=@var{num} -mpreferred-stack-boundary=@var{num}\n -mthreads -mno-align-stringops -minline-all-stringops\n+-mpush-args -maccumulate-outgoing-args\n \n @emph{HPPA Options}\n -march=@var{architecture type}\n@@ -6024,6 +6025,21 @@ to stack space usage, such as embedded systems and operating system kernels,\n may want to reduce the preferred alignment to\n @samp{-mpreferred-stack-boundary=2}.\n \n+@item -mpush-args\n+@kindex -mpush-args\n+Use PUSH operations to store outgoing parameters. This method is shorter\n+and usually equally fast as method using SUB/MOV operations and is enabled\n+by default. In some cases disabling it may improve performance because of\n+improved scheduling and reduced dependencies.\n+\n+@item -maccumulate-outgoing-args\n+@kindex -maccumulate-outgoing-args\n+If enabled, the maximum amount of space required for outgoing arguments will be\n+computed in the function prologue. This in faster on most modern CPUs\n+because of reduced dependecies, improved scheduling and reduced stack usage\n+when preferred stack boundary is not equal to 2.  The drawback is a notable\n+increase in code size. This switch implies -mno-push-args.\n+\n @item -mthreads\n @kindex -mthreads\n Support thread-safe exception handling on @samp{Mingw32}. Code that relies "}, {"sha": "dac89115101e30ee12f65775d3e16618a7f05771", "filename": "gcc/tm.texi", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -2630,15 +2630,24 @@ errors in certain cases of mismatch, it also makes for better\n code on certain machines.  If the macro is not defined in target\n header files, it defaults to 0.\n \n+@findex PUSH_ARGS\n+@item PUSH_ARGS\n+A C expression. If nonzero, push insns will be used to pass\n+outgoing arguments.\n+If the target machine does not have a push instruction, set it to zero.\n+That directs GCC to use an alternate strategy: to\n+allocate the entire argument block and then store the arguments into\n+it.  When PUSH_ARGS is nonzero, PUSH_ROUNDING must be defined too.\n+On some machines, the definition\n+\n+@findex PUSH_ROUNDING\n+@item PUSH_ROUNDING (@var{npushed})\n+A C expression that is the number of bytes actually pushed onto the\n+stack when an instruction attempts to push @var{npushed} bytes.\n @findex PUSH_ROUNDING\n @item PUSH_ROUNDING (@var{npushed})\n A C expression that is the number of bytes actually pushed onto the\n stack when an instruction attempts to push @var{npushed} bytes.\n-\n-If the target machine does not have a push instruction, do not define\n-this macro.  That directs GCC to use an alternate strategy: to\n-allocate the entire argument block and then store the arguments into\n-it.\n \n On some machines, the definition\n \n@@ -2658,13 +2667,13 @@ alignment.  Then the definition should be\n @findex ACCUMULATE_OUTGOING_ARGS\n @findex current_function_outgoing_args_size\n @item ACCUMULATE_OUTGOING_ARGS\n-If defined, the maximum amount of space required for outgoing arguments\n+A C expression. If nonzero, the maximum amount of space required for outgoing arguments\n will be computed and placed into the variable\n @code{current_function_outgoing_args_size}.  No space will be pushed\n onto the stack for each call; instead, the function prologue should\n increase the stack frame size by this amount.\n \n-Defining both @code{PUSH_ROUNDING} and @code{ACCUMULATE_OUTGOING_ARGS}\n+Setting both @code{PUSH_ARGS} and @code{ACCUMULATE_OUTGOING_ARGS}\n is not proper.\n \n @findex REG_PARM_STACK_SPACE"}, {"sha": "f91e488b2c80d89e6af1fe150d11bf8caacf81ec", "filename": "gcc/toplev.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f73ad30e011e5fa64e634e576bd6297b667f9364/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=f73ad30e011e5fa64e634e576bd6297b667f9364", "patch": "@@ -61,6 +61,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"loop.h\"\n #include \"regs.h\"\n \n+#ifndef ACCUMULATE_OUTGOING_ARGS\n+#define ACCUMULATE_OUTGOING_ARGS 0\n+#endif\n+\n #ifdef DWARF_DEBUGGING_INFO\n #include \"dwarfout.h\"\n #endif\n@@ -3568,9 +3572,14 @@ rest_of_compilation (decl)\n \t\t life_analysis (insns, max_reg_num (), rtl_dump_file, 1);\n \t       });\n \n-#ifndef ACCUMULATE_OUTGOING_ARGS\n-      TIMEVAR (flow2_time, { combine_stack_adjustments (); });\n+      /* This is kind of heruistics.  We need to run combine_stack_adjustments\n+         even for machines with possibly nonzero RETURN_POPS_ARGS\n+         and ACCUMULATE_OUTGOING_ARGS.  We expect that only ports having\n+         push instructions will have popping returns.  */\n+#ifndef PUSH_ROUNDING\n+      if (!ACCUMULATE_OUTGOING_ARGS)\n #endif\n+\tTIMEVAR (flow2_time, { combine_stack_adjustments (); });\n \n       if (ggc_p)\n \tggc_collect ();"}]}