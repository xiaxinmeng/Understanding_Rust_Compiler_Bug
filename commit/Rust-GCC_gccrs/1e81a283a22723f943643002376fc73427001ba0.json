{"sha": "1e81a283a22723f943643002376fc73427001ba0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU4MWEyODNhMjI3MjNmOTQzNjQzMDAyMzc2ZmM3MzQyNzAwMWJhMA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-11-13T09:05:38Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-11-13T09:05:38Z"}, "message": "GCOV: simplify usage of function_info::artificial.\n\n2017-11-13  Martin Liska  <mliska@suse.cz>\n\n\t* gcov.c (function_info::is_artificial): New function.\n\t(process_file): Erase all artificial early.\n\t(generate_results): Skip as all artificial are already\n\tremoved.\n\nFrom-SVN: r254673", "tree": {"sha": "10270f8a6f85e34cc0945dfcff28311b734245ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10270f8a6f85e34cc0945dfcff28311b734245ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e81a283a22723f943643002376fc73427001ba0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e81a283a22723f943643002376fc73427001ba0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e81a283a22723f943643002376fc73427001ba0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e81a283a22723f943643002376fc73427001ba0/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "211bea6b40bfa457a9e8619cf653227206736e76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/211bea6b40bfa457a9e8619cf653227206736e76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/211bea6b40bfa457a9e8619cf653227206736e76"}], "stats": {"total": 73, "additions": 47, "deletions": 26}, "files": [{"sha": "993477049f774d6409a7b958582f03157a853ecb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e81a283a22723f943643002376fc73427001ba0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e81a283a22723f943643002376fc73427001ba0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e81a283a22723f943643002376fc73427001ba0", "patch": "@@ -1,3 +1,10 @@\n+2017-11-13  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcov.c (function_info::is_artificial): New function.\n+\t(process_file): Erase all artificial early.\n+\t(generate_results): Skip as all artificial are already\n+\tremoved.\n+\n 2017-11-13  Martin Liska  <mliska@suse.cz>\n \n \t* gcov.c (read_graph_file): Store to global vector of functions."}, {"sha": "01901ed7493b1a32440e256a8a912ba01ddc9060", "filename": "gcc/gcov.c", "status": "modified", "additions": 40, "deletions": 26, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e81a283a22723f943643002376fc73427001ba0/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e81a283a22723f943643002376fc73427001ba0/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=1e81a283a22723f943643002376fc73427001ba0", "patch": "@@ -232,6 +232,14 @@ typedef struct function_info\n      The line must be defined in body of the function, can't be inlined.  */\n   bool group_line_p (unsigned n, unsigned src_idx);\n \n+  /* Function filter based on function_info::artificial variable.  */\n+\n+  static inline bool\n+  is_artificial (function_info *fn)\n+  {\n+    return fn->artificial;\n+  }\n+\n   /* Name of function.  */\n   char *name;\n   char *demangled_name;\n@@ -1152,33 +1160,40 @@ process_file (const char *file_name)\n \t  fn_map.put (needle, *it);\n       }\n \n+  /* Remove all artificial function.  */\n+  functions.erase (remove_if (functions.begin (), functions.end (),\n+\t\t\t      function_info::is_artificial), functions.end ());\n+\n   for (vector<function_t *>::iterator it = functions.begin ();\n        it != functions.end (); it++)\n     {\n       function_t *fn = *it;\n+      unsigned src = fn->src;\n \n       if (fn->counts || no_data_file)\n \t{\n-\t  unsigned src = fn->src;\n-\t  unsigned block_no;\n+\t  source_info *s = &sources[src];\n+\t  s->functions.push_back (fn);\n \n-\t  /* Process only non-artificial functions.  */\n-\t  if (!fn->artificial)\n+\t  /* Mark last line in files touched by function.  */\n+\t  for (unsigned block_no = 0; block_no != fn->blocks.size ();\n+\t       block_no++)\n \t    {\n-\t      source_info *s = &sources[src];\n-\t      s->functions.push_back (fn);\n-\n-\t      /* Mark last line in files touched by function.  */\n-\t      for (block_no = 0; block_no != fn->blocks.size (); block_no++)\n+\t      block_t *block = &fn->blocks[block_no];\n+\t      for (unsigned i = 0; i < block->locations.size (); i++)\n \t\t{\n-\t\t  block_t *block = &fn->blocks[block_no];\n-\t\t  for (unsigned i = 0; i < block->locations.size (); i++)\n+\t\t  /* Sort lines of locations.  */\n+\t\t  sort (block->locations[i].lines.begin (),\n+\t\t\tblock->locations[i].lines.end ());\n+\n+\t\t  if (!block->locations[i].lines.empty ())\n \t\t    {\n-\t\t      /* Sort lines of locations.  */\n-\t\t      sort (block->locations[i].lines.begin (),\n-\t\t\t    block->locations[i].lines.end ());\n+\t\t      s = &sources[block->locations[i].source_file_idx];\n+\t\t      unsigned last_line\n+\t\t\t= block->locations[i].lines.back ();\n \n-\t\t      if (!block->locations[i].lines.empty ())\n+\t\t      /* Record new lines for the function.  */\n+\t\t      if (last_line >= s->lines.size ())\n \t\t\t{\n \t\t\t  s = &sources[block->locations[i].source_file_idx];\n \t\t\t  unsigned last_line\n@@ -1192,17 +1207,18 @@ process_file (const char *file_name)\n \t\t\t    }\n \t\t\t}\n \t\t    }\n-\n-\t\t  /* Allocate lines for group function, following start_line\n-\t\t     and end_line information of the function.  */\n-\t\t  if (fn->is_group)\n-\t\t    fn->lines.resize (fn->end_line - fn->start_line + 1);\n \t\t}\n-\n-\t      solve_flow_graph (fn);\n-\t      if (fn->has_catch)\n-\t\tfind_exception_blocks (fn);\n \t    }\n+\n+\t  /* Allocate lines for group function, following start_line\n+\t     and end_line information of the function.  */\n+\t  if (fn->is_group)\n+\t    fn->lines.resize (fn->end_line - fn->start_line + 1);\n+\n+\n+\t  solve_flow_graph (fn);\n+\t  if (fn->has_catch)\n+\t    find_exception_blocks (fn);\n \t}\n       else\n \t{\n@@ -1251,8 +1267,6 @@ generate_results (const char *file_name)\n     {\n       function_t *fn = *it;\n       coverage_t coverage;\n-      if (fn->artificial)\n-\tcontinue;\n \n       memset (&coverage, 0, sizeof (coverage));\n       coverage.name = flag_demangled_names ? fn->demangled_name : fn->name;"}]}