{"sha": "79d652a570805345efea0ee370c0f7f07eada78c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzlkNjUyYTU3MDgwNTM0NWVmZWEwZWUzNzBjMGY3ZjA3ZWFkYTc4Yw==", "commit": {"author": {"name": "Cong Hou", "email": "congh@google.com", "date": "2014-06-25T02:58:43Z"}, "committer": {"name": "Cong Hou", "email": "congh@gcc.gnu.org", "date": "2014-06-25T02:58:43Z"}, "message": "tree-vect-patterns.c (vect_recog_sad_pattern): New function for SAD pattern recognition.\n\n2014-06-24  Cong Hou  <congh@google.com>\n\n    * tree-vect-patterns.c (vect_recog_sad_pattern): New function for SAD\n    pattern recognition.\n    (type_conversion_p): PROMOTION is true if it's a type promotion\n    conversion, and false otherwise.  Return true if the given expression\n    is a type conversion one.\n    * tree-vectorizer.h: Adjust the number of patterns.\n    * tree.def: Add SAD_EXPR.\n    * optabs.def: Add sad_optab.\n    * cfgexpand.c (expand_debug_expr): Add SAD_EXPR case.\n    * expr.c (expand_expr_real_2): Likewise.\n    * gimple-pretty-print.c (dump_ternary_rhs): Likewise.\n    * gimple.c (get_gimple_rhs_num_ops): Likewise.\n    * optabs.c (optab_for_tree_code): Likewise.\n    * tree-cfg.c (estimate_operator_cost): Likewise.\n    * tree-ssa-operands.c (get_expr_operands): Likewise.\n    * tree-vect-loop.c (get_initial_def_for_reduction): Likewise.\n    * config/i386/sse.md: Add SSE2 and AVX2 expand for SAD.\n    * doc/generic.texi: Add document for SAD_EXPR.\n    * doc/md.texi: Add document for ssad and usad.\n\n2014-06-24  Cong Hou  <congh@google.com>\n\n    * gcc.dg/vect/vect-reduc-sad.c: New.\n    * lib/target-supports.exp (check_effective_target_vect_usad_char): New.\n\nFrom-SVN: r211966", "tree": {"sha": "84fbd0fced8d4e426b96dfd6edf4dfa423455a70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84fbd0fced8d4e426b96dfd6edf4dfa423455a70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79d652a570805345efea0ee370c0f7f07eada78c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79d652a570805345efea0ee370c0f7f07eada78c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79d652a570805345efea0ee370c0f7f07eada78c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79d652a570805345efea0ee370c0f7f07eada78c/comments", "author": null, "committer": null, "parents": [{"sha": "22543f17af2e2f04ab57d7fc9bfed94da90345ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22543f17af2e2f04ab57d7fc9bfed94da90345ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22543f17af2e2f04ab57d7fc9bfed94da90345ba"}], "stats": {"total": 477, "additions": 471, "deletions": 6}, "files": [{"sha": "7651e6e261c42cae8a0c08a587779a4d48e258af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79d652a570805345efea0ee370c0f7f07eada78c", "patch": "@@ -1,3 +1,25 @@\n+2014-06-24  Cong Hou  <congh@google.com>\n+\n+\t* tree-vect-patterns.c (vect_recog_sad_pattern): New function for SAD\n+\tpattern recognition.\n+\t(type_conversion_p): PROMOTION is true if it's a type promotion\n+\tconversion, and false otherwise.  Return true if the given expression\n+\tis a type conversion one.\n+\t* tree-vectorizer.h: Adjust the number of patterns.\n+\t* tree.def: Add SAD_EXPR.\n+\t* optabs.def: Add sad_optab.\n+\t* cfgexpand.c (expand_debug_expr): Add SAD_EXPR case.\n+\t* expr.c (expand_expr_real_2): Likewise.\n+\t* gimple-pretty-print.c (dump_ternary_rhs): Likewise.\n+\t* gimple.c (get_gimple_rhs_num_ops): Likewise.\n+\t* optabs.c (optab_for_tree_code): Likewise.\n+\t* tree-cfg.c (estimate_operator_cost): Likewise.\n+\t* tree-ssa-operands.c (get_expr_operands): Likewise.\n+\t* tree-vect-loop.c (get_initial_def_for_reduction): Likewise.\n+\t* config/i386/sse.md: Add SSE2 and AVX2 expand for SAD.\n+\t* doc/generic.texi: Add document for SAD_EXPR.\n+\t* doc/md.texi: Add document for ssad and usad.\n+\n 2014-06-24  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* config/i386/winnt.c (i386_pe_section_type_flags): Fix const"}, {"sha": "0e079f596a5fd2bdda7a6512287254b70369a3fe", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=79d652a570805345efea0ee370c0f7f07eada78c", "patch": "@@ -3713,6 +3713,7 @@ expand_debug_expr (tree exp)\n \t{\n \tcase COND_EXPR:\n \tcase DOT_PROD_EXPR:\n+\tcase SAD_EXPR:\n \tcase WIDEN_MULT_PLUS_EXPR:\n \tcase WIDEN_MULT_MINUS_EXPR:\n \tcase FMA_EXPR:"}, {"sha": "f667362b6f72752ecd5b715d40a2946d930659eb", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=79d652a570805345efea0ee370c0f7f07eada78c", "patch": "@@ -8260,6 +8260,36 @@\n   DONE;\n })\n \n+(define_expand \"usadv16qi\"\n+  [(match_operand:V4SI 0 \"register_operand\")\n+   (match_operand:V16QI 1 \"register_operand\")\n+   (match_operand:V16QI 2 \"nonimmediate_operand\")\n+   (match_operand:V4SI 3 \"nonimmediate_operand\")]\n+  \"TARGET_SSE2\"\n+{\n+  rtx t1 = gen_reg_rtx (V2DImode);\n+  rtx t2 = gen_reg_rtx (V4SImode);\n+  emit_insn (gen_sse2_psadbw (t1, operands[1], operands[2]));\n+  convert_move (t2, t1, 0);\n+  emit_insn (gen_addv4si3 (operands[0], t2, operands[3]));\n+  DONE;\n+})\n+\n+(define_expand \"usadv32qi\"\n+  [(match_operand:V8SI 0 \"register_operand\")\n+   (match_operand:V32QI 1 \"register_operand\")\n+   (match_operand:V32QI 2 \"nonimmediate_operand\")\n+   (match_operand:V8SI 3 \"nonimmediate_operand\")]\n+  \"TARGET_AVX2\"\n+{\n+  rtx t1 = gen_reg_rtx (V4DImode);\n+  rtx t2 = gen_reg_rtx (V8SImode);\n+  emit_insn (gen_avx2_psadbw (t1, operands[1], operands[2]));\n+  convert_move (t2, t1, 0);\n+  emit_insn (gen_addv8si3 (operands[0], t2, operands[3]));\n+  DONE;\n+})\n+\n (define_insn \"ashr<mode>3\"\n   [(set (match_operand:VI24_AVX2 0 \"register_operand\" \"=x,x\")\n \t(ashiftrt:VI24_AVX2"}, {"sha": "4476f286d36f5c3005881e5d1c8d36d1b85c72fd", "filename": "gcc/doc/generic.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Fdoc%2Fgeneric.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Fdoc%2Fgeneric.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgeneric.texi?ref=79d652a570805345efea0ee370c0f7f07eada78c", "patch": "@@ -1702,6 +1702,7 @@ a value from @code{enum annot_expr_kind}.\n @tindex VEC_PACK_TRUNC_EXPR\n @tindex VEC_PACK_SAT_EXPR\n @tindex VEC_PACK_FIX_TRUNC_EXPR\n+@tindex SAD_EXPR\n \n @table @code\n @item VEC_LSHIFT_EXPR\n@@ -1782,6 +1783,15 @@ value, it is taken from the second operand. It should never evaluate to\n any other value currently, but optimizations should not rely on that\n property. In contrast with a @code{COND_EXPR}, all operands are always\n evaluated.\n+\n+@item SAD_EXPR\n+This node represents the Sum of Absolute Differences operation.  The three\n+operands must be vectors of integral types.  The first and second operand\n+must have the same type.  The size of the vector element of the third\n+operand must be at lease twice of the size of the vector element of the\n+first and second one.  The SAD is calculated between the first and second\n+operands, added to the third operand, and returned.\n+\n @end table\n \n "}, {"sha": "539865ea3da83222f7a183d1d391d8be7d663152", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=79d652a570805345efea0ee370c0f7f07eada78c", "patch": "@@ -4842,6 +4842,16 @@ wider mode, is computed and added to operand 3. Operand 3 is of a mode equal or\n wider than the mode of the product. The result is placed in operand 0, which\n is of the same mode as operand 3.\n \n+@cindex @code{ssad@var{m}} instruction pattern\n+@item @samp{ssad@var{m}}\n+@cindex @code{usad@var{m}} instruction pattern\n+@item @samp{usad@var{m}}\n+Compute the sum of absolute differences of two signed/unsigned elements.\n+Operand 1 and operand 2 are of the same mode. Their absolute difference, which\n+is of a wider mode, is computed and added to operand 3. Operand 3 is of a mode\n+equal or wider than the mode of the absolute difference. The result is placed\n+in operand 0, which is of the same mode as operand 3.\n+\n @cindex @code{ssum_widen@var{m3}} instruction pattern\n @item @samp{ssum_widen@var{m3}}\n @cindex @code{usum_widen@var{m3}} instruction pattern"}, {"sha": "4d2163f721b092e35fad464d71797aebaf0cb6e3", "filename": "gcc/expr.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=79d652a570805345efea0ee370c0f7f07eada78c", "patch": "@@ -9110,6 +9110,20 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \treturn target;\n       }\n \n+      case SAD_EXPR:\n+      {\n+\ttree oprnd0 = treeop0;\n+\ttree oprnd1 = treeop1;\n+\ttree oprnd2 = treeop2;\n+\trtx op2;\n+\n+\texpand_operands (oprnd0, oprnd1, NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n+\top2 = expand_normal (oprnd2);\n+\ttarget = expand_widen_pattern_expr (ops, op0, op1, op2,\n+\t\t\t\t\t    target, unsignedp);\n+\treturn target;\n+      }\n+\n     case REALIGN_LOAD_EXPR:\n       {\n         tree oprnd0 = treeop0;"}, {"sha": "283aca279bae23d49b67ddd6e762f55eb8b222f0", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=79d652a570805345efea0ee370c0f7f07eada78c", "patch": "@@ -437,6 +437,16 @@ dump_ternary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n       dump_generic_node (buffer, gimple_assign_rhs3 (gs), spc, flags, false);\n       pp_greater (buffer);\n       break;\n+\n+    case SAD_EXPR:\n+      pp_string (buffer, \"SAD_EXPR <\");\n+      dump_generic_node (buffer, gimple_assign_rhs1 (gs), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, gimple_assign_rhs2 (gs), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, gimple_assign_rhs3 (gs), spc, flags, false);\n+      pp_greater (buffer);\n+      break;\n     \n     case VEC_PERM_EXPR:\n       pp_string (buffer, \"VEC_PERM_EXPR <\");"}, {"sha": "4a9d37944f3ff9e1b9686203b453cc43824b1fbf", "filename": "gcc/gimple.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=79d652a570805345efea0ee370c0f7f07eada78c", "patch": "@@ -1934,6 +1934,7 @@ get_gimple_rhs_num_ops (enum tree_code code)\n       || (SYM) == WIDEN_MULT_PLUS_EXPR\t\t\t\t\t    \\\n       || (SYM) == WIDEN_MULT_MINUS_EXPR\t\t\t\t\t    \\\n       || (SYM) == DOT_PROD_EXPR\t\t\t\t\t\t    \\\n+      || (SYM) == SAD_EXPR\t\t\t\t\t\t    \\\n       || (SYM) == REALIGN_LOAD_EXPR\t\t\t\t\t    \\\n       || (SYM) == VEC_COND_EXPR\t\t\t\t\t\t    \\\n       || (SYM) == VEC_PERM_EXPR                                             \\"}, {"sha": "7ee84c4348c96a49e3749581b889364680ed292b", "filename": "gcc/optabs.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=79d652a570805345efea0ee370c0f7f07eada78c", "patch": "@@ -484,6 +484,9 @@ optab_for_tree_code (enum tree_code code, const_tree type,\n     case DOT_PROD_EXPR:\n       return TYPE_UNSIGNED (type) ? udot_prod_optab : sdot_prod_optab;\n \n+    case SAD_EXPR:\n+      return TYPE_UNSIGNED (type) ? usad_optab : ssad_optab;\n+\n     case WIDEN_MULT_PLUS_EXPR:\n       return (TYPE_UNSIGNED (type)\n \t      ? (TYPE_SATURATING (type)"}, {"sha": "b75547006585267d9f5b4f17ba972ba388852cf5", "filename": "gcc/optabs.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=79d652a570805345efea0ee370c0f7f07eada78c", "patch": "@@ -253,6 +253,8 @@ OPTAB_D (sdot_prod_optab, \"sdot_prod$I$a\")\n OPTAB_D (ssum_widen_optab, \"widen_ssum$I$a3\")\n OPTAB_D (udot_prod_optab, \"udot_prod$I$a\")\n OPTAB_D (usum_widen_optab, \"widen_usum$I$a3\")\n+OPTAB_D (usad_optab, \"usad$I$a\")\n+OPTAB_D (ssad_optab, \"ssad$I$a\")\n OPTAB_D (maskload_optab, \"maskload$a\")\n OPTAB_D (maskstore_optab, \"maskstore$a\")\n OPTAB_D (vec_extract_optab, \"vec_extract$a\")"}, {"sha": "219bef5bf32a9b0c9f1373a29064c4d43530f774", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=79d652a570805345efea0ee370c0f7f07eada78c", "patch": "@@ -1,3 +1,8 @@\n+2014-06-24  Cong Hou  <congh@google.com>\n+\n+\t* gcc.dg/vect/vect-reduc-sad.c: New.\n+\t* lib/target-supports.exp (check_effective_target_vect_usad_char): New.\n+\n 2014-06-24  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR tree-optimization/57742"}, {"sha": "15a625f6a30dc98d7e2bae8c52164f48fc106d0e", "filename": "gcc/testsuite/gcc.dg/vect/vect-reduc-sad.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-reduc-sad.c?ref=79d652a570805345efea0ee370c0f7f07eada78c", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-require-effective-target vect_usad_char } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+#define SAD N*N/2\n+\n+unsigned char X[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+unsigned char Y[N] __attribute__ ((__aligned__(__BIGGEST_ALIGNMENT__)));\n+\n+/* Sum of absolute differences between arrays of unsigned char types.\n+   Detected as a sad pattern.\n+   Vectorized on targets that support sad for unsigned chars.  */\n+\n+__attribute__ ((noinline)) int\n+foo (int len)\n+{\n+  int i;\n+  int result = 0;\n+\n+  for (i = 0; i < len; i++)\n+    result += abs (X[i] - Y[i]);\n+\n+  return result;\n+}\n+\n+\n+int\n+main (void)\n+{\n+  int i;\n+  int sad;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      X[i] = i;\n+      Y[i] = N - i;\n+      __asm__ volatile (\"\");\n+    }\n+\n+  sad = foo (N);\n+  if (sad != SAD)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vect_recog_sad_pattern: detected\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "41ecae9055095e2d873b84dc31c6185c86dca56d", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=79d652a570805345efea0ee370c0f7f07eada78c", "patch": "@@ -3919,6 +3919,26 @@ proc check_effective_target_vect_udot_hi { } {\n     return $et_vect_udot_hi_saved\n }\n \n+# Return 1 if the target plus current options supports a vector\n+# sad operation of unsigned chars, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+proc check_effective_target_vect_usad_char { } {\n+    global et_vect_usad_char\n+\n+    if [info exists et_vect_usad_char_saved] {\n+        verbose \"check_effective_target_vect_usad_char: using cached result\" 2\n+    } else {\n+        set et_vect_usad_char_saved 0\n+        if { ([istarget i?86-*-*]\n+             || [istarget x86_64-*-*]) } {\n+            set et_vect_usad_char_saved 1\n+        }\n+    }\n+    verbose \"check_effective_target_vect_usad_char: returning $et_vect_usad_char_saved\" 2\n+    return $et_vect_usad_char_saved\n+}\n \n # Return 1 if the target plus current options supports a vector\n # demotion (packing) of shorts (to chars) and ints (to shorts) "}, {"sha": "abf09d5304d002641634ea45e68c7c8939825a1f", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=79d652a570805345efea0ee370c0f7f07eada78c", "patch": "@@ -3972,6 +3972,36 @@ verify_gimple_assign_ternary (gimple stmt)\n \n       return false;\n \n+    case SAD_EXPR:\n+      if (!useless_type_conversion_p (rhs1_type, rhs2_type)\n+\t  || !useless_type_conversion_p (lhs_type, rhs3_type)\n+\t  || 2 * GET_MODE_BITSIZE (GET_MODE_INNER\n+\t\t\t\t     (TYPE_MODE (TREE_TYPE (rhs1_type))))\n+\t       > GET_MODE_BITSIZE (GET_MODE_INNER\n+\t\t\t\t     (TYPE_MODE (TREE_TYPE (lhs_type)))))\n+\t{\n+\t  error (\"type mismatch in sad expression\");\n+\t  debug_generic_expr (lhs_type);\n+\t  debug_generic_expr (rhs1_type);\n+\t  debug_generic_expr (rhs2_type);\n+\t  debug_generic_expr (rhs3_type);\n+\t  return true;\n+\t}\n+\n+      if (TREE_CODE (rhs1_type) != VECTOR_TYPE\n+\t  || TREE_CODE (rhs2_type) != VECTOR_TYPE\n+\t  || TREE_CODE (rhs3_type) != VECTOR_TYPE)\n+\t{\n+\t  error (\"vector types expected in sad expression\");\n+\t  debug_generic_expr (lhs_type);\n+\t  debug_generic_expr (rhs1_type);\n+\t  debug_generic_expr (rhs2_type);\n+\t  debug_generic_expr (rhs3_type);\n+\t  return true;\n+\t}\n+\n+      return false;\n+\n     case DOT_PROD_EXPR:\n     case REALIGN_LOAD_EXPR:\n       /* FIXME.  */"}, {"sha": "6b4d3f30ebc089783354b0c033bd75e968a60dfb", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=79d652a570805345efea0ee370c0f7f07eada78c", "patch": "@@ -3696,6 +3696,7 @@ estimate_operator_cost (enum tree_code code, eni_weights *weights,\n     case WIDEN_SUM_EXPR:\n     case WIDEN_MULT_EXPR:\n     case DOT_PROD_EXPR:\n+    case SAD_EXPR:\n     case WIDEN_MULT_PLUS_EXPR:\n     case WIDEN_MULT_MINUS_EXPR:\n     case WIDEN_LSHIFT_EXPR:"}, {"sha": "a939d41b894f6385d9be440c076d3bc4e68d6b6a", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=79d652a570805345efea0ee370c0f7f07eada78c", "patch": "@@ -859,6 +859,7 @@ get_expr_operands (struct function *fn, gimple stmt, tree *expr_p, int flags)\n       }\n \n     case DOT_PROD_EXPR:\n+    case SAD_EXPR:\n     case REALIGN_LOAD_EXPR:\n     case WIDEN_MULT_PLUS_EXPR:\n     case WIDEN_MULT_MINUS_EXPR:"}, {"sha": "7e013f3b549a07bd44789bd4d3e3701eec7c51dc", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=79d652a570805345efea0ee370c0f7f07eada78c", "patch": "@@ -3694,6 +3694,7 @@ get_initial_def_for_reduction (gimple stmt, tree init_val,\n     {\n       case WIDEN_SUM_EXPR:\n       case DOT_PROD_EXPR:\n+      case SAD_EXPR:\n       case PLUS_EXPR:\n       case MINUS_EXPR:\n       case BIT_IOR_EXPR:"}, {"sha": "ea3d542da366fdd6b81c8f9781484147dcb3d117", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 239, "deletions": 5, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=79d652a570805345efea0ee370c0f7f07eada78c", "patch": "@@ -58,6 +58,8 @@ static gimple vect_recog_widen_mult_pattern (vec<gimple> *, tree *,\n \t\t\t\t\t     tree *);\n static gimple vect_recog_dot_prod_pattern (vec<gimple> *, tree *,\n \t\t\t\t\t   tree *);\n+static gimple vect_recog_sad_pattern (vec<gimple> *, tree *,\n+\t\t\t\t      tree *);\n static gimple vect_recog_pow_pattern (vec<gimple> *, tree *, tree *);\n static gimple vect_recog_over_widening_pattern (vec<gimple> *, tree *,\n                                                  tree *);\n@@ -75,6 +77,7 @@ static vect_recog_func_ptr vect_vect_recog_func_ptrs[NUM_PATTERNS] = {\n \tvect_recog_widen_mult_pattern,\n \tvect_recog_widen_sum_pattern,\n \tvect_recog_dot_prod_pattern,\n+        vect_recog_sad_pattern,\n \tvect_recog_pow_pattern,\n \tvect_recog_widen_shift_pattern,\n \tvect_recog_over_widening_pattern,\n@@ -153,9 +156,8 @@ vect_single_imm_use (gimple def_stmt)\n }\n \n /* Check whether NAME, an ssa-name used in USE_STMT,\n-   is a result of a type promotion or demotion, such that:\n+   is a result of a type promotion, such that:\n      DEF_STMT: NAME = NOP (name0)\n-   where the type of name0 (ORIG_TYPE) is smaller/bigger than the type of NAME.\n    If CHECK_SIGN is TRUE, check that either both types are signed or both are\n    unsigned.  */\n \n@@ -202,10 +204,8 @@ type_conversion_p (tree name, gimple use_stmt, bool check_sign,\n \n   if (TYPE_PRECISION (type) >= (TYPE_PRECISION (*orig_type) * 2))\n     *promotion = true;\n-  else if (TYPE_PRECISION (*orig_type) >= (TYPE_PRECISION (type) * 2))\n-    *promotion = false;\n   else\n-    return false;\n+    *promotion = false;\n \n   if (!vect_is_simple_use (oprnd0, *def_stmt, loop_vinfo,\n \t\t\t   bb_vinfo, &dummy_gimple, &dummy, &dt))\n@@ -448,6 +448,240 @@ vect_recog_dot_prod_pattern (vec<gimple> *stmts, tree *type_in,\n }\n \n \n+/* Function vect_recog_sad_pattern\n+\n+   Try to find the following Sum of Absolute Difference (SAD) pattern:\n+\n+     type x_t, y_t;\n+     signed TYPE1 diff, abs_diff;\n+     TYPE2 sum = init;\n+   loop:\n+     sum_0 = phi <init, sum_1>\n+     S1  x_t = ...\n+     S2  y_t = ...\n+     S3  x_T = (TYPE1) x_t;\n+     S4  y_T = (TYPE1) y_t;\n+     S5  diff = x_T - y_T;\n+     S6  abs_diff = ABS_EXPR <diff>;\n+     [S7  abs_diff = (TYPE2) abs_diff;  #optional]\n+     S8  sum_1 = abs_diff + sum_0;\n+\n+   where 'TYPE1' is at least double the size of type 'type', and 'TYPE2' is the\n+   same size of 'TYPE1' or bigger. This is a special case of a reduction\n+   computation.\n+\n+   Input:\n+\n+   * STMTS: Contains a stmt from which the pattern search begins.  In the\n+   example, when this function is called with S8, the pattern\n+   {S3,S4,S5,S6,S7,S8} will be detected.\n+\n+   Output:\n+\n+   * TYPE_IN: The type of the input arguments to the pattern.\n+\n+   * TYPE_OUT: The type of the output of this pattern.\n+\n+   * Return value: A new stmt that will be used to replace the sequence of\n+   stmts that constitute the pattern. In this case it will be:\n+        SAD_EXPR <x_t, y_t, sum_0>\n+  */\n+\n+static gimple\n+vect_recog_sad_pattern (vec<gimple> *stmts, tree *type_in,\n+\t\t\t     tree *type_out)\n+{\n+  gimple last_stmt = (*stmts)[0];\n+  tree sad_oprnd0, sad_oprnd1;\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n+  tree half_type;\n+  loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+  struct loop *loop;\n+  bool promotion;\n+\n+  if (!loop_info)\n+    return NULL;\n+\n+  loop = LOOP_VINFO_LOOP (loop_info);\n+\n+  if (!is_gimple_assign (last_stmt))\n+    return NULL;\n+\n+  tree sum_type = gimple_expr_type (last_stmt);\n+\n+  /* Look for the following pattern\n+          DX = (TYPE1) X;\n+          DY = (TYPE1) Y;\n+          DDIFF = DX - DY;\n+          DAD = ABS_EXPR <DDIFF>;\n+          DDPROD = (TYPE2) DPROD;\n+          sum_1 = DAD + sum_0;\n+     In which\n+     - DX is at least double the size of X\n+     - DY is at least double the size of Y\n+     - DX, DY, DDIFF, DAD all have the same type\n+     - sum is the same size of DAD or bigger\n+     - sum has been recognized as a reduction variable.\n+\n+     This is equivalent to:\n+       DDIFF = X w- Y;          #widen sub\n+       DAD = ABS_EXPR <DDIFF>;\n+       sum_1 = DAD w+ sum_0;    #widen summation\n+     or\n+       DDIFF = X w- Y;          #widen sub\n+       DAD = ABS_EXPR <DDIFF>;\n+       sum_1 = DAD + sum_0;     #summation\n+   */\n+\n+  /* Starting from LAST_STMT, follow the defs of its uses in search\n+     of the above pattern.  */\n+\n+  if (gimple_assign_rhs_code (last_stmt) != PLUS_EXPR)\n+    return NULL;\n+\n+  tree plus_oprnd0, plus_oprnd1;\n+\n+  if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n+    {\n+      /* Has been detected as widening-summation?  */\n+\n+      gimple stmt = STMT_VINFO_RELATED_STMT (stmt_vinfo);\n+      sum_type = gimple_expr_type (stmt);\n+      if (gimple_assign_rhs_code (stmt) != WIDEN_SUM_EXPR)\n+        return NULL;\n+      plus_oprnd0 = gimple_assign_rhs1 (stmt);\n+      plus_oprnd1 = gimple_assign_rhs2 (stmt);\n+      half_type = TREE_TYPE (plus_oprnd0);\n+    }\n+  else\n+    {\n+      gimple def_stmt;\n+\n+      if (STMT_VINFO_DEF_TYPE (stmt_vinfo) != vect_reduction_def)\n+        return NULL;\n+      plus_oprnd0 = gimple_assign_rhs1 (last_stmt);\n+      plus_oprnd1 = gimple_assign_rhs2 (last_stmt);\n+      if (!types_compatible_p (TREE_TYPE (plus_oprnd0), sum_type)\n+\t  || !types_compatible_p (TREE_TYPE (plus_oprnd1), sum_type))\n+        return NULL;\n+\n+      /* The type conversion could be promotion, demotion,\n+         or just signed -> unsigned.  */\n+      if (type_conversion_p (plus_oprnd0, last_stmt, false,\n+                             &half_type, &def_stmt, &promotion))\n+        plus_oprnd0 = gimple_assign_rhs1 (def_stmt);\n+      else\n+        half_type = sum_type;\n+    }\n+\n+  /* So far so good.  Since last_stmt was detected as a (summation) reduction,\n+     we know that plus_oprnd1 is the reduction variable (defined by a loop-header\n+     phi), and plus_oprnd0 is an ssa-name defined by a stmt in the loop body.\n+     Then check that plus_oprnd0 is defined by an abs_expr.  */\n+\n+  if (TREE_CODE (plus_oprnd0) != SSA_NAME)\n+    return NULL;\n+\n+  tree abs_type = half_type;\n+  gimple abs_stmt = SSA_NAME_DEF_STMT (plus_oprnd0);\n+\n+  /* It could not be the sad pattern if the abs_stmt is outside the loop.  */\n+  if (!gimple_bb (abs_stmt) || !flow_bb_inside_loop_p (loop, gimple_bb (abs_stmt)))\n+    return NULL;\n+\n+  /* FORNOW.  Can continue analyzing the def-use chain when this stmt in a phi\n+     inside the loop (in case we are analyzing an outer-loop).  */\n+  if (!is_gimple_assign (abs_stmt))\n+    return NULL;\n+\n+  stmt_vec_info abs_stmt_vinfo = vinfo_for_stmt (abs_stmt);\n+  gcc_assert (abs_stmt_vinfo);\n+  if (STMT_VINFO_DEF_TYPE (abs_stmt_vinfo) != vect_internal_def)\n+    return NULL;\n+  if (gimple_assign_rhs_code (abs_stmt) != ABS_EXPR)\n+    return NULL;\n+\n+  tree abs_oprnd = gimple_assign_rhs1 (abs_stmt);\n+  if (!types_compatible_p (TREE_TYPE (abs_oprnd), abs_type))\n+    return NULL;\n+  if (TYPE_UNSIGNED (abs_type))\n+    return NULL;\n+\n+  /* We then detect if the operand of abs_expr is defined by a minus_expr.  */\n+\n+  if (TREE_CODE (abs_oprnd) != SSA_NAME)\n+    return NULL;\n+\n+  gimple diff_stmt = SSA_NAME_DEF_STMT (abs_oprnd);\n+\n+  /* It could not be the sad pattern if the diff_stmt is outside the loop.  */\n+  if (!gimple_bb (diff_stmt)\n+      || !flow_bb_inside_loop_p (loop, gimple_bb (diff_stmt)))\n+    return NULL;\n+\n+  /* FORNOW.  Can continue analyzing the def-use chain when this stmt in a phi\n+     inside the loop (in case we are analyzing an outer-loop).  */\n+  if (!is_gimple_assign (diff_stmt))\n+    return NULL;\n+\n+  stmt_vec_info diff_stmt_vinfo = vinfo_for_stmt (diff_stmt);\n+  gcc_assert (diff_stmt_vinfo);\n+  if (STMT_VINFO_DEF_TYPE (diff_stmt_vinfo) != vect_internal_def)\n+    return NULL;\n+  if (gimple_assign_rhs_code (diff_stmt) != MINUS_EXPR)\n+    return NULL;\n+\n+  tree half_type0, half_type1;\n+  gimple def_stmt;\n+\n+  tree minus_oprnd0 = gimple_assign_rhs1 (diff_stmt);\n+  tree minus_oprnd1 = gimple_assign_rhs2 (diff_stmt);\n+\n+  if (!types_compatible_p (TREE_TYPE (minus_oprnd0), abs_type)\n+      || !types_compatible_p (TREE_TYPE (minus_oprnd1), abs_type))\n+    return NULL;\n+  if (!type_conversion_p (minus_oprnd0, diff_stmt, false,\n+                          &half_type0, &def_stmt, &promotion)\n+      || !promotion)\n+    return NULL;\n+  sad_oprnd0 = gimple_assign_rhs1 (def_stmt);\n+\n+  if (!type_conversion_p (minus_oprnd1, diff_stmt, false,\n+                          &half_type1, &def_stmt, &promotion)\n+      || !promotion)\n+    return NULL;\n+  sad_oprnd1 = gimple_assign_rhs1 (def_stmt);\n+\n+  if (!types_compatible_p (half_type0, half_type1))\n+    return NULL;\n+  if (TYPE_PRECISION (abs_type) < TYPE_PRECISION (half_type0) * 2\n+      || TYPE_PRECISION (sum_type) < TYPE_PRECISION (half_type0) * 2)\n+    return NULL;\n+\n+  *type_in = TREE_TYPE (sad_oprnd0);\n+  *type_out = sum_type;\n+\n+  /* Pattern detected. Create a stmt to be used to replace the pattern: */\n+  tree var = vect_recog_temp_ssa_var (sum_type, NULL);\n+  gimple pattern_stmt = gimple_build_assign_with_ops\n+                          (SAD_EXPR, var, sad_oprnd0, sad_oprnd1, plus_oprnd1);\n+\n+  if (dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+                       \"vect_recog_sad_pattern: detected: \");\n+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);\n+      dump_printf (MSG_NOTE, \"\\n\");\n+    }\n+\n+  /* We don't allow changing the order of the computation in the inner-loop\n+     when doing outer-loop vectorization.  */\n+  gcc_assert (!nested_in_vect_loop_p (loop, last_stmt));\n+\n+  return pattern_stmt;\n+}\n+\n+\n /* Handle widening operation by a constant.  At the moment we support MULT_EXPR\n    and LSHIFT_EXPR.\n "}, {"sha": "a38443e142ff623c2e8e7b182236cf598dac8e90", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=79d652a570805345efea0ee370c0f7f07eada78c", "patch": "@@ -1123,7 +1123,7 @@ extern void vect_slp_transform_bb (basic_block);\n    Additional pattern recognition functions can (and will) be added\n    in the future.  */\n typedef gimple (* vect_recog_func_ptr) (vec<gimple> *, tree *, tree *);\n-#define NUM_PATTERNS 11\n+#define NUM_PATTERNS 12\n void vect_pattern_recog (loop_vec_info, bb_vec_info);\n \n /* In tree-vectorizer.c.  */"}, {"sha": "84ffe93aa6fdc827f18ca81225bca007d50b50f6", "filename": "gcc/tree.def", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d652a570805345efea0ee370c0f7f07eada78c/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=79d652a570805345efea0ee370c0f7f07eada78c", "patch": "@@ -1185,6 +1185,22 @@ DEFTREECODE (DOT_PROD_EXPR, \"dot_prod_expr\", tcc_expression, 3)\n    with the second argument.  */\n DEFTREECODE (WIDEN_SUM_EXPR, \"widen_sum_expr\", tcc_binary, 2)\n \n+/* Widening sad (sum of absolute differences).\n+   The first two arguments are of type t1 which should be integer.\n+   The third argument and the result are of type t2, such that t2 is at least\n+   twice the size of t1.  Like DOT_PROD_EXPR, SAD_EXPR (arg1,arg2,arg3) is\n+   equivalent to (note we don't have WIDEN_MINUS_EXPR now, but we assume its\n+   behavior is similar to WIDEN_SUM_EXPR):\n+       tmp = WIDEN_MINUS_EXPR (arg1, arg2)\n+       tmp2 = ABS_EXPR (tmp)\n+       arg3 = PLUS_EXPR (tmp2, arg3)\n+  or:\n+       tmp = WIDEN_MINUS_EXPR (arg1, arg2)\n+       tmp2 = ABS_EXPR (tmp)\n+       arg3 = WIDEN_SUM_EXPR (tmp2, arg3)\n+ */\n+DEFTREECODE (SAD_EXPR, \"sad_expr\", tcc_expression, 3)\n+\n /* Widening multiplication.\n    The two arguments are of type t1.\n    The result is of type t2, such that t2 is at least twice"}]}