{"sha": "b667dd7017a8f9d36d3ab266f22290d75fa527b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY2N2RkNzAxN2E4ZjlkMzZkM2FiMjY2ZjIyMjkwZDc1ZmE1MjdiMA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-08-14T08:47:11Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-08-14T08:47:11Z"}, "message": "Libsanitizer merge from trunk r368656.\n\n2019-08-14  Martin Liska  <mliska@suse.cz>\n\n\tPR sanitizer/89832\n\tPR sanitizer/91325\n\t* All source files: Merge from upstream 368656.\n\nFrom-SVN: r274426", "tree": {"sha": "4ac4174c89a321d511fafb283509ffca6562ca9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ac4174c89a321d511fafb283509ffca6562ca9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b667dd7017a8f9d36d3ab266f22290d75fa527b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b667dd7017a8f9d36d3ab266f22290d75fa527b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b667dd7017a8f9d36d3ab266f22290d75fa527b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b667dd7017a8f9d36d3ab266f22290d75fa527b0/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "063082768aab23d26e42954eb115b76318f0176d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/063082768aab23d26e42954eb115b76318f0176d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/063082768aab23d26e42954eb115b76318f0176d"}], "stats": {"total": 16501, "additions": 11985, "deletions": 4516}, "files": [{"sha": "1049000c4a349b09e17708a545238de11e77cbea", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,3 +1,9 @@\n+2019-08-14  Martin Liska  <mliska@suse.cz>\n+\n+\tPR sanitizer/89832\n+\tPR sanitizer/91325\n+\t* All source files: Merge from upstream 368656.\n+\n 2019-06-26  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* sanitizer_common/sanitizer_posix_libcdep.cc: Cherry-pick"}, {"sha": "bb1b045f488933d15b46320dec3901af53149499", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,4 +1,4 @@\n-345033\n+368656\n \n The first line of this file holds the svn revision number of the\n last merge done from the master library sources."}, {"sha": "8f59d804790c7c5ecd6d0b2e19163c189331674b", "filename": "libsanitizer/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMakefile.in?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,7 @@\n-# Makefile.in generated by automake 1.15.1 from Makefile.am.\n+# Makefile.in generated by automake 1.16.1 from Makefile.am.\n # @configure_input@\n \n-# Copyright (C) 1994-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1994-2018 Free Software Foundation, Inc.\n \n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -435,8 +435,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n \t    echo ' $(SHELL) ./config.status'; \\\n \t    $(SHELL) ./config.status;; \\\n \t  *) \\\n-\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n-\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__maybe_remake_depfiles)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__maybe_remake_depfiles);; \\\n \tesac;\n $(top_srcdir)/../multilib.am $(am__empty):\n "}, {"sha": "6c7c3d5f941e9bd1762cdedab48f01bc8d898cf3", "filename": "libsanitizer/aclocal.m4", "status": "modified", "additions": 87, "deletions": 104, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Faclocal.m4?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,6 +1,6 @@\n-# generated automatically by aclocal 1.15.1 -*- Autoconf -*-\n+# generated automatically by aclocal 1.16.1 -*- Autoconf -*-\n \n-# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1996-2018 Free Software Foundation, Inc.\n \n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -20,7 +20,7 @@ You have another version of autoconf.  It may work, but is not guaranteed to.\n If you have problems, you may need to regenerate the build system entirely.\n To do so, use the procedure documented by the package, typically 'autoreconf'.])])\n \n-# Copyright (C) 2002-2017 Free Software Foundation, Inc.\n+# Copyright (C) 2002-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -32,10 +32,10 @@ To do so, use the procedure documented by the package, typically 'autoreconf'.])\n # generated from the m4 files accompanying Automake X.Y.\n # (This private macro should not be called outside this file.)\n AC_DEFUN([AM_AUTOMAKE_VERSION],\n-[am__api_version='1.15'\n+[am__api_version='1.16'\n dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\n dnl require some minimum version.  Point them to the right macro.\n-m4_if([$1], [1.15.1], [],\n+m4_if([$1], [1.16.1], [],\n       [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n ])\n \n@@ -51,14 +51,14 @@ m4_define([_AM_AUTOCONF_VERSION], [])\n # Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n # This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\n AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n-[AM_AUTOMAKE_VERSION([1.15.1])dnl\n+[AM_AUTOMAKE_VERSION([1.16.1])dnl\n m4_ifndef([AC_AUTOCONF_VERSION],\n   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n _AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n \n # Figure out how to run the assembler.                      -*- Autoconf -*-\n \n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n+# Copyright (C) 2001-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -78,7 +78,7 @@ _AM_IF_OPTION([no-dependencies],, [_AM_DEPENDENCIES([CCAS])])dnl\n \n # AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n \n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n+# Copyright (C) 2001-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -130,7 +130,7 @@ am_aux_dir=`cd \"$ac_aux_dir\" && pwd`\n \n # AM_CONDITIONAL                                            -*- Autoconf -*-\n \n-# Copyright (C) 1997-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1997-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -161,7 +161,7 @@ AC_CONFIG_COMMANDS_PRE(\n Usually this means the macro was only invoked conditionally.]])\n fi])])\n \n-# Copyright (C) 1999-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1999-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -352,63 +352,54 @@ _AM_SUBST_NOTMAKE([am__nodep])dnl\n \n # Generate code to set up dependency tracking.              -*- Autoconf -*-\n \n-# Copyright (C) 1999-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1999-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n \n-\n # _AM_OUTPUT_DEPENDENCY_COMMANDS\n # ------------------------------\n AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n [{\n   # Older Autoconf quotes --file arguments for eval, but not when files\n   # are listed without --file.  Let's play safe and only enable the eval\n   # if we detect the quoting.\n-  case $CONFIG_FILES in\n-  *\\'*) eval set x \"$CONFIG_FILES\" ;;\n-  *)   set x $CONFIG_FILES ;;\n-  esac\n+  # TODO: see whether this extra hack can be removed once we start\n+  # requiring Autoconf 2.70 or later.\n+  AS_CASE([$CONFIG_FILES],\n+          [*\\'*], [eval set x \"$CONFIG_FILES\"],\n+          [*], [set x $CONFIG_FILES])\n   shift\n-  for mf\n+  # Used to flag and report bootstrapping failures.\n+  am_rc=0\n+  for am_mf\n   do\n     # Strip MF so we end up with the name of the file.\n-    mf=`echo \"$mf\" | sed -e 's/:.*$//'`\n-    # Check whether this is an Automake generated Makefile or not.\n-    # We used to match only the files named 'Makefile.in', but\n-    # some people rename them; so instead we look at the file content.\n-    # Grep'ing the first line is not enough: some people post-process\n-    # each Makefile.in and add a new line on top of each file to say so.\n-    # Grep'ing the whole file is not good either: AIX grep has a line\n+    am_mf=`AS_ECHO([\"$am_mf\"]) | sed -e 's/:.*$//'`\n+    # Check whether this is an Automake generated Makefile which includes\n+    # dependency-tracking related rules and includes.\n+    # Grep'ing the whole file directly is not great: AIX grep has a line\n     # limit of 2048, but all sed's we know have understand at least 4000.\n-    if sed -n 's,^#.*generated by automake.*,X,p' \"$mf\" | grep X >/dev/null 2>&1; then\n-      dirpart=`AS_DIRNAME(\"$mf\")`\n-    else\n-      continue\n-    fi\n-    # Extract the definition of DEPDIR, am__include, and am__quote\n-    # from the Makefile without running 'make'.\n-    DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n-    test -z \"$DEPDIR\" && continue\n-    am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n-    test -z \"$am__include\" && continue\n-    am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n-    # Find all dependency output files, they are included files with\n-    # $(DEPDIR) in their names.  We invoke sed twice because it is the\n-    # simplest approach to changing $(DEPDIR) to its actual value in the\n-    # expansion.\n-    for file in `sed -n \"\n-      s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n-\t sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g'`; do\n-      # Make sure the directory exists.\n-      test -f \"$dirpart/$file\" && continue\n-      fdir=`AS_DIRNAME([\"$file\"])`\n-      AS_MKDIR_P([$dirpart/$fdir])\n-      # echo \"creating $dirpart/$file\"\n-      echo '# dummy' > \"$dirpart/$file\"\n-    done\n+    sed -n 's,^am--depfiles:.*,X,p' \"$am_mf\" | grep X >/dev/null 2>&1 \\\n+      || continue\n+    am_dirpart=`AS_DIRNAME([\"$am_mf\"])`\n+    am_filepart=`AS_BASENAME([\"$am_mf\"])`\n+    AM_RUN_LOG([cd \"$am_dirpart\" \\\n+      && sed -e '/# am--include-marker/d' \"$am_filepart\" \\\n+        | $MAKE -f - am--depfiles]) || am_rc=$?\n   done\n+  if test $am_rc -ne 0; then\n+    AC_MSG_FAILURE([Something went wrong bootstrapping makefile fragments\n+    for automatic dependency tracking.  Try re-running configure with the\n+    '--disable-dependency-tracking' option to at least be able to build\n+    the package (albeit without support for automatic dependency tracking).])\n+  fi\n+  AS_UNSET([am_dirpart])\n+  AS_UNSET([am_filepart])\n+  AS_UNSET([am_mf])\n+  AS_UNSET([am_rc])\n+  rm -f conftest-deps.mk\n }\n ])# _AM_OUTPUT_DEPENDENCY_COMMANDS\n \n@@ -417,18 +408,17 @@ AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n # -----------------------------\n # This macro should only be invoked once -- use via AC_REQUIRE.\n #\n-# This code is only required when automatic dependency tracking\n-# is enabled.  FIXME.  This creates each '.P' file that we will\n-# need in order to bootstrap the dependency handling code.\n+# This code is only required when automatic dependency tracking is enabled.\n+# This creates each '.Po' and '.Plo' makefile fragment that we'll need in\n+# order to bootstrap the dependency handling code.\n AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n [AC_CONFIG_COMMANDS([depfiles],\n      [test x\"$AMDEP_TRUE\" != x\"\" || _AM_OUTPUT_DEPENDENCY_COMMANDS],\n-     [AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"])\n-])\n+     [AMDEP_TRUE=\"$AMDEP_TRUE\" MAKE=\"${MAKE-make}\"])])\n \n # Do all the work for Automake.                             -*- Autoconf -*-\n \n-# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1996-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -515,8 +505,8 @@ AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl\n AC_REQUIRE([AC_PROG_MKDIR_P])dnl\n # For better backward compatibility.  To be removed once Automake 1.9.x\n # dies out for good.  For more background, see:\n-# <http://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>\n-# <http://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>\n+# <https://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>\n+# <https://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>\n AC_SUBST([mkdir_p], ['$(MKDIR_P)'])\n # We need awk for the \"check\" target (and possibly the TAP driver).  The\n # system \"awk\" is bad on some platforms.\n@@ -583,7 +573,7 @@ END\n Aborting the configuration process, to ensure you take notice of the issue.\n \n You can download and install GNU coreutils to get an 'rm' implementation\n-that behaves properly: <http://www.gnu.org/software/coreutils/>.\n+that behaves properly: <https://www.gnu.org/software/coreutils/>.\n \n If you want to complete the configuration process using your problematic\n 'rm' anyway, export the environment variable ACCEPT_INFERIOR_RM_PROGRAM\n@@ -625,7 +615,7 @@ for _am_header in $config_headers :; do\n done\n echo \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n \n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n+# Copyright (C) 2001-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -649,7 +639,7 @@ AC_SUBST([install_sh])])\n # Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n # From Jim Meyering\n \n-# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1996-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -684,57 +674,50 @@ AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])\n \n # Check to see how 'make' treats includes.\t            -*- Autoconf -*-\n \n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n+# Copyright (C) 2001-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n \n # AM_MAKE_INCLUDE()\n # -----------------\n-# Check to see how make treats includes.\n+# Check whether make has an 'include' directive that can support all\n+# the idioms we need for our automatic dependency tracking code.\n AC_DEFUN([AM_MAKE_INCLUDE],\n-[am_make=${MAKE-make}\n-cat > confinc << 'END'\n+[AC_MSG_CHECKING([whether ${MAKE-make} supports the include directive])\n+cat > confinc.mk << 'END'\n am__doit:\n-\t@echo this is the am__doit target\n+\t@echo this is the am__doit target >confinc.out\n .PHONY: am__doit\n END\n-# If we don't find an include directive, just comment out the code.\n-AC_MSG_CHECKING([for style of include used by $am_make])\n am__include=\"#\"\n am__quote=\n-_am_result=none\n-# First try GNU make style include.\n-echo \"include confinc\" > confmf\n-# Ignore all kinds of additional output from 'make'.\n-case `$am_make -s -f confmf 2> /dev/null` in #(\n-*the\\ am__doit\\ target*)\n-  am__include=include\n-  am__quote=\n-  _am_result=GNU\n-  ;;\n-esac\n-# Now try BSD make style include.\n-if test \"$am__include\" = \"#\"; then\n-   echo '.include \"confinc\"' > confmf\n-   case `$am_make -s -f confmf 2> /dev/null` in #(\n-   *the\\ am__doit\\ target*)\n-     am__include=.include\n-     am__quote=\"\\\"\"\n-     _am_result=BSD\n-     ;;\n-   esac\n-fi\n-AC_SUBST([am__include])\n-AC_SUBST([am__quote])\n-AC_MSG_RESULT([$_am_result])\n-rm -f confinc confmf\n-])\n+# BSD make does it like this.\n+echo '.include \"confinc.mk\" # ignored' > confmf.BSD\n+# Other make implementations (GNU, Solaris 10, AIX) do it like this.\n+echo 'include confinc.mk # ignored' > confmf.GNU\n+_am_result=no\n+for s in GNU BSD; do\n+  AM_RUN_LOG([${MAKE-make} -f confmf.$s && cat confinc.out])\n+  AS_CASE([$?:`cat confinc.out 2>/dev/null`],\n+      ['0:this is the am__doit target'],\n+      [AS_CASE([$s],\n+          [BSD], [am__include='.include' am__quote='\"'],\n+          [am__include='include' am__quote=''])])\n+  if test \"$am__include\" != \"#\"; then\n+    _am_result=\"yes ($s style)\"\n+    break\n+  fi\n+done\n+rm -f confinc.* confmf.*\n+AC_MSG_RESULT([${_am_result}])\n+AC_SUBST([am__include])])\n+AC_SUBST([am__quote])])\n \n # Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n \n-# Copyright (C) 1997-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1997-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -773,7 +756,7 @@ fi\n \n # Helper functions for option handling.                     -*- Autoconf -*-\n \n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n+# Copyright (C) 2001-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -802,7 +785,7 @@ AC_DEFUN([_AM_SET_OPTIONS],\n AC_DEFUN([_AM_IF_OPTION],\n [m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n \n-# Copyright (C) 1999-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1999-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -849,7 +832,7 @@ AC_LANG_POP([C])])\n # For backward compatibility.\n AC_DEFUN_ONCE([AM_PROG_CC_C_O], [AC_REQUIRE([AC_PROG_CC])])\n \n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n+# Copyright (C) 2001-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -868,7 +851,7 @@ AC_DEFUN([AM_RUN_LOG],\n \n # Check to make sure that the build environment is sane.    -*- Autoconf -*-\n \n-# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1996-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -949,7 +932,7 @@ AC_CONFIG_COMMANDS_PRE(\n rm -f conftest.file\n ])\n \n-# Copyright (C) 2009-2017 Free Software Foundation, Inc.\n+# Copyright (C) 2009-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -1009,7 +992,7 @@ AC_SUBST([AM_BACKSLASH])dnl\n _AM_SUBST_NOTMAKE([AM_BACKSLASH])dnl\n ])\n \n-# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n+# Copyright (C) 2001-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -1037,7 +1020,7 @@ fi\n INSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\n AC_SUBST([INSTALL_STRIP_PROGRAM])])\n \n-# Copyright (C) 2006-2017 Free Software Foundation, Inc.\n+# Copyright (C) 2006-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -1056,7 +1039,7 @@ AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n \n # Check how to create a tarball.                            -*- Autoconf -*-\n \n-# Copyright (C) 2004-2017 Free Software Foundation, Inc.\n+# Copyright (C) 2004-2018 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,"}, {"sha": "7bba555b1712b08889ba988bc2fa208e815232cf", "filename": "libsanitizer/asan/Makefile.am", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2FMakefile.am?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -17,37 +17,38 @@ toolexeclib_LTLIBRARIES = libasan.la\n nodist_toolexeclib_HEADERS = libasan_preinit.o\n \n asan_files = \\\n-\tasan_activation.cc \\\n-\tasan_allocator.cc \\\n-\tasan_debugging.cc \\\n-\tasan_descriptions.cc \\\n-\tasan_errors.cc \\\n-\tasan_fake_stack.cc \\\n-\tasan_flags.cc \\\n-\tasan_globals.cc \\\n-\tasan_interceptors.cc \\\n-\tasan_interceptors_memintrinsics.cc \\\n-\tasan_linux.cc \\\n-\tasan_mac.cc \\\n-\tasan_malloc_linux.cc \\\n-\tasan_malloc_mac.cc \\\n-\tasan_malloc_win.cc \\\n-\tasan_memory_profile.cc \\\n-\tasan_new_delete.cc \\\n-\tasan_poisoning.cc \\\n-\tasan_posix.cc \\\n-\tasan_premap_shadow.cc \\\n-\tasan_report.cc \\\n-\tasan_rtems.cc \\\n-\tasan_rtl.cc \\\n-\tasan_shadow_setup.cc \\\n-\tasan_stack.cc \\\n-\tasan_stats.cc \\\n-\tasan_suppressions.cc \\\n-\tasan_thread.cc \\\n-\tasan_win.cc \\\n-\tasan_win_dll_thunk.cc \\\n-\tasan_win_dynamic_runtime_thunk.cc\n+\tasan_activation.cpp \\\n+\tasan_allocator.cpp \\\n+\tasan_debugging.cpp \\\n+\tasan_descriptions.cpp \\\n+\tasan_errors.cpp \\\n+\tasan_fake_stack.cpp \\\n+\tasan_flags.cpp \\\n+\tasan_globals.cpp \\\n+\tasan_interceptors.cpp \\\n+\tasan_interceptors_memintrinsics.cpp \\\n+\tasan_linux.cpp \\\n+\tasan_mac.cpp \\\n+\tasan_malloc_linux.cpp \\\n+\tasan_malloc_mac.cpp \\\n+\tasan_malloc_win.cpp \\\n+\tasan_memory_profile.cpp \\\n+\tasan_new_delete.cpp \\\n+\tasan_poisoning.cpp \\\n+\tasan_posix.cpp \\\n+\tasan_premap_shadow.cpp \\\n+\tasan_report.cpp \\\n+\tasan_rtems.cpp \\\n+\tasan_rtl.cpp \\\n+\tasan_shadow_setup.cpp \\\n+\tasan_stack.cpp \\\n+\tasan_stats.cpp \\\n+\tasan_suppressions.cpp \\\n+\tasan_thread.cpp \\\n+\tasan_win.cpp \\\n+\tasan_win_dll_thunk.cpp \\\n+\tasan_win_dynamic_runtime_thunk.cpp \\\n+  asan_interceptors_vfork.S\n \n libasan_la_SOURCES = $(asan_files)\n libasan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/lsan/libsanitizer_lsan.la"}, {"sha": "40041575394b68b83143aa408f7b9ac0cac39ae2", "filename": "libsanitizer/asan/Makefile.in", "status": "modified", "additions": 232, "deletions": 91, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2FMakefile.in?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,7 @@\n-# Makefile.in generated by automake 1.15.1 from Makefile.am.\n+# Makefile.in generated by automake 1.16.1 from Makefile.am.\n # @configure_input@\n \n-# Copyright (C) 1994-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1994-2018 Free Software Foundation, Inc.\n \n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -158,7 +158,8 @@ am__objects_1 = asan_activation.lo asan_allocator.lo asan_debugging.lo \\\n \tasan_posix.lo asan_premap_shadow.lo asan_report.lo \\\n \tasan_rtems.lo asan_rtl.lo asan_shadow_setup.lo asan_stack.lo \\\n \tasan_stats.lo asan_suppressions.lo asan_thread.lo asan_win.lo \\\n-\tasan_win_dll_thunk.lo asan_win_dynamic_runtime_thunk.lo\n+\tasan_win_dll_thunk.lo asan_win_dynamic_runtime_thunk.lo \\\n+\tasan_interceptors_vfork.lo\n am_libasan_la_OBJECTS = $(am__objects_1)\n libasan_la_OBJECTS = $(am_libasan_la_OBJECTS)\n AM_V_lt = $(am__v_lt_@AM_V@)\n@@ -182,8 +183,38 @@ am__v_at_0 = @\n am__v_at_1 = \n DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)\n depcomp = $(SHELL) $(top_srcdir)/../depcomp\n-am__depfiles_maybe = depfiles\n+am__maybe_remake_depfiles = depfiles\n+am__depfiles_remade = ./$(DEPDIR)/asan_activation.Plo \\\n+\t./$(DEPDIR)/asan_allocator.Plo ./$(DEPDIR)/asan_debugging.Plo \\\n+\t./$(DEPDIR)/asan_descriptions.Plo ./$(DEPDIR)/asan_errors.Plo \\\n+\t./$(DEPDIR)/asan_fake_stack.Plo ./$(DEPDIR)/asan_flags.Plo \\\n+\t./$(DEPDIR)/asan_globals.Plo ./$(DEPDIR)/asan_interceptors.Plo \\\n+\t./$(DEPDIR)/asan_interceptors_memintrinsics.Plo \\\n+\t./$(DEPDIR)/asan_interceptors_vfork.Plo \\\n+\t./$(DEPDIR)/asan_linux.Plo ./$(DEPDIR)/asan_mac.Plo \\\n+\t./$(DEPDIR)/asan_malloc_linux.Plo \\\n+\t./$(DEPDIR)/asan_malloc_mac.Plo \\\n+\t./$(DEPDIR)/asan_malloc_win.Plo \\\n+\t./$(DEPDIR)/asan_memory_profile.Plo \\\n+\t./$(DEPDIR)/asan_new_delete.Plo ./$(DEPDIR)/asan_poisoning.Plo \\\n+\t./$(DEPDIR)/asan_posix.Plo ./$(DEPDIR)/asan_premap_shadow.Plo \\\n+\t./$(DEPDIR)/asan_report.Plo ./$(DEPDIR)/asan_rtems.Plo \\\n+\t./$(DEPDIR)/asan_rtl.Plo ./$(DEPDIR)/asan_shadow_setup.Plo \\\n+\t./$(DEPDIR)/asan_stack.Plo ./$(DEPDIR)/asan_stats.Plo \\\n+\t./$(DEPDIR)/asan_suppressions.Plo ./$(DEPDIR)/asan_thread.Plo \\\n+\t./$(DEPDIR)/asan_win.Plo ./$(DEPDIR)/asan_win_dll_thunk.Plo \\\n+\t./$(DEPDIR)/asan_win_dynamic_runtime_thunk.Plo\n am__mv = mv -f\n+CPPASCOMPILE = $(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CCASFLAGS) $(CCASFLAGS)\n+LTCPPASCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=compile $(CCAS) $(DEFS) \\\n+\t$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \\\n+\t$(AM_CCASFLAGS) $(CCASFLAGS)\n+AM_V_CPPAS = $(am__v_CPPAS_@AM_V@)\n+am__v_CPPAS_ = $(am__v_CPPAS_@AM_DEFAULT_V@)\n+am__v_CPPAS_0 = @echo \"  CPPAS   \" $@;\n+am__v_CPPAS_1 = \n CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n \t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n LTCXXCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n@@ -202,6 +233,24 @@ AM_V_CXXLD = $(am__v_CXXLD_@AM_V@)\n am__v_CXXLD_ = $(am__v_CXXLD_@AM_DEFAULT_V@)\n am__v_CXXLD_0 = @echo \"  CXXLD   \" $@;\n am__v_CXXLD_1 = \n+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n+\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \\\n+\t$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \\\n+\t$(AM_CFLAGS) $(CFLAGS)\n+AM_V_CC = $(am__v_CC_@AM_V@)\n+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)\n+am__v_CC_0 = @echo \"  CC      \" $@;\n+am__v_CC_1 = \n+CCLD = $(CC)\n+LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \\\n+\t$(AM_LDFLAGS) $(LDFLAGS) -o $@\n+AM_V_CCLD = $(am__v_CCLD_@AM_V@)\n+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)\n+am__v_CCLD_0 = @echo \"  CCLD    \" $@;\n+am__v_CCLD_1 = \n SOURCES = $(libasan_la_SOURCES)\n am__can_run_installinfo = \\\n   case $$AM_UPDATE_INFO_DIR in \\\n@@ -256,8 +305,8 @@ CYGPATH_W = @CYGPATH_W@\n DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \\\n \t-D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS \\\n \t-DASAN_HAS_EXCEPTIONS=1 -DASAN_NEEDS_SEGV=1 \\\n-\t-DCAN_SANITIZE_UB=0 \\\n-\t-DASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION=0 $(am__append_1)\n+\t-DCAN_SANITIZE_UB=0 -DASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION=0 \\\n+\t$(am__append_1)\n DEPDIR = @DEPDIR@\n DSYMUTIL = @DSYMUTIL@\n DUMPBIN = @DUMPBIN@\n@@ -394,37 +443,38 @@ ACLOCAL_AMFLAGS = -I $(top_srcdir) -I $(top_srcdir)/config\n toolexeclib_LTLIBRARIES = libasan.la\n nodist_toolexeclib_HEADERS = libasan_preinit.o\n asan_files = \\\n-\tasan_activation.cc \\\n-\tasan_allocator.cc \\\n-\tasan_debugging.cc \\\n-\tasan_descriptions.cc \\\n-\tasan_errors.cc \\\n-\tasan_fake_stack.cc \\\n-\tasan_flags.cc \\\n-\tasan_globals.cc \\\n-\tasan_interceptors.cc \\\n-\tasan_interceptors_memintrinsics.cc \\\n-\tasan_linux.cc \\\n-\tasan_mac.cc \\\n-\tasan_malloc_linux.cc \\\n-\tasan_malloc_mac.cc \\\n-\tasan_malloc_win.cc \\\n-\tasan_memory_profile.cc \\\n-\tasan_new_delete.cc \\\n-\tasan_poisoning.cc \\\n-\tasan_posix.cc \\\n-\tasan_premap_shadow.cc \\\n-\tasan_report.cc \\\n-\tasan_rtems.cc \\\n-\tasan_rtl.cc \\\n-\tasan_shadow_setup.cc \\\n-\tasan_stack.cc \\\n-\tasan_stats.cc \\\n-\tasan_suppressions.cc \\\n-\tasan_thread.cc \\\n-\tasan_win.cc \\\n-\tasan_win_dll_thunk.cc \\\n-\tasan_win_dynamic_runtime_thunk.cc\n+\tasan_activation.cpp \\\n+\tasan_allocator.cpp \\\n+\tasan_debugging.cpp \\\n+\tasan_descriptions.cpp \\\n+\tasan_errors.cpp \\\n+\tasan_fake_stack.cpp \\\n+\tasan_flags.cpp \\\n+\tasan_globals.cpp \\\n+\tasan_interceptors.cpp \\\n+\tasan_interceptors_memintrinsics.cpp \\\n+\tasan_linux.cpp \\\n+\tasan_mac.cpp \\\n+\tasan_malloc_linux.cpp \\\n+\tasan_malloc_mac.cpp \\\n+\tasan_malloc_win.cpp \\\n+\tasan_memory_profile.cpp \\\n+\tasan_new_delete.cpp \\\n+\tasan_poisoning.cpp \\\n+\tasan_posix.cpp \\\n+\tasan_premap_shadow.cpp \\\n+\tasan_report.cpp \\\n+\tasan_rtems.cpp \\\n+\tasan_rtl.cpp \\\n+\tasan_shadow_setup.cpp \\\n+\tasan_stack.cpp \\\n+\tasan_stats.cpp \\\n+\tasan_suppressions.cpp \\\n+\tasan_thread.cpp \\\n+\tasan_win.cpp \\\n+\tasan_win_dll_thunk.cpp \\\n+\tasan_win_dynamic_runtime_thunk.cpp \\\n+  asan_interceptors_vfork.S\n \n libasan_la_SOURCES = $(asan_files)\n libasan_la_LIBADD =  \\\n@@ -475,7 +525,7 @@ MAKEOVERRIDES =\n all: all-am\n \n .SUFFIXES:\n-.SUFFIXES: .cc .lo .o .obj\n+.SUFFIXES: .S .cpp .lo .o .obj\n $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n \t@for dep in $?; do \\\n \t  case '$(am__configure_deps)' in \\\n@@ -493,8 +543,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n \t  *config.status*) \\\n \t    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \\\n \t  *) \\\n-\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \\\n-\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \\\n \tesac;\n \n $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n@@ -550,53 +600,81 @@ mostlyclean-compile:\n distclean-compile:\n \t-rm -f *.tab.c\n \n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_activation.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_allocator.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_debugging.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_descriptions.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_errors.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_fake_stack.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_flags.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_globals.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_interceptors.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_interceptors_memintrinsics.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_linux.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_mac.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_malloc_linux.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_malloc_mac.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_malloc_win.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_memory_profile.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_new_delete.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_poisoning.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_posix.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_premap_shadow.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_report.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_rtems.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_rtl.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_shadow_setup.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_stack.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_stats.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_suppressions.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_thread.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_win.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_win_dll_thunk.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_win_dynamic_runtime_thunk.Plo@am__quote@\n-\n-.cc.o:\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_activation.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_allocator.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_debugging.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_descriptions.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_errors.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_fake_stack.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_flags.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_globals.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_interceptors.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_interceptors_memintrinsics.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_interceptors_vfork.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_linux.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_mac.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_malloc_linux.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_malloc_mac.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_malloc_win.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_memory_profile.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_new_delete.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_poisoning.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_posix.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_premap_shadow.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_report.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_rtems.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_rtl.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_shadow_setup.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_stack.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_stats.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_suppressions.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_thread.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_win.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_win_dll_thunk.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_win_dynamic_runtime_thunk.Plo@am__quote@ # am--include-marker\n+\n+$(am__depfiles_remade):\n+\t@$(MKDIR_P) $(@D)\n+\t@echo '# dummy' >$@-t && $(am__mv) $@-t $@\n+\n+am--depfiles: $(am__depfiles_remade)\n+\n+.S.o:\n+@am__fastdepCCAS_TRUE@\t$(AM_V_CPPAS)$(CPPASCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCCAS_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tDEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS@am__nodep@)$(CPPASCOMPILE) -c -o $@ $<\n+\n+.S.obj:\n+@am__fastdepCCAS_TRUE@\t$(AM_V_CPPAS)$(CPPASCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n+@am__fastdepCCAS_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tDEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS@am__nodep@)$(CPPASCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n+\n+.S.lo:\n+@am__fastdepCCAS_TRUE@\t$(AM_V_CPPAS)$(LTCPPASCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCCAS_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tDEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS@am__nodep@)$(LTCPPASCOMPILE) -c -o $@ $<\n+\n+.cpp.o:\n @am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n @am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ $<\n \n-.cc.obj:\n+.cpp.obj:\n @am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n @am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n \n-.cc.lo:\n+.cpp.lo:\n @am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n @am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n@@ -724,7 +802,38 @@ clean-am: clean-generic clean-libtool clean-toolexeclibLTLIBRARIES \\\n \tmostlyclean-am\n \n distclean: distclean-am\n-\t-rm -rf ./$(DEPDIR)\n+\t\t-rm -f ./$(DEPDIR)/asan_activation.Plo\n+\t-rm -f ./$(DEPDIR)/asan_allocator.Plo\n+\t-rm -f ./$(DEPDIR)/asan_debugging.Plo\n+\t-rm -f ./$(DEPDIR)/asan_descriptions.Plo\n+\t-rm -f ./$(DEPDIR)/asan_errors.Plo\n+\t-rm -f ./$(DEPDIR)/asan_fake_stack.Plo\n+\t-rm -f ./$(DEPDIR)/asan_flags.Plo\n+\t-rm -f ./$(DEPDIR)/asan_globals.Plo\n+\t-rm -f ./$(DEPDIR)/asan_interceptors.Plo\n+\t-rm -f ./$(DEPDIR)/asan_interceptors_memintrinsics.Plo\n+\t-rm -f ./$(DEPDIR)/asan_interceptors_vfork.Plo\n+\t-rm -f ./$(DEPDIR)/asan_linux.Plo\n+\t-rm -f ./$(DEPDIR)/asan_mac.Plo\n+\t-rm -f ./$(DEPDIR)/asan_malloc_linux.Plo\n+\t-rm -f ./$(DEPDIR)/asan_malloc_mac.Plo\n+\t-rm -f ./$(DEPDIR)/asan_malloc_win.Plo\n+\t-rm -f ./$(DEPDIR)/asan_memory_profile.Plo\n+\t-rm -f ./$(DEPDIR)/asan_new_delete.Plo\n+\t-rm -f ./$(DEPDIR)/asan_poisoning.Plo\n+\t-rm -f ./$(DEPDIR)/asan_posix.Plo\n+\t-rm -f ./$(DEPDIR)/asan_premap_shadow.Plo\n+\t-rm -f ./$(DEPDIR)/asan_report.Plo\n+\t-rm -f ./$(DEPDIR)/asan_rtems.Plo\n+\t-rm -f ./$(DEPDIR)/asan_rtl.Plo\n+\t-rm -f ./$(DEPDIR)/asan_shadow_setup.Plo\n+\t-rm -f ./$(DEPDIR)/asan_stack.Plo\n+\t-rm -f ./$(DEPDIR)/asan_stats.Plo\n+\t-rm -f ./$(DEPDIR)/asan_suppressions.Plo\n+\t-rm -f ./$(DEPDIR)/asan_thread.Plo\n+\t-rm -f ./$(DEPDIR)/asan_win.Plo\n+\t-rm -f ./$(DEPDIR)/asan_win_dll_thunk.Plo\n+\t-rm -f ./$(DEPDIR)/asan_win_dynamic_runtime_thunk.Plo\n \t-rm -f Makefile\n distclean-am: clean-am distclean-compile distclean-generic \\\n \tdistclean-tags\n@@ -771,7 +880,38 @@ install-ps-am:\n installcheck-am:\n \n maintainer-clean: maintainer-clean-am\n-\t-rm -rf ./$(DEPDIR)\n+\t\t-rm -f ./$(DEPDIR)/asan_activation.Plo\n+\t-rm -f ./$(DEPDIR)/asan_allocator.Plo\n+\t-rm -f ./$(DEPDIR)/asan_debugging.Plo\n+\t-rm -f ./$(DEPDIR)/asan_descriptions.Plo\n+\t-rm -f ./$(DEPDIR)/asan_errors.Plo\n+\t-rm -f ./$(DEPDIR)/asan_fake_stack.Plo\n+\t-rm -f ./$(DEPDIR)/asan_flags.Plo\n+\t-rm -f ./$(DEPDIR)/asan_globals.Plo\n+\t-rm -f ./$(DEPDIR)/asan_interceptors.Plo\n+\t-rm -f ./$(DEPDIR)/asan_interceptors_memintrinsics.Plo\n+\t-rm -f ./$(DEPDIR)/asan_interceptors_vfork.Plo\n+\t-rm -f ./$(DEPDIR)/asan_linux.Plo\n+\t-rm -f ./$(DEPDIR)/asan_mac.Plo\n+\t-rm -f ./$(DEPDIR)/asan_malloc_linux.Plo\n+\t-rm -f ./$(DEPDIR)/asan_malloc_mac.Plo\n+\t-rm -f ./$(DEPDIR)/asan_malloc_win.Plo\n+\t-rm -f ./$(DEPDIR)/asan_memory_profile.Plo\n+\t-rm -f ./$(DEPDIR)/asan_new_delete.Plo\n+\t-rm -f ./$(DEPDIR)/asan_poisoning.Plo\n+\t-rm -f ./$(DEPDIR)/asan_posix.Plo\n+\t-rm -f ./$(DEPDIR)/asan_premap_shadow.Plo\n+\t-rm -f ./$(DEPDIR)/asan_report.Plo\n+\t-rm -f ./$(DEPDIR)/asan_rtems.Plo\n+\t-rm -f ./$(DEPDIR)/asan_rtl.Plo\n+\t-rm -f ./$(DEPDIR)/asan_shadow_setup.Plo\n+\t-rm -f ./$(DEPDIR)/asan_stack.Plo\n+\t-rm -f ./$(DEPDIR)/asan_stats.Plo\n+\t-rm -f ./$(DEPDIR)/asan_suppressions.Plo\n+\t-rm -f ./$(DEPDIR)/asan_thread.Plo\n+\t-rm -f ./$(DEPDIR)/asan_win.Plo\n+\t-rm -f ./$(DEPDIR)/asan_win_dll_thunk.Plo\n+\t-rm -f ./$(DEPDIR)/asan_win_dynamic_runtime_thunk.Plo\n \t-rm -f Makefile\n maintainer-clean-am: distclean-am maintainer-clean-generic\n \n@@ -793,20 +933,21 @@ uninstall-am: uninstall-nodist_toolexeclibHEADERS \\\n \n .MAKE: install-am install-strip\n \n-.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \\\n-\tclean-libtool clean-toolexeclibLTLIBRARIES cscopelist-am ctags \\\n-\tctags-am distclean distclean-compile distclean-generic \\\n-\tdistclean-libtool distclean-tags dvi dvi-am html html-am info \\\n-\tinfo-am install install-am install-data install-data-am \\\n-\tinstall-dvi install-dvi-am install-exec install-exec-am \\\n-\tinstall-html install-html-am install-info install-info-am \\\n-\tinstall-man install-nodist_toolexeclibHEADERS install-pdf \\\n-\tinstall-pdf-am install-ps install-ps-am install-strip \\\n-\tinstall-toolexeclibLTLIBRARIES installcheck installcheck-am \\\n-\tinstalldirs maintainer-clean maintainer-clean-generic \\\n-\tmostlyclean mostlyclean-compile mostlyclean-generic \\\n-\tmostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \\\n-\tuninstall-am uninstall-nodist_toolexeclibHEADERS \\\n+.PHONY: CTAGS GTAGS TAGS all all-am am--depfiles check check-am clean \\\n+\tclean-generic clean-libtool clean-toolexeclibLTLIBRARIES \\\n+\tcscopelist-am ctags ctags-am distclean distclean-compile \\\n+\tdistclean-generic distclean-libtool distclean-tags dvi dvi-am \\\n+\thtml html-am info info-am install install-am install-data \\\n+\tinstall-data-am install-dvi install-dvi-am install-exec \\\n+\tinstall-exec-am install-html install-html-am install-info \\\n+\tinstall-info-am install-man install-nodist_toolexeclibHEADERS \\\n+\tinstall-pdf install-pdf-am install-ps install-ps-am \\\n+\tinstall-strip install-toolexeclibLTLIBRARIES installcheck \\\n+\tinstallcheck-am installdirs maintainer-clean \\\n+\tmaintainer-clean-generic mostlyclean mostlyclean-compile \\\n+\tmostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \\\n+\ttags tags-am uninstall uninstall-am \\\n+\tuninstall-nodist_toolexeclibHEADERS \\\n \tuninstall-toolexeclibLTLIBRARIES\n \n .PRECIOUS: Makefile"}, {"sha": "795df95a5414ccb1f552193ab24786b34be60f34", "filename": "libsanitizer/asan/asan_activation.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_activation.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_activation.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_activation.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_activation.cc --------------------------------------*- C++ -*-===//\n+//===-- asan_activation.cpp -------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/asan/asan_activation.cc"}, {"sha": "93c290c2ae2f10c146760d91bd83456bcc7c5fa2", "filename": "libsanitizer/asan/asan_activation.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_activation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_activation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_activation.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- asan_activation.h ---------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "e0fdffc82ac334f9627f00b212e8719456402a98", "filename": "libsanitizer/asan/asan_activation_flags.inc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_activation_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_activation_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_activation_flags.inc?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- asan_activation_flags.inc -------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "b58116e17b756a23f803bd4e1d40ca8c1c61ddec", "filename": "libsanitizer/asan/asan_allocator.cpp", "status": "renamed", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_allocator.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_allocator.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_allocator.cc -------------------------------------------------===//\n+//===-- asan_allocator.cpp ------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -878,6 +879,17 @@ void *asan_calloc(uptr nmemb, uptr size, BufferedStackTrace *stack) {\n   return SetErrnoOnNull(instance.Calloc(nmemb, size, stack));\n }\n \n+void *asan_reallocarray(void *p, uptr nmemb, uptr size,\n+                        BufferedStackTrace *stack) {\n+  if (UNLIKELY(CheckForCallocOverflow(size, nmemb))) {\n+    errno = errno_ENOMEM;\n+    if (AllocatorMayReturnNull())\n+      return nullptr;\n+    ReportReallocArrayOverflow(nmemb, size, stack);\n+  }\n+  return asan_realloc(p, nmemb * size, stack);\n+}\n+\n void *asan_realloc(void *p, uptr size, BufferedStackTrace *stack) {\n   if (!p)\n     return SetErrnoOnNull(instance.Allocate(size, 8, stack, FROM_MALLOC, true));", "previous_filename": "libsanitizer/asan/asan_allocator.cc"}, {"sha": "b37d8ef4e8d2926e5014fe7a05467cd139d1023f", "filename": "libsanitizer/asan/asan_allocator.h", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,13 +1,14 @@\n //===-- asan_allocator.h ----------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n // This file is a part of AddressSanitizer, an address sanity checker.\n //\n-// ASan-private header for asan_allocator.cc.\n+// ASan-private header for asan_allocator.cpp.\n //===----------------------------------------------------------------------===//\n \n #ifndef ASAN_ALLOCATOR_H\n@@ -137,9 +138,9 @@ typedef VeryCompactSizeClassMap SizeClassMap;\n const uptr kAllocatorSpace =  0x10000000000ULL;\n const uptr kAllocatorSize  =  0x10000000000ULL;  // 3T.\n typedef DefaultSizeClassMap SizeClassMap;\n-# elif defined(__sparc__)\n+#elif defined(__sparc__)\n const uptr kAllocatorSpace = ~(uptr)0;\n-const uptr kAllocatorSize  =  0x20000000000ULL;  // 2T.\n+const uptr kAllocatorSize = 0x20000000000ULL;  // 2T.\n typedef DefaultSizeClassMap SizeClassMap;\n # elif SANITIZER_WINDOWS\n const uptr kAllocatorSpace = ~(uptr)0;\n@@ -150,44 +151,45 @@ const uptr kAllocatorSpace = 0x600000000000ULL;\n const uptr kAllocatorSize  =  0x40000000000ULL;  // 4T.\n typedef DefaultSizeClassMap SizeClassMap;\n # endif\n+template <typename AddressSpaceViewTy>\n struct AP64 {  // Allocator64 parameters. Deliberately using a short name.\n   static const uptr kSpaceBeg = kAllocatorSpace;\n   static const uptr kSpaceSize = kAllocatorSize;\n   static const uptr kMetadataSize = 0;\n   typedef __asan::SizeClassMap SizeClassMap;\n   typedef AsanMapUnmapCallback MapUnmapCallback;\n   static const uptr kFlags = 0;\n+  using AddressSpaceView = AddressSpaceViewTy;\n };\n \n-typedef SizeClassAllocator64<AP64> PrimaryAllocator;\n+template <typename AddressSpaceView>\n+using PrimaryAllocatorASVT = SizeClassAllocator64<AP64<AddressSpaceView>>;\n+using PrimaryAllocator = PrimaryAllocatorASVT<LocalAddressSpaceView>;\n #else  // Fallback to SizeClassAllocator32.\n-static const uptr kRegionSizeLog = 20;\n-static const uptr kNumRegions = SANITIZER_MMAP_RANGE_SIZE >> kRegionSizeLog;\n-# if SANITIZER_WORDSIZE == 32\n-typedef FlatByteMap<kNumRegions> ByteMap;\n-# elif SANITIZER_WORDSIZE == 64\n-typedef TwoLevelByteMap<(kNumRegions >> 12), 1 << 12> ByteMap;\n-# endif\n typedef CompactSizeClassMap SizeClassMap;\n+template <typename AddressSpaceViewTy>\n struct AP32 {\n   static const uptr kSpaceBeg = 0;\n   static const u64 kSpaceSize = SANITIZER_MMAP_RANGE_SIZE;\n   static const uptr kMetadataSize = 16;\n   typedef __asan::SizeClassMap SizeClassMap;\n-  static const uptr kRegionSizeLog = __asan::kRegionSizeLog;\n-  typedef __asan::ByteMap ByteMap;\n+  static const uptr kRegionSizeLog = 20;\n+  using AddressSpaceView = AddressSpaceViewTy;\n   typedef AsanMapUnmapCallback MapUnmapCallback;\n   static const uptr kFlags = 0;\n };\n-typedef SizeClassAllocator32<AP32> PrimaryAllocator;\n+template <typename AddressSpaceView>\n+using PrimaryAllocatorASVT = SizeClassAllocator32<AP32<AddressSpaceView> >;\n+using PrimaryAllocator = PrimaryAllocatorASVT<LocalAddressSpaceView>;\n #endif  // SANITIZER_CAN_USE_ALLOCATOR64\n \n static const uptr kNumberOfSizeClasses = SizeClassMap::kNumClasses;\n-typedef SizeClassAllocatorLocalCache<PrimaryAllocator> AllocatorCache;\n-typedef LargeMmapAllocator<AsanMapUnmapCallback> SecondaryAllocator;\n-typedef CombinedAllocator<PrimaryAllocator, AllocatorCache,\n-    SecondaryAllocator> AsanAllocator;\n \n+template <typename AddressSpaceView>\n+using AsanAllocatorASVT =\n+    CombinedAllocator<PrimaryAllocatorASVT<AddressSpaceView>>;\n+using AsanAllocator = AsanAllocatorASVT<LocalAddressSpaceView>;\n+using AllocatorCache = AsanAllocator::AllocatorCache;\n \n struct AsanThreadLocalMallocStorage {\n   uptr quarantine_cache[16];\n@@ -207,6 +209,8 @@ void asan_delete(void *ptr, uptr size, uptr alignment,\n void *asan_malloc(uptr size, BufferedStackTrace *stack);\n void *asan_calloc(uptr nmemb, uptr size, BufferedStackTrace *stack);\n void *asan_realloc(void *p, uptr size, BufferedStackTrace *stack);\n+void *asan_reallocarray(void *p, uptr nmemb, uptr size,\n+                        BufferedStackTrace *stack);\n void *asan_valloc(uptr size, BufferedStackTrace *stack);\n void *asan_pvalloc(uptr size, BufferedStackTrace *stack);\n "}, {"sha": "3fc15adf7b8cbf59a3e9ca57d30fb2cbf65c10aa", "filename": "libsanitizer/asan/asan_debugging.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_debugging.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_debugging.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_debugging.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_debugging.cc -------------------------------------------------===//\n+//===-- asan_debugging.cpp ------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/asan/asan_debugging.cc"}, {"sha": "153c874a4e775ea71560f9f384e630108b443130", "filename": "libsanitizer/asan/asan_descriptions.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_descriptions.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_descriptions.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_descriptions.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_descriptions.cc ------------------------------------*- C++ -*-===//\n+//===-- asan_descriptions.cpp -----------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/asan/asan_descriptions.cc"}, {"sha": "28b38100b85db8829e9d480153bebea365ec5600", "filename": "libsanitizer/asan/asan_descriptions.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_descriptions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_descriptions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_descriptions.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,13 +1,14 @@\n //===-- asan_descriptions.h -------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n // This file is a part of AddressSanitizer, an address sanity checker.\n //\n-// ASan-private header for asan_descriptions.cc.\n+// ASan-private header for asan_descriptions.cpp.\n // TODO(filcab): Most struct definitions should move to the interface headers.\n //===----------------------------------------------------------------------===//\n #ifndef ASAN_DESCRIPTIONS_H"}, {"sha": "75ee996ceef014449b1500d35cff7f8887c8ea64", "filename": "libsanitizer/asan/asan_errors.cpp", "status": "renamed", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_errors.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_errors.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_errors.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_errors.cc ------------------------------------------*- C++ -*-===//\n+//===-- asan_errors.cpp -----------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -34,7 +35,7 @@ static void OnStackUnwind(const SignalContext &sig,\n   // corresponding code in the sanitizer_common and we use this callback to\n   // print it.\n   static_cast<const ScarinessScoreBase *>(callback_context)->Print();\n-  GetStackTrace(stack, kStackTraceMax, sig.pc, sig.bp, sig.context, fast);\n+  stack->Unwind(sig.pc, sig.bp, sig.context, fast);\n }\n \n void ErrorDeadlySignal::Print() {\n@@ -176,6 +177,19 @@ void ErrorCallocOverflow::Print() {\n   ReportErrorSummary(scariness.GetDescription(), stack);\n }\n \n+void ErrorReallocArrayOverflow::Print() {\n+  Decorator d;\n+  Printf(\"%s\", d.Error());\n+  Report(\n+      \"ERROR: AddressSanitizer: reallocarray parameters overflow: count * size \"\n+      \"(%zd * %zd) cannot be represented in type size_t (thread %s)\\n\",\n+      count, size, AsanThreadIdAndName(tid).c_str());\n+  Printf(\"%s\", d.Default());\n+  stack->Print();\n+  PrintHintAllocatorCannotReturnNull();\n+  ReportErrorSummary(scariness.GetDescription(), stack);\n+}\n+\n void ErrorPvallocOverflow::Print() {\n   Decorator d;\n   Printf(\"%s\", d.Error());", "previous_filename": "libsanitizer/asan/asan_errors.cc"}, {"sha": "b84f56c18535de5ad2a3f9eca2560f14a6216fed", "filename": "libsanitizer/asan/asan_errors.h", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_errors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_errors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_errors.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- asan_errors.h -------------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -162,6 +163,21 @@ struct ErrorCallocOverflow : ErrorBase {\n   void Print();\n };\n \n+struct ErrorReallocArrayOverflow : ErrorBase {\n+  const BufferedStackTrace *stack;\n+  uptr count;\n+  uptr size;\n+\n+  ErrorReallocArrayOverflow() = default;  // (*)\n+  ErrorReallocArrayOverflow(u32 tid, BufferedStackTrace *stack_, uptr count_,\n+                            uptr size_)\n+      : ErrorBase(tid, 10, \"reallocarray-overflow\"),\n+        stack(stack_),\n+        count(count_),\n+        size(size_) {}\n+  void Print();\n+};\n+\n struct ErrorPvallocOverflow : ErrorBase {\n   const BufferedStackTrace *stack;\n   uptr size;\n@@ -370,6 +386,7 @@ struct ErrorGeneric : ErrorBase {\n   macro(MallocUsableSizeNotOwned)               \\\n   macro(SanitizerGetAllocatedSizeNotOwned)      \\\n   macro(CallocOverflow)                         \\\n+  macro(ReallocArrayOverflow)                   \\\n   macro(PvallocOverflow)                        \\\n   macro(InvalidAllocationAlignment)             \\\n   macro(InvalidAlignedAllocAlignment)           \\\n@@ -387,8 +404,10 @@ struct ErrorGeneric : ErrorBase {\n \n #define ASAN_DEFINE_ERROR_KIND(name) kErrorKind##name,\n #define ASAN_ERROR_DESCRIPTION_MEMBER(name) Error##name name;\n-#define ASAN_ERROR_DESCRIPTION_CONSTRUCTOR(name) \\\n-  ErrorDescription(Error##name const &e) : kind(kErrorKind##name), name(e) {}\n+#define ASAN_ERROR_DESCRIPTION_CONSTRUCTOR(name)                    \\\n+  ErrorDescription(Error##name const &e) : kind(kErrorKind##name) { \\\n+    internal_memcpy(&name, &e, sizeof(name));                       \\\n+  }\n #define ASAN_ERROR_DESCRIPTION_PRINT(name) \\\n   case kErrorKind##name:                   \\\n     return name.Print();"}, {"sha": "295e6debc96c2d72bc399efa6c11a25ed0461b8f", "filename": "libsanitizer/asan/asan_fake_stack.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_fake_stack.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_fake_stack.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_fake_stack.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_fake_stack.cc ------------------------------------------------===//\n+//===-- asan_fake_stack.cpp -----------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/asan/asan_fake_stack.cc"}, {"sha": "270a19816d6e21b8a971ee4c9a41d308f4ce23b2", "filename": "libsanitizer/asan/asan_fake_stack.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_fake_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_fake_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_fake_stack.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,13 +1,14 @@\n //===-- asan_fake_stack.h ---------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n // This file is a part of AddressSanitizer, an address sanity checker.\n //\n-// ASan-private header for asan_fake_stack.cc, implements FakeStack.\n+// ASan-private header for asan_fake_stack.cpp, implements FakeStack.\n //===----------------------------------------------------------------------===//\n \n #ifndef ASAN_FAKE_STACK_H"}, {"sha": "c5c70eaed737fe6ace886b3330db265c890ea383", "filename": "libsanitizer/asan/asan_flags.cpp", "status": "renamed", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_flags.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_flags.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_flags.cc -------------------------------------------*- C++ -*-===//\n+//===-- asan_flags.cpp ------------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -119,12 +120,12 @@ void InitializeFlags() {\n #endif\n \n   // Override from command line.\n-  asan_parser.ParseString(GetEnv(\"ASAN_OPTIONS\"));\n+  asan_parser.ParseStringFromEnv(\"ASAN_OPTIONS\");\n #if CAN_SANITIZE_LEAKS\n-  lsan_parser.ParseString(GetEnv(\"LSAN_OPTIONS\"));\n+  lsan_parser.ParseStringFromEnv(\"LSAN_OPTIONS\");\n #endif\n #if CAN_SANITIZE_UB\n-  ubsan_parser.ParseString(GetEnv(\"UBSAN_OPTIONS\"));\n+  ubsan_parser.ParseStringFromEnv(\"UBSAN_OPTIONS\");\n #endif\n \n   InitializeCommonFlags();", "previous_filename": "libsanitizer/asan/asan_flags.cc"}, {"sha": "b55c81f07d4bd170e7d9a0f7a9d046af69541541", "filename": "libsanitizer/asan/asan_flags.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- asan_flags.h -------------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "d360e03ca55ead1d4a5b0cda774823a98f193489", "filename": "libsanitizer/asan/asan_flags.inc", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.inc?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- asan_flags.inc ------------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -150,12 +151,12 @@ ASAN_FLAG(const char *, suppressions, \"\", \"Suppressions file name.\")\n ASAN_FLAG(bool, halt_on_error, true,\n           \"Crash the program after printing the first error report \"\n           \"(WARNING: USE AT YOUR OWN RISK!)\")\n-ASAN_FLAG(bool, use_odr_indicator, false,\n-          \"Use special ODR indicator symbol for ODR violation detection\")\n ASAN_FLAG(bool, allocator_frees_and_returns_null_on_realloc_zero, true,\n           \"realloc(p, 0) is equivalent to free(p) by default (Same as the \"\n           \"POSIX standard). If set to false, realloc(p, 0) will return a \"\n           \"pointer to an allocated space which can not be used.\")\n ASAN_FLAG(bool, verify_asan_link_order, true,\n           \"Check position of ASan runtime in library list (needs to be disabled\"\n           \" when other library has to be preloaded system-wide)\")\n+ASAN_FLAG(bool, windows_hook_rtl_allocators, false,\n+          \"(Windows only) enable hooking of Rtl(Allocate|Free|Size|ReAllocate)Heap.\")"}, {"sha": "f8b2d5f26979dfa5a62acd3a69a49afbecfefb40", "filename": "libsanitizer/asan/asan_fuchsia.cpp", "status": "renamed", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_fuchsia.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_fuchsia.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_fuchsia.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_fuchsia.cc --------------------------------------------------===//\n+//===-- asan_fuchsia.cpp -------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===---------------------------------------------------------------------===//\n //\n@@ -27,7 +28,7 @@ namespace __asan {\n \n // The system already set up the shadow memory for us.\n // __sanitizer::GetMaxUserVirtualAddress has already been called by\n-// AsanInitInternal->InitializeHighMemEnd (asan_rtl.cc).\n+// AsanInitInternal->InitializeHighMemEnd (asan_rtl.cpp).\n // Just do some additional sanity checks here.\n void InitializeShadowMemory() {\n   if (Verbosity()) PrintAddressSpaceLayout();\n@@ -171,13 +172,13 @@ static void ThreadCreateHook(void *hook, bool aborted) {\n \n // This is called in the newly-created thread before it runs anything else,\n // with the pointer returned by BeforeThreadCreateHook (above).\n-// cf. asan_interceptors.cc:asan_thread_start\n+// cf. asan_interceptors.cpp:asan_thread_start\n static void ThreadStartHook(void *hook, uptr os_id) {\n   AsanThread *thread = static_cast<AsanThread *>(hook);\n   SetCurrentThread(thread);\n \n   // In lieu of AsanThread::ThreadStart.\n-  asanThreadRegistry().StartThread(thread->tid(), os_id, /*workerthread*/ false,\n+  asanThreadRegistry().StartThread(thread->tid(), os_id, ThreadType::Regular,\n                                    nullptr);\n }\n \n@@ -188,6 +189,13 @@ static void ThreadExitHook(void *hook, uptr os_id) {\n   AsanThread::TSDDtor(per_thread);\n }\n \n+bool HandleDlopenInit() {\n+  // Not supported on this platform.\n+  static_assert(!SANITIZER_SUPPORTS_INIT_FOR_DLOPEN,\n+                \"Expected SANITIZER_SUPPORTS_INIT_FOR_DLOPEN to be false\");\n+  return false;\n+}\n+\n }  // namespace __asan\n \n // These are declared (in extern \"C\") by <zircon/sanitizer.h>.", "previous_filename": "libsanitizer/asan/asan_fuchsia.cc"}, {"sha": "54e75f3cee74d0754fa6dc615bd672f22f6a2a35", "filename": "libsanitizer/asan/asan_globals.cpp", "status": "renamed", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_globals.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_globals.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_globals.cc ---------------------------------------------------===//\n+//===-- asan_globals.cpp --------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -81,9 +82,11 @@ static bool IsAddressNearGlobal(uptr addr, const __asan_global &g) {\n }\n \n static void ReportGlobal(const Global &g, const char *prefix) {\n-  Report(\"%s Global[%p]: beg=%p size=%zu/%zu name=%s module=%s dyn_init=%zu\\n\",\n-         prefix, &g, (void *)g.beg, g.size, g.size_with_redzone, g.name,\n-         g.module_name, g.has_dynamic_init);\n+  Report(\n+      \"%s Global[%p]: beg=%p size=%zu/%zu name=%s module=%s dyn_init=%zu \"\n+      \"odr_indicator=%p\\n\",\n+      prefix, &g, (void *)g.beg, g.size, g.size_with_redzone, g.name,\n+      g.module_name, g.has_dynamic_init, (void *)g.odr_indicator);\n   if (g.location) {\n     Report(\"  location (%p): name=%s[%p], %d %d\\n\", g.location,\n            g.location->filename, g.location->filename, g.location->line_no,\n@@ -112,15 +115,12 @@ int GetGlobalsForAddress(uptr addr, Global *globals, u32 *reg_sites,\n     if (flags()->report_globals >= 2)\n       ReportGlobal(g, \"Search\");\n     if (IsAddressNearGlobal(addr, g)) {\n-#if defined(__GNUC__) && defined(__sparc__)\n       internal_memcpy(&globals[res], &g, sizeof(g));\n-#else\n-      globals[res] = g;\n-#endif\n       if (reg_sites)\n         reg_sites[res] = FindRegistrationSite(&g);\n       res++;\n-      if (res == max_globals) break;\n+      if (res == max_globals)\n+        break;\n     }\n   }\n   return res;\n@@ -135,6 +135,9 @@ enum GlobalSymbolState {\n // this method in case compiler instruments global variables through their\n // local aliases.\n static void CheckODRViolationViaIndicator(const Global *g) {\n+  // Instrumentation requests to skip ODR check.\n+  if (g->odr_indicator == UINTPTR_MAX)\n+    return;\n   u8 *odr_indicator = reinterpret_cast<u8 *>(g->odr_indicator);\n   if (*odr_indicator == UNREGISTERED) {\n     *odr_indicator = REGISTERED;\n@@ -151,6 +154,23 @@ static void CheckODRViolationViaIndicator(const Global *g) {\n   }\n }\n \n+// Check ODR violation for given global G by checking if it's already poisoned.\n+// We use this method in case compiler doesn't use private aliases for global\n+// variables.\n+static void CheckODRViolationViaPoisoning(const Global *g) {\n+  if (__asan_region_is_poisoned(g->beg, g->size_with_redzone)) {\n+    // This check may not be enough: if the first global is much larger\n+    // the entire redzone of the second global may be within the first global.\n+    for (ListOfGlobals *l = list_of_all_globals; l; l = l->next) {\n+      if (g->beg == l->g->beg &&\n+          (flags()->detect_odr_violation >= 2 || g->size != l->g->size) &&\n+          !IsODRViolationSuppressed(g->name))\n+        ReportODRViolation(g, FindRegistrationSite(g),\n+                           l->g, FindRegistrationSite(l->g));\n+    }\n+  }\n+}\n+\n // Clang provides two different ways for global variables protection:\n // it can poison the global itself or its private alias. In former\n // case we may poison same symbol multiple times, that can help us to\n@@ -168,9 +188,7 @@ static void CheckODRViolationViaIndicator(const Global *g) {\n // This routine chooses between two different methods of ODR violation\n // detection.\n static inline bool UseODRIndicator(const Global *g) {\n-  // Use ODR indicator method iff use_odr_indicator flag is set and\n-  // indicator symbol address is not 0.\n-  return flags()->use_odr_indicator && g->odr_indicator > 0;\n+  return g->odr_indicator > 0;\n }\n \n // Register a global variable.\n@@ -198,6 +216,8 @@ static void RegisterGlobal(const Global *g) {\n     // where two globals with the same name are defined in different modules.\n     if (UseODRIndicator(g))\n       CheckODRViolationViaIndicator(g);\n+    else\n+      CheckODRViolationViaPoisoning(g);\n   }\n   if (CanPoisonMemory())\n     PoisonRedZones(*g);\n@@ -231,7 +251,7 @@ static void UnregisterGlobal(const Global *g) {\n   // implementation. It might not be worth doing anyway.\n \n   // Release ODR indicator.\n-  if (UseODRIndicator(g)) {\n+  if (UseODRIndicator(g) && g->odr_indicator != UINTPTR_MAX) {\n     u8 *odr_indicator = reinterpret_cast<u8 *>(g->odr_indicator);\n     *odr_indicator = UNREGISTERED;\n   }", "previous_filename": "libsanitizer/asan/asan_globals.cc"}, {"sha": "ff5fe226b53b74e52685cebfa83d1266d83443b4", "filename": "libsanitizer/asan/asan_globals_win.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_globals_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_globals_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals_win.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_globals_win.cc -----------------------------------------------===//\n+//===-- asan_globals_win.cpp ----------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/asan/asan_globals_win.cc"}, {"sha": "b806d794e05613f970ab34d64edc0f965b7c3495", "filename": "libsanitizer/asan/asan_init_version.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_init_version.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_init_version.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_init_version.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- asan_init_version.h -------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "482e44d83b732bdd1d0ca749773ba00fa0f22a61", "filename": "libsanitizer/asan/asan_interceptors.cpp", "status": "renamed", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_interceptors.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_interceptors.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_interceptors.cc ----------------------------------------------===//\n+//===-- asan_interceptors.cpp ---------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -23,7 +24,7 @@\n #include \"sanitizer_common/sanitizer_libc.h\"\n \n // There is no general interception at all on Fuchsia and RTEMS.\n-// Only the functions in asan_interceptors_memintrinsics.cc are\n+// Only the functions in asan_interceptors_memintrinsics.cpp are\n // really defined to replace libc functions.\n #if !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n \n@@ -578,6 +579,11 @@ INTERCEPTOR(int, __cxa_atexit, void (*func)(void *), void *arg,\n }\n #endif  // ASAN_INTERCEPT___CXA_ATEXIT\n \n+#if ASAN_INTERCEPT_VFORK\n+DEFINE_REAL(int, vfork)\n+DECLARE_EXTERN_INTERCEPTOR_AND_WRAPPER(int, vfork)\n+#endif\n+\n // ---------------------- InitializeAsanInterceptors ---------------- {{{1\n namespace __asan {\n void InitializeAsanInterceptors() {\n@@ -655,6 +661,10 @@ void InitializeAsanInterceptors() {\n   ASAN_INTERCEPT_FUNC(__cxa_atexit);\n #endif\n \n+#if ASAN_INTERCEPT_VFORK\n+  ASAN_INTERCEPT_FUNC(vfork);\n+#endif\n+\n   InitializePlatformInterceptors();\n \n   VReport(1, \"AddressSanitizer: libc interceptors initialized\\n\");", "previous_filename": "libsanitizer/asan/asan_interceptors.cc"}, {"sha": "155ea4156abbea594da32fc79ad58d4aa848be61", "filename": "libsanitizer/asan/asan_interceptors.h", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,13 +1,14 @@\n //===-- asan_interceptors.h -------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n // This file is a part of AddressSanitizer, an address sanity checker.\n //\n-// ASan-private header for asan_interceptors.cc\n+// ASan-private header for asan_interceptors.cpp\n //===----------------------------------------------------------------------===//\n #ifndef ASAN_INTERCEPTORS_H\n #define ASAN_INTERCEPTORS_H\n@@ -79,12 +80,7 @@ void InitializePlatformInterceptors();\n #if ASAN_HAS_EXCEPTIONS && !SANITIZER_WINDOWS && !SANITIZER_SOLARIS && \\\n     !SANITIZER_NETBSD\n # define ASAN_INTERCEPT___CXA_THROW 1\n-# if ! defined(ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION) \\\n-     || ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION\n-#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1\n-# else\n-#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 0\n-# endif\n+# define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1\n # if defined(_GLIBCXX_SJLJ_EXCEPTIONS) || (SANITIZER_IOS && defined(__arm__))\n #  define ASAN_INTERCEPT__UNWIND_SJLJ_RAISEEXCEPTION 1\n # else\n@@ -109,6 +105,13 @@ void InitializePlatformInterceptors();\n # define ASAN_INTERCEPT___STRDUP 0\n #endif\n \n+#if SANITIZER_LINUX && (defined(__arm__) || defined(__aarch64__) || \\\n+                        defined(__i386__) || defined(__x86_64__))\n+# define ASAN_INTERCEPT_VFORK 1\n+#else\n+# define ASAN_INTERCEPT_VFORK 0\n+#endif\n+\n DECLARE_REAL(int, memcmp, const void *a1, const void *a2, uptr size)\n DECLARE_REAL(char*, strchr, const char *str, int c)\n DECLARE_REAL(SIZE_T, strlen, const char *s)\n@@ -117,16 +120,16 @@ DECLARE_REAL(uptr, strnlen, const char *s, uptr maxlen)\n DECLARE_REAL(char*, strstr, const char *s1, const char *s2)\n \n #if !SANITIZER_MAC\n-#define ASAN_INTERCEPT_FUNC(name)                                        \\\n-  do {                                                                   \\\n-    if ((!INTERCEPT_FUNCTION(name) || !REAL(name)))                      \\\n-      VReport(1, \"AddressSanitizer: failed to intercept '\" #name \"'\\n\"); \\\n+#define ASAN_INTERCEPT_FUNC(name)                                         \\\n+  do {                                                                    \\\n+    if (!INTERCEPT_FUNCTION(name))                                        \\\n+      VReport(1, \"AddressSanitizer: failed to intercept '%s'\\n'\", #name); \\\n   } while (0)\n-#define ASAN_INTERCEPT_FUNC_VER(name, ver)                                     \\\n-  do {                                                                         \\\n-    if ((!INTERCEPT_FUNCTION_VER(name, ver) || !REAL(name)))                   \\\n-      VReport(                                                                 \\\n-          1, \"AddressSanitizer: failed to intercept '\" #name \"@@\" #ver \"'\\n\"); \\\n+#define ASAN_INTERCEPT_FUNC_VER(name, ver)                                  \\\n+  do {                                                                      \\\n+    if (!INTERCEPT_FUNCTION_VER(name, ver))                                 \\\n+      VReport(1, \"AddressSanitizer: failed to intercept '%s@@%s'\\n\", #name, \\\n+              #ver);                                                        \\\n   } while (0)\n #else\n // OS X interceptors don't need to be initialized with INTERCEPT_FUNCTION."}, {"sha": "56df60ba6818b7e675434e71007780968c0c05e5", "filename": "libsanitizer/asan/asan_interceptors_memintrinsics.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_interceptors_memintrinsics.cc --------------------------------===//\n+//===-- asan_interceptors_memintrinsics.cpp -------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===---------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/asan/asan_interceptors_memintrinsics.cc"}, {"sha": "632f0515a9eb7466cab57a8f48288058894d6eee", "filename": "libsanitizer/asan/asan_interceptors_memintrinsics.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors_memintrinsics.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,13 +1,14 @@\n //===-- asan_interceptors_memintrinsics.h -----------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===---------------------------------------------------------------------===//\n //\n // This file is a part of AddressSanitizer, an address sanity checker.\n //\n-// ASan-private header for asan_memintrin.cc\n+// ASan-private header for asan_interceptors_memintrinsics.cpp\n //===---------------------------------------------------------------------===//\n #ifndef ASAN_MEMINTRIN_H\n #define ASAN_MEMINTRIN_H"}, {"sha": "90a169d4b609e395f4374401ab035a08350c89d7", "filename": "libsanitizer/asan/asan_interceptors_vfork.S", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_interceptors_vfork.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_interceptors_vfork.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors_vfork.S?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -0,0 +1,12 @@\n+#include \"sanitizer_common/sanitizer_asm.h\"\n+\n+#if defined(__linux__)\n+#define COMMON_INTERCEPTOR_SPILL_AREA __asan_extra_spill_area\n+#define COMMON_INTERCEPTOR_HANDLE_VFORK __asan_handle_vfork\n+#include \"sanitizer_common/sanitizer_common_interceptors_vfork_aarch64.inc.S\"\n+#include \"sanitizer_common/sanitizer_common_interceptors_vfork_arm.inc.S\"\n+#include \"sanitizer_common/sanitizer_common_interceptors_vfork_x86_64.inc.S\"\n+#include \"sanitizer_common/sanitizer_common_interceptors_vfork_i386.inc.S\"\n+#endif\n+\n+NO_EXEC_STACK_DIRECTIVE"}, {"sha": "7c341f22e15f4b37e03ea8c118ddfcfe06d6040a", "filename": "libsanitizer/asan/asan_interface.inc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_interface.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_interface.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interface.inc?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- asan_interface.inc ------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n // Asan interface list.\n@@ -37,6 +38,7 @@ INTERFACE_FUNCTION(__asan_get_report_pc)\n INTERFACE_FUNCTION(__asan_get_report_sp)\n INTERFACE_FUNCTION(__asan_get_shadow_mapping)\n INTERFACE_FUNCTION(__asan_handle_no_return)\n+INTERFACE_FUNCTION(__asan_handle_vfork)\n INTERFACE_FUNCTION(__asan_init)\n INTERFACE_FUNCTION(__asan_load_cxx_array_cookie)\n INTERFACE_FUNCTION(__asan_load1)"}, {"sha": "c83aa11d741a17126577d3966a2322bd2d8c7f16", "filename": "libsanitizer/asan/asan_interface_internal.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interface_internal.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- asan_interface_internal.h -------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -248,6 +249,8 @@ extern \"C\" {\n \n   SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n   const char* __asan_default_suppressions();\n+\n+  SANITIZER_INTERFACE_ATTRIBUTE void __asan_handle_vfork(void *sp);\n }  // extern \"C\"\n \n #endif  // ASAN_INTERFACE_INTERNAL_H"}, {"sha": "72a4c3f22ff1c22ec7f3be6341bc4a68081955ce", "filename": "libsanitizer/asan/asan_internal.h", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_internal.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- asan_internal.h -----------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -60,29 +61,29 @@ using __sanitizer::StackTrace;\n \n void AsanInitFromRtl();\n \n-// asan_win.cc\n+// asan_win.cpp\n void InitializePlatformExceptionHandlers();\n // Returns whether an address is a valid allocated system heap block.\n // 'addr' must point to the beginning of the block.\n bool IsSystemHeapAddress(uptr addr);\n \n-// asan_rtl.cc\n+// asan_rtl.cpp\n void PrintAddressSpaceLayout();\n void NORETURN ShowStatsAndAbort();\n \n-// asan_shadow_setup.cc\n+// asan_shadow_setup.cpp\n void InitializeShadowMemory();\n \n-// asan_malloc_linux.cc / asan_malloc_mac.cc\n+// asan_malloc_linux.cpp / asan_malloc_mac.cpp\n void ReplaceSystemMalloc();\n \n-// asan_linux.cc / asan_mac.cc / asan_rtems.cc / asan_win.cc\n+// asan_linux.cpp / asan_mac.cpp / asan_rtems.cpp / asan_win.cpp\n uptr FindDynamicShadowStart();\n void *AsanDoesNotSupportStaticLinkage();\n void AsanCheckDynamicRTPrereqs();\n void AsanCheckIncompatibleRT();\n \n-// asan_thread.cc\n+// asan_thread.cpp\n AsanThread *CreateMainThread();\n \n // Support function for __asan_(un)register_image_globals. Searches for the\n@@ -109,6 +110,11 @@ void *AsanDlSymNext(const char *sym);\n \n void ReserveShadowMemoryRange(uptr beg, uptr end, const char *name);\n \n+// Returns `true` iff most of ASan init process should be skipped due to the\n+// ASan library being loaded via `dlopen()`. Platforms may perform any\n+// `dlopen()` specific initialization inside this function.\n+bool HandleDlopenInit();\n+\n // Add convenient macro for interface functions that may be represented as\n // weak hooks.\n #define ASAN_MALLOC_HOOK(ptr, size)                                   \\"}, {"sha": "ce5e873dc51803cda6c1ece2e0e157f5643457f9", "filename": "libsanitizer/asan/asan_linux.cpp", "status": "renamed", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_linux.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_linux.cc -----------------------------------------------------===//\n+//===-- asan_linux.cpp ----------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -246,6 +247,13 @@ void *AsanDlSymNext(const char *sym) {\n   return dlsym(RTLD_NEXT, sym);\n }\n \n+bool HandleDlopenInit() {\n+  // Not supported on this platform.\n+  static_assert(!SANITIZER_SUPPORTS_INIT_FOR_DLOPEN,\n+                \"Expected SANITIZER_SUPPORTS_INIT_FOR_DLOPEN to be false\");\n+  return false;\n+}\n+\n } // namespace __asan\n \n #endif  // SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_NETBSD ||", "previous_filename": "libsanitizer/asan/asan_linux.cc"}, {"sha": "769d499672d69e7700e1c6afcc65f702414114e2", "filename": "libsanitizer/asan/asan_mac.cpp", "status": "renamed", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_mac.cc -------------------------------------------------------===//\n+//===-- asan_mac.cpp ------------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -180,8 +181,8 @@ void asan_register_worker_thread(int parent_tid, StackTrace *stack) {\n     t = AsanThread::Create(/* start_routine */ nullptr, /* arg */ nullptr,\n                            parent_tid, stack, /* detached */ true);\n     t->Init();\n-    asanThreadRegistry().StartThread(t->tid(), GetTid(),\n-                                     /* workerthread */ true, 0);\n+    asanThreadRegistry().StartThread(t->tid(), GetTid(), ThreadType::Worker,\n+                                     nullptr);\n     SetCurrentThread(t);\n   }\n }", "previous_filename": "libsanitizer/asan/asan_mac.cc"}, {"sha": "706bc39f0c47be44a4cc13c8aabe31ea16689d0c", "filename": "libsanitizer/asan/asan_malloc_linux.cpp", "status": "renamed", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_malloc_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_malloc_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_linux.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_malloc_linux.cc ----------------------------------------------===//\n+//===-- asan_malloc_linux.cpp ---------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -164,6 +165,14 @@ INTERCEPTOR(void*, realloc, void *ptr, uptr size) {\n   return asan_realloc(ptr, size, &stack);\n }\n \n+#if SANITIZER_INTERCEPT_REALLOCARRAY\n+INTERCEPTOR(void*, reallocarray, void *ptr, uptr nmemb, uptr size) {\n+  ENSURE_ASAN_INITED();\n+  GET_STACK_TRACE_MALLOC;\n+  return asan_reallocarray(ptr, nmemb, size, &stack);\n+}\n+#endif  // SANITIZER_INTERCEPT_REALLOCARRAY\n+\n #if SANITIZER_INTERCEPT_MEMALIGN\n INTERCEPTOR(void*, memalign, uptr boundary, uptr size) {\n   GET_STACK_TRACE_MALLOC;\n@@ -207,7 +216,7 @@ INTERCEPTOR(struct fake_mallinfo, mallinfo, void) {\n }\n \n INTERCEPTOR(int, mallopt, int cmd, int value) {\n-  return -1;\n+  return 0;\n }\n #endif // SANITIZER_INTERCEPT_MALLOPT_AND_MALLINFO\n ", "previous_filename": "libsanitizer/asan/asan_malloc_linux.cc"}, {"sha": "3f784b90c739c1ce6894cdea6acc523d9fd36852", "filename": "libsanitizer/asan/asan_malloc_local.h", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_malloc_local.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_malloc_local.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_local.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- asan_malloc_local.h -------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -16,25 +17,34 @@\n #include \"sanitizer_common/sanitizer_platform.h\"\n #include \"asan_internal.h\"\n \n-// On RTEMS, we use the local pool to handle memory allocation when the ASan\n-// run-time is not up.\n static INLINE bool EarlyMalloc() {\n-  return SANITIZER_RTEMS && (!__asan::asan_inited ||\n-                             __asan::asan_init_is_running);\n+  return SANITIZER_RTEMS &&\n+         (!__asan::asan_inited || __asan::asan_init_is_running);\n }\n \n-void* MemalignFromLocalPool(uptr alignment, uptr size);\n-\n #if SANITIZER_RTEMS\n \n bool IsFromLocalPool(const void *ptr);\n+void *MemalignFromLocalPool(uptr alignment, uptr size);\n+\n+// On RTEMS, we use the local pool to handle memory allocation when the ASan\n+// run-time is not up. This macro is expanded in the context of the operator new\n+// implementation.\n+#define MAYBE_ALLOCATE_FROM_LOCAL_POOL(nothrow)                    \\\n+  do {                                                             \\\n+    if (UNLIKELY(EarlyMalloc())) {                                 \\\n+      void *res = MemalignFromLocalPool(SHADOW_GRANULARITY, size); \\\n+      if (!nothrow)                                                \\\n+        CHECK(res);                                                \\\n+      return res;                                                  \\\n+    }                                                              \\\n+  } while (0)\n \n-#define ALLOCATE_FROM_LOCAL_POOL UNLIKELY(EarlyMalloc())\n #define IS_FROM_LOCAL_POOL(ptr) UNLIKELY(IsFromLocalPool(ptr))\n \n #else  // SANITIZER_RTEMS\n \n-#define ALLOCATE_FROM_LOCAL_POOL 0\n+#define MAYBE_ALLOCATE_FROM_LOCAL_POOL(nothrow)\n #define IS_FROM_LOCAL_POOL(ptr) 0\n \n #endif  // SANITIZER_RTEMS"}, {"sha": "e8484685daed43d0aebb34c1de4542b900232fc1", "filename": "libsanitizer/asan/asan_malloc_mac.cpp", "status": "renamed", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_malloc_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_malloc_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_mac.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_malloc_mac.cc ------------------------------------------------===//\n+//===-- asan_malloc_mac.cpp -----------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -17,6 +18,7 @@\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n #include \"asan_stats.h\"\n+#include \"lsan/lsan_common.h\"\n \n using namespace __asan;\n #define COMMON_MALLOC_ZONE_NAME \"asan\"\n@@ -56,7 +58,45 @@ using namespace __asan;\n   GET_STACK_TRACE_FREE; \\\n   ReportMacMzReallocUnknown((uptr)ptr, (uptr)zone_ptr, zone_name, &stack);\n #define COMMON_MALLOC_NAMESPACE __asan\n+#define COMMON_MALLOC_HAS_ZONE_ENUMERATOR 0\n+#define COMMON_MALLOC_HAS_EXTRA_INTROSPECTION_INIT 1\n \n #include \"sanitizer_common/sanitizer_malloc_mac.inc\"\n \n+namespace COMMON_MALLOC_NAMESPACE {\n+\n+bool HandleDlopenInit() {\n+  static_assert(SANITIZER_SUPPORTS_INIT_FOR_DLOPEN,\n+                \"Expected SANITIZER_SUPPORTS_INIT_FOR_DLOPEN to be true\");\n+  // We have no reliable way of knowing how we are being loaded\n+  // so make it a requirement on Apple platforms to set this environment\n+  // variable to indicate that we want to perform initialization via\n+  // dlopen().\n+  auto init_str = GetEnv(\"APPLE_ASAN_INIT_FOR_DLOPEN\");\n+  if (!init_str)\n+    return false;\n+  if (internal_strncmp(init_str, \"1\", 1) != 0)\n+    return false;\n+  // When we are loaded via `dlopen()` path we still initialize the malloc zone\n+  // so Symbolication clients (e.g. `leaks`) that load the ASan allocator can\n+  // find an initialized malloc zone.\n+  InitMallocZoneFields();\n+  return true;\n+}\n+}  // namespace COMMON_MALLOC_NAMESPACE\n+\n+namespace {\n+\n+void mi_extra_init(sanitizer_malloc_introspection_t *mi) {\n+  uptr last_byte_plus_one = 0;\n+  mi->allocator_ptr = 0;\n+  // Range is [begin_ptr, end_ptr)\n+  __lsan::GetAllocatorGlobalRange(&(mi->allocator_ptr), &last_byte_plus_one);\n+  CHECK_NE(mi->allocator_ptr, 0);\n+  CHECK_GT(last_byte_plus_one, mi->allocator_ptr);\n+  mi->allocator_size = last_byte_plus_one - (mi->allocator_ptr);\n+  CHECK_GT(mi->allocator_size, 0);\n+}\n+}  // namespace\n+\n #endif", "previous_filename": "libsanitizer/asan/asan_malloc_mac.cc"}, {"sha": "245186037921d0e5ebd37ed3e2533dfb04ddea79", "filename": "libsanitizer/asan/asan_malloc_win.cc", "status": "removed", "additions": 0, "deletions": 259, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/063082768aab23d26e42954eb115b76318f0176d/libsanitizer%2Fasan%2Fasan_malloc_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/063082768aab23d26e42954eb115b76318f0176d/libsanitizer%2Fasan%2Fasan_malloc_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_win.cc?ref=063082768aab23d26e42954eb115b76318f0176d", "patch": "@@ -1,259 +0,0 @@\n-//===-- asan_malloc_win.cc ------------------------------------------------===//\n-//\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file is a part of AddressSanitizer, an address sanity checker.\n-//\n-// Windows-specific malloc interception.\n-//===----------------------------------------------------------------------===//\n-\n-#include \"sanitizer_common/sanitizer_platform.h\"\n-#if SANITIZER_WINDOWS\n-// Intentionally not including windows.h here, to avoid the risk of\n-// pulling in conflicting declarations of these functions. (With mingw-w64,\n-// there's a risk of windows.h pulling in stdint.h.)\n-typedef int BOOL;\n-typedef void *HANDLE;\n-typedef const void *LPCVOID;\n-typedef void *LPVOID;\n-\n-#define HEAP_ZERO_MEMORY           0x00000008\n-#define HEAP_REALLOC_IN_PLACE_ONLY 0x00000010\n-\n-\n-#include \"asan_allocator.h\"\n-#include \"asan_interceptors.h\"\n-#include \"asan_internal.h\"\n-#include \"asan_stack.h\"\n-#include \"interception/interception.h\"\n-\n-#include <stddef.h>\n-\n-using namespace __asan;  // NOLINT\n-\n-// MT: Simply defining functions with the same signature in *.obj\n-// files overrides the standard functions in the CRT.\n-// MD: Memory allocation functions are defined in the CRT .dll,\n-// so we have to intercept them before they are called for the first time.\n-\n-#if ASAN_DYNAMIC\n-# define ALLOCATION_FUNCTION_ATTRIBUTE\n-#else\n-# define ALLOCATION_FUNCTION_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n-#endif\n-\n-extern \"C\" {\n-ALLOCATION_FUNCTION_ATTRIBUTE\n-void free(void *ptr) {\n-  GET_STACK_TRACE_FREE;\n-  return asan_free(ptr, &stack, FROM_MALLOC);\n-}\n-\n-ALLOCATION_FUNCTION_ATTRIBUTE\n-void _free_dbg(void *ptr, int) {\n-  free(ptr);\n-}\n-\n-ALLOCATION_FUNCTION_ATTRIBUTE\n-void _free_base(void *ptr) {\n-  free(ptr);\n-}\n-\n-ALLOCATION_FUNCTION_ATTRIBUTE\n-void *malloc(size_t size) {\n-  GET_STACK_TRACE_MALLOC;\n-  return asan_malloc(size, &stack);\n-}\n-\n-ALLOCATION_FUNCTION_ATTRIBUTE\n-void *_malloc_base(size_t size) {\n-  return malloc(size);\n-}\n-\n-ALLOCATION_FUNCTION_ATTRIBUTE\n-void *_malloc_dbg(size_t size, int, const char *, int) {\n-  return malloc(size);\n-}\n-\n-ALLOCATION_FUNCTION_ATTRIBUTE\n-void *calloc(size_t nmemb, size_t size) {\n-  GET_STACK_TRACE_MALLOC;\n-  return asan_calloc(nmemb, size, &stack);\n-}\n-\n-ALLOCATION_FUNCTION_ATTRIBUTE\n-void *_calloc_base(size_t nmemb, size_t size) {\n-  return calloc(nmemb, size);\n-}\n-\n-ALLOCATION_FUNCTION_ATTRIBUTE\n-void *_calloc_dbg(size_t nmemb, size_t size, int, const char *, int) {\n-  return calloc(nmemb, size);\n-}\n-\n-ALLOCATION_FUNCTION_ATTRIBUTE\n-void *_calloc_impl(size_t nmemb, size_t size, int *errno_tmp) {\n-  return calloc(nmemb, size);\n-}\n-\n-ALLOCATION_FUNCTION_ATTRIBUTE\n-void *realloc(void *ptr, size_t size) {\n-  GET_STACK_TRACE_MALLOC;\n-  return asan_realloc(ptr, size, &stack);\n-}\n-\n-ALLOCATION_FUNCTION_ATTRIBUTE\n-void *_realloc_dbg(void *ptr, size_t size, int) {\n-  UNREACHABLE(\"_realloc_dbg should not exist!\");\n-  return 0;\n-}\n-\n-ALLOCATION_FUNCTION_ATTRIBUTE\n-void *_realloc_base(void *ptr, size_t size) {\n-  return realloc(ptr, size);\n-}\n-\n-ALLOCATION_FUNCTION_ATTRIBUTE\n-void *_recalloc(void *p, size_t n, size_t elem_size) {\n-  if (!p)\n-    return calloc(n, elem_size);\n-  const size_t size = n * elem_size;\n-  if (elem_size != 0 && size / elem_size != n)\n-    return 0;\n-  return realloc(p, size);\n-}\n-\n-ALLOCATION_FUNCTION_ATTRIBUTE\n-void *_recalloc_base(void *p, size_t n, size_t elem_size) {\n-  return _recalloc(p, n, elem_size);\n-}\n-\n-ALLOCATION_FUNCTION_ATTRIBUTE\n-size_t _msize(void *ptr) {\n-  GET_CURRENT_PC_BP_SP;\n-  (void)sp;\n-  return asan_malloc_usable_size(ptr, pc, bp);\n-}\n-\n-ALLOCATION_FUNCTION_ATTRIBUTE\n-void *_expand(void *memblock, size_t size) {\n-  // _expand is used in realloc-like functions to resize the buffer if possible.\n-  // We don't want memory to stand still while resizing buffers, so return 0.\n-  return 0;\n-}\n-\n-ALLOCATION_FUNCTION_ATTRIBUTE\n-void *_expand_dbg(void *memblock, size_t size) {\n-  return _expand(memblock, size);\n-}\n-\n-// TODO(timurrrr): Might want to add support for _aligned_* allocation\n-// functions to detect a bit more bugs.  Those functions seem to wrap malloc().\n-\n-int _CrtDbgReport(int, const char*, int,\n-                  const char*, const char*, ...) {\n-  ShowStatsAndAbort();\n-}\n-\n-int _CrtDbgReportW(int reportType, const wchar_t*, int,\n-                   const wchar_t*, const wchar_t*, ...) {\n-  ShowStatsAndAbort();\n-}\n-\n-int _CrtSetReportMode(int, int) {\n-  return 0;\n-}\n-}  // extern \"C\"\n-\n-INTERCEPTOR_WINAPI(LPVOID, HeapAlloc, HANDLE hHeap, DWORD dwFlags,\n-                   SIZE_T dwBytes) {\n-  GET_STACK_TRACE_MALLOC;\n-  void *p = asan_malloc(dwBytes, &stack);\n-  // Reading MSDN suggests that the *entire* usable allocation is zeroed out.\n-  // Otherwise it is difficult to HeapReAlloc with HEAP_ZERO_MEMORY.\n-  // https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083\n-  if (dwFlags == HEAP_ZERO_MEMORY)\n-    internal_memset(p, 0, asan_mz_size(p));\n-  else\n-    CHECK(dwFlags == 0 && \"unsupported heap flags\");\n-  return p;\n-}\n-\n-INTERCEPTOR_WINAPI(BOOL, HeapFree, HANDLE hHeap, DWORD dwFlags, LPVOID lpMem) {\n-  CHECK(dwFlags == 0 && \"unsupported heap flags\");\n-  GET_STACK_TRACE_FREE;\n-  asan_free(lpMem, &stack, FROM_MALLOC);\n-  return true;\n-}\n-\n-INTERCEPTOR_WINAPI(LPVOID, HeapReAlloc, HANDLE hHeap, DWORD dwFlags,\n-                   LPVOID lpMem, SIZE_T dwBytes) {\n-  GET_STACK_TRACE_MALLOC;\n-  // Realloc should never reallocate in place.\n-  if (dwFlags & HEAP_REALLOC_IN_PLACE_ONLY)\n-    return nullptr;\n-  CHECK(dwFlags == 0 && \"unsupported heap flags\");\n-  return asan_realloc(lpMem, dwBytes, &stack);\n-}\n-\n-INTERCEPTOR_WINAPI(SIZE_T, HeapSize, HANDLE hHeap, DWORD dwFlags,\n-                   LPCVOID lpMem) {\n-  CHECK(dwFlags == 0 && \"unsupported heap flags\");\n-  GET_CURRENT_PC_BP_SP;\n-  (void)sp;\n-  return asan_malloc_usable_size(lpMem, pc, bp);\n-}\n-\n-namespace __asan {\n-\n-static void TryToOverrideFunction(const char *fname, uptr new_func) {\n-  // Failure here is not fatal. The CRT may not be present, and different CRT\n-  // versions use different symbols.\n-  if (!__interception::OverrideFunction(fname, new_func))\n-    VPrintf(2, \"Failed to override function %s\\n\", fname);\n-}\n-\n-void ReplaceSystemMalloc() {\n-#if defined(ASAN_DYNAMIC)\n-  TryToOverrideFunction(\"free\", (uptr)free);\n-  TryToOverrideFunction(\"_free_base\", (uptr)free);\n-  TryToOverrideFunction(\"malloc\", (uptr)malloc);\n-  TryToOverrideFunction(\"_malloc_base\", (uptr)malloc);\n-  TryToOverrideFunction(\"_malloc_crt\", (uptr)malloc);\n-  TryToOverrideFunction(\"calloc\", (uptr)calloc);\n-  TryToOverrideFunction(\"_calloc_base\", (uptr)calloc);\n-  TryToOverrideFunction(\"_calloc_crt\", (uptr)calloc);\n-  TryToOverrideFunction(\"realloc\", (uptr)realloc);\n-  TryToOverrideFunction(\"_realloc_base\", (uptr)realloc);\n-  TryToOverrideFunction(\"_realloc_crt\", (uptr)realloc);\n-  TryToOverrideFunction(\"_recalloc\", (uptr)_recalloc);\n-  TryToOverrideFunction(\"_recalloc_base\", (uptr)_recalloc);\n-  TryToOverrideFunction(\"_recalloc_crt\", (uptr)_recalloc);\n-  TryToOverrideFunction(\"_msize\", (uptr)_msize);\n-  TryToOverrideFunction(\"_expand\", (uptr)_expand);\n-  TryToOverrideFunction(\"_expand_base\", (uptr)_expand);\n-\n-  // Recent versions of ucrtbase.dll appear to be built with PGO and LTCG, which\n-  // enable cross-module inlining. This means our _malloc_base hook won't catch\n-  // all CRT allocations. This code here patches the import table of\n-  // ucrtbase.dll so that all attempts to use the lower-level win32 heap\n-  // allocation API will be directed to ASan's heap. We don't currently\n-  // intercept all calls to HeapAlloc. If we did, we would have to check on\n-  // HeapFree whether the pointer came from ASan of from the system.\n-#define INTERCEPT_UCRT_FUNCTION(func)                                         \\\n-  if (!INTERCEPT_FUNCTION_DLLIMPORT(\"ucrtbase.dll\",                           \\\n-                                    \"api-ms-win-core-heap-l1-1-0.dll\", func)) \\\n-    VPrintf(2, \"Failed to intercept ucrtbase.dll import %s\\n\", #func);\n-  INTERCEPT_UCRT_FUNCTION(HeapAlloc);\n-  INTERCEPT_UCRT_FUNCTION(HeapFree);\n-  INTERCEPT_UCRT_FUNCTION(HeapReAlloc);\n-  INTERCEPT_UCRT_FUNCTION(HeapSize);\n-#undef INTERCEPT_UCRT_FUNCTION\n-#endif\n-}\n-}  // namespace __asan\n-\n-#endif  // _WIN32"}, {"sha": "291d411ea7910c19d2fd99862cdeb83e27d97943", "filename": "libsanitizer/asan/asan_malloc_win.cpp", "status": "added", "additions": 553, "deletions": 0, "changes": 553, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_malloc_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_malloc_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_win.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -0,0 +1,553 @@\n+//===-- asan_malloc_win.cpp -----------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Windows-specific malloc interception.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_allocator_interface.h\"\n+#include \"sanitizer_common/sanitizer_platform.h\"\n+#if SANITIZER_WINDOWS\n+#include \"asan_allocator.h\"\n+#include \"asan_interceptors.h\"\n+#include \"asan_internal.h\"\n+#include \"asan_stack.h\"\n+#include \"interception/interception.h\"\n+#include <stddef.h>\n+\n+// Intentionally not including windows.h here, to avoid the risk of\n+// pulling in conflicting declarations of these functions. (With mingw-w64,\n+// there's a risk of windows.h pulling in stdint.h.)\n+typedef int BOOL;\n+typedef void *HANDLE;\n+typedef const void *LPCVOID;\n+typedef void *LPVOID;\n+\n+typedef unsigned long DWORD;\n+constexpr unsigned long HEAP_ZERO_MEMORY = 0x00000008;\n+constexpr unsigned long HEAP_REALLOC_IN_PLACE_ONLY = 0x00000010;\n+constexpr unsigned long HEAP_ALLOCATE_SUPPORTED_FLAGS = (HEAP_ZERO_MEMORY);\n+constexpr unsigned long HEAP_ALLOCATE_UNSUPPORTED_FLAGS =\n+    (~HEAP_ALLOCATE_SUPPORTED_FLAGS);\n+constexpr unsigned long HEAP_FREE_SUPPORTED_FLAGS = (0);\n+constexpr unsigned long HEAP_FREE_UNSUPPORTED_FLAGS =\n+    (~HEAP_ALLOCATE_SUPPORTED_FLAGS);\n+constexpr unsigned long HEAP_REALLOC_SUPPORTED_FLAGS =\n+    (HEAP_REALLOC_IN_PLACE_ONLY | HEAP_ZERO_MEMORY);\n+constexpr unsigned long HEAP_REALLOC_UNSUPPORTED_FLAGS =\n+    (~HEAP_ALLOCATE_SUPPORTED_FLAGS);\n+\n+\n+extern \"C\" {\n+LPVOID WINAPI HeapAlloc(HANDLE hHeap, DWORD dwFlags, size_t dwBytes);\n+LPVOID WINAPI HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem,\n+                         size_t dwBytes);\n+BOOL WINAPI HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);\n+size_t WINAPI HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);\n+\n+BOOL WINAPI HeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);\n+}\n+\n+using namespace __asan;  // NOLINT\n+\n+// MT: Simply defining functions with the same signature in *.obj\n+// files overrides the standard functions in the CRT.\n+// MD: Memory allocation functions are defined in the CRT .dll,\n+// so we have to intercept them before they are called for the first time.\n+\n+#if ASAN_DYNAMIC\n+# define ALLOCATION_FUNCTION_ATTRIBUTE\n+#else\n+# define ALLOCATION_FUNCTION_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+#endif\n+\n+extern \"C\" {\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+size_t _msize(void *ptr) {\n+  GET_CURRENT_PC_BP_SP;\n+  (void)sp;\n+  return asan_malloc_usable_size(ptr, pc, bp);\n+}\n+\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+size_t _msize_base(void *ptr) {\n+  return _msize(ptr);\n+}\n+\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void free(void *ptr) {\n+  GET_STACK_TRACE_FREE;\n+  return asan_free(ptr, &stack, FROM_MALLOC);\n+}\n+\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void _free_dbg(void *ptr, int) {\n+  free(ptr);\n+}\n+\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void _free_base(void *ptr) {\n+  free(ptr);\n+}\n+\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void *malloc(size_t size) {\n+  GET_STACK_TRACE_MALLOC;\n+  return asan_malloc(size, &stack);\n+}\n+\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void *_malloc_base(size_t size) {\n+  return malloc(size);\n+}\n+\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void *_malloc_dbg(size_t size, int, const char *, int) {\n+  return malloc(size);\n+}\n+\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void *calloc(size_t nmemb, size_t size) {\n+  GET_STACK_TRACE_MALLOC;\n+  return asan_calloc(nmemb, size, &stack);\n+}\n+\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void *_calloc_base(size_t nmemb, size_t size) {\n+  return calloc(nmemb, size);\n+}\n+\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void *_calloc_dbg(size_t nmemb, size_t size, int, const char *, int) {\n+  return calloc(nmemb, size);\n+}\n+\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void *_calloc_impl(size_t nmemb, size_t size, int *errno_tmp) {\n+  return calloc(nmemb, size);\n+}\n+\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void *realloc(void *ptr, size_t size) {\n+  GET_STACK_TRACE_MALLOC;\n+  return asan_realloc(ptr, size, &stack);\n+}\n+\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void *_realloc_dbg(void *ptr, size_t size, int) {\n+  UNREACHABLE(\"_realloc_dbg should not exist!\");\n+  return 0;\n+}\n+\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void *_realloc_base(void *ptr, size_t size) {\n+  return realloc(ptr, size);\n+}\n+\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void *_recalloc(void *p, size_t n, size_t elem_size) {\n+  if (!p)\n+    return calloc(n, elem_size);\n+  const size_t size = n * elem_size;\n+  if (elem_size != 0 && size / elem_size != n)\n+    return 0;\n+\n+  size_t old_size = _msize(p);\n+  void *new_alloc = malloc(size);\n+  if (new_alloc) {\n+    REAL(memcpy)(new_alloc, p, Min<size_t>(size, old_size));\n+    if (old_size < size)\n+      REAL(memset)(((u8 *)new_alloc) + old_size, 0, size - old_size);\n+    free(p);\n+  }\n+  return new_alloc;\n+}\n+\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void *_recalloc_base(void *p, size_t n, size_t elem_size) {\n+  return _recalloc(p, n, elem_size);\n+}\n+\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void *_expand(void *memblock, size_t size) {\n+  // _expand is used in realloc-like functions to resize the buffer if possible.\n+  // We don't want memory to stand still while resizing buffers, so return 0.\n+  return 0;\n+}\n+\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void *_expand_dbg(void *memblock, size_t size) {\n+  return _expand(memblock, size);\n+}\n+\n+// TODO(timurrrr): Might want to add support for _aligned_* allocation\n+// functions to detect a bit more bugs.  Those functions seem to wrap malloc().\n+\n+int _CrtDbgReport(int, const char*, int,\n+                  const char*, const char*, ...) {\n+  ShowStatsAndAbort();\n+}\n+\n+int _CrtDbgReportW(int reportType, const wchar_t*, int,\n+                   const wchar_t*, const wchar_t*, ...) {\n+  ShowStatsAndAbort();\n+}\n+\n+int _CrtSetReportMode(int, int) {\n+  return 0;\n+}\n+}  // extern \"C\"\n+\n+#define OWNED_BY_RTL(heap, memory) \\\n+  (!__sanitizer_get_ownership(memory) && HeapValidate(heap, 0, memory))\n+\n+INTERCEPTOR_WINAPI(size_t, HeapSize, HANDLE hHeap, DWORD dwFlags,\n+                   LPCVOID lpMem) {\n+  // If the RTL allocators are hooked we need to check whether the ASAN\n+  // allocator owns the pointer we're about to use. Allocations occur before\n+  // interception takes place, so if it is not owned by the RTL heap we can\n+  // pass it to the ASAN heap for inspection.\n+  if (flags()->windows_hook_rtl_allocators) {\n+    if (!asan_inited || OWNED_BY_RTL(hHeap, lpMem))\n+      return REAL(HeapSize)(hHeap, dwFlags, lpMem);\n+  } else {\n+    CHECK(dwFlags == 0 && \"unsupported heap flags\");\n+  }\n+  GET_CURRENT_PC_BP_SP;\n+  (void)sp;\n+  return asan_malloc_usable_size(lpMem, pc, bp);\n+}\n+\n+INTERCEPTOR_WINAPI(LPVOID, HeapAlloc, HANDLE hHeap, DWORD dwFlags,\n+                   size_t dwBytes) {\n+  // If the ASAN runtime is not initialized, or we encounter an unsupported\n+  // flag, fall back to the original allocator.\n+  if (flags()->windows_hook_rtl_allocators) {\n+    if (UNLIKELY(!asan_inited ||\n+                 (dwFlags & HEAP_ALLOCATE_UNSUPPORTED_FLAGS) != 0)) {\n+      return REAL(HeapAlloc)(hHeap, dwFlags, dwBytes);\n+    }\n+  } else {\n+    // In the case that we don't hook the rtl allocators,\n+    // this becomes an assert since there is no failover to the original\n+    // allocator.\n+    CHECK((HEAP_ALLOCATE_UNSUPPORTED_FLAGS & dwFlags) != 0 &&\n+          \"unsupported flags\");\n+  }\n+  GET_STACK_TRACE_MALLOC;\n+  void *p = asan_malloc(dwBytes, &stack);\n+  // Reading MSDN suggests that the *entire* usable allocation is zeroed out.\n+  // Otherwise it is difficult to HeapReAlloc with HEAP_ZERO_MEMORY.\n+  // https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083\n+  if (p && (dwFlags & HEAP_ZERO_MEMORY)) {\n+    GET_CURRENT_PC_BP_SP;\n+    (void)sp;\n+    auto usable_size = asan_malloc_usable_size(p, pc, bp);\n+    internal_memset(p, 0, usable_size);\n+  }\n+  return p;\n+}\n+\n+INTERCEPTOR_WINAPI(BOOL, HeapFree, HANDLE hHeap, DWORD dwFlags, LPVOID lpMem) {\n+  // Heap allocations happen before this function is hooked, so we must fall\n+  // back to the original function if the pointer is not from the ASAN heap,\n+  // or unsupported flags are provided.\n+  if (flags()->windows_hook_rtl_allocators) {\n+    if (OWNED_BY_RTL(hHeap, lpMem))\n+      return REAL(HeapFree)(hHeap, dwFlags, lpMem);\n+  } else {\n+    CHECK((HEAP_FREE_UNSUPPORTED_FLAGS & dwFlags) != 0 && \"unsupported flags\");\n+  }\n+  GET_STACK_TRACE_FREE;\n+  asan_free(lpMem, &stack, FROM_MALLOC);\n+  return true;\n+}\n+\n+namespace __asan {\n+using AllocFunction = LPVOID(WINAPI *)(HANDLE, DWORD, size_t);\n+using ReAllocFunction = LPVOID(WINAPI *)(HANDLE, DWORD, LPVOID, size_t);\n+using SizeFunction = size_t(WINAPI *)(HANDLE, DWORD, LPVOID);\n+using FreeFunction = BOOL(WINAPI *)(HANDLE, DWORD, LPVOID);\n+\n+void *SharedReAlloc(ReAllocFunction reallocFunc, SizeFunction heapSizeFunc,\n+                    FreeFunction freeFunc, AllocFunction allocFunc,\n+                    HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, size_t dwBytes) {\n+  CHECK(reallocFunc && heapSizeFunc && freeFunc && allocFunc);\n+  GET_STACK_TRACE_MALLOC;\n+  GET_CURRENT_PC_BP_SP;\n+  (void)sp;\n+  if (flags()->windows_hook_rtl_allocators) {\n+    enum AllocationOwnership { NEITHER = 0, ASAN = 1, RTL = 2 };\n+    AllocationOwnership ownershipState;\n+    bool owned_rtlalloc = false;\n+    bool owned_asan = __sanitizer_get_ownership(lpMem);\n+\n+    if (!owned_asan)\n+      owned_rtlalloc = HeapValidate(hHeap, 0, lpMem);\n+\n+    if (owned_asan && !owned_rtlalloc)\n+      ownershipState = ASAN;\n+    else if (!owned_asan && owned_rtlalloc)\n+      ownershipState = RTL;\n+    else if (!owned_asan && !owned_rtlalloc)\n+      ownershipState = NEITHER;\n+\n+    // If this heap block which was allocated before the ASAN\n+    // runtime came up, use the real HeapFree function.\n+    if (UNLIKELY(!asan_inited)) {\n+      return reallocFunc(hHeap, dwFlags, lpMem, dwBytes);\n+    }\n+    bool only_asan_supported_flags =\n+        (HEAP_REALLOC_UNSUPPORTED_FLAGS & dwFlags) == 0;\n+\n+    if (ownershipState == RTL ||\n+        (ownershipState == NEITHER && !only_asan_supported_flags)) {\n+      if (only_asan_supported_flags) {\n+        // if this is a conversion to ASAN upported flags, transfer this\n+        // allocation to the ASAN allocator\n+        void *replacement_alloc;\n+        if (dwFlags & HEAP_ZERO_MEMORY)\n+          replacement_alloc = asan_calloc(1, dwBytes, &stack);\n+        else\n+          replacement_alloc = asan_malloc(dwBytes, &stack);\n+        if (replacement_alloc) {\n+          size_t old_size = heapSizeFunc(hHeap, dwFlags, lpMem);\n+          if (old_size == ((size_t)0) - 1) {\n+            asan_free(replacement_alloc, &stack, FROM_MALLOC);\n+            return nullptr;\n+          }\n+          REAL(memcpy)(replacement_alloc, lpMem, old_size);\n+          freeFunc(hHeap, dwFlags, lpMem);\n+        }\n+        return replacement_alloc;\n+      } else {\n+        // owned by rtl or neither with unsupported ASAN flags,\n+        // just pass back to original allocator\n+        CHECK(ownershipState == RTL || ownershipState == NEITHER);\n+        CHECK(!only_asan_supported_flags);\n+        return reallocFunc(hHeap, dwFlags, lpMem, dwBytes);\n+      }\n+    }\n+\n+    if (ownershipState == ASAN && !only_asan_supported_flags) {\n+      // Conversion to unsupported flags allocation,\n+      // transfer this allocation back to the original allocator.\n+      void *replacement_alloc = allocFunc(hHeap, dwFlags, dwBytes);\n+      size_t old_usable_size = 0;\n+      if (replacement_alloc) {\n+        old_usable_size = asan_malloc_usable_size(lpMem, pc, bp);\n+        REAL(memcpy)(replacement_alloc, lpMem,\n+                     Min<size_t>(dwBytes, old_usable_size));\n+        asan_free(lpMem, &stack, FROM_MALLOC);\n+      }\n+      return replacement_alloc;\n+    }\n+\n+    CHECK((ownershipState == ASAN || ownershipState == NEITHER) &&\n+          only_asan_supported_flags);\n+    // At this point we should either be ASAN owned with ASAN supported flags\n+    // or we owned by neither and have supported flags.\n+    // Pass through even when it's neither since this could be a null realloc or\n+    // UAF that ASAN needs to catch.\n+  } else {\n+    CHECK((HEAP_REALLOC_UNSUPPORTED_FLAGS & dwFlags) != 0 &&\n+          \"unsupported flags\");\n+  }\n+  // asan_realloc will never reallocate in place, so for now this flag is\n+  // unsupported until we figure out a way to fake this.\n+  if (dwFlags & HEAP_REALLOC_IN_PLACE_ONLY)\n+    return nullptr;\n+\n+  // HeapReAlloc and HeapAlloc both happily accept 0 sized allocations.\n+  // passing a 0 size into asan_realloc will free the allocation.\n+  // To avoid this and keep behavior consistent, fudge the size if 0.\n+  // (asan_malloc already does this)\n+  if (dwBytes == 0)\n+    dwBytes = 1;\n+\n+  size_t old_size;\n+  if (dwFlags & HEAP_ZERO_MEMORY)\n+    old_size = asan_malloc_usable_size(lpMem, pc, bp);\n+\n+  void *ptr = asan_realloc(lpMem, dwBytes, &stack);\n+  if (ptr == nullptr)\n+    return nullptr;\n+\n+  if (dwFlags & HEAP_ZERO_MEMORY) {\n+    size_t new_size = asan_malloc_usable_size(ptr, pc, bp);\n+    if (old_size < new_size)\n+      REAL(memset)(((u8 *)ptr) + old_size, 0, new_size - old_size);\n+  }\n+\n+  return ptr;\n+}\n+}  // namespace __asan\n+\n+INTERCEPTOR_WINAPI(LPVOID, HeapReAlloc, HANDLE hHeap, DWORD dwFlags,\n+                   LPVOID lpMem, size_t dwBytes) {\n+  return SharedReAlloc(REAL(HeapReAlloc), (SizeFunction)REAL(HeapSize),\n+                       REAL(HeapFree), REAL(HeapAlloc), hHeap, dwFlags, lpMem,\n+                       dwBytes);\n+}\n+\n+// The following functions are undocumented and subject to change.\n+// However, hooking them is necessary to hook Windows heap\n+// allocations with detours and their definitions are unlikely to change.\n+// Comments in /minkernel/ntos/rtl/heappublic.c indicate that these functions\n+// are part of the heap's public interface.\n+typedef unsigned long LOGICAL;\n+\n+// This function is documented as part of the Driver Development Kit but *not*\n+// the Windows Development Kit.\n+LOGICAL RtlFreeHeap(void* HeapHandle, DWORD Flags,\n+                            void* BaseAddress);\n+\n+// This function is documented as part of the Driver Development Kit but *not*\n+// the Windows Development Kit.\n+void* RtlAllocateHeap(void* HeapHandle, DWORD Flags, size_t Size);\n+\n+// This function is completely undocumented.\n+void*\n+RtlReAllocateHeap(void* HeapHandle, DWORD Flags, void* BaseAddress,\n+                  size_t Size);\n+\n+// This function is completely undocumented.\n+size_t RtlSizeHeap(void* HeapHandle, DWORD Flags, void* BaseAddress);\n+\n+INTERCEPTOR_WINAPI(size_t, RtlSizeHeap, HANDLE HeapHandle, DWORD Flags,\n+                   void* BaseAddress) {\n+  if (!flags()->windows_hook_rtl_allocators ||\n+      UNLIKELY(!asan_inited || OWNED_BY_RTL(HeapHandle, BaseAddress))) {\n+    return REAL(RtlSizeHeap)(HeapHandle, Flags, BaseAddress);\n+  }\n+  GET_CURRENT_PC_BP_SP;\n+  (void)sp;\n+  return asan_malloc_usable_size(BaseAddress, pc, bp);\n+}\n+\n+INTERCEPTOR_WINAPI(BOOL, RtlFreeHeap, HANDLE HeapHandle, DWORD Flags,\n+                   void* BaseAddress) {\n+  // Heap allocations happen before this function is hooked, so we must fall\n+  // back to the original function if the pointer is not from the ASAN heap, or\n+  // unsupported flags are provided.\n+  if (!flags()->windows_hook_rtl_allocators ||\n+      UNLIKELY((HEAP_FREE_UNSUPPORTED_FLAGS & Flags) != 0 ||\n+               OWNED_BY_RTL(HeapHandle, BaseAddress))) {\n+    return REAL(RtlFreeHeap)(HeapHandle, Flags, BaseAddress);\n+  }\n+  GET_STACK_TRACE_FREE;\n+  asan_free(BaseAddress, &stack, FROM_MALLOC);\n+  return true;\n+}\n+\n+INTERCEPTOR_WINAPI(void*, RtlAllocateHeap, HANDLE HeapHandle, DWORD Flags,\n+                   size_t Size) {\n+  // If the ASAN runtime is not initialized, or we encounter an unsupported\n+  // flag, fall back to the original allocator.\n+  if (!flags()->windows_hook_rtl_allocators ||\n+      UNLIKELY(!asan_inited ||\n+               (Flags & HEAP_ALLOCATE_UNSUPPORTED_FLAGS) != 0)) {\n+    return REAL(RtlAllocateHeap)(HeapHandle, Flags, Size);\n+  }\n+  GET_STACK_TRACE_MALLOC;\n+  void *p;\n+  // Reading MSDN suggests that the *entire* usable allocation is zeroed out.\n+  // Otherwise it is difficult to HeapReAlloc with HEAP_ZERO_MEMORY.\n+  // https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083\n+  if (Flags & HEAP_ZERO_MEMORY) {\n+    p = asan_calloc(Size, 1, &stack);\n+  } else {\n+    p = asan_malloc(Size, &stack);\n+  }\n+  return p;\n+}\n+\n+INTERCEPTOR_WINAPI(void*, RtlReAllocateHeap, HANDLE HeapHandle, DWORD Flags,\n+                   void* BaseAddress, size_t Size) {\n+  // If it's actually a heap block which was allocated before the ASAN runtime\n+  // came up, use the real RtlFreeHeap function.\n+  if (!flags()->windows_hook_rtl_allocators)\n+    return REAL(RtlReAllocateHeap)(HeapHandle, Flags, BaseAddress, Size);\n+\n+  return SharedReAlloc(REAL(RtlReAllocateHeap), REAL(RtlSizeHeap),\n+                       REAL(RtlFreeHeap), REAL(RtlAllocateHeap), HeapHandle,\n+                       Flags, BaseAddress, Size);\n+}\n+\n+namespace __asan {\n+\n+static void TryToOverrideFunction(const char *fname, uptr new_func) {\n+  // Failure here is not fatal. The CRT may not be present, and different CRT\n+  // versions use different symbols.\n+  if (!__interception::OverrideFunction(fname, new_func))\n+    VPrintf(2, \"Failed to override function %s\\n\", fname);\n+}\n+\n+void ReplaceSystemMalloc() {\n+#if defined(ASAN_DYNAMIC)\n+  TryToOverrideFunction(\"free\", (uptr)free);\n+  TryToOverrideFunction(\"_free_base\", (uptr)free);\n+  TryToOverrideFunction(\"malloc\", (uptr)malloc);\n+  TryToOverrideFunction(\"_malloc_base\", (uptr)malloc);\n+  TryToOverrideFunction(\"_malloc_crt\", (uptr)malloc);\n+  TryToOverrideFunction(\"calloc\", (uptr)calloc);\n+  TryToOverrideFunction(\"_calloc_base\", (uptr)calloc);\n+  TryToOverrideFunction(\"_calloc_crt\", (uptr)calloc);\n+  TryToOverrideFunction(\"realloc\", (uptr)realloc);\n+  TryToOverrideFunction(\"_realloc_base\", (uptr)realloc);\n+  TryToOverrideFunction(\"_realloc_crt\", (uptr)realloc);\n+  TryToOverrideFunction(\"_recalloc\", (uptr)_recalloc);\n+  TryToOverrideFunction(\"_recalloc_base\", (uptr)_recalloc);\n+  TryToOverrideFunction(\"_recalloc_crt\", (uptr)_recalloc);\n+  TryToOverrideFunction(\"_msize\", (uptr)_msize);\n+  TryToOverrideFunction(\"_msize_base\", (uptr)_msize);\n+  TryToOverrideFunction(\"_expand\", (uptr)_expand);\n+  TryToOverrideFunction(\"_expand_base\", (uptr)_expand);\n+\n+  if (flags()->windows_hook_rtl_allocators) {\n+    INTERCEPT_FUNCTION(HeapSize);\n+    INTERCEPT_FUNCTION(HeapFree);\n+    INTERCEPT_FUNCTION(HeapReAlloc);\n+    INTERCEPT_FUNCTION(HeapAlloc);\n+\n+    // Undocumented functions must be intercepted by name, not by symbol.\n+    __interception::OverrideFunction(\"RtlSizeHeap\", (uptr)WRAP(RtlSizeHeap),\n+                                     (uptr *)&REAL(RtlSizeHeap));\n+    __interception::OverrideFunction(\"RtlFreeHeap\", (uptr)WRAP(RtlFreeHeap),\n+                                     (uptr *)&REAL(RtlFreeHeap));\n+    __interception::OverrideFunction(\"RtlReAllocateHeap\",\n+                                     (uptr)WRAP(RtlReAllocateHeap),\n+                                     (uptr *)&REAL(RtlReAllocateHeap));\n+    __interception::OverrideFunction(\"RtlAllocateHeap\",\n+                                     (uptr)WRAP(RtlAllocateHeap),\n+                                     (uptr *)&REAL(RtlAllocateHeap));\n+  } else {\n+#define INTERCEPT_UCRT_FUNCTION(func)                                         \\\n+  if (!INTERCEPT_FUNCTION_DLLIMPORT(\"ucrtbase.dll\",                           \\\n+                                    \"api-ms-win-core-heap-l1-1-0.dll\", func)) \\\n+    VPrintf(2, \"Failed to intercept ucrtbase.dll import %s\\n\", #func);\n+    INTERCEPT_UCRT_FUNCTION(HeapAlloc);\n+    INTERCEPT_UCRT_FUNCTION(HeapFree);\n+    INTERCEPT_UCRT_FUNCTION(HeapReAlloc);\n+    INTERCEPT_UCRT_FUNCTION(HeapSize);\n+#undef INTERCEPT_UCRT_FUNCTION\n+  }\n+  // Recent versions of ucrtbase.dll appear to be built with PGO and LTCG, which\n+  // enable cross-module inlining. This means our _malloc_base hook won't catch\n+  // all CRT allocations. This code here patches the import table of\n+  // ucrtbase.dll so that all attempts to use the lower-level win32 heap\n+  // allocation API will be directed to ASan's heap. We don't currently\n+  // intercept all calls to HeapAlloc. If we did, we would have to check on\n+  // HeapFree whether the pointer came from ASan of from the system.\n+\n+#endif  // defined(ASAN_DYNAMIC)\n+}\n+}  // namespace __asan\n+\n+#endif  // _WIN32"}, {"sha": "41fb49ee46d460774a487c638b2c58531b8ac8d0", "filename": "libsanitizer/asan/asan_mapping.h", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- asan_mapping.h ------------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -159,14 +160,10 @@ static const u64 kDefaultShadowOffset32 = 1ULL << 29;  // 0x20000000\n static const u64 kDefaultShadowOffset64 = 1ULL << 44;\n static const u64 kDefaultShort64bitShadowOffset =\n     0x7FFFFFFF & (~0xFFFULL << kDefaultShadowScale);  // < 2G.\n-static const u64 kIosShadowOffset32 = 1ULL << 30;  // 0x40000000\n-static const u64 kIosShadowOffset64 = 0x120200000;\n-static const u64 kIosSimShadowOffset32 = 1ULL << 30;\n-static const u64 kIosSimShadowOffset64 = kDefaultShadowOffset64;\n static const u64 kAArch64_ShadowOffset64 = 1ULL << 36;\n static const u64 kMIPS32_ShadowOffset32 = 0x0aaa0000;\n static const u64 kMIPS64_ShadowOffset64 = 1ULL << 37;\n-static const u64 kPPC64_ShadowOffset64 = 1ULL << 41;\n+static const u64 kPPC64_ShadowOffset64 = 1ULL << 44;\n static const u64 kSystemZ_ShadowOffset64 = 1ULL << 52;\n static const u64 kSPARC64_ShadowOffset64 = 1ULL << 43;  // 0x80000000000\n static const u64 kFreeBSD_ShadowOffset32 = 1ULL << 30;  // 0x40000000\n@@ -200,23 +197,15 @@ static const u64 kMyriadCacheBitMask32 = 0x40000000ULL;\n #  elif SANITIZER_WINDOWS\n #    define SHADOW_OFFSET kWindowsShadowOffset32\n #  elif SANITIZER_IOS\n-#    if SANITIZER_IOSSIM\n-#      define SHADOW_OFFSET kIosSimShadowOffset32\n-#    else\n-#      define SHADOW_OFFSET kIosShadowOffset32\n-#    endif\n+#    define SHADOW_OFFSET __asan_shadow_memory_dynamic_address\n #  elif SANITIZER_MYRIAD2\n #    define SHADOW_OFFSET kMyriadShadowOffset32\n #  else\n #    define SHADOW_OFFSET kDefaultShadowOffset32\n #  endif\n #else\n #  if SANITIZER_IOS\n-#    if SANITIZER_IOSSIM\n-#      define SHADOW_OFFSET kIosSimShadowOffset64\n-#    else\n-#      define SHADOW_OFFSET __asan_shadow_memory_dynamic_address\n-#    endif\n+#    define SHADOW_OFFSET __asan_shadow_memory_dynamic_address\n #  elif defined(__aarch64__)\n #    define SHADOW_OFFSET kAArch64_ShadowOffset64\n #  elif defined(__powerpc64__)\n@@ -231,8 +220,8 @@ static const u64 kMyriadCacheBitMask32 = 0x40000000ULL;\n #   define SHADOW_OFFSET kDefaultShadowOffset64\n #  elif defined(__mips64)\n #   define SHADOW_OFFSET kMIPS64_ShadowOffset64\n-#  elif defined(__sparc__)\n-#   define SHADOW_OFFSET kSPARC64_ShadowOffset64\n+#elif defined(__sparc__)\n+#define SHADOW_OFFSET kSPARC64_ShadowOffset64\n #  elif SANITIZER_WINDOWS64\n #   define SHADOW_OFFSET __asan_shadow_memory_dynamic_address\n #  else"}, {"sha": "6969e3a49310b05eda6fd179644fbfe1ef794654", "filename": "libsanitizer/asan/asan_mapping_myriad.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_mapping_myriad.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_mapping_myriad.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping_myriad.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- asan_mapping_myriad.h -----------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "432a1816f797d61f4ccf044ea3ba8880db3814b7", "filename": "libsanitizer/asan/asan_mapping_sparc64.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_mapping_sparc64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_mapping_sparc64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping_sparc64.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- asan_mapping_sparc64.h ----------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "4fcd5600ed1a14c8ca42556de1d4cc07cc57d557", "filename": "libsanitizer/asan/asan_memory_profile.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_memory_profile.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_memory_profile.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_memory_profile.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_memory_profile.cc.cc -----------------------------------------===//\n+//===-- asan_memory_profile.cpp ----------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/asan/asan_memory_profile.cc"}, {"sha": "c15e208094ef84d9882f3420ee6b7e534a1a8372", "filename": "libsanitizer/asan/asan_new_delete.cpp", "status": "renamed", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_new_delete.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_new_delete.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_new_delete.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_interceptors.cc ----------------------------------------------===//\n+//===-- asan_interceptors.cpp ---------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -70,25 +71,19 @@ enum class align_val_t: size_t {};\n // TODO(alekseyshl): throw std::bad_alloc instead of dying on OOM.\n // For local pool allocation, align to SHADOW_GRANULARITY to match asan\n // allocator behavior.\n-#define OPERATOR_NEW_BODY(type, nothrow) \\\n-  if (ALLOCATE_FROM_LOCAL_POOL) {\\\n-    void *res = MemalignFromLocalPool(SHADOW_GRANULARITY, size);\\\n-    if (!nothrow) CHECK(res);\\\n-    return res;\\\n-  }\\\n-  GET_STACK_TRACE_MALLOC;\\\n-  void *res = asan_memalign(0, size, &stack, type);\\\n-  if (!nothrow && UNLIKELY(!res)) ReportOutOfMemory(size, &stack);\\\n+#define OPERATOR_NEW_BODY(type, nothrow)            \\\n+  MAYBE_ALLOCATE_FROM_LOCAL_POOL(nothrow);          \\\n+  GET_STACK_TRACE_MALLOC;                           \\\n+  void *res = asan_memalign(0, size, &stack, type); \\\n+  if (!nothrow && UNLIKELY(!res))                   \\\n+    ReportOutOfMemory(size, &stack);                \\\n   return res;\n-#define OPERATOR_NEW_BODY_ALIGN(type, nothrow) \\\n-  if (ALLOCATE_FROM_LOCAL_POOL) {\\\n-    void *res = MemalignFromLocalPool((uptr)align, size);\\\n-    if (!nothrow) CHECK(res);\\\n-    return res;\\\n-  }\\\n-  GET_STACK_TRACE_MALLOC;\\\n-  void *res = asan_memalign((uptr)align, size, &stack, type);\\\n-  if (!nothrow && UNLIKELY(!res)) ReportOutOfMemory(size, &stack);\\\n+#define OPERATOR_NEW_BODY_ALIGN(type, nothrow)                \\\n+  MAYBE_ALLOCATE_FROM_LOCAL_POOL(nothrow);                    \\\n+  GET_STACK_TRACE_MALLOC;                                     \\\n+  void *res = asan_memalign((uptr)align, size, &stack, type); \\\n+  if (!nothrow && UNLIKELY(!res))                             \\\n+    ReportOutOfMemory(size, &stack);                          \\\n   return res;\n \n // On OS X it's not enough to just provide our own 'operator new' and", "previous_filename": "libsanitizer/asan/asan_new_delete.cc"}, {"sha": "6b36be7d1cd8c611ff05c6279338b6925cb583c8", "filename": "libsanitizer/asan/asan_poisoning.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_poisoning.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_poisoning.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_poisoning.cc -------------------------------------------------===//\n+//===-- asan_poisoning.cpp ------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/asan/asan_poisoning.cc"}, {"sha": "62dd9bd0edd3200c0f5738bb6bd2343ca315f4a9", "filename": "libsanitizer/asan/asan_poisoning.h", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_poisoning.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_poisoning.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- asan_poisoning.h ----------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -14,6 +15,7 @@\n #include \"asan_internal.h\"\n #include \"asan_mapping.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n+#include \"sanitizer_common/sanitizer_platform.h\"\n \n namespace __asan {\n \n@@ -37,6 +39,10 @@ void PoisonShadowPartialRightRedzone(uptr addr,\n ALWAYS_INLINE void FastPoisonShadow(uptr aligned_beg, uptr aligned_size,\n                                     u8 value) {\n   DCHECK(!value || CanPoisonMemory());\n+#if SANITIZER_FUCHSIA\n+  __sanitizer_fill_shadow(aligned_beg, aligned_size, value,\n+                          common_flags()->clear_shadow_mmap_threshold);\n+#else\n   uptr shadow_beg = MEM_TO_SHADOW(aligned_beg);\n   uptr shadow_end = MEM_TO_SHADOW(\n       aligned_beg + aligned_size - SHADOW_GRANULARITY) + 1;\n@@ -45,10 +51,6 @@ ALWAYS_INLINE void FastPoisonShadow(uptr aligned_beg, uptr aligned_size,\n   // probably provide higher-level interface for these operations.\n   // For now, just memset on Windows.\n   if (value || SANITIZER_WINDOWS == 1 ||\n-      // TODO(mcgrathr): Fuchsia doesn't allow the shadow mapping to be\n-      // changed at all.  It doesn't currently have an efficient means\n-      // to zero a bunch of pages, but maybe we should add one.\n-      SANITIZER_FUCHSIA == 1 ||\n       // RTEMS doesn't have have pages, let alone a fast way to zero\n       // them, so default to memset.\n       SANITIZER_RTEMS == 1 ||\n@@ -71,6 +73,7 @@ ALWAYS_INLINE void FastPoisonShadow(uptr aligned_beg, uptr aligned_size,\n       ReserveShadowMemoryRange(page_beg, page_end - 1, nullptr);\n     }\n   }\n+#endif // SANITIZER_FUCHSIA\n }\n \n ALWAYS_INLINE void FastPoisonShadowPartialRightRedzone("}, {"sha": "920d216624a3fd2587fcc62ee620ed2f1bd76c54", "filename": "libsanitizer/asan/asan_posix.cpp", "status": "renamed", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_posix.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_posix.cc -----------------------------------------------------===//\n+//===-- asan_posix.cpp ----------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -38,6 +39,51 @@ void AsanOnDeadlySignal(int signo, void *siginfo, void *context) {\n \n // ---------------------- TSD ---------------- {{{1\n \n+#if SANITIZER_NETBSD && !ASAN_DYNAMIC\n+// Thread Static Data cannot be used in early static ASan init on NetBSD.\n+// Reuse the Asan TSD API for compatibility with existing code\n+// with an alternative implementation.\n+\n+static void (*tsd_destructor)(void *tsd) = nullptr;\n+\n+struct tsd_key {\n+  tsd_key() : key(nullptr) {}\n+  ~tsd_key() {\n+    CHECK(tsd_destructor);\n+    if (key)\n+      (*tsd_destructor)(key);\n+  }\n+  void *key;\n+};\n+\n+static thread_local struct tsd_key key;\n+\n+void AsanTSDInit(void (*destructor)(void *tsd)) {\n+  CHECK(!tsd_destructor);\n+  tsd_destructor = destructor;\n+}\n+\n+void *AsanTSDGet() {\n+  CHECK(tsd_destructor);\n+  return key.key;\n+}\n+\n+void AsanTSDSet(void *tsd) {\n+  CHECK(tsd_destructor);\n+  CHECK(tsd);\n+  CHECK(!key.key);\n+  key.key = tsd;\n+}\n+\n+void PlatformTSDDtor(void *tsd) {\n+  CHECK(tsd_destructor);\n+  CHECK_EQ(key.key, tsd);\n+  key.key = nullptr;\n+  // Make sure that signal handler can not see a stale current thread pointer.\n+  atomic_signal_fence(memory_order_seq_cst);\n+  AsanThread::TSDDtor(tsd);\n+}\n+#else\n static pthread_key_t tsd_key;\n static bool tsd_key_inited = false;\n void AsanTSDInit(void (*destructor)(void *tsd)) {\n@@ -65,6 +111,7 @@ void PlatformTSDDtor(void *tsd) {\n   }\n   AsanThread::TSDDtor(tsd);\n }\n+#endif\n }  // namespace __asan\n \n #endif  // SANITIZER_POSIX", "previous_filename": "libsanitizer/asan/asan_posix.cc"}, {"sha": "b07556ec96f8f9f32acc7e20105eb650fbc4a18b", "filename": "libsanitizer/asan/asan_preinit.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_preinit.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_preinit.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_preinit.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_preinit.cc ---------------------------------------------------===//\n+//===-- asan_preinit.cpp --------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/asan/asan_preinit.cc"}, {"sha": "7835e99748ffa77d9882ae6ce8172432c7be69a4", "filename": "libsanitizer/asan/asan_premap_shadow.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_premap_shadow.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_premap_shadow.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_premap_shadow.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_premap_shadow.cc ---------------------------------------------===//\n+//===-- asan_premap_shadow.cpp --------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/asan/asan_premap_shadow.cc"}, {"sha": "c9c886e8dca775c629510ec02fef37456256e257", "filename": "libsanitizer/asan/asan_premap_shadow.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_premap_shadow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_premap_shadow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_premap_shadow.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- asan_mapping.h ------------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "d36b0b4c5948fa5a9b4decd93cc5bc6b75db92e5", "filename": "libsanitizer/asan/asan_report.cpp", "status": "renamed", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_report.cc ----------------------------------------------------===//\n+//===-- asan_report.cpp ---------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -189,7 +190,7 @@ class ScopedInErrorReport {\n   void ReportError(const ErrorDescription &description) {\n     // Can only report one error per ScopedInErrorReport.\n     CHECK_EQ(current_error_.kind, kErrorKindInvalid);\n-    current_error_ = description;\n+    internal_memcpy(&current_error_, &description, sizeof(current_error_));\n   }\n \n   static ErrorDescription &CurrentError() {\n@@ -262,6 +263,13 @@ void ReportCallocOverflow(uptr count, uptr size, BufferedStackTrace *stack) {\n   in_report.ReportError(error);\n }\n \n+void ReportReallocArrayOverflow(uptr count, uptr size,\n+                                BufferedStackTrace *stack) {\n+  ScopedInErrorReport in_report(/*fatal*/ true);\n+  ErrorReallocArrayOverflow error(GetCurrentTidOrInvalid(), stack, count, size);\n+  in_report.ReportError(error);\n+}\n+\n void ReportPvallocOverflow(uptr size, BufferedStackTrace *stack) {\n   ScopedInErrorReport in_report(/*fatal*/ true);\n   ErrorPvallocOverflow error(GetCurrentTidOrInvalid(), stack, size);", "previous_filename": "libsanitizer/asan/asan_report.cc"}, {"sha": "dcf60894ef346e21d29defd9f2331e1fb79032bf", "filename": "libsanitizer/asan/asan_report.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- asan_report.h -------------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -60,6 +61,8 @@ void ReportMallocUsableSizeNotOwned(uptr addr, BufferedStackTrace *stack);\n void ReportSanitizerGetAllocatedSizeNotOwned(uptr addr,\n                                              BufferedStackTrace *stack);\n void ReportCallocOverflow(uptr count, uptr size, BufferedStackTrace *stack);\n+void ReportReallocArrayOverflow(uptr count, uptr size,\n+                                BufferedStackTrace *stack);\n void ReportPvallocOverflow(uptr size, BufferedStackTrace *stack);\n void ReportInvalidAllocationAlignment(uptr alignment,\n                                       BufferedStackTrace *stack);"}, {"sha": "360d5780a3f2e8f621ea1e710620c13f09004d7e", "filename": "libsanitizer/asan/asan_rtems.cpp", "status": "renamed", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_rtems.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_rtems.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtems.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_rtems.cc -----------------------------------------------------===//\n+//===-- asan_rtems.cpp ----------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -182,8 +183,8 @@ static void ThreadStartHook(void *hook, uptr os_id) {\n   // Determine whether we are starting or restarting the thread.\n   if (status == ThreadStatusCreated)\n     // In lieu of AsanThread::ThreadStart.\n-    asanThreadRegistry().StartThread(thread->tid(), os_id,\n-                                     /*workerthread*/ false, nullptr);\n+    asanThreadRegistry().StartThread(thread->tid(), os_id, ThreadType::Regular,\n+                                     nullptr);\n   else {\n     // In a thread restart, a thread may resume execution at an\n     // arbitrary function entry point, with its stack and TLS state\n@@ -211,6 +212,12 @@ static void HandleExit() {\n   }\n }\n \n+bool HandleDlopenInit() {\n+  // Not supported on this platform.\n+  static_assert(!SANITIZER_SUPPORTS_INIT_FOR_DLOPEN,\n+                \"Expected SANITIZER_SUPPORTS_INIT_FOR_DLOPEN to be false\");\n+  return false;\n+}\n }  // namespace __asan\n \n // These are declared (in extern \"C\") by <some_path/sanitizer.h>.", "previous_filename": "libsanitizer/asan/asan_rtems.cc"}, {"sha": "b16ca950518ced99acccdb52d40efb4958f87401", "filename": "libsanitizer/asan/asan_rtl.cpp", "status": "renamed", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_rtl.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_rtl.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_rtl.cc -------------------------------------------------------===//\n+//===-- asan_rtl.cpp ------------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -381,6 +382,19 @@ void PrintAddressSpaceLayout() {\n           kHighShadowBeg > kMidMemEnd);\n }\n \n+#if defined(__thumb__) && defined(__linux__)\n+#define START_BACKGROUND_THREAD_IN_ASAN_INTERNAL\n+#endif\n+\n+#ifndef START_BACKGROUND_THREAD_IN_ASAN_INTERNAL\n+static bool UNUSED __local_asan_dyninit = [] {\n+  MaybeStartBackgroudThread();\n+  SetSoftRssLimitExceededCallback(AsanSoftRssLimitExceededCallback);\n+\n+  return false;\n+}();\n+#endif\n+\n static void AsanInitInternal() {\n   if (LIKELY(asan_inited)) return;\n   SanitizerToolName = \"AddressSanitizer\";\n@@ -394,6 +408,14 @@ static void AsanInitInternal() {\n   // initialization steps look at flags().\n   InitializeFlags();\n \n+  // Stop performing init at this point if we are being loaded via\n+  // dlopen() and the platform supports it.\n+  if (SANITIZER_SUPPORTS_INIT_FOR_DLOPEN && UNLIKELY(HandleDlopenInit())) {\n+    asan_init_is_running = false;\n+    VReport(1, \"AddressSanitizer init is being performed for dlopen().\\n\");\n+    return;\n+  }\n+\n   AsanCheckIncompatibleRT();\n   AsanCheckDynamicRTPrereqs();\n   AvoidCVE_2016_2143();\n@@ -418,6 +440,8 @@ static void AsanInitInternal() {\n   __asan_option_detect_stack_use_after_return =\n       flags()->detect_stack_use_after_return;\n \n+  __sanitizer::InitializePlatformEarly();\n+\n   // Re-exec ourselves if we need to set additional env or command line args.\n   MaybeReexec();\n \n@@ -445,8 +469,10 @@ static void AsanInitInternal() {\n   allocator_options.SetFrom(flags(), common_flags());\n   InitializeAllocator(allocator_options);\n \n+#ifdef START_BACKGROUND_THREAD_IN_ASAN_INTERNAL\n   MaybeStartBackgroudThread();\n   SetSoftRssLimitExceededCallback(AsanSoftRssLimitExceededCallback);\n+#endif\n \n   // On Linux AsanThread::ThreadStart() calls malloc() that's why asan_inited\n   // should be set to 1 prior to initializing the threads.\n@@ -571,6 +597,19 @@ void NOINLINE __asan_handle_no_return() {\n     curr_thread->fake_stack()->HandleNoReturn();\n }\n \n+extern \"C\" void *__asan_extra_spill_area() {\n+  AsanThread *t = GetCurrentThread();\n+  CHECK(t);\n+  return t->extra_spill_area();\n+}\n+\n+void __asan_handle_vfork(void *sp) {\n+  AsanThread *t = GetCurrentThread();\n+  CHECK(t);\n+  uptr bottom = t->stack_bottom();\n+  PoisonShadow(bottom, (uptr)sp - bottom, 0);\n+}\n+\n void NOINLINE __asan_set_death_callback(void (*callback)(void)) {\n   SetUserDieCallback(callback);\n }", "previous_filename": "libsanitizer/asan/asan_rtl.cc"}, {"sha": "9e7ba47d82dc3dd6354460304803e8c8e6a2a826", "filename": "libsanitizer/asan/asan_scariness_score.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_scariness_score.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_scariness_score.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_scariness_score.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- asan_scariness_score.h ----------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "fc9bf51e1b585b94c2f62ebecf06ea38346896ab", "filename": "libsanitizer/asan/asan_shadow_setup.cpp", "status": "renamed", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_shadow_setup.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_shadow_setup.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_shadow_setup.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_shadow_setup.cc ----------------------------------------------===//\n+//===-- asan_shadow_setup.cpp ---------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -12,7 +13,7 @@\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n \n-// asan_fuchsia.cc and asan_rtems.cc have their own\n+// asan_fuchsia.cpp and asan_rtems.cpp have their own\n // InitializeShadowMemory implementation.\n #if !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n \n@@ -36,7 +37,7 @@ void ReserveShadowMemoryRange(uptr beg, uptr end, const char *name) {\n         size);\n     Abort();\n   }\n-  if (common_flags()->no_huge_pages_for_shadow) NoHugePagesInRegion(beg, size);\n+  SetShadowRegionHugePageMode(beg, size);\n   if (common_flags()->use_madv_dontdump) DontDumpShadowMemory(beg, size);\n }\n ", "previous_filename": "libsanitizer/asan/asan_shadow_setup.cc"}, {"sha": "973c5ce59eff13c0293799e3c6d883d1dd7f4fb0", "filename": "libsanitizer/asan/asan_stack.cc", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/063082768aab23d26e42954eb115b76318f0176d/libsanitizer%2Fasan%2Fasan_stack.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/063082768aab23d26e42954eb115b76318f0176d/libsanitizer%2Fasan%2Fasan_stack.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stack.cc?ref=063082768aab23d26e42954eb115b76318f0176d", "patch": "@@ -1,38 +0,0 @@\n-//===-- asan_stack.cc -----------------------------------------------------===//\n-//\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file is a part of AddressSanitizer, an address sanity checker.\n-//\n-// Code for ASan stack trace.\n-//===----------------------------------------------------------------------===//\n-#include \"asan_internal.h\"\n-#include \"asan_stack.h\"\n-#include \"sanitizer_common/sanitizer_atomic.h\"\n-\n-namespace __asan {\n-\n-static atomic_uint32_t malloc_context_size;\n-\n-void SetMallocContextSize(u32 size) {\n-  atomic_store(&malloc_context_size, size, memory_order_release);\n-}\n-\n-u32 GetMallocContextSize() {\n-  return atomic_load(&malloc_context_size, memory_order_acquire);\n-}\n-\n-}  // namespace __asan\n-\n-// ------------------ Interface -------------- {{{1\n-\n-extern \"C\" {\n-SANITIZER_INTERFACE_ATTRIBUTE\n-void __sanitizer_print_stack_trace() {\n-  using namespace __asan;\n-  PRINT_CURRENT_STACK();\n-}\n-}  // extern \"C\""}, {"sha": "b7f4e6aeeab07a7410ec817180da0aa81f6d74b8", "filename": "libsanitizer/asan/asan_stack.cpp", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_stack.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_stack.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stack.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -0,0 +1,88 @@\n+//===-- asan_stack.cpp ----------------------------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Code for ASan stack trace.\n+//===----------------------------------------------------------------------===//\n+#include \"asan_internal.h\"\n+#include \"asan_stack.h\"\n+#include \"sanitizer_common/sanitizer_atomic.h\"\n+\n+namespace __asan {\n+\n+static atomic_uint32_t malloc_context_size;\n+\n+void SetMallocContextSize(u32 size) {\n+  atomic_store(&malloc_context_size, size, memory_order_release);\n+}\n+\n+u32 GetMallocContextSize() {\n+  return atomic_load(&malloc_context_size, memory_order_acquire);\n+}\n+\n+namespace {\n+\n+// ScopedUnwinding is a scope for stacktracing member of a context\n+class ScopedUnwinding {\n+ public:\n+  explicit ScopedUnwinding(AsanThread *t) : thread(t) {\n+    if (thread) {\n+      can_unwind = !thread->isUnwinding();\n+      thread->setUnwinding(true);\n+    }\n+  }\n+  ~ScopedUnwinding() {\n+    if (thread)\n+      thread->setUnwinding(false);\n+  }\n+\n+  bool CanUnwind() const { return can_unwind; }\n+\n+ private:\n+  AsanThread *thread = nullptr;\n+  bool can_unwind = true;\n+};\n+\n+}  // namespace\n+\n+}  // namespace __asan\n+\n+void __sanitizer::BufferedStackTrace::UnwindImpl(\n+    uptr pc, uptr bp, void *context, bool request_fast, u32 max_depth) {\n+  using namespace __asan;\n+  size = 0;\n+  if (UNLIKELY(!asan_inited))\n+    return;\n+  request_fast = StackTrace::WillUseFastUnwind(request_fast);\n+  AsanThread *t = GetCurrentThread();\n+  ScopedUnwinding unwind_scope(t);\n+  if (!unwind_scope.CanUnwind())\n+    return;\n+  if (request_fast) {\n+    if (t) {\n+      Unwind(max_depth, pc, bp, nullptr, t->stack_top(), t->stack_bottom(),\n+             true);\n+    }\n+    return;\n+  }\n+  if (SANITIZER_MIPS && t &&\n+      !IsValidFrame(bp, t->stack_top(), t->stack_bottom()))\n+    return;\n+  Unwind(max_depth, pc, bp, context, 0, 0, false);\n+}\n+\n+// ------------------ Interface -------------- {{{1\n+\n+extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __sanitizer_print_stack_trace() {\n+  using namespace __asan;\n+  PRINT_CURRENT_STACK();\n+}\n+}  // extern \"C\""}, {"sha": "4089d3d7340eed015c6209ae61575c12d16f3ddd", "filename": "libsanitizer/asan/asan_stack.h", "status": "modified", "additions": 10, "deletions": 37, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stack.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,13 +1,14 @@\n //===-- asan_stack.h --------------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n // This file is a part of AddressSanitizer, an address sanity checker.\n //\n-// ASan-private header for asan_stack.cc.\n+// ASan-private header for asan_stack.cpp.\n //===----------------------------------------------------------------------===//\n \n #ifndef ASAN_STACK_H\n@@ -25,34 +26,6 @@ static const u32 kDefaultMallocContextSize = 30;\n void SetMallocContextSize(u32 size);\n u32 GetMallocContextSize();\n \n-// Get the stack trace with the given pc and bp.\n-// The pc will be in the position 0 of the resulting stack trace.\n-// The bp may refer to the current frame or to the caller's frame.\n-ALWAYS_INLINE\n-void GetStackTrace(BufferedStackTrace *stack, uptr max_depth, uptr pc, uptr bp,\n-                   void *context, bool fast) {\n-#if SANITIZER_WINDOWS\n-  stack->Unwind(max_depth, pc, bp, context, 0, 0, fast);\n-#else\n-  AsanThread *t;\n-  stack->size = 0;\n-  if (LIKELY(asan_inited)) {\n-    if ((t = GetCurrentThread()) && !t->isUnwinding()) {\n-      uptr stack_top = t->stack_top();\n-      uptr stack_bottom = t->stack_bottom();\n-      ScopedUnwinding unwind_scope(t);\n-      if (!SANITIZER_MIPS || IsValidFrame(bp, stack_top, stack_bottom)) {\n-        stack->Unwind(max_depth, pc, bp, context, stack_top, stack_bottom,\n-                      fast);\n-      }\n-    } else if (!t && !fast) {\n-      /* If GetCurrentThread() has failed, try to do slow unwind anyways. */\n-      stack->Unwind(max_depth, pc, bp, context, 0, 0, false);\n-    }\n-  }\n-#endif // SANITIZER_WINDOWS\n-}\n-\n } // namespace __asan\n \n // NOTE: A Rule of thumb is to retrieve stack trace in the interceptors\n@@ -69,19 +42,19 @@ void GetStackTrace(BufferedStackTrace *stack, uptr max_depth, uptr pc, uptr bp,\n       if (max_size > 1) stack.trace_buffer[1] = GET_CALLER_PC(); \\\n     }                                                            \\\n   } else {                                                       \\\n-    GetStackTrace(&stack, max_size, StackTrace::GetCurrentPc(),  \\\n-                  GET_CURRENT_FRAME(), 0, fast);                 \\\n+    stack.Unwind(StackTrace::GetCurrentPc(),                     \\\n+                 GET_CURRENT_FRAME(), nullptr, fast, max_size);  \\\n   }\n \n #define GET_STACK_TRACE_FATAL(pc, bp)              \\\n   BufferedStackTrace stack;                        \\\n-  GetStackTrace(&stack, kStackTraceMax, pc, bp, 0, \\\n-                common_flags()->fast_unwind_on_fatal)\n+  stack.Unwind(pc, bp, nullptr,                    \\\n+               common_flags()->fast_unwind_on_fatal)\n \n #define GET_STACK_TRACE_SIGNAL(sig)                                        \\\n   BufferedStackTrace stack;                                                \\\n-  GetStackTrace(&stack, kStackTraceMax, (sig).pc, (sig).bp, (sig).context, \\\n-                common_flags()->fast_unwind_on_fatal)\n+  stack.Unwind((sig).pc, (sig).bp, (sig).context,                          \\\n+               common_flags()->fast_unwind_on_fatal)\n \n #define GET_STACK_TRACE_FATAL_HERE                                \\\n   GET_STACK_TRACE(kStackTraceMax, common_flags()->fast_unwind_on_fatal)"}, {"sha": "bc4e8c15cc156af9d6a32f16c4752b3fde6c2808", "filename": "libsanitizer/asan/asan_stats.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_stats.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_stats.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stats.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_stats.cc -----------------------------------------------------===//\n+//===-- asan_stats.cpp ----------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/asan/asan_stats.cc"}, {"sha": "d6da6534081f047b4e6ff3f3d22f7fa95f93fa3d", "filename": "libsanitizer/asan/asan_stats.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_stats.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_stats.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stats.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- asan_stats.h --------------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "a9c0d1076940f9e7885b8e5bf624b53012254820", "filename": "libsanitizer/asan/asan_suppressions.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_suppressions.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_suppressions.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_suppressions.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_suppressions.cc ----------------------------------------------===//\n+//===-- asan_suppressions.cpp ---------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/asan/asan_suppressions.cc"}, {"sha": "121d4ddf18756e0f0785764a02ad2e1969086a04", "filename": "libsanitizer/asan/asan_suppressions.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_suppressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_suppressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_suppressions.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,13 +1,14 @@\n //===-- asan_suppressions.h -------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n // This file is a part of AddressSanitizer, an address sanity checker.\n //\n-// ASan-private header for asan_suppressions.cc.\n+// ASan-private header for asan_suppressions.cpp.\n //===----------------------------------------------------------------------===//\n #ifndef ASAN_SUPPRESSIONS_H\n #define ASAN_SUPPRESSIONS_H"}, {"sha": "d48b3414dd57994f40d791c69b90fc506f43162f", "filename": "libsanitizer/asan/asan_thread.cpp", "status": "renamed", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_thread.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_thread.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_thread.cc ----------------------------------------------------===//\n+//===-- asan_thread.cpp ---------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -221,9 +222,11 @@ void AsanThread::Init(const InitOptions *options) {\n   atomic_store(&stack_switching_, false, memory_order_release);\n   CHECK_EQ(this->stack_size(), 0U);\n   SetThreadStackAndTls(options);\n-  CHECK_GT(this->stack_size(), 0U);\n-  CHECK(AddrIsInMem(stack_bottom_));\n-  CHECK(AddrIsInMem(stack_top_ - 1));\n+  if (stack_top_ != stack_bottom_) {\n+    CHECK_GT(this->stack_size(), 0U);\n+    CHECK(AddrIsInMem(stack_bottom_));\n+    CHECK(AddrIsInMem(stack_top_ - 1));\n+  }\n   ClearShadowForThreadStackAndTLS();\n   fake_stack_ = nullptr;\n   if (__asan_option_detect_stack_use_after_return)\n@@ -242,8 +245,7 @@ void AsanThread::Init(const InitOptions *options) {\n thread_return_t AsanThread::ThreadStart(\n     tid_t os_id, atomic_uintptr_t *signal_thread_is_registered) {\n   Init();\n-  asanThreadRegistry().StartThread(tid(), os_id, /*workerthread*/ false,\n-                                   nullptr);\n+  asanThreadRegistry().StartThread(tid(), os_id, ThreadType::Regular, nullptr);\n   if (signal_thread_is_registered)\n     atomic_store(signal_thread_is_registered, 1, memory_order_release);\n \n@@ -287,20 +289,23 @@ void AsanThread::SetThreadStackAndTls(const InitOptions *options) {\n   DCHECK_EQ(options, nullptr);\n   uptr tls_size = 0;\n   uptr stack_size = 0;\n-  GetThreadStackAndTls(tid() == 0, const_cast<uptr *>(&stack_bottom_),\n-                       const_cast<uptr *>(&stack_size), &tls_begin_, &tls_size);\n+  GetThreadStackAndTls(tid() == 0, &stack_bottom_, &stack_size, &tls_begin_,\n+                       &tls_size);\n   stack_top_ = stack_bottom_ + stack_size;\n   tls_end_ = tls_begin_ + tls_size;\n   dtls_ = DTLS_Get();\n \n-  int local;\n-  CHECK(AddrIsInStack((uptr)&local));\n+  if (stack_top_ != stack_bottom_) {\n+    int local;\n+    CHECK(AddrIsInStack((uptr)&local));\n+  }\n }\n \n #endif  // !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n \n void AsanThread::ClearShadowForThreadStackAndTLS() {\n-  PoisonShadow(stack_bottom_, stack_top_ - stack_bottom_, 0);\n+  if (stack_top_ != stack_bottom_)\n+    PoisonShadow(stack_bottom_, stack_top_ - stack_bottom_, 0);\n   if (tls_begin_ != tls_end_) {\n     uptr tls_begin_aligned = RoundDownTo(tls_begin_, SHADOW_GRANULARITY);\n     uptr tls_end_aligned = RoundUpTo(tls_end_, SHADOW_GRANULARITY);\n@@ -312,6 +317,9 @@ void AsanThread::ClearShadowForThreadStackAndTLS() {\n \n bool AsanThread::GetStackFrameAccessByAddr(uptr addr,\n                                            StackFrameAccess *access) {\n+  if (stack_top_ == stack_bottom_)\n+    return false;\n+\n   uptr bottom = 0;\n   if (AddrIsInStack(addr)) {\n     bottom = stack_bottom();", "previous_filename": "libsanitizer/asan/asan_thread.cc"}, {"sha": "c503f507059dd2e59d1bc176e5b58cd17cde94e0", "filename": "libsanitizer/asan/asan_thread.h", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,13 +1,14 @@\n //===-- asan_thread.h -------------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n // This file is a part of AddressSanitizer, an address sanity checker.\n //\n-// ASan-private header for asan_thread.cc.\n+// ASan-private header for asan_thread.cpp.\n //===----------------------------------------------------------------------===//\n \n #ifndef ASAN_THREAD_H\n@@ -129,6 +130,8 @@ class AsanThread {\n   AsanThreadLocalMallocStorage &malloc_storage() { return malloc_storage_; }\n   AsanStats &stats() { return stats_; }\n \n+  void *extra_spill_area() { return &extra_spill_area_; }\n+\n  private:\n   // NOTE: There is no AsanThread constructor. It is allocated\n   // via mmap() and *must* be valid in zero-initialized state.\n@@ -164,18 +167,7 @@ class AsanThread {\n   AsanThreadLocalMallocStorage malloc_storage_;\n   AsanStats stats_;\n   bool unwinding_;\n-};\n-\n-// ScopedUnwinding is a scope for stacktracing member of a context\n-class ScopedUnwinding {\n- public:\n-  explicit ScopedUnwinding(AsanThread *t) : thread(t) {\n-    t->setUnwinding(true);\n-  }\n-  ~ScopedUnwinding() { thread->setUnwinding(false); }\n-\n- private:\n-  AsanThread *thread;\n+  uptr extra_spill_area_;\n };\n \n // Returns a single instance of registry."}, {"sha": "f8b98ca336693d89f7ad0cba0283cc44559a9dd1", "filename": "libsanitizer/asan/asan_win.cpp", "status": "renamed", "additions": 81, "deletions": 34, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_win.cc -------------------------------------------------------===//\n+//===-- asan_win.cpp ------------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -19,10 +20,10 @@\n \n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n+#include \"asan_mapping.h\"\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n #include \"asan_thread.h\"\n-#include \"asan_mapping.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_mutex.h\"\n #include \"sanitizer_common/sanitizer_win.h\"\n@@ -76,7 +77,7 @@ static long WINAPI SEHHandler(EXCEPTION_POINTERS *info) {\n }\n \n INTERCEPTOR_WINAPI(LPTOP_LEVEL_EXCEPTION_FILTER, SetUnhandledExceptionFilter,\n-    LPTOP_LEVEL_EXCEPTION_FILTER ExceptionFilter) {\n+                   LPTOP_LEVEL_EXCEPTION_FILTER ExceptionFilter) {\n   CHECK(REAL(SetUnhandledExceptionFilter));\n   if (ExceptionFilter == &SEHHandler)\n     return REAL(SetUnhandledExceptionFilter)(ExceptionFilter);\n@@ -103,7 +104,9 @@ INTERCEPTOR_WINAPI(void, RaiseException, void *a, void *b, void *c, void *d) {\n \n #ifdef _WIN64\n \n-INTERCEPTOR_WINAPI(int, __C_specific_handler, void *a, void *b, void *c, void *d) {  // NOLINT\n+INTERCEPTOR_WINAPI(EXCEPTION_DISPOSITION, __C_specific_handler,\n+                   _EXCEPTION_RECORD *a, void *b, _CONTEXT *c,\n+                   _DISPATCHER_CONTEXT *d) {  // NOLINT\n   CHECK(REAL(__C_specific_handler));\n   __asan_handle_no_return();\n   return REAL(__C_specific_handler)(a, b, c, d);\n@@ -129,15 +132,14 @@ INTERCEPTOR(int, _except_handler4, void *a, void *b, void *c, void *d) {\n #endif\n \n static thread_return_t THREAD_CALLING_CONV asan_thread_start(void *arg) {\n-  AsanThread *t = (AsanThread*)arg;\n+  AsanThread *t = (AsanThread *)arg;\n   SetCurrentThread(t);\n   return t->ThreadStart(GetTid(), /* signal_thread_is_registered */ nullptr);\n }\n \n-INTERCEPTOR_WINAPI(DWORD, CreateThread,\n-                   void* security, uptr stack_size,\n-                   DWORD (__stdcall *start_routine)(void*), void* arg,\n-                   DWORD thr_flags, void* tid) {\n+INTERCEPTOR_WINAPI(HANDLE, CreateThread, LPSECURITY_ATTRIBUTES security,\n+                   SIZE_T stack_size, LPTHREAD_START_ROUTINE start_routine,\n+                   void *arg, DWORD thr_flags, DWORD *tid) {\n   // Strict init-order checking is thread-hostile.\n   if (flags()->strict_init_order)\n     StopInitOrderChecking();\n@@ -147,9 +149,9 @@ INTERCEPTOR_WINAPI(DWORD, CreateThread,\n   bool detached = false;  // FIXME: how can we determine it on Windows?\n   u32 current_tid = GetCurrentTidOrInvalid();\n   AsanThread *t =\n-        AsanThread::Create(start_routine, arg, current_tid, &stack, detached);\n-  return REAL(CreateThread)(security, stack_size,\n-                            asan_thread_start, t, thr_flags, tid);\n+      AsanThread::Create(start_routine, arg, current_tid, &stack, detached);\n+  return REAL(CreateThread)(security, stack_size, asan_thread_start, t,\n+                            thr_flags, tid);\n }\n \n // }}}\n@@ -160,10 +162,9 @@ void InitializePlatformInterceptors() {\n   // The interceptors were not designed to be removable, so we have to keep this\n   // module alive for the life of the process.\n   HMODULE pinned;\n-  CHECK(GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |\n-                           GET_MODULE_HANDLE_EX_FLAG_PIN,\n-                           (LPCWSTR)&InitializePlatformInterceptors,\n-                           &pinned));\n+  CHECK(GetModuleHandleExW(\n+      GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_PIN,\n+      (LPCWSTR)&InitializePlatformInterceptors, &pinned));\n \n   ASAN_INTERCEPT_FUNC(CreateThread);\n   ASAN_INTERCEPT_FUNC(SetUnhandledExceptionFilter);\n@@ -195,24 +196,46 @@ static bool tsd_key_inited = false;\n \n static __declspec(thread) void *fake_tsd = 0;\n \n+// https://docs.microsoft.com/en-us/windows/desktop/api/winternl/ns-winternl-_teb\n+// \"[This structure may be altered in future versions of Windows. Applications\n+// should use the alternate functions listed in this topic.]\"\n+typedef struct _TEB {\n+  PVOID Reserved1[12];\n+  // PVOID ThreadLocalStoragePointer; is here, at the last field in Reserved1.\n+  PVOID ProcessEnvironmentBlock;\n+  PVOID Reserved2[399];\n+  BYTE Reserved3[1952];\n+  PVOID TlsSlots[64];\n+  BYTE Reserved4[8];\n+  PVOID Reserved5[26];\n+  PVOID ReservedForOle;\n+  PVOID Reserved6[4];\n+  PVOID TlsExpansionSlots;\n+} TEB, *PTEB;\n+\n+constexpr size_t TEB_RESERVED_FIELDS_THREAD_LOCAL_STORAGE_OFFSET = 11;\n+BOOL IsTlsInitialized() {\n+  PTEB teb = (PTEB)NtCurrentTeb();\n+  return teb->Reserved1[TEB_RESERVED_FIELDS_THREAD_LOCAL_STORAGE_OFFSET] !=\n+         nullptr;\n+}\n+\n void AsanTSDInit(void (*destructor)(void *tsd)) {\n   // FIXME: we're ignoring the destructor for now.\n   tsd_key_inited = true;\n }\n \n void *AsanTSDGet() {\n   CHECK(tsd_key_inited);\n-  return fake_tsd;\n+  return IsTlsInitialized() ? fake_tsd : nullptr;\n }\n \n void AsanTSDSet(void *tsd) {\n   CHECK(tsd_key_inited);\n   fake_tsd = tsd;\n }\n \n-void PlatformTSDDtor(void *tsd) {\n-  AsanThread::TSDDtor(tsd);\n-}\n+void PlatformTSDDtor(void *tsd) { AsanThread::TSDDtor(tsd); }\n // }}}\n \n // ---------------------- Various stuff ---------------- {{{\n@@ -243,9 +266,7 @@ void ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n   UNIMPLEMENTED();\n }\n \n-void AsanOnDeadlySignal(int, void *siginfo, void *context) {\n-  UNIMPLEMENTED();\n-}\n+void AsanOnDeadlySignal(int, void *siginfo, void *context) { UNIMPLEMENTED(); }\n \n #if SANITIZER_WINDOWS64\n // Exception handler for dealing with shadow memory.\n@@ -254,7 +275,9 @@ ShadowExceptionHandler(PEXCEPTION_POINTERS exception_pointers) {\n   uptr page_size = GetPageSizeCached();\n   // Only handle access violations.\n   if (exception_pointers->ExceptionRecord->ExceptionCode !=\n-      EXCEPTION_ACCESS_VIOLATION) {\n+          EXCEPTION_ACCESS_VIOLATION ||\n+      exception_pointers->ExceptionRecord->NumberParameters < 2) {\n+    __asan_handle_no_return();\n     return EXCEPTION_CONTINUE_SEARCH;\n   }\n \n@@ -263,7 +286,10 @@ ShadowExceptionHandler(PEXCEPTION_POINTERS exception_pointers) {\n       (uptr)(exception_pointers->ExceptionRecord->ExceptionInformation[1]);\n \n   // Check valid shadow range.\n-  if (!AddrIsInShadow(addr)) return EXCEPTION_CONTINUE_SEARCH;\n+  if (!AddrIsInShadow(addr)) {\n+    __asan_handle_no_return();\n+    return EXCEPTION_CONTINUE_SEARCH;\n+  }\n \n   // This is an access violation while trying to read from the shadow. Commit\n   // the relevant page and let execution continue.\n@@ -274,7 +300,8 @@ ShadowExceptionHandler(PEXCEPTION_POINTERS exception_pointers) {\n   // Commit the page.\n   uptr result =\n       (uptr)::VirtualAlloc((LPVOID)page, page_size, MEM_COMMIT, PAGE_READWRITE);\n-  if (result != page) return EXCEPTION_CONTINUE_SEARCH;\n+  if (result != page)\n+    return EXCEPTION_CONTINUE_SEARCH;\n \n   // The page mapping succeeded, so continue execution as usual.\n   return EXCEPTION_CONTINUE_EXECUTION;\n@@ -291,7 +318,7 @@ void InitializePlatformExceptionHandlers() {\n }\n \n bool IsSystemHeapAddress(uptr addr) {\n-  return ::HeapValidate(GetProcessHeap(), 0, (void*)addr) != FALSE;\n+  return ::HeapValidate(GetProcessHeap(), 0, (void *)addr) != FALSE;\n }\n \n // We want to install our own exception handler (EH) to print helpful reports\n@@ -310,8 +337,7 @@ bool IsSystemHeapAddress(uptr addr) {\n // asan_dynamic_runtime_thunk.lib to all the modules, thus __asan_set_seh_filter\n // will be called for each instrumented module.  This ensures that at least one\n // __asan_set_seh_filter call happens after the .exe module CRT is initialized.\n-extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n-int __asan_set_seh_filter() {\n+extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE int __asan_set_seh_filter() {\n   // We should only store the previous handler if it's not our own handler in\n   // order to avoid loops in the EH chain.\n   auto prev_seh_handler = SetUnhandledExceptionFilter(SEHHandler);\n@@ -320,6 +346,13 @@ int __asan_set_seh_filter() {\n   return 0;\n }\n \n+bool HandleDlopenInit() {\n+  // Not supported on this platform.\n+  static_assert(!SANITIZER_SUPPORTS_INIT_FOR_DLOPEN,\n+                \"Expected SANITIZER_SUPPORTS_INIT_FOR_DLOPEN to be false\");\n+  return false;\n+}\n+\n #if !ASAN_DYNAMIC\n // The CRT runs initializers in this order:\n // - C initializers, from XIA to XIZ\n@@ -338,14 +371,28 @@ __declspec(allocate(\".CRT$XCAB\")) int (*__intercept_seh)() =\n // which run before the CRT. Users also add code to .CRT$XLC, so it's important\n // to run our initializers first.\n static void NTAPI asan_thread_init(void *module, DWORD reason, void *reserved) {\n-  if (reason == DLL_PROCESS_ATTACH) __asan_init();\n+  if (reason == DLL_PROCESS_ATTACH)\n+    __asan_init();\n }\n \n #pragma section(\".CRT$XLAB\", long, read)  // NOLINT\n-__declspec(allocate(\".CRT$XLAB\")) void (NTAPI *__asan_tls_init)(void *,\n-    unsigned long, void *) = asan_thread_init;\n+__declspec(allocate(\".CRT$XLAB\")) void(NTAPI *__asan_tls_init)(\n+    void *, unsigned long, void *) = asan_thread_init;\n #endif\n \n+static void NTAPI asan_thread_exit(void *module, DWORD reason, void *reserved) {\n+  if (reason == DLL_THREAD_DETACH) {\n+    // Unpoison the thread's stack because the memory may be re-used.\n+    NT_TIB *tib = (NT_TIB *)NtCurrentTeb();\n+    uptr stackSize = (uptr)tib->StackBase - (uptr)tib->StackLimit;\n+    __asan_unpoison_memory_region(tib->StackLimit, stackSize);\n+  }\n+}\n+\n+#pragma section(\".CRT$XLY\", long, read)  // NOLINT\n+__declspec(allocate(\".CRT$XLY\")) void(NTAPI *__asan_tls_exit)(\n+    void *, unsigned long, void *) = asan_thread_exit;\n+\n WIN_FORCE_LINK(__asan_dso_reg_hook)\n \n // }}}", "previous_filename": "libsanitizer/asan/asan_win.cc"}, {"sha": "95eee5eed0d3dd8363701dc8f838e57e922bc60c", "filename": "libsanitizer/asan/asan_win_dll_thunk.cpp", "status": "renamed", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_win_dll_thunk.cc ---------------------------------------------===//\n+//===-- asan_win_dll_thunk.cpp --------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -46,13 +47,14 @@ INTERCEPT_WRAP_W_WWW(_recalloc)\n INTERCEPT_WRAP_W_WWW(_recalloc_base)\n \n INTERCEPT_WRAP_W_W(_msize)\n+INTERCEPT_WRAP_W_W(_msize_base)\n INTERCEPT_WRAP_W_W(_expand)\n INTERCEPT_WRAP_W_W(_expand_dbg)\n \n // TODO(timurrrr): Might want to add support for _aligned_* allocation\n // functions to detect a bit more bugs.  Those functions seem to wrap malloc().\n \n-// TODO(timurrrr): Do we need to add _Crt* stuff here? (see asan_malloc_win.cc).\n+// TODO(timurrrr): Do we need to add _Crt* stuff here? (see asan_malloc_win.cpp)\n \n INTERCEPT_LIBRARY_FUNCTION(atoi);\n INTERCEPT_LIBRARY_FUNCTION(atol);", "previous_filename": "libsanitizer/asan/asan_win_dll_thunk.cc"}, {"sha": "5bd457a22b65ac1da08c5c22f81b212532ac7224", "filename": "libsanitizer/asan/asan_win_dynamic_runtime_thunk.cpp", "status": "renamed", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_win_dynamic_runtime_thunk.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_win_dynamic_runtime_thunk.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win_dynamic_runtime_thunk.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_win_dynamic_runtime_thunk.cc ---------------------------------===//\n+//===-- asan_win_dynamic_runtime_thunk.cpp --------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -113,7 +114,7 @@ int (*__asan_schedule_unregister_globals)() = ScheduleUnregisterGlobals;\n ////////////////////////////////////////////////////////////////////////////////\n // ASan SEH handling.\n // We need to set the ASan-specific SEH handler at the end of CRT initialization\n-// of each module (see also asan_win.cc).\n+// of each module (see also asan_win.cpp).\n extern \"C\" {\n __declspec(dllimport) int __asan_set_seh_filter();\n static int SetSEHFilter() { return __asan_set_seh_filter(); }", "previous_filename": "libsanitizer/asan/asan_win_dynamic_runtime_thunk.cc"}, {"sha": "62534e12e2a69c727bc682a8b885bcee77c57233", "filename": "libsanitizer/asan/asan_win_weak_interception.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_win_weak_interception.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fasan%2Fasan_win_weak_interception.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win_weak_interception.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- asan_win_weak_interception.cc -------------------------------------===//\n+//===-- asan_win_weak_interception.cpp ------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n // This module should be included in Address Sanitizer when it is implemented as", "previous_filename": "libsanitizer/asan/asan_win_weak_interception.cc"}, {"sha": "f437cb87f60ace84869930743330978ea9eb3952", "filename": "libsanitizer/builtins/assembly.h", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fbuiltins%2Fassembly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fbuiltins%2Fassembly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fbuiltins%2Fassembly.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,17 +1,15 @@\n-/* ===-- assembly.h - compiler-rt assembler support macros -----------------===\n- *\n- *                     The LLVM Compiler Infrastructure\n- *\n- * This file is dual licensed under the MIT and the University of Illinois Open\n- * Source Licenses. See LICENSE.TXT for details.\n- *\n- * ===----------------------------------------------------------------------===\n- *\n- * This file defines macros for use in compiler-rt assembler source.\n- * This file is not part of the interface of this library.\n- *\n- * ===----------------------------------------------------------------------===\n- */\n+//===-- assembly.h - compiler-rt assembler support macros -----------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file defines macros for use in compiler-rt assembler source.\n+// This file is not part of the interface of this library.\n+//\n+//===----------------------------------------------------------------------===//\n \n #ifndef COMPILERRT_ASSEMBLY_H\n #define COMPILERRT_ASSEMBLY_H\n@@ -69,11 +67,9 @@\n \n #if defined(__arm__)\n \n-/*\n- * Determine actual [ARM][THUMB[1][2]] ISA using compiler predefined macros:\n- * - for '-mthumb -march=armv6' compiler defines '__thumb__'\n- * - for '-mthumb -march=armv7' compiler defines '__thumb__' and '__thumb2__'\n- */\n+// Determine actual [ARM][THUMB[1][2]] ISA using compiler predefined macros:\n+// - for '-mthumb -march=armv6' compiler defines '__thumb__'\n+// - for '-mthumb -march=armv7' compiler defines '__thumb__' and '__thumb2__'\n #if defined(__thumb2__) || defined(__thumb__)\n #define DEFINE_CODE_STATE .thumb SEPARATOR\n #define DECLARE_FUNC_ENCODING    .thumb_func SEPARATOR\n@@ -201,4 +197,4 @@\n #define END_COMPILERRT_FUNCTION(name)\n #endif\n \n-#endif /* COMPILERRT_ASSEMBLY_H */\n+#endif // COMPILERRT_ASSEMBLY_H"}, {"sha": "106bc0cfa6a5e97c09126ffd31f03c9f36ac4d22", "filename": "libsanitizer/configure", "status": "modified", "additions": 96, "deletions": 95, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfigure?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -708,7 +708,6 @@ am__nodep\n AMDEPBACKSLASH\n AMDEP_FALSE\n AMDEP_TRUE\n-am__quote\n am__include\n DEPDIR\n am__untar\n@@ -797,7 +796,8 @@ PACKAGE_VERSION\n PACKAGE_TARNAME\n PACKAGE_NAME\n PATH_SEPARATOR\n-SHELL'\n+SHELL\n+am__quote'\n ac_subst_files=''\n ac_user_opts='\n enable_option_checking\n@@ -4221,7 +4221,7 @@ esac\n \n \n \n-am__api_version='1.15'\n+am__api_version='1.16'\n \n # Find a good install program.  We prefer a C program (faster),\n # so one script is as good as another.  But avoid the broken or\n@@ -4647,45 +4647,45 @@ DEPDIR=\"${am__leading_dot}deps\"\n \n ac_config_commands=\"$ac_config_commands depfiles\"\n \n-\n-am_make=${MAKE-make}\n-cat > confinc << 'END'\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether ${MAKE-make} supports the include directive\" >&5\n+$as_echo_n \"checking whether ${MAKE-make} supports the include directive... \" >&6; }\n+cat > confinc.mk << 'END'\n am__doit:\n-\t@echo this is the am__doit target\n+\t@echo this is the am__doit target >confinc.out\n .PHONY: am__doit\n END\n-# If we don't find an include directive, just comment out the code.\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for style of include used by $am_make\" >&5\n-$as_echo_n \"checking for style of include used by $am_make... \" >&6; }\n am__include=\"#\"\n am__quote=\n-_am_result=none\n-# First try GNU make style include.\n-echo \"include confinc\" > confmf\n-# Ignore all kinds of additional output from 'make'.\n-case `$am_make -s -f confmf 2> /dev/null` in #(\n-*the\\ am__doit\\ target*)\n-  am__include=include\n-  am__quote=\n-  _am_result=GNU\n-  ;;\n-esac\n-# Now try BSD make style include.\n-if test \"$am__include\" = \"#\"; then\n-   echo '.include \"confinc\"' > confmf\n-   case `$am_make -s -f confmf 2> /dev/null` in #(\n-   *the\\ am__doit\\ target*)\n-     am__include=.include\n-     am__quote=\"\\\"\"\n-     _am_result=BSD\n+# BSD make does it like this.\n+echo '.include \"confinc.mk\" # ignored' > confmf.BSD\n+# Other make implementations (GNU, Solaris 10, AIX) do it like this.\n+echo 'include confinc.mk # ignored' > confmf.GNU\n+_am_result=no\n+for s in GNU BSD; do\n+  { echo \"$as_me:$LINENO: ${MAKE-make} -f confmf.$s && cat confinc.out\" >&5\n+   (${MAKE-make} -f confmf.$s && cat confinc.out) >&5 2>&5\n+   ac_status=$?\n+   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+   (exit $ac_status); }\n+  case $?:`cat confinc.out 2>/dev/null` in #(\n+  '0:this is the am__doit target') :\n+    case $s in #(\n+  BSD) :\n+    am__include='.include' am__quote='\"' ;; #(\n+  *) :\n+    am__include='include' am__quote='' ;;\n+esac ;; #(\n+  *) :\n      ;;\n-   esac\n-fi\n-\n-\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $_am_result\" >&5\n-$as_echo \"$_am_result\" >&6; }\n-rm -f confinc confmf\n+esac\n+  if test \"$am__include\" != \"#\"; then\n+    _am_result=\"yes ($s style)\"\n+    break\n+  fi\n+done\n+rm -f confinc.* confmf.*\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: ${_am_result}\" >&5\n+$as_echo \"${_am_result}\" >&6; }\n \n # Check whether --enable-dependency-tracking was given.\n if test \"${enable_dependency_tracking+set}\" = set; then :\n@@ -4797,8 +4797,8 @@ MAKEINFO=${MAKEINFO-\"${am_missing_run}makeinfo\"}\n \n # For better backward compatibility.  To be removed once Automake 1.9.x\n # dies out for good.  For more background, see:\n-# <http://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>\n-# <http://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>\n+# <https://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>\n+# <https://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>\n mkdir_p='$(MKDIR_P)'\n \n # We need awk for the \"check\" target (and possibly the TAP driver).  The\n@@ -4977,7 +4977,7 @@ END\n Aborting the configuration process, to ensure you take notice of the issue.\n \n You can download and install GNU coreutils to get an 'rm' implementation\n-that behaves properly: <http://www.gnu.org/software/coreutils/>.\n+that behaves properly: <https://www.gnu.org/software/coreutils/>.\n \n If you want to complete the configuration process using your problematic\n 'rm' anyway, export the environment variable ACCEPT_INFERIOR_RM_PROGRAM\n@@ -17652,7 +17652,7 @@ CC=\"$CC\"\n CXX=\"$CXX\"\n GFORTRAN=\"$GFORTRAN\"\n GDC=\"$GDC\"\n-AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"\n+AMDEP_TRUE=\"$AMDEP_TRUE\" MAKE=\"${MAKE-make}\"\n \n \n # The HP-UX ksh and POSIX shell print the target directory to stdout\n@@ -18662,29 +18662,35 @@ esac ;;\n   # Older Autoconf quotes --file arguments for eval, but not when files\n   # are listed without --file.  Let's play safe and only enable the eval\n   # if we detect the quoting.\n-  case $CONFIG_FILES in\n-  *\\'*) eval set x \"$CONFIG_FILES\" ;;\n-  *)   set x $CONFIG_FILES ;;\n-  esac\n+  # TODO: see whether this extra hack can be removed once we start\n+  # requiring Autoconf 2.70 or later.\n+  case $CONFIG_FILES in #(\n+  *\\'*) :\n+    eval set x \"$CONFIG_FILES\" ;; #(\n+  *) :\n+    set x $CONFIG_FILES ;; #(\n+  *) :\n+     ;;\n+esac\n   shift\n-  for mf\n+  # Used to flag and report bootstrapping failures.\n+  am_rc=0\n+  for am_mf\n   do\n     # Strip MF so we end up with the name of the file.\n-    mf=`echo \"$mf\" | sed -e 's/:.*$//'`\n-    # Check whether this is an Automake generated Makefile or not.\n-    # We used to match only the files named 'Makefile.in', but\n-    # some people rename them; so instead we look at the file content.\n-    # Grep'ing the first line is not enough: some people post-process\n-    # each Makefile.in and add a new line on top of each file to say so.\n-    # Grep'ing the whole file is not good either: AIX grep has a line\n+    am_mf=`$as_echo \"$am_mf\" | sed -e 's/:.*$//'`\n+    # Check whether this is an Automake generated Makefile which includes\n+    # dependency-tracking related rules and includes.\n+    # Grep'ing the whole file directly is not great: AIX grep has a line\n     # limit of 2048, but all sed's we know have understand at least 4000.\n-    if sed -n 's,^#.*generated by automake.*,X,p' \"$mf\" | grep X >/dev/null 2>&1; then\n-      dirpart=`$as_dirname -- \"$mf\" ||\n-$as_expr X\"$mf\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n-\t X\"$mf\" : 'X\\(//\\)[^/]' \\| \\\n-\t X\"$mf\" : 'X\\(//\\)$' \\| \\\n-\t X\"$mf\" : 'X\\(/\\)' \\| . 2>/dev/null ||\n-$as_echo X\"$mf\" |\n+    sed -n 's,^am--depfiles:.*,X,p' \"$am_mf\" | grep X >/dev/null 2>&1 \\\n+      || continue\n+    am_dirpart=`$as_dirname -- \"$am_mf\" ||\n+$as_expr X\"$am_mf\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n+\t X\"$am_mf\" : 'X\\(//\\)[^/]' \\| \\\n+\t X\"$am_mf\" : 'X\\(//\\)$' \\| \\\n+\t X\"$am_mf\" : 'X\\(/\\)' \\| . 2>/dev/null ||\n+$as_echo X\"$am_mf\" |\n     sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n \t    s//\\1/\n \t    q\n@@ -18702,53 +18708,48 @@ $as_echo X\"$mf\" |\n \t    q\n \t  }\n \t  s/.*/./; q'`\n-    else\n-      continue\n-    fi\n-    # Extract the definition of DEPDIR, am__include, and am__quote\n-    # from the Makefile without running 'make'.\n-    DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n-    test -z \"$DEPDIR\" && continue\n-    am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n-    test -z \"$am__include\" && continue\n-    am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n-    # Find all dependency output files, they are included files with\n-    # $(DEPDIR) in their names.  We invoke sed twice because it is the\n-    # simplest approach to changing $(DEPDIR) to its actual value in the\n-    # expansion.\n-    for file in `sed -n \"\n-      s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n-\t sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g'`; do\n-      # Make sure the directory exists.\n-      test -f \"$dirpart/$file\" && continue\n-      fdir=`$as_dirname -- \"$file\" ||\n-$as_expr X\"$file\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n-\t X\"$file\" : 'X\\(//\\)[^/]' \\| \\\n-\t X\"$file\" : 'X\\(//\\)$' \\| \\\n-\t X\"$file\" : 'X\\(/\\)' \\| . 2>/dev/null ||\n-$as_echo X\"$file\" |\n-    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n-\t    s//\\1/\n-\t    q\n-\t  }\n-\t  /^X\\(\\/\\/\\)[^/].*/{\n+    am_filepart=`$as_basename -- \"$am_mf\" ||\n+$as_expr X/\"$am_mf\" : '.*/\\([^/][^/]*\\)/*$' \\| \\\n+\t X\"$am_mf\" : 'X\\(//\\)$' \\| \\\n+\t X\"$am_mf\" : 'X\\(/\\)' \\| . 2>/dev/null ||\n+$as_echo X/\"$am_mf\" |\n+    sed '/^.*\\/\\([^/][^/]*\\)\\/*$/{\n \t    s//\\1/\n \t    q\n \t  }\n-\t  /^X\\(\\/\\/\\)$/{\n+\t  /^X\\/\\(\\/\\/\\)$/{\n \t    s//\\1/\n \t    q\n \t  }\n-\t  /^X\\(\\/\\).*/{\n+\t  /^X\\/\\(\\/\\).*/{\n \t    s//\\1/\n \t    q\n \t  }\n \t  s/.*/./; q'`\n-      as_dir=$dirpart/$fdir; as_fn_mkdir_p\n-      # echo \"creating $dirpart/$file\"\n-      echo '# dummy' > \"$dirpart/$file\"\n-    done\n+    { echo \"$as_me:$LINENO: cd \"$am_dirpart\" \\\n+      && sed -e '/# am--include-marker/d' \"$am_filepart\" \\\n+        | $MAKE -f - am--depfiles\" >&5\n+   (cd \"$am_dirpart\" \\\n+      && sed -e '/# am--include-marker/d' \"$am_filepart\" \\\n+        | $MAKE -f - am--depfiles) >&5 2>&5\n+   ac_status=$?\n+   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+   (exit $ac_status); } || am_rc=$?\n   done\n+  if test $am_rc -ne 0; then\n+    { { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n+$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\n+as_fn_error $? \"Something went wrong bootstrapping makefile fragments\n+    for automatic dependency tracking.  Try re-running configure with the\n+    '--disable-dependency-tracking' option to at least be able to build\n+    the package (albeit without support for automatic dependency tracking).\n+See \\`config.log' for more details\" \"$LINENO\" 5; }\n+  fi\n+  { am_dirpart=; unset am_dirpart;}\n+  { am_filepart=; unset am_filepart;}\n+  { am_mf=; unset am_mf;}\n+  { am_rc=; unset am_rc;}\n+  rm -f conftest-deps.mk\n }\n  ;;\n     \"libtool\":C)"}, {"sha": "3fb90eab021eec4c9db5063b50ee2ae528400469", "filename": "libsanitizer/configure.tgt", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fconfigure.tgt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fconfigure.tgt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfigure.tgt?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -28,9 +28,6 @@ case \"${target}\" in\n \t\tLSAN_SUPPORTED=yes\n \t\tTSAN_TARGET_DEPENDENT_OBJECTS=tsan_rtl_amd64.lo\n \tfi\n-\tif echo \"int x = __x86_64__;\" | $CC -c -x c -o /dev/null - > /dev/null 2>&1; then\n-\t\tSANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS=sanitizer_linux_x86_64.lo\n-\tfi\n \t;;\n   powerpc*-*-linux*)\n \tif test x$ac_cv_sizeof_void_p = x8; then"}, {"sha": "6226135ef84b3c961212361dbc34e84d4010a106", "filename": "libsanitizer/include/sanitizer/allocator_interface.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Fallocator_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Fallocator_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fallocator_interface.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- allocator_interface.h ---------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "ab2dc97ed24ab51cc6374160acd47feefc158ab8", "filename": "libsanitizer/include/sanitizer/asan_interface.h", "status": "modified", "additions": 288, "deletions": 119, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,11 +1,12 @@\n //===-- sanitizer/asan_interface.h ------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n-// This file is a part of AddressSanitizer.\n+// This file is a part of AddressSanitizer (ASan).\n //\n // Public interface header.\n //===----------------------------------------------------------------------===//\n@@ -17,28 +18,54 @@\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n-  // Marks memory region [addr, addr+size) as unaddressable.\n-  // This memory must be previously allocated by the user program. Accessing\n-  // addresses in this region from instrumented code is forbidden until\n-  // this region is unpoisoned. This function is not guaranteed to poison\n-  // the whole region - it may poison only subregion of [addr, addr+size) due\n-  // to ASan alignment restrictions.\n-  // Method is NOT thread-safe in the sense that no two threads can\n-  // (un)poison memory in the same memory region simultaneously.\n-  void __asan_poison_memory_region(void const volatile *addr, size_t size);\n-  // Marks memory region [addr, addr+size) as addressable.\n-  // This memory must be previously allocated by the user program. Accessing\n-  // addresses in this region is allowed until this region is poisoned again.\n-  // This function may unpoison a superregion of [addr, addr+size) due to\n-  // ASan alignment restrictions.\n-  // Method is NOT thread-safe in the sense that no two threads can\n-  // (un)poison memory in the same memory region simultaneously.\n-  void __asan_unpoison_memory_region(void const volatile *addr, size_t size);\n-\n-// User code should use macros instead of functions.\n+/// Marks a memory region (<c>[addr, addr+size)</c>) as unaddressable.\n+///\n+/// This memory must be previously allocated by your program. Instrumented\n+/// code is forbidden from accessing addresses in this region until it is\n+/// unpoisoned. This function is not guaranteed to poison the entire region -\n+/// it could poison only a subregion of <c>[addr, addr+size)</c> due to ASan\n+/// alignment restrictions.\n+///\n+/// \\note This function is not thread-safe because no two threads can poison or\n+/// unpoison memory in the same memory region simultaneously.\n+///\n+/// \\param addr Start of memory region.\n+/// \\param size Size of memory region.\n+void __asan_poison_memory_region(void const volatile *addr, size_t size);\n+\n+/// Marks a memory region (<c>[addr, addr+size)</c>) as addressable.\n+///\n+/// This memory must be previously allocated by your program. Accessing\n+/// addresses in this region is allowed until this region is poisoned again.\n+/// This function could unpoison a super-region of <c>[addr, addr+size)</c> due\n+/// to ASan alignment restrictions.\n+///\n+/// \\note This function is not thread-safe because no two threads can\n+/// poison or unpoison memory in the same memory region simultaneously.\n+///\n+/// \\param addr Start of memory region.\n+/// \\param size Size of memory region.\n+void __asan_unpoison_memory_region(void const volatile *addr, size_t size);\n+\n+// Macros provided for convenience.\n #if __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)\n+/// Marks a memory region as unaddressable.\n+///\n+/// \\note Macro provided for convenience; defined as a no-op if ASan is not\n+/// enabled.\n+///\n+/// \\param addr Start of memory region.\n+/// \\param size Size of memory region.\n #define ASAN_POISON_MEMORY_REGION(addr, size) \\\n   __asan_poison_memory_region((addr), (size))\n+\n+/// Marks a memory region as addressable.\n+///\n+/// \\note Macro provided for convenience; defined as a no-op if ASan is not\n+/// enabled.\n+///\n+/// \\param addr Start of memory region.\n+/// \\param size Size of memory region.\n #define ASAN_UNPOISON_MEMORY_REGION(addr, size) \\\n   __asan_unpoison_memory_region((addr), (size))\n #else\n@@ -48,103 +75,245 @@ extern \"C\" {\n   ((void)(addr), (void)(size))\n #endif\n \n-  // Returns 1 if addr is poisoned (i.e. 1-byte read/write access to this\n-  // address will result in error report from AddressSanitizer).\n-  // Otherwise returns 0.\n-  int __asan_address_is_poisoned(void const volatile *addr);\n-\n-  // If at least one byte in [beg, beg+size) is poisoned, return the address\n-  // of the first such byte. Otherwise return 0.\n-  void *__asan_region_is_poisoned(void *beg, size_t size);\n-\n-  // Print the description of addr (useful when debugging in gdb).\n-  void __asan_describe_address(void *addr);\n-\n-  // Useful for calling from a debugger to get information about an ASan error.\n-  // Returns 1 if an error has been (or is being) reported, otherwise returns 0.\n-  int __asan_report_present(void);\n-\n-  // Useful for calling from a debugger to get information about an ASan error.\n-  // If an error has been (or is being) reported, the following functions return\n-  // the pc, bp, sp, address, access type (0 = read, 1 = write), access size and\n-  // bug description (e.g. \"heap-use-after-free\"). Otherwise they return 0.\n-  void *__asan_get_report_pc(void);\n-  void *__asan_get_report_bp(void);\n-  void *__asan_get_report_sp(void);\n-  void *__asan_get_report_address(void);\n-  int __asan_get_report_access_type(void);\n-  size_t __asan_get_report_access_size(void);\n-  const char *__asan_get_report_description(void);\n-\n-  // Useful for calling from the debugger to get information about a pointer.\n-  // Returns the category of the given pointer as a constant string.\n-  // Possible return values are \"global\", \"stack\", \"stack-fake\", \"heap\",\n-  // \"heap-invalid\", \"shadow-low\", \"shadow-gap\", \"shadow-high\", \"unknown\".\n-  // If global or stack, tries to also return the variable name, address and\n-  // size. If heap, tries to return the chunk address and size. 'name' should\n-  // point to an allocated buffer of size 'name_size'.\n-  const char *__asan_locate_address(void *addr, char *name, size_t name_size,\n-                                    void **region_address, size_t *region_size);\n-\n-  // Useful for calling from the debugger to get the allocation stack trace\n-  // and thread ID for a heap address. Stores up to 'size' frames into 'trace',\n-  // returns the number of stored frames or 0 on error.\n-  size_t __asan_get_alloc_stack(void *addr, void **trace, size_t size,\n-                                int *thread_id);\n-\n-  // Useful for calling from the debugger to get the free stack trace\n-  // and thread ID for a heap address. Stores up to 'size' frames into 'trace',\n-  // returns the number of stored frames or 0 on error.\n-  size_t __asan_get_free_stack(void *addr, void **trace, size_t size,\n-                               int *thread_id);\n-\n-  // Useful for calling from the debugger to get the current shadow memory\n-  // mapping.\n-  void __asan_get_shadow_mapping(size_t *shadow_scale, size_t *shadow_offset);\n-\n-  // This is an internal function that is called to report an error.\n-  // However it is still a part of the interface because users may want to\n-  // set a breakpoint on this function in a debugger.\n-  void __asan_report_error(void *pc, void *bp, void *sp,\n-                           void *addr, int is_write, size_t access_size);\n-\n-  // Deprecated. Call __sanitizer_set_death_callback instead.\n-  void __asan_set_death_callback(void (*callback)(void));\n-\n-  void __asan_set_error_report_callback(void (*callback)(const char*));\n-\n-  // User may provide function that would be called right when ASan detects\n-  // an error. This can be used to notice cases when ASan detects an error, but\n-  // the program crashes before ASan report is printed.\n-  void __asan_on_error(void);\n-\n-  // Prints accumulated stats to stderr. Used for debugging.\n-  void __asan_print_accumulated_stats(void);\n-\n-  // This function may be optionally provided by user and should return\n-  // a string containing ASan runtime options. See asan_flags.h for details.\n-  const char* __asan_default_options(void);\n-\n-  // The following 2 functions facilitate garbage collection in presence of\n-  // asan's fake stack.\n-\n-  // Returns an opaque handler to be used later in __asan_addr_is_in_fake_stack.\n-  // Returns NULL if the current thread does not have a fake stack.\n-  void *__asan_get_current_fake_stack(void);\n-\n-  // If fake_stack is non-NULL and addr belongs to a fake frame in\n-  // fake_stack, returns the address on real stack that corresponds to\n-  // the fake frame and sets beg/end to the boundaries of this fake frame.\n-  // Otherwise returns NULL and does not touch beg/end.\n-  // If beg/end are NULL, they are not touched.\n-  // This function may be called from a thread other than the owner of\n-  // fake_stack, but the owner thread need to be alive.\n-  void *__asan_addr_is_in_fake_stack(void *fake_stack, void *addr, void **beg,\n-                                     void **end);\n-\n-  // Performs cleanup before a [[noreturn]] function.  Must be called\n-  // before things like _exit and execl to avoid false positives on stack.\n-  void __asan_handle_no_return(void);\n+/// Checks if an address is poisoned.\n+///\n+/// Returns 1 if <c><i>addr</i></c> is poisoned (that is, 1-byte read/write\n+/// access to this address would result in an error report from ASan).\n+/// Otherwise returns 0.\n+///\n+/// \\param addr Address to check.\n+///\n+/// \\retval 1 Address is poisoned.\n+/// \\retval 0 Address is not poisoned.\n+int __asan_address_is_poisoned(void const volatile *addr);\n+\n+/// Checks if a region is poisoned.\n+///\n+/// If at least one byte in <c>[beg, beg+size)</c> is poisoned, returns the\n+/// address of the first such byte. Otherwise returns 0.\n+///\n+/// \\param beg Start of memory region.\n+/// \\param size Start of memory region.\n+/// \\returns Address of first poisoned byte.\n+void *__asan_region_is_poisoned(void *beg, size_t size);\n+\n+/// Describes an address (useful for calling from the debugger).\n+///\n+/// Prints the description of <c><i>addr</i></c>.\n+///\n+/// \\param addr Address to describe.\n+void __asan_describe_address(void *addr);\n+\n+/// Checks if an error has been or is being reported (useful for calling from\n+/// the debugger to get information about an ASan error).\n+///\n+/// Returns 1 if an error has been (or is being) reported. Otherwise returns 0.\n+///\n+/// \\returns 1 if an error has been (or is being) reported. Otherwise returns\n+/// 0.\n+int __asan_report_present(void);\n+\n+/// Gets the PC (program counter) register value of an ASan error (useful for\n+/// calling from the debugger).\n+///\n+/// Returns PC if an error has been (or is being) reported.\n+/// Otherwise returns 0.\n+///\n+/// \\returns PC value.\n+void *__asan_get_report_pc(void);\n+\n+/// Gets the BP (base pointer) register value of an ASan error (useful for\n+/// calling from the debugger).\n+///\n+/// Returns BP if an error has been (or is being) reported.\n+/// Otherwise returns 0.\n+///\n+/// \\returns BP value.\n+void *__asan_get_report_bp(void);\n+\n+/// Gets the SP (stack pointer) register value of an ASan error (useful for\n+/// calling from the debugger).\n+///\n+/// If an error has been (or is being) reported, returns SP.\n+/// Otherwise returns 0.\n+///\n+/// \\returns SP value.\n+void *__asan_get_report_sp(void);\n+\n+/// Gets the address of the report buffer of an ASan error (useful for calling\n+/// from the debugger).\n+///\n+/// Returns the address of the report buffer if an error has been (or is being)\n+/// reported. Otherwise returns 0.\n+///\n+/// \\returns Address of report buffer.\n+void *__asan_get_report_address(void);\n+\n+/// Gets access type of an ASan error (useful for calling from the debugger).\n+///\n+/// Returns access type (read or write) if an error has been (or is being)\n+/// reported. Otherwise returns 0.\n+///\n+/// \\returns Access type (0 = read, 1 = write).\n+int __asan_get_report_access_type(void);\n+\n+/// Gets access size of an ASan error (useful for calling from the debugger).\n+///\n+/// Returns access size if an error has been (or is being) reported. Otherwise\n+/// returns 0.\n+///\n+/// \\returns Access size in bytes.\n+size_t __asan_get_report_access_size(void);\n+\n+/// Gets the bug description of an ASan error (useful for calling from a\n+/// debugger).\n+///\n+/// \\returns Returns a bug description if an error has been (or is being)\n+/// reported - for example, \"heap-use-after-free\". Otherwise returns an empty\n+/// string.\n+const char *__asan_get_report_description(void);\n+\n+/// Gets information about a pointer (useful for calling from the debugger).\n+///\n+/// Returns the category of the given pointer as a constant string.\n+/// Possible return values are <c>global</c>, <c>stack</c>, <c>stack-fake</c>,\n+/// <c>heap</c>, <c>heap-invalid</c>, <c>shadow-low</c>, <c>shadow-gap</c>,\n+/// <c>shadow-high</c>, and <c>unknown</c>.\n+///\n+/// If the return value is <c>global</c> or <c>stack</c>, tries to also return\n+/// the variable name, address, and size. If the return value is <c>heap</c>,\n+/// tries to return the chunk address and size. <c><i>name</i></c> should point\n+/// to an allocated buffer of size <c><i>name_size</i></c>.\n+///\n+/// \\param addr Address to locate.\n+/// \\param name Buffer to store the variable's name.\n+/// \\param name_size Size in bytes of the variable's name buffer.\n+/// \\param region_address [out] Address of the region.\n+/// \\param region_size [out] Size of the region in bytes.\n+///\n+/// \\returns Returns the category of the given pointer as a constant string.\n+const char *__asan_locate_address(void *addr, char *name, size_t name_size,\n+                                  void **region_address, size_t *region_size);\n+\n+/// Gets the allocation stack trace and thread ID for a heap address (useful\n+/// for calling from the debugger).\n+///\n+/// Stores up to <c><i>size</i></c> frames in <c><i>trace</i></c>. Returns\n+/// the number of stored frames or 0 on error.\n+///\n+/// \\param addr A heap address.\n+/// \\param trace A buffer to store the stack trace.\n+/// \\param size Size in bytes of the trace buffer.\n+/// \\param thread_id [out] The thread ID of the address.\n+///\n+/// \\returns Returns the number of stored frames or 0 on error.\n+size_t __asan_get_alloc_stack(void *addr, void **trace, size_t size,\n+                              int *thread_id);\n+\n+/// Gets the free stack trace and thread ID for a heap address (useful for\n+/// calling from the debugger).\n+///\n+/// Stores up to <c><i>size</i></c> frames in <c><i>trace</i></c>. Returns\n+/// the number of stored frames or 0 on error.\n+///\n+/// \\param addr A heap address.\n+/// \\param trace A buffer to store the stack trace.\n+/// \\param size Size in bytes of the trace buffer.\n+/// \\param thread_id [out] The thread ID of the address.\n+///\n+/// \\returns Returns the number of stored frames or 0 on error.\n+size_t __asan_get_free_stack(void *addr, void **trace, size_t size,\n+                             int *thread_id);\n+\n+/// Gets the current shadow memory mapping (useful for calling from the\n+/// debugger).\n+///\n+/// \\param shadow_scale [out] Shadow scale value.\n+/// \\param shadow_offset [out] Offset value.\n+void __asan_get_shadow_mapping(size_t *shadow_scale, size_t *shadow_offset);\n+\n+/// This is an internal function that is called to report an error. However,\n+/// it is still a part of the interface because you might want to set a\n+/// breakpoint on this function in the debugger.\n+///\n+/// \\param pc <c><i>pc</i></c> value of the ASan error.\n+/// \\param bp <c><i>bp</i></c> value of the ASan error.\n+/// \\param sp <c><i>sp</i></c> value of the ASan error.\n+/// \\param addr Address of the ASan error.\n+/// \\param is_write True if the error is a write error; false otherwise.\n+/// \\param access_size Size of the memory access of the ASan error.\n+void __asan_report_error(void *pc, void *bp, void *sp,\n+                         void *addr, int is_write, size_t access_size);\n+\n+// Deprecated. Call __sanitizer_set_death_callback instead.\n+void __asan_set_death_callback(void (*callback)(void));\n+\n+/// Sets the callback function to be called during ASan error reporting.\n+///\n+/// The callback provides a string pointer to the report.\n+///\n+/// \\param callback User-provided function.\n+void __asan_set_error_report_callback(void (*callback)(const char *));\n+\n+/// User-provided callback on ASan errors.\n+///\n+/// You can provide a function that would be called immediately when ASan\n+/// detects an error. This is useful in cases when ASan detects an error but\n+/// your program crashes before the ASan report is printed.\n+void __asan_on_error(void);\n+\n+/// Prints accumulated statistics to <c>stderr</c> (useful for calling from the\n+/// debugger).\n+void __asan_print_accumulated_stats(void);\n+\n+/// User-provided default option settings.\n+///\n+/// You can provide your own implementation of this function to return a string\n+/// containing ASan runtime options (for example,\n+/// <c>verbosity=1:halt_on_error=0</c>).\n+///\n+/// \\returns Default options string.\n+const char* __asan_default_options(void);\n+\n+// The following two functions facilitate garbage collection in presence of\n+// ASan's fake stack.\n+\n+/// Gets an opaque handler to the current thread's fake stack.\n+///\n+/// Returns an opaque handler to be used by\n+/// <c>__asan_addr_is_in_fake_stack()</c>. Returns NULL if the current thread\n+/// does not have a fake stack.\n+///\n+/// \\returns An opaque handler to the fake stack or NULL.\n+void *__asan_get_current_fake_stack(void);\n+\n+/// Checks if an address belongs to a given fake stack.\n+///\n+/// If <c><i>fake_stack</i></c> is non-NULL and <c><i>addr</i></c> belongs to a\n+/// fake frame in <c><i>fake_stack</i></c>, returns the address of the real\n+/// stack that corresponds to the fake frame and sets <c><i>beg</i></c> and\n+/// <c><i>end</i></c> to the boundaries of this fake frame. Otherwise returns\n+/// NULL and does not touch <c><i>beg</i></c> and <c><i>end</i></c>.\n+///\n+/// If <c><i>beg</i></c> or <c><i>end</i></c> are NULL, they are not touched.\n+///\n+/// \\note This function can be called from a thread other than the owner of\n+/// <c><i>fake_stack</i></c>, but the owner thread needs to be alive.\n+///\n+/// \\param fake_stack An opaque handler to a fake stack.\n+/// \\param addr Address to test.\n+/// \\param beg [out] Beginning of fake frame.\n+/// \\param end [out] End of fake frame.\n+/// \\returns Stack address or NULL.\n+void *__asan_addr_is_in_fake_stack(void *fake_stack, void *addr, void **beg,\n+                                   void **end);\n+\n+/// Performs shadow memory cleanup of the current thread's stack before a\n+/// function marked with the <c>[[noreturn]]</c> attribute is called.\n+///\n+/// To avoid false positives on the stack, must be called before no-return\n+/// functions like <c>_exit()</c> and <c>execl()</c>.\n+void __asan_handle_no_return(void);\n \n #ifdef __cplusplus\n }  // extern \"C\""}, {"sha": "f979c6a8f63b1c0b767bd5f2239555fd6245b439", "filename": "libsanitizer/include/sanitizer/common_interface_defs.h", "status": "modified", "additions": 327, "deletions": 180, "changes": 507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer/common_interface_defs.h -----------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -16,189 +17,335 @@\n \n // GCC does not understand __has_feature.\n #if !defined(__has_feature)\n-# define __has_feature(x) 0\n+#define __has_feature(x) 0\n #endif\n \n #ifdef __cplusplus\n extern \"C\" {\n #endif\n-  // Arguments for __sanitizer_sandbox_on_notify() below.\n-  typedef struct {\n-    // Enable sandbox support in sanitizer coverage.\n-    int coverage_sandboxed;\n-    // File descriptor to write coverage data to. If -1 is passed, a file will\n-    // be pre-opened by __sanitizer_sandobx_on_notify(). This field has no\n-    // effect if coverage_sandboxed == 0.\n-    intptr_t coverage_fd;\n-    // If non-zero, split the coverage data into well-formed blocks. This is\n-    // useful when coverage_fd is a socket descriptor. Each block will contain\n-    // a header, allowing data from multiple processes to be sent over the same\n-    // socket.\n-    unsigned int coverage_max_block_size;\n-  } __sanitizer_sandbox_arguments;\n-\n-  // Tell the tools to write their reports to \"path.<pid>\" instead of stderr.\n-  void __sanitizer_set_report_path(const char *path);\n-  // Tell the tools to write their reports to the provided file descriptor\n-  // (casted to void *).\n-  void __sanitizer_set_report_fd(void *fd);\n-\n-  // Notify the tools that the sandbox is going to be turned on. The reserved\n-  // parameter will be used in the future to hold a structure with functions\n-  // that the tools may call to bypass the sandbox.\n-  void __sanitizer_sandbox_on_notify(__sanitizer_sandbox_arguments *args);\n-\n-  // This function is called by the tool when it has just finished reporting\n-  // an error. 'error_summary' is a one-line string that summarizes\n-  // the error message. This function can be overridden by the client.\n-  void __sanitizer_report_error_summary(const char *error_summary);\n-\n-  // Some of the sanitizers (e.g. asan/tsan) may miss bugs that happen\n-  // in unaligned loads/stores. In order to find such bugs reliably one needs\n-  // to replace plain unaligned loads/stores with these calls.\n-  uint16_t __sanitizer_unaligned_load16(const void *p);\n-  uint32_t __sanitizer_unaligned_load32(const void *p);\n-  uint64_t __sanitizer_unaligned_load64(const void *p);\n-  void __sanitizer_unaligned_store16(void *p, uint16_t x);\n-  void __sanitizer_unaligned_store32(void *p, uint32_t x);\n-  void __sanitizer_unaligned_store64(void *p, uint64_t x);\n-\n-  // Returns 1 on the first call, then returns 0 thereafter.  Called by the tool\n-  // to ensure only one report is printed when multiple errors occur\n-  // simultaneously.\n-  int __sanitizer_acquire_crash_state();\n-\n-  // Annotate the current state of a contiguous container, such as\n-  // std::vector, std::string or similar.\n-  // A contiguous container is a container that keeps all of its elements\n-  // in a contiguous region of memory. The container owns the region of memory\n-  // [beg, end); the memory [beg, mid) is used to store the current elements\n-  // and the memory [mid, end) is reserved for future elements;\n-  // beg <= mid <= end. For example, in \"std::vector<> v\"\n-  //   beg = &v[0];\n-  //   end = beg + v.capacity() * sizeof(v[0]);\n-  //   mid = beg + v.size()     * sizeof(v[0]);\n-  //\n-  // This annotation tells the Sanitizer tool about the current state of the\n-  // container so that the tool can report errors when memory from [mid, end)\n-  // is accessed. Insert this annotation into methods like push_back/pop_back.\n-  // Supply the old and the new values of mid (old_mid/new_mid).\n-  // In the initial state mid == end and so should be the final\n-  // state when the container is destroyed or when it reallocates the storage.\n-  //\n-  // Use with caution and don't use for anything other than vector-like classes.\n-  //\n-  // For AddressSanitizer, 'beg' should be 8-aligned and 'end' should\n-  // be either 8-aligned or it should point to the end of a separate heap-,\n-  // stack-, or global- allocated buffer. I.e. the following will not work:\n-  //   int64_t x[2];  // 16 bytes, 8-aligned.\n-  //   char *beg = (char *)&x[0];\n-  //   char *end = beg + 12;  // Not 8 aligned, not the end of the buffer.\n-  // This however will work fine:\n-  //   int32_t x[3];  // 12 bytes, but 8-aligned under AddressSanitizer.\n-  //   char *beg = (char*)&x[0];\n-  //   char *end = beg + 12;  // Not 8-aligned, but is the end of the buffer.\n-  void __sanitizer_annotate_contiguous_container(const void *beg,\n-                                                 const void *end,\n-                                                 const void *old_mid,\n-                                                 const void *new_mid);\n-  // Returns true if the contiguous container [beg, end) is properly poisoned\n-  // (e.g. with __sanitizer_annotate_contiguous_container), i.e. if\n-  //  - [beg, mid) is addressable,\n-  //  - [mid, end) is unaddressable.\n-  // Full verification requires O(end-beg) time; this function tries to avoid\n-  // such complexity by touching only parts of the container around beg/mid/end.\n-  int __sanitizer_verify_contiguous_container(const void *beg, const void *mid,\n-                                              const void *end);\n-\n-  // Similar to __sanitizer_verify_contiguous_container but returns the address\n-  // of the first improperly poisoned byte otherwise. Returns null if the area\n-  // is poisoned properly.\n-  const void *__sanitizer_contiguous_container_find_bad_address(\n-      const void *beg, const void *mid, const void *end);\n-\n-  // Print the stack trace leading to this call. Useful for debugging user code.\n-  void __sanitizer_print_stack_trace(void);\n-\n-  // Symbolizes the supplied 'pc' using the format string 'fmt'.\n-  // Outputs at most 'out_buf_size' bytes into 'out_buf'.\n-  // If 'out_buf' is not empty then output is zero or more non empty C strings\n-  // followed by single empty C string. Multiple strings can be returned if PC\n-  // corresponds to inlined function. Inlined frames are printed in the order\n-  // from \"most-inlined\" to the \"least-inlined\", so the last frame should be the\n-  // not inlined function.\n-  // Inlined frames can be removed with 'symbolize_inline_frames=0'.\n-  // The format syntax is described in\n-  // lib/sanitizer_common/sanitizer_stacktrace_printer.h.\n-  void __sanitizer_symbolize_pc(void *pc, const char *fmt, char *out_buf,\n-                                size_t out_buf_size);\n-  // Same as __sanitizer_symbolize_pc, but for data section (i.e. globals).\n-  void __sanitizer_symbolize_global(void *data_ptr, const char *fmt,\n-                                    char *out_buf, size_t out_buf_size);\n-\n-  // Sets the callback to be called right before death on error.\n-  // Passing 0 will unset the callback.\n-  void __sanitizer_set_death_callback(void (*callback)(void));\n-\n-  // Interceptor hooks.\n-  // Whenever a libc function interceptor is called it checks if the\n-  // corresponding weak hook is defined, and it so -- calls it.\n-  // The primary use case is data-flow-guided fuzzing, where the fuzzer needs\n-  // to know what is being passed to libc functions, e.g. memcmp.\n-  // FIXME: implement more hooks.\n-  void __sanitizer_weak_hook_memcmp(void *called_pc, const void *s1,\n-                                    const void *s2, size_t n, int result);\n-  void __sanitizer_weak_hook_strncmp(void *called_pc, const char *s1,\n-                                    const char *s2, size_t n, int result);\n-  void __sanitizer_weak_hook_strncasecmp(void *called_pc, const char *s1,\n-                                         const char *s2, size_t n, int result);\n-  void __sanitizer_weak_hook_strcmp(void *called_pc, const char *s1,\n-                                    const char *s2, int result);\n-  void __sanitizer_weak_hook_strcasecmp(void *called_pc, const char *s1,\n-                                        const char *s2, int result);\n-  void __sanitizer_weak_hook_strstr(void *called_pc, const char *s1,\n-                                    const char *s2, char *result);\n-  void __sanitizer_weak_hook_strcasestr(void *called_pc, const char *s1,\n-                                        const char *s2, char *result);\n-  void __sanitizer_weak_hook_memmem(void *called_pc,\n-                                    const void *s1, size_t len1,\n-                                    const void *s2, size_t len2, void *result);\n-\n-  // Prints stack traces for all live heap allocations ordered by total\n-  // allocation size until `top_percent` of total live heap is shown.\n-  // `top_percent` should be between 1 and 100.\n-  // At most `max_number_of_contexts` contexts (stack traces) is printed.\n-  // Experimental feature currently available only with asan on Linux/x86_64.\n-  void __sanitizer_print_memory_profile(size_t top_percent,\n-                                        size_t max_number_of_contexts);\n-\n-  // Fiber annotation interface.\n-  // Before switching to a different stack, one must call\n-  // __sanitizer_start_switch_fiber with a pointer to the bottom of the\n-  // destination stack and its size. When code starts running on the new stack,\n-  // it must call __sanitizer_finish_switch_fiber to finalize the switch.\n-  // The start_switch function takes a void** to store the current fake stack if\n-  // there is one (it is needed when detect_stack_use_after_return is enabled).\n-  // When restoring a stack, this pointer must be given to the finish_switch\n-  // function. In most cases, this void* can be stored on the stack just before\n-  // switching.  When leaving a fiber definitely, null must be passed as first\n-  // argument to the start_switch function so that the fake stack is destroyed.\n-  // If you do not want support for stack use-after-return detection, you can\n-  // always pass null to these two functions.\n-  // Note that the fake stack mechanism is disabled during fiber switch, so if a\n-  // signal callback runs during the switch, it will not benefit from the stack\n-  // use-after-return detection.\n-  void __sanitizer_start_switch_fiber(void **fake_stack_save,\n-                                      const void *bottom, size_t size);\n-  void __sanitizer_finish_switch_fiber(void *fake_stack_save,\n-                                       const void **bottom_old,\n-                                       size_t *size_old);\n-\n-  // Get full module name and calculate pc offset within it.\n-  // Returns 1 if pc belongs to some module, 0 if module was not found.\n-  int __sanitizer_get_module_and_offset_for_pc(void *pc, char *module_path,\n-                                               size_t module_path_len,\n-                                               void **pc_offset);\n+// Arguments for __sanitizer_sandbox_on_notify() below.\n+typedef struct {\n+  // Enable sandbox support in sanitizer coverage.\n+  int coverage_sandboxed;\n+  // File descriptor to write coverage data to. If -1 is passed, a file will\n+  // be pre-opened by __sanitizer_sandobx_on_notify(). This field has no\n+  // effect if coverage_sandboxed == 0.\n+  intptr_t coverage_fd;\n+  // If non-zero, split the coverage data into well-formed blocks. This is\n+  // useful when coverage_fd is a socket descriptor. Each block will contain\n+  // a header, allowing data from multiple processes to be sent over the same\n+  // socket.\n+  unsigned int coverage_max_block_size;\n+} __sanitizer_sandbox_arguments;\n+\n+// Tell the tools to write their reports to \"path.<pid>\" instead of stderr.\n+void __sanitizer_set_report_path(const char *path);\n+// Tell the tools to write their reports to the provided file descriptor\n+// (casted to void *).\n+void __sanitizer_set_report_fd(void *fd);\n+\n+// Notify the tools that the sandbox is going to be turned on. The reserved\n+// parameter will be used in the future to hold a structure with functions\n+// that the tools may call to bypass the sandbox.\n+void __sanitizer_sandbox_on_notify(__sanitizer_sandbox_arguments *args);\n+\n+// This function is called by the tool when it has just finished reporting\n+// an error. 'error_summary' is a one-line string that summarizes\n+// the error message. This function can be overridden by the client.\n+void __sanitizer_report_error_summary(const char *error_summary);\n+\n+// Some of the sanitizers (for example ASan/TSan) could miss bugs that happen\n+// in unaligned loads/stores. To find such bugs reliably, you need to replace\n+// plain unaligned loads/stores with these calls.\n+\n+/// Loads a 16-bit unaligned value.\n+///\n+/// \\param p Pointer to unaligned memory.\n+///\n+/// \\returns Loaded value.\n+uint16_t __sanitizer_unaligned_load16(const void *p);\n+\n+/// Loads a 32-bit unaligned value.\n+///\n+/// \\param p Pointer to unaligned memory.\n+///\n+/// \\returns Loaded value.\n+uint32_t __sanitizer_unaligned_load32(const void *p);\n+\n+/// Loads a 64-bit unaligned value.\n+///\n+/// \\param p Pointer to unaligned memory.\n+///\n+/// \\returns Loaded value.\n+uint64_t __sanitizer_unaligned_load64(const void *p);\n+\n+/// Stores a 16-bit unaligned value.\n+///\n+/// \\param p Pointer to unaligned memory.\n+/// \\param x 16-bit value to store.\n+void __sanitizer_unaligned_store16(void *p, uint16_t x);\n+\n+/// Stores a 32-bit unaligned value.\n+///\n+/// \\param p Pointer to unaligned memory.\n+/// \\param x 32-bit value to store.\n+void __sanitizer_unaligned_store32(void *p, uint32_t x);\n+\n+/// Stores a 64-bit unaligned value.\n+///\n+/// \\param p Pointer to unaligned memory.\n+/// \\param x 64-bit value to store.\n+void __sanitizer_unaligned_store64(void *p, uint64_t x);\n+\n+// Returns 1 on the first call, then returns 0 thereafter.  Called by the tool\n+// to ensure only one report is printed when multiple errors occur\n+// simultaneously.\n+int __sanitizer_acquire_crash_state();\n+\n+/// Annotates the current state of a contiguous container, such as\n+/// <c>std::vector</c>, <c>std::string</c>, or similar.\n+///\n+/// A contiguous container is a container that keeps all of its elements\n+/// in a contiguous region of memory. The container owns the region of memory\n+/// <c>[beg, end)</c>; the memory <c>[beg, mid)</c> is used to store the\n+/// current elements, and the memory <c>[mid, end)</c> is reserved for future\n+/// elements (<c>beg <= mid <= end</c>). For example, in\n+/// <c>std::vector<> v</c>:\n+///\n+/// \\code\n+///   beg = &v[0];\n+///   end = beg + v.capacity() * sizeof(v[0]);\n+///   mid = beg + v.size()     * sizeof(v[0]);\n+/// \\endcode\n+///\n+/// This annotation tells the Sanitizer tool about the current state of the\n+/// container so that the tool can report errors when memory from\n+/// <c>[mid, end)</c> is accessed. Insert this annotation into methods like\n+/// <c>push_back()</c> or <c>pop_back()</c>. Supply the old and new values of\n+/// <c>mid</c>(<c><i>old_mid</i></c> and <c><i>new_mid</i></c>). In the initial\n+/// state <c>mid == end</c>, so that should be the final state when the\n+/// container is destroyed or when the container reallocates the storage.\n+///\n+/// For ASan, <c><i>beg</i></c> should be 8-aligned and <c><i>end</i></c>\n+/// should be either 8-aligned or it should point to the end of a separate\n+/// heap-, stack-, or global-allocated buffer. So the following example will\n+/// not work:\n+///\n+/// \\code\n+///   int64_t x[2]; // 16 bytes, 8-aligned\n+///   char *beg = (char *)&x[0];\n+///   char *end = beg + 12; // Not 8-aligned, not the end of the buffer\n+/// \\endcode\n+///\n+/// The following, however, will work:\n+/// \\code\n+///   int32_t x[3]; // 12 bytes, but 8-aligned under ASan.\n+///   char *beg = (char*)&x[0];\n+///   char *end = beg + 12; // Not 8-aligned, but is the end of the buffer\n+/// \\endcode\n+///\n+/// \\note  Use this function with caution and do not use for anything other\n+/// than vector-like classes.\n+///\n+/// \\param beg Beginning of memory region.\n+/// \\param end End of memory region.\n+/// \\param old_mid Old middle of memory region.\n+/// \\param new_mid New middle of memory region.\n+void __sanitizer_annotate_contiguous_container(const void *beg,\n+                                               const void *end,\n+                                               const void *old_mid,\n+                                               const void *new_mid);\n+\n+/// Returns true if the contiguous container <c>[beg, end)</c> is properly\n+/// poisoned.\n+///\n+/// Proper poisoning could occur, for example, with\n+/// <c>__sanitizer_annotate_contiguous_container</c>), that is, if\n+/// <c>[beg, mid)</c> is addressable and <c>[mid, end)</c> is unaddressable.\n+/// Full verification requires O (<c>end - beg</c>) time; this function tries\n+/// to avoid such complexity by touching only parts of the container around\n+/// <c><i>beg</i></c>, <c><i>mid</i></c>, and <c><i>end</i></c>.\n+///\n+/// \\param beg Beginning of memory region.\n+/// \\param mid Middle of memory region.\n+/// \\param end Old end of memory region.\n+///\n+/// \\returns True if the contiguous container <c>[beg, end)</c> is properly\n+///  poisoned.\n+int __sanitizer_verify_contiguous_container(const void *beg, const void *mid,\n+                                            const void *end);\n+\n+/// Similar to <c>__sanitizer_verify_contiguous_container()</c> but also\n+/// returns the address of the first improperly poisoned byte.\n+///\n+/// Returns NULL if the area is poisoned properly.\n+///\n+/// \\param beg Beginning of memory region.\n+/// \\param mid Middle of memory region.\n+/// \\param end Old end of memory region.\n+///\n+/// \\returns The bad address or NULL.\n+const void *__sanitizer_contiguous_container_find_bad_address(const void *beg,\n+                                                              const void *mid,\n+                                                              const void *end);\n+\n+/// Prints the stack trace leading to this call (useful for calling from the\n+/// debugger).\n+void __sanitizer_print_stack_trace(void);\n+\n+// Symbolizes the supplied 'pc' using the format string 'fmt'.\n+// Outputs at most 'out_buf_size' bytes into 'out_buf'.\n+// If 'out_buf' is not empty then output is zero or more non empty C strings\n+// followed by single empty C string. Multiple strings can be returned if PC\n+// corresponds to inlined function. Inlined frames are printed in the order\n+// from \"most-inlined\" to the \"least-inlined\", so the last frame should be the\n+// not inlined function.\n+// Inlined frames can be removed with 'symbolize_inline_frames=0'.\n+// The format syntax is described in\n+// lib/sanitizer_common/sanitizer_stacktrace_printer.h.\n+void __sanitizer_symbolize_pc(void *pc, const char *fmt, char *out_buf,\n+                              size_t out_buf_size);\n+// Same as __sanitizer_symbolize_pc, but for data section (i.e. globals).\n+void __sanitizer_symbolize_global(void *data_ptr, const char *fmt,\n+                                  char *out_buf, size_t out_buf_size);\n+\n+/// Sets the callback to be called immediately before death on error.\n+///\n+/// Passing 0 will unset the callback.\n+///\n+/// \\param callback User-provided callback.\n+void __sanitizer_set_death_callback(void (*callback)(void));\n+\n+\n+// Interceptor hooks.\n+// Whenever a libc function interceptor is called, it checks if the\n+// corresponding weak hook is defined, and calls it if it is indeed defined.\n+// The primary use-case is data-flow-guided fuzzing, where the fuzzer needs\n+// to know what is being passed to libc functions (for example memcmp).\n+// FIXME: implement more hooks.\n+\n+/// Interceptor hook for <c>memcmp()</c>.\n+///\n+/// \\param called_pc PC (program counter) address of the original call.\n+/// \\param s1 Pointer to block of memory.\n+/// \\param s2 Pointer to block of memory.\n+/// \\param n Number of bytes to compare.\n+/// \\param result Value returned by the intercepted function.\n+void __sanitizer_weak_hook_memcmp(void *called_pc, const void *s1,\n+                                  const void *s2, size_t n, int result);\n+\n+/// Interceptor hook for <c>strncmp()</c>.\n+///\n+/// \\param called_pc PC (program counter) address of the original call.\n+/// \\param s1 Pointer to block of memory.\n+/// \\param s2 Pointer to block of memory.\n+/// \\param n Number of bytes to compare.\n+/// \\param result Value returned by the intercepted function.\n+void __sanitizer_weak_hook_strncmp(void *called_pc, const char *s1,\n+                                  const char *s2, size_t n, int result);\n+\n+/// Interceptor hook for <c>strncasecmp()</c>.\n+///\n+/// \\param called_pc PC (program counter) address of the original call.\n+/// \\param s1 Pointer to block of memory.\n+/// \\param s2 Pointer to block of memory.\n+/// \\param n Number of bytes to compare.\n+/// \\param result Value returned by the intercepted function.\n+void __sanitizer_weak_hook_strncasecmp(void *called_pc, const char *s1,\n+                                       const char *s2, size_t n, int result);\n+\n+/// Interceptor hook for <c>strcmp()</c>.\n+///\n+/// \\param called_pc PC (program counter) address of the original call.\n+/// \\param s1 Pointer to block of memory.\n+/// \\param s2 Pointer to block of memory.\n+/// \\param result Value returned by the intercepted function.\n+void __sanitizer_weak_hook_strcmp(void *called_pc, const char *s1,\n+                                  const char *s2, int result);\n+\n+/// Interceptor hook for <c>strcasecmp()</c>.\n+///\n+/// \\param called_pc PC (program counter) address of the original call.\n+/// \\param s1 Pointer to block of memory.\n+/// \\param s2 Pointer to block of memory.\n+/// \\param result Value returned by the intercepted function.\n+void __sanitizer_weak_hook_strcasecmp(void *called_pc, const char *s1,\n+                                      const char *s2, int result);\n+\n+/// Interceptor hook for <c>strstr()</c>.\n+///\n+/// \\param called_pc PC (program counter) address of the original call.\n+/// \\param s1 Pointer to block of memory.\n+/// \\param s2 Pointer to block of memory.\n+/// \\param result Value returned by the intercepted function.\n+void __sanitizer_weak_hook_strstr(void *called_pc, const char *s1,\n+                                  const char *s2, char *result);\n+\n+void __sanitizer_weak_hook_strcasestr(void *called_pc, const char *s1,\n+                                      const char *s2, char *result);\n+\n+void __sanitizer_weak_hook_memmem(void *called_pc,\n+                                  const void *s1, size_t len1,\n+                                  const void *s2, size_t len2, void *result);\n+\n+// Prints stack traces for all live heap allocations ordered by total\n+// allocation size until top_percent of total live heap is shown. top_percent\n+// should be between 1 and 100. At most max_number_of_contexts contexts\n+// (stack traces) are printed.\n+// Experimental feature currently available only with ASan on Linux/x86_64.\n+void __sanitizer_print_memory_profile(size_t top_percent,\n+                                      size_t max_number_of_contexts);\n+\n+/// Notify ASan that a fiber switch has started (required only if implementing\n+/// your own fiber library).\n+///\n+/// Before switching to a different stack, you must call\n+/// <c>__sanitizer_start_switch_fiber()</c> with a pointer to the bottom of the\n+/// destination stack and with its size. When code starts running on the new\n+/// stack, it must call <c>__sanitizer_finish_switch_fiber()</c> to finalize\n+/// the switch. The <c>__sanitizer_start_switch_fiber()</c> function takes a\n+/// <c>void**</c> pointer argument to store the current fake stack if there is\n+/// one (it is necessary when the runtime option\n+/// <c>detect_stack_use_after_return</c> is enabled).\n+///\n+/// When restoring a stack, this <c>void**</c> pointer must be given to the\n+/// <c>__sanitizer_finish_switch_fiber()</c> function. In most cases, this\n+/// pointer can be stored on the stack immediately before switching. When\n+/// leaving a fiber definitely, NULL must be passed as the first argument to\n+/// the <c>__sanitizer_start_switch_fiber()</c> function so that the fake stack\n+/// is destroyed. If your program does not need stack use-after-return\n+/// detection, you can always pass NULL to these two functions.\n+///\n+/// \\note The fake stack mechanism is disabled during fiber switch, so if a\n+/// signal callback runs during the switch, it will not benefit from stack\n+/// use-after-return detection.\n+///\n+/// \\param fake_stack_save [out] Fake stack save location.\n+/// \\param bottom Bottom address of stack.\n+/// \\param size Size of stack in bytes.\n+void __sanitizer_start_switch_fiber(void **fake_stack_save,\n+                                    const void *bottom, size_t size);\n+\n+/// Notify ASan that a fiber switch has completed (required only if\n+/// implementing your own fiber library).\n+///\n+/// When code starts running on the new stack, it must call\n+/// <c>__sanitizer_finish_switch_fiber()</c> to finalize\n+/// the switch. For usage details, see the description of\n+/// <c>__sanitizer_start_switch_fiber()</c>.\n+///\n+/// \\param fake_stack_save Fake stack save location.\n+/// \\param bottom_old [out] Bottom address of old stack.\n+/// \\param size_old [out] Size of old stack in bytes.\n+void __sanitizer_finish_switch_fiber(void *fake_stack_save,\n+                                     const void **bottom_old,\n+                                     size_t *size_old);\n+\n+// Get full module name and calculate pc offset within it.\n+// Returns 1 if pc belongs to some module, 0 if module was not found.\n+int __sanitizer_get_module_and_offset_for_pc(void *pc, char *module_path,\n+                                             size_t module_path_len,\n+                                             void **pc_offset);\n \n #ifdef __cplusplus\n }  // extern \"C\""}, {"sha": "c063cfe60c5ba34e793951bc478da7e5a9932a18", "filename": "libsanitizer/include/sanitizer/coverage_interface.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Fcoverage_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Fcoverage_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcoverage_interface.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer/coverage_interface.h --------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "c189ee55790afb09274c98f2ff02be716001940e", "filename": "libsanitizer/include/sanitizer/dfsan_interface.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fdfsan_interface.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- dfsan_interface.h -------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -78,6 +79,12 @@ dfsan_label dfsan_has_label_with_desc(dfsan_label label, const char *desc);\n /// Returns the number of labels allocated.\n size_t dfsan_get_label_count(void);\n \n+/// Flushes the DFSan shadow, i.e. forgets about all labels currently associated\n+/// with the application memory. Will work only if there are no other\n+/// threads executing DFSan-instrumented code concurrently.\n+/// Use this call to start over the taint tracking within the same procces.\n+void dfsan_flush(void);\n+\n /// Sets a callback to be invoked on calls to write().  The callback is invoked\n /// before the write is done.  The write is not guaranteed to succeed when the\n /// callback executes.  Pass in NULL to remove any callback."}, {"sha": "e22b6a8f4d7bc09f1387c193706d231ce305162e", "filename": "libsanitizer/include/sanitizer/esan_interface.h", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/063082768aab23d26e42954eb115b76318f0176d/libsanitizer%2Finclude%2Fsanitizer%2Fesan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/063082768aab23d26e42954eb115b76318f0176d/libsanitizer%2Finclude%2Fsanitizer%2Fesan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fesan_interface.h?ref=063082768aab23d26e42954eb115b76318f0176d", "patch": "@@ -1,48 +0,0 @@\n-//===-- sanitizer/esan_interface.h ------------------------------*- C++ -*-===//\n-//\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file is a part of EfficiencySanitizer, a family of performance tuners.\n-//\n-// Public interface header.\n-//===----------------------------------------------------------------------===//\n-#ifndef SANITIZER_ESAN_INTERFACE_H\n-#define SANITIZER_ESAN_INTERFACE_H\n-\n-#include <sanitizer/common_interface_defs.h>\n-\n-// We declare our interface routines as weak to allow the user to avoid\n-// ifdefs and instead use this pattern to allow building the same sources\n-// with and without our runtime library:\n-//     if (__esan_report)\n-//       __esan_report();\n-#ifdef _MSC_VER\n-/* selectany is as close to weak as we'll get. */\n-#define COMPILER_RT_WEAK __declspec(selectany)\n-#elif __GNUC__\n-#define COMPILER_RT_WEAK __attribute__((weak))\n-#else\n-#define COMPILER_RT_WEAK\n-#endif\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-// This function can be called mid-run (or at the end of a run for\n-// a server process that doesn't shut down normally) to request that\n-// data for that point in the run be reported from the tool.\n-void COMPILER_RT_WEAK __esan_report(void);\n-\n-// This function returns the number of samples that the esan tool has collected\n-// to this point.  This is useful for testing.\n-unsigned int COMPILER_RT_WEAK __esan_get_sample_count(void);\n-\n-#ifdef __cplusplus\n-} // extern \"C\"\n-#endif\n-\n-#endif // SANITIZER_ESAN_INTERFACE_H"}, {"sha": "4c9ad13aa0cb1a3105aadedbd2c49ee921ebc693", "filename": "libsanitizer/include/sanitizer/hwasan_interface.h", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Fhwasan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Fhwasan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fhwasan_interface.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer/asan_interface.h ------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -17,11 +18,15 @@\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n-  // Initialize shadow but not the rest of the runtime.\n+  // Libc hook for program startup in statically linked executables.\n+  // Initializes enough of the runtime to run instrumented code. This function\n+  // should only be called in statically linked executables because it modifies\n+  // the GOT, which won't work in regular binaries because RELRO will already\n+  // have been applied by the time the function is called. This also means that\n+  // the function should be called before libc applies RELRO.\n   // Does not call libc unless there is an error.\n-  // Can be called multiple times, or not at all (in which case shadow will\n-  // be initialized in compiler-inserted __hwasan_init() call).\n-  void __hwasan_shadow_init(void);\n+  // Can be called multiple times.\n+  void __hwasan_init_static(void);\n \n   // This function may be optionally provided by user and should return\n   // a string containing HWASan runtime options. See asan_flags.h for details.\n@@ -45,6 +50,10 @@ extern \"C\" {\n   // does would cause false reports.\n   void __hwasan_handle_longjmp(const void *sp_dst);\n \n+  // Set memory tag for the part of the current thread stack below sp_dst to\n+  // zero. Call this in vfork() before returning in the parent process.\n+  void __hwasan_handle_vfork(const void *sp_dst);\n+\n   // Libc hook for thread creation. Should be called in the child thread before\n   // any instrumented code.\n   void __hwasan_thread_enter();\n@@ -60,6 +69,10 @@ extern \"C\" {\n   // Print one-line report about the memory usage of the current process.\n   void __hwasan_print_memory_usage();\n \n+  /* Returns the offset of the first byte in the memory range that can not be\n+   * accessed through the pointer in x, or -1 if the whole range is good. */\n+  intptr_t __hwasan_test_shadow(const volatile void *x, size_t size);\n+\n   int __sanitizer_posix_memalign(void **memptr, size_t alignment, size_t size);\n   void * __sanitizer_memalign(size_t alignment, size_t size);\n   void * __sanitizer_aligned_alloc(size_t alignment, size_t size);\n@@ -74,6 +87,7 @@ extern \"C\" {\n   void __sanitizer_malloc_stats(void);\n   void * __sanitizer_calloc(size_t nmemb, size_t size);\n   void * __sanitizer_realloc(void *ptr, size_t size);\n+  void * __sanitizer_reallocarray(void *ptr, size_t nmemb, size_t size);\n   void * __sanitizer_malloc(size_t size);\n #ifdef __cplusplus\n }  // extern \"C\""}, {"sha": "a1794b71af503168a408b79acdf5cfdaae2143cf", "filename": "libsanitizer/include/sanitizer/linux_syscall_hooks.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Flinux_syscall_hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Flinux_syscall_hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Flinux_syscall_hooks.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- linux_syscall_hooks.h ---------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "2bb992672f2e68808deca7ff9238dff9b253e590", "filename": "libsanitizer/include/sanitizer/lsan_interface.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Flsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Flsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Flsan_interface.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer/lsan_interface.h ------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "d40c556a46d93509ec2c58a0af32b008adad217f", "filename": "libsanitizer/include/sanitizer/msan_interface.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fmsan_interface.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- msan_interface.h --------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -41,6 +42,9 @@ extern \"C\" {\n      contents). */\n   void __msan_unpoison_string(const volatile char *a);\n \n+  /* Make first n parameters of the next function call fully initialized. */\n+  void __msan_unpoison_param(size_t n);\n+\n   /* Make memory region fully uninitialized (without changing its contents).\n      This is a legacy interface that does not update origin information. Use\n      __msan_allocated_memory() instead. */"}, {"sha": "27780e0d419f6d324f75119c6770a7f0e970e564", "filename": "libsanitizer/include/sanitizer/netbsd_syscall_hooks.h", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Fnetbsd_syscall_hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Fnetbsd_syscall_hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fnetbsd_syscall_hooks.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- netbsd_syscall_hooks.h --------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -19,8 +20,8 @@\n // DO NOT EDIT! THIS FILE HAS BEEN GENERATED!\n //\n // Generated with: generate_netbsd_syscalls.awk\n-// Generated date: 2018-03-03\n-// Generated from: syscalls.master,v 1.291 2018/01/06 16:41:23 kamil Exp\n+// Generated date: 2018-10-30\n+// Generated from: syscalls.master,v 1.293 2018/07/31 13:00:13 rjs Exp\n //\n //===----------------------------------------------------------------------===//\n #ifndef SANITIZER_NETBSD_SYSCALL_HOOKS_H\n@@ -984,7 +985,15 @@\n #define __sanitizer_syscall_post_fpathconf(res, fd, name)                      \\\n   __sanitizer_syscall_post_impl_fpathconf(res, (long long)(fd),                \\\n                                           (long long)(name))\n-/* syscall 193 has been skipped */\n+#define __sanitizer_syscall_pre_getsockopt2(s, level, name, val, avalsize)     \\\n+  __sanitizer_syscall_pre_impl_getsockopt2(                                    \\\n+      (long long)(s), (long long)(level), (long long)(name), (long long)(val), \\\n+      (long long)(avalsize))\n+#define __sanitizer_syscall_post_getsockopt2(res, s, level, name, val,         \\\n+                                             avalsize)                         \\\n+  __sanitizer_syscall_post_impl_getsockopt2(                                   \\\n+      res, (long long)(s), (long long)(level), (long long)(name),              \\\n+      (long long)(val), (long long)(avalsize))\n #define __sanitizer_syscall_pre_getrlimit(which, rlp)                          \\\n   __sanitizer_syscall_pre_impl_getrlimit((long long)(which), (long long)(rlp))\n #define __sanitizer_syscall_post_getrlimit(res, which, rlp)                    \\\n@@ -1750,18 +1759,8 @@\n   __sanitizer_syscall_post_impl___sigaction_sigtramp(                          \\\n       res, (long long)(signum), (long long)(nsa), (long long)(osa),            \\\n       (long long)(tramp), (long long)(vers))\n-#define __sanitizer_syscall_pre_pmc_get_info(ctr, op, args)                    \\\n-  __sanitizer_syscall_pre_impl_pmc_get_info((long long)(ctr), (long long)(op), \\\n-                                            (long long)(args))\n-#define __sanitizer_syscall_post_pmc_get_info(res, ctr, op, args)              \\\n-  __sanitizer_syscall_post_impl_pmc_get_info(                                  \\\n-      res, (long long)(ctr), (long long)(op), (long long)(args))\n-#define __sanitizer_syscall_pre_pmc_control(ctr, op, args)                     \\\n-  __sanitizer_syscall_pre_impl_pmc_control((long long)(ctr), (long long)(op),  \\\n-                                           (long long)(args))\n-#define __sanitizer_syscall_post_pmc_control(res, ctr, op, args)               \\\n-  __sanitizer_syscall_post_impl_pmc_control(                                   \\\n-      res, (long long)(ctr), (long long)(op), (long long)(args))\n+/* syscall 341 has been skipped */\n+/* syscall 342 has been skipped */\n #define __sanitizer_syscall_pre_rasctl(addr, len, op)                          \\\n   __sanitizer_syscall_pre_impl_rasctl((long long)(addr), (long long)(len),     \\\n                                       (long long)(op))\n@@ -3442,7 +3441,13 @@ void __sanitizer_syscall_post_impl_pathconf(long long res, long long path,\n void __sanitizer_syscall_pre_impl_fpathconf(long long fd, long long name);\n void __sanitizer_syscall_post_impl_fpathconf(long long res, long long fd,\n                                              long long name);\n-/* syscall 193 has been skipped */\n+void __sanitizer_syscall_pre_impl_getsockopt2(long long s, long long level,\n+                                              long long name, long long val,\n+                                              long long avalsize);\n+void __sanitizer_syscall_post_impl_getsockopt2(long long res, long long s,\n+                                               long long level, long long name,\n+                                               long long val,\n+                                               long long avalsize);\n void __sanitizer_syscall_pre_impl_getrlimit(long long which, long long rlp);\n void __sanitizer_syscall_post_impl_getrlimit(long long res, long long which,\n                                              long long rlp);\n@@ -3999,14 +4004,8 @@ void __sanitizer_syscall_pre_impl___sigaction_sigtramp(long long signum,\n void __sanitizer_syscall_post_impl___sigaction_sigtramp(\n     long long res, long long signum, long long nsa, long long osa,\n     long long tramp, long long vers);\n-void __sanitizer_syscall_pre_impl_pmc_get_info(long long ctr, long long op,\n-                                               long long args);\n-void __sanitizer_syscall_post_impl_pmc_get_info(long long res, long long ctr,\n-                                                long long op, long long args);\n-void __sanitizer_syscall_pre_impl_pmc_control(long long ctr, long long op,\n-                                              long long args);\n-void __sanitizer_syscall_post_impl_pmc_control(long long res, long long ctr,\n-                                               long long op, long long args);\n+/* syscall 341 has been skipped */\n+/* syscall 342 has been skipped */\n void __sanitizer_syscall_pre_impl_rasctl(long long addr, long long len,\n                                          long long op);\n void __sanitizer_syscall_post_impl_rasctl(long long res, long long addr,"}, {"sha": "dd522c1efc212b6396fbb67bd37874b2250ba307", "filename": "libsanitizer/include/sanitizer/scudo_interface.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Fscudo_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Fscudo_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fscudo_interface.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer/scudo_interface.h -----------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "011b23350cac39f16d77d9e9d60047a33ae95ddb", "filename": "libsanitizer/include/sanitizer/tsan_interface.h", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- tsan_interface.h ----------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -135,6 +136,24 @@ void __tsan_external_assign_tag(void *addr, void *tag);\n void __tsan_external_read(void *addr, void *caller_pc, void *tag);\n void __tsan_external_write(void *addr, void *caller_pc, void *tag);\n \n+// Fiber switching API.\n+//   - TSAN context for fiber can be created by __tsan_create_fiber\n+//     and freed by __tsan_destroy_fiber.\n+//   - TSAN context of current fiber or thread can be obtained\n+//     by calling __tsan_get_current_fiber.\n+//   - __tsan_switch_to_fiber should be called immediatly before switch\n+//     to fiber, such as call of swapcontext.\n+//   - Fiber name can be set by __tsan_set_fiber_name.\n+void *__tsan_get_current_fiber(void);\n+void *__tsan_create_fiber(unsigned flags);\n+void __tsan_destroy_fiber(void *fiber);\n+void __tsan_switch_to_fiber(void *fiber, unsigned flags);\n+void __tsan_set_fiber_name(void *fiber, const char *name);\n+\n+// Flags for __tsan_switch_to_fiber:\n+// Do not establish a happens-before relation between fibers\n+const unsigned __tsan_switch_to_fiber_no_sync = 1 << 0;\n+\n #ifdef __cplusplus\n }  // extern \"C\"\n #endif"}, {"sha": "9ce0411917df698358fd1936a71556c51123d8f8", "filename": "libsanitizer/include/sanitizer/tsan_interface_atomic.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface_atomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface_atomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Ftsan_interface_atomic.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- tsan_interface_atomic.h ---------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -29,7 +30,7 @@ __extension__ typedef __int128 __tsan_atomic128;\n #endif\n \n // Part of ABI, do not change.\n-// http://llvm.org/viewvc/llvm-project/libcxx/trunk/include/atomic?view=markup\n+// https://github.com/llvm/llvm-project/blob/master/libcxx/include/atomic\n typedef enum {\n   __tsan_memory_order_relaxed,\n   __tsan_memory_order_consume,"}, {"sha": "a22e0b4e2af198f72c85bc37357e2ce099700629", "filename": "libsanitizer/interception/Makefile.am", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finterception%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finterception%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2FMakefile.am?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -13,10 +13,10 @@ ACLOCAL_AMFLAGS = -I m4\n noinst_LTLIBRARIES = libinterception.la\n \n interception_files = \\\n-        interception_linux.cc \\\n-        interception_mac.cc \\\n-        interception_win.cc \\\n-\tinterception_type_test.cc\n+        interception_linux.cpp \\\n+        interception_mac.cpp \\\n+        interception_win.cpp \\\n+\tinterception_type_test.cpp\n \n libinterception_la_SOURCES = $(interception_files)\n "}, {"sha": "5f7f0685a773d4153fc772e46b4ce050dbb2d483", "filename": "libsanitizer/interception/Makefile.in", "status": "modified", "additions": 48, "deletions": 32, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finterception%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finterception%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2FMakefile.in?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,7 @@\n-# Makefile.in generated by automake 1.15.1 from Makefile.am.\n+# Makefile.in generated by automake 1.16.1 from Makefile.am.\n # @configure_input@\n \n-# Copyright (C) 1994-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1994-2018 Free Software Foundation, Inc.\n \n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -134,7 +134,11 @@ am__v_at_0 = @\n am__v_at_1 = \n DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)\n depcomp = $(SHELL) $(top_srcdir)/../depcomp\n-am__depfiles_maybe = depfiles\n+am__maybe_remake_depfiles = depfiles\n+am__depfiles_remade = ./$(DEPDIR)/interception_linux.Plo \\\n+\t./$(DEPDIR)/interception_mac.Plo \\\n+\t./$(DEPDIR)/interception_type_test.Plo \\\n+\t./$(DEPDIR)/interception_win.Plo\n am__mv = mv -f\n CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n \t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n@@ -340,10 +344,10 @@ AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic \\\n ACLOCAL_AMFLAGS = -I m4\n noinst_LTLIBRARIES = libinterception.la\n interception_files = \\\n-        interception_linux.cc \\\n-        interception_mac.cc \\\n-        interception_win.cc \\\n-\tinterception_type_test.cc\n+        interception_linux.cpp \\\n+        interception_mac.cpp \\\n+        interception_win.cpp \\\n+\tinterception_type_test.cpp\n \n libinterception_la_SOURCES = $(interception_files)\n \n@@ -389,7 +393,7 @@ MAKEOVERRIDES =\n all: all-am\n \n .SUFFIXES:\n-.SUFFIXES: .cc .lo .o .obj\n+.SUFFIXES: .cpp .lo .o .obj\n $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n \t@for dep in $?; do \\\n \t  case '$(am__configure_deps)' in \\\n@@ -407,8 +411,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n \t  *config.status*) \\\n \t    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \\\n \t  *) \\\n-\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \\\n-\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \\\n \tesac;\n \n $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n@@ -440,26 +444,32 @@ mostlyclean-compile:\n distclean-compile:\n \t-rm -f *.tab.c\n \n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interception_linux.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interception_mac.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interception_type_test.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interception_win.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interception_linux.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interception_mac.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interception_type_test.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interception_win.Plo@am__quote@ # am--include-marker\n \n-.cc.o:\n+$(am__depfiles_remade):\n+\t@$(MKDIR_P) $(@D)\n+\t@echo '# dummy' >$@-t && $(am__mv) $@-t $@\n+\n+am--depfiles: $(am__depfiles_remade)\n+\n+.cpp.o:\n @am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n @am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ $<\n \n-.cc.obj:\n+.cpp.obj:\n @am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n @am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n \n-.cc.lo:\n+.cpp.lo:\n @am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n @am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n@@ -563,7 +573,10 @@ clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \\\n \tmostlyclean-am\n \n distclean: distclean-am\n-\t-rm -rf ./$(DEPDIR)\n+\t\t-rm -f ./$(DEPDIR)/interception_linux.Plo\n+\t-rm -f ./$(DEPDIR)/interception_mac.Plo\n+\t-rm -f ./$(DEPDIR)/interception_type_test.Plo\n+\t-rm -f ./$(DEPDIR)/interception_win.Plo\n \t-rm -f Makefile\n distclean-am: clean-am distclean-compile distclean-generic \\\n \tdistclean-tags\n@@ -609,7 +622,10 @@ install-ps-am:\n installcheck-am:\n \n maintainer-clean: maintainer-clean-am\n-\t-rm -rf ./$(DEPDIR)\n+\t\t-rm -f ./$(DEPDIR)/interception_linux.Plo\n+\t-rm -f ./$(DEPDIR)/interception_mac.Plo\n+\t-rm -f ./$(DEPDIR)/interception_type_test.Plo\n+\t-rm -f ./$(DEPDIR)/interception_win.Plo\n \t-rm -f Makefile\n maintainer-clean-am: distclean-am maintainer-clean-generic\n \n@@ -630,19 +646,19 @@ uninstall-am:\n \n .MAKE: install-am install-strip\n \n-.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \\\n-\tclean-libtool clean-noinstLTLIBRARIES cscopelist-am ctags \\\n-\tctags-am distclean distclean-compile distclean-generic \\\n-\tdistclean-libtool distclean-tags dvi dvi-am html html-am info \\\n-\tinfo-am install install-am install-data install-data-am \\\n-\tinstall-dvi install-dvi-am install-exec install-exec-am \\\n-\tinstall-html install-html-am install-info install-info-am \\\n-\tinstall-man install-pdf install-pdf-am install-ps \\\n-\tinstall-ps-am install-strip installcheck installcheck-am \\\n-\tinstalldirs maintainer-clean maintainer-clean-generic \\\n-\tmostlyclean mostlyclean-compile mostlyclean-generic \\\n-\tmostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \\\n-\tuninstall-am\n+.PHONY: CTAGS GTAGS TAGS all all-am am--depfiles check check-am clean \\\n+\tclean-generic clean-libtool clean-noinstLTLIBRARIES \\\n+\tcscopelist-am ctags ctags-am distclean distclean-compile \\\n+\tdistclean-generic distclean-libtool distclean-tags dvi dvi-am \\\n+\thtml html-am info info-am install install-am install-data \\\n+\tinstall-data-am install-dvi install-dvi-am install-exec \\\n+\tinstall-exec-am install-html install-html-am install-info \\\n+\tinstall-info-am install-man install-pdf install-pdf-am \\\n+\tinstall-ps install-ps-am install-strip installcheck \\\n+\tinstallcheck-am installdirs maintainer-clean \\\n+\tmaintainer-clean-generic mostlyclean mostlyclean-compile \\\n+\tmostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \\\n+\ttags tags-am uninstall uninstall-am\n \n .PRECIOUS: Makefile\n "}, {"sha": "dacfa5ede28df3f81d64e28f646699cdc351084c", "filename": "libsanitizer/interception/interception.h", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finterception%2Finterception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finterception%2Finterception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- interception.h ------------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -184,11 +185,17 @@ const interpose_substitution substitution_##func_name[] \\\n #endif  // SANITIZER_MAC\n \n #if !SANITIZER_FUCHSIA && !SANITIZER_RTEMS\n-#define DECLARE_REAL_AND_INTERCEPTOR(ret_type, func, ...) \\\n+# define DECLARE_REAL_AND_INTERCEPTOR(ret_type, func, ...) \\\n   DECLARE_REAL(ret_type, func, __VA_ARGS__) \\\n   extern \"C\" ret_type WRAP(func)(__VA_ARGS__);\n+// Declare an interceptor and its wrapper defined in a different translation\n+// unit (ex. asm).\n+# define DECLARE_EXTERN_INTERCEPTOR_AND_WRAPPER(ret_type, func, ...)    \\\n+  extern \"C\" ret_type WRAP(func)(__VA_ARGS__); \\\n+  extern \"C\" ret_type func(__VA_ARGS__);\n #else\n-#define DECLARE_REAL_AND_INTERCEPTOR(ret_type, func, ...)\n+# define DECLARE_REAL_AND_INTERCEPTOR(ret_type, func, ...)\n+# define DECLARE_EXTERN_INTERCEPTOR_AND_WRAPPER(ret_type, func, ...)\n #endif\n \n // Generally, you don't need to use DEFINE_REAL by itself, as INTERCEPTOR"}, {"sha": "781b77e46fd1a751928cd7cc9dbeec7d76a29008", "filename": "libsanitizer/interception/interception_linux.cc", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/063082768aab23d26e42954eb115b76318f0176d/libsanitizer%2Finterception%2Finterception_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/063082768aab23d26e42954eb115b76318f0176d/libsanitizer%2Finterception%2Finterception_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_linux.cc?ref=063082768aab23d26e42954eb115b76318f0176d", "patch": "@@ -1,53 +0,0 @@\n-//===-- interception_linux.cc -----------------------------------*- C++ -*-===//\n-//\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file is a part of AddressSanitizer, an address sanity checker.\n-//\n-// Linux-specific interception methods.\n-//===----------------------------------------------------------------------===//\n-\n-#include \"interception.h\"\n-\n-#if SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_NETBSD || \\\n-    SANITIZER_OPENBSD || SANITIZER_SOLARIS\n-\n-#include <dlfcn.h>   // for dlsym() and dlvsym()\n-\n-#if SANITIZER_NETBSD\n-#include \"sanitizer_common/sanitizer_libc.h\"\n-#endif\n-\n-namespace __interception {\n-bool GetRealFunctionAddress(const char *func_name, uptr *func_addr,\n-    uptr real, uptr wrapper) {\n-#if SANITIZER_NETBSD\n-  // XXX: Find a better way to handle renames\n-  if (internal_strcmp(func_name, \"sigaction\") == 0) func_name = \"__sigaction14\";\n-#endif\n-  *func_addr = (uptr)dlsym(RTLD_NEXT, func_name);\n-  if (!*func_addr) {\n-    // If the lookup using RTLD_NEXT failed, the sanitizer runtime library is\n-    // later in the library search order than the DSO that we are trying to\n-    // intercept, which means that we cannot intercept this function. We still\n-    // want the address of the real definition, though, so look it up using\n-    // RTLD_DEFAULT.\n-    *func_addr = (uptr)dlsym(RTLD_DEFAULT, func_name);\n-  }\n-  return real == wrapper;\n-}\n-\n-// Android and Solaris do not have dlvsym\n-#if !SANITIZER_ANDROID && !SANITIZER_SOLARIS && !SANITIZER_OPENBSD\n-void *GetFuncAddrVer(const char *func_name, const char *ver) {\n-  return dlvsym(RTLD_NEXT, func_name, ver);\n-}\n-#endif  // !SANITIZER_ANDROID\n-\n-}  // namespace __interception\n-\n-#endif  // SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_NETBSD ||\n-        // SANITIZER_OPENBSD || SANITIZER_SOLARIS"}, {"sha": "950cd5126538bea0c035697a7e23dceb5595e9a6", "filename": "libsanitizer/interception/interception_linux.cpp", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finterception%2Finterception_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finterception%2Finterception_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_linux.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -0,0 +1,83 @@\n+//===-- interception_linux.cpp ----------------------------------*- C++ -*-===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Linux-specific interception methods.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"interception.h\"\n+\n+#if SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_NETBSD || \\\n+    SANITIZER_OPENBSD || SANITIZER_SOLARIS\n+\n+#include <dlfcn.h>   // for dlsym() and dlvsym()\n+\n+namespace __interception {\n+\n+#if SANITIZER_NETBSD\n+static int StrCmp(const char *s1, const char *s2) {\n+  while (true) {\n+    if (*s1 != *s2)\n+      return false;\n+    if (*s1 == 0)\n+      return true;\n+    s1++;\n+    s2++;\n+  }\n+}\n+#endif\n+\n+static void *GetFuncAddr(const char *name, uptr wrapper_addr) {\n+#if SANITIZER_NETBSD\n+  // FIXME: Find a better way to handle renames\n+  if (StrCmp(name, \"sigaction\"))\n+    name = \"__sigaction14\";\n+#endif\n+  void *addr = dlsym(RTLD_NEXT, name);\n+  if (!addr) {\n+    // If the lookup using RTLD_NEXT failed, the sanitizer runtime library is\n+    // later in the library search order than the DSO that we are trying to\n+    // intercept, which means that we cannot intercept this function. We still\n+    // want the address of the real definition, though, so look it up using\n+    // RTLD_DEFAULT.\n+    addr = dlsym(RTLD_DEFAULT, name);\n+\n+    // In case `name' is not loaded, dlsym ends up finding the actual wrapper.\n+    // We don't want to intercept the wrapper and have it point to itself.\n+    if ((uptr)addr == wrapper_addr)\n+      addr = nullptr;\n+  }\n+  return addr;\n+}\n+\n+bool InterceptFunction(const char *name, uptr *ptr_to_real, uptr func,\n+                       uptr wrapper) {\n+  void *addr = GetFuncAddr(name, wrapper);\n+  *ptr_to_real = (uptr)addr;\n+  return addr && (func == wrapper);\n+}\n+\n+// Android and Solaris do not have dlvsym\n+#if !SANITIZER_ANDROID && !SANITIZER_SOLARIS && !SANITIZER_OPENBSD\n+static void *GetFuncAddr(const char *name, const char *ver) {\n+  return dlvsym(RTLD_NEXT, name, ver);\n+}\n+\n+bool InterceptFunction(const char *name, const char *ver, uptr *ptr_to_real,\n+                       uptr func, uptr wrapper) {\n+  void *addr = GetFuncAddr(name, ver);\n+  *ptr_to_real = (uptr)addr;\n+  return addr && (func == wrapper);\n+}\n+#endif  // !SANITIZER_ANDROID\n+\n+}  // namespace __interception\n+\n+#endif  // SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_NETBSD ||\n+        // SANITIZER_OPENBSD || SANITIZER_SOLARIS"}, {"sha": "e578da0cf64eecaa534949fedb7ee34452b54552", "filename": "libsanitizer/interception/interception_linux.h", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finterception%2Finterception_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finterception%2Finterception_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_linux.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- interception_linux.h ------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -21,23 +22,27 @@\n #define INTERCEPTION_LINUX_H\n \n namespace __interception {\n-// returns true if a function with the given name was found.\n-bool GetRealFunctionAddress(const char *func_name, uptr *func_addr,\n-    uptr real, uptr wrapper);\n-void *GetFuncAddrVer(const char *func_name, const char *ver);\n+bool InterceptFunction(const char *name, uptr *ptr_to_real, uptr func,\n+                       uptr wrapper);\n+bool InterceptFunction(const char *name, const char *ver, uptr *ptr_to_real,\n+                       uptr func, uptr wrapper);\n }  // namespace __interception\n \n-#define INTERCEPT_FUNCTION_LINUX_OR_FREEBSD(func)                          \\\n-  ::__interception::GetRealFunctionAddress(                                \\\n-      #func, (::__interception::uptr *)&__interception::PTR_TO_REAL(func), \\\n-      (::__interception::uptr) & (func),                                   \\\n+#define INTERCEPT_FUNCTION_LINUX_OR_FREEBSD(func) \\\n+  ::__interception::InterceptFunction(            \\\n+      #func,                                      \\\n+      (::__interception::uptr *) & REAL(func),    \\\n+      (::__interception::uptr) & (func),          \\\n       (::__interception::uptr) & WRAP(func))\n \n // Android,  Solaris and OpenBSD do not have dlvsym\n #if !SANITIZER_ANDROID && !SANITIZER_SOLARIS && !SANITIZER_OPENBSD\n #define INTERCEPT_FUNCTION_VER_LINUX_OR_FREEBSD(func, symver) \\\n-  (::__interception::real_##func = (func##_type)(                \\\n-       unsigned long)::__interception::GetFuncAddrVer(#func, symver))\n+  ::__interception::InterceptFunction(                        \\\n+      #func, symver,                                          \\\n+      (::__interception::uptr *) & REAL(func),                \\\n+      (::__interception::uptr) & (func),                      \\\n+      (::__interception::uptr) & WRAP(func))\n #else\n #define INTERCEPT_FUNCTION_VER_LINUX_OR_FREEBSD(func, symver) \\\n   INTERCEPT_FUNCTION_LINUX_OR_FREEBSD(func)"}, {"sha": "fb6eadcff597e0c8621ffe380ee693a2ff6c14e0", "filename": "libsanitizer/interception/interception_mac.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finterception%2Finterception_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finterception%2Finterception_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_mac.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- interception_mac.cc -------------------------------------*- C++ -*-===//\n+//===-- interception_mac.cpp ------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/interception/interception_mac.cc"}, {"sha": "eddedb8959c459c5e3ec909b2871977dc9642f8f", "filename": "libsanitizer/interception/interception_mac.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finterception%2Finterception_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finterception%2Finterception_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_mac.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- interception_mac.h --------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "a611604a700cf7f383b3a5f79f3aebc1bafd041b", "filename": "libsanitizer/interception/interception_type_test.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finterception%2Finterception_type_test.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finterception%2Finterception_type_test.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_type_test.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- interception_type_test.cc -------------------------------*- C++ -*-===//\n+//===-- interception_type_test.cpp ------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/interception/interception_type_test.cc"}, {"sha": "b94e214fdff80d3dcae7b1a124931fb621ce0f1c", "filename": "libsanitizer/interception/interception_win.cpp", "status": "renamed", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finterception%2Finterception_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finterception%2Finterception_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_win.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- interception_linux.cc -----------------------------------*- C++ -*-===//\n+//===-- interception_linux.cpp ----------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -511,17 +512,20 @@ static size_t GetInstructionSize(uptr address, size_t* rel_offset = nullptr) {\n     case 0xc0854d:    // 4d 85 c0 : test r8, r8\n     case 0xc2b60f:    // 0f b6 c2 : movzx eax, dl\n     case 0xc03345:    // 45 33 c0 : xor r8d, r8d\n+    case 0xc93345:    // 45 33 c9 : xor r9d, r9d\n     case 0xdb3345:    // 45 33 DB : xor r11d, r11d\n     case 0xd98b4c:    // 4c 8b d9 : mov r11, rcx\n     case 0xd28b4c:    // 4c 8b d2 : mov r10, rdx\n     case 0xc98b4c:    // 4C 8B C9 : mov r9, rcx\n+    case 0xc18b4c:    // 4C 8B C1 : mov r8, rcx\n     case 0xd2b60f:    // 0f b6 d2 : movzx edx, dl\n     case 0xca2b48:    // 48 2b ca : sub rcx, rdx\n     case 0x10b70f:    // 0f b7 10 : movzx edx, WORD PTR [rax]\n     case 0xc00b4d:    // 3d 0b c0 : or r8, r8\n     case 0xd18b48:    // 48 8b d1 : mov rdx, rcx\n     case 0xdc8b4c:    // 4c 8b dc : mov r11, rsp\n     case 0xd18b4c:    // 4c 8b d1 : mov r10, rcx\n+    case 0xE0E483:    // 83 E4 E0 : and esp, 0xFFFFFFE0\n       return 3;\n \n     case 0xec8348:    // 48 83 ec XX : sub rsp, XX\n@@ -553,6 +557,9 @@ static size_t GetInstructionSize(uptr address, size_t* rel_offset = nullptr) {\n     case 0x245c8948:  // 48 89 5c 24 XX : mov QWORD PTR [rsp + XX], rbx\n     case 0x24748948:  // 48 89 74 24 XX : mov QWORD PTR [rsp + XX], rsi\n     case 0x244C8948:  // 48 89 4C 24 XX : mov QWORD PTR [rsp + XX], rcx\n+    case 0x24548948:  // 48 89 54 24 XX : mov QWORD PTR [rsp + XX], rdx\n+    case 0x244c894c:  // 4c 89 4c 24 XX : mov QWORD PTR [rsp + XX], r9\n+    case 0x2444894c:  // 4c 89 44 24 XX : mov QWORD PTR [rsp + XX], r8\n       return 5;\n     case 0x24648348:  // 48 83 64 24 XX : and QWORD PTR [rsp + XX], YY\n       return 6;", "previous_filename": "libsanitizer/interception/interception_win.cc"}, {"sha": "4590013019e375a41817fc088a06463012d34b3b", "filename": "libsanitizer/interception/interception_win.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finterception%2Finterception_win.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Finterception%2Finterception_win.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_win.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- interception_linux.h ------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "36d4638a9b107dd671b466e7bd78ca44ec00ddb7", "filename": "libsanitizer/libbacktrace/Makefile.in", "status": "modified", "additions": 73, "deletions": 34, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flibbacktrace%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flibbacktrace%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flibbacktrace%2FMakefile.in?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,7 @@\n-# Makefile.in generated by automake 1.15.1 from Makefile.am.\n+# Makefile.in generated by automake 1.16.1 from Makefile.am.\n # @configure_input@\n \n-# Copyright (C) 1994-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1994-2018 Free Software Foundation, Inc.\n \n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -165,7 +165,14 @@ am__v_at_0 = @\n am__v_at_1 = \n DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)\n depcomp = $(SHELL) $(top_srcdir)/../depcomp\n-am__depfiles_maybe = depfiles\n+am__maybe_remake_depfiles = depfiles\n+am__depfiles_remade = ./$(DEPDIR)/alloc.Plo ./$(DEPDIR)/atomic.Plo \\\n+\t./$(DEPDIR)/bridge.Plo ./$(DEPDIR)/cp-demangle.Plo \\\n+\t./$(DEPDIR)/dwarf.Plo ./$(DEPDIR)/elf.Plo \\\n+\t./$(DEPDIR)/fileline.Plo ./$(DEPDIR)/mmap.Plo \\\n+\t./$(DEPDIR)/mmapio.Plo ./$(DEPDIR)/posix.Plo \\\n+\t./$(DEPDIR)/read.Plo ./$(DEPDIR)/sort.Plo \\\n+\t./$(DEPDIR)/state.Plo ./$(DEPDIR)/unknown.Plo\n am__mv = mv -f\n COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n \t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n@@ -447,8 +454,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n \t  *config.status*) \\\n \t    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \\\n \t  *) \\\n-\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \\\n-\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \\\n \tesac;\n \n $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n@@ -482,20 +489,26 @@ mostlyclean-compile:\n distclean-compile:\n \t-rm -f *.tab.c\n \n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/alloc.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/atomic.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bridge.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cp-demangle.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dwarf.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fileline.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mmap.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mmapio.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/posix.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/read.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sort.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/state.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unknown.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/alloc.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/atomic.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bridge.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cp-demangle.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dwarf.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fileline.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mmap.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mmapio.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/posix.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/read.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sort.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/state.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/unknown.Plo@am__quote@ # am--include-marker\n+\n+$(am__depfiles_remade):\n+\t@$(MKDIR_P) $(@D)\n+\t@echo '# dummy' >$@-t && $(am__mv) $@-t $@\n+\n+am--depfiles: $(am__depfiles_remade)\n \n .c.o:\n @am__fastdepCC_TRUE@\t$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n@@ -727,7 +740,20 @@ clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \\\n \tmostlyclean-am\n \n distclean: distclean-am\n-\t-rm -rf ./$(DEPDIR)\n+\t\t-rm -f ./$(DEPDIR)/alloc.Plo\n+\t-rm -f ./$(DEPDIR)/atomic.Plo\n+\t-rm -f ./$(DEPDIR)/bridge.Plo\n+\t-rm -f ./$(DEPDIR)/cp-demangle.Plo\n+\t-rm -f ./$(DEPDIR)/dwarf.Plo\n+\t-rm -f ./$(DEPDIR)/elf.Plo\n+\t-rm -f ./$(DEPDIR)/fileline.Plo\n+\t-rm -f ./$(DEPDIR)/mmap.Plo\n+\t-rm -f ./$(DEPDIR)/mmapio.Plo\n+\t-rm -f ./$(DEPDIR)/posix.Plo\n+\t-rm -f ./$(DEPDIR)/read.Plo\n+\t-rm -f ./$(DEPDIR)/sort.Plo\n+\t-rm -f ./$(DEPDIR)/state.Plo\n+\t-rm -f ./$(DEPDIR)/unknown.Plo\n \t-rm -f Makefile\n distclean-am: clean-am distclean-compile distclean-generic \\\n \tdistclean-tags\n@@ -773,7 +799,20 @@ install-ps-am:\n installcheck-am:\n \n maintainer-clean: maintainer-clean-am\n-\t-rm -rf ./$(DEPDIR)\n+\t\t-rm -f ./$(DEPDIR)/alloc.Plo\n+\t-rm -f ./$(DEPDIR)/atomic.Plo\n+\t-rm -f ./$(DEPDIR)/bridge.Plo\n+\t-rm -f ./$(DEPDIR)/cp-demangle.Plo\n+\t-rm -f ./$(DEPDIR)/dwarf.Plo\n+\t-rm -f ./$(DEPDIR)/elf.Plo\n+\t-rm -f ./$(DEPDIR)/fileline.Plo\n+\t-rm -f ./$(DEPDIR)/mmap.Plo\n+\t-rm -f ./$(DEPDIR)/mmapio.Plo\n+\t-rm -f ./$(DEPDIR)/posix.Plo\n+\t-rm -f ./$(DEPDIR)/read.Plo\n+\t-rm -f ./$(DEPDIR)/sort.Plo\n+\t-rm -f ./$(DEPDIR)/state.Plo\n+\t-rm -f ./$(DEPDIR)/unknown.Plo\n \t-rm -f Makefile\n maintainer-clean-am: distclean-am maintainer-clean-generic\n \n@@ -794,19 +833,19 @@ uninstall-am:\n \n .MAKE: install-am install-strip\n \n-.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \\\n-\tclean-libtool clean-noinstLTLIBRARIES cscopelist-am ctags \\\n-\tctags-am distclean distclean-compile distclean-generic \\\n-\tdistclean-libtool distclean-tags dvi dvi-am html html-am info \\\n-\tinfo-am install install-am install-data install-data-am \\\n-\tinstall-dvi install-dvi-am install-exec install-exec-am \\\n-\tinstall-html install-html-am install-info install-info-am \\\n-\tinstall-man install-pdf install-pdf-am install-ps \\\n-\tinstall-ps-am install-strip installcheck installcheck-am \\\n-\tinstalldirs maintainer-clean maintainer-clean-generic \\\n-\tmostlyclean mostlyclean-compile mostlyclean-generic \\\n-\tmostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \\\n-\tuninstall-am\n+.PHONY: CTAGS GTAGS TAGS all all-am am--depfiles check check-am clean \\\n+\tclean-generic clean-libtool clean-noinstLTLIBRARIES \\\n+\tcscopelist-am ctags ctags-am distclean distclean-compile \\\n+\tdistclean-generic distclean-libtool distclean-tags dvi dvi-am \\\n+\thtml html-am info info-am install install-am install-data \\\n+\tinstall-data-am install-dvi install-dvi-am install-exec \\\n+\tinstall-exec-am install-html install-html-am install-info \\\n+\tinstall-info-am install-man install-pdf install-pdf-am \\\n+\tinstall-ps install-ps-am install-strip installcheck \\\n+\tinstallcheck-am installdirs maintainer-clean \\\n+\tmaintainer-clean-generic mostlyclean mostlyclean-compile \\\n+\tmostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \\\n+\ttags tags-am uninstall uninstall-am\n \n .PRECIOUS: Makefile\n "}, {"sha": "62ea17dccec2242bc3a81ee3207dd6bec28d56fc", "filename": "libsanitizer/lsan/Makefile.am", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2FMakefile.am?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -17,19 +17,19 @@ nodist_toolexeclib_HEADERS = liblsan_preinit.o\n endif\n \n sanitizer_lsan_files = \\\n-\tlsan_common.cc \\\n-\tlsan_common_linux.cc \\\n-\tlsan_common_mac.cc\n+\tlsan_common.cpp \\\n+\tlsan_common_linux.cpp \\\n+\tlsan_common_mac.cpp\n \n lsan_files = \\\n \t$(sanitizer_lsan_files) \\\n-\tlsan.cc \\\n-\tlsan_linux.cc \\\n-\tlsan_mac.cc \\\n-\tlsan_malloc_mac.cc \\\n-\tlsan_allocator.cc \\\n-\tlsan_interceptors.cc \\\n-\tlsan_thread.cc\n+\tlsan.cpp \\\n+\tlsan_linux.cpp \\\n+\tlsan_mac.cpp \\\n+\tlsan_malloc_mac.cpp \\\n+\tlsan_allocator.cpp \\\n+\tlsan_interceptors.cpp \\\n+\tlsan_thread.cpp\n \n libsanitizer_lsan_la_SOURCES = $(sanitizer_lsan_files)\n "}, {"sha": "e40913e0e9fc1355984145f2b824b325f877c7a4", "filename": "libsanitizer/lsan/Makefile.in", "status": "modified", "additions": 65, "deletions": 34, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2FMakefile.in?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,7 @@\n-# Makefile.in generated by automake 1.15.1 from Makefile.am.\n+# Makefile.in generated by automake 1.16.1 from Makefile.am.\n # @configure_input@\n \n-# Copyright (C) 1994-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1994-2018 Free Software Foundation, Inc.\n \n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -178,7 +178,14 @@ am__v_at_0 = @\n am__v_at_1 = \n DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)\n depcomp = $(SHELL) $(top_srcdir)/../depcomp\n-am__depfiles_maybe = depfiles\n+am__maybe_remake_depfiles = depfiles\n+am__depfiles_remade = ./$(DEPDIR)/lsan.Plo \\\n+\t./$(DEPDIR)/lsan_allocator.Plo ./$(DEPDIR)/lsan_common.Plo \\\n+\t./$(DEPDIR)/lsan_common_linux.Plo \\\n+\t./$(DEPDIR)/lsan_common_mac.Plo \\\n+\t./$(DEPDIR)/lsan_interceptors.Plo ./$(DEPDIR)/lsan_linux.Plo \\\n+\t./$(DEPDIR)/lsan_mac.Plo ./$(DEPDIR)/lsan_malloc_mac.Plo \\\n+\t./$(DEPDIR)/lsan_thread.Plo\n am__mv = mv -f\n CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n \t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n@@ -387,19 +394,19 @@ noinst_LTLIBRARIES = libsanitizer_lsan.la\n @LSAN_SUPPORTED_TRUE@toolexeclib_LTLIBRARIES = liblsan.la\n @LSAN_SUPPORTED_TRUE@nodist_toolexeclib_HEADERS = liblsan_preinit.o\n sanitizer_lsan_files = \\\n-\tlsan_common.cc \\\n-\tlsan_common_linux.cc \\\n-\tlsan_common_mac.cc\n+\tlsan_common.cpp \\\n+\tlsan_common_linux.cpp \\\n+\tlsan_common_mac.cpp\n \n lsan_files = \\\n \t$(sanitizer_lsan_files) \\\n-\tlsan.cc \\\n-\tlsan_linux.cc \\\n-\tlsan_mac.cc \\\n-\tlsan_malloc_mac.cc \\\n-\tlsan_allocator.cc \\\n-\tlsan_interceptors.cc \\\n-\tlsan_thread.cc\n+\tlsan.cpp \\\n+\tlsan_linux.cpp \\\n+\tlsan_mac.cpp \\\n+\tlsan_malloc_mac.cpp \\\n+\tlsan_allocator.cpp \\\n+\tlsan_interceptors.cpp \\\n+\tlsan_thread.cpp\n \n libsanitizer_lsan_la_SOURCES = $(sanitizer_lsan_files)\n liblsan_la_SOURCES = $(lsan_files)\n@@ -451,7 +458,7 @@ MAKEOVERRIDES =\n all: all-am\n \n .SUFFIXES:\n-.SUFFIXES: .cc .lo .o .obj\n+.SUFFIXES: .cpp .lo .o .obj\n $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n \t@for dep in $?; do \\\n \t  case '$(am__configure_deps)' in \\\n@@ -469,8 +476,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n \t  *config.status*) \\\n \t    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \\\n \t  *) \\\n-\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \\\n-\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \\\n \tesac;\n \n $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n@@ -540,32 +547,38 @@ mostlyclean-compile:\n distclean-compile:\n \t-rm -f *.tab.c\n \n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_allocator.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_common.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_common_linux.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_common_mac.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_interceptors.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_linux.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_mac.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_malloc_mac.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_thread.Plo@am__quote@\n-\n-.cc.o:\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_allocator.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_common.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_common_linux.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_common_mac.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_interceptors.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_linux.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_mac.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_malloc_mac.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_thread.Plo@am__quote@ # am--include-marker\n+\n+$(am__depfiles_remade):\n+\t@$(MKDIR_P) $(@D)\n+\t@echo '# dummy' >$@-t && $(am__mv) $@-t $@\n+\n+am--depfiles: $(am__depfiles_remade)\n+\n+.cpp.o:\n @am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n @am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ $<\n \n-.cc.obj:\n+.cpp.obj:\n @am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n @am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n \n-.cc.lo:\n+.cpp.lo:\n @am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n @am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n@@ -693,7 +706,16 @@ clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \\\n \tclean-toolexeclibLTLIBRARIES mostlyclean-am\n \n distclean: distclean-am\n-\t-rm -rf ./$(DEPDIR)\n+\t\t-rm -f ./$(DEPDIR)/lsan.Plo\n+\t-rm -f ./$(DEPDIR)/lsan_allocator.Plo\n+\t-rm -f ./$(DEPDIR)/lsan_common.Plo\n+\t-rm -f ./$(DEPDIR)/lsan_common_linux.Plo\n+\t-rm -f ./$(DEPDIR)/lsan_common_mac.Plo\n+\t-rm -f ./$(DEPDIR)/lsan_interceptors.Plo\n+\t-rm -f ./$(DEPDIR)/lsan_linux.Plo\n+\t-rm -f ./$(DEPDIR)/lsan_mac.Plo\n+\t-rm -f ./$(DEPDIR)/lsan_malloc_mac.Plo\n+\t-rm -f ./$(DEPDIR)/lsan_thread.Plo\n \t-rm -f Makefile\n distclean-am: clean-am distclean-compile distclean-generic \\\n \tdistclean-tags\n@@ -740,7 +762,16 @@ install-ps-am:\n installcheck-am:\n \n maintainer-clean: maintainer-clean-am\n-\t-rm -rf ./$(DEPDIR)\n+\t\t-rm -f ./$(DEPDIR)/lsan.Plo\n+\t-rm -f ./$(DEPDIR)/lsan_allocator.Plo\n+\t-rm -f ./$(DEPDIR)/lsan_common.Plo\n+\t-rm -f ./$(DEPDIR)/lsan_common_linux.Plo\n+\t-rm -f ./$(DEPDIR)/lsan_common_mac.Plo\n+\t-rm -f ./$(DEPDIR)/lsan_interceptors.Plo\n+\t-rm -f ./$(DEPDIR)/lsan_linux.Plo\n+\t-rm -f ./$(DEPDIR)/lsan_mac.Plo\n+\t-rm -f ./$(DEPDIR)/lsan_malloc_mac.Plo\n+\t-rm -f ./$(DEPDIR)/lsan_thread.Plo\n \t-rm -f Makefile\n maintainer-clean-am: distclean-am maintainer-clean-generic\n \n@@ -762,8 +793,8 @@ uninstall-am: uninstall-nodist_toolexeclibHEADERS \\\n \n .MAKE: install-am install-strip\n \n-.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \\\n-\tclean-libtool clean-noinstLTLIBRARIES \\\n+.PHONY: CTAGS GTAGS TAGS all all-am am--depfiles check check-am clean \\\n+\tclean-generic clean-libtool clean-noinstLTLIBRARIES \\\n \tclean-toolexeclibLTLIBRARIES cscopelist-am ctags ctags-am \\\n \tdistclean distclean-compile distclean-generic \\\n \tdistclean-libtool distclean-tags dvi dvi-am html html-am info \\"}, {"sha": "5b5f6198a693694bdea630f69029e4463a71644c", "filename": "libsanitizer/lsan/lsan.cpp", "status": "renamed", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//=-- lsan.cc -------------------------------------------------------------===//\n+//=-- lsan.cpp ------------------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -31,6 +32,24 @@ bool WordIsPoisoned(uptr addr) {\n \n }  // namespace __lsan\n \n+void __sanitizer::BufferedStackTrace::UnwindImpl(\n+    uptr pc, uptr bp, void *context, bool request_fast, u32 max_depth) {\n+  using namespace __lsan;\n+  uptr stack_top = 0, stack_bottom = 0;\n+  ThreadContext *t;\n+  if (StackTrace::WillUseFastUnwind(request_fast) &&\n+      (t = CurrentThreadContext())) {\n+    stack_top = t->stack_end();\n+    stack_bottom = t->stack_begin();\n+  }\n+  if (!SANITIZER_MIPS || IsValidFrame(bp, stack_top, stack_bottom)) {\n+    if (StackTrace::WillUseFastUnwind(request_fast))\n+      Unwind(max_depth, pc, bp, nullptr, stack_top, stack_bottom, true);\n+    else\n+      Unwind(max_depth, pc, 0, context, 0, 0, false);\n+  }\n+}\n+\n using namespace __lsan;  // NOLINT\n \n static void InitializeFlags() {\n@@ -57,7 +76,7 @@ static void InitializeFlags() {\n   // Override from user-specified string.\n   const char *lsan_default_options = MaybeCallLsanDefaultOptions();\n   parser.ParseString(lsan_default_options);\n-  parser.ParseString(GetEnv(\"LSAN_OPTIONS\"));\n+  parser.ParseStringFromEnv(\"LSAN_OPTIONS\");\n \n   SetVerbosity(common_flags()->verbosity);\n \n@@ -70,7 +89,7 @@ static void InitializeFlags() {\n \n static void OnStackUnwind(const SignalContext &sig, const void *,\n                           BufferedStackTrace *stack) {\n-  GetStackTrace(stack, kStackTraceMax, sig.pc, sig.bp, sig.context,\n+  stack->Unwind(sig.pc, sig.bp, sig.context,\n                 common_flags()->fast_unwind_on_fatal);\n }\n ", "previous_filename": "libsanitizer/lsan/lsan.cc"}, {"sha": "9904ada4bb3bd93e50bc1801324b756671684241", "filename": "libsanitizer/lsan/lsan.h", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //=-- lsan.h --------------------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -16,8 +17,8 @@\n \n #define GET_STACK_TRACE(max_size, fast)                       \\\n   __sanitizer::BufferedStackTrace stack;                      \\\n-  GetStackTrace(&stack, max_size, StackTrace::GetCurrentPc(), \\\n-                GET_CURRENT_FRAME(), nullptr, fast);\n+  stack.Unwind(StackTrace::GetCurrentPc(),                    \\\n+               GET_CURRENT_FRAME(), nullptr, fast, max_size);\n \n #define GET_STACK_TRACE_FATAL \\\n   GET_STACK_TRACE(kStackTraceMax, common_flags()->fast_unwind_on_fatal)\n@@ -39,24 +40,6 @@ void ReplaceSystemMalloc();\n     __lsan_init();                \\\n } while (0)\n \n-// Get the stack trace with the given pc and bp.\n-// The pc will be in the position 0 of the resulting stack trace.\n-// The bp may refer to the current frame or to the caller's frame.\n-ALWAYS_INLINE\n-void GetStackTrace(__sanitizer::BufferedStackTrace *stack,\n-                   __sanitizer::uptr max_depth, __sanitizer::uptr pc,\n-                   __sanitizer::uptr bp, void *context, bool fast) {\n-  uptr stack_top = 0, stack_bottom = 0;\n-  ThreadContext *t;\n-  if (fast && (t = CurrentThreadContext())) {\n-    stack_top = t->stack_end();\n-    stack_bottom = t->stack_begin();\n-  }\n-  if (!SANITIZER_MIPS || IsValidFrame(bp, stack_top, stack_bottom)) {\n-    stack->Unwind(max_depth, pc, bp, context, stack_top, stack_bottom, fast);\n-  }\n-}\n-\n }  // namespace __lsan\n \n extern bool lsan_inited;"}, {"sha": "66a81ab350e5f9b979667cb6b4d7746a069277a4", "filename": "libsanitizer/lsan/lsan_allocator.cpp", "status": "renamed", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_allocator.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_allocator.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_allocator.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//=-- lsan_allocator.cc ---------------------------------------------------===//\n+//=-- lsan_allocator.cpp --------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -32,9 +33,6 @@ static const uptr kMaxAllowedMallocSize = 4UL << 30;\n #else\n static const uptr kMaxAllowedMallocSize = 8UL << 30;\n #endif\n-typedef LargeMmapAllocator<> SecondaryAllocator;\n-typedef CombinedAllocator<PrimaryAllocator, AllocatorCache,\n-          SecondaryAllocator> Allocator;\n \n static Allocator allocator;\n \n@@ -187,6 +185,17 @@ void *lsan_realloc(void *p, uptr size, const StackTrace &stack) {\n   return SetErrnoOnNull(Reallocate(stack, p, size, 1));\n }\n \n+void *lsan_reallocarray(void *ptr, uptr nmemb, uptr size,\n+                        const StackTrace &stack) {\n+  if (UNLIKELY(CheckForCallocOverflow(size, nmemb))) {\n+    errno = errno_ENOMEM;\n+    if (AllocatorMayReturnNull())\n+      return nullptr;\n+    ReportReallocArrayOverflow(nmemb, size, &stack);\n+  }\n+  return lsan_realloc(ptr, nmemb * size, stack);\n+}\n+\n void *lsan_calloc(uptr nmemb, uptr size, const StackTrace &stack) {\n   return SetErrnoOnNull(Calloc(nmemb, size, stack));\n }", "previous_filename": "libsanitizer/lsan/lsan_allocator.cc"}, {"sha": "e1397099767284f28376214ac9284a610cac46d2", "filename": "libsanitizer/lsan/lsan_allocator.h", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_allocator.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //=-- lsan_allocator.h ----------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -50,21 +51,20 @@ struct ChunkMetadata {\n \n #if defined(__mips64) || defined(__aarch64__) || defined(__i386__) || \\\n     defined(__arm__)\n-static const uptr kRegionSizeLog = 20;\n-static const uptr kNumRegions = SANITIZER_MMAP_RANGE_SIZE >> kRegionSizeLog;\n-typedef TwoLevelByteMap<(kNumRegions >> 12), 1 << 12> ByteMap;\n-\n+template <typename AddressSpaceViewTy>\n struct AP32 {\n   static const uptr kSpaceBeg = 0;\n   static const u64 kSpaceSize = SANITIZER_MMAP_RANGE_SIZE;\n   static const uptr kMetadataSize = sizeof(ChunkMetadata);\n   typedef __sanitizer::CompactSizeClassMap SizeClassMap;\n-  static const uptr kRegionSizeLog = __lsan::kRegionSizeLog;\n-  typedef __lsan::ByteMap ByteMap;\n+  static const uptr kRegionSizeLog = 20;\n+  using AddressSpaceView = AddressSpaceViewTy;\n   typedef NoOpMapUnmapCallback MapUnmapCallback;\n   static const uptr kFlags = 0;\n };\n-typedef SizeClassAllocator32<AP32> PrimaryAllocator;\n+template <typename AddressSpaceView>\n+using PrimaryAllocatorASVT = SizeClassAllocator32<AP32<AddressSpaceView>>;\n+using PrimaryAllocator = PrimaryAllocatorASVT<LocalAddressSpaceView>;\n #elif defined(__x86_64__) || defined(__powerpc64__)\n # if defined(__powerpc64__)\n const uptr kAllocatorSpace = 0xa0000000000ULL;\n@@ -73,20 +73,28 @@ const uptr kAllocatorSize  = 0x20000000000ULL;  // 2T.\n const uptr kAllocatorSpace = 0x600000000000ULL;\n const uptr kAllocatorSize  = 0x40000000000ULL;  // 4T.\n # endif\n+template <typename AddressSpaceViewTy>\n struct AP64 {  // Allocator64 parameters. Deliberately using a short name.\n   static const uptr kSpaceBeg = kAllocatorSpace;\n   static const uptr kSpaceSize = kAllocatorSize;\n   static const uptr kMetadataSize = sizeof(ChunkMetadata);\n   typedef DefaultSizeClassMap SizeClassMap;\n   typedef NoOpMapUnmapCallback MapUnmapCallback;\n   static const uptr kFlags = 0;\n+  using AddressSpaceView = AddressSpaceViewTy;\n };\n \n-typedef SizeClassAllocator64<AP64> PrimaryAllocator;\n+template <typename AddressSpaceView>\n+using PrimaryAllocatorASVT = SizeClassAllocator64<AP64<AddressSpaceView>>;\n+using PrimaryAllocator = PrimaryAllocatorASVT<LocalAddressSpaceView>;\n #endif\n-typedef SizeClassAllocatorLocalCache<PrimaryAllocator> AllocatorCache;\n \n-AllocatorCache *GetAllocatorCache();\n+template <typename AddressSpaceView>\n+using AllocatorASVT = CombinedAllocator<PrimaryAllocatorASVT<AddressSpaceView>>;\n+using Allocator = AllocatorASVT<LocalAddressSpaceView>;\n+using AllocatorCache = Allocator::AllocatorCache;\n+\n+Allocator::AllocatorCache *GetAllocatorCache();\n \n int lsan_posix_memalign(void **memptr, uptr alignment, uptr size,\n                         const StackTrace &stack);\n@@ -95,6 +103,8 @@ void *lsan_memalign(uptr alignment, uptr size, const StackTrace &stack);\n void *lsan_malloc(uptr size, const StackTrace &stack);\n void lsan_free(void *p);\n void *lsan_realloc(void *p, uptr size, const StackTrace &stack);\n+void *lsan_reallocarray(void *p, uptr nmemb, uptr size,\n+                        const StackTrace &stack);\n void *lsan_calloc(uptr nmemb, uptr size, const StackTrace &stack);\n void *lsan_valloc(uptr size, const StackTrace &stack);\n void *lsan_pvalloc(uptr size, const StackTrace &stack);"}, {"sha": "c39fab97c6425ecc4ca8f8f500cde75a7c7a05da", "filename": "libsanitizer/lsan/lsan_common.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_common.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_common.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//=-- lsan_common.cc ------------------------------------------------------===//\n+//=-- lsan_common.cpp -----------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/lsan/lsan_common.cc"}, {"sha": "58dc00faaee5cdd8796785cef34e7be6e746c4ae", "filename": "libsanitizer/lsan/lsan_common.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //=-- lsan_common.h -------------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -20,8 +21,8 @@\n #include \"sanitizer_common/sanitizer_stoptheworld.h\"\n #include \"sanitizer_common/sanitizer_symbolizer.h\"\n \n-// LeakSanitizer relies on some Glibc's internals (e.g. TLS machinery) thus\n-// supported for Linux only. Also, LSan doesn't like 32 bit architectures\n+// LeakSanitizer relies on some Glibc's internals (e.g. TLS machinery) on Linux.\n+// Also, LSan doesn't like 32 bit architectures\n // because of \"small\" (4 bytes) pointer size that leads to high false negative\n // ratio on large leaks. But we still want to have it for some 32 bit arches\n // (e.g. x86), see https://github.com/google/sanitizers/issues/403.\n@@ -39,6 +40,8 @@\n #elif defined(__arm__) && \\\n     SANITIZER_LINUX && !SANITIZER_ANDROID\n #define CAN_SANITIZE_LEAKS 1\n+#elif SANITIZER_NETBSD\n+#define CAN_SANITIZE_LEAKS 1\n #else\n #define CAN_SANITIZE_LEAKS 0\n #endif"}, {"sha": "9ce27a983b502c503dd001c61a5d02e4886a97dc", "filename": "libsanitizer/lsan/lsan_common_linux.cpp", "status": "renamed", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_common_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_common_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common_linux.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,19 +1,21 @@\n-//=-- lsan_common_linux.cc ------------------------------------------------===//\n+//=-- lsan_common_linux.cpp -----------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n // This file is a part of LeakSanitizer.\n-// Implementation of common leak checking functionality. Linux-specific code.\n+// Implementation of common leak checking functionality. Linux/NetBSD-specific\n+// code.\n //\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n #include \"lsan_common.h\"\n \n-#if CAN_SANITIZE_LEAKS && SANITIZER_LINUX\n+#if CAN_SANITIZE_LEAKS && (SANITIZER_LINUX || SANITIZER_NETBSD)\n #include <link.h>\n \n #include \"sanitizer_common/sanitizer_common.h\"\n@@ -135,4 +137,4 @@ void DoStopTheWorld(StopTheWorldCallback callback, void *argument) {\n \n } // namespace __lsan\n \n-#endif // CAN_SANITIZE_LEAKS && SANITIZER_LINUX\n+#endif", "previous_filename": "libsanitizer/lsan/lsan_common_linux.cc"}, {"sha": "5204a6624edcc2d5c3638558b2978784f8ef8d28", "filename": "libsanitizer/lsan/lsan_common_mac.cpp", "status": "renamed", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_common_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_common_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common_mac.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//=-- lsan_common_mac.cc --------------------------------------------------===//\n+//=-- lsan_common_mac.cpp -------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -11,6 +12,7 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n #include \"lsan_common.h\"\n \n #if CAN_SANITIZE_LEAKS && SANITIZER_MAC\n@@ -114,7 +116,8 @@ static const char *kSkippedSecNames[] = {\n \n // Scans global variables for heap pointers.\n void ProcessGlobalRegions(Frontier *frontier) {\n-  for (auto name : kSkippedSecNames) CHECK(ARRAY_SIZE(name) < kMaxSegName);\n+  for (auto name : kSkippedSecNames)\n+    CHECK(internal_strnlen(name, kMaxSegName + 1) <= kMaxSegName);\n \n   MemoryMappingLayout memory_mapping(false);\n   InternalMmapVector<LoadedModule> modules;", "previous_filename": "libsanitizer/lsan/lsan_common_mac.cc"}, {"sha": "9350f4bcdc34b39280a69bbbe1cbcf54c84077da", "filename": "libsanitizer/lsan/lsan_flags.inc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_flags.inc?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- lsan_flags.inc ------------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "f06d5fff7063597bb3226a672bd3622cf7b48166", "filename": "libsanitizer/lsan/lsan_interceptors.cpp", "status": "renamed", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_interceptors.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_interceptors.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_interceptors.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//=-- lsan_interceptors.cc ------------------------------------------------===//\n+//=-- lsan_interceptors.cpp -----------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -82,6 +83,12 @@ INTERCEPTOR(void*, realloc, void *q, uptr size) {\n   return lsan_realloc(q, size, stack);\n }\n \n+INTERCEPTOR(void*, reallocarray, void *q, uptr nmemb, uptr size) {\n+  ENSURE_LSAN_INITED;\n+  GET_STACK_TRACE_MALLOC;\n+  return lsan_reallocarray(q, nmemb, size, stack);\n+}\n+\n INTERCEPTOR(int, posix_memalign, void **memptr, uptr alignment, uptr size) {\n   ENSURE_LSAN_INITED;\n   GET_STACK_TRACE_MALLOC;\n@@ -151,7 +158,7 @@ INTERCEPTOR(struct fake_mallinfo, mallinfo, void) {\n #define LSAN_MAYBE_INTERCEPT_MALLINFO INTERCEPT_FUNCTION(mallinfo)\n \n INTERCEPTOR(int, mallopt, int cmd, int value) {\n-  return -1;\n+  return 0;\n }\n #define LSAN_MAYBE_INTERCEPT_MALLOPT INTERCEPT_FUNCTION(mallopt)\n #else", "previous_filename": "libsanitizer/lsan/lsan_interceptors.cc"}, {"sha": "14a42b75d2af337e862c96081e670e920cebdada", "filename": "libsanitizer/lsan/lsan_linux.cpp", "status": "renamed", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_linux.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,17 +1,18 @@\n-//=-- lsan_linux.cc -------------------------------------------------------===//\n+//=-- lsan_linux.cpp ------------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n-// This file is a part of LeakSanitizer. Linux-specific code.\n+// This file is a part of LeakSanitizer. Linux/NetBSD-specific code.\n //\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n \n-#if SANITIZER_LINUX\n+#if SANITIZER_LINUX || SANITIZER_NETBSD\n \n #include \"lsan_allocator.h\"\n \n@@ -28,4 +29,4 @@ void ReplaceSystemMalloc() {}\n \n } // namespace __lsan\n \n-#endif // SANITIZER_LINUX\n+#endif  // SANITIZER_LINUX || SANITIZER_NETBSD", "previous_filename": "libsanitizer/lsan/lsan_linux.cc"}, {"sha": "7bcd9c828ef4d815716e26bd5186a9a333cf3d6e", "filename": "libsanitizer/lsan/lsan_mac.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_mac.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- lsan_mac.cc -------------------------------------------------------===//\n+//===-- lsan_mac.cpp ------------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/lsan/lsan_mac.cc"}, {"sha": "d03eb2e915c0bc6ee7b390f2ed6b53d60c832251", "filename": "libsanitizer/lsan/lsan_malloc_mac.cpp", "status": "renamed", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_malloc_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_malloc_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_malloc_mac.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- lsan_malloc_mac.cc ------------------------------------------------===//\n+//===-- lsan_malloc_mac.cpp -----------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -50,6 +51,8 @@ using namespace __lsan;\n   (void)zone_name; \\\n   Report(\"mz_realloc(%p) -- attempting to realloc unallocated memory.\\n\", ptr);\n #define COMMON_MALLOC_NAMESPACE __lsan\n+#define COMMON_MALLOC_HAS_ZONE_ENUMERATOR 0\n+#define COMMON_MALLOC_HAS_EXTRA_INTROSPECTION_INIT 0\n \n #include \"sanitizer_common/sanitizer_malloc_mac.inc\"\n ", "previous_filename": "libsanitizer/lsan/lsan_malloc_mac.cc"}, {"sha": "cd94e1e8718e642a984f9e2b93bcef32fb921fc4", "filename": "libsanitizer/lsan/lsan_preinit.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_preinit.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_preinit.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_preinit.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- lsan_preinit.cc ---------------------------------------------------===//\n+//===-- lsan_preinit.cpp --------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/lsan/lsan_preinit.cc"}, {"sha": "84e7ce61b975659324d0a7280a18a5740cbc73c1", "filename": "libsanitizer/lsan/lsan_thread.cpp", "status": "renamed", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_thread.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_thread.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_thread.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//=-- lsan_thread.cc ------------------------------------------------------===//\n+//=-- lsan_thread.cpp -----------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -75,7 +76,7 @@ u32 ThreadCreate(u32 parent_tid, uptr user_id, bool detached) {\n                                        /* arg */ nullptr);\n }\n \n-void ThreadStart(u32 tid, tid_t os_id, bool workerthread) {\n+void ThreadStart(u32 tid, tid_t os_id, ThreadType thread_type) {\n   OnStartedArgs args;\n   uptr stack_size = 0;\n   uptr tls_size = 0;\n@@ -85,7 +86,7 @@ void ThreadStart(u32 tid, tid_t os_id, bool workerthread) {\n   args.tls_end = args.tls_begin + tls_size;\n   GetAllocatorCacheRange(&args.cache_begin, &args.cache_end);\n   args.dtls = DTLS_Get();\n-  thread_registry->StartThread(tid, os_id, workerthread, &args);\n+  thread_registry->StartThread(tid, os_id, thread_type, &args);\n }\n \n void ThreadFinish() {", "previous_filename": "libsanitizer/lsan/lsan_thread.cc"}, {"sha": "b869d066d9d8bdbf48c96c593b663cb75c1f0531", "filename": "libsanitizer/lsan/lsan_thread.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Flsan%2Flsan_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_thread.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //=-- lsan_thread.h -------------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -43,7 +44,8 @@ class ThreadContext : public ThreadContextBase {\n \n void InitializeThreadRegistry();\n \n-void ThreadStart(u32 tid, tid_t os_id, bool workerthread = false);\n+void ThreadStart(u32 tid, tid_t os_id,\n+                 ThreadType thread_type = ThreadType::Regular);\n void ThreadFinish();\n u32 ThreadCreate(u32 tid, uptr uid, bool detached);\n void ThreadJoin(u32 tid);"}, {"sha": "168fbbc9729d9873c4ca858f41db01e4f22cfedb", "filename": "libsanitizer/merge.sh", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fmerge.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fmerge.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fmerge.sh?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -18,7 +18,7 @@ get_current_rev() {\n }\n \n list_files() {\n-  (cd $1; ls *.{cc,h,inc,S} 2> /dev/null)\n+  (cd $1; ls *.{cc,cpp,h,inc,S} 2> /dev/null)\n \n }\n \n@@ -74,6 +74,7 @@ merge lib/tsan/rtl tsan\n merge lib/sanitizer_common sanitizer_common\n merge lib/interception interception\n merge lib/ubsan ubsan\n+merge lib/BlocksRuntime/ BlocksRuntime\n \n # Need to merge lib/builtins/assembly.h file:\n mkdir -p builtins"}, {"sha": "7e8ce9476ed4eab9af73275d38551f679b21c1ab", "filename": "libsanitizer/sanitizer_common/Makefile.am", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.am?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -10,6 +10,7 @@ AM_CXXFLAGS += -std=gnu++11\n AM_CXXFLAGS += $(EXTRA_CXXFLAGS)\n if LIBBACKTRACE_SUPPORTED\n AM_CXXFLAGS += -DSANITIZER_LIBBACKTRACE -DSANITIZER_CP_DEMANGLE \\\n+\t       -I $(top_srcdir)/ \\\n \t       -I $(top_srcdir)/../libbacktrace \\\n \t       -I $(top_builddir)/libbacktrace \\\n \t       -I $(top_srcdir)/../include \\\n@@ -21,68 +22,67 @@ ACLOCAL_AMFLAGS = -I m4\n noinst_LTLIBRARIES = libsanitizer_common.la\n \n sanitizer_common_files = \\\n-\tsancov_flags.cc \\\n-\tsanitizer_allocator.cc \\\n-\tsanitizer_allocator_checks.cc \\\n-\tsanitizer_allocator_report.cc \\\n-\tsanitizer_common.cc \\\n-\tsanitizer_common_libcdep.cc \\\n-\tsanitizer_coverage_libcdep_new.cc \\\n-\tsanitizer_deadlock_detector1.cc \\\n-\tsanitizer_deadlock_detector2.cc \\\n-\tsanitizer_errno.cc \\\n-\tsanitizer_file.cc \\\n-\tsanitizer_flags.cc \\\n-\tsanitizer_flag_parser.cc \\\n-\tsanitizer_libc.cc \\\n-\tsanitizer_libignore.cc \\\n-\tsanitizer_linux.cc \\\n-\tsanitizer_linux_libcdep.cc \\\n-\tsanitizer_linux_s390.cc \\\n-\tsanitizer_mac.cc \\\n-\tsanitizer_mac_libcdep.cc \\\n-\tsanitizer_netbsd.cc \\\n-\tsanitizer_openbsd.cc \\\n-\tsanitizer_persistent_allocator.cc \\\n-\tsanitizer_platform_limits_linux.cc \\\n-\tsanitizer_platform_limits_openbsd.cc \\\n-\tsanitizer_platform_limits_posix.cc \\\n-\tsanitizer_platform_limits_solaris.cc \\\n-\tsanitizer_posix.cc \\\n-\tsanitizer_posix_libcdep.cc \\\n-\tsanitizer_printf.cc \\\n-\tsanitizer_procmaps_bsd.cc \\\n-\tsanitizer_procmaps_common.cc \\\n-\tsanitizer_procmaps_linux.cc \\\n-\tsanitizer_procmaps_mac.cc \\\n-\tsanitizer_procmaps_solaris.cc \\\n-\tsanitizer_rtems.cc \\\n-\tsanitizer_solaris.cc \\\n-\tsanitizer_stackdepot.cc \\\n-\tsanitizer_stacktrace.cc \\\n-\tsanitizer_stacktrace_libcdep.cc \\\n-\tsanitizer_stacktrace_sparc.cc \\\n-\tsanitizer_symbolizer_mac.cc \\\n-\tsanitizer_symbolizer_report.cc \\\n-\tsanitizer_stacktrace_printer.cc \\\n-\tsanitizer_stoptheworld_linux_libcdep.cc \\\n-\tsanitizer_stoptheworld_mac.cc \\\n-\tsanitizer_suppressions.cc \\\n-\tsanitizer_symbolizer.cc \\\n-\tsanitizer_symbolizer_libbacktrace.cc \\\n-\tsanitizer_symbolizer_libcdep.cc \\\n-\tsanitizer_symbolizer_posix_libcdep.cc \\\n-\tsanitizer_symbolizer_win.cc \\\n-\tsanitizer_termination.cc \\\n-\tsanitizer_thread_registry.cc \\\n-\tsanitizer_tls_get_addr.cc \\\n-\tsanitizer_unwind_linux_libcdep.cc \\\n-\tsanitizer_unwind_win.cc \\\n-\tsanitizer_win.cc\n+\tsancov_flags.cpp \\\n+\tsanitizer_allocator.cpp \\\n+\tsanitizer_allocator_checks.cpp \\\n+\tsanitizer_allocator_report.cpp \\\n+\tsanitizer_common.cpp \\\n+\tsanitizer_common_libcdep.cpp \\\n+\tsanitizer_coverage_libcdep_new.cpp \\\n+\tsanitizer_deadlock_detector1.cpp \\\n+\tsanitizer_deadlock_detector2.cpp \\\n+\tsanitizer_errno.cpp \\\n+\tsanitizer_file.cpp \\\n+\tsanitizer_flags.cpp \\\n+\tsanitizer_flag_parser.cpp \\\n+\tsanitizer_libc.cpp \\\n+\tsanitizer_libignore.cpp \\\n+\tsanitizer_linux.cpp \\\n+\tsanitizer_linux_libcdep.cpp \\\n+\tsanitizer_linux_s390.cpp \\\n+\tsanitizer_mac.cpp \\\n+\tsanitizer_mac_libcdep.cpp \\\n+\tsanitizer_netbsd.cpp \\\n+\tsanitizer_openbsd.cpp \\\n+\tsanitizer_persistent_allocator.cpp \\\n+\tsanitizer_platform_limits_linux.cpp \\\n+\tsanitizer_platform_limits_openbsd.cpp \\\n+\tsanitizer_platform_limits_posix.cpp \\\n+\tsanitizer_platform_limits_solaris.cpp \\\n+\tsanitizer_posix.cpp \\\n+\tsanitizer_posix_libcdep.cpp \\\n+\tsanitizer_printf.cpp \\\n+\tsanitizer_procmaps_bsd.cpp \\\n+\tsanitizer_procmaps_common.cpp \\\n+\tsanitizer_procmaps_linux.cpp \\\n+\tsanitizer_procmaps_mac.cpp \\\n+\tsanitizer_procmaps_solaris.cpp \\\n+\tsanitizer_rtems.cpp \\\n+\tsanitizer_solaris.cpp \\\n+\tsanitizer_stackdepot.cpp \\\n+\tsanitizer_stacktrace.cpp \\\n+\tsanitizer_stacktrace_libcdep.cpp \\\n+\tsanitizer_stacktrace_sparc.cpp \\\n+\tsanitizer_symbolizer_mac.cpp \\\n+\tsanitizer_symbolizer_report.cpp \\\n+\tsanitizer_stacktrace_printer.cpp \\\n+\tsanitizer_stoptheworld_linux_libcdep.cpp \\\n+\tsanitizer_stoptheworld_mac.cpp \\\n+\tsanitizer_suppressions.cpp \\\n+\tsanitizer_symbolizer.cpp \\\n+\tsanitizer_symbolizer_libbacktrace.cpp \\\n+\tsanitizer_symbolizer_libcdep.cpp \\\n+\tsanitizer_symbolizer_posix_libcdep.cpp \\\n+\tsanitizer_symbolizer_win.cpp \\\n+\tsanitizer_termination.cpp \\\n+\tsanitizer_thread_registry.cpp \\\n+\tsanitizer_tls_get_addr.cpp \\\n+\tsanitizer_unwind_linux_libcdep.cpp \\\n+\tsanitizer_unwind_win.cpp \\\n+\tsanitizer_win.cpp\n \n \n libsanitizer_common_la_SOURCES = $(sanitizer_common_files) \n-EXTRA_libsanitizer_common_la_SOURCES = sanitizer_linux_mips64.S sanitizer_linux_x86_64.S\n libsanitizer_common_la_LIBADD = $(SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS)\n libsanitizer_common_la_DEPENDENCIES =  $(SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS)\n "}, {"sha": "6cc219fbf344b3dbbaf397663509c8eaa7f15a4c", "filename": "libsanitizer/sanitizer_common/Makefile.in", "status": "modified", "additions": 319, "deletions": 195, "changes": 514, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.in?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,7 @@\n-# Makefile.in generated by automake 1.15.1 from Makefile.am.\n+# Makefile.in generated by automake 1.16.1 from Makefile.am.\n # @configure_input@\n \n-# Copyright (C) 1994-2017 Free Software Foundation, Inc.\n+# Copyright (C) 1994-2018 Free Software Foundation, Inc.\n \n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -90,6 +90,7 @@ build_triplet = @build@\n host_triplet = @host@\n target_triplet = @target@\n @LIBBACKTRACE_SUPPORTED_TRUE@am__append_1 = -DSANITIZER_LIBBACKTRACE -DSANITIZER_CP_DEMANGLE \\\n+@LIBBACKTRACE_SUPPORTED_TRUE@\t       -I $(top_srcdir)/ \\\n @LIBBACKTRACE_SUPPORTED_TRUE@\t       -I $(top_srcdir)/../libbacktrace \\\n @LIBBACKTRACE_SUPPORTED_TRUE@\t       -I $(top_builddir)/libbacktrace \\\n @LIBBACKTRACE_SUPPORTED_TRUE@\t       -I $(top_srcdir)/../include \\\n@@ -170,18 +171,64 @@ am__v_at_0 = @\n am__v_at_1 = \n DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)\n depcomp = $(SHELL) $(top_srcdir)/../depcomp\n-am__depfiles_maybe = depfiles\n+am__maybe_remake_depfiles = depfiles\n+am__depfiles_remade = ./$(DEPDIR)/sancov_flags.Plo \\\n+\t./$(DEPDIR)/sanitizer_allocator.Plo \\\n+\t./$(DEPDIR)/sanitizer_allocator_checks.Plo \\\n+\t./$(DEPDIR)/sanitizer_allocator_report.Plo \\\n+\t./$(DEPDIR)/sanitizer_common.Plo \\\n+\t./$(DEPDIR)/sanitizer_common_libcdep.Plo \\\n+\t./$(DEPDIR)/sanitizer_coverage_libcdep_new.Plo \\\n+\t./$(DEPDIR)/sanitizer_deadlock_detector1.Plo \\\n+\t./$(DEPDIR)/sanitizer_deadlock_detector2.Plo \\\n+\t./$(DEPDIR)/sanitizer_errno.Plo ./$(DEPDIR)/sanitizer_file.Plo \\\n+\t./$(DEPDIR)/sanitizer_flag_parser.Plo \\\n+\t./$(DEPDIR)/sanitizer_flags.Plo ./$(DEPDIR)/sanitizer_libc.Plo \\\n+\t./$(DEPDIR)/sanitizer_libignore.Plo \\\n+\t./$(DEPDIR)/sanitizer_linux.Plo \\\n+\t./$(DEPDIR)/sanitizer_linux_libcdep.Plo \\\n+\t./$(DEPDIR)/sanitizer_linux_s390.Plo \\\n+\t./$(DEPDIR)/sanitizer_mac.Plo \\\n+\t./$(DEPDIR)/sanitizer_mac_libcdep.Plo \\\n+\t./$(DEPDIR)/sanitizer_netbsd.Plo \\\n+\t./$(DEPDIR)/sanitizer_openbsd.Plo \\\n+\t./$(DEPDIR)/sanitizer_persistent_allocator.Plo \\\n+\t./$(DEPDIR)/sanitizer_platform_limits_linux.Plo \\\n+\t./$(DEPDIR)/sanitizer_platform_limits_openbsd.Plo \\\n+\t./$(DEPDIR)/sanitizer_platform_limits_posix.Plo \\\n+\t./$(DEPDIR)/sanitizer_platform_limits_solaris.Plo \\\n+\t./$(DEPDIR)/sanitizer_posix.Plo \\\n+\t./$(DEPDIR)/sanitizer_posix_libcdep.Plo \\\n+\t./$(DEPDIR)/sanitizer_printf.Plo \\\n+\t./$(DEPDIR)/sanitizer_procmaps_bsd.Plo \\\n+\t./$(DEPDIR)/sanitizer_procmaps_common.Plo \\\n+\t./$(DEPDIR)/sanitizer_procmaps_linux.Plo \\\n+\t./$(DEPDIR)/sanitizer_procmaps_mac.Plo \\\n+\t./$(DEPDIR)/sanitizer_procmaps_solaris.Plo \\\n+\t./$(DEPDIR)/sanitizer_rtems.Plo \\\n+\t./$(DEPDIR)/sanitizer_solaris.Plo \\\n+\t./$(DEPDIR)/sanitizer_stackdepot.Plo \\\n+\t./$(DEPDIR)/sanitizer_stacktrace.Plo \\\n+\t./$(DEPDIR)/sanitizer_stacktrace_libcdep.Plo \\\n+\t./$(DEPDIR)/sanitizer_stacktrace_printer.Plo \\\n+\t./$(DEPDIR)/sanitizer_stacktrace_sparc.Plo \\\n+\t./$(DEPDIR)/sanitizer_stoptheworld_linux_libcdep.Plo \\\n+\t./$(DEPDIR)/sanitizer_stoptheworld_mac.Plo \\\n+\t./$(DEPDIR)/sanitizer_suppressions.Plo \\\n+\t./$(DEPDIR)/sanitizer_symbolizer.Plo \\\n+\t./$(DEPDIR)/sanitizer_symbolizer_libbacktrace.Plo \\\n+\t./$(DEPDIR)/sanitizer_symbolizer_libcdep.Plo \\\n+\t./$(DEPDIR)/sanitizer_symbolizer_mac.Plo \\\n+\t./$(DEPDIR)/sanitizer_symbolizer_posix_libcdep.Plo \\\n+\t./$(DEPDIR)/sanitizer_symbolizer_report.Plo \\\n+\t./$(DEPDIR)/sanitizer_symbolizer_win.Plo \\\n+\t./$(DEPDIR)/sanitizer_termination.Plo \\\n+\t./$(DEPDIR)/sanitizer_thread_registry.Plo \\\n+\t./$(DEPDIR)/sanitizer_tls_get_addr.Plo \\\n+\t./$(DEPDIR)/sanitizer_unwind_linux_libcdep.Plo \\\n+\t./$(DEPDIR)/sanitizer_unwind_win.Plo \\\n+\t./$(DEPDIR)/sanitizer_win.Plo\n am__mv = mv -f\n-CPPASCOMPILE = $(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n-\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CCASFLAGS) $(CCASFLAGS)\n-LTCPPASCOMPILE = $(LIBTOOL) $(AM_V_lt) $(AM_LIBTOOLFLAGS) \\\n-\t$(LIBTOOLFLAGS) --mode=compile $(CCAS) $(DEFS) \\\n-\t$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \\\n-\t$(AM_CCASFLAGS) $(CCASFLAGS)\n-AM_V_CPPAS = $(am__v_CPPAS_@AM_V@)\n-am__v_CPPAS_ = $(am__v_CPPAS_@AM_DEFAULT_V@)\n-am__v_CPPAS_0 = @echo \"  CPPAS   \" $@;\n-am__v_CPPAS_1 = \n CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n \t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n LTCXXCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n@@ -200,26 +247,7 @@ AM_V_CXXLD = $(am__v_CXXLD_@AM_V@)\n am__v_CXXLD_ = $(am__v_CXXLD_@AM_DEFAULT_V@)\n am__v_CXXLD_0 = @echo \"  CXXLD   \" $@;\n am__v_CXXLD_1 = \n-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n-\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n-LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n-\t$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \\\n-\t$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \\\n-\t$(AM_CFLAGS) $(CFLAGS)\n-AM_V_CC = $(am__v_CC_@AM_V@)\n-am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)\n-am__v_CC_0 = @echo \"  CC      \" $@;\n-am__v_CC_1 = \n-CCLD = $(CC)\n-LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n-\t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \\\n-\t$(AM_LDFLAGS) $(LDFLAGS) -o $@\n-AM_V_CCLD = $(am__v_CCLD_@AM_V@)\n-am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)\n-am__v_CCLD_0 = @echo \"  CCLD    \" $@;\n-am__v_CCLD_1 = \n-SOURCES = $(libsanitizer_common_la_SOURCES) \\\n-\t$(EXTRA_libsanitizer_common_la_SOURCES)\n+SOURCES = $(libsanitizer_common_la_SOURCES)\n am__can_run_installinfo = \\\n   case $$AM_UPDATE_INFO_DIR in \\\n     n|no|NO) false;; \\\n@@ -406,67 +434,66 @@ AM_CCASFLAGS = $(EXTRA_ASFLAGS)\n ACLOCAL_AMFLAGS = -I m4\n noinst_LTLIBRARIES = libsanitizer_common.la\n sanitizer_common_files = \\\n-\tsancov_flags.cc \\\n-\tsanitizer_allocator.cc \\\n-\tsanitizer_allocator_checks.cc \\\n-\tsanitizer_allocator_report.cc \\\n-\tsanitizer_common.cc \\\n-\tsanitizer_common_libcdep.cc \\\n-\tsanitizer_coverage_libcdep_new.cc \\\n-\tsanitizer_deadlock_detector1.cc \\\n-\tsanitizer_deadlock_detector2.cc \\\n-\tsanitizer_errno.cc \\\n-\tsanitizer_file.cc \\\n-\tsanitizer_flags.cc \\\n-\tsanitizer_flag_parser.cc \\\n-\tsanitizer_libc.cc \\\n-\tsanitizer_libignore.cc \\\n-\tsanitizer_linux.cc \\\n-\tsanitizer_linux_libcdep.cc \\\n-\tsanitizer_linux_s390.cc \\\n-\tsanitizer_mac.cc \\\n-\tsanitizer_mac_libcdep.cc \\\n-\tsanitizer_netbsd.cc \\\n-\tsanitizer_openbsd.cc \\\n-\tsanitizer_persistent_allocator.cc \\\n-\tsanitizer_platform_limits_linux.cc \\\n-\tsanitizer_platform_limits_openbsd.cc \\\n-\tsanitizer_platform_limits_posix.cc \\\n-\tsanitizer_platform_limits_solaris.cc \\\n-\tsanitizer_posix.cc \\\n-\tsanitizer_posix_libcdep.cc \\\n-\tsanitizer_printf.cc \\\n-\tsanitizer_procmaps_bsd.cc \\\n-\tsanitizer_procmaps_common.cc \\\n-\tsanitizer_procmaps_linux.cc \\\n-\tsanitizer_procmaps_mac.cc \\\n-\tsanitizer_procmaps_solaris.cc \\\n-\tsanitizer_rtems.cc \\\n-\tsanitizer_solaris.cc \\\n-\tsanitizer_stackdepot.cc \\\n-\tsanitizer_stacktrace.cc \\\n-\tsanitizer_stacktrace_libcdep.cc \\\n-\tsanitizer_stacktrace_sparc.cc \\\n-\tsanitizer_symbolizer_mac.cc \\\n-\tsanitizer_symbolizer_report.cc \\\n-\tsanitizer_stacktrace_printer.cc \\\n-\tsanitizer_stoptheworld_linux_libcdep.cc \\\n-\tsanitizer_stoptheworld_mac.cc \\\n-\tsanitizer_suppressions.cc \\\n-\tsanitizer_symbolizer.cc \\\n-\tsanitizer_symbolizer_libbacktrace.cc \\\n-\tsanitizer_symbolizer_libcdep.cc \\\n-\tsanitizer_symbolizer_posix_libcdep.cc \\\n-\tsanitizer_symbolizer_win.cc \\\n-\tsanitizer_termination.cc \\\n-\tsanitizer_thread_registry.cc \\\n-\tsanitizer_tls_get_addr.cc \\\n-\tsanitizer_unwind_linux_libcdep.cc \\\n-\tsanitizer_unwind_win.cc \\\n-\tsanitizer_win.cc\n+\tsancov_flags.cpp \\\n+\tsanitizer_allocator.cpp \\\n+\tsanitizer_allocator_checks.cpp \\\n+\tsanitizer_allocator_report.cpp \\\n+\tsanitizer_common.cpp \\\n+\tsanitizer_common_libcdep.cpp \\\n+\tsanitizer_coverage_libcdep_new.cpp \\\n+\tsanitizer_deadlock_detector1.cpp \\\n+\tsanitizer_deadlock_detector2.cpp \\\n+\tsanitizer_errno.cpp \\\n+\tsanitizer_file.cpp \\\n+\tsanitizer_flags.cpp \\\n+\tsanitizer_flag_parser.cpp \\\n+\tsanitizer_libc.cpp \\\n+\tsanitizer_libignore.cpp \\\n+\tsanitizer_linux.cpp \\\n+\tsanitizer_linux_libcdep.cpp \\\n+\tsanitizer_linux_s390.cpp \\\n+\tsanitizer_mac.cpp \\\n+\tsanitizer_mac_libcdep.cpp \\\n+\tsanitizer_netbsd.cpp \\\n+\tsanitizer_openbsd.cpp \\\n+\tsanitizer_persistent_allocator.cpp \\\n+\tsanitizer_platform_limits_linux.cpp \\\n+\tsanitizer_platform_limits_openbsd.cpp \\\n+\tsanitizer_platform_limits_posix.cpp \\\n+\tsanitizer_platform_limits_solaris.cpp \\\n+\tsanitizer_posix.cpp \\\n+\tsanitizer_posix_libcdep.cpp \\\n+\tsanitizer_printf.cpp \\\n+\tsanitizer_procmaps_bsd.cpp \\\n+\tsanitizer_procmaps_common.cpp \\\n+\tsanitizer_procmaps_linux.cpp \\\n+\tsanitizer_procmaps_mac.cpp \\\n+\tsanitizer_procmaps_solaris.cpp \\\n+\tsanitizer_rtems.cpp \\\n+\tsanitizer_solaris.cpp \\\n+\tsanitizer_stackdepot.cpp \\\n+\tsanitizer_stacktrace.cpp \\\n+\tsanitizer_stacktrace_libcdep.cpp \\\n+\tsanitizer_stacktrace_sparc.cpp \\\n+\tsanitizer_symbolizer_mac.cpp \\\n+\tsanitizer_symbolizer_report.cpp \\\n+\tsanitizer_stacktrace_printer.cpp \\\n+\tsanitizer_stoptheworld_linux_libcdep.cpp \\\n+\tsanitizer_stoptheworld_mac.cpp \\\n+\tsanitizer_suppressions.cpp \\\n+\tsanitizer_symbolizer.cpp \\\n+\tsanitizer_symbolizer_libbacktrace.cpp \\\n+\tsanitizer_symbolizer_libcdep.cpp \\\n+\tsanitizer_symbolizer_posix_libcdep.cpp \\\n+\tsanitizer_symbolizer_win.cpp \\\n+\tsanitizer_termination.cpp \\\n+\tsanitizer_thread_registry.cpp \\\n+\tsanitizer_tls_get_addr.cpp \\\n+\tsanitizer_unwind_linux_libcdep.cpp \\\n+\tsanitizer_unwind_win.cpp \\\n+\tsanitizer_win.cpp\n \n libsanitizer_common_la_SOURCES = $(sanitizer_common_files) \n-EXTRA_libsanitizer_common_la_SOURCES = sanitizer_linux_mips64.S sanitizer_linux_x86_64.S\n libsanitizer_common_la_LIBADD = $(SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS)\n libsanitizer_common_la_DEPENDENCIES = $(SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS)\n \n@@ -512,7 +539,7 @@ MAKEOVERRIDES =\n all: all-am\n \n .SUFFIXES:\n-.SUFFIXES: .S .cc .lo .o .obj\n+.SUFFIXES: .cpp .lo .o .obj\n $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n \t@for dep in $?; do \\\n \t  case '$(am__configure_deps)' in \\\n@@ -530,8 +557,8 @@ Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n \t  *config.status*) \\\n \t    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \\\n \t  *) \\\n-\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \\\n-\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__maybe_remake_depfiles);; \\\n \tesac;\n \n $(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n@@ -563,103 +590,86 @@ mostlyclean-compile:\n distclean-compile:\n \t-rm -f *.tab.c\n \n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sancov_flags.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_allocator.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_allocator_checks.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_allocator_report.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_common.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_common_libcdep.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_coverage_libcdep_new.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_deadlock_detector1.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_deadlock_detector2.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_errno.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_file.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_flag_parser.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_flags.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_libc.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_libignore.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux_libcdep.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux_mips64.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux_s390.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux_x86_64.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_mac.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_mac_libcdep.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_netbsd.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_openbsd.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_persistent_allocator.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_platform_limits_linux.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_platform_limits_openbsd.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_platform_limits_posix.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_platform_limits_solaris.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_posix.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_posix_libcdep.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_printf.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_procmaps_bsd.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_procmaps_common.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_procmaps_linux.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_procmaps_mac.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_procmaps_solaris.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_rtems.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_solaris.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stackdepot.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stacktrace.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stacktrace_libcdep.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stacktrace_printer.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stacktrace_sparc.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stoptheworld_linux_libcdep.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stoptheworld_mac.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_suppressions.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_libbacktrace.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_libcdep.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_mac.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_posix_libcdep.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_report.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_win.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_termination.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_thread_registry.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_tls_get_addr.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_unwind_linux_libcdep.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_unwind_win.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_win.Plo@am__quote@\n-\n-.S.o:\n-@am__fastdepCCAS_TRUE@\t$(AM_V_CPPAS)$(CPPASCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n-@am__fastdepCCAS_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n-@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tDEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS@am__nodep@)$(CPPASCOMPILE) -c -o $@ $<\n-\n-.S.obj:\n-@am__fastdepCCAS_TRUE@\t$(AM_V_CPPAS)$(CPPASCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n-@am__fastdepCCAS_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n-@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tDEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS@am__nodep@)$(CPPASCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n-\n-.S.lo:\n-@am__fastdepCCAS_TRUE@\t$(AM_V_CPPAS)$(LTCPPASCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n-@am__fastdepCCAS_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n-@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tDEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCCAS_FALSE@\t$(AM_V_CPPAS@am__nodep@)$(LTCPPASCOMPILE) -c -o $@ $<\n-\n-.cc.o:\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sancov_flags.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_allocator.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_allocator_checks.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_allocator_report.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_common.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_common_libcdep.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_coverage_libcdep_new.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_deadlock_detector1.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_deadlock_detector2.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_errno.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_file.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_flag_parser.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_flags.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_libc.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_libignore.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux_libcdep.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux_s390.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_mac.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_mac_libcdep.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_netbsd.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_openbsd.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_persistent_allocator.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_platform_limits_linux.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_platform_limits_openbsd.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_platform_limits_posix.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_platform_limits_solaris.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_posix.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_posix_libcdep.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_printf.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_procmaps_bsd.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_procmaps_common.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_procmaps_linux.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_procmaps_mac.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_procmaps_solaris.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_rtems.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_solaris.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stackdepot.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stacktrace.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stacktrace_libcdep.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stacktrace_printer.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stacktrace_sparc.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stoptheworld_linux_libcdep.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stoptheworld_mac.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_suppressions.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_libbacktrace.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_libcdep.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_mac.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_posix_libcdep.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_report.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_win.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_termination.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_thread_registry.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_tls_get_addr.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_unwind_linux_libcdep.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_unwind_win.Plo@am__quote@ # am--include-marker\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_win.Plo@am__quote@ # am--include-marker\n+\n+$(am__depfiles_remade):\n+\t@$(MKDIR_P) $(@D)\n+\t@echo '# dummy' >$@-t && $(am__mv) $@-t $@\n+\n+am--depfiles: $(am__depfiles_remade)\n+\n+.cpp.o:\n @am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n @am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ $<\n \n-.cc.obj:\n+.cpp.obj:\n @am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n @am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n \n-.cc.lo:\n+.cpp.lo:\n @am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n @am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n@@ -763,7 +773,64 @@ clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \\\n \tmostlyclean-am\n \n distclean: distclean-am\n-\t-rm -rf ./$(DEPDIR)\n+\t\t-rm -f ./$(DEPDIR)/sancov_flags.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_allocator.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_allocator_checks.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_allocator_report.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_common.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_common_libcdep.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_coverage_libcdep_new.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_deadlock_detector1.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_deadlock_detector2.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_errno.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_file.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_flag_parser.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_flags.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_libc.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_libignore.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_linux.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_linux_libcdep.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_linux_s390.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_mac.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_mac_libcdep.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_netbsd.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_openbsd.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_persistent_allocator.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_platform_limits_linux.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_platform_limits_openbsd.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_platform_limits_posix.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_platform_limits_solaris.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_posix.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_posix_libcdep.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_printf.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_procmaps_bsd.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_procmaps_common.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_procmaps_linux.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_procmaps_mac.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_procmaps_solaris.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_rtems.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_solaris.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_stackdepot.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_stacktrace.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_stacktrace_libcdep.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_stacktrace_printer.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_stacktrace_sparc.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_stoptheworld_linux_libcdep.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_stoptheworld_mac.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_suppressions.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_symbolizer.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_symbolizer_libbacktrace.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_symbolizer_libcdep.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_symbolizer_mac.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_symbolizer_posix_libcdep.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_symbolizer_report.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_symbolizer_win.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_termination.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_thread_registry.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_tls_get_addr.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_unwind_linux_libcdep.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_unwind_win.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_win.Plo\n \t-rm -f Makefile\n distclean-am: clean-am distclean-compile distclean-generic \\\n \tdistclean-tags\n@@ -809,7 +876,64 @@ install-ps-am:\n installcheck-am:\n \n maintainer-clean: maintainer-clean-am\n-\t-rm -rf ./$(DEPDIR)\n+\t\t-rm -f ./$(DEPDIR)/sancov_flags.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_allocator.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_allocator_checks.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_allocator_report.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_common.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_common_libcdep.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_coverage_libcdep_new.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_deadlock_detector1.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_deadlock_detector2.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_errno.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_file.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_flag_parser.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_flags.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_libc.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_libignore.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_linux.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_linux_libcdep.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_linux_s390.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_mac.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_mac_libcdep.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_netbsd.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_openbsd.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_persistent_allocator.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_platform_limits_linux.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_platform_limits_openbsd.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_platform_limits_posix.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_platform_limits_solaris.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_posix.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_posix_libcdep.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_printf.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_procmaps_bsd.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_procmaps_common.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_procmaps_linux.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_procmaps_mac.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_procmaps_solaris.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_rtems.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_solaris.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_stackdepot.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_stacktrace.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_stacktrace_libcdep.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_stacktrace_printer.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_stacktrace_sparc.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_stoptheworld_linux_libcdep.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_stoptheworld_mac.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_suppressions.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_symbolizer.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_symbolizer_libbacktrace.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_symbolizer_libcdep.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_symbolizer_mac.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_symbolizer_posix_libcdep.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_symbolizer_report.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_symbolizer_win.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_termination.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_thread_registry.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_tls_get_addr.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_unwind_linux_libcdep.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_unwind_win.Plo\n+\t-rm -f ./$(DEPDIR)/sanitizer_win.Plo\n \t-rm -f Makefile\n maintainer-clean-am: distclean-am maintainer-clean-generic\n \n@@ -830,19 +954,19 @@ uninstall-am:\n \n .MAKE: install-am install-strip\n \n-.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \\\n-\tclean-libtool clean-noinstLTLIBRARIES cscopelist-am ctags \\\n-\tctags-am distclean distclean-compile distclean-generic \\\n-\tdistclean-libtool distclean-tags dvi dvi-am html html-am info \\\n-\tinfo-am install install-am install-data install-data-am \\\n-\tinstall-dvi install-dvi-am install-exec install-exec-am \\\n-\tinstall-html install-html-am install-info install-info-am \\\n-\tinstall-man install-pdf install-pdf-am install-ps \\\n-\tinstall-ps-am install-strip installcheck installcheck-am \\\n-\tinstalldirs maintainer-clean maintainer-clean-generic \\\n-\tmostlyclean mostlyclean-compile mostlyclean-generic \\\n-\tmostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \\\n-\tuninstall-am\n+.PHONY: CTAGS GTAGS TAGS all all-am am--depfiles check check-am clean \\\n+\tclean-generic clean-libtool clean-noinstLTLIBRARIES \\\n+\tcscopelist-am ctags ctags-am distclean distclean-compile \\\n+\tdistclean-generic distclean-libtool distclean-tags dvi dvi-am \\\n+\thtml html-am info info-am install install-am install-data \\\n+\tinstall-data-am install-dvi install-dvi-am install-exec \\\n+\tinstall-exec-am install-html install-html-am install-info \\\n+\tinstall-info-am install-man install-pdf install-pdf-am \\\n+\tinstall-ps install-ps-am install-strip installcheck \\\n+\tinstallcheck-am installdirs maintainer-clean \\\n+\tmaintainer-clean-generic mostlyclean mostlyclean-compile \\\n+\tmostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \\\n+\ttags tags-am uninstall uninstall-am\n \n .PRECIOUS: Makefile\n "}, {"sha": "c8ad0a0bcb5c5d8740bb8071b64c704a3651c246", "filename": "libsanitizer/sanitizer_common/sancov_begin.S", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/063082768aab23d26e42954eb115b76318f0176d/libsanitizer%2Fsanitizer_common%2Fsancov_begin.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/063082768aab23d26e42954eb115b76318f0176d/libsanitizer%2Fsanitizer_common%2Fsancov_begin.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsancov_begin.S?ref=063082768aab23d26e42954eb115b76318f0176d", "patch": "@@ -1,5 +0,0 @@\n-\t.type\t\t__start___sancov_guards,@object\n-\t.globl\t\t__start___sancov_guards\n-        .section        __sancov_guards,\"aw\",@progbits\n-        .p2align        2\n-__start___sancov_guards:"}, {"sha": "31117b1c0b56105c3778ebf26d79f5928aecb66d", "filename": "libsanitizer/sanitizer_common/sancov_end.S", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/063082768aab23d26e42954eb115b76318f0176d/libsanitizer%2Fsanitizer_common%2Fsancov_end.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/063082768aab23d26e42954eb115b76318f0176d/libsanitizer%2Fsanitizer_common%2Fsancov_end.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsancov_end.S?ref=063082768aab23d26e42954eb115b76318f0176d", "patch": "@@ -1,5 +0,0 @@\n-\t.type\t\t__stop___sancov_guards,@object\n-\t.globl\t\t__stop___sancov_guards\n-        .section        __sancov_guards,\"aw\",@progbits\n-        .p2align        2\n-__stop___sancov_guards:"}, {"sha": "ed46e88acdfc6c589df9efd7a4093113f972b5e4", "filename": "libsanitizer/sanitizer_common/sancov_flags.cpp", "status": "renamed", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsancov_flags.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsancov_flags.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsancov_flags.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sancov_flags.cc -----------------------------------------*- C++ -*-===//\n+//===-- sancov_flags.cpp ----------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -48,7 +49,7 @@ void InitializeSancovFlags() {\n   RegisterSancovFlags(&parser, f);\n \n   parser.ParseString(MaybeCallSancovDefaultOptions());\n-  parser.ParseString(GetEnv(\"SANCOV_OPTIONS\"));\n+  parser.ParseStringFromEnv(\"SANCOV_OPTIONS\");\n \n   ReportUnrecognizedFlags();\n   if (f->help) parser.PrintFlagDescriptions();", "previous_filename": "libsanitizer/sanitizer_common/sancov_flags.cc"}, {"sha": "95d4ee5ca43d7292b9aeb6af7fd324b2483b919f", "filename": "libsanitizer/sanitizer_common/sancov_flags.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsancov_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsancov_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsancov_flags.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sancov_flags.h ------------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "cca33fc359f4ff59b8e9b2db6379afb1fc9b949d", "filename": "libsanitizer/sanitizer_common/sancov_flags.inc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsancov_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsancov_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsancov_flags.inc?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sancov_flags.inc ----------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "a033e788cbf86595228b02bc34c6e464a4437e39", "filename": "libsanitizer/sanitizer_common/sanitizer_addrhashmap.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_addrhashmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_addrhashmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_addrhashmap.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_addrhashmap.h ---------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "8d07906cca0348d25702c5cd255fa16ee171886f", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.cpp", "status": "renamed", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_allocator.cc --------------------------------------------===//\n+//===-- sanitizer_allocator.cpp -------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -169,6 +170,18 @@ void *InternalRealloc(void *addr, uptr size, InternalAllocatorCache *cache) {\n   return (char*)p + sizeof(u64);\n }\n \n+void *InternalReallocArray(void *addr, uptr count, uptr size,\n+                           InternalAllocatorCache *cache) {\n+  if (UNLIKELY(CheckForCallocOverflow(count, size))) {\n+    Report(\n+        \"FATAL: %s: reallocarray parameters overflow: count * size (%zd * %zd) \"\n+        \"cannot be represented in type size_t\\n\",\n+        SanitizerToolName, count, size);\n+    Die();\n+  }\n+  return InternalRealloc(addr, count * size, cache);\n+}\n+\n void *InternalCalloc(uptr count, uptr size, InternalAllocatorCache *cache) {\n   if (UNLIKELY(CheckForCallocOverflow(count, size))) {\n     Report(\"FATAL: %s: calloc parameters overflow: count * size (%zd * %zd) \"", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_allocator.cc"}, {"sha": "23d589888d3b6280837c6fd6272650633e1cc3ee", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_allocator.h -----------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -12,13 +13,15 @@\n #ifndef SANITIZER_ALLOCATOR_H\n #define SANITIZER_ALLOCATOR_H\n \n-#include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_common.h\"\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_lfstack.h\"\n #include \"sanitizer_libc.h\"\n #include \"sanitizer_list.h\"\n+#include \"sanitizer_local_address_space_view.h\"\n #include \"sanitizer_mutex.h\"\n-#include \"sanitizer_lfstack.h\"\n #include \"sanitizer_procmaps.h\"\n+#include \"sanitizer_type_traits.h\"\n \n namespace __sanitizer {\n "}, {"sha": "0084bb62c83c8063504a5914164cee868934a317", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_bytemap.h", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_bytemap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_bytemap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_bytemap.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_allocator_bytemap.h ---------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -13,9 +14,10 @@\n #endif\n \n // Maps integers in rage [0, kSize) to u8 values.\n-template<u64 kSize>\n+template <u64 kSize, typename AddressSpaceViewTy = LocalAddressSpaceView>\n class FlatByteMap {\n  public:\n+  using AddressSpaceView = AddressSpaceViewTy;\n   void Init() {\n     internal_memset(map_, 0, sizeof(map_));\n   }\n@@ -39,9 +41,12 @@ class FlatByteMap {\n // to kSize2-byte arrays. The secondary arrays are mmaped on demand.\n // Each value is initially zero and can be set to something else only once.\n // Setting and getting values from multiple threads is safe w/o extra locking.\n-template <u64 kSize1, u64 kSize2, class MapUnmapCallback = NoOpMapUnmapCallback>\n+template <u64 kSize1, u64 kSize2,\n+          typename AddressSpaceViewTy = LocalAddressSpaceView,\n+          class MapUnmapCallback = NoOpMapUnmapCallback>\n class TwoLevelByteMap {\n  public:\n+  using AddressSpaceView = AddressSpaceViewTy;\n   void Init() {\n     internal_memset(map1_, 0, sizeof(map1_));\n     mu_.Init();\n@@ -71,7 +76,8 @@ class TwoLevelByteMap {\n     CHECK_LT(idx, kSize1 * kSize2);\n     u8 *map2 = Get(idx / kSize2);\n     if (!map2) return 0;\n-    return map2[idx % kSize2];\n+    auto value_ptr = AddressSpaceView::Load(&map2[idx % kSize2]);\n+    return *value_ptr;\n   }\n \n  private:\n@@ -98,3 +104,4 @@ class TwoLevelByteMap {\n   atomic_uintptr_t map1_[kSize1];\n   StaticSpinMutex mu_;\n };\n+"}, {"sha": "9d67f679b56cb996e8fa5a7b649a48c5f1fbb048", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_checks.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_checks.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_checks.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_checks.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_allocator_checks.cc ---------------------------*- C++ -*-===//\n+//===-- sanitizer_allocator_checks.cpp --------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_allocator_checks.cc"}, {"sha": "f436ce9ecdea402fff83958bc66a107de2185b5b", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_checks.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_checks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_checks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_checks.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_allocator_checks.h ----------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "33f89d6d49928c1bfb4d8f1ed0286b51a745cac9", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_combined.h", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_combined.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_combined.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_combined.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_allocator_combined.h --------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -18,20 +19,26 @@\n //  When allocating 2^x bytes it should return 2^x aligned chunk.\n // PrimaryAllocator is used via a local AllocatorCache.\n // SecondaryAllocator can allocate anything, but is not efficient.\n-template <class PrimaryAllocator, class AllocatorCache,\n-          class SecondaryAllocator>  // NOLINT\n+template <class PrimaryAllocator,\n+          class LargeMmapAllocatorPtrArray = DefaultLargeMmapAllocatorPtrArray>\n class CombinedAllocator {\n  public:\n+  using AllocatorCache = typename PrimaryAllocator::AllocatorCache;\n+  using SecondaryAllocator =\n+      LargeMmapAllocator<typename PrimaryAllocator::MapUnmapCallback,\n+                         LargeMmapAllocatorPtrArray,\n+                         typename PrimaryAllocator::AddressSpaceView>;\n+\n   void InitLinkerInitialized(s32 release_to_os_interval_ms) {\n+    stats_.InitLinkerInitialized();\n     primary_.Init(release_to_os_interval_ms);\n     secondary_.InitLinkerInitialized();\n-    stats_.InitLinkerInitialized();\n   }\n \n   void Init(s32 release_to_os_interval_ms) {\n+    stats_.Init();\n     primary_.Init(release_to_os_interval_ms);\n     secondary_.Init();\n-    stats_.Init();\n   }\n \n   void *Allocate(AllocatorCache *cache, uptr size, uptr alignment) {"}, {"sha": "c1b27563e2fc7023f60d85a06903fd7bd9991828", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_interface.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_interface.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_allocator_interface.h ------------------------- C++ -----===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "32849036fd04b3a4b547172c0fcacc5d9ef1b142", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_internal.h", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_allocator_internal.h --------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -21,41 +22,30 @@ namespace __sanitizer {\n // purposes.\n typedef CompactSizeClassMap InternalSizeClassMap;\n \n-static const uptr kInternalAllocatorRegionSizeLog = 20;\n-static const uptr kInternalAllocatorNumRegions =\n-    SANITIZER_MMAP_RANGE_SIZE >> kInternalAllocatorRegionSizeLog;\n-#if SANITIZER_WORDSIZE == 32\n-typedef FlatByteMap<kInternalAllocatorNumRegions> ByteMap;\n-#else\n-typedef TwoLevelByteMap<(kInternalAllocatorNumRegions >> 12), 1 << 12> ByteMap;\n-#endif\n struct AP32 {\n   static const uptr kSpaceBeg = 0;\n   static const u64 kSpaceSize = SANITIZER_MMAP_RANGE_SIZE;\n   static const uptr kMetadataSize = 0;\n   typedef InternalSizeClassMap SizeClassMap;\n-  static const uptr kRegionSizeLog = kInternalAllocatorRegionSizeLog;\n-  typedef __sanitizer::ByteMap ByteMap;\n+  static const uptr kRegionSizeLog = 20;\n+  using AddressSpaceView = LocalAddressSpaceView;\n   typedef NoOpMapUnmapCallback MapUnmapCallback;\n   static const uptr kFlags = 0;\n };\n typedef SizeClassAllocator32<AP32> PrimaryInternalAllocator;\n \n-typedef SizeClassAllocatorLocalCache<PrimaryInternalAllocator>\n-    InternalAllocatorCache;\n-\n-typedef LargeMmapAllocator<NoOpMapUnmapCallback,\n-                           LargeMmapAllocatorPtrArrayStatic>\n-    SecondaryInternalAllocator;\n-\n-typedef CombinedAllocator<PrimaryInternalAllocator, InternalAllocatorCache,\n-                          SecondaryInternalAllocator> InternalAllocator;\n+typedef CombinedAllocator<PrimaryInternalAllocator,\n+                          LargeMmapAllocatorPtrArrayStatic>\n+    InternalAllocator;\n+typedef InternalAllocator::AllocatorCache InternalAllocatorCache;\n \n void *InternalAlloc(uptr size, InternalAllocatorCache *cache = nullptr,\n                     uptr alignment = 0);\n void *InternalRealloc(void *p, uptr size,\n                       InternalAllocatorCache *cache = nullptr);\n-void *InternalCalloc(uptr countr, uptr size,\n+void *InternalReallocArray(void *p, uptr count, uptr size,\n+                           InternalAllocatorCache *cache = nullptr);\n+void *InternalCalloc(uptr count, uptr size,\n                      InternalAllocatorCache *cache = nullptr);\n void InternalFree(void *p, InternalAllocatorCache *cache = nullptr);\n InternalAllocator *internal_allocator();"}, {"sha": "108dfc231a22795220187979925c01c144bbe10e", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_local_cache.h", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_local_cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_local_cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_local_cache.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_allocator_local_cache.h -----------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -12,13 +13,6 @@\n #error This file must be included inside sanitizer_allocator.h\n #endif\n \n-// Objects of this type should be used as local caches for SizeClassAllocator64\n-// or SizeClassAllocator32. Since the typical use of this class is to have one\n-// object per thread in TLS, is has to be POD.\n-template<class SizeClassAllocator>\n-struct SizeClassAllocatorLocalCache\n-    : SizeClassAllocator::AllocatorCache {};\n-\n // Cache used by SizeClassAllocator64.\n template <class SizeClassAllocator>\n struct SizeClassAllocator64LocalCache {"}, {"sha": "3b1838b3985ac1ebb6df2b6c5dc5bc5d09e4b201", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_primary32.h", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_allocator_primary32.h -------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -45,14 +46,24 @@ struct SizeClassAllocator32FlagMasks {  //  Bit masks.\n \n template <class Params>\n class SizeClassAllocator32 {\n+ private:\n+  static const u64 kTwoLevelByteMapSize1 =\n+      (Params::kSpaceSize >> Params::kRegionSizeLog) >> 12;\n+  static const u64 kMinFirstMapSizeTwoLevelByteMap = 4;\n+\n  public:\n+  using AddressSpaceView = typename Params::AddressSpaceView;\n   static const uptr kSpaceBeg = Params::kSpaceBeg;\n   static const u64 kSpaceSize = Params::kSpaceSize;\n   static const uptr kMetadataSize = Params::kMetadataSize;\n   typedef typename Params::SizeClassMap SizeClassMap;\n   static const uptr kRegionSizeLog = Params::kRegionSizeLog;\n-  typedef typename Params::ByteMap ByteMap;\n   typedef typename Params::MapUnmapCallback MapUnmapCallback;\n+  using ByteMap = typename conditional<\n+      (kTwoLevelByteMapSize1 < kMinFirstMapSizeTwoLevelByteMap),\n+      FlatByteMap<(Params::kSpaceSize >> Params::kRegionSizeLog),\n+                  AddressSpaceView>,\n+      TwoLevelByteMap<kTwoLevelByteMapSize1, 1 << 12, AddressSpaceView>>::type;\n \n   COMPILER_CHECK(!SANITIZER_SIGN_EXTENDED_ADDRESSES ||\n                  (kSpaceSize & (kSpaceSize - 1)) == 0);\n@@ -205,7 +216,7 @@ class SizeClassAllocator32 {\n     return ClassIdToSize(GetSizeClass(p));\n   }\n \n-  uptr ClassID(uptr size) { return SizeClassMap::ClassID(size); }\n+  static uptr ClassID(uptr size) { return SizeClassMap::ClassID(size); }\n \n   uptr TotalMemoryUsed() {\n     // No need to lock here.\n@@ -271,7 +282,7 @@ class SizeClassAllocator32 {\n   };\n   COMPILER_CHECK(sizeof(SizeClassInfo) % kCacheLineSize == 0);\n \n-  uptr ComputeRegionId(uptr mem) {\n+  uptr ComputeRegionId(uptr mem) const {\n     if (SANITIZER_SIGN_EXTENDED_ADDRESSES)\n       mem &= (kSpaceSize - 1);\n     const uptr res = mem >> kRegionSizeLog;"}, {"sha": "90603280e7c9558050675185bc8b157bb9281e56", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_primary64.h", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_allocator_primary64.h -------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -44,6 +45,7 @@ struct SizeClassAllocator64FlagMasks {  //  Bit masks.\n template <class Params>\n class SizeClassAllocator64 {\n  public:\n+  using AddressSpaceView = typename Params::AddressSpaceView;\n   static const uptr kSpaceBeg = Params::kSpaceBeg;\n   static const uptr kSpaceSize = Params::kSpaceSize;\n   static const uptr kMetadataSize = Params::kMetadataSize;\n@@ -78,7 +80,8 @@ class SizeClassAllocator64 {\n       CHECK_NE(NonConstSpaceBeg, ~(uptr)0);\n     }\n     SetReleaseToOSIntervalMs(release_to_os_interval_ms);\n-    MapWithCallbackOrDie(SpaceEnd(), AdditionalSize());\n+    MapWithCallbackOrDie(SpaceEnd(), AdditionalSize(),\n+                         \"SizeClassAllocator: region info\");\n     // Check that the RegionInfo array is aligned on the CacheLine size.\n     DCHECK_EQ(SpaceEnd() % kCacheLineSize, 0);\n   }\n@@ -151,7 +154,7 @@ class SizeClassAllocator64 {\n     return true;\n   }\n \n-  bool PointerIsMine(const void *p) {\n+  bool PointerIsMine(const void *p) const {\n     uptr P = reinterpret_cast<uptr>(p);\n     if (kUsingConstantSpaceBeg && (kSpaceBeg % kSpaceSize) == 0)\n       return P / kSpaceSize == kSpaceBeg / kSpaceSize;\n@@ -186,7 +189,7 @@ class SizeClassAllocator64 {\n     uptr beg = chunk_idx * size;\n     uptr next_beg = beg + size;\n     if (class_id >= kNumClasses) return nullptr;\n-    RegionInfo *region = GetRegionInfo(class_id);\n+    const RegionInfo *region = AddressSpaceView::Load(GetRegionInfo(class_id));\n     if (region->mapped_user >= next_beg)\n       return reinterpret_cast<void*>(reg_beg + beg);\n     return nullptr;\n@@ -197,7 +200,7 @@ class SizeClassAllocator64 {\n     return ClassIdToSize(GetSizeClass(p));\n   }\n \n-  uptr ClassID(uptr size) { return SizeClassMap::ClassID(size); }\n+  static uptr ClassID(uptr size) { return SizeClassMap::ClassID(size); }\n \n   void *GetMetaData(const void *p) {\n     uptr class_id = GetSizeClass(p);\n@@ -292,8 +295,10 @@ class SizeClassAllocator64 {\n       RegionInfo *region = GetRegionInfo(class_id);\n       uptr chunk_size = ClassIdToSize(class_id);\n       uptr region_beg = SpaceBeg() + class_id * kRegionSize;\n+      uptr region_allocated_user_size =\n+          AddressSpaceView::Load(region)->allocated_user;\n       for (uptr chunk = region_beg;\n-           chunk < region_beg + region->allocated_user;\n+           chunk < region_beg + region_allocated_user_size;\n            chunk += chunk_size) {\n         // Too slow: CHECK_EQ((void *)chunk, GetBlockBegin((void *)chunk));\n         callback(chunk, arg);\n@@ -629,17 +634,17 @@ class SizeClassAllocator64 {\n     return reinterpret_cast<CompactPtrT *>(GetMetadataEnd(region_beg));\n   }\n \n-  bool MapWithCallback(uptr beg, uptr size) {\n-    uptr mapped = address_range.Map(beg, size);\n+  bool MapWithCallback(uptr beg, uptr size, const char *name) {\n+    uptr mapped = address_range.Map(beg, size, name);\n     if (UNLIKELY(!mapped))\n       return false;\n     CHECK_EQ(beg, mapped);\n     MapUnmapCallback().OnMap(beg, size);\n     return true;\n   }\n \n-  void MapWithCallbackOrDie(uptr beg, uptr size) {\n-    CHECK_EQ(beg, address_range.MapOrDie(beg, size));\n+  void MapWithCallbackOrDie(uptr beg, uptr size, const char *name) {\n+    CHECK_EQ(beg, address_range.MapOrDie(beg, size, name));\n     MapUnmapCallback().OnMap(beg, size);\n   }\n \n@@ -657,7 +662,8 @@ class SizeClassAllocator64 {\n       uptr current_map_end = reinterpret_cast<uptr>(GetFreeArray(region_beg)) +\n                              region->mapped_free_array;\n       uptr new_map_size = new_mapped_free_array - region->mapped_free_array;\n-      if (UNLIKELY(!MapWithCallback(current_map_end, new_map_size)))\n+      if (UNLIKELY(!MapWithCallback(current_map_end, new_map_size,\n+                                    \"SizeClassAllocator: freearray\")))\n         return false;\n       region->mapped_free_array = new_mapped_free_array;\n     }\n@@ -708,7 +714,8 @@ class SizeClassAllocator64 {\n       if (UNLIKELY(IsRegionExhausted(region, class_id, user_map_size)))\n         return false;\n       if (UNLIKELY(!MapWithCallback(region_beg + region->mapped_user,\n-                                    user_map_size)))\n+                                    user_map_size,\n+                                    \"SizeClassAllocator: region data\")))\n         return false;\n       stat->Add(AllocatorStatMapped, user_map_size);\n       region->mapped_user += user_map_size;\n@@ -728,7 +735,7 @@ class SizeClassAllocator64 {\n           return false;\n         if (UNLIKELY(!MapWithCallback(\n             GetMetadataEnd(region_beg) - region->mapped_meta - meta_map_size,\n-            meta_map_size)))\n+            meta_map_size, \"SizeClassAllocator: region metadata\")))\n           return false;\n         region->mapped_meta += meta_map_size;\n       }"}, {"sha": "dbcf2b7bf260da261f6e994694f045c2583bc13d", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_report.cpp", "status": "renamed", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_report.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_allocator_report.cc ---------------------------*- C++ -*-===//\n+//===-- sanitizer_allocator_report.cpp --------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n ///\n@@ -50,6 +51,18 @@ void NORETURN ReportCallocOverflow(uptr count, uptr size,\n   Die();\n }\n \n+void NORETURN ReportReallocArrayOverflow(uptr count, uptr size,\n+                                         const StackTrace *stack) {\n+  {\n+    ScopedAllocatorErrorReport report(\"reallocarray-overflow\", stack);\n+    Report(\n+        \"ERROR: %s: reallocarray parameters overflow: count * size (%zd * %zd) \"\n+        \"cannot be represented in type size_t\\n\",\n+        SanitizerToolName, count, size);\n+  }\n+  Die();\n+}\n+\n void NORETURN ReportPvallocOverflow(uptr size, const StackTrace *stack) {\n   {\n     ScopedAllocatorErrorReport report(\"pvalloc-overflow\", stack);", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_allocator_report.cc"}, {"sha": "0653c365c1cd468added86c54b63f4af94f80a59", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_report.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_report.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_allocator_report.h ----------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n ///\n@@ -20,6 +21,8 @@ namespace __sanitizer {\n \n void NORETURN ReportCallocOverflow(uptr count, uptr size,\n                                    const StackTrace *stack);\n+void NORETURN ReportReallocArrayOverflow(uptr count, uptr size,\n+                                         const StackTrace *stack);\n void NORETURN ReportPvallocOverflow(uptr size, const StackTrace *stack);\n void NORETURN ReportInvalidAllocationAlignment(uptr alignment,\n                                                const StackTrace *stack);"}, {"sha": "1d128f55de05a56931fda376837dfd643fd9953e", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_secondary.h", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_secondary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_secondary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_secondary.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_allocator_secondary.h -------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -66,9 +67,11 @@ typedef LargeMmapAllocatorPtrArrayDynamic DefaultLargeMmapAllocatorPtrArray;\n // The main purpose of this allocator is to cover large and rare allocation\n // sizes not covered by more efficient allocators (e.g. SizeClassAllocator64).\n template <class MapUnmapCallback = NoOpMapUnmapCallback,\n-          class PtrArrayT = DefaultLargeMmapAllocatorPtrArray>\n+          class PtrArrayT = DefaultLargeMmapAllocatorPtrArray,\n+          class AddressSpaceViewTy = LocalAddressSpaceView>\n class LargeMmapAllocator {\n  public:\n+  using AddressSpaceView = AddressSpaceViewTy;\n   void InitLinkerInitialized() {\n     page_size_ = GetPageSizeCached();\n     chunks_ = reinterpret_cast<Header**>(ptr_array_.Init());\n@@ -180,29 +183,33 @@ class LargeMmapAllocator {\n     uptr p = reinterpret_cast<uptr>(ptr);\n     SpinMutexLock l(&mutex_);\n     uptr nearest_chunk = 0;\n+    Header *const *chunks = AddressSpaceView::Load(chunks_, n_chunks_);\n     // Cache-friendly linear search.\n     for (uptr i = 0; i < n_chunks_; i++) {\n-      uptr ch = reinterpret_cast<uptr>(chunks_[i]);\n+      uptr ch = reinterpret_cast<uptr>(chunks[i]);\n       if (p < ch) continue;  // p is at left to this chunk, skip it.\n       if (p - ch < p - nearest_chunk)\n         nearest_chunk = ch;\n     }\n     if (!nearest_chunk)\n       return nullptr;\n-    Header *h = reinterpret_cast<Header *>(nearest_chunk);\n+    const Header *h =\n+        AddressSpaceView::Load(reinterpret_cast<Header *>(nearest_chunk));\n+    Header *h_ptr = reinterpret_cast<Header *>(nearest_chunk);\n     CHECK_GE(nearest_chunk, h->map_beg);\n     CHECK_LT(nearest_chunk, h->map_beg + h->map_size);\n     CHECK_LE(nearest_chunk, p);\n     if (h->map_beg + h->map_size <= p)\n       return nullptr;\n-    return GetUser(h);\n+    return GetUser(h_ptr);\n   }\n \n   void EnsureSortedChunks() {\n     if (chunks_sorted_) return;\n-    Sort(reinterpret_cast<uptr *>(chunks_), n_chunks_);\n+    Header **chunks = AddressSpaceView::LoadWritable(chunks_, n_chunks_);\n+    Sort(reinterpret_cast<uptr *>(chunks), n_chunks_);\n     for (uptr i = 0; i < n_chunks_; i++)\n-      chunks_[i]->chunk_idx = i;\n+      AddressSpaceView::LoadWritable(chunks[i])->chunk_idx = i;\n     chunks_sorted_ = true;\n   }\n \n@@ -214,33 +221,35 @@ class LargeMmapAllocator {\n     uptr n = n_chunks_;\n     if (!n) return nullptr;\n     EnsureSortedChunks();\n-    auto min_mmap_ = reinterpret_cast<uptr>(chunks_[0]);\n-    auto max_mmap_ =\n-        reinterpret_cast<uptr>(chunks_[n - 1]) + chunks_[n - 1]->map_size;\n+    Header *const *chunks = AddressSpaceView::Load(chunks_, n_chunks_);\n+    auto min_mmap_ = reinterpret_cast<uptr>(chunks[0]);\n+    auto max_mmap_ = reinterpret_cast<uptr>(chunks[n - 1]) +\n+                     AddressSpaceView::Load(chunks[n - 1])->map_size;\n     if (p < min_mmap_ || p >= max_mmap_)\n       return nullptr;\n     uptr beg = 0, end = n - 1;\n     // This loop is a log(n) lower_bound. It does not check for the exact match\n     // to avoid expensive cache-thrashing loads.\n     while (end - beg >= 2) {\n       uptr mid = (beg + end) / 2;  // Invariant: mid >= beg + 1\n-      if (p < reinterpret_cast<uptr>(chunks_[mid]))\n-        end = mid - 1;  // We are not interested in chunks_[mid].\n+      if (p < reinterpret_cast<uptr>(chunks[mid]))\n+        end = mid - 1;  // We are not interested in chunks[mid].\n       else\n-        beg = mid;  // chunks_[mid] may still be what we want.\n+        beg = mid;  // chunks[mid] may still be what we want.\n     }\n \n     if (beg < end) {\n       CHECK_EQ(beg + 1, end);\n       // There are 2 chunks left, choose one.\n-      if (p >= reinterpret_cast<uptr>(chunks_[end]))\n+      if (p >= reinterpret_cast<uptr>(chunks[end]))\n         beg = end;\n     }\n \n-    Header *h = chunks_[beg];\n+    const Header *h = AddressSpaceView::Load(chunks[beg]);\n+    Header *h_ptr = chunks[beg];\n     if (h->map_beg + h->map_size <= p || p < h->map_beg)\n       return nullptr;\n-    return GetUser(h);\n+    return GetUser(h_ptr);\n   }\n \n   void PrintStats() {\n@@ -270,12 +279,13 @@ class LargeMmapAllocator {\n   // The allocator must be locked when calling this function.\n   void ForEachChunk(ForEachChunkCallback callback, void *arg) {\n     EnsureSortedChunks();  // Avoid doing the sort while iterating.\n+    const Header *const *chunks = AddressSpaceView::Load(chunks_, n_chunks_);\n     for (uptr i = 0; i < n_chunks_; i++) {\n-      auto t = chunks_[i];\n+      const Header *t = chunks[i];\n       callback(reinterpret_cast<uptr>(GetUser(t)), arg);\n       // Consistency check: verify that the array did not change.\n-      CHECK_EQ(chunks_[i], t);\n-      CHECK_EQ(chunks_[i]->chunk_idx, i);\n+      CHECK_EQ(chunks[i], t);\n+      CHECK_EQ(AddressSpaceView::Load(chunks[i])->chunk_idx, i);\n     }\n   }\n \n@@ -295,7 +305,7 @@ class LargeMmapAllocator {\n     return GetHeader(reinterpret_cast<uptr>(p));\n   }\n \n-  void *GetUser(Header *h) {\n+  void *GetUser(const Header *h) {\n     CHECK(IsAligned((uptr)h, page_size_));\n     return reinterpret_cast<void*>(reinterpret_cast<uptr>(h) + page_size_);\n   }"}, {"sha": "12d8c8923071d6953d46e1f5cfe23b4fbfd5bc76", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_size_class_map.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_size_class_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_size_class_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_size_class_map.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_allocator_size_class_map.h --------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -235,3 +236,6 @@ typedef SizeClassMap<2, 5, 9, 16, 64, 14> VeryCompactSizeClassMap;\n // allowing for denser per-class arrays, smaller memory footprint and usually\n // better performances in threaded environments.\n typedef SizeClassMap<3, 4, 8, 17, 8, 10> DenseSizeClassMap;\n+// Similar to VeryCompact map above, this one has a small number of different\n+// size classes, and also reduced thread-local caches.\n+typedef SizeClassMap<2, 5, 9, 16, 8, 10> VeryDenseSizeClassMap;"}, {"sha": "6f14e3863c31cc236814052bba0e587499092332", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_stats.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_stats.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_stats.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_stats.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_allocator_stats.h -----------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -101,3 +102,5 @@ class AllocatorGlobalStats : public AllocatorStats {\n  private:\n   mutable StaticSpinMutex mu_;\n };\n+\n+"}, {"sha": "184d118d97d81a1786bf34e6e8deaf109dd49538", "filename": "libsanitizer/sanitizer_common/sanitizer_asm.h", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_asm.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_asm.h -----------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -43,14 +44,23 @@\n \n #if !defined(__APPLE__)\n # define ASM_HIDDEN(symbol) .hidden symbol\n-# define ASM_TYPE_FUNCTION(symbol) .type symbol, @function\n+# define ASM_TYPE_FUNCTION(symbol) .type symbol, %function\n # define ASM_SIZE(symbol) .size symbol, .-symbol\n # define ASM_SYMBOL(symbol) symbol\n # define ASM_SYMBOL_INTERCEPTOR(symbol) symbol\n+# define ASM_WRAPPER_NAME(symbol) __interceptor_##symbol\n #else\n # define ASM_HIDDEN(symbol)\n # define ASM_TYPE_FUNCTION(symbol)\n # define ASM_SIZE(symbol)\n # define ASM_SYMBOL(symbol) _##symbol\n # define ASM_SYMBOL_INTERCEPTOR(symbol) _wrap_##symbol\n+# define ASM_WRAPPER_NAME(symbol) __interceptor_##symbol\n+#endif\n+\n+#if defined(__ELF__) && (defined(__GNU__) || defined(__FreeBSD__) || \\\n+                         defined(__Fuchsia__) || defined(__linux__))\n+#define NO_EXEC_STACK_DIRECTIVE .section .note.GNU-stack,\"\",%progbits // NOLINT\n+#else\n+#define NO_EXEC_STACK_DIRECTIVE\n #endif"}, {"sha": "a798a0cf25d9ce02ab540b4a4a9f9c69b6976dfc", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_atomic.h --------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "c40461ebc3bf64534adbb886da321b32c587bb75", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_clang.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_atomic_clang.h --------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "d369aeb9935c663981e67527ebfc2cbec9066eaa", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_clang_mips.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_mips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_mips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_mips.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_atomic_clang_mips.h ---------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -113,3 +114,4 @@ INLINE void atomic_store(volatile atomic_uint64_t *ptr, atomic_uint64_t::Type v,\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_ATOMIC_CLANG_MIPS_H\n+"}, {"sha": "b8685a8542676ea65c26a0c58e40c003298f489f", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_clang_other.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_other.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_other.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_other.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_atomic_clang_other.h --------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "f2ce553baa7a14813d642d6e9d3b0ffde45766f0", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_clang_x86.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_x86.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_x86.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang_x86.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_atomic_clang_x86.h ----------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "a249657d66170ae7c962b996d7caff838f6b007c", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_msvc.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_atomic_msvc.h ---------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "07a59ab11c4293a785d1e0df138cc6a50d113bb2", "filename": "libsanitizer/sanitizer_common/sanitizer_bitvector.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_bitvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_bitvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_bitvector.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_bitvector.h -----------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "e7249055bee643b7015ea7c170b6a97fdfd702cd", "filename": "libsanitizer/sanitizer_common/sanitizer_bvgraph.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_bvgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_bvgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_bvgraph.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_bvgraph.h -------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "451c9e526e061321a5fc1b70fae9009537868dca", "filename": "libsanitizer/sanitizer_common/sanitizer_common.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_common.cc -----------------------------------------------===//\n+//===-- sanitizer_common.cpp ----------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_common.cc"}, {"sha": "4f0f16d353280612bdd322546032d5c564538d10", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_common.h --------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -59,13 +60,23 @@ INLINE int Verbosity() {\n   return atomic_load(&current_verbosity, memory_order_relaxed);\n }\n \n+#if SANITIZER_ANDROID\n+INLINE uptr GetPageSize() {\n+// Android post-M sysconf(_SC_PAGESIZE) crashes if called from .preinit_array.\n+  return 4096;\n+}\n+INLINE uptr GetPageSizeCached() {\n+  return 4096;\n+}\n+#else\n uptr GetPageSize();\n extern uptr PageSizeCached;\n INLINE uptr GetPageSizeCached() {\n   if (!PageSizeCached)\n     PageSizeCached = GetPageSize();\n   return PageSizeCached;\n }\n+#endif\n uptr GetMmapGranularity();\n uptr GetMaxVirtualAddress();\n uptr GetMaxUserVirtualAddress();\n@@ -90,10 +101,11 @@ void *MmapOrDieOnFatalError(uptr size, const char *mem_type);\n bool MmapFixedNoReserve(uptr fixed_addr, uptr size, const char *name = nullptr)\n      WARN_UNUSED_RESULT;\n void *MmapNoReserveOrDie(uptr size, const char *mem_type);\n-void *MmapFixedOrDie(uptr fixed_addr, uptr size);\n+void *MmapFixedOrDie(uptr fixed_addr, uptr size, const char *name = nullptr);\n // Behaves just like MmapFixedOrDie, but tolerates out of memory condition, in\n // that case returns nullptr.\n-void *MmapFixedOrDieOnFatalError(uptr fixed_addr, uptr size);\n+void *MmapFixedOrDieOnFatalError(uptr fixed_addr, uptr size,\n+                                 const char *name = nullptr);\n void *MmapFixedNoAccess(uptr fixed_addr, uptr size, const char *name = nullptr);\n void *MmapNoAccess(uptr size);\n // Map aligned chunk of address space; size and alignment are powers of two.\n@@ -119,7 +131,7 @@ void ReleaseMemoryPagesToOS(uptr beg, uptr end);\n void IncreaseTotalMmap(uptr size);\n void DecreaseTotalMmap(uptr size);\n uptr GetRSS();\n-bool NoHugePagesInRegion(uptr addr, uptr length);\n+void SetShadowRegionHugePageMode(uptr addr, uptr length);\n bool DontDumpShadowMemory(uptr addr, uptr length);\n // Check if the built VMA size matches the runtime one.\n void CheckVMASize();\n@@ -129,8 +141,8 @@ void RunFreeHooks(const void *ptr);\n class ReservedAddressRange {\n  public:\n   uptr Init(uptr size, const char *name = nullptr, uptr fixed_addr = 0);\n-  uptr Map(uptr fixed_addr, uptr size);\n-  uptr MapOrDie(uptr fixed_addr, uptr size);\n+  uptr Map(uptr fixed_addr, uptr size, const char *name = nullptr);\n+  uptr MapOrDie(uptr fixed_addr, uptr size, const char *name = nullptr);\n   void Unmap(uptr addr, uptr size);\n   void *base() const { return base_; }\n   uptr size() const { return size_; }\n@@ -221,10 +233,11 @@ bool SetEnv(const char *name, const char *value);\n u32 GetUid();\n void ReExec();\n void CheckASLR();\n+void CheckMPROTECT();\n char **GetArgv();\n+char **GetEnviron();\n void PrintCmdline();\n bool StackSizeIsUnlimited();\n-uptr GetStackSizeLimitInBytes();\n void SetStackSizeLimitInBytes(uptr limit);\n bool AddressSpaceIsUnlimited();\n void SetAddressSpaceUnlimited();\n@@ -656,7 +669,7 @@ bool ReadFileToBuffer(const char *file_name, char **buff, uptr *buff_size,\n                       error_t *errno_p = nullptr);\n \n // When adding a new architecture, don't forget to also update\n-// script/asan_symbolize.py and sanitizer_symbolizer_libcdep.cc.\n+// script/asan_symbolize.py and sanitizer_symbolizer_libcdep.cpp.\n inline const char *ModuleArchToString(ModuleArch arch) {\n   switch (arch) {\n     case kModuleArchUnknown:\n@@ -790,7 +803,13 @@ enum AndroidApiLevel {\n \n void WriteToSyslog(const char *buffer);\n \n-#if SANITIZER_MAC\n+#if defined(SANITIZER_WINDOWS) && defined(_MSC_VER) && !defined(__clang__)\n+#define SANITIZER_WIN_TRACE 1\n+#else\n+#define SANITIZER_WIN_TRACE 0\n+#endif\n+\n+#if SANITIZER_MAC || SANITIZER_WIN_TRACE\n void LogFullErrorReport(const char *buffer);\n #else\n INLINE void LogFullErrorReport(const char *buffer) {}\n@@ -804,7 +823,7 @@ INLINE void WriteOneLineToSyslog(const char *s) {}\n INLINE void LogMessageOnPrintf(const char *str) {}\n #endif\n \n-#if SANITIZER_LINUX\n+#if SANITIZER_LINUX || SANITIZER_WIN_TRACE\n // Initialize Android logging. Any writes before this are silently lost.\n void AndroidLogInit();\n void SetAbortMessage(const char *);\n@@ -895,6 +914,7 @@ struct SignalContext {\n   bool IsMemoryAccess() const;\n };\n \n+void InitializePlatformEarly();\n void MaybeReexec();\n \n template <typename Fn>"}, {"sha": "9975f5321a59b25b60d6f7f8151ab5a3a4d840a2", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc", "status": "modified", "additions": 2501, "deletions": 119, "changes": 2620, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0"}, {"sha": "bbbedda8fbe212b6e3cacb3d36388dc2341098db", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_format.inc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_format.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_format.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_format.inc?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_common_interceptors_format.inc ----------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "490a04b2181b0996e65a3ded3a04d572c47e0c81", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_ioctl.inc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_common_interceptors_ioctl.inc -----------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "20f42f1ea94edee48bd8a9da01be96d596fe312a", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_vfork_aarch64.inc.S", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_aarch64.inc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_aarch64.inc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_aarch64.inc.S?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -0,0 +1,43 @@\n+#if defined(__aarch64__) && defined(__linux__)\n+\n+#include \"sanitizer_common/sanitizer_asm.h\"\n+\n+ASM_HIDDEN(COMMON_INTERCEPTOR_SPILL_AREA)\n+\n+.comm _ZN14__interception10real_vforkE,8,8\n+.globl ASM_WRAPPER_NAME(vfork)\n+ASM_TYPE_FUNCTION(ASM_WRAPPER_NAME(vfork))\n+ASM_WRAPPER_NAME(vfork):\n+        // Save x30 in the off-stack spill area.\n+        stp     xzr, x30, [sp, #-16]!\n+        bl      COMMON_INTERCEPTOR_SPILL_AREA\n+        ldp     xzr, x30, [sp], 16\n+        str     x30, [x0]\n+\n+        // Call real vfork. This may return twice. User code that runs between the first and the second return\n+        // may clobber the stack frame of the interceptor; that's why it does not have a frame.\n+        adrp    x0, _ZN14__interception10real_vforkE\n+        ldr     x0, [x0, :lo12:_ZN14__interception10real_vforkE]\n+        blr     x0\n+\n+        stp     x0, xzr, [sp, #-16]!\n+        cmp     x0, #0\n+        b.eq   .L_exit\n+\n+        // x0 != 0 => parent process. Clear stack shadow.\n+        add    x0, sp, #16\n+        bl     COMMON_INTERCEPTOR_HANDLE_VFORK\n+\n+.L_exit:\n+        // Restore x30.\n+        bl     COMMON_INTERCEPTOR_SPILL_AREA\n+        ldr    x30, [x0]\n+        ldp    x0, xzr, [sp], 16\n+\n+        ret\n+ASM_SIZE(vfork)\n+\n+.weak vfork\n+.set vfork, ASM_WRAPPER_NAME(vfork)\n+\n+#endif"}, {"sha": "780a9d46e26a09fe6236080a72e472c036a7abb6", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_vfork_arm.inc.S", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_arm.inc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_arm.inc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_arm.inc.S?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -0,0 +1,49 @@\n+#if defined(__arm__) && defined(__linux__)\n+\n+#include \"sanitizer_common/sanitizer_asm.h\"\n+\n+ASM_HIDDEN(COMMON_INTERCEPTOR_SPILL_AREA)\n+\n+.comm _ZN14__interception10real_vforkE,4,4\n+.globl ASM_WRAPPER_NAME(vfork)\n+ASM_TYPE_FUNCTION(ASM_WRAPPER_NAME(vfork))\n+ASM_WRAPPER_NAME(vfork):\n+        // Save LR in the off-stack spill area.\n+        push    {r4, lr}\n+        bl      COMMON_INTERCEPTOR_SPILL_AREA\n+        pop     {r4, lr}\n+        str     lr, [r0]\n+\n+        // Call real vfork. This may return twice. User code that runs between the first and the second return\n+        // may clobber the stack frame of the interceptor; that's why it does not have a frame.\n+        ldr     r0, .LCPI0_0\n+.LPC0_0:\n+        ldr     r0, [pc, r0]\n+        mov     lr, pc\n+        bx      r0\n+\n+        push    {r0, r4}\n+        cmp     r0, #0\n+        beq     .L_exit\n+\n+        // r0 != 0 => parent process. Clear stack shadow.\n+        add     r0, sp, #8\n+        bl      COMMON_INTERCEPTOR_HANDLE_VFORK\n+\n+.L_exit:\n+        // Restore LR.\n+        bl      COMMON_INTERCEPTOR_SPILL_AREA\n+        ldr     lr, [r0]\n+        pop     {r0, r4}\n+\n+        mov     pc, lr\n+\n+.LCPI0_0:\n+        .long   _ZN14__interception10real_vforkE - (.LPC0_0+8)\n+\n+ASM_SIZE(vfork)\n+\n+.weak vfork\n+.set vfork, ASM_WRAPPER_NAME(vfork)\n+\n+#endif"}, {"sha": "ed693819c6d4d7c3f896db919399334f24c7fbf6", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_vfork_i386.inc.S", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_i386.inc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_i386.inc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_i386.inc.S?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -0,0 +1,63 @@\n+#if defined(__i386__) && defined(__linux__)\n+\n+#include \"sanitizer_common/sanitizer_asm.h\"\n+\n+.comm _ZN14__interception10real_vforkE,4,4\n+.globl ASM_WRAPPER_NAME(vfork)\n+ASM_TYPE_FUNCTION(ASM_WRAPPER_NAME(vfork))\n+ASM_WRAPPER_NAME(vfork):\n+        // Store return address in the spill area and tear down the stack frame.\n+        sub     $12, %esp\n+        call    COMMON_INTERCEPTOR_SPILL_AREA\n+        mov     12(%esp), %ecx\n+        mov     %ecx, (%eax)\n+        add     $16, %esp\n+\n+        call    .L0$pb\n+.L0$pb:\n+        pop     %eax\n+.Ltmp0:\n+        add     $_GLOBAL_OFFSET_TABLE_+(.Ltmp0-.L0$pb), %eax\n+        call    *_ZN14__interception10real_vforkE@GOTOFF(%eax)\n+\n+        // Restore the stack frame.\n+        // 12(%esp) return address\n+        // 8(%esp) spill %ebx\n+        // 4(%esp) spill REAL(vfork) return value\n+        // (%esp) call frame (arg0) for __*_handle_vfork\n+        sub     $16, %esp\n+        mov     %ebx, 8(%esp)\n+        mov     %eax, 4(%esp)\n+\n+        // Form GOT address in %ebx.\n+        call    .L1$pb\n+.L1$pb:\n+        pop     %ebx\n+.Ltmp1:\n+        add     $_GLOBAL_OFFSET_TABLE_+(.Ltmp1-.L1$pb), %ebx\n+\n+        // Restore original return address.\n+        call    COMMON_INTERCEPTOR_SPILL_AREA\n+        mov     (%eax), %ecx\n+        mov     %ecx, 12(%esp)\n+        mov     4(%esp), %eax\n+\n+        // Call handle_vfork in the parent process (%rax != 0).\n+        test    %eax, %eax\n+        je      .L_exit\n+\n+        lea     16(%esp), %ecx\n+        mov     %ecx, (%esp)\n+        call    COMMON_INTERCEPTOR_HANDLE_VFORK@PLT\n+\n+.L_exit:\n+        mov     4(%esp), %eax\n+        mov     8(%esp), %ebx\n+        add     $12, %esp\n+        ret\n+ASM_SIZE(vfork)\n+\n+.weak vfork\n+.set vfork, ASM_WRAPPER_NAME(vfork)\n+\n+#endif"}, {"sha": "8147cdd0924730b39eca04e4c2b66a6d08787bc2", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_vfork_x86_64.inc.S", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_x86_64.inc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_x86_64.inc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_vfork_x86_64.inc.S?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -0,0 +1,41 @@\n+#if defined(__x86_64__) && defined(__linux__)\n+\n+#include \"sanitizer_common/sanitizer_asm.h\"\n+\n+.comm _ZN14__interception10real_vforkE,8,8\n+.globl ASM_WRAPPER_NAME(vfork)\n+ASM_TYPE_FUNCTION(ASM_WRAPPER_NAME(vfork))\n+ASM_WRAPPER_NAME(vfork):\n+        // Store return address in the spill area and tear down the stack frame.\n+        push    %rcx\n+        call    COMMON_INTERCEPTOR_SPILL_AREA\n+        pop     %rcx\n+        pop     %rdi\n+        mov     %rdi, (%rax)\n+\n+        call    *_ZN14__interception10real_vforkE(%rip)\n+\n+        // Restore return address from the spill area.\n+        push    %rcx\n+        push    %rax\n+        call    COMMON_INTERCEPTOR_SPILL_AREA\n+        mov     (%rax), %rdx\n+        mov     %rdx, 8(%rsp)\n+        mov     (%rsp), %rax\n+\n+        // Call handle_vfork in the parent process (%rax != 0).\n+        test    %rax, %rax\n+        je      .L_exit\n+\n+        lea     16(%rsp), %rdi\n+        call    COMMON_INTERCEPTOR_HANDLE_VFORK@PLT\n+\n+.L_exit:\n+        pop     %rax\n+        ret\n+ASM_SIZE(vfork)\n+\n+.weak vfork\n+.set vfork, ASM_WRAPPER_NAME(vfork)\n+\n+#endif"}, {"sha": "c72554973b05eb04ef55bb3361667cb3356d64a8", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interface.inc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interface.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interface.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interface.inc?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_common_interface.inc ------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n // Sanitizer Common interface list."}, {"sha": "38f9531148d4b6e31b98c73ea37437dd50dac4ac", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interface_posix.inc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interface_posix.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interface_posix.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interface_posix.inc?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_common_interface_posix.inc ------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n // Sanitizer Common interface list only available for Posix systems."}, {"sha": "27d6a177760e4dfc29cff823e86c582e0f835e98", "filename": "libsanitizer/sanitizer_common/sanitizer_common_libcdep.cpp", "status": "renamed", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_common_libcdep.cc ---------------------------------------===//\n+//===-- sanitizer_common_libcdep.cpp --------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -23,7 +24,7 @@ void SetSoftRssLimitExceededCallback(void (*Callback)(bool exceeded)) {\n   SoftRssLimitExceededCallback = Callback;\n }\n \n-#if SANITIZER_LINUX && !SANITIZER_GO\n+#if (SANITIZER_LINUX || SANITIZER_NETBSD) && !SANITIZER_GO\n // Weak default implementation for when sanitizer_stackdepot is not linked in.\n SANITIZER_WEAK_ATTRIBUTE StackDepotStats *StackDepotGetStats() {\n   return nullptr;\n@@ -112,7 +113,7 @@ void WriteToSyslog(const char *msg) {\n }\n \n void MaybeStartBackgroudThread() {\n-#if SANITIZER_LINUX && \\\n+#if (SANITIZER_LINUX || SANITIZER_NETBSD) && \\\n     !SANITIZER_GO  // Need to implement/test on other platforms.\n   // Start the background thread if one of the rss limits is given.\n   if (!common_flags()->hard_rss_limit_mb &&", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_common_libcdep.cc"}, {"sha": "3b278e017eb7c6f70587fc480ff9747e5b59297d", "filename": "libsanitizer/sanitizer_common/sanitizer_common_nolibc.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_nolibc.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_nolibc.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_nolibc.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_common_nolibc.cc ----------------------------------------===//\n+//===-- sanitizer_common_nolibc.cpp ---------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_common_nolibc.cc"}, {"sha": "31ff48cfd2cfccef973402f8613568e32afb205f", "filename": "libsanitizer/sanitizer_common/sanitizer_common_syscalls.inc", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_common_syscalls.inc ---------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -2872,6 +2873,18 @@ POST_SYSCALL(rt_sigaction)(long res, long signum,\n     POST_WRITE(oldact, oldact_sz);\n   }\n }\n+\n+PRE_SYSCALL(getrandom)(void *buf, uptr count, long flags) {\n+  if (buf) {\n+    PRE_WRITE(buf, count);\n+  }\n+}\n+\n+POST_SYSCALL(getrandom)(long res, void *buf, uptr count, long flags) {\n+  if (res > 0 && buf) {\n+    POST_WRITE(buf, res);\n+  }\n+}\n }  // extern \"C\"\n \n #undef PRE_SYSCALL"}, {"sha": "5451d1e758b7e2659eda5653515e100172e3062d", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_fuchsia.cpp", "status": "renamed", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_fuchsia.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_fuchsia.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_fuchsia.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_coverage_fuchsia.cc -------------------------------------===//\n+//===-- sanitizer_coverage_fuchsia.cpp ------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -29,6 +30,7 @@\n #include \"sanitizer_atomic.h\"\n #include \"sanitizer_common.h\"\n #include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_symbolizer_fuchsia.h\"\n \n #include <zircon/process.h>\n #include <zircon/sanitizer.h>\n@@ -99,7 +101,7 @@ class TracePcGuardController final {\n       // uses the `dumpfile` symbolizer markup element to highlight the\n       // dump.  See the explanation for this in:\n       // https://fuchsia.googlesource.com/zircon/+/master/docs/symbolizer_markup.md\n-      Printf(\"SanitizerCoverage: {{{dumpfile:%s:%s}}} with up to %u PCs\\n\",\n+      Printf(\"SanitizerCoverage: \" FORMAT_DUMPFILE \" with up to %u PCs\\n\",\n              kSancovSinkName, vmo_name_, next_index_ - 1);\n     }\n   }\n@@ -130,7 +132,7 @@ class TracePcGuardController final {\n       // The first sample goes at [1] to reserve [0] for the magic number.\n       next_index_ = 1 + num_guards;\n \n-      zx_status_t status = _zx_vmo_create(DataSize(), 0, &vmo_);\n+      zx_status_t status = _zx_vmo_create(DataSize(), ZX_VMO_RESIZABLE, &vmo_);\n       CHECK_EQ(status, ZX_OK);\n \n       // Give the VMO a name including our process KOID so it's easy to spot.", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_coverage_fuchsia.cc"}, {"sha": "7beeff7e8af80b96e398709a362e68039ad95c31", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_interface.inc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_interface.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_interface.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_interface.inc?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_coverage_interface.inc ----------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n // Sanitizer Coverage interface list."}, {"sha": "ad137f936ffa0871b785e314e46feb418ffe1098", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_libcdep_new.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep_new.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep_new.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep_new.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_coverage_libcdep_new.cc ---------------------------------===//\n+//===-- sanitizer_coverage_libcdep_new.cpp --------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n // Sanitizer Coverage Controller for Trace PC Guard.", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_coverage_libcdep_new.cc"}, {"sha": "d0bf8a4556436c9fbdd50976735b352ba46d1163", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_win_dll_thunk.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_dll_thunk.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_dll_thunk.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_dll_thunk.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_coverage_win_dll_thunk.cc -------------------------------===//\n+//===-- sanitizer_coverage_win_dll_thunk.cpp ------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_coverage_win_dll_thunk.cc"}, {"sha": "0bdf0c5aed418daa526d87ad16eef71d8698eeb0", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_win_dynamic_runtime_thunk.cpp", "status": "renamed", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_dynamic_runtime_thunk.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_dynamic_runtime_thunk.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_dynamic_runtime_thunk.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_coverage_win_dynamic_runtime_thunk.cc -------------------===//\n+//===-- sanitizer_coverage_win_dynamic_runtime_thunk.cpp ------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -17,3 +18,9 @@\n #define INTERFACE_WEAK_FUNCTION(Name) WIN_WEAK_IMPORT_DEF(Name)\n #include \"sanitizer_coverage_interface.inc\"\n #endif // SANITIZER_DYNAMIC_RUNTIME_THUNK\n+\n+namespace __sanitizer {\n+// Add one, otherwise unused, external symbol to this object file so that the\n+// Visual C++ linker includes it and reads the .drective section.\n+void ForceWholeArchiveIncludeForSanCov() {}\n+}", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_coverage_win_dynamic_runtime_thunk.cc"}, {"sha": "40184bbb913349d0a008b5c49acb5a0deed1eca7", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_win_sections.cpp", "status": "renamed", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_sections.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_sections.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_sections.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_coverage_win_sections.cc --------------------------------===//\n+//===-- sanitizer_coverage_win_sections.cpp -------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -25,35 +26,40 @@\n #include \"sanitizer_platform.h\"\n #if SANITIZER_WINDOWS\n #include <stdint.h>\n-extern \"C\" {\n-// The Guard array and counter array should both be merged into the .data\n-// section to reduce the number of PE sections However, because PCTable is\n-// constant it should be merged with the .rdata section.\n-#pragma section(\".SCOV$GA\", read, write)  // NOLINT\n-// Use align(1) to avoid adding any padding that will mess up clients trying to\n-// determine the start and end of the array.\n-__declspec(allocate(\".SCOV$GA\")) __declspec(align(1)) uint64_t\n-    __start___sancov_guards = 0;\n-#pragma section(\".SCOV$GZ\", read, write)  // NOLINT\n-__declspec(allocate(\".SCOV$GZ\")) __declspec(align(1)) uint64_t\n-    __stop___sancov_guards = 0;\n \n+extern \"C\" {\n+// Use uint64_t so the linker won't need to add any padding if it tries to word\n+// align the start of the 8-bit counters array. The array will always start 8\n+// bytes after __start_sancov_cntrs.\n #pragma section(\".SCOV$CA\", read, write)  // NOLINT\n-__declspec(allocate(\".SCOV$CA\")) __declspec(align(1)) uint64_t\n-    __start___sancov_cntrs = 0;\n+__declspec(allocate(\".SCOV$CA\")) uint64_t __start___sancov_cntrs = 0;\n+\n+// Even though we said not to align __stop__sancov_cntrs (using the \"align\"\n+// declspec), MSVC's linker may try to align the section, .SCOV$CZ, containing\n+// it. This can cause a mismatch between the number of PCs and counters since\n+// each PCTable element is 8 bytes (unlike counters which are 1 byte) so no\n+// padding would be added to align .SCOVP$Z, However, if .SCOV$CZ section is 1\n+// byte, the linker won't try to align it on an 8-byte boundary, so use a\n+// uint8_t for __stop_sancov_cntrs.\n #pragma section(\".SCOV$CZ\", read, write)  // NOLINT\n-__declspec(allocate(\".SCOV$CZ\")) __declspec(align(1)) uint64_t\n+__declspec(allocate(\".SCOV$CZ\")) __declspec(align(1)) uint8_t\n     __stop___sancov_cntrs = 0;\n \n+#pragma section(\".SCOV$GA\", read, write)  // NOLINT\n+__declspec(allocate(\".SCOV$GA\")) uint64_t __start___sancov_guards = 0;\n+#pragma section(\".SCOV$GZ\", read, write)  // NOLINT\n+__declspec(allocate(\".SCOV$GZ\")) __declspec(align(1)) uint8_t\n+    __stop___sancov_guards = 0;\n+\n+// The guard array and counter array should both be merged into the .data\n+// section to reduce the number of PE sections. However, because PCTable is\n+// constant it should be merged with the .rdata section.\n #pragma comment(linker, \"/MERGE:.SCOV=.data\")\n \n-// Use uint64_t so there won't be any issues if the linker tries to word align\n-// the pc array.\n #pragma section(\".SCOVP$A\", read)  // NOLINT\n-__declspec(allocate(\".SCOVP$A\")) __declspec(align(1)) uint64_t\n-    __start___sancov_pcs = 0;\n+__declspec(allocate(\".SCOVP$A\")) uint64_t __start___sancov_pcs = 0;\n #pragma section(\".SCOVP$Z\", read)  // NOLINT\n-__declspec(allocate(\".SCOVP$Z\")) __declspec(align(1)) uint64_t\n+__declspec(allocate(\".SCOVP$Z\")) __declspec(align(1)) uint8_t\n     __stop___sancov_pcs = 0;\n \n #pragma comment(linker, \"/MERGE:.SCOVP=.rdata\")", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_coverage_win_sections.cc"}, {"sha": "55263981705fa603ada80c5d0ac19c9471c95c0e", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_win_weak_interception.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_weak_interception.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_weak_interception.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_win_weak_interception.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_coverage_win_weak_interception.cc -----------------------===//\n+//===-- sanitizer_coverage_win_weak_interception.cpp ----------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n // This module should be included in Sanitizer Coverage when it implemented as a", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_coverage_win_weak_interception.cc"}, {"sha": "00a5399800670a20d3f19f44c314bfc570e11c97", "filename": "libsanitizer/sanitizer_common/sanitizer_dbghelp.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_dbghelp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_dbghelp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_dbghelp.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_dbghelp.h ------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "b80cff460edab3d01d9bc4dc2e161444dd5d4fa3", "filename": "libsanitizer/sanitizer_common/sanitizer_deadlock_detector.h", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_deadlock_detector.h ---------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -24,8 +25,8 @@\n #ifndef SANITIZER_DEADLOCK_DETECTOR_H\n #define SANITIZER_DEADLOCK_DETECTOR_H\n \n-#include \"sanitizer_common.h\"\n #include \"sanitizer_bvgraph.h\"\n+#include \"sanitizer_common.h\"\n \n namespace __sanitizer {\n \n@@ -56,7 +57,6 @@ class DeadlockDetectorTLS {\n \n   // Returns true if this is the first (non-recursive) acquisition of this lock.\n   bool addLock(uptr lock_id, uptr current_epoch, u32 stk) {\n-    // Printf(\"addLock: %zx %zx stk %u\\n\", lock_id, current_epoch, stk);\n     CHECK_EQ(epoch_, current_epoch);\n     if (!bv_.setBit(lock_id)) {\n       // The lock is already held by this thread, it must be recursive.\n@@ -82,7 +82,6 @@ class DeadlockDetectorTLS {\n         }\n       }\n     }\n-    // Printf(\"remLock: %zx %zx\\n\", lock_id, epoch_);\n     if (!bv_.clearBit(lock_id))\n       return;  // probably addLock happened before flush\n     if (n_all_locks_) {\n@@ -156,7 +155,6 @@ class DeadlockDetector {\n     if (!available_nodes_.empty())\n       return getAvailableNode(data);\n     if (!recycled_nodes_.empty()) {\n-      // Printf(\"recycling: n_edges_ %zd\\n\", n_edges_);\n       for (sptr i = n_edges_ - 1; i >= 0; i--) {\n         if (recycled_nodes_.getBit(edges_[i].from) ||\n             recycled_nodes_.getBit(edges_[i].to)) {\n@@ -253,8 +251,6 @@ class DeadlockDetector {\n                   unique_tid};\n         edges_[n_edges_++] = e;\n       }\n-      // Printf(\"Edge%zd: %u %zd=>%zd in T%d\\n\",\n-      //        n_edges_, stk, added_edges[i], cur_idx, unique_tid);\n     }\n     return n_added_edges;\n   }"}, {"sha": "d4a325bea4b2d9243a181d13533bedfe4ce176c6", "filename": "libsanitizer/sanitizer_common/sanitizer_deadlock_detector1.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector1.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector1.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector1.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_deadlock_detector1.cc -----------------------------------===//\n+//===-- sanitizer_deadlock_detector1.cpp ----------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_deadlock_detector1.cc"}, {"sha": "4026739d4e5154c06862ff19735216a208dcaba6", "filename": "libsanitizer/sanitizer_common/sanitizer_deadlock_detector2.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector2.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector2.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector2.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_deadlock_detector2.cc -----------------------------------===//\n+//===-- sanitizer_deadlock_detector2.cpp ----------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_deadlock_detector2.cc"}, {"sha": "a4722b080ebd176f20911c5493f42a4e00c039dd", "filename": "libsanitizer/sanitizer_common/sanitizer_deadlock_detector_interface.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector_interface.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_deadlock_detector_interface.h -----------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "cbadf4d924a7e0a4706bf4a364e16ed9906ccd05", "filename": "libsanitizer/sanitizer_common/sanitizer_errno.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_errno.cc --------------------------------------*- C++ -*-===//\n+//===-- sanitizer_errno.cpp -------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_errno.cc"}, {"sha": "584e66e4a861aa9fb225df861c3e2f4c87358be6", "filename": "libsanitizer/sanitizer_common/sanitizer_errno.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_errno.h ---------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "f388d0d364633b4153fdba9f6543e62234695de0", "filename": "libsanitizer/sanitizer_common/sanitizer_errno_codes.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno_codes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno_codes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_errno_codes.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_errno_codes.h ---------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "c8c0b33cd6c19e59ebd5d4f40a0096286fabc70b", "filename": "libsanitizer/sanitizer_common/sanitizer_file.cpp", "status": "renamed", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,13 +1,14 @@\n-//===-- sanitizer_file.cc ------------------------------------------------===//\n+//===-- sanitizer_file.cpp -----------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===---------------------------------------------------------------------===//\n //\n // This file is shared between AddressSanitizer and ThreadSanitizer\n // run-time libraries.  It defines filesystem-related interfaces.  This\n-// is separate from sanitizer_common.cc so that it's simpler to disable\n+// is separate from sanitizer_common.cpp so that it's simpler to disable\n // all the filesystem support code for a port that doesn't use it.\n //\n //===---------------------------------------------------------------------===//", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_file.cc"}, {"sha": "4a78a0e0ac88102546a4154b455154da2f3e54ab", "filename": "libsanitizer/sanitizer_common/sanitizer_file.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_file.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_file.h ---------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===---------------------------------------------------------------------===//\n //\n@@ -64,9 +65,6 @@ bool ReadFromFile(fd_t fd, void *buff, uptr buff_size,\n bool WriteToFile(fd_t fd, const void *buff, uptr buff_size,\n                  uptr *bytes_written = nullptr, error_t *error_p = nullptr);\n \n-bool RenameFile(const char *oldpath, const char *newpath,\n-                error_t *error_p = nullptr);\n-\n // Scoped file handle closer.\n struct FileCloser {\n   explicit FileCloser(fd_t fd) : fd(fd) {}"}, {"sha": "4831814b6dfb11c2b5dd013ee54850722c323060", "filename": "libsanitizer/sanitizer_common/sanitizer_flag_parser.cpp", "status": "renamed", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_flag_parser.cc ------------------------------------------===//\n+//===-- sanitizer_flag_parser.cpp -----------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -61,7 +62,7 @@ void FlagParser::PrintFlagDescriptions() {\n }\n \n void FlagParser::fatal_error(const char *err) {\n-  Printf(\"ERROR: %s\\n\", err);\n+  Printf(\"%s: ERROR: %s\\n\", SanitizerToolName, err);\n   Die();\n }\n \n@@ -74,10 +75,17 @@ void FlagParser::skip_whitespace() {\n   while (is_space(buf_[pos_])) ++pos_;\n }\n \n-void FlagParser::parse_flag() {\n+void FlagParser::parse_flag(const char *env_option_name) {\n   uptr name_start = pos_;\n   while (buf_[pos_] != 0 && buf_[pos_] != '=' && !is_space(buf_[pos_])) ++pos_;\n-  if (buf_[pos_] != '=') fatal_error(\"expected '='\");\n+  if (buf_[pos_] != '=') {\n+    if (env_option_name) {\n+      Printf(\"%s: ERROR: expected '=' in %s\\n\", SanitizerToolName,\n+             env_option_name);\n+      Die();\n+    } else\n+      fatal_error(\"expected '='\");\n+  }\n   char *name = ll_strndup(buf_ + name_start, pos_ - name_start);\n \n   uptr value_start = ++pos_;\n@@ -99,27 +107,33 @@ void FlagParser::parse_flag() {\n   if (!res) fatal_error(\"Flag parsing failed.\");\n }\n \n-void FlagParser::parse_flags() {\n+void FlagParser::parse_flags(const char *env_option_name) {\n   while (true) {\n     skip_whitespace();\n     if (buf_[pos_] == 0) break;\n-    parse_flag();\n+    parse_flag(env_option_name);\n   }\n \n   // Do a sanity check for certain flags.\n   if (common_flags_dont_use.malloc_context_size < 1)\n     common_flags_dont_use.malloc_context_size = 1;\n }\n \n-void FlagParser::ParseString(const char *s) {\n+void FlagParser::ParseStringFromEnv(const char *env_name) {\n+  const char *env = GetEnv(env_name);\n+  VPrintf(1, \"%s: %s\\n\", env_name, env ? env : \"<empty>\");\n+  ParseString(env, env_name);\n+}\n+\n+void FlagParser::ParseString(const char *s, const char *env_option_name) {\n   if (!s) return;\n   // Backup current parser state to allow nested ParseString() calls.\n   const char *old_buf_ = buf_;\n   uptr old_pos_ = pos_;\n   buf_ = s;\n   pos_ = 0;\n \n-  parse_flags();\n+  parse_flags(env_option_name);\n \n   buf_ = old_buf_;\n   pos_ = old_pos_;\n@@ -138,7 +152,7 @@ bool FlagParser::ParseFile(const char *path, bool ignore_missing) {\n     Printf(\"Failed to read options from '%s': error %d\\n\", path, err);\n     return false;\n   }\n-  ParseString(data);\n+  ParseString(data, path);\n   UnmapOrDie(data, data_mapped_size);\n   return true;\n }", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_flag_parser.cc"}, {"sha": "8e12700bbe8c3c5870d3e74dfdff82d62906adff", "filename": "libsanitizer/sanitizer_common/sanitizer_flag_parser.h", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flag_parser.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_flag_parser.h ---------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -21,6 +22,9 @@ namespace __sanitizer {\n class FlagHandlerBase {\n  public:\n   virtual bool Parse(const char *value) { return false; }\n+\n+ protected:\n+  ~FlagHandlerBase() {};\n };\n \n template <typename T>\n@@ -95,6 +99,15 @@ inline bool FlagHandler<uptr>::Parse(const char *value) {\n   return ok;\n }\n \n+template <>\n+inline bool FlagHandler<s64>::Parse(const char *value) {\n+  const char *value_end;\n+  *t_ = internal_simple_strtoll(value, &value_end, 10);\n+  bool ok = *value_end == 0;\n+  if (!ok) Printf(\"ERROR: Invalid value for s64 option: '%s'\\n\", value);\n+  return ok;\n+}\n+\n class FlagParser {\n   static const int kMaxFlags = 200;\n   struct Flag {\n@@ -111,7 +124,8 @@ class FlagParser {\n   FlagParser();\n   void RegisterHandler(const char *name, FlagHandlerBase *handler,\n                        const char *desc);\n-  void ParseString(const char *s);\n+  void ParseString(const char *s, const char *env_name = 0);\n+  void ParseStringFromEnv(const char *env_name);\n   bool ParseFile(const char *path, bool ignore_missing);\n   void PrintFlagDescriptions();\n \n@@ -121,8 +135,8 @@ class FlagParser {\n   void fatal_error(const char *err);\n   bool is_space(char c);\n   void skip_whitespace();\n-  void parse_flags();\n-  void parse_flag();\n+  void parse_flags(const char *env_option_name);\n+  void parse_flag(const char *env_option_name);\n   bool run_handler(const char *name, const char *value);\n   char *ll_strndup(const char *s, uptr n);\n };"}, {"sha": "acc7ed39cb0ab3a5920ab77c3ade8610763325ce", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_flags.cc ------------------------------------------------===//\n+//===-- sanitizer_flags.cpp -----------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_flags.cc"}, {"sha": "8f5e987da3ffd6d9546de8d0e2d3498d9341d9a3", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_flags.h ---------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "7d592bdcb61fcefbe6d5d35b0dbab6354306024e", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.inc", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_flags.h ---------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -101,7 +102,7 @@ COMMON_FLAG(bool, allow_user_segv_handler, true,\n             \"handle_*=1 will be upgraded to handle_*=2.\")\n COMMON_FLAG(bool, use_sigaltstack, true,\n             \"If set, uses alternate stack for signal handling.\")\n-COMMON_FLAG(bool, detect_deadlocks, false,\n+COMMON_FLAG(bool, detect_deadlocks, true,\n             \"If set, deadlock detection is enabled.\")\n COMMON_FLAG(\n     uptr, clear_shadow_mmap_threshold, 64 * 1024,\n@@ -217,9 +218,9 @@ COMMON_FLAG(bool, intercept_stat, true,\n COMMON_FLAG(bool, intercept_send, true,\n             \"If set, uses custom wrappers for send* functions \"\n             \"to find more errors.\")\n-COMMON_FLAG(bool, decorate_proc_maps, false, \"If set, decorate sanitizer \"\n-                                             \"mappings in /proc/self/maps with \"\n-                                             \"user-readable names\")\n+COMMON_FLAG(bool, decorate_proc_maps, (bool)SANITIZER_ANDROID,\n+            \"If set, decorate sanitizer mappings in /proc/self/maps with \"\n+            \"user-readable names\")\n COMMON_FLAG(int, exitcode, 1, \"Override the program exit status if the tool \"\n                               \"found an error\")\n COMMON_FLAG(\n@@ -241,3 +242,6 @@ COMMON_FLAG(bool, dump_registers, true,\n COMMON_FLAG(bool, detect_write_exec, false,\n           \"If true, triggers warning when writable-executable pages requests \"\n           \"are being made\")\n+COMMON_FLAG(bool, test_only_emulate_no_memorymap, false,\n+            \"TEST ONLY fail to read memory mappings to emulate sanitized \"\n+            \"\\\"init\\\"\")"}, {"sha": "64cb21f1c3d2bc46537ae5bad367a9d064053965", "filename": "libsanitizer/sanitizer_common/sanitizer_freebsd.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_freebsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_freebsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_freebsd.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_freebsd.h -------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "3dc6863a03af65d5155c687817561b1203488899", "filename": "libsanitizer/sanitizer_common/sanitizer_fuchsia.cpp", "status": "renamed", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_fuchsia.cc ----------------------------------------------===//\n+//===-- sanitizer_fuchsia.cpp ---------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -45,9 +46,14 @@ unsigned int internal_sleep(unsigned int seconds) {\n   return 0;\n }\n \n-u64 NanoTime() { return _zx_clock_get(ZX_CLOCK_UTC); }\n+u64 NanoTime() {\n+  zx_time_t time;\n+  zx_status_t status = _zx_clock_get(ZX_CLOCK_UTC, &time);\n+  CHECK_EQ(status, ZX_OK);\n+  return time;\n+}\n \n-u64 MonotonicNanoTime() { return _zx_clock_get(ZX_CLOCK_MONOTONIC); }\n+u64 MonotonicNanoTime() { return _zx_clock_get_monotonic(); }\n \n uptr internal_getpid() {\n   zx_info_handle_basic_t info;\n@@ -84,8 +90,10 @@ void GetThreadStackTopAndBottom(bool, uptr *stack_top, uptr *stack_bottom) {\n   *stack_top = *stack_bottom + size;\n }\n \n+void InitializePlatformEarly() {}\n void MaybeReexec() {}\n void CheckASLR() {}\n+void CheckMPROTECT() {}\n void PlatformPrepareForSandboxing(__sanitizer_sandbox_arguments *args) {}\n void DisableCoreDumperIfNecessary() {}\n void InstallDeadlySignalHandlers(SignalHandlerType handler) {}\n@@ -117,8 +125,9 @@ void BlockingMutex::Lock() {\n   if (atomic_exchange(m, MtxLocked, memory_order_acquire) == MtxUnlocked)\n     return;\n   while (atomic_exchange(m, MtxSleeping, memory_order_acquire) != MtxUnlocked) {\n-    zx_status_t status = _zx_futex_wait(reinterpret_cast<zx_futex_t *>(m),\n-                                        MtxSleeping, ZX_TIME_INFINITE);\n+    zx_status_t status =\n+        _zx_futex_wait(reinterpret_cast<zx_futex_t *>(m), MtxSleeping,\n+                       ZX_HANDLE_INVALID, ZX_TIME_INFINITE);\n     if (status != ZX_ERR_BAD_STATE)  // Normal race.\n       CHECK_EQ(status, ZX_OK);\n   }\n@@ -205,10 +214,10 @@ uptr ReservedAddressRange::Init(uptr init_size, const char *name,\n   uintptr_t base;\n   zx_handle_t vmar;\n   zx_status_t status =\n-      _zx_vmar_allocate_old(_zx_vmar_root_self(), 0, init_size,\n-                            ZX_VM_FLAG_CAN_MAP_READ | ZX_VM_FLAG_CAN_MAP_WRITE |\n-                                ZX_VM_FLAG_CAN_MAP_SPECIFIC,\n-                            &vmar, &base);\n+      _zx_vmar_allocate(\n+          _zx_vmar_root_self(),\n+          ZX_VM_CAN_MAP_READ | ZX_VM_CAN_MAP_WRITE | ZX_VM_CAN_MAP_SPECIFIC,\n+          0, init_size, &vmar, &base);\n   if (status != ZX_OK)\n     ReportMmapFailureAndDie(init_size, name, \"zx_vmar_allocate\", status);\n   base_ = reinterpret_cast<void *>(base);\n@@ -248,12 +257,14 @@ static uptr DoMmapFixedOrDie(zx_handle_t vmar, uptr fixed_addr, uptr map_size,\n   return addr;\n }\n \n-uptr ReservedAddressRange::Map(uptr fixed_addr, uptr map_size) {\n+uptr ReservedAddressRange::Map(uptr fixed_addr, uptr map_size,\n+                               const char *name) {\n   return DoMmapFixedOrDie(os_handle_, fixed_addr, map_size, base_,\n                           name_, false);\n }\n \n-uptr ReservedAddressRange::MapOrDie(uptr fixed_addr, uptr map_size) {\n+uptr ReservedAddressRange::MapOrDie(uptr fixed_addr, uptr map_size,\n+                                    const char *name) {\n   return DoMmapFixedOrDie(os_handle_, fixed_addr, map_size, base_,\n                           name_, true);\n }\n@@ -449,6 +460,7 @@ char **StoredArgv;\n char **StoredEnviron;\n \n char **GetArgv() { return StoredArgv; }\n+char **GetEnviron() { return StoredEnviron; }\n \n const char *GetEnv(const char *name) {\n   if (StoredEnviron) {", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_fuchsia.cc"}, {"sha": "5a2ad32b4113b92dac27cf5c8c8c342b3a714c51", "filename": "libsanitizer/sanitizer_common/sanitizer_fuchsia.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_fuchsia.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_fuchsia.h ------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===---------------------------------------------------------------------===//\n //"}, {"sha": "cbd1af12c04f26a3aac2aa93fa98db040d581717", "filename": "libsanitizer/sanitizer_common/sanitizer_getauxval.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_getauxval.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_getauxval.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_getauxval.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_getauxval.h -----------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "3d97dcc5d2802cc3e2283d4d436c2a117b85fcbf", "filename": "libsanitizer/sanitizer_common/sanitizer_hash.h", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_hash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_hash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_hash.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -0,0 +1,43 @@\n+//===-- sanitizer_common.h --------------------------------------*- C++ -*-===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file implements a simple hash function.\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_HASH_H\n+#define SANITIZER_HASH_H\n+\n+#include \"sanitizer_internal_defs.h\"\n+\n+namespace __sanitizer {\n+class MurMur2HashBuilder {\n+  static const u32 m = 0x5bd1e995;\n+  static const u32 seed = 0x9747b28c;\n+  static const u32 r = 24;\n+  u32 h;\n+\n+ public:\n+  explicit MurMur2HashBuilder(u32 init = 0) { h = seed ^ init; }\n+  void add(u32 k) {\n+    k *= m;\n+    k ^= k >> r;\n+    k *= m;\n+    h *= m;\n+    h ^= k;\n+  }\n+  u32 get() {\n+    u32 x = h;\n+    x ^= x >> 13;\n+    x *= m;\n+    x ^= x >> 15;\n+    return x;\n+  }\n+};\n+}  //namespace __sanitizer\n+\n+#endif  // SANITIZER_HASH_H"}, {"sha": "1ec73827b8b1427c505dd5c815905ea670b1e5e0", "filename": "libsanitizer/sanitizer_common/sanitizer_interceptors_ioctl_netbsd.inc", "status": "modified", "additions": 67, "deletions": 21, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_interceptors_ioctl_netbsd.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_interceptors_ioctl_netbsd.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_interceptors_ioctl_netbsd.inc?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_interceptors_ioctl_netbsd.inc -----------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -23,7 +24,7 @@ struct ioctl_desc {\n   const char *name;\n };\n \n-const unsigned ioctl_table_max = 1198;\n+const unsigned ioctl_table_max = 1236;\n static ioctl_desc ioctl_table[ioctl_table_max];\n static unsigned ioctl_table_size = 0;\n \n@@ -286,6 +287,8 @@ static void ioctl_table_fill() {\n   _(MLX_GET_CINFO, WRITE, struct_mlx_cinfo_sz);\n   /* Entries from file: dev/ic/nvmeio.h */\n   _(NVME_PASSTHROUGH_CMD, READWRITE, struct_nvme_pt_command_sz);\n+  /* Entries from file: dev/ic/qemufwcfgio.h */\n+  _(FWCFGIO_SET_INDEX, READ, sizeof(u16));\n   /* Entries from file: dev/ir/irdaio.h */\n   _(IRDA_RESET_PARAMS, NONE, 0);\n   _(IRDA_SET_PARAMS, READ, struct_irda_params_sz);\n@@ -294,9 +297,6 @@ static void ioctl_table_fill() {\n   _(IRFRAMETTY_GET_DEVICE, WRITE, sizeof(unsigned int));\n   _(IRFRAMETTY_GET_DONGLE, WRITE, sizeof(unsigned int));\n   _(IRFRAMETTY_SET_DONGLE, READ, sizeof(unsigned int));\n-  /* Entries from file: dev/isa/satlinkio.h */\n-  _(SATIORESET, NONE, 0);\n-  _(SATIOGID, WRITE, struct_satlink_id_sz);\n   /* Entries from file: dev/isa/isvio.h */\n   _(ISV_CMD, READWRITE, struct_isv_cmd_sz);\n   /* Entries from file: dev/isa/wtreg.h */\n@@ -645,6 +645,30 @@ static void ioctl_table_fill() {\n   _(SPKRTUNE, NONE, 0);\n   _(SPKRGETVOL, WRITE, sizeof(unsigned int));\n   _(SPKRSETVOL, READ, sizeof(unsigned int));\n+#if defined(__x86_64__)\n+  /* Entries from file: dev/nvmm/nvmm_ioctl.h */\n+  _(NVMM_IOC_CAPABILITY, WRITE, struct_nvmm_ioc_capability_sz);\n+  _(NVMM_IOC_MACHINE_CREATE, READWRITE, struct_nvmm_ioc_machine_create_sz);\n+  _(NVMM_IOC_MACHINE_DESTROY, READ, struct_nvmm_ioc_machine_destroy_sz);\n+  _(NVMM_IOC_MACHINE_CONFIGURE, READ, struct_nvmm_ioc_machine_configure_sz);\n+  _(NVMM_IOC_VCPU_CREATE, READ, struct_nvmm_ioc_vcpu_create_sz);\n+  _(NVMM_IOC_VCPU_DESTROY, READ, struct_nvmm_ioc_vcpu_destroy_sz);\n+  _(NVMM_IOC_VCPU_SETSTATE, READ, struct_nvmm_ioc_vcpu_setstate_sz);\n+  _(NVMM_IOC_VCPU_GETSTATE, READ, struct_nvmm_ioc_vcpu_getstate_sz);\n+  _(NVMM_IOC_VCPU_INJECT, READ, struct_nvmm_ioc_vcpu_inject_sz);\n+  _(NVMM_IOC_VCPU_RUN, READWRITE, struct_nvmm_ioc_vcpu_run_sz);\n+  _(NVMM_IOC_GPA_MAP, READ, struct_nvmm_ioc_gpa_map_sz);\n+  _(NVMM_IOC_GPA_UNMAP, READ, struct_nvmm_ioc_gpa_unmap_sz);\n+  _(NVMM_IOC_HVA_MAP, READ, struct_nvmm_ioc_hva_map_sz);\n+  _(NVMM_IOC_HVA_UNMAP, READ, struct_nvmm_ioc_hva_unmap_sz);\n+  _(NVMM_IOC_CTL, READ, struct_nvmm_ioc_ctl_sz);\n+#endif\n+  /* Entries from file: dev/spi/spi_io.h */\n+  _(SPI_IOCTL_CONFIGURE, READ, struct_spi_ioctl_configure_sz);\n+  _(SPI_IOCTL_TRANSFER, READ, struct_spi_ioctl_transfer_sz);\n+  /* Entries from file: fs/autofs/autofs_ioctl.h */\n+  _(AUTOFSREQUEST, WRITE, struct_autofs_daemon_request_sz);\n+  _(AUTOFSDONE, READ, struct_autofs_daemon_done_sz);\n   /* Entries from file: net/bpf.h */\n   _(BIOCGBLEN, WRITE, sizeof(unsigned int));\n   _(BIOCSBLEN, READWRITE, sizeof(unsigned int));\n@@ -664,20 +688,12 @@ static void ioctl_table_fill() {\n   _(BIOCSHDRCMPLT, READ, sizeof(unsigned int));\n   _(BIOCSDLT, READ, sizeof(unsigned int));\n   _(BIOCGDLTLIST, READWRITE, struct_bpf_dltlist_sz);\n-  _(BIOCGSEESENT, WRITE, sizeof(unsigned int));\n-  _(BIOCSSEESENT, READ, sizeof(unsigned int));\n+  _(BIOCGDIRECTION, WRITE, sizeof(unsigned int));\n+  _(BIOCSDIRECTION, READ, sizeof(unsigned int));\n   _(BIOCSRTIMEOUT, READ, struct_timeval_sz);\n   _(BIOCGRTIMEOUT, WRITE, struct_timeval_sz);\n   _(BIOCGFEEDBACK, WRITE, sizeof(unsigned int));\n   _(BIOCSFEEDBACK, READ, sizeof(unsigned int));\n-  /* Entries from file: net/if_atm.h */\n-  _(SIOCRAWATM, READWRITE, sizeof(int));\n-  _(SIOCATMENA, READWRITE, struct_atm_pseudoioctl_sz);\n-  _(SIOCATMDIS, READWRITE, struct_atm_pseudoioctl_sz);\n-  _(SIOCSPVCTX, READWRITE, struct_pvctxreq_sz);\n-  _(SIOCGPVCTX, READWRITE, struct_pvctxreq_sz);\n-  _(SIOCSPVCSIF, READWRITE, struct_ifreq_sz);\n-  _(SIOCGPVCSIF, READWRITE, struct_ifreq_sz);\n   /* Entries from file: net/if_gre.h */\n   _(GRESADDRS, READ, struct_ifreq_sz);\n   _(GRESADDRD, READ, struct_ifreq_sz);\n@@ -713,12 +729,12 @@ static void ioctl_table_fill() {\n   /* Entries from file: net/npf.h */\n   _(IOC_NPF_VERSION, WRITE, sizeof(int));\n   _(IOC_NPF_SWITCH, READ, sizeof(int));\n-  _(IOC_NPF_LOAD, READWRITE, struct_plistref_sz);\n+  _(IOC_NPF_LOAD, READWRITE, struct_nvlist_ref_sz);\n   _(IOC_NPF_TABLE, READ, struct_npf_ioctl_table_sz);\n   _(IOC_NPF_STATS, READ, sizeof(uptr));\n-  _(IOC_NPF_SAVE, WRITE, struct_plistref_sz);\n-  _(IOC_NPF_RULE, READWRITE, struct_plistref_sz);\n-  _(IOC_NPF_CONN_LOOKUP, READWRITE, struct_plistref_sz);\n+  _(IOC_NPF_SAVE, WRITE, struct_nvlist_ref_sz);\n+  _(IOC_NPF_RULE, READWRITE, struct_nvlist_ref_sz);\n+  _(IOC_NPF_CONN_LOOKUP, READWRITE, struct_nvlist_ref_sz);\n   /* Entries from file: net/if_pppoe.h */\n   _(PPPOESETPARMS, READ, struct_pppoediscparms_sz);\n   _(PPPOEGETPARMS, READWRITE, struct_pppoediscparms_sz);\n@@ -841,6 +857,9 @@ static void ioctl_table_fill() {\n   _(SIOCGNATS, READWRITE, struct_ipfobj_sz);\n   _(SIOCGNATL, READWRITE, struct_ipfobj_sz);\n   _(SIOCPURGENAT, READWRITE, struct_ipfobj_sz);\n+  /* Entries from file: netinet/sctp_uio.h */\n+  _(SIOCCONNECTX, READWRITE, struct_sctp_connectx_addrs_sz);\n+  _(SIOCCONNECTXDEL, READWRITE, struct_sctp_connectx_addrs_sz);\n   /* Entries from file: netinet6/in6_var.h */\n   _(SIOCSIFINFO_FLAGS, READWRITE, struct_in6_ndireq_sz);\n   _(SIOCAADDRCTL_POLICY, READ, struct_in6_addrpolicy_sz);\n@@ -880,6 +899,9 @@ static void ioctl_table_fill() {\n   _(AUDIO_GETBUFINFO, WRITE, struct_audio_info_sz);\n   _(AUDIO_SETCHAN, READ, sizeof(int));\n   _(AUDIO_GETCHAN, WRITE, sizeof(int));\n+  _(AUDIO_QUERYFORMAT, READWRITE, struct_audio_format_query_sz);\n+  _(AUDIO_GETFORMAT, WRITE, struct_audio_info_sz);\n+  _(AUDIO_SETFORMAT, READ, struct_audio_info_sz);\n   _(AUDIO_MIXER_READ, READWRITE, struct_mixer_ctrl_sz);\n   _(AUDIO_MIXER_WRITE, READWRITE, struct_mixer_ctrl_sz);\n   _(AUDIO_MIXER_DEVINFO, READWRITE, struct_mixer_devinfo_sz);\n@@ -970,6 +992,7 @@ static void ioctl_table_fill() {\n   _(DIOCMWEDGES, WRITE, sizeof(int));\n   _(DIOCGSECTORSIZE, WRITE, sizeof(unsigned int));\n   _(DIOCGMEDIASIZE, WRITE, sizeof(uptr));\n+  _(DIOCRMWEDGES, WRITE, sizeof(int));\n   /* Entries from file: sys/drvctlio.h */\n   _(DRVDETACHDEV, READ, struct_devdetachargs_sz);\n   _(DRVRESCANBUS, READ, struct_devrescanargs_sz);\n@@ -1000,6 +1023,8 @@ static void ioctl_table_fill() {\n   /* Entries from file: sys/filio.h */\n   _(FIOCLEX, NONE, 0);\n   _(FIONCLEX, NONE, 0);\n+  _(FIOSEEKDATA, READWRITE, sizeof(uptr));\n+  _(FIOSEEKHOLE, READWRITE, sizeof(uptr));\n   _(FIONREAD, WRITE, sizeof(int));\n   _(FIONBIO, READ, sizeof(int));\n   _(FIOASYNC, READ, sizeof(int));\n@@ -1093,7 +1118,6 @@ static void ioctl_table_fill() {\n   /* Entries from file: sys/power.h */\n   _(POWER_EVENT_RECVDICT, READWRITE, struct_plistref_sz);\n   _(POWER_IOC_GET_TYPE, WRITE, struct_power_type_sz);\n-  _(POWER_IOC_GET_TYPE_WITH_LOSSAGE, WRITE, sizeof(uptr));\n   /* Entries from file: sys/radioio.h */\n   _(RIOCGINFO, WRITE, struct_radio_info_sz);\n   _(RIOCSINFO, READWRITE, struct_radio_info_sz);\n@@ -1131,6 +1155,7 @@ static void ioctl_table_fill() {\n   _(SIOCATMARK, WRITE, sizeof(int));\n   _(SIOCSPGRP, READ, sizeof(int));\n   _(SIOCGPGRP, WRITE, sizeof(int));\n+  _(SIOCPEELOFF, READWRITE, sizeof(int));\n   _(SIOCADDRT, READ, struct_ortentry_sz);\n   _(SIOCDELRT, READ, struct_ortentry_sz);\n   _(SIOCSIFADDR, READ, struct_ifreq_sz);\n@@ -1188,6 +1213,12 @@ static void ioctl_table_fill() {\n   _(SIOCSLINKSTR, READ, struct_ifdrv_sz);\n   _(SIOCGETHERCAP, READWRITE, struct_eccapreq_sz);\n   _(SIOCGIFINDEX, READWRITE, struct_ifreq_sz);\n+  _(SIOCSETHERCAP, READ, struct_eccapreq_sz);\n+  _(SIOCSIFDESCR, READ, struct_ifreq_sz);\n+  _(SIOCGIFDESCR, READWRITE, struct_ifreq_sz);\n+  _(SIOCGUMBINFO, READWRITE, struct_ifreq_sz);\n+  _(SIOCSUMBPARAM, READ, struct_ifreq_sz);\n+  _(SIOCGUMBPARAM, READWRITE, struct_ifreq_sz);\n   _(SIOCSETPFSYNC, READ, struct_ifreq_sz);\n   _(SIOCGETPFSYNC, READWRITE, struct_ifreq_sz);\n   /* Entries from file: sys/timepps.h */\n@@ -1314,6 +1345,21 @@ static void ioctl_table_fill() {\n   _(WDOGIOC_TICKLE, NONE, 0);\n   _(WDOGIOC_GTICKLER, WRITE, sizeof(int));\n   _(WDOGIOC_GWDOGS, READWRITE, struct_wdog_conf_sz);\n+  /* Entries from file: sys/kcov.h */\n+  _(KCOV_IOC_SETBUFSIZE, READ, sizeof(u64));\n+  _(KCOV_IOC_ENABLE, READ, sizeof(int));\n+  _(KCOV_IOC_DISABLE, NONE, 0);\n+  /* Entries from file: sys/ipmi.h */\n+  _(IPMICTL_RECEIVE_MSG_TRUNC, READWRITE, struct_ipmi_recv_sz);\n+  _(IPMICTL_RECEIVE_MSG, READWRITE, struct_ipmi_recv_sz);\n+  _(IPMICTL_SEND_COMMAND, READ, struct_ipmi_req_sz);\n+  _(IPMICTL_REGISTER_FOR_CMD, READ, struct_ipmi_cmdspec_sz);\n+  _(IPMICTL_UNREGISTER_FOR_CMD, READ, struct_ipmi_cmdspec_sz);\n+  _(IPMICTL_SET_GETS_EVENTS_CMD, READ, sizeof(int));\n+  _(IPMICTL_SET_MY_ADDRESS_CMD, READ, sizeof(unsigned int));\n+  _(IPMICTL_GET_MY_ADDRESS_CMD, WRITE, sizeof(unsigned int));\n+  _(IPMICTL_SET_MY_LUN_CMD, READ, sizeof(unsigned int));\n+  _(IPMICTL_GET_MY_LUN_CMD, WRITE, sizeof(unsigned int));\n   /* Entries from file: soundcard.h */\n   _(SNDCTL_DSP_RESET, NONE, 0);\n   _(SNDCTL_DSP_SYNC, NONE, 0);"}, {"sha": "c110eff130f24f53391086c6df3ad9b6af66ad13", "filename": "libsanitizer/sanitizer_common/sanitizer_interface_internal.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_interface_internal.h --------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "e0c6506bed51ec181a58fb408b4baaa5677e8290", "filename": "libsanitizer/sanitizer_common/sanitizer_internal_defs.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_internal_defs.h -------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -195,7 +196,9 @@ typedef u64 tid_t;\n // This header should NOT include any other headers to avoid portability issues.\n \n // Common defs.\n+#ifndef INLINE\n #define INLINE inline\n+#endif\n #define INTERFACE_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n #define SANITIZER_WEAK_DEFAULT_IMPL \\\n   extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE NOINLINE\n@@ -419,7 +422,6 @@ inline void Trap() {\n namespace __asan  { using namespace __sanitizer; }  // NOLINT\n namespace __dsan  { using namespace __sanitizer; }  // NOLINT\n namespace __dfsan { using namespace __sanitizer; }  // NOLINT\n-namespace __esan  { using namespace __sanitizer; }  // NOLINT\n namespace __lsan  { using namespace __sanitizer; }  // NOLINT\n namespace __msan  { using namespace __sanitizer; }  // NOLINT\n namespace __hwasan  { using namespace __sanitizer; }  // NOLINT"}, {"sha": "af2ca55ec3f6a8cd5aad0b51ce9069fa459cf1e9", "filename": "libsanitizer/sanitizer_common/sanitizer_lfstack.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_lfstack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_lfstack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_lfstack.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_lfstack.h -=-----------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "5c9d3a80c1331faa4644a7fa605131c6153ecc4f", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_libc.cc -------------------------------------------------===//\n+//===-- sanitizer_libc.cpp ------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_libc.cc"}, {"sha": "3d5db35d68ba560d8de46b82746fe4d867423b2c", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_libc.h ----------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "eb9bb765013dadab2cbc64a07dd954b1d4dad3b5", "filename": "libsanitizer/sanitizer_common/sanitizer_libignore.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_libignore.cc --------------------------------------------===//\n+//===-- sanitizer_libignore.cpp -------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n ", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_libignore.cc"}, {"sha": "256f685979f48b441ff80270472c9d55fa79ac3b", "filename": "libsanitizer/sanitizer_common/sanitizer_libignore.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_libignore.h -----------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "1ed6af33fb8af100830b374fbc3643ec315f1499", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cpp", "status": "renamed", "additions": 80, "deletions": 75, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_linux.cc ------------------------------------------------===//\n+//===-- sanitizer_linux.cpp -----------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -127,12 +128,6 @@ const int FUTEX_WAKE_PRIVATE = FUTEX_WAKE | FUTEX_PRIVATE_FLAG;\n # define SANITIZER_LINUX_USES_64BIT_SYSCALLS 0\n #endif\n \n-#if defined(__x86_64__) || SANITIZER_MIPS64\n-extern \"C\" {\n-extern void internal_sigreturn();\n-}\n-#endif\n-\n // Note : FreeBSD had implemented both\n // Linux and OpenBSD apis, available from\n // future 12.x version most likely\n@@ -379,6 +374,10 @@ uptr internal_filesize(fd_t fd) {\n   return (uptr)st.st_size;\n }\n \n+uptr internal_dup(int oldfd) {\n+  return internal_syscall(SYSCALL(dup), oldfd);\n+}\n+\n uptr internal_dup2(int oldfd, int newfd) {\n #if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n   return internal_syscall(SYSCALL(dup3), oldfd, newfd, 0);\n@@ -431,7 +430,7 @@ void internal__exit(int exitcode) {\n \n unsigned int internal_sleep(unsigned int seconds) {\n   struct timespec ts;\n-  ts.tv_sec = 1;\n+  ts.tv_sec = seconds;\n   ts.tv_nsec = 0;\n   int res = internal_syscall(SYSCALL(nanosleep), &ts, &ts);\n   if (res) return ts.tv_sec;\n@@ -447,6 +446,8 @@ uptr internal_execve(const char *filename, char *const argv[],\n \n // ----------------- sanitizer_common.h\n bool FileExists(const char *filename) {\n+  if (ShouldMockFailureToOpen(filename))\n+    return false;\n   struct stat st;\n #if SANITIZER_USES_CANONICAL_LINUX_SYSCALLS\n   if (internal_syscall(SYSCALL(newfstatat), AT_FDCWD, filename, &st, 0))\n@@ -621,33 +622,13 @@ char **GetArgv() {\n   return argv;\n }\n \n-void ReExec() {\n+char **GetEnviron() {\n   char **argv, **envp;\n-  const char *pathname = \"/proc/self/exe\";\n-\n-#if SANITIZER_NETBSD\n-  static const int name[] = {\n-    CTL_KERN, KERN_PROC_ARGS, -1, KERN_PROC_PATHNAME,\n-  };\n-  char path[400];\n-  uptr len;\n-\n-  len = sizeof(path);\n-  if (internal_sysctl(name, ARRAY_SIZE(name), path, &len, NULL, 0) != -1)\n-    pathname = path;\n-#elif SANITIZER_SOLARIS\n-  pathname = getexecname();\n-  CHECK_NE(pathname, NULL);\n-#endif\n-\n   GetArgsAndEnv(&argv, &envp);\n-  uptr rv = internal_execve(pathname, argv, envp);\n-  int rverrno;\n-  CHECK_EQ(internal_iserror(rv, &rverrno), true);\n-  Printf(\"execve failed, errno %d\\n\", rverrno);\n-  Die();\n+  return envp;\n }\n-#endif\n+\n+#endif  // !SANITIZER_OPENBSD\n \n #if !SANITIZER_SOLARIS\n enum MutexState {\n@@ -790,14 +771,19 @@ int internal_sysctl(const int *name, unsigned int namelen, void *oldp,\n   return sysctl(name, namelen, oldp, (size_t *)oldlenp, (void *)newp,\n                 (size_t)newlen);\n #else\n-  return sysctl(name, namelen, oldp, (size_t *)oldlenp, newp, (size_t)newlen);\n+  return internal_syscall(SYSCALL(__sysctl), name, namelen, oldp,\n+                          (size_t *)oldlenp, newp, (size_t)newlen);\n #endif\n }\n \n #if SANITIZER_FREEBSD\n int internal_sysctlbyname(const char *sname, void *oldp, uptr *oldlenp,\n                           const void *newp, uptr newlen) {\n-  return sysctlbyname(sname, oldp, (size_t *)oldlenp, newp, (size_t)newlen);\n+  static decltype(sysctlbyname) *real = nullptr;\n+  if (!real)\n+    real = (decltype(sysctlbyname) *)dlsym(RTLD_NEXT, \"sysctlbyname\");\n+  CHECK(real);\n+  return real(sname, oldp, (size_t *)oldlenp, newp, (size_t)newlen);\n }\n #endif\n #endif\n@@ -849,24 +835,6 @@ int internal_sigaction_norestorer(int signum, const void *act, void *oldact) {\n   }\n   return result;\n }\n-\n-// Invokes sigaction via a raw syscall with a restorer, but does not support\n-// all platforms yet.\n-// We disable for Go simply because we have not yet added to buildgo.sh.\n-#if (defined(__x86_64__) || SANITIZER_MIPS64) && !SANITIZER_GO\n-int internal_sigaction_syscall(int signum, const void *act, void *oldact) {\n-  if (act == nullptr)\n-    return internal_sigaction_norestorer(signum, act, oldact);\n-  __sanitizer_sigaction u_adjust;\n-  internal_memcpy(&u_adjust, act, sizeof(u_adjust));\n-#if !SANITIZER_ANDROID || !SANITIZER_MIPS32\n-  if (u_adjust.sa_restorer == nullptr) {\n-    u_adjust.sa_restorer = internal_sigreturn;\n-  }\n-#endif\n-  return internal_sigaction_norestorer(signum, (const void *)&u_adjust, oldact);\n-}\n-#endif  // defined(__x86_64__) && !SANITIZER_GO\n #endif  // SANITIZER_LINUX\n \n uptr internal_sigprocmask(int how, __sanitizer_sigset_t *set,\n@@ -1021,6 +989,8 @@ static uptr GetKernelAreaSize() {\n   // Firstly check if there are writable segments\n   // mapped to top gigabyte (e.g. stack).\n   MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n+  if (proc_maps.Error())\n+    return 0;\n   MemoryMappedSegment segment;\n   while (proc_maps.Next(&segment)) {\n     if ((segment.end >= 3 * gbyte) && segment.IsWritable()) return 0;\n@@ -1064,7 +1034,7 @@ uptr GetMaxVirtualAddress() {\n   return (1ULL << 40) - 1;  // 0x000000ffffffffffUL;\n # elif defined(__s390x__)\n   return (1ULL << 53) - 1;  // 0x001fffffffffffffUL;\n-# elif defined(__sparc__)\n+#elif defined(__sparc__)\n   return ~(uptr)0;\n # else\n   return (1ULL << 47) - 1;  // 0x00007fffffffffffUL;\n@@ -1088,18 +1058,25 @@ uptr GetMaxUserVirtualAddress() {\n   return addr;\n }\n \n+#if !SANITIZER_ANDROID\n uptr GetPageSize() {\n-// Android post-M sysconf(_SC_PAGESIZE) crashes if called from .preinit_array.\n-#if SANITIZER_ANDROID\n-  return 4096;\n-#elif SANITIZER_LINUX && (defined(__x86_64__) || defined(__i386__))\n+#if SANITIZER_LINUX && (defined(__x86_64__) || defined(__i386__))\n   return EXEC_PAGESIZE;\n #elif SANITIZER_USE_GETAUXVAL\n   return getauxval(AT_PAGESZ);\n+#elif SANITIZER_FREEBSD || SANITIZER_NETBSD\n+// Use sysctl as sysconf can trigger interceptors internally.\n+  int pz = 0;\n+  uptr pzl = sizeof(pz);\n+  int mib[2] = {CTL_HW, HW_PAGESIZE};\n+  int rv = internal_sysctl(mib, 2, &pz, &pzl, nullptr, 0);\n+  CHECK_EQ(rv, 0);\n+  return (uptr)pz;\n #else\n   return sysconf(_SC_PAGESIZE);  // EXEC_PAGESIZE may not be trustworthy.\n #endif\n }\n+#endif // !SANITIZER_ANDROID\n \n #if !SANITIZER_OPENBSD\n uptr ReadBinaryName(/*out*/char *buf, uptr buf_len) {\n@@ -1853,17 +1830,17 @@ SignalContext::WriteFlag SignalContext::GetWriteFlag() const {\n #elif defined(__sparc__)\n   // Decode the instruction to determine the access type.\n   // From OpenSolaris $SRC/uts/sun4/os/trap.c (get_accesstype).\n-# if SANITIZER_SOLARIS\n+#if SANITIZER_SOLARIS\n   uptr pc = ucontext->uc_mcontext.gregs[REG_PC];\n-# else\n+#else\n   // Historical BSDism here.\n   struct sigcontext *scontext = (struct sigcontext *)context;\n-#  if defined(__arch64__)\n+#if defined(__arch64__)\n   uptr pc = scontext->sigc_regs.tpc;\n-#  else\n+#else\n   uptr pc = scontext->si_regs.pc;\n-#  endif\n-# endif\n+#endif\n+#endif\n   u32 instr = *(u32 *)pc;\n   return (instr >> 21) & 1 ? WRITE: READ;\n #else\n@@ -1954,27 +1931,27 @@ static void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n   // pointer, but GCC always uses r31 when we need a frame pointer.\n   *bp = ucontext->uc_mcontext.regs->gpr[PT_R31];\n #elif defined(__sparc__)\n-# if defined(__arch64__) || defined(__sparcv9)\n-#  define STACK_BIAS 2047\n-# else\n-#  define STACK_BIAS 0\n+#if defined(__arch64__) || defined(__sparcv9)\n+#define STACK_BIAS 2047\n+#else\n+#define STACK_BIAS 0\n # endif\n # if SANITIZER_SOLARIS\n-  ucontext_t *ucontext = (ucontext_t*)context;\n+  ucontext_t *ucontext = (ucontext_t *)context;\n   *pc = ucontext->uc_mcontext.gregs[REG_PC];\n   *sp = ucontext->uc_mcontext.gregs[REG_O6] + STACK_BIAS;\n-# else\n+#else\n   // Historical BSDism here.\n   struct sigcontext *scontext = (struct sigcontext *)context;\n-#  if defined(__arch64__)\n+#if defined(__arch64__)\n   *pc = scontext->sigc_regs.tpc;\n   *sp = scontext->sigc_regs.u_regs[14] + STACK_BIAS;\n-#  else\n+#else\n   *pc = scontext->si_regs.pc;\n   *sp = scontext->si_regs.u_regs[14];\n-#  endif\n+#endif\n # endif\n-  *bp = (uptr) ((uhwptr *) *sp)[14] + STACK_BIAS;\n+  *bp = (uptr)((uhwptr *)*sp)[14] + STACK_BIAS;\n #elif defined(__mips__)\n   ucontext_t *ucontext = (ucontext_t*)context;\n   *pc = ucontext->uc_mcontext.pc;\n@@ -1996,6 +1973,10 @@ static void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n \n void SignalContext::InitPcSpBp() { GetPcSpBp(context, &pc, &sp, &bp); }\n \n+void InitializePlatformEarly() {\n+  // Do nothing.\n+}\n+\n void MaybeReexec() {\n   // No need to re-exec on Linux.\n }\n@@ -2035,6 +2016,30 @@ void CheckASLR() {\n #endif\n }\n \n+void CheckMPROTECT() {\n+#if SANITIZER_NETBSD\n+  int mib[3];\n+  int paxflags;\n+  uptr len = sizeof(paxflags);\n+\n+  mib[0] = CTL_PROC;\n+  mib[1] = internal_getpid();\n+  mib[2] = PROC_PID_PAXFLAGS;\n+\n+  if (UNLIKELY(internal_sysctl(mib, 3, &paxflags, &len, NULL, 0) == -1)) {\n+    Printf(\"sysctl failed\\n\");\n+    Die();\n+  }\n+\n+  if (UNLIKELY(paxflags & CTL_PROC_PAXFLAGS_MPROTECT)) {\n+    Printf(\"This sanitizer is not compatible with enabled MPROTECT\\n\");\n+    Die();\n+  }\n+#else\n+  // Do nothing\n+#endif\n+}\n+\n void PrintModuleMap() { }\n \n void CheckNoDeepBind(const char *filename, int flag) {", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_linux.cc"}, {"sha": "c28347ad963a7e1482e3aa06bd433670f76cd7d4", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.h", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_linux.h ---------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -16,6 +17,7 @@\n     SANITIZER_OPENBSD || SANITIZER_SOLARIS\n #include \"sanitizer_common.h\"\n #include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_platform_limits_freebsd.h\"\n #include \"sanitizer_platform_limits_netbsd.h\"\n #include \"sanitizer_platform_limits_openbsd.h\"\n #include \"sanitizer_platform_limits_posix.h\"\n@@ -56,10 +58,6 @@ uptr internal_prctl(int option, uptr arg2, uptr arg3, uptr arg4, uptr arg5);\n // (like the process-wide error reporting SEGV handler) must use\n // internal_sigaction instead.\n int internal_sigaction_norestorer(int signum, const void *act, void *oldact);\n-#if (defined(__x86_64__) || SANITIZER_MIPS64) && !SANITIZER_GO\n-// Uses a raw system call to avoid interceptors.\n-int internal_sigaction_syscall(int signum, const void *act, void *oldact);\n-#endif\n void internal_sigdelset(__sanitizer_sigset_t *set, int signum);\n #if defined(__x86_64__) || defined(__mips__) || defined(__aarch64__) \\\n   || defined(__powerpc64__) || defined(__s390__) || defined(__i386__) \\\n@@ -69,6 +67,9 @@ uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n #endif\n #elif SANITIZER_FREEBSD\n void internal_sigdelset(__sanitizer_sigset_t *set, int signum);\n+#elif SANITIZER_NETBSD\n+void internal_sigdelset(__sanitizer_sigset_t *set, int signum);\n+uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg);\n #endif  // SANITIZER_LINUX\n \n // This class reads thread IDs from /proc/<pid>/task using only syscalls.\n@@ -103,6 +104,17 @@ bool LibraryNameIs(const char *full_name, const char *base_name);\n // Call cb for each region mapped by map.\n void ForEachMappedRegion(link_map *map, void (*cb)(const void *, uptr));\n \n+// Releases memory pages entirely within the [beg, end] address range.\n+// The pages no longer count toward RSS; reads are guaranteed to return 0.\n+// Requires (but does not verify!) that pages are MAP_PRIVATE.\n+INLINE void ReleaseMemoryPagesToOSAndZeroFill(uptr beg, uptr end) {\n+  // man madvise on Linux promises zero-fill for anonymous private pages.\n+  // Testing shows the same behaviour for private (but not anonymous) mappings\n+  // of shm_open() files, as long as the underlying file is untouched.\n+  CHECK(SANITIZER_LINUX);\n+  ReleaseMemoryPagesToOS(beg, end);\n+}\n+\n #if SANITIZER_ANDROID\n \n #if defined(__aarch64__)\n@@ -131,13 +143,13 @@ void ForEachMappedRegion(link_map *map, void (*cb)(const void *, uptr));\n #error \"Unsupported architecture.\"\n #endif\n \n-// The Android Bionic team has allocated a TLS slot for TSan starting with N,\n-// given that Android currently doesn't support ELF TLS. It is used to store\n-// Sanitizers thread specific data.\n-static const int TLS_SLOT_TSAN = 8;\n+// The Android Bionic team has allocated a TLS slot for sanitizers starting\n+// with Q, given that Android currently doesn't support ELF TLS. It is used to\n+// store sanitizer thread specific data.\n+static const int TLS_SLOT_SANITIZER = 6;\n \n ALWAYS_INLINE uptr *get_android_tls_ptr() {\n-  return reinterpret_cast<uptr *>(&__get_tls()[TLS_SLOT_TSAN]);\n+  return reinterpret_cast<uptr *>(&__get_tls()[TLS_SLOT_SANITIZER]);\n }\n \n #endif  // SANITIZER_ANDROID"}, {"sha": "1f584a2add682c87f3faa456b319c1f67985dbb6", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cpp", "status": "renamed", "additions": 44, "deletions": 7, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_linux_libcdep.cc ----------------------------------------===//\n+//===-- sanitizer_linux_libcdep.cpp ---------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -21,6 +22,7 @@\n #include \"sanitizer_file.h\"\n #include \"sanitizer_flags.h\"\n #include \"sanitizer_freebsd.h\"\n+#include \"sanitizer_getauxval.h\"\n #include \"sanitizer_linux.h\"\n #include \"sanitizer_placement_new.h\"\n #include \"sanitizer_procmaps.h\"\n@@ -50,6 +52,7 @@\n #endif\n \n #if SANITIZER_SOLARIS\n+#include <stdlib.h>\n #include <thread.h>\n #endif\n \n@@ -97,6 +100,10 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n \n     // Find the mapping that contains a stack variable.\n     MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n+    if (proc_maps.Error()) {\n+      *stack_top = *stack_bottom = 0;\n+      return;\n+    }\n     MemoryMappedSegment segment;\n     uptr prev_end = 0;\n     while (proc_maps.Next(&segment)) {\n@@ -694,13 +701,9 @@ u32 GetNumberOfCPUs() {\n #elif SANITIZER_SOLARIS\n   return sysconf(_SC_NPROCESSORS_ONLN);\n #else\n-#if defined(CPU_COUNT)\n   cpu_set_t CPUs;\n   CHECK_EQ(sched_getaffinity(0, sizeof(cpu_set_t), &CPUs), 0);\n   return CPU_COUNT(&CPUs);\n-#else\n-  return 1;\n-#endif\n #endif\n }\n \n@@ -808,6 +811,40 @@ u64 MonotonicNanoTime() {\n }\n #endif  // SANITIZER_LINUX && !SANITIZER_GO\n \n+#if !SANITIZER_OPENBSD\n+void ReExec() {\n+  const char *pathname = \"/proc/self/exe\";\n+\n+#if SANITIZER_NETBSD\n+  static const int name[] = {\n+      CTL_KERN,\n+      KERN_PROC_ARGS,\n+      -1,\n+      KERN_PROC_PATHNAME,\n+  };\n+  char path[400];\n+  uptr len;\n+\n+  len = sizeof(path);\n+  if (internal_sysctl(name, ARRAY_SIZE(name), path, &len, NULL, 0) != -1)\n+    pathname = path;\n+#elif SANITIZER_SOLARIS\n+  pathname = getexecname();\n+  CHECK_NE(pathname, NULL);\n+#elif SANITIZER_USE_GETAUXVAL\n+  // Calling execve with /proc/self/exe sets that as $EXEC_ORIGIN. Binaries that\n+  // rely on that will fail to load shared libraries. Query AT_EXECFN instead.\n+  pathname = reinterpret_cast<const char *>(getauxval(AT_EXECFN));\n+#endif\n+\n+  uptr rv = internal_execve(pathname, GetArgv(), GetEnviron());\n+  int rverrno;\n+  CHECK_EQ(internal_iserror(rv, &rverrno), true);\n+  Printf(\"execve failed, errno %d\\n\", rverrno);\n+  Die();\n+}\n+#endif  // !SANITIZER_OPENBSD\n+\n } // namespace __sanitizer\n \n #endif", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc"}, {"sha": "8729642aa654985b50c2fc0a42750247d57c6231", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_mips64.S", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/063082768aab23d26e42954eb115b76318f0176d/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_mips64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/063082768aab23d26e42954eb115b76318f0176d/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_mips64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_mips64.S?ref=063082768aab23d26e42954eb115b76318f0176d", "patch": "@@ -1,23 +0,0 @@\n-// This file is dual licensed under the MIT and the University of Illinois Open\n-// Source Licenses. See LICENSE.TXT for details.\n-\n-// Avoid being marked as needing an executable stack:\n-#if defined(__linux__) && defined(__ELF__)\n-.section .note.GNU-stack,\"\",%progbits\n-#endif\n-\n-// Further contents are mips64 only:\n-#if defined(__linux__) && defined(__mips64)\n-\n-.section .text\n-.set noreorder\n-.globl internal_sigreturn\n-.type internal_sigreturn, @function\n-internal_sigreturn:\n-\n-        li $v0,5211 // #5211 is for SYS_rt_sigreturn\n-        syscall\n-\n-.size internal_sigreturn, .-internal_sigreturn\n-\n-#endif // defined(__linux__) && defined(__mips64)"}, {"sha": "41e187eaf8daea9f28ad91e1baf61f39ebfdb567", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_s390.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_s390.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_s390.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_s390.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_linux_s390.cc -------------------------------------------===//\n+//===-- sanitizer_linux_s390.cpp ------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_linux_s390.cc"}, {"sha": "8ff909542b681cb79bd40d2e3b08c75e8f8e1a2f", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_x86_64.S", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/063082768aab23d26e42954eb115b76318f0176d/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_x86_64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/063082768aab23d26e42954eb115b76318f0176d/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_x86_64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_x86_64.S?ref=063082768aab23d26e42954eb115b76318f0176d", "patch": "@@ -1,25 +0,0 @@\n-// This file is dual licensed under the MIT and the University of Illinois Open\n-// Source Licenses. See LICENSE.TXT for details.\n-\n-// Avoid being marked as needing an executable stack:\n-#if defined(__linux__) && defined(__ELF__)\n-.section .note.GNU-stack,\"\",%progbits\n-#endif\n-\n-// Further contents are x86_64-only:\n-#if defined(__linux__) && defined(__x86_64__)\n-\n-#include \"../builtins/assembly.h\"\n-\n-// If the \"naked\" function attribute were supported for x86 we could\n-// do this via inline asm.\n-.text\n-.balign 4\n-DEFINE_COMPILERRT_FUNCTION(internal_sigreturn)\n-        mov           $0xf,             %eax    // 0xf == SYS_rt_sigreturn\n-        mov           %rcx,             %r10\n-        syscall\n-        ret                                     // Won't normally reach here.\n-END_COMPILERRT_FUNCTION(internal_sigreturn)\n-\n-#endif // defined(__linux__) && defined(__x86_64__)"}, {"sha": "f0b925945e66b15449e39c097c24cab315917032", "filename": "libsanitizer/sanitizer_common/sanitizer_list.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_list.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_list.h ----------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "5d1b5264b5edb08edbd166bbb50f1410e5f28ba6", "filename": "libsanitizer/sanitizer_common/sanitizer_local_address_space_view.h", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_local_address_space_view.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_local_address_space_view.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_local_address_space_view.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -0,0 +1,76 @@\n+//===-- sanitizer_local_address_space_view.h --------------------*- C++ -*-===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// `LocalAddressSpaceView` provides the local (i.e. target and current address\n+// space are the same) implementation of the `AddressSpaveView` interface which\n+// provides a simple interface to load memory from another process (i.e.\n+// out-of-process)\n+//\n+// The `AddressSpaceView` interface requires that the type can be used as a\n+// template parameter to objects that wish to be able to operate in an\n+// out-of-process manner. In normal usage, objects are in-process and are thus\n+// instantiated with the `LocalAddressSpaceView` type. This type is used to\n+// load any pointers in instance methods. This implementation is effectively\n+// a no-op. When an object is to be used in an out-of-process manner it is\n+// instansiated with the `RemoteAddressSpaceView` type.\n+//\n+// By making `AddressSpaceView` a template parameter of an object, it can\n+// change its implementation at compile time which has no run time overhead.\n+// This also allows unifying in-process and out-of-process code which avoids\n+// code duplication.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_LOCAL_ADDRES_SPACE_VIEW_H\n+#define SANITIZER_LOCAL_ADDRES_SPACE_VIEW_H\n+\n+namespace __sanitizer {\n+struct LocalAddressSpaceView {\n+  // Load memory `sizeof(T) * num_elements` bytes of memory from the target\n+  // process (always local for this implementation) starting at address\n+  // `target_address`. The local copy of this memory is returned as a pointer.\n+  // The caller should not write to this memory. The behaviour when doing so is\n+  // undefined. Callers should use `LoadWritable()` to get access to memory\n+  // that is writable.\n+  //\n+  // The lifetime of loaded memory is implementation defined.\n+  template <typename T>\n+  static const T *Load(const T *target_address, uptr num_elements = 1) {\n+    // The target address space is the local address space so\n+    // nothing needs to be copied. Just return the pointer.\n+    return target_address;\n+  }\n+\n+  // Load memory `sizeof(T) * num_elements` bytes of memory from the target\n+  // process (always local for this implementation) starting at address\n+  // `target_address`. The local copy of this memory is returned as a pointer.\n+  // The memory returned may be written to.\n+  //\n+  // Writes made to the returned memory will be visible in the memory returned\n+  // by subsequent `Load()` or `LoadWritable()` calls provided the\n+  // `target_address` parameter is the same. It is not guaranteed that the\n+  // memory returned by previous calls to `Load()` will contain any performed\n+  // writes.  If two or more overlapping regions of memory are loaded via\n+  // separate calls to `LoadWritable()`, it is implementation defined whether\n+  // writes made to the region returned by one call are visible in the regions\n+  // returned by other calls.\n+  //\n+  // Given the above it is recommended to load the largest possible object\n+  // that requires modification (e.g. a class) rather than individual fields\n+  // from a class to avoid issues with overlapping writable regions.\n+  //\n+  // The lifetime of loaded memory is implementation defined.\n+  template <typename T>\n+  static T *LoadWritable(T *target_address, uptr num_elements = 1) {\n+    // The target address space is the local address space so\n+    // nothing needs to be copied. Just return the pointer.\n+    return target_address;\n+  }\n+};\n+}  // namespace __sanitizer\n+\n+#endif"}, {"sha": "bd6301aebadc98447ad3d845dc3c6dd5720061d1", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cpp", "status": "renamed", "additions": 96, "deletions": 52, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_mac.cc --------------------------------------------------===//\n+//===-- sanitizer_mac.cpp -------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -35,7 +36,7 @@\n extern char **environ;\n #endif\n \n-#if defined(__has_include) && __has_include(<os/trace.h>) && defined(__BLOCKS__)\n+#if defined(__has_include) && __has_include(<os/trace.h>)\n #define SANITIZER_OS_TRACE 1\n #include <os/trace.h>\n #else\n@@ -106,9 +107,20 @@ extern \"C\" int __munmap(void *, size_t) SANITIZER_WEAK_ATTRIBUTE;\n #define VM_MEMORY_SANITIZER 99\n #endif\n \n+// XNU on Darwin provides a mmap flag that optimizes allocation/deallocation of\n+// giant memory regions (i.e. shadow memory regions).\n+#define kXnuFastMmapFd 0x4\n+static size_t kXnuFastMmapThreshold = 2 << 30; // 2 GB\n+static bool use_xnu_fast_mmap = false;\n+\n uptr internal_mmap(void *addr, size_t length, int prot, int flags,\n                    int fd, u64 offset) {\n-  if (fd == -1) fd = VM_MAKE_TAG(VM_MEMORY_SANITIZER);\n+  if (fd == -1) {\n+    fd = VM_MAKE_TAG(VM_MEMORY_SANITIZER);\n+    if (length >= kXnuFastMmapThreshold) {\n+      if (use_xnu_fast_mmap) fd |= kXnuFastMmapFd;\n+    }\n+  }\n   if (&__mmap) return (uptr)__mmap(addr, length, prot, flags, fd, offset);\n   return (uptr)mmap(addr, length, prot, flags, fd, offset);\n }\n@@ -161,6 +173,10 @@ uptr internal_filesize(fd_t fd) {\n   return (uptr)st.st_size;\n }\n \n+uptr internal_dup(int oldfd) {\n+  return dup(oldfd);\n+}\n+\n uptr internal_dup2(int oldfd, int newfd) {\n   return dup2(oldfd, newfd);\n }\n@@ -223,25 +239,25 @@ int internal_sysctlbyname(const char *sname, void *oldp, uptr *oldlenp,\n                       (size_t)newlen);\n }\n \n-int internal_forkpty(int *amaster) {\n-  int master, slave;\n-  if (openpty(&master, &slave, nullptr, nullptr, nullptr) == -1) return -1;\n+int internal_forkpty(int *aparent) {\n+  int parent, worker;\n+  if (openpty(&parent, &worker, nullptr, nullptr, nullptr) == -1) return -1;\n   int pid = internal_fork();\n   if (pid == -1) {\n-    close(master);\n-    close(slave);\n+    close(parent);\n+    close(worker);\n     return -1;\n   }\n   if (pid == 0) {\n-    close(master);\n-    if (login_tty(slave) != 0) {\n+    close(parent);\n+    if (login_tty(worker) != 0) {\n       // We already forked, there's not much we can do.  Let's quit.\n       Report(\"login_tty failed (errno %d)\\n\", errno);\n       internal__exit(1);\n     }\n   } else {\n-    *amaster = master;\n-    close(slave);\n+    *aparent = parent;\n+    close(worker);\n   }\n   return pid;\n }\n@@ -265,6 +281,8 @@ uptr internal_waitpid(int pid, int *status, int options) {\n \n // ----------------- sanitizer_common.h\n bool FileExists(const char *filename) {\n+  if (ShouldMockFailureToOpen(filename))\n+    return false;\n   struct stat st;\n   if (stat(filename, &st))\n     return false;\n@@ -360,6 +378,10 @@ void CheckASLR() {\n   // Do nothing\n }\n \n+void CheckMPROTECT() {\n+  // Do nothing\n+}\n+\n uptr GetPageSize() {\n   return sysconf(_SC_PAGESIZE);\n }\n@@ -512,27 +534,35 @@ MacosVersion GetMacosVersionInternal() {\n   CHECK_NE(internal_sysctl(mib, 2, 0, &len, 0, 0), -1);\n   CHECK_LT(len, maxlen);\n   CHECK_NE(internal_sysctl(mib, 2, version, &len, 0, 0), -1);\n-  switch (version[0]) {\n-    case '9': return MACOS_VERSION_LEOPARD;\n-    case '1': {\n-      switch (version[1]) {\n-        case '0': return MACOS_VERSION_SNOW_LEOPARD;\n-        case '1': return MACOS_VERSION_LION;\n-        case '2': return MACOS_VERSION_MOUNTAIN_LION;\n-        case '3': return MACOS_VERSION_MAVERICKS;\n-        case '4': return MACOS_VERSION_YOSEMITE;\n-        case '5': return MACOS_VERSION_EL_CAPITAN;\n-        case '6': return MACOS_VERSION_SIERRA;\n-        case '7': return MACOS_VERSION_HIGH_SIERRA;\n-        case '8': return MACOS_VERSION_MOJAVE;\n-        default:\n-          if (IsDigit(version[1]))\n-            return MACOS_VERSION_UNKNOWN_NEWER;\n-          else\n-            return MACOS_VERSION_UNKNOWN;\n-      }\n-    }\n-    default: return MACOS_VERSION_UNKNOWN;\n+\n+  // Expect <major>.<minor>(.<patch>)\n+  CHECK_GE(len, 3);\n+  const char *p = version;\n+  int major = internal_simple_strtoll(p, &p, /*base=*/10);\n+  if (*p != '.') return MACOS_VERSION_UNKNOWN;\n+  p += 1;\n+  int minor = internal_simple_strtoll(p, &p, /*base=*/10);\n+  if (*p != '.') return MACOS_VERSION_UNKNOWN;\n+\n+  switch (major) {\n+    case 9: return MACOS_VERSION_LEOPARD;\n+    case 10: return MACOS_VERSION_SNOW_LEOPARD;\n+    case 11: return MACOS_VERSION_LION;\n+    case 12: return MACOS_VERSION_MOUNTAIN_LION;\n+    case 13: return MACOS_VERSION_MAVERICKS;\n+    case 14: return MACOS_VERSION_YOSEMITE;\n+    case 15: return MACOS_VERSION_EL_CAPITAN;\n+    case 16: return MACOS_VERSION_SIERRA;\n+    case 17:\n+      // Not a typo, 17.5 Darwin Kernel Version maps to High Sierra 10.13.4.\n+      if (minor >= 5)\n+        return MACOS_VERSION_HIGH_SIERRA_DOT_RELEASE_4;\n+      return MACOS_VERSION_HIGH_SIERRA;\n+    case 18: return MACOS_VERSION_MOJAVE;\n+    case 19: return MACOS_VERSION_CATALINA;\n+    default:\n+      if (major < 9) return MACOS_VERSION_UNKNOWN;\n+      return MACOS_VERSION_UNKNOWN_NEWER;\n   }\n }\n \n@@ -675,6 +705,16 @@ static void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n \n void SignalContext::InitPcSpBp() { GetPcSpBp(context, &pc, &sp, &bp); }\n \n+void InitializePlatformEarly() {\n+  // Only use xnu_fast_mmap when on x86_64 and the OS supports it.\n+  use_xnu_fast_mmap =\n+#if defined(__x86_64__)\n+      GetMacosVersion() >= MACOS_VERSION_HIGH_SIERRA_DOT_RELEASE_4;\n+#else\n+      false;\n+#endif\n+}\n+\n #if !SANITIZER_GO\n static const char kDyldInsertLibraries[] = \"DYLD_INSERT_LIBRARIES\";\n LowLevelAllocator allocator_for_env;\n@@ -872,7 +912,7 @@ char **GetArgv() {\n   return *_NSGetArgv();\n }\n \n-#if defined(__aarch64__) && SANITIZER_IOS && !SANITIZER_IOSSIM\n+#if SANITIZER_IOS\n // The task_vm_info struct is normally provided by the macOS SDK, but we need\n // fields only available in 10.12+. Declare the struct manually to be able to\n // build against older SDKs.\n@@ -903,33 +943,37 @@ struct __sanitizer_task_vm_info {\n #define __SANITIZER_TASK_VM_INFO_COUNT ((mach_msg_type_number_t) \\\n     (sizeof(__sanitizer_task_vm_info) / sizeof(natural_t)))\n \n-uptr GetTaskInfoMaxAddress() {\n+static uptr GetTaskInfoMaxAddress() {\n   __sanitizer_task_vm_info vm_info = {} /* zero initialize */;\n   mach_msg_type_number_t count = __SANITIZER_TASK_VM_INFO_COUNT;\n   int err = task_info(mach_task_self(), TASK_VM_INFO, (int *)&vm_info, &count);\n-  if (err == 0 && vm_info.max_address != 0) {\n-    return vm_info.max_address - 1;\n-  } else {\n-    // xnu cannot provide vm address limit\n-    return 0x200000000 - 1;\n-  }\n+  return err ? 0 : vm_info.max_address;\n }\n-#endif\n \n uptr GetMaxUserVirtualAddress() {\n-#if SANITIZER_WORDSIZE == 64\n-# if defined(__aarch64__) && SANITIZER_IOS && !SANITIZER_IOSSIM\n-  // Get the maximum VM address\n   static uptr max_vm = GetTaskInfoMaxAddress();\n-  CHECK(max_vm);\n-  return max_vm;\n+  if (max_vm != 0)\n+    return max_vm - 1;\n+\n+  // xnu cannot provide vm address limit\n+# if SANITIZER_WORDSIZE == 32\n+  return 0xffe00000 - 1;\n # else\n-  return (1ULL << 47) - 1;  // 0x00007fffffffffffUL;\n+  return 0x200000000 - 1;\n # endif\n-#else  // SANITIZER_WORDSIZE == 32\n+}\n+\n+#else // !SANITIZER_IOS\n+\n+uptr GetMaxUserVirtualAddress() {\n+# if SANITIZER_WORDSIZE == 64\n+  return (1ULL << 47) - 1;  // 0x00007fffffffffffUL;\n+# else // SANITIZER_WORDSIZE == 32\n+  static_assert(SANITIZER_WORDSIZE == 32, \"Wrong wordsize\");\n   return (1ULL << 32) - 1;  // 0xffffffff;\n-#endif  // SANITIZER_WORDSIZE\n+# endif\n }\n+#endif\n \n uptr GetMaxVirtualAddress() {\n   return GetMaxUserVirtualAddress();", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_mac.cc"}, {"sha": "2257883084ea9a769c7279f2d7ce66375bc513c5", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_mac.h -----------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -41,7 +42,9 @@ enum MacosVersion {\n   MACOS_VERSION_EL_CAPITAN,\n   MACOS_VERSION_SIERRA,\n   MACOS_VERSION_HIGH_SIERRA,\n+  MACOS_VERSION_HIGH_SIERRA_DOT_RELEASE_4,\n   MACOS_VERSION_MOJAVE,\n+  MACOS_VERSION_CATALINA,\n   MACOS_VERSION_UNKNOWN_NEWER\n };\n "}, {"sha": "ac7e328946bfbe2785c0c73f58e6ace5d3a7011f", "filename": "libsanitizer/sanitizer_common/sanitizer_mac_libcdep.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac_libcdep.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_mac_libcdep.cc ------------------------------------------===//\n+//===-- sanitizer_mac_libcdep.cpp -----------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_mac_libcdep.cc"}, {"sha": "11adbe5c25b4b26e8db77568ad0a500517231ce2", "filename": "libsanitizer/sanitizer_common/sanitizer_malloc_mac.inc", "status": "modified", "additions": 92, "deletions": 9, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_malloc_mac.inc --------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -28,9 +29,29 @@\n // https://github.com/gperftools/gperftools.\n \n namespace __sanitizer {\n+\n extern malloc_zone_t sanitizer_zone;\n+\n+struct sanitizer_malloc_introspection_t : public malloc_introspection_t {\n+  // IMPORTANT: Do not change the order, alignment, or types of these fields to\n+  // maintain binary compatibility. You should only add fields to this struct.\n+\n+  // Used to track changes to the allocator that will affect\n+  // zone enumeration.\n+  u64 allocator_enumeration_version;\n+  uptr allocator_ptr;\n+  uptr allocator_size;\n+};\n+\n+u64 GetMallocZoneAllocatorEnumerationVersion() {\n+  // This represents the current allocator ABI version.\n+  // This field should be incremented every time the Allocator\n+  // ABI changes in a way that breaks allocator enumeration.\n+  return 0;\n }\n \n+}  // namespace __sanitizer\n+\n INTERCEPTOR(malloc_zone_t *, malloc_create_zone,\n                              vm_size_t start_size, unsigned zone_flags) {\n   COMMON_MALLOC_ENTER();\n@@ -70,6 +91,15 @@ INTERCEPTOR(malloc_zone_t *, malloc_default_zone, void) {\n   return &sanitizer_zone;\n }\n \n+INTERCEPTOR(malloc_zone_t *, malloc_zone_from_ptr, const void *ptr) {\n+  COMMON_MALLOC_ENTER();\n+  size_t size = sanitizer_zone.size(&sanitizer_zone, ptr);\n+  if (size) { // Claimed by sanitizer zone?\n+    return &sanitizer_zone;\n+  }\n+  return REAL(malloc_zone_from_ptr)(ptr);\n+}\n+\n INTERCEPTOR(malloc_zone_t *, malloc_default_purgeable_zone, void) {\n   // FIXME: ASan should support purgeable allocations.\n   // https://github.com/google/sanitizers/issues/139\n@@ -205,7 +235,7 @@ void __sanitizer_mz_free(malloc_zone_t *zone, void *ptr) {\n }\n \n #define GET_ZONE_FOR_PTR(ptr) \\\n-  malloc_zone_t *zone_ptr = malloc_zone_from_ptr(ptr); \\\n+  malloc_zone_t *zone_ptr = WRAP(malloc_zone_from_ptr)(ptr); \\\n   const char *zone_name = (zone_ptr == 0) ? 0 : zone_ptr->zone_name\n \n extern \"C\"\n@@ -245,6 +275,13 @@ void *__sanitizer_mz_memalign(malloc_zone_t *zone, size_t align, size_t size) {\n   return p;\n }\n \n+// This public API exists purely for testing purposes.\n+extern \"C\"\n+SANITIZER_INTERFACE_ATTRIBUTE\n+malloc_zone_t* __sanitizer_mz_default_zone() {\n+  return &sanitizer_zone;\n+}\n+\n // This function is currently unused, and we build with -Werror.\n #if 0\n void __sanitizer_mz_free_definite_size(\n@@ -254,13 +291,48 @@ void __sanitizer_mz_free_definite_size(\n }\n #endif\n \n-kern_return_t mi_enumerator(task_t task, void *,\n-                            unsigned type_mask, vm_address_t zone_address,\n-                            memory_reader_t reader,\n+#ifndef COMMON_MALLOC_HAS_ZONE_ENUMERATOR\n+#error \"COMMON_MALLOC_HAS_ZONE_ENUMERATOR must be defined\"\n+#endif\n+static_assert((COMMON_MALLOC_HAS_ZONE_ENUMERATOR) == 0 ||\n+                  (COMMON_MALLOC_HAS_ZONE_ENUMERATOR) == 1,\n+              \"COMMON_MALLOC_HAS_ZONE_ENUMERATOR must be 0 or 1\");\n+\n+#if COMMON_MALLOC_HAS_ZONE_ENUMERATOR\n+// Forward declare and expect the implementation to provided by\n+// includer.\n+kern_return_t mi_enumerator(task_t task, void *, unsigned type_mask,\n+                            vm_address_t zone_address, memory_reader_t reader,\n+                            vm_range_recorder_t recorder);\n+#else\n+// Provide stub implementation that fails.\n+kern_return_t mi_enumerator(task_t task, void *, unsigned type_mask,\n+                            vm_address_t zone_address, memory_reader_t reader,\n                             vm_range_recorder_t recorder) {\n-  // Should enumerate all the pointers we have.  Seems like a lot of work.\n+  // Not supported.\n   return KERN_FAILURE;\n }\n+#endif\n+\n+#ifndef COMMON_MALLOC_HAS_EXTRA_INTROSPECTION_INIT\n+#error \"COMMON_MALLOC_HAS_EXTRA_INTROSPECTION_INIT must be defined\"\n+#endif\n+static_assert((COMMON_MALLOC_HAS_EXTRA_INTROSPECTION_INIT) == 0 ||\n+                  (COMMON_MALLOC_HAS_EXTRA_INTROSPECTION_INIT) == 1,\n+              \"COMMON_MALLOC_HAS_EXTRA_INTROSPECTION_INIT must be 0 or 1\");\n+#if COMMON_MALLOC_HAS_EXTRA_INTROSPECTION_INIT\n+// Forward declare and expect the implementation to provided by\n+// includer.\n+void mi_extra_init(\n+    sanitizer_malloc_introspection_t *mi);\n+#else\n+void mi_extra_init(\n+    sanitizer_malloc_introspection_t *mi) {\n+  // Just zero initialize the fields.\n+  mi->allocator_ptr = 0;\n+  mi->allocator_size = 0;\n+}\n+#endif\n \n size_t mi_good_size(malloc_zone_t *zone, size_t size) {\n   // I think it's always safe to return size, but we maybe could do better.\n@@ -300,8 +372,8 @@ boolean_t mi_zone_locked(malloc_zone_t *zone) {\n \n namespace COMMON_MALLOC_NAMESPACE {\n \n-void ReplaceSystemMalloc() {\n-  static malloc_introspection_t sanitizer_zone_introspection;\n+void InitMallocZoneFields() {\n+  static sanitizer_malloc_introspection_t sanitizer_zone_introspection;\n   // Ok to use internal_memset, these places are not performance-critical.\n   internal_memset(&sanitizer_zone_introspection, 0,\n                   sizeof(sanitizer_zone_introspection));\n@@ -316,6 +388,13 @@ void ReplaceSystemMalloc() {\n   sanitizer_zone_introspection.statistics = &mi_statistics;\n   sanitizer_zone_introspection.zone_locked = &mi_zone_locked;\n \n+  // Set current allocator enumeration version.\n+  sanitizer_zone_introspection.allocator_enumeration_version =\n+      GetMallocZoneAllocatorEnumerationVersion();\n+\n+  // Perform any sanitizer specific initialization.\n+  mi_extra_init(&sanitizer_zone_introspection);\n+\n   internal_memset(&sanitizer_zone, 0, sizeof(malloc_zone_t));\n \n   // Use version 6 for OSX >= 10.6.\n@@ -333,6 +412,10 @@ void ReplaceSystemMalloc() {\n   sanitizer_zone.free_definite_size = 0;\n   sanitizer_zone.memalign = &__sanitizer_mz_memalign;\n   sanitizer_zone.introspect = &sanitizer_zone_introspection;\n+}\n+\n+void ReplaceSystemMalloc() {\n+  InitMallocZoneFields();\n \n   // Register the zone.\n   malloc_zone_register(&sanitizer_zone);"}, {"sha": "40a65914299eaff025ea6c99ca3f1d8ca7d11f1f", "filename": "libsanitizer/sanitizer_common/sanitizer_mutex.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_mutex.h ---------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "4e74f6a3b5161cf704202d9a931b318790467c49", "filename": "libsanitizer/sanitizer_common/sanitizer_netbsd.cpp", "status": "renamed", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_netbsd.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_netbsd.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_netbsd.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_netbsd.cc -----------------------------------------------===//\n+//===-- sanitizer_netbsd.cpp ----------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -167,6 +168,11 @@ uptr internal_filesize(fd_t fd) {\n   return (uptr)st.st_size;\n }\n \n+uptr internal_dup(int oldfd) {\n+  DEFINE__REAL(int, dup, int a);\n+  return _REAL(dup, oldfd);\n+}\n+\n uptr internal_dup2(int oldfd, int newfd) {\n   DEFINE__REAL(int, dup2, int a, int b);\n   return _REAL(dup2, oldfd, newfd);\n@@ -200,7 +206,7 @@ void internal__exit(int exitcode) {\n \n unsigned int internal_sleep(unsigned int seconds) {\n   struct timespec ts;\n-  ts.tv_sec = 1;\n+  ts.tv_sec = seconds;\n   ts.tv_nsec = 0;\n   CHECK(&_sys___nanosleep50);\n   int res = _sys___nanosleep50(&ts, &ts);\n@@ -239,10 +245,9 @@ uptr internal_clock_gettime(__sanitizer_clockid_t clk_id, void *tp) {\n   return _REAL(__clock_gettime50, clk_id, tp);\n }\n \n-uptr internal_ptrace(int request, int pid, void *addr, void *data) {\n-  Printf(\"internal_ptrace not implemented for NetBSD\");\n-  Die();\n-  return 0;\n+uptr internal_ptrace(int request, int pid, void *addr, int data) {\n+  DEFINE__REAL(int, ptrace, int a, int b, void *c, int d);\n+  return _REAL(ptrace, request, pid, addr, data);\n }\n \n uptr internal_waitpid(int pid, int *status, int options) {\n@@ -316,11 +321,16 @@ void internal_sigemptyset(__sanitizer_sigset_t *set) {\n   (void)_REAL(__sigemptyset14, set);\n }\n \n-uptr intrnal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n-                   int *parent_tidptr, void *newtls, int *child_tidptr) {\n-  Printf(\"internal_clone not implemented for NetBSD\");\n-  Die();\n-  return 0;\n+void internal_sigdelset(__sanitizer_sigset_t *set, int signo) {\n+  DEFINE__REAL(int, __sigdelset14, const void *a, int b);\n+  (void)_REAL(__sigdelset14, set, signo);\n+}\n+\n+uptr internal_clone(int (*fn)(void *), void *child_stack, int flags,\n+                    void *arg) {\n+  DEFINE__REAL(int, clone, int (*a)(void *b), void *c, int d, void *e);\n+\n+  return _REAL(clone, fn, child_stack, flags, arg);\n }\n \n }  // namespace __sanitizer", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_netbsd.cc"}, {"sha": "ed2d8edeb7a2cf16b1fdc9ae961a65187ace6539", "filename": "libsanitizer/sanitizer_common/sanitizer_openbsd.cpp", "status": "renamed", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_openbsd.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_openbsd.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_openbsd.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_openbsd.cc ----------------------------------------------===//\n+//===-- sanitizer_openbsd.cpp ---------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -99,6 +100,12 @@ char **GetArgv() {\n   return argv;\n }\n \n+char **GetEnviron() {\n+  char **argv, **envp;\n+  GetArgsAndEnv(&argv, &envp);\n+  return envp;\n+}\n+\n void ReExec() {\n   UNIMPLEMENTED();\n }", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_openbsd.cc"}, {"sha": "1ca0375b8a54c07ecb5521af54bacb61e5279517", "filename": "libsanitizer/sanitizer_common/sanitizer_persistent_allocator.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_persistent_allocator.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_persistent_allocator.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_persistent_allocator.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_persistent_allocator.cc -----------------------*- C++ -*-===//\n+//===-- sanitizer_persistent_allocator.cpp ----------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_persistent_allocator.cc"}, {"sha": "de4fb6ebc3cf8733afca4a9ebb64e107fd93d139", "filename": "libsanitizer/sanitizer_common/sanitizer_persistent_allocator.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_persistent_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_persistent_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_persistent_allocator.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_persistent_allocator.h ------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "1ceb8b909268f3ebfc85941822609f55cf41ed89", "filename": "libsanitizer/sanitizer_common/sanitizer_placement_new.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_placement_new.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_placement_new.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_placement_new.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_placement_new.h -------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "b45c975358db76409186cafd5bdbf49c936462f9", "filename": "libsanitizer/sanitizer_common/sanitizer_platform.h", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_platform.h ------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -240,7 +241,7 @@\n #  define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 48)\n # endif\n #elif defined(__sparc__)\n-# define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 52)\n+#define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 52)\n #else\n # define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 47)\n #endif\n@@ -249,9 +250,9 @@\n // The SPARC64 Linux port implements this to split the VMA space into two\n // non-contiguous halves with a huge hole in the middle.\n #if defined(__sparc__) && SANITIZER_WORDSIZE == 64\n-# define SANITIZER_SIGN_EXTENDED_ADDRESSES 1\n+#define SANITIZER_SIGN_EXTENDED_ADDRESSES 1\n #else\n-# define SANITIZER_SIGN_EXTENDED_ADDRESSES 0\n+#define SANITIZER_SIGN_EXTENDED_ADDRESSES 0\n #endif\n \n // The AArch64 linux port uses the canonical syscall set as mandated by\n@@ -284,12 +285,6 @@\n # define SANITIZER_POINTER_FORMAT_LENGTH FIRST_32_SECOND_64(8, 12)\n #endif\n \n-// Assume obsolete RPC headers are available by default\n-#if !defined(HAVE_RPC_XDR_H) && !defined(HAVE_TIRPC_RPC_XDR_H)\n-# define HAVE_RPC_XDR_H (SANITIZER_LINUX && !SANITIZER_ANDROID)\n-# define HAVE_TIRPC_RPC_XDR_H 0\n-#endif\n-\n /// \\macro MSC_PREREQ\n /// \\brief Is the compiler MSVC of at least the specified version?\n /// The common \\param version values to check for are:\n@@ -351,4 +346,13 @@\n #define SANITIZER_SYMBOLIZER_MARKUP 0\n #endif\n \n+// Enable ability to support sanitizer initialization that is\n+// compatible with the sanitizer library being loaded via\n+// `dlopen()`.\n+#if SANITIZER_MAC\n+#define SANITIZER_SUPPORTS_INIT_FOR_DLOPEN 1\n+#else\n+#define SANITIZER_SUPPORTS_INIT_FOR_DLOPEN 0\n+#endif\n+\n #endif // SANITIZER_PLATFORM_H"}, {"sha": "e7becbb0e206a901adf2d171bcda7e7cab52a43b", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_interceptors.h", "status": "modified", "additions": 64, "deletions": 5, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_platform_interceptors.h -----------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -31,8 +32,9 @@\n #endif\n \n #if SI_POSIX\n+# include \"sanitizer_platform_limits_freebsd.h\"\n # include \"sanitizer_platform_limits_netbsd.h\"\n-#include \"sanitizer_platform_limits_openbsd.h\"\n+# include \"sanitizer_platform_limits_openbsd.h\"\n # include \"sanitizer_platform_limits_posix.h\"\n # include \"sanitizer_platform_limits_solaris.h\"\n #endif\n@@ -140,6 +142,9 @@\n #define SANITIZER_INTERCEPT_MEMMOVE 1\n #define SANITIZER_INTERCEPT_MEMCPY 1\n #define SANITIZER_INTERCEPT_MEMCMP SI_NOT_FUCHSIA\n+#define SANITIZER_INTERCEPT_BCMP \\\n+  SANITIZER_INTERCEPT_MEMCMP &&  \\\n+      ((SI_POSIX && _GNU_SOURCE) || SI_NETBSD || SI_OPENBSD || SI_FREEBSD)\n #define SANITIZER_INTERCEPT_STRNDUP SI_POSIX\n #define SANITIZER_INTERCEPT___STRNDUP SI_LINUX_NOT_FREEBSD\n #if defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && \\\n@@ -205,9 +210,13 @@\n #define SANITIZER_INTERCEPT_GETPWENT                                          \\\n   (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_MAC || SI_LINUX_NOT_ANDROID || \\\n   SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_FGETGRENT_R                                       \\\n+  (SI_FREEBSD || SI_OPENBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_FGETPWENT SI_LINUX_NOT_ANDROID || SI_SOLARIS\n #define SANITIZER_INTERCEPT_GETPWENT_R \\\n   (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_FGETPWENT_R \\\n+  (SI_FREEBSD || SI_OPENBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_SETPWENT \\\n   (SI_MAC || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_CLOCK_GETTIME \\\n@@ -274,6 +283,9 @@\n #define SANITIZER_INTERCEPT_WCRTOMB                                           \\\n   (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_MAC || SI_LINUX_NOT_ANDROID || \\\n   SI_SOLARIS)\n+#define SANITIZER_INTERCEPT_WCTOMB                                           \\\n+  (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_MAC || SI_LINUX_NOT_ANDROID || \\\n+  SI_SOLARIS)\n #define SANITIZER_INTERCEPT_TCGETATTR SI_LINUX_NOT_ANDROID || SI_SOLARIS\n #define SANITIZER_INTERCEPT_REALPATH SI_POSIX\n #define SANITIZER_INTERCEPT_CANONICALIZE_FILE_NAME \\\n@@ -302,6 +314,7 @@\n   (SI_FREEBSD || SI_NETBSD || SI_MAC || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_SIGPENDING SI_POSIX\n #define SANITIZER_INTERCEPT_SIGPROCMASK SI_POSIX\n+#define SANITIZER_INTERCEPT_PTHREAD_SIGMASK SI_POSIX\n #define SANITIZER_INTERCEPT_BACKTRACE \\\n   (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_GETMNTENT SI_LINUX\n@@ -350,11 +363,14 @@\n #define SANITIZER_INTERCEPT_THR_EXIT SI_FREEBSD\n #define SANITIZER_INTERCEPT_TMPNAM SI_POSIX\n #define SANITIZER_INTERCEPT_TMPNAM_R SI_LINUX_NOT_ANDROID || SI_SOLARIS\n+#define SANITIZER_INTERCEPT_TTYNAME SI_POSIX\n #define SANITIZER_INTERCEPT_TTYNAME_R SI_POSIX\n #define SANITIZER_INTERCEPT_TEMPNAM SI_POSIX\n #define SANITIZER_INTERCEPT_SINCOS SI_LINUX || SI_SOLARIS\n #define SANITIZER_INTERCEPT_REMQUO SI_POSIX\n+#define SANITIZER_INTERCEPT_REMQUOL (SI_POSIX && !SI_NETBSD)\n #define SANITIZER_INTERCEPT_LGAMMA SI_POSIX\n+#define SANITIZER_INTERCEPT_LGAMMAL (SI_POSIX && !SI_NETBSD)\n #define SANITIZER_INTERCEPT_LGAMMA_R (SI_FREEBSD || SI_LINUX || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_LGAMMAL_R SI_LINUX_NOT_ANDROID || SI_SOLARIS\n #define SANITIZER_INTERCEPT_DRAND48_R SI_LINUX_NOT_ANDROID\n@@ -378,7 +394,7 @@\n #define SANITIZER_INTERCEPT_PTHREAD_SETNAME_NP \\\n   (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n #define SANITIZER_INTERCEPT_PTHREAD_GETNAME_NP \\\n-  (SI_FREEBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n+  (SI_FREEBSD || SI_NETBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n \n #define SANITIZER_INTERCEPT_TLS_GET_ADDR \\\n   (SI_FREEBSD || SI_NETBSD || SI_OPENBSD || SI_LINUX_NOT_ANDROID || SI_SOLARIS)\n@@ -398,7 +414,8 @@\n #else\n #define SANITIZER_INTERCEPT_AEABI_MEM 0\n #endif\n-#define SANITIZER_INTERCEPT___BZERO SI_MAC\n+#define SANITIZER_INTERCEPT___BZERO SI_MAC || SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_BZERO SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_FTIME \\\n   (!SI_FREEBSD && !SI_NETBSD && !SI_OPENBSD && SI_POSIX)\n #define SANITIZER_INTERCEPT_XDR SI_LINUX_NOT_ANDROID || SI_SOLARIS\n@@ -470,10 +487,12 @@\n #define SANITIZER_INTERCEPT_CFREE \\\n   (!SI_FREEBSD && !SI_MAC && !SI_NETBSD && !SI_OPENBSD && SI_NOT_FUCHSIA && \\\n   SI_NOT_RTEMS)\n+#define SANITIZER_INTERCEPT_REALLOCARRAY SI_POSIX\n #define SANITIZER_INTERCEPT_ALIGNED_ALLOC (!SI_MAC && SI_NOT_RTEMS)\n #define SANITIZER_INTERCEPT_MALLOC_USABLE_SIZE (!SI_MAC && !SI_OPENBSD)\n #define SANITIZER_INTERCEPT_MCHECK_MPROBE SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_WCSCAT SI_POSIX\n+#define SANITIZER_INTERCEPT_WCSDUP SI_POSIX\n #define SANITIZER_INTERCEPT_SIGNAL_AND_SIGACTION (!SI_WINDOWS && SI_NOT_FUCHSIA)\n #define SANITIZER_INTERCEPT_BSD_SIGNAL SI_ANDROID\n \n@@ -508,5 +527,45 @@\n #define SANITIZER_INTERCEPT_TTYENT SI_NETBSD\n #define SANITIZER_INTERCEPT_PROTOENT SI_NETBSD\n #define SANITIZER_INTERCEPT_NETENT SI_NETBSD\n+#define SANITIZER_INTERCEPT_SETVBUF (SI_NETBSD || SI_FREEBSD || \\\n+  SI_LINUX || SI_MAC)\n+#define SANITIZER_INTERCEPT_GETMNTINFO (SI_NETBSD || SI_FREEBSD || SI_MAC)\n+#define SANITIZER_INTERCEPT_MI_VECTOR_HASH SI_NETBSD\n+#define SANITIZER_INTERCEPT_GETVFSSTAT SI_NETBSD\n+#define SANITIZER_INTERCEPT_REGEX (SI_NETBSD || SI_FREEBSD || SI_LINUX)\n+#define SANITIZER_INTERCEPT_REGEXSUB SI_NETBSD\n+#define SANITIZER_INTERCEPT_FTS (SI_NETBSD || SI_FREEBSD)\n+#define SANITIZER_INTERCEPT_SYSCTL (SI_NETBSD || SI_FREEBSD || SI_MAC)\n+#define SANITIZER_INTERCEPT_ASYSCTL SI_NETBSD\n+#define SANITIZER_INTERCEPT_SYSCTLGETMIBINFO SI_NETBSD\n+#define SANITIZER_INTERCEPT_NL_LANGINFO (SI_NETBSD || SI_FREEBSD || SI_MAC)\n+#define SANITIZER_INTERCEPT_MODCTL SI_NETBSD\n+#define SANITIZER_INTERCEPT_CAPSICUM SI_FREEBSD\n+#define SANITIZER_INTERCEPT_STRTONUM (SI_NETBSD || SI_FREEBSD)\n+#define SANITIZER_INTERCEPT_FPARSELN SI_NETBSD\n+#define SANITIZER_INTERCEPT_STATVFS1 SI_NETBSD\n+#define SANITIZER_INTERCEPT_STRTOI SI_NETBSD\n+#define SANITIZER_INTERCEPT_CAPSICUM SI_FREEBSD\n+#define SANITIZER_INTERCEPT_SHA1 SI_NETBSD\n+#define SANITIZER_INTERCEPT_MD4 SI_NETBSD\n+#define SANITIZER_INTERCEPT_RMD160 SI_NETBSD\n+#define SANITIZER_INTERCEPT_MD5 SI_NETBSD\n+#define SANITIZER_INTERCEPT_FSEEK (SI_NETBSD || SI_FREEBSD)\n+#define SANITIZER_INTERCEPT_MD2 SI_NETBSD\n+#define SANITIZER_INTERCEPT_SHA2 SI_NETBSD\n+#define SANITIZER_INTERCEPT_CDB SI_NETBSD\n+#define SANITIZER_INTERCEPT_VIS (SI_NETBSD || SI_FREEBSD)\n+#define SANITIZER_INTERCEPT_POPEN SI_POSIX\n+#define SANITIZER_INTERCEPT_POPENVE SI_NETBSD\n+#define SANITIZER_INTERCEPT_PCLOSE SI_POSIX\n+#define SANITIZER_INTERCEPT_FUNOPEN (SI_NETBSD || SI_FREEBSD)\n+#define SANITIZER_INTERCEPT_FUNOPEN2 SI_NETBSD\n+#define SANITIZER_INTERCEPT_GETFSENT (SI_FREEBSD || SI_NETBSD || SI_MAC)\n+#define SANITIZER_INTERCEPT_ARC4RANDOM (SI_FREEBSD || SI_NETBSD)\n+#define SANITIZER_INTERCEPT_FDEVNAME SI_FREEBSD\n+#define SANITIZER_INTERCEPT_GETUSERSHELL (SI_POSIX && !SI_ANDROID)\n+#define SANITIZER_INTERCEPT_SL_INIT (SI_FREEBSD || SI_NETBSD)\n+\n+#define SANITIZER_INTERCEPT_GETRANDOM SI_LINUX\n \n #endif  // #ifndef SANITIZER_PLATFORM_INTERCEPTORS_H"}, {"sha": "2d1bb1a12da6e40458c6adf639284bf01c202a39", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_freebsd.cpp", "status": "added", "additions": 525, "deletions": 0, "changes": 525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -0,0 +1,525 @@\n+//===-- sanitizer_platform_limits_freebsd.cpp -----------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of Sanitizer common code.\n+//\n+// Sizes and layouts of platform-specific FreeBSD data structures.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+\n+#if SANITIZER_FREEBSD\n+\n+#include <arpa/inet.h>\n+#include <dirent.h>\n+#include <fts.h>\n+#include <fstab.h>\n+#include <grp.h>\n+#include <limits.h>\n+#include <net/if.h>\n+#include <netdb.h>\n+#include <poll.h>\n+#include <pthread.h>\n+#include <pwd.h>\n+#include <regex.h>\n+#include <signal.h>\n+#include <stddef.h>\n+#include <sys/mman.h>\n+#include <sys/capsicum.h>\n+#include <sys/resource.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/times.h>\n+#include <sys/types.h>\n+#include <sys/utsname.h>\n+#include <termios.h>\n+#include <time.h>\n+\n+#include <net/route.h>\n+#include <sys/mount.h>\n+#include <sys/sockio.h>\n+#include <sys/socket.h>\n+#include <sys/filio.h>\n+#include <sys/signal.h>\n+#include <sys/timespec.h>\n+#include <sys/timeb.h>\n+#include <sys/mqueue.h>\n+#include <sys/msg.h>\n+#include <sys/ipc.h>\n+#include <sys/msg.h>\n+#include <sys/statvfs.h>\n+#include <sys/soundcard.h>\n+#include <sys/mtio.h>\n+#include <sys/consio.h>\n+#include <sys/kbio.h>\n+#include <sys/link_elf.h>\n+#include <netinet/ip_mroute.h>\n+#include <netinet/in.h>\n+#include <net/ethernet.h>\n+#include <net/ppp_defs.h>\n+#include <glob.h>\n+#include <stdio.h>\n+#include <stringlist.h>\n+#include <term.h>\n+#include <utmpx.h>\n+#include <wchar.h>\n+#include <vis.h>\n+\n+#define _KERNEL  // to declare 'shminfo' structure\n+# include <sys/shm.h>\n+#undef _KERNEL\n+\n+#undef INLINE  // to avoid clashes with sanitizers' definitions\n+\n+#undef IOC_DIRMASK\n+\n+# include <utime.h>\n+# include <sys/ptrace.h>\n+# include <semaphore.h>\n+\n+#include <ifaddrs.h>\n+#include <sys/ucontext.h>\n+#include <wordexp.h>\n+\n+// Include these after system headers to avoid name clashes and ambiguities.\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_platform_limits_freebsd.h\"\n+\n+namespace __sanitizer {\n+  unsigned struct_cap_rights_sz = sizeof(cap_rights_t);\n+  unsigned struct_utsname_sz = sizeof(struct utsname);\n+  unsigned struct_stat_sz = sizeof(struct stat);\n+  unsigned struct_rusage_sz = sizeof(struct rusage);\n+  unsigned struct_tm_sz = sizeof(struct tm);\n+  unsigned struct_passwd_sz = sizeof(struct passwd);\n+  unsigned struct_group_sz = sizeof(struct group);\n+  unsigned siginfo_t_sz = sizeof(siginfo_t);\n+  unsigned struct_sigaction_sz = sizeof(struct sigaction);\n+  unsigned struct_itimerval_sz = sizeof(struct itimerval);\n+  unsigned pthread_t_sz = sizeof(pthread_t);\n+  unsigned pthread_mutex_t_sz = sizeof(pthread_mutex_t);\n+  unsigned pthread_cond_t_sz = sizeof(pthread_cond_t);\n+  unsigned pid_t_sz = sizeof(pid_t);\n+  unsigned timeval_sz = sizeof(timeval);\n+  unsigned uid_t_sz = sizeof(uid_t);\n+  unsigned gid_t_sz = sizeof(gid_t);\n+  unsigned fpos_t_sz = sizeof(fpos_t);\n+  unsigned mbstate_t_sz = sizeof(mbstate_t);\n+  unsigned sigset_t_sz = sizeof(sigset_t);\n+  unsigned struct_timezone_sz = sizeof(struct timezone);\n+  unsigned struct_tms_sz = sizeof(struct tms);\n+  unsigned struct_sigevent_sz = sizeof(struct sigevent);\n+  unsigned struct_sched_param_sz = sizeof(struct sched_param);\n+  unsigned struct_statfs_sz = sizeof(struct statfs);\n+  unsigned struct_sockaddr_sz = sizeof(struct sockaddr);\n+  unsigned ucontext_t_sz = sizeof(ucontext_t);\n+  unsigned struct_rlimit_sz = sizeof(struct rlimit);\n+  unsigned struct_timespec_sz = sizeof(struct timespec);\n+  unsigned struct_utimbuf_sz = sizeof(struct utimbuf);\n+  unsigned struct_itimerspec_sz = sizeof(struct itimerspec);\n+  unsigned struct_timeb_sz = sizeof(struct timeb);\n+  unsigned struct_msqid_ds_sz = sizeof(struct msqid_ds);\n+  unsigned struct_mq_attr_sz = sizeof(struct mq_attr);\n+  unsigned struct_statvfs_sz = sizeof(struct statvfs);\n+  unsigned struct_shminfo_sz = sizeof(struct shminfo);\n+  unsigned struct_shm_info_sz = sizeof(struct shm_info);\n+  unsigned struct_regmatch_sz = sizeof(regmatch_t);\n+  unsigned struct_regex_sz = sizeof(regex_t);\n+  unsigned struct_fstab_sz = sizeof(struct fstab);\n+  unsigned struct_FTS_sz = sizeof(FTS);\n+  unsigned struct_FTSENT_sz = sizeof(FTSENT);\n+  unsigned struct_StringList_sz = sizeof(StringList);\n+\n+  const uptr sig_ign = (uptr)SIG_IGN;\n+  const uptr sig_dfl = (uptr)SIG_DFL;\n+  const uptr sig_err = (uptr)SIG_ERR;\n+  const uptr sa_siginfo = (uptr)SA_SIGINFO;\n+\n+  int shmctl_ipc_stat = (int)IPC_STAT;\n+  int shmctl_ipc_info = (int)IPC_INFO;\n+  int shmctl_shm_info = (int)SHM_INFO;\n+  int shmctl_shm_stat = (int)SHM_STAT;\n+  unsigned struct_utmpx_sz = sizeof(struct utmpx);\n+\n+  int map_fixed = MAP_FIXED;\n+\n+  int af_inet = (int)AF_INET;\n+  int af_inet6 = (int)AF_INET6;\n+\n+  uptr __sanitizer_in_addr_sz(int af) {\n+    if (af == AF_INET)\n+      return sizeof(struct in_addr);\n+    else if (af == AF_INET6)\n+      return sizeof(struct in6_addr);\n+    else\n+      return 0;\n+  }\n+\n+  unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n+  int glob_nomatch = GLOB_NOMATCH;\n+  int glob_altdirfunc = GLOB_ALTDIRFUNC;\n+\n+  unsigned path_max = PATH_MAX;\n+\n+  // ioctl arguments\n+  unsigned struct_ifreq_sz = sizeof(struct ifreq);\n+  unsigned struct_termios_sz = sizeof(struct termios);\n+  unsigned struct_winsize_sz = sizeof(struct winsize);\n+#if SOUND_VERSION >= 0x040000\n+  unsigned struct_copr_buffer_sz = 0;\n+  unsigned struct_copr_debug_buf_sz = 0;\n+  unsigned struct_copr_msg_sz = 0;\n+#else\n+  unsigned struct_copr_buffer_sz = sizeof(struct copr_buffer);\n+  unsigned struct_copr_debug_buf_sz = sizeof(struct copr_debug_buf);\n+  unsigned struct_copr_msg_sz = sizeof(struct copr_msg);\n+#endif\n+  unsigned struct_midi_info_sz = sizeof(struct midi_info);\n+  unsigned struct_mtget_sz = sizeof(struct mtget);\n+  unsigned struct_mtop_sz = sizeof(struct mtop);\n+  unsigned struct_sbi_instrument_sz = sizeof(struct sbi_instrument);\n+  unsigned struct_seq_event_rec_sz = sizeof(struct seq_event_rec);\n+  unsigned struct_synth_info_sz = sizeof(struct synth_info);\n+  unsigned struct_audio_buf_info_sz = sizeof(struct audio_buf_info);\n+  unsigned struct_ppp_stats_sz = sizeof(struct ppp_stats);\n+  unsigned struct_sioc_sg_req_sz = sizeof(struct sioc_sg_req);\n+  unsigned struct_sioc_vif_req_sz = sizeof(struct sioc_vif_req);\n+  const unsigned long __sanitizer_bufsiz = BUFSIZ;\n+\n+  const unsigned IOCTL_NOT_PRESENT = 0;\n+\n+  unsigned IOCTL_FIOASYNC = FIOASYNC;\n+  unsigned IOCTL_FIOCLEX = FIOCLEX;\n+  unsigned IOCTL_FIOGETOWN = FIOGETOWN;\n+  unsigned IOCTL_FIONBIO = FIONBIO;\n+  unsigned IOCTL_FIONCLEX = FIONCLEX;\n+  unsigned IOCTL_FIOSETOWN = FIOSETOWN;\n+  unsigned IOCTL_SIOCADDMULTI = SIOCADDMULTI;\n+  unsigned IOCTL_SIOCATMARK = SIOCATMARK;\n+  unsigned IOCTL_SIOCDELMULTI = SIOCDELMULTI;\n+  unsigned IOCTL_SIOCGIFADDR = SIOCGIFADDR;\n+  unsigned IOCTL_SIOCGIFBRDADDR = SIOCGIFBRDADDR;\n+  unsigned IOCTL_SIOCGIFCONF = SIOCGIFCONF;\n+  unsigned IOCTL_SIOCGIFDSTADDR = SIOCGIFDSTADDR;\n+  unsigned IOCTL_SIOCGIFFLAGS = SIOCGIFFLAGS;\n+  unsigned IOCTL_SIOCGIFMETRIC = SIOCGIFMETRIC;\n+  unsigned IOCTL_SIOCGIFMTU = SIOCGIFMTU;\n+  unsigned IOCTL_SIOCGIFNETMASK = SIOCGIFNETMASK;\n+  unsigned IOCTL_SIOCGPGRP = SIOCGPGRP;\n+  unsigned IOCTL_SIOCSIFADDR = SIOCSIFADDR;\n+  unsigned IOCTL_SIOCSIFBRDADDR = SIOCSIFBRDADDR;\n+  unsigned IOCTL_SIOCSIFDSTADDR = SIOCSIFDSTADDR;\n+  unsigned IOCTL_SIOCSIFFLAGS = SIOCSIFFLAGS;\n+  unsigned IOCTL_SIOCSIFMETRIC = SIOCSIFMETRIC;\n+  unsigned IOCTL_SIOCSIFMTU = SIOCSIFMTU;\n+  unsigned IOCTL_SIOCSIFNETMASK = SIOCSIFNETMASK;\n+  unsigned IOCTL_SIOCSPGRP = SIOCSPGRP;\n+  unsigned IOCTL_TIOCCONS = TIOCCONS;\n+  unsigned IOCTL_TIOCEXCL = TIOCEXCL;\n+  unsigned IOCTL_TIOCGETD = TIOCGETD;\n+  unsigned IOCTL_TIOCGPGRP = TIOCGPGRP;\n+  unsigned IOCTL_TIOCGWINSZ = TIOCGWINSZ;\n+  unsigned IOCTL_TIOCMBIC = TIOCMBIC;\n+  unsigned IOCTL_TIOCMBIS = TIOCMBIS;\n+  unsigned IOCTL_TIOCMGET = TIOCMGET;\n+  unsigned IOCTL_TIOCMSET = TIOCMSET;\n+  unsigned IOCTL_TIOCNOTTY = TIOCNOTTY;\n+  unsigned IOCTL_TIOCNXCL = TIOCNXCL;\n+  unsigned IOCTL_TIOCOUTQ = TIOCOUTQ;\n+  unsigned IOCTL_TIOCPKT = TIOCPKT;\n+  unsigned IOCTL_TIOCSCTTY = TIOCSCTTY;\n+  unsigned IOCTL_TIOCSETD = TIOCSETD;\n+  unsigned IOCTL_TIOCSPGRP = TIOCSPGRP;\n+  unsigned IOCTL_TIOCSTI = TIOCSTI;\n+  unsigned IOCTL_TIOCSWINSZ = TIOCSWINSZ;\n+  unsigned IOCTL_SIOCGETSGCNT = SIOCGETSGCNT;\n+  unsigned IOCTL_SIOCGETVIFCNT = SIOCGETVIFCNT;\n+  unsigned IOCTL_MTIOCGET = MTIOCGET;\n+  unsigned IOCTL_MTIOCTOP = MTIOCTOP;\n+  unsigned IOCTL_SNDCTL_DSP_GETBLKSIZE = SNDCTL_DSP_GETBLKSIZE;\n+  unsigned IOCTL_SNDCTL_DSP_GETFMTS = SNDCTL_DSP_GETFMTS;\n+  unsigned IOCTL_SNDCTL_DSP_NONBLOCK = SNDCTL_DSP_NONBLOCK;\n+  unsigned IOCTL_SNDCTL_DSP_POST = SNDCTL_DSP_POST;\n+  unsigned IOCTL_SNDCTL_DSP_RESET = SNDCTL_DSP_RESET;\n+  unsigned IOCTL_SNDCTL_DSP_SETFMT = SNDCTL_DSP_SETFMT;\n+  unsigned IOCTL_SNDCTL_DSP_SETFRAGMENT = SNDCTL_DSP_SETFRAGMENT;\n+  unsigned IOCTL_SNDCTL_DSP_SPEED = SNDCTL_DSP_SPEED;\n+  unsigned IOCTL_SNDCTL_DSP_STEREO = SNDCTL_DSP_STEREO;\n+  unsigned IOCTL_SNDCTL_DSP_SUBDIVIDE = SNDCTL_DSP_SUBDIVIDE;\n+  unsigned IOCTL_SNDCTL_DSP_SYNC = SNDCTL_DSP_SYNC;\n+  unsigned IOCTL_SNDCTL_FM_4OP_ENABLE = SNDCTL_FM_4OP_ENABLE;\n+  unsigned IOCTL_SNDCTL_FM_LOAD_INSTR = SNDCTL_FM_LOAD_INSTR;\n+  unsigned IOCTL_SNDCTL_MIDI_INFO = SNDCTL_MIDI_INFO;\n+  unsigned IOCTL_SNDCTL_MIDI_PRETIME = SNDCTL_MIDI_PRETIME;\n+  unsigned IOCTL_SNDCTL_SEQ_CTRLRATE = SNDCTL_SEQ_CTRLRATE;\n+  unsigned IOCTL_SNDCTL_SEQ_GETINCOUNT = SNDCTL_SEQ_GETINCOUNT;\n+  unsigned IOCTL_SNDCTL_SEQ_GETOUTCOUNT = SNDCTL_SEQ_GETOUTCOUNT;\n+  unsigned IOCTL_SNDCTL_SEQ_NRMIDIS = SNDCTL_SEQ_NRMIDIS;\n+  unsigned IOCTL_SNDCTL_SEQ_NRSYNTHS = SNDCTL_SEQ_NRSYNTHS;\n+  unsigned IOCTL_SNDCTL_SEQ_OUTOFBAND = SNDCTL_SEQ_OUTOFBAND;\n+  unsigned IOCTL_SNDCTL_SEQ_PANIC = SNDCTL_SEQ_PANIC;\n+  unsigned IOCTL_SNDCTL_SEQ_PERCMODE = SNDCTL_SEQ_PERCMODE;\n+  unsigned IOCTL_SNDCTL_SEQ_RESET = SNDCTL_SEQ_RESET;\n+  unsigned IOCTL_SNDCTL_SEQ_RESETSAMPLES = SNDCTL_SEQ_RESETSAMPLES;\n+  unsigned IOCTL_SNDCTL_SEQ_SYNC = SNDCTL_SEQ_SYNC;\n+  unsigned IOCTL_SNDCTL_SEQ_TESTMIDI = SNDCTL_SEQ_TESTMIDI;\n+  unsigned IOCTL_SNDCTL_SEQ_THRESHOLD = SNDCTL_SEQ_THRESHOLD;\n+  unsigned IOCTL_SNDCTL_SYNTH_INFO = SNDCTL_SYNTH_INFO;\n+  unsigned IOCTL_SNDCTL_SYNTH_MEMAVL = SNDCTL_SYNTH_MEMAVL;\n+  unsigned IOCTL_SNDCTL_TMR_CONTINUE = SNDCTL_TMR_CONTINUE;\n+  unsigned IOCTL_SNDCTL_TMR_METRONOME = SNDCTL_TMR_METRONOME;\n+  unsigned IOCTL_SNDCTL_TMR_SELECT = SNDCTL_TMR_SELECT;\n+  unsigned IOCTL_SNDCTL_TMR_SOURCE = SNDCTL_TMR_SOURCE;\n+  unsigned IOCTL_SNDCTL_TMR_START = SNDCTL_TMR_START;\n+  unsigned IOCTL_SNDCTL_TMR_STOP = SNDCTL_TMR_STOP;\n+  unsigned IOCTL_SNDCTL_TMR_TEMPO = SNDCTL_TMR_TEMPO;\n+  unsigned IOCTL_SNDCTL_TMR_TIMEBASE = SNDCTL_TMR_TIMEBASE;\n+  unsigned IOCTL_SOUND_MIXER_READ_ALTPCM = SOUND_MIXER_READ_ALTPCM;\n+  unsigned IOCTL_SOUND_MIXER_READ_BASS = SOUND_MIXER_READ_BASS;\n+  unsigned IOCTL_SOUND_MIXER_READ_CAPS = SOUND_MIXER_READ_CAPS;\n+  unsigned IOCTL_SOUND_MIXER_READ_CD = SOUND_MIXER_READ_CD;\n+  unsigned IOCTL_SOUND_MIXER_READ_DEVMASK = SOUND_MIXER_READ_DEVMASK;\n+  unsigned IOCTL_SOUND_MIXER_READ_ENHANCE = SOUND_MIXER_READ_ENHANCE;\n+  unsigned IOCTL_SOUND_MIXER_READ_IGAIN = SOUND_MIXER_READ_IGAIN;\n+  unsigned IOCTL_SOUND_MIXER_READ_IMIX = SOUND_MIXER_READ_IMIX;\n+  unsigned IOCTL_SOUND_MIXER_READ_LINE = SOUND_MIXER_READ_LINE;\n+  unsigned IOCTL_SOUND_MIXER_READ_LINE1 = SOUND_MIXER_READ_LINE1;\n+  unsigned IOCTL_SOUND_MIXER_READ_LINE2 = SOUND_MIXER_READ_LINE2;\n+  unsigned IOCTL_SOUND_MIXER_READ_LINE3 = SOUND_MIXER_READ_LINE3;\n+  unsigned IOCTL_SOUND_MIXER_READ_LOUD = SOUND_MIXER_READ_LOUD;\n+  unsigned IOCTL_SOUND_MIXER_READ_MIC = SOUND_MIXER_READ_MIC;\n+  unsigned IOCTL_SOUND_MIXER_READ_MUTE = SOUND_MIXER_READ_MUTE;\n+  unsigned IOCTL_SOUND_MIXER_READ_OGAIN = SOUND_MIXER_READ_OGAIN;\n+  unsigned IOCTL_SOUND_MIXER_READ_PCM = SOUND_MIXER_READ_PCM;\n+  unsigned IOCTL_SOUND_MIXER_READ_RECLEV = SOUND_MIXER_READ_RECLEV;\n+  unsigned IOCTL_SOUND_MIXER_READ_RECMASK = SOUND_MIXER_READ_RECMASK;\n+  unsigned IOCTL_SOUND_MIXER_READ_RECSRC = SOUND_MIXER_READ_RECSRC;\n+  unsigned IOCTL_SOUND_MIXER_READ_SPEAKER = SOUND_MIXER_READ_SPEAKER;\n+  unsigned IOCTL_SOUND_MIXER_READ_STEREODEVS = SOUND_MIXER_READ_STEREODEVS;\n+  unsigned IOCTL_SOUND_MIXER_READ_SYNTH = SOUND_MIXER_READ_SYNTH;\n+  unsigned IOCTL_SOUND_MIXER_READ_TREBLE = SOUND_MIXER_READ_TREBLE;\n+  unsigned IOCTL_SOUND_MIXER_READ_VOLUME = SOUND_MIXER_READ_VOLUME;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_ALTPCM = SOUND_MIXER_WRITE_ALTPCM;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_BASS = SOUND_MIXER_WRITE_BASS;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_CD = SOUND_MIXER_WRITE_CD;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_ENHANCE = SOUND_MIXER_WRITE_ENHANCE;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_IGAIN = SOUND_MIXER_WRITE_IGAIN;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_IMIX = SOUND_MIXER_WRITE_IMIX;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_LINE = SOUND_MIXER_WRITE_LINE;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_LINE1 = SOUND_MIXER_WRITE_LINE1;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_LINE2 = SOUND_MIXER_WRITE_LINE2;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_LINE3 = SOUND_MIXER_WRITE_LINE3;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_LOUD = SOUND_MIXER_WRITE_LOUD;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_MIC = SOUND_MIXER_WRITE_MIC;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_MUTE = SOUND_MIXER_WRITE_MUTE;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_OGAIN = SOUND_MIXER_WRITE_OGAIN;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_PCM = SOUND_MIXER_WRITE_PCM;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_RECLEV = SOUND_MIXER_WRITE_RECLEV;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_RECSRC = SOUND_MIXER_WRITE_RECSRC;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_SPEAKER = SOUND_MIXER_WRITE_SPEAKER;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_SYNTH = SOUND_MIXER_WRITE_SYNTH;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_TREBLE = SOUND_MIXER_WRITE_TREBLE;\n+  unsigned IOCTL_SOUND_MIXER_WRITE_VOLUME = SOUND_MIXER_WRITE_VOLUME;\n+  unsigned IOCTL_VT_ACTIVATE = VT_ACTIVATE;\n+  unsigned IOCTL_VT_GETMODE = VT_GETMODE;\n+  unsigned IOCTL_VT_OPENQRY = VT_OPENQRY;\n+  unsigned IOCTL_VT_RELDISP = VT_RELDISP;\n+  unsigned IOCTL_VT_SETMODE = VT_SETMODE;\n+  unsigned IOCTL_VT_WAITACTIVE = VT_WAITACTIVE;\n+  unsigned IOCTL_GIO_SCRNMAP = GIO_SCRNMAP;\n+  unsigned IOCTL_KDDISABIO = KDDISABIO;\n+  unsigned IOCTL_KDENABIO = KDENABIO;\n+  unsigned IOCTL_KDGETLED = KDGETLED;\n+  unsigned IOCTL_KDGETMODE = KDGETMODE;\n+  unsigned IOCTL_KDGKBMODE = KDGKBMODE;\n+  unsigned IOCTL_KDGKBTYPE = KDGKBTYPE;\n+  unsigned IOCTL_KDMKTONE = KDMKTONE;\n+  unsigned IOCTL_KDSETLED = KDSETLED;\n+  unsigned IOCTL_KDSETMODE = KDSETMODE;\n+  unsigned IOCTL_KDSKBMODE = KDSKBMODE;\n+  unsigned IOCTL_KIOCSOUND = KIOCSOUND;\n+  unsigned IOCTL_PIO_SCRNMAP = PIO_SCRNMAP;\n+  unsigned IOCTL_SNDCTL_DSP_GETISPACE = SNDCTL_DSP_GETISPACE;\n+\n+  const int si_SEGV_MAPERR = SEGV_MAPERR;\n+  const int si_SEGV_ACCERR = SEGV_ACCERR;\n+  const int unvis_valid = UNVIS_VALID;\n+  const int unvis_validpush = UNVIS_VALIDPUSH;\n+} // namespace __sanitizer\n+\n+using namespace __sanitizer;\n+\n+COMPILER_CHECK(sizeof(__sanitizer_pthread_attr_t) >= sizeof(pthread_attr_t));\n+\n+COMPILER_CHECK(sizeof(socklen_t) == sizeof(unsigned));\n+CHECK_TYPE_SIZE(pthread_key_t);\n+\n+// There are more undocumented fields in dl_phdr_info that we are not interested\n+// in.\n+COMPILER_CHECK(sizeof(__sanitizer_dl_phdr_info) <= sizeof(dl_phdr_info));\n+CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_addr);\n+CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_name);\n+CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_phdr);\n+CHECK_SIZE_AND_OFFSET(dl_phdr_info, dlpi_phnum);\n+\n+CHECK_TYPE_SIZE(glob_t);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_pathc);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_pathv);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_offs);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_flags);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_closedir);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_readdir);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_opendir);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_lstat);\n+CHECK_SIZE_AND_OFFSET(glob_t, gl_stat);\n+\n+CHECK_TYPE_SIZE(addrinfo);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_flags);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_family);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_socktype);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_protocol);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_protocol);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_addrlen);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_canonname);\n+CHECK_SIZE_AND_OFFSET(addrinfo, ai_addr);\n+\n+CHECK_TYPE_SIZE(hostent);\n+CHECK_SIZE_AND_OFFSET(hostent, h_name);\n+CHECK_SIZE_AND_OFFSET(hostent, h_aliases);\n+CHECK_SIZE_AND_OFFSET(hostent, h_addrtype);\n+CHECK_SIZE_AND_OFFSET(hostent, h_length);\n+CHECK_SIZE_AND_OFFSET(hostent, h_addr_list);\n+\n+CHECK_TYPE_SIZE(iovec);\n+CHECK_SIZE_AND_OFFSET(iovec, iov_base);\n+CHECK_SIZE_AND_OFFSET(iovec, iov_len);\n+\n+CHECK_TYPE_SIZE(msghdr);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_name);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_namelen);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_iov);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_iovlen);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_control);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_controllen);\n+CHECK_SIZE_AND_OFFSET(msghdr, msg_flags);\n+\n+CHECK_TYPE_SIZE(cmsghdr);\n+CHECK_SIZE_AND_OFFSET(cmsghdr, cmsg_len);\n+CHECK_SIZE_AND_OFFSET(cmsghdr, cmsg_level);\n+CHECK_SIZE_AND_OFFSET(cmsghdr, cmsg_type);\n+\n+COMPILER_CHECK(sizeof(__sanitizer_dirent) <= sizeof(dirent));\n+CHECK_SIZE_AND_OFFSET(dirent, d_ino);\n+CHECK_SIZE_AND_OFFSET(dirent, d_reclen);\n+\n+CHECK_TYPE_SIZE(ifconf);\n+CHECK_SIZE_AND_OFFSET(ifconf, ifc_len);\n+CHECK_SIZE_AND_OFFSET(ifconf, ifc_ifcu);\n+\n+CHECK_TYPE_SIZE(pollfd);\n+CHECK_SIZE_AND_OFFSET(pollfd, fd);\n+CHECK_SIZE_AND_OFFSET(pollfd, events);\n+CHECK_SIZE_AND_OFFSET(pollfd, revents);\n+\n+CHECK_TYPE_SIZE(nfds_t);\n+\n+CHECK_TYPE_SIZE(sigset_t);\n+\n+COMPILER_CHECK(sizeof(__sanitizer_sigaction) == sizeof(struct sigaction));\n+// Can't write checks for sa_handler and sa_sigaction due to them being\n+// preprocessor macros.\n+CHECK_STRUCT_SIZE_AND_OFFSET(sigaction, sa_mask);\n+\n+CHECK_TYPE_SIZE(wordexp_t);\n+CHECK_SIZE_AND_OFFSET(wordexp_t, we_wordc);\n+CHECK_SIZE_AND_OFFSET(wordexp_t, we_wordv);\n+CHECK_SIZE_AND_OFFSET(wordexp_t, we_offs);\n+\n+CHECK_TYPE_SIZE(tm);\n+CHECK_SIZE_AND_OFFSET(tm, tm_sec);\n+CHECK_SIZE_AND_OFFSET(tm, tm_min);\n+CHECK_SIZE_AND_OFFSET(tm, tm_hour);\n+CHECK_SIZE_AND_OFFSET(tm, tm_mday);\n+CHECK_SIZE_AND_OFFSET(tm, tm_mon);\n+CHECK_SIZE_AND_OFFSET(tm, tm_year);\n+CHECK_SIZE_AND_OFFSET(tm, tm_wday);\n+CHECK_SIZE_AND_OFFSET(tm, tm_yday);\n+CHECK_SIZE_AND_OFFSET(tm, tm_isdst);\n+CHECK_SIZE_AND_OFFSET(tm, tm_gmtoff);\n+CHECK_SIZE_AND_OFFSET(tm, tm_zone);\n+\n+CHECK_TYPE_SIZE(ether_addr);\n+\n+CHECK_TYPE_SIZE(ipc_perm);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, key);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, seq);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, uid);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, gid);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, cuid);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, cgid);\n+\n+CHECK_TYPE_SIZE(shmid_ds);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_perm);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_segsz);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_atime);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_dtime);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_ctime);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_cpid);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_lpid);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_nattch);\n+\n+CHECK_TYPE_SIZE(clock_t);\n+\n+CHECK_TYPE_SIZE(ifaddrs);\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_next);\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_name);\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_addr);\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_netmask);\n+#undef ifa_dstaddr\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_dstaddr);\n+CHECK_SIZE_AND_OFFSET(ifaddrs, ifa_data);\n+\n+CHECK_TYPE_SIZE(timeb);\n+CHECK_SIZE_AND_OFFSET(timeb, time);\n+CHECK_SIZE_AND_OFFSET(timeb, millitm);\n+CHECK_SIZE_AND_OFFSET(timeb, timezone);\n+CHECK_SIZE_AND_OFFSET(timeb, dstflag);\n+\n+CHECK_TYPE_SIZE(passwd);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_name);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_passwd);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_uid);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_gid);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_dir);\n+CHECK_SIZE_AND_OFFSET(passwd, pw_shell);\n+\n+CHECK_SIZE_AND_OFFSET(passwd, pw_gecos);\n+\n+CHECK_TYPE_SIZE(group);\n+CHECK_SIZE_AND_OFFSET(group, gr_name);\n+CHECK_SIZE_AND_OFFSET(group, gr_passwd);\n+CHECK_SIZE_AND_OFFSET(group, gr_gid);\n+CHECK_SIZE_AND_OFFSET(group, gr_mem);\n+\n+#if HAVE_RPC_XDR_H\n+CHECK_TYPE_SIZE(XDR);\n+CHECK_SIZE_AND_OFFSET(XDR, x_op);\n+CHECK_SIZE_AND_OFFSET(XDR, x_ops);\n+CHECK_SIZE_AND_OFFSET(XDR, x_public);\n+CHECK_SIZE_AND_OFFSET(XDR, x_private);\n+CHECK_SIZE_AND_OFFSET(XDR, x_base);\n+CHECK_SIZE_AND_OFFSET(XDR, x_handy);\n+COMPILER_CHECK(__sanitizer_XDR_ENCODE == XDR_ENCODE);\n+COMPILER_CHECK(__sanitizer_XDR_DECODE == XDR_DECODE);\n+COMPILER_CHECK(__sanitizer_XDR_FREE == XDR_FREE);\n+#endif\n+\n+CHECK_TYPE_SIZE(sem_t);\n+\n+COMPILER_CHECK(sizeof(__sanitizer_cap_rights_t) >= sizeof(cap_rights_t));\n+#endif  // SANITIZER_FREEBSD"}, {"sha": "46307c6c4340fc3b3e2dc64ea06c63adc81e83ef", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_freebsd.h", "status": "added", "additions": 656, "deletions": 0, "changes": 656, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_freebsd.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -0,0 +1,656 @@\n+//===-- sanitizer_platform_limits_freebsd.h -------------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of Sanitizer common code.\n+//\n+// Sizes and layouts of platform-specific FreeBSD data structures.\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_PLATFORM_LIMITS_FREEBSD_H\n+#define SANITIZER_PLATFORM_LIMITS_FREEBSD_H\n+\n+#if SANITIZER_FREEBSD\n+\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_platform.h\"\n+\n+#include \"sanitizer_platform_limits_posix.h\"\n+\n+// FreeBSD's dlopen() returns a pointer to an Obj_Entry structure that\n+// incorporates the map structure.\n+# define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) \\\n+    ((link_map*)((handle) == nullptr ? nullptr : ((char*)(handle) + 560)))\n+// Get sys/_types.h, because that tells us whether 64-bit inodes are\n+// used in struct dirent below.\n+#include <sys/_types.h>\n+\n+namespace __sanitizer {\n+  extern unsigned struct_utsname_sz;\n+  extern unsigned struct_stat_sz;\n+#if defined(__powerpc64__)\n+  const unsigned struct___old_kernel_stat_sz = 0;\n+#else\n+  const unsigned struct___old_kernel_stat_sz = 32;\n+#endif\n+  extern unsigned struct_rusage_sz;\n+  extern unsigned siginfo_t_sz;\n+  extern unsigned struct_itimerval_sz;\n+  extern unsigned pthread_t_sz;\n+  extern unsigned pthread_mutex_t_sz;\n+  extern unsigned pthread_cond_t_sz;\n+  extern unsigned pid_t_sz;\n+  extern unsigned timeval_sz;\n+  extern unsigned uid_t_sz;\n+  extern unsigned gid_t_sz;\n+  extern unsigned fpos_t_sz;\n+  extern unsigned mbstate_t_sz;\n+  extern unsigned struct_timezone_sz;\n+  extern unsigned struct_tms_sz;\n+  extern unsigned struct_itimerspec_sz;\n+  extern unsigned struct_sigevent_sz;\n+  extern unsigned struct_sched_param_sz;\n+  extern unsigned struct_statfs64_sz;\n+  extern unsigned struct_statfs_sz;\n+  extern unsigned struct_sockaddr_sz;\n+  extern unsigned ucontext_t_sz;\n+  extern unsigned struct_rlimit_sz;\n+  extern unsigned struct_utimbuf_sz;\n+  extern unsigned struct_timespec_sz;\n+  extern unsigned struct_regmatch_sz;\n+  extern unsigned struct_regex_sz;\n+  extern unsigned struct_FTS_sz;\n+  extern unsigned struct_FTSENT_sz;\n+  extern const int unvis_valid;\n+  extern const int unvis_validpush;\n+\n+  struct __sanitizer_iocb {\n+    u64   aio_data;\n+    u32   aio_key_or_aio_reserved1; // Simply crazy.\n+    u32   aio_reserved1_or_aio_key; // Luckily, we don't need these.\n+    u16   aio_lio_opcode;\n+    s16   aio_reqprio;\n+    u32   aio_fildes;\n+    u64   aio_buf;\n+    u64   aio_nbytes;\n+    s64   aio_offset;\n+    u64   aio_reserved2;\n+    u64   aio_reserved3;\n+  };\n+\n+  struct __sanitizer_io_event {\n+    u64 data;\n+    u64 obj;\n+    u64 res;\n+    u64 res2;\n+  };\n+\n+  const unsigned iocb_cmd_pread = 0;\n+  const unsigned iocb_cmd_pwrite = 1;\n+  const unsigned iocb_cmd_preadv = 7;\n+  const unsigned iocb_cmd_pwritev = 8;\n+\n+  struct __sanitizer___sysctl_args {\n+    int *name;\n+    int nlen;\n+    void *oldval;\n+    uptr *oldlenp;\n+    void *newval;\n+    uptr newlen;\n+    unsigned long ___unused[4];\n+  };\n+\n+  struct __sanitizer_ipc_perm {\n+    unsigned int cuid;\n+    unsigned int cgid;\n+    unsigned int uid;\n+    unsigned int gid;\n+    unsigned short mode;\n+    unsigned short seq;\n+    long key;\n+  };\n+\n+  struct __sanitizer_shmid_ds {\n+    __sanitizer_ipc_perm shm_perm;\n+    unsigned long shm_segsz;\n+    unsigned int shm_lpid;\n+    unsigned int shm_cpid;\n+    int shm_nattch;\n+    unsigned long shm_atime;\n+    unsigned long shm_dtime;\n+    unsigned long shm_ctime;\n+  };\n+\n+  extern unsigned struct_msqid_ds_sz;\n+  extern unsigned struct_mq_attr_sz;\n+  extern unsigned struct_timeb_sz;\n+  extern unsigned struct_statvfs_sz;\n+\n+  struct __sanitizer_iovec {\n+    void *iov_base;\n+    uptr iov_len;\n+  };\n+\n+  struct __sanitizer_ifaddrs {\n+    struct __sanitizer_ifaddrs *ifa_next;\n+    char *ifa_name;\n+    unsigned int ifa_flags;\n+    void *ifa_addr;    // (struct sockaddr *)\n+    void *ifa_netmask; // (struct sockaddr *)\n+# undef ifa_dstaddr\n+    void *ifa_dstaddr; // (struct sockaddr *)\n+    void *ifa_data;\n+  };\n+\n+  typedef unsigned __sanitizer_pthread_key_t;\n+\n+  struct __sanitizer_passwd {\n+    char *pw_name;\n+    char *pw_passwd;\n+    int pw_uid;\n+    int pw_gid;\n+    long pw_change;\n+    char *pw_class;\n+    char *pw_gecos;\n+    char *pw_dir;\n+    char *pw_shell;\n+    long pw_expire;\n+    int pw_fields;\n+  };\n+\n+  struct __sanitizer_group {\n+    char *gr_name;\n+    char *gr_passwd;\n+    int gr_gid;\n+    char **gr_mem;\n+  };\n+\n+#if defined(__LP64___)\n+  typedef long long __sanitizer_time_t;\n+#else\n+  typedef long __sanitizer_time_t;\n+#endif\n+\n+  typedef long __sanitizer_suseconds_t;\n+\n+  struct __sanitizer_timeval {\n+    __sanitizer_time_t tv_sec;\n+    __sanitizer_suseconds_t tv_usec;\n+  };\n+\n+  struct __sanitizer_itimerval {\n+    struct __sanitizer_timeval it_interval;\n+    struct __sanitizer_timeval it_value;\n+  };\n+\n+  struct __sanitizer_timeb {\n+    __sanitizer_time_t time;\n+    unsigned short millitm;\n+    short timezone;\n+    short dstflag;\n+  };\n+\n+  struct __sanitizer_ether_addr {\n+    u8 octet[6];\n+  };\n+\n+  struct __sanitizer_tm {\n+    int tm_sec;\n+    int tm_min;\n+    int tm_hour;\n+    int tm_mday;\n+    int tm_mon;\n+    int tm_year;\n+    int tm_wday;\n+    int tm_yday;\n+    int tm_isdst;\n+    long int tm_gmtoff;\n+    const char *tm_zone;\n+  };\n+\n+  struct __sanitizer_msghdr {\n+    void *msg_name;\n+    unsigned msg_namelen;\n+    struct __sanitizer_iovec *msg_iov;\n+    unsigned msg_iovlen;\n+    void *msg_control;\n+    unsigned msg_controllen;\n+    int msg_flags;\n+  };\n+\n+  struct __sanitizer_cmsghdr {\n+    unsigned cmsg_len;\n+    int cmsg_level;\n+    int cmsg_type;\n+  };\n+\n+  struct __sanitizer_dirent {\n+#if defined(__INO64)\n+    unsigned long long d_fileno;\n+    unsigned long long d_off;\n+#else\n+    unsigned int d_fileno;\n+#endif\n+    unsigned short d_reclen;\n+    // more fields that we don't care about\n+  };\n+\n+// 'clock_t' is 32 bits wide on x64 FreeBSD\n+  typedef int __sanitizer_clock_t;\n+  typedef int __sanitizer_clockid_t;\n+\n+#if defined(_LP64) || defined(__x86_64__) || defined(__powerpc__)\\\n+                   || defined(__mips__)\n+  typedef unsigned __sanitizer___kernel_uid_t;\n+  typedef unsigned __sanitizer___kernel_gid_t;\n+#else\n+  typedef unsigned short __sanitizer___kernel_uid_t;\n+  typedef unsigned short __sanitizer___kernel_gid_t;\n+#endif\n+  typedef long long __sanitizer___kernel_off_t;\n+\n+#if defined(__powerpc__) || defined(__mips__)\n+  typedef unsigned int __sanitizer___kernel_old_uid_t;\n+  typedef unsigned int __sanitizer___kernel_old_gid_t;\n+#else\n+  typedef unsigned short __sanitizer___kernel_old_uid_t;\n+  typedef unsigned short __sanitizer___kernel_old_gid_t;\n+#endif\n+\n+  typedef long long __sanitizer___kernel_loff_t;\n+  typedef struct {\n+    unsigned long fds_bits[1024 / (8 * sizeof(long))];\n+  } __sanitizer___kernel_fd_set;\n+\n+  // This thing depends on the platform. We are only interested in the upper\n+  // limit. Verified with a compiler assert in .cpp.\n+  const int pthread_attr_t_max_sz = 128;\n+  union __sanitizer_pthread_attr_t {\n+    char size[pthread_attr_t_max_sz]; // NOLINT\n+    void *align;\n+  };\n+\n+  const unsigned old_sigset_t_sz = sizeof(unsigned long);\n+\n+  struct __sanitizer_sigset_t {\n+     // uint32_t * 4\n+     unsigned int __bits[4];\n+  };\n+\n+  typedef __sanitizer_sigset_t __sanitizer_kernel_sigset_t;\n+\n+  struct __sanitizer_siginfo {\n+    // The size is determined by looking at sizeof of real siginfo_t on linux.\n+    u64 opaque[128 / sizeof(u64)];\n+  };\n+\n+  using __sanitizer_sighandler_ptr = void (*)(int sig);\n+  using __sanitizer_sigactionhandler_ptr =\n+      void (*)(int sig, __sanitizer_siginfo *siginfo, void *uctx);\n+\n+  struct __sanitizer_sigaction {\n+    union {\n+      __sanitizer_sigactionhandler_ptr sigaction;\n+      __sanitizer_sighandler_ptr handler;\n+    };\n+    int sa_flags;\n+    __sanitizer_sigset_t sa_mask;\n+  };\n+\n+  struct __sanitizer_sem_t {\n+    u32 data[4];\n+  };\n+\n+  extern const uptr sig_ign;\n+  extern const uptr sig_dfl;\n+  extern const uptr sig_err;\n+  extern const uptr sa_siginfo;\n+\n+  extern int af_inet;\n+  extern int af_inet6;\n+  uptr __sanitizer_in_addr_sz(int af);\n+\n+  struct __sanitizer_dl_phdr_info {\n+    uptr dlpi_addr;\n+    const char *dlpi_name;\n+    const void *dlpi_phdr;\n+    short dlpi_phnum;\n+  };\n+\n+  extern unsigned struct_ElfW_Phdr_sz;\n+\n+  struct __sanitizer_addrinfo {\n+    int ai_flags;\n+    int ai_family;\n+    int ai_socktype;\n+    int ai_protocol;\n+    unsigned ai_addrlen;\n+    char *ai_canonname;\n+    void *ai_addr;\n+    struct __sanitizer_addrinfo *ai_next;\n+  };\n+\n+  struct __sanitizer_hostent {\n+    char *h_name;\n+    char **h_aliases;\n+    int h_addrtype;\n+    int h_length;\n+    char **h_addr_list;\n+  };\n+\n+  struct __sanitizer_pollfd {\n+    int fd;\n+    short events;\n+    short revents;\n+  };\n+\n+  typedef unsigned __sanitizer_nfds_t;\n+\n+  struct __sanitizer_glob_t {\n+    uptr gl_pathc;\n+    uptr gl_matchc;\n+    uptr gl_offs;\n+    int gl_flags;\n+    char **gl_pathv;\n+    int (*gl_errfunc)(const char*, int);\n+    void (*gl_closedir)(void *dirp);\n+    struct dirent *(*gl_readdir)(void *dirp);\n+    void *(*gl_opendir)(const char*);\n+    int (*gl_lstat)(const char*, void* /* struct stat* */);\n+    int (*gl_stat)(const char*, void* /* struct stat* */);\n+  };\n+\n+  extern int glob_nomatch;\n+  extern int glob_altdirfunc;\n+\n+  extern unsigned path_max;\n+\n+  struct __sanitizer_wordexp_t {\n+    uptr we_wordc;\n+    char **we_wordv;\n+    uptr we_offs;\n+    char *we_strings;\n+    uptr we_nbytes;\n+  };\n+\n+  typedef void __sanitizer_FILE;\n+\n+  extern unsigned struct_shminfo_sz;\n+  extern unsigned struct_shm_info_sz;\n+  extern int shmctl_ipc_stat;\n+  extern int shmctl_ipc_info;\n+  extern int shmctl_shm_info;\n+  extern int shmctl_shm_stat;\n+\n+  extern unsigned struct_utmpx_sz;\n+\n+  extern int map_fixed;\n+\n+  // ioctl arguments\n+  struct __sanitizer_ifconf {\n+    int ifc_len;\n+    union {\n+      void *ifcu_req;\n+    } ifc_ifcu;\n+  };\n+\n+#define IOC_NRBITS 8\n+#define IOC_TYPEBITS 8\n+#if defined(__powerpc__) || defined(__powerpc64__) || defined(__mips__)\n+#define IOC_SIZEBITS 13\n+#define IOC_DIRBITS 3\n+#define IOC_NONE 1U\n+#define IOC_WRITE 4U\n+#define IOC_READ 2U\n+#else\n+#define IOC_SIZEBITS 14\n+#define IOC_DIRBITS 2\n+#define IOC_NONE 0U\n+#define IOC_WRITE 1U\n+#define IOC_READ 2U\n+#endif\n+#define IOC_NRMASK ((1 << IOC_NRBITS) - 1)\n+#define IOC_TYPEMASK ((1 << IOC_TYPEBITS) - 1)\n+#define IOC_SIZEMASK ((1 << IOC_SIZEBITS) - 1)\n+#if defined(IOC_DIRMASK)\n+#undef IOC_DIRMASK\n+#endif\n+#define IOC_DIRMASK ((1 << IOC_DIRBITS) - 1)\n+#define IOC_NRSHIFT 0\n+#define IOC_TYPESHIFT (IOC_NRSHIFT + IOC_NRBITS)\n+#define IOC_SIZESHIFT (IOC_TYPESHIFT + IOC_TYPEBITS)\n+#define IOC_DIRSHIFT (IOC_SIZESHIFT + IOC_SIZEBITS)\n+#define EVIOC_EV_MAX 0x1f\n+#define EVIOC_ABS_MAX 0x3f\n+\n+#define IOC_DIR(nr) (((nr) >> IOC_DIRSHIFT) & IOC_DIRMASK)\n+#define IOC_TYPE(nr) (((nr) >> IOC_TYPESHIFT) & IOC_TYPEMASK)\n+#define IOC_NR(nr) (((nr) >> IOC_NRSHIFT) & IOC_NRMASK)\n+#define IOC_SIZE(nr) (((nr) >> IOC_SIZESHIFT) & IOC_SIZEMASK)\n+\n+  extern unsigned struct_ifreq_sz;\n+  extern unsigned struct_termios_sz;\n+  extern unsigned struct_winsize_sz;\n+\n+  extern unsigned struct_copr_buffer_sz;\n+  extern unsigned struct_copr_debug_buf_sz;\n+  extern unsigned struct_copr_msg_sz;\n+  extern unsigned struct_midi_info_sz;\n+  extern unsigned struct_mtget_sz;\n+  extern unsigned struct_mtop_sz;\n+  extern unsigned struct_rtentry_sz;\n+  extern unsigned struct_sbi_instrument_sz;\n+  extern unsigned struct_seq_event_rec_sz;\n+  extern unsigned struct_synth_info_sz;\n+  extern unsigned struct_vt_mode_sz;\n+\n+  extern const unsigned long __sanitizer_bufsiz;\n+  extern unsigned struct_audio_buf_info_sz;\n+  extern unsigned struct_ppp_stats_sz;\n+  extern unsigned struct_sioc_sg_req_sz;\n+  extern unsigned struct_sioc_vif_req_sz;\n+\n+  // ioctl request identifiers\n+\n+  // A special value to mark ioctls that are not present on the target platform,\n+  // when it can not be determined without including any system headers.\n+  extern const unsigned IOCTL_NOT_PRESENT;\n+\n+  extern unsigned IOCTL_FIOASYNC;\n+  extern unsigned IOCTL_FIOCLEX;\n+  extern unsigned IOCTL_FIOGETOWN;\n+  extern unsigned IOCTL_FIONBIO;\n+  extern unsigned IOCTL_FIONCLEX;\n+  extern unsigned IOCTL_FIOSETOWN;\n+  extern unsigned IOCTL_SIOCADDMULTI;\n+  extern unsigned IOCTL_SIOCATMARK;\n+  extern unsigned IOCTL_SIOCDELMULTI;\n+  extern unsigned IOCTL_SIOCGIFADDR;\n+  extern unsigned IOCTL_SIOCGIFBRDADDR;\n+  extern unsigned IOCTL_SIOCGIFCONF;\n+  extern unsigned IOCTL_SIOCGIFDSTADDR;\n+  extern unsigned IOCTL_SIOCGIFFLAGS;\n+  extern unsigned IOCTL_SIOCGIFMETRIC;\n+  extern unsigned IOCTL_SIOCGIFMTU;\n+  extern unsigned IOCTL_SIOCGIFNETMASK;\n+  extern unsigned IOCTL_SIOCGPGRP;\n+  extern unsigned IOCTL_SIOCSIFADDR;\n+  extern unsigned IOCTL_SIOCSIFBRDADDR;\n+  extern unsigned IOCTL_SIOCSIFDSTADDR;\n+  extern unsigned IOCTL_SIOCSIFFLAGS;\n+  extern unsigned IOCTL_SIOCSIFMETRIC;\n+  extern unsigned IOCTL_SIOCSIFMTU;\n+  extern unsigned IOCTL_SIOCSIFNETMASK;\n+  extern unsigned IOCTL_SIOCSPGRP;\n+  extern unsigned IOCTL_TIOCCONS;\n+  extern unsigned IOCTL_TIOCEXCL;\n+  extern unsigned IOCTL_TIOCGETD;\n+  extern unsigned IOCTL_TIOCGPGRP;\n+  extern unsigned IOCTL_TIOCGWINSZ;\n+  extern unsigned IOCTL_TIOCMBIC;\n+  extern unsigned IOCTL_TIOCMBIS;\n+  extern unsigned IOCTL_TIOCMGET;\n+  extern unsigned IOCTL_TIOCMSET;\n+  extern unsigned IOCTL_TIOCNOTTY;\n+  extern unsigned IOCTL_TIOCNXCL;\n+  extern unsigned IOCTL_TIOCOUTQ;\n+  extern unsigned IOCTL_TIOCPKT;\n+  extern unsigned IOCTL_TIOCSCTTY;\n+  extern unsigned IOCTL_TIOCSETD;\n+  extern unsigned IOCTL_TIOCSPGRP;\n+  extern unsigned IOCTL_TIOCSTI;\n+  extern unsigned IOCTL_TIOCSWINSZ;\n+  extern unsigned IOCTL_SIOCGETSGCNT;\n+  extern unsigned IOCTL_SIOCGETVIFCNT;\n+  extern unsigned IOCTL_MTIOCGET;\n+  extern unsigned IOCTL_MTIOCTOP;\n+  extern unsigned IOCTL_SIOCADDRT;\n+  extern unsigned IOCTL_SIOCDELRT;\n+  extern unsigned IOCTL_SNDCTL_DSP_GETBLKSIZE;\n+  extern unsigned IOCTL_SNDCTL_DSP_GETFMTS;\n+  extern unsigned IOCTL_SNDCTL_DSP_NONBLOCK;\n+  extern unsigned IOCTL_SNDCTL_DSP_POST;\n+  extern unsigned IOCTL_SNDCTL_DSP_RESET;\n+  extern unsigned IOCTL_SNDCTL_DSP_SETFMT;\n+  extern unsigned IOCTL_SNDCTL_DSP_SETFRAGMENT;\n+  extern unsigned IOCTL_SNDCTL_DSP_SPEED;\n+  extern unsigned IOCTL_SNDCTL_DSP_STEREO;\n+  extern unsigned IOCTL_SNDCTL_DSP_SUBDIVIDE;\n+  extern unsigned IOCTL_SNDCTL_DSP_SYNC;\n+  extern unsigned IOCTL_SNDCTL_FM_4OP_ENABLE;\n+  extern unsigned IOCTL_SNDCTL_FM_LOAD_INSTR;\n+  extern unsigned IOCTL_SNDCTL_MIDI_INFO;\n+  extern unsigned IOCTL_SNDCTL_MIDI_PRETIME;\n+  extern unsigned IOCTL_SNDCTL_SEQ_CTRLRATE;\n+  extern unsigned IOCTL_SNDCTL_SEQ_GETINCOUNT;\n+  extern unsigned IOCTL_SNDCTL_SEQ_GETOUTCOUNT;\n+  extern unsigned IOCTL_SNDCTL_SEQ_NRMIDIS;\n+  extern unsigned IOCTL_SNDCTL_SEQ_NRSYNTHS;\n+  extern unsigned IOCTL_SNDCTL_SEQ_OUTOFBAND;\n+  extern unsigned IOCTL_SNDCTL_SEQ_PANIC;\n+  extern unsigned IOCTL_SNDCTL_SEQ_PERCMODE;\n+  extern unsigned IOCTL_SNDCTL_SEQ_RESET;\n+  extern unsigned IOCTL_SNDCTL_SEQ_RESETSAMPLES;\n+  extern unsigned IOCTL_SNDCTL_SEQ_SYNC;\n+  extern unsigned IOCTL_SNDCTL_SEQ_TESTMIDI;\n+  extern unsigned IOCTL_SNDCTL_SEQ_THRESHOLD;\n+  extern unsigned IOCTL_SNDCTL_SYNTH_INFO;\n+  extern unsigned IOCTL_SNDCTL_SYNTH_MEMAVL;\n+  extern unsigned IOCTL_SNDCTL_TMR_CONTINUE;\n+  extern unsigned IOCTL_SNDCTL_TMR_METRONOME;\n+  extern unsigned IOCTL_SNDCTL_TMR_SELECT;\n+  extern unsigned IOCTL_SNDCTL_TMR_SOURCE;\n+  extern unsigned IOCTL_SNDCTL_TMR_START;\n+  extern unsigned IOCTL_SNDCTL_TMR_STOP;\n+  extern unsigned IOCTL_SNDCTL_TMR_TEMPO;\n+  extern unsigned IOCTL_SNDCTL_TMR_TIMEBASE;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_ALTPCM;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_BASS;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_CAPS;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_CD;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_DEVMASK;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_ENHANCE;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_IGAIN;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_IMIX;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_LINE1;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_LINE2;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_LINE3;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_LINE;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_LOUD;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_MIC;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_MUTE;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_OGAIN;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_PCM;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_RECLEV;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_RECMASK;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_RECSRC;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_SPEAKER;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_STEREODEVS;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_SYNTH;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_TREBLE;\n+  extern unsigned IOCTL_SOUND_MIXER_READ_VOLUME;\n+  extern unsigned IOCTL_SOUND_MIXER_WRITE_ALTPCM;\n+  extern unsigned IOCTL_SOUND_MIXER_WRITE_BASS;\n+  extern unsigned IOCTL_SOUND_MIXER_WRITE_CD;\n+  extern unsigned IOCTL_SOUND_MIXER_WRITE_ENHANCE;\n+  extern unsigned IOCTL_SOUND_MIXER_WRITE_IGAIN;\n+  extern unsigned IOCTL_SOUND_MIXER_WRITE_IMIX;\n+  extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE1;\n+  extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE2;\n+  extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE3;\n+  extern unsigned IOCTL_SOUND_MIXER_WRITE_LINE;\n+  extern unsigned IOCTL_SOUND_MIXER_WRITE_LOUD;\n+  extern unsigned IOCTL_SOUND_MIXER_WRITE_MIC;\n+  extern unsigned IOCTL_SOUND_MIXER_WRITE_MUTE;\n+  extern unsigned IOCTL_SOUND_MIXER_WRITE_OGAIN;\n+  extern unsigned IOCTL_SOUND_MIXER_WRITE_PCM;\n+  extern unsigned IOCTL_SOUND_MIXER_WRITE_RECLEV;\n+  extern unsigned IOCTL_SOUND_MIXER_WRITE_RECSRC;\n+  extern unsigned IOCTL_SOUND_MIXER_WRITE_SPEAKER;\n+  extern unsigned IOCTL_SOUND_MIXER_WRITE_SYNTH;\n+  extern unsigned IOCTL_SOUND_MIXER_WRITE_TREBLE;\n+  extern unsigned IOCTL_SOUND_MIXER_WRITE_VOLUME;\n+  extern unsigned IOCTL_SOUND_PCM_READ_BITS;\n+  extern unsigned IOCTL_SOUND_PCM_READ_CHANNELS;\n+  extern unsigned IOCTL_SOUND_PCM_READ_FILTER;\n+  extern unsigned IOCTL_SOUND_PCM_READ_RATE;\n+  extern unsigned IOCTL_SOUND_PCM_WRITE_CHANNELS;\n+  extern unsigned IOCTL_SOUND_PCM_WRITE_FILTER;\n+  extern unsigned IOCTL_VT_ACTIVATE;\n+  extern unsigned IOCTL_VT_GETMODE;\n+  extern unsigned IOCTL_VT_OPENQRY;\n+  extern unsigned IOCTL_VT_RELDISP;\n+  extern unsigned IOCTL_VT_SETMODE;\n+  extern unsigned IOCTL_VT_WAITACTIVE;\n+  extern unsigned IOCTL_GIO_SCRNMAP;\n+  extern unsigned IOCTL_KDDISABIO;\n+  extern unsigned IOCTL_KDENABIO;\n+  extern unsigned IOCTL_KDGETLED;\n+  extern unsigned IOCTL_KDGETMODE;\n+  extern unsigned IOCTL_KDGKBMODE;\n+  extern unsigned IOCTL_KDGKBTYPE;\n+  extern unsigned IOCTL_KDMKTONE;\n+  extern unsigned IOCTL_KDSETLED;\n+  extern unsigned IOCTL_KDSETMODE;\n+  extern unsigned IOCTL_KDSKBMODE;\n+\n+  extern const int si_SEGV_MAPERR;\n+  extern const int si_SEGV_ACCERR;\n+\n+  struct __sanitizer_cap_rights {\n+    u64 cr_rights[2];\n+  };\n+\n+  typedef struct __sanitizer_cap_rights __sanitizer_cap_rights_t;\n+  extern unsigned struct_cap_rights_sz;\n+\n+  extern unsigned struct_fstab_sz;\n+  extern unsigned struct_StringList_sz;\n+} // namespace __sanitizer\n+\n+#define CHECK_TYPE_SIZE(TYPE) \\\n+  COMPILER_CHECK(sizeof(__sanitizer_##TYPE) == sizeof(TYPE))\n+\n+#define CHECK_SIZE_AND_OFFSET(CLASS, MEMBER)                       \\\n+  COMPILER_CHECK(sizeof(((__sanitizer_##CLASS *) NULL)->MEMBER) == \\\n+                 sizeof(((CLASS *) NULL)->MEMBER));                \\\n+  COMPILER_CHECK(offsetof(__sanitizer_##CLASS, MEMBER) ==          \\\n+                 offsetof(CLASS, MEMBER))\n+\n+// For sigaction, which is a function and struct at the same time,\n+// and thus requires explicit \"struct\" in sizeof() expression.\n+#define CHECK_STRUCT_SIZE_AND_OFFSET(CLASS, MEMBER)                       \\\n+  COMPILER_CHECK(sizeof(((struct __sanitizer_##CLASS *) NULL)->MEMBER) == \\\n+                 sizeof(((struct CLASS *) NULL)->MEMBER));                \\\n+  COMPILER_CHECK(offsetof(struct __sanitizer_##CLASS, MEMBER) ==          \\\n+                 offsetof(struct CLASS, MEMBER))\n+\n+#define SIGACTION_SYMNAME sigaction\n+\n+#endif\n+\n+#endif // SANITIZER_FREEBSD"}, {"sha": "842bc789f4793117134a82a7fe18a8cc60dbf5ce", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_linux.cpp", "status": "renamed", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_platform_limits_linux.cc --------------------------------===//\n+//===-- sanitizer_platform_limits_linux.cpp -------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -12,7 +13,7 @@\n \n // This is a separate compilation unit for linux headers that conflict with\n // userspace headers.\n-// Most \"normal\" includes go in sanitizer_platform_limits_posix.cc\n+// Most \"normal\" includes go in sanitizer_platform_limits_posix.cpp\n \n #include \"sanitizer_platform.h\"\n #if SANITIZER_LINUX\n@@ -25,12 +26,9 @@\n \n // With old kernels (and even new kernels on powerpc) asm/stat.h uses types that\n // are not defined anywhere in userspace headers. Fake them. This seems to work\n-// fine with newer headers, too.  Beware that with <sys/stat.h>, struct stat\n-// takes the form of struct stat64 on 32-bit platforms if _FILE_OFFSET_BITS=64.\n-// Also, for some platforms (e.g. mips) there are additional members in the\n-// <sys/stat.h> struct stat:s.\n+// fine with newer headers, too.\n #include <linux/posix_types.h>\n-#if defined(__x86_64__)\n+#if defined(__x86_64__) ||  defined(__mips__)\n #include <sys/stat.h>\n #else\n #define ino_t __kernel_ino_t", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_linux.cc"}, {"sha": "f01de6c995e60e09f9875bb04e6270d7411e6fc0", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_netbsd.cpp", "status": "renamed", "additions": 296, "deletions": 126, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_platform_limits_netbsd.cc -------------------------------===//\n+//===-- sanitizer_platform_limits_netbsd.cpp ------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -13,9 +14,82 @@\n #include \"sanitizer_platform.h\"\n \n #if SANITIZER_NETBSD\n+\n+#define _KMEMUSER\n+#define RAY_DO_SIGLEV\n+\n+// clang-format off\n #include <sys/param.h>\n #include <sys/types.h>\n-\n+#include <sys/sysctl.h>\n+#include <sys/disk.h>\n+#include <sys/disklabel.h>\n+#include <sys/mount.h>\n+#include <sys/agpio.h>\n+#include <sys/ataio.h>\n+#include <sys/audioio.h>\n+#include <sys/cdbr.h>\n+#include <sys/cdio.h>\n+#include <sys/chio.h>\n+#include <sys/clockctl.h>\n+#include <sys/cpuio.h>\n+#include <sys/dkio.h>\n+#include <sys/drvctlio.h>\n+#include <sys/dvdio.h>\n+#include <sys/envsys.h>\n+#include <sys/event.h>\n+#include <sys/fdio.h>\n+#include <sys/filio.h>\n+#include <sys/gpio.h>\n+#include <sys/ioctl.h>\n+#include <sys/ioctl_compat.h>\n+#include <sys/joystick.h>\n+#include <sys/ksyms.h>\n+#include <sys/lua.h>\n+#include <sys/midiio.h>\n+#include <sys/mtio.h>\n+#include <sys/power.h>\n+#include <sys/radioio.h>\n+#include <sys/rndio.h>\n+#include <sys/scanio.h>\n+#include <sys/scsiio.h>\n+#include <sys/sockio.h>\n+#include <sys/timepps.h>\n+#include <sys/ttycom.h>\n+#include <sys/verified_exec.h>\n+#include <sys/videoio.h>\n+#include <sys/wdog.h>\n+#include <sys/event.h>\n+#include <sys/filio.h>\n+#include <sys/ipc.h>\n+#include <sys/ipmi.h>\n+#include <sys/kcov.h>\n+#include <sys/mman.h>\n+#include <sys/module.h>\n+#include <sys/mount.h>\n+#include <sys/mqueue.h>\n+#include <sys/msg.h>\n+#include <sys/mtio.h>\n+#include <sys/ptrace.h>\n+#include <sys/resource.h>\n+#include <sys/sem.h>\n+#include <sys/sha1.h>\n+#include <sys/sha2.h>\n+#include <sys/shm.h>\n+#include <sys/signal.h>\n+#include <sys/socket.h>\n+#include <sys/sockio.h>\n+#include <sys/soundcard.h>\n+#include <sys/stat.h>\n+#include <sys/statvfs.h>\n+#include <sys/time.h>\n+#include <sys/timeb.h>\n+#include <sys/times.h>\n+#include <sys/timespec.h>\n+#include <sys/timex.h>\n+#include <sys/types.h>\n+#include <sys/ucontext.h>\n+#include <sys/utsname.h>\n #include <altq/altq.h>\n #include <altq/altq_afmap.h>\n #include <altq/altq_blue.h>\n@@ -45,47 +119,39 @@\n #include <dev/ic/icp_ioctl.h>\n #include <dev/ic/isp_ioctl.h>\n #include <dev/ic/mlxio.h>\n+#include <dev/ic/qemufwcfgio.h>\n #include <dev/ic/nvmeio.h>\n #include <dev/ir/irdaio.h>\n #include <dev/isa/isvio.h>\n-#include <dev/isa/satlinkio.h>\n #include <dev/isa/wtreg.h>\n #include <dev/iscsi/iscsi_ioctl.h>\n #include <dev/ofw/openfirmio.h>\n #include <dev/pci/amrio.h>\n-\n #include <dev/pci/mlyreg.h>\n #include <dev/pci/mlyio.h>\n-\n #include <dev/pci/pciio.h>\n #include <dev/pci/tweio.h>\n #include <dev/pcmcia/if_cnwioctl.h>\n-#include <dirent.h>\n-#include <glob.h>\n-#include <grp.h>\n-#include <ifaddrs.h>\n-#include <limits.h>\n-#include <link_elf.h>\n-#include <net/if.h>\n-#include <net/if_ether.h>\n+#include <net/bpf.h>\n+#include <net/if_gre.h>\n #include <net/ppp_defs.h>\n-#include <net/route.h>\n-#include <netdb.h>\n-#include <netinet/in.h>\n+#include <net/if_ppp.h>\n+#include <net/if_pppoe.h>\n+#include <net/if_sppp.h>\n+#include <net/if_srt.h>\n+#include <net/if_tap.h>\n+#include <net/if_tun.h>\n+#include <net/npf.h>\n+#include <net/pfvar.h>\n+#include <net/slip.h>\n+#include <netbt/hci.h>\n #include <netinet/ip_compat.h>\n #include <netinet/ip_fil.h>\n-#include <netinet/ip_mroute.h>\n-#include <poll.h>\n-#include <pthread.h>\n-#include <pwd.h>\n-#include <semaphore.h>\n-#include <signal.h>\n-#include <stddef.h>\n-#include <stdio.h>\n-#include <sys/disk.h>\n-#include <sys/disklabel.h>\n-#include <sys/mount.h>\n-#define RAY_DO_SIGLEV\n+#include <netinet/ip_nat.h>\n+#include <netinet/ip_proxy.h>\n+#include <netinet6/in6_var.h>\n+#include <netinet6/nd6.h>\n+#include <netsmb/smb_dev.h>\n #include <dev/biovar.h>\n #include <dev/bluetooth/btdev.h>\n #include <dev/bluetooth/btsco.h>\n@@ -95,10 +161,13 @@\n #include <dev/kttcpio.h>\n #include <dev/lockstat.h>\n #include <dev/md.h>\n+#include <net/if_ether.h>\n #include <dev/pcmcia/if_rayreg.h>\n+#include <stdio.h>\n #include <dev/raidframe/raidframeio.h>\n #include <dev/sbus/mbppio.h>\n #include <dev/scsipi/ses.h>\n+#include <dev/spi/spi_io.h>\n #include <dev/spkrio.h>\n #include <dev/sun/disklabel.h>\n #include <dev/sun/fbio.h>\n@@ -113,95 +182,50 @@\n #include <dev/vndvar.h>\n #include <dev/wscons/wsconsio.h>\n #include <dev/wscons/wsdisplay_usl_io.h>\n-#include <net/bpf.h>\n-#include <net/if_atm.h>\n-#include <net/if_gre.h>\n-#include <net/if_ppp.h>\n-#include <net/if_pppoe.h>\n-#include <net/if_sppp.h>\n-#include <net/if_srt.h>\n-#include <net/if_tap.h>\n-#include <net/if_tun.h>\n-#include <net/npf.h>\n-#include <net/pfvar.h>\n-#include <net/slip.h>\n-#include <netbt/hci.h>\n-#include <netinet/ip_nat.h>\n-#include <netinet/ip_proxy.h>\n-#include <netinet6/in6_var.h>\n-#include <netinet6/nd6.h>\n-#include <netnatm/natm.h>\n-#include <netsmb/smb_dev.h>\n+#include <fs/autofs/autofs_ioctl.h>\n+#include <dirent.h>\n+#include <glob.h>\n+#include <grp.h>\n+#include <ifaddrs.h>\n+#include <limits.h>\n+#include <link_elf.h>\n+#include <net/if.h>\n+#include <net/route.h>\n+#include <netdb.h>\n+#include <netinet/in.h>\n+#include <netinet/ip_mroute.h>\n+#include <netinet/sctp_uio.h>\n+#include <poll.h>\n+#include <pthread.h>\n+#include <pwd.h>\n+#include <semaphore.h>\n+#include <signal.h>\n+#include <stddef.h>\n+#include <md2.h>\n+#include <md4.h>\n+#include <md5.h>\n+#include <rmd160.h>\n #include <soundcard.h>\n-#include <sys/agpio.h>\n-#include <sys/ataio.h>\n-#include <sys/audioio.h>\n-#include <sys/cdio.h>\n-#include <sys/chio.h>\n-#include <sys/clockctl.h>\n-#include <sys/cpuio.h>\n-#include <sys/dkio.h>\n-#include <sys/drvctlio.h>\n-#include <sys/dvdio.h>\n-#include <sys/envsys.h>\n-#include <sys/event.h>\n-#include <sys/fdio.h>\n-#include <sys/filio.h>\n-#include <sys/gpio.h>\n-#include <sys/ioctl.h>\n-#include <sys/ioctl_compat.h>\n-#include <sys/joystick.h>\n-#include <sys/ksyms.h>\n-#include <sys/lua.h>\n-#include <sys/midiio.h>\n-#include <sys/mtio.h>\n-#include <sys/power.h>\n-#include <sys/radioio.h>\n-#include <sys/rndio.h>\n-#include <sys/scanio.h>\n-#include <sys/scsiio.h>\n-#include <sys/sockio.h>\n-#include <sys/timepps.h>\n-#include <sys/ttycom.h>\n-#include <sys/verified_exec.h>\n-#include <sys/videoio.h>\n-#include <sys/wdog.h>\n-//#include <xen/xenio.h>\n-#include <sys/event.h>\n-#include <sys/filio.h>\n-#include <sys/ipc.h>\n-#include <sys/mman.h>\n-#include <sys/mount.h>\n-#include <sys/mqueue.h>\n-#include <sys/msg.h>\n-#include <sys/mtio.h>\n-#include <sys/ptrace.h>\n-#include <sys/resource.h>\n-#include <sys/sem.h>\n-#include <sys/shm.h>\n-#include <sys/signal.h>\n-#include <sys/socket.h>\n-#include <sys/sockio.h>\n-#include <sys/soundcard.h>\n-#include <sys/stat.h>\n-#include <sys/statvfs.h>\n-#include <sys/time.h>\n-#include <sys/timeb.h>\n-#include <sys/times.h>\n-#include <sys/timespec.h>\n-#include <sys/timex.h>\n-#include <sys/types.h>\n-#include <sys/ucontext.h>\n-#include <sys/utsname.h>\n #include <term.h>\n #include <termios.h>\n #include <time.h>\n #include <ttyent.h>\n #include <utime.h>\n #include <utmp.h>\n #include <utmpx.h>\n+#include <vis.h>\n #include <wchar.h>\n #include <wordexp.h>\n+#include <ttyent.h>\n+#include <fts.h>\n+#include <regex.h>\n+#include <fstab.h>\n+#include <stringlist.h>\n+\n+#if defined(__x86_64__)\n+#include <nvmm.h>\n+#endif\n+// clang-format on\n \n // Include these after system headers to avoid name clashes and ambiguities.\n #include \"sanitizer_internal_defs.h\"\n@@ -236,6 +260,11 @@ unsigned struct_rlimit_sz = sizeof(struct rlimit);\n unsigned struct_timespec_sz = sizeof(struct timespec);\n unsigned struct_sembuf_sz = sizeof(struct sembuf);\n unsigned struct_kevent_sz = sizeof(struct kevent);\n+unsigned struct_FTS_sz = sizeof(FTS);\n+unsigned struct_FTSENT_sz = sizeof(FTSENT);\n+unsigned struct_regex_sz = sizeof(regex_t);\n+unsigned struct_regmatch_sz = sizeof(regmatch_t);\n+unsigned struct_fstab_sz = sizeof(struct fstab);\n unsigned struct_utimbuf_sz = sizeof(struct utimbuf);\n unsigned struct_itimerspec_sz = sizeof(struct itimerspec);\n unsigned struct_timex_sz = sizeof(struct timex);\n@@ -249,6 +278,8 @@ const uptr sig_dfl = (uptr)SIG_DFL;\n const uptr sig_err = (uptr)SIG_ERR;\n const uptr sa_siginfo = (uptr)SA_SIGINFO;\n \n+const unsigned long __sanitizer_bufsiz = BUFSIZ;\n+\n int ptrace_pt_io = PT_IO;\n int ptrace_pt_lwpinfo = PT_LWPINFO;\n int ptrace_pt_set_event_mask = PT_SET_EVENT_MASK;\n@@ -337,6 +368,14 @@ unsigned path_max = PATH_MAX;\n \n int struct_ttyent_sz = sizeof(struct ttyent);\n \n+struct __sanitizer_nvlist_ref_t {\n+  void *buf;\n+  uptr len;\n+  int flags;\n+};\n+\n+typedef __sanitizer_nvlist_ref_t nvlist_ref_t;\n+\n // ioctl arguments\n unsigned struct_altqreq_sz = sizeof(altqreq);\n unsigned struct_amr_user_ioctl_sz = sizeof(amr_user_ioctl);\n@@ -348,7 +387,6 @@ unsigned struct_atabusiodetach_args_sz = sizeof(atabusiodetach_args);\n unsigned struct_atabusioscan_args_sz = sizeof(atabusioscan_args);\n unsigned struct_ath_diag_sz = sizeof(ath_diag);\n unsigned struct_atm_flowmap_sz = sizeof(atm_flowmap);\n-unsigned struct_atm_pseudoioctl_sz = sizeof(atm_pseudoioctl);\n unsigned struct_audio_buf_info_sz = sizeof(audio_buf_info);\n unsigned struct_audio_device_sz = sizeof(audio_device);\n unsigned struct_audio_encoding_sz = sizeof(audio_encoding);\n@@ -594,7 +632,6 @@ unsigned struct_priq_delete_filter_sz = sizeof(priq_delete_filter);\n unsigned struct_priq_interface_sz = sizeof(priq_interface);\n unsigned struct_priq_modify_class_sz = sizeof(priq_modify_class);\n unsigned struct_ptmget_sz = sizeof(ptmget);\n-unsigned struct_pvctxreq_sz = sizeof(pvctxreq);\n unsigned struct_radio_info_sz = sizeof(radio_info);\n unsigned struct_red_conf_sz = sizeof(red_conf);\n unsigned struct_red_interface_sz = sizeof(red_interface);\n@@ -606,7 +643,6 @@ unsigned struct_rf_recon_req_sz = sizeof(rf_recon_req);\n unsigned struct_rio_conf_sz = sizeof(rio_conf);\n unsigned struct_rio_interface_sz = sizeof(rio_interface);\n unsigned struct_rio_stats_sz = sizeof(rio_stats);\n-unsigned struct_satlink_id_sz = sizeof(satlink_id);\n unsigned struct_scan_io_sz = sizeof(scan_io);\n unsigned struct_scbusaccel_args_sz = sizeof(scbusaccel_args);\n unsigned struct_scbusiodetach_args_sz = sizeof(scbusiodetach_args);\n@@ -654,6 +690,29 @@ unsigned struct_usb_config_desc_sz = sizeof(usb_config_desc);\n unsigned struct_usb_ctl_report_desc_sz = sizeof(usb_ctl_report_desc);\n unsigned struct_usb_ctl_report_sz = sizeof(usb_ctl_report);\n unsigned struct_usb_ctl_request_sz = sizeof(usb_ctl_request);\n+#if defined(__x86_64__)\n+unsigned struct_nvmm_ioc_capability_sz = sizeof(nvmm_ioc_capability);\n+unsigned struct_nvmm_ioc_machine_create_sz = sizeof(nvmm_ioc_machine_create);\n+unsigned struct_nvmm_ioc_machine_destroy_sz = sizeof(nvmm_ioc_machine_destroy);\n+unsigned struct_nvmm_ioc_machine_configure_sz =\n+    sizeof(nvmm_ioc_machine_configure);\n+unsigned struct_nvmm_ioc_vcpu_create_sz = sizeof(nvmm_ioc_vcpu_create);\n+unsigned struct_nvmm_ioc_vcpu_destroy_sz = sizeof(nvmm_ioc_vcpu_destroy);\n+unsigned struct_nvmm_ioc_vcpu_setstate_sz = sizeof(nvmm_ioc_vcpu_destroy);\n+unsigned struct_nvmm_ioc_vcpu_getstate_sz = sizeof(nvmm_ioc_vcpu_getstate);\n+unsigned struct_nvmm_ioc_vcpu_inject_sz = sizeof(nvmm_ioc_vcpu_inject);\n+unsigned struct_nvmm_ioc_vcpu_run_sz = sizeof(nvmm_ioc_vcpu_run);\n+unsigned struct_nvmm_ioc_gpa_map_sz = sizeof(nvmm_ioc_gpa_map);\n+unsigned struct_nvmm_ioc_gpa_unmap_sz = sizeof(nvmm_ioc_gpa_unmap);\n+unsigned struct_nvmm_ioc_hva_map_sz = sizeof(nvmm_ioc_hva_map);\n+unsigned struct_nvmm_ioc_hva_unmap_sz = sizeof(nvmm_ioc_hva_unmap);\n+unsigned struct_nvmm_ioc_ctl_sz = sizeof(nvmm_ioc_ctl);\n+#endif\n+unsigned struct_spi_ioctl_configure_sz = sizeof(spi_ioctl_configure);\n+unsigned struct_spi_ioctl_transfer_sz = sizeof(spi_ioctl_transfer);\n+unsigned struct_autofs_daemon_request_sz = sizeof(autofs_daemon_request);\n+unsigned struct_autofs_daemon_done_sz = sizeof(autofs_daemon_done);\n+unsigned struct_sctp_connectx_addrs_sz = sizeof(sctp_connectx_addrs);\n unsigned struct_usb_device_info_old_sz = sizeof(usb_device_info_old);\n unsigned struct_usb_device_info_sz = sizeof(usb_device_info);\n unsigned struct_usb_device_stats_sz = sizeof(usb_device_stats);\n@@ -693,6 +752,9 @@ unsigned struct_vnd_user_sz = sizeof(vnd_user);\n unsigned struct_vt_stat_sz = sizeof(vt_stat);\n unsigned struct_wdog_conf_sz = sizeof(wdog_conf);\n unsigned struct_wdog_mode_sz = sizeof(wdog_mode);\n+unsigned struct_ipmi_recv_sz = sizeof(ipmi_recv);\n+unsigned struct_ipmi_req_sz = sizeof(ipmi_req);\n+unsigned struct_ipmi_cmdspec_sz = sizeof(ipmi_cmdspec);\n unsigned struct_wfq_conf_sz = sizeof(wfq_conf);\n unsigned struct_wfq_getqid_sz = sizeof(wfq_getqid);\n unsigned struct_wfq_getstats_sz = sizeof(wfq_getstats);\n@@ -778,6 +840,7 @@ unsigned struct_iscsi_wait_event_parameters_sz =\n unsigned struct_isp_stats_sz = sizeof(isp_stats_t);\n unsigned struct_lsenable_sz = sizeof(struct lsenable);\n unsigned struct_lsdisable_sz = sizeof(struct lsdisable);\n+unsigned struct_audio_format_query_sz = sizeof(audio_format_query);\n unsigned struct_mixer_ctrl_sz = sizeof(struct mixer_ctrl);\n unsigned struct_mixer_devinfo_sz = sizeof(struct mixer_devinfo);\n unsigned struct_mpu_command_rec_sz = sizeof(mpu_command_rec);\n@@ -795,6 +858,8 @@ unsigned struct_RF_SparetWait_sz = sizeof(RF_SparetWait_t);\n unsigned struct_RF_ComponentLabel_sz = sizeof(RF_ComponentLabel_t);\n unsigned struct_RF_SingleComponent_sz = sizeof(RF_SingleComponent_t);\n unsigned struct_RF_ProgressInfo_sz = sizeof(RF_ProgressInfo_t);\n+unsigned struct_nvlist_ref_sz = sizeof(struct __sanitizer_nvlist_ref_t);\n+unsigned struct_StringList_sz = sizeof(StringList);\n \n const unsigned IOCTL_NOT_PRESENT = 0;\n \n@@ -1059,16 +1124,14 @@ unsigned IOCTL_MLX_REBUILDSTAT = MLX_REBUILDSTAT;\n unsigned IOCTL_MLX_GET_SYSDRIVE = MLX_GET_SYSDRIVE;\n unsigned IOCTL_MLX_GET_CINFO = MLX_GET_CINFO;\n unsigned IOCTL_NVME_PASSTHROUGH_CMD = NVME_PASSTHROUGH_CMD;\n+unsigned IOCTL_FWCFGIO_SET_INDEX = FWCFGIO_SET_INDEX;\n unsigned IOCTL_IRDA_RESET_PARAMS = IRDA_RESET_PARAMS;\n unsigned IOCTL_IRDA_SET_PARAMS = IRDA_SET_PARAMS;\n unsigned IOCTL_IRDA_GET_SPEEDMASK = IRDA_GET_SPEEDMASK;\n unsigned IOCTL_IRDA_GET_TURNAROUNDMASK = IRDA_GET_TURNAROUNDMASK;\n unsigned IOCTL_IRFRAMETTY_GET_DEVICE = IRFRAMETTY_GET_DEVICE;\n unsigned IOCTL_IRFRAMETTY_GET_DONGLE = IRFRAMETTY_GET_DONGLE;\n unsigned IOCTL_IRFRAMETTY_SET_DONGLE = IRFRAMETTY_SET_DONGLE;\n-unsigned IOCTL_SATIORESET = SATIORESET;\n-unsigned IOCTL_SATIOGID = SATIOGID;\n-unsigned IOCTL_SATIOSBUFSIZE = SATIOSBUFSIZE;\n unsigned IOCTL_ISV_CMD = ISV_CMD;\n unsigned IOCTL_WTQICMD = WTQICMD;\n unsigned IOCTL_ISCSI_GET_VERSION = ISCSI_GET_VERSION;\n@@ -1388,6 +1451,27 @@ unsigned IOCTL_SPKRTONE = SPKRTONE;\n unsigned IOCTL_SPKRTUNE = SPKRTUNE;\n unsigned IOCTL_SPKRGETVOL = SPKRGETVOL;\n unsigned IOCTL_SPKRSETVOL = SPKRSETVOL;\n+#if defined(__x86_64__)\n+unsigned IOCTL_NVMM_IOC_CAPABILITY = NVMM_IOC_CAPABILITY;\n+unsigned IOCTL_NVMM_IOC_MACHINE_CREATE = NVMM_IOC_MACHINE_CREATE;\n+unsigned IOCTL_NVMM_IOC_MACHINE_DESTROY = NVMM_IOC_MACHINE_DESTROY;\n+unsigned IOCTL_NVMM_IOC_MACHINE_CONFIGURE = NVMM_IOC_MACHINE_CONFIGURE;\n+unsigned IOCTL_NVMM_IOC_VCPU_CREATE = NVMM_IOC_VCPU_CREATE;\n+unsigned IOCTL_NVMM_IOC_VCPU_DESTROY = NVMM_IOC_VCPU_DESTROY;\n+unsigned IOCTL_NVMM_IOC_VCPU_SETSTATE = NVMM_IOC_VCPU_SETSTATE;\n+unsigned IOCTL_NVMM_IOC_VCPU_GETSTATE = NVMM_IOC_VCPU_GETSTATE;\n+unsigned IOCTL_NVMM_IOC_VCPU_INJECT = NVMM_IOC_VCPU_INJECT;\n+unsigned IOCTL_NVMM_IOC_VCPU_RUN = NVMM_IOC_VCPU_RUN;\n+unsigned IOCTL_NVMM_IOC_GPA_MAP = NVMM_IOC_GPA_MAP;\n+unsigned IOCTL_NVMM_IOC_GPA_UNMAP = NVMM_IOC_GPA_UNMAP;\n+unsigned IOCTL_NVMM_IOC_HVA_MAP = NVMM_IOC_HVA_MAP;\n+unsigned IOCTL_NVMM_IOC_HVA_UNMAP = NVMM_IOC_HVA_UNMAP;\n+unsigned IOCTL_NVMM_IOC_CTL = NVMM_IOC_CTL;\n+#endif\n+unsigned IOCTL_SPI_IOCTL_CONFIGURE = SPI_IOCTL_CONFIGURE;\n+unsigned IOCTL_SPI_IOCTL_TRANSFER = SPI_IOCTL_TRANSFER;\n+unsigned IOCTL_AUTOFSREQUEST = AUTOFSREQUEST;\n+unsigned IOCTL_AUTOFSDONE = AUTOFSDONE;\n unsigned IOCTL_BIOCGBLEN = BIOCGBLEN;\n unsigned IOCTL_BIOCSBLEN = BIOCSBLEN;\n unsigned IOCTL_BIOCSETF = BIOCSETF;\n@@ -1406,19 +1490,12 @@ unsigned IOCTL_BIOCGHDRCMPLT = BIOCGHDRCMPLT;\n unsigned IOCTL_BIOCSHDRCMPLT = BIOCSHDRCMPLT;\n unsigned IOCTL_BIOCSDLT = BIOCSDLT;\n unsigned IOCTL_BIOCGDLTLIST = BIOCGDLTLIST;\n-unsigned IOCTL_BIOCGSEESENT = BIOCGSEESENT;\n-unsigned IOCTL_BIOCSSEESENT = BIOCSSEESENT;\n+unsigned IOCTL_BIOCGDIRECTION = BIOCGDIRECTION;\n+unsigned IOCTL_BIOCSDIRECTION = BIOCSDIRECTION;\n unsigned IOCTL_BIOCSRTIMEOUT = BIOCSRTIMEOUT;\n unsigned IOCTL_BIOCGRTIMEOUT = BIOCGRTIMEOUT;\n unsigned IOCTL_BIOCGFEEDBACK = BIOCGFEEDBACK;\n unsigned IOCTL_BIOCSFEEDBACK = BIOCSFEEDBACK;\n-unsigned IOCTL_SIOCRAWATM = SIOCRAWATM;\n-unsigned IOCTL_SIOCATMENA = SIOCATMENA;\n-unsigned IOCTL_SIOCATMDIS = SIOCATMDIS;\n-unsigned IOCTL_SIOCSPVCTX = SIOCSPVCTX;\n-unsigned IOCTL_SIOCGPVCTX = SIOCGPVCTX;\n-unsigned IOCTL_SIOCSPVCSIF = SIOCSPVCSIF;\n-unsigned IOCTL_SIOCGPVCSIF = SIOCGPVCSIF;\n unsigned IOCTL_GRESADDRS = GRESADDRS;\n unsigned IOCTL_GRESADDRD = GRESADDRD;\n unsigned IOCTL_GREGADDRS = GREGADDRS;\n@@ -1573,6 +1650,8 @@ unsigned IOCTL_SIOCRMNAT = SIOCRMNAT;\n unsigned IOCTL_SIOCGNATS = SIOCGNATS;\n unsigned IOCTL_SIOCGNATL = SIOCGNATL;\n unsigned IOCTL_SIOCPURGENAT = SIOCPURGENAT;\n+unsigned IOCTL_SIOCCONNECTX = SIOCCONNECTX;\n+unsigned IOCTL_SIOCCONNECTXDEL = SIOCCONNECTXDEL;\n unsigned IOCTL_SIOCSIFINFO_FLAGS = SIOCSIFINFO_FLAGS;\n unsigned IOCTL_SIOCAADDRCTL_POLICY = SIOCAADDRCTL_POLICY;\n unsigned IOCTL_SIOCDADDRCTL_POLICY = SIOCDADDRCTL_POLICY;\n@@ -1608,6 +1687,9 @@ unsigned IOCTL_AUDIO_GETPROPS = AUDIO_GETPROPS;\n unsigned IOCTL_AUDIO_GETBUFINFO = AUDIO_GETBUFINFO;\n unsigned IOCTL_AUDIO_SETCHAN = AUDIO_SETCHAN;\n unsigned IOCTL_AUDIO_GETCHAN = AUDIO_GETCHAN;\n+unsigned IOCTL_AUDIO_QUERYFORMAT = AUDIO_QUERYFORMAT;\n+unsigned IOCTL_AUDIO_GETFORMAT = AUDIO_GETFORMAT;\n+unsigned IOCTL_AUDIO_SETFORMAT = AUDIO_SETFORMAT;\n unsigned IOCTL_AUDIO_MIXER_READ = AUDIO_MIXER_READ;\n unsigned IOCTL_AUDIO_MIXER_WRITE = AUDIO_MIXER_WRITE;\n unsigned IOCTL_AUDIO_MIXER_DEVINFO = AUDIO_MIXER_DEVINFO;\n@@ -1693,6 +1775,7 @@ unsigned IOCTL_DIOCTUR = DIOCTUR;\n unsigned IOCTL_DIOCMWEDGES = DIOCMWEDGES;\n unsigned IOCTL_DIOCGSECTORSIZE = DIOCGSECTORSIZE;\n unsigned IOCTL_DIOCGMEDIASIZE = DIOCGMEDIASIZE;\n+unsigned IOCTL_DIOCRMWEDGES = DIOCRMWEDGES;\n unsigned IOCTL_DRVDETACHDEV = DRVDETACHDEV;\n unsigned IOCTL_DRVRESCANBUS = DRVRESCANBUS;\n unsigned IOCTL_DRVCTLCOMMAND = DRVCTLCOMMAND;\n@@ -1717,6 +1800,8 @@ unsigned IOCTL_FDIOCGETFORMAT = FDIOCGETFORMAT;\n unsigned IOCTL_FDIOCFORMAT_TRACK = FDIOCFORMAT_TRACK;\n unsigned IOCTL_FIOCLEX = FIOCLEX;\n unsigned IOCTL_FIONCLEX = FIONCLEX;\n+unsigned IOCTL_FIOSEEKDATA = FIOSEEKDATA;\n+unsigned IOCTL_FIOSEEKHOLE = FIOSEEKHOLE;\n unsigned IOCTL_FIONREAD = FIONREAD;\n unsigned IOCTL_FIONBIO = FIONBIO;\n unsigned IOCTL_FIOASYNC = FIOASYNC;\n@@ -1802,8 +1887,6 @@ unsigned IOCTL_MTIOCSLOCATE = MTIOCSLOCATE;\n unsigned IOCTL_MTIOCHLOCATE = MTIOCHLOCATE;\n unsigned IOCTL_POWER_EVENT_RECVDICT = POWER_EVENT_RECVDICT;\n unsigned IOCTL_POWER_IOC_GET_TYPE = POWER_IOC_GET_TYPE;\n-unsigned IOCTL_POWER_IOC_GET_TYPE_WITH_LOSSAGE =\n-    POWER_IOC_GET_TYPE_WITH_LOSSAGE;\n unsigned IOCTL_RIOCGINFO = RIOCGINFO;\n unsigned IOCTL_RIOCSINFO = RIOCSINFO;\n unsigned IOCTL_RIOCSSRCH = RIOCSSRCH;\n@@ -1838,6 +1921,7 @@ unsigned IOCTL_SIOCGLOWAT = SIOCGLOWAT;\n unsigned IOCTL_SIOCATMARK = SIOCATMARK;\n unsigned IOCTL_SIOCSPGRP = SIOCSPGRP;\n unsigned IOCTL_SIOCGPGRP = SIOCGPGRP;\n+unsigned IOCTL_SIOCPEELOFF = SIOCPEELOFF;\n unsigned IOCTL_SIOCADDRT = SIOCADDRT;\n unsigned IOCTL_SIOCDELRT = SIOCDELRT;\n unsigned IOCTL_SIOCSIFADDR = SIOCSIFADDR;\n@@ -1895,6 +1979,12 @@ unsigned IOCTL_SIOCGLINKSTR = SIOCGLINKSTR;\n unsigned IOCTL_SIOCSLINKSTR = SIOCSLINKSTR;\n unsigned IOCTL_SIOCGETHERCAP = SIOCGETHERCAP;\n unsigned IOCTL_SIOCGIFINDEX = SIOCGIFINDEX;\n+unsigned IOCTL_SIOCSETHERCAP = SIOCSETHERCAP;\n+unsigned IOCTL_SIOCSIFDESCR = SIOCSIFDESCR;\n+unsigned IOCTL_SIOCGIFDESCR = SIOCGIFDESCR;\n+unsigned IOCTL_SIOCGUMBINFO = SIOCGUMBINFO;\n+unsigned IOCTL_SIOCSUMBPARAM = SIOCSUMBPARAM;\n+unsigned IOCTL_SIOCGUMBPARAM = SIOCGUMBPARAM;\n unsigned IOCTL_SIOCSETPFSYNC = SIOCSETPFSYNC;\n unsigned IOCTL_SIOCGETPFSYNC = SIOCGETPFSYNC;\n unsigned IOCTL_PPS_IOC_CREATE = PPS_IOC_CREATE;\n@@ -2016,6 +2106,19 @@ unsigned IOCTL_WDOGIOC_WHICH = WDOGIOC_WHICH;\n unsigned IOCTL_WDOGIOC_TICKLE = WDOGIOC_TICKLE;\n unsigned IOCTL_WDOGIOC_GTICKLER = WDOGIOC_GTICKLER;\n unsigned IOCTL_WDOGIOC_GWDOGS = WDOGIOC_GWDOGS;\n+unsigned IOCTL_KCOV_IOC_SETBUFSIZE = KCOV_IOC_SETBUFSIZE;\n+unsigned IOCTL_KCOV_IOC_ENABLE = KCOV_IOC_ENABLE;\n+unsigned IOCTL_KCOV_IOC_DISABLE = KCOV_IOC_DISABLE;\n+unsigned IOCTL_IPMICTL_RECEIVE_MSG_TRUNC = IPMICTL_RECEIVE_MSG_TRUNC;\n+unsigned IOCTL_IPMICTL_RECEIVE_MSG = IPMICTL_RECEIVE_MSG;\n+unsigned IOCTL_IPMICTL_SEND_COMMAND = IPMICTL_SEND_COMMAND;\n+unsigned IOCTL_IPMICTL_REGISTER_FOR_CMD = IPMICTL_REGISTER_FOR_CMD;\n+unsigned IOCTL_IPMICTL_UNREGISTER_FOR_CMD = IPMICTL_UNREGISTER_FOR_CMD;\n+unsigned IOCTL_IPMICTL_SET_GETS_EVENTS_CMD = IPMICTL_SET_GETS_EVENTS_CMD;\n+unsigned IOCTL_IPMICTL_SET_MY_ADDRESS_CMD = IPMICTL_SET_MY_ADDRESS_CMD;\n+unsigned IOCTL_IPMICTL_GET_MY_ADDRESS_CMD = IPMICTL_GET_MY_ADDRESS_CMD;\n+unsigned IOCTL_IPMICTL_SET_MY_LUN_CMD = IPMICTL_SET_MY_LUN_CMD;\n+unsigned IOCTL_IPMICTL_GET_MY_LUN_CMD = IPMICTL_GET_MY_LUN_CMD;\n unsigned IOCTL_SNDCTL_DSP_RESET = SNDCTL_DSP_RESET;\n unsigned IOCTL_SNDCTL_DSP_SYNC = SNDCTL_DSP_SYNC;\n unsigned IOCTL_SNDCTL_DSP_SPEED = SNDCTL_DSP_SPEED;\n@@ -2061,6 +2164,44 @@ unsigned IOCTL_SNDCTL_DSP_SILENCE = SNDCTL_DSP_SILENCE;\n \n const int si_SEGV_MAPERR = SEGV_MAPERR;\n const int si_SEGV_ACCERR = SEGV_ACCERR;\n+\n+const int modctl_load = MODCTL_LOAD;\n+const int modctl_unload = MODCTL_UNLOAD;\n+const int modctl_stat = MODCTL_STAT;\n+const int modctl_exists = MODCTL_EXISTS;\n+\n+const unsigned SHA1_CTX_sz = sizeof(SHA1_CTX);\n+const unsigned SHA1_return_length = SHA1_DIGEST_STRING_LENGTH;\n+\n+const unsigned MD4_CTX_sz = sizeof(MD4_CTX);\n+const unsigned MD4_return_length = MD4_DIGEST_STRING_LENGTH;\n+\n+const unsigned RMD160_CTX_sz = sizeof(RMD160_CTX);\n+const unsigned RMD160_return_length = RMD160_DIGEST_STRING_LENGTH;\n+\n+const unsigned MD5_CTX_sz = sizeof(MD5_CTX);\n+const unsigned MD5_return_length = MD5_DIGEST_STRING_LENGTH;\n+\n+const unsigned fpos_t_sz = sizeof(fpos_t);\n+\n+const unsigned MD2_CTX_sz = sizeof(MD2_CTX);\n+const unsigned MD2_return_length = MD2_DIGEST_STRING_LENGTH;\n+\n+#define SHA2_CONST(LEN)                                                      \\\n+  const unsigned SHA##LEN##_CTX_sz = sizeof(SHA##LEN##_CTX);                 \\\n+  const unsigned SHA##LEN##_return_length = SHA##LEN##_DIGEST_STRING_LENGTH; \\\n+  const unsigned SHA##LEN##_block_length = SHA##LEN##_BLOCK_LENGTH;          \\\n+  const unsigned SHA##LEN##_digest_length = SHA##LEN##_DIGEST_LENGTH\n+\n+SHA2_CONST(224);\n+SHA2_CONST(256);\n+SHA2_CONST(384);\n+SHA2_CONST(512);\n+\n+#undef SHA2_CONST\n+\n+const int unvis_valid = UNVIS_VALID;\n+const int unvis_validpush = UNVIS_VALIDPUSH;\n }  // namespace __sanitizer\n \n using namespace __sanitizer;\n@@ -2151,6 +2292,29 @@ CHECK_SIZE_AND_OFFSET(wordexp_t, we_wordc);\n CHECK_SIZE_AND_OFFSET(wordexp_t, we_wordv);\n CHECK_SIZE_AND_OFFSET(wordexp_t, we_offs);\n \n+COMPILER_CHECK(sizeof(__sanitizer_FILE) <= sizeof(FILE));\n+CHECK_SIZE_AND_OFFSET(FILE, _p);\n+CHECK_SIZE_AND_OFFSET(FILE, _r);\n+CHECK_SIZE_AND_OFFSET(FILE, _w);\n+CHECK_SIZE_AND_OFFSET(FILE, _flags);\n+CHECK_SIZE_AND_OFFSET(FILE, _file);\n+CHECK_SIZE_AND_OFFSET(FILE, _bf);\n+CHECK_SIZE_AND_OFFSET(FILE, _lbfsize);\n+CHECK_SIZE_AND_OFFSET(FILE, _cookie);\n+CHECK_SIZE_AND_OFFSET(FILE, _close);\n+CHECK_SIZE_AND_OFFSET(FILE, _read);\n+CHECK_SIZE_AND_OFFSET(FILE, _seek);\n+CHECK_SIZE_AND_OFFSET(FILE, _write);\n+CHECK_SIZE_AND_OFFSET(FILE, _ext);\n+CHECK_SIZE_AND_OFFSET(FILE, _up);\n+CHECK_SIZE_AND_OFFSET(FILE, _ur);\n+CHECK_SIZE_AND_OFFSET(FILE, _ubuf);\n+CHECK_SIZE_AND_OFFSET(FILE, _nbuf);\n+CHECK_SIZE_AND_OFFSET(FILE, _flush);\n+CHECK_SIZE_AND_OFFSET(FILE, _lb_unused);\n+CHECK_SIZE_AND_OFFSET(FILE, _blksize);\n+CHECK_SIZE_AND_OFFSET(FILE, _offset);\n+\n CHECK_TYPE_SIZE(tm);\n CHECK_SIZE_AND_OFFSET(tm, tm_sec);\n CHECK_SIZE_AND_OFFSET(tm, tm_min);\n@@ -2222,4 +2386,10 @@ CHECK_SIZE_AND_OFFSET(group, gr_passwd);\n CHECK_SIZE_AND_OFFSET(group, gr_gid);\n CHECK_SIZE_AND_OFFSET(group, gr_mem);\n \n+CHECK_TYPE_SIZE(modctl_load_t);\n+CHECK_SIZE_AND_OFFSET(modctl_load_t, ml_filename);\n+CHECK_SIZE_AND_OFFSET(modctl_load_t, ml_flags);\n+CHECK_SIZE_AND_OFFSET(modctl_load_t, ml_props);\n+CHECK_SIZE_AND_OFFSET(modctl_load_t, ml_propslen);\n+\n #endif  // SANITIZER_NETBSD", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_netbsd.cc"}, {"sha": "4fb3b8c0e06f1b268e4a09059d97d7fb0bb3df82", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_netbsd.h", "status": "modified", "additions": 208, "deletions": 21, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_netbsd.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_platform_limits_netbsd.h --------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -23,10 +24,10 @@\n \n #if defined(__x86_64__)\n #define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) \\\n-  _GET_LINK_MAP_BY_DLOPEN_HANDLE(handle, 312)\n+  _GET_LINK_MAP_BY_DLOPEN_HANDLE(handle, 264)\n #elif defined(__i386__)\n #define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) \\\n-  _GET_LINK_MAP_BY_DLOPEN_HANDLE(handle, 164)\n+  _GET_LINK_MAP_BY_DLOPEN_HANDLE(handle, 136)\n #endif\n \n namespace __sanitizer {\n@@ -58,6 +59,29 @@ extern unsigned struct_timespec_sz;\n extern unsigned struct_sembuf_sz;\n \n extern unsigned struct_kevent_sz;\n+extern unsigned struct_FTS_sz;\n+extern unsigned struct_FTSENT_sz;\n+\n+extern unsigned struct_regex_sz;\n+extern unsigned struct_regmatch_sz;\n+\n+extern unsigned struct_fstab_sz;\n+\n+struct __sanitizer_regmatch {\n+  OFF_T rm_so;\n+  OFF_T rm_eo;\n+};\n+\n+typedef struct __sanitizer_modctl_load {\n+  const char *ml_filename;\n+  int ml_flags;\n+  const char *ml_props;\n+  uptr ml_propslen;\n+} __sanitizer_modctl_load_t;\n+extern const int modctl_load;\n+extern const int modctl_unload;\n+extern const int modctl_stat;\n+extern const int modctl_exists;\n \n union __sanitizer_sigval {\n   int sival_int;\n@@ -423,8 +447,36 @@ struct __sanitizer_wordexp_t {\n   uptr we_nbytes;\n };\n \n-typedef char __sanitizer_FILE;\n-#define SANITIZER_HAS_STRUCT_FILE 0\n+struct __sanitizer_FILE {\n+  unsigned char *_p;\n+  int _r;\n+  int _w;\n+  unsigned short _flags;\n+  short _file;\n+  struct {\n+    unsigned char *_base;\n+    int _size;\n+  } _bf;\n+  int _lbfsize;\n+  void *_cookie;\n+  int (*_close)(void *ptr);\n+  u64 (*_read)(void *, void *, uptr);\n+  u64 (*_seek)(void *, u64, int);\n+  uptr (*_write)(void *, const void *, uptr);\n+  struct {\n+    unsigned char *_base;\n+    int _size;\n+  } _ext;\n+  unsigned char *_up;\n+  int _ur;\n+  unsigned char _ubuf[3];\n+  unsigned char _nbuf[1];\n+  int (*_flush)(void *ptr);\n+  char _lb_unused[sizeof(uptr)];\n+  int _blksize;\n+  u64 _offset;\n+};\n+#define SANITIZER_HAS_STRUCT_FILE 1\n \n extern int shmctl_ipc_stat;\n \n@@ -458,6 +510,8 @@ struct __sanitizer_ttyent {\n   char *ty_class;\n };\n \n+extern const unsigned long __sanitizer_bufsiz;\n+\n #define IOC_NRBITS 8\n #define IOC_TYPEBITS 8\n #define IOC_SIZEBITS 14\n@@ -494,7 +548,6 @@ extern unsigned struct_atabusiodetach_args_sz;\n extern unsigned struct_atabusioscan_args_sz;\n extern unsigned struct_ath_diag_sz;\n extern unsigned struct_atm_flowmap_sz;\n-extern unsigned struct_atm_pseudoioctl_sz;\n extern unsigned struct_audio_buf_info_sz;\n extern unsigned struct_audio_device_sz;\n extern unsigned struct_audio_encoding_sz;\n@@ -749,7 +802,6 @@ extern unsigned struct_rf_recon_req_sz;\n extern unsigned struct_rio_conf_sz;\n extern unsigned struct_rio_interface_sz;\n extern unsigned struct_rio_stats_sz;\n-extern unsigned struct_satlink_id_sz;\n extern unsigned struct_scan_io_sz;\n extern unsigned struct_scbusaccel_args_sz;\n extern unsigned struct_scbusiodetach_args_sz;\n@@ -797,6 +849,28 @@ extern unsigned struct_usb_config_desc_sz;\n extern unsigned struct_usb_ctl_report_desc_sz;\n extern unsigned struct_usb_ctl_report_sz;\n extern unsigned struct_usb_ctl_request_sz;\n+#if defined(__x86_64__)\n+extern unsigned struct_nvmm_ioc_capability_sz;\n+extern unsigned struct_nvmm_ioc_machine_create_sz;\n+extern unsigned struct_nvmm_ioc_machine_destroy_sz;\n+extern unsigned struct_nvmm_ioc_machine_configure_sz;\n+extern unsigned struct_nvmm_ioc_vcpu_create_sz;\n+extern unsigned struct_nvmm_ioc_vcpu_destroy_sz;\n+extern unsigned struct_nvmm_ioc_vcpu_setstate_sz;\n+extern unsigned struct_nvmm_ioc_vcpu_getstate_sz;\n+extern unsigned struct_nvmm_ioc_vcpu_inject_sz;\n+extern unsigned struct_nvmm_ioc_vcpu_run_sz;\n+extern unsigned struct_nvmm_ioc_gpa_map_sz;\n+extern unsigned struct_nvmm_ioc_gpa_unmap_sz;\n+extern unsigned struct_nvmm_ioc_hva_map_sz;\n+extern unsigned struct_nvmm_ioc_hva_unmap_sz;\n+extern unsigned struct_nvmm_ioc_ctl_sz;\n+#endif\n+extern unsigned struct_spi_ioctl_configure_sz;\n+extern unsigned struct_spi_ioctl_transfer_sz;\n+extern unsigned struct_autofs_daemon_request_sz;\n+extern unsigned struct_autofs_daemon_done_sz;\n+extern unsigned struct_sctp_connectx_addrs_sz;\n extern unsigned struct_usb_device_info_old_sz;\n extern unsigned struct_usb_device_info_sz;\n extern unsigned struct_usb_device_stats_sz;\n@@ -836,6 +910,9 @@ extern unsigned struct_vnd_user_sz;\n extern unsigned struct_vt_stat_sz;\n extern unsigned struct_wdog_conf_sz;\n extern unsigned struct_wdog_mode_sz;\n+extern unsigned struct_ipmi_recv_sz;\n+extern unsigned struct_ipmi_req_sz;\n+extern unsigned struct_ipmi_cmdspec_sz;\n extern unsigned struct_wfq_conf_sz;\n extern unsigned struct_wfq_getqid_sz;\n extern unsigned struct_wfq_getstats_sz;\n@@ -914,6 +991,7 @@ extern unsigned struct_iscsi_wait_event_parameters_sz;\n extern unsigned struct_isp_stats_sz;\n extern unsigned struct_lsenable_sz;\n extern unsigned struct_lsdisable_sz;\n+extern unsigned struct_audio_format_query_sz;\n extern unsigned struct_mixer_ctrl_sz;\n extern unsigned struct_mixer_devinfo_sz;\n extern unsigned struct_mpu_command_rec_sz;\n@@ -931,6 +1009,8 @@ extern unsigned struct_RF_SparetWait_sz;\n extern unsigned struct_RF_ComponentLabel_sz;\n extern unsigned struct_RF_SingleComponent_sz;\n extern unsigned struct_RF_ProgressInfo_sz;\n+extern unsigned struct_nvlist_ref_sz;\n+extern unsigned struct_StringList_sz;\n \n \n // A special value to mark ioctls that are not present on the target platform,\n@@ -1199,16 +1279,14 @@ extern unsigned IOCTL_MLX_REBUILDSTAT;\n extern unsigned IOCTL_MLX_GET_SYSDRIVE;\n extern unsigned IOCTL_MLX_GET_CINFO;\n extern unsigned IOCTL_NVME_PASSTHROUGH_CMD;\n+extern unsigned IOCTL_FWCFGIO_SET_INDEX;\n extern unsigned IOCTL_IRDA_RESET_PARAMS;\n extern unsigned IOCTL_IRDA_SET_PARAMS;\n extern unsigned IOCTL_IRDA_GET_SPEEDMASK;\n extern unsigned IOCTL_IRDA_GET_TURNAROUNDMASK;\n extern unsigned IOCTL_IRFRAMETTY_GET_DEVICE;\n extern unsigned IOCTL_IRFRAMETTY_GET_DONGLE;\n extern unsigned IOCTL_IRFRAMETTY_SET_DONGLE;\n-extern unsigned IOCTL_SATIORESET;\n-extern unsigned IOCTL_SATIOGID;\n-extern unsigned IOCTL_SATIOSBUFSIZE;\n extern unsigned IOCTL_ISV_CMD;\n extern unsigned IOCTL_WTQICMD;\n extern unsigned IOCTL_ISCSI_GET_VERSION;\n@@ -1520,6 +1598,25 @@ extern unsigned IOCTL_SPKRTONE;\n extern unsigned IOCTL_SPKRTUNE;\n extern unsigned IOCTL_SPKRGETVOL;\n extern unsigned IOCTL_SPKRSETVOL;\n+#if defined(__x86_64__)\n+extern unsigned IOCTL_NVMM_IOC_CAPABILITY;\n+extern unsigned IOCTL_NVMM_IOC_MACHINE_CREATE;\n+extern unsigned IOCTL_NVMM_IOC_MACHINE_DESTROY;\n+extern unsigned IOCTL_NVMM_IOC_MACHINE_CONFIGURE;\n+extern unsigned IOCTL_NVMM_IOC_VCPU_CREATE;\n+extern unsigned IOCTL_NVMM_IOC_VCPU_DESTROY;\n+extern unsigned IOCTL_NVMM_IOC_VCPU_SETSTATE;\n+extern unsigned IOCTL_NVMM_IOC_VCPU_GETSTATE;\n+extern unsigned IOCTL_NVMM_IOC_VCPU_INJECT;\n+extern unsigned IOCTL_NVMM_IOC_VCPU_RUN;\n+extern unsigned IOCTL_NVMM_IOC_GPA_MAP;\n+extern unsigned IOCTL_NVMM_IOC_GPA_UNMAP;\n+extern unsigned IOCTL_NVMM_IOC_HVA_MAP;\n+extern unsigned IOCTL_NVMM_IOC_HVA_UNMAP;\n+extern unsigned IOCTL_NVMM_IOC_CTL;\n+#endif\n+extern unsigned IOCTL_AUTOFSREQUEST;\n+extern unsigned IOCTL_AUTOFSDONE;\n extern unsigned IOCTL_BIOCGBLEN;\n extern unsigned IOCTL_BIOCSBLEN;\n extern unsigned IOCTL_BIOCSETF;\n@@ -1538,19 +1635,12 @@ extern unsigned IOCTL_BIOCGHDRCMPLT;\n extern unsigned IOCTL_BIOCSHDRCMPLT;\n extern unsigned IOCTL_BIOCSDLT;\n extern unsigned IOCTL_BIOCGDLTLIST;\n-extern unsigned IOCTL_BIOCGSEESENT;\n-extern unsigned IOCTL_BIOCSSEESENT;\n+extern unsigned IOCTL_BIOCGDIRECTION;\n+extern unsigned IOCTL_BIOCSDIRECTION;\n extern unsigned IOCTL_BIOCSRTIMEOUT;\n extern unsigned IOCTL_BIOCGRTIMEOUT;\n extern unsigned IOCTL_BIOCGFEEDBACK;\n extern unsigned IOCTL_BIOCSFEEDBACK;\n-extern unsigned IOCTL_SIOCRAWATM;\n-extern unsigned IOCTL_SIOCATMENA;\n-extern unsigned IOCTL_SIOCATMDIS;\n-extern unsigned IOCTL_SIOCSPVCTX;\n-extern unsigned IOCTL_SIOCGPVCTX;\n-extern unsigned IOCTL_SIOCSPVCSIF;\n-extern unsigned IOCTL_SIOCGPVCSIF;\n extern unsigned IOCTL_GRESADDRS;\n extern unsigned IOCTL_GRESADDRD;\n extern unsigned IOCTL_GREGADDRS;\n@@ -1705,6 +1795,8 @@ extern unsigned IOCTL_SIOCRMNAT;\n extern unsigned IOCTL_SIOCGNATS;\n extern unsigned IOCTL_SIOCGNATL;\n extern unsigned IOCTL_SIOCPURGENAT;\n+extern unsigned IOCTL_SIOCCONNECTX;\n+extern unsigned IOCTL_SIOCCONNECTXDEL;\n extern unsigned IOCTL_SIOCSIFINFO_FLAGS;\n extern unsigned IOCTL_SIOCAADDRCTL_POLICY;\n extern unsigned IOCTL_SIOCDADDRCTL_POLICY;\n@@ -1740,6 +1832,9 @@ extern unsigned IOCTL_AUDIO_GETPROPS;\n extern unsigned IOCTL_AUDIO_GETBUFINFO;\n extern unsigned IOCTL_AUDIO_SETCHAN;\n extern unsigned IOCTL_AUDIO_GETCHAN;\n+extern unsigned IOCTL_AUDIO_QUERYFORMAT;\n+extern unsigned IOCTL_AUDIO_GETFORMAT;\n+extern unsigned IOCTL_AUDIO_SETFORMAT;\n extern unsigned IOCTL_AUDIO_MIXER_READ;\n extern unsigned IOCTL_AUDIO_MIXER_WRITE;\n extern unsigned IOCTL_AUDIO_MIXER_DEVINFO;\n@@ -1825,6 +1920,7 @@ extern unsigned IOCTL_DIOCTUR;\n extern unsigned IOCTL_DIOCMWEDGES;\n extern unsigned IOCTL_DIOCGSECTORSIZE;\n extern unsigned IOCTL_DIOCGMEDIASIZE;\n+extern unsigned IOCTL_DIOCRMWEDGES;\n extern unsigned IOCTL_DRVDETACHDEV;\n extern unsigned IOCTL_DRVRESCANBUS;\n extern unsigned IOCTL_DRVCTLCOMMAND;\n@@ -1849,6 +1945,8 @@ extern unsigned IOCTL_FDIOCGETFORMAT;\n extern unsigned IOCTL_FDIOCFORMAT_TRACK;\n extern unsigned IOCTL_FIOCLEX;\n extern unsigned IOCTL_FIONCLEX;\n+extern unsigned IOCTL_FIOSEEKDATA;\n+extern unsigned IOCTL_FIOSEEKHOLE;\n extern unsigned IOCTL_FIONREAD;\n extern unsigned IOCTL_FIONBIO;\n extern unsigned IOCTL_FIOASYNC;\n@@ -1924,6 +2022,8 @@ extern unsigned IOCTL_SEQUENCER_TMR_TEMPO;\n extern unsigned IOCTL_SEQUENCER_TMR_SOURCE;\n extern unsigned IOCTL_SEQUENCER_TMR_METRONOME;\n extern unsigned IOCTL_SEQUENCER_TMR_SELECT;\n+extern unsigned IOCTL_SPI_IOCTL_CONFIGURE;\n+extern unsigned IOCTL_SPI_IOCTL_TRANSFER;\n extern unsigned IOCTL_MTIOCTOP;\n extern unsigned IOCTL_MTIOCGET;\n extern unsigned IOCTL_MTIOCIEOT;\n@@ -1934,7 +2034,6 @@ extern unsigned IOCTL_MTIOCSLOCATE;\n extern unsigned IOCTL_MTIOCHLOCATE;\n extern unsigned IOCTL_POWER_EVENT_RECVDICT;\n extern unsigned IOCTL_POWER_IOC_GET_TYPE;\n-extern unsigned IOCTL_POWER_IOC_GET_TYPE_WITH_LOSSAGE;\n extern unsigned IOCTL_RIOCGINFO;\n extern unsigned IOCTL_RIOCSINFO;\n extern unsigned IOCTL_RIOCSSRCH;\n@@ -1969,6 +2068,7 @@ extern unsigned IOCTL_SIOCGLOWAT;\n extern unsigned IOCTL_SIOCATMARK;\n extern unsigned IOCTL_SIOCSPGRP;\n extern unsigned IOCTL_SIOCGPGRP;\n+extern unsigned IOCTL_SIOCPEELOFF;\n extern unsigned IOCTL_SIOCADDRT;\n extern unsigned IOCTL_SIOCDELRT;\n extern unsigned IOCTL_SIOCSIFADDR;\n@@ -2026,6 +2126,12 @@ extern unsigned IOCTL_SIOCGLINKSTR;\n extern unsigned IOCTL_SIOCSLINKSTR;\n extern unsigned IOCTL_SIOCGETHERCAP;\n extern unsigned IOCTL_SIOCGIFINDEX;\n+extern unsigned IOCTL_SIOCSETHERCAP;\n+extern unsigned IOCTL_SIOCSIFDESCR;\n+extern unsigned IOCTL_SIOCGIFDESCR;\n+extern unsigned IOCTL_SIOCGUMBINFO;\n+extern unsigned IOCTL_SIOCSUMBPARAM;\n+extern unsigned IOCTL_SIOCGUMBPARAM;\n extern unsigned IOCTL_SIOCSETPFSYNC;\n extern unsigned IOCTL_SIOCGETPFSYNC;\n extern unsigned IOCTL_PPS_IOC_CREATE;\n@@ -2147,6 +2253,19 @@ extern unsigned IOCTL_WDOGIOC_WHICH;\n extern unsigned IOCTL_WDOGIOC_TICKLE;\n extern unsigned IOCTL_WDOGIOC_GTICKLER;\n extern unsigned IOCTL_WDOGIOC_GWDOGS;\n+extern unsigned IOCTL_KCOV_IOC_SETBUFSIZE;\n+extern unsigned IOCTL_KCOV_IOC_ENABLE;\n+extern unsigned IOCTL_KCOV_IOC_DISABLE;\n+extern unsigned IOCTL_IPMICTL_RECEIVE_MSG_TRUNC;\n+extern unsigned IOCTL_IPMICTL_RECEIVE_MSG;\n+extern unsigned IOCTL_IPMICTL_SEND_COMMAND;\n+extern unsigned IOCTL_IPMICTL_REGISTER_FOR_CMD;\n+extern unsigned IOCTL_IPMICTL_UNREGISTER_FOR_CMD;\n+extern unsigned IOCTL_IPMICTL_SET_GETS_EVENTS_CMD;\n+extern unsigned IOCTL_IPMICTL_SET_MY_ADDRESS_CMD;\n+extern unsigned IOCTL_IPMICTL_GET_MY_ADDRESS_CMD;\n+extern unsigned IOCTL_IPMICTL_SET_MY_LUN_CMD;\n+extern unsigned IOCTL_IPMICTL_GET_MY_LUN_CMD;\n extern unsigned IOCTL_SNDCTL_DSP_RESET;\n extern unsigned IOCTL_SNDCTL_DSP_SYNC;\n extern unsigned IOCTL_SNDCTL_DSP_SPEED;\n@@ -2192,6 +2311,74 @@ extern unsigned IOCTL_SNDCTL_DSP_SILENCE;\n \n extern const int si_SEGV_MAPERR;\n extern const int si_SEGV_ACCERR;\n+\n+extern const unsigned SHA1_CTX_sz;\n+extern const unsigned SHA1_return_length;\n+\n+extern const unsigned MD4_CTX_sz;\n+extern const unsigned MD4_return_length;\n+\n+extern const unsigned RMD160_CTX_sz;\n+extern const unsigned RMD160_return_length;\n+\n+extern const unsigned MD5_CTX_sz;\n+extern const unsigned MD5_return_length;\n+\n+extern const unsigned fpos_t_sz;\n+\n+extern const unsigned MD2_CTX_sz;\n+extern const unsigned MD2_return_length;\n+\n+#define SHA2_EXTERN(LEN)                          \\\n+  extern const unsigned SHA##LEN##_CTX_sz;        \\\n+  extern const unsigned SHA##LEN##_return_length; \\\n+  extern const unsigned SHA##LEN##_block_length;  \\\n+  extern const unsigned SHA##LEN##_digest_length\n+\n+SHA2_EXTERN(224);\n+SHA2_EXTERN(256);\n+SHA2_EXTERN(384);\n+SHA2_EXTERN(512);\n+\n+#undef SHA2_EXTERN\n+\n+extern const int unvis_valid;\n+extern const int unvis_validpush;\n+\n+struct __sanitizer_cdbr {\n+  void (*unmap)(void *, void *, uptr);\n+  void *cookie;\n+  u8 *mmap_base;\n+  uptr mmap_size;\n+\n+  u8 *hash_base;\n+  u8 *offset_base;\n+  u8 *data_base;\n+\n+  u32 data_size;\n+  u32 entries;\n+  u32 entries_index;\n+  u32 seed;\n+\n+  u8 offset_size;\n+  u8 index_size;\n+\n+  u32 entries_m;\n+  u32 entries_index_m;\n+  u8 entries_s1, entries_s2;\n+  u8 entries_index_s1, entries_index_s2;\n+};\n+\n+struct __sanitizer_cdbw {\n+  uptr data_counter;\n+  uptr data_allocated;\n+  uptr data_size;\n+  uptr *data_len;\n+  void **data_ptr;\n+  uptr hash_size;\n+  void *hash;\n+  uptr key_counter;\n+};\n }  // namespace __sanitizer\n \n #define CHECK_TYPE_SIZE(TYPE) \\"}, {"sha": "12515626ce5342ec816f38ad991da47a3e05dbdd", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_openbsd.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_openbsd.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_openbsd.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_openbsd.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_platform_limits_openbsd.cc ------------------------------===//\n+//===-- sanitizer_platform_limits_openbsd.cpp -----------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_openbsd.cc"}, {"sha": "6d8b062716b7839593cbd0e3fb2d56f7d1b3a201", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_openbsd.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_openbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_openbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_openbsd.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_platform_limits_openbsd.h -------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "7f1132c461e9812c1703434c050d57455bc1641b", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cpp", "status": "renamed", "additions": 30, "deletions": 60, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_platform_limits_posix.cc --------------------------------===//\n+//===-- sanitizer_platform_limits_posix.cpp -------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -12,7 +13,7 @@\n \n #include \"sanitizer_platform.h\"\n \n-#if SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_MAC\n+#if SANITIZER_LINUX || SANITIZER_MAC\n // Tests in this file assume that off_t-dependent data structures match the\n // libc ABI. For example, struct dirent here is what readdir() function (as\n // exported from libc) returns, and not the user-facing \"dirent\", which\n@@ -43,7 +44,8 @@\n #include <termios.h>\n #include <time.h>\n #include <wchar.h>\n-#if !SANITIZER_MAC && !SANITIZER_FREEBSD\n+#include <regex.h>\n+#if !SANITIZER_MAC\n #include <utmp.h>\n #endif\n \n@@ -52,6 +54,7 @@\n #endif\n \n #if !SANITIZER_ANDROID\n+#include <fstab.h>\n #include <sys/mount.h>\n #include <sys/timeb.h>\n #include <utmpx.h>\n@@ -76,43 +79,11 @@\n #include <net/if_arp.h>\n #endif\n \n-#if SANITIZER_FREEBSD\n-# include <sys/mount.h>\n-# include <sys/sockio.h>\n-# include <sys/socket.h>\n-# include <sys/filio.h>\n-# include <sys/signal.h>\n-# include <sys/timespec.h>\n-# include <sys/timex.h>\n-# include <sys/mqueue.h>\n-# include <sys/msg.h>\n-# include <sys/ipc.h>\n-# include <sys/msg.h>\n-# include <sys/statvfs.h>\n-# include <sys/soundcard.h>\n-# include <sys/mtio.h>\n-# include <sys/consio.h>\n-# include <sys/kbio.h>\n-# include <sys/link_elf.h>\n-# include <netinet/ip_mroute.h>\n-# include <netinet/in.h>\n-# include <net/ethernet.h>\n-# include <net/ppp_defs.h>\n-# include <glob.h>\n-# include <term.h>\n-\n-#define _KERNEL  // to declare 'shminfo' structure\n-# include <sys/shm.h>\n-#undef _KERNEL\n-\n-#undef INLINE  // to avoid clashes with sanitizers' definitions\n-#endif\n-\n-#if SANITIZER_FREEBSD || SANITIZER_IOS\n+#if SANITIZER_IOS\n #undef IOC_DIRMASK\n #endif\n \n-#if SANITIZER_LINUX || SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n # include <utime.h>\n # include <sys/ptrace.h>\n # if defined(__mips64) || defined(__aarch64__) || defined(__arm__)\n@@ -144,8 +115,6 @@ typedef struct user_fpregs elf_fpregset_t;\n #include <netrom/netrom.h>\n #if HAVE_RPC_XDR_H\n # include <rpc/xdr.h>\n-#elif HAVE_TIRPC_RPC_XDR_H\n-# include <tirpc/rpc/xdr.h>\n #endif\n #include <scsi/scsi.h>\n #include <sys/mtio.h>\n@@ -196,9 +165,9 @@ typedef struct user_fpregs elf_fpregset_t;\n namespace __sanitizer {\n   unsigned struct_utsname_sz = sizeof(struct utsname);\n   unsigned struct_stat_sz = sizeof(struct stat);\n-#if !SANITIZER_IOS && !SANITIZER_FREEBSD\n+#if !SANITIZER_IOS\n   unsigned struct_stat64_sz = sizeof(struct stat64);\n-#endif // !SANITIZER_IOS && !SANITIZER_FREEBSD\n+#endif // !SANITIZER_IOS\n   unsigned struct_rusage_sz = sizeof(struct rusage);\n   unsigned struct_tm_sz = sizeof(struct tm);\n   unsigned struct_passwd_sz = sizeof(struct passwd);\n@@ -219,13 +188,15 @@ namespace __sanitizer {\n   unsigned struct_tms_sz = sizeof(struct tms);\n   unsigned struct_sigevent_sz = sizeof(struct sigevent);\n   unsigned struct_sched_param_sz = sizeof(struct sched_param);\n-\n+  unsigned struct_regex_sz = sizeof(regex_t);\n+  unsigned struct_regmatch_sz = sizeof(regmatch_t);\n \n #if SANITIZER_MAC && !SANITIZER_IOS\n   unsigned struct_statfs64_sz = sizeof(struct statfs64);\n #endif // SANITIZER_MAC && !SANITIZER_IOS\n \n #if !SANITIZER_ANDROID\n+  unsigned struct_fstab_sz = sizeof(struct fstab);\n   unsigned struct_statfs_sz = sizeof(struct statfs);\n   unsigned struct_sockaddr_sz = sizeof(struct sockaddr);\n   unsigned ucontext_t_sz = sizeof(ucontext_t);\n@@ -242,12 +213,12 @@ namespace __sanitizer {\n   unsigned struct_oldold_utsname_sz = sizeof(struct oldold_utsname);\n #endif // SANITIZER_LINUX\n \n-#if SANITIZER_LINUX || SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n   unsigned struct_rlimit_sz = sizeof(struct rlimit);\n   unsigned struct_timespec_sz = sizeof(struct timespec);\n   unsigned struct_utimbuf_sz = sizeof(struct utimbuf);\n   unsigned struct_itimerspec_sz = sizeof(struct itimerspec);\n-#endif // SANITIZER_LINUX || SANITIZER_FREEBSD\n+#endif // SANITIZER_LINUX\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n   // Use pre-computed size of struct ustat to avoid <sys/ustat.h> which\n@@ -267,12 +238,12 @@ namespace __sanitizer {\n   unsigned struct_statvfs64_sz = sizeof(struct statvfs64);\n #endif // SANITIZER_LINUX && !SANITIZER_ANDROID\n \n-#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n   unsigned struct_timex_sz = sizeof(struct timex);\n   unsigned struct_msqid_ds_sz = sizeof(struct msqid_ds);\n   unsigned struct_mq_attr_sz = sizeof(struct mq_attr);\n   unsigned struct_statvfs_sz = sizeof(struct statvfs);\n-#endif // (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+#endif // SANITIZER_LINUX && !SANITIZER_ANDROID\n \n   const uptr sig_ign = (uptr)SIG_IGN;\n   const uptr sig_dfl = (uptr)SIG_DFL;\n@@ -284,7 +255,7 @@ namespace __sanitizer {\n #endif\n \n \n-#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n   unsigned struct_shminfo_sz = sizeof(struct shminfo);\n   unsigned struct_shm_info_sz = sizeof(struct shm_info);\n   int shmctl_ipc_stat = (int)IPC_STAT;\n@@ -320,7 +291,7 @@ unsigned struct_ElfW_Phdr_sz = sizeof(ElfW(Phdr));\n unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n #endif\n \n-#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n   int glob_nomatch = GLOB_NOMATCH;\n   int glob_altdirfunc = GLOB_ALTDIRFUNC;\n #endif\n@@ -445,7 +416,7 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n   unsigned struct_vt_stat_sz = sizeof(struct vt_stat);\n #endif // SANITIZER_LINUX\n \n-#if SANITIZER_LINUX || SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n #if SOUND_VERSION >= 0x040000\n   unsigned struct_copr_buffer_sz = 0;\n   unsigned struct_copr_debug_buf_sz = 0;\n@@ -462,7 +433,7 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n   unsigned struct_seq_event_rec_sz = sizeof(struct seq_event_rec);\n   unsigned struct_synth_info_sz = sizeof(struct synth_info);\n   unsigned struct_vt_mode_sz = sizeof(struct vt_mode);\n-#endif // SANITIZER_LINUX || SANITIZER_FREEBSD\n+#endif // SANITIZER_LINUX\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n   unsigned struct_ax25_parms_struct_sz = sizeof(struct ax25_parms_struct);\n@@ -489,7 +460,7 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n   unsigned struct_unimapinit_sz = sizeof(struct unimapinit);\n #endif // SANITIZER_LINUX && !SANITIZER_ANDROID\n \n-#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n   unsigned struct_audio_buf_info_sz = sizeof(struct audio_buf_info);\n   unsigned struct_ppp_stats_sz = sizeof(struct ppp_stats);\n #endif // (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n@@ -499,6 +470,8 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n   unsigned struct_sioc_vif_req_sz = sizeof(struct sioc_vif_req);\n #endif\n \n+  const unsigned long __sanitizer_bufsiz = BUFSIZ;\n+\n   const unsigned IOCTL_NOT_PRESENT = 0;\n \n   unsigned IOCTL_FIOASYNC = FIOASYNC;\n@@ -545,7 +518,7 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n   unsigned IOCTL_TIOCSPGRP = TIOCSPGRP;\n   unsigned IOCTL_TIOCSTI = TIOCSTI;\n   unsigned IOCTL_TIOCSWINSZ = TIOCSWINSZ;\n-#if ((SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID)\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n   unsigned IOCTL_SIOCGETSGCNT = SIOCGETSGCNT;\n   unsigned IOCTL_SIOCGETVIFCNT = SIOCGETVIFCNT;\n #endif\n@@ -735,9 +708,6 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n   unsigned IOCTL_VT_RESIZE = VT_RESIZE;\n   unsigned IOCTL_VT_RESIZEX = VT_RESIZEX;\n   unsigned IOCTL_VT_SENDSIG = VT_SENDSIG;\n-#endif // SANITIZER_LINUX\n-\n-#if SANITIZER_LINUX || SANITIZER_FREEBSD\n   unsigned IOCTL_MTIOCGET = MTIOCGET;\n   unsigned IOCTL_MTIOCTOP = MTIOCTOP;\n   unsigned IOCTL_SNDCTL_DSP_GETBLKSIZE = SNDCTL_DSP_GETBLKSIZE;\n@@ -830,7 +800,7 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n   unsigned IOCTL_VT_RELDISP = VT_RELDISP;\n   unsigned IOCTL_VT_SETMODE = VT_SETMODE;\n   unsigned IOCTL_VT_WAITACTIVE = VT_WAITACTIVE;\n-#endif // SANITIZER_LINUX || SANITIZER_FREEBSD\n+#endif // SANITIZER_LINUX\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n   unsigned IOCTL_CYGETDEFTHRESH = CYGETDEFTHRESH;\n@@ -923,7 +893,7 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n   unsigned IOCTL_TIOCSSERIAL = TIOCSSERIAL;\n #endif // SANITIZER_LINUX && !SANITIZER_ANDROID\n \n-#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n   unsigned IOCTL_GIO_SCRNMAP = GIO_SCRNMAP;\n   unsigned IOCTL_KDDISABIO = KDDISABIO;\n   unsigned IOCTL_KDENABIO = KDENABIO;\n@@ -1241,7 +1211,7 @@ CHECK_SIZE_AND_OFFSET(group, gr_passwd);\n CHECK_SIZE_AND_OFFSET(group, gr_gid);\n CHECK_SIZE_AND_OFFSET(group, gr_mem);\n \n-#if HAVE_RPC_XDR_H || HAVE_TIRPC_RPC_XDR_H\n+#if HAVE_RPC_XDR_H\n CHECK_TYPE_SIZE(XDR);\n CHECK_SIZE_AND_OFFSET(XDR, x_op);\n CHECK_SIZE_AND_OFFSET(XDR, x_ops);", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc"}, {"sha": "ef90a2592cfc15ca57b12bd9d1ca7d434fd8f6e4", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h", "status": "modified", "additions": 35, "deletions": 109, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_platform_limits_posix.h ---------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -13,22 +14,12 @@\n #ifndef SANITIZER_PLATFORM_LIMITS_POSIX_H\n #define SANITIZER_PLATFORM_LIMITS_POSIX_H\n \n-#if SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_MAC\n+#if SANITIZER_LINUX || SANITIZER_MAC\n \n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_platform.h\"\n \n-#if SANITIZER_FREEBSD\n-// FreeBSD's dlopen() returns a pointer to an Obj_Entry structure that\n-// incorporates the map structure.\n-# define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) \\\n-    ((link_map*)((handle) == nullptr ? nullptr : ((char*)(handle) + 560)))\n-// Get sys/_types.h, because that tells us whether 64-bit inodes are\n-// used in struct dirent below.\n-#include <sys/_types.h>\n-#else\n # define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) ((link_map*)(handle))\n-#endif  // !SANITIZER_FREEBSD\n \n #ifndef __GLIBC_PREREQ\n #define __GLIBC_PREREQ(x, y) 0\n@@ -37,7 +28,7 @@\n namespace __sanitizer {\n   extern unsigned struct_utsname_sz;\n   extern unsigned struct_stat_sz;\n-#if !SANITIZER_FREEBSD && !SANITIZER_IOS\n+#if !SANITIZER_IOS\n   extern unsigned struct_stat64_sz;\n #endif\n   extern unsigned struct_rusage_sz;\n@@ -57,8 +48,11 @@ namespace __sanitizer {\n   extern unsigned struct_sigevent_sz;\n   extern unsigned struct_sched_param_sz;\n   extern unsigned struct_statfs64_sz;\n+  extern unsigned struct_regex_sz;\n+  extern unsigned struct_regmatch_sz;\n \n #if !SANITIZER_ANDROID\n+  extern unsigned struct_fstab_sz;\n   extern unsigned struct_statfs_sz;\n   extern unsigned struct_sockaddr_sz;\n   extern unsigned ucontext_t_sz;\n@@ -87,7 +81,7 @@ namespace __sanitizer {\n #elif defined(__mips__)\n   const unsigned struct_kernel_stat_sz =\n                  SANITIZER_ANDROID ? FIRST_32_SECOND_64(104, 128) :\n-                                     FIRST_32_SECOND_64(144, 216);\n+                                     FIRST_32_SECOND_64(160, 216);\n   const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__s390__) && !defined(__s390x__)\n   const unsigned struct_kernel_stat_sz = 64;\n@@ -121,7 +115,7 @@ namespace __sanitizer {\n   const unsigned struct_kexec_segment_sz = 4 * sizeof(unsigned long);\n #endif  // SANITIZER_LINUX\n \n-#if SANITIZER_LINUX || SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n \n #if defined(__powerpc64__) || defined(__s390__)\n   const unsigned struct___old_kernel_stat_sz = 0;\n@@ -178,11 +172,9 @@ namespace __sanitizer {\n     int data;\n #elif SANITIZER_LINUX\n     uptr data[4];\n-#elif SANITIZER_FREEBSD\n-    u32 data[4];\n #endif\n   };\n-#endif // SANITIZER_LINUX || SANITIZER_FREEBSD\n+#endif // SANITIZER_LINUX\n \n #if SANITIZER_ANDROID\n   struct __sanitizer_struct_mallinfo {\n@@ -304,35 +296,14 @@ namespace __sanitizer {\n   #endif\n #endif\n   };\n-#elif SANITIZER_FREEBSD\n-  struct __sanitizer_ipc_perm {\n-    unsigned int cuid;\n-    unsigned int cgid;\n-    unsigned int uid;\n-    unsigned int gid;\n-    unsigned short mode;\n-    unsigned short seq;\n-    long key;\n-  };\n-\n-  struct __sanitizer_shmid_ds {\n-    __sanitizer_ipc_perm shm_perm;\n-    unsigned long shm_segsz;\n-    unsigned int shm_lpid;\n-    unsigned int shm_cpid;\n-    int shm_nattch;\n-    unsigned long shm_atime;\n-    unsigned long shm_dtime;\n-    unsigned long shm_ctime;\n-  };\n #endif\n \n-#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n   extern unsigned struct_msqid_ds_sz;\n   extern unsigned struct_mq_attr_sz;\n   extern unsigned struct_timex_sz;\n   extern unsigned struct_statvfs_sz;\n-#endif  // (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+#endif  // SANITIZER_LINUX && !SANITIZER_ANDROID\n \n   struct __sanitizer_iovec {\n     void *iov_base;\n@@ -382,7 +353,7 @@ namespace __sanitizer {\n     char *pw_passwd;\n     int pw_uid;\n     int pw_gid;\n-#if SANITIZER_MAC || SANITIZER_FREEBSD\n+#if SANITIZER_MAC\n     long pw_change;\n     char *pw_class;\n #endif\n@@ -391,11 +362,8 @@ namespace __sanitizer {\n #endif\n     char *pw_dir;\n     char *pw_shell;\n-#if SANITIZER_MAC || SANITIZER_FREEBSD\n+#if SANITIZER_MAC\n     long pw_expire;\n-#endif\n-#if SANITIZER_FREEBSD\n-    int pw_fields;\n #endif\n   };\n \n@@ -466,7 +434,7 @@ namespace __sanitizer {\n   };\n #endif\n \n-#if SANITIZER_MAC || SANITIZER_FREEBSD\n+#if SANITIZER_MAC\n   struct __sanitizer_msghdr {\n     void *msg_name;\n     unsigned msg_namelen;\n@@ -512,17 +480,6 @@ namespace __sanitizer {\n     unsigned short d_reclen;\n     // more fields that we don't care about\n   };\n-#elif SANITIZER_FREEBSD\n-  struct __sanitizer_dirent {\n-#if defined(__INO64)\n-    unsigned long long d_fileno;\n-    unsigned long long d_off;\n-#else\n-    unsigned int d_fileno;\n-#endif\n-    unsigned short d_reclen;\n-    // more fields that we don't care about\n-  };\n #elif SANITIZER_ANDROID || defined(__x86_64__)\n   struct __sanitizer_dirent {\n     unsigned long long d_ino;\n@@ -548,20 +505,17 @@ namespace __sanitizer {\n   };\n #endif\n \n-// 'clock_t' is 32 bits wide on x64 FreeBSD\n-#if SANITIZER_FREEBSD\n-  typedef int __sanitizer_clock_t;\n-#elif defined(__x86_64__) && !defined(_LP64)\n+#if defined(__x86_64__) && !defined(_LP64)\n   typedef long long __sanitizer_clock_t;\n #else\n   typedef long __sanitizer_clock_t;\n #endif\n \n-#if SANITIZER_LINUX || SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n   typedef int __sanitizer_clockid_t;\n #endif\n \n-#if SANITIZER_LINUX || SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n #if defined(_LP64) || defined(__x86_64__) || defined(__powerpc__)\\\n                    || defined(__mips__)\n   typedef unsigned __sanitizer___kernel_uid_t;\n@@ -591,7 +545,7 @@ namespace __sanitizer {\n #endif\n \n   // This thing depends on the platform. We are only interested in the upper\n-  // limit. Verified with a compiler assert in .cc.\n+  // limit. Verified with a compiler assert in .cpp.\n   const int pthread_attr_t_max_sz = 128;\n   union __sanitizer_pthread_attr_t {\n     char size[pthread_attr_t_max_sz]; // NOLINT\n@@ -611,11 +565,6 @@ namespace __sanitizer {\n     // The size is determined by looking at sizeof of real sigset_t on linux.\n     uptr val[128 / sizeof(uptr)];\n   };\n-#elif SANITIZER_FREEBSD\n-  struct __sanitizer_sigset_t {\n-     // uint32_t * 4\n-     unsigned int __bits[4];\n-  };\n #endif\n \n   struct __sanitizer_siginfo {\n@@ -705,9 +654,7 @@ namespace __sanitizer {\n   };\n #endif // !SANITIZER_ANDROID\n \n-#if SANITIZER_FREEBSD\n-  typedef __sanitizer_sigset_t __sanitizer_kernel_sigset_t;\n-#elif defined(__mips__)\n+#if defined(__mips__)\n   struct __sanitizer_kernel_sigset_t {\n     uptr sig[2];\n   };\n@@ -753,7 +700,7 @@ namespace __sanitizer {\n   extern int af_inet6;\n   uptr __sanitizer_in_addr_sz(int af);\n \n-#if SANITIZER_LINUX || SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n   struct __sanitizer_dl_phdr_info {\n     uptr dlpi_addr;\n     const char *dlpi_name;\n@@ -769,7 +716,7 @@ namespace __sanitizer {\n     int ai_family;\n     int ai_socktype;\n     int ai_protocol;\n-#if SANITIZER_ANDROID || SANITIZER_MAC || SANITIZER_FREEBSD\n+#if SANITIZER_ANDROID || SANITIZER_MAC\n     unsigned ai_addrlen;\n     char *ai_canonname;\n     void *ai_addr;\n@@ -795,7 +742,7 @@ namespace __sanitizer {\n     short revents;\n   };\n \n-#if SANITIZER_ANDROID || SANITIZER_MAC || SANITIZER_FREEBSD\n+#if SANITIZER_ANDROID || SANITIZER_MAC\n   typedef unsigned __sanitizer_nfds_t;\n #else\n   typedef unsigned long __sanitizer_nfds_t;\n@@ -815,23 +762,9 @@ namespace __sanitizer {\n     int (*gl_lstat)(const char *, void *);\n     int (*gl_stat)(const char *, void *);\n   };\n-# elif SANITIZER_FREEBSD\n-  struct __sanitizer_glob_t {\n-    uptr gl_pathc;\n-    uptr gl_matchc;\n-    uptr gl_offs;\n-    int gl_flags;\n-    char **gl_pathv;\n-    int (*gl_errfunc)(const char*, int);\n-    void (*gl_closedir)(void *dirp);\n-    struct dirent *(*gl_readdir)(void *dirp);\n-    void *(*gl_opendir)(const char*);\n-    int (*gl_lstat)(const char*, void* /* struct stat* */);\n-    int (*gl_stat)(const char*, void* /* struct stat* */);\n-  };\n-# endif  // SANITIZER_FREEBSD\n+# endif  // SANITIZER_LINUX\n \n-# if SANITIZER_LINUX || SANITIZER_FREEBSD\n+# if SANITIZER_LINUX\n   extern int glob_nomatch;\n   extern int glob_altdirfunc;\n # endif\n@@ -843,10 +776,6 @@ namespace __sanitizer {\n     uptr we_wordc;\n     char **we_wordv;\n     uptr we_offs;\n-#if SANITIZER_FREEBSD\n-    char *we_strings;\n-    uptr we_nbytes;\n-#endif\n   };\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n@@ -900,7 +829,7 @@ namespace __sanitizer {\n   extern int ptrace_geteventmsg;\n #endif\n \n-#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+#if SANITIZER_LINUX  && !SANITIZER_ANDROID\n   extern unsigned struct_shminfo_sz;\n   extern unsigned struct_shm_info_sz;\n   extern int shmctl_ipc_stat;\n@@ -1037,7 +966,7 @@ struct __sanitizer_cookie_io_functions_t {\n   extern unsigned struct_vt_stat_sz;\n #endif  // SANITIZER_LINUX\n \n-#if SANITIZER_LINUX || SANITIZER_FREEBSD\n+#if SANITIZER_LINUX\n   extern unsigned struct_copr_buffer_sz;\n   extern unsigned struct_copr_debug_buf_sz;\n   extern unsigned struct_copr_msg_sz;\n@@ -1049,7 +978,7 @@ struct __sanitizer_cookie_io_functions_t {\n   extern unsigned struct_seq_event_rec_sz;\n   extern unsigned struct_synth_info_sz;\n   extern unsigned struct_vt_mode_sz;\n-#endif // SANITIZER_LINUX || SANITIZER_FREEBSD\n+#endif // SANITIZER_LINUX\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n   extern unsigned struct_ax25_parms_struct_sz;\n@@ -1071,7 +1000,9 @@ struct __sanitizer_cookie_io_functions_t {\n   extern unsigned struct_unimapinit_sz;\n #endif  // SANITIZER_LINUX && !SANITIZER_ANDROID\n \n-#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+  extern const unsigned long __sanitizer_bufsiz;\n+\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n   extern unsigned struct_audio_buf_info_sz;\n   extern unsigned struct_ppp_stats_sz;\n #endif  // (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n@@ -1131,7 +1062,7 @@ struct __sanitizer_cookie_io_functions_t {\n   extern unsigned IOCTL_TIOCSPGRP;\n   extern unsigned IOCTL_TIOCSTI;\n   extern unsigned IOCTL_TIOCSWINSZ;\n-#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n   extern unsigned IOCTL_SIOCGETSGCNT;\n   extern unsigned IOCTL_SIOCGETVIFCNT;\n #endif\n@@ -1293,8 +1224,6 @@ struct __sanitizer_cookie_io_functions_t {\n   extern unsigned IOCTL_VT_RESIZE;\n   extern unsigned IOCTL_VT_RESIZEX;\n   extern unsigned IOCTL_VT_SENDSIG;\n-#endif  // SANITIZER_LINUX\n-#if SANITIZER_LINUX || SANITIZER_FREEBSD\n   extern unsigned IOCTL_MTIOCGET;\n   extern unsigned IOCTL_MTIOCTOP;\n   extern unsigned IOCTL_SIOCADDRT;\n@@ -1395,7 +1324,7 @@ struct __sanitizer_cookie_io_functions_t {\n   extern unsigned IOCTL_VT_RELDISP;\n   extern unsigned IOCTL_VT_SETMODE;\n   extern unsigned IOCTL_VT_WAITACTIVE;\n-#endif  // SANITIZER_LINUX || SANITIZER_FREEBSD\n+#endif  // SANITIZER_LINUX\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n   extern unsigned IOCTL_CYGETDEFTHRESH;\n@@ -1482,9 +1411,6 @@ struct __sanitizer_cookie_io_functions_t {\n   extern unsigned IOCTL_TIOCSERGETMULTI;\n   extern unsigned IOCTL_TIOCSERSETMULTI;\n   extern unsigned IOCTL_TIOCSSERIAL;\n-#endif  // SANITIZER_LINUX && !SANITIZER_ANDROID\n-\n-#if (SANITIZER_LINUX || SANITIZER_FREEBSD) && !SANITIZER_ANDROID\n   extern unsigned IOCTL_GIO_SCRNMAP;\n   extern unsigned IOCTL_KDDISABIO;\n   extern unsigned IOCTL_KDENABIO;\n@@ -1523,6 +1449,6 @@ struct __sanitizer_cookie_io_functions_t {\n \n #define SIGACTION_SYMNAME sigaction\n \n-#endif  // SANITIZER_FREEBSD || SANITIZER_LINUX || SANITIZER_MAC\n+#endif  // SANITIZER_LINUX || SANITIZER_MAC\n \n #endif"}, {"sha": "9717d98ebf1aa6f23a7fd09217661564b0c0e59c", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_solaris.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_platform_limits_solaris.cc ------------------------------===//\n+//===-- sanitizer_platform_limits_solaris.cpp -----------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_solaris.cc"}, {"sha": "ed3b7a04dff51379f17492346c9b3a5afb0cc9d0", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_solaris.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_solaris.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_platform_limits_solaris.h -------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -235,7 +236,7 @@ typedef long __sanitizer_clock_t;\n typedef int __sanitizer_clockid_t;\n \n // This thing depends on the platform. We are only interested in the upper\n-// limit. Verified with a compiler assert in .cc.\n+// limit. Verified with a compiler assert in .cpp.\n const int pthread_attr_t_max_sz = 128;\n union __sanitizer_pthread_attr_t {\n   char size[pthread_attr_t_max_sz]; // NOLINT"}, {"sha": "002bcb1eda4ab6f41fa3288bbe37912621dce1c3", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.cpp", "status": "renamed", "additions": 95, "deletions": 38, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_posix.cc ------------------------------------------------===//\n+//===-- sanitizer_posix.cpp -----------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -16,6 +17,7 @@\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_file.h\"\n+#include \"sanitizer_flags.h\"\n #include \"sanitizer_libc.h\"\n #include \"sanitizer_posix.h\"\n #include \"sanitizer_procmaps.h\"\n@@ -41,9 +43,8 @@ uptr GetMmapGranularity() {\n \n void *MmapOrDie(uptr size, const char *mem_type, bool raw_report) {\n   size = RoundUpTo(size, GetPageSizeCached());\n-  uptr res = internal_mmap(nullptr, size,\n-                           PROT_READ | PROT_WRITE,\n-                           MAP_PRIVATE | MAP_ANON, -1, 0);\n+  uptr res = MmapNamed(nullptr, size, PROT_READ | PROT_WRITE,\n+                       MAP_PRIVATE | MAP_ANON, mem_type);\n   int reserrno;\n   if (UNLIKELY(internal_iserror(res, &reserrno)))\n     ReportMmapFailureAndDie(size, mem_type, \"allocate\", reserrno, raw_report);\n@@ -64,9 +65,8 @@ void UnmapOrDie(void *addr, uptr size) {\n \n void *MmapOrDieOnFatalError(uptr size, const char *mem_type) {\n   size = RoundUpTo(size, GetPageSizeCached());\n-  uptr res = internal_mmap(nullptr, size,\n-                           PROT_READ | PROT_WRITE,\n-                           MAP_PRIVATE | MAP_ANON, -1, 0);\n+  uptr res = MmapNamed(nullptr, size, PROT_READ | PROT_WRITE,\n+                       MAP_PRIVATE | MAP_ANON, mem_type);\n   int reserrno;\n   if (UNLIKELY(internal_iserror(res, &reserrno))) {\n     if (reserrno == ENOMEM)\n@@ -101,26 +101,22 @@ void *MmapAlignedOrDieOnFatalError(uptr size, uptr alignment,\n }\n \n void *MmapNoReserveOrDie(uptr size, const char *mem_type) {\n-  uptr PageSize = GetPageSizeCached();\n-  uptr p = internal_mmap(nullptr,\n-                         RoundUpTo(size, PageSize),\n-                         PROT_READ | PROT_WRITE,\n-                         MAP_PRIVATE | MAP_ANON | MAP_NORESERVE,\n-                         -1, 0);\n+  size = RoundUpTo(size, GetPageSizeCached());\n+  uptr p = MmapNamed(nullptr, size, PROT_READ | PROT_WRITE,\n+                     MAP_PRIVATE | MAP_ANON | MAP_NORESERVE, mem_type);\n   int reserrno;\n   if (UNLIKELY(internal_iserror(p, &reserrno)))\n     ReportMmapFailureAndDie(size, mem_type, \"allocate noreserve\", reserrno);\n   IncreaseTotalMmap(size);\n   return (void *)p;\n }\n \n-void *MmapFixedImpl(uptr fixed_addr, uptr size, bool tolerate_enomem) {\n-  uptr PageSize = GetPageSizeCached();\n-  uptr p = internal_mmap((void*)(fixed_addr & ~(PageSize - 1)),\n-      RoundUpTo(size, PageSize),\n-      PROT_READ | PROT_WRITE,\n-      MAP_PRIVATE | MAP_ANON | MAP_FIXED,\n-      -1, 0);\n+static void *MmapFixedImpl(uptr fixed_addr, uptr size, bool tolerate_enomem,\n+                           const char *name) {\n+  size = RoundUpTo(size, GetPageSizeCached());\n+  fixed_addr = RoundDownTo(fixed_addr, GetPageSizeCached());\n+  uptr p = MmapNamed((void *)fixed_addr, size, PROT_READ | PROT_WRITE,\n+                     MAP_PRIVATE | MAP_ANON | MAP_FIXED, name);\n   int reserrno;\n   if (UNLIKELY(internal_iserror(p, &reserrno))) {\n     if (tolerate_enomem && reserrno == ENOMEM)\n@@ -134,12 +130,12 @@ void *MmapFixedImpl(uptr fixed_addr, uptr size, bool tolerate_enomem) {\n   return (void *)p;\n }\n \n-void *MmapFixedOrDie(uptr fixed_addr, uptr size) {\n-  return MmapFixedImpl(fixed_addr, size, false /*tolerate_enomem*/);\n+void *MmapFixedOrDie(uptr fixed_addr, uptr size, const char *name) {\n+  return MmapFixedImpl(fixed_addr, size, false /*tolerate_enomem*/, name);\n }\n \n-void *MmapFixedOrDieOnFatalError(uptr fixed_addr, uptr size) {\n-  return MmapFixedImpl(fixed_addr, size, true /*tolerate_enomem*/);\n+void *MmapFixedOrDieOnFatalError(uptr fixed_addr, uptr size, const char *name) {\n+  return MmapFixedImpl(fixed_addr, size, true /*tolerate_enomem*/, name);\n }\n \n bool MprotectNoAccess(uptr addr, uptr size) {\n@@ -155,6 +151,8 @@ void MprotectMallocZones(void *addr, int prot) {}\n #endif\n \n fd_t OpenFile(const char *filename, FileAccessMode mode, error_t *errno_p) {\n+  if (ShouldMockFailureToOpen(filename))\n+    return kInvalidFd;\n   int flags;\n   switch (mode) {\n     case RdOnly: flags = O_RDONLY; break;\n@@ -164,7 +162,7 @@ fd_t OpenFile(const char *filename, FileAccessMode mode, error_t *errno_p) {\n   fd_t res = internal_open(filename, flags, 0660);\n   if (internal_iserror(res, errno_p))\n     return kInvalidFd;\n-  return res;\n+  return ReserveStandardFds(res);\n }\n \n void CloseFile(fd_t fd) {\n@@ -191,11 +189,6 @@ bool WriteToFile(fd_t fd, const void *buff, uptr buff_size, uptr *bytes_written,\n   return true;\n }\n \n-bool RenameFile(const char *oldpath, const char *newpath, error_t *error_p) {\n-  uptr res = internal_rename(oldpath, newpath);\n-  return !internal_iserror(res, error_p);\n-}\n-\n void *MapFileToMemory(const char *file_name, uptr *buff_size) {\n   fd_t fd = OpenFile(file_name, RdOnly);\n   CHECK(fd != kInvalidFd);\n@@ -233,6 +226,8 @@ static inline bool IntervalsAreSeparate(uptr start1, uptr end1,\n // memory).\n bool MemoryRangeIsAvailable(uptr range_start, uptr range_end) {\n   MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n+  if (proc_maps.Error())\n+    return true; // and hope for the best\n   MemoryMappedSegment segment;\n   while (proc_maps.Next(&segment)) {\n     if (segment.start == segment.end) continue;  // Empty range.\n@@ -272,13 +267,8 @@ bool IsAbsolutePath(const char *path) {\n \n void ReportFile::Write(const char *buffer, uptr length) {\n   SpinMutexLock l(mu);\n-  static const char *kWriteError =\n-      \"ReportFile::Write() can't output requested buffer!\\n\";\n   ReopenIfNecessary();\n-  if (length != internal_write(fd, buffer, length)) {\n-    internal_write(fd, kWriteError, internal_strlen(kWriteError));\n-    Die();\n-  }\n+  internal_write(fd, buffer, length);\n }\n \n bool GetCodeRangeForFile(const char *module, uptr *start, uptr *end) {\n@@ -326,6 +316,73 @@ const char *SignalContext::Describe() const {\n   return \"UNKNOWN SIGNAL\";\n }\n \n+fd_t ReserveStandardFds(fd_t fd) {\n+  CHECK_GE(fd, 0);\n+  if (fd > 2)\n+    return fd;\n+  bool used[3];\n+  internal_memset(used, 0, sizeof(used));\n+  while (fd <= 2) {\n+    used[fd] = true;\n+    fd = internal_dup(fd);\n+  }\n+  for (int i = 0; i <= 2; ++i)\n+    if (used[i])\n+      internal_close(i);\n+  return fd;\n+}\n+\n+bool ShouldMockFailureToOpen(const char *path) {\n+  return common_flags()->test_only_emulate_no_memorymap &&\n+         internal_strncmp(path, \"/proc/\", 6) == 0;\n+}\n+\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID && !SANITIZER_GO\n+int GetNamedMappingFd(const char *name, uptr size, int *flags) {\n+  if (!common_flags()->decorate_proc_maps || !name)\n+    return -1;\n+  char shmname[200];\n+  CHECK(internal_strlen(name) < sizeof(shmname) - 10);\n+  internal_snprintf(shmname, sizeof(shmname), \"/dev/shm/%zu [%s]\",\n+                    internal_getpid(), name);\n+  int fd = ReserveStandardFds(\n+      internal_open(shmname, O_RDWR | O_CREAT | O_TRUNC | O_CLOEXEC, S_IRWXU));\n+  CHECK_GE(fd, 0);\n+  int res = internal_ftruncate(fd, size);\n+  CHECK_EQ(0, res);\n+  res = internal_unlink(shmname);\n+  CHECK_EQ(0, res);\n+  *flags &= ~(MAP_ANON | MAP_ANONYMOUS);\n+  return fd;\n+}\n+#else\n+int GetNamedMappingFd(const char *name, uptr size, int *flags) {\n+  return -1;\n+}\n+#endif\n+\n+#if SANITIZER_ANDROID\n+#define PR_SET_VMA 0x53564d41\n+#define PR_SET_VMA_ANON_NAME 0\n+void DecorateMapping(uptr addr, uptr size, const char *name) {\n+  if (!common_flags()->decorate_proc_maps || !name)\n+    return;\n+  internal_prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, addr, size, (uptr)name);\n+}\n+#else\n+void DecorateMapping(uptr addr, uptr size, const char *name) {\n+}\n+#endif\n+\n+uptr MmapNamed(void *addr, uptr length, int prot, int flags, const char *name) {\n+  int fd = GetNamedMappingFd(name, length, &flags);\n+  uptr res = internal_mmap(addr, length, prot, flags, fd, 0);\n+  if (!internal_iserror(res))\n+    DecorateMapping(res, length, name);\n+  return res;\n+}\n+\n+\n } // namespace __sanitizer\n \n #endif // SANITIZER_POSIX", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_posix.cc"}, {"sha": "6cf5ce75b12e8c681c56326951ae30391bedf725", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.h", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_posix.h -------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -14,6 +15,7 @@\n // ----------- ATTENTION -------------\n // This header should NOT include any other headers from sanitizer runtime.\n #include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_platform_limits_freebsd.h\"\n #include \"sanitizer_platform_limits_netbsd.h\"\n #include \"sanitizer_platform_limits_openbsd.h\"\n #include \"sanitizer_platform_limits_posix.h\"\n@@ -46,13 +48,18 @@ uptr internal_filesize(fd_t fd);  // -1 on error.\n uptr internal_stat(const char *path, void *buf);\n uptr internal_lstat(const char *path, void *buf);\n uptr internal_fstat(fd_t fd, void *buf);\n+uptr internal_dup(int oldfd);\n uptr internal_dup2(int oldfd, int newfd);\n uptr internal_readlink(const char *path, char *buf, uptr bufsize);\n uptr internal_unlink(const char *path);\n uptr internal_rename(const char *oldpath, const char *newpath);\n uptr internal_lseek(fd_t fd, OFF_T offset, int whence);\n \n+#if SANITIZER_NETBSD\n+uptr internal_ptrace(int request, int pid, void *addr, int data);\n+#else\n uptr internal_ptrace(int request, int pid, void *addr, void *data);\n+#endif\n uptr internal_waitpid(int pid, int *status, int options);\n \n int internal_fork();\n@@ -96,6 +103,23 @@ uptr internal_execve(const char *filename, char *const argv[],\n \n bool IsStateDetached(int state);\n \n+// Move the fd out of {0, 1, 2} range.\n+fd_t ReserveStandardFds(fd_t fd);\n+\n+bool ShouldMockFailureToOpen(const char *path);\n+\n+// Create a non-file mapping with a given /proc/self/maps name.\n+uptr MmapNamed(void *addr, uptr length, int prot, int flags, const char *name);\n+\n+// Platforms should implement at most one of these.\n+// 1. Provide a pre-decorated file descriptor to use instead of an anonymous\n+// mapping.\n+int GetNamedMappingFd(const char *name, uptr size, int *flags);\n+// 2. Add name to an existing anonymous mapping. The caller must keep *name\n+// alive at least as long as the mapping exists.\n+void DecorateMapping(uptr addr, uptr size, const char *name);\n+\n+\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_POSIX_H"}, {"sha": "1bbbf8a675fdfff76009d947139be0782429ee43", "filename": "libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cpp", "status": "renamed", "additions": 29, "deletions": 60, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_posix_libcdep.cc ----------------------------------------===//\n+//===-- sanitizer_posix_libcdep.cpp ---------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -67,11 +68,12 @@ void ReleaseMemoryPagesToOS(uptr beg, uptr end) {\n             SANITIZER_MADVISE_DONTNEED);\n }\n \n-bool NoHugePagesInRegion(uptr addr, uptr size) {\n+void SetShadowRegionHugePageMode(uptr addr, uptr size) {\n #ifdef MADV_NOHUGEPAGE  // May not be defined on old systems.\n-  return madvise((char *)addr, size, MADV_NOHUGEPAGE) == 0;\n-#else\n-  return true;\n+  if (common_flags()->no_huge_pages_for_shadow)\n+    madvise((char *)addr, size, MADV_NOHUGEPAGE);\n+  else\n+    madvise((char *)addr, size, MADV_HUGEPAGE);\n #endif  // MADV_NOHUGEPAGE\n }\n \n@@ -92,10 +94,12 @@ static rlim_t getlim(int res) {\n }\n \n static void setlim(int res, rlim_t lim) {\n-  // The following magic is to prevent clang from replacing it with memset.\n-  volatile struct rlimit rlim;\n+  struct rlimit rlim;\n+  if (getrlimit(res, const_cast<struct rlimit *>(&rlim))) {\n+    Report(\"ERROR: %s getrlimit() failed %d\\n\", SanitizerToolName, errno);\n+    Die();\n+  }\n   rlim.rlim_cur = lim;\n-  rlim.rlim_max = lim;\n   if (setrlimit(res, const_cast<struct rlimit *>(&rlim))) {\n     Report(\"ERROR: %s setrlimit() failed %d\\n\", SanitizerToolName, errno);\n     Die();\n@@ -113,10 +117,6 @@ bool StackSizeIsUnlimited() {\n   return (stack_size == RLIM_INFINITY);\n }\n \n-uptr GetStackSizeLimitInBytes() {\n-  return (uptr)getlim(RLIMIT_STACK);\n-}\n-\n void SetStackSizeLimitInBytes(uptr limit) {\n   setlim(RLIMIT_STACK, (rlim_t)limit);\n   CHECK(!StackSizeIsUnlimited());\n@@ -304,37 +304,11 @@ void PlatformPrepareForSandboxing(__sanitizer_sandbox_arguments *args) {\n   MemoryMappingLayout::CacheMemoryMappings();\n }\n \n-#if SANITIZER_ANDROID || SANITIZER_GO\n-int GetNamedMappingFd(const char *name, uptr size) {\n-  return -1;\n-}\n-#else\n-int GetNamedMappingFd(const char *name, uptr size) {\n-  if (!common_flags()->decorate_proc_maps)\n-    return -1;\n-  char shmname[200];\n-  CHECK(internal_strlen(name) < sizeof(shmname) - 10);\n-  internal_snprintf(shmname, sizeof(shmname), \"%zu [%s]\", internal_getpid(),\n-                    name);\n-  int fd = shm_open(shmname, O_RDWR | O_CREAT | O_TRUNC, S_IRWXU);\n-  CHECK_GE(fd, 0);\n-  int res = internal_ftruncate(fd, size);\n-  CHECK_EQ(0, res);\n-  res = shm_unlink(shmname);\n-  CHECK_EQ(0, res);\n-  return fd;\n-}\n-#endif\n-\n bool MmapFixedNoReserve(uptr fixed_addr, uptr size, const char *name) {\n-  int fd = name ? GetNamedMappingFd(name, size) : -1;\n-  unsigned flags = MAP_PRIVATE | MAP_FIXED | MAP_NORESERVE;\n-  if (fd == -1) flags |= MAP_ANON;\n-\n-  uptr PageSize = GetPageSizeCached();\n-  uptr p = internal_mmap((void *)(fixed_addr & ~(PageSize - 1)),\n-                         RoundUpTo(size, PageSize), PROT_READ | PROT_WRITE,\n-                         flags, fd, 0);\n+  size = RoundUpTo(size, GetPageSizeCached());\n+  fixed_addr = RoundDownTo(fixed_addr, GetPageSizeCached());\n+  uptr p = MmapNamed((void *)fixed_addr, size, PROT_READ | PROT_WRITE,\n+                     MAP_PRIVATE | MAP_FIXED | MAP_NORESERVE | MAP_ANON, name);\n   int reserrno;\n   if (internal_iserror(p, &reserrno)) {\n     Report(\"ERROR: %s failed to \"\n@@ -347,12 +321,8 @@ bool MmapFixedNoReserve(uptr fixed_addr, uptr size, const char *name) {\n }\n \n uptr ReservedAddressRange::Init(uptr size, const char *name, uptr fixed_addr) {\n-  // We don't pass `name` along because, when you enable `decorate_proc_maps`\n-  // AND actually use a named mapping AND are using a sanitizer intercepting\n-  // `open` (e.g. TSAN, ESAN), then you'll get a failure during initialization.\n-  // TODO(flowerhack): Fix the implementation of GetNamedMappingFd to solve\n-  // this problem.\n-  base_ = fixed_addr ? MmapFixedNoAccess(fixed_addr, size) : MmapNoAccess(size);\n+  base_ = fixed_addr ? MmapFixedNoAccess(fixed_addr, size, name)\n+                     : MmapNoAccess(size);\n   size_ = size;\n   name_ = name;\n   (void)os_handle_;  // unsupported\n@@ -361,12 +331,14 @@ uptr ReservedAddressRange::Init(uptr size, const char *name, uptr fixed_addr) {\n \n // Uses fixed_addr for now.\n // Will use offset instead once we've implemented this function for real.\n-uptr ReservedAddressRange::Map(uptr fixed_addr, uptr size) {\n-  return reinterpret_cast<uptr>(MmapFixedOrDieOnFatalError(fixed_addr, size));\n+uptr ReservedAddressRange::Map(uptr fixed_addr, uptr size, const char *name) {\n+  return reinterpret_cast<uptr>(\n+      MmapFixedOrDieOnFatalError(fixed_addr, size, name));\n }\n \n-uptr ReservedAddressRange::MapOrDie(uptr fixed_addr, uptr size) {\n-  return reinterpret_cast<uptr>(MmapFixedOrDie(fixed_addr, size));\n+uptr ReservedAddressRange::MapOrDie(uptr fixed_addr, uptr size,\n+                                    const char *name) {\n+  return reinterpret_cast<uptr>(MmapFixedOrDie(fixed_addr, size, name));\n }\n \n void ReservedAddressRange::Unmap(uptr addr, uptr size) {\n@@ -381,12 +353,9 @@ void ReservedAddressRange::Unmap(uptr addr, uptr size) {\n }\n \n void *MmapFixedNoAccess(uptr fixed_addr, uptr size, const char *name) {\n-  int fd = name ? GetNamedMappingFd(name, size) : -1;\n-  unsigned flags = MAP_PRIVATE | MAP_FIXED | MAP_NORESERVE;\n-  if (fd == -1) flags |= MAP_ANON;\n-\n-  return (void *)internal_mmap((void *)fixed_addr, size, PROT_NONE, flags, fd,\n-                               0);\n+  return (void *)MmapNamed((void *)fixed_addr, size, PROT_NONE,\n+                           MAP_PRIVATE | MAP_FIXED | MAP_NORESERVE | MAP_ANON,\n+                           name);\n }\n \n void *MmapNoAccess(uptr size) {", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cc"}, {"sha": "9d1c544786d34f621a3cfddba0c4c36769fe8f28", "filename": "libsanitizer/sanitizer_common/sanitizer_printf.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_printf.cc -----------------------------------------------===//\n+//===-- sanitizer_printf.cpp ----------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_printf.cc"}, {"sha": "052027111ceb4b8546fae102f5c807a197cb3876", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_procmaps.h ------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -68,6 +69,7 @@ class MemoryMappingLayout {\n   explicit MemoryMappingLayout(bool cache_enabled);\n   ~MemoryMappingLayout();\n   bool Next(MemoryMappedSegment *segment);\n+  bool Error() const;\n   void Reset();\n   // In some cases, e.g. when running under a sandbox on Linux, ASan is unable\n   // to obtain the memory mappings. It should fall back to pre-cached data"}, {"sha": "02ff7c0e91a865c804a68cfd119b362609383e70", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_bsd.cpp", "status": "renamed", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_bsd.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_bsd.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_bsd.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_procmaps_bsd.cc -----------------------------------------===//\n+//===-- sanitizer_procmaps_bsd.cpp ----------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -97,6 +98,7 @@ void ReadProcMaps(ProcSelfMapsBuff *proc_maps) {\n }\n \n bool MemoryMappingLayout::Next(MemoryMappedSegment *segment) {\n+  CHECK(!Error()); // can not fail\n   char *last = data_.proc_self_maps.data + data_.proc_self_maps.len;\n   if (data_.current >= last)\n     return false;", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_bsd.cc"}, {"sha": "e0cb47f8ca9a121351a3070b5ed2c3689e1e3b99", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_common.cpp", "status": "renamed", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_common.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_common.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_common.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_procmaps_common.cc --------------------------------------===//\n+//===-- sanitizer_procmaps_common.cpp -------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -78,12 +79,14 @@ MemoryMappingLayout::MemoryMappingLayout(bool cache_enabled) {\n   ReadProcMaps(&data_.proc_self_maps);\n   if (cache_enabled && data_.proc_self_maps.mmaped_size == 0)\n     LoadFromCache();\n-  CHECK_GT(data_.proc_self_maps.mmaped_size, 0);\n-  CHECK_GT(data_.proc_self_maps.len, 0);\n \n   Reset();\n }\n \n+bool MemoryMappingLayout::Error() const {\n+  return data_.current == nullptr;\n+}\n+\n MemoryMappingLayout::~MemoryMappingLayout() {\n   // Only unmap the buffer if it is different from the cached one. Otherwise\n   // it will be unmapped when the cache is refreshed.", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_common.cc"}, {"sha": "c7af57355b91a7bdd49bbe45b15113fb6fd3eedb", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_linux.cpp", "status": "renamed", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_linux.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_procmaps_linux.cc ---------------------------------------===//\n+//===-- sanitizer_procmaps_linux.cpp --------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -29,6 +30,7 @@ static bool IsOneOf(char c, char c1, char c2) {\n }\n \n bool MemoryMappingLayout::Next(MemoryMappedSegment *segment) {\n+  if (Error()) return false; // simulate empty maps\n   char *last = data_.proc_self_maps.data + data_.proc_self_maps.len;\n   if (data_.current >= last) return false;\n   char *next_line =", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_linux.cc"}, {"sha": "ea72a57bf3cb4a6b7f2c4a466a8fea0740dfcf82", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_mac.cpp", "status": "renamed", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_procmaps_mac.cc -----------------------------------------===//\n+//===-- sanitizer_procmaps_mac.cpp ----------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -86,6 +87,10 @@ MemoryMappingLayout::MemoryMappingLayout(bool cache_enabled) {\n MemoryMappingLayout::~MemoryMappingLayout() {\n }\n \n+bool MemoryMappingLayout::Error() const {\n+  return false;\n+}\n+\n // More information about Mach-O headers can be found in mach-o/loader.h\n // Each Mach-O image has a header (mach_header or mach_header_64) starting with\n // a magic number, and a list of linker load commands directly following the", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_mac.cc"}, {"sha": "8793423a60178b79454d5a648ba28027a6feedd9", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_solaris.cpp", "status": "renamed", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_solaris.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_solaris.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_solaris.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_procmaps_solaris.cc -------------------------------------===//\n+//===-- sanitizer_procmaps_solaris.cpp ------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -21,11 +22,16 @@\n namespace __sanitizer {\n \n void ReadProcMaps(ProcSelfMapsBuff *proc_maps) {\n-  ReadFileToBuffer(\"/proc/self/xmap\", &proc_maps->data, &proc_maps->mmaped_size,\n-                   &proc_maps->len);\n+  if (!ReadFileToBuffer(\"/proc/self/xmap\", &proc_maps->data,\n+                        &proc_maps->mmaped_size, &proc_maps->len)) {\n+    proc_maps->data = nullptr;\n+    proc_maps->mmaped_size = 0;\n+    proc_maps->len = 0;\n+  }\n }\n \n bool MemoryMappingLayout::Next(MemoryMappedSegment *segment) {\n+  if (Error()) return false; // simulate empty maps\n   char *last = data_.proc_self_maps.data + data_.proc_self_maps.len;\n   if (data_.current >= last) return false;\n \n@@ -44,9 +50,11 @@ bool MemoryMappingLayout::Next(MemoryMappedSegment *segment) {\n     segment->protection |= kProtectionExecute;\n \n   if (segment->filename != NULL && segment->filename_size > 0) {\n-    internal_snprintf(segment->filename,\n-                      Min(segment->filename_size, (uptr)PATH_MAX), \"%s\",\n+    char proc_path[PATH_MAX + 1];\n+\n+    internal_snprintf(proc_path, sizeof(proc_path), \"/proc/self/path/%s\",\n                       xmapentry->pr_mapname);\n+    internal_readlink(proc_path, segment->filename, segment->filename_size);\n   }\n \n   data_.current += sizeof(prxmap_t);", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_solaris.cc"}, {"sha": "992f23152c6aebe506d272b5e42da89c15fdff27", "filename": "libsanitizer/sanitizer_common/sanitizer_quarantine.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_quarantine.h ----------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "d276c2cdd84d91a962802444c4777b6f1d01bd0d", "filename": "libsanitizer/sanitizer_common/sanitizer_report_decorator.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_report_decorator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_report_decorator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_report_decorator.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_report_decorator.h ----------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "2a46e933b75d07ed9155c37901228e7aa88fed58", "filename": "libsanitizer/sanitizer_common/sanitizer_ring_buffer.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_ring_buffer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_ring_buffer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_ring_buffer.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_ring_buffer.h ---------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -138,7 +139,7 @@ class CompactRingBuffer {\n     SetNext(next);\n   }\n \n-  T operator[](uptr Idx) const {\n+  const T &operator[](uptr Idx) const {\n     CHECK_LT(Idx, size());\n     const T *Begin = (const T *)StartOfStorage();\n     sptr StorageIdx = Next() - Begin;"}, {"sha": "0d2576c00ab3c8d34c0f3ac8eb8984e5b49b586d", "filename": "libsanitizer/sanitizer_common/sanitizer_rtems.cpp", "status": "renamed", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_rtems.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_rtems.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_rtems.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_rtems.cc ------------------------------------------------===//\n+//===-- sanitizer_rtems.cpp -----------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -93,8 +94,10 @@ void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n   *tls_addr = *tls_size = 0;\n }\n \n+void InitializePlatformEarly() {}\n void MaybeReexec() {}\n void CheckASLR() {}\n+void CheckMPROTECT() {}\n void DisableCoreDumperIfNecessary() {}\n void InstallDeadlySignalHandlers(SignalHandlerType handler) {}\n void SetAlternateSignalStack() {}\n@@ -224,11 +227,6 @@ bool WriteToFile(fd_t fd, const void *buff, uptr buff_size, uptr *bytes_written,\n   return true;\n }\n \n-bool RenameFile(const char *oldpath, const char *newpath, error_t *error_p) {\n-  uptr res = rename(oldpath, newpath);\n-  return !internal_iserror(res, error_p);\n-}\n-\n void ReleaseMemoryPagesToOS(uptr beg, uptr end) {}\n void DumpProcessMap() {}\n \n@@ -238,6 +236,7 @@ bool IsAccessibleMemoryRange(uptr beg, uptr size) {\n }\n \n char **GetArgv() { return nullptr; }\n+char **GetEnviron() { return nullptr; }\n \n const char *GetEnv(const char *name) {\n   return getenv(name);", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_rtems.cc"}, {"sha": "e8adfd500dffa8f52c3bf4ad35c175001f9d80cf", "filename": "libsanitizer/sanitizer_common/sanitizer_rtems.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_rtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_rtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_rtems.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_rtems.h ---------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "68d9eb65968dd391dee4d155d79a61d87ed74c54", "filename": "libsanitizer/sanitizer_common/sanitizer_signal_interceptors.inc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_signal_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_signal_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_signal_interceptors.inc?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_signal_interceptors.inc -----------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "035f2d0ca292ada96c7e2f76296bfd0d89ca6bb4", "filename": "libsanitizer/sanitizer_common/sanitizer_solaris.cpp", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_solaris.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_solaris.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_solaris.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_solaris.cc ----------------------------------------------===//\n+//===-- sanitizer_solaris.cpp ---------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -87,11 +88,6 @@ uptr internal_open(const char *filename, int flags, u32 mode) {\n   return _REAL64(open)(filename, flags, mode);\n }\n \n-uptr OpenFile(const char *filename, bool write) {\n-  return internal_open(filename,\n-      write ? O_WRONLY | O_CREAT : O_RDONLY, 0660);\n-}\n-\n DECLARE__REAL_AND_INTERNAL(uptr, read, fd_t fd, void *buf, uptr count) {\n   return _REAL(read)(fd, buf, count);\n }\n@@ -124,6 +120,10 @@ uptr internal_filesize(fd_t fd) {\n   return (uptr)st.st_size;\n }\n \n+DECLARE__REAL_AND_INTERNAL(uptr, dup, int oldfd) {\n+  return _REAL(dup)(oldfd);\n+}\n+\n DECLARE__REAL_AND_INTERNAL(uptr, dup2, int oldfd, int newfd) {\n   return _REAL(dup2)(oldfd, newfd);\n }", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_solaris.cc"}, {"sha": "30073a96ceebd7fa850b8dcf9e40557f1ddbffa1", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepot.cpp", "status": "renamed", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_stackdepot.cc -------------------------------------------===//\n+//===-- sanitizer_stackdepot.cpp ------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -12,6 +13,7 @@\n #include \"sanitizer_stackdepot.h\"\n \n #include \"sanitizer_common.h\"\n+#include \"sanitizer_hash.h\"\n #include \"sanitizer_stackdepotbase.h\"\n \n namespace __sanitizer {\n@@ -24,7 +26,7 @@ struct StackDepotNode {\n   u32 tag;\n   uptr stack[1];  // [size]\n \n-  static const u32 kTabSizeLog = 20;\n+  static const u32 kTabSizeLog = SANITIZER_ANDROID ? 16 : 20;\n   // Lower kTabSizeLog bits are equal for all items in one bucket.\n   // We use these bits to store the per-stack use counter.\n   static const u32 kUseCountBits = kTabSizeLog;\n@@ -48,23 +50,9 @@ struct StackDepotNode {\n     return sizeof(StackDepotNode) + (args.size - 1) * sizeof(uptr);\n   }\n   static u32 hash(const args_type &args) {\n-    // murmur2\n-    const u32 m = 0x5bd1e995;\n-    const u32 seed = 0x9747b28c;\n-    const u32 r = 24;\n-    u32 h = seed ^ (args.size * sizeof(uptr));\n-    for (uptr i = 0; i < args.size; i++) {\n-      u32 k = args.trace[i];\n-      k *= m;\n-      k ^= k >> r;\n-      k *= m;\n-      h *= m;\n-      h ^= k;\n-    }\n-    h ^= h >> 13;\n-    h *= m;\n-    h ^= h >> 15;\n-    return h;\n+    MurMur2HashBuilder H(args.size * sizeof(uptr));\n+    for (uptr i = 0; i < args.size; i++) H.add(args.trace[i]);\n+    return H.get();\n   }\n   static bool is_valid(const args_type &args) {\n     return args.size > 0 && args.trace;", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_stackdepot.cc"}, {"sha": "bf29cb9a006e937f21ee976fff418faec49055b2", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepot.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_stackdepot.h ----------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -30,7 +31,7 @@ struct StackDepotHandle {\n   void inc_use_count_unsafe();\n };\n \n-const int kStackDepotMaxUseCount = 1U << 20;\n+const int kStackDepotMaxUseCount = 1U << (SANITIZER_ANDROID ? 16 : 20);\n \n StackDepotStats *StackDepotGetStats();\n u32 StackDepotPut(StackTrace stack);"}, {"sha": "ef1b4f7f70555545cdf6778f1c5b899b26e8fd4f", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepotbase.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepotbase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepotbase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepotbase.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_stackdepotbase.h ------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "ef14fb704eed394acf0be36505eaae5f952fa6d2", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cpp", "status": "renamed", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_stacktrace.cc -------------------------------------------===//\n+//===-- sanitizer_stacktrace.cpp ------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -47,6 +48,7 @@ void BufferedStackTrace::Init(const uptr *pcs, uptr cnt, uptr extra_top_pc) {\n static inline uhwptr *GetCanonicFrame(uptr bp,\n                                       uptr stack_top,\n                                       uptr stack_bottom) {\n+  CHECK_GT(stack_top, stack_bottom);\n #ifdef __arm__\n   if (!IsValidFrame(bp, stack_top, stack_bottom)) return 0;\n   uhwptr *bp_prev = (uhwptr *)bp;\n@@ -58,17 +60,18 @@ static inline uhwptr *GetCanonicFrame(uptr bp,\n   // Nope, this does not look right either. This means the frame after next does\n   // not have a valid frame pointer, but we can still extract the caller PC.\n   // Unfortunately, there is no way to decide between GCC and LLVM frame\n-  // layouts. Assume GCC.\n-  return bp_prev - 1;\n+  // layouts. Assume LLVM.\n+  return bp_prev;\n #else\n   return (uhwptr*)bp;\n #endif\n }\n \n-void BufferedStackTrace::FastUnwindStack(uptr pc, uptr bp, uptr stack_top,\n-                                         uptr stack_bottom, u32 max_depth) {\n-  const uptr kPageSize = GetPageSizeCached();\n+void BufferedStackTrace::UnwindFast(uptr pc, uptr bp, uptr stack_top,\n+                                    uptr stack_bottom, u32 max_depth) {\n+  // TODO(yln): add arg sanity check for stack_top/stack_bottom\n   CHECK_GE(max_depth, 2);\n+  const uptr kPageSize = GetPageSizeCached();\n   trace_buffer[0] = pc;\n   size = 1;\n   if (stack_top < 4096) return;  // Sanity check for stack top.\n@@ -81,21 +84,14 @@ void BufferedStackTrace::FastUnwindStack(uptr pc, uptr bp, uptr stack_top,\n          IsAligned((uptr)frame, sizeof(*frame)) &&\n          size < max_depth) {\n #ifdef __powerpc__\n-    // PowerPC ABIs specify that the return address is saved on the\n-    // *caller's* stack frame.  Thus we must dereference the back chain\n-    // to find the caller frame before extracting it.\n+    // PowerPC ABIs specify that the return address is saved at offset\n+    // 16 of the *caller's* stack frame.  Thus we must dereference the\n+    // back chain to find the caller frame before extracting it.\n     uhwptr *caller_frame = (uhwptr*)frame[0];\n     if (!IsValidFrame((uptr)caller_frame, stack_top, bottom) ||\n         !IsAligned((uptr)caller_frame, sizeof(uhwptr)))\n       break;\n-    // For most ABIs the offset where the return address is saved is two\n-    // register sizes.  The exception is the SVR4 ABI, which uses an\n-    // offset of only one register size.\n-#ifdef _CALL_SYSV\n-    uhwptr pc1 = caller_frame[1];\n-#else\n     uhwptr pc1 = caller_frame[2];\n-#endif\n #elif defined(__s390__)\n     uhwptr pc1 = frame[14];\n #else", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cc"}, {"sha": "f1f29e9f32ee811ac771ab6d56e9e1a565c7d0bd", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.h", "status": "modified", "additions": 45, "deletions": 16, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_stacktrace.h ----------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -15,6 +16,8 @@\n \n namespace __sanitizer {\n \n+struct BufferedStackTrace;\n+\n static const u32 kStackTraceMax = 256;\n \n #if SANITIZER_LINUX && defined(__mips__)\n@@ -57,7 +60,7 @@ struct StackTrace {\n   static bool WillUseFastUnwind(bool request_fast_unwind) {\n     if (!SANITIZER_CAN_FAST_UNWIND)\n       return false;\n-    else if (!SANITIZER_CAN_SLOW_UNWIND)\n+    if (!SANITIZER_CAN_SLOW_UNWIND)\n       return true;\n     return request_fast_unwind;\n   }\n@@ -95,6 +98,23 @@ struct BufferedStackTrace : public StackTrace {\n   BufferedStackTrace() : StackTrace(trace_buffer, 0), top_frame_bp(0) {}\n \n   void Init(const uptr *pcs, uptr cnt, uptr extra_top_pc = 0);\n+\n+  // Get the stack trace with the given pc and bp.\n+  // The pc will be in the position 0 of the resulting stack trace.\n+  // The bp may refer to the current frame or to the caller's frame.\n+  void Unwind(uptr pc, uptr bp, void *context, bool request_fast,\n+              u32 max_depth = kStackTraceMax) {\n+    top_frame_bp = (max_depth > 0) ? bp : 0;\n+    // Small max_depth optimization\n+    if (max_depth <= 1) {\n+      if (max_depth == 1)\n+        trace_buffer[0] = pc;\n+      size = max_depth;\n+      return;\n+    }\n+    UnwindImpl(pc, bp, context, request_fast, max_depth);\n+  }\n+\n   void Unwind(u32 max_depth, uptr pc, uptr bp, void *context, uptr stack_top,\n               uptr stack_bottom, bool request_fast_unwind);\n \n@@ -104,16 +124,23 @@ struct BufferedStackTrace : public StackTrace {\n   }\n \n  private:\n-  void FastUnwindStack(uptr pc, uptr bp, uptr stack_top, uptr stack_bottom,\n-                       u32 max_depth);\n-  void SlowUnwindStack(uptr pc, u32 max_depth);\n-  void SlowUnwindStackWithContext(uptr pc, void *context,\n-                                  u32 max_depth);\n+  // Every runtime defines its own implementation of this method\n+  void UnwindImpl(uptr pc, uptr bp, void *context, bool request_fast,\n+                  u32 max_depth);\n+\n+  // UnwindFast/Slow have platform-specific implementations\n+  void UnwindFast(uptr pc, uptr bp, uptr stack_top, uptr stack_bottom,\n+                  u32 max_depth);\n+  void UnwindSlow(uptr pc, u32 max_depth);\n+  void UnwindSlow(uptr pc, void *context, u32 max_depth);\n+\n   void PopStackFrames(uptr count);\n   uptr LocatePcInTrace(uptr pc);\n \n   BufferedStackTrace(const BufferedStackTrace &) = delete;\n   void operator=(const BufferedStackTrace &) = delete;\n+\n+  friend class FastUnwindTest;\n };\n \n // Check if given pointer points into allocated stack area.\n@@ -125,21 +152,23 @@ static inline bool IsValidFrame(uptr frame, uptr stack_top, uptr stack_bottom) {\n \n // Use this macro if you want to print stack trace with the caller\n // of the current function in the top frame.\n-#define GET_CALLER_PC_BP_SP \\\n-  uptr bp = GET_CURRENT_FRAME();              \\\n-  uptr pc = GET_CALLER_PC();                  \\\n-  uptr local_stack;                           \\\n-  uptr sp = (uptr)&local_stack\n-\n #define GET_CALLER_PC_BP \\\n   uptr bp = GET_CURRENT_FRAME();              \\\n   uptr pc = GET_CALLER_PC();\n \n+#define GET_CALLER_PC_BP_SP \\\n+  GET_CALLER_PC_BP;                           \\\n+  uptr local_stack;                           \\\n+  uptr sp = (uptr)&local_stack\n+\n // Use this macro if you want to print stack trace with the current\n // function in the top frame.\n-#define GET_CURRENT_PC_BP_SP \\\n+#define GET_CURRENT_PC_BP \\\n   uptr bp = GET_CURRENT_FRAME();              \\\n-  uptr pc = StackTrace::GetCurrentPc();   \\\n+  uptr pc = StackTrace::GetCurrentPc()\n+\n+#define GET_CURRENT_PC_BP_SP \\\n+  GET_CURRENT_PC_BP;                          \\\n   uptr local_stack;                           \\\n   uptr sp = (uptr)&local_stack\n "}, {"sha": "2c08274f35cdce65f7cbba6a067e24011f9b673f", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_libcdep.cpp", "status": "renamed", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_stacktrace_libcdep.cc -----------------------------------===//\n+//===-- sanitizer_stacktrace_libcdep.cpp ----------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -56,6 +57,8 @@ void StackTrace::Print() const {\n void BufferedStackTrace::Unwind(u32 max_depth, uptr pc, uptr bp, void *context,\n                                 uptr stack_top, uptr stack_bottom,\n                                 bool request_fast_unwind) {\n+  // Ensures all call sites get what they requested.\n+  CHECK_EQ(request_fast_unwind, WillUseFastUnwind(request_fast_unwind));\n   top_frame_bp = (max_depth > 0) ? bp : 0;\n   // Avoid doing any work for small max_depth.\n   if (max_depth == 0) {\n@@ -70,14 +73,14 @@ void BufferedStackTrace::Unwind(u32 max_depth, uptr pc, uptr bp, void *context,\n   if (!WillUseFastUnwind(request_fast_unwind)) {\n #if SANITIZER_CAN_SLOW_UNWIND\n     if (context)\n-      SlowUnwindStackWithContext(pc, context, max_depth);\n+      UnwindSlow(pc, context, max_depth);\n     else\n-      SlowUnwindStack(pc, max_depth);\n+      UnwindSlow(pc, max_depth);\n #else\n     UNREACHABLE(\"slow unwind requested but not available\");\n #endif\n   } else {\n-    FastUnwindStack(pc, bp, stack_top, stack_bottom, max_depth);\n+    UnwindFast(pc, bp, stack_top, stack_bottom, max_depth);\n   }\n }\n ", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_libcdep.cc"}, {"sha": "150ff475316bd8293518d3798716bb47cb4e72f7", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_printer.cpp", "status": "renamed", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_common.cc -----------------------------------------------===//\n+//===-- sanitizer_common.cpp ----------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -15,7 +16,7 @@\n \n namespace __sanitizer {\n \n-// sanitizer_symbolizer_markup.cc implements these differently.\n+// sanitizer_symbolizer_markup.cpp implements these differently.\n #if !SANITIZER_SYMBOLIZER_MARKUP\n \n static const char *StripFunctionName(const char *function, const char *prefix) {\n@@ -96,6 +97,8 @@ static const char *DemangleFunctionName(const char *function) {\n     return \"pthread_equal\";\n   if (!internal_strcmp(function, \"__libc_thr_curcpu\"))\n     return \"pthread_curcpu_np\";\n+  if (!internal_strcmp(function, \"__libc_thr_sigsetmask\"))\n+    return \"pthread_sigmask\";\n #endif\n \n   return function;", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_printer.cc"}, {"sha": "f7f7629f773f9f111672422bfa8132e4de1528fd", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_printer.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_stacktrace_printer.h --------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "34190fb1bbb201f3d2eab24c84f9d9da234908cb", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_sparc.cpp", "status": "renamed", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_sparc.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_sparc.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_sparc.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_stacktrace_sparc.cc -------------------------------------===//\n+//===-- sanitizer_stacktrace_sparc.cpp ------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -24,10 +25,11 @@\n \n namespace __sanitizer {\n \n-void BufferedStackTrace::FastUnwindStack(uptr pc, uptr bp, uptr stack_top,\n-                                         uptr stack_bottom, u32 max_depth) {\n-  const uptr kPageSize = GetPageSizeCached();\n+void BufferedStackTrace::UnwindFast(uptr pc, uptr bp, uptr stack_top,\n+                                    uptr stack_bottom, u32 max_depth) {\n+  // TODO(yln): add arg sanity check for stack_top/stack_bottom\n   CHECK_GE(max_depth, 2);\n+  const uptr kPageSize = GetPageSizeCached();\n #if defined(__GNUC__)\n   // __builtin_return_address returns the address of the call instruction\n   // on the SPARC and not the return address, so we need to compensate.\n@@ -50,20 +52,17 @@ void BufferedStackTrace::FastUnwindStack(uptr pc, uptr bp, uptr stack_top,\n   uptr prev_bp = GET_CURRENT_FRAME();\n   uptr next_bp = prev_bp;\n   unsigned int i = 0;\n-  while (next_bp != bp &&\n-\t IsAligned(next_bp, sizeof(uhwptr)) &&\n-\t i++ < 8) {\n+  while (next_bp != bp && IsAligned(next_bp, sizeof(uhwptr)) && i++ < 8) {\n     prev_bp = next_bp;\n-    next_bp = (uptr) ((uhwptr *) next_bp)[14] + STACK_BIAS;\n+    next_bp = (uptr)((uhwptr *)next_bp)[14] + STACK_BIAS;\n   }\n   if (next_bp == bp)\n     bp = prev_bp;\n   // Lowest possible address that makes sense as the next frame pointer.\n   // Goes up as we walk the stack.\n   uptr bottom = stack_bottom;\n   // Avoid infinite loop when frame == frame[0] by using frame > prev_frame.\n-  while (IsValidFrame(bp, stack_top, bottom) &&\n-         IsAligned(bp, sizeof(uhwptr)) &&\n+  while (IsValidFrame(bp, stack_top, bottom) && IsAligned(bp, sizeof(uhwptr)) &&\n          size < max_depth) {\n     uhwptr pc1 = ((uhwptr *)bp)[15];\n     // Let's assume that any pointer in the 0th page is invalid and\n@@ -74,10 +73,10 @@ void BufferedStackTrace::FastUnwindStack(uptr pc, uptr bp, uptr stack_top,\n     if (pc1 != pc) {\n       // %o7 contains the address of the call instruction and not the\n       // return address, so we need to compensate.\n-      trace_buffer[size++] = GetNextInstructionPc((uptr) pc1);\n+      trace_buffer[size++] = GetNextInstructionPc((uptr)pc1);\n     }\n     bottom = bp;\n-    bp = (uptr) ((uhwptr *) bp)[14] + STACK_BIAS;\n+    bp = (uptr)((uhwptr *)bp)[14] + STACK_BIAS;\n   }\n }\n ", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_sparc.cc"}, {"sha": "4e42400571423f82d31455d022616821688925e6", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_stoptheworld.h --------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "b520dc8daca6a787162458115c35f4044b5430f6", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_stoptheworld_linux_libcdep.cc ---------------------------===//\n+//===-- sanitizer_stoptheworld_linux_libcdep.cpp --------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cc"}, {"sha": "9dffd21ecb7cc52668b4c860c70eebc92c6a2bb3", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_mac.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_mac.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_stoptheworld_mac.cc -------------------------------------===//\n+//===-- sanitizer_stoptheworld_mac.cpp ------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_mac.cc"}, {"sha": "5690d75097f94bfb9caf318fa7f9052ec6533457", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_netbsd_libcdep.cpp", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_netbsd_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_netbsd_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_netbsd_libcdep.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -0,0 +1,356 @@\n+//===-- sanitizer_stoptheworld_netbsd_libcdep.cpp -------------------------===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// See sanitizer_stoptheworld.h for details.\n+// This implementation was inspired by Markus Gutschke's linuxthreads.cc.\n+//\n+// This is a NetBSD variation of Linux stoptheworld implementation\n+// See sanitizer_stoptheworld_linux_libcdep.cpp for code comments.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+\n+#if SANITIZER_NETBSD\n+\n+#include \"sanitizer_stoptheworld.h\"\n+\n+#include \"sanitizer_atomic.h\"\n+#include \"sanitizer_platform_limits_posix.h\"\n+\n+#include <sys/types.h>\n+\n+#include <sys/ptrace.h>\n+#include <sys/uio.h>\n+#include <sys/wait.h>\n+\n+#include <machine/reg.h>\n+\n+#include <elf.h>\n+#include <errno.h>\n+#include <sched.h>\n+#include <signal.h>\n+#include <stddef.h>\n+\n+#define internal_sigaction_norestorer internal_sigaction\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_flags.h\"\n+#include \"sanitizer_libc.h\"\n+#include \"sanitizer_linux.h\"\n+#include \"sanitizer_mutex.h\"\n+#include \"sanitizer_placement_new.h\"\n+\n+namespace __sanitizer {\n+\n+class SuspendedThreadsListNetBSD : public SuspendedThreadsList {\n+ public:\n+  SuspendedThreadsListNetBSD() { thread_ids_.reserve(1024); }\n+\n+  tid_t GetThreadID(uptr index) const;\n+  uptr ThreadCount() const;\n+  bool ContainsTid(tid_t thread_id) const;\n+  void Append(tid_t tid);\n+\n+  PtraceRegistersStatus GetRegistersAndSP(uptr index, uptr *buffer,\n+                                          uptr *sp) const;\n+  uptr RegisterCount() const;\n+\n+ private:\n+  InternalMmapVector<tid_t> thread_ids_;\n+};\n+\n+struct TracerThreadArgument {\n+  StopTheWorldCallback callback;\n+  void *callback_argument;\n+  BlockingMutex mutex;\n+  atomic_uintptr_t done;\n+  uptr parent_pid;\n+};\n+\n+class ThreadSuspender {\n+ public:\n+  explicit ThreadSuspender(pid_t pid, TracerThreadArgument *arg)\n+      : arg(arg), pid_(pid) {\n+    CHECK_GE(pid, 0);\n+  }\n+  bool SuspendAllThreads();\n+  void ResumeAllThreads();\n+  void KillAllThreads();\n+  SuspendedThreadsListNetBSD &suspended_threads_list() {\n+    return suspended_threads_list_;\n+  }\n+  TracerThreadArgument *arg;\n+\n+ private:\n+  SuspendedThreadsListNetBSD suspended_threads_list_;\n+  pid_t pid_;\n+};\n+\n+void ThreadSuspender::ResumeAllThreads() {\n+  int pterrno;\n+  if (!internal_iserror(internal_ptrace(PT_DETACH, pid_, (void *)(uptr)1, 0),\n+                        &pterrno)) {\n+    VReport(2, \"Detached from process %d.\\n\", pid_);\n+  } else {\n+    VReport(1, \"Could not detach from process %d (errno %d).\\n\", pid_, pterrno);\n+  }\n+}\n+\n+void ThreadSuspender::KillAllThreads() {\n+  internal_ptrace(PT_KILL, pid_, nullptr, 0);\n+}\n+\n+bool ThreadSuspender::SuspendAllThreads() {\n+  int pterrno;\n+  if (internal_iserror(internal_ptrace(PT_ATTACH, pid_, nullptr, 0),\n+                       &pterrno)) {\n+    Printf(\"Could not attach to process %d (errno %d).\\n\", pid_, pterrno);\n+    return false;\n+  }\n+\n+  int status;\n+  uptr waitpid_status;\n+  HANDLE_EINTR(waitpid_status, internal_waitpid(pid_, &status, 0));\n+\n+  VReport(2, \"Attached to process %d.\\n\", pid_);\n+\n+  struct ptrace_lwpinfo pl;\n+  int val;\n+  pl.pl_lwpid = 0;\n+  while ((val = ptrace(PT_LWPINFO, pid_, (void *)&pl, sizeof(pl))) != -1 &&\n+         pl.pl_lwpid != 0) {\n+    suspended_threads_list_.Append(pl.pl_lwpid);\n+    VReport(2, \"Appended thread %d in process %d.\\n\", pl.pl_lwpid, pid_);\n+  }\n+  return true;\n+}\n+\n+// Pointer to the ThreadSuspender instance for use in signal handler.\n+static ThreadSuspender *thread_suspender_instance = nullptr;\n+\n+// Synchronous signals that should not be blocked.\n+static const int kSyncSignals[] = {SIGABRT, SIGILL,  SIGFPE, SIGSEGV,\n+                                   SIGBUS,  SIGXCPU, SIGXFSZ};\n+\n+static void TracerThreadDieCallback() {\n+  ThreadSuspender *inst = thread_suspender_instance;\n+  if (inst && stoptheworld_tracer_pid == internal_getpid()) {\n+    inst->KillAllThreads();\n+    thread_suspender_instance = nullptr;\n+  }\n+}\n+\n+// Signal handler to wake up suspended threads when the tracer thread dies.\n+static void TracerThreadSignalHandler(int signum, __sanitizer_siginfo *siginfo,\n+                                      void *uctx) {\n+  SignalContext ctx(siginfo, uctx);\n+  Printf(\"Tracer caught signal %d: addr=0x%zx pc=0x%zx sp=0x%zx\\n\", signum,\n+         ctx.addr, ctx.pc, ctx.sp);\n+  ThreadSuspender *inst = thread_suspender_instance;\n+  if (inst) {\n+    if (signum == SIGABRT)\n+      inst->KillAllThreads();\n+    else\n+      inst->ResumeAllThreads();\n+    RAW_CHECK(RemoveDieCallback(TracerThreadDieCallback));\n+    thread_suspender_instance = nullptr;\n+    atomic_store(&inst->arg->done, 1, memory_order_relaxed);\n+  }\n+  internal__exit((signum == SIGABRT) ? 1 : 2);\n+}\n+\n+// Size of alternative stack for signal handlers in the tracer thread.\n+static const int kHandlerStackSize = 8192;\n+\n+// This function will be run as a cloned task.\n+static int TracerThread(void *argument) {\n+  TracerThreadArgument *tracer_thread_argument =\n+      (TracerThreadArgument *)argument;\n+\n+  // Check if parent is already dead.\n+  if (internal_getppid() != tracer_thread_argument->parent_pid)\n+    internal__exit(4);\n+\n+  // Wait for the parent thread to finish preparations.\n+  tracer_thread_argument->mutex.Lock();\n+  tracer_thread_argument->mutex.Unlock();\n+\n+  RAW_CHECK(AddDieCallback(TracerThreadDieCallback));\n+\n+  ThreadSuspender thread_suspender(internal_getppid(), tracer_thread_argument);\n+  // Global pointer for the signal handler.\n+  thread_suspender_instance = &thread_suspender;\n+\n+  // Alternate stack for signal handling.\n+  InternalMmapVector<char> handler_stack_memory(kHandlerStackSize);\n+  stack_t handler_stack;\n+  internal_memset(&handler_stack, 0, sizeof(handler_stack));\n+  handler_stack.ss_sp = handler_stack_memory.data();\n+  handler_stack.ss_size = kHandlerStackSize;\n+  internal_sigaltstack(&handler_stack, nullptr);\n+\n+  // Install our handler for synchronous signals. Other signals should be\n+  // blocked by the mask we inherited from the parent thread.\n+  for (uptr i = 0; i < ARRAY_SIZE(kSyncSignals); i++) {\n+    __sanitizer_sigaction act;\n+    internal_memset(&act, 0, sizeof(act));\n+    act.sigaction = TracerThreadSignalHandler;\n+    act.sa_flags = SA_ONSTACK | SA_SIGINFO;\n+    internal_sigaction_norestorer(kSyncSignals[i], &act, 0);\n+  }\n+\n+  int exit_code = 0;\n+  if (!thread_suspender.SuspendAllThreads()) {\n+    VReport(1, \"Failed suspending threads.\\n\");\n+    exit_code = 3;\n+  } else {\n+    tracer_thread_argument->callback(thread_suspender.suspended_threads_list(),\n+                                     tracer_thread_argument->callback_argument);\n+    thread_suspender.ResumeAllThreads();\n+    exit_code = 0;\n+  }\n+  RAW_CHECK(RemoveDieCallback(TracerThreadDieCallback));\n+  thread_suspender_instance = nullptr;\n+  atomic_store(&tracer_thread_argument->done, 1, memory_order_relaxed);\n+  return exit_code;\n+}\n+\n+class ScopedStackSpaceWithGuard {\n+ public:\n+  explicit ScopedStackSpaceWithGuard(uptr stack_size) {\n+    stack_size_ = stack_size;\n+    guard_size_ = GetPageSizeCached();\n+    // FIXME: Omitting MAP_STACK here works in current kernels but might break\n+    // in the future.\n+    guard_start_ =\n+        (uptr)MmapOrDie(stack_size_ + guard_size_, \"ScopedStackWithGuard\");\n+    CHECK(MprotectNoAccess((uptr)guard_start_, guard_size_));\n+  }\n+  ~ScopedStackSpaceWithGuard() {\n+    UnmapOrDie((void *)guard_start_, stack_size_ + guard_size_);\n+  }\n+  void *Bottom() const {\n+    return (void *)(guard_start_ + stack_size_ + guard_size_);\n+  }\n+\n+ private:\n+  uptr stack_size_;\n+  uptr guard_size_;\n+  uptr guard_start_;\n+};\n+\n+static __sanitizer_sigset_t blocked_sigset;\n+static __sanitizer_sigset_t old_sigset;\n+\n+struct ScopedSetTracerPID {\n+  explicit ScopedSetTracerPID(uptr tracer_pid) {\n+    stoptheworld_tracer_pid = tracer_pid;\n+    stoptheworld_tracer_ppid = internal_getpid();\n+  }\n+  ~ScopedSetTracerPID() {\n+    stoptheworld_tracer_pid = 0;\n+    stoptheworld_tracer_ppid = 0;\n+  }\n+};\n+\n+void StopTheWorld(StopTheWorldCallback callback, void *argument) {\n+  // Prepare the arguments for TracerThread.\n+  struct TracerThreadArgument tracer_thread_argument;\n+  tracer_thread_argument.callback = callback;\n+  tracer_thread_argument.callback_argument = argument;\n+  tracer_thread_argument.parent_pid = internal_getpid();\n+  atomic_store(&tracer_thread_argument.done, 0, memory_order_relaxed);\n+  const uptr kTracerStackSize = 2 * 1024 * 1024;\n+  ScopedStackSpaceWithGuard tracer_stack(kTracerStackSize);\n+\n+  tracer_thread_argument.mutex.Lock();\n+\n+  internal_sigfillset(&blocked_sigset);\n+  for (uptr i = 0; i < ARRAY_SIZE(kSyncSignals); i++)\n+    internal_sigdelset(&blocked_sigset, kSyncSignals[i]);\n+  int rv = internal_sigprocmask(SIG_BLOCK, &blocked_sigset, &old_sigset);\n+  CHECK_EQ(rv, 0);\n+  uptr tracer_pid = internal_clone(TracerThread, tracer_stack.Bottom(),\n+                                   CLONE_VM | CLONE_FS | CLONE_FILES,\n+                                   &tracer_thread_argument);\n+  internal_sigprocmask(SIG_SETMASK, &old_sigset, 0);\n+  int local_errno = 0;\n+  if (internal_iserror(tracer_pid, &local_errno)) {\n+    VReport(1, \"Failed spawning a tracer thread (errno %d).\\n\", local_errno);\n+    tracer_thread_argument.mutex.Unlock();\n+  } else {\n+    ScopedSetTracerPID scoped_set_tracer_pid(tracer_pid);\n+\n+    tracer_thread_argument.mutex.Unlock();\n+\n+    while (atomic_load(&tracer_thread_argument.done, memory_order_relaxed) == 0)\n+      sched_yield();\n+\n+    for (;;) {\n+      uptr waitpid_status = internal_waitpid(tracer_pid, nullptr, __WALL);\n+      if (!internal_iserror(waitpid_status, &local_errno))\n+        break;\n+      if (local_errno == EINTR)\n+        continue;\n+      VReport(1, \"Waiting on the tracer thread failed (errno %d).\\n\",\n+              local_errno);\n+      break;\n+    }\n+  }\n+}\n+\n+tid_t SuspendedThreadsListNetBSD::GetThreadID(uptr index) const {\n+  CHECK_LT(index, thread_ids_.size());\n+  return thread_ids_[index];\n+}\n+\n+uptr SuspendedThreadsListNetBSD::ThreadCount() const {\n+  return thread_ids_.size();\n+}\n+\n+bool SuspendedThreadsListNetBSD::ContainsTid(tid_t thread_id) const {\n+  for (uptr i = 0; i < thread_ids_.size(); i++) {\n+    if (thread_ids_[i] == thread_id)\n+      return true;\n+  }\n+  return false;\n+}\n+\n+void SuspendedThreadsListNetBSD::Append(tid_t tid) {\n+  thread_ids_.push_back(tid);\n+}\n+\n+PtraceRegistersStatus SuspendedThreadsListNetBSD::GetRegistersAndSP(\n+    uptr index, uptr *buffer, uptr *sp) const {\n+  lwpid_t tid = GetThreadID(index);\n+  pid_t ppid = internal_getppid();\n+  struct reg regs;\n+  int pterrno;\n+  bool isErr =\n+      internal_iserror(internal_ptrace(PT_GETREGS, ppid, &regs, tid), &pterrno);\n+  if (isErr) {\n+    VReport(1,\n+            \"Could not get registers from process %d thread %d (errno %d).\\n\",\n+            ppid, tid, pterrno);\n+    return pterrno == ESRCH ? REGISTERS_UNAVAILABLE_FATAL\n+                            : REGISTERS_UNAVAILABLE;\n+  }\n+\n+  *sp = PTRACE_REG_SP(&regs);\n+  internal_memcpy(buffer, &regs, sizeof(regs));\n+\n+  return REGISTERS_AVAILABLE;\n+}\n+\n+uptr SuspendedThreadsListNetBSD::RegisterCount() const {\n+  return sizeof(struct reg) / sizeof(uptr);\n+}\n+}  // namespace __sanitizer\n+\n+#endif"}, {"sha": "44c83a66c5fe19fc1d6ba356413b2fd0cd4aef4c", "filename": "libsanitizer/sanitizer_common/sanitizer_suppressions.cpp", "status": "renamed", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_suppressions.cc -----------------------------------------===//\n+//===-- sanitizer_suppressions.cpp ----------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -29,6 +30,7 @@ SuppressionContext::SuppressionContext(const char *suppression_types[],\n   internal_memset(has_suppression_type_, 0, suppression_types_num_);\n }\n \n+#if !SANITIZER_FUCHSIA\n static bool GetPathAssumingFileIsRelativeToExec(const char *file_path,\n                                                 /*out*/char *new_file_path,\n                                                 uptr new_file_path_size) {\n@@ -45,20 +47,30 @@ static bool GetPathAssumingFileIsRelativeToExec(const char *file_path,\n   return false;\n }\n \n+static const char *FindFile(const char *file_path,\n+                            /*out*/char *new_file_path,\n+                            uptr new_file_path_size) {\n+  // If we cannot find the file, check if its location is relative to\n+  // the location of the executable.\n+  if (!FileExists(file_path) && !IsAbsolutePath(file_path) &&\n+      GetPathAssumingFileIsRelativeToExec(file_path, new_file_path,\n+                                          new_file_path_size)) {\n+    return new_file_path;\n+  }\n+  return file_path;\n+}\n+#else\n+static const char *FindFile(const char *file_path, char *, uptr) {\n+  return file_path;\n+}\n+#endif\n+\n void SuppressionContext::ParseFromFile(const char *filename) {\n   if (filename[0] == '\\0')\n     return;\n \n-#if !SANITIZER_FUCHSIA\n-  // If we cannot find the file, check if its location is relative to\n-  // the location of the executable.\n   InternalScopedString new_file_path(kMaxPathLength);\n-  if (!FileExists(filename) && !IsAbsolutePath(filename) &&\n-      GetPathAssumingFileIsRelativeToExec(filename, new_file_path.data(),\n-                                          new_file_path.size())) {\n-    filename = new_file_path.data();\n-  }\n-#endif  // !SANITIZER_FUCHSIA\n+  filename = FindFile(filename, new_file_path.data(), new_file_path.size());\n \n   // Read the file.\n   VPrintf(1, \"%s: reading suppressions file at %s\\n\",\n@@ -92,7 +104,7 @@ bool SuppressionContext::Match(const char *str, const char *type,\n }\n \n static const char *StripPrefix(const char *str, const char *prefix) {\n-  while (str && *str == *prefix) {\n+  while (*str && *str == *prefix) {\n     str++;\n     prefix++;\n   }", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_suppressions.cc"}, {"sha": "f9da7af7e6ab3ae6f2021dae9320d599d1a3a0c6", "filename": "libsanitizer/sanitizer_common/sanitizer_suppressions.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_suppressions.h --------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "ce2ece5f4d51236aed44b500ce5fb116139da8ed", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.cpp", "status": "renamed", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_symbolizer.cc -------------------------------------------===//\n+//===-- sanitizer_symbolizer.cpp ------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -65,6 +66,16 @@ void DataInfo::Clear() {\n   internal_memset(this, 0, sizeof(DataInfo));\n }\n \n+void FrameInfo::Clear() {\n+  InternalFree(module);\n+  for (LocalInfo &local : locals) {\n+    InternalFree(local.function_name);\n+    InternalFree(local.name);\n+    InternalFree(local.decl_file);\n+  }\n+  locals.clear();\n+}\n+\n Symbolizer *Symbolizer::symbolizer_;\n StaticSpinMutex Symbolizer::init_mu_;\n LowLevelAllocator Symbolizer::symbolizer_allocator_;", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.cc"}, {"sha": "51648e2d0e8d7d31150343b8d057c4b3d2b65c93", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.h", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_symbolizer.h ----------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -19,6 +20,7 @@\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_mutex.h\"\n+#include \"sanitizer_vector.h\"\n \n namespace __sanitizer {\n \n@@ -76,6 +78,32 @@ struct DataInfo {\n   void Clear();\n };\n \n+struct LocalInfo {\n+  char *function_name = nullptr;\n+  char *name = nullptr;\n+  char *decl_file = nullptr;\n+  unsigned decl_line = 0;\n+\n+  bool has_frame_offset = false;\n+  bool has_size = false;\n+  bool has_tag_offset = false;\n+\n+  sptr frame_offset;\n+  uptr size;\n+  uptr tag_offset;\n+\n+  void Clear();\n+};\n+\n+struct FrameInfo {\n+  char *module;\n+  uptr module_offset;\n+  ModuleArch module_arch;\n+\n+  InternalMmapVector<LocalInfo> locals;\n+  void Clear();\n+};\n+\n class SymbolizerTool;\n \n class Symbolizer final {\n@@ -88,6 +116,7 @@ class Symbolizer final {\n   // all inlined functions, if necessary).\n   SymbolizedStack *SymbolizePC(uptr address);\n   bool SymbolizeData(uptr address, DataInfo *info);\n+  bool SymbolizeFrame(uptr address, FrameInfo *info);\n \n   // The module names Symbolizer returns are stable and unique for every given\n   // module.  It is safe to store and compare them as pointers."}, {"sha": "c4061e38c6a47cfb756a193f7212127a4b02ecfc", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_fuchsia.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_fuchsia.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_fuchsia.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_fuchsia.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_symbolizer_fuchsia.h -----------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -33,6 +34,9 @@ constexpr const char *kFormatData = \"{{{data:%p}}}\";\n // One frame in a backtrace (printed on a line by itself).\n constexpr const char *kFormatFrame = \"{{{bt:%u:%p}}}\";\n \n+// Dump trigger element.\n+#define FORMAT_DUMPFILE \"{{{dumpfile:%s:%s}}}\"\n+\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_SYMBOLIZER_FUCHSIA_H"}, {"sha": "3031f28a20e19e71ece9af2a202a5c93361e9aab", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_internal.h", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_internal.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_symbolizer_internal.h -------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -14,6 +15,7 @@\n \n #include \"sanitizer_symbolizer.h\"\n #include \"sanitizer_file.h\"\n+#include \"sanitizer_vector.h\"\n \n namespace __sanitizer {\n \n@@ -57,6 +59,10 @@ class SymbolizerTool {\n     UNIMPLEMENTED();\n   }\n \n+  virtual bool SymbolizeFrame(uptr addr, FrameInfo *info) {\n+    return false;\n+  }\n+\n   virtual void Flush() {}\n \n   // Return nullptr to fallback to the default platform-specific demangler.\n@@ -74,26 +80,27 @@ class SymbolizerProcess {\n   const char *SendCommand(const char *command);\n \n  protected:\n+  /// The maximum number of arguments required to invoke a tool process.\n+  static const unsigned kArgVMax = 6;\n+\n+  // Customizable by subclasses.\n+  virtual bool StartSymbolizerSubprocess();\n+  virtual bool ReadFromSymbolizer(char *buffer, uptr max_length);\n+\n+ private:\n   virtual bool ReachedEndOfOutput(const char *buffer, uptr length) const {\n     UNIMPLEMENTED();\n   }\n \n-  /// The maximum number of arguments required to invoke a tool process.\n-  enum { kArgVMax = 6 };\n-\n   /// Fill in an argv array to invoke the child process.\n   virtual void GetArgV(const char *path_to_binary,\n                        const char *(&argv)[kArgVMax]) const {\n     UNIMPLEMENTED();\n   }\n \n-  virtual bool ReadFromSymbolizer(char *buffer, uptr max_length);\n-\n- private:\n   bool Restart();\n   const char *SendCommandImpl(const char *command);\n   bool WriteToSymbolizer(const char *buffer, uptr length);\n-  bool StartSymbolizerSubprocess();\n \n   const char *path_;\n   fd_t input_fd_;\n@@ -119,12 +126,13 @@ class LLVMSymbolizer : public SymbolizerTool {\n   explicit LLVMSymbolizer(const char *path, LowLevelAllocator *allocator);\n \n   bool SymbolizePC(uptr addr, SymbolizedStack *stack) override;\n-\n   bool SymbolizeData(uptr addr, DataInfo *info) override;\n+  bool SymbolizeFrame(uptr addr, FrameInfo *info) override;\n \n  private:\n-  const char *FormatAndSendCommand(bool is_data, const char *module_name,\n-                                   uptr module_offset, ModuleArch arch);\n+  const char *FormatAndSendCommand(const char *command_prefix,\n+                                   const char *module_name, uptr module_offset,\n+                                   ModuleArch arch);\n \n   LLVMSymbolizerProcess *symbolizer_process_;\n   static const uptr kBufferSize = 16 * 1024;"}, {"sha": "27ed222745ec678f0e5a883ccd26ad0e800461ba", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libbacktrace.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_symbolizer_libbacktrace.cc ------------------------------===//\n+//===-- sanitizer_symbolizer_libbacktrace.cpp -----------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libbacktrace.cc"}, {"sha": "e2a0f71420f0e5af321fabeb980d34fd758d9aa1", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libbacktrace.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_symbolizer_libbacktrace.h ---------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "742b9748c98f6d6947ab41e564e15d03f5d63c31", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libcdep.cpp", "status": "renamed", "additions": 76, "deletions": 12, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_symbolizer_libcdep.cc -----------------------------------===//\n+//===-- sanitizer_symbolizer_libcdep.cpp ----------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -24,7 +25,7 @@ Symbolizer *Symbolizer::GetOrInit() {\n   return symbolizer_;\n }\n \n-// See sanitizer_symbolizer_markup.cc.\n+// See sanitizer_symbolizer_markup.cpp.\n #if !SANITIZER_SYMBOLIZER_MARKUP\n \n const char *ExtractToken(const char *str, const char *delims, char **result) {\n@@ -57,6 +58,16 @@ const char *ExtractUptr(const char *str, const char *delims, uptr *result) {\n   return ret;\n }\n \n+const char *ExtractSptr(const char *str, const char *delims, sptr *result) {\n+  char *buff;\n+  const char *ret = ExtractToken(str, delims, &buff);\n+  if (buff != 0) {\n+    *result = (sptr)internal_atoll(buff);\n+  }\n+  InternalFree(buff);\n+  return ret;\n+}\n+\n const char *ExtractTokenUpToDelimiter(const char *str, const char *delimiter,\n                                       char **result) {\n   const char *found_delimiter = internal_strstr(str, delimiter);\n@@ -111,6 +122,22 @@ bool Symbolizer::SymbolizeData(uptr addr, DataInfo *info) {\n   return true;\n }\n \n+bool Symbolizer::SymbolizeFrame(uptr addr, FrameInfo *info) {\n+  BlockingMutexLock l(&mu_);\n+  const char *module_name;\n+  if (!FindModuleNameAndOffsetForAddress(\n+          addr, &module_name, &info->module_offset, &info->module_arch))\n+    return false;\n+  info->module = internal_strdup(module_name);\n+  for (auto &tool : tools_) {\n+    SymbolizerScope sym_scope(this);\n+    if (tool.SymbolizeFrame(addr, info)) {\n+      return true;\n+    }\n+  }\n+  return true;\n+}\n+\n bool Symbolizer::GetModuleNameAndOffsetForPC(uptr pc, const char **module_name,\n                                              uptr *module_address) {\n   BlockingMutexLock l(&mu_);\n@@ -342,10 +369,38 @@ void ParseSymbolizeDataOutput(const char *str, DataInfo *info) {\n   str = ExtractUptr(str, \"\\n\", &info->size);\n }\n \n+static void ParseSymbolizeFrameOutput(const char *str,\n+                                      InternalMmapVector<LocalInfo> *locals) {\n+  if (internal_strncmp(str, \"??\", 2) == 0)\n+    return;\n+\n+  while (*str) {\n+    LocalInfo local;\n+    str = ExtractToken(str, \"\\n\", &local.function_name);\n+    str = ExtractToken(str, \"\\n\", &local.name);\n+\n+    AddressInfo addr;\n+    str = ParseFileLineInfo(&addr, str);\n+    local.decl_file = addr.file;\n+    local.decl_line = addr.line;\n+\n+    local.has_frame_offset = internal_strncmp(str, \"??\", 2) != 0;\n+    str = ExtractSptr(str, \" \", &local.frame_offset);\n+\n+    local.has_size = internal_strncmp(str, \"??\", 2) != 0;\n+    str = ExtractUptr(str, \" \", &local.size);\n+\n+    local.has_tag_offset = internal_strncmp(str, \"??\", 2) != 0;\n+    str = ExtractUptr(str, \"\\n\", &local.tag_offset);\n+\n+    locals->push_back(local);\n+  }\n+}\n+\n bool LLVMSymbolizer::SymbolizePC(uptr addr, SymbolizedStack *stack) {\n   AddressInfo *info = &stack->info;\n   const char *buf = FormatAndSendCommand(\n-      /*is_data*/ false, info->module, info->module_offset, info->module_arch);\n+      \"CODE\", info->module, info->module_offset, info->module_arch);\n   if (buf) {\n     ParseSymbolizePCOutput(buf, stack);\n     return true;\n@@ -355,7 +410,7 @@ bool LLVMSymbolizer::SymbolizePC(uptr addr, SymbolizedStack *stack) {\n \n bool LLVMSymbolizer::SymbolizeData(uptr addr, DataInfo *info) {\n   const char *buf = FormatAndSendCommand(\n-      /*is_data*/ true, info->module, info->module_offset, info->module_arch);\n+      \"DATA\", info->module, info->module_offset, info->module_arch);\n   if (buf) {\n     ParseSymbolizeDataOutput(buf, info);\n     info->start += (addr - info->module_offset); // Add the base address.\n@@ -364,22 +419,31 @@ bool LLVMSymbolizer::SymbolizeData(uptr addr, DataInfo *info) {\n   return false;\n }\n \n-const char *LLVMSymbolizer::FormatAndSendCommand(bool is_data,\n+bool LLVMSymbolizer::SymbolizeFrame(uptr addr, FrameInfo *info) {\n+  const char *buf = FormatAndSendCommand(\n+      \"FRAME\", info->module, info->module_offset, info->module_arch);\n+  if (buf) {\n+    ParseSymbolizeFrameOutput(buf, &info->locals);\n+    return true;\n+  }\n+  return false;\n+}\n+\n+const char *LLVMSymbolizer::FormatAndSendCommand(const char *command_prefix,\n                                                  const char *module_name,\n                                                  uptr module_offset,\n                                                  ModuleArch arch) {\n   CHECK(module_name);\n-  const char *is_data_str = is_data ? \"DATA \" : \"\";\n   if (arch == kModuleArchUnknown) {\n-    if (internal_snprintf(buffer_, kBufferSize, \"%s\\\"%s\\\" 0x%zx\\n\", is_data_str,\n-                          module_name,\n+    if (internal_snprintf(buffer_, kBufferSize, \"%s \\\"%s\\\" 0x%zx\\n\",\n+                          command_prefix, module_name,\n                           module_offset) >= static_cast<int>(kBufferSize)) {\n       Report(\"WARNING: Command buffer too small\");\n       return nullptr;\n     }\n   } else {\n-    if (internal_snprintf(buffer_, kBufferSize, \"%s\\\"%s:%s\\\" 0x%zx\\n\",\n-                          is_data_str, module_name, ModuleArchToString(arch),\n+    if (internal_snprintf(buffer_, kBufferSize, \"%s \\\"%s:%s\\\" 0x%zx\\n\",\n+                          command_prefix, module_name, ModuleArchToString(arch),\n                           module_offset) >= static_cast<int>(kBufferSize)) {\n       Report(\"WARNING: Command buffer too small\");\n       return nullptr;", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libcdep.cc"}, {"sha": "7bc4b0ce025ffb3c148c5c59344b6c0e88f9ee9f", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_mac.cpp", "status": "renamed", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_symbolizer_mac.cc ---------------------------------------===//\n+//===-- sanitizer_symbolizer_mac.cpp --------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -56,6 +57,11 @@ class AtosSymbolizerProcess : public SymbolizerProcess {\n   }\n \n  private:\n+  virtual bool StartSymbolizerSubprocess() override {\n+    // Configure sandbox before starting atos process.\n+    return SymbolizerProcess::StartSymbolizerSubprocess();\n+  }\n+\n   bool ReachedEndOfOutput(const char *buffer, uptr length) const override {\n     return (length >= 1 && buffer[length - 1] == '\\n');\n   }", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_mac.cc"}, {"sha": "68521375e64c44e7842307488a68216acab26532", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_mac.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_symbolizer_mac.h ------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "57b4d0c9d9613bdc69240e17e3592b0bc3e90492", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_markup.cpp", "status": "renamed", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_markup.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_markup.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_markup.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_symbolizer_markup.cc ------------------------------------===//\n+//===-- sanitizer_symbolizer_markup.cpp -----------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -116,7 +117,7 @@ _Unwind_Reason_Code Unwind_Trace(struct _Unwind_Context *ctx, void *param) {\n                                              : _URC_NO_REASON);\n }\n \n-void BufferedStackTrace::SlowUnwindStack(uptr pc, u32 max_depth) {\n+void BufferedStackTrace::UnwindSlow(uptr pc, u32 max_depth) {\n   CHECK_GE(max_depth, 2);\n   size = 0;\n   UnwindTraceArg arg = {this, Min(max_depth + 1, kStackTraceMax)};\n@@ -131,9 +132,9 @@ void BufferedStackTrace::SlowUnwindStack(uptr pc, u32 max_depth) {\n   trace_buffer[0] = pc;\n }\n \n-void BufferedStackTrace::SlowUnwindStackWithContext(uptr pc, void *context,\n-                                                    u32 max_depth) {\n-  CHECK_NE(context, nullptr);\n+void BufferedStackTrace::UnwindSlow(uptr pc, void *context, u32 max_depth) {\n+  CHECK(context);\n+  CHECK_GE(max_depth, 2);\n   UNREACHABLE(\"signal context doesn't exist\");\n }\n #endif  // SANITIZER_CAN_SLOW_UNWIND", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_markup.cc"}, {"sha": "43e6a6d2dbf77cdfb586b28958a2b6796c54d4da", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_symbolizer_posix_libcdep.cc -----------------------------===//\n+//===-- sanitizer_symbolizer_posix_libcdep.cpp ----------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cc"}, {"sha": "a8b449b030e75628e3ae122dd141da8e59300f11", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_report.cpp", "status": "renamed", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_report.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_report.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_report.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_symbolizer_report.cc ------------------------------------===//\n+//===-- sanitizer_symbolizer_report.cpp -----------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n ///\n@@ -102,9 +103,11 @@ void ReportMmapWriteExec(int prot) {\n   GET_CALLER_PC_BP_SP;\n   (void)sp;\n   bool fast = common_flags()->fast_unwind_on_fatal;\n-  if (fast)\n+  if (StackTrace::WillUseFastUnwind(fast)) {\n     GetThreadStackTopAndBottom(false, &top, &bottom);\n-  stack->Unwind(kStackTraceMax, pc, bp, nullptr, top, bottom, fast);\n+    stack->Unwind(kStackTraceMax, pc, bp, nullptr, top, bottom, true);\n+  } else\n+    stack->Unwind(kStackTraceMax, pc, 0, nullptr, 0, 0, false);\n \n   Printf(\"%s\", d.Warning());\n   Report(\"WARNING: %s: writable-executable page usage\\n\", SanitizerToolName);", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_report.cc"}, {"sha": "3371092e0687599f374a4cd1477e52c504f1b418", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_rtems.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_rtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_rtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_rtems.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_symbolizer_rtems.h -----------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "2808779156edd2142a434236ae39d06c40118bd7", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_win.cpp", "status": "renamed", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_symbolizer_win.cc ---------------------------------------===//\n+//===-- sanitizer_symbolizer_win.cpp --------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -34,6 +35,9 @@ namespace {\n \n class WinSymbolizerTool : public SymbolizerTool {\n  public:\n+  // The constructor is provided to avoid synthesized memsets.\n+  WinSymbolizerTool() {}\n+\n   bool SymbolizePC(uptr addr, SymbolizedStack *stack) override;\n   bool SymbolizeData(uptr addr, DataInfo *info) override {\n     return false;", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_win.cc"}, {"sha": "a43ce3efab127812759415c35b5ac63a244460e1", "filename": "libsanitizer/sanitizer_common/sanitizer_syscall_generic.inc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_generic.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_generic.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_generic.inc?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_syscall_generic.inc ---------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "56c5e99220cc9ce9cafad3fc2d3c03094df9088a", "filename": "libsanitizer/sanitizer_common/sanitizer_syscall_linux_aarch64.inc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_aarch64.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_aarch64.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_aarch64.inc?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_syscall_linux_aarch64.inc --------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "121a9445b41ca76a4029430140c17d383094c60f", "filename": "libsanitizer/sanitizer_common/sanitizer_syscall_linux_arm.inc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_arm.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_arm.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_arm.inc?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_syscall_linux_arm.inc -------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "67e8686d12cabb3ad48befe3f4f6b0bbf5d4b27c", "filename": "libsanitizer/sanitizer_common/sanitizer_syscall_linux_x86_64.inc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_x86_64.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_x86_64.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_x86_64.inc?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_syscall_linux_x86_64.inc ----------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "21b521669630698f0dbf4de0fa44d59c275e64ac", "filename": "libsanitizer/sanitizer_common/sanitizer_syscalls_netbsd.inc", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscalls_netbsd.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscalls_netbsd.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscalls_netbsd.inc?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_syscalls_netbsd.inc ---------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -41,8 +42,8 @@\n // DO NOT EDIT! THIS FILE HAS BEEN GENERATED!\n //\n // Generated with: generate_netbsd_syscalls.awk\n-// Generated date: 2018-03-03\n-// Generated from: syscalls.master,v 1.291 2018/01/06 16:41:23 kamil Exp\n+// Generated date: 2018-10-30\n+// Generated from: syscalls.master,v 1.293 2018/07/31 13:00:13 rjs Exp\n //\n //===----------------------------------------------------------------------===//\n \n@@ -1452,7 +1453,15 @@ PRE_SYSCALL(fpathconf)(long long fd_, long long name_) { /* Nothing to do */ }\n POST_SYSCALL(fpathconf)(long long res, long long fd_, long long name_) {\n   /* Nothing to do */\n }\n-/* syscall 193 has been skipped */\n+PRE_SYSCALL(getsockopt2)\n+(long long s_, long long level_, long long name_, void *val_, void *avalsize_) {\n+  /* TODO */\n+}\n+POST_SYSCALL(getsockopt2)\n+(long long res, long long s_, long long level_, long long name_, void *val_,\n+  void *avalsize_) {\n+  /* TODO */\n+}\n PRE_SYSCALL(getrlimit)(long long which_, void *rlp_) {\n   PRE_WRITE(rlp_, struct_rlimit_sz);\n }\n@@ -2339,20 +2348,8 @@ POST_SYSCALL(__sigaction_sigtramp)\n     PRE_READ(nsa_, sizeof(__sanitizer_sigaction));\n   }\n }\n-PRE_SYSCALL(pmc_get_info)(long long ctr_, long long op_, void *args_) {\n-  /* TODO */\n-}\n-POST_SYSCALL(pmc_get_info)\n-(long long res, long long ctr_, long long op_, void *args_) {\n-  /* TODO */\n-}\n-PRE_SYSCALL(pmc_control)(long long ctr_, long long op_, void *args_) {\n-  /* TODO */\n-}\n-POST_SYSCALL(pmc_control)\n-(long long res, long long ctr_, long long op_, void *args_) {\n-  /* TODO */\n-}\n+/* syscall 341 has been skipped */\n+/* syscall 342 has been skipped */\n PRE_SYSCALL(rasctl)(void *addr_, long long len_, long long op_) {\n   /* Nothing to do */\n }\n@@ -3693,18 +3690,18 @@ POST_SYSCALL(recvmmsg)\n PRE_SYSCALL(sendmmsg)\n (long long s_, void *mmsg_, long long vlen_, long long flags_) {\n   struct __sanitizer_mmsghdr *mmsg = (struct __sanitizer_mmsghdr *)mmsg_;\n-  unsigned int vlen = (vlen_ > 1024 ? 1024 : vlen_);\n   if (mmsg) {\n-    PRE_READ(mmsg, sizeof(struct __sanitizer_mmsghdr) * vlen);\n+    PRE_READ(mmsg, sizeof(struct __sanitizer_mmsghdr) *\n+                       (vlen_ > 1024 ? 1024 : vlen_));\n   }\n }\n POST_SYSCALL(sendmmsg)\n (long long res, long long s_, void *mmsg_, long long vlen_, long long flags_) {\n   struct __sanitizer_mmsghdr *mmsg = (struct __sanitizer_mmsghdr *)mmsg_;\n-  unsigned int vlen = (vlen_ > 1024 ? 1024 : vlen_);\n   if (res >= 0) {\n     if (mmsg) {\n-      POST_READ(mmsg, sizeof(struct __sanitizer_mmsghdr) * vlen);\n+      POST_READ(mmsg, sizeof(struct __sanitizer_mmsghdr) *\n+                          (vlen_ > 1024 ? 1024 : vlen_));\n     }\n   }\n }"}, {"sha": "e588c93b9943b1bd54e7562eeea4220cff8ef20b", "filename": "libsanitizer/sanitizer_common/sanitizer_termination.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_termination.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_termination.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_termination.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_termination.cc --------------------------------*- C++ -*-===//\n+//===-- sanitizer_termination.cpp -------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n ///", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_termination.cc"}, {"sha": "f2c6f279931516986fcfaa523779bfa5aad1bf87", "filename": "libsanitizer/sanitizer_common/sanitizer_thread_registry.cpp", "status": "renamed", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_thread_registry.cc --------------------------------------===//\n+//===-- sanitizer_thread_registry.cpp -------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -16,8 +17,8 @@ namespace __sanitizer {\n \n ThreadContextBase::ThreadContextBase(u32 tid)\n     : tid(tid), unique_id(0), reuse_count(), os_id(0), user_id(0),\n-      status(ThreadStatusInvalid),\n-      detached(false), workerthread(false), parent_tid(0), next(0) {\n+      status(ThreadStatusInvalid), detached(false),\n+      thread_type(ThreadType::Regular), parent_tid(0), next(0) {\n   name[0] = '\\0';\n   atomic_store(&thread_destroyed, 0, memory_order_release);\n }\n@@ -69,11 +70,11 @@ void ThreadContextBase::SetFinished() {\n   OnFinished();\n }\n \n-void ThreadContextBase::SetStarted(tid_t _os_id, bool _workerthread,\n+void ThreadContextBase::SetStarted(tid_t _os_id, ThreadType _thread_type,\n                                    void *arg) {\n   status = ThreadStatusRunning;\n   os_id = _os_id;\n-  workerthread = _workerthread;\n+  thread_type = _thread_type;\n   OnStarted(arg);\n }\n \n@@ -301,15 +302,15 @@ void ThreadRegistry::FinishThread(u32 tid) {\n   tctx->SetDestroyed();\n }\n \n-void ThreadRegistry::StartThread(u32 tid, tid_t os_id, bool workerthread,\n+void ThreadRegistry::StartThread(u32 tid, tid_t os_id, ThreadType thread_type,\n                                  void *arg) {\n   BlockingMutexLock l(&mtx_);\n   running_threads_++;\n   CHECK_LT(tid, n_contexts_);\n   ThreadContextBase *tctx = threads_[tid];\n   CHECK_NE(tctx, 0);\n   CHECK_EQ(ThreadStatusCreated, tctx->status);\n-  tctx->SetStarted(os_id, workerthread, arg);\n+  tctx->SetStarted(os_id, thread_type, arg);\n }\n \n void ThreadRegistry::QuarantinePush(ThreadContextBase *tctx) {\n@@ -336,4 +337,15 @@ ThreadContextBase *ThreadRegistry::QuarantinePop() {\n   return tctx;\n }\n \n+void ThreadRegistry::SetThreadUserId(u32 tid, uptr user_id) {\n+  BlockingMutexLock l(&mtx_);\n+  CHECK_LT(tid, n_contexts_);\n+  ThreadContextBase *tctx = threads_[tid];\n+  CHECK_NE(tctx, 0);\n+  CHECK_NE(tctx->status, ThreadStatusInvalid);\n+  CHECK_NE(tctx->status, ThreadStatusDead);\n+  CHECK_EQ(tctx->user_id, 0);\n+  tctx->user_id = user_id;\n+}\n+\n }  // namespace __sanitizer", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_thread_registry.cc"}, {"sha": "493aa988f7e6df3db81b78183bc0ad0c23df8d16", "filename": "libsanitizer/sanitizer_common/sanitizer_thread_registry.h", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_thread_registry.h -----------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -27,6 +28,12 @@ enum ThreadStatus {\n   ThreadStatusDead       // Joined, but some info is still available.\n };\n \n+enum class ThreadType {\n+  Regular, // Normal thread\n+  Worker,  // macOS Grand Central Dispatch (GCD) worker thread\n+  Fiber,   // Fiber\n+};\n+\n // Generic thread context. Specific sanitizer tools may inherit from it.\n // If thread is dead, context may optionally be reused for a new thread.\n class ThreadContextBase {\n@@ -43,7 +50,7 @@ class ThreadContextBase {\n \n   ThreadStatus status;\n   bool detached;\n-  bool workerthread;\n+  ThreadType thread_type;\n \n   u32 parent_tid;\n   ThreadContextBase *next;  // For storing thread contexts in a list.\n@@ -55,7 +62,7 @@ class ThreadContextBase {\n   void SetDead();\n   void SetJoined(void *arg);\n   void SetFinished();\n-  void SetStarted(tid_t _os_id, bool _workerthread, void *arg);\n+  void SetStarted(tid_t _os_id, ThreadType _thread_type, void *arg);\n   void SetCreated(uptr _user_id, u64 _unique_id, bool _detached,\n                   u32 _parent_tid, void *arg);\n   void Reset();\n@@ -119,7 +126,8 @@ class ThreadRegistry {\n   void DetachThread(u32 tid, void *arg);\n   void JoinThread(u32 tid, void *arg);\n   void FinishThread(u32 tid);\n-  void StartThread(u32 tid, tid_t os_id, bool workerthread, void *arg);\n+  void StartThread(u32 tid, tid_t os_id, ThreadType thread_type, void *arg);\n+  void SetThreadUserId(u32 tid, uptr user_id);\n \n  private:\n   const ThreadContextFactory context_factory_;"}, {"sha": "9ca898a306a88b7ac19ef1919dc162af939e03fe", "filename": "libsanitizer/sanitizer_common/sanitizer_tls_get_addr.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_tls_get_addr.cc -----------------------------------------===//\n+//===-- sanitizer_tls_get_addr.cpp ----------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_tls_get_addr.cc"}, {"sha": "c7cd5a8bffcf99bf7e2c6295ca30566cabcb100a", "filename": "libsanitizer/sanitizer_common/sanitizer_tls_get_addr.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_tls_get_addr.h --------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -41,7 +42,7 @@ struct DTLS {\n   uptr dtv_size;\n   DTV *dtv;  // dtv_size elements, allocated by MmapOrDie.\n \n-  // Auxiliary fields, don't access them outside sanitizer_tls_get_addr.cc\n+  // Auxiliary fields, don't access them outside sanitizer_tls_get_addr.cpp\n   uptr last_memalign_size;\n   uptr last_memalign_ptr;\n };"}, {"sha": "5ee37d7376f977fa3a41e588b71f3b5afd1cf2ce", "filename": "libsanitizer/sanitizer_common/sanitizer_type_traits.cpp", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_type_traits.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_type_traits.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_type_traits.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -0,0 +1,20 @@\n+//===-- sanitizer_type_traits.cpp -------------------------------*- C++ -*-===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Implements a subset of C++ type traits. This is so we can avoid depending\n+// on system C++ headers.\n+//\n+//===----------------------------------------------------------------------===//\n+#include \"sanitizer_type_traits.h\"\n+\n+namespace __sanitizer {\n+\n+const bool true_type::value;\n+const bool false_type::value;\n+\n+}  // namespace __sanitizer"}, {"sha": "2a58d9874d2cb966ecaed786e0a33b6fe62d62ab", "filename": "libsanitizer/sanitizer_common/sanitizer_type_traits.h", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_type_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_type_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_type_traits.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -0,0 +1,62 @@\n+//===-- sanitizer_type_traits.h ---------------------------------*- C++ -*-===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Implements a subset of C++ type traits. This is so we can avoid depending\n+// on system C++ headers.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_TYPE_TRAITS_H\n+#define SANITIZER_TYPE_TRAITS_H\n+\n+namespace __sanitizer {\n+\n+struct true_type {\n+  static const bool value = true;\n+};\n+\n+struct false_type {\n+  static const bool value = false;\n+};\n+\n+// is_same<T, U>\n+//\n+// Type trait to compare if types are the same.\n+// E.g.\n+//\n+// ```\n+// is_same<int,int>::value - True\n+// is_same<int,char>::value - False\n+// ```\n+template <typename T, typename U>\n+struct is_same : public false_type {};\n+\n+template <typename T>\n+struct is_same<T, T> : public true_type {};\n+\n+// conditional<B, T, F>\n+//\n+// Defines type as T if B is true or as F otherwise.\n+// E.g. the following is true\n+//\n+// ```\n+// is_same<int, conditional<true, int, double>::type>::value\n+// is_same<double, conditional<false, int, double>::type>::value\n+// ```\n+template <bool B, class T, class F>\n+struct conditional {\n+  using type = T;\n+};\n+\n+template <class T, class F>\n+struct conditional<false, T, F> {\n+  using type = F;\n+};\n+\n+}  // namespace __sanitizer\n+\n+#endif"}, {"sha": "1a43759e38ae12ac493327bab7f9289a7221dd0b", "filename": "libsanitizer/sanitizer_common/sanitizer_unwind_linux_libcdep.cpp", "status": "renamed", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_unwind_linux_libcdep.cc ---------------------------------===//\n+//===-- sanitizer_unwind_linux_libcdep.cpp --------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -26,7 +27,7 @@\n \n namespace __sanitizer {\n \n-//------------------------- SlowUnwindStack -----------------------------------\n+//---------------------------- UnwindSlow --------------------------------------\n \n typedef struct {\n   uptr absolute_pc;\n@@ -95,7 +96,7 @@ uptr Unwind_GetIP(struct _Unwind_Context *ctx) {\n   // Clear the Thumb bit.\n   return val & ~(uptr)1;\n #else\n-  return _Unwind_GetIP(ctx);\n+  return (uptr)_Unwind_GetIP(ctx);\n #endif\n }\n \n@@ -118,7 +119,7 @@ _Unwind_Reason_Code Unwind_Trace(struct _Unwind_Context *ctx, void *param) {\n   return UNWIND_CONTINUE;\n }\n \n-void BufferedStackTrace::SlowUnwindStack(uptr pc, u32 max_depth) {\n+void BufferedStackTrace::UnwindSlow(uptr pc, u32 max_depth) {\n   CHECK_GE(max_depth, 2);\n   size = 0;\n   UnwindTraceArg arg = {this, Min(max_depth + 1, kStackTraceMax)};\n@@ -143,11 +144,11 @@ void BufferedStackTrace::SlowUnwindStack(uptr pc, u32 max_depth) {\n #endif\n }\n \n-void BufferedStackTrace::SlowUnwindStackWithContext(uptr pc, void *context,\n-                                                    u32 max_depth) {\n+void BufferedStackTrace::UnwindSlow(uptr pc, void *context, u32 max_depth) {\n+  CHECK(context);\n   CHECK_GE(max_depth, 2);\n   if (!unwind_backtrace_signal_arch) {\n-    SlowUnwindStack(pc, max_depth);\n+    UnwindSlow(pc, max_depth);\n     return;\n   }\n ", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_unwind_linux_libcdep.cc"}, {"sha": "8e06940685dcb785098d8823cf516e6b73b0fc04", "filename": "libsanitizer/sanitizer_common/sanitizer_unwind_win.cpp", "status": "renamed", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_win.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_unwind_win.cc -------------------------------------------===//\n+//===-- sanitizer_unwind_win.cpp ------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -23,7 +24,7 @@\n using namespace __sanitizer;\n \n #if !SANITIZER_GO\n-void BufferedStackTrace::SlowUnwindStack(uptr pc, u32 max_depth) {\n+void BufferedStackTrace::UnwindSlow(uptr pc, u32 max_depth) {\n   CHECK_GE(max_depth, 2);\n   // FIXME: CaptureStackBackTrace might be too slow for us.\n   // FIXME: Compare with StackWalk64.\n@@ -38,8 +39,9 @@ void BufferedStackTrace::SlowUnwindStack(uptr pc, u32 max_depth) {\n   PopStackFrames(pc_location);\n }\n \n-void BufferedStackTrace::SlowUnwindStackWithContext(uptr pc, void *context,\n-  u32 max_depth) {\n+void BufferedStackTrace::UnwindSlow(uptr pc, void *context, u32 max_depth) {\n+  CHECK(context);\n+  CHECK_GE(max_depth, 2);\n   CONTEXT ctx = *(CONTEXT *)context;\n   STACKFRAME64 stack_frame;\n   memset(&stack_frame, 0, sizeof(stack_frame));", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_unwind_win.cc"}, {"sha": "4b9ae7db4c13414301a29928a8dec3884fdd41a1", "filename": "libsanitizer/sanitizer_common/sanitizer_vector.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_vector.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_vector.h -------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "c98e3d42f43fe6fb5230ddf0249cb52e25f0d955", "filename": "libsanitizer/sanitizer_common/sanitizer_win.cpp", "status": "renamed", "additions": 71, "deletions": 15, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_win.cc --------------------------------------------------===//\n+//===-- sanitizer_win.cpp -------------------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -30,6 +31,18 @@\n #if defined(PSAPI_VERSION) && PSAPI_VERSION == 1\n #pragma comment(lib, \"psapi\")\n #endif\n+#if SANITIZER_WIN_TRACE\n+#include <traceloggingprovider.h>\n+//  Windows trace logging provider init\n+#pragma comment(lib, \"advapi32.lib\")\n+TRACELOGGING_DECLARE_PROVIDER(g_asan_provider);\n+// GUID must be the same in utils/AddressSanitizerLoggingProvider.wprp\n+TRACELOGGING_DEFINE_PROVIDER(g_asan_provider, \"AddressSanitizerLoggingProvider\",\n+                             (0x6c6c766d, 0x3846, 0x4e6a, 0xa4, 0xfb, 0x5b,\n+                              0x53, 0x0b, 0xd0, 0xf3, 0xfa));\n+#else\n+#define TraceLoggingUnregister(x)\n+#endif\n \n // A macro to tell the compiler that this part of the code cannot be reached,\n // if the compiler supports this feature. Since we're using this in\n@@ -228,7 +241,7 @@ bool MmapFixedNoReserve(uptr fixed_addr, uptr size, const char *name) {\n \n // Memory space mapped by 'MmapFixedOrDie' must have been reserved by\n // 'MmapFixedNoAccess'.\n-void *MmapFixedOrDie(uptr fixed_addr, uptr size) {\n+void *MmapFixedOrDie(uptr fixed_addr, uptr size, const char *name) {\n   void *p = VirtualAlloc((LPVOID)fixed_addr, size,\n       MEM_COMMIT, PAGE_READWRITE);\n   if (p == 0) {\n@@ -242,11 +255,12 @@ void *MmapFixedOrDie(uptr fixed_addr, uptr size) {\n \n // Uses fixed_addr for now.\n // Will use offset instead once we've implemented this function for real.\n-uptr ReservedAddressRange::Map(uptr fixed_addr, uptr size) {\n+uptr ReservedAddressRange::Map(uptr fixed_addr, uptr size, const char *name) {\n   return reinterpret_cast<uptr>(MmapFixedOrDieOnFatalError(fixed_addr, size));\n }\n \n-uptr ReservedAddressRange::MapOrDie(uptr fixed_addr, uptr size) {\n+uptr ReservedAddressRange::MapOrDie(uptr fixed_addr, uptr size,\n+                                    const char *name) {\n   return reinterpret_cast<uptr>(MmapFixedOrDie(fixed_addr, size));\n }\n \n@@ -259,7 +273,7 @@ void ReservedAddressRange::Unmap(uptr addr, uptr size) {\n   UnmapOrDie(reinterpret_cast<void*>(addr), size);\n }\n \n-void *MmapFixedOrDieOnFatalError(uptr fixed_addr, uptr size) {\n+void *MmapFixedOrDieOnFatalError(uptr fixed_addr, uptr size, const char *name) {\n   void *p = VirtualAlloc((LPVOID)fixed_addr, size,\n       MEM_COMMIT, PAGE_READWRITE);\n   if (p == 0) {\n@@ -315,9 +329,8 @@ void ReleaseMemoryPagesToOS(uptr beg, uptr end) {\n   // FIXME: add madvise-analog when we move to 64-bits.\n }\n \n-bool NoHugePagesInRegion(uptr addr, uptr size) {\n+void SetShadowRegionHugePageMode(uptr addr, uptr size) {\n   // FIXME: probably similar to ReleaseMemoryToOS.\n-  return true;\n }\n \n bool DontDumpShadowMemory(uptr addr, uptr length) {\n@@ -485,8 +498,14 @@ bool IsPathSeparator(const char c) {\n   return c == '\\\\' || c == '/';\n }\n \n+static bool IsAlpha(char c) {\n+  c = ToLower(c);\n+  return c >= 'a' && c <= 'z';\n+}\n+\n bool IsAbsolutePath(const char *path) {\n-  UNIMPLEMENTED();\n+  return path != nullptr && IsAlpha(path[0]) && path[1] == ':' &&\n+         IsPathSeparator(path[2]);\n }\n \n void SleepForSeconds(int seconds) {\n@@ -644,6 +663,7 @@ int Atexit(void (*function)(void)) {\n }\n \n static int RunAtexit() {\n+  TraceLoggingUnregister(g_asan_provider);\n   int ret = 0;\n   for (uptr i = 0; i < atexit_functions.size(); ++i) {\n     ret |= atexit(atexit_functions[i]);\n@@ -735,16 +755,13 @@ bool WriteToFile(fd_t fd, const void *buff, uptr buff_size, uptr *bytes_written,\n   }\n }\n \n-bool RenameFile(const char *oldpath, const char *newpath, error_t *error_p) {\n-  UNIMPLEMENTED();\n-}\n-\n uptr internal_sched_yield() {\n   Sleep(0);\n   return 0;\n }\n \n void internal__exit(int exitcode) {\n+  TraceLoggingUnregister(g_asan_provider);\n   // ExitProcess runs some finalizers, so use TerminateProcess to avoid that.\n   // The debugger doesn't stop on TerminateProcess like it does on ExitProcess,\n   // so add our own breakpoint here.\n@@ -1006,6 +1023,10 @@ void CheckVMASize() {\n   // Do nothing.\n }\n \n+void InitializePlatformEarly() {\n+  // Do nothing.\n+}\n+\n void MaybeReexec() {\n   // No need to re-exec on Windows.\n }\n@@ -1014,17 +1035,26 @@ void CheckASLR() {\n   // Do nothing\n }\n \n+void CheckMPROTECT() {\n+  // Do nothing\n+}\n+\n char **GetArgv() {\n   // FIXME: Actually implement this function.\n   return 0;\n }\n \n+char **GetEnviron() {\n+  // FIXME: Actually implement this function.\n+  return 0;\n+}\n+\n pid_t StartSubprocess(const char *program, const char *const argv[],\n                       fd_t stdin_fd, fd_t stdout_fd, fd_t stderr_fd) {\n   // FIXME: implement on this platform\n   // Should be implemented based on\n   // SymbolizerProcess::StarAtSymbolizerSubprocess\n-  // from lib/sanitizer_common/sanitizer_symbolizer_win.cc.\n+  // from lib/sanitizer_common/sanitizer_symbolizer_win.cpp.\n   return -1;\n }\n \n@@ -1053,6 +1083,32 @@ u32 GetNumberOfCPUs() {\n   return sysinfo.dwNumberOfProcessors;\n }\n \n+#if SANITIZER_WIN_TRACE\n+// TODO(mcgov): Rename this project-wide to PlatformLogInit\n+void AndroidLogInit(void) {\n+  HRESULT hr = TraceLoggingRegister(g_asan_provider);\n+  if (!SUCCEEDED(hr))\n+    return;\n+}\n+\n+void SetAbortMessage(const char *) {}\n+\n+void LogFullErrorReport(const char *buffer) {\n+  if (common_flags()->log_to_syslog) {\n+    InternalMmapVector<wchar_t> filename;\n+    DWORD filename_length = 0;\n+    do {\n+      filename.resize(filename.size() + 0x100);\n+      filename_length =\n+          GetModuleFileNameW(NULL, filename.begin(), filename.size());\n+    } while (filename_length >= filename.size());\n+    TraceLoggingWrite(g_asan_provider, \"AsanReportEvent\",\n+                      TraceLoggingValue(filename.begin(), \"ExecutableName\"),\n+                      TraceLoggingValue(buffer, \"AsanReportContents\"));\n+  }\n+}\n+#endif // SANITIZER_WIN_TRACE\n+\n }  // namespace __sanitizer\n \n #endif  // _WIN32", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_win.cc"}, {"sha": "ff8939ca5e85579644f7b400b2edccaea7be2bbe", "filename": "libsanitizer/sanitizer_common/sanitizer_win.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_win.h -----------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "bcd94a08dc4412bb609fd9b877f4a2bdcc9fa089", "filename": "libsanitizer/sanitizer_common/sanitizer_win_defs.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_defs.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_win_defs.h ------------------------------------*- C++ -*-===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //"}, {"sha": "aa0eb4d43a4d065b2d79429f5dea73f95125fd97", "filename": "libsanitizer/sanitizer_common/sanitizer_win_dll_thunk.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_dll_thunk.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_dll_thunk.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_dll_thunk.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_win_dll_thunk.cc ----------------------------------------===//\n+//===-- sanitizer_win_dll_thunk.cpp ---------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n // This file defines a family of thunks that should be statically linked into", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_win_dll_thunk.cc"}, {"sha": "48c73c4c98ad56bdf1d807e2c8cbbd0be48ba0bc", "filename": "libsanitizer/sanitizer_common/sanitizer_win_dll_thunk.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_dll_thunk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_dll_thunk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_dll_thunk.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_win_dll_thunk.h -----------------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n // This header provide helper macros to delegate calls to the shared runtime"}, {"sha": "87c032c6e61bc9106433063a1ae3f4ba7f39cb32", "filename": "libsanitizer/sanitizer_common/sanitizer_win_dynamic_runtime_thunk.cpp", "status": "renamed", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_dynamic_runtime_thunk.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_dynamic_runtime_thunk.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_dynamic_runtime_thunk.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- santizer_win_dynamic_runtime_thunk.cc -----------------------------===//\n+//===-- santizer_win_dynamic_runtime_thunk.cpp ----------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n //\n@@ -17,3 +18,9 @@\n #define INTERFACE_WEAK_FUNCTION(Name) WIN_WEAK_IMPORT_DEF(Name)\n #include \"sanitizer_common_interface.inc\"\n #endif // SANITIZER_DYNAMIC_RUNTIME_THUNK\n+\n+namespace __sanitizer {\n+// Add one, otherwise unused, external symbol to this object file so that the\n+// Visual C++ linker includes it and reads the .drective section.\n+void ForceWholeArchiveIncludeForSanitizerCommon() {}\n+}", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_win_dynamic_runtime_thunk.cc"}, {"sha": "a6f34c27788b9df818c5d5e0ea8f625e5c95adc9", "filename": "libsanitizer/sanitizer_common/sanitizer_win_weak_interception.cpp", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_weak_interception.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_weak_interception.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_weak_interception.cpp?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n-//===-- sanitizer_win_weak_interception.cc --------------------------------===//\n+//===-- sanitizer_win_weak_interception.cpp -------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n // This module should be included in the sanitizer when it is implemented as a", "previous_filename": "libsanitizer/sanitizer_common/sanitizer_win_weak_interception.cc"}, {"sha": "5e4d8b8def3e7da74b9f6dcb075cf7d149f1fcc4", "filename": "libsanitizer/sanitizer_common/sanitizer_win_weak_interception.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_weak_interception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b667dd7017a8f9d36d3ab266f22290d75fa527b0/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_weak_interception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win_weak_interception.h?ref=b667dd7017a8f9d36d3ab266f22290d75fa527b0", "patch": "@@ -1,7 +1,8 @@\n //===-- sanitizer_win_weak_interception.h ---------------------------------===//\n //\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n //\n //===----------------------------------------------------------------------===//\n // This header provide helper macros to delegate calls of weak functions to the"}]}