{"sha": "5401050bd5d50fd5d66a378afe4f6eda697d5484", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQwMTA1MGJkNWQ1MGZkNWQ2NmEzNzhhZmU0ZjZlZGE2OTdkNTQ4NA==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2006-01-11T00:07:16Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2006-01-11T00:07:16Z"}, "message": "re PR target/20754 (ACATS cxg1005 fails at runtime on hppa-linux)\n\n\tPR target/20754\n\t* pa.md: Create separate 32 and 64-bit move patterns for SI, DI, SF\n\tand DF modes.  Add alternatives to copy between general and floating\n\tpoint registers to the 32-bit patterns.\n\t* pa-64.h (SECONDARY_MEMORY_NEEDED_RTX): Delete undefine.\n\t* pa.h (SECONDARY_MEMORY_NEEDED_RTX): Delete define.\n\t(SECONDARY_MEMORY_NEEDED): Secondary memory is only needed when\n\tgenerating 64-bit code.\n\t* pa.c (output_move_double): Handle copies between general and\n\tfloating registers.\n\nFrom-SVN: r109557", "tree": {"sha": "a957155246dc29dc5494f727934fd6001f0f94b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a957155246dc29dc5494f727934fd6001f0f94b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5401050bd5d50fd5d66a378afe4f6eda697d5484", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5401050bd5d50fd5d66a378afe4f6eda697d5484", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5401050bd5d50fd5d66a378afe4f6eda697d5484", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5401050bd5d50fd5d66a378afe4f6eda697d5484/comments", "author": null, "committer": null, "parents": [{"sha": "7d0720375952abd2c48d95f4cf752eff7d732e48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d0720375952abd2c48d95f4cf752eff7d732e48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d0720375952abd2c48d95f4cf752eff7d732e48"}], "stats": {"total": 146, "additions": 116, "deletions": 30}, "files": [{"sha": "e4a8ce86f5e4219ec816314d4478392eb607c646", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5401050bd5d50fd5d66a378afe4f6eda697d5484/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5401050bd5d50fd5d66a378afe4f6eda697d5484/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5401050bd5d50fd5d66a378afe4f6eda697d5484", "patch": "@@ -1,3 +1,16 @@\n+2006-01-10  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR target/20754\n+\t* pa.md: Create separate 32 and 64-bit move patterns for SI, DI, SF\n+\tand DF modes.  Add alternatives to copy between general and floating\n+\tpoint registers to the 32-bit patterns.\n+\t* pa-64.h (SECONDARY_MEMORY_NEEDED_RTX): Delete undefine.\n+\t* pa.h (SECONDARY_MEMORY_NEEDED_RTX): Delete define.\n+\t(SECONDARY_MEMORY_NEEDED): Secondary memory is only needed when\n+\tgenerating 64-bit code.\n+\t* pa.c (output_move_double): Handle copies between general and\n+\tfloating registers.\n+\n 2006-01-10  Stuart Hastings  <stuart@apple.com>\n \n \t* gcc/config/i386/i386.md (set_got): Update."}, {"sha": "750b13ca0329dc04fc16900401dd56230b27153e", "filename": "gcc/config/pa/pa-64.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5401050bd5d50fd5d66a378afe4f6eda697d5484/gcc%2Fconfig%2Fpa%2Fpa-64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5401050bd5d50fd5d66a378afe4f6eda697d5484/gcc%2Fconfig%2Fpa%2Fpa-64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-64.h?ref=5401050bd5d50fd5d66a378afe4f6eda697d5484", "patch": "@@ -70,10 +70,6 @@ Boston, MA 02110-1301, USA.  */\n    relocs which appear in stabs.  */\n #undef DBX_DEBUGGING_INFO\n \n-/* We want the compiler to select a suitable secondary memory location.\n-   ?!? This may not work reliably.  Keep an eye out for problems.  */\n-#undef SECONDARY_MEMORY_NEEDED_RTX\n-\n /* ?!? This needs to be made compile-time selectable.\n \n    The PA64 runtime model has arguments that grow to higher addresses"}, {"sha": "0d8ec24c1f9eac345e9815bfbca7eabd561b28b9", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5401050bd5d50fd5d66a378afe4f6eda697d5484/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5401050bd5d50fd5d66a378afe4f6eda697d5484/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=5401050bd5d50fd5d66a378afe4f6eda697d5484", "patch": "@@ -2209,6 +2209,25 @@ output_move_double (rtx *operands)\n      supposed to allow to happen.  */\n   gcc_assert (optype0 == REGOP || optype1 == REGOP);\n \n+  /* Handle copies between general and floating registers.  */\n+\n+  if (optype0 == REGOP && optype1 == REGOP\n+      && FP_REG_P (operands[0]) ^ FP_REG_P (operands[1]))\n+    {\n+      if (FP_REG_P (operands[0]))\n+\t{\n+\t  output_asm_insn (\"{stws|stw} %1,-16(%%sp)\", operands);\n+\t  output_asm_insn (\"{stws|stw} %R1,-12(%%sp)\", operands);\n+\t  return \"{fldds|fldd} -16(%%sp),%0\";\n+\t}\n+      else\n+\t{\n+\t  output_asm_insn (\"{fstds|fstd} %1,-16(%%sp)\", operands);\n+\t  output_asm_insn (\"{ldws|ldw} -16(%%sp),%0\", operands);\n+\t  return \"{ldws|ldw} -12(%%sp),%R0\";\n+\t}\n+    }\n+\n    /* Handle auto decrementing and incrementing loads and stores\n      specifically, since the structure of the function doesn't work\n      for them without major modification.  Do it better when we learn"}, {"sha": "c29a8764eab089167a99dc216dced788d0d439d7", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5401050bd5d50fd5d66a378afe4f6eda697d5484/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5401050bd5d50fd5d66a378afe4f6eda697d5484/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=5401050bd5d50fd5d66a378afe4f6eda697d5484", "patch": "@@ -531,14 +531,15 @@ extern struct rtx_def *hppa_pic_save_rtx (void);\n   reg_classes_intersect_p ((CLASS), FP_REGS)\n \n /* On the PA it is not possible to directly move data between\n-   GENERAL_REGS and FP_REGS.  */\n-#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE)\t\t\\\n-  (MAYBE_FP_REG_CLASS_P (CLASS1) != FP_REG_CLASS_P (CLASS2)\t\\\n-   || MAYBE_FP_REG_CLASS_P (CLASS2) != FP_REG_CLASS_P (CLASS1))\n-\n-/* Return the stack location to use for secondary memory needed reloads.  */\n-#define SECONDARY_MEMORY_NEEDED_RTX(MODE) \\\n-  gen_rtx_MEM (MODE, gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (-16)))\n+   GENERAL_REGS and FP_REGS.  On the 32-bit port, we use the\n+   location at SP-16.  We don't expose this location in the RTL to\n+   avoid scheduling related problems.  For example, the store and\n+   load could be separated by a call to a pure or const function\n+   which has no frame and uses SP-16.  */\n+#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE)\t\t\t\\\n+  (TARGET_64BIT\t\t\t\t\t\t\t\t\\\n+   && (MAYBE_FP_REG_CLASS_P (CLASS1) != FP_REG_CLASS_P (CLASS2)\t\t\\\n+       || MAYBE_FP_REG_CLASS_P (CLASS2) != FP_REG_CLASS_P (CLASS1)))\n \n \f\n /* Stack layout; function entry, exit and calling.  */"}, {"sha": "b51feb0ee162f510ac6a3879b3429aa6ffb3e052", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 75, "deletions": 18, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5401050bd5d50fd5d66a378afe4f6eda697d5484/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5401050bd5d50fd5d66a378afe4f6eda697d5484/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=5401050bd5d50fd5d66a378afe4f6eda697d5484", "patch": "@@ -2305,14 +2305,43 @@\n   DONE;\n }\")\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"move_dest_operand\"\n+\t\t\t  \"=r,r,r,r,r,r,Q,!*q,!r,!*f,*f,T,r,f\")\n+\t(match_operand:SI 1 \"move_src_operand\"\n+\t\t\t  \"A,r,J,N,K,RQ,rM,!rM,!*q,!*fM,RT,*f,f,r\"))]\n+  \"(register_operand (operands[0], SImode)\n+    || reg_or_0_operand (operands[1], SImode))\n+   && !TARGET_SOFT_FLOAT\n+   && !TARGET_64BIT\"\n+  \"@\n+   ldw RT'%A1,%0\n+   copy %1,%0\n+   ldi %1,%0\n+   ldil L'%1,%0\n+   {zdepi|depwi,z} %Z1,%0\n+   ldw%M1 %1,%0\n+   stw%M0 %r1,%0\n+   mtsar %r1\n+   {mfctl|mfctl,w} %%sar,%0\n+   fcpy,sgl %f1,%0\n+   fldw%F1 %1,%0\n+   fstw%F0 %1,%0\n+   {fstws|fstw} %1,-16(%%sp)\\n\\t{ldws|ldw} -16(%%sp),%0\n+   {stws|stw} %1,-16(%%sp)\\n\\t{fldws|fldw} -16(%%sp),%0\"\n+  [(set_attr \"type\" \"load,move,move,move,shift,load,store,move,move,fpalu,fpload,fpstore,move,move\")\n+   (set_attr \"pa_combine_type\" \"addmove\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,4,4,8,8\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"move_dest_operand\"\n \t\t\t  \"=r,r,r,r,r,r,Q,!*q,!r,!*f,*f,T\")\n \t(match_operand:SI 1 \"move_src_operand\"\n \t\t\t  \"A,r,J,N,K,RQ,rM,!rM,!*q,!*fM,RT,*f\"))]\n   \"(register_operand (operands[0], SImode)\n     || reg_or_0_operand (operands[1], SImode))\n-   && !TARGET_SOFT_FLOAT\"\n+   && !TARGET_SOFT_FLOAT\n+   && TARGET_64BIT\"\n   \"@\n    ldw RT'%A1,%0\n    copy %1,%0\n@@ -3840,9 +3869,9 @@\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"move_dest_operand\"\n-\t\t\t  \"=f,*r,Q,?o,?Q,f,*r,*r\")\n+\t\t\t  \"=f,*r,Q,?o,?Q,f,*r,*r,r,f\")\n \t(match_operand:DF 1 \"reg_or_0_or_nonsymb_mem_operand\"\n-\t\t\t  \"fG,*rG,f,*r,*r,RQ,o,RQ\"))]\n+\t\t\t  \"fG,*rG,f,*r,*r,RQ,o,RQ,f,r\"))]\n   \"(register_operand (operands[0], DFmode)\n     || reg_or_0_operand (operands[1], DFmode))\n    && !(GET_CODE (operands[1]) == CONST_DOUBLE\n@@ -3851,13 +3880,15 @@\n    && !TARGET_SOFT_FLOAT\"\n   \"*\n {\n-  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1])\n-      || operands[1] == CONST0_RTX (DFmode))\n+  if ((FP_REG_P (operands[0]) || FP_REG_P (operands[1])\n+       || operands[1] == CONST0_RTX (DFmode))\n+      && !(REG_P (operands[0]) && REG_P (operands[1])\n+\t   && FP_REG_P (operands[0]) ^ FP_REG_P (operands[1])))\n     return output_fp_move_double (operands);\n   return output_move_double (operands);\n }\"\n-  [(set_attr \"type\" \"fpalu,move,fpstore,store,store,fpload,load,load\")\n-   (set_attr \"length\" \"4,8,4,8,16,4,8,16\")])\n+  [(set_attr \"type\" \"fpalu,move,fpstore,store,store,fpload,load,load,move,move\")\n+   (set_attr \"length\" \"4,8,4,8,16,4,8,16,12,12\")])\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"indexed_memory_operand\" \"=R\")\n@@ -4012,9 +4043,9 @@\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"move_dest_operand\"\n-\t\t\t  \"=r,?o,?Q,r,r\")\n+\t\t\t  \"=r,?o,?Q,r,r,r,f\")\n \t(match_operand:DF 1 \"reg_or_0_or_nonsymb_mem_operand\"\n-\t\t\t  \"rG,r,r,o,RQ\"))]\n+\t\t\t  \"rG,r,r,o,RQ,f,r\"))]\n   \"(register_operand (operands[0], DFmode)\n     || reg_or_0_operand (operands[1], DFmode))\n    && !TARGET_64BIT\n@@ -4023,8 +4054,8 @@\n {\n   return output_move_double (operands);\n }\"\n-  [(set_attr \"type\" \"move,store,store,load,load\")\n-   (set_attr \"length\" \"8,8,16,8,16\")])\n+  [(set_attr \"type\" \"move,store,store,load,load,move,move\")\n+   (set_attr \"length\" \"8,8,16,8,16,12,12\")])\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"move_dest_operand\"\n@@ -4154,22 +4185,25 @@\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"move_dest_operand\"\n-\t\t\t  \"=r,o,Q,r,r,r,*f,*f,T\")\n+\t\t\t  \"=r,o,Q,r,r,r,*f,*f,T,r,f\")\n \t(match_operand:DI 1 \"general_operand\"\n-\t\t\t  \"rM,r,r,o*R,Q,i,*fM,RT,*f\"))]\n+\t\t\t  \"rM,r,r,o*R,Q,i,*fM,RT,*f,f,r\"))]\n   \"(register_operand (operands[0], DImode)\n     || reg_or_0_operand (operands[1], DImode))\n    && !TARGET_64BIT\n    && !TARGET_SOFT_FLOAT\"\n   \"*\n {\n-  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1])\n-      || (operands[1] == CONST0_RTX (DImode)))\n+  if ((FP_REG_P (operands[0]) || FP_REG_P (operands[1])\n+       || operands[1] == CONST0_RTX (DFmode))\n+      && !(REG_P (operands[0]) && REG_P (operands[1])\n+\t   && FP_REG_P (operands[0]) ^ FP_REG_P (operands[1])))\n     return output_fp_move_double (operands);\n   return output_move_double (operands);\n }\"\n-  [(set_attr \"type\" \"move,store,store,load,load,multi,fpalu,fpload,fpstore\")\n-   (set_attr \"length\" \"8,8,16,8,16,16,4,4,4\")])\n+  [(set_attr \"type\"\n+    \"move,store,store,load,load,multi,fpalu,fpload,fpstore,move,move\")\n+   (set_attr \"length\" \"8,8,16,8,16,16,4,4,4,12,12\")])\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"move_dest_operand\"\n@@ -4378,14 +4412,37 @@\n   DONE;\n }\")\n \n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"move_dest_operand\"\n+\t\t\t  \"=f,!*r,f,*r,Q,Q,r,f\")\n+\t(match_operand:SF 1 \"reg_or_0_or_nonsymb_mem_operand\"\n+\t\t\t  \"fG,!*rG,RQ,RQ,f,*rG,f,r\"))]\n+  \"(register_operand (operands[0], SFmode)\n+    || reg_or_0_operand (operands[1], SFmode))\n+   && !TARGET_SOFT_FLOAT\n+   && !TARGET_64BIT\"\n+  \"@\n+   fcpy,sgl %f1,%0\n+   copy %r1,%0\n+   fldw%F1 %1,%0\n+   ldw%M1 %1,%0\n+   fstw%F0 %1,%0\n+   stw%M0 %r1,%0\n+   {fstws|fstw} %1,-16(%%sp)\\n\\t{ldws|ldw} -16(%%sp),%0\n+   {stws|stw} %1,-16(%%sp)\\n\\t{fldws|fldw} -16(%%sp),%0\"\n+  [(set_attr \"type\" \"fpalu,move,fpload,load,fpstore,store,move,move\")\n+   (set_attr \"pa_combine_type\" \"addmove\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,8,8\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"move_dest_operand\"\n \t\t\t  \"=f,!*r,f,*r,Q,Q\")\n \t(match_operand:SF 1 \"reg_or_0_or_nonsymb_mem_operand\"\n \t\t\t  \"fG,!*rG,RQ,RQ,f,*rG\"))]\n   \"(register_operand (operands[0], SFmode)\n     || reg_or_0_operand (operands[1], SFmode))\n-   && !TARGET_SOFT_FLOAT\"\n+   && !TARGET_SOFT_FLOAT\n+   && TARGET_64BIT\"\n   \"@\n    fcpy,sgl %f1,%0\n    copy %r1,%0"}]}