{"sha": "bfa30b22c7637187d60bc8a85ec3fee005fccbc4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZhMzBiMjJjNzYzNzE4N2Q2MGJjOGE4NWVjM2ZlZTAwNWZjY2JjNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-05-12T02:51:59Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-05-12T02:51:59Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r961", "tree": {"sha": "44fb64872887b03a3f10b09ea55576a754cdfb8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44fb64872887b03a3f10b09ea55576a754cdfb8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfa30b22c7637187d60bc8a85ec3fee005fccbc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfa30b22c7637187d60bc8a85ec3fee005fccbc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfa30b22c7637187d60bc8a85ec3fee005fccbc4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfa30b22c7637187d60bc8a85ec3fee005fccbc4/comments", "author": null, "committer": null, "parents": [{"sha": "3351cb0051c003c9b5c018ad5509033fc9e00235", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3351cb0051c003c9b5c018ad5509033fc9e00235", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3351cb0051c003c9b5c018ad5509033fc9e00235"}], "stats": {"total": 169, "additions": 125, "deletions": 44}, "files": [{"sha": "00c33802059fac3169d7cab501f5badef31b107a", "filename": "gcc/cccp.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa30b22c7637187d60bc8a85ec3fee005fccbc4/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa30b22c7637187d60bc8a85ec3fee005fccbc4/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=bfa30b22c7637187d60bc8a85ec3fee005fccbc4", "patch": "@@ -333,9 +333,6 @@ static enum {dump_none, dump_only, dump_names, dump_definitions}\n    where they are defined.  */\n static int debug_output = 0;\n \n-/* Holds local startup time.  */\n-static struct tm *timebuf = NULL;\n-\n /* Nonzero indicates special processing used by the pcp program.  The\n    special effects of this mode are: \n      \n@@ -3433,6 +3430,17 @@ handle_directive (ip, op)\n   return 0;\n }\n \f\n+static struct tm *\n+timestamp ()\n+{\n+  static struct tm *timebuf;\n+  if (!timebuf) {\n+    time_t t = time (0);\n+    timebuf = localtime (&t);\n+  }\n+  return timebuf;\n+}\n+\n static char *monthnames[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n \t\t\t     \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\",\n \t\t\t    };\n@@ -3451,6 +3459,7 @@ special_symbol (hp, op)\n   int i, len;\n   int true_indepth;\n   FILE_BUF *ip = NULL;\n+  struct tm *timebuf;\n \n   int paren = 0;\t\t/* For special `defined' keyword */\n \n@@ -3536,6 +3545,7 @@ special_symbol (hp, op)\n   case T_DATE:\n   case T_TIME:\n     buf = (char *) alloca (20);\n+    timebuf = timestamp ();\n     if (hp->type == T_DATE)\n       sprintf (buf, \"\\\"%s %2d %4d\\\"\", monthnames[timebuf->tm_mon],\n \t      timebuf->tm_mday, timebuf->tm_year + 1900);\n@@ -8055,11 +8065,6 @@ initialize_builtins (inp, outp)\n      FILE_BUF *inp;\n      FILE_BUF *outp;\n {\n-  time_t t;\n-\n-  t = time (0);\n-  timebuf = localtime (&t);\n-\n   install (\"__LINE__\", -1, T_SPECLINE, 0, -1);\n   install (\"__DATE__\", -1, T_DATE, 0, -1);\n   install (\"__FILE__\", -1, T_FILE, 0, -1);\n@@ -8082,6 +8087,7 @@ initialize_builtins (inp, outp)\n     {\n       char directive[2048];\n       register struct directive *dp = &directive_table[0];\n+      struct tm *timebuf = timestamp ();\n \n       sprintf (directive, \" __BASE_FILE__ \\\"%s\\\"\\n\",\n \t       instack[0].nominal_fname);"}, {"sha": "fae93a1a3948d99c352620344ab31d10acba7527", "filename": "gcc/integrate.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa30b22c7637187d60bc8a85ec3fee005fccbc4/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa30b22c7637187d60bc8a85ec3fee005fccbc4/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=bfa30b22c7637187d60bc8a85ec3fee005fccbc4", "patch": "@@ -1040,7 +1040,7 @@ rtx *global_const_equiv_map;\n /* Integrate the procedure defined by FNDECL.  Note that this function\n    may wind up calling itself.  Since the static variables are not\n    reentrant, we do not assign them until after the possibility\n-   or recursion is eliminated.\n+   of recursion is eliminated.\n \n    If IGNORE is nonzero, do not produce a value.\n    Otherwise store the value in TARGET if it is nonzero and that is convenient.\n@@ -1557,6 +1557,7 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n \n \tcase CODE_LABEL:\n \t  copy = emit_label (map->label_map[CODE_LABEL_NUMBER (insn)]);\n+\t  LABEL_NAME (copy) = LABEL_NAME (insn);\n \t  map->const_age++;\n \t  break;\n "}, {"sha": "4bc377019c0cbc4ee4913b12cba2d1ac5489ce17", "filename": "gcc/reload.c", "status": "modified", "additions": 82, "deletions": 14, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa30b22c7637187d60bc8a85ec3fee005fccbc4/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa30b22c7637187d60bc8a85ec3fee005fccbc4/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=bfa30b22c7637187d60bc8a85ec3fee005fccbc4", "patch": "@@ -547,7 +547,7 @@ push_reload (in, out, inloc, outloc, class,\n   /* If IN appears in OUT, we can't share any input-only reload for IN.  */\n   if (in != 0 && out != 0 && GET_CODE (out) == MEM\n       && (GET_CODE (in) == REG || GET_CODE (in) == MEM)\n-      && reg_overlap_mentioned_p (in, XEXP (out, 0)))\n+      && reg_overlap_mentioned_for_reload_p (in, XEXP (out, 0)))\n     dont_share = 1;\n \n   /* Narrow down the class of register wanted if that is\n@@ -1104,17 +1104,17 @@ combine_reloads ()\n \t    /* Args reversed because the first arg seems to be\n \t       the one that we imagine being modified\n \t       while the second is the one that might be affected.  */\n-\t    || (! reg_overlap_mentioned_p (reload_out[output_reload],\n-\t\t\t\t\t   reload_in[i])\n+\t    || (! reg_overlap_mentioned_for_reload_p (reload_out[output_reload],\n+\t\t\t\t\t\t      reload_in[i])\n \t\t/* However, if the input is a register that appears inside\n \t\t   the output, then we also can't share.\n \t\t   Imagine (set (mem (reg 69)) (plus (reg 69) ...)).\n \t\t   If the same reload reg is used for both reg 69 and the\n \t\t   result to be stored in memory, then that result\n \t\t   will clobber the address of the memory ref.  */\n \t\t&& ! (GET_CODE (reload_in[i]) == REG\n-\t\t      && reg_overlap_mentioned_p (reload_in[i],\n-\t\t\t\t\t\t  reload_out[output_reload])))))\n+\t\t      && reg_overlap_mentioned_for_reload_p (reload_in[i],\n+\t\t\t\t\t\t\t     reload_out[output_reload])))))\n       {\n \tint j;\n \n@@ -1162,8 +1162,8 @@ combine_reloads ()\n   for (note = REG_NOTES (this_insn); note; note = XEXP (note, 1))\n     if (REG_NOTE_KIND (note) == REG_DEAD\n \t&& GET_CODE (XEXP (note, 0)) == REG\n-\t&& ! reg_overlap_mentioned_p (XEXP (note, 0),\n-\t\t\t\t      reload_out[output_reload])\n+\t&& ! reg_overlap_mentioned_for_reload_p (XEXP (note, 0),\n+\t\t\t\t\t\t reload_out[output_reload])\n \t&& REGNO (XEXP (note, 0)) < FIRST_PSEUDO_REGISTER\n \t&& HARD_REGNO_MODE_OK (REGNO (XEXP (note, 0)), reload_outmode[output_reload])\n \t&& TEST_HARD_REG_BIT (reg_class_contents[(int) reload_reg_class[output_reload]],\n@@ -4343,6 +4343,70 @@ refers_to_regno_for_reload_p (regno, endregno, x, loc)\n     }\n   return 0;\n }\n+\n+/* Nonzero if modifying X will affect IN.  If X is a register or a SUBREG,\n+   we check if any register number in X conflicts with the relevant register\n+   numbers.  If X is a constant, return 0.  If X is a MEM, return 1 iff IN\n+   contains a MEM (we don't bother checking for memory addresses that can't\n+   conflict because we expect this to be a rare case. \n+\n+   This function is similar to reg_overlap_mention_p in rtlanal.c except\n+   that we look at equivalences for pseudos that didn't get hard registers.  */\n+\n+int\n+reg_overlap_mentioned_for_reload_p (x, in)\n+     rtx x, in;\n+{\n+  int regno, endregno;\n+\n+  if (GET_CODE (x) == SUBREG)\n+    {\n+      regno = REGNO (SUBREG_REG (x));\n+      if (regno < FIRST_PSEUDO_REGISTER)\n+\tregno += SUBREG_WORD (x);\n+    }\n+  else if (GET_CODE (x) == REG)\n+    {\n+      regno = REGNO (x);\n+      if (regno >= FIRST_PSEUDO_REGISTER && reg_renumber[regno] == -1\n+\t  && ((reg_equiv_address[regno]\n+\t       && reg_overlap_mentioned_for_reload_p (reg_equiv_address[regno],\n+\t\t\t\t\t\t      in))\n+\t      || (reg_equiv_mem[regno]\n+\t\t  && reg_overlap_mentioned_for_reload_p (reg_equiv_mem[regno],\n+\t\t\t\t\t\t\t in))))\n+\treturn 1;\n+    }\n+  else if (CONSTANT_P (x))\n+    return 0;\n+  else if (GET_CODE (x) == MEM)\n+    {\n+      char *fmt;\n+      int i;\n+\n+      if (GET_CODE (in) == MEM)\n+\treturn 1;\n+\n+      fmt = GET_RTX_FORMAT (GET_CODE (in));\n+\n+      for (i = GET_RTX_LENGTH (GET_CODE (in)) - 1; i >= 0; i--)\n+\tif (fmt[i] == 'e' && reg_overlap_mentioned_for_reload_p (x,\n+\t\t\t\t\t\t\t\t XEXP (in, i)))\n+\t  return 1;\n+\n+      return 0;\n+    }\n+  else if (GET_CODE (x) == SCRATCH || GET_CODE (x) == PC\n+\t   || GET_CODE (x) == CC0)\n+    return reg_mentioned_p (x, in);\n+  else\n+    abort ();\n+\n+  endregno = regno + (regno < FIRST_PSEUDO_REGISTER\n+\t\t      ? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n+\n+  return refers_to_regno_for_reload_p (regno, endregno, in, 0);\n+}\n \f\n #if 0\n \n@@ -4584,7 +4648,8 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n   /* If we propose to get the value from the stack pointer or if GOAL is\n      a MEM based on the stack pointer, we need a stable SP.  */\n   if (valueno == STACK_POINTER_REGNUM\n-      || (goal_mem && reg_overlap_mentioned_p (stack_pointer_rtx, goal)))\n+      || (goal_mem && reg_overlap_mentioned_for_reload_p (stack_pointer_rtx,\n+\t\t\t\t\t\t\t  goal)))\n     need_stable_sp = 1;\n \n   /* Reject VALUE if the copy-insn moved the wrong sort of datum.  */\n@@ -4595,9 +4660,10 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n      and is also a register that appears in the address of GOAL.  */\n \n   if (goal_mem && value == SET_DEST (PATTERN (where))\n-      && refers_to_regno_p (valueno,\n-\t\t\t    valueno + HARD_REGNO_NREGS (valueno, mode),\n-\t\t\t    goal, 0))\n+      && refers_to_regno_for_reload_p (valueno,\n+\t\t\t\t       (valueno\n+\t\t\t\t\t+ HARD_REGNO_NREGS (valueno, mode)),\n+\t\t\t\t       goal, 0))\n     return 0;\n \n   /* Reject registers that overlap GOAL.  */\n@@ -4710,7 +4776,7 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \t\t      && xregno + xnregs > valueno)\n \t\t    return 0;\n \t\t  if (goal_mem_addr_varies\n-\t\t      && reg_overlap_mentioned_p (dest, goal))\n+\t\t      && reg_overlap_mentioned_for_reload_p (dest, goal))\n \t\t    return 0;\n \t\t}\n \t      else if (goal_mem && GET_CODE (dest) == MEM\n@@ -4748,7 +4814,8 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \t\t\t      && xregno + xnregs > valueno)\n \t\t\t    return 0;\n \t\t\t  if (goal_mem_addr_varies\n-\t\t\t      && reg_overlap_mentioned_p (dest, goal))\n+\t\t\t      && reg_overlap_mentioned_for_reload_p (dest,\n+\t\t\t\t\t\t\t\t     goal))\n \t\t\t    return 0;\n \t\t\t}\n \t\t      else if (goal_mem && GET_CODE (dest) == MEM\n@@ -4779,7 +4846,8 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \t\t  if (incno < valueno + valuenregs && incno >= valueno)\n \t\t    return 0;\n \t\t  if (goal_mem_addr_varies\n-\t\t      && reg_overlap_mentioned_p (XEXP (link, 0), goal))\n+\t\t      && reg_overlap_mentioned_for_reload_p (XEXP (link, 0),\n+\t\t\t\t\t\t\t     goal))\n \t\t    return 0;\n \t\t}\n \t  }"}, {"sha": "127b22dcdbcfdb0b18c7504ddbf144b3ef8f3cf5", "filename": "gcc/reload1.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa30b22c7637187d60bc8a85ec3fee005fccbc4/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa30b22c7637187d60bc8a85ec3fee005fccbc4/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=bfa30b22c7637187d60bc8a85ec3fee005fccbc4", "patch": "@@ -4272,7 +4272,8 @@ choose_reload_regs (insn, avoid_return_reg)\n \n \t      if (equiv != 0)\n \t\tfor (i = 0; i < n_earlyclobbers; i++)\n-\t\t  if (reg_overlap_mentioned_p (equiv, reload_earlyclobbers[i]))\n+\t\t  if (reg_overlap_mentioned_for_reload_p (equiv,\n+\t\t\t\t\t\t\t  reload_earlyclobbers[i]))\n \t\t    {\n \t\t      reload_override_in[r] = equiv;\n \t\t      equiv = 0;\n@@ -4600,7 +4601,8 @@ emit_reload_insns (insn)\n \t\t  int k;\n \t\t  for (k = 0; k < n_reloads; k++)\n \t\t    if (reload_reg_rtx[k] != 0 && k != j\n-\t\t\t&& reg_overlap_mentioned_p (reload_reg_rtx[k], oldequiv))\n+\t\t\t&& reg_overlap_mentioned_for_reload_p (reload_reg_rtx[k],\n+\t\t\t\t\t\t\t       oldequiv))\n \t\t      {\n \t\t\toldequiv = 0;\n \t\t\tbreak;\n@@ -4879,8 +4881,8 @@ emit_reload_insns (insn)\n \t\t       prev != PREV_INSN (this_reload_insn);\n \t\t       prev = PREV_INSN (prev))\n \t\t    if (GET_RTX_CLASS (GET_CODE (prev) == 'i')\n-\t\t\t&& reg_overlap_mentioned_p (second_reload_reg,\n-\t\t\t\t\t\t    PATTERN (prev)))\n+\t\t\t&& reg_overlap_mentioned_for_reload_p (second_reload_reg,\n+\t\t\t\t\t\t\t       PATTERN (prev)))\n \t\t      {\n \t\t\tREG_NOTES (prev) = gen_rtx (EXPR_LIST, REG_DEAD,\n \t\t\t\t\t\t    second_reload_reg,\n@@ -5008,8 +5010,8 @@ emit_reload_insns (insn)\n \t\t    for (prev1 = this_reload_insn;\n \t\t\t prev1; prev1 = PREV_INSN (prev1))\n \t\t      if (GET_RTX_CLASS (GET_CODE (prev1) == 'i')\n-\t\t\t&& reg_overlap_mentioned_p (oldequiv_reg,\n-\t\t\t\t\t\t    PATTERN (prev1)))\n+\t\t\t&& reg_overlap_mentioned_for_reload_p (oldequiv_reg,\n+\t\t\t\t\t\t\t       PATTERN (prev1)))\n \t\t      {\n \t\t\tREG_NOTES (prev1) = gen_rtx (EXPR_LIST, REG_DEAD,\n \t\t\t\t\t\t     oldequiv_reg,\n@@ -5190,7 +5192,8 @@ emit_reload_insns (insn)\n \t    for (p = PREV_INSN (first_output_reload_insn);\n \t\t p != prev_insn; p = PREV_INSN (p))\n \t      if (GET_RTX_CLASS (GET_CODE (p)) == 'i'\n-\t\t  && reg_overlap_mentioned_p (reloadreg, PATTERN (p)))\n+\t\t  && reg_overlap_mentioned_for_reload_p (reloadreg,\n+\t\t\t\t\t\t\t PATTERN (p)))\n \t\tREG_NOTES (p) = gen_rtx (EXPR_LIST, REG_DEAD,\n \t\t\t\t\t reloadreg, REG_NOTES (p));\n \n@@ -5200,7 +5203,8 @@ emit_reload_insns (insn)\n \t    for (p = PREV_INSN (first_output_reload_insn);\n \t\t p != prev_insn; p = PREV_INSN (p))\n \t      if (GET_RTX_CLASS (GET_CODE (p)) == 'i'\n-\t\t  && reg_overlap_mentioned_p (second_reloadreg, PATTERN (p)))\n+\t\t  && reg_overlap_mentioned_for_reload_p (second_reloadreg,\n+\t\t\t\t\t\t\t PATTERN (p)))\n \t\tREG_NOTES (p) = gen_rtx (EXPR_LIST, REG_DEAD,\n \t\t\t\t\t second_reloadreg, REG_NOTES (p));\n #endif\n@@ -5253,8 +5257,10 @@ emit_reload_insns (insn)\n \t      if (REG_NOTE_KIND (reg_notes) == REG_DEAD\n \t\t  && GET_CODE (XEXP (reg_notes, 0)) == REG\n \t\t  && ((GET_CODE (dest) != REG\n-\t\t       && reg_overlap_mentioned_p (XEXP (reg_notes, 0), dest))\n-\t\t      || reg_overlap_mentioned_p (XEXP (reg_notes, 0), source)))\n+\t\t       && reg_overlap_mentioned_for_reload_p (XEXP (reg_notes, 0),\n+\t\t\t\t\t\t\t      dest))\n+\t\t      || reg_overlap_mentioned_for_reload_p (XEXP (reg_notes, 0),\n+\t\t\t\t\t\t\t     source)))\n \t\t{\n \t\t  *prev_reg_note = next_reg_notes;\n \t\t  XEXP (reg_notes, 1) = REG_NOTES (insn1);"}, {"sha": "5207ba1da02f4e082f0c34778b2dbcc5a3d8a07b", "filename": "gcc/tree.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa30b22c7637187d60bc8a85ec3fee005fccbc4/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa30b22c7637187d60bc8a85ec3fee005fccbc4/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=bfa30b22c7637187d60bc8a85ec3fee005fccbc4", "patch": "@@ -3104,22 +3104,22 @@ int_fits_type_p (c, type)\n \t    && !INT_CST_LT (c, TYPE_MIN_VALUE (type)));\n }\n \n-/* Return the innermost context enclosing FNDECL that is\n+/* Return the innermost context enclosing DECL that is\n    a FUNCTION_DECL, or zero if none.  */\n \n tree\n-decl_function_context (fndecl)\n-     tree fndecl;\n+decl_function_context (decl)\n+     tree decl;\n {\n   tree context;\n \n-  if (TREE_CODE (fndecl) == ERROR_MARK)\n+  if (TREE_CODE (decl) == ERROR_MARK)\n     return 0;\n \n-  if (TREE_CODE (fndecl) == SAVE_EXPR)\n-    context = SAVE_EXPR_CONTEXT (fndecl);\n+  if (TREE_CODE (decl) == SAVE_EXPR)\n+    context = SAVE_EXPR_CONTEXT (decl);\n   else\n-    context = DECL_CONTEXT (fndecl);\n+    context = DECL_CONTEXT (decl);\n \n   while (context && TREE_CODE (context) != FUNCTION_DECL)\n     {\n@@ -3138,15 +3138,15 @@ decl_function_context (fndecl)\n   return context;\n }\n \n-/* Return the innermost context enclosing FNDECL that is\n+/* Return the innermost context enclosing DECL that is\n    a RECORD_TYPE or UNION_TYPE, or zero if none.\n    TYPE_DECLs and FUNCTION_DECLs are transparent to this function.  */\n \n tree\n-decl_type_context (fndecl)\n-     tree fndecl;\n+decl_type_context (decl)\n+     tree decl;\n {\n-  tree context = DECL_CONTEXT (fndecl);\n+  tree context = DECL_CONTEXT (decl);\n \n   while (context)\n     {"}]}