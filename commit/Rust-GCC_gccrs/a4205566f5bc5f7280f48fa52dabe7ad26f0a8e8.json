{"sha": "a4205566f5bc5f7280f48fa52dabe7ad26f0a8e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQyMDU1NjZmNWJjNWY3MjgwZjQ4ZmE1MmRhYmU3YWQyNmYwYThlOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-11-26T19:14:06Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-11-26T19:14:06Z"}, "message": "(REG_OK_FOR_INDEX_P, REG_OK_FOR_BASE_P): Corrected.\n\n(ASM_OUTPUT_[datatype]): Corrected datalbl[].size computation\nfor output of arrays.\n\nFrom-SVN: r10595", "tree": {"sha": "f5a761a43fecfb2882244433461c3f55a4a20277", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5a761a43fecfb2882244433461c3f55a4a20277"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4205566f5bc5f7280f48fa52dabe7ad26f0a8e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4205566f5bc5f7280f48fa52dabe7ad26f0a8e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4205566f5bc5f7280f48fa52dabe7ad26f0a8e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4205566f5bc5f7280f48fa52dabe7ad26f0a8e8/comments", "author": null, "committer": null, "parents": [{"sha": "04ac5b95df838a19592df6405a56b58c0e1c7ee0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04ac5b95df838a19592df6405a56b58c0e1c7ee0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04ac5b95df838a19592df6405a56b58c0e1c7ee0"}], "stats": {"total": 69, "additions": 37, "deletions": 32}, "files": [{"sha": "997b6c61ca21ba3c9ca64310e6145656a198c927", "filename": "gcc/config/1750a/1750a.h", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4205566f5bc5f7280f48fa52dabe7ad26f0a8e8/gcc%2Fconfig%2F1750a%2F1750a.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4205566f5bc5f7280f48fa52dabe7ad26f0a8e8/gcc%2Fconfig%2F1750a%2F1750a.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.h?ref=a4205566f5bc5f7280f48fa52dabe7ad26f0a8e8", "patch": "@@ -205,8 +205,10 @@ extern char *strdup(), *float_label();\n    late and fixed registers last.  Note that, in general, we prefer\n    registers listed in CALL_USED_REGISTERS, keeping the others\n    available for storage of persistent values.  */\n+\n #define REG_ALLOC_ORDER \\\n    { 2, 0, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }\n+\n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n    This is ordinarily the length in words of a value of mode MODE\n@@ -377,6 +379,7 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n    In general this is just CLASS; but on some machines\n    in some cases it is preferable to use a more restrictive class.\n    For the 1750A, we force an immediate CONST_DOUBLE value to memory. */\n+\n #define PREFERRED_RELOAD_CLASS(X,CLASS)  \\\n \t\t(GET_CODE(X) == CONST_DOUBLE ? NO_REGS : CLASS)\n \n@@ -729,9 +732,9 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n #ifdef REG_OK_STRICT\n \n /* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+#define REG_OK_FOR_INDEX_P(X) (REGNO (X) >= 12 && REGNO (X) <= 15)\n /* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+#define REG_OK_FOR_BASE_P(X)  (REGNO (X) > 0 && REGNO (X) <= 15)\n \n #else\n \n@@ -858,15 +861,19 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n \n #define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n   case CONST_INT:\t\t\t\t\t\t\\\n-    if (INTVAL(RTX) >= -16 && INTVAL(RTX) <= 16) return 1;\t\\\n+    return (INTVAL(RTX) >= -16 && INTVAL(RTX) <= 16) ? 1 : 3;\t\\\n   case CONST:\t\t\t\t\t\t\t\\\n   case LABEL_REF:\t\t\t\t\t\t\\\n   case SYMBOL_REF:\t\t\t\t\t\t\\\n     return 5;\t\t\t\t\t\t\t\\\n   case CONST_DOUBLE:\t\t\t\t\t\t\\\n     return 7;\n \n-#define ADDRESS_COST(ADDRESS)\t(memop_valid(ADDRESS) ?  3 : 1000)\n+#define ADDRESS_COST(ADDRESS)  (memop_valid(ADDRESS) ?  3 : 1000)\n+\n+#define REGISTER_MOVE_COST(FROM,TO)\t2\n+\n+#define MEMORY_MOVE_COST(M)\t\t5\n \n /* Tell final.c how to eliminate redundant test instructions.  */\n \n@@ -1046,7 +1053,9 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n \telse {\t\t\t\t\t\t\t\\\n \t   check_section(Konst);\t\t\t\t\\\n \t   fprintf(FILE,\"K%s\\n\",NAME);\t\t\t\t\\\n+\t   fflush(FILE);\t\t\t\t\t\\\n \t   datalbl[++datalbl_ndx].name = (char *)strdup (NAME);\t\\\n+\t   datalbl[datalbl_ndx].size = 0;\t\t\t\\\n \t   label_pending = 1;\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\\\n   } while (0)\n@@ -1074,6 +1083,7 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n \t     label_pending = 1;\t\t\t\t\t\\\n \t     datalbl[++datalbl_ndx].name = (char *) malloc (9); \\\n \t     sprintf(datalbl[datalbl_ndx].name,\"LC%d\",NUM);\t\\\n+\t     datalbl[datalbl_ndx].size = 0;\t\t\t\\\n \t     check_section(Konst);\t\t\t\t\\\n \t     fprintf(FILE,\"K%s%d\\n\",PREFIX,NUM);\t\t\\\n \t  }\t\t\t\t\t\t\t\\\n@@ -1082,6 +1092,7 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n \t     jmplbl[jmplbl_ndx].pc = program_counter;\t\t\\\n \t     fprintf(FILE, \"%s%d\\n\", PREFIX, NUM);\t\t\\\n \t  }\t\t\t\t\t\t\t\\\n+\t  fflush(FILE);\t\t\t\t\t\t\\\n \t} while (0)\n \n \n@@ -1116,12 +1127,11 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n \n #define ASM_OUTPUT_SHORT_FLOAT(FILE,VALUE) \t\t\t\\\n   do {\t\t\t\t\t\t\t\t\\\n-      if (label_pending)\t\t\t\t\t\\\n+      if (label_pending) {\t\t\t\t\t\\\n \t label_pending = 0;\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-         datalbl[++datalbl_ndx].name = float_label('D',VALUE);\t\\\n-      sprintf (datalbl[datalbl_ndx].value, \"%lf\", (double) VALUE); \\\n-      datalbl[datalbl_ndx].size = 2;\t\t\t\t\\\n+         sprintf (datalbl[datalbl_ndx].value, \"%lf\", (double) VALUE); \\\n+      }\t\t\t\t\t\t\t\t\\\n+      datalbl[datalbl_ndx].size += 2;\t\t\t\t\\\n       fprintf (FILE, \"\\tdataf\\t%lf\\n\",VALUE);\t\t\t\\\n   } while(0)\n \n@@ -1130,25 +1140,21 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n \n #define ASM_OUTPUT_THREE_QUARTER_FLOAT(FILE,VALUE)\t\t\\\n   do {\t\t\t\t\t\t\t\t\\\n-      if (label_pending)\t\t\t\t\t\\\n+      if (label_pending) {\t\t\t\t\t\\\n \t label_pending = 0;\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-         datalbl[++datalbl_ndx].name = float_label('E',VALUE);\t\\\n-      sprintf (datalbl[datalbl_ndx].value, \"%lf\", VALUE);\t\\\n-      datalbl[datalbl_ndx].size = 3;\t\t\t\t\\\n+         sprintf (datalbl[datalbl_ndx].value, \"%lf\", VALUE);\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+      datalbl[datalbl_ndx].size += 3;\t\t\t\t\\\n       fprintf(FILE,\"\\tdataef\\t%lf\\n\",VALUE);\t\t\t\\\n   } while (0)\n \n /* This is how to output an assembler line defining a string constant.  */\n \n #define ASM_OUTPUT_ASCII(FILE, PTR, LEN)  do {\t\t\\\n \tint i;\t\t\t\t\t\t\t\t\\\n-\tif (! label_pending)\t\t\t\t\t\t\\\n-\t   fprintf(FILE,\";in ASM_OUTPUT_ASCII without label_pending\\n\");\\\n-\telse {\t\t\t\t\t\t\t\t\\\n+\tif (label_pending)\t\t\t\t\t\t\\\n \t   label_pending = 0;\t\t\t\t\t\t\\\n-\t   datalbl[datalbl_ndx].size = LEN;\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n+\tdatalbl[datalbl_ndx].size += LEN;\t\t\t\t\\\n \tfor (i = 0; i < LEN; i++) {\t\t\t\t\t\\\n \t  if ((i % 15) == 0) {\t\t\t\t\t\t\\\n \t    if (i != 0)\t\t\t\t\t\t\t\\\n@@ -1175,12 +1181,9 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n  */\n \n #define ASM_OUTPUT_CHAR(FILE,VALUE)  do {\t  \\\n-\tif (! label_pending) \t\t\t\t\t\t\\\n-\t   fprintf(FILE,\";in ASM_OUTPUT_CHAR without label_pending\\n\");\t\\\n-\telse {\t\t\t\t\t\t\t\t\\\n+\tif (label_pending) \t\t\t\t\t\t\\\n \t   label_pending = 0;\t\t\t\t\t\t\\\n-\t   datalbl[datalbl_ndx].size = 1;\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n+\tdatalbl[datalbl_ndx].size++;\t\t\t\t\t\\\n \tfprintf(FILE, \"\\tdata\\t\");\t\t\t\t\t\\\n \toutput_addr_const(FILE, VALUE); \t\t\t\t\\\n \tfprintf(FILE, \"\\n\");\t\t\t\t\t\t\\\n@@ -1193,18 +1196,20 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n  */\n \n #define ASM_OUTPUT_SHORT(FILE,VALUE) do {\t  \\\n-\tif (! label_pending)\t\t\t\t\t\t\\\n-\t   fprintf(FILE,\";in ASM_OUTPUT_SHORT without label_pending\\n\");\\\n-\telse {\t\t\t\t\t\t\t\t\\\n+\tif (label_pending)\t\t\t\t\t\t\\\n \t   label_pending = 0;\t\t\t\t\t\t\\\n-\t   datalbl[datalbl_ndx].size = 2;\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n+\tdatalbl[datalbl_ndx].size += 2;\t\t\t\t\t\\\n \tfprintf(FILE, \"\\tdatal\\t%d\\n\",INTVAL(VALUE));\t\t\t\\\n   } while (0)\n \n /* This is how to output an assembler line for a numeric constant byte.  */\n \n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  fprintf(FILE, \"\\tdata\\t#%x\\n\", VALUE)\n+#define ASM_OUTPUT_BYTE(FILE,VALUE) do {\t  \\\n+\tif (label_pending)\t\t\t\t\t\t\\\n+\t   label_pending = 0;\t\t\t\t\t\t\\\n+\tdatalbl[datalbl_ndx].size++;\t\t\t\t\t\\\n+\tfprintf(FILE, \"\\tdata\\t#%x\\n\", VALUE);\t\t\t\t\\\n+  } while (0)\n \n /* This is how to output an insn to push a register on the stack.\n    It need not be very fast code.  */\n@@ -1268,11 +1273,11 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n \n #define ASM_OUTPUT_CONSTRUCTOR(FILE, NAME)  do {\t\\\n \tfprintf(FILE, \"\\tinit\\n\\t\"); assemble_name(FILE, NAME); \\\n-\tfprintf(FILE,\"  ;constructor\\n\"); } while (0)\n+        fprintf(FILE,\"  ;constructor\\n\"); } while (0)\n \n #define ASM_OUTPUT_DESTRUCTOR(FILE, NAME)  do {\t\\\n \tfprintf(FILE, \"\\tinit\\n\\t\"); assemble_name(FILE, NAME); \\\n-        fprintf(FILE,\"  ;destructor\"); } while (0)\n+        fprintf(FILE,\"  ;destructor\\n\"); } while (0)\n \n /* Define the parentheses used to group arithmetic operations\n    in assembler code.  */"}]}