{"sha": "3faa0dde31720a59082b038a9f50f5703711bb53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZhYTBkZGUzMTcyMGE1OTA4MmIwMzhhOWY1MGY1NzAzNzExYmI1Mw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-06-24T05:49:06Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-06-24T19:59:24Z"}, "message": "c++: Simplify build_over_call a bit.\n\nIt occurred to me that if we're looking up the defining base within the\nconversion_path binfo, we could use the result for the conversion as well\ninstead of doing two separate conversions.\n\ngcc/cp/ChangeLog:\n\n\t* call.c (build_over_call): Only call build_base_path once.", "tree": {"sha": "68eaaee7525ca49b16a10ee33df8d0243e151abe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68eaaee7525ca49b16a10ee33df8d0243e151abe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3faa0dde31720a59082b038a9f50f5703711bb53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3faa0dde31720a59082b038a9f50f5703711bb53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3faa0dde31720a59082b038a9f50f5703711bb53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3faa0dde31720a59082b038a9f50f5703711bb53/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d6baf68fe22b6ef5b1d6fabbef97c0e1b4d7abf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d6baf68fe22b6ef5b1d6fabbef97c0e1b4d7abf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d6baf68fe22b6ef5b1d6fabbef97c0e1b4d7abf"}], "stats": {"total": 54, "additions": 23, "deletions": 31}, "files": [{"sha": "d8923be1d68bcc016e500c6e2d39e3669ec1f7d3", "filename": "gcc/cp/call.c", "status": "modified", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3faa0dde31720a59082b038a9f50f5703711bb53/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3faa0dde31720a59082b038a9f50f5703711bb53/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=3faa0dde31720a59082b038a9f50f5703711bb53", "patch": "@@ -8658,13 +8658,10 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n   /* Bypass access control for 'this' parameter.  */\n   else if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE)\n     {\n-      tree parmtype = TREE_VALUE (parm);\n       tree arg = build_this (first_arg != NULL_TREE\n \t\t\t     ? first_arg\n \t\t\t     : (*args)[arg_index]);\n       tree argtype = TREE_TYPE (arg);\n-      tree converted_arg;\n-      tree base_binfo;\n \n       if (arg == error_mark_node)\n \treturn error_mark_node;\n@@ -8683,38 +8680,20 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t    return error_mark_node;\n \t}\n \n+      /* The class where FN is defined.  */\n+      tree ctx = DECL_CONTEXT (fn);\n+\n       /* See if the function member or the whole class type is declared\n \t final and the call can be devirtualized.  */\n-      if (DECL_FINAL_P (fn)\n-\t  || CLASSTYPE_FINAL (TYPE_METHOD_BASETYPE (TREE_TYPE (fn))))\n+      if (DECL_FINAL_P (fn) || CLASSTYPE_FINAL (ctx))\n \tflags |= LOOKUP_NONVIRTUAL;\n \n-      /* If we know the dynamic type of the object, look up the final overrider\n-\t in the BINFO.  */\n-      if (DECL_VINDEX (fn) && (flags & LOOKUP_NONVIRTUAL) == 0\n-\t  && resolves_to_fixed_type_p (arg))\n-\t{\n-\t  tree binfo = cand->conversion_path;\n-\t  if (BINFO_TYPE (binfo) != DECL_CONTEXT (fn))\n-\t    binfo = lookup_base (binfo, DECL_CONTEXT (fn), ba_unique,\n-\t\t\t\t NULL, complain);\n-\t  fn = lookup_vfn_in_binfo (DECL_VINDEX (fn), binfo);\n-\t  flags |= LOOKUP_NONVIRTUAL;\n-\t}\n-\n       /* [class.mfct.non-static]: If a non-static member function of a class\n \t X is called for an object that is not of type X, or of a type\n \t derived from X, the behavior is undefined.\n \n \t So we can assume that anything passed as 'this' is non-null, and\n \t optimize accordingly.  */\n-      gcc_assert (TYPE_PTR_P (parmtype));\n-      /* Convert to the base in which the function was declared.  */\n-      gcc_assert (cand->conversion_path != NULL_TREE);\n-      converted_arg = build_base_path (PLUS_EXPR,\n-\t\t\t\t       arg,\n-\t\t\t\t       cand->conversion_path,\n-\t\t\t\t       1, complain);\n       /* Check that the base class is accessible.  */\n       if (!accessible_base_p (TREE_TYPE (argtype),\n \t\t\t      BINFO_TYPE (cand->conversion_path), true))\n@@ -8728,12 +8707,25 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t}\n       /* If fn was found by a using declaration, the conversion path\n \t will be to the derived class, not the base declaring fn. We\n-\t must convert from derived to base.  */\n-      base_binfo = lookup_base (TREE_TYPE (TREE_TYPE (converted_arg)),\n-\t\t\t\tTREE_TYPE (parmtype), ba_unique,\n-\t\t\t\tNULL, complain);\n-      converted_arg = build_base_path (PLUS_EXPR, converted_arg,\n-\t\t\t\t       base_binfo, 1, complain);\n+\t must convert to the base.  */\n+      tree base_binfo = cand->conversion_path;\n+      if (BINFO_TYPE (base_binfo) != ctx)\n+\t{\n+\t  base_binfo = lookup_base (base_binfo, ctx, ba_unique, NULL, complain);\n+\t  if (base_binfo == error_mark_node)\n+\t    return error_mark_node;\n+\t}\n+      tree converted_arg = build_base_path (PLUS_EXPR, arg,\n+\t\t\t\t\t    base_binfo, 1, complain);\n+\n+      /* If we know the dynamic type of the object, look up the final overrider\n+\t in the BINFO.  */\n+      if (DECL_VINDEX (fn) && (flags & LOOKUP_NONVIRTUAL) == 0\n+\t  && resolves_to_fixed_type_p (arg))\n+\t{\n+\t  fn = lookup_vfn_in_binfo (DECL_VINDEX (fn), base_binfo);\n+\t  flags |= LOOKUP_NONVIRTUAL;\n+\t}\n \n       argarray[j++] = converted_arg;\n       parm = TREE_CHAIN (parm);"}]}