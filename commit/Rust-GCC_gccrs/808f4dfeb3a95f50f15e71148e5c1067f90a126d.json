{"sha": "808f4dfeb3a95f50f15e71148e5c1067f90a126d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA4ZjRkZmViM2E5NWY1MGYxNWU3MTE0OGU1YzEwNjdmOTBhMTI2ZA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-05-06T19:16:35Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-08-13T20:01:39Z"}, "message": "analyzer: rewrite of region and value-handling\n\nThis large patch reimplements how the analyzer tracks regions and\nvalues.\n\nElimination of region_id and svalue_id\n**************************************\n\nThe patch eliminates region_id and svalue_id in favor of simply\nusing pointers.  I'd hoped that the ID classes would make it easier\nto compare states, avoiding having to compare long hexadecimal addresses\nin favor of small integers.  Unfortunately it added lots of complexity,\nwith the need to remap IDs when comparing or purging states, and the\nneed to \"canonicalize\" when comparing states.\n\nVarious \"state explosion\" bugs in the old implementation were due to\nfailures in canonicalization, where two states that ought to be equal\nwere non-equal due to differences in ID ordering.  I spent a lot of\ntime trying to fix canonicalization bugs, and there always seemed to\nbe one more bug.  By eliminating IDs in this new implementation, lots\nof tricky canonicalization goes away and no ID remapping should be\nneeded; almost all of the old validation code becomes redundant.\nThere's still some canonicalization in the new implementation, mostly\nin constraint_manager, but much less than before.\n\nOwnership of regions and svalues\n********************************\n\nIn the old implementation, each region_model had its own copies of\nregions and svalues, so there was heap bloat and churn as lots of\nlittle objects were cloned when copying program_state instances.  In the\nnew implementation the regions and svalues are immutable and are shared\nthoughout the analysis, rather than being per region_model.  They are\nowned by a manager class, and are effectively singletons.  Region and\nsvalue instances can now be compared by pointer rather than by comparing\ntheir fields (the manager class takes care of uniqueness).\n\nThis is a huge simplification, and (I hope) will avoid lots\nof heap churn as states are copied; all mutable state from regions and\nsvalues is now stored in a \"store\" class in the region_model.\n\nChanges to the meaning of a \"region\"\n************************************\n\nRegion subclasses no longer represent internal structure, but instead\nrepresent how the regions are reached.  So e.g. a global \"struct coord\nc;\" is now a decl_region, rather than a struct_region.\n\nIn the old implementation, the values for each region were stored in the\nregion instances, but in the new implementation the regions are immutable.\nMemory is now modeled in a new \"store\" class: a mapping from keys to\nsvalues, where the keys are both concrete bit-offsets from the start of\na \"base region\", and \"symbolic\" keys (thus hopefully making unions,\ncasts, aliasing etc easier to deal with).  So e.g. for assignments to\nthe fields of a struct, it records the mapping from bit-offsets of e.g.\nfield to the values; if that memory is cast to another type and written\nto, the appropriate clobbering of the bound values can happen.\n\nThe concept of \"what the current stack is\" moves from the regions to\nbeing a field within the region_model (\"m_current_frame\").\n\nBugs fixed by this patch\n************************\n\nPR analyzer/93032 (missing leak diagnostic for zlib/contrib/minizip/mztools.c)\nPR analyzer/93938 (ICE in analyzer)\nPR analyzer/94011 (ICE in analyzer)\nPR analyzer/94099 (ICE in analyzer)\nPR analyzer/94399 (leak false positive with __attribute__((cleanup())))\nPR analyzer/94458 (leak false positive)\nPR analyzer/94503 (ICE on C++ return-value-optimization)\nPR analyzer/94640 (leak false positive)\nPR analyzer/94688 (ICE in analyzer)\nPR analyzer/94689 (\"arrays of functions are not meaningful\" error)\nPR analyzer/94839 (leak false positive)\nPR analyzer/95026 (leak false positive)\nPR analyzer/95042 (ICE merging const and non-const C++ object instances)\nPR analyzer/95240 (leak false positive)\n\ngcc/ChangeLog:\n\t* Makefile.in (ANALYZER_OBJS): Add analyzer/region.o,\n\tanalyzer/region-model-impl-calls.o,\n\tanalyzer/region-model-manager.o,\n\tanalyzer/region-model-reachability.o, analyzer/store.o, and\n\tanalyzer/svalue.o.\n\t* doc/analyzer.texi: Update for changes to analyzer\n\timplementation.\n\t* tristate.h (tristate::get_value): New accessor.\n\ngcc/analyzer/ChangeLog:\n\t* analyzer-logging.cc: Ignore \"-Wformat-diag\".\n\t(logger::enter_scope): Use inc_indent in both overloads.\n\t(logger::exit_scope): Use dec_indent.\n\t* analyzer-logging.h (logger::inc_indent): New.\n\t(logger::dec_indent): New.\n\t* analyzer-selftests.cc (run_analyzer_selftests): Call\n\tanalyzer_store_cc_tests.\n\t* analyzer-selftests.h (analyzer_store_cc_tests): New decl.\n\t* analyzer.cc (get_stmt_location): New function.\n\t* analyzer.h (class initial_svalue): New forward decl.\n\t(class unaryop_svalue): New forward decl.\n\t(class binop_svalue): New forward decl.\n\t(class sub_svalue): New forward decl.\n\t(class unmergeable_svalue): New forward decl.\n\t(class placeholder_svalue): New forward decl.\n\t(class widening_svalue): New forward decl.\n\t(class compound_svalue): New forward decl.\n\t(class conjured_svalue): New forward decl.\n\t(svalue_set): New typedef.\n\t(class map_region): Delete.\n\t(class array_region): Delete.\n\t(class frame_region): New forward decl.\n\t(class function_region): New forward decl.\n\t(class label_region): New forward decl.\n\t(class decl_region): New forward decl.\n\t(class element_region): New forward decl.\n\t(class offset_region): New forward decl.\n\t(class cast_region): New forward decl.\n\t(class field_region): New forward decl.\n\t(class string_region): New forward decl.\n\t(class region_model_manager): New forward decl.\n\t(class store_manager): New forward decl.\n\t(class store): New forward decl.\n\t(class call_details): New forward decl.\n\t(struct svalue_id_merger_mapping): Delete.\n\t(struct canonicalization): Delete.\n\t(class function_point): New forward decl.\n\t(class engine): New forward decl.\n\t(dump_tree): New function decl.\n\t(print_quoted_type): New function decl.\n\t(readability_comparator): New function decl.\n\t(tree_cmp): New function decl.\n\t(class path_var): Move here from region-model.h\n\t(bit_offset_t, bit_size_t, byte_size_t): New typedefs.\n\t(class region_offset): New class.\n\t(get_stmt_location): New decl.\n\t(struct member_function_hash_traits): New struct.\n\t(class consolidation_map): New class.\n\tIgnore \"-Wformat-diag\".\n\t* analyzer.opt (-param=analyzer-max-svalue-depth=): New param.\n\t(-param=analyzer-max-enodes-for-full-dump=): New param.\n\t* call-string.cc: Ignore -Wformat-diag.\n\t* checker-path.cc: Move includes of \"analyzer/call-string.h\" and\n\t\"analyzer/program-point.h\" to before \"analyzer/region-model.h\",\n\tand also include \"analyzer/store.h\" before it.\n\t(state_change_event::state_change_event): Replace \"tree var\" param\n\twith \"const svalue *sval\".  Convert \"origin\" param from tree to\n\t\"const svalue *\".\n\t(state_change_event::get_desc): Call get_representative_tree to\n\tconvert the var and origin from const svalue * to tree.  Use\n\tsvalue::get_desc rather than %qE when describing state changes.\n\t(checker_path::add_final_event): Use get_stmt_location.\n\t* checker-path.h (state_change_event::state_change_event): Port\n\tfrom tree to const svalue *.\n\t(state_change_event::get_lvalue): Delete.\n\t(state_change_event::get_dest_function): New.\n\t(state_change_event::m_var): Replace with...\n\t(state_change_event::m_sval): ...this.\n\t(state_change_event::m_origin): Convert from tree to\n\tconst svalue *.\n\t* constraint-manager.cc: Include \"analyzer/call-string.h\",\n\t\"analyzer/program-point.h\", and \"analyzer/store.h\" before\n\t\"analyzer/region-model.h\".\n\t(struct bound, struct range): Move to constraint-manager.h.\n\t(compare_constants): New function.\n\t(range::dump): Rename to...\n\t(range::dump_to_pp): ...this.  Support NULL constants.\n\t(range::dump): Reintroduce for dumping to stderr.\n\t(range::constrained_to_single_element): Return result, rather than\n\twriting to *OUT.\n\t(range::eval_condition): New.\n\t(range::below_lower_bound): New.\n\t(range::above_upper_bound): New.\n\t(equiv_class::equiv_class): Port from svalue_id to const svalue *.\n\t(equiv_class::print): Likewise.\n\t(equiv_class::hash): Likewise.\n\t(equiv_class::operator==): Port from svalue_id to const svalue *.\n\t(equiv_class::add): Port from svalue_id to const svalue *. Drop\n\t\"cm\" param.\n\t(equiv_class::del): Port from svalue_id to const svalue *.\n\t(equiv_class::get_representative): Likewise.\n\t(equiv_class::remap_svalue_ids): Delete.\n\t(svalue_id_cmp_by_id): Rename to...\n\t(svalue_cmp_by_ptr): ...this, porting from svalue_id to\n\tconst svalue *.\n\t(equiv_class::canonicalize): Update qsort comparator.\n\t(constraint::implied_by): New.\n\t(constraint_manager::constraint_manager): Copy m_mgr in copy ctor.\n\t(constraint_manager::dump_to_pp): Add \"multiline\" param\n\t(constraint_manager::dump): Pass \"true\" for \"multiline\".\n\t(constraint_manager::add_constraint): Port from svalue_id to\n\tconst svalue *.  Split out second part into...\n\t(constraint_manager::add_unknown_constraint): ...this new\n\tfunction.  Remove self-constraints when merging equivalence\n\tclasses.\n\t(constraint_manager::add_constraint_internal): Remove constraints\n\tthat would be implied by the new constraint.  Port from svalue_id\n\tto const svalue *.\n\t(constraint_manager::get_equiv_class_by_sid): Rename to...\n\t(constraint_manager::get_equiv_class_by_svalue): ...this, porting\n\tfrom svalue_id to const svalue *.\n\t(constraint_manager::get_or_add_equiv_class): Port from svalue_id\n\tto const svalue *.\n\t(constraint_manager::eval_condition): Make const.  Call\n\tcompare_constants and return early if it provides a known result.\n\t(constraint_manager::get_ec_bounds): New.\n\t(constraint_manager::eval_condition): New overloads.  Make\n\texisting one const, and use compare_constants.\n\t(constraint_manager::purge): Convert \"p\" param to a template\n\trather that an abstract base class.  Port from svalue_id to\n\tconst svalue *.\n\t(class dead_svalue_purger): New class.\n\t(constraint_manager::remap_svalue_ids): Delete.\n\t(constraint_manager::on_liveness_change): New.\n\t(equiv_class_cmp): Port from svalue_id to const svalue *.\n\t(constraint_manager::canonicalize): Likewise.  Combine with\n\tpurging of redundant equivalence classes and constraints.\n\t(class cleaned_constraint_manager): Delete.\n\t(class merger_fact_visitor): Make \"m_cm_b\" const.  Add \"m_merger\"\n\tfield.\n\t(merger_fact_visitor::fact): Port from svalue_id to const svalue *.\n\tAdd special case for widening.\n\t(constraint_manager::merge): Port from svalue_id to const svalue *.\n\t(constraint_manager::clean_merger_input): Delete.\n\t(constraint_manager::for_each_fact): Port from svalue_id to\n\tconst svalue *.\n\t(constraint_manager::validate): Likewise.\n\t(selftest::test_constraint_conditions): Provide a\n\tregion_model_manager when creating region_model instances.\n\tAdd test for self-equality not creating equivalence classes.\n\t(selftest::test_transitivity): Provide a region_model_manager when\n\tcreating region_model instances.  Verify that EC-merging happens\n\twhen constraints are implied.\n\t(selftest::test_constant_comparisons):  Provide a\n\tregion_model_manager when creating region_model instances.\n\t(selftest::test_constraint_impl): Likewise.  Remove over-specified\n\tassertions.\n\t(selftest::test_equality): Provide a region_model_manager when\n\tcreating region_model instances.\n\t(selftest::test_many_constants): Likewise.  Provide a\n\tprogram_point when testing merging.\n\t(selftest::run_constraint_manager_tests): Move call to\n\ttest_constant_comparisons to outside the transitivity guard.\n\t* constraint-manager.h (struct bound): Move here from\n\tconstraint-manager.cc.\n\t(struct range): Likewise.\n\t(struct::eval_condition): New decl.\n\t(struct::below_lower_bound): New decl.\n\t(struct::above_upper_bound): New decl.\n\t(equiv_class::add): Port from svalue_id to const svalue *.\n\t(equiv_class::del): Likewise.\n\t(equiv_class::get_representative): Likewise.\n\t(equiv_class::remap_svalue_ids): Drop.\n\t(equiv_class::m_cst_sid): Convert to..\n\t(equiv_class::m_cst_sval): ...this.\n\t(equiv_class::m_vars): Port from svalue_id to const svalue *.\n\t(constraint::bool implied_by): New decl.\n\t(fact_visitor::on_fact): Port from svalue_id to const svalue *.\n\t(constraint_manager::constraint_manager): Add mgr param.\n\t(constraint_manager::clone): Delete.\n\t(constraint_manager::maybe_get_constant): Delete.\n\t(constraint_manager::get_sid_for_constant): Delete.\n\t(constraint_manager::get_num_svalues): Delete.\n\t(constraint_manager::dump_to_pp): Add \"multiline\" param.\n\t(constraint_manager::get_equiv_class): Port from svalue_id to\n\tconst svalue *.\n\t(constraint_manager::add_constraint):  Likewise.\n\t(constraint_manager::get_equiv_class_by_sid): Rename to...\n\t(constraint_manager::get_equiv_class_by_svalue): ...this, porting\n\tfrom svalue_id to const svalue *.\n\t(constraint_manager::add_unknown_constraint): New decl.\n\t(constraint_manager::get_or_add_equiv_class): Port from svalue_id\n\tto const svalue *.\n\t(constraint_manager::eval_condition): Likewise.  Add overloads.\n\t(constraint_manager::get_ec_bounds): New decl.\n\t(constraint_manager::purge): Convert to template.\n\t(constraint_manager::remap_svalue_ids): Delete.\n\t(constraint_manager::on_liveness_change): New decl.\n\t(constraint_manager::canonicalize): Drop param.\n\t(constraint_manager::clean_merger_input): Delete.\n\t(constraint_manager::m_mgr): New field.\n\t* diagnostic-manager.cc: Move includes of\n\t\"analyzer/call-string.h\" and \"analyzer/program-point.h\" to before\n\t\"analyzer/region-model.h\", and also include \"analyzer/store.h\"\n\tbefore it.\n\t(saved_diagnostic::saved_diagnostic): Add \"sval\" param.\n\t(diagnostic_manager::diagnostic_manager): Add engine param.\n\t(diagnostic_manager::add_diagnostic): Add \"sval\" param, passing it\n\tto saved_diagnostic ctor.  Update overload to pass NULL for it.\n\t(dedupe_winners::dedupe_winners): Add engine param.\n\t(dedupe_winners::add): Add \"eg\" param.  Pass m_engine to\n\tfeasible_p.\n\t(dedupe_winner::m_engine): New field.\n\t(diagnostic_manager::emit_saved_diagnostics): Pass engine to\n\tdedupe_winners.  Pass &eg when adding candidates.  Pass svalue\n\trather than tree to prune_path.  Use get_stmt_location to get\n\tprimary location of diagnostic.\n\t(diagnostic_manager::emit_saved_diagnostic): Likewise.\n\t(get_any_origin): Drop.\n\t(state_change_event_creator::on_global_state_change): Pass NULL\n\tconst svalue * rather than NULL_TREE trees to state_change_event\n\tctor.\n\t(state_change_event_creator::on_state_change): Port from tree and\n\tsvalue_id to const svalue *.\n\t(for_each_state_change): Port from svalue_id to const svalue *.\n\t(struct null_assignment_sm_context): New.\n\t(diagnostic_manager::add_events_for_eedge):  Add state change\n\tevents for assignment to NULL.\n\t(diagnostic_manager::prune_path): Update param from tree to\n\tconst svalue *.\n\t(diagnostic_manager::prune_for_sm_diagnostic): Port from tracking\n\tby tree to by const svalue *.\n\t* diagnostic-manager.h (saved_diagnostic::saved_diagnostic): Add sval\n\tparam.\n\t(saved_diagnostic::m_sval): New field.\n\t(diagnostic_manager::diagnostic_manager): Add engine param.\n\t(diagnostic_manager::get_engine): New.\n\t(diagnostic_manager::add_diagnostic): Add \"sval\" param.\n\t(diagnostic_manager::prune_path): Likewise.\n\t(diagnostic_manager::prune_for_sm_diagnostic): New overload.\n\t(diagnostic_manager::m_eng): New field.\n\t* engine.cc: Move includes of \"analyzer/call-string.h\" and\n\t\"analyzer/program-point.h\" to before \"analyzer/region-model.h\",\n\tand also include \"analyzer/store.h\" before it.\n\t(impl_region_model_context::impl_region_model_context): Update for\n\tremoval of m_change field.\n\t(impl_region_model_context::remap_svalue_ids): Delete.\n\t(impl_region_model_context::on_svalue_leak): New.\n\t(impl_region_model_context::on_svalue_purge): Delete.\n\t(impl_region_model_context::on_liveness_change): New.\n\t(impl_region_model_context::on_unknown_change): Update param\n\tfrom svalue_id to const svalue *.  Add is_mutable param.\n\t(setjmp_svalue::compare_fields): Delete.\n\t(setjmp_svalue::accept): New.\n\t(setjmp_svalue::add_to_hash): Delete.\n\t(setjmp_svalue::dump_to_pp): New.\n\t(setjmp_svalue::print_details): Delete.\n\t(impl_sm_context::impl_sm_context): Drop \"change\" param.\n\t(impl_sm_context::get_fndecl_for_call): Drop \"m_change\".\n\t(impl_sm_context::on_transition): Drop ATTRIBUTE_UNUSED from\n\t\"stmt\" param.  Drop m_change.  Port from svalue_id to\n\tconst svalue *.\n\t(impl_sm_context::warn_for_state): Drop m_change.  Port from\n\tsvalue_id to const svalue *.\n\t(impl_sm_context::get_readable_tree): Rename to...\n\t(impl_sm_context::get_diagnostic_tree): ...this.  Port from\n\tsvalue_id to const svalue *.\n\t(impl_sm_context::is_zero_assignment): New.\n\t(impl_sm_context::m_change): Delete field.\n\t(leak_stmt_finder::find_stmt): Handle m_var being NULL.\n\t(readability):  Increase penalty for MEM_REF.  For SSA_NAMEs,\n\tslightly favor the underlying var over the SSA name.  Heavily\n\tpenalize temporaries.  Handle RESULT_DECL.\n\t(readability_comparator): Make non-static.  Consider stack depths.\n\t(impl_region_model_context::on_state_leak): Convert from svalue_id\n\tto const svalue *, updating for region_model changes.  Use\n\tid_equal.\n\t(impl_region_model_context::on_inherited_svalue): Delete.\n\t(impl_region_model_context::on_cast): Delete.\n\t(impl_region_model_context::on_condition):  Drop m_change.\n\t(impl_region_model_context::on_phi): Likewise.\n\t(impl_region_model_context::on_unexpected_tree_code): Handle t\n\tbeing NULL.\n\t(point_and_state::validate): Update stack checking for\n\tregion_model changes.\n\t(eg_traits::dump_args_t::show_enode_details_p): New.\n\t(exploded_node::exploded_node): Initialize m_num_processed_stmts.\n\t(exploded_node::get_processed_stmt): New function.\n\t(exploded_node::get_dot_fillcolor): Add more colors.\n\t(exploded_node::dump_dot): Guard the printing of the point and\n\tstate with show_enode_details_p.  Print the processed stmts for\n\tthis enode after the initial state.\n\t(exploded_node::dump_to_pp): Pass true for new multiline param\n\tof program_state::dump_to_pp.\n\t(exploded_node::on_stmt): Drop \"change\" param.  Log the stmt.\n\tSet input_location.  Implement __analyzer_describe.  Update\n\timplementation of __analyzer_dump and __analyzer_eval.\n\tRemove purging of sm-state for unknown fncalls from here.\n\t(exploded_node::on_edge): Drop \"change\" param.\n\t(exploded_node::on_longjmp): Port from region_id/svalue_id to\n\tconst region */const svalue *.  Call program_state::detect_leaks.\n\tDrop state_change.\n\t(exploded_node::detect_leaks): Update for changes to region_model.\n\tCall program_state::detect_leaks.\n\t(exploded_edge::exploded_edge): Drop ext_state and change params.\n\t(exploded_edge::dump_dot): \"args\" is no longer used.  Drop dumping\n\tof m_change.\n\t(exploded_graph::exploded_graph): Pass engine to\n\tm_diagnostic_manager ctor.  Use program_point::origin.\n\t(exploded_graph::add_function_entry):  Drop ctxt.  Use\n\tprogram_state::push_frame.  Drop state_change.\n\t(exploded_graph::get_or_create_node): Drop \"change\" param.  Add\n\t\"enode_for_diag\" param.  Update dumping calls for API changes.\n\tPass point to can_merge_with_p.  Show enode indices\n\twithin -Wanalyzer-too-complex diagnostic for hitting the per-point\n\tlimit.\n\t(exploded_graph::add_edge): Drop \"change\" param.  Log which nodes\n\tare being connected.  Update for changes to exploded_edge ctor.\n\t(exploded_graph::get_per_program_point_data): New.\n\t(exploded_graph::process_worklist): Pass point to\n\tcan_merge_with_p.  Drop state_change.  Update dumping call for API\n\tchange.\n\t(exploded_graph::process_node):  Drop state_change.  Split the\n\tnode in-place if an sm-state-change occurs.  Update\n\tm_num_processed_stmts.  Update dumping calls for API change.\n\t(exploded_graph::log_stats): Call engine::log_stats.\n\t(exploded_graph::dump_states_for_supernode): Update dumping\n\tcall.\n\t(exploded_path::feasible_p): Add \"eng\" and \"eg\" params.\n\tRename \"i\" to \"end_idx\".  Pass the manager to the region_model\n\tctor.  Update for every processed stmt in the enode, not just the\n\tfirst.  Keep track of which snodes have been visited, and call\n\tloop_replay_fixup when revisiting one.\n\t(enode_label::get_text): Update dump call for new param.\n\t(exploded_graph::dump_exploded_nodes): Likewise.\n\t(exploded_graph::get_node_by_index): New.\n\t(impl_run_checkers): Create engine instance and pass its address\n\tto extrinsic_state ctor.\n\t* exploded-graph.h\n\t(impl_region_model_context::impl_region_model_context): Drop\n\t\"change\" params.\n\t(impl_region_model_context::void remap_svalue_ids): Delete.\n\t(impl_region_model_context::on_svalue_purge): Delete.\n\t(impl_region_model_context::on_svalue_leak): New.\n\t(impl_region_model_context::on_liveness_change): New.\n\t(impl_region_model_context::on_state_leak): Update signature.\n\t(impl_region_model_context::on_inherited_svalue): Delete.\n\t(impl_region_model_context::on_cast): Delete.\n\t(impl_region_model_context::on_unknown_change): Update signature.\n\t(impl_region_model_context::m_change): Delete.\n\t(eg_traits::dump_args_t::show_enode_details_p): New.\n\t(exploded_node::on_stmt): Drop \"change\" param.\n\t(exploded_node::on_edge): Likewise.\n\t(exploded_node::get_processed_stmt): New decl.\n\t(exploded_node::m_num_processed_stmts): New field.\n\t(exploded_edge::exploded_edge): Drop ext_state and change params.\n\t(exploded_edge::m_change): Delete.\n\t(exploded_graph::get_engine): New accessor.\n\t(exploded_graph::get_or_create_node): Drop \"change\" param.  Add\n\t\"enode_for_diag\" param.\n\t(exploded_graph::add_edge): Drop \"change\" param.\n\t(exploded_graph::get_per_program_point_data): New decl.\n\t(exploded_graph::get_node_by_index): New decl.\n\t(exploded_path::feasible_p): Add \"eng\" and \"eg\" params.\n\t* program-point.cc: Include \"analyzer/store.h\" before including\n\t\"analyzer/region-model.h\".\n\t(function_point::function_point): Move here from\n\tprogram-point.h.\n\t(function_point::get_function): Likewise.\n\t(function_point::from_function_entry): Likewise.\n\t(function_point::before_supernode): Likewise.\n\t(function_point::next_stmt): New function.\n\t* program-point.h (function_point::function_point): Move\n\timplementation from here to program-point.cc.\n\t(function_point::get_function): Likewise.\n\t(function_point::from_function_entry): Likewise.\n\t(function_point::before_supernode): Likewise.\n\t(function_point::next_stmt): New decl.\n\t(program_point::operator!=): New.\n\t(program_point::origin): New.\n\t(program_point::next_stmt): New.\n\t(program_point::m_function_point): Make non-const.\n\t* program-state.cc: Move includes of \"analyzer/call-string.h\" and\n\t\"analyzer/program-point.h\" to before \"analyzer/region-model.h\",\n\tand also include \"analyzer/store.h\" before it.\n\t(extrinsic_state::get_model_manager): New.\n\t(sm_state_map::sm_state_map): Pass in sm and sm_idx to ctor,\n\trather than pass the around.\n\t(sm_state_map::clone_with_remapping): Delete.\n\t(sm_state_map::print): Remove \"sm\" param in favor of \"m_sm\".  Add\n\t\"simple\" and \"multiline\" params and support multiline vs single\n\tline dumping.\n\t(sm_state_map::dump): Remove \"sm\" param in favor of \"m_sm\".  Add\n\t\"simple\" param.\n\t(sm_state_map::hash): Port from svalue_id to const svalue *.\n\t(sm_state_map::operator==): Likewise.\n\t(sm_state_map::get_state): Likewise.  Call canonicalize_svalue on\n\tinput.  Handle inheritance of sm-state.  Call get_default_state.\n\t(sm_state_map::get_origin): Port from svalue_id to const svalue *.\n\t(sm_state_map::set_state): Likewise.  Pass in ext_state.  Reject\n\tattempts to set state on UNKNOWN.\n\t(sm_state_map::impl_set_state): Port from svalue_id to\n\tconst svalue *.  Pass in ext_state.  Call canonicalize_svalue on\n\tinput.\n\t(sm_state_map::purge_for_unknown_fncall): Delete.\n\t(sm_state_map::on_svalue_leak): New.\n\t(sm_state_map::remap_svalue_ids): Delete.\n\t(sm_state_map::on_liveness_change): New.\n\t(sm_state_map::on_unknown_change): Reimplement.\n\t(sm_state_map::on_svalue_purge): Delete.\n\t(sm_state_map::on_inherited_svalue): Delete.\n\t(sm_state_map::on_cast): Delete.\n\t(sm_state_map::validate): Delete.\n\t(sm_state_map::canonicalize_svalue): New.\n\t(program_state::program_state): Update to pass manager to\n\tregion_model's ctor.  Constify num_states and pass state machine\n\tand index to sm_state_map ctor.\n\t(program_state::print): Update for changes to dump API.\n\t(program_state::dump_to_pp): Ignore the summarize param.  Add\n\t\"multiline\" param.\n\t(program_state::dump_to_file): Add \"multiline\" param.\n\t(program_state::dump): Pass \"true\" for new \"multiline\" param.\n\t(program_state::push_frame): New.\n\t(program_state::on_edge): Drop \"change\" param.  Call\n\tprogram_state::detect_leaks.\n\t(program_state::prune_for_point): Add enode_for_diag param.\n\tReimplement based on store class.  Call detect_leaks\n\t(program_state::remap_svalue_ids): Delete.\n\t(program_state::get_representative_tree): Port from svalue_id to\n\tconst svalue *.\n\t(program_state::can_merge_with_p): Add \"point\" param.  Add early\n\treject for sm-differences.  Drop id remapping.\n\t(program_state::validate): Drop region model and sm_state_map\n\tvalidation.\n\t(state_change::sm_change::dump): Delete.\n\t(state_change::sm_change::remap_svalue_ids): Delete.\n\t(state_change::sm_change::on_svalue_purge): Delete.\n\t(log_set_of_svalues): New.\n\t(state_change::sm_change::validate): Delete.\n\t(state_change::state_change): Delete.\n\t(state_change::add_sm_change): Delete.\n\t(state_change::affects_p): Delete.\n\t(state_change::dump): Delete.\n\t(state_change::remap_svalue_ids): Delete.\n\t(state_change::on_svalue_purge): Delete.\n\t(state_change::validate): Delete.\n\t(selftest::assert_dump_eq): Delete.\n\t(ASSERT_DUMP_EQ): Delete.\n\t(selftest::test_sm_state_map): Update for changes to region_model\n\tand sm_state_map, porting from svalue_id to const svalue *.\n\t(selftest::test_program_state_dumping): Likewise.  Drop test of\n\tdumping, renaming to...\n\t(selftest::test_program_state_1): ...this.\n\t(selftest::test_program_state_dumping_2): Likewise, renaming to...\n\t(selftest::test_program_state_2): ...this.\n\t(selftest::test_program_state_merging): Update for changes to\n\tregion_model.\n\t(selftest::test_program_state_merging_2): Likewise.\n\t(selftest::analyzer_program_state_cc_tests): Update for renamed\n\ttests.\n\t* program-state.h (extrinsic_state::extrinsic_state): Add logger\n\tand engine params.\n\t(extrinsic_state::get_logger): New accessor.\n\t(extrinsic_state::get_engine): New accessor.\n\t(extrinsic_state::get_model_manager): New accessor.\n\t(extrinsic_state::m_logger): New field.\n\t(extrinsic_state::m_engine): New field.\n\t(struct default_hash_traits<svalue_id>): Delete.\n\t(pod_hash_traits<svalue_id>::hash): Delete.\n\t(pod_hash_traits<svalue_id>::equal): Delete.\n\t(pod_hash_traits<svalue_id>::mark_deleted): Delete.\n\t(pod_hash_traits<svalue_id>::mark_empty): Delete.\n\t(pod_hash_traits<svalue_id>::is_deleted): Delete.\n\t(pod_hash_traits<svalue_id>::is_empty): Delete.\n\t(sm_state_map::entry_t::entry_t): Port from svalue_id to\n\tconst svalue *.\n\t(sm_state_map::entry_t::m_origin): Likewise.\n\t(sm_state_map::map_t): Likewise.\n\t(sm_state_map::sm_state_map): Add state_machine and index params.\n\t(sm_state_map::clone_with_remapping): Delete.\n\t(sm_state_map::print):  Drop sm param; add simple and multiline\n\tparams.\n\t(sm_state_map::dump): Drop sm param; add simple param.\n\t(sm_state_map::get_state): Port from svalue_id to const svalue *.\n\tAdd ext_state param.\n\t(sm_state_map::get_origin): Likewise.\n\t(sm_state_map::set_state): Likewise.\n\t(sm_state_map::impl_set_state): Likewise.\n\t(sm_state_map::purge_for_unknown_fncall): Delete.\n\t(sm_state_map::remap_svalue_ids): Delete.\n\t(sm_state_map::on_svalue_purge): Delete.\n\t(sm_state_map::on_svalue_leak): New.\n\t(sm_state_map::on_liveness_change): New.\n\t(sm_state_map::on_inherited_svalue): Delete.\n\t(sm_state_map::on_cast): Delete.\n\t(sm_state_map::validate): Delete.\n\t(sm_state_map::on_unknown_change): Port from svalue_id to\n\tconst svalue *.  Add is_mutable and ext_state params.\n\t(sm_state_map::canonicalize_svalue): New.\n\t(sm_state_map::m_sm): New field.\n\t(sm_state_map::m_sm_idx): New field.\n\t(program_state::operator=): Delete.\n\t(program_state::dump_to_pp): Drop \"summarize\" param, adding\n\t\"simple\" and \"multiline\".\n\t(program_state::dump_to_file): Likewise.\n\t(program_state::dump): Rename \"summarize\" to \"simple\".\n\t(program_state::push_frame): New.\n\t(program_state::get_current_function): New.\n\t(program_state::on_edge): Drop \"change\" param.\n\t(program_state::prune_for_point): Likewise.  Add enode_for_diag\n\tparam.\n\t(program_state::remap_svalue_ids): Delete.\n\t(program_state::get_representative_tree): Port from svalue_id to\n\tconst svalue *.\n\t(program_state::can_purge_p): Likewise.  Pass ext_state to get_state.\n\t(program_state::can_merge_with_p): Add point param.\n\t(program_state::detect_leaks): New.\n\t(state_change_visitor::on_state_change): Port from tree and\n\tsvalue_id to a pair of const svalue *.\n\t(class state_change): Delete.\n\t* region.cc: New file.\n\t* region-model-impl-calls.cc: New file.\n\t* region-model-manager.cc: New file.\n\t* region-model-reachability.cc: New file.\n\t* region-model-reachability.h: New file.\n\t* region-model.cc: Include \"analyzer/call-string.h\",\n\t\"analyzer/program-point.h\", and \"analyzer/store.h\" before\n\t\"analyzer/region-model.h\".  Include\n\t\"analyzer/region-model-reachability.h\".\n\t(dump_tree): Make non-static.\n\t(dump_quoted_tree): Make non-static.\n\t(print_quoted_type): Make non-static.\n\t(path_var::dump): Delete.\n\t(dump_separator): Delete.\n\t(class impl_constraint_manager): Delete.\n\t(svalue_id::print): Delete.\n\t(svalue_id::dump_node_name_to_pp): Delete.\n\t(svalue_id::validate): Delete.\n\t(region_id::print): Delete.\n\t(region_id::dump_node_name_to_pp): Delete.\n\t(region_id::validate): Delete.\n\t(region_id_set::region_id_set): Delete.\n\t(svalue_id_set::svalue_id_set): Delete.\n\t(svalue::operator==): Delete.\n\t(svalue::hash): Delete.\n\t(svalue::print): Delete.\n\t(svalue::dump_dot_to_pp): Delete.\n\t(svalue::remap_region_ids): Delete.\n\t(svalue::walk_for_canonicalization): Delete.\n\t(svalue::get_child_sid): Delete.\n\t(svalue::maybe_get_constant): Delete.\n\t(region_svalue::compare_fields): Delete.\n\t(region_svalue::add_to_hash): Delete.\n\t(region_svalue::print_details): Delete.\n\t(region_svalue::dump_dot_to_pp): Delete.\n\t(region_svalue::remap_region_ids): Delete.\n\t(region_svalue::merge_values): Delete.\n\t(region_svalue::walk_for_canonicalization): Delete.\n\t(region_svalue::eval_condition): Delete.\n\t(constant_svalue::compare_fields): Delete.\n\t(constant_svalue::add_to_hash): Delete.\n\t(constant_svalue::merge_values): Delete.\n\t(constant_svalue::eval_condition): Move to svalue.cc.\n\t(constant_svalue::print_details): Delete.\n\t(constant_svalue::get_child_sid): Delete.\n\t(unknown_svalue::compare_fields): Delete.\n\t(unknown_svalue::add_to_hash): Delete.\n\t(unknown_svalue::print_details): Delete.\n\t(poison_kind_to_str): Move to svalue.cc.\n\t(poisoned_svalue::compare_fields): Delete.\n\t(poisoned_svalue::add_to_hash): Delete.\n\t(poisoned_svalue::print_details): Delete.\n\t(region_kind_to_str): Move to region.cc and reimplement.\n\t(region::operator==): Delete.\n\t(region::get_parent_region): Delete.\n\t(region::set_value): Delete.\n\t(region::become_active_view): Delete.\n\t(region::deactivate_any_active_view): Delete.\n\t(region::deactivate_view): Delete.\n\t(region::get_value): Delete.\n\t(region::get_inherited_child_sid): Delete.\n\t(region_model::copy_region): Delete.\n\t(region_model::copy_struct_region): Delete.\n\t(region_model::copy_union_region): Delete.\n\t(region_model::copy_array_region): Delete.\n\t(region::hash): Delete.\n\t(region::print): Delete.\n\t(region::dump_dot_to_pp): Delete.\n\t(region::dump_to_pp): Delete.\n\t(region::dump_child_label): Delete.\n\t(region::validate): Delete.\n\t(region::remap_svalue_ids): Delete.\n\t(region::remap_region_ids): Delete.\n\t(region::add_view): Delete.\n\t(region::get_view): Delete.\n\t(region::region): Move to region.cc.\n\t(region::add_to_hash): Delete.\n\t(region::print_fields): Delete.\n\t(region::non_null_p): Delete.\n\t(primitive_region::clone): Delete.\n\t(primitive_region::walk_for_canonicalization): Delete.\n\t(map_region::map_region): Delete.\n\t(map_region::compare_fields): Delete.\n\t(map_region::print_fields): Delete.\n\t(map_region::validate): Delete.\n\t(map_region::dump_dot_to_pp): Delete.\n\t(map_region::dump_child_label): Delete.\n\t(map_region::get_or_create): Delete.\n\t(map_region::get): Delete.\n\t(map_region::add_to_hash): Delete.\n\t(map_region::remap_region_ids): Delete.\n\t(map_region::unbind): Delete.\n\t(map_region::get_tree_for_child_region): Delete.\n\t(map_region::get_tree_for_child_region): Delete.\n\t(tree_cmp): Move to region.cc.\n\t(map_region::can_merge_p): Delete.\n\t(map_region::walk_for_canonicalization): Delete.\n\t(map_region::get_value_by_name): Delete.\n\t(struct_or_union_region::valid_key_p): Delete.\n\t(struct_or_union_region::compare_fields): Delete.\n\t(struct_region::clone): Delete.\n\t(struct_region::compare_fields): Delete.\n\t(union_region::clone): Delete.\n\t(union_region::compare_fields): Delete.\n\t(frame_region::compare_fields): Delete.\n\t(frame_region::clone): Delete.\n\t(frame_region::valid_key_p): Delete.\n\t(frame_region::print_fields): Delete.\n\t(frame_region::add_to_hash): Delete.\n\t(globals_region::compare_fields): Delete.\n\t(globals_region::clone): Delete.\n\t(globals_region::valid_key_p): Delete.\n\t(code_region::compare_fields): Delete.\n\t(code_region::clone): Delete.\n\t(code_region::valid_key_p): Delete.\n\t(array_region::array_region): Delete.\n\t(array_region::get_element): Delete.\n\t(array_region::clone): Delete.\n\t(array_region::compare_fields): Delete.\n\t(array_region::print_fields): Delete.\n\t(array_region::validate): Delete.\n\t(array_region::dump_dot_to_pp): Delete.\n\t(array_region::dump_child_label): Delete.\n\t(array_region::get_or_create): Delete.\n\t(array_region::get): Delete.\n\t(array_region::add_to_hash): Delete.\n\t(array_region::remap_region_ids): Delete.\n\t(array_region::get_key_for_child_region): Delete.\n\t(array_region::key_cmp): Delete.\n\t(array_region::walk_for_canonicalization): Delete.\n\t(array_region::key_from_constant): Delete.\n\t(array_region::constant_from_key): Delete.\n\t(function_region::compare_fields): Delete.\n\t(function_region::clone): Delete.\n\t(function_region::valid_key_p): Delete.\n\t(stack_region::stack_region): Delete.\n\t(stack_region::compare_fields): Delete.\n\t(stack_region::clone): Delete.\n\t(stack_region::print_fields): Delete.\n\t(stack_region::dump_child_label): Delete.\n\t(stack_region::validate): Delete.\n\t(stack_region::push_frame): Delete.\n\t(stack_region::get_current_frame_id): Delete.\n\t(stack_region::pop_frame): Delete.\n\t(stack_region::add_to_hash): Delete.\n\t(stack_region::remap_region_ids): Delete.\n\t(stack_region::can_merge_p): Delete.\n\t(stack_region::walk_for_canonicalization): Delete.\n\t(stack_region::get_value_by_name): Delete.\n\t(heap_region::heap_region): Delete.\n\t(heap_region::compare_fields): Delete.\n\t(heap_region::clone): Delete.\n\t(heap_region::walk_for_canonicalization): Delete.\n\t(root_region::root_region): Delete.\n\t(root_region::compare_fields): Delete.\n\t(root_region::clone): Delete.\n\t(root_region::print_fields): Delete.\n\t(root_region::validate): Delete.\n\t(root_region::dump_child_label): Delete.\n\t(root_region::push_frame): Delete.\n\t(root_region::get_current_frame_id): Delete.\n\t(root_region::pop_frame): Delete.\n\t(root_region::ensure_stack_region): Delete.\n\t(root_region::get_stack_region): Delete.\n\t(root_region::ensure_globals_region): Delete.\n\t(root_region::get_code_region): Delete.\n\t(root_region::ensure_code_region): Delete.\n\t(root_region::get_globals_region): Delete.\n\t(root_region::ensure_heap_region): Delete.\n\t(root_region::get_heap_region): Delete.\n\t(root_region::remap_region_ids): Delete.\n\t(root_region::can_merge_p): Delete.\n\t(root_region::add_to_hash): Delete.\n\t(root_region::walk_for_canonicalization): Delete.\n\t(root_region::get_value_by_name): Delete.\n\t(symbolic_region::symbolic_region): Delete.\n\t(symbolic_region::compare_fields): Delete.\n\t(symbolic_region::clone): Delete.\n\t(symbolic_region::walk_for_canonicalization): Delete.\n\t(symbolic_region::print_fields): Delete.\n\t(region_model::region_model): Add region_model_manager * param.\n\tReimplement in terms of store, dropping impl_constraint_manager\n\tsubclass.\n\t(region_model::operator=): Reimplement in terms of store\n\t(region_model::operator==): Likewise.\n\t(region_model::hash): Likewise.\n\t(region_model::print): Delete.\n\t(region_model::print_svalue): Delete.\n\t(region_model::dump_dot_to_pp): Delete.\n\t(region_model::dump_dot_to_file): Delete.\n\t(region_model::dump_dot): Delete.\n\t(region_model::dump_to_pp): Replace \"summarize\" param with\n\t\"simple\" and \"multiline\".  Port to store-based implementation.\n\t(region_model::dump): Replace \"summarize\" param with \"simple\" and\n\t\"multiline\".\n\t(dump_vec_of_tree): Delete.\n\t(region_model::dump_summary_of_rep_path_vars): Delete.\n\t(region_model::validate): Delete.\n\t(svalue_id_cmp_by_constant_svalue_model): Delete.\n\t(svalue_id_cmp_by_constant_svalue): Delete.\n\t(region_model::canonicalize): Drop \"ctxt\" param.  Reimplement in\n\tterms of store and constraints.\n\t(region_model::canonicalized_p): Remove NULL arg to canonicalize.\n\t(region_model::loop_replay_fixup): New.\n\t(poisoned_value_diagnostic::emit): Tweak wording of warnings.\n\t(region_model::check_for_poison): Delete.\n\t(region_model::get_gassign_result): New.\n\t(region_model::on_assignment): Port to store-based implementation.\n\t(region_model::on_call_pre): Delete calls to check_for_poison.\n\tMove implementations to region-model-impl-calls.c and port to\n\tstore-based implementation.\n\t(region_model::on_call_post): Likewise.\n\t(class reachable_regions): Move to region-model-reachability.h/cc\n\tand port to store-based implementation.\n\t(region_model::handle_unrecognized_call): Port to store-based\n\timplementation.\n\t(region_model::get_reachable_svalues): New.\n\t(region_model::on_setjmp): Port to store-based implementation.\n\t(region_model::on_longjmp): Likewise.\n\t(region_model::handle_phi): Drop is_back_edge param and the logic\n\tusing it.\n\t(region_model::get_lvalue_1): Port from region_id to const region *.\n\t(region_model::make_region_for_unexpected_tree_code): Delete.\n\t(assert_compat_types): If the check fails, use internal_error to\n\tshow the types.\n\t(region_model::get_lvalue): Port from region_id to const region *.\n\t(region_model::get_rvalue_1): Port from svalue_id to const svalue *.\n\t(region_model::get_rvalue): Likewise.\n\t(region_model::get_or_create_ptr_svalue): Delete.\n\t(region_model::get_or_create_constant_svalue): Delete.\n\t(region_model::get_svalue_for_fndecl): Delete.\n\t(region_model::get_region_for_fndecl): Delete.\n\t(region_model::get_svalue_for_label): Delete.\n\t(region_model::get_region_for_label): Delete.\n\t(build_cast): Delete.\n\t(region_model::maybe_cast_1): Delete.\n\t(region_model::maybe_cast): Delete.\n\t(region_model::get_field_region): Delete.\n\t(region_model::get_store_value): New.\n\t(region_model::region_exists_p): New.\n\t(region_model::deref_rvalue): Port from svalue_id to const svalue *.\n\t(region_model::set_value): Likewise.\n\t(region_model::clobber_region): New.\n\t(region_model::purge_region): New.\n\t(region_model::zero_fill_region): New.\n\t(region_model::mark_region_as_unknown): New.\n\t(region_model::eval_condition): Port from svalue_id to\n\tconst svalue *.\n\t(region_model::eval_condition_without_cm): Likewise.\n\t(region_model::compare_initial_and_pointer): New.\n\t(region_model::add_constraint): Port from svalue_id to\n\tconst svalue *.\n\t(region_model::maybe_get_constant): Delete.\n\t(region_model::get_representative_path_var): New.\n\t(region_model::add_new_malloc_region): Delete.\n\t(region_model::get_representative_tree): Port to const svalue *.\n\t(region_model::get_representative_path_var): Port to\n\tconst region *.\n\t(region_model::get_path_vars_for_svalue): Delete.\n\t(region_model::set_to_new_unknown_value): Delete.\n\t(region_model::update_for_phis): Don't pass is_back_edge to handle_phi.\n\t(region_model::update_for_call_superedge): Port from svalue_id to\n\tconst svalue *.\n\t(region_model::update_for_return_superedge): Port to store-based\n\timplementation.\n\t(region_model::update_for_call_summary): Replace\n\tset_to_new_unknown_value with mark_region_as_unknown.\n\t(region_model::get_root_region): Delete.\n\t(region_model::get_stack_region_id): Delete.\n\t(region_model::push_frame): Delete.\n\t(region_model::get_current_frame_id): Delete.\n\t(region_model::get_current_function): Delete.\n\t(region_model::pop_frame): Delete.\n\t(region_model::on_top_level_param): New.\n\t(region_model::get_stack_depth): Delete.\n\t(region_model::get_function_at_depth): Delete.\n\t(region_model::get_globals_region_id): Delete.\n\t(region_model::add_svalue): Delete.\n\t(region_model::replace_svalue): Delete.\n\t(region_model::add_region): Delete.\n\t(region_model::get_svalue): Delete.\n\t(region_model::get_region): Delete.\n\t(make_region_for_type): Delete.\n\t(region_model::add_region_for_type): Delete.\n\t(region_model::on_top_level_param): New.\n\t(class restrict_to_used_svalues): Delete.\n\t(region_model::purge_unused_svalues): Delete.\n\t(region_model::push_frame): New.\n\t(region_model::remap_svalue_ids): Delete.\n\t(region_model::remap_region_ids): Delete.\n\t(region_model::purge_regions): Delete.\n\t(region_model::get_descendents): Delete.\n\t(region_model::delete_region_and_descendents): Delete.\n\t(region_model::poison_any_pointers_to_bad_regions): Delete.\n\t(region_model::can_merge_with_p): Delete.\n\t(region_model::get_current_function): New.\n\t(region_model::get_value_by_name): Delete.\n\t(region_model::convert_byte_offset_to_array_index): Delete.\n\t(region_model::pop_frame): New.\n\t(region_model::get_or_create_mem_ref): Delete.\n\t(region_model::get_stack_depth): New.\n\t(region_model::get_frame_at_index): New.\n\t(region_model::unbind_region_and_descendents): New.\n\t(struct bad_pointer_finder): New.\n\t(region_model::get_or_create_pointer_plus_expr): Delete.\n\t(region_model::poison_any_pointers_to_descendents): New.\n\t(region_model::get_or_create_view): Delete.\n\t(region_model::can_merge_with_p): New.\n\t(region_model::get_fndecl_for_call):  Port from svalue_id to\n\tconst svalue *.\n\t(struct append_ssa_names_cb_data): New.\n\t(get_ssa_name_regions_for_current_frame): New.\n\t(region_model::append_ssa_names_cb): New.\n\t(model_merger::dump_to_pp): Add \"simple\" param.  Drop dumping of\n\tremappings.\n\t(model_merger::dump): Add \"simple\" param to both overloads.\n\t(model_merger::can_merge_values_p): Delete.\n\t(model_merger::record_regions): Delete.\n\t(model_merger::record_svalues): Delete.\n\t(svalue_id_merger_mapping::svalue_id_merger_mapping): Delete.\n\t(svalue_id_merger_mapping::dump_to_pp): Delete.\n\t(svalue_id_merger_mapping::dump): Delete.\n\t(region_model::create_region_for_heap_alloc): New.\n\t(region_model::create_region_for_alloca): New.\n\t(region_model::record_dynamic_extents): New.\n\t(canonicalization::canonicalization): Delete.\n\t(canonicalization::walk_rid): Delete.\n\t(canonicalization::walk_sid): Delete.\n\t(canonicalization::dump_to_pp): Delete.\n\t(canonicalization::dump): Delete.\n\t(inchash::add): Delete overloads for svalue_id and region_id.\n\t(engine::log_stats): New.\n\t(assert_condition): Add overload comparing svalues.\n\t(assert_dump_eq): Pass \"true\" for multiline.\n\t(selftest::test_dump): Update for rewrite of region_model.\n\t(selftest::test_dump_2): Rename to...\n\t(selftest::test_struct): ...this.  Provide a region_model_manager\n\twhen creating region_model instance.  Remove dump test.  Add\n\tchecks for get_offset.\n\t(selftest::test_dump_3): Rename to...\n\t(selftest::test_array_1): ...this.  Provide a region_model_manager\n\twhen creating region_model instance.  Remove dump test.\n\t(selftest::test_get_representative_tree): Port from svalue_id to\n\tnew API.  Add test coverage for various expressions.\n\t(selftest::test_unique_constants): Provide a region_model_manager\n\tfor the region_model.  Add test coverage for comparing const vs\n\tnon-const.\n\t(selftest::test_svalue_equality): Delete.\n\t(selftest::test_region_equality): Delete.\n\t(selftest::test_unique_unknowns): New.\n\t(class purge_all_svalue_ids): Delete.\n\t(class purge_one_svalue_id): Delete.\n\t(selftest::test_purging_by_criteria): Delete.\n\t(selftest::test_initial_svalue_folding): New.\n\t(selftest::test_unaryop_svalue_folding): New.\n\t(selftest::test_binop_svalue_folding): New.\n\t(selftest::test_sub_svalue_folding): New.\n\t(selftest::test_purge_unused_svalues): Delete.\n\t(selftest::test_descendent_of_p): New.\n\t(selftest::test_assignment): Provide a region_model_manager for\n\tthe region_model.  Drop the dump test.\n\t(selftest::test_compound_assignment): Likewise.\n\t(selftest::test_stack_frames): Port to new implementation.\n\t(selftest::test_get_representative_path_var): Likewise.\n\t(selftest::test_canonicalization_1): Rename to...\n\t(selftest::test_equality_1): ...this.  Port to new API, and add\n\t(selftest::test_canonicalization_2): Provide a\n\tregion_model_manager when creating region_model instances.\n\tRemove redundant canicalization.\n\t(selftest::test_canonicalization_3): Provide a\n\tregion_model_manager when creating region_model instances.\n\tRemove param from calls to region_model::canonicalize.\n\t(selftest::test_canonicalization_4): Likewise.\n\t(selftest::assert_region_models_merge): Constify\n\tout_merged_svalue.  Port to new API.\n\t(selftest::test_state_merging): Provide a\n\tregion_model_manager when creating region_model instances.\n\tProvide a program_point point when merging them.  Replace\n\tset_to_new_unknown_value with usage of placeholder_svalues.\n\tDrop get_value_by_name.  Port from svalue_id to const svalue *.\n\tAdd test of heap allocation.\n\t(selftest::test_constraint_merging):  Provide a\n\tregion_model_manager when creating region_model instances.\n\tProvide a program_point point when merging them.  Eliminate use\n\tof set_to_new_unknown_value.\n\t(selftest::test_widening_constraints): New.\n\t(selftest::test_iteration_1): New.\n\t(selftest::test_malloc_constraints): Port to store-based\n\timplementation.\n\t(selftest::test_var): New test.\n\t(selftest::test_array_2): New test.\n\t(selftest::test_mem_ref): New test.\n\t(selftest::test_POINTER_PLUS_EXPR_then_MEM_REF): New.\n\t(selftest::test_malloc): New.\n\t(selftest::test_alloca): New.\n\t(selftest::analyzer_region_model_cc_tests): Update for renamings.\n\tCall new functions.\n\t* region-model.h (class path_var): Move to analyzer.h.\n\t(class svalue_id): Delete.\n\t(class region_id): Delete.\n\t(class id_map): Delete.\n\t(svalue_id_map): Delete.\n\t(region_id_map): Delete.\n\t(id_map<T>::id_map): Delete.\n\t(id_map<T>::put): Delete.\n\t(id_map<T>::get_dst_for_src): Delete.\n\t(id_map<T>::get_src_for_dst): Delete.\n\t(id_map<T>::dump_to_pp): Delete.\n\t(id_map<T>::dump): Delete.\n\t(id_map<T>::update): Delete.\n\t(one_way_svalue_id_map): Delete.\n\t(one_way_region_id_map): Delete.\n\t(class region_id_set): Delete.\n\t(class svalue_id_set): Delete.\n\t(struct complexity): New.\n\t(class visitor): New.\n\t(enum svalue_kind): Add SK_SETJMP, SK_INITIAL, SK_UNARYOP,\n\tSK_BINOP, SK_SUB,SK_UNMERGEABLE, SK_PLACEHOLDER, SK_WIDENING,\n\tSK_COMPOUND, and SK_CONJURED.\n\t(svalue::operator==): Delete.\n\t(svalue::operator!=): Delete.\n\t(svalue::clone): Delete.\n\t(svalue::hash): Delete.\n\t(svalue::dump_dot_to_pp): Delete.\n\t(svalue::dump_to_pp): New.\n\t(svalue::dump): New.\n\t(svalue::get_desc): New.\n\t(svalue::dyn_cast_initial_svalue): New.\n\t(svalue::dyn_cast_unaryop_svalue): New.\n\t(svalue::dyn_cast_binop_svalue): New.\n\t(svalue::dyn_cast_sub_svalue): New.\n\t(svalue::dyn_cast_unmergeable_svalue): New.\n\t(svalue::dyn_cast_widening_svalue): New.\n\t(svalue::dyn_cast_compound_svalue): New.\n\t(svalue::dyn_cast_conjured_svalue): New.\n\t(svalue::maybe_undo_cast): New.\n\t(svalue::unwrap_any_unmergeable): New.\n\t(svalue::remap_region_ids): Delete\n\t(svalue::can_merge_p): New.\n\t(svalue::walk_for_canonicalization): Delete\n\t(svalue::get_complexity): New.\n\t(svalue::get_child_sid): Delete\n\t(svalue::accept): New.\n\t(svalue::live_p): New.\n\t(svalue::implicitly_live_p): New.\n\t(svalue::svalue): Add complexity param.\n\t(svalue::add_to_hash): Delete\n\t(svalue::print_details): Delete\n\t(svalue::m_complexity): New field.\n\t(region_svalue::key_t): New struct.\n\t(region_svalue::region_svalue): Port from region_id to\n\tconst region_id *.  Add complexity.\n\t(region_svalue::compare_fields): Delete.\n\t(region_svalue::clone): Delete.\n\t(region_svalue::dump_dot_to_pp): Delete.\n\t(region_svalue::get_pointee): Port from region_id to\n\tconst region_id *.\n\t(region_svalue::remap_region_ids): Delete.\n\t(region_svalue::merge_values): Delete.\n\t(region_svalue::dump_to_pp): New.\n\t(region_svalue::accept): New.\n\t(region_svalue::walk_for_canonicalization): Delete.\n\t(region_svalue::eval_condition): Make params const.\n\t(region_svalue::add_to_hash): Delete.\n\t(region_svalue::print_details): Delete.\n\t(region_svalue::m_rid): Replace with...\n\t(region_svalue::m_reg): ...this.\n\t(is_a_helper <region_svalue *>::test): Convert to...\n\t(is_a_helper <const region_svalue *>::test): ...this.\n\t(template <> struct default_hash_traits<region_svalue::key_t>):\n\tNew.\n\t(constant_svalue::constant_svalue): Add complexity.\n\t(constant_svalue::compare_fields): Delete.\n\t(constant_svalue::clone): Delete.\n\t(constant_svalue::add_to_hash): Delete.\n\t(constant_svalue::dump_to_pp): New.\n\t(constant_svalue::accept): New.\n\t(constant_svalue::implicitly_live_p): New.\n\t(constant_svalue::merge_values): Delete.\n\t(constant_svalue::eval_condition): Make params const.\n\t(constant_svalue::get_child_sid): Delete.\n\t(constant_svalue::print_details): Delete.\n\t(is_a_helper <constant_svalue *>::test): Convert to...\n\t(is_a_helper <const constant_svalue *>::test): ...this.\n\t(class unknown_svalue): Update leading comment.\n\t(unknown_svalue::unknown_svalue): Add complexity.\n\t(unknown_svalue::compare_fields): Delete.\n\t(unknown_svalue::add_to_hash): Delete.\n\t(unknown_svalue::dyn_cast_unknown_svalue): Delete.\n\t(unknown_svalue::print_details): Delete.\n\t(unknown_svalue::dump_to_pp): New.\n\t(unknown_svalue::accept): New.\n\t(poisoned_svalue::key_t): New struct.\n\t(poisoned_svalue::poisoned_svalue): Add complexity.\n\t(poisoned_svalue::compare_fields): Delete.\n\t(poisoned_svalue::clone): Delete.\n\t(poisoned_svalue::add_to_hash): Delete.\n\t(poisoned_svalue::dump_to_pp): New.\n\t(poisoned_svalue::accept): New.\n\t(poisoned_svalue::print_details): Delete.\n\t(is_a_helper <poisoned_svalue *>::test): Convert to...\n\t(is_a_helper <const poisoned_svalue *>::test): ...this.\n\t(template <> struct default_hash_traits<poisoned_svalue::key_t>):\n\tNew.\n\t(setjmp_record::add_to_hash): New.\n\t(setjmp_svalue::key_t): New struct.\n\t(setjmp_svalue::compare_fields): Delete.\n\t(setjmp_svalue::clone): Delete.\n\t(setjmp_svalue::add_to_hash): Delete.\n\t(setjmp_svalue::setjmp_svalue): Add complexity.\n\t(setjmp_svalue::dump_to_pp): New.\n\t(setjmp_svalue::accept): New.\n\t(setjmp_svalue::void print_details): Delete.\n\t(is_a_helper <const setjmp_svalue *>::test): New.\n\t(template <> struct default_hash_traits<setjmp_svalue::key_t>): New.\n\t(class initial_svalue : public svalue): New.\n\t(is_a_helper <const initial_svalue *>::test): New.\n\t(class unaryop_svalue): New.\n\t(is_a_helper <const unaryop_svalue *>::test): New.\n\t(template <> struct default_hash_traits<unaryop_svalue::key_t>): New.\n\t(class binop_svalue): New.\n\t(is_a_helper <const binop_svalue *>::test): New.\n\t(template <> struct default_hash_traits<binop_svalue::key_t>): New.\n\t(class sub_svalue): New.\n\t(is_a_helper <const sub_svalue *>::test): New.\n\t(template <> struct default_hash_traits<sub_svalue::key_t>): New.\n\t(class unmergeable_svalue): New.\n\t(is_a_helper <const unmergeable_svalue *>::test): New.\n\t(class placeholder_svalue): New.\n\t(is_a_helper <placeholder_svalue *>::test): New.\n\t(class widening_svalue): New.\n\t(is_a_helper <widening_svalue *>::test): New.\n\t(template <> struct default_hash_traits<widening_svalue::key_t>): New.\n\t(class compound_svalue): New.\n\t(is_a_helper <compound_svalue *>::test): New.\n\t(template <> struct default_hash_traits<compound_svalue::key_t>): New.\n\t(class conjured_svalue): New.\n\t(is_a_helper <conjured_svalue *>::test): New.\n\t(template <> struct default_hash_traits<conjured_svalue::key_t>): New.\n\t(enum region_kind): Delete RK_PRIMITIVE, RK_STRUCT, RK_UNION, and\n\tRK_ARRAY.  Add RK_LABEL, RK_DECL, RK_FIELD, RK_ELEMENT, RK_OFFSET,\n\tRK_CAST, RK_HEAP_ALLOCATED, RK_ALLOCA, RK_STRING, and RK_UNKNOWN.\n\t(region_kind_to_str): Delete.\n\t(region::~region): Move implementation to region.cc.\n\t(region::operator==): Delete.\n\t(region::operator!=): Delete.\n\t(region::clone): Delete.\n\t(region::get_id): New.\n\t(region::cmp_ids): New.\n\t(region::dyn_cast_map_region): Delete.\n\t(region::dyn_cast_array_region): Delete.\n\t(region::region_id get_parent): Delete.\n\t(region::get_parent_region): Convert to a simple accessor.\n\t(region::void set_value): Delete.\n\t(region::svalue_id get_value): Delete.\n\t(region::svalue_id get_value_direct): Delete.\n\t(region::svalue_id get_inherited_child_sid): Delete.\n\t(region::dyn_cast_frame_region): New.\n\t(region::dyn_cast_function_region): New.\n\t(region::dyn_cast_decl_region): New.\n\t(region::dyn_cast_field_region): New.\n\t(region::dyn_cast_element_region): New.\n\t(region::dyn_cast_offset_region): New.\n\t(region::dyn_cast_cast_region): New.\n\t(region::dyn_cast_string_region): New.\n\t(region::accept): New.\n\t(region::get_base_region): New.\n\t(region::base_region_p): New.\n\t(region::descendent_of_p): New.\n\t(region::maybe_get_frame_region): New.\n\t(region::maybe_get_decl): New.\n\t(region::hash): Delete.\n\t(region::rint): Delete.\n\t(region::dump_dot_to_pp): Delete.\n\t(region::get_desc): New.\n\t(region::dump_to_pp): Convert to vfunc, changing signature.\n\t(region::dump_child_label): Delete.\n\t(region::remap_svalue_ids): Delete.\n\t(region::remap_region_ids): Delete.\n\t(region::dump): New.\n\t(region::walk_for_canonicalization): Delete.\n\t(region::non_null_p): Drop region_model param.\n\t(region::add_view): Delete.\n\t(region::get_view): Delete.\n\t(region::get_active_view): Delete.\n\t(region::is_view_p): Delete.\n\t(region::cmp_ptrs): New.\n\t(region::validate): Delete.\n\t(region::get_offset): New.\n\t(region::get_byte_size): New.\n\t(region::get_bit_size): New.\n\t(region::get_subregions_for_binding): New.\n\t(region::region): Add complexity param.  Convert parent from\n\tregion_id to const region *.  Drop svalue_id.  Drop copy ctor.\n\t(region::symbolic_for_unknown_ptr_p): New.\n\t(region::add_to_hash): Delete.\n\t(region::print_fields): Delete.\n\t(region::get_complexity): New accessor.\n\t(region::become_active_view): Delete.\n\t(region::deactivate_any_active_view): Delete.\n\t(region::deactivate_view): Delete.\n\t(region::calc_offset): New.\n\t(region::m_parent_rid): Delete.\n\t(region::m_sval_id): Delete.\n\t(region::m_complexity): New.\n\t(region::m_id): New.\n\t(region::m_parent): New.\n\t(region::m_view_rids): Delete.\n\t(region::m_is_view): Delete.\n\t(region::m_active_view_rid): Delete.\n\t(region::m_cached_offset): New.\n\t(is_a_helper <region *>::test): Convert to...\n\t(is_a_helper <const region *>::test): ... this.\n\t(class primitive_region): Delete.\n\t(class space_region): New.\n\t(class map_region): Delete.\n\t(is_a_helper <map_region *>::test): Delete.\n\t(class frame_region): Reimplement.\n\t(template <> struct default_hash_traits<frame_region::key_t>):\n\tNew.\n\t(class globals_region): Reimplement.\n\t(is_a_helper <globals_region *>::test): Convert to...\n\t(is_a_helper <const globals_region *>::test): ...this.\n\t(class struct_or_union_region): Delete.\n\t(is_a_helper <struct_or_union_region *>::test): Delete.\n\t(class code_region): Reimplement.\n\t(is_a_helper <const code_region *>::test): New.\n\t(class struct_region): Delete.\n\t(is_a_helper <struct_region *>::test): Delete.\n\t(class function_region): Reimplement.\n\t(is_a_helper <function_region *>::test): Convert to...\n\t(is_a_helper <const function_region *>::test): ...this.\n\t(class union_region): Delete.\n\t(is_a_helper <union_region *>::test): Delete.\n\t(class label_region): New.\n\t(is_a_helper <const label_region *>::test): New.\n\t(class scope_region): Delete.\n\t(class stack_region): Reimplement.\n\t(is_a_helper <stack_region *>::test): Convert to...\n\t(is_a_helper <const stack_region *>::test): ...this.\n\t(class heap_region): Reimplement.\n\t(is_a_helper <heap_region *>::test): Convert to...\n\t(is_a_helper <const heap_region *>::test): ...this.\n\t(class root_region): Reimplement.\n\t(is_a_helper <root_region *>::test): Convert to...\n\t(is_a_helper <const root_region *>::test): ...this.\n\t(class symbolic_region): Reimplement.\n\t(is_a_helper <const symbolic_region *>::test): New.\n\t(template <> struct default_hash_traits<symbolic_region::key_t>):\n\tNew.\n\t(class decl_region): New.\n\t(is_a_helper <const decl_region *>::test): New.\n\t(class field_region): New.\n\t(template <> struct default_hash_traits<field_region::key_t>): New.\n\t(class array_region): Delete.\n\t(class element_region): New.\n\t(is_a_helper <array_region *>::test): Delete.\n\t(is_a_helper <const element_region *>::test): New.\n\t(template <> struct default_hash_traits<element_region::key_t>):\n\tNew.\n\t(class offset_region): New.\n\t(is_a_helper <const offset_region *>::test): New.\n\t(template <> struct default_hash_traits<offset_region::key_t>):\n\tNew.\n\t(class cast_region): New.\n\t(is_a_helper <const cast_region *>::test): New.\n\t(template <> struct default_hash_traits<cast_region::key_t>): New.\n\t(class heap_allocated_region): New.\n\t(class alloca_region): New.\n\t(class string_region): New.\n\t(is_a_helper <const string_region *>::test): New.\n\t(class unknown_region): New.\n\t(class region_model_manager): New.\n\t(struct append_ssa_names_cb_data): New.\n\t(class call_details): New.\n\t(region_model::region_model): Add region_model_manager param.\n\t(region_model::print_svalue): Delete.\n\t(region_model::dump_dot_to_pp): Delete.\n\t(region_model::dump_dot_to_file): Delete.\n\t(region_model::dump_dot): Delete.\n\t(region_model::dump_to_pp): Drop summarize param in favor of\n\tsimple and multiline.\n\t(region_model::dump): Likewise.\n\t(region_model::summarize_to_pp): Delete.\n\t(region_model::summarize): Delete.\n\t(region_model::void canonicalize): Drop ctxt param.\n\t(region_model::void check_for_poison): Delete.\n\t(region_model::get_gassign_result): New.\n\t(region_model::impl_call_alloca): New.\n\t(region_model::impl_call_analyzer_describe): New.\n\t(region_model::impl_call_analyzer_eval): New.\n\t(region_model::impl_call_builtin_expect): New.\n\t(region_model::impl_call_calloc): New.\n\t(region_model::impl_call_free): New.\n\t(region_model::impl_call_malloc): New.\n\t(region_model::impl_call_memset): New.\n\t(region_model::impl_call_strlen): New.\n\t(region_model::get_reachable_svalues): New.\n\t(region_model::handle_phi): Drop is_back_edge param.\n\t(region_model::region_id get_root_rid): Delete.\n\t(region_model::root_region *get_root_region): Delete.\n\t(region_model::region_id get_stack_region_id): Delete.\n\t(region_model::push_frame): Convert from region_id and svalue_id\n\tto const region * and const svalue *.\n\t(region_model::get_current_frame_id): Replace with...\n\t(region_model::get_current_frame): ...this.\n\t(region_model::pop_frame): Convert from region_id to\n\tconst region *.  Drop purge and stats param.  Add out_result.\n\t(region_model::function *get_function_at_depth): Delete.\n\t(region_model::get_globals_region_id): Delete.\n\t(region_model::add_svalue): Delete.\n\t(region_model::replace_svalue): Delete.\n\t(region_model::add_region): Delete.\n\t(region_model::add_region_for_type): Delete.\n\t(region_model::get_svalue): Delete.\n\t(region_model::get_region): Delete.\n\t(region_model::get_lvalue): Convert from region_id to\n\tconst region *.\n\t(region_model::get_rvalue): Convert from svalue_id to\n\tconst svalue *.\n\t(region_model::get_or_create_ptr_svalue): Delete.\n\t(region_model::get_or_create_constant_svalue): Delete.\n\t(region_model::get_svalue_for_fndecl): Delete.\n\t(region_model::get_svalue_for_label): Delete.\n\t(region_model::get_region_for_fndecl): Delete.\n\t(region_model::get_region_for_label): Delete.\n\t(region_model::get_frame_at_index (int index) const;): New.\n\t(region_model::maybe_cast): Delete.\n\t(region_model::maybe_cast_1): Delete.\n\t(region_model::get_field_region): Delete.\n\t(region_model::id deref_rvalue): Convert from region_id and\n\tsvalue_id to const region * and const svalue *.  Drop overload,\n\tpassing in both a tree and an svalue.\n\t(region_model::set_value): Convert from region_id and svalue_id to\n\tconst region * and const svalue *.\n\t(region_model::set_to_new_unknown_value): Delete.\n\t(region_model::clobber_region (const region *reg);): New.\n\t(region_model::purge_region (const region *reg);): New.\n\t(region_model::zero_fill_region (const region *reg);): New.\n\t(region_model::mark_region_as_unknown (const region *reg);): New.\n\t(region_model::copy_region): Convert from region_id to\n\tconst region *.\n\t(region_model::eval_condition): Convert from svalue_id to\n\tconst svalue *.\n\t(region_model::eval_condition_without_cm): Likewise.\n\t(region_model::compare_initial_and_pointer): New.\n\t(region_model:maybe_get_constant): Delete.\n\t(region_model::add_new_malloc_region): Delete.\n\t(region_model::get_representative_tree): Convert from svalue_id to\n\tconst svalue *.\n\t(region_model::get_representative_path_var): Delete decl taking a\n\tregion_id in favor of two decls, for svalue vs region, with an\n\tsvalue_set to ensure termination.\n\t(region_model::get_path_vars_for_svalue): Delete.\n\t(region_model::create_region_for_heap_alloc): New.\n\t(region_model::create_region_for_alloca): New.\n\t(region_model::purge_unused_svalues): Delete.\n\t(region_model::remap_svalue_ids): Delete.\n\t(region_model::remap_region_ids): Delete.\n\t(region_model::purge_regions): Delete.\n\t(region_model::get_num_svalues): Delete.\n\t(region_model::get_num_regions): Delete.\n\t(region_model::get_descendents): Delete.\n\t(region_model::get_store): New.\n\t(region_model::delete_region_and_descendents): Delete.\n\t(region_model::get_manager): New.\n\t(region_model::unbind_region_and_descendents): New.\n\t(region_model::can_merge_with_p): Add point param.  Drop\n\tsvalue_id_merger_mapping.\n\t(region_model::get_value_by_name): Delete.\n\t(region_model::convert_byte_offset_to_array_index): Delete.\n\t(region_model::get_or_create_mem_ref): Delete.\n\t(region_model::get_or_create_pointer_plus_expr): Delete.\n\t(region_model::get_or_create_view): Delete.\n\t(region_model::get_lvalue_1): Convert from region_id to\n\tconst region *.\n\t(region_model::get_rvalue_1): Convert from svalue_id to\n\tconst svalue *.\n\t(region_model::get_ssa_name_regions_for_current_frame): New.\n\t(region_model::append_ssa_names_cb): New.\n\t(region_model::get_store_value): New.\n\t(region_model::copy_struct_region): Delete.\n\t(region_model::copy_union_region): Delete.\n\t(region_model::copy_array_region): Delete.\n\t(region_model::region_exists_p): New.\n\t(region_model::make_region_for_unexpected_tree_code): Delete.\n\t(region_model::loop_replay_fixup): New.\n\t(region_model::poison_any_pointers_to_bad_regions): Delete.\n\t(region_model::poison_any_pointers_to_descendents): New.\n\t(region_model::dump_summary_of_rep_path_vars): Delete.\n\t(region_model::on_top_level_param): New.\n\t(region_model::record_dynamic_extents): New.\n\t(region_model::m_mgr;): New.\n\t(region_model::m_store;): New.\n\t(region_model::m_svalues;): Delete.\n\t(region_model::m_regions;): Delete.\n\t(region_model::m_root_rid;): Delete.\n\t(region_model::m_current_frame;): New.\n\t(region_model_context::remap_svalue_ids): Delete.\n\t(region_model_context::can_purge_p): Delete.\n\t(region_model_context::on_svalue_leak): New.\n\t(region_model_context::on_svalue_purge): Delete.\n\t(region_model_context::on_liveness_change): New.\n\t(region_model_context::on_inherited_svalue): Delete.\n\t(region_model_context::on_cast): Delete.\n\t(region_model_context::on_unknown_change): Convert from svalue_id to\n\tconst svalue * and add is_mutable.\n\t(class noop_region_model_context): Update for region_model_context\n\tchanges.\n\t(model_merger::model_merger): Add program_point.  Drop\n\tsvalue_id_merger_mapping.\n\t(model_merger::dump_to_pp): Add \"simple\" param.\n\t(model_merger::dump): Likewise.\n\t(model_merger::get_region_a): Delete.\n\t(model_merger::get_region_b): Delete.\n\t(model_merger::can_merge_values_p): Delete.\n\t(model_merger::record_regions): Delete.\n\t(model_merger::record_svalues): Delete.\n\t(model_merger::m_point): New field.\n\t(model_merger::m_map_regions_from_a_to_m): Delete.\n\t(model_merger::m_map_regions_from_b_to_m): Delete.\n\t(model_merger::m_sid_mapping): Delete.\n\t(struct svalue_id_merger_mapping): Delete.\n\t(class engine): New.\n\t(struct canonicalization): Delete.\n\t(inchash::add): Delete decls for hashing svalue_id and region_id.\n\t(test_region_model_context::on_unexpected_tree_code): Require t to\n\tbe non-NULL.\n\t(selftest::assert_condition): Add overload comparing a pair of\n\tconst svalue *.\n\t* sm-file.cc: Include \"tristate.h\", \"selftest.h\",\n\t\"analyzer/call-string.h\", \"analyzer/program-point.h\",\n\t\"analyzer/store.h\", and \"analyzer/region-model.h\".\n\t(fileptr_state_machine::get_default_state): New.\n\t(fileptr_state_machine::on_stmt): Remove calls to\n\tget_readable_tree in favor of get_diagnostic_tree.\n\t* sm-malloc.cc: Include \"tristate.h\", \"selftest.h\",\n\t\"analyzer/call-string.h\", \"analyzer/program-point.h\",\n\t\"analyzer/store.h\", and \"analyzer/region-model.h\".\n\t(malloc_state_machine::get_default_state): New.\n\t(malloc_state_machine::reset_when_passed_to_unknown_fn_p): New.\n\t(malloc_diagnostic::describe_state_change): Handle change.m_expr\n\tbeing NULL.\n\t(null_arg::emit): Avoid printing \"NULL '0'\".\n\t(null_arg::describe_final_event): Avoid printing \"(0) NULL\".\n\t(malloc_leak::emit): Handle m_arg being NULL.\n\t(malloc_leak::describe_final_event): Handle ev.m_expr being NULL.\n\t(malloc_state_machine::on_stmt): Don't call get_readable_tree.\n\tCall get_diagnostic_tree when creating pending diagnostics.\n\tUpdate for is_zero_assignment becoming a member function of\n\tsm_ctxt.\n\tDon't transition to m_non_heap for ADDR_EXPR(MEM_REF()).\n\t(malloc_state_machine::reset_when_passed_to_unknown_fn_p): New\n\tvfunc implementation.\n\t* sm-sensitive.cc (sensitive_state_machine::warn_for_any_exposure): Call\n\tget_diagnostic_tree and pass the result to warn_for_state.\n\t* sm-signal.cc: Move includes of \"analyzer/call-string.h\" and\n\t\"analyzer/program-point.h\" to before \"analyzer/region-model.h\",\n\tand also include \"analyzer/store.h\" before it.\n\t(signal_unsafe_call::describe_state_change): Use\n\tget_dest_function to get handler.\n\t(update_model_for_signal_handler): Pass manager to region_model\n\tctor.\n\t(register_signal_handler::impl_transition): Update for changes to\n\tget_or_create_nod\u2026", "tree": {"sha": "dbbeef4508d1df652fab4da7f56a89db52c81d8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbbeef4508d1df652fab4da7f56a89db52c81d8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/808f4dfeb3a95f50f15e71148e5c1067f90a126d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/808f4dfeb3a95f50f15e71148e5c1067f90a126d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/808f4dfeb3a95f50f15e71148e5c1067f90a126d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/808f4dfeb3a95f50f15e71148e5c1067f90a126d/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5034abbaa49f15646c83224711447aa1ed31756", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5034abbaa49f15646c83224711447aa1ed31756", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5034abbaa49f15646c83224711447aa1ed31756"}], "stats": {"total": 26555, "additions": 16153, "deletions": 10402}, "files": [{"sha": "79e854aa938101d09e75a3fe56af346e72ad9ea5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -1237,7 +1237,11 @@ ANALYZER_OBJS = \\\n \tanalyzer/pending-diagnostic.o \\\n \tanalyzer/program-point.o \\\n \tanalyzer/program-state.o \\\n+\tanalyzer/region.o \\\n \tanalyzer/region-model.o \\\n+\tanalyzer/region-model-impl-calls.o \\\n+\tanalyzer/region-model-manager.o \\\n+\tanalyzer/region-model-reachability.o \\\n \tanalyzer/sm.o \\\n \tanalyzer/sm-file.o \\\n \tanalyzer/sm-malloc.o \\\n@@ -1246,7 +1250,9 @@ ANALYZER_OBJS = \\\n \tanalyzer/sm-signal.o \\\n \tanalyzer/sm-taint.o \\\n \tanalyzer/state-purge.o \\\n-\tanalyzer/supergraph.o\n+\tanalyzer/store.o \\\n+\tanalyzer/supergraph.o \\\n+\tanalyzer/svalue.o\n \n # Language-independent object files.\n # We put the *-match.o and insn-*.o files first so that a parallel make"}, {"sha": "d2bbd05d32330edc7fd4724fcabc9596b744ed8c", "filename": "gcc/analyzer/analyzer-logging.cc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fanalyzer-logging.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fanalyzer-logging.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer-logging.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -30,6 +30,8 @@ along with GCC; see the file COPYING3.  If not see\n \n #if ENABLE_ANALYZER\n \n+#pragma GCC diagnostic ignored \"-Wformat-diag\"\n+\n namespace ana {\n \n /* Implementation of class logger.  */\n@@ -164,7 +166,7 @@ void\n logger::enter_scope (const char *scope_name)\n {\n   log (\"entering: %s\", scope_name);\n-  m_indent_level += 1;\n+  inc_indent ();\n }\n \n void\n@@ -175,7 +177,7 @@ logger::enter_scope (const char *scope_name, const char *fmt, va_list *ap)\n   log_va_partial (fmt, ap);\n   end_log_line ();\n \n-  m_indent_level += 1;\n+  inc_indent ();\n }\n \n \n@@ -186,7 +188,7 @@ void\n logger::exit_scope (const char *scope_name)\n {\n   if (m_indent_level)\n-    m_indent_level -= 1;\n+    dec_indent ();\n   else\n     log (\"(mismatching indentation)\");\n   log (\"exiting: %s\", scope_name);"}, {"sha": "0c0b8d71678c53bf365ac8282005305c7c6eda1a", "filename": "gcc/analyzer/analyzer-logging.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fanalyzer-logging.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fanalyzer-logging.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer-logging.h?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -52,6 +52,8 @@ class logger\n   void enter_scope (const char *scope_name, const char *fmt, va_list *ap)\n     ATTRIBUTE_GCC_DIAG(3, 0);\n   void exit_scope (const char *scope_name);\n+  void inc_indent () { m_indent_level++; }\n+  void dec_indent () { m_indent_level--; }\n \n   pretty_printer *get_printer () const { return m_pp; }\n   FILE *get_file () const { return m_f_out; }"}, {"sha": "aa2fd30c4816d8169bc0b7f04481814199489644", "filename": "gcc/analyzer/analyzer-selftests.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fanalyzer-selftests.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fanalyzer-selftests.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer-selftests.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -58,6 +58,7 @@ run_analyzer_selftests ()\n   analyzer_region_model_cc_tests ();\n   analyzer_sm_file_cc_tests ();\n   analyzer_sm_signal_cc_tests ();\n+  analyzer_store_cc_tests ();\n #endif /* #if ENABLE_ANALYZER */\n }\n "}, {"sha": "af40d36e92b5b32939648d8d512d84d10399b0cf", "filename": "gcc/analyzer/analyzer-selftests.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fanalyzer-selftests.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fanalyzer-selftests.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer-selftests.h?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -41,6 +41,7 @@ extern void analyzer_program_state_cc_tests ();\n extern void analyzer_region_model_cc_tests ();\n extern void analyzer_sm_file_cc_tests ();\n extern void analyzer_sm_signal_cc_tests ();\n+extern void analyzer_store_cc_tests ();\n \n } /* end of namespace ana::selftest.  */\n "}, {"sha": "814f6248992fffa04aeb9e3495f871b2e31c35d7", "filename": "gcc/analyzer/analyzer.cc", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fanalyzer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fanalyzer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -32,6 +32,36 @@ along with GCC; see the file COPYING3.  If not see\n \n #if ENABLE_ANALYZER\n \n+namespace ana {\n+\n+/* Workaround for missing location information for some stmts,\n+   which ultimately should be solved by fixing the frontends\n+   to provide the locations (TODO).  */\n+\n+location_t\n+get_stmt_location (const gimple *stmt, function *fun)\n+{\n+  if (get_pure_location (stmt->location) == UNKNOWN_LOCATION)\n+    {\n+      /* Workaround for missing location information for clobber\n+\t stmts, which seem to lack location information in the C frontend\n+\t at least.  Created by gimplify_bind_expr, which uses the\n+\t   BLOCK_SOURCE_END_LOCATION (BIND_EXPR_BLOCK (bind_expr))\n+\t but this is never set up when the block is created in\n+\t c_end_compound_stmt's pop_scope.\n+\t TODO: fix this missing location information.\n+\n+\t For now, as a hackish workaround, use the location of the end of\n+\t the function.  */\n+      if (gimple_clobber_p (stmt) && fun)\n+\treturn fun->function_end_locus;\n+    }\n+\n+  return stmt->location;\n+}\n+\n+} // namespace ana\n+\n /* Helper function for checkers.  Is the CALL to the given function name,\n    and with the given number of arguments?\n "}, {"sha": "d234fcf47e729d7ca2c029d064895fe30c54ff3f", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 186, "deletions": 6, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -35,31 +35,53 @@ class superedge;\n   class callgraph_superedge;\n     class call_superedge;\n     class return_superedge;\n+\n class svalue;\n   class region_svalue;\n   class constant_svalue;\n-  class poisoned_svalue;\n   class unknown_svalue;\n+  class poisoned_svalue;\n   class setjmp_svalue;\n+  class initial_svalue;\n+  class unaryop_svalue;\n+  class binop_svalue;\n+  class sub_svalue;\n+  class unmergeable_svalue;\n+  class placeholder_svalue;\n+  class widening_svalue;\n+  class compound_svalue;\n+  class conjured_svalue;\n+typedef hash_set<const svalue *> svalue_set;\n class region;\n-  class map_region;\n-  class array_region;\n+  class frame_region;\n+  class function_region;\n+  class label_region;\n+  class decl_region;\n   class symbolic_region;\n+  class element_region;\n+  class offset_region;\n+  class cast_region;\n+  class field_region;\n+  class string_region;\n+class region_model_manager;\n+struct model_merger;\n+class store_manager;\n+class store;\n class region_model;\n class region_model_context;\n   class impl_region_model_context;\n+class call_details;\n class constraint_manager;\n class equiv_class;\n-struct model_merger;\n-struct svalue_id_merger_mapping;\n-struct canonicalization;\n+\n class pending_diagnostic;\n class state_change_event;\n class checker_path;\n class extrinsic_state;\n class sm_state_map;\n class stmt_finder;\n class program_point;\n+class function_point;\n class program_state;\n class exploded_graph;\n class exploded_node;\n@@ -73,9 +95,95 @@ class state_purge_per_ssa_name;\n class state_change;\n class rewind_info_t;\n \n+class engine;\n+\n /* Forward decls of functions.  */\n \n+extern void dump_tree (pretty_printer *pp, tree t);\n extern void dump_quoted_tree (pretty_printer *pp, tree t);\n+extern void print_quoted_type (pretty_printer *pp, tree t);\n+extern int readability_comparator (const void *p1, const void *p2);\n+extern int tree_cmp (const void *p1, const void *p2);\n+\n+/* A tree, extended with stack frame information for locals, so that\n+   we can distinguish between different values of locals within a potentially\n+   recursive callstack.  */\n+\n+class path_var\n+{\n+public:\n+  path_var (tree t, int stack_depth)\n+  : m_tree (t), m_stack_depth (stack_depth)\n+  {\n+    // TODO: ignore stack depth for globals and constants\n+  }\n+\n+  bool operator== (const path_var &other) const\n+  {\n+    return (m_tree == other.m_tree\n+\t    && m_stack_depth == other.m_stack_depth);\n+  }\n+\n+  operator bool () const\n+  {\n+    return m_tree != NULL_TREE;\n+  }\n+\n+  void dump (pretty_printer *pp) const;\n+\n+  tree m_tree;\n+  int m_stack_depth; // or -1 for globals?\n+};\n+\n+typedef offset_int bit_offset_t;\n+typedef offset_int bit_size_t;\n+typedef offset_int byte_size_t;\n+\n+/* The location of a region expressesd as an offset relative to a\n+   base region.  */\n+\n+class region_offset\n+{\n+public:\n+  static region_offset make_concrete (const region *base_region,\n+\t\t\t\t      bit_offset_t offset)\n+  {\n+    return region_offset (base_region, offset, false);\n+  }\n+  static region_offset make_symbolic (const region *base_region)\n+  {\n+    return region_offset (base_region, 0, true);\n+  }\n+\n+  const region *get_base_region () const { return m_base_region; }\n+\n+  bool symbolic_p () const { return m_is_symbolic; }\n+\n+  bit_offset_t get_bit_offset () const\n+  {\n+    gcc_assert (!symbolic_p ());\n+    return m_offset;\n+  }\n+\n+  bool operator== (const region_offset &other)\n+  {\n+    return (m_base_region == other.m_base_region\n+\t    && m_offset == other.m_offset\n+\t    && m_is_symbolic == other.m_is_symbolic);\n+  }\n+\n+private:\n+  region_offset (const region *base_region, bit_offset_t offset,\n+\t\t bool is_symbolic)\n+  : m_base_region (base_region), m_offset (offset), m_is_symbolic (is_symbolic)\n+  {}\n+\n+  const region *m_base_region;\n+  bit_offset_t m_offset;\n+  bool m_is_symbolic;\n+};\n+\n+extern location_t get_stmt_location (const gimple *stmt, function *fun);\n \n } // namespace ana\n \n@@ -124,4 +232,76 @@ struct pod_hash_traits : typed_noop_remove<Type>\n   static inline bool is_empty (Type);\n };\n \n+/* A hash traits class that uses member functions to implement\n+   the various required ops.  */\n+\n+template <typename Type>\n+struct member_function_hash_traits : public typed_noop_remove<Type>\n+{\n+  typedef Type value_type;\n+  typedef Type compare_type;\n+  static inline hashval_t hash (value_type v) { return v.hash (); }\n+  static inline bool equal (const value_type &existing,\n+\t\t\t    const value_type &candidate)\n+  {\n+    return existing == candidate;\n+  }\n+  static inline void mark_deleted (Type &t) { t.mark_deleted (); }\n+  static inline void mark_empty (Type &t) { t.mark_empty (); }\n+  static inline bool is_deleted (Type t) { return t.is_deleted (); }\n+  static inline bool is_empty (Type t) { return t.is_empty (); }\n+};\n+\n+/* A map from T::key_t to T* for use in consolidating instances of T.\n+   Owns all instances of T.\n+   T::key_t should have operator== and be hashable.  */\n+\n+template <typename T>\n+class consolidation_map\n+{\n+public:\n+  typedef typename T::key_t key_t;\n+  typedef T instance_t;\n+  typedef hash_map<key_t, instance_t *> inner_map_t;\n+  typedef typename inner_map_t::iterator iterator;\n+\n+  /* Delete all instances of T.  */\n+\n+  ~consolidation_map ()\n+  {\n+    for (typename inner_map_t::iterator iter = m_inner_map.begin ();\n+\t iter != m_inner_map.end (); ++iter)\n+      delete (*iter).second;\n+  }\n+\n+  /* Get the instance of T for K if one exists, or NULL.  */\n+\n+  T *get (const key_t &k) const\n+  {\n+    if (instance_t **slot = const_cast<inner_map_t &> (m_inner_map).get (k))\n+      return *slot;\n+    return NULL;\n+  }\n+\n+  /* Take ownership of INSTANCE.  */\n+\n+  void put (const key_t &k, T *instance)\n+  {\n+    m_inner_map.put (k, instance);\n+  }\n+\n+  size_t elements () const { return m_inner_map.elements (); }\n+\n+  iterator begin () const { return m_inner_map.begin (); }\n+  iterator end () const { return m_inner_map.end (); }\n+\n+private:\n+  inner_map_t m_inner_map;\n+};\n+\n+/* Disable -Wformat-diag; we want to be able to use pp_printf\n+   for logging/dumping without complying with the rules for diagnostics.  */\n+\n+#pragma GCC diagnostic ignored \"-Wformat-diag\"\n+\n #endif /* GCC_ANALYZER_ANALYZER_H */"}, {"sha": "b0c797ff9a78e1ed168fb9b1a51b44c2f37c55b8", "filename": "gcc/analyzer/analyzer.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fanalyzer.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fanalyzer.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.opt?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -34,10 +34,18 @@ The maximum number of exploded nodes per program point within the analyzer, befo\n Common Joined UInteger Var(param_analyzer_max_recursion_depth) Init(2) Param\n The maximum number of times a callsite can appear in a call stack within the analyzer, before terminating analysis of a call that would recurse deeper.\n \n+-param=analyzer-max-svalue-depth=\n+Common Joined UInteger Var(param_analyzer_max_svalue_depth) Init(13) Param\n+The maximum depth of a symbolic value, before approximating the value as unknown.\n+\n -param=analyzer-min-snodes-for-call-summary=\n Common Joined UInteger Var(param_analyzer_min_snodes_for_call_summary) Init(10) Param\n The minimum number of supernodes within a function for the analyzer to consider summarizing its effects at call sites.\n \n+-param=analyzer-max-enodes-for-full-dump=\n+Common Joined UInteger Var(param_analyzer_max_enodes_for_full_dump) Init(200) Param\n+The maximum depth of exploded nodes that should appear in a dot dump before switching to a less verbose format.\n+\n Wanalyzer-double-fclose\n Common Var(warn_analyzer_double_fclose) Init(1) Warning\n Warn about code paths in which a stdio FILE can be closed more than once."}, {"sha": "d3630316c4e7a658214c16f401ae607982db78b7", "filename": "gcc/analyzer/call-string.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fcall-string.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fcall-string.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-string.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -38,6 +38,8 @@ along with GCC; see the file COPYING3.  If not see\n \n #if ENABLE_ANALYZER\n \n+#pragma GCC diagnostic ignored \"-Wformat-diag\"\n+\n /* class call_string.  */\n \n /* call_string's copy ctor.  */"}, {"sha": "5f2b83464853db365c50ec74f9ad0ab60effd009", "filename": "gcc/analyzer/checker-path.cc", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fchecker-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fchecker-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -46,6 +46,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tristate.h\"\n #include \"ordered-hash-map.h\"\n #include \"selftest.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n #include \"analyzer/program-state.h\"\n #include \"analyzer/checker-path.h\"\n@@ -56,8 +59,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/constraint-manager.h\"\n #include \"analyzer/diagnostic-manager.h\"\n #include \"analyzer/checker-path.h\"\n-#include \"analyzer/call-string.h\"\n-#include \"analyzer/program-point.h\"\n #include \"analyzer/exploded-graph.h\"\n \n #if ENABLE_ANALYZER\n@@ -214,16 +215,16 @@ state_change_event::state_change_event (const supernode *node,\n \t\t\t\t\tconst gimple *stmt,\n \t\t\t\t\tint stack_depth,\n \t\t\t\t\tconst state_machine &sm,\n-\t\t\t\t\ttree var,\n+\t\t\t\t\tconst svalue *sval,\n \t\t\t\t\tstate_machine::state_t from,\n \t\t\t\t\tstate_machine::state_t to,\n-\t\t\t\t\ttree origin,\n+\t\t\t\t\tconst svalue *origin,\n \t\t\t\t\tconst program_state &dst_state)\n : checker_event (EK_STATE_CHANGE,\n \t\t stmt->location, node->m_fun->decl,\n \t\t stack_depth),\n   m_node (node), m_stmt (stmt), m_sm (sm),\n-  m_var (var), m_from (from), m_to (to),\n+  m_sval (sval), m_from (from), m_to (to),\n   m_origin (origin),\n   m_dst_state (dst_state)\n {\n@@ -245,9 +246,12 @@ state_change_event::get_desc (bool can_colorize) const\n {\n   if (m_pending_diagnostic)\n     {\n+      region_model *model = m_dst_state.m_region_model;\n+      tree var = model->get_representative_tree (m_sval);\n+      tree origin = model->get_representative_tree (m_origin);\n       label_text custom_desc\n \t= m_pending_diagnostic->describe_state_change\n-\t    (evdesc::state_change (can_colorize, m_var, m_origin,\n+\t    (evdesc::state_change (can_colorize, var, origin,\n \t\t\t\t   m_from, m_to, m_emission_id, *this));\n       if (custom_desc.m_buffer)\n \t{\n@@ -260,16 +264,16 @@ state_change_event::get_desc (bool can_colorize) const\n \t\t  (can_colorize,\n \t\t   \"%s (state of %qE: %qs -> %qs, origin: %qE)\",\n \t\t   custom_desc.m_buffer,\n-\t\t   m_var,\n+\t\t   var,\n \t\t   m_sm.get_state_name (m_from),\n \t\t   m_sm.get_state_name (m_to),\n-\t\t   m_origin);\n+\t\t   origin);\n \t      else\n \t\tresult = make_label_text\n \t\t  (can_colorize,\n-\t\t   \"%s (state of %qE: %qs -> %qs, origin: NULL)\",\n+\t\t   \"%s (state of %qE: %qs -> %qs, NULL origin)\",\n \t\t   custom_desc.m_buffer,\n-\t\t   m_var,\n+\t\t   var,\n \t\t   m_sm.get_state_name (m_from),\n \t\t   m_sm.get_state_name (m_to));\n \t      custom_desc.maybe_free ();\n@@ -281,27 +285,31 @@ state_change_event::get_desc (bool can_colorize) const\n     }\n \n   /* Fallback description.  */\n-  if (m_var)\n+  if (m_sval)\n     {\n+      label_text sval_desc = m_sval->get_desc ();\n       if (m_origin)\n-\treturn make_label_text\n-\t  (can_colorize,\n-\t   \"state of %qE: %qs -> %qs (origin: %qE)\",\n-\t   m_var,\n-\t   m_sm.get_state_name (m_from),\n-\t   m_sm.get_state_name (m_to),\n-\t   m_origin);\n+\t{\n+\t  label_text origin_desc = m_origin->get_desc ();\n+\t  return make_label_text\n+\t    (can_colorize,\n+\t     \"state of %qs: %qs -> %qs (origin: %qs)\",\n+\t     sval_desc.m_buffer,\n+\t     m_sm.get_state_name (m_from),\n+\t     m_sm.get_state_name (m_to),\n+\t     origin_desc.m_buffer);\n+\t}\n       else\n \treturn make_label_text\n \t  (can_colorize,\n-\t   \"state of %qE: %qs -> %qs (origin: NULL)\",\n-\t   m_var,\n+\t   \"state of %qs: %qs -> %qs (NULL origin)\",\n+\t   sval_desc.m_buffer,\n \t   m_sm.get_state_name (m_from),\n \t   m_sm.get_state_name (m_to));\n     }\n   else\n     {\n-      gcc_assert (m_origin == NULL_TREE);\n+      gcc_assert (m_origin == NULL);\n       return make_label_text\n \t(can_colorize,\n \t \"global state: %qs -> %qs\",\n@@ -954,7 +962,7 @@ checker_path::add_final_event (const state_machine *sm,\n \t\t\t       tree var, state_machine::state_t state)\n {\n   checker_event *end_of_path\n-    = new warning_event (stmt->location,\n+    = new warning_event (get_stmt_location (stmt, enode->get_function ()),\n \t\t\t enode->get_function ()->decl,\n \t\t\t enode->get_stack_depth (),\n \t\t\t sm, var, state);"}, {"sha": "7b86d48e983d3c51a9ff295ac93ac75d6a602de5", "filename": "gcc/analyzer/checker-path.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fchecker-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fchecker-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.h?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -193,26 +193,26 @@ class state_change_event : public checker_event\n   state_change_event (const supernode *node, const gimple *stmt,\n \t\t      int stack_depth,\n \t\t      const state_machine &sm,\n-\t\t      tree var,\n+\t\t      const svalue *sval,\n \t\t      state_machine::state_t from,\n \t\t      state_machine::state_t to,\n-\t\t      tree origin,\n+\t\t      const svalue *origin,\n \t\t      const program_state &dst_state);\n \n   label_text get_desc (bool can_colorize) const FINAL OVERRIDE;\n \n-  region_id get_lvalue (tree expr, region_model_context *ctxt) const\n+  function *get_dest_function () const\n   {\n-    return m_dst_state.m_region_model->get_lvalue (expr, ctxt);\n+    return m_dst_state.get_current_function ();\n   }\n \n   const supernode *m_node;\n   const gimple *m_stmt;\n   const state_machine &m_sm;\n-  tree m_var;\n+  const svalue *m_sval;\n   state_machine::state_t m_from;\n   state_machine::state_t m_to;\n-  tree m_origin;\n+  const svalue *m_origin;\n   program_state m_dst_state;\n };\n "}, {"sha": "2f7a65374935dc30bf470084c9bc918954984e11", "filename": "gcc/analyzer/constraint-manager.cc", "status": "modified", "additions": 825, "deletions": 401, "changes": 1226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fconstraint-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fconstraint-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -41,6 +41,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"sbitmap.h\"\n #include \"bitmap.h\"\n #include \"tristate.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n #include \"analyzer/constraint-manager.h\"\n #include \"analyzer/analyzer-selftests.h\"\n@@ -49,38 +52,17 @@ along with GCC; see the file COPYING3.  If not see\n \n namespace ana {\n \n-/* One of the end-points of a range.  */\n-\n-struct bound\n-{\n-  bound () : m_constant (NULL_TREE), m_closed (false) {}\n-  bound (tree constant, bool closed)\n-  : m_constant (constant), m_closed (closed) {}\n-\n-  void ensure_closed (bool is_upper);\n-\n-  const char * get_relation_as_str () const;\n-\n-  tree m_constant;\n-  bool m_closed;\n-};\n-\n-/* A range of values, used for determining if a value has been\n-   constrained to just one possible constant value.  */\n-\n-struct range\n+static tristate\n+compare_constants (tree lhs_const, enum tree_code op, tree rhs_const)\n {\n-  range () : m_lower_bound (), m_upper_bound () {}\n-  range (const bound &lower, const bound &upper)\n-  : m_lower_bound (lower), m_upper_bound (upper) {}\n-\n-  void dump (pretty_printer *pp) const;\n-\n-  bool constrained_to_single_element (tree *out);\n-\n-  bound m_lower_bound;\n-  bound m_upper_bound;\n-};\n+  tree comparison\n+    = fold_binary (op, boolean_type_node, lhs_const, rhs_const);\n+  if (comparison == boolean_true_node)\n+    return tristate (tristate::TS_TRUE);\n+  if (comparison == boolean_false_node)\n+    return tristate (tristate::TS_FALSE);\n+  return tristate (tristate::TS_UNKNOWN);\n+}\n \n /* struct bound.  */\n \n@@ -120,26 +102,60 @@ bound::get_relation_as_str () const\n /* Dump this range to PP, which must support %E for tree.  */\n \n void\n-range::dump (pretty_printer *pp) const\n+range::dump_to_pp (pretty_printer *pp) const\n+{\n+  if (m_lower_bound.m_constant)\n+    {\n+      if (m_upper_bound.m_constant)\n+\tpp_printf (pp, \"%qE %s x %s %qE\",\n+\t\t   m_lower_bound.m_constant,\n+\t\t   m_lower_bound.get_relation_as_str (),\n+\t\t   m_upper_bound.get_relation_as_str (),\n+\t\t   m_upper_bound.m_constant);\n+      else\n+\tpp_printf (pp, \"%qE %s x\",\n+\t\t   m_lower_bound.m_constant,\n+\t\t   m_lower_bound.get_relation_as_str ());\n+    }\n+  else\n+    {\n+      if (m_upper_bound.m_constant)\n+\tpp_printf (pp, \"x %s %qE\",\n+\t\t   m_upper_bound.get_relation_as_str (),\n+\t\t   m_upper_bound.m_constant);\n+      else\n+\tpp_string (pp, \"x\");\n+    }\n+}\n+\n+/* Dump this range to stderr.  */\n+\n+DEBUG_FUNCTION void\n+range::dump () const\n {\n-  pp_printf (pp, \"%qE %s x %s %qE\",\n-\t     m_lower_bound.m_constant,\n-\t     m_lower_bound.get_relation_as_str (),\n-\t     m_upper_bound.get_relation_as_str (),\n-\t     m_upper_bound.m_constant);\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = stderr;\n+  dump_to_pp (&pp);\n+  pp_newline (&pp);\n+  pp_flush (&pp);\n }\n \n /* Determine if there is only one possible value for this range.\n-   If so, return true and write the constant to *OUT.\n-   Otherwise, return false.  */\n+   If so, return the constant; otherwise, return NULL_TREE.  */\n \n-bool\n-range::constrained_to_single_element (tree *out)\n+tree\n+range::constrained_to_single_element ()\n {\n+  if (m_lower_bound.m_constant == NULL_TREE\n+      || m_upper_bound.m_constant == NULL_TREE)\n+    return NULL_TREE;\n+\n   if (!INTEGRAL_TYPE_P (TREE_TYPE (m_lower_bound.m_constant)))\n-    return false;\n+    return NULL_TREE;\n   if (!INTEGRAL_TYPE_P (TREE_TYPE (m_upper_bound.m_constant)))\n-    return false;\n+    return NULL_TREE;\n \n   /* Convert any open bounds to closed bounds.  */\n   m_lower_bound.ensure_closed (false);\n@@ -150,34 +166,113 @@ range::constrained_to_single_element (tree *out)\n \t\t\t\t m_lower_bound.m_constant,\n \t\t\t\t m_upper_bound.m_constant);\n   if (comparison == boolean_true_node)\n+    return m_lower_bound.m_constant;\n+  else\n+    return NULL_TREE;\n+}\n+\n+/* Eval the condition \"X OP RHS_CONST\" for X within the range.  */\n+\n+tristate\n+range::eval_condition (enum tree_code op, tree rhs_const) const\n+{\n+  range copy (*this);\n+  if (tree single_element = copy.constrained_to_single_element ())\n+    return compare_constants (single_element, op, rhs_const);\n+\n+  switch (op)\n     {\n-      *out = m_lower_bound.m_constant;\n-      return true;\n+    case EQ_EXPR:\n+      if (below_lower_bound (rhs_const))\n+\treturn tristate (tristate::TS_FALSE);\n+      if (above_upper_bound (rhs_const))\n+\treturn tristate (tristate::TS_FALSE);\n+      break;\n+\n+    case LT_EXPR:\n+    case LE_EXPR:\n+      /* Qn: \"X </<= RHS_CONST\".  */\n+      /* If RHS_CONST > upper bound, then it's true.\n+\t If RHS_CONST < lower bound, then it's false.\n+\t Otherwise unknown.  */\n+      if (above_upper_bound (rhs_const))\n+\treturn tristate (tristate::TS_TRUE);\n+      if (below_lower_bound (rhs_const))\n+\treturn tristate (tristate::TS_FALSE);\n+      break;\n+\n+    case NE_EXPR:\n+      /* Qn: \"X != RHS_CONST\".  */\n+      /* If RHS_CONST < lower bound, then it's true.\n+\t If RHS_CONST > upper bound, then it's false.\n+\t Otherwise unknown.  */\n+      if (below_lower_bound (rhs_const))\n+\treturn tristate (tristate::TS_TRUE);\n+      if (above_upper_bound (rhs_const))\n+\treturn tristate (tristate::TS_TRUE);\n+      break;\n+\n+    case GE_EXPR:\n+    case GT_EXPR:\n+      /* Qn: \"X >=/> RHS_CONST\".  */\n+      if (above_upper_bound (rhs_const))\n+\treturn tristate (tristate::TS_FALSE);\n+      if (below_lower_bound (rhs_const))\n+\treturn tristate (tristate::TS_TRUE);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+      break;\n     }\n-  else\n+  return tristate (tristate::TS_UNKNOWN);\n+}\n+\n+/* Return true if RHS_CONST is below the lower bound of this range.  */\n+\n+bool\n+range::below_lower_bound (tree rhs_const) const\n+{\n+  if (!m_lower_bound.m_constant)\n     return false;\n+\n+  return compare_constants (rhs_const,\n+\t\t\t    m_lower_bound.m_closed ? LT_EXPR : LE_EXPR,\n+\t\t\t    m_lower_bound.m_constant).is_true ();\n+}\n+\n+/* Return true if RHS_CONST is above the upper bound of this range.  */\n+\n+bool\n+range::above_upper_bound (tree rhs_const) const\n+{\n+  if (!m_upper_bound.m_constant)\n+    return false;\n+\n+  return compare_constants (rhs_const,\n+\t\t\t    m_upper_bound.m_closed ? GT_EXPR : GE_EXPR,\n+\t\t\t    m_upper_bound.m_constant).is_true ();\n }\n \n /* class equiv_class.  */\n \n /* equiv_class's default ctor.  */\n \n equiv_class::equiv_class ()\n-: m_constant (NULL_TREE), m_cst_sid (svalue_id::null ()),\n-  m_vars ()\n+: m_constant (NULL_TREE), m_cst_sval (NULL), m_vars ()\n {\n }\n \n /* equiv_class's copy ctor.  */\n \n equiv_class::equiv_class (const equiv_class &other)\n-: m_constant (other.m_constant), m_cst_sid (other.m_cst_sid),\n+: m_constant (other.m_constant), m_cst_sval (other.m_cst_sval),\n   m_vars (other.m_vars.length ())\n {\n   int i;\n-  svalue_id *sid;\n-  FOR_EACH_VEC_ELT (other.m_vars, i, sid)\n-    m_vars.quick_push (*sid);\n+  const svalue *sval;\n+  FOR_EACH_VEC_ELT (other.m_vars, i, sval)\n+    m_vars.quick_push (sval);\n }\n \n /* Print an all-on-one-line representation of this equiv_class to PP,\n@@ -188,54 +283,59 @@ equiv_class::print (pretty_printer *pp) const\n {\n   pp_character (pp, '{');\n   int i;\n-  svalue_id *sid;\n-  FOR_EACH_VEC_ELT (m_vars, i, sid)\n+  const svalue *sval;\n+  FOR_EACH_VEC_ELT (m_vars, i, sval)\n     {\n       if (i > 0)\n \tpp_string (pp, \" == \");\n-      sid->print (pp);\n+      sval->dump_to_pp (pp, true);\n     }\n   if (m_constant)\n     {\n       if (i > 0)\n \tpp_string (pp, \" == \");\n-      pp_printf (pp, \"%qE\", m_constant);\n+      pp_printf (pp, \"[m_constant]%qE\", m_constant);\n     }\n   pp_character (pp, '}');\n }\n \n-/* Generate a hash value for this equiv_class.  */\n+/* Generate a hash value for this equiv_class.\n+   This relies on the ordering of m_vars, and so this object needs to\n+   have been canonicalized for this to be meaningful.  */\n \n hashval_t\n equiv_class::hash () const\n {\n   inchash::hash hstate;\n-  int i;\n-  svalue_id *sid;\n \n   inchash::add_expr (m_constant, hstate);\n-  FOR_EACH_VEC_ELT (m_vars, i, sid)\n-    inchash::add (*sid, hstate);\n+  int i;\n+  const svalue *sval;\n+  FOR_EACH_VEC_ELT (m_vars, i, sval)\n+    hstate.add_ptr (sval);\n   return hstate.end ();\n }\n \n-/* Equality operator for equiv_class.  */\n+/* Equality operator for equiv_class.\n+   This relies on the ordering of m_vars, and so this object\n+   and OTHER need to have been canonicalized for this to be\n+   meaningful.  */\n \n bool\n equiv_class::operator== (const equiv_class &other)\n {\n   if (m_constant != other.m_constant)\n     return false; // TODO: use tree equality here?\n \n-  /* FIXME: should we compare m_cst_sid?  */\n+  /* FIXME: should we compare m_cst_sval?  */\n \n   if (m_vars.length () != other.m_vars.length ())\n     return false;\n \n   int i;\n-  svalue_id *sid;\n-  FOR_EACH_VEC_ELT (m_vars, i, sid)\n-    if (! (*sid == other.m_vars[i]))\n+  const svalue *sval;\n+  FOR_EACH_VEC_ELT (m_vars, i, sval)\n+    if (sval != other.m_vars[i])\n       return false;\n \n   return true;\n@@ -244,90 +344,77 @@ equiv_class::operator== (const equiv_class &other)\n /* Add SID to this equiv_class, using CM to check if it's a constant.  */\n \n void\n-equiv_class::add (svalue_id sid, const constraint_manager &cm)\n+equiv_class::add (const svalue *sval)\n {\n-  gcc_assert (!sid.null_p ());\n-  if (tree cst = cm.maybe_get_constant (sid))\n+  gcc_assert (sval);\n+  if (tree cst = sval->maybe_get_constant ())\n     {\n       gcc_assert (CONSTANT_CLASS_P (cst));\n       /* FIXME: should we canonicalize which svalue is the constant\n \t when there are multiple equal constants?  */\n       m_constant = cst;\n-      m_cst_sid = sid;\n+      m_cst_sval = sval;\n     }\n-  m_vars.safe_push (sid);\n+  m_vars.safe_push (sval);\n }\n \n /* Remove SID from this equivalence class.\n    Return true if SID was the last var in the equivalence class (suggesting\n    a possible leak).  */\n \n bool\n-equiv_class::del (svalue_id sid)\n+equiv_class::del (const svalue *sval)\n {\n-  gcc_assert (!sid.null_p ());\n-  gcc_assert (sid != m_cst_sid);\n+  gcc_assert (sval);\n+  gcc_assert (sval != m_cst_sval);\n \n   int i;\n-  svalue_id *iv;\n+  const svalue *iv;\n   FOR_EACH_VEC_ELT (m_vars, i, iv)\n     {\n-      if (*iv == sid)\n+      if (iv == sval)\n \t{\n \t  m_vars[i] = m_vars[m_vars.length () - 1];\n \t  m_vars.pop ();\n \t  return m_vars.length () == 0;\n \t}\n     }\n \n-  /* SID must be in the class.  */\n+  /* SVAL must be in the class.  */\n   gcc_unreachable ();\n   return false;\n }\n \n /* Get a representative member of this class, for handling cases\n    where the IDs can change mid-traversal.  */\n \n-svalue_id\n+const svalue *\n equiv_class::get_representative () const\n {\n-  if (!m_cst_sid.null_p ())\n-    return m_cst_sid;\n-  else\n-    {\n-      gcc_assert (m_vars.length () > 0);\n-      return m_vars[0];\n-    }\n-}\n-\n-/* Remap all svalue_ids within this equiv_class using MAP.  */\n-\n-void\n-equiv_class::remap_svalue_ids (const svalue_id_map &map)\n-{\n-  int i;\n-  svalue_id *iv;\n-  FOR_EACH_VEC_ELT (m_vars, i, iv)\n-    map.update (iv);\n-  map.update (&m_cst_sid);\n+  gcc_assert (m_vars.length () > 0);\n+  return m_vars[0];\n }\n \n /* Comparator for use by equiv_class::canonicalize.  */\n \n static int\n-svalue_id_cmp_by_id (const void *p1, const void *p2)\n+svalue_cmp_by_ptr (const void *p1, const void *p2)\n {\n-  const svalue_id *sid1 = (const svalue_id *)p1;\n-  const svalue_id *sid2 = (const svalue_id *)p2;\n-  return sid1->as_int () - sid2->as_int ();\n+  const svalue *sval1 = *(const svalue * const *)p1;\n+  const svalue *sval2 = *(const svalue * const *)p2;\n+  if (sval1 < sval2)\n+    return 1;\n+  if (sval1 > sval2)\n+    return -1;\n+  return 0;\n }\n \n-/* Sort the svalues_ids within this equiv_class.  */\n+/* Sort the svalues within this equiv_class.  */\n \n void\n equiv_class::canonicalize ()\n {\n-  m_vars.qsort (svalue_id_cmp_by_id);\n+  m_vars.qsort (svalue_cmp_by_ptr);\n }\n \n /* Get a debug string for C_OP.  */\n@@ -438,6 +525,32 @@ constraint::operator== (const constraint &other) const\n   return true;\n }\n \n+/* Return true if this constraint is implied by OTHER.  */\n+\n+bool\n+constraint::implied_by (const constraint &other,\n+\t\t\t const constraint_manager &cm) const\n+{\n+  if (m_lhs == other.m_lhs)\n+    if (tree rhs_const = m_rhs.get_obj (cm).get_any_constant ())\n+      if (tree other_rhs_const = other.m_rhs.get_obj (cm).get_any_constant ())\n+\tif (m_lhs.get_obj (cm).get_any_constant () == NULL_TREE)\n+\t  if (m_op == other.m_op)\n+\t    switch (m_op)\n+\t      {\n+\t      default:\n+\t\tbreak;\n+\t      case CONSTRAINT_LE:\n+\t      case CONSTRAINT_LT:\n+\t\tif (compare_constants (rhs_const,\n+\t\t\t\t       GE_EXPR,\n+\t\t\t\t       other_rhs_const).is_true ())\n+\t\t  return true;\n+\t\tbreak;\n+\t      }\n+  return false;\n+}\n+\n /* class equiv_class_id.  */\n \n /* Get the underlying equiv_class for this ID from CM.  */\n@@ -473,7 +586,8 @@ equiv_class_id::print (pretty_printer *pp) const\n \n constraint_manager::constraint_manager (const constraint_manager &other)\n : m_equiv_classes (other.m_equiv_classes.length ()),\n-  m_constraints (other.m_constraints.length ())\n+  m_constraints (other.m_constraints.length ()),\n+  m_mgr (other.m_mgr)\n {\n   int i;\n   equiv_class *ec;\n@@ -575,34 +689,54 @@ constraint_manager::print (pretty_printer *pp) const\n   pp_printf (pp, \"}\");\n }\n \n-/* Dump a multiline representation of this constraint_manager to PP\n+/* Dump a representation of this constraint_manager to PP\n    (which must support %E for trees).  */\n \n void\n-constraint_manager::dump_to_pp (pretty_printer *pp) const\n+constraint_manager::dump_to_pp (pretty_printer *pp, bool multiline) const\n {\n-  // TODO\n-  pp_string (pp, \"  equiv classes:\");\n-  pp_newline (pp);\n+  if (multiline)\n+    pp_string (pp, \"  \");\n+  pp_string (pp, \"equiv classes:\");\n+  if (multiline)\n+    pp_newline (pp);\n+  else\n+    pp_string (pp, \" {\");\n   int i;\n   equiv_class *ec;\n   FOR_EACH_VEC_ELT (m_equiv_classes, i, ec)\n     {\n-      pp_string (pp, \"    \");\n+      if (multiline)\n+\tpp_string (pp, \"    \");\n+      else if (i > 0)\n+\tpp_string (pp, \", \");\n       equiv_class_id (i).print (pp);\n       pp_string (pp, \": \");\n       ec->print (pp);\n-      pp_newline (pp);\n+      if (multiline)\n+\tpp_newline (pp);\n     }\n-  pp_string (pp, \"  constraints:\");\n-  pp_newline (pp);\n+  if (multiline)\n+    pp_string (pp, \"  \");\n+  else\n+    pp_string (pp, \"}\");\n+  pp_string (pp, \"constraints:\");\n+  if (multiline)\n+    pp_newline (pp);\n+  else\n+    pp_string (pp, \"{\");\n   constraint *c;\n   FOR_EACH_VEC_ELT (m_constraints, i, c)\n     {\n-      pp_printf (pp, \"    %i: \", i);\n+      if (multiline)\n+\tpp_string (pp, \"    \");\n+      pp_printf (pp, \"%i: \", i);\n       c->print (pp, *this);\n-      pp_newline (pp);\n+      if (multiline)\n+\tpp_newline (pp);\n     }\n+  if (!multiline)\n+    pp_string (pp, \"}\");\n }\n \n /* Dump a multiline representation of this constraint_manager to FP.  */\n@@ -614,7 +748,7 @@ constraint_manager::dump (FILE *fp) const\n   pp_format_decoder (&pp) = default_tree_printer;\n   pp_show_color (&pp) = pp_show_color (global_dc->printer);\n   pp.buffer->stream = fp;\n-  dump_to_pp (&pp);\n+  dump_to_pp (&pp, true);\n   pp_flush (&pp);\n }\n \n@@ -639,13 +773,51 @@ debug (const constraint_manager &cm)\n    Return false if the constraint contradicts existing knowledge.  */\n \n bool\n-constraint_manager::add_constraint (svalue_id lhs,\n-\t\t\t\t    enum tree_code op,\n-\t\t\t\t    svalue_id rhs)\n+constraint_manager::add_constraint (const svalue *lhs,\n+\t\t\t\t     enum tree_code op,\n+\t\t\t\t     const svalue *rhs)\n {\n+  lhs = lhs->unwrap_any_unmergeable ();\n+  rhs = rhs->unwrap_any_unmergeable ();\n+\n+  /* Nothing can be known about unknown values.  */\n+  if (lhs->get_kind () == SK_UNKNOWN\n+      || rhs->get_kind () == SK_UNKNOWN)\n+    /* Not a contradiction.  */\n+    return true;\n+\n+  /* Check the conditions on svalues.  */\n+  {\n+    tristate t_cond = eval_condition (lhs, op, rhs);\n+\n+    /* If we already have the condition, do nothing.  */\n+    if (t_cond.is_true ())\n+      return true;\n+\n+    /* Reject a constraint that would contradict existing knowledge, as\n+       unsatisfiable.  */\n+    if (t_cond.is_false ())\n+      return false;\n+  }\n+\n   equiv_class_id lhs_ec_id = get_or_add_equiv_class (lhs);\n   equiv_class_id rhs_ec_id = get_or_add_equiv_class (rhs);\n-  return add_constraint (lhs_ec_id, op,rhs_ec_id);\n+\n+  /* Check the stronger conditions on ECs.  */\n+  {\n+    tristate t = eval_condition (lhs_ec_id, op, rhs_ec_id);\n+\n+    /* Discard constraints that are already known.  */\n+    if (t.is_true ())\n+      return true;\n+\n+    /* Reject unsatisfiable constraints.  */\n+    if (t.is_false ())\n+      return false;\n+  }\n+\n+  add_unknown_constraint (lhs_ec_id, op, rhs_ec_id);\n+  return true;\n }\n \n /* Attempt to add the constraint LHS_EC_ID OP RHS_EC_ID to this\n@@ -655,8 +827,8 @@ constraint_manager::add_constraint (svalue_id lhs,\n \n bool\n constraint_manager::add_constraint (equiv_class_id lhs_ec_id,\n-\t\t\t\t    enum tree_code op,\n-\t\t\t\t    equiv_class_id rhs_ec_id)\n+\t\t\t\t     enum tree_code op,\n+\t\t\t\t     equiv_class_id rhs_ec_id)\n {\n   tristate t = eval_condition (lhs_ec_id, op, rhs_ec_id);\n \n@@ -668,6 +840,18 @@ constraint_manager::add_constraint (equiv_class_id lhs_ec_id,\n   if (t.is_false ())\n     return false;\n \n+  add_unknown_constraint (lhs_ec_id, op, rhs_ec_id);\n+  return true;\n+}\n+\n+/* Add the constraint LHS_EC_ID OP RHS_EC_ID to this constraint_manager,\n+   where the constraint has already been checked for being \"unknown\".  */\n+\n+void\n+constraint_manager::add_unknown_constraint (equiv_class_id lhs_ec_id,\n+\t\t\t\t\t     enum tree_code op,\n+\t\t\t\t\t     equiv_class_id rhs_ec_id)\n+{\n   gcc_assert (lhs_ec_id != rhs_ec_id);\n \n   /* For now, simply accumulate constraints, without attempting any further\n@@ -681,14 +865,14 @@ constraint_manager::add_constraint (equiv_class_id lhs_ec_id,\n \tconst equiv_class &rhs_ec_obj = rhs_ec_id.get_obj (*this);\n \n \tint i;\n-\tsvalue_id *sid;\n-\tFOR_EACH_VEC_ELT (rhs_ec_obj.m_vars, i, sid)\n-\t  lhs_ec_obj.add (*sid, *this);\n+\tconst svalue *sval;\n+\tFOR_EACH_VEC_ELT (rhs_ec_obj.m_vars, i, sval)\n+\t  lhs_ec_obj.add (sval);\n \n \tif (rhs_ec_obj.m_constant)\n \t  {\n \t    lhs_ec_obj.m_constant = rhs_ec_obj.m_constant;\n-\t    lhs_ec_obj.m_cst_sid = rhs_ec_obj.m_cst_sid;\n+\t    lhs_ec_obj.m_cst_sval = rhs_ec_obj.m_cst_sval;\n \t  }\n \n \t/* Drop rhs equivalence class, overwriting it with the\n@@ -718,6 +902,12 @@ constraint_manager::add_constraint (equiv_class_id lhs_ec_id,\n \t    if (c->m_rhs == final_ec_id)\n \t      c->m_rhs = rhs_ec_id;\n \t  }\n+\n+\t/* We may now have self-comparisons due to the merger; these\n+\t   constraints should be removed.  */\n+\tunsigned read_index, write_index;\n+\tVEC_ORDERED_REMOVE_IF (m_constraints, read_index, write_index, c,\n+\t\t\t       (c->m_lhs == c->m_rhs));\n       }\n       break;\n     case GE_EXPR:\n@@ -740,19 +930,27 @@ constraint_manager::add_constraint (equiv_class_id lhs_ec_id,\n       break;\n     }\n   validate ();\n-  return true;\n }\n \n /* Subroutine of constraint_manager::add_constraint, for handling all\n    operations other than equality (for which equiv classes are merged).  */\n \n void\n constraint_manager::add_constraint_internal (equiv_class_id lhs_id,\n-\t\t\t\t\t     enum constraint_op c_op,\n-\t\t\t\t\t     equiv_class_id rhs_id)\n+\t\t\t\t\t      enum constraint_op c_op,\n+\t\t\t\t\t      equiv_class_id rhs_id)\n {\n+  constraint new_c (lhs_id, c_op, rhs_id);\n+\n+  /* Remove existing constraints that would be implied by the\n+     new constraint.  */\n+  unsigned read_index, write_index;\n+  constraint *c;\n+  VEC_ORDERED_REMOVE_IF (m_constraints, read_index, write_index, c,\n+\t\t\t (c->implied_by (new_c, *this)));\n+\n   /* Add the constraint.  */\n-  m_constraints.safe_push (constraint (lhs_id, c_op, rhs_id));\n+  m_constraints.safe_push (new_c);\n \n   if (!flag_analyzer_transitivity)\n     return;\n@@ -762,8 +960,8 @@ constraint_manager::add_constraint_internal (equiv_class_id lhs_id,\n       /* The following can potentially add EQ_EXPR facts, which could lead\n \t to ECs being merged, which would change the meaning of the EC IDs.\n \t Hence we need to do this via representatives.  */\n-      svalue_id lhs = lhs_id.get_obj (*this).get_representative ();\n-      svalue_id rhs = rhs_id.get_obj (*this).get_representative ();\n+      const svalue *lhs = lhs_id.get_obj (*this).get_representative ();\n+      const svalue *rhs = rhs_id.get_obj (*this).get_representative ();\n \n       /* We have LHS </<= RHS */\n \n@@ -833,13 +1031,13 @@ constraint_manager::add_constraint_internal (equiv_class_id lhs_id,\n \t\t      range r (bound (lhs_const, c_op == CONSTRAINT_LE),\n \t\t\t       bound (other_rhs_const,\n \t\t\t\t      other->m_op == CONSTRAINT_LE));\n-\t\t      tree constant;\n-\t\t      if (r.constrained_to_single_element (&constant))\n+\t\t      if (tree constant = r.constrained_to_single_element ())\n \t\t\t{\n-\t\t\t  svalue_id cst_sid = get_sid_for_constant (constant);\n+\t\t\t  const svalue *cst_sval\n+\t\t\t    = m_mgr->get_or_create_constant_svalue (constant);\n \t\t\t  add_constraint\n \t\t\t    (rhs_id, EQ_EXPR,\n-\t\t\t     get_or_add_equiv_class (cst_sid));\n+\t\t\t     get_or_add_equiv_class (cst_sval));\n \t\t\t  return;\n \t\t\t}\n \t\t    }\n@@ -865,13 +1063,13 @@ constraint_manager::add_constraint_internal (equiv_class_id lhs_id,\n \t\t\t\t      other->m_op == CONSTRAINT_LE),\n \t\t\t       bound (rhs_const,\n \t\t\t\t      c_op == CONSTRAINT_LE));\n-\t\t      tree constant;\n-\t\t      if (r.constrained_to_single_element (&constant))\n+\t\t      if (tree constant = r.constrained_to_single_element ())\n \t\t\t{\n-\t\t\t  svalue_id cst_sid = get_sid_for_constant (constant);\n+\t\t\t  const svalue *cst_sval\n+\t\t\t    = m_mgr->get_or_create_constant_svalue (constant);\n \t\t\t  add_constraint\n \t\t\t    (lhs_id, EQ_EXPR,\n-\t\t\t     get_or_add_equiv_class (cst_sid));\n+\t\t\t     get_or_add_equiv_class (cst_sval));\n \t\t\t  return;\n \t\t\t}\n \t\t    }\n@@ -887,43 +1085,55 @@ constraint_manager::add_constraint_internal (equiv_class_id lhs_id,\n     }\n }\n \n-/* Look for SID within the equivalence classes of this constraint_manager;\n-   if found, write the id to *OUT and return true, otherwise return false.  */\n+/* Look for SVAL within the equivalence classes of this constraint_manager;\n+   if found, return true, writing the id to *OUT if OUT is non-NULL,\n+   otherwise return false.  */\n \n bool\n-constraint_manager::get_equiv_class_by_sid (svalue_id sid, equiv_class_id *out) const\n+constraint_manager::get_equiv_class_by_svalue (const svalue *sval,\n+\t\t\t\t\t       equiv_class_id *out) const\n {\n   /* TODO: should we have a map, rather than these searches?  */\n   int i;\n   equiv_class *ec;\n   FOR_EACH_VEC_ELT (m_equiv_classes, i, ec)\n     {\n       int j;\n-      svalue_id *iv;\n+      const svalue *iv;\n       FOR_EACH_VEC_ELT (ec->m_vars, j, iv)\n-\tif (*iv == sid)\n+\tif (iv == sval)\n \t  {\n-\t    *out = equiv_class_id (i);\n+\t    if (out)\n+\t      *out = equiv_class_id (i);\n \t    return true;\n \t  }\n     }\n   return false;\n }\n \n-/* Ensure that SID has an equivalence class within this constraint_manager;\n+/* Ensure that SVAL has an equivalence class within this constraint_manager;\n    return the ID of the class.  */\n \n equiv_class_id\n-constraint_manager::get_or_add_equiv_class (svalue_id sid)\n+constraint_manager::get_or_add_equiv_class (const svalue *sval)\n {\n   equiv_class_id result (-1);\n \n-  /* Try svalue_id match.  */\n-  if (get_equiv_class_by_sid (sid, &result))\n+  gcc_assert (sval->get_kind () != SK_UNKNOWN);\n+\n+  /* Convert all NULL pointers to (void *) to avoid state explosions\n+     involving all of the various (foo *)NULL vs (bar *)NULL.  */\n+  if (POINTER_TYPE_P (sval->get_type ()))\n+    if (tree cst = sval->maybe_get_constant ())\n+      if (zerop (cst))\n+\tsval = m_mgr->get_or_create_constant_svalue (null_pointer_node);\n+\n+  /* Try svalue match.  */\n+  if (get_equiv_class_by_svalue (sval, &result))\n     return result;\n \n   /* Try equality of constants.  */\n-  if (tree cst = maybe_get_constant (sid))\n+  if (tree cst = sval->maybe_get_constant ())\n     {\n       int i;\n       equiv_class *ec;\n@@ -936,7 +1146,7 @@ constraint_manager::get_or_add_equiv_class (svalue_id sid)\n \t\t\t\t   cst, ec->m_constant);\n \t    if (eq == boolean_true_node)\n \t      {\n-\t\tec->add (sid, *this);\n+\t\tec->add (sval);\n \t\treturn equiv_class_id (i);\n \t      }\n \t  }\n@@ -945,12 +1155,12 @@ constraint_manager::get_or_add_equiv_class (svalue_id sid)\n \n   /* Not found.  */\n   equiv_class *new_ec = new equiv_class ();\n-  new_ec->add (sid, *this);\n+  new_ec->add (sval);\n   m_equiv_classes.safe_push (new_ec);\n \n   equiv_class_id new_id (m_equiv_classes.length () - 1);\n \n-  if (maybe_get_constant (sid))\n+  if (sval->maybe_get_constant ())\n     {\n       /* If we have a new EC for a constant, add constraints comparing this\n \t to other constants we may have (so that we accumulate the transitive\n@@ -975,10 +1185,10 @@ constraint_manager::get_or_add_equiv_class (svalue_id sid)\n \t\tadd_constraint_internal (new_id, CONSTRAINT_LT, other_id);\n \t      else if (lt == boolean_false_node)\n \t\tadd_constraint_internal (other_id, CONSTRAINT_LT, new_id);\n-\t      /* Refresh new_id, in case ECs were merged.  SID should always\n+\t      /* Refresh new_id, in case ECs were merged.  SVAL should always\n \t\t be present by now, so this should never lead to a\n \t\t recursion.  */\n-\t      new_id = get_or_add_equiv_class (sid);\n+\t      new_id = get_or_add_equiv_class (sval);\n \t    }\n \t}\n     }\n@@ -991,7 +1201,7 @@ constraint_manager::get_or_add_equiv_class (svalue_id sid)\n tristate\n constraint_manager::eval_condition (equiv_class_id lhs_ec,\n \t\t\t\t    enum tree_code op,\n-\t\t\t\t    equiv_class_id rhs_ec)\n+\t\t\t\t    equiv_class_id rhs_ec) const\n {\n   if (lhs_ec == rhs_ec)\n     {\n@@ -1015,12 +1225,10 @@ constraint_manager::eval_condition (equiv_class_id lhs_ec,\n   tree rhs_const = rhs_ec.get_obj (*this).get_any_constant ();\n   if (lhs_const && rhs_const)\n     {\n-      tree comparison\n-\t= fold_binary (op, boolean_type_node, lhs_const, rhs_const);\n-      if (comparison == boolean_true_node)\n-\treturn tristate (tristate::TS_TRUE);\n-      if (comparison == boolean_false_node)\n-\treturn tristate (tristate::TS_FALSE);\n+      tristate result_for_constants\n+\t= compare_constants (lhs_const, op, rhs_const);\n+      if (result_for_constants.is_known ())\n+\treturn result_for_constants;\n     }\n \n   enum tree_code swapped_op = swap_tree_comparison (op);\n@@ -1051,43 +1259,241 @@ constraint_manager::eval_condition (equiv_class_id lhs_ec,\n   return tristate (tristate::TS_UNKNOWN);\n }\n \n-/* Evaluate the condition LHS OP RHS, creating equiv_class instances for\n-   LHS and RHS if they aren't already in equiv_classes.  */\n+range\n+constraint_manager::get_ec_bounds (equiv_class_id ec_id) const\n+{\n+  range result;\n+\n+  int i;\n+  constraint *c;\n+  FOR_EACH_VEC_ELT (m_constraints, i, c)\n+    {\n+      if (c->m_lhs == ec_id)\n+\t{\n+\t  if (tree other_cst = c->m_rhs.get_obj (*this).get_any_constant ())\n+\t    switch (c->m_op)\n+\t      {\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      case CONSTRAINT_NE:\n+\t\tcontinue;\n+\n+\t      case CONSTRAINT_LT:\n+\t\t/* We have \"EC_ID < OTHER_CST\".  */\n+\t\tresult.m_upper_bound = bound (other_cst, false);\n+\t\tbreak;\n+\n+\t      case CONSTRAINT_LE:\n+\t\t/* We have \"EC_ID <= OTHER_CST\".  */\n+\t\tresult.m_upper_bound = bound (other_cst, true);\n+\t\tbreak;\n+\t      }\n+\t}\n+      if (c->m_rhs == ec_id)\n+\t{\n+\t  if (tree other_cst = c->m_lhs.get_obj (*this).get_any_constant ())\n+\t    switch (c->m_op)\n+\t      {\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      case CONSTRAINT_NE:\n+\t\tcontinue;\n+\n+\t      case CONSTRAINT_LT:\n+\t\t/* We have \"OTHER_CST < EC_ID\"\n+\t\t   i.e. \"EC_ID > OTHER_CST\".  */\n+\t\tresult.m_lower_bound = bound (other_cst, false);\n+\t\tbreak;\n+\n+\t      case CONSTRAINT_LE:\n+\t\t/* We have \"OTHER_CST <= EC_ID\"\n+\t\t   i.e. \"EC_ID >= OTHER_CST\".  */\n+\t\tresult.m_lower_bound = bound (other_cst, true);\n+\t\tbreak;\n+\t      }\n+\t}\n+    }\n+\n+  return result;\n+}\n+\n+/* Evaluate the condition LHS_EC OP RHS_CONST, avoiding the creation\n+   of equiv_class instances.  */\n \n tristate\n-constraint_manager::eval_condition (svalue_id lhs,\n+constraint_manager::eval_condition (equiv_class_id lhs_ec,\n \t\t\t\t    enum tree_code op,\n-\t\t\t\t    svalue_id rhs)\n+\t\t\t\t    tree rhs_const) const\n {\n-  return eval_condition (get_or_add_equiv_class (lhs),\n-\t\t\t op,\n-\t\t\t get_or_add_equiv_class (rhs));\n+  gcc_assert (!lhs_ec.null_p ());\n+  gcc_assert (CONSTANT_CLASS_P (rhs_const));\n+\n+  if (tree lhs_const = lhs_ec.get_obj (*this).get_any_constant ())\n+    return compare_constants (lhs_const, op, rhs_const);\n+\n+  /* Check for known inequalities of the form\n+       (LHS_EC != OTHER_CST) or (OTHER_CST != LHS_EC).\n+     If RHS_CONST == OTHER_CST, then we also know that LHS_EC != OTHER_CST.\n+     For example, we might have the constraint\n+       ptr != (void *)0\n+     so we want the condition\n+       ptr == (foo *)0\n+     to be false.  */\n+  int i;\n+  constraint *c;\n+  FOR_EACH_VEC_ELT (m_constraints, i, c)\n+    {\n+      if (c->m_op == CONSTRAINT_NE)\n+\t{\n+\t  if (c->m_lhs == lhs_ec)\n+\t    {\n+\t      if (tree other_cst = c->m_rhs.get_obj (*this).get_any_constant ())\n+\t\tif (compare_constants\n+\t\t      (rhs_const, EQ_EXPR, other_cst).is_true ())\n+\t\t  {\n+\t\t    switch (op)\n+\t\t      {\n+\t\t      case EQ_EXPR:\n+\t\t\treturn tristate (tristate::TS_FALSE);\n+\t\t      case NE_EXPR:\n+\t\t\treturn tristate (tristate::TS_TRUE);\n+\t\t      default:\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t    }\n+\t  if (c->m_rhs == lhs_ec)\n+\t    {\n+\t      if (tree other_cst = c->m_lhs.get_obj (*this).get_any_constant ())\n+\t\tif (compare_constants\n+\t\t      (rhs_const, EQ_EXPR, other_cst).is_true ())\n+\t\t  {\n+\t\t    switch (op)\n+\t\t      {\n+\t\t      case EQ_EXPR:\n+\t\t\treturn tristate (tristate::TS_FALSE);\n+\t\t      case NE_EXPR:\n+\t\t\treturn tristate (tristate::TS_TRUE);\n+\t\t      default:\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t    }\n+\t}\n+    }\n+  /* Look at existing bounds on LHS_EC.  */\n+  range lhs_bounds = get_ec_bounds (lhs_ec);\n+  return lhs_bounds.eval_condition (op, rhs_const);\n }\n \n-/* Delete any information about svalue_id instances identified by P.\n+/* Evaluate the condition LHS OP RHS, without modifying this\n+   constraint_manager (avoiding the creation of equiv_class instances).  */\n+\n+tristate\n+constraint_manager::eval_condition (const svalue *lhs,\n+\t\t\t\t    enum tree_code op,\n+\t\t\t\t    const svalue *rhs) const\n+{\n+  lhs = lhs->unwrap_any_unmergeable ();\n+  rhs = rhs->unwrap_any_unmergeable ();\n+\n+  /* Nothing can be known about unknown or poisoned values.  */\n+  if (lhs->get_kind () == SK_UNKNOWN\n+      || lhs->get_kind () == SK_POISONED\n+      || rhs->get_kind () == SK_UNKNOWN\n+      || rhs->get_kind () == SK_POISONED)\n+    return tristate (tristate::TS_UNKNOWN);\n+\n+  if (lhs == rhs\n+      && !(FLOAT_TYPE_P (lhs->get_type ())\n+\t   || FLOAT_TYPE_P (rhs->get_type ())))\n+    {\n+      switch (op)\n+\t{\n+\tcase EQ_EXPR:\n+\tcase GE_EXPR:\n+\tcase LE_EXPR:\n+\t  return tristate (tristate::TS_TRUE);\n+\n+\tcase NE_EXPR:\n+\tcase GT_EXPR:\n+\tcase LT_EXPR:\n+\t  return tristate (tristate::TS_FALSE);\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  equiv_class_id lhs_ec (-1);\n+  equiv_class_id rhs_ec (-1);\n+  get_equiv_class_by_svalue (lhs, &lhs_ec);\n+  get_equiv_class_by_svalue (rhs, &rhs_ec);\n+  if (!lhs_ec.null_p () && !rhs_ec.null_p ())\n+    {\n+      tristate result_for_ecs\n+\t= eval_condition (lhs_ec, op, rhs_ec);\n+      if (result_for_ecs.is_known ())\n+\treturn result_for_ecs;\n+    }\n+\n+  /* If at least one is not in an EC, we have no constraints\n+     comparing LHS and RHS yet.\n+     They might still be comparable if one (or both) is a constant.\n+\n+     Alternatively, we can also get here if we had ECs but they weren't\n+     comparable.  Again, constant comparisons might give an answer.  */\n+  tree lhs_const = lhs->maybe_get_constant ();\n+  tree rhs_const = rhs->maybe_get_constant ();\n+  if (lhs_const && rhs_const)\n+    {\n+      tristate result_for_constants\n+\t= compare_constants (lhs_const, op, rhs_const);\n+      if (result_for_constants.is_known ())\n+\treturn result_for_constants;\n+    }\n+\n+  if (!lhs_ec.null_p ())\n+    {\n+      if (rhs_const)\n+\treturn eval_condition (lhs_ec, op, rhs_const);\n+    }\n+  if (!rhs_ec.null_p ())\n+    {\n+      if (lhs_const)\n+\t{\n+\t  enum tree_code swapped_op = swap_tree_comparison (op);\n+\t  return eval_condition (rhs_ec, swapped_op, lhs_const);\n+\t}\n+    }\n+\n+  return tristate (tristate::TS_UNKNOWN);\n+}\n+\n+/* Delete any information about svalues identified by P.\n    Such instances are removed from equivalence classes, and any\n    redundant ECs and constraints are also removed.\n    Accumulate stats into STATS.  */\n \n+template <typename PurgeCriteria>\n void\n-constraint_manager::purge (const purge_criteria &p, purge_stats *stats)\n+constraint_manager::purge (const PurgeCriteria &p, purge_stats *stats)\n {\n-  /* Delete any svalue_ids identified by P within the various equivalence\n+  /* Delete any svalues identified by P within the various equivalence\n      classes.  */\n   for (unsigned ec_idx = 0; ec_idx < m_equiv_classes.length (); )\n     {\n       equiv_class *ec = m_equiv_classes[ec_idx];\n \n       int i;\n-      svalue_id *pv;\n+      const svalue *sval;\n       bool delete_ec = false;\n-      FOR_EACH_VEC_ELT (ec->m_vars, i, pv)\n+      FOR_EACH_VEC_ELT (ec->m_vars, i, sval)\n \t{\n-\t  if (*pv == ec->m_cst_sid)\n+\t  if (sval == ec->m_cst_sval)\n \t    continue;\n-\t  if (p.should_purge_p (*pv))\n+\t  if (p.should_purge_p (sval))\n \t    {\n-\t      if (ec->del (*pv))\n+\t      if (ec->del (sval))\n \t\tif (!ec->m_constant)\n \t\t  delete_ec = true;\n \t    }\n@@ -1190,31 +1596,61 @@ constraint_manager::purge (const purge_criteria &p, purge_stats *stats)\n   validate ();\n }\n \n-/* Remap all svalue_ids within this constraint_manager using MAP.  */\n+/* Implementation of PurgeCriteria: purge svalues that are not live\n+   with respect to LIVE_SVALUES and MODEL.  */\n+\n+class dead_svalue_purger\n+{\n+public:\n+  dead_svalue_purger (const svalue_set &live_svalues,\n+\t\t      const region_model *model)\n+  : m_live_svalues (live_svalues), m_model (model)\n+  {\n+  }\n+\n+  bool should_purge_p (const svalue *sval) const\n+  {\n+    return !sval->live_p (m_live_svalues, m_model);\n+  }\n+\n+private:\n+  const svalue_set &m_live_svalues;\n+  const region_model *m_model;\n+};\n+\n+/* Purge dead svalues from equivalence classes and update constraints\n+   accordingly.  */\n \n void\n-constraint_manager::remap_svalue_ids (const svalue_id_map &map)\n+constraint_manager::\n+on_liveness_change (const svalue_set &live_svalues,\n+\t\t    const region_model *model)\n {\n-  int i;\n-  equiv_class *ec;\n-  FOR_EACH_VEC_ELT (m_equiv_classes, i, ec)\n-    ec->remap_svalue_ids (map);\n+  dead_svalue_purger p (live_svalues, model);\n+  purge (p, NULL);\n }\n \n /* Comparator for use by constraint_manager::canonicalize.\n    Sort a pair of equiv_class instances, using the representative\n-   svalue_id as a sort key.  */\n+   svalue as a sort key.  */\n \n static int\n equiv_class_cmp (const void *p1, const void *p2)\n {\n   const equiv_class *ec1 = *(const equiv_class * const *)p1;\n   const equiv_class *ec2 = *(const equiv_class * const *)p2;\n \n-  svalue_id rep1 = ec1->get_representative ();\n-  svalue_id rep2 = ec2->get_representative ();\n+  const svalue *rep1 = ec1->get_representative ();\n+  const svalue *rep2 = ec2->get_representative ();\n+\n+  gcc_assert (rep1);\n+  gcc_assert (rep2);\n \n-  return rep1.as_int () - rep2.as_int ();\n+  if (rep1 < rep2)\n+    return 1;\n+  if (rep1 > rep2)\n+    return -1;\n+  return 0;\n }\n \n /* Comparator for use by constraint_manager::canonicalize.\n@@ -1234,48 +1670,79 @@ constraint_cmp (const void *p1, const void *p2)\n   return c1->m_op - c2->m_op;\n }\n \n-/* Reorder the equivalence classes and constraints within this\n-   constraint_manager into a canonical order, to increase the\n+/* Purge redundant equivalence classes and constraints, and reorder them\n+   within this constraint_manager into a canonical order, to increase the\n    chances of finding equality with another instance.  */\n \n void\n-constraint_manager::canonicalize (unsigned num_svalue_ids)\n+constraint_manager::canonicalize ()\n {\n-  /* First, sort svalue_ids within the ECs.  */\n+  /* First, sort svalues within the ECs.  */\n   unsigned i;\n   equiv_class *ec;\n   FOR_EACH_VEC_ELT (m_equiv_classes, i, ec)\n     ec->canonicalize ();\n \n-  /* Next, sort the ECs into a canonical order.  */\n+  /* TODO: remove constraints where both sides have a constant, and are\n+     thus implicit.  But does this break transitivity?  */\n \n-  /* We will need to remap the equiv_class_ids in the constraints,\n+  /* We will be purging and reordering ECs.\n+     We will need to remap the equiv_class_ids in the constraints,\n      so we need to store the original index of each EC.\n-     Build a lookup table, mapping from representative svalue_id\n-     to the original equiv_class_id of that svalue_id.  */\n-  auto_vec<equiv_class_id> original_ec_id (num_svalue_ids);\n-  for (i = 0; i < num_svalue_ids; i++)\n-    original_ec_id.quick_push (equiv_class_id::null ());\n+     Build a lookup table, mapping from the representative svalue\n+     to the original equiv_class_id of that svalue.  */\n+  hash_map<const svalue *, equiv_class_id> original_ec_id;\n+  const unsigned orig_num_equiv_classes = m_equiv_classes.length ();\n   FOR_EACH_VEC_ELT (m_equiv_classes, i, ec)\n     {\n-      svalue_id rep = ec->get_representative ();\n-      gcc_assert (!rep.null_p ());\n-      original_ec_id[rep.as_int ()] = i;\n+      const svalue *rep = ec->get_representative ();\n+      gcc_assert (rep);\n+      original_ec_id.put (rep, i);\n     }\n \n-  /* Sort the equivalence classes.  */\n+  /* Find ECs used by constraints.  */\n+  hash_set<const equiv_class *> used_ecs;\n+  constraint *c;\n+  FOR_EACH_VEC_ELT (m_constraints, i, c)\n+    {\n+      used_ecs.add (m_equiv_classes[c->m_lhs.as_int ()]);\n+      used_ecs.add (m_equiv_classes[c->m_rhs.as_int ()]);\n+    }\n+\n+  /* Purge unused ECs: those that aren't used by constraints and\n+     that effectively have only one svalue (either in m_constant\n+     or in m_vars).  */\n+  {\n+    /* \"unordered remove if\" from a vec.  */\n+    unsigned i = 0;\n+    while (i < m_equiv_classes.length ())\n+      {\n+\tequiv_class *ec = m_equiv_classes[i];\n+\tif (!used_ecs.contains (ec)\n+\t    && ((ec->m_vars.length () < 2 && ec->m_constant == NULL_TREE)\n+\t\t|| (ec->m_vars.length () == 0)))\n+\t  {\n+\t    m_equiv_classes.unordered_remove (i);\n+\t    delete ec;\n+\t  }\n+\telse\n+\t  i++;\n+      }\n+  }\n+\n+  /* Next, sort the surviving ECs into a canonical order.  */\n   m_equiv_classes.qsort (equiv_class_cmp);\n \n   /* Populate ec_id_map based on the old vs new EC ids.  */\n-  one_way_id_map<equiv_class_id> ec_id_map (m_equiv_classes.length ());\n+  one_way_id_map<equiv_class_id> ec_id_map (orig_num_equiv_classes);\n   FOR_EACH_VEC_ELT (m_equiv_classes, i, ec)\n     {\n-      svalue_id rep = ec->get_representative ();\n-      ec_id_map.put (original_ec_id[rep.as_int ()], i);\n+      const svalue *rep = ec->get_representative ();\n+      gcc_assert (rep);\n+      ec_id_map.put (*original_ec_id.get (rep), i);\n     }\n \n-  /* Update the EC ids within the constraints.  */\n-  constraint *c;\n+  /* Use ec_id_map to update the EC ids within the constraints.  */\n   FOR_EACH_VEC_ELT (m_constraints, i, c)\n     {\n       ec_id_map.update (&c->m_lhs);\n@@ -1286,52 +1753,32 @@ constraint_manager::canonicalize (unsigned num_svalue_ids)\n   m_constraints.qsort (constraint_cmp);\n }\n \n-/* A concrete subclass of constraint_manager for use when\n-   merging two constraint_manager into a third constraint_manager,\n-   each of which has its own region_model.\n-   Calls are delegated to the constraint_manager for the merged model,\n-   and thus affect its region_model.  */\n-\n-class cleaned_constraint_manager : public constraint_manager\n-{\n-public:\n-  cleaned_constraint_manager (constraint_manager *merged) : m_merged (merged) {}\n-\n-  constraint_manager *clone (region_model *) const FINAL OVERRIDE\n-  {\n-    gcc_unreachable ();\n-  }\n-  tree maybe_get_constant (svalue_id sid) const FINAL OVERRIDE\n-  {\n-    return m_merged->maybe_get_constant (sid);\n-  }\n-  svalue_id get_sid_for_constant (tree cst) const FINAL OVERRIDE\n-  {\n-    return m_merged->get_sid_for_constant (cst);\n-  }\n-  virtual int get_num_svalues () const FINAL OVERRIDE\n-  {\n-    return m_merged->get_num_svalues ();\n-  }\n-private:\n-  constraint_manager *m_merged;\n-};\n-\n /* Concrete subclass of fact_visitor for use by constraint_manager::merge.\n    For every fact in CM_A, see if it is also true in *CM_B.  Add such\n    facts to *OUT.  */\n \n class merger_fact_visitor : public fact_visitor\n {\n public:\n-  merger_fact_visitor (constraint_manager *cm_b,\n-\t\t       constraint_manager *out)\n-  : m_cm_b (cm_b), m_out (out)\n+  merger_fact_visitor (const constraint_manager *cm_b,\n+\t\t       constraint_manager *out,\n+\t\t       const model_merger &merger)\n+  : m_cm_b (cm_b), m_out (out), m_merger (merger)\n   {}\n \n-  void on_fact (svalue_id lhs, enum tree_code code, svalue_id rhs)\n+  void on_fact (const svalue *lhs, enum tree_code code, const svalue *rhs)\n     FINAL OVERRIDE\n   {\n+    /* Special-case for widening.  */\n+    if (lhs->get_kind () == SK_WIDENING)\n+      if (!m_cm_b->get_equiv_class_by_svalue (lhs, NULL))\n+\t{\n+\t  /* LHS isn't constrained within m_cm_b.  */\n+\t  bool sat = m_out->add_constraint (lhs, code, rhs);\n+\t  gcc_assert (sat);\n+\t  return;\n+\t}\n+\n     if (m_cm_b->eval_condition (lhs, code, rhs).is_true ())\n       {\n \tbool sat = m_out->add_constraint (lhs, code, rhs);\n@@ -1340,8 +1787,9 @@ class merger_fact_visitor : public fact_visitor\n   }\n \n private:\n-  constraint_manager *m_cm_b;\n+  const constraint_manager *m_cm_b;\n   constraint_manager *m_out;\n+  const model_merger &m_merger;\n };\n \n /* Use MERGER to merge CM_A and CM_B into *OUT.\n@@ -1356,90 +1804,12 @@ constraint_manager::merge (const constraint_manager &cm_a,\n \t\t\t   constraint_manager *out,\n \t\t\t   const model_merger &merger)\n {\n-  gcc_assert (merger.m_sid_mapping);\n-\n-  /* Map svalue_ids in each equiv class from both sources\n-     to the merged region_model, dropping ids that don't survive merger,\n-     and potentially creating svalues in *OUT for constants.  */\n-  cleaned_constraint_manager cleaned_cm_a (out);\n-  const one_way_svalue_id_map &map_a_to_m\n-    = merger.m_sid_mapping->m_map_from_a_to_m;\n-  clean_merger_input (cm_a, map_a_to_m, &cleaned_cm_a);\n-\n-  cleaned_constraint_manager cleaned_cm_b (out);\n-  const one_way_svalue_id_map &map_b_to_m\n-    = merger.m_sid_mapping->m_map_from_b_to_m;\n-  clean_merger_input (cm_b, map_b_to_m, &cleaned_cm_b);\n-\n-  /* At this point, the two cleaned CMs have ECs and constraints referring\n-     to svalues in the merged region model, but both of them have separate\n-     ECs.  */\n-\n   /* Merge the equivalence classes and constraints.\n      The easiest way to do this seems to be to enumerate all of the facts\n-     in cleaned_cm_a, see which are also true in cleaned_cm_b,\n+     in cm_a, see which are also true in cm_b,\n      and add those to *OUT.  */\n-  merger_fact_visitor v (&cleaned_cm_b, out);\n-  cleaned_cm_a.for_each_fact (&v);\n-}\n-\n-/* A subroutine of constraint_manager::merge.\n-   Use MAP_SID_TO_M to map equivalence classes and constraints from\n-   SM_IN to *OUT.  Purge any non-constant svalue_id that don't appear\n-   in the result of MAP_SID_TO_M, purging any ECs and their constraints\n-   that become empty as a result.  Potentially create svalues in\n-   the merged region_model for constants that weren't already in use there.  */\n-\n-void\n-constraint_manager::\n-clean_merger_input (const constraint_manager &cm_in,\n-\t\t    const one_way_svalue_id_map &map_sid_to_m,\n-\t\t    constraint_manager *out)\n-{\n-  one_way_id_map<equiv_class_id> map_ec_to_m\n-    (cm_in.m_equiv_classes.length ());\n-  unsigned ec_idx;\n-  equiv_class *ec;\n-  FOR_EACH_VEC_ELT (cm_in.m_equiv_classes, ec_idx, ec)\n-    {\n-      equiv_class cleaned_ec;\n-      if (tree cst = ec->get_any_constant ())\n-\t{\n-\t  cleaned_ec.m_constant = cst;\n-\t  /* Lazily create the constant in the out region_model.  */\n-\t  cleaned_ec.m_cst_sid = out->get_sid_for_constant (cst);\n-\t}\n-      unsigned var_idx;\n-      svalue_id *var_in_sid;\n-      FOR_EACH_VEC_ELT (ec->m_vars, var_idx, var_in_sid)\n-\t{\n-\t  svalue_id var_m_sid = map_sid_to_m.get_dst_for_src (*var_in_sid);\n-\t  if (!var_m_sid.null_p ())\n-\t    cleaned_ec.m_vars.safe_push (var_m_sid);\n-\t}\n-      if (cleaned_ec.get_any_constant () || !cleaned_ec.m_vars.is_empty ())\n-\t{\n-\t  map_ec_to_m.put (ec_idx, out->m_equiv_classes.length ());\n-\t  out->m_equiv_classes.safe_push (new equiv_class (cleaned_ec));\n-\t}\n-    }\n-\n-  /* Write out to *OUT any constraints for which both sides survived\n-     cleaning, using the new EC IDs.  */\n-  unsigned con_idx;\n-  constraint *c;\n-  FOR_EACH_VEC_ELT (cm_in.m_constraints, con_idx, c)\n-    {\n-      equiv_class_id new_lhs = map_ec_to_m.get_dst_for_src (c->m_lhs);\n-      if (new_lhs.null_p ())\n-\tcontinue;\n-      equiv_class_id new_rhs = map_ec_to_m.get_dst_for_src (c->m_rhs);\n-      if (new_rhs.null_p ())\n-\tcontinue;\n-      out->m_constraints.safe_push (constraint (new_lhs,\n-\t\t\t\t\t\tc->m_op,\n-\t\t\t\t\t\tnew_rhs));\n-    }\n+  merger_fact_visitor v (&cm_b, out, merger);\n+  cm_a.for_each_fact (&v);\n }\n \n /* Call VISITOR's on_fact vfunc repeatedly to express the various\n@@ -1455,12 +1825,12 @@ constraint_manager::for_each_fact (fact_visitor *visitor) const\n   equiv_class *ec;\n   FOR_EACH_VEC_ELT (m_equiv_classes, ec_idx, ec)\n     {\n-      if (!ec->m_cst_sid.null_p ())\n+      if (ec->m_cst_sval)\n \t{\n \t  unsigned i;\n-\t  svalue_id *sid;\n-\t  FOR_EACH_VEC_ELT (ec->m_vars, i, sid)\n-\t    visitor->on_fact (ec->m_cst_sid, EQ_EXPR, *sid);\n+\t  const svalue *sval;\n+\t  FOR_EACH_VEC_ELT (ec->m_vars, i, sval)\n+\t    visitor->on_fact (ec->m_cst_sval, EQ_EXPR, sval);\n \t}\n       for (unsigned i = 0; i < ec->m_vars.length (); i++)\n \tfor (unsigned j = i + 1; j < ec->m_vars.length (); j++)\n@@ -1476,17 +1846,17 @@ constraint_manager::for_each_fact (fact_visitor *visitor) const\n       const equiv_class &ec_rhs = c->m_rhs.get_obj (*this);\n       enum tree_code code = constraint_tree_code (c->m_op);\n \n-      if (!ec_lhs.m_cst_sid.null_p ())\n+      if (ec_lhs.m_cst_sval)\n \t{\n \t  for (unsigned j = 0; j < ec_rhs.m_vars.length (); j++)\n \t    {\n-\t      visitor->on_fact (ec_lhs.m_cst_sid, code, ec_rhs.m_vars[j]);\n+\t      visitor->on_fact (ec_lhs.m_cst_sval, code, ec_rhs.m_vars[j]);\n \t    }\n \t}\n       for (unsigned i = 0; i < ec_lhs.m_vars.length (); i++)\n \t{\n-\t  if (!ec_rhs.m_cst_sid.null_p ())\n-\t    visitor->on_fact (ec_lhs.m_vars[i], code, ec_rhs.m_cst_sid);\n+\t  if (ec_rhs.m_cst_sval)\n+\t    visitor->on_fact (ec_lhs.m_vars[i], code, ec_rhs.m_cst_sval);\n \t  for (unsigned j = 0; j < ec_rhs.m_vars.length (); j++)\n \t    visitor->on_fact (ec_lhs.m_vars[i], code, ec_rhs.m_vars[j]);\n \t}\n@@ -1510,17 +1880,13 @@ constraint_manager::validate () const\n       gcc_assert (ec);\n \n       int j;\n-      svalue_id *sid;\n-      FOR_EACH_VEC_ELT (ec->m_vars, j, sid)\n-\t{\n-\t  gcc_assert (!sid->null_p ());\n-\t  gcc_assert (sid->as_int () < get_num_svalues ());\n-\t}\n+      const svalue *sval;\n+      FOR_EACH_VEC_ELT (ec->m_vars, j, sval)\n+\tgcc_assert (sval);\n       if (ec->m_constant)\n \t{\n \t  gcc_assert (CONSTANT_CLASS_P (ec->m_constant));\n-\t  gcc_assert (!ec->m_cst_sid.null_p ());\n-\t  gcc_assert (ec->m_cst_sid.as_int () < get_num_svalues ());\n+\t  gcc_assert (ec->m_cst_sval);\n \t}\n #if 0\n       else\n@@ -1544,8 +1910,7 @@ namespace selftest {\n \n /* Various constraint_manager selftests.\n    These have to be written in terms of a region_model, since\n-   the latter is responsible for managing svalue and svalue_id\n-   instances.  */\n+   the latter is responsible for managing svalue instances.  */\n \n /* Verify that setting and getting simple conditions within a region_model\n    work (thus exercising the underlying constraint_manager).  */\n@@ -1562,7 +1927,8 @@ test_constraint_conditions ()\n \n   /* Self-comparisons.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ASSERT_CONDITION_TRUE (model, x, EQ_EXPR, x);\n     ASSERT_CONDITION_TRUE (model, x, LE_EXPR, x);\n     ASSERT_CONDITION_TRUE (model, x, GE_EXPR, x);\n@@ -1571,9 +1937,25 @@ test_constraint_conditions ()\n     ASSERT_CONDITION_FALSE (model, x, GT_EXPR, x);\n   }\n \n+  /* Adding self-equality shouldn't add equiv classes.  */\n+  {\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n+    ADD_SAT_CONSTRAINT (model, x, EQ_EXPR, x);\n+    ADD_SAT_CONSTRAINT (model, int_42, EQ_EXPR, int_42);\n+    /* ...even when done directly via svalues: */\n+    const svalue *sval_int_42 = model.get_rvalue (int_42, NULL);\n+    bool sat = model.get_constraints ()->add_constraint (sval_int_42,\n+\t\t\t\t\t\t\t  EQ_EXPR,\n+\t\t\t\t\t\t\t  sval_int_42);\n+    ASSERT_TRUE (sat);\n+    ASSERT_EQ (model.get_constraints ()->m_equiv_classes.length (), 0);\n+  }\n+\n   /* x == y.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, y);\n \n     ADD_SAT_CONSTRAINT (model, x, EQ_EXPR, y);\n@@ -1604,7 +1986,8 @@ test_constraint_conditions ()\n \n   /* x == y, then y == z  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, y);\n \n     ADD_SAT_CONSTRAINT (model, x, EQ_EXPR, y);\n@@ -1620,7 +2003,8 @@ test_constraint_conditions ()\n \n   /* x != y.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n \n     ADD_SAT_CONSTRAINT (model, x, NE_EXPR, y);\n \n@@ -1650,7 +2034,8 @@ test_constraint_conditions ()\n \n   /* x < y.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n \n     ADD_SAT_CONSTRAINT (model, x, LT_EXPR, y);\n \n@@ -1672,7 +2057,8 @@ test_constraint_conditions ()\n \n   /* x <= y.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n \n     ADD_SAT_CONSTRAINT (model, x, LE_EXPR, y);\n \n@@ -1694,7 +2080,8 @@ test_constraint_conditions ()\n \n   /* x > y.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n \n     ADD_SAT_CONSTRAINT (model, x, GT_EXPR, y);\n \n@@ -1716,7 +2103,8 @@ test_constraint_conditions ()\n \n   /* x >= y.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n \n     ADD_SAT_CONSTRAINT (model, x, GE_EXPR, y);\n \n@@ -1740,7 +2128,8 @@ test_constraint_conditions ()\n \n   /* Constants.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ASSERT_CONDITION_FALSE (model, int_0, EQ_EXPR, int_42);\n     ASSERT_CONDITION_TRUE (model, int_0, NE_EXPR, int_42);\n     ASSERT_CONDITION_TRUE (model, int_0, LT_EXPR, int_42);\n@@ -1751,7 +2140,8 @@ test_constraint_conditions ()\n \n   /* x == 0, y == 42.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, x, EQ_EXPR, int_0);\n     ADD_SAT_CONSTRAINT (model, y, EQ_EXPR, int_42);\n \n@@ -1767,42 +2157,48 @@ test_constraint_conditions ()\n \n   /* x == y && x != y.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, x, EQ_EXPR, y);\n     ADD_UNSAT_CONSTRAINT (model, x, NE_EXPR, y);\n   }\n \n   /* x == 0 then x == 42.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, x, EQ_EXPR, int_0);\n     ADD_UNSAT_CONSTRAINT (model, x, EQ_EXPR, int_42);\n   }\n \n   /* x == 0 then x != 0.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, x, EQ_EXPR, int_0);\n     ADD_UNSAT_CONSTRAINT (model, x, NE_EXPR, int_0);\n   }\n \n   /* x == 0 then x > 0.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, x, EQ_EXPR, int_0);\n     ADD_UNSAT_CONSTRAINT (model, x, GT_EXPR, int_0);\n   }\n \n   /* x != y && x == y.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, x, NE_EXPR, y);\n     ADD_UNSAT_CONSTRAINT (model, x, EQ_EXPR, y);\n   }\n \n   /* x <= y && x > y.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, x, LE_EXPR, y);\n     ADD_UNSAT_CONSTRAINT (model, x, GT_EXPR, y);\n   }\n@@ -1822,7 +2218,8 @@ test_transitivity ()\n \n   /* a == b, then c == d, then c == b.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ASSERT_CONDITION_UNKNOWN (model, a, EQ_EXPR, b);\n     ASSERT_CONDITION_UNKNOWN (model, b, EQ_EXPR, c);\n     ASSERT_CONDITION_UNKNOWN (model, c, EQ_EXPR, d);\n@@ -1842,7 +2239,8 @@ test_transitivity ()\n \n   /* Transitivity: \"a < b\", \"b < c\" should imply \"a < c\".  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, a, LT_EXPR, b);\n     ADD_SAT_CONSTRAINT (model, b, LT_EXPR, c);\n \n@@ -1852,7 +2250,8 @@ test_transitivity ()\n \n   /* Transitivity: \"a <= b\", \"b < c\" should imply \"a < c\".  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, a, LE_EXPR, b);\n     ADD_SAT_CONSTRAINT (model, b, LT_EXPR, c);\n \n@@ -1862,7 +2261,8 @@ test_transitivity ()\n \n   /* Transitivity: \"a <= b\", \"b <= c\" should imply \"a <= c\".  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, a, LE_EXPR, b);\n     ADD_SAT_CONSTRAINT (model, b, LE_EXPR, c);\n \n@@ -1872,7 +2272,8 @@ test_transitivity ()\n \n   /* Transitivity: \"a > b\", \"b > c\" should imply \"a > c\".  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, a, GT_EXPR, b);\n     ADD_SAT_CONSTRAINT (model, b, GT_EXPR, c);\n \n@@ -1882,7 +2283,8 @@ test_transitivity ()\n \n   /* Transitivity: \"a >= b\", \"b > c\" should imply \" a > c\".  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, a, GE_EXPR, b);\n     ADD_SAT_CONSTRAINT (model, b, GT_EXPR, c);\n \n@@ -1892,7 +2294,8 @@ test_transitivity ()\n \n   /* Transitivity: \"a >= b\", \"b >= c\" should imply \"a >= c\".  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, a, GE_EXPR, b);\n     ADD_SAT_CONSTRAINT (model, b, GE_EXPR, c);\n \n@@ -1907,7 +2310,8 @@ test_transitivity ()\n      but also that:\n        (a < d).  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, a, LT_EXPR, b);\n     ADD_SAT_CONSTRAINT (model, c, LT_EXPR, d);\n     ADD_SAT_CONSTRAINT (model, b, LT_EXPR, c);\n@@ -1919,25 +2323,32 @@ test_transitivity ()\n \n   /* Transitivity: \"a >= b\", \"b >= a\" should imply that a == b.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, a, GE_EXPR, b);\n     ADD_SAT_CONSTRAINT (model, b, GE_EXPR, a);\n \n     // TODO:\n     ASSERT_CONDITION_TRUE (model, a, EQ_EXPR, b);\n+\n+    /* The ECs for a and b should have merged, and any constraints removed.  */\n+    ASSERT_EQ (model.get_constraints ()->m_equiv_classes.length (), 1);\n+    ASSERT_EQ (model.get_constraints ()->m_constraints.length (), 0);\n   }\n \n   /* Transitivity: \"a >= b\", \"b > a\" should be impossible.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, a, GE_EXPR, b);\n     ADD_UNSAT_CONSTRAINT (model, b, GT_EXPR, a);\n   }\n \n   /* Transitivity: \"a >= b\", \"b >= c\", \"c >= a\" should imply\n      that a == b == c.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, a, GE_EXPR, b);\n     ADD_SAT_CONSTRAINT (model, b, GE_EXPR, c);\n     ADD_SAT_CONSTRAINT (model, c, GE_EXPR, a);\n@@ -1948,7 +2359,8 @@ test_transitivity ()\n   /* Transitivity: \"a > b\", \"b > c\", \"c > a\"\n      should be impossible.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, a, GT_EXPR, b);\n     ADD_SAT_CONSTRAINT (model, b, GT_EXPR, c);\n     ADD_UNSAT_CONSTRAINT (model, c, GT_EXPR, a);\n@@ -1974,14 +2386,16 @@ test_constant_comparisons ()\n \n   /* Given a >= 1024, then a <= 1023 should be impossible.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, a, GE_EXPR, int_1024);\n     ADD_UNSAT_CONSTRAINT (model, a, LE_EXPR, int_1023);\n   }\n \n   /* a > 4.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, a, GT_EXPR, int_4);\n     ASSERT_CONDITION_TRUE (model, a, GT_EXPR, int_4);\n     ASSERT_CONDITION_TRUE (model, a, NE_EXPR, int_3);\n@@ -1990,7 +2404,8 @@ test_constant_comparisons ()\n \n   /* a <= 4.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, a, LE_EXPR, int_4);\n     ASSERT_CONDITION_FALSE (model, a, GT_EXPR, int_4);\n     ASSERT_CONDITION_FALSE (model, a, GT_EXPR, int_5);\n@@ -1999,7 +2414,8 @@ test_constant_comparisons ()\n \n   /* If \"a > b\" and \"a == 3\", then \"b == 4\" ought to be unsatisfiable.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, a, GT_EXPR, b);\n     ADD_SAT_CONSTRAINT (model, a, EQ_EXPR, int_3);\n     ADD_UNSAT_CONSTRAINT (model, b, EQ_EXPR, int_4);\n@@ -2010,7 +2426,8 @@ test_constant_comparisons ()\n     /* If \"a <= 4\" && \"a > 3\", then \"a == 4\",\n        assuming a is of integral type.  */\n     {\n-      region_model model;\n+      region_model_manager mgr;\n+      region_model model (&mgr);\n       ADD_SAT_CONSTRAINT (model, a, LE_EXPR, int_4);\n       ADD_SAT_CONSTRAINT (model, a, GT_EXPR, int_3);\n       ASSERT_CONDITION_TRUE (model, a, EQ_EXPR, int_4);\n@@ -2019,30 +2436,34 @@ test_constant_comparisons ()\n     /* If \"a > 3\" && \"a <= 4\", then \"a == 4\",\n        assuming a is of integral type.  */\n     {\n-      region_model model;\n+      region_model_manager mgr;\n+      region_model model (&mgr);\n       ADD_SAT_CONSTRAINT (model, a, GT_EXPR, int_3);\n       ADD_SAT_CONSTRAINT (model, a, LE_EXPR, int_4);\n       ASSERT_CONDITION_TRUE (model, a, EQ_EXPR, int_4);\n     }\n     /* If \"a > 3\" && \"a < 5\", then \"a == 4\",\n        assuming a is of integral type.  */\n     {\n-      region_model model;\n+      region_model_manager mgr;\n+      region_model model (&mgr);\n       ADD_SAT_CONSTRAINT (model, a, GT_EXPR, int_3);\n       ADD_SAT_CONSTRAINT (model, a, LT_EXPR, int_5);\n       ASSERT_CONDITION_TRUE (model, a, EQ_EXPR, int_4);\n     }\n     /* If \"a >= 4\" && \"a < 5\", then \"a == 4\",\n        assuming a is of integral type.  */\n     {\n-      region_model model;\n+      region_model_manager mgr;\n+      region_model model (&mgr);\n       ADD_SAT_CONSTRAINT (model, a, GE_EXPR, int_4);\n       ADD_SAT_CONSTRAINT (model, a, LT_EXPR, int_5);\n       ASSERT_CONDITION_TRUE (model, a, EQ_EXPR, int_4);\n     }\n     /* If \"a >= 4\" && \"a <= 4\", then \"a == 4\".  */\n     {\n-      region_model model;\n+      region_model_manager mgr;\n+      region_model model (&mgr);\n       ADD_SAT_CONSTRAINT (model, a, GE_EXPR, int_4);\n       ADD_SAT_CONSTRAINT (model, a, LE_EXPR, int_4);\n       ASSERT_CONDITION_TRUE (model, a, EQ_EXPR, int_4);\n@@ -2056,7 +2477,8 @@ test_constant_comparisons ()\n     tree float_3 = build_real_from_int_cst (double_type_node, int_3);\n     tree float_4 = build_real_from_int_cst (double_type_node, int_4);\n \n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ADD_SAT_CONSTRAINT (model, f, GT_EXPR, float_3);\n     ADD_SAT_CONSTRAINT (model, f, LE_EXPR, float_4);\n     ASSERT_CONDITION_UNKNOWN (model, f, EQ_EXPR, float_4);\n@@ -2079,7 +2501,8 @@ test_constraint_impl ()\n \n   /* x == y.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n \n     ADD_SAT_CONSTRAINT (model, x, EQ_EXPR, y);\n \n@@ -2091,7 +2514,8 @@ test_constraint_impl ()\n \n   /* y <= z; x == y.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, y);\n     ASSERT_CONDITION_UNKNOWN (model, x, GE_EXPR, z);\n \n@@ -2112,7 +2536,8 @@ test_constraint_impl ()\n \n   /* y <= z; y == x.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n     ASSERT_CONDITION_UNKNOWN (model, x, EQ_EXPR, y);\n     ASSERT_CONDITION_UNKNOWN (model, x, GE_EXPR, z);\n \n@@ -2133,20 +2558,16 @@ test_constraint_impl ()\n \n   /* x == 0, then x != 42.  */\n   {\n-    region_model model;\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n \n     ADD_SAT_CONSTRAINT (model, x, EQ_EXPR, int_0);\n     ADD_SAT_CONSTRAINT (model, x, NE_EXPR, int_42);\n \n     /* Assert various things about the insides of model.  */\n     constraint_manager *cm = model.get_constraints ();\n-    ASSERT_EQ (cm->m_constraints.length (), 1);\n-    ASSERT_EQ (cm->m_equiv_classes.length (), 2);\n-    ASSERT_EQ (cm->m_constraints[0].m_lhs,\n-\t       cm->get_or_add_equiv_class (model.get_rvalue (int_0, NULL)));\n-    ASSERT_EQ (cm->m_constraints[0].m_rhs,\n-\t       cm->get_or_add_equiv_class (model.get_rvalue (int_42, NULL)));\n-    ASSERT_EQ (cm->m_constraints[0].m_op, CONSTRAINT_LT);\n+    ASSERT_EQ (cm->m_constraints.length (), 0);\n+    ASSERT_EQ (cm->m_equiv_classes.length (), 1);\n   }\n \n   // TODO: selftest for merging ecs \"in the middle\"\n@@ -2165,8 +2586,9 @@ test_equality ()\n   tree y = build_global_decl (\"y\", integer_type_node);\n \n   {\n-    region_model model0;\n-    region_model model1;\n+    region_model_manager mgr;\n+    region_model model0 (&mgr);\n+    region_model model1 (&mgr);\n \n     constraint_manager *cm0 = model0.get_constraints ();\n     constraint_manager *cm1 = model1.get_constraints ();\n@@ -2184,7 +2606,7 @@ test_equality ()\n     ASSERT_NE (model0.hash (), model1.hash ());\n     ASSERT_NE (model0, model1);\n \n-    region_model model2;\n+    region_model model2 (&mgr);\n     constraint_manager *cm2 = model2.get_constraints ();\n     /* Make the same change to cm2.  */\n     ADD_SAT_CONSTRAINT (model2, x, EQ_EXPR, y);\n@@ -2201,9 +2623,11 @@ test_equality ()\n static void\n test_many_constants ()\n {\n+  program_point point (program_point::origin ());\n   tree a = build_global_decl (\"a\", integer_type_node);\n \n-  region_model model;\n+  region_model_manager mgr;\n+  region_model model (&mgr);\n   auto_vec<tree> constants;\n   for (int i = 0; i < 20; i++)\n     {\n@@ -2214,10 +2638,10 @@ test_many_constants ()\n       /* Merge, and check the result.  */\n       region_model other (model);\n \n-      region_model merged;\n-      ASSERT_TRUE (model.can_merge_with_p (other, &merged));\n-      model.canonicalize (NULL);\n-      merged.canonicalize (NULL);\n+      region_model merged (&mgr);\n+      ASSERT_TRUE (model.can_merge_with_p (other, point, &merged));\n+      model.canonicalize ();\n+      merged.canonicalize ();\n       ASSERT_EQ (model, merged);\n \n       for (int j = 0; j <= i; j++)\n@@ -2239,8 +2663,8 @@ run_constraint_manager_tests (bool transitivity)\n     {\n       /* These selftests assume transitivity.  */\n       test_transitivity ();\n-      test_constant_comparisons ();\n     }\n+  test_constant_comparisons ();\n   test_constraint_impl ();\n   test_equality ();\n   test_many_constants ();"}, {"sha": "3c31a891f709107089f6b1ed627fced54f422379", "filename": "gcc/analyzer/constraint-manager.h", "status": "modified", "additions": 77, "deletions": 36, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fconstraint-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fconstraint-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.h?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -25,17 +25,47 @@ namespace ana {\n \n class constraint_manager;\n \n-/* Abstract base class for specifying how state should be purged.  */\n+/* One of the end-points of a range.  */\n \n-class purge_criteria\n+struct bound\n {\n-public:\n-  virtual ~purge_criteria () {}\n-  virtual bool should_purge_p (svalue_id sid) const = 0;\n+  bound () : m_constant (NULL_TREE), m_closed (false) {}\n+  bound (tree constant, bool closed)\n+  : m_constant (constant), m_closed (closed) {}\n+\n+  void ensure_closed (bool is_upper);\n+\n+  const char * get_relation_as_str () const;\n+\n+  tree m_constant;\n+  bool m_closed;\n+};\n+\n+/* A range of values, used for determining if a value has been\n+   constrained to just one possible constant value.  */\n+\n+struct range\n+{\n+  range () : m_lower_bound (), m_upper_bound () {}\n+  range (const bound &lower, const bound &upper)\n+  : m_lower_bound (lower), m_upper_bound (upper) {}\n+\n+  void dump_to_pp (pretty_printer *pp) const;\n+  void dump () const;\n+\n+  tree constrained_to_single_element ();\n+\n+  tristate eval_condition (enum tree_code op,\n+\t\t\t   tree rhs_const) const;\n+  bool below_lower_bound (tree rhs_const) const;\n+  bool above_upper_bound (tree rhs_const) const;\n+\n+  bound m_lower_bound;\n+  bound m_upper_bound;\n };\n \n /* An equivalence class within a constraint manager: a set of\n-   svalue_ids that are known to all be equal to each other,\n+   svalues that are known to all be equal to each other,\n    together with an optional tree constant that they are equal to.  */\n \n class equiv_class\n@@ -47,14 +77,12 @@ class equiv_class\n   hashval_t hash () const;\n   bool operator== (const equiv_class &other);\n \n-  void add (svalue_id sid, const constraint_manager &cm);\n-  bool del (svalue_id sid);\n+  void add (const svalue *sval);\n+  bool del (const svalue *sval);\n \n   tree get_any_constant () const { return m_constant; }\n \n-  svalue_id get_representative () const;\n-\n-  void remap_svalue_ids (const svalue_id_map &map);\n+  const svalue *get_representative () const;\n \n   void canonicalize ();\n \n@@ -64,10 +92,10 @@ class equiv_class\n      different zeroes, for different types); these are just for the last\n      constant added.  */\n   tree m_constant;\n-  svalue_id m_cst_sid;\n+  const svalue *m_cst_sval;\n \n   // TODO: should this be a set rather than a vec?\n-  auto_vec<svalue_id> m_vars;\n+  auto_vec<const svalue *> m_vars;\n };\n \n /* The various kinds of constraint.  */\n@@ -141,6 +169,9 @@ class constraint\n     return m_op != CONSTRAINT_NE;\n   }\n \n+  bool implied_by (const constraint &other,\n+\t\t   const constraint_manager &cm) const;\n+\n   equiv_class_id m_lhs;\n   enum constraint_op m_op;\n   equiv_class_id m_rhs;\n@@ -152,7 +183,9 @@ class fact_visitor\n {\n  public:\n   virtual ~fact_visitor () {}\n-  virtual void on_fact (svalue_id lhs, enum tree_code, svalue_id rhs) = 0;\n+  virtual void on_fact (const svalue *lhs,\n+\t\t\tenum tree_code,\n+\t\t\tconst svalue *rhs) = 0;\n };\n \n /* A collection of equivalence classes and constraints on them.\n@@ -164,15 +197,10 @@ class fact_visitor\n class constraint_manager\n {\n public:\n-  constraint_manager () {}\n+  constraint_manager (region_model_manager *mgr) : m_mgr (mgr) {}\n   constraint_manager (const constraint_manager &other);\n   virtual ~constraint_manager () {}\n \n-  virtual constraint_manager *clone (region_model *) const = 0;\n-  virtual tree maybe_get_constant (svalue_id sid) const = 0;\n-  virtual svalue_id get_sid_for_constant (tree cst) const = 0;\n-  virtual int get_num_svalues () const = 0;\n-\n   constraint_manager& operator= (const constraint_manager &other);\n \n   hashval_t hash () const;\n@@ -183,7 +211,7 @@ class constraint_manager\n   }\n \n   void print (pretty_printer *pp) const;\n-  void dump_to_pp (pretty_printer *pp) const;\n+  void dump_to_pp (pretty_printer *pp, bool multiline) const;\n   void dump (FILE *fp) const;\n   void dump () const;\n \n@@ -196,32 +224,47 @@ class constraint_manager\n     return *m_equiv_classes[idx];\n   }\n \n-  equiv_class &get_equiv_class (svalue_id sid)\n+  equiv_class &get_equiv_class (const svalue *sval)\n   {\n-    equiv_class_id ec_id = get_or_add_equiv_class (sid);\n+    equiv_class_id ec_id = get_or_add_equiv_class (sval);\n     return ec_id.get_obj (*this);\n   }\n \n-  bool add_constraint (svalue_id lhs, enum tree_code op, svalue_id rhs);\n+  bool add_constraint (const svalue *lhs,\n+\t\t       enum tree_code op,\n+\t\t       const svalue *rhs);\n \n   bool add_constraint (equiv_class_id lhs_ec_id,\n \t\t       enum tree_code op,\n \t\t       equiv_class_id rhs_ec_id);\n \n-  bool get_equiv_class_by_sid (svalue_id sid, equiv_class_id *out) const;\n-  equiv_class_id get_or_add_equiv_class (svalue_id sid);\n+  void add_unknown_constraint (equiv_class_id lhs_ec_id,\n+\t\t\t       enum tree_code op,\n+\t\t\t       equiv_class_id rhs_ec_id);\n+\n+  bool get_equiv_class_by_svalue (const svalue *sval,\n+\t\t\t\t    equiv_class_id *out) const;\n+  equiv_class_id get_or_add_equiv_class (const svalue *sval);\n   tristate eval_condition (equiv_class_id lhs,\n \t\t\t   enum tree_code op,\n-\t\t\t   equiv_class_id rhs);\n-  tristate eval_condition (svalue_id lhs,\n+\t\t\t   equiv_class_id rhs) const;\n+  tristate eval_condition (equiv_class_id lhs_ec,\n+\t\t\t   enum tree_code op,\n+\t\t\t   tree rhs_const) const;\n+  tristate eval_condition (const svalue *lhs,\n \t\t\t   enum tree_code op,\n-\t\t\t   svalue_id rhs);\n+\t\t\t   const svalue *rhs) const;\n+  range get_ec_bounds (equiv_class_id ec_id) const;\n \n-  void purge (const purge_criteria &p, purge_stats *stats);\n+  /* PurgeCriteria should have:\n+     bool should_purge_p (const svalue *sval) const.  */\n+  template <typename PurgeCriteria>\n+  void purge (const PurgeCriteria &p, purge_stats *stats);\n \n-  void remap_svalue_ids (const svalue_id_map &map);\n+  void on_liveness_change (const svalue_set &live_svalues,\n+\t\t\t   const region_model *model);\n \n-  void canonicalize (unsigned num_svalue_ids);\n+  void canonicalize ();\n \n   static void merge (const constraint_manager &cm_a,\n \t\t     const constraint_manager &cm_b,\n@@ -236,13 +279,11 @@ class constraint_manager\n   auto_vec<constraint> m_constraints;\n \n  private:\n-  static void clean_merger_input (const constraint_manager &cm_in,\n-\t\t\t\t  const one_way_svalue_id_map &map_sid_to_m,\n-\t\t\t\t  constraint_manager *out);\n-\n   void add_constraint_internal (equiv_class_id lhs_id,\n \t\t\t\tenum constraint_op c_op,\n \t\t\t\tequiv_class_id rhs_id);\n+\n+  region_model_manager *m_mgr;\n };\n \n } // namespace ana"}, {"sha": "c38395a4b0d55c2d28aae342cadbcab68714dfb2", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 253, "deletions": 198, "changes": 451, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -42,6 +42,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/sm.h\"\n #include \"analyzer/pending-diagnostic.h\"\n #include \"analyzer/diagnostic-manager.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n #include \"analyzer/constraint-manager.h\"\n #include \"cfg.h\"\n@@ -51,8 +54,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"digraph.h\"\n #include \"analyzer/supergraph.h\"\n-#include \"analyzer/call-string.h\"\n-#include \"analyzer/program-point.h\"\n #include \"analyzer/program-state.h\"\n #include \"analyzer/exploded-graph.h\"\n #include \"analyzer/checker-path.h\"\n@@ -71,13 +72,15 @@ saved_diagnostic::saved_diagnostic (const state_machine *sm,\n \t\t\t\t    const exploded_node *enode,\n \t\t\t\t    const supernode *snode, const gimple *stmt,\n \t\t\t\t    stmt_finder *stmt_finder,\n-\t\t\t\t    tree var, state_machine::state_t state,\n+\t\t\t\t    tree var,\n+\t\t\t\t    const svalue *sval,\n+\t\t\t\t    state_machine::state_t state,\n \t\t\t\t    pending_diagnostic *d)\n : m_sm (sm), m_enode (enode), m_snode (snode), m_stmt (stmt),\n  /* stmt_finder could be on-stack; we want our own copy that can\n     outlive that.  */\n   m_stmt_finder (stmt_finder ? stmt_finder->clone () : NULL),\n-  m_var (var), m_state (state),\n+  m_var (var), m_sval (sval), m_state (state),\n   m_d (d), m_trailing_eedge (NULL),\n   m_status (STATUS_NEW), m_epath_length (0), m_problem (NULL)\n {\n@@ -150,8 +153,9 @@ class path_builder\n \n /* diagnostic_manager's ctor.  */\n \n-diagnostic_manager::diagnostic_manager (logger *logger, int verbosity)\n-: log_user (logger), m_verbosity (verbosity)\n+diagnostic_manager::diagnostic_manager (logger *logger, engine *eng,\n+\t\t\t\t\tint verbosity)\n+: log_user (logger), m_eng (eng), m_verbosity (verbosity)\n {\n }\n \n@@ -162,7 +166,9 @@ diagnostic_manager::add_diagnostic (const state_machine *sm,\n \t\t\t\t    const exploded_node *enode,\n \t\t\t\t    const supernode *snode, const gimple *stmt,\n \t\t\t\t    stmt_finder *finder,\n-\t\t\t\t    tree var, state_machine::state_t state,\n+\t\t\t\t    tree var,\n+\t\t\t\t    const svalue *sval,\n+\t\t\t\t    state_machine::state_t state,\n \t\t\t\t    pending_diagnostic *d)\n {\n   LOG_FUNC (get_logger ());\n@@ -172,7 +178,8 @@ diagnostic_manager::add_diagnostic (const state_machine *sm,\n   gcc_assert (enode);\n \n   saved_diagnostic *sd\n-    = new saved_diagnostic (sm, enode, snode, stmt, finder, var, state, d);\n+    = new saved_diagnostic (sm, enode, snode, stmt, finder, var, sval,\n+\t\t\t    state, d);\n   m_saved_diagnostics.safe_push (sd);\n   if (get_logger ())\n     log (\"adding saved diagnostic %i at SN %i: %qs\",\n@@ -189,7 +196,7 @@ diagnostic_manager::add_diagnostic (const exploded_node *enode,\n \t\t\t\t    pending_diagnostic *d)\n {\n   gcc_assert (enode);\n-  add_diagnostic (NULL, enode, snode, stmt, finder, NULL_TREE, 0, d);\n+  add_diagnostic (NULL, enode, snode, stmt, finder, NULL_TREE, NULL, 0, d);\n }\n \n /* A class for identifying sets of duplicated pending_diagnostic.\n@@ -329,6 +336,8 @@ class dedupe_hash_map_traits\n class dedupe_winners\n {\n public:\n+  dedupe_winners (engine *eng) : m_engine (eng) {}\n+\n   ~dedupe_winners ()\n   {\n     /* Delete all keys and candidates.  */\n@@ -347,6 +356,7 @@ class dedupe_winners\n \n   void add (logger *logger,\n \t    const shortest_exploded_paths &sp,\n+\t    const exploded_graph *eg,\n \t    saved_diagnostic *sd)\n   {\n     /* Build a dedupe_candidate for SD.\n@@ -368,7 +378,7 @@ class dedupe_winners\n \t\t   sd->m_snode->m_index);\n \n     feasibility_problem *p = NULL;\n-    if (!dc->get_path ().feasible_p (logger, &p))\n+    if (!dc->get_path ().feasible_p (logger, &p, m_engine, eg))\n       {\n \tif (logger)\n \t  logger->log (\"rejecting %qs at EN: %i, SN: %i\"\n@@ -463,6 +473,7 @@ class dedupe_winners\n   }\n \n private:\n+  engine *m_engine;\n \n   /* This maps from each dedupe_key to a current best dedupe_candidate.  */\n \n@@ -499,12 +510,12 @@ diagnostic_manager::emit_saved_diagnostics (const exploded_graph &eg)\n      instance.  This partitions the saved diagnostics by dedupe_key,\n      generating exploded_paths for them, and retaining the best one in each\n      partition.  */\n-  dedupe_winners best_candidates;\n+  dedupe_winners best_candidates (eg.get_engine ());\n \n   int i;\n   saved_diagnostic *sd;\n   FOR_EACH_VEC_ELT (m_saved_diagnostics, i, sd)\n-    best_candidates.add (get_logger (), sp, sd);\n+    best_candidates.add (get_logger (), sp, &eg, sd);\n \n   /* For each dedupe-key, call emit_saved_diagnostic on the \"best\"\n      saved_diagnostic.  */\n@@ -539,7 +550,7 @@ diagnostic_manager::emit_saved_diagnostic (const exploded_graph &eg,\n   build_emission_path (pb, epath, &emission_path);\n \n   /* Now prune it to just cover the most pertinent events.  */\n-  prune_path (&emission_path, sd.m_sm, sd.m_var, sd.m_state);\n+  prune_path (&emission_path, sd.m_sm, sd.m_sval, sd.m_state);\n \n   /* Add a final event to the path, covering the diagnostic itself.\n      We use the final enode from the epath, which might be different from\n@@ -556,7 +567,7 @@ diagnostic_manager::emit_saved_diagnostic (const exploded_graph &eg,\n \n   emission_path.prepare_for_emission (sd.m_d);\n \n-  gcc_rich_location rich_loc (stmt->location);\n+  gcc_rich_location rich_loc (get_stmt_location (stmt, sd.m_snode->m_fun));\n   rich_loc.set_path (&emission_path);\n \n   auto_diagnostic_group d;\n@@ -571,56 +582,6 @@ diagnostic_manager::emit_saved_diagnostic (const exploded_graph &eg,\n   delete pp;\n }\n \n-/* Given a state change to DST_REP, determine a tree that gives the origin\n-   of that state at STMT, using DST_STATE's region model, so that state\n-   changes based on assignments can be tracked back to their origins.\n-\n-   For example, if we have\n-\n-     (S1) _1 = malloc (64);\n-     (S2) EXPR = _1;\n-\n-   then at stmt S2 we can get the origin of EXPR's state as being _1,\n-   and thus track the allocation back to S1.  */\n-\n-static tree\n-get_any_origin (const gimple *stmt,\n-\t\ttree dst_rep,\n-\t\tconst program_state &dst_state)\n-{\n-  if (!stmt)\n-    return NULL_TREE;\n-\n-  gcc_assert (dst_rep);\n-\n-  if (const gassign *assign = dyn_cast <const gassign *> (stmt))\n-    {\n-      tree lhs = gimple_assign_lhs (assign);\n-      /* Use region IDs to compare lhs with DST_REP, bulletproofing against\n-\t cases where they can't have lvalues by using\n-\t tentative_region_model_context.  */\n-      tentative_region_model_context ctxt;\n-      region_id lhs_rid = dst_state.m_region_model->get_lvalue (lhs, &ctxt);\n-      region_id dst_rep_rid\n-\t= dst_state.m_region_model->get_lvalue (dst_rep, &ctxt);\n-      if (lhs_rid == dst_rep_rid && !ctxt.had_errors_p ())\n-\t{\n-\t  tree rhs1 = gimple_assign_rhs1 (assign);\n-\t  enum tree_code op = gimple_assign_rhs_code (assign);\n-\t  switch (op)\n-\t    {\n-\t    default:\n-\t      //gcc_unreachable ();  // TODO\n-\t      break;\n-\t    case COMPONENT_REF:\n-\t    case SSA_NAME:\n-\t      return rhs1;\n-\t    }\n-\t}\n-    }\n-  return NULL_TREE;\n-}\n-\n /* Emit a \"path\" of events to EMISSION_PATH describing the exploded path\n    EPATH within EG.  */\n \n@@ -668,19 +629,19 @@ class state_change_event_creator : public state_change_visitor\n \t\t\t\t\t\t\tstmt,\n \t\t\t\t\t\t\tstack_depth,\n \t\t\t\t\t\t\tsm,\n-\t\t\t\t\t\t\tNULL_TREE,\n+\t\t\t\t\t\t\tNULL,\n \t\t\t\t\t\t\tsrc_sm_val,\n \t\t\t\t\t\t\tdst_sm_val,\n-\t\t\t\t\t\t\tNULL_TREE,\n+\t\t\t\t\t\t\tNULL,\n \t\t\t\t\t\t\tdst_state));\n     return false;\n   }\n \n   bool on_state_change (const state_machine &sm,\n \t\t\tstate_machine::state_t src_sm_val,\n \t\t\tstate_machine::state_t dst_sm_val,\n-\t\t\ttree dst_rep,\n-\t\t\tsvalue_id dst_origin_sid) FINAL OVERRIDE\n+\t\t\tconst svalue *sval,\n+\t\t\tconst svalue *dst_origin_sval) FINAL OVERRIDE\n   {\n     const exploded_node *src_node = m_eedge.m_src;\n     const program_point &src_point = src_node->get_point ();\n@@ -705,19 +666,14 @@ class state_change_event_creator : public state_change_visitor\n     if (!stmt)\n       return false;\n \n-    tree origin_rep\n-      = dst_state.get_representative_tree (dst_origin_sid);\n-\n-    if (origin_rep == NULL_TREE)\n-      origin_rep = get_any_origin (stmt, dst_rep, dst_state);\n     m_emission_path->add_event (new state_change_event (supernode,\n \t\t\t\t\t\t\tstmt,\n \t\t\t\t\t\t\tstack_depth,\n \t\t\t\t\t\t\tsm,\n-\t\t\t\t\t\t\tdst_rep,\n+\t\t\t\t\t\t\tsval,\n \t\t\t\t\t\t\tsrc_sm_val,\n \t\t\t\t\t\t\tdst_sm_val,\n-\t\t\t\t\t\t\torigin_rep,\n+\t\t\t\t\t\t\tdst_origin_sval,\n \t\t\t\t\t\t\tdst_state));\n     return false;\n   }\n@@ -771,44 +727,119 @@ for_each_state_change (const program_state &src_state,\n \t   iter != dst_smap.end ();\n \t   ++iter)\n \t{\n-\t  /* Ideally we'd directly compare the SM state between src state\n-\t     and dst state, but there's no guarantee that the IDs can\n-\t     be meaningfully compared.  */\n-\t  svalue_id dst_sid = (*iter).first;\n+\t  const svalue *sval = (*iter).first;\n \t  state_machine::state_t dst_sm_val = (*iter).second.m_state;\n-\n-\t  auto_vec<path_var> dst_pvs;\n-\t  dst_state.m_region_model->get_path_vars_for_svalue (dst_sid,\n-\t\t\t\t\t\t\t      &dst_pvs);\n-\n-\t  unsigned j;\n-\t  path_var *dst_pv;\n-\t  FOR_EACH_VEC_ELT (dst_pvs, j, dst_pv)\n+\t  state_machine::state_t src_sm_val\n+\t    = src_smap.get_state (sval, ext_state);\n+\t  if (dst_sm_val != src_sm_val)\n \t    {\n-\t      tree dst_rep = dst_pv->m_tree;\n-\t      gcc_assert (dst_rep);\n-\t      if (dst_pv->m_stack_depth\n-\t\t  >= src_state.m_region_model->get_stack_depth ())\n-\t\tcontinue;\n-\t      tentative_region_model_context ctxt;\n-\t      svalue_id src_sid\n-\t\t= src_state.m_region_model->get_rvalue (*dst_pv, &ctxt);\n-\t      if (src_sid.null_p () || ctxt.had_errors_p ())\n-\t\tcontinue;\n-\t      state_machine::state_t src_sm_val = src_smap.get_state (src_sid);\n-\t      if (dst_sm_val != src_sm_val)\n-\t\t{\n-\t\t  svalue_id dst_origin_sid = (*iter).second.m_origin;\n-\t\t  if (visitor->on_state_change (sm, src_sm_val, dst_sm_val,\n-\t\t\t\t\t\tdst_rep, dst_origin_sid))\n-\t\t    return true;\n-\t\t}\n+\t      const svalue *origin_sval = (*iter).second.m_origin;\n+\t      if (visitor->on_state_change (sm, src_sm_val, dst_sm_val,\n+\t\t\t\t\t    sval, origin_sval))\n+\t\treturn true;\n \t    }\n \t}\n     }\n   return false;\n }\n \n+/* An sm_context for adding state_change_event on assignments to NULL,\n+   where the default state isn't m_start.  Storing such state in the\n+   sm_state_map would lead to bloat of the exploded_graph, so we want\n+   to leave it as a default state, and inject state change events here\n+   when we have a diagnostic.\n+   Find transitions of constants, for handling on_zero_assignment.  */\n+\n+struct null_assignment_sm_context : public sm_context\n+{\n+  null_assignment_sm_context (int sm_idx,\n+\t\t\t      const state_machine &sm,\n+\t\t\t      const program_state *new_state,\n+\t\t\t      const gimple *stmt,\n+\t\t\t      const program_point *point,\n+\t\t\t      checker_path *emission_path)\n+  : sm_context (sm_idx, sm), m_new_state (new_state),\n+    m_stmt (stmt), m_point (point), m_emission_path (emission_path)\n+  {\n+  }\n+\n+  tree get_fndecl_for_call (const gcall */*call*/) FINAL OVERRIDE\n+  {\n+    return NULL_TREE;\n+  }\n+\n+  void on_transition (const supernode *node ATTRIBUTE_UNUSED,\n+\t\t      const gimple *stmt ATTRIBUTE_UNUSED,\n+\t\t      tree var,\n+\t\t      state_machine::state_t from,\n+\t\t      state_machine::state_t to,\n+\t\t      tree origin ATTRIBUTE_UNUSED) FINAL OVERRIDE\n+  {\n+    if (from != 0)\n+      return;\n+\n+    const svalue *var_new_sval\n+      = m_new_state->m_region_model->get_rvalue (var, NULL);\n+    const supernode *supernode = m_point->get_supernode ();\n+    int stack_depth = m_point->get_stack_depth ();\n+\n+    m_emission_path->add_event (new state_change_event (supernode,\n+\t\t\t\t\t\t\tm_stmt,\n+\t\t\t\t\t\t\tstack_depth,\n+\t\t\t\t\t\t\tm_sm,\n+\t\t\t\t\t\t\tvar_new_sval,\n+\t\t\t\t\t\t\tfrom, to,\n+\t\t\t\t\t\t\tNULL,\n+\t\t\t\t\t\t\t*m_new_state));\n+\n+  }\n+\n+  void warn_for_state (const supernode *, const gimple *,\n+\t\t       tree, state_machine::state_t,\n+\t\t       pending_diagnostic *d) FINAL OVERRIDE\n+  {\n+    delete d;\n+  }\n+\n+  tree get_diagnostic_tree (tree expr) FINAL OVERRIDE\n+  {\n+    return expr;\n+  }\n+\n+  state_machine::state_t get_global_state () const FINAL OVERRIDE\n+  {\n+    return 0;\n+  }\n+\n+  void set_global_state (state_machine::state_t) FINAL OVERRIDE\n+  {\n+    /* No-op.  */\n+  }\n+\n+  void on_custom_transition (custom_transition *) FINAL OVERRIDE\n+  {\n+  }\n+\n+  tree is_zero_assignment (const gimple *stmt) FINAL OVERRIDE\n+  {\n+    const gassign *assign_stmt = dyn_cast <const gassign *> (stmt);\n+    if (!assign_stmt)\n+     return NULL_TREE;\n+    if (const svalue *sval\n+\t= m_new_state->m_region_model->get_gassign_result (assign_stmt, NULL))\n+      if (tree cst = sval->maybe_get_constant ())\n+\tif (::zerop(cst))\n+\t  return gimple_assign_lhs (assign_stmt);\n+    return NULL_TREE;\n+  }\n+\n+  const program_state *m_new_state;\n+  const gimple *m_stmt;\n+  const program_point *m_point;\n+  state_change_visitor *m_visitor;\n+  checker_path *m_emission_path;\n+};\n+\n /* Subroutine of diagnostic_manager::build_emission_path.\n    Add any events for EEDGE to EMISSION_PATH.  */\n \n@@ -898,6 +929,41 @@ diagnostic_manager::add_events_for_eedge (const path_builder &pb,\n \t    (new statement_event (stmt,\n \t\t\t\t  dst_point.get_fndecl (),\n \t\t\t\t  dst_stack_depth, dst_state));\n+\n+\t/* Create state change events for assignment to NULL.\n+\t   Iterate through the stmts in dst_enode, adding state change\n+\t   events for them.  */\n+\tif (dst_state.m_region_model)\n+\t  {\n+\t    program_state iter_state (dst_state);\n+\t    program_point iter_point (dst_point);\n+\t    while (1)\n+\t      {\n+\t\tconst gimple *stmt = iter_point.get_stmt ();\n+\t\tif (const gassign *assign = dyn_cast<const gassign *> (stmt))\n+\t\t  {\n+\t\t    const extrinsic_state &ext_state = pb.get_ext_state ();\n+\t\t    iter_state.m_region_model->on_assignment (assign, NULL);\n+\t\t    for (unsigned i = 0; i < ext_state.get_num_checkers (); i++)\n+\t\t      {\n+\t\t\tconst state_machine &sm = ext_state.get_sm (i);\n+\t\t\tnull_assignment_sm_context sm_ctxt (i, sm,\n+\t\t\t\t\t\t\t    &iter_state,\n+\t\t\t\t\t\t\t    stmt,\n+\t\t\t\t\t\t\t    &iter_point,\n+\t\t\t\t\t\t\t    emission_path);\n+\t\t\tsm.on_stmt (&sm_ctxt, dst_point.get_supernode (), stmt);\n+\t\t\t// TODO: what about phi nodes?\n+\t\t      }\n+\t\t  }\n+\t\titer_point.next_stmt ();\n+\t\tif (iter_point.get_kind () == PK_AFTER_SUPERNODE\n+\t\t    || (dst_node->m_succs.length () > 1\n+\t\t\t&& (iter_point\n+\t\t\t    == dst_node->m_succs[0]->m_dest->get_point ())))\n+\t\t  break;\n+\t      }\n+\t  }\n       }\n       break;\n     }\n@@ -1076,12 +1142,12 @@ diagnostic_manager::add_events_for_superedge (const path_builder &pb,\n void\n diagnostic_manager::prune_path (checker_path *path,\n \t\t\t\tconst state_machine *sm,\n-\t\t\t\ttree var,\n+\t\t\t\tconst svalue *sval,\n \t\t\t\tstate_machine::state_t state) const\n {\n   LOG_FUNC (get_logger ());\n   path->maybe_log (get_logger (), \"path\");\n-  prune_for_sm_diagnostic (path, sm, var, state);\n+  prune_for_sm_diagnostic (path, sm, sval, state);\n   prune_interproc_events (path);\n   finish_pruning (path);\n   path->maybe_log (get_logger (), \"pruned\");\n@@ -1125,11 +1191,9 @@ can_be_expr_of_interest_p (tree expr)\n void\n diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \t\t\t\t\t     const state_machine *sm,\n-\t\t\t\t\t     tree var,\n+\t\t\t\t\t     const svalue *sval,\n \t\t\t\t\t     state_machine::state_t state) const\n {\n-  update_for_unsuitable_sm_exprs (&var);\n-\n   int idx = path->num_events () - 1;\n   while (idx >= 0 && idx < (signed)path->num_events ())\n     {\n@@ -1138,17 +1202,22 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \t{\n \t  if (sm)\n \t    {\n-\t      if (var)\n-\t\tlog (\"considering event %i, with var: %qE, state: %qs\",\n-\t\t     idx, var, sm->get_state_name (state));\n+\t      if (sval)\n+\t\t{\n+\t\t  label_text sval_desc = sval->get_desc ();\n+\t\t  log (\"considering event %i (%s), with sval: %qs, state: %qs\",\n+\t\t       idx, event_kind_to_string (base_event->m_kind),\n+\t\t       sval_desc.m_buffer, sm->get_state_name (state));\n+\t\t}\n \t      else\n-\t\tlog (\"considering event %i, with global state: %qs\",\n-\t\t     idx, sm->get_state_name (state));\n+\t\tlog (\"considering event %i (%s), with global state: %qs\",\n+\t\t     idx, event_kind_to_string (base_event->m_kind),\n+\t\t     sm->get_state_name (state));\n \t    }\n \t  else\n \t    log (\"considering event %i\", idx);\n \t}\n-      gcc_assert (var == NULL || can_be_expr_of_interest_p (var));\n+\n       switch (base_event->m_kind)\n \t{\n \tdefault:\n@@ -1168,19 +1237,6 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \n \tcase EK_STMT:\n \t  {\n-\t    /* If this stmt is the origin of \"var\", update var.  */\n-\t    if (var)\n-\t      {\n-\t\tstatement_event *stmt_event = (statement_event *)base_event;\n-\t\ttree new_var = get_any_origin (stmt_event->m_stmt, var,\n-\t\t\t\t\t       stmt_event->m_dst_state);\n-\t\tif (new_var)\n-\t\t  {\n-\t\t    log (\"event %i: switching var of interest from %qE to %qE\",\n-\t\t\t idx, var, new_var);\n-\t\t    var = new_var;\n-\t\t  }\n-\t      }\n \t    if (m_verbosity < 4)\n \t      {\n \t\tlog (\"filtering event %i: statement event\", idx);\n@@ -1200,21 +1256,23 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \tcase EK_STATE_CHANGE:\n \t  {\n \t    state_change_event *state_change = (state_change_event *)base_event;\n-\t    /* Use region IDs to compare var with the state_change's m_var,\n-\t       bulletproofing against cases where they can't have lvalues by\n-\t       using tentative_region_model_context.  */\n-\t    tentative_region_model_context ctxt;\n-\t    region_id state_var_rid\n-\t      = state_change->get_lvalue (state_change->m_var, &ctxt);\n-\t    region_id var_rid = state_change->get_lvalue (var, &ctxt);\n-\t    if (state_var_rid == var_rid && !ctxt.had_errors_p ())\n+\t    gcc_assert (state_change->m_dst_state.m_region_model);\n+\n+\t    if (state_change->m_sval == sval)\n \t      {\n \t\tif (state_change->m_origin)\n \t\t  {\n-\t\t    log (\"event %i: switching var of interest from %qE to %qE\",\n-\t\t\t idx, var, state_change->m_origin);\n-\t\t    var = state_change->m_origin;\n-\t\t    update_for_unsuitable_sm_exprs (&var);\n+\t\t    if (get_logger ())\n+\t\t      {\n+\t\t\tlabel_text sval_desc = sval->get_desc ();\n+\t\t\tlabel_text origin_sval_desc\n+\t\t\t  = state_change->m_origin->get_desc ();\n+\t\t\tlog (\"event %i:\"\n+\t\t\t     \" switching var of interest from %qs to %qs\",\n+\t\t\t     idx, sval_desc.m_buffer,\n+\t\t\t     origin_sval_desc.m_buffer);\n+\t\t      }\n+\t\t    sval = state_change->m_origin;\n \t\t  }\n \t\tlog (\"event %i: switching state of interest from %qs to %qs\",\n \t\t     idx, sm->get_state_name (state_change->m_to),\n@@ -1223,15 +1281,27 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \t      }\n \t    else if (m_verbosity < 4)\n \t      {\n-\t\tif (var)\n-\t\t  log (\"filtering event %i:\"\n-\t\t       \" state change to %qE unrelated to %qE\",\n-\t\t       idx, state_change->m_var, var);\n-\t\telse\n-\t\t  log (\"filtering event %i: state change to %qE\",\n-\t\t       idx, state_change->m_var);\n-\t\tif (ctxt.had_errors_p ())\n-\t\t  log (\"context had errors\");\n+\t\tif (get_logger ())\n+\t\t  {\n+\t\t    if (state_change->m_sval)\n+\t\t      {\n+\t\t\tlabel_text change_sval_desc\n+\t\t\t  = state_change->m_sval->get_desc ();\n+\t\t\tif (sval)\n+\t\t\t  {\n+\t\t\t    label_text sval_desc = sval->get_desc ();\n+\t\t\t    log (\"filtering event %i:\"\n+\t\t\t\t \" state change to %qs unrelated to %qs\",\n+\t\t\t\t idx, change_sval_desc.m_buffer,\n+\t\t\t\t sval_desc.m_buffer);\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  log (\"filtering event %i: state change to %qs\",\n+\t\t\t       idx, change_sval_desc.m_buffer);\n+\t\t      }\n+\t\t    else\n+\t\t      log (\"filtering event %i: global state change\", idx);\n+\t\t  }\n \t\tpath->delete_event (idx);\n \t      }\n \t  }\n@@ -1240,34 +1310,6 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \tcase EK_START_CFG_EDGE:\n \t  {\n \t    cfg_edge_event *event = (cfg_edge_event *)base_event;\n-\t    const cfg_superedge& cfg_superedge\n-\t      = event->get_cfg_superedge ();\n-\t    const supernode *dest = event->m_sedge->m_dest;\n-\t    /* Do we have an SSA_NAME defined via a phi node in\n-\t       the dest CFG node?  */\n-\t    if (var && TREE_CODE (var) == SSA_NAME)\n-\t      if (SSA_NAME_DEF_STMT (var)->bb == dest->m_bb)\n-\t\t{\n-\t\t  if (gphi *phi\n-\t\t      = dyn_cast <gphi *> (SSA_NAME_DEF_STMT (var)))\n-\t\t    {\n-\t\t      /* Update var based on its phi node.  */\n-\t\t      tree old_var = var;\n-\t\t      var = cfg_superedge.get_phi_arg (phi);\n-\t\t      log (\"updating from %qE to %qE based on phi node\",\n-\t\t\t   old_var, var);\n-\t\t      if (get_logger ())\n-\t\t\t{\n-\t\t\t  pretty_printer pp;\n-\t\t\t  pp_gimple_stmt_1 (&pp, phi, 0, (dump_flags_t)0);\n-\t\t\t  log (\"  phi: %s\", pp_formatted_text (&pp));\n-\t\t\t}\n-\t\t      /* If we've chosen a bad exploded_path, then the\n-\t\t\t phi arg might be a constant.  Fail gracefully for\n-\t\t\t this case.  */\n-\t\t      update_for_unsuitable_sm_exprs (&var);\n-\t\t    }\n-\t\t}\n \n \t    /* TODO: is this edge significant to var?\n \t       See if var can be in other states in the dest, but not\n@@ -1276,7 +1318,7 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \n \t    if (event->should_filter_p (m_verbosity))\n \t      {\n-\t\tlog (\"filtering event %i: CFG edge\", idx);\n+\t\tlog (\"filtering events %i and %i: CFG edge\", idx, idx + 1);\n \t\tpath->delete_event (idx);\n \t\t/* Also delete the corresponding EK_END_CFG_EDGE.  */\n \t\tgcc_assert (path->get_checker_event (idx)->m_kind\n@@ -1296,45 +1338,58 @@ diagnostic_manager::prune_for_sm_diagnostic (checker_path *path,\n \t    call_event *event = (call_event *)base_event;\n \t    const callgraph_superedge& cg_superedge\n \t      = event->get_callgraph_superedge ();\n+\t    const region_model *callee_model\n+\t      = event->m_eedge.m_dest->get_state ().m_region_model;\n+\t    tree callee_var = callee_model->get_representative_tree (sval);\n+\t    /* We could just use caller_model->get_representative_tree (sval);\n+\t       to get the caller_var, but for now use\n+\t       map_expr_from_callee_to_caller so as to only record critical\n+\t       state for parms and the like.  */\n \t    callsite_expr expr;\n \t    tree caller_var\n-\t      = cg_superedge.map_expr_from_callee_to_caller (var, &expr);\n+\t      = cg_superedge.map_expr_from_callee_to_caller (callee_var, &expr);\n \t    if (caller_var)\n \t      {\n-\t\tlog (\"event %i:\"\n-\t\t     \" switching var of interest\"\n-\t\t     \" from %qE in callee to %qE in caller\",\n-\t\t     idx, var, caller_var);\n-\t\tvar = caller_var;\n+\t\tif (get_logger ())\n+\t\t  {\n+\t\t    label_text sval_desc = sval->get_desc ();\n+\t\t    log (\"event %i:\"\n+\t\t\t \" recording critical state for %qs at call\"\n+\t\t\t \" from %qE in callee to %qE in caller\",\n+\t\t\t idx, sval_desc.m_buffer, callee_var, caller_var);\n+\t\t  }\n \t\tif (expr.param_p ())\n-\t\t  event->record_critical_state (var, state);\n-\t\tupdate_for_unsuitable_sm_exprs (&var);\n+\t\t  event->record_critical_state (caller_var, state);\n \t      }\n \t  }\n \t  break;\n \n \tcase EK_RETURN_EDGE:\n-\t  // TODO: potentially update var/state based on return value,\n-\t  // args etc\n \t  {\n-\t    if (var)\n+\t    if (sval)\n \t      {\n \t\treturn_event *event = (return_event *)base_event;\n \t\tconst callgraph_superedge& cg_superedge\n \t\t  = event->get_callgraph_superedge ();\n+\t\tconst region_model *caller_model\n+\t\t  = event->m_eedge.m_dest->get_state ().m_region_model;\n+\t\ttree caller_var = caller_model->get_representative_tree (sval);\n \t\tcallsite_expr expr;\n \t\ttree callee_var\n-\t\t  = cg_superedge.map_expr_from_caller_to_callee (var, &expr);\n+\t\t  = cg_superedge.map_expr_from_caller_to_callee (caller_var,\n+\t\t\t\t\t\t\t\t &expr);\n \t\tif (callee_var)\n \t\t  {\n-\t\t    log (\"event %i:\"\n-\t\t\t \" switching var of interest\"\n-\t\t\t \" from %qE in caller to %qE in callee\",\n-\t\t\t idx, var, callee_var);\n-\t\t    var = callee_var;\n+\t\t    if (get_logger ())\n+\t\t      {\n+\t\t\tlabel_text sval_desc = sval->get_desc ();\n+\t\t\tlog (\"event %i:\"\n+\t\t\t     \" recording critical state for %qs at return\"\n+\t\t\t     \" from %qE in caller to %qE in callee\",\n+\t\t\t     idx, sval_desc.m_buffer, callee_var, callee_var);\n+\t\t      }\n \t\t    if (expr.return_value_p ())\n-\t\t      event->record_critical_state (var, state);\n-\t\t    update_for_unsuitable_sm_exprs (&var);\n+\t\t      event->record_critical_state (callee_var, state);\n \t\t  }\n \t      }\n \t  }"}, {"sha": "1e310f7fe15a821d10c0f8e65dea596bfed9c033", "filename": "gcc/analyzer/diagnostic-manager.h", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.h?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -39,7 +39,8 @@ class saved_diagnostic\n \t\t    const exploded_node *enode,\n \t\t    const supernode *snode, const gimple *stmt,\n \t\t    stmt_finder *stmt_finder,\n-\t\t    tree var, state_machine::state_t state,\n+\t\t    tree var, const svalue *sval,\n+\t\t    state_machine::state_t state,\n \t\t    pending_diagnostic *d);\n   ~saved_diagnostic ();\n \n@@ -73,6 +74,7 @@ class saved_diagnostic\n   const gimple *m_stmt;\n   stmt_finder *m_stmt_finder;\n   tree m_var;\n+  const svalue *m_sval;\n   state_machine::state_t m_state;\n   pending_diagnostic *m_d;\n   exploded_edge *m_trailing_eedge;\n@@ -99,13 +101,17 @@ class path_builder;\n class diagnostic_manager : public log_user\n {\n public:\n-  diagnostic_manager (logger *logger, int verbosity);\n+  diagnostic_manager (logger *logger, engine *eng, int verbosity);\n+\n+  engine *get_engine () const { return m_eng; }\n \n   void add_diagnostic (const state_machine *sm,\n \t\t       const exploded_node *enode,\n \t\t       const supernode *snode, const gimple *stmt,\n \t\t       stmt_finder *finder,\n-\t\t       tree var, state_machine::state_t state,\n+\t\t       tree var,\n+\t\t       const svalue *sval,\n+\t\t       state_machine::state_t state,\n \t\t       pending_diagnostic *d);\n \n   void add_diagnostic (const exploded_node *enode,\n@@ -152,16 +158,22 @@ class diagnostic_manager : public log_user\n \n   void prune_path (checker_path *path,\n \t\t   const state_machine *sm,\n-\t\t   tree var, state_machine::state_t state) const;\n+\t\t   const svalue *sval,\n+\t\t   state_machine::state_t state) const;\n \n   void prune_for_sm_diagnostic (checker_path *path,\n \t\t\t\tconst state_machine *sm,\n \t\t\t\ttree var,\n \t\t\t\tstate_machine::state_t state) const;\n+  void prune_for_sm_diagnostic (checker_path *path,\n+\t\t\t\tconst state_machine *sm,\n+\t\t\t\tconst svalue *sval,\n+\t\t\t\tstate_machine::state_t state) const;\n   void update_for_unsuitable_sm_exprs (tree *expr) const;\n   void prune_interproc_events (checker_path *path) const;\n   void finish_pruning (checker_path *path) const;\n \n+  engine *m_eng;\n   auto_delete_vec<saved_diagnostic> m_saved_diagnostics;\n   const int m_verbosity;\n };"}, {"sha": "fdfbb0b95686eabb8d1bca16c1e68274205a566f", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 434, "deletions": 356, "changes": 790, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -39,6 +39,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"selftest.h\"\n #include \"analyzer/analyzer.h\"\n #include \"analyzer/analyzer-logging.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n #include \"analyzer/constraint-manager.h\"\n #include \"analyzer/sm.h\"\n@@ -52,8 +55,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"digraph.h\"\n #include \"analyzer/supergraph.h\"\n-#include \"analyzer/call-string.h\"\n-#include \"analyzer/program-point.h\"\n #include \"analyzer/program-state.h\"\n #include \"analyzer/exploded-graph.h\"\n #include \"analyzer/analysis-plan.h\"\n@@ -67,23 +68,19 @@ along with GCC; see the file COPYING3.  If not see\n \n namespace ana {\n \n-static int readability_comparator (const void *p1, const void *p2);\n-\n /* class impl_region_model_context : public region_model_context.  */\n \n impl_region_model_context::\n impl_region_model_context (exploded_graph &eg,\n \t\t\t   const exploded_node *enode_for_diag,\n \t\t\t   const program_state *old_state,\n \t\t\t   program_state *new_state,\n-\t\t\t   state_change *change,\n \t\t\t   const gimple *stmt,\n \t\t\t   stmt_finder *stmt_finder)\n : m_eg (&eg), m_logger (eg.get_logger ()),\n   m_enode_for_diag (enode_for_diag),\n   m_old_state (old_state),\n   m_new_state (new_state),\n-  m_change (change),\n   m_stmt (stmt),\n   m_stmt_finder (stmt_finder),\n   m_ext_state (eg.get_ext_state ())\n@@ -92,13 +89,11 @@ impl_region_model_context (exploded_graph &eg,\n \n impl_region_model_context::\n impl_region_model_context (program_state *state,\n-\t\t\t   state_change *change,\n \t\t\t   const extrinsic_state &ext_state,\n \t\t\t   logger *logger)\n : m_eg (NULL), m_logger (logger), m_enode_for_diag (NULL),\n   m_old_state (NULL),\n   m_new_state (state),\n-  m_change (change),\n   m_stmt (NULL),\n   m_stmt_finder (NULL),\n   m_ext_state (ext_state)\n@@ -116,58 +111,55 @@ impl_region_model_context::warn (pending_diagnostic *d)\n }\n \n void\n-impl_region_model_context::remap_svalue_ids (const svalue_id_map &map)\n+impl_region_model_context::on_svalue_leak (const svalue *sval)\n+\n {\n-  m_new_state->remap_svalue_ids (map);\n-  if (m_change)\n-    m_change->remap_svalue_ids (map);\n+  int sm_idx;\n+  sm_state_map *smap;\n+  FOR_EACH_VEC_ELT (m_new_state->m_checker_states, sm_idx, smap)\n+    smap->on_svalue_leak (sval, this);\n }\n \n-int\n-impl_region_model_context::on_svalue_purge (svalue_id first_unused_sid,\n-\t\t\t\t\t    const svalue_id_map &map)\n+void\n+impl_region_model_context::\n+on_liveness_change (const svalue_set &live_svalues,\n+\t\t    const region_model *model)\n {\n-  int total = 0;\n   int sm_idx;\n   sm_state_map *smap;\n   FOR_EACH_VEC_ELT (m_new_state->m_checker_states, sm_idx, smap)\n-    {\n-      const state_machine &sm = m_ext_state.get_sm (sm_idx);\n-      total += smap->on_svalue_purge (sm, sm_idx, first_unused_sid,\n-\t\t\t\t      map, this);\n-    }\n-  if (m_change)\n-    total += m_change->on_svalue_purge (first_unused_sid);\n-  return total;\n+    smap->on_liveness_change (live_svalues, model, this);\n }\n \n void\n-impl_region_model_context::on_unknown_change (svalue_id sid)\n+impl_region_model_context::on_unknown_change (const svalue *sval,\n+\t\t\t\t\t      bool is_mutable)\n {\n   int sm_idx;\n   sm_state_map *smap;\n   FOR_EACH_VEC_ELT (m_new_state->m_checker_states, sm_idx, smap)\n-    smap->on_unknown_change (sid);\n+    smap->on_unknown_change (sval, is_mutable, m_ext_state);\n }\n \n /* class setjmp_svalue : public svalue.  */\n \n-/* Compare the fields of this setjmp_svalue with OTHER, returning true\n-   if they are equal.\n-   For use by svalue::operator==.  */\n+/* Implementation of svalue::accept vfunc for setjmp_svalue.  */\n \n-bool\n-setjmp_svalue::compare_fields (const setjmp_svalue &other) const\n+void\n+setjmp_svalue::accept (visitor *v) const\n {\n-  return m_setjmp_record == other.m_setjmp_record;\n+  v->visit_setjmp_svalue (this);\n }\n \n-/* Implementation of svalue::add_to_hash vfunc for setjmp_svalue.  */\n+/* Implementation of svalue::dump_to_pp vfunc for setjmp_svalue.  */\n \n void\n-setjmp_svalue::add_to_hash (inchash::hash &hstate) const\n+setjmp_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n {\n-  hstate.add_int (m_setjmp_record.m_enode->m_index);\n+  if (simple)\n+    pp_printf (pp, \"SETJMP(EN: %i)\", get_enode_index ());\n+  else\n+    pp_printf (pp, \"setjmp_svalue(EN%i)\", get_enode_index ());\n }\n \n /* Get the index of the stored exploded_node.  */\n@@ -178,16 +170,6 @@ setjmp_svalue::get_enode_index () const\n   return m_setjmp_record.m_enode->m_index;\n }\n \n-/* Implementation of svalue::print_details vfunc for setjmp_svalue.  */\n-\n-void\n-setjmp_svalue::print_details (const region_model &model ATTRIBUTE_UNUSED,\n-\t\t\t      svalue_id this_sid ATTRIBUTE_UNUSED,\n-\t\t\t      pretty_printer *pp) const\n-{\n-  pp_printf (pp, \"setjmp: EN: %i\", get_enode_index ());\n-}\n-\n /* Concrete implementation of sm_context, wiring it up to the rest of this\n    file.  */\n \n@@ -200,15 +182,13 @@ class impl_sm_context : public sm_context\n \t\t   const exploded_node *enode_for_diag,\n \t\t   const program_state *old_state,\n \t\t   program_state *new_state,\n-\t\t   state_change *change,\n \t\t   const sm_state_map *old_smap,\n \t\t   sm_state_map *new_smap,\n \t\t   stmt_finder *stmt_finder = NULL)\n   : sm_context (sm_idx, sm),\n     m_logger (eg.get_logger ()),\n     m_eg (eg), m_enode_for_diag (enode_for_diag),\n     m_old_state (old_state), m_new_state (new_state),\n-    m_change (change),\n     m_old_smap (old_smap), m_new_smap (new_smap),\n     m_stmt_finder (stmt_finder)\n   {\n@@ -220,13 +200,13 @@ class impl_sm_context : public sm_context\n   {\n     impl_region_model_context old_ctxt\n       (m_eg, m_enode_for_diag, NULL, NULL/*m_enode->get_state ()*/,\n-       m_change, call);\n+       call);\n     region_model *model = m_new_state->m_region_model;\n     return model->get_fndecl_for_call (call, &old_ctxt);\n   }\n \n   void on_transition (const supernode *node  ATTRIBUTE_UNUSED,\n-\t\t      const gimple *stmt  ATTRIBUTE_UNUSED,\n+\t\t      const gimple *stmt,\n \t\t      tree var,\n \t\t      state_machine::state_t from,\n \t\t      state_machine::state_t to,\n@@ -236,19 +216,20 @@ class impl_sm_context : public sm_context\n     LOG_FUNC (logger);\n     impl_region_model_context old_ctxt\n       (m_eg, m_enode_for_diag, NULL, NULL/*m_enode->get_state ()*/,\n-       m_change, stmt);\n-    svalue_id var_old_sid\n+       stmt);\n+    const svalue *var_old_sval\n       = m_old_state->m_region_model->get_rvalue (var, &old_ctxt);\n \n     impl_region_model_context new_ctxt (m_eg, m_enode_for_diag,\n \t\t\t\t\tm_old_state, m_new_state,\n-\t\t\t\t\tm_change, NULL);\n-    svalue_id var_new_sid\n+\t\t\t\t\tstmt);\n+    const svalue *var_new_sval\n       = m_new_state->m_region_model->get_rvalue (var, &new_ctxt);\n-    svalue_id origin_new_sid\n+    const svalue *origin_new_sval\n       = m_new_state->m_region_model->get_rvalue (origin, &new_ctxt);\n \n-    state_machine::state_t current = m_old_smap->get_state (var_old_sid);\n+    state_machine::state_t current\n+      = m_old_smap->get_state (var_old_sval, m_eg.get_ext_state ());\n     if (current == from)\n       {\n \tif (logger)\n@@ -257,10 +238,8 @@ class impl_sm_context : public sm_context\n \t\t       var,\n \t\t       m_sm.get_state_name (from),\n \t\t       m_sm.get_state_name (to));\n-\tm_new_smap->set_state (m_new_state->m_region_model, var_new_sid,\n-\t\t\t       to, origin_new_sid);\n-\tif (m_change)\n-\t  m_change->add_sm_change (m_sm_idx, var_new_sid, from, to);\n+\tm_new_smap->set_state (m_new_state->m_region_model, var_new_sval,\n+\t\t\t       to, origin_new_sval, m_eg.get_ext_state ());\n       }\n   }\n \n@@ -272,22 +251,24 @@ class impl_sm_context : public sm_context\n     gcc_assert (d); // take ownership\n \n     impl_region_model_context old_ctxt\n-      (m_eg, m_enode_for_diag, m_old_state, m_new_state, m_change, NULL);\n+      (m_eg, m_enode_for_diag, m_old_state, m_new_state, NULL);\n     state_machine::state_t current;\n     if (var)\n       {\n-\tsvalue_id var_old_sid\n+\tconst svalue *var_old_sval\n \t  = m_old_state->m_region_model->get_rvalue (var, &old_ctxt);\n-\tcurrent = m_old_smap->get_state (var_old_sid);\n+\tcurrent = m_old_smap->get_state (var_old_sval, m_eg.get_ext_state ());\n       }\n     else\n       current = m_old_smap->get_global_state ();\n \n     if (state == current)\n       {\n+\tconst svalue *var_old_sval\n+\t  = m_old_state->m_region_model->get_rvalue (var, &old_ctxt);\n \tm_eg.get_diagnostic_manager ().add_diagnostic\n \t  (&m_sm, m_enode_for_diag, snode, stmt, m_stmt_finder,\n-\t   var, state, d);\n+\t   var, var_old_sval, state, d);\n       }\n     else\n       delete d;\n@@ -299,7 +280,7 @@ class impl_sm_context : public sm_context\n      we can print:\n        \"double-free of 'inbuf.data'\".  */\n \n-  tree get_readable_tree (tree expr) FINAL OVERRIDE\n+  tree get_diagnostic_tree (tree expr) FINAL OVERRIDE\n   {\n     /* Only for SSA_NAMEs of temporaries; otherwise, return EXPR, as it's\n        likely to be the least surprising tree to report.  */\n@@ -309,16 +290,12 @@ class impl_sm_context : public sm_context\n       return expr;\n \n     gcc_assert (m_new_state);\n-    svalue_id sid = m_new_state->m_region_model->get_rvalue (expr, NULL);\n+    const svalue *sval = m_new_state->m_region_model->get_rvalue (expr, NULL);\n     /* Find trees for all regions storing the value.  */\n-    auto_vec<path_var> pvs;\n-    m_new_state->m_region_model->get_path_vars_for_svalue (sid, &pvs);\n-    if (pvs.length () < 1)\n+    if (tree t = m_new_state->m_region_model->get_representative_tree (sval))\n+      return t;\n+    else\n       return expr;\n-    /* Pick the \"best\" such tree.  */\n-    // TODO: should we also consider (and consolidate) equiv classes?\n-    pvs.qsort (readability_comparator);\n-    return pvs[0].m_tree;\n   }\n \n   state_machine::state_t get_global_state () const FINAL OVERRIDE\n@@ -338,12 +315,27 @@ class impl_sm_context : public sm_context\n \t\t\t\t m_sm_idx);\n   }\n \n+  tree is_zero_assignment (const gimple *stmt) FINAL OVERRIDE\n+  {\n+    const gassign *assign_stmt = dyn_cast <const gassign *> (stmt);\n+    if (!assign_stmt)\n+     return NULL_TREE;\n+    impl_region_model_context old_ctxt\n+      (m_eg, m_enode_for_diag, m_old_state, m_new_state, stmt);\n+    if (const svalue *sval\n+\t= m_new_state->m_region_model->get_gassign_result (assign_stmt,\n+\t\t\t\t\t\t\t    &old_ctxt))\n+      if (tree cst = sval->maybe_get_constant ())\n+\tif (::zerop(cst))\n+\t  return gimple_assign_lhs (assign_stmt);\n+    return NULL_TREE;\n+  }\n+\n   log_user m_logger;\n   exploded_graph &m_eg;\n   const exploded_node *m_enode_for_diag;\n   const program_state *m_old_state;\n   program_state *m_new_state;\n-  state_change *m_change;\n   const sm_state_map *m_old_smap;\n   sm_state_map *m_new_smap;\n   stmt_finder *m_stmt_finder;\n@@ -369,7 +361,7 @@ class leak_stmt_finder : public stmt_finder\n     logger * const logger = m_eg.get_logger ();\n     LOG_FUNC (logger);\n \n-    if (TREE_CODE (m_var) == SSA_NAME)\n+    if (m_var && TREE_CODE (m_var) == SSA_NAME)\n       {\n \t/* Locate the final write to this SSA name in the path.  */\n \tconst gimple *def_stmt = SSA_NAME_DEF_STMT (m_var);\n@@ -452,20 +444,34 @@ readability (const_tree expr)\n     case MEM_REF:\n       /* Impose a slight readability penalty relative to that of\n \t operand 0.  */\n-      return readability (TREE_OPERAND (expr, 0)) - 1;\n+      return readability (TREE_OPERAND (expr, 0)) - 16;\n \n     case SSA_NAME:\n       {\n \tif (tree var = SSA_NAME_VAR (expr))\n-\t  return readability (var);\n+\t  /* Slightly favor the underlying var over the SSA name to\n+\t     avoid having them compare equal.  */\n+\t  return readability (var) - 1;\n \t/* Avoid printing '<unknown>' for SSA names for temporaries.  */\n \treturn -1;\n       }\n       break;\n \n+    case PARM_DECL:\n     case VAR_DECL:\n-      /* Arbitrarily-chosen \"high readability\" value.  */\n-      return 256;\n+      if (DECL_NAME (expr))\n+\t/* Arbitrarily-chosen \"high readability\" value.  */\n+\treturn 65536;\n+      else\n+\t/* We don't want to print temporaries.  For example, the C FE\n+\t   prints them as e.g. \"<Uxxxx>\" where \"xxxx\" is the low 16 bits\n+\t   of the tree pointer (see pp_c_tree_decl_identifier).  */\n+\treturn -1;\n+\n+    case RESULT_DECL:\n+      /* Printing \"<return-value>\" isn't ideal, but is less awful than\n+\t trying to print a temporary.  */\n+      return 32768;\n \n     default:\n       return 0;\n@@ -477,117 +483,81 @@ readability (const_tree expr)\n /* A qsort comparator for trees to sort them into most user-readable to\n    least user-readable.  */\n \n-static int\n+int\n readability_comparator (const void *p1, const void *p2)\n {\n   path_var pv1 = *(path_var const *)p1;\n   path_var pv2 = *(path_var const *)p2;\n \n-  /* TODO: should we consider stack depths?  */\n   int r1 = readability (pv1.m_tree);\n   int r2 = readability (pv2.m_tree);\n+  if (int cmp = r2 - r1)\n+    return cmp;\n+\n+  /* Favor items that are deeper on the stack and hence more recent;\n+     this also favors locals over globals.  */\n+  if (int cmp = pv2.m_stack_depth - pv1.m_stack_depth)\n+    return cmp;\n \n-  return r2 - r1;\n+  /* TODO: We ought to find ways of sorting such cases.  */\n+  return 0;\n }\n \n-/* Create an sm_context and use it to call SM's on_leak vfunc, so that\n-   it can potentially complain about a leak of DST_SID (in a new region_model)\n-   in the given STATE, where MAP can be used to map SID back to an \"old\"\n-   region_model.  */\n+/* Find the best tree for SVAL and call SM's on_leak vfunc with it.\n+   If on_leak returns a pending_diagnostic, queue it up to be reported,\n+   so that we potentially complain about a leak of SVAL in the given STATE.  */\n \n void\n impl_region_model_context::on_state_leak (const state_machine &sm,\n-\t\t\t\t\t  int sm_idx,\n-\t\t\t\t\t  svalue_id dst_sid,\n-\t\t\t\t\t  svalue_id first_unused_sid,\n-\t\t\t\t\t  const svalue_id_map &map,\n+\t\t\t\t\t  const svalue *sval,\n \t\t\t\t\t  state_machine::state_t state)\n {\n   logger * const logger = get_logger ();\n   LOG_SCOPE (logger);\n   if (logger)\n-    logger->log (\"considering leak of sv%i\", dst_sid.as_int ());\n+    {\n+      logger->start_log_line ();\n+      logger->log_partial (\"considering leak of \");\n+      sval->dump_to_pp (logger->get_printer (), true);\n+      logger->end_log_line ();\n+    }\n \n   if (!m_eg)\n     return;\n \n   /* m_old_state also needs to be non-NULL so that the sm_ctxt can look\n-     up the old state of the sid.  */\n+     up the old state of SVAL.  */\n   gcc_assert (m_old_state);\n \n-  /* Don't report on sid leaking if it's equal to one of the used sids.\n-     For example, given:\n-       some_non_trivial_expression = malloc (sizeof (struct foo));\n-     we have:\n-       _1 = malloc;                         (void *)\n-       some_non_trivial_expression = _1;    (struct foo *)\n-     and at leak-detection time we may have:\n-       sv5: {type: 'struct foo *', &r3}  (used)\n-       sv6: {type: 'void *', &r3}         (unused)\n-     where both point to the same region.  We don't want to report a\n-     leak of sv6, so we reject the report due to its equality with sv5.  */\n-  gcc_assert (m_new_state);\n-  gcc_assert (!first_unused_sid.null_p ());\n-  for (int i = 0; i < first_unused_sid.as_int (); i++)\n+  /* SVAL has leaked within the new state: it is not used by any reachable\n+     regions.\n+     We need to convert it back to a tree, but since it's likely no regions\n+     use it, we have to find the \"best\" tree for it in the old_state.  */\n+  svalue_set visited;\n+  path_var leaked_pv\n+    = m_old_state->m_region_model->get_representative_path_var (sval,\n+\t\t\t\t\t\t\t\t&visited);\n+\n+  /* This might be NULL; the pending_diagnostic subclasses need to cope\n+     with this.  */\n+  tree leaked_tree = leaked_pv.m_tree;\n+  if (logger)\n     {\n-      svalue_id used_sid = svalue_id::from_int (i);\n-\n-      /* Use the \"_without_cm\" form of eval_condition, since\n-\t we're half-way through purging - we don't want to introduce new\n-\t equivalence classes into the constraint_manager for \"sid\" and\n-\t for each of the used_sids.  */\n-      const region_model &rm = *m_new_state->m_region_model;\n-      tristate eq = rm.eval_condition_without_cm (dst_sid, EQ_EXPR, used_sid);\n-      if (eq.is_true ())\n-\t{\n-\t  if (logger)\n-\t    logger->log (\"rejecting leak of sv%i due to equality with sv%i\",\n-\t\t\t dst_sid.as_int (), used_sid.as_int ());\n-\t  return;\n-\t}\n+      if (leaked_tree)\n+\tlogger->log (\"best leaked_tree: %qE\", leaked_tree);\n+      else\n+\tlogger->log (\"best leaked_tree: NULL\");\n     }\n \n-  /* SID has leaked within the new state: no regions use it.\n-     We need to convert it back to a tree, but since no regions use it, we\n-     have to use MAP to convert it back to an svalue_id within the old state.\n-     We can then look that svalue_id up to locate regions and thus tree(s)\n-     that use it.  */\n-\n-  svalue_id old_sid = map.get_src_for_dst (dst_sid);\n-\n-  auto_vec<path_var> leaked_pvs;\n-  m_old_state->m_region_model->get_path_vars_for_svalue (old_sid, &leaked_pvs);\n-\n-  if (leaked_pvs.length () < 1)\n-    return;\n-\n-  /* Find \"best\" leaked tree.\n-     Sort the leaks into most human-readable first, through\n-     to least user-readable.  Given that we only emit one\n-     leak per EC, this ought to ensure that we pick the most\n-     user-readable description of each leaking EC.\n-     This assumes that all vars in the EC have the same state.  */\n-  leaked_pvs.qsort (readability_comparator);\n-\n-  tree leaked_tree = leaked_pvs[0].m_tree;\n-  if (logger)\n-    logger->log (\"best leaked_tree: %qE\", leaked_tree);\n-\n   leak_stmt_finder stmt_finder (*m_eg, leaked_tree);\n-  impl_sm_context sm_ctxt (*m_eg, sm_idx, sm, m_enode_for_diag,\n-\t\t\t   m_old_state, m_new_state,\n-\t\t\t   m_change,\n-\t\t\t   m_old_state->m_checker_states[sm_idx],\n-\t\t\t   m_new_state->m_checker_states[sm_idx],\n-\t\t\t   &stmt_finder);\n   gcc_assert (m_enode_for_diag);\n \n   /* Don't complain about leaks when returning from \"main\".  */\n   if (m_enode_for_diag->get_supernode ()\n       && m_enode_for_diag->get_supernode ()->return_p ())\n     {\n       tree fndecl = m_enode_for_diag->get_function ()->decl;\n-      if (0 == strcmp (IDENTIFIER_POINTER (DECL_NAME (fndecl)), \"main\"))\n+      if (id_equal (DECL_NAME (fndecl), \"main\"))\n \t{\n \t  if (logger)\n \t    logger->log (\"not reporting leak from main\");\n@@ -600,48 +570,7 @@ impl_region_model_context::on_state_leak (const state_machine &sm,\n     m_eg->get_diagnostic_manager ().add_diagnostic\n       (&sm, m_enode_for_diag, m_enode_for_diag->get_supernode (),\n        m_stmt, &stmt_finder,\n-       leaked_tree, state, pd);\n-}\n-\n-/* Implementation of region_model_context::on_inherited_svalue vfunc\n-   for impl_region_model_context.\n-   Notify all checkers that CHILD_SID has been created from PARENT_SID,\n-   so that those state machines that inherit state can propagate the state\n-   from parent to child.  */\n-\n-void\n-impl_region_model_context::on_inherited_svalue (svalue_id parent_sid,\n-\t\t\t\t\t\tsvalue_id child_sid)\n-{\n-  if (!m_new_state)\n-    return;\n-\n-  int sm_idx;\n-  sm_state_map *smap;\n-  FOR_EACH_VEC_ELT (m_new_state->m_checker_states, sm_idx, smap)\n-    {\n-      const state_machine &sm = m_ext_state.get_sm (sm_idx);\n-      if (sm.inherited_state_p ())\n-\tsmap->on_inherited_svalue (parent_sid, child_sid);\n-    }\n-}\n-\n-/* Implementation of region_model_context::on_cast vfunc\n-   for impl_region_model_context.\n-   Notify all checkers that DST_SID is a cast of SRC_SID, so that sm-state\n-   can be propagated from src to dst.  */\n-\n-void\n-impl_region_model_context::on_cast (svalue_id src_sid,\n-\t\t\t\t    svalue_id dst_sid)\n-{\n-  if (!m_new_state)\n-    return;\n-\n-  int sm_idx;\n-  sm_state_map *smap;\n-  FOR_EACH_VEC_ELT (m_new_state->m_checker_states, sm_idx, smap)\n-    smap->on_cast (src_sid, dst_sid);\n+       leaked_tree, sval, state, pd);\n }\n \n /* Implementation of region_model_context::on_condition vfunc.\n@@ -658,7 +587,6 @@ impl_region_model_context::on_condition (tree lhs, enum tree_code op, tree rhs)\n       const state_machine &sm = m_ext_state.get_sm (sm_idx);\n       impl_sm_context sm_ctxt (*m_eg, sm_idx, sm, m_enode_for_diag,\n \t\t\t       m_old_state, m_new_state,\n-\t\t\t       m_change,\n \t\t\t       m_old_state->m_checker_states[sm_idx],\n \t\t\t       m_new_state->m_checker_states[sm_idx]);\n       sm.on_condition (&sm_ctxt,\n@@ -681,7 +609,6 @@ impl_region_model_context::on_phi (const gphi *phi, tree rhs)\n       const state_machine &sm = m_ext_state.get_sm (sm_idx);\n       impl_sm_context sm_ctxt (*m_eg, sm_idx, sm, m_enode_for_diag,\n \t\t\t       m_old_state, m_new_state,\n-\t\t\t       m_change,\n \t\t\t       m_old_state->m_checker_states[sm_idx],\n \t\t\t       m_new_state->m_checker_states[sm_idx]);\n       sm.on_phi (&sm_ctxt, m_enode_for_diag->get_supernode (), phi, rhs);\n@@ -699,7 +626,7 @@ impl_region_model_context::on_unexpected_tree_code (tree t,\n   logger * const logger = get_logger ();\n   if (logger)\n     logger->log (\"unhandled tree code: %qs in %qs at %s:%i\",\n-\t\t t ? get_tree_code_name (TREE_CODE (t)) : \"(null)\",\n+\t\t get_tree_code_name (TREE_CODE (t)),\n \t\t loc.get_impl_location ().m_function,\n \t\t loc.get_impl_location ().m_file,\n \t\t loc.get_impl_location ().m_line);\n@@ -730,10 +657,13 @@ point_and_state::validate (const extrinsic_state &ext_state) const\n \t      == m_state.m_region_model->get_stack_depth ());\n   /* Check the functions in the callstring vs those in the frames\n      at each depth.  */\n-  for (int depth = 0; depth < m_point.get_stack_depth (); ++depth)\n+  for (const frame_region *iter_frame\n+\t = m_state.m_region_model->get_current_frame ();\n+       iter_frame; iter_frame = iter_frame->get_calling_frame ())\n     {\n-      gcc_assert (m_point.get_function_at_depth (depth)\n-\t\t  == m_state.m_region_model->get_function_at_depth (depth));\n+      int index = iter_frame->get_index ();\n+      gcc_assert (m_point.get_function_at_depth (index)\n+\t\t  == iter_frame->get_function ());\n     }\n }\n \n@@ -797,17 +727,71 @@ print_enode_indices (pretty_printer *pp,\n     }\n }\n \n+/* struct eg_traits::dump_args_t.  */\n+\n+/* The <FILENAME>.eg.dot output can quickly become unwieldy if we show\n+   full details for all enodes (both in terms of CPU time to render it,\n+   and in terms of being meaningful to a human viewing it).\n+\n+   If we show just the IDs then the resulting graph is usually viewable,\n+   but then we have to keep switching back and forth between the .dot\n+   view and other dumps.\n+\n+   This function implements a heuristic for showing detail at the enodes\n+   that (we hope) matter, and just the ID at other enodes, fixing the CPU\n+   usage of the .dot viewer, and drawing the attention of the viewer\n+   to these enodes.\n+\n+   Return true if ENODE should be shown in detail in .dot output.\n+   Return false if no detail should be shown for ENODE.  */\n+\n+bool\n+eg_traits::dump_args_t::show_enode_details_p (const exploded_node &enode) const\n+{\n+  /* If the number of exploded nodes isn't too large, we may as well show\n+     all enodes in full detail in the .dot output.  */\n+  if (m_eg.m_nodes.length ()\n+\t<= (unsigned) param_analyzer_max_enodes_for_full_dump)\n+    return true;\n+\n+  /* Otherwise, assume that what's most interesting are state explosions,\n+     and thus the places where this happened.\n+     Expand enodes at program points where we hit the per-enode limit, so we\n+     can investigate what exploded.  */\n+  const per_program_point_data *per_point_data\n+    = m_eg.get_per_program_point_data (enode.get_point ());\n+  return per_point_data->m_excess_enodes > 0;\n+}\n+\n /* class exploded_node : public dnode<eg_traits>.  */\n \n /* exploded_node's ctor.  */\n \n exploded_node::exploded_node (const point_and_state &ps,\n \t\t\t      int index)\n-: m_ps (ps), m_status (STATUS_WORKLIST), m_index (index)\n+: m_ps (ps), m_status (STATUS_WORKLIST), m_index (index),\n+  m_num_processed_stmts (0)\n {\n   gcc_checking_assert (ps.get_state ().m_region_model->canonicalized_p ());\n }\n \n+/* Get the stmt that was processed in this enode at index IDX.\n+   IDX is an index within the stmts processed at this enode, rather\n+   than within those of the supernode.  */\n+\n+const gimple *\n+exploded_node::get_processed_stmt (unsigned idx) const\n+{\n+  gcc_assert (idx < m_num_processed_stmts);\n+  const program_point &point = get_point ();\n+  gcc_assert (point.get_kind () == PK_BEFORE_STMT);\n+  const supernode *snode = get_supernode ();\n+  const unsigned int point_stmt_idx = point.get_stmt_idx ();\n+  const unsigned int idx_within_snode = point_stmt_idx + idx;\n+  const gimple *stmt = snode->m_stmts[idx_within_snode];\n+  return stmt;\n+}\n+\n /* For use by dump_dot, get a value for the .dot \"fillcolor\" attribute.\n    Colorize by sm-state, to make it easier to see how sm-state propagates\n    through the exploded_graph.  */\n@@ -829,7 +813,7 @@ exploded_node::get_dot_fillcolor () const\n   FOR_EACH_VEC_ELT (state.m_checker_states, i, smap)\n     {\n       for (sm_state_map::iterator_t iter = smap->begin ();\n-\t iter != smap->end ();\n+\t   iter != smap->end ();\n \t   ++iter)\n \ttotal_sm_state += (*iter).second.m_state;\n       total_sm_state += smap->get_global_state ();\n@@ -839,7 +823,9 @@ exploded_node::get_dot_fillcolor () const\n     {\n       /* An arbitrarily-picked collection of light colors.  */\n       const char * const colors[]\n-\t= {\"azure\", \"coral\", \"cornsilk\", \"lightblue\", \"yellow\"};\n+\t= {\"azure\", \"coral\", \"cornsilk\", \"lightblue\", \"yellow\",\n+\t   \"honeydew\", \"lightpink\", \"lightsalmon\", \"palegreen1\",\n+\t   \"wheat\", \"seashell\"};\n       const int num_colors = sizeof (colors) / sizeof (colors[0]);\n       return colors[total_sm_state % num_colors];\n     }\n@@ -865,28 +851,38 @@ exploded_node::dump_dot (graphviz_out *gv, const dump_args_t &args) const\n     pp_string (pp, \" (merger)\");\n   pp_newline (pp);\n \n-  format f (true);\n-  m_ps.get_point ().print (pp, f);\n-  pp_newline (pp);\n+  if (args.show_enode_details_p (*this))\n+    {\n+      format f (true);\n+      m_ps.get_point ().print (pp, f);\n+      pp_newline (pp);\n \n-  const extrinsic_state &ext_state = args.m_eg.get_ext_state ();\n-  const program_state &state = m_ps.get_state ();\n-  state.dump_to_pp (ext_state, true, pp);\n-  pp_newline (pp);\n+      const extrinsic_state &ext_state = args.m_eg.get_ext_state ();\n+      const program_state &state = m_ps.get_state ();\n+      state.dump_to_pp (ext_state, false, true, pp);\n+      pp_newline (pp);\n \n-  {\n-    int i;\n-    sm_state_map *smap;\n-    FOR_EACH_VEC_ELT (state.m_checker_states, i, smap)\n-      {\n-\tif (!smap->is_empty_p ())\n-\t  {\n-\t    pp_printf (pp, \"%s: \", ext_state.get_name (i));\n-\t    smap->print (ext_state.get_sm (i), state.m_region_model, pp);\n-\t    pp_newline (pp);\n-\t  }\n-      }\n-  }\n+      /* Show any stmts that were processed within this enode,\n+\t and their index within the supernode.  */\n+      if (m_num_processed_stmts > 0)\n+\t{\n+\t  const program_point &point = get_point ();\n+\t  gcc_assert (point.get_kind () == PK_BEFORE_STMT);\n+\t  const supernode *snode = get_supernode ();\n+\t  const unsigned int point_stmt_idx = point.get_stmt_idx ();\n+\n+\t  pp_printf (pp, \"stmts: %i\", m_num_processed_stmts);\n+\t  pp_newline (pp);\n+\t  for (unsigned i = 0; i < m_num_processed_stmts; i++)\n+\t    {\n+\t      const unsigned int idx_within_snode = point_stmt_idx + i;\n+\t      const gimple *stmt = snode->m_stmts[idx_within_snode];\n+\t      pp_printf (pp, \"  %i: \", idx_within_snode);\n+\t      pp_gimple_stmt_1 (pp, stmt, 0, (dump_flags_t)0);\n+\t      pp_newline (pp);\n+\t    }\n+\t}\n+    }\n \n   /* Dump any saved_diagnostics at this enode.  */\n   {\n@@ -929,7 +925,7 @@ exploded_node::dump_to_pp (pretty_printer *pp,\n   m_ps.get_point ().print (pp, f);\n   pp_newline (pp);\n \n-  m_ps.get_state ().dump_to_pp (ext_state, false, pp);\n+  m_ps.get_state ().dump_to_pp (ext_state, false, true, pp);\n   pp_newline (pp);\n }\n \n@@ -1002,17 +998,31 @@ exploded_node::on_stmt_flags\n exploded_node::on_stmt (exploded_graph &eg,\n \t\t\tconst supernode *snode,\n \t\t\tconst gimple *stmt,\n-\t\t\tprogram_state *state,\n-\t\t\tstate_change *change) const\n+\t\t\tprogram_state *state) const\n {\n+  logger *logger = eg.get_logger ();\n+  LOG_SCOPE (logger);\n+  if (logger)\n+    {\n+      logger->start_log_line ();\n+      pp_gimple_stmt_1 (logger->get_printer (), stmt, 0, (dump_flags_t)0);\n+      logger->end_log_line ();\n+    }\n+\n+  /* Update input_location in case of ICE: make it easier to track down which\n+     source construct we're failing to handle.  */\n+  input_location = stmt->location;\n+\n+  gcc_assert (state->m_region_model);\n+\n   /* Preserve the old state.  It is used here for looking\n      up old checker states, for determining state transitions, and\n      also within impl_region_model_context and impl_sm_context for\n      going from tree to svalue_id.  */\n   const program_state old_state (*state);\n \n   impl_region_model_context ctxt (eg, this,\n-\t\t\t\t  &old_state, state, change,\n+\t\t\t\t  &old_state, state,\n \t\t\t\t  stmt);\n \n   if (const gassign *assign = dyn_cast <const gassign *> (stmt))\n@@ -1028,11 +1038,13 @@ exploded_node::on_stmt (exploded_graph &eg,\n   if (const gcall *call = dyn_cast <const gcall *> (stmt))\n     {\n       /* Debugging/test support.  */\n-      if (is_special_named_call_p (call, \"__analyzer_dump\", 0))\n+      if (is_special_named_call_p (call, \"__analyzer_describe\", 2))\n+\tstate->m_region_model->impl_call_analyzer_describe (call, &ctxt);\n+      else if (is_special_named_call_p (call, \"__analyzer_dump\", 0))\n \t{\n \t  /* Handle the builtin \"__analyzer_dump\" by dumping state\n \t     to stderr.  */\n-\t  dump (eg.get_ext_state ());\n+\t  state->dump (eg.get_ext_state (), true);\n \t}\n       else if (is_special_named_call_p (call, \"__analyzer_dump_path\", 0))\n \t{\n@@ -1047,19 +1059,7 @@ exploded_node::on_stmt (exploded_graph &eg,\n \t  state->m_region_model->dump (false);\n \t}\n       else if (is_special_named_call_p (call, \"__analyzer_eval\", 1))\n-\t{\n-\t  /* Handle the builtin \"__analyzer_eval\" by evaluating the input\n-\t     and dumping as a dummy warning, so that test cases can use\n-\t     dg-warning to validate the result (and so unexpected warnings will\n-\t     lead to DejaGnu failures).  */\n-\t  tree t_arg = gimple_call_arg (call, 0);\n-\t  tristate t\n-\t    = state->m_region_model->eval_condition (t_arg,\n-\t\t\t\t\t\t     NE_EXPR,\n-\t\t\t\t\t\t     integer_zero_node,\n-\t\t\t\t\t\t     &ctxt);\n-\t  warning_at (call->location, 0, \"%s\", t.as_string ());\n-\t}\n+\tstate->m_region_model->impl_call_analyzer_eval (call, &ctxt);\n       else if (is_special_named_call_p (call, \"__analyzer_break\", 0))\n \t{\n \t  /* Handle the builtin \"__analyzer_break\" by triggering a\n@@ -1093,25 +1093,10 @@ exploded_node::on_stmt (exploded_graph &eg,\n \t= old_state.m_checker_states[sm_idx];\n       sm_state_map *new_smap = state->m_checker_states[sm_idx];\n       impl_sm_context sm_ctxt (eg, sm_idx, sm, this, &old_state, state,\n-\t\t\t       change,\n \t\t\t       old_smap, new_smap);\n       /* Allow the state_machine to handle the stmt.  */\n       if (sm.on_stmt (&sm_ctxt, snode, stmt))\n \tunknown_side_effects = false;\n-      else\n-\t{\n-\t  /* For those stmts that were not handled by the state machine.  */\n-\t  if (const gcall *call = dyn_cast <const gcall *> (stmt))\n-\t    {\n-\t      tree callee_fndecl\n-\t\t= state->m_region_model->get_fndecl_for_call (call, &ctxt);\n-\n-\t      if (!fndecl_has_gimple_body_p (callee_fndecl))\n-\t\tnew_smap->purge_for_unknown_fncall (eg, sm, call, callee_fndecl,\n-\t\t\t\t\t\t    state->m_region_model,\n-\t\t\t\t\t\t    &ctxt);\n-\t    }\n-\t}\n       if (*old_smap != *new_smap)\n \tany_sm_changes = true;\n     }\n@@ -1142,15 +1127,14 @@ bool\n exploded_node::on_edge (exploded_graph &eg,\n \t\t\tconst superedge *succ,\n \t\t\tprogram_point *next_point,\n-\t\t\tprogram_state *next_state,\n-\t\t\tstate_change *change) const\n+\t\t\tprogram_state *next_state) const\n {\n   LOG_FUNC (eg.get_logger ());\n \n   if (!next_point->on_edge (eg, succ))\n     return false;\n \n-  if (!next_state->on_edge (eg, *this, succ, change))\n+  if (!next_state->on_edge (eg, *this, succ))\n     return false;\n \n   return true;\n@@ -1231,17 +1215,13 @@ exploded_node::on_longjmp (exploded_graph &eg,\n   tree buf_ptr = gimple_call_arg (longjmp_call, 0);\n \n   region_model *new_region_model = new_state->m_region_model;\n-  region_id buf_rid = new_region_model->deref_rvalue (buf_ptr, ctxt);\n-  region *buf = new_region_model->get_region (buf_rid);\n-  if (!buf)\n-    return;\n+  const svalue *buf_ptr_sval = new_region_model->get_rvalue (buf_ptr, ctxt);\n+  const region *buf = new_region_model->deref_rvalue (buf_ptr_sval, buf_ptr,\n+\t\t\t\t\t\t       ctxt);\n \n-  svalue_id buf_content_sid\n-    = buf->get_value (*new_region_model, false, ctxt);\n-  svalue *buf_content_sval = new_region_model->get_svalue (buf_content_sid);\n-  if (!buf_content_sval)\n-    return;\n-  setjmp_svalue *setjmp_sval = buf_content_sval->dyn_cast_setjmp_svalue ();\n+  const svalue *buf_content_sval = new_region_model->get_store_value (buf);\n+  const setjmp_svalue *setjmp_sval\n+    = buf_content_sval->dyn_cast_setjmp_svalue ();\n   if (!setjmp_sval)\n     return;\n \n@@ -1277,19 +1257,22 @@ exploded_node::on_longjmp (exploded_graph &eg,\n   new_region_model->on_longjmp (longjmp_call, setjmp_call,\n \t\t\t\tsetjmp_point.get_stack_depth (), ctxt);\n \n+  /* Detect leaks in the new state relative to the old state.  */\n+  program_state::detect_leaks (get_state (), *new_state, NULL,\n+\t\t\t\teg.get_ext_state (), ctxt);\n+\n   program_point next_point\n     = program_point::after_supernode (setjmp_point.get_supernode (),\n \t\t\t\t      setjmp_point.get_call_string ());\n \n-  state_change change;\n-  exploded_node *next = eg.get_or_create_node (next_point, *new_state, &change);\n+  exploded_node *next\n+    = eg.get_or_create_node (next_point, *new_state, this);\n \n   /* Create custom exploded_edge for a longjmp.  */\n   if (next)\n     {\n       exploded_edge *eedge\n \t= eg.add_edge (const_cast<exploded_node *> (this), next, NULL,\n-\t\t       change,\n \t\t       new rewind_info_t (tmp_setjmp_record, longjmp_call));\n \n       /* For any diagnostics that were queued here (such as leaks) we want\n@@ -1357,13 +1340,13 @@ exploded_node::detect_leaks (exploded_graph &eg) const\n \n   gcc_assert (new_state.m_region_model);\n \n-  purge_stats stats;\n   impl_region_model_context ctxt (eg, this,\n \t\t\t\t  &old_state, &new_state,\n-\t\t\t\t  NULL,\n \t\t\t\t  get_stmt ());\n-  new_state.m_region_model->pop_frame (region_id::null (),\n-\t\t\t\t       true, &stats, &ctxt);\n+  const svalue *result = NULL;\n+  new_state.m_region_model->pop_frame (NULL, &result, &ctxt);\n+  program_state::detect_leaks (old_state, new_state, result,\n+\t\t\t       eg.get_ext_state (), &ctxt);\n }\n \n /* Dump the successors and predecessors of this enode to OUTF.  */\n@@ -1448,14 +1431,11 @@ rewind_info_t::add_events_to_path (checker_path *emission_path,\n /* exploded_edge's ctor.  */\n \n exploded_edge::exploded_edge (exploded_node *src, exploded_node *dest,\n-\t\t\t      const extrinsic_state &ext_state,\n \t\t\t      const superedge *sedge,\n-\t\t\t      const state_change &change,\n \t\t\t      custom_info_t *custom_info)\n-: dedge<eg_traits> (src, dest), m_sedge (sedge), m_change (change),\n+: dedge<eg_traits> (src, dest), m_sedge (sedge),\n   m_custom_info (custom_info)\n {\n-  change.validate (dest->get_state (), ext_state);\n }\n \n /* exploded_edge's dtor.  */\n@@ -1469,7 +1449,7 @@ exploded_edge::~exploded_edge ()\n    Use the label of the underlying superedge, if any.  */\n \n void\n-exploded_edge::dump_dot (graphviz_out *gv, const dump_args_t &args) const\n+exploded_edge::dump_dot (graphviz_out *gv, const dump_args_t &) const\n {\n   pretty_printer *pp = gv->get_pp ();\n \n@@ -1516,7 +1496,6 @@ exploded_edge::dump_dot (graphviz_out *gv, const dump_args_t &args) const\n   else if (m_custom_info)\n     m_custom_info->print (pp);\n \n-  m_change.dump (pp, args.m_eg.get_ext_state ());\n   //pp_write_text_as_dot_label_to_stream (pp, /*for_record=*/false);\n \n   pp_printf (pp, \"\\\"];\\n\");\n@@ -1816,14 +1795,12 @@ exploded_graph::exploded_graph (const supergraph &sg, logger *logger,\n   m_ext_state (ext_state),\n   m_purge_map (purge_map),\n   m_plan (plan),\n-  m_diagnostic_manager (logger, verbosity),\n+  m_diagnostic_manager (logger, ext_state.get_engine (), verbosity),\n   m_global_stats (m_sg.num_nodes ()),\n   m_functionless_stats (m_sg.num_nodes ()),\n   m_PK_AFTER_SUPERNODE_per_snode (m_sg.num_nodes ())\n {\n-  m_origin = get_or_create_node (program_point (function_point (NULL, NULL,\n-\t\t\t\t\t\t\t\t0, PK_ORIGIN),\n-\t\t\t\t\t\tcall_string ()),\n+  m_origin = get_or_create_node (program_point::origin (),\n \t\t\t\t program_state (ext_state), NULL);\n   for (int i = 0; i < m_sg.num_nodes (); i++)\n     m_PK_AFTER_SUPERNODE_per_snode.quick_push (i);\n@@ -1857,29 +1834,29 @@ exploded_graph::add_function_entry (function *fun)\n {\n   program_point point = program_point::from_function_entry (m_sg, fun);\n   program_state state (m_ext_state);\n-  impl_region_model_context ctxt (&state, NULL, m_ext_state, get_logger ());\n-  state.m_region_model->push_frame (fun, NULL, &ctxt);\n+  state.push_frame (m_ext_state, fun);\n \n   if (!state.m_valid)\n     return NULL;\n \n   exploded_node *enode = get_or_create_node (point, state, NULL);\n   /* We should never fail to add such a node.  */\n   gcc_assert (enode);\n-  state_change change;\n-  add_edge (m_origin, enode, NULL, change);\n+  add_edge (m_origin, enode, NULL);\n   return enode;\n }\n \n /* Get or create an exploded_node for (POINT, STATE).\n    If a new node is created, it is added to the worklist.\n-   If CHANGE is non-NULL, use it to suppress some purging of state,\n-   to make generation of state_change_event instances easier.  */\n+\n+   Use ENODE_FOR_DIAG, a pre-existing enode, for any diagnostics\n+   that need to be emitted (e.g. when purging state *before* we have\n+   a new enode).  */\n \n exploded_node *\n exploded_graph::get_or_create_node (const program_point &point,\n \t\t\t\t    const program_state &state,\n-\t\t\t\t    state_change *change)\n+\t\t\t\t    const exploded_node *enode_for_diag)\n {\n   logger * const logger = get_logger ();\n   LOG_FUNC (logger);\n@@ -1893,7 +1870,7 @@ exploded_graph::get_or_create_node (const program_point &point,\n       logger->end_log_line ();\n       logger->start_log_line ();\n       pp_string (pp, \"state: \");\n-      state.dump_to_pp (m_ext_state, true, pp);\n+      state.dump_to_pp (m_ext_state, true, false, pp);\n       logger->end_log_line ();\n     }\n \n@@ -1914,7 +1891,8 @@ exploded_graph::get_or_create_node (const program_point &point,\n \n   /* Prune state to try to improve the chances of a cache hit,\n      avoiding generating redundant nodes.  */\n-  program_state pruned_state = state.prune_for_point (*this, point, change);\n+  program_state pruned_state\n+    = state.prune_for_point (*this, point, enode_for_diag);\n \n   pruned_state.validate (get_ext_state ());\n \n@@ -1925,9 +1903,10 @@ exploded_graph::get_or_create_node (const program_point &point,\n       pretty_printer *pp = logger->get_printer ();\n       logger->start_log_line ();\n       pp_string (pp, \"pruned_state: \");\n-      pruned_state.dump_to_pp (m_ext_state, true, pp);\n+      pruned_state.dump_to_pp (m_ext_state, true, false, pp);\n       logger->end_log_line ();\n-      pruned_state.m_region_model->dump_to_pp (logger->get_printer (), true);\n+      pruned_state.m_region_model->dump_to_pp (logger->get_printer (), true,\n+\t\t\t\t\t\tfalse);\n     }\n \n   stats *per_fn_stats = get_or_create_function_stats (point.get_function ());\n@@ -1967,7 +1946,7 @@ exploded_graph::get_or_create_node (const program_point &point,\n \t  /* This merges successfully within the loop.  */\n \n \t  program_state merged_state (m_ext_state);\n-\t  if (pruned_state.can_merge_with_p (existing_state, m_ext_state,\n+\t  if (pruned_state.can_merge_with_p (existing_state, point,\n \t\t\t\t\t     &merged_state))\n \t    {\n \t      if (logger)\n@@ -1979,8 +1958,6 @@ exploded_graph::get_or_create_node (const program_point &point,\n \t\t relationship to those of the input state, and thus to those\n \t\t of CHANGE, so we must purge any svalue_ids from *CHANGE.  */\n \t      ps.set_state (merged_state);\n-\t      if (change)\n-\t\tchange->on_svalue_purge (svalue_id::from_int (0));\n \n \t      if (exploded_node **slot = m_point_and_state_to_node.get (&ps))\n \t\t{\n@@ -2005,10 +1982,14 @@ exploded_graph::get_or_create_node (const program_point &point,\n   if ((int)per_point_data->m_enodes.length ()\n       > param_analyzer_max_enodes_per_program_point)\n     {\n+      pretty_printer pp;\n+      print_enode_indices (&pp, per_point_data->m_enodes);\n       if (logger)\n-\tlogger->log (\"not creating enode; too many at program point\");\n+\tlogger->log (\"not creating enode; too many at program point: %s\",\n+\t\t     pp_formatted_text (&pp));\n       warning_at (point.get_location (), OPT_Wanalyzer_too_complex,\n-\t\t  \"terminating analysis for this program point\");\n+\t\t  \"terminating analysis for this program point: %s\",\n+\t\t  pp_formatted_text (&pp));\n       per_point_data->m_excess_enodes++;\n       return NULL;\n     }\n@@ -2042,7 +2023,7 @@ exploded_graph::get_or_create_node (const program_point &point,\n       logger->end_log_line ();\n       logger->start_log_line ();\n       pp_string (pp, \"pruned_state: \");\n-      pruned_state.dump_to_pp (m_ext_state, true, pp);\n+      pruned_state.dump_to_pp (m_ext_state, true, false, pp);\n       logger->end_log_line ();\n     }\n \n@@ -2059,11 +2040,12 @@ exploded_graph::get_or_create_node (const program_point &point,\n exploded_edge *\n exploded_graph::add_edge (exploded_node *src, exploded_node *dest,\n \t\t\t  const superedge *sedge,\n-\t\t\t  const state_change &change,\n \t\t\t  exploded_edge::custom_info_t *custom_info)\n {\n-  exploded_edge *e = new exploded_edge (src, dest, m_ext_state,\n-\t\t\t\t\tsedge, change, custom_info);\n+  if (get_logger ())\n+    get_logger ()->log (\"creating edge EN: %i -> EN: %i\",\n+\t\t\tsrc->m_index, dest->m_index);\n+  exploded_edge *e = new exploded_edge (src, dest, sedge, custom_info);\n   digraph<eg_traits>::add_edge (e);\n   return e;\n }\n@@ -2083,6 +2065,19 @@ get_or_create_per_program_point_data (const program_point &point)\n   return per_point_data;\n }\n \n+/* Get this graph's per-program-point-data for POINT if there is any,\n+   otherwise NULL.  */\n+\n+per_program_point_data *\n+exploded_graph::get_per_program_point_data (const program_point &point) const\n+{\n+  if (per_program_point_data **slot\n+      = const_cast <point_map_t &> (m_per_point_data).get (&point))\n+    return *slot;\n+\n+  return NULL;\n+}\n+\n /* Ensure that this graph has per-call_string-data for CS;\n    borrow a pointer to it.  */\n \n@@ -2234,6 +2229,7 @@ exploded_graph::process_worklist ()\n \n \t    if (node->get_point () == node_2->get_point ())\n \t      {\n+\t\tconst program_point &point = node->get_point ();\n \t\tif (logger)\n \t\t  {\n \t\t    format f (false);\n@@ -2242,10 +2238,9 @@ exploded_graph::process_worklist ()\n \t\t    logger->log_partial\n \t\t      (\"got potential merge EN: %i and EN: %i at \",\n \t\t       node->m_index, node_2->m_index);\n-\t\t    node->get_point ().print (pp, f);\n+\t\t    point.print (pp, f);\n \t\t    logger->end_log_line ();\n \t\t  }\n-\n \t\tconst program_state &state = node->get_state ();\n \t\tconst program_state &state_2 = node_2->get_state ();\n \n@@ -2254,9 +2249,7 @@ exploded_graph::process_worklist ()\n \t\tgcc_assert (state != state_2);\n \n \t\tprogram_state merged_state (m_ext_state);\n-\t\tstate_change change;\n-\t\tif (state.can_merge_with_p (state_2, m_ext_state,\n-\t\t\t\t\t    &merged_state))\n+\t\tif (state.can_merge_with_p (state_2, point, &merged_state))\n \t\t  {\n \t\t    if (logger)\n \t\t      logger->log (\"merging EN: %i and EN: %i\",\n@@ -2265,7 +2258,7 @@ exploded_graph::process_worklist ()\n \t\t    if (merged_state == state)\n \t\t      {\n \t\t\t/* Then merge node_2 into node by adding an edge.  */\n-\t\t\tadd_edge (node_2, node, NULL, change);\n+\t\t\tadd_edge (node_2, node, NULL);\n \n \t\t\t/* Remove node_2 from the worklist.  */\n \t\t\tm_worklist.take_next ();\n@@ -2278,7 +2271,7 @@ exploded_graph::process_worklist ()\n \t\t\t/* Then merge node into node_2, and leave node_2\n \t\t\t   in the worklist, to be processed on the next\n \t\t\t   iteration.  */\n-\t\t\tadd_edge (node, node_2, NULL, change);\n+\t\t\tadd_edge (node, node_2, NULL);\n \t\t\tnode->set_status (exploded_node::STATUS_MERGER);\n \t\t\tcontinue;\n \t\t      }\n@@ -2294,7 +2287,7 @@ exploded_graph::process_worklist ()\n \t\t\t   states, adding to the worklist.  */\n \t\t\texploded_node *merged_enode\n \t\t\t  = get_or_create_node (node->get_point (),\n-\t\t\t\t\t\tmerged_state, &change);\n+\t\t\t\t\t\tmerged_state, node);\n \t\t\tif (merged_enode == NULL)\n \t\t\t  continue;\n \n@@ -2323,15 +2316,15 @@ exploded_graph::process_worklist ()\n \t\t\t  m_worklist.add_node (merged_enode);\n \t\t\telse\n \t\t\t  {\n-\t\t\t    add_edge (node, merged_enode, NULL, change);\n+\t\t\t    add_edge (node, merged_enode, NULL);\n \t\t\t    node->set_status (exploded_node::STATUS_MERGER);\n \t\t\t  }\n \n \t\t\tif (merged_enode == node_2)\n \t\t\t  m_worklist.add_node (merged_enode);\n \t\t\telse\n \t\t\t  {\n-\t\t\t    add_edge (node_2, merged_enode, NULL, change);\n+\t\t\t    add_edge (node_2, merged_enode, NULL);\n \t\t\t    node_2->set_status (exploded_node::STATUS_MERGER);\n \t\t\t  }\n \n@@ -2435,7 +2428,7 @@ exploded_graph::process_node (exploded_node *node)\n       pp_string (pp, \"point: \");\n       point.print (pp, format (false));\n       pp_string (pp, \", state: \");\n-      state.dump_to_pp (m_ext_state, true, pp);\n+      state.dump_to_pp (m_ext_state, true, false, pp);\n       logger->end_log_line ();\n     }\n \n@@ -2451,13 +2444,11 @@ exploded_graph::process_node (exploded_node *node)\n     case PK_BEFORE_SUPERNODE:\n       {\n \tprogram_state next_state (state);\n-\tstate_change change;\n \n \tif (point.get_from_edge ())\n \t  {\n \t    impl_region_model_context ctxt (*this, node,\n-\t\t\t\t\t    &state, &next_state, &change,\n-\t\t\t\t\t    NULL);\n+\t\t\t\t\t    &state, &next_state, NULL);\n \t    const cfg_superedge *last_cfg_superedge\n \t      = point.get_from_edge ()->dyn_cast_cfg_superedge ();\n \t    if (last_cfg_superedge)\n@@ -2473,19 +2464,19 @@ exploded_graph::process_node (exploded_node *node)\n \t      = program_point::before_stmt (point.get_supernode (), 0,\n \t\t\t\t\t    point.get_call_string ());\n \t    exploded_node *next\n-\t      = get_or_create_node (next_point, next_state, &change);\n+\t      = get_or_create_node (next_point, next_state, node);\n \t    if (next)\n-\t      add_edge (node, next, NULL, change);\n+\t      add_edge (node, next, NULL);\n \t  }\n \telse\n \t  {\n \t    program_point next_point\n \t      = program_point::after_supernode (point.get_supernode (),\n \t\t\t\t\t\tpoint.get_call_string ());\n \t    exploded_node *next = get_or_create_node (next_point, next_state,\n-\t\t\t\t\t\t      &change);\n+\t\t\t\t\t\t      node);\n \t    if (next)\n-\t      add_edge (node, next, NULL, change);\n+\t      add_edge (node, next, NULL);\n \t  }\n       }\n       break;\n@@ -2505,9 +2496,12 @@ exploded_graph::process_node (exploded_node *node)\n \t   their enode (for which stmt_requires_new_enode_p returns true)\n \n \t   Update next_state in-place, to get the result of the one\n-\t   or more stmts that are processed.  */\n+\t   or more stmts that are processed.\n+\n+\t   Split the node in-place if an sm-state-change occurs, so that\n+\t   the sm-state-change occurs on an edge where the src enode has\n+\t   exactly one stmt, the one that caused the change. */\n \tprogram_state next_state (state);\n-\tstate_change change;\n \tconst supernode *snode = point.get_supernode ();\n \tunsigned stmt_idx;\n \tconst gimple *prev_stmt = NULL;\n@@ -2525,17 +2519,71 @@ exploded_graph::process_node (exploded_node *node)\n \t\t}\n \t    prev_stmt = stmt;\n \n+\t    program_state old_state (next_state);\n+\n \t    /* Process the stmt.  */\n \t    exploded_node::on_stmt_flags flags\n-\t      = node->on_stmt (*this, snode, stmt, &next_state, &change);\n+\t      = node->on_stmt (*this, snode, stmt, &next_state);\n+\t    node->m_num_processed_stmts++;\n \n \t    /* If flags.m_terminate_path, stop analyzing; any nodes/edges\n \t       will have been added by on_stmt (e.g. for handling longjmp).  */\n \t    if (flags.m_terminate_path)\n \t      return;\n \n+\t    if (next_state.m_region_model)\n+\t      {\n+\t\timpl_region_model_context ctxt (*this, node,\n+\t\t\t\t\t\t&old_state, &next_state, stmt);\n+\t\tprogram_state::detect_leaks (old_state, next_state, NULL,\n+\t\t\t\t\t     get_ext_state (), &ctxt);\n+\t      }\n+\n+\t    unsigned next_idx = stmt_idx + 1;\n+\t    program_point next_point\n+\t      = (next_idx < point.get_supernode ()->m_stmts.length ()\n+\t\t ? program_point::before_stmt (point.get_supernode (), next_idx,\n+\t\t\t\t\t       point.get_call_string ())\n+\t\t : program_point::after_supernode (point.get_supernode (),\n+\t\t\t\t\t\t   point.get_call_string ()));\n+\t    next_state = next_state.prune_for_point (*this, next_point, node);\n+\n \t    if (flags.m_sm_changes || flag_analyzer_fine_grained)\n-\t      break;\n+\t      {\n+\t\tprogram_point split_point\n+\t\t  = program_point::before_stmt (point.get_supernode (),\n+\t\t\t\t\t\tstmt_idx,\n+\t\t\t\t\t\tpoint.get_call_string ());\n+\t\tif (split_point != node->get_point ())\n+\t\t  {\n+\t\t    /* If we're not at the start of NODE, split the enode at\n+\t\t       this stmt, so we have:\n+\t\t\t node -> split_enode\n+\t\t       so that when split_enode is processed the next edge\n+\t\t       we add will be:\n+\t\t\t split_enode -> next\n+\t\t       and any state change will effectively occur on that\n+\t\t       latter edge, and split_enode will contain just stmt.  */\n+\t\t    if (logger)\n+\t\t      logger->log (\"getting split_enode\");\n+\t\t    exploded_node *split_enode\n+\t\t      = get_or_create_node (split_point, old_state, node);\n+\t\t    if (!split_enode)\n+\t\t      return;\n+\t\t    /* \"stmt\" will be reprocessed when split_enode is\n+\t\t       processed.  */\n+\t\t    node->m_num_processed_stmts--;\n+\t\t    if (logger)\n+\t\t      logger->log (\"creating edge to split_enode\");\n+\t\t    add_edge (node, split_enode, NULL);\n+\t\t    return;\n+\t\t  }\n+\t\telse\n+\t\t  /* If we're at the start of NODE, stop iterating,\n+\t\t     so that an edge will be created from NODE to\n+\t\t     (next_point, next_state) below. */\n+\t\t  break;\n+\t      }\n \t  }\n \tunsigned next_idx = stmt_idx + 1;\n \tprogram_point next_point\n@@ -2544,10 +2592,9 @@ exploded_graph::process_node (exploded_node *node)\n \t\t\t\t\t   point.get_call_string ())\n \t     : program_point::after_supernode (point.get_supernode (),\n \t\t\t\t\t       point.get_call_string ()));\n-\texploded_node *next = get_or_create_node (next_point,\n-\t\t\t\t\t\t  next_state, &change);\n+\texploded_node *next = get_or_create_node (next_point, next_state, node);\n \tif (next)\n-\t  add_edge (node, next, NULL, change);\n+\t  add_edge (node, next, NULL);\n       }\n       break;\n     case PK_AFTER_SUPERNODE:\n@@ -2570,7 +2617,7 @@ exploded_graph::process_node (exploded_node *node)\n \t\t    logger->log_partial\n \t\t      (\"would create function summary for %qE; state: \",\n \t\t       point.get_fndecl ());\n-\t\t    state.dump_to_pp (m_ext_state, true, pp);\n+\t\t    state.dump_to_pp (m_ext_state, true, false, pp);\n \t\t    logger->end_log_line ();\n \t\t  }\n \t\tper_function_data *per_fn_data\n@@ -2587,14 +2634,12 @@ exploded_graph::process_node (exploded_node *node)\n \t      logger->log (\"considering SN: %i -> SN: %i\",\n \t\t\t   succ->m_src->m_index, succ->m_dest->m_index);\n \n-\t    state_change change;\n-\n \t    program_point next_point\n \t      = program_point::before_supernode (succ->m_dest, succ,\n \t\t\t\t\t\t point.get_call_string ());\n \t    program_state next_state (state);\n \n-\t    if (!node->on_edge (*this, succ, &next_point, &next_state, &change))\n+\t    if (!node->on_edge (*this, succ, &next_point, &next_state))\n \t      {\n \t\tif (logger)\n \t\t  logger->log (\"skipping impossible edge to SN: %i\",\n@@ -2603,9 +2648,9 @@ exploded_graph::process_node (exploded_node *node)\n \t      }\n \n \t    exploded_node *next = get_or_create_node (next_point, next_state,\n-\t\t\t\t\t\t      &change);\n+\t\t\t\t\t\t      node);\n \t    if (next)\n-\t      add_edge (node, next, succ, change);\n+\t      add_edge (node, next, succ);\n \t  }\n       }\n       break;\n@@ -2739,6 +2784,8 @@ exploded_graph::log_stats () const\n \n   LOG_SCOPE (logger);\n \n+  m_ext_state.get_engine ()->log_stats (logger);\n+\n   logger->log (\"m_sg.num_nodes (): %i\", m_sg.num_nodes ());\n   logger->log (\"m_nodes.length (): %i\", m_nodes.length ());\n   logger->log (\"m_edges.length (): %i\", m_edges.length ());\n@@ -2802,7 +2849,7 @@ exploded_graph::dump_states_for_supernode (FILE *out,\n \t{\n \t  pretty_printer pp;\n \t  pp_format_decoder (&pp) = default_tree_printer;\n-\t  enode->get_state ().dump_to_pp (m_ext_state, true, &pp);\n+\t  enode->get_state ().dump_to_pp (m_ext_state, true, false, &pp);\n \t  fprintf (out, \"state %i: EN: %i\\n  %s\\n\",\n \t\t   state_idx++, enode->m_index,\n \t\t   pp_formatted_text (&pp));\n@@ -2850,18 +2897,21 @@ exploded_path::get_final_enode () const\n    feasibility_problem to *OUT.  */\n \n bool\n-exploded_path::feasible_p (logger *logger, feasibility_problem **out) const\n+exploded_path::feasible_p (logger *logger, feasibility_problem **out,\n+\t\t\t    engine *eng, const exploded_graph *eg) const\n {\n   LOG_SCOPE (logger);\n \n+  auto_sbitmap snodes_visited (eg->get_supergraph ().m_nodes.length ());\n+\n   /* Traverse the path, updating this model.  */\n-  region_model model;\n-  for (unsigned i = 0; i < m_edges.length (); i++)\n+  region_model model (eng->get_model_manager ());\n+  for (unsigned edge_idx = 0; edge_idx < m_edges.length (); edge_idx++)\n     {\n-      const exploded_edge *eedge = m_edges[i];\n+      const exploded_edge *eedge = m_edges[edge_idx];\n       if (logger)\n \tlogger->log (\"considering edge %i: EN:%i -> EN:%i\",\n-\t\t     i,\n+\t\t     edge_idx,\n \t\t     eedge->m_src->m_index,\n \t\t     eedge->m_dest->m_index);\n       const exploded_node &src_enode = *eedge->m_src;\n@@ -2873,8 +2923,12 @@ exploded_path::feasible_p (logger *logger, feasibility_problem **out) const\n \t  logger->end_log_line ();\n \t}\n \n-      if (const gimple *stmt = src_point.get_stmt ())\n+      /* Update state for the stmts that were processed in each enode.  */\n+      for (unsigned stmt_idx = 0; stmt_idx < src_enode.m_num_processed_stmts;\n+\t   stmt_idx++)\n \t{\n+\t  const gimple *stmt = src_enode.get_processed_stmt (stmt_idx);\n+\n \t  /* Update cfun and input_location in case of ICE: make it easier to\n \t     track down which source construct we're failing to handle.  */\n \t  auto_cfun sentinel (src_point.get_function ());\n@@ -2901,18 +2955,19 @@ exploded_path::feasible_p (logger *logger, feasibility_problem **out) const\n \t      if (logger)\n \t\t{\n \t\t  logger->log (\"rejecting due to region model\");\n-\t\t  model.dump_to_pp (logger->get_printer (), false);\n+\t\t  model.dump_to_pp (logger->get_printer (), true, false);\n \t\t}\n \t      if (out)\n-\t\t*out = new feasibility_problem (i, model, *eedge, last_stmt);\n+\t\t*out = new feasibility_problem (edge_idx, model, *eedge,\n+\t\t\t\t\t\tlast_stmt);\n \t      return false;\n \t    }\n \t}\n       else\n \t{\n \t  /* Special-case the initial eedge from the origin node to the\n \t     initial function by pushing a frame for it.  */\n-\t  if (i == 0)\n+\t  if (edge_idx == 0)\n \t    {\n \t      gcc_assert (eedge->m_src->m_index == 0);\n \t      gcc_assert (src_point.get_kind () == PK_ORIGIN);\n@@ -2925,7 +2980,9 @@ exploded_path::feasible_p (logger *logger, feasibility_problem **out) const\n \t\tlogger->log (\"  pushing frame for %qD\", fun->decl);\n \t    }\n \t  else if (eedge->m_custom_info)\n-\t    eedge->m_custom_info->update_model (&model, *eedge);\n+\t    {\n+\t      eedge->m_custom_info->update_model (&model, *eedge);\n+\t    }\n \t}\n \n       /* Handle phi nodes on an edge leaving a PK_BEFORE_SUPERNODE (to\n@@ -2935,24 +2992,35 @@ exploded_path::feasible_p (logger *logger, feasibility_problem **out) const\n \t{\n \t  const cfg_superedge *last_cfg_superedge\n \t    = src_point.get_from_edge ()->dyn_cast_cfg_superedge ();\n+\t  const exploded_node &dst_enode = *eedge->m_dest;\n+\t  const unsigned dst_snode_idx = dst_enode.get_supernode ()->m_index;\n \t  if (last_cfg_superedge)\n \t    {\n \t      if (logger)\n \t\tlogger->log (\"  update for phis\");\n \t      model.update_for_phis (src_enode.get_supernode (),\n \t\t\t\t     last_cfg_superedge,\n \t\t\t\t     NULL);\n+\t      /* If we've entering an snode that we've already visited on this\n+\t\t epath, then we need do fix things up for loops; see the\n+\t\t comment for store::loop_replay_fixup.\n+\t\t Perhaps we should probably also verify the callstring,\n+\t\t and track program_points,  but hopefully doing it by supernode\n+\t\t is good enough.  */\n+\t      if (bitmap_bit_p (snodes_visited, dst_snode_idx))\n+\t\tmodel.loop_replay_fixup (dst_enode.get_state ().m_region_model);\n \t    }\n+\t  bitmap_set_bit (snodes_visited, dst_snode_idx);\n \t}\n \n       if (logger)\n \t{\n \t  logger->log (\"state after edge %i: EN:%i -> EN:%i\",\n-\t\t       i,\n+\t\t       edge_idx,\n \t\t       eedge->m_src->m_index,\n \t\t       eedge->m_dest->m_index);\n \t  logger->start_log_line ();\n-\t  model.dump_to_pp (logger->get_printer (), true);\n+\t  model.dump_to_pp (logger->get_printer (), true, false);\n \t  logger->end_log_line ();\n \t}\n     }\n@@ -3259,7 +3327,7 @@ class enode_label : public range_label\n   {\n     pretty_printer pp;\n     pp_format_decoder (&pp) = default_tree_printer;\n-    m_enode->get_state ().dump_to_pp (m_ext_state, true, &pp);\n+    m_enode->get_state ().dump_to_pp (m_ext_state, true, false, &pp);\n     return make_label_text (false, \"EN: %i: %s\",\n \t\t\t    m_enode->m_index, pp_formatted_text (&pp));\n   }\n@@ -3346,7 +3414,7 @@ exploded_graph::dump_exploded_nodes () const\n \t  pretty_printer pp;\n \t  enode->get_point ().print (&pp, format (true));\n \t  fprintf (outf, \"%s\\n\", pp_formatted_text (&pp));\n-\t  enode->get_state ().dump_to_file (m_ext_state, false, outf);\n+\t  enode->get_state ().dump_to_file (m_ext_state, false, true, outf);\n \t}\n \n       fclose (outf);\n@@ -3373,7 +3441,7 @@ exploded_graph::dump_exploded_nodes () const\n \t  pretty_printer pp;\n \t  enode->get_point ().print (&pp, format (true));\n \t  fprintf (outf, \"%s\\n\", pp_formatted_text (&pp));\n-\t  enode->get_state ().dump_to_file (m_ext_state, false, outf);\n+\t  enode->get_state ().dump_to_file (m_ext_state, false, true, outf);\n \n \t  fclose (outf);\n \t}\n@@ -3482,6 +3550,14 @@ exploded_graph::dump_exploded_nodes () const\n     }\n }\n \n+DEBUG_FUNCTION exploded_node *\n+exploded_graph::get_node_by_index (int idx) const\n+{\n+  exploded_node *enode = m_nodes[idx];\n+  gcc_assert (enode->m_index == idx);\n+  return enode;\n+}\n+\n /* A collection of classes for visualizing the callgraph in .dot form\n    (as represented in the supergraph).  */\n \n@@ -3974,6 +4050,8 @@ impl_run_checkers (logger *logger)\n   FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n     node->get_untransformed_body ();\n \n+  engine eng;\n+\n   /* Create the supergraph.  */\n   supergraph sg (logger);\n \n@@ -4014,7 +4092,7 @@ impl_run_checkers (logger *logger)\n     }\n \n   /* Extrinsic state shared by nodes in the graph.  */\n-  const extrinsic_state ext_state (checkers);\n+  const extrinsic_state ext_state (checkers, logger, &eng);\n \n   const analysis_plan plan (sg, logger);\n "}, {"sha": "e36f94ec1254c8369a21c0c02dbe5cc51ca8106e", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 24, "deletions": 31, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -36,44 +36,30 @@ class impl_region_model_context : public region_model_context\n \t\t\t\told state, rather than the new?  */\n \t\t\t     const program_state *old_state,\n \t\t\t     program_state *new_state,\n-\t\t\t     state_change *change,\n \n \t\t\t     const gimple *stmt,\n \t\t\t     stmt_finder *stmt_finder = NULL);\n \n   impl_region_model_context (program_state *state,\n-\t\t\t     state_change *change,\n \t\t\t     const extrinsic_state &ext_state,\n \t\t\t     logger *logger = NULL);\n \n   void warn (pending_diagnostic *d) FINAL OVERRIDE;\n-\n-  void remap_svalue_ids (const svalue_id_map &map) FINAL OVERRIDE;\n-\n-  int on_svalue_purge (svalue_id first_unused_sid,\n-\t\t       const svalue_id_map &map) FINAL OVERRIDE;\n-\n+  void on_svalue_leak (const svalue *) OVERRIDE;\n+  void on_liveness_change (const svalue_set &live_svalues,\n+\t\t\t   const region_model *model) FINAL OVERRIDE;\n   logger *get_logger () FINAL OVERRIDE\n   {\n     return m_logger.get_logger ();\n   }\n \n   void on_state_leak (const state_machine &sm,\n-\t\t      int sm_idx,\n-\t\t      svalue_id sid,\n-\t\t      svalue_id first_unused_sid,\n-\t\t      const svalue_id_map &map,\n+\t\t      const svalue *sval,\n \t\t      state_machine::state_t state);\n \n-  void on_inherited_svalue (svalue_id parent_sid,\n-\t\t\t    svalue_id child_sid) FINAL OVERRIDE;\n-\n-  void on_cast (svalue_id src_sid,\n-\t\tsvalue_id dst_sid) FINAL OVERRIDE;\n-\n   void on_condition (tree lhs, enum tree_code op, tree rhs) FINAL OVERRIDE;\n \n-  void on_unknown_change (svalue_id sid ATTRIBUTE_UNUSED) FINAL OVERRIDE;\n+  void on_unknown_change (const svalue *sval, bool is_mutable) FINAL OVERRIDE;\n \n   void on_phi (const gphi *phi, tree rhs) FINAL OVERRIDE;\n \n@@ -85,7 +71,6 @@ class impl_region_model_context : public region_model_context\n   const exploded_node *m_enode_for_diag;\n   const program_state *m_old_state;\n   program_state *m_new_state;\n-  state_change *m_change;\n   const gimple *m_stmt;\n   stmt_finder *m_stmt_finder;\n   const extrinsic_state &m_ext_state;\n@@ -145,6 +130,9 @@ struct eg_traits\n   struct dump_args_t\n   {\n     dump_args_t (const exploded_graph &eg) : m_eg (eg) {}\n+\n+    bool show_enode_details_p (const exploded_node &enode) const;\n+\n     const exploded_graph &m_eg;\n   };\n   typedef exploded_cluster cluster_t;\n@@ -172,7 +160,7 @@ class exploded_node : public dnode<eg_traits>\n \n     /* Node was left unprocessed due to merger; it won't have had\n        exploded_graph::process_node called on it.  */\n-    STATUS_MERGER\n+    STATUS_MERGER,\n   };\n \n   exploded_node (const point_and_state &ps, int index);\n@@ -224,13 +212,11 @@ class exploded_node : public dnode<eg_traits>\n   on_stmt_flags on_stmt (exploded_graph &eg,\n \t\t\t const supernode *snode,\n \t\t\t const gimple *stmt,\n-\t\t\t program_state *state,\n-\t\t\t state_change *change) const;\n+\t\t\t program_state *state) const;\n   bool on_edge (exploded_graph &eg,\n \t\tconst superedge *succ,\n \t\tprogram_point *next_point,\n-\t\tprogram_state *next_state,\n-\t\tstate_change *change) const;\n+\t\tprogram_state *next_state) const;\n   void on_longjmp (exploded_graph &eg,\n \t\t   const gcall *call,\n \t\t   program_state *new_state,\n@@ -252,6 +238,7 @@ class exploded_node : public dnode<eg_traits>\n     return get_point ().get_stack_depth ();\n   }\n   const gimple *get_stmt () const { return get_point ().get_stmt (); }\n+  const gimple *get_processed_stmt (unsigned idx) const;\n \n   const program_state &get_state () const { return m_ps.get_state (); }\n \n@@ -279,6 +266,10 @@ class exploded_node : public dnode<eg_traits>\n public:\n   /* The index of this exploded_node.  */\n   const int m_index;\n+\n+  /* The number of stmts that were processed when process_node was\n+     called on this enode.  */\n+  unsigned m_num_processed_stmts;\n };\n \n /* An edge within the exploded graph.\n@@ -307,9 +298,7 @@ class exploded_edge : public dedge<eg_traits>\n   };\n \n   exploded_edge (exploded_node *src, exploded_node *dest,\n-\t\t const extrinsic_state &ext_state,\n \t\t const superedge *sedge,\n-\t\t const state_change &change,\n \t\t custom_info_t *custom_info);\n   ~exploded_edge ();\n   void dump_dot (graphviz_out *gv, const dump_args_t &args)\n@@ -318,8 +307,6 @@ class exploded_edge : public dedge<eg_traits>\n   //private:\n   const superedge *const m_sedge;\n \n-  const state_change m_change;\n-\n   /* NULL for most edges; will be non-NULL for special cases\n      such as an unwind from a longjmp to a setjmp, or when\n      a signal is delivered to a signal-handler.\n@@ -733,6 +720,7 @@ class exploded_graph : public digraph<eg_traits>\n \n   const supergraph &get_supergraph () const { return m_sg; }\n   const extrinsic_state &get_ext_state () const { return m_ext_state; }\n+  engine *get_engine () const { return m_ext_state.get_engine (); }\n   const state_purge_map *get_purge_map () const { return m_purge_map; }\n   const analysis_plan &get_analysis_plan () const { return m_plan; }\n \n@@ -746,14 +734,15 @@ class exploded_graph : public digraph<eg_traits>\n \n   exploded_node *get_or_create_node (const program_point &point,\n \t\t\t\t     const program_state &state,\n-\t\t\t\t     state_change *change);\n+\t\t\t\t     const exploded_node *enode_for_diag);\n   exploded_edge *add_edge (exploded_node *src, exploded_node *dest,\n \t\t\t   const superedge *sedge,\n-\t\t\t   const state_change &change,\n \t\t\t   exploded_edge::custom_info_t *custom = NULL);\n \n   per_program_point_data *\n   get_or_create_per_program_point_data (const program_point &);\n+  per_program_point_data *\n+  get_per_program_point_data (const program_point &) const;\n \n   per_call_string_data *\n   get_or_create_per_call_string_data (const call_string &);\n@@ -785,6 +774,8 @@ class exploded_graph : public digraph<eg_traits>\n   void dump_states_for_supernode (FILE *, const supernode *snode) const;\n   void dump_exploded_nodes () const;\n \n+  exploded_node *get_node_by_index (int idx) const;\n+\n   const call_string_data_map_t *get_per_call_string_data () const\n   { return &m_per_call_string_data; }\n \n@@ -857,6 +848,8 @@ class exploded_path\n   void dump () const;\n \n   bool feasible_p (logger *logger, feasibility_problem **out) const;\n+  bool feasible_p (logger *logger, feasibility_problem **out,\n+\t\t    engine *eng, const exploded_graph *eg) const;\n \n   auto_vec<const exploded_edge *> m_edges;\n };"}, {"sha": "2c0a4c42bf513a3d4744523ae08e8bbc3eb70cc2", "filename": "gcc/analyzer/program-point.cc", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fprogram-point.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fprogram-point.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-point.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"bitmap.h\"\n #include \"tristate.h\"\n #include \"selftest.h\"\n+#include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n #include \"analyzer/sm.h\"\n #include \"analyzer/program-state.h\"\n@@ -84,6 +85,22 @@ point_kind_to_string (enum point_kind pk)\n \n /* class function_point.  */\n \n+function_point::function_point (const supernode *supernode,\n+\t\t\t\tconst superedge *from_edge,\n+\t\t\t\tunsigned stmt_idx,\n+\t\t\t\tenum point_kind kind)\n+: m_supernode (supernode), m_from_edge (from_edge),\n+  m_stmt_idx (stmt_idx), m_kind (kind)\n+{\n+  if (from_edge)\n+    {\n+      gcc_checking_assert (m_kind == PK_BEFORE_SUPERNODE);\n+      gcc_checking_assert (from_edge->get_kind () == SUPEREDGE_CFG_EDGE);\n+    }\n+  if (stmt_idx)\n+    gcc_checking_assert (m_kind == PK_BEFORE_STMT);\n+}\n+\n /* Print this function_point to PP.  */\n \n void\n@@ -149,6 +166,17 @@ function_point::hash () const\n   return hstate.end ();\n }\n \n+/* Get the function at this point, if any.  */\n+\n+function *\n+function_point::get_function () const\n+{\n+  if (m_supernode)\n+    return m_supernode->m_fun;\n+  else\n+    return NULL;\n+}\n+\n /* Get the gimple stmt for this function_point, if any.  */\n \n const gimple *\n@@ -174,6 +202,26 @@ function_point::get_location () const\n   return UNKNOWN_LOCATION;\n }\n \n+/* Create a function_point representing the entrypoint of function FUN.  */\n+\n+function_point\n+function_point::from_function_entry (const supergraph &sg, function *fun)\n+{\n+  return before_supernode (sg.get_node_for_function_entry (fun), NULL);\n+}\n+\n+/* Create a function_point representing entering supernode SUPERNODE,\n+   having reached it via FROM_EDGE (which could be NULL).  */\n+\n+function_point\n+function_point::before_supernode (const supernode *supernode,\n+\t\t\t\t  const superedge *from_edge)\n+{\n+  if (from_edge && from_edge->get_kind () != SUPEREDGE_CFG_EDGE)\n+    from_edge = NULL;\n+  return function_point (supernode, from_edge, 0, PK_BEFORE_SUPERNODE);\n+}\n+\n /* A subclass of diagnostic_context for use by\n    program_point::print_source_line.  */\n \n@@ -468,6 +516,19 @@ function_point::cmp_within_supernode (const function_point &point_a,\n   return result;\n }\n \n+/* For PK_BEFORE_STMT, go to next stmt (or to PK_AFTER_SUPERNODE).  */\n+\n+void\n+function_point::next_stmt ()\n+{\n+  gcc_assert (m_kind == PK_BEFORE_STMT);\n+  if (++m_stmt_idx == m_supernode->m_stmts.length ())\n+    {\n+      m_kind = PK_AFTER_SUPERNODE;\n+      m_stmt_idx = 0;\n+    }\n+}\n+\n #if CHECKING_P\n \n namespace selftest {"}, {"sha": "cb11478468d2cc48fdee27d7a3f6d277f168ab6e", "filename": "gcc/analyzer/program-point.h", "status": "modified", "additions": 21, "deletions": 31, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fprogram-point.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fprogram-point.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-point.h?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -72,18 +72,7 @@ class function_point\n   function_point (const supernode *supernode,\n \t\t  const superedge *from_edge,\n \t\t  unsigned stmt_idx,\n-\t\t  enum point_kind kind)\n-  : m_supernode (supernode), m_from_edge (from_edge),\n-    m_stmt_idx (stmt_idx), m_kind (kind)\n-  {\n-    if (from_edge)\n-      {\n-\tgcc_checking_assert (m_kind == PK_BEFORE_SUPERNODE);\n-\tgcc_checking_assert (from_edge->get_kind () == SUPEREDGE_CFG_EDGE);\n-      }\n-    if (stmt_idx)\n-      gcc_checking_assert (m_kind == PK_BEFORE_STMT);\n-  }\n+\t\t  enum point_kind kind);\n \n   void print (pretty_printer *pp, const format &f) const;\n   void print_source_line (pretty_printer *pp) const;\n@@ -101,13 +90,7 @@ class function_point\n   /* Accessors.  */\n \n   const supernode *get_supernode () const { return m_supernode; }\n-  function *get_function () const\n-  {\n-    if (m_supernode)\n-      return m_supernode->m_fun;\n-    else\n-      return NULL;\n-  }\n+  function *get_function () const;\n   const gimple *get_stmt () const;\n   location_t get_location () const;\n   enum point_kind get_kind () const { return m_kind; }\n@@ -124,19 +107,10 @@ class function_point\n   /* Factory functions for making various kinds of program_point.  */\n \n   static function_point from_function_entry (const supergraph &sg,\n-\t\t\t\t\t    function *fun)\n-  {\n-    return before_supernode (sg.get_node_for_function_entry (fun),\n-\t\t\t     NULL);\n-  }\n+\t\t\t\t\t     function *fun);\n \n   static function_point before_supernode (const supernode *supernode,\n-\t\t\t\t\t  const superedge *from_edge)\n-  {\n-    if (from_edge && from_edge->get_kind () != SUPEREDGE_CFG_EDGE)\n-      from_edge = NULL;\n-    return function_point (supernode, from_edge, 0, PK_BEFORE_SUPERNODE);\n-  }\n+\t\t\t\t\t  const superedge *from_edge);\n \n   static function_point before_stmt (const supernode *supernode,\n \t\t\t\t     unsigned stmt_idx)\n@@ -165,6 +139,9 @@ class function_point\n   static int cmp_within_supernode (const function_point &point_a,\n \t\t\t\t   const function_point &point_b);\n \n+  /* For before_stmt, go to next stmt.  */\n+  void next_stmt ();\n+\n  private:\n   const supernode *m_supernode;\n \n@@ -204,6 +181,10 @@ class program_point\n     return (m_function_point == other.m_function_point\n \t    && m_call_string == other.m_call_string);\n   }\n+  bool operator!= (const program_point &other) const\n+  {\n+    return !(*this == other);\n+  }\n \n   /* Accessors.  */\n \n@@ -257,6 +238,12 @@ class program_point\n   }\n \n   /* Factory functions for making various kinds of program_point.  */\n+  static program_point origin ()\n+  {\n+    return program_point (function_point (NULL, NULL,\n+\t\t\t\t\t  0, PK_ORIGIN),\n+\t\t\t  call_string ());\n+  }\n \n   static program_point from_function_entry (const supergraph &sg,\n \t\t\t\t\t    function *fun)\n@@ -304,8 +291,11 @@ class program_point\n \n   void validate () const;\n \n+  /* For before_stmt, go to next stmt.  */\n+  void next_stmt () { m_function_point.next_stmt (); }\n+\n  private:\n-  const function_point m_function_point;\n+  function_point m_function_point;\n   call_string m_call_string;\n };\n "}, {"sha": "ede20a70ccae88ec494a5e713cfbb3a7ec81ec0d", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 490, "deletions": 781, "changes": 1271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -33,13 +33,15 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tristate.h\"\n #include \"ordered-hash-map.h\"\n #include \"selftest.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n #include \"analyzer/program-state.h\"\n #include \"analyzer/constraint-manager.h\"\n #include \"alloc-pool.h\"\n #include \"fibonacci_heap.h\"\n #include \"shortest-paths.h\"\n-#include \"analyzer/constraint-manager.h\"\n #include \"diagnostic-event-id.h\"\n #include \"analyzer/pending-diagnostic.h\"\n #include \"analyzer/diagnostic-manager.h\"\n@@ -50,8 +52,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"digraph.h\"\n #include \"analyzer/supergraph.h\"\n-#include \"analyzer/call-string.h\"\n-#include \"analyzer/program-point.h\"\n #include \"analyzer/program-state.h\"\n #include \"analyzer/exploded-graph.h\"\n #include \"analyzer/state-purge.h\"\n@@ -99,12 +99,23 @@ extrinsic_state::dump () const\n   dump_to_file (stderr);\n }\n \n+/* Get the region_model_manager for this extrinsic_state.  */\n+\n+region_model_manager *\n+extrinsic_state::get_model_manager () const\n+{\n+  if (m_engine)\n+    return m_engine->get_model_manager ();\n+  else\n+    return NULL; /* for selftests.  */\n+}\n+\n /* class sm_state_map.  */\n \n /* sm_state_map's ctor.  */\n \n-sm_state_map::sm_state_map ()\n-: m_map (), m_global_state (0)\n+sm_state_map::sm_state_map (const state_machine &sm, int sm_idx)\n+: m_sm (sm), m_sm_idx (sm_idx), m_map (), m_global_state (0)\n {\n }\n \n@@ -116,77 +127,56 @@ sm_state_map::clone () const\n   return new sm_state_map (*this);\n }\n \n-/* Clone this sm_state_map, remapping all svalue_ids within it with ID_MAP.\n-\n-   Return NULL if there are any svalue_ids that have sm-state for which\n-   ID_MAP maps them to svalue_id::null (and thus the clone would have lost\n-   the sm-state information). */\n-\n-sm_state_map *\n-sm_state_map::clone_with_remapping (const one_way_svalue_id_map &id_map) const\n-{\n-  sm_state_map *result = new sm_state_map ();\n-  result->m_global_state = m_global_state;\n-  for (map_t::iterator iter = m_map.begin ();\n-       iter != m_map.end ();\n-       ++iter)\n-    {\n-      svalue_id sid = (*iter).first;\n-      gcc_assert (!sid.null_p ());\n-      entry_t e = (*iter).second;\n-      /* TODO: what should we do if the origin maps from non-null to null?\n-\t Is that loss of information acceptable?  */\n-      id_map.update (&e.m_origin);\n-\n-      svalue_id new_sid = id_map.get_dst_for_src (sid);\n-      if (new_sid.null_p ())\n-\t{\n-\t  delete result;\n-\t  return NULL;\n-\t}\n-      result->m_map.put (new_sid, e);\n-    }\n-  return result;\n-}\n-\n-/* Print this sm_state_map (for SM) to PP.\n+/* Print this sm_state_map to PP.\n    If MODEL is non-NULL, print representative tree values where\n    available.  */\n \n void\n-sm_state_map::print (const state_machine &sm, const region_model *model,\n-\t\t     pretty_printer *pp) const\n+sm_state_map::print (const region_model *model,\n+\t\t      bool simple, bool multiline,\n+\t\t      pretty_printer *pp) const\n {\n   bool first = true;\n-  pp_string (pp, \"{\");\n+  if (!multiline)\n+    pp_string (pp, \"{\");\n   if (m_global_state != 0)\n     {\n-      pp_printf (pp, \"global: %s\", sm.get_state_name (m_global_state));\n+      if (multiline)\n+\tpp_string (pp, \"  \");\n+      pp_printf (pp, \"global: %s\", m_sm.get_state_name (m_global_state));\n+      if (multiline)\n+\tpp_newline (pp);\n       first = false;\n     }\n   for (map_t::iterator iter = m_map.begin ();\n        iter != m_map.end ();\n        ++iter)\n     {\n-      if (!first)\n+      if (multiline)\n+\tpp_string (pp, \"  \");\n+      else if (!first)\n \tpp_string (pp, \", \");\n       first = false;\n-      svalue_id sid = (*iter).first;\n-      sid.print (pp);\n+      const svalue *sval = (*iter).first;\n+      pp_pointer (pp, sval);\n+      pp_string (pp, \": \");\n+      sval->dump_to_pp (pp, simple);\n \n       entry_t e = (*iter).second;\n-      pp_printf (pp, \": %s\", sm.get_state_name (e.m_state));\n+      pp_printf (pp, \": %s\", m_sm.get_state_name (e.m_state));\n       if (model)\n-\tif (tree rep = model->get_representative_tree (sid))\n+\tif (tree rep = model->get_representative_tree (sval))\n \t  {\n \t    pp_string (pp, \" (\");\n \t    dump_quoted_tree (pp, rep);\n \t    pp_character (pp, ')');\n \t  }\n-      if (!e.m_origin.null_p ())\n+      if (e.m_origin)\n \t{\n \t  pp_string (pp, \" (origin: \");\n-\t  e.m_origin.print (pp);\n+\t  pp_pointer (pp, e.m_origin);\n+\t  pp_string (pp, \": \");\n+\t  e.m_origin->dump_to_pp (pp, simple);\n \t  if (model)\n \t    if (tree rep = model->get_representative_tree (e.m_origin))\n \t      {\n@@ -196,19 +186,22 @@ sm_state_map::print (const state_machine &sm, const region_model *model,\n \t      }\n \t  pp_string (pp, \")\");\n \t}\n+      if (multiline)\n+\tpp_newline (pp);\n     }\n-  pp_string (pp, \"}\");\n+  if (!multiline)\n+    pp_string (pp, \"}\");\n }\n \n-/* Dump this object (for SM) to stderr.  */\n+/* Dump this object to stderr.  */\n \n DEBUG_FUNCTION void\n-sm_state_map::dump (const state_machine &sm) const\n+sm_state_map::dump (bool simple) const\n {\n   pretty_printer pp;\n   pp_show_color (&pp) = pp_show_color (global_dc->printer);\n   pp.buffer->stream = stderr;\n-  print (sm, NULL, &pp);\n+  print (NULL, simple, true, &pp);\n   pp_newline (&pp);\n   pp_flush (&pp);\n }\n@@ -237,10 +230,10 @@ sm_state_map::hash () const\n        ++iter)\n     {\n       inchash::hash hstate;\n-      inchash::add ((*iter).first, hstate);\n+      hstate.add_ptr ((*iter).first);\n       entry_t e = (*iter).second;\n       hstate.add_int (e.m_state);\n-      inchash::add (e.m_origin, hstate);\n+      hstate.add_ptr (e.m_origin);\n       result ^= hstate.end ();\n     }\n   result ^= m_global_state;\n@@ -263,9 +256,9 @@ sm_state_map::operator== (const sm_state_map &other) const\n        iter != m_map.end ();\n        ++iter)\n     {\n-      svalue_id sid = (*iter).first;\n+      const svalue *sval = (*iter).first;\n       entry_t e = (*iter).second;\n-      entry_t *other_slot = const_cast <map_t &> (other.m_map).get (sid);\n+      entry_t *other_slot = const_cast <map_t &> (other.m_map).get (sval);\n       if (other_slot == NULL)\n \treturn false;\n       if (e != *other_slot)\n@@ -277,63 +270,85 @@ sm_state_map::operator== (const sm_state_map &other) const\n   return true;\n }\n \n-/* Get the state of SID within this object.\n+/* Get the state of SVAL within this object.\n    States default to the start state.  */\n \n state_machine::state_t\n-sm_state_map::get_state (svalue_id sid) const\n+sm_state_map::get_state (const svalue *sval,\n+\t\t\t  const extrinsic_state &ext_state) const\n {\n-  gcc_assert (!sid.null_p ());\n+  gcc_assert (sval);\n+\n+  sval = canonicalize_svalue (sval, ext_state);\n \n   if (entry_t *slot\n-      = const_cast <map_t &> (m_map).get (sid))\n+      = const_cast <map_t &> (m_map).get (sval))\n     return slot->m_state;\n-  else\n-    return 0;\n+\n+  /* SVAL has no explicit sm-state.\n+     If this sm allows for state inheritance, then SVAL might have implicit\n+     sm-state inherited via a parent.\n+     For example INIT_VAL(foo.field) might inherit taintedness state from\n+     INIT_VAL(foo).  */\n+  if (m_sm.inherited_state_p ())\n+    if (region_model_manager *mgr = ext_state.get_model_manager ())\n+      if (const initial_svalue *init_sval = sval->dyn_cast_initial_svalue ())\n+\t{\n+\t  const region *reg = init_sval->get_region ();\n+\t  /* Try recursing upwards (up to the base region for the cluster).  */\n+\t  if (!reg->base_region_p ())\n+\t    if (const region *parent_reg = reg->get_parent_region ())\n+\t      {\n+\t\tconst svalue *parent_init_sval\n+\t\t  = mgr->get_or_create_initial_value (parent_reg);\n+\t\tstate_machine::state_t parent_state\n+\t\t  = get_state (parent_init_sval, ext_state);\n+\t\tif (parent_state)\n+\t\t  return parent_state;\n+\t      }\n+\t}\n+\n+  return m_sm.get_default_state (sval);\n }\n \n-/* Get the \"origin\" svalue_id for any state of SID.  */\n+/* Get the \"origin\" svalue for any state of SVAL.  */\n \n-svalue_id\n-sm_state_map::get_origin (svalue_id sid) const\n+const svalue *\n+sm_state_map::get_origin (const svalue *sval,\n+\t\t\t   const extrinsic_state &ext_state) const\n {\n-  gcc_assert (!sid.null_p ());\n+  gcc_assert (sval);\n+\n+  sval = canonicalize_svalue (sval, ext_state);\n \n   entry_t *slot\n-    = const_cast <map_t &> (m_map).get (sid);\n+    = const_cast <map_t &> (m_map).get (sval);\n   if (slot)\n     return slot->m_origin;\n   else\n-    return svalue_id::null ();\n+    return NULL;\n }\n \n /* Set the state of SID within MODEL to STATE, recording that\n    the state came from ORIGIN.  */\n \n void\n sm_state_map::set_state (region_model *model,\n-\t\t\t svalue_id sid,\n+\t\t\t const svalue *sval,\n \t\t\t state_machine::state_t state,\n-\t\t\t svalue_id origin)\n+\t\t\t const svalue *origin,\n+\t\t\t const extrinsic_state &ext_state)\n {\n   if (model == NULL)\n     return;\n-  equiv_class &ec = model->get_constraints ()->get_equiv_class (sid);\n-  if (!set_state (ec, state, origin))\n-    return;\n \n-  /* Also do it for all svalues that are equal via non-cm, so that\n-     e.g. (void *)&r and (foo *)&r transition together.  */\n-  for (unsigned i = 0; i < model->get_num_svalues (); i++)\n-    {\n-      svalue_id other_sid = svalue_id::from_int (i);\n-      if (other_sid == sid)\n-\tcontinue;\n+  /* Reject attempts to set state on UNKNOWN.  */\n+  if (sval->get_kind () == SK_UNKNOWN)\n+    return;\n \n-      tristate eq = model->eval_condition_without_cm (sid, EQ_EXPR, other_sid);\n-      if (eq.is_true ())\n-\timpl_set_state (other_sid, state, origin);\n-    }\n+  equiv_class &ec = model->get_constraints ()->get_equiv_class (sval);\n+  if (!set_state (ec, state, origin, ext_state))\n+    return;\n }\n \n /* Set the state of EC to STATE, recording that the state came from\n@@ -343,35 +358,40 @@ sm_state_map::set_state (region_model *model,\n bool\n sm_state_map::set_state (const equiv_class &ec,\n \t\t\t state_machine::state_t state,\n-\t\t\t svalue_id origin)\n+\t\t\t const svalue *origin,\n+\t\t\t const extrinsic_state &ext_state)\n {\n   int i;\n-  svalue_id *sid;\n+  const svalue *sval;\n   bool any_changed = false;\n-  FOR_EACH_VEC_ELT (ec.m_vars, i, sid)\n-    any_changed |= impl_set_state (*sid, state, origin);\n+  FOR_EACH_VEC_ELT (ec.m_vars, i, sval)\n+    any_changed |= impl_set_state (sval, state, origin, ext_state);\n   return any_changed;\n }\n \n-/* Set state of SID to STATE, bypassing equivalence classes.\n+/* Set state of SVAL to STATE, bypassing equivalence classes.\n    Return true if the state changed.  */\n \n bool\n-sm_state_map::impl_set_state (svalue_id sid, state_machine::state_t state,\n-\t\t\t      svalue_id origin)\n+sm_state_map::impl_set_state (const svalue *sval,\n+\t\t\t      state_machine::state_t state,\n+\t\t\t      const svalue *origin,\n+\t\t\t      const extrinsic_state &ext_state)\n {\n-  if (get_state (sid) == state)\n+  sval = canonicalize_svalue (sval, ext_state);\n+\n+  if (get_state (sval, ext_state) == state)\n     return false;\n \n   /* Special-case state 0 as the default value.  */\n   if (state == 0)\n     {\n-      if (m_map.get (sid))\n-\tm_map.remove (sid);\n+      if (m_map.get (sval))\n+\tm_map.remove (sval);\n       return true;\n     }\n-  gcc_assert (!sid.null_p ());\n-  m_map.put (sid, entry_t (state, origin));\n+  gcc_assert (sval);\n+  m_map.put (sval, entry_t (state, origin));\n   return true;\n }\n \n@@ -391,217 +411,125 @@ sm_state_map::get_global_state () const\n   return m_global_state;\n }\n \n-/* Handle CALL to unknown FNDECL with an unknown function body, which\n-   could do anything to the states passed to it.\n-   Clear any state for SM for the params and any LHS.\n-   Note that the function might be known to other state machines, but\n-   not to this one.  */\n+/* Purge any state for SVAL.\n+   If !SM::can_purge_p, then report the state as leaking,\n+   using CTXT.  */\n \n void\n-sm_state_map::purge_for_unknown_fncall (const exploded_graph &eg,\n-\t\t\t\t\tconst state_machine &sm,\n-\t\t\t\t\tconst gcall *call,\n-\t\t\t\t\ttree fndecl,\n-\t\t\t\t\tregion_model *new_model,\n-\t\t\t\t\tregion_model_context *ctxt)\n+sm_state_map::on_svalue_leak (const svalue *sval,\n+\t\t\t      impl_region_model_context *ctxt)\n {\n-  logger * const logger = eg.get_logger ();\n-  if (logger)\n+  if (state_machine::state_t state = get_state (sval, ctxt->m_ext_state))\n     {\n-      if (fndecl)\n-\tlogger->log (\"function %qE is unknown to checker %qs\",\n-\t\t     fndecl, sm.get_name ());\n-      else\n-\tlogger->log (\"unknown function pointer for checker %qs\",\n-\t\t     sm.get_name ());\n-    }\n-\n-  /* Purge any state for parms.  */\n-  tree iter_param_types = NULL_TREE;\n-  if (fndecl)\n-    iter_param_types = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n-  for (unsigned arg_idx = 0; arg_idx < gimple_call_num_args (call); arg_idx++)\n-    {\n-      /* Track expected param type, where available.  */\n-      if (iter_param_types)\n-\t{\n-\t  tree param_type = TREE_VALUE (iter_param_types);\n-\t  gcc_assert (param_type);\n-\t  iter_param_types = TREE_CHAIN (iter_param_types);\n-\n-\t  /* Don't purge state if it was passed as a const pointer\n-\t     e.g. for things like strlen (PTR).  */\n-\t  if (TREE_CODE (param_type) == POINTER_TYPE)\n-\t    if (TYPE_READONLY (TREE_TYPE (param_type)))\n-\t      continue;\n-\t}\n-      tree parm = gimple_call_arg (call, arg_idx);\n-      svalue_id parm_sid = new_model->get_rvalue (parm, ctxt);\n-      set_state (new_model, parm_sid, 0, svalue_id::null ());\n-\n-      /* Also clear sm-state from svalue_ids that are passed via a\n-\t pointer.  */\n-      if (TREE_CODE (parm) == ADDR_EXPR)\n-\t{\n-\t  tree pointee = TREE_OPERAND (parm, 0);\n-\t  svalue_id parm_sid = new_model->get_rvalue (pointee, ctxt);\n-\t  set_state (new_model, parm_sid, 0, svalue_id::null ());\n-\t}\n-    }\n-\n-  /* Purge any state for any LHS.  */\n-  if (tree lhs = gimple_call_lhs (call))\n-    {\n-      svalue_id lhs_sid = new_model->get_rvalue (lhs, ctxt);\n-      set_state (new_model, lhs_sid, 0, svalue_id::null ());\n+      if (!m_sm.can_purge_p (state))\n+\tctxt->on_state_leak (m_sm, sval, state);\n+      m_map.remove (sval);\n     }\n }\n \n-/* Update this map based on MAP.  */\n+/* Purge any state for svalues that aren't live with respect to LIVE_SVALUES\n+   and MODEL.  */\n \n void\n-sm_state_map::remap_svalue_ids (const svalue_id_map &map)\n+sm_state_map::on_liveness_change (const svalue_set &live_svalues,\n+\t\t\t\t  const region_model *model,\n+\t\t\t\t  impl_region_model_context *ctxt)\n {\n-  map_t tmp_map;\n+  svalue_set svals_to_unset;\n \n-  /* Build an intermediate map, using the new sids.  */\n   for (map_t::iterator iter = m_map.begin ();\n        iter != m_map.end ();\n        ++iter)\n     {\n-      svalue_id sid = (*iter).first;\n-      entry_t e = (*iter).second;\n-\n-      map.update (&sid);\n-      map.update (&e.m_origin);\n-      tmp_map.put (sid, e);\n-    }\n-\n-  /* Clear the existing values.  */\n-  m_map.empty ();\n-\n-  /* Copy over from intermediate map.  */\n-  for (map_t::iterator iter = tmp_map.begin ();\n-       iter != tmp_map.end ();\n-       ++iter)\n-    {\n-      svalue_id sid = (*iter).first;\n-      entry_t e = (*iter).second;\n-\n-      impl_set_state (sid, e.m_state, e.m_origin);\n-    }\n-}\n-\n-/* Purge any state for svalue_ids >= FIRST_UNUSED_SID.\n-   If !SM::can_purge_p, then report the state as leaking,\n-   using SM_IDX, CTXT, and MAP.\n-   Return the number of states that were purged.  */\n-\n-int\n-sm_state_map::on_svalue_purge (const state_machine &sm,\n-\t\t\t       int sm_idx,\n-\t\t\t       svalue_id first_unused_sid,\n-\t\t\t       const svalue_id_map &map,\n-\t\t\t       impl_region_model_context *ctxt)\n-{\n-  /* TODO: ideally remove the slot directly; for now\n-     do it in two stages.  */\n-  auto_vec<svalue_id> to_remove;\n-  for (map_t::iterator iter = m_map.begin ();\n-       iter != m_map.end ();\n-       ++iter)\n-    {\n-      svalue_id dst_sid ((*iter).first);\n-      if (dst_sid.as_int () >= first_unused_sid.as_int ())\n+      const svalue *iter_sval = (*iter).first;\n+      if (!iter_sval->live_p (live_svalues, model))\n \t{\n-\t  /* Complain about leaks here.  */\n+\t  svals_to_unset.add (iter_sval);\n \t  entry_t e = (*iter).second;\n-\n-\t  if (!sm.can_purge_p (e.m_state))\n-\t    ctxt->on_state_leak (sm, sm_idx, dst_sid, first_unused_sid,\n-\t\t\t\t map, e.m_state);\n-\n-\t  to_remove.safe_push (dst_sid);\n-\t}\n-      else if ((*iter).second.m_origin.as_int () >= first_unused_sid.as_int ())\n-\t{\n-\t  /* If the origin svalue is being purged, then reset it to null.  */\n-\t  (*iter).second.m_origin = svalue_id::null ();\n+\t  if (!m_sm.can_purge_p (e.m_state))\n+\t    ctxt->on_state_leak (m_sm, iter_sval, e.m_state);\n \t}\n     }\n \n-  int i;\n-  svalue_id *dst_sid;\n-  FOR_EACH_VEC_ELT (to_remove, i, dst_sid)\n-    m_map.remove (*dst_sid);\n-\n-  return to_remove.length ();\n+  for (svalue_set::iterator iter = svals_to_unset.begin ();\n+       iter != svals_to_unset.end (); ++iter)\n+    m_map.remove (*iter);\n }\n \n-/* Set the state of CHILD_SID to that of PARENT_SID.  */\n+/* Purge state from SVAL (in response to a call to an unknown function).  */\n \n void\n-sm_state_map::on_inherited_svalue (svalue_id parent_sid,\n-\t\t\t\t   svalue_id child_sid)\n+sm_state_map::on_unknown_change (const svalue *sval,\n+\t\t\t\t bool is_mutable,\n+\t\t\t\t const extrinsic_state &ext_state)\n {\n-  state_machine::state_t state = get_state (parent_sid);\n-  impl_set_state (child_sid, state, parent_sid);\n-}\n-\n-/* Set the state of DST_SID to that of SRC_SID.  */\n-\n-void\n-sm_state_map::on_cast (svalue_id src_sid,\n-\t\t       svalue_id dst_sid)\n-{\n-  state_machine::state_t state = get_state (src_sid);\n-  impl_set_state (dst_sid, state, get_origin (src_sid));\n-}\n-\n-/* Purge state from SID (in response to a call to an unknown function).  */\n-\n-void\n-sm_state_map::on_unknown_change (svalue_id sid)\n-{\n-  impl_set_state (sid, (state_machine::state_t)0, svalue_id::null ());\n-}\n-\n-/* Assert that this object is sane.  */\n-\n-void\n-sm_state_map::validate (const state_machine &sm,\n-\t\t\tint num_svalues) const\n-{\n-  /* Skip this in a release build.  */\n-#if !CHECKING_P\n-  return;\n-#endif\n+  svalue_set svals_to_unset;\n \n   for (map_t::iterator iter = m_map.begin ();\n        iter != m_map.end ();\n        ++iter)\n     {\n-      svalue_id sid = (*iter).first;\n+      const svalue *key = (*iter).first;\n       entry_t e = (*iter).second;\n-\n-      gcc_assert (sid.as_int () < num_svalues);\n-      sm.validate (e.m_state);\n-      gcc_assert (e.m_origin.as_int () < num_svalues);\n+      /* We only want to purge state for some states when things\n+\t are mutable.  For example, in sm-malloc.cc, an on-stack ptr\n+\t doesn't stop being stack-allocated when passed to an unknown fn.  */\n+      if (!m_sm.reset_when_passed_to_unknown_fn_p (e.m_state, is_mutable))\n+\tcontinue;\n+      if (key == sval)\n+\tsvals_to_unset.add (key);\n+      /* If we have INIT_VAL(BASE_REG), then unset any INIT_VAL(REG)\n+\t for REG within BASE_REG.  */\n+      if (const initial_svalue *init_sval = sval->dyn_cast_initial_svalue ())\n+\tif (const initial_svalue *init_key = key->dyn_cast_initial_svalue ())\n+\t  {\n+\t    const region *changed_reg = init_sval->get_region ();\n+\t    const region *changed_key = init_key->get_region ();\n+\t    if (changed_key->get_base_region () == changed_reg)\n+\t      svals_to_unset.add (key);\n+\t  }\n     }\n+\n+  for (svalue_set::iterator iter = svals_to_unset.begin ();\n+       iter != svals_to_unset.end (); ++iter)\n+    impl_set_state (*iter, (state_machine::state_t)0, NULL, ext_state);\n+}\n+\n+/* Canonicalize SVAL before getting/setting it within the map.\n+   Convert all NULL pointers to (void *) to avoid state explosions\n+   involving all of the various (foo *)NULL vs (bar *)NULL.  */\n+\n+const svalue *\n+sm_state_map::canonicalize_svalue (const svalue *sval,\n+\t\t\t\t   const extrinsic_state &ext_state)\n+{\n+  region_model_manager *mgr = ext_state.get_model_manager ();\n+  if (mgr && sval->get_type () && POINTER_TYPE_P (sval->get_type ()))\n+    if (tree cst = sval->maybe_get_constant ())\n+      if (zerop (cst))\n+\treturn mgr->get_or_create_constant_svalue (null_pointer_node);\n+\n+  return sval;\n }\n \n /* class program_state.  */\n \n /* program_state's ctor.  */\n \n program_state::program_state (const extrinsic_state &ext_state)\n-: m_region_model (new region_model ()),\n+: m_region_model (NULL),\n   m_checker_states (ext_state.get_num_checkers ()),\n   m_valid (true)\n {\n-  int num_states = ext_state.get_num_checkers ();\n+  engine *eng = ext_state.get_engine ();\n+  region_model_manager *mgr = eng->get_model_manager ();\n+  m_region_model = new region_model (mgr);\n+  const int num_states = ext_state.get_num_checkers ();\n   for (int i = 0; i < num_states; i++)\n-    m_checker_states.quick_push (new sm_state_map ());\n+    {\n+      sm_state_map *sm = new sm_state_map (ext_state.get_sm (i), i);\n+      m_checker_states.quick_push (sm);\n+    }\n }\n \n /* program_state's copy ctor.  */\n@@ -708,7 +636,7 @@ program_state::print (const extrinsic_state &ext_state,\n \t\t      pretty_printer *pp) const\n {\n   pp_printf (pp, \"rmodel: \");\n-  m_region_model->print (pp);\n+  m_region_model->dump_to_pp (pp, true, false);\n   pp_newline (pp);\n \n   int i;\n@@ -718,7 +646,7 @@ program_state::print (const extrinsic_state &ext_state,\n       if (!smap->is_empty_p ())\n \t{\n \t  pp_printf (pp, \"%s: \", ext_state.get_name (i));\n-\t  smap->print (ext_state.get_sm (i), m_region_model, pp);\n+\t  smap->print (m_region_model, true, false, pp);\n \t  pp_newline (pp);\n \t}\n     }\n@@ -729,56 +657,68 @@ program_state::print (const extrinsic_state &ext_state,\n     }\n }\n \n-/* Dump a representation of this state to PP.\n-   If SUMMARIZE is true, print a one-line summary;\n-   if false, print a detailed multiline representation.  */\n+/* Dump a representation of this state to PP.  */\n \n void\n program_state::dump_to_pp (const extrinsic_state &ext_state,\n-\t\t\t   bool summarize,\n+\t\t\t   bool /*summarize*/, bool multiline,\n \t\t\t   pretty_printer *pp) const\n {\n-  pp_printf (pp, \"rmodel: \");\n-  m_region_model->dump_to_pp (pp, summarize);\n+  if (!multiline)\n+    pp_string (pp, \"{\");\n+  {\n+    pp_printf (pp, \"rmodel:\");\n+    if (multiline)\n+      pp_newline (pp);\n+    else\n+      pp_string (pp, \" {\");\n+    m_region_model->dump_to_pp (pp, true, multiline);\n+    if (!multiline)\n+      pp_string (pp, \"}\");\n+  }\n \n   int i;\n   sm_state_map *smap;\n   FOR_EACH_VEC_ELT (m_checker_states, i, smap)\n     {\n       if (!smap->is_empty_p ())\n \t{\n-\t  if (summarize)\n-\t    pp_space (pp);\n+\t  if (!multiline)\n+\t    pp_string (pp, \" {\");\n \t  pp_printf (pp, \"%s: \", ext_state.get_name (i));\n-\t  smap->print (ext_state.get_sm (i), m_region_model, pp);\n-\t  if (!summarize)\n+\t  if (multiline)\n \t    pp_newline (pp);\n+\t  smap->print (m_region_model, true, multiline, pp);\n+\t  if (!multiline)\n+\t    pp_string (pp, \"}\");\n \t}\n     }\n \n   if (!m_valid)\n     {\n-      if (summarize)\n+      if (!multiline)\n \tpp_space (pp);\n       pp_printf (pp, \"invalid state\");\n-      if (!summarize)\n+      if (multiline)\n \tpp_newline (pp);\n     }\n+  if (!multiline)\n+    pp_string (pp, \"}\");\n }\n \n-/* Dump a multiline representation of this state to OUTF.  */\n+/* Dump a representation of this state to OUTF.  */\n \n void\n program_state::dump_to_file (const extrinsic_state &ext_state,\n-\t\t\t     bool summarize,\n+\t\t\t     bool summarize, bool multiline,\n \t\t\t     FILE *outf) const\n {\n   pretty_printer pp;\n   pp_format_decoder (&pp) = default_tree_printer;\n   if (outf == stderr)\n     pp_show_color (&pp) = pp_show_color (global_dc->printer);\n   pp.buffer->stream = outf;\n-  dump_to_pp (ext_state, summarize, &pp);\n+  dump_to_pp (ext_state, summarize, multiline, &pp);\n   pp_flush (&pp);\n }\n \n@@ -788,7 +728,25 @@ DEBUG_FUNCTION void\n program_state::dump (const extrinsic_state &ext_state,\n \t\t     bool summarize) const\n {\n-  dump_to_file (ext_state, summarize, stderr);\n+  dump_to_file (ext_state, summarize, true, stderr);\n+}\n+\n+/* Update this program_state to reflect a top-level call to FUN.\n+   The params will have initial_svalues.  */\n+\n+void\n+program_state::push_frame (const extrinsic_state &ext_state ATTRIBUTE_UNUSED,\n+\t\t\t   function *fun)\n+{\n+  m_region_model->push_frame (fun, NULL, NULL);\n+}\n+\n+/* Get the current function of this state.  */\n+\n+function *\n+program_state::get_current_function () const\n+{\n+  return m_region_model->get_current_function ();\n }\n \n /* Determine if following edge SUCC from ENODE is valid within the graph EG\n@@ -806,8 +764,7 @@ program_state::dump (const extrinsic_state &ext_state,\n bool\n program_state::on_edge (exploded_graph &eg,\n \t\t\tconst exploded_node &enode,\n-\t\t\tconst superedge *succ,\n-\t\t\tstate_change *change)\n+\t\t\tconst superedge *succ)\n {\n   /* Update state.  */\n   const program_point &point = enode.get_point ();\n@@ -824,7 +781,7 @@ program_state::on_edge (exploded_graph &eg,\n \n   impl_region_model_context ctxt (eg, &enode,\n \t\t\t\t  &enode.get_state (),\n-\t\t\t\t  this, change,\n+\t\t\t\t  this,\n \t\t\t\t  last_stmt);\n   if (!m_region_model->maybe_update_for_edge (*succ,\n \t\t\t\t\t      last_stmt,\n@@ -838,22 +795,23 @@ program_state::on_edge (exploded_graph &eg,\n       return false;\n     }\n \n+  program_state::detect_leaks (enode.get_state (), *this,\n+\t\t\t\tNULL, eg.get_ext_state (),\n+\t\t\t\t&ctxt);\n+\n   return true;\n }\n \n /* Generate a simpler version of THIS, discarding state that's no longer\n    relevant at POINT.\n    The idea is that we're more likely to be able to consolidate\n    multiple (point, state) into single exploded_nodes if we discard\n-   irrelevant state (e.g. at the end of functions).\n-\n-   Retain state affected by CHANGE, to make it easier to generate\n-   state_change_events.  */\n+   irrelevant state (e.g. at the end of functions).  */\n \n program_state\n program_state::prune_for_point (exploded_graph &eg,\n \t\t\t\tconst program_point &point,\n-\t\t\t\tstate_change *change) const\n+\t\t\t\tconst exploded_node *enode_for_diag) const\n {\n   logger * const logger = eg.get_logger ();\n   LOG_SCOPE (logger);\n@@ -864,207 +822,110 @@ program_state::prune_for_point (exploded_graph &eg,\n \n   program_state new_state (*this);\n \n-  purge_stats stats;\n-\n   const state_purge_map *pm = eg.get_purge_map ();\n   if (pm)\n     {\n-      region_id_set purgeable_ssa_regions (new_state.m_region_model);\n-      region_id frame_rid\n-\t= new_state.m_region_model->get_current_frame_id ();\n-      frame_region *frame\n-\t= new_state.m_region_model->get_region <frame_region>(frame_rid);\n-\n-      /* TODO: maybe move to a member of region_model?  */\n-\n-      auto_vec<tree> ssa_names_to_purge;\n-      for (frame_region::map_t::iterator iter = frame->begin ();\n-\t   iter != frame->end ();\n-\t   ++iter)\n+      unsigned num_ssas_purged = 0;\n+      auto_vec<const decl_region *> ssa_name_regs;\n+      new_state.m_region_model->get_ssa_name_regions_for_current_frame\n+\t(&ssa_name_regs);\n+      unsigned i;\n+      const decl_region *reg;\n+      FOR_EACH_VEC_ELT (ssa_name_regs, i, reg)\n \t{\n-\t  tree var = (*iter).first;\n-\t  region_id rid = (*iter).second;\n-\t  if (TREE_CODE (var) == SSA_NAME)\n+\t  tree ssa_name = reg->get_decl ();\n+\t  const state_purge_per_ssa_name &per_ssa\n+\t    = pm->get_data_for_ssa_name (ssa_name);\n+\t  if (!per_ssa.needed_at_point_p (point.get_function_point ()))\n \t    {\n-\t      const state_purge_per_ssa_name &per_ssa\n-\t\t= pm->get_data_for_ssa_name (var);\n-\t      if (!per_ssa.needed_at_point_p (point.get_function_point ()))\n+\t      /* Don't purge bindings of SSA names to svalues\n+\t\t that have unpurgable sm-state, so that leaks are\n+\t\t reported at the end of the function, rather than\n+\t\t at the last place that such an SSA name is referred to.\n+\n+\t\t But do purge them for temporaries (when SSA_NAME_VAR is\n+\t\t NULL), so that we report for cases where a leak happens when\n+\t\t a variable is overwritten with another value, so that the leak\n+\t\t is reported at the point of overwrite, rather than having\n+\t\t temporaries keep the value reachable until the frame is\n+\t\t popped.  */\n+\t      const svalue *sval\n+\t\t= new_state.m_region_model->get_store_value (reg);\n+\t      if (!new_state.can_purge_p (eg.get_ext_state (), sval)\n+\t\t  && SSA_NAME_VAR (ssa_name))\n \t\t{\n-\t\t  region *region\n-\t\t    = new_state.m_region_model->get_region (rid);\n-\t\t  svalue_id sid = region->get_value_direct ();\n-\t\t  if (!sid.null_p ())\n-\t\t    {\n-\t\t      if (!new_state.can_purge_p (eg.get_ext_state (), sid))\n-\t\t\t{\n-\t\t\t  /* (currently only state maps can keep things\n-\t\t\t     alive).  */\n-\t\t\t  if (logger)\n-\t\t\t    logger->log (\"not purging RID: %i for %qE\"\n-\t\t\t\t\t \" (used by state map)\",\n-\t\t\t\t\t rid.as_int (), var);\n-\t\t\t  continue;\n-\t\t\t}\n-\n-\t\t      /* Don't purge regions containing svalues that\n-\t\t\t have a change of sm-state, to make it easier to\n-\t\t\t generate state_change_event messages.  */\n-\t\t      if (change)\n-\t\t\tif (change->affects_p (sid))\n-\t\t\t  {\n-\t\t\t    if (logger)\n-\t\t\t      logger->log (\"not purging RID: %i for %qE\"\n-\t\t\t\t\t   \" (affected by change)\",\n-\t\t\t\t\t   rid.as_int (), var);\n-\t\t\t    continue;\n-\t\t\t  }\n-\t\t    }\n-\t\t  purgeable_ssa_regions.add_region (rid);\n-\t\t  ssa_names_to_purge.safe_push (var);\n+\t\t  /* (currently only state maps can keep things\n+\t\t     alive).  */\n \t\t  if (logger)\n-\t\t    logger->log (\"purging RID: %i for %qE\", rid.as_int (), var);\n-\t\t  /* We also need to remove the region from the map.\n-\t\t     We're in mid-traversal, so the removal is done in\n-\t\t     unbind below.  */\n+\t\t    logger->log (\"not purging binding for %qE\"\n+\t\t\t\t \" (used by state map)\", ssa_name);\n+\t\t  continue;\n \t\t}\n+\n+\t      new_state.m_region_model->purge_region (reg);\n+\t      num_ssas_purged++;\n \t    }\n \t}\n \n-      /* Unbind the regions from the frame's map of vars-to-regions.  */\n-      unsigned i;\n-      tree var;\n-      FOR_EACH_VEC_ELT (ssa_names_to_purge, i, var)\n-\tframe->unbind (var);\n-\n-      /* Purge the regions.  Nothing should point to them, and they\n-\t should have no children, as they are for SSA names.  */\n-      new_state.m_region_model->purge_regions (purgeable_ssa_regions,\n-\t\t\t\t\t       &stats,\n-\t\t\t\t\t       eg.get_logger ());\n-    }\n-\n-  /* Purge unused svalues.  */\n-  // TODO: which enode to use, if any?\n-  impl_region_model_context ctxt (eg, NULL,\n-\t\t\t\t  this,\n-\t\t\t\t  &new_state,\n-\t\t\t\t  change,\n-\t\t\t\t  NULL);\n-  new_state.m_region_model->purge_unused_svalues (&stats, &ctxt);\n-  if (logger)\n-    {\n-      logger->log (\"num svalues purged: %i\", stats.m_num_svalues);\n-      logger->log (\"num regions purged: %i\", stats.m_num_regions);\n-      logger->log (\"num equiv_classes purged: %i\", stats.m_num_equiv_classes);\n-      logger->log (\"num constraints purged: %i\", stats.m_num_constraints);\n-      logger->log (\"num sm map items purged: %i\", stats.m_num_client_items);\n+      if (num_ssas_purged > 0)\n+\t{\n+\t  if (logger)\n+\t    logger->log (\"num_ssas_purged: %i\", num_ssas_purged);\n+\t  impl_region_model_context ctxt (eg, enode_for_diag,\n+\t\t\t\t\t  this,\n+\t\t\t\t\t  &new_state,\n+\t\t\t\t\t  point.get_stmt ());\n+\t  detect_leaks (*this, new_state, NULL, eg.get_ext_state (), &ctxt);\n+\t}\n     }\n \n-  new_state.m_region_model->canonicalize (&ctxt);\n+  new_state.m_region_model->canonicalize ();\n \n   return new_state;\n }\n \n-/* Remap all svalue_ids in this state's m_checker_states according to MAP.\n-   The svalues_ids in the region_model are assumed to already have been\n-   remapped.  */\n-\n-void\n-program_state::remap_svalue_ids (const svalue_id_map &map)\n-{\n-  int i;\n-  sm_state_map *smap;\n-  FOR_EACH_VEC_ELT (m_checker_states, i, smap)\n-    smap->remap_svalue_ids (map);\n-}\n-\n-/* Attempt to return a tree that represents SID, or return NULL_TREE.\n-   Find the first region that stores the value (e.g. a local) and\n-   generate a representative tree for it.  */\n+/* Get a representative tree to use for describing SVAL.  */\n \n tree\n-program_state::get_representative_tree (svalue_id sid) const\n+program_state::get_representative_tree (const svalue *sval) const\n {\n-  return m_region_model->get_representative_tree (sid);\n+  gcc_assert (m_region_model);\n+  return m_region_model->get_representative_tree (sval);\n }\n \n-/* Attempt to merge this state with OTHER, both using EXT_STATE.\n+/* Attempt to merge this state with OTHER, both at POINT.\n    Write the result to *OUT.\n    If the states were merged successfully, return true.  */\n \n bool\n program_state::can_merge_with_p (const program_state &other,\n-\t\t\t\t const extrinsic_state &ext_state,\n+\t\t\t\t const program_point &point,\n \t\t\t\t program_state *out) const\n {\n   gcc_assert (out);\n+  gcc_assert (m_region_model);\n \n-  /* TODO:  initially I had an early reject here if there\n-     are sm-differences between the states.  However, this was\n-     falsely rejecting merger opportunities for states where the\n-     only difference was in svalue_id ordering.  */\n+  /* Early reject if there are sm-differences between the states.  */\n+  int i;\n+  sm_state_map *smap;\n+  FOR_EACH_VEC_ELT (out->m_checker_states, i, smap)\n+    if (*m_checker_states[i] != *other.m_checker_states[i])\n+      return false;\n \n   /* Attempt to merge the region_models.  */\n-\n-  svalue_id_merger_mapping sid_mapping (*m_region_model,\n-\t\t\t\t\t*other.m_region_model);\n   if (!m_region_model->can_merge_with_p (*other.m_region_model,\n-\t\t\t\t\t out->m_region_model,\n-\t\t\t\t\t &sid_mapping))\n+\t\t\t\t\t  point,\n+\t\t\t\t\t  out->m_region_model))\n     return false;\n \n-  /* Copy m_checker_states to result, remapping svalue_ids using\n-     sid_mapping.  */\n-  int i;\n-  sm_state_map *smap;\n+  /* Copy m_checker_states to OUT.  */\n   FOR_EACH_VEC_ELT (out->m_checker_states, i, smap)\n-    delete smap;\n-  out->m_checker_states.truncate (0);\n-\n-  /* Remap this and other's m_checker_states using sid_mapping.\n-     Only merge states that have equality between the two end-results:\n-     sm-state differences are likely to be interesting to end-users, and\n-     hence are worth exploring as separate paths in the exploded graph.  */\n-  FOR_EACH_VEC_ELT (m_checker_states, i, smap)\n     {\n-      sm_state_map *other_smap = other.m_checker_states[i];\n-\n-      /* If clone_with_remapping returns NULL for one of the input smaps,\n-\t then it has sm-state for an svalue_id where the svalue_id is\n-\t being mapped to svalue_id::null in its sid_mapping, meaning that\n-\t the svalue is to be dropped during the merger.  We don't want\n-\t to lose sm-state during a state merger, so return false for these\n-\t cases.  */\n-      sm_state_map *remapped_a_smap\n-\t= smap->clone_with_remapping (sid_mapping.m_map_from_a_to_m);\n-      if (!remapped_a_smap)\n-\treturn false;\n-      sm_state_map *remapped_b_smap\n-\t= other_smap->clone_with_remapping (sid_mapping.m_map_from_b_to_m);\n-      if (!remapped_b_smap)\n-\t{\n-\t  delete remapped_a_smap;\n-\t  return false;\n-\t}\n-\n-      /* Both states have sm-state for the same values; now ensure that the\n-\t states are equal.  */\n-      if (*remapped_a_smap == *remapped_b_smap)\n-\t{\n-\t  out->m_checker_states.safe_push (remapped_a_smap);\n-\t  delete remapped_b_smap;\n-\t}\n-      else\n-\t{\n-\t  /* Don't merge if there are sm-state differences.  */\n-\t  delete remapped_a_smap;\n-\t  delete remapped_b_smap;\n-\t  return false;\n-\t}\n+      delete smap;\n+      out->m_checker_states[i] = m_checker_states[i]->clone ();\n     }\n \n-  impl_region_model_context ctxt (out, NULL, ext_state);\n-  out->m_region_model->canonicalize (&ctxt);\n+  out->m_region_model->canonicalize ();\n \n   return true;\n }\n@@ -1079,212 +940,107 @@ program_state::validate (const extrinsic_state &ext_state) const\n   return;\n #endif\n \n-  m_region_model->validate ();\n   gcc_assert (m_checker_states.length () == ext_state.get_num_checkers ());\n-  int sm_idx;\n-  sm_state_map *smap;\n-  FOR_EACH_VEC_ELT (m_checker_states, sm_idx, smap)\n-    {\n-      const state_machine &sm = ext_state.get_sm (sm_idx);\n-      smap->validate (sm, m_region_model->get_num_svalues ());\n-    }\n }\n \n-/* Dump this sm_change to PP.  */\n-\n-void\n-state_change::sm_change::dump (pretty_printer *pp,\n-\t\t\t       const extrinsic_state &ext_state) const\n-{\n-  const state_machine &sm = get_sm (ext_state);\n-  pp_string (pp, \"(\");\n-  m_new_sid.print (pp);\n-  pp_printf (pp, \": %s: %qs -> %qs)\",\n-\t     sm.get_name (),\n-\t     sm.get_state_name (m_old_state),\n-\t     sm.get_state_name (m_new_state));\n-}\n-\n-/* Remap all svalue_ids in this change according to MAP.  */\n-\n-void\n-state_change::sm_change::remap_svalue_ids (const svalue_id_map &map)\n-{\n-  map.update (&m_new_sid);\n-}\n-\n-/* Purge any svalue_ids >= FIRST_UNUSED_SID.\n-   Return the number of states that were purged.  */\n-\n-int\n-state_change::sm_change::on_svalue_purge (svalue_id first_unused_sid)\n+static void\n+log_set_of_svalues (logger *logger, const char *name,\n+\t\t     const svalue_set &set)\n {\n-  if (m_new_sid.as_int () >= first_unused_sid.as_int ())\n+  logger->log (name);\n+  logger->inc_indent ();\n+  for (svalue_set::iterator iter = set.begin ();\n+       iter != set.end (); ++iter)\n     {\n-      m_new_sid = svalue_id::null ();\n-      return 1;\n+      logger->start_log_line ();\n+      pretty_printer *pp = logger->get_printer ();\n+      const svalue *sval = (*iter);\n+      pp_pointer (pp, sval);\n+      pp_string (pp, \": \");\n+      sval->dump_to_pp (pp, false);\n+      logger->end_log_line ();\n     }\n-\n-  return 0;\n-}\n-\n-/* Assert that this object is sane.  */\n-\n-void\n-state_change::sm_change::validate (const program_state &new_state,\n-\t\t\t\t   const extrinsic_state &ext_state) const\n-{\n-  gcc_assert ((unsigned)m_sm_idx < ext_state.get_num_checkers ());\n-  const state_machine &sm = ext_state.get_sm (m_sm_idx);\n-  sm.validate (m_old_state);\n-  sm.validate (m_new_state);\n-  m_new_sid.validate (*new_state.m_region_model);\n-}\n-\n-/* state_change's ctor.  */\n-\n-state_change::state_change ()\n-{\n+  logger->dec_indent ();\n }\n \n-/* state_change's copy ctor.  */\n+/* Compare the sets of svalues reachable from each of SRC_STATE and DEST_STATE.\n+   For all svalues that are reachable in SRC_STATE and are not live in\n+   DEST_STATE (whether explicitly reachable in DEST_STATE, or implicitly live\n+   based on the former set), call CTXT->on_svalue_leak for them.\n \n-state_change::state_change (const state_change &other)\n-: m_sm_changes (other.m_sm_changes.length ())\n-{\n-  unsigned i;\n-  sm_change *change;\n-  FOR_EACH_VEC_ELT (other.m_sm_changes, i, change)\n-    m_sm_changes.quick_push (*change);\n-}\n+   Call on_liveness_change on both the CTXT and on the DEST_STATE's\n+   constraint_manager, purging dead svalues from sm-state and from\n+   constraints, respectively.\n \n-/* Record a state-machine state change.  */\n+   This function should be called at each fine-grained state change, not\n+   just at exploded edges.  */\n \n void\n-state_change::add_sm_change (int sm_idx,\n-\t\t\t     svalue_id new_sid,\n-\t\t\t     state_machine::state_t old_state,\n-\t\t\t     state_machine::state_t new_state)\n-{\n-  m_sm_changes.safe_push (sm_change (sm_idx,\n-\t\t\t\t     new_sid,\n-\t\t\t\t     old_state, new_state));\n-}\n-\n-/* Return true if SID (in the new state) was affected by any\n-   sm-state changes.  */\n-\n-bool\n-state_change::affects_p (svalue_id sid) const\n+program_state::detect_leaks (const program_state &src_state,\n+\t\t\t     const program_state &dest_state,\n+\t\t\t     const svalue *extra_sval,\n+\t\t\t     const extrinsic_state &ext_state,\n+\t\t\t     region_model_context *ctxt)\n {\n-  unsigned i;\n-  sm_change *change;\n-  FOR_EACH_VEC_ELT (m_sm_changes, i, change)\n+  logger *logger = ext_state.get_logger ();\n+  LOG_SCOPE (logger);\n+  if (logger)\n     {\n-      if (sid == change->m_new_sid)\n-\treturn true;\n+      pretty_printer *pp = logger->get_printer ();\n+      logger->start_log_line ();\n+      pp_string (pp, \"src_state: \");\n+      src_state.dump_to_pp (ext_state, true, false, pp);\n+      logger->end_log_line ();\n+      logger->start_log_line ();\n+      pp_string (pp, \"dest_state: \");\n+      dest_state.dump_to_pp (ext_state, true, false, pp);\n+      logger->end_log_line ();\n+      if (extra_sval)\n+\t{\n+\t  logger->start_log_line ();\n+\t  pp_string (pp, \"extra_sval: \");\n+\t  extra_sval->dump_to_pp (pp, true);\n+\t  logger->end_log_line ();\n+\t}\n     }\n-  return false;\n-}\n \n-/* Dump this state_change to PP.  */\n+  /* Get svalues reachable from each of src_state and dst_state.  */\n+  svalue_set src_svalues;\n+  svalue_set dest_svalues;\n+  src_state.m_region_model->get_reachable_svalues (&src_svalues, NULL);\n+  dest_state.m_region_model->get_reachable_svalues (&dest_svalues, extra_sval);\n \n-void\n-state_change::dump (pretty_printer *pp,\n-\t\t    const extrinsic_state &ext_state) const\n-{\n-  unsigned i;\n-  sm_change *change;\n-  FOR_EACH_VEC_ELT (m_sm_changes, i, change)\n+  if (logger)\n     {\n-      if (i > 0)\n-\tpp_string (pp, \", \");\n-      change->dump (pp, ext_state);\n+      log_set_of_svalues (logger, \"src_state reachable svalues:\", src_svalues);\n+      log_set_of_svalues (logger, \"dest_state reachable svalues:\",\n+\t\t\t  dest_svalues);\n     }\n-}\n-\n-/* Dump this state_change to stderr.  */\n \n-void\n-state_change::dump (const extrinsic_state &ext_state) const\n-{\n-  pretty_printer pp;\n-  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n-  pp.buffer->stream = stderr;\n-  dump (&pp, ext_state);\n-  pp_newline (&pp);\n-  pp_flush (&pp);\n-}\n-\n-/* Remap all svalue_ids in this state_change according to MAP.  */\n-\n-void\n-state_change::remap_svalue_ids (const svalue_id_map &map)\n-{\n-  unsigned i;\n-  sm_change *change;\n-  FOR_EACH_VEC_ELT (m_sm_changes, i, change)\n-    change->remap_svalue_ids (map);\n-}\n-\n-/* Purge any svalue_ids >= FIRST_UNUSED_SID.\n-   Return the number of states that were purged.  */\n-\n-int\n-state_change::on_svalue_purge (svalue_id first_unused_sid)\n-{\n-  int result = 0;\n-  unsigned i;\n-  sm_change *change;\n-  FOR_EACH_VEC_ELT (m_sm_changes, i, change)\n-    result += change->on_svalue_purge (first_unused_sid);\n-  return result;\n-}\n+  for (svalue_set::iterator iter = src_svalues.begin ();\n+       iter != src_svalues.end (); ++iter)\n+    {\n+      const svalue *sval = (*iter);\n+      /* For each sval reachable from SRC_STATE, determine if it is\n+\t live in DEST_STATE: either explicitly reachable, or implicitly\n+\t live based on the set of explicitly reachable svalues.\n+\t Call CTXT->on_svalue_leak on those that have ceased to be live.  */\n+      if (!sval->live_p (dest_svalues, dest_state.m_region_model))\n+\tctxt->on_svalue_leak (sval);\n+    }\n \n-/* Assert that this object is sane.  */\n+  /* Purge dead svals from sm-state.  */\n+  ctxt->on_liveness_change (dest_svalues, dest_state.m_region_model);\n \n-void\n-state_change::validate (const program_state &new_state,\n-\t\t\tconst extrinsic_state &ext_state) const\n-{\n-  /* Skip this in a release build.  */\n-#if !CHECKING_P\n-  return;\n-#endif\n-  unsigned i;\n-  sm_change *change;\n-  FOR_EACH_VEC_ELT (m_sm_changes, i, change)\n-    change->validate (new_state, ext_state);\n+  /* Purge dead svals from constraints.  */\n+  dest_state.m_region_model->get_constraints ()->on_liveness_change\n+    (dest_svalues, dest_state.m_region_model);\n }\n \n #if CHECKING_P\n \n namespace selftest {\n \n-/* Implementation detail of ASSERT_DUMP_EQ.  */\n-\n-static void\n-assert_dump_eq (const location &loc,\n-\t\tconst program_state &state,\n-\t\tconst extrinsic_state &ext_state,\n-\t\tbool summarize,\n-\t\tconst char *expected)\n-{\n-  auto_fix_quotes sentinel;\n-  pretty_printer pp;\n-  pp_format_decoder (&pp) = default_tree_printer;\n-  state.dump_to_pp (ext_state, summarize, &pp);\n-  ASSERT_STREQ_AT (loc, pp_formatted_text (&pp), expected);\n-}\n-\n-/* Assert that STATE.dump_to_pp (SUMMARIZE) is EXPECTED.  */\n-\n-#define ASSERT_DUMP_EQ(STATE, EXT_STATE, SUMMARIZE, EXPECTED)\t\t\\\n-  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t\\\n-  assert_dump_eq ((SELFTEST_LOCATION), (STATE), (EXT_STATE), (SUMMARIZE), \\\n-\t\t  (EXPECTED));\t\t\t\t\t\t\\\n-  SELFTEST_END_STMT\n-\n /* Tests for sm_state_map.  */\n \n static void\n@@ -1294,134 +1050,119 @@ test_sm_state_map ()\n   tree y = build_global_decl (\"y\", integer_type_node);\n   tree z = build_global_decl (\"z\", integer_type_node);\n \n+  state_machine *sm = make_malloc_state_machine (NULL);\n+  auto_delete_vec <state_machine> checkers;\n+  checkers.safe_push (sm);\n+  extrinsic_state ext_state (checkers);\n+\n   /* Test setting states on svalue_id instances directly.  */\n   {\n-    region_model model;\n-    svalue_id sid_x = model.get_rvalue (x, NULL);\n-    svalue_id sid_y = model.get_rvalue (y, NULL);\n-    svalue_id sid_z = model.get_rvalue (z, NULL);\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n+    const svalue *x_sval = model.get_rvalue (x, NULL);\n+    const svalue *y_sval = model.get_rvalue (y, NULL);\n+    const svalue *z_sval = model.get_rvalue (z, NULL);\n \n-    sm_state_map map;\n+    sm_state_map map (*sm, 0);\n     ASSERT_TRUE (map.is_empty_p ());\n-    ASSERT_EQ (map.get_state (sid_x), 0);\n+    ASSERT_EQ (map.get_state (x_sval, ext_state), 0);\n \n-    map.impl_set_state (sid_x, 42, sid_z);\n-    ASSERT_EQ (map.get_state (sid_x), 42);\n-    ASSERT_EQ (map.get_origin (sid_x), sid_z);\n-    ASSERT_EQ (map.get_state (sid_y), 0);\n+    map.impl_set_state (x_sval, 42, z_sval, ext_state);\n+    ASSERT_EQ (map.get_state (x_sval, ext_state), 42);\n+    ASSERT_EQ (map.get_origin (x_sval, ext_state), z_sval);\n+    ASSERT_EQ (map.get_state (y_sval, ext_state), 0);\n     ASSERT_FALSE (map.is_empty_p ());\n \n-    map.impl_set_state (sid_y, 0, sid_z);\n-    ASSERT_EQ (map.get_state (sid_y), 0);\n+    map.impl_set_state (y_sval, 0, z_sval, ext_state);\n+    ASSERT_EQ (map.get_state (y_sval, ext_state), 0);\n \n-    map.impl_set_state (sid_x, 0, sid_z);\n-    ASSERT_EQ (map.get_state (sid_x), 0);\n+    map.impl_set_state (x_sval, 0, z_sval, ext_state);\n+    ASSERT_EQ (map.get_state (x_sval, ext_state), 0);\n     ASSERT_TRUE (map.is_empty_p ());\n   }\n \n   /* Test setting states via equivalence classes.  */\n   {\n-    region_model model;\n-    svalue_id sid_x = model.get_rvalue (x, NULL);\n-    svalue_id sid_y = model.get_rvalue (y, NULL);\n-    svalue_id sid_z = model.get_rvalue (z, NULL);\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n+    const svalue *x_sval = model.get_rvalue (x, NULL);\n+    const svalue *y_sval = model.get_rvalue (y, NULL);\n+    const svalue *z_sval = model.get_rvalue (z, NULL);\n \n-    sm_state_map map;\n+    sm_state_map map (*sm, 0);\n     ASSERT_TRUE (map.is_empty_p ());\n-    ASSERT_EQ (map.get_state (sid_x), 0);\n-    ASSERT_EQ (map.get_state (sid_y), 0);\n+    ASSERT_EQ (map.get_state (x_sval, ext_state), 0);\n+    ASSERT_EQ (map.get_state (y_sval, ext_state), 0);\n \n     model.add_constraint (x, EQ_EXPR, y, NULL);\n \n     /* Setting x to a state should also update y, as they\n        are in the same equivalence class.  */\n-    map.set_state (&model, sid_x, 5, sid_z);\n-    ASSERT_EQ (map.get_state (sid_x), 5);\n-    ASSERT_EQ (map.get_state (sid_y), 5);\n-    ASSERT_EQ (map.get_origin (sid_x), sid_z);\n-    ASSERT_EQ (map.get_origin (sid_y), sid_z);\n+    map.set_state (&model, x_sval, 5, z_sval, ext_state);\n+    ASSERT_EQ (map.get_state (x_sval, ext_state), 5);\n+    ASSERT_EQ (map.get_state (y_sval, ext_state), 5);\n+    ASSERT_EQ (map.get_origin (x_sval, ext_state), z_sval);\n+    ASSERT_EQ (map.get_origin (y_sval, ext_state), z_sval);\n   }\n \n   /* Test equality and hashing.  */\n   {\n-    region_model model;\n-    svalue_id sid_y = model.get_rvalue (y, NULL);\n-    svalue_id sid_z = model.get_rvalue (z, NULL);\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n+    const svalue *y_sval = model.get_rvalue (y, NULL);\n+    const svalue *z_sval = model.get_rvalue (z, NULL);\n \n-    sm_state_map map0;\n-    sm_state_map map1;\n-    sm_state_map map2;\n+    sm_state_map map0 (*sm, 0);\n+    sm_state_map map1 (*sm, 0);\n+    sm_state_map map2 (*sm, 0);\n \n     ASSERT_EQ (map0.hash (), map1.hash ());\n     ASSERT_EQ (map0, map1);\n \n-    map1.impl_set_state (sid_y, 5, sid_z);\n+    map1.impl_set_state (y_sval, 5, z_sval, ext_state);\n     ASSERT_NE (map0.hash (), map1.hash ());\n     ASSERT_NE (map0, map1);\n \n     /* Make the same change to map2.  */\n-    map2.impl_set_state (sid_y, 5, sid_z);\n+    map2.impl_set_state (y_sval, 5, z_sval, ext_state);\n     ASSERT_EQ (map1.hash (), map2.hash ());\n     ASSERT_EQ (map1, map2);\n   }\n \n   /* Equality and hashing shouldn't depend on ordering.  */\n   {\n-    sm_state_map map0;\n-    sm_state_map map1;\n-    sm_state_map map2;\n+    sm_state_map map0 (*sm, 0);\n+    sm_state_map map1 (*sm, 0);\n+    sm_state_map map2 (*sm, 0);\n \n     ASSERT_EQ (map0.hash (), map1.hash ());\n     ASSERT_EQ (map0, map1);\n \n-    map1.impl_set_state (svalue_id::from_int (14), 2, svalue_id::null ());\n-    map1.impl_set_state (svalue_id::from_int (16), 3, svalue_id::null ());\n-    map1.impl_set_state (svalue_id::from_int (1), 2, svalue_id::null ());\n-    map1.impl_set_state (svalue_id::from_int (9), 2, svalue_id::null ());\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n+    const svalue *x_sval = model.get_rvalue (x, NULL);\n+    const svalue *y_sval = model.get_rvalue (y, NULL);\n+    const svalue *z_sval = model.get_rvalue (z, NULL);\n \n-    map2.impl_set_state (svalue_id::from_int (1), 2, svalue_id::null ());\n-    map2.impl_set_state (svalue_id::from_int (16), 3, svalue_id::null ());\n-    map2.impl_set_state (svalue_id::from_int (14), 2, svalue_id::null ());\n-    map2.impl_set_state (svalue_id::from_int (9), 2, svalue_id::null ());\n+    map1.impl_set_state (x_sval, 2, NULL, ext_state);\n+    map1.impl_set_state (y_sval, 3, NULL, ext_state);\n+    map1.impl_set_state (z_sval, 2, NULL, ext_state);\n+\n+    map2.impl_set_state (z_sval, 2, NULL, ext_state);\n+    map2.impl_set_state (y_sval, 3, NULL, ext_state);\n+    map2.impl_set_state (x_sval, 2, NULL, ext_state);\n \n     ASSERT_EQ (map1.hash (), map2.hash ());\n     ASSERT_EQ (map1, map2);\n   }\n \n-  /* Test sm_state_map::remap_svalue_ids.  */\n-  {\n-    sm_state_map map;\n-    svalue_id sid_0 = svalue_id::from_int (0);\n-    svalue_id sid_1 = svalue_id::from_int (1);\n-    svalue_id sid_2 = svalue_id::from_int (2);\n-\n-    map.impl_set_state (sid_0, 42, sid_2);\n-    ASSERT_EQ (map.get_state (sid_0), 42);\n-    ASSERT_EQ (map.get_origin (sid_0), sid_2);\n-    ASSERT_EQ (map.get_state (sid_1), 0);\n-    ASSERT_EQ (map.get_state (sid_2), 0);\n-\n-    /* Apply a remapping to the IDs.  */\n-    svalue_id_map remapping (3);\n-    remapping.put (sid_0, sid_1);\n-    remapping.put (sid_1, sid_2);\n-    remapping.put (sid_2, sid_0);\n-    map.remap_svalue_ids (remapping);\n-\n-    /* Verify that the IDs have been remapped.  */\n-    ASSERT_EQ (map.get_state (sid_1), 42);\n-    ASSERT_EQ (map.get_origin (sid_1), sid_0);\n-    ASSERT_EQ (map.get_state (sid_2), 0);\n-    ASSERT_EQ (map.get_state (sid_0), 0);\n-  }\n-\n   // TODO: coverage for purging\n }\n \n-/* Verify that program_state::dump_to_pp works as expected.  */\n+/* Check program_state works as expected.  */\n \n static void\n-test_program_state_dumping ()\n+test_program_state_1 ()\n {\n   /* Create a program_state for a global ptr \"p\" that has\n      malloc sm-state, pointing to a region on the heap.  */\n@@ -1432,83 +1173,44 @@ test_program_state_dumping ()\n     = sm->get_state_by_name (\"unchecked\");\n   auto_delete_vec <state_machine> checkers;\n   checkers.safe_push (sm);\n-  extrinsic_state ext_state (checkers);\n \n+  engine eng;\n+  extrinsic_state ext_state (checkers, NULL, &eng);\n+  region_model_manager *mgr = eng.get_model_manager ();\n   program_state s (ext_state);\n   region_model *model = s.m_region_model;\n-  region_id new_rid = model->add_new_malloc_region ();\n-  svalue_id ptr_sid\n-      = model->get_or_create_ptr_svalue (ptr_type_node, new_rid);\n+  const svalue *size_in_bytes\n+    = mgr->get_or_create_unknown_svalue (integer_type_node);\n+  const region *new_reg = model->create_region_for_heap_alloc (size_in_bytes);\n+  const svalue *ptr_sval = mgr->get_ptr_svalue (ptr_type_node, new_reg);\n   model->set_value (model->get_lvalue (p, NULL),\n-\t\t    ptr_sid, NULL);\n+\t\t    ptr_sval, NULL);\n   sm_state_map *smap = s.m_checker_states[0];\n \n-  smap->impl_set_state (ptr_sid, UNCHECKED_STATE, svalue_id::null ());\n-  ASSERT_EQ (smap->get_state (ptr_sid), UNCHECKED_STATE);\n-\n-  ASSERT_DUMP_EQ\n-    (s, ext_state, false,\n-     \"rmodel: r0: {kind: `root', parent: null, sval: null}\\n\"\n-     \"|-heap: r1: {kind: `heap', parent: r0, sval: null}\\n\"\n-     \"|  `-r2: {kind: `symbolic', parent: r1, sval: null, possibly_null: true}\\n\"\n-     \"`-globals: r3: {kind: `globals', parent: r0, sval: null, map: {`p': r4}}\\n\"\n-     \"  `-`p': r4: {kind: `primitive', parent: r3, sval: sv0, type: `void *'}\\n\"\n-     \"    |: sval: sv0: {type: `void *', &r2}\\n\"\n-     \"    |: type: `void *'\\n\"\n-     \"svalues:\\n\"\n-     \"  sv0: {type: `void *', &r2}\\n\"\n-     \"constraint manager:\\n\"\n-     \"  equiv classes:\\n\"\n-     \"  constraints:\\n\"\n-     \"malloc: {sv0: unchecked (`p')}\\n\");\n-\n-  ASSERT_DUMP_EQ (s, ext_state, true,\n-\t\t  \"rmodel: p: &r2 malloc: {sv0: unchecked (`p')}\");\n+  smap->impl_set_state (ptr_sval, UNCHECKED_STATE, NULL, ext_state);\n+  ASSERT_EQ (smap->get_state (ptr_sval, ext_state), UNCHECKED_STATE);\n }\n \n-/* Verify that program_state::dump_to_pp works for string literals.  */\n+/* Check that program_state works for string literals.  */\n \n static void\n-test_program_state_dumping_2 ()\n+test_program_state_2 ()\n {\n-    /* Create a program_state for a global ptr \"p\" that points to\n-       a string constant.  */\n+  /* Create a program_state for a global ptr \"p\" that points to\n+     a string constant.  */\n   tree p = build_global_decl (\"p\", ptr_type_node);\n \n   tree string_cst_ptr = build_string_literal (4, \"foo\");\n \n   auto_delete_vec <state_machine> checkers;\n-  extrinsic_state ext_state (checkers);\n+  engine eng;\n+  extrinsic_state ext_state (checkers, NULL, &eng);\n \n   program_state s (ext_state);\n   region_model *model = s.m_region_model;\n-  region_id p_rid = model->get_lvalue (p, NULL);\n-  svalue_id str_sid = model->get_rvalue (string_cst_ptr, NULL);\n-  model->set_value (p_rid, str_sid, NULL);\n-\n-  ASSERT_DUMP_EQ\n-    (s, ext_state, false,\n-     \"rmodel: r0: {kind: `root', parent: null, sval: null}\\n\"\n-     \"|-globals: r1: {kind: `globals', parent: r0, sval: null, map: {`p': r2}}\\n\"\n-     \"|  `-`p': r2: {kind: `primitive', parent: r1, sval: sv3, type: `void *'}\\n\"\n-     \"|    |: sval: sv3: {type: `void *', &r4}\\n\"\n-     \"|    |: type: `void *'\\n\"\n-     \"`-r3: {kind: `array', parent: r0, sval: sv0, type: `const char[4]', array: {[0]: r4}}\\n\"\n-     \"  |: sval: sv0: {type: `const char[4]', `\\\"foo\\\"'}\\n\"\n-     \"  |: type: `const char[4]'\\n\"\n-     \"  `-[0]: r4: {kind: `primitive', parent: r3, sval: null, type: `const char'}\\n\"\n-     \"    |: type: `const char'\\n\"\n-     \"svalues:\\n\"\n-     \"  sv0: {type: `const char[4]', `\\\"foo\\\"'}\\n\"\n-     \"  sv1: {type: `int', `0'}\\n\"\n-     \"  sv2: {type: `const char *', &r4}\\n\"\n-     \"  sv3: {type: `void *', &r4}\\n\"\n-     \"constraint manager:\\n\"\n-     \"  equiv classes:\\n\"\n-     \"  constraints:\\n\");\n-\n-  ASSERT_DUMP_EQ (s, ext_state, true,\n-\t\t  \"rmodel: p: &\\\"foo\\\"[0]\");\n+  const region *p_reg = model->get_lvalue (p, NULL);\n+  const svalue *str_sval = model->get_rvalue (string_cst_ptr, NULL);\n+  model->set_value (p_reg, str_sval, NULL);\n }\n \n /* Verify that program_states with identical sm-state can be merged,\n@@ -1521,28 +1223,33 @@ test_program_state_merging ()\n      malloc sm-state, pointing to a region on the heap.  */\n   tree p = build_global_decl (\"p\", ptr_type_node);\n \n+  program_point point (program_point::origin ());\n   auto_delete_vec <state_machine> checkers;\n   checkers.safe_push (make_malloc_state_machine (NULL));\n-  extrinsic_state ext_state (checkers);\n+  engine eng;\n+  extrinsic_state ext_state (checkers, NULL, &eng);\n+  region_model_manager *mgr = eng.get_model_manager ();\n \n   program_state s0 (ext_state);\n-  impl_region_model_context ctxt (&s0, NULL, ext_state);\n+  impl_region_model_context ctxt (&s0, ext_state);\n \n   region_model *model0 = s0.m_region_model;\n-  region_id new_rid = model0->add_new_malloc_region ();\n-  svalue_id ptr_sid\n-      = model0->get_or_create_ptr_svalue (ptr_type_node, new_rid);\n+  const svalue *size_in_bytes\n+    = mgr->get_or_create_unknown_svalue (integer_type_node);\n+  const region *new_reg = model0->create_region_for_heap_alloc (size_in_bytes);\n+  const svalue *ptr_sval = mgr->get_ptr_svalue (ptr_type_node, new_reg);\n   model0->set_value (model0->get_lvalue (p, &ctxt),\n-\t\t     ptr_sid, &ctxt);\n+\t\t     ptr_sval, &ctxt);\n   sm_state_map *smap = s0.m_checker_states[0];\n   const state_machine::state_t TEST_STATE = 3;\n-  smap->impl_set_state (ptr_sid, TEST_STATE, svalue_id::null ());\n-  ASSERT_EQ (smap->get_state (ptr_sid), TEST_STATE);\n+  smap->impl_set_state (ptr_sval, TEST_STATE, NULL, ext_state);\n+  ASSERT_EQ (smap->get_state (ptr_sval, ext_state), TEST_STATE);\n \n-  model0->canonicalize (&ctxt);\n+  model0->canonicalize ();\n \n   /* Verify that canonicalization preserves sm-state.  */\n-  ASSERT_EQ (smap->get_state (model0->get_rvalue (p, NULL)), TEST_STATE);\n+  ASSERT_EQ (smap->get_state (model0->get_rvalue (p, NULL), ext_state),\n+\t     TEST_STATE);\n \n   /* Make a copy of the program_state.  */\n   program_state s1 (s0);\n@@ -1552,22 +1259,23 @@ test_program_state_merging ()\n      with the given sm-state.\n      They ought to be mergeable, preserving the sm-state.  */\n   program_state merged (ext_state);\n-  ASSERT_TRUE (s0.can_merge_with_p (s1, ext_state, &merged));\n+  ASSERT_TRUE (s0.can_merge_with_p (s1, point, &merged));\n   merged.validate (ext_state);\n \n   /* Verify that the merged state has the sm-state for \"p\".  */\n   region_model *merged_model = merged.m_region_model;\n   sm_state_map *merged_smap = merged.m_checker_states[0];\n-  ASSERT_EQ (merged_smap->get_state (merged_model->get_rvalue (p, NULL)),\n+  ASSERT_EQ (merged_smap->get_state (merged_model->get_rvalue (p, NULL),\n+\t\t\t\t     ext_state),\n \t     TEST_STATE);\n \n   /* Try canonicalizing.  */\n-  impl_region_model_context merged_ctxt (&merged, NULL, ext_state);\n-  merged.m_region_model->canonicalize (&merged_ctxt);\n+  merged.m_region_model->canonicalize ();\n   merged.validate (ext_state);\n \n   /* Verify that the merged state still has the sm-state for \"p\".  */\n-  ASSERT_EQ (merged_smap->get_state (merged_model->get_rvalue (p, NULL)),\n+  ASSERT_EQ (merged_smap->get_state (merged_model->get_rvalue (p, NULL),\n+\t\t\t\t     ext_state),\n \t     TEST_STATE);\n \n   /* After canonicalization, we ought to have equality with the inputs.  */\n@@ -1580,6 +1288,7 @@ test_program_state_merging ()\n static void\n test_program_state_merging_2 ()\n {\n+  program_point point (program_point::origin ());\n   auto_delete_vec <state_machine> checkers;\n   checkers.safe_push (make_signal_state_machine (NULL));\n   extrinsic_state ext_state (checkers);\n@@ -1604,7 +1313,7 @@ test_program_state_merging_2 ()\n \n   /* They ought to not be mergeable.  */\n   program_state merged (ext_state);\n-  ASSERT_FALSE (s0.can_merge_with_p (s1, ext_state, &merged));\n+  ASSERT_FALSE (s0.can_merge_with_p (s1, point, &merged));\n }\n \n /* Run all of the selftests within this file.  */\n@@ -1613,8 +1322,8 @@ void\n analyzer_program_state_cc_tests ()\n {\n   test_sm_state_map ();\n-  test_program_state_dumping ();\n-  test_program_state_dumping_2 ();\n+  test_program_state_1 ();\n+  test_program_state_2 ();\n   test_program_state_merging ();\n   test_program_state_merging_2 ();\n }"}, {"sha": "cb0df8cd9044a895d222b93d80881e6b60d278bf", "filename": "gcc/analyzer/program-state.h", "status": "modified", "additions": 69, "deletions": 171, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fprogram-state.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fprogram-state.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.h?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -28,8 +28,10 @@ namespace ana {\n class extrinsic_state\n {\n public:\n-  extrinsic_state (auto_delete_vec <state_machine> &checkers)\n-  : m_checkers (checkers)\n+  extrinsic_state (auto_delete_vec <state_machine> &checkers,\n+\t\t   logger *logger = NULL,\n+\t\t   engine *eng = NULL)\n+  : m_checkers (checkers), m_logger (logger), m_engine (eng)\n   {\n   }\n \n@@ -45,65 +47,24 @@ class extrinsic_state\n \n   unsigned get_num_checkers () const { return m_checkers.length (); }\n \n+  logger *get_logger () const { return m_logger; }\n+\n   void dump_to_pp (pretty_printer *pp) const;\n   void dump_to_file (FILE *outf) const;\n   void dump () const;\n \n+  engine *get_engine () const { return m_engine; }\n+  region_model_manager *get_model_manager () const;\n+\n private:\n   /* The state machines.  */\n   auto_delete_vec <state_machine> &m_checkers;\n-};\n \n-} // namespace ana\n-\n-template <> struct default_hash_traits<svalue_id>\n-: public pod_hash_traits<svalue_id>\n-{\n-  static const bool empty_zero_p = false;\n+  logger *m_logger;\n+  engine *m_engine;\n };\n \n-template <>\n-inline hashval_t\n-pod_hash_traits<svalue_id>::hash (value_type v)\n-{\n-  return v.as_int ();\n-}\n-\n-template <>\n-inline bool\n-pod_hash_traits<svalue_id>::equal (const value_type &existing,\n-\t\t\t\t   const value_type &candidate)\n-{\n-  return existing == candidate;\n-}\n-template <>\n-inline void\n-pod_hash_traits<svalue_id>::mark_deleted (value_type &v)\n-{\n-  v = svalue_id::from_int (-2);\n-}\n-template <>\n-inline void\n-pod_hash_traits<svalue_id>::mark_empty (value_type &v)\n-{\n-  v = svalue_id::null ();\n-}\n-template <>\n-inline bool\n-pod_hash_traits<svalue_id>::is_deleted (value_type v)\n-{\n-  return v.as_int () == -2;\n-}\n-template <>\n-inline bool\n-pod_hash_traits<svalue_id>::is_empty (value_type v)\n-{\n-  return v.null_p ();\n-}\n-\n-namespace ana {\n-\n-/* Map from svalue_id to state machine state, also capturing the origin of\n+/* Map from svalue * to state machine state, also capturing the origin of\n    each state.  */\n \n class sm_state_map\n@@ -114,12 +75,12 @@ class sm_state_map\n   {\n     /* Default ctor needed by hash_map::empty.  */\n     entry_t ()\n-    : m_state (0), m_origin (svalue_id::null ())\n+    : m_state (0), m_origin (NULL)\n     {\n     }\n \n     entry_t (state_machine::state_t state,\n-\t     svalue_id origin)\n+\t     const svalue *origin)\n     : m_state (state), m_origin (origin)\n     {}\n \n@@ -134,21 +95,19 @@ class sm_state_map\n     }\n \n     state_machine::state_t m_state;\n-    svalue_id m_origin;\n+    const svalue *m_origin;\n   };\n-  typedef hash_map <svalue_id, entry_t> map_t;\n+  typedef hash_map <const svalue *, entry_t> map_t;\n   typedef map_t::iterator iterator_t;\n \n-  sm_state_map ();\n+  sm_state_map (const state_machine &sm, int m_sm_idx);\n \n   sm_state_map *clone () const;\n \n-  sm_state_map *\n-  clone_with_remapping (const one_way_svalue_id_map &id_map) const;\n-\n-  void print (const state_machine &sm, const region_model *model,\n+  void print (const region_model *model,\n+\t      bool simple, bool multiline,\n \t      pretty_printer *pp) const;\n-  void dump (const state_machine &sm) const;\n+  void dump (bool simple) const;\n \n   bool is_empty_p () const;\n \n@@ -160,51 +119,47 @@ class sm_state_map\n     return !(*this == other);\n   }\n \n-  state_machine::state_t get_state (svalue_id sid) const;\n-  svalue_id get_origin (svalue_id sid) const;\n+  state_machine::state_t get_state (const svalue *sval,\n+\t\t\t\t    const extrinsic_state &ext_state) const;\n+  const svalue *get_origin (const svalue *sval,\n+\t\t\t    const extrinsic_state &ext_state) const;\n \n   void set_state (region_model *model,\n-\t\t  svalue_id sid,\n+\t\t  const svalue *sval,\n \t\t  state_machine::state_t state,\n-\t\t  svalue_id origin);\n+\t\t  const svalue *origin,\n+\t\t  const extrinsic_state &ext_state);\n   bool set_state (const equiv_class &ec,\n \t\t  state_machine::state_t state,\n-\t\t  svalue_id origin);\n-  bool impl_set_state (svalue_id sid,\n+\t\t  const svalue *origin,\n+\t\t  const extrinsic_state &ext_state);\n+  bool impl_set_state (const svalue *sval,\n \t\t       state_machine::state_t state,\n-\t\t       svalue_id origin);\n+\t\t       const svalue *origin,\n+\t\t       const extrinsic_state &ext_state);\n \n   void set_global_state (state_machine::state_t state);\n   state_machine::state_t get_global_state () const;\n \n-  void purge_for_unknown_fncall (const exploded_graph &eg,\n-\t\t\t\t const state_machine &sm,\n-\t\t\t\t const gcall *call, tree fndecl,\n-\t\t\t\t region_model *new_model,\n-\t\t\t\t region_model_context *ctxt);\n-\n-  void remap_svalue_ids (const svalue_id_map &map);\n-\n-  int on_svalue_purge (const state_machine &sm,\n-\t\t       int sm_idx,\n-\t\t       svalue_id first_unused_sid,\n-\t\t       const svalue_id_map &map,\n+  void on_svalue_leak (const svalue *sval,\n \t\t       impl_region_model_context *ctxt);\n+  void on_liveness_change (const svalue_set &live_svalues,\n+\t\t\t   const region_model *model,\n+\t\t\t   impl_region_model_context *ctxt);\n \n-  void on_inherited_svalue (svalue_id parent_sid,\n-\t\t\t    svalue_id child_sid);\n-\n-  void on_cast (svalue_id src_sid,\n-\t\tsvalue_id dst_sid);\n-\n-  void on_unknown_change (svalue_id sid);\n-\n-  void validate (const state_machine &sm, int num_svalues) const;\n+  void on_unknown_change (const svalue *sval,\n+\t\t\t  bool is_mutable,\n+\t\t\t  const extrinsic_state &ext_state);\n \n   iterator_t begin () const { return m_map.begin (); }\n   iterator_t end () const { return m_map.end (); }\n \n+  static const svalue *\n+  canonicalize_svalue (const svalue *sval, const extrinsic_state &ext_state);\n+\n private:\n+  const state_machine &m_sm;\n+  int m_sm_idx;\n   map_t m_map;\n   state_machine::state_t m_global_state;\n };\n@@ -229,7 +184,6 @@ class program_state\n \n #if __cplusplus >= 201103\n   program_state (program_state &&other);\n-  program_state& operator= (program_state &&other); // doesn't seem to be used\n #endif\n \n   ~program_state ();\n@@ -244,27 +198,27 @@ class program_state\n   void print (const extrinsic_state &ext_state,\n \t      pretty_printer *pp) const;\n \n-  void dump_to_pp (const extrinsic_state &ext_state, bool summarize,\n-\t\t   pretty_printer *pp) const;\n-  void dump_to_file (const extrinsic_state &ext_state, bool summarize,\n-\t\t     FILE *outf) const;\n-  void dump (const extrinsic_state &ext_state, bool summarize) const;\n+  void dump_to_pp (const extrinsic_state &ext_state, bool simple,\n+\t\t   bool multiline, pretty_printer *pp) const;\n+  void dump_to_file (const extrinsic_state &ext_state, bool simple,\n+\t\t     bool multiline, FILE *outf) const;\n+  void dump (const extrinsic_state &ext_state, bool simple) const;\n+\n+  void push_frame (const extrinsic_state &ext_state, function *fun);\n+  function * get_current_function () const;\n \n   bool on_edge (exploded_graph &eg,\n \t\tconst exploded_node &enode,\n-\t\tconst superedge *succ,\n-\t\tstate_change *change);\n+\t\tconst superedge *succ);\n \n   program_state prune_for_point (exploded_graph &eg,\n \t\t\t\t const program_point &point,\n-\t\t\t\t state_change *change) const;\n+\t\t\t\t const exploded_node *enode_for_diag) const;\n \n-  void remap_svalue_ids (const svalue_id_map &map);\n-\n-  tree get_representative_tree (svalue_id sid) const;\n+  tree get_representative_tree (const svalue *sval) const;\n \n   bool can_purge_p (const extrinsic_state &ext_state,\n-\t\t    svalue_id sid)\n+\t\t    const svalue *sval)\n   {\n     /* Don't purge vars that have non-purgeable sm state, to avoid\n        generating false \"leak\" complaints.  */\n@@ -273,18 +227,24 @@ class program_state\n     FOR_EACH_VEC_ELT (m_checker_states, i, smap)\n       {\n \tconst state_machine &sm = ext_state.get_sm (i);\n-\tif (!sm.can_purge_p (smap->get_state (sid)))\n+\tif (!sm.can_purge_p (smap->get_state (sval, ext_state)))\n \t  return false;\n       }\n     return true;\n   }\n \n   bool can_merge_with_p (const program_state &other,\n-\t\t\t const extrinsic_state &ext_state,\n+\t\t\t const program_point &point,\n \t\t\t program_state *out) const;\n \n   void validate (const extrinsic_state &ext_state) const;\n \n+  static void detect_leaks (const program_state &src_state,\n+\t\t\t    const program_state &dest_state,\n+\t\t\t    const svalue *extra_sval,\n+\t\t\t    const extrinsic_state &ext_state,\n+\t\t\t    region_model_context *ctxt);\n+\n   /* TODO: lose the pointer here (const-correctness issues?).  */\n   region_model *m_region_model;\n   auto_delete_vec<sm_state_map> m_checker_states;\n@@ -311,76 +271,14 @@ class state_change_visitor\n   virtual bool on_state_change (const state_machine &sm,\n \t\t\t\tstate_machine::state_t src_sm_val,\n \t\t\t\tstate_machine::state_t dst_sm_val,\n-\t\t\t\ttree dst_rep,\n-\t\t\t\tsvalue_id dst_origin_sid) = 0;\n+\t\t\t\tconst svalue *dst_sval,\n+\t\t\t\tconst svalue *dst_origin_sval) = 0;\n };\n \n extern bool for_each_state_change (const program_state &src_state,\n-\t\t\t\t   const program_state &dst_state,\n-\t\t\t\t   const extrinsic_state &ext_state,\n-\t\t\t\t   state_change_visitor *visitor);\n-\n-/* A class for recording \"interesting\" state changes.\n-   This is used for annotating edges in the GraphViz output of the\n-   exploded_graph, and for recording sm-state-changes, so that\n-   values that change aren't purged (to make it easier to generate\n-   state_change_event instances in the diagnostic_path).  */\n-\n-class state_change\n-{\n- public:\n-  struct sm_change\n-  {\n-    sm_change (int sm_idx,\n-\t       svalue_id new_sid,\n-\t       state_machine::state_t old_state,\n-\t       state_machine::state_t new_state)\n-    : m_sm_idx (sm_idx),\n-      m_new_sid (new_sid),\n-      m_old_state (old_state), m_new_state (new_state)\n-    {}\n-\n-    const state_machine &get_sm (const extrinsic_state &ext_state) const\n-    {\n-      return ext_state.get_sm (m_sm_idx);\n-    }\n-\n-    void dump (pretty_printer *pp, const extrinsic_state &ext_state) const;\n-\n-    void remap_svalue_ids (const svalue_id_map &map);\n-    int on_svalue_purge (svalue_id first_unused_sid);\n-\n-    void validate (const program_state &new_state,\n-\t\t   const extrinsic_state &ext_state) const;\n-\n-    int m_sm_idx;\n-    svalue_id m_new_sid;\n-    state_machine::state_t m_old_state;\n-    state_machine::state_t m_new_state;\n-  };\n-\n-  state_change ();\n-  state_change (const state_change &other);\n-\n-  void add_sm_change (int sm_idx,\n-\t\t      svalue_id new_sid,\n-\t\t      state_machine::state_t old_state,\n-\t\t      state_machine::state_t new_state);\n-\n-  bool affects_p (svalue_id sid) const;\n-\n-  void dump (pretty_printer *pp, const extrinsic_state &ext_state) const;\n-  void dump (const extrinsic_state &ext_state) const;\n-\n-  void remap_svalue_ids (const svalue_id_map &map);\n-  int on_svalue_purge (svalue_id first_unused_sid);\n-\n-  void validate (const program_state &new_state,\n-\t\t const extrinsic_state &ext_state) const;\n-\n- private:\n-  auto_vec<sm_change> m_sm_changes;\n-};\n+\t\t\t\t    const program_state &dst_state,\n+\t\t\t\t    const extrinsic_state &ext_state,\n+\t\t\t\t    state_change_visitor *visitor);\n \n } // namespace ana\n "}, {"sha": "27c8ae54bd6e643912fe7729212f7ad54c484ca1", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "added", "additions": 352, "deletions": 0, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,352 @@\n+/* Handling for the known behavior of various specific functions.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"diagnostic-core.h\"\n+#include \"graphviz.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"tree-dfa.h\"\n+#include \"stringpool.h\"\n+#include \"convert.h\"\n+#include \"target.h\"\n+#include \"fold-const.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"diagnostic-color.h\"\n+#include \"diagnostic-metadata.h\"\n+#include \"tristate.h\"\n+#include \"bitmap.h\"\n+#include \"selftest.h\"\n+#include \"function.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"cfg.h\"\n+#include \"digraph.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"sbitmap.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"gimple-pretty-print.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* class call_details.  */\n+\n+/* call_details's ctor.  */\n+\n+call_details::call_details (const gcall *call, region_model *model,\n+\t\t\t    region_model_context *ctxt)\n+: m_call (call), m_model (model), m_ctxt (ctxt),\n+  m_lhs_type (NULL_TREE), m_lhs_region (NULL)\n+{\n+  m_lhs_type = NULL_TREE;\n+  if (tree lhs = gimple_call_lhs (call))\n+    {\n+      m_lhs_region = model->get_lvalue (lhs, ctxt);\n+      m_lhs_type = TREE_TYPE (lhs);\n+    }\n+}\n+\n+/* If the callsite has a left-hand-side region, set it to RESULT\n+   and return true.\n+   Otherwise do nothing and return false.  */\n+\n+bool\n+call_details::maybe_set_lhs (const svalue *result) const\n+{\n+  gcc_assert (result);\n+  if (m_lhs_region)\n+    {\n+      m_model->set_value (m_lhs_region, result, m_ctxt);\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n+/* Get argument IDX at the callsite as a tree.  */\n+\n+tree\n+call_details::get_arg_tree (unsigned idx) const\n+{\n+  return gimple_call_arg (m_call, idx);\n+}\n+\n+/* Get argument IDX at the callsite as an svalue.  */\n+\n+const svalue *\n+call_details::get_arg_svalue (unsigned idx) const\n+{\n+  tree arg = get_arg_tree (idx);\n+  return m_model->get_rvalue (arg, m_ctxt);\n+}\n+\n+/* Dump a multiline representation of this call to PP.  */\n+\n+void\n+call_details::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  pp_string (pp, \"gcall: \");\n+  pp_gimple_stmt_1 (pp, m_call, 0 /* spc */, TDF_NONE /* flags */);\n+  pp_newline (pp);\n+  pp_string (pp, \"return region: \");\n+  if (m_lhs_region)\n+    m_lhs_region->dump_to_pp (pp, simple);\n+  else\n+    pp_string (pp, \"NULL\");\n+  pp_newline (pp);\n+  for (unsigned i = 0; i < gimple_call_num_args (m_call); i++)\n+    {\n+      const svalue *arg_sval = get_arg_svalue (i);\n+      pp_printf (pp, \"arg %i: \", i);\n+      arg_sval->dump_to_pp (pp, simple);\n+      pp_newline (pp);\n+    }\n+}\n+\n+/* Dump a multiline representation of this call to stderr.  */\n+\n+DEBUG_FUNCTION void\n+call_details::dump (bool simple) const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = stderr;\n+  dump_to_pp (&pp, simple);\n+  pp_flush (&pp);\n+}\n+\n+/* Implementations of specific functions.  */\n+\n+/* Handle the on_call_pre part of \"alloca\".  */\n+\n+bool\n+region_model::impl_call_alloca (const call_details &cd)\n+{\n+  const svalue *size_sval = cd.get_arg_svalue (0);\n+  const region *new_reg = create_region_for_alloca (size_sval);\n+  const svalue *ptr_sval\n+    = m_mgr->get_ptr_svalue (cd.get_lhs_type (), new_reg);\n+  cd.maybe_set_lhs (ptr_sval);\n+  return true;\n+}\n+\n+/* Handle a call to \"__analyzer_describe\".\n+\n+   Emit a warning describing the 2nd argument (which can be of any\n+   type), at the given verbosity level.  This is for use when\n+   debugging, and may be of use in DejaGnu tests.  */\n+\n+void\n+region_model::impl_call_analyzer_describe (const gcall *call,\n+\t\t\t\t\t   region_model_context *ctxt)\n+{\n+  tree t_verbosity = gimple_call_arg (call, 0);\n+  tree t_val = gimple_call_arg (call, 1);\n+  const svalue *sval = get_rvalue (t_val, ctxt);\n+  bool simple = zerop (t_verbosity);\n+  label_text desc = sval->get_desc (simple);\n+  warning_at (call->location, 0, \"svalue: %qs\", desc.m_buffer);\n+}\n+\n+/* Handle a call to \"__analyzer_eval\" by evaluating the input\n+   and dumping as a dummy warning, so that test cases can use\n+   dg-warning to validate the result (and so unexpected warnings will\n+   lead to DejaGnu failures).\n+   Broken out as a subroutine to make it easier to put a breakpoint on it\n+   - though typically this doesn't help, as we have an SSA name as the arg,\n+   and what's more interesting is usually the def stmt for that name.  */\n+\n+void\n+region_model::impl_call_analyzer_eval (const gcall *call,\n+\t\t\t\t       region_model_context *ctxt)\n+{\n+  tree t_arg = gimple_call_arg (call, 0);\n+  tristate t = eval_condition (t_arg, NE_EXPR, integer_zero_node, ctxt);\n+  warning_at (call->location, 0, \"%s\", t.as_string ());\n+}\n+\n+/* Handle the on_call_pre part of \"__builtin_expect\" etc.  */\n+\n+bool\n+region_model::impl_call_builtin_expect (const call_details &cd)\n+{\n+  /* __builtin_expect's return value is its initial argument.  */\n+  const svalue *sval = cd.get_arg_svalue (0);\n+  cd.maybe_set_lhs (sval);\n+  return false;\n+}\n+\n+/* Handle the on_call_pre part of \"calloc\".  */\n+\n+bool\n+region_model::impl_call_calloc (const call_details &cd)\n+{\n+  const svalue *nmemb_sval = cd.get_arg_svalue (0);\n+  const svalue *size_sval = cd.get_arg_svalue (1);\n+  /* TODO: check for overflow here?  */\n+  const svalue *prod_sval\n+    = m_mgr->get_or_create_binop (size_type_node, MULT_EXPR,\n+\t\t\t\t  nmemb_sval, size_sval);\n+  const region *new_reg = create_region_for_heap_alloc (prod_sval);\n+  zero_fill_region (new_reg);\n+  if (cd.get_lhs_type ())\n+    {\n+      const svalue *ptr_sval\n+\t= m_mgr->get_ptr_svalue (cd.get_lhs_type (), new_reg);\n+      cd.maybe_set_lhs (ptr_sval);\n+    }\n+  return true;\n+}\n+\n+/* Handle the on_call_post part of \"free\", after sm-handling.\n+\n+   If the ptr points to an underlying heap region, delete the region,\n+   poisoning pointers to it and regions within it.\n+\n+   We delay this until after sm-state has been updated so that the\n+   sm-handling can transition all of the various casts of the pointer\n+   to a \"freed\" state *before* we delete the related region here.\n+\n+   This has to be done here so that the sm-handling can use the fact\n+   that they point to the same region to establish that they are equal\n+   (in region_model::eval_condition_without_cm), and thus transition\n+   all pointers to the region to the \"freed\" state together, regardless\n+   of casts.  */\n+\n+void\n+region_model::impl_call_free (const call_details &cd)\n+{\n+  const svalue *ptr_sval = cd.get_arg_svalue (0);\n+  if (const region_svalue *ptr_to_region_sval\n+      = ptr_sval->dyn_cast_region_svalue ())\n+    {\n+      /* If the ptr points to an underlying heap region, delete it,\n+\t poisoning pointers.  */\n+      const region *freed_reg = ptr_to_region_sval->get_pointee ();\n+      unbind_region_and_descendents (freed_reg, POISON_KIND_FREED);\n+    }\n+}\n+\n+/* Handle the on_call_pre part of \"malloc\".  */\n+\n+bool\n+region_model::impl_call_malloc (const call_details &cd)\n+{\n+  const svalue *size_sval = cd.get_arg_svalue (0);\n+  const region *new_reg = create_region_for_heap_alloc (size_sval);\n+  if (cd.get_lhs_type ())\n+    {\n+      const svalue *ptr_sval\n+\t= m_mgr->get_ptr_svalue (cd.get_lhs_type (), new_reg);\n+      cd.maybe_set_lhs (ptr_sval);\n+    }\n+  return true;\n+}\n+\n+/* Handle the on_call_pre part of \"memset\" and \"__builtin_memset\".  */\n+\n+bool\n+region_model::impl_call_memset (const call_details &cd)\n+{\n+  const svalue *dest_sval = cd.get_arg_svalue (0);\n+  const svalue *fill_value_sval = cd.get_arg_svalue (1);\n+  const svalue *num_bytes_sval = cd.get_arg_svalue (2);\n+\n+  const region *dest_reg = deref_rvalue (dest_sval, cd.get_arg_tree (0),\n+\t\t\t\t\t  cd.get_ctxt ());\n+\n+  if (tree num_bytes = num_bytes_sval->maybe_get_constant ())\n+    {\n+      /* \"memset\" of zero size is a no-op.  */\n+      if (zerop (num_bytes))\n+\treturn true;\n+\n+      /* Set with known amount.  */\n+      byte_size_t reg_size;\n+      if (dest_reg->get_byte_size (&reg_size))\n+\t{\n+\t  /* Check for an exact size match.  */\n+\t  if (reg_size == wi::to_offset (num_bytes))\n+\t    {\n+\t      if (tree cst = fill_value_sval->maybe_get_constant ())\n+\t\t{\n+\t\t  if (zerop (cst))\n+\t\t    {\n+\t\t      zero_fill_region (dest_reg);\n+\t\t      return true;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  /* Otherwise, mark region's contents as unknown.  */\n+  mark_region_as_unknown (dest_reg);\n+  return false;\n+}\n+\n+/* Handle the on_call_pre part of \"strlen\".\n+   Return true if the LHS is updated.  */\n+\n+bool\n+region_model::impl_call_strlen (const call_details &cd)\n+{\n+  region_model_context *ctxt = cd.get_ctxt ();\n+  const svalue *arg_sval = cd.get_arg_svalue (0);\n+  const region *buf_reg = deref_rvalue (arg_sval, cd.get_arg_tree (0), ctxt);\n+  if (const string_region *str_reg\n+      = buf_reg->dyn_cast_string_region ())\n+    {\n+      tree str_cst = str_reg->get_string_cst ();\n+      /* TREE_STRING_LENGTH is sizeof, not strlen.  */\n+      int sizeof_cst = TREE_STRING_LENGTH (str_cst);\n+      int strlen_cst = sizeof_cst - 1;\n+      if (cd.get_lhs_type ())\n+\t{\n+\t  tree t_cst = build_int_cst (cd.get_lhs_type (), strlen_cst);\n+\t  const svalue *result_sval\n+\t    = m_mgr->get_or_create_constant_svalue (t_cst);\n+\t  cd.maybe_set_lhs (result_sval);\n+\t  return true;\n+\t}\n+    }\n+  /* Otherwise an unknown value.  */\n+  return true;\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "9c7b0602e88cac5fc10c25281d1af557911f6cb7", "filename": "gcc/analyzer/region-model-manager.cc", "status": "added", "additions": 1088, "deletions": 0, "changes": 1088, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fregion-model-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fregion-model-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,1088 @@\n+/* Consolidation of svalues and regions.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"diagnostic-core.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"diagnostic-core.h\"\n+#include \"graphviz.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"tree-dfa.h\"\n+#include \"stringpool.h\"\n+#include \"convert.h\"\n+#include \"target.h\"\n+#include \"fold-const.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"tristate.h\"\n+#include \"bitmap.h\"\n+#include \"selftest.h\"\n+#include \"function.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"cfg.h\"\n+#include \"digraph.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"sbitmap.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/region-model.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* class region_model_manager.  */\n+\n+/* region_model_manager's ctor.  */\n+\n+region_model_manager::region_model_manager ()\n+: m_next_region_id (0),\n+  m_root_region (alloc_region_id ()),\n+  m_stack_region (alloc_region_id (), &m_root_region),\n+  m_heap_region (alloc_region_id (), &m_root_region),\n+  m_unknown_NULL (NULL),\n+  m_max_complexity (0, 0),\n+  m_code_region (alloc_region_id (), &m_root_region),\n+  m_fndecls_map (), m_labels_map (),\n+  m_globals_region (alloc_region_id (), &m_root_region),\n+  m_globals_map (),\n+  m_store_mgr (this)\n+{\n+}\n+\n+/* region_model_manager's dtor.  Delete all of the managed svalues\n+   and regions.  */\n+\n+region_model_manager::~region_model_manager ()\n+{\n+  /* Delete consolidated svalues.  */\n+  for (constants_map_t::iterator iter = m_constants_map.begin ();\n+       iter != m_constants_map.end (); ++iter)\n+    delete (*iter).second;\n+  for (unknowns_map_t::iterator iter = m_unknowns_map.begin ();\n+       iter != m_unknowns_map.end (); ++iter)\n+    delete (*iter).second;\n+  delete m_unknown_NULL;\n+  for (setjmp_values_map_t::iterator iter = m_setjmp_values_map.begin ();\n+       iter != m_setjmp_values_map.end (); ++iter)\n+    delete (*iter).second;\n+  for (poisoned_values_map_t::iterator iter = m_poisoned_values_map.begin ();\n+       iter != m_poisoned_values_map.end (); ++iter)\n+    delete (*iter).second;\n+  for (initial_values_map_t::iterator iter = m_initial_values_map.begin ();\n+       iter != m_initial_values_map.end (); ++iter)\n+    delete (*iter).second;\n+  for (pointer_values_map_t::iterator iter = m_pointer_values_map.begin ();\n+       iter != m_pointer_values_map.end (); ++iter)\n+    delete (*iter).second;\n+  for (unaryop_values_map_t::iterator iter = m_unaryop_values_map.begin ();\n+       iter != m_unaryop_values_map.end (); ++iter)\n+    delete (*iter).second;\n+  for (binop_values_map_t::iterator iter = m_binop_values_map.begin ();\n+       iter != m_binop_values_map.end (); ++iter)\n+    delete (*iter).second;\n+  for (sub_values_map_t::iterator iter = m_sub_values_map.begin ();\n+       iter != m_sub_values_map.end (); ++iter)\n+    delete (*iter).second;\n+  for (unmergeable_values_map_t::iterator iter\n+\t = m_unmergeable_values_map.begin ();\n+       iter != m_unmergeable_values_map.end (); ++iter)\n+    delete (*iter).second;\n+  for (widening_values_map_t::iterator iter = m_widening_values_map.begin ();\n+       iter != m_widening_values_map.end (); ++iter)\n+    delete (*iter).second;\n+  for (compound_values_map_t::iterator iter = m_compound_values_map.begin ();\n+       iter != m_compound_values_map.end (); ++iter)\n+    delete (*iter).second;\n+  for (conjured_values_map_t::iterator iter = m_conjured_values_map.begin ();\n+       iter != m_conjured_values_map.end (); ++iter)\n+    delete (*iter).second;\n+\n+  /* Delete consolidated regions.  */\n+  for (fndecls_map_t::iterator iter = m_fndecls_map.begin ();\n+       iter != m_fndecls_map.end (); ++iter)\n+    delete (*iter).second;\n+  for (labels_map_t::iterator iter = m_labels_map.begin ();\n+       iter != m_labels_map.end (); ++iter)\n+    delete (*iter).second;\n+  for (globals_map_t::iterator iter = m_globals_map.begin ();\n+       iter != m_globals_map.end (); ++iter)\n+    delete (*iter).second;\n+  for (string_map_t::iterator iter = m_string_map.begin ();\n+       iter != m_string_map.end (); ++iter)\n+    delete (*iter).second;\n+}\n+\n+/* Return true if C exceeds the complexity limit for svalues.  */\n+\n+bool\n+region_model_manager::too_complex_p (const complexity &c) const\n+{\n+  if (c.m_max_depth > (unsigned)param_analyzer_max_svalue_depth)\n+    return true;\n+  return false;\n+}\n+\n+/* If SVAL exceeds the complexity limit for svalues, delete it\n+   and return true.\n+   Otherwise update m_max_complexity and return false.  */\n+\n+bool\n+region_model_manager::reject_if_too_complex (svalue *sval)\n+{\n+  const complexity &c = sval->get_complexity ();\n+  if (!too_complex_p (c))\n+    {\n+      if (m_max_complexity.m_num_nodes < c.m_num_nodes)\n+\tm_max_complexity.m_num_nodes = c.m_num_nodes;\n+      if (m_max_complexity.m_max_depth < c.m_max_depth)\n+\tm_max_complexity.m_max_depth = c.m_max_depth;\n+      return false;\n+    }\n+\n+  delete sval;\n+  return true;\n+}\n+\n+/* Macro for imposing a complexity limit on svalues, for use within\n+   region_model_manager member functions.\n+\n+   If SVAL exceeds the complexity limit, delete it and return an UNKNOWN\n+   value of the same type.\n+   Otherwise update m_max_complexity and carry on.  */\n+\n+#define RETURN_UNKNOWN_IF_TOO_COMPLEX(SVAL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    svalue *sval_ = (SVAL);\t\t\t\t\t\\\n+    tree type_ = sval_->get_type ();\t\t\t\t\\\n+    if (reject_if_too_complex (sval_))\t\t\t\t\\\n+      return get_or_create_unknown_svalue (type_);\t\t\\\n+  } while (0)\n+\n+/* svalue consolidation.  */\n+\n+/* Return the svalue * for a constant_svalue for CST_EXPR,\n+   creating it if necessary.\n+   The constant_svalue instances are reused, based on pointer equality\n+   of trees  */\n+\n+const svalue *\n+region_model_manager::get_or_create_constant_svalue (tree cst_expr)\n+{\n+  gcc_assert (cst_expr);\n+\n+  constant_svalue **slot = m_constants_map.get (cst_expr);\n+  if (slot)\n+    return *slot;\n+  constant_svalue *cst_sval = new constant_svalue (cst_expr);\n+  RETURN_UNKNOWN_IF_TOO_COMPLEX (cst_sval);\n+  m_constants_map.put (cst_expr, cst_sval);\n+  return cst_sval;\n+}\n+\n+/* Return the svalue * for a unknown_svalue for TYPE (which can be NULL),\n+   creating it if necessary.\n+   The unknown_svalue instances are reused, based on pointer equality\n+   of the types  */\n+\n+const svalue *\n+region_model_manager::get_or_create_unknown_svalue (tree type)\n+{\n+  /* Special-case NULL, so that the hash_map can use NULL as the\n+     \"empty\" value.  */\n+  if (type == NULL_TREE)\n+    {\n+      if (!m_unknown_NULL)\n+\tm_unknown_NULL = new unknown_svalue (type);\n+      return m_unknown_NULL;\n+    }\n+\n+  unknown_svalue **slot = m_unknowns_map.get (type);\n+  if (slot)\n+    return *slot;\n+  unknown_svalue *sval = new unknown_svalue (type);\n+  m_unknowns_map.put (type, sval);\n+  return sval;\n+}\n+\n+/* Return the svalue * for the initial value of REG, creating it if\n+   necessary.  */\n+\n+const svalue *\n+region_model_manager::get_or_create_initial_value (const region *reg)\n+{\n+  /* The initial value of a cast is a cast of the initial value.  */\n+  if (const cast_region *cast_reg = reg->dyn_cast_cast_region ())\n+    {\n+      const region *original_reg = cast_reg->get_original_region ();\n+      return get_or_create_cast (cast_reg->get_type (),\n+\t\t\t\t get_or_create_initial_value (original_reg));\n+    }\n+\n+  if (initial_svalue **slot = m_initial_values_map.get (reg))\n+    return *slot;\n+  initial_svalue *initial_sval = new initial_svalue (reg->get_type (), reg);\n+  RETURN_UNKNOWN_IF_TOO_COMPLEX (initial_sval);\n+  m_initial_values_map.put (reg, initial_sval);\n+  return initial_sval;\n+}\n+\n+/* Return the svalue * for R using type TYPE, creating it if\n+   necessary.  */\n+\n+const svalue *\n+region_model_manager::get_or_create_setjmp_svalue (const setjmp_record &r,\n+\t\t\t\t\t\t   tree type)\n+{\n+  setjmp_svalue::key_t key (r, type);\n+  if (setjmp_svalue **slot = m_setjmp_values_map.get (key))\n+    return *slot;\n+  setjmp_svalue *setjmp_sval = new setjmp_svalue (r, type);\n+  RETURN_UNKNOWN_IF_TOO_COMPLEX (setjmp_sval);\n+  m_setjmp_values_map.put (key, setjmp_sval);\n+  return setjmp_sval;\n+}\n+\n+/* Return the svalue * for a poisoned value of KIND and TYPE, creating it if\n+   necessary.  */\n+\n+const svalue *\n+region_model_manager::get_or_create_poisoned_svalue (enum poison_kind kind,\n+\t\t\t\t\t\t     tree type)\n+{\n+  poisoned_svalue::key_t key (kind, type);\n+  if (poisoned_svalue **slot = m_poisoned_values_map.get (key))\n+    return *slot;\n+  poisoned_svalue *poisoned_sval = new poisoned_svalue (kind, type);\n+  RETURN_UNKNOWN_IF_TOO_COMPLEX (poisoned_sval);\n+  m_poisoned_values_map.put (key, poisoned_sval);\n+  return poisoned_sval;\n+}\n+\n+/* Return the svalue * for a pointer to POINTEE of type PTR_TYPE,\n+   creating it if necessary.  */\n+\n+const svalue *\n+region_model_manager::get_ptr_svalue (tree ptr_type, const region *pointee)\n+{\n+  /* If this is a symbolic region from dereferencing a pointer, and the types\n+     match, then return the original pointer.  */\n+  if (const symbolic_region *sym_reg = pointee->dyn_cast_symbolic_region ())\n+    if (ptr_type == sym_reg->get_pointer ()->get_type ())\n+      return sym_reg->get_pointer ();\n+\n+  region_svalue::key_t key (ptr_type, pointee);\n+  if (region_svalue **slot = m_pointer_values_map.get (key))\n+    return *slot;\n+  region_svalue *sval = new region_svalue (ptr_type, pointee);\n+  RETURN_UNKNOWN_IF_TOO_COMPLEX (sval);\n+  m_pointer_values_map.put (key, sval);\n+  return sval;\n+}\n+\n+/* Subroutine of region_model_manager::get_or_create_unaryop.\n+   Attempt to fold the inputs and return a simpler svalue *.\n+   Otherwise, return NULL.  */\n+\n+const svalue *\n+region_model_manager::maybe_fold_unaryop (tree type, enum tree_code op,\n+\t\t\t\t\t  const svalue *arg)\n+{\n+  /* Ops on \"unknown\" are also unknown.  */\n+  if (arg->get_kind () == SK_UNKNOWN)\n+    return get_or_create_unknown_svalue (type);\n+\n+  switch (op)\n+    {\n+    default: break;\n+    case NOP_EXPR:\n+      {\n+\t/* Handle redundant casts.  */\n+\tif (arg->get_type ()\n+\t    && useless_type_conversion_p (arg->get_type (), type))\n+\t  return arg;\n+\n+\t/* Fold \"cast<TYPE> (cast <INNER_TYPE> (innermost_arg))\n+\t     => \"cast<TYPE> (innermost_arg)\",\n+\t   unless INNER_TYPE is narrower than TYPE.  */\n+\tif (const svalue *innermost_arg = arg->maybe_undo_cast ())\n+\t  {\n+\t    tree inner_type = arg->get_type ();\n+\t    if (TYPE_SIZE (type)\n+\t\t&& TYPE_SIZE (inner_type)\n+\t\t&& (fold_binary (LE_EXPR, boolean_type_node,\n+\t\t\t\t TYPE_SIZE (type), TYPE_SIZE (inner_type))\n+\t\t    == boolean_true_node))\n+\t      return maybe_fold_unaryop (type, op, innermost_arg);\n+\t  }\n+      }\n+      break;\n+    case TRUTH_NOT_EXPR:\n+      {\n+\t/* Invert comparisons e.g. \"!(x == y)\" => \"x != y\".  */\n+\tif (const binop_svalue *binop = arg->dyn_cast_binop_svalue ())\n+\t  if (TREE_CODE_CLASS (binop->get_op ()) == tcc_comparison)\n+\t    {\n+\t      enum tree_code inv_op\n+\t\t= invert_tree_comparison (binop->get_op (),\n+\t\t\t\t\t  HONOR_NANS (binop->get_type ()));\n+\t      if (inv_op != ERROR_MARK)\n+\t\treturn get_or_create_binop (binop->get_type (), inv_op,\n+\t\t\t\t\t    binop->get_arg0 (),\n+\t\t\t\t\t    binop->get_arg1 ());\n+\t    }\n+      }\n+      break;\n+    }\n+\n+  /* Constants.  */\n+  if (tree cst = arg->maybe_get_constant ())\n+    if (tree result = fold_unary (op, type, cst))\n+      return get_or_create_constant_svalue (result);\n+\n+  return NULL;\n+}\n+\n+/* Return the svalue * for an unary operation OP on ARG with a result of\n+   type TYPE, creating it if necessary.  */\n+\n+const svalue *\n+region_model_manager::get_or_create_unaryop (tree type, enum tree_code op,\n+\t\t\t\t\t     const svalue *arg)\n+{\n+  if (const svalue *folded = maybe_fold_unaryop  (type, op, arg))\n+    return folded;\n+  unaryop_svalue::key_t key (type, op, arg);\n+  if (unaryop_svalue **slot = m_unaryop_values_map.get (key))\n+    return *slot;\n+  unaryop_svalue *unaryop_sval = new unaryop_svalue (type, op, arg);\n+  RETURN_UNKNOWN_IF_TOO_COMPLEX (unaryop_sval);\n+  m_unaryop_values_map.put (key, unaryop_sval);\n+  return unaryop_sval;\n+}\n+\n+/* Return the svalue * for a cast of ARG to type TYPE, creating it\n+   if necessary.  */\n+\n+const svalue *\n+region_model_manager::get_or_create_cast (tree type, const svalue *arg)\n+{\n+  return get_or_create_unaryop (type, NOP_EXPR, arg);\n+}\n+\n+/* Subroutine of region_model_manager::get_or_create_binop.\n+   Attempt to fold the inputs and return a simpler svalue *.\n+   Otherwise, return NULL.  */\n+\n+const svalue *\n+region_model_manager::maybe_fold_binop (tree type, enum tree_code op,\n+\t\t\t\t\tconst svalue *arg0,\n+\t\t\t\t\tconst svalue *arg1)\n+{\n+  tree cst0 = arg0->maybe_get_constant ();\n+  tree cst1 = arg1->maybe_get_constant ();\n+  /* (CST OP CST).  */\n+  if (cst0 && cst1)\n+    {\n+      if (tree result = fold_binary (op, type, cst0, cst1))\n+\tif (CONSTANT_CLASS_P (result))\n+\t  return get_or_create_constant_svalue (result);\n+    }\n+\n+  if (FLOAT_TYPE_P (type)\n+      || (arg0->get_type () && FLOAT_TYPE_P (arg0->get_type ()))\n+      || (arg1->get_type () && FLOAT_TYPE_P (arg1->get_type ())))\n+    return NULL;\n+\n+  switch (op)\n+    {\n+    default:\n+      break;\n+    case POINTER_PLUS_EXPR:\n+    case PLUS_EXPR:\n+      /* (VAL + 0) -> VAL.  */\n+      if (cst1 && zerop (cst1) && type == arg0->get_type ())\n+\treturn arg0;\n+      break;\n+    case MINUS_EXPR:\n+      /* (VAL - 0) -> VAL.  */\n+      if (cst1 && zerop (cst1) && type == arg0->get_type ())\n+\treturn arg0;\n+      break;\n+    case MULT_EXPR:\n+      /* (VAL * 0).  */\n+      if (cst1 && zerop (cst1))\n+\treturn get_or_create_constant_svalue (build_int_cst (type, 0));\n+      /* (VAL * 1) -> VAL.  */\n+      if (cst1 && integer_onep (cst1))\n+\treturn arg0;\n+      break;\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_AND_EXPR:\n+      if (cst1)\n+\t{\n+\t  if (zerop (cst1))\n+\t    /* \"(ARG0 && 0)\" -> \"0\".  */\n+\t    return get_or_create_constant_svalue (build_int_cst (type, 0));\n+\t  else\n+\t    /* \"(ARG0 && nonzero-cst)\" -> \"ARG0\".  */\n+\t    return get_or_create_cast (type, arg0);\n+\t}\n+      break;\n+    case TRUTH_ORIF_EXPR:\n+    case TRUTH_OR_EXPR:\n+      if (cst1)\n+\t{\n+\t  if (zerop (cst1))\n+\t    /* \"(ARG0 || 0)\" -> \"ARG0\".  */\n+\t    return get_or_create_cast (type, arg0);\n+\t  else\n+\t    /* \"(ARG0 && nonzero-cst)\" -> \"nonzero-cst\".  */\n+\t    return get_or_create_cast (type, arg1);\n+\t}\n+      break;\n+    }\n+\n+  /* For associative ops, fold \"(X op CST_A) op CST_B)\" to\n+     \"X op (CST_A op CST_B)\".  */\n+  if (cst1 && associative_tree_code (op))\n+    if (const binop_svalue *binop = arg0->dyn_cast_binop_svalue ())\n+      if (binop->get_op () == op\n+\t  && binop->get_arg1 ()->maybe_get_constant ()\n+\t  && type == binop->get_type ()\n+\t  && type == binop->get_arg0 ()->get_type ()\n+\t  && type == binop->get_arg1 ()->get_type ())\n+\treturn get_or_create_binop\n+\t  (type, op, binop->get_arg0 (),\n+\t   get_or_create_binop (type, op,\n+\t\t\t\tbinop->get_arg1 (), arg1));\n+\n+  /* associative_tree_code is false for POINTER_PLUS_EXPR, but we\n+     can fold:\n+       \"(PTR ptr+ CST_A) ptr+ CST_B)\" to \"PTR ptr+ (CST_A ptr+ CST_B)\"\n+     e.g. in data-model-1.c: test_4c.  */\n+  if (cst1 && op == POINTER_PLUS_EXPR)\n+    if (const binop_svalue *binop = arg0->dyn_cast_binop_svalue ())\n+      if (binop->get_op () == POINTER_PLUS_EXPR)\n+\tif (binop->get_arg1 ()->maybe_get_constant ())\n+\t  return get_or_create_binop\n+\t    (type, op, binop->get_arg0 (),\n+\t     get_or_create_binop (size_type_node, op,\n+\t\t\t\t  binop->get_arg1 (), arg1));\n+\n+  /* Ops on \"unknown\" are also unknown (unless we can use one of the\n+     identities above).  */\n+  if (arg0->get_kind () == SK_UNKNOWN\n+      || arg1->get_kind () == SK_UNKNOWN)\n+    return get_or_create_unknown_svalue (type);\n+\n+  /* etc.  */\n+\n+  return NULL;\n+}\n+\n+/* Return the svalue * for an binary operation OP on ARG0 and ARG1\n+   with a result of type TYPE, creating it if necessary.  */\n+\n+const svalue *\n+region_model_manager::get_or_create_binop (tree type, enum tree_code op,\n+\t\t\t\t\t   const svalue *arg0,\n+\t\t\t\t\t   const svalue *arg1)\n+{\n+  /* For commutative ops, put any constant on the RHS.  */\n+  if (arg0->maybe_get_constant () && commutative_tree_code (op))\n+    std::swap (arg0, arg1);\n+\n+  if (const svalue *folded = maybe_fold_binop (type, op, arg0, arg1))\n+    return folded;\n+\n+  binop_svalue::key_t key (type, op, arg0, arg1);\n+  if (binop_svalue **slot = m_binop_values_map.get (key))\n+    return *slot;\n+  binop_svalue *binop_sval = new binop_svalue (type, op, arg0, arg1);\n+  RETURN_UNKNOWN_IF_TOO_COMPLEX (binop_sval);\n+  m_binop_values_map.put (key, binop_sval);\n+  return binop_sval;\n+}\n+\n+/* Subroutine of region_model_manager::get_or_create_sub_svalue.\n+   Return a folded svalue, or NULL.  */\n+\n+const svalue *\n+region_model_manager::maybe_fold_sub_svalue (tree type,\n+\t\t\t\t\t     const svalue *parent_svalue,\n+\t\t\t\t\t     const region *subregion)\n+{\n+  /* Subvalues of \"unknown\" are unknown.  */\n+  if (parent_svalue->get_kind () == SK_UNKNOWN)\n+    return get_or_create_unknown_svalue (type);\n+\n+  /* If we have a subregion of a zero-fill, it's zero.  */\n+  if (const unaryop_svalue *unary\n+      = parent_svalue->dyn_cast_unaryop_svalue ())\n+    {\n+      if (unary->get_op () == NOP_EXPR)\n+\tif (tree cst = unary->get_arg ()->maybe_get_constant ())\n+\t  if (zerop (cst))\n+\t    {\n+\t      const svalue *cst_sval\n+\t\t= get_or_create_constant_svalue (cst);\n+\t      return get_or_create_cast (type, cst_sval);\n+\t    }\n+    }\n+\n+  /* Handle getting individual chars from a STRING_CST.  */\n+  if (tree cst = parent_svalue->maybe_get_constant ())\n+    if (TREE_CODE (cst) == STRING_CST)\n+      if (const element_region *element_reg\n+\t    = subregion->dyn_cast_element_region ())\n+\t{\n+\t  const svalue *idx_sval = element_reg->get_index ();\n+\t  if (tree cst_idx = idx_sval->maybe_get_constant ())\n+\t    if (const svalue *char_sval\n+\t\t= maybe_get_char_from_string_cst (cst, cst_idx))\n+\t      return get_or_create_cast (type, char_sval);\n+\t}\n+\n+  /* SUB(INIT(r)).FIELD -> INIT(r.FIELD)\n+     i.e.\n+     Subvalue(InitialValue(R1), FieldRegion(R2, F))\n+       -> InitialValue(FieldRegion(R1, F)).  */\n+  if (const initial_svalue *init_sval\n+        = parent_svalue->dyn_cast_initial_svalue ())\n+    {\n+      if (const field_region *field_reg = subregion->dyn_cast_field_region ())\n+\t{\n+\t  const region *field_reg_new\n+\t    = get_field_region (init_sval->get_region (),\n+\t\t\t\tfield_reg->get_field ());\n+\t  return get_or_create_initial_value (field_reg_new);\n+\t}\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Return the svalue * for extracting a subvalue of type TYPE from\n+   PARENT_SVALUE based on SUBREGION, creating it if necessary.  */\n+\n+const svalue *\n+region_model_manager::get_or_create_sub_svalue (tree type,\n+\t\t\t\t\t\tconst svalue *parent_svalue,\n+\t\t\t\t\t\tconst region *subregion)\n+{\n+  if (const svalue *folded\n+\t= maybe_fold_sub_svalue (type, parent_svalue, subregion))\n+    return folded;\n+\n+  sub_svalue::key_t key (type, parent_svalue, subregion);\n+  if (sub_svalue **slot = m_sub_values_map.get (key))\n+    return *slot;\n+  sub_svalue *sub_sval\n+    = new sub_svalue (type, parent_svalue, subregion);\n+  RETURN_UNKNOWN_IF_TOO_COMPLEX (sub_sval);\n+  m_sub_values_map.put (key, sub_sval);\n+  return sub_sval;\n+}\n+\n+/* Return the svalue * that decorates ARG as being unmergeable,\n+   creating it if necessary.  */\n+\n+const svalue *\n+region_model_manager::get_or_create_unmergeable (const svalue *arg)\n+{\n+  if (arg->get_kind () == SK_UNMERGEABLE)\n+    return arg;\n+\n+  if (unmergeable_svalue **slot = m_unmergeable_values_map.get (arg))\n+    return *slot;\n+  unmergeable_svalue *unmergeable_sval = new unmergeable_svalue (arg);\n+  RETURN_UNKNOWN_IF_TOO_COMPLEX (unmergeable_sval);\n+  m_unmergeable_values_map.put (arg, unmergeable_sval);\n+  return unmergeable_sval;\n+}\n+\n+/* Return the svalue * of type TYPE for the merger of value BASE_SVAL\n+   and ITER_SVAL at POINT, creating it if necessary.  */\n+\n+const svalue *\n+region_model_manager::get_or_create_widening_svalue (tree type,\n+\t\t\t\t\t\t     const program_point &point,\n+\t\t\t\t\t\t     const svalue *base_sval,\n+\t\t\t\t\t\t     const svalue *iter_sval)\n+{\n+  widening_svalue::key_t key (type, point, base_sval, iter_sval);\n+  if (widening_svalue **slot = m_widening_values_map.get (key))\n+    return *slot;\n+  widening_svalue *widening_sval\n+    = new widening_svalue (type, point, base_sval, iter_sval);\n+  RETURN_UNKNOWN_IF_TOO_COMPLEX (widening_sval);\n+  m_widening_values_map.put (key, widening_sval);\n+  return widening_sval;\n+}\n+\n+/* Return the svalue * of type TYPE for the compound values in MAP,\n+   creating it if necessary.  */\n+\n+const svalue *\n+region_model_manager::get_or_create_compound_svalue (tree type,\n+\t\t\t\t\t\t     const binding_map &map)\n+{\n+  compound_svalue::key_t tmp_key (type, &map);\n+  if (compound_svalue **slot = m_compound_values_map.get (tmp_key))\n+    return *slot;\n+  compound_svalue *compound_sval\n+    = new compound_svalue (type, map);\n+  RETURN_UNKNOWN_IF_TOO_COMPLEX (compound_sval);\n+  /* Use make_key rather than reusing the key, so that we use a\n+     ptr to compound_sval's binding_map, rather than the MAP param.  */\n+  m_compound_values_map.put (compound_sval->make_key (), compound_sval);\n+  return compound_sval;\n+}\n+\n+/* Return the svalue * of type TYPE for the value conjured for ID_REG\n+   at STMT, creating it if necessary.  */\n+\n+const svalue *\n+region_model_manager::get_or_create_conjured_svalue (tree type,\n+\t\t\t\t\t\t     const gimple *stmt,\n+\t\t\t\t\t\t     const region *id_reg)\n+{\n+  conjured_svalue::key_t key (type, stmt, id_reg);\n+  if (conjured_svalue **slot = m_conjured_values_map.get (key))\n+    return *slot;\n+  conjured_svalue *conjured_sval\n+    = new conjured_svalue (type, stmt, id_reg);\n+  RETURN_UNKNOWN_IF_TOO_COMPLEX (conjured_sval);\n+  m_conjured_values_map.put (key, conjured_sval);\n+  return conjured_sval;\n+}\n+\n+/* Given STRING_CST, a STRING_CST and BYTE_OFFSET_CST a constant,\n+   attempt to get the character at that offset, returning either\n+   the svalue for the character constant, or NULL if unsuccessful.  */\n+\n+const svalue *\n+region_model_manager::maybe_get_char_from_string_cst (tree string_cst,\n+\t\t\t\t\t\t      tree byte_offset_cst)\n+{\n+  gcc_assert (TREE_CODE (string_cst) == STRING_CST);\n+\n+  /* Adapted from fold_read_from_constant_string.  */\n+  scalar_int_mode char_mode;\n+  if (TREE_CODE (byte_offset_cst) == INTEGER_CST\n+      && compare_tree_int (byte_offset_cst,\n+\t\t\t   TREE_STRING_LENGTH (string_cst)) < 0\n+      && is_int_mode (TYPE_MODE (TREE_TYPE (TREE_TYPE (string_cst))),\n+\t\t      &char_mode)\n+      && GET_MODE_SIZE (char_mode) == 1)\n+    {\n+      tree char_cst\n+\t= build_int_cst_type (TREE_TYPE (TREE_TYPE (string_cst)),\n+\t\t\t      (TREE_STRING_POINTER (string_cst)\n+\t\t\t       [TREE_INT_CST_LOW (byte_offset_cst)]));\n+      return get_or_create_constant_svalue (char_cst);\n+    }\n+  return NULL;\n+}\n+\n+/* region consolidation.  */\n+\n+/* Return the region for FNDECL, creating it if necessary.  */\n+\n+const function_region *\n+region_model_manager::get_region_for_fndecl (tree fndecl)\n+{\n+  gcc_assert (TREE_CODE (fndecl) == FUNCTION_DECL);\n+\n+  function_region **slot = m_fndecls_map.get (fndecl);\n+  if (slot)\n+    return *slot;\n+  function_region *reg\n+    = new function_region (alloc_region_id (), &m_code_region, fndecl);\n+  m_fndecls_map.put (fndecl, reg);\n+  return reg;\n+}\n+\n+/* Return the region for LABEL, creating it if necessary.  */\n+\n+const label_region *\n+region_model_manager::get_region_for_label (tree label)\n+{\n+  gcc_assert (TREE_CODE (label) == LABEL_DECL);\n+\n+  label_region **slot = m_labels_map.get (label);\n+  if (slot)\n+    return *slot;\n+\n+  tree fndecl = DECL_CONTEXT (label);\n+  gcc_assert (fndecl && TREE_CODE (fndecl) == FUNCTION_DECL);\n+\n+  const function_region *func_reg = get_region_for_fndecl (fndecl);\n+  label_region *reg\n+    = new label_region (alloc_region_id (), func_reg, label);\n+  m_labels_map.put (label, reg);\n+  return reg;\n+}\n+\n+/* Return the region for EXPR, creating it if necessary.  */\n+\n+const decl_region *\n+region_model_manager::get_region_for_global (tree expr)\n+{\n+  gcc_assert (TREE_CODE (expr) == VAR_DECL);\n+\n+  decl_region **slot = m_globals_map.get (expr);\n+  if (slot)\n+    return *slot;\n+  decl_region *reg\n+    = new decl_region (alloc_region_id (), &m_globals_region, expr);\n+  m_globals_map.put (expr, reg);\n+  return reg;\n+}\n+\n+/* Return the region that describes accessing field FIELD of PARENT,\n+   creating it if necessary.  */\n+\n+const region *\n+region_model_manager::get_field_region (const region *parent, tree field)\n+{\n+  field_region::key_t key (parent, field);\n+  if (field_region *reg = m_field_regions.get (key))\n+    return reg;\n+\n+  field_region *field_reg\n+    = new field_region (alloc_region_id (), parent, field);\n+  m_field_regions.put (key, field_reg);\n+  return field_reg;\n+}\n+\n+/* Return the region that describes accessing the element of type\n+   ELEMENT_TYPE at index INDEX of PARENT, creating it if necessary.  */\n+\n+const region *\n+region_model_manager::get_element_region (const region *parent,\n+\t\t\t\t\t  tree element_type,\n+\t\t\t\t\t  const svalue *index)\n+{\n+  element_region::key_t key (parent, element_type, index);\n+  if (element_region *reg = m_element_regions.get (key))\n+    return reg;\n+\n+  element_region *element_reg\n+    = new element_region (alloc_region_id (), parent, element_type, index);\n+  m_element_regions.put (key, element_reg);\n+  return element_reg;\n+}\n+\n+/* Return the region that describes accessing the subregion of type\n+   ELEMENT_TYPE at offset BYTE_OFFSET within PARENT, creating it if\n+   necessary.  */\n+\n+const region *\n+region_model_manager::get_offset_region (const region *parent,\n+\t\t\t\t\t tree type,\n+\t\t\t\t\t const svalue *byte_offset)\n+{\n+  /* If BYTE_OFFSET is zero, return PARENT.  */\n+  if (tree cst_offset = byte_offset->maybe_get_constant ())\n+    if (zerop (cst_offset))\n+      return get_cast_region (parent, type);\n+\n+  /* Fold OFFSET_REGION(OFFSET_REGION(REG, X), Y)\n+     to   OFFSET_REGION(REG, (X + Y)).  */\n+  if (const offset_region *parent_offset_reg\n+\t= parent->dyn_cast_offset_region ())\n+    {\n+      const svalue *sval_x = parent_offset_reg->get_byte_offset ();\n+      const svalue *sval_sum\n+\t= get_or_create_binop (byte_offset->get_type (),\n+\t\t\t       PLUS_EXPR, sval_x, byte_offset);\n+      return get_offset_region (parent->get_parent_region (), type, sval_sum);\n+    }\n+\n+  offset_region::key_t key (parent, type, byte_offset);\n+  if (offset_region *reg = m_offset_regions.get (key))\n+    return reg;\n+\n+  offset_region *offset_reg\n+    = new offset_region (alloc_region_id (), parent, type, byte_offset);\n+  m_offset_regions.put (key, offset_reg);\n+  return offset_reg;\n+}\n+\n+/* Return the region that describes accessing PARENT_REGION as if\n+   it were of type TYPE, creating it if necessary.  */\n+\n+const region *\n+region_model_manager::get_cast_region (const region *original_region,\n+\t\t\t\t       tree type)\n+{\n+  /* If types match, return ORIGINAL_REGION.  */\n+  if (type == original_region->get_type ())\n+    return original_region;\n+\n+  cast_region::key_t key (original_region, type);\n+  if (cast_region *reg = m_cast_regions.get (key))\n+    return reg;\n+\n+  cast_region *cast_reg\n+    = new cast_region (alloc_region_id (), original_region, type);\n+  m_cast_regions.put (key, cast_reg);\n+  return cast_reg;\n+}\n+\n+/* Return the frame_region for call to FUN from CALLING_FRAME, creating it\n+   if necessary.  CALLING_FRAME may be NULL.  */\n+\n+const frame_region *\n+region_model_manager::get_frame_region (const frame_region *calling_frame,\n+\t\t\t\t\tfunction *fun)\n+{\n+  int index = calling_frame ? calling_frame->get_index () + 1 : 0;\n+\n+  frame_region::key_t key (calling_frame, fun);\n+  if (frame_region *reg = m_frame_regions.get (key))\n+    return reg;\n+\n+  frame_region *frame_reg\n+    = new frame_region (alloc_region_id (), &m_stack_region, calling_frame,\n+\t\t\t fun, index);\n+  m_frame_regions.put (key, frame_reg);\n+  return frame_reg;\n+}\n+\n+/* Return the region that describes dereferencing SVAL, creating it\n+   if necessary.  */\n+\n+const region *\n+region_model_manager::get_symbolic_region (const svalue *sval)\n+{\n+  symbolic_region::key_t key (&m_root_region, sval);\n+  if (symbolic_region *reg = m_symbolic_regions.get (key))\n+    return reg;\n+\n+  symbolic_region *symbolic_reg\n+    = new symbolic_region (alloc_region_id (), &m_root_region, sval);\n+  m_symbolic_regions.put (key, symbolic_reg);\n+  return symbolic_reg;\n+}\n+\n+/* Return the region that describes accessing STRING_CST, creating it\n+   if necessary.  */\n+\n+const string_region *\n+region_model_manager::get_region_for_string (tree string_cst)\n+{\n+  gcc_assert (TREE_CODE (string_cst) == STRING_CST);\n+\n+  string_region **slot = m_string_map.get (string_cst);\n+  if (slot)\n+    return *slot;\n+  string_region *reg\n+    = new string_region (alloc_region_id (), &m_root_region, string_cst);\n+  m_string_map.put (string_cst, reg);\n+  return reg;\n+}\n+\n+/* If we see a tree code we don't know how to handle, rather than\n+   ICE or generate bogus results, create a dummy region, and notify\n+   CTXT so that it can mark the new state as being not properly\n+   modelled.  The exploded graph can then stop exploring that path,\n+   since any diagnostics we might issue will have questionable\n+   validity.  */\n+\n+const region *\n+region_model_manager::\n+get_region_for_unexpected_tree_code (region_model_context *ctxt,\n+\t\t\t\t     tree t,\n+\t\t\t\t     const dump_location_t &loc)\n+{\n+  gcc_assert (ctxt);\n+  tree type = TYPE_P (t) ? t : TREE_TYPE (t);\n+  region *new_reg\n+    = new unknown_region (alloc_region_id (), &m_root_region, type);\n+  ctxt->on_unexpected_tree_code (t, loc);\n+  return new_reg;\n+}\n+\n+/* Return a new region describing a heap-allocated block of memory.  */\n+\n+const region *\n+region_model_manager::create_region_for_heap_alloc ()\n+{\n+  region *reg\n+    = new heap_allocated_region (alloc_region_id (), &m_heap_region);\n+  m_managed_dynamic_regions.safe_push (reg);\n+  return reg;\n+}\n+\n+/* Return a new region describing a block of memory allocated within FRAME.  */\n+\n+const region *\n+region_model_manager::create_region_for_alloca (const frame_region *frame)\n+{\n+  gcc_assert (frame);\n+  region *reg = new alloca_region (alloc_region_id (), frame);\n+  m_managed_dynamic_regions.safe_push (reg);\n+  return reg;\n+}\n+\n+/* Log OBJ to LOGGER.  */\n+\n+template <typename T>\n+static void\n+log_managed_object (logger *logger, const T *obj)\n+{\n+  logger->start_log_line ();\n+  pretty_printer *pp = logger->get_printer ();\n+  pp_string (pp, \"    \");\n+  obj->dump_to_pp (pp, true);\n+  logger->end_log_line ();\n+}\n+\n+/* Specialization for frame_region, which also logs the count of locals\n+   managed by the frame_region.  */\n+\n+template <>\n+void\n+log_managed_object (logger *logger, const frame_region *obj)\n+{\n+  logger->start_log_line ();\n+  pretty_printer *pp = logger->get_printer ();\n+  pp_string (pp, \"    \");\n+  obj->dump_to_pp (pp, true);\n+  pp_printf (pp, \" [with %i region(s) for locals]\", obj->get_num_locals ());\n+  logger->end_log_line ();\n+}\n+\n+/* Dump the number of objects that were managed by UNIQ_MAP to LOGGER.\n+   If SHOW_OBJS is true, also dump the objects themselves.  */\n+\n+template <typename K, typename T>\n+static void\n+log_uniq_map (logger *logger, bool show_objs, const char *title,\n+\t      const hash_map<K, T*> &uniq_map)\n+{\n+  logger->log (\"  # %s: %li\", title, uniq_map.elements ());\n+  if (show_objs)\n+    for (typename hash_map<K, T*>::iterator iter = uniq_map.begin ();\n+\t iter != uniq_map.end (); ++iter)\n+      {\n+\tT *managed_obj = (*iter).second;\n+\tlog_managed_object<T> (logger, managed_obj);\n+      }\n+}\n+\n+/* Dump the number of objects that were managed by MAP to LOGGER.\n+   If SHOW_OBJS is true, also dump the objects themselves.  */\n+\n+template <typename T>\n+static void\n+log_uniq_map (logger *logger, bool show_objs, const char *title,\n+\t      const consolidation_map<T> &map)\n+{\n+  logger->log (\"  # %s: %li\", title, map.elements ());\n+  if (show_objs)\n+    for (typename consolidation_map<T>::iterator iter = map.begin ();\n+\t iter != map.end (); ++iter)\n+      {\n+\tT *managed_obj = (*iter).second;\n+\tlog_managed_object<T> (logger, managed_obj);\n+      }\n+}\n+\n+/* Dump the number of objects of each class that were managed by this\n+   manager to LOGGER.\n+   If SHOW_OBJS is true, also dump the objects themselves.  */\n+\n+void\n+region_model_manager::log_stats (logger *logger, bool show_objs) const\n+{\n+  LOG_SCOPE (logger);\n+  logger->log (\"svalue consolidation\");\n+  log_uniq_map (logger, show_objs, \"constant_svalue\", m_constants_map);\n+  log_uniq_map (logger, show_objs, \"unknown_svalue\", m_unknowns_map);\n+  if (m_unknown_NULL)\n+    log_managed_object (logger, m_unknown_NULL);\n+  log_uniq_map (logger, show_objs, \"poisoned_svalue\", m_poisoned_values_map);\n+  log_uniq_map (logger, show_objs, \"setjmp_svalue\", m_setjmp_values_map);\n+  log_uniq_map (logger, show_objs, \"initial_svalue\", m_initial_values_map);\n+  log_uniq_map (logger, show_objs, \"region_svalue\", m_pointer_values_map);\n+  log_uniq_map (logger, show_objs, \"unaryop_svalue\", m_unaryop_values_map);\n+  log_uniq_map (logger, show_objs, \"binop_svalue\", m_binop_values_map);\n+  log_uniq_map (logger, show_objs, \"sub_svalue\", m_sub_values_map);\n+  log_uniq_map (logger, show_objs, \"unmergeable_svalue\",\n+\t\tm_unmergeable_values_map);\n+  log_uniq_map (logger, show_objs, \"widening_svalue\", m_widening_values_map);\n+  log_uniq_map (logger, show_objs, \"compound_svalue\", m_compound_values_map);\n+  log_uniq_map (logger, show_objs, \"conjured_svalue\", m_conjured_values_map);\n+  logger->log (\"max accepted svalue num_nodes: %i\",\n+\t       m_max_complexity.m_num_nodes);\n+  logger->log (\"max accepted svalue max_depth: %i\",\n+\t       m_max_complexity.m_max_depth);\n+\n+  logger->log (\"region consolidation\");\n+  logger->log (\"  next region id: %i\", m_next_region_id);\n+  log_uniq_map (logger, show_objs, \"function_region\", m_fndecls_map);\n+  log_uniq_map (logger, show_objs, \"label_region\", m_labels_map);\n+  log_uniq_map (logger, show_objs, \"decl_region for globals\", m_globals_map);\n+  log_uniq_map (logger, show_objs, \"field_region\", m_field_regions);\n+  log_uniq_map (logger, show_objs, \"element_region\", m_element_regions);\n+  log_uniq_map (logger, show_objs, \"offset_region\", m_offset_regions);\n+  log_uniq_map (logger, show_objs, \"cast_region\", m_cast_regions);\n+  log_uniq_map (logger, show_objs, \"frame_region\", m_frame_regions);\n+  log_uniq_map (logger, show_objs, \"symbolic_region\", m_symbolic_regions);\n+  log_uniq_map (logger, show_objs, \"string_region\", m_string_map);\n+  logger->log (\"  # managed dynamic regions: %i\",\n+\t       m_managed_dynamic_regions.length ());\n+  m_store_mgr.log_stats (logger, show_objs);\n+}\n+\n+/* Dump the number of objects of each class that were managed by this\n+   manager to LOGGER.\n+   If SHOW_OBJS is true, also dump the objects themselves.\n+   This is here so it can use log_uniq_map.  */\n+\n+void\n+store_manager::log_stats (logger *logger, bool show_objs) const\n+{\n+  LOG_SCOPE (logger);\n+  log_uniq_map (logger, show_objs, \"concrete_binding\",\n+\t\tm_concrete_binding_key_mgr);\n+  log_uniq_map (logger, show_objs, \"symbolic_binding\",\n+\t\tm_symbolic_binding_key_mgr);\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "681b8f74b197933bdd7ca743e968f5d4189adff6", "filename": "gcc/analyzer/region-model-reachability.cc", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fregion-model-reachability.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fregion-model-reachability.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-reachability.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,280 @@\n+/* Finding reachable regions and values.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"diagnostic-core.h\"\n+#include \"graphviz.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"tree-dfa.h\"\n+#include \"stringpool.h\"\n+#include \"convert.h\"\n+#include \"target.h\"\n+#include \"fold-const.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"tristate.h\"\n+#include \"bitmap.h\"\n+#include \"selftest.h\"\n+#include \"function.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"cfg.h\"\n+#include \"digraph.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"analyzer/region-model-reachability.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+reachable_regions::reachable_regions (store *store,\n+\t\t\t\t      region_model_manager *mgr)\n+: m_store (store), m_mgr (mgr),\n+  m_reachable_base_regs (), m_mutable_base_regs ()\n+{\n+}\n+\n+/* Callback called for each cluster when initializing this object.  */\n+\n+void\n+reachable_regions::init_cluster_cb (const region *base_reg,\n+\t\t\t\t    reachable_regions *this_ptr)\n+{\n+  this_ptr->init_cluster (base_reg);\n+}\n+\n+/* Called for each cluster when initializing this object.  */\n+void\n+reachable_regions::init_cluster (const region *base_reg)\n+{\n+  /* Mark any globals as mutable (and traverse what they point to).  */\n+  const region *parent = base_reg->get_parent_region ();\n+  gcc_assert (parent);\n+  if (parent->get_kind () == RK_GLOBALS)\n+    add (base_reg, true);\n+\n+  /* Mark any clusters that already escaped in previous unknown calls\n+     as mutable (and traverse what they currently point to).  */\n+  if (m_store->escaped_p (base_reg))\n+    add (base_reg, true);\n+\n+  /* If BASE_REG is *INIT_VAL(REG) for some other REG, see if REG is\n+     unbound and untouched.  If so, then add BASE_REG as a root.  */\n+  if (const symbolic_region *sym_reg = base_reg->dyn_cast_symbolic_region ())\n+    {\n+      const svalue *ptr = sym_reg->get_pointer ();\n+      if (const initial_svalue *init_sval = ptr->dyn_cast_initial_svalue ())\n+\t{\n+\t  const region *init_sval_reg = init_sval->get_region ();\n+\t  const region *other_base_reg = init_sval_reg->get_base_region ();\n+\t  const binding_cluster *other_cluster\n+\t    = m_store->get_cluster (other_base_reg);\n+\t  if (other_cluster == NULL\n+\t      || !other_cluster->touched_p ())\n+\t    add (base_reg, true);\n+\t}\n+    }\n+}\n+\n+  /* Lazily mark the cluster containing REG as being reachable, recursively\n+     adding clusters reachable from REG's cluster.  */\n+void\n+reachable_regions::add (const region *reg, bool is_mutable)\n+{\n+  gcc_assert (reg);\n+\n+  const region *base_reg = const_cast <region *> (reg->get_base_region ());\n+  gcc_assert (base_reg);\n+\n+  /* Bail out if this cluster is already in the sets at the IS_MUTABLE\n+     level of mutability.  */\n+  if (!is_mutable && m_reachable_base_regs.contains (base_reg))\n+    return;\n+  m_reachable_base_regs.add (base_reg);\n+\n+  if (is_mutable)\n+    {\n+      if (m_mutable_base_regs.contains (base_reg))\n+\treturn;\n+      else\n+\tm_mutable_base_regs.add (base_reg);\n+    }\n+\n+  /* Add values within the cluster.  If any are pointers, add the pointee.  */\n+  if (binding_cluster *bind_cluster = m_store->get_cluster (base_reg))\n+    bind_cluster->for_each_value (handle_sval_cb, this);\n+  else\n+    handle_sval (m_mgr->get_or_create_initial_value (base_reg));\n+}\n+\n+void\n+reachable_regions::handle_sval_cb (const svalue *sval,\n+\t\t\t\t   reachable_regions *this_ptr)\n+{\n+  this_ptr->handle_sval (sval);\n+}\n+\n+/* Add SVAL.  If it is a pointer, add the pointed-to region.  */\n+\n+void\n+reachable_regions::handle_sval (const svalue *sval)\n+{\n+  m_reachable_svals.add (sval);\n+  if (const region_svalue *ptr = sval->dyn_cast_region_svalue ())\n+    {\n+      const region *pointee = ptr->get_pointee ();\n+      /* Use const-ness of pointer type to affect mutability.  */\n+      bool ptr_is_mutable = true;\n+      if (ptr->get_type ()\n+\t  && TREE_CODE (ptr->get_type ()) == POINTER_TYPE\n+\t  && TYPE_READONLY (TREE_TYPE (ptr->get_type ())))\n+\t{\n+\t  ptr_is_mutable = false;\n+\t}\n+      else\n+\t{\n+\t  m_mutable_svals.add (sval);\n+\t}\n+      add (pointee, ptr_is_mutable);\n+    }\n+  /* Treat all svalues within a compound_svalue as reachable.  */\n+  if (const compound_svalue *compound_sval\n+      = sval->dyn_cast_compound_svalue ())\n+    {\n+      for (compound_svalue::iterator_t iter = compound_sval->begin ();\n+\t   iter != compound_sval->end (); ++iter)\n+\t{\n+\t  const svalue *iter_sval = (*iter).second;\n+\t  handle_sval (iter_sval);\n+\t}\n+    }\n+  if (const svalue *cast = sval->maybe_undo_cast ())\n+    handle_sval (cast);\n+}\n+\n+/* Add SVAL.  If it is a pointer, add the pointed-to region.\n+   Use PARAM_TYPE for determining mutability.  */\n+\n+void\n+reachable_regions::handle_parm (const svalue *sval, tree param_type)\n+{\n+  bool is_mutable = true;\n+  if (param_type\n+      && TREE_CODE (param_type) == POINTER_TYPE\n+      &&  TYPE_READONLY (TREE_TYPE (param_type)))\n+    is_mutable = false;\n+  if (is_mutable)\n+    m_mutable_svals.add (sval);\n+  else\n+    m_reachable_svals.add (sval);\n+  if (const region_svalue *parm_ptr\n+      = sval->dyn_cast_region_svalue ())\n+    {\n+      const region *pointee_reg = parm_ptr->get_pointee ();\n+      add (pointee_reg, is_mutable);\n+    }\n+}\n+\n+/* Update m_store to mark the clusters that were found to be mutable\n+   as having escaped.  */\n+\n+void\n+reachable_regions::mark_escaped_clusters ()\n+{\n+  for (hash_set<const region *>::iterator iter = m_mutable_base_regs.begin ();\n+       iter != m_mutable_base_regs.end (); ++iter)\n+    {\n+      const region *base_reg = *iter;\n+      m_store->mark_as_escaped (base_reg);\n+    }\n+}\n+\n+/* Dump a multiline representation of this object to PP.  */\n+\n+void\n+reachable_regions::dump_to_pp (pretty_printer *pp) const\n+{\n+  pp_string (pp, \"reachable clusters: \");\n+  pp_newline (pp);\n+  for (hash_set<const region *>::iterator iter = m_reachable_base_regs.begin ();\n+       iter != m_reachable_base_regs.end (); ++iter)\n+    {\n+      pp_string (pp, \"  \");\n+      (*iter)->dump_to_pp (pp, true);\n+      pp_newline (pp);\n+    }\n+  pp_string (pp, \"mutable clusters: \");\n+  pp_newline (pp);\n+  for (hash_set<const region *>::iterator iter = m_mutable_base_regs.begin ();\n+       iter != m_mutable_base_regs.end (); ++iter)\n+    {\n+      pp_string (pp, \"  \");\n+      (*iter)->dump_to_pp (pp, true);\n+      pp_newline (pp);\n+    }\n+  pp_string (pp, \"reachable svals: \");\n+  pp_newline (pp);\n+  for (svalue_set::iterator iter = m_reachable_svals.begin ();\n+       iter != m_reachable_svals.end (); ++iter)\n+    {\n+      pp_string (pp, \"  \");\n+      (*iter)->dump_to_pp (pp, true);\n+      pp_newline (pp);\n+    }\n+  pp_string (pp, \"mutable svals: \");\n+  pp_newline (pp);\n+  for (svalue_set::iterator iter = m_mutable_svals.begin ();\n+       iter != m_mutable_svals.end (); ++iter)\n+    {\n+      pp_string (pp, \"  \");\n+      (*iter)->dump_to_pp (pp, true);\n+      pp_newline (pp);\n+    }\n+}\n+\n+/* Dump a multiline representation of this object to stderr.  */\n+\n+DEBUG_FUNCTION void\n+reachable_regions::dump () const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = stderr;\n+  dump_to_pp (&pp);\n+  pp_flush (&pp);\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "aba1a58ec7f0cb6a57664f47b5e8f297f0ac1af6", "filename": "gcc/analyzer/region-model-reachability.h", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fregion-model-reachability.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fregion-model-reachability.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-reachability.h?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,117 @@\n+/* Finding reachable regions and values.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_REGION_MODEL_REACHABILITY_H\n+#define GCC_ANALYZER_REGION_MODEL_REACHABILITY_H\n+\n+namespace ana {\n+\n+/* A class for determining which regions and svalues are reachable.\n+\n+   Used by region_model::handle_unrecognized_call for keeping\n+   track of all regions that are reachable, and, of those, which are\n+   mutable.\n+\n+   Used by program_state::detect_leaks\n+   (via region_model::get_reachable_svalues) for detecting leaks.  */\n+\n+class reachable_regions\n+{\n+public:\n+  reachable_regions (store *store, region_model_manager *mgr);\n+\n+  /* Callback called for each cluster when initializing this object.  */\n+  static void init_cluster_cb (const region *base_reg,\n+\t\t\t       reachable_regions *this_ptr);\n+\n+  /* Called for each cluster when initializing this object.  */\n+  void init_cluster (const region *base_reg);\n+\n+  /* Lazily mark the cluster containing REG as being reachable, recursively\n+     adding clusters reachable from REG's cluster.  */\n+  void add (const region *reg, bool is_mutable);\n+\n+  static void handle_sval_cb (const svalue *sval,\n+\t\t\t      reachable_regions *this_ptr);\n+\n+  /* Add SVAL.  If it is a pointer, add the pointed-to region.  */\n+  void handle_sval (const svalue *sval);\n+\n+  /* Add SVAL.  If it is a pointer, add the pointed-to region.\n+     Use PARAM_TYPE for determining mutability.  */\n+  void handle_parm (const svalue *sval, tree param_type);\n+\n+  /* Update the store to mark the clusters that were found to be mutable\n+     as having escaped.  */\n+  void mark_escaped_clusters ();\n+\n+  /* Iteration over reachable base regions.  */\n+  hash_set<const region *>::iterator begin ()\n+  {\n+    return m_reachable_base_regs.begin ();\n+  }\n+  hash_set<const region *>::iterator end ()\n+  {\n+    return m_reachable_base_regs.end ();\n+  }\n+\n+  svalue_set::iterator begin_reachable_svals ()\n+  {\n+    return m_reachable_svals.begin ();\n+  }\n+  svalue_set::iterator end_reachable_svals ()\n+  {\n+    return m_reachable_svals.end ();\n+  }\n+  svalue_set::iterator begin_mutable_svals ()\n+  {\n+    return m_mutable_svals.begin ();\n+  }\n+  svalue_set::iterator end_mutable_svals ()\n+  {\n+    return m_mutable_svals.end ();\n+  }\n+\n+  void dump_to_pp (pretty_printer *pp) const;\n+\n+  DEBUG_FUNCTION void dump () const;\n+\n+private:\n+  store *m_store;\n+  region_model_manager *m_mgr;\n+\n+  /* The base regions already seen.  */\n+  hash_set<const region *> m_reachable_base_regs;\n+\n+  /* The base regions that can be changed (accessed via non-const pointers).  */\n+  hash_set<const region *> m_mutable_base_regs;\n+\n+  /* svalues that were passed as const pointers, so e.g. couldn't have\n+     been freed (but could have e.g. had \"close\" called on them if an\n+     int file-descriptor).  */\n+  svalue_set m_reachable_svals;\n+  /* svalues that were passed as non-const pointers, so e.g. could have\n+     been freed.  */\n+  svalue_set m_mutable_svals;\n+};\n+\n+} // namespace ana\n+\n+#endif /* GCC_ANALYZER_REGION_MODEL_REACHABILITY_H */"}, {"sha": "649e20438e4241d50faba4b08fa13a25a493e344", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 2338, "deletions": 6593, "changes": 8931, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d"}, {"sha": "33aa3461611661cf3d0cde4df3cb646ed38251d7", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 1908, "deletions": 1232, "changes": 3140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d"}, {"sha": "f3f577c43de9d4e8b9cfad4ce4b325a92e11495c", "filename": "gcc/analyzer/region.cc", "status": "added", "additions": 1064, "deletions": 0, "changes": 1064, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fregion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fregion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,1064 @@\n+/* Regions of memory.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"diagnostic-core.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"diagnostic-core.h\"\n+#include \"graphviz.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"tree-dfa.h\"\n+#include \"stringpool.h\"\n+#include \"convert.h\"\n+#include \"target.h\"\n+#include \"fold-const.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"diagnostic-color.h\"\n+#include \"diagnostic-metadata.h\"\n+#include \"tristate.h\"\n+#include \"bitmap.h\"\n+#include \"selftest.h\"\n+#include \"function.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"cfg.h\"\n+#include \"digraph.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"sbitmap.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/region-model.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* class region and its various subclasses.  */\n+\n+/* class region.  */\n+\n+region::~region ()\n+{\n+  delete m_cached_offset;\n+}\n+\n+/* Compare REG1 and REG2 by id.  */\n+\n+int\n+region::cmp_ids (const region *reg1, const region *reg2)\n+{\n+  return (long)reg1->get_id () - (long)reg2->get_id ();\n+}\n+\n+/* Determine the base region for this region: when considering bindings\n+   for this region, the base region is the ancestor which identifies\n+   which cluster they should be partitioned into.\n+   Regions within the same struct/union/array are in the same cluster.\n+   Different decls are in different clusters.  */\n+\n+const region *\n+region::get_base_region () const\n+{\n+  const region *iter = this;\n+  while (iter)\n+    {\n+      switch (iter->get_kind ())\n+\t{\n+\tcase RK_FIELD:\n+\tcase RK_ELEMENT:\n+\tcase RK_OFFSET:\n+\t  iter = iter->get_parent_region ();\n+\t  continue;\n+\tcase RK_CAST:\n+\t  iter = iter->dyn_cast_cast_region ()->get_original_region ();\n+\t  continue;\n+\tdefault:\n+\t  return iter;\n+\t}\n+    }\n+  return iter;\n+}\n+\n+/* Return true if get_base_region() == this for this region.  */\n+\n+bool\n+region::base_region_p () const\n+{\n+  switch (get_kind ())\n+    {\n+    /* Region kinds representing a descendent of a base region.  */\n+    case RK_FIELD:\n+    case RK_ELEMENT:\n+    case RK_OFFSET:\n+    case RK_CAST:\n+      return false;\n+\n+    default:\n+      return true;\n+    }\n+}\n+\n+/* Return true if this region is ELDER or one of its descendents.  */\n+\n+bool\n+region::descendent_of_p (const region *elder) const\n+{\n+  const region *iter = this;\n+  while (iter)\n+    {\n+      if (iter == elder)\n+\treturn true;\n+      if (iter->get_kind () == RK_CAST)\n+\titer = iter->dyn_cast_cast_region ()->get_original_region ();\n+      else\n+\titer = iter->get_parent_region ();\n+    }\n+  return false;\n+}\n+\n+/* If this region is a frame_region, or a descendent of one, return it.\n+   Otherwise return NULL.  */\n+\n+const frame_region *\n+region::maybe_get_frame_region () const\n+{\n+  const region *iter = this;\n+  while (iter)\n+    {\n+      if (const frame_region *frame_reg = iter->dyn_cast_frame_region ())\n+\treturn frame_reg;\n+      if (iter->get_kind () == RK_CAST)\n+\titer = iter->dyn_cast_cast_region ()->get_original_region ();\n+      else\n+\titer = iter->get_parent_region ();\n+    }\n+  return NULL;\n+}\n+\n+/* If this region is a decl_region, return the decl.\n+   Otherwise return NULL.  */\n+\n+tree\n+region::maybe_get_decl () const\n+{\n+  if (const decl_region *decl_reg = dyn_cast_decl_region ())\n+    return decl_reg->get_decl ();\n+  return NULL_TREE;\n+}\n+\n+/* Get the region_offset for this region (calculating it on the\n+   first call and caching it internally).  */\n+\n+region_offset\n+region::get_offset () const\n+{\n+  if(!m_cached_offset)\n+    m_cached_offset = new region_offset (calc_offset ());\n+  return *m_cached_offset;\n+}\n+\n+/* If the size of this region (in bytes) is known statically, write it to *OUT\n+   and return true.\n+   Otherwise return false.  */\n+\n+bool\n+region::get_byte_size (byte_size_t *out) const\n+{\n+  tree type = get_type ();\n+\n+  /* Bail out e.g. for heap-allocated regions.  */\n+  if (!type)\n+    return false;\n+\n+  HOST_WIDE_INT bytes = int_size_in_bytes (type);\n+  if (bytes == -1)\n+    return false;\n+  *out = bytes;\n+  return true;\n+}\n+\n+/* If the size of this region (in bits) is known statically, write it to *OUT\n+   and return true.\n+   Otherwise return false.  */\n+\n+bool\n+region::get_bit_size (bit_size_t *out) const\n+{\n+  byte_size_t byte_size;\n+  if (!get_byte_size (&byte_size))\n+    return false;\n+  *out = byte_size * BITS_PER_UNIT;\n+  return true;\n+}\n+\n+/* Get the field within RECORD_TYPE at BIT_OFFSET.  */\n+\n+static tree\n+get_field_at_bit_offset (tree record_type, bit_offset_t bit_offset)\n+{\n+  gcc_assert (TREE_CODE (record_type) == RECORD_TYPE);\n+  gcc_assert (bit_offset >= 0);\n+\n+  /* Find the first field that has an offset > BIT_OFFSET,\n+     then return the one preceding it.\n+     Skip other trees within the chain, such as FUNCTION_DECLs.  */\n+  tree last_field = NULL_TREE;\n+  for (tree iter = TYPE_FIELDS (record_type); iter != NULL_TREE;\n+       iter = DECL_CHAIN (iter))\n+    {\n+      if (TREE_CODE (iter) == FIELD_DECL)\n+\t{\n+\t  int iter_field_offset = int_bit_position (iter);\n+\t  if (bit_offset < iter_field_offset)\n+\t    return last_field;\n+\t  last_field = iter;\n+\t}\n+    }\n+  return last_field;\n+}\n+\n+/* Populate *OUT with descendent regions of type TYPE that match\n+   RELATIVE_BIT_OFFSET and SIZE_IN_BITS within this region.  */\n+\n+void\n+region::get_subregions_for_binding (region_model_manager *mgr,\n+\t\t\t\t    bit_offset_t relative_bit_offset,\n+\t\t\t\t    bit_size_t size_in_bits,\n+\t\t\t\t    tree type,\n+\t\t\t\t    auto_vec <const region *> *out) const\n+{\n+  if (get_type () == NULL_TREE)\n+    return;\n+  if (relative_bit_offset == 0\n+      && types_compatible_p (get_type (), type))\n+    {\n+      out->safe_push (this);\n+      return;\n+    }\n+  switch (TREE_CODE (get_type ()))\n+    {\n+    case ARRAY_TYPE:\n+      {\n+\ttree element_type = TREE_TYPE (get_type ());\n+\tHOST_WIDE_INT hwi_byte_size = int_size_in_bytes (element_type);\n+\tif (hwi_byte_size > 0)\n+\t  {\n+\t    HOST_WIDE_INT bits_per_element\n+\t      = hwi_byte_size << LOG2_BITS_PER_UNIT;\n+\t    HOST_WIDE_INT element_index\n+\t      = (relative_bit_offset.to_shwi () / bits_per_element);\n+\t    tree element_index_cst\n+\t      = build_int_cst (integer_type_node, element_index);\n+\t    HOST_WIDE_INT inner_bit_offset\n+\t      = relative_bit_offset.to_shwi () % bits_per_element;\n+\t    const region *subregion = mgr->get_element_region\n+\t      (this, element_type,\n+\t       mgr->get_or_create_constant_svalue (element_index_cst));\n+\t    subregion->get_subregions_for_binding (mgr, inner_bit_offset,\n+\t\t\t\t\t\t   size_in_bits, type, out);\n+\t  }\n+      }\n+      break;\n+    case RECORD_TYPE:\n+      {\n+\t/* The bit offset might be *within* one of the fields (such as\n+\t   with nested structs).\n+\t   So we want to find the enclosing field, adjust the offset,\n+\t   and repeat.  */\n+\tif (tree field = get_field_at_bit_offset (get_type (),\n+\t\t\t\t\t\t  relative_bit_offset))\n+\t  {\n+\t    int field_bit_offset = int_bit_position (field);\n+\t    const region *subregion = mgr->get_field_region (this, field);\n+\t    subregion->get_subregions_for_binding\n+\t      (mgr, relative_bit_offset - field_bit_offset,\n+\t       size_in_bits, type, out);\n+\t  }\n+      }\n+      break;\n+    case UNION_TYPE:\n+      {\n+\tfor (tree field = TYPE_FIELDS (get_type ()); field != NULL_TREE;\n+\t     field = DECL_CHAIN (field))\n+\t  {\n+\t    const region *subregion = mgr->get_field_region (this, field);\n+\t    subregion->get_subregions_for_binding (mgr,\n+\t\t\t\t\t\t   relative_bit_offset,\n+\t\t\t\t\t\t   size_in_bits,\n+\t\t\t\t\t\t   type,\n+\t\t\t\t\t\t   out);\n+\t  }\n+      }\n+      break;\n+    default:\n+      /* Do nothing.  */\n+      break;\n+    }\n+}\n+\n+/* Walk from this region up to the base region within its cluster, calculating\n+   the offset relative to the base region, either as an offset in bits,\n+   or a symbolic offset.  */\n+\n+region_offset\n+region::calc_offset () const\n+{\n+  const region *iter_region = this;\n+  bit_offset_t accum_bit_offset = 0;\n+\n+  while (iter_region)\n+    {\n+      switch (iter_region->get_kind ())\n+\t{\n+\tcase RK_FIELD:\n+\t  {\n+\t    const field_region *field_reg\n+\t      = (const field_region *)iter_region;\n+\t    iter_region = iter_region->get_parent_region ();\n+\n+\t    /* Compare with e.g. gimple-fold.c's\n+\t       fold_nonarray_ctor_reference.  */\n+\t    tree field = field_reg->get_field ();\n+\t    tree byte_offset = DECL_FIELD_OFFSET (field);\n+\t    if (TREE_CODE (byte_offset) != INTEGER_CST)\n+\t      return region_offset::make_symbolic (iter_region);\n+\t    tree field_offset = DECL_FIELD_BIT_OFFSET (field);\n+\t    /* Compute bit offset of the field.  */\n+\t    offset_int bitoffset\n+\t      = (wi::to_offset (field_offset)\n+\t\t + (wi::to_offset (byte_offset) << LOG2_BITS_PER_UNIT));\n+\t    accum_bit_offset += bitoffset;\n+\t  }\n+\t  continue;\n+\n+\tcase RK_ELEMENT:\n+\t  {\n+\t    const element_region *element_reg\n+\t      = (const element_region *)iter_region;\n+\t    iter_region = iter_region->get_parent_region ();\n+\n+\t    if (tree idx_cst\n+\t\t  = element_reg->get_index ()->maybe_get_constant ())\n+\t      {\n+\t\tgcc_assert (TREE_CODE (idx_cst) == INTEGER_CST);\n+\n+\t\ttree elem_type = element_reg->get_type ();\n+\t\toffset_int element_idx = wi::to_offset (idx_cst);\n+\n+\t\t/* First, use int_size_in_bytes, to reject the case where we\n+\t\t   have an incomplete type, or a non-constant value.  */\n+\t\tHOST_WIDE_INT hwi_byte_size = int_size_in_bytes (elem_type);\n+\t\tif (hwi_byte_size > 0)\n+\t\t  {\n+\t\t    offset_int element_bit_size\n+\t\t      = hwi_byte_size << LOG2_BITS_PER_UNIT;\n+\t\t    offset_int element_bit_offset\n+\t\t      = element_idx * element_bit_size;\n+\t\t    accum_bit_offset += element_bit_offset;\n+\t\t    continue;\n+\t\t  }\n+\t      }\n+\t    return region_offset::make_symbolic (iter_region);\n+\t  }\n+\t  continue;\n+\n+\tcase RK_OFFSET:\n+\t  {\n+\t    const offset_region *offset_reg\n+\t      = (const offset_region *)iter_region;\n+\t    iter_region = iter_region->get_parent_region ();\n+\n+\t    if (tree byte_offset_cst\n+\t\t  = offset_reg->get_byte_offset ()->maybe_get_constant ())\n+\t      {\n+\t\tgcc_assert (TREE_CODE (byte_offset_cst) == INTEGER_CST);\n+\t\t/* Use a signed value for the byte offset, to handle\n+\t\t   negative offsets.  */\n+\t\tHOST_WIDE_INT byte_offset\n+\t\t  = wi::to_offset (byte_offset_cst).to_shwi ();\n+\t\tHOST_WIDE_INT bit_offset = byte_offset * BITS_PER_UNIT;\n+\t\taccum_bit_offset += bit_offset;\n+\t      }\n+\t    else\n+\t      return region_offset::make_symbolic (iter_region);\n+\t  }\n+\t  continue;\n+\n+\tcase RK_CAST:\n+\t  {\n+\t    const cast_region *cast_reg\n+\t      = as_a <const cast_region *> (iter_region);\n+\t    iter_region = cast_reg->get_original_region ();\n+\t  }\n+\t  continue;\n+\n+\tdefault:\n+\t  return region_offset::make_concrete (iter_region, accum_bit_offset);\n+\t}\n+    }\n+  return region_offset::make_concrete (iter_region, accum_bit_offset);\n+}\n+\n+/* Copy from SRC_REG to DST_REG, using CTXT for any issues that occur.  */\n+\n+void\n+region_model::copy_region (const region *dst_reg, const region *src_reg,\n+\t\t\t   region_model_context *ctxt)\n+{\n+  gcc_assert (dst_reg);\n+  gcc_assert (src_reg);\n+  if (dst_reg == src_reg)\n+    return;\n+\n+  const svalue *sval = get_store_value (src_reg);\n+  set_value (dst_reg, sval, ctxt);\n+}\n+\n+/* Dump a description of this region to stderr.  */\n+\n+DEBUG_FUNCTION void\n+region::dump (bool simple) const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = stderr;\n+  dump_to_pp (&pp, simple);\n+  pp_newline (&pp);\n+  pp_flush (&pp);\n+}\n+\n+/* Generate a description of this region.  */\n+\n+DEBUG_FUNCTION label_text\n+region::get_desc (bool simple) const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  dump_to_pp (&pp, simple);\n+  return label_text::take (xstrdup (pp_formatted_text (&pp)));\n+}\n+\n+/* Base implementation of region::accept vfunc.\n+   Subclass implementations should chain up to this.  */\n+\n+void\n+region::accept (visitor *v) const\n+{\n+  v->visit_region (this);\n+  if (m_parent)\n+    m_parent->accept (v);\n+}\n+\n+/* Return true if this is a symbolic region for deferencing an\n+   unknown ptr.\n+   We shouldn't attempt to bind values for this region (but\n+   can unbind values for other regions).  */\n+\n+bool\n+region::symbolic_for_unknown_ptr_p () const\n+{\n+  if (const symbolic_region *sym_reg = dyn_cast_symbolic_region ())\n+    if (sym_reg->get_pointer ()->get_kind () == SK_UNKNOWN)\n+      return true;\n+  return false;\n+}\n+\n+/* region's ctor.  */\n+\n+region::region (complexity c, unsigned id, const region *parent, tree type)\n+: m_complexity (c), m_id (id), m_parent (parent), m_type (type),\n+  m_cached_offset (NULL)\n+{\n+  gcc_assert (type == NULL_TREE || TYPE_P (type));\n+}\n+\n+/* Comparator for regions, using their IDs to order them.  */\n+\n+int\n+region::cmp_ptrs (const void *p1, const void *p2)\n+{\n+  const region * const *reg1 = (const region * const *)p1;\n+  const region * const *reg2 = (const region * const *)p2;\n+\n+  return cmp_ids (*reg1, *reg2);\n+}\n+\n+/* Determine if a pointer to this region must be non-NULL.\n+\n+   Generally, pointers to regions must be non-NULL, but pointers\n+   to symbolic_regions might, in fact, be NULL.\n+\n+   This allows us to simulate functions like malloc and calloc with:\n+   - only one \"outcome\" from each statement,\n+   - the idea that the pointer is on the heap if non-NULL\n+   - the possibility that the pointer could be NULL\n+   - the idea that successive values returned from malloc are non-equal\n+   - to be able to zero-fill for calloc.  */\n+\n+bool\n+region::non_null_p () const\n+{\n+  switch (get_kind ())\n+    {\n+    default:\n+      return true;\n+    case RK_SYMBOLIC:\n+      /* Are we within a symbolic_region?  If so, it could be NULL, and we\n+\t have to fall back on the constraints.  */\n+      return false;\n+    case RK_HEAP_ALLOCATED:\n+      return false;\n+    }\n+}\n+\n+/* Comparator for trees to impose a deterministic ordering on\n+   T1 and T2.  */\n+\n+static int\n+tree_cmp (const_tree t1, const_tree t2)\n+{\n+  gcc_assert (t1);\n+  gcc_assert (t2);\n+\n+  /* Test tree codes first.  */\n+  if (TREE_CODE (t1) != TREE_CODE (t2))\n+    return TREE_CODE (t1) - TREE_CODE (t2);\n+\n+  /* From this point on, we know T1 and T2 have the same tree code.  */\n+\n+  if (DECL_P (t1))\n+    {\n+      if (DECL_NAME (t1) && DECL_NAME (t2))\n+\treturn strcmp (IDENTIFIER_POINTER (DECL_NAME (t1)),\n+\t\t       IDENTIFIER_POINTER (DECL_NAME (t2)));\n+      else\n+\t{\n+\t  if (DECL_NAME (t1))\n+\t    return -1;\n+\t  else if (DECL_NAME (t2))\n+\t    return 1;\n+\t  else\n+\t    return DECL_UID (t1) - DECL_UID (t2);\n+\t}\n+    }\n+\n+  switch (TREE_CODE (t1))\n+    {\n+    case SSA_NAME:\n+      {\n+\tif (SSA_NAME_VAR (t1) && SSA_NAME_VAR (t2))\n+\t  {\n+\t    int var_cmp = tree_cmp (SSA_NAME_VAR (t1), SSA_NAME_VAR (t2));\n+\t    if (var_cmp)\n+\t      return var_cmp;\n+\t    return SSA_NAME_VERSION (t1) - SSA_NAME_VERSION (t2);\n+\t  }\n+\telse\n+\t  {\n+\t    if (SSA_NAME_VAR (t1))\n+\t      return -1;\n+\t    else if (SSA_NAME_VAR (t2))\n+\t      return 1;\n+\t    else\n+\t      return SSA_NAME_VERSION (t1) - SSA_NAME_VERSION (t2);\n+\t  }\n+      }\n+      break;\n+\n+    case INTEGER_CST:\n+      return tree_int_cst_compare (t1, t2);\n+\n+    case REAL_CST:\n+      {\n+\tconst real_value *rv1 = TREE_REAL_CST_PTR (t1);\n+\tconst real_value *rv2 = TREE_REAL_CST_PTR (t2);\n+\tif (real_compare (UNORDERED_EXPR, rv1, rv2))\n+\t  {\n+\t    /* Impose an arbitrary order on NaNs relative to other NaNs\n+\t       and to non-NaNs.  */\n+\t    if (int cmp_isnan = real_isnan (rv1) - real_isnan (rv2))\n+\t      return cmp_isnan;\n+\t    if (int cmp_issignaling_nan\n+\t\t  = real_issignaling_nan (rv1) - real_issignaling_nan (rv2))\n+\t      return cmp_issignaling_nan;\n+\t    return real_isneg (rv1) - real_isneg (rv2);\n+\t  }\n+\tif (real_compare (LT_EXPR, rv1, rv2))\n+\t  return -1;\n+\tif (real_compare (GT_EXPR, rv1, rv2))\n+\t  return 1;\n+\treturn 0;\n+      }\n+\n+    case STRING_CST:\n+      return strcmp (TREE_STRING_POINTER (t1),\n+\t\t     TREE_STRING_POINTER (t2));\n+\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+\n+  gcc_unreachable ();\n+\n+  return 0;\n+}\n+\n+/* qsort comparator for trees to impose a deterministic ordering on\n+   P1 and P2.  */\n+\n+int\n+tree_cmp (const void *p1, const void *p2)\n+{\n+  const_tree t1 = *(const_tree const *)p1;\n+  const_tree t2 = *(const_tree const *)p2;\n+\n+  return tree_cmp (t1, t2);\n+}\n+\n+/* class frame_region : public space_region.  */\n+\n+frame_region::~frame_region ()\n+{\n+  for (map_t::iterator iter = m_locals.begin ();\n+       iter != m_locals.end ();\n+       ++iter)\n+    delete (*iter).second;\n+}\n+\n+void\n+frame_region::accept (visitor *v) const\n+{\n+  region::accept (v);\n+  if (m_calling_frame)\n+    m_calling_frame->accept (v);\n+}\n+\n+/* Implementation of region::dump_to_pp vfunc for frame_region.  */\n+\n+void\n+frame_region::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    pp_printf (pp, \"frame: %qs@%i\", function_name (m_fun), get_stack_depth ());\n+  else\n+    pp_printf (pp, \"frame_region(%qs, index: %i, depth: %i)\",\n+\t       function_name (m_fun), m_index, get_stack_depth ());\n+}\n+\n+const decl_region *\n+frame_region::get_region_for_local (region_model_manager *mgr,\n+\t\t\t\t    tree expr) const\n+{\n+  // TODO: could also check that VAR_DECLs are locals\n+  gcc_assert (TREE_CODE (expr) == PARM_DECL\n+\t      || TREE_CODE (expr) == VAR_DECL\n+\t      || TREE_CODE (expr) == SSA_NAME\n+\t      || TREE_CODE (expr) == RESULT_DECL);\n+\n+  /* Ideally we'd use mutable here.  */\n+  map_t &mutable_locals = const_cast <map_t &> (m_locals);\n+\n+  if (decl_region **slot = mutable_locals.get (expr))\n+    return *slot;\n+  decl_region *reg\n+    = new decl_region (mgr->alloc_region_id (), this, expr);\n+  mutable_locals.put (expr, reg);\n+  return reg;\n+}\n+\n+/* class globals_region : public space_region.  */\n+\n+/* Implementation of region::dump_to_pp vfunc for globals_region.  */\n+\n+void\n+globals_region::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    pp_string (pp, \"::\");\n+  else\n+    pp_string (pp, \"globals\");\n+}\n+\n+/* class code_region : public map_region.  */\n+\n+/* Implementation of region::dump_to_pp vfunc for code_region.  */\n+\n+void\n+code_region::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    pp_string (pp, \"code region\");\n+  else\n+    pp_string (pp, \"code_region()\");\n+}\n+\n+/* class function_region : public region.  */\n+\n+/* Implementation of region::dump_to_pp vfunc for function_region.  */\n+\n+void\n+function_region::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    {\n+      dump_quoted_tree (pp, m_fndecl);\n+    }\n+  else\n+    {\n+      pp_string (pp, \"function_region(\");\n+      dump_quoted_tree (pp, m_fndecl);\n+      pp_string (pp, \")\");\n+    }\n+}\n+\n+/* class label_region : public region.  */\n+\n+/* Implementation of region::dump_to_pp vfunc for label_region.  */\n+\n+void\n+label_region::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    {\n+      dump_quoted_tree (pp, m_label);\n+    }\n+  else\n+    {\n+      pp_string (pp, \"label_region(\");\n+      dump_quoted_tree (pp, m_label);\n+      pp_string (pp, \")\");\n+    }\n+}\n+\n+/* class stack_region : public region.  */\n+\n+/* Implementation of region::dump_to_pp vfunc for stack_region.  */\n+\n+void\n+stack_region::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    pp_string (pp, \"stack region\");\n+  else\n+    pp_string (pp, \"stack_region()\");\n+}\n+\n+/* class heap_region : public region.  */\n+\n+/* Implementation of region::dump_to_pp vfunc for heap_region.  */\n+\n+void\n+heap_region::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    pp_string (pp, \"heap region\");\n+  else\n+    pp_string (pp, \"heap_region()\");\n+}\n+\n+/* class root_region : public region.  */\n+\n+/* root_region's ctor.  */\n+\n+root_region::root_region (unsigned id)\n+: region (complexity (1, 1), id, NULL, NULL_TREE)\n+{\n+}\n+\n+/* Implementation of region::dump_to_pp vfunc for root_region.  */\n+\n+void\n+root_region::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    pp_string (pp, \"root region\");\n+  else\n+    pp_string (pp, \"root_region()\");\n+}\n+\n+/* class symbolic_region : public map_region.  */\n+\n+/* Implementation of region::accept vfunc for symbolic_region.  */\n+\n+void\n+symbolic_region::accept (visitor *v) const\n+{\n+  region::accept (v);\n+  m_sval_ptr->accept (v);\n+}\n+\n+/* Implementation of region::dump_to_pp vfunc for symbolic_region.  */\n+\n+void\n+symbolic_region::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    {\n+      pp_string (pp, \"(*\");\n+      m_sval_ptr->dump_to_pp (pp, simple);\n+      pp_string (pp, \")\");\n+    }\n+  else\n+    {\n+      pp_string (pp, \"symbolic_region(\");\n+      get_parent_region ()->dump_to_pp (pp, simple);\n+      pp_string (pp, \", \");\n+      print_quoted_type (pp, get_type ());\n+      pp_string (pp, \", \");\n+      m_sval_ptr->dump_to_pp (pp, simple);\n+      pp_string (pp, \")\");\n+    }\n+}\n+\n+/* class decl_region : public region.  */\n+\n+/* Implementation of region::dump_to_pp vfunc for decl_region.  */\n+\n+void\n+decl_region::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    pp_printf (pp, \"%E\", m_decl);\n+  else\n+    {\n+      pp_string (pp, \"decl_region(\");\n+      get_parent_region ()->dump_to_pp (pp, simple);\n+      pp_string (pp, \", \");\n+      print_quoted_type (pp, get_type ());\n+      pp_printf (pp, \", %qE)\", m_decl);\n+    }\n+}\n+\n+/* Get the stack depth for the frame containing this decl, or 0\n+   for a global.  */\n+\n+int\n+decl_region::get_stack_depth () const\n+{\n+  if (get_parent_region () == NULL)\n+    return 0;\n+  if (const frame_region *frame_reg\n+\t= get_parent_region ()->dyn_cast_frame_region ())\n+    return frame_reg->get_stack_depth ();\n+  return 0;\n+}\n+\n+/* class field_region : public region.  */\n+\n+/* Implementation of region::dump_to_pp vfunc for field_region.  */\n+\n+void\n+field_region::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    {\n+      get_parent_region ()->dump_to_pp (pp, simple);\n+      pp_string (pp, \".\");\n+      pp_printf (pp, \"%E\", m_field);\n+    }\n+  else\n+    {\n+      pp_string (pp, \"field_region(\");\n+      get_parent_region ()->dump_to_pp (pp, simple);\n+      pp_string (pp, \", \");\n+      print_quoted_type (pp, get_type ());\n+      pp_printf (pp, \", %qE)\", m_field);\n+    }\n+}\n+\n+/* class element_region : public region.  */\n+\n+/* Implementation of region::accept vfunc for element_region.  */\n+\n+void\n+element_region::accept (visitor *v) const\n+{\n+  region::accept (v);\n+  m_index->accept (v);\n+}\n+\n+/* Implementation of region::dump_to_pp vfunc for element_region.  */\n+\n+void\n+element_region::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    {\n+      //pp_string (pp, \"(\");\n+      get_parent_region ()->dump_to_pp (pp, simple);\n+      pp_string (pp, \"[\");\n+      m_index->dump_to_pp (pp, simple);\n+      pp_string (pp, \"]\");\n+      //pp_string (pp, \")\");\n+    }\n+  else\n+    {\n+      pp_string (pp, \"element_region(\");\n+      get_parent_region ()->dump_to_pp (pp, simple);\n+      pp_string (pp, \", \");\n+      print_quoted_type (pp, get_type ());\n+      pp_string (pp, \", \");\n+      m_index->dump_to_pp (pp, simple);\n+      pp_printf (pp, \")\");\n+    }\n+}\n+\n+/* class offset_region : public region.  */\n+\n+/* Implementation of region::accept vfunc for offset_region.  */\n+\n+void\n+offset_region::accept (visitor *v) const\n+{\n+  region::accept (v);\n+  m_byte_offset->accept (v);\n+}\n+\n+/* Implementation of region::dump_to_pp vfunc for offset_region.  */\n+\n+void\n+offset_region::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    {\n+      //pp_string (pp, \"(\");\n+      get_parent_region ()->dump_to_pp (pp, simple);\n+      pp_string (pp, \"+\");\n+      m_byte_offset->dump_to_pp (pp, simple);\n+      //pp_string (pp, \")\");\n+    }\n+  else\n+    {\n+      pp_string (pp, \"offset_region(\");\n+      get_parent_region ()->dump_to_pp (pp, simple);\n+      pp_string (pp, \", \");\n+      print_quoted_type (pp, get_type ());\n+      pp_string (pp, \", \");\n+      m_byte_offset->dump_to_pp (pp, simple);\n+      pp_printf (pp, \")\");\n+    }\n+}\n+\n+/* class cast_region : public region.  */\n+\n+/* Implementation of region::accept vfunc for cast_region.  */\n+\n+void\n+cast_region::accept (visitor *v) const\n+{\n+  region::accept (v);\n+  m_original_region->accept (v);\n+}\n+\n+/* Implementation of region::dump_to_pp vfunc for cast_region.  */\n+\n+void\n+cast_region::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    {\n+      pp_string (pp, \"CAST_REG(\");\n+      print_quoted_type (pp, get_type ());\n+      pp_string (pp, \", \");\n+      m_original_region->dump_to_pp (pp, simple);\n+      pp_string (pp, \")\");\n+    }\n+  else\n+    {\n+      pp_string (pp, \"cast_region(\");\n+      m_original_region->dump_to_pp (pp, simple);\n+      pp_string (pp, \", \");\n+      print_quoted_type (pp, get_type ());\n+      pp_printf (pp, \")\");\n+    }\n+}\n+\n+/* class heap_allocated_region : public region.  */\n+\n+/* Implementation of region::dump_to_pp vfunc for heap_allocated_region.  */\n+\n+void\n+heap_allocated_region::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    pp_printf (pp, \"HEAP_ALLOCATED_REGION(%i)\", get_id ());\n+  else\n+    pp_printf (pp, \"heap_allocated_region(%i)\", get_id ());\n+}\n+\n+/* class alloca_region : public region.  */\n+\n+/* Implementation of region::dump_to_pp vfunc for alloca_region.  */\n+\n+void\n+alloca_region::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    pp_string (pp, \"ALLOCA_REGION\");\n+  else\n+    pp_string (pp, \"alloca_region()\");\n+}\n+\n+/* class string_region : public region.  */\n+\n+/* Implementation of region::dump_to_pp vfunc for string_region.  */\n+\n+void\n+string_region::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    dump_tree (pp, m_string_cst);\n+  else\n+    {\n+      pp_string (pp, \"string_region(\");\n+      dump_tree (pp, m_string_cst);\n+      pp_string (pp, \" (\");\n+      pp_pointer (pp, m_string_cst);\n+      pp_string (pp, \"))\");\n+    }\n+}\n+\n+/* class unknown_region : public region.  */\n+\n+/* Implementation of region::dump_to_pp vfunc for unknown_region.  */\n+\n+void\n+unknown_region::dump_to_pp (pretty_printer *pp, bool /*simple*/) const\n+{\n+  pp_string (pp, \"UNKNOWN_REGION\");\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "eaec176d7bbd7c7605bacd2a03d311ee17e6b8d8", "filename": "gcc/analyzer/sm-file.cc", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fsm-file.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fsm-file.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-file.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -36,6 +36,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/pending-diagnostic.h\"\n #include \"analyzer/function-set.h\"\n #include \"analyzer/analyzer-selftests.h\"\n+#include \"tristate.h\"\n+#include \"selftest.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/region-model.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -52,6 +58,17 @@ class fileptr_state_machine : public state_machine\n \n   bool inherited_state_p () const FINAL OVERRIDE { return false; }\n \n+  state_machine::state_t\n+  get_default_state (const svalue *sval) const FINAL OVERRIDE\n+  {\n+    if (tree cst = sval->maybe_get_constant ())\n+      {\n+\tif (zerop (cst))\n+\t  return m_null;\n+      }\n+    return m_start;\n+  }\n+\n   bool on_stmt (sm_context *sm_ctxt,\n \t\tconst supernode *node,\n \t\tconst gimple *stmt) const FINAL OVERRIDE;\n@@ -310,10 +327,7 @@ fileptr_state_machine::on_stmt (sm_context *sm_ctxt,\n \t  {\n \t    tree lhs = gimple_call_lhs (call);\n \t    if (lhs)\n-\t      {\n-\t\tlhs = sm_ctxt->get_readable_tree (lhs);\n-\t\tsm_ctxt->on_transition (node, stmt, lhs, m_start, m_unchecked);\n-\t      }\n+\t      sm_ctxt->on_transition (node, stmt, lhs, m_start, m_unchecked);\n \t    else\n \t      {\n \t\t/* TODO: report leak.  */\n@@ -324,7 +338,7 @@ fileptr_state_machine::on_stmt (sm_context *sm_ctxt,\n \tif (is_named_call_p (callee_fndecl, \"fclose\", call, 1))\n \t  {\n \t    tree arg = gimple_call_arg (call, 0);\n-\t    arg = sm_ctxt->get_readable_tree (arg);\n+\t    tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n \n \t    sm_ctxt->on_transition (node, stmt, arg, m_start, m_closed);\n \n@@ -335,7 +349,7 @@ fileptr_state_machine::on_stmt (sm_context *sm_ctxt,\n \t    sm_ctxt->on_transition (node, stmt , arg, m_nonnull, m_closed);\n \n \t    sm_ctxt->warn_for_state (node, stmt, arg, m_closed,\n-\t\t\t\t     new double_fclose (*this, arg));\n+\t\t\t\t     new double_fclose (*this, diag_arg));\n \t    sm_ctxt->on_transition (node, stmt, arg, m_closed, m_stop);\n \t    return true;\n \t  }"}, {"sha": "ba6d41cf8ee034a2bad149e92976198adf4b532e", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 125, "deletions": 39, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -35,6 +35,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/analyzer-logging.h\"\n #include \"analyzer/sm.h\"\n #include \"analyzer/pending-diagnostic.h\"\n+#include \"tristate.h\"\n+#include \"selftest.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/region-model.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -53,6 +59,23 @@ class malloc_state_machine : public state_machine\n \n   bool inherited_state_p () const FINAL OVERRIDE { return false; }\n \n+  state_machine::state_t\n+  get_default_state (const svalue *sval) const FINAL OVERRIDE\n+  {\n+    if (tree cst = sval->maybe_get_constant ())\n+      {\n+\tif (zerop (cst))\n+\t  return m_null;\n+      }\n+    if (const region_svalue *ptr = sval->dyn_cast_region_svalue ())\n+      {\n+\tconst region *reg = ptr->get_pointee ();\n+\tif (reg->get_kind () == RK_STRING)\n+\t  return m_non_heap;\n+      }\n+    return m_start;\n+  }\n+\n   bool on_stmt (sm_context *sm_ctxt,\n \t\tconst supernode *node,\n \t\tconst gimple *stmt) const FINAL OVERRIDE;\n@@ -72,6 +95,9 @@ class malloc_state_machine : public state_machine\n   bool can_purge_p (state_t s) const FINAL OVERRIDE;\n   pending_diagnostic *on_leak (tree var) const FINAL OVERRIDE;\n \n+  bool reset_when_passed_to_unknown_fn_p (state_t s,\n+\t\t\t\t\t  bool is_mutable) const FINAL OVERRIDE;\n+\n   /* Start state.  */\n   state_t m_start;\n \n@@ -127,16 +153,34 @@ class malloc_diagnostic : public pending_diagnostic\n       return label_text::borrow (\"allocated here\");\n     if (change.m_old_state == m_sm.m_unchecked\n \t&& change.m_new_state == m_sm.m_nonnull)\n-      return change.formatted_print (\"assuming %qE is non-NULL\",\n-\t\t\t\t     change.m_expr);\n+      {\n+\tif (change.m_expr)\n+\t  return change.formatted_print (\"assuming %qE is non-NULL\",\n+\t\t\t\t\t change.m_expr);\n+\telse\n+\t  return change.formatted_print (\"assuming %qs is non-NULL\",\n+\t\t\t\t\t \"<unknown>\");\n+      }\n     if (change.m_new_state == m_sm.m_null)\n       {\n \tif (change.m_old_state == m_sm.m_unchecked)\n-\t  return change.formatted_print (\"assuming %qE is NULL\",\n-\t\t\t\t\t change.m_expr);\n+\t  {\n+\t    if (change.m_expr)\n+\t      return change.formatted_print (\"assuming %qE is NULL\",\n+\t\t\t\t\t     change.m_expr);\n+\t    else\n+\t      return change.formatted_print (\"assuming %qs is NULL\",\n+\t\t\t\t\t     \"<unknown>\");\n+\t  }\n \telse\n-\t  return change.formatted_print (\"%qE is NULL\",\n-\t\t\t\t\t change.m_expr);\n+\t  {\n+\t    if (change.m_expr)\n+\t      return change.formatted_print (\"%qE is NULL\",\n+\t\t\t\t\t     change.m_expr);\n+\t    else\n+\t      return change.formatted_print (\"%qs is NULL\",\n+\t\t\t\t\t     \"<unknown>\");\n+\t  }\n       }\n \n     return label_text ();\n@@ -406,19 +450,29 @@ class null_arg : public malloc_diagnostic\n     auto_diagnostic_group d;\n     diagnostic_metadata m;\n     m.add_cwe (690);\n-    bool warned = warning_meta (rich_loc, m, OPT_Wanalyzer_null_argument,\n-\t\t\t\t\"use of NULL %qE where non-null expected\",\n-\t\t\t\tm_arg);\n+\n+    bool warned;\n+    if (zerop (m_arg))\n+      warned = warning_meta (rich_loc, m, OPT_Wanalyzer_null_argument,\n+\t\t\t     \"use of NULL where non-null expected\");\n+    else\n+      warned = warning_meta (rich_loc, m, OPT_Wanalyzer_null_argument,\n+\t\t\t     \"use of NULL %qE where non-null expected\",\n+\t\t\t     m_arg);\n     if (warned)\n       inform_nonnull_attribute (m_fndecl, m_arg_idx);\n     return warned;\n   }\n \n   label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n   {\n-    return ev.formatted_print (\"argument %u (%qE) NULL\"\n-\t\t\t       \" where non-null expected\",\n-\t\t\t       m_arg_idx + 1, ev.m_expr);\n+    if (zerop (ev.m_expr))\n+      return ev.formatted_print (\"argument %u NULL where non-null expected\",\n+\t\t\t\t m_arg_idx + 1);\n+    else\n+      return ev.formatted_print (\"argument %u (%qE) NULL\"\n+\t\t\t\t \" where non-null expected\",\n+\t\t\t\t m_arg_idx + 1, ev.m_expr);\n   }\n \n private:\n@@ -480,8 +534,12 @@ class malloc_leak : public malloc_diagnostic\n   {\n     diagnostic_metadata m;\n     m.add_cwe (401);\n-    return warning_meta (rich_loc, m, OPT_Wanalyzer_malloc_leak,\n-\t\t\t \"leak of %qE\", m_arg);\n+    if (m_arg)\n+      return warning_meta (rich_loc, m, OPT_Wanalyzer_malloc_leak,\n+\t\t\t   \"leak of %qE\", m_arg);\n+    else\n+      return warning_meta (rich_loc, m, OPT_Wanalyzer_malloc_leak,\n+\t\t\t   \"leak of %qs\", \"<unknown>\");\n   }\n \n   label_text describe_state_change (const evdesc::state_change &change)\n@@ -497,11 +555,22 @@ class malloc_leak : public malloc_diagnostic\n \n   label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n   {\n-    if (m_malloc_event.known_p ())\n-      return ev.formatted_print (\"%qE leaks here; was allocated at %@\",\n-\t\t\t\t ev.m_expr, &m_malloc_event);\n+    if (ev.m_expr)\n+      {\n+\tif (m_malloc_event.known_p ())\n+\t  return ev.formatted_print (\"%qE leaks here; was allocated at %@\",\n+\t\t\t\t     ev.m_expr, &m_malloc_event);\n+\telse\n+\t  return ev.formatted_print (\"%qE leaks here\", ev.m_expr);\n+      }\n     else\n-      return ev.formatted_print (\"%qE leaks here\", ev.m_expr);\n+      {\n+\tif (m_malloc_event.known_p ())\n+\t  return ev.formatted_print (\"%qs leaks here; was allocated at %@\",\n+\t\t\t\t     \"<unknown>\", &m_malloc_event);\n+\telse\n+\t  return ev.formatted_print (\"%qs leaks here\", \"<unknown>\");\n+      }\n   }\n \n private:\n@@ -618,10 +687,7 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t  {\n \t    tree lhs = gimple_call_lhs (call);\n \t    if (lhs)\n-\t      {\n-\t\tlhs = sm_ctxt->get_readable_tree (lhs);\n-\t\tsm_ctxt->on_transition (node, stmt, lhs, m_start, m_unchecked);\n-\t      }\n+\t      sm_ctxt->on_transition (node, stmt, lhs, m_start, m_unchecked);\n \t    else\n \t      {\n \t\t/* TODO: report leak.  */\n@@ -634,10 +700,7 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t  {\n \t    tree lhs = gimple_call_lhs (call);\n \t    if (lhs)\n-\t      {\n-\t\tlhs = sm_ctxt->get_readable_tree (lhs);\n-\t\tsm_ctxt->on_transition (node, stmt, lhs, m_start, m_non_heap);\n-\t      }\n+\t      sm_ctxt->on_transition (node, stmt, lhs, m_start, m_non_heap);\n \t    return true;\n \t  }\n \n@@ -646,8 +709,7 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t    || is_named_call_p (callee_fndecl, \"__builtin_free\", call, 1))\n \t  {\n \t    tree arg = gimple_call_arg (call, 0);\n-\n-\t    arg = sm_ctxt->get_readable_tree (arg);\n+\t    tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n \n \t    /* start/unchecked/nonnull -> freed.  */\n \t    sm_ctxt->on_transition (node, stmt, arg, m_start, m_freed);\n@@ -659,12 +721,12 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \n \t    /* freed -> stop, with warning.  */\n \t    sm_ctxt->warn_for_state (node, stmt, arg, m_freed,\n-\t\t\t\t     new double_free (*this, arg));\n+\t\t\t\t     new double_free (*this, diag_arg));\n \t    sm_ctxt->on_transition (node, stmt, arg, m_freed, m_stop);\n \n \t    /* non-heap -> stop, with warning.  */\n \t    sm_ctxt->warn_for_state (node, stmt, arg, m_non_heap,\n-\t\t\t\t     new free_of_non_heap (*this, arg));\n+\t\t\t\t     new free_of_non_heap (*this, diag_arg));\n \t    sm_ctxt->on_transition (node, stmt, arg, m_non_heap, m_stop);\n \t    return true;\n \t  }\n@@ -685,15 +747,17 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t\t  if (bitmap_empty_p (nonnull_args)\n \t\t      || bitmap_bit_p (nonnull_args, i))\n \t\t    {\n+\t\t      tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n \t\t      sm_ctxt->warn_for_state\n \t\t\t(node, stmt, arg, m_unchecked,\n-\t\t\t new possible_null_arg (*this, arg, callee_fndecl, i));\n+\t\t\t new possible_null_arg (*this, diag_arg, callee_fndecl,\n+\t\t\t\t\t\ti));\n \t\t      sm_ctxt->on_transition (node, stmt, arg, m_unchecked,\n \t\t\t\t\t      m_nonnull);\n \n \t\t      sm_ctxt->warn_for_state\n \t\t\t(node, stmt, arg, m_null,\n-\t\t\t new null_arg (*this, arg, callee_fndecl, i));\n+\t\t\t new null_arg (*this, diag_arg, callee_fndecl, i));\n \t\t      sm_ctxt->on_transition (node, stmt, arg, m_null, m_stop);\n \t\t    }\n \t\t}\n@@ -702,10 +766,15 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t}\n       }\n \n-  if (tree lhs = is_zero_assignment (stmt))\n+  if (tree lhs = sm_ctxt->is_zero_assignment (stmt))\n     if (any_pointer_p (lhs))\n       on_zero_assignment (sm_ctxt, node, stmt,lhs);\n \n+  /* If we have \"LHS = &EXPR;\" and EXPR is something other than a MEM_REF,\n+     transition LHS from start to non_heap.\n+     Doing it for ADDR_EXPR(MEM_REF()) is likely wrong, and can lead to\n+     unbounded chains of unmergeable sm-state on pointer arithmetic in loops\n+     when optimization is enabled.  */\n   if (const gassign *assign_stmt = dyn_cast <const gassign *> (stmt))\n     {\n       enum tree_code op = gimple_assign_rhs_code (assign_stmt);\n@@ -714,8 +783,9 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t  tree lhs = gimple_assign_lhs (assign_stmt);\n \t  if (lhs)\n \t    {\n-\t      lhs = sm_ctxt->get_readable_tree (lhs);\n-\t      sm_ctxt->on_transition (node, stmt, lhs, m_start, m_non_heap);\n+\t      tree addr_expr = gimple_assign_rhs1 (assign_stmt);\n+\t      if (TREE_CODE (TREE_OPERAND (addr_expr, 0)) != MEM_REF)\n+\t\tsm_ctxt->on_transition (node, stmt, lhs, m_start, m_non_heap);\n \t    }\n \t}\n     }\n@@ -732,18 +802,18 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n       if (TREE_CODE (op) == MEM_REF)\n \t{\n \t  tree arg = TREE_OPERAND (op, 0);\n-\t  arg = sm_ctxt->get_readable_tree (arg);\n+\t  tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n \n \t  sm_ctxt->warn_for_state (node, stmt, arg, m_unchecked,\n-\t\t\t\t   new possible_null_deref (*this, arg));\n+\t\t\t\t   new possible_null_deref (*this, diag_arg));\n \t  sm_ctxt->on_transition (node, stmt, arg, m_unchecked, m_nonnull);\n \n \t  sm_ctxt->warn_for_state (node, stmt, arg, m_null,\n-\t\t\t\t   new null_deref (*this, arg));\n+\t\t\t\t   new null_deref (*this, diag_arg));\n \t  sm_ctxt->on_transition (node, stmt, arg, m_null, m_stop);\n \n \t  sm_ctxt->warn_for_state (node, stmt, arg, m_freed,\n-\t\t\t\t   new use_after_free (*this, arg));\n+\t\t\t\t   new use_after_free (*this, diag_arg));\n \t  sm_ctxt->on_transition (node, stmt, arg, m_freed, m_stop);\n \t}\n     }\n@@ -818,6 +888,22 @@ malloc_state_machine::on_leak (tree var) const\n   return new malloc_leak (*this, var);\n }\n \n+/* Implementation of state_machine::reset_when_passed_to_unknown_fn_p vfunc\n+   for malloc_state_machine.  */\n+\n+bool\n+malloc_state_machine::reset_when_passed_to_unknown_fn_p (state_t s,\n+\t\t\t\t\t\t\t bool is_mutable) const\n+{\n+  /* An on-stack ptr doesn't stop being stack-allocated when passed to an\n+     unknown fn.  */\n+  if (s == m_non_heap)\n+    return false;\n+\n+  /* Otherwise, pointers passed as non-const can be freed.  */\n+  return is_mutable;\n+}\n+\n /* Shared logic for handling GIMPLE_ASSIGNs and GIMPLE_PHIs that\n    assign zero to LHS.  */\n "}, {"sha": "b14bf147d0cfca1ae0be17d799571fef00288059", "filename": "gcc/analyzer/sm-sensitive.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fsm-sensitive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fsm-sensitive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-sensitive.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -177,8 +177,9 @@ sensitive_state_machine::warn_for_any_exposure (sm_context *sm_ctxt,\n \t\t\t\t\t\tconst gimple *stmt,\n \t\t\t\t\t\ttree arg) const\n {\n+  tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n   sm_ctxt->warn_for_state (node, stmt, arg, m_sensitive,\n-\t\t\t   new exposure_through_output_file (*this, arg));\n+\t\t\t   new exposure_through_output_file (*this, diag_arg));\n }\n \n /* Implementation of state_machine::on_stmt vfunc for"}, {"sha": "85c4b433d7b7a913e6a0b4e6503bdeef51e06c74", "filename": "gcc/analyzer/sm-signal.cc", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fsm-signal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fsm-signal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-signal.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -41,6 +41,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tristate.h\"\n #include \"ordered-hash-map.h\"\n #include \"selftest.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n #include \"analyzer/program-state.h\"\n #include \"analyzer/checker-path.h\"\n@@ -49,8 +52,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-iterator.h\"\n #include \"cgraph.h\"\n #include \"analyzer/supergraph.h\"\n-#include \"analyzer/call-string.h\"\n-#include \"analyzer/program-point.h\"\n #include \"alloc-pool.h\"\n #include \"fibonacci_heap.h\"\n #include \"analyzer/diagnostic-manager.h\"\n@@ -157,8 +158,7 @@ class signal_unsafe_call\n     if (change.is_global_p ()\n \t&& change.m_new_state == m_sm.m_in_signal_handler)\n       {\n-\tfunction *handler\n-\t  = change.m_event.m_dst_state.m_region_model->get_current_function ();\n+\tfunction *handler = change.m_event.get_dest_function ();\n \treturn change.formatted_print (\"registering %qD as signal handler\",\n \t\t\t\t       handler->decl);\n       }\n@@ -208,8 +208,9 @@ static void\n update_model_for_signal_handler (region_model *model,\n \t\t\t\t function *handler_fun)\n {\n+  gcc_assert (model);\n   /* Purge all state within MODEL.  */\n-  *model = region_model ();\n+  *model = region_model (model->get_manager ());\n   model->push_frame (handler_fun, NULL, NULL);\n }\n \n@@ -273,9 +274,9 @@ class register_signal_handler : public custom_transition\n \n     exploded_node *dst_enode = eg->get_or_create_node (entering_handler,\n \t\t\t\t\t\t       state_entering_handler,\n-\t\t\t\t\t\t       NULL);\n+\t\t\t\t\t\t       src_enode);\n     if (dst_enode)\n-      eg->add_edge (src_enode, dst_enode, NULL, state_change (),\n+      eg->add_edge (src_enode, dst_enode, NULL, /*state_change (),*/\n \t\t    new signal_delivery_edge_info_t ());\n   }\n "}, {"sha": "28d196505d2f301f9a79be863ccc8a82a23df34c", "filename": "gcc/analyzer/sm-taint.cc", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fsm-taint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fsm-taint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-taint.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -208,7 +208,6 @@ taint_state_machine::on_stmt (sm_context *sm_ctxt,\n \tif (is_named_call_p (callee_fndecl, \"fread\", call, 4))\n \t  {\n \t    tree arg = gimple_call_arg (call, 0);\n-\t    arg = sm_ctxt->get_readable_tree (arg);\n \n \t    sm_ctxt->on_transition (node, stmt, arg, m_start, m_tainted);\n \n@@ -231,7 +230,7 @@ taint_state_machine::on_stmt (sm_context *sm_ctxt,\n       if (op == ARRAY_REF)\n \t{\n \t  tree arg = TREE_OPERAND (rhs1, 1);\n-\t  arg = sm_ctxt->get_readable_tree (arg);\n+\t  tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n \n \t  /* Unsigned types have an implicit lower bound.  */\n \t  bool is_unsigned = false;\n@@ -241,22 +240,22 @@ taint_state_machine::on_stmt (sm_context *sm_ctxt,\n \t  /* Complain about missing bounds.  */\n \t  sm_ctxt->warn_for_state\n \t    (node, stmt, arg, m_tainted,\n-\t     new tainted_array_index (*this, arg,\n+\t     new tainted_array_index (*this, diag_arg,\n \t\t\t\t      is_unsigned\n \t\t\t\t      ? BOUNDS_LOWER : BOUNDS_NONE));\n \t  sm_ctxt->on_transition (node, stmt, arg, m_tainted, m_stop);\n \n \t  /* Complain about missing upper bound.  */\n \t  sm_ctxt->warn_for_state  (node, stmt, arg, m_has_lb,\n-\t\t\t\t    new tainted_array_index (*this, arg,\n+\t\t\t\t    new tainted_array_index (*this, diag_arg,\n \t\t\t\t\t\t\t     BOUNDS_LOWER));\n \t  sm_ctxt->on_transition (node, stmt, arg, m_has_lb, m_stop);\n \n \t  /* Complain about missing lower bound.  */\n \t  if (!is_unsigned)\n \t    {\n \t      sm_ctxt->warn_for_state  (node, stmt, arg, m_has_ub,\n-\t\t\t\t\tnew tainted_array_index (*this, arg,\n+\t\t\t\t\tnew tainted_array_index (*this, diag_arg,\n \t\t\t\t\t\t\t\t BOUNDS_UPPER));\n \t      sm_ctxt->on_transition (node, stmt, arg, m_has_ub, m_stop);\n \t    }"}, {"sha": "3504b2e3cbb161aa69188ff4c2786ade0aa42f09", "filename": "gcc/analyzer/sm.cc", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fsm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fsm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -35,24 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #if ENABLE_ANALYZER\n \n-/* If STMT is an assignment from zero, return the LHS.  */\n-\n-tree\n-is_zero_assignment (const gimple *stmt)\n-{\n-  const gassign *assign_stmt = dyn_cast <const gassign *> (stmt);\n-  if (!assign_stmt)\n-    return NULL_TREE;\n-\n-  enum tree_code op = gimple_assign_rhs_code (assign_stmt);\n-  if (TREE_CODE_CLASS (op) != tcc_constant)\n-    return NULL_TREE;\n-\n-  if (!zerop (gimple_assign_rhs1 (assign_stmt)))\n-    return NULL_TREE;\n-\n-  return gimple_assign_lhs (assign_stmt);\n-}\n+namespace ana {\n \n /* Return true if VAR has pointer or reference type.  */\n \n@@ -62,8 +45,6 @@ any_pointer_p (tree var)\n   return POINTER_TYPE_P (TREE_TYPE (var));\n }\n \n-namespace ana {\n-\n /* Add a state with name NAME to this state_machine.\n    The string is required to outlive the state_machine.\n "}, {"sha": "fa65f52739938468d6a1a1c5097a9e7f55f0567a", "filename": "gcc/analyzer/sm.h", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fsm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fsm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.h?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -23,15 +23,14 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Utility functions for use by state machines.  */\n \n-extern tree is_zero_assignment (const gimple *stmt);\n-extern bool any_pointer_p (tree var);\n-\n namespace ana {\n \n class state_machine;\n class sm_context;\n class pending_diagnostic;\n \n+extern bool any_pointer_p (tree var);\n+\n /* An abstract base class for a state machine describing an API.\n    A mapping from state IDs to names, and various virtual functions\n    for pattern-matching on statements.  */\n@@ -53,6 +52,11 @@ class state_machine : public log_user\n      within a heap-allocated struct.  */\n   virtual bool inherited_state_p () const = 0;\n \n+  virtual state_machine::state_t get_default_state (const svalue *) const\n+  {\n+    return 0;\n+  }\n+\n   const char *get_name () const { return m_name; }\n \n   const char *get_state_name (state_t s) const;\n@@ -87,6 +91,19 @@ class state_machine : public log_user\n     return NULL;\n   }\n \n+  /* Return true if S should be reset to \"start\" for values passed (or reachable\n+     from) calls to unknown functions.  IS_MUTABLE is true for pointers as\n+     non-const, false if only passed as const-pointers.\n+\n+     For example, in sm-malloc.cc, an on-stack ptr doesn't stop being\n+     stack-allocated when passed to an unknown fn, but a malloc-ed pointer\n+     could be freed when passed to an unknown fn (unless passed as \"const\").  */\n+  virtual bool reset_when_passed_to_unknown_fn_p (state_t s ATTRIBUTE_UNUSED,\n+\t\t\t\t\t\t  bool is_mutable) const\n+  {\n+    return is_mutable;\n+  }\n+\n   void validate (state_t s) const;\n \n   void dump_to_pp (pretty_printer *pp) const;\n@@ -154,7 +171,12 @@ class sm_context\n \t\t\t       tree var, state_machine::state_t state,\n \t\t\t       pending_diagnostic *d) = 0;\n \n-  virtual tree get_readable_tree (tree expr)\n+  /* For use when generating trees when creating pending_diagnostics, so that\n+     rather than e.g.\n+       \"double-free of '<unknown>'\"\n+     we can print:\n+       \"double-free of 'inbuf.data'\".  */\n+  virtual tree get_diagnostic_tree (tree expr)\n   {\n     return expr;\n   }\n@@ -166,6 +188,11 @@ class sm_context\n      a signal handler.  */\n   virtual void on_custom_transition (custom_transition *transition) = 0;\n \n+  /* If STMT is an assignment known to assign zero to its LHS, return\n+     the LHS.\n+     Otherwise return NULL_TREE.  */\n+  virtual tree is_zero_assignment (const gimple *stmt) = 0;\n+\n protected:\n   sm_context (int sm_idx, const state_machine &sm)\n   : m_sm_idx (sm_idx), m_sm (sm) {}"}, {"sha": "5fef27c8bd2b9053a9f1df6189e018ae339f2f1f", "filename": "gcc/analyzer/store.cc", "status": "added", "additions": 2008, "deletions": 0, "changes": 2008, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,2008 @@\n+/* Classes for modeling the state of memory.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"diagnostic-core.h\"\n+#include \"graphviz.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"tree-dfa.h\"\n+#include \"stringpool.h\"\n+#include \"convert.h\"\n+#include \"target.h\"\n+#include \"fold-const.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"diagnostic-color.h\"\n+#include \"diagnostic-metadata.h\"\n+#include \"tristate.h\"\n+#include \"bitmap.h\"\n+#include \"selftest.h\"\n+#include \"function.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"ordered-hash-map.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"cfg.h\"\n+#include \"digraph.h\"\n+#include \"analyzer/supergraph.h\"\n+#include \"sbitmap.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"analyzer/analyzer-selftests.h\"\n+#include \"stor-layout.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* Get a human-readable string for KIND for dumps.  */\n+\n+const char *binding_kind_to_string (enum binding_kind kind)\n+{\n+  switch (kind)\n+    {\n+    default:\n+    case BK_empty:\n+    case BK_deleted:\n+      /* We shouldn't be attempting to print the hash kinds.  */\n+      gcc_unreachable ();\n+    case BK_direct:\n+      return \"direct\";\n+    case BK_default:\n+      return \"default\";\n+    }\n+}\n+\n+/* class binding_key.  */\n+\n+const binding_key *\n+binding_key::make (store_manager *mgr, const region *r,\n+\t\t   enum binding_kind kind)\n+{\n+  region_offset offset = r->get_offset ();\n+  if (offset.symbolic_p ())\n+    return mgr->get_symbolic_binding (r, kind);\n+  else\n+    {\n+      bit_size_t bit_size;\n+      if (r->get_bit_size (&bit_size))\n+\treturn mgr->get_concrete_binding (offset.get_bit_offset (),\n+\t\t\t\t\t  bit_size, kind);\n+      else\n+\treturn mgr->get_symbolic_binding (r, kind);\n+    }\n+}\n+\n+/* Base class implementation of binding_key::dump_to_pp vfunc.  */\n+\n+void\n+binding_key::dump_to_pp (pretty_printer *pp, bool /*simple*/) const\n+{\n+  pp_printf (pp, \"kind: %s\", binding_kind_to_string (m_kind));\n+}\n+\n+/* Dump this binding_key to stderr.  */\n+\n+DEBUG_FUNCTION void\n+binding_key::dump (bool simple) const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = stderr;\n+  dump_to_pp (&pp, simple);\n+  pp_newline (&pp);\n+  pp_flush (&pp);\n+}\n+\n+/* qsort callback.  */\n+\n+int\n+binding_key::cmp_ptrs (const void *p1, const void *p2)\n+{\n+  const binding_key * const *pk1 = (const binding_key * const *)p1;\n+  const binding_key * const *pk2 = (const binding_key * const *)p2;\n+  return cmp (*pk1, *pk2);\n+}\n+\n+/* Comparator for binding_keys.  */\n+\n+int\n+binding_key::cmp (const binding_key *k1, const binding_key *k2)\n+{\n+  enum binding_kind kind1 = k1->get_kind ();\n+  enum binding_kind kind2 = k2->get_kind ();\n+  if (kind1 != kind2)\n+    return (int)kind1 - (int)kind2;\n+\n+  int concrete1 = k1->concrete_p ();\n+  int concrete2 = k2->concrete_p ();\n+  if (int concrete_cmp = concrete1 - concrete2)\n+    return concrete_cmp;\n+  if (concrete1)\n+    {\n+      const concrete_binding *b1 = (const concrete_binding *)k1;\n+      const concrete_binding *b2 = (const concrete_binding *)k2;\n+      if (int start_cmp = wi::cmp (b1->get_start_bit_offset (),\n+\t\t\t\t   b2->get_start_bit_offset (),\n+\t\t\t\t   SIGNED))\n+\treturn start_cmp;\n+      return wi::cmp (b1->get_next_bit_offset (), b2->get_next_bit_offset (),\n+\t\t      SIGNED);\n+    }\n+  else\n+    {\n+      const symbolic_binding *s1 = (const symbolic_binding *)k1;\n+      const symbolic_binding *s2 = (const symbolic_binding *)k2;\n+      if (s1 > s2)\n+\treturn 1;\n+      if (s1 < s2)\n+\treturn -1;\n+      return 0;\n+    }\n+}\n+\n+/* class concrete_binding : public binding_key.  */\n+\n+/* Implementation of binding_key::dump_to_pp vfunc for concrete_binding.  */\n+\n+void\n+concrete_binding::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  binding_key::dump_to_pp (pp, simple);\n+  pp_string (pp, \", start: \");\n+  pp_wide_int (pp, m_start_bit_offset, SIGNED);\n+  pp_string (pp, \", size: \");\n+  pp_wide_int (pp, m_size_in_bits, SIGNED);\n+  pp_string (pp, \", next: \");\n+  pp_wide_int (pp, get_next_bit_offset (), SIGNED);\n+}\n+\n+/* Return true if this binding overlaps with OTHER.  */\n+\n+bool\n+concrete_binding::overlaps_p (const concrete_binding &other) const\n+{\n+  if (m_start_bit_offset < other.get_next_bit_offset ()\n+      && get_next_bit_offset () > other.get_start_bit_offset ())\n+    return true;\n+  return false;\n+}\n+\n+/* class symbolic_binding : public binding_key.  */\n+\n+void\n+symbolic_binding::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  binding_key::dump_to_pp (pp, simple);\n+  pp_string (pp, \", region: \");\n+  m_region->dump_to_pp (pp, simple);\n+}\n+\n+/* The store is oblivious to the types of the svalues bound within\n+   it: any type can get bound at any location.\n+   Simplify any casts before binding.\n+\n+   For example, if we have:\n+     struct big { int ia[1024]; };\n+     struct big src, dst;\n+     memcpy (&dst, &src, sizeof (struct big));\n+   this reaches us in gimple form as:\n+     MEM <unsigned char[4096]> [(char * {ref-all})&dst]\n+       = MEM <unsigned char[4096]> [(char * {ref-all})&src];\n+   Using cast_region when handling the MEM_REF would give us:\n+     INIT_VAL(CAST_REG(unsigned char[4096], src))\n+   as rhs_sval, but we can fold that into a cast svalue:\n+     CAST(unsigned char[4096], INIT_VAL(src))\n+   We can discard that cast from the svalue when binding it in\n+   the store for \"dst\", and simply store:\n+     cluster for: dst\n+       key:   {kind: direct, start: 0, size: 32768, next: 32768}\n+       value: \u2018struct big\u2019 {INIT_VAL(src)}.  */\n+\n+static const svalue *\n+simplify_for_binding (const svalue *sval)\n+{\n+  if (const svalue *cast_sval = sval->maybe_undo_cast ())\n+    sval = cast_sval;\n+  return sval;\n+}\n+\n+/* class binding_map.  */\n+\n+/* binding_map's copy ctor.  */\n+\n+binding_map::binding_map (const binding_map &other)\n+: m_map (other.m_map)\n+{\n+}\n+\n+/* binding_map's assignment operator.  */\n+\n+binding_map&\n+binding_map::operator=(const binding_map &other)\n+{\n+  /* For now, assume we only ever copy to an empty cluster.  */\n+  gcc_assert (m_map.elements () == 0);\n+  for (map_t::iterator iter = other.m_map.begin (); iter != other.m_map.end ();\n+       ++iter)\n+    {\n+      const binding_key *key = (*iter).first;\n+      const svalue *sval = (*iter).second;\n+      m_map.put (key, sval);\n+    }\n+  return *this;\n+}\n+\n+/* binding_map's equality operator.  */\n+\n+bool\n+binding_map::operator== (const binding_map &other) const\n+{\n+  if (m_map.elements () != other.m_map.elements ())\n+    return false;\n+\n+  for (map_t::iterator iter = m_map.begin (); iter != m_map.end (); ++iter)\n+    {\n+      const binding_key *key = (*iter).first;\n+      const svalue *sval = (*iter).second;\n+      const svalue **other_slot\n+\t= const_cast <map_t &> (other.m_map).get (key);\n+      if (other_slot == NULL)\n+\treturn false;\n+      if (sval != *other_slot)\n+\treturn false;\n+    }\n+  gcc_checking_assert (hash () == other.hash ());\n+  return true;\n+}\n+\n+/* Generate a hash value for this binding_map.  */\n+\n+hashval_t\n+binding_map::hash () const\n+{\n+  hashval_t result = 0;\n+  for (map_t::iterator iter = m_map.begin (); iter != m_map.end (); ++iter)\n+    {\n+      /* Use a new hasher for each key to avoid depending on the ordering\n+\t of keys when accumulating the result.  */\n+      inchash::hash hstate;\n+      hstate.add_ptr ((*iter).first);\n+      hstate.add_ptr ((*iter).second);\n+      result ^= hstate.end ();\n+    }\n+  return result;\n+}\n+\n+/* Dump a representation of this binding_map to PP.\n+   SIMPLE controls how values and regions are to be printed.\n+   If MULTILINE, then split the dump over multiple lines and\n+   use whitespace for readability, otherwise put all on one line.  */\n+\n+void\n+binding_map::dump_to_pp (pretty_printer *pp, bool simple,\n+\t\t\t bool multiline) const\n+{\n+  auto_vec <const binding_key *> binding_keys;\n+  for (map_t::iterator iter = m_map.begin ();\n+       iter != m_map.end (); ++iter)\n+    {\n+      const binding_key *key = (*iter).first;\n+      binding_keys.safe_push (key);\n+    }\n+  binding_keys.qsort (binding_key::cmp_ptrs);\n+\n+  const binding_key *key;\n+  unsigned i;\n+  FOR_EACH_VEC_ELT (binding_keys, i, key)\n+    {\n+      const svalue *value = *const_cast <map_t &> (m_map).get (key);\n+      if (multiline)\n+\t{\n+\t  pp_string (pp, \"    key:   {\");\n+\t  key->dump_to_pp (pp, simple);\n+\t  pp_string (pp, \"}\");\n+\t  pp_newline (pp);\n+\t  pp_string (pp, \"    value: \");\n+\t  if (tree t = value->get_type ())\n+\t    dump_quoted_tree (pp, t);\n+\t  pp_string (pp, \" {\");\n+\t  value->dump_to_pp (pp, simple);\n+\t  pp_string (pp, \"}\");\n+\t  pp_newline (pp);\n+\t}\n+      else\n+\t{\n+\t  if (i > 0)\n+\t    pp_string (pp, \", \");\n+\t  pp_string (pp, \"binding key: {\");\n+\t  key->dump_to_pp (pp, simple);\n+\t  pp_string (pp, \"}, value: {\");\n+\t  value->dump_to_pp (pp, simple);\n+\t  pp_string (pp, \"}\");\n+\t}\n+    }\n+}\n+\n+/* Dump a multiline representation of this binding_map to stderr.  */\n+\n+DEBUG_FUNCTION void\n+binding_map::dump (bool simple) const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = stderr;\n+  dump_to_pp (&pp, simple, true);\n+  pp_newline (&pp);\n+  pp_flush (&pp);\n+}\n+\n+/* class binding_cluster.  */\n+\n+/* binding_cluster's copy ctor.  */\n+\n+binding_cluster::binding_cluster (const binding_cluster &other)\n+: m_base_region (other.m_base_region), m_map (other.m_map),\n+  m_escaped (other.m_escaped), m_touched (other.m_touched)\n+{\n+}\n+\n+/* binding_cluster's assignment operator.  */\n+\n+binding_cluster&\n+binding_cluster::operator= (const binding_cluster &other)\n+{\n+  gcc_assert (m_base_region == other.m_base_region);\n+  m_map = other.m_map;\n+  m_escaped = other.m_escaped;\n+  m_touched = other.m_touched;\n+  return *this;\n+}\n+\n+/* binding_cluster's equality operator.  */\n+\n+bool\n+binding_cluster::operator== (const binding_cluster &other) const\n+{\n+  if (m_map != other.m_map)\n+    return false;\n+\n+  if (m_base_region != other.m_base_region)\n+    return false;\n+\n+  if (m_escaped != other.m_escaped)\n+    return false;\n+\n+  if (m_touched != other.m_touched)\n+    return false;\n+\n+  gcc_checking_assert (hash () == other.hash ());\n+\n+  return true;\n+}\n+\n+/* Generate a hash value for this binding_cluster.  */\n+\n+hashval_t\n+binding_cluster::hash () const\n+{\n+  return m_map.hash ();\n+}\n+\n+/* Return true if this binding_cluster is symbolic\n+   i.e. its base region is symbolic.  */\n+\n+bool\n+binding_cluster::symbolic_p () const\n+{\n+  return m_base_region->get_kind () == RK_SYMBOLIC;\n+}\n+\n+/* Dump a representation of this binding_cluster to PP.\n+   SIMPLE controls how values and regions are to be printed.\n+   If MULTILINE, then split the dump over multiple lines and\n+   use whitespace for readability, otherwise put all on one line.  */\n+\n+void\n+binding_cluster::dump_to_pp (pretty_printer *pp, bool simple,\n+\t\t\t     bool multiline) const\n+{\n+  if (m_escaped)\n+    {\n+      if (multiline)\n+\t{\n+\t  pp_string (pp, \"    ESCAPED\");\n+\t  pp_newline (pp);\n+\t}\n+      else\n+\tpp_string (pp, \"(ESCAPED)\");\n+    }\n+  if (m_touched)\n+    {\n+      if (multiline)\n+\t{\n+\t  pp_string (pp, \"    TOUCHED\");\n+\t  pp_newline (pp);\n+\t}\n+      else\n+\tpp_string (pp, \"(TOUCHED)\");\n+    }\n+\n+  m_map.dump_to_pp (pp, simple, multiline);\n+}\n+\n+/* Dump a multiline representation of this binding_cluster to stderr.  */\n+\n+DEBUG_FUNCTION void\n+binding_cluster::dump (bool simple) const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = stderr;\n+  pp_string (&pp, \"  cluster for: \");\n+  m_base_region->dump_to_pp (&pp, simple);\n+  pp_string (&pp, \": \");\n+  pp_newline (&pp);\n+  dump_to_pp (&pp, simple, true);\n+  pp_newline (&pp);\n+  pp_flush (&pp);\n+}\n+\n+/* Add a binding of SVAL of kind KIND to REG, unpacking SVAL if it is a\n+   compound_sval.  */\n+\n+void\n+binding_cluster::bind (store_manager *mgr,\n+\t\t       const region *reg, const svalue *sval,\n+\t\t       binding_kind kind)\n+{\n+  if (const compound_svalue *compound_sval\n+\t= sval->dyn_cast_compound_svalue ())\n+    {\n+      bind_compound_sval (mgr, reg, compound_sval);\n+      return;\n+    }\n+\n+  const binding_key *binding = binding_key::make (mgr, reg, kind);\n+  bind_key (binding, sval);\n+}\n+\n+/* Bind SVAL to KEY.\n+   Unpacking of compound_svalues should already have been done by the\n+   time this is called.  */\n+\n+void\n+binding_cluster::bind_key (const binding_key *key, const svalue *sval)\n+{\n+  gcc_assert (sval->get_kind () != SK_COMPOUND);\n+\n+  m_map.put (key, sval);\n+  if (key->symbolic_p ())\n+    m_touched = true;\n+}\n+\n+/* Subroutine of binding_cluster::bind.\n+   Unpack compound_svals when binding them, so that we bind them\n+   element-wise.  */\n+\n+void\n+binding_cluster::bind_compound_sval (store_manager *mgr,\n+\t\t\t\t     const region *reg,\n+\t\t\t\t     const compound_svalue *compound_sval)\n+{\n+  region_offset reg_offset = reg->get_offset ();\n+  if (reg_offset.symbolic_p ())\n+    {\n+      m_touched = true;\n+      clobber_region (mgr, reg);\n+      return;\n+    }\n+\n+  for (map_t::iterator iter = compound_sval->begin ();\n+       iter != compound_sval->end (); ++iter)\n+    {\n+      const binding_key *iter_key = (*iter).first;\n+      const svalue *iter_sval = (*iter).second;\n+\n+      if (const concrete_binding *concrete_key\n+\t  = iter_key->dyn_cast_concrete_binding ())\n+\t{\n+\t  bit_offset_t effective_start\n+\t    = (concrete_key->get_start_bit_offset ()\n+\t       + reg_offset.get_bit_offset ());\n+\t  const concrete_binding *effective_concrete_key\n+\t    = mgr->get_concrete_binding (effective_start,\n+\t\t\t\t\t concrete_key->get_size_in_bits (),\n+\t\t\t\t\t iter_key->get_kind ());\n+\t  bind_key (effective_concrete_key, iter_sval);\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+}\n+\n+/* Remove all bindings overlapping REG within this cluster.  */\n+\n+void\n+binding_cluster::clobber_region (store_manager *mgr, const region *reg)\n+{\n+  remove_overlapping_bindings (mgr, reg);\n+}\n+\n+/* Remove any bindings for REG within this cluster.  */\n+\n+void\n+binding_cluster::purge_region (store_manager *mgr, const region *reg)\n+{\n+  gcc_assert (reg->get_kind () == RK_DECL);\n+  const binding_key *binding\n+    = binding_key::make (mgr, const_cast<region *> (reg),\n+\t\t\t BK_direct);\n+  m_map.remove (binding);\n+}\n+\n+/* Mark REG within this cluster as being filled with zeroes.\n+   Remove all bindings, add a default binding to zero, and clear the\n+   TOUCHED flag.  */\n+\n+void\n+binding_cluster::zero_fill_region (store_manager *mgr, const region *reg)\n+{\n+  clobber_region (mgr, reg);\n+\n+  /* Add a default binding to zero.  */\n+  region_model_manager *sval_mgr = mgr->get_svalue_manager ();\n+  tree cst_zero = build_int_cst (integer_type_node, 0);\n+  const svalue *cst_sval = sval_mgr->get_or_create_constant_svalue (cst_zero);\n+  const svalue *bound_sval = cst_sval;\n+  if (reg->get_type ())\n+    bound_sval = sval_mgr->get_or_create_unaryop (reg->get_type (), NOP_EXPR,\n+\t\t\t\t\t\t  cst_sval);\n+  bind (mgr, reg, bound_sval, BK_default);\n+\n+  m_touched = false;\n+}\n+\n+/* Mark REG within this cluster as being unknown.  */\n+\n+void\n+binding_cluster::mark_region_as_unknown (store_manager *mgr,\n+\t\t\t\t\t const region *reg)\n+{\n+  remove_overlapping_bindings (mgr, reg);\n+\n+  /* Add a default binding to \"unknown\".  */\n+  region_model_manager *sval_mgr = mgr->get_svalue_manager ();\n+  const svalue *sval\n+    = sval_mgr->get_or_create_unknown_svalue (reg->get_type ());\n+  bind (mgr, reg, sval, BK_default);\n+}\n+\n+/* Get any SVAL bound to REG within this cluster via kind KIND,\n+   without checking parent regions of REG.  */\n+\n+const svalue *\n+binding_cluster::get_binding (store_manager *mgr,\n+\t\t\t      const region *reg,\n+\t\t\t      binding_kind kind) const\n+{\n+  const binding_key *reg_binding = binding_key::make (mgr, reg, kind);\n+  const svalue *sval = m_map.get (reg_binding);\n+  if (sval)\n+    {\n+      /* If we have a struct with a single field, then the binding of\n+\t the field will equal that of the struct, and looking up e.g.\n+\t PARENT_REG.field within:\n+\t    cluster for PARENT_REG: INIT_VAL(OTHER_REG)\n+\t will erroneously return INIT_VAL(OTHER_REG), rather than\n+\t   SUB_VALUE(INIT_VAL(OTHER_REG), FIELD) == INIT_VAL(OTHER_REG.FIELD).\n+\t Fix this issue by iterating upwards whilst the bindings are equal,\n+\t expressing the lookups as subvalues.\n+\t We have to gather a list of subregion accesses, then walk it\n+\t in reverse to get the subvalues.  */\n+      auto_vec<const region *> regions;\n+      while (const region *parent_reg = reg->get_parent_region ())\n+\t{\n+\t  const binding_key *parent_reg_binding\n+\t    = binding_key::make (mgr, parent_reg, kind);\n+\t  if (parent_reg_binding == reg_binding\n+\t      && sval->get_type ()\n+\t      && reg->get_type ()\n+\t      && sval->get_type () != reg->get_type ())\n+\t    {\n+\t      regions.safe_push (reg);\n+\t      reg = parent_reg;\n+\t    }\n+\t  else\n+\t    break;\n+\t}\n+      if (sval->get_type ()\n+\t  && reg->get_type ()\n+\t  && sval->get_type () == reg->get_type ())\n+\t{\n+\t  unsigned i;\n+\t  const region *iter_reg;\n+\t  FOR_EACH_VEC_ELT_REVERSE (regions, i, iter_reg)\n+\t    {\n+\t      region_model_manager *rmm_mgr = mgr->get_svalue_manager ();\n+\t      sval = rmm_mgr->get_or_create_sub_svalue (reg->get_type (),\n+\t\t\t\t\t\t\tsval, iter_reg);\n+\t    }\n+\t}\n+    }\n+  return sval;\n+}\n+\n+/* Get any SVAL bound to REG within this cluster via kind KIND,\n+   either directly for REG, or recursively checking for bindings within\n+   parent regions and extracting subvalues if need be.  */\n+\n+const svalue *\n+binding_cluster::get_binding_recursive (store_manager *mgr,\n+\t\t\t\t\tconst region *reg,\n+\t\t\t\t\tenum binding_kind kind) const\n+{\n+  if (const svalue *sval = get_binding (mgr, reg, kind))\n+    return sval;\n+  if (reg != m_base_region)\n+    if (const region *parent_reg = reg->get_parent_region ())\n+      if (const svalue *parent_sval\n+\t  = get_binding_recursive (mgr, parent_reg, kind))\n+\t{\n+\t  /* Extract child svalue from parent svalue.  */\n+\t  region_model_manager *rmm_mgr = mgr->get_svalue_manager ();\n+\t  return rmm_mgr->get_or_create_sub_svalue (reg->get_type (),\n+\t\t\t\t\t\t    parent_sval, reg);\n+\t}\n+  return NULL;\n+}\n+\n+/* Get any value bound for REG within this cluster.  */\n+\n+const svalue *\n+binding_cluster::get_any_binding (store_manager *mgr,\n+\t\t\t\t  const region *reg) const\n+{\n+  /* Look for a \"direct\" binding.  */\n+  if (const svalue *direct_sval\n+      = get_binding_recursive (mgr, reg, BK_direct))\n+    return direct_sval;\n+\n+  /* Look for a \"default\" binding, but not if there's been a symbolic\n+     write.  */\n+  if (!m_touched)\n+    if (const svalue *default_sval\n+\t= get_binding_recursive (mgr, reg, BK_default))\n+      return default_sval;\n+\n+  /* If this cluster has been touched by a symbolic write, then the content\n+     of any subregion not currently specifically bound is \"UNKNOWN\".  */\n+  if (m_touched)\n+    {\n+      region_model_manager *rmm_mgr = mgr->get_svalue_manager ();\n+      return rmm_mgr->get_or_create_unknown_svalue (reg->get_type ());\n+    }\n+\n+  if (const svalue *compound_sval = maybe_get_compound_binding (mgr, reg))\n+    return compound_sval;\n+\n+  /* Otherwise, the initial value, or uninitialized.  */\n+  return NULL;\n+}\n+\n+/* Attempt to get a compound_svalue for the bindings within the cluster\n+   affecting REG (which could be the base region itself).\n+\n+   Create a compound_svalue with the subset of bindings the affect REG,\n+   offsetting them so that the offsets are relative to the start of REG\n+   within the cluster.\n+\n+   For example, REG could be one element within an array of structs.\n+\n+   Return the resulting compound_svalue, or NULL if there's a problem.  */\n+\n+const svalue *\n+binding_cluster::maybe_get_compound_binding (store_manager *mgr,\n+\t\t\t\t\t     const region *reg) const\n+{\n+  binding_map map;\n+\n+  region_offset cluster_offset = m_base_region->get_offset ();\n+  if (cluster_offset.symbolic_p ())\n+    return NULL;\n+  region_offset reg_offset = reg->get_offset ();\n+  if (reg_offset.symbolic_p ())\n+    return NULL;\n+\n+  for (map_t::iterator iter = m_map.begin (); iter != m_map.end (); ++iter)\n+    {\n+      const binding_key *key = (*iter).first;\n+      const svalue *sval = (*iter).second;\n+\n+      if (const concrete_binding *concrete_key\n+\t  = key->dyn_cast_concrete_binding ())\n+\t{\n+\t  /* Skip bindings that are outside the bit range of REG.  */\n+\t  if (concrete_key->get_start_bit_offset ()\n+\t      < reg_offset.get_bit_offset ())\n+\t    continue;\n+\t  bit_size_t reg_bit_size;\n+\t  if (reg->get_bit_size (&reg_bit_size))\n+\t    if (concrete_key->get_start_bit_offset ()\n+\t      >= reg_offset.get_bit_offset () + reg_bit_size)\n+\t    continue;\n+\n+\t  /* Get offset of KEY relative to REG, rather than to\n+\t     the cluster.  */\n+\t  bit_offset_t relative_start\n+\t    = (concrete_key->get_start_bit_offset ()\n+\t       - reg_offset.get_bit_offset ());\n+\t  const concrete_binding *offset_concrete_key\n+\t    = mgr->get_concrete_binding (relative_start,\n+\t\t\t\t\t concrete_key->get_size_in_bits (),\n+\t\t\t\t\t key->get_kind ());\n+\t  map.put (offset_concrete_key, sval);\n+\t}\n+      else\n+\treturn NULL;\n+    }\n+\n+  if (map.elements () == 0)\n+    return NULL;\n+\n+  region_model_manager *sval_mgr = mgr->get_svalue_manager ();\n+  return sval_mgr->get_or_create_compound_svalue (reg->get_type (), map);\n+}\n+\n+\n+/* Populate OUT with all bindings within this cluster that overlap REG.  */\n+\n+void\n+binding_cluster::get_overlapping_bindings (store_manager *mgr,\n+\t\t\t\t\t   const region *reg,\n+\t\t\t\t\t   auto_vec<const binding_key *> *out)\n+{\n+  const binding_key *binding\n+    = binding_key::make (mgr, reg, BK_direct);\n+  for (map_t::iterator iter = m_map.begin ();\n+       iter != m_map.end (); ++iter)\n+    {\n+      const binding_key *iter_key = (*iter).first;\n+      if (const concrete_binding *ckey\n+\t    = binding->dyn_cast_concrete_binding ())\n+\t{\n+\t  if (const concrete_binding *iter_ckey\n+\t      = iter_key->dyn_cast_concrete_binding ())\n+\t    {\n+\t      if (ckey->overlaps_p (*iter_ckey))\n+\t\tout->safe_push (iter_key);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Assume overlap.  */\n+\t      out->safe_push (iter_key);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Assume overlap.  */\n+\t  out->safe_push (iter_key);\n+\t}\n+    }\n+}\n+\n+/* Remove any bindings within this cluster that overlap REG,\n+   but retain default bindings that overlap but aren't fully covered\n+   by REG.  */\n+\n+void\n+binding_cluster::remove_overlapping_bindings (store_manager *mgr,\n+\t\t\t\t\t      const region *reg)\n+{\n+  auto_vec<const binding_key *> bindings;\n+  get_overlapping_bindings (mgr, reg, &bindings);\n+\n+  unsigned i;\n+  const binding_key *iter_binding;\n+  FOR_EACH_VEC_ELT (bindings, i, iter_binding)\n+    {\n+      /* Don't remove default bindings, unless the default binding\n+\t is fully covered by REG.  */\n+      if (iter_binding->get_kind () == BK_default)\n+\t{\n+\t  const binding_key *reg_binding\n+\t    = binding_key::make (mgr, reg, BK_default);\n+\t  if (reg_binding != iter_binding)\n+\t    continue;\n+\t}\n+      m_map.remove (iter_binding);\n+    }\n+}\n+\n+/* Attempt to merge CLUSTER_A and CLUSTER_B into OUT_CLUSTER, using\n+   MGR and MERGER.\n+   Return true if they can be merged, false otherwise.  */\n+\n+bool\n+binding_cluster::can_merge_p (const binding_cluster *cluster_a,\n+\t\t\t      const binding_cluster *cluster_b,\n+\t\t\t      binding_cluster *out_cluster,\n+\t\t\t      store_manager *mgr,\n+\t\t\t      model_merger *merger)\n+{\n+  gcc_assert (out_cluster);\n+\n+  /* Merge flags (\"ESCAPED\" and \"TOUCHED\") by setting the merged flag to\n+     true if either of the inputs is true.  */\n+  if ((cluster_a && cluster_a->m_escaped)\n+      || (cluster_b && cluster_b->m_escaped))\n+    out_cluster->m_escaped = true;\n+  if ((cluster_a && cluster_a->m_touched)\n+      || (cluster_b && cluster_b->m_touched))\n+    out_cluster->m_touched = true;\n+\n+  /* At least one of CLUSTER_A and CLUSTER_B are non-NULL, but either\n+     could be NULL.  Handle these cases.  */\n+  if (cluster_a == NULL)\n+    {\n+      gcc_assert (cluster_b != NULL);\n+      gcc_assert (cluster_b->m_base_region == out_cluster->m_base_region);\n+      out_cluster->make_unknown_relative_to (cluster_b, mgr);\n+      return true;\n+    }\n+  if (cluster_b == NULL)\n+    {\n+      gcc_assert (cluster_a != NULL);\n+      gcc_assert (cluster_a->m_base_region == out_cluster->m_base_region);\n+      out_cluster->make_unknown_relative_to (cluster_a, mgr);\n+      return true;\n+    }\n+\n+  /* The \"both inputs are non-NULL\" case.  */\n+  gcc_assert (cluster_a != NULL && cluster_b != NULL);\n+  gcc_assert (cluster_a->m_base_region == out_cluster->m_base_region);\n+  gcc_assert (cluster_b->m_base_region == out_cluster->m_base_region);\n+\n+  hash_set<const binding_key *> keys;\n+  for (map_t::iterator iter_a = cluster_a->m_map.begin ();\n+       iter_a != cluster_a->m_map.end (); ++iter_a)\n+    {\n+      const binding_key *key_a = (*iter_a).first;\n+      keys.add (key_a);\n+    }\n+  for (map_t::iterator iter_b = cluster_b->m_map.begin ();\n+       iter_b != cluster_b->m_map.end (); ++iter_b)\n+    {\n+      const binding_key *key_b = (*iter_b).first;\n+      keys.add (key_b);\n+    }\n+  for (hash_set<const binding_key *>::iterator iter = keys.begin ();\n+       iter != keys.end (); ++iter)\n+    {\n+      const binding_key *key = *iter;\n+      const svalue *sval_a = cluster_a->get_any_value (key);\n+      const svalue *sval_b = cluster_b->get_any_value (key);\n+\n+      if (sval_a == sval_b)\n+\t{\n+\t  gcc_assert (sval_a);\n+\t  out_cluster->m_map.put (key, sval_a);\n+\t  continue;\n+\t}\n+      else if (sval_a && sval_b)\n+\t{\n+\t  region_model_manager *sval_mgr = mgr->get_svalue_manager ();\n+\t  if (const svalue *merged_sval\n+\t      = sval_a->can_merge_p (sval_b, sval_mgr, merger))\n+\t    {\n+\t      out_cluster->m_map.put (key, merged_sval);\n+\t      continue;\n+\t    }\n+\t  /* Merger of the svalues failed.  Reject merger of the cluster.   */\n+\t  return false;\n+\t}\n+\n+      /* If we get here, then one cluster binds this key and the other\n+\t doesn't; merge them as \"UNKNOWN\".  */\n+      gcc_assert (sval_a || sval_b);\n+      tree type = sval_a ? sval_a->get_type () : sval_b->get_type ();\n+      const svalue *unknown_sval\n+\t= mgr->get_svalue_manager ()->get_or_create_unknown_svalue (type);\n+      out_cluster->m_map.put (key, unknown_sval);\n+    }\n+\n+  /* Handle the case where we get a default binding from one and a direct\n+     binding from the other.  */\n+  auto_vec<const concrete_binding *> duplicate_keys;\n+  for (map_t::iterator iter = out_cluster->m_map.begin ();\n+       iter != out_cluster->m_map.end (); ++iter)\n+    {\n+      const concrete_binding *ckey\n+\t= (*iter).first->dyn_cast_concrete_binding ();\n+      if (!ckey)\n+\tcontinue;\n+      if (ckey->get_kind () != BK_direct)\n+\tcontinue;\n+      const concrete_binding *def_ckey\n+\t= mgr->get_concrete_binding (ckey->get_start_bit_offset (),\n+\t\t\t\t     ckey->get_size_in_bits (),\n+\t\t\t\t     BK_default);\n+      if (out_cluster->m_map.get (def_ckey))\n+\tduplicate_keys.safe_push (def_ckey);\n+    }\n+  unsigned i;\n+  const concrete_binding *key;\n+  FOR_EACH_VEC_ELT (duplicate_keys, i, key)\n+    out_cluster->m_map.remove (key);\n+\n+  /* We don't handle other kinds of overlaps yet.  */\n+\n+  return true;\n+}\n+\n+/* Update this cluster to reflect an attempt to merge OTHER where there\n+   is no other cluster to merge with, and so we're notionally merging the\n+   bound values in OTHER with the initial value of the relevant regions.\n+\n+   Any bound keys in OTHER should be bound to unknown in this.  */\n+\n+void\n+binding_cluster::make_unknown_relative_to (const binding_cluster *other,\n+\t\t\t\t\t   store_manager *mgr)\n+{\n+  for (map_t::iterator iter = other->m_map.begin ();\n+       iter != other->m_map.end (); ++iter)\n+    {\n+      const binding_key *iter_key = (*iter).first;\n+      const svalue *iter_sval = (*iter).second;\n+      const svalue *unknown_sval\n+\t= mgr->get_svalue_manager ()->get_or_create_unknown_svalue\n+\t  (iter_sval->get_type ());\n+      m_map.put (iter_key, unknown_sval);\n+    }\n+}\n+\n+/* Mark this cluster as having escaped.  */\n+\n+void\n+binding_cluster::mark_as_escaped ()\n+{\n+  m_escaped = true;\n+}\n+\n+/* If this cluster has escaped (by this call, or by an earlier one, or\n+   by being an external param), then unbind all values and mark it\n+   as \"touched\", so that it has an unknown value, rather than an\n+   initial_svalue.  */\n+\n+void\n+binding_cluster::on_unknown_fncall (const gcall *call,\n+\t\t\t\t    store_manager *mgr)\n+{\n+  if (m_escaped)\n+    {\n+      m_map.empty ();\n+\n+      /* Bind it to a new \"conjured\" value using CALL.  */\n+      const svalue *sval\n+\t= mgr->get_svalue_manager ()->get_or_create_conjured_svalue\n+\t    (m_base_region->get_type (), call, m_base_region);\n+      bind (mgr, m_base_region, sval, BK_direct);\n+\n+      m_touched = true;\n+    }\n+}\n+\n+/* Return true if this binding_cluster has no information\n+   i.e. if there are no bindings, and it hasn't been marked as having\n+   escaped, or touched symbolically.  */\n+\n+bool\n+binding_cluster::redundant_p () const\n+{\n+  return (m_map.elements () == 0\n+\t  && !m_escaped\n+\t  && !m_touched);\n+}\n+\n+/* Find representative path_vars for SVAL within this binding of BASE_REG,\n+   appending the results to OUT_PVS.  */\n+\n+void\n+binding_cluster::get_representative_path_vars (const region_model *model,\n+\t\t\t\t\t       svalue_set *visited,\n+\t\t\t\t\t       const region *base_reg,\n+\t\t\t\t\t       const svalue *sval,\n+\t\t\t\t\t       auto_vec<path_var> *out_pvs)\n+  const\n+{\n+  sval = simplify_for_binding (sval);\n+\n+  for (map_t::iterator iter = m_map.begin (); iter != m_map.end (); ++iter)\n+    {\n+      const binding_key *key = (*iter).first;\n+      const svalue *bound_sval = (*iter).second;\n+      if (bound_sval == sval)\n+\t{\n+\t  if (const concrete_binding *ckey\n+\t\t= key->dyn_cast_concrete_binding ())\n+\t    {\n+\t      auto_vec <const region *> subregions;\n+\t      base_reg->get_subregions_for_binding\n+\t\t(model->get_manager (),\n+\t\t ckey->get_start_bit_offset (),\n+\t\t ckey->get_size_in_bits (),\n+\t\t sval->get_type (),\n+\t\t &subregions);\n+\t      unsigned i;\n+\t      const region *subregion;\n+\t      FOR_EACH_VEC_ELT (subregions, i, subregion)\n+\t\t{\n+\t\t  if (path_var pv\n+\t\t      = model->get_representative_path_var (subregion,\n+\t\t\t\t\t\t\t    visited))\n+\t\t    out_pvs->safe_push (pv);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      const symbolic_binding *skey = (const symbolic_binding *)key;\n+\t      if (path_var pv\n+\t\t  = model->get_representative_path_var (skey->get_region (),\n+\t\t\t\t\t\t\tvisited))\n+\t\tout_pvs->safe_push (pv);\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Get any svalue bound to KEY, or NULL.  */\n+\n+const svalue *\n+binding_cluster::get_any_value (const binding_key *key) const\n+{\n+  return m_map.get (key);\n+}\n+\n+/* If this cluster has a single direct binding for the whole of the region,\n+   return it.\n+   For use in simplifying dumps.  */\n+\n+const svalue *\n+binding_cluster::maybe_get_simple_value (store_manager *mgr) const\n+{\n+  /* Fail gracefully if MGR is NULL to make it easier to dump store\n+     instances in the debugger.  */\n+  if (mgr == NULL)\n+    return NULL;\n+\n+  if (m_map.elements () != 1)\n+    return NULL;\n+\n+  const binding_key *key = binding_key::make (mgr, m_base_region, BK_direct);\n+  return get_any_value (key);\n+}\n+\n+/* class store_manager.  */\n+\n+/* binding consolidation.  */\n+\n+const concrete_binding *\n+store_manager::get_concrete_binding (bit_offset_t start_bit_offset,\n+\t\t\t\t     bit_offset_t size_in_bits,\n+\t\t\t\t     enum binding_kind kind)\n+{\n+  concrete_binding b (start_bit_offset, size_in_bits, kind);\n+  if (concrete_binding *existing = m_concrete_binding_key_mgr.get (b))\n+    return existing;\n+\n+  concrete_binding *to_save = new concrete_binding (b);\n+  m_concrete_binding_key_mgr.put (b, to_save);\n+  return to_save;\n+}\n+\n+const symbolic_binding *\n+store_manager::get_symbolic_binding (const region *reg,\n+\t\t\t\t     enum binding_kind kind)\n+{\n+  symbolic_binding b (reg, kind);\n+  if (symbolic_binding *existing = m_symbolic_binding_key_mgr.get (b))\n+    return existing;\n+\n+  symbolic_binding *to_save = new symbolic_binding (b);\n+  m_symbolic_binding_key_mgr.put (b, to_save);\n+  return to_save;\n+}\n+\n+/* class store.  */\n+\n+/* store's default ctor.  */\n+\n+store::store ()\n+: m_called_unknown_fn (false)\n+{\n+}\n+\n+/* store's copy ctor.  */\n+\n+store::store (const store &other)\n+: m_called_unknown_fn (other.m_called_unknown_fn)\n+{\n+  for (cluster_map_t::iterator iter = other.m_cluster_map.begin ();\n+       iter != other.m_cluster_map.end ();\n+       ++iter)\n+    {\n+      const region *reg = (*iter).first;\n+      gcc_assert (reg);\n+      binding_cluster *c = (*iter).second;\n+      gcc_assert (c);\n+      m_cluster_map.put (reg, new binding_cluster (*c));\n+    }\n+}\n+\n+/* store's dtor.  */\n+\n+store::~store ()\n+{\n+  for (cluster_map_t::iterator iter = m_cluster_map.begin ();\n+       iter != m_cluster_map.end ();\n+       ++iter)\n+    delete (*iter).second;\n+}\n+\n+/* store's assignment operator.  */\n+\n+store &\n+store::operator= (const store &other)\n+{\n+  /* Delete existing cluster map.  */\n+  for (cluster_map_t::iterator iter = m_cluster_map.begin ();\n+       iter != m_cluster_map.end ();\n+       ++iter)\n+    delete (*iter).second;\n+  m_cluster_map.empty ();\n+\n+  m_called_unknown_fn = other.m_called_unknown_fn;\n+\n+  for (cluster_map_t::iterator iter = other.m_cluster_map.begin ();\n+       iter != other.m_cluster_map.end ();\n+       ++iter)\n+    {\n+      const region *reg = (*iter).first;\n+      gcc_assert (reg);\n+      binding_cluster *c = (*iter).second;\n+      gcc_assert (c);\n+      m_cluster_map.put (reg, new binding_cluster (*c));\n+    }\n+  return *this;\n+}\n+\n+/* store's equality operator.  */\n+\n+bool\n+store::operator== (const store &other) const\n+{\n+  if (m_called_unknown_fn != other.m_called_unknown_fn)\n+    return false;\n+\n+  if (m_cluster_map.elements () != other.m_cluster_map.elements ())\n+    return false;\n+\n+  for (cluster_map_t::iterator iter = m_cluster_map.begin ();\n+       iter != m_cluster_map.end ();\n+       ++iter)\n+    {\n+      const region *reg = (*iter).first;\n+      binding_cluster *c = (*iter).second;\n+      binding_cluster **other_slot\n+\t= const_cast <cluster_map_t &> (other.m_cluster_map).get (reg);\n+      if (other_slot == NULL)\n+\treturn false;\n+      if (*c != **other_slot)\n+\treturn false;\n+    }\n+\n+  gcc_checking_assert (hash () == other.hash ());\n+\n+  return true;\n+}\n+\n+/* Get a hash value for this store.  */\n+\n+hashval_t\n+store::hash () const\n+{\n+  hashval_t result = 0;\n+  for (cluster_map_t::iterator iter = m_cluster_map.begin ();\n+       iter != m_cluster_map.end ();\n+       ++iter)\n+    result ^= (*iter).second->hash ();\n+  return result;\n+}\n+\n+/* Populate OUT with a sorted list of parent regions for the regions in IN,\n+   removing duplicate parents.  */\n+\n+static void\n+get_sorted_parent_regions (auto_vec<const region *> *out,\n+\t\t\t   auto_vec<const region *> &in)\n+{\n+  /* Get the set of parent regions.  */\n+  hash_set<const region *> parent_regions;\n+  const region *iter_reg;\n+  unsigned i;\n+  FOR_EACH_VEC_ELT (in, i, iter_reg)\n+    {\n+      const region *parent_reg = iter_reg->get_parent_region ();\n+      gcc_assert (parent_reg);\n+      parent_regions.add (parent_reg);\n+    }\n+\n+  /* Write to OUT.  */\n+  for (hash_set<const region *>::iterator iter = parent_regions.begin();\n+       iter != parent_regions.end(); ++iter)\n+    out->safe_push (*iter);\n+\n+  /* Sort OUT.  */\n+  out->qsort (region::cmp_ptrs);\n+}\n+\n+/* Dump a representation of this store to PP, using SIMPLE to control how\n+   svalues and regions are printed.\n+   MGR is used for simplifying dumps if non-NULL, but can also be NULL\n+   (to make it easier to use from the debugger).  */\n+\n+void\n+store::dump_to_pp (pretty_printer *pp, bool simple, bool multiline,\n+\t\t   store_manager *mgr) const\n+{\n+  /* Sort into some deterministic order.  */\n+  auto_vec<const region *> base_regions;\n+  for (cluster_map_t::iterator iter = m_cluster_map.begin ();\n+       iter != m_cluster_map.end (); ++iter)\n+    {\n+      const region *base_reg = (*iter).first;\n+      base_regions.safe_push (base_reg);\n+    }\n+  base_regions.qsort (region::cmp_ptrs);\n+\n+  /* Gather clusters, organize by parent region, so that we can group\n+     together locals, globals, etc.  */\n+  auto_vec<const region *> parent_regions;\n+  get_sorted_parent_regions (&parent_regions, base_regions);\n+\n+  const region *parent_reg;\n+  unsigned i;\n+  FOR_EACH_VEC_ELT (parent_regions, i, parent_reg)\n+    {\n+      gcc_assert (parent_reg);\n+      pp_string (pp, \"clusters within \");\n+      parent_reg->dump_to_pp (pp, simple);\n+      if (multiline)\n+\tpp_newline (pp);\n+      else\n+\tpp_string (pp, \" {\");\n+\n+      const region *base_reg;\n+      unsigned j;\n+      FOR_EACH_VEC_ELT (base_regions, j, base_reg)\n+\t{\n+\t  /* This is O(N * M), but N ought to be small.  */\n+\t  if (base_reg->get_parent_region () != parent_reg)\n+\t    continue;\n+\t  binding_cluster *cluster\n+\t    = *const_cast<cluster_map_t &> (m_cluster_map).get (base_reg);\n+\t  if (!multiline)\n+\t    {\n+\t      if (j > 0)\n+\t\tpp_string (pp, \", \");\n+\t    }\n+\t  if (const svalue *sval = cluster->maybe_get_simple_value (mgr))\n+\t    {\n+\t      /* Special-case to simplify dumps for the common case where\n+\t\t we just have one value directly bound to the whole of a\n+\t\t region.  */\n+\t      if (multiline)\n+\t\t{\n+\t\t  pp_string (pp, \"  cluster for: \");\n+\t\t  base_reg->dump_to_pp (pp, simple);\n+\t\t  pp_string (pp, \": \");\n+\t\t  sval->dump_to_pp (pp, simple);\n+\t\t  if (cluster->escaped_p ())\n+\t\t    pp_string (pp, \" (ESCAPED)\");\n+\t\t  if (cluster->touched_p ())\n+\t\t    pp_string (pp, \" (TOUCHED)\");\n+\t\t  pp_newline (pp);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  pp_string (pp, \"region: {\");\n+\t\t  base_reg->dump_to_pp (pp, simple);\n+\t\t  pp_string (pp, \", value: \");\n+\t\t  sval->dump_to_pp (pp, simple);\n+\t\t  if (cluster->escaped_p ())\n+\t\t    pp_string (pp, \" (ESCAPED)\");\n+\t\t  if (cluster->touched_p ())\n+\t\t    pp_string (pp, \" (TOUCHED)\");\n+\t\t  pp_string (pp, \"}\");\n+\t\t}\n+\t    }\n+\t  else if (multiline)\n+\t    {\n+\t      pp_string (pp, \"  cluster for: \");\n+\t      base_reg->dump_to_pp (pp, simple);\n+\t      pp_newline (pp);\n+\t      cluster->dump_to_pp (pp, simple, multiline);\n+\t    }\n+\t  else\n+\t    {\n+\t      pp_string (pp, \"base region: {\");\n+\t      base_reg->dump_to_pp (pp, simple);\n+\t      pp_string (pp, \"} has cluster: {\");\n+\t      cluster->dump_to_pp (pp, simple, multiline);\n+\t      pp_string (pp, \"}\");\n+\t    }\n+\t}\n+      if (!multiline)\n+\tpp_string (pp, \"}\");\n+    }\n+  pp_printf (pp, \"m_called_unknown_fn: %s\",\n+\t     m_called_unknown_fn ? \"TRUE\" : \"FALSE\");\n+  if (multiline)\n+    pp_newline (pp);\n+}\n+\n+/* Dump a multiline representation of this store to stderr.  */\n+\n+DEBUG_FUNCTION void\n+store::dump (bool simple) const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = stderr;\n+  dump_to_pp (&pp, simple, true, NULL);\n+  pp_newline (&pp);\n+  pp_flush (&pp);\n+}\n+\n+/* Get any svalue bound to REG, or NULL.  */\n+\n+const svalue *\n+store::get_any_binding (store_manager *mgr, const region *reg) const\n+{\n+  const region *base_reg = reg->get_base_region ();\n+  binding_cluster **cluster_slot\n+    = const_cast <cluster_map_t &> (m_cluster_map).get (base_reg);\n+  if (!cluster_slot)\n+    return NULL;\n+  return (*cluster_slot)->get_any_binding (mgr, reg);\n+}\n+\n+/* Set the value of LHS_REG to RHS_SVAL.  */\n+\n+void\n+store::set_value (store_manager *mgr, const region *lhs_reg,\n+\t\t  const svalue *rhs_sval, enum binding_kind kind)\n+{\n+  remove_overlapping_bindings (mgr, lhs_reg);\n+\n+  rhs_sval = simplify_for_binding (rhs_sval);\n+\n+  const region *lhs_base_reg = lhs_reg->get_base_region ();\n+  binding_cluster *lhs_cluster;\n+  if (lhs_base_reg->symbolic_for_unknown_ptr_p ())\n+    /* Reject attempting to bind values into a symbolic region\n+       for an unknown ptr; merely invalidate values below.  */\n+    lhs_cluster = NULL;\n+  else\n+    {\n+      lhs_cluster = get_or_create_cluster (lhs_base_reg);\n+      lhs_cluster->bind (mgr, lhs_reg, rhs_sval, kind);\n+    }\n+\n+  /* Bindings to a cluster can affect other clusters if a symbolic\n+     base region is involved.\n+     Writes to concrete clusters can't affect other concrete clusters,\n+     but can affect symbolic clusters.\n+     Writes to symbolic clusters can affect both concrete and symbolic\n+     clusters.\n+     Invalidate our knowledge of other clusters that might have been\n+     affected by the write.  */\n+  for (cluster_map_t::iterator iter = m_cluster_map.begin ();\n+       iter != m_cluster_map.end (); ++iter)\n+    {\n+      const region *iter_base_reg = (*iter).first;\n+      binding_cluster *iter_cluster = (*iter).second;\n+      if (iter_base_reg != lhs_base_reg\n+\t  && (lhs_cluster == NULL\n+\t      || lhs_cluster->symbolic_p ()\n+\t      || iter_cluster->symbolic_p ()))\n+\t{\n+\t  tristate t_alias = eval_alias (lhs_base_reg, iter_base_reg);\n+\t  switch (t_alias.get_value ())\n+\t    {\n+\t    default:\n+\t      gcc_unreachable ();\n+\n+\t    case tristate::TS_UNKNOWN:\n+\t      iter_cluster->mark_region_as_unknown (mgr, iter_base_reg);\n+\t      break;\n+\n+\t    case tristate::TS_TRUE:\n+\t      gcc_unreachable ();\n+\t      break;\n+\n+\t    case tristate::TS_FALSE:\n+\t      /* If they can't be aliases, then don't invalidate this\n+\t\t cluster.  */\n+\t      break;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Determine if BASE_REG_A could be an alias of BASE_REG_B.  */\n+\n+tristate\n+store::eval_alias (const region *base_reg_a,\n+\t\t   const region *base_reg_b)\n+{\n+  /* SSA names can't alias.  */\n+  tree decl_a = base_reg_a->maybe_get_decl ();\n+  if (decl_a && TREE_CODE (decl_a) == SSA_NAME)\n+    return tristate::TS_FALSE;\n+  tree decl_b = base_reg_b->maybe_get_decl ();\n+  if (decl_b && TREE_CODE (decl_b) == SSA_NAME)\n+    return tristate::TS_FALSE;\n+\n+  if (const symbolic_region *sym_reg_a\n+      = base_reg_a->dyn_cast_symbolic_region ())\n+    {\n+      const svalue *sval_a = sym_reg_a->get_pointer ();\n+      if (sval_a->get_kind () == SK_INITIAL\n+\t  && decl_b\n+\t  && !is_global_var (decl_b))\n+\t{\n+\t  /* The initial value of a pointer can't point to a local.  */\n+\t  return tristate::TS_FALSE;\n+\t}\n+    }\n+  if (const symbolic_region *sym_reg_b\n+      = base_reg_b->dyn_cast_symbolic_region ())\n+    {\n+      const svalue *sval_b = sym_reg_b->get_pointer ();\n+      if (sval_b->get_kind () == SK_INITIAL\n+\t  && decl_a\n+\t  && !is_global_var (decl_a))\n+\t{\n+\t  /* The initial value of a pointer can't point to a local.  */\n+\t  return tristate::TS_FALSE;\n+\t}\n+    }\n+\n+  return tristate::TS_UNKNOWN;\n+}\n+\n+/* Remove all bindings overlapping REG within this store.  */\n+\n+void\n+store::clobber_region (store_manager *mgr, const region *reg)\n+{\n+  const region *base_reg = reg->get_base_region ();\n+  binding_cluster **slot = m_cluster_map.get (base_reg);\n+  if (!slot)\n+    return;\n+  binding_cluster *cluster = *slot;\n+  cluster->clobber_region (mgr, reg);\n+  if (cluster->redundant_p ())\n+    {\n+      delete cluster;\n+      m_cluster_map.remove (base_reg);\n+    }\n+}\n+\n+/* Remove any bindings for REG within this store.  */\n+\n+void\n+store::purge_region (store_manager *mgr, const region *reg)\n+{\n+  const region *base_reg = reg->get_base_region ();\n+  binding_cluster **slot = m_cluster_map.get (base_reg);\n+  if (!slot)\n+    return;\n+  binding_cluster *cluster = *slot;\n+  cluster->purge_region (mgr, reg);\n+  if (cluster->redundant_p ())\n+    {\n+      delete cluster;\n+      m_cluster_map.remove (base_reg);\n+    }\n+}\n+\n+/* Zero-fill REG.  */\n+\n+void\n+store::zero_fill_region (store_manager *mgr, const region *reg)\n+{\n+  const region *base_reg = reg->get_base_region ();\n+  if (base_reg->symbolic_for_unknown_ptr_p ())\n+    return;\n+  binding_cluster *cluster = get_or_create_cluster (base_reg);\n+  cluster->zero_fill_region (mgr, reg);\n+}\n+\n+/* Mark REG as having unknown content.  */\n+\n+void\n+store::mark_region_as_unknown (store_manager *mgr, const region *reg)\n+{\n+  const region *base_reg = reg->get_base_region ();\n+  if (base_reg->symbolic_for_unknown_ptr_p ())\n+    return;\n+  binding_cluster *cluster = get_or_create_cluster (base_reg);\n+  cluster->mark_region_as_unknown (mgr, reg);\n+}\n+\n+/* Get the cluster for BASE_REG, or NULL (const version).  */\n+\n+const binding_cluster *\n+store::get_cluster (const region *base_reg) const\n+{\n+  gcc_assert (base_reg);\n+  gcc_assert (base_reg->get_base_region () == base_reg);\n+  if (binding_cluster **slot\n+\t= const_cast <cluster_map_t &> (m_cluster_map).get (base_reg))\n+    return *slot;\n+  else\n+    return NULL;\n+}\n+\n+/* Get the cluster for BASE_REG, or NULL (non-const version).  */\n+\n+binding_cluster *\n+store::get_cluster (const region *base_reg)\n+{\n+  gcc_assert (base_reg);\n+  gcc_assert (base_reg->get_base_region () == base_reg);\n+  if (binding_cluster **slot = m_cluster_map.get (base_reg))\n+    return *slot;\n+  else\n+    return NULL;\n+}\n+\n+/* Get the cluster for BASE_REG, creating it if doesn't already exist.  */\n+\n+binding_cluster *\n+store::get_or_create_cluster (const region *base_reg)\n+{\n+  gcc_assert (base_reg);\n+  gcc_assert (base_reg->get_base_region () == base_reg);\n+\n+  /* We shouldn't create clusters for dereferencing an UNKNOWN ptr.  */\n+  gcc_assert (!base_reg->symbolic_for_unknown_ptr_p ());\n+\n+  if (binding_cluster **slot = m_cluster_map.get (base_reg))\n+    return *slot;\n+\n+  binding_cluster *cluster = new binding_cluster (base_reg);\n+  m_cluster_map.put (base_reg, cluster);\n+\n+  return cluster;\n+}\n+\n+/* Remove any cluster for BASE_REG, for use by\n+   region_model::unbind_region_and_descendents\n+   when popping stack frames and handling deleted heap regions.  */\n+\n+void\n+store::purge_cluster (const region *base_reg)\n+{\n+  gcc_assert (base_reg->get_base_region () == base_reg);\n+  binding_cluster **slot = m_cluster_map.get (base_reg);\n+  if (!slot)\n+    return;\n+  binding_cluster *cluster = *slot;\n+  delete cluster;\n+  m_cluster_map.remove (base_reg);\n+}\n+\n+/* Attempt to merge STORE_A and STORE_B into OUT_STORE.\n+   Return true if successful, or false if the stores can't be merged.  */\n+\n+bool\n+store::can_merge_p (const store *store_a, const store *store_b,\n+\t\t    store *out_store, store_manager *mgr,\n+\t\t    model_merger *merger)\n+{\n+  if (store_a->m_called_unknown_fn || store_b->m_called_unknown_fn)\n+    out_store->m_called_unknown_fn = true;\n+\n+  /* Get the union of all base regions for STORE_A and STORE_B.  */\n+  hash_set<const region *> base_regions;\n+  for (cluster_map_t::iterator iter_a = store_a->m_cluster_map.begin ();\n+       iter_a != store_a->m_cluster_map.end (); ++iter_a)\n+    {\n+      const region *base_reg_a = (*iter_a).first;\n+      base_regions.add (base_reg_a);\n+    }\n+  for (cluster_map_t::iterator iter_b = store_b->m_cluster_map.begin ();\n+       iter_b != store_b->m_cluster_map.end (); ++iter_b)\n+    {\n+      const region *base_reg_b = (*iter_b).first;\n+      base_regions.add (base_reg_b);\n+    }\n+\n+  for (hash_set<const region *>::iterator iter = base_regions.begin ();\n+       iter != base_regions.end (); ++iter)\n+    {\n+      const region *base_reg = *iter;\n+      const binding_cluster *cluster_a = store_a->get_cluster (base_reg);\n+      const binding_cluster *cluster_b = store_b->get_cluster (base_reg);\n+      /* At least one of cluster_a and cluster_b must be non-NULL.  */\n+      binding_cluster *out_cluster\n+\t= out_store->get_or_create_cluster (base_reg);\n+      if (!binding_cluster::can_merge_p (cluster_a, cluster_b,\n+\t\t\t\t\t out_cluster, mgr, merger))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Mark the cluster for BASE_REG as having escaped.\n+   For use when handling an unrecognized function call, and\n+   for params to \"top-level\" calls.\n+   Further unknown function calls could touch it, even if the cluster\n+   isn't reachable from args of those calls.  */\n+\n+void\n+store::mark_as_escaped (const region *base_reg)\n+{\n+  gcc_assert (base_reg);\n+  gcc_assert (base_reg->get_base_region () == base_reg);\n+\n+  binding_cluster *cluster = get_or_create_cluster (base_reg);\n+  cluster->mark_as_escaped ();\n+}\n+\n+/* Handle an unknown fncall by updating any clusters that have escaped\n+   (either in this fncall, or in a prior one).  */\n+\n+void\n+store::on_unknown_fncall (const gcall *call, store_manager *mgr)\n+{\n+  m_called_unknown_fn = true;\n+\n+  for (cluster_map_t::iterator iter = m_cluster_map.begin ();\n+       iter != m_cluster_map.end (); ++iter)\n+    (*iter).second->on_unknown_fncall (call, mgr);\n+}\n+\n+/* Return true if a non-const pointer to BASE_REG (or something within it)\n+   has escaped to code outside of the TU being analyzed.  */\n+\n+bool\n+store::escaped_p (const region *base_reg) const\n+{\n+  gcc_assert (base_reg);\n+  gcc_assert (base_reg->get_base_region () == base_reg);\n+\n+  if (binding_cluster **cluster_slot\n+      = const_cast <cluster_map_t &>(m_cluster_map).get (base_reg))\n+    return (*cluster_slot)->escaped_p ();\n+  return false;\n+}\n+\n+/* Populate OUT_PVS with a list of path_vars for describing SVAL based on\n+   this store, using VISITED to ensure the traversal terminates.  */\n+\n+void\n+store::get_representative_path_vars (const region_model *model,\n+\t\t\t\t     svalue_set *visited,\n+\t\t\t\t     const svalue *sval,\n+\t\t\t\t     auto_vec<path_var> *out_pvs) const\n+{\n+  gcc_assert (sval);\n+\n+  /* Find all bindings that reference SVAL.  */\n+  for (cluster_map_t::iterator iter = m_cluster_map.begin ();\n+       iter != m_cluster_map.end (); ++iter)\n+    {\n+      const region *base_reg = (*iter).first;\n+      binding_cluster *cluster = (*iter).second;\n+      cluster->get_representative_path_vars (model, visited, base_reg, sval,\n+\t\t\t\t\t     out_pvs);\n+    }\n+\n+  if (const initial_svalue *init_sval = sval->dyn_cast_initial_svalue ())\n+    {\n+      const region *reg = init_sval->get_region ();\n+      if (path_var pv = model->get_representative_path_var (reg,\n+\t\t\t\t\t\t\t    visited))\n+\tout_pvs->safe_push (pv);\n+    }\n+}\n+\n+/* Remove all bindings overlapping REG within this store, removing\n+   any clusters that become redundant.  */\n+\n+void\n+store::remove_overlapping_bindings (store_manager *mgr, const region *reg)\n+{\n+  const region *base_reg = reg->get_base_region ();\n+  if (binding_cluster **cluster_slot = m_cluster_map.get (base_reg))\n+    {\n+      binding_cluster *cluster = *cluster_slot;\n+      if (reg == base_reg && !escaped_p (base_reg))\n+\t{\n+\t  /* Remove whole cluster.  */\n+\t  m_cluster_map.remove (base_reg);\n+\t  delete cluster;\n+\t  return;\n+\t}\n+      cluster->remove_overlapping_bindings (mgr, reg);\n+    }\n+}\n+\n+/* Subclass of visitor that accumulates a hash_set of the regions that\n+   were visited.  */\n+\n+struct region_finder : public visitor\n+{\n+  void visit_region (const region *reg) FINAL OVERRIDE\n+  {\n+    m_regs.add (reg);\n+  }\n+\n+  hash_set<const region *> m_regs;\n+};\n+\n+/* Canonicalize this store, to maximize the chance of equality between\n+   instances.  */\n+\n+void\n+store::canonicalize (store_manager *mgr)\n+{\n+  /* If we have e.g.:\n+         cluster for: HEAP_ALLOCATED_REGION(543)\n+           ESCAPED\n+           TOUCHED\n+     where the heap region is empty and unreferenced, then purge that\n+     cluster, to avoid unbounded state chains involving these.  */\n+\n+  /* Find regions that are referenced by bound values in the store.  */\n+  region_finder s;\n+  for (cluster_map_t::iterator iter = m_cluster_map.begin ();\n+       iter != m_cluster_map.end (); ++iter)\n+    {\n+      binding_cluster *cluster = (*iter).second;\n+      for (binding_cluster::iterator_t bind_iter = cluster->m_map.begin ();\n+\t   bind_iter != cluster->m_map.end (); ++bind_iter)\n+\t(*bind_iter).second->accept (&s);\n+    }\n+\n+  /* Locate heap-allocated regions that have empty bindings that weren't\n+     found above.  */\n+  hash_set<const region *> purgeable_regions;\n+  for (cluster_map_t::iterator iter = m_cluster_map.begin ();\n+       iter != m_cluster_map.end (); ++iter)\n+    {\n+      const region *base_reg = (*iter).first;\n+      binding_cluster *cluster = (*iter).second;\n+      if (base_reg->get_kind () == RK_HEAP_ALLOCATED)\n+\t{\n+\t  if (cluster->empty_p ())\n+\t    if (!s.m_regs.contains (base_reg))\n+\t      purgeable_regions.add (base_reg);\n+\n+\t  /* Also cover the UNKNOWN case.  */\n+\t  if (const svalue *sval = cluster->maybe_get_simple_value (mgr))\n+\t    if (sval->get_kind () == SK_UNKNOWN)\n+\t      if (!s.m_regs.contains (base_reg))\n+\t\tpurgeable_regions.add (base_reg);\n+\t}\n+    }\n+\n+  /* Purge them.  */\n+  for (hash_set<const region *>::iterator iter = purgeable_regions.begin ();\n+       iter != purgeable_regions.end (); ++iter)\n+    {\n+      const region *base_reg = *iter;\n+      purge_cluster (base_reg);\n+    }\n+}\n+\n+/* Subroutine for use by exploded_path::feasible_p.\n+\n+   We need to deal with state differences between:\n+   (a) when the exploded_graph is being initially constructed and\n+   (b) when replaying the state changes along a specific path in\n+   in exploded_path::feasible_p.\n+\n+   In (a), state merging happens, so when exploring a loop\n+     for (i = 0; i < 1024; i++)\n+   on successive iterations we have i == 0, then i == WIDENING.\n+\n+   In (b), no state merging happens, so naively replaying the path\n+   that goes twice through the loop then exits it\n+   would lead to i == 0, then i == 1, and then a (i >= 1024) eedge\n+   that exits the loop, which would be found to be infeasible as i == 1,\n+   and the path would be rejected.\n+\n+   We need to fix up state during replay.  This subroutine is\n+   called whenever we enter a supernode that we've already\n+   visited along this exploded_path, passing in OTHER_STORE\n+   from the destination enode's state.\n+\n+   Find bindings to widening values in OTHER_STORE.\n+   For all that are found, update the binding in this store to UNKNOWN.  */\n+\n+void\n+store::loop_replay_fixup (const store *other_store,\n+\t\t\t  region_model_manager *mgr)\n+{\n+  gcc_assert (other_store);\n+  for (cluster_map_t::iterator iter = other_store->m_cluster_map.begin ();\n+       iter != other_store->m_cluster_map.end (); ++iter)\n+    {\n+      const region *base_reg = (*iter).first;\n+      binding_cluster *cluster = (*iter).second;\n+      for (binding_cluster::iterator_t bind_iter = cluster->m_map.begin ();\n+\t   bind_iter != cluster->m_map.end (); ++bind_iter)\n+\t{\n+\t  const binding_key *key = (*bind_iter).first;\n+\t  const svalue *sval = (*bind_iter).second;\n+\t  if (sval->get_kind () == SK_WIDENING)\n+\t    {\n+\t      binding_cluster *this_cluster\n+\t\t= get_or_create_cluster (base_reg);\n+\t      const svalue *unknown\n+\t\t= mgr->get_or_create_unknown_svalue (sval->get_type ());\n+\t      this_cluster->bind_key (key, unknown);\n+\t    }\n+\t}\n+    }\n+}\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Implementation detail of ASSERT_OVERLAP.  */\n+\n+static void\n+assert_overlap (const location &loc,\n+\t\tconst concrete_binding *b1,\n+\t\tconst concrete_binding *b2)\n+{\n+  ASSERT_TRUE_AT (loc, b1->overlaps_p (*b2));\n+  ASSERT_TRUE_AT (loc, b2->overlaps_p (*b1));\n+}\n+\n+/* Implementation detail of ASSERT_DISJOINT.  */\n+\n+static void\n+assert_disjoint (const location &loc,\n+\t\t const concrete_binding *b1,\n+\t\t const concrete_binding *b2)\n+{\n+  ASSERT_FALSE_AT (loc, b1->overlaps_p (*b2));\n+  ASSERT_FALSE_AT (loc, b2->overlaps_p (*b1));\n+}\n+\n+/* Assert that B1 and B2 overlap, checking both ways.  */\n+\n+#define ASSERT_OVERLAP(B1, B2) \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\\\n+  assert_overlap (SELFTEST_LOCATION, B1, B2);\t\\\n+  SELFTEST_END_STMT\n+\n+/* Assert that B1 and B2 do not overlap, checking both ways.  */\n+\n+#define ASSERT_DISJOINT(B1, B2) \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\\\n+  assert_disjoint (SELFTEST_LOCATION, B1, B2);  \\\n+  SELFTEST_END_STMT\n+\n+/* Verify that concrete_binding::overlaps_p works as expected.  */\n+\n+static void\n+test_binding_key_overlap ()\n+{\n+  store_manager mgr (NULL);\n+\n+  /* Various 8-bit bindings.  */\n+  const concrete_binding *cb_0_7\n+    = mgr.get_concrete_binding (0, 8, BK_direct);\n+  const concrete_binding *cb_8_15\n+    = mgr.get_concrete_binding (8, 8, BK_direct);\n+  const concrete_binding *cb_16_23\n+    = mgr.get_concrete_binding (16, 8, BK_direct);\n+  const concrete_binding *cb_24_31\n+    = mgr.get_concrete_binding (24, 8, BK_direct);\n+\n+  /* 16-bit bindings.  */\n+  const concrete_binding *cb_0_15\n+    = mgr.get_concrete_binding (0, 16, BK_direct);\n+  const concrete_binding *cb_8_23\n+    = mgr.get_concrete_binding (8, 16, BK_direct);\n+  const concrete_binding *cb_16_31\n+    = mgr.get_concrete_binding (16, 16, BK_direct);\n+\n+  /* 32-bit binding.  */\n+  const concrete_binding *cb_0_31\n+    = mgr.get_concrete_binding (0, 32, BK_direct);\n+\n+  /* Everything should self-overlap.  */\n+  ASSERT_OVERLAP (cb_0_7, cb_0_7);\n+  ASSERT_OVERLAP (cb_8_15, cb_8_15);\n+  ASSERT_OVERLAP (cb_16_23, cb_16_23);\n+  ASSERT_OVERLAP (cb_24_31, cb_24_31);\n+  ASSERT_OVERLAP (cb_0_15, cb_0_15);\n+  ASSERT_OVERLAP (cb_8_23, cb_8_23);\n+  ASSERT_OVERLAP (cb_16_31, cb_16_31);\n+  ASSERT_OVERLAP (cb_0_31, cb_0_31);\n+\n+  /* Verify the 8-bit bindings that don't overlap each other.  */\n+  ASSERT_DISJOINT (cb_0_7, cb_8_15);\n+  ASSERT_DISJOINT (cb_8_15, cb_16_23);\n+\n+  /* Check for overlap of differently-sized bindings.  */\n+  ASSERT_OVERLAP (cb_0_7, cb_0_31);\n+  /* ...and with differing start points.  */\n+  ASSERT_OVERLAP (cb_8_15, cb_0_31);\n+  ASSERT_DISJOINT (cb_8_15, cb_16_31);\n+  ASSERT_OVERLAP (cb_16_23, cb_0_31);\n+  ASSERT_OVERLAP (cb_16_31, cb_0_31);\n+\n+  ASSERT_DISJOINT (cb_0_7, cb_8_23);\n+  ASSERT_OVERLAP (cb_8_23, cb_16_23);\n+  ASSERT_OVERLAP (cb_8_23, cb_16_31);\n+  ASSERT_DISJOINT (cb_8_23, cb_24_31);\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+analyzer_store_cc_tests ()\n+{\n+  test_binding_key_overlap ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* CHECKING_P */\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "4f251d6420fb9f0be78410c7153aa97168883232", "filename": "gcc/analyzer/store.h", "status": "added", "additions": 613, "deletions": 0, "changes": 613, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fstore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fstore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.h?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,613 @@\n+/* Classes for modeling the state of memory.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_STORE_H\n+#define GCC_ANALYZER_STORE_H\n+\n+/* Implementation of the region-based ternary model described in:\n+     \"A Memory Model for Static Analysis of C Programs\"\n+      (Zhongxing Xu, Ted Kremenek, and Jian Zhang)\n+     http://lcs.ios.ac.cn/~xuzb/canalyze/memmodel.pdf  */\n+\n+/* The store models memory as a collection of \"clusters\", where regions\n+   are partitioned into clusters via their base region.\n+\n+   For example, given:\n+     int a, b, c;\n+     struct coord { double x; double y; } verts[3];\n+   then \"verts[0].y\" and \"verts[1].x\" both have \"verts\" as their base region.\n+   Each of a, b, c, and verts will have their own clusters, so that we\n+   know that writes to e.g. \"verts[1].x\".don't affect e.g. \"a\".\n+\n+   Within each cluster we store a map of bindings to values, where the\n+   binding keys can be either concrete or symbolic.\n+\n+   Concrete bindings affect a specific range of bits relative to the start\n+   of the base region of the cluster, whereas symbolic bindings affect\n+   a specific subregion within the cluster.\n+\n+   Consider (from the symbolic-1.c testcase):\n+\n+     char arr[1024];\n+     arr[2] = a;  (1)\n+     arr[3] = b;  (2)\n+       After (1) and (2), the cluster for \"arr\" has concrete bindings\n+       for bits 16-23 and for bits 24-31, with svalues \"INIT_VAL(a)\"\n+       and \"INIT_VAL(b)\" respectively:\n+       cluster: {bits 16-23: \"INIT_VAL(a)\",\n+                 bits 24-31: \"INIT_VAL(b)\";\n+                 flags: {}}\n+       Attempting to query unbound subregions e.g. arr[4] will\n+       return \"UNINITIALIZED\".\n+       \"a\" and \"b\" are each in their own clusters, with no explicit\n+       bindings, and thus implicitly have value INIT_VAL(a) and INIT_VAL(b).\n+\n+     arr[3] = c;  (3)\n+       After (3), the concrete binding for bits 24-31 is replaced with the\n+       svalue \"INIT_VAL(c)\":\n+       cluster: {bits 16-23: \"INIT_VAL(a)\",  (from before)\n+                 bits 24-31: \"INIT_VAL(c)\";  (updated)\n+                 flags: {}}\n+\n+     arr[i] = d;  (4)\n+       After (4), we lose the concrete bindings and replace them with a\n+       symbolic binding for \"arr[i]\", with svalue \"INIT_VAL(d)\".  We also\n+       mark the cluster as having been \"symbolically touched\": future\n+       attempts to query the values of subregions other than \"arr[i]\",\n+       such as \"arr[3]\" are \"UNKNOWN\", since we don't know if the write\n+       to arr[i] affected them.\n+       cluster: {symbolic_key(arr[i]): \"INIT_VAL(d)\";\n+                 flags: {TOUCHED}}\n+\n+     arr[j] = e;  (5)\n+       After (5), we lose the symbolic binding for \"arr[i]\" since we could\n+       have overwritten it, and add a symbolic binding for \"arr[j]\".\n+       cluster: {symbolic_key(arr[j]): \"INIT_VAL(d)\"; (different symbolic\n+                 flags: {TOUCHED}}                     binding)\n+\n+     arr[3] = f;  (6)\n+       After (6), we lose the symbolic binding for \"arr[j]\" since we could\n+       have overwritten it, and gain a concrete binding for bits 24-31\n+       again, this time with svalue \"INIT_VAL(e)\":\n+       cluster: {bits 24-31: \"INIT_VAL(d)\";\n+                 flags: {TOUCHED}}\n+       The cluster is still flagged as touched, so that we know that\n+       accesses to other elements are \"UNKNOWN\" rather than\n+       \"UNINITIALIZED\".\n+\n+   Handling symbolic regions requires us to handle aliasing.\n+\n+   In the first example above, each of a, b, c and verts are non-symbolic\n+   base regions and so their clusters are \"concrete clusters\", whereas given:\n+       struct coord *p, *q;\n+   then \"*p\" and \"*q\" are symbolic base regions, and thus \"*p\" and \"*q\"\n+   have \"symbolic clusters\".\n+\n+   In the above, \"verts[i].x\" will have a symbolic *binding* within a\n+   concrete cluster for \"verts\", whereas \"*p\" is a symbolic *cluster*.\n+\n+   Writes to concrete clusters can't affect other concrete clusters,\n+   but can affect symbolic clusters; e.g. after:\n+       verts[0].x = 42;\n+   we bind 42 in the cluster for \"verts\", but the clusters for \"b\" and \"c\"\n+   can't be affected.  Any symbolic clusters for *p and for *q can be\n+   affected, *p and *q could alias verts.\n+\n+   Writes to a symbolic cluster can affect other clusters, both\n+   concrete and symbolic; e.g. after:\n+       p->x = 17;\n+   we bind 17 within the cluster for \"*p\".  The concrete clusters for a, b,\n+   c, and verts could be affected, depending on whether *p aliases them.\n+   Similarly, the symbolic cluster to *q could be affected.  */\n+\n+namespace ana {\n+\n+class concrete_binding;\n+\n+/* An enum for discriminating between \"direct\" vs \"default\" levels of\n+   mapping.  */\n+\n+enum binding_kind\n+{\n+  /* Special-case value for hash support.\n+     This is the initial entry, so that hash traits can have\n+     empty_zero_p = true.  */\n+  BK_empty = 0,\n+\n+  /* Special-case value for hash support.  */\n+  BK_deleted,\n+\n+  /* The normal kind of mapping.  */\n+  BK_direct,\n+\n+  /* A lower-priority kind of mapping, for use when inheriting\n+     default values from a parent region.  */\n+  BK_default\n+};\n+\n+extern const char *binding_kind_to_string (enum binding_kind kind);\n+\n+/* Abstract base class for describing ranges of bits within a binding_map\n+   that can have svalues bound to them.  */\n+\n+class binding_key\n+{\n+public:\n+  virtual ~binding_key () {}\n+  virtual bool concrete_p () const = 0;\n+  bool symbolic_p () const { return !concrete_p (); }\n+\n+  static const binding_key *make (store_manager *mgr, const region *r,\n+\t\t\t\t   enum binding_kind kind);\n+\n+  virtual void dump_to_pp (pretty_printer *pp, bool simple) const;\n+  void dump (bool simple) const;\n+\n+  static int cmp_ptrs (const void *, const void *);\n+  static int cmp (const binding_key *, const binding_key *);\n+\n+  virtual const concrete_binding *dyn_cast_concrete_binding () const\n+  { return NULL; }\n+\n+  enum binding_kind get_kind () const { return m_kind; }\n+\n+  void mark_deleted () { m_kind = BK_deleted; }\n+  void mark_empty () { m_kind = BK_empty; }\n+  bool is_deleted () const { return m_kind == BK_deleted; }\n+  bool is_empty () const { return m_kind == BK_empty; }\n+\n+protected:\n+  binding_key (enum binding_kind kind) : m_kind (kind) {}\n+\n+  hashval_t impl_hash () const\n+  {\n+    return m_kind;\n+  }\n+  bool impl_eq (const binding_key &other) const\n+  {\n+    return m_kind == other.m_kind;\n+  }\n+\n+private:\n+  enum binding_kind m_kind;\n+};\n+\n+/* Concrete subclass of binding_key, for describing a concrete range of\n+   bits within the binding_map (e.g. \"bits 8-15\").  */\n+\n+class concrete_binding : public binding_key\n+{\n+public:\n+  /* This class is its own key for the purposes of consolidation.  */\n+  typedef concrete_binding key_t;\n+\n+  concrete_binding (bit_offset_t start_bit_offset, bit_size_t size_in_bits,\n+\t\t    enum binding_kind kind)\n+  : binding_key (kind),\n+    m_start_bit_offset (start_bit_offset),\n+    m_size_in_bits (size_in_bits)\n+  {}\n+  bool concrete_p () const FINAL OVERRIDE { return true; }\n+\n+  hashval_t hash () const\n+  {\n+    inchash::hash hstate;\n+    hstate.add_wide_int (m_start_bit_offset);\n+    hstate.add_wide_int (m_size_in_bits);\n+    return hstate.end () ^ binding_key::impl_hash ();\n+  }\n+  bool operator== (const concrete_binding &other) const\n+  {\n+    if (!binding_key::impl_eq (other))\n+      return false;\n+    return (m_start_bit_offset == other.m_start_bit_offset\n+\t    && m_size_in_bits == other.m_size_in_bits);\n+  }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+\n+  const concrete_binding *dyn_cast_concrete_binding () const FINAL OVERRIDE\n+  { return this; }\n+\n+  bit_offset_t get_start_bit_offset () const { return m_start_bit_offset; }\n+  bit_size_t get_size_in_bits () const { return m_size_in_bits; }\n+  /* Return the next bit offset after the end of this binding.  */\n+  bit_offset_t get_next_bit_offset () const\n+  {\n+    return m_start_bit_offset + m_size_in_bits;\n+  }\n+\n+  bool overlaps_p (const concrete_binding &other) const;\n+\n+private:\n+  bit_offset_t m_start_bit_offset;\n+  bit_size_t m_size_in_bits;\n+};\n+\n+} // namespace ana\n+\n+template <> struct default_hash_traits<ana::concrete_binding>\n+: public member_function_hash_traits<ana::concrete_binding>\n+{\n+  static const bool empty_zero_p = true;\n+};\n+\n+namespace ana {\n+\n+/* Concrete subclass of binding_key, for describing a symbolic set of\n+   bits within the binding_map in terms of a region (e.g. \"arr[i]\").  */\n+\n+class symbolic_binding : public binding_key\n+{\n+public:\n+  /* This class is its own key for the purposes of consolidation.  */\n+  typedef symbolic_binding key_t;\n+\n+  symbolic_binding (const region *region, enum binding_kind kind)\n+  : binding_key (kind),\n+    m_region (region)\n+  {}\n+  bool concrete_p () const FINAL OVERRIDE { return false; }\n+\n+  hashval_t hash () const\n+  {\n+    return (binding_key::impl_hash () ^ (long)m_region);\n+  }\n+  bool operator== (const symbolic_binding &other) const\n+  {\n+    if (!binding_key::impl_eq (other))\n+      return false;\n+    return (m_region == other.m_region);\n+  }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+\n+  const region *get_region () const { return m_region; }\n+\n+private:\n+  const region *m_region;\n+};\n+\n+} // namespace ana\n+\n+template <> struct default_hash_traits<ana::symbolic_binding>\n+: public member_function_hash_traits<ana::symbolic_binding>\n+{\n+  static const bool empty_zero_p = true;\n+};\n+\n+namespace ana {\n+\n+/* A mapping from binding_keys to svalues, for use by binding_cluster\n+   and compound_svalue.  */\n+\n+class binding_map\n+{\n+public:\n+  typedef hash_map <const binding_key *, const svalue *> map_t;\n+  typedef map_t::iterator iterator_t;\n+\n+  binding_map () : m_map () {}\n+  binding_map (const binding_map &other);\n+  binding_map& operator=(const binding_map &other);\n+\n+  bool operator== (const binding_map &other) const;\n+  bool operator!= (const binding_map &other) const\n+  {\n+    return !(*this == other);\n+  }\n+\n+  hashval_t hash () const;\n+\n+  const svalue *get (const binding_key *key) const\n+  {\n+    const svalue **slot = const_cast<map_t &> (m_map).get (key);\n+    if (slot)\n+      return *slot;\n+    else\n+      return NULL;\n+  }\n+  bool put (const binding_key *k, const svalue *v)\n+  {\n+    gcc_assert (v);\n+    return m_map.put (k, v);\n+  }\n+\n+  void remove (const binding_key *k) { m_map.remove (k); }\n+  void empty () { m_map.empty (); }\n+\n+  iterator_t begin () const { return m_map.begin (); }\n+  iterator_t end () const { return m_map.end (); }\n+  size_t elements () const { return m_map.elements (); }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple, bool multiline) const;\n+  void dump (bool simple) const;\n+\n+private:\n+  map_t m_map;\n+};\n+\n+/* Concept: BindingVisitor, for use by binding_cluster::for_each_binding\n+   and store::for_each_binding.\n+\n+   Should implement:\n+     void on_binding (const binding_key *key, const svalue *&sval);\n+*/\n+\n+/* All of the bindings within a store for regions that share the same\n+   base region.  */\n+\n+class binding_cluster\n+{\n+public:\n+  friend class store;\n+\n+  typedef hash_map <const binding_key *, const svalue *> map_t;\n+  typedef map_t::iterator iterator_t;\n+\n+  binding_cluster (const region *base_region)\n+  : m_base_region (base_region), m_map (),\n+    m_escaped (false), m_touched (false) {}\n+  binding_cluster (const binding_cluster &other);\n+  binding_cluster& operator=(const binding_cluster &other);\n+\n+  bool operator== (const binding_cluster &other) const;\n+  bool operator!= (const binding_cluster &other) const\n+  {\n+    return !(*this == other);\n+  }\n+\n+  hashval_t hash () const;\n+\n+  bool symbolic_p () const;\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple, bool multiline) const;\n+  void dump (bool simple) const;\n+\n+  void bind (store_manager *mgr, const region *, const svalue *,\n+\t     binding_kind kind);\n+\n+  void clobber_region (store_manager *mgr, const region *reg);\n+  void purge_region (store_manager *mgr, const region *reg);\n+  void zero_fill_region (store_manager *mgr, const region *reg);\n+  void mark_region_as_unknown (store_manager *mgr, const region *reg);\n+\n+  const svalue *get_binding (store_manager *mgr, const region *reg,\n+\t\t\t      binding_kind kind) const;\n+  const svalue *get_binding_recursive (store_manager *mgr,\n+\t\t\t\t\tconst region *reg,\n+\t\t\t\t\tenum binding_kind kind) const;\n+  const svalue *get_any_binding (store_manager *mgr,\n+\t\t\t\t  const region *reg) const;\n+  const svalue *maybe_get_compound_binding (store_manager *mgr,\n+\t\t\t\t\t     const region *reg) const;\n+\n+  void remove_overlapping_bindings (store_manager *mgr, const region *reg);\n+\n+  template <typename T>\n+  void for_each_value (void (*cb) (const svalue *sval, T user_data),\n+\t\t       T user_data)\n+  {\n+    for (map_t::iterator iter = m_map.begin (); iter != m_map.end (); ++iter)\n+      cb ((*iter).second, user_data);\n+  }\n+\n+  static bool can_merge_p (const binding_cluster *cluster_a,\n+\t\t\t   const binding_cluster *cluster_b,\n+\t\t\t   binding_cluster *out_cluster,\n+\t\t\t   store_manager *mgr,\n+\t\t\t   model_merger *merger);\n+  void make_unknown_relative_to (const binding_cluster *other_cluster,\n+\t\t\t\t store_manager *mgr);\n+\n+  void mark_as_escaped ();\n+  void on_unknown_fncall (const gcall *call, store_manager *mgr);\n+\n+  bool escaped_p () const { return m_escaped; }\n+  bool touched_p () const { return m_touched; }\n+\n+  bool redundant_p () const;\n+  bool empty_p () const { return m_map.elements () == 0; }\n+\n+  void get_representative_path_vars (const region_model *model,\n+\t\t\t\t     svalue_set *visited,\n+\t\t\t\t     const region *base_reg,\n+\t\t\t\t     const svalue *sval,\n+\t\t\t\t     auto_vec<path_var> *out_pvs) const;\n+\n+  const svalue *maybe_get_simple_value (store_manager *mgr) const;\n+\n+  template <typename BindingVisitor>\n+  void for_each_binding (BindingVisitor &v)\n+  {\n+    for (map_t::iterator iter = m_map.begin (); iter != m_map.end (); ++iter)\n+      {\n+\tconst binding_key *key = (*iter).first;\n+\tconst svalue *&sval = (*iter).second;\n+\tv.on_binding (key, sval);\n+      }\n+  }\n+\n+  iterator_t begin () const { return m_map.begin (); }\n+  iterator_t end () const { return m_map.end (); }\n+\n+private:\n+  const svalue *get_any_value (const binding_key *key) const;\n+  void get_overlapping_bindings (store_manager *mgr, const region *reg,\n+\t\t\t\t auto_vec<const binding_key *> *out);\n+  void bind_compound_sval (store_manager *mgr,\n+\t\t\t   const region *reg,\n+\t\t\t   const compound_svalue *compound_sval);\n+  void bind_key (const binding_key *key, const svalue *sval);\n+\n+  const region *m_base_region;\n+\n+  binding_map m_map;\n+\n+  /* Has a pointer to this cluster \"escaped\" into a part of the program\n+     we don't know about (via a call to a function with an unknown body,\n+     or by being passed in as a pointer param of a \"top-level\" function call).\n+     Such regions could be overwritten when other such functions are called,\n+     even if the region is no longer reachable by pointers that we are\n+     tracking. */\n+  bool m_escaped;\n+\n+  /* Has this cluster been written to via a symbolic binding?\n+     If so, then we don't know anything about unbound subregions,\n+     so we can't use initial_svalue, treat them as uninitialized, or\n+     inherit values from a parent region.  */\n+  bool m_touched;\n+};\n+\n+/* The mapping from regions to svalues.\n+   This is actually expressed by subdividing into clusters, to better\n+   handle aliasing.  */\n+\n+class store\n+{\n+public:\n+  typedef hash_map <const region *, binding_cluster *> cluster_map_t;\n+\n+  store ();\n+  store (const store &other);\n+  ~store ();\n+\n+  store &operator= (const store &other);\n+\n+  bool operator== (const store &other) const;\n+  bool operator!= (const store &other) const\n+  {\n+    return !(*this == other);\n+  }\n+\n+  hashval_t hash () const;\n+\n+  void dump_to_pp (pretty_printer *pp, bool summarize, bool multiline,\n+\t\t   store_manager *mgr) const;\n+  void dump (bool simple) const;\n+  void summarize_to_pp (pretty_printer *pp, bool simple) const;\n+\n+  const svalue *get_direct_binding (store_manager *mgr, const region *reg);\n+  const svalue *get_default_binding (store_manager *mgr, const region *reg);\n+  const svalue *get_any_binding (store_manager *mgr, const region *reg) const;\n+\n+  bool called_unknown_fn_p () const { return m_called_unknown_fn; }\n+\n+  void set_value (store_manager *mgr, const region *lhs_reg,\n+\t\t  const svalue *rhs_sval, enum binding_kind kind);\n+  void clobber_region (store_manager *mgr, const region *reg);\n+  void purge_region (store_manager *mgr, const region *reg);\n+  void zero_fill_region (store_manager *mgr, const region *reg);\n+  void mark_region_as_unknown (store_manager *mgr, const region *reg);\n+\n+  const binding_cluster *get_cluster (const region *base_reg) const;\n+  binding_cluster *get_cluster (const region *base_reg);\n+  binding_cluster *get_or_create_cluster (const region *base_reg);\n+  void purge_cluster (const region *base_reg);\n+\n+  template <typename T>\n+  void for_each_cluster (void (*cb) (const region *base_reg, T user_data),\n+\t\t\t T user_data) const\n+  {\n+    for (cluster_map_t::iterator iter = m_cluster_map.begin ();\n+\t iter != m_cluster_map.end (); ++iter)\n+      cb ((*iter).first, user_data);\n+  }\n+\n+  static bool can_merge_p (const store *store_a, const store *store_b,\n+\t\t\t   store *out_store, store_manager *mgr,\n+\t\t\t   model_merger *merger);\n+\n+  void mark_as_escaped (const region *base_reg);\n+  void on_unknown_fncall (const gcall *call, store_manager *mgr);\n+  bool escaped_p (const region *reg) const;\n+\n+  void get_representative_path_vars (const region_model *model,\n+\t\t\t\t     svalue_set *visited,\n+\t\t\t\t     const svalue *sval,\n+\t\t\t\t     auto_vec<path_var> *out_pvs) const;\n+\n+  cluster_map_t::iterator begin () const { return m_cluster_map.begin (); }\n+  cluster_map_t::iterator end () const { return m_cluster_map.end (); }\n+\n+  tristate eval_alias (const region *base_reg_a,\n+\t\t       const region *base_reg_b);\n+\n+  template <typename BindingVisitor>\n+  void for_each_binding (BindingVisitor &v)\n+  {\n+    for (cluster_map_t::iterator iter = m_cluster_map.begin ();\n+\t iter != m_cluster_map.end (); ++iter)\n+      (*iter).second->for_each_binding (v);\n+  }\n+\n+  void canonicalize (store_manager *mgr);\n+  void loop_replay_fixup (const store *other_store,\n+\t\t\t  region_model_manager *mgr);\n+\n+private:\n+  void remove_overlapping_bindings (store_manager *mgr, const region *reg);\n+\n+  cluster_map_t m_cluster_map;\n+\n+  /* If this is true, then unknown code has been called, and so\n+     any global variable that isn't currently modelled by the store\n+     has unknown state, rather than being in an \"initial state\".\n+     This is to avoid having to mark (and thus explicitly track)\n+     every global when an unknown function is called; instead, they\n+     can be tracked implicitly.  */\n+  bool m_called_unknown_fn;\n+};\n+\n+/* A class responsible for owning and consolidating binding keys\n+   (both concrete and symbolic).\n+   Key instances are immutable as far as clients are concerned, so they\n+   are provided as \"const\" ptrs.  */\n+\n+class store_manager\n+{\n+public:\n+  store_manager (region_model_manager *mgr) : m_mgr (mgr) {}\n+\n+  /* binding consolidation.  */\n+  const concrete_binding *\n+  get_concrete_binding (bit_offset_t start_bit_offset,\n+\t\t\tbit_offset_t size_in_bits,\n+\t\t\tenum binding_kind kind);\n+  const symbolic_binding *\n+  get_symbolic_binding (const region *region,\n+\t\t\tenum binding_kind kind);\n+\n+  region_model_manager *get_svalue_manager () const\n+  {\n+    return m_mgr;\n+  }\n+\n+  void log_stats (logger *logger, bool show_objs) const;\n+\n+private:\n+  region_model_manager *m_mgr;\n+  consolidation_map<concrete_binding> m_concrete_binding_key_mgr;\n+  consolidation_map<symbolic_binding> m_symbolic_binding_key_mgr;\n+};\n+\n+} // namespace ana\n+\n+#endif /* GCC_ANALYZER_STORE_H */"}, {"sha": "eabb13affcba25db1da11cf6b0f480598f27caba", "filename": "gcc/analyzer/svalue.cc", "status": "added", "additions": 1004, "deletions": 0, "changes": 1004, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fsvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fanalyzer%2Fsvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.cc?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,1004 @@\n+/* Symbolic values.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"diagnostic-core.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"diagnostic-core.h\"\n+#include \"graphviz.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"tree-dfa.h\"\n+#include \"stringpool.h\"\n+#include \"convert.h\"\n+#include \"target.h\"\n+#include \"fold-const.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"tristate.h\"\n+#include \"bitmap.h\"\n+#include \"selftest.h\"\n+#include \"function.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"options.h\"\n+#include \"cgraph.h\"\n+#include \"cfg.h\"\n+#include \"digraph.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/region-model.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* struct complexity.  */\n+\n+/* Get complexity for a new node that references REG\n+   (the complexity of REG, plus one for the new node).  */\n+\n+complexity::complexity (const region *reg)\n+: m_num_nodes (reg->get_complexity ().m_num_nodes + 1),\n+  m_max_depth (reg->get_complexity ().m_max_depth + 1)\n+{\n+}\n+\n+/* Get complexity for a new node that references SVAL.\n+   (the complexity of SVAL, plus one for the new node).  */\n+\n+complexity::complexity (const svalue *sval)\n+: m_num_nodes (sval->get_complexity ().m_num_nodes + 1),\n+  m_max_depth (sval->get_complexity ().m_max_depth + 1)\n+{\n+}\n+\n+/* Get complexity for a new node that references nodes with complexity\n+   C1 and C2.  */\n+\n+complexity\n+complexity::from_pair (const complexity &c1, const complexity &c2)\n+{\n+  return complexity (c1.m_num_nodes + c2.m_num_nodes + 1,\n+\t\t     MAX (c1.m_max_depth, c2.m_max_depth) + 1);\n+}\n+\n+/* class svalue and its various subclasses.  */\n+\n+/* class svalue.  */\n+\n+/* Dump a representation of this svalue to stderr.  */\n+\n+DEBUG_FUNCTION void\n+svalue::dump (bool simple) const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = stderr;\n+  dump_to_pp (&pp, simple);\n+  pp_newline (&pp);\n+  pp_flush (&pp);\n+}\n+\n+/* Generate a textual representation of this svalue for debugging purposes.  */\n+\n+label_text\n+svalue::get_desc (bool simple) const\n+{\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  dump_to_pp (&pp, simple);\n+  return label_text::take (xstrdup (pp_formatted_text (&pp)));\n+}\n+\n+/* If this svalue is a constant_svalue, return the underlying tree constant.\n+   Otherwise return NULL_TREE.  */\n+\n+tree\n+svalue::maybe_get_constant () const\n+{\n+  if (const constant_svalue *cst_sval = dyn_cast_constant_svalue ())\n+    return cst_sval->get_constant ();\n+  else\n+    return NULL_TREE;\n+}\n+\n+/* If this svalue is a cast (i.e a unaryop NOP_EXPR), return the underlying\n+   svalue.\n+   Otherwise return NULL.  */\n+\n+const svalue *\n+svalue::maybe_undo_cast () const\n+{\n+  if (const unaryop_svalue *unaryop_sval = dyn_cast_unaryop_svalue ())\n+    if (unaryop_sval->get_op () == NOP_EXPR)\n+      return unaryop_sval->get_arg ();\n+  return NULL;\n+}\n+\n+/* If this svalue is an unmergeable decorator around another svalue, return\n+   the underlying svalue.\n+   Otherwise return this svalue.  */\n+\n+const svalue *\n+svalue::unwrap_any_unmergeable () const\n+{\n+  if (const unmergeable_svalue *unmergeable = dyn_cast_unmergeable_svalue ())\n+    return unmergeable->get_arg ();\n+  return this;\n+}\n+\n+/* Attempt to merge THIS with OTHER, returning the merged svalue.\n+   Return NULL if not mergeable.  */\n+\n+const svalue *\n+svalue::can_merge_p (const svalue *other,\n+\t\t     region_model_manager *mgr,\n+\t\t     model_merger *merger) const\n+{\n+  if (!(get_type () && other->get_type ()))\n+    return NULL;\n+\n+  if (!types_compatible_p (get_type (), other->get_type ()))\n+    return NULL;\n+\n+  /* Reject attempts to merge unmergeable svalues.  */\n+  if ((get_kind () == SK_UNMERGEABLE)\n+      || (other->get_kind () == SK_UNMERGEABLE))\n+    return NULL;\n+\n+  /* Reject attempts to merge NULL pointers with not-NULL-pointers.  */\n+  if (POINTER_TYPE_P (get_type ()))\n+    {\n+      bool null0 = false;\n+      bool null1 = false;\n+      if (tree cst0 = maybe_get_constant ())\n+\tif (zerop (cst0))\n+\t  null0 = true;\n+      if (tree cst1 = other->maybe_get_constant ())\n+\tif (zerop (cst1))\n+\t  null1 = true;\n+      if (null0 != null1)\n+\treturn NULL;\n+    }\n+\n+  /* Widening.  */\n+  /* Merge: (new_cst, existing_cst) -> widen (existing, new).  */\n+  if (maybe_get_constant () && other->maybe_get_constant ())\n+    {\n+      return mgr->get_or_create_widening_svalue (other->get_type (),\n+\t\t\t\t\t\t merger->m_point,\n+\t\t\t\t\t\t other, this);\n+    }\n+\n+  /* Merge: (Widen(existing_val, V), existing_val) -> Widen (existing_val, V)\n+     and thus get a fixed point.  */\n+  if (const widening_svalue *widen_sval = dyn_cast_widening_svalue ())\n+    {\n+      if (other == widen_sval->get_base_svalue ())\n+\treturn this;\n+      if (other == widen_sval->get_iter_svalue ())\n+\treturn this;\n+    }\n+\n+  if (const binop_svalue *binop_sval = dyn_cast_binop_svalue ())\n+    if (const widening_svalue *widen_arg0\n+\t= binop_sval->get_arg0 ()->dyn_cast_widening_svalue ())\n+      {\n+\tif (other == binop_sval->get_arg1 ())\n+\t  {\n+\t    /* Merger of: (Widen(..., OTHER) BINOP X)\n+\t       and      : OTHER\n+\t       to       : (Widen(..., OTHER) BINOP X)\n+\t       e.g. merge of Widen(0, 1) + 1 with 1 to the Widen(0, 1) + 1.  */\n+\t    return this;\n+\t  }\n+\n+\t/* Merger of : (Widen() BINOP X)\n+\t   and       : Widen()\n+\t   to        : Widen()\n+\t   e.g. merge of Widen(0, 1) + 1 and Widen(0, 1) to Widen(0, 1).\n+\t   However, we want to update constraints for this case, since we're\n+\t   considering another iteration.\n+\t   Presumably we also want to ensure that it converges; we don't want\n+\t   a descending chain of constraints.  */\n+\tif (other == widen_arg0)\n+\t  {\n+\t    return widen_arg0;\n+\t  }\n+      }\n+\n+  return mgr->get_or_create_unknown_svalue (get_type ());\n+}\n+\n+/* Determine if this svalue is either within LIVE_SVALUES, or is implicitly\n+   live with respect to LIVE_SVALUES and MODEL.  */\n+\n+bool\n+svalue::live_p (const svalue_set &live_svalues,\n+\t\tconst region_model *model) const\n+{\n+  /* Determine if SVAL is explicitly live.  */\n+  if (const_cast<svalue_set &> (live_svalues).contains (this))\n+    return true;\n+\n+  /* Otherwise, determine if SVAL is implicitly live due to being made of\n+     other live svalues.  */\n+  return implicitly_live_p (live_svalues, model);\n+}\n+\n+/* Base implementation of svalue::implicitly_live_p.  */\n+\n+bool\n+svalue::implicitly_live_p (const svalue_set &, const region_model *) const\n+{\n+  return false;\n+}\n+\n+/* class region_svalue : public svalue.  */\n+\n+/* Implementation of svalue::dump_to_pp vfunc for region_svalue.  */\n+\n+void\n+region_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    {\n+      pp_string (pp, \"&\");\n+      m_reg->dump_to_pp (pp, simple);\n+    }\n+  else\n+    {\n+      pp_string (pp, \"region_svalue(\");\n+      print_quoted_type (pp, get_type ());\n+      pp_string (pp, \", \");\n+      m_reg->dump_to_pp (pp, simple);\n+      pp_string (pp, \")\");\n+    }\n+}\n+\n+/* Implementation of svalue::accept vfunc for region_svalue.  */\n+\n+void\n+region_svalue::accept (visitor *v) const\n+{\n+  v->visit_region_svalue (this);\n+  m_reg->accept (v);\n+}\n+\n+/* Evaluate the condition LHS OP RHS.\n+   Subroutine of region_model::eval_condition for when we have a pair of\n+   pointers.  */\n+\n+tristate\n+region_svalue::eval_condition (const region_svalue *lhs,\n+\t\t\t       enum tree_code op,\n+\t\t\t       const region_svalue *rhs)\n+{\n+  /* See if they point to the same region.  */\n+  const region *lhs_reg = lhs->get_pointee ();\n+  const region *rhs_reg = rhs->get_pointee ();\n+  bool ptr_equality = lhs_reg == rhs_reg;\n+  switch (op)\n+    {\n+    default:\n+      gcc_unreachable ();\n+\n+    case EQ_EXPR:\n+      if (ptr_equality)\n+\treturn tristate::TS_TRUE;\n+      else\n+\treturn tristate::TS_FALSE;\n+      break;\n+\n+    case NE_EXPR:\n+      if (ptr_equality)\n+\treturn tristate::TS_FALSE;\n+      else\n+\treturn tristate::TS_TRUE;\n+      break;\n+\n+    case GE_EXPR:\n+    case LE_EXPR:\n+      if (ptr_equality)\n+\treturn tristate::TS_TRUE;\n+      break;\n+\n+    case GT_EXPR:\n+    case LT_EXPR:\n+      if (ptr_equality)\n+\treturn tristate::TS_FALSE;\n+      break;\n+    }\n+\n+  return tristate::TS_UNKNOWN;\n+}\n+\n+/* class constant_svalue : public svalue.  */\n+\n+/* Implementation of svalue::dump_to_pp vfunc for constant_svalue.  */\n+\n+void\n+constant_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    {\n+      pp_string (pp, \"(\");\n+      dump_tree (pp, get_type ());\n+      pp_string (pp, \")\");\n+      dump_tree (pp, m_cst_expr);\n+    }\n+  else\n+    {\n+      pp_string (pp, \"constant_svalue(\");\n+      print_quoted_type (pp, get_type ());\n+      pp_string (pp, \", \");\n+      dump_tree (pp, m_cst_expr);\n+      pp_string (pp, \")\");\n+    }\n+}\n+\n+/* Implementation of svalue::accept vfunc for constant_svalue.  */\n+\n+void\n+constant_svalue::accept (visitor *v) const\n+{\n+  v->visit_constant_svalue (this);\n+}\n+\n+/* Implementation of svalue::implicitly_live_p vfunc for constant_svalue.\n+   Constants are implicitly live.  */\n+\n+bool\n+constant_svalue::implicitly_live_p (const svalue_set &,\n+\t\t\t\t    const region_model *) const\n+{\n+  return true;\n+}\n+\n+/* Evaluate the condition LHS OP RHS.\n+   Subroutine of region_model::eval_condition for when we have a pair of\n+   constants.  */\n+\n+tristate\n+constant_svalue::eval_condition (const constant_svalue *lhs,\n+\t\t\t\t  enum tree_code op,\n+\t\t\t\t  const constant_svalue *rhs)\n+{\n+  tree lhs_const = lhs->get_constant ();\n+  tree rhs_const = rhs->get_constant ();\n+\n+  gcc_assert (CONSTANT_CLASS_P (lhs_const));\n+  gcc_assert (CONSTANT_CLASS_P (rhs_const));\n+\n+  /* Check for comparable types.  */\n+  if (types_compatible_p (TREE_TYPE (lhs_const), TREE_TYPE (rhs_const)))\n+    {\n+      tree comparison\n+\t= fold_binary (op, boolean_type_node, lhs_const, rhs_const);\n+      if (comparison == boolean_true_node)\n+\treturn tristate (tristate::TS_TRUE);\n+      if (comparison == boolean_false_node)\n+\treturn tristate (tristate::TS_FALSE);\n+    }\n+  return tristate::TS_UNKNOWN;\n+}\n+\n+/* class unknown_svalue : public svalue.  */\n+\n+/* Implementation of svalue::dump_to_pp vfunc for unknown_svalue.  */\n+\n+void\n+unknown_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    {\n+      pp_string (pp, \"UNKNOWN(\");\n+      if (get_type ())\n+\tdump_tree (pp, get_type ());\n+      pp_character (pp, ')');\n+    }\n+  else\n+    {\n+      pp_string (pp, \"unknown_svalue(\");\n+      if (get_type ())\n+\tdump_tree (pp, get_type ());\n+      pp_character (pp, ')');\n+    }\n+}\n+\n+/* Implementation of svalue::accept vfunc for unknown_svalue.  */\n+\n+void\n+unknown_svalue::accept (visitor *v) const\n+{\n+  v->visit_unknown_svalue (this);\n+}\n+\n+/* Get a string for KIND for use in debug dumps.  */\n+\n+const char *\n+poison_kind_to_str (enum poison_kind kind)\n+{\n+  switch (kind)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case POISON_KIND_FREED:\n+      return \"freed\";\n+    case POISON_KIND_POPPED_STACK:\n+      return \"popped stack\";\n+    }\n+}\n+\n+/* class poisoned_svalue : public svalue.  */\n+\n+/* Implementation of svalue::dump_to_pp vfunc for poisoned_svalue.  */\n+\n+void\n+poisoned_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    pp_printf (pp, \"POISONED(%s)\", poison_kind_to_str (m_kind));\n+  else\n+    pp_printf (pp, \"poisoned_svalue(%s)\", poison_kind_to_str (m_kind));\n+}\n+\n+/* Implementation of svalue::accept vfunc for poisoned_svalue.  */\n+\n+void\n+poisoned_svalue::accept (visitor *v) const\n+{\n+  v->visit_poisoned_svalue (this);\n+}\n+\n+/* class setjmp_svalue's implementation is in engine.cc, so that it can use\n+   the declaration of exploded_node.  */\n+\n+/* class initial_svalue : public svalue.  */\n+\n+/* Implementation of svalue::dump_to_pp vfunc for initial_svalue.  */\n+\n+void\n+initial_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    {\n+      pp_string (pp, \"INIT_VAL(\");\n+      m_reg->dump_to_pp (pp, simple);\n+      pp_string (pp, \")\");\n+    }\n+  else\n+    {\n+      pp_string (pp, \"initial_svalue(\");\n+      print_quoted_type (pp, get_type ());\n+      pp_string (pp, \", \");\n+      m_reg->dump_to_pp (pp, simple);\n+      pp_string (pp, \")\");\n+    }\n+}\n+\n+/* Implementation of svalue::accept vfunc for initial_svalue.  */\n+\n+void\n+initial_svalue::accept (visitor *v) const\n+{\n+  v->visit_initial_svalue (this);\n+  m_reg->accept (v);\n+}\n+\n+/* Implementation of svalue::implicitly_live_p vfunc for initial_svalue.  */\n+\n+bool\n+initial_svalue::implicitly_live_p (const svalue_set &,\n+\t\t\t\t   const region_model *model) const\n+{\n+  /* This svalue may be implicitly live if the region still implicitly\n+     has its initial value and is reachable.  */\n+\n+  /* It must be a region that exists; we don't want to consider\n+     INIT_VAL(R) as still being implicitly reachable if R is in\n+     a popped stack frame.  */\n+  if (model->region_exists_p (m_reg))\n+    {\n+      const svalue *reg_sval = model->get_store_value (m_reg);\n+      if (reg_sval == this)\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* class unaryop_svalue : public svalue.  */\n+\n+/* Implementation of svalue::dump_to_pp vfunc for unaryop_svalue.  */\n+\n+void\n+unaryop_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    {\n+      if (m_op == NOP_EXPR)\n+\t{\n+\t  pp_string (pp, \"CAST(\");\n+\t  dump_tree (pp, get_type ());\n+\t  pp_string (pp, \", \");\n+\t  m_arg->dump_to_pp (pp, simple);\n+\t  pp_character (pp, ')');\n+\t}\n+      else\n+\t{\n+\t  pp_character (pp, '(');\n+\t  pp_string (pp, get_tree_code_name (m_op));\n+\t  //pp_string (pp, op_symbol_code (m_op));\n+\t  m_arg->dump_to_pp (pp, simple);\n+\t  pp_character (pp, ')');\n+\t}\n+    }\n+  else\n+    {\n+      pp_string (pp, \"unaryop_svalue (\");\n+      pp_string (pp, get_tree_code_name (m_op));\n+      pp_string (pp, \", \");\n+      m_arg->dump_to_pp (pp, simple);\n+      pp_character (pp, ')');\n+    }\n+}\n+\n+/* Implementation of svalue::accept vfunc for unaryop_svalue.  */\n+\n+void\n+unaryop_svalue::accept (visitor *v) const\n+{\n+  v->visit_unaryop_svalue (this);\n+  m_arg->accept (v);\n+}\n+\n+/* Implementation of svalue::implicitly_live_p vfunc for unaryop_svalue.  */\n+\n+bool\n+unaryop_svalue::implicitly_live_p (const svalue_set &live_svalues,\n+\t\t\t\t   const region_model *model) const\n+{\n+  return get_arg ()->live_p (live_svalues, model);\n+}\n+\n+/* class binop_svalue : public svalue.  */\n+\n+/* Implementation of svalue::dump_to_pp vfunc for binop_svalue.  */\n+\n+void\n+binop_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    {\n+      pp_character (pp, '(');\n+      m_arg0->dump_to_pp (pp, simple);\n+      pp_string (pp, op_symbol_code (m_op));\n+      m_arg1->dump_to_pp (pp, simple);\n+      pp_character (pp, ')');\n+    }\n+  else\n+    {\n+      pp_string (pp, \"binop_svalue (\");\n+      pp_string (pp, get_tree_code_name (m_op));\n+      pp_string (pp, \", \");\n+      m_arg0->dump_to_pp (pp, simple);\n+      pp_string (pp, \", \");\n+      m_arg1->dump_to_pp (pp, simple);\n+      pp_character (pp, ')');\n+    }\n+}\n+\n+/* Implementation of svalue::accept vfunc for binop_svalue.  */\n+\n+void\n+binop_svalue::accept (visitor *v) const\n+{\n+  v->visit_binop_svalue (this);\n+  m_arg0->accept (v);\n+  m_arg1->accept (v);\n+}\n+\n+/* Implementation of svalue::implicitly_live_p vfunc for binop_svalue.  */\n+\n+bool\n+binop_svalue::implicitly_live_p (const svalue_set &live_svalues,\n+\t\t\t\t const region_model *model) const\n+{\n+  return (get_arg0 ()->live_p (live_svalues, model)\n+\t  && get_arg1 ()->live_p (live_svalues, model));\n+}\n+\n+/* class sub_svalue : public svalue.  */\n+\n+/* sub_svalue'c ctor.  */\n+\n+sub_svalue::sub_svalue (tree type, const svalue *parent_svalue,\n+\t\t\tconst region *subregion)\n+: svalue (complexity::from_pair (parent_svalue->get_complexity (),\n+\t\t\t\t subregion->get_complexity ()),\n+\t  type),\n+  m_parent_svalue (parent_svalue), m_subregion (subregion)\n+{\n+}\n+\n+/* Implementation of svalue::dump_to_pp vfunc for sub_svalue.  */\n+\n+void\n+sub_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    {\n+      pp_string (pp, \"SUB(\");\n+      m_parent_svalue->dump_to_pp (pp, simple);\n+      pp_string (pp, \", \");\n+      m_subregion->dump_to_pp (pp, simple);\n+      pp_character (pp, ')');\n+    }\n+  else\n+    {\n+      pp_string (pp, \"sub_svalue (\");\n+      pp_string (pp, \", \");\n+      m_parent_svalue->dump_to_pp (pp, simple);\n+      pp_string (pp, \", \");\n+      m_subregion->dump_to_pp (pp, simple);\n+      pp_character (pp, ')');\n+    }\n+}\n+\n+/* Implementation of svalue::accept vfunc for sub_svalue.  */\n+\n+void\n+sub_svalue::accept (visitor *v) const\n+{\n+  v->visit_sub_svalue (this);\n+  m_parent_svalue->accept (v);\n+  m_subregion->accept (v);\n+}\n+\n+/* Implementation of svalue::implicitly_live_p vfunc for sub_svalue.  */\n+\n+bool\n+sub_svalue::implicitly_live_p (const svalue_set &live_svalues,\n+\t\t\t       const region_model *model) const\n+{\n+  return get_parent ()->live_p (live_svalues, model);\n+}\n+\n+/* class widening_svalue : public svalue.  */\n+\n+/* Implementation of svalue::dump_to_pp vfunc for widening_svalue.  */\n+\n+void\n+widening_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    {\n+      pp_string (pp, \"WIDENING(\");\n+      pp_character (pp, '{');\n+      m_point.print (pp, format (false));\n+      pp_string (pp, \"}, \");\n+      m_base_sval->dump_to_pp (pp, simple);\n+      pp_string (pp, \", \");\n+      m_iter_sval->dump_to_pp (pp, simple);\n+      pp_character (pp, ')');\n+    }\n+  else\n+    {\n+      pp_string (pp, \"widening_svalue (\");\n+      pp_string (pp, \", \");\n+      pp_character (pp, '{');\n+      m_point.print (pp, format (false));\n+      pp_string (pp, \"}, \");\n+      m_base_sval->dump_to_pp (pp, simple);\n+      pp_string (pp, \", \");\n+      m_iter_sval->dump_to_pp (pp, simple);\n+      pp_character (pp, ')');\n+    }\n+}\n+\n+/* Implementation of svalue::accept vfunc for widening_svalue.  */\n+\n+void\n+widening_svalue::accept (visitor *v) const\n+{\n+  v->visit_widening_svalue (this);\n+  m_base_sval->accept (v);\n+  m_iter_sval->accept (v);\n+}\n+\n+/* Attempt to determine in which direction this value is changing\n+   w.r.t. the initial value.  */\n+\n+enum widening_svalue::direction_t\n+widening_svalue::get_direction () const\n+{\n+  tree base_cst = m_base_sval->maybe_get_constant ();\n+  if (base_cst == NULL_TREE)\n+    return DIR_UNKNOWN;\n+  tree iter_cst = m_iter_sval->maybe_get_constant ();\n+  if (iter_cst == NULL_TREE)\n+    return DIR_UNKNOWN;\n+\n+  tree iter_gt_base = fold_binary (GT_EXPR, boolean_type_node,\n+\t\t\t\t   iter_cst, base_cst);\n+  if (iter_gt_base == boolean_true_node)\n+    return DIR_ASCENDING;\n+\n+  tree iter_lt_base = fold_binary (LT_EXPR, boolean_type_node,\n+\t\t\t\t   iter_cst, base_cst);\n+  if (iter_lt_base == boolean_true_node)\n+    return DIR_DESCENDING;\n+\n+  return DIR_UNKNOWN;\n+}\n+\n+/* Compare this value against constant RHS_CST.  */\n+\n+tristate\n+widening_svalue::eval_condition_without_cm (enum tree_code op,\n+\t\t\t\t\t    tree rhs_cst) const\n+{\n+  tree base_cst = m_base_sval->maybe_get_constant ();\n+  if (base_cst == NULL_TREE)\n+    return tristate::TS_UNKNOWN;\n+  tree iter_cst = m_iter_sval->maybe_get_constant ();\n+  if (iter_cst == NULL_TREE)\n+    return tristate::TS_UNKNOWN;\n+\n+  switch (get_direction ())\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case DIR_ASCENDING:\n+      /* LHS is in [base_cst, +ve infinity), assuming no overflow.  */\n+      switch (op)\n+\t{\n+\tcase LE_EXPR:\n+\tcase LT_EXPR:\n+\t  {\n+\t    /* [BASE, +INF) OP RHS:\n+\t       This is either true or false at +ve ininity,\n+\t       It can be true for points X where X OP RHS, so we have either\n+\t       \"false\", or \"unknown\".  */\n+\t    tree base_op_rhs = fold_binary (op, boolean_type_node,\n+\t\t\t\t\t    base_cst, rhs_cst);\n+\t    if (base_op_rhs == boolean_true_node)\n+\t      return tristate::TS_UNKNOWN;\n+\t    else\n+\t      return tristate::TS_FALSE;\n+\t  }\n+\n+\tcase GE_EXPR:\n+\tcase GT_EXPR:\n+\t  {\n+\t    /* [BASE, +INF) OP RHS:\n+\t       This is true at +ve infinity.  It will be true everywhere\n+\t       in the range if BASE >= RHS.  */\n+\t    tree base_op_rhs = fold_binary (op, boolean_type_node,\n+\t\t\t\t\t    base_cst, rhs_cst);\n+\t    if (base_op_rhs == boolean_true_node)\n+\t      return tristate::TS_TRUE;\n+\t    else\n+\t      return tristate::TS_UNKNOWN;\n+\t  }\n+\n+\tcase EQ_EXPR:\n+\t  {\n+\t    /* [BASE, +INF) == RHS:\n+\t       Could this be true at any point in the range?  If so we\n+\t       have \"unknown\", otherwise we have \"false\".  */\n+\t    tree base_le_rhs = fold_binary (LE_EXPR, boolean_type_node,\n+\t\t\t\t\t    base_cst, rhs_cst);\n+\t    if (base_le_rhs == boolean_true_node)\n+\t      return tristate::TS_UNKNOWN;\n+\t    else\n+\t      return tristate::TS_FALSE;\n+\t  }\n+\n+\tcase NE_EXPR:\n+\t  {\n+\t    /* [BASE, +INF) != RHS:\n+\t       Could we have equality at any point in the range?  If so we\n+\t       have \"unknown\", otherwise we have \"true\".  */\n+\t    tree base_le_rhs = fold_binary (LE_EXPR, boolean_type_node,\n+\t\t\t\t\t    base_cst, rhs_cst);\n+\t    if (base_le_rhs == boolean_true_node)\n+\t      return tristate::TS_UNKNOWN;\n+\t    else\n+\t      return tristate::TS_TRUE;\n+\t  }\n+\n+\tdefault:\n+\t  return tristate::TS_UNKNOWN;\n+\t}\n+\n+    case DIR_DESCENDING:\n+      /* LHS is in (-ve infinity, base_cst], assuming no overflow.  */\n+      return tristate::TS_UNKNOWN;\n+\n+    case DIR_UNKNOWN:\n+      return tristate::TS_UNKNOWN;\n+    }\n+}\n+\n+/* class placeholder_svalue : public svalue.  */\n+\n+/* Implementation of svalue::dump_to_pp vfunc for placeholder_svalue.  */\n+\n+void\n+placeholder_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    pp_printf (pp, \"PLACEHOLDER(%qs)\", m_name);\n+  else\n+    pp_printf (pp, \"placeholder_svalue (%qs)\", m_name);\n+}\n+\n+/* Implementation of svalue::accept vfunc for placeholder_svalue.  */\n+\n+void\n+placeholder_svalue::accept (visitor *v) const\n+{\n+  v->visit_placeholder_svalue (this);\n+}\n+\n+/* class unmergeable_svalue : public svalue.  */\n+\n+/* Implementation of svalue::dump_to_pp vfunc for unmergeable_svalue.  */\n+\n+void\n+unmergeable_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    {\n+      pp_string (pp, \"UNMERGEABLE(\");\n+      m_arg->dump_to_pp (pp, simple);\n+      pp_character (pp, ')');\n+    }\n+  else\n+    {\n+      pp_string (pp, \"unmergeable_svalue (\");\n+      m_arg->dump_to_pp (pp, simple);\n+      pp_character (pp, ')');\n+    }\n+}\n+\n+/* Implementation of svalue::accept vfunc for unmergeable_svalue.  */\n+\n+void\n+unmergeable_svalue::accept (visitor *v) const\n+{\n+  v->visit_unmergeable_svalue (this);\n+  m_arg->accept (v);\n+}\n+\n+/* Implementation of svalue::implicitly_live_p vfunc for unmergeable_svalue.  */\n+\n+bool\n+unmergeable_svalue::implicitly_live_p (const svalue_set &live_svalues,\n+\t\t\t\t       const region_model *model) const\n+{\n+  return get_arg ()->live_p (live_svalues, model);\n+}\n+\n+/* class compound_svalue : public svalue.  */\n+\n+/* Implementation of svalue::dump_to_pp vfunc for compound_svalue.  */\n+\n+void\n+compound_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    {\n+      pp_string (pp, \"COMPOUND(\");\n+      m_map.dump_to_pp (pp, simple, false);\n+      pp_character (pp, ')');\n+    }\n+  else\n+    {\n+      pp_string (pp, \"compound_svalue (\");\n+      pp_string (pp, \", \");\n+      pp_character (pp, '{');\n+      m_map.dump_to_pp (pp, simple, false);\n+      pp_string (pp, \"}, \");\n+      pp_character (pp, ')');\n+    }\n+}\n+\n+/* Implementation of svalue::accept vfunc for compound_svalue.  */\n+\n+void\n+compound_svalue::accept (visitor *v) const\n+{\n+  v->visit_compound_svalue (this);\n+  for (binding_map::iterator_t iter = m_map.begin ();\n+       iter != m_map.end (); ++iter)\n+    {\n+      //(*iter).first.accept (v);\n+      (*iter).second->accept (v);\n+    }\n+}\n+\n+/* Calculate what the complexity of a compound_svalue instance for MAP\n+   will be, based on the svalues bound within MAP.  */\n+\n+complexity\n+compound_svalue::calc_complexity (const binding_map &map)\n+{\n+  unsigned num_child_nodes = 0;\n+  unsigned max_child_depth = 0;\n+  for (binding_map::iterator_t iter = map.begin ();\n+       iter != map.end (); ++iter)\n+    {\n+      const complexity &sval_c = (*iter).second->get_complexity ();\n+      num_child_nodes += sval_c.m_num_nodes;\n+      max_child_depth = MAX (max_child_depth, sval_c.m_max_depth);\n+    }\n+  return complexity (num_child_nodes + 1, max_child_depth + 1);\n+}\n+\n+/* class conjured_svalue : public svalue.  */\n+\n+/* Implementation of svalue::dump_to_pp vfunc for conjured_svalue.  */\n+\n+void\n+conjured_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    {\n+      pp_string (pp, \"CONJURED(\");\n+      pp_gimple_stmt_1 (pp, m_stmt, 0, (dump_flags_t)0);\n+      pp_string (pp, \", \");\n+      m_id_reg->dump_to_pp (pp, simple);\n+      pp_character (pp, ')');\n+    }\n+  else\n+    {\n+      pp_string (pp, \"conjured_svalue (\");\n+      pp_string (pp, \", \");\n+      pp_gimple_stmt_1 (pp, m_stmt, 0, (dump_flags_t)0);\n+      pp_string (pp, \", \");\n+      m_id_reg->dump_to_pp (pp, simple);\n+      pp_character (pp, ')');\n+    }\n+}\n+\n+/* Implementation of svalue::accept vfunc for conjured_svalue.  */\n+\n+void\n+conjured_svalue::accept (visitor *v) const\n+{\n+  v->visit_conjured_svalue (this);\n+  m_id_reg->accept (v);\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "b5d6d0f393e549cda0a31f15d37910586b7508ec", "filename": "gcc/doc/analyzer.texi", "status": "modified", "additions": 35, "deletions": 75, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fdoc%2Fanalyzer.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Fdoc%2Fanalyzer.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fanalyzer.texi?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -245,51 +245,34 @@ This is an implementation of the region-based ternary model described in\n (Zhongxing Xu, Ted Kremenek, and Jian Zhang).\n \n A @code{region_model} encapsulates a representation of the state of\n-memory, with a tree of @code{region} instances, along with their associated\n-values.  The representation is graph-like because values can be pointers\n-to regions.  It also stores a constraint_manager, capturing relationships\n-between the values.\n+memory, with a @code{store} recording a binding between @code{region}\n+instances, to @code{svalue} instances.  The bindings are organized into\n+clusters, where regions accessible via well-defined pointer arithmetic\n+are in the same cluster.  The representation is graph-like because values\n+can be pointers to regions.  It also stores a constraint_manager,\n+capturing relationships between the values.\n \n Because each node in the @code{exploded_graph} has a @code{region_model},\n and each of the latter is graph-like, the @code{exploded_graph} is in some\n ways a graph of graphs.\n \n-Here's an example of printing a @code{region_model}, showing the ASCII-art\n-used to visualize the region hierarchy (colorized when printing to stderr):\n+Here's an example of printing a @code{program_state}, showing the\n+@code{region_model} within it, along with state for the @code{malloc}\n+state machine.\n \n @smallexample\n (gdb) call debug (*this)\n-r0: @{kind: 'root', parent: null, sval: null@}\n-|-stack: r1: @{kind: 'stack', parent: r0, sval: sv1@}\n-|  |: sval: sv1: @{poisoned: uninit@}\n-|  |-frame for 'test': r2: @{kind: 'frame', parent: r1, sval: null, map: @{'ptr_3': r3@}, function: 'test', depth: 0@}\n-|  |  `-'ptr_3': r3: @{kind: 'map', parent: r2, sval: sv3, type: 'void *', map: @{@}@}\n-|  |    |: sval: sv3: @{type: 'void *', unknown@}\n-|  |    |: type: 'void *'\n-|  `-frame for 'calls_malloc': r4: @{kind: 'frame', parent: r1, sval: null, map: @{'result_3': r7, '_4': r8, '<anonymous>': r5@}, function: 'calls_malloc', depth: 1@}\n-|    |-'<anonymous>': r5: @{kind: 'map', parent: r4, sval: sv4, type: 'void *', map: @{@}@}\n-|    |  |: sval: sv4: @{type: 'void *', &r6@}\n-|    |  |: type: 'void *'\n-|    |-'result_3': r7: @{kind: 'map', parent: r4, sval: sv4, type: 'void *', map: @{@}@}\n-|    |  |: sval: sv4: @{type: 'void *', &r6@}\n-|    |  |: type: 'void *'\n-|    `-'_4': r8: @{kind: 'map', parent: r4, sval: sv4, type: 'void *', map: @{@}@}\n-|      |: sval: sv4: @{type: 'void *', &r6@}\n-|      |: type: 'void *'\n-`-heap: r9: @{kind: 'heap', parent: r0, sval: sv2@}\n-  |: sval: sv2: @{poisoned: uninit@}\n-  `-r6: @{kind: 'symbolic', parent: r9, sval: null, map: @{@}@}\n-svalues:\n-  sv0: @{type: 'size_t', '1024'@}\n-  sv1: @{poisoned: uninit@}\n-  sv2: @{poisoned: uninit@}\n-  sv3: @{type: 'void *', unknown@}\n-  sv4: @{type: 'void *', &r6@}\n-constraint manager:\n+rmodel:\n+stack depth: 1\n+  frame (index 0): frame: \u2018test\u2019@@1\n+clusters within frame: \u2018test\u2019@@1\n+  cluster for: ptr_3: &HEAP_ALLOCATED_REGION(12)\n+m_called_unknown_fn: FALSE\n+constraint_manager:\n   equiv classes:\n-    ec0: @{sv0 == '1024'@}\n-    ec1: @{sv4@}\n   constraints:\n+malloc:\n+  0x2e89590: &HEAP_ALLOCATED_REGION(12): unchecked ('ptr_3')\n @end smallexample\n \n This is the state at the point of returning from @code{calls_malloc} back\n@@ -310,13 +293,12 @@ void test (void)\n @}\n @end smallexample\n \n-The ``root'' region (``r0'') has a ``stack'' child (``r1''), with two\n-children: a frame for @code{test} (``r2''), and a frame for\n-@code{calls_malloc} (``r4'').  These frame regions have child regions for\n-storing their local variables.  For example, the return region\n-and that of various other regions within the ``calls_malloc'' frame all have\n-value ``sv4'', a pointer to a heap-allocated region ``r6''.  Within the parent\n-frame, @code{ptr_3} has value ``sv3'', an unknown @code{void *}.\n+Within the store, there is the cluster for @code{ptr_3} within the frame\n+for @code{test}, where the whole cluster is bound to a pointer value,\n+pointing at @code{HEAP_ALLOCATED_REGION(12)}.  Additionally, this pointer\n+has the @code{unchecked} state for the @code{malloc} state machine\n+indicating it hasn't yet been checked against NULL since the allocation\n+call.\n \n @subsection Analyzer Paths\n \n@@ -393,21 +375,6 @@ The constraint-handling code assumes reflexivity in some places\n As a simple workaround, constraints on floating-point values are\n currently ignored.\n @item\n-The region model code creates lots of little mutable objects at each\n-@code{region_model} (and thus per @code{exploded_node}) rather than\n-sharing immutable objects and having the mutable state in the\n-@code{program_state} or @code{region_model}.  The latter approach might be\n-more efficient, and might avoid dealing with IDs rather than pointers\n-(which requires us to impose an ordering to get meaningful equality).\n-@item\n-The region model code doesn't yet support @code{memcpy}.  At the\n-gimple-ssa level these have been optimized to statements like this:\n-@smallexample\n-_10 = MEM <long unsigned int> [(char * @{ref-all@})&c]\n-MEM <long unsigned int> [(char * @{ref-all@})&d] = _10;\n-@end smallexample\n-Perhaps they could be supported via a new @code{compound_svalue} type.\n-@item\n There are various other limitations in the region model (grep for TODO/xfail\n in the testsuite).\n @item\n@@ -455,6 +422,16 @@ to the source being analyzed to trigger a breakpoint in the analyzer when\n that source is reached.  By putting a series of these in the source, it's\n much easier to effectively step through the program state as it's analyzed.\n \n+The analyzer handles:\n+\n+@smallexample\n+__analyzer_describe (0, expr);\n+@end smallexample\n+\n+by emitting a warning describing the 2nd argument (which can be of any\n+type), at a verbosity level given by the 1st argument.  This is for use when\n+debugging, and may be of use in DejaGnu tests.\n+\n @smallexample\n __analyzer_dump ();\n @end smallexample\n@@ -508,21 +485,4 @@ truthfulness of the argument.  This is useful for writing DejaGnu tests.\n \n One approach when tracking down where a particular bogus state is\n introduced into the @code{exploded_graph} is to add custom code to\n-@code{region_model::validate}.\n-\n-For example, this custom code (added to @code{region_model::validate})\n-breaks with an assertion failure when a variable called @code{ptr}\n-acquires a value that's unknown, using\n-@code{region_model::get_value_by_name} to locate the variable\n-\n-@smallexample\n-    /* Find a variable matching \"ptr\".  */\n-    svalue_id sid = get_value_by_name (\"ptr\");\n-    if (!sid.null_p ())\n-      @{\n-\tsvalue *sval = get_svalue (sid);\n-\tgcc_assert (sval->get_kind () != SK_UNKNOWN);\n-      @}\n-@end smallexample\n-\n-making it easier to investigate further in a debugger when this occurs.\n+@code{program_state::validate}."}, {"sha": "1029e8d547ba8354373eb84fc695504c9007ed61", "filename": "gcc/testsuite/g++.dg/analyzer/pr93212.C", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr93212.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr93212.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr93212.C?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -5,8 +5,11 @@ auto lol()\n {\n     int aha = 3;\n     return [&aha] {\n-        return aha;\n+        return aha; // { dg-warning \"dereferencing pointer '.*' to within stale stack frame\" }\n     };\n+    /* TODO: may be worth special-casing the reporting of dangling\n+       references from lambdas, to highlight the declaration, and maybe fix\n+       the wording (it's a reference, not a pointer, for one thing).  */\n }\n \n int main()"}, {"sha": "129690c82be4ccab012030c8e506520a519f6e1b", "filename": "gcc/testsuite/g++.dg/analyzer/pr93950.C", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr93950.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr93950.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr93950.C?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -9,9 +9,7 @@ struct d\n   };\n   void h (e * i)\n   {\n-    void *j = nullptr; // { dg-bogus \"NULL\" \"\" { xfail *-*-* } }\n-    // TODO(xfail): we report \"'i' is NULL\" above, which is the wrong location\n-    \n+    void *j = nullptr; // { dg-bogus \"NULL\" }\n     i->f = *i->g; // { dg-warning \"dereference of NULL 'i'\" }\n   }\n   virtual void c (int, int)"}, {"sha": "2642aa40c1ba6eef0314f96b433aa2d561313ecb", "filename": "gcc/testsuite/g++.dg/analyzer/pr94011.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr94011.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr94011.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr94011.C?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-additional-options \"-O1\" }\n+\n+template <typename DV> DV\n+vu (DV j4)\n+{\n+  return [j4] () { return j4 () ? j4 : throw j4 (); } ();\n+}\n+\n+void\n+foo ()\n+{\n+  auto n1 = [] { return nullptr; };\n+\n+  vu (n1);\n+}"}, {"sha": "0573d309ba25e95d8dbf3156694014ca9c35f42f", "filename": "gcc/testsuite/g++.dg/analyzer/pr94028.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr94028.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr94028.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr94028.C?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -19,11 +19,11 @@ struct j\n     throw()\n #endif\n   {\n-    return calloc (b, sizeof (int)); // { dg-warning \"leak\" }\n+    return calloc (b, sizeof (int)); // { dg-bogus \"leak\" \"\" { xfail c++98_only } }\n   }\n   j (B *, int)\n   {\n-  } // { dg-warning \"leak\" }\n+  }\n };\n \n j *"}, {"sha": "9432ac407640fd8b0f66fdb4b41cc1bea25fd9b7", "filename": "gcc/testsuite/g++.dg/analyzer/pr94503.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr94503.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr94503.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr94503.C?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,25 @@\n+template <typename> class allocator {\n+public:\n+  allocator(const allocator &);\n+  allocator();\n+};\n+\n+template <typename> struct allocator_traits;\n+template <typename _Tp> struct allocator_traits<allocator<_Tp> > {\n+  static allocator<_Tp> select_on_container_copy_construction() {\n+    return allocator<_Tp>();\n+  }\n+  static allocator<_Tp> _S_select_on_copy() {\n+    return select_on_container_copy_construction();\n+  }\n+};\n+\n+class basic_string {\n+  struct _Alloc_hider {\n+    _Alloc_hider(allocator<char>);\n+  } _M_dataplus;\n+\n+public:\n+  basic_string(basic_string &)\n+    : _M_dataplus(allocator_traits<allocator<char> >::_S_select_on_copy()) {}\n+} xxx(xxx);"}, {"sha": "0e745529f45dad1da7eeb6b82f5ebad496fa89ef", "filename": "gcc/testsuite/g++.dg/analyzer/pr95042.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr95042.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr95042.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr95042.C?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,28 @@\n+// { dg-additional-options \"-O1\" }\n+\n+class kz {\n+public:\n+  kz ();\n+\n+private:\n+  int yu;\n+};\n+\n+const kz vl;\n+kz ax;\n+\n+void\n+c1 (bool va, bool ze)\n+{\n+  kz ny, fb = vl;\n+\n+  if (va)\n+    {\n+      if (ze)\n+        ny = vl;\n+\n+      fb = ny;\n+    }\n+\n+  ax = fb;\n+}"}, {"sha": "57fd30add7b04e0f7c99cb552ee9ef4aee48cb28", "filename": "gcc/testsuite/gcc.dg/analyzer/CVE-2005-1689-dedupe-issue-2.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2FCVE-2005-1689-dedupe-issue-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2FCVE-2005-1689-dedupe-issue-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2FCVE-2005-1689-dedupe-issue-2.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-additional-options \"-fanalyzer-show-duplicate-count\" } */\n+\n+#include <stdlib.h>\n+\n+typedef struct _krb5_data {\n+  char *data;\n+} krb5_data;\n+\n+/* Ensure that we de-duplicate the various paths to reach here,\n+   and only emit one diagnostic.  */\n+\n+void\n+recvauth_common(krb5_data common)\n+{\n+  free(common.data);\n+  free(common.data); /* { dg-warning \"double-'free' of 'common.data'\" \"inner warning\" } */\n+  /* { dg-warning \"double-'free' of 'inbuf_a.data' \" \"inbuf_a warning\" { target *-*-* } .-1 } */\n+  /* { dg-warning \"double-'free' of 'inbuf_b.data' \" \"inbuf_b warning\" { target *-*-* } .-2 } */\n+  /* { dg-message \"2 duplicates\" \"duplicates notification\" { xfail *-*-* } .-3 } */\n+}\n+\n+void krb5_recvauth(krb5_data inbuf_a)\n+{\n+  recvauth_common(inbuf_a);\n+}\n+\n+void krb5_recvauth_version(krb5_data inbuf_b)\n+{\n+  recvauth_common(inbuf_b);\n+}"}, {"sha": "0fc865f599bfed82f14eb8d9a93f62252187a66e", "filename": "gcc/testsuite/gcc.dg/analyzer/CVE-2005-1689-dedupe-issue.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2FCVE-2005-1689-dedupe-issue.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2FCVE-2005-1689-dedupe-issue.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2FCVE-2005-1689-dedupe-issue.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -14,7 +14,7 @@ recvauth_common(krb5_data inbuf)\n {\n   free(inbuf.data);\n   free(inbuf.data); /* { dg-warning \"double-'free'\" \"warning\" } */\n-  /* { dg-message \"2 duplicates\" \"duplicates notification\" { target *-*-* } .-1 } */\n+  /* { dg-message \"2 duplicates\" \"duplicates notification\" { xfail *-*-* } .-1 } */\n }\n \n void krb5_recvauth(krb5_data inbuf)"}, {"sha": "5edbdb1cc3e261a8daa30b086073afc0a3c0d9da", "filename": "gcc/testsuite/gcc.dg/analyzer/CVE-2005-1689-minimal.c", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2FCVE-2005-1689-minimal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2FCVE-2005-1689-minimal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2FCVE-2005-1689-minimal.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -1,4 +1,5 @@\n #include <stdlib.h>\n+#include \"analyzer-decls.h\"\n \n typedef struct _krb5_data {\n   char *data;\n@@ -28,3 +29,63 @@ test_3 (krb5_data inbuf, int flag)\n   }\n   free((char *)inbuf.data); /* { dg-warning \"double-'free' of 'inbuf.data'\" } */\n }\n+\n+extern void unknown_fn (void *);\n+\n+void\n+test_4 (krb5_data inbuf)\n+{\n+  unknown_fn (NULL);\n+  free(inbuf.data); /* { dg-message \"first 'free' here\" } */\n+  free(inbuf.data); /* { dg-warning \"double-'free' of 'inbuf.data'\" } */\n+}\n+\n+void\n+test_5 (krb5_data inbuf)\n+{\n+  unknown_fn (&inbuf);\n+  free(inbuf.data); /* { dg-message \"first 'free' here\" } */\n+  free(inbuf.data); /* { dg-warning \"double-'free' of 'inbuf.data'\" \"inbuf.data\" } */\n+  /* { dg-bogus \"double-'free' of 'inbuf'\" \"inbuf\" { target *-*-* } .-1 } */\n+}\n+\n+typedef struct _padded_krb5_data {\n+  int pad;\n+  char *data;\n+} padded_krb5_data;\n+\n+void\n+test_6 (padded_krb5_data inbuf)\n+{\n+  unknown_fn (&inbuf.data);\n+  free((char *)inbuf.data); /* { dg-message \"first 'free' here\" } */\n+  free((char *)inbuf.data); /* { dg-warning \"double-'free' of 'inbuf.data'\" \"inbuf.data\" } */\n+}\n+\n+void\n+test_7 (padded_krb5_data inbuf)\n+{\n+  unknown_fn (&inbuf.data);\n+  free((char *)inbuf.data);\n+\n+  unknown_fn (&inbuf.data);\n+  free((char *)inbuf.data);  \n+}\n+\n+void\n+test_8 (padded_krb5_data inbuf, int flag)\n+{\n+  if (flag)\n+    {\n+      unknown_fn (&inbuf.data);\n+      free((char *)inbuf.data);\n+    }\n+  /* Should have two enodes, one for the explicit \"freed\" state, and one\n+     for the implicit \"start\" state.  */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n+\n+  unknown_fn (&inbuf.data);\n+\n+  /* Should have just one enode, for the implicit \"start\" state.  */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+}"}, {"sha": "d6ce8d6afad9aa9fc3e5d9c552c589fbc1ecf87d", "filename": "gcc/testsuite/gcc.dg/analyzer/abs-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fabs-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fabs-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fabs-1.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,22 @@\n+#include \"analyzer-decls.h\"\n+\n+extern long int labs (long int x)\n+  __attribute__ ((__nothrow__ , __leaf__))\n+  __attribute__ ((__const__));\n+\n+long int test_1 (long int x)\n+{\n+  return labs (x);\n+}\n+\n+static long __attribute__((noinline))\n+hide_long (long x)\n+{\n+  return x;\n+}\n+  \n+long int test_2 (long int x)\n+{\n+  __analyzer_eval (labs (hide_long (42)) == 42); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (labs (hide_long (-17)) == 17); /* { dg-warning \"TRUE\" } */\n+}"}, {"sha": "26050f1eee3101abee8452d9376039904749c509", "filename": "gcc/testsuite/gcc.dg/analyzer/aliasing-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Faliasing-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Faliasing-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Faliasing-1.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,25 @@\n+#include \"analyzer-decls.h\"\n+\n+int a;\n+void test (int *p, int x)\n+{\n+  int y;\n+\n+  a = 17;\n+  x = 42;\n+  y = 13;\n+\n+  __analyzer_eval (a == 17); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (x == 42); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (y == 13); /* { dg-warning \"TRUE\" } */\n+\n+  __analyzer_eval (p == &a); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (p == &x); /* { dg-warning \"FALSE\" } */\n+  __analyzer_eval (p == &y); /* { dg-warning \"FALSE\" } */\n+  \n+  *p = 73;\n+\n+  __analyzer_eval (a == 17); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (x == 42); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (y == 13); /* { dg-warning \"TRUE\" } */\n+}"}, {"sha": "38ceeffbe371fe96caf08559ff25e2ad49dadfee", "filename": "gcc/testsuite/gcc.dg/analyzer/aliasing-2.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Faliasing-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Faliasing-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Faliasing-2.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,32 @@\n+#include \"analyzer-decls.h\"\n+\n+extern void escape (int *p);\n+\n+int a;\n+void test (int *p, int x)\n+{\n+  int y;\n+\n+  a = 17;\n+  x = 42;\n+  y = 13;\n+\n+  __analyzer_eval (a == 17); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (x == 42); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (y == 13); /* { dg-warning \"TRUE\" } */\n+\n+  escape (&x);\n+  __analyzer_eval (a == 17); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (x == 42); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (y == 13); /* { dg-warning \"TRUE\" } */\n+\n+  __analyzer_eval (p == &a); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (p == &x); /* { dg-warning \"FALSE\" } */\n+  __analyzer_eval (p == &y); /* { dg-warning \"FALSE\" } */\n+  \n+  *p = 73;\n+\n+  __analyzer_eval (a == 17); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (x == 42); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (y == 13); /* { dg-warning \"TRUE\" } */\n+}"}, {"sha": "d96b3f2f29a3fae192369f1c6203efdb3c30293f", "filename": "gcc/testsuite/gcc.dg/analyzer/analyzer-decls.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fanalyzer-decls.h?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -7,6 +7,11 @@\n /* Trigger a breakpoint in the analyzer when reached.  */\n extern void __analyzer_break (void);\n \n+/* Emit a warning describing the 2nd argument (which can be of any\n+   type), at the given verbosity level.  This is for use when\n+   debugging, and may be of use in DejaGnu tests.  */\n+extern void __analyzer_describe (int verbosity, ...);\n+\n /* Dump copious information about the analyzer\u2019s state when reached.  */\n extern void __analyzer_dump (void);\n \n@@ -20,8 +25,6 @@ extern void __analyzer_dump (void);\n    will also dump all of the states within those nodes.  */\n extern void __analyzer_dump_exploded_nodes (int);\n \n-extern void __analyzer_dump_num_heap_regions (void);\n-\n /* Emit a placeholder \"note\" diagnostic with a path to this call site,\n    if the analyzer finds a feasible path to it.  */\n extern void __analyzer_dump_path (void);"}, {"sha": "70bb921e7429fd7843d3ee6ce79e174dc9ca689c", "filename": "gcc/testsuite/gcc.dg/analyzer/attribute-nonnull.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattribute-nonnull.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattribute-nonnull.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattribute-nonnull.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -12,9 +12,10 @@ extern void bar(void *ptrA, void *ptrB, void *ptrC) /* { dg-message \"argument 1\n void test_1 (void *p, void *q, void *r)\n {\n   foo(p, q, r);\n-  foo(NULL, q, r);\n+  foo(NULL, q, r); /* { dg-warning \"use of NULL where non-null expected\" \"warning\" } */\n+  /* { dg-message \"argument 1 NULL where non-null expected\" \"note\" { target *-*-* } .-1 } */\n   foo(p, NULL, r);\n-  foo(p, q, NULL);\n+  foo(p, q, NULL); /* { dg-warning \"use of NULL where non-null expected\" } */\n }\n \n void test_1a (void *q, void *r)\n@@ -27,9 +28,10 @@ void test_1a (void *q, void *r)\n void test_2 (void *p, void *q, void *r)\n {\n   bar(p, q, r);\n-  bar(NULL, q, r);\n-  bar(p, NULL, r);\n-  bar(p, q, NULL);\n+  bar(NULL, q, r); /* { dg-warning \"use of NULL where non-null expected\" \"warning\" } */\n+  bar(p, NULL, r); /* { dg-warning \"use of NULL where non-null expected\" \"warning\" } */\n+  /* { dg-message \"argument 2 NULL where non-null expected\" \"note\" { target *-*-* } .-1 } */\n+  bar(p, q, NULL); /* { dg-warning \"use of NULL where non-null expected\" \"warning\" } */\n }\n \n void test_3 (void *q, void *r)"}, {"sha": "894508611fefe43cc4534df897f5f0a12d4304c3", "filename": "gcc/testsuite/gcc.dg/analyzer/bzero-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fbzero-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fbzero-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fbzero-1.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,11 @@\n+#include \"analyzer-decls.h\"\n+\n+extern void bzero(void *s, __SIZE_TYPE__ n);\n+\n+void test_1 (void)\n+{\n+  char tmp[1024];\n+  bzero (tmp, 1024);\n+  __analyzer_eval (tmp[0] == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (tmp[1023] == 0); /* { dg-warning \"TRUE\" } */\n+}"}, {"sha": "15cd85f77cf10d720d17b56c7bc5772513ce8437", "filename": "gcc/testsuite/gcc.dg/analyzer/casts-1.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcasts-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcasts-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcasts-1.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,49 @@\n+#include \"analyzer-decls.h\"\n+\n+struct s1\n+{\n+  char a;\n+  char b;\n+  char c;\n+  char d;\n+};\n+\n+struct s2\n+{\n+  char arr[4];\n+};\n+\n+void test_1 ()\n+{\n+  struct s1 x = {'A', 'B', 'C', 'D'};\n+  __analyzer_eval (x.a == 'A'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (x.b == 'B'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (x.c == 'C'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (x.d == 'D'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (((struct s2 *)&x)->arr[0] == 'A'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (((struct s2 *)&x)->arr[1] == 'B'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (((struct s2 *)&x)->arr[2] == 'C'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (((struct s2 *)&x)->arr[3] == 'D'); /* { dg-warning \"TRUE\" } */\n+\n+  ((struct s2 *)&x)->arr[1] = '#';\n+  __analyzer_eval (((struct s2 *)&x)->arr[1] == '#'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (x.b == '#'); /* { dg-warning \"TRUE\" } */\n+}\n+\n+void test_2 ()\n+{\n+  struct s2 x = {{'A', 'B', 'C', 'D'}};\n+  __analyzer_eval (x.arr[0] == 'A'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (x.arr[1] == 'B'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (x.arr[2] == 'C'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (x.arr[3] == 'D'); /* { dg-warning \"TRUE\" } */\n+  struct s1 *p = (struct s1 *)&x;\n+  __analyzer_eval (p->a == 'A'); /* { dg-warning \"TRUE\" \"true\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+  __analyzer_eval (p->b == 'B'); /* { dg-warning \"TRUE\" \"true\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+  __analyzer_eval (p->c == 'C'); /* { dg-warning \"TRUE\" \"true\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+  __analyzer_eval (p->d == 'D'); /* { dg-warning \"TRUE\" \"true\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+}"}, {"sha": "3eef71726ba397c86eeef714b1ad95810537cf93", "filename": "gcc/testsuite/gcc.dg/analyzer/casts-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcasts-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcasts-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcasts-2.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,15 @@\n+#include \"analyzer-decls.h\"\n+\n+void test_1 (int i)\n+{\n+  char c1 = i;\n+  char c2 = i;\n+  __analyzer_eval (c1 == i); /* { dg-warning \"UNKNOWN\" } */  \n+  __analyzer_eval (c1 == c2); /* { dg-warning \"TRUE\" } */  \n+}\n+\n+void test_2 (char c)\n+{\n+  int i = c;\n+  __analyzer_eval (i == c); /* { dg-warning \"TRUE\" } */  \n+}"}, {"sha": "0f07818dcdd211091398697165496ec71bba38c8", "filename": "gcc/testsuite/gcc.dg/analyzer/compound-assignment-1.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcompound-assignment-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcompound-assignment-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcompound-assignment-1.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -40,29 +40,28 @@ void test_4 (void)\n   struct ptr_wrapper r;\n   r.ptr = malloc (sizeof (int)); /* { dg-message \"allocated here\" } */\n } /* { dg-warning \"leak of 'r.ptr'\" } */\n-/* { dg-bogus \"leak of '<unknown>'\" \"unknown leak\" { xfail *-*-* } .-1 } */\n+/* { dg-bogus \"leak of '<unknown>'\" \"unknown leak\" { target *-*-* } .-1 } */\n \n static struct ptr_wrapper __attribute__((noinline))\n called_by_test_5a (void)\n {\n   struct ptr_wrapper r;\n-  r.ptr = malloc (sizeof (int));\n+  r.ptr = malloc (sizeof (int)); /* { dg-message \"allocated here\" } */\n   return r;\n }\n \n void test_5a (void)\n {\n   struct ptr_wrapper q = called_by_test_5a ();  \n } /* { dg-warning \"leak of 'q.ptr'\" } */\n-/* TODO: show the allocation point.  */\n \n static struct ptr_wrapper __attribute__((noinline))\n called_by_test_5b (void)\n {\n   struct ptr_wrapper r;\n   r.ptr = malloc (sizeof (int));\n-  return r; /* { dg-warning \"leak\" } */\n-  /* TODO: show the allocation point.  */\n+  return r; /* { dg-warning \"leak of '<return-value>.ptr'\" } */\n+  /* TODO: show the allocation point; improve above message.  */\n }\n \n void test_5b (void)"}, {"sha": "49259262c4affc6f313ccf176e0bb9f0e4f92c90", "filename": "gcc/testsuite/gcc.dg/analyzer/compound-assignment-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcompound-assignment-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcompound-assignment-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcompound-assignment-3.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -22,4 +22,4 @@ test_2 (void)\n {\n   struct union_wrapper uw2;\n   uw2.u.ptr = malloc (1024);\n-} /* { dg-warning \"leak of '\\\\(void \\\\*\\\\)uw2.u'\" } */\n+} /* { dg-warning \"leak of 'uw2.u.ptr'\" } */"}, {"sha": "5c0a5f9d47c0bf1b603434746bd63f2577649e07", "filename": "gcc/testsuite/gcc.dg/analyzer/compound-assignment-4.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcompound-assignment-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcompound-assignment-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcompound-assignment-4.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,28 @@\n+#include \"analyzer-decls.h\"\n+\n+struct coord\n+{\n+  int x;\n+  int y;\n+};\n+\n+void test_1 (void)\n+{\n+  struct coord arr[16];\n+\n+  arr[2].y = 4;\n+  arr[3].x = 5;\n+  arr[3].y = 6;\n+  arr[4].x = 7;\n+  arr[6].y = 8;\n+  arr[8].x = 9;\n+\n+  arr[7] = arr[3];\n+\n+  __analyzer_eval (arr[7].x == 5); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (arr[7].y == 6); /* { dg-warning \"TRUE\" } */\n+\n+  /* Make sure we don't touch the neighbors.  */\n+  __analyzer_eval (arr[6].y == 8); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (arr[8].x == 9); /* { dg-warning \"TRUE\" } */\n+}"}, {"sha": "ccf8fe392bfa867952944a6c0768cb2e194022e9", "filename": "gcc/testsuite/gcc.dg/analyzer/compound-assignment-5.c", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcompound-assignment-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcompound-assignment-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcompound-assignment-5.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,142 @@\n+#include \"analyzer-decls.h\"\n+\n+struct coord\n+{\n+  int x;\n+  int y;\n+};\n+\n+/* Copying from one on-stack array to another.  */\n+\n+void test_1 (void)\n+{\n+  struct coord arr_a[16];\n+  struct coord arr_b[16];\n+  arr_a[3].x = 5;\n+  arr_a[3].y = 6;\n+\n+  arr_b[7] = arr_a[3];\n+\n+  __analyzer_eval (arr_b[7].x == 5); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (arr_b[7].y == 6); /* { dg-warning \"TRUE\" } */\n+}\n+\n+/* Copying from an on-stack array to a global array.  */\n+\n+struct coord glob_arr[16];\n+\n+void test_2 (void)\n+{\n+  struct coord arr[16];\n+  arr[3].x = 5;\n+  arr[3].y = 6;\n+\n+  glob_arr[7] = arr[3];\n+\n+  __analyzer_eval (glob_arr[7].x == 5); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (glob_arr[7].y == 6); /* { dg-warning \"TRUE\" } */\n+}\n+\n+/* Copying from a partially initialized on-stack array to a global array.  */\n+\n+struct coord glob_arr[16];\n+\n+void test_3 (void)\n+{\n+  struct coord arr[16];\n+  arr[3].y = 6;\n+\n+  glob_arr[7] = arr[3]; // or should the uninit warning be here?\n+\n+  __analyzer_eval (glob_arr[7].x); /* { dg-warning \"uninitialized\" \"uninit\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+  __analyzer_eval (glob_arr[7].y == 6); /* { dg-warning \"TRUE\" } */\n+}\n+\n+/* Symbolic bindings: copying from one array to another.  */\n+\n+struct coord glob_arr[16];\n+\n+void test_4 (int i)\n+{\n+  struct coord arr_a[16];\n+  struct coord arr_b[16];\n+  arr_a[i].x = 5;\n+  arr_a[i].y = 6;\n+  __analyzer_eval (arr_a[i].x == 5); /* { dg-warning \"TRUE\" \"TRUE\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"UNKNOWN\" { xfail *-*-* } .-1 } */\n+  __analyzer_eval (arr_a[i].y == 6); /* { dg-warning \"TRUE\" } */\n+\n+  arr_b[i] = arr_a[i];\n+\n+  __analyzer_eval (arr_b[i].x == 5); /* { dg-warning \"TRUE\" \"TRUE\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"UNKNOWN\" { xfail *-*-* } .-1 } */\n+  __analyzer_eval (arr_b[i].y == 6); /* { dg-warning \"TRUE\" \"TRUE\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"UNKNOWN\" { xfail *-*-* } .-1 } */\n+}\n+\n+/* Symbolic bindings: copying within an array: symbolic src and dest  */\n+\n+struct coord glob_arr[16];\n+\n+void test_5a (int i, int j)\n+{\n+  struct coord arr[16];\n+  arr[i].x = 5;\n+  arr[i].y = 6;\n+\n+  arr[j] = arr[i];\n+\n+  __analyzer_eval (arr[j].x == 5); /* { dg-warning \"TRUE\" \"TRUE\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"UNKNOWN\" { xfail *-*-* } .-1 } */\n+  __analyzer_eval (arr[j].y == 6); /* { dg-warning \"TRUE\" \"TRUE\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"UNKNOWN\" { xfail *-*-* } .-1 } */\n+}\n+\n+/* Symbolic bindings: copying within an array: symbolic src, concrete dest.  */\n+\n+struct coord glob_arr[16];\n+\n+void test_5b (int i)\n+{\n+  struct coord arr[16];\n+  arr[i].x = 5;\n+  arr[i].y = 6;\n+\n+  arr[3] = arr[i];\n+\n+  __analyzer_eval (arr[3].x == 5); /* { dg-warning \"TRUE\" \"TRUE\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"UNKNOWN\" { xfail *-*-* } .-1 } */\n+  __analyzer_eval (arr[3].y == 6); /* { dg-warning \"TRUE\" \"TRUE\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"UNKNOWN\" { xfail *-*-* } .-1 } */\n+}\n+\n+/* Symbolic bindings: copying within an array: concrete src, symbolic dest.  */\n+\n+struct coord glob_arr[16];\n+\n+void test_5c (int i)\n+{\n+  struct coord arr[16];\n+  arr[3].x = 5;\n+  arr[3].y = 6;\n+\n+  arr[i] = arr[3];\n+\n+  __analyzer_eval (arr[i].x == 5); /* { dg-warning \"TRUE\" \"TRUE\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"UNKNOWN\" { xfail *-*-* } .-1 } */\n+  __analyzer_eval (arr[i].y == 6); /* { dg-warning \"TRUE\" \"TRUE\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"UNKNOWN\" { xfail *-*-* } .-1 } */\n+}\n+\n+/* No info on the subregion being copied, and hence\n+   binding_cluster2::maybe_get_compound_binding should return NULL.  */\n+\n+void test_6 (void)\n+{\n+  struct coord arr[16];\n+  arr[7] = glob_arr[3];\n+\n+  __analyzer_eval (arr[7].x == 5); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (arr[7].y == 6); /* { dg-warning \"UNKNOWN\" } */\n+}"}, {"sha": "b1ac541920f66ba51a3f4a2e207b2023f89ef04c", "filename": "gcc/testsuite/gcc.dg/analyzer/conditionals-notrans.c", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fconditionals-notrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fconditionals-notrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fconditionals-notrans.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -7,15 +7,12 @@ void test (int i, int j)\n     {\n       __analyzer_eval (i > 4); /* { dg-warning \"TRUE\" } */\n       __analyzer_eval (i <= 4); /* { dg-warning \"FALSE\" } */\n-      __analyzer_eval (i > 3); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-      /* { dg-bogus \"UNKNOWN\" \"status quo\" { xfail *-*-* } .-1 } */\n+      __analyzer_eval (i > 3); /* { dg-warning \"TRUE\" } */\n \n       __analyzer_eval (i > 5); /* { dg-warning \"UNKNOWN\" } */\n-      __analyzer_eval (i != 3); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-      /* { dg-bogus \"UNKNOWN\" \"status quo\" { xfail *-*-* } .-1 } */\n+      __analyzer_eval (i != 3); /* { dg-warning \"TRUE\" } */\n \n-      __analyzer_eval (i == 3); /* { dg-warning \"FALSE\" \"desired\" { xfail *-*-* } } */\n-      /* { dg-bogus \"UNKNOWN\" \"status quo\" { xfail *-*-* } .-1 } */\n+      __analyzer_eval (i == 3); /* { dg-warning \"FALSE\" } */\n \n       __analyzer_eval (i != 4); /* { dg-warning \"TRUE\" } */\n       __analyzer_eval (i == 4); /* { dg-warning \"FALSE\" } */\n@@ -43,21 +40,17 @@ void test (int i, int j)\n       __analyzer_eval (i <= 4); /* { dg-warning \"TRUE\" } */\n       __analyzer_eval (i > 3); /* { dg-warning \"UNKNOWN\" } */\n \n-      __analyzer_eval (i > 5); /* { dg-warning \"FALSE\" \"desired\" { xfail *-*-* } } */\n-\t  /* { dg-bogus \"UNKNOWN\" \"status quo\" { xfail *-*-* } .-1 } */\n+      __analyzer_eval (i > 5); /* { dg-warning \"FALSE\" } */\n       __analyzer_eval (i != 3); /* { dg-warning \"UNKNOWN\" } */\n \n       __analyzer_eval (i == 3); /* { dg-warning \"UNKNOWN\" } */\n \n       __analyzer_eval (i != 4); /* { dg-warning \"UNKNOWN\" } */\n       __analyzer_eval (i == 4); /* { dg-warning \"UNKNOWN\" } */\n-      __analyzer_eval (i == 5); /* { dg-warning \"FALSE\" \"desired\" { xfail *-*-* } } */\n-      /* { dg-bogus \"UNKNOWN\" \"status quo\" { xfail *-*-* } .-1 } */\n-      __analyzer_eval (i != 5); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-      /* { dg-bogus \"UNKNOWN\" \"status quo\" { xfail *-*-* } .-1 } */\n+      __analyzer_eval (i == 5); /* { dg-warning \"FALSE\" } */\n+      __analyzer_eval (i != 5); /* { dg-warning \"TRUE\" } */\n       __analyzer_eval (i < 5); /* { dg-warning \"TRUE\" } */\n-      __analyzer_eval (i <= 5); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-      /* { dg-bogus \"UNKNOWN\" \"status quo\" { xfail *-*-* } .-1 } */\n+      __analyzer_eval (i <= 5); /* { dg-warning \"TRUE\" } */\n     }\n }\n \n@@ -101,8 +94,7 @@ void test_range_int_gt_lt (int i)\n {\n   if (i > 3)\n     if (i < 5)\n-      __analyzer_eval (i == 4); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-      /* { dg-bogus \"UNKNOWN\" \"status quo\" { xfail *-*-* } .-1 } */\n+      __analyzer_eval (i == 4); /* { dg-warning \"TRUE\" } */\n }\n \n void test_range_float_gt_lt (float f)\n@@ -116,8 +108,7 @@ void test_range_int_ge_lt (int i)\n {\n   if (i >= 4)\n     if (i < 5)\n-      __analyzer_eval (i == 4); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-      /* { dg-bogus \"UNKNOWN\" \"status quo\" { xfail *-*-* } .-1 } */\n+      __analyzer_eval (i == 4); /* { dg-warning \"TRUE\" } */\n }\n \n void test_range_float_ge_lt (float f)\n@@ -131,8 +122,7 @@ void test_range_int_gt_le (int i)\n {\n   if (i > 3)\n     if (i <= 4)\n-      __analyzer_eval (i == 4); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-      /* { dg-bogus \"UNKNOWN\" \"status quo\" { xfail *-*-* } .-1 } */\n+      __analyzer_eval (i == 4); /* { dg-warning \"TRUE\" } */\n }\n \n void test_range_float_gt_le (float f)\n@@ -146,8 +136,7 @@ void test_range_int_ge_le (int i)\n {\n   if (i >= 4)\n     if (i <= 4)\n-      __analyzer_eval (i == 4); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-      /* { dg-bogus \"UNKNOWN\" \"status quo\" { xfail *-*-* } .-1 } */\n+      __analyzer_eval (i == 4); /* { dg-warning \"TRUE\" } */\n }\n \n void test_range_float_ge_le (float f)"}, {"sha": "3f16a38ab14d424ee3dec5e3b0691789f9c51813", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-1.c", "status": "modified", "additions": 32, "deletions": 64, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-1.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -181,15 +181,8 @@ int test_12d (struct coord c)\n {\n   struct coord d;\n   d = c;\n-  __analyzer_eval (d.x == c.x); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-  /* { dg-warning \"UNKNOWN\" \"actual\" { target *-*-* } .-1 } */\n-  /* TODO(xfail): c and d share the same unknown value of type \"coord\", but\n-     attempts to access the fields lead to different unknown values.  */\n-\n-  __analyzer_eval (d.y == c.y); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-  /* { dg-warning \"UNKNOWN\" \"actual\" { target *-*-* } .-1 } */\n-  // TODO(xfail): likewise\n-\n+  __analyzer_eval (d.x == c.x); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (d.y == c.y); /* { dg-warning \"TRUE\" } */\n   __analyzer_eval (d.x == d.y); /* { dg-warning \"UNKNOWN\" } */\n   /* d and c share an unknown value of type \"struct coord\".\n      But d.x and d.y should be different unknown values (although they inherit\n@@ -211,25 +204,21 @@ void test_13 (struct outer *o)\n {\n   __analyzer_eval (o->mid.in.f == 0.f); /* { dg-warning \"UNKNOWN\" } */\n   o->mid.in.f = 0.f;\n-  __analyzer_eval (o->mid.in.f == 0.f); /* { dg-warning \"TRUE\" \"PR 93356\" { xfail *-*-* } } */\n-  /* { dg-warning \"UNKNOWN\" \"disabled float comparisons\" { target *-*-* } .-1 } */\n+  __analyzer_eval (o->mid.in.f == 0.f); /* { dg-warning \"TRUE\" } */\n }\n \n void test_14 (struct outer o)\n {\n   __analyzer_eval (o.mid.in.f == 0.f); /* { dg-warning \"UNKNOWN\" } */\n   o.mid.in.f = 0.f;\n-  __analyzer_eval (o.mid.in.f == 0.f); /* { dg-warning \"TRUE\" \"PR 93356\" { xfail *-*-* } } */\n-  /* { dg-warning \"UNKNOWN\" \"disabled float comparisons\" { target *-*-* } .-1 } */\n+  __analyzer_eval (o.mid.in.f == 0.f); /* { dg-warning \"TRUE\" } */\n }\n \n void test_15 (const char *str)\n {\n   char ch = str[0];\n   __analyzer_eval (ch == 'a'); /* { dg-warning \"UNKNOWN\" } */\n-  __analyzer_eval (ch == str[0]); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-  /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-1 } */\n-  // TODO(xfail)\n+  __analyzer_eval (ch == str[0]); /* { dg-warning \"TRUE\" } */\n \n   ch = 'a';\n   __analyzer_eval (ch == 'a'); /* { dg-warning \"TRUE\" } */\n@@ -242,15 +231,15 @@ void test_16 (void)\n \n   __analyzer_eval (msg != NULL); /* { dg-warning \"TRUE\" } */\n \n-  __analyzer_eval (msg[0] == 'h'); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-  /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-1 } */\n-  // TODO(xfail)\n+  __analyzer_eval (msg[0] == 'h'); /* { dg-warning \"TRUE\" } */\n \n-  __analyzer_eval (msg[1] == 'e'); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-  /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-1 } */\n-  // TODO(xfail)\n+  __analyzer_eval (msg[1] == 'e'); /* { dg-warning \"TRUE\" } */\n \n   __analyzer_eval (strlen (msg) == 11); /* { dg-warning \"TRUE\" } */\n+\n+  /* Out-of-bounds.  */\n+  __analyzer_eval (msg[100] == 'e'); /* { dg-warning \"UNKNOWN\" } */\n+  // TODO: some kind of warning for the out-of-bounds access\n }\n \n static const char *__attribute__((noinline))\n@@ -265,13 +254,9 @@ void test_16_alt (void)\n \n   __analyzer_eval (msg != NULL); /* { dg-warning \"TRUE\" } */\n \n-  __analyzer_eval (msg[0] == 'h'); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-  /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-1 } */\n-  // TODO(xfail)\n+  __analyzer_eval (msg[0] == 'h'); /* { dg-warning \"TRUE\" } */\n \n-  __analyzer_eval (msg[1] == 'e'); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-  /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-1 } */\n-  // TODO(xfail)\n+  __analyzer_eval (msg[1] == 'e'); /* { dg-warning \"TRUE\" } */\n \n   __analyzer_eval (strlen (msg) == 11); /* { dg-warning \"TRUE\" } */\n }\n@@ -334,9 +319,6 @@ void test_16e (int i)\n   __analyzer_eval (j == i); /* { dg-warning \"UNKNOWN\" } */\n }\n \n-/* TODO: and more complicated graph-like examples, where anything that's\n-   reachable from the pointer might be modified.  */\n-\n void test_17 (int i)\n {\n   int j = 42;\n@@ -477,13 +459,7 @@ void test_23 (struct foo *f, struct foo *g)\n   i = f->i + g->i;\n   j = f->i + g->i;\n   k = f->i * g->i;\n-  __analyzer_eval (i == j); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-  /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-1 } */\n-  /* TODO(xfail): we'd need to record that the two unknown values are both\n-     the sum of the two unknown input values (and thus are the same); not\n-     yet sure if we want arbitrary expression trees in the representation\n-     (analysis termination concerns).  */\n-\n+  __analyzer_eval (i == j); /* { dg-warning \"TRUE\" } */\n   __analyzer_eval (i == k); /* { dg-warning \"UNKNOWN\" } */\n }\n \n@@ -496,9 +472,7 @@ void test_24 (struct foo *f)\n   /* Overwriting a whole struct should invalidate our knowledge\n      about fields within it.  */\n   g = *f;\n-  __analyzer_eval (g.i == 42); /* { dg-warning \"UNKNOWN\" \"desired\" { xfail *-*-* } } */\n-  /* { dg-warning \"TRUE\" \"status quo\" { target *-*-* } .-1 } */\n-  // TODO(xfail)\n+  __analyzer_eval (g.i == 42); /* { dg-warning \"UNKNOWN\" } */\n }\n \n void test_25 (struct foo *f)\n@@ -513,16 +487,14 @@ void test_25 (struct foo *f)\n      source value should update our knowledge about fields within\n      the dest value.  */\n   g = *f;\n-  __analyzer_eval (g.i == 43); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-  /* { dg-warning \"FALSE\" \"status quo\" { target *-*-* } .-1 } */\n-  // TODO(xfail)\n+  __analyzer_eval (g.i == 43); /* { dg-warning \"TRUE\" } */\n }\n \n void test_26 (struct coord *p, struct coord *q)\n {\n   p->x = 42;\n-  q->y = 17;\n-  __analyzer_eval (p->x == 42); /* { dg-warning \"TRUE\" } */\n+  q->y = 17; /* could clobber p->x.  */\n+  __analyzer_eval (p->x == 42); /* { dg-warning \"UNKNOWN\" } */\n   __analyzer_eval (p->y); /* { dg-warning \"UNKNOWN\" } */\n   __analyzer_eval (q->x); /* { dg-warning \"UNKNOWN\" } */\n   __analyzer_eval (q->y == 17); /* { dg-warning \"TRUE\" } */\n@@ -531,26 +503,21 @@ void test_26 (struct coord *p, struct coord *q)\n      source value should update our knowledge about fields within\n      the dest value.  */\n   *p = *q;\n-  __analyzer_eval (p->x); /* { dg-warning \"UNKNOWN\" \"desired\" { xfail *-*-* } } */\n-  /* { dg-warning \"TRUE\" \"status quo\" { target *-*-* } .-1 } */\n-  // TODO(xfail): should have been overwritten\n+  __analyzer_eval (p->x); /* { dg-warning \"UNKNOWN\" } */\n   __analyzer_eval (p->y == 17); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n   /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-1 } */\n   // TODO(xfail): should have been overwritten with q->y\n \n   __analyzer_eval (q->x); /* { dg-warning \"UNKNOWN\" } */\n-  __analyzer_eval (q->y == 17); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (q->y == 17); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n+  /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-1 } */\n }\n \n void test_27 (struct coord *p)\n {\n   memset (p, 0, sizeof (struct coord));\n-  __analyzer_eval (p->x == 0); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-  /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-1 } */\n-  // TODO(xfail):\n-  __analyzer_eval (p->y == 0); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-  /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-1 } */\n-  // TODO(xfail):\n+  __analyzer_eval (p->x == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p->y == 0); /* { dg-warning \"TRUE\" } */\n }\n \n void test_28 (struct coord *p)\n@@ -663,6 +630,8 @@ void test_29a (struct coord p[])\n   __analyzer_eval (q[-2].y == 107025); /* { dg-warning \"TRUE\" } */\n \n   q -= 2;\n+  __analyzer_eval (q == &p[7]); /* { dg-warning \"UNKNOWN\" } */\n+  // TODO: make this be TRUE\n \n   __analyzer_eval (q->x == 107024); /* { dg-warning \"TRUE\" } */\n   __analyzer_eval (q->y == 107025); /* { dg-warning \"TRUE\" } */\n@@ -711,6 +680,7 @@ void test_29b (void)\n   __analyzer_eval (q[-2].y == 107025); /* { dg-warning \"TRUE\" } */\n \n   q -= 2;\n+  __analyzer_eval (q == &p[7]); /* { dg-warning \"TRUE\" } */\n \n   __analyzer_eval (q->x == 107024); /* { dg-warning \"TRUE\" } */\n   __analyzer_eval (q->y == 107025); /* { dg-warning \"TRUE\" } */\n@@ -759,6 +729,7 @@ void test_29c (int len)\n   __analyzer_eval (q[-2].y == 107025); /* { dg-warning \"TRUE\" } */\n \n   q -= 2;\n+  __analyzer_eval (q == &p[7]); /* { dg-warning \"TRUE\" } */\n \n   __analyzer_eval (q->x == 107024); /* { dg-warning \"TRUE\" } */\n   __analyzer_eval (q->y == 107025); /* { dg-warning \"TRUE\" } */\n@@ -936,12 +907,12 @@ void test_41 (void)\n   union u u;\n   u.i = 42;\n   __analyzer_eval (u.i == 42); /* { dg-warning \"TRUE\" } */\n-  __analyzer_eval (u.ptr == NULL); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (u.ptr == NULL); /* { dg-warning \"UNKNOWN|FALSE\" } */\n \n   /* Writes to a union member should invalidate knowledge about other members.  */\n   u.ptr = NULL;\n   __analyzer_eval (u.ptr == NULL); /* { dg-warning \"TRUE\" } */\n-  __analyzer_eval (u.i == 42); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (u.i == 42); /* { dg-warning \"UNKNOWN|FALSE\" } */\n }\n \n void test_42 (void)\n@@ -950,8 +921,7 @@ void test_42 (void)\n   float f;\n   i = 42;\n   f = i;\n-  __analyzer_eval (f == 42.0); /* { dg-warning \"TRUE\" \"PR 93356\" { xfail *-*-* } } */\n-  /* { dg-warning \"UNKNOWN\" \"disabled float comparisons\" { target *-*-* } .-1 } */\n+  __analyzer_eval (f == 42.0); /* { dg-warning \"TRUE\" } */\n }\n \n void test_43 (void)\n@@ -1063,10 +1033,8 @@ void test_51 (struct coord c)\n {\n   struct coord d;\n   memcpy (&d, &c, sizeof (struct coord));\n-  __analyzer_eval (c.x == d.x); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-  /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-1 } */\n-  __analyzer_eval (c.y == d.y); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-  /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-1 } */\n+  __analyzer_eval (c.x == d.x); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c.y == d.y); /* { dg-warning \"TRUE\" } */\n }\n \n struct big"}, {"sha": "31c1896b0c2e61ca9289b318100a654278c0afb3", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-13.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-13.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -14,8 +14,5 @@ void test_1 (void)\n void test_2 (void)\n {\n   global_union.ptr_val = malloc (1024); /* { dg-message \"allocated here\" } */\n-  global_union.int_val = 0;\n-} /* { dg-warning \"leak of '<unknown>' \" } */\n-/* TODO: something better than \"<unknown>\".  */\n-/* TODO: better location for the leak.  */\n-\n+  global_union.int_val = 0; /* { dg-warning \"leak of 'global_union.ptr_val' \" } */\n+} "}, {"sha": "1dbcb70112303d01fa04a539e4c3b42034773b8f", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-14.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-14.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -1,21 +1,16 @@\n-/* FIXME: we shouldn't need this.  */\n-/* { dg-additional-options \"-fanalyzer-fine-grained\" } */\n-\n #include <stdlib.h>\n \n void *global_ptr;\n \n void test_1 (int i)\n {\n   global_ptr = malloc (1024); /* { dg-message \"allocated here\" } */\n-  *(int *)&global_ptr = i; /* { dg-warning \"leak of '<unknown>'\" } */\n-  // TODO: something better than \"<unknown>\" here ^^^\n+  *(int *)&global_ptr = i; /* { dg-warning \"leak of 'global_ptr'\" } */\n }\n \n void test_2 (int i)\n {\n-  void *p = malloc (1024); /* { dg-message \"allocated here\" \"\" { xfail *-*-* } } */\n-  // TODO(xfail)\n+  void *p = malloc (1024); /* { dg-message \"allocated here\" } */\n   global_ptr = p;\n   *(int *)&p = i;\n   p = global_ptr;"}, {"sha": "86e8110ccf67796ff94274e15d1d7ddcd404b4cd", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-18.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-18.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -16,7 +16,5 @@ void test (int *p, int i, int j)\n \n   __analyzer_eval (p[3] == 42); /* { dg-warning \"UNKNOWN\" } */\n   __analyzer_eval (p[i] == 17); /* { dg-warning \"TRUE\" } */\n-  __analyzer_eval (p[j] == 17); /* { dg-warning \"UNKNOWN\" \"desired\" { xfail *-*-* } } */\n-  /* { dg-bogus \"TRUE\" \"status quo\" { xfail *-*-* } .-1 } */\n-  // FIXME(xfails) ^^^\n+  __analyzer_eval (p[j] == 17); /* { dg-warning \"UNKNOWN\" } */\n }"}, {"sha": "8fdbb6b3df6ccc67e264c339b35eab88c8b080a5", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-20.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-20.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-additional-options \"-Wno-analyzer-too-complex\" } */\n+\n+#include <stdlib.h>\n+\n+struct foo { int dummy; };\n+\n+struct foo **\n+test (int n) {\n+  struct foo **arr;\n+  int i;\n+\n+  if ((arr = (struct foo **)malloc(n * sizeof(struct foo *))) == NULL)\n+    return NULL;\n+\n+  for (i = 0; i < n; i++) {\n+    if ((arr[i] = (struct foo *)malloc(sizeof(struct foo))) == NULL) {\n+      for (; i >= 0; i++) {\n+\tfree(arr[i]); /* { dg-bogus \"double-'free'\" } */\n+      }\n+      free(arr);\n+      return NULL;\n+    }\n+  }\n+  return arr;\n+}"}, {"sha": "2135c70eb8dd3340eb6839e1e5dbac3f9b298528", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-5.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -90,11 +90,20 @@ void unref (base_obj *obj)\n {\n   if (--obj->ob_refcnt == 0) /* { dg-bogus \"dereference of uninitialized pointer 'obj'\" } */\n     obj->ob_type->tp_dealloc (obj);\n+  /* { dg-warning \"dereference of NULL 'obj'\" \"deref of NULL\" { target *-*-* } .-2 } */\n+  /* FIXME: ideally we wouldn't issue this, as we've already issued a\n+     warning about str_obj which is now in the \"stop\" state; the cast\n+     confuses things.  */\n }\n \n void test_1 (const char *str)\n {\n   base_obj *obj = new_string_obj (str);\n-  //__analyzer_dump();\n   unref (obj);\n-} /* { dg-bogus \"leak\" } */\n+} /* { dg-bogus \"leak\" \"\" { xfail *-*-* } } */\n+/* XFAIL (false leak):\n+   Given that we only know \"len\" symbolically, this line:\n+     str_obj->str_buf[len] = '\\0';\n+   is a symbolic write which could clobber the ob_type or ob_refcnt.\n+   It reports a leak when following the path where the refcount is clobbered\n+   to be a value that leads to the deallocator not being called.  */"}, {"sha": "cd6a4df00dd940457d6c0b750432569cded09695", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-5b.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5b.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -86,8 +86,10 @@ void test_1 (const char *str)\n   //__analyzer_dump();\n   if (obj)\n     unref (obj);\n-} /* { dg-bogus \"leak of 'obj'\" \"\" { xfail *-*-* } } */\n-/* TODO(xfail): the false leak report involves the base_obj.ob_refcnt\n-   being 1, but the string_obj.str_base.ob_refcnt being unknown (when\n-   they ought to be the same region), thus allowing for a path in which\n-   the object is allocated but not freed.  */\n+} /* { dg-bogus \"leak\" \"\" { xfail *-*-* } } */\n+/* XFAIL (false leak):\n+   Given that we only know \"len\" symbolically, this line:\n+     str_obj->str_buf[len] = '\\0';\n+   is a symbolic write which could clobber the ob_type or ob_refcnt.\n+   It reports a leak when following the path where the refcount is clobbered\n+   to be a value that leads to the deallocator not being called.  */"}, {"sha": "ad4e1d2644dfe77fd6dc927b31b355506eec396b", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-5c.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5c.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -75,9 +75,10 @@ void test_1 (const char *str)\n   string_obj *obj = new_string_obj (str);\n   if (obj)\n     unref (obj);\n-} /* { dg-bogus \"leak of 'obj'\" \"\" { xfail *-*-* } } */\n-/* TODO(xfail): the false leak report involves the base_obj.ob_refcnt\n-   being 1, but the string_obj.str_base.ob_refcnt being unknown (when\n-   they ought to be the same region), thus allowing for a path in which\n-   the object is allocated but not freed.  */\n-\n+} /* { dg-bogus \"leak\" \"\" { xfail *-*-* } } */\n+/* XFAIL (false leak):\n+   Given that we only know \"len\" symbolically, this line:\n+     str_obj->str_buf[len] = '\\0';\n+   is a symbolic write which could clobber the ob_type or ob_refcnt.\n+   It reports a leak when following the path where the refcount is clobbered\n+   to be a value that leads to the deallocator not being called.  */"}, {"sha": "b4d77a939bc93c388f7b96abdc1274fe0d159a0d", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-5d.c", "status": "modified", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5d.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -5,34 +5,33 @@\n #include <stdlib.h>\n #include \"analyzer-decls.h\"\n \n-typedef struct base_obj base_obj;\n-typedef struct type_obj type_obj;\n-typedef struct string_obj string_obj;\n-\n-struct base_obj\n+typedef struct base_obj\n {\n   struct type_obj *ob_type;\n   int ob_refcnt;\n-};\n+} base_obj;\n \n-struct type_obj\n+typedef struct type_obj\n {\n   base_obj tp_base;\n-};\n+  void (*tp_dealloc) (base_obj *);\n+} type_obj;\n \n-struct string_obj\n+typedef struct boxed_int_obj\n {\n-  base_obj str_base;\n-  size_t str_len;\n-  char str_buf[];\n-};\n+  base_obj int_base;\n+  int int_val;\n+} boxed_int_obj;\n+\n+extern void int_del (base_obj *);\n \n type_obj type_type = {\n-  { &type_type, 1},\n+  { &type_type, 1}\n };\n \n-type_obj str_type = {\n-  { &str_type, 1},\n+type_obj boxed_int_type = {\n+  { &type_type, 1},\n+  int_del\n };\n \n base_obj *alloc_obj (type_obj *ob_type, size_t sz)\n@@ -45,20 +44,28 @@ base_obj *alloc_obj (type_obj *ob_type, size_t sz)\n   return obj;\n }\n \n+base_obj *new_int_obj (int val)\n+{\n+  boxed_int_obj *int_obj\n+    = (boxed_int_obj *)alloc_obj (&boxed_int_type, sizeof (boxed_int_obj));\n+  if (!int_obj)\n+    return NULL;\n+  int_obj->int_val = val;\n+  return (base_obj *)int_obj;\n+}\n+\n void unref (base_obj *obj)\n {\n-  //__analyzer_dump();\n   if (--obj->ob_refcnt == 0)\n-    free (obj);\n+    obj->ob_type->tp_dealloc (obj);\n }\n \n-void test_1 ()\n+void test_1 (const char *str)\n {\n-  base_obj *obj = alloc_obj (&str_type, sizeof (string_obj));\n-  if (obj)\n-    {\n-      __analyzer_dump_num_heap_regions (); /* { dg-warning \"num heap regions: '1'\" } */\n-      unref (obj);\n-      __analyzer_dump_num_heap_regions (); /* { dg-warning \"num heap regions: '0'\" } */\n-    }\n-}\n+  base_obj *obj = new_int_obj (42);\n+  if (!obj)\n+    return;\n+  __analyzer_eval (((boxed_int_obj *)obj)->int_val == 42); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (obj->ob_refcnt == 1); /* { dg-warning \"TRUE\" } */\n+  unref (obj);\n+} /* { dg-bogus \"leak\" \"\" } */"}, {"sha": "78a797ead76e4a6445e6eeb05012792b2f404db8", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-6.c", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5034abbaa49f15646c83224711447aa1ed31756/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5034abbaa49f15646c83224711447aa1ed31756/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-6.c?ref=b5034abbaa49f15646c83224711447aa1ed31756", "patch": "@@ -1,14 +0,0 @@\n-#include <stdlib.h>\n-#include \"analyzer-decls.h\"\n-\n-/* Verify that we don't accumulate state after a malloc/free pair.  */\n-\n-void test (void)\n-{\n-  void *ptr;\n-  __analyzer_dump_num_heap_regions (); /* { dg-warning \"num heap regions: '0'\" } */\n-  ptr = malloc (1024);\n-  __analyzer_dump_num_heap_regions (); /* { dg-warning \"num heap regions: '1'\" } */\n-  free (ptr);\n-  __analyzer_dump_num_heap_regions (); /* { dg-warning \"num heap regions: '0'\" } */\n-}"}, {"sha": "3e69d0f8aa5a4511eb14b6f0f92b681fef2c3544", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-8.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-8.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -21,6 +21,5 @@ void test (void)\n \n   struct base *bp = (struct base *)&s;\n \n-  __analyzer_eval (bp->i == 3); /* { dg-warning \"TRUE\"  \"desired\" { xfail *-*-* } } */\n-  /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-1 } */\n+  __analyzer_eval (bp->i == 3); /* { dg-warning \"TRUE\" } */\n }"}, {"sha": "bc57c6ecef234177f0fc16a9f8429c9305df7882", "filename": "gcc/testsuite/gcc.dg/analyzer/describe-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdescribe-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdescribe-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdescribe-1.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,11 @@\n+/* Smoketest for __analyzer_describe.  */\n+\n+#include \"analyzer-decls.h\"\n+\n+void test (int i)\n+{\n+  __analyzer_describe (0, 42); /* { dg-warning \"svalue: '\\\\(int\\\\)42'\" } */\n+  __analyzer_describe (0, i); /* { dg-warning \"svalue: 'INIT_VAL\\\\(i.*\\\\)'\" } */\n+  __analyzer_describe (0, &i); /* { dg-warning \"svalue: '&i'\" } */\n+  /* Further cases would risk overspecifying things. */\n+}"}, {"sha": "ff418b156c084a0d96faf3f8227d0d3f9948407d", "filename": "gcc/testsuite/gcc.dg/analyzer/dot-output.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdot-output.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdot-output.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdot-output.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -18,8 +18,7 @@ int *test (int *buf, int n, int *out)\n   \n   /* A loop, to ensure we have phi nodes.  */\n   for (i = 0; i < n; i++)\n-    result[i] = buf[i] + i; /* { dg-warning \"possibly-NULL\" \"\" { xfail *-*-* } } */\n-  /* TODO(xfail): why isn't the warning appearing? */\n+    result[i] = buf[i] + i; /* { dg-warning \"possibly-NULL\" } */\n \n   /* Example of a \"'\" (to test quoting).  */\n   *out = some_call (i, 'a');"}, {"sha": "9b95afd9a031aad10ea7ed89d74790ecab2a85ac", "filename": "gcc/testsuite/gcc.dg/analyzer/explode-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-1.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -47,7 +47,7 @@ void test (void)\n \t{\n \tdefault:\n \tcase 0:\n-\t  *pp = malloc (16);\n+\t  *pp = malloc (16); /* { dg-warning \"leak\" } */\n \t  break;\n \tcase 1:\n \t  free (*pp);"}, {"sha": "70d8fecae8f624b6c7c001df8b71c8211961c9dd", "filename": "gcc/testsuite/gcc.dg/analyzer/explode-2.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-2.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -19,31 +19,31 @@ void test (void)\n \t{\n \tdefault:\n \tcase 0:\n-\t  p0 = malloc (16);\n+\t  p0 = malloc (16); /* { dg-warning \"leak\" } */\n \t  break;\n \tcase 1:\n-\t  free (p0); /* { dg-warning \"double-'free' of 'p0'\" } */\n+\t  free (p0); /* { dg-warning \"double-'free' of 'p0'\" \"\" { xfail *-*-* } } */\n \t  break;\n \n \tcase 2:\n-\t  p1 = malloc (16);\n+\t  p1 = malloc (16); /* { dg-warning \"leak\" } */\n \t  break;\n \tcase 3:\n-\t  free (p1); /* { dg-warning \"double-'free' of 'p1'\" } */\n+\t  free (p1); /* { dg-warning \"double-'free' of 'p1'\" \"\" { xfail *-*-* } } */\n \t  break;\n \n \tcase 4:\n-\t  p2 = malloc (16);\n+\t  p2 = malloc (16); /* { dg-warning \"leak\" } */\n \t  break;\n \tcase 5:\n-\t  free (p2); /* { dg-warning \"double-'free' of 'p2'\" } */\n+\t  free (p2); /* { dg-warning \"double-'free' of 'p2'\" \"\" { xfail *-*-* } } */\n \t  break;\n \n \tcase 6:\n-\t  p3 = malloc (16);\n+\t  p3 = malloc (16); /* { dg-warning \"leak\" } */\n \t  break;\n \tcase 7:\n-\t  free (p3); /* { dg-warning \"double-'free' of 'p3'\" } */\n+\t  free (p3); /* { dg-warning \"double-'free' of 'p3'\" \"\" { xfail *-*-* } } */\n \t  break;\n \t}\n     }"}, {"sha": "f2a8a4cb0be355cfb927fbcba343b5d92f8524f0", "filename": "gcc/testsuite/gcc.dg/analyzer/feasibility-1.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffeasibility-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffeasibility-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffeasibility-1.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,62 @@\n+#include \"analyzer-decls.h\"\n+\n+void test_1 (void)\n+{\n+  __analyzer_dump_path (); /* { dg-message \"path\" } */\n+}\n+\n+void test_2 (int flag)\n+{\n+  if (flag)\n+    __analyzer_dump_path (); /* { dg-message \"path\" } */\n+}\n+\n+void test_3 (int flag)\n+{\n+  if (flag)\n+    if (!flag)\n+      __analyzer_dump_path (); /* { dg-bogus \"path\" } */\n+}\n+\n+int global_for_test_4;\n+static void __attribute__((noinline)) called_by_test_4 () {}\n+void test_4 (void)\n+{\n+  /* Verify that a state change that happens in a stmt that\n+     isn't the first within its BB can affect path feasibility.  */\n+  global_for_test_4 = 0;\n+  global_for_test_4 = 1;\n+  /* Thwart the optimizer.  */\n+  called_by_test_4 ();\n+  if (global_for_test_4)\n+    __analyzer_dump_path (); /* { dg-message \"path\" } */\n+}\n+\n+/* Verify that loops don't confuse the feasibility checker.  */\n+\n+void test_5 (void)\n+{\n+  for (int i = 0; i < 1024; i++)\n+    {\n+    }\n+  __analyzer_dump_path (); /* { dg-message \"path\" } */\n+}\n+\n+/* Reproducer for an issue seen with CVE-2005-1689 (PR analyzer/96374): if we\n+   take the shortest path and update state and check feasibility per-edge, we\n+   can erroneously reject valid diagnostics.  */\n+\n+int test_6 (int a, int b)\n+{\n+  int problem = 0;\n+  if (a)\n+    problem = 1;\n+  if (b)\n+    {\n+      if (!problem)\n+\tproblem = 2;\n+      __analyzer_dump_path (); /* { dg-message \"path\" \"\" { xfail *-*-* } } */\n+      /* XFAIL is PR analyzer/96374.  */\n+    }\n+  return problem;\n+}"}, {"sha": "8b71e1abcae81c2e510ff2865e099c563c8af54a", "filename": "gcc/testsuite/gcc.dg/analyzer/first-field-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffirst-field-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffirst-field-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffirst-field-1.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,24 @@\n+#include \"analyzer-decls.h\"\n+\n+typedef struct base_obj\n+{\n+  int m_first;\n+  int m_second;\n+} base_obj;\n+\n+typedef struct sub_obj\n+{\n+  base_obj base;\n+} sub_obj;\n+\n+void test (sub_obj *sub)\n+{\n+  sub->base.m_first = 1;\n+  sub->base.m_second = 2;\n+  __analyzer_eval (sub->base.m_first == 1); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (sub->base.m_second == 2); /* { dg-warning \"TRUE\" } */\n+\n+  base_obj *base = (struct base_obj *)sub;\n+  __analyzer_eval (base->m_first == 1); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (base->m_second == 2); /* { dg-warning \"TRUE\" } */\n+}"}, {"sha": "2fb98d3c9d728bddf2f7cf5546c7730fbde8c00f", "filename": "gcc/testsuite/gcc.dg/analyzer/first-field-2.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffirst-field-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffirst-field-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffirst-field-2.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,33 @@\n+/* A toy re-implementation of CPython's object model.  */\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"analyzer-decls.h\"\n+\n+typedef struct base_obj base_obj;\n+typedef struct string_obj string_obj;\n+\n+struct base_obj\n+{\n+  int ob_refcnt;\n+};\n+\n+struct string_obj\n+{\n+  base_obj str_base;\n+  size_t str_len;\n+  char str_buf[];\n+};\n+\n+base_obj *alloc_obj (const char *str)\n+{\n+  size_t len = strlen (str);\n+  base_obj *obj = (base_obj *)malloc (sizeof (string_obj) + len + 1);\n+  if (!obj)\n+    return NULL;\n+  obj->ob_refcnt = 1;\n+  string_obj *str_obj = (string_obj *)obj;\n+  __analyzer_eval (str_obj->str_base.ob_refcnt == 1); /* { dg-warning \"TRUE\" } */\n+  return obj;\n+}"}, {"sha": "e51d88e9ff927b60361c08daf56f36166076ce8c", "filename": "gcc/testsuite/gcc.dg/analyzer/init.c", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Finit.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,136 @@\n+/* Tests of brace-enclosed initializers\n+   Some of these use the CONSTRUCTOR tree code, but it appears\n+   only for a full zero-init; it appears that by the time the analyzer\n+   runs that this initialization has been converted into field-wise\n+   gimple assign stmts, with just \"zero-init everything\" CONSTRUCTORs\n+   and \"clobber\" CONSTRUCTORs.  */\n+\n+#include \"analyzer-decls.h\"\n+\n+struct coord\n+{\n+  int x;\n+  int y;\n+};\n+\n+struct tri\n+{\n+  struct coord v[3];\n+};\n+\n+union iap\n+{\n+  int i;\n+  void *p;\n+};\n+\n+void test_1 (void)\n+{\n+  struct coord c = {3, 4};\n+  __analyzer_eval (c.x == 3); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c.y == 4); /* { dg-warning \"TRUE\" } */  \n+}\n+\n+void test_2 (void)\n+{\n+  struct coord c = {3};\n+  __analyzer_eval (c.x == 3); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c.y == 0); /* { dg-warning \"TRUE\" } */  \n+}\n+\n+void test_3 (void)\n+{\n+  struct coord c = {};\n+  __analyzer_eval (c.x == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c.y == 0); /* { dg-warning \"TRUE\" } */  \n+}\n+\n+void test_4 (void)\n+{\n+  int c[2] = {3, 4};\n+  __analyzer_eval (c[0] == 3); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c[1] == 4); /* { dg-warning \"TRUE\" } */  \n+}\n+\n+void test_5 (void)\n+{\n+  int c[2] = {3};\n+  __analyzer_eval (c[0] == 3); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c[1] == 0); /* { dg-warning \"TRUE\" } */  \n+}\n+\n+void test_6 (void)\n+{\n+  int c[2] = {};\n+  __analyzer_eval (c[0] == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c[1] == 0); /* { dg-warning \"TRUE\" } */  \n+}\n+\n+void test_7 (void)\n+{\n+  struct coord c[2] = {{3, 4}, {5, 6}};\n+  __analyzer_eval (c[0].x == 3); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c[0].y == 4); /* { dg-warning \"TRUE\" } */  \n+  __analyzer_eval (c[1].x == 5); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c[1].y == 6); /* { dg-warning \"TRUE\" } */  \n+}\n+\n+void test_8 (void)\n+{\n+  struct coord c[2] = {{3}, {5}};\n+  __analyzer_eval (c[0].x == 3); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c[0].y == 0); /* { dg-warning \"TRUE\" } */  \n+  __analyzer_eval (c[1].x == 5); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c[1].y == 0); /* { dg-warning \"TRUE\" } */  \n+}\n+\n+void test_9 (void)\n+{\n+  struct coord c[2] = {{}, {}};\n+  __analyzer_eval (c[0].x == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c[0].y == 0); /* { dg-warning \"TRUE\" } */  \n+  __analyzer_eval (c[1].x == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c[1].y == 0); /* { dg-warning \"TRUE\" } */  \n+}\n+\n+void test_10 (void)\n+{\n+  struct coord c[2] = {{.y = 4, .x = 3}, {5, 6}};\n+  __analyzer_eval (c[0].x == 3); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c[0].y == 4); /* { dg-warning \"TRUE\" } */  \n+  __analyzer_eval (c[1].x == 5); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c[1].y == 6); /* { dg-warning \"TRUE\" } */  \n+}\n+\n+void test_11 (void)\n+{\n+  struct coord c[2] = {{.y = 4}, {5, 6}};\n+  __analyzer_eval (c[0].x == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c[0].y == 4); /* { dg-warning \"TRUE\" } */  \n+  __analyzer_eval (c[1].x == 5); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c[1].y == 6); /* { dg-warning \"TRUE\" } */  \n+}\n+\n+void test_12 (void)\n+{\n+  struct tri t = {};\n+  __analyzer_eval (t.v[0].x == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (t.v[2].y == 0); /* { dg-warning \"TRUE\" } */  \n+}\n+\n+void test_13 (void)\n+{\n+  struct tri t = {3, 4, 5, 6, 7, 8};\n+  __analyzer_eval (t.v[0].x == 3); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (t.v[0].y == 4); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (t.v[1].x == 5); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (t.v[1].y == 6); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (t.v[2].x == 7); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (t.v[2].y == 8); /* { dg-warning \"TRUE\" } */\n+}\n+\n+void test_14 (void)\n+{\n+  union iap u = {};\n+  __analyzer_eval (u.i == 0); /* { dg-warning \"TRUE\" } */\n+}"}, {"sha": "bba3e816db76bfd3c3fa6c3db2730e7a9c15e180", "filename": "gcc/testsuite/gcc.dg/analyzer/leak-2.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fleak-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fleak-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fleak-2.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,9 @@\n+#include <stdlib.h>\n+\n+void *ptr;\n+\n+void *test (void)\n+{\n+  ptr = malloc (1024);\n+  ptr = NULL; /* { dg-warning \"leak of 'ptr'\" } */\n+}"}, {"sha": "0172c9b324c7c4a31d45f5aa71bb488f8e734d01", "filename": "gcc/testsuite/gcc.dg/analyzer/loop-0-up-to-n-by-1-with-iter-obj.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-0-up-to-n-by-1-with-iter-obj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-0-up-to-n-by-1-with-iter-obj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-0-up-to-n-by-1-with-iter-obj.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,73 @@\n+#include <stdlib.h>\n+\n+#include \"analyzer-decls.h\"\n+\n+struct iter\n+{\n+  int start;\n+  int end;\n+  int step;\n+  int val;\n+};\n+\n+struct iter *  __attribute__((noinline))\n+iter_new (int start, int end, int step)\n+{\n+  struct iter *it = (struct iter *)malloc (sizeof (struct iter));\n+  if (!it)\n+    abort ();\n+  it->start = start;\n+  it->end = end;\n+  it->step = step;\n+  it->val = start;\n+  return it;\n+}\n+\n+int __attribute__((noinline))\n+iter_done_p (struct iter *it)\n+{\n+  return it->val >= it->end;\n+}\n+\n+void __attribute__((noinline))\n+iter_next (struct iter *it)\n+{\n+  it->val += it->step;\n+}\n+\n+/* Example of an iterator object, to see how well we cope with a well-disguised\n+   iteration from 0 to n with a step of 1.  */\n+\n+void test(int n)\n+{\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+\n+  struct iter *it = iter_new (0, n, 1);\n+  while (!iter_done_p (it))\n+    {\n+      __analyzer_eval (it->val < n); /* { dg-warning \"TRUE\" \"true\" { xfail *-*-* } } */\n+      /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+      /* TODO(xfail^^^): ideally we ought to figure out i > 0 after 1st iteration.  */\n+\n+      __analyzer_eval (it->val == 0); /* { dg-warning \"TRUE\" \"true on 1st iter\" } */\n+      /* { dg-warning \"UNKNOWN\" \"unknown\" { target *-*-* } .-1 } */\n+      /* TODO: should we ought to figure out i > 0 after 1st iteration?  */\n+\n+      __analyzer_eval (it->val >= 0); /* { dg-warning \"TRUE\" } */\n+\n+      __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n+\n+      iter_next (it);\n+    }\n+\n+  __analyzer_eval (it->val >= n); /* { dg-warning \"TRUE\" \"true\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+\n+  __analyzer_eval (it->val == n); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n+  /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-1 } */\n+  /* TODO(xfail^^^): it only figures out i >= 256, rather than i == 256.  */\n+\n+  free (it);\n+\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+}"}, {"sha": "d49ed130488801bfc00b6dee1d3310eaf507c670", "filename": "gcc/testsuite/gcc.dg/analyzer/loop-0-up-to-n-by-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-0-up-to-n-by-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-0-up-to-n-by-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-0-up-to-n-by-1.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,31 @@\n+#include \"analyzer-decls.h\"\n+\n+void test(int n)\n+{\n+  int i;\n+\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+\n+  for (i = 0; i < n; i++) {\n+      __analyzer_eval (i < n); /* { dg-warning \"TRUE\" } */\n+      /* (should report TRUE twice). */\n+\n+      __analyzer_eval (i == 0); /* { dg-warning \"TRUE\" \"1st\" } */\n+      /* { dg-warning \"FALSE\" \"2nd\" { xfail *-*-* } .-1 } */\n+      /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-2 } */\n+      /* TODO(xfail^^^): ideally we ought to figure out i > 0 after 1st iteration.  */\n+\n+      __analyzer_eval (i >= 0); /* { dg-warning \"TRUE\" } */\n+\n+      __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n+  }\n+\n+  __analyzer_eval (i >= n); /* { dg-warning \"TRUE\" \"true\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+\n+  __analyzer_eval (i == n); /* { dg-warning \"TRUE\" \"true\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+  /* TODO(xfail^^^): it only figures out i >= 256, rather than i == 256.  */\n+\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+}"}, {"sha": "16b64497cb7d33657beaeca8b027b3e420416897", "filename": "gcc/testsuite/gcc.dg/analyzer/loop-2a.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-2a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-2a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-2a.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -14,10 +14,7 @@ void test(void)\n \n \n   for (u.i=0; u.i<256; u.i++) {\n-    __analyzer_eval (u.i < 256); /* { dg-warning \"TRUE\" \"1st\" } */\n-    /* { dg-warning \"TRUE\" \"2nd\" { xfail *-*-* } .-1 } */\n-    /* { dg-bogus \"UNKNOWN\" \"status quo\" { xfail *-*-* } .-2 } */\n-    /* (should report TRUE twice). */\n+    __analyzer_eval (u.i < 256); /* { dg-warning \"TRUE\" } */\n \n     __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n \n@@ -26,11 +23,10 @@ void test(void)\n       /* TODO(xfail^^^): we're only capturing the first iteration, so\n \t we erroneously get i == 0.  */\n \n-      //__analyzer_eval (u.i >= 0); /* { d-todo-g-warning \"TRUE\" } */\n+    __analyzer_eval (u.i >= 0); /* { dg-warning \"TRUE\" } */\n   }\n \n-  __analyzer_eval (u.i >= 256); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-  /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-1 } */\n+  __analyzer_eval (u.i >= 256); /* { dg-warning \"TRUE\" } */\n \n   __analyzer_eval (u.i == 256); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n   /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-1 } */"}, {"sha": "0bcf70746232fec276c641e3ac4b4a63c77c461a", "filename": "gcc/testsuite/gcc.dg/analyzer/loop-3.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-3.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -6,11 +6,8 @@ void test(int c)\n   char *buffer = (char*)malloc(256);\n \n   for (i=0; i<255; i++) {\n-    buffer[i] = c; /* { dg-warning \"use after 'free' of 'buffer'\" } */\n-\t\t   /* BUG: the malloc could have failed\n-\t\t      TODO: the checker doesn't yet pick up on this, perhaps\n-\t\t      due to the pointer arithmetic not picking up on the\n-\t\t      state */\n+    buffer[i] = c; /* { dg-warning \"use after 'free' of 'buffer'\" \"use after free\" { xfail *-*-* } } */\n+                   /* { dg-warning \"possibly-NULL 'buffer'\" \"deref of unchecked\" { target *-*-* } .-1 } */\n     free(buffer); /* { dg-warning \"double-'free' of 'buffer'\" } */\n   }\n "}, {"sha": "b66a3459437679125b728c15ce294391324b8947", "filename": "gcc/testsuite/gcc.dg/analyzer/loop-4.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-4.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -1,6 +1,3 @@\n-// FIXME:\n-/* { dg-additional-options \"-fno-analyzer-state-purge\" } */\n-\n /* Example of nested loops.  */\n \n #include \"analyzer-decls.h\"\n@@ -13,8 +10,7 @@ void test(void)\n \n   for (i=0; i<256; i++) {\n \n-    __analyzer_eval (i >= 0); /* { dg-warning \"TRUE\" \"true\" } */\n-      /* { dg-warning \"UNKNOWN\" \"unknown\" { target *-*-* } .-1 } */\n+    __analyzer_eval (i >= 0); /* { dg-warning \"TRUE\" } */\n \n     __analyzer_eval (i < 256); /* { dg-warning \"TRUE\" } */\n \n@@ -23,7 +19,9 @@ void test(void)\n       __analyzer_eval (j >= 0); /* { dg-warning \"TRUE\" \"true\" } */\n       /* { dg-warning \"UNKNOWN\" \"unknown\" { target *-*-* } .-1 } */\n \n-      __analyzer_eval (j < 256); /* { dg-warning \"TRUE\" } */\n+      __analyzer_eval (j < 256); /* { dg-warning \"TRUE\" \"true\" } */\n+      /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+      /* TODO(xfail^^^): should report TRUE twice. */\n \n       __analyzer_dump_exploded_nodes (0); /* { dg-warning \"3 processed enodes\" } */\n \n@@ -32,7 +30,8 @@ void test(void)\n \t__analyzer_eval (k >= 0); /* { dg-warning \"TRUE\" \"true\" } */\n \t/* { dg-warning \"UNKNOWN\" \"unknown\" { target *-*-* } .-1 } */\n \n-\t__analyzer_eval (k < 256); /* { dg-warning \"TRUE\" } */\n+\t__analyzer_eval (k < 256); /* { dg-warning \"TRUE\" \"true\" } */\n+\t/* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n \n \t__analyzer_dump_exploded_nodes (0); /* { dg-warning \"4 processed enodes\" } */\n       }"}, {"sha": "e02a849d4bbfcc3dd13df60f1ae1307e2aa4dcc5", "filename": "gcc/testsuite/gcc.dg/analyzer/loop-n-down-to-1-by-1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-n-down-to-1-by-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-n-down-to-1-by-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-n-down-to-1-by-1.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,35 @@\n+#include \"analyzer-decls.h\"\n+\n+void test(int n)\n+{\n+  int i;\n+\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+\n+  for (i = n; i > 0; i--) {\n+      __analyzer_eval (i > 0); /* { dg-warning \"TRUE\" \"true\" } */\n+      /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+      /* TODO(xfail^^^): should report TRUE twice. */\n+\n+      __analyzer_eval (i == n); /* { dg-warning \"TRUE\" \"1st\" } */\n+      /* { dg-warning \"FALSE\" \"2nd\" { xfail *-*-* } .-1 } */\n+      /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-2 } */\n+      /* TODO(xfail^^^): ideally we ought to figure out i > 0 after 1st iteration.  */\n+\n+      __analyzer_eval (i <= n); /* { dg-warning \"TRUE\" \"1st\" } */\n+      /* { dg-warning \"TRUE\" \"2nd\" { xfail *-*-* } } */\n+      /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-2 } */\n+      /* TODO(xfail^^^): ideally we ought to figure out i >= 0 for all iterations.  */\n+\n+      __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n+  }\n+\n+  __analyzer_eval (i <= 0); /* { dg-warning \"TRUE\" \"true\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+\n+  __analyzer_eval (i == 0); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n+  /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-1 } */\n+  /* TODO(xfail^^^): it only figures out i >= 256, rather than i == 256.  */\n+\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+}"}, {"sha": "3513bf423474a2290beac6c170eb3b3a6fe29ed5", "filename": "gcc/testsuite/gcc.dg/analyzer/loop-start-down-to-end-by-1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-start-down-to-end-by-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-start-down-to-end-by-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-start-down-to-end-by-1.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,35 @@\n+#include \"analyzer-decls.h\"\n+\n+void test(int start, int end, int step)\n+{\n+  int i;\n+\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+\n+  for (i = start; i > end; i --) {\n+      __analyzer_eval (i > end); /* { dg-warning \"TRUE\" \"true\" } */\n+      /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+      /* TODO(xfail^^^): should report TRUE twice. */\n+\n+      __analyzer_eval (i == start); /* { dg-warning \"TRUE\" \"1st\" } */\n+      /* { dg-warning \"FALSE\" \"2nd\" { xfail *-*-* } .-1 } */\n+      /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-2 } */\n+      /* TODO(xfail^^^): ideally we ought to figure out i > 0 after 1st iteration.  */\n+\n+      __analyzer_eval (i <= start); /* { dg-warning \"TRUE\" \"true\" } */\n+      /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+      /* TODO(xfail^^^): should report TRUE twice. */\n+\n+      __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n+  }\n+\n+  __analyzer_eval (i >= end); /* { dg-warning \"TRUE\" \"true\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+\n+  // FIXME: do we know this?  What if we overshoot?\n+  __analyzer_eval (i == end); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n+  /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-1 } */\n+  /* TODO(xfail^^^): it only figures out i >= 256, rather than i == 256.  */\n+\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+}"}, {"sha": "2692c503b5c94b9277364224d2fe680eb96aeebe", "filename": "gcc/testsuite/gcc.dg/analyzer/loop-start-down-to-end-by-step.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-start-down-to-end-by-step.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-start-down-to-end-by-step.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-start-down-to-end-by-step.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,30 @@\n+#include \"analyzer-decls.h\"\n+\n+void test(int start, int end, int step)\n+{\n+  int i;\n+\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+\n+  for (i = start; i > end; i -= step) {\n+      __analyzer_eval (i > end); /* { dg-warning \"TRUE\" \"true\" } */\n+      /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+      /* TODO(xfail^^^): should report TRUE twice. */\n+\n+      __analyzer_eval (i == start); /* { dg-warning \"TRUE\" \"1st\" } */\n+      /* { dg-warning \"FALSE\" \"2nd\" { xfail *-*-* } .-1 } */\n+      /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-2 } */\n+      /* TODO(xfail^^^): ideally we ought to figure out i > 0 after 1st iteration.  */\n+\n+      /* We don't know the direction of step.  */\n+      __analyzer_eval (i <= start); /* { dg-warning \"TRUE\" \"true\" } */\n+      /* { dg-warning \"UNKNOWN\" \"unknown\" { target *-*-* } .-1 } */\n+\n+      __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n+  }\n+\n+  __analyzer_eval (i <= end); /* { dg-warning \"TRUE\" \"true\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+}"}, {"sha": "3fc1362d1cf9a5927343ebc64c2852ecc7ebc79f", "filename": "gcc/testsuite/gcc.dg/analyzer/loop-start-to-end-by-step.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-start-to-end-by-step.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-start-to-end-by-step.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-start-to-end-by-step.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,36 @@\n+#include \"analyzer-decls.h\"\n+\n+void test(int start, int end, int step)\n+{\n+  int i;\n+\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+\n+  for (i = start; i < end; i += step) {\n+      __analyzer_eval (i < end); /* { dg-warning \"TRUE\" \"true\" } */\n+      /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+      /* TODO(xfail^^^): should report TRUE twice. */\n+\n+      __analyzer_eval (i == start); /* { dg-warning \"TRUE\" \"1st\" } */\n+      /* { dg-warning \"FALSE\" \"2nd\" { xfail *-*-* } .-1 } */\n+      /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-2 } */\n+      /* TODO(xfail^^^): ideally we ought to figure out i > 0 after 1st iteration.  */\n+\n+      /* We don't know the direction of step.  */\n+      __analyzer_eval (i >= start); /* { dg-warning \"TRUE\" \"true\" } */\n+      /* { dg-warning \"UNKNOWN\" \"unknown\" { target *-*-* } .-1 } */\n+\n+      __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n+  }\n+\n+  // FIXME: do we know this?  What about direction of step?\n+  __analyzer_eval (i >= end); /* { dg-warning \"TRUE\" \"true\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+\n+  // FIXME: do we know this?  What if we overshoot?\n+  __analyzer_eval (i == end); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n+  /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-1 } */\n+  /* TODO(xfail^^^): it only figures out i >= 256, rather than i == 256.  */\n+\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+}"}, {"sha": "ca6a862092c356b72e050759aefddf92b8ae7af7", "filename": "gcc/testsuite/gcc.dg/analyzer/loop-start-up-to-end-by-1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-start-up-to-end-by-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-start-up-to-end-by-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop-start-up-to-end-by-1.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,34 @@\n+#include \"analyzer-decls.h\"\n+\n+void test(int start, int end)\n+{\n+  int i;\n+\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+\n+  for (i = start; i < end; i++) {\n+      __analyzer_eval (i < end); /* { dg-warning \"TRUE\" \"true\" } */\n+      /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+      /* TODO(xfail^^^): should report TRUE twice. */\n+\n+      __analyzer_eval (i == start); /* { dg-warning \"TRUE\" \"1st\" } */\n+      /* { dg-warning \"FALSE\" \"2nd\" { xfail *-*-* } .-1 } */\n+      /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-2 } */\n+      /* TODO(xfail^^^): ideally we ought to figure out i > 0 after 1st iteration.  */\n+\n+      __analyzer_eval (i >= start); /* { dg-warning \"TRUE\" \"true\" } */\n+      /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+      /* TODO(xfail^^^): should report TRUE twice. */\n+\n+      __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n+  }\n+\n+  __analyzer_eval (i >= end); /* { dg-warning \"TRUE\" \"true\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+\n+  __analyzer_eval (i == end); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n+  /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-1 } */\n+  /* TODO(xfail^^^): it only figures out i >= end, rather than i == end.  */\n+\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+}"}, {"sha": "c4cfd88c9122bec02d7f76b2fd666d9a4704b331", "filename": "gcc/testsuite/gcc.dg/analyzer/loop.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Floop.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -1,5 +1,3 @@\n-/* { dg-additional-options \"-fno-analyzer-state-purge\" } */\n-\n #include \"analyzer-decls.h\"\n \n void test(void)\n@@ -12,15 +10,12 @@ void test(void)\n       __analyzer_eval (i < 256); /* { dg-warning \"TRUE\" } */\n       /* (should report TRUE twice). */\n \n-      __analyzer_eval (i == 0); /* { dg-warning \"TRUE\" \"1st\" } */\n+      __analyzer_eval (i == 0); /* { dg-warning \"TRUE\" } */\n       /* { dg-warning \"FALSE\" \"2nd\" { xfail *-*-* } .-1 } */\n       /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-2 } */\n       /* TODO(xfail^^^): ideally we ought to figure out i > 0 after 1st iteration.  */\n \n-      __analyzer_eval (i >= 0); /* { dg-warning \"TRUE\" \"1st\" } */\n-      /* { dg-warning \"TRUE\" \"2nd\" { xfail *-*-* } } */\n-      /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-2 } */\n-      /* TODO(xfail^^^): ideally we ought to figure out i >= 0 for all iterations.  */\n+      __analyzer_eval (i >= 0); /* { dg-warning \"TRUE\" } */\n \n       __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n   }"}, {"sha": "c3e1330ec6a9ee708cdbf7d752b7e2376bab2b13", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-1.c", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-1.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -360,15 +360,15 @@ void test_30 (void)\n   struct link tmp;\n   tmp.m_ptr = (struct link *)malloc (sizeof (struct link)); /* { dg-message \"allocated here\" } */\n } /* { dg-warning \"leak of 'tmp.m_ptr'\" } */ \n-/* { dg-bogus \"leak of '<unknown>'\" \"\" { xfail *-*-* } .-1 } */ \n+/* { dg-bogus \"leak of '<unknown>'\" \"leak of unknown\" { target *-*-* } .-1 } */\n \n void test_31 (void)\n {\n   struct link tmp;\n   void *ptr = malloc (sizeof (struct link)); /* { dg-message \"allocated here\" } */\n   tmp.m_ptr = (struct link *)ptr;\n } /* { dg-warning \"leak of 'ptr'\" } */ \n-/* { dg-bogus \"leak of 'tmp.m_ptr'\" \"\" { xfail *-*-* } .-1 } */ \n+/* { dg-bogus \"leak of 'tmp.m_ptr'\" \"\" { target *-*-* } .-1 } */\n \n void test_32 (void)\n {\n@@ -507,8 +507,7 @@ void test_42c (void)\n   void *p = malloc (1024);\n   void *q = p + 64;\n   free (q - 64); /* this is probably OK.  */\n-} /* { dg-bogus \"leak of 'p'\" \"\" { xfail *-*-* } } */\n-// TODO(xfail)\n+} /* { dg-bogus \"leak of 'p'\" } */\n \n #if 0\n void test_31 (void *p)\n@@ -531,10 +530,8 @@ struct link global_link;\n void test_43 (void)\n {\n   global_link.m_ptr = malloc (sizeof (struct link)); /* { dg-message \"allocated here\" } */\n-  global_link.m_ptr = NULL;\n-} /* { dg-warning \"leak of '<unknown>'\" } */\n-/* TODO: should be more precise than just '<unknown>', and\n-   ideally would be at the assigment to NULL.  */\n+  global_link.m_ptr = NULL; /* { dg-warning \"leak of 'global_link.m_ptr'\" } */\n+}\n \n struct link *global_ptr;\n \n@@ -591,3 +588,16 @@ void test_48 (void)\n   int *p = NULL; /* { dg-message \"'p' is NULL\" } */\n   *p = 1; /* { dg-warning \"dereference of NULL 'p'\" } */\n }\n+\n+/* As test_48, but where the assignment of NULL is not at the start of a BB.  */\n+\n+int test_49 (int i)\n+{\n+  int *p;\n+  int x;\n+\n+  x = i * 2;\n+  p = NULL; /* { dg-message \"'p' is NULL\" } */\n+  *p = 1; /* { dg-warning \"dereference of NULL 'p'\" } */\n+  return x;\n+}"}, {"sha": "908bb28ee500c970738b14e5161c307f7b278439", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-4.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -10,11 +10,11 @@ void *hv (struct foo **tm)\n   *tm = p;\n   if (!p)\n     abort ();\n-  return p; /* { dg-warning \"leak of 'tm'\" } */\n+  return p;\n }\n \n void a5 (void)\n {\n   struct bar *qb = NULL;\n   hv (&qb);\n-} /* { dg-warning \"leak of '\\\\(struct foo \\\\*\\\\)qb'\" } */\n+} /* { dg-warning \"leak of 'qb'\" } */"}, {"sha": "a8c85a9c61885ec829e686e7879463696001e39a", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-in-loop.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-in-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-in-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-in-loop.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,19 @@\n+#include <stdlib.h>\n+#include \"analyzer-decls.h\"\n+\n+extern void foo (int *);\n+\n+void test (int n)\n+{\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+\n+  for (int i = 0; i < n; i++)\n+    {\n+      int *ptr = (int *)malloc (sizeof (int) * i);\n+      foo (ptr);\n+      free (ptr);\n+      __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n+    }\n+\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+}"}, {"sha": "cdf5ac1832454aa4567db5188d2e4118c3bfe33b", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-8-double-free.c", "status": "modified", "additions": 52, "deletions": 30, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-double-free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-double-free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-double-free.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -61,111 +61,133 @@ void test (int i)\n     |      |                    |\n     |      |                    (2) calling 'make_boxed_int' from 'test'\n     |\n-    +--> 'make_boxed_int': events 3-6\n+    +--> 'make_boxed_int': events 3-4\n            |\n            |   NN | make_boxed_int (int i)\n            |      | ^~~~~~~~~~~~~~\n            |      | |\n            |      | (3) entry to 'make_boxed_int'\n-           |......\n+           |   NN | {\n+           |   NN |   boxed_int *result = (boxed_int *)wrapped_malloc (sizeof (boxed_int));\n+           |      |                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+           |      |                                    |\n+           |      |                                    (4) calling 'wrapped_malloc' from 'make_boxed_int'\n+           |\n+           +--> 'wrapped_malloc': events 5-6\n+                  |\n+                  |   NN | void *wrapped_malloc (size_t size)\n+                  |      |       ^~~~~~~~~~~~~~\n+                  |      |       |\n+                  |      |       (5) entry to 'wrapped_malloc'\n+                  |   NN | {\n+                  |   NN |   return malloc (size);\n+                  |      |          ~~~~~~~~~~~~~\n+                  |      |          |\n+                  |      |          (6) allocated here (state of '<unknown>': 'start' -> 'unchecked', NULL origin)\n+                  |\n+           <------+\n+           |\n+         'make_boxed_int': events 7-10\n+           |\n+           |   NN |   boxed_int *result = (boxed_int *)wrapped_malloc (sizeof (boxed_int));\n+           |      |                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+           |      |                                    |\n+           |      |                                    (7) returning to 'make_boxed_int' from 'wrapped_malloc'\n            |   NN |   if (!result)\n-           |      |      ~\n+           |      |      ~                              \n            |      |      |\n-           |      |      (4) following 'false' branch (when 'result' is non-NULL)...\n+           |      |      (8) assuming 'result' is non-NULL (state of 'result': 'unchecked' -> 'nonnull', NULL origin)\n+           |      |      (9) following 'false' branch (when 'result' is non-NULL)...\n            |   NN |     abort ();\n            |   NN |   result->i = i;\n-           |      |   ~~~~~~~~~~~~~\n+           |      |   ~~~~~~~~~~~~~                     \n            |      |             |\n-           |      |             (5) ...to here\n-           |   NN |   return result;\n-           |      |          ~~~~~~\n-           |      |          |\n-           |      |          (6) state of '<return-value>': 'start' -> 'nonnull' (origin: NULL)\n+           |      |             (10) ...to here\n            |\n     <------+\n     |\n-  'test': events 7-8\n+  'test': events 11-12\n     |\n     |   NN |   boxed_int *obj = make_boxed_int (i);\n     |      |                    ^~~~~~~~~~~~~~~~~~\n     |      |                    |\n-    |      |                    (7) returning to 'test' from 'make_boxed_int'\n+    |      |                    (11) returning to 'test' from 'make_boxed_int'\n     |   NN | \n     |   NN |   free_boxed_int (obj);\n     |      |   ~~~~~~~~~~~~~~~~~~~~\n     |      |   |\n-    |      |   (8) calling 'free_boxed_int' from 'test'\n+    |      |   (12) calling 'free_boxed_int' from 'test'\n     |\n-    +--> 'free_boxed_int': events 9-10\n+    +--> 'free_boxed_int': events 13-14\n            |\n            |   NN | free_boxed_int (boxed_int *bi)\n            |      | ^~~~~~~~~~~~~~\n            |      | |\n-           |      | (9) entry to 'free_boxed_int'\n+           |      | (13) entry to 'free_boxed_int'\n            |   NN | {\n            |   NN |   wrapped_free (bi);\n            |      |   ~~~~~~~~~~~~~~~~~\n            |      |   |\n-           |      |   (10) calling 'wrapped_free' from 'free_boxed_int'\n+           |      |   (14) calling 'wrapped_free' from 'free_boxed_int'\n            |\n-           +--> 'wrapped_free': events 11-12\n+           +--> 'wrapped_free': events 15-16\n                   |\n                   |   NN | void wrapped_free (void *ptr)\n                   |      |      ^~~~~~~~~~~~\n                   |      |      |\n-                  |      |      (11) entry to 'wrapped_free'\n+                  |      |      (15) entry to 'wrapped_free'\n                   |   NN | {\n                   |   NN |   free (ptr);\n                   |      |   ~~~~~~~~~~\n                   |      |   |\n-                  |      |   (12) first 'free' here (state of 'ptr': 'nonnull' -> 'freed', origin: NULL)\n+                  |      |   (16) first 'free' here (state of 'ptr': 'nonnull' -> 'freed', NULL origin)\n                   |\n            <------+\n            |\n-         'free_boxed_int': event 13\n+         'free_boxed_int': event 17\n            |\n            |   NN |   wrapped_free (bi);\n            |      |   ^~~~~~~~~~~~~~~~~\n            |      |   |\n-           |      |   (13) returning to 'free_boxed_int' from 'wrapped_free'\n+           |      |   (17) returning to 'free_boxed_int' from 'wrapped_free'\n            |\n     <------+\n     |\n-  'test': events 14-15\n+  'test': events 18-19\n     |\n     |   NN |   free_boxed_int (obj);\n     |      |   ^~~~~~~~~~~~~~~~~~~~\n     |      |   |\n-    |      |   (14) returning to 'test' from 'free_boxed_int'\n+    |      |   (18) returning to 'test' from 'free_boxed_int'\n     |   NN | \n     |   NN |   free_boxed_int (obj);\n     |      |   ~~~~~~~~~~~~~~~~~~~~\n     |      |   |\n-    |      |   (15) passing freed pointer 'obj' in call to 'free_boxed_int' from 'test'\n+    |      |   (19) passing freed pointer 'obj' in call to 'free_boxed_int' from 'test'\n     |\n-    +--> 'free_boxed_int': events 16-17\n+    +--> 'free_boxed_int': events 20-21\n            |\n            |   NN | free_boxed_int (boxed_int *bi)\n            |      | ^~~~~~~~~~~~~~\n            |      | |\n-           |      | (16) entry to 'free_boxed_int'\n+           |      | (20) entry to 'free_boxed_int'\n            |   NN | {\n            |   NN |   wrapped_free (bi);\n            |      |   ~~~~~~~~~~~~~~~~~\n            |      |   |\n-           |      |   (17) passing freed pointer 'bi' in call to 'wrapped_free' from 'free_boxed_int'\n+           |      |   (21) passing freed pointer 'bi' in call to 'wrapped_free' from 'free_boxed_int'\n            |\n-           +--> 'wrapped_free': events 18-19\n+           +--> 'wrapped_free': events 22-23\n                   |\n                   |   NN | void wrapped_free (void *ptr)\n                   |      |      ^~~~~~~~~~~~\n                   |      |      |\n-                  |      |      (18) entry to 'wrapped_free'\n+                  |      |      (22) entry to 'wrapped_free'\n                   |   NN | {\n                   |   NN |   free (ptr);\n                   |      |   ~~~~~~~~~~\n                   |      |   |\n-                  |      |   (19) second 'free' here; first 'free' was at (12) ('ptr' is in state 'freed')\n+                  |      |   (23) second 'free' here; first 'free' was at (16) ('ptr' is in state 'freed')\n                   |\n    { dg-end-multiline-output \"\" } */\n "}, {"sha": "320044753a183e94b46f4d7ad4998a83cc9336bc", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-8-unchecked.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-unchecked.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-unchecked.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-8-unchecked.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -1,6 +1,6 @@\n /* Example of a multilevel wrapper around malloc, with an unchecked write.  */\n \n-/* { dg-additional-options \"-fdiagnostics-show-line-numbers -fdiagnostics-path-format=inline-events -fanalyzer-checker=malloc -fdiagnostics-show-caret -fanalyzer-verbose-state-changes\" } */\n+/* { dg-additional-options \"-fdiagnostics-show-line-numbers -fdiagnostics-path-format=inline-events -fanalyzer-checker=malloc -fdiagnostics-show-caret\" } */\n /* { dg-enable-nn-line-numbers \"\" } */\n \n #include <stdlib.h>\n@@ -49,7 +49,7 @@ make_boxed_int (int i)\n            |   NN |   return malloc (size);\n            |      |          ~~~~~~~~~~~~~\n            |      |          |\n-           |      |          (4) this call could return NULL (state of '<return-value>': 'start' -> 'unchecked', origin: NULL)\n+           |      |          (4) this call could return NULL\n            |\n     <------+\n     |\n@@ -62,6 +62,6 @@ make_boxed_int (int i)\n     |   NN |   result->i = i;\n     |      |   ~~~~~~~~~~~~~                     \n     |      |             |\n-    |      |             (6) 'result' could be NULL: unchecked value from (4) ('result' is in state 'unchecked')\n+    |      |             (6) 'result' could be NULL: unchecked value from (4)\n     |\n   { dg-end-multiline-output \"\" } */"}, {"sha": "a3cacc07fab5e9a607bab3c358f4bc26ea17ffbd", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-paths-9.c", "status": "modified", "additions": 1, "deletions": 58, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-paths-9.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -112,8 +112,7 @@ int test_3 (int x, int y)\n     free (ptr); /* No double-'free' warning: we've already attempted\n \t\t   to dereference it above.  */\n   return *ptr; /* { dg-warning \"use after 'free' of 'ptr'\" \"use-after-free\" } */\n-  // TODO: two warnings here:  one is from sm-malloc, the other from region model\n-  /* { dg-warning \"leak of 'ptr'\" \"leak\" { target *-*-* } .-2 } */\n+  /* { dg-warning \"leak of 'ptr'\" \"leak\" { target *-*-* } .-1 } */\n }\n \n /* \"dereference of possibly-NULL 'ptr'\".  */\n@@ -241,59 +240,3 @@ int test_3 (int x, int y)\n     |      |          (7) 'ptr' leaks here; was allocated at (1)\n     |\n    { dg-end-multiline-output \"\" } */\n-\n-/* \"use after 'free' of 'ptr'\".  */\n-/* { dg-begin-multiline-output \"\" }\n-   NN |   *ptr = 19;\n-      |   ~~~~~^~~~\n-  'test_3': events 1-3\n-    |\n-    |   NN |   if (x)\n-    |      |      ^\n-    |      |      |\n-    |      |      (1) following 'true' branch (when 'x != 0')...\n-    |   NN |     free (ptr);\n-    |      |     ~~~~~~~~~~\n-    |      |     |\n-    |      |     (2) ...to here\n-    |   NN | \n-    |   NN |   *ptr = 19;\n-    |      |   ~~~~~~~~~\n-    |      |        |\n-    |      |        (3) use after 'free' of 'ptr' here\n-    |\n-   { dg-end-multiline-output \"\" } */\n-\n-/* \"use after 'free' of 'ptr'\".  */\n-/* { dg-begin-multiline-output \"\" }\n-   NN |   return *ptr;\n-      |          ^~~~\n-  'test_3': events 1-5\n-    |\n-    |   NN |   if (x)\n-    |      |      ^\n-    |      |      |\n-    |      |      (1) following 'false' branch (when 'x == 0')...\n-    |......\n-    |   NN |   *ptr = 19;\n-    |      |   ~~~~~~~~~\n-    |      |        |\n-    |      |        (2) ...to here\n-    |......\n-    |   NN |   if (y)\n-    |      |      ~\n-    |      |      |\n-    |      |      (3) following 'true' branch (when 'y != 0')...\n-    |   NN |     free (ptr);\n-    |      |     ~~~~~~~~~~\n-    |      |     |\n-    |      |     (4) ...to here\n-    |   NN |                    to dereference it above\n-    |   NN |   return *ptr;\n-    |      |          ~~~~\n-    |      |          |\n-    |      |          (5) use after 'free' of 'ptr' here\n-    |\n-   { dg-end-multiline-output \"\" } */\n-/* TODO: this is really a duplicate; can we either eliminate it, or\n-   improve the path?  */"}, {"sha": "4e70694a33df1ff0d81f5781c09b89255bb1b324", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-vs-local-1a.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-1a.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -11,7 +11,7 @@ do_stuff (int *p, int n)\n   int sum = 0;\n   int i;\n   for (i = 0; i < n; i++)\n-    p[i] = i;\n+    p[i] = i; /* { dg-warning \"dereference of possibly-NULL 'p'\" } */\n   for (i = 0; i < n; i++)\n     sum += foo (p[i]); /* { dg-bogus \"uninitialized\" } */\n   return sum;\n@@ -48,10 +48,10 @@ int test_repeated_predicate_1 (int n)\n \n   result = do_stuff (ptr, n);\n \n-  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"3 processed enodes\" } */\n-  // FIXME: why 3 here?\n-  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"3 processed enodes\" } */\n-  // FIXME: why 3 here?\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"5 processed enodes\" } */\n+  // FIXME: why 5 here?\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"5 processed enodes\" } */\n+  // FIXME: why 5 here?\n \n   if (n > 10)\n     free (ptr); /* { dg-bogus \"not on the heap\" } */\n@@ -105,8 +105,8 @@ int test_explicit_flag (int n)\n \n   result = do_stuff (ptr, n);\n \n-  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"3 processed enodes\" } */\n-  // FIXME: why 3 here?\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"5 processed enodes\" } */\n+  // FIXME: why 5 here?\n \n   if (need_to_free)\n     free (ptr); /* { dg-bogus \"not on the heap\" } */\n@@ -131,8 +131,8 @@ int test_pointer_comparison (int n)\n \n   result = do_stuff (ptr, n);\n \n-  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"3 processed enodes\" } */\n-  // FIXME: why 3 here?\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"5 processed enodes\" } */\n+  // FIXME: why 5 here?\n \n   if (ptr != buf)\n     free (ptr); /* { dg-bogus \"not on the heap\" } */\n@@ -169,8 +169,8 @@ int test_initial_flag (int n)\n \n   result = do_stuff (ptr, n);\n \n-  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"5 processed enodes\" } */\n-  // FIXME: why 5 here?\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"6 processed enodes\" } */\n+  // FIXME: why 6 here?\n \n   if (n > 10)\n     free (ptr); /* { dg-bogus \"not on the heap\" } */"}, {"sha": "9001fe66cd78a8ab024595938191db4e66c0a8c9", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-vs-local-2.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-2.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -31,13 +31,13 @@ int test_repeated_predicate_1 (int n)\n     int sum = 0;\n     int i;\n     for (i = 0; i < n; i++)\n-      p[i] = i;\n+      p[i] = i; /* { dg-warning \"dereference of possibly-NULL\" } */\n     for (i = 0; i < n; i++)\n       sum += foo (p[i]); /* { dg-bogus \"uninitialized\" } */\n     result = sum;\n   }\n \n-  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"3 processed enodes\" } */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n \n   if (n > 10)\n     free (ptr); /* { dg-bogus \"not on the heap\" } */\n@@ -65,11 +65,11 @@ int test_repeated_predicate_1a (int n)\n     int sum = 0;\n     int i;\n     for (i = 0; i < n; i++)\n-      p[i] = i;\n+      p[i] = i; /* { dg-warning \"dereference of possibly-NULL\" } */\n     result = sum;\n   }\n \n-  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"3 processed enodes\" } */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n \n   if (n > 10)\n     free (ptr); /* { dg-bogus \"not on the heap\" } */\n@@ -126,13 +126,13 @@ int test_explicit_flag (int n)\n     int sum = 0;\n     int i;\n     for (i = 0; i < n; i++)\n-      p[i] = i;\n+      p[i] = i; /* { dg-warning \"dereference of possibly-NULL\" } */\n     for (i = 0; i < n; i++)\n       sum += foo (p[i]); /* { dg-bogus \"uninitialized\" } */\n     result = sum;\n   }\n \n-  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"3 processed enodes\" } */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n \n   if (need_to_free)\n     free (ptr); /* { dg-bogus \"not on the heap\" } */\n@@ -160,13 +160,13 @@ int test_pointer_comparison (int n)\n     int sum = 0;\n     int i;\n     for (i = 0; i < n; i++)\n-      p[i] = i;\n+      p[i] = i; /* { dg-warning \"dereference of possibly-NULL\" } */\n     for (i = 0; i < n; i++)\n       sum += foo (p[i]); /* { dg-bogus \"uninitialized\" } */\n     result = sum;\n   }\n \n-  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"3 processed enodes\" } */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n \n   if (ptr != buf)\n     free (ptr); /* { dg-bogus \"not on the heap\" } */"}, {"sha": "0196389d3a59a7d5b4f46fe8f14894648115a05e", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-vs-local-3.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-vs-local-3.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -30,16 +30,15 @@ int test_1 (int n)\n     int sum = 0;\n     int i;\n     for (i = 0; i < n; i++)\n-      p[i] = i;\n+      p[i] = i; /* { dg-warning \"dereference of possibly-NULL\" } */\n     for (i = 0; i < n; i++)\n       sum += foo (p[i]); /* { dg-bogus \"uninitialized\" } */\n     result = sum;\n   }\n \n-  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"3 processed enodes\" } */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n \n-  return result; /* { dg-message \"leak of 'p'\" } */\n-  /* FIXME: should this be 'ptr'?  */\n+  return result; /* { dg-message \"leak of 'p'|leak of 'ptr'\" } */\n }\n \n /* A simpler version of the above.  */"}, {"sha": "830c1105f466012bcebab29d1c9eeb892724609c", "filename": "gcc/testsuite/gcc.dg/analyzer/memset-1.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmemset-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmemset-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmemset-1.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,100 @@\n+#include <string.h>\n+#include \"analyzer-decls.h\"\n+\n+/* Zero-fill of uninitialized buffer.  */\n+\n+void test_1 (void)\n+{\n+  char buf[256];\n+  memset (buf, 0, 256);\n+  __analyzer_eval (buf[42] == 0); /* { dg-warning \"TRUE\" } */\n+}\n+\n+/* As above, but with __builtin_memset.  */\n+\n+void test_1a (void)\n+{\n+  char buf[256];\n+  __builtin_memset (buf, 0, 256);\n+  __analyzer_eval (buf[42] == 0); /* { dg-warning \"TRUE\" } */\n+}\n+\n+/* Zero-fill of partially initialized buffer.  */\n+\n+void test_2 (void)\n+{\n+  char buf[256];\n+  buf[42] = 'A';\n+  __analyzer_eval (buf[42] == 'A'); /* { dg-warning \"TRUE\" } */\n+  memset (buf, 0, 256);\n+  __analyzer_eval (buf[42] == '\\0'); /* { dg-warning \"TRUE\" } */\n+}\n+\n+/* A \"memset\" with known non-zero value.  */\n+\n+void test_3 (int val)\n+{\n+  char buf[256];\n+  memset (buf, 'A', 256);\n+  /* We currently merely mark such regions as \"unknown\", so querying\n+     values within them yields UNKNOWN when ideally it would be TRUE.  */\n+  __analyzer_eval (buf[42] == 'A'); /* { dg-warning \"TRUE\" \"known nonzero\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"status quo\" { xfail *-*-* } .-1 } */\n+}\n+\n+/* A \"memset\" with unknown value.  */\n+\n+void test_4 (int val)\n+{\n+  char buf[256];\n+  memset (buf, val, 256);\n+  /* We currently merely mark such regions as \"unknown\", so querying\n+     values within them yields UNKNOWN when ideally it would be TRUE.  */\n+  __analyzer_eval (buf[42] == (char)val); /* { dg-warning \"TRUE\" \"known nonzero\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"status quo\" { xfail *-*-* } .-1 } */\n+}\n+\n+/* A \"memset\" with unknown num bytes.  */\n+\n+void test_5 (int n)\n+{\n+  char buf[256];\n+  buf[42] = 'A';\n+  __analyzer_eval (buf[42] == 'A'); /* { dg-warning \"TRUE\" } */\n+  memset (buf, 0, n);\n+\n+  /* We can't know if buf[42] was written to or not.  */\n+  __analyzer_eval (buf[42] == 'A'); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (buf[42] == '\\0'); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+/* A \"memset\" with unknown value, but with zero size.  */\n+\n+static size_t __attribute__((noinline))\n+get_zero (void)\n+{\n+  return 0;\n+}\n+\n+void test_6 (int val)\n+{\n+  char buf[256];\n+  buf[42] = 'A';\n+  memset (buf, 'B', get_zero ());\n+  __analyzer_eval (buf[42] == 'A'); /* { dg-warning \"TRUE\" } */  \n+}\n+\n+/* A \"memset\" of known size that's not the full buffer.  */\n+\n+void test_7 (void)\n+{\n+  char buf[256];\n+  buf[128] = 'A';\n+  memset (buf, 0, 128);\n+  /* We currently merely mark the whole region as \"unknown\", so querying\n+     values within them yields UNKNOWN.  */\n+  __analyzer_eval (buf[127] == '\\0'); /* { dg-warning \"TRUE\" \"known nonzero\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"status quo\" { xfail *-*-* } .-1 } */\n+  __analyzer_eval (buf[128] == 'A'); /* { dg-warning \"TRUE\" \"known nonzero\" { xfail *-*-* } } */\n+  /* { dg-bogus \"UNKNOWN\" \"status quo\" { xfail *-*-* } .-1 } */\n+}"}, {"sha": "b5ab810e5363d4ebf09b62f7e018eb0d05b10939", "filename": "gcc/testsuite/gcc.dg/analyzer/paths-3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-3.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -13,7 +13,7 @@ int test_1 (int a, int b)\n     else\n       p = malloc (32);\n \n-  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"3 processed enodes\" } */\n \n   if (a > 5)\n     {\n@@ -34,7 +34,7 @@ int test_2 (int a, int b)\n     else\n       p = malloc (32);\n \n-  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"3 processed enodes\" } */\n \n   if (a > 6) /* different condition */\n     {"}, {"sha": "b72e658739e148dea3ec05351b9aecbc8d4a5a55", "filename": "gcc/testsuite/gcc.dg/analyzer/paths-4.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-4.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -13,8 +13,8 @@ int test_1 (struct state *s)\n   __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n   while (1)\n     {\n-      __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n-      __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+      __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enode\" } */\n+      __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enode\" } */\n       /* TODO: why does the above need an extra stmt to merge state?  */\n       do_stuff (s, s->mode);\n     }\n@@ -25,13 +25,13 @@ int test_2 (struct state *s)\n   __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n   while (1)\n     {\n-      __analyzer_dump_exploded_nodes (0); /* { dg-warning \"3 processed enodes\" } */\n-      __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+      __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enode\" } */\n+      __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enode\" } */\n       /* TODO: why does the above need an extra stmt to merge state?  */\n       switch (s->mode)\n \t{\n \tcase 0:\n-\t  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+\t  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enode\" } */\n \t  do_stuff (s, 0);\n \t  break;\n \tcase 1:"}, {"sha": "ef1a4e6c04d1c29def3c7e10c094441d21d23d8d", "filename": "gcc/testsuite/gcc.dg/analyzer/paths-6.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-6.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -89,7 +89,7 @@ void test_3 (int i)\n       break;\n     }\n \n-  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enode\" } */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n   __analyzer_eval (f == 3); /* { dg-warning \"TRUE\" } */\n   __analyzer_eval (g == 4); /* { dg-warning \"TRUE\" } */\n   __analyzer_eval (h == 5); /* { dg-warning \"TRUE\" } */\n@@ -108,7 +108,7 @@ void test_4 (int flag)\n       q = malloc (256);\n       p = malloc (256);\n     }\n-  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enode\" } */\n   free (p);\n   free (q);\n }"}, {"sha": "8caaee8a3fd09976692dbc2351bf7baf713d0cc1", "filename": "gcc/testsuite/gcc.dg/analyzer/paths-7.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpaths-7.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -50,8 +50,7 @@ int test_2 (int flag, int *p, int n)\n     sum += foo (p[i]); /* { dg-bogus \"uninitialized\" } */\n   result = sum;\n \n-  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"5 processed enodes\" } */\n-  // FIXME: why 5 here?\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n \n   free (ptr); /* { dg-warning \"double-'free' of 'ptr'\" } */\n   return result;"}, {"sha": "4a08f0f1f50fb778236ae3940fc26fd4b0b9748f", "filename": "gcc/testsuite/gcc.dg/analyzer/pr93032-mztools-simplified.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93032-mztools-simplified.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93032-mztools-simplified.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93032-mztools-simplified.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do \"compile\" } */\n+\n+/* Minimal replacement of system headers.  */\n+#define NULL ((void *) 0)\n+typedef struct _IO_FILE FILE;\n+extern FILE *fopen(const char *__restrict __filename,\n+\t\t   const char *__restrict __modes);\n+extern int fclose (FILE *__stream);\n+\n+extern void unzRepair(const char* file, const char* fileOut, const char* fileOutTmp)\n+{\n+  FILE* fpZip = fopen(file, \"rb\");\n+  FILE* fpOut = fopen(fileOut, \"wb\");\n+  FILE* fpOutCD = fopen(fileOutTmp, \"wb\");\n+  if (fpZip != NULL && fpOut != NULL) {\n+    fclose(fpOutCD);\n+    fclose(fpZip);\n+    fclose(fpOut);\n+  }\n+} /* { dg-warning \"leak of FILE 'fpZip'\" \"leak of fpZip\" } */\n+  /* { dg-warning \"leak of FILE 'fpOut'\" \"leak of fpOut\" { target *-*-* } .-1 } */\n+  /* { dg-warning \"leak of FILE 'fpOutCD'\" \"leak of fpOutCD\" { target *-*-* } .-2 } */"}, {"sha": "88ab5bf8c1808d15f8b3d5e43014efd17490231a", "filename": "gcc/testsuite/gcc.dg/analyzer/pr93032-mztools.c", "status": "added", "additions": 331, "deletions": 0, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93032-mztools.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93032-mztools.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93032-mztools.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,331 @@\n+/* Integration test to ensure we issue FILE * leak diagnostics for\n+   this particular non-trivial case.\n+   Adapted from zlib/contrib/minizip/mztools.c, with all #includes\n+   removed.  */\n+\n+/* { dg-do \"compile\" } */\n+\n+/* Minimal replacement of system headers.  */\n+\n+typedef __SIZE_TYPE__ size_t;\n+#define NULL ((void *) 0)\n+\n+typedef struct _IO_FILE FILE;\n+extern FILE *fopen(const char *__restrict __filename,\n+\t\t   const char *__restrict __modes);\n+extern size_t fread (void *__restrict __ptr, size_t __size,\n+\t\t     size_t __n, FILE *__restrict __stream);\n+extern size_t fwrite (const void *__restrict __ptr, size_t __size,\n+\t\t      size_t __n, FILE *__restrict __s);\n+extern int fclose (FILE *__stream);\n+extern int remove (const char *__filename)\n+  __attribute__ ((__nothrow__ , __leaf__));\n+\n+extern void *malloc (size_t __size)\n+  __attribute__ ((__nothrow__ , __leaf__))\n+  __attribute__ ((__malloc__));\n+extern void free (void *__ptr)\n+  __attribute__ ((__nothrow__ , __leaf__));\n+\n+extern size_t strlen (const char *__s)\n+  __attribute__ ((__nothrow__ , __leaf__))\n+  __attribute__ ((__pure__))\n+  __attribute__ ((__nonnull__ (1)));\n+\n+/* Minimal replacement of zlib headers.  */\n+\n+#define ZEXPORT\n+typedef unsigned long  uLong; /* 32 bits or more */\n+#define Z_OK            0\n+#define Z_ERRNO        (-1)\n+#define Z_STREAM_ERROR (-2)\n+#define Z_MEM_ERROR    (-4)\n+\n+/*\n+  Additional tools for Minizip\n+  Code: Xavier Roche '2004\n+  License: Same as ZLIB (www.gzip.org)\n+*/\n+\n+/* Code */\n+\n+#define READ_8(adr)  ((unsigned char)*(adr))\n+#define READ_16(adr) ( READ_8(adr) | (READ_8(adr+1) << 8) )\n+#define READ_32(adr) ( READ_16(adr) | (READ_16((adr)+2) << 16) )\n+\n+#define WRITE_8(buff, n) do { \\\n+  *((unsigned char*)(buff)) = (unsigned char) ((n) & 0xff); \\\n+} while(0)\n+#define WRITE_16(buff, n) do { \\\n+  WRITE_8((unsigned char*)(buff), n); \\\n+  WRITE_8(((unsigned char*)(buff)) + 1, (n) >> 8); \\\n+} while(0)\n+#define WRITE_32(buff, n) do { \\\n+  WRITE_16((unsigned char*)(buff), (n) & 0xffff); \\\n+  WRITE_16((unsigned char*)(buff) + 2, (n) >> 16); \\\n+} while(0)\n+\n+extern int ZEXPORT unzRepair(file, fileOut, fileOutTmp, nRecovered, bytesRecovered)\n+const char* file;\n+const char* fileOut;\n+const char* fileOutTmp;\n+uLong* nRecovered;\n+uLong* bytesRecovered;\n+{\n+  int err = Z_OK;\n+  FILE* fpZip = fopen(file, \"rb\");\n+  FILE* fpOut = fopen(fileOut, \"wb\");\n+  FILE* fpOutCD = fopen(fileOutTmp, \"wb\");\n+  if (fpZip != NULL && fpOut != NULL) {\n+    int entries = 0;\n+    uLong totalBytes = 0;\n+    char header[30];\n+    char filename[1024];\n+    char extra[1024];\n+    int offset = 0;\n+    int offsetCD = 0;\n+    while ( fread(header, 1, 30, fpZip) == 30 ) {\n+      int currentOffset = offset;\n+\n+      /* File entry */\n+      if (READ_32(header) == 0x04034b50) {\n+        unsigned int version = READ_16(header + 4);\n+        unsigned int gpflag = READ_16(header + 6);\n+        unsigned int method = READ_16(header + 8);\n+        unsigned int filetime = READ_16(header + 10);\n+        unsigned int filedate = READ_16(header + 12);\n+        unsigned int crc = READ_32(header + 14); /* crc */\n+        unsigned int cpsize = READ_32(header + 18); /* compressed size */\n+        unsigned int uncpsize = READ_32(header + 22); /* uncompressed sz */\n+        unsigned int fnsize = READ_16(header + 26); /* file name length */\n+        unsigned int extsize = READ_16(header + 28); /* extra field length */\n+        filename[0] = extra[0] = '\\0';\n+\n+        /* Header */\n+        if (fwrite(header, 1, 30, fpOut) == 30) {\n+          offset += 30;\n+        } else {\n+          err = Z_ERRNO;\n+          break;\n+        }\n+\n+        /* Filename */\n+        if (fnsize > 0) {\n+          if (fnsize < sizeof(filename)) {\n+            if (fread(filename, 1, fnsize, fpZip) == fnsize) {\n+                if (fwrite(filename, 1, fnsize, fpOut) == fnsize) {\n+                offset += fnsize;\n+              } else {\n+                err = Z_ERRNO;\n+                break;\n+              }\n+            } else {\n+              err = Z_ERRNO;\n+              break;\n+            }\n+          } else {\n+            err = Z_ERRNO;\n+            break;\n+          }\n+        } else {\n+          err = Z_STREAM_ERROR;\n+          break;\n+        }\n+\n+        /* Extra field */\n+        if (extsize > 0) {\n+          if (extsize < sizeof(extra)) {\n+            if (fread(extra, 1, extsize, fpZip) == extsize) {\n+              if (fwrite(extra, 1, extsize, fpOut) == extsize) {\n+                offset += extsize;\n+                } else {\n+                err = Z_ERRNO;\n+                break;\n+              }\n+            } else {\n+              err = Z_ERRNO;\n+              break;\n+            }\n+          } else {\n+            err = Z_ERRNO;\n+            break;\n+          }\n+        }\n+\n+        /* Data */\n+        {\n+          int dataSize = cpsize;\n+          if (dataSize == 0) {\n+            dataSize = uncpsize;\n+          }\n+          if (dataSize > 0) {\n+            char* data = malloc(dataSize);\n+            if (data != NULL) {\n+              if ((int)fread(data, 1, dataSize, fpZip) == dataSize) {\n+                if ((int)fwrite(data, 1, dataSize, fpOut) == dataSize) {\n+                  offset += dataSize;\n+                  totalBytes += dataSize;\n+                } else {\n+                  err = Z_ERRNO;\n+                }\n+              } else {\n+                err = Z_ERRNO;\n+              }\n+              free(data);\n+              if (err != Z_OK) {\n+                break;\n+              }\n+            } else {\n+              err = Z_MEM_ERROR;\n+              break;\n+            }\n+          }\n+        }\n+\n+        /* Central directory entry */\n+        {\n+          char header[46];\n+          char* comment = \"\";\n+          int comsize = (int) strlen(comment);\n+          WRITE_32(header, 0x02014b50);\n+          WRITE_16(header + 4, version);\n+          WRITE_16(header + 6, version);\n+          WRITE_16(header + 8, gpflag);\n+          WRITE_16(header + 10, method);\n+          WRITE_16(header + 12, filetime);\n+          WRITE_16(header + 14, filedate);\n+          WRITE_32(header + 16, crc);\n+          WRITE_32(header + 20, cpsize);\n+          WRITE_32(header + 24, uncpsize);\n+          WRITE_16(header + 28, fnsize);\n+          WRITE_16(header + 30, extsize);\n+          WRITE_16(header + 32, comsize);\n+          WRITE_16(header + 34, 0);     /* disk # */\n+          WRITE_16(header + 36, 0);     /* int attrb */\n+          WRITE_32(header + 38, 0);     /* ext attrb */\n+          WRITE_32(header + 42, currentOffset);\n+          /* Header */\n+          if (fwrite(header, 1, 46, fpOutCD) == 46) {\n+            offsetCD += 46;\n+\n+            /* Filename */\n+            if (fnsize > 0) {\n+              if (fwrite(filename, 1, fnsize, fpOutCD) == fnsize) {\n+                offsetCD += fnsize;\n+              } else {\n+                err = Z_ERRNO;\n+                break;\n+              }\n+            } else {\n+              err = Z_STREAM_ERROR;\n+              break;\n+            }\n+\n+            /* Extra field */\n+            if (extsize > 0) {\n+              if (fwrite(extra, 1, extsize, fpOutCD) == extsize) {\n+                offsetCD += extsize;\n+              } else {\n+                err = Z_ERRNO;\n+                break;\n+              }\n+            }\n+\n+            /* Comment field */\n+            if (comsize > 0) {\n+              if ((int)fwrite(comment, 1, comsize, fpOutCD) == comsize) {\n+                offsetCD += comsize;\n+              } else {\n+                err = Z_ERRNO;\n+                break;\n+              }\n+            }\n+\n+\n+          } else {\n+            err = Z_ERRNO;\n+            break;\n+          }\n+        }\n+\n+        /* Success */\n+        entries++;\n+\n+      } else {\n+        break;\n+      }\n+    }\n+\n+    /* Final central directory  */\n+    {\n+      int entriesZip = entries;\n+      char header[22];\n+      char* comment = \"\"; // \"ZIP File recovered by zlib/minizip/mztools\";\n+      int comsize = (int) strlen(comment);\n+      if (entriesZip > 0xffff) {\n+        entriesZip = 0xffff;\n+      }\n+      WRITE_32(header, 0x06054b50);\n+      WRITE_16(header + 4, 0);    /* disk # */\n+      WRITE_16(header + 6, 0);    /* disk # */\n+      WRITE_16(header + 8, entriesZip);   /* hack */\n+      WRITE_16(header + 10, entriesZip);  /* hack */\n+      WRITE_32(header + 12, offsetCD);    /* size of CD */\n+      WRITE_32(header + 16, offset);      /* offset to CD */\n+      WRITE_16(header + 20, comsize);     /* comment */\n+\n+      /* Header */\n+      if (fwrite(header, 1, 22, fpOutCD) == 22) {\n+\n+        /* Comment field */\n+        if (comsize > 0) {\n+          if ((int)fwrite(comment, 1, comsize, fpOutCD) != comsize) {\n+            err = Z_ERRNO;\n+          }\n+        }\n+\n+      } else {\n+        err = Z_ERRNO;\n+      }\n+    }\n+\n+    /* Final merge (file + central directory) */\n+    fclose(fpOutCD);\n+    if (err == Z_OK) {\n+      fpOutCD = fopen(fileOutTmp, \"rb\");\n+      if (fpOutCD != NULL) {\n+        int nRead;\n+        char buffer[8192];\n+        while ( (nRead = (int)fread(buffer, 1, sizeof(buffer), fpOutCD)) > 0) {\n+          if ((int)fwrite(buffer, 1, nRead, fpOut) != nRead) {\n+            err = Z_ERRNO;\n+            break;\n+          }\n+        }\n+        fclose(fpOutCD);\n+      }\n+    }\n+\n+    /* Close */\n+    fclose(fpZip);\n+    fclose(fpOut);\n+\n+    /* Wipe temporary file */\n+    (void)remove(fileOutTmp);\n+\n+    /* Number of recovered entries */\n+    if (err == Z_OK) {\n+      if (nRecovered != NULL) {\n+        *nRecovered = entries;\n+      }\n+      if (bytesRecovered != NULL) {\n+        *bytesRecovered = totalBytes;\n+      }\n+    }\n+  } else {\n+    err = Z_STREAM_ERROR;\n+  }\n+  return err; /* { dg-warning \"leak of FILE 'fpZip'\" \"leak of fpZip\" } */\n+  /* { dg-warning \"leak of FILE 'fpOut'\" \"leak of fpOut\" { target *-*-* } .-1 } */\n+  /* { dg-warning \"leak of FILE 'fpOutCD'\" \"leak of fpOutCD\" { target *-*-* } .-2 } */\n+}"}, {"sha": "210b97d1a471b84018a2986d976f041d4dc4c7e7", "filename": "gcc/testsuite/gcc.dg/analyzer/pr93382.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93382.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93382.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93382.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -13,8 +13,8 @@ ql (void)\n {\n   int n1[1];\n \n-  fread (n1, sizeof (n1[0]), 1, fp); /* { dg-message \"'n1' gets an unchecked value here\" } */\n-  idx = n1[0]; /* { dg-message \"'idx' has an unchecked value here \\\\\\(from 'n1'\\\\\\)\" } */\n+  fread (n1, sizeof (n1[0]), 1, fp); /* { dg-message \"'n1' gets an unchecked value here\" \"\" { xfail *-*-* } } */\n+  idx = n1[0]; /* { dg-message \"'idx' has an unchecked value here \\\\\\(from 'n1'\\\\\\)\" \"\" { xfail *-*-* } } */\n }\n \n int arr[10];\n@@ -23,5 +23,5 @@ int\n pl (void)\n {\n   ql ();\n-  return arr[idx]; /* { dg-warning \"use of tainted value 'idx' in array lookup without bounds checking\" } */\n+  return arr[idx]; /* { dg-warning \"use of tainted value 'idx' in array lookup without bounds checking\" \"\" { xfail *-*-* } } */\n }"}, {"sha": "81d9983083fd14d768868340a81107637f150350", "filename": "gcc/testsuite/gcc.dg/analyzer/pr93938.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93938.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93938.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93938.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,13 @@\n+/* Taken from gcc.dg/pr70022.c, adding -O1 to the options\n+   (and -fanalyzer, implicitly).  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-w -Wno-psabi -O1\" } */\n+\n+typedef int v4si __attribute__ ((vector_size (16)));\n+\n+int\n+foo (v4si v)\n+{\n+  return v[~0UL];\n+}"}, {"sha": "1d7a5d771d6223291452e69bc31a2429fd20ef26", "filename": "gcc/testsuite/gcc.dg/analyzer/pr94099.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94099.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94099.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94099.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -21,7 +21,8 @@ pl (void)\n   for (sc = 0; sc < 1; ++sc)\n     {\n       th.gk.hk = 0;\n-      th.gk.bg[sc] = 0; /* { dg-warning \"uninitialized\" \"uninit-warning-removed\" { xfail *-*-* } } */\n+      th.gk.bg[sc] = 0; /* { dg-warning \"dereference of NULL '0'\" } */\n+      // TODO: above message could be improved\n       l3 (&th);\n     }\n }"}, {"sha": "e897c04a007ef9935ac5717ac1d14e6cbfe9812a", "filename": "gcc/testsuite/gcc.dg/analyzer/pr94399.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94399.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94399.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94399.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,13 @@\n+#include <stdlib.h>\n+\n+#define _cleanup_(f) __attribute__((cleanup(f)))\n+\n+static inline void freep(void **p) {\n+  free(*p);\n+}\n+\n+void test(void) {\n+  _cleanup_(freep) void *ptr;\n+\n+  ptr = malloc(3);\n+} /* { dg-bogus \"leak\" } */"}, {"sha": "7c61a2030674033dd79bf1d0affe5fac5982576f", "filename": "gcc/testsuite/gcc.dg/analyzer/pr94447.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94447.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94447.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94447.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -6,5 +6,5 @@ struct foo\n int test (void)\n {\n   struct foo f = {};\n-  return *f.v;\n+  return *f.v; /* { dg-warning \"dereference of NULL\" } */\n }"}, {"sha": "ad9bfc94ad4c450f48afc6892037146f4f5ceef9", "filename": "gcc/testsuite/gcc.dg/analyzer/pr94458.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94458.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94458.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94458.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,23 @@\n+#include <stdlib.h>\n+\n+struct ret\n+{\n+  int **array;\n+};\n+\n+struct ret *allocate_stuff(void)\n+{\n+  struct ret *ret;\n+\n+  ret = calloc(1, sizeof (struct ret));\n+  if (!ret) {\n+    abort();\n+  }\n+\n+  ret->array = calloc (10, sizeof(int *));\n+  if (!ret->array) {\n+    abort();\n+  }\n+\n+  return ret;\n+}"}, {"sha": "9722a179fcd7c9dbe32bf753d392331136c8fa70", "filename": "gcc/testsuite/gcc.dg/analyzer/pr94640.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94640.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94640.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94640.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,17 @@\n+#include <stdio.h>\n+  \n+int debug;\n+\n+int opencfgfile(const char *cfgfile, FILE **fd)\n+{\n+  if (cfgfile[0] != '\\0') {\n+\n+    if ((*fd = fopen(cfgfile, \"r\")) != NULL) {\n+      if (debug)\n+\tprintf(\"Config file: --config\\n\");\n+    }\n+    \n+  }\n+\n+  return 2;\n+}"}, {"sha": "f553b8cfdad44041793a96452e20813737075f89", "filename": "gcc/testsuite/gcc.dg/analyzer/pr94688.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94688.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94688.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94688.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,6 @@\n+int a, b;\n+void d();\n+void c()\n+{\n+  d((void (*)()) & a + b);\n+}"}, {"sha": "09802a7ecf5f7af40ccdf762cfda1d95522935d4", "filename": "gcc/testsuite/gcc.dg/analyzer/pr94689.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94689.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94689.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94689.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,8 @@\n+typedef void (*F) (void);\n+void bar (F);\n+\n+void\n+foo (void *a, int b)\n+{\n+  bar ((F) a + b);\n+}"}, {"sha": "46c8bb98bd23f3d5b671f0d113a86441010e5586", "filename": "gcc/testsuite/gcc.dg/analyzer/pr94839.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94839.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94839.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94839.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,20 @@\n+struct bitmap\n+{\n+  int min;\n+  int max;\n+  int *vec;\n+};\n+\n+int bitmap_create(struct bitmap *bm, int min, int max)\n+{\n+  int sz;\n+\n+  sz = (max / sizeof(int)) + 1;\n+\n+  bm->min = min;\n+  bm->max = max;\n+  bm->vec = __builtin_calloc(sz, sizeof(int));\n+  if (!bm->vec)\n+    return (-12);\n+  return 0; /* { dg-bogus \"leak\" } */\n+}"}, {"sha": "1845f15ae5997dd21984b883e03bf33273a9db8c", "filename": "gcc/testsuite/gcc.dg/analyzer/pr95026.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr95026.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr95026.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr95026.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,17 @@\n+struct _IO_FILE;\n+typedef struct _IO_FILE FILE;\n+typedef struct _message\n+{\n+  FILE *fp;\n+} MESSAGE;\n+extern FILE *fopen (const char *__restrict __filename,\n+                    const char *__restrict __modes);\n+FILE *f (void);\n+int imap_fetch_message (int i, MESSAGE *msg, char *p)\n+{\n+  if ((msg->fp = i ? 0 : f ()))\n+    return 0;\n+  if (p)\n+    msg->fp = fopen (p, \"r\");\n+  return -1;\n+}"}, {"sha": "c84c64de8b838df53319270a00d66bae0dfcdbb5", "filename": "gcc/testsuite/gcc.dg/analyzer/pr95240.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr95240.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr95240.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr95240.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,27 @@\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void *calloc(size_t nmemb, size_t size);\n+extern void free(void *ptr);\n+\n+static char *activeTroubleArray;\n+\n+int\n+initActiveTroubleArray ()\n+{\n+  activeTroubleArray = calloc (1, 1);\n+  return activeTroubleArray ? 0 : 1;\n+}\n+\n+void\n+freeActiveTroubleArray ()\n+{\n+  free (activeTroubleArray);\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  initActiveTroubleArray ();\n+  freeActiveTroubleArray ();\n+\n+  return 1;\n+}"}, {"sha": "4eb3a3e6ff20b0df8d6c23bc5912f19d32b6800b", "filename": "gcc/testsuite/gcc.dg/analyzer/refcounting-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frefcounting-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frefcounting-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Frefcounting-1.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,31 @@\n+#include \"analyzer-decls.h\"\n+\n+typedef struct obj {\n+  int ob_refcnt;\n+} PyObject;\n+\n+extern void Py_Dealloc (PyObject *op);\n+\n+#define Py_INCREF(op)\t\t\t\\\n+  do {\t\t\t\t\t\\\n+    ((PyObject*)(op))->ob_refcnt++;\t\\\n+  } while (0)\n+\n+#define Py_DECREF(op)                                   \\\n+    do {                                                \\\n+      if (--((PyObject*)(op))->ob_refcnt == 0)\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  /*Py_Dealloc((PyObject *)(op));*/\t\t\\\n+\t}\t\t\t\t\t\t\\\n+    } while (0)\n+\n+void test_1 (PyObject *obj)\n+{\n+  int orig_refcnt = obj->ob_refcnt;\n+  Py_INCREF (obj);\n+  Py_INCREF (obj);\n+  Py_DECREF (obj);\n+  Py_INCREF (obj);\n+  __analyzer_eval (obj->ob_refcnt == orig_refcnt + 2); /* { dg-warning \"TRUE\" } */\n+}\n+/* TODO: uncomment the Py_Dealloc, which leads to two paths.  */"}, {"sha": "d54cfb0c4d1eccb572414a6ae6e3ef49d6c89c9e", "filename": "gcc/testsuite/gcc.dg/analyzer/single-field.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsingle-field.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsingle-field.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsingle-field.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,37 @@\n+#include <stdlib.h>\n+#include \"analyzer-decls.h\"\n+\n+struct foo\n+{\n+  char *ptr;\n+};\n+\n+void test_1 (struct foo f)\n+{\n+  __analyzer_describe (0, f.ptr); /* { dg-warning \"svalue: 'INIT_VAL\\\\(f.ptr\\\\)'\" } */\n+}\n+\n+static void called_by_test_2 (struct foo f_inner)\n+{\n+  free (f_inner.ptr);\n+  free (f_inner.ptr); /* { dg-warning \"double-'free' of 'f_outer.ptr'\" } */\n+}\n+void test_2 (struct foo f_outer)\n+{\n+  called_by_test_2 (f_outer);\n+}\n+\n+struct nested\n+{\n+  struct foo f;\n+};\n+\n+static void called_by_test_3 (struct nested n_inner)\n+{\n+  free (n_inner.f.ptr);\n+  free (n_inner.f.ptr); /* { dg-warning \"double-'free' of 'n_outer.f.ptr'\" } */\n+}\n+void test_3 (struct nested n_outer)\n+{\n+  called_by_test_3 (n_outer);\n+}"}, {"sha": "04221479bf969ed819029df08b6418fa8bb4d227", "filename": "gcc/testsuite/gcc.dg/analyzer/stale-frame-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstale-frame-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstale-frame-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstale-frame-1.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,15 @@\n+\n+int *global_ptr;\n+\n+static void __attribute__((noinline))\n+called_by_test_1 (void)\n+{\n+  int i = 42;\n+  global_ptr = &i;  \n+}\n+\n+int test_1 (void)\n+{\n+  called_by_test_1 ();\n+  return *global_ptr; /* { dg-warning \"dereferencing pointer 'global_ptr' to within stale stack frame\" } */\n+}"}, {"sha": "9d228e6331c796b7207dab6cedcb04f6fe6a9bb9", "filename": "gcc/testsuite/gcc.dg/analyzer/symbolic-1.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-1.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,43 @@\n+#include \"analyzer-decls.h\"\n+\n+/* The example from store2.h  */\n+\n+void test_1 (char a, char b, char c, char d, char e, char f,\n+\t     int i, int j)\n+{\n+  char arr[1024];\n+  arr[2] = a;  /* (1) */\n+  arr[3] = b;  /* (2) */\n+\n+  __analyzer_eval (arr[2] == a); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (arr[3] == b); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (arr[4]); /* { dg-warning \"UNKNOWN\" } */ // TODO: report uninit\n+\n+  /* Replace one concrete binding's value with a different value.  */\n+  arr[3] = c;  /* (3) */\n+  __analyzer_eval (arr[2] == a); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (arr[3] == c); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (arr[3] == b); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (arr[4]); /* { dg-warning \"UNKNOWN\" } */ // TODO: report uninit\n+\n+  /* Symbolic binding.  */\n+  arr[i] = d;  /* (4) */\n+  __analyzer_eval (arr[i] == d); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (arr[2] == a); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (arr[3] == c); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (arr[4]); /* { dg-warning \"UNKNOWN\" } */ /* Don't report uninit. */\n+\n+  /* Replace symbolic binding with a different one.  */\n+  arr[j] = e;  /* (5) */\n+  __analyzer_eval (arr[j] == e); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (arr[i] == d); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (arr[4]); /* { dg-warning \"UNKNOWN\" } */ /* Don't report uninit. */\n+\n+  /* Add a concrete binding.  */\n+  arr[3] = f;  /* (6) */\n+  __analyzer_eval (arr[3] == f); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (arr[j] == e); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (arr[4]); /* { dg-warning \"UNKNOWN\" } */ /* Don't report uninit. */\n+}\n+\n+// TODO: as above, but with int rather than char so there's a cast"}, {"sha": "70c00ce386751d930735eba35b13f8a6f1d9ff78", "filename": "gcc/testsuite/gcc.dg/analyzer/symbolic-2.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-2.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,32 @@\n+#include \"analyzer-decls.h\"\n+\n+struct foo\n+{\n+  int ival;\n+  int iarr[10];\n+};\n+\n+void test_1 (int i, int j)\n+{\n+  struct foo fooarr[4];\n+  fooarr[1].ival = 42;\n+  fooarr[1].iarr[3] = 27;\n+  fooarr[2].iarr[1] = 17;\n+  __analyzer_eval (fooarr[1].ival == 42); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (fooarr[1].iarr[3] == 27); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (fooarr[2].iarr[1] == 17); /* { dg-warning \"TRUE\" } */\n+\n+  /* Symbolic binding.  */\n+  fooarr[2].iarr[i] = j;\n+  __analyzer_eval (fooarr[2].iarr[i] == j); /* { dg-warning \"TRUE\" } */\n+\n+  /* We should have lost our knowledge about fooarr[2].\n+     It's not clear to me if we should also lose our knowledge about\n+     fooarr[1] (for the case where i is negative).  For now, we do.  */\n+  __analyzer_eval (fooarr[1].ival == 42); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (fooarr[1].iarr[3] == 27); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (fooarr[2].iarr[1] == 17); /* { dg-warning \"UNKNOWN\" } */\n+  /* Should also be safe to read from fooarr[2];\n+     it isn't known to be uninit anymore.  */\n+  __analyzer_eval (fooarr[2].iarr[10] == 17); /* { dg-warning \"UNKNOWN\" } */\n+}"}, {"sha": "da4cdbbc54c162090da1c5666b94960bee85b4e5", "filename": "gcc/testsuite/gcc.dg/analyzer/symbolic-3.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-3.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,12 @@\n+#include \"analyzer-decls.h\"\n+\n+int iarr[16];\n+\n+void test_1 (int i, int j)\n+{\n+  int init_el_8 = iarr[8];\n+  __analyzer_eval (init_el_8 == iarr[8]); /* { dg-warning \"TRUE\" } */\n+\n+  iarr[i] = j;\n+  __analyzer_eval (init_el_8 == iarr[8]); /* { dg-warning \"UNKNOWN\" } */\n+}"}, {"sha": "a466f912007cf38eb23315b6faf34cb82f0422df", "filename": "gcc/testsuite/gcc.dg/analyzer/symbolic-4.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-4.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,20 @@\n+#include <string.h>\n+#include \"analyzer-decls.h\"\n+\n+void test_1 (int i, int j, int k)\n+{\n+  int iarr[16];\n+  iarr[i] = j;\n+  __analyzer_eval (iarr[i] == j); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (iarr[k] == j); /* { dg-warning \"UNKNOWN\" } */\n+\n+  memset (iarr, 0, sizeof (iarr));\n+  __analyzer_eval (iarr[0] == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (iarr[i] == 0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (iarr[i] == j); /* { dg-warning \"UNKNOWN\" } */\n+\n+  iarr[i] = j;\n+  __analyzer_eval (iarr[i] == j); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (iarr[0] == 0); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (iarr[i] == 0); /* { dg-warning \"UNKNOWN\" } */\n+}"}, {"sha": "3f696503606f085049ca92364dbc497dcc9ae326", "filename": "gcc/testsuite/gcc.dg/analyzer/symbolic-5.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-5.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,29 @@\n+#include \"analyzer-decls.h\"\n+\n+int a[1024];\n+int b[1024];\n+\n+extern void escape (void *ptr);\n+\n+void test_1 (int *p)\n+{\n+  int c, d;\n+  escape (&c);\n+  a[16] = 42;\n+  b[16] = 17;\n+  c = 33;\n+  d = 44;\n+  __analyzer_eval (a[16] == 42); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (b[16] == 17); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c == 33); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (d == 44); /* { dg-warning \"TRUE\" } */\n+\n+  /* Write through an externally-provided pointer.  */\n+  *p = 100;\n+  /* It could clobber our writes to the global arrays...  */\n+  __analyzer_eval (a[16] == 42); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (b[16] == 17); /* { dg-warning \"UNKNOWN\" } */  \n+  /* ...but can't clobber locals, even ones like \"c\" that have escaped.  */\n+  __analyzer_eval (c == 33); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (d == 44); /* { dg-warning \"TRUE\" } */\n+}"}, {"sha": "10d4e97229933d8357bbe0cb6c6353e62b5c5e06", "filename": "gcc/testsuite/gcc.dg/analyzer/symbolic-6.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-6.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,24 @@\n+#include \"analyzer-decls.h\"\n+\n+int a[1024];\n+int b[1024];\n+\n+extern void escape (void *ptr);\n+\n+void test_1 (int *p)\n+{\n+  int c, d;\n+  escape (&c);\n+\n+  *p = 42;\n+  __analyzer_eval (*p == 42); /* { dg-warning \"TRUE\" } */\n+\n+  /* These writes shouldn't affect *p.  */\n+  c = 33;\n+  d = 44;\n+  __analyzer_eval (*p == 42); /* { dg-warning \"TRUE\" } */\n+\n+  /* This write could affect *p.  */\n+  a[16] = 55;\n+  __analyzer_eval (*p == 42); /* { dg-warning \"UNKNOWN\" } */\n+}"}, {"sha": "cd46dd5fc14ac053c1e3254381f04f8701644c01", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-1.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-1.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -14,14 +14,14 @@ char test_1(FILE *f)\n {\n   struct foo tmp;\n \n-  if (1 == fread(&tmp, sizeof(tmp), 1, f)) { /* { dg-message \"\\\\(1\\\\) 'tmp' gets an unchecked value here\" \"event 1\" } */\n-                                             /* { dg-message \"\\\\(2\\\\) following 'true' branch\\\\.\\\\.\\\\.\" \"event 2\" { target *-*-* } .-1 } */\n+  if (1 == fread(&tmp, sizeof(tmp), 1, f)) { /* { dg-message \"\\\\(\\[0-9\\]+\\\\) 'tmp' gets an unchecked value here\" \"event: tmp gets unchecked value\" { xfail *-*-* } } */\n+                                             /* { dg-message \"\\\\(\\[0-9\\]+\\\\) following 'true' branch\\\\.\\\\.\\\\.\" \"event: following true branch\" { target *-*-* } .-1 } */\n     /* BUG: the following array lookup trusts that the input data's index is\n        in the range 0 <= i < 256; otherwise it's accessing the stack */\n     return tmp.buf[tmp.i]; // { dg-warning \"use of tainted value 'tmp.i' in array lookup without bounds checking\" \"warning\" } */\n-    /* { dg-message \"23: \\\\(3\\\\) \\\\.\\\\.\\\\.to here\" \"event 3\" { target *-*-* } .-1 } */\n-    /* { dg-message \"23: \\\\(4\\\\) 'tmp.i' has an unchecked value here \\\\(from 'tmp'\\\\)\" \"event 4\" { target *-*-* } .-2 } */\n-    /* { dg-message \"\\\\(5\\\\) use of tainted value 'tmp.i' in array lookup without bounds checking\" \"event 5\" { target *-*-* } .-3 } */\n+    /* { dg-message \"23: \\\\(\\[0-9\\]+\\\\) \\\\.\\\\.\\\\.to here\" \"event: to here\" { target *-*-* } .-1 } */\n+    /* { dg-message \"23: \\\\(\\[0-9\\]+\\\\) 'tmp.i' has an unchecked value here \\\\(from 'tmp'\\\\)\" \"event: tmp.i has an unchecked value\" { xfail *-*-* } .-2 } */\n+    /* { dg-message \"\\\\(\\[0-9\\]+\\\\) use of tainted value 'tmp.i' in array lookup without bounds checking\" \"final event\" { target *-*-* } .-3 } */\n     \n     // TOOD: better messages for state changes\n   }\n@@ -52,9 +52,9 @@ char test_4(FILE *f)\n   struct foo tmp;\n \n   if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n-    if (tmp.i >= 0) { /* { dg-message \"'tmp.i' has an unchecked value here \\\\(from 'tmp'\\\\)\" \"warning\" } */\n-      /* { dg-message \"'tmp.i' has its lower bound checked here\" \"event\" { target *-*-* } .-1 } */\n-      return tmp.buf[tmp.i]; /* { dg-warning \"use of tainted value 'tmp.i' in array lookup without upper-bounds checking\" } */\n+    if (tmp.i >= 0) { /* { dg-message \"'tmp.i' has an unchecked value here \\\\(from 'tmp'\\\\)\" \"event: tmp.i has an unchecked value\" { xfail *-*-* } } */\n+      /* { dg-message \"'tmp.i' has its lower bound checked here\" \"event: lower bound checked\" { target *-*-* } .-1 } */\n+      return tmp.buf[tmp.i]; /* { dg-warning \"use of tainted value 'tmp.i' in array lookup without upper-bounds checking\" \"warning\" } */\n     }\n   }\n   return 0;\n@@ -65,9 +65,9 @@ char test_5(FILE *f)\n   struct foo tmp;\n \n   if (1 == fread(&tmp, sizeof(tmp), 1, f)) {\n-    if (tmp.i < 256) { /* { dg-message \"'tmp.i' has an unchecked value here \\\\(from 'tmp'\\\\)\" \"warning\" } */\n-      /* { dg-message \"'tmp.i' has its upper bound checked here\" \"event\" { target *-*-* } .-1 } */\n-      return tmp.buf[tmp.i]; /* { dg-warning \"use of tainted value 'tmp.i' in array lookup without lower-bounds checking\" } */\n+    if (tmp.i < 256) { /* { dg-message \"'tmp.i' has an unchecked value here \\\\(from 'tmp'\\\\)\" \"event: tmp.i has an unchecked value\" { xfail *-*-* } } */\n+      /* { dg-message \"'tmp.i' has its upper bound checked here\" \"event: upper bound checked\" { target *-*-* } .-1 } */\n+      return tmp.buf[tmp.i]; /* { dg-warning \"use of tainted value 'tmp.i' in array lookup without lower-bounds checking\" \"warning\" } */\n     }\n   }\n   return 0;"}, {"sha": "afb27185f1b54e9593b15ca352c404836f9079ad", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/loop-inc-ptr-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Floop-inc-ptr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Floop-inc-ptr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Floop-inc-ptr-1.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-skip-if \"\" { *-*-* } { \"-fno-fat-lto-objects\" } { \"\" } } */\n+\n+#include \"../analyzer-decls.h\"\n+\n+void test (int *p)\n+{\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+\n+  while (*p)\n+    {\n+      __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enode\" } */\n+      p++;\n+    }\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+}"}, {"sha": "95d8c53ade190e79fa2137f087284ea21ba52fb2", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/loop-inc-ptr-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Floop-inc-ptr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Floop-inc-ptr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Floop-inc-ptr-2.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-skip-if \"\" { *-*-* } { \"-fno-fat-lto-objects\" } { \"\" } } */\n+\n+#include \"../analyzer-decls.h\"\n+\n+void test (int *p, int val, int count)\n+{\n+  int n = count;\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+\n+  while (n--)\n+    {\n+      __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enode\" } */\n+      *p++ = val;\n+    }\n+\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+}"}, {"sha": "1d3576d93083079eeb63956c951838300617db2c", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/loop-inc-ptr-3.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Floop-inc-ptr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Floop-inc-ptr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Floop-inc-ptr-3.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-skip-if \"\" { *-*-* } { \"-fno-fat-lto-objects\" } { \"\" } } */\n+\n+#include \"../analyzer-decls.h\"\n+\n+void test (int *p, int a, int b, int count)\n+{\n+  int n = count;\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+\n+  while (n--)\n+    {\n+      __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enode\" } */\n+      *p++ = a;\n+      *p++ = b;\n+    }\n+\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+}"}, {"sha": "1c4bdd6b51b855cf41fb4cb31bbfd180252fc9fd", "filename": "gcc/testsuite/gcc.dg/analyzer/unknown-fns-2.c", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funknown-fns-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funknown-fns-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funknown-fns-2.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,238 @@\n+/* Tests for data model handling of unknown fns.  */\n+\n+#include <stddef.h>\n+#include \"analyzer-decls.h\"\n+\n+void unknown_fn (void *);\n+\n+void test_1 (void)\n+{\n+  int i;\n+\n+  i = 42;\n+  __analyzer_eval (i == 42); /* { dg-warning \"TRUE\" } */\n+\n+  unknown_fn (NULL);\n+  __analyzer_eval (i == 42); /* { dg-warning \"TRUE\" } */\n+  \n+  unknown_fn (&i);\n+  __analyzer_eval (i == 42); /* { dg-warning \"UNKNOWN\" } */\n+\n+  i = 17;\n+  __analyzer_eval (i == 17); /* { dg-warning \"TRUE\" } */\n+\n+  /* Even though we're not passing &i to unknown_fn, it escaped\n+     above, so unknown_fn could write to it.  */\n+  unknown_fn (NULL);\n+  __analyzer_eval (i == 17); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+/* As test_1, but with an unknown fn_ptr.  */\n+\n+void test_1a (void (*fn_ptr) (void *))\n+{\n+  int i;\n+\n+  i = 42;\n+  __analyzer_eval (i == 42); /* { dg-warning \"TRUE\" } */\n+\n+  fn_ptr (NULL);\n+  __analyzer_eval (i == 42); /* { dg-warning \"TRUE\" } */\n+  \n+  fn_ptr (&i);\n+  __analyzer_eval (i == 42); /* { dg-warning \"UNKNOWN\" } */\n+\n+  i = 17;\n+  __analyzer_eval (i == 17); /* { dg-warning \"TRUE\" } */\n+\n+  /* Even though we're not passing &i to unknown_fn, it escaped\n+     above, so fn_ptr (NULL) could write to it.  */\n+  fn_ptr (NULL);\n+  __analyzer_eval (i == 17); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+int *global_for_test_2;\n+\n+void test_2 (void)\n+{\n+  int i;\n+\n+  i = 42;\n+  __analyzer_eval (i == 42); /* { dg-warning \"TRUE\" } */\n+\n+  global_for_test_2 = &i;\n+  unknown_fn (NULL);\n+  __analyzer_eval (i == 42); /* { dg-warning \"UNKNOWN\" } */\n+\n+  global_for_test_2 = NULL;\n+\n+  i = 17;\n+  __analyzer_eval (i == 17); /* { dg-warning \"TRUE\" } */\n+\n+  /* Even though the global no longer points to i, it escaped\n+     above, so unknown_fn could write to it.  */\n+  unknown_fn (NULL);\n+  __analyzer_eval (i == 17); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+struct used_by_test_3\n+{\n+  int *int_ptr;\n+};\n+\n+void test_3 (void)\n+{\n+  int i;\n+\n+  struct used_by_test_3 s;\n+  s.int_ptr = &i;\n+\n+  i = 42;\n+  __analyzer_eval (i == 42); /* { dg-warning \"TRUE\" } */\n+\n+  unknown_fn (NULL);\n+  __analyzer_eval (i == 42); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (s.int_ptr == &i); /* { dg-warning \"TRUE\" } */\n+\n+  /* i should escape here.  */\n+  unknown_fn (&s);\n+  __analyzer_eval (i == 42); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (s.int_ptr == &i); /* { dg-warning \"UNKNOWN\" } */\n+\n+  s.int_ptr = NULL;\n+  __analyzer_eval (s.int_ptr == NULL); /* { dg-warning \"TRUE\" } */\n+\n+  i = 17;\n+  __analyzer_eval (i == 17); /* { dg-warning \"TRUE\" } */\n+\n+  /* Even though nothing we know about points to i, it escaped\n+     above, so unknown_fn could write to it.  */\n+  unknown_fn (NULL);\n+  __analyzer_eval (i == 17); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+struct used_by_test_4\n+{\n+  int *int_ptr;\n+};\n+\n+void test_4 (struct used_by_test_4 *st4_ptr)\n+{\n+  /* Something unknown called \"test_4\", and hence *st4_ptr has\n+     effectively already escaped.  */\n+\n+  int i = 42;\n+  __analyzer_eval (i == 42); /* { dg-warning \"TRUE\" } */\n+\n+  unknown_fn (NULL);\n+  __analyzer_eval (i == 42); /* { dg-warning \"TRUE\" } */\n+\n+  /* Given that *st4_ptr has effectively already escaped, calling\n+     an unknown fn should invalidate our knowledge of i\".  */\n+  st4_ptr->int_ptr = &i;\n+  unknown_fn (NULL);\n+  __analyzer_eval (i == 42); /* { dg-warning \"UNKNOWN\" } */\n+\n+  /* ...and \"&i\" should now be treated as having escaped.  */\n+  i = 17;\n+  __analyzer_eval (i == 17); /* { dg-warning \"TRUE\" } */\n+  st4_ptr->int_ptr = NULL;\n+  unknown_fn (NULL);\n+  __analyzer_eval (i == 17); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+static void __attribute__((noinline))\n+known_fn (void *ptr)\n+{\n+  /* Empty.  */\n+}\n+\n+void test_5 (void)\n+{\n+  int i;\n+\n+  i = 42;\n+  __analyzer_eval (i == 42); /* { dg-warning \"TRUE\" } */\n+\n+  known_fn (&i);\n+  __analyzer_eval (i == 42); /* { dg-warning \"TRUE\" } */\n+\n+  i = 17;\n+  __analyzer_eval (i == 17); /* { dg-warning \"TRUE\" } */\n+\n+  /* Ensure that we don't consider &i to have escaped.  */\n+  unknown_fn (NULL);\n+  __analyzer_eval (i == 17); /* { dg-warning \"TRUE\" } */\n+}\n+\n+extern int __attribute__ ((__pure__))\n+unknown_pure_fn (void *);\n+\n+void test_6 (void)\n+{\n+  int i;\n+\n+  i = 42;\n+  __analyzer_eval (i == 42); /* { dg-warning \"TRUE\" } */\n+\n+  unknown_pure_fn (&i);\n+  __analyzer_eval (i == 42); /* { dg-warning \"TRUE\" } */\n+\n+  i = 17;\n+  __analyzer_eval (i == 17); /* { dg-warning \"TRUE\" } */\n+\n+  /* Ensure that we don't consider &i to have escaped.  */\n+  unknown_fn (NULL);\n+  __analyzer_eval (i == 17); /* { dg-warning \"TRUE\" } */\n+}\n+\n+extern void unknown_const_fn (const void *);\n+\n+void test_7 (void)\n+{\n+  int i;\n+\n+  i = 42;\n+  __analyzer_eval (i == 42); /* { dg-warning \"TRUE\" } */\n+\n+  /* &i is passed as a const void *, so i shouldn't be clobbered by\n+     the call.  */\n+  unknown_const_fn (&i);\n+  __analyzer_eval (i == 42); /* { dg-warning \"TRUE\" } */\n+\n+  i = 17;\n+  __analyzer_eval (i == 17); /* { dg-warning \"TRUE\" } */\n+\n+  /* Ensure that we don't consider &i to have escaped.  */\n+  unknown_fn (NULL);\n+  __analyzer_eval (i == 17); /* { dg-warning \"TRUE\" } */\n+}\n+\n+struct used_by_test_8\n+{\n+  int *int_ptr;\n+};\n+\n+void test_8 (void)\n+{\n+  int i;\n+\n+  i = 42;\n+  __analyzer_eval (i == 42); /* { dg-warning \"TRUE\" } */\n+\n+  struct used_by_test_8 st8;\n+  st8.int_ptr = &i;\n+\n+  /* Although unknown_const_fn takes a const void *, the\n+     int_ptr is a non-const int *, and so &i should be considered\n+     writable.  */\n+  unknown_const_fn (&st8);\n+  __analyzer_eval (i == 42); /* { dg-warning \"UNKNOWN\" } */\n+\n+  i = 17;\n+  __analyzer_eval (i == 17); /* { dg-warning \"TRUE\" } */\n+\n+  /* &i should be considered to have escaped.  */\n+  unknown_fn (NULL);\n+  __analyzer_eval (i == 17); /* { dg-warning \"UNKNOWN\" } */\n+}"}, {"sha": "095df5e77a7ae84c571aafac96e2c30d30b55182", "filename": "gcc/testsuite/gcc.dg/analyzer/unknown-fns-3.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funknown-fns-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funknown-fns-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funknown-fns-3.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,67 @@\n+/* Tests for handling constraints on results of unknown fns.  */\n+\n+#include <stddef.h>\n+#include \"analyzer-decls.h\"\n+\n+void unknown_fn (void *);\n+\n+void test_1 (void)\n+{\n+  int i;\n+  unknown_fn (&i);\n+  if (i)\n+    __analyzer_eval (i); /* { dg-warning \"TRUE\" } */\n+  else\n+    __analyzer_eval (i); /* { dg-warning \"FALSE\" } */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+}\n+\n+struct foo\n+{\n+  int i;\n+  int j;\n+};\n+\n+void test_2 (void)\n+{\n+  struct foo f;\n+  unknown_fn (&f);\n+  if (f.j)\n+    __analyzer_eval (f.j); /* { dg-warning \"TRUE\" } */\n+  else\n+    __analyzer_eval (f.j); /* { dg-warning \"FALSE\" } */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+}\n+\n+void test_3 (int flag)\n+{\n+  int i;\n+  unknown_fn (&i);\n+  if (i)\n+    {\n+      __analyzer_eval (i); /* { dg-warning \"TRUE\" } */\n+      if (flag)\n+\t__analyzer_eval (flag); /* { dg-warning \"TRUE\" } */\n+      else\n+\t__analyzer_eval (flag); /* { dg-warning \"FALSE\" } */\n+    }\n+  else\n+    __analyzer_eval (i); /* { dg-warning \"FALSE\" } */\n+  if (flag)\n+    __analyzer_eval (flag); /* { dg-warning \"TRUE\" } */\n+  else\n+    __analyzer_eval (flag); /* { dg-warning \"FALSE\" } */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+}\n+\n+void test_4 (int y)\n+{\n+  int x;\n+  unknown_fn (&x);\n+  if (x)\n+    {\n+      __analyzer_eval (x); /* { dg-warning \"TRUE\" } */\n+      x = 0;\n+    }\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n+}"}, {"sha": "3d8f82ee2900280283c3bbe0596b4560c3af6f12", "filename": "gcc/testsuite/gcc.dg/analyzer/unknown-fns-4.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funknown-fns-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funknown-fns-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funknown-fns-4.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,15 @@\n+#include \"analyzer-decls.h\"\n+\n+int get(void);\n+void test (void)\n+{\n+  int got = 0;\n+  while (1)\n+    {\n+      if (get ())\n+\tgot = 1;\n+      else\n+\tif (got)\n+\t  __analyzer_dump_path (); /* { dg-message \"path\" \"\" { xfail *-*-* } } */\n+    }\n+}"}, {"sha": "fd1ecbb7005b0ccfc9a4f907b24760b24c006eb6", "filename": "gcc/testsuite/gcc.dg/analyzer/unknown-fns.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funknown-fns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funknown-fns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funknown-fns.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -76,10 +76,10 @@ void test_4a (void)\n   node_b.ptr = malloc (sizeof (int));\n   global_ptr = &node_a;\n   *node_b.ptr = 42; /* { dg-warning \"possibly-NULL\" \"possibly-NULL\" } */\n-  /* { dg-warning \"leak\" \"leak\" { target *-*-* } .-1 } */\n-  /* FIXME: the above leak report is correct, but is reported at the wrong\n-     location.  */\n-} /* { dg-warning \"leak\" } */\n+  /* Although there's a chain of pointers to the allocation, pointed to\n+     by global_ptr, the chain goes through the stack frame and thus\n+     there's a leak when it is popped.  */\n+} /* { dg-warning \"leak of 'node_b.ptr'\" } */\n \n /* With a call to an unknown function.  */\n "}, {"sha": "d7e4bc2c6cac627fc58f53e70713876e2f669f92", "filename": "gcc/testsuite/gcc.dg/analyzer/use-after-free.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fuse-after-free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fuse-after-free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fuse-after-free.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,12 @@\n+#include <stdlib.h>\n+#include \"analyzer-decls.h\"\n+\n+struct link { struct link *next; };\n+\n+int free_a_list_badly (struct link *n)\n+{\n+  while (n) {\n+    free(n); /* { dg-message \"freed here\" } */\n+    n = n->next; /* { dg-warning \"use after 'free' of 'n'\" } */\n+  }\n+}"}, {"sha": "0488ff282a4d5a1dde023323828dfdea4d32cb15", "filename": "gcc/testsuite/gcc.dg/analyzer/vla-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fvla-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fvla-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fvla-1.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -0,0 +1,13 @@\n+#include \"analyzer-decls.h\"\n+\n+void test_1 (int n)\n+{\n+  struct\n+  {\n+    char a[n], b;\n+  } s;\n+  s.a[0] = 42;\n+  __analyzer_eval (s.a[0] == 42); /* { dg-warning \"TRUE\" } */\n+  s.b = 17;\n+  __analyzer_eval (s.b == 17); /* { dg-warning \"TRUE\" } */\n+}"}, {"sha": "ae2f6c9f8ad12e468e8ddcc4600a400e8495bed7", "filename": "gcc/testsuite/gcc.dg/analyzer/zlib-4.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-4.c?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -7,14 +7,18 @@ typedef unsigned long uLong;\n \n #define Z_NULL  0\n \n-void test ()\n+int test ()\n {\n     uLong comprLen = 10000*sizeof(int);\n     uLong uncomprLen = comprLen;\n     Byte *compr    = (Byte*)calloc((uInt)comprLen, 1);\n     Byte *uncompr  = (Byte*)calloc((uInt)uncomprLen, 1);\n     if (compr == Z_NULL || uncompr == Z_NULL)\n-      exit (1);\n+      {\n+\treturn 1; /* { dg-warning \"leak of 'uncompr'\" \"uncompr leak\" } */\n+\t          /* { dg-warning \"leak of 'compr'\" \"compr leak\" { target *-*-* } .-1 } */\n+      }\n     strcpy((char*)uncompr, \"garbage\");\n-    exit (0);\n+    return 0; /* { dg-warning \"leak of 'uncompr'\" \"uncompr leak\" } */\n+\t      /* { dg-warning \"leak of 'compr'\" \"compr leak\" { target *-*-* } .-1 } */\n }"}, {"sha": "230b99e4fcde88d05b96d356ecf795132c4dc5ef", "filename": "gcc/testsuite/gfortran.dg/analyzer/pr93993.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgfortran.dg%2Fanalyzer%2Fpr93993.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftestsuite%2Fgfortran.dg%2Fanalyzer%2Fpr93993.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fanalyzer%2Fpr93993.f90?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -18,7 +18,7 @@ function hv (tm) result(ce)\n \n     allocate (tm) ! { dg-bogus \"dereference of possibly-NULL\" }\n     ce => tm\n-  end function hv ! { dg-warning \"leak of 'tm'\" }\n+  end function hv\n \n end module gg\n "}, {"sha": "dcd096bf77b0d005800c3503c7e02c8213f5dca3", "filename": "gcc/tristate.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftristate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/808f4dfeb3a95f50f15e71148e5c1067f90a126d/gcc%2Ftristate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftristate.h?ref=808f4dfeb3a95f50f15e71148e5c1067f90a126d", "patch": "@@ -55,6 +55,8 @@ class tristate {\n     return m_value != other.m_value;\n   }\n \n+  enum value get_value () const { return m_value; }\n+\n  private:\n   enum value m_value;\n };"}]}