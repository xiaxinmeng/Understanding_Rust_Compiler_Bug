{"sha": "40207762a82f9d6fde9a9ac529ea3a170dac1a91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAyMDc3NjJhODJmOWQ2ZmRlOWE5YWM1MjllYTNhMTcwZGFjMWE5MQ==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2011-11-29T07:45:58Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2011-11-29T07:45:58Z"}, "message": "hashtable.h (_Hashtable<>::_M_rehash): Remove code useless now that the hashtable implementation put the hash code in...\n\n2011-11-29  Fran\u00e7ois Dumont <fdumont@gcc.gnu.org>\n\n\t* include/bits/hashtable.h (_Hashtable<>::_M_rehash): Remove code\n\tuseless now that the hashtable implementation put the hash code in\n\tcache if the hash functor throws.\n\t* testsuite/23_containers/unordered_set/erase/1.cc: Enhance test by\n\tchecking also distance between begin and end iterators to validate\n\tunderlying data model.\n\t* testsuite/23_containers/unordered_multiset/erase/1.cc: Likewise.\n\t* testsuire/23_containers/unordered_map/erase/1.cc: Likewise.\n\t* testsuite/23_containers/unordered_multimap/erase/1.cc: Likewise.\n\t* testsuite/23_containers/unordered_multiset/erase/2.cc: New.\n\t* testsuite/23_containers/unordered_multimap/erase/2.cc: New.\n\nFrom-SVN: r181799", "tree": {"sha": "9a9ec4da9401072fba5355ee158be75f6a46ec0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a9ec4da9401072fba5355ee158be75f6a46ec0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40207762a82f9d6fde9a9ac529ea3a170dac1a91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40207762a82f9d6fde9a9ac529ea3a170dac1a91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40207762a82f9d6fde9a9ac529ea3a170dac1a91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40207762a82f9d6fde9a9ac529ea3a170dac1a91/comments", "author": null, "committer": null, "parents": [{"sha": "714cb9f01a3b5ebcc929263295262010844a1b90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/714cb9f01a3b5ebcc929263295262010844a1b90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/714cb9f01a3b5ebcc929263295262010844a1b90"}], "stats": {"total": 359, "additions": 319, "deletions": 40}, "files": [{"sha": "4be8353ab44e8f4c7626559e8e1295b836bffc2d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40207762a82f9d6fde9a9ac529ea3a170dac1a91/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40207762a82f9d6fde9a9ac529ea3a170dac1a91/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=40207762a82f9d6fde9a9ac529ea3a170dac1a91", "patch": "@@ -1,3 +1,17 @@\n+2011-11-29  Fran\u00e7ois Dumont <fdumont@gcc.gnu.org>\n+\n+\t* include/bits/hashtable.h (_Hashtable<>::_M_rehash): Remove code\n+\tuseless now that the hashtable implementation put the hash code in\n+\tcache if the hash functor throws.\n+\t* testsuite/23_containers/unordered_set/erase/1.cc: Enhance test by\n+\tchecking also distance between begin and end iterators to validate\n+\tunderlying data model.\n+\t* testsuite/23_containers/unordered_multiset/erase/1.cc: Likewise.\n+\t* testsuire/23_containers/unordered_map/erase/1.cc: Likewise.\n+\t* testsuite/23_containers/unordered_multimap/erase/1.cc: Likewise.\n+\t* testsuite/23_containers/unordered_multiset/erase/2.cc: New.\n+\t* testsuite/23_containers/unordered_multimap/erase/2.cc: New.\n+\n 2011-11-28  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* include/bits/atomic_base.h (ATOMIC_*_LOCK_FREE): Use new cpp"}, {"sha": "712b1df91c284012ee4a01945eac6300e67f2309", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 5, "deletions": 39, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40207762a82f9d6fde9a9ac529ea3a170dac1a91/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40207762a82f9d6fde9a9ac529ea3a170dac1a91/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=40207762a82f9d6fde9a9ac529ea3a170dac1a91", "patch": "@@ -233,11 +233,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_deallocate_node(_Node* __n);\n \n-      // Deallocate all nodes contained in the bucket array, buckets' nodes\n-      // are not linked to each other\n-      void\n-      _M_deallocate_nodes(_Bucket*, size_type);\n-\n       // Deallocate the linked list of nodes pointed to by __n\n       void\n       _M_deallocate_nodes(_Node* __n);\n@@ -584,19 +579,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_node_allocator.deallocate(__n, 1);\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_deallocate_nodes(_Bucket* __buckets, size_type __n)\n-    {\n-      for (size_type __i = 0; __i != __n; ++__i)\n-\t_M_deallocate_nodes(__buckets[__i]);\n-    }\n-\n   template<typename _Key, typename _Value,\n \t   typename _Allocator, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n@@ -1542,11 +1524,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n     _M_rehash(size_type __n, const _RehashPolicyState& __state)\n     {\n-      _Bucket* __new_buckets = nullptr;\n-      _Node* __p = _M_buckets[_M_begin_bucket_index];\n       __try\n \t{\n-\t  __new_buckets = _M_allocate_buckets(__n);\n+\t  _Bucket* __new_buckets = _M_allocate_buckets(__n);\n+\t  _Node* __p = _M_buckets[_M_begin_bucket_index];\n \t  // First loop to store each node in its new bucket\n \t  while (__p)\n \t    {\n@@ -1591,24 +1572,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n       __catch(...)\n \t{\n-\t  if (__new_buckets)\n-\t    {\n-\t      // A failure here means that a hash function threw an exception.\n-\t      // We can't restore the previous state without calling the hash\n-\t      // function again, so the only sensible recovery is to delete\n-\t      // everything.\n-\t      _M_deallocate_nodes(__new_buckets, __n);\n-\t      _M_deallocate_buckets(__new_buckets, __n);\n-\t      _M_deallocate_nodes(__p);\n-\t      __builtin_memset(_M_buckets, 0, sizeof(_Bucket) * _M_bucket_count);\n-\t      _M_element_count = 0;\n-\t      _M_begin_bucket_index = _M_bucket_count;\n-\t      _M_rehash_policy._M_reset(_RehashPolicyState());\n-\t    }\n-\t  else\n-\t    // A failure here means that buckets allocation failed.  We only\n-\t    // have to restore hash policy previous state.\n-\t    _M_rehash_policy._M_reset(__state);\n+\t  // A failure here means that buckets allocation failed.  We only\n+\t  // have to restore hash policy previous state.\n+\t  _M_rehash_policy._M_reset(__state);\n \t  __throw_exception_again;\n \t}\n     }"}, {"sha": "9863ef792bae9966ed009bfd402f420c561594c6", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/erase/1.cc", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40207762a82f9d6fde9a9ac529ea3a170dac1a91/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Ferase%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40207762a82f9d6fde9a9ac529ea3a170dac1a91/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Ferase%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Ferase%2F1.cc?ref=40207762a82f9d6fde9a9ac529ea3a170dac1a91", "patch": "@@ -23,6 +23,18 @@\n #include <string>\n #include <testsuite_hooks.h>\n \n+namespace\n+{\n+  std::size_t\n+  get_nb_bucket_elems(const std::unordered_map<std::string, int>& us)\n+  {\n+    std::size_t nb = 0;\n+    for (std::size_t b = 0; b != us.bucket_count(); ++b)\n+      nb += us.bucket_size(b);\n+    return nb;\n+  }\n+}\n+\n void test01()\n {\n   bool test __attribute__((unused)) = true;\n@@ -33,7 +45,7 @@ void test01()\n   typedef Map::value_type     value_type;\n \n   Map m1;\n-\n+ \n   m1.insert(value_type(\"because to why\", 1));\n   m1.insert(value_type(\"the stockholm syndrome\", 2));\n   m1.insert(value_type(\"a cereous night\", 3));\n@@ -45,14 +57,20 @@ void test01()\n   m1.insert(value_type(\"belonging (no longer mix)\", 9));\n   m1.insert(value_type(\"one line behind\", 10));\n   VERIFY( m1.size() == 10 );\n+  VERIFY( get_nb_bucket_elems(m1) == m1.size() );\n+  VERIFY( distance(m1.begin(), m1.end()) == m1.size() );\n \n   VERIFY( m1.erase(\"eeilo\") == 1 );\n   VERIFY( m1.size() == 9 );\n+  VERIFY( get_nb_bucket_elems(m1) == m1.size() );\n+  VERIFY( distance(m1.begin(), m1.end()) == m1.size() );\n   iterator it1 = m1.find(\"eeilo\");\n   VERIFY( it1 == m1.end() );\n \n   VERIFY( m1.erase(\"tillsammans\") == 1 );\n   VERIFY( m1.size() == 8 );\n+  VERIFY( get_nb_bucket_elems(m1) == m1.size() );\n+  VERIFY( distance(m1.begin(), m1.end()) == m1.size() );\n   iterator it2 = m1.find(\"tillsammans\");\n   VERIFY( it2 == m1.end() );\n \n@@ -61,17 +79,23 @@ void test01()\n   VERIFY( it3 != m1.end() );\n   VERIFY( m1.erase(it3->first) == 1 );\n   VERIFY( m1.size() == 7 );\n+  VERIFY( get_nb_bucket_elems(m1) == m1.size() );\n+  VERIFY( distance(m1.begin(), m1.end()) == m1.size() );\n   it3 = m1.find(\"belonging (no longer mix)\");\n   VERIFY( it3 == m1.end() );\n \n   VERIFY( !m1.erase(\"abra\") );\n   VERIFY( m1.size() == 7 );\n+  VERIFY( get_nb_bucket_elems(m1) == m1.size() );\n+  VERIFY( distance(m1.begin(), m1.end()) == m1.size() );\n \n   VERIFY( !m1.erase(\"eeilo\") );\n   VERIFY( m1.size() == 7 );\n \n   VERIFY( m1.erase(\"because to why\") == 1 );\n   VERIFY( m1.size() == 6 );\n+  VERIFY( get_nb_bucket_elems(m1) == m1.size() );\n+  VERIFY( distance(m1.begin(), m1.end()) == m1.size() );\n   iterator it4 = m1.find(\"because to why\");\n   VERIFY( it4 == m1.end() );\n \n@@ -87,11 +111,15 @@ void test01()\n \n   VERIFY( m1.erase(it5->first) == 1 );\n   VERIFY( m1.size() == 5 );\n+  VERIFY( get_nb_bucket_elems(m1) == m1.size() );\n+  VERIFY( distance(m1.begin(), m1.end()) == m1.size() );\n   it5 = m1.find(\"umbra/penumbra\");\n   VERIFY( it5 == m1.end() );\n \n   VERIFY( m1.erase(it6->first) == 1 );\n   VERIFY( m1.size() == 4 );\n+  VERIFY( get_nb_bucket_elems(m1) == m1.size() );\n+  VERIFY( distance(m1.begin(), m1.end()) == m1.size() );\n   it6 = m1.find(\"one line behind\");\n   VERIFY( it6 == m1.end() );\n \n@@ -103,22 +131,30 @@ void test01()\n \n   VERIFY( m1.erase(it8->first) == 1 );\n   VERIFY( m1.size() == 3 );\n+  VERIFY( get_nb_bucket_elems(m1) == m1.size() );\n+  VERIFY( distance(m1.begin(), m1.end()) == m1.size() );\n   VERIFY( ++it7 == it9 );\n \n   iterator it10 = it9;\n   ++it10;\n   iterator it11 = it10;\n \n   VERIFY( m1.erase(it9->first) == 1 );\n+  VERIFY( get_nb_bucket_elems(m1) == m1.size() );\n+  VERIFY( distance(m1.begin(), m1.end()) == m1.size() );\n   VERIFY( m1.size() == 2 );\n   VERIFY( ++it10 == m1.end() );\n \n   VERIFY( m1.erase(m1.begin()) != m1.end() );  \n   VERIFY( m1.size() == 1 );\n+  VERIFY( get_nb_bucket_elems(m1) == m1.size() );\n+  VERIFY( distance(m1.begin(), m1.end()) == m1.size() );\n   VERIFY( m1.begin() == it11 );\n \n   VERIFY( m1.erase(m1.begin()->first) == 1 );  \n   VERIFY( m1.size() == 0 );\n+  VERIFY( get_nb_bucket_elems(m1) == m1.size() );\n+  VERIFY( distance(m1.begin(), m1.end()) == m1.size() );\n   VERIFY( m1.begin() == m1.end() );\n }\n "}, {"sha": "c599cc01a73f48402fd6194f7a82e74d524dd7ea", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/erase/1.cc", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40207762a82f9d6fde9a9ac529ea3a170dac1a91/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Ferase%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40207762a82f9d6fde9a9ac529ea3a170dac1a91/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Ferase%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Ferase%2F1.cc?ref=40207762a82f9d6fde9a9ac529ea3a170dac1a91", "patch": "@@ -23,6 +23,18 @@\n #include <string>\n #include <testsuite_hooks.h>\n \n+namespace\n+{\n+  std::size_t\n+  get_nb_bucket_elems(const std::unordered_multimap<std::string, int>& us)\n+  {\n+    std::size_t nb = 0;\n+    for (std::size_t b = 0; b != us.bucket_count(); ++b)\n+      nb += us.bucket_size(b);\n+    return nb;\n+  }\n+}\n+\n void test01()\n {\n   bool test __attribute__((unused)) = true;\n@@ -46,14 +58,20 @@ void test01()\n   mm1.insert(value_type(\"one line behind\", 10));\n   mm1.insert(value_type(\"because to why\", 11));\n   VERIFY( mm1.size() == 11 );\n+  VERIFY( get_nb_bucket_elems(mm1) == mm1.size() );\n+  VERIFY( distance(mm1.begin(), mm1.end()) == mm1.size() );\n \n   VERIFY( mm1.erase(\"eeilo\") == 1 );\n   VERIFY( mm1.size() == 10 );\n+  VERIFY( get_nb_bucket_elems(mm1) == mm1.size() );\n+  VERIFY( distance(mm1.begin(), mm1.end()) == mm1.size() );\n   iterator it1 = mm1.find(\"eeilo\");\n   VERIFY( it1 == mm1.end() );\n \n   VERIFY( mm1.erase(\"tillsammans\") == 1 );\n   VERIFY( mm1.size() == 9 );\n+  VERIFY( get_nb_bucket_elems(mm1) == mm1.size() );\n+  VERIFY( distance(mm1.begin(), mm1.end()) == mm1.size() );\n   iterator it2 = mm1.find(\"tillsammans\");\n   VERIFY( it2 == mm1.end() );\n \n@@ -62,17 +80,23 @@ void test01()\n   VERIFY( it3 != mm1.end() );\n   VERIFY( mm1.erase(it3->first) == 1 );\n   VERIFY( mm1.size() == 8 );\n+  VERIFY( get_nb_bucket_elems(mm1) == mm1.size() );\n+  VERIFY( distance(mm1.begin(), mm1.end()) == mm1.size() );\n   it3 = mm1.find(\"belonging (no longer mix)\");\n   VERIFY( it3 == mm1.end() );\n \n   VERIFY( !mm1.erase(\"abra\") );\n   VERIFY( mm1.size() == 8 );\n+  VERIFY( get_nb_bucket_elems(mm1) == mm1.size() );\n+  VERIFY( distance(mm1.begin(), mm1.end()) == mm1.size() );\n \n   VERIFY( !mm1.erase(\"eeilo\") );\n   VERIFY( mm1.size() == 8 );\n \n   VERIFY( mm1.erase(\"because to why\") == 2 );\n   VERIFY( mm1.size() == 6 );\n+  VERIFY( get_nb_bucket_elems(mm1) == mm1.size() );\n+  VERIFY( distance(mm1.begin(), mm1.end()) == mm1.size() );\n   iterator it4 = mm1.find(\"because to why\");\n   VERIFY( it4 == mm1.end() );\n \n@@ -88,11 +112,15 @@ void test01()\n \n   VERIFY( mm1.erase(it5->first) == 1 );\n   VERIFY( mm1.size() == 5 );\n+  VERIFY( get_nb_bucket_elems(mm1) == mm1.size() );\n+  VERIFY( distance(mm1.begin(), mm1.end()) == mm1.size() );\n   it5 = mm1.find(\"umbra/penumbra\");\n   VERIFY( it5 == mm1.end() );\n \n   VERIFY( mm1.erase(it6->first) == 1 );\n   VERIFY( mm1.size() == 4 );\n+  VERIFY( get_nb_bucket_elems(mm1) == mm1.size() );\n+  VERIFY( distance(mm1.begin(), mm1.end()) == mm1.size() );\n   it6 = mm1.find(\"one line behind\");\n   VERIFY( it6 == mm1.end() );\n \n@@ -104,22 +132,30 @@ void test01()\n \n   VERIFY( mm1.erase(it8->first) == 1 );\n   VERIFY( mm1.size() == 3 );\n+  VERIFY( get_nb_bucket_elems(mm1) == mm1.size() );\n+  VERIFY( distance(mm1.begin(), mm1.end()) == mm1.size() );\n   VERIFY( ++it7 == it9 );\n \n   iterator it10 = it9;\n   ++it10;\n   iterator it11 = it10;\n \n   VERIFY( mm1.erase(it9->first) == 1 );\n+  VERIFY( get_nb_bucket_elems(mm1) == mm1.size() );\n+  VERIFY( distance(mm1.begin(), mm1.end()) == mm1.size() );\n   VERIFY( mm1.size() == 2 );\n   VERIFY( ++it10 == mm1.end() );\n \n   VERIFY( mm1.erase(mm1.begin()) != mm1.end() );  \n   VERIFY( mm1.size() == 1 );\n+  VERIFY( get_nb_bucket_elems(mm1) == mm1.size() );\n+  VERIFY( distance(mm1.begin(), mm1.end()) == mm1.size() );\n   VERIFY( mm1.begin() == it11 );\n \n   VERIFY( mm1.erase(mm1.begin()->first) == 1 );  \n   VERIFY( mm1.size() == 0 );\n+  VERIFY( get_nb_bucket_elems(mm1) == mm1.size() );\n+  VERIFY( distance(mm1.begin(), mm1.end()) == mm1.size() );\n   VERIFY( mm1.begin() == mm1.end() );\n }\n "}, {"sha": "df73a85dcc15065097b38b52335f8a0752400217", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/erase/2.cc", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40207762a82f9d6fde9a9ac529ea3a170dac1a91/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Ferase%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40207762a82f9d6fde9a9ac529ea3a170dac1a91/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Ferase%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Ferase%2F2.cc?ref=40207762a82f9d6fde9a9ac529ea3a170dac1a91", "patch": "@@ -0,0 +1,90 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_map>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+namespace\n+{\n+  std::size_t\n+  get_nb_bucket_elems(const std::unordered_multimap<std::string, int>& um)\n+  {\n+    std::size_t nb = 0;\n+    for (std::size_t b = 0; b != um.bucket_count(); ++b)\n+      nb += um.bucket_size(b);\n+    return nb;\n+  }\n+}\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef std::unordered_multimap<std::string, int> Mmap;\n+  typedef Mmap::iterator       iterator;\n+  typedef Mmap::const_iterator const_iterator;\n+  typedef Mmap::value_type     value_type;\n+\n+  Mmap mm1;\n+  \n+  mm1.insert(value_type(\"foo\", 10));\n+  mm1.insert(value_type(\"foo\", 11));\n+  mm1.insert(value_type(\"foo\", 12));\n+  mm1.insert(value_type(\"foo\", 13));\n+  mm1.insert(value_type(\"foo\", 14));\n+  mm1.insert(value_type(\"foo\", 15));\n+  mm1.insert(value_type(\"bar\", 20));\n+  mm1.insert(value_type(\"bar\", 21));\n+  mm1.insert(value_type(\"bar\", 22));\n+  mm1.insert(value_type(\"bar\", 23));\n+  mm1.insert(value_type(\"bar\", 24));\n+  mm1.insert(value_type(\"bar\", 25));\n+  VERIFY( mm1.size() == 12 );\n+  VERIFY( get_nb_bucket_elems(mm1) == mm1.size() );\n+  VERIFY( distance(mm1.begin(), mm1.end()) == mm1.size() );\n+\n+  VERIFY( mm1.erase(mm1.begin()) != mm1.end() );\n+  VERIFY( mm1.size() == 11 );\n+  VERIFY( get_nb_bucket_elems(mm1) == mm1.size() );\n+  VERIFY( distance(mm1.begin(), mm1.end()) == mm1.size() );\n+\n+  auto it = mm1.begin();\n+  advance(it, 2);\n+  VERIFY( mm1.erase(mm1.begin(), it) != mm1.end() );\n+  VERIFY( mm1.size() == 9 );\n+  VERIFY( get_nb_bucket_elems(mm1) == mm1.size() );\n+  VERIFY( distance(mm1.begin(), mm1.end()) == mm1.size() );\n+\n+  VERIFY( mm1.erase(mm1.begin()->first) == 3 );\n+  VERIFY( mm1.size() == 6 );\n+  VERIFY( get_nb_bucket_elems(mm1) == mm1.size() );\n+  VERIFY( distance(mm1.begin(), mm1.end()) == mm1.size() );\n+\n+  VERIFY( mm1.erase(mm1.begin(), mm1.end()) == mm1.end() );\n+  VERIFY( mm1.empty() );\n+  VERIFY( get_nb_bucket_elems(mm1) == mm1.size() );\n+  VERIFY( distance(mm1.begin(), mm1.end()) == mm1.size() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "b95c8a38706a90d748f738d211213c3546b582be", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/erase/1.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40207762a82f9d6fde9a9ac529ea3a170dac1a91/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Ferase%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40207762a82f9d6fde9a9ac529ea3a170dac1a91/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Ferase%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Ferase%2F1.cc?ref=40207762a82f9d6fde9a9ac529ea3a170dac1a91", "patch": "@@ -58,16 +58,19 @@ void test01()\n   ms1.insert(\"because to why\");\n   VERIFY( ms1.size() == 11 );\n   VERIFY( get_nb_bucket_elems(ms1) == ms1.size() );\n+  VERIFY( distance(ms1.begin(), ms1.end()) == ms1.size() );\n \n   VERIFY( ms1.erase(\"eeilo\") == 1 );\n   VERIFY( ms1.size() == 10 );\n   VERIFY( get_nb_bucket_elems(ms1) == ms1.size() );\n+  VERIFY( distance(ms1.begin(), ms1.end()) == ms1.size() );\n   iterator it1 = ms1.find(\"eeilo\");\n   VERIFY( it1 == ms1.end() );\n \n   VERIFY( ms1.erase(\"tillsammans\") == 1 );\n   VERIFY( ms1.size() == 9 );\n   VERIFY( get_nb_bucket_elems(ms1) == ms1.size() );\n+  VERIFY( distance(ms1.begin(), ms1.end()) == ms1.size() );\n   iterator it2 = ms1.find(\"tillsammans\");\n   VERIFY( it2 == ms1.end() );\n \n@@ -77,19 +80,22 @@ void test01()\n   VERIFY( ms1.erase(*it3) == 1 );\n   VERIFY( ms1.size() == 8 );\n   VERIFY( get_nb_bucket_elems(ms1) == ms1.size() );\n+  VERIFY( distance(ms1.begin(), ms1.end()) == ms1.size() );\n   it3 = ms1.find(\"belonging (no longer mix)\");\n   VERIFY( it3 == ms1.end() );\n \n   VERIFY( !ms1.erase(\"abra\") );\n   VERIFY( ms1.size() == 8 );\n   VERIFY( get_nb_bucket_elems(ms1) == ms1.size() );\n+  VERIFY( distance(ms1.begin(), ms1.end()) == ms1.size() );\n \n   VERIFY( !ms1.erase(\"eeilo\") );\n   VERIFY( ms1.size() == 8 );\n \n   VERIFY( ms1.erase(\"because to why\") == 2 );\n   VERIFY( ms1.size() == 6 );\n   VERIFY( get_nb_bucket_elems(ms1) == ms1.size() );\n+  VERIFY( distance(ms1.begin(), ms1.end()) == ms1.size() );\n   iterator it4 = ms1.find(\"because to why\");\n   VERIFY( it4 == ms1.end() );\n \n@@ -106,12 +112,14 @@ void test01()\n   VERIFY( ms1.erase(*it5) == 1 );\n   VERIFY( ms1.size() == 5 );\n   VERIFY( get_nb_bucket_elems(ms1) == ms1.size() );\n+  VERIFY( distance(ms1.begin(), ms1.end()) == ms1.size() );\n   it5 = ms1.find(\"umbra/penumbra\");\n   VERIFY( it5 == ms1.end() );\n \n   VERIFY( ms1.erase(*it6) == 1 );\n   VERIFY( ms1.size() == 4 );\n   VERIFY( get_nb_bucket_elems(ms1) == ms1.size() );\n+  VERIFY( distance(ms1.begin(), ms1.end()) == ms1.size() );\n   it6 = ms1.find(\"one line behind\");\n   VERIFY( it6 == ms1.end() );\n \n@@ -124,6 +132,7 @@ void test01()\n   VERIFY( ms1.erase(*it8) == 1 );\n   VERIFY( ms1.size() == 3 );\n   VERIFY( get_nb_bucket_elems(ms1) == ms1.size() );\n+  VERIFY( distance(ms1.begin(), ms1.end()) == ms1.size() );\n   VERIFY( ++it7 == it9 );\n \n   iterator it10 = it9;\n@@ -132,17 +141,20 @@ void test01()\n \n   VERIFY( ms1.erase(*it9) == 1 );\n   VERIFY( get_nb_bucket_elems(ms1) == ms1.size() );\n+  VERIFY( distance(ms1.begin(), ms1.end()) == ms1.size() );\n   VERIFY( ms1.size() == 2 );\n   VERIFY( ++it10 == ms1.end() );\n \n   VERIFY( ms1.erase(ms1.begin()) != ms1.end() );  \n   VERIFY( ms1.size() == 1 );\n   VERIFY( get_nb_bucket_elems(ms1) == ms1.size() );\n+  VERIFY( distance(ms1.begin(), ms1.end()) == ms1.size() );\n   VERIFY( ms1.begin() == it11 );\n \n   VERIFY( ms1.erase(*ms1.begin()) == 1 );  \n   VERIFY( ms1.size() == 0 );\n   VERIFY( get_nb_bucket_elems(ms1) == ms1.size() );\n+  VERIFY( distance(ms1.begin(), ms1.end()) == ms1.size() );\n   VERIFY( ms1.begin() == ms1.end() );\n }\n "}, {"sha": "ad6cad4a00dfb4b314feb143be908884bd21c0ca", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/erase/2.cc", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40207762a82f9d6fde9a9ac529ea3a170dac1a91/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Ferase%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40207762a82f9d6fde9a9ac529ea3a170dac1a91/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Ferase%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Ferase%2F2.cc?ref=40207762a82f9d6fde9a9ac529ea3a170dac1a91", "patch": "@@ -0,0 +1,89 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_set>\n+#include <string>\n+#include <testsuite_hooks.h>\n+\n+namespace\n+{\n+  std::size_t\n+  get_nb_bucket_elems(const std::unordered_multiset<std::string>& us)\n+  {\n+    std::size_t nb = 0;\n+    for (std::size_t b = 0; b != us.bucket_count(); ++b)\n+      nb += us.bucket_size(b);\n+    return nb;\n+  }\n+}\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  \n+  typedef std::unordered_multiset<std::string> Mset;\n+  typedef Mset::iterator       iterator;\n+  typedef Mset::const_iterator const_iterator;\n+\n+  Mset ms1;\n+  \n+  ms1.insert(\"foo\");\n+  ms1.insert(\"foo\");\n+  ms1.insert(\"foo\");\n+  ms1.insert(\"foo\");\n+  ms1.insert(\"foo\");\n+  ms1.insert(\"foo\");\n+  ms1.insert(\"bar\");\n+  ms1.insert(\"bar\");\n+  ms1.insert(\"bar\");\n+  ms1.insert(\"bar\");\n+  ms1.insert(\"bar\");\n+  ms1.insert(\"bar\");\n+  VERIFY( ms1.size() == 12 );\n+  VERIFY( get_nb_bucket_elems(ms1) == ms1.size() );\n+  VERIFY( distance(ms1.begin(), ms1.end()) == ms1.size() );\n+\n+  VERIFY( ms1.erase(ms1.begin()) != ms1.end() );\n+  VERIFY( ms1.size() == 11 );\n+  VERIFY( get_nb_bucket_elems(ms1) == ms1.size() );\n+  VERIFY( distance(ms1.begin(), ms1.end()) == ms1.size() );\n+\n+  auto it = ms1.begin();\n+  advance(it, 2);\n+  VERIFY( ms1.erase(ms1.begin(), it) != ms1.end() );\n+  VERIFY( ms1.size() == 9 );\n+  VERIFY( get_nb_bucket_elems(ms1) == ms1.size() );\n+  VERIFY( distance(ms1.begin(), ms1.end()) == ms1.size() );\n+\n+  VERIFY( ms1.erase(*(ms1.begin())) == 3 );\n+  VERIFY( ms1.size() == 6 );\n+  VERIFY( get_nb_bucket_elems(ms1) == ms1.size() );\n+  VERIFY( distance(ms1.begin(), ms1.end()) == ms1.size() );\n+\n+  VERIFY( ms1.erase(ms1.begin(), ms1.end()) == ms1.end() );\n+  VERIFY( ms1.empty() );\n+  VERIFY( get_nb_bucket_elems(ms1) == ms1.size() );\n+  VERIFY( distance(ms1.begin(), ms1.end()) == ms1.size() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "cdefef2afc1d5a24bdcc34b27c94e36fb76777bd", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/erase/1.cc", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40207762a82f9d6fde9a9ac529ea3a170dac1a91/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Ferase%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40207762a82f9d6fde9a9ac529ea3a170dac1a91/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Ferase%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Ferase%2F1.cc?ref=40207762a82f9d6fde9a9ac529ea3a170dac1a91", "patch": "@@ -23,6 +23,18 @@\n #include <string>\n #include <testsuite_hooks.h>\n \n+namespace\n+{\n+  std::size_t\n+  get_nb_bucket_elems(const std::unordered_set<std::string>& us)\n+  {\n+    std::size_t nb = 0;\n+    for (std::size_t b = 0; b != us.bucket_count(); ++b)\n+      nb += us.bucket_size(b);\n+    return nb;\n+  }\n+}\n+\n void test01()\n {\n   bool test __attribute__((unused)) = true;\n@@ -44,14 +56,20 @@ void test01()\n   s1.insert(\"belonging (no longer mix)\");\n   s1.insert(\"one line behind\");\n   VERIFY( s1.size() == 10 );\n+  VERIFY( get_nb_bucket_elems(s1) == s1.size() );\n+  VERIFY( distance(s1.begin(), s1.end()) == s1.size() );\n \n   VERIFY( s1.erase(\"eeilo\") == 1 );\n   VERIFY( s1.size() == 9 );\n+  VERIFY( get_nb_bucket_elems(s1) == s1.size() );\n+  VERIFY( distance(s1.begin(), s1.end()) == s1.size() );\n   iterator it1 = s1.find(\"eeilo\");\n   VERIFY( it1 == s1.end() );\n \n   VERIFY( s1.erase(\"tillsammans\") == 1 );\n   VERIFY( s1.size() == 8 );\n+  VERIFY( get_nb_bucket_elems(s1) == s1.size() );\n+  VERIFY( distance(s1.begin(), s1.end()) == s1.size() );\n   iterator it2 = s1.find(\"tillsammans\");\n   VERIFY( it2 == s1.end() );\n \n@@ -60,17 +78,23 @@ void test01()\n   VERIFY( it3 != s1.end() );\n   VERIFY( s1.erase(*it3) == 1 );\n   VERIFY( s1.size() == 7 );\n+  VERIFY( get_nb_bucket_elems(s1) == s1.size() );\n+  VERIFY( distance(s1.begin(), s1.end()) == s1.size() );\n   it3 = s1.find(\"belonging (no longer mix)\");\n   VERIFY( it3 == s1.end() );\n \n   VERIFY( !s1.erase(\"abra\") );\n   VERIFY( s1.size() == 7 );\n+  VERIFY( get_nb_bucket_elems(s1) == s1.size() );\n+  VERIFY( distance(s1.begin(), s1.end()) == s1.size() );\n \n   VERIFY( !s1.erase(\"eeilo\") );\n   VERIFY( s1.size() == 7 );\n \n   VERIFY( s1.erase(\"because to why\") == 1 );\n   VERIFY( s1.size() == 6 );\n+  VERIFY( get_nb_bucket_elems(s1) == s1.size() );\n+  VERIFY( distance(s1.begin(), s1.end()) == s1.size() );\n   iterator it4 = s1.find(\"because to why\");\n   VERIFY( it4 == s1.end() );\n \n@@ -86,11 +110,15 @@ void test01()\n \n   VERIFY( s1.erase(*it5) == 1 );\n   VERIFY( s1.size() == 5 );\n+  VERIFY( get_nb_bucket_elems(s1) == s1.size() );\n+  VERIFY( distance(s1.begin(), s1.end()) == s1.size() );\n   it5 = s1.find(\"umbra/penumbra\");\n   VERIFY( it5 == s1.end() );\n \n   VERIFY( s1.erase(*it6) == 1 );\n   VERIFY( s1.size() == 4 );\n+  VERIFY( get_nb_bucket_elems(s1) == s1.size() );\n+  VERIFY( distance(s1.begin(), s1.end()) == s1.size() );\n   it6 = s1.find(\"one line behind\");\n   VERIFY( it6 == s1.end() );\n \n@@ -102,22 +130,30 @@ void test01()\n \n   VERIFY( s1.erase(*it8) == 1 );\n   VERIFY( s1.size() == 3 );\n+  VERIFY( get_nb_bucket_elems(s1) == s1.size() );\n+  VERIFY( distance(s1.begin(), s1.end()) == s1.size() );\n   VERIFY( ++it7 == it9 );\n \n   iterator it10 = it9;\n   ++it10;\n   iterator it11 = it10;\n \n   VERIFY( s1.erase(*it9) == 1 );\n+  VERIFY( get_nb_bucket_elems(s1) == s1.size() );\n+  VERIFY( distance(s1.begin(), s1.end()) == s1.size() );\n   VERIFY( s1.size() == 2 );\n   VERIFY( ++it10 == s1.end() );\n \n   VERIFY( s1.erase(s1.begin()) != s1.end() );  \n   VERIFY( s1.size() == 1 );\n+  VERIFY( get_nb_bucket_elems(s1) == s1.size() );\n+  VERIFY( distance(s1.begin(), s1.end()) == s1.size() );\n   VERIFY( s1.begin() == it11 );\n \n   VERIFY( s1.erase(*s1.begin()) == 1 );  \n   VERIFY( s1.size() == 0 );\n+  VERIFY( get_nb_bucket_elems(s1) == s1.size() );\n+  VERIFY( distance(s1.begin(), s1.end()) == s1.size() );\n   VERIFY( s1.begin() == s1.end() );\n }\n "}]}