{"sha": "008f6fd3f92a521324ba4fd26bd17aad0f7cbef5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA4ZjZmZDNmOTJhNTIxMzI0YmE0ZmQyNmJkMTdhYWQwZjdjYmVmNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-21T13:26:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-21T13:26:24Z"}, "message": "[multiple changes]\n\n2010-06-21  Pascal Obry  <obry@adacore.com>\n\n\t* prj-nmsc.adb (Search_Directories): Use the non-translated directory\n\tpath to open it.\n\n2010-06-21  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_cg.adb (Write_Call_Info): Fill the component sourcename using the\n\texternal name.\n\n2010-06-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch4.adb (Expand_Concatenate): If an object declaration is created\n\tto hold the result, indicate that the target of the declaration does\n\tnot need an initialization, to prevent spurious errors when\n\tInitialize_Scalars is enabled.\n\n2010-06-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* a-tifiio.adb (Put): In the procedure that performs I/O on a String,\n\tFore is not bound by line length. The Fore parameter of the internal\n\tprocedure that performs the operation is an integer.\n\n2010-06-21  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_res.adb, checks.adb: Minor reformatting.\n\n2010-06-21  Emmanuel Briot  <briot@adacore.com>\n\n\t* s-regpat.adb (Next_Instruction, Get_Next_Offset): Removed, merged\n\tinto Get_Next.\n\t(Insert_Operator_Before): New subprogram, avoids duplicated code\n\t(Compile): Avoid doing two compilations when the pattern matcher ends\n\tup being small.\n\nFrom-SVN: r161074", "tree": {"sha": "16da38487c1dbb96449cc09436baac0dc959fce1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16da38487c1dbb96449cc09436baac0dc959fce1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/008f6fd3f92a521324ba4fd26bd17aad0f7cbef5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/008f6fd3f92a521324ba4fd26bd17aad0f7cbef5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/008f6fd3f92a521324ba4fd26bd17aad0f7cbef5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/008f6fd3f92a521324ba4fd26bd17aad0f7cbef5/comments", "author": null, "committer": null, "parents": [{"sha": "0b33adf1a552da45bafde9a512d23330c449ecde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b33adf1a552da45bafde9a512d23330c449ecde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b33adf1a552da45bafde9a512d23330c449ecde"}], "stats": {"total": 325, "additions": 162, "deletions": 163}, "files": [{"sha": "71627b22ca40525aadf833985e66241897f5aa8c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/008f6fd3f92a521324ba4fd26bd17aad0f7cbef5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/008f6fd3f92a521324ba4fd26bd17aad0f7cbef5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=008f6fd3f92a521324ba4fd26bd17aad0f7cbef5", "patch": "@@ -1,3 +1,38 @@\n+2010-06-21  Pascal Obry  <obry@adacore.com>\n+\n+\t* prj-nmsc.adb (Search_Directories): Use the non-translated directory\n+\tpath to open it.\n+\n+2010-06-21  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_cg.adb (Write_Call_Info): Fill the component sourcename using the\n+\texternal name.\n+\n+2010-06-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_Concatenate): If an object declaration is created\n+\tto hold the result, indicate that the target of the declaration does\n+\tnot need an initialization, to prevent spurious errors when\n+\tInitialize_Scalars is enabled.\n+\n+2010-06-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* a-tifiio.adb (Put): In the procedure that performs I/O on a String,\n+\tFore is not bound by line length. The Fore parameter of the internal\n+\tprocedure that performs the operation is an integer.\n+\n+2010-06-21  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_res.adb, checks.adb: Minor reformatting.\n+\n+2010-06-21  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* s-regpat.adb (Next_Instruction, Get_Next_Offset): Removed, merged\n+\tinto Get_Next.\n+\t(Insert_Operator_Before): New subprogram, avoids duplicated code\n+\t(Compile): Avoid doing two compilations when the pattern matcher ends\n+\tup being small.\n+\n 2010-06-21  Emmanuel Briot  <briot@adacore.com>\n \n \t* s-regpat.adb: Improve debug traces"}, {"sha": "28267ad85fcd82c3255ac8294a2fd26fb1a6493f", "filename": "gcc/ada/a-tifiio.adb", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/008f6fd3f92a521324ba4fd26bd17aad0f7cbef5/gcc%2Fada%2Fa-tifiio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/008f6fd3f92a521324ba4fd26bd17aad0f7cbef5/gcc%2Fada%2Fa-tifiio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tifiio.adb?ref=008f6fd3f92a521324ba4fd26bd17aad0f7cbef5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -301,10 +301,14 @@ package body Ada.Text_IO.Fixed_IO is\n      (To   : out String;\n       Last : out Natural;\n       Item : Num;\n-      Fore : Field;\n+      Fore : Integer;\n       Aft  : Field;\n       Exp  : Field);\n    --  Actual output function, used internally by all other Put routines\n+   --  The formal Fore is an Integer, not a Field, because the routine is\n+   --  also called from the version of Put that performs I/O to a string,\n+   --  where the starting position depends on the size of the String, and\n+   --  bears no relation to the bounds of Field.\n \n    ---------\n    -- Get --\n@@ -392,7 +396,7 @@ package body Ada.Text_IO.Fixed_IO is\n       Last : Natural;\n \n    begin\n-      if Fore - Boolean'Pos (Item < 0.0) < 1 or else Fore > Field'Last then\n+      if Fore - Boolean'Pos (Item < 0.0) < 1 then\n          raise Layout_Error;\n       end if;\n \n@@ -407,7 +411,7 @@ package body Ada.Text_IO.Fixed_IO is\n      (To   : out String;\n       Last : out Natural;\n       Item : Num;\n-      Fore : Field;\n+      Fore : Integer;\n       Aft  : Field;\n       Exp  : Field)\n    is"}, {"sha": "0f18fbc582348a9d2d0b4f778f92756fc2bbdb61", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/008f6fd3f92a521324ba4fd26bd17aad0f7cbef5/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/008f6fd3f92a521324ba4fd26bd17aad0f7cbef5/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=008f6fd3f92a521324ba4fd26bd17aad0f7cbef5", "patch": "@@ -6477,7 +6477,7 @@ package body Checks is\n                      --  current discriminal, which is the renaming within\n                      --  the task body.\n \n-                     Disc :=  First_Discriminant (Tsk);\n+                     Disc := First_Discriminant (Tsk);\n                      while Present (Disc) loop\n                         if Chars (Disc) = Chars (Entity (Bound)) then\n                            Set_Scope (Discriminal (Disc), Tsk);"}, {"sha": "fcfbb263ac3613a31bf483e5b2960929663ff0f7", "filename": "gcc/ada/exp_cg.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/008f6fd3f92a521324ba4fd26bd17aad0f7cbef5/gcc%2Fada%2Fexp_cg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/008f6fd3f92a521324ba4fd26bd17aad0f7cbef5/gcc%2Fada%2Fexp_cg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_cg.adb?ref=008f6fd3f92a521324ba4fd26bd17aad0f7cbef5", "patch": "@@ -28,6 +28,7 @@ with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Exp_Disp; use Exp_Disp;\n+with Exp_Dbug; use Exp_Dbug;\n with Exp_Tss;  use Exp_Tss;\n with Lib;      use Lib;\n with Namet;    use Namet;\n@@ -392,7 +393,8 @@ package body Exp_CG is\n \n       Write_Str (\"edge: { sourcename: \");\n       Write_Char ('\"');\n-      Write_Name (Chars (Defining_Entity (P)));\n+      Get_External_Name (Defining_Entity (P), Has_Suffix => False);\n+      Write_Str (Name_Buffer (1 .. Name_Len));\n \n       if Nkind (P) = N_Package_Declaration then\n          Write_Str (\"___elabs\");"}, {"sha": "c19024aa44be11b6b600db1721e34cd841c0d4f2", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/008f6fd3f92a521324ba4fd26bd17aad0f7cbef5/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/008f6fd3f92a521324ba4fd26bd17aad0f7cbef5/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=008f6fd3f92a521324ba4fd26bd17aad0f7cbef5", "patch": "@@ -2827,8 +2827,11 @@ package body Exp_Ch4 is\n       Insert_Actions (Cnode, Actions, Suppress => All_Checks);\n \n       --  Now we construct an array object with appropriate bounds\n+      --  The target is marked as internal, to prevent useless initialization\n+      --  when Initialize_Scalars is enabled.\n \n       Ent := Make_Temporary (Loc, 'S');\n+      Set_Is_Internal (Ent);\n \n       --  If the bound is statically known to be out of range, we do not want\n       --  to abort, we want a warning and a runtime constraint error. Note that"}, {"sha": "9e114f6ae8d709f892343cc2ed31994ad9274037", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/008f6fd3f92a521324ba4fd26bd17aad0f7cbef5/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/008f6fd3f92a521324ba4fd26bd17aad0f7cbef5/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=008f6fd3f92a521324ba4fd26bd17aad0f7cbef5", "patch": "@@ -4788,8 +4788,8 @@ package body Prj.Nmsc is\n    ---------------------\n \n    procedure Get_Directories\n-     (Project     : Project_Id;\n-      Data        : in out Tree_Processing_Data)\n+     (Project : Project_Id;\n+      Data    : in out Tree_Processing_Data)\n    is\n       package Recursive_Dirs is new GNAT.Dynamic_HTables.Simple_HTable\n         (Header_Num => Header_Num,\n@@ -6839,12 +6839,18 @@ package body Prj.Nmsc is\n                declare\n                   --  We use Element.Value, not Display_Value, because we want\n                   --  the symbolic links to be resolved when appropriate.\n-                  Source_Directory : constant String :=\n-                                       Get_Name_String (Element.Value)\n-                                         & Directory_Separator;\n-                  Dir_Last : constant Natural :=\n-                                       Compute_Directory_Last\n-                                         (Source_Directory);\n+                  Source_Directory         : constant String :=\n+                                               Get_Name_String (Element.Value)\n+                                                 & Directory_Separator;\n+                  Dir_Last                 : constant Natural :=\n+                                               Compute_Directory_Last\n+                                                 (Source_Directory);\n+                  --  The Display_Source_Directory is to be able to open an\n+                  --  UTF-8 encoded directory on Windows.\n+                  Display_Source_Directory : constant String :=\n+                                               Get_Name_String\n+                                                 (Element.Display_Value)\n+                                                  & Directory_Separator;\n \n                begin\n                   if Current_Verbosity = High then\n@@ -6856,7 +6862,7 @@ package body Prj.Nmsc is\n \n                   --  We look to every entry in the source directory\n \n-                  Open (Dir, Source_Directory);\n+                  Open (Dir, Display_Source_Directory);\n \n                   loop\n                      Read (Dir, Name, Last);\n@@ -6871,7 +6877,7 @@ package body Prj.Nmsc is\n \n                      if not Opt.Follow_Links_For_Files\n                        or else Is_Regular_File\n-                                 (Source_Directory & Name (1 .. Last))\n+                                 (Display_Source_Directory & Name (1 .. Last))\n                      then\n                         if Current_Verbosity = High then\n                            Write_Str  (\"   Checking \");"}, {"sha": "517256aff7725a1fd0f3e9eeef889589b139c89b", "filename": "gcc/ada/s-regpat.adb", "status": "modified", "additions": 95, "deletions": 146, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/008f6fd3f92a521324ba4fd26bd17aad0f7cbef5/gcc%2Fada%2Fs-regpat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/008f6fd3f92a521324ba4fd26bd17aad0f7cbef5/gcc%2Fada%2Fs-regpat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-regpat.adb?ref=008f6fd3f92a521324ba4fd26bd17aad0f7cbef5", "patch": "@@ -50,13 +50,6 @@ package body System.Regpat is\n    Debug : constant Boolean := False;\n    --  Set to True to activate debug traces\n \n-   MAGIC : constant Character := Character'Val (10#0234#);\n-   --  The first byte of the regexp internal \"program\" is actually\n-   --  this magic number; the start node begins in the second byte.\n-   --\n-   --  This is used to make sure that a regular expression was correctly\n-   --  compiled.\n-\n    ----------------------------\n    -- Implementation details --\n    ----------------------------\n@@ -79,21 +72,19 @@ package body System.Regpat is\n    --  You can see the exact byte-compiled version by using the Dump\n    --  subprogram. However, here are a few examples:\n \n-   --  (a|b):  1 : MAGIC\n-   --          2 : BRANCH  (next at  10)\n-   --          5 :    EXACT  (next at  18)   operand=a\n-   --         10 : BRANCH  (next at  18)\n-   --         13 :    EXACT  (next at  18)   operand=b\n-   --         18 : EOP  (next at 0)\n+   --  (a|b):  1 : BRANCH  (next at  9)\n+   --          4 :    EXACT  (next at  17)   operand=a\n+   --          9 : BRANCH  (next at  17)\n+   --         12 :    EXACT  (next at  17)   operand=b\n+   --         17 : EOP  (next at 0)\n    --\n-   --  (ab)*:  1 : MAGIC\n-   --          2 : CURLYX  (next at  26)  { 0, 32767}\n-   --          9 :    OPEN 1  (next at  13)\n-   --         13 :       EXACT  (next at  19)   operand=ab\n-   --         19 :    CLOSE 1  (next at  23)\n-   --         23 :    WHILEM  (next at 0)\n-   --         26 : NOTHING  (next at  29)\n-   --         29 : EOP  (next at 0)\n+   --  (ab)*:  1 : CURLYX  (next at  25)  { 0, 32767}\n+   --          8 :    OPEN 1  (next at  12)\n+   --         12 :       EXACT  (next at  18)   operand=ab\n+   --         18 :    CLOSE 1  (next at  22)\n+   --         22 :    WHILEM  (next at 0)\n+   --         25 : NOTHING  (next at  28)\n+   --         28 : EOP  (next at 0)\n \n    --  The opcodes are:\n \n@@ -282,11 +273,6 @@ package body System.Regpat is\n       Op      : out Character_Class);\n    --  Return a pointer to the string argument of the node at P\n \n-   function Get_Next_Offset\n-     (Program : Program_Data;\n-      IP      : Pointer) return Pointer;\n-   --  Get the offset field of a node. Used by Get_Next\n-\n    function Get_Next\n      (Program : Program_Data;\n       IP      : Pointer) return Pointer;\n@@ -306,7 +292,6 @@ package body System.Regpat is\n    pragma Inline (Is_Alnum);\n    pragma Inline (Is_White_Space);\n    pragma Inline (Get_Next);\n-   pragma Inline (Get_Next_Offset);\n    pragma Inline (Operand);\n    pragma Inline (Read_Natural);\n    pragma Inline (String_Length);\n@@ -389,7 +374,6 @@ package body System.Regpat is\n       PM        : Pattern_Matcher renames Matcher;\n       Program   : Program_Data renames PM.Program;\n \n-      Emit_Code : constant Boolean := PM.Size > 0;\n       Emit_Ptr  : Pointer := Program_First;\n \n       Parse_Pos : Natural := Expression'First; -- Input-scan pointer\n@@ -456,6 +440,17 @@ package body System.Regpat is\n       --  This applies to PLUS and STAR.\n       --  If Minmod is True, then the operator is non-greedy.\n \n+      function Insert_Operator_Before\n+        (Op      : Opcode;\n+         Operand : Pointer;\n+         Greedy  : Boolean;\n+         Opsize  : Pointer) return Pointer;\n+      --  Insert an operator before Operand (and move the latter forward in the\n+      --  program). Opsize is the size needed to represent the operator.\n+      --  This returns the position at which the operator was\n+      --  inserted, and moves Emit_Ptr after the new position of the\n+      --  operand.\n+\n       procedure Insert_Curly_Operator\n         (Op      : Opcode;\n          Min     : Natural;\n@@ -471,9 +466,6 @@ package body System.Regpat is\n       procedure Link_Operand_Tail (P, Val : Pointer);\n       --  Link_Tail on operand of first argument; noop if operand-less\n \n-      function  Next_Instruction (P : Pointer) return Pointer;\n-      --  Dig the \"next\" pointer out of a node\n-\n       procedure Fail (M : String);\n       pragma No_Return (Fail);\n       --  Fail with a diagnostic message, if possible\n@@ -533,7 +525,7 @@ package body System.Regpat is\n \n       procedure Emit (B : Character) is\n       begin\n-         if Emit_Code then\n+         if Emit_Ptr <= PM.Size then\n             Program (Emit_Ptr) := B;\n          end if;\n \n@@ -551,7 +543,7 @@ package body System.Regpat is\n            (Character_Class, Program31);\n \n       begin\n-         if Emit_Code then\n+         if Emit_Ptr + 31 <= PM.Size then\n             Program (Emit_Ptr .. Emit_Ptr + 31) := Convert (Bitmap);\n          end if;\n \n@@ -564,7 +556,7 @@ package body System.Regpat is\n \n       procedure Emit_Natural (IP : Pointer; N : Natural) is\n       begin\n-         if Emit_Code then\n+         if IP + 1 <= PM.Size then\n             Program (IP + 1) := Character'Val (N / 256);\n             Program (IP) := Character'Val (N mod 256);\n          end if;\n@@ -578,7 +570,7 @@ package body System.Regpat is\n          Result : constant Pointer := Emit_Ptr;\n \n       begin\n-         if Emit_Code then\n+         if Emit_Ptr + 2 <= PM.Size then\n             Program (Emit_Ptr) := Character'Val (Opcode'Pos (Op));\n             Program (Emit_Ptr + 1) := ASCII.NUL;\n             Program (Emit_Ptr + 2) := ASCII.NUL;\n@@ -659,12 +651,29 @@ package body System.Regpat is\n          Operand : Pointer;\n          Greedy  : Boolean := True)\n       is\n-         Dest   : constant Pointer := Emit_Ptr;\n          Old    : Pointer;\n-         Size   : Pointer := 7;\n+      begin\n+         Old := Insert_Operator_Before (Op, Operand, Greedy, Opsize => 7);\n+         Emit_Natural (Old + 3, Min);\n+         Emit_Natural (Old + 5, Max);\n+      end Insert_Curly_Operator;\n+\n+      ----------------------------\n+      -- Insert_Operator_Before --\n+      ----------------------------\n+\n+      function Insert_Operator_Before\n+        (Op      : Opcode;\n+         Operand : Pointer;\n+         Greedy  : Boolean;\n+         Opsize  : Pointer) return Pointer\n+      is\n+         Dest : constant Pointer := Emit_Ptr;\n+         Old  : Pointer;\n+         Size : Pointer := Opsize;\n \n       begin\n-         --  If the operand is not greedy, insert an extra operand before it\n+         --  If not greedy, we have to emit another opcode first\n \n          if not Greedy then\n             Size := Size + 3;\n@@ -673,7 +682,7 @@ package body System.Regpat is\n          --  Move the operand in the byte-compilation, so that we can insert\n          --  the operator before it.\n \n-         if Emit_Code then\n+         if Emit_Ptr + Size <= PM.Size then\n             Program (Operand + Size .. Emit_Ptr + Size) :=\n               Program (Operand .. Emit_Ptr);\n          end if;\n@@ -689,11 +698,9 @@ package body System.Regpat is\n          end if;\n \n          Old := Emit_Node (Op);\n-         Emit_Natural (Old + 3, Min);\n-         Emit_Natural (Old + 5, Max);\n-\n          Emit_Ptr := Dest + Size;\n-      end Insert_Curly_Operator;\n+         return Old;\n+      end Insert_Operator_Before;\n \n       ---------------------\n       -- Insert_Operator --\n@@ -704,40 +711,10 @@ package body System.Regpat is\n          Operand : Pointer;\n          Greedy  : Boolean := True)\n       is\n-         Dest : constant Pointer := Emit_Ptr;\n-         Old  : Pointer;\n-         Size : Pointer := 3;\n-\n          Discard : Pointer;\n          pragma Warnings (Off, Discard);\n-\n       begin\n-         --  If not greedy, we have to emit another opcode first\n-\n-         if not Greedy then\n-            Size := Size + 3;\n-         end if;\n-\n-         --  Move the operand in the byte-compilation, so that we can insert\n-         --  the operator before it.\n-\n-         if Emit_Code then\n-            Program (Operand + Size .. Emit_Ptr + Size) :=\n-              Program (Operand .. Emit_Ptr);\n-         end if;\n-\n-         --  Insert the operator at the position previously occupied by the\n-         --  operand.\n-\n-         Emit_Ptr := Operand;\n-\n-         if not Greedy then\n-            Old := Emit_Node (MINMOD);\n-            Link_Tail (Old, Old + 3);\n-         end if;\n-\n-         Discard := Emit_Node (Op);\n-         Emit_Ptr := Dest + Size;\n+         Discard := Insert_Operator_Before (Op, Operand, Greedy, Opsize => 3);\n       end Insert_Operator;\n \n       -----------------------\n@@ -804,7 +781,7 @@ package body System.Regpat is\n \n       procedure Link_Operand_Tail (P, Val : Pointer) is\n       begin\n-         if Emit_Code and then Program (P) = BRANCH then\n+         if Program (P) = BRANCH then\n             Link_Tail (Operand (P), Val);\n          end if;\n       end Link_Operand_Tail;\n@@ -819,16 +796,16 @@ package body System.Regpat is\n          Offset : Pointer;\n \n       begin\n-         if not Emit_Code then\n+         if Emit_Ptr > PM.Size then\n             return;\n          end if;\n \n          --  Find last node\n \n          Scan := P;\n          loop\n-            Temp := Next_Instruction (Scan);\n-            exit when Temp = 0;\n+            Temp := Get_Next (Program, Scan);\n+            exit when Temp = Scan;\n             Scan := Temp;\n          end loop;\n \n@@ -837,27 +814,6 @@ package body System.Regpat is\n          Emit_Natural (Scan + 1, Natural (Offset));\n       end Link_Tail;\n \n-      ----------------------\n-      -- Next_Instruction --\n-      ----------------------\n-\n-      function Next_Instruction (P : Pointer) return Pointer is\n-         Offset : Pointer;\n-\n-      begin\n-         if not Emit_Code then\n-            return 0;\n-         end if;\n-\n-         Offset := Get_Next_Offset (Program, P);\n-\n-         if Offset = 0 then\n-            return 0;\n-         end if;\n-\n-         return P + Offset;\n-      end Next_Instruction;\n-\n       -----------\n       -- Parse --\n       -----------\n@@ -873,7 +829,7 @@ package body System.Regpat is\n          IP             : out Pointer)\n       is\n          E              : String renames Expression;\n-         Br             : Pointer;\n+         Br, Br2        : Pointer;\n          Ender          : Pointer;\n          Par_No         : Natural;\n          New_Flags      : Expression_Flags;\n@@ -964,9 +920,10 @@ package body System.Regpat is\n \n             Br := IP;\n             loop\n-               exit when Br = 0;\n                Link_Operand_Tail (Br, Ender);\n-               Br := Next_Instruction (Br);\n+               Br2 := Get_Next (Program, Br);\n+               exit when Br2 = Br;\n+               Br := Br2;\n             end loop;\n          end if;\n \n@@ -1665,7 +1622,7 @@ package body System.Regpat is\n             Parse_Pos := Start_Pos;\n          end if;\n \n-         if Emit_Code then\n+         if Length_Ptr <= PM.Size then\n             Program (Length_Ptr) := Character'Val (Emit_Ptr - Length_Ptr - 2);\n          end if;\n \n@@ -2007,7 +1964,6 @@ package body System.Regpat is\n    --  Start of processing for Compile\n \n    begin\n-      Emit (MAGIC);\n       Parse (False, Expr_Flags, Result);\n \n       if Result = 0 then\n@@ -2019,7 +1975,7 @@ package body System.Regpat is\n       --  Do we want to actually compile the expression, or simply get the\n       --  code size ???\n \n-      if Emit_Code then\n+      if Emit_Ptr <= PM.Size then\n          Optimize (PM);\n       end if;\n \n@@ -2030,19 +1986,37 @@ package body System.Regpat is\n      (Expression : String;\n       Flags      : Regexp_Flags := No_Flags) return Pattern_Matcher\n    is\n+      --  Assume the compiled regexp will fit in 1000 chars. If it does not\n+      --  we will have to compile a second time once the correct size is\n+      --  known. If it fits, we save a significant amount of time by avoiding\n+      --  the second compilation.\n+      Dummy : Pattern_Matcher (1000);\n       Size  : Program_Size;\n-      Dummy : Pattern_Matcher (0);\n-      pragma Unreferenced (Dummy);\n \n    begin\n       Compile (Dummy, Expression, Size, Flags);\n \n-      declare\n-         Result : Pattern_Matcher (Size);\n-      begin\n-         Compile (Result, Expression, Size, Flags);\n-         return Result;\n-      end;\n+      if Size <= Dummy.Size then\n+         return Pattern_Matcher'\n+           (Size             => Size,\n+            First            => Dummy.First,\n+            Anchored         => Dummy.Anchored,\n+            Must_Have        => Dummy.Must_Have,\n+            Must_Have_Length => Dummy.Must_Have_Length,\n+            Paren_Count      => Dummy.Paren_Count,\n+            Flags            => Dummy.Flags,\n+            Program          => Dummy.Program\n+              (Dummy.Program'First .. Dummy.Program'First + Size - 1));\n+      else\n+         --  We have to recompile now that we know the size\n+         --  ??? Can we use Ada05's return construct ?\n+         declare\n+            Result : Pattern_Matcher (Size);\n+         begin\n+            Compile (Result, Expression, Size, Flags);\n+            return Result;\n+         end;\n+      end if;\n    end Compile;\n \n    procedure Compile\n@@ -2051,9 +2025,11 @@ package body System.Regpat is\n       Flags      : Regexp_Flags := No_Flags)\n    is\n       Size : Program_Size;\n-      pragma Unreferenced (Size);\n    begin\n       Compile (Matcher, Expression, Size, Flags);\n+      if Size > Matcher.Size then\n+         raise Expression_Error with \"Pattern_Matcher is too small\";\n+      end if;\n    end Compile;\n \n    --------------------\n@@ -2101,7 +2077,7 @@ package body System.Regpat is\n    begin\n       while Index < Till loop\n          Op   := Opcode'Val (Character'Pos ((Program (Index))));\n-         Next := Index + Get_Next_Offset (Program, Index);\n+         Next := Get_Next (Program, Index);\n \n          if Do_Print then\n             declare\n@@ -2254,14 +2230,11 @@ package body System.Regpat is\n \n    procedure Dump (Self : Pattern_Matcher) is\n       Program : Program_Data renames Self.Program;\n-      Index   : Pointer := Program'First + 1;\n+      Index   : Pointer := Program'First;\n \n    --  Start of processing for Dump\n \n    begin\n-      pragma Assert (Self.Program (Program_First) = MAGIC,\n-                     \"Corrupted Pattern_Matcher\");\n-\n       Put_Line (\"Must start with (Self.First) = \"\n                 & Character'Image (Self.First));\n \n@@ -2277,7 +2250,6 @@ package body System.Regpat is\n          Put_Line (\"  Multiple_Lines mode\");\n       end if;\n \n-      Put_Line (\"   1:MAGIC\");\n       Dump_Until (Program, Index, Self.Program'Last + 1, 0);\n    end Dump;\n \n@@ -2300,27 +2272,10 @@ package body System.Regpat is\n    --------------\n \n    function Get_Next (Program : Program_Data; IP : Pointer) return Pointer is\n-      Offset : constant Pointer := Get_Next_Offset (Program, IP);\n    begin\n-      if Offset = 0 then\n-         return 0;\n-      else\n-         return IP + Offset;\n-      end if;\n+      return IP + Pointer (Read_Natural (Program, IP + 1));\n    end Get_Next;\n \n-   ---------------------\n-   -- Get_Next_Offset --\n-   ---------------------\n-\n-   function Get_Next_Offset\n-     (Program : Program_Data;\n-      IP      : Pointer) return Pointer\n-   is\n-   begin\n-      return Pointer (Read_Natural (Program, IP + 1));\n-   end Get_Next_Offset;\n-\n    --------------\n    -- Is_Alnum --\n    --------------\n@@ -3366,7 +3321,7 @@ package body System.Regpat is\n          Last_Paren := 0;\n          Matches_Full := (others => No_Match);\n \n-         if Match (Program_First + 1) then\n+         if Match (Program_First) then\n             Matches_Full (0) := (Pos, Input_Pos - 1);\n             return True;\n          end if;\n@@ -3384,12 +3339,6 @@ package body System.Regpat is\n          return;\n       end if;\n \n-      --  Check validity of program\n-\n-      pragma Assert\n-        (Program (Program_First) = MAGIC,\n-         \"Corrupted Pattern_Matcher\");\n-\n       --  If there is a \"must appear\" string, look for it\n \n       if Self.Must_Have_Length > 0 then\n@@ -3618,7 +3567,7 @@ package body System.Regpat is\n       Self.Must_Have := Program'Last + 1;\n       Self.Must_Have_Length := 0;\n \n-      Scan := Program_First + 1;  --  First instruction (can be anything)\n+      Scan := Program_First;  --  First instruction (can be anything)\n \n       if Program (Scan) = EXACT then\n          Self.First := Program (String_Operand (Scan));"}, {"sha": "86ee044c40daeb09725579602c9292ebff9a2e59", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/008f6fd3f92a521324ba4fd26bd17aad0f7cbef5/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/008f6fd3f92a521324ba4fd26bd17aad0f7cbef5/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=008f6fd3f92a521324ba4fd26bd17aad0f7cbef5", "patch": "@@ -5906,7 +5906,7 @@ package body Sem_Res is\n          --  to the discriminant of the same name in the target task. If the\n          --  entry name is the target of a requeue statement and the entry is\n          --  in the current protected object, the bound to be used is the\n-         --  discriminal of the object (see apply_range_checks for details of\n+         --  discriminal of the object (see Apply_Range_Checks for details of\n          --  the transformation).\n \n          -----------------------------"}]}