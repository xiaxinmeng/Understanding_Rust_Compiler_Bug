{"sha": "c9de716a59c873859df3b3e1fbb993200fce5a73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzlkZTcxNmE1OWM4NzM4NTlkZjNiM2UxZmJiOTkzMjAwZmNlNWE3Mw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-09-15T12:35:40Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-09-15T12:41:21Z"}, "message": "Allow more BB vectorization\n\nThe following allows more BB vectorization by generally building leafs\nfrom scalars rather than giving up.  Note this is only a first step\ntowards this and as can be seen with the exception for node splitting\nit is generally hard to get this heuristic sound.  I've added variants\nof the bb-slp-48.c testcase to make sure we still try permuting for\nexample.\n\n2020-09-15  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-slp.c (vect_build_slp_tree_2): Also consider\n\tbuilding an operand from scalars when building it did not\n\tfail fatally but avoid messing with the upcall splitting\n\tof groups.\n\n\t* gcc.dg/vect/bb-slp-48.c: New testcase.\n\t* gcc.dg/vect/bb-slp-7.c: Adjust.", "tree": {"sha": "dcf2c6218ef64c1050e9df4358fc6603de07b9a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcf2c6218ef64c1050e9df4358fc6603de07b9a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9de716a59c873859df3b3e1fbb993200fce5a73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9de716a59c873859df3b3e1fbb993200fce5a73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9de716a59c873859df3b3e1fbb993200fce5a73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9de716a59c873859df3b3e1fbb993200fce5a73/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80297f897758f59071968ddff2a04a8d11481117", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80297f897758f59071968ddff2a04a8d11481117", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80297f897758f59071968ddff2a04a8d11481117"}], "stats": {"total": 128, "additions": 98, "deletions": 30}, "files": [{"sha": "cd229323ecfab210f8f559d67b6e8dd1fa342194", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-48.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9de716a59c873859df3b3e1fbb993200fce5a73/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-48.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9de716a59c873859df3b3e1fbb993200fce5a73/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-48.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-48.c?ref=c9de716a59c873859df3b3e1fbb993200fce5a73", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fgimple -fdump-tree-optimized\" } */\n+/* { dg-require-effective-target vect_double } */\n+\n+double a[2];\n+\n+void __GIMPLE (ssa,startwith (\"fix_loops\"))\n+foo (double x)\n+{\n+  double tem2;\n+  double tem1;\n+  double _1;\n+  double _2;\n+  double _3;\n+  double _4;\n+\n+  __BB(2):\n+  _1 = a[0];\n+  _2 = x_6(D) * 3.0e+0;\n+  tem1_7 = _1 + _2;\n+  _3 = x_6(D) + 1.0e+0;\n+  _4 = a[1];\n+  tem2_8 = _4 + _3;\n+  a[0] = tem1_7;\n+  a[1] = tem2_8;\n+  return;\n+}\n+\n+void __GIMPLE (ssa,startwith (\"fix_loops\"))\n+bar (double x)\n+{\n+  double tem2;\n+  double tem1;\n+  double _1;\n+  double _2;\n+  double _3;\n+  double _4;\n+\n+  __BB(2):\n+  _1 = a[0];\n+  _2 = x_6(D) * 3.0e+0;\n+  tem1_7 = _1 + _2;\n+  _3 = x_6(D) + 1.0e+0;\n+  _4 = a[1];\n+  /* Once with operands swapped.  */\n+  tem2_8 = _3 + _4;\n+  a[0] = tem1_7;\n+  a[1] = tem2_8;\n+  return;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block part vectorized\" 2 \"slp2\" } } */\n+/* We want to vectorize as { a[0], a[1] } + { x*3, x+1 } and thus\n+   elide one add in each function.  */\n+/* { dg-final { scan-tree-dump-times \" \\\\+ \" 4 \"optimized\" } } */"}, {"sha": "f12dc275667c842f3fb74addb465ebeca6f3adbb", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-7.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9de716a59c873859df3b3e1fbb993200fce5a73/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9de716a59c873859df3b3e1fbb993200fce5a73/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-7.c?ref=c9de716a59c873859df3b3e1fbb993200fce5a73", "patch": "@@ -22,6 +22,7 @@ main1 (unsigned int x, unsigned int y)\n   a2 = *pin++ + 2;\n   a3 = *pin++ * 31;\n \n+  /* But we can still vectorize the multiplication or the store.  */\n   *pout++ = a0 * x;\n   *pout++ = a1 * y;\n   *pout++ = a2 * x;\n@@ -46,5 +47,5 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"basic block vectorized\" 0 \"slp2\" } } */\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized\" 1 \"slp2\" } } */\n "}, {"sha": "d844fe4d6bb6e1ecc8ec9ab3948bc728f76241a9", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9de716a59c873859df3b3e1fbb993200fce5a73/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9de716a59c873859df3b3e1fbb993200fce5a73/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=c9de716a59c873859df3b3e1fbb993200fce5a73", "patch": "@@ -1444,33 +1444,6 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t  continue;\n \t}\n \n-      /* If the SLP build failed fatally and we analyze a basic-block\n-         simply treat nodes we fail to build as externally defined\n-\t (and thus build vectors from the scalar defs).\n-\t The cost model will reject outright expensive cases.\n-\t ???  This doesn't treat cases where permutation ultimatively\n-\t fails (or we don't try permutation below).  Ideally we'd\n-\t even compute a permutation that will end up with the maximum\n-\t SLP tree size...  */\n-      if (is_a <bb_vec_info> (vinfo)\n-\t  && !matches[0]\n-\t  /* ???  Rejecting patterns this way doesn't work.  We'd have to\n-\t     do extra work to cancel the pattern so the uses see the\n-\t     scalar version.  */\n-\t  && !is_pattern_stmt_p (stmt_info)\n-\t  && !oprnd_info->any_pattern)\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t     \"Building vector operands from scalars\\n\");\n-\t  this_tree_size++;\n-\t  child = vect_create_new_slp_node (oprnd_info->ops);\n-\t  children.safe_push (child);\n-\t  oprnd_info->ops = vNULL;\n-\t  oprnd_info->def_stmts = vNULL;\n-\t  continue;\n-\t}\n-\n       /* If the SLP build for operand zero failed and operand zero\n \t and one can be commutated try that for the scalar stmts\n \t that failed the match.  */\n@@ -1542,11 +1515,50 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t      children.safe_push (child);\n \t      continue;\n \t    }\n-\n+\t  /* We do not undo the swapping here since it might still be\n+\t     the better order for the second operand in case we build\n+\t     the first one from scalars below.  */\n \t  ++*npermutes;\n \t}\n-\n fail:\n+\n+      /* If the SLP build failed and we analyze a basic-block\n+\t simply treat nodes we fail to build as externally defined\n+\t (and thus build vectors from the scalar defs).\n+\t The cost model will reject outright expensive cases.\n+\t ???  This doesn't treat cases where permutation ultimatively\n+\t fails (or we don't try permutation below).  Ideally we'd\n+\t even compute a permutation that will end up with the maximum\n+\t SLP tree size...  */\n+      if (is_a <bb_vec_info> (vinfo)\n+\t  /* ???  Rejecting patterns this way doesn't work.  We'd have to\n+\t     do extra work to cancel the pattern so the uses see the\n+\t     scalar version.  */\n+\t  && !is_pattern_stmt_p (stmt_info)\n+\t  && !oprnd_info->any_pattern)\n+\t{\n+\t  /* But if there's a leading vector sized set of matching stmts\n+\t     fail here so we can split the group.  This matches the condition\n+\t     vect_analyze_slp_instance uses.  */\n+\t  /* ???  We might want to split here and combine the results to support\n+\t     multiple vector sizes better.  */\n+\t  for (j = 0; j < group_size; ++j)\n+\t    if (!matches[j])\n+\t      break;\n+\t  if (!known_ge (j, TYPE_VECTOR_SUBPARTS (vectype)))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"Building vector operands from scalars\\n\");\n+\t      this_tree_size++;\n+\t      child = vect_create_new_slp_node (oprnd_info->ops);\n+\t      children.safe_push (child);\n+\t      oprnd_info->ops = vNULL;\n+\t      oprnd_info->def_stmts = vNULL;\n+\t      continue;\n+\t    }\n+\t}\n+\n       gcc_assert (child == NULL);\n       FOR_EACH_VEC_ELT (children, j, child)\n \tvect_free_slp_tree (child, false);"}]}