{"sha": "7307d8e10727aea8069c0e47e64a7a9b8588a22e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMwN2Q4ZTEwNzI3YWVhODA2OWMwZTQ3ZTY0YTdhOWI4NTg4YTIyZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-06T10:11:42Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-06T11:43:33Z"}, "message": "tree-optimization/97706 - part one, refactor vect_determine_mask_precision\n\nThis computes vect_determine_mask_precision in a RPO forward walk\nrather than in a backward walk and using a worklist.  It will make\nfixing PR97706 easier but for bisecting I wanted it to be separate.\n\n2020-11-06  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/97706\n\t* tree-vect-patterns.c (vect_determine_mask_precision):\n\tRemove worklist operation.\n\t(vect_determine_stmt_precisions): Do not call\n\tvect_determine_mask_precision here.\n\t(vect_determine_precisions): Compute mask precision\n\tin a forward walk.", "tree": {"sha": "05e7a189f2453c514750e7c0db19f3a4b59bb7d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05e7a189f2453c514750e7c0db19f3a4b59bb7d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7307d8e10727aea8069c0e47e64a7a9b8588a22e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7307d8e10727aea8069c0e47e64a7a9b8588a22e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7307d8e10727aea8069c0e47e64a7a9b8588a22e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7307d8e10727aea8069c0e47e64a7a9b8588a22e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2e9f586fde57e64dc20e5528870d06cde894785", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2e9f586fde57e64dc20e5528870d06cde894785", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2e9f586fde57e64dc20e5528870d06cde894785"}], "stats": {"total": 161, "additions": 81, "deletions": 80}, "files": [{"sha": "47d9fce594f2b6315a3a560fe7d17bc40906d670", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 81, "deletions": 80, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7307d8e10727aea8069c0e47e64a7a9b8588a22e/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7307d8e10727aea8069c0e47e64a7a9b8588a22e/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=7307d8e10727aea8069c0e47e64a7a9b8588a22e", "patch": "@@ -5017,104 +5017,88 @@ possible_vector_mask_operation_p (stmt_vec_info stmt_info)\n static void\n vect_determine_mask_precision (vec_info *vinfo, stmt_vec_info stmt_info)\n {\n-  if (!possible_vector_mask_operation_p (stmt_info)\n-      || stmt_info->mask_precision)\n+  if (!possible_vector_mask_operation_p (stmt_info))\n     return;\n \n-  auto_vec<stmt_vec_info, 32> worklist;\n-  worklist.quick_push (stmt_info);\n-  while (!worklist.is_empty ())\n-    {\n-      stmt_info = worklist.last ();\n-      unsigned int orig_length = worklist.length ();\n-\n-      /* If at least one boolean input uses a vector mask type,\n-\t pick the mask type with the narrowest elements.\n-\n-\t ??? This is the traditional behavior.  It should always produce\n-\t the smallest number of operations, but isn't necessarily the\n-\t optimal choice.  For example, if we have:\n+  /* If at least one boolean input uses a vector mask type,\n+     pick the mask type with the narrowest elements.\n \n-\t   a = b & c\n+     ??? This is the traditional behavior.  It should always produce\n+     the smallest number of operations, but isn't necessarily the\n+     optimal choice.  For example, if we have:\n \n-\t where:\n+       a = b & c\n \n-\t - the user of a wants it to have a mask type for 16-bit elements (M16)\n-\t - b also uses M16\n-\t - c uses a mask type for 8-bit elements (M8)\n+     where:\n \n-\t then picking M8 gives:\n+       - the user of a wants it to have a mask type for 16-bit elements (M16)\n+       - b also uses M16\n+       - c uses a mask type for 8-bit elements (M8)\n \n-\t - 1 M16->M8 pack for b\n-\t - 1 M8 AND for a\n-\t - 2 M8->M16 unpacks for the user of a\n+     then picking M8 gives:\n \n-\t whereas picking M16 would have given:\n+       - 1 M16->M8 pack for b\n+       - 1 M8 AND for a\n+       - 2 M8->M16 unpacks for the user of a\n \n-\t - 2 M8->M16 unpacks for c\n-\t - 2 M16 ANDs for a\n-\n-\t The number of operations are equal, but M16 would have given\n-\t a shorter dependency chain and allowed more ILP.  */\n-      unsigned int precision = ~0U;\n-      gassign *assign = as_a <gassign *> (stmt_info->stmt);\n-      unsigned int nops = gimple_num_ops (assign);\n-      for (unsigned int i = 1; i < nops; ++i)\n-\t{\n-\t  tree rhs = gimple_op (assign, i);\n-\t  if (!VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (rhs)))\n-\t    continue;\n+     whereas picking M16 would have given:\n \n-\t  stmt_vec_info def_stmt_info = vinfo->lookup_def (rhs);\n-\t  if (!def_stmt_info)\n-\t    /* Don't let external or constant operands influence the choice.\n-\t       We can convert them to whichever vector type we pick.  */\n-\t    continue;\n+       - 2 M8->M16 unpacks for c\n+       - 2 M16 ANDs for a\n \n-\t  if (def_stmt_info->mask_precision)\n-\t    {\n-\t      if (precision > def_stmt_info->mask_precision)\n-\t\tprecision = def_stmt_info->mask_precision;\n-\t    }\n-\t  else if (possible_vector_mask_operation_p (def_stmt_info))\n-\t    worklist.safe_push (def_stmt_info);\n-\t}\n+     The number of operations are equal, but M16 would have given\n+     a shorter dependency chain and allowed more ILP.  */\n+  unsigned int precision = ~0U;\n+  gassign *assign = as_a <gassign *> (stmt_info->stmt);\n+  unsigned int nops = gimple_num_ops (assign);\n+  for (unsigned int i = 1; i < nops; ++i)\n+    {\n+      tree rhs = gimple_op (assign, i);\n+      if (!VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (rhs)))\n+\tcontinue;\n \n-      /* Defer the choice if we need to visit operands first.  */\n-      if (orig_length != worklist.length ())\n+      stmt_vec_info def_stmt_info = vinfo->lookup_def (rhs);\n+      if (!def_stmt_info)\n+\t/* Don't let external or constant operands influence the choice.\n+\t   We can convert them to whichever vector type we pick.  */\n \tcontinue;\n \n-      /* If the statement compares two values that shouldn't use vector masks,\n-\t try comparing the values as normal scalars instead.  */\n-      tree_code rhs_code = gimple_assign_rhs_code (assign);\n-      if (precision == ~0U\n-\t  && TREE_CODE_CLASS (rhs_code) == tcc_comparison)\n+      if (def_stmt_info->mask_precision)\n \t{\n-\t  tree rhs1_type = TREE_TYPE (gimple_assign_rhs1 (assign));\n-\t  scalar_mode mode;\n-\t  tree vectype, mask_type;\n-\t  if (is_a <scalar_mode> (TYPE_MODE (rhs1_type), &mode)\n-\t      && (vectype = get_vectype_for_scalar_type (vinfo, rhs1_type))\n-\t      && (mask_type = get_mask_type_for_scalar_type (vinfo, rhs1_type))\n-\t      && expand_vec_cmp_expr_p (vectype, mask_type, rhs_code))\n-\t    precision = GET_MODE_BITSIZE (mode);\n+\t  if (precision > def_stmt_info->mask_precision)\n+\t    precision = def_stmt_info->mask_precision;\n \t}\n+    }\n \n-      if (dump_enabled_p ())\n-\t{\n-\t  if (precision == ~0U)\n-\t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t     \"using normal nonmask vectors for %G\",\n-\t\t\t     stmt_info->stmt);\n-\t  else\n-\t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t     \"using boolean precision %d for %G\",\n-\t\t\t     precision, stmt_info->stmt);\n-\t}\n+  /* If the statement compares two values that shouldn't use vector masks,\n+     try comparing the values as normal scalars instead.  */\n+  tree_code rhs_code = gimple_assign_rhs_code (assign);\n+  if (precision == ~0U\n+      && TREE_CODE_CLASS (rhs_code) == tcc_comparison)\n+    {\n+      tree rhs1_type = TREE_TYPE (gimple_assign_rhs1 (assign));\n+      scalar_mode mode;\n+      tree vectype, mask_type;\n+      if (is_a <scalar_mode> (TYPE_MODE (rhs1_type), &mode)\n+\t  && (vectype = get_vectype_for_scalar_type (vinfo, rhs1_type))\n+\t  && (mask_type = get_mask_type_for_scalar_type (vinfo, rhs1_type))\n+\t  && expand_vec_cmp_expr_p (vectype, mask_type, rhs_code))\n+\tprecision = GET_MODE_BITSIZE (mode);\n+    }\n \n-      stmt_info->mask_precision = precision;\n-      worklist.pop ();\n+  if (dump_enabled_p ())\n+    {\n+      if (precision == ~0U)\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"using normal nonmask vectors for %G\",\n+\t\t\t stmt_info->stmt);\n+      else\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"using boolean precision %d for %G\",\n+\t\t\t precision, stmt_info->stmt);\n     }\n+\n+  stmt_info->mask_precision = precision;\n }\n \n /* Handle vect_determine_precisions for STMT_INFO, given that we\n@@ -5129,7 +5113,6 @@ vect_determine_stmt_precisions (vec_info *vinfo, stmt_vec_info stmt_info)\n       vect_determine_precisions_from_range (stmt_info, stmt);\n       vect_determine_precisions_from_users (stmt_info, stmt);\n     }\n-  vect_determine_mask_precision (vinfo, stmt_info);\n }\n \n /* Walk backwards through the vectorizable region to determine the\n@@ -5151,6 +5134,14 @@ vect_determine_precisions (vec_info *vinfo)\n       basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n       unsigned int nbbs = loop->num_nodes;\n \n+      for (unsigned int i = 0; i < nbbs; i++)\n+\t{\n+\t  basic_block bb = bbs[i];\n+\t  for (auto si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+\t    if (!is_gimple_debug (gsi_stmt (si)))\n+\t      vect_determine_mask_precision\n+\t\t(vinfo, vinfo->lookup_stmt (gsi_stmt (si)));\n+\t}\n       for (unsigned int i = 0; i < nbbs; i++)\n \t{\n \t  basic_block bb = bbs[nbbs - i - 1];\n@@ -5164,6 +5155,16 @@ vect_determine_precisions (vec_info *vinfo)\n   else\n     {\n       bb_vec_info bb_vinfo = as_a <bb_vec_info> (vinfo);\n+      for (unsigned i = 0; i < bb_vinfo->bbs.length (); ++i)\n+\t{\n+\t  basic_block bb = bb_vinfo->bbs[i];\n+\t  for (auto gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      stmt_vec_info stmt_info = vinfo->lookup_stmt (gsi_stmt (gsi));\n+\t      if (stmt_info && STMT_VINFO_VECTORIZABLE (stmt_info))\n+\t\tvect_determine_mask_precision (vinfo, stmt_info);\n+\t    }\n+\t}\n       for (int i = bb_vinfo->bbs.length () - 1; i != -1; --i)\n \tfor (gimple_stmt_iterator gsi = gsi_last_bb (bb_vinfo->bbs[i]);\n \t     !gsi_end_p (gsi); gsi_prev (&gsi))"}]}