{"sha": "930d560203039875c4da07a01f579f56f5f2c636", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTMwZDU2MDIwMzAzOTg3NWM0ZGEwN2EwMWY1NzlmNTZmNWYyYzYzNg==", "commit": {"author": {"name": "Fan You", "email": "youfan.noey@gmail.com", "date": "2015-11-13T11:05:28Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2015-11-13T11:05:28Z"}, "message": "Implement std::experimental::shared_ptr with array support\n\n2015-11-13  Fan You  <youfan.noey@gmail.com>\n\t    Jonathan Wakely  <jwakely@redhat.com>\n\n\t* include/Makefile.am: Add new header.\n\t* include/Makefile.in: Regenerate.\n\t* include/experimental/bits/shared_ptr.h: New.\n\t* include/experimental/memory: Include new header.\n\t* testsuite/experimental/memory/shared_ptr/assign/assign.cc: New.\n\t* testsuite/experimental/memory/shared_ptr/cast/cast.cc: New.\n\t* testsuite/experimental/memory/shared_ptr/comparison/comparison.cc:\n\tNew.\n\t* testsuite/experimental/memory/shared_ptr/cons/alias_ctor.cc: New.\n\t* testsuite/experimental/memory/shared_ptr/cons/alloc_ctor.cc: New.\n\t* testsuite/experimental/memory/shared_ptr/cons/copy_ctor.cc: New.\n\t* testsuite/experimental/memory/shared_ptr/cons/copy_ctor_neg.cc: New.\n\t* testsuite/experimental/memory/shared_ptr/cons/default_ctor.cc: New.\n\t* testsuite/experimental/memory/shared_ptr/cons/move_ctor.cc: New.\n\t* testsuite/experimental/memory/shared_ptr/cons/pointer_ctor.cc: New.\n\t* testsuite/experimental/memory/shared_ptr/cons/unique_ptr_ctor.cc:\n\tNew.\n\t* testsuite/experimental/memory/shared_ptr/cons/weak_ptr_ctor.cc: New.\n\t* testsuite/experimental/memory/shared_ptr/dest/dest.cc: New.\n\t* testsuite/experimental/memory/shared_ptr/modifiers/reset.cc: New.\n\t* testsuite/experimental/memory/shared_ptr/modifiers/swap.cc: New.\n\t* testsuite/experimental/memory/shared_ptr/observers/bool_conv.cc:\n\tNew.\n\t* testsuite/experimental/memory/shared_ptr/observers/operators.cc:\n\tNew.\n\t* testsuite/experimental/memory/shared_ptr/observers/owner_before.cc:\n\tNew.\n\t* testsuite/experimental/memory/shared_ptr/observers/use_count.cc: New.\n\nCo-Authored-By: Jonathan Wakely <jwakely@redhat.com>\n\nFrom-SVN: r230300", "tree": {"sha": "eb90f7cf60efb62b0d81e4ce24af95491ce9aff9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb90f7cf60efb62b0d81e4ce24af95491ce9aff9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/930d560203039875c4da07a01f579f56f5f2c636", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/930d560203039875c4da07a01f579f56f5f2c636", "html_url": "https://github.com/Rust-GCC/gccrs/commit/930d560203039875c4da07a01f579f56f5f2c636", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/930d560203039875c4da07a01f579f56f5f2c636/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "755fdaab8ed0d1c1f954c21a2a4a8d6830165bda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/755fdaab8ed0d1c1f954c21a2a4a8d6830165bda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/755fdaab8ed0d1c1f954c21a2a4a8d6830165bda"}], "stats": {"total": 2869, "additions": 2868, "deletions": 1}, "files": [{"sha": "fc49f8db6822b8a57841aa523952aefcb844ecfb", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -1,3 +1,35 @@\n+2015-11-13  Fan You  <youfan.noey@gmail.com>\n+\t    Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/Makefile.am: Add new header.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/experimental/bits/shared_ptr.h: New.\n+\t* include/experimental/memory: Include new header.\n+\t* testsuite/experimental/memory/shared_ptr/assign/assign.cc: New.\n+\t* testsuite/experimental/memory/shared_ptr/cast/cast.cc: New.\n+\t* testsuite/experimental/memory/shared_ptr/comparison/comparison.cc:\n+\tNew.\n+\t* testsuite/experimental/memory/shared_ptr/cons/alias_ctor.cc: New.\n+\t* testsuite/experimental/memory/shared_ptr/cons/alloc_ctor.cc: New.\n+\t* testsuite/experimental/memory/shared_ptr/cons/copy_ctor.cc: New.\n+\t* testsuite/experimental/memory/shared_ptr/cons/copy_ctor_neg.cc: New.\n+\t* testsuite/experimental/memory/shared_ptr/cons/default_ctor.cc: New.\n+\t* testsuite/experimental/memory/shared_ptr/cons/move_ctor.cc: New.\n+\t* testsuite/experimental/memory/shared_ptr/cons/pointer_ctor.cc: New.\n+\t* testsuite/experimental/memory/shared_ptr/cons/unique_ptr_ctor.cc:\n+\tNew.\n+\t* testsuite/experimental/memory/shared_ptr/cons/weak_ptr_ctor.cc: New.\n+\t* testsuite/experimental/memory/shared_ptr/dest/dest.cc: New.\n+\t* testsuite/experimental/memory/shared_ptr/modifiers/reset.cc: New.\n+\t* testsuite/experimental/memory/shared_ptr/modifiers/swap.cc: New.\n+\t* testsuite/experimental/memory/shared_ptr/observers/bool_conv.cc:\n+\tNew.\n+\t* testsuite/experimental/memory/shared_ptr/observers/operators.cc:\n+\tNew.\n+\t* testsuite/experimental/memory/shared_ptr/observers/owner_before.cc:\n+\tNew.\n+\t* testsuite/experimental/memory/shared_ptr/observers/use_count.cc: New.\n+\n 2015-11-13  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/Makefile.am: Add new header."}, {"sha": "4e2ae18153878a0d7cfd8866ac5b87b430c0f30f", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -678,6 +678,7 @@ experimental_bits_srcdir = ${glibcxx_srcdir}/include/experimental/bits\n experimental_bits_builddir = ./experimental/bits\n experimental_bits_headers = \\\n \t${experimental_bits_srcdir}/erase_if.h \\\n+\t${experimental_bits_srcdir}/shared_ptr.h \\\n \t${experimental_bits_srcdir}/string_view.tcc \\\n \t${experimental_bits_filesystem_headers}\n "}, {"sha": "89dfdbe5278754a5e6d33c994a3f9e224d4a4775", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -967,6 +967,7 @@ experimental_bits_srcdir = ${glibcxx_srcdir}/include/experimental/bits\n experimental_bits_builddir = ./experimental/bits\n experimental_bits_headers = \\\n \t${experimental_bits_srcdir}/erase_if.h \\\n+\t${experimental_bits_srcdir}/shared_ptr.h \\\n \t${experimental_bits_srcdir}/string_view.tcc \\\n \t${experimental_bits_filesystem_headers}\n "}, {"sha": "feba7d7efa1fd738c00e94df27b3dc2656c860df", "filename": "libstdc++-v3/include/experimental/bits/shared_ptr.h", "status": "added", "additions": 1197, "deletions": 0, "changes": 1197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fshared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fshared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fshared_ptr.h?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -0,0 +1,1197 @@\n+// Experimental shared_ptr with array support -*- C++ -*-\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/bits/shared_ptr.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{memory}\n+ */\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_SHARED_PTR_H\n+#define _GLIBCXX_EXPERIMENTAL_SHARED_PTR_H 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus <= 201103L\n+# include <bits/c++14_warning.h>\n+#else\n+\n+#include <memory>\n+#include <experimental/type_traits>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace experimental\n+{\n+inline namespace fundamentals_v2\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+  template<typename _Tp> class enable_shared_from_this;\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace fundamentals_v2\n+} // namespace experimental\n+\n+#define __cpp_lib_experimental_shared_ptr_arrays 201406\n+\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /*\n+   * The specification of std::experimental::shared_ptr is slightly different\n+   * to std::shared_ptr (specifically in terms of pointer \"compatibility\") so\n+   * to implement std::experimental::shared_ptr without too much duplication\n+   * we make it derive from a partial specialization of std::__shared_ptr\n+   * using a special tag type, __libfund_v1.\n+   *\n+   * There are two partial specializations for the tag type, supporting the\n+   * different interfaces of the array and non-array forms.\n+  */\n+\n+  template <typename _Tp, bool = is_array<_Tp>::value>\n+    struct __libfund_v1 { using type = _Tp; };\n+\n+  // helper for _Compatible\n+  template<typename _From_type, typename _To_type>\n+    struct __sp_compatible\n+    : is_convertible<_From_type*, _To_type*>::type\n+    { };\n+\n+  template<size_t _Nm, typename _Tp>\n+    struct __sp_compatible<_Tp[_Nm], _Tp[]>\n+    : true_type\n+    { };\n+\n+  template<size_t _Nm, typename _Tp>\n+    struct __sp_compatible<_Tp[_Nm], const _Tp[]>\n+    : true_type\n+    { };\n+\n+  // Partial specialization for base class of experimental::shared_ptr<T>\n+  // (i.e. the non-array form of experimental::shared_ptr)\n+  template<typename _Tp, _Lock_policy _Lp>\n+    class __shared_ptr<__libfund_v1<_Tp, false>, _Lp>\n+    : private __shared_ptr<_Tp, _Lp>\n+    {\n+      template<typename _Tp1>\n+\tusing _Compatible\n+\t  = enable_if_t<__sp_compatible<_Tp1, _Tp>::value>;\n+\n+      using _Base_type = __shared_ptr<_Tp>;\n+\n+      _Base_type&  _M_get_base() { return *this;}\n+      const _Base_type&  _M_get_base() const { return *this;}\n+\n+    public:\n+      using element_type = _Tp;\n+\n+      constexpr __shared_ptr() noexcept = default;\n+\n+      template<typename _Tp1>\n+\texplicit __shared_ptr(_Tp1* __p)\n+\t: _Base_type(__p)\n+\t{ }\n+\n+      template<typename _Tp1, typename _Deleter>\n+\t__shared_ptr(_Tp1* __p, _Deleter __d)\n+\t: _Base_type(__p, __d)\n+\t{ }\n+\n+      template<typename _Tp1, typename _Deleter, typename _Alloc>\n+\t__shared_ptr(_Tp1* __p, _Deleter __d, _Alloc __a)\n+\t: _Base_type(__p, __d, __a)\n+\t{ }\n+\n+      template<typename _Deleter>\n+\t__shared_ptr(nullptr_t __p, _Deleter __d)\n+\t: _Base_type(__p, __d)\n+\t{ }\n+\n+      template<typename _Deleter, typename _Alloc>\n+\t__shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)\n+\t: _Base_type(__p, __d, __a)\n+\t{ }\n+\n+      template<typename _Tp1>\n+\t__shared_ptr(const __shared_ptr<__libfund_v1<_Tp1>, _Lp>& __r,\n+\t\t     element_type* __p) noexcept\n+\t: _Base_type(__r._M_get_base(), __p)\n+\t{ }\n+\n+      __shared_ptr(const __shared_ptr&) noexcept = default;\n+      __shared_ptr(__shared_ptr&&) noexcept = default;\n+      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;\n+      __shared_ptr& operator=(__shared_ptr&&) noexcept = default;\n+      ~__shared_ptr() = default;\n+\n+      template<typename _Tp1, typename = _Compatible<_Tp1>>\n+\t__shared_ptr(const __shared_ptr<__libfund_v1<_Tp1>, _Lp>& __r) noexcept\n+\t: _Base_type(__r._M_get_base())\n+\t{ }\n+\n+      template<typename _Tp1, typename = _Compatible<_Tp1>>\n+\t__shared_ptr(__shared_ptr<__libfund_v1<_Tp1>, _Lp>&& __r) noexcept\n+\t: _Base_type(std::move((__r._M_get_base())))\n+\t{ }\n+\n+      template<typename _Tp1>\n+\texplicit __shared_ptr(const __weak_ptr<__libfund_v1<_Tp1>, _Lp>& __r)\n+\t: _Base_type(__r._M_get_base())\n+\t{ }\n+\n+      template<typename _Tp1, typename _Del, typename\n+\t      = _Compatible<remove_pointer_t<\n+\t\t\t    typename unique_ptr<_Tp1, _Del>::pointer>>>\n+\t  __shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)\n+\t  : _Base_type(std::move(__r))\n+\t  { }\n+\n+#if _GLIBCXX_USE_DEPRECATED\n+      // Postcondition: use_count() == 1 and __r.get() == 0\n+      template<typename _Tp1>\n+\t__shared_ptr(std::auto_ptr<_Tp1>&& __r)\n+        : _Base_type(std::move(__r))\n+\t{ }\n+#endif\n+\n+      constexpr __shared_ptr(nullptr_t) noexcept : __shared_ptr() { }\n+\n+      // reset\n+      void\n+      reset() noexcept\n+      { __shared_ptr(nullptr).swap(*this); }\n+\n+      template<typename _Tp1>\n+\tvoid\n+\treset(_Tp1* __p)\n+\t{\n+\t  _GLIBCXX_DEBUG_ASSERT(__p == 0 || __p != get());\n+\t  __shared_ptr(__p).swap(*this);\n+\t}\n+\n+      template<typename _Tp1, typename _Deleter>\n+\tvoid\n+\treset(_Tp1* __p, _Deleter __d)\n+\t{ __shared_ptr(__p, __d).swap(*this); }\n+\n+      template<typename _Tp1, typename _Deleter, typename _Alloc>\n+\tvoid\n+\treset(_Tp1* __p, _Deleter __d, _Alloc __a)\n+\t{ __shared_ptr(__p, __d, std::move(__a)).swap(*this); }\n+\n+      using _Base_type::operator*;\n+      using _Base_type::operator->;\n+\n+      template<typename _Tp1>\n+\t__shared_ptr&\n+\toperator=(const __shared_ptr<__libfund_v1<_Tp1>, _Lp>& __r) noexcept\n+\t{\n+\t  _Base_type::operator=(__r._M_get_base());\n+\t  return *this;\n+\t}\n+\n+      template<class _Tp1>\n+\t__shared_ptr&\n+\toperator=(__shared_ptr<__libfund_v1<_Tp1>, _Lp>&& __r) noexcept\n+\t{\n+\t  _Base_type::operator=(std::move(__r._M_get_base()));\n+\t  return *this;\n+\t}\n+\n+      template<typename _Tp1>\n+\t__shared_ptr&\n+\toperator=(std::unique_ptr<_Tp1>&& __r)\n+\t{\n+\t  _Base_type::operator=(std::move(__r));\n+\t  return *this;\n+\t}\n+\n+#if _GLIBCXX_USE_DEPRECATED\n+      template<typename _Tp1>\n+\t__shared_ptr&\n+\toperator=(std::auto_ptr<_Tp1>&& __r)\n+\t{\n+\t  _Base_type::operator=(std::move(__r));\n+\t  return *this;\n+\t}\n+#endif\n+\n+      void\n+      swap(__shared_ptr& __other) noexcept\n+      { _Base_type::swap(__other); }\n+\n+      template<typename _Tp1>\n+\tbool\n+\towner_before(__shared_ptr<__libfund_v1<_Tp1>, _Lp> const& __rhs) const\n+\t{ return _Base_type::owner_before(__rhs._M_get_base()); }\n+\n+      template<typename _Tp1>\n+\tbool\n+\towner_before(__weak_ptr<__libfund_v1<_Tp1>, _Lp> const& __rhs) const\n+\t{ return _Base_type::owner_before(__rhs._M_get_base()); }\n+\n+      using _Base_type::operator bool;\n+      using _Base_type::get;\n+      using _Base_type::unique;\n+      using _Base_type::use_count;\n+\n+    protected:\n+\n+      // make_shared not yet support for shared_ptr_arrays\n+      //template<typename _Alloc, typename... _Args>\n+      //  __shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,\n+      //\t             _Args&&... __args)\n+      //\t: _M_ptr(), _M_refcount(__tag, (_Tp*)0, __a,\n+      //\t                        std::forward<_Args>(__args)...)\n+      //\t{\n+      //\t  void* __p = _M_refcount._M_get_deleter(typeid(__tag));\n+      //\t  _M_ptr = static_cast<_Tp*>(__p);\n+      //\t  __enable_shared_from_this_helper(_M_refcount, _M_ptr, _M_ptr);\n+      //\t}\n+\n+      // __weak_ptr::lock()\n+      __shared_ptr(const __weak_ptr<__libfund_v1<_Tp>, _Lp>& __r,\n+\t\t   std::nothrow_t)\n+      : _Base_type(__r._M_get_base(), std::nothrow)\n+      { }\n+\n+    private:\n+      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n+      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n+\n+      // TODO\n+      template<typename _Del, typename _Tp1, _Lock_policy _Lp1>\n+\tfriend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&) noexcept;\n+    };\n+\n+  // Partial specialization for base class of experimental::shared_ptr<T[N]>\n+  // and experimental::shared_ptr<T[]> (i.e. the array forms).\n+  template<typename _Tp, _Lock_policy _Lp>\n+    class __shared_ptr<__libfund_v1<_Tp, true>, _Lp>\n+    : private __shared_ptr<remove_extent_t<_Tp>, _Lp>\n+    {\n+    public:\n+      using element_type = remove_extent_t<_Tp>;\n+\n+    private:\n+      struct _Array_Deleter\n+      {\n+\tvoid\n+\toperator()(element_type const *__p) const\n+\t{ delete [] __p; }\n+      };\n+\n+      struct _Normal_Deleter\n+      {\n+\tvoid\n+\toperator()(element_type const *__p) const\n+\t{ delete __p; }\n+      };\n+\n+      template<typename _Tp1>\n+\tusing _Compatible\n+\t  = enable_if_t<__sp_compatible<_Tp1, _Tp>::value>;\n+\n+      using _Deleter_type\n+\t= conditional_t<is_array<_Tp>::value, _Array_Deleter, _Normal_Deleter>;\n+\n+      using _Base_type = __shared_ptr<element_type>;\n+\n+      _Base_type&  _M_get_base() { return *this;}\n+      const _Base_type&  _M_get_base() const { return *this;}\n+\n+    public:\n+      constexpr __shared_ptr() noexcept\n+      : _Base_type()\n+      { }\n+\n+      template<typename _Tp1>\n+\texplicit __shared_ptr(_Tp1* __p)\n+\t: _Base_type(__p, _Deleter_type())\n+\t{ }\n+\n+      template<typename _Tp1, typename _Deleter>\n+\t__shared_ptr(_Tp1* __p, _Deleter __d)\n+\t: _Base_type(__p, __d)\n+\t{ }\n+\n+      template<typename _Tp1, typename _Deleter, typename _Alloc>\n+\t__shared_ptr(_Tp1* __p, _Deleter __d, _Alloc __a)\n+\t: _Base_type(__p, __d, __a)\n+\t{ }\n+\n+      template<typename _Deleter>\n+\t__shared_ptr(nullptr_t __p, _Deleter __d)\n+\t: _Base_type(__p, __d)\n+\t{ }\n+\n+      template<typename _Deleter, typename _Alloc>\n+\t__shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)\n+\t: _Base_type(__p, __d, __a)\n+\t{ }\n+\n+      template<typename _Tp1>\n+\t__shared_ptr(const __shared_ptr<__libfund_v1<_Tp1>, _Lp>& __r,\n+\t\t     element_type* __p) noexcept\n+\t: _Base_type(__r._M_get_base(), __p)\n+\t{ }\n+\n+      __shared_ptr(const __shared_ptr&) noexcept = default;\n+      __shared_ptr(__shared_ptr&&) noexcept = default;\n+      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;\n+      __shared_ptr& operator=(__shared_ptr&&) noexcept = default;\n+      ~__shared_ptr() = default;\n+\n+      template<typename _Tp1, typename = _Compatible<_Tp1>>\n+\t__shared_ptr(const __shared_ptr<__libfund_v1<_Tp1>, _Lp>& __r) noexcept\n+\t: _Base_type(__r._M_get_base())\n+\t{ }\n+\n+      template<typename _Tp1, typename = _Compatible<_Tp1>>\n+\t__shared_ptr(__shared_ptr<__libfund_v1<_Tp1>, _Lp>&& __r) noexcept\n+\t: _Base_type(std::move((__r._M_get_base())))\n+\t{ }\n+\n+      template<typename _Tp1>\n+\texplicit __shared_ptr(const __weak_ptr<__libfund_v1<_Tp1>, _Lp>& __r)\n+\t: _Base_type(__r._M_get_base())\n+\t{ }\n+\n+      template<typename _Tp1, typename _Del, typename\n+\t      = _Compatible<remove_pointer_t<\n+\t\t\t    typename unique_ptr<_Tp1, _Del>::pointer>>>\n+\t  __shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)\n+\t  : _Base_type(std::move(__r))\n+\t  { }\n+\n+#if _GLIBCXX_USE_DEPRECATED\n+      // Postcondition: use_count() == 1 and __r.get() == 0\n+      template<typename _Tp1>\n+\t__shared_ptr(std::auto_ptr<_Tp1>&& __r)\n+        : _Base_type(std::move(__r))\n+\t{ }\n+#endif\n+\n+      constexpr __shared_ptr(nullptr_t) noexcept : __shared_ptr() { }\n+\n+      // reset\n+      void\n+      reset() noexcept\n+      { __shared_ptr(nullptr).swap(*this); }\n+\n+      template<typename _Tp1>\n+\tvoid\n+\treset(_Tp1* __p)\n+\t{\n+\t  _GLIBCXX_DEBUG_ASSERT(__p == 0 || __p != get());\n+\t  __shared_ptr(__p, _Deleter_type()).swap(*this);\n+\t}\n+\n+      template<typename _Tp1, typename _Deleter>\n+\tvoid\n+\treset(_Tp1* __p, _Deleter __d)\n+\t{ __shared_ptr(__p, __d).swap(*this); }\n+\n+      template<typename _Tp1, typename _Deleter, typename _Alloc>\n+\tvoid\n+\treset(_Tp1* __p, _Deleter __d, _Alloc __a)\n+\t{ __shared_ptr(__p, __d, std::move(__a)).swap(*this); }\n+\n+      element_type&\n+      operator[](ptrdiff_t i) const noexcept\n+      {\n+\t_GLIBCXX_DEBUG_ASSERT(get() != 0 && i >= 0);\n+\treturn get()[i];\n+      }\n+\n+      template<typename _Tp1>\n+\t__shared_ptr&\n+\toperator=(const __shared_ptr<__libfund_v1<_Tp1>, _Lp>& __r) noexcept\n+\t{\n+\t  _Base_type::operator=(__r._M_get_base());\n+\t  return *this;\n+\t}\n+\n+      template<class _Tp1>\n+\t__shared_ptr&\n+\toperator=(__shared_ptr<__libfund_v1<_Tp1>, _Lp>&& __r) noexcept\n+\t{\n+\t  _Base_type::operator=(std::move(__r._M_get_base()));\n+\t  return *this;\n+\t}\n+\n+      template<typename _Tp1>\n+\t__shared_ptr&\n+\toperator=(std::unique_ptr<_Tp1>&& __r)\n+\t{\n+\t  _Base_type::operator=(std::move(__r));\n+\t  return *this;\n+\t}\n+\n+#if _GLIBCXX_USE_DEPRECATED\n+      template<typename _Tp1>\n+\t__shared_ptr&\n+\toperator=(std::auto_ptr<_Tp1>&& __r)\n+\t{\n+\t  _Base_type::operator=(std::move(__r));\n+\t  return *this;\n+\t}\n+#endif\n+\n+      void\n+      swap(__shared_ptr& __other) noexcept\n+      { _Base_type::swap(__other); }\n+\n+      template<typename _Tp1>\n+\tbool\n+\towner_before(__shared_ptr<__libfund_v1<_Tp1>, _Lp> const& __rhs) const\n+\t{ return _Base_type::owner_before(__rhs._M_get_base()); }\n+\n+      template<typename _Tp1>\n+\tbool\n+\towner_before(__weak_ptr<__libfund_v1<_Tp1>, _Lp> const& __rhs) const\n+\t{ return _Base_type::owner_before(__rhs._M_get_base()); }\n+\n+      using _Base_type::operator bool;\n+      using _Base_type::get;\n+      using _Base_type::unique;\n+      using _Base_type::use_count;\n+\n+    protected:\n+\n+      // make_shared not yet support for shared_ptr_arrays\n+      //template<typename _Alloc, typename... _Args>\n+      //  __shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,\n+      //\t             _Args&&... __args)\n+      //\t: _M_ptr(), _M_refcount(__tag, (_Tp*)0, __a,\n+      //\t                        std::forward<_Args>(__args)...)\n+      //\t{\n+      //\t  void* __p = _M_refcount._M_get_deleter(typeid(__tag));\n+      //\t  _M_ptr = static_cast<_Tp*>(__p);\n+      //\t  __enable_shared_from_this_helper(_M_refcount, _M_ptr, _M_ptr);\n+      //\t}\n+\n+      // __weak_ptr::lock()\n+      __shared_ptr(const __weak_ptr<__libfund_v1<_Tp>, _Lp>& __r,\n+\t\t   std::nothrow_t)\n+      : _Base_type(__r._M_get_base(), std::nothrow)\n+      { }\n+\n+    private:\n+      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n+      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n+\n+      // TODO\n+      template<typename _Del, typename _Tp1, _Lock_policy _Lp1>\n+\tfriend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&) noexcept;\n+    };\n+\n+  // weak_ptr specialization for __shared_ptr array\n+  template<typename _Tp, _Lock_policy _Lp>\n+    class __weak_ptr<__libfund_v1<_Tp>, _Lp>\n+    : __weak_ptr<remove_extent_t<_Tp>, _Lp>\n+    {\n+      template<typename _Tp1>\n+\tusing _Compatible = enable_if_t<__sp_compatible<_Tp1, _Tp>::value>;\n+\n+      using _Base_type = __weak_ptr<remove_extent_t<_Tp>>;\n+\n+      _Base_type&  _M_get_base() { return *this;}\n+      const _Base_type&  _M_get_base() const { return *this; }\n+\n+    public:\n+      using element_type = remove_extent_t<_Tp>;\n+\n+      constexpr __weak_ptr() noexcept\n+      : _Base_type()\n+      { }\n+\n+      __weak_ptr(const __weak_ptr&) noexcept = default;\n+\n+      ~__weak_ptr() = default;\n+\n+      template<typename _Tp1, typename = _Compatible<_Tp1>>\n+\t__weak_ptr(const __weak_ptr<__libfund_v1<_Tp1>, _Lp>& __r) noexcept\n+\t: _Base_type(__r._M_get_base())\n+\t{ }\n+\n+      template<typename _Tp1, typename = _Compatible<_Tp1>>\n+\t__weak_ptr(const __shared_ptr<__libfund_v1<_Tp1>, _Lp>& __r) noexcept\n+\t: _Base_type(__r._M_get_base())\n+\t{ }\n+\n+      __weak_ptr(__weak_ptr&& __r) noexcept\n+      : _Base_type(std::move(__r))\n+      { }\n+\n+      template<typename _Tp1, typename = _Compatible<_Tp1>>\n+\t__weak_ptr(__weak_ptr<__libfund_v1<_Tp1>, _Lp>&& __r) noexcept\n+\t: _Base_type(std::move(__r._M_get_base()))\n+\t{ }\n+\n+      __weak_ptr&\n+      operator=(const __weak_ptr& __r) noexcept = default;\n+\n+      template<typename _Tp1>\n+\t__weak_ptr&\n+\toperator=(const __weak_ptr<__libfund_v1<_Tp1>, _Lp>& __r) noexcept\n+\t{\n+\t  this->_Base_type::operator=(__r._M_get_base());\n+\t  return *this;\n+\t}\n+\n+      template<typename _Tp1>\n+\t__weak_ptr&\n+\toperator=(const __shared_ptr<_Tp1, _Lp>& __r) noexcept\n+\t{\n+\t  this->_Base_type::operator=(__r._M_get_base());\n+\t  return *this;\n+\t}\n+\n+      __weak_ptr&\n+      operator=(__weak_ptr&& __r) noexcept\n+      {\n+\tthis->_Base_type::operator=(std::move(__r));\n+\treturn *this;\n+      }\n+\n+      template<typename _Tp1>\n+\t__weak_ptr&\n+\toperator=(__weak_ptr<_Tp1, _Lp>&& __r) noexcept\n+\t{\n+\t  this->_Base_type::operator=(std::move(__r._M_get_base()));\n+\t  return *this;\n+\t}\n+\n+      void\n+      swap(__weak_ptr& __other) noexcept\n+      { this->_Base_type::swap(__other); }\n+\n+      template<typename _Tp1>\n+\tbool\n+\towner_before(const __shared_ptr<__libfund_v1<_Tp1>, _Lp>& __rhs) const\n+\t{ return _Base_type::owner_before(__rhs._M_get_base()); }\n+\n+      template<typename _Tp1>\n+\tbool\n+\towner_before(const __weak_ptr<__libfund_v1<_Tp1>, _Lp>& __rhs) const\n+\t{ return _Base_type::owner_before(__rhs._M_get_base()); }\n+\n+      __shared_ptr<__libfund_v1<_Tp>, _Lp>\n+      lock() const noexcept  // should not be element_type\n+      { return __shared_ptr<__libfund_v1<_Tp>, _Lp>(*this, std::nothrow); }\n+\n+      using _Base_type::use_count;\n+      using _Base_type::expired;\n+      using _Base_type::reset;\n+\n+    private:\n+      // Used by __enable_shared_from_this.\n+      void\n+      _M_assign(element_type* __ptr,\n+\t\tconst __shared_count<_Lp>& __refcount) noexcept\n+      { this->_Base_type::_M_assign(__ptr, __refcount); }\n+\n+      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n+      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n+      friend class __enable_shared_from_this<_Tp, _Lp>;\n+      friend class experimental::enable_shared_from_this<_Tp>;\n+      friend class enable_shared_from_this<_Tp>;\n+    };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+\n+namespace experimental\n+{\n+inline namespace fundamentals_v2\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+    // 8.2.1\n+\n+  template<typename _Tp> class shared_ptr;\n+  template<typename _Tp> class weak_ptr;\n+\n+  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n+    using __shared_ptr = std::__shared_ptr<__libfund_v1<_Tp>, _Lp>;\n+\n+  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n+    using __weak_ptr = std::__weak_ptr<__libfund_v1<_Tp>, _Lp>;\n+\n+  template<typename _Tp>\n+    class shared_ptr : public __shared_ptr<_Tp>\n+    {\n+      template<typename _Tp1>\n+\tusing _Compatible = enable_if_t<__sp_compatible<_Tp1, _Tp>::value>;\n+\n+      using _Base_type = __shared_ptr<_Tp>;\n+\n+    public:\n+      using element_type = typename _Base_type::element_type;\n+\n+      // 8.2.1.1, shared_ptr constructors\n+      constexpr shared_ptr() noexcept = default;\n+\n+      template<typename _Tp1>\n+\texplicit shared_ptr(_Tp1* __p) : _Base_type(__p) { }\n+\n+      template<typename _Tp1, typename _Deleter>\n+\tshared_ptr(_Tp1* __p, _Deleter __d)\n+\t: _Base_type(__p, __d) { }\n+\n+      template<typename _Tp1, typename _Deleter, typename _Alloc>\n+\tshared_ptr(_Tp1* __p, _Deleter __d, _Alloc __a)\n+\t: _Base_type(__p, __d, __a) { }\n+\n+      template<typename _Deleter>\n+\tshared_ptr(nullptr_t __p, _Deleter __d)\n+\t: _Base_type(__p, __d) { }\n+\n+      template<typename _Deleter, typename _Alloc>\n+\tshared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)\n+\t: _Base_type(__p, __d, __a) { }\n+\n+      template<typename _Tp1>\n+\tshared_ptr(const shared_ptr<_Tp1>& __r, element_type* __p) noexcept\n+\t: _Base_type(__r, __p) { }\n+\n+      shared_ptr(const shared_ptr& __r) noexcept\n+\t: _Base_type(__r) { }\n+\n+      template<typename _Tp1, typename = _Compatible<_Tp1>>\n+\tshared_ptr(const shared_ptr<_Tp1>& __r) noexcept\n+\t: _Base_type(__r) { }\n+\n+      shared_ptr(const shared_ptr<_Tp>&& __r) noexcept\n+      : _Base_type(std::move(__r)) { }\n+\n+      template<typename _Tp1, typename = _Compatible<_Tp1>>\n+\tshared_ptr(shared_ptr<_Tp1>&& __r) noexcept\n+\t: _Base_type(std::move(__r)) { }\n+\n+      template<typename _Tp1>\n+\texplicit shared_ptr(const weak_ptr<_Tp1>& __r)\n+\t: _Base_type(__r) { }\n+\n+#if _GLIBCXX_USE_DEPRECATED\n+      template<typename _Tp1>\n+\tshared_ptr(std::auto_ptr<_Tp1>&& __r)\n+\t: _Base_type() { } // TODO\n+#endif\n+\n+      template<typename _Tp1, typename _Del, typename\n+\t= _Compatible<remove_pointer_t<\n+\t\t      typename unique_ptr<_Tp1, _Del>::pointer>>>\n+\tshared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)\n+\t: _Base_type(std::move(__r)) { }\n+\n+      constexpr shared_ptr(nullptr_t __p)\n+      : _Base_type(__p) { }\n+\n+      // C++14 \u00a720.8.2.2\n+      ~shared_ptr() = default;\n+\n+      // C++14 \u00a720.8.2.3\n+      shared_ptr& operator=(const shared_ptr&) noexcept = default;\n+\n+      template <typename _Tp1>\n+\tshared_ptr&\n+\toperator=(const shared_ptr<_Tp1>& __r) noexcept\n+\t{\n+\t  _Base_type::operator=(__r);\n+\t  return *this;\n+\t}\n+\n+      shared_ptr&\n+      operator=(shared_ptr&& __r) noexcept\n+      {\n+\t_Base_type::operator=(std::move(__r));\n+\treturn *this;\n+      }\n+\n+      template <typename _Tp1>\n+\tshared_ptr&\n+\toperator=(shared_ptr<_Tp1>&& __r) noexcept\n+\t{\n+\t  _Base_type::operator=(std::move(__r));\n+\t  return *this;\n+\t}\n+\n+#if _GLIBCXX_USE_DEPRECATED\n+      template<typename _Tp1>\n+\tshared_ptr&\n+\toperator=(std::auto_ptr<_Tp1>&& __r)\n+\t{\n+\t  __shared_ptr<_Tp>::operator=(std::move(__r));\n+\t  return *this;\n+\t}\n+#endif\n+\n+      template <typename _Tp1, typename _Del>\n+\tshared_ptr&\n+\toperator=(unique_ptr<_Tp1, _Del>&& __r)\n+\t{\n+\t  _Base_type::operator=(std::move(__r));\n+\t  return *this;\n+\t}\n+\n+      // C++14 \u00a720.8.2.2.4\n+      // swap & reset\n+      // 8.2.1.2 shared_ptr observers\n+      // in __shared_ptr\n+\n+    private:\n+      template<typename _Alloc, typename... _Args>\n+      shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,\n+\t\t _Args&&... __args)\n+      : _Base_type(__tag, __a, std::forward<_Args>(__args)...)\n+      { }\n+\n+      template<typename _Tp1, typename _Alloc, typename... _Args>\n+\tfriend shared_ptr<_Tp1>\n+\tallocate_shared(const _Alloc& __a, _Args&&...  __args);\n+\n+      shared_ptr(const weak_ptr<_Tp>& __r, std::nothrow_t)\n+      : _Base_type(__r, std::nothrow) { }\n+\n+      friend class weak_ptr<_Tp>;\n+    };\n+\n+  // C++14 \u00a720.8.2.2.7 //DOING\n+   template<typename _Tp1, typename _Tp2>\n+     bool operator==(const shared_ptr<_Tp1>& __a,\n+\t\t     const shared_ptr<_Tp2>& __b) noexcept\n+     { return __a.get() == __b.get(); }\n+\n+   template<typename _Tp>\n+     inline bool\n+     operator==(const shared_ptr<_Tp>& __a, nullptr_t) noexcept\n+     { return !__a; }\n+\n+   template<typename _Tp>\n+     inline bool\n+     operator==(nullptr_t, const shared_ptr<_Tp>& __a) noexcept\n+     { return !__a; }\n+\n+   template<typename _Tp1, typename _Tp2>\n+     inline bool\n+     operator!=(const shared_ptr<_Tp1>& __a,\n+\t\tconst shared_ptr<_Tp2>& __b) noexcept\n+     { return __a.get() != __b.get(); }\n+\n+   template<typename _Tp>\n+     inline bool\n+     operator!=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept\n+     { return (bool)__a; }\n+\n+   template<typename _Tp>\n+     inline bool\n+     operator!=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept\n+     { return (bool)__a; }\n+\n+   template<typename _Tp1, typename _Tp2>\n+     inline bool\n+     operator<(const shared_ptr<_Tp1>& __a,\n+\t       const shared_ptr<_Tp2>& __b) noexcept\n+     {\n+       using __elem_t1 = typename shared_ptr<_Tp1>::element_type;\n+       using __elem_t2 = typename shared_ptr<_Tp2>::element_type;\n+       using _CT = common_type_t<__elem_t1*, __elem_t2*>;\n+       return std::less<_CT>()(__a.get(), __b.get());\n+     }\n+\n+   template<typename _Tp>\n+     inline bool\n+     operator<(const shared_ptr<_Tp>& __a, nullptr_t) noexcept\n+     {\n+       using __elem_t = typename shared_ptr<_Tp>::element_type;\n+       return std::less<__elem_t>()(__a.get(), nullptr);\n+     }\n+\n+   template<typename _Tp>\n+     inline bool\n+     operator<(nullptr_t, const shared_ptr<_Tp>& __a) noexcept\n+     {\n+       using __elem_t = typename shared_ptr<_Tp>::element_type;\n+       return std::less<__elem_t*>()(nullptr, __a.get());\n+     }\n+\n+   template<typename _Tp1, typename _Tp2>\n+     inline bool\n+     operator<=(const shared_ptr<_Tp1>& __a,\n+\t\tconst shared_ptr<_Tp2>& __b) noexcept\n+     { return !(__b < __a); }\n+\n+   template<typename _Tp>\n+     inline bool\n+     operator<=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept\n+     { return !(nullptr < __a); }\n+\n+   template<typename _Tp>\n+     inline bool\n+     operator<=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept\n+     { return !(__a < nullptr); }\n+\n+   template<typename _Tp1, typename _Tp2>\n+     inline bool\n+     operator>(const shared_ptr<_Tp1>& __a,\n+\t       const shared_ptr<_Tp2>& __b) noexcept\n+     { return (__b < __a); }\n+\n+   template<typename _Tp>\n+     inline bool\n+     operator>(const shared_ptr<_Tp>& __a, nullptr_t) noexcept\n+     {\n+       using __elem_t = typename shared_ptr<_Tp>::element_type;\n+       return std::less<__elem_t*>()(nullptr, __a.get());\n+     }\n+\n+   template<typename _Tp>\n+     inline bool\n+     operator>(nullptr_t, const shared_ptr<_Tp>& __a) noexcept\n+     {\n+       using __elem_t = typename shared_ptr<_Tp>::element_type;\n+       return std::less<__elem_t*>()(__a.get(), nullptr);\n+     }\n+\n+   template<typename _Tp1, typename _Tp2>\n+     inline bool\n+     operator>=(const shared_ptr<_Tp1>& __a,\n+\t\tconst shared_ptr<_Tp2>& __b) noexcept\n+     { return !(__a < __b); }\n+\n+   template<typename _Tp>\n+     inline bool\n+     operator>=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept\n+     { return !(__a < nullptr); }\n+\n+   template<typename _Tp>\n+     inline bool\n+     operator>=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept\n+     { return !(nullptr < __a); }\n+\n+   // C++14 \u00a720.8.2.2.8\n+   template<typename _Tp>\n+     inline void\n+     swap(shared_ptr<_Tp>& __a, shared_ptr<_Tp>& __b) noexcept\n+     { __a.swap(__b); }\n+\n+   // 8.2.1.3, shared_ptr casts\n+   template<typename _Tp, typename _Tp1>\n+     inline shared_ptr<_Tp>\n+     static_pointer_cast(const shared_ptr<_Tp1>& __r) noexcept\n+     {\n+       using __elem_t = typename shared_ptr<_Tp>::element_type;\n+       return shared_ptr<_Tp>(__r, static_cast<__elem_t*>(__r.get()));\n+     }\n+\n+   template<typename _Tp, typename _Tp1>\n+     inline shared_ptr<_Tp>\n+     dynamic_pointer_cast(const shared_ptr<_Tp1>& __r) noexcept\n+     {\n+       using __elem_t = typename shared_ptr<_Tp>::element_type;\n+       if (_Tp* __p = dynamic_cast<__elem_t*>(__r.get()))\n+\t return shared_ptr<_Tp>(__r, __p);\n+       return shared_ptr<_Tp>();\n+     }\n+\n+   template<typename _Tp, typename _Tp1>\n+     inline shared_ptr<_Tp>\n+     const_pointer_cast(const shared_ptr<_Tp1>& __r) noexcept\n+     {\n+       using __elem_t = typename shared_ptr<_Tp>::element_type;\n+       return shared_ptr<_Tp>(__r, const_cast<__elem_t*>(__r.get()));\n+     }\n+\n+   template<typename _Tp, typename _Tp1>\n+     inline shared_ptr<_Tp>\n+     reinterpret_pointer_cast(const shared_ptr<_Tp1>& __r) noexcept\n+     {\n+       using __elem_t = typename shared_ptr<_Tp>::element_type;\n+       return shared_ptr<_Tp>(__r, reinterpret_cast<__elem_t*>(__r.get()));\n+     }\n+\n+   // C++14 \u00a720.8.2.3\n+   template<typename _Tp>\n+     class weak_ptr : public __weak_ptr<_Tp>\n+     {\n+      template<typename _Tp1>\n+\tusing _Compatible = enable_if_t<__sp_compatible<_Tp1, _Tp>::value>;\n+\n+      using _Base_type = __weak_ptr<_Tp>;\n+\n+   public:\n+       constexpr weak_ptr() noexcept = default;\n+\n+       template<typename _Tp1, typename = _Compatible<_Tp1>>\n+\t weak_ptr(const shared_ptr<_Tp1>& __r) noexcept\n+\t : _Base_type(__r) { }\n+\n+       weak_ptr(const weak_ptr&) noexcept = default;\n+\n+       template<typename _Tp1, typename = _Compatible<_Tp1>>\n+\t weak_ptr(const weak_ptr<_Tp1>& __r) noexcept\n+\t : _Base_type(__r) { }\n+\n+       weak_ptr(weak_ptr&&) noexcept = default;\n+\n+       template<typename _Tp1, typename = _Compatible<_Tp1>>\n+\t weak_ptr(weak_ptr<_Tp1>&& __r) noexcept\n+\t : _Base_type(std::move(__r)) { }\n+\n+       weak_ptr&\n+       operator=(const weak_ptr& __r) noexcept = default;\n+\n+       template<typename _Tp1>\n+\t weak_ptr&\n+\t operator=(const weak_ptr<_Tp1>& __r) noexcept\n+\t {\n+\t   this->_Base_type::operator=(__r);\n+\t   return *this;\n+\t }\n+\n+       template<typename _Tp1>\n+\t weak_ptr&\n+\t operator=(const shared_ptr<_Tp1>& __r) noexcept\n+\t {\n+\t   this->_Base_type::operator=(__r);\n+\t   return *this;\n+\t }\n+\n+       weak_ptr&\n+       operator=(weak_ptr&& __r) noexcept = default;\n+\n+       template<typename _Tp1>\n+\t weak_ptr&\n+\t operator=(weak_ptr<_Tp1>&& __r) noexcept\n+\t {\n+\t   this->_Base_type::operator=(std::move(__r));\n+\t   return *this;\n+\t }\n+\n+       shared_ptr<_Tp>\n+       lock() const noexcept\n+       { return shared_ptr<_Tp>(*this, std::nothrow); }\n+\n+       friend class enable_shared_from_this<_Tp>;\n+     };\n+\n+   // C++14 \u00a720.8.2.3.6\n+   template<typename _Tp>\n+     inline void\n+     swap(weak_ptr<_Tp>& __a, weak_ptr<_Tp>& __b) noexcept\n+     { __a.swap(__b); }\n+\n+  /// C++14 \u00a720.8.2.2.10\n+  template<typename _Del, typename _Tp, _Lock_policy _Lp>\n+    inline _Del*\n+    get_deleter(const __shared_ptr<_Tp, _Lp>& __p) noexcept\n+    { return std::get_deleter<_Del>(__p); }\n+\n+  // C++14 \u00a720.8.2.2.11\n+  template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>\n+    inline std::basic_ostream<_Ch, _Tr>&\n+    operator<<(std::basic_ostream<_Ch, _Tr>& __os,\n+\t       const __shared_ptr<_Tp, _Lp>& __p)\n+    {\n+      __os << __p.get();\n+      return __os;\n+    }\n+\n+   // C++14 \u00a720.8.2.4\n+   template<typename _Tp = void> class owner_less;\n+\n+   /// Partial specialization of owner_less for shared_ptr.\n+  template<typename _Tp>\n+    struct owner_less<shared_ptr<_Tp>>\n+    : public _Sp_owner_less<shared_ptr<_Tp>, weak_ptr<_Tp>>\n+    { };\n+\n+  /// Partial specialization of owner_less for weak_ptr.\n+  template<typename _Tp>\n+    struct owner_less<weak_ptr<_Tp>>\n+    : public _Sp_owner_less<weak_ptr<_Tp>, shared_ptr<_Tp>>\n+    { };\n+\n+  template<>\n+    class owner_less<void>\n+    {\n+      template<typename _Tp, typename _Up>\n+        bool\n+        operator()(shared_ptr<_Tp> const& __lhs,\n+                   shared_ptr<_Up> const& __rhs) const\n+        { return __lhs.owner_before(__rhs); }\n+\n+      template<typename _Tp, typename _Up>\n+        bool\n+        operator()(shared_ptr<_Tp> const& __lhs,\n+                   weak_ptr<_Up> const& __rhs) const\n+        { return __lhs.owner_before(__rhs); }\n+\n+      template<typename _Tp, typename _Up>\n+        bool\n+        operator()(weak_ptr<_Tp> const& __lhs,\n+                   shared_ptr<_Up> const& __rhs) const\n+        { return __lhs.owner_before(__rhs); }\n+\n+      template<typename _Tp, typename _Up>\n+        bool\n+        operator()(weak_ptr<_Tp> const& __lhs,\n+                   weak_ptr<_Up> const& __rhs) const\n+        { return __lhs.owner_before(__rhs); }\n+\n+      typedef void is_transparent;\n+    };\n+\n+   // C++14 \u00a720.8.2.6\n+   template<typename _Tp>\n+     inline bool\n+     atomic_is_lock_free(const shared_ptr<_Tp>* __p)\n+     { return std::atomic_is_lock_free<_Tp, __default_lock_policy>(__p); }\n+\n+   template<typename _Tp>\n+     shared_ptr<_Tp> atomic_load(const shared_ptr<_Tp>* __p)\n+     { return std::atomic_load<_Tp>(__p); }\n+\n+   template<typename _Tp>\n+     shared_ptr<_Tp>\n+     atomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order __mo)\n+     { return std::atomic_load_explicit<_Tp>(__p, __mo); }\n+\n+   template<typename _Tp>\n+     void atomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n+     { return std::atomic_store<_Tp>(__p, __r); }\n+\n+   template<typename _Tp>\n+     shared_ptr<_Tp>\n+     atomic_store_explicit(const shared_ptr<_Tp>* __p,\n+\t\t\t   shared_ptr<_Tp> __r,\n+\t\t\t   memory_order __mo)\n+     { return std::atomic_store_explicit<_Tp>(__p, __r, __mo); }\n+\n+   template<typename _Tp>\n+     void atomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n+     { return std::atomic_exchange<_Tp>(__p, __r); }\n+\n+   template<typename _Tp>\n+     shared_ptr<_Tp>\n+     atomic_exchange_explicit(const shared_ptr<_Tp>* __p,\n+\t\t\t      shared_ptr<_Tp> __r,\n+\t\t\t      memory_order __mo)\n+     { return std::atomic_exchange_explicit<_Tp>(__p, __r, __mo); }\n+\n+   template<typename _Tp>\n+     bool atomic_compare_exchange_weak(shared_ptr<_Tp>* __p,\n+\t\t\t\t       shared_ptr<_Tp>* __v,\n+\t\t\t\t       shared_ptr<_Tp> __w)\n+     { return std::atomic_compare_exchange_weak<_Tp>(__p, __v, __w); }\n+\n+   template<typename _Tp>\n+     bool atomic_compare_exchange_strong(shared_ptr<_Tp>* __p,\n+\t\t\t\t\t shared_ptr<_Tp>* __v,\n+\t\t\t\t\t shared_ptr<_Tp> __w)\n+     { return std::atomic_compare_exchange_strong<_Tp>(__p, __v, __w); }\n+\n+   template<typename _Tp>\n+     bool atomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p,\n+\t\t\t\t\t\tshared_ptr<_Tp>* __v,\n+\t\t\t\t\t\tshared_ptr<_Tp> __w,\n+\t\t\t\t\t\tmemory_order __success,\n+\t\t\t\t\t\tmemory_order __failure)\n+     { return std::atomic_compare_exchange_weak_explicit<_Tp>(__p, __v, __w,\n+\t\t\t\t\t\t\t      __success,\n+\t\t\t\t\t\t\t      __failure); }\n+\n+   template<typename _Tp>\n+     bool atomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p,\n+\t\t\t\t\t\t  shared_ptr<_Tp>* __v,\n+\t\t\t\t\t\t  shared_ptr<_Tp> __w,\n+\t\t\t\t\t\t  memory_order __success,\n+\t\t\t\t\t\t  memory_order __failure)\n+     { return std::atomic_compare_exchange_strong_explicit<_Tp>(__p, __v, __w,\n+\t\t\t\t\t\t\t\t__success,\n+\t\t\t\t\t\t\t\t__failure); }\n+\n+  //enable_shared_from_this\n+  template<typename _Tp>\n+    class enable_shared_from_this\n+    {\n+    protected:\n+      constexpr enable_shared_from_this() noexcept { }\n+\n+      enable_shared_from_this(const enable_shared_from_this&) noexcept { }\n+\n+      enable_shared_from_this&\n+      operator=(const enable_shared_from_this&) noexcept\n+      { return *this; }\n+\n+      ~enable_shared_from_this() { }\n+\n+    public:\n+      shared_ptr<_Tp>\n+      shared_from_this()\n+      { return shared_ptr<_Tp>(this->_M_weak_this); }\n+\n+      shared_ptr<const _Tp>\n+      shared_from_this() const\n+      { return shared_ptr<const _Tp>(this->_M_weak_this); }\n+\n+    private:\n+      template<typename _Tp1>\n+\tvoid\n+\t_M_weak_assign(_Tp1* __p, const __shared_count<>& __n) const noexcept\n+\t{ _M_weak_this._M_assign(__p, __n); }\n+\n+      template<typename _Tp1>\n+\tfriend void\n+\t__enable_shared_from_this_helper(const __shared_count<>& __pn,\n+\t\t\t\t\t const enable_shared_from_this* __pe,\n+\t\t\t\t\t const _Tp1* __px) noexcept\n+\t{\n+\t  if(__pe != 0)\n+\t    __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);\n+\t}\n+\n+      mutable weak_ptr<_Tp> _M_weak_this;\n+    };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace fundamentals_v2\n+} // namespace experimental\n+\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /// std::hash specialization for shared_ptr.\n+  template<typename _Tp>\n+    struct hash<experimental::shared_ptr<_Tp>>\n+    : public __hash_base<size_t, experimental::shared_ptr<_Tp>>\n+    {\n+      size_t\n+      operator()(const experimental::shared_ptr<_Tp>& __s) const noexcept\n+      { return std::hash<_Tp*>()(__s.get()); }\n+    };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif // __cplusplus <= 201103L\n+\n+#endif // _GLIBCXX_EXPERIMENTAL_SHARED_PTR_H"}, {"sha": "b8c7849e11f6ba2e366f3e705f2007a26594a90e", "filename": "libstdc++-v3/include/experimental/memory", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fmemory?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -43,6 +43,7 @@\n #include <type_traits>\n #include <utility>\n #include <functional>\n+#include <experimental/bits/shared_ptr.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -247,7 +248,6 @@ template <typename _Tp>\n     {\n       return hash<typename add_pointer<_Tp>::type> {}(__t.get());\n     }\n-\n   };\n \n } // namespace std"}, {"sha": "7656c98c3274f9d5898b73432b430b9615b78cc2", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/assign/assign.cc", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fassign%2Fassign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fassign%2Fassign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fassign%2Fassign.cc?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -0,0 +1,120 @@\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.2.1 Class template shared_ptr [memory.smartptr.shared]\n+\n+\n+#include <experimental/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  A() { ++ctor_count; }\n+  virtual ~A() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long A::ctor_count = 0;\n+long A::dtor_count = 0;\n+\n+struct B : A\n+{\n+  B() { ++ctor_count; }\n+  virtual ~B() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long B::ctor_count = 0;\n+long B::dtor_count = 0;\n+\n+struct reset_count_struct\n+{\n+  ~reset_count_struct()\n+  {\n+    A::ctor_count = 0;\n+    A::dtor_count = 0;\n+    B::ctor_count = 0;\n+    B::dtor_count = 0;\n+  }\n+};\n+\n+// C++14 \u00a720.8.2.2.3 shared_ptr assignment\n+\n+void\n+test01()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[5]> a;\n+  std::experimental::shared_ptr<A[]> a1;\n+  std::experimental::shared_ptr<B[5]> a2;\n+\n+  a = std::experimental::shared_ptr<A[5]> ();\n+  VERIFY( a.get() == 0 );\n+  VERIFY( A::ctor_count == 0 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 0 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  a = std::experimental::shared_ptr<A[5]> (new A[5]);\n+  VERIFY( a.get() != 0 );\n+  VERIFY( A::ctor_count == 5 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 0 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  a1 = std::experimental::shared_ptr<A[5]> (new A[5]);\n+  VERIFY( a1.get() != 0 );\n+  VERIFY( A::ctor_count == 10 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 0 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  a2 = std::experimental::shared_ptr<B[5]> (new B[5]);\n+  VERIFY( a2.get() != 0 );\n+  VERIFY( A::ctor_count == 15 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 5 );\n+  VERIFY( B::dtor_count == 0 );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[5]> p(new A[5]);\n+  std::experimental::shared_ptr<A[5]> p1;\n+  std::experimental::shared_ptr<A[]> p2;\n+\n+  p1 = p;\n+  VERIFY( p.get() == p1.get() );\n+\n+  p2 = p1;\n+  VERIFY( p1.get() == p2.get() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "18c2ba4a4ec752a0e6dcc88a4b292aa560cb35b3", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/cast/cast.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcast%2Fcast.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcast%2Fcast.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcast%2Fcast.cc?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -0,0 +1,44 @@\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.2.1.3 shared_ptr casts [memory.smartptr.shared.cast]\n+\n+#include <experimental/memory>\n+#include <testsuite_tr1.h>\n+\n+// { dg-do compile }\n+\n+struct A { };\n+\n+int\n+main()\n+{\n+  using __gnu_test::check_ret_type;\n+  using std::experimental::shared_ptr;\n+  using std::experimental::static_pointer_cast;\n+  using std::experimental::const_pointer_cast;\n+  using std::experimental::dynamic_pointer_cast;\n+\n+  shared_ptr<A[5]> spa;\n+  shared_ptr<const A[5]> spa1;\n+\n+  check_ret_type<shared_ptr<A[]> >(static_pointer_cast<A[]>(spa));\n+  check_ret_type<shared_ptr<A[]> >(const_pointer_cast<A[]>(spa1));\n+  return 0;\n+}"}, {"sha": "52fc1934ed2bdafebc937fe557ec41182823e1e6", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/comparison/comparison.cc", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcomparison%2Fcomparison.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcomparison%2Fcomparison.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcomparison%2Fcomparison.cc?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -0,0 +1,84 @@\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.2.1 Class template shared_ptr [memory.smartptr.shared]\n+\n+#include <experimental/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+    virtual ~A() { }\n+};\n+\n+struct B : A\n+{\n+};\n+\n+// 20.8.2.2.7 shared_ptr comparison\n+\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  // test empty shared_ptrs compare equivalent\n+  std::experimental::shared_ptr<A[5]> p1;\n+  std::experimental::shared_ptr<B[5]> p2;\n+  VERIFY( p1 == p2 );\n+  VERIFY( !(p1 != p2) );\n+  VERIFY( !(p1 < p2) && !(p2 < p1) );\n+  return 0;\n+}\n+\n+int\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[5]> A_default;\n+\n+  std::experimental::shared_ptr<A[5]> A_from_A(new A[5]);\n+  VERIFY( A_default != A_from_A );\n+  VERIFY( !(A_default == A_from_A) );\n+  VERIFY( (A_default < A_from_A) || (A_from_A < A_default) );\n+\n+  std::experimental::shared_ptr<B[5]> B_from_B(new B[5]);\n+  VERIFY( B_from_B != A_from_A );\n+  VERIFY( !(B_from_B == A_from_A) );\n+  VERIFY( (B_from_B < A_from_A) || (A_from_A < B_from_B) );\n+\n+  A_from_A.reset();\n+  VERIFY( A_default == A_from_A );\n+  VERIFY( !(A_default != A_from_A) );\n+  VERIFY( !(A_default < A_from_A) && !(A_from_A < A_default));\n+\n+  B_from_B.reset();\n+  VERIFY( B_from_B == A_from_A );\n+  VERIFY( !(B_from_B != A_from_A) );\n+  VERIFY( !(B_from_B < A_from_A) && !(A_from_A < B_from_B) );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  return 0;\n+}"}, {"sha": "15d1de8e12a709a371c668a25ce870ed52226069", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/cons/alias_ctor.cc", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Falias_ctor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Falias_ctor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Falias_ctor.cc?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -0,0 +1,100 @@\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.2.1 Class template shared_ptr [memory.smartptr.shared]\n+\n+#include <experimental/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  A() : i() { }\n+  virtual ~A() { }\n+  int i;\n+};\n+\n+struct B : A\n+{\n+  B() : A(), a() { }\n+  virtual ~B() { }\n+  A a;\n+};\n+\n+// 8.2.1.1 shared_ptr constructors [memory.smartptr.shared.const]\n+\n+// Aliasing constructors\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[5]> a;\n+  std::experimental::shared_ptr<bool> b1(a, &test);\n+  VERIFY( b1.use_count() == 0 );\n+  VERIFY( a.get() == 0 );\n+  VERIFY( b1.get() == &test );\n+\n+  std::experimental::shared_ptr<bool> b2(b1);\n+  VERIFY( b2.use_count() == 0 );\n+  VERIFY( b1.get() == b2.get() );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[5]> a(new A[5]);\n+  std::experimental::shared_ptr<int> i1(a, &a[0].i);\n+  VERIFY( i1.use_count() == 2 );\n+\n+  std::experimental::shared_ptr<int> i2(i1);\n+  VERIFY( i2.use_count() == 3 );\n+  VERIFY( i2.get() == &a[0].i );\n+}\n+\n+void\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<B> b(new B);\n+  std::experimental::shared_ptr<A> a1(b, b.get());\n+  std::experimental::shared_ptr<A> a2(b, &b->a);\n+  VERIFY( a2.use_count() == 3 );\n+  VERIFY( a1 == b );\n+  VERIFY( a2 != b );\n+  VERIFY( a1.get() != a2.get() );\n+\n+  std::experimental::shared_ptr<A> a3(a1);\n+  VERIFY( a3 == b );\n+\n+  a3 = a2;\n+  VERIFY( a3.get() == &b->a );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "12eb15ccef6974ea182518bb7317f0039fd090a0", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/cons/alloc_ctor.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Falloc_ctor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Falloc_ctor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Falloc_ctor.cc?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -0,0 +1,73 @@\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.2.1 Class template shared_ptr [memory.smartptr.shared]\n+\n+#include <experimental/memory>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+using __gnu_test::tracker_allocator_counter;\n+using __gnu_test::tracker_allocator;\n+\n+struct A { };\n+void deletefunc(A* p) { delete [] p; }\n+struct D\n+{\n+    void operator()(A* p) { delete [] p; ++delete_count; }\n+    static long delete_count;\n+};\n+long D::delete_count = 0;\n+\n+// 8.2.1.1 shared_ptr constructors [memory.smartptr.shared.const]\n+\n+// Construction with allocator\n+\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  tracker_allocator_counter::reset();\n+\n+  std::experimental::shared_ptr<A[5]> p1(new A[5], deletefunc, tracker_allocator<A[5]>());\n+  std::size_t const sz = tracker_allocator_counter::get_allocation_count();\n+  VERIFY( sz > 0 );\n+  {\n+    std::experimental::shared_ptr<A[5]> p2(p1);\n+    VERIFY( p2.use_count() == 2 );\n+    VERIFY( tracker_allocator_counter::get_allocation_count() == sz );\n+    VERIFY( tracker_allocator_counter::get_deallocation_count() == 0 );\n+  }\n+  VERIFY( p1.use_count() == 1 );\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == sz);\n+  VERIFY( tracker_allocator_counter::get_deallocation_count() == 0 );\n+  p1.reset();\n+  VERIFY( p1.use_count() == 0 );\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == sz );\n+  VERIFY( tracker_allocator_counter::get_deallocation_count() == sz );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "4c3680ed156c6262a43358071fe802b98ef8f294", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/cons/copy_ctor.cc", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fcopy_ctor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fcopy_ctor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fcopy_ctor.cc?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -0,0 +1,178 @@\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.2.1 Class template shared_ptr [memory.smartptr.shared]\n+\n+#include <experimental/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  A() { ++ctor_count; }\n+  virtual ~A() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long A::ctor_count = 0;\n+long A::dtor_count = 0;\n+\n+struct B : A\n+{\n+  B() { ++ctor_count; }\n+  virtual ~B() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long B::ctor_count = 0;\n+long B::dtor_count = 0;\n+\n+void deleter(A* p) { delete [] p; }\n+\n+struct reset_count_struct\n+{\n+  ~reset_count_struct()\n+    {\n+      A::ctor_count = 0;\n+      A::dtor_count = 0;\n+      B::ctor_count = 0;\n+      B::dtor_count = 0;\n+    }\n+};\n+\n+// 8.2.1.1 shared_ptr constructors [memory.smartptr.shared.const]\n+\n+// Copy construction\n+\n+int\n+test01()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[5]> a1;\n+  std::experimental::shared_ptr<A[5]> a2(a1);\n+  VERIFY( a2.use_count() == 0 );\n+  VERIFY( A::ctor_count == 0 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 0 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+test02()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[5]> a1(new A[5]);\n+  std::experimental::shared_ptr<A[5]> a2(a1);\n+  VERIFY( a2.use_count() == 2 );\n+  VERIFY( A::ctor_count == 5 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 0 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+test03()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[5]> a1(new A[5], &deleter);\n+  std::experimental::shared_ptr<A[5]> a2(a1);\n+  VERIFY( a2.use_count() == 2 );\n+  VERIFY( A::ctor_count == 5 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 0 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+test04()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[5]> a1(std::experimental::shared_ptr<A[5]>\n+                                          (new A[5]));\n+  VERIFY( a1.use_count() == 1 );\n+  VERIFY( A::ctor_count == 5 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 0 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+test05()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[5]> a1(new A[5]);\n+  std::experimental::shared_ptr<A[]> a2(a1);\n+\n+  VERIFY( a2.use_count() == 2 );\n+  VERIFY( a2.get() == a1.get() );\n+  VERIFY( A::ctor_count == 5 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 0 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+test06()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<B> a1(new B);\n+  std::experimental::shared_ptr<A> a2(a1);\n+\n+  VERIFY( a2.use_count() == 2 );\n+  VERIFY( a2.get() == a1.get() );\n+  VERIFY( A::ctor_count == 1 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 1 );\n+  VERIFY( B::dtor_count == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  test06();\n+  return 0;\n+}"}, {"sha": "d3c94cf34054caca0f1868d28627ad226253489e", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/cons/copy_ctor_neg.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fcopy_ctor_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fcopy_ctor_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fcopy_ctor_neg.cc?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -0,0 +1,59 @@\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.2.1 Class template shared_ptr [memory.smartptr.shared]\n+\n+\n+#include <experimental/memory>\n+#include <testsuite_hooks.h>\n+\n+\n+struct A { virtual ~A() { } };\n+struct B : A { };\n+\n+\n+// 8.2.1.1 shared_ptr constructors [memory.smartptr.shared.const]\n+\n+// Copy construction\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[3]> a;\n+  a = std::experimental::shared_ptr<B[3]> (new B[3]); // { dg-excess-errors \"no matching\" }\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[]> a(new A[3]);\n+  std::experimental::shared_ptr<A[2]> spa(a); // { dg-excess-errors \"no matching\" }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "794e86528c0f0e7f5c0d5533e5ce2795de530f87", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/cons/default_ctor.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fdefault_ctor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fdefault_ctor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fdefault_ctor.cc?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -0,0 +1,46 @@\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.2.1 Class template shared_ptr [memory.smartptr.shared]\n+\n+#include <experimental/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 8.2.1.1 shared_ptr constructors [memory.smartptr.shared.const]\n+\n+// Default construction\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[5]> a;\n+  VERIFY( a.get() == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "3c070fe669e0b247d037f80a81c9941d7a4ffe7f", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/cons/move_ctor.cc", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fmove_ctor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fmove_ctor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fmove_ctor.cc?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -0,0 +1,146 @@\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.2.1 Class template shared_ptr [memory.smartptr.shared]\n+\n+#include <experimental/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  A() { ++ctor_count; }\n+  virtual ~A() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long A::ctor_count = 0;\n+long A::dtor_count = 0;\n+\n+struct D\n+{\n+  void operator()(A* p) const { delete [] p; ++delete_count; }\n+  static long delete_count;\n+};\n+long D::delete_count = 0;\n+\n+struct reset_count_struct\n+{\n+  ~reset_count_struct()\n+    {\n+      A::ctor_count = 0;\n+      A::dtor_count = 0;\n+      D::delete_count = 0;\n+    }\n+};\n+\n+// 8.2.1.1 shared_ptr constructors [memory.smartptr.shared.const]\n+\n+// Rvalue construction\n+int test01()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[5]> a1;\n+  std::experimental::shared_ptr<A[5]> a2(std::move(a1));\n+  VERIFY( a1.use_count() == 0 );\n+  VERIFY( a2.use_count() == 0 );\n+  VERIFY( A::ctor_count == 0 );\n+  VERIFY( A::dtor_count == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+test02()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[5]> a1(new A[5]);\n+  std::experimental::shared_ptr<A[5]> a2(std::move(a1));\n+  VERIFY( a2.use_count() == 1 );\n+  VERIFY( A::ctor_count == 5 );\n+  VERIFY( A::dtor_count == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+test03()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[5]> b(new A[5], D());\n+  std::experimental::shared_ptr<A[5]> b1(std::move(b));\n+  VERIFY( b.use_count() == 0 );\n+  VERIFY( b1.use_count() == 1 );\n+  VERIFY( A::ctor_count == 5 );\n+  VERIFY( A::dtor_count == 0 );\n+\n+  b1 = std::move(std::experimental::shared_ptr<A[5]> ());\n+\n+  VERIFY( A::ctor_count == 5 );\n+  VERIFY( A::dtor_count == 5 );\n+  VERIFY( D::delete_count == 1 );\n+\n+  return 0;\n+}\n+\n+void\n+test04()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[5]> a(std::move(std::experimental\n+                                        ::shared_ptr<A[5]>\n+                                        (new A[5])));\n+\n+  VERIFY( a.use_count() == 1 );\n+  VERIFY( A::ctor_count == 5 );\n+  VERIFY( A::dtor_count == 0 );\n+}\n+\n+void\n+test05()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[]> a(std::move(std::experimental\n+                                        ::shared_ptr<A[5]>\n+                                        (new A[5])));\n+\n+  VERIFY( a.use_count() == 1 );\n+  VERIFY( A::ctor_count == 5 );\n+  VERIFY( A::dtor_count == 0 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  return 0;\n+}"}, {"sha": "d9ae591a41d9695aef7c8aa7ce92ad9c362196df", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/cons/pointer_ctor.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fpointer_ctor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fpointer_ctor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fpointer_ctor.cc?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -0,0 +1,75 @@\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.2.1 Class template shared_ptr [memory.smartptr.shared]\n+\n+#include <experimental/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+struct B : A { };\n+\n+// 8.2.1.1 shared_ptr constructors [memory.smartptr.shared.const]\n+\n+// Construction from pointer\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = 0;\n+  std::experimental::shared_ptr<A> p(a);\n+  VERIFY( p.get() == 0 );\n+  VERIFY( p.use_count() == 1 );\n+  return 0;\n+}\n+\n+int\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = new A[5];\n+  std::experimental::shared_ptr<A[5]> p(a);\n+  VERIFY( p.get() == a );\n+  VERIFY( p.use_count() == 1 );\n+  return 0;\n+}\n+\n+int\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  B * const b = new B[5];\n+  std::experimental::shared_ptr<A[5]> p(b);\n+  VERIFY( p.get() == b );\n+  VERIFY( p.use_count() == 1 );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "35fb82f36bf1306afacc2f89dfa2b8810801f509", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/cons/unique_ptr_ctor.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Funique_ptr_ctor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Funique_ptr_ctor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Funique_ptr_ctor.cc?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -0,0 +1,60 @@\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.2.1 Class template shared_ptr [memory.smartptr.shared]\n+\n+#include <experimental/memory>\n+#include <testsuite_hooks.h>\n+\n+int destroyed = 0;\n+\n+struct A : std::experimental::enable_shared_from_this<A>\n+{\n+    ~A() { ++destroyed; }\n+};\n+\n+// 8.2.1.1 shared_ptr constructors [memory.smartptr.shared.const]\n+\n+// Construction from unique_ptr<A[]>\n+\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::unique_ptr<A[]> up(new A[5]);\n+  std::experimental::shared_ptr<A> sp(std::move(up));\n+  VERIFY( up.get() == 0 );\n+  VERIFY( sp.get() != 0 );\n+  VERIFY( sp.use_count() == 1 );\n+\n+  VERIFY( sp->shared_from_this() != nullptr );\n+\n+  sp.reset();\n+  VERIFY( destroyed == 5 );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "342b37baa0dbc1767f8e7b749c696606516511af", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/cons/weak_ptr_ctor.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fweak_ptr_ctor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fweak_ptr_ctor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fcons%2Fweak_ptr_ctor.cc?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -0,0 +1,54 @@\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.2.1 Class template shared_ptr [memory.smartptr.shared]\n+\n+#include <experimental/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 8.2.1.1 shared_ptr constructors [memory.smartptr.shared.const]\n+\n+// Construction from weak_ptr\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * a = new A[5];\n+  std::experimental::shared_ptr<A[5]> a1(a);\n+  std::experimental::weak_ptr<A[5]> wa(a1);\n+  std::experimental::shared_ptr<A[5]> a2(wa);\n+  std::experimental::shared_ptr<A[5]> a3 = wa.lock();\n+  VERIFY( a2.get() == a );\n+  VERIFY( a3.get() == a );\n+  VERIFY( a2.use_count() == wa.use_count() );\n+  VERIFY( a3.use_count() == wa.use_count() );\n+\n+  return 0;\n+}\n+\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "989121df90957523ff8ba0eaa1394b18ac553301", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/dest/dest.cc", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fdest%2Fdest.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fdest%2Fdest.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fdest%2Fdest.cc?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -0,0 +1,129 @@\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.2.1 Class template shared_ptr [memory.smartptr.shared]\n+\n+#include <experimental/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  A() { ++ctor_count; }\n+  ~A() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long A::ctor_count = 0;\n+long A::dtor_count = 0;\n+\n+struct B : A\n+{\n+  B() { ++ctor_count; }\n+  ~B() { ++dtor_count; }\n+  static long ctor_count;\n+  static long dtor_count;\n+};\n+long B::ctor_count = 0;\n+long B::dtor_count = 0;\n+\n+struct D\n+{\n+  void operator()(const B* p) { delete [] p; ++delete_count; }\n+  static long delete_count;\n+};\n+long D::delete_count = 0;\n+\n+struct reset_count_struct\n+{\n+  ~reset_count_struct()\n+    {\n+      A::ctor_count = 0;\n+      A::dtor_count = 0;\n+      B::ctor_count = 0;\n+      B::dtor_count = 0;\n+      D::delete_count = 0;\n+    }\n+};\n+\n+// 20.8.2.2.2 shared_ptr destructor\n+\n+int\n+test01()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  {\n+    std::experimental::shared_ptr<A[5]> a;\n+  }\n+  VERIFY( A::ctor_count == 0 );\n+  VERIFY( A::dtor_count == 0 );\n+  VERIFY( B::ctor_count == 0 );\n+  VERIFY( B::dtor_count == 0 );\n+  VERIFY( D::delete_count == 0 );\n+\n+  return 0;\n+}\n+\n+int\n+test02()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  {\n+    std::experimental::shared_ptr<B[5]> a;\n+    a = std::experimental::shared_ptr<B[5]>(new B[5], D());\n+  }\n+  VERIFY( A::ctor_count == 5 );\n+  VERIFY( A::dtor_count == 5 );\n+  VERIFY( B::ctor_count == 5 );\n+  VERIFY( B::dtor_count == 5 );\n+  VERIFY( D::delete_count == 1 );\n+\n+  return 0;\n+}\n+\n+int\n+test03()\n+{\n+  reset_count_struct __attribute__((unused)) reset;\n+  bool test __attribute__((unused)) = true;\n+\n+  {\n+    std::experimental::shared_ptr<B[]> a;\n+    a = std::experimental::shared_ptr<B[5]>(new B[5], D());\n+  }\n+  VERIFY( A::ctor_count == 5 );\n+  VERIFY( A::dtor_count == 5 );\n+  VERIFY( B::ctor_count == 5 );\n+  VERIFY( B::dtor_count == 5 );\n+  VERIFY( D::delete_count == 1 );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "bd1ce1d24b9ec19c614b7265e46f9dcd3cb12695", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/modifiers/reset.cc", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fmodifiers%2Freset.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fmodifiers%2Freset.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fmodifiers%2Freset.cc?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -0,0 +1,89 @@\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.2.1 Class template shared_ptr [memory.smartptr.shared]\n+\n+#include <experimental/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+struct B : A { };\n+struct D\n+{\n+  void operator()(B* p) { delete [] p; ++delete_count; }\n+  static long delete_count;\n+};\n+long D::delete_count = 0;\n+\n+// C++14 \u00a720.8.2.2.4\n+\n+// reset\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = new A[5];\n+  std::experimental::shared_ptr<A[5]> p1(a);\n+  std::experimental::shared_ptr<A[5]> p2(p1);\n+  p1.reset();\n+  VERIFY( p1.get() == 0 );\n+  VERIFY( p2.get() == a );\n+\n+  return 0;\n+}\n+\n+int\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = new A[5];\n+  B * const b = new B[5];\n+  std::experimental::shared_ptr<A[5]> p1(a);\n+  std::experimental::shared_ptr<A[5]> p2(p1);\n+  p1.reset(b);\n+  VERIFY( p1.get() == b );\n+  VERIFY( p2.get() == a );\n+\n+  return 0;\n+}\n+\n+int\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  {\n+    std::experimental::shared_ptr<A[5]> p1;\n+    p1.reset(new B[5], D());\n+  }\n+  VERIFY( D::delete_count == 1 );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "758042caf3adc71e04fceae4d051fd080b00936d", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/modifiers/swap.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fmodifiers%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fmodifiers%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fmodifiers%2Fswap.cc?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -0,0 +1,53 @@\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.2.1 Class template shared_ptr [memory.smartptr.shared]\n+\n+#include <experimental/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// C++14 \u00a720.8.2.2.4\n+\n+// swap\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a1 = new A[5];\n+  A * const a2 = new A[5];\n+  std::experimental::shared_ptr<A[5]> p1(a1);\n+  std::experimental::shared_ptr<A[5]> p2(a2);\n+  p1.swap(p2);\n+  VERIFY( p1.get() == a2 );\n+  VERIFY( p2.get() == a1 );\n+\n+  return 0;\n+}\n+\n+\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "7e4c750a3cfb1b563d73ab73991a4c3d6322f2c5", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/observers/bool_conv.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fobservers%2Fbool_conv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fobservers%2Fbool_conv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fobservers%2Fbool_conv.cc?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -0,0 +1,74 @@\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.2.1 Class template shared_ptr [memory.smartptr.shared]\n+\n+#include <experimental/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 8.2.1.2 shared_ptr observers [memory.smartptr.shared.obs]\n+\n+// Conversion to bool\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const std::experimental::shared_ptr<A[5]> p1;\n+  VERIFY( static_cast<bool>(p1) == false );\n+  const std::experimental::shared_ptr<A[5]> p2(p1);\n+  VERIFY( static_cast<bool>(p2) == false );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[5]> p1(new A[5]);\n+  VERIFY( static_cast<bool>(p1) );\n+  std::experimental::shared_ptr<A[5]> p2(p1);\n+  VERIFY( static_cast<bool>(p2) );\n+  p1.reset();\n+  VERIFY( !static_cast<bool>(p1) );\n+  VERIFY( static_cast<bool>(p2) );\n+}\n+\n+void\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[5]> p1(new A[5]);\n+  std::experimental::shared_ptr<A[5]> p2(p1);\n+  p2.reset(new A[5]);\n+  VERIFY( static_cast<bool>(p1) );\n+  VERIFY( static_cast<bool>(p2) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "d32c89978aa1d9d74c15ed75bc572786e81c61c2", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/observers/operators.cc", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fobservers%2Foperators.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fobservers%2Foperators.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fobservers%2Foperators.cc?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -0,0 +1,93 @@\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.2.1 Class template shared_ptr [memory.smartptr.shared]\n+\n+#include <experimental/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  A() : i() {}\n+  int i;\n+};\n+\n+// 8.2.1.2 shared_ptr observers [memory.smartptr.shared.obs]\n+\n+// get\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = new A[5];\n+  const std::experimental::shared_ptr<A[5]> p(a);\n+  VERIFY( p.get() == a );\n+}\n+\n+// operator []\n+int\n+test02()\n+{\n+  A * p = new A[5];\n+  std::experimental::shared_ptr<A[5]> a(p);\n+\n+  for(int j = 0; j < 5; j++)\n+  { a[j].i = j; }\n+\n+  VERIFY(a.get() == p);\n+  VERIFY(a.use_count() == 1);\n+\n+  for(int j = 0; j < 5; j++)\n+  { VERIFY(a[j].i == j); }\n+\n+  return 0;\n+}\n+\n+// operator*\n+void\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = new A[5];\n+  const std::experimental::shared_ptr<A[5]> p(a);\n+  VERIFY( p.get() == a );\n+}\n+\n+// operator->\n+void\n+test04()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  A * const a = new A[5];\n+  const std::experimental::shared_ptr<A[5]> p(a);\n+  VERIFY( &p[0].i == &a[0].i );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  return 0;\n+}"}, {"sha": "24a658a96f849c0b5325ecc83922bdebc4cc8473", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/observers/owner_before.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fobservers%2Fowner_before.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fobservers%2Fowner_before.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fobservers%2Fowner_before.cc?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -0,0 +1,86 @@\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.2.1 Class template shared_ptr [memory.smartptr.shared]\n+\n+#include <experimental/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  int i;\n+  virtual ~A() { }\n+};\n+\n+struct B : A { };\n+\n+// 8.2.1.2 shared_ptr observers [memory.smartptr.shared.obs]\n+\n+// owner_before\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  // test empty shared_ptrs compare equivalent\n+  std::experimental::shared_ptr<A[5]> p1;\n+  std::experimental::shared_ptr<B[5]> p2;\n+  VERIFY( !p1.owner_before(p2) && !p2.owner_before(p1) );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[5]> a0;\n+\n+  std::experimental::shared_ptr<A[5]> a1(new A[5]);\n+  VERIFY( a1.owner_before(a0) || a0.owner_before(a1) );\n+  VERIFY( !(a1.owner_before(a0) && a0.owner_before(a1)) );\n+\n+  std::experimental::shared_ptr<B[5]> b1(new B[5]);\n+  VERIFY( a1.owner_before(b1) || b1.owner_before(a1) );\n+  VERIFY( !(a1.owner_before(b1) && b1.owner_before(a1)) );\n+\n+  std::experimental::shared_ptr<A[5]> a2(a1);\n+  VERIFY( !a1.owner_before(a2) && !a2.owner_before(a1) );\n+\n+  std::experimental::weak_ptr<A[5]> w1(a1);\n+  VERIFY( !a1.owner_before(w1) && !w1.owner_before(a1) );\n+}\n+\n+void\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[5]> p1(new A[5]);\n+  std::experimental::shared_ptr<int> p2(p1, &p1[0].i);\n+  VERIFY( !p1.owner_before(p2) && !p2.owner_before(p1) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "fc48bf2160d92a1e53558db19b7e35b94c713bf2", "filename": "libstdc++-v3/testsuite/experimental/memory/shared_ptr/observers/use_count.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fobservers%2Fuse_count.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/930d560203039875c4da07a01f579f56f5f2c636/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fobservers%2Fuse_count.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fmemory%2Fshared_ptr%2Fobservers%2Fuse_count.cc?ref=930d560203039875c4da07a01f579f56f5f2c636", "patch": "@@ -0,0 +1,73 @@\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 8.2.1 Class template shared_ptr [memory.smartptr.shared]\n+\n+#include <experimental/memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+struct B : A { };\n+\n+// 8.2.1.2 shared_ptr observers [memory.smartptr.shared.obs]\n+\n+// use_count\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  const std::experimental::shared_ptr<A[5]> p1;\n+  VERIFY( p1.use_count() == 0 );\n+  const std::experimental::shared_ptr<A[5]> p2(p1);\n+  VERIFY( p1.use_count() == 0 );\n+}\n+\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[5]> p1(new A[5]);\n+  std::experimental::shared_ptr<A[5]> p2(p1);\n+  p1.reset();\n+  VERIFY( p1.use_count() == 0 );\n+  VERIFY( p2.use_count() == 1 );\n+}\n+\n+void\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::experimental::shared_ptr<A[5]> p1(new A[5]);\n+  std::experimental::shared_ptr<A[5]> p2(p1);\n+  p2.reset(new B[5]);\n+  VERIFY( p1.use_count() == 1 );\n+  VERIFY( p2.use_count() == 1 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}]}