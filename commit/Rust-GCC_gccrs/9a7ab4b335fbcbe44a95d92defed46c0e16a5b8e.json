{"sha": "9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE3YWI0YjMzNWZiY2JlNDRhOTVkOTJkZWZlZDQ2YzBlMTZhNWI4ZQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-06-22T05:17:35Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-06-22T05:17:35Z"}, "message": "[multiple changes]\n\n2000-06-21  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* except.c (prepare_eh_table_type): Use `CATCH_ALL_TYPE'.\n\n2000-06-20  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* check-init.c (ENABLE_JC1_CHECKING): Replaces ENABLE_CHECKING for\n\tJava specific checks.\n\t* expr.c (build_instanceof): CLASS_INTERFACE and CLASS_FINAL usage\n\tscreened by DECL_P.\n\t* java-tree.def (CASE_EXPR): Marked 'e'.\n\t(DEFAULT_EXPR): Likewise.\n\t* jcf-parse.c (set_source_filename): CLASS_COMPLETE_P usage\n\tscreened by DECL_P.\n\t* jcf-write.c (ENABLE_JC1_CHECKING): Replaces ENABLE_CHECKING for\n\tJava specific checks.\n\t(generate_bytecode_insns): Test try_block for BLOCK before using\n\tBLOCK_EXPR_BODY.\n\t* parse.y (build_wfl_wrap): Added `location' argument. Set\n\tEXPR_WFL_LINECOL accordingly.\n\t(dim_expr:): Wrap constants with WFLs.\n\t(method_declarator): Use TREE_TYPE not TYPE_NAME on GET_CPC.\n\t(resolve_package): Check for `stmt' not being a BLOCK before\n\tbuilding a debuggable statement with it.\n\t(make_qualified_primary): Added extra parameter to build_wfl_wrap\n\tinvocation.\n\t(resolve_field_access): Make sure `decl' is a DECL before treating\n\tit as such.\n\t(maybe_build_primttype_type_ref): Make sure `wfl''s node is an\n\tIDENTIFIER_NODE before treating it as such.\n\t(patch_new_array_init): Make sure `elt' is a TREE_LIST before\n\ttreating it as such.\n\t(find_applicable_accessible_methods_list): CLASS_INTERFACE macro\n\tto be applied only on non array types.\n\n2000-06-16  Per Bothner  <per@bothner.com>\n\n\t* java-tree.h (LABEL_RETURN_LABELS, LABEL_PENDING_CHAIN):  Don't\n\tdefine in terms of DECL_RESULT, as that fails when --enable-checking.\n\n2000-06-06  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* parse.h (REGISTER_IMPORT): Use `chainon' to link new entries.\n\t* parse.y (find_in_imports): Returned type changed to void,\n\tleading comment fixed.\n\t(register_package): New function.\n\t(qualify_and_find): Likewise.\n\t(package_declaration:): Use `register_package'.\n\t(single_type_import_declaration:): Removed local variable\n\t`node'. Added missing `;' for consistency.\n\t(type_import_on_demand_declaration:): Use `chainon' to link new\n\tentries.\n\t(lookup_field_wrapper): Lookup local variables defined in outer\n\tcontexts first.\n\t(java_complete_class): Don't reverse the list of imported on demand.\n\t(do_resolve_class): Reorganized. Removed local variable\n\t`original_name'. Call `qualify_and_find' with the current package\n\tname, invoke `find_in_imports_on_demand' right after. Call\n\t`qualify_and_find' with the packages we've seen so far. Fixed\n\toperations numbering in comments.\n\t(java_expand_class): Don't reverse `package_list'.\n\t(find_most_specific_methods_list): New local variables `abstract'\n\tand `candidates'. Use them to pick the right method.\n\n(Fixes for the ENABLE_TREE_CHECKING Java run-time build problem:\n http://gcc.gnu.org/ml/gcc-patches/2000-06/msg00551.html)\n\nFrom-SVN: r34642", "tree": {"sha": "ff9df27c0d4cd502638abc1b22e1967847919550", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff9df27c0d4cd502638abc1b22e1967847919550"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/comments", "author": null, "committer": null, "parents": [{"sha": "e605b0403e89c0286910889cfca158bfc2567cfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e605b0403e89c0286910889cfca158bfc2567cfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e605b0403e89c0286910889cfca158bfc2567cfa"}], "stats": {"total": 1430, "additions": 806, "deletions": 624}, "files": [{"sha": "70b26f0bc28e9e5f59b7b80e39262c9e6bc344e9", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e", "patch": "@@ -1,3 +1,43 @@\n+2000-06-21  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* except.c (prepare_eh_table_type): Use `CATCH_ALL_TYPE'.\n+\n+2000-06-20  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* check-init.c (ENABLE_JC1_CHECKING): Replaces ENABLE_CHECKING for\n+\tJava specific checks.\n+\t* expr.c (build_instanceof): CLASS_INTERFACE and CLASS_FINAL usage\n+\tscreened by DECL_P.\n+\t* java-tree.def (CASE_EXPR): Marked 'e'.\n+\t(DEFAULT_EXPR): Likewise.\n+\t* jcf-parse.c (set_source_filename): CLASS_COMPLETE_P usage\n+\tscreened by DECL_P.\n+\t* jcf-write.c (ENABLE_JC1_CHECKING): Replaces ENABLE_CHECKING for\n+\tJava specific checks.\n+\t(generate_bytecode_insns): Test try_block for BLOCK before using\n+\tBLOCK_EXPR_BODY.\n+\t* parse.y (build_wfl_wrap): Added `location' argument. Set\n+\tEXPR_WFL_LINECOL accordingly.\n+\t(dim_expr:): Wrap constants with WFLs.\n+\t(method_declarator): Use TREE_TYPE not TYPE_NAME on GET_CPC.\n+\t(resolve_package): Check for `stmt' not being a BLOCK before\n+\tbuilding a debuggable statement with it.\n+\t(make_qualified_primary): Added extra parameter to build_wfl_wrap\n+\tinvocation.\n+\t(resolve_field_access): Make sure `decl' is a DECL before treating\n+\tit as such.\n+\t(maybe_build_primttype_type_ref): Make sure `wfl''s node is an\n+\tIDENTIFIER_NODE before treating it as such.\n+\t(patch_new_array_init): Make sure `elt' is a TREE_LIST before\n+\ttreating it as such.\n+\t(find_applicable_accessible_methods_list): CLASS_INTERFACE macro\n+\tto be applied only on non array types.\n+\n+2000-06-16  Per Bothner  <per@bothner.com>\n+\n+\t* java-tree.h (LABEL_RETURN_LABELS, LABEL_PENDING_CHAIN):  Don't\n+\tdefine in terms of DECL_RESULT, as that fails when --enable-checking.\n+\t\n 2000-06-15  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* jcf-write.c (CHECK_PUT): Add static prototype.  Make pointer\n@@ -19,6 +59,30 @@\n \n \t* lang.c (lang_get_alias_set): Mark parameter with ATTRIBUTE_UNUSED.\n \n+2000-06-06  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.h (REGISTER_IMPORT): Use `chainon' to link new entries.\n+\t* parse.y (find_in_imports): Returned type changed to void,\n+\tleading comment fixed.\n+\t(register_package): New function.\n+\t(qualify_and_find): Likewise.\n+\t(package_declaration:): Use `register_package'.\n+\t(single_type_import_declaration:): Removed local variable\n+\t`node'. Added missing `;' for consistency.\n+\t(type_import_on_demand_declaration:): Use `chainon' to link new\n+\tentries.\n+\t(lookup_field_wrapper): Lookup local variables defined in outer\n+\tcontexts first.\n+\t(java_complete_class): Don't reverse the list of imported on demand.\n+\t(do_resolve_class): Reorganized. Removed local variable\n+\t`original_name'. Call `qualify_and_find' with the current package\n+\tname, invoke `find_in_imports_on_demand' right after. Call\n+\t`qualify_and_find' with the packages we've seen so far. Fixed\n+\toperations numbering in comments.\n+\t(java_expand_class): Don't reverse `package_list'.\n+\t(find_most_specific_methods_list): New local variables `abstract'\n+\tand `candidates'. Use them to pick the right method.\n+\n Tue Jun  6 11:39:05 2000  Tom Tromey  <tromey@ferrule.cygnus.com>\n \n \t* parse.y (check_modifiers_consistency): Don't subtract out"}, {"sha": "ffa65da393edbf08a82893fd7c5fc291080f9d52", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e", "patch": "@@ -463,7 +463,7 @@ check_init (exp, before)\n \twords tmp = ALLOC_WORDS (2 * num_current_words);\n \twords when_true = tmp;\n \twords when_false = tmp + num_current_words;\n-#ifdef ENABLE_CHECKING\n+#ifdef ENABLE_JC1_CHECKING\n \tif (TREE_CODE (alt->block) != LOOP_EXPR)\n \t  fatal (\"internal error in check-init:  EXIT_EXPR not in LOOP_EXPR\");\n #endif\n@@ -534,7 +534,7 @@ check_init (exp, before)\n     case WITH_CLEANUP_EXPR:\n       {\n \tstruct alternatives *alt = alternatives;\t\n-#ifdef ENABLE_CHECKING\n+#ifdef ENABLE_JC1_CHECKING\n \tif (TREE_CODE (alt->block) != CLEANUP_POINT_EXPR)\n \t  fatal (\"internal error in check-init:  WITH_CLEANUP_EXPR not in CLEANUP_POINT_EXPR\");\n #endif"}, {"sha": "9075e6168f8b921716a410c16d15bd8d97822ed5", "filename": "gcc/java/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e", "patch": "@@ -325,7 +325,7 @@ prepare_eh_table_type (type)\n \n   push_obstacks (&permanent_obstack, &permanent_obstack);\n   if (type == NULL_TREE)\n-    exp = null_pointer_node;\n+    exp = CATCH_ALL_TYPE;\n   else if (is_compiled_class (type))\n     exp = build_class_ref (type);\n   else"}, {"sha": "886c0cde9b09fe6587aecebb20ce7f4ec8a49ee2", "filename": "gcc/java/expr.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e", "patch": "@@ -1087,7 +1087,8 @@ build_instanceof (value, type)\n \t\t    value,\n \t\t    boolean_true_node, boolean_false_node);\n     }\n-  else if (! CLASS_INTERFACE (valclass)\n+  else if (DECL_P (klass) && DECL_P (valclass)\n+\t   && ! CLASS_INTERFACE (valclass)\n \t   && ! CLASS_INTERFACE (klass)\n \t   && ! inherits_from_p (type, valtype)\n \t   && (CLASS_FINAL (klass)\n@@ -1097,7 +1098,7 @@ build_instanceof (value, type)\n \t tree, so we immediately know the answer.  */\n       expr = boolean_false_node;\n     }\n-  else if (CLASS_FINAL (klass))\n+  else if (DECL_P (klass) && CLASS_FINAL (klass))\n     {\n       tree save = save_expr (value);\n       expr = build (COND_EXPR, itype,"}, {"sha": "930979b5b240bddb26205fc1a4d9982d7a3a3531", "filename": "gcc/java/java-tree.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/gcc%2Fjava%2Fjava-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/gcc%2Fjava%2Fjava-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.def?ref=9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e", "patch": "@@ -42,10 +42,10 @@ DEFTREECODE (THIS_EXPR, \"this\", '1', 0)\n \n /* Case statement expression.\n    Operand 1 is the case value.  */\n-DEFTREECODE (CASE_EXPR, \"case\", 'x', 1)\n+DEFTREECODE (CASE_EXPR, \"case\", 'e', 1)\n \n /* Default statement expression. */\n-DEFTREECODE (DEFAULT_EXPR, \"default\", 'x', 0)\n+DEFTREECODE (DEFAULT_EXPR, \"default\", 'e', 0)\n \n /* Try expression\n    Operand 0 is the tried block,"}, {"sha": "6f3d3274d944d951068e006ecf53158029388d7f", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e", "patch": "@@ -465,11 +465,12 @@ struct lang_identifier\n #define RETURN_MAP_ADJUSTED(NODE) TREE_LANG_FLAG_2(NODE)\n \n /* In the label of a sub-routine, a chain of the return location labels. */\n-#define LABEL_RETURN_LABELS(node) DECL_RESULT (LABEL_RETURN_LABEL(node))\n+#define LABEL_RETURN_LABELS(node) \\\n+  (LABEL_DECL_CHECK (LABEL_RETURN_LABEL(node))->decl.result)\n \n /* In a LABEL_DECL, the next pending label.\n    See pending_blocks in expr.c. */\n-#define LABEL_PENDING_CHAIN(NODE) DECL_RESULT(NODE)\n+#define LABEL_PENDING_CHAIN(NODE) (LABEL_DECL_CHECK (NODE)->decl.result)\n \n /* In a LABEL_DECL, the corresponding bytecode program counter. */\n #define LABEL_PC(NODE) ((NODE)->decl.u2.i)"}, {"sha": "bd41b8b8ab7a33fc00779f64b7b25b6c14275bf8", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e", "patch": "@@ -193,7 +193,7 @@ set_source_filename (jcf, index)\n   while (c--)\t\t\t\t\t\t\t\t  \\\n     {\t\t\t\t\t\t\t\t\t  \\\n       tree class = get_class_constant (jcf, JCF_readu2 (jcf));\t    \t  \\\n-      if (!CLASS_COMPLETE_P (class))\t\t\t\t\t  \\\n+      if (DECL_P (class) && !CLASS_COMPLETE_P (class))\t\t\t  \\\n \t{\t\t\t\t\t\t\t\t  \\\n \t  tree outer = TYPE_NAME (get_class_constant (jcf, \t\t  \\\n \t\t\t\t\t\t      JCF_readu2 (jcf))); \\"}, {"sha": "3fc8b30608c66b52c5458aefda95ae523e4b0e09", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e", "patch": "@@ -347,7 +347,7 @@ static void append_innerclasses_attribute_entry PARAMS ((struct jcf_partial *, t\n    We assume a local variable 'ptr' points into where we want to\n    write next, and we assume enoygh space has been allocated. */\n \n-#ifdef ENABLE_CHECKING\n+#ifdef ENABLE_JC1_CHECKING\n static int CHECK_PUT PARAMS ((void *, struct jcf_partial *, int));\n \n static int\n@@ -403,7 +403,7 @@ alloc_chunk (last, data, size, work)\n   return chunk;\n }\n \n-#ifdef ENABLE_CHECKING\n+#ifdef ENABLE_JC1_CHECKING\n static int CHECK_OP PARAMS ((struct jcf_partial *));\n \n static int\n@@ -2358,6 +2358,7 @@ generate_bytecode_insns (exp, target, state)\n \t  }\n \n \tif (CAN_COMPLETE_NORMALLY (try_block)\n+\t    && TREE_CODE (try_block) == BLOCK\n \t    && BLOCK_EXPR_BODY (try_block) != empty_stmt_node)\n \t  emit_goto (finished_label, state);\n "}, {"sha": "415d8775487e3110192f6799b320b91b640e6dc2", "filename": "gcc/java/parse.c", "status": "modified", "additions": 577, "deletions": 520, "changes": 1097, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e", "patch": "@@ -174,8 +174,9 @@ static void complete_class_report_errors PARAMS ((jdep *));\n static int process_imports PARAMS ((void));\n static void read_import_dir PARAMS ((tree));\n static int find_in_imports_on_demand PARAMS ((tree));\n-static int find_in_imports PARAMS ((tree));\n+static void find_in_imports PARAMS ((tree));\n static int check_pkg_class_access PARAMS ((tree, tree));\n+static void register_package PARAMS ((tree));\n static tree resolve_package PARAMS ((tree, tree *));\n static tree lookup_package_type PARAMS ((const char *, int));\n static tree lookup_package_type_and_set_next PARAMS ((const char *, int, tree *));\n@@ -195,6 +196,7 @@ static tree patch_method_invocation PARAMS ((tree, tree, tree,\n \t\t\t\t\t    int *, tree *));\n static int breakdown_qualified PARAMS ((tree *, tree *, tree));\n static tree resolve_and_layout PARAMS ((tree, tree));\n+static tree qualify_and_find PARAMS ((tree, tree, tree));\n static tree resolve_no_layout PARAMS ((tree, tree));\n static int invocation_mode PARAMS ((tree, int));\n static tree find_applicable_accessible_methods_list PARAMS ((int, tree, \n@@ -209,7 +211,7 @@ static tree lookup_method_invoke PARAMS ((int, tree, tree, tree, tree));\n static tree register_incomplete_type PARAMS ((int, tree, tree, tree));\n static tree obtain_incomplete_type PARAMS ((tree));\n static tree java_complete_lhs PARAMS ((tree));\n-static tree java_complete_tree PARAMS ((tree));\n+tree java_complete_tree PARAMS ((tree));\n static tree maybe_generate_pre_expand_clinit PARAMS ((tree));\n static int maybe_yank_clinit PARAMS ((tree));\n static void java_complete_expand_method PARAMS ((tree));\n@@ -255,7 +257,7 @@ static tree build_newarray_node PARAMS ((tree, tree, int));\n static tree patch_newarray PARAMS ((tree));\n static tree resolve_type_during_patch PARAMS ((tree));\n static tree build_this PARAMS ((int));\n-static tree build_wfl_wrap PARAMS ((tree));\n+static tree build_wfl_wrap PARAMS ((tree, int));\n static tree build_return PARAMS ((int, tree));\n static tree patch_return PARAMS ((tree));\n static tree maybe_access_field PARAMS ((tree, tree, tree));\n@@ -486,7 +488,7 @@ static tree package_list = NULL_TREE;\n } while (0)\n \n \n-#line 415 \"./parse.y\"\n+#line 417 \"./parse.y\"\n typedef union {\n   tree node;\n   int sub_token;\n@@ -496,7 +498,7 @@ typedef union {\n   } operator;\n   int value;\n } YYSTYPE;\n-#line 425 \"./parse.y\"\n+#line 427 \"./parse.y\"\n \n #include \"lex.c\"\n #ifndef YYDEBUG\n@@ -797,57 +799,57 @@ static const short yyrhs[] = {   123,\n \n #if YYDEBUG != 0\n static const short yyrline[] = { 0,\n-   574,   580,   582,   583,   584,   585,   586,   590,   592,   595,\n-   597,   598,   601,   603,   606,   610,   614,   618,   624,   626,\n-   628,   630,   635,   637,   640,   644,   649,   654,   656,   657,\n-   658,   659,   660,   661,   662,   665,   670,   676,   678,   681,\n-   687,   689,   693,   695,   698,   725,   727,   731,   744,   746,\n-   750,   753,   755,   757,   767,   772,   787,   791,   791,   794,\n-   794,   796,   798,   803,   807,   809,   811,   813,   817,   819,\n-   821,   828,   834,   839,   843,   852,   862,   864,   867,   869,\n-   870,   871,   878,   880,   882,   883,   885,   890,   893,   903,\n-   906,   908,   912,   915,   922,   928,   936,   938,   940,   942,\n-   944,   948,   950,   954,   965,   966,   970,   973,   975,   977,\n-   979,   984,   986,   988,   990,   997,  1003,  1005,  1014,  1016,\n-  1020,  1025,  1030,  1034,  1039,  1044,  1049,  1056,  1066,  1068,\n-  1070,  1074,  1077,  1079,  1083,  1085,  1086,  1091,  1097,  1104,\n-  1120,  1127,  1130,  1133,  1137,  1143,  1147,  1156,  1158,  1160,\n-  1164,  1166,  1169,  1176,  1184,  1186,  1190,  1197,  1207,  1211,\n-  1211,  1214,  1214,  1217,  1217,  1220,  1220,  1222,  1226,  1232,\n-  1237,  1239,  1243,  1246,  1250,  1252,  1255,  1257,  1258,  1260,\n-  1264,  1268,  1274,  1279,  1282,  1284,  1288,  1294,  1298,  1303,\n-  1312,  1316,  1321,  1335,  1337,  1340,  1342,  1344,  1351,  1355,\n-  1358,  1362,  1364,  1365,  1366,  1367,  1368,  1372,  1374,  1375,\n-  1376,  1377,  1381,  1383,  1384,  1385,  1386,  1387,  1388,  1389,\n-  1390,  1391,  1392,  1395,  1400,  1411,  1414,  1418,  1425,  1435,\n-  1441,  1447,  1453,  1455,  1460,  1462,  1467,  1469,  1471,  1473,\n-  1475,  1479,  1481,  1482,  1483,  1484,  1485,  1486,  1489,  1495,\n-  1497,  1499,  1503,  1508,  1513,  1519,  1529,  1535,  1537,  1539,\n-  1546,  1549,  1551,  1553,  1557,  1559,  1562,  1566,  1568,  1571,\n-  1578,  1584,  1586,  1588,  1592,  1600,  1603,  1605,  1607,  1611,\n-  1616,  1625,  1630,  1633,  1640,  1642,  1644,  1648,  1651,  1660,\n-  1667,  1669,  1673,  1686,  1688,  1694,  1700,  1704,  1706,  1710,\n-  1713,  1715,  1719,  1722,  1724,  1726,  1730,  1733,  1735,  1737,\n-  1741,  1744,  1746,  1748,  1752,  1758,  1760,  1764,  1771,  1773,\n-  1775,  1777,  1781,  1793,  1796,  1798,  1803,  1807,  1809,  1816,\n-  1824,  1841,  1843,  1848,  1852,  1855,  1860,  1862,  1865,  1867,\n-  1869,  1871,  1872,  1873,  1874,  1875,  1879,  1884,  1886,  1888,\n-  1890,  1897,  1903,  1912,  1915,  1917,  1919,  1923,  1926,  1928,\n-  1932,  1938,  1939,  1945,  1946,  1948,  1950,  1952,  1954,  1956,\n-  1965,  1969,  1999,  2002,  2016,  2019,  2023,  2029,  2034,  2038,\n-  2041,  2043,  2045,  2049,  2058,  2066,  2068,  2072,  2075,  2079,\n-  2085,  2087,  2095,  2122,  2124,  2128,  2133,  2140,  2144,  2147,\n-  2149,  2160,  2171,  2176,  2185,  2187,  2191,  2194,  2196,  2201,\n-  2206,  2211,  2218,  2220,  2221,  2222,  2225,  2230,  2235,  2237,\n-  2238,  2240,  2242,  2243,  2245,  2249,  2252,  2256,  2259,  2263,\n-  2265,  2267,  2269,  2270,  2272,  2276,  2285,  2287,  2289,  2302,\n-  2304,  2310,  2312,  2314,  2318,  2320,  2325,  2330,  2335,  2337,\n-  2339,  2343,  2345,  2350,  2355,  2357,  2361,  2363,  2368,  2373,\n-  2378,  2380,  2382,  2386,  2388,  2393,  2398,  2403,  2408,  2410,\n-  2412,  2414,  2416,  2418,  2422,  2424,  2429,  2434,  2436,  2440,\n-  2442,  2447,  2451,  2453,  2458,  2462,  2464,  2469,  2473,  2475,\n-  2480,  2484,  2486,  2491,  2495,  2497,  2502,  2508,  2510,  2514,\n-  2516,  2519,  2522,  2530,  2532,  2533,  2536,  2538,  2541,  2545\n+   576,   582,   584,   585,   586,   587,   588,   592,   594,   597,\n+   599,   600,   603,   605,   608,   612,   616,   620,   626,   628,\n+   630,   632,   637,   639,   642,   646,   651,   656,   658,   659,\n+   660,   661,   662,   663,   664,   667,   672,   678,   680,   683,\n+   689,   691,   695,   697,   700,   727,   729,   733,   746,   748,\n+   752,   755,   757,   759,   769,   774,   789,   793,   793,   796,\n+   796,   798,   800,   805,   809,   811,   813,   815,   819,   821,\n+   823,   830,   836,   841,   845,   854,   864,   866,   869,   871,\n+   872,   873,   880,   882,   884,   885,   887,   892,   895,   905,\n+   908,   910,   914,   917,   924,   930,   938,   940,   942,   944,\n+   946,   950,   952,   956,   967,   968,   972,   975,   977,   979,\n+   981,   986,   988,   990,   992,   999,  1005,  1007,  1016,  1018,\n+  1022,  1027,  1032,  1036,  1041,  1046,  1051,  1058,  1068,  1070,\n+  1072,  1076,  1079,  1081,  1085,  1087,  1088,  1093,  1099,  1106,\n+  1122,  1129,  1132,  1135,  1139,  1145,  1149,  1158,  1160,  1162,\n+  1166,  1168,  1171,  1178,  1186,  1188,  1192,  1199,  1209,  1213,\n+  1213,  1216,  1216,  1219,  1219,  1222,  1222,  1224,  1228,  1234,\n+  1239,  1241,  1245,  1248,  1252,  1254,  1257,  1259,  1260,  1262,\n+  1266,  1270,  1276,  1281,  1284,  1286,  1290,  1296,  1300,  1305,\n+  1314,  1318,  1323,  1337,  1339,  1342,  1344,  1346,  1353,  1357,\n+  1360,  1364,  1366,  1367,  1368,  1369,  1370,  1374,  1376,  1377,\n+  1378,  1379,  1383,  1385,  1386,  1387,  1388,  1389,  1390,  1391,\n+  1392,  1393,  1394,  1397,  1402,  1413,  1416,  1420,  1427,  1437,\n+  1443,  1449,  1455,  1457,  1462,  1464,  1469,  1471,  1473,  1475,\n+  1477,  1481,  1483,  1484,  1485,  1486,  1487,  1488,  1491,  1497,\n+  1499,  1501,  1505,  1510,  1515,  1521,  1531,  1537,  1539,  1541,\n+  1548,  1551,  1553,  1555,  1559,  1561,  1564,  1568,  1570,  1573,\n+  1580,  1586,  1588,  1590,  1594,  1602,  1605,  1607,  1609,  1613,\n+  1618,  1627,  1632,  1635,  1642,  1644,  1646,  1650,  1653,  1662,\n+  1669,  1671,  1675,  1688,  1690,  1696,  1702,  1706,  1708,  1712,\n+  1715,  1717,  1721,  1724,  1726,  1728,  1732,  1735,  1737,  1739,\n+  1743,  1746,  1748,  1750,  1754,  1760,  1762,  1766,  1773,  1775,\n+  1777,  1779,  1783,  1795,  1798,  1800,  1805,  1809,  1811,  1818,\n+  1826,  1843,  1845,  1850,  1854,  1857,  1862,  1864,  1867,  1869,\n+  1871,  1873,  1874,  1875,  1876,  1877,  1881,  1886,  1888,  1890,\n+  1892,  1899,  1905,  1914,  1917,  1919,  1921,  1925,  1928,  1930,\n+  1934,  1940,  1941,  1947,  1948,  1950,  1952,  1954,  1956,  1958,\n+  1967,  1971,  2001,  2004,  2018,  2021,  2025,  2031,  2036,  2040,\n+  2043,  2045,  2047,  2051,  2060,  2068,  2070,  2074,  2077,  2081,\n+  2092,  2094,  2102,  2129,  2131,  2135,  2140,  2147,  2151,  2154,\n+  2156,  2167,  2178,  2183,  2192,  2194,  2198,  2201,  2203,  2208,\n+  2213,  2218,  2225,  2227,  2228,  2229,  2232,  2237,  2242,  2244,\n+  2245,  2247,  2249,  2250,  2252,  2256,  2259,  2263,  2266,  2270,\n+  2272,  2274,  2276,  2277,  2279,  2283,  2292,  2294,  2296,  2309,\n+  2311,  2317,  2319,  2321,  2325,  2327,  2332,  2337,  2342,  2344,\n+  2346,  2350,  2352,  2357,  2362,  2364,  2368,  2370,  2375,  2380,\n+  2385,  2387,  2389,  2393,  2395,  2400,  2405,  2410,  2415,  2417,\n+  2419,  2421,  2423,  2425,  2429,  2431,  2436,  2441,  2443,  2447,\n+  2449,  2454,  2458,  2460,  2465,  2469,  2471,  2476,  2480,  2482,\n+  2487,  2491,  2493,  2498,  2502,  2504,  2509,  2515,  2517,  2521,\n+  2523,  2526,  2529,  2537,  2539,  2540,  2543,  2545,  2548,  2552\n };\n #endif\n \n@@ -2930,71 +2932,71 @@ yyparse(YYPARSE_PARAM_ARG)\n   switch (yyn) {\n \n case 1:\n-#line 576 \"./parse.y\"\n+#line 578 \"./parse.y\"\n {;\n     break;}\n case 18:\n-#line 620 \"./parse.y\"\n+#line 622 \"./parse.y\"\n { \n \t\t  yyval.node = build_java_array_type (yyvsp[-2].node, -1);\n \t\t  CLASS_LOADED_P (yyval.node) = 1;\n \t\t;\n     break;}\n case 19:\n-#line 625 \"./parse.y\"\n+#line 627 \"./parse.y\"\n { yyval.node = build_unresolved_array_type (yyvsp[-2].node); ;\n     break;}\n case 20:\n-#line 627 \"./parse.y\"\n+#line 629 \"./parse.y\"\n { yyval.node = build_unresolved_array_type (yyvsp[-2].node); ;\n     break;}\n case 21:\n-#line 629 \"./parse.y\"\n+#line 631 \"./parse.y\"\n {RULE (\"']' expected\"); RECOVER;;\n     break;}\n case 22:\n-#line 631 \"./parse.y\"\n+#line 633 \"./parse.y\"\n {RULE (\"']' expected\"); RECOVER;;\n     break;}\n case 26:\n-#line 646 \"./parse.y\"\n+#line 648 \"./parse.y\"\n { yyval.node = make_qualified_name (yyvsp[-2].node, yyvsp[0].node, yyvsp[-1].operator.location); ;\n     break;}\n case 28:\n-#line 655 \"./parse.y\"\n+#line 657 \"./parse.y\"\n {yyval.node = NULL;;\n     break;}\n case 36:\n-#line 667 \"./parse.y\"\n+#line 669 \"./parse.y\"\n {\n \t\t  yyval.node = NULL;\n \t\t;\n     break;}\n case 37:\n-#line 671 \"./parse.y\"\n+#line 673 \"./parse.y\"\n {\n \t\t  yyval.node = NULL;\n \t\t;\n     break;}\n case 40:\n-#line 683 \"./parse.y\"\n+#line 685 \"./parse.y\"\n { \n \t\t  ctxp->package = EXPR_WFL_NODE (yyvsp[-1].node);\n-\t\t  package_list = tree_cons (ctxp->package, NULL, package_list);\n+\t\t  register_package (ctxp->package);\n \t\t;\n     break;}\n case 41:\n-#line 688 \"./parse.y\"\n+#line 690 \"./parse.y\"\n {yyerror (\"Missing name\"); RECOVER;;\n     break;}\n case 42:\n-#line 690 \"./parse.y\"\n+#line 692 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 45:\n-#line 700 \"./parse.y\"\n+#line 702 \"./parse.y\"\n {\n-\t\t  tree name = EXPR_WFL_NODE (yyvsp[-1].node), node, last_name;\n+\t\t  tree name = EXPR_WFL_NODE (yyvsp[-1].node), last_name;\n \t\t  int   i = IDENTIFIER_LENGTH (name)-1;\n \t\t  const char *last = &IDENTIFIER_POINTER (name)[i];\n \t\t  while (last != IDENTIFIER_POINTER (name))\n@@ -3013,69 +3015,69 @@ case 45:\n \t\t\t   IDENTIFIER_POINTER (name), \n \t\t\t   IDENTIFIER_POINTER (err));\n \t\t      else\n-\t\t\tREGISTER_IMPORT (yyvsp[-1].node, last_name)\n+\t\t\tREGISTER_IMPORT (yyvsp[-1].node, last_name);\n \t\t    }\n \t\t  else\n \t\t    REGISTER_IMPORT (yyvsp[-1].node, last_name);\n \t\t;\n     break;}\n case 46:\n-#line 726 \"./parse.y\"\n+#line 728 \"./parse.y\"\n {yyerror (\"Missing name\"); RECOVER;;\n     break;}\n case 47:\n-#line 728 \"./parse.y\"\n+#line 730 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 48:\n-#line 733 \"./parse.y\"\n+#line 735 \"./parse.y\"\n {\n \t\t  tree name = EXPR_WFL_NODE (yyvsp[-3].node);\n \t\t  /* Don't import java.lang.* twice. */\n \t\t  if (name != java_lang_id)\n \t\t    {\n-\t\t      tree node = build_tree_list (yyvsp[-3].node, NULL_TREE);\n \t\t      read_import_dir (yyvsp[-3].node);\n-\t\t      TREE_CHAIN (node) = ctxp->import_demand_list;\n-\t\t      ctxp->import_demand_list = node;\n+\t\t      ctxp->import_demand_list = \n+\t\t\tchainon (ctxp->import_demand_list,\n+\t\t\t\t build_tree_list (yyvsp[-3].node, NULL_TREE));\n \t\t    }\n \t\t;\n     break;}\n case 49:\n-#line 745 \"./parse.y\"\n+#line 747 \"./parse.y\"\n {yyerror (\"'*' expected\"); RECOVER;;\n     break;}\n case 50:\n-#line 747 \"./parse.y\"\n+#line 749 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 51:\n-#line 752 \"./parse.y\"\n+#line 754 \"./parse.y\"\n { end_class_declaration (0); ;\n     break;}\n case 52:\n-#line 754 \"./parse.y\"\n+#line 756 \"./parse.y\"\n { end_class_declaration (0); ;\n     break;}\n case 53:\n-#line 756 \"./parse.y\"\n+#line 758 \"./parse.y\"\n { yyval.node = NULL; ;\n     break;}\n case 54:\n-#line 758 \"./parse.y\"\n+#line 760 \"./parse.y\"\n {\n \t\t  YYERROR_NOW;\n \t\t  yyerror (\"Class or interface declaration expected\");\n \t\t;\n     break;}\n case 55:\n-#line 769 \"./parse.y\"\n+#line 771 \"./parse.y\"\n {\n \t\t  yyval.value = (1 << yyvsp[0].value);\n \t\t;\n     break;}\n case 56:\n-#line 773 \"./parse.y\"\n+#line 775 \"./parse.y\"\n {\n \t\t  int acc = (1 << yyvsp[0].value);\n \t\t  if (yyval.value & acc)\n@@ -3089,83 +3091,83 @@ case 56:\n \t\t;\n     break;}\n case 57:\n-#line 789 \"./parse.y\"\n+#line 791 \"./parse.y\"\n { create_class (yyvsp[-4].value, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 59:\n-#line 792 \"./parse.y\"\n+#line 794 \"./parse.y\"\n { create_class (0, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 61:\n-#line 795 \"./parse.y\"\n+#line 797 \"./parse.y\"\n {yyerror (\"Missing class name\"); RECOVER;;\n     break;}\n case 62:\n-#line 797 \"./parse.y\"\n+#line 799 \"./parse.y\"\n {yyerror (\"Missing class name\"); RECOVER;;\n     break;}\n case 63:\n-#line 799 \"./parse.y\"\n+#line 801 \"./parse.y\"\n {\n \t\t  if (!ctxp->class_err) yyerror (\"'{' expected\"); \n \t\t  DRECOVER(class1);\n \t\t;\n     break;}\n case 64:\n-#line 804 \"./parse.y\"\n+#line 806 \"./parse.y\"\n {if (!ctxp->class_err) yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 65:\n-#line 808 \"./parse.y\"\n+#line 810 \"./parse.y\"\n { yyval.node = NULL; ;\n     break;}\n case 66:\n-#line 810 \"./parse.y\"\n+#line 812 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 67:\n-#line 812 \"./parse.y\"\n+#line 814 \"./parse.y\"\n {yyerror (\"'{' expected\"); ctxp->class_err=1;;\n     break;}\n case 68:\n-#line 814 \"./parse.y\"\n+#line 816 \"./parse.y\"\n {yyerror (\"Missing super class name\"); ctxp->class_err=1;;\n     break;}\n case 69:\n-#line 818 \"./parse.y\"\n+#line 820 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 70:\n-#line 820 \"./parse.y\"\n+#line 822 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 71:\n-#line 822 \"./parse.y\"\n+#line 824 \"./parse.y\"\n {\n \t\t  ctxp->class_err=1;\n \t\t  yyerror (\"Missing interface name\"); \n \t\t;\n     break;}\n case 72:\n-#line 830 \"./parse.y\"\n+#line 832 \"./parse.y\"\n { \n \t\t  ctxp->interface_number = 1;\n \t\t  yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE);\n \t\t;\n     break;}\n case 73:\n-#line 835 \"./parse.y\"\n+#line 837 \"./parse.y\"\n { \n \t\t  ctxp->interface_number++;\n \t\t  yyval.node = chainon (yyvsp[-2].node, build_tree_list (yyvsp[0].node, NULL_TREE));\n \t\t;\n     break;}\n case 74:\n-#line 840 \"./parse.y\"\n+#line 842 \"./parse.y\"\n {yyerror (\"Missing interface name\"); RECOVER;;\n     break;}\n case 75:\n-#line 845 \"./parse.y\"\n+#line 847 \"./parse.y\"\n { \n \t\t  /* Store the location of the `}' when doing xrefs */\n \t\t  if (flag_emit_xref)\n@@ -3175,7 +3177,7 @@ case 75:\n \t\t;\n     break;}\n case 76:\n-#line 853 \"./parse.y\"\n+#line 855 \"./parse.y\"\n { \n \t\t  /* Store the location of the `}' when doing xrefs */\n \t\t  if (flag_emit_xref)\n@@ -3185,30 +3187,30 @@ case 76:\n \t\t;\n     break;}\n case 82:\n-#line 872 \"./parse.y\"\n+#line 874 \"./parse.y\"\n {\n \t\t  TREE_CHAIN (yyvsp[0].node) = CPC_INSTANCE_INITIALIZER_STMT (ctxp);\n \t\t  SET_CPC_INSTANCE_INITIALIZER_STMT (ctxp, yyvsp[0].node);\n \t\t;\n     break;}\n case 84:\n-#line 881 \"./parse.y\"\n+#line 883 \"./parse.y\"\n { yyval.node = yyvsp[-1].node; ;\n     break;}\n case 86:\n-#line 884 \"./parse.y\"\n+#line 886 \"./parse.y\"\n { end_class_declaration (1); ;\n     break;}\n case 87:\n-#line 886 \"./parse.y\"\n+#line 888 \"./parse.y\"\n { end_class_declaration (1); ;\n     break;}\n case 88:\n-#line 892 \"./parse.y\"\n+#line 894 \"./parse.y\"\n { register_fields (0, yyvsp[-2].node, yyvsp[-1].node); ;\n     break;}\n case 89:\n-#line 894 \"./parse.y\"\n+#line 896 \"./parse.y\"\n {\n \t\t  check_modifiers \n \t\t    (\"Illegal modifier `%s' for field declaration\",\n@@ -3218,19 +3220,19 @@ case 89:\n \t\t;\n     break;}\n case 91:\n-#line 907 \"./parse.y\"\n+#line 909 \"./parse.y\"\n { yyval.node = chainon (yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 92:\n-#line 909 \"./parse.y\"\n+#line 911 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 93:\n-#line 914 \"./parse.y\"\n+#line 916 \"./parse.y\"\n { yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE); ;\n     break;}\n case 94:\n-#line 916 \"./parse.y\"\n+#line 918 \"./parse.y\"\n { \n \t\t  if (java_error_count)\n \t\t    yyvsp[0].node = NULL_TREE;\n@@ -3239,39 +3241,39 @@ case 94:\n \t\t;\n     break;}\n case 95:\n-#line 923 \"./parse.y\"\n+#line 925 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing variable initializer\");\n \t\t  yyval.node = build_tree_list (yyvsp[-2].node, NULL_TREE);\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 96:\n-#line 929 \"./parse.y\"\n+#line 931 \"./parse.y\"\n {\n \t\t  yyerror (\"';' expected\");\n \t\t  yyval.node = build_tree_list (yyvsp[-3].node, NULL_TREE);\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 98:\n-#line 939 \"./parse.y\"\n+#line 941 \"./parse.y\"\n { yyval.node = build_unresolved_array_type (yyvsp[-2].node); ;\n     break;}\n case 99:\n-#line 941 \"./parse.y\"\n+#line 943 \"./parse.y\"\n {yyerror (\"Invalid declaration\"); DRECOVER(vdi);;\n     break;}\n case 100:\n-#line 943 \"./parse.y\"\n+#line 945 \"./parse.y\"\n {yyerror (\"']' expected\"); DRECOVER(vdi);;\n     break;}\n case 101:\n-#line 945 \"./parse.y\"\n+#line 947 \"./parse.y\"\n {yyerror (\"Unbalanced ']'\"); DRECOVER(vdi);;\n     break;}\n case 104:\n-#line 956 \"./parse.y\"\n+#line 958 \"./parse.y\"\n {\n \t\t  current_function_decl = yyvsp[0].node;\n \t\t  if (current_function_decl\n@@ -3282,68 +3284,68 @@ case 104:\n \t\t;\n     break;}\n case 105:\n-#line 965 \"./parse.y\"\n+#line 967 \"./parse.y\"\n { finish_method_declaration (yyvsp[0].node); ;\n     break;}\n case 106:\n-#line 967 \"./parse.y\"\n+#line 969 \"./parse.y\"\n {YYNOT_TWICE yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 107:\n-#line 972 \"./parse.y\"\n+#line 974 \"./parse.y\"\n { yyval.node = method_header (0, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 108:\n-#line 974 \"./parse.y\"\n+#line 976 \"./parse.y\"\n { yyval.node = method_header (0, void_type_node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 109:\n-#line 976 \"./parse.y\"\n+#line 978 \"./parse.y\"\n { yyval.node = method_header (yyvsp[-3].value, yyvsp[-2].node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 110:\n-#line 978 \"./parse.y\"\n+#line 980 \"./parse.y\"\n { yyval.node = method_header (yyvsp[-3].value, void_type_node, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 111:\n-#line 980 \"./parse.y\"\n+#line 982 \"./parse.y\"\n {\n \t\t  yyerror (\"Invalid method declaration, method name required\");\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 112:\n-#line 985 \"./parse.y\"\n+#line 987 \"./parse.y\"\n {RECOVER;;\n     break;}\n case 113:\n-#line 987 \"./parse.y\"\n+#line 989 \"./parse.y\"\n {yyerror (\"Identifier expected\"); RECOVER;;\n     break;}\n case 114:\n-#line 989 \"./parse.y\"\n+#line 991 \"./parse.y\"\n {yyerror (\"Identifier expected\"); RECOVER;;\n     break;}\n case 115:\n-#line 991 \"./parse.y\"\n+#line 993 \"./parse.y\"\n {\n \t\t  yyerror (\"Invalid method declaration, return type required\");\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 116:\n-#line 999 \"./parse.y\"\n+#line 1001 \"./parse.y\"\n { \n \t\t  ctxp->formal_parameter_number = 0;\n \t\t  yyval.node = method_declarator (yyvsp[-2].node, NULL_TREE);\n \t\t;\n     break;}\n case 117:\n-#line 1004 \"./parse.y\"\n+#line 1006 \"./parse.y\"\n { yyval.node = method_declarator (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 118:\n-#line 1006 \"./parse.y\"\n+#line 1008 \"./parse.y\"\n {\n \t\t  EXPR_WFL_LINECOL (wfl_operator) = yyvsp[-1].operator.location;\n \t\t  TREE_PURPOSE (yyvsp[-2].node) = \n@@ -3354,59 +3356,59 @@ case 118:\n \t\t;\n     break;}\n case 119:\n-#line 1015 \"./parse.y\"\n+#line 1017 \"./parse.y\"\n {yyerror (\"')' expected\"); DRECOVER(method_declarator);;\n     break;}\n case 120:\n-#line 1017 \"./parse.y\"\n+#line 1019 \"./parse.y\"\n {yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 121:\n-#line 1022 \"./parse.y\"\n+#line 1024 \"./parse.y\"\n {\n \t\t  ctxp->formal_parameter_number = 1;\n \t\t;\n     break;}\n case 122:\n-#line 1026 \"./parse.y\"\n+#line 1028 \"./parse.y\"\n {\n \t\t  ctxp->formal_parameter_number += 1;\n \t\t  yyval.node = chainon (yyvsp[-2].node, yyvsp[0].node);\n \t\t;\n     break;}\n case 123:\n-#line 1031 \"./parse.y\"\n+#line 1033 \"./parse.y\"\n { yyerror (\"Missing formal parameter term\"); RECOVER; ;\n     break;}\n case 124:\n-#line 1036 \"./parse.y\"\n+#line 1038 \"./parse.y\"\n {\n \t\t  yyval.node = build_tree_list (yyvsp[0].node, yyvsp[-1].node);\n \t\t;\n     break;}\n case 125:\n-#line 1040 \"./parse.y\"\n+#line 1042 \"./parse.y\"\n { \n \t\t  yyval.node = build_tree_list (yyvsp[0].node, yyvsp[-1].node);\n \t\t  ARG_FINAL_P (yyval.node) = 1;\n \t\t;\n     break;}\n case 126:\n-#line 1045 \"./parse.y\"\n+#line 1047 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing identifier\"); RECOVER;\n \t\t  yyval.node = NULL_TREE;\n \t\t;\n     break;}\n case 127:\n-#line 1050 \"./parse.y\"\n+#line 1052 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing identifier\"); RECOVER;\n \t\t  yyval.node = NULL_TREE;\n \t\t;\n     break;}\n case 128:\n-#line 1058 \"./parse.y\"\n+#line 1060 \"./parse.y\"\n {\n \t\t  check_modifiers (\"Illegal modifier `%s'. Only `final' was expected here\",\n \t\t\t\t   yyvsp[0].value, ACC_FINAL);\n@@ -3415,49 +3417,49 @@ case 128:\n \t\t;\n     break;}\n case 129:\n-#line 1067 \"./parse.y\"\n+#line 1069 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 130:\n-#line 1069 \"./parse.y\"\n+#line 1071 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 131:\n-#line 1071 \"./parse.y\"\n+#line 1073 \"./parse.y\"\n {yyerror (\"Missing class type term\"); RECOVER;;\n     break;}\n case 132:\n-#line 1076 \"./parse.y\"\n+#line 1078 \"./parse.y\"\n { yyval.node = build_tree_list (yyvsp[0].node, yyvsp[0].node); ;\n     break;}\n case 133:\n-#line 1078 \"./parse.y\"\n+#line 1080 \"./parse.y\"\n { yyval.node = tree_cons (yyvsp[0].node, yyvsp[0].node, yyvsp[-2].node); ;\n     break;}\n case 134:\n-#line 1080 \"./parse.y\"\n+#line 1082 \"./parse.y\"\n {yyerror (\"Missing class type term\"); RECOVER;;\n     break;}\n case 137:\n-#line 1087 \"./parse.y\"\n+#line 1089 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 138:\n-#line 1093 \"./parse.y\"\n+#line 1095 \"./parse.y\"\n {\n \t\t  TREE_CHAIN (yyvsp[0].node) = CPC_STATIC_INITIALIZER_STMT (ctxp);\n \t\t  SET_CPC_STATIC_INITIALIZER_STMT (ctxp, yyvsp[0].node);\n \t\t;\n     break;}\n case 139:\n-#line 1098 \"./parse.y\"\n+#line 1100 \"./parse.y\"\n {\n \t\t  TREE_CHAIN (yyvsp[-1].node) = CPC_STATIC_INITIALIZER_STMT (ctxp);\n \t\t  SET_CPC_STATIC_INITIALIZER_STMT (ctxp, yyvsp[-1].node);\n \t\t;\n     break;}\n case 140:\n-#line 1106 \"./parse.y\"\n+#line 1108 \"./parse.y\"\n {\n \t\t  check_modifiers (\"Illegal modifier `%s' for static initializer\", yyvsp[0].value, ACC_STATIC);\n \t\t  /* Can't have a static initializer in an innerclass */\n@@ -3471,198 +3473,198 @@ case 140:\n \t\t;\n     break;}\n case 141:\n-#line 1122 \"./parse.y\"\n+#line 1124 \"./parse.y\"\n {\n \t\t  current_function_decl = yyvsp[0].node;\n \t\t  source_start_java_method (current_function_decl);\n \t\t;\n     break;}\n case 142:\n-#line 1127 \"./parse.y\"\n+#line 1129 \"./parse.y\"\n { finish_method_declaration (yyvsp[0].node); ;\n     break;}\n case 143:\n-#line 1132 \"./parse.y\"\n+#line 1134 \"./parse.y\"\n { yyval.node = method_header (0, NULL_TREE, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 144:\n-#line 1134 \"./parse.y\"\n+#line 1136 \"./parse.y\"\n { yyval.node = method_header (yyvsp[-2].value, NULL_TREE, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 145:\n-#line 1139 \"./parse.y\"\n+#line 1141 \"./parse.y\"\n { \n \t\t  ctxp->formal_parameter_number = 0;  \n \t\t  yyval.node = method_declarator (yyvsp[-2].node, NULL_TREE);\n \t\t;\n     break;}\n case 146:\n-#line 1144 \"./parse.y\"\n+#line 1146 \"./parse.y\"\n { yyval.node = method_declarator (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 147:\n-#line 1152 \"./parse.y\"\n+#line 1154 \"./parse.y\"\n { \n \t\t  BLOCK_EXPR_BODY (yyvsp[0].node) = empty_stmt_node;\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 148:\n-#line 1157 \"./parse.y\"\n+#line 1159 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 149:\n-#line 1159 \"./parse.y\"\n+#line 1161 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 150:\n-#line 1161 \"./parse.y\"\n+#line 1163 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 153:\n-#line 1171 \"./parse.y\"\n+#line 1173 \"./parse.y\"\n { \n \t\t  yyval.node = build_method_invocation (yyvsp[-3].node, NULL_TREE); \n \t\t  yyval.node = build_debugable_stmt (EXPR_WFL_LINECOL (yyvsp[-3].node), yyval.node);\n \t\t  yyval.node = java_method_add_stmt (current_function_decl, yyval.node);\n \t\t;\n     break;}\n case 154:\n-#line 1177 \"./parse.y\"\n+#line 1179 \"./parse.y\"\n { \n \t\t  yyval.node = build_method_invocation (yyvsp[-4].node, yyvsp[-2].node); \n \t\t  yyval.node = build_debugable_stmt (EXPR_WFL_LINECOL (yyvsp[-4].node), yyval.node);\n \t\t  yyval.node = java_method_add_stmt (current_function_decl, yyval.node);\n \t\t;\n     break;}\n case 155:\n-#line 1185 \"./parse.y\"\n+#line 1187 \"./parse.y\"\n {yyval.node = parse_jdk1_1_error (\"explicit constructor invocation\"); ;\n     break;}\n case 156:\n-#line 1187 \"./parse.y\"\n+#line 1189 \"./parse.y\"\n {yyval.node = parse_jdk1_1_error (\"explicit constructor invocation\"); ;\n     break;}\n case 157:\n-#line 1192 \"./parse.y\"\n+#line 1194 \"./parse.y\"\n {\n \t\t  tree wfl = build_wfl_node (this_identifier_node);\n \t\t  EXPR_WFL_LINECOL (wfl) = yyvsp[0].operator.location;\n \t\t  yyval.node = wfl;\n \t\t;\n     break;}\n case 158:\n-#line 1198 \"./parse.y\"\n+#line 1200 \"./parse.y\"\n {\n \t\t  tree wfl = build_wfl_node (super_identifier_node);\n \t\t  EXPR_WFL_LINECOL (wfl) = yyvsp[0].operator.location;\n \t\t  yyval.node = wfl;\n \t\t;\n     break;}\n case 159:\n-#line 1209 \"./parse.y\"\n+#line 1211 \"./parse.y\"\n { create_interface (0, yyvsp[0].node, NULL_TREE); ;\n     break;}\n case 161:\n-#line 1212 \"./parse.y\"\n+#line 1214 \"./parse.y\"\n { create_interface (yyvsp[-2].value, yyvsp[0].node, NULL_TREE); ;\n     break;}\n case 163:\n-#line 1215 \"./parse.y\"\n+#line 1217 \"./parse.y\"\n { create_interface (0, yyvsp[-1].node, yyvsp[0].node);\t;\n     break;}\n case 165:\n-#line 1218 \"./parse.y\"\n+#line 1220 \"./parse.y\"\n { create_interface (yyvsp[-3].value, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 167:\n-#line 1221 \"./parse.y\"\n+#line 1223 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 168:\n-#line 1223 \"./parse.y\"\n+#line 1225 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 169:\n-#line 1228 \"./parse.y\"\n+#line 1230 \"./parse.y\"\n { \n \t\t  ctxp->interface_number = 1;\n \t\t  yyval.node = build_tree_list (yyvsp[0].node, NULL_TREE);\n \t\t;\n     break;}\n case 170:\n-#line 1233 \"./parse.y\"\n+#line 1235 \"./parse.y\"\n { \n \t\t  ctxp->interface_number++;\n \t\t  yyval.node = chainon (yyvsp[-2].node, build_tree_list (yyvsp[0].node, NULL_TREE));\n \t\t;\n     break;}\n case 171:\n-#line 1238 \"./parse.y\"\n+#line 1240 \"./parse.y\"\n {yyerror (\"Invalid interface type\"); RECOVER;;\n     break;}\n case 172:\n-#line 1240 \"./parse.y\"\n+#line 1242 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 173:\n-#line 1245 \"./parse.y\"\n+#line 1247 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 174:\n-#line 1247 \"./parse.y\"\n+#line 1249 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 179:\n-#line 1259 \"./parse.y\"\n+#line 1261 \"./parse.y\"\n { end_class_declaration (1); ;\n     break;}\n case 180:\n-#line 1261 \"./parse.y\"\n+#line 1263 \"./parse.y\"\n { end_class_declaration (1); ;\n     break;}\n case 182:\n-#line 1270 \"./parse.y\"\n+#line 1272 \"./parse.y\"\n { \n \t\t  check_abstract_method_header (yyvsp[-1].node);\n \t\t  current_function_decl = NULL_TREE; /* FIXME ? */\n \t\t;\n     break;}\n case 183:\n-#line 1275 \"./parse.y\"\n+#line 1277 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 184:\n-#line 1281 \"./parse.y\"\n+#line 1283 \"./parse.y\"\n { yyval.node = build_new_array_init (yyvsp[-1].operator.location, NULL_TREE); ;\n     break;}\n case 185:\n-#line 1283 \"./parse.y\"\n+#line 1285 \"./parse.y\"\n { yyval.node = build_new_array_init (yyvsp[-2].operator.location, yyvsp[-1].node); ;\n     break;}\n case 186:\n-#line 1285 \"./parse.y\"\n+#line 1287 \"./parse.y\"\n { yyval.node = build_new_array_init (yyvsp[-3].operator.location, yyvsp[-2].node); ;\n     break;}\n case 187:\n-#line 1290 \"./parse.y\"\n+#line 1292 \"./parse.y\"\n { \n \t\t  yyval.node = tree_cons (maybe_build_array_element_wfl (yyvsp[0].node), \n \t\t\t\t  yyvsp[0].node, NULL_TREE);\n \t\t;\n     break;}\n case 188:\n-#line 1295 \"./parse.y\"\n+#line 1297 \"./parse.y\"\n {\n \t\t  yyval.node = tree_cons (maybe_build_array_element_wfl (yyvsp[0].node), yyvsp[0].node, yyvsp[-2].node);\n \t\t;\n     break;}\n case 189:\n-#line 1299 \"./parse.y\"\n+#line 1301 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 190:\n-#line 1305 \"./parse.y\"\n+#line 1307 \"./parse.y\"\n { \n \t\t  /* Store the location of the `}' when doing xrefs */\n \t\t  if (current_function_decl && flag_emit_xref)\n@@ -3672,15 +3674,15 @@ case 190:\n \t\t;\n     break;}\n case 191:\n-#line 1313 \"./parse.y\"\n+#line 1315 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 192:\n-#line 1318 \"./parse.y\"\n+#line 1320 \"./parse.y\"\n { enter_block (); ;\n     break;}\n case 193:\n-#line 1323 \"./parse.y\"\n+#line 1325 \"./parse.y\"\n { \n \t\t  maybe_absorb_scoping_blocks ();\n \t\t  /* Store the location of the `}' when doing xrefs */\n@@ -3693,38 +3695,38 @@ case 193:\n \t\t;\n     break;}\n case 197:\n-#line 1343 \"./parse.y\"\n+#line 1345 \"./parse.y\"\n { java_method_add_stmt (current_function_decl, yyvsp[0].node); ;\n     break;}\n case 198:\n-#line 1345 \"./parse.y\"\n+#line 1347 \"./parse.y\"\n { \n \t\t  LOCAL_CLASS_P (TREE_TYPE (GET_CPC ())) = 1;\n \t\t  end_class_declaration (1);\n \t\t;\n     break;}\n case 200:\n-#line 1357 \"./parse.y\"\n+#line 1359 \"./parse.y\"\n { declare_local_variables (0, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 201:\n-#line 1359 \"./parse.y\"\n+#line 1361 \"./parse.y\"\n { declare_local_variables (yyvsp[-2].value, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 207:\n-#line 1369 \"./parse.y\"\n+#line 1371 \"./parse.y\"\n { yyval.node = exit_block (); ;\n     break;}\n case 212:\n-#line 1378 \"./parse.y\"\n+#line 1380 \"./parse.y\"\n { yyval.node = exit_block (); ;\n     break;}\n case 224:\n-#line 1397 \"./parse.y\"\n+#line 1399 \"./parse.y\"\n { yyval.node = empty_stmt_node; ;\n     break;}\n case 225:\n-#line 1402 \"./parse.y\"\n+#line 1404 \"./parse.y\"\n {\n \t\t  yyval.node = build_labeled_block (EXPR_WFL_LINECOL (yyvsp[-1].node), \n \t\t\t\t\t    EXPR_WFL_NODE (yyvsp[-1].node));\n@@ -3734,19 +3736,19 @@ case 225:\n \t\t;\n     break;}\n case 226:\n-#line 1413 \"./parse.y\"\n+#line 1415 \"./parse.y\"\n { yyval.node = finish_labeled_statement (yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 227:\n-#line 1415 \"./parse.y\"\n+#line 1417 \"./parse.y\"\n {yyerror (\"':' expected\"); RECOVER;;\n     break;}\n case 228:\n-#line 1420 \"./parse.y\"\n+#line 1422 \"./parse.y\"\n { yyval.node = finish_labeled_statement (yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 229:\n-#line 1427 \"./parse.y\"\n+#line 1429 \"./parse.y\"\n {\n \t\t  /* We have a statement. Generate a WFL around it so\n \t\t     we can debug it */\n@@ -3757,106 +3759,106 @@ case 229:\n \t\t;\n     break;}\n case 230:\n-#line 1436 \"./parse.y\"\n+#line 1438 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid expression statement\");\n \t\t  DRECOVER (expr_stmt);\n \t\t;\n     break;}\n case 231:\n-#line 1442 \"./parse.y\"\n+#line 1444 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid expression statement\");\n \t\t  DRECOVER (expr_stmt);\n \t\t;\n     break;}\n case 232:\n-#line 1448 \"./parse.y\"\n+#line 1450 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid expression statement\");\n \t\t  DRECOVER (expr_stmt);\n \t\t;\n     break;}\n case 233:\n-#line 1454 \"./parse.y\"\n+#line 1456 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 234:\n-#line 1456 \"./parse.y\"\n+#line 1458 \"./parse.y\"\n {\n \t\t  parse_ctor_invocation_error ();\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 235:\n-#line 1461 \"./parse.y\"\n+#line 1463 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 236:\n-#line 1463 \"./parse.y\"\n+#line 1465 \"./parse.y\"\n {\n \t\t  parse_ctor_invocation_error ();\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 237:\n-#line 1468 \"./parse.y\"\n+#line 1470 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 238:\n-#line 1470 \"./parse.y\"\n+#line 1472 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 239:\n-#line 1472 \"./parse.y\"\n+#line 1474 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 240:\n-#line 1474 \"./parse.y\"\n+#line 1476 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 241:\n-#line 1476 \"./parse.y\"\n+#line 1478 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 249:\n-#line 1491 \"./parse.y\"\n+#line 1493 \"./parse.y\"\n { \n \t\t  yyval.node = build_if_else_statement (yyvsp[-3].operator.location, yyvsp[-2].node, \n \t\t\t\t\t\tyyvsp[0].node, NULL_TREE);\n \t\t;\n     break;}\n case 250:\n-#line 1496 \"./parse.y\"\n+#line 1498 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 251:\n-#line 1498 \"./parse.y\"\n+#line 1500 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 252:\n-#line 1500 \"./parse.y\"\n+#line 1502 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 253:\n-#line 1505 \"./parse.y\"\n+#line 1507 \"./parse.y\"\n { yyval.node = build_if_else_statement (yyvsp[-5].operator.location, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 254:\n-#line 1510 \"./parse.y\"\n+#line 1512 \"./parse.y\"\n { yyval.node = build_if_else_statement (yyvsp[-5].operator.location, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 255:\n-#line 1515 \"./parse.y\"\n+#line 1517 \"./parse.y\"\n {\n \t\t  enter_block ();\n \t\t;\n     break;}\n case 256:\n-#line 1519 \"./parse.y\"\n+#line 1521 \"./parse.y\"\n { \n \t\t  /* Make into \"proper list\" of COMPOUND_EXPRs.\n \t\t     I.e. make the last statment also have its own\n@@ -3867,112 +3869,112 @@ case 256:\n \t\t;\n     break;}\n case 257:\n-#line 1531 \"./parse.y\"\n+#line 1533 \"./parse.y\"\n { \n \t\t  yyval.node = build (SWITCH_EXPR, NULL_TREE, yyvsp[-1].node, NULL_TREE);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-2].operator.location;\n \t\t;\n     break;}\n case 258:\n-#line 1536 \"./parse.y\"\n+#line 1538 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 259:\n-#line 1538 \"./parse.y\"\n+#line 1540 \"./parse.y\"\n {yyerror (\"Missing term or ')'\"); DRECOVER(switch_statement);;\n     break;}\n case 260:\n-#line 1540 \"./parse.y\"\n+#line 1542 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 261:\n-#line 1548 \"./parse.y\"\n+#line 1550 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 262:\n-#line 1550 \"./parse.y\"\n+#line 1552 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 263:\n-#line 1552 \"./parse.y\"\n+#line 1554 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 264:\n-#line 1554 \"./parse.y\"\n+#line 1556 \"./parse.y\"\n { yyval.node = NULL_TREE; ;\n     break;}\n case 270:\n-#line 1573 \"./parse.y\"\n+#line 1575 \"./parse.y\"\n { \n \t\t  tree lab = build1 (CASE_EXPR, NULL_TREE, yyvsp[-1].node);\n \t\t  EXPR_WFL_LINECOL (lab) = yyvsp[-2].operator.location;\n \t\t  java_method_add_stmt (current_function_decl, lab);\n \t\t;\n     break;}\n case 271:\n-#line 1579 \"./parse.y\"\n+#line 1581 \"./parse.y\"\n { \n \t\t  tree lab = build1 (DEFAULT_EXPR, NULL_TREE, NULL_TREE);\n \t\t  EXPR_WFL_LINECOL (lab) = yyvsp[-1].operator.location;\n \t\t  java_method_add_stmt (current_function_decl, lab);\n \t\t;\n     break;}\n case 272:\n-#line 1585 \"./parse.y\"\n+#line 1587 \"./parse.y\"\n {yyerror (\"Missing or invalid constant expression\"); RECOVER;;\n     break;}\n case 273:\n-#line 1587 \"./parse.y\"\n+#line 1589 \"./parse.y\"\n {yyerror (\"':' expected\"); RECOVER;;\n     break;}\n case 274:\n-#line 1589 \"./parse.y\"\n+#line 1591 \"./parse.y\"\n {yyerror (\"':' expected\"); RECOVER;;\n     break;}\n case 275:\n-#line 1594 \"./parse.y\"\n+#line 1596 \"./parse.y\"\n { \n \t\t  tree body = build_loop_body (yyvsp[-2].operator.location, yyvsp[-1].node, 0);\n \t\t  yyval.node = build_new_loop (body);\n \t\t;\n     break;}\n case 276:\n-#line 1602 \"./parse.y\"\n+#line 1604 \"./parse.y\"\n { yyval.node = finish_loop_body (0, NULL_TREE, yyvsp[0].node, 0); ;\n     break;}\n case 277:\n-#line 1604 \"./parse.y\"\n+#line 1606 \"./parse.y\"\n {YYERROR_NOW; yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 278:\n-#line 1606 \"./parse.y\"\n+#line 1608 \"./parse.y\"\n {yyerror (\"Missing term and ')' expected\"); RECOVER;;\n     break;}\n case 279:\n-#line 1608 \"./parse.y\"\n+#line 1610 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 280:\n-#line 1613 \"./parse.y\"\n+#line 1615 \"./parse.y\"\n { yyval.node = finish_loop_body (0, NULL_TREE, yyvsp[0].node, 0); ;\n     break;}\n case 281:\n-#line 1618 \"./parse.y\"\n+#line 1620 \"./parse.y\"\n { \n \t\t  tree body = build_loop_body (0, NULL_TREE, 1);\n \t\t  yyval.node = build_new_loop (body);\n \t\t;\n     break;}\n case 282:\n-#line 1627 \"./parse.y\"\n+#line 1629 \"./parse.y\"\n { yyval.node = finish_loop_body (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[-5].node, 1); ;\n     break;}\n case 283:\n-#line 1632 \"./parse.y\"\n+#line 1634 \"./parse.y\"\n { yyval.node = finish_for_loop (EXPR_WFL_LINECOL (yyvsp[-4].node), yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 284:\n-#line 1634 \"./parse.y\"\n+#line 1636 \"./parse.y\"\n { \n \t\t  yyval.node = finish_for_loop (0, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  /* We have not condition, so we get rid of the EXIT_EXPR */\n@@ -3981,23 +3983,23 @@ case 284:\n \t\t;\n     break;}\n case 285:\n-#line 1641 \"./parse.y\"\n+#line 1643 \"./parse.y\"\n {yyerror (\"Invalid control expression\"); RECOVER;;\n     break;}\n case 286:\n-#line 1643 \"./parse.y\"\n+#line 1645 \"./parse.y\"\n {yyerror (\"Invalid update expression\"); RECOVER;;\n     break;}\n case 287:\n-#line 1645 \"./parse.y\"\n+#line 1647 \"./parse.y\"\n {yyerror (\"Invalid update expression\"); RECOVER;;\n     break;}\n case 288:\n-#line 1650 \"./parse.y\"\n+#line 1652 \"./parse.y\"\n { yyval.node = finish_for_loop (EXPR_WFL_LINECOL (yyvsp[-4].node), yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node);;\n     break;}\n case 289:\n-#line 1652 \"./parse.y\"\n+#line 1654 \"./parse.y\"\n { \n \t\t  yyval.node = finish_for_loop (0, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  /* We have not condition, so we get rid of the EXIT_EXPR */\n@@ -4006,23 +4008,23 @@ case 289:\n \t\t;\n     break;}\n case 290:\n-#line 1662 \"./parse.y\"\n+#line 1664 \"./parse.y\"\n { \n \t\t  /* This scope defined for local variable that may be\n                      defined within the scope of the for loop */\n \t\t  enter_block (); \n \t\t;\n     break;}\n case 291:\n-#line 1668 \"./parse.y\"\n+#line 1670 \"./parse.y\"\n {yyerror (\"'(' expected\"); DRECOVER(for_1);;\n     break;}\n case 292:\n-#line 1670 \"./parse.y\"\n+#line 1672 \"./parse.y\"\n {yyerror (\"Invalid init statement\"); RECOVER;;\n     break;}\n case 293:\n-#line 1675 \"./parse.y\"\n+#line 1677 \"./parse.y\"\n { \n \t\t  /* We now declare the loop body. The loop is\n                      declared as a for loop. */\n@@ -4035,138 +4037,138 @@ case 293:\n \t\t;\n     break;}\n case 294:\n-#line 1687 \"./parse.y\"\n+#line 1689 \"./parse.y\"\n { yyval.node = empty_stmt_node; ;\n     break;}\n case 295:\n-#line 1689 \"./parse.y\"\n+#line 1691 \"./parse.y\"\n { \n \t\t  /* Init statement recorded within the previously\n                      defined block scope */\n \t\t  yyval.node = java_method_add_stmt (current_function_decl, yyvsp[0].node);\n \t\t;\n     break;}\n case 296:\n-#line 1695 \"./parse.y\"\n+#line 1697 \"./parse.y\"\n { \n \t\t  /* Local variable are recorded within the previously\n \t\t     defined block scope */\n \t\t  yyval.node = NULL_TREE;\n \t\t;\n     break;}\n case 297:\n-#line 1701 \"./parse.y\"\n+#line 1703 \"./parse.y\"\n {yyerror (\"';' expected\"); DRECOVER(for_init_1);;\n     break;}\n case 298:\n-#line 1705 \"./parse.y\"\n+#line 1707 \"./parse.y\"\n {yyval.node = empty_stmt_node;;\n     break;}\n case 299:\n-#line 1707 \"./parse.y\"\n+#line 1709 \"./parse.y\"\n { yyval.node = build_debugable_stmt (BUILD_LOCATION (), yyvsp[0].node); ;\n     break;}\n case 300:\n-#line 1712 \"./parse.y\"\n+#line 1714 \"./parse.y\"\n { yyval.node = add_stmt_to_compound (NULL_TREE, NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 301:\n-#line 1714 \"./parse.y\"\n+#line 1716 \"./parse.y\"\n { yyval.node = add_stmt_to_compound (yyvsp[-2].node, NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 302:\n-#line 1716 \"./parse.y\"\n+#line 1718 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 303:\n-#line 1721 \"./parse.y\"\n+#line 1723 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-1].operator.location, 1, NULL_TREE); ;\n     break;}\n case 304:\n-#line 1723 \"./parse.y\"\n+#line 1725 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-2].operator.location, 1, yyvsp[-1].node); ;\n     break;}\n case 305:\n-#line 1725 \"./parse.y\"\n+#line 1727 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 306:\n-#line 1727 \"./parse.y\"\n+#line 1729 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 307:\n-#line 1732 \"./parse.y\"\n+#line 1734 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-1].operator.location, 0, NULL_TREE); ;\n     break;}\n case 308:\n-#line 1734 \"./parse.y\"\n+#line 1736 \"./parse.y\"\n { yyval.node = build_bc_statement (yyvsp[-2].operator.location, 0, yyvsp[-1].node); ;\n     break;}\n case 309:\n-#line 1736 \"./parse.y\"\n+#line 1738 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 310:\n-#line 1738 \"./parse.y\"\n+#line 1740 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 311:\n-#line 1743 \"./parse.y\"\n+#line 1745 \"./parse.y\"\n { yyval.node = build_return (yyvsp[-1].operator.location, NULL_TREE); ;\n     break;}\n case 312:\n-#line 1745 \"./parse.y\"\n+#line 1747 \"./parse.y\"\n { yyval.node = build_return (yyvsp[-2].operator.location, yyvsp[-1].node); ;\n     break;}\n case 313:\n-#line 1747 \"./parse.y\"\n+#line 1749 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 314:\n-#line 1749 \"./parse.y\"\n+#line 1751 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 315:\n-#line 1754 \"./parse.y\"\n+#line 1756 \"./parse.y\"\n { \n \t\t  yyval.node = build1 (THROW_EXPR, NULL_TREE, yyvsp[-1].node);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-2].operator.location;\n \t\t;\n     break;}\n case 316:\n-#line 1759 \"./parse.y\"\n+#line 1761 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 317:\n-#line 1761 \"./parse.y\"\n+#line 1763 \"./parse.y\"\n {yyerror (\"';' expected\"); RECOVER;;\n     break;}\n case 318:\n-#line 1766 \"./parse.y\"\n+#line 1768 \"./parse.y\"\n { \n \t\t  yyval.node = build (SYNCHRONIZED_EXPR, NULL_TREE, yyvsp[-2].node, yyvsp[0].node);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = \n \t\t    EXPR_WFL_LINECOL (MODIFIER_WFL (SYNCHRONIZED_TK));\n \t\t;\n     break;}\n case 319:\n-#line 1772 \"./parse.y\"\n+#line 1774 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER;;\n     break;}\n case 320:\n-#line 1774 \"./parse.y\"\n+#line 1776 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 321:\n-#line 1776 \"./parse.y\"\n+#line 1778 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 322:\n-#line 1778 \"./parse.y\"\n+#line 1780 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 323:\n-#line 1783 \"./parse.y\"\n+#line 1785 \"./parse.y\"\n {\n \t\t  check_modifiers (\n              \"Illegal modifier `%s'. Only `synchronized' was expected here\",\n@@ -4177,41 +4179,41 @@ case 323:\n \t\t;\n     break;}\n case 324:\n-#line 1795 \"./parse.y\"\n+#line 1797 \"./parse.y\"\n { yyval.node = build_try_statement (yyvsp[-2].operator.location, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 325:\n-#line 1797 \"./parse.y\"\n+#line 1799 \"./parse.y\"\n { yyval.node = build_try_finally_statement (yyvsp[-2].operator.location, yyvsp[-1].node, yyvsp[0].node); ;\n     break;}\n case 326:\n-#line 1799 \"./parse.y\"\n+#line 1801 \"./parse.y\"\n { yyval.node = build_try_finally_statement \n \t\t    (yyvsp[-3].operator.location, build_try_statement (yyvsp[-3].operator.location,\n \t\t\t\t\t\t       yyvsp[-2].node, yyvsp[-1].node), yyvsp[0].node);\n \t\t;\n     break;}\n case 327:\n-#line 1804 \"./parse.y\"\n+#line 1806 \"./parse.y\"\n {yyerror (\"'{' expected\"); DRECOVER (try_statement);;\n     break;}\n case 329:\n-#line 1810 \"./parse.y\"\n+#line 1812 \"./parse.y\"\n { \n \t\t  TREE_CHAIN (yyvsp[0].node) = yyvsp[-1].node;\n \t\t  yyval.node = yyvsp[0].node;\n \t\t;\n     break;}\n case 330:\n-#line 1818 \"./parse.y\"\n+#line 1820 \"./parse.y\"\n { \n \t\t  java_method_add_stmt (current_function_decl, yyvsp[0].node);\n \t\t  exit_block ();\n \t\t  yyval.node = yyvsp[-1].node;\n \t\t;\n     break;}\n case 331:\n-#line 1826 \"./parse.y\"\n+#line 1828 \"./parse.y\"\n { \n \t\t  /* We add a block to define a scope for\n \t\t     formal_parameter (CCBP). The formal parameter is\n@@ -4229,140 +4231,140 @@ case 331:\n \t\t;\n     break;}\n case 332:\n-#line 1842 \"./parse.y\"\n+#line 1844 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER; yyval.node = NULL_TREE;;\n     break;}\n case 333:\n-#line 1844 \"./parse.y\"\n+#line 1846 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term or ')' expected\"); \n \t\t  RECOVER; yyval.node = NULL_TREE;\n \t\t;\n     break;}\n case 334:\n-#line 1849 \"./parse.y\"\n+#line 1851 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER; yyval.node = NULL_TREE;;\n     break;}\n case 335:\n-#line 1854 \"./parse.y\"\n+#line 1856 \"./parse.y\"\n { yyval.node = yyvsp[0].node; ;\n     break;}\n case 336:\n-#line 1856 \"./parse.y\"\n+#line 1858 \"./parse.y\"\n {yyerror (\"'{' expected\"); RECOVER; ;\n     break;}\n case 340:\n-#line 1868 \"./parse.y\"\n+#line 1870 \"./parse.y\"\n { yyval.node = build_this (yyvsp[0].operator.location); ;\n     break;}\n case 341:\n-#line 1870 \"./parse.y\"\n+#line 1872 \"./parse.y\"\n {yyval.node = yyvsp[-1].node;;\n     break;}\n case 347:\n-#line 1880 \"./parse.y\"\n+#line 1882 \"./parse.y\"\n { \n \t\t  tree wfl = build_wfl_node (this_identifier_node);\n \t\t  yyval.node = make_qualified_primary (yyvsp[-2].node, wfl, EXPR_WFL_LINECOL (yyvsp[-2].node));\n \t\t;\n     break;}\n case 348:\n-#line 1885 \"./parse.y\"\n+#line 1887 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 349:\n-#line 1887 \"./parse.y\"\n+#line 1889 \"./parse.y\"\n {yyerror (\"'class' or 'this' expected\" ); RECOVER;;\n     break;}\n case 350:\n-#line 1889 \"./parse.y\"\n+#line 1891 \"./parse.y\"\n {yyerror (\"'class' expected\" ); RECOVER;;\n     break;}\n case 351:\n-#line 1891 \"./parse.y\"\n+#line 1893 \"./parse.y\"\n {yyerror (\"'class' expected\" ); RECOVER;;\n     break;}\n case 352:\n-#line 1899 \"./parse.y\"\n+#line 1901 \"./parse.y\"\n { \n \t\t  yyval.node = build_java_array_type (yyvsp[-2].node, -1);\n \t\t  CLASS_LOADED_P (yyval.node) = 1;\n \t\t;\n     break;}\n case 353:\n-#line 1904 \"./parse.y\"\n+#line 1906 \"./parse.y\"\n { yyval.node = build_unresolved_array_type (yyvsp[-2].node); ;\n     break;}\n case 354:\n-#line 1914 \"./parse.y\"\n+#line 1916 \"./parse.y\"\n { yyval.node = build_incomplete_class_ref (yyvsp[-1].operator.location, yyvsp[-2].node); ;\n     break;}\n case 355:\n-#line 1916 \"./parse.y\"\n+#line 1918 \"./parse.y\"\n { yyval.node = build_incomplete_class_ref (yyvsp[-1].operator.location, yyvsp[-2].node); ;\n     break;}\n case 356:\n-#line 1918 \"./parse.y\"\n+#line 1920 \"./parse.y\"\n { yyval.node = build_class_ref (yyvsp[-2].node); ;\n     break;}\n case 357:\n-#line 1920 \"./parse.y\"\n+#line 1922 \"./parse.y\"\n { yyval.node = build_class_ref (void_type_node); ;\n     break;}\n case 358:\n-#line 1925 \"./parse.y\"\n+#line 1927 \"./parse.y\"\n { yyval.node = build_new_invocation (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 359:\n-#line 1927 \"./parse.y\"\n+#line 1929 \"./parse.y\"\n { yyval.node = build_new_invocation (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 361:\n-#line 1933 \"./parse.y\"\n+#line 1935 \"./parse.y\"\n { \n \t\t  tree ctor = build_new_invocation (yyvsp[-2].node, NULL_TREE);\n \t\t  yyval.node = make_qualified_primary (yyvsp[-3].node, ctor, \n \t\t\t\t\t       EXPR_WFL_LINECOL (yyvsp[-3].node));\n \t\t;\n     break;}\n case 363:\n-#line 1940 \"./parse.y\"\n+#line 1942 \"./parse.y\"\n { \n \t\t  tree ctor = build_new_invocation (yyvsp[-3].node, yyvsp[-1].node);\n \t\t  yyval.node = make_qualified_primary (yyvsp[-4].node, ctor, \n \t\t\t\t\t       EXPR_WFL_LINECOL (yyvsp[-4].node));\n \t\t;\n     break;}\n case 365:\n-#line 1947 \"./parse.y\"\n+#line 1949 \"./parse.y\"\n {yyerror (\"'(' expected\"); DRECOVER(new_1);;\n     break;}\n case 366:\n-#line 1949 \"./parse.y\"\n+#line 1951 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 367:\n-#line 1951 \"./parse.y\"\n+#line 1953 \"./parse.y\"\n {yyerror (\"')' or term expected\"); RECOVER;;\n     break;}\n case 368:\n-#line 1953 \"./parse.y\"\n+#line 1955 \"./parse.y\"\n {yyerror (\"')' expected\"); RECOVER;;\n     break;}\n case 369:\n-#line 1955 \"./parse.y\"\n+#line 1957 \"./parse.y\"\n {YYERROR_NOW; yyerror (\"Identifier expected\"); RECOVER;;\n     break;}\n case 370:\n-#line 1957 \"./parse.y\"\n+#line 1959 \"./parse.y\"\n {yyerror (\"'(' expected\"); RECOVER;;\n     break;}\n case 371:\n-#line 1967 \"./parse.y\"\n+#line 1969 \"./parse.y\"\n { create_anonymous_class (yyvsp[-4].operator.location, yyvsp[-3].node); ;\n     break;}\n case 372:\n-#line 1969 \"./parse.y\"\n+#line 1971 \"./parse.y\"\n { \n \t\t  tree id = build_wfl_node (DECL_NAME (GET_CPC ()));\n \t\t  EXPR_WFL_LINECOL (id) = EXPR_WFL_LINECOL (yyvsp[-5].node);\n@@ -4395,11 +4397,11 @@ case 372:\n \t\t;\n     break;}\n case 373:\n-#line 2000 \"./parse.y\"\n+#line 2002 \"./parse.y\"\n { create_anonymous_class (yyvsp[-3].operator.location, yyvsp[-2].node); ;\n     break;}\n case 374:\n-#line 2002 \"./parse.y\"\n+#line 2004 \"./parse.y\"\n { \n \t\t  tree id = build_wfl_node (DECL_NAME (GET_CPC ()));\n \t\t  EXPR_WFL_LINECOL (id) = EXPR_WFL_LINECOL (yyvsp[-4].node);\n@@ -4414,49 +4416,49 @@ case 374:\n \t\t;\n     break;}\n case 375:\n-#line 2018 \"./parse.y\"\n+#line 2020 \"./parse.y\"\n { yyval.node = yyvsp[-2].node; ;\n     break;}\n case 376:\n-#line 2020 \"./parse.y\"\n+#line 2022 \"./parse.y\"\n { yyval.node = yyvsp[-2].node; ;\n     break;}\n case 377:\n-#line 2025 \"./parse.y\"\n+#line 2027 \"./parse.y\"\n { \n \t\t  yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, NULL_TREE);\n \t\t  ctxp->formal_parameter_number = 1; \n \t\t;\n     break;}\n case 378:\n-#line 2030 \"./parse.y\"\n+#line 2032 \"./parse.y\"\n {\n \t\t  ctxp->formal_parameter_number += 1;\n \t\t  yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, yyvsp[-2].node);\n \t\t;\n     break;}\n case 379:\n-#line 2035 \"./parse.y\"\n+#line 2037 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 380:\n-#line 2040 \"./parse.y\"\n+#line 2042 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-1].node, yyvsp[0].node, 0); ;\n     break;}\n case 381:\n-#line 2042 \"./parse.y\"\n+#line 2044 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-1].node, yyvsp[0].node, 0); ;\n     break;}\n case 382:\n-#line 2044 \"./parse.y\"\n+#line 2046 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-2].node, yyvsp[-1].node, CURRENT_OSB (ctxp));;\n     break;}\n case 383:\n-#line 2046 \"./parse.y\"\n+#line 2048 \"./parse.y\"\n { yyval.node = build_newarray_node (yyvsp[-2].node, yyvsp[-1].node, CURRENT_OSB (ctxp));;\n     break;}\n case 384:\n-#line 2050 \"./parse.y\"\n+#line 2052 \"./parse.y\"\n {\n \t\t  char *sig;\n \t\t  while (CURRENT_OSB (ctxp)--)\n@@ -4467,7 +4469,7 @@ case 384:\n \t\t;\n     break;}\n case 385:\n-#line 2059 \"./parse.y\"\n+#line 2061 \"./parse.y\"\n { \n \t\t  tree type = yyvsp[-2].node;\n \t\t  while (CURRENT_OSB (ctxp)--)\n@@ -4477,42 +4479,47 @@ case 385:\n \t\t;\n     break;}\n case 386:\n-#line 2067 \"./parse.y\"\n+#line 2069 \"./parse.y\"\n {yyerror (\"'[' expected\"); DRECOVER (\"]\");;\n     break;}\n case 387:\n-#line 2069 \"./parse.y\"\n+#line 2071 \"./parse.y\"\n {yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 388:\n-#line 2074 \"./parse.y\"\n+#line 2076 \"./parse.y\"\n { yyval.node = build_tree_list (NULL_TREE, yyvsp[0].node); ;\n     break;}\n case 389:\n-#line 2076 \"./parse.y\"\n+#line 2078 \"./parse.y\"\n { yyval.node = tree_cons (NULL_TREE, yyvsp[0].node, yyval.node); ;\n     break;}\n case 390:\n-#line 2081 \"./parse.y\"\n+#line 2083 \"./parse.y\"\n { \n+\t\t  if (JNUMERIC_TYPE_P (TREE_TYPE (yyvsp[-1].node)))\n+\t\t    {\n+\t\t      yyvsp[-1].node = build_wfl_node (yyvsp[-1].node);\n+\t\t      TREE_TYPE (yyvsp[-1].node) = NULL_TREE;\n+\t\t    }\n \t\t  EXPR_WFL_LINECOL (yyvsp[-1].node) = yyvsp[-2].operator.location;\n \t\t  yyval.node = yyvsp[-1].node;\n \t\t;\n     break;}\n case 391:\n-#line 2086 \"./parse.y\"\n+#line 2093 \"./parse.y\"\n {yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 392:\n-#line 2088 \"./parse.y\"\n+#line 2095 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term\");\n \t\t  yyerror (\"']' expected\");\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 393:\n-#line 2097 \"./parse.y\"\n+#line 2104 \"./parse.y\"\n { \n \t\t  int allocate = 0;\n \t\t  /* If not initialized, allocate memory for the osb\n@@ -4540,19 +4547,19 @@ case 393:\n \t\t;\n     break;}\n case 394:\n-#line 2123 \"./parse.y\"\n+#line 2130 \"./parse.y\"\n { CURRENT_OSB (ctxp)++; ;\n     break;}\n case 395:\n-#line 2125 \"./parse.y\"\n+#line 2132 \"./parse.y\"\n { yyerror (\"']' expected\"); RECOVER;;\n     break;}\n case 396:\n-#line 2130 \"./parse.y\"\n+#line 2137 \"./parse.y\"\n { yyval.node = make_qualified_primary (yyvsp[-2].node, yyvsp[0].node, yyvsp[-1].operator.location); ;\n     break;}\n case 397:\n-#line 2134 \"./parse.y\"\n+#line 2141 \"./parse.y\"\n {\n \t\t  tree super_wfl = \n \t\t    build_wfl_node (super_identifier_node);\n@@ -4561,19 +4568,19 @@ case 397:\n \t\t;\n     break;}\n case 398:\n-#line 2141 \"./parse.y\"\n+#line 2148 \"./parse.y\"\n {yyerror (\"Field expected\"); DRECOVER (super_field_acces);;\n     break;}\n case 399:\n-#line 2146 \"./parse.y\"\n+#line 2153 \"./parse.y\"\n { yyval.node = build_method_invocation (yyvsp[-2].node, NULL_TREE); ;\n     break;}\n case 400:\n-#line 2148 \"./parse.y\"\n+#line 2155 \"./parse.y\"\n { yyval.node = build_method_invocation (yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 401:\n-#line 2150 \"./parse.y\"\n+#line 2157 \"./parse.y\"\n { \n \t\t  if (TREE_CODE (yyvsp[-4].node) == THIS_EXPR)\n \t\t    yyval.node = build_this_super_qualified_invocation \n@@ -4586,7 +4593,7 @@ case 401:\n \t\t;\n     break;}\n case 402:\n-#line 2161 \"./parse.y\"\n+#line 2168 \"./parse.y\"\n { \n \t\t  if (TREE_CODE (yyvsp[-5].node) == THIS_EXPR)\n \t\t    yyval.node = build_this_super_qualified_invocation \n@@ -4599,121 +4606,121 @@ case 402:\n \t\t;\n     break;}\n case 403:\n-#line 2172 \"./parse.y\"\n+#line 2179 \"./parse.y\"\n { \n \t\t  yyval.node = build_this_super_qualified_invocation \n \t\t    (0, yyvsp[-2].node, NULL_TREE, yyvsp[-4].operator.location, yyvsp[-3].operator.location);\n \t\t;\n     break;}\n case 404:\n-#line 2177 \"./parse.y\"\n+#line 2184 \"./parse.y\"\n {\n \t\t  yyval.node = build_this_super_qualified_invocation \n \t\t    (0, yyvsp[-3].node, yyvsp[-1].node, yyvsp[-5].operator.location, yyvsp[-4].operator.location);\n \t\t;\n     break;}\n case 405:\n-#line 2186 \"./parse.y\"\n+#line 2193 \"./parse.y\"\n { yyerror (\"'(' expected\"); DRECOVER (method_invocation); ;\n     break;}\n case 406:\n-#line 2188 \"./parse.y\"\n+#line 2195 \"./parse.y\"\n { yyerror (\"'(' expected\"); DRECOVER (method_invocation); ;\n     break;}\n case 407:\n-#line 2193 \"./parse.y\"\n+#line 2200 \"./parse.y\"\n { yyval.node = build_array_ref (yyvsp[-2].operator.location, yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 408:\n-#line 2195 \"./parse.y\"\n+#line 2202 \"./parse.y\"\n { yyval.node = build_array_ref (yyvsp[-2].operator.location, yyvsp[-3].node, yyvsp[-1].node); ;\n     break;}\n case 409:\n-#line 2197 \"./parse.y\"\n+#line 2204 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term and ']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 410:\n-#line 2202 \"./parse.y\"\n+#line 2209 \"./parse.y\"\n {\n \t\t  yyerror (\"']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 411:\n-#line 2207 \"./parse.y\"\n+#line 2214 \"./parse.y\"\n {\n \t\t  yyerror (\"Missing term and ']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 412:\n-#line 2212 \"./parse.y\"\n+#line 2219 \"./parse.y\"\n {\n \t\t  yyerror (\"']' expected\");\n \t\t  DRECOVER(array_access);\n \t\t;\n     break;}\n case 417:\n-#line 2227 \"./parse.y\"\n+#line 2234 \"./parse.y\"\n { yyval.node = build_incdec (yyvsp[0].operator.token, yyvsp[0].operator.location, yyvsp[-1].node, 1); ;\n     break;}\n case 418:\n-#line 2232 \"./parse.y\"\n+#line 2239 \"./parse.y\"\n { yyval.node = build_incdec (yyvsp[0].operator.token, yyvsp[0].operator.location, yyvsp[-1].node, 1); ;\n     break;}\n case 421:\n-#line 2239 \"./parse.y\"\n+#line 2246 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 422:\n-#line 2241 \"./parse.y\"\n+#line 2248 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 424:\n-#line 2244 \"./parse.y\"\n+#line 2251 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 425:\n-#line 2246 \"./parse.y\"\n+#line 2253 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 426:\n-#line 2251 \"./parse.y\"\n+#line 2258 \"./parse.y\"\n {yyval.node = build_incdec (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node, 0); ;\n     break;}\n case 427:\n-#line 2253 \"./parse.y\"\n+#line 2260 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 428:\n-#line 2258 \"./parse.y\"\n+#line 2265 \"./parse.y\"\n {yyval.node = build_incdec (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node, 0); ;\n     break;}\n case 429:\n-#line 2260 \"./parse.y\"\n+#line 2267 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 431:\n-#line 2266 \"./parse.y\"\n+#line 2273 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 432:\n-#line 2268 \"./parse.y\"\n+#line 2275 \"./parse.y\"\n {yyval.node = build_unaryop (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[0].node); ;\n     break;}\n case 434:\n-#line 2271 \"./parse.y\"\n+#line 2278 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 435:\n-#line 2273 \"./parse.y\"\n+#line 2280 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;\n     break;}\n case 436:\n-#line 2278 \"./parse.y\"\n+#line 2285 \"./parse.y\"\n { \n \t\t  tree type = yyvsp[-3].node;\n \t\t  while (CURRENT_OSB (ctxp)--)\n@@ -4723,15 +4730,15 @@ case 436:\n \t\t;\n     break;}\n case 437:\n-#line 2286 \"./parse.y\"\n+#line 2293 \"./parse.y\"\n { yyval.node = build_cast (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 438:\n-#line 2288 \"./parse.y\"\n+#line 2295 \"./parse.y\"\n { yyval.node = build_cast (yyvsp[-3].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 439:\n-#line 2290 \"./parse.y\"\n+#line 2297 \"./parse.y\"\n { \n \t\t  const char *ptr;\n \t\t  while (CURRENT_OSB (ctxp)--)\n@@ -4746,275 +4753,275 @@ case 439:\n \t\t;\n     break;}\n case 440:\n-#line 2303 \"./parse.y\"\n+#line 2310 \"./parse.y\"\n {yyerror (\"']' expected, invalid type expression\");;\n     break;}\n case 441:\n-#line 2305 \"./parse.y\"\n+#line 2312 \"./parse.y\"\n {\n \t          if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Invalid type expression\"); RECOVER;\n \t\t  RECOVER;\n \t\t;\n     break;}\n case 442:\n-#line 2311 \"./parse.y\"\n+#line 2318 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 443:\n-#line 2313 \"./parse.y\"\n+#line 2320 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 444:\n-#line 2315 \"./parse.y\"\n+#line 2322 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 446:\n-#line 2321 \"./parse.y\"\n+#line 2328 \"./parse.y\"\n { \n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), \n \t\t\t\t    yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node);\n \t\t;\n     break;}\n case 447:\n-#line 2326 \"./parse.y\"\n+#line 2333 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 448:\n-#line 2331 \"./parse.y\"\n+#line 2338 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 449:\n-#line 2336 \"./parse.y\"\n+#line 2343 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 450:\n-#line 2338 \"./parse.y\"\n+#line 2345 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 451:\n-#line 2340 \"./parse.y\"\n+#line 2347 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 453:\n-#line 2346 \"./parse.y\"\n+#line 2353 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 454:\n-#line 2351 \"./parse.y\"\n+#line 2358 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 455:\n-#line 2356 \"./parse.y\"\n+#line 2363 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 456:\n-#line 2358 \"./parse.y\"\n+#line 2365 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 458:\n-#line 2364 \"./parse.y\"\n+#line 2371 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 459:\n-#line 2369 \"./parse.y\"\n+#line 2376 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 460:\n-#line 2374 \"./parse.y\"\n+#line 2381 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 461:\n-#line 2379 \"./parse.y\"\n+#line 2386 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 462:\n-#line 2381 \"./parse.y\"\n+#line 2388 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 463:\n-#line 2383 \"./parse.y\"\n+#line 2390 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 465:\n-#line 2389 \"./parse.y\"\n+#line 2396 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 466:\n-#line 2394 \"./parse.y\"\n+#line 2401 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 467:\n-#line 2399 \"./parse.y\"\n+#line 2406 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 468:\n-#line 2404 \"./parse.y\"\n+#line 2411 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 469:\n-#line 2409 \"./parse.y\"\n+#line 2416 \"./parse.y\"\n { yyval.node = build_binop (INSTANCEOF_EXPR, yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 470:\n-#line 2411 \"./parse.y\"\n+#line 2418 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 471:\n-#line 2413 \"./parse.y\"\n+#line 2420 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 472:\n-#line 2415 \"./parse.y\"\n+#line 2422 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 473:\n-#line 2417 \"./parse.y\"\n+#line 2424 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 474:\n-#line 2419 \"./parse.y\"\n+#line 2426 \"./parse.y\"\n {yyerror (\"Invalid reference type\"); RECOVER;;\n     break;}\n case 476:\n-#line 2425 \"./parse.y\"\n+#line 2432 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 477:\n-#line 2430 \"./parse.y\"\n+#line 2437 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 478:\n-#line 2435 \"./parse.y\"\n+#line 2442 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 479:\n-#line 2437 \"./parse.y\"\n+#line 2444 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 481:\n-#line 2443 \"./parse.y\"\n+#line 2450 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 482:\n-#line 2448 \"./parse.y\"\n+#line 2455 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 484:\n-#line 2454 \"./parse.y\"\n+#line 2461 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 485:\n-#line 2459 \"./parse.y\"\n+#line 2466 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 487:\n-#line 2465 \"./parse.y\"\n+#line 2472 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 488:\n-#line 2470 \"./parse.y\"\n+#line 2477 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 490:\n-#line 2476 \"./parse.y\"\n+#line 2483 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 491:\n-#line 2481 \"./parse.y\"\n+#line 2488 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 493:\n-#line 2487 \"./parse.y\"\n+#line 2494 \"./parse.y\"\n {\n \t\t  yyval.node = build_binop (BINOP_LOOKUP (yyvsp[-1].operator.token), yyvsp[-1].operator.location,\n \t\t\t\t    yyvsp[-2].node, yyvsp[0].node); \n \t\t;\n     break;}\n case 494:\n-#line 2492 \"./parse.y\"\n+#line 2499 \"./parse.y\"\n {yyerror (\"Missing term\"); RECOVER;;\n     break;}\n case 496:\n-#line 2498 \"./parse.y\"\n+#line 2505 \"./parse.y\"\n {\n \t\t  yyval.node = build (CONDITIONAL_EXPR, NULL_TREE, yyvsp[-4].node, yyvsp[-2].node, yyvsp[0].node);\n \t\t  EXPR_WFL_LINECOL (yyval.node) = yyvsp[-3].operator.location;\n \t\t;\n     break;}\n case 497:\n-#line 2503 \"./parse.y\"\n+#line 2510 \"./parse.y\"\n {\n \t\t  YYERROR_NOW;\n \t\t  yyerror (\"Missing term\");\n \t\t  DRECOVER (1);\n \t\t;\n     break;}\n case 498:\n-#line 2509 \"./parse.y\"\n+#line 2516 \"./parse.y\"\n {yyerror (\"Missing term\"); DRECOVER (2);;\n     break;}\n case 499:\n-#line 2511 \"./parse.y\"\n+#line 2518 \"./parse.y\"\n {yyerror (\"Missing term\"); DRECOVER (3);;\n     break;}\n case 502:\n-#line 2521 \"./parse.y\"\n+#line 2528 \"./parse.y\"\n { yyval.node = build_assignment (yyvsp[-1].operator.token, yyvsp[-1].operator.location, yyvsp[-2].node, yyvsp[0].node); ;\n     break;}\n case 503:\n-#line 2523 \"./parse.y\"\n+#line 2530 \"./parse.y\"\n {\n \t\t  if (ctxp->prevent_ese != lineno)\n \t\t    yyerror (\"Missing term\");\n@@ -5243,7 +5250,7 @@ case 503:\n     }\n   return 1;\n }\n-#line 2549 \"./parse.y\"\n+#line 2556 \"./parse.y\"\n \n \f\n \n@@ -6691,23 +6698,27 @@ lookup_field_wrapper (class, name)\n      tree class, name;\n {\n   tree type = class;\n-  tree decl;\n+  tree decl = NULL_TREE;\n   java_parser_context_save_global ();\n-  decl = lookup_field (&type, name);\n \n   /* Last chance: if we're within the context of an inner class, we\n      might be trying to access a local variable defined in an outer\n      context. We try to look for it now. */\n-  if (INNER_CLASS_TYPE_P (class) && (!decl || decl == error_mark_node))\n+  if (INNER_CLASS_TYPE_P (class))\n     {\n       char *alias_buffer;\n+      tree new_name;\n       MANGLE_OUTER_LOCAL_VARIABLE_NAME (alias_buffer, name);\n-      name = get_identifier (alias_buffer);\n-      type = class;\n-      decl = lookup_field (&type, name);\n+      new_name = get_identifier (alias_buffer);\n+      decl = lookup_field (&type, new_name);\n       if (decl && decl != error_mark_node)\n \tFIELD_LOCAL_ALIAS_USED (decl) = 1;\n     }\n+  if (!decl || decl == error_mark_node)\n+    {\n+      type = class;\n+      decl = lookup_field (&type, name);\n+    }\n \n   java_parser_context_restore_global ();\n   return decl == error_mark_node ? NULL : decl;\n@@ -7311,10 +7322,8 @@ check_modifiers_consistency (flags)\n \n   acc_count = 0;\n   cl = NULL_TREE;\n-  THIS_MODIFIER_ONLY (flags, ACC_FINAL, FINAL_TK - PUBLIC_TK,\n-\t\t      acc_count, cl);\n-  THIS_MODIFIER_ONLY (flags, ACC_VOLATILE, VOLATILE_TK - PUBLIC_TK,\n-\t\t      acc_count, cl);\n+  THIS_MODIFIER_ONLY (flags, ACC_FINAL, FINAL_TK, acc_count, cl);\n+  THIS_MODIFIER_ONLY (flags, ACC_VOLATILE, VOLATILE_TK, acc_count, cl);\n   if (acc_count > 1)\n     parse_error_context (cl,\n \t\t\t \"Inconsistent member declaration.  At most one of `final' or `volatile' may be specified\");\n@@ -7373,7 +7382,7 @@ method_declarator (id, list)\n \n       /* Then this$<n> */\n       type = TREE_TYPE (DECL_CONTEXT (GET_CPC ()));\n-      thisn = build_current_thisn (TYPE_NAME (GET_CPC ()));\n+      thisn = build_current_thisn (TREE_TYPE (GET_CPC ()));\n       list = tree_cons (build_wfl_node (thisn), build_pointer_type (type),\n \t\t\tlist);\n     }\n@@ -7907,10 +7916,8 @@ java_complete_class ()\n \n   push_obstacks (&permanent_obstack, &permanent_obstack);\n \n-  /* Process imports and reverse the import on demand list */\n+  /* Process imports */\n   process_imports ();\n-  if (ctxp->import_demand_list)\n-    ctxp->import_demand_list = nreverse (ctxp->import_demand_list);\n \n   /* Rever things so we have the right order */\n   ctxp->class_list = nreverse (ctxp->class_list);\n@@ -8115,10 +8122,10 @@ do_resolve_class (enclosing, class_type, decl, cl)\n      tree enclosing, class_type, decl, cl;\n {\n   tree new_class_decl;\n-  tree original_name = NULL_TREE;\n \n   /* Do not try to replace TYPE_NAME (class_type) by a variable, since\n-     its is changed by find_in_imports{_on_demand} */\n+     it is changed by find_in_imports{_on_demand} and (but it doesn't\n+     really matter) qualify_and_find */\n \n   /* 0- Search in the current class as an inner class */\n \n@@ -8152,12 +8159,11 @@ do_resolve_class (enclosing, class_type, decl, cl)\n       enclosing = do_resolve_class (NULL, name, NULL, NULL);\n     }\n \n-  /* 1- Check for the type in single imports */\n-  if (find_in_imports (class_type))\n-    return NULL_TREE;\n+  /* 1- Check for the type in single imports. This will change\n+     TYPE_NAME() if something relevant is found */\n+  find_in_imports (class_type);\n \n-  /* 2- And check for the type in the current compilation unit. If it fails,\n-     try with a name qualified with the package name we've seen so far */\n+  /* 2- And check for the type in the current compilation unit */\n   if ((new_class_decl = IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type))))\n     {\n       if (!CLASS_LOADED_P (TREE_TYPE (new_class_decl)) &&\n@@ -8166,34 +8172,37 @@ do_resolve_class (enclosing, class_type, decl, cl)\n       return IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type));\n     }\n \n-  original_name = TYPE_NAME (class_type);\n+  /* 3- Search according to the current package definition */\n+  if (!QUALIFIED_P (TYPE_NAME (class_type)))\n+    {\n+      if ((new_class_decl = qualify_and_find (class_type, ctxp->package,\n+\t\t\t\t\t     TYPE_NAME (class_type))))\n+\treturn new_class_decl;\n+    }\n+\n+  /* 4- Check the import on demands. Don't allow bar.baz to be\n+     imported from foo.* */\n+  if (!QUALIFIED_P (TYPE_NAME (class_type)))\n+    if (find_in_imports_on_demand (class_type))\n+      return NULL_TREE;\n+\n+  /* If found in find_in_imports_on_demant, the type has already been\n+     loaded. */\n+  if ((new_class_decl = IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type))))\n+    return new_class_decl;\n+\n+  /* 5- Try with a name qualified with the package name we've seen so far */\n   if (!QUALIFIED_P (TYPE_NAME (class_type)))\n     {\n       tree package;\n       for (package = package_list; package; package = TREE_CHAIN (package))\n-  \t{\n- \t  tree new_qualified;\n- \t  \n- \t  new_qualified = merge_qualified_name (TREE_PURPOSE (package),\n- \t\t\t\t\t\toriginal_name);\n- \t  TYPE_NAME (class_type) = new_qualified;\n- \t  new_class_decl = IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type));\n- \t  if (!new_class_decl)\n- \t    load_class (TYPE_NAME (class_type), 0);\n- \t  new_class_decl = IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type));\n- \t  if (new_class_decl)\n- \t    {\n- \t      if (!CLASS_LOADED_P (TREE_TYPE (new_class_decl)) &&\n- \t\t  !CLASS_FROM_SOURCE_P (TREE_TYPE (new_class_decl)))\n- \t\tload_class (TYPE_NAME (class_type), 0);\n- \t      return IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type));\n- \t    }\n-\t}\n+\tif ((new_class_decl = qualify_and_find (class_type,\n+\t\t\t\t\t       TREE_PURPOSE (package), \n+\t\t\t\t\t       TYPE_NAME (class_type))))\n+\t  return new_class_decl;\n     }\n \n-  TYPE_NAME (class_type) = original_name;\n-\n-  /* 3- Check an other compilation unit that bears the name of type */\n+  /* 5- Check an other compilation unit that bears the name of type */\n   load_class (TYPE_NAME (class_type), 0);\n   if (check_pkg_class_access (TYPE_NAME (class_type), \n \t\t\t      (cl ? cl : lookup_cl (decl))))\n@@ -8202,16 +8211,30 @@ do_resolve_class (enclosing, class_type, decl, cl)\n   if ((new_class_decl = IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type))))\n     return new_class_decl;\n \n-  /* 4- Check the import on demands. Don't allow bar.baz to be\n-     imported from foo.* */\n-  if (!QUALIFIED_P (TYPE_NAME (class_type)))\n-    if (find_in_imports_on_demand (class_type))\n-      return NULL_TREE;\n-\n-  /* 5- Last call for a resolution */\n+  /* 6- Last call for a resolution */\n   return IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type));\n }\n \n+static tree\n+qualify_and_find (class_type, package, name)\n+     tree class_type, package, name;\n+{\n+  tree new_qualified = merge_qualified_name (package, name);\n+  tree new_class_decl;\n+\n+  if (!IDENTIFIER_CLASS_VALUE (new_qualified))\n+    load_class (new_qualified, 0);\n+  if ((new_class_decl = IDENTIFIER_CLASS_VALUE (new_qualified)))\n+    {\n+      if (!CLASS_LOADED_P (TREE_TYPE (new_class_decl)) &&\n+\t  !CLASS_FROM_SOURCE_P (TREE_TYPE (new_class_decl)))\n+\tload_class (new_qualified, 0);\n+      TYPE_NAME (class_type) = new_qualified;\n+      return IDENTIFIER_CLASS_VALUE (new_qualified);\n+    }\n+  return NULL_TREE;\n+}\n+\n /* Resolve NAME and lay it out (if not done and if not the current\n    parsed class). Return a decl node. This function is meant to be\n    called when type resolution is necessary during the walk pass.  */\n@@ -9085,10 +9108,10 @@ process_imports ()\n   return 0;\n }\n \n-/* Possibly find a class imported by a single-type import statement. Return\n-   1 if an error occured, 0 otherwise. */\n+/* Possibly find and mark a class imported by a single-type import\n+   statement.  */\n \n-static int\n+static void\n find_in_imports (class_type)\n      tree class_type;\n {\n@@ -9100,7 +9123,6 @@ find_in_imports (class_type)\n \tTYPE_NAME (class_type) = EXPR_WFL_NODE (TREE_PURPOSE (import));\n \tQUALIFIED_P (TYPE_NAME (class_type)) = 1;\n       }\n-  return 0;\n }\n \n static int\n@@ -9310,6 +9332,30 @@ find_in_imports_on_demand (class_type)\n     return (seen_once < 0 ? 0 : seen_once); /* It's ok not to have found */\n }\n \n+/* Add package NAME to the list of package encountered so far. To\n+   speed up class lookup in do_resolve_class, we make sure a\n+   particular package is added only once.  */\n+\n+static void\n+register_package (name)\n+     tree name;\n+{\n+  static struct hash_table _pht, *pht = NULL;\n+\n+  if (!pht)\n+    {\n+      hash_table_init (&_pht, hash_newfunc, \n+\t\t       java_hash_hash_tree_node, java_hash_compare_tree_node);\n+      pht = &_pht;\n+    }\n+  \n+  if (!hash_lookup (pht, (const hash_table_key) name, FALSE, NULL))\n+    {\n+      package_list = chainon (package_list, build_tree_list (name, NULL));\n+      hash_lookup (pht, (const hash_table_key) name, TRUE, NULL);\n+    }\n+}\n+\n static tree\n resolve_package (pkg, next)\n      tree pkg, *next;\n@@ -10078,10 +10124,12 @@ maybe_generate_pre_expand_clinit (class_type)\n   for (current = TYPE_CLINIT_STMT_LIST (class_type); current;\n        current = TREE_CHAIN (current))\n     {\n+      tree stmt = current;\n       /* We build the assignment expression that will initialize the\n \t field to its value. There are strict rules on static\n \t initializers (8.5). FIXME */\n-      tree stmt = build_debugable_stmt (EXPR_WFL_LINECOL (current), current);\n+      if (TREE_CODE (stmt) != BLOCK)\n+\tstmt = build_debugable_stmt (EXPR_WFL_LINECOL (stmt), stmt);\n       java_method_add_stmt (mdecl, stmt);\n     }\n \n@@ -11042,12 +11090,6 @@ java_expand_classes ()\n   java_layout_classes ();\n   java_parse_abort_on_error ();\n \n-  /* The list of packages declaration seen so far needs to be\n-     reversed, so that package declared in a file being compiled gets\n-     priority over packages declared as a side effect of parsing other\n-     files.*/\n-  package_list = nreverse (package_list);\n-\n   saved_ctxp = ctxp_for_generation;\n   for (; ctxp_for_generation; ctxp_for_generation = ctxp_for_generation->next)\n     {\n@@ -11126,7 +11168,7 @@ make_qualified_primary (primary, right, location)\n   tree wfl;\n \n   if (TREE_CODE (primary) != EXPR_WITH_FILE_LOCATION)\n-    wfl = build_wfl_wrap (primary);\n+    wfl = build_wfl_wrap (primary, location);\n   else\n     {\n       wfl = primary;\n@@ -11343,7 +11385,8 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n     return error_mark_node;\n \n   /* Resolve the LENGTH field of an array here */\n-  if (DECL_NAME (decl) == length_identifier_node && TYPE_ARRAY_P (type_found)\n+  if (DECL_P (decl) && DECL_NAME (decl) == length_identifier_node \n+      && TYPE_ARRAY_P (type_found) \n       && ! flag_emit_class_files && ! flag_emit_xref)\n     {\n       tree length = build_java_array_length_access (where_found);\n@@ -12735,7 +12778,8 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n     }\n \n   /* Search interfaces */\n-  if (CLASS_INTERFACE (TYPE_NAME (class)))\n+  if (TREE_CODE (TYPE_NAME (class)) == TYPE_DECL \n+      && CLASS_INTERFACE (TYPE_NAME (class)))\n     {\n       static struct hash_table t, *searched_interfaces = NULL;\n       static int search_not_done = 0;\n@@ -12883,6 +12927,7 @@ find_most_specific_methods_list (list)\n      tree list;\n {\n   int max = 0;\n+  int abstract, candidates;\n   tree current, new_list = NULL_TREE;\n   for (current = list; current; current = TREE_CHAIN (current))\n     {\n@@ -12909,24 +12954,33 @@ find_most_specific_methods_list (list)\n     }\n \n   /* Review the list and select the maximally specific methods */\n-  for (current = list; current; current = TREE_CHAIN (current))\n+  for (current = list, abstract = -1, candidates = -1;\n+       current; current = TREE_CHAIN (current))\n     if (DECL_SPECIFIC_COUNT (TREE_VALUE (current)) == max)\n-      new_list = tree_cons (NULL_TREE, TREE_VALUE (current), new_list);\n+      {\n+\tnew_list = tree_cons (NULL_TREE, TREE_VALUE (current), new_list);\n+\tabstract += (METHOD_ABSTRACT (TREE_VALUE (current)) ? 1 : 0);\n+\tcandidates++;\n+      }\n \n   /* If we have several and they're all abstract, just pick the\n      closest one. */\n+  if (candidates > 0 && (candidates == abstract))\n+    {\n+      new_list = nreverse (new_list);\n+      TREE_CHAIN (new_list) = NULL_TREE;\n+    }\n \n-  if (new_list && TREE_CHAIN (new_list))\n+  /* We have several, we couldn't find a most specific, all but one are\n+     abstract, we pick the only non abstract one. */\n+  if (candidates > 0 && !max && (candidates == abstract+1))\n     {\n-      tree c;\n-      for (c = new_list; c && METHOD_ABSTRACT (TREE_VALUE (c)); \n-\t   c = TREE_CHAIN (c))\n-        ;\n-      if (!c)\n-\t{\n-\t  new_list = nreverse (new_list);\n-\t  TREE_CHAIN (new_list) = NULL_TREE;\n-\t}\n+      for (current = new_list; current; current = TREE_CHAIN (current))\n+\tif (!METHOD_ABSTRACT (TREE_VALUE (current)))\n+\t  {\n+\t    TREE_CHAIN (current) = NULL_TREE;\n+\t    new_list = current;\n+\t  }\n     }\n \n   /* If we can't find one, lower expectations and try to gather multiple\n@@ -13226,7 +13280,7 @@ breakdown_qualified (left, right, source)\n    local variable decls if present.\n    Same as java_complete_lhs, but does resolve static finals to values. */\n \n-static tree\n+tree\n java_complete_tree (node)\n      tree node;\n {\n@@ -14165,8 +14219,9 @@ maybe_absorb_scoping_blocks ()\n \n /* Wrap a non WFL node around a WFL.  */\n static tree\n-build_wfl_wrap (node)\n+build_wfl_wrap (node, location)\n     tree node;\n+    int location;\n {\n   tree wfl, node_to_insert = node;\n   \n@@ -14178,7 +14233,7 @@ build_wfl_wrap (node)\n   else\n     wfl = build_expr_wfl (NULL_TREE, ctxp->filename, 0, 0);\n \n-  EXPR_WFL_LINECOL (wfl) = EXPR_WFL_LINECOL (node);\n+  EXPR_WFL_LINECOL (wfl) = location;\n   EXPR_WFL_QUALIFICATION (wfl) = build_tree_list (node_to_insert, NULL_TREE);\n   return wfl;\n }\n@@ -14344,7 +14399,8 @@ maybe_build_primttype_type_ref (rhs, wfl)\n       tree n = TREE_OPERAND (rhs, 1);\n       if (TREE_CODE (n) == VAR_DECL \n \t  && DECL_NAME (n) == TYPE_identifier_node\n-\t  && rhs_type == class_ptr_type)\n+\t  && rhs_type == class_ptr_type\n+\t  && TREE_CODE (EXPR_WFL_NODE (wfl)) == IDENTIFIER_NODE)\n \t{\n \t  const char *self_name = IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl));\n \t  if (!strncmp (self_name, \"java.lang.\", 10))\n@@ -16236,7 +16292,8 @@ patch_new_array_init (type, node)\n \t  TREE_PURPOSE (current) = NULL_TREE;\n \t  all_constant = 0;\n \t}\n-      if (elt && TREE_VALUE (elt) == error_mark_node)\n+      if (elt && TREE_CODE (elt) == TREE_LIST \n+\t  && TREE_VALUE (elt) == error_mark_node)\n \terror_seen = 1;\n     }\n "}, {"sha": "45573fb355adbb2baedcc242aed32f7298e085d0", "filename": "gcc/java/parse.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e", "patch": "@@ -687,12 +687,11 @@ typedef struct _jdeplist {\n   }\n \n /* Register an import */\n-#define REGISTER_IMPORT(WHOLE, NAME)\t\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  IS_A_SINGLE_IMPORT_CLASSFILE_NAME_P ((NAME)) = 1;\t\\\n-  node = build_tree_list ((WHOLE), (NAME));\t\t\\\n-  TREE_CHAIN (node) = ctxp->import_list;\t\t\\\n-  ctxp->import_list = node;\t\t\t\t\\\n+#define REGISTER_IMPORT(WHOLE, NAME)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  IS_A_SINGLE_IMPORT_CLASSFILE_NAME_P ((NAME)) = 1;\t\t\t\\\n+  ctxp->import_list = chainon (ctxp->import_list, \t\t\t\\\n+\t\t\t       build_tree_list ((WHOLE), (NAME)));\t\\\n }\n \n /* Macro to access the osb (opening square bracket) count */"}, {"sha": "3cf2df40be6cc1e8477747f6fbff0c587f6002a2", "filename": "gcc/java/parse.y", "status": "modified", "additions": 145, "deletions": 86, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=9a7ab4b335fbcbe44a95d92defed46c0e16a5b8e", "patch": "@@ -99,8 +99,9 @@ static void complete_class_report_errors PARAMS ((jdep *));\n static int process_imports PARAMS ((void));\n static void read_import_dir PARAMS ((tree));\n static int find_in_imports_on_demand PARAMS ((tree));\n-static int find_in_imports PARAMS ((tree));\n+static void find_in_imports PARAMS ((tree));\n static int check_pkg_class_access PARAMS ((tree, tree));\n+static void register_package PARAMS ((tree));\n static tree resolve_package PARAMS ((tree, tree *));\n static tree lookup_package_type PARAMS ((const char *, int));\n static tree lookup_package_type_and_set_next PARAMS ((const char *, int, tree *));\n@@ -120,6 +121,7 @@ static tree patch_method_invocation PARAMS ((tree, tree, tree,\n \t\t\t\t\t    int *, tree *));\n static int breakdown_qualified PARAMS ((tree *, tree *, tree));\n static tree resolve_and_layout PARAMS ((tree, tree));\n+static tree qualify_and_find PARAMS ((tree, tree, tree));\n static tree resolve_no_layout PARAMS ((tree, tree));\n static int invocation_mode PARAMS ((tree, int));\n static tree find_applicable_accessible_methods_list PARAMS ((int, tree, \n@@ -180,7 +182,7 @@ static tree build_newarray_node PARAMS ((tree, tree, int));\n static tree patch_newarray PARAMS ((tree));\n static tree resolve_type_during_patch PARAMS ((tree));\n static tree build_this PARAMS ((int));\n-static tree build_wfl_wrap PARAMS ((tree));\n+static tree build_wfl_wrap PARAMS ((tree, int));\n static tree build_return PARAMS ((int, tree));\n static tree patch_return PARAMS ((tree));\n static tree maybe_access_field PARAMS ((tree, tree, tree));\n@@ -682,7 +684,7 @@ package_declaration:\n \tPACKAGE_TK name SC_TK\n \t\t{ \n \t\t  ctxp->package = EXPR_WFL_NODE ($2);\n-\t\t  package_list = tree_cons (ctxp->package, NULL, package_list);\n+\t\t  register_package (ctxp->package);\n \t\t}\n |\tPACKAGE_TK error\n \t\t{yyerror (\"Missing name\"); RECOVER;}\n@@ -698,7 +700,7 @@ import_declaration:\n single_type_import_declaration:\n \tIMPORT_TK name SC_TK\n \t\t{\n-\t\t  tree name = EXPR_WFL_NODE ($2), node, last_name;\n+\t\t  tree name = EXPR_WFL_NODE ($2), last_name;\n \t\t  int   i = IDENTIFIER_LENGTH (name)-1;\n \t\t  const char *last = &IDENTIFIER_POINTER (name)[i];\n \t\t  while (last != IDENTIFIER_POINTER (name))\n@@ -717,7 +719,7 @@ single_type_import_declaration:\n \t\t\t   IDENTIFIER_POINTER (name), \n \t\t\t   IDENTIFIER_POINTER (err));\n \t\t      else\n-\t\t\tREGISTER_IMPORT ($2, last_name)\n+\t\t\tREGISTER_IMPORT ($2, last_name);\n \t\t    }\n \t\t  else\n \t\t    REGISTER_IMPORT ($2, last_name);\n@@ -735,10 +737,10 @@ type_import_on_demand_declaration:\n \t\t  /* Don't import java.lang.* twice. */\n \t\t  if (name != java_lang_id)\n \t\t    {\n-\t\t      tree node = build_tree_list ($2, NULL_TREE);\n \t\t      read_import_dir ($2);\n-\t\t      TREE_CHAIN (node) = ctxp->import_demand_list;\n-\t\t      ctxp->import_demand_list = node;\n+\t\t      ctxp->import_demand_list = \n+\t\t\tchainon (ctxp->import_demand_list,\n+\t\t\t\t build_tree_list ($2, NULL_TREE));\n \t\t    }\n \t\t}\n |\tIMPORT_TK name DOT_TK error\n@@ -2079,6 +2081,11 @@ dim_exprs:\n dim_expr:\n \tOSB_TK expression CSB_TK\n \t\t{ \n+\t\t  if (JNUMERIC_TYPE_P (TREE_TYPE ($2)))\n+\t\t    {\n+\t\t      $2 = build_wfl_node ($2);\n+\t\t      TREE_TYPE ($2) = NULL_TREE;\n+\t\t    }\n \t\t  EXPR_WFL_LINECOL ($2) = $1.location;\n \t\t  $$ = $2;\n \t\t}\n@@ -3993,23 +4000,27 @@ lookup_field_wrapper (class, name)\n      tree class, name;\n {\n   tree type = class;\n-  tree decl;\n+  tree decl = NULL_TREE;\n   java_parser_context_save_global ();\n-  decl = lookup_field (&type, name);\n \n   /* Last chance: if we're within the context of an inner class, we\n      might be trying to access a local variable defined in an outer\n      context. We try to look for it now. */\n-  if (INNER_CLASS_TYPE_P (class) && (!decl || decl == error_mark_node))\n+  if (INNER_CLASS_TYPE_P (class))\n     {\n       char *alias_buffer;\n+      tree new_name;\n       MANGLE_OUTER_LOCAL_VARIABLE_NAME (alias_buffer, name);\n-      name = get_identifier (alias_buffer);\n-      type = class;\n-      decl = lookup_field (&type, name);\n+      new_name = get_identifier (alias_buffer);\n+      decl = lookup_field (&type, new_name);\n       if (decl && decl != error_mark_node)\n \tFIELD_LOCAL_ALIAS_USED (decl) = 1;\n     }\n+  if (!decl || decl == error_mark_node)\n+    {\n+      type = class;\n+      decl = lookup_field (&type, name);\n+    }\n \n   java_parser_context_restore_global ();\n   return decl == error_mark_node ? NULL : decl;\n@@ -4673,7 +4684,7 @@ method_declarator (id, list)\n \n       /* Then this$<n> */\n       type = TREE_TYPE (DECL_CONTEXT (GET_CPC ()));\n-      thisn = build_current_thisn (TYPE_NAME (GET_CPC ()));\n+      thisn = build_current_thisn (TREE_TYPE (GET_CPC ()));\n       list = tree_cons (build_wfl_node (thisn), build_pointer_type (type),\n \t\t\tlist);\n     }\n@@ -5207,10 +5218,8 @@ java_complete_class ()\n \n   push_obstacks (&permanent_obstack, &permanent_obstack);\n \n-  /* Process imports and reverse the import on demand list */\n+  /* Process imports */\n   process_imports ();\n-  if (ctxp->import_demand_list)\n-    ctxp->import_demand_list = nreverse (ctxp->import_demand_list);\n \n   /* Rever things so we have the right order */\n   ctxp->class_list = nreverse (ctxp->class_list);\n@@ -5415,10 +5424,10 @@ do_resolve_class (enclosing, class_type, decl, cl)\n      tree enclosing, class_type, decl, cl;\n {\n   tree new_class_decl;\n-  tree original_name = NULL_TREE;\n \n   /* Do not try to replace TYPE_NAME (class_type) by a variable, since\n-     its is changed by find_in_imports{_on_demand} */\n+     it is changed by find_in_imports{_on_demand} and (but it doesn't\n+     really matter) qualify_and_find */\n \n   /* 0- Search in the current class as an inner class */\n \n@@ -5452,12 +5461,11 @@ do_resolve_class (enclosing, class_type, decl, cl)\n       enclosing = do_resolve_class (NULL, name, NULL, NULL);\n     }\n \n-  /* 1- Check for the type in single imports */\n-  if (find_in_imports (class_type))\n-    return NULL_TREE;\n+  /* 1- Check for the type in single imports. This will change\n+     TYPE_NAME() if something relevant is found */\n+  find_in_imports (class_type);\n \n-  /* 2- And check for the type in the current compilation unit. If it fails,\n-     try with a name qualified with the package name we've seen so far */\n+  /* 2- And check for the type in the current compilation unit */\n   if ((new_class_decl = IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type))))\n     {\n       if (!CLASS_LOADED_P (TREE_TYPE (new_class_decl)) &&\n@@ -5466,34 +5474,37 @@ do_resolve_class (enclosing, class_type, decl, cl)\n       return IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type));\n     }\n \n-  original_name = TYPE_NAME (class_type);\n+  /* 3- Search according to the current package definition */\n+  if (!QUALIFIED_P (TYPE_NAME (class_type)))\n+    {\n+      if ((new_class_decl = qualify_and_find (class_type, ctxp->package,\n+\t\t\t\t\t     TYPE_NAME (class_type))))\n+\treturn new_class_decl;\n+    }\n+\n+  /* 4- Check the import on demands. Don't allow bar.baz to be\n+     imported from foo.* */\n+  if (!QUALIFIED_P (TYPE_NAME (class_type)))\n+    if (find_in_imports_on_demand (class_type))\n+      return NULL_TREE;\n+\n+  /* If found in find_in_imports_on_demant, the type has already been\n+     loaded. */\n+  if ((new_class_decl = IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type))))\n+    return new_class_decl;\n+\n+  /* 5- Try with a name qualified with the package name we've seen so far */\n   if (!QUALIFIED_P (TYPE_NAME (class_type)))\n     {\n       tree package;\n       for (package = package_list; package; package = TREE_CHAIN (package))\n-  \t{\n- \t  tree new_qualified;\n- \t  \n- \t  new_qualified = merge_qualified_name (TREE_PURPOSE (package),\n- \t\t\t\t\t\toriginal_name);\n- \t  TYPE_NAME (class_type) = new_qualified;\n- \t  new_class_decl = IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type));\n- \t  if (!new_class_decl)\n- \t    load_class (TYPE_NAME (class_type), 0);\n- \t  new_class_decl = IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type));\n- \t  if (new_class_decl)\n- \t    {\n- \t      if (!CLASS_LOADED_P (TREE_TYPE (new_class_decl)) &&\n- \t\t  !CLASS_FROM_SOURCE_P (TREE_TYPE (new_class_decl)))\n- \t\tload_class (TYPE_NAME (class_type), 0);\n- \t      return IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type));\n- \t    }\n-\t}\n-    }\n-\n-  TYPE_NAME (class_type) = original_name;\n-\n-  /* 3- Check an other compilation unit that bears the name of type */\n+\tif ((new_class_decl = qualify_and_find (class_type,\n+\t\t\t\t\t       TREE_PURPOSE (package), \n+\t\t\t\t\t       TYPE_NAME (class_type))))\n+\t  return new_class_decl;\n+    }\n+\n+  /* 5- Check an other compilation unit that bears the name of type */\n   load_class (TYPE_NAME (class_type), 0);\n   if (check_pkg_class_access (TYPE_NAME (class_type), \n \t\t\t      (cl ? cl : lookup_cl (decl))))\n@@ -5502,16 +5513,30 @@ do_resolve_class (enclosing, class_type, decl, cl)\n   if ((new_class_decl = IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type))))\n     return new_class_decl;\n \n-  /* 4- Check the import on demands. Don't allow bar.baz to be\n-     imported from foo.* */\n-  if (!QUALIFIED_P (TYPE_NAME (class_type)))\n-    if (find_in_imports_on_demand (class_type))\n-      return NULL_TREE;\n-\n-  /* 5- Last call for a resolution */\n+  /* 6- Last call for a resolution */\n   return IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type));\n }\n \n+static tree\n+qualify_and_find (class_type, package, name)\n+     tree class_type, package, name;\n+{\n+  tree new_qualified = merge_qualified_name (package, name);\n+  tree new_class_decl;\n+\n+  if (!IDENTIFIER_CLASS_VALUE (new_qualified))\n+    load_class (new_qualified, 0);\n+  if ((new_class_decl = IDENTIFIER_CLASS_VALUE (new_qualified)))\n+    {\n+      if (!CLASS_LOADED_P (TREE_TYPE (new_class_decl)) &&\n+\t  !CLASS_FROM_SOURCE_P (TREE_TYPE (new_class_decl)))\n+\tload_class (new_qualified, 0);\n+      TYPE_NAME (class_type) = new_qualified;\n+      return IDENTIFIER_CLASS_VALUE (new_qualified);\n+    }\n+  return NULL_TREE;\n+}\n+\n /* Resolve NAME and lay it out (if not done and if not the current\n    parsed class). Return a decl node. This function is meant to be\n    called when type resolution is necessary during the walk pass.  */\n@@ -6385,10 +6410,10 @@ process_imports ()\n   return 0;\n }\n \n-/* Possibly find a class imported by a single-type import statement. Return\n-   1 if an error occured, 0 otherwise. */\n+/* Possibly find and mark a class imported by a single-type import\n+   statement.  */\n \n-static int\n+static void\n find_in_imports (class_type)\n      tree class_type;\n {\n@@ -6400,7 +6425,6 @@ find_in_imports (class_type)\n \tTYPE_NAME (class_type) = EXPR_WFL_NODE (TREE_PURPOSE (import));\n \tQUALIFIED_P (TYPE_NAME (class_type)) = 1;\n       }\n-  return 0;\n }\n \n static int\n@@ -6610,6 +6634,30 @@ find_in_imports_on_demand (class_type)\n     return (seen_once < 0 ? 0 : seen_once); /* It's ok not to have found */\n }\n \n+/* Add package NAME to the list of package encountered so far. To\n+   speed up class lookup in do_resolve_class, we make sure a\n+   particular package is added only once.  */\n+\n+static void\n+register_package (name)\n+     tree name;\n+{\n+  static struct hash_table _pht, *pht = NULL;\n+\n+  if (!pht)\n+    {\n+      hash_table_init (&_pht, hash_newfunc, \n+\t\t       java_hash_hash_tree_node, java_hash_compare_tree_node);\n+      pht = &_pht;\n+    }\n+  \n+  if (!hash_lookup (pht, (const hash_table_key) name, FALSE, NULL))\n+    {\n+      package_list = chainon (package_list, build_tree_list (name, NULL));\n+      hash_lookup (pht, (const hash_table_key) name, TRUE, NULL);\n+    }\n+}\n+\n static tree\n resolve_package (pkg, next)\n      tree pkg, *next;\n@@ -7378,10 +7426,12 @@ maybe_generate_pre_expand_clinit (class_type)\n   for (current = TYPE_CLINIT_STMT_LIST (class_type); current;\n        current = TREE_CHAIN (current))\n     {\n+      tree stmt = current;\n       /* We build the assignment expression that will initialize the\n \t field to its value. There are strict rules on static\n \t initializers (8.5). FIXME */\n-      tree stmt = build_debugable_stmt (EXPR_WFL_LINECOL (current), current);\n+      if (TREE_CODE (stmt) != BLOCK)\n+\tstmt = build_debugable_stmt (EXPR_WFL_LINECOL (stmt), stmt);\n       java_method_add_stmt (mdecl, stmt);\n     }\n \n@@ -8342,12 +8392,6 @@ java_expand_classes ()\n   java_layout_classes ();\n   java_parse_abort_on_error ();\n \n-  /* The list of packages declaration seen so far needs to be\n-     reversed, so that package declared in a file being compiled gets\n-     priority over packages declared as a side effect of parsing other\n-     files.*/\n-  package_list = nreverse (package_list);\n-\n   saved_ctxp = ctxp_for_generation;\n   for (; ctxp_for_generation; ctxp_for_generation = ctxp_for_generation->next)\n     {\n@@ -8426,7 +8470,7 @@ make_qualified_primary (primary, right, location)\n   tree wfl;\n \n   if (TREE_CODE (primary) != EXPR_WITH_FILE_LOCATION)\n-    wfl = build_wfl_wrap (primary);\n+    wfl = build_wfl_wrap (primary, location);\n   else\n     {\n       wfl = primary;\n@@ -8643,7 +8687,8 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n     return error_mark_node;\n \n   /* Resolve the LENGTH field of an array here */\n-  if (DECL_NAME (decl) == length_identifier_node && TYPE_ARRAY_P (type_found)\n+  if (DECL_P (decl) && DECL_NAME (decl) == length_identifier_node \n+      && TYPE_ARRAY_P (type_found) \n       && ! flag_emit_class_files && ! flag_emit_xref)\n     {\n       tree length = build_java_array_length_access (where_found);\n@@ -10035,7 +10080,8 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n     }\n \n   /* Search interfaces */\n-  if (CLASS_INTERFACE (TYPE_NAME (class)))\n+  if (TREE_CODE (TYPE_NAME (class)) == TYPE_DECL \n+      && CLASS_INTERFACE (TYPE_NAME (class)))\n     {\n       static struct hash_table t, *searched_interfaces = NULL;\n       static int search_not_done = 0;\n@@ -10183,6 +10229,7 @@ find_most_specific_methods_list (list)\n      tree list;\n {\n   int max = 0;\n+  int abstract, candidates;\n   tree current, new_list = NULL_TREE;\n   for (current = list; current; current = TREE_CHAIN (current))\n     {\n@@ -10209,24 +10256,33 @@ find_most_specific_methods_list (list)\n     }\n \n   /* Review the list and select the maximally specific methods */\n-  for (current = list; current; current = TREE_CHAIN (current))\n+  for (current = list, abstract = -1, candidates = -1;\n+       current; current = TREE_CHAIN (current))\n     if (DECL_SPECIFIC_COUNT (TREE_VALUE (current)) == max)\n-      new_list = tree_cons (NULL_TREE, TREE_VALUE (current), new_list);\n+      {\n+\tnew_list = tree_cons (NULL_TREE, TREE_VALUE (current), new_list);\n+\tabstract += (METHOD_ABSTRACT (TREE_VALUE (current)) ? 1 : 0);\n+\tcandidates++;\n+      }\n \n   /* If we have several and they're all abstract, just pick the\n      closest one. */\n+  if (candidates > 0 && (candidates == abstract))\n+    {\n+      new_list = nreverse (new_list);\n+      TREE_CHAIN (new_list) = NULL_TREE;\n+    }\n \n-  if (new_list && TREE_CHAIN (new_list))\n+  /* We have several, we couldn't find a most specific, all but one are\n+     abstract, we pick the only non abstract one. */\n+  if (candidates > 0 && !max && (candidates == abstract+1))\n     {\n-      tree c;\n-      for (c = new_list; c && METHOD_ABSTRACT (TREE_VALUE (c)); \n-\t   c = TREE_CHAIN (c))\n-        ;\n-      if (!c)\n-\t{\n-\t  new_list = nreverse (new_list);\n-\t  TREE_CHAIN (new_list) = NULL_TREE;\n-\t}\n+      for (current = new_list; current; current = TREE_CHAIN (current))\n+\tif (!METHOD_ABSTRACT (TREE_VALUE (current)))\n+\t  {\n+\t    TREE_CHAIN (current) = NULL_TREE;\n+\t    new_list = current;\n+\t  }\n     }\n \n   /* If we can't find one, lower expectations and try to gather multiple\n@@ -11465,8 +11521,9 @@ maybe_absorb_scoping_blocks ()\n \n /* Wrap a non WFL node around a WFL.  */\n static tree\n-build_wfl_wrap (node)\n+build_wfl_wrap (node, location)\n     tree node;\n+    int location;\n {\n   tree wfl, node_to_insert = node;\n   \n@@ -11478,7 +11535,7 @@ build_wfl_wrap (node)\n   else\n     wfl = build_expr_wfl (NULL_TREE, ctxp->filename, 0, 0);\n \n-  EXPR_WFL_LINECOL (wfl) = EXPR_WFL_LINECOL (node);\n+  EXPR_WFL_LINECOL (wfl) = location;\n   EXPR_WFL_QUALIFICATION (wfl) = build_tree_list (node_to_insert, NULL_TREE);\n   return wfl;\n }\n@@ -11644,7 +11701,8 @@ maybe_build_primttype_type_ref (rhs, wfl)\n       tree n = TREE_OPERAND (rhs, 1);\n       if (TREE_CODE (n) == VAR_DECL \n \t  && DECL_NAME (n) == TYPE_identifier_node\n-\t  && rhs_type == class_ptr_type)\n+\t  && rhs_type == class_ptr_type\n+\t  && TREE_CODE (EXPR_WFL_NODE (wfl)) == IDENTIFIER_NODE)\n \t{\n \t  const char *self_name = IDENTIFIER_POINTER (EXPR_WFL_NODE (wfl));\n \t  if (!strncmp (self_name, \"java.lang.\", 10))\n@@ -13536,7 +13594,8 @@ patch_new_array_init (type, node)\n \t  TREE_PURPOSE (current) = NULL_TREE;\n \t  all_constant = 0;\n \t}\n-      if (elt && TREE_VALUE (elt) == error_mark_node)\n+      if (elt && TREE_CODE (elt) == TREE_LIST \n+\t  && TREE_VALUE (elt) == error_mark_node)\n \terror_seen = 1;\n     }\n "}]}