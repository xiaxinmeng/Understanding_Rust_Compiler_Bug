{"sha": "8d261514a7f4641eb540352156386d444962fb73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQyNjE1MTRhN2Y0NjQxZWI1NDAzNTIxNTYzODZkNDQ0OTYyZmI3Mw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2014-11-18T16:13:05Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2014-11-18T16:13:05Z"}, "message": "fibonacci_heap is used for bb-reoder purpose.\n\n\t* bb-reorder.c (mark_bb_visited): New fibonacci_heap is used.\n\t(find_traces): Likewise.\n\t(find_traces_1_round): Likewise.\n\nFrom-SVN: r217721", "tree": {"sha": "3c2d77a8109c9a7b14034ac608fe4bad8f41e0c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c2d77a8109c9a7b14034ac608fe4bad8f41e0c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d261514a7f4641eb540352156386d444962fb73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d261514a7f4641eb540352156386d444962fb73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d261514a7f4641eb540352156386d444962fb73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d261514a7f4641eb540352156386d444962fb73/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4a91004954f29d8f7c05da3cf70ace12eaeb891b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a91004954f29d8f7c05da3cf70ace12eaeb891b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a91004954f29d8f7c05da3cf70ace12eaeb891b"}], "stats": {"total": 67, "additions": 36, "deletions": 31}, "files": [{"sha": "3f285a57a618a265f581c6f5de95f2621b897f82", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d261514a7f4641eb540352156386d444962fb73/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d261514a7f4641eb540352156386d444962fb73/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d261514a7f4641eb540352156386d444962fb73", "patch": "@@ -1,3 +1,9 @@\n+2014-11-18  Martin Liska  <mliska@suse.cz>\n+\n+\t* bb-reorder.c (mark_bb_visited): New fibonacci_heap is used.\n+\t(find_traces): Likewise.\n+\t(find_traces_1_round): Likewise.\n+\n 2014-11-18  Martin Liska  <mliska@suse.cz>\n \n \t* fibonacci_heap.h: New file."}, {"sha": "0cab286115166576c0df3c515d31da0aff00e3a9", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d261514a7f4641eb540352156386d444962fb73/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d261514a7f4641eb540352156386d444962fb73/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=8d261514a7f4641eb540352156386d444962fb73", "patch": "@@ -87,7 +87,6 @@\n #include \"regs.h\"\n #include \"flags.h\"\n #include \"output.h\"\n-#include \"fibheap.h\"\n #include \"target.h\"\n #include \"hashtab.h\"\n #include \"hash-set.h\"\n@@ -120,6 +119,7 @@\n #include \"ipa-ref.h\"\n #include \"cgraph.h\"\n #include \"except.h\"\n+#include \"fibonacci_heap.h\"\n \n /* The number of rounds.  In most cases there will only be 4 rounds, but\n    when partitioning hot and cold basic blocks into separate sections of\n@@ -153,6 +153,9 @@ static const int exec_threshold[N_ROUNDS] = {500, 200, 50, 0, 0};\n    block the edge destination is not duplicated while connecting traces.  */\n #define DUPLICATION_THRESHOLD 100\n \n+typedef fibonacci_heap <long, basic_block_def> bb_heap_t;\n+typedef fibonacci_node <long, basic_block_def> bb_heap_node_t;\n+\n /* Structure to hold needed information for each basic block.  */\n typedef struct bbro_basic_block_data_def\n {\n@@ -169,10 +172,10 @@ typedef struct bbro_basic_block_data_def\n   int visited;\n \n   /* Which heap is BB in (if any)?  */\n-  fibheap_t heap;\n+  bb_heap_t *heap;\n \n   /* Which heap node is BB in (if any)?  */\n-  fibnode_t node;\n+  bb_heap_node_t *node;\n } bbro_basic_block_data;\n \n /* The current size of the following dynamic array.  */\n@@ -210,9 +213,9 @@ static void find_traces (int *, struct trace *);\n static basic_block rotate_loop (edge, struct trace *, int);\n static void mark_bb_visited (basic_block, int);\n static void find_traces_1_round (int, int, gcov_type, struct trace *, int *,\n-\t\t\t\t int, fibheap_t *, int);\n+\t\t\t\t int, bb_heap_t **, int);\n static basic_block copy_bb (basic_block, edge, basic_block, int);\n-static fibheapkey_t bb_to_key (basic_block);\n+static long bb_to_key (basic_block);\n static bool better_edge_p (const_basic_block, const_edge, int, int, int, int,\n \t\t\t   const_edge);\n static bool connect_better_edge_p (const_edge, bool, int, const_edge,\n@@ -238,7 +241,7 @@ mark_bb_visited (basic_block bb, int trace)\n   bbd[bb->index].visited = trace;\n   if (bbd[bb->index].heap)\n     {\n-      fibheap_delete_node (bbd[bb->index].heap, bbd[bb->index].node);\n+      bbd[bb->index].heap->delete_node (bbd[bb->index].node);\n       bbd[bb->index].heap = NULL;\n       bbd[bb->index].node = NULL;\n     }\n@@ -283,7 +286,7 @@ find_traces (int *n_traces, struct trace *traces)\n   int number_of_rounds;\n   edge e;\n   edge_iterator ei;\n-  fibheap_t heap;\n+  bb_heap_t *heap = new bb_heap_t (LONG_MIN);\n \n   /* Add one extra round of trace collection when partitioning hot/cold\n      basic blocks into separate sections.  The last round is for all the\n@@ -292,14 +295,12 @@ find_traces (int *n_traces, struct trace *traces)\n   number_of_rounds = N_ROUNDS - 1;\n \n   /* Insert entry points of function into heap.  */\n-  heap = fibheap_new ();\n   max_entry_frequency = 0;\n   max_entry_count = 0;\n   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs)\n     {\n       bbd[e->dest->index].heap = heap;\n-      bbd[e->dest->index].node = fibheap_insert (heap, bb_to_key (e->dest),\n-\t\t\t\t\t\t    e->dest);\n+      bbd[e->dest->index].node = heap->insert (bb_to_key (e->dest), e->dest);\n       if (e->dest->frequency > max_entry_frequency)\n \tmax_entry_frequency = e->dest->frequency;\n       if (e->dest->count > max_entry_count)\n@@ -324,7 +325,7 @@ find_traces (int *n_traces, struct trace *traces)\n \t\t\t   count_threshold, traces, n_traces, i, &heap,\n \t\t\t   number_of_rounds);\n     }\n-  fibheap_delete (heap);\n+  delete heap;\n \n   if (dump_file)\n     {\n@@ -470,22 +471,22 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n static void\n find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t     struct trace *traces, int *n_traces, int round,\n-\t\t     fibheap_t *heap, int number_of_rounds)\n+\t\t     bb_heap_t **heap, int number_of_rounds)\n {\n   /* Heap for discarded basic blocks which are possible starting points for\n      the next round.  */\n-  fibheap_t new_heap = fibheap_new ();\n+  bb_heap_t *new_heap = new bb_heap_t (LONG_MIN);\n   bool for_size = optimize_function_for_size_p (cfun);\n \n-  while (!fibheap_empty (*heap))\n+  while (!(*heap)->empty ())\n     {\n       basic_block bb;\n       struct trace *trace;\n       edge best_edge, e;\n-      fibheapkey_t key;\n+      long key;\n       edge_iterator ei;\n \n-      bb = (basic_block) fibheap_extract_min (*heap);\n+      bb = (*heap)->extract_min ();\n       bbd[bb->index].heap = NULL;\n       bbd[bb->index].node = NULL;\n \n@@ -503,7 +504,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t{\n \t  int key = bb_to_key (bb);\n \t  bbd[bb->index].heap = new_heap;\n-\t  bbd[bb->index].node = fibheap_insert (new_heap, key, bb);\n+\t  bbd[bb->index].node = new_heap->insert (key, bb);\n \n \t  if (dump_file)\n \t    fprintf (dump_file,\n@@ -633,23 +634,23 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t      if (bbd[e->dest->index].heap)\n \t\t{\n \t\t  /* E->DEST is already in some heap.  */\n-\t\t  if (key != bbd[e->dest->index].node->key)\n+\t\t  if (key != bbd[e->dest->index].node->get_key ())\n \t\t    {\n \t\t      if (dump_file)\n \t\t\t{\n \t\t\t  fprintf (dump_file,\n \t\t\t\t   \"Changing key for bb %d from %ld to %ld.\\n\",\n \t\t\t\t   e->dest->index,\n-\t\t\t\t   (long) bbd[e->dest->index].node->key,\n+\t\t\t\t   (long) bbd[e->dest->index].node->get_key (),\n \t\t\t\t   key);\n \t\t\t}\n-\t\t      fibheap_replace_key (bbd[e->dest->index].heap,\n-\t\t\t\t\t   bbd[e->dest->index].node, key);\n+\t\t      bbd[e->dest->index].heap->decrease_key\n+\t\t        (bbd[e->dest->index].node, key);\n \t\t    }\n \t\t}\n \t      else\n \t\t{\n-\t\t  fibheap_t which_heap = *heap;\n+\t\t  bb_heap_t *which_heap = *heap;\n \n \t\t  prob = e->probability;\n \t\t  freq = EDGE_FREQUENCY (e);\n@@ -671,8 +672,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t    }\n \n \t\t  bbd[e->dest->index].heap = which_heap;\n-\t\t  bbd[e->dest->index].node = fibheap_insert (which_heap,\n-\t\t\t\t\t\t\t\tkey, e->dest);\n+\t\t  bbd[e->dest->index].node = which_heap->insert (key, e->dest);\n \n \t\t  if (dump_file)\n \t\t    {\n@@ -803,24 +803,23 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t  if (bbd[e->dest->index].heap)\n \t    {\n \t      key = bb_to_key (e->dest);\n-\t      if (key != bbd[e->dest->index].node->key)\n+\t      if (key != bbd[e->dest->index].node->get_key ())\n \t\t{\n \t\t  if (dump_file)\n \t\t    {\n \t\t      fprintf (dump_file,\n \t\t\t       \"Changing key for bb %d from %ld to %ld.\\n\",\n \t\t\t       e->dest->index,\n-\t\t\t       (long) bbd[e->dest->index].node->key, key);\n+\t\t\t       (long) bbd[e->dest->index].node->get_key (), key);\n \t\t    }\n-\t\t  fibheap_replace_key (bbd[e->dest->index].heap,\n-\t\t\t\t       bbd[e->dest->index].node,\n-\t\t\t\t       key);\n+\t\t  bbd[e->dest->index].heap->decrease_key\n+\t\t    (bbd[e->dest->index].node, key);\n \t\t}\n \t    }\n \t}\n     }\n \n-  fibheap_delete (*heap);\n+  delete (*heap);\n \n   /* \"Return\" the new heap.  */\n   *heap = new_heap;\n@@ -885,7 +884,7 @@ copy_bb (basic_block old_bb, edge e, basic_block bb, int trace)\n \n /* Compute and return the key (for the heap) of the basic block BB.  */\n \n-static fibheapkey_t\n+static long\n bb_to_key (basic_block bb)\n {\n   edge e;"}]}