{"sha": "6f1661e52511a14300cfbc8bc14de28b0847e1f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYxNjYxZTUyNTExYTE0MzAwY2ZiYzhiYzE0ZGUyOGIwODQ3ZTFmMw==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "1999-08-29T10:31:20Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-08-29T10:31:20Z"}, "message": "jump.c (delete_prior_computation): Also check calls to constant functions.\n\n        * jump.c (delete_prior_computation): Also check calls\n        to constant functions.  Don't bother checking for a\n        REG_UNUSED note before adding it.\n        (delete_computation): Handle multi-word hard registers\n        when synthesizing missing REG_DEAD notes for a register\n        which is both set and used by an insn.\n\nFrom-SVN: r28962", "tree": {"sha": "56b1f77682c9609d7671a1a5f29abe1d056814f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56b1f77682c9609d7671a1a5f29abe1d056814f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f1661e52511a14300cfbc8bc14de28b0847e1f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f1661e52511a14300cfbc8bc14de28b0847e1f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f1661e52511a14300cfbc8bc14de28b0847e1f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f1661e52511a14300cfbc8bc14de28b0847e1f3/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3c748bb6de9b66e09e269e20c07107a3f120b4e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c748bb6de9b66e09e269e20c07107a3f120b4e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c748bb6de9b66e09e269e20c07107a3f120b4e4"}], "stats": {"total": 60, "additions": 43, "deletions": 17}, "files": [{"sha": "b57e6c631e54d63d2a0e062c916e48cfd9e86100", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1661e52511a14300cfbc8bc14de28b0847e1f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1661e52511a14300cfbc8bc14de28b0847e1f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f1661e52511a14300cfbc8bc14de28b0847e1f3", "patch": "@@ -1,3 +1,12 @@\n+Sun Aug 29 04:30:52 1999  John Wehle  (john@feith.com)\n+\n+\t* jump.c (delete_prior_computation): Also check calls\n+\tto constant functions.  Don't bother checking for a\n+\tREG_UNUSED note before adding it.\n+\t(delete_computation): Handle multi-word hard registers\n+\twhen synthesizing missing REG_DEAD notes for a register\n+\twhich is both set and used by an insn.\n+\n 1999-08-29  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* loop.c (this_loop_info): New variable."}, {"sha": "098e2d4dd7a475d405f561ebdb5b1a6f0775b1d3", "filename": "gcc/jump.c", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1661e52511a14300cfbc8bc14de28b0847e1f3/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1661e52511a14300cfbc8bc14de28b0847e1f3/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=6f1661e52511a14300cfbc8bc14de28b0847e1f3", "patch": "@@ -3892,11 +3892,19 @@ delete_prior_computation (note, insn)\n   rtx reg = XEXP (note, 0);\n \n   for (our_prev = prev_nonnote_insn (insn);\n-       our_prev && GET_CODE (our_prev) == INSN;\n+       our_prev && (GET_CODE (our_prev) == INSN\n+\t\t    || GET_CODE (our_prev) == CALL_INSN);\n        our_prev = prev_nonnote_insn (our_prev))\n     {\n       rtx pat = PATTERN (our_prev);\n \n+      /* If we reach a CALL which is not calling a const function\n+\t or the callee pops the arguments, then give up.  */\n+      if (GET_CODE (our_prev) == CALL_INSN\n+\t  && (! CONST_CALL_P (our_prev)\n+\t      || GET_CODE (pat) != SET || GET_CODE (SET_SRC (pat)) != CALL))\n+\tbreak;\n+\n       /* If we reach a SEQUENCE, it is too complex to try to\n \t do anything with it, so give up.  */\n       if (GET_CODE (pat) == SEQUENCE)\n@@ -3910,7 +3918,7 @@ delete_prior_computation (note, insn)\n \n       if (reg_set_p (reg, pat))\n \t{\n-\t  if (side_effects_p (pat))\n+\t  if (side_effects_p (pat) && GET_CODE (our_prev) != CALL_INSN)\n \t    break;\n \n \t  if (GET_CODE (pat) == PARALLEL)\n@@ -3953,8 +3961,7 @@ delete_prior_computation (note, insn)\n \t\t insns.  Write REG_UNUSED notes for those parts that were not\n \t\t needed.  */\n \t      else if (dest_regno <= regno\n-\t\t       && dest_endregno >= endregno\n-\t\t       && ! find_regno_note (our_prev, REG_UNUSED, REGNO(reg)))\n+\t\t       && dest_endregno >= endregno)\n \t\t{\n \t\t  int i;\n \n@@ -4040,7 +4047,30 @@ delete_computation (insn)\n     }\n #endif\n \n+  /* The REG_DEAD note may have been omitted for a register\n+     which is both set and used by the insn.  */\n   set = single_set (insn);\n+  if (set && GET_CODE (SET_DEST (set)) == REG)\n+    {\n+    int dest_regno = REGNO (SET_DEST (set));\n+    int dest_endregno\n+\t  = dest_regno + (dest_regno < FIRST_PSEUDO_REGISTER \n+\t    ? HARD_REGNO_NREGS (dest_regno,\n+\t\t\t\tGET_MODE (SET_DEST (set))) : 1);\n+    int i;\n+\n+    for (i = dest_regno; i < dest_endregno; i++)\n+      {\n+\tif (! refers_to_regno_p (i, i + 1, SET_SRC (set), NULL_PTR)\n+\t    || find_regno_note (insn, REG_DEAD, i))\n+\t  continue;\n+\n+\tnote = gen_rtx_EXPR_LIST (REG_DEAD, (i < FIRST_PSEUDO_REGISTER\n+\t\t\t\t\t     ? gen_rtx_REG (reg_raw_mode[i], i)\n+\t\t\t\t\t     : SET_DEST (set)), NULL_RTX);\n+\tdelete_prior_computation (note, insn);\n+      }\n+    }\n \n   for (note = REG_NOTES (insn); note; note = next)\n     {\n@@ -4051,19 +4081,6 @@ delete_computation (insn)\n \t  || GET_CODE (XEXP (note, 0)) != REG)\n \tcontinue;\n \n-      if (set && reg_overlap_mentioned_p (SET_DEST (set), XEXP (note, 0)))\n-\tset = NULL_RTX;\n-\n-      delete_prior_computation (note, insn);\n-    }\n-\n-  /* The REG_DEAD note may have been omitted for a register\n-     which is both set and used by the insn.  */\n-  if (set\n-      && GET_CODE (SET_DEST (set)) == REG\n-      && reg_mentioned_p (SET_DEST (set), SET_SRC (set)))\n-    {\n-      note = gen_rtx_EXPR_LIST (REG_DEAD, SET_DEST (set), NULL_RTX);\n       delete_prior_computation (note, insn);\n     }\n "}]}