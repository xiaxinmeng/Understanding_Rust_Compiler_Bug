{"sha": "3598c8db4045d17705f845561517f74bf877a2e4", "node_id": "C_kwDOANBUbNoAKDM1OThjOGRiNDA0NWQxNzcwNWY4NDU1NjE1MTdmNzRiZjg3N2EyZTQ", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2021-06-30T23:42:54Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-09-21T15:24:56Z"}, "message": "[Ada] Refactor sort procedures of doubly linked list containers\n\ngcc/ada/\n\n\t* libgnat/a-costso.ads, libgnat/a-costso.adb: A new library\n\tunit, Ada.Containers.Stable_Sorting, which exports a pair of\n\tgenerics (one within the other) which are instantiated by each\n\tof the 5 doubly-linked list container generics to implement\n\ttheir respective Sort procedures. We use a pair of generics,\n\trather than a single generic, in order to further reduce code\n\tduplication. The outer generic takes a formal private Node_Ref\n\ttype representing a reference to a linked list element. For some\n\tinstances, the corresponding actual parameter will be an access\n\ttype; for others, it will be the index type for an array.\n\t* Makefile.rtl: Include new Ada.Containers.Stable_Sorting unit.\n\t* libgnat/a-cbdlli.adb, libgnat/a-cdlili.adb,\n\tlibgnat/a-cfdlli.adb, libgnat/a-cidlli.adb, libgnat/a-crdlli.adb\n\t(Sort): Replace existing Sort implementation with a call to an\n\tinstance of\n\tAda.Containers.Stable_Sorting.Doubly_Linked_List_Sort. Declare\n\tthe (trivial) actual parameters needed to declare that instance.\n\t* libgnat/a-cfdlli.ads: Fix a bug encountered during testing in\n\tthe postcondition for M_Elements_Sorted. With a partial\n\tordering, it is possible for all three of (X < Y), (Y < X),\n\tand (X = Y) to be simultaneously false, so that case needs to\n\thandled correctly.", "tree": {"sha": "ce4f30b2ef15034be4d6da524d7fc2f93595679e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce4f30b2ef15034be4d6da524d7fc2f93595679e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3598c8db4045d17705f845561517f74bf877a2e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3598c8db4045d17705f845561517f74bf877a2e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3598c8db4045d17705f845561517f74bf877a2e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3598c8db4045d17705f845561517f74bf877a2e4/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2528d0c7ce0536b3299f6a7452195362002c1a8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2528d0c7ce0536b3299f6a7452195362002c1a8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2528d0c7ce0536b3299f6a7452195362002c1a8c"}], "stats": {"total": 903, "additions": 455, "deletions": 448}, "files": [{"sha": "f32ed170ef2e82a038e0c899e07c141e41b405bb", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3598c8db4045d17705f845561517f74bf877a2e4/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3598c8db4045d17705f845561517f74bf877a2e4/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=3598c8db4045d17705f845561517f74bf877a2e4", "patch": "@@ -162,6 +162,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-coormu$(objext) \\\n   a-coorse$(objext) \\\n   a-coprnu$(objext) \\\n+  a-costso$(objext) \\\n   a-coteio$(objext) \\\n   a-crbltr$(objext) \\\n   a-crbtgk$(objext) \\"}, {"sha": "3752ca94aff5b28ed17f5387767666b152a589fe", "filename": "gcc/ada/libgnat/a-cbdlli.adb", "status": "modified", "additions": 38, "deletions": 69, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3598c8db4045d17705f845561517f74bf877a2e4/gcc%2Fada%2Flibgnat%2Fa-cbdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3598c8db4045d17705f845561517f74bf877a2e4/gcc%2Fada%2Flibgnat%2Fa-cbdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cbdlli.adb?ref=3598c8db4045d17705f845561517f74bf877a2e4", "patch": "@@ -27,6 +27,8 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n+with Ada.Containers.Stable_Sorting; use Ada.Containers.Stable_Sorting;\n+\n with System; use type System.Address;\n with System.Put_Images;\n \n@@ -858,74 +860,6 @@ is\n \n       procedure Sort (Container : in out List) is\n          N : Node_Array renames Container.Nodes;\n-\n-         procedure Partition (Pivot, Back : Count_Type);\n-         --  What does this do ???\n-\n-         procedure Sort (Front, Back : Count_Type);\n-         --  Internal procedure, what does it do??? rename it???\n-\n-         ---------------\n-         -- Partition --\n-         ---------------\n-\n-         procedure Partition (Pivot, Back : Count_Type) is\n-            Node : Count_Type;\n-\n-         begin\n-            Node := N (Pivot).Next;\n-            while Node /= Back loop\n-               if N (Node).Element < N (Pivot).Element then\n-                  declare\n-                     Prev : constant Count_Type := N (Node).Prev;\n-                     Next : constant Count_Type := N (Node).Next;\n-\n-                  begin\n-                     N (Prev).Next := Next;\n-\n-                     if Next = 0 then\n-                        Container.Last := Prev;\n-                     else\n-                        N (Next).Prev := Prev;\n-                     end if;\n-\n-                     N (Node).Next := Pivot;\n-                     N (Node).Prev := N (Pivot).Prev;\n-\n-                     N (Pivot).Prev := Node;\n-\n-                     if N (Node).Prev = 0 then\n-                        Container.First := Node;\n-                     else\n-                        N (N (Node).Prev).Next := Node;\n-                     end if;\n-\n-                     Node := Next;\n-                  end;\n-\n-               else\n-                  Node := N (Node).Next;\n-               end if;\n-            end loop;\n-         end Partition;\n-\n-         ----------\n-         -- Sort --\n-         ----------\n-\n-         procedure Sort (Front, Back : Count_Type) is\n-            Pivot : constant Count_Type :=\n-              (if Front = 0 then Container.First else N (Front).Next);\n-         begin\n-            if Pivot /= Back then\n-               Partition (Pivot, Back);\n-               Sort (Front, Pivot);\n-               Sort (Pivot, Back);\n-            end if;\n-         end Sort;\n-\n-      --  Start of processing for Sort\n-\n       begin\n          if Container.Length <= 1 then\n             return;\n@@ -941,8 +875,43 @@ is\n \n          declare\n             Lock : With_Lock (Container.TC'Unchecked_Access);\n+\n+            package Descriptors is new List_Descriptors\n+              (Node_Ref => Count_Type, Nil => 0);\n+            use Descriptors;\n+\n+            function Next (Idx : Count_Type) return Count_Type is\n+              (N (Idx).Next);\n+            procedure Set_Next (Idx : Count_Type; Next : Count_Type)\n+              with Inline;\n+            procedure Set_Prev (Idx : Count_Type; Prev : Count_Type)\n+              with Inline;\n+            function \"<\" (L, R : Count_Type) return Boolean is\n+              (N (L).Element < N (R).Element);\n+            procedure Update_Container (List : List_Descriptor) with Inline;\n+\n+            procedure Set_Next (Idx : Count_Type; Next : Count_Type) is\n+            begin\n+               N (Idx).Next := Next;\n+            end Set_Next;\n+\n+            procedure Set_Prev (Idx : Count_Type; Prev : Count_Type) is\n+            begin\n+               N (Idx).Prev := Prev;\n+            end Set_Prev;\n+\n+            procedure Update_Container (List : List_Descriptor) is\n+            begin\n+               Container.First  := List.First;\n+               Container.Last   := List.Last;\n+               Container.Length := List.Length;\n+            end Update_Container;\n+\n+            procedure Sort_List is new Doubly_Linked_List_Sort;\n          begin\n-            Sort (Front => 0, Back => 0);\n+            Sort_List (List_Descriptor'(First  => Container.First,\n+                                        Last   => Container.Last,\n+                                        Length => Container.Length));\n          end;\n \n          pragma Assert (N (Container.First).Prev = 0);"}, {"sha": "1d48ed9209ae8781e58f4223fdf2c5886478badc", "filename": "gcc/ada/libgnat/a-cdlili.adb", "status": "modified", "additions": 36, "deletions": 169, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3598c8db4045d17705f845561517f74bf877a2e4/gcc%2Fada%2Flibgnat%2Fa-cdlili.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3598c8db4045d17705f845561517f74bf877a2e4/gcc%2Fada%2Flibgnat%2Fa-cdlili.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cdlili.adb?ref=3598c8db4045d17705f845561517f74bf877a2e4", "patch": "@@ -29,6 +29,8 @@\n \n with Ada.Unchecked_Deallocation;\n \n+with Ada.Containers.Stable_Sorting; use Ada.Containers.Stable_Sorting;\n+\n with System; use type System.Address;\n with System.Put_Images;\n \n@@ -674,156 +676,6 @@ is\n       ----------\n \n       procedure Sort (Container : in out List) is\n-\n-         type List_Descriptor is\n-            record\n-               First, Last : Node_Access;\n-               Length      : Count_Type;\n-            end record;\n-\n-         function Merge_Sort (Arg : List_Descriptor) return List_Descriptor;\n-         --  Sort list of given length using MergeSort; length must be >= 2.\n-         --  As required by RM, the sort is stable.\n-\n-         ----------------\n-         -- Merge_Sort --\n-         ----------------\n-\n-         function Merge_Sort (Arg : List_Descriptor) return List_Descriptor\n-         is\n-            procedure Split_List\n-              (Unsplit : List_Descriptor; Part1, Part2 : out List_Descriptor);\n-            --  Split list into two parts for divide-and-conquer.\n-            --  Unsplit.Length must be >= 2.\n-\n-            function Merge_Parts\n-              (Part1, Part2 : List_Descriptor) return List_Descriptor;\n-            --  Merge two sorted lists, preserving sorted property.\n-\n-            ----------------\n-            -- Split_List --\n-            ----------------\n-\n-            procedure Split_List\n-              (Unsplit : List_Descriptor; Part1, Part2 : out List_Descriptor)\n-            is\n-               Rover : Node_Access := Unsplit.First;\n-               Bump_Count : constant Count_Type := (Unsplit.Length - 1) / 2;\n-            begin\n-               for Iter in 1 .. Bump_Count loop\n-                  Rover := Rover.Next;\n-               end loop;\n-\n-               Part1 := (First  => Unsplit.First,\n-                         Last   => Rover,\n-                         Length => Bump_Count + 1);\n-\n-               Part2 := (First => Rover.Next,\n-                         Last  => Unsplit.Last,\n-                         Length => Unsplit.Length - Part1.Length);\n-\n-               --  Detach\n-               Part1.Last.Next := null;\n-               Part2.First.Prev := null;\n-            end Split_List;\n-\n-            -----------------\n-            -- Merge_Parts --\n-            -----------------\n-\n-            function Merge_Parts\n-              (Part1, Part2 : List_Descriptor) return List_Descriptor\n-            is\n-               Empty  : constant List_Descriptor := (null, null, 0);\n-\n-               procedure Detach_First (Source   : in out List_Descriptor;\n-                                       Detached : out Node_Access);\n-               --  Detach the first element from a non-empty list and\n-               --  return the detached node via the Detached parameter.\n-\n-               ------------------\n-               -- Detach_First --\n-               ------------------\n-\n-               procedure Detach_First (Source   : in out List_Descriptor;\n-                                       Detached : out Node_Access) is\n-               begin\n-                  Detached := Source.First;\n-\n-                  if Source.Length = 1 then\n-                     Source := Empty;\n-                  else\n-                     Source := (Source.First.Next,\n-                                Source.Last,\n-                                Source.Length - 1);\n-\n-                     Detached.Next.Prev := null;\n-                     Detached.Next := null;\n-                  end if;\n-               end Detach_First;\n-\n-               P1     : List_Descriptor := Part1;\n-               P2     : List_Descriptor := Part2;\n-               Merged : List_Descriptor := Empty;\n-\n-               Take_From_P2 : Boolean;\n-               Detached     : Node_Access;\n-\n-            --  Start of processing for Merge_Parts\n-\n-            begin\n-               while (P1.Length /= 0) or (P2.Length /= 0) loop\n-                  if P1.Length = 0 then\n-                     Take_From_P2 := True;\n-                  elsif P2.Length = 0 then\n-                     Take_From_P2 := False;\n-                  else\n-                     --  If the compared elements are equal then Take_From_P2\n-                     --  must be False in order to ensure stability.\n-\n-                     Take_From_P2 := P2.First.Element < P1.First.Element;\n-                  end if;\n-\n-                  if Take_From_P2 then\n-                     Detach_First (P2, Detached);\n-                  else\n-                     Detach_First (P1, Detached);\n-                  end if;\n-\n-                  if Merged.Length = 0 then\n-                     Merged := (First | Last => Detached, Length => 1);\n-                  else\n-                     Detached.Prev := Merged.Last;\n-                     Merged.Last.Next := Detached;\n-                     Merged.Last := Detached;\n-                     Merged.Length := Merged.Length + 1;\n-                  end if;\n-               end loop;\n-               return Merged;\n-            end Merge_Parts;\n-\n-         --  Start of processing for Merge_Sort\n-\n-         begin\n-            if Arg.Length < 2 then\n-               --  already sorted\n-               return Arg;\n-            end if;\n-\n-            declare\n-               Part1, Part2 : List_Descriptor;\n-            begin\n-               Split_List (Unsplit => Arg, Part1 => Part1, Part2 => Part2);\n-\n-               Part1 := Merge_Sort (Part1);\n-               Part2 := Merge_Sort (Part2);\n-\n-               return Merge_Parts (Part1, Part2);\n-            end;\n-         end Merge_Sort;\n-\n-      --  Start of processing for Sort\n-\n       begin\n          if Container.Length <= 1 then\n             return;\n@@ -838,28 +690,43 @@ is\n          --  element tampering by a generic actual subprogram.\n \n          declare\n-            Lock     : With_Lock (Container.TC'Unchecked_Access);\n+            Lock : With_Lock (Container.TC'Unchecked_Access);\n+\n+            package Descriptors is new List_Descriptors\n+              (Node_Ref => Node_Access, Nil => null);\n+            use Descriptors;\n+\n+            function Next (N : Node_Access) return Node_Access is (N.Next);\n+            procedure Set_Next (N : Node_Access; Next : Node_Access)\n+              with Inline;\n+            procedure Set_Prev (N : Node_Access; Prev : Node_Access)\n+              with Inline;\n+            function \"<\" (L, R : Node_Access) return Boolean is\n+              (L.Element < R.Element);\n+            procedure Update_Container (List : List_Descriptor) with Inline;\n+\n+            procedure Set_Next (N : Node_Access; Next : Node_Access) is\n+            begin\n+               N.Next := Next;\n+            end Set_Next;\n \n-            Unsorted : constant List_Descriptor :=\n-                                  (First  => Container.First,\n-                                   Last   => Container.Last,\n-                                   Length => Container.Length);\n+            procedure Set_Prev (N : Node_Access; Prev : Node_Access) is\n+            begin\n+               N.Prev := Prev;\n+            end Set_Prev;\n+\n+            procedure Update_Container (List : List_Descriptor) is\n+            begin\n+               Container.First  := List.First;\n+               Container.Last   := List.Last;\n+               Container.Length := List.Length;\n+            end Update_Container;\n \n-            Sorted   : List_Descriptor;\n+            procedure Sort_List is new Doubly_Linked_List_Sort;\n          begin\n-            --  If a call to the formal < operator references the container\n-            --  during sorting, seeing an empty container seems preferable\n-            --  to seeing an internally inconsistent container.\n-            --\n-            Container.First  := null;\n-            Container.Last   := null;\n-            Container.Length := 0;\n-\n-            Sorted := Merge_Sort (Unsorted);\n-\n-            Container.First  := Sorted.First;\n-            Container.Last   := Sorted.Last;\n-            Container.Length := Sorted.Length;\n+            Sort_List (List_Descriptor'(First  => Container.First,\n+                                        Last   => Container.Last,\n+                                        Length => Container.Length));\n          end;\n \n          pragma Assert (Container.First.Prev = null);"}, {"sha": "c9897c761774bbd8f6a1799750a878f3314216cc", "filename": "gcc/ada/libgnat/a-cfdlli.adb", "status": "modified", "additions": 40, "deletions": 72, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3598c8db4045d17705f845561517f74bf877a2e4/gcc%2Fada%2Flibgnat%2Fa-cfdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3598c8db4045d17705f845561517f74bf877a2e4/gcc%2Fada%2Flibgnat%2Fa-cfdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfdlli.adb?ref=3598c8db4045d17705f845561517f74bf877a2e4", "patch": "@@ -25,6 +25,8 @@\n -- <http://www.gnu.org/licenses/>.                                          --\n ------------------------------------------------------------------------------\n \n+with Ada.Containers.Stable_Sorting; use Ada.Containers.Stable_Sorting;\n+\n with System; use type System.Address;\n \n package body Ada.Containers.Formal_Doubly_Linked_Lists with\n@@ -976,77 +978,6 @@ is\n \n       procedure Sort (Container : in out List) is\n          N : Node_Array renames Container.Nodes;\n-\n-         procedure Partition (Pivot : Count_Type; Back : Count_Type);\n-         procedure Sort (Front : Count_Type; Back : Count_Type);\n-\n-         ---------------\n-         -- Partition --\n-         ---------------\n-\n-         procedure Partition (Pivot : Count_Type; Back : Count_Type) is\n-            Node : Count_Type;\n-\n-         begin\n-            Node := N (Pivot).Next;\n-            while Node /= Back loop\n-               if N (Node).Element < N (Pivot).Element then\n-                  declare\n-                     Prev : constant Count_Type := N (Node).Prev;\n-                     Next : constant Count_Type := N (Node).Next;\n-\n-                  begin\n-                     N (Prev).Next := Next;\n-\n-                     if Next = 0 then\n-                        Container.Last := Prev;\n-                     else\n-                        N (Next).Prev := Prev;\n-                     end if;\n-\n-                     N (Node).Next := Pivot;\n-                     N (Node).Prev := N (Pivot).Prev;\n-\n-                     N (Pivot).Prev := Node;\n-\n-                     if N (Node).Prev = 0 then\n-                        Container.First := Node;\n-                     else\n-                        N (N (Node).Prev).Next := Node;\n-                     end if;\n-\n-                     Node := Next;\n-                  end;\n-\n-               else\n-                  Node := N (Node).Next;\n-               end if;\n-            end loop;\n-         end Partition;\n-\n-         ----------\n-         -- Sort --\n-         ----------\n-\n-         procedure Sort (Front : Count_Type; Back : Count_Type) is\n-            Pivot : Count_Type;\n-\n-         begin\n-            if Front = 0 then\n-               Pivot := Container.First;\n-            else\n-               Pivot := N (Front).Next;\n-            end if;\n-\n-            if Pivot /= Back then\n-               Partition (Pivot, Back);\n-               Sort (Front, Pivot);\n-               Sort (Pivot, Back);\n-            end if;\n-         end Sort;\n-\n-      --  Start of processing for Sort\n-\n       begin\n          if Container.Length <= 1 then\n             return;\n@@ -1055,7 +986,44 @@ is\n          pragma Assert (N (Container.First).Prev = 0);\n          pragma Assert (N (Container.Last).Next = 0);\n \n-         Sort (Front => 0, Back => 0);\n+         declare\n+            package Descriptors is new List_Descriptors\n+              (Node_Ref => Count_Type, Nil => 0);\n+            use Descriptors;\n+\n+            function Next (Idx : Count_Type) return Count_Type is\n+              (N (Idx).Next);\n+            procedure Set_Next (Idx : Count_Type; Next : Count_Type)\n+              with Inline;\n+            procedure Set_Prev (Idx : Count_Type; Prev : Count_Type)\n+              with Inline;\n+            function \"<\" (L, R : Count_Type) return Boolean is\n+              (N (L).Element < N (R).Element);\n+            procedure Update_Container (List : List_Descriptor) with Inline;\n+\n+            procedure Set_Next (Idx : Count_Type; Next : Count_Type) is\n+            begin\n+               N (Idx).Next := Next;\n+            end Set_Next;\n+\n+            procedure Set_Prev (Idx : Count_Type; Prev : Count_Type) is\n+            begin\n+               N (Idx).Prev := Prev;\n+            end Set_Prev;\n+\n+            procedure Update_Container (List : List_Descriptor) is\n+            begin\n+               Container.First  := List.First;\n+               Container.Last   := List.Last;\n+               Container.Length := List.Length;\n+            end Update_Container;\n+\n+            procedure Sort_List is new Doubly_Linked_List_Sort;\n+         begin\n+            Sort_List (List_Descriptor'(First  => Container.First,\n+                                        Last   => Container.Last,\n+                                        Length => Container.Length));\n+         end;\n \n          pragma Assert (N (Container.First).Prev = 0);\n          pragma Assert (N (Container.Last).Next = 0);"}, {"sha": "590643e7af08ca42a36abd90cc8cb111eb7b962d", "filename": "gcc/ada/libgnat/a-cfdlli.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3598c8db4045d17705f845561517f74bf877a2e4/gcc%2Fada%2Flibgnat%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3598c8db4045d17705f845561517f74bf877a2e4/gcc%2Fada%2Flibgnat%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfdlli.ads?ref=3598c8db4045d17705f845561517f74bf877a2e4", "patch": "@@ -1596,8 +1596,7 @@ is\n              M_Elements_Sorted'Result =\n                (for all I in 1 .. M.Length (Container) =>\n                  (for all J in I .. M.Length (Container) =>\n-                   Element (Container, I) = Element (Container, J)\n-                     or Element (Container, I) < Element (Container, J)));\n+                   not (Element (Container, J) < Element (Container, I))));\n          pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Sorted);\n \n       end Formal_Model;"}, {"sha": "1cf94013c542d957b705e645acbfd74fd135b3be", "filename": "gcc/ada/libgnat/a-cidlli.adb", "status": "modified", "additions": 37, "deletions": 68, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3598c8db4045d17705f845561517f74bf877a2e4/gcc%2Fada%2Flibgnat%2Fa-cidlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3598c8db4045d17705f845561517f74bf877a2e4/gcc%2Fada%2Flibgnat%2Fa-cidlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cidlli.adb?ref=3598c8db4045d17705f845561517f74bf877a2e4", "patch": "@@ -29,6 +29,8 @@\n \n with Ada.Unchecked_Deallocation;\n \n+with Ada.Containers.Stable_Sorting; use Ada.Containers.Stable_Sorting;\n+\n with System; use type System.Address;\n with System.Put_Images;\n \n@@ -731,73 +733,6 @@ is\n       ----------\n \n       procedure Sort (Container : in out List) is\n-         procedure Partition (Pivot : Node_Access; Back  : Node_Access);\n-         --  Comment ???\n-\n-         procedure Sort (Front, Back : Node_Access);\n-         --  Comment??? Confusing name??? change name???\n-\n-         ---------------\n-         -- Partition --\n-         ---------------\n-\n-         procedure Partition (Pivot : Node_Access; Back : Node_Access) is\n-            Node : Node_Access;\n-\n-         begin\n-            Node := Pivot.Next;\n-            while Node /= Back loop\n-               if Node.Element.all < Pivot.Element.all then\n-                  declare\n-                     Prev : constant Node_Access := Node.Prev;\n-                     Next : constant Node_Access := Node.Next;\n-\n-                  begin\n-                     Prev.Next := Next;\n-\n-                     if Next = null then\n-                        Container.Last := Prev;\n-                     else\n-                        Next.Prev := Prev;\n-                     end if;\n-\n-                     Node.Next := Pivot;\n-                     Node.Prev := Pivot.Prev;\n-\n-                     Pivot.Prev := Node;\n-\n-                     if Node.Prev = null then\n-                        Container.First := Node;\n-                     else\n-                        Node.Prev.Next := Node;\n-                     end if;\n-\n-                     Node := Next;\n-                  end;\n-\n-               else\n-                  Node := Node.Next;\n-               end if;\n-            end loop;\n-         end Partition;\n-\n-         ----------\n-         -- Sort --\n-         ----------\n-\n-         procedure Sort (Front, Back : Node_Access) is\n-            Pivot : constant Node_Access :=\n-              (if Front = null then Container.First else Front.Next);\n-         begin\n-            if Pivot /= Back then\n-               Partition (Pivot, Back);\n-               Sort (Front, Pivot);\n-               Sort (Pivot, Back);\n-            end if;\n-         end Sort;\n-\n-      --  Start of processing for Sort\n-\n       begin\n          if Container.Length <= 1 then\n             return;\n@@ -813,8 +748,42 @@ is\n \n          declare\n             Lock : With_Lock (Container.TC'Unchecked_Access);\n+\n+            package Descriptors is new List_Descriptors\n+              (Node_Ref => Node_Access, Nil => null);\n+            use Descriptors;\n+\n+            function Next (N : Node_Access) return Node_Access is (N.Next);\n+            procedure Set_Next (N : Node_Access; Next : Node_Access)\n+              with Inline;\n+            procedure Set_Prev (N : Node_Access; Prev : Node_Access)\n+              with Inline;\n+            function \"<\" (L, R : Node_Access) return Boolean is\n+              (L.Element.all < R.Element.all);\n+            procedure Update_Container (List : List_Descriptor) with Inline;\n+\n+            procedure Set_Next (N : Node_Access; Next : Node_Access) is\n+            begin\n+               N.Next := Next;\n+            end Set_Next;\n+\n+            procedure Set_Prev (N : Node_Access; Prev : Node_Access) is\n+            begin\n+               N.Prev := Prev;\n+            end Set_Prev;\n+\n+            procedure Update_Container (List : List_Descriptor) is\n+            begin\n+               Container.First  := List.First;\n+               Container.Last   := List.Last;\n+               Container.Length := List.Length;\n+            end Update_Container;\n+\n+            procedure Sort_List is new Doubly_Linked_List_Sort;\n          begin\n-            Sort (Front => null, Back => null);\n+            Sort_List (List_Descriptor'(First  => Container.First,\n+                                        Last   => Container.Last,\n+                                        Length => Container.Length));\n          end;\n \n          pragma Assert (Container.First.Prev = null);"}, {"sha": "e14ecbbae4d00c70dcafac146ec7d26c5a5af0ea", "filename": "gcc/ada/libgnat/a-costso.adb", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3598c8db4045d17705f845561517f74bf877a2e4/gcc%2Fada%2Flibgnat%2Fa-costso.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3598c8db4045d17705f845561517f74bf877a2e4/gcc%2Fada%2Flibgnat%2Fa-costso.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-costso.adb?ref=3598c8db4045d17705f845561517f74bf877a2e4", "patch": "@@ -0,0 +1,191 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                         --\n+--                                                                          --\n+--         A D A . C O N T A I N E R S . S T A B L E _ S O R T I N G        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                     Copyright (C) 1995-2021, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body Ada.Containers.Stable_Sorting is\n+   package body List_Descriptors is\n+      procedure Doubly_Linked_List_Sort (List : List_Descriptor) is\n+\n+         Empty  : constant List_Descriptor := (Nil, Nil, 0);\n+\n+         function Merge_Sort (Arg : List_Descriptor) return List_Descriptor;\n+         --  Sort list of given length using MergeSort; length must be >= 2.\n+         --  As required by RM, the sort is stable.\n+\n+         ----------------\n+         -- Merge_Sort --\n+         ----------------\n+\n+         function Merge_Sort (Arg : List_Descriptor) return List_Descriptor\n+         is\n+            procedure Split_List\n+              (Unsplit : List_Descriptor; Part1, Part2 : out List_Descriptor);\n+            --  Split list into two parts for divide-and-conquer.\n+            --  Unsplit.Length must be >= 2.\n+\n+            function Merge_Parts\n+              (Part1, Part2 : List_Descriptor) return List_Descriptor;\n+            --  Merge two sorted lists, preserving sorted property.\n+\n+            ----------------\n+            -- Split_List --\n+            ----------------\n+\n+            procedure Split_List\n+              (Unsplit : List_Descriptor; Part1, Part2 : out List_Descriptor)\n+            is\n+               Rover : Node_Ref := Unsplit.First;\n+               Bump_Count : constant Count_Type := (Unsplit.Length - 1) / 2;\n+            begin\n+               for Iter in 1 .. Bump_Count loop\n+                  Rover := Next (Rover);\n+               end loop;\n+\n+               Part1 := (First  => Unsplit.First,\n+                         Last   => Rover,\n+                         Length => Bump_Count + 1);\n+\n+               Part2 := (First => Next (Rover),\n+                         Last  => Unsplit.Last,\n+                         Length => Unsplit.Length - Part1.Length);\n+\n+               --  Detach\n+               Set_Next (Part1.Last, Nil);\n+               Set_Prev (Part2.First, Nil);\n+            end Split_List;\n+\n+            -----------------\n+            -- Merge_Parts --\n+            -----------------\n+\n+            function Merge_Parts\n+              (Part1, Part2 : List_Descriptor) return List_Descriptor\n+            is\n+               procedure Detach_First (Source   : in out List_Descriptor;\n+                                       Detached : out Node_Ref);\n+               --  Detach the first element from a non-empty list and\n+               --  return the detached node via the Detached parameter.\n+\n+               ------------------\n+               -- Detach_First --\n+               ------------------\n+\n+               procedure Detach_First (Source   : in out List_Descriptor;\n+                                       Detached : out Node_Ref) is\n+               begin\n+                  Detached := Source.First;\n+\n+                  if Source.Length = 1 then\n+                     Source := Empty;\n+                  else\n+                     Source := (Next (Source.First),\n+                                Source.Last,\n+                                Source.Length - 1);\n+\n+                     Set_Prev (Next (Detached), Nil);\n+                     Set_Next (Detached, Nil);\n+                  end if;\n+               end Detach_First;\n+\n+               P1     : List_Descriptor := Part1;\n+               P2     : List_Descriptor := Part2;\n+               Merged : List_Descriptor := Empty;\n+\n+               Take_From_P2 : Boolean;\n+               Detached     : Node_Ref;\n+\n+            --  Start of processing for Merge_Parts\n+\n+            begin\n+               while (P1.Length /= 0) or (P2.Length /= 0) loop\n+                  if P1.Length = 0 then\n+                     Take_From_P2 := True;\n+                  elsif P2.Length = 0 then\n+                     Take_From_P2 := False;\n+                  else\n+                     --  If the compared elements are equal then Take_From_P2\n+                     --  must be False in order to ensure stability.\n+\n+                     Take_From_P2 := P2.First < P1.First;\n+                  end if;\n+\n+                  if Take_From_P2 then\n+                     Detach_First (P2, Detached);\n+                  else\n+                     Detach_First (P1, Detached);\n+                  end if;\n+\n+                  if Merged.Length = 0 then\n+                     Merged := (First | Last => Detached, Length => 1);\n+                  else\n+                     Set_Prev (Detached, Merged.Last);\n+                     Set_Next (Merged.Last, Detached);\n+                     Merged.Last := Detached;\n+                     Merged.Length := Merged.Length + 1;\n+                  end if;\n+               end loop;\n+               return Merged;\n+            end Merge_Parts;\n+\n+         --  Start of processing for Merge_Sort\n+\n+         begin\n+            if Positive (Arg.Length) < 2 then\n+               --  already sorted\n+               return Arg;\n+            end if;\n+\n+            declare\n+               Part1, Part2 : List_Descriptor;\n+            begin\n+               Split_List (Unsplit => Arg, Part1 => Part1, Part2 => Part2);\n+\n+               Part1 := Merge_Sort (Part1);\n+               Part2 := Merge_Sort (Part2);\n+\n+               return Merge_Parts (Part1, Part2);\n+            end;\n+         end Merge_Sort;\n+\n+      --  Start of processing for Sort\n+\n+      begin\n+         if List.Length > 1 then\n+            --  If a call to the formal \"<\" op references the container\n+            --  during sorting, seeing an empty container seems preferable\n+            --  to seeing an internally inconsistent container.\n+            --\n+            Update_Container (Empty);\n+\n+            Update_Container (Merge_Sort (List));\n+         end if;\n+      end Doubly_Linked_List_Sort;\n+   end List_Descriptors;\n+end Ada.Containers.Stable_Sorting;"}, {"sha": "db0be24c5e3f5d893dce6c9a00e6d686ade6c602", "filename": "gcc/ada/libgnat/a-costso.ads", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3598c8db4045d17705f845561517f74bf877a2e4/gcc%2Fada%2Flibgnat%2Fa-costso.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3598c8db4045d17705f845561517f74bf877a2e4/gcc%2Fada%2Flibgnat%2Fa-costso.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-costso.ads?ref=3598c8db4045d17705f845561517f74bf877a2e4", "patch": "@@ -0,0 +1,71 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                         --\n+--                                                                          --\n+--         A D A . C O N T A I N E R S . S T A B L E _ S O R T I N G        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                     Copyright (C) 1995-2021, AdaCore                     --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Stable_Sorting package\n+\n+--  This package provides a generic stable sorting procedure that is\n+--  intended for use by the various doubly linked list container generics.\n+--  If a stable array sorting algorithm with better-than-quadratic worst\n+--  case execution time is ever needed, then it could also reside here.\n+\n+private package Ada.Containers.Stable_Sorting is\n+   pragma Annotate (CodePeer, Skip_Analysis);\n+   pragma Pure;\n+   pragma Remote_Types;\n+\n+   --  Stable sorting algorithms with N-log-N worst case execution time.\n+\n+   generic\n+      type Node_Ref is private; -- access value or array index\n+      Nil : Node_Ref;\n+   package List_Descriptors is\n+\n+      type List_Descriptor is\n+         record\n+            First, Last : Node_Ref := Nil;\n+            Length      : Count_Type := 0;\n+         end record;\n+\n+      --  We use a nested generic here so that the inner generic can\n+      --  refer to the List_Descriptor type.\n+\n+      generic\n+         with function Next (N : Node_Ref) return Node_Ref is <>;\n+         with procedure Set_Next (N : Node_Ref; Next : Node_Ref) is <>;\n+         with procedure Set_Prev (N : Node_Ref; Prev : Node_Ref) is <>;\n+         with function \"<\" (L, R : Node_Ref) return Boolean is <>;\n+\n+         with procedure Update_Container (List : List_Descriptor) is <>;\n+      procedure Doubly_Linked_List_Sort (List : List_Descriptor);\n+\n+   end List_Descriptors;\n+\n+end Ada.Containers.Stable_Sorting;"}, {"sha": "48cdb0c4c2ca11ee83fd45f26c6ebba92f442280", "filename": "gcc/ada/libgnat/a-crdlli.adb", "status": "modified", "additions": 40, "deletions": 68, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3598c8db4045d17705f845561517f74bf877a2e4/gcc%2Fada%2Flibgnat%2Fa-crdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3598c8db4045d17705f845561517f74bf877a2e4/gcc%2Fada%2Flibgnat%2Fa-crdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-crdlli.adb?ref=3598c8db4045d17705f845561517f74bf877a2e4", "patch": "@@ -27,6 +27,8 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n+with Ada.Containers.Stable_Sorting; use Ada.Containers.Stable_Sorting;\n+\n with System; use type System.Address;\n \n package body Ada.Containers.Restricted_Doubly_Linked_Lists is\n@@ -509,83 +511,53 @@ package body Ada.Containers.Restricted_Doubly_Linked_Lists is\n \n       procedure Sort (Container : in out List) is\n          N : Node_Array renames Container.Nodes;\n-\n-         procedure Partition (Pivot, Back : Count_Type);\n-         procedure Sort (Front, Back : Count_Type);\n-\n-         ---------------\n-         -- Partition --\n-         ---------------\n-\n-         procedure Partition (Pivot, Back : Count_Type) is\n-            Node : Count_Type := N (Pivot).Next;\n-\n-         begin\n-            while Node /= Back loop\n-               if N (Node).Element < N (Pivot).Element then\n-                  declare\n-                     Prev : constant Count_Type := N (Node).Prev;\n-                     Next : constant Count_Type := N (Node).Next;\n-\n-                  begin\n-                     N (Prev).Next := Next;\n-\n-                     if Next = 0 then\n-                        Container.Last := Prev;\n-                     else\n-                        N (Next).Prev := Prev;\n-                     end if;\n-\n-                     N (Node).Next := Pivot;\n-                     N (Node).Prev := N (Pivot).Prev;\n-\n-                     N (Pivot).Prev := Node;\n-\n-                     if N (Node).Prev = 0 then\n-                        Container.First := Node;\n-                     else\n-                        N (N (Node).Prev).Next := Node;\n-                     end if;\n-\n-                     Node := Next;\n-                  end;\n-\n-               else\n-                  Node := N (Node).Next;\n-               end if;\n-            end loop;\n-         end Partition;\n-\n-         ----------\n-         -- Sort --\n-         ----------\n-\n-         procedure Sort (Front, Back : Count_Type) is\n-            Pivot : constant Count_Type :=\n-              (if Front = 0 then Container.First else N (Front).Next);\n-         begin\n-            if Pivot /= Back then\n-               Partition (Pivot, Back);\n-               Sort (Front, Pivot);\n-               Sort (Pivot, Back);\n-            end if;\n-         end Sort;\n-\n-      --  Start of processing for Sort\n-\n       begin\n          if Container.Length <= 1 then\n             return;\n          end if;\n \n-         pragma Assert (N (Container.First).Prev = 0);\n-         pragma Assert (N (Container.Last).Next = 0);\n-\n --       if Container.Busy > 0 then\n --          raise Program_Error;\n --       end if;\n \n-         Sort (Front => 0, Back => 0);\n+         declare\n+            package Descriptors is new List_Descriptors\n+              (Node_Ref => Count_Type, Nil => 0);\n+            use Descriptors;\n+\n+            function Next (Idx : Count_Type) return Count_Type is\n+              (N (Idx).Next);\n+            procedure Set_Next (Idx : Count_Type; Next : Count_Type)\n+              with Inline;\n+            procedure Set_Prev (Idx : Count_Type; Prev : Count_Type)\n+              with Inline;\n+            function \"<\" (L, R : Count_Type) return Boolean is\n+              (N (L).Element < N (R).Element);\n+            procedure Update_Container (List : List_Descriptor) with Inline;\n+\n+            procedure Set_Next (Idx : Count_Type; Next : Count_Type) is\n+            begin\n+               N (Idx).Next := Next;\n+            end Set_Next;\n+\n+            procedure Set_Prev (Idx : Count_Type; Prev : Count_Type) is\n+            begin\n+               N (Idx).Prev := Prev;\n+            end Set_Prev;\n+\n+            procedure Update_Container (List : List_Descriptor) is\n+            begin\n+               Container.First  := List.First;\n+               Container.Last   := List.Last;\n+               Container.Length := List.Length;\n+            end Update_Container;\n+\n+            procedure Sort_List is new Doubly_Linked_List_Sort;\n+         begin\n+            Sort_List (List_Descriptor'(First  => Container.First,\n+                                        Last   => Container.Last,\n+                                        Length => Container.Length));\n+         end;\n \n          pragma Assert (N (Container.First).Prev = 0);\n          pragma Assert (N (Container.Last).Next = 0);"}]}