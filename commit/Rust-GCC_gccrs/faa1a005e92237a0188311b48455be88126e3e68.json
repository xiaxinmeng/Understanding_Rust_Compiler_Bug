{"sha": "faa1a005e92237a0188311b48455be88126e3e68", "node_id": "C_kwDOANBUbNoAKGZhYTFhMDA1ZTkyMjM3YTAxODgzMTFiNDg0NTViZTg4MTI2ZTNlNjg", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-10-29T16:38:29Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-11-01T13:12:47Z"}, "message": "Refactor ADTType to consist of multiple variants\n\nAlgebraic data types represent Structs, Tuple Structs, unit\nstructs and enums in rust. The key difference here is that\neach of these are an ADT with a single variant and enums\nare an ADT with multiple variants.\n\nIt adds indirection to where the fields of an ADT are\nmanaged.\n\nCo-authored-by: Mark Wielaard <mark@klomp.org>\n\nAddresses #79", "tree": {"sha": "40a10c0a05c8b3a10b8d52844cddca31bcf5069d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40a10c0a05c8b3a10b8d52844cddca31bcf5069d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/faa1a005e92237a0188311b48455be88126e3e68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faa1a005e92237a0188311b48455be88126e3e68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faa1a005e92237a0188311b48455be88126e3e68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faa1a005e92237a0188311b48455be88126e3e68/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82f3dd40d2dcc9eb2ea261e42bf7bb365faaf0a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82f3dd40d2dcc9eb2ea261e42bf7bb365faaf0a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82f3dd40d2dcc9eb2ea261e42bf7bb365faaf0a0"}], "stats": {"total": 636, "additions": 452, "deletions": 184}, "files": [{"sha": "551e0413007fd0b859d3361027a6ffca1a9fcaff", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=faa1a005e92237a0188311b48455be88126e3e68", "patch": "@@ -431,10 +431,15 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n     if (ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type))\n       return;\n \n+    // we dont support enums yet\n+    rust_assert (!type.is_enum ());\n+    rust_assert (type.number_of_variants () == 1);\n+\n+    TyTy::VariantDef &variant = *type.get_variants ().at (0);\n     std::vector<Backend::Btyped_identifier> fields;\n-    for (size_t i = 0; i < type.num_fields (); i++)\n+    for (size_t i = 0; i < variant.num_fields (); i++)\n       {\n-\tconst TyTy::StructFieldType *field = type.get_field (i);\n+\tconst TyTy::StructFieldType *field = variant.get_field_at_index (i);\n \tBtype *compiled_field_ty\n \t  = TyTyResolveCompile::compile (ctx, field->get_field_type ());\n "}, {"sha": "f43db501a56dace25892ef6ee74430334a0ee127", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=faa1a005e92237a0188311b48455be88126e3e68", "patch": "@@ -698,7 +698,13 @@ class CompileExpr : public HIRCompileBase\n     if (receiver->get_kind () == TyTy::TypeKind::ADT)\n       {\n \tTyTy::ADTType *adt = static_cast<TyTy::ADTType *> (receiver);\n-\tadt->get_field (expr.get_field_name (), &field_index);\n+\trust_assert (!adt->is_enum ());\n+\trust_assert (adt->number_of_variants () == 1);\n+\n+\tTyTy::VariantDef *variant = adt->get_variants ().at (0);\n+\tbool ok = variant->lookup_field (expr.get_field_name (), nullptr,\n+\t\t\t\t\t &field_index);\n+\trust_assert (ok);\n       }\n     else if (receiver->get_kind () == TyTy::TypeKind::REF)\n       {\n@@ -707,9 +713,15 @@ class CompileExpr : public HIRCompileBase\n \trust_assert (b->get_kind () == TyTy::TypeKind::ADT);\n \n \tTyTy::ADTType *adt = static_cast<TyTy::ADTType *> (b);\n-\tadt->get_field (expr.get_field_name (), &field_index);\n-\tBtype *adt_tyty = TyTyResolveCompile::compile (ctx, adt);\n+\trust_assert (!adt->is_enum ());\n+\trust_assert (adt->number_of_variants () == 1);\n \n+\tTyTy::VariantDef *variant = adt->get_variants ().at (0);\n+\tbool ok = variant->lookup_field (expr.get_field_name (), nullptr,\n+\t\t\t\t\t &field_index);\n+\trust_assert (ok);\n+\n+\tBtype *adt_tyty = TyTyResolveCompile::compile (ctx, adt);\n \tBexpression *indirect\n \t  = ctx->get_backend ()->indirect_expression (adt_tyty, receiver_ref,\n \t\t\t\t\t\t      true, expr.get_locus ());"}, {"sha": "a5d32b191d31b829c4c6502e5351738042df333d", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=faa1a005e92237a0188311b48455be88126e3e68", "patch": "@@ -73,6 +73,10 @@ CompileExpr::visit (HIR::CallExpr &expr)\n       TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (tyty);\n       Btype *compiled_adt_type = TyTyResolveCompile::compile (ctx, tyty);\n \n+      rust_assert (!adt->is_enum ());\n+      rust_assert (adt->number_of_variants () == 1);\n+      auto variant = adt->get_variants ().at (0);\n+\n       // this assumes all fields are in order from type resolution and if a\n       // base struct was specified those fields are filed via accesors\n       std::vector<Bexpression *> vals;\n@@ -83,7 +87,7 @@ CompileExpr::visit (HIR::CallExpr &expr)\n \n \t  // assignments are coercion sites so lets convert the rvalue if\n \t  // necessary\n-\t  auto respective_field = adt->get_field (i);\n+\t  auto respective_field = variant->get_field_at_index (i);\n \t  auto expected = respective_field->get_field_type ();\n \n \t  TyTy::BaseType *actual = nullptr;"}, {"sha": "c5a8d06a3da1c577d2aa7804068f1b1a672e4d9d", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=faa1a005e92237a0188311b48455be88126e3e68", "patch": "@@ -2005,14 +2005,7 @@ class Union : public VisItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n-  void iterate (std::function<bool (StructField &)> cb)\n-  {\n-    for (auto &variant : variants)\n-      {\n-\tif (!cb (variant))\n-\t  return;\n-      }\n-  }\n+  std::vector<StructField> &get_variants () { return variants; }\n \n   WhereClause &get_where_clause () { return where_clause; }\n "}, {"sha": "ef207bc9d68ccc7fa7a55da8af0f786e8490299d", "filename": "gcc/rust/lint/rust-lint-marklive.cc", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Flint%2Frust-lint-marklive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Flint%2Frust-lint-marklive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flint%2Frust-lint-marklive.cc?ref=faa1a005e92237a0188311b48455be88126e3e68", "patch": "@@ -228,11 +228,17 @@ MarkLive::visit (HIR::FieldAccessExpr &expr)\n     }\n \n   rust_assert (adt != nullptr);\n+  rust_assert (!adt->is_enum ());\n+  rust_assert (adt->number_of_variants () == 1);\n+\n+  TyTy::VariantDef *variant = adt->get_variants ().at (0);\n \n   // get the field index\n-  size_t index = 0;\n-  adt->get_field (expr.get_field_name (), &index);\n-  if (index >= adt->num_fields ())\n+  size_t index;\n+  TyTy::StructFieldType *field;\n+  bool ok = variant->lookup_field (expr.get_field_name (), &field, &index);\n+  rust_assert (ok);\n+  if (index >= variant->num_fields ())\n     {\n       rust_error_at (expr.get_receiver_expr ()->get_locus (),\n \t\t     \"cannot access struct %s by index: %ld\",\n@@ -241,7 +247,7 @@ MarkLive::visit (HIR::FieldAccessExpr &expr)\n     }\n \n   // get the field hir id\n-  HirId field_id = adt->get_field (index)->get_ref ();\n+  HirId field_id = field->get_ref ();\n   mark_hir_id (field_id);\n }\n "}, {"sha": "851407e04b3f82f423e2887794ec5b00e2fb1031", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=faa1a005e92237a0188311b48455be88126e3e68", "patch": "@@ -113,14 +113,18 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n \n     TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (resolved);\n+    rust_assert (!adt->is_enum ());\n+    rust_assert (adt->number_of_variants () == 1);\n+\n+    TyTy::VariantDef *variant = adt->get_variants ().at (0);\n     TupleIndex index = expr.get_tuple_index ();\n-    if ((size_t) index >= adt->num_fields ())\n+    if ((size_t) index >= variant->num_fields ())\n       {\n \trust_error_at (expr.get_locus (), \"unknown field at index %i\", index);\n \treturn;\n       }\n \n-    auto field_tyty = adt->get_field ((size_t) index);\n+    auto field_tyty = variant->get_field_at_index ((size_t) index);\n     if (field_tyty == nullptr)\n       {\n \trust_error_at (expr.get_locus (),\n@@ -984,16 +988,23 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n \n     TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (struct_base);\n-    auto resolved = adt->get_field (expr.get_field_name ());\n-    if (resolved == nullptr)\n+    rust_assert (!adt->is_enum ());\n+    rust_assert (adt->number_of_variants () == 1);\n+\n+    TyTy::VariantDef *vaiant = adt->get_variants ().at (0);\n+\n+    TyTy::StructFieldType *lookup = nullptr;\n+    bool found\n+      = vaiant->lookup_field (expr.get_field_name (), &lookup, nullptr);\n+    if (!found)\n       {\n \trust_error_at (expr.get_locus (), \"unknown field [%s] for type [%s]\",\n \t\t       expr.get_field_name ().c_str (),\n \t\t       adt->as_string ().c_str ());\n \treturn;\n       }\n \n-    infered = resolved->get_field_type ();\n+    infered = lookup->get_field_type ();\n   }\n \n   void visit (HIR::QualifiedPathInExpression &expr) override;"}, {"sha": "219596850d78d5b6658ff31e0ae5669b61382cd4", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=faa1a005e92237a0188311b48455be88126e3e68", "patch": "@@ -155,7 +155,6 @@ class TypeCheckStmt : public TypeCheckBase\n       }\n \n     std::vector<TyTy::StructFieldType *> fields;\n-\n     size_t idx = 0;\n     for (auto &field : struct_decl.get_fields ())\n       {\n@@ -170,12 +169,19 @@ class TypeCheckStmt : public TypeCheckBase\n \tidx++;\n       }\n \n+    // there is only a single variant\n+    std::vector<TyTy::VariantDef *> variants;\n+    variants.push_back (\n+      new TyTy::VariantDef (struct_decl.get_identifier (),\n+\t\t\t    TyTy::VariantDef::VariantType::TUPLE,\n+\t\t\t    std::move (fields)));\n+\n     TyTy::BaseType *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n \t\t\t   mappings->get_next_hir_id (),\n \t\t\t   struct_decl.get_identifier (),\n \t\t\t   TyTy::ADTType::ADTKind::TUPLE_STRUCT,\n-\t\t\t   std::move (fields), std::move (substitutions));\n+\t\t\t   std::move (variants), std::move (substitutions));\n \n     context->insert_type (struct_decl.get_mappings (), type);\n     infered = type;\n@@ -222,12 +228,19 @@ class TypeCheckStmt : public TypeCheckBase\n \t\t\t      ty_field->get_field_type ());\n       }\n \n+    // there is only a single variant\n+    std::vector<TyTy::VariantDef *> variants;\n+    variants.push_back (\n+      new TyTy::VariantDef (struct_decl.get_identifier (),\n+\t\t\t    TyTy::VariantDef::VariantType::STRUCT,\n+\t\t\t    std::move (fields)));\n+\n     TyTy::BaseType *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n \t\t\t   mappings->get_next_hir_id (),\n \t\t\t   struct_decl.get_identifier (),\n \t\t\t   TyTy::ADTType::ADTKind::STRUCT_STRUCT,\n-\t\t\t   std::move (fields), std::move (substitutions));\n+\t\t\t   std::move (variants), std::move (substitutions));\n \n     context->insert_type (struct_decl.get_mappings (), type);\n     infered = type;\n@@ -261,18 +274,25 @@ class TypeCheckStmt : public TypeCheckBase\n \t  }\n       }\n \n-    std::vector<TyTy::StructFieldType *> variants;\n-    union_decl.iterate ([&] (HIR::StructField &variant) mutable -> bool {\n-      TyTy::BaseType *variant_type\n-\t= TypeCheckType::Resolve (variant.get_field_type ().get ());\n-      TyTy::StructFieldType *ty_variant\n-\t= new TyTy::StructFieldType (variant.get_mappings ().get_hirid (),\n-\t\t\t\t     variant.get_field_name (), variant_type);\n-      variants.push_back (ty_variant);\n-      context->insert_type (variant.get_mappings (),\n-\t\t\t    ty_variant->get_field_type ());\n-      return true;\n-    });\n+    std::vector<TyTy::StructFieldType *> fields;\n+    for (auto &variant : union_decl.get_variants ())\n+      {\n+\tTyTy::BaseType *variant_type\n+\t  = TypeCheckType::Resolve (variant.get_field_type ().get ());\n+\tTyTy::StructFieldType *ty_variant\n+\t  = new TyTy::StructFieldType (variant.get_mappings ().get_hirid (),\n+\t\t\t\t       variant.get_field_name (), variant_type);\n+\tfields.push_back (ty_variant);\n+\tcontext->insert_type (variant.get_mappings (),\n+\t\t\t      ty_variant->get_field_type ());\n+      }\n+\n+    // there is only a single variant\n+    std::vector<TyTy::VariantDef *> variants;\n+    variants.push_back (\n+      new TyTy::VariantDef (union_decl.get_identifier (),\n+\t\t\t    TyTy::VariantDef::VariantType::STRUCT,\n+\t\t\t    std::move (fields)));\n \n     TyTy::BaseType *type\n       = new TyTy::ADTType (union_decl.get_mappings ().get_hirid (),"}, {"sha": "4dae9536c06c77a1a0d521f740ea5cfc8486c341", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=faa1a005e92237a0188311b48455be88126e3e68", "patch": "@@ -87,7 +87,6 @@ class TypeCheckTopLevel : public TypeCheckBase\n       }\n \n     std::vector<TyTy::StructFieldType *> fields;\n-\n     size_t idx = 0;\n     for (auto &field : struct_decl.get_fields ())\n       {\n@@ -102,12 +101,19 @@ class TypeCheckTopLevel : public TypeCheckBase\n \tidx++;\n       }\n \n+    // there is only a single variant\n+    std::vector<TyTy::VariantDef *> variants;\n+    variants.push_back (\n+      new TyTy::VariantDef (struct_decl.get_identifier (),\n+\t\t\t    TyTy::VariantDef::VariantType::TUPLE,\n+\t\t\t    std::move (fields)));\n+\n     TyTy::BaseType *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n \t\t\t   mappings->get_next_hir_id (),\n \t\t\t   struct_decl.get_identifier (),\n \t\t\t   TyTy::ADTType::ADTKind::TUPLE_STRUCT,\n-\t\t\t   std::move (fields), std::move (substitutions));\n+\t\t\t   std::move (variants), std::move (substitutions));\n \n     context->insert_type (struct_decl.get_mappings (), type);\n   }\n@@ -165,12 +171,19 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t\t\t      ty_field->get_field_type ());\n       }\n \n+    // there is only a single variant\n+    std::vector<TyTy::VariantDef *> variants;\n+    variants.push_back (\n+      new TyTy::VariantDef (struct_decl.get_identifier (),\n+\t\t\t    TyTy::VariantDef::VariantType::STRUCT,\n+\t\t\t    std::move (fields)));\n+\n     TyTy::BaseType *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n \t\t\t   mappings->get_next_hir_id (),\n \t\t\t   struct_decl.get_identifier (),\n \t\t\t   TyTy::ADTType::ADTKind::STRUCT_STRUCT,\n-\t\t\t   std::move (fields), std::move (substitutions));\n+\t\t\t   std::move (variants), std::move (substitutions));\n \n     context->insert_type (struct_decl.get_mappings (), type);\n   }\n@@ -208,18 +221,25 @@ class TypeCheckTopLevel : public TypeCheckBase\n \tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n       }\n \n-    std::vector<TyTy::StructFieldType *> variants;\n-    union_decl.iterate ([&] (HIR::StructField &variant) mutable -> bool {\n-      TyTy::BaseType *variant_type\n-\t= TypeCheckType::Resolve (variant.get_field_type ().get ());\n-      TyTy::StructFieldType *ty_variant\n-\t= new TyTy::StructFieldType (variant.get_mappings ().get_hirid (),\n-\t\t\t\t     variant.get_field_name (), variant_type);\n-      variants.push_back (ty_variant);\n-      context->insert_type (variant.get_mappings (),\n-\t\t\t    ty_variant->get_field_type ());\n-      return true;\n-    });\n+    std::vector<TyTy::StructFieldType *> fields;\n+    for (auto &variant : union_decl.get_variants ())\n+      {\n+\tTyTy::BaseType *variant_type\n+\t  = TypeCheckType::Resolve (variant.get_field_type ().get ());\n+\tTyTy::StructFieldType *ty_variant\n+\t  = new TyTy::StructFieldType (variant.get_mappings ().get_hirid (),\n+\t\t\t\t       variant.get_field_name (), variant_type);\n+\tfields.push_back (ty_variant);\n+\tcontext->insert_type (variant.get_mappings (),\n+\t\t\t      ty_variant->get_field_type ());\n+      }\n+\n+    // there is only a single variant\n+    std::vector<TyTy::VariantDef *> variants;\n+    variants.push_back (\n+      new TyTy::VariantDef (union_decl.get_identifier (),\n+\t\t\t    TyTy::VariantDef::VariantType::STRUCT,\n+\t\t\t    std::move (fields)));\n \n     TyTy::BaseType *type\n       = new TyTy::ADTType (union_decl.get_mappings ().get_hirid (),"}, {"sha": "339429fa2a0d7339db7a0173f5a94f687f4d6281", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=faa1a005e92237a0188311b48455be88126e3e68", "patch": "@@ -178,7 +178,11 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n     }\n \n   // check the arguments are all assigned and fix up the ordering\n-  if (fields_assigned.size () != struct_path_resolved->num_fields ())\n+  rust_assert (!struct_path_resolved->is_enum ());\n+  rust_assert (struct_path_resolved->number_of_variants () == 1);\n+  TyTy::VariantDef *variant = struct_path_resolved->get_variants ().at (0);\n+\n+  if (fields_assigned.size () != variant->num_fields ())\n     {\n       if (struct_def->is_union ())\n \t{\n@@ -201,7 +205,7 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n \t  // we have a struct base to assign the missing fields from.\n \t  // the missing fields can be implicit FieldAccessExprs for the value\n \t  std::set<std::string> missing_fields;\n-\t  for (auto &field : struct_path_resolved->get_fields ())\n+\t  for (auto &field : variant->get_fields ())\n \t    {\n \t      auto it = fields_assigned.find (field->get_name ());\n \t      if (it == fields_assigned.end ())\n@@ -235,7 +239,7 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n \t\tstruct_expr.struct_base->base_struct->get_locus ());\n \n \t      size_t field_index;\n-\t      bool ok = struct_path_resolved->get_field (missing, &field_index);\n+\t      bool ok = variant->lookup_field (missing, nullptr, &field_index);\n \t      rust_assert (ok);\n \n \t      adtFieldIndexToField[field_index] = implicit_field;\n@@ -291,10 +295,14 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifierValue &field)\n       return;\n     }\n \n+  rust_assert (!struct_path_resolved->is_enum ());\n+  rust_assert (struct_path_resolved->number_of_variants () == 1);\n+  TyTy::VariantDef *variant = struct_path_resolved->get_variants ().at (0);\n+\n   size_t field_index;\n-  TyTy::StructFieldType *field_type\n-    = struct_path_resolved->get_field (field.field_name, &field_index);\n-  if (field_type == nullptr)\n+  TyTy::StructFieldType *field_type;\n+  bool ok = variant->lookup_field (field.field_name, &field_type, &field_index);\n+  if (!ok)\n     {\n       rust_error_at (field.get_locus (), \"unknown field\");\n       return;\n@@ -320,11 +328,14 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIndexValue &field)\n       return;\n     }\n \n-  size_t field_index;\n+  rust_assert (!struct_path_resolved->is_enum ());\n+  rust_assert (struct_path_resolved->number_of_variants () == 1);\n+  TyTy::VariantDef *variant = struct_path_resolved->get_variants ().at (0);\n \n-  TyTy::StructFieldType *field_type\n-    = struct_path_resolved->get_field (field_name, &field_index);\n-  if (field_type == nullptr)\n+  size_t field_index;\n+  TyTy::StructFieldType *field_type;\n+  bool ok = variant->lookup_field (field_name, &field_type, &field_index);\n+  if (!ok)\n     {\n       rust_error_at (field.get_locus (), \"unknown field\");\n       return;\n@@ -349,10 +360,15 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifier &field)\n       return;\n     }\n \n+  rust_assert (!struct_path_resolved->is_enum ());\n+  rust_assert (struct_path_resolved->number_of_variants () == 1);\n+  TyTy::VariantDef *variant = struct_path_resolved->get_variants ().at (0);\n+\n   size_t field_index;\n-  TyTy::StructFieldType *field_type\n-    = struct_path_resolved->get_field (field.get_field_name (), &field_index);\n-  if (field_type == nullptr)\n+  TyTy::StructFieldType *field_type;\n+  bool ok = variant->lookup_field (field.get_field_name (), &field_type,\n+\t\t\t\t   &field_index);\n+  if (!ok)\n     {\n       rust_error_at (field.get_locus (), \"unknown field\");\n       return;"}, {"sha": "aaa589beda38df568d319d669fced3554d477ad8", "filename": "gcc/rust/typecheck/rust-tyty-cast.h", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cast.h?ref=faa1a005e92237a0188311b48455be88126e3e68", "patch": "@@ -993,29 +993,47 @@ class ADTCastRules : public BaseCastRules\n \n   void visit (ADTType &type) override\n   {\n+    if (base->get_adt_kind () != type.get_adt_kind ())\n+      {\n+\tBaseCastRules::visit (type);\n+\treturn;\n+      }\n+\n     if (base->get_identifier ().compare (type.get_identifier ()) != 0)\n       {\n \tBaseCastRules::visit (type);\n \treturn;\n       }\n \n-    if (base->num_fields () != type.num_fields ())\n+    if (base->number_of_variants () != type.number_of_variants ())\n       {\n \tBaseCastRules::visit (type);\n \treturn;\n       }\n \n-    for (size_t i = 0; i < type.num_fields (); ++i)\n+    for (size_t i = 0; i < type.number_of_variants (); ++i)\n       {\n-\tTyTy::StructFieldType *base_field = base->get_field (i);\n-\tTyTy::StructFieldType *other_field = type.get_field (i);\n+\tTyTy::VariantDef *a = base->get_variants ().at (i);\n+\tTyTy::VariantDef *b = type.get_variants ().at (i);\n \n-\tTyTy::BaseType *this_field_ty = base_field->get_field_type ();\n-\tTyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\tif (a->num_fields () != b->num_fields ())\n+\t  {\n+\t    BaseCastRules::visit (type);\n+\t    return;\n+\t  }\n \n-\tBaseType *unified_ty = this_field_ty->unify (other_field_ty);\n-\tif (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n-\t  return;\n+\tfor (size_t j = 0; j < a->num_fields (); j++)\n+\t  {\n+\t    TyTy::StructFieldType *base_field = a->get_field_at_index (i);\n+\t    TyTy::StructFieldType *other_field = b->get_field_at_index (i);\n+\n+\t    TyTy::BaseType *this_field_ty = base_field->get_field_type ();\n+\t    TyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\n+\t    BaseType *unified_ty = this_field_ty->unify (other_field_ty);\n+\t    if (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n+\t      return;\n+\t  }\n       }\n \n     resolved = type.clone ();"}, {"sha": "4ab3df20fdcb53f8e596ce39b3a80c9ebc252497", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=faa1a005e92237a0188311b48455be88126e3e68", "patch": "@@ -990,32 +990,50 @@ class ADTCmp : public BaseCmp\n \n   void visit (const ADTType &type) override\n   {\n-    if (base->get_identifier ().compare (type.get_identifier ()) != 0)\n+    if (base->get_adt_kind () != type.get_adt_kind ())\n       {\n \tBaseCmp::visit (type);\n \treturn;\n       }\n \n-    if (base->num_fields () != type.num_fields ())\n+    if (base->get_identifier ().compare (type.get_identifier ()) != 0)\n       {\n \tBaseCmp::visit (type);\n \treturn;\n       }\n \n-    for (size_t i = 0; i < type.num_fields (); ++i)\n+    if (base->number_of_variants () != type.number_of_variants ())\n       {\n-\tconst TyTy::StructFieldType *base_field = base->get_imm_field (i);\n-\tconst TyTy::StructFieldType *other_field = type.get_imm_field (i);\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n \n-\tTyTy::BaseType *this_field_ty = base_field->get_field_type ();\n-\tTyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+    for (size_t i = 0; i < type.number_of_variants (); ++i)\n+      {\n+\tTyTy::VariantDef *a = base->get_variants ().at (i);\n+\tTyTy::VariantDef *b = type.get_variants ().at (i);\n \n-\tif (!this_field_ty->can_eq (other_field_ty, emit_error_flag,\n-\t\t\t\t    autoderef_mode_flag))\n+\tif (a->num_fields () != b->num_fields ())\n \t  {\n \t    BaseCmp::visit (type);\n \t    return;\n \t  }\n+\n+\tfor (size_t j = 0; j < a->num_fields (); j++)\n+\t  {\n+\t    TyTy::StructFieldType *base_field = a->get_field_at_index (i);\n+\t    TyTy::StructFieldType *other_field = b->get_field_at_index (i);\n+\n+\t    TyTy::BaseType *this_field_ty = base_field->get_field_type ();\n+\t    TyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\n+\t    if (!this_field_ty->can_eq (other_field_ty, emit_error_flag,\n+\t\t\t\t\tautoderef_mode_flag))\n+\t      {\n+\t\tBaseCmp::visit (type);\n+\t\treturn;\n+\t      }\n+\t  }\n       }\n \n     ok = true;"}, {"sha": "6525da3d372c2b29a0363191509277bd401aeb5f", "filename": "gcc/rust/typecheck/rust-tyty-coercion.h", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h?ref=faa1a005e92237a0188311b48455be88126e3e68", "patch": "@@ -1000,29 +1000,47 @@ class ADTCoercionRules : public BaseCoercionRules\n \n   void visit (ADTType &type) override\n   {\n+    if (base->get_adt_kind () != type.get_adt_kind ())\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n     if (base->get_identifier ().compare (type.get_identifier ()) != 0)\n       {\n \tBaseCoercionRules::visit (type);\n \treturn;\n       }\n \n-    if (base->num_fields () != type.num_fields ())\n+    if (base->number_of_variants () != type.number_of_variants ())\n       {\n \tBaseCoercionRules::visit (type);\n \treturn;\n       }\n \n-    for (size_t i = 0; i < type.num_fields (); ++i)\n+    for (size_t i = 0; i < type.number_of_variants (); ++i)\n       {\n-\tTyTy::StructFieldType *base_field = base->get_field (i);\n-\tTyTy::StructFieldType *other_field = type.get_field (i);\n+\tTyTy::VariantDef *a = base->get_variants ().at (i);\n+\tTyTy::VariantDef *b = type.get_variants ().at (i);\n \n-\tTyTy::BaseType *this_field_ty = base_field->get_field_type ();\n-\tTyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\tif (a->num_fields () != b->num_fields ())\n+\t  {\n+\t    BaseCoercionRules::visit (type);\n+\t    return;\n+\t  }\n \n-\tBaseType *unified_ty = this_field_ty->unify (other_field_ty);\n-\tif (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n-\t  return;\n+\tfor (size_t j = 0; j < a->num_fields (); j++)\n+\t  {\n+\t    TyTy::StructFieldType *base_field = a->get_field_at_index (i);\n+\t    TyTy::StructFieldType *other_field = b->get_field_at_index (i);\n+\n+\t    TyTy::BaseType *this_field_ty = base_field->get_field_type ();\n+\t    TyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\n+\t    BaseType *unified_ty = this_field_ty->unify (other_field_ty);\n+\t    if (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n+\t      return;\n+\t  }\n       }\n \n     resolved = type.clone ();"}, {"sha": "db86de9fd6bfe047bb618d99e46c30b189916ea9", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=faa1a005e92237a0188311b48455be88126e3e68", "patch": "@@ -1016,29 +1016,47 @@ class ADTRules : public BaseRules\n \n   void visit (ADTType &type) override\n   {\n+    if (base->get_adt_kind () != type.get_adt_kind ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n     if (base->get_identifier ().compare (type.get_identifier ()) != 0)\n       {\n \tBaseRules::visit (type);\n \treturn;\n       }\n \n-    if (base->num_fields () != type.num_fields ())\n+    if (base->number_of_variants () != type.number_of_variants ())\n       {\n \tBaseRules::visit (type);\n \treturn;\n       }\n \n-    for (size_t i = 0; i < type.num_fields (); ++i)\n+    for (size_t i = 0; i < type.number_of_variants (); ++i)\n       {\n-\tTyTy::StructFieldType *base_field = base->get_field (i);\n-\tTyTy::StructFieldType *other_field = type.get_field (i);\n+\tTyTy::VariantDef *a = base->get_variants ().at (i);\n+\tTyTy::VariantDef *b = type.get_variants ().at (i);\n \n-\tTyTy::BaseType *this_field_ty = base_field->get_field_type ();\n-\tTyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\tif (a->num_fields () != b->num_fields ())\n+\t  {\n+\t    BaseRules::visit (type);\n+\t    return;\n+\t  }\n \n-\tBaseType *unified_ty = this_field_ty->unify (other_field_ty);\n-\tif (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n-\t  return;\n+\tfor (size_t j = 0; j < a->num_fields (); j++)\n+\t  {\n+\t    TyTy::StructFieldType *base_field = a->get_field_at_index (i);\n+\t    TyTy::StructFieldType *other_field = b->get_field_at_index (i);\n+\n+\t    TyTy::BaseType *this_field_ty = base_field->get_field_type ();\n+\t    TyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\n+\t    BaseType *unified_ty = this_field_ty->unify (other_field_ty);\n+\t    if (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n+\t      return;\n+\t  }\n       }\n \n     resolved = type.clone ();"}, {"sha": "9f345c3c2598ac949c8774adb7ef901abfec9ea7", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 34, "deletions": 40, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=faa1a005e92237a0188311b48455be88126e3e68", "patch": "@@ -590,35 +590,16 @@ ADTType::accept_vis (TyConstVisitor &vis) const\n std::string\n ADTType::as_string () const\n {\n-  if (num_fields () == 0)\n-    return identifier;\n-\n-  std::string fields_buffer;\n-  for (size_t i = 0; i < num_fields (); ++i)\n+  std::string variants_buffer;\n+  for (size_t i = 0; i < number_of_variants (); ++i)\n     {\n-      fields_buffer += get_field (i)->as_string ();\n-      if ((i + 1) < num_fields ())\n-\tfields_buffer += \", \";\n+      TyTy::VariantDef *variant = variants.at (i);\n+      variants_buffer += variant->as_string ();\n+      if ((i + 1) < number_of_variants ())\n+\tvariants_buffer += \", \";\n     }\n \n-  return identifier + subst_as_string () + \"{\" + fields_buffer + \"}\";\n-}\n-\n-const StructFieldType *\n-ADTType::get_field (size_t index) const\n-{\n-  return fields.at (index);\n-}\n-\n-const BaseType *\n-ADTType::get_field_type (size_t index) const\n-{\n-  const StructFieldType *ref = get_field (index);\n-  auto context = Resolver::TypeCheckContext::get ();\n-  BaseType *lookup = nullptr;\n-  bool ok = context->lookup_type (ref->get_field_type ()->get_ref (), &lookup);\n-  rust_assert (ok);\n-  return lookup;\n+  return identifier + subst_as_string () + \"{\" + variants_buffer + \"}\";\n }\n \n BaseType *\n@@ -657,7 +638,10 @@ ADTType::is_equal (const BaseType &other) const\n     return false;\n \n   auto other2 = static_cast<const ADTType &> (other);\n-  if (num_fields () != other2.num_fields ())\n+  if (get_adt_kind () != other2.get_adt_kind ())\n+    return false;\n+\n+  if (number_of_variants () != other2.number_of_variants ())\n     return false;\n \n   if (has_subsititions_defined () != other2.has_subsititions_defined ())\n@@ -683,9 +667,12 @@ ADTType::is_equal (const BaseType &other) const\n     }\n   else\n     {\n-      for (size_t i = 0; i < num_fields (); i++)\n+      for (size_t i = 0; i < number_of_variants (); i++)\n \t{\n-\t  if (!get_field (i)->is_equal (*other2.get_field (i)))\n+\t  const TyTy::VariantDef *a = get_variants ().at (i);\n+\t  const TyTy::VariantDef *b = other2.get_variants ().at (i);\n+\n+\t  if (!a->is_equal (*b))\n \t    return false;\n \t}\n     }\n@@ -696,12 +683,12 @@ ADTType::is_equal (const BaseType &other) const\n BaseType *\n ADTType::clone () const\n {\n-  std::vector<StructFieldType *> cloned_fields;\n-  for (auto &f : fields)\n-    cloned_fields.push_back ((StructFieldType *) f->clone ());\n+  std::vector<VariantDef *> cloned_variants;\n+  for (auto &variant : variants)\n+    cloned_variants.push_back (variant->clone ());\n \n   return new ADTType (get_ref (), get_ty_ref (), identifier, get_adt_kind (),\n-\t\t      cloned_fields, clone_substs (), used_arguments,\n+\t\t      cloned_variants, clone_substs (), used_arguments,\n \t\t      get_combined_refs ());\n }\n \n@@ -772,11 +759,14 @@ ADTType::handle_substitions (SubstitutionArgumentMappings subst_mappings)\n \tsub.fill_param_ty (*arg.get_tyty (), subst_mappings.get_locus ());\n     }\n \n-  for (auto &field : adt->fields)\n+  for (auto &variant : adt->get_variants ())\n     {\n-      bool ok = ::Rust::TyTy::handle_substitions (subst_mappings, field);\n-      if (!ok)\n-\treturn adt;\n+      for (auto &field : variant->get_fields ())\n+\t{\n+\t  bool ok = ::Rust::TyTy::handle_substitions (subst_mappings, field);\n+\t  if (!ok)\n+\t    return adt;\n+\t}\n     }\n \n   return adt;\n@@ -2556,18 +2546,22 @@ TypeCheckCallExpr::visit (ADTType &type)\n       return;\n     }\n \n-  if (call.num_params () != type.num_fields ())\n+  rust_assert (!type.is_enum ());\n+  rust_assert (type.number_of_variants () == 1);\n+  TyTy::VariantDef *variant = type.get_variants ().at (0);\n+\n+  if (call.num_params () != variant->num_fields ())\n     {\n       rust_error_at (call.get_locus (),\n \t\t     \"unexpected number of arguments %lu expected %lu\",\n-\t\t     call.num_params (), type.num_fields ());\n+\t\t     call.num_params (), variant->num_fields ());\n       return;\n     }\n \n   size_t i = 0;\n   for (auto &argument : call.get_arguments ())\n     {\n-      StructFieldType *field = type.get_field (i);\n+      StructFieldType *field = variant->get_field_at_index (i);\n       BaseType *field_tyty = field->get_field_type ();\n \n       BaseType *arg = Resolver::TypeCheckExpr::Resolve (argument.get (), false);"}, {"sha": "909f2109f072187ed4d11307d28c6a67d2b502d2", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 157, "deletions": 42, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/faa1a005e92237a0188311b48455be88126e3e68/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=faa1a005e92237a0188311b48455be88126e3e68", "patch": "@@ -1009,6 +1009,139 @@ class SubstitutionRef\n   SubstitutionArgumentMappings used_arguments;\n };\n \n+// https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.VariantDef.html\n+class VariantDef\n+{\n+public:\n+  enum VariantType\n+  {\n+    NUM,\n+    TUPLE,\n+    STRUCT\n+  };\n+\n+  VariantDef (std::string identifier, int discriminant)\n+    : identifier (identifier), discriminant (discriminant)\n+  {\n+    type = VariantType::NUM;\n+    fields = {};\n+  }\n+\n+  VariantDef (std::string identifier, VariantType type,\n+\t      std::vector<StructFieldType *> fields)\n+    : identifier (identifier), type (type), fields (fields)\n+  {\n+    discriminant = 0;\n+    rust_assert (type == VariantType::TUPLE || type == VariantType::STRUCT);\n+  }\n+\n+  VariantDef (std::string identifier, VariantType type, int discriminant,\n+\t      std::vector<StructFieldType *> fields)\n+    : identifier (identifier), type (type), discriminant (discriminant),\n+      fields (fields)\n+  {\n+    rust_assert ((type == VariantType::NUM && fields.empty ())\n+\t\t || (type == VariantType::TUPLE && discriminant == 0)\n+\t\t || (type == VariantType::STRUCT && discriminant == 0));\n+  }\n+\n+  VariantType get_variant_type () const { return type; }\n+\n+  std::string get_identifier () const { return identifier; }\n+  int get_discriminant () const { return discriminant; }\n+\n+  size_t num_fields () const { return fields.size (); }\n+  StructFieldType *get_field_at_index (size_t index)\n+  {\n+    // FIXME this is not safe\n+    return fields.at (index);\n+  }\n+\n+  std::vector<StructFieldType *> &get_fields ()\n+  {\n+    rust_assert (type != NUM);\n+    return fields;\n+  }\n+\n+  bool lookup_field (const std::string &lookup, StructFieldType **field_lookup,\n+\t\t     size_t *index) const\n+  {\n+    size_t i = 0;\n+    for (auto &field : fields)\n+      {\n+\tif (field->get_name ().compare (lookup) == 0)\n+\t  {\n+\t    if (index != nullptr)\n+\t      *index = i;\n+\n+\t    if (field_lookup != nullptr)\n+\t      *field_lookup = field;\n+\n+\t    return true;\n+\t  }\n+\ti++;\n+      }\n+    return false;\n+  }\n+\n+  std::string as_string () const\n+  {\n+    if (type == VariantType::NUM)\n+      return identifier + \" = \" + std::to_string (discriminant);\n+\n+    std::string buffer;\n+    for (size_t i = 0; i < fields.size (); ++i)\n+      {\n+\tbuffer += fields.at (i)->as_string ();\n+\tif ((i + 1) < fields.size ())\n+\t  buffer += \", \";\n+      }\n+\n+    if (type == VariantType::TUPLE)\n+      return identifier + \" (\" + buffer + \")\";\n+    else\n+      return identifier + \" {\" + buffer + \"}\";\n+  }\n+\n+  bool is_equal (const VariantDef &other) const\n+  {\n+    if (type != other.type)\n+      return false;\n+\n+    if (identifier.compare (other.identifier) != 0)\n+      return false;\n+\n+    if (discriminant != other.discriminant)\n+      return false;\n+\n+    if (fields.size () != other.fields.size ())\n+      return false;\n+\n+    for (size_t i = 0; i < fields.size (); i++)\n+      {\n+\tif (!fields.at (i)->is_equal (*other.fields.at (i)))\n+\t  return false;\n+      }\n+\n+    return true;\n+  }\n+\n+  VariantDef *clone () const\n+  {\n+    std::vector<StructFieldType *> cloned_fields;\n+    for (auto &f : fields)\n+      cloned_fields.push_back ((StructFieldType *) f->clone ());\n+\n+    return new VariantDef (identifier, type, discriminant, cloned_fields);\n+  }\n+\n+private:\n+  std::string identifier;\n+  VariantType type;\n+  int discriminant; /* Either discriminant or fields are valid.  */\n+  std::vector<StructFieldType *> fields;\n+};\n+\n class ADTType : public BaseType, public SubstitutionRef\n {\n public:\n@@ -1017,36 +1150,48 @@ class ADTType : public BaseType, public SubstitutionRef\n     STRUCT_STRUCT,\n     TUPLE_STRUCT,\n     UNION,\n-    // ENUM ?\n+    ENUM\n   };\n \n   ADTType (HirId ref, std::string identifier, ADTKind adt_kind,\n-\t   std::vector<StructFieldType *> fields,\n+\t   std::vector<VariantDef *> variants,\n \t   std::vector<SubstitutionParamMapping> subst_refs,\n \t   SubstitutionArgumentMappings generic_arguments\n \t   = SubstitutionArgumentMappings::error (),\n \t   std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ref, TypeKind::ADT, refs),\n       SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n-      identifier (identifier), fields (fields), adt_kind (adt_kind)\n+      identifier (identifier), variants (variants), adt_kind (adt_kind)\n   {}\n \n   ADTType (HirId ref, HirId ty_ref, std::string identifier, ADTKind adt_kind,\n-\t   std::vector<StructFieldType *> fields,\n+\t   std::vector<VariantDef *> variants,\n \t   std::vector<SubstitutionParamMapping> subst_refs,\n \t   SubstitutionArgumentMappings generic_arguments\n \t   = SubstitutionArgumentMappings::error (),\n \t   std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ty_ref, TypeKind::ADT, refs),\n       SubstitutionRef (std::move (subst_refs), std::move (generic_arguments)),\n-      identifier (identifier), fields (fields), adt_kind (adt_kind)\n+      identifier (identifier), variants (variants), adt_kind (adt_kind)\n   {}\n \n   ADTKind get_adt_kind () const { return adt_kind; }\n+\n+  bool is_struct_struct () const { return adt_kind == STRUCT_STRUCT; }\n   bool is_tuple_struct () const { return adt_kind == TUPLE_STRUCT; }\n   bool is_union () const { return adt_kind == UNION; }\n+  bool is_enum () const { return adt_kind == ENUM; }\n \n-  bool is_unit () const override { return this->fields.empty (); }\n+  bool is_unit () const override\n+  {\n+    if (number_of_variants () == 0)\n+      return true;\n+\n+    if (number_of_variants () == 1)\n+      return variants.at (0)->num_fields () == 0;\n+\n+    return false;\n+  }\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n@@ -1061,50 +1206,15 @@ class ADTType : public BaseType, public SubstitutionRef\n \n   bool is_equal (const BaseType &other) const override;\n \n-  size_t num_fields () const { return fields.size (); }\n-\n   std::string get_identifier () const { return identifier; }\n \n   std::string get_name () const override final\n   {\n     return identifier + subst_as_string ();\n   }\n \n-  BaseType *get_field_type (size_t index);\n-\n-  const BaseType *get_field_type (size_t index) const;\n-\n-  const StructFieldType *get_field (size_t index) const;\n-\n-  StructFieldType *get_field (size_t index) { return fields.at (index); }\n-\n-  const StructFieldType *get_imm_field (size_t index) const\n-  {\n-    return fields.at (index);\n-  }\n-\n-  StructFieldType *get_field (const std::string &lookup,\n-\t\t\t      size_t *index = nullptr) const\n-  {\n-    size_t i = 0;\n-    for (auto &field : fields)\n-      {\n-\tif (field->get_name ().compare (lookup) == 0)\n-\t  {\n-\t    if (index != nullptr)\n-\t      *index = i;\n-\t    return field;\n-\t  }\n-\ti++;\n-      }\n-    return nullptr;\n-  }\n-\n   BaseType *clone () const final override;\n \n-  std::vector<StructFieldType *> &get_fields () { return fields; }\n-  const std::vector<StructFieldType *> &get_fields () const { return fields; }\n-\n   bool needs_generic_substitutions () const override final\n   {\n     return needs_substitution ();\n@@ -1117,12 +1227,17 @@ class ADTType : public BaseType, public SubstitutionRef\n     return has_substitutions ();\n   }\n \n+  size_t number_of_variants () const { return variants.size (); }\n+\n+  std::vector<VariantDef *> &get_variants () { return variants; }\n+  const std::vector<VariantDef *> &get_variants () const { return variants; }\n+\n   ADTType *\n   handle_substitions (SubstitutionArgumentMappings mappings) override final;\n \n private:\n   std::string identifier;\n-  std::vector<StructFieldType *> fields;\n+  std::vector<VariantDef *> variants;\n   ADTType::ADTKind adt_kind;\n };\n "}]}