{"sha": "598848e4d62700217e10f5d30c12fec4aa4d6edb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk4ODQ4ZTRkNjI3MDAyMTdlMTBmNWQzMGMxMmZlYzRhYTRkNmVkYg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2008-03-25T00:54:53Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2008-03-25T00:54:53Z"}, "message": "sha1.h: New file, from gnulib.\n\ninclude/:\n\t* sha1.h: New file, from gnulib.\nlibiberty/:\n\t* sha1.c: New file, from gnulib.\n\t* Makefile.in: Rebuild dependencies.\n\t(CFILES): Add sha1.c.\n\t(REQUIRED_OFILES): Add sha1.o.\n\nFrom-SVN: r133503", "tree": {"sha": "32635e2ba714a77df03638f051b1981d3d93da8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32635e2ba714a77df03638f051b1981d3d93da8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/598848e4d62700217e10f5d30c12fec4aa4d6edb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/598848e4d62700217e10f5d30c12fec4aa4d6edb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/598848e4d62700217e10f5d30c12fec4aa4d6edb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/598848e4d62700217e10f5d30c12fec4aa4d6edb/comments", "author": null, "committer": null, "parents": [{"sha": "8e291ddfb2b1e16d6c0355b2f92c6ac7d2241a06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e291ddfb2b1e16d6c0355b2f92c6ac7d2241a06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e291ddfb2b1e16d6c0355b2f92c6ac7d2241a06"}], "stats": {"total": 584, "additions": 579, "deletions": 5}, "files": [{"sha": "2ace7e097eaa62d17081fff4167bbcaefa39a087", "filename": "include/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598848e4d62700217e10f5d30c12fec4aa4d6edb/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598848e4d62700217e10f5d30c12fec4aa4d6edb/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=598848e4d62700217e10f5d30c12fec4aa4d6edb", "patch": "@@ -1,5 +1,7 @@\n 2008-03-24  Ian Lance Taylor  <iant@google.com>\n \n+\t* sha1.h: New file, from gnulib.\n+\n \t* md5.h: Add extern \"C\" when compiled with C++.\n \n 2008-03-21  Ian Lance Taylor  <iant@google.com>"}, {"sha": "0c2b76557e4be9b799382e3086aacc3c6663ad7c", "filename": "include/sha1.h", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598848e4d62700217e10f5d30c12fec4aa4d6edb/include%2Fsha1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598848e4d62700217e10f5d30c12fec4aa4d6edb/include%2Fsha1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fsha1.h?ref=598848e4d62700217e10f5d30c12fec4aa4d6edb", "patch": "@@ -0,0 +1,141 @@\n+/* Declarations of functions and data types used for SHA1 sum\n+   library functions.\n+   Copyright (C) 2000, 2001, 2003, 2005, 2006, 2008\n+   Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 2, or (at your option) any\n+   later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software Foundation,\n+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */\n+\n+#ifndef SHA1_H\n+# define SHA1_H 1\n+\n+#include <stdio.h>\n+\n+#if defined HAVE_LIMITS_H || _LIBC\n+# include <limits.h>\n+#endif\n+\n+#include \"ansidecl.h\"\n+\n+/* The following contortions are an attempt to use the C preprocessor\n+   to determine an unsigned integral type that is 32 bits wide.  An\n+   alternative approach is to use autoconf's AC_CHECK_SIZEOF macro, but\n+   doing that would require that the configure script compile and *run*\n+   the resulting executable.  Locally running cross-compiled executables\n+   is usually not possible.  */\n+\n+#ifdef _LIBC\n+# include <sys/types.h>\n+typedef u_int32_t sha1_uint32;\n+typedef uintptr_t sha1_uintptr;\n+#else\n+#  define INT_MAX_32_BITS 2147483647\n+\n+/* If UINT_MAX isn't defined, assume it's a 32-bit type.\n+   This should be valid for all systems GNU cares about because\n+   that doesn't include 16-bit systems, and only modern systems\n+   (that certainly have <limits.h>) have 64+-bit integral types.  */\n+\n+# ifndef INT_MAX\n+#  define INT_MAX INT_MAX_32_BITS\n+# endif\n+\n+# if INT_MAX == INT_MAX_32_BITS\n+   typedef unsigned int sha1_uint32;\n+# else\n+#  if SHRT_MAX == INT_MAX_32_BITS\n+    typedef unsigned short sha1_uint32;\n+#  else\n+#   if LONG_MAX == INT_MAX_32_BITS\n+     typedef unsigned long sha1_uint32;\n+#   else\n+     /* The following line is intended to evoke an error.\n+        Using #error is not portable enough.  */\n+     \"Cannot determine unsigned 32-bit data type.\"\n+#   endif\n+#  endif\n+# endif\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* Structure to save state of computation between the single steps.  */\n+struct sha1_ctx\n+{\n+  sha1_uint32 A;\n+  sha1_uint32 B;\n+  sha1_uint32 C;\n+  sha1_uint32 D;\n+  sha1_uint32 E;\n+\n+  sha1_uint32 total[2];\n+  sha1_uint32 buflen;\n+  sha1_uint32 buffer[32];\n+};\n+\n+\n+/* Initialize structure containing state of computation. */\n+extern void sha1_init_ctx (struct sha1_ctx *ctx);\n+\n+/* Starting with the result of former calls of this function (or the\n+   initialization function update the context for the next LEN bytes\n+   starting at BUFFER.\n+   It is necessary that LEN is a multiple of 64!!! */\n+extern void sha1_process_block (const void *buffer, size_t len,\n+\t\t\t\tstruct sha1_ctx *ctx);\n+\n+/* Starting with the result of former calls of this function (or the\n+   initialization function update the context for the next LEN bytes\n+   starting at BUFFER.\n+   It is NOT required that LEN is a multiple of 64.  */\n+extern void sha1_process_bytes (const void *buffer, size_t len,\n+\t\t\t\tstruct sha1_ctx *ctx);\n+\n+/* Process the remaining bytes in the buffer and put result from CTX\n+   in first 20 bytes following RESBUF.  The result is always in little\n+   endian byte order, so that a byte-wise output yields to the wanted\n+   ASCII representation of the message digest.\n+\n+   IMPORTANT: On some systems it is required that RESBUF be correctly\n+   aligned for a 32 bits value.  */\n+extern void *sha1_finish_ctx (struct sha1_ctx *ctx, void *resbuf);\n+\n+\n+/* Put result from CTX in first 20 bytes following RESBUF.  The result is\n+   always in little endian byte order, so that a byte-wise output yields\n+   to the wanted ASCII representation of the message digest.\n+\n+   IMPORTANT: On some systems it is required that RESBUF is correctly\n+   aligned for a 32 bits value.  */\n+extern void *sha1_read_ctx (const struct sha1_ctx *ctx, void *resbuf);\n+\n+\n+/* Compute SHA1 message digest for bytes read from STREAM.  The\n+   resulting message digest number will be written into the 20 bytes\n+   beginning at RESBLOCK.  */\n+extern int sha1_stream (FILE *stream, void *resblock);\n+\n+/* Compute SHA1 message digest for LEN bytes beginning at BUFFER.  The\n+   result is always in little endian byte order, so that a byte-wise\n+   output yields to the wanted ASCII representation of the message\n+   digest.  */\n+extern void *sha1_buffer (const char *buffer, size_t len, void *resblock);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif"}, {"sha": "04ca869264876641f32a146e1c33c90e774b38c7", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598848e4d62700217e10f5d30c12fec4aa4d6edb/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598848e4d62700217e10f5d30c12fec4aa4d6edb/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=598848e4d62700217e10f5d30c12fec4aa4d6edb", "patch": "@@ -1,3 +1,10 @@\n+2008-03-24  Ian Lance Taylor  <iant@google.com>\n+\n+\t* sha1.c: New file, from gnulib.\n+\t* Makefile.in: Rebuild dependencies.\n+\t(CFILES): Add sha1.c.\n+\t(REQUIRED_OFILES): Add sha1.o.\n+\n 2008-03-24  Doug Evans  <dje@google.com>\n \n \t* make-relative-prefix.c (make_relative_prefix_1): Handle NULL"}, {"sha": "bb3bd814a40ea82e98d2a5c568027d219a75ef0e", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598848e4d62700217e10f5d30c12fec4aa4d6edb/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598848e4d62700217e10f5d30c12fec4aa4d6edb/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=598848e4d62700217e10f5d30c12fec4aa4d6edb", "patch": "@@ -143,10 +143,11 @@ CFILES = alloca.c argv.c asprintf.c atexit.c\t\t\t\t\\\n \t pex-unix.c pex-win32.c\t\t\t\t\t\t\\\n          physmem.c putenv.c\t\t\t\t\t\t\\\n \trandom.c regex.c rename.c rindex.c\t\t\t\t\\\n-\tsafe-ctype.c setenv.c sigsetmask.c snprintf.c sort.c spaces.c\t\\\n-\t splay-tree.c stpcpy.c stpncpy.c strcasecmp.c strchr.c strdup.c\t\\\n-\t strerror.c strncasecmp.c strncmp.c strrchr.c strsignal.c\t\\\n-\t strstr.c strtod.c strtol.c strtoul.c strndup.c\tstrverscmp.c\t\\\n+\tsafe-ctype.c setenv.c sha1.c sigsetmask.c snprintf.c sort.c\t\\\n+\t spaces.c splay-tree.c stpcpy.c stpncpy.c strcasecmp.c\t\t\\\n+\t strchr.c strdup.c strerror.c strncasecmp.c strncmp.c\t\t\\\n+\t strrchr.c strsignal.c strstr.c strtod.c strtol.c strtoul.c\t\\\n+\t strndup.c strverscmp.c\t\t\t\t\t\t\\\n \ttmpnam.c\t\t\t\t\t\t\t\\\n \tunlink-if-ordinary.c\t\t\t\t\t\t\\\n \tvasprintf.c vfork.c vfprintf.c vprintf.c vsnprintf.c vsprintf.c\t\\\n@@ -156,7 +157,8 @@ CFILES = alloca.c argv.c asprintf.c atexit.c\t\t\t\t\\\n \n # These are always included in the library.  The first four are listed\n # first and by compile time to optimize parallel builds.\n-REQUIRED_OFILES = ./regex.o ./cplus-dem.o ./cp-demangle.o ./md5.o\t\\\n+REQUIRED_OFILES =\t\t\t\t\t\t\t\\\n+\t./regex.o ./cplus-dem.o ./cp-demangle.o ./md5.o ./sha1.o\t\\\n \t./alloca.o ./argv.o\t\t\t\t\t\t\\\n \t./choose-temp.o ./concat.o ./cp-demint.o\t\t\t\\\n \t./dyn-string.o\t\t\t\t\t\t\t\\\n@@ -944,6 +946,12 @@ $(CONFIGURED_OFILES): stamp-picdir\n \telse true; fi\n \t$(COMPILE.c) $(srcdir)/setenv.c $(OUTPUT_OPTION)\n \n+./sha1.o: $(srcdir)/sha1.c stamp-h $(INCDIR)/sha1.h\n+\tif [ x\"$(PICFLAG)\" != x ]; then \\\n+\t  $(COMPILE.c) $(PICFLAG) $(srcdir)/sha1.c -o pic/$@; \\\n+\telse true; fi\n+\t$(COMPILE.c) $(srcdir)/sha1.c $(OUTPUT_OPTION)\n+\n ./sigsetmask.o: $(srcdir)/sigsetmask.c $(INCDIR)/ansidecl.h\n \tif [ x\"$(PICFLAG)\" != x ]; then \\\n \t  $(COMPILE.c) $(PICFLAG) $(srcdir)/sigsetmask.c -o pic/$@; \\"}, {"sha": "6a25ab239925aa21ebbbd29708b00120b4b77849", "filename": "libiberty/sha1.c", "status": "added", "additions": 416, "deletions": 0, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/598848e4d62700217e10f5d30c12fec4aa4d6edb/libiberty%2Fsha1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/598848e4d62700217e10f5d30c12fec4aa4d6edb/libiberty%2Fsha1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsha1.c?ref=598848e4d62700217e10f5d30c12fec4aa4d6edb", "patch": "@@ -0,0 +1,416 @@\n+/* sha1.c - Functions to compute SHA1 message digest of files or\n+   memory blocks according to the NIST specification FIPS-180-1.\n+\n+   Copyright (C) 2000, 2001, 2003, 2004, 2005, 2006, 2008 Free Software\n+   Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 2, or (at your option) any\n+   later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software Foundation,\n+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */\n+\n+/* Written by Scott G. Miller\n+   Credits:\n+      Robert Klep <robert@ilse.nl>  -- Expansion function fix\n+*/\n+\n+#include <config.h>\n+\n+#include \"sha1.h\"\n+\n+#include <stddef.h>\n+#include <string.h>\n+\n+#if USE_UNLOCKED_IO\n+# include \"unlocked-io.h\"\n+#endif\n+\n+#ifdef WORDS_BIGENDIAN\n+# define SWAP(n) (n)\n+#else\n+# define SWAP(n) \\\n+    (((n) << 24) | (((n) & 0xff00) << 8) | (((n) >> 8) & 0xff00) | ((n) >> 24))\n+#endif\n+\n+#define BLOCKSIZE 4096\n+#if BLOCKSIZE % 64 != 0\n+# error \"invalid BLOCKSIZE\"\n+#endif\n+\n+/* This array contains the bytes used to pad the buffer to the next\n+   64-byte boundary.  (RFC 1321, 3.1: Step 1)  */\n+static const unsigned char fillbuf[64] = { 0x80, 0 /* , 0, 0, ...  */ };\n+\n+\n+/* Take a pointer to a 160 bit block of data (five 32 bit ints) and\n+   initialize it to the start constants of the SHA1 algorithm.  This\n+   must be called before using hash in the call to sha1_hash.  */\n+void\n+sha1_init_ctx (struct sha1_ctx *ctx)\n+{\n+  ctx->A = 0x67452301;\n+  ctx->B = 0xefcdab89;\n+  ctx->C = 0x98badcfe;\n+  ctx->D = 0x10325476;\n+  ctx->E = 0xc3d2e1f0;\n+\n+  ctx->total[0] = ctx->total[1] = 0;\n+  ctx->buflen = 0;\n+}\n+\n+/* Put result from CTX in first 20 bytes following RESBUF.  The result\n+   must be in little endian byte order.\n+\n+   IMPORTANT: On some systems it is required that RESBUF is correctly\n+   aligned for a 32-bit value.  */\n+void *\n+sha1_read_ctx (const struct sha1_ctx *ctx, void *resbuf)\n+{\n+  ((sha1_uint32 *) resbuf)[0] = SWAP (ctx->A);\n+  ((sha1_uint32 *) resbuf)[1] = SWAP (ctx->B);\n+  ((sha1_uint32 *) resbuf)[2] = SWAP (ctx->C);\n+  ((sha1_uint32 *) resbuf)[3] = SWAP (ctx->D);\n+  ((sha1_uint32 *) resbuf)[4] = SWAP (ctx->E);\n+\n+  return resbuf;\n+}\n+\n+/* Process the remaining bytes in the internal buffer and the usual\n+   prolog according to the standard and write the result to RESBUF.\n+\n+   IMPORTANT: On some systems it is required that RESBUF is correctly\n+   aligned for a 32-bit value.  */\n+void *\n+sha1_finish_ctx (struct sha1_ctx *ctx, void *resbuf)\n+{\n+  /* Take yet unprocessed bytes into account.  */\n+  sha1_uint32 bytes = ctx->buflen;\n+  size_t size = (bytes < 56) ? 64 / 4 : 64 * 2 / 4;\n+\n+  /* Now count remaining bytes.  */\n+  ctx->total[0] += bytes;\n+  if (ctx->total[0] < bytes)\n+    ++ctx->total[1];\n+\n+  /* Put the 64-bit file length in *bits* at the end of the buffer.  */\n+  ctx->buffer[size - 2] = SWAP ((ctx->total[1] << 3) | (ctx->total[0] >> 29));\n+  ctx->buffer[size - 1] = SWAP (ctx->total[0] << 3);\n+\n+  memcpy (&((char *) ctx->buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);\n+\n+  /* Process last bytes.  */\n+  sha1_process_block (ctx->buffer, size * 4, ctx);\n+\n+  return sha1_read_ctx (ctx, resbuf);\n+}\n+\n+/* Compute SHA1 message digest for bytes read from STREAM.  The\n+   resulting message digest number will be written into the 16 bytes\n+   beginning at RESBLOCK.  */\n+int\n+sha1_stream (FILE *stream, void *resblock)\n+{\n+  struct sha1_ctx ctx;\n+  char buffer[BLOCKSIZE + 72];\n+  size_t sum;\n+\n+  /* Initialize the computation context.  */\n+  sha1_init_ctx (&ctx);\n+\n+  /* Iterate over full file contents.  */\n+  while (1)\n+    {\n+      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the\n+\t computation function processes the whole buffer so that with the\n+\t next round of the loop another block can be read.  */\n+      size_t n;\n+      sum = 0;\n+\n+      /* Read block.  Take care for partial reads.  */\n+      while (1)\n+\t{\n+\t  n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);\n+\n+\t  sum += n;\n+\n+\t  if (sum == BLOCKSIZE)\n+\t    break;\n+\n+\t  if (n == 0)\n+\t    {\n+\t      /* Check for the error flag IFF N == 0, so that we don't\n+\t\t exit the loop after a partial read due to e.g., EAGAIN\n+\t\t or EWOULDBLOCK.  */\n+\t      if (ferror (stream))\n+\t\treturn 1;\n+\t      goto process_partial_block;\n+\t    }\n+\n+\t  /* We've read at least one byte, so ignore errors.  But always\n+\t     check for EOF, since feof may be true even though N > 0.\n+\t     Otherwise, we could end up calling fread after EOF.  */\n+\t  if (feof (stream))\n+\t    goto process_partial_block;\n+\t}\n+\n+      /* Process buffer with BLOCKSIZE bytes.  Note that\n+\t\t\tBLOCKSIZE % 64 == 0\n+       */\n+      sha1_process_block (buffer, BLOCKSIZE, &ctx);\n+    }\n+\n+ process_partial_block:;\n+\n+  /* Process any remaining bytes.  */\n+  if (sum > 0)\n+    sha1_process_bytes (buffer, sum, &ctx);\n+\n+  /* Construct result in desired memory.  */\n+  sha1_finish_ctx (&ctx, resblock);\n+  return 0;\n+}\n+\n+/* Compute SHA1 message digest for LEN bytes beginning at BUFFER.  The\n+   result is always in little endian byte order, so that a byte-wise\n+   output yields to the wanted ASCII representation of the message\n+   digest.  */\n+void *\n+sha1_buffer (const char *buffer, size_t len, void *resblock)\n+{\n+  struct sha1_ctx ctx;\n+\n+  /* Initialize the computation context.  */\n+  sha1_init_ctx (&ctx);\n+\n+  /* Process whole buffer but last len % 64 bytes.  */\n+  sha1_process_bytes (buffer, len, &ctx);\n+\n+  /* Put result in desired memory area.  */\n+  return sha1_finish_ctx (&ctx, resblock);\n+}\n+\n+void\n+sha1_process_bytes (const void *buffer, size_t len, struct sha1_ctx *ctx)\n+{\n+  /* When we already have some bits in our internal buffer concatenate\n+     both inputs first.  */\n+  if (ctx->buflen != 0)\n+    {\n+      size_t left_over = ctx->buflen;\n+      size_t add = 128 - left_over > len ? len : 128 - left_over;\n+\n+      memcpy (&((char *) ctx->buffer)[left_over], buffer, add);\n+      ctx->buflen += add;\n+\n+      if (ctx->buflen > 64)\n+\t{\n+\t  sha1_process_block (ctx->buffer, ctx->buflen & ~63, ctx);\n+\n+\t  ctx->buflen &= 63;\n+\t  /* The regions in the following copy operation cannot overlap.  */\n+\t  memcpy (ctx->buffer,\n+\t\t  &((char *) ctx->buffer)[(left_over + add) & ~63],\n+\t\t  ctx->buflen);\n+\t}\n+\n+      buffer = (const char *) buffer + add;\n+      len -= add;\n+    }\n+\n+  /* Process available complete blocks.  */\n+  if (len >= 64)\n+    {\n+#if !_STRING_ARCH_unaligned\n+# define alignof(type) offsetof (struct { char c; type x; }, x)\n+# define UNALIGNED_P(p) (((size_t) p) % alignof (sha1_uint32) != 0)\n+      if (UNALIGNED_P (buffer))\n+\twhile (len > 64)\n+\t  {\n+\t    sha1_process_block (memcpy (ctx->buffer, buffer, 64), 64, ctx);\n+\t    buffer = (const char *) buffer + 64;\n+\t    len -= 64;\n+\t  }\n+      else\n+#endif\n+\t{\n+\t  sha1_process_block (buffer, len & ~63, ctx);\n+\t  buffer = (const char *) buffer + (len & ~63);\n+\t  len &= 63;\n+\t}\n+    }\n+\n+  /* Move remaining bytes in internal buffer.  */\n+  if (len > 0)\n+    {\n+      size_t left_over = ctx->buflen;\n+\n+      memcpy (&((char *) ctx->buffer)[left_over], buffer, len);\n+      left_over += len;\n+      if (left_over >= 64)\n+\t{\n+\t  sha1_process_block (ctx->buffer, 64, ctx);\n+\t  left_over -= 64;\n+\t  memcpy (ctx->buffer, &ctx->buffer[16], left_over);\n+\t}\n+      ctx->buflen = left_over;\n+    }\n+}\n+\n+/* --- Code below is the primary difference between md5.c and sha1.c --- */\n+\n+/* SHA1 round constants */\n+#define K1 0x5a827999\n+#define K2 0x6ed9eba1\n+#define K3 0x8f1bbcdc\n+#define K4 0xca62c1d6\n+\n+/* Round functions.  Note that F2 is the same as F4.  */\n+#define F1(B,C,D) ( D ^ ( B & ( C ^ D ) ) )\n+#define F2(B,C,D) (B ^ C ^ D)\n+#define F3(B,C,D) ( ( B & C ) | ( D & ( B | C ) ) )\n+#define F4(B,C,D) (B ^ C ^ D)\n+\n+/* Process LEN bytes of BUFFER, accumulating context into CTX.\n+   It is assumed that LEN % 64 == 0.\n+   Most of this code comes from GnuPG's cipher/sha1.c.  */\n+\n+void\n+sha1_process_block (const void *buffer, size_t len, struct sha1_ctx *ctx)\n+{\n+  const sha1_uint32 *words = (const sha1_uint32*) buffer;\n+  size_t nwords = len / sizeof (sha1_uint32);\n+  const sha1_uint32 *endp = words + nwords;\n+  sha1_uint32 x[16];\n+  sha1_uint32 a = ctx->A;\n+  sha1_uint32 b = ctx->B;\n+  sha1_uint32 c = ctx->C;\n+  sha1_uint32 d = ctx->D;\n+  sha1_uint32 e = ctx->E;\n+\n+  /* First increment the byte count.  RFC 1321 specifies the possible\n+     length of the file up to 2^64 bits.  Here we only compute the\n+     number of bytes.  Do a double word increment.  */\n+  ctx->total[0] += len;\n+  if (ctx->total[0] < len)\n+    ++ctx->total[1];\n+\n+#define rol(x, n) (((x) << (n)) | ((sha1_uint32) (x) >> (32 - (n))))\n+\n+#define M(I) ( tm =   x[I&0x0f] ^ x[(I-14)&0x0f] \\\n+\t\t    ^ x[(I-8)&0x0f] ^ x[(I-3)&0x0f] \\\n+\t       , (x[I&0x0f] = rol(tm, 1)) )\n+\n+#define R(A,B,C,D,E,F,K,M)  do { E += rol( A, 5 )     \\\n+\t\t\t\t      + F( B, C, D )  \\\n+\t\t\t\t      + K\t      \\\n+\t\t\t\t      + M;\t      \\\n+\t\t\t\t B = rol( B, 30 );    \\\n+\t\t\t       } while(0)\n+\n+  while (words < endp)\n+    {\n+      sha1_uint32 tm;\n+      int t;\n+      for (t = 0; t < 16; t++)\n+\t{\n+\t  x[t] = SWAP (*words);\n+\t  words++;\n+\t}\n+\n+      R( a, b, c, d, e, F1, K1, x[ 0] );\n+      R( e, a, b, c, d, F1, K1, x[ 1] );\n+      R( d, e, a, b, c, F1, K1, x[ 2] );\n+      R( c, d, e, a, b, F1, K1, x[ 3] );\n+      R( b, c, d, e, a, F1, K1, x[ 4] );\n+      R( a, b, c, d, e, F1, K1, x[ 5] );\n+      R( e, a, b, c, d, F1, K1, x[ 6] );\n+      R( d, e, a, b, c, F1, K1, x[ 7] );\n+      R( c, d, e, a, b, F1, K1, x[ 8] );\n+      R( b, c, d, e, a, F1, K1, x[ 9] );\n+      R( a, b, c, d, e, F1, K1, x[10] );\n+      R( e, a, b, c, d, F1, K1, x[11] );\n+      R( d, e, a, b, c, F1, K1, x[12] );\n+      R( c, d, e, a, b, F1, K1, x[13] );\n+      R( b, c, d, e, a, F1, K1, x[14] );\n+      R( a, b, c, d, e, F1, K1, x[15] );\n+      R( e, a, b, c, d, F1, K1, M(16) );\n+      R( d, e, a, b, c, F1, K1, M(17) );\n+      R( c, d, e, a, b, F1, K1, M(18) );\n+      R( b, c, d, e, a, F1, K1, M(19) );\n+      R( a, b, c, d, e, F2, K2, M(20) );\n+      R( e, a, b, c, d, F2, K2, M(21) );\n+      R( d, e, a, b, c, F2, K2, M(22) );\n+      R( c, d, e, a, b, F2, K2, M(23) );\n+      R( b, c, d, e, a, F2, K2, M(24) );\n+      R( a, b, c, d, e, F2, K2, M(25) );\n+      R( e, a, b, c, d, F2, K2, M(26) );\n+      R( d, e, a, b, c, F2, K2, M(27) );\n+      R( c, d, e, a, b, F2, K2, M(28) );\n+      R( b, c, d, e, a, F2, K2, M(29) );\n+      R( a, b, c, d, e, F2, K2, M(30) );\n+      R( e, a, b, c, d, F2, K2, M(31) );\n+      R( d, e, a, b, c, F2, K2, M(32) );\n+      R( c, d, e, a, b, F2, K2, M(33) );\n+      R( b, c, d, e, a, F2, K2, M(34) );\n+      R( a, b, c, d, e, F2, K2, M(35) );\n+      R( e, a, b, c, d, F2, K2, M(36) );\n+      R( d, e, a, b, c, F2, K2, M(37) );\n+      R( c, d, e, a, b, F2, K2, M(38) );\n+      R( b, c, d, e, a, F2, K2, M(39) );\n+      R( a, b, c, d, e, F3, K3, M(40) );\n+      R( e, a, b, c, d, F3, K3, M(41) );\n+      R( d, e, a, b, c, F3, K3, M(42) );\n+      R( c, d, e, a, b, F3, K3, M(43) );\n+      R( b, c, d, e, a, F3, K3, M(44) );\n+      R( a, b, c, d, e, F3, K3, M(45) );\n+      R( e, a, b, c, d, F3, K3, M(46) );\n+      R( d, e, a, b, c, F3, K3, M(47) );\n+      R( c, d, e, a, b, F3, K3, M(48) );\n+      R( b, c, d, e, a, F3, K3, M(49) );\n+      R( a, b, c, d, e, F3, K3, M(50) );\n+      R( e, a, b, c, d, F3, K3, M(51) );\n+      R( d, e, a, b, c, F3, K3, M(52) );\n+      R( c, d, e, a, b, F3, K3, M(53) );\n+      R( b, c, d, e, a, F3, K3, M(54) );\n+      R( a, b, c, d, e, F3, K3, M(55) );\n+      R( e, a, b, c, d, F3, K3, M(56) );\n+      R( d, e, a, b, c, F3, K3, M(57) );\n+      R( c, d, e, a, b, F3, K3, M(58) );\n+      R( b, c, d, e, a, F3, K3, M(59) );\n+      R( a, b, c, d, e, F4, K4, M(60) );\n+      R( e, a, b, c, d, F4, K4, M(61) );\n+      R( d, e, a, b, c, F4, K4, M(62) );\n+      R( c, d, e, a, b, F4, K4, M(63) );\n+      R( b, c, d, e, a, F4, K4, M(64) );\n+      R( a, b, c, d, e, F4, K4, M(65) );\n+      R( e, a, b, c, d, F4, K4, M(66) );\n+      R( d, e, a, b, c, F4, K4, M(67) );\n+      R( c, d, e, a, b, F4, K4, M(68) );\n+      R( b, c, d, e, a, F4, K4, M(69) );\n+      R( a, b, c, d, e, F4, K4, M(70) );\n+      R( e, a, b, c, d, F4, K4, M(71) );\n+      R( d, e, a, b, c, F4, K4, M(72) );\n+      R( c, d, e, a, b, F4, K4, M(73) );\n+      R( b, c, d, e, a, F4, K4, M(74) );\n+      R( a, b, c, d, e, F4, K4, M(75) );\n+      R( e, a, b, c, d, F4, K4, M(76) );\n+      R( d, e, a, b, c, F4, K4, M(77) );\n+      R( c, d, e, a, b, F4, K4, M(78) );\n+      R( b, c, d, e, a, F4, K4, M(79) );\n+\n+      a = ctx->A += a;\n+      b = ctx->B += b;\n+      c = ctx->C += c;\n+      d = ctx->D += d;\n+      e = ctx->E += e;\n+    }\n+}"}]}