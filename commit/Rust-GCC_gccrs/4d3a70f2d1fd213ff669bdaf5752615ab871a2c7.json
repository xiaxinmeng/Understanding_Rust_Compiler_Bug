{"sha": "4d3a70f2d1fd213ff669bdaf5752615ab871a2c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQzYTcwZjJkMWZkMjEzZmY2NjliZGFmNTc1MjYxNWFiODcxYTJjNw==", "commit": {"author": {"name": "Piotr Trojanek", "email": "trojanek@adacore.com", "date": "2020-11-30T15:56:38Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-12-17T10:49:22Z"}, "message": "[Ada] Move folding of unchecked conversions from expansion to evaluation\n\ngcc/ada/\n\n\t* exp_ch4.adb (Expand_N_Unchecked_Type_Conversion): Remove\n\tfolding of discrete values.\n\t* exp_intr.adb (Expand_Unc_Conversion): Analyze, resolve and\n\tevaluate (if possible) calls to instances of\n\tAda.Unchecked_Conversion after they have been expanded into\n\tN_Unchecked_Type_Conversion.\n\t* sem_eval.adb (Eval_Unchecked_Conversion): Add folding of\n\tdiscrete values.", "tree": {"sha": "15dbaff7c8211f0ca668e4472fab27277478b6f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15dbaff7c8211f0ca668e4472fab27277478b6f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d3a70f2d1fd213ff669bdaf5752615ab871a2c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d3a70f2d1fd213ff669bdaf5752615ab871a2c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d3a70f2d1fd213ff669bdaf5752615ab871a2c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d3a70f2d1fd213ff669bdaf5752615ab871a2c7/comments", "author": {"login": "ptroja", "id": 161602, "node_id": "MDQ6VXNlcjE2MTYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/161602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptroja", "html_url": "https://github.com/ptroja", "followers_url": "https://api.github.com/users/ptroja/followers", "following_url": "https://api.github.com/users/ptroja/following{/other_user}", "gists_url": "https://api.github.com/users/ptroja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptroja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptroja/subscriptions", "organizations_url": "https://api.github.com/users/ptroja/orgs", "repos_url": "https://api.github.com/users/ptroja/repos", "events_url": "https://api.github.com/users/ptroja/events{/privacy}", "received_events_url": "https://api.github.com/users/ptroja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97919732a8ebeb343705966b2ca649d35d3197e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97919732a8ebeb343705966b2ca649d35d3197e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97919732a8ebeb343705966b2ca649d35d3197e9"}], "stats": {"total": 116, "additions": 57, "deletions": 59}, "files": [{"sha": "e376648a4a50822e8536d5aba325924ee2fe8e3f", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3a70f2d1fd213ff669bdaf5752615ab871a2c7/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3a70f2d1fd213ff669bdaf5752615ab871a2c7/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=4d3a70f2d1fd213ff669bdaf5752615ab871a2c7", "patch": "@@ -12815,56 +12815,6 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n-      --  If we have a conversion of a compile time known value to a target\n-      --  type and the value is in range of the target type, then we can simply\n-      --  replace the construct by an integer literal of the correct type. We\n-      --  only apply this to discrete types being converted. Possibly it may\n-      --  apply in other cases, but it is too much trouble to worry about.\n-\n-      --  Note that we do not do this transformation if the Kill_Range_Check\n-      --  flag is set, since then the value may be outside the expected range.\n-      --  This happens in the Normalize_Scalars case.\n-\n-      --  We also skip this if either the target or operand type is biased\n-      --  because in this case, the unchecked conversion is supposed to\n-      --  preserve the bit pattern, not the integer value.\n-\n-      if Is_Integer_Type (Target_Type)\n-        and then not Has_Biased_Representation (Target_Type)\n-        and then Is_Discrete_Type (Operand_Type)\n-        and then not Has_Biased_Representation (Operand_Type)\n-        and then Compile_Time_Known_Value (Operand)\n-        and then not Kill_Range_Check (N)\n-      then\n-         declare\n-            Val : constant Uint := Expr_Rep_Value (Operand);\n-\n-         begin\n-            if Compile_Time_Known_Value (Type_Low_Bound (Target_Type))\n-                 and then\n-               Compile_Time_Known_Value (Type_High_Bound (Target_Type))\n-                 and then\n-               Val >= Expr_Value (Type_Low_Bound (Target_Type))\n-                 and then\n-               Val <= Expr_Value (Type_High_Bound (Target_Type))\n-            then\n-               Rewrite (N, Make_Integer_Literal (Sloc (N), Val));\n-\n-               --  If Address is the target type, just set the type to avoid a\n-               --  spurious type error on the literal when Address is a visible\n-               --  integer type.\n-\n-               if Is_Descendant_Of_Address (Target_Type) then\n-                  Set_Etype (N, Target_Type);\n-               else\n-                  Analyze_And_Resolve (N, Target_Type);\n-               end if;\n-\n-               return;\n-            end if;\n-         end;\n-      end if;\n-\n       --  Generate an extra temporary for cases unsupported by the C backend\n \n       if Modify_Tree_For_C then"}, {"sha": "3be039b4be5de626f1b600fbb9781602ebcdf003", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3a70f2d1fd213ff669bdaf5752615ab871a2c7/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3a70f2d1fd213ff669bdaf5752615ab871a2c7/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=4d3a70f2d1fd213ff669bdaf5752615ab871a2c7", "patch": "@@ -29,7 +29,6 @@ with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Expander; use Expander;\n with Exp_Atag; use Exp_Atag;\n-with Exp_Ch4;  use Exp_Ch4;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Ch11; use Exp_Ch11;\n with Exp_Code; use Exp_Code;\n@@ -857,7 +856,7 @@ package body Exp_Intr is\n    ---------------------------\n \n    procedure Expand_Unc_Conversion (N : Node_Id; E : Entity_Id) is\n-      Func : constant Entity_Id  := Entity (Name (N));\n+      Func : constant Entity_Id := Entity (Name (N));\n       Conv : Node_Id;\n       Ftyp : Entity_Id;\n       Ttyp : Entity_Id;\n@@ -908,12 +907,7 @@ package body Exp_Intr is\n       end if;\n \n       Rewrite (N, Unchecked_Convert_To (Ttyp, Conv));\n-      Set_Etype (N, Ttyp);\n-      Set_Analyzed (N);\n-\n-      if Nkind (N) = N_Unchecked_Type_Conversion then\n-         Expand_N_Unchecked_Type_Conversion (N);\n-      end if;\n+      Analyze_And_Resolve (N, Ttyp);\n    end Expand_Unc_Conversion;\n \n    -----------------------------"}, {"sha": "1a832f767cd9a1113d8a57986ec4efc089948f37", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d3a70f2d1fd213ff669bdaf5752615ab871a2c7/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d3a70f2d1fd213ff669bdaf5752615ab871a2c7/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=4d3a70f2d1fd213ff669bdaf5752615ab871a2c7", "patch": "@@ -4359,8 +4359,62 @@ package body Sem_Eval is\n    --  processing is to check for a non-static context for the operand.\n \n    procedure Eval_Unchecked_Conversion (N : Node_Id) is\n+      Target_Type  : constant Entity_Id := Etype (N);\n+      Operand      : constant Node_Id   := Expression (N);\n+      Operand_Type : constant Entity_Id := Etype (Operand);\n+\n    begin\n-      Check_Non_Static_Context (Expression (N));\n+      Check_Non_Static_Context (Operand);\n+\n+      --  If we have a conversion of a compile time known value to a target\n+      --  type and the value is in range of the target type, then we can simply\n+      --  replace the construct by an integer literal of the correct type. We\n+      --  only apply this to discrete types being converted. Possibly it may\n+      --  apply in other cases, but it is too much trouble to worry about.\n+\n+      --  Note that we do not do this transformation if the Kill_Range_Check\n+      --  flag is set, since then the value may be outside the expected range.\n+      --  This happens in the Normalize_Scalars case.\n+\n+      --  We also skip this if either the target or operand type is biased\n+      --  because in this case, the unchecked conversion is supposed to\n+      --  preserve the bit pattern, not the integer value.\n+\n+      if Is_Integer_Type (Target_Type)\n+        and then not Has_Biased_Representation (Target_Type)\n+        and then Is_Discrete_Type (Operand_Type)\n+        and then not Has_Biased_Representation (Operand_Type)\n+        and then Compile_Time_Known_Value (Operand)\n+        and then not Kill_Range_Check (N)\n+      then\n+         declare\n+            Val : constant Uint := Expr_Rep_Value (Operand);\n+\n+         begin\n+            if Compile_Time_Known_Value (Type_Low_Bound (Target_Type))\n+                 and then\n+               Compile_Time_Known_Value (Type_High_Bound (Target_Type))\n+                 and then\n+               Val >= Expr_Value (Type_Low_Bound (Target_Type))\n+                 and then\n+               Val <= Expr_Value (Type_High_Bound (Target_Type))\n+            then\n+               Rewrite (N, Make_Integer_Literal (Sloc (N), Val));\n+\n+               --  If Address is the target type, just set the type to avoid a\n+               --  spurious type error on the literal when Address is a visible\n+               --  integer type.\n+\n+               if Is_Descendant_Of_Address (Target_Type) then\n+                  Set_Etype (N, Target_Type);\n+               else\n+                  Analyze_And_Resolve (N, Target_Type);\n+               end if;\n+\n+               return;\n+            end if;\n+         end;\n+      end if;\n    end Eval_Unchecked_Conversion;\n \n    --------------------"}]}