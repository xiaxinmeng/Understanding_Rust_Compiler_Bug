{"sha": "ffb5e2e21f98abfdb6cb7efdf8ff2e911f09ec64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZiNWUyZTIxZjk4YWJmZGI2Y2I3ZWZkZjhmZjJlOTExZjA5ZWM2NA==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2001-10-16T04:19:26Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2001-10-16T04:19:26Z"}, "message": "* recog.c: Formatting and comment typo fixes.\n\nFrom-SVN: r46276", "tree": {"sha": "e0d9de1c8a74c34a1204dc2eb571d455a6257a76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0d9de1c8a74c34a1204dc2eb571d455a6257a76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffb5e2e21f98abfdb6cb7efdf8ff2e911f09ec64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffb5e2e21f98abfdb6cb7efdf8ff2e911f09ec64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffb5e2e21f98abfdb6cb7efdf8ff2e911f09ec64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffb5e2e21f98abfdb6cb7efdf8ff2e911f09ec64/comments", "author": null, "committer": null, "parents": [{"sha": "0936a455f303b0f1e29bda6cd10cba773a3e0a16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0936a455f303b0f1e29bda6cd10cba773a3e0a16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0936a455f303b0f1e29bda6cd10cba773a3e0a16"}], "stats": {"total": 68, "additions": 35, "deletions": 33}, "files": [{"sha": "b5479fa93555cbbd2197d6166555d3f13c076ee2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffb5e2e21f98abfdb6cb7efdf8ff2e911f09ec64/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffb5e2e21f98abfdb6cb7efdf8ff2e911f09ec64/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ffb5e2e21f98abfdb6cb7efdf8ff2e911f09ec64", "patch": "@@ -1,5 +1,7 @@\n 2001-10-16  Alan Modra  <amodra@bigpond.net.au>\n \n+\t* recog.c: Formatting and comment typo fixes.\n+\n \t* configure.in (gcc_cv_as_bfd_srcdir): New.  Use it to find gas\n \tversion in single tree build.\n \t* configure: Regenerate."}, {"sha": "6c3ecd446db7e91ab1f3079665905b0e6f28ea81", "filename": "gcc/recog.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffb5e2e21f98abfdb6cb7efdf8ff2e911f09ec64/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffb5e2e21f98abfdb6cb7efdf8ff2e911f09ec64/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=ffb5e2e21f98abfdb6cb7efdf8ff2e911f09ec64", "patch": "@@ -215,7 +215,7 @@ validate_change (object, loc, new, in_group)\n   if (in_group == 0 && num_changes != 0)\n     abort ();\n \n-   *loc = new;\n+  *loc = new;\n \n   /* Save the information describing this change.  */\n   if (num_changes >= changes_allocated)\n@@ -353,33 +353,33 @@ apply_change_group ()\n \t      && GET_CODE (XVECEXP (pat, 0, XVECLEN (pat, 0) - 1)) == CLOBBER\n \t      && asm_noperands (PATTERN (object)) < 0)\n \t    {\n-\t       rtx newpat;\n-\n-\t       if (XVECLEN (pat, 0) == 2)\n-\t\t newpat = XVECEXP (pat, 0, 0);\n-\t       else\n-\t\t {\n-\t\t   int j;\n-\n-\t\t   newpat\n-\t\t     = gen_rtx_PARALLEL (VOIDmode, \n-\t\t\t\t\t rtvec_alloc (XVECLEN (pat, 0) - 1));\n-\t\t   for (j = 0; j < XVECLEN (newpat, 0); j++)\n-\t\t     XVECEXP (newpat, 0, j) = XVECEXP (pat, 0, j);\n-\t\t }\n-\n-\t       /* Add a new change to this group to replace the pattern\n-\t\t  with this new pattern.  Then consider this change\n-\t\t  as having succeeded.  The change we added will\n-\t\t  cause the entire call to fail if things remain invalid.\n-\n-\t\t  Note that this can lose if a later change than the one\n-\t\t  we are processing specified &XVECEXP (PATTERN (object), 0, X)\n-\t\t  but this shouldn't occur.  */\n-\n-\t       validate_change (object, &PATTERN (object), newpat, 1);\n-\t       continue;\n-\t     }\n+\t      rtx newpat;\n+\n+\t      if (XVECLEN (pat, 0) == 2)\n+\t\tnewpat = XVECEXP (pat, 0, 0);\n+\t      else\n+\t\t{\n+\t\t  int j;\n+\n+\t\t  newpat\n+\t\t    = gen_rtx_PARALLEL (VOIDmode, \n+\t\t\t\t\trtvec_alloc (XVECLEN (pat, 0) - 1));\n+\t\t  for (j = 0; j < XVECLEN (newpat, 0); j++)\n+\t\t    XVECEXP (newpat, 0, j) = XVECEXP (pat, 0, j);\n+\t\t}\n+\n+\t      /* Add a new change to this group to replace the pattern\n+\t\t with this new pattern.  Then consider this change\n+\t\t as having succeeded.  The change we added will\n+\t\t cause the entire call to fail if things remain invalid.\n+\n+\t\t Note that this can lose if a later change than the one\n+\t\t we are processing specified &XVECEXP (PATTERN (object), 0, X)\n+\t\t but this shouldn't occur.  */\n+\n+\t      validate_change (object, &PATTERN (object), newpat, 1);\n+\t      continue;\n+\t    }\n \t  else if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n \t    /* If this insn is a CLOBBER or USE, it is always valid, but is\n \t       never recognized.  */\n@@ -468,7 +468,7 @@ validate_replace_rtx_1 (loc, from, to, object)\n       return;\n     }\n \n-  /* Call ourseves recursivly to perform the replacements.  */\n+  /* Call ourself recursively to perform the replacements.  */\n \n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n@@ -479,7 +479,7 @@ validate_replace_rtx_1 (loc, from, to, object)\n \t  validate_replace_rtx_1 (&XVECEXP (x, i, j), from, to, object);\n     }\n \n-  /* In case we didn't substituted, there is nothing to do.  */\n+  /* If we didn't substitute, there is nothing more to do.  */\n   if (num_changes == prev_changes)\n     return;\n \n@@ -542,7 +542,7 @@ validate_replace_rtx_1 (loc, from, to, object)\n       new = simplify_subreg (GET_MODE (x), SUBREG_REG (x), op0_mode,\n \t\t\t     SUBREG_BYTE (x));\n \n-      /* Subregs of VOIDmode operands are incorect.  */\n+      /* Subregs of VOIDmode operands are incorrect.  */\n       if (!new && GET_MODE (SUBREG_REG (x)) == VOIDmode)\n \tnew = gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n       if (new)\n@@ -1204,7 +1204,7 @@ nonmemory_operand (op, mode)\n \treturn 0;\n \n       return ((GET_MODE (op) == VOIDmode || GET_MODE (op) == mode\n-\t      || mode == VOIDmode)\n+\t       || mode == VOIDmode)\n #ifdef LEGITIMATE_PIC_OPERAND_P\n \t      && (! flag_pic || LEGITIMATE_PIC_OPERAND_P (op))\n #endif\n@@ -2669,7 +2669,7 @@ reg_fits_class_p (operand, class, offset, mode)\n }\n \f\n /* Split single instruction.  Helper function for split_all_insns.\n-   Return last insn in the sequence if succesfull, or NULL if unsuccesfull.  */\n+   Return last insn in the sequence if successful, or NULL if unsuccessful.  */\n static rtx\n split_insn (insn)\n      rtx insn;"}]}