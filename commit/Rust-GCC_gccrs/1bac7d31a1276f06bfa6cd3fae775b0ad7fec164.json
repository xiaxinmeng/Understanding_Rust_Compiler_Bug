{"sha": "1bac7d31a1276f06bfa6cd3fae775b0ad7fec164", "node_id": "C_kwDOANBUbNoAKDFiYWM3ZDMxYTEyNzZmMDZiZmE2Y2QzZmFlNzc1YjBhZDdmZWMxNjQ", "commit": {"author": {"name": "Stafford Horne", "email": "shorne@gmail.com", "date": "2021-11-08T22:10:12Z"}, "committer": {"name": "Stafford Horne", "email": "shorne@gmail.com", "date": "2021-11-12T22:58:00Z"}, "message": "or1k: Fix clobbering of _mcount argument if fPIC is enabled\n\nRecently we changed the PROFILE_HOOK _mcount call to pass in the link\nregister as an argument.  This actually does not work when the _mcount\ncall uses a PLT because the GOT register setup code ends up getting\ninserted before the PROFILE_HOOK and clobbers the link register\nargument.\n\nThese glibc tests are failing:\n  gmon/tst-gmon-pie-gprof\n  gmon/tst-gmon-static-gprof\n\nThis patch fixes this by saving the instruction that stores the Link\nRegister to the _mcount argument and then inserts the GOT register setup\ninstructions after that.\n\nFor example:\n\nmain.c:\n\n    extern int e;\n\n    int f2(int a) {\n      return a + e;\n    }\n\n    int f1(int a) {\n      return f2 (a + a);\n    }\n\n    int main(int argc, char ** argv) {\n      return f1 (argc);\n    }\n\nCompiled:\n\n    or1k-smh-linux-gnu-gcc -Wall -c -O2 -fPIC -pg -S main.c\n\nBefore Fix:\n\n    main:\n        l.addi  r1, r1, -16\n        l.sw    8(r1), r2\n        l.sw    0(r1), r16\n        l.addi  r2, r1, 16   # Keeping FP, but not needed\n        l.sw    4(r1), r18\n        l.sw    12(r1), r9\n        l.jal   8            # GOT Setup clobbers r9 (Link Register)\n         l.movhi        r16, gotpchi(_GLOBAL_OFFSET_TABLE_-4)\n        l.ori   r16, r16, gotpclo(_GLOBAL_OFFSET_TABLE_+0)\n        l.add   r16, r16, r9\n        l.or    r18, r3, r3\n        l.or    r3, r9, r9    # This is not the original LR\n        l.jal   plt(_mcount)\n         l.nop\n\n        l.jal   plt(f1)\n         l.or    r3, r18, r18\n        l.lwz   r9, 12(r1)\n        l.lwz   r16, 0(r1)\n        l.lwz   r18, 4(r1)\n        l.lwz   r2, 8(r1)\n        l.jr    r9\n         l.addi  r1, r1, 16\n\nAfter the fix:\n\n    main:\n        l.addi  r1, r1, -12\n        l.sw    0(r1), r16\n        l.sw    4(r1), r18\n        l.sw    8(r1), r9\n        l.or    r18, r3, r3\n        l.or    r3, r9, r9    # We now have r9 (LR) set early\n        l.jal   8             # Clobbers r9 (Link Register)\n         l.movhi        r16, gotpchi(_GLOBAL_OFFSET_TABLE_-4)\n        l.ori   r16, r16, gotpclo(_GLOBAL_OFFSET_TABLE_+0)\n        l.add   r16, r16, r9\n        l.jal   plt(_mcount)\n         l.nop\n\n        l.jal   plt(f1)\n         l.or    r3, r18, r18\n        l.lwz   r9, 8(r1)\n        l.lwz   r16, 0(r1)\n        l.lwz   r18, 4(r1)\n        l.jr    r9\n         l.addi  r1, r1, 12\n\nFixes: 308531d148a (\"or1k: Add return address argument to _mcount call\")\n\ngcc/ChangeLog:\n\t* config/or1k/or1k-protos.h (or1k_profile_hook): New function.\n\t* config/or1k/or1k.h (PROFILE_HOOK): Change macro to reference\n\tnew function or1k_profile_hook.\n\t* config/or1k/or1k.c (struct machine_function): Add new field\n\tset_mcount_arg_insn.\n\t(or1k_profile_hook): New function.\n\t(or1k_init_pic_reg): Update to inject pic rtx after _mcount arg\n\twhen profiling.\n\t(or1k_frame_pointer_required): Frame pointer no longer needed\n\twhen profiling.", "tree": {"sha": "36043c0912cc342774dee5f34623dcf563471e97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36043c0912cc342774dee5f34623dcf563471e97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1bac7d31a1276f06bfa6cd3fae775b0ad7fec164", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bac7d31a1276f06bfa6cd3fae775b0ad7fec164", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bac7d31a1276f06bfa6cd3fae775b0ad7fec164", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bac7d31a1276f06bfa6cd3fae775b0ad7fec164/comments", "author": {"login": "stffrdhrn", "id": 2404255, "node_id": "MDQ6VXNlcjI0MDQyNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/2404255?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stffrdhrn", "html_url": "https://github.com/stffrdhrn", "followers_url": "https://api.github.com/users/stffrdhrn/followers", "following_url": "https://api.github.com/users/stffrdhrn/following{/other_user}", "gists_url": "https://api.github.com/users/stffrdhrn/gists{/gist_id}", "starred_url": "https://api.github.com/users/stffrdhrn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stffrdhrn/subscriptions", "organizations_url": "https://api.github.com/users/stffrdhrn/orgs", "repos_url": "https://api.github.com/users/stffrdhrn/repos", "events_url": "https://api.github.com/users/stffrdhrn/events{/privacy}", "received_events_url": "https://api.github.com/users/stffrdhrn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "stffrdhrn", "id": 2404255, "node_id": "MDQ6VXNlcjI0MDQyNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/2404255?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stffrdhrn", "html_url": "https://github.com/stffrdhrn", "followers_url": "https://api.github.com/users/stffrdhrn/followers", "following_url": "https://api.github.com/users/stffrdhrn/following{/other_user}", "gists_url": "https://api.github.com/users/stffrdhrn/gists{/gist_id}", "starred_url": "https://api.github.com/users/stffrdhrn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stffrdhrn/subscriptions", "organizations_url": "https://api.github.com/users/stffrdhrn/orgs", "repos_url": "https://api.github.com/users/stffrdhrn/repos", "events_url": "https://api.github.com/users/stffrdhrn/events{/privacy}", "received_events_url": "https://api.github.com/users/stffrdhrn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d2d5565a0953eaa829d10006baf007cf33bab89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d2d5565a0953eaa829d10006baf007cf33bab89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d2d5565a0953eaa829d10006baf007cf33bab89"}], "stats": {"total": 58, "additions": 42, "deletions": 16}, "files": [{"sha": "56554f2937f0f212c9a5eb0bbf637a272ecd3665", "filename": "gcc/config/or1k/or1k-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bac7d31a1276f06bfa6cd3fae775b0ad7fec164/gcc%2Fconfig%2For1k%2For1k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bac7d31a1276f06bfa6cd3fae775b0ad7fec164/gcc%2Fconfig%2For1k%2For1k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2For1k-protos.h?ref=1bac7d31a1276f06bfa6cd3fae775b0ad7fec164", "patch": "@@ -20,6 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n extern HOST_WIDE_INT or1k_initial_elimination_offset (int, int);\n extern void or1k_expand_prologue (void);\n extern void or1k_expand_epilogue (void);\n+extern void or1k_profile_hook (void);\n extern void or1k_expand_eh_return (rtx);\n extern rtx  or1k_initial_frame_addr (void);\n extern rtx  or1k_dynamic_chain_addr (rtx);"}, {"sha": "bb7270ca0d7ae62880554c8adf15ea867f0fd2cc", "filename": "gcc/config/or1k/or1k.c", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bac7d31a1276f06bfa6cd3fae775b0ad7fec164/gcc%2Fconfig%2For1k%2For1k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bac7d31a1276f06bfa6cd3fae775b0ad7fec164/gcc%2Fconfig%2For1k%2For1k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2For1k.c?ref=1bac7d31a1276f06bfa6cd3fae775b0ad7fec164", "patch": "@@ -73,6 +73,10 @@ struct GTY(()) machine_function\n \n   /* Remember where the set_got_placeholder is located.  */\n   rtx_insn *set_got_insn;\n+\n+  /* Remember where mcount args are stored so we can insert set_got_insn\n+     after.  */\n+  rtx_insn *set_mcount_arg_insn;\n };\n \n /* Zero initialization is OK for all current fields.  */\n@@ -415,6 +419,25 @@ or1k_expand_epilogue (void)\n \t\t\t   EH_RETURN_STACKADJ_RTX));\n }\n \n+/* Worker for PROFILE_HOOK.\n+   The OpenRISC profile hook uses the link register which will get clobbered by\n+   the GOT setup RTX.  This sets up a placeholder to allow injecting of the GOT\n+   setup RTX to avoid clobbering.  */\n+\n+void\n+or1k_profile_hook (void)\n+{\n+  rtx a1 = gen_rtx_REG (Pmode, 3);\n+  rtx ra = get_hard_reg_initial_val (Pmode, LR_REGNUM);\n+  rtx fun = gen_rtx_SYMBOL_REF (Pmode, \"_mcount\");\n+\n+  /* Keep track of where we setup the _mcount argument so we can insert the\n+     GOT setup RTX after it.  */\n+  cfun->machine->set_mcount_arg_insn = emit_move_insn (a1, ra);\n+\n+  emit_library_call (fun, LCT_NORMAL, VOIDmode, a1, Pmode);\n+}\n+\n /* Worker for TARGET_INIT_PIC_REG.\n    Initialize the cfun->machine->set_got_insn rtx and insert it at the entry\n    of the current function.  The rtx is just a temporary placeholder for\n@@ -423,17 +446,25 @@ or1k_expand_epilogue (void)\n static void\n or1k_init_pic_reg (void)\n {\n-  start_sequence ();\n \n-  cfun->machine->set_got_insn\n-    = emit_insn (gen_set_got_tmp (pic_offset_table_rtx));\n+  if (crtl->profile)\n+    cfun->machine->set_got_insn =\n+      emit_insn_after (gen_set_got_tmp (pic_offset_table_rtx),\n+\t\t       cfun->machine->set_mcount_arg_insn);\n+  else\n+    {\n+      start_sequence ();\n+\n+      cfun->machine->set_got_insn =\n+\temit_insn (gen_set_got_tmp (pic_offset_table_rtx));\n \n-  rtx_insn *seq = get_insns ();\n-  end_sequence ();\n+      rtx_insn *seq = get_insns ();\n+      end_sequence ();\n \n-  edge entry_edge = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n-  insert_insn_on_edge (seq, entry_edge);\n-  commit_one_edge_insertion (entry_edge);\n+      edge entry_edge = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+      insert_insn_on_edge (seq, entry_edge);\n+      commit_one_edge_insertion (entry_edge);\n+    }\n }\n \n #undef TARGET_INIT_PIC_REG\n@@ -480,7 +511,7 @@ or1k_frame_pointer_required ()\n {\n   /* ??? While IRA checks accesses_prior_frames, reload does not.\n      We do want the frame pointer for this case.  */\n-  return (crtl->accesses_prior_frames || crtl->profile);\n+  return (crtl->accesses_prior_frames);\n }\n \n /* Expand the \"eh_return\" pattern."}, {"sha": "bea7ba4c6c98a8c69a2b2a924c91d586dc323b92", "filename": "gcc/config/or1k/or1k.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bac7d31a1276f06bfa6cd3fae775b0ad7fec164/gcc%2Fconfig%2For1k%2For1k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bac7d31a1276f06bfa6cd3fae775b0ad7fec164/gcc%2Fconfig%2For1k%2For1k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2For1k%2For1k.h?ref=1bac7d31a1276f06bfa6cd3fae775b0ad7fec164", "patch": "@@ -392,13 +392,7 @@ do {                                                    \\\n \n /* Emit rtl for profiling.  Output assembler code to call \"_mcount\" for\n    profiling a function entry.  */\n-#define PROFILE_HOOK(LABEL)\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    rtx fun, ra;\t\t\t\t\t\t\t\\\n-    ra = get_hard_reg_initial_val (Pmode, LR_REGNUM);\t\t\t\\\n-    fun = gen_rtx_SYMBOL_REF (Pmode, \"_mcount\");\t\t\t\\\n-    emit_library_call (fun, LCT_NORMAL, VOIDmode, ra, Pmode);\t\t\\\n-  }\n+#define PROFILE_HOOK(LABEL)  or1k_profile_hook()\n \n /* All the work is done in PROFILE_HOOK, but this is still required.  */\n #define FUNCTION_PROFILER(STREAM, LABELNO) do { } while (0)"}]}