{"sha": "a653e758f68488c0056b0a0a3d9fcbe5d5eaf50f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY1M2U3NThmNjg0ODhjMDA1NmIwYTBhM2Q5ZmNiZTVkNWVhZjUwZg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-06-10T00:02:48Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-06-10T00:02:48Z"}, "message": "fold-const.c (fold_not_const): New function.\n\n\n\t* fold-const.c (fold_not_const): New function.\n\t(fold) <ABS_EXPR>: Don't bother testing wins.\n\t(fold) <BIT_NOT_EXPR>: Call fold_not_const.\n\t(nondestructive_fold_unary_to_constant) <BIT_NOT_EXPR>: Likewise.\n\nFrom-SVN: r82868", "tree": {"sha": "5fc66f9f60abbd000cc68d47fb8bb109947f94bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fc66f9f60abbd000cc68d47fb8bb109947f94bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a653e758f68488c0056b0a0a3d9fcbe5d5eaf50f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a653e758f68488c0056b0a0a3d9fcbe5d5eaf50f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a653e758f68488c0056b0a0a3d9fcbe5d5eaf50f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a653e758f68488c0056b0a0a3d9fcbe5d5eaf50f/comments", "author": null, "committer": null, "parents": [{"sha": "e66e7856e8c88873ba3a5b37f8afcd003e0f8df9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e66e7856e8c88873ba3a5b37f8afcd003e0f8df9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e66e7856e8c88873ba3a5b37f8afcd003e0f8df9"}], "stats": {"total": 64, "additions": 40, "deletions": 24}, "files": [{"sha": "b375ff2d98087d136a246d9a9005a0f139fef70b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a653e758f68488c0056b0a0a3d9fcbe5d5eaf50f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a653e758f68488c0056b0a0a3d9fcbe5d5eaf50f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a653e758f68488c0056b0a0a3d9fcbe5d5eaf50f", "patch": "@@ -1,3 +1,10 @@\n+2004-06-09  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (fold_not_const): New function.\n+\t(fold) <ABS_EXPR>: Don't bother testing wins.\n+\t(fold) <BIT_NOT_EXPR>: Call fold_not_const.\n+\t(nondestructive_fold_unary_to_constant) <BIT_NOT_EXPR>: Likewise.\n+\n 2004-06-09  Richard Henderson  <rth@redhat.com>\n  \n         PR middle-end/15228"}, {"sha": "be97417253db3d5118bd356910f1d29a19a610af", "filename": "gcc/fold-const.c", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a653e758f68488c0056b0a0a3d9fcbe5d5eaf50f/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a653e758f68488c0056b0a0a3d9fcbe5d5eaf50f/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=a653e758f68488c0056b0a0a3d9fcbe5d5eaf50f", "patch": "@@ -136,8 +136,10 @@ static bool tree_swap_operands_p (tree, tree, bool);\n \n static tree fold_negate_const (tree, tree);\n static tree fold_abs_const (tree, tree);\n+static tree fold_not_const (tree, tree);\n static tree fold_relational_const (enum tree_code, tree, tree, tree);\n-static tree fold_relational_hi_lo (enum tree_code *, const tree, tree *, tree *);\n+static tree fold_relational_hi_lo (enum tree_code *, const tree,\n+                                   tree *, tree *);\n \n /* We know that A1 + B1 = SUM1, using 2's complement arithmetic and ignoring\n    overflow.  Suppose A, B and SUM have the same respective signs as A1, B1,\n@@ -6018,8 +6020,7 @@ fold (tree expr)\n       return t;\n \n     case ABS_EXPR:\n-      if (wins\n-\t  && (TREE_CODE (arg0) == INTEGER_CST || TREE_CODE (arg0) == REAL_CST))\n+      if (TREE_CODE (arg0) == INTEGER_CST || TREE_CODE (arg0) == REAL_CST)\n \treturn fold_abs_const (arg0, type);\n       else if (TREE_CODE (arg0) == NEGATE_EXPR)\n \treturn fold (build1 (ABS_EXPR, type, TREE_OPERAND (arg0, 0)));\n@@ -6058,16 +6059,8 @@ fold (tree expr)\n       return t;\n \n     case BIT_NOT_EXPR:\n-      if (wins)\n-\t{\n-\t  tem = build_int_2 (~ TREE_INT_CST_LOW (arg0),\n-\t\t\t     ~ TREE_INT_CST_HIGH (arg0));\n-\t  TREE_TYPE (tem) = type;\n-\t  force_fit_type (tem, 0);\n-\t  TREE_OVERFLOW (tem) = TREE_OVERFLOW (arg0);\n-\t  TREE_CONSTANT_OVERFLOW (tem) = TREE_CONSTANT_OVERFLOW (arg0);\n-\t  return tem;\n-\t}\n+      if (TREE_CODE (arg0) == INTEGER_CST)\n+        return fold_not_const (arg0, type);\n       else if (TREE_CODE (arg0) == BIT_NOT_EXPR)\n \treturn TREE_OPERAND (arg0, 0);\n       return t;\n@@ -9697,8 +9690,6 @@ tree\n nondestructive_fold_unary_to_constant (enum tree_code code, tree type,\n \t\t\t\t       tree op0)\n {\n-  tree t;\n-\n   /* Make sure we have a suitable constant argument.  */\n   if (code == NOP_EXPR || code == FLOAT_EXPR || code == CONVERT_EXPR)\n     {\n@@ -9736,15 +9727,8 @@ nondestructive_fold_unary_to_constant (enum tree_code code, tree type,\n \treturn NULL_TREE;\n \n     case BIT_NOT_EXPR:\n-      if (TREE_CODE (op0) == INTEGER_CST || TREE_CODE (op0) == REAL_CST)\n-\t{\n-\t  t = build_int_2 (~ TREE_INT_CST_LOW (op0), ~ TREE_INT_CST_HIGH (op0));\n-\t  TREE_TYPE (t) = type;\n-\t  force_fit_type (t, 0);\n-\t  TREE_OVERFLOW (t) = TREE_OVERFLOW (op0);\n-\t  TREE_CONSTANT_OVERFLOW (t) = TREE_CONSTANT_OVERFLOW (op0);\n-\t  return t;\n-\t}\n+      if (TREE_CODE (op0) == INTEGER_CST)\n+\treturn fold_not_const (op0, type);\n       else\n \treturn NULL_TREE;\n \n@@ -9910,6 +9894,31 @@ fold_abs_const (tree arg0, tree type)\n   return t;\n }\n \n+/* Return the tree for not (ARG0) when ARG0 is known to be an integer\n+   constant.  TYPE is the type of the result.  */\n+\n+static tree\n+fold_not_const (tree arg0, tree type)\n+{\n+  tree t = NULL_TREE;\n+\n+  if (TREE_CODE (arg0) == INTEGER_CST)\n+    {\n+      t = build_int_2 (~ TREE_INT_CST_LOW (arg0),\n+\t\t       ~ TREE_INT_CST_HIGH (arg0));\n+      TREE_TYPE (t) = type;\n+      force_fit_type (t, 0);\n+      TREE_OVERFLOW (t) = TREE_OVERFLOW (arg0);\n+      TREE_CONSTANT_OVERFLOW (t) = TREE_CONSTANT_OVERFLOW (arg0);\n+    }\n+#ifdef ENABLE_CHECKING\n+  else\n+    abort ();\n+#endif\n+    \n+  return t;\n+}\n+\n /* Given CODE, a relational operator, the target type, TYPE and two\n    constant operands OP0 and OP1, return the result of the\n    relational operation.  If the result is not a compile time"}]}