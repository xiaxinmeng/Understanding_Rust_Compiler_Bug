{"sha": "f4e801988dc5c06739a76e6808c588fe7b74f9ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRlODAxOTg4ZGM1YzA2NzM5YTc2ZTY4MDhjNTg4ZmU3Yjc0ZjljYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-03-25T18:18:54Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-03-25T18:18:54Z"}, "message": "(output_move_{si,hi,qi}mode): New functions.\n\nFrom-SVN: r13787", "tree": {"sha": "3d9c46c56b8da092e80f466579b575f38ee9e2d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d9c46c56b8da092e80f466579b575f38ee9e2d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4e801988dc5c06739a76e6808c588fe7b74f9ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4e801988dc5c06739a76e6808c588fe7b74f9ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4e801988dc5c06739a76e6808c588fe7b74f9ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4e801988dc5c06739a76e6808c588fe7b74f9ca/comments", "author": null, "committer": null, "parents": [{"sha": "bae348586b3fd9e727054754ab03db44e9084db8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bae348586b3fd9e727054754ab03db44e9084db8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bae348586b3fd9e727054754ab03db44e9084db8"}], "stats": {"total": 140, "additions": 140, "deletions": 0}, "files": [{"sha": "59b931525e194d0dedf2148e3b407a8121e65d5c", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4e801988dc5c06739a76e6808c588fe7b74f9ca/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4e801988dc5c06739a76e6808c588fe7b74f9ca/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=f4e801988dc5c06739a76e6808c588fe7b74f9ca", "patch": "@@ -1406,6 +1406,146 @@ output_move_simode_const (operands)\n   return \"move%.l %1,%0\";\n }\n \n+char *\n+output_move_simode (operands)\n+     rtx *operands;\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    return output_move_simode_const (operands);\n+  else if ((GET_CODE (operands[1]) == SYMBOL_REF\n+\t    || GET_CODE (operands[1]) == CONST)\n+\t   && push_operand (operands[0], SImode))\n+    return \"pea %a1\";\n+  else if ((GET_CODE (operands[1]) == SYMBOL_REF\n+\t    || GET_CODE (operands[1]) == CONST)\n+\t   && ADDRESS_REG_P (operands[0]))\n+    return \"lea %a1,%0\";\n+  return \"move%.l %1,%0\";\n+}\n+\n+char *\n+output_move_himode (operands)\n+     rtx *operands;\n+{\n+ if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      if (operands[1] == const0_rtx\n+\t  && (DATA_REG_P (operands[0])\n+\t      || GET_CODE (operands[0]) == MEM)\n+\t  /* clr insns on 68000 read before writing.\n+\t     This isn't so on the 68010, but we have no TARGET_68010.  */\n+\t  && ((TARGET_68020 || TARGET_5200)\n+\t      || !(GET_CODE (operands[0]) == MEM\n+\t\t   && MEM_VOLATILE_P (operands[0]))))\n+\treturn \"clr%.w %0\";\n+      else if (DATA_REG_P (operands[0])\n+\t       && INTVAL (operands[1]) < 128\n+\t       && INTVAL (operands[1]) >= -128)\n+\t{\n+#if defined(MOTOROLA) && !defined(CRDS)\n+\t  return \"moveq%.l %1,%0\";\n+#else\n+\t  return \"moveq %1,%0\";\n+#endif\n+\t}\n+      else if (INTVAL (operands[1]) < 0x8000\n+\t       && INTVAL (operands[1]) >= -0x8000)\n+\treturn \"move%.w %1,%0\";\n+    }\n+  else if (CONSTANT_P (operands[1]))\n+    return \"move%.l %1,%0\";\n+#ifndef SGS_NO_LI\n+  /* Recognize the insn before a tablejump, one that refers\n+     to a table of offsets.  Such an insn will need to refer\n+     to a label on the insn.  So output one.  Use the label-number\n+     of the table of offsets to generate this label.  This code,\n+     and similar code below, assumes that there will be at most one\n+     reference to each table.  */\n+  if (GET_CODE (operands[1]) == MEM\n+      && GET_CODE (XEXP (operands[1], 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (operands[1], 0), 1)) == LABEL_REF\n+      && GET_CODE (XEXP (XEXP (operands[1], 0), 0)) != PLUS)\n+    {\n+      rtx labelref = XEXP (XEXP (operands[1], 0), 1);\n+#if defined (MOTOROLA) && !defined (SGS_SWITCH_TABLES)\n+#ifdef SGS\n+      asm_fprintf (asm_out_file, \"\\tset %LLI%d,.+2\\n\",\n+\t\t   CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n+#else /* not SGS */\n+      asm_fprintf (asm_out_file, \"\\t.set %LLI%d,.+2\\n\",\n+\t\t   CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n+#endif /* not SGS */\n+#else /* SGS_SWITCH_TABLES or not MOTOROLA */\n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LI\",\n+\t\t\t\t CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n+#ifdef SGS_SWITCH_TABLES\n+      /* Set flag saying we need to define the symbol\n+\t LD%n (with value L%n-LI%n) at the end of the switch table.  */\n+      switch_table_difference_label_flag = 1;\n+#endif /* SGS_SWITCH_TABLES */\n+#endif /* SGS_SWITCH_TABLES or not MOTOROLA */\n+    }\n+#endif /* SGS_NO_LI */\n+  return \"move%.w %1,%0\";\n+}\n+\n+char *\n+output_move_qimode (operands)\n+     rtx *operands;\n+{\n+  rtx xoperands[4];\n+\n+  /* This is probably useless, since it loses for pushing a struct\n+     of several bytes a byte at a time.\t */\n+  if (GET_CODE (operands[0]) == MEM\n+      && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC\n+      && XEXP (XEXP (operands[0], 0), 0) == stack_pointer_rtx\n+      && ! ADDRESS_REG_P (operands[1]))\n+    {\n+      xoperands[1] = operands[1];\n+      xoperands[2]\n+\t= gen_rtx (MEM, QImode,\n+\t\t   gen_rtx (PLUS, VOIDmode, stack_pointer_rtx, const1_rtx));\n+      /* Just pushing a byte puts it in the high byte of the halfword.\t*/\n+      /* We must put it in the low-order, high-numbered byte.  */\n+      output_asm_insn (\"move%.b %1,%-\\n\\tmove%.b %@,%2\", xoperands);\n+      return \"\";\n+    }\n+\n+  /* clr and st insns on 68000 read before writing.\n+     This isn't so on the 68010, but we have no TARGET_68010.  */\n+  if (!ADDRESS_REG_P (operands[0])\n+      && ((TARGET_68020 || TARGET_5200)\n+\t  || !(GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0]))))\n+    {\n+      if (operands[1] == const0_rtx)\n+\treturn \"clr%.b %0\";\n+      if ((!TARGET_5200 || DATA_REG_P (operands[0]))\n+\t  && GET_CODE (operands[1]) == CONST_INT\n+\t  && (INTVAL (operands[1]) & 255) == 255)\n+\t{\n+\t  CC_STATUS_INIT;\n+\t  return \"st %0\";\n+\t}\n+    }\n+  if (GET_CODE (operands[1]) == CONST_INT\n+      && DATA_REG_P (operands[0])\n+      && INTVAL (operands[1]) < 128\n+      && INTVAL (operands[1]) >= -128)\n+    {\n+#if defined(MOTOROLA) && !defined(CRDS)\n+      return \"moveq%.l %1,%0\";\n+#else\n+      return \"moveq %1,%0\";\n+#endif\n+    }\n+  if (GET_CODE (operands[1]) != CONST_INT && CONSTANT_P (operands[1]))\n+    return \"move%.l %1,%0\";\n+  if (ADDRESS_REG_P (operands[0]) || ADDRESS_REG_P (operands[1]))\n+    return \"move%.w %1,%0\";\n+  return \"move%.b %1,%0\";\n+}\n+\n /* Return the best assembler insn template\n    for moving operands[1] into operands[0] as a fullword.  */\n "}]}