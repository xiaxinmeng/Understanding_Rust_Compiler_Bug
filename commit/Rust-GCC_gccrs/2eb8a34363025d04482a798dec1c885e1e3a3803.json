{"sha": "2eb8a34363025d04482a798dec1c885e1e3a3803", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmViOGEzNDM2MzAyNWQwNDQ4MmE3OThkZWMxYzg4NWUxZTNhMzgwMw==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2017-04-23T07:25:30Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2017-04-23T07:25:30Z"}, "message": "re PR target/70799 (STV pass does not convert DImode shifts)\n\n\tPR target/70799\n\t* config/i386/i386.c (dimode_scalar_to_vector_candidate_p)\n\t<case ASHIFT, case LSHIFTRT>: Also consider variable shifts.\n\tCheck \"XEXP (src, 1)\" operand here.\n\t<case PLUS, case MINUS, case IOR, case XOR, case AND>:\n\tCheck \"XEXP (src, 1)\" operand here.\n\t(dimode_scalar_chain::make_vector_copies): Detect count register\n\tof a shift instruction.  Zero extend count register from QImode\n\tto DImode to satisfy vector shift pattern count operand predicate.\n\tSubstitute vector shift count operand with a DImode copy.\n\t(dimode_scalar_chain::convert_reg): Ditto, zero-extend from\n\tvector register.\n\ntestsuite/ChangeLog:\n\n\tPR target/70799\n\t* gcc.target/i186/pr70799-4.c: New test.\n\nFrom-SVN: r247082", "tree": {"sha": "b5da08f631dab69d29e95297a4be8d4f01c857d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5da08f631dab69d29e95297a4be8d4f01c857d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2eb8a34363025d04482a798dec1c885e1e3a3803", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eb8a34363025d04482a798dec1c885e1e3a3803", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2eb8a34363025d04482a798dec1c885e1e3a3803", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eb8a34363025d04482a798dec1c885e1e3a3803/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a1687c59a105c3131f0f33be8cae4f0a7ea660cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1687c59a105c3131f0f33be8cae4f0a7ea660cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1687c59a105c3131f0f33be8cae4f0a7ea660cc"}], "stats": {"total": 196, "additions": 173, "deletions": 23}, "files": [{"sha": "416cc17790389d53e81fed70005d8e5f8550367f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eb8a34363025d04482a798dec1c885e1e3a3803/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eb8a34363025d04482a798dec1c885e1e3a3803/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2eb8a34363025d04482a798dec1c885e1e3a3803", "patch": "@@ -1,3 +1,18 @@\n+2017-04-23  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/70799\n+\t* config/i386/i386.c (dimode_scalar_to_vector_candidate_p)\n+\t<case ASHIFT, case LSHIFTRT>: Also consider variable shifts.\n+\tCheck \"XEXP (src, 1)\" operand here.\n+\t<case PLUS, case MINUS, case IOR, case XOR, case AND>:\n+\tCheck \"XEXP (src, 1)\" operand here.\n+\t(dimode_scalar_chain::make_vector_copies): Detect count register\n+\tof a shift instruction.  Zero extend count register from QImode\n+\tto DImode to satisfy vector shift pattern count operand predicate.\n+\tSubstitute vector shift count operand with a DImode copy.\n+\t(dimode_scalar_chain::convert_reg): Ditto, zero-extend from\n+\tvector register.\n+\n 2017-04-21  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (*extzvqi_mem_rex64): Move above *extzv<mode>."}, {"sha": "3bebb47b6650e04b33e11df82462c66b8a1504fb", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 136, "deletions": 23, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eb8a34363025d04482a798dec1c885e1e3a3803/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eb8a34363025d04482a798dec1c885e1e3a3803/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2eb8a34363025d04482a798dec1c885e1e3a3803", "patch": "@@ -2811,9 +2811,16 @@ dimode_scalar_to_vector_candidate_p (rtx_insn *insn)\n     {\n     case ASHIFT:\n     case LSHIFTRT:\n-      /* FIXME: consider also variable shifts.  */\n-      if (!CONST_INT_P (XEXP (src, 1))\n-\t  || !IN_RANGE (INTVAL (XEXP (src, 1)), 0, 63))\n+      if (!REG_P (XEXP (src, 1))\n+\t  && (!SUBREG_P (XEXP (src, 1))\n+\t      || SUBREG_BYTE (XEXP (src, 1)) != 0\n+\t      || !REG_P (SUBREG_REG (XEXP (src, 1))))\n+\t  && (!CONST_INT_P (XEXP (src, 1))\n+\t      || !IN_RANGE (INTVAL (XEXP (src, 1)), 0, 63)))\n+\treturn false;\n+\n+      if (GET_MODE (XEXP (src, 1)) != QImode\n+\t  && !CONST_INT_P (XEXP (src, 1)))\n \treturn false;\n       break;\n \n@@ -2826,6 +2833,10 @@ dimode_scalar_to_vector_candidate_p (rtx_insn *insn)\n \t  && !MEM_P (XEXP (src, 1))\n \t  && !CONST_INT_P (XEXP (src, 1)))\n \treturn false;\n+\n+      if (GET_MODE (XEXP (src, 1)) != DImode\n+\t  && !CONST_INT_P (XEXP (src, 1)))\n+\treturn false;\n       break;\n \n     case NEG:\n@@ -2852,12 +2863,8 @@ dimode_scalar_to_vector_candidate_p (rtx_insn *insn)\n \t  || !REG_P (XEXP (XEXP (src, 0), 0))))\n       return false;\n \n-  if ((GET_MODE (XEXP (src, 0)) != DImode\n-       && !CONST_INT_P (XEXP (src, 0)))\n-      || (GET_CODE (src) != NEG\n-\t  && GET_CODE (src) != NOT\n-\t  && GET_MODE (XEXP (src, 1)) != DImode\n-\t  && !CONST_INT_P (XEXP (src, 1))))\n+  if (GET_MODE (XEXP (src, 0)) != DImode\n+      && !CONST_INT_P (XEXP (src, 0)))\n     return false;\n \n   return true;\n@@ -3407,12 +3414,17 @@ dimode_scalar_chain::compute_convert_gain ()\n       else if (GET_CODE (src) == ASHIFT\n \t       || GET_CODE (src) == LSHIFTRT)\n \t{\n-\t  gain += ix86_cost->shift_const;\n     \t  if (CONST_INT_P (XEXP (src, 0)))\n \t    gain -= vector_const_cost (XEXP (src, 0));\n-\t  if (CONST_INT_P (XEXP (src, 1))\n-\t      && INTVAL (XEXP (src, 1)) >= 32)\n-\t    gain -= COSTS_N_INSNS (1);\n+\t  if (CONST_INT_P (XEXP (src, 1)))\n+\t    {\n+\t      gain += ix86_cost->shift_const;\n+\t      if (INTVAL (XEXP (src, 1)) >= 32)\n+\t\tgain -= COSTS_N_INSNS (1);\n+\t    }\n+\t  else\n+\t    /* Additional gain for omitting two CMOVs.  */\n+\t    gain += ix86_cost->shift_var + COSTS_N_INSNS (2);\n \t}\n       else if (GET_CODE (src) == PLUS\n \t       || GET_CODE (src) == MINUS\n@@ -3528,15 +3540,59 @@ dimode_scalar_chain::make_vector_copies (unsigned regno)\n {\n   rtx reg = regno_reg_rtx[regno];\n   rtx vreg = gen_reg_rtx (DImode);\n+  bool count_reg = false;\n   df_ref ref;\n \n   for (ref = DF_REG_DEF_CHAIN (regno); ref; ref = DF_REF_NEXT_REG (ref))\n     if (!bitmap_bit_p (insns, DF_REF_INSN_UID (ref)))\n       {\n-\trtx_insn *insn = DF_REF_INSN (ref);\n+\tdf_ref use;\n+\n+\t/* Detect the count register of a shift instruction.  */\n+\tfor (use = DF_REG_USE_CHAIN (regno); use; use = DF_REF_NEXT_REG (use))\n+\t  if (bitmap_bit_p (insns, DF_REF_INSN_UID (use)))\n+\t    {\n+\t      rtx_insn *insn = DF_REF_INSN (use);\n+\t      rtx def_set = single_set (insn);\n+\n+\t      gcc_assert (def_set);\n+\n+\t      rtx src = SET_SRC (def_set);\n+\n+\t      if ((GET_CODE (src) == ASHIFT\n+\t\t   || GET_CODE (src) == LSHIFTRT)\n+\t\t  && !CONST_INT_P (XEXP (src, 1))\n+\t\t  && reg_or_subregno (XEXP (src, 1)) == regno)\n+\t\tcount_reg = true;\n+\t    }\n \n \tstart_sequence ();\n-\tif (TARGET_SSE4_1)\n+\tif (count_reg)\n+\t  {\n+\t    rtx qreg = gen_lowpart (QImode, reg);\n+\t    rtx tmp = gen_reg_rtx (SImode);\n+\n+\t    if (TARGET_ZERO_EXTEND_WITH_AND\n+\t\t&& optimize_function_for_speed_p (cfun))\n+\t      {\n+\t\temit_move_insn (tmp, const0_rtx);\n+\t\temit_insn (gen_movstrictqi\n+\t\t\t   (gen_lowpart (QImode, tmp), qreg));\n+\t      }\n+\t    else\n+\t      emit_insn (gen_rtx_SET\n+\t\t\t (tmp, gen_rtx_ZERO_EXTEND (SImode, qreg)));\n+\n+\t    if (!TARGET_INTER_UNIT_MOVES_TO_VEC)\n+\t      {\n+\t\trtx slot = assign_386_stack_local (SImode, SLOT_STV_TEMP);\n+\t\temit_move_insn (slot, tmp);\n+\t\ttmp = copy_rtx (slot);\n+\t      }\n+\n+\t    emit_insn (gen_zero_extendsidi2 (vreg, tmp));\n+\t  }\n+\telse if (TARGET_SSE4_1)\n \t  {\n \t    emit_insn (gen_sse2_loadld (gen_rtx_SUBREG (V4SImode, vreg, 0),\n \t\t\t\t\tCONST0_RTX (V4SImode),\n@@ -3571,22 +3627,38 @@ dimode_scalar_chain::make_vector_copies (unsigned regno)\n \t  }\n \trtx_insn *seq = get_insns ();\n \tend_sequence ();\n+\trtx_insn *insn = DF_REF_INSN (ref);\n \temit_conversion_insns (seq, insn);\n \n \tif (dump_file)\n \t  fprintf (dump_file,\n \t\t   \"  Copied r%d to a vector register r%d for insn %d\\n\",\n-\t\t   regno, REGNO (vreg), DF_REF_INSN_UID (ref));\n+\t\t   regno, REGNO (vreg), INSN_UID (insn));\n       }\n \n   for (ref = DF_REG_USE_CHAIN (regno); ref; ref = DF_REF_NEXT_REG (ref))\n     if (bitmap_bit_p (insns, DF_REF_INSN_UID (ref)))\n       {\n-\treplace_with_subreg_in_insn (DF_REF_INSN (ref), reg, vreg);\n+\trtx_insn *insn = DF_REF_INSN (ref);\n+\tif (count_reg)\n+\t  {\n+\t    rtx def_set = single_set (insn);\n+\t    gcc_assert (def_set);\n+\n+\t    rtx src = SET_SRC (def_set);\n+\n+\t    if ((GET_CODE (src) == ASHIFT\n+\t\t || GET_CODE (src) == LSHIFTRT)\n+\t\t&& !CONST_INT_P (XEXP (src, 1))\n+\t\t&& reg_or_subregno (XEXP (src, 1)) == regno)\n+\t      XEXP (src, 1) = vreg;\n+\t  }\n+\telse\n+\t  replace_with_subreg_in_insn (insn, reg, vreg);\n \n \tif (dump_file)\n \t  fprintf (dump_file, \"  Replaced r%d with r%d in insn %d\\n\",\n-\t\t   regno, REGNO (vreg), DF_REF_INSN_UID (ref));\n+\t\t   regno, REGNO (vreg), INSN_UID (insn));\n       }\n }\n \n@@ -3677,11 +3749,52 @@ dimode_scalar_chain::convert_reg (unsigned regno)\n       {\n \tif (bitmap_bit_p (conv, DF_REF_INSN_UID (ref)))\n \t  {\n-\t    rtx def_set = single_set (DF_REF_INSN (ref));\n-\t    if (!MEM_P (SET_DEST (def_set))\n-\t\t|| !REG_P (SET_SRC (def_set)))\n-\t      replace_with_subreg_in_insn (DF_REF_INSN (ref), reg, reg);\n-\t    bitmap_clear_bit (conv, DF_REF_INSN_UID (ref));\n+\t    rtx_insn *insn = DF_REF_INSN (ref);\n+\n+\t    rtx def_set = single_set (insn);\n+\t    gcc_assert (def_set);\n+\n+\t    rtx src = SET_SRC (def_set);\n+\t    rtx dst = SET_DEST (def_set);\n+\n+\t    if ((GET_CODE (src) == ASHIFT\n+\t\t || GET_CODE (src) == LSHIFTRT)\n+\t\t&& !CONST_INT_P (XEXP (src, 1))\n+\t\t&& reg_or_subregno (XEXP (src, 1)) == regno)\n+\t      {\n+\t\trtx tmp2 = gen_reg_rtx (V2DImode);\n+\n+\t\tstart_sequence ();\n+\n+\t\tif (TARGET_SSE4_1)\n+\t\t  emit_insn (gen_sse4_1_zero_extendv2qiv2di2\n+\t\t\t     (tmp2, gen_rtx_SUBREG (V16QImode, reg, 0)));\n+\t\telse\n+\t\t  {\n+\t\t    rtx vec_cst\n+\t\t      = gen_rtx_CONST_VECTOR (V2DImode,\n+\t\t\t\t\t      gen_rtvec (2, GEN_INT (0xff),\n+\t\t\t\t\t\t\t const0_rtx));\n+\t\t    vec_cst\n+\t\t      = validize_mem (force_const_mem (V2DImode, vec_cst));\n+\n+\t\t    emit_insn (gen_rtx_SET\n+\t\t\t       (tmp2,\n+\t\t\t\tgen_rtx_AND (V2DImode,\n+\t\t\t\t\t     gen_rtx_SUBREG (V2DImode, reg, 0),\n+\t\t\t\t\t     vec_cst)));\n+\t\t  }\n+\t\trtx_insn *seq = get_insns ();\n+\t\tend_sequence ();\n+\n+\t\temit_insn_before (seq, insn);\n+\n+\t\tXEXP (src, 1) = gen_rtx_SUBREG (DImode, tmp2, 0);\n+\t      }\n+\t    else if (!MEM_P (dst) || !REG_P (src))\n+\t      replace_with_subreg_in_insn (insn, reg, reg);\n+\n+\t    bitmap_clear_bit (conv, INSN_UID (insn));\n \t  }\n       }\n     /* Skip debug insns and uninitialized uses.  */"}, {"sha": "39c270773f265f8d67a96eca15a4d3f924c0977a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eb8a34363025d04482a798dec1c885e1e3a3803/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eb8a34363025d04482a798dec1c885e1e3a3803/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2eb8a34363025d04482a798dec1c885e1e3a3803", "patch": "@@ -1,3 +1,8 @@\n+2017-04-23  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/70799\n+\t* gcc.target/i186/pr70799-4.c: New test.\n+\n 2017-04-21  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/80392"}, {"sha": "999d5ab5d8df8addeab22f6c50a751e760e7098b", "filename": "gcc/testsuite/gcc.target/i386/pr70799-4.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eb8a34363025d04482a798dec1c885e1e3a3803/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr70799-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eb8a34363025d04482a798dec1c885e1e3a3803/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr70799-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr70799-4.c?ref=2eb8a34363025d04482a798dec1c885e1e3a3803", "patch": "@@ -0,0 +1,17 @@\n+/* PR target/pr70799 */\n+/* { dg-do compile { target { ia32 } } } */\n+/* { dg-options \"-O2 -march=slm -mno-stackrealign\" } */\n+/* { dg-final { scan-assembler \"psllq\" } } */\n+/* { dg-final { scan-assembler \"psrlq\" } } */\n+\n+unsigned long long a, b;\n+\n+void test1 (int c)\n+{\n+  a = b << c;\n+}\n+\n+void test2 (int c)\n+{\n+  a = b >> c;\n+}"}]}