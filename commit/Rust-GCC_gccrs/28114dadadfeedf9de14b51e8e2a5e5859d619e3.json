{"sha": "28114dadadfeedf9de14b51e8e2a5e5859d619e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgxMTRkYWRhZGZlZWRmOWRlMTRiNTFlOGUyYTVlNTg1OWQ2MTllMw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-07-17T17:22:44Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-07-17T17:22:44Z"}, "message": "re PR fortran/31320 (Illegal read with gfortran.dg/alloc_comp_assign_2.f90 and *_3.f90)\n\n2007-07-17  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/31320\n\tPR fortran/32665\n\t* trans-expr.c (gfc_trans_subcomponent_assign): Ensure that\n\trenormalization unity base is done independently of existing\n\tlbound value.\n\t(gfc_trans_scalar_assign): If rhs is not a variable, put\n\tlse->pre after rse->pre to ensure that de-allocation of lhs\n\toccurs after evaluation of rhs.\n\n2007-07-17  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/31320\n\tPR fortran/32665\n\t* gfortran.dg/alloc_comp_constructor_3.f90: New test.\n\nFrom-SVN: r126703", "tree": {"sha": "68ba4b18261ead6f352d9cbbba151c1b0052fd4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68ba4b18261ead6f352d9cbbba151c1b0052fd4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28114dadadfeedf9de14b51e8e2a5e5859d619e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28114dadadfeedf9de14b51e8e2a5e5859d619e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28114dadadfeedf9de14b51e8e2a5e5859d619e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28114dadadfeedf9de14b51e8e2a5e5859d619e3/comments", "author": null, "committer": null, "parents": [{"sha": "4c85af60e8b5736e5534fee89d1a671b9f3ab7a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c85af60e8b5736e5534fee89d1a671b9f3ab7a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c85af60e8b5736e5534fee89d1a671b9f3ab7a9"}], "stats": {"total": 126, "additions": 85, "deletions": 41}, "files": [{"sha": "726fd181eda43083ff7c3c66e384dbec8ad9ac63", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28114dadadfeedf9de14b51e8e2a5e5859d619e3/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28114dadadfeedf9de14b51e8e2a5e5859d619e3/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=28114dadadfeedf9de14b51e8e2a5e5859d619e3", "patch": "@@ -1,3 +1,14 @@\n+2007-07-17  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/31320\n+\tPR fortran/32665\n+\t* trans-expr.c (gfc_trans_subcomponent_assign): Ensure that\n+\trenormalization unity base is done independently of existing\n+\tlbound value.\n+\t(gfc_trans_scalar_assign): If rhs is not a variable, put\n+\tlse->pre after rse->pre to ensure that de-allocation of lhs\n+\toccurs after evaluation of rhs.\n+\n 2007-07-16  Lee Millward  <lee.millward@gmail.com>\n \n \tPR fortran/32222"}, {"sha": "fce615935409a32c6cbb2fdf8958a8633708fd74", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 52, "deletions": 41, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28114dadadfeedf9de14b51e8e2a5e5859d619e3/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28114dadadfeedf9de14b51e8e2a5e5859d619e3/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=28114dadadfeedf9de14b51e8e2a5e5859d619e3", "patch": "@@ -2973,65 +2973,68 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n       if (cm->allocatable && expr->expr_type == EXPR_NULL)\n  \tgfc_conv_descriptor_data_set (&block, dest, null_pointer_node);\n       else if (cm->allocatable)\n-        {\n-          tree tmp2;\n+\t{\n+\t  tree tmp2;\n \n           gfc_init_se (&se, NULL);\n  \n \t  rss = gfc_walk_expr (expr);\n-          se.want_pointer = 0;\n-          gfc_conv_expr_descriptor (&se, expr, rss);\n+\t  se.want_pointer = 0;\n+\t  gfc_conv_expr_descriptor (&se, expr, rss);\n \t  gfc_add_block_to_block (&block, &se.pre);\n \n \t  tmp = fold_convert (TREE_TYPE (dest), se.expr);\n \t  gfc_add_modify_expr (&block, dest, tmp);\n \n-          if (cm->ts.type == BT_DERIVED && cm->ts.derived->attr.alloc_comp)\n+\t  if (cm->ts.type == BT_DERIVED && cm->ts.derived->attr.alloc_comp)\n \t    tmp = gfc_copy_alloc_comp (cm->ts.derived, se.expr, dest,\n \t\t\t\t       cm->as->rank);\n \t  else\n-            tmp = gfc_duplicate_allocatable (dest, se.expr,\n+\t    tmp = gfc_duplicate_allocatable (dest, se.expr,\n \t\t\t\t\t     TREE_TYPE(cm->backend_decl),\n \t\t\t\t\t     cm->as->rank);\n \n-          gfc_add_expr_to_block (&block, tmp);\n-\n-          gfc_add_block_to_block (&block, &se.post);\n-          gfc_conv_descriptor_data_set (&block, se.expr, null_pointer_node);\n+\t  gfc_add_expr_to_block (&block, tmp);\n \n-          /* Shift the lbound and ubound of temporaries to being unity, rather\n-             than zero, based.  Calculate the offset for all cases.  */\n-          offset = gfc_conv_descriptor_offset (dest);\n-          gfc_add_modify_expr (&block, offset, gfc_index_zero_node);\n-          tmp2 =gfc_create_var (gfc_array_index_type, NULL);\n-          for (n = 0; n < expr->rank; n++)\n-            {\n-              if (expr->expr_type != EXPR_VARIABLE\n-                  && expr->expr_type != EXPR_CONSTANT)\n-                {\n-                  tmp = gfc_conv_descriptor_ubound (dest, gfc_rank_cst[n]);\n-                  gfc_add_modify_expr (&block, tmp,\n-                                       fold_build2 (PLUS_EXPR,\n-\t\t\t\t      \t\t    gfc_array_index_type,\n-                                                    tmp, gfc_index_one_node));\n-                  tmp = gfc_conv_descriptor_lbound (dest, gfc_rank_cst[n]);\n-                  gfc_add_modify_expr (&block, tmp, gfc_index_one_node);\n-                }\n-              tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-                                 gfc_conv_descriptor_lbound (dest,\n+\t  gfc_add_block_to_block (&block, &se.post);\n+\t  gfc_conv_descriptor_data_set (&block, se.expr, null_pointer_node);\n+\n+\t  /* Shift the lbound and ubound of temporaries to being unity, rather\n+\t     than zero, based.  Calculate the offset for all cases.  */\n+\t  offset = gfc_conv_descriptor_offset (dest);\n+\t  gfc_add_modify_expr (&block, offset, gfc_index_zero_node);\n+\t  tmp2 =gfc_create_var (gfc_array_index_type, NULL);\n+\t  for (n = 0; n < expr->rank; n++)\n+\t    {\n+\t      if (expr->expr_type != EXPR_VARIABLE\n+\t\t    && expr->expr_type != EXPR_CONSTANT)\n+\t\t{\n+\t\t  tree span;\n+\t\t  tmp = gfc_conv_descriptor_ubound (dest, gfc_rank_cst[n]);\n+\t\t  span = fold_build2 (MINUS_EXPR, gfc_array_index_type, tmp,\n+\t\t\t    gfc_conv_descriptor_lbound (dest, gfc_rank_cst[n]));\n+\t\t  gfc_add_modify_expr (&block, tmp,\n+\t\t\t\t       fold_build2 (PLUS_EXPR,\n+\t\t\t\t\t\t    gfc_array_index_type,\n+\t\t\t\t\t\t    span, gfc_index_one_node));\n+\t\t  tmp = gfc_conv_descriptor_lbound (dest, gfc_rank_cst[n]);\n+\t\t  gfc_add_modify_expr (&block, tmp, gfc_index_one_node);\n+\t\t}\n+\t      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t gfc_conv_descriptor_lbound (dest,\n \t\t\t\t\t\t\t     gfc_rank_cst[n]),\n-                                 gfc_conv_descriptor_stride (dest,\n+\t\t\t\t gfc_conv_descriptor_stride (dest,\n \t\t\t\t\t\t\t     gfc_rank_cst[n]));\n-              gfc_add_modify_expr (&block, tmp2, tmp);\n-              tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp2);\n-              gfc_add_modify_expr (&block, offset, tmp);\n-            }\n-        }\n+\t      gfc_add_modify_expr (&block, tmp2, tmp);\n+\t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp2);\n+\t      gfc_add_modify_expr (&block, offset, tmp);\n+\t    }\n+\t}\n       else\n-        {\n+\t{\n \t  tmp = gfc_trans_subarray_assign (dest, cm, expr);\n \t  gfc_add_expr_to_block (&block, tmp);\n-        }\n+\t}\n     }\n   else if (expr->ts.type == BT_DERIVED)\n     {\n@@ -3497,9 +3500,17 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n \t    tmp = build3_v (COND_EXPR, cond, build_empty_stmt (), tmp);\n \t  gfc_add_expr_to_block (&lse->pre, tmp);\n \t}\n-\t\n-      gfc_add_block_to_block (&block, &lse->pre);\n-      gfc_add_block_to_block (&block, &rse->pre);\n+\n+      if (r_is_var)\n+\t{\n+\t  gfc_add_block_to_block (&block, &lse->pre);\n+\t  gfc_add_block_to_block (&block, &rse->pre);\n+\t}\n+      else\n+\t{\n+\t  gfc_add_block_to_block (&block, &rse->pre);\n+\t  gfc_add_block_to_block (&block, &lse->pre);\n+\t}\n \n       gfc_add_modify_expr (&block, lse->expr,\n \t\t\t   fold_convert (TREE_TYPE (lse->expr), rse->expr));"}, {"sha": "ec808dea0f08d65a06403ac5e49860f959202999", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28114dadadfeedf9de14b51e8e2a5e5859d619e3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28114dadadfeedf9de14b51e8e2a5e5859d619e3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=28114dadadfeedf9de14b51e8e2a5e5859d619e3", "patch": "@@ -1,3 +1,9 @@\n+2007-07-17  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/31320\n+\tPR fortran/32665\n+\t* gfortran.dg/alloc_comp_constructor_3.f90: New test.\n+\n 2007-07-17  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \tPR rtl-optimization/32773"}, {"sha": "53fa79c00f04adea17b2ae8a46485ba3ab1665ac", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_constructor_3.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28114dadadfeedf9de14b51e8e2a5e5859d619e3/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28114dadadfeedf9de14b51e8e2a5e5859d619e3/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_constructor_3.f90?ref=28114dadadfeedf9de14b51e8e2a5e5859d619e3", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! Tests the fix for PR32665 in which the structure initializer at line\n+! 13 was getting the array length wrong by one and in which the automatic\n+! deallocation of a in 14 was occurring before the evaluation of the rhs.\n+!\n+! Contributed by Daniel Franke <dfranke@gcc.gnu.org>\n+!\n+  TYPE :: x\n+    INTEGER, ALLOCATABLE :: a(:)\n+  END TYPE\n+  TYPE(x) :: a\n+\n+  a = x ((/ 1, 2, 3 /))                             ! This is also pr31320.\n+  a = x ((/ a%a, 4 /))\n+  if (any (a%a .ne. (/1,2,3,4/))) call abort ()\n+end"}]}