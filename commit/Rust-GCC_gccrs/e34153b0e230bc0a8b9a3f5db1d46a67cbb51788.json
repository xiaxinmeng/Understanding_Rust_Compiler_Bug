{"sha": "e34153b0e230bc0a8b9a3f5db1d46a67cbb51788", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM0MTUzYjBlMjMwYmMwYThiOWEzZjVkYjFkNDZhNjdjYmI1MTc4OA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-02T10:33:33Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-02T10:40:47Z"}, "message": "expansion: Fix up infinite recursion due to double-word modulo optimization\n\nJeff has reported that my earlier patch broke rl78-elf, e.g. with\nunsigned short foo (unsigned short x) { return x % 7; }\nwhen compiled with -O2 -mg14.  The problem is that rl78 is a BITS_PER_WORD\n== 8 target which doesn't have 8-bit modulo or divmod optab, but has instead\n16-bit divmod, so my patch attempted to optimize it, then called\nexpand_divmod to do 8-bit modulo and that in turn tried to do 16-bit modulo\nagain.\n\nThe following patch fixes it in two ways.\nOne is to not perform the optimization when we have {u,s}divmod_optab\nhandler for the double-word mode, in that case it is IMHO better to just\ndo whatever we used to do before.  This alone should fix the infinite\nrecursion.  But I'd be afraid some other target might have similar problem\nand might not have a divmod pattern, but only say a library call.\nSo the patch also introduces a methods argument to expand_divmod such that\nnormally we allow everything that was allowed before (using libcalls and\nwidening), but when called from these expand_doubleword*mod routines we\nrestrict it to no widening and no libcalls.\n\n2020-12-02  Jakub Jelinek  <jakub@redhat.com>\n\n\t* expmed.h (expand_divmod): Only declare if GCC_OPTABS_H is defined.\n\tAdd enum optabs_method argument defaulted to OPTAB_LIB_WIDEN.\n\t* expmed.c: Include expmed.h after optabs.h.\n\t(expand_divmod): Add methods argument, if it is not OPTAB_{,LIB_}WIDEN,\n\tdon't choose a wider mode, and pass it to other calls instead of\n\thardcoded OPTAB_LIB_WIDEN.  Avoid emitting libcalls if not\n\tOPTAB_LIB or OPTAB_LIB_WIDEN.\n\t* optabs.c: Include expmed.h after optabs.h.\n\t(expand_doubleword_mod, expand_doubleword_divmod): Pass OPTAB_DIRECT\n\tas last argument to expand_divmod.\n\t(expand_binop): Punt if {s,u}divmod_optab has handler for double-word\n\tint_mode.\n\t* expr.c: Include expmed.h after optabs.h.\n\t* explow.c: Include expmed.h after optabs.h.", "tree": {"sha": "e2df47d8da8ea8bae2100da5aed849fd05274c00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2df47d8da8ea8bae2100da5aed849fd05274c00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e34153b0e230bc0a8b9a3f5db1d46a67cbb51788", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e34153b0e230bc0a8b9a3f5db1d46a67cbb51788", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e34153b0e230bc0a8b9a3f5db1d46a67cbb51788", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e34153b0e230bc0a8b9a3f5db1d46a67cbb51788/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "037fe26ee1ac18581bf0ad646d48591c97d10bd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/037fe26ee1ac18581bf0ad646d48591c97d10bd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/037fe26ee1ac18581bf0ad646d48591c97d10bd3"}], "stats": {"total": 91, "additions": 53, "deletions": 38}, "files": [{"sha": "65f904a3d140e1a6dded842b4f62675d9c35d7af", "filename": "gcc/explow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e34153b0e230bc0a8b9a3f5db1d46a67cbb51788/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e34153b0e230bc0a8b9a3f5db1d46a67cbb51788/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=e34153b0e230bc0a8b9a3f5db1d46a67cbb51788", "patch": "@@ -27,9 +27,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"memmodel.h\"\n #include \"tm_p.h\"\n+#include \"optabs.h\"\n #include \"expmed.h\"\n #include \"profile-count.h\"\n-#include \"optabs.h\"\n #include \"emit-rtl.h\"\n #include \"recog.h\"\n #include \"diagnostic-core.h\""}, {"sha": "ce88f32296169a00cedb1f81a956203f948c12c9", "filename": "gcc/expmed.c", "status": "modified", "additions": 41, "deletions": 31, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e34153b0e230bc0a8b9a3f5db1d46a67cbb51788/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e34153b0e230bc0a8b9a3f5db1d46a67cbb51788/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=e34153b0e230bc0a8b9a3f5db1d46a67cbb51788", "patch": "@@ -31,8 +31,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"predict.h\"\n #include \"memmodel.h\"\n #include \"tm_p.h\"\n-#include \"expmed.h\"\n #include \"optabs.h\"\n+#include \"expmed.h\"\n #include \"regs.h\"\n #include \"emit-rtl.h\"\n #include \"diagnostic-core.h\"\n@@ -4193,7 +4193,8 @@ expand_sdiv_pow2 (scalar_int_mode mode, rtx op0, HOST_WIDE_INT d)\n \n rtx\n expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n-\t       rtx op0, rtx op1, rtx target, int unsignedp)\n+\t       rtx op0, rtx op1, rtx target, int unsignedp,\n+\t       enum optab_methods methods)\n {\n   machine_mode compute_mode;\n   rtx tquotient;\n@@ -4299,17 +4300,22 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n   optab2 = (op1_is_pow2 ? optab1\n \t    : (unsignedp ? udivmod_optab : sdivmod_optab));\n \n-  FOR_EACH_MODE_FROM (compute_mode, mode)\n-    if (optab_handler (optab1, compute_mode) != CODE_FOR_nothing\n-\t|| optab_handler (optab2, compute_mode) != CODE_FOR_nothing)\n-      break;\n-\n-  if (compute_mode == VOIDmode)\n-    FOR_EACH_MODE_FROM (compute_mode, mode)\n-      if (optab_libfunc (optab1, compute_mode)\n-\t  || optab_libfunc (optab2, compute_mode))\n+  if (methods == OPTAB_WIDEN || methods == OPTAB_LIB_WIDEN)\n+    {\n+      FOR_EACH_MODE_FROM (compute_mode, mode)\n+      if (optab_handler (optab1, compute_mode) != CODE_FOR_nothing\n+\t  || optab_handler (optab2, compute_mode) != CODE_FOR_nothing)\n \tbreak;\n \n+      if (compute_mode == VOIDmode && methods == OPTAB_LIB_WIDEN)\n+\tFOR_EACH_MODE_FROM (compute_mode, mode)\n+\t  if (optab_libfunc (optab1, compute_mode)\n+\t      || optab_libfunc (optab2, compute_mode))\n+\t    break;\n+    }\n+  else\n+    compute_mode = mode;\n+\n   /* If we still couldn't find a mode, use MODE, but expand_binop will\n      probably die.  */\n   if (compute_mode == VOIDmode)\n@@ -4412,8 +4418,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t\tremainder\n \t\t\t  = expand_binop (int_mode, and_optab, op0,\n \t\t\t\t\t  gen_int_mode (mask, int_mode),\n-\t\t\t\t\t  remainder, 1,\n-\t\t\t\t\t  OPTAB_LIB_WIDEN);\n+\t\t\t\t\t  remainder, 1, methods);\n \t\t\tif (remainder)\n \t\t\t  return gen_lowpart (mode, remainder);\n \t\t      }\n@@ -4721,7 +4726,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t\tremainder = expand_binop\n \t\t\t  (int_mode, and_optab, op0,\n \t\t\t   gen_int_mode (mask, int_mode),\n-\t\t\t   remainder, 0, OPTAB_LIB_WIDEN);\n+\t\t\t   remainder, 0, methods);\n \t\t\tif (remainder)\n \t\t\t  return gen_lowpart (mode, remainder);\n \t\t      }\n@@ -4846,7 +4851,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t  do_cmp_and_jump (op1, const0_rtx, LT, compute_mode, label2);\n \t  do_cmp_and_jump (adjusted_op0, const0_rtx, LT, compute_mode, label1);\n \t  tem = expand_binop (compute_mode, sdiv_optab, adjusted_op0, op1,\n-\t\t\t      quotient, 0, OPTAB_LIB_WIDEN);\n+\t\t\t      quotient, 0, methods);\n \t  if (tem != quotient)\n \t    emit_move_insn (quotient, tem);\n \t  emit_jump_insn (targetm.gen_jump (label5));\n@@ -4858,7 +4863,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t  emit_label (label2);\n \t  do_cmp_and_jump (adjusted_op0, const0_rtx, GT, compute_mode, label3);\n \t  tem = expand_binop (compute_mode, sdiv_optab, adjusted_op0, op1,\n-\t\t\t      quotient, 0, OPTAB_LIB_WIDEN);\n+\t\t\t      quotient, 0, methods);\n \t  if (tem != quotient)\n \t    emit_move_insn (quotient, tem);\n \t  emit_jump_insn (targetm.gen_jump (label5));\n@@ -4867,7 +4872,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t  expand_dec (adjusted_op0, const1_rtx);\n \t  emit_label (label4);\n \t  tem = expand_binop (compute_mode, sdiv_optab, adjusted_op0, op1,\n-\t\t\t      quotient, 0, OPTAB_LIB_WIDEN);\n+\t\t\t      quotient, 0, methods);\n \t  if (tem != quotient)\n \t    emit_move_insn (quotient, tem);\n \t  expand_dec (quotient, const1_rtx);\n@@ -4892,7 +4897,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t\t\t   floor_log2 (d), tquotient, 1);\n \t\tt2 = expand_binop (int_mode, and_optab, op0,\n \t\t\t\t   gen_int_mode (d - 1, int_mode),\n-\t\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\t\t\t\t   NULL_RTX, 1, methods);\n \t\tt3 = gen_reg_rtx (int_mode);\n \t\tt3 = emit_store_flag (t3, NE, t2, const0_rtx, int_mode, 1, 1);\n \t\tif (t3 == 0)\n@@ -4963,7 +4968,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t      emit_label (label1);\n \t      expand_dec (adjusted_op0, const1_rtx);\n \t      tem = expand_binop (compute_mode, udiv_optab, adjusted_op0, op1,\n-\t\t\t\t  quotient, 1, OPTAB_LIB_WIDEN);\n+\t\t\t\t  quotient, 1, methods);\n \t      if (tem != quotient)\n \t\temit_move_insn (quotient, tem);\n \t      expand_inc (quotient, const1_rtx);\n@@ -4987,7 +4992,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t\t\t   floor_log2 (d), tquotient, 0);\n \t\tt2 = expand_binop (compute_mode, and_optab, op0,\n \t\t\t\t   gen_int_mode (d - 1, compute_mode),\n-\t\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n+\t\t\t\t   NULL_RTX, 1, methods);\n \t\tt3 = gen_reg_rtx (compute_mode);\n \t\tt3 = emit_store_flag (t3, NE, t2, const0_rtx,\n \t\t\t\t      compute_mode, 1, 1);\n@@ -5063,7 +5068,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t      do_cmp_and_jump (adjusted_op0, const0_rtx, GT,\n \t\t\t       compute_mode, label1);\n \t      tem = expand_binop (compute_mode, sdiv_optab, adjusted_op0, op1,\n-\t\t\t\t  quotient, 0, OPTAB_LIB_WIDEN);\n+\t\t\t\t  quotient, 0, methods);\n \t      if (tem != quotient)\n \t\temit_move_insn (quotient, tem);\n \t      emit_jump_insn (targetm.gen_jump (label5));\n@@ -5076,7 +5081,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t      do_cmp_and_jump (adjusted_op0, const0_rtx, LT,\n \t\t\t       compute_mode, label3);\n \t      tem = expand_binop (compute_mode, sdiv_optab, adjusted_op0, op1,\n-\t\t\t\t  quotient, 0, OPTAB_LIB_WIDEN);\n+\t\t\t\t  quotient, 0, methods);\n \t      if (tem != quotient)\n \t\temit_move_insn (quotient, tem);\n \t      emit_jump_insn (targetm.gen_jump (label5));\n@@ -5085,7 +5090,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t      expand_inc (adjusted_op0, const1_rtx);\n \t      emit_label (label4);\n \t      tem = expand_binop (compute_mode, sdiv_optab, adjusted_op0, op1,\n-\t\t\t\t  quotient, 0, OPTAB_LIB_WIDEN);\n+\t\t\t\t  quotient, 0, methods);\n \t      if (tem != quotient)\n \t\temit_move_insn (quotient, tem);\n \t      expand_inc (quotient, const1_rtx);\n@@ -5133,10 +5138,10 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t      {\n \t\trtx tem;\n \t\tquotient = expand_binop (int_mode, udiv_optab, op0, op1,\n-\t\t\t\t\t quotient, 1, OPTAB_LIB_WIDEN);\n+\t\t\t\t\t quotient, 1, methods);\n \t\ttem = expand_mult (int_mode, quotient, op1, NULL_RTX, 1);\n \t\tremainder = expand_binop (int_mode, sub_optab, op0, tem,\n-\t\t\t\t\t  remainder, 1, OPTAB_LIB_WIDEN);\n+\t\t\t\t\t  remainder, 1, methods);\n \t      }\n \t    tem = plus_constant (int_mode, op1, -1);\n \t    tem = expand_shift (RSHIFT_EXPR, int_mode, tem, 1, NULL_RTX, 1);\n@@ -5158,10 +5163,10 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t      {\n \t\trtx tem;\n \t\tquotient = expand_binop (int_mode, sdiv_optab, op0, op1,\n-\t\t\t\t\t quotient, 0, OPTAB_LIB_WIDEN);\n+\t\t\t\t\t quotient, 0, methods);\n \t\ttem = expand_mult (int_mode, quotient, op1, NULL_RTX, 0);\n \t\tremainder = expand_binop (int_mode, sub_optab, op0, tem,\n-\t\t\t\t\t  remainder, 0, OPTAB_LIB_WIDEN);\n+\t\t\t\t\t  remainder, 0, methods);\n \t      }\n \t    abs_rem = expand_abs (int_mode, remainder, NULL_RTX, 1, 0);\n \t    abs_op1 = expand_abs (int_mode, op1, NULL_RTX, 1, 0);\n@@ -5258,7 +5263,7 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\tquotient = sign_expand_binop (compute_mode,\n \t\t\t\t\t      udiv_optab, sdiv_optab,\n \t\t\t\t\t      op0, op1, target,\n-\t\t\t\t\t      unsignedp, OPTAB_LIB_WIDEN);\n+\t\t\t\t\t      unsignedp, methods);\n \t    }\n \t}\n     }\n@@ -5273,10 +5278,11 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t  /* No divide instruction either.  Use library for remainder.  */\n \t  remainder = sign_expand_binop (compute_mode, umod_optab, smod_optab,\n \t\t\t\t\t op0, op1, target,\n-\t\t\t\t\t unsignedp, OPTAB_LIB_WIDEN);\n+\t\t\t\t\t unsignedp, methods);\n \t  /* No remainder function.  Try a quotient-and-remainder\n \t     function, keeping the remainder.  */\n-\t  if (!remainder)\n+\t  if (!remainder\n+\t      && (methods == OPTAB_LIB || methods == OPTAB_LIB_WIDEN))\n \t    {\n \t      remainder = gen_reg_rtx (compute_mode);\n \t      if (!expand_twoval_binop_libfunc\n@@ -5294,10 +5300,14 @@ expand_divmod (int rem_flag, enum tree_code code, machine_mode mode,\n \t\t\t\t   NULL_RTX, unsignedp);\n \t  remainder = expand_binop (compute_mode, sub_optab, op0,\n \t\t\t\t    remainder, target, unsignedp,\n-\t\t\t\t    OPTAB_LIB_WIDEN);\n+\t\t\t\t    methods);\n \t}\n     }\n \n+  if (methods != OPTAB_LIB_WIDEN\n+      && (rem_flag ? remainder : quotient) == NULL_RTX)\n+    return NULL_RTX;\n+\n   return gen_lowpart (mode, rem_flag ? remainder : quotient);\n }\n \f"}, {"sha": "6a9bab70911dd4e94fa1fda2e69e983765851a62", "filename": "gcc/expmed.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e34153b0e230bc0a8b9a3f5db1d46a67cbb51788/gcc%2Fexpmed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e34153b0e230bc0a8b9a3f5db1d46a67cbb51788/gcc%2Fexpmed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.h?ref=e34153b0e230bc0a8b9a3f5db1d46a67cbb51788", "patch": "@@ -716,8 +716,10 @@ extern rtx expand_variable_shift (enum tree_code, machine_mode,\n \t\t\t\t  rtx, tree, rtx, int);\n extern rtx expand_shift (enum tree_code, machine_mode, rtx, poly_int64, rtx,\n \t\t\t int);\n+#ifdef GCC_OPTABS_H\n extern rtx expand_divmod (int, enum tree_code, machine_mode, rtx, rtx,\n-\t\t\t  rtx, int);\n+\t\t\t  rtx, int, enum optab_methods = OPTAB_LIB_WIDEN);\n+#endif\n #endif\n \n extern void store_bit_field (rtx, poly_uint64, poly_uint64,"}, {"sha": "798285eb52caf836d32b67517e8efbb63fe7bdaa", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e34153b0e230bc0a8b9a3f5db1d46a67cbb51788/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e34153b0e230bc0a8b9a3f5db1d46a67cbb51788/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e34153b0e230bc0a8b9a3f5db1d46a67cbb51788", "patch": "@@ -29,8 +29,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"memmodel.h\"\n #include \"tm_p.h\"\n #include \"ssa.h\"\n-#include \"expmed.h\"\n #include \"optabs.h\"\n+#include \"expmed.h\"\n #include \"regs.h\"\n #include \"emit-rtl.h\"\n #include \"recog.h\""}, {"sha": "bdc692bbc73503def6df9ced302a2cb880b01f56", "filename": "gcc/optabs.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e34153b0e230bc0a8b9a3f5db1d46a67cbb51788/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e34153b0e230bc0a8b9a3f5db1d46a67cbb51788/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=e34153b0e230bc0a8b9a3f5db1d46a67cbb51788", "patch": "@@ -28,8 +28,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"memmodel.h\"\n #include \"predict.h\"\n #include \"tm_p.h\"\n-#include \"expmed.h\"\n #include \"optabs.h\"\n+#include \"expmed.h\"\n #include \"emit-rtl.h\"\n #include \"recog.h\"\n #include \"diagnostic-core.h\"\n@@ -1082,7 +1082,7 @@ expand_doubleword_mod (machine_mode mode, rtx op0, rtx op1, bool unsignedp)\n \t    }\n \t}\n       rtx remainder = expand_divmod (1, TRUNC_MOD_EXPR, word_mode, sum, op1,\n-\t\t\t\t     NULL_RTX, 1);\n+\t\t\t\t     NULL_RTX, 1, OPTAB_DIRECT);\n       if (remainder == NULL_RTX)\n \treturn NULL_RTX;\n \n@@ -1180,7 +1180,7 @@ expand_doubleword_divmod (machine_mode mode, rtx op0, rtx op1, rtx *rem,\n   if (op11 != const1_rtx)\n     {\n       rtx rem2 = expand_divmod (1, TRUNC_MOD_EXPR, mode, quot1, op11,\n-\t\t\t\tNULL_RTX, unsignedp);\n+\t\t\t\tNULL_RTX, unsignedp, OPTAB_DIRECT);\n       if (rem2 == NULL_RTX)\n \treturn NULL_RTX;\n \n@@ -1195,7 +1195,7 @@ expand_doubleword_divmod (machine_mode mode, rtx op0, rtx op1, rtx *rem,\n \treturn NULL_RTX;\n \n       rtx quot2 = expand_divmod (0, TRUNC_DIV_EXPR, mode, quot1, op11,\n-\t\t\t\t NULL_RTX, unsignedp);\n+\t\t\t\t NULL_RTX, unsignedp, OPTAB_DIRECT);\n       if (quot2 == NULL_RTX)\n \treturn NULL_RTX;\n \n@@ -2100,6 +2100,9 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       && CONST_INT_P (op1)\n       && is_int_mode (mode, &int_mode)\n       && GET_MODE_SIZE (int_mode) == 2 * UNITS_PER_WORD\n+      && optab_handler ((binoptab == umod_optab || binoptab == udiv_optab)\n+\t\t\t? udivmod_optab : sdivmod_optab,\n+\t\t\tint_mode) == CODE_FOR_nothing\n       && optab_handler (and_optab, word_mode) != CODE_FOR_nothing\n       && optab_handler (add_optab, word_mode) != CODE_FOR_nothing\n       && optimize_insn_for_speed_p ())"}]}