{"sha": "d8202b848c1d8b270fb9f82c8e91b507ec266cdb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDgyMDJiODQ4YzFkOGIyNzBmYjlmODJjOGU5MWI1MDdlYzI2NmNkYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-10-31T13:51:38Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-10-31T13:51:38Z"}, "message": "tree-cfg.c (assert_unreachable_fallthru_edge_p): New function.\n\n\t* tree-cfg.c (assert_unreachable_fallthru_edge_p): New function.\n\t* tree-cfg.h (assert_unreachable_fallthru_edge_p): New prototype.\n\t* tree-vrp.c (all_imm_uses_in_stmt_or_feed_cond): New function.\n\t(remove_range_assertions): If ASSERT_EXPR_VAR has no other immediate\n\tuses but in the condition and ASSERT_EXPR and the other successor of\n\tthe predecessor bb is __builtin_unreachable (), set_range_info of the\n\tASSERT_EXPR_VAR to the range info of the ASSERT_EXPR's lhs.\n\nFrom-SVN: r204255", "tree": {"sha": "dffa484c461c05b7e871c844f87d11d31d6fe5d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dffa484c461c05b7e871c844f87d11d31d6fe5d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8202b848c1d8b270fb9f82c8e91b507ec266cdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8202b848c1d8b270fb9f82c8e91b507ec266cdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8202b848c1d8b270fb9f82c8e91b507ec266cdb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8202b848c1d8b270fb9f82c8e91b507ec266cdb/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b319f79c92d4e8aad6c7a73e9a31a8cd93b372d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b319f79c92d4e8aad6c7a73e9a31a8cd93b372d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b319f79c92d4e8aad6c7a73e9a31a8cd93b372d4"}], "stats": {"total": 132, "additions": 123, "deletions": 9}, "files": [{"sha": "e46ad1529a3695c6d4520c44685fa58dbe6e0892", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8202b848c1d8b270fb9f82c8e91b507ec266cdb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8202b848c1d8b270fb9f82c8e91b507ec266cdb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d8202b848c1d8b270fb9f82c8e91b507ec266cdb", "patch": "@@ -1,3 +1,13 @@\n+2013-10-31  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* tree-cfg.c (assert_unreachable_fallthru_edge_p): New function.\n+\t* tree-cfg.h (assert_unreachable_fallthru_edge_p): New prototype.\n+\t* tree-vrp.c (all_imm_uses_in_stmt_or_feed_cond): New function.\n+\t(remove_range_assertions): If ASSERT_EXPR_VAR has no other immediate\n+\tuses but in the condition and ASSERT_EXPR and the other successor of\n+\tthe predecessor bb is __builtin_unreachable (), set_range_info of the\n+\tASSERT_EXPR_VAR to the range info of the ASSERT_EXPR's lhs.\n+\n 2013-10-31  Martin Jambor  <mjambor@suse.cz>\n \n \tPR rtl-optimization/58934"}, {"sha": "d646693903259340de65f4f5beb20a4f59df8e02", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8202b848c1d8b270fb9f82c8e91b507ec266cdb/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8202b848c1d8b270fb9f82c8e91b507ec266cdb/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=d8202b848c1d8b270fb9f82c8e91b507ec266cdb", "patch": "@@ -381,6 +381,50 @@ computed_goto_p (gimple t)\n \t  && TREE_CODE (gimple_goto_dest (t)) != LABEL_DECL);\n }\n \n+/* Returns true for edge E where e->src ends with a GIMPLE_COND and\n+   the other edge points to a bb with just __builtin_unreachable ().\n+   I.e. return true for C->M edge in:\n+   <bb C>:\n+   ...\n+   if (something)\n+     goto <bb N>;\n+   else\n+     goto <bb M>;\n+   <bb N>:\n+   __builtin_unreachable ();\n+   <bb M>:  */\n+\n+bool\n+assert_unreachable_fallthru_edge_p (edge e)\n+{\n+  basic_block pred_bb = e->src;\n+  gimple last = last_stmt (pred_bb);\n+  if (last && gimple_code (last) == GIMPLE_COND)\n+    {\n+      basic_block other_bb = EDGE_SUCC (pred_bb, 0)->dest;\n+      if (other_bb == e->dest)\n+\tother_bb = EDGE_SUCC (pred_bb, 1)->dest;\n+      if (EDGE_COUNT (other_bb->succs) == 0)\n+\t{\n+\t  gimple_stmt_iterator gsi = gsi_after_labels (other_bb);\n+\t  gimple stmt;\n+\n+\t  if (gsi_end_p (gsi))\n+\t    return false;\n+\t  stmt = gsi_stmt (gsi);\n+\t  if (is_gimple_debug (stmt))\n+\t    {\n+\t      gsi_next_nondebug (&gsi);\n+\t      if (gsi_end_p (gsi))\n+\t\treturn false;\n+\t      stmt = gsi_stmt (gsi);\n+\t    }\n+\t  return gimple_call_builtin_p (stmt, BUILT_IN_UNREACHABLE);\n+\t}\n+    }\n+  return false;\n+}\n+\n \n /* Search the CFG for any computed gotos.  If found, factor them to a\n    common computed goto site.  Also record the location of that site so"}, {"sha": "c5c105dbdaa980b27bca13d658da225f5d0ba5b3", "filename": "gcc/tree-cfg.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8202b848c1d8b270fb9f82c8e91b507ec266cdb/gcc%2Ftree-cfg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8202b848c1d8b270fb9f82c8e91b507ec266cdb/gcc%2Ftree-cfg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.h?ref=d8202b848c1d8b270fb9f82c8e91b507ec266cdb", "patch": "@@ -51,6 +51,7 @@ extern bool is_ctrl_stmt (gimple);\n extern bool is_ctrl_altering_stmt (gimple);\n extern bool simple_goto_p (gimple);\n extern bool stmt_ends_bb_p (gimple);\n+extern bool assert_unreachable_fallthru_edge_p (edge);\n extern void delete_tree_cfg_annotations (void);\n extern gimple first_stmt (basic_block);\n extern gimple last_stmt (basic_block);"}, {"sha": "a28e9369660520ad6124838ac1e4c349fa28a62c", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 68, "deletions": 9, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8202b848c1d8b270fb9f82c8e91b507ec266cdb/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8202b848c1d8b270fb9f82c8e91b507ec266cdb/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=d8202b848c1d8b270fb9f82c8e91b507ec266cdb", "patch": "@@ -6459,6 +6459,33 @@ check_all_array_refs (void)\n     }\n }\n \n+/* Return true if all imm uses of VAR are either in STMT, or\n+   feed (optionally through a chain of single imm uses) GIMPLE_COND\n+   in basic block COND_BB.  */\n+\n+static bool\n+all_imm_uses_in_stmt_or_feed_cond (tree var, gimple stmt, basic_block cond_bb)\n+{\n+  use_operand_p use_p, use2_p;\n+  imm_use_iterator iter;\n+\n+  FOR_EACH_IMM_USE_FAST (use_p, iter, var)\n+    if (USE_STMT (use_p) != stmt)\n+      {\n+\tgimple use_stmt = USE_STMT (use_p);\n+\tif (is_gimple_debug (use_stmt))\n+\t  continue;\n+\twhile (is_gimple_assign (use_stmt)\n+\t       && single_imm_use (gimple_assign_lhs (use_stmt),\n+\t\t\t\t  &use2_p, &use_stmt))\n+\t  ;\n+\tif (gimple_code (use_stmt) != GIMPLE_COND\n+\t    || gimple_bb (use_stmt) != cond_bb)\n+\t  return false;\n+      }\n+  return true;\n+}\n+\n /* Convert range assertion expressions into the implied copies and\n    copy propagate away the copies.  Doing the trivial copy propagation\n    here avoids the need to run the full copy propagation pass after\n@@ -6488,19 +6515,24 @@ remove_range_assertions (void)\n {\n   basic_block bb;\n   gimple_stmt_iterator si;\n+  /* 1 if looking at ASSERT_EXPRs immediately at the beginning of\n+     a basic block preceeded by GIMPLE_COND branching to it and\n+     __builtin_trap, -1 if not yet checked, 0 otherwise.  */\n+  int is_unreachable;\n \n   /* Note that the BSI iterator bump happens at the bottom of the\n      loop and no bump is necessary if we're removing the statement\n      referenced by the current BSI.  */\n   FOR_EACH_BB (bb)\n-    for (si = gsi_start_bb (bb); !gsi_end_p (si);)\n+    for (si = gsi_after_labels (bb), is_unreachable = -1; !gsi_end_p (si);)\n       {\n \tgimple stmt = gsi_stmt (si);\n \tgimple use_stmt;\n \n \tif (is_gimple_assign (stmt)\n \t    && gimple_assign_rhs_code (stmt) == ASSERT_EXPR)\n \t  {\n+\t    tree lhs = gimple_assign_lhs (stmt);\n \t    tree rhs = gimple_assign_rhs1 (stmt);\n \t    tree var;\n \t    tree cond = fold (ASSERT_EXPR_COND (rhs));\n@@ -6509,22 +6541,49 @@ remove_range_assertions (void)\n \n \t    gcc_assert (cond != boolean_false_node);\n \n-\t    /* Propagate the RHS into every use of the LHS.  */\n \t    var = ASSERT_EXPR_VAR (rhs);\n-\t    FOR_EACH_IMM_USE_STMT (use_stmt, iter,\n-\t\t\t\t   gimple_assign_lhs (stmt))\n+\t    gcc_assert (TREE_CODE (var) == SSA_NAME);\n+\n+\t    if (!POINTER_TYPE_P (TREE_TYPE (lhs))\n+\t\t&& SSA_NAME_RANGE_INFO (lhs))\n+\t      {\n+\t\tif (is_unreachable == -1)\n+\t\t  {\n+\t\t    is_unreachable = 0;\n+\t\t    if (single_pred_p (bb)\n+\t\t\t&& assert_unreachable_fallthru_edge_p\n+\t\t\t\t\t\t    (single_pred_edge (bb)))\n+\t\t      is_unreachable = 1;\n+\t\t  }\n+\t\t/* Handle\n+\t\t   if (x_7 >= 10 && x_7 < 20)\n+\t\t     __builtin_unreachable ();\n+\t\t   x_8 = ASSERT_EXPR <x_7, ...>;\n+\t\t   if the only uses of x_7 are in the ASSERT_EXPR and\n+\t\t   in the condition.  In that case, we can copy the\n+\t\t   range info from x_8 computed in this pass also\n+\t\t   for x_7.  */\n+\t\tif (is_unreachable\n+\t\t    && all_imm_uses_in_stmt_or_feed_cond (var, stmt,\n+\t\t\t\t\t\t\t  single_pred (bb)))\n+\t\t  set_range_info (var, SSA_NAME_RANGE_INFO (lhs)->min,\n+\t\t\t\t  SSA_NAME_RANGE_INFO (lhs)->max);\n+\t      }\n+\n+\t    /* Propagate the RHS into every use of the LHS.  */\n+\t    FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n \t      FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n-\t\t{\n-\t\t  SET_USE (use_p, var);\n-\t\t  gcc_assert (TREE_CODE (var) == SSA_NAME);\n-\t\t}\n+\t\tSET_USE (use_p, var);\n \n \t    /* And finally, remove the copy, it is not needed.  */\n \t    gsi_remove (&si, true);\n \t    release_defs (stmt);\n \t  }\n \telse\n-\t  gsi_next (&si);\n+\t  {\n+\t    gsi_next (&si);\n+\t    is_unreachable = 0;\n+\t  }\n       }\n }\n "}]}