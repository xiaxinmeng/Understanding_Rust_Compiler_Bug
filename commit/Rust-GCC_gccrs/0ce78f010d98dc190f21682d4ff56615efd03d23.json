{"sha": "0ce78f010d98dc190f21682d4ff56615efd03d23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNlNzhmMDEwZDk4ZGMxOTBmMjE2ODJkNGZmNTY2MTVlZmQwM2QyMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2004-01-25T06:58:33Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2004-01-25T06:58:33Z"}, "message": "ffi.c (ffi_prep_args_v9): Shift the parameter array when the structure return address is passed in %o0.\n\n\t* src/sparc/ffi.c (ffi_prep_args_v9): Shift the parameter array\n\twhen the structure return address is passed in %o0.\n\t(ffi_V9_return_struct): Rename into ffi_v9_layout_struct.\n\t(ffi_v9_layout_struct): Align the field following a nested structure\n\ton a word boundary.  Use memmove instead of memcpy.\n\t(ffi_call): Update call to ffi_V9_return_struct.\n\t(ffi_prep_closure): Define 'ctx' only for V8.\n\t(ffi_closure_sparc_inner): Clone into ffi_closure_sparc_inner_v8\n\tand ffi_closure_sparc_inner_v9.\n\t(ffi_closure_sparc_inner_v8): Return long doubles by reference.\n\tAlways skip the structure return address.  For structures and long\n\tdoubles, copy the argument directly.\n\t(ffi_closure_sparc_inner_v9): Skip the structure return address only\n\tif required.  Shift the maximum floating-point slot accordingly.  For\n\tbig structures, copy the argument directly; otherwise, left-justify the\n\targument and call ffi_v9_layout_struct to lay out the structure on\n\tthe stack.\n\t* src/sparc/v8.S: Undef STACKFRAME before defining it.\n\t(ffi_closure_v8): Pass the structure return address.  Update call to\n\tffi_closure_sparc_inner_v8.  Short-circuit FFI_TYPE_INT handling.\n\tSkip the 'unimp' insn when returning long doubles and structures.\n\t* src/sparc/v9.S: Undef STACKFRAME before defining it.\n\t(ffi_closure_v9): Increase the frame size by 2 words.  Short-circuit\n\tFFI_TYPE_INT handling.  Load structures both in integers and\n\tfloating-point registers on return.\n\t* README: Update status of the SPARC port.\n\nFrom-SVN: r76543", "tree": {"sha": "7445f9705e38d94597a97bcbe627b6fad908defe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7445f9705e38d94597a97bcbe627b6fad908defe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ce78f010d98dc190f21682d4ff56615efd03d23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ce78f010d98dc190f21682d4ff56615efd03d23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ce78f010d98dc190f21682d4ff56615efd03d23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ce78f010d98dc190f21682d4ff56615efd03d23/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bd915f51cfc98e3ad406f30b9aa67b85c57f8b9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd915f51cfc98e3ad406f30b9aa67b85c57f8b9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd915f51cfc98e3ad406f30b9aa67b85c57f8b9c"}], "stats": {"total": 314, "additions": 219, "deletions": 95}, "files": [{"sha": "c2df6b7a19d0f4104634572f9788562cb261e0db", "filename": "libffi/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ce78f010d98dc190f21682d4ff56615efd03d23/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ce78f010d98dc190f21682d4ff56615efd03d23/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=0ce78f010d98dc190f21682d4ff56615efd03d23", "patch": "@@ -1,3 +1,32 @@\n+2004-01-25  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* src/sparc/ffi.c (ffi_prep_args_v9): Shift the parameter array\n+\twhen the structure return address is passed in %o0.\n+\t(ffi_V9_return_struct): Rename into ffi_v9_layout_struct.\n+\t(ffi_v9_layout_struct): Align the field following a nested structure\n+\ton a word boundary.  Use memmove instead of memcpy.\n+\t(ffi_call): Update call to ffi_V9_return_struct.\n+\t(ffi_prep_closure): Define 'ctx' only for V8.\n+\t(ffi_closure_sparc_inner): Clone into ffi_closure_sparc_inner_v8\n+\tand ffi_closure_sparc_inner_v9.\n+\t(ffi_closure_sparc_inner_v8): Return long doubles by reference.\n+\tAlways skip the structure return address.  For structures and long\n+\tdoubles, copy the argument directly.\n+\t(ffi_closure_sparc_inner_v9): Skip the structure return address only\n+\tif required.  Shift the maximum floating-point slot accordingly.  For\n+\tbig structures, copy the argument directly; otherwise, left-justify the\n+\targument and call ffi_v9_layout_struct to lay out the structure on\n+\tthe stack.\n+\t* src/sparc/v8.S: Undef STACKFRAME before defining it.\n+\t(ffi_closure_v8): Pass the structure return address.  Update call to\n+\tffi_closure_sparc_inner_v8.  Short-circuit FFI_TYPE_INT handling.\n+\tSkip the 'unimp' insn when returning long doubles and structures.\n+\t* src/sparc/v9.S: Undef STACKFRAME before defining it.\n+\t(ffi_closure_v9): Increase the frame size by 2 words.  Short-circuit\n+\tFFI_TYPE_INT handling.  Load structures both in integers and\n+\tfloating-point registers on return.\n+\t* README: Update status of the SPARC port.\n+\n 2004-01-24  Andreas Tobler  <a.tobler@schweiz.ch>\n \n \t* testsuite/libffi.call/pyobjc-tc.c (main): Treat result value"}, {"sha": "1fc27470d0a352b92497f1d1a07e971a6e257c45", "filename": "libffi/README", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ce78f010d98dc190f21682d4ff56615efd03d23/libffi%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ce78f010d98dc190f21682d4ff56615efd03d23/libffi%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FREADME?ref=0ce78f010d98dc190f21682d4ff56615efd03d23", "patch": "@@ -46,7 +46,7 @@ Supported Platforms and Prerequisites\n \n Libffi has been ported to:\n \n-\tSunOS 4.1.3 & Solaris 2.x (Sparc v8)\n+\tSunOS 4.1.3 & Solaris 2.x (SPARC-V8, SPARC-V9)\n \n \tIrix 5.3 & 6.2 (System V/o32 & n32)\n \n@@ -306,15 +306,9 @@ Platform Specific Notes\n \n There are no known problems with the x86 port.\n \n-\tSun Sparc - SunOS 4.1.3 & Solaris 2.x\n+\tSun SPARC - SunOS 4.1.3 & Solaris 2.x\n \t-------------------------------------\n \n-There's a bug in the structure passing code for sparc processors.\n-Struct arguments that are passed in value actually end up being passed\n-by reference. This will be fixed Real Soon Now.\n-\n-\"long long\" values are not supported yet.\n-\n You must use GNU Make to build libffi on Sun platforms.\n \n \tMIPS - Irix 5.3 & 6.x"}, {"sha": "ad15bee986c8891cc62dc00a7c12d39e506d6814", "filename": "libffi/src/sparc/ffi.c", "status": "modified", "additions": 122, "deletions": 42, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ce78f010d98dc190f21682d4ff56615efd03d23/libffi%2Fsrc%2Fsparc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ce78f010d98dc190f21682d4ff56615efd03d23/libffi%2Fsrc%2Fsparc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fffi.c?ref=0ce78f010d98dc190f21682d4ff56615efd03d23", "patch": "@@ -1,7 +1,7 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 1996, 2003 Red Hat, Inc.\n+   ffi.c - Copyright (c) 1996, 2003, 2004 Red Hat, Inc.\n    \n-   Sparc Foreign Function Interface \n+   SPARC Foreign Function Interface \n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -28,11 +28,6 @@\n \n #include <stdlib.h>\n \n-#ifdef SPARC64\n-extern void ffi_closure_v9(void);\n-#else\n-extern void ffi_closure_v8(void);\n-#endif\n \n /* ffi_prep_args is called by the assembly routine once stack space\n    has been allocated for the function's arguments */\n@@ -154,6 +149,7 @@ int ffi_prep_args_v9(char *stack, extended_cif *ecif)\n       ecif->cif->rtype->size > 32)\n     {\n       *(unsigned long long *) argp = (unsigned long)ecif->rvalue;\n+      argp += sizeof(long long);\n       tmp = 1;\n     }\n \n@@ -326,7 +322,7 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n   return FFI_OK;\n }\n \n-int ffi_V9_return_struct(ffi_type *arg, int off, char *ret, char *intg, char *flt)\n+int ffi_v9_layout_struct(ffi_type *arg, int off, char *ret, char *intg, char *flt)\n {\n   ffi_type **ptr = &arg->elements[0];\n \n@@ -338,18 +334,19 @@ int ffi_V9_return_struct(ffi_type *arg, int off, char *ret, char *intg, char *fl\n       switch ((*ptr)->type)\n \t{\n \tcase FFI_TYPE_STRUCT:\n-\t  off = ffi_V9_return_struct(*ptr, off, ret, intg, flt);\n+\t  off = ffi_v9_layout_struct(*ptr, off, ret, intg, flt);\n+\t  off = ALIGN(off, FFI_SIZEOF_ARG);\n \t  break;\n \tcase FFI_TYPE_FLOAT:\n \tcase FFI_TYPE_DOUBLE:\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n \tcase FFI_TYPE_LONGDOUBLE:\n #endif\n-\t  memcpy(ret + off, flt + off, (*ptr)->size);\n+\t  memmove(ret + off, flt + off, (*ptr)->size);\n \t  off += (*ptr)->size;\n \t  break;\n \tdefault:\n-\t  memcpy(ret + off, intg + off, (*ptr)->size);\n+\t  memmove(ret + off, intg + off, (*ptr)->size);\n \t  off += (*ptr)->size;\n \t  break;\n \t}\n@@ -358,10 +355,14 @@ int ffi_V9_return_struct(ffi_type *arg, int off, char *ret, char *intg, char *fl\n   return off;\n }\n \n-extern int ffi_call_V8(void *, extended_cif *, unsigned, \n+\n+#ifdef SPARC64\n+extern int ffi_call_v9(void *, extended_cif *, unsigned, \n \t\t       unsigned, unsigned *, void (*fn)());\n-extern int ffi_call_V9(void *, extended_cif *, unsigned, \n+#else\n+extern int ffi_call_v8(void *, extended_cif *, unsigned, \n \t\t       unsigned, unsigned *, void (*fn)());\n+#endif\n \n void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n {\n@@ -394,16 +395,16 @@ void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n       /* We don't yet support calling 32bit code from 64bit */\n       FFI_ASSERT(0);\n #else\n-      ffi_call_V8(ffi_prep_args_v8, &ecif, cif->bytes, \n+      ffi_call_v8(ffi_prep_args_v8, &ecif, cif->bytes, \n \t\t  cif->flags, rvalue, fn);\n #endif\n       break;\n     case FFI_V9:\n #ifdef SPARC64\n-      ffi_call_V9(ffi_prep_args_v9, &ecif, cif->bytes,\n+      ffi_call_v9(ffi_prep_args_v9, &ecif, cif->bytes,\n \t\t  cif->flags, rval, fn);\n       if (rvalue && rval && cif->rtype->type == FFI_TYPE_STRUCT)\n-\tffi_V9_return_struct(cif->rtype, 0, (char *)rvalue, (char *)rval, ((char *)rval)+32);\n+\tffi_v9_layout_struct(cif->rtype, 0, (char *)rvalue, (char *)rval, ((char *)rval)+32);\n #else\n       /* And vice versa */\n       FFI_ASSERT(0);\n@@ -416,6 +417,13 @@ void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n \n }\n \n+\n+#ifdef SPARC64\n+extern void ffi_closure_v9(void);\n+#else\n+extern void ffi_closure_v8(void);\n+#endif\n+\n ffi_status\n ffi_prep_closure (ffi_closure* closure,\n \t\t  ffi_cif* cif,\n@@ -424,8 +432,6 @@ ffi_prep_closure (ffi_closure* closure,\n {\n   unsigned int *tramp = (unsigned int *) &closure->tramp[0];\n   unsigned long fn;\n-  unsigned long ctx = (unsigned long) closure;\n-\n #ifdef SPARC64\n   /* Trampoline address is equal to the closure address.  We take advantage\n      of that to reduce the trampoline size by 8 bytes. */\n@@ -437,6 +443,7 @@ ffi_prep_closure (ffi_closure* closure,\n   tramp[3] = 0x01000000;\t/* nop\t\t\t*/\n   *((unsigned long *) &tramp[4]) = fn;\n #else\n+  unsigned long ctx = (unsigned long) closure;\n   FFI_ASSERT (cif->abi == FFI_V8);\n   fn = (unsigned long) ffi_closure_v8;\n   tramp[0] = 0x03000000 | fn >> 10;\t/* sethi %hi(fn), %g1\t*/\n@@ -462,49 +469,122 @@ ffi_prep_closure (ffi_closure* closure,\n }\n \n int\n-ffi_closure_sparc_inner(ffi_closure *closure,\n-  void *rvalue, unsigned long *gpr, double *fpr)\n+ffi_closure_sparc_inner_v8(ffi_closure *closure,\n+  void *rvalue, unsigned long *gpr)\n {\n   ffi_cif *cif;\n-  void **avalue;\n   ffi_type **arg_types;\n-  int i, avn, argn;\n+  void **avalue;\n+  int i, argn;\n \n   cif = closure->cif;\n+  arg_types = cif->arg_types;\n   avalue = alloca(cif->nargs * sizeof(void *));\n \n-  argn = 0;\n+  /* Copy the caller's structure return address so that the closure\n+     returns the data directly to the caller.  */\n+  if (cif->flags == FFI_TYPE_STRUCT\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE  \n+      || cif->flags == FFI_TYPE_LONGDOUBLE\n+#endif\n+     )\n+    rvalue = (void *) gpr[0];\n+\n+  /* Always skip the structure return address.  */\n+  argn = 1;\n+\n+  /* Grab the addresses of the arguments from the stack frame.  */\n+  for (i = 0; i < cif->nargs; i++)\n+    {\n+      if (arg_types[i]->type == FFI_TYPE_STRUCT\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\t  || arg_types[i]->type == FFI_TYPE_LONGDOUBLE\n+#endif\n+         )\n+\t{\n+\t  /* Straight copy of invisible reference.  */\n+\t  avalue[i] = (void *)gpr[argn++];\n+\t}\n+      else\n+\t{\n+\t  /* Always right-justify.  */\n+\t  argn += ALIGN(arg_types[i]->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n+\t  avalue[i] = ((char *) &gpr[argn]) - arg_types[i]->size;\n+\t}\n+    }\n \n-  /* Copy the caller's structure return address to that the closure\n+  /* Invoke the closure.  */\n+  (closure->fun) (cif, rvalue, avalue, closure->user_data);\n+\n+  /* Tell ffi_closure_sparc how to perform return type promotions.  */\n+  return cif->rtype->type;\n+}\n+\n+int\n+ffi_closure_sparc_inner_v9(ffi_closure *closure,\n+  void *rvalue, unsigned long *gpr, double *fpr)\n+{\n+  ffi_cif *cif;\n+  ffi_type **arg_types;\n+  void **avalue;\n+  int i, argn, fp_slot_max;\n+\n+  cif = closure->cif;\n+  arg_types = cif->arg_types;\n+  avalue = alloca(cif->nargs * sizeof(void *));\n+\n+  /* Copy the caller's structure return address so that the closure\n      returns the data directly to the caller.  */\n-  if (cif->flags == FFI_TYPE_STRUCT)\n+  if (cif->flags == FFI_TYPE_VOID\n+      && cif->rtype->type == FFI_TYPE_STRUCT)\n     {\n       rvalue = (void *) gpr[0];\n+      /* Skip the structure return address.  */\n       argn = 1;\n     }\n+  else\n+    argn = 0;\n+\n+  fp_slot_max = 16 - argn;\n \n-  i = 0;\n-  avn = cif->nargs;\n-  arg_types = cif->arg_types;\n-  \n   /* Grab the addresses of the arguments from the stack frame.  */\n-  while (i < avn)\n+  for (i = 0; i < cif->nargs; i++)\n     {\n-      /* Assume big-endian.  FIXME */\n-      argn += ALIGN(arg_types[i]->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n+      if (arg_types[i]->type == FFI_TYPE_STRUCT)\n+\t{\n+\t  if (arg_types[i]->size > 16)\n+\t    {\n+\t      /* Straight copy of invisible reference.  */\n+\t      avalue[i] = (void *)gpr[argn++];\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Left-justify.  */\n+\t      ffi_v9_layout_struct(arg_types[i],\n+\t\t\t\t   0,\n+\t\t\t\t   (char *) &gpr[argn],\n+\t\t\t\t   (char *) &gpr[argn],\n+\t\t\t\t   (char *) &fpr[argn]);\n+\t      avalue[i] = &gpr[argn];\n+\t      argn += ALIGN(arg_types[i]->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Right-justify.  */\n+\t  argn += ALIGN(arg_types[i]->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n \n-#ifdef SPARC64\n-      if (i < 16 && (arg_types[i]->type == FFI_TYPE_FLOAT\n-\t\t || arg_types[i]->type == FFI_TYPE_DOUBLE\n+\t  if (i < fp_slot_max\n+\t      && (arg_types[i]->type == FFI_TYPE_FLOAT\n+\t\t  || arg_types[i]->type == FFI_TYPE_DOUBLE\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\t\t || arg_types[i]->type == FFI_TYPE_LONGDOUBLE\n+\t\t  || arg_types[i]->type == FFI_TYPE_LONGDOUBLE\n #endif\n-\t\t))\n-        avalue[i] = ((char *) &fpr[argn]) - arg_types[i]->size;\n-      else\n-#endif\n-        avalue[i] = ((char *) &gpr[argn]) - arg_types[i]->size;\n-      i++;\n+\t\t  ))\n+\t    avalue[i] = ((char *) &fpr[argn]) - arg_types[i]->size;\n+\t  else\n+\t    avalue[i] = ((char *) &gpr[argn]) - arg_types[i]->size;\n+\t}\n     }\n \n   /* Invoke the closure.  */"}, {"sha": "aaa7be7b4c8e1ee6f6c5b4e7d14cb87759ed6900", "filename": "libffi/src/sparc/v8.S", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ce78f010d98dc190f21682d4ff56615efd03d23/libffi%2Fsrc%2Fsparc%2Fv8.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ce78f010d98dc190f21682d4ff56615efd03d23/libffi%2Fsrc%2Fsparc%2Fv8.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fv8.S?ref=0ce78f010d98dc190f21682d4ff56615efd03d23", "patch": "@@ -1,7 +1,7 @@\n /* -----------------------------------------------------------------------\n-   v8.S - Copyright (c) 1996, 1997, 2003 Red Hat, Inc.\n+   v8.S - Copyright (c) 1996, 1997, 2003, 2004 Red Hat, Inc.\n    \n-   Sparc Foreign Function Interface \n+   SPARC Foreign Function Interface \n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -32,11 +32,11 @@\n \n .text\n         .align 8\n-.globl ffi_call_V8\n-.globl _ffi_call_V8\n+.globl ffi_call_v8\n+.globl _ffi_call_v8\n \n-ffi_call_V8:\n-_ffi_call_V8:\n+ffi_call_v8:\n+_ffi_call_v8:\n .LLFB1:\n \tsave\t%sp, -STACKFRAME, %sp\n .LLCFI0:\n@@ -92,10 +92,11 @@ longlong:\n \trestore\n .LLFE1:\n \n-.ffi_call_V8_end:\n-\t.size\tffi_call_V8,.ffi_call_V8_end-ffi_call_V8\n+.ffi_call_v8_end:\n+\t.size\tffi_call_v8,.ffi_call_v8_end-ffi_call_v8\n \n \n+#undef STACKFRAME\n #define\tSTACKFRAME\t104\t/* 16*4 register window +\n \t\t\t\t   1*4 struct return +\t\n \t\t\t\t   6*4 args backing store +\n@@ -128,14 +129,17 @@ ffi_closure_v8:\n \t! Call ffi_closure_sparc_inner to do the bulk of the work.\n \tmov\t%g2, %o0\n \tadd\t%fp, -8, %o1\n-\tadd\t%fp,  68, %o2\n-\tcall\tffi_closure_sparc_inner\n-\t mov\t0, %o3\n+\tcall\tffi_closure_sparc_inner_v8\n+\t add\t%fp,  64, %o2\n \n \t! Load up the return value in the proper type.\n+\t! See ffi_prep_cif_machdep for the list of cases.\n \tcmp\t%o0, FFI_TYPE_VOID\n \tbe\tdone1\n \n+\tcmp\t%o0, FFI_TYPE_INT\n+\tbe\tinteger\n+\n \tcmp\t%o0, FFI_TYPE_FLOAT\n \tbe,a\tdone1\n \t ld\t[%fp-8], %f0\n@@ -144,19 +148,26 @@ ffi_closure_v8:\n \tbe,a\tdone1\n \t ldd\t[%fp-8], %f0\n \n-\tcmp\t%o0, FFI_TYPE_SINT64\n-\tbe,a\tinteger\n-\t ld\t[%fp-4], %i1\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\tcmp\t%o0, FFI_TYPE_LONGDOUBLE\n+\tbe\tdone2\n+#endif\n+\n+\tcmp\t%o0, FFI_TYPE_STRUCT\n+\tbe\tdone2\n \n-\tcmp\t%o0, FFI_TYPE_UINT64\n-\tbe,a\tinteger\n-\t ld\t[%fp-4], %i1\n+\t! FFI_TYPE_SINT64\n+\tld\t[%fp-4], %i1\n \n integer:\n \tld\t[%fp-8], %i0\n \n done1:\n-\tret\n+\tjmp\t%i7+8\n+\t restore\n+done2:\n+\t! Skip 'unimp'.\n+\tjmp\t%i7+12\n \t restore\n .LLFE2:\n "}, {"sha": "d640e0232d5cd1e9b63bee966a756f56c9900f85", "filename": "libffi/src/sparc/v9.S", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ce78f010d98dc190f21682d4ff56615efd03d23/libffi%2Fsrc%2Fsparc%2Fv9.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ce78f010d98dc190f21682d4ff56615efd03d23/libffi%2Fsrc%2Fsparc%2Fv9.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fv9.S?ref=0ce78f010d98dc190f21682d4ff56615efd03d23", "patch": "@@ -1,7 +1,7 @@\n /* -----------------------------------------------------------------------\n-   v9.S - Copyright (c) 2000, 2003 Red Hat, Inc.\n+   v9.S - Copyright (c) 2000, 2003, 2004 Red Hat, Inc.\n    \n-   Sparc 64bit Foreign Function Interface \n+   SPARC 64-bit Foreign Function Interface \n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -37,11 +37,11 @@\n \n .text\n         .align 8\n-.globl ffi_call_V9\n-.globl _ffi_call_V9\n+.globl ffi_call_v9\n+.globl _ffi_call_v9\n \n-ffi_call_V9:\n-_ffi_call_V9:\n+ffi_call_v9:\n+_ffi_call_v9:\n .LLFB1:\n \tsave\t%sp, -STACKFRAME, %sp\n .LLCFI0:\n@@ -87,7 +87,7 @@ _ffi_call_V9:\n \n \tcmp\t%i3, FFI_TYPE_INT\n \tbe,a,pt\t%icc, done\n-\t stx\t%o0, [%i4]\t! (delay)\n+\t stx\t%o0, [%i4+0]\t! (delay)\n \n \tcmp\t%i3, FFI_TYPE_FLOAT\n \tbe,a,pn\t%icc, done\n@@ -123,13 +123,14 @@ dostruct:\n \t restore\n .LLFE1:\n \n-.ffi_call_V9_end:\n-\t.size\tffi_call_V9,.ffi_call_V9_end-ffi_call_V9\n+.ffi_call_v9_end:\n+\t.size\tffi_call_v9,.ffi_call_v9_end-ffi_call_v9\n \n \n-#define\tSTACKFRAME\t 320\t/* 16*8 register window +\n+#undef STACKFRAME\n+#define\tSTACKFRAME\t 336\t/* 16*8 register window +\n \t\t\t\t   6*8 args backing store +\n-\t\t\t\t   18*8 locals */\n+\t\t\t\t   20*8 locals */\n #define\tFP\t\t%fp+STACK_BIAS\n \n /* ffi_closure_v9(...)\n@@ -173,46 +174,55 @@ ffi_closure_v9:\n \n \t! Call ffi_closure_sparc_inner to do the bulk of the work.\n \tmov\t%g1, %o0\n-\tadd\t%fp, STACK_BIAS-144, %o1\n+\tadd\t%fp, STACK_BIAS-160, %o1\n \tadd\t%fp, STACK_BIAS+128, %o2\n-\tcall\tffi_closure_sparc_inner\n-\tadd\t%fp, STACK_BIAS-128, %o3\n+\tcall\tffi_closure_sparc_inner_v9\n+\t add\t%fp, STACK_BIAS-128, %o3\n \n \t! Load up the return value in the proper type.\n+\t! See ffi_prep_cif_machdep for the list of cases.\n \tcmp\t%o0, FFI_TYPE_VOID\n \tbe,pn\t%icc, done1\n \n+\tcmp\t%o0, FFI_TYPE_INT\n+\tbe,pn\t%icc, integer\n+\n \tcmp\t%o0, FFI_TYPE_FLOAT\n \tbe,a,pn\t%icc, done1\n-\t ld\t[FP-144], %f0\n+\t ld\t[FP-160], %f0\n \n \tcmp\t%o0, FFI_TYPE_DOUBLE\n \tbe,a,pn\t%icc, done1\n-\t ldd\t[FP-144], %f0\n+\t ldd\t[FP-160], %f0\n \n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n \tcmp\t%o0, FFI_TYPE_LONGDOUBLE\n \tbe,a,pn\t%icc, longdouble1\n-\t ldd\t[FP-144], %f0\n+\t ldd\t[FP-160], %f0\n+#endif\n \n-\tcmp\t%o0, FFI_TYPE_STRUCT\n-\tbe,pn\t%icc, struct1\n+\t! FFI_TYPE_STRUCT\n+\tldx\t[FP-152], %i1\n+\tldx\t[FP-144], %i2\n+\tldx\t[FP-136], %i3\n+\tldd\t[FP-160], %f0\n+\tldd\t[FP-152], %f2\n+\tldd\t[FP-144], %f4\n+\tldd\t[FP-136], %f6\n \n-\t! FFI_TYPE_UINT64 | FFI_TYPE_SINT64 | FFI_TYPE_POINTER\n-\tldx\t[FP-144], %i0\n+integer:\n+\tldx\t[FP-160], %i0\n \n done1:\n \tret\n \t restore\n \n-struct1:\n-\tldx\t[FP-136], %i2\n-\tret\n-\t restore\n-\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n longdouble1:\n-\tldd\t[FP-136], %f2\n+\tldd\t[FP-152], %f2\n \tret\n \t restore\n+#endif\n .LLFE2:\n \n .ffi_closure_v9_end:"}]}