{"sha": "4ec7c4ec03148023c0d7ee29c46a8c79d36438b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVjN2M0ZWMwMzE0ODAyM2MwZDdlZTI5YzQ2YThjNzlkMzY0MzhiNA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2017-05-02T09:21:19Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-05-02T09:21:19Z"}, "message": "trans.c (assoc_to_constructor): Make sure Corresponding_Discriminant is only called on discriminants.\n\n2017-05-02  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* gcc-interface/trans.c (assoc_to_constructor): Make sure\n\tCorresponding_Discriminant is only called on discriminants.\n\tSkip the saving of the result only for them.\n\t(gnat_to_gnu) <N_Selected_Component>: Likewise.\n\t<N_Unchecked_Type_Conversion>: Translate the result type first.\n\t(gigi): Set TREE_NOTHROW on Begin_Handler.\n\t(stmt_list_cannot_raise_p): New predicate.\n\t(Exception_Handler_to_gnu_gcc): Emit a simple final call instead of\n\ta cleanup if the statements of the handler cannot raise.\n\t(process_freeze_entity): Use Is_Record_Type.\n\t(process_type): Likewise.\n\nFrom-SVN: r247484", "tree": {"sha": "dcbc0076f6b89fee7e1d0e1540b4e89bd0eab770", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcbc0076f6b89fee7e1d0e1540b4e89bd0eab770"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ec7c4ec03148023c0d7ee29c46a8c79d36438b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ec7c4ec03148023c0d7ee29c46a8c79d36438b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ec7c4ec03148023c0d7ee29c46a8c79d36438b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ec7c4ec03148023c0d7ee29c46a8c79d36438b4/comments", "author": null, "committer": null, "parents": [{"sha": "52e0a9f766c29557c52b6dbef536103d30d97e86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52e0a9f766c29557c52b6dbef536103d30d97e86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52e0a9f766c29557c52b6dbef536103d30d97e86"}], "stats": {"total": 112, "additions": 84, "deletions": 28}, "files": [{"sha": "2ddf900f5df2dafdcb972fbc1f3b5f38c271285e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ec7c4ec03148023c0d7ee29c46a8c79d36438b4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ec7c4ec03148023c0d7ee29c46a8c79d36438b4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4ec7c4ec03148023c0d7ee29c46a8c79d36438b4", "patch": "@@ -1,3 +1,17 @@\n+2017-05-02  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (assoc_to_constructor): Make sure\n+\tCorresponding_Discriminant is only called on discriminants.\n+\tSkip the saving of the result only for them.\n+\t(gnat_to_gnu) <N_Selected_Component>: Likewise.\n+\t<N_Unchecked_Type_Conversion>: Translate the result type first.\n+\t(gigi): Set TREE_NOTHROW on Begin_Handler.\n+\t(stmt_list_cannot_raise_p): New predicate.\n+\t(Exception_Handler_to_gnu_gcc): Emit a simple final call instead of\n+\ta cleanup if the statements of the handler cannot raise.\n+\t(process_freeze_entity): Use Is_Record_Type.\n+\t(process_type): Likewise.\n+\n 2017-05-02  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* einfo.ads (Corresponding_Record_Component): New alias"}, {"sha": "9b7155282f7ad80be8dbd473f0bd9ec1c63fed8e", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 70, "deletions": 28, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ec7c4ec03148023c0d7ee29c46a8c79d36438b4/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ec7c4ec03148023c0d7ee29c46a8c79d36438b4/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=4ec7c4ec03148023c0d7ee29c46a8c79d36438b4", "patch": "@@ -516,6 +516,8 @@ gigi (Node_Id gnat_root,\n     = create_subprog_decl (get_identifier (\"__gnat_begin_handler\"), NULL_TREE,\n \t\t\t   ftype, NULL_TREE,\n \t\t\t   is_disabled, true, true, true, false, NULL, Empty);\n+  /* __gnat_begin_handler is a dummy procedure.  */\n+  TREE_NOTHROW (begin_handler_decl) = 1;\n \n   end_handler_decl\n     = create_subprog_decl (get_identifier (\"__gnat_end_handler\"), NULL_TREE,\n@@ -5256,6 +5258,36 @@ Exception_Handler_to_gnu_fe_sjlj (Node_Id gnat_node)\n   return build3 (COND_EXPR, void_type_node, gnu_choice, gnu_body, NULL_TREE);\n }\n \f\n+/* Return true if no statement in GNAT_LIST can alter the control flow.  */\n+\n+static bool\n+stmt_list_cannot_alter_control_flow_p (List_Id gnat_list)\n+{\n+  if (No (gnat_list))\n+    return true;\n+\n+  /* This is very conservative, we reject everything except for simple\n+     assignments between identifiers or literals.  */\n+  for (Node_Id gnat_node = First (gnat_list);\n+       Present (gnat_node);\n+       gnat_node = Next (gnat_node))\n+    {\n+      if (Nkind (gnat_node) != N_Assignment_Statement)\n+\treturn false;\n+\n+      if (Nkind (Name (gnat_node)) != N_Identifier)\n+\treturn false;\n+\n+      Node_Kind nkind = Nkind (Expression (gnat_node));\n+      if (nkind != N_Identifier\n+\t  && nkind != N_Integer_Literal\n+\t  && nkind != N_Real_Literal)\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n /* Subroutine of gnat_to_gnu to translate gnat_node, an N_Exception_Handler,\n    to a GCC tree, which is returned.  This is the variant for GCC exception\n    schemes.  */\n@@ -5264,16 +5296,15 @@ static tree\n Exception_Handler_to_gnu_gcc (Node_Id gnat_node)\n {\n   tree gnu_etypes_list = NULL_TREE;\n-  tree gnu_current_exc_ptr, prev_gnu_incoming_exc_ptr;\n-  Node_Id gnat_temp;\n \n   /* We build a TREE_LIST of nodes representing what exception types this\n      handler can catch, with special cases for others and all others cases.\n \n      Each exception type is actually identified by a pointer to the exception\n      id, or to a dummy object for \"others\" and \"all others\".  */\n-  for (gnat_temp = First (Exception_Choices (gnat_node));\n-       gnat_temp; gnat_temp = Next (gnat_temp))\n+  for (Node_Id gnat_temp = First (Exception_Choices (gnat_node));\n+       gnat_temp;\n+       gnat_temp = Next (gnat_temp))\n     {\n       tree gnu_expr, gnu_etype;\n \n@@ -5329,10 +5360,10 @@ Exception_Handler_to_gnu_gcc (Node_Id gnat_node)\n      We use a local variable to retrieve the incoming value at handler entry\n      time, and reuse it to feed the end_handler hook's argument at exit.  */\n \n-  gnu_current_exc_ptr\n+  tree gnu_current_exc_ptr\n     = build_call_expr (builtin_decl_explicit (BUILT_IN_EH_POINTER),\n \t\t       1, integer_zero_node);\n-  prev_gnu_incoming_exc_ptr = gnu_incoming_exc_ptr;\n+  tree prev_gnu_incoming_exc_ptr = gnu_incoming_exc_ptr;\n   gnu_incoming_exc_ptr\n     = create_var_decl (get_identifier (\"EXPTR\"), NULL_TREE,\n \t\t       ptr_type_node, gnu_current_exc_ptr,\n@@ -5355,11 +5386,16 @@ Exception_Handler_to_gnu_gcc (Node_Id gnat_node)\n \t\t gnu_incoming_exc_ptr));\n     }\n \n+  add_stmt_list (Statements (gnat_node));\n+\n   /* We don't have an End_Label at hand to set the location of the cleanup\n      actions, so we use that of the exception handler itself instead.  */\n-  add_cleanup (build_call_n_expr (end_handler_decl, 1, gnu_incoming_exc_ptr),\n-\t       gnat_node);\n-  add_stmt_list (Statements (gnat_node));\n+  tree stmt = build_call_n_expr (end_handler_decl, 1, gnu_incoming_exc_ptr);\n+  if (stmt_list_cannot_alter_control_flow_p (Statements (gnat_node)))\n+    add_stmt_with_node (stmt, gnat_node);\n+  else\n+    add_cleanup (stmt, gnat_node);\n+\n   gnat_poplevel ();\n \n   gnu_incoming_exc_ptr = prev_gnu_incoming_exc_ptr;\n@@ -6370,16 +6406,22 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \tgnu_prefix = maybe_implicit_deref (gnu_prefix);\n \n-\t/* For discriminant references in tagged types always substitute the\n-\t   corresponding discriminant as the actual selected component.  */\n-\tif (Is_Tagged_Type (Underlying_Type (Etype (gnat_prefix))))\n-\t  while (Present (Corresponding_Discriminant (gnat_field)))\n-\t    gnat_field = Corresponding_Discriminant (gnat_field);\n-\n-\t/* For discriminant references of untagged types always substitute the\n-\t   corresponding stored discriminant.  */\n-\telse if (Present (Corresponding_Discriminant (gnat_field)))\n-\t  gnat_field = Original_Record_Component (gnat_field);\n+\t/* gnat_to_gnu_entity does not save the GNU tree made for renamed\n+\t   discriminants so avoid making recursive calls on each reference\n+\t   to them by following the appropriate link directly here.  */\n+\tif (Ekind (gnat_field) == E_Discriminant)\n+\t  {\n+\t    /* For discriminant references in tagged types always substitute\n+\t       the corresponding discriminant as the actual component.  */\n+\t    if (Is_Tagged_Type (Underlying_Type (Etype (gnat_prefix))))\n+\t      while (Present (Corresponding_Discriminant (gnat_field)))\n+\t\tgnat_field = Corresponding_Discriminant (gnat_field);\n+\n+\t    /* For discriminant references in untagged types always substitute\n+\t       the corresponding stored discriminant.  */\n+\t    else if (Present (Corresponding_Discriminant (gnat_field)))\n+\t      gnat_field = Original_Record_Component (gnat_field);\n+\t  }\n \n \t/* Handle extracting the real or imaginary part of a complex.\n \t   The real part is the first field and the imaginary the last.  */\n@@ -6515,6 +6557,7 @@ gnat_to_gnu (Node_Id gnat_node)\n       break;\n \n     case N_Unchecked_Type_Conversion:\n+      gnu_result_type = get_unpadded_type (Etype (gnat_node));\n       gnu_expr = maybe_character_value (gnat_to_gnu (Expression (gnat_node)));\n \n       /* Skip further processing if the conversion is deemed a no-op.  */\n@@ -6525,8 +6568,6 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  break;\n \t}\n \n-      gnu_result_type = get_unpadded_type (Etype (gnat_node));\n-\n       /* If the result is a pointer type, see if we are improperly\n \t converting to a stricter alignment.  */\n       if (STRICT_ALIGNMENT && POINTER_TYPE_P (gnu_result_type)\n@@ -8666,7 +8707,7 @@ process_freeze_entity (Node_Id gnat_node)\n \t   && TYPE_IS_DUMMY_P (TREE_TYPE (gnu_old))))\n     {\n       gcc_assert (Is_Concurrent_Type (gnat_entity)\n-\t\t  || (IN (kind, Record_Kind)\n+\t\t  || (Is_Record_Type (gnat_entity)\n \t\t      && Is_Concurrent_Record_Type (gnat_entity)));\n       return;\n     }\n@@ -9600,7 +9641,7 @@ process_type (Entity_Id gnat_entity)\n   /* If this is a record type corresponding to a task or protected type\n      that is a completion of an incomplete type, perform a similar update\n      on the type.  ??? Including protected types here is a guess.  */\n-  if (IN (Ekind (gnat_entity), Record_Kind)\n+  if (Is_Record_Type (gnat_entity)\n       && Is_Concurrent_Record_Type (gnat_entity)\n       && present_gnu_tree (Corresponding_Concurrent_Type (gnat_entity)))\n     {\n@@ -9641,15 +9682,16 @@ assoc_to_constructor (Entity_Id gnat_entity, Node_Id gnat_assoc, tree gnu_type)\n \t in every record component association.  */\n       gcc_assert (No (Next (gnat_field)));\n \n-      /* Ignore fields that have Corresponding_Discriminants since we'll\n-\t be setting that field in the parent.  */\n-      if (Present (Corresponding_Discriminant (Entity (gnat_field)))\n+      /* Ignore discriminants that have Corresponding_Discriminants in tagged\n+\t types since we'll be setting those fields in the parent subtype.  */\n+      if (Ekind (Entity (gnat_field)) == E_Discriminant\n+\t  && Present (Corresponding_Discriminant (Entity (gnat_field)))\n \t  && Is_Tagged_Type (Scope (Entity (gnat_field))))\n \tcontinue;\n \n       /* Also ignore discriminants of Unchecked_Unions.  */\n-      if (Is_Unchecked_Union (gnat_entity)\n-\t  && Ekind (Entity (gnat_field)) == E_Discriminant)\n+      if (Ekind (Entity (gnat_field)) == E_Discriminant\n+\t  && Is_Unchecked_Union (gnat_entity))\n \tcontinue;\n \n       /* Before assigning a value in an aggregate make sure range checks"}]}