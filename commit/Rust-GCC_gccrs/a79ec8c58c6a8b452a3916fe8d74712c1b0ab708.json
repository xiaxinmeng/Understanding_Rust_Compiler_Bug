{"sha": "a79ec8c58c6a8b452a3916fe8d74712c1b0ab708", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc5ZWM4YzU4YzZhOGI0NTJhMzkxNmZlOGQ3NDcxMmMxYjBhYjcwOA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-06-06T10:25:25Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:25:25Z"}, "message": "exp_ch5.adb (Expand_N_Assignment_Statement): For the assignment of a controlled type...\n\n2007-04-20  Ed Schonberg  <schonberg@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch5.adb (Expand_N_Assignment_Statement): For the assignment of a\n\tcontrolled type, use Make_Handler_For_Ctrl_Operation to construct the\n\trequired exception handler.\n\t(Expand_Simple_Function_Return, Expand_N_Return_Statement): Handle\n\tproperly the case of a function whose return type is a limited\n\tclass-wide interface type. Modify the code of the accessibility\n\tcheck to handle class-wide interface objects. In this case we need to\n\tdisplace \"this\" to reference the primary dispatch table to get access\n\tto the TSD of the object (to evaluate its accessibility level).\n\t(Expand_N_Extended_Return_Statement): Test for a tagged result type\n\trather than a controlling result as one of the conditions for\n\tgenerating tests of the implicit BIP_Alloc_Form formal. The\n\tinitialization assignment is also handled according to whether the\n\tresult is tagged instead of controlling.\n\tIn the case where the init assignment is inserted in the \"then\" part of\n\tthe allocation conditional, rewrite the target to be a dereference of\n\tthe implicit BIP_Object_Access formal.\n\tIf the returned value is unconstrained and created on the secondary\n\tstack, mark the enclosing block and function so that the secondary\n\tstack is not reclaimed on return.\n\tTreat returns from functions with controlling results similarly to\n\treturns from functions with unconstrained result subtypes.\n\tIf the object returned is unconstrained, and an allocator must be\n\tcreated for it, analyze the allocator once the block for the extended\n\treturn is installed, to ensure that finalizable components\n\tof the expression use the proper finalization list. Guard the call to\n\tMove_Final_List with a check that there is something to finalize.\n\t(Make_Tag_Ctrl_Assignment): Use \"old\" handling\n\tof controlled type assignment for virtual machines, since new code uses\n\tunsupported features (such as direct access to bytes in memory).\n\nFrom-SVN: r125398", "tree": {"sha": "6543f310ee10860562ac2feddf3d18351989eb96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6543f310ee10860562ac2feddf3d18351989eb96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a79ec8c58c6a8b452a3916fe8d74712c1b0ab708", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a79ec8c58c6a8b452a3916fe8d74712c1b0ab708", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a79ec8c58c6a8b452a3916fe8d74712c1b0ab708", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a79ec8c58c6a8b452a3916fe8d74712c1b0ab708/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "26bff3d98f6cf1aad9668c401286ac31822ee986", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26bff3d98f6cf1aad9668c401286ac31822ee986", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26bff3d98f6cf1aad9668c401286ac31822ee986"}], "stats": {"total": 1432, "additions": 783, "deletions": 649}, "files": [{"sha": "d497224a554b9d88b80e9808745488c17f0a55e6", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 783, "deletions": 649, "changes": 1432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79ec8c58c6a8b452a3916fe8d74712c1b0ab708/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79ec8c58c6a8b452a3916fe8d74712c1b0ab708/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=a79ec8c58c6a8b452a3916fe8d74712c1b0ab708", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,7 +38,7 @@ with Exp_Dbug; use Exp_Dbug;\n with Exp_Pakd; use Exp_Pakd;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n-with Hostparm; use Hostparm;\n+with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n@@ -56,6 +56,7 @@ with Sem_Util; use Sem_Util;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n+with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;\n with Uintp;    use Uintp;\n@@ -128,14 +129,6 @@ package body Exp_Ch5 is\n    --  pointers which are not 'part of the value' and must not be changed\n    --  upon assignment. N is the original Assignment node.\n \n-   function Possible_Bit_Aligned_Component (N : Node_Id) return Boolean;\n-   --  This function is used in processing the assignment of a record or\n-   --  indexed component. The argument N is either the left hand or right\n-   --  hand side of an assignment, and this function determines if there\n-   --  is a record component reference where the record may be bit aligned\n-   --  in a manner that causes trouble for the back end (see description\n-   --  of Exp_Util.Component_May_Be_Bit_Aligned for further details).\n-\n    ------------------------------\n    -- Change_Of_Representation --\n    ------------------------------\n@@ -279,26 +272,26 @@ package body Exp_Ch5 is\n       Set_Forwards_OK  (N, True);\n       Set_Backwards_OK (N, True);\n \n-      --  Normally it is only the slice case that can lead to overlap,\n-      --  and explicit checks for slices are made below. But there is\n-      --  one case where the slice can be implicit and invisible to us\n-      --  and that is the case where we have a one dimensional array,\n-      --  and either both operands are parameters, or one is a parameter\n-      --  and the other is a global variable. In this case the parameter\n-      --  could be a slice that overlaps with the other parameter.\n-\n-      --  Check for the case of slices requiring an explicit loop. Normally\n-      --  it is only the explicit slice cases that bother us, but in the\n-      --  case of one dimensional arrays, parameters can be slices that\n-      --  are passed by reference, so we can have aliasing for assignments\n-      --  from one parameter to another, or assignments between parameters\n-      --  and nonlocal variables. However, if the array subtype is a\n-      --  constrained first subtype in the parameter case, then we don't\n-      --  have to worry about overlap, since slice assignments aren't\n-      --  possible (other than for a slice denoting the whole array).\n-\n-      --  Note: overlap is never possible if there is a change of\n-      --  representation, so we can exclude this case.\n+      --  Normally it is only the slice case that can lead to overlap, and\n+      --  explicit checks for slices are made below. But there is one case\n+      --  where the slice can be implicit and invisible to us and that is the\n+      --  case where we have a one dimensional array, and either both operands\n+      --  are parameters, or one is a parameter and the other is a global\n+      --  variable. In this case the parameter could be a slice that overlaps\n+      --  with the other parameter.\n+\n+      --  Check for the case of slices requiring an explicit loop. Normally it\n+      --  is only the explicit slice cases that bother us, but in the case of\n+      --  one dimensional arrays, parameters can be slices that are passed by\n+      --  reference, so we can have aliasing for assignments from one parameter\n+      --  to another, or assignments between parameters and nonlocal variables.\n+      --  However, if the array subtype is a constrained first subtype in the\n+      --  parameter case, then we don't have to worry about overlap, since\n+      --  slice assignments aren't possible (other than for a slice denoting\n+      --  the whole array).\n+\n+      --  Note: No overlap is possible if there is a change of representation,\n+      --  so we can exclude this case.\n \n       if Ndim = 1\n         and then not Crep\n@@ -312,27 +305,27 @@ package body Exp_Ch5 is\n            (not Is_Constrained (Etype (Lhs))\n              or else not Is_First_Subtype (Etype (Lhs)))\n \n-         --  In the case of compiling for the Java Virtual Machine,\n-         --  slices are always passed by making a copy, so we don't\n-         --  have to worry about overlap. We also want to prevent\n-         --  generation of \"<\" comparisons for array addresses,\n-         --  since that's a meaningless operation on the JVM.\n+         --  In the case of compiling for the Java or .NET Virtual Machine,\n+         --  slices are always passed by making a copy, so we don't have to\n+         --  worry about overlap. We also want to prevent generation of \"<\"\n+         --  comparisons for array addresses, since that's a meaningless\n+         --  operation on the VM.\n \n-        and then not Java_VM\n+        and then VM_Target = No_VM\n       then\n          Set_Forwards_OK  (N, False);\n          Set_Backwards_OK (N, False);\n \n-         --  Note: the bit-packed case is not worrisome here, since if\n-         --  we have a slice passed as a parameter, it is always aligned\n-         --  on a byte boundary, and if there are no explicit slices, the\n-         --  assignment can be performed directly.\n+         --  Note: the bit-packed case is not worrisome here, since if we have\n+         --  a slice passed as a parameter, it is always aligned on a byte\n+         --  boundary, and if there are no explicit slices, the assignment\n+         --  can be performed directly.\n       end if;\n \n-      --  We certainly must use a loop for change of representation\n-      --  and also we use the operand of the conversion on the right\n-      --  hand side as the effective right hand side (the component\n-      --  types must match in this situation).\n+      --  We certainly must use a loop for change of representation and also\n+      --  we use the operand of the conversion on the right hand side as the\n+      --  effective right hand side (the component types must match in this\n+      --  situation).\n \n       if Crep then\n          Act_Rhs := Get_Referenced_Object (Rhs);\n@@ -375,17 +368,15 @@ package body Exp_Ch5 is\n \n       elsif not L_Slice and not R_Slice then\n \n-         --  The following code deals with the case of unconstrained bit\n-         --  packed arrays. The problem is that the template for such\n-         --  arrays contains the bounds of the actual source level array,\n-\n-         --  But the copy of an entire array requires the bounds of the\n-         --  underlying array. It would be nice if the back end could take\n-         --  care of this, but right now it does not know how, so if we\n-         --  have such a type, then we expand out into a loop, which is\n-         --  inefficient but works correctly. If we don't do this, we\n-         --  get the wrong length computed for the array to be moved.\n-         --  The two cases we need to worry about are:\n+         --  The following code deals with the case of unconstrained bit packed\n+         --  arrays. The problem is that the template for such arrays contains\n+         --  the bounds of the actual source level array, but the copy of an\n+         --  entire array requires the bounds of the underlying array. It would\n+         --  be nice if the back end could take care of this, but right now it\n+         --  does not know how, so if we have such a type, then we expand out\n+         --  into a loop, which is inefficient but works correctly. If we don't\n+         --  do this, we get the wrong length computed for the array to be\n+         --  moved. The two cases we need to worry about are:\n \n          --  Explicit deference of an unconstrained packed array type as\n          --  in the following example:\n@@ -401,9 +392,9 @@ package body Exp_Ch5 is\n          --       P2.ALL := P1.ALL;\n          --    end C52;\n \n-         --  A formal parameter reference with an unconstrained bit\n-         --  array type is the other case we need to worry about (here\n-         --  we assume the same BITS type declared above):\n+         --  A formal parameter reference with an unconstrained bit array type\n+         --  is the other case we need to worry about (here we assume the same\n+         --  BITS type declared above):\n \n          --    procedure Write_All (File : out BITS; Contents : BITS);\n          --    begin\n@@ -419,8 +410,8 @@ package body Exp_Ch5 is\n          Check_Unconstrained_Bit_Packed_Array : declare\n \n             function Is_UBPA_Reference (Opnd : Node_Id) return Boolean;\n-            --  Function to perform required test for the first case,\n-            --  above (dereference of an unconstrained bit packed array)\n+            --  Function to perform required test for the first case, above\n+            --  (dereference of an unconstrained bit packed array)\n \n             -----------------------\n             -- Is_UBPA_Reference --\n@@ -465,10 +456,9 @@ package body Exp_Ch5 is\n             then\n                Loop_Required := True;\n \n-            --  Here if we do not have the case of a reference to a bit\n-            --  packed unconstrained array case. In this case gigi can\n-            --  most certainly handle the assignment if a forwards move\n-            --  is allowed.\n+            --  Here if we do not have the case of a reference to a bit packed\n+            --  unconstrained array case. In this case gigi can most certainly\n+            --  handle the assignment if a forwards move is allowed.\n \n             --  (could it handle the backwards case also???)\n \n@@ -485,9 +475,9 @@ package body Exp_Ch5 is\n       --  null statement, a length check has already been emitted to verify\n       --  that the range of the left-hand side is empty.\n \n-      --  Note that this code is not executed if we had an assignment of\n-      --  a string literal to a non-bit aligned component of a record, a\n-      --  case which cannot be handled by the backend\n+      --  Note that this code is not executed if we had an assignment of a\n+      --  string literal to a non-bit aligned component of a record, a case\n+      --  which cannot be handled by the backend\n \n       elsif Nkind (Rhs) = N_String_Literal then\n          if String_Length (Strval (Rhs)) = 0\n@@ -499,10 +489,10 @@ package body Exp_Ch5 is\n \n          return;\n \n-      --  If either operand is bit packed, then we need a loop, since we\n-      --  can't be sure that the slice is byte aligned. Similarly, if either\n-      --  operand is a possibly unaligned slice, then we need a loop (since\n-      --  the back end cannot handle unaligned slices).\n+      --  If either operand is bit packed, then we need a loop, since we can't\n+      --  be sure that the slice is byte aligned. Similarly, if either operand\n+      --  is a possibly unaligned slice, then we need a loop (since the back\n+      --  end cannot handle unaligned slices).\n \n       elsif Is_Bit_Packed_Array (L_Type)\n         or else Is_Bit_Packed_Array (R_Type)\n@@ -511,18 +501,18 @@ package body Exp_Ch5 is\n       then\n          Loop_Required := True;\n \n-      --  If we are not bit-packed, and we have only one slice, then no\n-      --  overlap is possible except in the parameter case, so we can let\n-      --  the back end handle things.\n+      --  If we are not bit-packed, and we have only one slice, then no overlap\n+      --  is possible except in the parameter case, so we can let the back end\n+      --  handle things.\n \n       elsif not (L_Slice and R_Slice) then\n          if Forwards_OK (N) then\n             return;\n          end if;\n       end if;\n \n-      --  If the right-hand side is a string literal, introduce a temporary\n-      --  for it, for use in the generated loop that will follow.\n+      --  If the right-hand side is a string literal, introduce a temporary for\n+      --  it, for use in the generated loop that will follow.\n \n       if Nkind (Rhs) = N_String_Literal then\n          declare\n@@ -554,11 +544,11 @@ package body Exp_Ch5 is\n       --    Backwards_OK:  Set to False if we already know that a backwards\n       --                   move is not safe, else set to True\n \n-      --  Our task at this stage is to complete the overlap analysis, which\n-      --  can result in possibly setting Forwards_OK or Backwards_OK to\n-      --  False, and then generating the final code, either by deciding\n-      --  that it is OK after all to let Gigi handle it, or by generating\n-      --  appropriate code in the front end.\n+      --  Our task at this stage is to complete the overlap analysis, which can\n+      --  result in possibly setting Forwards_OK or Backwards_OK to False, and\n+      --  then generating the final code, either by deciding that it is OK\n+      --  after all to let Gigi handle it, or by generating appropriate code\n+      --  in the front end.\n \n       declare\n          L_Index_Typ : constant Node_Id := Etype (First_Index (L_Type));\n@@ -581,8 +571,8 @@ package body Exp_Ch5 is\n       begin\n          --  Get the expressions for the arrays. If we are dealing with a\n          --  private type, then convert to the underlying type. We can do\n-         --  direct assignments to an array that is a private type, but\n-         --  we cannot assign to elements of the array without this extra\n+         --  direct assignments to an array that is a private type, but we\n+         --  cannot assign to elements of the array without this extra\n          --  unchecked conversion.\n \n          if Nkind (Act_Lhs) = N_Slice then\n@@ -609,36 +599,34 @@ package body Exp_Ch5 is\n             end if;\n          end if;\n \n-         --  If both sides are slices, we must figure out whether\n-         --  it is safe to do the move in one direction or the other\n-         --  It is always safe if there is a change of representation\n-         --  since obviously two arrays with different representations\n-         --  cannot possibly overlap.\n+         --  If both sides are slices, we must figure out whether it is safe\n+         --  to do the move in one direction or the other It is always safe if\n+         --  there is a change of representation since obviously two arrays\n+         --  with different representations cannot possibly overlap.\n \n          if (not Crep) and L_Slice and R_Slice then\n             Act_L_Array := Get_Referenced_Object (Prefix (Act_Lhs));\n             Act_R_Array := Get_Referenced_Object (Prefix (Act_Rhs));\n \n-            --  If both left and right hand arrays are entity names, and\n-            --  refer to different entities, then we know that the move\n-            --  is safe (the two storage areas are completely disjoint).\n+            --  If both left and right hand arrays are entity names, and refer\n+            --  to different entities, then we know that the move is safe (the\n+            --  two storage areas are completely disjoint).\n \n             if Is_Entity_Name (Act_L_Array)\n               and then Is_Entity_Name (Act_R_Array)\n               and then Entity (Act_L_Array) /= Entity (Act_R_Array)\n             then\n                null;\n \n-            --  Otherwise, we assume the worst, which is that the two\n-            --  arrays are the same array. There is no need to check if\n-            --  we know that is the case, because if we don't know it,\n-            --  we still have to assume it!\n+            --  Otherwise, we assume the worst, which is that the two arrays\n+            --  are the same array. There is no need to check if we know that\n+            --  is the case, because if we don't know it, we still have to\n+            --  assume it!\n \n-            --  Generally if the same array is involved, then we have\n-            --  an overlapping case. We will have to really assume the\n-            --  worst (i.e. set neither of the OK flags) unless we can\n-            --  determine the lower or upper bounds at compile time and\n-            --  compare them.\n+            --  Generally if the same array is involved, then we have an\n+            --  overlapping case. We will have to really assume the worst (i.e.\n+            --  set neither of the OK flags) unless we can determine the lower\n+            --  or upper bounds at compile time and compare them.\n \n             else\n                Cresult := Compile_Time_Compare (Left_Lo, Right_Lo);\n@@ -657,9 +645,9 @@ package body Exp_Ch5 is\n          end if;\n \n          --  If after that analysis, Forwards_OK is still True, and\n-         --  Loop_Required is False, meaning that we have not discovered\n-         --  some non-overlap reason for requiring a loop, then we can\n-         --  still let gigi handle it.\n+         --  Loop_Required is False, meaning that we have not discovered some\n+         --  non-overlap reason for requiring a loop, then we can still let\n+         --  gigi handle it.\n \n          if not Loop_Required then\n             if Forwards_OK (N) then\n@@ -670,8 +658,8 @@ package body Exp_Ch5 is\n             end if;\n          end if;\n \n-         --  At this stage we have to generate an explicit loop, and\n-         --  we have the following cases:\n+         --  At this stage we have to generate an explicit loop, and we have\n+         --  the following cases:\n \n          --  Forwards_OK = True\n \n@@ -681,9 +669,9 @@ package body Exp_Ch5 is\n          --       Rnn := right_index'Succ (Rnn);\n          --    end loop;\n \n-         --    Note: the above code MUST be analyzed with checks off,\n-         --    because otherwise the Succ could overflow. But in any\n-         --    case this is more efficient!\n+         --    Note: the above code MUST be analyzed with checks off, because\n+         --    otherwise the Succ could overflow. But in any case this is more\n+         --    efficient!\n \n          --  Forwards_OK = False, Backwards_OK = True\n \n@@ -693,9 +681,9 @@ package body Exp_Ch5 is\n          --       Rnn := right_index'Pred (Rnn);\n          --    end loop;\n \n-         --    Note: the above code MUST be analyzed with checks off,\n-         --    because otherwise the Pred could overflow. But in any\n-         --    case this is more efficient!\n+         --    Note: the above code MUST be analyzed with checks off, because\n+         --    otherwise the Pred could overflow. But in any case this is more\n+         --    efficient!\n \n          --  Forwards_OK = Backwards_OK = False\n \n@@ -790,21 +778,20 @@ package body Exp_Ch5 is\n          --  Case of both are false with implicit conditionals allowed\n \n          else\n-            --  Before we generate this code, we must ensure that the\n-            --  left and right side array types are defined. They may\n-            --  be itypes, and we cannot let them be defined inside the\n-            --  if, since the first use in the then may not be executed.\n+            --  Before we generate this code, we must ensure that the left and\n+            --  right side array types are defined. They may be itypes, and we\n+            --  cannot let them be defined inside the if, since the first use\n+            --  in the then may not be executed.\n \n             Ensure_Defined (L_Type, N);\n             Ensure_Defined (R_Type, N);\n \n-            --  We normally compare addresses to find out which way round\n-            --  to do the loop, since this is realiable, and handles the\n-            --  cases of parameters, conversions etc. But we can't do that\n-            --  in the bit packed case or the Java VM case, because addresses\n-            --  don't work there.\n+            --  We normally compare addresses to find out which way round to\n+            --  do the loop, since this is realiable, and handles the cases of\n+            --  parameters, conversions etc. But we can't do that in the bit\n+            --  packed case or the VM case, because addresses don't work there.\n \n-            if not Is_Bit_Packed_Array (L_Type) and then not Java_VM then\n+            if not Is_Bit_Packed_Array (L_Type) and then VM_Target = No_VM then\n                Condition :=\n                  Make_Op_Le (Loc,\n                    Left_Opnd =>\n@@ -837,10 +824,10 @@ package body Exp_Ch5 is\n                                  Attribute_Name => Name_First))),\n                          Attribute_Name => Name_Address)));\n \n-            --  For the bit packed and Java VM cases we use the bounds.\n-            --  That's OK, because we don't have to worry about parameters,\n-            --  since they cannot cause overlap. Perhaps we should worry\n-            --  about weird slice conversions ???\n+            --  For the bit packed and VM cases we use the bounds. That's OK,\n+            --  because we don't have to worry about parameters, since they\n+            --  cannot cause overlap. Perhaps we should worry about weird slice\n+            --  conversions ???\n \n             else\n                --  Copy the bounds and reset the Analyzed flag, because the\n@@ -864,8 +851,8 @@ package body Exp_Ch5 is\n               and then not No_Ctrl_Actions (N)\n             then\n \n-               --  Call TSS procedure for array assignment, passing the\n-               --  the explicit bounds of right and left hand sides.\n+               --  Call TSS procedure for array assignment, passing the the\n+               --  explicit bounds of right and left hand sides.\n \n                declare\n                   Proc    : constant Node_Id :=\n@@ -922,8 +909,8 @@ package body Exp_Ch5 is\n    -- Expand_Assign_Array_Loop --\n    ------------------------------\n \n-   --  The following is an example of the loop generated for the case of\n-   --  a two-dimensional array:\n+   --  The following is an example of the loop generated for the case of a\n+   --  two-dimensional array:\n \n    --    declare\n    --       R2b : Tm1X1 := 1;\n@@ -941,9 +928,9 @@ package body Exp_Ch5 is\n    --       end loop;\n    --    end;\n \n-   --  Here Rev is False, and Tm1Xn are the subscript types for the right\n-   --  hand side. The declarations of R2b and R4b are inserted before the\n-   --  original assignment statement.\n+   --  Here Rev is False, and Tm1Xn are the subscript types for the right hand\n+   --  side. The declarations of R2b and R4b are inserted before the original\n+   --  assignment statement.\n \n    function Expand_Assign_Array_Loop\n      (N      : Node_Id;\n@@ -1091,27 +1078,27 @@ package body Exp_Ch5 is\n    -- Expand_Assign_Record --\n    --------------------------\n \n-   --  The only processing required is in the change of representation\n-   --  case, where we must expand the assignment to a series of field\n-   --  by field assignments.\n+   --  The only processing required is in the change of representation case,\n+   --  where we must expand the assignment to a series of field by field\n+   --  assignments.\n \n    procedure Expand_Assign_Record (N : Node_Id) is\n       Lhs : constant Node_Id := Name (N);\n       Rhs : Node_Id          := Expression (N);\n \n    begin\n-      --  If change of representation, then extract the real right hand\n-      --  side from the type conversion, and proceed with component-wise\n-      --  assignment, since the two types are not the same as far as the\n-      --  back end is concerned.\n+      --  If change of representation, then extract the real right hand side\n+      --  from the type conversion, and proceed with component-wise assignment,\n+      --  since the two types are not the same as far as the back end is\n+      --  concerned.\n \n       if Change_Of_Representation (N) then\n          Rhs := Expression (Rhs);\n \n-      --  If this may be a case of a large bit aligned component, then\n-      --  proceed with component-wise assignment, to avoid possible\n-      --  clobbering of other components sharing bits in the first or\n-      --  last byte of the component to be assigned.\n+      --  If this may be a case of a large bit aligned component, then proceed\n+      --  with component-wise assignment, to avoid possible clobbering of other\n+      --  components sharing bits in the first or last byte of the component to\n+      --  be assigned.\n \n       elsif Possible_Bit_Aligned_Component (Lhs)\n               or\n@@ -1140,9 +1127,8 @@ package body Exp_Ch5 is\n            (Typ  : Entity_Id;\n             Comp : Entity_Id) return Entity_Id;\n          --  Find the component with the given name in the underlying record\n-         --  declaration for Typ. We need to use the actual entity because\n-         --  the type may be private and resolution by identifier alone would\n-         --  fail.\n+         --  declaration for Typ. We need to use the actual entity because the\n+         --  type may be private and resolution by identifier alone would fail.\n \n          function Make_Component_List_Assign\n            (CL  : Node_Id;\n@@ -1511,11 +1497,11 @@ package body Exp_Ch5 is\n       --  packed array is as follows:\n \n       --    An indexed component whose prefix is a bit packed array is a\n-      --     reference to a bit packed array.\n+      --    reference to a bit packed array.\n \n       --    An indexed component or selected component whose prefix is a\n-      --     reference to a bit packed array is itself a reference ot a\n-      --     bit packed array.\n+      --    reference to a bit packed array is itself a reference ot a\n+      --    bit packed array.\n \n       --  The required transformation is\n \n@@ -1545,27 +1531,27 @@ package body Exp_Ch5 is\n                             Chars => New_Internal_Name ('T'));\n \n          begin\n-            --  Insert the post assignment first, because we want to copy\n-            --  the BPAR_Expr tree before it gets analyzed in the context\n-            --  of the pre assignment. Note that we do not analyze the\n-            --  post assignment yet (we cannot till we have completed the\n-            --  analysis of the pre assignment). As usual, the analysis\n-            --  of this post assignment will happen on its own when we\n-            --  \"run into\" it after finishing the current assignment.\n+            --  Insert the post assignment first, because we want to copy the\n+            --  BPAR_Expr tree before it gets analyzed in the context of the\n+            --  pre assignment. Note that we do not analyze the post assignment\n+            --  yet (we cannot till we have completed the analysis of the pre\n+            --  assignment). As usual, the analysis of this post assignment\n+            --  will happen on its own when we \"run into\" it after finishing\n+            --  the current assignment.\n \n             Insert_After (N,\n               Make_Assignment_Statement (Loc,\n                 Name       => New_Copy_Tree (BPAR_Expr),\n                 Expression => New_Occurrence_Of (Tnn, Loc)));\n \n-            --  At this stage BPAR_Expr is a reference to a bit packed\n-            --  array where the reference was not expanded in the original\n-            --  tree, since it was on the left side of an assignment. But\n-            --  in the pre-assignment statement (the object definition),\n-            --  BPAR_Expr will end up on the right hand side, and must be\n-            --  reexpanded. To achieve this, we reset the analyzed flag\n-            --  of all selected and indexed components down to the actual\n-            --  indexed component for the packed array.\n+            --  At this stage BPAR_Expr is a reference to a bit packed array\n+            --  where the reference was not expanded in the original tree,\n+            --  since it was on the left side of an assignment. But in the\n+            --  pre-assignment statement (the object definition), BPAR_Expr\n+            --  will end up on the right hand side, and must be reexpanded. To\n+            --  achieve this, we reset the analyzed flag of all selected and\n+            --  indexed components down to the actual indexed component for\n+            --  the packed array.\n \n             Exp := BPAR_Expr;\n             loop\n@@ -1596,7 +1582,7 @@ package body Exp_Ch5 is\n \n             begin\n                if Uses_Transient_Scope then\n-                  New_Scope (Scope (Current_Scope));\n+                  Push_Scope (Scope (Current_Scope));\n                end if;\n \n                Insert_Before_And_Analyze (N,\n@@ -1636,8 +1622,8 @@ package body Exp_Ch5 is\n          return;\n       end if;\n \n-      --  Apply discriminant check if required. If Lhs is an access type\n-      --  to a designated type with discriminants, we must always check.\n+      --  Apply discriminant check if required. If Lhs is an access type to a\n+      --  designated type with discriminants, we must always check.\n \n       if Has_Discriminants (Etype (Lhs)) then\n \n@@ -1682,8 +1668,8 @@ package body Exp_Ch5 is\n          Rewrite (Rhs, OK_Convert_To (Base_Type (Typ), Rhs));\n          Apply_Discriminant_Check (Rhs, Typ, Lhs);\n \n-      --  In the access type case, we need the same discriminant check,\n-      --  and also range checks if we have an access to constrained array.\n+      --  In the access type case, we need the same discriminant check, and\n+      --  also range checks if we have an access to constrained array.\n \n       elsif Is_Access_Type (Etype (Lhs))\n         and then Is_Constrained (Designated_Type (Etype (Lhs)))\n@@ -1755,14 +1741,19 @@ package body Exp_Ch5 is\n          return;\n \n       --  Build-in-place function call case. Note that we're not yet doing\n-      --  build-in-place for user-written assignment statements; the\n-      --  assignment here came from an aggregate.\n+      --  build-in-place for user-written assignment statements (the assignment\n+      --  here came from an aggregate.)\n \n       elsif Ada_Version >= Ada_05\n         and then Is_Build_In_Place_Function_Call (Rhs)\n       then\n          Make_Build_In_Place_Call_In_Assignment (N, Rhs);\n \n+      elsif Is_Tagged_Type (Typ) and then Is_Value_Type (Etype (Lhs)) then\n+         --  Nothing to do for valuetypes\n+         --  ??? Set_Scope_Is_Transient (False);\n+         return;\n+\n       elsif Is_Tagged_Type (Typ)\n         or else (Controlled_Type (Typ) and then not Is_Array_Type (Typ))\n       then\n@@ -1772,9 +1763,9 @@ package body Exp_Ch5 is\n \n          begin\n             --  In the controlled case, we need to make sure that function\n-            --  calls are evaluated before finalizing the target. In all\n-            --  cases, it makes the expansion easier if the side-effects\n-            --  are removed first.\n+            --  calls are evaluated before finalizing the target. In all cases,\n+            --  it makes the expansion easier if the side-effects are removed\n+            --  first.\n \n             Remove_Side_Effects (Lhs);\n             Remove_Side_Effects (Rhs);\n@@ -1790,25 +1781,26 @@ package body Exp_Ch5 is\n                --  If the type is tagged, we may as well use the predefined\n                --  primitive assignment. This avoids inlining a lot of code\n                --  and in the class-wide case, the assignment is replaced by\n-               --  dispatch call to _assign. Note that this cannot be done\n-               --  when discriminant checks are locally suppressed (as in\n-               --  extension aggregate expansions) because otherwise the\n-               --  discriminant check will be performed within the _assign\n-               --  call. It is also suppressed for assignmments created by the\n-               --  expander that correspond to initializations, where we do\n-               --  want to copy the tag (No_Ctrl_Actions flag set True).\n-               --  by the expander and we do not need to mess with tags ever\n-               --  (Expand_Ctrl_Actions flag is set True in this case).\n+               --  dispatch call to _assign. Note that this cannot be done when\n+               --  discriminant checks are locally suppressed (as in extension\n+               --  aggregate expansions) because otherwise the discriminant\n+               --  check will be performed within the _assign call. It is also\n+               --  suppressed for assignmments created by the expander that\n+               --  correspond to initializations, where we do want to copy the\n+               --  tag (No_Ctrl_Actions flag set True). by the expander and we\n+               --  do not need to mess with tags ever (Expand_Ctrl_Actions flag\n+               --  is set True in this case).\n \n                or else (Is_Tagged_Type (Typ)\n+                          and then not Is_Value_Type (Etype (Lhs))\n                           and then Chars (Current_Scope) /= Name_uAssign\n                           and then Expand_Ctrl_Actions\n                           and then not Discriminant_Checks_Suppressed (Empty))\n             then\n-               --  Fetch the primitive op _assign and proper type to call\n-               --  it. Because of possible conflits between private and\n-               --  full view the proper type is fetched directly from the\n-               --  operation profile.\n+               --  Fetch the primitive op _assign and proper type to call it.\n+               --  Because of possible conflits between private and full view\n+               --  the proper type is fetched directly from the operation\n+               --  profile.\n \n                declare\n                   Op    : constant Entity_Id :=\n@@ -1865,10 +1857,10 @@ package body Exp_Ch5 is\n             else\n                L := Make_Tag_Ctrl_Assignment (N);\n \n-               --  We can't afford to have destructive Finalization Actions\n-               --  in the Self assignment case, so if the target and the\n-               --  source are not obviously different, code is generated to\n-               --  avoid the self assignment case:\n+               --  We can't afford to have destructive Finalization Actions in\n+               --  the Self assignment case, so if the target and the source\n+               --  are not obviously different, code is generated to avoid the\n+               --  self assignment case:\n \n                --    if lhs'address /= rhs'address then\n                --       <code for controlled and/or tagged assignment>\n@@ -1895,7 +1887,7 @@ package body Exp_Ch5 is\n                end if;\n \n                --  We need to set up an exception handler for implementing\n-               --  7.6.1 (18). The remaining adjustments are tackled by the\n+               --  7.6.1(18). The remaining adjustments are tackled by the\n                --  implementation of adjust for record_controllers (see\n                --  s-finimp.adb).\n \n@@ -1910,14 +1902,7 @@ package body Exp_Ch5 is\n                         Make_Handled_Sequence_Of_Statements (Loc,\n                           Statements => L,\n                           Exception_Handlers => New_List (\n-                            Make_Implicit_Exception_Handler (Loc,\n-                              Exception_Choices =>\n-                                New_List (Make_Others_Choice (Loc)),\n-                              Statements        => New_List (\n-                                Make_Raise_Program_Error (Loc,\n-                                  Reason =>\n-                                    PE_Finalize_Raised_Exception)\n-                              ))))));\n+                            Make_Handler_For_Ctrl_Operation (Loc)))));\n                end if;\n             end if;\n \n@@ -1983,21 +1968,21 @@ package body Exp_Ch5 is\n          Expand_Assign_Record (N);\n          return;\n \n-      --  Scalar types. This is where we perform the processing related\n-      --  to the requirements of (RM 13.9.1(9-11)) concerning the handling\n-      --  of invalid scalar values.\n+      --  Scalar types. This is where we perform the processing related to the\n+      --  requirements of (RM 13.9.1(9-11)) concerning the handling of invalid\n+      --  scalar values.\n \n       elsif Is_Scalar_Type (Typ) then\n \n          --  Case where right side is known valid\n \n          if Expr_Known_Valid (Rhs) then\n \n-            --  Here the right side is valid, so it is fine. The case to\n-            --  deal with is when the left side is a local variable reference\n-            --  whose value is not currently known to be valid. If this is\n-            --  the case, and the assignment appears in an unconditional\n-            --  context, then we can mark the left side as now being valid.\n+            --  Here the right side is valid, so it is fine. The case to deal\n+            --  with is when the left side is a local variable reference whose\n+            --  value is not currently known to be valid. If this is the case,\n+            --  and the assignment appears in an unconditional context, then we\n+            --  can mark the left side as now being valid.\n \n             if Is_Local_Variable_Reference (Lhs)\n               and then not Is_Known_Valid (Entity (Lhs))\n@@ -2007,9 +1992,9 @@ package body Exp_Ch5 is\n             end if;\n \n          --  Case where right side may be invalid in the sense of the RM\n-         --  reference above. The RM does not require that we check for\n-         --  the validity on an assignment, but it does require that the\n-         --  assignment of an invalid value not cause erroneous behavior.\n+         --  reference above. The RM does not require that we check for the\n+         --  validity on an assignment, but it does require that the assignment\n+         --  of an invalid value not cause erroneous behavior.\n \n          --  The general approach in GNAT is to use the Is_Known_Valid flag\n          --  to avoid the need for validity checking on assignments. However\n@@ -2046,19 +2031,18 @@ package body Exp_Ch5 is\n \n             --  Otherwise check to see what should be done\n \n-            --  If left side is a local variable, then we just set its\n-            --  flag to indicate that its value may no longer be valid,\n-            --  since we are copying a potentially invalid value.\n+            --  If left side is a local variable, then we just set its flag to\n+            --  indicate that its value may no longer be valid, since we are\n+            --  copying a potentially invalid value.\n \n             elsif Is_Local_Variable_Reference (Lhs) then\n                Set_Is_Known_Valid (Entity (Lhs), False);\n \n-            --  Check for case of a nonlocal variable on the left side\n-            --  which is currently known to be valid. In this case, we\n-            --  simply ensure that the right side is valid. We only play\n-            --  the game of copying validity status for local variables,\n-            --  since we are doing this statically, not by tracing the\n-            --  full flow graph.\n+            --  Check for case of a nonlocal variable on the left side which\n+            --  is currently known to be valid. In this case, we simply ensure\n+            --  that the right side is valid. We only play the game of copying\n+            --  validity status for local variables, since we are doing this\n+            --  statically, not by tracing the full flow graph.\n \n             elsif Is_Entity_Name (Lhs)\n               and then Is_Known_Valid (Entity (Lhs))\n@@ -2069,9 +2053,9 @@ package body Exp_Ch5 is\n \n                Ensure_Valid (Rhs);\n \n-            --  In all other cases, we can safely copy an invalid value\n-            --  without worrying about the status of the left side. Since\n-            --  it is not a variable reference it will not be considered\n+            --  In all other cases, we can safely copy an invalid value without\n+            --  worrying about the status of the left side. Since it is not a\n+            --  variable reference it will not be considered\n             --  as being known to be valid in any case.\n \n             else\n@@ -2080,9 +2064,9 @@ package body Exp_Ch5 is\n          end if;\n       end if;\n \n-      --  Defend against invalid subscripts on left side if we are in\n-      --  standard validity checking mode. No need to do this if we\n-      --  are checking all subscripts.\n+      --  Defend against invalid subscripts on left side if we are in standard\n+      --  validity checking mode. No need to do this if we are checking all\n+      --  subscripts.\n \n       if Validity_Checks_On\n         and then Validity_Check_Default\n@@ -2121,15 +2105,14 @@ package body Exp_Ch5 is\n       Chlist : List_Id;\n \n    begin\n-      --  Check for the situation where we know at compile time which\n-      --  branch will be taken\n+      --  Check for the situation where we know at compile time which branch\n+      --  will be taken\n \n       if Compile_Time_Known_Value (Expr) then\n          Alt := Find_Static_Alternative (N);\n \n-         --  Move the statements from this alternative after the case\n-         --  statement. They are already analyzed, so will be skipped\n-         --  by the analyzer.\n+         --  Move statements from this alternative after the case statement.\n+         --  They are already analyzed, so will be skipped by the analyzer.\n \n          Insert_List_After (N, Statements (Alt));\n \n@@ -2193,9 +2176,9 @@ package body Exp_Ch5 is\n             Ensure_Valid (Expr);\n          end if;\n \n-         --  If there is only a single alternative, just replace it with\n-         --  the sequence of statements since obviously that is what is\n-         --  going to be executed in all cases.\n+         --  If there is only a single alternative, just replace it with the\n+         --  sequence of statements since obviously that is what is going to\n+         --  be executed in all cases.\n \n          Len := List_Length (Alternatives (N));\n \n@@ -2207,9 +2190,9 @@ package body Exp_Ch5 is\n \n             Insert_List_After (N, Statements (First (Alternatives (N))));\n \n-            --  That leaves the case statement as a shell. The alternative\n-            --  that will be executed is reset to a null list. So now we can\n-            --  kill the entire case statement.\n+            --  That leaves the case statement as a shell. The alternative that\n+            --  will be executed is reset to a null list. So now we can kill\n+            --  the entire case statement.\n \n             Kill_Dead_Code (Expression (N));\n             Rewrite (N, Make_Null_Statement (Loc));\n@@ -2283,16 +2266,16 @@ package body Exp_Ch5 is\n             end if;\n          end if;\n \n-         --  If the last alternative is not an Others choice, replace it\n-         --  with an N_Others_Choice. Note that we do not bother to call\n-         --  Analyze on the modified case statement, since it's only effect\n-         --  would be to compute the contents of the Others_Discrete_Choices\n-         --  which is not needed by the back end anyway.\n+         --  If the last alternative is not an Others choice, replace it with\n+         --  an N_Others_Choice. Note that we do not bother to call Analyze on\n+         --  the modified case statement, since it's only effect would be to\n+         --  compute the contents of the Others_Discrete_Choices which is not\n+         --  needed by the back end anyway.\n \n          --  The reason we do this is that the back end always needs some\n          --  default for a switch, so if we have not supplied one in the\n-         --  processing above for validity checking, then we need to\n-         --  supply one here.\n+         --  processing above for validity checking, then we need to supply\n+         --  one here.\n \n          if not Others_Present then\n             Others_Node := Make_Others_Choice (Sloc (Last_Alt));\n@@ -2389,25 +2372,30 @@ package body Exp_Ch5 is\n       function Move_Final_List return Node_Id;\n       --  Construct call to System.Finalization_Implementation.Move_Final_List\n       --  with parameters:\n-      --  From           finalization list of the return statement\n-      --  To             finalization list passed in by the caller\n+      --\n+      --    From         finalization list of the return statement\n+      --    To           finalization list passed in by the caller\n \n-      ---------------------\n+      ---------------------------\n       -- Move_Activation_Chain --\n-      ---------------------\n+      ---------------------------\n \n       function Move_Activation_Chain return Node_Id is\n          Activation_Chain_Formal : constant Entity_Id :=\n-           Build_In_Place_Formal (Parent_Function, BIP_Activation_Chain);\n+                                     Build_In_Place_Formal\n+                                       (Parent_Function, BIP_Activation_Chain);\n          To                      : constant Node_Id :=\n-           New_Reference_To (Activation_Chain_Formal, Loc);\n+                                     New_Reference_To\n+                                       (Activation_Chain_Formal, Loc);\n          Master_Formal           : constant Entity_Id :=\n-           Build_In_Place_Formal (Parent_Function, BIP_Master);\n+                                     Build_In_Place_Formal\n+                                       (Parent_Function, BIP_Master);\n          New_Master              : constant Node_Id :=\n-           New_Reference_To (Master_Formal, Loc);\n+                                     New_Reference_To (Master_Formal, Loc);\n \n          Chain_Entity : Entity_Id;\n          From         : Node_Id;\n+\n       begin\n          Chain_Entity := First_Entity (Return_Statement_Entity (N));\n          while Chars (Chain_Entity) /= Name_uChain loop\n@@ -2418,7 +2406,7 @@ package body Exp_Ch5 is\n            Make_Attribute_Reference (Loc,\n              Prefix         => New_Reference_To (Chain_Entity, Loc),\n              Attribute_Name => Name_Unrestricted_Access);\n-         --  ??? I'm not sure why \"Make_Identifier (Loc, Name_uChain)\" doesn't\n+         --  ??? Not clear why \"Make_Identifier (Loc, Name_uChain)\" doesn't\n          --  work, instead of \"New_Reference_To (Chain_Entity, Loc)\" above.\n \n          return\n@@ -2432,23 +2420,32 @@ package body Exp_Ch5 is\n       ---------------------\n \n       function Move_Final_List return Node_Id is\n-         Flist : constant Entity_Id  :=\n-                   Finalization_Chain_Entity (Return_Statement_Entity (N));\n+         Flist             : constant Entity_Id  :=\n+                               Finalization_Chain_Entity\n+                                 (Return_Statement_Entity (N));\n \n-         From  : constant Node_Id := New_Reference_To (Flist, Loc);\n+         From              : constant Node_Id :=\n+                               New_Reference_To (Flist, Loc);\n \n          Caller_Final_List : constant Entity_Id :=\n                                Build_In_Place_Formal\n                                  (Parent_Function, BIP_Final_List);\n \n-         To    : constant Node_Id :=\n-                   New_Reference_To (Caller_Final_List, Loc);\n+         To                : constant Node_Id :=\n+                               New_Reference_To (Caller_Final_List, Loc);\n \n       begin\n          return\n-           Make_Procedure_Call_Statement (Loc,\n-             Name => New_Reference_To (RTE (RE_Move_Final_List), Loc),\n-             Parameter_Associations => New_List (From, To));\n+           Make_If_Statement (Loc,\n+             Condition =>\n+               Make_Op_Ne (Loc,\n+                 Left_Opnd  => New_Copy (From),\n+                 Right_Opnd => New_Node (N_Null, Loc)),\n+             Then_Statements =>\n+               New_List (\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name => New_Reference_To (RTE (RE_Move_Final_List), Loc),\n+                   Parameter_Associations => New_List (From, To))));\n       end Move_Final_List;\n \n    --  Start of processing for Expand_N_Extended_Return_Statement\n@@ -2480,33 +2477,49 @@ package body Exp_Ch5 is\n \n          --  If control gets past the above Statements, we have successfully\n          --  completed the return statement. If the result type has controlled\n-         --  parts, we call Move_Final_List to transfer responsibility for\n-         --  finalization of the return object to the caller. An alternative\n-         --  would be to declare a Success flag in the function, initialize it\n-         --  to False, and set it to True here. Then move the Move_Final_List\n-         --  call into the cleanup code, and check Success. If Success then\n-         --  Move_Final_List else do finalization. Then we can remove the\n+         --  parts and the return is for a build-in-place function, then we\n+         --  call Move_Final_List to transfer responsibility for finalization\n+         --  of the return object to the caller. An alternative would be to\n+         --  declare a Success flag in the function, initialize it to False,\n+         --  and set it to True here. Then move the Move_Final_List call into\n+         --  the cleanup code, and check Success. If Success then make a call\n+         --  to Move_Final_List else do finalization. Then we can remove the\n          --  abort-deferral and the nulling-out of the From parameter from\n-         --  Move_Final_List. Note that the current method is not quite\n-         --  correct in the rather obscure case of a select-then-abort\n-         --  statement whose abortable part contains the return statement.\n+         --  Move_Final_List. Note that the current method is not quite correct\n+         --  in the rather obscure case of a select-then-abort statement whose\n+         --  abortable part contains the return statement.\n \n-         if Is_Controlled (Etype (Parent_Function))\n-           or else Has_Controlled_Component (Etype (Parent_Function))\n+         --  We test the type of the expression as well as the return type\n+         --  of the function, because the latter may be a class-wide type\n+         --  which is always treated as controlled, while the expression itself\n+         --  has to have a definite type. The expression may be absent if a\n+         --  constrained aggregate has been expanded into component assignments\n+         --  so we have to check for this as well.\n+\n+         if Is_Build_In_Place\n+           and then Controlled_Type (Etype (Parent_Function))\n          then\n-            Append_To (Statements, Move_Final_List);\n+            if not Is_Class_Wide_Type (Etype (Parent_Function))\n+              or else\n+               (Present (Exp)\n+                 and then Controlled_Type (Etype (Exp)))\n+            then\n+               Append_To (Statements, Move_Final_List);\n+            end if;\n          end if;\n \n          --  Similarly to the above Move_Final_List, if the result type\n          --  contains tasks, we call Move_Activation_Chain. Later, the cleanup\n          --  code will call Complete_Master, which will terminate any\n          --  unactivated tasks belonging to the return statement master. But\n          --  Move_Activation_Chain updates their master to be that of the\n-         --  caller, so they will not be terminated unless the return\n-         --  statement completes unsuccessfully due to exception, abort, goto,\n-         --  or exit.\n+         --  caller, so they will not be terminated unless the return statement\n+         --  completes unsuccessfully due to exception, abort, goto, or exit.\n+         --  As a formality, we test whether the function requires the result\n+         --  to be built in place, though that's necessarily true for the case\n+         --  of result types with task parts.\n \n-         if Has_Task (Etype (Parent_Function)) then\n+         if Is_Build_In_Place and Has_Task (Etype (Parent_Function)) then\n             Append_To (Statements, Move_Activation_Chain);\n          end if;\n \n@@ -2554,7 +2567,7 @@ package body Exp_Ch5 is\n          elsif Is_Build_In_Place then\n \n             --  Locate the implicit access parameter associated with the\n-            --  the caller-supplied return object and convert the return\n+            --  caller-supplied return object and convert the return\n             --  statement's return object declaration to a renaming of a\n             --  dereference of the access parameter. If the return object's\n             --  declaration includes an expression that has not already been\n@@ -2612,9 +2625,11 @@ package body Exp_Ch5 is\n                     Make_Assignment_Statement (Loc,\n                       Name       => New_Reference_To (Return_Obj_Id, Loc),\n                       Expression => Relocate_Node (Return_Obj_Expr));\n+                  Set_Etype (Name (Init_Assignment), Etype (Return_Obj_Id));\n                   Set_Assignment_OK (Name (Init_Assignment));\n                   Set_No_Ctrl_Actions (Init_Assignment);\n \n+                  Set_Parent (Name (Init_Assignment), Init_Assignment);\n                   Set_Parent (Expression (Init_Assignment), Init_Assignment);\n \n                   Set_Expression (Return_Object_Decl, Empty);\n@@ -2632,27 +2647,41 @@ package body Exp_Ch5 is\n                            Relocate_Node (Expression (Init_Assignment))));\n                   end if;\n \n-                  if Constr_Result then\n+                  --  In the case of functions where the calling context can\n+                  --  determine the form of allocation needed, initialization\n+                  --  is done with each part of the if statement that handles\n+                  --  the different forms of allocation (this is true for\n+                  --  unconstrained and tagged result subtypes).\n+\n+                  if Constr_Result\n+                    and then not Is_Tagged_Type (Underlying_Type (Result_Subt))\n+                  then\n                      Insert_After (Return_Object_Decl, Init_Assignment);\n                   end if;\n                end if;\n \n                --  When the function's subtype is unconstrained, a run-time\n                --  test is needed to determine the form of allocation to use\n                --  for the return object. The function has an implicit formal\n-               --  parameter that indicates this. If the BIP_Alloc_Form formal\n-               --  has the value one, then the caller has passed access to an\n+               --  parameter indicating this. If the BIP_Alloc_Form formal has\n+               --  the value one, then the caller has passed access to an\n                --  existing object for use as the return object. If the value\n                --  is two, then the return object must be allocated on the\n                --  secondary stack. Otherwise, the object must be allocated in\n-               --  a storage pool. Currently the last case is only supported\n-               --  for the global heap (user-defined storage pools TBD ???). We\n-               --  generate an if statement to test the implicit allocation\n-               --  formal and initialize a local access value appropriately,\n-               --  creating allocators in the secondary stack and global heap\n-               --  cases.\n-\n-               if not Constr_Result then\n+               --  a storage pool (currently only supported for the global\n+               --  heap, user-defined storage pools TBD ???). We generate an\n+               --  if statement to test the implicit allocation formal and\n+               --  initialize a local access value appropriately, creating\n+               --  allocators in the secondary stack and global heap cases.\n+               --  The special formal also exists and must be tested when the\n+               --  function has a tagged result, even when the result subtype\n+               --  is constrained, because in general such functions can be\n+               --  called in dispatching contexts and must be handled similarly\n+               --  to functions with a class-wide result.\n+\n+               if not Constr_Result\n+                 or else Is_Tagged_Type (Underlying_Type (Result_Subt))\n+               then\n                   Obj_Alloc_Formal :=\n                     Build_In_Place_Formal (Parent_Function, BIP_Alloc_Form);\n \n@@ -2688,8 +2717,7 @@ package body Exp_Ch5 is\n                              Subtype_Indication =>\n                                New_Reference_To (Return_Obj_Typ, Loc)));\n \n-                     Insert_Before_And_Analyze\n-                       (Return_Object_Decl, Ptr_Type_Decl);\n+                     Insert_Before (Return_Object_Decl, Ptr_Type_Decl);\n \n                      --  Create an access object that will be initialized to an\n                      --  access value denoting the return object, either coming\n@@ -2707,8 +2735,7 @@ package body Exp_Ch5 is\n                          Object_Definition   => New_Reference_To\n                                                   (Ref_Type, Loc));\n \n-                     Insert_Before_And_Analyze\n-                       (Return_Object_Decl, Alloc_Obj_Decl);\n+                     Insert_Before (Return_Object_Decl, Alloc_Obj_Decl);\n \n                      --  Create allocators for both the secondary stack and\n                      --  global heap. If there's an initialization expression,\n@@ -2729,9 +2756,21 @@ package body Exp_Ch5 is\n                         SS_Allocator := New_Copy_Tree (Heap_Allocator);\n \n                      else\n-                        Heap_Allocator :=\n-                          Make_Allocator (Loc,\n-                            New_Reference_To (Return_Obj_Typ, Loc));\n+                        --  If the function returns a class-wide type we cannot\n+                        --  use the return type for the allocator. Instead we\n+                        --  use the type of the expression, which must be an\n+                        --  aggregate of a definite type.\n+\n+                        if Is_Class_Wide_Type (Return_Obj_Typ) then\n+                           Heap_Allocator :=\n+                             Make_Allocator (Loc,\n+                               New_Reference_To\n+                                 (Etype (Return_Obj_Expr), Loc));\n+                        else\n+                           Heap_Allocator :=\n+                             Make_Allocator (Loc,\n+                               New_Reference_To (Return_Obj_Typ, Loc));\n+                        end if;\n \n                         --  If the object requires default initialization then\n                         --  that will happen later following the elaboration of\n@@ -2748,10 +2787,24 @@ package body Exp_Ch5 is\n                      Set_Procedure_To_Call\n                        (SS_Allocator, RTE (RE_SS_Allocate));\n \n+                     --  The allocator is returned on the secondary stack,\n+                     --  so indicate that the function return, as well as\n+                     --  the block that encloses the allocator, must not\n+                     --  release it. The flags must be set now because the\n+                     --  decision to use the secondary stack is done very\n+                     --  late in the course of expanding the return statement,\n+                     --  past the point where these flags are normally set.\n+\n+                     Set_Sec_Stack_Needed_For_Return (Parent_Function);\n+                     Set_Sec_Stack_Needed_For_Return\n+                       (Return_Statement_Entity (N));\n+                     Set_Uses_Sec_Stack (Parent_Function);\n+                     Set_Uses_Sec_Stack (Return_Statement_Entity (N));\n+\n                      --  Create an if statement to test the BIP_Alloc_Form\n                      --  formal and initialize the access object to either the\n                      --  BIP_Object_Access formal (BIP_Alloc_Form = 0), the\n-                     --  result of allocaing the object in the secondary stack\n+                     --  result of allocating the object in the secondary stack\n                      --  (BIP_Alloc_Form = 1), or else an allocator to create\n                      --  the return object in the heap (BIP_Alloc_Form = 2).\n \n@@ -2818,14 +2871,23 @@ package body Exp_Ch5 is\n                      --  earlier, append that following the assignment of the\n                      --  implicit access formal to the access object, to ensure\n                      --  that the return object is initialized in that case.\n+                     --  In this situation, the target of the assignment must\n+                     --  be rewritten to denote a derference of the access to\n+                     --  the return object passed in by the caller.\n \n                      if Present (Init_Assignment) then\n+                        Rewrite (Name (Init_Assignment),\n+                          Make_Explicit_Dereference (Loc,\n+                            Prefix => New_Reference_To (Alloc_Obj_Id, Loc)));\n+                        Set_Etype\n+                          (Name (Init_Assignment), Etype (Return_Obj_Id));\n+\n                         Append_To\n                           (Then_Statements (Alloc_If_Stmt),\n                            Init_Assignment);\n                      end if;\n \n-                     Insert_After_And_Analyze (Alloc_Obj_Decl, Alloc_If_Stmt);\n+                     Insert_Before (Return_Object_Decl, Alloc_If_Stmt);\n \n                      --  Remember the local access object for use in the\n                      --  dereference of the renaming created below.\n@@ -3659,10 +3721,10 @@ package body Exp_Ch5 is\n          else\n             Set_Storage_Pool      (N, RTE (RE_SS_Pool));\n \n-            --  If we are generating code for the Java VM do not use\n+            --  If we are generating code for the VM do not use\n             --  SS_Allocate since everything is heap-allocated anyway.\n \n-            if not Java_VM then\n+            if VM_Target = No_VM then\n                Set_Procedure_To_Call (N, RTE (RE_SS_Allocate));\n             end if;\n          end if;\n@@ -3739,7 +3801,11 @@ package body Exp_Ch5 is\n       --  return expression has a specific type whose level is known not to\n       --  be statically deeper than the function's result type.\n \n+      --  Note: accessibility check is skipped in the VM case, since there\n+      --  does not seem to be any practical way to implement this check.\n+\n       elsif Ada_Version >= Ada_05\n+        and then VM_Target = No_VM\n         and then Is_Class_Wide_Type (Return_Type)\n         and then not Scope_Suppress (Accessibility_Check)\n         and then\n@@ -3951,8 +4017,13 @@ package body Exp_Ch5 is\n       --  Expand_N_Extended_Return_Statement, and in order to do\n       --  build-in-place for efficiency when it is not required.\n \n+      --  As before, we check the type of the return expression rather than the\n+      --  return type of the function, because the latter may be a limited\n+      --  class-wide interface type, which is not a limited type, even though\n+      --  the type of the expression may be.\n+\n       if not Comes_From_Extended_Return_Statement (N)\n-        and then Is_Inherently_Limited_Type (R_Type) --  ???\n+        and then Is_Inherently_Limited_Type (Etype (Expression (N)))\n         and then Ada_Version >= Ada_05 --  ???\n         and then not Debug_Flag_Dot_L\n       then\n@@ -4021,7 +4092,9 @@ package body Exp_Ch5 is\n       --  type that requires special processing (indicated by the fact that\n       --  it requires a cleanup scope for the secondary stack case).\n \n-      if Is_Inherently_Limited_Type (Exptyp) then\n+      if Is_Inherently_Limited_Type (Exptyp)\n+        or else Is_Limited_Interface (Exptyp)\n+      then\n          null;\n \n       elsif not Requires_Transient_Scope (R_Type) then\n@@ -4154,10 +4227,10 @@ package body Exp_Ch5 is\n          else\n             Set_Storage_Pool      (N, RTE (RE_SS_Pool));\n \n-            --  If we are generating code for the Java VM do not use\n+            --  If we are generating code for the VM do not use\n             --  SS_Allocate since everything is heap-allocated anyway.\n \n-            if not Java_VM then\n+            if VM_Target = No_VM then\n                Set_Procedure_To_Call (N, RTE (RE_SS_Allocate));\n             end if;\n          end if;\n@@ -4239,7 +4312,11 @@ package body Exp_Ch5 is\n       --  return expression has a specific type whose level is known not to\n       --  be statically deeper than the function's result type.\n \n+      --  Note: accessibility check is skipped in the VM case, since there\n+      --  does not seem to be any practical way to implement this check.\n+\n       elsif Ada_Version >= Ada_05\n+        and then VM_Target = No_VM\n         and then Is_Class_Wide_Type (R_Type)\n         and then not Scope_Suppress (Accessibility_Check)\n         and then\n@@ -4251,19 +4328,44 @@ package body Exp_Ch5 is\n             or else Scope_Depth (Enclosing_Dynamic_Scope (Etype (Exp))) >\n                       Scope_Depth (Enclosing_Dynamic_Scope (Scope_Id)))\n       then\n-         Insert_Action (Exp,\n-           Make_Raise_Program_Error (Loc,\n-             Condition =>\n-               Make_Op_Gt (Loc,\n-                 Left_Opnd =>\n-                   Build_Get_Access_Level (Loc,\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix => Duplicate_Subexpr (Exp),\n-                     Attribute_Name => Name_Tag)),\n-                 Right_Opnd =>\n-                   Make_Integer_Literal (Loc,\n-                     Scope_Depth (Enclosing_Dynamic_Scope (Scope_Id)))),\n-             Reason => PE_Accessibility_Check_Failed));\n+         declare\n+            Tag_Node : Node_Id;\n+\n+         begin\n+            --  Ada 2005 (AI-251): In class-wide interface objects we displace\n+            --  \"this\" to reference the base of the object --- required to get\n+            --  access to the TSD of the object.\n+\n+            if Is_Class_Wide_Type (Etype (Exp))\n+              and then Is_Interface (Etype (Exp))\n+              and then Nkind (Exp) = N_Explicit_Dereference\n+            then\n+               Tag_Node :=\n+                 Make_Explicit_Dereference (Loc,\n+                   Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n+                     Make_Function_Call (Loc,\n+                       Name => New_Reference_To (RTE (RE_Base_Address), Loc),\n+                       Parameter_Associations => New_List (\n+                         Unchecked_Convert_To (RTE (RE_Address),\n+                           Duplicate_Subexpr (Prefix (Exp)))))));\n+            else\n+               Tag_Node :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix => Duplicate_Subexpr (Exp),\n+                   Attribute_Name => Name_Tag);\n+            end if;\n+\n+            Insert_Action (Exp,\n+              Make_Raise_Program_Error (Loc,\n+                Condition =>\n+                  Make_Op_Gt (Loc,\n+                    Left_Opnd =>\n+                      Build_Get_Access_Level (Loc, Tag_Node),\n+                    Right_Opnd =>\n+                      Make_Integer_Literal (Loc,\n+                        Scope_Depth (Enclosing_Dynamic_Scope (Scope_Id)))),\n+                Reason => PE_Accessibility_Check_Failed));\n+         end;\n       end if;\n    end Expand_Simple_Function_Return;\n \n@@ -4281,12 +4383,16 @@ package body Exp_Ch5 is\n \n       Save_Tag : constant Boolean := Is_Tagged_Type (T)\n                                        and then not No_Ctrl_Actions (N)\n-                                       and then not Java_VM;\n-      --  Tags are not saved and restored when Java_VM because JVM tags are\n+                                       and then VM_Target = No_VM;\n+      --  Tags are not saved and restored when VM_Target because VM tags are\n       --  represented implicitly in objects.\n \n-      Res       : List_Id;\n-      Tag_Tmp   : Entity_Id;\n+      Res      : List_Id;\n+      Tag_Tmp  : Entity_Id;\n+\n+      Prev_Tmp : Entity_Id;\n+      Next_Tmp : Entity_Id;\n+      Ctrl_Ref : Node_Id;\n \n    begin\n       Res := New_List;\n@@ -4346,315 +4452,382 @@ package body Exp_Ch5 is\n          Tag_Tmp := Empty;\n       end if;\n \n-      --  Processing for controlled types and types with controlled components\n+      if Ctrl_Act then\n+         if VM_Target /= No_VM then\n \n-      --  Variables of such types contain pointers used to chain them in\n-      --  finalization lists, in addition to user data. These pointers are\n-      --  specific to each object of the type, not to the value being assigned.\n-      --  Thus they need to be left intact during the assignment. We achieve\n-      --  this by constructing a Storage_Array subtype, and by overlaying\n-      --  objects of this type on the source and target of the assignment. The\n-      --  assignment is then rewritten to assignments of slices of these\n-      --  arrays, copying the user data, and leaving the pointers untouched.\n+            --  Cannot assign part of the object in a VM context, so instead\n+            --  fallback to the previous mechanism, even though it is not\n+            --  completely correct ???\n \n-      if Ctrl_Act then\n-         Controlled_Actions : declare\n-            Prev_Ref : Node_Id;\n-            --  A reference to the Prev component of the record controller\n-\n-            First_After_Root : Node_Id := Empty;\n-            --  Index of first byte to be copied (used to skip\n-            --  Root_Controlled in controlled objects).\n-\n-            Last_Before_Hole : Node_Id := Empty;\n-            --  Index of last byte to be copied before outermost record\n-            --  controller data.\n-\n-            Hole_Length      : Node_Id := Empty;\n-            --  Length of record controller data (Prev and Next pointers)\n-\n-            First_After_Hole : Node_Id := Empty;\n-            --  Index of first byte to be copied after outermost record\n-            --  controller data.\n-\n-            Expr, Source_Size     : Node_Id;\n-            Source_Actual_Subtype : Entity_Id;\n-            --  Used for computation of the size of the data to be copied\n-\n-            Range_Type  : Entity_Id;\n-            Opaque_Type : Entity_Id;\n-\n-            function Build_Slice\n-              (Rec : Entity_Id;\n-               Lo  : Node_Id;\n-               Hi  : Node_Id) return Node_Id;\n-            --  Build and return a slice of an array of type S overlaid on\n-            --  object Rec, with bounds specified by Lo and Hi. If either bound\n-            --  is empty, a default of S'First (respectively S'Last) is used.\n-\n-            -----------------\n-            -- Build_Slice --\n-            -----------------\n-\n-            function Build_Slice\n-              (Rec : Node_Id;\n-               Lo  : Node_Id;\n-               Hi  : Node_Id) return Node_Id\n-            is\n-               Lo_Bound : Node_Id;\n-               Hi_Bound : Node_Id;\n-\n-               Opaque : constant Node_Id :=\n-                          Unchecked_Convert_To (Opaque_Type,\n-                            Make_Attribute_Reference (Loc,\n-                              Prefix         => Rec,\n-                              Attribute_Name => Name_Address));\n-               --  Access value designating an opaque storage array of type S\n-               --  overlaid on record Rec.\n+            --  Save the Finalization Pointers in local variables Prev_Tmp and\n+            --  Next_Tmp. For objects with Has_Controlled_Component set, these\n+            --  pointers are in the Record_Controller\n \n-            begin\n-               --  Compute slice bounds using S'First (1) and S'Last as default\n-               --  values when not specified by the caller.\n+            Ctrl_Ref := Duplicate_Subexpr (L);\n \n-               if No (Lo) then\n-                  Lo_Bound := Make_Integer_Literal (Loc, 1);\n-               else\n-                  Lo_Bound := Lo;\n-               end if;\n+            if Has_Controlled_Component (T) then\n+               Ctrl_Ref :=\n+                 Make_Selected_Component (Loc,\n+                   Prefix => Ctrl_Ref,\n+                   Selector_Name =>\n+                     New_Reference_To (Controller_Component (T), Loc));\n+            end if;\n \n-               if No (Hi) then\n-                  Hi_Bound := Make_Attribute_Reference (Loc,\n-                    Prefix => New_Occurrence_Of (Range_Type, Loc),\n-                    Attribute_Name => Name_Last);\n-               else\n-                  Hi_Bound := Hi;\n-               end if;\n+            Prev_Tmp :=\n+              Make_Defining_Identifier (Loc, New_Internal_Name ('B'));\n \n-               return Make_Slice (Loc,\n-                 Prefix =>\n-                   Opaque,\n-                 Discrete_Range => Make_Range (Loc,\n-                   Lo_Bound, Hi_Bound));\n-            end Build_Slice;\n+            Append_To (Res,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Prev_Tmp,\n \n-         --  Start of processing for Controlled_Actions\n+                Object_Definition =>\n+                  New_Reference_To (RTE (RE_Finalizable_Ptr), Loc),\n \n-         begin\n-            --  Create a constrained subtype of Storage_Array whose size\n-            --  corresponds to the value being assigned.\n+                Expression =>\n+                  Make_Selected_Component (Loc,\n+                    Prefix =>\n+                      Unchecked_Convert_To (RTE (RE_Finalizable), Ctrl_Ref),\n+                    Selector_Name => Make_Identifier (Loc, Name_Prev))));\n+\n+            Next_Tmp :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_Internal_Name ('C'));\n \n-            --  subtype G is Storage_Offset range\n-            --    1 .. (Expr'Size + Storage_Unit - 1) / Storage_Unit\n+            Append_To (Res,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Next_Tmp,\n \n-            Expr := Duplicate_Subexpr_No_Checks (Expression (N));\n+                Object_Definition   =>\n+                  New_Reference_To (RTE (RE_Finalizable_Ptr), Loc),\n \n-            if Nkind (Expr) = N_Qualified_Expression then\n-               Expr := Expression (Expr);\n-            end if;\n+                Expression          =>\n+                  Make_Selected_Component (Loc,\n+                    Prefix =>\n+                      Unchecked_Convert_To (RTE (RE_Finalizable),\n+                        New_Copy_Tree (Ctrl_Ref)),\n+                    Selector_Name => Make_Identifier (Loc, Name_Next))));\n \n-            Source_Actual_Subtype := Etype (Expr);\n+            --  Do the Assignment\n \n-            if Has_Discriminants (Source_Actual_Subtype)\n-              and then not Is_Constrained (Source_Actual_Subtype)\n-            then\n-               Append_To (Res,\n-                 Build_Actual_Subtype (Source_Actual_Subtype, Expr));\n-               Source_Actual_Subtype := Defining_Identifier (Last (Res));\n-            end if;\n+            Append_To (Res, Relocate_Node (N));\n \n-            Source_Size :=\n-              Make_Op_Add (Loc,\n-                Left_Opnd =>\n-                  Make_Attribute_Reference (Loc,\n+         else\n+            --  Regular (non VM) processing for controlled types and types with\n+            --  controlled components\n+\n+            --  Variables of such types contain pointers used to chain them in\n+            --  finalization lists, in addition to user data. These pointers\n+            --  are specific to each object of the type, not to the value being\n+            --  assigned.\n+\n+            --  Thus they need to be left intact during the assignment. We\n+            --  achieve this by constructing a Storage_Array subtype, and by\n+            --  overlaying objects of this type on the source and target of the\n+            --  assignment. The assignment is then rewritten to assignments of\n+            --  slices of these arrays, copying the user data, and leaving the\n+            --  pointers untouched.\n+\n+            Controlled_Actions : declare\n+               Prev_Ref : Node_Id;\n+               --  A reference to the Prev component of the record controller\n+\n+               First_After_Root : Node_Id := Empty;\n+               --  Index of first byte to be copied (used to skip\n+               --  Root_Controlled in controlled objects).\n+\n+               Last_Before_Hole : Node_Id := Empty;\n+               --  Index of last byte to be copied before outermost record\n+               --  controller data.\n+\n+               Hole_Length : Node_Id := Empty;\n+               --  Length of record controller data (Prev and Next pointers)\n+\n+               First_After_Hole : Node_Id := Empty;\n+               --  Index of first byte to be copied after outermost record\n+               --  controller data.\n+\n+               Expr, Source_Size     : Node_Id;\n+               Source_Actual_Subtype : Entity_Id;\n+               --  Used for computation of the size of the data to be copied\n+\n+               Range_Type  : Entity_Id;\n+               Opaque_Type : Entity_Id;\n+\n+               function Build_Slice\n+                 (Rec : Entity_Id;\n+                  Lo  : Node_Id;\n+                  Hi  : Node_Id) return Node_Id;\n+               --  Build and return a slice of an array of type S overlaid on\n+               --  object Rec, with bounds specified by Lo and Hi. If either\n+               --  bound is empty, a default of S'First (respectively S'Last)\n+               --  is used.\n+\n+               -----------------\n+               -- Build_Slice --\n+               -----------------\n+\n+               function Build_Slice\n+                 (Rec : Node_Id;\n+                  Lo  : Node_Id;\n+                  Hi  : Node_Id) return Node_Id\n+               is\n+                  Lo_Bound : Node_Id;\n+                  Hi_Bound : Node_Id;\n+\n+                  Opaque : constant Node_Id :=\n+                             Unchecked_Convert_To (Opaque_Type,\n+                               Make_Attribute_Reference (Loc,\n+                                 Prefix         => Rec,\n+                                 Attribute_Name => Name_Address));\n+                  --  Access value designating an opaque storage array of type\n+                  --  S overlaid on record Rec.\n+\n+               begin\n+                  --  Compute slice bounds using S'First (1) and S'Last as\n+                  --  default values when not specified by the caller.\n+\n+                  if No (Lo) then\n+                     Lo_Bound := Make_Integer_Literal (Loc, 1);\n+                  else\n+                     Lo_Bound := Lo;\n+                  end if;\n+\n+                  if No (Hi) then\n+                     Hi_Bound := Make_Attribute_Reference (Loc,\n+                       Prefix => New_Occurrence_Of (Range_Type, Loc),\n+                       Attribute_Name => Name_Last);\n+                  else\n+                     Hi_Bound := Hi;\n+                  end if;\n+\n+                  return Make_Slice (Loc,\n                     Prefix =>\n-                      New_Occurrence_Of (Source_Actual_Subtype, Loc),\n-                    Attribute_Name =>\n-                      Name_Size),\n-                Right_Opnd =>\n-                  Make_Integer_Literal (Loc,\n-                  System_Storage_Unit - 1));\n-            Source_Size :=\n-              Make_Op_Divide (Loc,\n-                Left_Opnd => Source_Size,\n-                Right_Opnd =>\n-                  Make_Integer_Literal (Loc,\n-                    Intval => System_Storage_Unit));\n-\n-            Range_Type :=\n-              Make_Defining_Identifier (Loc,\n-                New_Internal_Name ('G'));\n+                      Opaque,\n+                    Discrete_Range => Make_Range (Loc,\n+                      Lo_Bound, Hi_Bound));\n+               end Build_Slice;\n \n-            Append_To (Res,\n-              Make_Subtype_Declaration (Loc,\n-                Defining_Identifier => Range_Type,\n-                Subtype_Indication =>\n-                  Make_Subtype_Indication (Loc,\n-                    Subtype_Mark =>\n-                      New_Reference_To (RTE (RE_Storage_Offset), Loc),\n-                    Constraint   => Make_Range_Constraint (Loc,\n-                      Range_Expression =>\n-                        Make_Range (Loc,\n-                          Low_Bound  => Make_Integer_Literal (Loc, 1),\n-                          High_Bound => Source_Size)))));\n-\n-            --  subtype S is Storage_Array (G)\n+            --  Start of processing for Controlled_Actions\n \n-            Append_To (Res,\n-              Make_Subtype_Declaration (Loc,\n-                Defining_Identifier =>\n-                  Make_Defining_Identifier (Loc,\n-                    New_Internal_Name ('S')),\n-                Subtype_Indication  =>\n-                  Make_Subtype_Indication (Loc,\n-                    Subtype_Mark =>\n-                      New_Reference_To (RTE (RE_Storage_Array), Loc),\n-                    Constraint =>\n-                      Make_Index_Or_Discriminant_Constraint (Loc,\n-                        Constraints =>\n-                          New_List (New_Reference_To (Range_Type, Loc))))));\n-\n-            --  type A is access S\n-\n-            Opaque_Type :=\n-              Make_Defining_Identifier (Loc,\n-                Chars => New_Internal_Name ('A'));\n+            begin\n+               --  Create a constrained subtype of Storage_Array whose size\n+               --  corresponds to the value being assigned.\n \n-            Append_To (Res,\n-              Make_Full_Type_Declaration (Loc,\n-                Defining_Identifier => Opaque_Type,\n-                Type_Definition     =>\n-                  Make_Access_To_Object_Definition (Loc,\n-                    Subtype_Indication =>\n-                      New_Occurrence_Of (\n-                        Defining_Identifier (Last (Res)), Loc))));\n+               --  subtype G is Storage_Offset range\n+               --    1 .. (Expr'Size + Storage_Unit - 1) / Storage_Unit\n+\n+               Expr := Duplicate_Subexpr_No_Checks (Expression (N));\n \n-            --  Generate appropriate slice assignments\n+               if Nkind (Expr) = N_Qualified_Expression then\n+                  Expr := Expression (Expr);\n+               end if;\n \n-            First_After_Root := Make_Integer_Literal (Loc, 1);\n+               Source_Actual_Subtype := Etype (Expr);\n \n-            --  For the case of a controlled object, skip the\n-            --  Root_Controlled part.\n+               if Has_Discriminants (Source_Actual_Subtype)\n+                 and then not Is_Constrained (Source_Actual_Subtype)\n+               then\n+                  Append_To (Res,\n+                    Build_Actual_Subtype (Source_Actual_Subtype, Expr));\n+                  Source_Actual_Subtype := Defining_Identifier (Last (Res));\n+               end if;\n \n-            if Is_Controlled (T) then\n-               First_After_Root :=\n+               Source_Size :=\n                  Make_Op_Add (Loc,\n-                   First_After_Root,\n-                   Make_Op_Divide (Loc,\n+                   Left_Opnd =>\n                      Make_Attribute_Reference (Loc,\n                        Prefix =>\n-                         New_Occurrence_Of (RTE (RE_Root_Controlled), Loc),\n-                       Attribute_Name => Name_Size),\n-                     Make_Integer_Literal (Loc, System_Storage_Unit)));\n-            end if;\n+                         New_Occurrence_Of (Source_Actual_Subtype, Loc),\n+                     Attribute_Name => Name_Size),\n+                   Right_Opnd =>\n+                     Make_Integer_Literal (Loc,\n+                       Intval => System_Storage_Unit - 1));\n \n-            --  For the case of a record with controlled components, skip\n-            --  the Prev and Next components of the record controller.\n-            --  These components constitute a 'hole' in the middle of the\n-            --  data to be copied.\n+               Source_Size :=\n+                 Make_Op_Divide (Loc,\n+                   Left_Opnd => Source_Size,\n+                   Right_Opnd =>\n+                     Make_Integer_Literal (Loc,\n+                       Intval => System_Storage_Unit));\n \n-            if Has_Controlled_Component (T) then\n-               Prev_Ref :=\n-                 Make_Selected_Component (Loc,\n-                   Prefix =>\n-                     Make_Selected_Component (Loc,\n-                       Prefix => Duplicate_Subexpr_No_Checks (L),\n-                       Selector_Name =>\n-                         New_Reference_To (Controller_Component (T), Loc)),\n-                   Selector_Name =>  Make_Identifier (Loc, Name_Prev));\n+               Range_Type :=\n+                 Make_Defining_Identifier (Loc,\n+                   New_Internal_Name ('G'));\n \n-               --  Last index before hole: determined by position of\n-               --  the _Controller.Prev component.\n+               Append_To (Res,\n+                 Make_Subtype_Declaration (Loc,\n+                   Defining_Identifier => Range_Type,\n+                   Subtype_Indication =>\n+                     Make_Subtype_Indication (Loc,\n+                       Subtype_Mark =>\n+                         New_Reference_To (RTE (RE_Storage_Offset), Loc),\n+                       Constraint   => Make_Range_Constraint (Loc,\n+                         Range_Expression =>\n+                           Make_Range (Loc,\n+                             Low_Bound  => Make_Integer_Literal (Loc, 1),\n+                             High_Bound => Source_Size)))));\n+\n+               --  subtype S is Storage_Array (G)\n \n-               Last_Before_Hole :=\n+               Append_To (Res,\n+                 Make_Subtype_Declaration (Loc,\n+                   Defining_Identifier =>\n+                     Make_Defining_Identifier (Loc,\n+                       New_Internal_Name ('S')),\n+                   Subtype_Indication  =>\n+                     Make_Subtype_Indication (Loc,\n+                       Subtype_Mark =>\n+                         New_Reference_To (RTE (RE_Storage_Array), Loc),\n+                       Constraint =>\n+                         Make_Index_Or_Discriminant_Constraint (Loc,\n+                           Constraints =>\n+                             New_List (New_Reference_To (Range_Type, Loc))))));\n+\n+               --  type A is access S\n+\n+               Opaque_Type :=\n                  Make_Defining_Identifier (Loc,\n-                   New_Internal_Name ('L'));\n+                   Chars => New_Internal_Name ('A'));\n \n                Append_To (Res,\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Last_Before_Hole,\n-                   Object_Definition   => New_Occurrence_Of (\n-                     RTE (RE_Storage_Offset), Loc),\n-                   Constant_Present    => True,\n-                   Expression          => Make_Op_Add (Loc,\n-                       Make_Attribute_Reference (Loc,\n-                         Prefix => Prev_Ref,\n-                         Attribute_Name => Name_Position),\n-                       Make_Attribute_Reference (Loc,\n-                         Prefix => New_Copy_Tree (Prefix (Prev_Ref)),\n-                         Attribute_Name => Name_Position))));\n+                 Make_Full_Type_Declaration (Loc,\n+                   Defining_Identifier => Opaque_Type,\n+                   Type_Definition     =>\n+                     Make_Access_To_Object_Definition (Loc,\n+                       Subtype_Indication =>\n+                         New_Occurrence_Of (\n+                           Defining_Identifier (Last (Res)), Loc))));\n \n-               --  Hole length: size of the Prev and Next components\n+               --  Generate appropriate slice assignments\n \n-               Hole_Length :=\n-                 Make_Op_Multiply (Loc,\n-                   Left_Opnd  => Make_Integer_Literal (Loc, Uint_2),\n-                   Right_Opnd =>\n-                     Make_Op_Divide (Loc,\n-                       Left_Opnd =>\n-                         Make_Attribute_Reference (Loc,\n-                           Prefix         => New_Copy_Tree (Prev_Ref),\n-                           Attribute_Name => Name_Size),\n-                       Right_Opnd =>\n-                         Make_Integer_Literal (Loc,\n-                           Intval => System_Storage_Unit)));\n+               First_After_Root := Make_Integer_Literal (Loc, 1);\n \n-               --  First index after hole\n+               --  For the case of a controlled object, skip the\n+               --  Root_Controlled part.\n \n-               First_After_Hole :=\n-                 Make_Defining_Identifier (Loc,\n-                   New_Internal_Name ('F'));\n+               if Is_Controlled (T) then\n+                  First_After_Root :=\n+                    Make_Op_Add (Loc,\n+                      First_After_Root,\n+                      Make_Op_Divide (Loc,\n+                        Make_Attribute_Reference (Loc,\n+                          Prefix =>\n+                            New_Occurrence_Of (RTE (RE_Root_Controlled), Loc),\n+                          Attribute_Name => Name_Size),\n+                        Make_Integer_Literal (Loc, System_Storage_Unit)));\n+               end if;\n \n-               Append_To (Res,\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => First_After_Hole,\n-                   Object_Definition   => New_Occurrence_Of (\n-                     RTE (RE_Storage_Offset), Loc),\n-                   Constant_Present    => True,\n-                   Expression          =>\n-                     Make_Op_Add (Loc,\n-                       Left_Opnd  =>\n-                         Make_Op_Add (Loc,\n-                           Left_Opnd  =>\n-                             New_Occurrence_Of (Last_Before_Hole, Loc),\n-                           Right_Opnd => Hole_Length),\n-                       Right_Opnd => Make_Integer_Literal (Loc, 1))));\n-\n-               Last_Before_Hole := New_Occurrence_Of (Last_Before_Hole, Loc);\n-               First_After_Hole := New_Occurrence_Of (First_After_Hole, Loc);\n-            end if;\n+               --  For the case of a record with controlled components, skip\n+               --  the Prev and Next components of the record controller.\n+               --  These components constitute a 'hole' in the middle of the\n+               --  data to be copied.\n \n-            --  Assign the first slice (possibly skipping Root_Controlled,\n-            --  up to the beginning of the record controller if present,\n-            --  up to the end of the object if not).\n+               if Has_Controlled_Component (T) then\n+                  Prev_Ref :=\n+                    Make_Selected_Component (Loc,\n+                      Prefix =>\n+                        Make_Selected_Component (Loc,\n+                          Prefix => Duplicate_Subexpr_No_Checks (L),\n+                          Selector_Name =>\n+                            New_Reference_To (Controller_Component (T), Loc)),\n+                      Selector_Name =>  Make_Identifier (Loc, Name_Prev));\n+\n+                  --  Last index before hole: determined by position of\n+                  --  the _Controller.Prev component.\n+\n+                  Last_Before_Hole :=\n+                    Make_Defining_Identifier (Loc,\n+                      New_Internal_Name ('L'));\n+\n+                  Append_To (Res,\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Last_Before_Hole,\n+                      Object_Definition   => New_Occurrence_Of (\n+                        RTE (RE_Storage_Offset), Loc),\n+                      Constant_Present    => True,\n+                      Expression          => Make_Op_Add (Loc,\n+                          Make_Attribute_Reference (Loc,\n+                            Prefix => Prev_Ref,\n+                            Attribute_Name => Name_Position),\n+                          Make_Attribute_Reference (Loc,\n+                            Prefix => New_Copy_Tree (Prefix (Prev_Ref)),\n+                            Attribute_Name => Name_Position))));\n+\n+                  --  Hole length: size of the Prev and Next components\n+\n+                  Hole_Length :=\n+                    Make_Op_Multiply (Loc,\n+                      Left_Opnd  => Make_Integer_Literal (Loc, Uint_2),\n+                      Right_Opnd =>\n+                        Make_Op_Divide (Loc,\n+                          Left_Opnd =>\n+                            Make_Attribute_Reference (Loc,\n+                              Prefix         => New_Copy_Tree (Prev_Ref),\n+                              Attribute_Name => Name_Size),\n+                          Right_Opnd =>\n+                            Make_Integer_Literal (Loc,\n+                              Intval => System_Storage_Unit)));\n \n-            Append_To (Res, Make_Assignment_Statement (Loc,\n-              Name       => Build_Slice (\n-                Rec => Duplicate_Subexpr_No_Checks (L),\n-                Lo  => First_After_Root,\n-                Hi  => Last_Before_Hole),\n+                  --  First index after hole\n \n-              Expression => Build_Slice (\n-                Rec => Expression (N),\n-                Lo  => First_After_Root,\n-                Hi  => New_Copy_Tree (Last_Before_Hole))));\n+                  First_After_Hole :=\n+                    Make_Defining_Identifier (Loc,\n+                      New_Internal_Name ('F'));\n \n-            if Present (First_After_Hole) then\n+                  Append_To (Res,\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => First_After_Hole,\n+                      Object_Definition   => New_Occurrence_Of (\n+                        RTE (RE_Storage_Offset), Loc),\n+                      Constant_Present    => True,\n+                      Expression          =>\n+                        Make_Op_Add (Loc,\n+                          Left_Opnd  =>\n+                            Make_Op_Add (Loc,\n+                              Left_Opnd  =>\n+                                New_Occurrence_Of (Last_Before_Hole, Loc),\n+                              Right_Opnd => Hole_Length),\n+                          Right_Opnd => Make_Integer_Literal (Loc, 1))));\n+\n+                  Last_Before_Hole :=\n+                    New_Occurrence_Of (Last_Before_Hole, Loc);\n+                  First_After_Hole :=\n+                    New_Occurrence_Of (First_After_Hole, Loc);\n+               end if;\n \n-               --  If a record controller is present, copy the second slice,\n-               --  from right after the _Controller.Next component up to the\n-               --  end of the object.\n+               --  Assign the first slice (possibly skipping Root_Controlled,\n+               --  up to the beginning of the record controller if present,\n+               --  up to the end of the object if not).\n \n                Append_To (Res, Make_Assignment_Statement (Loc,\n                  Name       => Build_Slice (\n                    Rec => Duplicate_Subexpr_No_Checks (L),\n-                   Lo  => First_After_Hole,\n-                   Hi  => Empty),\n+                   Lo  => First_After_Root,\n+                   Hi  => Last_Before_Hole),\n+\n                  Expression => Build_Slice (\n-                   Rec => Duplicate_Subexpr_No_Checks (Expression (N)),\n-                   Lo  => New_Copy_Tree (First_After_Hole),\n-                   Hi  => Empty)));\n-            end if;\n-         end Controlled_Actions;\n+                   Rec => Expression (N),\n+                   Lo  => First_After_Root,\n+                   Hi  => New_Copy_Tree (Last_Before_Hole))));\n+\n+               if Present (First_After_Hole) then\n+\n+                  --  If a record controller is present, copy the second slice,\n+                  --  from right after the _Controller.Next component up to the\n+                  --  end of the object.\n+\n+                  Append_To (Res, Make_Assignment_Statement (Loc,\n+                    Name       => Build_Slice (\n+                      Rec => Duplicate_Subexpr_No_Checks (L),\n+                      Lo  => First_After_Hole,\n+                      Hi  => Empty),\n+                    Expression => Build_Slice (\n+                      Rec => Duplicate_Subexpr_No_Checks (Expression (N)),\n+                      Lo  => New_Copy_Tree (First_After_Hole),\n+                      Hi  => Empty)));\n+               end if;\n+            end Controlled_Actions;\n+         end if;\n \n       else\n          Append_To (Res, Relocate_Node (N));\n@@ -4673,10 +4846,34 @@ package body Exp_Ch5 is\n              Expression => New_Reference_To (Tag_Tmp, Loc)));\n       end if;\n \n-      --  Adjust the target after the assignment when controlled (not in the\n-      --  init proc since it is an initialization more than an assignment).\n-\n       if Ctrl_Act then\n+         if VM_Target /= No_VM then\n+            --  Restore the finalization pointers\n+\n+            Append_To (Res,\n+              Make_Assignment_Statement (Loc,\n+                Name =>\n+                  Make_Selected_Component (Loc,\n+                    Prefix =>\n+                      Unchecked_Convert_To (RTE (RE_Finalizable),\n+                        New_Copy_Tree (Ctrl_Ref)),\n+                    Selector_Name => Make_Identifier (Loc, Name_Prev)),\n+                Expression => New_Reference_To (Prev_Tmp, Loc)));\n+\n+            Append_To (Res,\n+              Make_Assignment_Statement (Loc,\n+                Name =>\n+                  Make_Selected_Component (Loc,\n+                    Prefix =>\n+                      Unchecked_Convert_To (RTE (RE_Finalizable),\n+                        New_Copy_Tree (Ctrl_Ref)),\n+                    Selector_Name => Make_Identifier (Loc, Name_Next)),\n+                Expression => New_Reference_To (Next_Tmp, Loc)));\n+         end if;\n+\n+         --  Adjust the target after the assignment when controlled (not in the\n+         --  init proc since it is an initialization more than an assignment).\n+\n          Append_List_To (Res,\n            Make_Adjust_Call (\n              Ref         => Duplicate_Subexpr_Move_Checks (L),\n@@ -4694,67 +4891,4 @@ package body Exp_Ch5 is\n          return Empty_List;\n    end Make_Tag_Ctrl_Assignment;\n \n-   ------------------------------------\n-   -- Possible_Bit_Aligned_Component --\n-   ------------------------------------\n-\n-   function Possible_Bit_Aligned_Component (N : Node_Id) return Boolean is\n-   begin\n-      case Nkind (N) is\n-\n-         --  Case of indexed component\n-\n-         when N_Indexed_Component =>\n-            declare\n-               P    : constant Node_Id   := Prefix (N);\n-               Ptyp : constant Entity_Id := Etype (P);\n-\n-            begin\n-               --  If we know the component size and it is less than 64, then\n-               --  we are definitely OK. The back end always does assignment\n-               --  of misaligned small objects correctly.\n-\n-               if Known_Static_Component_Size (Ptyp)\n-                 and then Component_Size (Ptyp) <= 64\n-               then\n-                  return False;\n-\n-               --  Otherwise, we need to test the prefix, to see if we are\n-               --  indexing from a possibly unaligned component.\n-\n-               else\n-                  return Possible_Bit_Aligned_Component (P);\n-               end if;\n-            end;\n-\n-         --  Case of selected component\n-\n-         when N_Selected_Component =>\n-            declare\n-               P    : constant Node_Id   := Prefix (N);\n-               Comp : constant Entity_Id := Entity (Selector_Name (N));\n-\n-            begin\n-               --  If there is no component clause, then we are in the clear\n-               --  since the back end will never misalign a large component\n-               --  unless it is forced to do so. In the clear means we need\n-               --  only the recursive test on the prefix.\n-\n-               if Component_May_Be_Bit_Aligned (Comp) then\n-                  return True;\n-               else\n-                  return Possible_Bit_Aligned_Component (P);\n-               end if;\n-            end;\n-\n-         --  If we have neither a record nor array component, it means that we\n-         --  have fallen off the top testing prefixes recursively, and we now\n-         --  have a stand alone object, where we don't have a problem.\n-\n-         when others =>\n-            return False;\n-\n-      end case;\n-   end Possible_Bit_Aligned_Component;\n-\n end Exp_Ch5;"}]}