{"sha": "bd6dd8453c857d8ee420c960503d8eb72de1aa75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ2ZGQ4NDUzYzg1N2Q4ZWU0MjBjOTYwNTAzZDhlYjcyZGUxYWE3NQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-04-02T03:58:33Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-04-02T03:58:33Z"}, "message": "90th Cygnus<->FSF quick merge\n\nFrom-SVN: r13831", "tree": {"sha": "06738d9c5eb08b5bba7232faeef34e816727c0b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06738d9c5eb08b5bba7232faeef34e816727c0b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd6dd8453c857d8ee420c960503d8eb72de1aa75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd6dd8453c857d8ee420c960503d8eb72de1aa75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd6dd8453c857d8ee420c960503d8eb72de1aa75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd6dd8453c857d8ee420c960503d8eb72de1aa75/comments", "author": null, "committer": null, "parents": [{"sha": "70e06f23df998477ef7b1b906968aef1f2afc388", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70e06f23df998477ef7b1b906968aef1f2afc388", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70e06f23df998477ef7b1b906968aef1f2afc388"}], "stats": {"total": 1740, "additions": 914, "deletions": 826}, "files": [{"sha": "d945770bc4f0164b680740e63b6014755174c851", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bd6dd8453c857d8ee420c960503d8eb72de1aa75", "patch": "@@ -1,3 +1,194 @@\n+Wed Mar 19 14:14:45 1997  Mike Stump  <mrs@cygnus.com>\n+\n+\t* parse.y (left_curly): Avoid trying to use any fields of\n+ \terror_mark_node, as there aren't any.\n+\n+Thu Mar 13 16:33:22 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* lex.c (do_identifier): Avoid breaking on overloaded methods\n+\tas default arguments.\n+\n+Wed Mar 12 13:55:10 1997  Hans-Peter Nilsson  <Hans-Peter.Nilsson@axis.se>\n+\n+        * call.c (add_template_candidate): Initialize the variable \"dummy\".\n+\n+Mon Mar 10 15:13:14 1997  Brendan Kehoe  <brendan@canuck.cygnus.com>\n+\n+\t* decl.c (start_decl): Make sure TYPE isn't an error_mark_node\n+\tbefore we try to use TYPE_SIZE and TREE_CONSTANT on it.\n+\n+Fri Mar  7 13:19:36 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* cp-tree.h (comp_ptr_ttypes, more_specialized): Add decl.\n+\t(debug_binfo): Delete decl, not needed.\n+\n+\t* tree.c (fnaddr_from_vtable_entry, function_arg_chain,\n+\tpromotes_to_aggr_type): Delete fns.\n+\t* cp-tree.h (FNADDR_FROM_VTABLE_ENTRY,\n+\tSET_FNADDR_FROM_VTABLE_ENTRY, FUNCTION_ARG_CHAIN,\n+\tPROMOTES_TO_AGGR_TYPE): Delete alternates to #if 1.\n+\n+\t* decl.c (pending_invalid_xref{,_file,_line}): Delete unused vars.\n+\n+\t* friend.c (is_friend_type): Delete fn.\n+\t* cp-tree.h (is_friend_type): Delete decl.\n+\n+\t* decl.c (original_result_rtx, double_ftype_double,\n+\tdouble_ftype_double_double, int_ftype_int, long_ftype_long,\n+\tfloat_ftype_float, ldouble_ftype_ldouble, last_dtor_insn): Make static.\n+\t* typeck.c (original_result_rtx, warn_synth): Delete extern decls.\n+\n+\t* decl.c (push_overloaded_decl{,_top_level}): Make static, adding\n+\tfwd decls.\n+\t* cp-tree.h (push_overloaded_decl{,_top_level}): Delete decls.\n+\n+\t* decl.c (pushdecl_nonclass_level): #if 0, unused.\n+\t* cp-tree.h (pushdecl_nonclass_level): #if 0 decl.\n+\n+\t* lex.c (reinit_lang_specific): #if 0, unused.\n+\t* cp-tree.h (reinit_lang_specific): #if 0 decl.\n+\n+\t* decl.c (revert_static_member_fn): Make static, adding fwd decl.\n+\t* cp-tree.h (revert_static_member_fn): Delete decl.\n+\n+\t* class.c (root_lang_context_p): Delete fn.\n+\t* cp-tree.h (root_lang_context_p): Delete decl.\n+\n+\t* decl.c (set_current_level_tags_transparency): #if 0, unused.\n+\t* cp-tree.h (set_current_level_tags_transparency): #if 0 decl.\n+\n+\t* lex.c (set_vardecl_interface_info): Make static.\n+\t* cp-tree.h (set_vardecl_interface_info): Delete decl.\n+\n+\t* call.c (find_scoped_type): Make static.\n+\t* cp-tree.h (find_scoped_type): Delete decl.\n+\n+\t* search.c (convert_pointer_to_vbase): Make static.\n+\t* cp-tree.h (convert_pointer_to_vbase): Delete decl.\n+\n+\t* decl.c (const_ptr_type_node): Likewise.\n+\t* cp-tree.h (const_ptr_type_node): Delete decl.\n+\n+\t* typeck.c (common_base_type): Make static.\n+\t* cp-tree.h (common_base_types): Delete erroneous decl.\n+\n+\t* pt.c (classtype_mangled_name): Make static.\n+\t* cp-tree.h (classtype_mangled_name): Delete decl.\n+\n+\t* lex.c (check_newline): Make static.\n+\t* cp-tree.h (check_newline): Delete decl.\n+\n+\t* typeck.c (build_x_array_ref): Delete fn, same idea as\n+\tgrok_array_decl.\n+\t* cp-tree.h (build_x_array_ref): Delete decl.\n+\n+\t* lex.c (copy_decl_lang_specific): Delete fn, same idea as\n+\tcopy_lang_decl.\n+\t* cp-tree.h (copy_decl_lang_specific): #if 0 decl.\n+\n+\t* class.c (build_vtable_entry): Make static.\n+\t* cp-tree.h (build_vtable_entry): Delete decl.\n+\n+\t* class.c (build_vbase_pointer): Make static.\n+\t* cp-tree.h (build_vbase_pointer): Delete decl.\n+\n+\t* sig.c (build_sptr_ref): Add forward decl and make static.\n+\t* cp-tree.h (build_sptr_ref): Delete decl.\n+\n+\t* call.c (build_new_method_call): Add forward decl and make static.\n+\t* cp-tree.h (build_new_method_call): Delete decl.\n+\n+\t* call.c (build_object_call): Make static.\n+\t* class.c (check_for_override, complete_type_p, mark_overriders):\n+\tLikewise.\n+\t* decl.c (cp_function_chain): Likewise.\n+\t* lex.c (set_typedecl_interface_info, reinit_parse_for_block):\n+\tLikewise.\n+\t* pt.c (comp_template_args, get_class_bindings, push_tinst_level):\n+\tLikewise.\n+\t* tree.c (build_cplus_array_type_1): Likewise.\n+\t* typeck.c (comp_ptr_ttypes_{const,real,reinterpret}): Likewise.\n+\t(comp_target_parms): Likewise.\n+\n+\t* init.c (build_builtin_call): Make static.\n+\t* cp-tree.h (build_builtin_call): Delete decl.\n+\n+\t* typeck.c (binary_op_error): Delete decl.\n+\t* cp-tree.h (binary_op_error): Likewise.\n+\n+Thu Mar  6 16:13:52 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* call.c (build_method_call): Compare against error_mark_node\n+\tdirectly, rather than the ERROR_MARK tree code.\n+\t* cvt.c (cp_convert): Likewise.\n+\t* decl.c (print_binding_level): Likewise.\n+\t(duplicate_decls): Likewise.\n+\t(grokdeclarator): Likewise.\n+\t(grokdeclarator): Likewise.\n+\t* init.c (expand_aggr_init_1): Likewise.\n+\t(decl_constant_value): Likewise.\n+\t* method.c (build_opfncall): Likewise.\n+\t(hack_identifier): Likewise.\n+\t* typeck.c (build_modify_expr): Likewise.\n+\n+\t* typeck.c (build_c_cast): Don't decl TYPE as register tree.\n+\n+Sun Mar  2 02:54:36 1997  Bruno Haible  <bruno@linuix.mathematik.uni-karlsruhe.de>\n+\n+\t* pt.c (unify): Strip NOP_EXPR wrappers before unifying integer values.\n+\n+\t* pt.c (coerce_template_parms): Add new error message.\n+\n+\t* method.c (build_overload_value): Implement name mangling for\n+\tfloating-point template arguments.\n+\n+\t* method.c (build_overload_int, icat, dicat): Fix mangling of template\n+\targuments whose absolute value doesn't fit in a signed word.\n+\n+Mon Mar  3 12:14:54 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* friend.c: New file; put all of the friend stuff in here.\n+\t* init.c: Instead of here.\n+\t* Makefile.in (CXX_OBJS): Add friend.o.\n+\t(friend.o): Add dependencies.\n+\t* Make-lang.in (CXX_SRCS): Add $(srcdir)/cp/friend.c.\n+\n+Sun Mar  2 11:04:43 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* call.c (build_scoped_method_call): Complain if the scope isn't a\n+ \tbase.\n+\n+Wed Feb 26 11:31:06 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* parse.y (left_curly): Don't crash on erroneous type.\n+\n+\t* init.c (build_delete): Fix type of ref.\n+\n+Tue Feb 25 12:41:48 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* search.c (get_vbase_1): Renamed from get_vbase.\n+\t(get_vbase): Wrapper, now non-static.\n+\t(convert_pointer_to_vbase): Now static.\n+\n+\t* call.c (build_scoped_method_call): Accept a binfo for BASETYPE.\n+\t* init.c (build_delete): Pass one.\n+\t(build_partial_cleanup_for): Use build_scoped_method_call.\n+\t* decl.c (finish_function): Pass a binfo.\n+\n+Mon Feb 24 15:00:12 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* call.c (build_over_call): Only synthesize non-trivial copy ctors.\n+\n+\t* typeck.c (build_c_cast): Lose other reference to flag.\n+\n+\t* call.c (build_field_call): Don't look for [cd]tor_identifier.\n+\t* decl2.c (delete_sanity): Remove meaningless use of\n+ \tLOOKUP_HAS_IN_CHARGE.\n+\t* decl.c (finish_function): Use build_scoped_method_call instead\n+ \tof build_delete for running vbase dtors.\n+\t* init.c (build_delete): Call overload resolution code instead of\n+ \tduplicating it badly.\n+\n Thu Feb 20 15:12:15 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* call.c (build_over_call): Call mark_used before trying to elide"}, {"sha": "2dcfe43425c6cb418812a3ec8e3882b4d67001e8", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=bd6dd8453c857d8ee420c960503d8eb72de1aa75", "patch": "@@ -118,8 +118,9 @@ CXX_SRCS = $(srcdir)/cp/call.c $(srcdir)/cp/decl2.c \\\n  $(srcdir)/cp/ptree.c $(srcdir)/cp/tree.c $(srcdir)/cp/cvt.c \\\n  $(srcdir)/cp/errfn.c $(srcdir)/cp/rtti.c $(srcdir)/cp/method.c \\\n  $(srcdir)/cp/search.c $(srcdir)/cp/typeck.c $(srcdir)/cp/decl.c \\\n- $(srcdir)/cp/error.c $(srcdir)/cp/init.c $(srcdir)/cp/parse.y \\\n- $(srcdir)/cp/sig.c $(srcdir)/cp/typeck2.c $(srcdir)/cp/repo.c\n+ $(srcdir)/cp/error.c $(srcdir)/cp/friend.c $(srcdir)/cp/init.c \\\n+ $(srcdir)/cp/parse.y $(srcdir)/cp/sig.c $(srcdir)/cp/typeck2.c \\\n+ $(srcdir)/cp/repo.c\n \n cc1plus: $(P) $(CXX_SRCS) $(LIBDEPS) stamp-objlist c-common.o c-pragma.o\n \tcd cp; $(MAKE) $(FLAGS_TO_PASS) $(CXX_FLAGS_TO_PASS) ../cc1plus"}, {"sha": "03ba91a500f6dbfb089e13e6a628adc3248eecc6", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=bd6dd8453c857d8ee420c960503d8eb72de1aa75", "patch": "@@ -160,7 +160,7 @@ INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config\n \n CXX_OBJS = call.o decl.o errfn.o expr.o pt.o sig.o typeck2.o \\\n  class.o decl2.o error.o lex.o parse.o ptree.o rtti.o spew.o typeck.o cvt.o \\\n- except.o init.o method.o search.o tree.o xref.o repo.o\n+ except.o friend.o init.o method.o search.o tree.o xref.o repo.o\n \n # Language-independent object files.\n OBJS = `cat ../stamp-objlist` ../c-common.o ../c-pragma.o\n@@ -231,6 +231,7 @@ typeck2.o : typeck2.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h\n typeck.o : typeck.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H)\n class.o : class.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h\n call.o : call.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h class.h\n+friend.o : friend.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H)\n init.o : init.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H)\n method.o : method.c $(CONFIG_H) $(CXX_TREE_H) class.h\n cvt.o : cvt.c $(CONFIG_H) $(CXX_TREE_H) class.h"}, {"sha": "df4ced9af19e942ff1bba95e9fc948f2aac225d8", "filename": "gcc/cp/call.c", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=bd6dd8453c857d8ee420c960503d8eb72de1aa75", "patch": "@@ -44,6 +44,7 @@ extern tree ctor_label, dtor_label;\n    between an expected and the given type.  */\n \n static struct harshness_code convert_harshness PROTO((register tree, register tree, tree));\n+static tree build_new_method_call\t\tPROTO((tree, tree, tree, tree, int));\n \n #define EVIL_RETURN(ARG)\t((ARG).code = EVIL_CODE, (ARG))\n #define STD_RETURN(ARG)\t\t((ARG).code = STD_CODE, (ARG))\n@@ -1175,6 +1176,9 @@ build_field_call (basetype_path, instance_ptr, name, parms)\n {\n   tree field, instance;\n \n+  if (name == ctor_identifier || name == dtor_identifier)\n+    return NULL_TREE;\n+\n   if (instance_ptr == current_class_ptr)\n     {\n       /* Check to see if we really have a reference to an instance variable\n@@ -1266,7 +1270,7 @@ build_field_call (basetype_path, instance_ptr, name, parms)\n   return NULL_TREE;\n }\n \n-tree\n+static tree\n find_scoped_type (type, inner_name, inner_types)\n      tree type, inner_name, inner_types;\n {\n@@ -1424,6 +1428,14 @@ build_scoped_method_call (exp, basetype, name, parms)\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     type = TREE_TYPE (type);\n \n+  if (TREE_CODE (basetype) == TREE_VEC)\n+    {\n+      binfo = basetype;\n+      basetype = BINFO_TYPE (binfo);\n+    }\n+  else\n+    binfo = NULL_TREE;\n+\n   /* Destructors can be \"called\" for simple types; see 5.2.4 and 12.4 Note\n      that explicit ~int is caught in the parser; this deals with typedefs\n      and template parms.  */\n@@ -1449,13 +1461,21 @@ build_scoped_method_call (exp, basetype, name, parms)\n       return error_mark_node;\n     }\n \n-  if ((binfo = binfo_or_else (basetype, type)))\n+  if (! binfo)\n     {\n+      binfo = get_binfo (basetype, type, 1);\n       if (binfo == error_mark_node)\n \treturn error_mark_node;\n+      if (! binfo)\n+\terror_not_base_type (basetype, type);\n+    }\n+\n+  if (binfo)\n+    {\n       if (TREE_CODE (exp) == INDIRECT_REF)\n-\tdecl = build_indirect_ref (convert_pointer_to (binfo,\n-\t\t\t\t\t\t       build_unary_op (ADDR_EXPR, exp, 0)), NULL_PTR);\n+\tdecl = build_indirect_ref\n+\t  (convert_pointer_to_real\n+\t   (binfo, build_unary_op (ADDR_EXPR, exp, 0)), NULL_PTR);\n       else\n \tdecl = build_scoped_ref (exp, basetype);\n \n@@ -1820,7 +1840,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n       if (! IS_AGGR_TYPE (basetype))\n \t{\n \tnon_aggr_error:\n-\t  if ((flags & LOOKUP_COMPLAIN) && TREE_CODE (basetype) != ERROR_MARK)\n+\t  if ((flags & LOOKUP_COMPLAIN) && basetype != error_mark_node)\n \t    cp_error (\"request for member `%D' in `%E', which is of non-aggregate type `%T'\",\n \t\t      name, instance, basetype);\n \n@@ -2568,7 +2588,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\t   && TREE_OPERAND (TREE_OPERAND (instance_ptr, 0), 0) == instance)\n \t    ;\n \t  /* The call to `convert_pointer_to' may return error_mark_node.  */\n-\t  else if (TREE_CODE (instance_ptr) == ERROR_MARK)\n+\t  else if (instance_ptr == error_mark_node)\n \t    return instance_ptr;\n \t  else if (instance == NULL_TREE\n \t\t   || TREE_CODE (instance) != INDIRECT_REF\n@@ -4074,7 +4094,7 @@ add_template_candidate (candidates, tmpl, arglist, flags)\n   int ntparms = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (tmpl));\n   tree *targs = (tree *) alloca (sizeof (tree) * ntparms);\n   struct z_candidate *cand;\n-  int i, dummy; \n+  int i, dummy = 0;\n   tree fn;\n \n   i = type_unification (DECL_TEMPLATE_PARMS (tmpl), targs,\n@@ -4356,7 +4376,7 @@ build_new_function_call (fn, args, obj)\n   return build_function_call (fn, args);\n }\n \n-tree\n+static tree\n build_object_call (obj, args)\n      tree obj, args;\n {\n@@ -5092,10 +5112,6 @@ build_over_call (fn, convs, args, flags)\n \n   converted_args = nreverse (converted_args);\n \n-  /* [class.copy]: the copy constructor is implicitly defined even if the\n-     implementation  elided  its  use.  */\n-  mark_used (fn);\n-\n   /* Avoid actually calling copy constructors and copy assignment operators,\n      if possible.  */\n   if (DECL_CONSTRUCTOR_P (fn)\n@@ -5119,6 +5135,11 @@ build_over_call (fn, convs, args, flags)\n       else\n \targ = build_indirect_ref (arg, 0);\n \n+      /* [class.copy]: the copy constructor is implicitly defined even if\n+\t the implementation elided its use.  */\n+      if (TYPE_HAS_COMPLEX_INIT_REF (DECL_CONTEXT (fn)))\n+\tmark_used (fn);\n+\n       /* If we're creating a temp and we already have one, don't create a\n          new one.  If we're not creating a temp but we get one, use\n          INIT_EXPR to collapse the temp into our target.  Otherwise, if the\n@@ -5159,6 +5180,8 @@ build_over_call (fn, convs, args, flags)\n       return val;\n     }\n \n+  mark_used (fn);\n+\n   if (DECL_CONTEXT (fn) && IS_SIGNATURE (DECL_CONTEXT (fn)))\n     return build_signature_method_call (fn, converted_args);\n   else if (DECL_VINDEX (fn) && (flags & LOOKUP_NONVIRTUAL) == 0)\n@@ -5186,7 +5209,7 @@ build_over_call (fn, convs, args, flags)\n   return convert_from_reference (require_complete_type (fn));\n }\n \n-tree\n+static tree\n build_new_method_call (instance, name, args, basetype_path, flags)\n      tree instance, name, args, basetype_path;\n      int flags;"}, {"sha": "5ada32baf9e300e7060ecd1e450bee0d65c5a57a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=bd6dd8453c857d8ee420c960503d8eb72de1aa75", "patch": "@@ -121,7 +121,7 @@ int n_inner_fields_searched = 0;\n \n /* Virtual baseclass things.  */\n \n-tree\n+static tree\n build_vbase_pointer (exp, type)\n      tree exp, type;\n {\n@@ -135,7 +135,7 @@ build_vbase_pointer (exp, type)\n /* Is the type of the EXPR, the complete type of the object?\n    If we are going to be wrong, we must be conservative, and return 0.  */\n \n-int\n+static int\n complete_type_p (expr)\n      tree expr;\n {\n@@ -372,11 +372,10 @@ static tree pending_hard_virtuals;\n    Note that the index (DELTA2) in the virtual function table\n    is always 0.  */\n \n-tree\n+static tree\n build_vtable_entry (delta, pfn)\n      tree delta, pfn;\n {\n-\n   if (flag_vtable_thunks)\n     {\n       HOST_WIDE_INT idelta = TREE_INT_CST_LOW (delta);\n@@ -2755,7 +2754,7 @@ get_basefndecls (fndecl, t)\n    Since we start out with all functions already marked with a hider,\n    no need to mark functions that are just hidden.  */\n \n-void\n+static void\n mark_overriders (fndecl, base_fndecls)\n      tree fndecl, base_fndecls;\n {\n@@ -2772,7 +2771,7 @@ mark_overriders (fndecl, base_fndecls)\n    a method declared virtual in the base class, then\n    mark this field as being virtual as well.  */\n \n-void\n+static void\n check_for_override (decl, ctype)\n      tree decl, ctype;\n {\n@@ -4821,12 +4820,6 @@ pop_lang_context ()\n   else if (current_lang_name == lang_name_c)\n     strict_prototype = strict_prototypes_lang_c;\n }\n-\n-int\n-root_lang_context_p ()\n-{\n-  return current_lang_stack == current_lang_base;\n-}\n \f\n /* Type instantiation routines.  */\n "}, {"sha": "31cc776a7c02fcec4021032d26b1d489d1ed3f82", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 36, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=bd6dd8453c857d8ee420c960503d8eb72de1aa75", "patch": "@@ -325,14 +325,12 @@ enum languages { lang_c, lang_cplusplus };\n /* In a *_TYPE, nonzero means a built-in type.  */\n #define TYPE_BUILT_IN(NODE) TYPE_LANG_FLAG_6(NODE)\n \n-/* Macros which might want to be replaced by function calls.  */\n-\n #define DELTA_FROM_VTABLE_ENTRY(ENTRY) \\\n   (!flag_vtable_thunks ? \\\n      TREE_VALUE (CONSTRUCTOR_ELTS (ENTRY)) \\\n    : TREE_CODE (TREE_OPERAND ((ENTRY), 0)) != THUNK_DECL ? integer_zero_node \\\n    : build_int_2 (THUNK_DELTA (TREE_OPERAND ((ENTRY), 0)), 0))\n-#if 1\n+\n /* Virtual function addresses can be gotten from a virtual function\n    table entry using this macro.  */\n #define FNADDR_FROM_VTABLE_ENTRY(ENTRY) \\\n@@ -348,14 +346,6 @@ enum languages { lang_c, lang_cplusplus };\n        && IS_AGGR_TYPE (TREE_TYPE (NODE)))\t\\\n    || IS_AGGR_TYPE (NODE))\n \n-#else\n-#define FNADDR_FROM_VTABLE_ENTRY(ENTRY) (fnaddr_from_vtable_entry (ENTRY))\n-#define SET_FNADDR_FROM_VTABLE_ENTRY(ENTRY,VALUE) \\\n-  (set_fnaddr_from_vtable_entry (ENTRY, VALUE))\n-/* #define TYPE_NAME_STRING(NODE) (type_name_string (NODE)) */\n-#define FUNCTION_ARG_CHAIN(NODE) (function_arg_chain (NODE))\n-#define PROMOTES_TO_AGGR_TYPE(NODE,CODE) (promotes_to_aggr_type (NODE, CODE))\n-#endif\n /* Nonzero iff TYPE is uniquely derived from PARENT.  Under MI, PARENT can\n    be an ambiguous base class of TYPE, and this macro will be false.  */\n #define UNIQUELY_DERIVED_FROM_P(PARENT, TYPE) (get_base_distance (PARENT, TYPE, 0, (tree *)0) >= 0)\n@@ -1499,7 +1489,7 @@ extern tree vt_off_identifier;\n /* A node that is a list (length 1) of error_mark_nodes.  */\n extern tree error_mark_list;\n \n-extern tree ptr_type_node, const_ptr_type_node;\n+extern tree ptr_type_node;\n extern tree class_type_node, record_type_node, union_type_node, enum_type_node;\n extern tree unknown_type_node;\n extern tree opaque_type_node, signature_type_node;\n@@ -1927,7 +1917,6 @@ extern int get_arglist_len_in_bytes\t\tPROTO((tree));\n extern int rank_for_overload\t\t\tPROTO((struct candidate *, struct candidate *));\n extern void compute_conversion_costs\t\tPROTO((tree, tree, struct candidate *, int));\n extern tree build_vfield_ref\t\t\tPROTO((tree, tree));\n-extern tree find_scoped_type\t\t\tPROTO((tree, tree, tree));\n extern tree resolve_scope_to_name\t\tPROTO((tree, tree));\n extern tree build_scoped_method_call\t\tPROTO((tree, tree, tree, tree));\n extern tree build_addr_func\t\t\tPROTO((tree));\n@@ -1939,16 +1928,12 @@ extern int null_ptr_cst_p\t\t\tPROTO((tree));\n extern tree type_decays_to\t\t\tPROTO((tree));\n extern tree build_user_type_conversion\t\tPROTO((tree, tree, int));\n extern tree build_new_function_call\t\tPROTO((tree, tree, tree));\n-extern tree build_object_call\t\t\tPROTO((tree, tree));\n extern tree build_new_op\t\t\tPROTO((enum tree_code, int, tree, tree, tree));\n-extern tree build_new_method_call\t\tPROTO((tree, tree, tree, tree, int));\n extern int can_convert\t\t\t\tPROTO((tree, tree));\n extern int can_convert_arg\t\t\tPROTO((tree, tree, tree));\n \n /* in class.c */\n-extern tree build_vbase_pointer\t\t\tPROTO((tree, tree));\n extern tree build_vbase_path\t\t\tPROTO((enum tree_code, tree, tree, tree, int));\n-extern tree build_vtable_entry\t\t\tPROTO((tree, tree));\n extern tree build_vtbl_ref\t\t\tPROTO((tree, tree));\n extern tree build_vfn_ref\t\t\tPROTO((tree *, tree, tree));\n extern void add_method\t\t\t\tPROTO((tree, tree *, tree));\n@@ -1965,7 +1950,6 @@ extern void push_nested_class\t\t\tPROTO((tree, int));\n extern void pop_nested_class\t\t\tPROTO((int));\n extern void push_lang_context\t\t\tPROTO((tree));\n extern void pop_lang_context\t\t\tPROTO((void));\n-extern int root_lang_context_p\t\t\tPROTO((void));\n extern tree instantiate_type\t\t\tPROTO((tree, tree, int));\n extern void print_class_statistics\t\tPROTO((void));\n extern void maybe_push_cache_obstack\t\tPROTO((void));\n@@ -2023,12 +2007,12 @@ extern int decls_match\t\t\t\tPROTO((tree, tree));\n extern int duplicate_decls\t\t\tPROTO((tree, tree));\n extern tree pushdecl\t\t\t\tPROTO((tree));\n extern tree pushdecl_top_level\t\t\tPROTO((tree));\n-extern void push_overloaded_decl_top_level\tPROTO((tree, int));\n extern tree pushdecl_class_level\t\tPROTO((tree));\n+#if 0\n extern void pushdecl_nonclass_level\t\tPROTO((tree));\n+#endif\n extern void push_class_level_binding\t\tPROTO((tree, tree));\n extern int overloaded_globals_p\t\t\tPROTO((tree));\n-extern tree push_overloaded_decl\t\tPROTO((tree, int));\n extern tree implicitly_declare\t\t\tPROTO((tree));\n extern tree lookup_label\t\t\tPROTO((tree));\n extern tree shadow_label\t\t\tPROTO((tree));\n@@ -2038,7 +2022,9 @@ extern void pop_switch\t\t\t\tPROTO((void));\n extern void define_case_label\t\t\tPROTO((tree));\n extern tree getdecls\t\t\t\tPROTO((void));\n extern tree gettags\t\t\t\tPROTO((void));\n+#if 0\n extern void set_current_level_tags_transparency\tPROTO((int));\n+#endif\n extern tree lookup_namespace_name\t\tPROTO((tree, tree));\n extern tree make_typename_type\t\t\tPROTO((tree, tree));\n extern tree lookup_name_nonclass\t\tPROTO((tree));\n@@ -2082,7 +2068,6 @@ extern tree maybe_build_cleanup_and_delete\tPROTO((tree));\n extern tree maybe_build_cleanup\t\t\tPROTO((tree));\n extern void cplus_expand_expr_stmt\t\tPROTO((tree));\n extern void finish_stmt\t\t\t\tPROTO((void));\n-extern void revert_static_member_fn\t\tPROTO((tree *, tree *, tree *));\n extern int id_in_current_class\t\t\tPROTO((tree));\n extern void push_cp_function_context\t\tPROTO((tree));\n extern void pop_cp_function_context\t\tPROTO((tree));\n@@ -2184,6 +2169,11 @@ extern void fixup_result_decl\t\t\tPROTO((tree, struct rtx_def *));\n extern int extract_init\t\t\t\tPROTO((tree, tree));\n extern void do_case\t\t\t\tPROTO((tree, tree));\n \n+/* friend.c */\n+extern int is_friend\t\t\t\tPROTO((tree, tree));\n+extern void make_friend_class\t\t\tPROTO((tree, tree));\n+extern tree do_friend\t\t\t\tPROTO((tree, tree, tree, tree, enum overload_flags, tree, int));\n+\n /* in init.c */\n extern void init_init_processing\t\tPROTO((void));\n extern void expand_direct_vtbls_init\t\tPROTO((tree, tree, int, int, tree));\n@@ -2200,11 +2190,6 @@ extern tree build_member_call\t\t\tPROTO((tree, tree, tree));\n extern tree build_offset_ref\t\t\tPROTO((tree, tree));\n extern tree resolve_offset_ref\t\t\tPROTO((tree));\n extern tree decl_constant_value\t\t\tPROTO((tree));\n-extern int is_friend_type\t\t\tPROTO((tree, tree));\n-extern int is_friend\t\t\t\tPROTO((tree, tree));\n-extern void make_friend_class\t\t\tPROTO((tree, tree));\n-extern tree do_friend\t\t\t\tPROTO((tree, tree, tree, tree, enum overload_flags, tree, int));\n-extern tree build_builtin_call\t\t\tPROTO((tree, tree, tree));\n extern tree build_new\t\t\t\tPROTO((tree, tree, tree, int));\n extern tree expand_vec_init\t\t\tPROTO((tree, tree, tree, tree, int));\n extern tree build_x_delete\t\t\tPROTO((tree, tree, int, tree));\n@@ -2223,27 +2208,27 @@ extern char *operator_name_string\t\tPROTO((tree));\n extern void lang_init\t\t\t\tPROTO((void));\n extern void lang_finish\t\t\t\tPROTO((void));\n extern void init_filename_times\t\t\tPROTO((void));\n+#if 0\n extern void reinit_lang_specific\t\tPROTO((void));\n+#endif\n extern void init_lex\t\t\t\tPROTO((void));\n extern void reinit_parse_for_function\t\tPROTO((void));\n extern int *init_parse\t\t\t\tPROTO((void));\n extern void print_parse_statistics\t\tPROTO((void));\n extern void extract_interface_info\t\tPROTO((void));\n-extern int set_vardecl_interface_info\t\tPROTO((tree, tree));\n extern void do_pending_inlines\t\t\tPROTO((void));\n extern void process_next_inline\t\t\tPROTO((tree));\n /* skip save_pending_input */\n /* skip restore_pending_input */\n extern void yyungetc\t\t\t\tPROTO((int, int));\n extern void reinit_parse_for_method\t\tPROTO((int, tree));\n #if 0\n-extern void reinit_parse_for_block\t\tPROTO((int, struct obstack *, int));\n+extern void reinit_parse_for_block\t\tPROTO((int, struct obstack *));\n #endif\n extern tree cons_up_default_function\t\tPROTO((tree, tree, int));\n extern void check_for_missing_semicolon\t\tPROTO((tree));\n extern void note_got_semicolon\t\t\tPROTO((tree));\n extern void note_list_got_semicolon\t\tPROTO((tree));\n-extern int check_newline\t\t\tPROTO((void));\n extern void do_pending_lang_change\t\tPROTO((void));\n extern int identifier_type\t\t\tPROTO((tree));\n extern void see_typename\t\t\tPROTO((void));\n@@ -2256,7 +2241,6 @@ extern tree build_lang_decl\t\t\tPROTO((enum tree_code, tree, tree));\n extern tree build_lang_field_decl\t\tPROTO((enum tree_code, tree, tree));\n extern void copy_lang_decl\t\t\tPROTO((tree));\n extern tree make_lang_type\t\t\tPROTO((enum tree_code));\n-extern void copy_decl_lang_specific\t\tPROTO((tree));\n extern void dump_time_statistics\t\tPROTO((void));\n /* extern void compiler_error\t\t\tPROTO((char *, HOST_WIDE_INT, HOST_WIDE_INT)); */\n extern void yyerror\t\t\t\tPROTO((char *));\n@@ -2295,11 +2279,11 @@ extern void overload_template_name\t\tPROTO((tree));\n extern int type_unification\t\t\tPROTO((tree, tree *, tree, tree, int *, int, int));\n struct tinst_level *tinst_for_decl\t\tPROTO((void));\n extern void mark_decl_instantiated\t\tPROTO((tree, int));\n+extern int more_specialized\t\t\tPROTO((tree, tree));\n extern void mark_class_instantiated\t\tPROTO((tree, int));\n extern void do_function_instantiation\t\tPROTO((tree, tree, tree));\n extern void do_type_instantiation\t\tPROTO((tree, tree));\n extern tree instantiate_decl\t\t\tPROTO((tree));\n-extern tree classtype_mangled_name\t\tPROTO((tree));\n extern tree lookup_nested_type_by_name\t\tPROTO((tree, tree));\n extern tree do_poplevel\t\t\t\tPROTO((void));\n extern tree *get_bindings\t\t\tPROTO((tree, tree));\n@@ -2326,7 +2310,7 @@ extern void synthesize_tinfo_fn\t\t\tPROTO((tree));\n /* in search.c */\n extern void push_memoized_context\t\tPROTO((tree, int));\n extern void pop_memoized_context\t\tPROTO((int));\n-extern tree convert_pointer_to_vbase\t\tPROTO((tree, tree));\n+extern tree get_vbase\t\t\t\tPROTO((tree, tree));\n extern tree get_binfo\t\t\t\tPROTO((tree, tree, int));\n extern int get_base_distance\t\t\tPROTO((tree, tree, int, tree *));\n extern tree compute_access\t\t\tPROTO((tree, tree));\n@@ -2365,7 +2349,6 @@ extern tree build_signature_reference_type\tPROTO((tree, int, int));\n extern tree build_signature_pointer_constructor\tPROTO((tree, tree));\n extern tree build_signature_method_call\t\tPROTO((tree, tree));\n extern tree build_optr_ref\t\t\tPROTO((tree));\n-extern tree build_sptr_ref\t\t\tPROTO((tree));\n extern void append_signature_fields\t\tPROTO((tree));\n \n /* in spew.c */\n@@ -2401,7 +2384,6 @@ extern tree get_decl_list\t\t\tPROTO((tree));\n extern tree make_binfo\t\t\t\tPROTO((tree, tree, tree, tree, tree));\n extern tree binfo_value\t\t\t\tPROTO((tree, tree));\n extern tree reverse_path\t\t\tPROTO((tree));\n-extern void debug_binfo\t\t\t\tPROTO((tree));\n extern int decl_list_length\t\t\tPROTO((tree));\n extern int count_functions\t\t\tPROTO((tree));\n extern int is_overloaded_fn\t\t\tPROTO((tree));\n@@ -2438,7 +2420,6 @@ extern tree common_type\t\t\t\tPROTO((tree, tree));\n extern int compexcepttypes\t\t\tPROTO((tree, tree));\n extern int comptypes\t\t\t\tPROTO((tree, tree, int));\n extern int comp_target_types\t\t\tPROTO((tree, tree, int));\n-extern tree common_base_types\t\t\tPROTO((tree, tree));\n extern int compparms\t\t\t\tPROTO((tree, tree, int));\n extern int comp_target_types\t\t\tPROTO((tree, tree, int));\n extern int self_promoting_args_p\t\tPROTO((tree));\n@@ -2458,7 +2439,6 @@ extern tree build_component_ref\t\t\tPROTO((tree, tree, tree, int));\n extern tree build_x_component_ref\t\tPROTO((tree, tree, tree, int));\n extern tree build_x_indirect_ref\t\tPROTO((tree, char *));\n extern tree build_indirect_ref\t\t\tPROTO((tree, char *));\n-extern tree build_x_array_ref\t\t\tPROTO((tree, tree));\n extern tree build_array_ref\t\t\tPROTO((tree, tree));\n extern tree build_x_function_call\t\tPROTO((tree, tree, tree));\n extern tree get_member_function_from_ptrfunc\tPROTO((tree *, tree));\n@@ -2490,6 +2470,7 @@ extern tree convert_for_initialization\t\tPROTO((tree, tree, tree, int, char *, tr\n extern void c_expand_asm_operands\t\tPROTO((tree, tree, tree, tree, int, char *, int));\n extern void c_expand_return\t\t\tPROTO((tree));\n extern tree c_expand_start_case\t\t\tPROTO((tree));\n+extern int comp_ptr_ttypes\t\t\tPROTO((tree, tree));\n extern int ptr_reasonably_similar\t\tPROTO((tree, tree));\n extern tree build_ptrmemfunc\t\t\tPROTO((tree, tree, int));\n "}, {"sha": "cf961156411c8bf9c3c727c36cd5843fda1d0008", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=bd6dd8453c857d8ee420c960503d8eb72de1aa75", "patch": "@@ -1153,8 +1153,8 @@ cp_convert (type, expr, convtype, flags)\n   register tree e = expr;\n   register enum tree_code code = TREE_CODE (type);\n \n-  if (TREE_CODE (e) == ERROR_MARK\n-      || TREE_CODE (TREE_TYPE (e)) == ERROR_MARK)\n+  if (e == error_mark_node\n+      || TREE_TYPE (e) == error_mark_node)\n     return error_mark_node;\n \n   if (IS_AGGR_TYPE (type) && (convtype & CONV_FORCE_TEMP))"}, {"sha": "1fd2026f118edae6084de7ce2dc72beb1afea9ff", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 47, "deletions": 48, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=bd6dd8453c857d8ee420c960503d8eb72de1aa75", "patch": "@@ -126,6 +126,9 @@ static struct stack_level *decl_stack;\n static tree grokparms\t\t\t\tPROTO((tree, int));\n static tree lookup_nested_type\t\t\tPROTO((tree, tree));\n static char *redeclaration_error_message\tPROTO((tree, tree));\n+static void revert_static_member_fn\t\tPROTO((tree *, tree *, tree *));\n+static tree push_overloaded_decl\t\tPROTO((tree, int));\n+static void push_overloaded_decl_top_level\tPROTO((tree, int));\n \n tree define_function\t\t\n \tPROTO((char *, tree, enum built_in_function, void (*)(), char *));\n@@ -185,7 +188,8 @@ tree void_zero_node;\n \n /* Nodes for types `void *' and `const void *'.  */\n \n-tree ptr_type_node, const_ptr_type_node;\n+tree ptr_type_node;\n+static tree const_ptr_type_node;\n \n /* Nodes for types `char *' and `const char *'.  */\n \n@@ -215,10 +219,10 @@ tree default_function_type;\n \n /* function types `double (double)' and `double (double, double)', etc.  */\n \n-tree double_ftype_double, double_ftype_double_double;\n-tree int_ftype_int, long_ftype_long;\n-tree float_ftype_float;\n-tree ldouble_ftype_ldouble;\n+static tree double_ftype_double, double_ftype_double_double;\n+static tree int_ftype_int, long_ftype_long;\n+static tree float_ftype_float;\n+static tree ldouble_ftype_ldouble;\n \n /* Function type `int (const void *, const void *, size_t)' */\n static tree int_ftype_cptr_cptr_sizet;\n@@ -264,7 +268,7 @@ tree dtor_label;\n /* In a destructor, the last insn emitted after the start of the\n    function and the parms.  */\n \n-rtx last_dtor_insn;\n+static rtx last_dtor_insn;\n \n /* In a constructor, the point at which we are ready to return\n    the pointer to the initialized object.  */\n@@ -283,7 +287,7 @@ extern rtx cleanup_label, return_label;\n    but due to being an addressable named return value, would up\n    on the stack, this variable holds the named return value's\n    original location.  */\n-rtx original_result_rtx;\n+static rtx original_result_rtx;\n \n /* Sequence of insns which represents base initialization.  */\n tree base_init_expr;\n@@ -350,14 +354,6 @@ tree null_node;\n \n tree integer_one_node, integer_two_node, integer_three_node;\n \n-/* Nonzero if we have seen an invalid cross reference\n-   to a struct, union, or enum, but not yet printed the message.  */\n-\n-tree pending_invalid_xref;\n-/* File and line to appear in the eventual error message.  */\n-char *pending_invalid_xref_file;\n-int pending_invalid_xref_line;\n-\n /* While defining an enum type, this is 1 plus the last enumerator\n    constant value.  */\n \n@@ -1507,7 +1503,7 @@ print_binding_level (lvl)\n \t      i = len;\n \t    }\n \t  print_node_brief (stderr, \"\", t, 0);\n-\t  if (TREE_CODE (t) == ERROR_MARK)\n+\t  if (t == error_mark_node)\n \t    break;\n \t}\n       if (i)\n@@ -2375,10 +2371,8 @@ duplicate_decls (newdecl, olddecl)\n      error (earlier) for some bogus type specification, and in that case,\n      it is rather pointless to harass the user with yet more error message\n      about the same declaration, so well just pretent the types match here.  */\n-  if ((TREE_TYPE (newdecl)\n-       && TREE_CODE (TREE_TYPE (newdecl)) == ERROR_MARK)\n-      || (TREE_TYPE (olddecl)\n-\t  && TREE_CODE (TREE_TYPE (olddecl)) == ERROR_MARK))\n+  if (TREE_TYPE (newdecl) == error_mark_node\n+      || TREE_TYPE (olddecl) == error_mark_node)\n     types_match = 1;\n \n   if (TREE_CODE (olddecl) == FUNCTION_DECL\n@@ -2897,7 +2891,7 @@ duplicate_decls (newdecl, olddecl)\n \t    }\n \t  else\n \t    {\n-\t      /* Storage leak.  */\n+\t      /* Storage leak.  */;\n \t    }\n \t}\n     }\n@@ -3350,7 +3344,7 @@ pushdecl_top_level (x)\n /* Like push_overloaded_decl, only it places X in GLOBAL_BINDING_LEVEL,\n    if appropriate.  */\n \n-void\n+static void\n push_overloaded_decl_top_level (x, forget)\n      tree x;\n      int forget;\n@@ -3403,6 +3397,7 @@ pushdecl_class_level (x)\n   return x;\n }\n \n+#if 0\n /* This function is used to push the mangled decls for nested types into\n    the appropriate scope.  Previously pushdecl_top_level was used, but that\n    is incorrect for members of local classes.  */\n@@ -3423,6 +3418,7 @@ pushdecl_nonclass_level (x)\n \n   pushdecl_with_scope (x, b);\n }\n+#endif\n \n /* Make the declaration(s) of X appear in CLASS scope\n    under the name NAME.  */\n@@ -3477,7 +3473,7 @@ overloaded_globals_p (list)\n    about what language DECL should belong to (C or C++).  Otherwise,\n    it's always DECL (and never something that's not a _DECL).  */\n \n-tree\n+static tree\n push_overloaded_decl (decl, forgettable)\n      tree decl;\n      int forgettable;\n@@ -4118,12 +4114,14 @@ lookup_tag (form, name, binding_level, thislevel_only)\n   return NULL_TREE;\n }\n \n+#if 0\n void\n set_current_level_tags_transparency (tags_transparent)\n      int tags_transparent;\n {\n   current_binding_level->tag_transparent = tags_transparent;\n }\n+#endif\n \n /* Given a type, find the tag that was defined for it and return the tag name.\n    Otherwise return 0.  However, the value can never be 0\n@@ -5744,20 +5742,24 @@ start_decl (declarator, declspecs, initialized)\n       default:\n \tif (! processing_template_decl)\n \t  {\n-\t    if (TYPE_SIZE (type) != NULL_TREE\n-\t\t&& ! TREE_CONSTANT (TYPE_SIZE (type)))\n+\t    if (type != error_mark_node)\n \t      {\n-\t\tcp_error\n-\t\t  (\"variable-sized object `%D' may not be initialized\", decl);\n-\t\tinitialized = 0;\n-\t      }\n+\t\tif (TYPE_SIZE (type) != NULL_TREE\n+\t\t    && ! TREE_CONSTANT (TYPE_SIZE (type)))\n+\t\t  {\n+\t\t    cp_error\n+\t\t      (\"variable-sized object `%D' may not be initialized\",\n+\t\t       decl);\n+\t\t    initialized = 0;\n+\t\t  }\n \n-\t    if (TREE_CODE (type) == ARRAY_TYPE\n-\t\t&& TYPE_SIZE (complete_type (TREE_TYPE (type))) == NULL_TREE)\n-\t      {\n-\t\tcp_error\n-\t\t  (\"elements of array `%#D' have incomplete type\", decl);\n-\t\tinitialized = 0;\n+\t\tif (TREE_CODE (type) == ARRAY_TYPE\n+\t\t    && TYPE_SIZE (complete_type (TREE_TYPE (type))) == NULL_TREE)\n+\t\t  {\n+\t\t    cp_error\n+\t\t      (\"elements of array `%#D' have incomplete type\", decl);\n+\t\t    initialized = 0;\n+\t\t  }\n \t      }\n \t  }\n       }\n@@ -7799,7 +7801,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      typedef_decl = t;\n \t    }\n \t}\n-      else if (TREE_CODE (id) != ERROR_MARK)\n+      else if (id != error_mark_node)\n \t/* Can't change CLASS nodes into RECORD nodes here!  */\n \ttype = id;\n \n@@ -8207,7 +8209,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t array or function or pointer, and DECLARATOR has had its\n \t outermost layer removed.  */\n \n-      if (TREE_CODE (type) == ERROR_MARK)\n+      if (type == error_mark_node)\n \t{\n \t  if (TREE_CODE (declarator) == SCOPE_REF)\n \t    declarator = TREE_OPERAND (declarator, 1);\n@@ -11661,14 +11663,13 @@ finish_function (lineno, call_poplevel, nested)\n \t\t    {\n \t\t      if (TYPE_NEEDS_DESTRUCTOR (BINFO_TYPE (vbases)))\n \t\t\t{\n-\t\t\t  tree ptr = convert_pointer_to_vbase (BINFO_TYPE (vbases), current_class_ptr);\n+\t\t\t  tree vb = get_vbase\n+\t\t\t    (BINFO_TYPE (vbases),\n+\t\t\t     TYPE_BINFO (current_class_type));\n \t\t\t  expand_expr_stmt\n-\t\t\t    (build_delete\n-\t\t\t     (build_pointer_type (BINFO_TYPE (vbases)),\n-\t\t\t      ptr, integer_zero_node,\n-\t\t\t      (LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR\n-\t\t\t       |LOOKUP_HAS_IN_CHARGE|LOOKUP_NORMAL),\n-\t\t\t      0));\n+\t\t\t    (build_scoped_method_call\n+\t\t\t     (current_class_ref, vb, dtor_identifier,\n+\t\t\t      build_tree_list (NULL_TREE, integer_zero_node)));\n \t\t\t}\n \t\t      vbases = TREE_CHAIN (vbases);\n \t\t    }\n@@ -12460,7 +12461,7 @@ finish_stmt ()\n    (TREE_TYPE (decl)) to ARGTYPES, as doing so will corrupt the types of\n    other decls.  Either pass the addresses of local variables or NULL.  */\n \n-void\n+static void\n revert_static_member_fn (decl, fn, argtypes)\n      tree *decl, *fn, *argtypes;\n {\n@@ -12520,9 +12521,7 @@ struct cp_function\n   struct binding_level *binding_level;\n };\n \n-\n-\n-struct cp_function *cp_function_chain;\n+static struct cp_function *cp_function_chain;\n \n extern int temp_name_counter;\n "}, {"sha": "60a27a41f9a227a46e179cb175d3e243865060d6", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=bd6dd8453c857d8ee420c960503d8eb72de1aa75", "patch": "@@ -1245,8 +1245,7 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n \t}\n \n       return build_delete (type, t, integer_three_node,\n-\t\t\t   LOOKUP_NORMAL|LOOKUP_HAS_IN_CHARGE,\n-\t\t\t   use_global_delete);\n+\t\t\t   LOOKUP_NORMAL, use_global_delete);\n     }\n }\n "}, {"sha": "6d7d9d54003073b30ccf1ae6279c0a9c9f537365", "filename": "gcc/cp/friend.c", "status": "added", "additions": 414, "deletions": 0, "changes": 414, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=bd6dd8453c857d8ee420c960503d8eb72de1aa75", "patch": "@@ -0,0 +1,414 @@\n+/* Help friends in C++.\n+   Copyright (C) 1997 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"cp-tree.h\"\n+#include \"flags.h\"\n+#include \"output.h\"\n+\n+/* Friend data structures:\n+\n+   Lists of friend functions come from TYPE_DECL nodes.  Since all\n+   aggregate types are automatically typedef'd, these nodes are guaranteed\n+   to exist.\n+\n+   The TREE_PURPOSE of a friend list is the name of the friend,\n+   and its TREE_VALUE is another list.\n+\n+   For each element of that list, either the TREE_VALUE or the TREE_PURPOSE\n+   will be filled in, but not both.  The TREE_VALUE of that list is an\n+   individual function which is a friend.  The TREE_PURPOSE of that list\n+   indicates a type in which all functions by that name are friends.\n+\n+   Lists of friend classes come from _TYPE nodes.  Love that consistency\n+   thang.  */\n+\n+int\n+is_friend (type, supplicant)\n+     tree type, supplicant;\n+{\n+  int declp;\n+  register tree list;\n+\n+  if (supplicant == NULL_TREE || type == NULL_TREE)\n+    return 0;\n+\n+  declp = (TREE_CODE_CLASS (TREE_CODE (supplicant)) == 'd');\n+\n+  if (declp)\n+    /* It's a function decl.  */\n+    {\n+      tree list = DECL_FRIENDLIST (TYPE_MAIN_DECL (type));\n+      tree name = DECL_NAME (supplicant);\n+      tree ctype;\n+\n+      if (DECL_FUNCTION_MEMBER_P (supplicant))\n+\tctype = DECL_CLASS_CONTEXT (supplicant);\n+      else\n+\tctype = NULL_TREE;\n+\n+      for (; list ; list = TREE_CHAIN (list))\n+\t{\n+\t  if (name == TREE_PURPOSE (list))\n+\t    {\n+\t      tree friends = TREE_VALUE (list);\n+\t      for (; friends ; friends = TREE_CHAIN (friends))\n+\t\t{\n+\t\t  if (ctype == TREE_PURPOSE (friends))\n+\t\t    return 1;\n+\t\t  if (comptypes (TREE_TYPE (supplicant),\n+\t\t\t\t TREE_TYPE (TREE_VALUE (friends)), 1))\n+\t\t    return 1;\n+\t\t}\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  else\n+    /* It's a type.  */\n+    {\n+      if (type == supplicant)\n+\treturn 1;\n+      \n+      list = CLASSTYPE_FRIEND_CLASSES (TREE_TYPE (TYPE_MAIN_DECL (type)));\n+      for (; list ; list = TREE_CHAIN (list))\n+\tif (supplicant == TREE_VALUE (list))\n+\t  return 1;\n+    }      \n+\n+  {\n+    tree context;\n+\n+    if (! declp)\n+      {\n+\t/* Are we a nested or local class?  If so, we aren't friends\n+           with the CONTEXT.  */\n+\tif (IS_AGGR_TYPE (supplicant))\n+\t  context = NULL_TREE;\n+\telse\n+\t  context = DECL_CONTEXT (TYPE_MAIN_DECL (supplicant));\n+      }\n+    else if (DECL_FUNCTION_MEMBER_P (supplicant))\n+      context = DECL_CLASS_CONTEXT (supplicant);\n+    else\n+      context = NULL_TREE;\n+\n+    if (context)\n+      return is_friend (type, context);\n+  }\n+\n+  return 0;\n+}\n+\n+/* Add a new friend to the friends of the aggregate type TYPE.\n+   DECL is the FUNCTION_DECL of the friend being added.  */\n+\n+static void\n+add_friend (type, decl)\n+     tree type, decl;\n+{\n+  tree typedecl = TYPE_MAIN_DECL (type);\n+  tree list = DECL_FRIENDLIST (typedecl);\n+  tree name = DECL_NAME (decl);\n+\n+  while (list)\n+    {\n+      if (name == TREE_PURPOSE (list))\n+\t{\n+\t  tree friends = TREE_VALUE (list);\n+\t  for (; friends ; friends = TREE_CHAIN (friends))\n+\t    {\n+\t      if (decl == TREE_VALUE (friends))\n+\t\t{\n+\t\t  cp_warning (\"`%D' is already a friend of class `%T'\",\n+\t\t\t      decl, type);\n+\t\t  cp_warning_at (\"previous friend declaration of `%D'\",\n+\t\t\t\t TREE_VALUE (friends));\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t  TREE_VALUE (list) = tree_cons (error_mark_node, decl,\n+\t\t\t\t\t TREE_VALUE (list));\n+\t  return;\n+\t}\n+      list = TREE_CHAIN (list);\n+    }\n+  DECL_FRIENDLIST (typedecl)\n+    = tree_cons (DECL_NAME (decl), build_tree_list (error_mark_node, decl),\n+\t\t DECL_FRIENDLIST (typedecl));\n+  if (DECL_NAME (decl) == ansi_opname[(int) MODIFY_EXPR])\n+    {\n+      tree parmtypes = TYPE_ARG_TYPES (TREE_TYPE (decl));\n+      TYPE_HAS_ASSIGNMENT (TREE_TYPE (typedecl)) = 1;\n+      if (parmtypes && TREE_CHAIN (parmtypes))\n+\t{\n+\t  tree parmtype = TREE_VALUE (TREE_CHAIN (parmtypes));\n+\t  if (TREE_CODE (parmtype) == REFERENCE_TYPE\n+\t      && TREE_TYPE (parmtypes) == TREE_TYPE (typedecl))\n+\t    TYPE_HAS_ASSIGN_REF (TREE_TYPE (typedecl)) = 1;\n+\t}\n+    }\n+}\n+\n+/* Declare that every member function NAME in FRIEND_TYPE\n+   (which may be NULL_TREE) is a friend of type TYPE.  */\n+\n+static void\n+add_friends (type, name, friend_type)\n+     tree type, name, friend_type;\n+{\n+  tree typedecl = TYPE_MAIN_DECL (type);\n+  tree list = DECL_FRIENDLIST (typedecl);\n+\n+  while (list)\n+    {\n+      if (name == TREE_PURPOSE (list))\n+\t{\n+\t  tree friends = TREE_VALUE (list);\n+\t  while (friends && TREE_PURPOSE (friends) != friend_type)\n+\t    friends = TREE_CHAIN (friends);\n+\t  if (friends)\n+\t    if (friend_type)\n+\t      warning (\"method `%s::%s' is already a friend of class\",\n+\t\t       TYPE_NAME_STRING (friend_type),\n+\t\t       IDENTIFIER_POINTER (name));\n+\t    else\n+\t      warning (\"function `%s' is already a friend of class `%s'\",\n+\t\t       IDENTIFIER_POINTER (name),\n+\t\t       IDENTIFIER_POINTER (DECL_NAME (typedecl)));\n+\t  else\n+\t    TREE_VALUE (list) = tree_cons (friend_type, NULL_TREE,\n+\t\t\t\t\t   TREE_VALUE (list));\n+\t  return;\n+\t}\n+      list = TREE_CHAIN (list);\n+    }\n+  DECL_FRIENDLIST (typedecl) =\n+    tree_cons (name,\n+\t       build_tree_list (friend_type, NULL_TREE),\n+\t       DECL_FRIENDLIST (typedecl));\n+  if (! strncmp (IDENTIFIER_POINTER (name),\n+\t\t IDENTIFIER_POINTER (ansi_opname[(int) MODIFY_EXPR]),\n+\t\t strlen (IDENTIFIER_POINTER (ansi_opname[(int) MODIFY_EXPR]))))\n+    {\n+      TYPE_HAS_ASSIGNMENT (TREE_TYPE (typedecl)) = 1;\n+      sorry (\"declaring \\\"friend operator =\\\" will not find \\\"operator = (X&)\\\" if it exists\");\n+    }\n+}\n+\n+/* Make FRIEND_TYPE a friend class to TYPE.  If FRIEND_TYPE has already\n+   been defined, we make all of its member functions friends of\n+   TYPE.  If not, we make it a pending friend, which can later be added\n+   when its definition is seen.  If a type is defined, then its TYPE_DECL's\n+   DECL_UNDEFINED_FRIENDS contains a (possibly empty) list of friend\n+   classes that are not defined.  If a type has not yet been defined,\n+   then the DECL_WAITING_FRIENDS contains a list of types\n+   waiting to make it their friend.  Note that these two can both\n+   be in use at the same time!  */\n+\n+void\n+make_friend_class (type, friend_type)\n+     tree type, friend_type;\n+{\n+  tree classes;\n+\n+  if (IS_SIGNATURE (type))\n+    {\n+      error (\"`friend' declaration in signature definition\");\n+      return;\n+    }\n+  if (IS_SIGNATURE (friend_type))\n+    {\n+      error (\"signature type `%s' declared `friend'\",\n+\t     IDENTIFIER_POINTER (TYPE_IDENTIFIER (friend_type)));\n+      return;\n+    }\n+  if (type == friend_type)\n+    {\n+      pedwarn (\"class `%s' is implicitly friends with itself\",\n+\t       TYPE_NAME_STRING (type));\n+      return;\n+    }\n+\n+  GNU_xref_hier (TYPE_NAME_STRING (type),\n+\t\t TYPE_NAME_STRING (friend_type), 0, 0, 1);\n+\n+  classes = CLASSTYPE_FRIEND_CLASSES (type);\n+  while (classes && TREE_VALUE (classes) != friend_type)\n+    classes = TREE_CHAIN (classes);\n+  if (classes)\n+    warning (\"class `%s' is already friends with class `%s'\",\n+\t     TYPE_NAME_STRING (TREE_VALUE (classes)), TYPE_NAME_STRING (type));\n+  else\n+    {\n+      CLASSTYPE_FRIEND_CLASSES (type)\n+\t= tree_cons (NULL_TREE, friend_type, CLASSTYPE_FRIEND_CLASSES (type));\n+    }\n+}\n+\n+/* Main friend processor.  This is large, and for modularity purposes,\n+   has been removed from grokdeclarator.  It returns `void_type_node'\n+   to indicate that something happened, though a FIELD_DECL is\n+   not returned.\n+\n+   CTYPE is the class this friend belongs to.\n+\n+   DECLARATOR is the name of the friend.\n+\n+   DECL is the FUNCTION_DECL that the friend is.\n+\n+   In case we are parsing a friend which is part of an inline\n+   definition, we will need to store PARM_DECL chain that comes\n+   with it into the DECL_ARGUMENTS slot of the FUNCTION_DECL.\n+\n+   FLAGS is just used for `grokclassfn'.\n+\n+   QUALS say what special qualifies should apply to the object\n+   pointed to by `this'.  */\n+\n+tree\n+do_friend (ctype, declarator, decl, parmdecls, flags, quals, funcdef_flag)\n+     tree ctype, declarator, decl, parmdecls;\n+     enum overload_flags flags;\n+     tree quals;\n+     int funcdef_flag;\n+{\n+  /* Every decl that gets here is a friend of something.  */\n+  DECL_FRIEND_P (decl) = 1;\n+\n+  if (ctype)\n+    {\n+      tree cname = TYPE_NAME (ctype);\n+      if (TREE_CODE (cname) == TYPE_DECL)\n+\tcname = DECL_NAME (cname);\n+\n+      /* A method friend.  */\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t{\n+\t  if (flags == NO_SPECIAL && ctype && declarator == cname)\n+\t    DECL_CONSTRUCTOR_P (decl) = 1;\n+\n+\t  /* This will set up DECL_ARGUMENTS for us.  */\n+\t  grokclassfn (ctype, cname, decl, flags, quals);\n+\t  if (TYPE_SIZE (ctype) != 0)\n+\t    decl = check_classfn (ctype, decl);\n+\n+\t  if (TREE_TYPE (decl) != error_mark_node)\n+\t    {\n+\t      if (TYPE_SIZE (ctype))\n+\t\tadd_friend (current_class_type, decl);\n+\t      else\n+\t\t{\n+\t\t  cp_error (\"member `%D' declared as friend before type `%T' defined\",\n+\t\t\t    decl, ctype);\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Possibly a bunch of method friends.  */\n+\n+\t  /* Get the class they belong to.  */\n+\t  tree ctype = IDENTIFIER_TYPE_VALUE (cname);\n+\t  tree fields = lookup_fnfields (TYPE_BINFO (ctype), declarator, 0);\n+\n+\t  if (fields)\n+\t    add_friends (current_class_type, declarator, ctype);\n+\t  else\n+\t    error (\"method `%s' is not a member of class `%s'\",\n+\t\t   IDENTIFIER_POINTER (declarator),\n+\t\t   IDENTIFIER_POINTER (cname));\n+\t  decl = void_type_node;\n+\t}\n+    }\n+  else if (TREE_CODE (decl) == FUNCTION_DECL\n+\t   && ((IDENTIFIER_LENGTH (declarator) == 4\n+\t\t&& IDENTIFIER_POINTER (declarator)[0] == 'm'\n+\t\t&& ! strcmp (IDENTIFIER_POINTER (declarator), \"main\"))\n+\t       || (IDENTIFIER_LENGTH (declarator) > 10\n+\t\t   && IDENTIFIER_POINTER (declarator)[0] == '_'\n+\t\t   && IDENTIFIER_POINTER (declarator)[1] == '_'\n+\t\t   && strncmp (IDENTIFIER_POINTER (declarator)+2,\n+\t\t\t       \"builtin_\", 8) == 0)))\n+    {\n+      /* raw \"main\", and builtin functions never gets overloaded,\n+\t but they can become friends.  */\n+      add_friend (current_class_type, decl);\n+      DECL_FRIEND_P (decl) = 1;\n+      decl = void_type_node;\n+    }\n+  /* A global friend.\n+     @@ or possibly a friend from a base class ?!?  */\n+  else if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      /* Friends must all go through the overload machinery,\n+\t even though they may not technically be overloaded.\n+\n+\t Note that because classes all wind up being top-level\n+\t in their scope, their friend wind up in top-level scope as well.  */\n+      DECL_ASSEMBLER_NAME (decl)\n+\t= build_decl_overload (declarator, TYPE_ARG_TYPES (TREE_TYPE (decl)),\n+\t\t\t       TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE);\n+      DECL_ARGUMENTS (decl) = parmdecls;\n+      if (funcdef_flag)\n+\tDECL_CLASS_CONTEXT (decl) = current_class_type;\n+\n+      /* We can call pushdecl here, because the TREE_CHAIN of this\n+\t FUNCTION_DECL is not needed for other purposes.  */\n+      decl = pushdecl (decl);\n+\n+      make_decl_rtl (decl, NULL_PTR, 1);\n+      add_friend (current_class_type, decl);\n+\n+      DECL_FRIEND_P (decl) = 1;\n+    }\n+  else\n+    {\n+      /* @@ Should be able to ingest later definitions of this function\n+\t before use.  */\n+      tree decl = lookup_name_nonclass (declarator);\n+      if (decl == NULL_TREE)\n+\t{\n+\t  warning (\"implicitly declaring `%s' as struct\",\n+\t\t   IDENTIFIER_POINTER (declarator));\n+\t  decl = xref_tag (record_type_node, declarator, NULL_TREE, 1);\n+\t  decl = TYPE_MAIN_DECL (decl);\n+\t}\n+\n+      /* Allow abbreviated declarations of overloaded functions,\n+\t but not if those functions are really class names.  */\n+      if (TREE_CODE (decl) == TREE_LIST && TREE_TYPE (TREE_PURPOSE (decl)))\n+\t{\n+\t  warning (\"`friend %s' archaic, use `friend class %s' instead\",\n+\t\t   IDENTIFIER_POINTER (declarator),\n+\t\t   IDENTIFIER_POINTER (declarator));\n+\t  decl = TREE_TYPE (TREE_PURPOSE (decl));\n+\t}\n+\n+      if (TREE_CODE (decl) == TREE_LIST)\n+\tadd_friends (current_class_type, TREE_PURPOSE (decl), NULL_TREE);\n+      else\n+\tmake_friend_class (current_class_type, TREE_TYPE (decl));\n+      decl = void_type_node;\n+    }\n+  return decl;\n+}"}, {"sha": "4e1785d8ec93561cd2c3abf33db6cec1875bead9", "filename": "gcc/cp/init.c", "status": "modified", "additions": 34, "deletions": 548, "changes": 582, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=bd6dd8453c857d8ee420c960503d8eb72de1aa75", "patch": "@@ -19,7 +19,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-\n /* High-level class interface.  */\n \n #include \"config.h\"\n@@ -52,8 +51,6 @@ static void expand_aggr_init_1 PROTO((tree, tree, tree, tree, int, int));\n static void expand_virtual_init PROTO((tree, tree));\n tree expand_vec_init ();\n \n-static void add_friend (), add_friends ();\n-\n /* Cache _builtin_new and _builtin_delete exprs.  */\n static tree BIN, BID, BIVN, BIVD;\n \n@@ -491,13 +488,9 @@ static tree\n build_partial_cleanup_for (binfo)\n      tree binfo;\n {\n-  tree expr = convert_pointer_to_real (binfo,\n-\t\t\t\t       build_unary_op (ADDR_EXPR, current_class_ref, 0));\n-\n-  return build_delete (TREE_TYPE (expr),\n-\t\t       expr,\n-\t\t       integer_zero_node,\n-\t\t       LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n+  return build_scoped_method_call\n+    (current_class_ref, binfo, dtor_identifier,\n+     build_tree_list (NULL_TREE, integer_zero_node));\n }\n \n /* Perform whatever initializations have yet to be done on the base\n@@ -1452,7 +1445,7 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \n       if (TREE_CODE (init) != TREE_LIST)\n \t{\n-\t  if (TREE_CODE (init_type) == ERROR_MARK)\n+\t  if (init_type == error_mark_node)\n \t    return;\n \n \t  /* This happens when we use C++'s functional cast notation.\n@@ -2186,7 +2179,7 @@ decl_constant_value (decl)\n       && ! pedantic\n #endif /* 0 */\n       && DECL_INITIAL (decl) != 0\n-      && TREE_CODE (DECL_INITIAL (decl)) != ERROR_MARK\n+      && DECL_INITIAL (decl) != error_mark_node\n       /* This is invalid if initial value is not constant.\n \t If it has either a function call, a memory reference,\n \t or a variable, then re-evaluating it could give different results.  */\n@@ -2204,408 +2197,12 @@ decl_constant_value (decl)\n   return decl;\n }\n \f\n-/* Friend handling routines.  */\n-/* Friend data structures:\n-\n-   Lists of friend functions come from TYPE_DECL nodes.  Since all\n-   aggregate types are automatically typedef'd, these nodes are guaranteed\n-   to exist.\n-\n-   The TREE_PURPOSE of a friend list is the name of the friend,\n-   and its TREE_VALUE is another list.\n-\n-   For each element of that list, either the TREE_VALUE or the TREE_PURPOSE\n-   will be filled in, but not both.  The TREE_VALUE of that list is an\n-   individual function which is a friend.  The TREE_PURPOSE of that list\n-   indicates a type in which all functions by that name are friends.\n-\n-   Lists of friend classes come from _TYPE nodes.  Love that consistency\n-   thang.  */\n-\n-int\n-is_friend_type (type1, type2)\n-     tree type1, type2;\n-{\n-  return is_friend (type1, type2);\n-}\n-\n-int\n-is_friend (type, supplicant)\n-     tree type, supplicant;\n-{\n-  int declp;\n-  register tree list;\n-\n-  if (supplicant == NULL_TREE || type == NULL_TREE)\n-    return 0;\n-\n-  declp = (TREE_CODE_CLASS (TREE_CODE (supplicant)) == 'd');\n-\n-  if (declp)\n-    /* It's a function decl.  */\n-    {\n-      tree list = DECL_FRIENDLIST (TYPE_MAIN_DECL (type));\n-      tree name = DECL_NAME (supplicant);\n-      tree ctype;\n-\n-      if (DECL_FUNCTION_MEMBER_P (supplicant))\n-\tctype = DECL_CLASS_CONTEXT (supplicant);\n-      else\n-\tctype = NULL_TREE;\n-\n-      for (; list ; list = TREE_CHAIN (list))\n-\t{\n-\t  if (name == TREE_PURPOSE (list))\n-\t    {\n-\t      tree friends = TREE_VALUE (list);\n-\t      for (; friends ; friends = TREE_CHAIN (friends))\n-\t\t{\n-\t\t  if (ctype == TREE_PURPOSE (friends))\n-\t\t    return 1;\n-\t\t  if (comptypes (TREE_TYPE (supplicant),\n-\t\t\t\t TREE_TYPE (TREE_VALUE (friends)), 1))\n-\t\t    return 1;\n-\t\t}\n-\t      break;\n-\t    }\n-\t}\n-    }\n-  else\n-    /* It's a type.  */\n-    {\n-      if (type == supplicant)\n-\treturn 1;\n-      \n-      list = CLASSTYPE_FRIEND_CLASSES (TREE_TYPE (TYPE_MAIN_DECL (type)));\n-      for (; list ; list = TREE_CHAIN (list))\n-\tif (supplicant == TREE_VALUE (list))\n-\t  return 1;\n-    }      \n-\n-  {\n-    tree context;\n-\n-    if (! declp)\n-      {\n-\t/* Are we a nested or local class?  If so, we aren't friends\n-           with the CONTEXT.  */\n-\tif (IS_AGGR_TYPE (supplicant))\n-\t  context = NULL_TREE;\n-\telse\n-\t  context = DECL_CONTEXT (TYPE_MAIN_DECL (supplicant));\n-      }\n-    else if (DECL_FUNCTION_MEMBER_P (supplicant))\n-      context = DECL_CLASS_CONTEXT (supplicant);\n-    else\n-      context = NULL_TREE;\n-\n-    if (context)\n-      return is_friend (type, context);\n-  }\n-\n-  return 0;\n-}\n-\n-/* Add a new friend to the friends of the aggregate type TYPE.\n-   DECL is the FUNCTION_DECL of the friend being added.  */\n-\n-static void\n-add_friend (type, decl)\n-     tree type, decl;\n-{\n-  tree typedecl = TYPE_MAIN_DECL (type);\n-  tree list = DECL_FRIENDLIST (typedecl);\n-  tree name = DECL_NAME (decl);\n-\n-  while (list)\n-    {\n-      if (name == TREE_PURPOSE (list))\n-\t{\n-\t  tree friends = TREE_VALUE (list);\n-\t  for (; friends ; friends = TREE_CHAIN (friends))\n-\t    {\n-\t      if (decl == TREE_VALUE (friends))\n-\t\t{\n-\t\t  cp_warning (\"`%D' is already a friend of class `%T'\",\n-\t\t\t      decl, type);\n-\t\t  cp_warning_at (\"previous friend declaration of `%D'\",\n-\t\t\t\t TREE_VALUE (friends));\n-\t\t  return;\n-\t\t}\n-\t    }\n-\t  TREE_VALUE (list) = tree_cons (error_mark_node, decl,\n-\t\t\t\t\t TREE_VALUE (list));\n-\t  return;\n-\t}\n-      list = TREE_CHAIN (list);\n-    }\n-  DECL_FRIENDLIST (typedecl)\n-    = tree_cons (DECL_NAME (decl), build_tree_list (error_mark_node, decl),\n-\t\t DECL_FRIENDLIST (typedecl));\n-  if (DECL_NAME (decl) == ansi_opname[(int) MODIFY_EXPR])\n-    {\n-      tree parmtypes = TYPE_ARG_TYPES (TREE_TYPE (decl));\n-      TYPE_HAS_ASSIGNMENT (TREE_TYPE (typedecl)) = 1;\n-      if (parmtypes && TREE_CHAIN (parmtypes))\n-\t{\n-\t  tree parmtype = TREE_VALUE (TREE_CHAIN (parmtypes));\n-\t  if (TREE_CODE (parmtype) == REFERENCE_TYPE\n-\t      && TREE_TYPE (parmtypes) == TREE_TYPE (typedecl))\n-\t    TYPE_HAS_ASSIGN_REF (TREE_TYPE (typedecl)) = 1;\n-\t}\n-    }\n-}\n-\n-/* Declare that every member function NAME in FRIEND_TYPE\n-   (which may be NULL_TREE) is a friend of type TYPE.  */\n-\n-static void\n-add_friends (type, name, friend_type)\n-     tree type, name, friend_type;\n-{\n-  tree typedecl = TYPE_MAIN_DECL (type);\n-  tree list = DECL_FRIENDLIST (typedecl);\n-\n-  while (list)\n-    {\n-      if (name == TREE_PURPOSE (list))\n-\t{\n-\t  tree friends = TREE_VALUE (list);\n-\t  while (friends && TREE_PURPOSE (friends) != friend_type)\n-\t    friends = TREE_CHAIN (friends);\n-\t  if (friends)\n-\t    if (friend_type)\n-\t      warning (\"method `%s::%s' is already a friend of class\",\n-\t\t       TYPE_NAME_STRING (friend_type),\n-\t\t       IDENTIFIER_POINTER (name));\n-\t    else\n-\t      warning (\"function `%s' is already a friend of class `%s'\",\n-\t\t       IDENTIFIER_POINTER (name),\n-\t\t       IDENTIFIER_POINTER (DECL_NAME (typedecl)));\n-\t  else\n-\t    TREE_VALUE (list) = tree_cons (friend_type, NULL_TREE,\n-\t\t\t\t\t   TREE_VALUE (list));\n-\t  return;\n-\t}\n-      list = TREE_CHAIN (list);\n-    }\n-  DECL_FRIENDLIST (typedecl) =\n-    tree_cons (name,\n-\t       build_tree_list (friend_type, NULL_TREE),\n-\t       DECL_FRIENDLIST (typedecl));\n-  if (! strncmp (IDENTIFIER_POINTER (name),\n-\t\t IDENTIFIER_POINTER (ansi_opname[(int) MODIFY_EXPR]),\n-\t\t strlen (IDENTIFIER_POINTER (ansi_opname[(int) MODIFY_EXPR]))))\n-    {\n-      TYPE_HAS_ASSIGNMENT (TREE_TYPE (typedecl)) = 1;\n-      sorry (\"declaring \\\"friend operator =\\\" will not find \\\"operator = (X&)\\\" if it exists\");\n-    }\n-}\n-\n-/* Make FRIEND_TYPE a friend class to TYPE.  If FRIEND_TYPE has already\n-   been defined, we make all of its member functions friends of\n-   TYPE.  If not, we make it a pending friend, which can later be added\n-   when its definition is seen.  If a type is defined, then its TYPE_DECL's\n-   DECL_UNDEFINED_FRIENDS contains a (possibly empty) list of friend\n-   classes that are not defined.  If a type has not yet been defined,\n-   then the DECL_WAITING_FRIENDS contains a list of types\n-   waiting to make it their friend.  Note that these two can both\n-   be in use at the same time!  */\n-\n-void\n-make_friend_class (type, friend_type)\n-     tree type, friend_type;\n-{\n-  tree classes;\n-\n-  if (IS_SIGNATURE (type))\n-    {\n-      error (\"`friend' declaration in signature definition\");\n-      return;\n-    }\n-  if (IS_SIGNATURE (friend_type))\n-    {\n-      error (\"signature type `%s' declared `friend'\",\n-\t     IDENTIFIER_POINTER (TYPE_IDENTIFIER (friend_type)));\n-      return;\n-    }\n-  if (type == friend_type)\n-    {\n-      pedwarn (\"class `%s' is implicitly friends with itself\",\n-\t       TYPE_NAME_STRING (type));\n-      return;\n-    }\n-\n-  GNU_xref_hier (TYPE_NAME_STRING (type),\n-\t\t TYPE_NAME_STRING (friend_type), 0, 0, 1);\n-\n-  classes = CLASSTYPE_FRIEND_CLASSES (type);\n-  while (classes && TREE_VALUE (classes) != friend_type)\n-    classes = TREE_CHAIN (classes);\n-  if (classes)\n-    warning (\"class `%s' is already friends with class `%s'\",\n-\t     TYPE_NAME_STRING (TREE_VALUE (classes)), TYPE_NAME_STRING (type));\n-  else\n-    {\n-      CLASSTYPE_FRIEND_CLASSES (type)\n-\t= tree_cons (NULL_TREE, friend_type, CLASSTYPE_FRIEND_CLASSES (type));\n-    }\n-}\n-\n-/* Main friend processor.  This is large, and for modularity purposes,\n-   has been removed from grokdeclarator.  It returns `void_type_node'\n-   to indicate that something happened, though a FIELD_DECL is\n-   not returned.\n-\n-   CTYPE is the class this friend belongs to.\n-\n-   DECLARATOR is the name of the friend.\n-\n-   DECL is the FUNCTION_DECL that the friend is.\n-\n-   In case we are parsing a friend which is part of an inline\n-   definition, we will need to store PARM_DECL chain that comes\n-   with it into the DECL_ARGUMENTS slot of the FUNCTION_DECL.\n-\n-   FLAGS is just used for `grokclassfn'.\n-\n-   QUALS say what special qualifies should apply to the object\n-   pointed to by `this'.  */\n-\n-tree\n-do_friend (ctype, declarator, decl, parmdecls, flags, quals, funcdef_flag)\n-     tree ctype, declarator, decl, parmdecls;\n-     enum overload_flags flags;\n-     tree quals;\n-     int funcdef_flag;\n-{\n-  /* Every decl that gets here is a friend of something.  */\n-  DECL_FRIEND_P (decl) = 1;\n-\n-  if (ctype)\n-    {\n-      tree cname = TYPE_NAME (ctype);\n-      if (TREE_CODE (cname) == TYPE_DECL)\n-\tcname = DECL_NAME (cname);\n-\n-      /* A method friend.  */\n-      if (TREE_CODE (decl) == FUNCTION_DECL)\n-\t{\n-\t  if (flags == NO_SPECIAL && ctype && declarator == cname)\n-\t    DECL_CONSTRUCTOR_P (decl) = 1;\n-\n-\t  /* This will set up DECL_ARGUMENTS for us.  */\n-\t  grokclassfn (ctype, cname, decl, flags, quals);\n-\t  if (TYPE_SIZE (ctype) != 0)\n-\t    decl = check_classfn (ctype, decl);\n-\n-\t  if (TREE_TYPE (decl) != error_mark_node)\n-\t    {\n-\t      if (TYPE_SIZE (ctype))\n-\t\tadd_friend (current_class_type, decl);\n-\t      else\n-\t\t{\n-\t\t  cp_error (\"member `%D' declared as friend before type `%T' defined\",\n-\t\t\t    decl, ctype);\n-\t\t}\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Possibly a bunch of method friends.  */\n-\n-\t  /* Get the class they belong to.  */\n-\t  tree ctype = IDENTIFIER_TYPE_VALUE (cname);\n-\t  tree fields = lookup_fnfields (TYPE_BINFO (ctype), declarator, 0);\n-\n-\t  if (fields)\n-\t    add_friends (current_class_type, declarator, ctype);\n-\t  else\n-\t    error (\"method `%s' is not a member of class `%s'\",\n-\t\t   IDENTIFIER_POINTER (declarator),\n-\t\t   IDENTIFIER_POINTER (cname));\n-\t  decl = void_type_node;\n-\t}\n-    }\n-  else if (TREE_CODE (decl) == FUNCTION_DECL\n-\t   && ((IDENTIFIER_LENGTH (declarator) == 4\n-\t\t&& IDENTIFIER_POINTER (declarator)[0] == 'm'\n-\t\t&& ! strcmp (IDENTIFIER_POINTER (declarator), \"main\"))\n-\t       || (IDENTIFIER_LENGTH (declarator) > 10\n-\t\t   && IDENTIFIER_POINTER (declarator)[0] == '_'\n-\t\t   && IDENTIFIER_POINTER (declarator)[1] == '_'\n-\t\t   && strncmp (IDENTIFIER_POINTER (declarator)+2,\n-\t\t\t       \"builtin_\", 8) == 0)))\n-    {\n-      /* raw \"main\", and builtin functions never gets overloaded,\n-\t but they can become friends.  */\n-      add_friend (current_class_type, decl);\n-      DECL_FRIEND_P (decl) = 1;\n-      decl = void_type_node;\n-    }\n-  /* A global friend.\n-     @@ or possibly a friend from a base class ?!?  */\n-  else if (TREE_CODE (decl) == FUNCTION_DECL)\n-    {\n-      /* Friends must all go through the overload machinery,\n-\t even though they may not technically be overloaded.\n-\n-\t Note that because classes all wind up being top-level\n-\t in their scope, their friend wind up in top-level scope as well.  */\n-      DECL_ASSEMBLER_NAME (decl)\n-\t= build_decl_overload (declarator, TYPE_ARG_TYPES (TREE_TYPE (decl)),\n-\t\t\t       TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE);\n-      DECL_ARGUMENTS (decl) = parmdecls;\n-      if (funcdef_flag)\n-\tDECL_CLASS_CONTEXT (decl) = current_class_type;\n-\n-      /* We can call pushdecl here, because the TREE_CHAIN of this\n-\t FUNCTION_DECL is not needed for other purposes.  */\n-      decl = pushdecl (decl);\n-\n-      make_decl_rtl (decl, NULL_PTR, 1);\n-      add_friend (current_class_type, decl);\n-\n-      DECL_FRIEND_P (decl) = 1;\n-    }\n-  else\n-    {\n-      /* @@ Should be able to ingest later definitions of this function\n-\t before use.  */\n-      tree decl = lookup_name_nonclass (declarator);\n-      if (decl == NULL_TREE)\n-\t{\n-\t  warning (\"implicitly declaring `%s' as struct\",\n-\t\t   IDENTIFIER_POINTER (declarator));\n-\t  decl = xref_tag (record_type_node, declarator, NULL_TREE, 1);\n-\t  decl = TYPE_MAIN_DECL (decl);\n-\t}\n-\n-      /* Allow abbreviated declarations of overloaded functions,\n-\t but not if those functions are really class names.  */\n-      if (TREE_CODE (decl) == TREE_LIST && TREE_TYPE (TREE_PURPOSE (decl)))\n-\t{\n-\t  warning (\"`friend %s' archaic, use `friend class %s' instead\",\n-\t\t   IDENTIFIER_POINTER (declarator),\n-\t\t   IDENTIFIER_POINTER (declarator));\n-\t  decl = TREE_TYPE (TREE_PURPOSE (decl));\n-\t}\n-\n-      if (TREE_CODE (decl) == TREE_LIST)\n-\tadd_friends (current_class_type, TREE_PURPOSE (decl), NULL_TREE);\n-      else\n-\tmake_friend_class (current_class_type, TREE_TYPE (decl));\n-      decl = void_type_node;\n-    }\n-  return decl;\n-}\n-\f\n /* Common subroutines of build_new and build_vec_delete.  */\n \n /* Common interface for calling \"builtin\" functions that are not\n    really builtin.  */\n \n-tree\n+static tree\n build_builtin_call (type, node, arglist)\n      tree type;\n      tree node;\n@@ -3661,11 +3258,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n       else\n \taddr = convert_force (build_pointer_type (type), addr, 0);\n \n-      if (TREE_CODE (addr) == NOP_EXPR\n-\t  && TREE_OPERAND (addr, 0) == current_class_ptr)\n-\tref = current_class_ref;\n-      else\n-\tref = build_indirect_ref (addr, NULL_PTR);\n+      ref = build_indirect_ref (addr, NULL_PTR);\n       ptr = 0;\n     }\n \n@@ -3699,6 +3292,8 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n       tree dtor = DECL_MAIN_VARIANT (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), 1));\n       tree passed_auto_delete;\n       tree do_delete = NULL_TREE;\n+      tree ifexp;\n+      int nonnull;\n \n       if (use_global_delete)\n \t{\n@@ -3718,148 +3313,42 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n       else\n \tpassed_auto_delete = auto_delete;\n \n-      if (flags & LOOKUP_PROTECT)\n-\t{\n-\t  tree access;\n-\t  tree basetypes = NULL_TREE;\n-\t  if (current_class_type != NULL_TREE)\n-\t    basetypes = get_binfo (type, current_class_type, 0);\n-\t  if (basetypes == NULL_TREE)\n-\t    basetypes = TYPE_BINFO (type);\n-\t  access = compute_access (basetypes, dtor);\n-\n-\t  if (access == access_private_node)\n-\t    {\n-\t      if (flags & LOOKUP_COMPLAIN)\n-\t\tcp_error (\"destructor for type `%T' is private in this scope\", type);\n-\t      return error_mark_node;\n-\t    }\n-\t  else if (access == access_protected_node)\n-\t    {\n-\t      if (flags & LOOKUP_COMPLAIN)\n-\t\tcp_error (\"destructor for type `%T' is protected in this scope\", type);\n-\t      return error_mark_node;\n-\t    }\n-\t}\n-\n-      /* Once we are in a destructor, try not going through\n-\t the virtual function table to find the next destructor.  */\n-      if (DECL_VINDEX (dtor)\n-\t  && ! (flags & LOOKUP_NONVIRTUAL)\n-\t  && TREE_CODE (auto_delete) != PARM_DECL\n-\t  && (ptr == 1 || ! resolves_to_fixed_type_p (ref, 0)))\n-\t{\n-\t  tree binfo, basetype;\n-\t  /* The code below is probably all broken.  See call.c for the\n-\t     complete right way to do this. this offsets may not be right\n-\t     in the below.  (mrs) */\n-\t  /* This destructor must be called via virtual function table.  */\n-\t  dtor = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (DECL_CONTEXT (dtor)), 1);\n-\t  basetype = DECL_CLASS_CONTEXT (dtor);\n-\t  binfo = get_binfo (basetype,\n-\t\t\t     TREE_TYPE (TREE_TYPE (TREE_VALUE (parms))),\n-\t\t\t     0);\n-\t  expr = convert_pointer_to_real (binfo, TREE_VALUE (parms));\n-\t  if (expr != TREE_VALUE (parms))\n-\t    {\n-\t      expr = fold (expr);\n-\t      ref = build_indirect_ref (expr, NULL_PTR);\n-\t      TREE_VALUE (parms) = expr;\n-\t    }\n-\t  function = build_vfn_ref (&TREE_VALUE (parms), ref, DECL_VINDEX (dtor));\n-\t  if (function == error_mark_node)\n-\t    return error_mark_node;\n-\t  TREE_TYPE (function) = build_pointer_type (TREE_TYPE (dtor));\n-\t  TREE_CHAIN (parms) = build_tree_list (NULL_TREE, passed_auto_delete);\n-\t  expr = build_function_call (function, parms);\n-\t  if (do_delete)\n-\t    expr = build (COMPOUND_EXPR, void_type_node, expr, do_delete);\n-\t  if (ptr && (flags & LOOKUP_DESTRUCTOR) == 0)\n-\t    {\n-\t      /* Handle the case where a virtual destructor is\n-\t\t being called on an item that is 0.\n+      expr = build_method_call\n+\t(ref, dtor_identifier, build_tree_list (NULL_TREE, passed_auto_delete),\n+\t NULL_TREE, flags);\n \n-\t\t @@ Does this really need to be done?  */\n-\t      tree ifexp = build_binary_op(NE_EXPR, addr, integer_zero_node,1);\n+      if (do_delete)\n+\texpr = build (COMPOUND_EXPR, void_type_node, expr, do_delete);\n \n-\t      expr = build (COND_EXPR, void_type_node,\n-\t\t\t    ifexp, expr, void_zero_node);\n-\t    }\n-\t}\n+      if (flags & LOOKUP_DESTRUCTOR)\n+\t/* Explicit destructor call; don't check for null pointer.  */\n+\tifexp = integer_one_node;\n       else\n-\t{\n-\t  tree ifexp;\n-\n-\t  if ((flags & LOOKUP_DESTRUCTOR)\n-\t      || TREE_CODE (ref) == VAR_DECL\n-\t      || TREE_CODE (ref) == PARM_DECL\n-\t      || TREE_CODE (ref) == COMPONENT_REF\n-\t      || TREE_CODE (ref) == ARRAY_REF)\n-\t    /* These can't be 0.  */\n-\t    ifexp = integer_one_node;\n-\t  else\n-\t    /* Handle the case where a non-virtual destructor is\n-\t       being called on an item that is 0.  */\n-\t    ifexp = build_binary_op (NE_EXPR, addr, integer_zero_node, 1);\n+\t/* Handle deleting a null pointer.  */\n+\tifexp = fold (build_binary_op (NE_EXPR, addr, integer_zero_node, 1));\n \n-\t  /* Used to mean that this destructor was known to be empty,\n-\t     but that's now obsolete.  */\n-\t  my_friendly_assert (DECL_INITIAL (dtor) != void_type_node, 221);\n+      if (ifexp != integer_one_node)\n+\texpr = build (COND_EXPR, void_type_node,\n+\t\t      ifexp, expr, void_zero_node);\n \n-\t  TREE_CHAIN (parms) = build_tree_list (NULL_TREE, passed_auto_delete);\n-\t  expr = build_function_call (dtor, parms);\n-\t  if (do_delete)\n-\t    expr = build (COMPOUND_EXPR, void_type_node, expr, do_delete);\n-\n-\t  if (ifexp != integer_one_node)\n-\t    expr = build (COND_EXPR, void_type_node,\n-\t\t\t  ifexp, expr, void_zero_node);\n-\t}\n       return expr;\n     }\n   else\n     {\n-      /* This can get visibilities wrong.  */\n+      /* We only get here from finish_function for a destructor.  */\n       tree binfos = BINFO_BASETYPES (TYPE_BINFO (type));\n       int i, n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n       tree base_binfo = n_baseclasses > 0 ? TREE_VEC_ELT (binfos, 0) : NULL_TREE;\n       tree exprstmt = NULL_TREE;\n       tree parent_auto_delete = auto_delete;\n       tree cond;\n \n-      /* If this type does not have a destructor, but does have\n-\t operator delete, call the parent parent destructor (if any),\n-\t but let this node do the deleting.  Otherwise, it is ok\n-\t to let the parent destructor do the deleting.  */\n-      if (TYPE_GETS_REG_DELETE (type) && !use_global_delete)\n-\t{\n-\t  parent_auto_delete = integer_zero_node;\n-\t  if (auto_delete == integer_zero_node)\n-\t    cond = NULL_TREE;\n-\t  else\n-\t    {\n-\t      tree virtual_size;\n-\n-\t        /* This is probably wrong. It should be the size of the\n-\t\t   virtual object being deleted.  */\n-\t      virtual_size = c_sizeof_nowarn (type);\n-\n-\t      expr = build_opfncall (DELETE_EXPR, LOOKUP_NORMAL, addr,\n-\t\t\t\t     virtual_size, NULL_TREE);\n-\t      if (expr == error_mark_node)\n-\t\treturn error_mark_node;\n-\t      if (auto_delete != integer_one_node)\n-\t\tcond = build (COND_EXPR, void_type_node,\n-\t\t\t      build (BIT_AND_EXPR, integer_type_node,\n-\t\t\t\t     auto_delete, integer_one_node),\n-\t\t\t      expr, void_zero_node);\n-\t      else\n-\t\tcond = expr;\n-\t    }\n-\t}\n+      /* If we have member delete or vbases, we call delete in\n+\t finish_function.  */\n+      if (auto_delete == integer_zero_node)\n+\tcond = NULL_TREE;\n       else if (base_binfo == NULL_TREE\n-\t       || (TREE_VIA_VIRTUAL (base_binfo) == 0\n-\t\t   && ! TYPE_NEEDS_DESTRUCTOR (BINFO_TYPE (base_binfo))))\n+\t       || ! TYPE_NEEDS_DESTRUCTOR (BINFO_TYPE (base_binfo)))\n \t{\n \t  cond = build (COND_EXPR, void_type_node,\n \t\t\tbuild (BIT_AND_EXPR, integer_type_node, auto_delete, integer_one_node),\n@@ -3884,8 +3373,9 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t  else\n \t    this_auto_delete = integer_zero_node;\n \n-\t  expr = build_delete (build_pointer_type (BINFO_TYPE (base_binfo)), addr,\n-\t\t\t       this_auto_delete, flags, 0);\n+\t  expr = build_scoped_method_call\n+\t    (ref, base_binfo, dtor_identifier,\n+\t     build_tree_list (NULL_TREE, this_auto_delete));\n \t  exprstmt = tree_cons (NULL_TREE, expr, exprstmt);\n \t}\n \n@@ -3897,13 +3387,9 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \t      || TREE_VIA_VIRTUAL (base_binfo))\n \t    continue;\n \n-\t  /* May be zero offset if other baseclasses are virtual.  */\n-\t  expr = fold (build (PLUS_EXPR, build_pointer_type (BINFO_TYPE (base_binfo)),\n-\t\t\t      addr, BINFO_OFFSET (base_binfo)));\n-\n-\t  expr = build_delete (build_pointer_type (BINFO_TYPE (base_binfo)), expr,\n-\t\t\t       integer_zero_node,\n-\t\t\t       flags, 0);\n+\t  expr = build_scoped_method_call\n+\t    (ref, base_binfo, dtor_identifier,\n+\t     build_tree_list (NULL_TREE, integer_zero_node));\n \n \t  exprstmt = tree_cons (NULL_TREE, expr, exprstmt);\n \t}"}, {"sha": "befb5a1521176fe970b9ce6ae5da68dce527e3be", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 14, "deletions": 34, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=bd6dd8453c857d8ee420c960503d8eb72de1aa75", "patch": "@@ -271,7 +271,7 @@ char *token_buffer;\t\t/* Pointer to token buffer.\n \n #include \"hash.h\"\n \f\n-int check_newline ();\n+static int check_newline ();\n \n /* Nonzero tells yylex to ignore \\ in string constants.  */\n static int ignore_escape_flag = 0;\n@@ -392,12 +392,14 @@ init_filename_times ()\n    Stuck this hack in to get the files open correctly; this is called\n    in place of init_lex if we are an unexec'd binary.    */\n \n+#if 0\n void\n reinit_lang_specific ()\n {\n   init_filename_times ();\n   reinit_search_statistics ();\n }\n+#endif\n \n int *init_parse ();\n \n@@ -1091,7 +1093,7 @@ interface_strcmp (s)\n   return 1;\n }\n \n-void\n+static void\n set_typedecl_interface_info (prev, vars)\n      tree prev, vars;\n {\n@@ -1103,7 +1105,7 @@ set_typedecl_interface_info (prev, vars)\n     = interface_strcmp (FILE_NAME_NONDIRECTORY (DECL_SOURCE_FILE (vars)));\n }\n \n-int\n+static int\n set_vardecl_interface_info (prev, vars)\n      tree prev, vars;\n {\n@@ -1403,7 +1405,7 @@ store_pending_inline (decl, t)\n   pending_inlines = t;\n }\n \n-void reinit_parse_for_block ();\n+static void reinit_parse_for_block PROTO((int, struct obstack *));\n \n void\n reinit_parse_for_method (yychar, decl)\n@@ -1455,7 +1457,7 @@ reinit_parse_for_method (yychar, decl)\n /* Consume a block -- actually, a method beginning\n    with `:' or `{' -- and save it away on the specified obstack.  */\n \n-void\n+static void\n reinit_parse_for_block (pyychar, obstackp)\n      int pyychar;\n      struct obstack *obstackp;\n@@ -1900,7 +1902,7 @@ static int handle_sysv_pragma ();\n #endif\n static int handle_cp_pragma ();\n \n-int\n+static int\n check_newline ()\n {\n   register int c;\n@@ -2517,7 +2519,12 @@ do_identifier (token, parsing)\n      [class.scope0] */\n   if (id && current_class_type && parsing\n       && TYPE_BEING_DEFINED (current_class_type)\n-      && ! IDENTIFIER_CLASS_VALUE (token))\n+      && ! IDENTIFIER_CLASS_VALUE (token)\n+      /* Avoid breaking if we get called for a default argument that\n+\t refers to an overloaded method.  Eventually this will not be\n+\t necessary, since default arguments shouldn't be parsed until\n+\t after the class is complete.  (jason 3/12/97) */\n+      && TREE_CODE (id) != TREE_LIST)\n     pushdecl_class_level (id);\n     \n   if (!id || id == error_mark_node)\n@@ -4157,33 +4164,6 @@ make_lang_type (code)\n   return t;\n }\n \n-void\n-copy_decl_lang_specific (decl)\n-     tree decl;\n-{\n-  extern struct obstack *current_obstack, *saveable_obstack;\n-  register int *old = (int *)DECL_LANG_SPECIFIC (decl);\n-  struct obstack *obstack = current_obstack;\n-  register int i = sizeof (struct lang_decl) / sizeof (int);\n-  register int *pi;\n-\n-  if (! TREE_PERMANENT (decl))\n-    obstack = saveable_obstack;\n-  else\n-    my_friendly_assert (obstack == &permanent_obstack, 237);\n-\n-  pi = (int *) obstack_alloc (obstack, sizeof (struct lang_decl));\n-  while (i-- > 0)\n-    pi[i] = old[i];\n-\n-  DECL_LANG_SPECIFIC (decl) = (struct lang_decl *) pi;\n-\n-#ifdef GATHER_STATISTICS\n-  tree_node_counts[(int)lang_decl] += 1;\n-  tree_node_sizes[(int)lang_decl] += sizeof (struct lang_decl);\n-#endif\n-}\n-\n void\n dump_time_statistics ()\n {"}, {"sha": "a9dd9d5de8e57d722d3708f12b714dca381ed2f5", "filename": "gcc/cp/method.c", "status": "modified", "additions": 95, "deletions": 42, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=bd6dd8453c857d8ee420c960503d8eb72de1aa75", "patch": "@@ -261,28 +261,67 @@ __inline\n #endif\n void\n icat (i)\n-     int i;\n+     HOST_WIDE_INT i;\n {\n+  unsigned HOST_WIDE_INT ui;\n+\n   /* Handle this case first, to go really quickly.  For many common values,\n-     the result of i/10 below is 1.  */\n+     the result of ui/10 below is 1.  */\n   if (i == 1)\n     {\n       OB_PUTC ('1');\n       return;\n     }\n \n-  if (i < 0)\n+  if (i >= 0)\n+    ui = i;\n+  else\n     {\n       OB_PUTC ('m');\n-      i = -i;\n+      ui = -i;\n+    }\n+\n+  if (ui >= 10)\n+    icat (ui / 10);\n+\n+  OB_PUTC ('0' + (ui % 10));\n+}\n+\n+static void\n+dicat (lo, hi)\n+     HOST_WIDE_INT lo, hi;\n+{\n+  unsigned HOST_WIDE_INT ulo, uhi, qlo, qhi;\n+\n+  if (hi >= 0)\n+    {\n+      uhi = hi;\n+      ulo = lo;\n     }\n-  if (i < 10)\n-    OB_PUTC ('0' + i);\n   else\n     {\n-      icat (i / 10);\n-      OB_PUTC ('0' + (i % 10));\n+      uhi = (lo == 0 ? -hi : -hi-1);\n+      ulo = -lo;\n+    }\n+  if (uhi == 0\n+      && ulo < ((unsigned HOST_WIDE_INT)1 << (HOST_BITS_PER_WIDE_INT - 1)))\n+    {\n+      icat (ulo);\n+      return;\n     }\n+  /* Divide 2^HOST_WIDE_INT*uhi+ulo by 10. */\n+  qhi = uhi / 10;\n+  uhi = uhi % 10;\n+  qlo = uhi * (((unsigned HOST_WIDE_INT)1 << (HOST_BITS_PER_WIDE_INT - 1)) / 5);\n+  qlo += ulo / 10;\n+  ulo = ulo % 10;\n+  ulo += uhi * (((unsigned HOST_WIDE_INT)1 << (HOST_BITS_PER_WIDE_INT - 1)) % 5)\n+\t * 2;\n+  qlo += ulo / 10;\n+  ulo = ulo % 10;\n+  /* Quotient is 2^HOST_WIDE_INT*qhi+qlo, remainder is ulo. */\n+  dicat (qlo, qhi);\n+  OB_PUTC ('0' + ulo);\n }\n \n static\n@@ -380,17 +419,12 @@ build_overload_int (value)\n   my_friendly_assert (TREE_CODE (value) == INTEGER_CST, 243);\n   if (TYPE_PRECISION (TREE_TYPE (value)) == 2 * HOST_BITS_PER_WIDE_INT)\n     {\n-      if (tree_int_cst_lt (value, integer_zero_node))\n-\t{\n-\t  OB_PUTC ('m');\n-\t  value = build_int_2 (~ TREE_INT_CST_LOW (value),\n-\t\t\t       - TREE_INT_CST_HIGH (value));\n-\t}\n       if (TREE_INT_CST_HIGH (value)\n \t  != (TREE_INT_CST_LOW (value) >> (HOST_BITS_PER_WIDE_INT - 1)))\n \t{\n \t  /* need to print a DImode value in decimal */\n-\t  sorry (\"conversion of long long as PT parameter\");\n+\t  dicat (TREE_INT_CST_LOW (value), TREE_INT_CST_HIGH (value));\n+\t  return;\n \t}\n       /* else fall through to print in smaller mode */\n     }\n@@ -440,54 +474,73 @@ build_overload_value (type, value)\n \tnumeric_output_need_bar = 1;\n \treturn;\n       }\n-#ifndef REAL_IS_NOT_DOUBLE\n     case REAL_TYPE:\n       {\n \tREAL_VALUE_TYPE val;\n \tchar *bufp = digit_buffer;\n \textern char *index ();\n \n+\tpedwarn (\"ANSI C++ forbids floating-point template arguments\");\n+\n \tmy_friendly_assert (TREE_CODE (value) == REAL_CST, 244);\n \tval = TREE_REAL_CST (value);\n-\tif (val < 0)\n+\tif (REAL_VALUE_ISNAN (val))\n \t  {\n-\t    val = -val;\n-\t    *bufp++ = 'm';\n+\t    sprintf (bufp, \"NaN\");\n \t  }\n-\tsprintf (bufp, \"%e\", val);\n-\tbufp = (char *) index (bufp, 'e');\n-\tif (!bufp)\n-\t  strcat (digit_buffer, \"e0\");\n \telse\n \t  {\n-\t    char *p;\n-\t    bufp++;\n-\t    if (*bufp == '-')\n+\t    if (REAL_VALUE_NEGATIVE (val))\n \t      {\n+\t\tval = REAL_VALUE_NEGATE (val);\n \t\t*bufp++ = 'm';\n \t      }\n-\t    p = bufp;\n-\t    if (*p == '+')\n-\t      p++;\n-\t    while (*p == '0')\n-\t      p++;\n-\t    if (*p == 0)\n+\t    if (REAL_VALUE_ISINF (val))\n \t      {\n-\t\t*bufp++ = '0';\n-\t\t*bufp = 0;\n+\t\tsprintf (bufp, \"Infinity\");\n \t      }\n-\t    else if (p != bufp)\n+\t    else\n \t      {\n-\t\twhile (*p)\n-\t\t  *bufp++ = *p++;\n-\t\t*bufp = 0;\n+\t\tereal_to_decimal (val, bufp);\n+\t\tbufp = (char *) index (bufp, 'e');\n+\t\tif (!bufp)\n+\t\t  strcat (digit_buffer, \"e0\");\n+\t\telse\n+\t\t  {\n+\t\t    char *p;\n+\t\t    bufp++;\n+\t\t    if (*bufp == '-')\n+\t\t      {\n+\t\t\t*bufp++ = 'm';\n+\t\t      }\n+\t\t    p = bufp;\n+\t\t    if (*p == '+')\n+\t\t      p++;\n+\t\t    while (*p == '0')\n+\t\t      p++;\n+\t\t    if (*p == 0)\n+\t\t      {\n+\t\t\t*bufp++ = '0';\n+\t\t\t*bufp = 0;\n+\t\t      }\n+\t\t    else if (p != bufp)\n+\t\t      {\n+\t\t\twhile (*p)\n+\t\t\t  *bufp++ = *p++;\n+\t\t\t*bufp = 0;\n+\t\t      }\n+\t\t  }\n+#ifdef NO_DOT_IN_LABEL\n+\t\tbufp = (char *) index (bufp, '.');\n+\t\tif (bufp)\n+\t\t  *bufp = '_';\n+#endif\n \t      }\n \t  }\n \tOB_PUTCP (digit_buffer);\n \tnumeric_output_need_bar = 1;\n \treturn;\n       }\n-#endif\n     case POINTER_TYPE:\n       if (TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE\n \t  && TREE_CODE (value) != ADDR_EXPR)\n@@ -1151,8 +1204,8 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n \n   if (code == COND_EXPR)\n     {\n-      if (TREE_CODE (xarg2) == ERROR_MARK\n-\t  || TREE_CODE (arg3) == ERROR_MARK)\n+      if (xarg2 == error_mark_node\n+\t  || arg3 == error_mark_node)\n \treturn error_mark_node;\n     }\n   if (code == COMPONENT_REF)\n@@ -1468,7 +1521,7 @@ hack_identifier (value, name)\n {\n   tree type;\n \n-  if (TREE_CODE (value) == ERROR_MARK)\n+  if (value == error_mark_node)\n     {\n       if (current_class_name)\n \t{"}, {"sha": "720c041eef4e58a3bc1b55cc9394b731ff4e5199", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=bd6dd8453c857d8ee420c960503d8eb72de1aa75", "patch": "@@ -2478,10 +2478,11 @@ left_curly:\n \t\t  push_obstacks_nochange ();\n \t\t  end_temporary_allocation ();\n \n-\t\t  if (! IS_AGGR_TYPE (t))\n+\t\t  if (t == error_mark_node\n+\t\t      || ! IS_AGGR_TYPE (t))\n \t\t    {\n \t\t      t = $<ttype>0 = make_lang_type (RECORD_TYPE);\n-\t\t      TYPE_NAME (t) = get_identifier (\"erroneous type\");\n+\t\t      pushtag (make_anon_name (), t, 0);\n \t\t    }\n \t\t  if (TYPE_SIZE (t))\n \t\t    duplicate_tag_error (t);"}, {"sha": "d0a6c7644efe6ccdceca680530f758ab93c967c1", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=bd6dd8453c857d8ee420c960503d8eb72de1aa75", "patch": "@@ -65,11 +65,12 @@ static int unify ();\n \n void pop_template_decls ();\n \n-tree classtype_mangled_name ();\n+static tree classtype_mangled_name ();\n static char * mangle_class_name_for_template ();\n static tree tsubst_expr_values ();\n+static int comp_template_args PROTO((tree, tree));\n tree most_specialized_class PROTO((tree, tree));\n-tree get_class_bindings PROTO((tree, tree, tree));\n+static tree get_class_bindings PROTO((tree, tree, tree));\n tree make_temp_vec PROTO((int));\n \n /* We've got a template header coming up; push to a new level for storing\n@@ -448,6 +449,11 @@ coerce_template_parms (parms, arglist, in_decl)\n \t  /* 14.2: Other template-arguments must be constant-expressions,\n \t     addresses of objects or functions with external linkage, or of\n \t     static class members.  */\n+\t  else if (IS_AGGR_TYPE (TREE_TYPE (val)))\n+\t    {\n+\t      cp_error (\"object `%E' cannot be used as template argument\", arg);\n+\t      val = error_mark_node;\n+\t    }\n \t  else if (!TREE_CONSTANT (val))\n \t    {\n \t      cp_error (\"non-const `%E' cannot be used as template argument\",\n@@ -504,7 +510,7 @@ coerce_template_parms (parms, arglist, in_decl)\n   return vec;\n }\n \n-int\n+static int\n comp_template_args (oldargs, newargs)\n      tree oldargs, newargs;\n {\n@@ -616,7 +622,7 @@ mangle_class_name_for_template (name, parms, arglist)\n   return NULL;\n }\n \n-tree\n+static tree\n classtype_mangled_name (t)\n      tree t;\n {\n@@ -968,7 +974,7 @@ extern int max_tinst_depth;\n int depth_reached = 0;\n #endif\n \n-int\n+static int\n push_tinst_level (d)\n      tree d;\n {\n@@ -2808,7 +2814,11 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n       return 0;\n \n       /* Types INTEGER_CST and MINUS_EXPR can come from array bounds.  */\n+      /* Type INTEGER_CST can come from ordinary constant template args.  */\n     case INTEGER_CST:\n+      while (TREE_CODE (arg) == NOP_EXPR)\n+\targ = TREE_OPERAND (arg, 0);\n+\n       if (TREE_CODE (arg) != INTEGER_CST)\n \treturn 1;\n       return !tree_int_cst_equal (parm, arg);\n@@ -2993,7 +3003,7 @@ get_bindings (fn, decl)\n   return 0;\n }\n \n-tree\n+static tree\n get_class_bindings (tparms, parms, args)\n      tree tparms, parms, args;\n {"}, {"sha": "f5f372c39438bf1a99f8e8693c1f0a9ec8d5cc08", "filename": "gcc/cp/search.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=bd6dd8453c857d8ee420c960503d8eb72de1aa75", "patch": "@@ -412,23 +412,17 @@ pop_memoized_context (use_old)\n /* Get a virtual binfo that is found inside BINFO's hierarchy that is\n    the same type as the type given in PARENT.  To be optimal, we want\n    the first one that is found by going through the least number of\n-   virtual bases.  DEPTH should be NULL_PTR.  */\n+   virtual bases.  */\n \n static tree\n-get_vbase (parent, binfo, depth)\n+get_vbase_1 (parent, binfo, depth)\n      tree parent, binfo;\n      unsigned int *depth;\n {\n   tree binfos;\n   int i, n_baselinks;\n   tree rval = NULL_TREE;\n \n-  if (depth == 0)\n-    {\n-      unsigned int d = (unsigned int)-1;\n-      return get_vbase (parent, binfo, &d);\n-    }\n-\n   if (BINFO_TYPE (binfo) == parent && TREE_VIA_VIRTUAL (binfo))\n     {\n       *depth = 0;\n@@ -449,24 +443,33 @@ get_vbase (parent, binfo, depth)\n       if (*depth == 0)\n \tbreak;\n \n-      nrval = get_vbase (parent, base_binfo, depth);\n+      nrval = get_vbase_1 (parent, base_binfo, depth);\n       if (nrval)\n \trval = nrval;\n     }\n   *depth = *depth+1;\n   return rval;\n }\n \n+tree\n+get_vbase (parent, binfo)\n+     tree parent;\n+     tree binfo;\n+{\n+  unsigned int d = (unsigned int)-1;\n+  return get_vbase_1 (parent, binfo, &d);\n+}\n+\n /* Convert EXPR to a virtual base class of type TYPE.  We know that\n    EXPR is a non-null POINTER_TYPE to RECORD_TYPE.  We also know that\n    the type of what expr points to has a virtual base of type TYPE.  */\n \n-tree\n+static tree\n convert_pointer_to_vbase (type, expr)\n      tree type;\n      tree expr;\n {\n-  tree vb = get_vbase (type, TYPE_BINFO (TREE_TYPE (TREE_TYPE (expr))), NULL_PTR);\n+  tree vb = get_vbase (type, TYPE_BINFO (TREE_TYPE (TREE_TYPE (expr))));\n   return convert_pointer_to_real (vb, expr);\n }\n \n@@ -3158,7 +3161,6 @@ note_debug_info_needed (type)\n /* Subroutines of push_class_decls ().  */\n \n /* Add in a decl to the envelope.  */\n-\n static void\n envelope_add_decl (type, decl, values)\n      tree type, decl, *values;"}, {"sha": "2a5efcd59f72a20b6e109b24f10af43a8eabe4b9", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=bd6dd8453c857d8ee420c960503d8eb72de1aa75", "patch": "@@ -37,6 +37,8 @@ extern void sorry ();\n extern void compiler_error ();\n extern void make_decl_rtl\t\t\tPROTO((tree, char *, int));\n \n+static tree build_sptr_ref\t\t\tPROTO((tree));\n+\n /* Used to help generate globally unique names for signature tables.  */\n \n static int global_sigtable_name_counter;\n@@ -1047,7 +1049,7 @@ build_optr_ref (instance)\n /* Create a COMPONENT_REF expression for referencing the SPTR field\n    of a signature pointer or reference.  */\n \n-tree\n+static tree\n build_sptr_ref (instance)\n      tree instance;\n {"}, {"sha": "aefce65b2cb20c85c549d4bc7b2c52c0b0efe67e", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=bd6dd8453c857d8ee420c960503d8eb72de1aa75", "patch": "@@ -404,7 +404,7 @@ build_cplus_method_type (basetype, rettype, argtypes)\n   return t;\n }\n \n-tree\n+static tree\n build_cplus_array_type_1 (elt_type, index_type)\n      tree elt_type;\n      tree index_type;\n@@ -1319,41 +1319,6 @@ get_first_fn (from)\n   return TREE_VALUE (from);\n }\n \n-tree\n-fnaddr_from_vtable_entry (entry)\n-     tree entry;\n-{\n-  if (flag_vtable_thunks)\n-    {\n-      tree func = entry;\n-      if (TREE_CODE (func) == ADDR_EXPR)\n-\tfunc = TREE_OPERAND (func, 0);\n-      if (TREE_CODE (func) == THUNK_DECL)\n-\treturn DECL_INITIAL (func);\n-      else\n-\treturn entry;\n-    }\n-  else\n-    return TREE_VALUE (TREE_CHAIN (TREE_CHAIN (CONSTRUCTOR_ELTS (entry))));\n-}\n-\n-tree\n-function_arg_chain (t)\n-     tree t;\n-{\n-  return TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (t)));\n-}\n-\n-int\n-promotes_to_aggr_type (t, code)\n-     tree t;\n-     enum tree_code code;\n-{\n-  if (TREE_CODE (t) == code)\n-    t = TREE_TYPE (t);\n-  return IS_AGGR_TYPE (t);\n-}\n-\n int\n is_aggr_type_2 (t1, t2)\n      tree t1, t2;"}, {"sha": "a734c01344aaeb8ab377a5151add2803c042c3f1", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd6dd8453c857d8ee420c960503d8eb72de1aa75/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=bd6dd8453c857d8ee420c960503d8eb72de1aa75", "patch": "@@ -44,18 +44,17 @@ int mark_addressable PROTO((tree));\n static tree convert_for_assignment PROTO((tree, tree, char*, tree, int));\n /* static */ tree convert_for_initialization PROTO((tree, tree, tree, int, char*, tree, int));\n extern tree shorten_compare ();\n-extern void binary_op_error ();\n static tree pointer_int_sum PROTO((enum tree_code, register tree, register tree));\n static tree pointer_diff PROTO((register tree, register tree));\n+static int comp_target_parms PROTO((tree, tree, int));\n+static int comp_ptr_ttypes_const PROTO((tree, tree));\n+static int comp_ptr_ttypes_reinterpret PROTO((tree, tree));\n #if 0\n static tree convert_sequence ();\n #endif\n /* static */ tree unary_complex_lvalue PROTO((enum tree_code, tree));\n static tree get_delta_difference PROTO((tree, tree, int));\n \n-extern rtx original_result_rtx;\n-extern int warn_synth;\n-\n /* Return the target type of TYPE, which meas return T for:\n    T*, T&, T[], T (...), and otherwise, just T.  */\n \n@@ -942,7 +941,7 @@ comp_target_types (ttl, ttr, nptrs)\n    If there is not a unique most-derived base type, this function\n    returns ERROR_MARK_NODE.  */\n \n-tree\n+static tree\n common_base_type (tt1, tt2)\n      tree tt1, tt2;\n {\n@@ -1049,7 +1048,7 @@ compparms (parms1, parms2, strict)\n /* This really wants return whether or not parameter type lists\n    would make their owning functions assignment compatible or not.  */\n \n-int\n+static int\n comp_target_parms (parms1, parms2, strict)\n      tree parms1, parms2;\n      int strict;\n@@ -2070,16 +2069,6 @@ build_indirect_ref (ptr, errorstring)\n    integer type.  Otherwise, to make a compatible PLUS_EXPR, it\n    will inherit the type of the array, which will be some pointer type.  */\n \n-tree\n-build_x_array_ref (array, idx)\n-     tree array, idx;\n-{\n-  tree rval = build_opfncall (ARRAY_REF, LOOKUP_NORMAL, array, idx, NULL_TREE);\n-  if (rval)\n-    return rval;\n-  return build_array_ref (array, idx);\n-}\n-\n tree\n build_array_ref (array, idx)\n      tree array, idx;\n@@ -5365,8 +5354,7 @@ build_const_cast (type, expr)\n \n tree\n build_c_cast (type, expr)\n-     register tree type;\n-     tree expr;\n+     tree type, expr;\n {\n   register tree value = expr;\n \n@@ -5436,7 +5424,6 @@ build_c_cast (type, expr)\n   else\n     {\n       tree otype;\n-      int flag;\n \n       /* Convert functions and arrays to pointers and\n \t convert references to their expanded types,\n@@ -5506,7 +5493,7 @@ build_c_cast (type, expr)\n \t    value = decl_constant_value (value);\n \n \t  ovalue = value;\n-\t  value = convert_force (type, value, flag);\n+\t  value = convert_force (type, value, CONV_C_CAST);\n \n \t  /* Ignore any integer overflow caused by the cast.  */\n \t  if (TREE_CODE (value) == INTEGER_CST)\n@@ -5580,7 +5567,7 @@ build_modify_expr (lhs, modifycode, rhs)\n   tree olhs = lhs;\n \n   /* Avoid duplicate error messages from operands that had errors.  */\n-  if (TREE_CODE (lhs) == ERROR_MARK || TREE_CODE (rhs) == ERROR_MARK)\n+  if (lhs == error_mark_node || rhs == error_mark_node)\n     return error_mark_node;\n \n   /* Types that aren't fully specified cannot be used in assignments.  */\n@@ -5616,14 +5603,14 @@ build_modify_expr (lhs, modifycode, rhs)\n     case COMPOUND_EXPR:\n       newrhs = build_modify_expr (TREE_OPERAND (lhs, 1),\n \t\t\t\t  modifycode, rhs);\n-      if (TREE_CODE (newrhs) == ERROR_MARK)\n+      if (newrhs == error_mark_node)\n \treturn error_mark_node;\n       return build (COMPOUND_EXPR, lhstype,\n \t\t    TREE_OPERAND (lhs, 0), newrhs);\n \n     case MODIFY_EXPR:\n       newrhs = build_modify_expr (TREE_OPERAND (lhs, 0), modifycode, rhs);\n-      if (TREE_CODE (newrhs) == ERROR_MARK)\n+      if (newrhs == error_mark_node)\n \treturn error_mark_node;\n       return build (COMPOUND_EXPR, lhstype, lhs, newrhs);\n \n@@ -5640,7 +5627,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \t\t\t\t\t\t       modifycode, rhs),\n \t\t\t\t    build_modify_expr (convert (TREE_TYPE (lhs), TREE_OPERAND (lhs, 2)),\n \t\t\t\t\t\t       modifycode, rhs));\n-\tif (TREE_CODE (cond) == ERROR_MARK)\n+\tif (cond == error_mark_node)\n \t  return cond;\n \t/* Make sure the code to compute the rhs comes out\n \t   before the split.  */\n@@ -5796,7 +5783,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \tresult = build_modify_expr (inner_lhs, NOP_EXPR,\n \t\t\t\t    convert (TREE_TYPE (inner_lhs),\n \t\t\t\t\t     convert (lhstype, newrhs)));\n-\tif (TREE_CODE (result) == ERROR_MARK)\n+\tif (result == error_mark_node)\n \t  return result;\n \treturn convert (TREE_TYPE (lhs), result);\n       }\n@@ -5983,7 +5970,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \t\t\tTREE_OPERAND (newrhs, 0));\n     }\n \n-  if (TREE_CODE (newrhs) == ERROR_MARK)\n+  if (newrhs == error_mark_node)\n     return error_mark_node;\n \n   if (TREE_CODE (newrhs) == COND_EXPR)\n@@ -7321,7 +7308,7 @@ c_expand_start_case (exp)\n /* CONSTP remembers whether or not all the intervening pointers in the `to'\n    type have been const.  */\n \n-int\n+static int\n comp_ptr_ttypes_real (to, from, constp)\n      tree to, from;\n      int constp;\n@@ -7392,7 +7379,7 @@ ptr_reasonably_similar (to, from)\n \n /* Like comp_ptr_ttypes, for const_cast.  */\n \n-int\n+static int\n comp_ptr_ttypes_const (to, from)\n      tree to, from;\n {\n@@ -7413,7 +7400,7 @@ comp_ptr_ttypes_const (to, from)\n \n /* Like comp_ptr_ttypes, for reinterpret_cast.  */\n \n-int\n+static int\n comp_ptr_ttypes_reinterpret (to, from)\n      tree to, from;\n {"}]}