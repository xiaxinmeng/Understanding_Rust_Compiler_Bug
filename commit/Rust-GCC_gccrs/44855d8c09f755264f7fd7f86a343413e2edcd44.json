{"sha": "44855d8c09f755264f7fd7f86a343413e2edcd44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ4NTVkOGMwOWY3NTUyNjRmN2ZkN2Y4NmEzNDM0MTNlMmVkY2Q0NA==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2008-02-24T16:43:23Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2008-02-24T16:43:23Z"}, "message": "trans-array.c (gfc_conv_descriptor_data_get, [...]): Use fold_buildN instead of buildN.\n\n* trans-array.c (gfc_conv_descriptor_data_get,\ngfc_conv_descriptor_data_set_internal,\ngfc_conv_descriptor_data_addr, gfc_conv_descriptor_offset,\ngfc_conv_descriptor_dtype, gfc_conv_descriptor_dimension,\ngfc_conv_descriptor_stride, gfc_conv_descriptor_lbound,\ngfc_conv_descriptor_ubound, gfc_trans_create_temp_array,\ngfc_conv_array_transpose, gfc_grow_array,\ngfc_trans_array_constructor_subarray,\ngfc_trans_array_constructor_value, gfc_trans_scalarized_loop_end,\ngfc_array_init_size, gfc_array_allocate, gfc_array_deallocate,\ngfc_conv_array_initializer, gfc_trans_array_bounds,\ngfc_trans_auto_array_allocation, gfc_trans_dummy_array_bias,\ngfc_get_dataptr_offset, gfc_conv_array_parameter,\ngfc_trans_dealloc_allocated, get_full_array_size,\ngfc_duplicate_allocatable, structure_alloc_comps): Use fold_buildN\ninstead of buildN.\n* trans-expr.c (gfc_conv_expr_present, gfc_conv_missing_dummy,\ngfc_conv_component_ref, gfc_conv_cst_int_power,\ngfc_conv_function_call, gfc_trans_structur_assign): Likewise.\n* trans-common.c (create_common): Likewise.\n* trans-openmp.c (gfc_trans_omp_atomic, gfc_trans_omp_do):\nLikewise.\n* trans-const.c (gfc_conv_constant_to_tree): Likewise.\n* trans-stmt.c (gfc_trans_goto, gfc_trans_return, gfc_trans_do,\ngfc_trans_integer_select, gfc_trans_character_select,\ngfc_trans_forall_loop, compute_overall_iter_number,\ngfc_trans_forall_1, gfc_evaluate_where_mask, gfc_trans_allocate,\ngfc_trans_deallocate): Likewise.\n* trans.c (gfc_build_addr_expr, gfc_trans_runtime_check,\ngfc_allocate_with_status, gfc_allocate_array_with_status,\ngfc_deallocate_with_status): Likewise.\n* f95-lang.c (gfc_truthvalue_conversion): Likewise.\n* trans-io.c (set_parameter_const, set_parameter_value,\nset_parameter_ref, set_string, set_internal_unit, io_result,\nset_error_locus, nml_get_addr_expr, transfer_expr): Likewise.\n* trans-decl.c (gfc_build_qualified_array, build_entry_thunks,\ngfc_get_fake_result_decl, gfc_trans_auto_character_variable,\ngfc_generate_function_code): Likewise.\n* convert.c (convert): Likewise.\n* trans-intrinsic.c (gfc_conv_intrinsic_conversion,\nbuild_fixbound_expr, build_fix_expr, gfc_conv_intrinsic_aint,\ngfc_conv_intrinsic_int, gfc_conv_intrinsic_imagpart,\ngfc_conv_intrinsic_conjg, gfc_conv_intrinsic_abs,\ngfc_conv_intrinsic_cmplx, gfc_conv_intrinsic_mod,\ngfc_conv_intrinsic_dim, gfc_conv_intrinsic_dprod,\ngfc_conv_intrinsic_ctime, gfc_conv_intrinsic_fdate,\ngfc_conv_intrinsic_ttynam, gfc_conv_intrinsic_minmax,\ngfc_conv_intrinsic_minmax_char, gfc_conv_intrinsic_count,\ngfc_conv_intrinsic_arith, gfc_conv_intrinsic_dot_product,\ngfc_conv_intrinsic_minmaxloc, gfc_conv_intrinsic_minmaxval,\ngfc_conv_intrinsic_btest, gfc_conv_intrinsic_not,\ngfc_conv_intrinsic_ibits, gfc_conv_intrinsic_ishft,\ngfc_conv_intrinsic_ichar, gfc_conv_intrinsic_size,\ngfc_conv_intrinsic_array_transfer, gfc_conv_intrinsic_transfer,\ngfc_conv_allocated, gfc_conv_associated, gfc_conv_intrinsic_trim,\ngfc_conv_intrinsic_repeat): Likewise.\n\nFrom-SVN: r132592", "tree": {"sha": "405bd7396b605b64b780b51b408b0d9c87bcc36e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/405bd7396b605b64b780b51b408b0d9c87bcc36e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44855d8c09f755264f7fd7f86a343413e2edcd44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44855d8c09f755264f7fd7f86a343413e2edcd44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44855d8c09f755264f7fd7f86a343413e2edcd44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44855d8c09f755264f7fd7f86a343413e2edcd44/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "faebccf9b6ec3f4bfdcc268fc55cf58c397bed6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faebccf9b6ec3f4bfdcc268fc55cf58c397bed6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faebccf9b6ec3f4bfdcc268fc55cf58c397bed6c"}], "stats": {"total": 701, "additions": 367, "deletions": 334}, "files": [{"sha": "1e7d090cbf1f1bc327a611e1cb4c2f6759a6a655", "filename": "gcc/fortran/convert.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fconvert.c?ref=44855d8c09f755264f7fd7f86a343413e2edcd44", "patch": "@@ -1,5 +1,5 @@\n /* Language-level data type conversion for GNU C.\n-   Copyright (C) 1987, 1988, 1991, 1998, 2002, 2007\n+   Copyright (C) 1987, 1988, 1991, 1998, 2002, 2007, 2008\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -89,7 +89,7 @@ convert (tree type, tree expr)\n       return error_mark_node;\n     }\n   if (code == VOID_TYPE)\n-    return build1 (CONVERT_EXPR, type, e);\n+    return fold_build1 (CONVERT_EXPR, type, e);\n #if 0\n   /* This is incorrect.  A truncation can't be stripped this way.\n      Extensions will be stripped by the use of get_unwidened.  */"}, {"sha": "ea795b24f74e6c3cc2ba6482b6538d6198a6651b", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=44855d8c09f755264f7fd7f86a343413e2edcd44", "patch": "@@ -1,5 +1,5 @@\n /* gfortran backend interface\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook.\n \n@@ -220,16 +220,17 @@ gfc_truthvalue_conversion (tree expr)\n \t  return expr;\n \t}\n       else if (TREE_CODE (expr) == NOP_EXPR)\n-        return build1 (NOP_EXPR, boolean_type_node, TREE_OPERAND (expr, 0));\n+        return fold_build1 (NOP_EXPR,\n+\t\t\t    boolean_type_node, TREE_OPERAND (expr, 0));\n       else\n-        return build1 (NOP_EXPR, boolean_type_node, expr);\n+        return fold_build1 (NOP_EXPR, boolean_type_node, expr);\n \n     case INTEGER_TYPE:\n       if (TREE_CODE (expr) == INTEGER_CST)\n \treturn integer_zerop (expr) ? boolean_false_node : boolean_true_node;\n       else\n-        return build2 (NE_EXPR, boolean_type_node, expr,\n-\t\t       build_int_cst (TREE_TYPE (expr), 0));\n+        return fold_build2 (NE_EXPR, boolean_type_node, expr,\n+\t\t\t    build_int_cst (TREE_TYPE (expr), 0));\n \n     default:\n       internal_error (\"Unexpected type in truthvalue_conversion\");"}, {"sha": "07b0f60c86dd6f98c8a85cbed2bacabaedd53ef9", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 91, "deletions": 72, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=44855d8c09f755264f7fd7f86a343413e2edcd44", "patch": "@@ -1,5 +1,5 @@\n /* Array translation routines\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n    and Steven Bosscher <s.bosscher@student.tudelft.nl>\n@@ -149,7 +149,7 @@ gfc_conv_descriptor_data_get (tree desc)\n   field = TYPE_FIELDS (type);\n   gcc_assert (DATA_FIELD == 0);\n \n-  t = build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n+  t = fold_build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n   t = fold_convert (GFC_TYPE_ARRAY_DATAPTR_TYPE (type), t);\n \n   return t;\n@@ -176,7 +176,7 @@ gfc_conv_descriptor_data_set_internal (stmtblock_t *block,\n   field = TYPE_FIELDS (type);\n   gcc_assert (DATA_FIELD == 0);\n \n-  t = build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n+  t = fold_build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n   gfc_add_modify (block, t, fold_convert (TREE_TYPE (field), value), tuples_p);\n }\n \n@@ -195,7 +195,7 @@ gfc_conv_descriptor_data_addr (tree desc)\n   field = TYPE_FIELDS (type);\n   gcc_assert (DATA_FIELD == 0);\n \n-  t = build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n+  t = fold_build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n   return build_fold_addr_expr (t);\n }\n \n@@ -211,7 +211,8 @@ gfc_conv_descriptor_offset (tree desc)\n   field = gfc_advance_chain (TYPE_FIELDS (type), OFFSET_FIELD);\n   gcc_assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n-  return build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n+  return fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n+\t\t      desc, field, NULL_TREE);\n }\n \n tree\n@@ -226,7 +227,8 @@ gfc_conv_descriptor_dtype (tree desc)\n   field = gfc_advance_chain (TYPE_FIELDS (type), DTYPE_FIELD);\n   gcc_assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n-  return build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n+  return fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n+\t\t      desc, field, NULL_TREE);\n }\n \n static tree\n@@ -244,7 +246,8 @@ gfc_conv_descriptor_dimension (tree desc, tree dim)\n \t  && TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (field))) == RECORD_TYPE);\n \n-  tmp = build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n+  tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n+\t\t     desc, field, NULL_TREE);\n   tmp = gfc_build_array_ref (tmp, dim, NULL);\n   return tmp;\n }\n@@ -260,7 +263,8 @@ gfc_conv_descriptor_stride (tree desc, tree dim)\n   field = gfc_advance_chain (field, STRIDE_SUBFIELD);\n   gcc_assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n-  tmp = build3 (COMPONENT_REF, TREE_TYPE (field), tmp, field, NULL_TREE);\n+  tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n+\t\t     tmp, field, NULL_TREE);\n   return tmp;\n }\n \n@@ -275,7 +279,8 @@ gfc_conv_descriptor_lbound (tree desc, tree dim)\n   field = gfc_advance_chain (field, LBOUND_SUBFIELD);\n   gcc_assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n-  tmp = build3 (COMPONENT_REF, TREE_TYPE (field), tmp, field, NULL_TREE);\n+  tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n+\t\t     tmp, field, NULL_TREE);\n   return tmp;\n }\n \n@@ -290,7 +295,8 @@ gfc_conv_descriptor_ubound (tree desc, tree dim)\n   field = gfc_advance_chain (field, UBOUND_SUBFIELD);\n   gcc_assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n-  tmp = build3 (COMPONENT_REF, TREE_TYPE (field), tmp, field, NULL_TREE);\n+  tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n+\t\t     tmp, field, NULL_TREE);\n   return tmp;\n }\n \n@@ -641,9 +647,10 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n         {\n \t  /* For a callee allocated array express the loop bounds in terms\n \t     of the descriptor fields.  */\n-          tmp = build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\tgfc_conv_descriptor_ubound (desc, gfc_rank_cst[n]),\n-\t\t\tgfc_conv_descriptor_lbound (desc, gfc_rank_cst[n]));\n+          tmp =\n+\t    fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t gfc_conv_descriptor_ubound (desc, gfc_rank_cst[n]),\n+\t\t\t gfc_conv_descriptor_lbound (desc, gfc_rank_cst[n]));\n           loop->to[n] = tmp;\n           size = NULL_TREE;\n           continue;\n@@ -774,9 +781,10 @@ gfc_conv_array_transpose (gfc_se * se, gfc_expr * expr)\n       if (!loop->to[n])\n         {\n \t  gcc_assert (integer_zerop (loop->from[n]));\n-\t  loop->to[n] = build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\tgfc_conv_descriptor_ubound (dest, dest_index),\n-\t\t\t\tgfc_conv_descriptor_lbound (dest, dest_index));\n+\t  loop->to[n] =\n+\t    fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t gfc_conv_descriptor_ubound (dest, dest_index),\n+\t\t\t gfc_conv_descriptor_lbound (dest, dest_index));\n         }\n     }\n \n@@ -835,17 +843,19 @@ gfc_grow_array (stmtblock_t * pblock, tree desc, tree extra)\n   ubound = gfc_conv_descriptor_ubound (desc, gfc_rank_cst[0]);\n \n   /* Add EXTRA to the upper bound.  */\n-  tmp = build2 (PLUS_EXPR, gfc_array_index_type, ubound, extra);\n+  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type, ubound, extra);\n   gfc_add_modify_expr (pblock, ubound, tmp);\n \n   /* Get the value of the current data pointer.  */\n   arg0 = gfc_conv_descriptor_data_get (desc);\n \n   /* Calculate the new array size.  */\n   size = TYPE_SIZE_UNIT (gfc_get_element_type (TREE_TYPE (desc)));\n-  tmp = build2 (PLUS_EXPR, gfc_array_index_type, ubound, gfc_index_one_node);\n-  arg1 = build2 (MULT_EXPR, size_type_node, fold_convert (size_type_node, tmp),\n-\t\t fold_convert (size_type_node, size));\n+  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t     ubound, gfc_index_one_node);\n+  arg1 = fold_build2 (MULT_EXPR, size_type_node,\n+\t\t       fold_convert (size_type_node, tmp),\n+\t\t       fold_convert (size_type_node, size));\n \n   /* Call the realloc() function.  */\n   tmp = gfc_call_realloc (pblock, arg0, arg1);\n@@ -1084,7 +1094,8 @@ gfc_trans_array_constructor_subarray (stmtblock_t * pblock,\n   gcc_assert (se.ss == gfc_ss_terminator);\n \n   /* Increment the offset.  */\n-  tmp = build2 (PLUS_EXPR, gfc_array_index_type, *poffset, gfc_index_one_node);\n+  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t     *poffset, gfc_index_one_node);\n   gfc_add_modify_expr (&body, *poffset, tmp);\n \n   /* Finish the loop.  */\n@@ -1317,10 +1328,10 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t  tmp = fold_build2 (GT_EXPR, boolean_type_node, step, \n \t\t\t     build_int_cst (TREE_TYPE (step), 0));\n \t  cond = fold_build3 (COND_EXPR, boolean_type_node, tmp,\n-\t\t\t      build2 (GT_EXPR, boolean_type_node,\n-\t\t\t\t      loopvar, end),\n-\t\t\t      build2 (LT_EXPR, boolean_type_node,\n-\t\t\t\t      loopvar, end));\n+\t\t\t      fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t\t\t\t   loopvar, end),\n+\t\t\t      fold_build2 (LT_EXPR, boolean_type_node,\n+\t\t\t\t\t   loopvar, end));\n \t  tmp = build1_v (GOTO_EXPR, exit_label);\n \t  TREE_USED (exit_label) = 1;\n \t  tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n@@ -1330,7 +1341,7 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t  gfc_add_expr_to_block (&body, loopbody);\n \n \t  /* Increase loop variable by step.  */\n-\t  tmp = build2 (PLUS_EXPR, TREE_TYPE (loopvar), loopvar, step);\n+\t  tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (loopvar), loopvar, step);\n \t  gfc_add_modify_expr (&body, loopvar, tmp);\n \n \t  /* Finish the loop.  */\n@@ -2568,7 +2579,8 @@ gfc_trans_scalarized_loop_end (gfc_loopinfo * loop, int n,\n   gfc_init_block (&block);\n \n   /* The exit condition.  */\n-  cond = build2 (GT_EXPR, boolean_type_node, loop->loopvar[n], loop->to[n]);\n+  cond = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t      loop->loopvar[n], loop->to[n]);\n   tmp = build1_v (GOTO_EXPR, exit_label);\n   TREE_USED (exit_label) = 1;\n   tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n@@ -2578,8 +2590,8 @@ gfc_trans_scalarized_loop_end (gfc_loopinfo * loop, int n,\n   gfc_add_expr_to_block (&block, loopbody);\n \n   /* Increment the loopvar.  */\n-  tmp = build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\tloop->loopvar[n], gfc_index_one_node);\n+  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t     loop->loopvar[n], gfc_index_one_node);\n   gfc_add_modify_expr (&block, loop->loopvar[n], tmp);\n \n   /* Build the loop.  */\n@@ -3563,8 +3575,8 @@ gfc_array_init_size (tree descriptor, int rank, tree * poffset,\n       offset = fold_build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp);\n \n       /* Start the calculation for the size of this dimension.  */\n-      size = build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t     gfc_index_one_node, se.expr);\n+      size = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t  gfc_index_one_node, se.expr);\n \n       /* Set upper bound.  */\n       gfc_init_se (&se, NULL);\n@@ -3700,7 +3712,7 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n     tmp = gfc_allocate_array_with_status (&se->pre, pointer, size, pstat);\n   else\n     tmp = gfc_allocate_with_status (&se->pre, size, pstat);\n-  tmp = build2 (MODIFY_EXPR, void_type_node, pointer, tmp);\n+  tmp = fold_build2 (MODIFY_EXPR, void_type_node, pointer, tmp);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   tmp = gfc_conv_descriptor_offset (se->expr);\n@@ -3739,8 +3751,8 @@ gfc_array_deallocate (tree descriptor, tree pstat)\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* Zero the data pointer.  */\n-  tmp = build2 (MODIFY_EXPR, void_type_node,\n-                var, build_int_cst (TREE_TYPE (var), 0));\n+  tmp = fold_build2 (MODIFY_EXPR, void_type_node,\n+\t\t     var, build_int_cst (TREE_TYPE (var), 0));\n   gfc_add_expr_to_block (&block, tmp);\n \n   return gfc_finish_block (&block);\n@@ -3825,7 +3837,7 @@ gfc_conv_array_initializer (tree type, gfc_expr * expr)\n               else\n                 tmp1 = gfc_conv_mpz_to_tree (c->n.offset, gfc_index_integer_kind);\n \n-              range = build2 (RANGE_EXPR, integer_type_node, tmp1, tmp2);\n+              range = fold_build2 (RANGE_EXPR, integer_type_node, tmp1, tmp2);\n             }\n           else\n             range = NULL;\n@@ -3937,10 +3949,10 @@ gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n \n \t  /* Make sure that negative size arrays are translated\n \t     to being zero size.  */\n-\t  tmp = build2 (GE_EXPR, boolean_type_node,\n-\t\t\tstride, gfc_index_zero_node);\n-\t  tmp = build3 (COND_EXPR, gfc_array_index_type, tmp,\n-\t\t\tstride, gfc_index_zero_node);\n+\t  tmp = fold_build2 (GE_EXPR, boolean_type_node,\n+\t\t\t     stride, gfc_index_zero_node);\n+\t  tmp = fold_build3 (COND_EXPR, gfc_array_index_type, tmp,\n+\t\t\t     stride, gfc_index_zero_node);\n \t  gfc_add_modify_expr (pblock, stride, tmp);\n         }\n \n@@ -3988,7 +4000,7 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n \n       /* Emit a DECL_EXPR for this variable, which will cause the\n \t gimplifier to allocate storage, and all that good stuff.  */\n-      tmp = build1 (DECL_EXPR, TREE_TYPE (decl), decl);\n+      tmp = fold_build1 (DECL_EXPR, TREE_TYPE (decl), decl);\n       gfc_add_expr_to_block (&block, tmp);\n     }\n \n@@ -4195,9 +4207,10 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n       stride = gfc_conv_descriptor_stride (dumdesc, gfc_rank_cst[0]);\n       stride = gfc_evaluate_now (stride, &block);\n \n-      tmp = build2 (EQ_EXPR, boolean_type_node, stride, gfc_index_zero_node);\n-      tmp = build3 (COND_EXPR, gfc_array_index_type, tmp,\n-\t\t    gfc_index_one_node, stride);\n+      tmp = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t stride, gfc_index_zero_node);\n+      tmp = fold_build3 (COND_EXPR, gfc_array_index_type, tmp,\n+\t\t\t gfc_index_one_node, stride);\n       stride = GFC_TYPE_ARRAY_STRIDE (type, 0);\n       gfc_add_modify_expr (&block, stride, tmp);\n \n@@ -4225,8 +4238,8 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n   if (stmt_packed != NULL_TREE && stmt_unpacked != NULL_TREE)\n     {\n       /* Don't repack unknown shape arrays when the first stride is 1.  */\n-      tmp = build3 (COND_EXPR, TREE_TYPE (stmt_packed), partial,\n-\t\t    stmt_packed, stmt_unpacked);\n+      tmp = fold_build3 (COND_EXPR, TREE_TYPE (stmt_packed),\n+\t\t\t partial, stmt_packed, stmt_unpacked);\n     }\n   else\n     tmp = stmt_packed != NULL_TREE ? stmt_packed : stmt_unpacked;\n@@ -4282,8 +4295,8 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n \n \t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n \t\t\t\t ubound, lbound);\n-              stride2 = build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t       dubound, dlbound);\n+              stride2 = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t\t     dubound, dlbound);\n               tmp = fold_build2 (NE_EXPR, gfc_array_index_type, tmp, stride2);\n \t      asprintf (&msg, \"%s for dimension %d of array '%s'\",\n \t\t\tgfc_msg_bounds, n+1, sym->name);\n@@ -4295,7 +4308,8 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n \t{\n \t  /* For assumed shape arrays move the upper bound by the same amount\n \t     as the lower bound.  */\n-          tmp = build2 (MINUS_EXPR, gfc_array_index_type, dubound, dlbound);\n+          tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     dubound, dlbound);\n           tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type, tmp, lbound);\n           gfc_add_modify_expr (&block, ubound, tmp);\n \t}\n@@ -4333,8 +4347,8 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n \n               /* Assign the stride.  */\n               if (stmt_packed != NULL_TREE && stmt_unpacked != NULL_TREE)\n-\t\ttmp = build3 (COND_EXPR, gfc_array_index_type, partial,\n-\t\t\t      stmt_unpacked, stmt_packed);\n+\t\ttmp = fold_build3 (COND_EXPR, gfc_array_index_type, partial,\n+\t\t\t\t   stmt_unpacked, stmt_packed);\n               else\n                 tmp = (stmt_packed != NULL_TREE) ? stmt_packed : stmt_unpacked;\n               gfc_add_modify_expr (&block, stride, tmp);\n@@ -4404,7 +4418,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n       /* Only do the cleanup if the array was repacked.  */\n       tmp = build_fold_indirect_ref (dumdesc);\n       tmp = gfc_conv_descriptor_data_get (tmp);\n-      tmp = build2 (NE_EXPR, boolean_type_node, tmp, tmpdesc);\n+      tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp, tmpdesc);\n       stmt = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n \n       if (optional_arg)\n@@ -4468,7 +4482,8 @@ gfc_get_dataptr_offset (stmtblock_t *block, tree parm, tree desc, tree offset,\n \t    case REF_COMPONENT:\n \t      field = ref->u.c.component->backend_decl;\n \t      gcc_assert (field && TREE_CODE (field) == FIELD_DECL);\n-\t      tmp = build3 (COMPONENT_REF, TREE_TYPE (field), tmp, field, NULL_TREE);\n+\t      tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t\t tmp, field, NULL_TREE);\n \t      break;\n \n \t    case REF_SUBSTRING:\n@@ -5151,8 +5166,8 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77)\n          loop cleanup code.  */\n       tmp = build_fold_indirect_ref (desc);\n       tmp = gfc_conv_array_data (tmp);\n-      tmp = build2 (NE_EXPR, boolean_type_node,\n-\t\t    fold_convert (TREE_TYPE (tmp), ptr), tmp);\n+      tmp = fold_build2 (NE_EXPR, boolean_type_node,\n+\t\t\t fold_convert (TREE_TYPE (tmp), ptr), tmp);\n       tmp = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n \n       gfc_add_expr_to_block (&block, tmp);\n@@ -5185,8 +5200,8 @@ gfc_trans_dealloc_allocated (tree descriptor)\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* Zero the data pointer.  */\n-  tmp = build2 (MODIFY_EXPR, void_type_node,\n-\t\tvar, build_int_cst (TREE_TYPE (var), 0));\n+  tmp = fold_build2 (MODIFY_EXPR, void_type_node,\n+\t\t     var, build_int_cst (TREE_TYPE (var), 0));\n   gfc_add_expr_to_block (&block, tmp);\n \n   return gfc_finish_block (&block);\n@@ -5204,13 +5219,13 @@ get_full_array_size (stmtblock_t *block, tree decl, int rank)\n   idx = gfc_rank_cst[rank - 1];\n   nelems = gfc_conv_descriptor_ubound (decl, idx);\n   tmp = gfc_conv_descriptor_lbound (decl, idx);\n-  tmp = build2 (MINUS_EXPR, gfc_array_index_type, nelems, tmp);\n-  tmp = build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\ttmp, gfc_index_one_node);\n+  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, nelems, tmp);\n+  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t     tmp, gfc_index_one_node);\n   tmp = gfc_evaluate_now (tmp, block);\n \n   nelems = gfc_conv_descriptor_stride (decl, idx);\n-  tmp = build2 (MULT_EXPR, gfc_array_index_type, nelems, tmp);\n+  tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, nelems, tmp);\n   return gfc_evaluate_now (tmp, block);\n }\n \n@@ -5256,8 +5271,8 @@ gfc_duplicate_allocatable(tree dest, tree src, tree type, int rank)\n      the allocate and copy.  */\n   null_cond = gfc_conv_descriptor_data_get (src);\n   null_cond = convert (pvoid_type_node, null_cond);\n-  null_cond = build2 (NE_EXPR, boolean_type_node, null_cond,\n-\t\t      null_pointer_node);\n+  null_cond = fold_build2 (NE_EXPR, boolean_type_node,\n+\t\t\t   null_cond, null_pointer_node);\n   return build3_v (COND_EXPR, null_cond, tmp, null_data);\n }\n \n@@ -5307,12 +5322,12 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t     is a full array reference, we only need the descriptor\n \t     information from dimension = rank.  */\n \t  tmp = get_full_array_size (&fnblock, decl, rank);\n-\t  tmp = build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\ttmp, gfc_index_one_node);\n+\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     tmp, gfc_index_one_node);\n \n \t  null_cond = gfc_conv_descriptor_data_get (decl);\n-\t  null_cond = build2 (NE_EXPR, boolean_type_node, null_cond,\n-\t\t\t      build_int_cst (TREE_TYPE (null_cond), 0));\n+\t  null_cond = fold_build2 (NE_EXPR, boolean_type_node, null_cond,\n+\t\t\t\t   build_int_cst (TREE_TYPE (null_cond), 0));\n \t}\n       else\n \t{\n@@ -5376,7 +5391,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t     components.  */\n \t  if (cmp_has_alloc_comps && !c->pointer)\n \t    {\n-\t      comp = build3 (COMPONENT_REF, ctype, decl, cdecl, NULL_TREE);\n+\t      comp = fold_build3 (COMPONENT_REF, ctype,\n+\t\t\t\t  decl, cdecl, NULL_TREE);\n \t      rank = c->as ? c->as->rank : 0;\n \t      tmp = structure_alloc_comps (c->ts.derived, comp, NULL_TREE,\n \t\t\t\t\t   rank, purpose);\n@@ -5385,7 +5401,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \n \t  if (c->allocatable)\n \t    {\n-\t      comp = build3 (COMPONENT_REF, ctype, decl, cdecl, NULL_TREE);\n+\t      comp = fold_build3 (COMPONENT_REF, ctype,\n+\t\t\t\t  decl, cdecl, NULL_TREE);\n \t      tmp = gfc_trans_dealloc_allocated (comp);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n@@ -5396,12 +5413,14 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t    continue;\n \t  else if (c->allocatable)\n \t    {\n-\t      comp = build3 (COMPONENT_REF, ctype, decl, cdecl, NULL_TREE);\n+\t      comp = fold_build3 (COMPONENT_REF, ctype,\n+\t\t\t\t  decl, cdecl, NULL_TREE);\n \t      gfc_conv_descriptor_data_set (&fnblock, comp, null_pointer_node);\n \t    }\n           else if (cmp_has_alloc_comps)\n \t    {\n-\t      comp = build3 (COMPONENT_REF, ctype, decl, cdecl, NULL_TREE);\n+\t      comp = fold_build3 (COMPONENT_REF, ctype,\n+\t\t\t\t  decl, cdecl, NULL_TREE);\n \t      rank = c->as ? c->as->rank : 0;\n \t      tmp = structure_alloc_comps (c->ts.derived, comp, NULL_TREE,\n \t\t\t\t\t   rank, purpose);\n@@ -5414,8 +5433,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t    continue;\n \n \t  /* We need source and destination components.  */\n-\t  comp = build3 (COMPONENT_REF, ctype, decl, cdecl, NULL_TREE);\n-\t  dcmp = build3 (COMPONENT_REF, ctype, dest, cdecl, NULL_TREE);\n+\t  comp = fold_build3 (COMPONENT_REF, ctype, decl, cdecl, NULL_TREE);\n+\t  dcmp = fold_build3 (COMPONENT_REF, ctype, dest, cdecl, NULL_TREE);\n \t  dcmp = fold_convert (TREE_TYPE (comp), dcmp);\n \n \t  if (c->allocatable && !cmp_has_alloc_comps)"}, {"sha": "7086a6ceabdff9ffad40e61baf06c5df6ec0b003", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=44855d8c09f755264f7fd7f86a343413e2edcd44", "patch": "@@ -1,5 +1,5 @@\n /* Common block and equivalence list handling\n-   Copyright (C) 2000, 2003, 2004, 2005, 2006, 2007\n+   Copyright (C) 2000, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Canqun Yang <canqun@nudt.edu.cn>\n \n@@ -693,8 +693,8 @@ create_common (gfc_common_head *com, segment_info *head, bool saw_equiv)\n \tgfc_add_decl_to_function (var_decl);\n \n       SET_DECL_VALUE_EXPR (var_decl,\n-\t\t\t   build3 (COMPONENT_REF, TREE_TYPE (s->field),\n-\t\t\t\t   decl, s->field, NULL_TREE));\n+\t\t\t   fold_build3 (COMPONENT_REF, TREE_TYPE (s->field),\n+\t\t\t\t\tdecl, s->field, NULL_TREE));\n       DECL_HAS_VALUE_EXPR_P (var_decl) = 1;\n       GFC_DECL_COMMON_OR_EQUIV (var_decl) = 1;\n "}, {"sha": "8d5f8a8bc51f2fa71c7572b25b591092ac528cfa", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=44855d8c09f755264f7fd7f86a343413e2edcd44", "patch": "@@ -1,5 +1,5 @@\n /* Translation of constants\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Free Software\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software\n    Foundation, Inc.\n    Contributed by Paul Brook\n \n@@ -215,38 +215,38 @@ gfc_conv_constant_to_tree (gfc_expr * expr)\n     {\n     case BT_INTEGER:\n       if (expr->representation.string)\n-\treturn build1 (VIEW_CONVERT_EXPR,\n-\t\t\tgfc_get_int_type (expr->ts.kind),\n-\t\t\tgfc_build_string_const (expr->representation.length,\n-\t\t\t\texpr->representation.string));\n+\treturn fold_build1 (VIEW_CONVERT_EXPR,\n+\t\t\t    gfc_get_int_type (expr->ts.kind),\n+\t\t\t    gfc_build_string_const (expr->representation.length,\n+\t\t\t\t\t\t    expr->representation.string));\n       else\n \treturn gfc_conv_mpz_to_tree (expr->value.integer, expr->ts.kind);\n \n     case BT_REAL:\n       if (expr->representation.string)\n-\treturn build1 (VIEW_CONVERT_EXPR,\n-\t\t\tgfc_get_real_type (expr->ts.kind),\n-\t\t\tgfc_build_string_const (expr->representation.length,\n-\t\t\t\texpr->representation.string));\n+\treturn fold_build1 (VIEW_CONVERT_EXPR,\n+\t\t\t    gfc_get_real_type (expr->ts.kind),\n+\t\t\t    gfc_build_string_const (expr->representation.length,\n+\t\t\t\t\t\t    expr->representation.string));\n       else\n \treturn gfc_conv_mpfr_to_tree (expr->value.real, expr->ts.kind);\n \n     case BT_LOGICAL:\n       if (expr->representation.string)\n-\treturn build1 (VIEW_CONVERT_EXPR,\n-\t\t\tgfc_get_logical_type (expr->ts.kind),\n-\t\t\tgfc_build_string_const (expr->representation.length,\n-\t\t\t\texpr->representation.string));\n+\treturn fold_build1 (VIEW_CONVERT_EXPR,\n+\t\t\t    gfc_get_logical_type (expr->ts.kind),\n+\t\t\t    gfc_build_string_const (expr->representation.length,\n+\t\t\t\t\t\t    expr->representation.string));\n       else\n \treturn build_int_cst (gfc_get_logical_type (expr->ts.kind),\n \t\t\t    expr->value.logical);\n \n     case BT_COMPLEX:\n       if (expr->representation.string)\n-\treturn build1 (VIEW_CONVERT_EXPR,\n-\t\t\tgfc_get_complex_type (expr->ts.kind),\n-\t\t\tgfc_build_string_const (expr->representation.length,\n-\t\t\t\texpr->representation.string));\n+\treturn fold_build1 (VIEW_CONVERT_EXPR,\n+\t\t\t    gfc_get_complex_type (expr->ts.kind),\n+\t\t\t    gfc_build_string_const (expr->representation.length,\n+\t\t\t\t\t\t    expr->representation.string));\n       else\n \t{\n \t  tree real = gfc_conv_mpfr_to_tree (expr->value.complex.r,"}, {"sha": "52393b46bf2c587f087b1094cdf72c79a0d14494", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=44855d8c09f755264f7fd7f86a343413e2edcd44", "patch": "@@ -1,5 +1,5 @@\n /* Backend function setup\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Free Software\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software\n    Foundation, Inc.\n    Contributed by Paul Brook\n \n@@ -689,8 +689,8 @@ gfc_build_qualified_array (tree decl, gfc_symbol * sym)\n     {\n       tree size, range;\n \n-      size = build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t     GFC_TYPE_ARRAY_SIZE (type), gfc_index_one_node);\n+      size = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t  GFC_TYPE_ARRAY_SIZE (type), gfc_index_one_node);\n       range = build_range_type (gfc_array_index_type, gfc_index_zero_node,\n \t\t\t\tsize);\n       TYPE_DOMAIN (type) = range;\n@@ -1729,9 +1729,8 @@ build_entry_thunks (gfc_namespace * ns)\n \t  pushdecl (union_decl);\n \n \t  DECL_CONTEXT (union_decl) = current_function_decl;\n-\t  tmp = build2 (MODIFY_EXPR,\n-\t\t\tTREE_TYPE (union_decl),\n-\t\t\tunion_decl, tmp);\n+\t  tmp = fold_build2 (MODIFY_EXPR, TREE_TYPE (union_decl),\n+\t\t\t     union_decl, tmp);\n \t  gfc_add_expr_to_block (&body, tmp);\n \n \t  for (field = TYPE_FIELDS (TREE_TYPE (union_decl));\n@@ -1740,19 +1739,19 @@ build_entry_thunks (gfc_namespace * ns)\n \t\tthunk_sym->result->name) == 0)\n \t      break;\n \t  gcc_assert (field != NULL_TREE);\n-\t  tmp = build3 (COMPONENT_REF, TREE_TYPE (field), union_decl, field,\n-\t\t\tNULL_TREE);\n-\t  tmp = build2 (MODIFY_EXPR,\n-\t\t\tTREE_TYPE (DECL_RESULT (current_function_decl)),\n-\t\t\tDECL_RESULT (current_function_decl), tmp);\n+\t  tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t     union_decl, field, NULL_TREE);\n+\t  tmp = fold_build2 (MODIFY_EXPR, \n+\t\t\t     TREE_TYPE (DECL_RESULT (current_function_decl)),\n+\t\t\t     DECL_RESULT (current_function_decl), tmp);\n \t  tmp = build1_v (RETURN_EXPR, tmp);\n \t}\n       else if (TREE_TYPE (DECL_RESULT (current_function_decl))\n \t       != void_type_node)\n \t{\n-\t  tmp = build2 (MODIFY_EXPR,\n-\t\t\tTREE_TYPE (DECL_RESULT (current_function_decl)),\n-\t\t\tDECL_RESULT (current_function_decl), tmp);\n+\t  tmp = fold_build2 (MODIFY_EXPR,\n+\t\t\t     TREE_TYPE (DECL_RESULT (current_function_decl)),\n+\t\t\t     DECL_RESULT (current_function_decl), tmp);\n \t  tmp = build1_v (RETURN_EXPR, tmp);\n \t}\n       gfc_add_expr_to_block (&body, tmp);\n@@ -1874,8 +1873,8 @@ gfc_get_fake_result_decl (gfc_symbol * sym, int parent_flag)\n \t      break;\n \n \t  gcc_assert (field != NULL_TREE);\n-\t  decl = build3 (COMPONENT_REF, TREE_TYPE (field), decl, field,\n-\t\t\t NULL_TREE);\n+\t  decl = fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t      decl, field, NULL_TREE);\n \t}\n \n       var = create_tmp_var_raw (TREE_TYPE (decl), sym->name);\n@@ -2430,7 +2429,7 @@ gfc_trans_auto_character_variable (gfc_symbol * sym, tree fnbody)\n \n   /* Emit a DECL_EXPR for this variable, which will cause the\n      gimplifier to allocate storage, and all that good stuff.  */\n-  tmp = build1 (DECL_EXPR, TREE_TYPE (decl), decl);\n+  tmp = fold_build1 (DECL_EXPR, TREE_TYPE (decl), decl);\n   gfc_add_expr_to_block (&body, tmp);\n \n   gfc_add_expr_to_block (&body, fnbody);\n@@ -3318,8 +3317,8 @@ gfc_generate_function_code (gfc_namespace * ns)\n \t     types may be different for scalar default REAL functions\n \t     with -ff2c, therefore we have to convert.  */\n \t  tmp = convert (TREE_TYPE (DECL_RESULT (fndecl)), result);\n-\t  tmp = build2 (MODIFY_EXPR, TREE_TYPE (tmp),\n-\t\t\tDECL_RESULT (fndecl), tmp);\n+\t  tmp = fold_build2 (MODIFY_EXPR, TREE_TYPE (tmp),\n+\t\t\t     DECL_RESULT (fndecl), tmp);\n \t  tmp = build1_v (RETURN_EXPR, tmp);\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}"}, {"sha": "471f168357a3dd9e5c6222c5fff611551740c7d5", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=44855d8c09f755264f7fd7f86a343413e2edcd44", "patch": "@@ -1,5 +1,5 @@\n /* Expression translation\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Free Software\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software\n    Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n    and Steven Bosscher <s.bosscher@student.tudelft.nl>\n@@ -139,8 +139,8 @@ gfc_conv_expr_present (gfc_symbol * sym)\n              || GFC_ARRAY_TYPE_P (TREE_TYPE (decl)));\n       decl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n     }\n-  return build2 (NE_EXPR, boolean_type_node, decl,\n-\t\t fold_convert (TREE_TYPE (decl), null_pointer_node));\n+  return fold_build2 (NE_EXPR, boolean_type_node, decl,\n+\t\t      fold_convert (TREE_TYPE (decl), null_pointer_node));\n }\n \n \n@@ -176,8 +176,8 @@ gfc_conv_missing_dummy (gfc_se * se, gfc_expr * arg, gfc_typespec ts, int kind)\n   if (ts.type == BT_CHARACTER)\n     {\n       tmp = build_int_cst (gfc_charlen_type_node, 0);\n-      tmp = build3 (COND_EXPR, gfc_charlen_type_node, present,\n-\t\t    se->string_length, tmp);\n+      tmp = fold_build3 (COND_EXPR, gfc_charlen_type_node,\n+\t\t\t present, se->string_length, tmp);\n       tmp = gfc_evaluate_now (tmp, &se->pre);\n       se->string_length = tmp;\n     }\n@@ -378,7 +378,7 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)\n   field = c->backend_decl;\n   gcc_assert (TREE_CODE (field) == FIELD_DECL);\n   decl = se->expr;\n-  tmp = build3 (COMPONENT_REF, TREE_TYPE (field), decl, field, NULL_TREE);\n+  tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (field), decl, field, NULL_TREE);\n \n   se->expr = tmp;\n \n@@ -748,25 +748,27 @@ gfc_conv_cst_int_power (gfc_se * se, tree lhs, tree rhs)\n   /* If rhs < 0 and lhs is an integer, the result is -1, 0 or 1.  */\n   if ((sgn == -1) && (TREE_CODE (type) == INTEGER_TYPE))\n     {\n-      tmp = build2 (EQ_EXPR, boolean_type_node, lhs,\n-\t\t    build_int_cst (TREE_TYPE (lhs), -1));\n-      cond = build2 (EQ_EXPR, boolean_type_node, lhs,\n-\t\t     build_int_cst (TREE_TYPE (lhs), 1));\n+      tmp = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t lhs, build_int_cst (TREE_TYPE (lhs), -1));\n+      cond = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t  lhs, build_int_cst (TREE_TYPE (lhs), 1));\n \n       /* If rhs is even,\n \t result = (lhs == 1 || lhs == -1) ? 1 : 0.  */\n       if ((n & 1) == 0)\n         {\n-\t  tmp = build2 (TRUTH_OR_EXPR, boolean_type_node, tmp, cond);\n-\t  se->expr = build3 (COND_EXPR, type, tmp, build_int_cst (type, 1),\n-\t\t\t     build_int_cst (type, 0));\n+\t  tmp = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, tmp, cond);\n+\t  se->expr = fold_build3 (COND_EXPR, type,\n+\t\t\t\t  tmp, build_int_cst (type, 1),\n+\t\t\t\t  build_int_cst (type, 0));\n \t  return 1;\n \t}\n       /* If rhs is odd,\n \t result = (lhs == 1) ? 1 : (lhs == -1) ? -1 : 0.  */\n-      tmp = build3 (COND_EXPR, type, tmp, build_int_cst (type, -1),\n-\t\t    build_int_cst (type, 0));\n-      se->expr = build3 (COND_EXPR, type, cond, build_int_cst (type, 1), tmp);\n+      tmp = fold_build3 (COND_EXPR, type, tmp, build_int_cst (type, -1),\n+\t\t\t build_int_cst (type, 0));\n+      se->expr = fold_build3 (COND_EXPR, type,\n+\t\t\t      cond, build_int_cst (type, 1), tmp);\n       return 1;\n     }\n \n@@ -775,7 +777,7 @@ gfc_conv_cst_int_power (gfc_se * se, tree lhs, tree rhs)\n   if (sgn == -1)\n     {\n       tmp = gfc_build_const (type, integer_one_node);\n-      vartmp[1] = build2 (RDIV_EXPR, type, tmp, vartmp[1]);\n+      vartmp[1] = fold_build2 (RDIV_EXPR, type, tmp, vartmp[1]);\n     }\n \n   se->expr = gfc_conv_powi (se, n, vartmp);\n@@ -2306,9 +2308,9 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t  if (arg->next == NULL)\n \t    /* Only given one arg so generate a null and do a\n \t       not-equal comparison against the first arg.  */\n-\t    se->expr = build2 (NE_EXPR, boolean_type_node, arg1se.expr,\n-\t\t\t       fold_convert (TREE_TYPE (arg1se.expr),\n-\t\t\t\t\t     null_pointer_node));\n+\t    se->expr = fold_build2 (NE_EXPR, boolean_type_node, arg1se.expr,\n+\t\t\t\t    fold_convert (TREE_TYPE (arg1se.expr),\n+\t\t\t\t\t\t  null_pointer_node));\n \t  else\n \t    {\n \t      tree eq_expr;\n@@ -2321,16 +2323,16 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t      gfc_add_block_to_block (&se->post, &arg2se.post);\n \n \t      /* Generate test to compare that the two args are equal.  */\n-\t      eq_expr = build2 (EQ_EXPR, boolean_type_node, arg1se.expr,\n-\t\t\t\targ2se.expr);\n+\t      eq_expr = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\t     arg1se.expr, arg2se.expr);\n \t      /* Generate test to ensure that the first arg is not null.  */\n-\t      not_null_expr = build2 (NE_EXPR, boolean_type_node, arg1se.expr,\n-\t\t\t\t      null_pointer_node);\n+\t      not_null_expr = fold_build2 (NE_EXPR, boolean_type_node,\n+\t\t\t\t\t   arg1se.expr, null_pointer_node);\n \n \t      /* Finally, the generated test must check that both arg1 is not\n \t\t NULL and that it is equal to the second arg.  */\n-\t      se->expr = build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t not_null_expr, eq_expr);\n+\t      se->expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t      not_null_expr, eq_expr);\n \t    }\n \n \t  return 0;\n@@ -3418,7 +3420,8 @@ gfc_trans_structure_assign (tree dest, gfc_expr * expr)\n \t}\n       \n       field = cm->backend_decl;\n-      tmp = build3 (COMPONENT_REF, TREE_TYPE (field), dest, field, NULL_TREE);\n+      tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t dest, field, NULL_TREE);\n       tmp = gfc_trans_subcomponent_assign (tmp, cm, c->expr);\n       gfc_add_expr_to_block (&block, tmp);\n     }"}, {"sha": "6591b97a316a6b465ef78b285684d271f7c23af5", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 111, "deletions": 103, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=44855d8c09f755264f7fd7f86a343413e2edcd44", "patch": "@@ -1,5 +1,5 @@\n /* Intrinsic translation\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n    and Steven Bosscher <s.bosscher@student.tudelft.nl>\n@@ -274,7 +274,7 @@ gfc_conv_intrinsic_conversion (gfc_se * se, gfc_expr * expr)\n       tree artype;\n \n       artype = TREE_TYPE (TREE_TYPE (args[0]));\n-      args[0] = build1 (REALPART_EXPR, artype, args[0]);\n+      args[0] = fold_build1 (REALPART_EXPR, artype, args[0]);\n     }\n \n   se->expr = convert (type, args[0]);\n@@ -300,11 +300,11 @@ build_fixbound_expr (stmtblock_t * pblock, tree arg, tree type, int up)\n   intval = gfc_evaluate_now (intval, pblock);\n \n   tmp = convert (argtype, intval);\n-  cond = build2 (up ? GE_EXPR : LE_EXPR, boolean_type_node, tmp, arg);\n+  cond = fold_build2 (up ? GE_EXPR : LE_EXPR, boolean_type_node, tmp, arg);\n \n-  tmp = build2 (up ? PLUS_EXPR : MINUS_EXPR, type, intval,\n-\t\tbuild_int_cst (type, 1));\n-  tmp = build3 (COND_EXPR, type, cond, intval, tmp);\n+  tmp = fold_build2 (up ? PLUS_EXPR : MINUS_EXPR, type, intval,\n+\t\t     build_int_cst (type, 1));\n+  tmp = fold_build3 (COND_EXPR, type, cond, intval, tmp);\n   return tmp;\n }\n \n@@ -370,7 +370,7 @@ build_fix_expr (stmtblock_t * pblock, tree arg, tree type,\n       break;\n \n     case RND_TRUNC:\n-      return build1 (FIX_TRUNC_EXPR, type, arg);\n+      return fold_build1 (FIX_TRUNC_EXPR, type, arg);\n       break;\n \n     default:\n@@ -470,17 +470,17 @@ gfc_conv_intrinsic_aint (gfc_se * se, gfc_expr * expr, enum rounding_mode op)\n   n = gfc_validate_kind (BT_INTEGER, kind, false);\n   mpfr_set_z (huge, gfc_integer_kinds[n].huge, GFC_RND_MODE);\n   tmp = gfc_conv_mpfr_to_tree (huge, kind);\n-  cond = build2 (LT_EXPR, boolean_type_node, arg[0], tmp);\n+  cond = fold_build2 (LT_EXPR, boolean_type_node, arg[0], tmp);\n \n   mpfr_neg (huge, huge, GFC_RND_MODE);\n   tmp = gfc_conv_mpfr_to_tree (huge, kind);\n-  tmp = build2 (GT_EXPR, boolean_type_node, arg[0], tmp);\n-  cond = build2 (TRUTH_AND_EXPR, boolean_type_node, cond, tmp);\n+  tmp = fold_build2 (GT_EXPR, boolean_type_node, arg[0], tmp);\n+  cond = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, cond, tmp);\n   itype = gfc_get_int_type (kind);\n \n   tmp = build_fix_expr (&se->pre, arg[0], itype, op);\n   tmp = convert (type, tmp);\n-  se->expr = build3 (COND_EXPR, type, cond, tmp, arg[0]);\n+  se->expr = fold_build3 (COND_EXPR, type, cond, tmp, arg[0]);\n   mpfr_clear (huge);\n }\n \n@@ -518,7 +518,7 @@ gfc_conv_intrinsic_int (gfc_se * se, gfc_expr * expr, enum rounding_mode op)\n \t  tree artype;\n \n \t  artype = TREE_TYPE (TREE_TYPE (args[0]));\n-\t  args[0] = build1 (REALPART_EXPR, artype, args[0]);\n+\t  args[0] = fold_build1 (REALPART_EXPR, artype, args[0]);\n \t}\n \n       se->expr = build_fix_expr (&se->pre, args[0], type, op);\n@@ -534,7 +534,7 @@ gfc_conv_intrinsic_imagpart (gfc_se * se, gfc_expr * expr)\n   tree arg;\n \n   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n-  se->expr = build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg);\n+  se->expr = fold_build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg);\n }\n \n \n@@ -546,7 +546,7 @@ gfc_conv_intrinsic_conjg (gfc_se * se, gfc_expr * expr)\n   tree arg;\n \n   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n-  se->expr = build1 (CONJ_EXPR, TREE_TYPE (arg), arg);\n+  se->expr = fold_build1 (CONJ_EXPR, TREE_TYPE (arg), arg);\n }\n \n \n@@ -971,7 +971,7 @@ gfc_conv_intrinsic_abs (gfc_se * se, gfc_expr * expr)\n     {\n     case BT_INTEGER:\n     case BT_REAL:\n-      se->expr = build1 (ABS_EXPR, TREE_TYPE (arg), arg);\n+      se->expr = fold_build1 (ABS_EXPR, TREE_TYPE (arg), arg);\n       break;\n \n     case BT_COMPLEX:\n@@ -1020,7 +1020,8 @@ gfc_conv_intrinsic_cmplx (gfc_se * se, gfc_expr * expr, int both)\n     imag = convert (TREE_TYPE (type), args[1]);\n   else if (TREE_CODE (TREE_TYPE (args[0])) == COMPLEX_TYPE)\n     {\n-      imag = build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (args[0])), args[0]);\n+      imag = fold_build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (args[0])),\n+\t\t\t  args[0]);\n       imag = convert (TREE_TYPE (type), imag);\n     }\n   else\n@@ -1054,9 +1055,9 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n       type = TREE_TYPE (args[0]);\n \n       if (modulo)\n-       se->expr = build2 (FLOOR_MOD_EXPR, type, args[0], args[1]);\n+       se->expr = fold_build2 (FLOOR_MOD_EXPR, type, args[0], args[1]);\n       else\n-       se->expr = build2 (TRUNC_MOD_EXPR, type, args[0], args[1]);\n+       se->expr = fold_build2 (TRUNC_MOD_EXPR, type, args[0], args[1]);\n       break;\n \n     case BT_REAL:\n@@ -1107,20 +1108,21 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n \t{\n \t  tree zero = gfc_build_const (type, integer_zero_node);\n \t  tmp = gfc_evaluate_now (se->expr, &se->pre);\n-\t  test = build2 (LT_EXPR, boolean_type_node, args[0], zero);\n-\t  test2 = build2 (LT_EXPR, boolean_type_node, args[1], zero);\n-\t  test2 = build2 (TRUTH_XOR_EXPR, boolean_type_node, test, test2);\n-\t  test = build2 (NE_EXPR, boolean_type_node, tmp, zero);\n-\t  test = build2 (TRUTH_AND_EXPR, boolean_type_node, test, test2);\n+\t  test = fold_build2 (LT_EXPR, boolean_type_node, args[0], zero);\n+\t  test2 = fold_build2 (LT_EXPR, boolean_type_node, args[1], zero);\n+\t  test2 = fold_build2 (TRUTH_XOR_EXPR, boolean_type_node, test, test2);\n+\t  test = fold_build2 (NE_EXPR, boolean_type_node, tmp, zero);\n+\t  test = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, test, test2);\n \t  test = gfc_evaluate_now (test, &se->pre);\n-\t  se->expr = build3 (COND_EXPR, type, test,\n-\t\t\t     build2 (PLUS_EXPR, type, tmp, args[1]), tmp);\n+\t  se->expr = fold_build3 (COND_EXPR, type, test,\n+\t\t\t\t  fold_build2 (PLUS_EXPR, type, tmp, args[1]),\n+\t\t\t\t  tmp);\n \t  return;\n \t}\n \n       /* If we do not have a built_in fmod, the calculation is going to\n \t have to be done longhand.  */\n-      tmp = build2 (RDIV_EXPR, type, args[0], args[1]);\n+      tmp = fold_build2 (RDIV_EXPR, type, args[0], args[1]);\n \n       /* Test if the value is too large to handle sensibly.  */\n       gfc_set_model_kind (expr->ts.kind);\n@@ -1134,22 +1136,22 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n \t}\n       mpfr_set_z (huge, gfc_integer_kinds[n].huge, GFC_RND_MODE);\n       test = gfc_conv_mpfr_to_tree (huge, expr->ts.kind);\n-      test2 = build2 (LT_EXPR, boolean_type_node, tmp, test);\n+      test2 = fold_build2 (LT_EXPR, boolean_type_node, tmp, test);\n \n       mpfr_neg (huge, huge, GFC_RND_MODE);\n       test = gfc_conv_mpfr_to_tree (huge, expr->ts.kind);\n-      test = build2 (GT_EXPR, boolean_type_node, tmp, test);\n-      test2 = build2 (TRUTH_AND_EXPR, boolean_type_node, test, test2);\n+      test = fold_build2 (GT_EXPR, boolean_type_node, tmp, test);\n+      test2 = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, test, test2);\n \n       itype = gfc_get_int_type (ikind);\n       if (modulo)\n        tmp = build_fix_expr (&se->pre, tmp, itype, RND_FLOOR);\n       else\n        tmp = build_fix_expr (&se->pre, tmp, itype, RND_TRUNC);\n       tmp = convert (type, tmp);\n-      tmp = build3 (COND_EXPR, type, test2, tmp, args[0]);\n-      tmp = build2 (MULT_EXPR, type, tmp, args[1]);\n-      se->expr = build2 (MINUS_EXPR, type, args[0], tmp);\n+      tmp = fold_build3 (COND_EXPR, type, test2, tmp, args[0]);\n+      tmp = fold_build2 (MULT_EXPR, type, tmp, args[1]);\n+      se->expr = fold_build2 (MINUS_EXPR, type, args[0], tmp);\n       mpfr_clear (huge);\n       break;\n \n@@ -1172,12 +1174,12 @@ gfc_conv_intrinsic_dim (gfc_se * se, gfc_expr * expr)\n   gfc_conv_intrinsic_function_args (se, expr, args, 2);\n   type = TREE_TYPE (args[0]);\n \n-  val = build2 (MINUS_EXPR, type, args[0], args[1]);\n+  val = fold_build2 (MINUS_EXPR, type, args[0], args[1]);\n   val = gfc_evaluate_now (val, &se->pre);\n \n   zero = gfc_build_const (type, integer_zero_node);\n-  tmp = build2 (LE_EXPR, boolean_type_node, val, zero);\n-  se->expr = build3 (COND_EXPR, type, tmp, zero, val);\n+  tmp = fold_build2 (LE_EXPR, boolean_type_node, val, zero);\n+  se->expr = fold_build3 (COND_EXPR, type, tmp, zero, val);\n }\n \n \n@@ -1266,7 +1268,7 @@ gfc_conv_intrinsic_dprod (gfc_se * se, gfc_expr * expr)\n   type = gfc_typenode_for_spec (&expr->ts);\n   args[0] = convert (type, args[0]);\n   args[1] = convert (type, args[1]);\n-  se->expr = build2 (MULT_EXPR, type, args[0], args[1]);\n+  se->expr = fold_build2 (MULT_EXPR, type, args[0], args[1]);\n }\n \n \n@@ -1323,8 +1325,8 @@ gfc_conv_intrinsic_ctime (gfc_se * se, gfc_expr * expr)\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n-  cond = build2 (GT_EXPR, boolean_type_node, len,\n-\t\t build_int_cst (TREE_TYPE (len), 0));\n+  cond = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t      len, build_int_cst (TREE_TYPE (len), 0));\n   tmp = gfc_call_free (var);\n   tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n   gfc_add_expr_to_block (&se->post, tmp);\n@@ -1364,8 +1366,8 @@ gfc_conv_intrinsic_fdate (gfc_se * se, gfc_expr * expr)\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n-  cond = build2 (GT_EXPR, boolean_type_node, len,\n-\t\t build_int_cst (TREE_TYPE (len), 0));\n+  cond = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t      len, build_int_cst (TREE_TYPE (len), 0));\n   tmp = gfc_call_free (var);\n   tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n   gfc_add_expr_to_block (&se->post, tmp);\n@@ -1407,8 +1409,8 @@ gfc_conv_intrinsic_ttynam (gfc_se * se, gfc_expr * expr)\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n-  cond = build2 (GT_EXPR, boolean_type_node, len,\n-\t\t build_int_cst (TREE_TYPE (len), 0));\n+  cond = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t      len, build_int_cst (TREE_TYPE (len), 0));\n   tmp = gfc_call_free (var);\n   tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n   gfc_add_expr_to_block (&se->post, tmp);\n@@ -1470,8 +1472,9 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, int op)\n       if (argexpr->expr->expr_type == EXPR_VARIABLE\n \t  && argexpr->expr->symtree->n.sym->attr.optional\n \t  && TREE_CODE (val) == INDIRECT_REF)\n-\tcond = build2 (NE_EXPR, boolean_type_node, TREE_OPERAND (val, 0),\n-\t\t       build_int_cst (TREE_TYPE (TREE_OPERAND (val, 0)), 0));\n+\tcond = fold_build2\n+\t         (NE_EXPR, boolean_type_node, TREE_OPERAND (val, 0),\n+\t\t  build_int_cst (TREE_TYPE (TREE_OPERAND (val, 0)), 0));\n       else\n       {\n \tcond = NULL_TREE;\n@@ -1483,7 +1486,7 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, int op)\n \n       thencase = build2_v (MODIFY_EXPR, mvar, convert (type, val));\n \n-      tmp = build2 (op, boolean_type_node, convert (type, val), mvar);\n+      tmp = fold_build2 (op, boolean_type_node, convert (type, val), mvar);\n \n       /* FIXME: When the IEEE_ARITHMETIC module is implemented, the call to\n \t __builtin_isnan might be made dependent on that module being loaded,\n@@ -1534,8 +1537,8 @@ gfc_conv_intrinsic_minmax_char (gfc_se * se, gfc_expr * expr, int op)\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n-  cond = build2 (GT_EXPR, boolean_type_node, len,\n-\t\t build_int_cst (TREE_TYPE (len), 0));\n+  cond = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t      len, build_int_cst (TREE_TYPE (len), 0));\n   tmp = gfc_call_free (var);\n   tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n   gfc_add_expr_to_block (&se->post, tmp);\n@@ -1792,8 +1795,8 @@ gfc_conv_intrinsic_count (gfc_se * se, gfc_expr * expr)\n   /* Generate the loop body.  */\n   gfc_start_scalarized_body (&loop, &body);\n \n-  tmp = build2 (PLUS_EXPR, TREE_TYPE (resvar), resvar,\n-\t\tbuild_int_cst (TREE_TYPE (resvar), 1));\n+  tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (resvar),\n+\t\t     resvar, build_int_cst (TREE_TYPE (resvar), 1));\n   tmp = build2_v (MODIFY_EXPR, resvar, tmp);\n \n   gfc_init_se (&arrayse, NULL);\n@@ -1903,7 +1906,7 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, int op)\n   gfc_conv_expr_val (&arrayse, arrayexpr);\n   gfc_add_block_to_block (&block, &arrayse.pre);\n \n-  tmp = build2 (op, type, resvar, arrayse.expr);\n+  tmp = fold_build2 (op, type, resvar, arrayse.expr);\n   gfc_add_modify_expr (&block, resvar, tmp);\n   gfc_add_block_to_block (&block, &arrayse.post);\n \n@@ -2007,7 +2010,7 @@ gfc_conv_intrinsic_dot_product (gfc_se * se, gfc_expr * expr)\n   arrayse1.ss = arrayss1;\n   gfc_conv_expr_val (&arrayse1, arrayexpr1);\n   if (expr->ts.type == BT_COMPLEX)\n-    arrayse1.expr = build1 (CONJ_EXPR, type, arrayse1.expr);\n+    arrayse1.expr = fold_build1 (CONJ_EXPR, type, arrayse1.expr);\n   gfc_add_block_to_block (&block, &arrayse1.pre);\n \n   /* Make the tree expression for array2.  */\n@@ -2020,13 +2023,13 @@ gfc_conv_intrinsic_dot_product (gfc_se * se, gfc_expr * expr)\n   /* Do the actual product and sum.  */\n   if (expr->ts.type == BT_LOGICAL)\n     {\n-      tmp = build2 (TRUTH_AND_EXPR, type, arrayse1.expr, arrayse2.expr);\n-      tmp = build2 (TRUTH_OR_EXPR, type, resvar, tmp);\n+      tmp = fold_build2 (TRUTH_AND_EXPR, type, arrayse1.expr, arrayse2.expr);\n+      tmp = fold_build2 (TRUTH_OR_EXPR, type, resvar, tmp);\n     }\n   else\n     {\n-      tmp = build2 (MULT_EXPR, type, arrayse1.expr, arrayse2.expr);\n-      tmp = build2 (PLUS_EXPR, type, resvar, tmp);\n+      tmp = fold_build2 (MULT_EXPR, type, arrayse1.expr, arrayse2.expr);\n+      tmp = fold_build2 (PLUS_EXPR, type, resvar, tmp);\n     }\n   gfc_add_modify_expr (&block, resvar, tmp);\n \n@@ -2121,8 +2124,8 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n   gfc_add_modify_expr (&se->pre, limit, tmp);\n \n   if (op == GT_EXPR && expr->ts.type == BT_INTEGER)\n-    tmp = build2 (MINUS_EXPR, TREE_TYPE (tmp), tmp,\n-\t\t  build_int_cst (type, 1));\n+    tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (tmp), tmp,\n+\t\t       build_int_cst (type, 1));\n \n   /* Initialize the scalarizer.  */\n   gfc_init_loopinfo (&loop);\n@@ -2183,19 +2186,22 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n \t\t\t gfc_index_one_node, loop.from[0]);\n   gfc_add_modify_expr (&block, offset, tmp);\n \n-  tmp = build2 (PLUS_EXPR, TREE_TYPE (pos),\n-\t\tloop.loopvar[0], offset);\n+  tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (pos),\n+\t\t     loop.loopvar[0], offset);\n   gfc_add_modify_expr (&ifblock, pos, tmp);\n \n   ifbody = gfc_finish_block (&ifblock);\n \n   /* If it is a more extreme value or pos is still zero and the value\n      equal to the limit.  */\n-  tmp = build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\tbuild2 (EQ_EXPR, boolean_type_node, pos, gfc_index_zero_node),\n-\t\tbuild2 (EQ_EXPR, boolean_type_node, arrayse.expr, limit));\n-  tmp = build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\tbuild2 (op, boolean_type_node, arrayse.expr, limit), tmp);\n+  tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t     fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\t  pos, gfc_index_zero_node),\n+\t\t     fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\t  arrayse.expr, limit));\n+  tmp = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t     fold_build2 (op, boolean_type_node,\n+\t\t\t\t  arrayse.expr, limit), tmp);\n   tmp = build3_v (COND_EXPR, tmp, ifbody, build_empty_stmt ());\n   gfc_add_expr_to_block (&block, tmp);\n \n@@ -2294,8 +2300,8 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, int op)\n     tmp = fold_build1 (NEGATE_EXPR, TREE_TYPE (tmp), tmp);\n \n   if (op == GT_EXPR && expr->ts.type == BT_INTEGER)\n-    tmp = build2 (MINUS_EXPR, TREE_TYPE (tmp), tmp,\n-\t\t  build_int_cst (type, 1));\n+    tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (tmp),\n+\t\t       tmp, build_int_cst (type, 1));\n \n   gfc_add_modify_expr (&se->pre, limit, tmp);\n \n@@ -2357,7 +2363,7 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, int op)\n   ifbody = build2_v (MODIFY_EXPR, limit, arrayse.expr);\n \n   /* If it is a more extreme value.  */\n-  tmp = build2 (op, boolean_type_node, arrayse.expr, limit);\n+  tmp = fold_build2 (op, boolean_type_node, arrayse.expr, limit);\n   tmp = build3_v (COND_EXPR, tmp, ifbody, build_empty_stmt ());\n   gfc_add_expr_to_block (&block, tmp);\n   gfc_add_block_to_block (&block, &arrayse.post);\n@@ -2406,8 +2412,8 @@ gfc_conv_intrinsic_btest (gfc_se * se, gfc_expr * expr)\n   gfc_conv_intrinsic_function_args (se, expr, args, 2);\n   type = TREE_TYPE (args[0]);\n \n-  tmp = build2 (LSHIFT_EXPR, type, build_int_cst (type, 1), args[1]);\n-  tmp = build2 (BIT_AND_EXPR, type, args[0], tmp);\n+  tmp = fold_build2 (LSHIFT_EXPR, type, build_int_cst (type, 1), args[1]);\n+  tmp = fold_build2 (BIT_AND_EXPR, type, args[0], tmp);\n   tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp,\n \t\t     build_int_cst (type, 0));\n   type = gfc_typenode_for_spec (&expr->ts);\n@@ -2431,7 +2437,7 @@ gfc_conv_intrinsic_not (gfc_se * se, gfc_expr * expr)\n   tree arg;\n \n   gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n-  se->expr = build1 (BIT_NOT_EXPR, TREE_TYPE (arg), arg);\n+  se->expr = fold_build1 (BIT_NOT_EXPR, TREE_TYPE (arg), arg);\n }\n \n /* Set or clear a single bit.  */\n@@ -2471,10 +2477,10 @@ gfc_conv_intrinsic_ibits (gfc_se * se, gfc_expr * expr)\n   type = TREE_TYPE (args[0]);\n \n   mask = build_int_cst (type, -1);\n-  mask = build2 (LSHIFT_EXPR, type, mask, args[2]);\n-  mask = build1 (BIT_NOT_EXPR, type, mask);\n+  mask = fold_build2 (LSHIFT_EXPR, type, mask, args[2]);\n+  mask = fold_build1 (BIT_NOT_EXPR, type, mask);\n \n-  tmp = build2 (RSHIFT_EXPR, type, args[0], args[1]);\n+  tmp = fold_build2 (RSHIFT_EXPR, type, args[0], args[1]);\n \n   se->expr = fold_build2 (BIT_AND_EXPR, type, tmp, mask);\n }\n@@ -2523,8 +2529,8 @@ gfc_conv_intrinsic_ishft (gfc_se * se, gfc_expr * expr)\n      The standard doesn't define the case of shifting negative\n      numbers, and we try to be compatible with other compilers, most\n      notably g77, here.  */\n-  rshift = fold_convert (type, build2 (RSHIFT_EXPR, utype, \n-\t\t\t\t       convert (utype, args[0]), width));\n+  rshift = fold_convert (type, fold_build2 (RSHIFT_EXPR, utype, \n+\t\t\t\t\t    convert (utype, args[0]), width));\n \n   tmp = fold_build2 (GE_EXPR, boolean_type_node, args[1],\n \t\t     build_int_cst (TREE_TYPE (args[1]), 0));\n@@ -2740,7 +2746,7 @@ gfc_conv_intrinsic_ichar (gfc_se * se, gfc_expr * expr)\n \n   gfc_conv_intrinsic_function_args (se, expr, args, 2);\n   gcc_assert (POINTER_TYPE_P (TREE_TYPE (args[1])));\n-  args[1] = build1 (NOP_EXPR, pchar_type_node, args[1]);\n+  args[1] = fold_build1 (NOP_EXPR, pchar_type_node, args[1]);\n   type = gfc_typenode_for_spec (&expr->ts);\n \n   se->expr = build_fold_indirect_ref (args[1]);\n@@ -2868,11 +2874,11 @@ gfc_conv_intrinsic_size (gfc_se * se, gfc_expr * expr)\n \t  argse.data_not_needed = 1;\n \t  gfc_conv_expr (&argse, actual->expr);\n \t  gfc_add_block_to_block (&se->pre, &argse.pre);\n-\t  tmp = build2 (NE_EXPR, boolean_type_node, argse.expr,\n-\t\t\tnull_pointer_node);\n+\t  tmp = fold_build2 (NE_EXPR, boolean_type_node,\n+\t\t\t     argse.expr, null_pointer_node);\n \t  tmp = gfc_evaluate_now (tmp, &se->pre);\n-\t  se->expr = build3 (COND_EXPR, pvoid_type_node,\n-\t\t\t     tmp, fncall1, fncall0);\n+\t  se->expr = fold_build3 (COND_EXPR, pvoid_type_node,\n+\t\t\t\t  tmp, fncall1, fncall0);\n \t}\n       else\n \tse->expr = fncall1;\n@@ -3079,7 +3085,7 @@ gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n \t  /* Clean up if it was repacked.  */\n \t  gfc_init_block (&block);\n \t  tmp = gfc_conv_array_data (argse.expr);\n-\t  tmp = build2 (NE_EXPR, boolean_type_node, source, tmp);\n+\t  tmp = fold_build2 (NE_EXPR, boolean_type_node, source, tmp);\n \t  tmp = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n \t  gfc_add_expr_to_block (&block, tmp);\n \t  gfc_add_block_to_block (&block, &se->post);\n@@ -3284,7 +3290,7 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n       moldsize = size_in_bytes (type);\n \n       /* Use memcpy to do the transfer.  */\n-      tmp = build1 (ADDR_EXPR, build_pointer_type (type), tmpdecl);\n+      tmp = fold_build1 (ADDR_EXPR, build_pointer_type (type), tmpdecl);\n       tmp = build_call_expr (built_in_decls[BUILT_IN_MEMCPY], 3,\n \t\t\t     fold_convert (pvoid_type_node, tmp),\n \t\t\t     fold_convert (pvoid_type_node, ptr),\n@@ -3314,8 +3320,8 @@ gfc_conv_allocated (gfc_se *se, gfc_expr *expr)\n   gfc_conv_expr_descriptor (&arg1se, arg1->expr, ss1);\n \n   tmp = gfc_conv_descriptor_data_get (arg1se.expr);\n-  tmp = build2 (NE_EXPR, boolean_type_node, tmp,\n-\t\tfold_convert (TREE_TYPE (tmp), null_pointer_node));\n+  tmp = fold_build2 (NE_EXPR, boolean_type_node,\n+\t\t     tmp, fold_convert (TREE_TYPE (tmp), null_pointer_node));\n   se->expr = convert (gfc_typenode_for_spec (&expr->ts), tmp);\n }\n \n@@ -3363,8 +3369,8 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n         }\n       gfc_add_block_to_block (&se->pre, &arg1se.pre);\n       gfc_add_block_to_block (&se->post, &arg1se.post);\n-      tmp = build2 (NE_EXPR, boolean_type_node, tmp2,\n-\t\t    fold_convert (TREE_TYPE (tmp2), null_pointer_node));\n+      tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp2,\n+\t\t\t fold_convert (TREE_TYPE (tmp2), null_pointer_node));\n       se->expr = tmp;\n     }\n   else\n@@ -3374,9 +3380,9 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n \n       nonzero_charlen = NULL_TREE;\n       if (arg1->expr->ts.type == BT_CHARACTER)\n-\tnonzero_charlen = build2 (NE_EXPR, boolean_type_node,\n-\t\t\t\t  arg1->expr->ts.cl->backend_decl,\n-\t\t\t\t  integer_zero_node);\n+\tnonzero_charlen = fold_build2 (NE_EXPR, boolean_type_node,\n+\t\t\t\t       arg1->expr->ts.cl->backend_decl,\n+\t\t\t\t       integer_zero_node);\n \n       if (ss1 == gfc_ss_terminator)\n         {\n@@ -3388,10 +3394,12 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n           gfc_conv_expr (&arg2se, arg2->expr);\n \t  gfc_add_block_to_block (&se->pre, &arg1se.pre);\n \t  gfc_add_block_to_block (&se->post, &arg1se.post);\n-          tmp = build2 (EQ_EXPR, boolean_type_node, arg1se.expr, arg2se.expr);\n-          tmp2 = build2 (NE_EXPR, boolean_type_node, arg1se.expr,\n-                         null_pointer_node);\n-          se->expr = build2 (TRUTH_AND_EXPR, boolean_type_node, tmp, tmp2);\n+          tmp = fold_build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t     arg1se.expr, arg2se.expr);\n+          tmp2 = fold_build2 (NE_EXPR, boolean_type_node,\n+\t\t\t      arg1se.expr, null_pointer_node);\n+          se->expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t  tmp, tmp2);\n         }\n       else\n         {\n@@ -3401,8 +3409,8 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n \t  gfc_conv_expr_lhs (&arg1se, arg1->expr);\n \t  tmp = gfc_conv_descriptor_stride (arg1se.expr,\n \t\t\t\t\t    gfc_rank_cst[arg1->expr->rank - 1]);\n-\t  nonzero_arraylen = build2 (NE_EXPR, boolean_type_node,\n-\t\t\t\t     tmp, build_int_cst (TREE_TYPE (tmp), 0));\n+\t  nonzero_arraylen = fold_build2 (NE_EXPR, boolean_type_node, tmp,\n+\t\t\t\t\t  build_int_cst (TREE_TYPE (tmp), 0));\n \n           /* A pointer to an array, call library function _gfor_associated.  */\n           gcc_assert (ss2 != gfc_ss_terminator);\n@@ -3416,15 +3424,15 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n           se->expr = build_call_expr (gfor_fndecl_associated, 2,\n \t\t\t\t      arg1se.expr, arg2se.expr);\n \t  se->expr = convert (boolean_type_node, se->expr);\n-\t  se->expr = build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t     se->expr, nonzero_arraylen);\n+\t  se->expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t  se->expr, nonzero_arraylen);\n         }\n \n       /* If target is present zero character length pointers cannot\n \t be associated.  */\n       if (nonzero_charlen != NULL_TREE)\n-\tse->expr = build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t   se->expr, nonzero_charlen);\n+\tse->expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\tse->expr, nonzero_charlen);\n     }\n \n   se->expr = convert (gfc_typenode_for_spec (&expr->ts), se->expr);\n@@ -3527,8 +3535,8 @@ gfc_conv_intrinsic_trim (gfc_se * se, gfc_expr * expr)\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n-  cond = build2 (GT_EXPR, boolean_type_node, len,\n-\t\t build_int_cst (TREE_TYPE (len), 0));\n+  cond = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t      len, build_int_cst (TREE_TYPE (len), 0));\n   tmp = gfc_call_free (var);\n   tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n   gfc_add_expr_to_block (&se->post, tmp);\n@@ -3632,8 +3640,8 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Increment count.  */\n-  tmp = build2 (PLUS_EXPR, ncopies_type, count,\n-\t\tbuild_int_cst (TREE_TYPE (count), 1));\n+  tmp = fold_build2 (PLUS_EXPR, ncopies_type,\n+\t\t     count, build_int_cst (TREE_TYPE (count), 1));\n   gfc_add_modify_expr (&body, count, tmp);\n \n   /* Build the loop.  */"}, {"sha": "c3124f3923a28a8a5ca89972e3c7cca6fa293b32", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=44855d8c09f755264f7fd7f86a343413e2edcd44", "patch": "@@ -1,5 +1,5 @@\n /* IO Code translation/library interface\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Free Software\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software\n    Foundation, Inc.\n    Contributed by Paul Brook\n \n@@ -429,10 +429,10 @@ set_parameter_const (stmtblock_t *block, tree var, enum iofield type,\n   gfc_st_parameter_field *p = &st_parameter_field[type];\n \n   if (p->param_type == IOPARM_ptype_common)\n-    var = build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n-\t\t  var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n-  tmp = build3 (COMPONENT_REF, TREE_TYPE (p->field), var, p->field,\n-\t\tNULL_TREE);\n+    var = fold_build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n+\t\t       var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n+  tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (p->field), var, p->field,\n+\t\t     NULL_TREE);\n   gfc_add_modify_expr (block, tmp, build_int_cst (TREE_TYPE (p->field), val));\n   return p->mask;\n }\n@@ -484,10 +484,10 @@ set_parameter_value (stmtblock_t *block, tree var, enum iofield type,\n   gfc_add_block_to_block (block, &se.pre);\n \n   if (p->param_type == IOPARM_ptype_common)\n-    var = build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n-\t\t  var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n+    var = fold_build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n+\t\t       var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n \n-  tmp = build3 (COMPONENT_REF, dest_type, var, p->field, NULL_TREE);\n+  tmp = fold_build3 (COMPONENT_REF, dest_type, var, p->field, NULL_TREE);\n   gfc_add_modify_expr (block, tmp, se.expr);\n   return p->mask;\n }\n@@ -542,10 +542,10 @@ set_parameter_ref (stmtblock_t *block, stmtblock_t *postblock,\n      }\n \n   if (p->param_type == IOPARM_ptype_common)\n-    var = build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n-\t\t  var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n-  tmp = build3 (COMPONENT_REF, TREE_TYPE (p->field), var, p->field,\n-\t\tNULL_TREE);\n+    var = fold_build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n+\t\t       var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n+  tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (p->field),\n+\t\t     var, p->field, NULL_TREE);\n   gfc_add_modify_expr (block, tmp, addr);\n   return p->mask;\n }\n@@ -631,12 +631,12 @@ set_string (stmtblock_t * block, stmtblock_t * postblock, tree var,\n   gfc_init_se (&se, NULL);\n \n   if (p->param_type == IOPARM_ptype_common)\n-    var = build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n-\t\t  var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n-  io = build3 (COMPONENT_REF, TREE_TYPE (p->field), var, p->field,\n-\t       NULL_TREE);\n-  len = build3 (COMPONENT_REF, TREE_TYPE (p->field_len), var, p->field_len,\n-\t\tNULL_TREE);\n+    var = fold_build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n+\t\t       var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n+  io = fold_build3 (COMPONENT_REF, TREE_TYPE (p->field),\n+\t\t    var, p->field, NULL_TREE);\n+  len = fold_build3 (COMPONENT_REF, TREE_TYPE (p->field_len),\n+\t\t     var, p->field_len, NULL_TREE);\n \n   /* Integer variable assigned a format label.  */\n   if (e->ts.type == BT_INTEGER && e->symtree->n.sym->attr.assign == 1)\n@@ -700,13 +700,13 @@ set_internal_unit (stmtblock_t * block, stmtblock_t * post_block,\n \n   p = &st_parameter_field[IOPARM_dt_internal_unit];\n   mask = p->mask;\n-  io = build3 (COMPONENT_REF, TREE_TYPE (p->field), var, p->field,\n-\t       NULL_TREE);\n-  len = build3 (COMPONENT_REF, TREE_TYPE (p->field_len), var, p->field_len,\n-\t\tNULL_TREE);\n+  io = fold_build3 (COMPONENT_REF, TREE_TYPE (p->field),\n+\t\t    var, p->field, NULL_TREE);\n+  len = fold_build3 (COMPONENT_REF, TREE_TYPE (p->field_len),\n+\t\t     var, p->field_len,\tNULL_TREE);\n   p = &st_parameter_field[IOPARM_dt_internal_unit_desc];\n-  desc = build3 (COMPONENT_REF, TREE_TYPE (p->field), var, p->field,\n-\t\t NULL_TREE);\n+  desc = fold_build3 (COMPONENT_REF, TREE_TYPE (p->field),\n+\t\t      var, p->field, NULL_TREE);\n \n   gcc_assert (e->ts.type == BT_CHARACTER);\n \n@@ -814,12 +814,13 @@ io_result (stmtblock_t * block, tree var, gfc_st_label * err_label,\n \n   tmp = gfc_finish_block (&body);\n \n-  var = build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n-\t\tvar, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n-  rc = build3 (COMPONENT_REF, TREE_TYPE (p->field), var, p->field,\n-\t       NULL_TREE);\n-  rc = build2 (BIT_AND_EXPR, TREE_TYPE (rc), rc,\n-\t       build_int_cst (TREE_TYPE (rc), IOPARM_common_libreturn_mask));\n+  var = fold_build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n+\t\t     var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n+  rc = fold_build3 (COMPONENT_REF, TREE_TYPE (p->field),\n+\t\t    var, p->field, NULL_TREE);\n+  rc = fold_build2 (BIT_AND_EXPR, TREE_TYPE (rc),\n+\t\t    rc, build_int_cst (TREE_TYPE (rc),\n+\t\t\t\t       IOPARM_common_libreturn_mask));\n \n   tmp = build3_v (SWITCH_EXPR, rc, tmp, NULL_TREE);\n \n@@ -838,10 +839,11 @@ set_error_locus (stmtblock_t * block, tree var, locus * where)\n   int line;\n   gfc_st_parameter_field *p = &st_parameter_field[IOPARM_common_filename];\n \n-  locus_file = build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n-\t\t       var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n-  locus_file = build3 (COMPONENT_REF, TREE_TYPE (p->field), locus_file,\n-\t\t       p->field, NULL_TREE);\n+  locus_file = fold_build3 (COMPONENT_REF,\n+\t\t\t    st_parameter[IOPARM_ptype_common].type,\n+\t\t\t    var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n+  locus_file = fold_build3 (COMPONENT_REF, TREE_TYPE (p->field),\n+\t\t\t    locus_file, p->field, NULL_TREE);\n   f = where->lb->file;\n   str = gfc_build_cstring_const (f->filename);\n \n@@ -1357,8 +1359,8 @@ nml_get_addr_expr (gfc_symbol * sym, gfc_component * c,\n      the derived type.  */\n \n   if (TREE_CODE (decl) == FIELD_DECL)\n-    tmp = build3 (COMPONENT_REF, TREE_TYPE (tmp),\n-\t\t  base_addr, tmp, NULL_TREE);\n+    tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (tmp),\n+\t\t       base_addr, tmp, NULL_TREE);\n \n   /* If we have a derived type component, a reference to the first\n      element of the array is built.  This is done so that base_addr,\n@@ -1908,8 +1910,8 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr, gfc_code * code)\n \t  field = c->backend_decl;\n \t  gcc_assert (field && TREE_CODE (field) == FIELD_DECL);\n \n-\t  tmp = build3 (COMPONENT_REF, TREE_TYPE (field), expr, field,\n-\t\t\tNULL_TREE);\n+\t  tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t     expr, field, NULL_TREE);\n \n           if (c->dimension)\n             {"}, {"sha": "d1188a168d431c47f71e2afc894566cb10df5569", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=44855d8c09f755264f7fd7f86a343413e2edcd44", "patch": "@@ -1,5 +1,5 @@\n /* OpenMP directive translation -- generate GCC trees from gfc_code.\n-   Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Jakub Jelinek <jakub@redhat.com>\n \n This file is part of GCC.\n@@ -863,7 +863,7 @@ gfc_trans_omp_atomic (gfc_code *code)\n \n   if (TREE_CODE (TREE_TYPE (rhs)) == COMPLEX_TYPE\n       && TREE_CODE (type) != COMPLEX_TYPE)\n-    x = build1 (REALPART_EXPR, TREE_TYPE (TREE_TYPE (rhs)), x);\n+    x = fold_build1 (REALPART_EXPR, TREE_TYPE (TREE_TYPE (rhs)), x);\n \n   x = build2_v (OMP_ATOMIC, lhsaddr, convert (type, x));\n   gfc_add_expr_to_block (&block, x);\n@@ -961,8 +961,8 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n   if (simple)\n     {\n       init = build2_v (GIMPLE_MODIFY_STMT, dovar, from);\n-      cond = build2 (simple > 0 ? LE_EXPR : GE_EXPR, boolean_type_node,\n-\t\t     dovar, to);\n+      cond = fold_build2 (simple > 0 ? LE_EXPR : GE_EXPR, boolean_type_node,\n+\t\t\t  dovar, to);\n       incr = fold_build2 (PLUS_EXPR, type, dovar, step);\n       incr = fold_build2 (GIMPLE_MODIFY_STMT, type, dovar, incr);\n       if (pblock != &block)\n@@ -987,7 +987,7 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n       tmp = gfc_evaluate_now (tmp, pblock);\n       count = gfc_create_var (type, \"count\");\n       init = build2_v (GIMPLE_MODIFY_STMT, count, build_int_cst (type, 0));\n-      cond = build2 (LT_EXPR, boolean_type_node, count, tmp);\n+      cond = fold_build2 (LT_EXPR, boolean_type_node, count, tmp);\n       incr = fold_build2 (PLUS_EXPR, type, count, build_int_cst (type, 1));\n       incr = fold_build2 (GIMPLE_MODIFY_STMT, type, count, incr);\n \n@@ -1000,7 +1000,7 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n \n       /* Initialize DOVAR.  */\n       tmp = fold_build2 (MULT_EXPR, type, count, step);\n-      tmp = build2 (PLUS_EXPR, type, from, tmp);\n+      tmp = fold_build2 (PLUS_EXPR, type, from, tmp);\n       gfc_add_modify_stmt (&body, dovar, tmp);\n     }\n "}, {"sha": "e3f4cd456e81fc164efce40b95780c371c0bd63a", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=44855d8c09f755264f7fd7f86a343413e2edcd44", "patch": "@@ -1,5 +1,5 @@\n /* Statement translation -- generate GCC trees from gfc_code.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n    and Steven Bosscher <s.bosscher@student.tudelft.nl>\n@@ -161,7 +161,7 @@ gfc_trans_goto (gfc_code * code)\n   code = code->block;\n   if (code == NULL)\n     {\n-      target = build1 (GOTO_EXPR, void_type_node, assigned_goto);\n+      target = fold_build1 (GOTO_EXPR, void_type_node, assigned_goto);\n       gfc_add_expr_to_block (&se.pre, target);\n       return gfc_finish_block (&se.pre);\n     }\n@@ -171,9 +171,9 @@ gfc_trans_goto (gfc_code * code)\n     {\n       target = gfc_get_label_decl (code->label);\n       tmp = gfc_build_addr_expr (pvoid_type_node, target);\n-      tmp = build2 (EQ_EXPR, boolean_type_node, tmp, assigned_goto);\n+      tmp = fold_build2 (EQ_EXPR, boolean_type_node, tmp, assigned_goto);\n       tmp = build3_v (COND_EXPR, tmp,\n-\t\t      build1 (GOTO_EXPR, void_type_node, target),\n+\t\t      fold_build1 (GOTO_EXPR, void_type_node, target),\n \t\t      build_empty_stmt ());\n       gfc_add_expr_to_block (&se.pre, tmp);\n       code = code->block;\n@@ -444,8 +444,8 @@ gfc_trans_return (gfc_code * code ATTRIBUTE_UNUSED)\n \n       gfc_conv_expr (&se, code->expr);\n \n-      tmp = build2 (MODIFY_EXPR, TREE_TYPE (result), result,\n-\t\t    fold_convert (TREE_TYPE (result), se.expr));\n+      tmp = fold_build2 (MODIFY_EXPR, TREE_TYPE (result), result,\n+\t\t\t fold_convert (TREE_TYPE (result), se.expr));\n       gfc_add_expr_to_block (&se.pre, tmp);\n \n       tmp = build1_v (GOTO_EXPR, gfc_get_return_label ());\n@@ -946,7 +946,7 @@ gfc_trans_do (gfc_code * code)\n     }\n \n   /* Increment the loop variable.  */\n-  tmp = build2 (PLUS_EXPR, type, dovar, step);\n+  tmp = fold_build2 (PLUS_EXPR, type, dovar, step);\n   gfc_add_modify_expr (&body, dovar, tmp);\n \n   /* End with the loop condition.  Loop until countm1 == 0.  */\n@@ -958,7 +958,7 @@ gfc_trans_do (gfc_code * code)\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Decrement the loop count.  */\n-  tmp = build2 (MINUS_EXPR, utype, countm1, build_int_cst (utype, 1));\n+  tmp = fold_build2 (MINUS_EXPR, utype, countm1, build_int_cst (utype, 1));\n   gfc_add_modify_expr (&body, countm1, tmp);\n \n   /* End of loop body.  */\n@@ -1181,7 +1181,8 @@ gfc_trans_integer_select (gfc_code * code)\n \n \t  /* Add this case label.\n              Add parameter 'label', make it match GCC backend.  */\n-\t  tmp = build3 (CASE_LABEL_EXPR, void_type_node, low, high, label);\n+\t  tmp = fold_build3 (CASE_LABEL_EXPR, void_type_node,\n+\t\t\t     low, high, label);\n \t  gfc_add_expr_to_block (&body, tmp);\n \t}\n \n@@ -1373,9 +1374,9 @@ gfc_trans_character_select (gfc_code *code)\n       for (d = c->ext.case_list; d; d = d->next)\n         {\n \t  label = gfc_build_label_decl (NULL_TREE);\n-\t  tmp = build3 (CASE_LABEL_EXPR, void_type_node,\n-\t\t\tbuild_int_cst (NULL_TREE, d->n),\n-\t\t\tbuild_int_cst (NULL_TREE, d->n), label);\n+\t  tmp = fold_build3 (CASE_LABEL_EXPR, void_type_node,\n+\t\t\t     build_int_cst (NULL_TREE, d->n),\n+\t\t\t     build_int_cst (NULL_TREE, d->n), label);\n           gfc_add_expr_to_block (&body, tmp);\n         }\n \n@@ -1775,22 +1776,22 @@ gfc_trans_forall_loop (forall_info *forall_tmp, tree body,\n       gfc_add_expr_to_block (&block, body);\n \n       /* Increment the loop variable.  */\n-      tmp = build2 (PLUS_EXPR, TREE_TYPE (var), var, step);\n+      tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (var), var, step);\n       gfc_add_modify_expr (&block, var, tmp);\n \n       /* Advance to the next mask element.  Only do this for the\n \t innermost loop.  */\n       if (n == 0 && mask_flag && forall_tmp->mask)\n \t{\n \t  tree maskindex = forall_tmp->maskindex;\n-\t  tmp = build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\tmaskindex, gfc_index_one_node);\n+\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     maskindex, gfc_index_one_node);\n \t  gfc_add_modify_expr (&block, maskindex, tmp);\n \t}\n \n       /* Decrement the loop counter.  */\n-      tmp = build2 (MINUS_EXPR, TREE_TYPE (var), count,\n-\t\t    build_int_cst (TREE_TYPE (var), 1));\n+      tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (var), count,\n+\t\t\t build_int_cst (TREE_TYPE (var), 1));\n       gfc_add_modify_expr (&block, count, tmp);\n \n       body = gfc_finish_block (&block);\n@@ -2241,8 +2242,8 @@ compute_overall_iter_number (forall_info *nested_forall_info, tree inner_size,\n   if (inner_size_body)\n     gfc_add_block_to_block (&body, inner_size_body);\n   if (forall_tmp)\n-    tmp = build2 (PLUS_EXPR, gfc_array_index_type, number,\n-\t\t  inner_size);\n+    tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t       number, inner_size);\n   else\n     tmp = inner_size;\n   gfc_add_modify_expr (&body, number, tmp);\n@@ -2817,8 +2818,8 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n       gfc_add_modify_expr (&body, tmp, se.expr);\n \n       /* Advance to the next mask element.  */\n-      tmp = build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t    maskindex, gfc_index_one_node);\n+      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t maskindex, gfc_index_one_node);\n       gfc_add_modify_expr (&body, maskindex, tmp);\n \n       /* Generate the loops.  */\n@@ -3034,16 +3035,16 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n       tmp1 = gfc_build_array_ref (cmask, count, NULL);\n       tmp = cond;\n       if (mask)\n-\ttmp = build2 (TRUTH_AND_EXPR, mask_type, mtmp, tmp);\n+\ttmp = fold_build2 (TRUTH_AND_EXPR, mask_type, mtmp, tmp);\n       gfc_add_modify_expr (&body1, tmp1, tmp);\n     }\n \n   if (pmask)\n     {\n       tmp1 = gfc_build_array_ref (pmask, count, NULL);\n-      tmp = build1 (TRUTH_NOT_EXPR, mask_type, cond);\n+      tmp = fold_build1 (TRUTH_NOT_EXPR, mask_type, cond);\n       if (mask)\n-\ttmp = build2 (TRUTH_AND_EXPR, mask_type, mtmp, tmp);\n+\ttmp = fold_build2 (TRUTH_AND_EXPR, mask_type, mtmp, tmp);\n       gfc_add_modify_expr (&body1, tmp1, tmp);\n     }\n \n@@ -3815,8 +3816,8 @@ gfc_trans_allocate (gfc_code * code)\n \t    tmp = se.string_length;\n \n \t  tmp = gfc_allocate_with_status (&se.pre, tmp, pstat);\n-\t  tmp = build2 (MODIFY_EXPR, void_type_node, se.expr,\n-\t\t\tfold_convert (TREE_TYPE (se.expr), tmp));\n+\t  tmp = fold_build2 (MODIFY_EXPR, void_type_node, se.expr,\n+\t\t\t     fold_convert (TREE_TYPE (se.expr), tmp));\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n \n \t  if (code->expr)\n@@ -3944,8 +3945,8 @@ gfc_trans_deallocate (gfc_code * code)\n \t  tmp = gfc_deallocate_with_status (se.expr, pstat, false);\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n \n-\t  tmp = build2 (MODIFY_EXPR, void_type_node,\n-\t\t\tse.expr, build_int_cst (TREE_TYPE (se.expr), 0));\n+\t  tmp = fold_build2 (MODIFY_EXPR, void_type_node,\n+\t\t\t     se.expr, build_int_cst (TREE_TYPE (se.expr), 0));\n \t}\n \n       gfc_add_expr_to_block (&se.pre, tmp);\n@@ -3954,7 +3955,7 @@ gfc_trans_deallocate (gfc_code * code)\n \t of the last deallocation to the running total.  */\n       if (code->expr)\n \t{\n-\t  apstat = build2 (PLUS_EXPR, TREE_TYPE (stat), astat, stat);\n+\t  apstat = fold_build2 (PLUS_EXPR, TREE_TYPE (stat), astat, stat);\n \t  gfc_add_modify_expr (&se.pre, astat, apstat);\n \t}\n "}, {"sha": "6964aa93b6688ff31b851619cadcd09841d0e9d6", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44855d8c09f755264f7fd7f86a343413e2edcd44/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=44855d8c09f755264f7fd7f86a343413e2edcd44", "patch": "@@ -1,5 +1,5 @@\n /* Code translation -- generate GCC trees from gfc_code.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007 Free Software\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software\n    Foundation, Inc.\n    Contributed by Paul Brook\n \n@@ -278,8 +278,8 @@ gfc_build_addr_expr (tree type, tree t)\n       tree type_domain = TYPE_DOMAIN (base_type);\n       if (type_domain && TYPE_MIN_VALUE (type_domain))\n         min_val = TYPE_MIN_VALUE (type_domain);\n-      t = build4 (ARRAY_REF, TREE_TYPE (type), t, min_val,\n-\t\t  NULL_TREE, NULL_TREE);\n+      t = fold (build4 (ARRAY_REF, TREE_TYPE (type),\n+\t\t\tt, min_val, NULL_TREE, NULL_TREE));\n       natural_type = type;\n     }\n   else\n@@ -296,7 +296,7 @@ gfc_build_addr_expr (tree type, tree t)\n     {\n       if (DECL_P (t))\n         TREE_ADDRESSABLE (t) = 1;\n-      t = build1 (ADDR_EXPR, natural_type, t);\n+      t = fold_build1 (ADDR_EXPR, natural_type, t);\n     }\n \n   if (type && natural_type != type)\n@@ -414,9 +414,9 @@ gfc_trans_runtime_check (tree cond, stmtblock_t * pblock, locus * where,\n      number of arguments, we can't use build_call_expr directly.  */\n   fntype = TREE_TYPE (gfor_fndecl_runtime_error_at);\n   tmp = fold_builtin_call_array (TREE_TYPE (fntype),\n-\t\t\t\t build1 (ADDR_EXPR,\n-\t\t\t\t\t build_pointer_type (fntype),\n-\t\t\t\t\t gfor_fndecl_runtime_error_at),\n+\t\t\t\t fold_build1 (ADDR_EXPR,\n+\t\t\t\t\t      build_pointer_type (fntype),\n+\t\t\t\t\t      gfor_fndecl_runtime_error_at),\n \t\t\t\t nargs + 2, argarray);\n   gfc_add_expr_to_block (&block, tmp);\n \n@@ -553,7 +553,7 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n   if (status != NULL_TREE && !integer_zerop (status))\n     {\n       tmp = fold_build2 (MODIFY_EXPR, status_type,\n-\t\t\t build1 (INDIRECT_REF, status_type, status),\n+\t\t\t fold_build1 (INDIRECT_REF, status_type, status),\n \t\t\t build_int_cst (status_type, 0));\n       tmp = fold_build3 (COND_EXPR, void_type_node,\n \t\t\t fold_build2 (NE_EXPR, boolean_type_node,\n@@ -575,7 +575,7 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n \n       gfc_start_block (&set_status_block);\n       gfc_add_modify_expr (&set_status_block,\n-\t\t\t   build1 (INDIRECT_REF, status_type, status),\n+\t\t\t   fold_build1 (INDIRECT_REF, status_type, status),\n \t\t\t   build_int_cst (status_type, LIBERROR_ALLOCATION));\n       gfc_add_modify_expr (&set_status_block, res,\n \t\t\t   build_int_cst (pvoid_type_node, 0));\n@@ -606,7 +606,7 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n       cond = fold_build2 (EQ_EXPR, boolean_type_node, status,\n \t\t\t  build_int_cst (status_type, 0));\n       tmp2 = fold_build2 (MODIFY_EXPR, status_type,\n-\t\t\t  build1 (INDIRECT_REF, status_type, status),\n+\t\t\t  fold_build1 (INDIRECT_REF, status_type, status),\n \t\t\t  build_int_cst (status_type, LIBERROR_ALLOCATION));\n       tmp = fold_build3 (COND_EXPR, void_type_node, cond, tmp,\n \t\t\t tmp2);\n@@ -692,7 +692,7 @@ gfc_allocate_array_with_status (stmtblock_t * block, tree mem, tree size,\n       gfc_add_modify_expr (&set_status_block, res, fold_convert (type, tmp));\n \n       gfc_add_modify_expr (&set_status_block,\n-\t\t\t   build1 (INDIRECT_REF, status_type, status),\n+\t\t\t   fold_build1 (INDIRECT_REF, status_type, status),\n \t\t\t   build_int_cst (status_type, LIBERROR_ALLOCATION));\n \n       tmp = fold_build2 (EQ_EXPR, boolean_type_node, status,\n@@ -787,7 +787,7 @@ gfc_deallocate_with_status (tree pointer, tree status, bool can_fail)\n       cond2 = fold_build2 (NE_EXPR, boolean_type_node, status,\n \t\t\t   build_int_cst (TREE_TYPE (status), 0));\n       tmp = fold_build2 (MODIFY_EXPR, status_type,\n-\t\t\t build1 (INDIRECT_REF, status_type, status),\n+\t\t\t fold_build1 (INDIRECT_REF, status_type, status),\n \t\t\t build_int_cst (status_type, 1));\n       error = fold_build3 (COND_EXPR, void_type_node, cond2, tmp, error);\n     }\n@@ -809,7 +809,7 @@ gfc_deallocate_with_status (tree pointer, tree status, bool can_fail)\n       cond2 = fold_build2 (NE_EXPR, boolean_type_node, status,\n \t\t\t   build_int_cst (TREE_TYPE (status), 0));\n       tmp = fold_build2 (MODIFY_EXPR, status_type,\n-\t\t\t build1 (INDIRECT_REF, status_type, status),\n+\t\t\t fold_build1 (INDIRECT_REF, status_type, status),\n \t\t\t build_int_cst (status_type, 0));\n       tmp = fold_build3 (COND_EXPR, void_type_node, cond2, tmp,\n \t\t\t build_empty_stmt ());"}]}