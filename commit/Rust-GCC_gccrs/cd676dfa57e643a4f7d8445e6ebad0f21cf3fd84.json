{"sha": "cd676dfa57e643a4f7d8445e6ebad0f21cf3fd84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q2NzZkZmE1N2U2NDNhNGY3ZDg0NDVlNmViYWQwZjIxY2YzZmQ4NA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-16T12:08:07Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-12-16T12:08:07Z"}, "message": "bswap: Handle vector CONSTRUCTORs [PR96239]\n\nThe following patch teaches the bswap pass to handle for small (2/4/8 byte\nlong) vectors a CONSTRUCTOR by determining if the bytes of the constructor\ncome from non-vector sources and are either nop or bswap and changing the\nCONSTRUCTOR in that case to VIEW_CONVERT_EXPR from scalar integer to\nthe vector type.\n\nUnfortunately, as I found after the patch was written, due to pass ordering\nthis doesn't really fix the original testcase, just the one I wrote,\nbecause both loop and slp vectorization is done only after the bswap pass.\nA possible way out of that would be to perform just this particular bswap\noptimization (i.e. for CONSTRUCTOR assignments with integral vector types\ncall find_bswap_or_nop and bswap_replace if successful) also during the\nstore merging pass, it isn't really a store, but the store merging pass\nalready performs bswapping when handling store, so it wouldn't be that big\nhack.  What do you think?\n\n2020-12-16  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/96239\n\t* gimple-ssa-store-merging.c (find_bswap_or_nop): Handle a vector\n\tCONSTRUCTOR.\n\t(bswap_replace): Likewise.\n\n\t* gcc.dg/pr96239.c: New test.", "tree": {"sha": "3fc863b0210fb4d33afb5f5b16063cb9c4b79386", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fc863b0210fb4d33afb5f5b16063cb9c4b79386"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd676dfa57e643a4f7d8445e6ebad0f21cf3fd84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd676dfa57e643a4f7d8445e6ebad0f21cf3fd84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd676dfa57e643a4f7d8445e6ebad0f21cf3fd84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd676dfa57e643a4f7d8445e6ebad0f21cf3fd84/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eece52b53b75767593282d178bae12ceebb33f12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eece52b53b75767593282d178bae12ceebb33f12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eece52b53b75767593282d178bae12ceebb33f12"}], "stats": {"total": 145, "additions": 140, "deletions": 5}, "files": [{"sha": "2894205fa3c3f5e7b757fa5c4dacde353aafd20b", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 86, "deletions": 5, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd676dfa57e643a4f7d8445e6ebad0f21cf3fd84/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd676dfa57e643a4f7d8445e6ebad0f21cf3fd84/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=cd676dfa57e643a4f7d8445e6ebad0f21cf3fd84", "patch": "@@ -865,7 +865,66 @@ find_bswap_or_nop (gimple *stmt, struct symbolic_number *n, bool *bswap)\n   gimple *ins_stmt = find_bswap_or_nop_1 (stmt, n, limit);\n \n   if (!ins_stmt)\n-    return NULL;\n+    {\n+      if (gimple_assign_rhs_code (stmt) != CONSTRUCTOR\n+\t  || BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN)\n+\treturn NULL;\n+      unsigned HOST_WIDE_INT sz = tree_to_uhwi (type_size) * BITS_PER_UNIT;\n+      if (sz != 16 && sz != 32 && sz != 64)\n+\treturn NULL;\n+      tree rhs = gimple_assign_rhs1 (stmt);\n+      tree eltype = TREE_TYPE (TREE_TYPE (rhs));\n+      unsigned HOST_WIDE_INT eltsz\n+\t= int_size_in_bytes (eltype) * BITS_PER_UNIT;\n+      if (TYPE_PRECISION (eltype) != eltsz)\n+\treturn NULL;\n+      constructor_elt *elt;\n+      unsigned int i;\n+      tree type = build_nonstandard_integer_type (sz, 1);\n+      FOR_EACH_VEC_SAFE_ELT (CONSTRUCTOR_ELTS (rhs), i, elt)\n+\t{\n+\t  if (TREE_CODE (elt->value) != SSA_NAME\n+\t      || !INTEGRAL_TYPE_P (TREE_TYPE (elt->value)))\n+\t    return NULL;\n+\t  struct symbolic_number n1;\n+\t  gimple *source_stmt\n+\t    = find_bswap_or_nop_1 (SSA_NAME_DEF_STMT (elt->value), &n1,\n+\t\t\t\t   limit - 1);\n+\n+\t  if (!source_stmt)\n+\t    return NULL;\n+\n+\t  n1.type = type;\n+\t  if (!n1.base_addr)\n+\t    n1.range = sz / BITS_PER_UNIT;\n+\n+\t  if (i == 0)\n+\t    {\n+\t      ins_stmt = source_stmt;\n+\t      *n = n1;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (n->vuse != n1.vuse)\n+\t\treturn NULL;\n+\n+\t      struct symbolic_number n0 = *n;\n+\n+\t      if (!BYTES_BIG_ENDIAN)\n+\t\t{\n+\t\t  if (!do_shift_rotate (LSHIFT_EXPR, &n1, i * eltsz))\n+\t\t    return NULL;\n+\t\t}\n+\t      else if (!do_shift_rotate (LSHIFT_EXPR, &n0, eltsz))\n+\t\treturn NULL;\n+\t      ins_stmt\n+\t\t= perform_symbolic_merge (ins_stmt, &n0, source_stmt, &n1, n);\n+\n+\t      if (!ins_stmt)\n+\t\treturn NULL;\n+\t    }\n+\t}\n+    }\n \n   uint64_t cmpxchg, cmpnop;\n   find_bswap_or_nop_finalize (n, &cmpxchg, &cmpnop);\n@@ -939,11 +998,18 @@ bswap_replace (gimple_stmt_iterator gsi, gimple *ins_stmt, tree fndecl,\n {\n   tree src, tmp, tgt = NULL_TREE;\n   gimple *bswap_stmt;\n+  tree_code conv_code = NOP_EXPR;\n \n   gimple *cur_stmt = gsi_stmt (gsi);\n   src = n->src;\n   if (cur_stmt)\n-    tgt = gimple_assign_lhs (cur_stmt);\n+    {\n+      tgt = gimple_assign_lhs (cur_stmt);\n+      if (gimple_assign_rhs_code (cur_stmt) == CONSTRUCTOR\n+\t  && tgt\n+\t  && VECTOR_TYPE_P (TREE_TYPE (tgt)))\n+\tconv_code = VIEW_CONVERT_EXPR;\n+    }\n \n   /* Need to load the value from memory first.  */\n   if (n->base_addr)\n@@ -1031,7 +1097,9 @@ bswap_replace (gimple_stmt_iterator gsi, gimple *ins_stmt, tree fndecl,\n \t      load_stmt = gimple_build_assign (val_tmp, val_expr);\n \t      gimple_set_vuse (load_stmt, n->vuse);\n \t      gsi_insert_before (&gsi, load_stmt, GSI_SAME_STMT);\n-\t      gimple_assign_set_rhs_with_ops (&gsi, NOP_EXPR, val_tmp);\n+\t      if (conv_code == VIEW_CONVERT_EXPR)\n+\t\tval_tmp = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (tgt), val_tmp);\n+\t      gimple_assign_set_rhs_with_ops (&gsi, conv_code, val_tmp);\n \t      update_stmt (cur_stmt);\n \t    }\n \t  else if (cur_stmt)\n@@ -1073,7 +1141,9 @@ bswap_replace (gimple_stmt_iterator gsi, gimple *ins_stmt, tree fndecl,\n \t{\n \t  if (!is_gimple_val (src))\n \t    return NULL_TREE;\n-\t  g = gimple_build_assign (tgt, NOP_EXPR, src);\n+\t  if (conv_code == VIEW_CONVERT_EXPR)\n+\t    src = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (tgt), src);\n+\t  g = gimple_build_assign (tgt, conv_code, src);\n \t}\n       else if (cur_stmt)\n \tg = gimple_build_assign (tgt, src);\n@@ -1153,7 +1223,10 @@ bswap_replace (gimple_stmt_iterator gsi, gimple *ins_stmt, tree fndecl,\n       gimple *convert_stmt;\n \n       tmp = make_temp_ssa_name (bswap_type, NULL, \"bswapdst\");\n-      convert_stmt = gimple_build_assign (tgt, NOP_EXPR, tmp);\n+      tree atmp = tmp;\n+      if (conv_code == VIEW_CONVERT_EXPR)\n+\tatmp = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (tgt), tmp);\n+      convert_stmt = gimple_build_assign (tgt, conv_code, atmp);\n       gsi_insert_after (&gsi, convert_stmt, GSI_SAME_STMT);\n     }\n \n@@ -1258,6 +1331,14 @@ pass_optimize_bswap::execute (function *fun)\n \t      /* Fall through.  */\n \t    case BIT_IOR_EXPR:\n \t      break;\n+\t    case CONSTRUCTOR:\n+\t      {\n+\t\ttree rhs = gimple_assign_rhs1 (cur_stmt);\n+\t\tif (VECTOR_TYPE_P (TREE_TYPE (rhs))\n+\t\t    && INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (rhs))))\n+\t\t  break;\n+\t      }\n+\t      continue;\n \t    default:\n \t      continue;\n \t    }"}, {"sha": "8af56e12bb4367c7ddf208ede1a326d5af03639e", "filename": "gcc/testsuite/gcc.dg/pr96239.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd676dfa57e643a4f7d8445e6ebad0f21cf3fd84/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96239.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd676dfa57e643a4f7d8445e6ebad0f21cf3fd84/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96239.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr96239.c?ref=cd676dfa57e643a4f7d8445e6ebad0f21cf3fd84", "patch": "@@ -0,0 +1,54 @@\n+/* PR tree-optimization/96239 */\n+/* { dg-do run { target { ilp32 || lp64 } } } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-times \" r>> 8;\" 1 \"optimized\" { target bswap } } } */\n+/* { dg-final { scan-tree-dump-times \" = __builtin_bswap64 \" 1 \"optimized\" { target bswap } } } */\n+/* { dg-final { scan-tree-dump-not \" >> \\(8\\|16\\|24\\|32\\|40\\|48\\|56\\);\" \"optimized\" { target bswap } } } */\n+\n+typedef unsigned char V __attribute__((vector_size (2)));\n+typedef unsigned char W __attribute__((vector_size (8)));\n+\n+__attribute__((noipa)) void\n+foo (unsigned short x, V *p)\n+{\n+  *p = (V) { x >> 8, x };\n+}\n+\n+__attribute__((noipa)) void\n+bar (unsigned long long x, W *p)\n+{\n+  *p = (W) { x >> 56, x >> 48, x >> 40, x >> 32, x >> 24, x >> 16, x >> 8, x };\n+}\n+\n+__attribute__((noipa)) void\n+baz (unsigned short x, V *p)\n+{\n+  *p = (V) { x, x >> 8 };\n+}\n+\n+__attribute__((noipa)) void\n+qux (unsigned long long x, W *p)\n+{\n+  *p = (W) { x, x >> 8, x >> 16, x >> 24, x >> 32, x >> 40, x >> 48, x >> 56 };\n+}\n+\n+int\n+main ()\n+{\n+  V a, c, e, g;\n+  W b, d, f, h;\n+  foo (0xcafe, &a);\n+  bar (0xdeadbeefcafebabeULL, &b);\n+  baz (0xdead, &c);\n+  qux (0xfeedbac1beefdeadULL, &d);\n+  e = (V) { 0xca, 0xfe };\n+  f = (W) { 0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe, 0xba, 0xbe };\n+  g = (V) { 0xad, 0xde };\n+  h = (W) { 0xad, 0xde, 0xef, 0xbe, 0xc1, 0xba, 0xed, 0xfe };\n+  if (__builtin_memcmp (&a, &e, sizeof (V))\n+      || __builtin_memcmp (&b, &f, sizeof (W))\n+      || __builtin_memcmp (&c, &g, sizeof (V))\n+      || __builtin_memcmp (&d, &h, sizeof (W)))\n+    __builtin_abort ();\n+  return 0;\n+}"}]}