{"sha": "df89ab66c78f31b9365a2d051ba72e62d992fe49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY4OWFiNjZjNzhmMzFiOTM2NWEyZDA1MWJhNzJlNjJkOTkyZmU0OQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2008-03-26T07:38:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-03-26T07:38:40Z"}, "message": "sem_ch3.adb (Access_Definition): If the access type is the return result of a protected function...\n\n2008-03-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Access_Definition): If the access type is the return\n\tresult of a protected function, create an itype reference for it\n\tbecause usage will be in an inner scope from the point of declaration.\n\t(Build_Derived_Record_Type): Inherit Reverse_Bit_Order and\n\tOK_To_Reorder_Components.\n\t(Make_Index): If an overloaded range includes a universal integer\n\tinterpretation, resolve to Standard.Integer.\n\t(Analyze_Subtype_Indication): Copy Convention to subtype\n\t(Check_Abstract_Interfaces): Complete semantic checks on the legality of\n\tlimited an synchronized progenitors in type declaration and private\n\textension declarations.\n\n\t* exp_ch13.adb (Expand_N_Freeze_Entity): If the scope of the entity is a\n\tprotected subprogram body, determine proper scope from subprogram\n\tdeclaration.\n\nFrom-SVN: r133561", "tree": {"sha": "3ec3ff84f377e5a9fd2ca954a00f375ec9408452", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ec3ff84f377e5a9fd2ca954a00f375ec9408452"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df89ab66c78f31b9365a2d051ba72e62d992fe49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df89ab66c78f31b9365a2d051ba72e62d992fe49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df89ab66c78f31b9365a2d051ba72e62d992fe49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df89ab66c78f31b9365a2d051ba72e62d992fe49/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "06eab6a7fadd9a6502a7fe439140f8ac1091231e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06eab6a7fadd9a6502a7fe439140f8ac1091231e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06eab6a7fadd9a6502a7fe439140f8ac1091231e"}], "stats": {"total": 201, "additions": 171, "deletions": 30}, "files": [{"sha": "11b3fef88610c0b786a3e7cef50cbc7023dddd5a", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df89ab66c78f31b9365a2d051ba72e62d992fe49/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df89ab66c78f31b9365a2d051ba72e62d992fe49/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=df89ab66c78f31b9365a2d051ba72e62d992fe49", "patch": "@@ -212,13 +212,19 @@ package body Exp_Ch13 is\n       --  expanded away. The same is true for entities in task types, in\n       --  particular the parameter records of entries (Entities in bodies are\n       --  all frozen within the body). If we are in the task body, this is a\n-      --  proper scope.\n+      --  proper scope. If we are within a subprogram body, the proper scope\n+      --  is the corresponding spec. This may happen for itypes generated in\n+      --  the bodies of protected operations.\n \n       if Ekind (E_Scope) = E_Protected_Type\n         or else (Ekind (E_Scope) = E_Task_Type\n                    and then not Has_Completion (E_Scope))\n       then\n          E_Scope := Scope (E_Scope);\n+\n+      elsif Ekind (E_Scope) = E_Subprogram_Body then\n+         E_Scope := Corresponding_Spec (Unit_Declaration_Node (E_Scope));\n+\n       end if;\n \n       S := Current_Scope;"}, {"sha": "87e256a349d1b9508b18efbc216663262e957485", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 164, "deletions": 29, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df89ab66c78f31b9365a2d051ba72e62d992fe49/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df89ab66c78f31b9365a2d051ba72e62d992fe49/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=df89ab66c78f31b9365a2d051ba72e62d992fe49", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -904,6 +904,23 @@ package body Sem_Ch3 is\n \n       if Nkind (Parent (Related_Nod)) = N_Protected_Definition then\n          Build_Itype_Reference (Anon_Type, Parent (Parent (Related_Nod)));\n+\n+      --  Similarly, if the access definition is the return result of a\n+      --  protected function, create an itype reference for it because it\n+      --  will be used within the function body.\n+\n+      elsif Nkind (Related_Nod) = N_Function_Specification\n+        and then  Ekind (Current_Scope) = E_Protected_Type\n+      then\n+         Build_Itype_Reference (Anon_Type, Parent (Current_Scope));\n+\n+      --  Finally, create an itype reference for an object declaration of\n+      --  an anonymous access type. This is strictly necessary only for\n+      --  deferred constants, but in any case will avoid out-of-scope\n+      --  problems in the back-end.\n+\n+      elsif Nkind (Related_Nod) = N_Object_Declaration then\n+         Build_Itype_Reference (Anon_Type, Related_Nod);\n       end if;\n \n       return Anon_Type;\n@@ -2928,8 +2945,8 @@ package body Sem_Ch3 is\n          --  Force generation of debugging information for the constant and for\n          --  the renamed function call.\n \n-         Set_Needs_Debug_Info (Id);\n-         Set_Needs_Debug_Info (Entity (Prefix (E)));\n+         Set_Debug_Info_Needed (Id);\n+         Set_Debug_Info_Needed (Entity (Prefix (E)));\n       end if;\n \n       if Present (Prev_Entity)\n@@ -3213,6 +3230,7 @@ package body Sem_Ch3 is\n       Set_Treat_As_Volatile (Id, Treat_As_Volatile (T));\n       Set_Is_Atomic         (Id, Is_Atomic         (T));\n       Set_Is_Ada_2005_Only  (Id, Is_Ada_2005_Only  (T));\n+      Set_Convention        (Id, Convention        (T));\n \n       --  In the case where there is no constraint given in the subtype\n       --  indication, Process_Subtype just returns the Subtype_Mark, so its\n@@ -6633,13 +6651,13 @@ package body Sem_Ch3 is\n       --  Fields inherited from the Parent_Type\n \n       Set_Discard_Names\n-        (Derived_Type, Einfo.Discard_Names  (Parent_Type));\n+        (Derived_Type, Einfo.Discard_Names      (Parent_Type));\n       Set_Has_Specified_Layout\n-        (Derived_Type, Has_Specified_Layout (Parent_Type));\n+        (Derived_Type, Has_Specified_Layout     (Parent_Type));\n       Set_Is_Limited_Composite\n-        (Derived_Type, Is_Limited_Composite (Parent_Type));\n+        (Derived_Type, Is_Limited_Composite     (Parent_Type));\n       Set_Is_Private_Composite\n-        (Derived_Type, Is_Private_Composite (Parent_Type));\n+        (Derived_Type, Is_Private_Composite     (Parent_Type));\n \n       --  Fields inherited from the Parent_Base\n \n@@ -6650,13 +6668,22 @@ package body Sem_Ch3 is\n       Set_Has_Primitive_Operations\n         (Derived_Type, Has_Primitive_Operations (Parent_Base));\n \n-      --  For non-private case, we also inherit Has_Complex_Representation\n+      --  Fields inherited from the Parent_Base in the non-private case\n \n       if Ekind (Derived_Type) = E_Record_Type then\n          Set_Has_Complex_Representation\n            (Derived_Type, Has_Complex_Representation (Parent_Base));\n       end if;\n \n+      --  Fields inherited from the Parent_Base for record types\n+\n+      if Is_Record_Type (Derived_Type) then\n+         Set_OK_To_Reorder_Components\n+           (Derived_Type, OK_To_Reorder_Components   (Parent_Base));\n+         Set_Reverse_Bit_Order\n+           (Derived_Type, Reverse_Bit_Order          (Parent_Base));\n+      end if;\n+\n       --  Direct controlled types do not inherit Finalize_Storage_Only flag\n \n       if not Is_Controlled (Parent_Type) then\n@@ -7731,21 +7758,80 @@ package body Sem_Ch3 is\n    -------------------------------\n \n    procedure Check_Abstract_Interfaces (N : Node_Id; Def : Node_Id) is\n+      Parent_Type : constant Entity_Id := Etype (Defining_Identifier (N));\n+\n+      Iface       : Node_Id;\n+      Iface_Def   : Node_Id;\n+      Iface_Typ   : Entity_Id;\n+      Parent_Node : Node_Id;\n+\n+      Is_Task : Boolean := False;\n+      --  Set True if parent type or any progenitor is a task interface\n+\n+      Is_Protected : Boolean := False;\n+      --  Set True if parent type or any progenitor is a protected interface\n \n       procedure Check_Ifaces (Iface_Def : Node_Id; Error_Node : Node_Id);\n-      --  Local subprogram used to avoid code duplication. In case of error\n-      --  the message will be associated to Error_Node.\n+      --  Check that a progenitor is compatible with declaration.\n+      --  Error is posted on Error_Node.\n \n       ------------------\n       -- Check_Ifaces --\n       ------------------\n \n       procedure Check_Ifaces (Iface_Def : Node_Id; Error_Node : Node_Id) is\n+         Iface_Id : constant Entity_Id :=\n+                      Defining_Identifier (Parent (Iface_Def));\n+         Type_Def : Node_Id;\n+\n       begin\n-         --  Ada 2005 (AI-345): Protected interfaces can only inherit from\n-         --  limited, synchronized or protected interfaces.\n+         if Nkind (N) = N_Private_Extension_Declaration then\n+            Type_Def := N;\n+         else\n+            Type_Def := Type_Definition (N);\n+         end if;\n \n-         if Protected_Present (Def) then\n+         if Is_Task_Interface (Iface_Id) then\n+            Is_Task := True;\n+\n+         elsif Is_Protected_Interface (Iface_Id) then\n+            Is_Protected := True;\n+         end if;\n+\n+         --  Check that the characteristics of the progenitor are compatible\n+         --  with the explicit qualifier in the declaration.\n+         --  The check only applies to qualifiers that come from source.\n+         --  Limited_Present also appears in the declaration of corresponding\n+         --  records, and the check does not apply to them.\n+\n+         if Limited_Present (Type_Def)\n+           and then not\n+             Is_Concurrent_Record_Type (Defining_Identifier (N))\n+         then\n+            if Is_Limited_Interface (Parent_Type)\n+              and then not Is_Limited_Interface (Iface_Id)\n+            then\n+               Error_Msg_NE\n+                 (\"progenitor& must be limited interface\",\n+                   Error_Node, Iface_Id);\n+\n+            elsif\n+              (Task_Present (Iface_Def)\n+                or else Protected_Present (Iface_Def)\n+                or else Synchronized_Present (Iface_Def))\n+              and then Nkind (N) /= N_Private_Extension_Declaration\n+            then\n+               Error_Msg_NE\n+                 (\"progenitor& must be limited interface\",\n+                   Error_Node, Iface_Id);\n+            end if;\n+\n+         --  Protected interfaces can only inherit from limited, synchronized\n+         --  or protected interfaces.\n+\n+         elsif Nkind (N) = N_Full_Type_Declaration\n+           and then  Protected_Present (Type_Def)\n+         then\n             if Limited_Present (Iface_Def)\n               or else Synchronized_Present (Iface_Def)\n               or else Protected_Present (Iface_Def)\n@@ -7764,29 +7850,35 @@ package body Sem_Ch3 is\n          --  Ada 2005 (AI-345): Synchronized interfaces can only inherit from\n          --  limited and synchronized.\n \n-         elsif Synchronized_Present (Def) then\n+         elsif Synchronized_Present (Type_Def) then\n             if Limited_Present (Iface_Def)\n               or else Synchronized_Present (Iface_Def)\n             then\n                null;\n \n-            elsif Protected_Present (Iface_Def) then\n+            elsif Protected_Present (Iface_Def)\n+              and then Nkind (N) /= N_Private_Extension_Declaration\n+            then\n                Error_Msg_N (\"(Ada 2005) synchronized interface cannot inherit\"\n                             & \" from protected interface\", Error_Node);\n \n-            elsif Task_Present (Iface_Def) then\n+            elsif Task_Present (Iface_Def)\n+              and then Nkind (N) /= N_Private_Extension_Declaration\n+            then\n                Error_Msg_N (\"(Ada 2005) synchronized interface cannot inherit\"\n                             & \" from task interface\", Error_Node);\n \n-            else\n+            elsif not Is_Limited_Interface (Iface_Id) then\n                Error_Msg_N (\"(Ada 2005) synchronized interface cannot inherit\"\n                             & \" from non-limited interface\", Error_Node);\n             end if;\n \n          --  Ada 2005 (AI-345): Task interfaces can only inherit from limited,\n          --  synchronized or task interfaces.\n \n-         elsif Task_Present (Def) then\n+         elsif Nkind (N) = N_Full_Type_Declaration\n+           and then Task_Present (Type_Def)\n+         then\n             if Limited_Present (Iface_Def)\n               or else Synchronized_Present (Iface_Def)\n               or else Task_Present (Iface_Def)\n@@ -7804,35 +7896,65 @@ package body Sem_Ch3 is\n          end if;\n       end Check_Ifaces;\n \n-      --  Local variables\n-\n-      Iface       : Node_Id;\n-      Iface_Def   : Node_Id;\n-      Iface_Typ   : Entity_Id;\n-      Parent_Node : Node_Id;\n-\n    --  Start of processing for Check_Abstract_Interfaces\n \n    begin\n-      --  Why is this still unsupported???\n+      if Is_Interface (Parent_Type) then\n+         if Is_Task_Interface (Parent_Type) then\n+            Is_Task := True;\n+\n+         elsif Is_Protected_Interface (Parent_Type) then\n+            Is_Protected := True;\n+         end if;\n+      end if;\n \n       if Nkind (N) = N_Private_Extension_Declaration then\n+\n+         --  Check that progenitors are compatible with declaration\n+\n+         Iface := First (Interface_List (Def));\n+         while Present (Iface) loop\n+            Iface_Typ := Find_Type_Of_Subtype_Indic (Iface);\n+\n+            Parent_Node := Parent (Base_Type (Iface_Typ));\n+            Iface_Def   := Type_Definition (Parent_Node);\n+\n+            if not Is_Interface (Iface_Typ) then\n+               Error_Msg_NE (\"(Ada 2005) & must be an interface\",\n+                          Iface, Iface_Typ);\n+\n+            else\n+               Check_Ifaces (Iface_Def, Iface);\n+            end if;\n+\n+            Next (Iface);\n+         end loop;\n+\n+         if Is_Task and Is_Protected then\n+            Error_Msg_N\n+              (\"type cannot derive from task and protected interface\", N);\n+         end if;\n+\n          return;\n       end if;\n \n-      --  Check the parent in case of derivation of interface type\n+      --  Full type declaration of derived type.\n+      --  Check compatibility with parent if it is interface type\n \n       if Nkind (Type_Definition (N)) = N_Derived_Type_Definition\n-        and then Is_Interface (Etype (Defining_Identifier (N)))\n+        and then Is_Interface (Parent_Type)\n       then\n-         Parent_Node := Parent (Etype (Defining_Identifier (N)));\n+         Parent_Node := Parent (Parent_Type);\n+\n+         --  More detailed checks for interface varieties\n \n          Check_Ifaces\n            (Iface_Def  => Type_Definition (Parent_Node),\n             Error_Node => Subtype_Indication (Type_Definition (N)));\n       end if;\n \n       Iface := First (Interface_List (Def));\n+\n       while Present (Iface) loop\n          Iface_Typ := Find_Type_Of_Subtype_Indic (Iface);\n \n@@ -7853,6 +7975,12 @@ package body Sem_Ch3 is\n \n          Next (Iface);\n       end loop;\n+\n+      if Is_Task and Is_Protected then\n+         Error_Msg_N\n+           (\"type cannot derive from task and protected interface\", N);\n+      end if;\n+\n    end Check_Abstract_Interfaces;\n \n    -------------------------------\n@@ -14002,6 +14130,13 @@ package body Sem_Ch3 is\n                T := Standard_Character;\n             end if;\n \n+         --  The node may be overloaded because some user-defined operators\n+         --  are available, but if a universal interpretation exists it is\n+         --  also the selected one.\n+\n+         elsif Universal_Interpretation (I) = Universal_Integer then\n+            T := Standard_Integer;\n+\n          else\n             T := Any_Type;\n "}]}