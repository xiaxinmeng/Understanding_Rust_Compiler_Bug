{"sha": "0215b3559e55f39f38e10984a804c53907f7491c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIxNWIzNTU5ZTU1ZjM5ZjM4ZTEwOTg0YTgwNGM1MzkwN2Y3NDkxYw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-08-16T13:17:08Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-08-17T07:24:21Z"}, "message": "tree-optimization/101925 - fix VN with reverse storage order\n\nThis fixes value-numbering breaking reverse storage order accesses\ndue to a missed check.  It adds a new overload for\nreverse_storage_order_for_component_p and sets reversed on the\nVN IL ops for component and array accesses accordingly.\nIt also compares the reversed reference ops flag on reference\nlookup.\n\n2021-08-16  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/101925\n\t* tree-ssa-sccvn.c (copy_reference_ops_from_ref): Set\n\treverse on COMPONENT_REF and ARRAY_REF according to\n\twhat reverse_storage_order_for_component_p does.\n\t(vn_reference_eq): Compare reversed on reference ops.\n\t(reverse_storage_order_for_component_p): New overload.\n\t(vn_reference_lookup_3): Check reverse_storage_order_for_component_p\n\ton the reference looked up.\n\n\t* gcc.dg/sso-16.c: New testcase.", "tree": {"sha": "e68670344dedba214ac58bb684efe45e21c2cfab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e68670344dedba214ac58bb684efe45e21c2cfab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0215b3559e55f39f38e10984a804c53907f7491c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0215b3559e55f39f38e10984a804c53907f7491c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0215b3559e55f39f38e10984a804c53907f7491c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0215b3559e55f39f38e10984a804c53907f7491c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75a7176575c409940b66020def23508f5701f5fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75a7176575c409940b66020def23508f5701f5fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75a7176575c409940b66020def23508f5701f5fb"}], "stats": {"total": 133, "additions": 132, "deletions": 1}, "files": [{"sha": "7bf89385ec6a3f972e423b13a8a9e5d387a377d8", "filename": "gcc/testsuite/gcc.dg/sso-16.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0215b3559e55f39f38e10984a804c53907f7491c/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0215b3559e55f39f38e10984a804c53907f7491c/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsso-16.c?ref=0215b3559e55f39f38e10984a804c53907f7491c", "patch": "@@ -0,0 +1,100 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target int32plus } */\n+/* { dg-options \"-O3\" } */\n+\n+typedef __INT32_TYPE__ int32_t;\n+\n+#define BIG_ENDIAN   __attribute__((scalar_storage_order(\"big-endian\")))\n+\n+/* host order version (little endian)*/\n+struct _ip6_addr {\n+    union {\n+        char addr8[16];\n+        int32_t  addr32[4];\n+    } u;\n+};\n+\n+typedef struct _ip6_addr t_ip6_addr;\n+\n+struct _net_addr {\n+    char is_v4;\n+    union {\n+        int32_t        addr;\n+        t_ip6_addr addr6;\n+    } u;\n+};\n+\n+typedef struct _net_addr t_net_addr;\n+\n+/* big endian version */\n+struct _be_ip6_addr {\n+    union {\n+        char addr8[16];\n+    } BIG_ENDIAN u;\n+} BIG_ENDIAN;\n+\n+typedef struct _be_ip6_addr t_be_ip6_addr;\n+\n+struct _be_net_addr {\n+    char is_v4;\n+    union {\n+        t_be_ip6_addr addr6;\n+        int32_t           addr;\n+    } BIG_ENDIAN u;\n+} BIG_ENDIAN;\n+\n+typedef struct _be_net_addr t_be_net_addr;\n+\n+/* convert */\n+t_be_ip6_addr be_ip6_addr(const t_ip6_addr ip6)\n+{\n+    t_be_ip6_addr rc = {\n+        .u.addr8[0] = ip6.u.addr8[0],\n+        .u.addr8[1] = ip6.u.addr8[1],\n+        .u.addr8[2] = ip6.u.addr8[2],\n+        .u.addr8[3] = ip6.u.addr8[3],\n+        .u.addr8[4] = ip6.u.addr8[4],\n+        .u.addr8[5] = ip6.u.addr8[5],\n+        .u.addr8[6] = ip6.u.addr8[6],\n+        .u.addr8[7] = ip6.u.addr8[7],\n+        .u.addr8[8] = ip6.u.addr8[8],\n+        .u.addr8[9] = ip6.u.addr8[9],\n+        .u.addr8[10] = ip6.u.addr8[10],\n+        .u.addr8[11] = ip6.u.addr8[11],\n+        .u.addr8[12] = ip6.u.addr8[12],\n+        .u.addr8[13] = ip6.u.addr8[13],\n+        .u.addr8[14] = ip6.u.addr8[14],\n+        .u.addr8[15] = ip6.u.addr8[15],\n+    };\n+    return rc;\n+}\n+\n+t_be_net_addr __attribute__((noipa)) be_net_addr(const t_net_addr ip)\n+{\n+    t_be_net_addr rc = {.is_v4 = ip.is_v4 };\n+    if (ip.is_v4) {\n+        rc.u.addr = ip.u.addr;\n+    } else {\n+        rc.u.addr6 = be_ip6_addr(ip.u.addr6);\n+    }\n+    return rc;\n+}\n+\n+int main(void)\n+{\n+    t_be_net_addr out = { };\n+\n+    t_net_addr in = {\n+        .is_v4 = 0,\n+        .u.addr6.u.addr8 =\n+            { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }\n+    };\n+\n+    out = be_net_addr(in);\n+\n+    // actually first 4 bytes are swapped\n+    if (in.u.addr6.u.addr8[0] != out.u.addr6.u.addr8[0])\n+        __builtin_abort();\n+\n+    return 0;\n+}"}, {"sha": "82bd10bd83c75bb9d2450049e5e0cacdc7c61d22", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0215b3559e55f39f38e10984a804c53907f7491c/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0215b3559e55f39f38e10984a804c53907f7491c/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=0215b3559e55f39f38e10984a804c53907f7491c", "patch": "@@ -797,13 +797,15 @@ vn_reference_eq (const_vn_reference_t const vr1, const_vn_reference_t const vr2)\n       vn_reference_op_t vro1, vro2;\n       vn_reference_op_s tem1, tem2;\n       bool deref1 = false, deref2 = false;\n+      bool reverse1 = false, reverse2 = false;\n       for (; vr1->operands.iterate (i, &vro1); i++)\n \t{\n \t  if (vro1->opcode == MEM_REF)\n \t    deref1 = true;\n \t  /* Do not look through a storage order barrier.  */\n \t  else if (vro1->opcode == VIEW_CONVERT_EXPR && vro1->reverse)\n \t    return false;\n+\t  reverse1 |= vro1->reverse;\n \t  if (known_eq (vro1->off, -1))\n \t    break;\n \t  off1 += vro1->off;\n@@ -815,11 +817,12 @@ vn_reference_eq (const_vn_reference_t const vr1, const_vn_reference_t const vr2)\n \t  /* Do not look through a storage order barrier.  */\n \t  else if (vro2->opcode == VIEW_CONVERT_EXPR && vro2->reverse)\n \t    return false;\n+\t  reverse2 |= vro2->reverse;\n \t  if (known_eq (vro2->off, -1))\n \t    break;\n \t  off2 += vro2->off;\n \t}\n-      if (maybe_ne (off1, off2))\n+      if (maybe_ne (off1, off2) || reverse1 != reverse2)\n \treturn false;\n       if (deref1 && vro1->opcode == ADDR_EXPR)\n \t{\n@@ -916,6 +919,9 @@ copy_reference_ops_from_ref (tree ref, vec<vn_reference_op_s> *result)\n \t  temp.type = NULL_TREE;\n \t  temp.op0 = TREE_OPERAND (ref, 1);\n \t  temp.op1 = TREE_OPERAND (ref, 2);\n+\t  temp.reverse = (AGGREGATE_TYPE_P (TREE_TYPE (TREE_OPERAND (ref, 0)))\n+\t\t\t  && TYPE_REVERSE_STORAGE_ORDER\n+\t\t\t       (TREE_TYPE (TREE_OPERAND (ref, 0))));\n \t  {\n \t    tree this_offset = component_ref_field_offset (ref);\n \t    if (this_offset\n@@ -962,6 +968,9 @@ copy_reference_ops_from_ref (tree ref, vec<vn_reference_op_s> *result)\n \t\t\t\t       * vn_ref_op_align_unit (&temp));\n \t\toff.to_shwi (&temp.off);\n \t      }\n+\t    temp.reverse = (AGGREGATE_TYPE_P (TREE_TYPE (TREE_OPERAND (ref, 0)))\n+\t\t\t    && TYPE_REVERSE_STORAGE_ORDER\n+\t\t\t\t (TREE_TYPE (TREE_OPERAND (ref, 0))));\n \t  }\n \t  break;\n \tcase VAR_DECL:\n@@ -1583,6 +1592,26 @@ contains_storage_order_barrier_p (vec<vn_reference_op_s> ops)\n   return false;\n }\n \n+/* Return true if OPS represent an access with reverse storage order.  */\n+\n+static bool\n+reverse_storage_order_for_component_p (vec<vn_reference_op_s> ops)\n+{\n+  unsigned i = 0;\n+  if (ops[i].opcode == REALPART_EXPR || ops[i].opcode == IMAGPART_EXPR)\n+    ++i;\n+  switch (ops[i].opcode)\n+    {\n+    case ARRAY_REF:\n+    case COMPONENT_REF:\n+    case BIT_FIELD_REF:\n+    case MEM_REF:\n+      return ops[i].reverse;\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Transform any SSA_NAME's in a vector of vn_reference_op_s\n    structures into their value numbers.  This is done in-place, and\n    the vector passed in is returned.  *VALUEIZED_ANYTHING will specify\n@@ -2899,6 +2928,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n      routines to extract the assigned bits.  */\n   else if (known_eq (ref->size, maxsize)\n \t   && is_gimple_reg_type (vr->type)\n+\t   && !reverse_storage_order_for_component_p (vr->operands)\n \t   && !contains_storage_order_barrier_p (vr->operands)\n \t   && gimple_assign_single_p (def_stmt)\n \t   && CHAR_BIT == 8\n@@ -3050,6 +3080,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,\n      to access pieces from or we can combine to a larger entity.  */\n   else if (known_eq (ref->size, maxsize)\n \t   && is_gimple_reg_type (vr->type)\n+\t   && !reverse_storage_order_for_component_p (vr->operands)\n \t   && !contains_storage_order_barrier_p (vr->operands)\n \t   && gimple_assign_single_p (def_stmt)\n \t   && TREE_CODE (gimple_assign_rhs1 (def_stmt)) == SSA_NAME)"}]}