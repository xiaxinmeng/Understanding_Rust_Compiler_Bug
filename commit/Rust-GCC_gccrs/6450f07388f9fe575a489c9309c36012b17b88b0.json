{"sha": "6450f07388f9fe575a489c9309c36012b17b88b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ1MGYwNzM4OGY5ZmU1NzVhNDg5YzkzMDljMzYwMTJiMTdiODhiMA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-09-19T23:21:52Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-09-19T23:34:31Z"}, "message": "Infrastructure & C front end changes for array parameter checking (PR c/50584).\n\ngcc/ChangeLog:\n\n\tPR c/50584\n\t* attribs.c (decl_attributes): Also pass decl along with type\n\tattributes to handlers.\n\t(init_attr_rdwr_indices): Change second argument to attribute chain.\n\tHandle internal attribute representation in addition to external.\n\t(get_parm_access): New function.\n\t(attr_access::to_internal_string): Define new member function.\n\t(attr_access::to_external_string): Define new member function.\n\t(attr_access::vla_bounds): Define new member function.\n\t* attribs.h (struct attr_access): Declare new members.\n\t(attr_access::from_mode_char): Define new member function.\n\t(get_parm_access): Declare new function.\n\t* calls.c (initialize_argument_information): Pass function type\n\tattributes to init_attr_rdwr_indices.\n\t* doc/invoke.texi (-Warray-parameter, -Wvla-parameter): Document.\n\t* tree-pretty-print.c (dump_generic_node): Correct handling of\n\tqualifiers.\n\t* tree-ssa-uninit.c (maybe_warn_pass_by_reference): Same.\n\t* tree.h (access_mode): Add new enumerator.\n\ngcc/c-family/ChangeLog:\n\n\tPR c/50584\n\t* c-attribs.c (c_common_attribute_table): Add \"arg spec\" attribute.\n\t(handle_argspec_attribute): New function.\n\t(get_argument, get_argument_type): New functions.\n\t(append_access_attrs): Add overload.  Handle internal attribute\n\trepresentation in addition to external.\n\t(handle_access_attribute): Handle internal attribute representation\n\tin addition to external.\n\t(build_attr_access_from_parms): New function.\n\ngcc/c-family/ChangeLog:\n\n\tPR c/50584\n\t* c-common.h (warn_parm_array_mismatch): Declare new function.\n\t(has_attribute): Move declaration of an existing function.\n\t(build_attr_access_from_parms): Declare new function.\n\t* c-warn.c (parm_array_as_string): Define new function.\n\t(plus_one):  Define new function.\n\t(warn_parm_ptrarray_mismatch): Define new function.\n\t(warn_parm_array_mismatch):  Define new function.\n\t(vla_bound_parm_decl): New function.\n\t* c.opt (-Warray-parameter, -Wvla-parameter): New options.\n\t* c-pretty-print.c (pp_c_type_qualifier_list): Don't print array type\n\tqualifiers here...\n\t(c_pretty_printer::direct_abstract_declarator): ...but instead print\n\tthem in brackets here.  Also print [static].  Strip extraneous\n\texpressions from VLA bounds.\n\ngcc/c/ChangeLog:\n\n\tPR c/50584\n\t* c-decl.c (lookup_last_decl): Define new function.\n\t(c_decl_attributes): Call it.\n\t(start_decl): Add argument and use it.\n\t(finish_decl): Call build_attr_access_from_parms and decl_attributes.\n\t(get_parm_array_spec): Define new function.\n\t(push_parm_decl): Call get_parm_array_spec.\n\t(start_function): Call warn_parm_array_mismatch.  Build attribute\n\taccess and add it to current function.\n\t* c-parser.c (c_parser_declaration_or_fndef): Diagnose mismatches\n\tin forms of array parameters.\n\t* c-tree.h (start_decl): Add argument.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c/50584\n\t* gcc.dg/attr-access-read-write-2.c: Adjust text of expected message.\n\t* c-c++-common/Warray-bounds-6.c: Correct C++ declaration, adjust\n\ttext of expected diagnostics.\n\t* gcc.dg/Wbuiltin-declaration-mismatch-9.c: Prune expected warning.\n\t* gcc.dg/Warray-parameter-2.c: New test.\n\t* gcc.dg/Warray-parameter-3.c: New test.\n\t* gcc.dg/Warray-parameter-4.c: New test.\n\t* gcc.dg/Warray-parameter-5.c: New test.\n\t* gcc.dg/Warray-parameter.c: New test.\n\t* gcc.dg/Wvla-parameter-2.c: New test.\n\t* gcc.dg/Wvla-parameter-3.c: New test.\n\t* gcc.dg/Wvla-parameter.c: New test.", "tree": {"sha": "929351afdf436f119f15a3d37da96d3a0e3ae27c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/929351afdf436f119f15a3d37da96d3a0e3ae27c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6450f07388f9fe575a489c9309c36012b17b88b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6450f07388f9fe575a489c9309c36012b17b88b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6450f07388f9fe575a489c9309c36012b17b88b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6450f07388f9fe575a489c9309c36012b17b88b0/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3696a50beeb73f4ded8a584e76ee16f0bde109b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3696a50beeb73f4ded8a584e76ee16f0bde109b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3696a50beeb73f4ded8a584e76ee16f0bde109b9"}], "stats": {"total": 2793, "additions": 2588, "deletions": 205}, "files": [{"sha": "abc75368e6c29a5be3f6051316e951f992d2cb66", "filename": "gcc/attribs.c", "status": "modified", "additions": 266, "deletions": 27, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -17,6 +17,7 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+#define INCLUDE_STRING\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -25,13 +26,15 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"diagnostic-core.h\"\n #include \"attribs.h\"\n+#include \"fold-const.h\"\n #include \"stor-layout.h\"\n #include \"langhooks.h\"\n #include \"plugin.h\"\n #include \"selftest.h\"\n #include \"hash-set.h\"\n #include \"diagnostic.h\"\n #include \"pretty-print.h\"\n+#include \"tree-pretty-print.h\"\n #include \"intl.h\"\n \n /* Table of the tables of attributes (common, language, format, machine)\n@@ -707,10 +710,16 @@ decl_attributes (tree *node, tree attributes, int flags,\n \t  int cxx11_flag = (cxx11_attr_p ? ATTR_FLAG_CXX11 : 0);\n \n \t  /* Pass in an array of the current declaration followed\n-\t     by the last pushed/merged declaration if  one exists.\n+\t     by the last pushed/merged declaration if one exists.\n+\t     For calls that modify the type attributes of a DECL\n+\t     and for which *ANODE is *NODE's type, also pass in\n+\t     the DECL as the third element to use in diagnostics.\n \t     If the handler changes CUR_AND_LAST_DECL[0] replace\n \t     *ANODE with its value.  */\n-\t  tree cur_and_last_decl[] = { *anode, last_decl };\n+\t  tree cur_and_last_decl[3] = { *anode, last_decl };\n+\t  if (anode != node && DECL_P (*node))\n+\t    cur_and_last_decl[2] = *node;\n+\n \t  tree ret = (spec->handler) (cur_and_last_decl, name, args,\n \t\t\t\t      flags|cxx11_flag, &no_add_attrs);\n \n@@ -2017,65 +2026,295 @@ maybe_diag_alias_attributes (tree alias, tree target)\n     }\n }\n \n-/* Initialize a mapping for a call to function FNDECL declared with\n-   attribute access.  Each attribute positional operand inserts one\n-   entry into the mapping with the operand number as the key.  */\n+/* Initialize a mapping RWM for a call to a function declared with\n+   attribute access in ATTRS.  Each attribute positional operand\n+   inserts one entry into the mapping with the operand number as\n+   the key.  */\n \n void\n-init_attr_rdwr_indices (rdwr_map *rwm, tree fntype)\n+init_attr_rdwr_indices (rdwr_map *rwm, tree attrs)\n {\n-  if (!fntype)\n+  if (!attrs)\n     return;\n \n-  for (tree access = TYPE_ATTRIBUTES (fntype);\n+  for (tree access = attrs;\n        (access = lookup_attribute (\"access\", access));\n        access = TREE_CHAIN (access))\n     {\n       /* The TREE_VALUE of an attribute is a TREE_LIST whose TREE_VALUE\n \t is the attribute argument's value.  */\n       tree mode = TREE_VALUE (access);\n-      gcc_assert (TREE_CODE (mode) == TREE_LIST);\n+      if (!mode)\n+\treturn;\n+\n+      /* The (optional) list of VLA bounds.  */\n+      tree vblist = TREE_CHAIN (mode);\n+\n       mode = TREE_VALUE (mode);\n+      if (TREE_CODE (mode) != STRING_CST)\n+\tcontinue;\n       gcc_assert (TREE_CODE (mode) == STRING_CST);\n \n-      const char *modestr = TREE_STRING_POINTER (mode);\n-      for (const char *m = modestr; *m; )\n+      for (const char *m = TREE_STRING_POINTER (mode); *m; )\n \t{\n \t  attr_access acc = { };\n \n-\t  switch (*m)\n+\t  /* Skip the internal-only plus sign.  */\n+\t  if (*m == '+')\n+\t    ++m;\n+\n+\t  acc.str = m;\n+\t  acc.mode = acc.from_mode_char (*m);\n+\t  acc.sizarg = UINT_MAX;\n+\n+\t  const char *end;\n+\t  acc.ptrarg = strtoul (++m, const_cast<char**>(&end), 10);\n+\t  m = end;\n+\n+\t  if (*m == '[')\n \t    {\n-\t    case 'r': acc.mode = access_read_only; break;\n-\t    case 'w': acc.mode = access_write_only; break;\n-\t    case 'x': acc.mode = access_read_write; break;\n-\t    case '-': acc.mode = access_none; break;\n-\t    default: gcc_unreachable ();\n+\t      /* Forms containing the square bracket are internal-only\n+\t\t (not specified by an attribute declaration), and used\n+\t\t for various forms of array and VLA parameters.  */\n+\t      acc.internal_p = true;\n+\n+\t      /* Search to the closing bracket and look at the preceding\n+\t\t code: it determines the form of the most significant\n+\t\t bound of the array.  Others prior to it encode the form\n+\t\t of interior VLA bounds.  They're not of interest here.  */\n+\t      end = strchr (m, ']');\n+\t      const char *p = end;\n+\t      gcc_assert (p);\n+\n+\t      while (ISDIGIT (p[-1]))\n+\t\t--p;\n+\n+\t      if (ISDIGIT (*p))\n+\t\t{\n+\t\t  /* A digit denotes a constant bound (as in T[3]).  */\n+\t\t  acc.static_p = p[-1] == 's';\n+\t\t  acc.minsize = strtoull (p, NULL, 10);\n+\t\t}\n+\t      else if (' ' == p[-1])\n+\t\t{\n+\t\t  /* A space denotes an ordinary array of unspecified bound\n+\t\t     (as in T[]).  */\n+\t\t  acc.minsize = 0;\n+\t\t}\n+\t      else if ('*' == p[-1] || '$' == p[-1])\n+\t\t{\n+\t\t  /* An asterisk denotes a VLA.  When the closing bracket\n+\t\t     is followed by a comma and a dollar sign its bound is\n+\t\t     on the list.  Otherwise it's a VLA with an unspecified\n+\t\t     bound.  */\n+\t\t  acc.minsize = HOST_WIDE_INT_M1U;\n+\t\t}\n+\n+\t      m = end + 1;\n \t    }\n \n-\t  char *end;\n-\t  acc.ptrarg = strtoul (++m, &end, 10);\n-\t  m = end;\n \t  if (*m == ',')\n \t    {\n-\t      acc.sizarg = strtoul (++m, &end, 10);\n-\t      m = end;\n+\t      ++m;\n+\t      do\n+\t\t{\n+\t\t  if (*m == '$')\n+\t\t    {\n+\t\t      ++m;\n+\t\t      if (!acc.size)\n+\t\t\t{\n+\t\t\t  /* Extract the list of VLA bounds for the current\n+\t\t\t     parameter, store it in ACC.SIZE, and advance\n+\t\t\t     to the list of bounds for the next VLA parameter.\n+\t\t\t  */\n+\t\t\t  acc.size = TREE_VALUE (vblist);\n+\t\t\t  vblist = TREE_CHAIN (vblist);\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  if (ISDIGIT (*m))\n+\t\t    {\n+\t\t      /* Extract the positional argument.  It's absent\n+\t\t\t for VLAs whose bound doesn't name a function\n+\t\t\t parameter.  */\n+\t\t      unsigned pos = strtoul (m, const_cast<char**>(&end), 10);\n+\t\t      if (acc.sizarg == UINT_MAX)\n+\t\t\tacc.sizarg = pos;\n+\t\t      m = end;\n+\t\t    }\n+\t\t}\n+\t      while (*m == '$');\n+\t    }\n+\n+\t  acc.end = m;\n+\n+\t  bool existing;\n+\t  auto &ref = rwm->get_or_insert (acc.ptrarg, &existing);\n+\t  if (existing)\n+\t    {\n+\t      /* Merge the new spec with the existing.  */\n+\t      if (acc.minsize == HOST_WIDE_INT_M1U)\n+\t\tref.minsize = HOST_WIDE_INT_M1U;\n+\n+\t      if (acc.sizarg != UINT_MAX)\n+\t\tref.sizarg = acc.sizarg;\n+\n+\t      if (acc.mode)\n+\t\tref.mode = acc.mode;\n \t    }\n \t  else\n-\t    acc.sizarg = UINT_MAX;\n-\n-\t  acc.ptr = NULL_TREE;\n-\t  acc.size = NULL_TREE;\n+\t    ref = acc;\n \n \t  /* Unconditionally add an entry for the required pointer\n \t     operand of the attribute, and one for the optional size\n \t     operand when it's specified.  */\n-\t  rwm->put (acc.ptrarg, acc);\n \t  if (acc.sizarg != UINT_MAX)\n \t    rwm->put (acc.sizarg, acc);\n \t}\n     }\n }\n \n+/* Return the access specification for a function parameter PARM\n+   or null if the current function has no such specification.  */\n+\n+attr_access *\n+get_parm_access (rdwr_map &rdwr_idx, tree parm,\n+\t\t tree fndecl /* = current_function_decl */)\n+{\n+  tree fntype = TREE_TYPE (fndecl);\n+  init_attr_rdwr_indices (&rdwr_idx, TYPE_ATTRIBUTES (fntype));\n+\n+  if (rdwr_idx.is_empty ())\n+    return NULL;\n+\n+  unsigned argpos = 0;\n+  tree fnargs = DECL_ARGUMENTS (fndecl);\n+  for (tree arg = fnargs; arg; arg = TREE_CHAIN (arg), ++argpos)\n+    if (arg == parm)\n+      return rdwr_idx.get (argpos);\n+\n+  return NULL;\n+}\n+\n+/* Return the internal representation as STRING_CST.  Internal positional\n+   arguments are zero-based.  */\n+\n+tree\n+attr_access::to_internal_string () const\n+{\n+  return build_string (end - str, str);\n+}\n+\n+/* Return the human-readable representation of the external attribute\n+   specification (as it might appear in the source code) as STRING_CST.\n+   External positional arguments are one-based.  */\n+\n+tree\n+attr_access::to_external_string () const\n+{\n+  char buf[80];\n+  gcc_assert (mode != access_deferred);\n+  int len = snprintf (buf, sizeof buf, \"access (%s, %u\",\n+\t\t      mode_names[mode], ptrarg + 1);\n+  if (sizarg != UINT_MAX)\n+    len += snprintf (buf + len, sizeof buf - len, \", %u\", sizarg + 1);\n+  strcpy (buf + len, \")\");\n+  return build_string (len + 2, buf);\n+}\n+\n+/* Return the number of specified VLA bounds and set *nunspec to\n+   the number of unspecified ones (those designated by [*]).  */\n+\n+unsigned\n+attr_access::vla_bounds (unsigned *nunspec) const\n+{\n+  *nunspec = 0;\n+  for (const char* p = strrchr (str, ']'); p && *p != '['; --p)\n+    if (*p == '*')\n+      ++*nunspec;\n+  return list_length (size);\n+}\n+\n+\n+/* Defined in attr_access.  */\n+constexpr char attr_access::mode_chars[];\n+constexpr char attr_access::mode_names[][11];\n+\n+/* Format an array, including a VLA, pointed to by TYPE and used as\n+   a function parameter as a human-readable string.  ACC describes\n+   an access to the parameter and is used to determine the outermost\n+   form of the array including its bound which is otherwise obviated\n+   by its decay to pointer.  Return the formatted string.  */\n+\n+std::string\n+attr_access::array_as_string (tree type) const\n+{\n+  std::string typstr;\n+\n+  if (type == error_mark_node)\n+    return std::string ();\n+\n+  if (this->str)\n+    {\n+      /* For array parameters (but not pointers) create an array type\n+\t that corresponds to the form of the parameter including its\n+\t qualifiers even though they apply to the pointer, not the array\n+\t type.  */\n+      const bool vla_p = minsize == HOST_WIDE_INT_M1U;\n+      tree eltype = TREE_TYPE (type);\n+      tree artype;\n+\n+      tree index_type = NULL_TREE;\n+      if (minsize == HOST_WIDE_INT_M1U)\n+\t{\n+\t  /* Determine if this is a VLA (an array whose most significant\n+\t     bound is nonconstant and whose access string has \"$]\" in it)\n+\t     extract the bound expression from SIZE.  */\n+\t  const char *p = end;\n+\t  for ( ; *p-- != ']'; );\n+\t  if (*p == '$')\n+\t    index_type = build_index_type (TREE_VALUE (size));\n+\t}\n+      else  if (minsize)\n+\tindex_type = build_index_type (size_int (minsize - 1));\n+\n+      artype = build_array_type (eltype, index_type);\n+\n+      if (static_p || vla_p)\n+\t{\n+\t  tree flag = static_p ? integer_one_node : NULL_TREE;\n+\t  /* Hack: there's no language-independent way to encode\n+\t     the \"static\" specifier or the \"*\" notation in an array type.\n+\t     Temporarily add an attribute to have the pretty printer add\n+\t     \"static\" or \"*\", and remove it later.  The static notation\n+\t     is only valid in the most significant bound but [*] can be\n+\t     used for any bound.  Because [*] is represented the same as\n+\t     [0] this hack only works for the most significant bound like\n+\t     static and the others are rendered as [0].  */\n+\t  tree at = tree_cons (get_identifier (\"array\"), flag, NULL_TREE);\n+\t  TYPE_ATTRIBUTES (artype) = at;\n+\t}\n+\n+      TYPE_ATOMIC (artype) = TYPE_ATOMIC (type);\n+      TYPE_READONLY (artype) = TYPE_READONLY (type);\n+      TYPE_RESTRICT (artype) = TYPE_RESTRICT (type);\n+      TYPE_VOLATILE (artype) = TYPE_VOLATILE (type);\n+      type = artype;\n+    }\n+\n+  /* Format the type using the current pretty printer.  The generic tree\n+     printer does a terrible job.  */\n+  pretty_printer *pp = global_dc->printer->clone ();\n+  pp_printf (pp, \"%qT\", type);\n+  typstr = pp_formatted_text (pp);\n+  delete pp;\n+\n+  if (this->str)\n+    /* Remove the attribute that wasn't installed by decl_attributes.  */\n+    TYPE_ATTRIBUTES (type) = NULL_TREE;\n+\n+  return typstr;\n+}\n \n #if CHECKING_P\n "}, {"sha": "6ed2d1cd49e8029fbc3a82d12ff3580e51b35aa2", "filename": "gcc/attribs.h", "status": "modified", "additions": 65, "deletions": 2, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fattribs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fattribs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.h?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -224,19 +224,80 @@ lookup_attribute_by_prefix (const char *attr_name, tree list)\n \n struct attr_access\n {\n+  /* The beginning and end of the internal string representation.  */\n+  const char *str, *end;\n   /* The attribute pointer argument.  */\n   tree ptr;\n-  /* The size of the pointed-to object or NULL when not specified.  */\n+  /* For a declaration, a TREE_CHAIN of VLA bound expressions stored\n+     in TREE_VALUE and their positions in the argument list (stored\n+     in TREE_PURPOSE).  Each expression may be a PARM_DECL or some\n+     other DECL (for ordinary variables), or an EXPR for other\n+     expressions (e.g., funcion calls).  */\n   tree size;\n \n-  /* The zero-based number of each of the formal function arguments.  */\n+  /* The zero-based position of each of the formal function arguments.\n+     For the optional SIZARG, UINT_MAX when not specified.  For VLAs\n+     with multiple variable bounds, SIZARG is the position corresponding\n+     to the most significant bound in the argument list.  Positions of\n+     subsequent bounds are in the TREE_PURPOSE field of the SIZE chain.  */\n   unsigned ptrarg;\n   unsigned sizarg;\n+  /* For internal specifications only, the constant minimum size of\n+     the array, zero if not specified, and HWI_M1U for the unspecified\n+     VLA [*] notation.  Meaningless for external (explicit) access\n+     specifications.  */\n+  unsigned HOST_WIDE_INT minsize;\n \n   /* The access mode.  */\n   access_mode mode;\n+\n+  /* Set for an attribute added internally rather than by an explicit\n+     declaration. */\n+  bool internal_p;\n+  /* Set for the T[static MINSIZE] array notation for nonzero MINSIZE\n+     less than HWI_M1U.  */\n+  bool static_p;\n+\n+  /* Return the number of specified VLA bounds.  */\n+  unsigned vla_bounds (unsigned *) const;\n+\n+  /* Return internal representation as STRING_CST.  */\n+  tree to_internal_string () const;\n+\n+  /* Return the human-readable representation of the external attribute\n+     specification (as it might appear in the source code) as STRING_CST.  */\n+  tree to_external_string () const;\n+\n+  /* Return argument of array type formatted as a readable string.  */\n+  std::string array_as_string (tree) const;\n+\n+  /* Return the access mode corresponding to the character code.  */\n+  static access_mode from_mode_char (char);\n+\n+  /* The character codes corresponding to all the access modes.  */\n+  static constexpr char mode_chars[5] = { '-', 'r', 'w', 'x', '^' };\n+\n+  /* The strings corresponding to just the external access modes.  */\n+  static constexpr char mode_names[4][11] =\n+    {\n+     \"none\", \"read_only\", \"write_only\", \"read_write\"\n+    };\n };\n \n+inline access_mode\n+attr_access::from_mode_char (char c)\n+{\n+  switch (c)\n+    {\n+    case mode_chars[access_none]: return access_none;\n+    case mode_chars[access_read_only]: return access_read_only;\n+    case mode_chars[access_write_only]: return access_write_only;\n+    case mode_chars[access_read_write]: return access_read_write;\n+    case mode_chars[access_deferred]: return access_deferred;\n+    }\n+  gcc_unreachable ();\n+}\n+\n /* Used to define rdwr_map below.  */\n struct rdwr_access_hash: int_hash<int, -1> { };\n \n@@ -246,5 +307,7 @@ struct attr_access;\n typedef hash_map<rdwr_access_hash, attr_access> rdwr_map;\n \n extern void init_attr_rdwr_indices (rdwr_map *, tree);\n+extern attr_access *get_parm_access (rdwr_map &, tree,\n+\t\t\t\t     tree = current_function_decl);\n \n #endif // GCC_ATTRIBS_H"}, {"sha": "70b00037d987562934648da5cbd38ee1cf034922", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 446, "deletions": 133, "changes": 579, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -17,6 +17,7 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+#define INCLUDE_STRING\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -45,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"opts.h\"\n #include \"gimplify.h\"\n #include \"tree-pretty-print.h\"\n+#include \"gcc-rich-location.h\"\n \n static tree handle_packed_attribute (tree *, tree, tree, int, bool *);\n static tree handle_nocommon_attribute (tree *, tree, tree, int, bool *);\n@@ -136,6 +138,7 @@ static tree handle_target_clones_attribute (tree *, tree, tree, int, bool *);\n static tree handle_optimize_attribute (tree *, tree, tree, int, bool *);\n static tree ignore_attribute (tree *, tree, tree, int, bool *);\n static tree handle_no_split_stack_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_argspec_attribute (tree *, tree, tree, int, bool *);\n static tree handle_fnspec_attribute (tree *, tree, tree, int, bool *);\n static tree handle_warn_unused_attribute (tree *, tree, tree, int, bool *);\n static tree handle_returns_nonnull_attribute (tree *, tree, tree, int, bool *);\n@@ -434,6 +437,10 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      ignore_attribute, NULL },\n   { \"no_split_stack\",\t      0, 0, true,  false, false, false,\n \t\t\t      handle_no_split_stack_attribute, NULL },\n+  /* For internal use only (marking of function arguments).\n+     The name contains a space to prevent its usage in source code.  */\n+  { \"arg spec\",\t\t      1, -1, true, false, false, false,\n+\t\t\t      handle_argspec_attribute, NULL },\n   /* For internal use (marking of builtins and runtime functions) only.\n      The name contains space to prevent its usage in source code.  */\n   { \"fn spec\",\t\t      1, 1, false, true, true, false,\n@@ -3180,8 +3187,22 @@ handle_assume_aligned_attribute (tree *node, tree name, tree args, int,\n   return NULL_TREE;\n }\n \n-/* Handle a \"fn spec\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n+/* Handle the internal-only \"arg spec\" attribute.  */\n+\n+static tree\n+handle_argspec_attribute (tree *, tree, tree args, int, bool *)\n+{\n+  /* Verify the attribute has one or two arguments and their kind.  */\n+  gcc_assert (args && TREE_CODE (TREE_VALUE (args)) == STRING_CST);\n+  for (tree next = TREE_CHAIN (args); next; next = TREE_CHAIN (next))\n+    {\n+      tree val = TREE_VALUE (next);\n+      gcc_assert (DECL_P (val) || EXPR_P (val));\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Handle the internal-only \"fn spec\" attribute.  */\n \n static tree\n handle_fnspec_attribute (tree *node ATTRIBUTE_UNUSED, tree ARG_UNUSED (name),\n@@ -3967,151 +3988,280 @@ get_argument_type (tree functype, unsigned argno, unsigned *nargs)\n \t  tree argtype = function_args_iter_cond (&iter);\n \t  if (VOID_TYPE_P (argtype))\n \t    break;\n-\t  return argtype;\n+\t  if (argtype != error_mark_node)\n+\t    return argtype;\n \t}\n     }\n \n   *nargs = count;\n   return NULL_TREE;\n }\n \n-/* Appends ATTRSTR to the access string in ATTRS if one is there\n-   or creates a new one and returns the concatenated access string.  */\n+/* Given a function FNDECL return the function argument at the zero-\n+   based position ARGNO or null if it can't be found.  */\n \n static tree\n-append_access_attrs (tree t, tree attrs, const char *attrstr,\n-\t\t     char code, HOST_WIDE_INT idxs[2])\n+get_argument (tree fndecl, unsigned argno)\n {\n-  char attrspec[80];\n-  int n1 = sprintf (attrspec, \"%c%u\", code, (unsigned) idxs[0] - 1);\n-  int n2 = 0;\n-  if (idxs[1])\n-    n2 = sprintf (attrspec + n1 + 1, \"%u\", (unsigned) idxs[1] - 1);\n+  if (!DECL_P (fndecl))\n+    return NULL_TREE;\n \n-  size_t newlen = n1 + n2 + !!n2;\n-  char *newspec = attrspec;\n+  unsigned i = 0;\n+  for (tree arg = DECL_ARGUMENTS (fndecl); arg; arg = TREE_CHAIN (arg))\n+    if (i++ == argno)\n+      return arg;\n \n-  if (tree acs = lookup_attribute (\"access\", attrs))\n-    {\n-      /* The TREE_VALUE of an attribute is a TREE_LIST whose TREE_VALUE\n-\t is the attribute argument's value.  */\n-      acs = TREE_VALUE (acs);\n-      gcc_assert (TREE_CODE (acs) == TREE_LIST);\n-      acs = TREE_VALUE (acs);\n-      gcc_assert (TREE_CODE (acs) == STRING_CST);\n+  return NULL_TREE;\n+}\n \n-      /* Check to make sure ATTRSPEC doesn't conflict with another\n-\t access attribute specified in ATTRS by searching the access\n-\t string in ATTRS for the position string formatted above into\n-\t ATTRSPEC, and if it's found, that the two match.  */\n+/* Attempt to append attribute access specification ATTRSPEC, optionally\n+   described by the human-readable string ATTRSTR, for type T, to one in\n+   ATTRS. VBLIST is an optional list of bounds of variable length array\n+   parameters described by ATTRSTR.\n+   Issue warning for conflicts and return null if any are found.\n+   Return the concatenated access string on success.  */\n \n-      const char *posstr = attrspec + 1;\n-      const char *str = TREE_STRING_POINTER (acs);\n-      const char *pos = str;\n-      for ( ; ; pos += n1)\n+static tree\n+append_access_attr (tree node[3], tree attrs, const char *attrstr,\n+\t\t    const char *attrspec, tree vblist = NULL_TREE)\n+{\n+  tree argstr = build_string (strlen (attrspec) + 1, attrspec);\n+  tree ataccess = tree_cons (NULL_TREE, argstr, vblist);\n+  ataccess = tree_cons (get_identifier (\"access\"), ataccess, NULL_TREE);\n+\n+  /* The access specification being applied.  This may be an implicit\n+     access spec synthesized for array (or VLA) parameters even for\n+     a declaration with an explicit access spec already applied, if\n+     this call corresponds to the first declaration of the function.  */\n+  rdwr_map new_idxs;\n+  init_attr_rdwr_indices (&new_idxs, ataccess);\n+\n+  /* The current access specification alrady applied.  */\n+  rdwr_map cur_idxs;\n+  init_attr_rdwr_indices (&cur_idxs, attrs);\n+\n+  std::string spec;\n+  for (auto it = new_idxs.begin (); it != new_idxs.end (); ++it)\n+    {\n+      const auto &newaxsref = *it;\n+\n+      /* The map has two equal entries for each pointer argument that\n+\t has an associated size argument.  Process just the entry for\n+\t the former.  */\n+      if ((unsigned)newaxsref.first != newaxsref.second.ptrarg)\n+\tcontinue;\n+\n+      const attr_access* const cura = cur_idxs.get (newaxsref.first);\n+      if (!cura)\n \t{\n-\t  pos = strstr (pos, posstr);\n-\t  if (!pos)\n-\t    break;\n+\t  /* The new attribute needs to be added.  */\n+\t  tree str = newaxsref.second.to_internal_string ();\n+\t  spec += TREE_STRING_POINTER (str);\n+\t  continue;\n+\t}\n+\n+      /* The new access spec refers to an array/pointer argument for\n+\t which an access spec already exists.  Check and diagnose any\n+\t conflicts.  If no conflicts are found, merge the two.  */\n+      const attr_access* const newa = &newaxsref.second;\n+\n+      if (!attrstr)\n+\t{\n+\t  tree str = NULL_TREE;\n+\t  if (newa->mode != access_deferred)\n+\t    str = newa->to_external_string ();\n+\t  else if (cura->mode != access_deferred)\n+\t    str = cura->to_external_string ();\n+\t  if (str)\n+\t    attrstr = TREE_STRING_POINTER (str);\n+\t}\n+\n+      location_t curloc = input_location;\n+      if (node[2] && DECL_P (node[2]))\n+\tcurloc = DECL_SOURCE_LOCATION (node[2]);\n+\n+      location_t prevloc = UNKNOWN_LOCATION;\n+      if (node[1] && DECL_P (node[1]))\n+\tprevloc = DECL_SOURCE_LOCATION (node[1]);\n+\n+      if (newa->mode != cura->mode\n+\t  && newa->mode != access_deferred\n+\t  && cura->mode != access_deferred\n+\t  && newa->internal_p == cura->internal_p)\n+\t{\n+\t  /* Mismatch in access mode.  */\n+\t  auto_diagnostic_group d;\n+\t  if (warning_at (curloc, OPT_Wattributes,\n+\t\t\t  \"attribute %qs mismatch with mode %qs\",\n+\t\t\t  attrstr, cura->mode_names[cura->mode])\n+\t      && prevloc != UNKNOWN_LOCATION)\n+\t    inform (prevloc, \"previous declaration here\");\n+\t  continue;\n+\t}\n+\n+      /* Set if PTRARG refers to a VLA with an unspecified bound (T[*]).\n+\t Be prepared for either CURA or NEWA to refer to it, depending\n+\t on which happens to come first in the declaration.  */\n+      const bool cur_vla_ub = (cura->internal_p\n+\t\t\t       && cura->sizarg == UINT_MAX\n+\t\t\t       && cura->minsize == HOST_WIDE_INT_M1U);\n+      const bool new_vla_ub = (newa->internal_p\n+\t\t\t       && newa->sizarg == UINT_MAX\n+\t\t\t       && newa->minsize == HOST_WIDE_INT_M1U);\n+\n+      if (newa->sizarg != cura->sizarg\n+\t  && attrstr\n+\t  && (!(cur_vla_ub ^ new_vla_ub)\n+\t      || (!cura->internal_p && !newa->internal_p)))\n+\t{\n+\t  /* Avoid diagnosing redeclarations of functions with no explicit\n+\t     attribute access that add one.  */\n+\t  if (newa->mode == access_deferred\n+\t      && cura->mode != access_deferred\n+\t      && newa->sizarg == UINT_MAX\n+\t      && cura->sizarg != UINT_MAX)\n+\t    continue;\n \n-\t  if (ISDIGIT (pos[-1]) || ISDIGIT (pos[n1 -1]))\n+\t  if (cura->mode == access_deferred\n+\t      && newa->mode != access_deferred\n+\t      && cura->sizarg == UINT_MAX\n+\t      && newa->sizarg != UINT_MAX)\n \t    continue;\n \n-\t  /* Found a matching positional argument.  */\n-\t  if (*attrspec != pos[-1])\n+\t  /* The two specs designate different size arguments.  It's okay\n+\t     for the explicit spec to specify a size where none is provided\n+\t     by the implicit (VLA) one, as in:\n+\t       __attribute__ ((access (read_write, 1, 2)))\n+\t       void f (int*, int);\n+\t     but not for two explicit access attributes to do that.  */\n+\t  bool warned = false;\n+\n+\t  auto_diagnostic_group d;\n+\n+\t  if (newa->sizarg == UINT_MAX)\n+\t    /* Mismatch in the presence of the size argument.  */\n+\t    warned = warning_at (curloc, OPT_Wattributes,\n+\t\t\t\t \"attribute %qs missing positional argument 2 \"\n+\t\t\t\t \"provided in previous designation by argument \"\n+\t\t\t\t \"%u\", attrstr, cura->sizarg + 1);\n+\t  else if (cura->sizarg == UINT_MAX)\n+\t    /* Mismatch in the presence of the size argument.  */\n+\t    warned = warning_at (curloc, OPT_Wattributes,\n+\t\t\t\t \"attribute %qs positional argument 2 \"\n+\t\t\t\t \"missing in previous designation\",\n+\t\t\t\t attrstr);\n+\t  else if (newa->internal_p || cura->internal_p)\n \t    {\n-\t      const char* const modestr\n-\t\t= (pos[-1] == 'r'\n-\t\t   ? \"read_only\"\n-\t\t   : (pos[-1] == 'w'\n-\t\t      ? \"write_only\"\n-\t\t      : (pos[-1] == 'x' ? \"read_write\" : \"none\")));\n-\t      /* Mismatch in access mode.  */\n-\t      auto_diagnostic_group d;\n-\t      if (warning (OPT_Wattributes,\n-\t\t\t   \"attribute %qs mismatch with mode %qs\",\n-\t\t\t   attrstr, modestr)\n-\t\t  && DECL_P (t))\n-\t\tinform (DECL_SOURCE_LOCATION (t),\n-\t\t\t\"previous declaration here\");\n-\t      return NULL_TREE;\n+\t      /* Mismatch in the value of the size argument and a VLA\n+\t\t bound.  */\n+\t      location_t argloc = curloc;\n+\t      if (tree arg = get_argument (node[2], newa->sizarg))\n+\t\targloc = DECL_SOURCE_LOCATION (arg);\n+\t      warned = warning_at (argloc, OPT_Wattributes,\n+\t\t\t\t   \"attribute %qs positional argument 2 \"\n+\t\t\t\t   \"conflicts with previous designation \"\n+\t\t\t\t   \"by argument %u\",\n+\t\t\t\t   attrstr, cura->sizarg + 1);\n \t    }\n-\n-\t  if ((n2 && pos[n1 - 1] != ','))\n+\t  else\n+\t    /* Mismatch in the value of the size argument between two\n+\t       explicit access attributes.  */\n+\t    warned = warning_at (curloc, OPT_Wattributes,\n+\t\t\t\t \"attribute %qs mismatched positional argument \"\n+\t\t\t\t \"values %i and %i\",\n+\t\t\t\t attrstr, newa->sizarg + 1, cura->sizarg + 1);\n+\n+\t  if (warned)\n \t    {\n-\t      /* Mismatch in the presence of the size argument.  */\n-\t      auto_diagnostic_group d;\n-\t      if (warning (OPT_Wattributes,\n-\t\t\t   \"attribute %qs positional argument 2 conflicts \"\n-\t\t\t   \"with previous designation\",\n-\t\t\t   attrstr)\n-\t\t  && DECL_P (t))\n-\t\tinform (DECL_SOURCE_LOCATION (t),\n-\t\t\t\"previous declaration here\");\n-\t      return NULL_TREE;\n-\t    }\n+\t      /* If the previous declaration is a function (as opposed\n+\t\t to a typedef of one), find the location of the array\n+\t\t or pointer argument that uses the conflicting VLA bound\n+\t\t and point to it in the note.  */\n+\t      const attr_access* const pa = cura->size ? cura : newa;\n+\t      tree size = pa->size ? TREE_VALUE (pa->size) : NULL_TREE;\n+\t      if (size && DECL_P (size))\n+\t\t{\n+\t\t  location_t argloc = UNKNOWN_LOCATION;\n+\t\t  if (tree arg = get_argument (node[2], pa->ptrarg))\n+\t\t    argloc = DECL_SOURCE_LOCATION (arg);\n \n-\t  if (!n2 && pos[n1 - 1] == ',')\n-\t    {\n-\t      /* Mismatch in the presence of the size argument.  */\n-\t      auto_diagnostic_group d;\n-\t      if (warning (OPT_Wattributes,\n-\t\t\t   \"attribute %qs missing positional argument 2 \"\n-\t\t\t   \"provided in previous designation\",\n-\t\t\t   attrstr)\n-\t\t  && DECL_P (t))\n-\t\tinform (DECL_SOURCE_LOCATION (t),\n-\t\t\t\"previous declaration here\");\n-\t      return NULL_TREE;\n-\t    }\n+\t\t  gcc_rich_location richloc (DECL_SOURCE_LOCATION (size));\n+\t\t  if (argloc != UNKNOWN_LOCATION)\n+\t\t    richloc.add_range (argloc);\n \n-\t  if (n2 && strncmp (attrspec + n1 + 1, pos + n1, n2))\n-\t    {\n-\t      /* Mismatch in the value of the size argument.  */\n-\t      auto_diagnostic_group d;\n-\t      if (warning (OPT_Wattributes,\n-\t\t\t   \"attribute %qs mismatched positional argument \"\n-\t\t\t   \"values %i and %i\",\n-\t\t\t   attrstr, atoi (attrspec + n1 + 1) + 1,\n-\t\t\t   atoi (pos + n1) + 1)\n-\t\t  && DECL_P (t))\n-\t\tinform (DECL_SOURCE_LOCATION (t),\n-\t\t\t\"previous declaration here\");\n-\t      return NULL_TREE;\n+\t\t  inform (&richloc, \"designating the bound of variable \"\n+\t\t\t  \"length array argument %u\",\n+\t\t\t  pa->ptrarg + 1);\n+\t\t}\n+\t      else if (prevloc != UNKNOWN_LOCATION)\n+\t\tinform (prevloc, \"previous declaration here\");\n \t    }\n \n-\t  /* Avoid adding the same attribute specification.  */\n-\t  return NULL_TREE;\n+\t  continue;\n \t}\n \n-      /* Connect the two substrings formatted above into a single one.  */\n-      if (idxs[1])\n-\tattrspec[n1] = ',';\n+      if (newa->internal_p == cura->internal_p)\n+\tcontinue;\n \n-      size_t len = strlen (str);\n-      newspec = XNEWVEC (char, newlen + len + 1);\n-      strcpy (newspec, str);\n-      strcpy (newspec + len, attrspec);\n-      newlen += len;\n+      /* Merge the CURA and NEWA.  */\n+      attr_access merged = newaxsref.second;\n+\n+      /* VLA seen in a declaration takes precedence.  */\n+      if (cura->minsize == HOST_WIDE_INT_M1U)\n+\tmerged.minsize = HOST_WIDE_INT_M1U;\n+\n+      /* Use the explicitly specified size positional argument.  */\n+      if (cura->sizarg != UINT_MAX)\n+\tmerged.sizarg = cura->sizarg;\n+\n+      /* Use the explicitly specified mode.  */\n+      if (merged.mode == access_deferred)\n+\tmerged.mode = cura->mode;\n+\n+      tree str = merged.to_internal_string ();\n+      spec += TREE_STRING_POINTER (str);\n     }\n-  else if (idxs[1])\n-    /* Connect the two substrings formatted above into a single one.  */\n-    attrspec[n1] = ',';\n \n-  tree ret = build_string (newlen + 1, newspec);\n-  if (newspec != attrspec)\n-    XDELETEVEC (newspec);\n-  return ret;\n+  if (!spec.length ())\n+    return NULL_TREE;\n+\n+  return build_string (spec.length (), spec.c_str ());\n }\n \n-/* Handle the access attribute (read_only, write_only, and read_write).  */\n+/* Convenience wrapper for the above.  */\n+\n+tree\n+append_access_attr (tree node[3], tree attrs, const char *attrstr,\n+\t\t    char code, HOST_WIDE_INT idxs[2])\n+{\n+  char attrspec[80];\n+  int n = sprintf (attrspec, \"%c%u\", code, (unsigned) idxs[0] - 1);\n+  if (idxs[1])\n+    n += sprintf (attrspec + n, \",%u\", (unsigned) idxs[1] - 1);\n+\n+  return append_access_attr (node, attrs, attrstr, attrspec);\n+}\n+\n+/* Handle the access attribute for function type NODE[0], with the function\n+   DECL optionally in NODE[1].  The handler is called both in response to\n+   an explict attribute access on a declaration with a mode and one or two\n+   positional arguments, and for internally synthesized access specifications\n+   with a string argument optionally followd by a DECL or expression\n+   representing a VLA bound.  To speed up parsing, the handler transforms\n+   the attribute and its arguments into a string.  */\n \n static tree\n-handle_access_attribute (tree *node, tree name, tree args,\n+handle_access_attribute (tree node[3], tree name, tree args,\n \t\t\t int ARG_UNUSED (flags), bool *no_add_attrs)\n {\n+  tree attrs = TYPE_ATTRIBUTES (*node);\n   tree type = *node;\n-  tree attrs = TYPE_ATTRIBUTES (type);\n+  if (POINTER_TYPE_P (type))\n+    {\n+      tree ptype = TREE_TYPE (type);\n+      if (FUNC_OR_METHOD_TYPE_P (ptype))\n+\ttype = ptype;\n+    }\n \n   *no_add_attrs = true;\n \n@@ -4129,9 +4279,32 @@ handle_access_attribute (tree *node, tree name, tree args,\n   tree access_mode = TREE_VALUE (args);\n   if (TREE_CODE (access_mode) == STRING_CST)\n     {\n-      /* This must be a recursive call to handle the condensed internal\n-\t form of the attribute (see below).  Since all validation has\n-\t been done simply return here, accepting the attribute as is.  */\n+      const char* const str = TREE_STRING_POINTER (access_mode);\n+      if (*str == '+')\n+\t{\n+\t  /* This is a request to merge an internal specification for\n+\t     a function declaration involving arrays but no explicit\n+\t     attribute access.  */\n+\t  tree vblist = TREE_CHAIN (args);\n+\t  tree axstr = append_access_attr (node, attrs, NULL, str + 1,\n+\t\t\t\t\t   vblist);\n+\t  if (!axstr)\n+\t    return NULL_TREE;\n+\n+\t  /* Replace any existing access attribute specification with\n+\t     the concatenation above.  */\n+\t  tree axsat = tree_cons (NULL_TREE, axstr, vblist);\n+\t  axsat = tree_cons (name, axsat, NULL_TREE);\n+\n+\t  /* Recursively call self to \"replace\" the documented/external\n+\t     form of the attribute with the condensend internal form.  */\n+\t  decl_attributes (node, axsat, flags);\n+\t  return NULL_TREE;\n+\t}\n+\n+      /* This is a recursive call to handle the condensed internal form\n+\t of the attribute (see below).  Since all validation has been\n+\t done simply return here, accepting the attribute as is.  */\n       *no_add_attrs = false;\n       return NULL_TREE;\n     }\n@@ -4162,16 +4335,27 @@ handle_access_attribute (tree *node, tree name, tree args,\n \tps += 2;\n     }\n \n-  const bool read_only = !strncmp (ps, \"read_only\", 9);\n-  const bool write_only = !strncmp (ps, \"write_only\", 10);\n-  const bool read_write = !strncmp (ps, \"read_write\", 10);\n-  if (!read_only && !write_only && !read_write && strncmp (ps, \"none\", 4))\n-    {\n-      error (\"attribute %qE invalid mode %qs; expected one of \"\n-\t     \"%qs, %qs, %qs, or %qs\", name, access_str,\n-\t     \"read_only\", \"read_write\", \"write_only\", \"none\");\n-      return NULL_TREE;\n-    }\n+  int imode;\n+\n+  {\n+    const int nmodes =\n+      sizeof attr_access::mode_names / sizeof *attr_access::mode_names;\n+\n+    for (imode = 0; imode != nmodes; ++imode)\n+      if (!strncmp (ps, attr_access::mode_names[imode],\n+\t\t    strlen (attr_access::mode_names[imode])))\n+\tbreak;\n+\n+    if (imode == nmodes)\n+      {\n+\terror (\"attribute %qE invalid mode %qs; expected one of \"\n+\t       \"%qs, %qs, %qs, or %qs\", name, access_str,\n+\t       \"read_only\", \"read_write\", \"write_only\", \"none\");\n+\treturn NULL_TREE;\n+      }\n+  }\n+\n+  const ::access_mode mode = static_cast<::access_mode>(imode);\n \n   if (funcall)\n     {\n@@ -4294,7 +4478,7 @@ handle_access_attribute (tree *node, tree name, tree args,\n       }\n   }\n \n-  if (read_write || write_only)\n+  if (mode == access_read_write || mode == access_write_only)\n     {\n       /* Read_write and write_only modes must reference non-const\n \t arguments.  */\n@@ -4327,35 +4511,164 @@ handle_access_attribute (tree *node, tree name, tree args,\n   /* Verify that the new attribute doesn't conflict with any existing\n      attributes specified on previous declarations of the same type\n      and if not, concatenate the two.  */\n-  const char code\n-    = read_only ? 'r' : write_only ? 'w' : read_write ? 'x' : '-';\n-  tree new_attrs = append_access_attrs (node[0], attrs, attrstr, code, idxs);\n+  const char code = attr_access::mode_chars[mode];\n+  tree new_attrs = append_access_attr (node, attrs, attrstr, code, idxs);\n   if (!new_attrs)\n     return NULL_TREE;\n \n   /* Replace any existing access attribute specification with\n      the concatenation above.  */\n   new_attrs = tree_cons (NULL_TREE, new_attrs, NULL_TREE);\n-  new_attrs = tree_cons (name, new_attrs, attrs);\n+  new_attrs = tree_cons (name, new_attrs, NULL_TREE);\n \n   if (node[1])\n     {\n       /* Repeat for the previously declared type.  */\n       attrs = TYPE_ATTRIBUTES (TREE_TYPE (node[1]));\n-      tree attrs1 = append_access_attrs (node[1], attrs, attrstr, code, idxs);\n-      if (!attrs1)\n+      new_attrs = append_access_attr (node, attrs, attrstr, code, idxs);\n+      if (!new_attrs)\n \treturn NULL_TREE;\n \n-      attrs1 = tree_cons (NULL_TREE, attrs1, NULL_TREE);\n-      new_attrs = tree_cons (name, attrs1, attrs);\n+      new_attrs = tree_cons (NULL_TREE, new_attrs, NULL_TREE);\n+      new_attrs = tree_cons (name, new_attrs, NULL_TREE);\n     }\n \n   /* Recursively call self to \"replace\" the documented/external form\n-     of the attribute with the condensend internal form.  */\n+     of the attribute with the condensed internal form.  */\n   decl_attributes (node, new_attrs, flags);\n   return NULL_TREE;\n }\n \n+/* Extract attribute \"arg spec\" from each FNDECL argument that has it,\n+   build a single attribute access corresponding to all the arguments,\n+   and return the result.  SKIP_VOIDPTR set to ignore void* parameters\n+   (used for user-defined functions for which, unlike in for built-ins,\n+   void* cannot be relied on to determine anything about the access\n+   through it or whether it even takes place).\n+\n+   For example, the parameters in the declaration:\n+\n+     void f (int x, int y, char [x][1][y][3], char [y][2][y][5]);\n+\n+   result in the following attribute access:\n+\n+     value: \"+^2[*],$0$1^3[*],$1$1\"\n+     chain: <0, x> <1, y>\n+\n+   where each <node> on the chain corresponds to one VLA bound for each\n+   of the two parameters.  */\n+\n+tree\n+build_attr_access_from_parms (tree parms, bool skip_voidptr)\n+{\n+  /* Maps each named integral argument DECL seen so far to its position\n+     in the argument list; used to associate VLA sizes with arguments.  */\n+  hash_map<tree, unsigned> arg2pos;\n+\n+  /* The string representation of the access specification for all\n+     arguments.  */\n+  std::string spec;\n+  unsigned argpos = 0;\n+\n+  /* A TREE_LIST of VLA bounds.  */\n+  tree vblist = NULL_TREE;\n+\n+  for (tree arg = parms; arg; arg = TREE_CHAIN (arg), ++argpos)\n+    {\n+      if (!DECL_P (arg))\n+\tcontinue;\n+\n+      tree argtype = TREE_TYPE (arg);\n+      if (DECL_NAME (arg) && INTEGRAL_TYPE_P (argtype))\n+\targ2pos.put (arg, argpos);\n+\n+      tree argspec = DECL_ATTRIBUTES (arg);\n+      if (!argspec)\n+\tcontinue;\n+\n+      if (POINTER_TYPE_P (argtype))\n+\t{\n+\t  /* void* arguments in user-defined functions could point to\n+\t     anything; skip them.  */\n+\t  tree reftype = TREE_TYPE (argtype);\n+\t  if (skip_voidptr && VOID_TYPE_P (reftype))\n+\t    continue;\n+\t}\n+\n+      /* Each parameter should have at most one \"arg spec\" attribute.  */\n+      argspec = lookup_attribute (\"arg spec\", argspec);\n+      if (!argspec)\n+\tcontinue;\n+\n+      /* Attribute arg spec should have one or two arguments.  */\n+      argspec = TREE_VALUE (argspec);\n+\n+      /* The attribute arg spec string.  */\n+      tree str = TREE_VALUE (argspec);\n+      const char *s = TREE_STRING_POINTER (str);\n+\n+      /* Create the attribute access string from the arg spec string,\n+\t optionally followed by position of the VLA bound argument if\n+\t it is one.  */\n+      char specbuf[80];\n+      int len = snprintf (specbuf, sizeof specbuf, \"%c%u%s\",\n+\t\t\t  attr_access::mode_chars[access_deferred],\n+\t\t\t  argpos, s);\n+      gcc_assert ((size_t) len < sizeof specbuf);\n+\n+      if (!spec.length ())\n+\tspec += '+';\n+\n+      spec += specbuf;\n+\n+      /* The (optional) list of expressions denoting the VLA bounds\n+\t N in ARGTYPE <arg>[Ni]...[Nj]...[Nk].  */\n+      tree argvbs = TREE_CHAIN (argspec);\n+      if (argvbs)\n+\t{\n+\t  spec += ',';\n+\t  /* Add ARGVBS to the list.  Their presence is indicated by\n+\t     appending a comma followed by the dollar sign and, when\n+\t     it corresponds to a function parameter, the position of\n+\t     each bound Ni, so it can be distinguished from\n+\t     an unspecified bound (as in T[*]).  The list is in reverse\n+\t     order of arguments and needs to be reversed to access in\n+\t     order.  */\n+\t  vblist = tree_cons (NULL_TREE, argvbs, vblist);\n+\n+\t  unsigned nelts = 0;\n+\t  for (tree vb = argvbs; vb; vb = TREE_CHAIN (vb), ++nelts)\n+\t    {\n+\t      tree bound = TREE_VALUE (vb);\n+\t      if (const unsigned *psizpos = arg2pos.get (bound))\n+\t\t{\n+\t\t  /* BOUND previously seen in the parameter list.  */\n+\t\t  TREE_PURPOSE (vb) = size_int (*psizpos);\n+\t\t  sprintf (specbuf, \"$%u\", *psizpos);\n+\t\t  spec += specbuf;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* BOUND doesn't name a parameter (it could be a global\n+\t\t     variable or an expression such as a function call).  */\n+\t\t  spec += '$';\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (!spec.length ())\n+    return NULL_TREE;\n+\n+  /* Build a single attribute access with the string describing all\n+     array arguments and an optional list of any non-parameter VLA\n+     bounds in order.  */\n+  tree str = build_string (spec.length (), spec.c_str ());\n+  tree attrargs = tree_cons (NULL_TREE, str, vblist);\n+  tree name = get_identifier (\"access\");\n+  return tree_cons (name, attrargs, NULL_TREE);\n+}\n+\n /* Handle a \"nothrow\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "3d96092a2970d1c0fdf1c27584c800ae6d737f1d", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -1372,6 +1372,7 @@ extern void c_do_switch_warnings (splay_tree, location_t, tree, tree, bool);\n extern void warn_for_omitted_condop (location_t, tree);\n extern bool warn_for_restrict (unsigned, tree *, unsigned);\n extern void warn_for_address_or_pointer_of_packed_member (tree, tree);\n+extern void warn_parm_array_mismatch (location_t, tree, tree);\n \n /* Places where an lvalue, or modifiable lvalue, may be required.\n    Used to select diagnostic messages in lvalue_error and\n@@ -1426,6 +1427,8 @@ extern tree find_tm_attribute (tree);\n extern const struct attribute_spec::exclusions attr_cold_hot_exclusions[];\n extern const struct attribute_spec::exclusions attr_noreturn_exclusions[];\n extern tree handle_noreturn_attribute (tree *, tree, tree, int, bool *);\n+extern bool has_attribute (location_t, tree, tree, tree (*)(tree));\n+extern tree build_attr_access_from_parms (tree, bool);\n \n /* In c-format.c.  */\n extern bool valid_format_string_type_p (tree);\n@@ -1454,8 +1457,6 @@ extern void maybe_suggest_missing_token_insertion (rich_location *richloc,\n \t\t\t\t\t\t   location_t prev_token_loc);\n extern tree braced_lists_to_strings (tree, tree);\n \n-extern bool has_attribute (location_t, tree, tree, tree (*)(tree));\n-\n #if CHECKING_P\n namespace selftest {\n   /* Declarations for specific families of tests within c-family,"}, {"sha": "acffd7b872cb89e5f13a2113963528dace682d2c", "filename": "gcc/c-family/c-pretty-print.c", "status": "modified", "additions": 57, "deletions": 4, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fc-family%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fc-family%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.c?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -248,9 +248,12 @@ pp_c_type_qualifier_list (c_pretty_printer *pp, tree t)\n   if (!TYPE_P (t))\n     t = TREE_TYPE (t);\n \n-  qualifiers = TYPE_QUALS (t);\n-  pp_c_cv_qualifiers (pp, qualifiers,\n-\t\t      TREE_CODE (t) == FUNCTION_TYPE);\n+  if (TREE_CODE (t) != ARRAY_TYPE)\n+    {\n+      qualifiers = TYPE_QUALS (t);\n+      pp_c_cv_qualifiers (pp, qualifiers,\n+\t\t\t  TREE_CODE (t) == FUNCTION_TYPE);\n+    }\n \n   if (!ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (t)))\n     {\n@@ -572,6 +575,8 @@ c_pretty_printer::abstract_declarator (tree t)\n void\n c_pretty_printer::direct_abstract_declarator (tree t)\n {\n+  bool add_space = false;\n+\n   switch (TREE_CODE (t))\n     {\n     case POINTER_TYPE:\n@@ -585,17 +590,65 @@ c_pretty_printer::direct_abstract_declarator (tree t)\n \n     case ARRAY_TYPE:\n       pp_c_left_bracket (this);\n+\n+      if (int quals = TYPE_QUALS (t))\n+\t{\n+\t  /* Print the array qualifiers such as in \"T[const restrict 3]\".  */\n+\t  pp_c_cv_qualifiers (this, quals, false);\n+\t  add_space = true;\n+\t}\n+\n+      if (tree arr = lookup_attribute (\"array\", TYPE_ATTRIBUTES (t)))\n+\t{\n+\t  if (TREE_VALUE (arr))\n+\t    {\n+\t      /* Print the specifier as in \"T[static 3]\" that's not actually\n+\t\t part of the type but may be added by the front end.  */\n+\t      pp_c_ws_string (this, \"static\");\n+\t      add_space = true;\n+\t    }\n+\t  else if (!TYPE_DOMAIN (t))\n+\t    /* For arrays of unspecified bound using the [*] notation. */\n+\t    pp_character (this, '*');\n+\t}\n+\n       if (tree dom = TYPE_DOMAIN (t))\n \t{\n \t  if (tree maxval = TYPE_MAX_VALUE (dom))\n \t    {\n+\t      if (add_space)\n+\t\tpp_space (this);\n+\n \t      tree type = TREE_TYPE (maxval);\n \n \t      if (tree_fits_shwi_p (maxval))\n \t\tpp_wide_integer (this, tree_to_shwi (maxval) + 1);\n-\t      else\n+\t      else if (TREE_CODE (maxval) == INTEGER_CST)\n \t\texpression (fold_build2 (PLUS_EXPR, type, maxval,\n \t\t\t\t\t build_int_cst (type, 1)));\n+\t      else\n+\t\t{\n+\t\t  /* Strip the expressions from around a VLA bound added\n+\t\t     internally to make it fit the domain mold, including\n+\t\t     any casts.  */\n+\t\t  if (TREE_CODE (maxval) == NOP_EXPR)\n+\t\t    maxval = TREE_OPERAND (maxval, 0);\n+\t\t  if (TREE_CODE (maxval) == PLUS_EXPR\n+\t\t      && integer_all_onesp (TREE_OPERAND (maxval, 1)))\n+\t\t    {\n+\t\t      maxval = TREE_OPERAND (maxval, 0);\n+\t\t      if (TREE_CODE (maxval) == NOP_EXPR)\n+\t\t\tmaxval = TREE_OPERAND (maxval, 0);\n+\t\t    }\n+\t\t  if (TREE_CODE (maxval) == SAVE_EXPR)\n+\t\t    {\n+\t\t      maxval = TREE_OPERAND (maxval, 0);\n+\t\t      if (TREE_CODE (maxval) == NOP_EXPR)\n+\t\t\tmaxval = TREE_OPERAND (maxval, 0);\n+\t\t    }\n+\n+\t\t  expression (maxval);\n+\t\t}\n \t    }\n \t  else if (TYPE_SIZE (t))\n \t    /* Print zero for zero-length arrays but not for flexible"}, {"sha": "d6db85b6de551a041dc0b3772df5c5dd83de6db8", "filename": "gcc/c-family/c-warn.c", "status": "modified", "additions": 561, "deletions": 0, "changes": 561, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fc-family%2Fc-warn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fc-family%2Fc-warn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-warn.c?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -17,6 +17,7 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+#define INCLUDE_STRING\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -37,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-family/c-spellcheck.h\"\n #include \"calls.h\"\n #include \"stor-layout.h\"\n+#include \"tree-pretty-print.h\"\n \n /* Print a warning if a constant expression had overflow in folding.\n    Invoke this function on every expression that the language\n@@ -3099,3 +3101,562 @@ warn_for_address_or_pointer_of_packed_member (tree type, tree rhs)\n \n   check_and_warn_address_or_pointer_of_packed_member (type, rhs);\n }\n+\n+/* Return EXPR + 1.  Convenience helper used below.  */\n+\n+static inline tree\n+plus_one (tree expr)\n+{\n+  tree type = TREE_TYPE (expr);\n+  return fold_build2 (PLUS_EXPR, type, expr, build_int_cst (type, 1));\n+}\n+\n+/* Try to strip the expressions from around a VLA bound added internally\n+   to make it fit the domain mold, including any casts, and return\n+   the result.  The goal is to obtain the PARM_DECL the VLA bound may\n+   refer to.  */\n+\n+static tree\n+vla_bound_parm_decl (tree expr)\n+{\n+  if (!expr)\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (expr) == NOP_EXPR)\n+    expr = TREE_OPERAND (expr, 0);\n+  if (TREE_CODE (expr) == PLUS_EXPR\n+      && integer_all_onesp (TREE_OPERAND (expr, 1)))\n+    {\n+      expr = TREE_OPERAND (expr, 0);\n+      if (TREE_CODE (expr) == NOP_EXPR)\n+\texpr = TREE_OPERAND (expr, 0);\n+    }\n+  if (TREE_CODE (expr) == SAVE_EXPR)\n+    {\n+      expr = TREE_OPERAND (expr, 0);\n+      if (TREE_CODE (expr) == NOP_EXPR)\n+\texpr = TREE_OPERAND (expr, 0);\n+    }\n+  return expr;\n+}\n+\n+/* Diagnose mismatches in VLA bounds between function parameters NEWPARMS\n+   of pointer types on a redeclaration os a function previously declared\n+   with CURPARMS at ORIGLOC.  */\n+\n+static void\n+warn_parm_ptrarray_mismatch (location_t origloc, tree curparms, tree newparms)\n+{\n+  /* Maps each named integral parameter seen so far to its position\n+     in the argument list; used to associate VLA sizes with arguments.  */\n+  hash_map<tree, unsigned> curparm2pos;\n+  hash_map<tree, unsigned> newparm2pos;\n+\n+  unsigned parmpos = 1;\n+  for (tree curp = curparms, newp = newparms; curp && newp;\n+       curp = TREE_CHAIN (curp), newp = TREE_CHAIN (newp), ++parmpos)\n+    {\n+      tree curtyp = TREE_TYPE (curp), newtyp = TREE_TYPE (newp);\n+      if (INTEGRAL_TYPE_P (curtyp))\n+\t{\n+\t  /* Only add named parameters; unnamed ones cannot be referred\n+\t     to in VLA bounds.  */\n+\t  if (DECL_NAME (curp))\n+\t    curparm2pos.put (curp, parmpos);\n+\t  if (DECL_NAME (newp))\n+\t    newparm2pos.put (newp, parmpos);\n+\n+\t  continue;\n+\t}\n+\n+      /* The parameter types should match at this point so only test one.  */\n+      if (TREE_CODE (curtyp) != POINTER_TYPE)\n+\tcontinue;\n+\n+      do\n+\t{\n+\t  curtyp = TREE_TYPE (curtyp);\n+\t  newtyp = TREE_TYPE (newtyp);\n+\t}\n+      while (TREE_CODE (curtyp) == POINTER_TYPE\n+\t     && TREE_CODE (newtyp) == POINTER_TYPE);\n+\n+      if (TREE_CODE (curtyp) != ARRAY_TYPE\n+\t  || TREE_CODE (newtyp) != ARRAY_TYPE)\n+\t{\n+\t  if (curtyp == error_mark_node\n+\t      || newtyp == error_mark_node)\n+\t    return;\n+\n+\t  continue;\n+\t}\n+\n+      tree curdom = TYPE_DOMAIN (curtyp), newdom = TYPE_DOMAIN (newtyp);\n+      tree curbnd = curdom ? TYPE_MAX_VALUE (curdom) : NULL_TREE;\n+      tree newbnd = newdom ? TYPE_MAX_VALUE (newdom) : NULL_TREE;\n+\n+      if (DECL_P (curp))\n+\torigloc = DECL_SOURCE_LOCATION (curp);\n+      else if (EXPR_P (curp) && EXPR_HAS_LOCATION (curp))\n+\torigloc = EXPR_LOCATION (curp);\n+\n+      /* The location of the parameter in the current redeclaration.  */\n+      location_t newloc = DECL_SOURCE_LOCATION (newp);\n+      if (origloc == UNKNOWN_LOCATION)\n+\torigloc = newloc;\n+\n+      /* Issue -Warray-parameter onless one or more mismatches involves\n+\t a VLA bound; then issue -Wvla-parameter.  */\n+      int opt = OPT_Warray_parameter_;\n+      /* Traverse the two array types looking for variable bounds and\n+\t comparing the two in each pair for mismatches either in their\n+\t positions in the function parameter list or lexicographically\n+\t for others.  Record the 1-based parameter position of each\n+\t mismatch in BNDVEC, and the location of each parameter in\n+\t the mismatch in WARNLOC (for the new parameter list) and\n+\t NOTELOC (for the current parameter list).  */\n+      unsigned bndpos = 1;\n+      auto_vec<int> bndvec;\n+      gcc_rich_location warnloc (newloc);\n+      gcc_rich_location noteloc (origloc);\n+      for ( ; curtyp || newtyp;\n+\t    ++bndpos,\n+\t      curbnd = curdom ? TYPE_MAX_VALUE (curdom) : NULL_TREE,\n+\t      newbnd = newdom ? TYPE_MAX_VALUE (newdom) : NULL_TREE)\n+\t{\n+\t  /* Try to strip each bound down to the PARM_DECL if it does\n+\t     correspond to one.  Either bound can be null if it's\n+\t     unspecified (i.e., has the [*] form).  */\n+\t  curbnd = vla_bound_parm_decl (curbnd);\n+\t  newbnd = vla_bound_parm_decl (newbnd);\n+\n+\t  /* Peel the current bound off CURTYP and NEWTYP, skipping\n+\t     over any subsequent pointer types.  */\n+\t  if (curtyp && TREE_CODE (curtyp) == ARRAY_TYPE)\n+\t    {\n+\t      do\n+\t\tcurtyp = TREE_TYPE (curtyp);\n+\t      while (TREE_CODE (curtyp) == POINTER_TYPE);\n+\t      if (TREE_CODE (curtyp) == ARRAY_TYPE)\n+\t\tcurdom = TYPE_DOMAIN (curtyp);\n+\t      else\n+\t\tcurdom = NULL_TREE;\n+\t    }\n+\t  else\n+\t    curtyp = NULL_TREE;\n+\n+\t  if (newtyp && TREE_CODE (newtyp) == ARRAY_TYPE)\n+\t    {\n+\t      do\n+\t\tnewtyp = TREE_TYPE (newtyp);\n+\t      while (TREE_CODE (newtyp) == POINTER_TYPE);\n+\t      if (TREE_CODE (newtyp) == ARRAY_TYPE)\n+\t\tnewdom = TYPE_DOMAIN (newtyp);\n+\t      else\n+\t\tnewdom = NULL_TREE;\n+\t    }\n+\t  else\n+\t    newtyp = NULL_TREE;\n+\n+\t  /* Move on to the next bound if this one is unspecified.  */\n+\t  if (!curbnd && !newbnd)\n+\t    continue;\n+\n+\t  /* Try to find each bound in the parameter list.  */\n+\t  const unsigned* const pcurbndpos = curparm2pos.get (curbnd);\n+\t  const unsigned* const pnewbndpos = newparm2pos.get (newbnd);\n+\t  /* Move on if both bounds refer to the same parameter.  */\n+\t  if (pcurbndpos && pnewbndpos && *pcurbndpos == *pnewbndpos)\n+\t    continue;\n+\n+\t  /* Move on if the bounds look the same.  */\n+\t  if (!pcurbndpos && !pnewbndpos\n+\t      && curbnd && newbnd\n+\t      && operand_equal_p (curbnd, newbnd, OEP_LEXICOGRAPHIC))\n+\t    continue;\n+\n+\t  if ((curbnd && TREE_CODE (curbnd) != INTEGER_CST)\n+\t      || (newbnd && TREE_CODE (newbnd) != INTEGER_CST))\n+\t    opt = OPT_Wvla_parameter;\n+\n+\t  /* Record the mismatch.  */\n+\t  bndvec.safe_push (bndpos);\n+\t  /* Underline the bounding parameter in the declaration.  */\n+\t  if (curbnd && TREE_CODE (curbnd) == PARM_DECL)\n+\t    noteloc.add_range (DECL_SOURCE_LOCATION (curbnd));\n+\t  if (newbnd && TREE_CODE (newbnd) == PARM_DECL)\n+\t    warnloc.add_range (DECL_SOURCE_LOCATION (newbnd));\n+\t}\n+\n+      const unsigned nbnds = bndvec.length ();\n+      if (!nbnds)\n+\tcontinue;\n+\n+      /* Use attr_access to format the parameter types.  */\n+      attr_access spec = { };\n+      const std::string newparmstr = spec.array_as_string (TREE_TYPE (newp));\n+      const std::string curparmstr = spec.array_as_string (TREE_TYPE (curp));\n+\n+      if (warning_n (&warnloc, opt, nbnds,\n+\t\t     \"mismatch in bound %Z of argument %u declared as %s\",\n+\t\t     \"mismatch in bounds %Z of argument %u declared as %s\",\n+\t\t     bndvec.address (), nbnds, parmpos, newparmstr.c_str ()))\n+\tinform (&noteloc, \"previously declared as %s\",\tcurparmstr.c_str ());\n+    }\n+}\n+\n+/* Detect and diagnose a mismatch between an attribute access specification\n+   on the original declaration of FNDECL and that on the parameters NEWPARMS\n+   from its refeclaration.  ORIGLOC is the location of the first declaration\n+   (FNDECL's is set to the location of the redeclaration).  */\n+\n+void\n+warn_parm_array_mismatch (location_t origloc, tree fndecl, tree newparms)\n+{\n+    /* The original parameter list (copied from the original declaration\n+       into the current [re]declaration, FNDECL)).  The two are equal if\n+       and only if FNDECL is the first declaratation.  */\n+  tree curparms = DECL_ARGUMENTS (fndecl);\n+  if (!curparms || !newparms || curparms == newparms)\n+    return;\n+\n+  if (TREE_CODE (curparms) != PARM_DECL\n+      || TREE_CODE (newparms) != PARM_DECL)\n+    return;\n+  /* Extract the (possibly empty) attribute access specification from\n+     the declaration and its type (it doesn't yet reflect those created\n+     in response to NEWPARMS).  */\n+  rdwr_map cur_idx;\n+  tree fntype = TREE_TYPE (fndecl);\n+  init_attr_rdwr_indices (&cur_idx, TYPE_ATTRIBUTES (fntype));\n+\n+  /* Build a (possibly null) chain of access attributes corresponding\n+     to NEWPARMS.  */\n+  const bool builtin = fndecl_built_in_p (fndecl);\n+  tree newattrs = build_attr_access_from_parms (newparms, builtin);\n+\n+  /* Extract the (possibly empty) attribute access specification from\n+     NEWATTRS.  */\n+  rdwr_map new_idx;\n+  init_attr_rdwr_indices (&new_idx, newattrs);\n+\n+  if (cur_idx.is_empty () && new_idx.is_empty ())\n+    {\n+      /* If both specs are empty check pointers to VLAs for mismatches. */\n+      warn_parm_ptrarray_mismatch (origloc, curparms, newparms);\n+      return;\n+    }\n+  /* ...otherwise, if at least one spec isn't empty there may be mismatches,\n+     such as  between f(T*) and f(T[1]), where the former mapping woud be\n+     empty.  */\n+\n+  /* Create an empty access specification and use it for pointers with\n+     no spec of their own.  */\n+  attr_access ptr_spec = { };\n+\n+  /* Iterate over the two lists of function parameters, comparing their\n+     respective mappings and diagnosing mismatches.  */\n+  unsigned parmpos = 0;\n+  for (tree curp = curparms, newp = newparms; curp;\n+       curp = TREE_CHAIN (curp), newp = TREE_CHAIN (newp), ++parmpos)\n+    {\n+      /* Only check pointers and C++ references.  */\n+      tree newptype = TREE_TYPE (newp);\n+      if (!POINTER_TYPE_P (newptype))\n+\tcontinue;\n+\n+      {\n+\t/* Skip mismatches in __builtin_va_list that is commonly\n+\t   an array but that in declarations of built-ins decays\n+\t   to a pointer.  */\n+\tif (builtin && TREE_TYPE (newptype) == TREE_TYPE (va_list_type_node))\n+\t  continue;\n+      }\n+\n+      /* Access specs for the argument on the current (previous) and\n+\t new (to replace the current) declarations.  Either may be null,\n+\t indicating the parameter is an ordinary pointer with no size\n+\t associated with it.  */\n+      attr_access *cura = cur_idx.get (parmpos);\n+      attr_access *newa = new_idx.get (parmpos);\n+\n+      if (!newa)\n+\t{\n+\t  /* Continue of both parameters are pointers with no size\n+\t     associated with it.  */\n+\t  if (!cura)\n+\t    continue;\n+\n+\t  /* Otherwise point at PTR_SPEC and set its parameter pointer\n+\t     and number.  */\n+\t  newa = &ptr_spec;\n+\t  newa->ptr = newp;\n+\t  newa->ptrarg = parmpos;\n+\t}\n+      else if (!cura)\n+\t{\n+\t  cura = &ptr_spec;\n+\t  cura->ptr = curp;\n+\t  cura->ptrarg = parmpos;\n+\t}\n+\n+      /* Set if the parameter is [re]declared as a VLA.  */\n+      const bool cur_vla_p = cura->size || cura->minsize == HOST_WIDE_INT_M1U;\n+      const bool new_vla_p = newa->size || newa->minsize == HOST_WIDE_INT_M1U;\n+\n+      if (DECL_P (curp))\n+\torigloc = DECL_SOURCE_LOCATION (curp);\n+      else if (EXPR_P (curp) && EXPR_HAS_LOCATION (curp))\n+\torigloc = EXPR_LOCATION (curp);\n+\n+      /* The location of the parameter in the current redeclaration.  */\n+      location_t newloc = DECL_SOURCE_LOCATION (newp);\n+      if (origloc == UNKNOWN_LOCATION)\n+\torigloc = newloc;\n+\n+      tree curptype = TREE_TYPE (curp);\n+      const std::string newparmstr = newa->array_as_string (newptype);\n+      const std::string curparmstr = cura->array_as_string (curptype);\n+      if (new_vla_p && !cur_vla_p)\n+\t{\n+\t  if (warning_at (newloc, OPT_Wvla_parameter,\n+\t\t\t  \"argument %u of type %s declared as \"\n+\t\t\t  \"a variable length array\",\n+\t\t\t  parmpos + 1, newparmstr.c_str ()))\n+\t    inform (origloc,\n+\t\t    (cura == &ptr_spec\n+\t\t     ? G_(\"previously declared as a pointer %s\")\n+\t\t     : G_(\"previously declared as an ordinary array %s\")),\n+\t\t    curparmstr.c_str ());\n+\t  continue;\n+\t}\n+\n+      if (newa == &ptr_spec)\n+\t{\n+\t  /* The new declaration uses the pointer form.  Detect mismatches\n+\t     between the pointer and a previous array or VLA forms.  */\n+\t  if (cura->minsize == HOST_WIDE_INT_M1U)\n+\t    {\n+\t      /* Diagnose a pointer/VLA mismatch.  */\n+\t      if (warning_at (newloc, OPT_Wvla_parameter,\n+\t\t\t      \"argument %u of type %s declared \"\n+\t\t\t      \"as a pointer\",\n+\t\t\t      parmpos + 1, newparmstr.c_str ()))\n+\t\tinform (origloc,\n+\t\t\t\"previously declared as a variable length array %s\",\n+\t\t\tcurparmstr.c_str ());\n+\t      continue;\n+\t    }\n+\n+\t  if (cura->minsize && cura->minsize != HOST_WIDE_INT_M1U)\n+\t    {\n+\t      /* Diagnose mismatches between arrays with a constant\n+\t\t bound and pointers.  */\n+\t      if (warning_at (newloc, OPT_Warray_parameter_,\n+\t\t\t      \"argument %u of type %s declared \"\n+\t\t\t      \"as a pointer\",\n+\t\t\t      parmpos + 1, newparmstr.c_str ()))\n+\t\tinform (origloc, \"previously declared as an array %s\",\n+\t\t\tcurparmstr.c_str ());\n+\t      continue;\n+\t    }\n+\t}\n+\n+      if (!new_vla_p && cur_vla_p)\n+\t{\n+\t  if (warning_at (newloc, OPT_Wvla_parameter,\n+\t\t\t  \"argument %u of type %s declared \"\n+\t\t\t  \"as an ordinary array\",\n+\t\t\t  parmpos + 1, newparmstr.c_str ()))\n+\t    inform (origloc,\n+\t\t    \"previously declared as a variable length array %s\",\n+\t\t    curparmstr.c_str ());\n+\t  continue;\n+\t}\n+\n+      /* Move on to the next pair of parameters if both of the current\n+\t pair are VLAs with a single variable bound that refers to\n+\t a parameter at the same position.  */\n+      if (newa->size && cura->size\n+\t  && newa->sizarg != UINT_MAX\n+\t  && newa->sizarg == cura->sizarg\n+\t  && newa->minsize == cura->minsize\n+\t  && !TREE_CHAIN (newa->size) && !TREE_CHAIN (cura->size))\n+\tcontinue;\n+\n+      if (newa->size || cura->size)\n+\t{\n+\t  unsigned newunspec, curunspec;\n+\t  unsigned newbnds = newa->vla_bounds (&newunspec) + newunspec;\n+\t  unsigned curbnds = cura->vla_bounds (&curunspec) + curunspec;\n+\n+\t  if (newbnds != curbnds)\n+\t    {\n+\t      if (warning_n (newloc, OPT_Wvla_parameter, newbnds,\n+\t\t\t     \"argument %u of type %s declared with \"\n+\t\t\t     \"%u variable bound\",\n+\t\t\t     \"argument %u of type %s declared with \"\n+\t\t\t     \"%u variable bounds\",\n+\t\t\t     parmpos + 1, newparmstr.c_str (),\n+\t\t\t     newbnds))\n+\t\tinform_n (origloc, curbnds,\n+\t\t\t  \"previously declared as %s with %u variable bound\",\n+\t\t\t  \"previously declared as %s with %u variable bounds\",\n+\t\t\t  curparmstr.c_str (), curbnds);\n+\t      continue;\n+\t    }\n+\n+\t  if (newunspec != curunspec)\n+\t    {\n+\t      location_t warnloc = newloc, noteloc = origloc;\n+\t      const char *warnparmstr = newparmstr.c_str ();\n+\t      const char *noteparmstr = curparmstr.c_str ();\n+\t      unsigned warnunspec = newunspec, noteunspec = curunspec;\n+\n+\t      if (newunspec < curunspec)\n+\t\t{\n+\t\t  /* If the new declaration has fewer unspecified bounds\n+\t\t     point the warning to the previous declaration to make\n+\t\t     it clear that that's the one to change.  Otherwise,\n+\t\t     point it to the new decl.  */\n+\t\t  std::swap (warnloc, noteloc);\n+\t\t  std::swap (warnparmstr, noteparmstr);\n+\t\t  std::swap (warnunspec, noteunspec);\n+\t\t}\n+\t      if (warning_n (warnloc, OPT_Wvla_parameter, warnunspec,\n+\t\t\t     \"argument %u of type %s declared with \"\n+\t\t\t     \"%u unspecified variable bound\",\n+\t\t\t     \"argument %u of type %s declared with \"\n+\t\t\t     \"%u unspecified variable bounds\",\n+\t\t\t     parmpos + 1, warnparmstr, warnunspec))\n+\t\t{\n+\t\t  if (warnloc == newloc)\n+\t\t    inform_n (noteloc, noteunspec,\n+\t\t\t      \"previously declared as %s with %u unspecified \"\n+\t\t\t      \"variable bound\",\n+\t\t\t      \"previously declared as %s with %u unspecified \"\n+\t\t\t      \"variable bounds\",\n+\t\t\t      noteparmstr, noteunspec);\n+\t\t  else\n+\t\t    inform_n (noteloc, noteunspec,\n+\t\t\t      \"subsequently declared as %s with %u unspecified \"\n+\t\t\t      \"variable bound\",\n+\t\t\t      \"subsequently declared as %s with %u unspecified \"\n+\t\t\t      \"variable bounds\",\n+\t\t\t      noteparmstr, noteunspec);\n+\t\t}\n+\t      continue;\n+\t    }\n+\t}\n+\n+      /* Iterate over the lists of VLA variable bounds, comparing each\n+\t pair for equality, and diagnosing mismatches.  The case of\n+\t the lists having different lengths is handled above so at\n+\t this point they do .  */\n+      for (tree newvbl = newa->size, curvbl = cura->size; newvbl;\n+\t   newvbl = TREE_CHAIN (newvbl), curvbl = TREE_CHAIN (curvbl))\n+\t{\n+\t  tree newpos = TREE_PURPOSE (newvbl);\n+\t  tree curpos = TREE_PURPOSE (curvbl);\n+\n+\t  tree newbnd = vla_bound_parm_decl (TREE_VALUE (newvbl));\n+\t  tree curbnd = vla_bound_parm_decl (TREE_VALUE (curvbl));\n+\n+\t  if (newpos == curpos && newbnd == curbnd)\n+\t    /* In the expected case when both bounds either refer to\n+\t       the same positional parameter or when neither does,\n+\t       and both are the same expression they are necessarily\n+\t       the same.  */\n+\t    continue;\n+\n+\t  const char* const newbndstr =\n+\t    newbnd ? print_generic_expr_to_str (newbnd) : \"*\";\n+\t  const char* const curbndstr =\n+\t    curbnd ? print_generic_expr_to_str (curbnd) : \"*\";\n+\n+\t  if (!newpos != !curpos\n+\t      || (newpos && !tree_int_cst_equal (newpos, curpos)))\n+\t    {\n+\t      /* Diagnose a mismatch between a specified VLA bound and\n+\t\t an unspecified one.  This can only happen in the most\n+\t\t significant bound.\n+\n+\t\t Distinguish between the common case of bounds that are\n+\t\t other function parameters such as in\n+\t\t   f (int n, int[n]);\n+\t\t and others.  */\n+\n+\t      gcc_rich_location richloc (newloc);\n+\t      bool warned;\n+\t      if (newpos)\n+\t\t{\n+\t\t  /* Also underline the VLA bound argument.  */\n+\t\t  richloc.add_range (DECL_SOURCE_LOCATION (newbnd));\n+\t\t  warned = warning_at (&richloc, OPT_Wvla_parameter,\n+\t\t\t\t       \"argument %u of type %s declared \"\n+\t\t\t\t       \"with mismatched bound argument %E\",\n+\t\t\t\t       parmpos + 1, newparmstr.c_str (),\n+\t\t\t\t       plus_one (newpos));\n+\t\t}\n+\t      else\n+\t\twarned = warning_at (&richloc, OPT_Wvla_parameter,\n+\t\t\t\t     \"argument %u of type %s declared \"\n+\t\t\t\t     \"with mismatched bound %<%s%>\",\n+\t\t\t\t     parmpos + 1, newparmstr.c_str (),\n+\t\t\t\t     newbndstr);\n+\n+\t      if (warned)\n+\t\t{\n+\t\t  gcc_rich_location richloc (origloc);\n+\t\t  if (curpos)\n+\t\t    {\n+\t\t      /* Also underline the VLA bound argument.  */\n+\t\t      richloc.add_range (DECL_SOURCE_LOCATION (curbnd));\n+\t\t      inform (&richloc, \"previously declared as %s with \"\n+\t\t\t      \"bound argument %E\",\n+\t\t\t      curparmstr.c_str (), plus_one (curpos));\n+\t\t    }\n+\t\t  else\n+\t\t    inform (&richloc, \"previously declared as %s with bound \"\n+\t\t\t    \"%<%s%>\", curparmstr.c_str (), curbndstr);\n+\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\n+\t  if (!newpos && newbnd && curbnd)\n+\t    {\n+\t      /* The VLA bounds don't refer to other function parameters.\n+\t\t Compare them lexicographically to detect gross mismatches\n+\t\t such as between T[foo()] and T[bar()].  */\n+\t      if (operand_equal_p (newbnd, curbnd, OEP_LEXICOGRAPHIC))\n+\t\tcontinue;\n+\n+\t      if (warning_at (newloc, OPT_Wvla_parameter,\n+\t\t\t      \"argument %u of type %s declared with \"\n+\t\t\t      \"mismatched bound %<%s%>\",\n+\t\t\t      parmpos + 1, newparmstr.c_str (), newbndstr))\n+\t\tinform (origloc, \"previously declared as %s with bound %qs\",\n+\t\t\tcurparmstr.c_str (), curbndstr);\n+\t      continue;\n+\t    }\n+\t}\n+\n+      if (newa->minsize == cura->minsize\n+\t  || (((newa->minsize == 0 && newa->mode != access_deferred)\n+\t       || (cura->minsize == 0 && cura->mode != access_deferred))\n+\t      && newa != &ptr_spec\n+\t      && cura != &ptr_spec))\n+\tcontinue;\n+\n+      if (!newa->static_p && !cura->static_p && warn_array_parameter < 2)\n+\t/* Avoid warning about mismatches in ordinary (non-static) arrays\n+\t   at levels below 2.  */\n+\tcontinue;\n+\n+      if (warning_at (newloc, OPT_Warray_parameter_,\n+\t\t      \"argument %u of type %s with mismatched bound\",\n+\t\t      parmpos + 1, newparmstr.c_str ()))\n+\tinform (origloc, \"previously declared as %s\", curparmstr.c_str ());\n+    }\n+}"}, {"sha": "7a61351bf84434a898238ff1eabd80c1318cfb44", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -338,6 +338,14 @@ Warray-bounds=\n LangEnabledBy(C ObjC C++ LTO ObjC++,Wall,1,0)\n ; in common.opt\n \n+Warray-parameter\n+C ObjC C++ ObjC++ Warning Alias(Warray-parameter=, 2, 0)\n+Warn about mismatched declarations of array parameters and unsafe accesses to them.\n+\n+Warray-parameter=\n+C ObjC C++ ObjC++ Joined RejectNegative UInteger Var(warn_array_parameter) IntegerRange(0, 2) LangEnabledBy(C ObjC C++ ObjC++,Wall, 2, 0) Warning\n+Warn about mismatched declarations of array parameters and unsafe accesses to them.\n+\n Wzero-length-bounds\n C ObjC C++ ObjC++ Var(warn_zero_length_bounds) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall)\n Warn about accesses to interior zero-length array members.\n@@ -1257,6 +1265,10 @@ Wno-vla-larger-than\n C ObjC C++ LTO ObjC++ Alias(Wvla-larger-than=,18446744073709551615EiB,none) Warning\n Disable Wvla-larger-than= warning.  Equivalent to Wvla-larger-than=<SIZE_MAX> or larger.\n \n+Wvla-parameter\n+C ObjC C++ ObjC++ Var(warn_vla_parameter) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall)\n+Warn about mismatched declarations of VLA parameters.\n+\n Wvolatile\n C++ ObjC++ Var(warn_volatile) Warning\n Warn about deprecated uses of volatile qualifier."}, {"sha": "81b9adb6a332c1aa23c1c3297f8cebf5552ef948", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 214, "deletions": 9, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n    line numbers.  For example, the CONST_DECLs for enum values.  */\n \n #include \"config.h\"\n+#define INCLUDE_STRING\n #define INCLUDE_UNIQUE_PTR\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -58,6 +59,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-family/known-headers.h\"\n #include \"c-family/c-spellcheck.h\"\n \n+#include \"tree-pretty-print.h\"\n+\n /* In grokdeclarator, distinguish syntactic contexts of declarators.  */\n enum decl_context\n { NORMAL,\t\t\t/* Ordinary declaration */\n@@ -4970,6 +4973,17 @@ groktypename (struct c_type_name *type_name, tree *expr,\n   return type;\n }\n \n+/* Looks up the most recent pushed declaration corresponding to DECL.  */\n+\n+static tree\n+lookup_last_decl (tree decl)\n+{\n+  tree last_decl = lookup_name (DECL_NAME (decl));\n+  if (!last_decl)\n+    last_decl = lookup_name_in_scope (DECL_NAME (decl), external_scope);\n+  return last_decl;\n+}\n+\n /* Wrapper for decl_attributes that adds some implicit attributes\n    to VAR_DECLs or FUNCTION_DECLs.  */\n \n@@ -4998,10 +5012,7 @@ c_decl_attributes (tree *node, tree attributes, int flags)\n      so far so that attributes on the current declaration that's\n      about to be pushed that conflict with the former can be detected,\n      diagnosed, and rejected as appropriate.  */\n-  tree last_decl = lookup_name (DECL_NAME (*node));\n-  if (!last_decl)\n-    last_decl = lookup_name_in_scope (DECL_NAME (*node), external_scope);\n-\n+  tree last_decl = lookup_last_decl (*node);\n   return decl_attributes (node, attributes, flags, last_decl);\n }\n \n@@ -5011,6 +5022,8 @@ c_decl_attributes (tree *node, tree attributes, int flags)\n    have been parsed, before parsing the initializer if any.\n    Here we create the ..._DECL node, fill in its type,\n    and put it on the list of decls for the current context.\n+   When nonnull, set *LASTLOC to the location of the prior declaration\n+   of the same entity if one exists.\n    The ..._DECL node is returned as the value.\n \n    Exception: for arrays where the length is not specified,\n@@ -5023,7 +5036,7 @@ c_decl_attributes (tree *node, tree attributes, int flags)\n \n tree\n start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n-\t    bool initialized, tree attributes)\n+\t    bool initialized, tree attributes, location_t *lastloc /* = NULL */)\n {\n   tree decl;\n   tree tem;\n@@ -5041,6 +5054,10 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n   if (!decl || decl == error_mark_node)\n     return NULL_TREE;\n \n+  if (tree lastdecl = lastloc ? lookup_last_decl (decl) : NULL_TREE)\n+    if (lastdecl != error_mark_node)\n+      *lastloc = DECL_SOURCE_LOCATION (lastdecl);\n+\n   if (expr)\n     add_stmt (fold_convert (void_type_node, expr));\n \n@@ -5478,6 +5495,14 @@ finish_decl (tree decl, location_t init_loc, tree init,\n \t  if (asmspec && VAR_P (decl) && C_DECL_REGISTER (decl))\n \t    DECL_HARD_REGISTER (decl) = 1;\n \t  rest_of_decl_compilation (decl, true, 0);\n+\n+\t  if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t    {\n+\t      tree parms = DECL_ARGUMENTS (decl);\n+\t      const bool builtin = fndecl_built_in_p (decl);\n+\t      if (tree access = build_attr_access_from_parms (parms, !builtin))\n+\t\tdecl_attributes (&decl, access, 0);\n+\t    }\n \t}\n       else\n \t{\n@@ -5630,6 +5655,175 @@ grokparm (const struct c_parm *parm, tree *expr)\n   return decl;\n }\n \n+/* Return attribute \"arg spec\" corresponding to an array/VLA parameter\n+   described by PARM, concatenated onto attributes ATTRS.\n+   The spec consists of one dollar symbol for each specified variable\n+   bound, one asterisk for each unspecified variable bound, followed\n+   by at most one specification of the most significant bound of\n+   an ordinary array parameter.  For ordinary arrays the specification\n+   is either the constant bound itself, or the space character for\n+   an array with an unspecified bound (the [] form).  Finally, a chain\n+   of specified variable bounds is appended to the spec, starting with\n+   the most significant bound.  For example, the PARM T a[2][m][3][n]\n+   will produce __attribute__((arg spec (\"[$$2]\", m, n)).\n+   For T a typedef for an array with variable bounds, the bounds are\n+   included in the specification in the expected order.\n+   No \"arg spec\"  is created for parameters of pointer types, making\n+   a distinction between T(*)[N] (or, equivalently, T[][N]) and\n+   the T[M][N] form, all of which have the same type and are represented\n+   the same, but only the last of which gets an \"arg spec\" describing\n+   the most significant bound M.  */\n+\n+static tree\n+get_parm_array_spec (const struct c_parm *parm, tree attrs)\n+{\n+  /* The attribute specification string, minor bound first.  */\n+  std::string spec;\n+\n+  /* A list of VLA variable bounds, major first, or null if unspecified\n+     or not a VLA.  */\n+  tree vbchain = NULL_TREE;\n+  /* True for a pointer parameter.  */\n+  bool pointer = false;\n+  /* True for an ordinary array with an unpecified bound.  */\n+  bool nobound = false;\n+\n+  /* Create a string representation for the bounds of the array/VLA.  */\n+  for (c_declarator *pd = parm->declarator, *next; pd; pd = next)\n+    {\n+      next = pd->declarator;\n+      while (next && next->kind == cdk_attrs)\n+\tnext = next->declarator;\n+\n+      /* Remember if a pointer has been seen to avoid storing the constant\n+\t bound.  */\n+      if (pd->kind == cdk_pointer)\n+\tpointer = true;\n+\n+      if ((pd->kind == cdk_pointer || pd->kind == cdk_function)\n+\t  && (!next || next->kind == cdk_id))\n+\t{\n+\t  /* Do nothing for the common case of a pointer.  The fact that\n+\t     the parameter is one can be deduced from the absence of\n+\t     an arg spec for it.  */\n+\t  return attrs;\n+\t}\n+\n+      if (pd->kind == cdk_id)\n+\t{\n+\t  if (pointer\n+\t      || !parm->specs->type\n+\t      || TREE_CODE (parm->specs->type) != ARRAY_TYPE\n+\t      || !TYPE_DOMAIN (parm->specs->type)\n+\t      || !TYPE_MAX_VALUE (TYPE_DOMAIN (parm->specs->type)))\n+\t    continue;\n+\n+\t  tree max = TYPE_MAX_VALUE (TYPE_DOMAIN (parm->specs->type));\n+\t  if (!vbchain\n+\t      && TREE_CODE (max) == INTEGER_CST)\n+\t    {\n+\t      /* Extract the upper bound from a parameter of an array type\n+\t\t unless the parameter is an ordinary array of unspecified\n+\t\t bound in which case a next iteration of the loop will\n+\t\t exit.  */\n+\t      if (spec.empty () || spec.end ()[-1] != ' ')\n+\t\t{\n+\t\t  if (!tree_fits_shwi_p (max))\n+\t\t    continue;\n+\n+\t\t  /* The upper bound is the value of the largest valid\n+\t\t     index.  */\n+\t\t  HOST_WIDE_INT n = tree_to_shwi (max) + 1;\n+\t\t  char buf[40];\n+\t\t  sprintf (buf, \"%lu\", (unsigned long)n);\n+\t\t  spec += buf;\n+\t\t}\n+\t      continue;\n+\t    }\n+\n+\t  /* For a VLA typedef, create a list of its variable bounds and\n+\t     append it in the expected order to VBCHAIN.  */\n+\t  tree tpbnds = NULL_TREE;\n+\t  for (tree type = parm->specs->type; TREE_CODE (type) == ARRAY_TYPE;\n+\t       type = TREE_TYPE (type))\n+\t    {\n+\t      tree nelts = array_type_nelts (type);\n+\t      if (TREE_CODE (nelts) != INTEGER_CST)\n+\t\t{\n+\t\t  /* Each variable VLA bound is represented by the dollar\n+\t\t     sign.  */\n+\t\t  spec += \"$\";\n+\t\t  tpbnds = tree_cons (NULL_TREE, nelts, tpbnds);\n+\t\t}\n+\t    }\n+\t  tpbnds = nreverse (tpbnds);\n+\t  vbchain = chainon (vbchain, tpbnds);\n+\t  continue;\n+\t}\n+\n+      if (pd->kind != cdk_array)\n+\tcontinue;\n+\n+      if (pd->u.array.vla_unspec_p)\n+\t{\n+\t  /* Each unspecified bound is represented by a star.  There\n+\t     can be any number of these in a declaration (but none in\n+\t     a definition).  */\n+\t  spec += '*';\n+\t  continue;\n+\t}\n+\n+      tree nelts = pd->u.array.dimen;\n+      if (!nelts)\n+\t{\n+\t  /* Ordinary array of unspecified size.  There can be at most\n+\t     one for the most significant bound.  Exit on the next\n+\t     iteration which determines whether or not PARM is declared\n+\t     as a pointer or an array.  */\n+\t  nobound = true;\n+\t  continue;\n+\t}\n+\n+      if (TREE_CODE (nelts) == INTEGER_CST)\n+\t{\n+\t  /* Skip all constant bounds except the most significant one.\n+\t     The interior ones are included in the array type.  */\n+\t  if (next && (next->kind == cdk_array || next->kind == cdk_pointer))\n+\t    continue;\n+\n+\t  if (!tree_fits_uhwi_p (nelts))\n+\t    /* Bail completely on invalid bounds.  */\n+\t    return attrs;\n+\n+\t  char buf[40];\n+\t  const char *code = pd->u.array.static_p ? \"s\" : \"\";\n+\t  unsigned HOST_WIDE_INT n = tree_to_uhwi (nelts);\n+\t  sprintf (buf, \"%s%llu\", code, (unsigned long long)n);\n+\t  spec += buf;\n+\t  break;\n+\t}\n+\n+      /* Each variable VLA bound is represented by a dollar sign.  */\n+      spec += \"$\";\n+      vbchain = tree_cons (NULL_TREE, nelts, vbchain);\n+    }\n+\n+  if (spec.empty () && !nobound)\n+    return attrs;\n+\n+  spec.insert (0, \"[\");\n+  if (nobound)\n+    /* Ordinary array of unspecified bound is represented by a space.\n+       It must be last in the spec.  */\n+    spec += ' ';\n+  spec += ']';\n+\n+  tree acsstr = build_string (spec.length () + 1, spec.c_str ());\n+  tree args = tree_cons (NULL_TREE, acsstr, vbchain);\n+  tree name = get_identifier (\"arg spec\");\n+  return tree_cons (name, args, attrs);\n+}\n+\n /* Given a parsed parameter declaration, decode it into a PARM_DECL\n    and push that on the current scope.  EXPR is a pointer to an\n    expression that needs to be evaluated for the side effects of array\n@@ -5639,12 +5833,12 @@ void\n push_parm_decl (const struct c_parm *parm, tree *expr)\n {\n   tree attrs = parm->attrs;\n-  tree decl;\n-\n-  decl = grokdeclarator (parm->declarator, parm->specs, PARM, false, NULL,\n-\t\t\t &attrs, expr, NULL, DEPRECATED_NORMAL);\n+  tree decl = grokdeclarator (parm->declarator, parm->specs, PARM, false, NULL,\n+\t\t\t      &attrs, expr, NULL, DEPRECATED_NORMAL);\n   if (decl && DECL_P (decl))\n     DECL_SOURCE_LOCATION (decl) = parm->loc;\n+\n+  attrs = get_parm_array_spec (parm, attrs);\n   decl_attributes (&decl, attrs, 0);\n \n   decl = pushdecl (decl);\n@@ -9228,6 +9422,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n   old_decl = lookup_name_in_scope (DECL_NAME (decl1), current_scope);\n   if (old_decl && TREE_CODE (old_decl) != FUNCTION_DECL)\n     old_decl = NULL_TREE;\n+\n   current_function_prototype_locus = UNKNOWN_LOCATION;\n   current_function_prototype_built_in = false;\n   current_function_prototype_arg_types = NULL_TREE;\n@@ -9358,12 +9553,22 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n \t\t \"%qD is normally a non-static function\", decl1);\n     }\n \n+  tree parms = current_function_arg_info->parms;\n+  if (old_decl)\n+    {\n+      location_t origloc = DECL_SOURCE_LOCATION (old_decl);\n+      warn_parm_array_mismatch (origloc, old_decl, parms);\n+    }\n+\n   /* Record the decl so that the function name is defined.\n      If we already have a decl for this name, and it is a FUNCTION_DECL,\n      use the old decl.  */\n \n   current_function_decl = pushdecl (decl1);\n \n+  if (tree access = build_attr_access_from_parms (parms, false))\n+    decl_attributes (&current_function_decl, access, 0, old_decl);\n+\n   push_scope ();\n   declare_parm_level ();\n "}, {"sha": "7d58356f0d71bf4d7339226beb406dfa60ffa6f9", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -68,6 +68,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"c-family/name-hint.h\"\n #include \"tree-iterator.h\"\n+#include \"tree-pretty-print.h\"\n #include \"memmodel.h\"\n #include \"c-family/known-headers.h\"\n \n@@ -2299,13 +2300,11 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t  c_parser_skip_to_end_of_block_or_statement (parser);\n \t\t  return;\n \t\t}\n-\t      tree d = start_decl (declarator, specs, false,\n-\t\t\t\t   chainon (postfix_attrs,\n-\t\t\t\t\t    all_prefix_attrs));\n-\t      if (d\n-\t\t  && TREE_CODE (d) == FUNCTION_DECL\n-\t\t  && DECL_ARGUMENTS (d) == NULL_TREE\n-\t\t  && DECL_INITIAL (d) == NULL_TREE)\n+\n+\t      location_t lastloc = UNKNOWN_LOCATION;\n+\t      tree attrs = chainon (postfix_attrs, all_prefix_attrs);\n+\t      tree d = start_decl (declarator, specs, false, attrs, &lastloc);\n+\t      if (d && TREE_CODE (d) == FUNCTION_DECL)\n \t\t{\n \t\t  /* Find the innermost declarator that is neither cdk_id\n \t\t     nor cdk_attrs.  */\n@@ -2334,10 +2333,18 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t\tgcc_unreachable ();\n \t\t      }\n \n-\t\t  /* If it exists and is cdk_function, use its parameters.  */\n+\t\t  /* If it exists and is cdk_function declaration whose\n+\t\t     arguments have not been set yet, use its arguments.  */\n \t\t  if (last_non_id_attrs\n \t\t      && last_non_id_attrs->kind == cdk_function)\n-\t\t    DECL_ARGUMENTS (d) = last_non_id_attrs->u.arg_info->parms;\n+\t\t    {\n+\t\t      tree parms = last_non_id_attrs->u.arg_info->parms;\n+\t\t      if (DECL_ARGUMENTS (d) == NULL_TREE\n+\t\t\t  && DECL_INITIAL (d) == NULL_TREE)\n+\t\t\tDECL_ARGUMENTS (d) = parms;\n+\n+\t\t      warn_parm_array_mismatch (lastloc, d, parms);\n+\t\t    }\n \t\t}\n \t      if (omp_declare_simd_clauses.exists ())\n \t\t{\n@@ -2366,7 +2373,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t      if (d)\n \t\tfinish_decl (d, UNKNOWN_LOCATION, NULL_TREE,\n \t\t\t     NULL_TREE, asm_name);\n-\t      \n+\n \t      if (c_parser_next_token_is_keyword (parser, RID_IN))\n \t\t{\n \t\t  if (d)"}, {"sha": "287b1df51e0fb9d6df37cddb4df9cda6b4bab17c", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -620,7 +620,7 @@ extern void shadow_tag_warned (const struct c_declspecs *, int);\n extern tree start_enum (location_t, struct c_enum_contents *, tree);\n extern bool start_function (struct c_declspecs *, struct c_declarator *, tree);\n extern tree start_decl (struct c_declarator *, struct c_declspecs *, bool,\n-\t\t\ttree);\n+\t\t\ttree, location_t * = NULL);\n extern tree start_struct (location_t, enum tree_code, tree,\n \t\t\t  class c_struct_parse_info **);\n extern void store_parm_decls (void);"}, {"sha": "b56069ded4de2ab499203892c479bc41a70520b9", "filename": "gcc/calls.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -2209,13 +2209,13 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \n   bitmap_obstack_release (NULL);\n \n+  tree fntypeattrs = TYPE_ATTRIBUTES (fntype);\n   /* Extract attribute alloc_size from the type of the called expression\n      (which could be a function or a function pointer) and if set, store\n      the indices of the corresponding arguments in ALLOC_IDX, and then\n      the actual argument(s) at those indices in ALLOC_ARGS.  */\n   int alloc_idx[2] = { -1, -1 };\n-  if (tree alloc_size = lookup_attribute (\"alloc_size\",\n-\t\t\t\t\t  TYPE_ATTRIBUTES (fntype)))\n+  if (tree alloc_size = lookup_attribute (\"alloc_size\", fntypeattrs))\n     {\n       tree args = TREE_VALUE (alloc_size);\n       alloc_idx[0] = TREE_INT_CST_LOW (TREE_VALUE (args)) - 1;\n@@ -2228,7 +2228,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \n   /* Map of attribute accewss specifications for function arguments.  */\n   rdwr_map rdwr_idx;\n-  init_attr_rdwr_indices (&rdwr_idx, fntype);\n+  init_attr_rdwr_indices (&rdwr_idx, fntypeattrs);\n \n   /* I counts args in order (to be) pushed; ARGPOS counts in order written.  */\n   for (argpos = 0; argpos < num_actuals; i--, argpos++)\n@@ -2478,7 +2478,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t  if (POINTER_TYPE_P (type))\n \t    {\n \t      access->ptr = args[i].tree_value;\n-\t      gcc_assert (access->size == NULL_TREE);\n+\t      // A nonnull ACCESS->SIZE contains VLA bounds.  */\n \t    }\n \t  else\n \t    {"}, {"sha": "8be2b4f4de6e45192bf489d5d6fcb3c81e240780", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -5217,6 +5217,7 @@ Options} and @ref{Objective-C and Objective-C++ Dialect Options}.\n \n @gccoptlist{-Waddress   @gol\n -Warray-bounds=1 @r{(only with} @option{-O2}@r{)}  @gol\n+-Warray-parameter=2 @r{(C and Objective-C only)} @gol\n -Wbool-compare  @gol\n -Wbool-operation  @gol\n -Wc++11-compat  -Wc++14-compat  @gol\n@@ -5268,6 +5269,7 @@ Options} and @ref{Objective-C and Objective-C++ Dialect Options}.\n -Wunused-label     @gol\n -Wunused-value     @gol\n -Wunused-variable  @gol\n+-Wvla-parameter @r{(C and Objective-C only)} @gol\n -Wvolatile-register-var  @gol\n -Wzero-length-bounds}\n \n@@ -7134,6 +7136,54 @@ pointers. This warning level may give a larger number of\n false positives and is deactivated by default.\n @end table\n \n+@item -Warray-parameter\n+@itemx -Warray-parameter=@var{n}\n+@opindex Wno-array-parameter\n+Warn about redeclarations of functions involving arguments of array or\n+pointer types of inconsistent kinds or forms, and enable the detection\n+of out-of-bounds accesses to such parameters by warnings such as\n+@option{-Warray-bounds}.\n+\n+If the first function declaration uses the array form the bound specified\n+in the array is assumed to be the minimum number of elements expected to\n+be provided in calls to the function and the maximum number of elements\n+accessed by it.  Failing to provide arguments of sufficient size or accessing\n+more than the maximum number of elements may be diagnosed by warnings such\n+as @option{-Warray-bounds}.  At level 1 the warning diagnoses inconsistencies\n+involving array parameters declared using the @code{T[static N]} form.\n+\n+For example, the warning triggers for the following redeclarations because\n+the first one allows an array of any size to be passed to @code{f} while\n+the second one with the keyword @code{static} specifies that the array\n+argument must have at least four elements.\n+\n+@smallexample\n+void f (int[static 4]);\n+void f (int[]);           // warning (inconsistent array form)\n+\n+void g (void)\n+@{\n+  int *p = (int *)malloc (4);\n+  f (p);                  // warning (array too small)\n+  @dots{}\n+@}\n+@end smallexample\n+\n+At level 2 the warning also triggers for redeclarations involving any other\n+inconsistency in array or pointer argument forms denoting array sizes.\n+Pointers and arrays of unspecified bound are considered equivalent and do\n+not trigger a warning.\n+\n+@smallexample\n+void g (int*);\n+void g (int[]);     // no warning\n+void g (int[8]);    // warning (inconsistent array bound)\n+@end smallexample\n+\n+@option{-Warray-parameter=2} is included in @option{-Wall}.  The\n+@option{-Wvla-parameter} option triggers warnings for similar inconsistencies\n+involving Variable Length Array arguments.\n+\n @item -Wattribute-alias=@var{n}\n @itemx -Wno-attribute-alias\n @opindex Wattribute-alias\n@@ -8561,6 +8611,44 @@ See also @option{-Walloca-larger-than=@var{byte-size}}.\n Disable @option{-Wvla-larger-than=} warnings.  The option is equivalent\n to @option{-Wvla-larger-than=}@samp{SIZE_MAX} or larger.\n \n+@item -Wvla-parameter\n+@opindex Wno-vla-parameter\n+Warn about redeclarations of functions involving arguments of Variable\n+Length Array types of inconsistent kinds or forms, and enable the detection\n+of out-of-bounds accesses to such parameters by warnings such as\n+@option{-Warray-bounds}.\n+\n+If the first function declaration uses the VLA form the bound specified\n+in the array is assumed to be the minimum number of elements expected to\n+be provided in calls to the function and the maximum number of elements\n+accessed by it.  Failing to provide arguments of sufficient size or\n+accessing more than the maximum number of elements may be diagnosed.\n+\n+For example, the warning triggers for the following redeclarations because\n+the first one allows an array of any size to be passed to @code{f} while\n+the second one specifies that the array argument must have at least @code{n}\n+elements.  In addition, calling @code{f} with the assotiated VLA bound\n+parameter in excess of the actual VLA bound triggers a warning as well.\n+\n+@smallexample\n+void f (int n, int[n]);\n+void f (int, int[]);     // warning: argument 2 previously declared as a VLA\n+\n+void g (int n)\n+@{\n+    if (n > 4)\n+      return;\n+    int a[n];\n+    f (sizeof a, a);     // warning: access to a by f may be out of bounds\n+  @dots{}\n+@}\n+\n+@end smallexample\n+\n+@option{-Wvla-parameter} is included in @option{-Wall}.  The\n+@option{-Warray-parameter} option triggers warnings for similar problems\n+involving ordinary array arguments.\n+\n @item -Wvolatile-register-var\n @opindex Wvolatile-register-var\n @opindex Wno-volatile-register-var"}, {"sha": "5e787360314d4f19192cbcf1626e3c5474ba6ed2", "filename": "gcc/testsuite/c-c++-common/Warray-bounds-6.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-6.c?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -1,8 +1,12 @@\n-/* PR tree-optimization/86614 */\n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -Warray-bounds\" } */\n+/* PR tree-optimization/86614 - duplicate -Warray-bounds for a strncpy\n+   call with out-of-bounds offset\n+   { dg-do compile }\n+   { dg-options \"-O2 -Warray-bounds\" } */\n \n-extern char *strncpy (char *, const char *, __SIZE_TYPE__);\n+#if __cplusplus\n+extern \"C\"\n+#endif\n+char *strncpy (char *, const char *, __SIZE_TYPE__);\n \n void sink (void *);\n \n@@ -12,7 +16,8 @@ void g (const char *s, unsigned n)\n {\n   int i = (char *)a[1].b - (char *)a + 1;\n   char *d = a[1].b;\n-  /* Ensure the same bug is not diagnosed more than once.  */\n-  strncpy (d + i, s, n);\t/* { dg-warning \"array subscript \\[0-9]+ is outside array bounds of\" } */\n-\t\t\t\t/* { dg-bogus \"offset \\[0-9]+ is out of the bounds \\\\\\[0, \\[0-9]+\\\\\\] of object 'a' with type\" \"\" { target *-*-* } .-1 } */\n+  /* Verify the bug is diagnosed exactly once, using either form\n+     of the warning.  */\n+  strncpy (d + i, s, n);\t/* { dg-warning \"array subscript \\[0-9]+ is outside array bounds|offset \\[0-9]+ is out of the bounds\" } */\n+\t\t\t\t/* { dg-bogus \"offset \\[0-9]+ is out of the bounds|array subscript \\[0-9]+ is outside array bounds\" \"\" { target *-*-* } .-1 } */\n }"}, {"sha": "88f20e203ce7b8aa55d4d803306149b8d37e13d4", "filename": "gcc/testsuite/gcc.dg/Warray-parameter-2.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-2.c?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -0,0 +1,45 @@\n+/* PR c/50584 - No warning for passing small array to C99 static array\n+   declarator\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+// Reduced from Glibc.\n+\n+typedef struct FILE FILE;\n+\n+int vfprintf (FILE*, const char*, __builtin_va_list);\n+int vfprintf (FILE*, const char*, __builtin_va_list);   // { dg-bogus \"-Warray-parameter\" }\n+int vfprintf (FILE*, const char*, __builtin_va_list);\n+\n+int vfscanf (FILE*, const char*, __builtin_va_list);\n+int vfscanf (FILE*, const char*, __builtin_va_list);    // { dg-bogus \"-Warray-parameter\" }\n+int vfscanf (FILE*, const char*, __builtin_va_list);\n+\n+\n+/* Verify that mismatches in array/to pointer to va_list are still\n+   diagnosed.  */\n+\n+int fva (__builtin_va_list);\n+int fva (__builtin_va_list);\n+\n+int fpva_a1 (__builtin_va_list*);\n+int fpva_a1 (__builtin_va_list[1]);     // { dg-warning \"\\\\\\[-Warray-parameter\" }\n+\n+int fpva_a_ (__builtin_va_list*);\n+int fpva_a_ (__builtin_va_list[]);\n+int fpva_a_ (__builtin_va_list*);\n+int fpva_a_ (__builtin_va_list[]);\n+\n+/* Also verify that a mismatch between a pointer and a one-element\n+   array are diagnosed.  This is pervasive in Glibc headers but\n+   making an exception for it would leave no way to express\n+   the requirement that a function take at least one argument\n+   by reference.  */\n+\n+struct __jmp_buf_tag;\n+int __sigsetjmp (struct __jmp_buf_tag*, int);\n+\n+struct __jmp_buf_tag { };\n+typedef struct __jmp_buf_tag jmp_buf[1];\n+\n+int __sigsetjmp (struct __jmp_buf_tag[1], int);   // { dg-warning \"\\\\\\[-Warray-parameter\" }"}, {"sha": "cbf3e9339f500c9b28fa526c868d2eff640c0416", "filename": "gcc/testsuite/gcc.dg/Warray-parameter-3.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-3.c?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -0,0 +1,89 @@\n+/* PR c/50584 - No warning for passing small array to C99 static array\n+   declarator\n+   { dg-do compile }\n+   { dg-options \"-Wall -Warray-parameter=1\" } */\n+\n+/* Verify that at level 1 mismatches in the bounds of ordinary array\n+   parameters don't trigger -Warray-parameter.  */\n+void fax (int[]);\n+void fax (int[0]);\n+void fax (int[1]);\n+void fax (int[2]);\n+void fax (int[3]);\n+\n+/* Same as above but starting with an array with a specified bound.  */\n+void gax (int[3]);\n+void gax (int[2]);\n+void gax (int[1]);\n+void gax (int[0]);\n+void gax (int[]);\n+\n+/* Same for multidimensional arrays.  */\n+void fax_y (int[][3]);\n+void fax_y (int[0][3]);\n+void fax_y (int[1][3]);\n+void fax_y (int[2][3]);\n+void fax_y (int[3][3]);\n+\n+/* Same as above but starting with an array with a specified bound.  */\n+void gax_y (int[3][5]);\n+void gax_y (int[2][5]);\n+void gax_y (int[1][5]);\n+void gax_y (int[0][5]);\n+void gax_y (int[][5]);\n+\n+/* Exercise VLAs with a mismatch in the bound for an ordinary array.  */\n+void fvlax_y (int n, int[][n]);\n+void fvlax_y (int n, int[0][n]);\n+void fvlax_y (int n, int[1][n]);\n+void fvlax_y (int n, int[2][n]);\n+void fvlax_y (int n, int[3][n]);\n+\n+void fvlaxn_y (int n, int[][n]);\n+void fvlaxn_y (int n, int[0][n]);\n+void fvlaxn_y (int n, int[1][n]);\n+void fvlaxn_y (int n, int[2][n]);\n+void fvlaxn_y (int n, int[3][n]);\n+\n+void fvlaxx_y (int[][*]);\n+void fvlaxx_y (int[0][*]);\n+void fvlaxx_y (int[1][*]);\n+void fvlaxx_y (int[2][*]);\n+void fvlaxx_y (int[3][*]);\n+\n+/* Verify that mismatches in the bounds of array parameters declared\n+   static do trigger -Warray-parameter.  */\n+void fas1 (int[static 1]);    // { dg-message \"previously declared as 'int\\\\\\[static 1]'\" }\n+void fas1 (int[static 2]);    // { dg-warning \"\\\\\\[-Warray-parameter=\" }\n+\n+\n+/* Also verify that -Warray-bounds doesn't trigger for ordinary array\n+   parameters...  */\n+#pragma GCC optimize \"2\"\n+\n+__attribute__ ((noipa)) void\n+gca3 (char a[3])\n+{\n+  a[0] = 0; a[1] = 1; a[2] = 2; a[3] = 3;\n+}\n+\n+__attribute__ ((noipa)) void\n+gia3 (int a[3])\n+{\n+  a[0] = 0; a[1] = 1; a[2] = 2; a[3] = 3;\n+}\n+\n+/* ...but does for static arrays.  */\n+__attribute__ ((noipa)) void\n+gcas3 (char a[static 3])\n+{\n+  a[0] = 0; a[1] = 1; a[2] = 2;\n+  a[3] = 3;                   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+__attribute__ ((noipa)) void\n+gias3 (int a[static 3])\n+{\n+  a[0] = 0; a[1] = 1; a[2] = 2;\n+  a[3] = 3;                   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}"}, {"sha": "b702d730a13ec7a7114285e242f95d78fdb9d001", "filename": "gcc/testsuite/gcc.dg/Warray-parameter-4.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-4.c?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -0,0 +1,119 @@\n+/* PR c/50584 - No warning for passing small array to C99 static array\n+   declarator\n+   Verify warnings for multidimensional arrays, including mismatches\n+   in bounds of arrays of VLAs.  (Mismatches in variable bounds are\n+   diagnosed by -Wvla-parameter.)\n+   { dg-do compile }\n+   { dg-options \"-Wall -Warray-parameter=2\" } */\n+\n+// Verify that equivalent forms don't tigger a warning.\n+\n+typedef int IA1[1];\n+typedef int IA1x_[][1];\n+typedef int IA1x0[0][1];\n+\n+void fia_x1 (int[][1]);\n+void fia_x1 (IA1[0]);\n+void fia_x1 (IA1x_);\n+void fia_x1 (IA1x0);\n+void fia_x1 (int[0][1]);\n+void fia_x1 (int[static 0][1]);\n+\n+// Same as above one more time.\n+void fia_x1 (int[][1]);\n+void fia_x1 (IA1[0]);\n+void fia_x1 (IA1x_);\n+void fia_x1 (IA1x0);\n+void fia_x1 (int[0][1]);\n+void fia_x1 (int[static 0][1]);\n+\n+\n+void fia1x1 (int[1][1]);\n+void fia1x1 (int[1][1]);\n+void fia1x1 (int[static 1][1]);\n+\n+void fia2x1 (int[2][1]);\n+void fia2x1 (int[2][1]);\n+void fia2x1 (int[static 2][1]);\n+\n+void fia1x2 (int[1][2]);\n+void fia1x2 (int[1][2]);\n+void fia1x2 (int[static 1][2]);\n+\n+void fia1x1_2x1 (int[1][1]);          // { dg-message \"previously declared as 'int\\\\\\[1]\\\\\\[1]'\" }\n+void fia1x1_2x1 (int[2][1]);          // { dg-warning \"\\\\\\[-Warray-parameter\" }\n+void fia1x1_2x1 (int[static 1][1]);\n+void fia1x1_2x1 (int[static 2][1]);   // { dg-warning \"\\\\\\[-Warray-parameter\" }\n+\n+\n+void fia2x1_1x1 (int[2][1]);          // { dg-message \"previously declared as 'int\\\\\\[2]\\\\\\[1]'\" }\n+void fia2x1_1x1 (int[1][1]);          // { dg-warning \"\\\\\\[-Warray-parameter\" }\n+void fia2x1_1x1 (int[2][1]);\n+void fia2x1_1x1 (int[static 1][1]);   // { dg-warning \"\\\\\\[-Warray-parameter\" }\n+void fia2x1_1x1 (int[static 2][1]);\n+\n+\n+extern int n1, n2;\n+\n+void fca_xn1 (char[][n1]);\n+void fca_xn1 (char[0][n1]);\n+void fca_xn1 (char[static 0][n1]);\n+\n+void fca1xn1_2xn1 (char[1][n1]);\n+void fca1xn1_2xn1 (char[2][n1]);        // { dg-warning \"\\\\\\[-Warray-parameter\" }\n+void fca1xn1_2xn1 (char[1][n1]);\n+void fca1xn1_2xn1 (char[static 1][n1]);\n+void fca1xn1_2xn1 (char[static 2][n1]); // { dg-warning \"\\\\\\[-Warray-parameter\" }\n+\n+\n+/* Exercise VLAs with a mismatch in the bound for an ordinary array.  */\n+void fvlax_y (int n, int[][n]);\n+void fvlax_y (int n, int[0][n]);\n+void fvlax_y (int n, int[1][n]);        // { dg-warning \"argument 2 of type 'int\\\\\\[1]\\\\\\[n]' with mismatched bound\" }\n+void fvlax_y (int n, int[2][n]);        // { dg-warning \"argument 2 of type 'int\\\\\\[2]\\\\\\[n]' with mismatched bound\" }\n+void fvlax_y (int n, int[3][n]);        // { dg-warning \"argument 2 of type 'int\\\\\\[3]\\\\\\[n]' with mismatched bound\" }\n+\n+void fvlaxn_y (int n, int[][n]);\n+void fvlaxn_y (int n, int[0][n]);\n+void fvlaxn_y (int n, int[1][n]);       // { dg-warning \"\\\\\\[-Warray-parameter\" }\n+void fvlaxn_y (int n, int[2][n]);       // { dg-warning \"\\\\\\[-Warray-parameter\" }\n+void fvlaxn_y (int n, int[3][n]);       // { dg-warning \"\\\\\\[-Warray-parameter\" }\n+\n+void fvlaxx_y (int[][*]);\n+void fvlaxx_y (int[0][*]);\n+void fvlaxx_y (int[1][*]);              // { dg-warning \"\\\\\\[-Warray-parameter\" }\n+void fvlaxx_y (int[2][*]);              // { dg-warning \"\\\\\\[-Warray-parameter\" }\n+void fvlaxx_y (int[3][*]);              // { dg-warning \"\\\\\\[-Warray-parameter\" }\n+\n+\n+// Verify an array of pointers to an array of function pointers.\n+\n+void ffpa7_5 (void (* (* (* [7])[5])(void))(void));\n+// { dg-message \"previously declared as 'void \\\\\\(\\\\\\* ?\\\\\\(\\\\\\* ?\\\\\\(\\\\\\*\\\\\\[7]\\\\\\)\\\\\\[5]\\\\\\)\\\\\\(void\\\\\\)\\\\\\)\\\\\\(void\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+void ffpa7_5 (void (* (* (* [6])[5])(void))(void));\n+// { dg-warning \"argument 1 of type 'void \\\\\\(\\\\\\* ?\\\\\\(\\\\\\* ?\\\\\\(\\\\\\*\\\\\\[6]\\\\\\)\\\\\\[5]\\\\\\)\\\\\\(void\\\\\\)\\\\\\)\\\\\\(void\\\\\\)' with mismatched bound\" \"\" { target *-*-* } .-1 }\n+void ffpa7_5 (void (* (* (* [])[5])(void))(void));\n+// { dg-warning \"argument 1 of type 'void \\\\\\(\\\\\\* ?\\\\\\(\\\\\\* ?\\\\\\(\\\\\\*\\\\\\[]\\\\\\)\\\\\\[5]\\\\\\)\\\\\\(void\\\\\\)\\\\\\)\\\\\\(void\\\\\\)' with mismatched bound\" \"\" { target *-*-* } .-1 }\n+void ffpa7_5 (void (* (* (* (*))[5])(void))(void));\n+// { dg-warning \"argument 1 of type 'void \\\\\\(\\\\\\* ?\\\\\\(\\\\\\* ?\\\\\\(\\\\\\*\\\\\\*\\\\\\)\\\\\\[5]\\\\\\)\\\\\\(void\\\\\\)\\\\\\)\\\\\\(void\\\\\\)' declared as a pointer\" \"\" { target *-*-* } .-1 }\n+\n+// Same as above but with array of pointers to a VLA of function pointers.\n+void ffpa7_n1 (void (* (* (* [7])[n1])(void))(void));\n+// { dg-message \"previously declared as 'void \\\\\\(\\\\\\* ?\\\\\\(\\\\\\* ?\\\\\\(\\\\\\*\\\\\\[7]\\\\\\)\\\\\\[n1]\\\\\\)\\\\\\(void\\\\\\)\\\\\\)\\\\\\(void\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+void ffpa7_n1 (void (* (* (* [8])[n1])(void))(void));\n+// { dg-warning \"argument 1 of type 'void \\\\\\(\\\\\\* ?\\\\\\(\\\\\\* ?\\\\\\(\\\\\\*\\\\\\[8]\\\\\\)\\\\\\[n1]\\\\\\)\\\\\\(void\\\\\\)\\\\\\)\\\\\\(void\\\\\\)' with mismatched bound\" \"\" { target *-*-* } .-1 }\n+\n+void ffpa9_x (void (* (* (* [9])[*])(void))(void));\n+// { dg-message \"previously declared as 'void \\\\\\(\\\\\\* ?\\\\\\(\\\\\\* ?\\\\\\(\\\\\\*\\\\\\[9]\\\\\\)\\\\\\[\\\\\\*]\\\\\\)\\\\\\(void\\\\\\)\\\\\\)\\\\\\(void\\\\\\)'\" \"pr?????\" { xfail *-*-* } .-1 }\n+// { dg-message \"previously declared as 'void \\\\\\(\\\\\\* ?\\\\\\(\\\\\\* ?\\\\\\(\\\\\\*\\\\\\[9]\\\\\\)\\\\\\[0]\\\\\\)\\\\\\(void\\\\\\)\\\\\\)\\\\\\(void\\\\\\)'\" \"\" { target *-*-* } .-2 }\n+void ffpa9_x (void (* (* (* [8])[*])(void))(void));\n+// { dg-warning \"argument 1 of type 'void \\\\\\(\\\\\\* ?\\\\\\(\\\\\\* ?\\\\\\(\\\\\\*\\\\\\[8]\\\\\\)\\\\\\[\\\\\\*]\\\\\\)\\\\\\(void\\\\\\)\\\\\\)\\\\\\(void\\\\\\)' with mismatched bound\" \"pr?????\" { xfail *-*-* } .-1 }\n+// { dg-warning \"argument 1 of type 'void \\\\\\(\\\\\\* ?\\\\\\(\\\\\\* ?\\\\\\(\\\\\\*\\\\\\[8]\\\\\\)\\\\\\[0]\\\\\\)\\\\\\(void\\\\\\)\\\\\\)\\\\\\(void\\\\\\)' with mismatched bound\"  \"\" { target *-*-* } .-2 }\n+\n+/* Verify a three-dimensional array of pointers to two-dimensional arrays\n+   of pointers to function pointers.  */\n+\n+void ffpa7_5_3 (void (* (* (* (* [7])[5])[3])(void))(void));\n+// { dg-message \"previously declared as 'void ?\\\\\\(\\\\\\* ?\\\\\\(\\\\\\* ?\\\\\\(\\\\\\* ?\\\\\\(\\\\\\* ?\\\\\\[7]\\\\\\)\\\\\\[5]\\\\\\)\\\\\\[3]\\\\\\)\\\\\\(void\\\\\\)\\\\\\)\\\\\\(void\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+void ffpa7_5_3 (void (* (* (* (* [1])[5])[3])(void))(void));\n+// { dg-warning \"argument 1 of type 'void ?\\\\\\(\\\\\\* ?\\\\\\(\\\\\\* ?\\\\\\(\\\\\\* ?\\\\\\(\\\\\\* ?\\\\\\[1]\\\\\\)\\\\\\[5]\\\\\\)\\\\\\[3]\\\\\\)\\\\\\(void\\\\\\)\\\\\\)\\\\\\(void\\\\\\)' with mismatched bound\" \"\" { target *-*-* } .-1 }"}, {"sha": "6e89bf0c801a3fc078003a14cc53d0236e2df0e0", "filename": "gcc/testsuite/gcc.dg/Warray-parameter-5.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-5.c?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -0,0 +1,14 @@\n+/* PR c/50584 - No warning for passing small array to C99 static array\n+   declarator\n+   Verify that -Warray-parameter diagnoses mismatches in bounds of\n+   arrays between redeclarations of the same function and with pointer\n+   parameters pointing to those arrays.\n+   { dg-do compile }\n+   { dg-options \"-Wall -Warray-parameter\" } */\n+\n+void fa_x (int (*)[]);        // { dg-message \"previously declared as 'int \\\\\\(\\\\\\*\\\\\\)\\\\\\[]'\" }\n+void fa_x (int (*)[2]);       // { dg-warning \"\\\\\\[-Warray-parameter\" }\n+void fa_x (int (*)[2]);       // { dg-warning \"mismatch in bound 1 of argument 1 declared as 'int \\\\\\(\\\\\\*\\\\\\)\\\\\\[2]'\" }\n+\n+void fa_2 (int (*)[2]);       // { dg-message \"previously declared as 'int \\\\\\(\\\\\\*\\\\\\)\\\\\\[2]'\" }\n+void fa_2 (int (*)[]);        // { dg-warning \"mismatch in bound 1 of argument 1 declared as 'int \\\\\\(\\\\\\*\\\\\\)\\\\\\[]'\" }"}, {"sha": "42be3100e45e48baae7eab68badd3199b07964bd", "filename": "gcc/testsuite/gcc.dg/Warray-parameter.c", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter.c?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -0,0 +1,187 @@\n+/* PR c/50584 - No warning for passing small array to C99 static array\n+   declarator\n+   Verify that -Warray-parameter diagnoses mismatches in array (and\n+   pointer) arrguments between redeclarations of the same function.\n+   Also verify that the array/pointer argument form in a mismatched\n+   redeclaration doesn't override the form in the initial declaration.\n+   { dg-do compile }\n+   { dg-options \"-Wall -Warray-parameter -Wno-vla-paramater\" } */\n+\n+/* Redclarations with the same or equivalent array form should not\n+   be dianosed.  T[0] is diagnosed by -Wpedantic for being invalid\n+   C so there's little point in also warning for the difference in\n+   array form.  */\n+void f1vpp (void**);\n+void f1vpp (void*[]);\n+void f1vpp (void*[0]);\n+\n+void f1ia_ (int[]);\n+void f1ia_ (int[]);\n+void f1ia_ (int[0]);\n+/* Verify the unused attribute still has an effect.  */\n+void f1ia_ (int a[0] __attribute__ ((unused))) { }\n+void f1ia_ (int[]);\n+\n+void f1ia_p (int[]);\n+void f1ia_p (int*);\n+void f1ia_p (int *p  __attribute__ ((unused))) { }\n+void f1ia_p (int[]);\n+\n+void f1p_ia (const int*);\n+void f1p_ia (const int[]);\n+void f1p_ia (const int *p __attribute__ ((unused))) { }\n+void f1p_ia (const int[]);\n+\n+void f1ia1 (int[1]);\n+void f1ia1 (int[1]);\n+void f1ia1 (int[2 - 1]);\n+\n+void f1ias2 (int[static 2]);\n+void f1ias2 (int[static 2]);\n+void f1ias2 (int[static 1 + 1]);\n+void f1ias2 (int a[static 3 - 1]) { (void)&a; }\n+\n+void f1ipa_ (int*[]);\n+void f1ipa_ (int*[]);\n+void f1ipa_ (int*[0]);\n+\n+void f1ia1_x (int[1]);          // { dg-message \"previously declared as 'int\\\\\\[1]'\" }\n+void f1ia1_x (int[]);           // { dg-warning \"argument 1 of type 'int\\\\\\[]' with mismatched bound\" }\n+void f1ia1_x (int[]);           // { dg-warning \"argument 1 of type 'int\\\\\\[]' with mismatched bound\" }\n+void f1ia1_x (int[1]);\n+void f1ia1_x (int[2]);          // { dg-warning \"argument 1 of type 'int\\\\\\[2]' with mismatched bound\" }\n+void f1ia1_x (int[1]);\n+void f1ia1_x (int[3]);          // { dg-warning \"argument 1 of type 'int\\\\\\[3]' with mismatched bound\" }\n+void f1ia1_x (int a[1] __attribute__ ((unused))) { }\n+\n+\n+void f1ias2_s3 (int[static 2]); // { dg-message \"previously declared as 'int\\\\\\[static 2]'\" }\n+void f1ias2_s3 (int[static 3]); // { dg-warning \"argument 1 of type 'int\\\\\\[static 3]' with mismatched bound\" }\n+/* Verify the unused attribute still has an effect and doesn't interfere\n+   with the warning.  */\n+void f1ias2_s3 (int a[static 3] __attribute__ ((unused))) { }  // { dg-warning \"argument 1 of type 'int\\\\\\[static 3]' with mismatched bound\" }\n+\n+\n+/* Ordinary T[N] and T[static N] forms are both effectively treated\n+   the same but strictly have different meanings so they are diagnosed.\n+   It might be worth splitting the warning into two levels and having\n+   only the higher level treat the ordinary form as T[static N].  */\n+\n+void f1ia3_s4 (int[3]);         // { dg-message \"previously declared as 'int\\\\\\[3]'\" }\n+void f1ia3_s4 (int[static 4]);  // { dg-warning \"argument 1 of type 'int\\\\\\[static 4]' with mismatched bound\" }\n+void f1ia3_s4 (int[3]);\n+\n+\n+void f1ias4_5 (int[static 4]);  // { dg-message \"previously declared as 'int\\\\\\[static 4]'\" }\n+void f1ias4_5 (int[5]);         // { dg-warning \"argument 1 of type 'int\\\\\\[5]' with mismatched bound\" }\n+void f1ias4_5 (int[static 4]);\n+\n+\n+void f1ia_1 (int[]);            // { dg-message \"previously declared as 'int\\\\\\[]'\" }\n+void f1ia_1 (int[1]);           // { dg-warning \"argument 1 of type 'int\\\\\\[1]' with mismatched bound\" }\n+void f1ia_1 (int[]);\n+\n+\n+void f1ca_ (char[]);            // { dg-message \"previously declared as 'char\\\\\\[]'\" }\n+void f1ca_ (char[2]);           // { dg-warning \"argument 1 of type 'char\\\\\\[2]' with mismatched bound\" }\n+void f1ca_ (char[]);\n+\n+\n+void f1csp (const short*);      // { dg-message \"previously declared as 'const short int ?\\\\\\*'\" }\n+void f1csp (const short[3]);    // { dg-warning \"argument 1 of type 'const short int\\\\\\[3]' with mismatched bound\" }\n+void f1csp (const short*);\n+\n+\n+void f1ia2 (int[2]);            // { dg-message \"previously declared as 'int\\\\\\[2]'\" }\n+void f1ia2 (int[1]);            // { dg-warning \"argument 1 of type 'int\\\\\\[1]' with mismatched bound\" }\n+void f1ia2 (int[2]);\n+\n+\n+void f1cvla2 (const volatile long[3]);  // { dg-message \"previously declared as 'const volatile long int\\\\\\[3]'\" }\n+void f1cvla2 (const volatile long[2]);  // { dg-warning \"argument 1 of type 'const volatile long int\\\\\\[2]' with mismatched bound\" }\n+void f1cvla2 (const volatile long[3]);\n+void f1cvla2 (const volatile long[restrict 4]); // { dg-warning \"argument 1 of type 'const volatile long int\\\\\\[restrict 4]' with mismatched bound\" }\n+\n+\n+void f1afa4 (_Atomic float[3]);         // { dg-message \"previously declared as an array '_Atomic float ?\\\\\\[3]'\" }\n+void f1afa4 (_Atomic float*);           // { dg-warning \"argument 1 of type '_Atomic float ?\\\\\\*' declared as a pointer\" }\n+void f1afa4 (_Atomic float[3]);\n+\n+void f1ipa1_a2 (int*[1]);       // { dg-message \"previously declared as 'int \\\\\\*\\\\\\[1]'\" }\n+void f1ipa1_a2 (int*[2]);       // { dg-warning \"argument 1 of type 'int \\\\\\*\\\\\\[2]' with mismatched bound\" }\n+void f1ipa1_a2 (int*[1]);\n+\n+\n+typedef int IAx[];\n+typedef int IA1[1];\n+typedef int IA2[2];\n+typedef int IA3[3];\n+\n+// The message should differentiate between the [] form and *.\n+void f1IAx_A1 (IAx);            // { dg-message \"previously declared as 'int\\\\\\[]'\" \"pr?????\" { xfail *-*-* } }\n+                                // { dg-message \"previously declared as 'int *\\\\\\*'\" \"note\" { target *-*-* } .-1 }\n+void f1IAx_A1 (IA1);            // { dg-message \"argument 1 of type 'int\\\\\\[1]' with mismatched bound\" }\n+\n+void f1IA1_A2 (IA1);            // { dg-message \"previously declared as 'int\\\\\\[1]'\" }\n+void f1IA1_A2 (IA2);            // { dg-warning \"argument 1 of type 'int\\\\\\[2]' with mismatched bound\" }\n+void f1IA1_A2 (IA1);\n+void f1IA1_A2 (int[2]);         // { dg-warning \"argument 1 of type 'int\\\\\\[2]' with mismatched bound\" }\n+\n+\n+void f1IA1_A3 (IA1 ia1);        // { dg-message \"previously declared as 'int\\\\\\[1]'\" }\n+void f1IA1_A3 (IA3 ia3);        // { dg-warning \"argument 1 of type 'int\\\\\\[3]' with mismatched bound\" }\n+void f1IA1_A3 (IA1 ia1);\n+\n+\n+void f1IA2_A3 (IA2 a);          // { dg-message \"previously declared as 'int\\\\\\[2]'\" }\n+void f1IA2_A3 (IA3 a);          // { dg-warning \"argument 1 of type 'int\\\\\\[3]' with mismatched bound\" }\n+void f1IA2_A3 (IA2 a);\n+\n+\n+// Verify multiple array arguments.\n+\n+void f2a2_a3_3_3 (int[2], int[3]);  // { dg-message \"previously declared as 'int\\\\\\[2]'\" }\n+void f2a2_a3_3_3 (int[2], int[3]);\n+void f2a2_a3_3_3 (int[3], int[3]);  // { dg-warning \"argument 1 of type 'int\\\\\\[3]' with mismatched bound\" }\n+\n+\n+void f2a2_a3_2_4 (int[2], int[3]);  // { dg-message \"previously declared as 'int\\\\\\[3]'\" }\n+void f2a2_a3_2_4 (int[2], int[4]);  // { dg-warning \"argument 2 of type 'int\\\\\\[4]' with mismatched bound\" }\n+\n+\n+/* Verify that pointers to arrays and arrays of arrays are differentiated\n+   the same way as pointers and arrays of other types.  */\n+typedef IA1 *PA1;\n+\n+void fpia1 (IA1*);              // { dg-message \"previously declared as 'int ?\\\\(\\\\\\*\\\\)\\\\\\[1]'\" }\n+void fpia1 (IA1[1]);            // { dg-warning \"argument 1 of type 'int\\\\\\[1]\\\\\\[1]' with mismatched bound\" }\n+void fpia1 (PA1);\n+void fpia1 (int(*)[1]);\n+void fpia1 (int[][1]);\n+\n+void f1vpa1 (void*[][1]);\n+void f1vpa1 (void*[0][1]);\n+\n+/* Verify arrays of pointers.  */\n+void vaip1 (int (*[3]));       // { dg-message \"previously declared as 'int *\\\\\\*\\\\\\[3]'\" }\n+void vaip1 (int (*[5]));       // { dg-warning \"argument 1 of type 'int *\\\\\\*\\\\\\[5]' with mismatched bound\" }\n+void vaip1 (int (*[3]));\n+void vaip1 (int (*[]));        // { dg-warning \"argument 1 of type 'int *\\\\\\*\\\\\\[]' with mismatched bound\" }\n+void vaip1 (int (*[3]));\n+\n+/* Verify that attributes with arrays don't cause unwanted warnings and\n+   don't suppress intended ones.  */\n+\n+#define ALIGN(N)__attribute__ ((aligned (__alignof__ (char[N]))))\n+\n+void fatipa2 (int (* ALIGN (3)[2]));  // { dg-message \"previously declared as 'int \\\\\\*\\\\\\[2]'\" }\n+void fatipa2 (int (* ALIGN (4)[2]));\n+void fatipa2 (int (* ALIGN (5)[2]));\n+void fatipa2 (int (* ALIGN (7)[3]));  // { dg-warning \"argument 1 of type 'int \\\\\\*\\\\\\[3]' with mismatched bound\" }\n+\n+void fatiap (int (* ALIGN (3))[2]);\n+void fatiap (int (* ALIGN (5))[2]);\n+\n+\n+void fatipa3 (int (* ALIGN (1) (* ALIGN (2))[3]));\n+void fatipa3 (int (* ALIGN (1) (* ALIGN (2))[3]));"}, {"sha": "da767b87700cc83965299fe726340914715acdc2", "filename": "gcc/testsuite/gcc.dg/Wbuiltin-declaration-mismatch-9.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fgcc.dg%2FWbuiltin-declaration-mismatch-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fgcc.dg%2FWbuiltin-declaration-mismatch-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWbuiltin-declaration-mismatch-9.c?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -10,3 +10,6 @@ void a (void)\n \t  \"\"        /* { dg-warning \"passing argument 2 of .sscanf. from incompatible pointer type\" } */\n \t  );\n }\n+\n+/* The scanf call may also trigger:\n+   { dg-prune-output \"-Wstringop-overflow\" } */"}, {"sha": "ba9324143b47b8c0e6bb8ab8b71a1a8a0dadd0ac", "filename": "gcc/testsuite/gcc.dg/Wvla-parameter-2.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-parameter-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-parameter-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-parameter-2.c?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -0,0 +1,75 @@\n+/* PR c/50584 - No warning for passing small array to C99 static array\n+   declarator\n+   Verify the -Wvla-parameter warnings correctly diagnose mismatches\n+   between multimensional array arguments with one or more variable\n+   bounds in redeclarations of the same function.\n+   { dg-do compile }\n+   { dg-options \"-Wall -Wvla-parameter\" } */\n+\n+void fmn_a1n_axn (int n, int[1][n]);            // { dg-message \"previously declared as 'int\\\\\\[1]\\\\\\[n]' with 1 variable bound\" \"note\" }\n+void fmn_a1n_axn (int n, int[*][n]);            // { dg-warning \"argument 2 of type 'int\\\\\\[\\\\\\*]\\\\\\[n]' declared with 2 variable bounds\" }\n+\n+\n+void fmn_axn_a2n (int n, int[*][n]);            // { dg-message \"previously declared as 'int\\\\\\[\\\\\\*]\\\\\\[n]' with 2 variable bounds\" \"note\" }\n+void fmn_axn_a2n (int n, int[2][n]);            // { dg-warning \"argument 2 of type 'int\\\\\\[2]\\\\\\[n]' declared with 1 variable bound\" }\n+\n+\n+void fmn_amn_axn (int m, int n, int[m][n]);     // { dg-message \"previously declared as 'int\\\\\\[m]\\\\\\[n]' with 0 unspecified variable bounds\" \"note\" }\n+void fmn_amn_axn (int m, int n, int[*][n]);     // { dg-warning \"argument 3 of type 'int\\\\\\[\\\\\\*]\\\\\\[n]' declared with 1 unspecified variable bound\" }\n+\n+// Same as above but a different function name.\n+void gmn_amn_axn (int m, int n, int[m][n]);     // { dg-message \"previously declared as 'int\\\\\\[m]\\\\\\[n]' with 0 unspecified variable bounds\" \"note\" }\n+void gmn_amn_axn (int m, int n, int[*][n]);     // { dg-warning \"argument 3 of type 'int\\\\\\[\\\\\\*]\\\\\\[n]' declared with 1 unspecified variable bound\" }\n+\n+typedef int A7[7];\n+\n+void fm_A7_m_5 (int m, A7[m][5]);               // { dg-message \"previously declared as 'int\\\\\\[m]\\\\\\[5]\\\\\\[7]' with bound argument 1\" \"note\" }\n+void fm_A7_m_5 (int n, A7[n][5]);\n+\n+void fm_A7_m_5 (int n, A7[n + 1][5]);           // { dg-warning \"argument 2 of type 'int\\\\\\[n \\\\\\+ 1]\\\\\\[5]\\\\\\[7]' declared with mismatched bound 'n \\\\\\+ 1'\" }\n+\n+\n+int n1, n2, n3, n4, n5, n6, n7, n8, n9;\n+void f (int[n1][2][n3][4][n5][6][n7][8][n9]);   // { dg-message \"previously declared as 'int\\\\\\[n1]\\\\\\[2]\\\\\\[n3]\\\\\\[4]\\\\\\[n5]\\\\\\[6]\\\\\\[n7]\\\\\\[8]\\\\\\[n9]' with 0 unspecified variable bounds\" \"note\" }\n+                                                // { dg-message \"with 5 variable bounds\" \"note\" { target *-*-* } .-1  }\n+void f (int[n1][2][n3][4][n5][6][n7][8][n9]);\n+\n+/* Due to a limitation and because [*] is represented the same as [0]\n+   only the most significant array bound is rendered as [*]; the others\n+   are rendered as [0].  */\n+void f (int[n1][2][n3][4][n5][6][n7][8][*]);    // { dg-warning \"argument 1 of type 'int\\\\\\[n1]\\\\\\[2]\\\\\\[n3]\\\\\\[4]\\\\\\[n5]\\\\\\[6]\\\\\\[n7]\\\\\\[8]\\\\\\[\\\\\\*]' declared with 1 unspecified variable bound\" \"pr?????\" { xfail *-*-* } }\n+// { dg-warning \"argument 1 of type 'int\\\\\\[n1]\\\\\\[2]\\\\\\[n3]\\\\\\[4]\\\\\\[n5]\\\\\\[6]\\\\\\[n7]\\\\\\[8]\\\\\\[0]' declared with 1 unspecified variable bound\" \"pr?????\" { target *-*-* } .-1 }\n+void f (int[n1][2][n3][4][n5][6][*][8][n9]);   // { dg-warning \"argument 1 of type 'int\\\\\\[n1]\\\\\\[2]\\\\\\[n3]\\\\\\[4]\\\\\\[n5]\\\\\\[6]\\\\\\[\\\\\\*]\\\\\\[8]\\\\\\[n9]' declared with 1 unspecified variable bound\" \"pr?????\" { xfail *-*-* } }\n+// { dg-warning \"argument 1 of type 'int\\\\\\[n1]\\\\\\[2]\\\\\\[n3]\\\\\\[4]\\\\\\[n5]\\\\\\[6]\\\\\\[0]\\\\\\[8]\\\\\\[n9]' declared with 1 unspecified variable bound\" \"pr?????\" { target *-*-* } .-1 }\n+void f (int[n1][2][n3][4][*][6][n7][8][n9]);   // { dg-warning \"argument 1 of type 'int\\\\\\[n1]\\\\\\[2]\\\\\\[n3]\\\\\\[4]\\\\\\[\\\\\\*]\\\\\\[6]\\\\\\[n7]\\\\\\[8]\\\\\\[n9]' declared with 1 unspecified variable bound\" \"pr?????\" { xfail *-*-*} }\n+// { dg-warning \"argument 1 of type 'int\\\\\\[n1]\\\\\\[2]\\\\\\[n3]\\\\\\[4]\\\\\\[0]\\\\\\[6]\\\\\\[n7]\\\\\\[8]\\\\\\[n9]' declared with 1 unspecified variable bound\" \"pr?????\" { target *-*-* } .-1 }\n+void f (int[n1][2][*][4][n5][6][n7][8][n9]);   // { dg-warning \"argument 1 of type 'int\\\\\\[n1]\\\\\\[2]\\\\\\[\\\\\\*]\\\\\\[4]\\\\\\[n5]\\\\\\[6]\\\\\\[n7]\\\\\\[8]\\\\\\[n9]' declared with 1 unspecified variable bound\" \"pr?????\" { xfail *-*-* } }\n+// { dg-warning \"argument 1 of type 'int\\\\\\[n1]\\\\\\[2]\\\\\\[0]\\\\\\[4]\\\\\\[n5]\\\\\\[6]\\\\\\[n7]\\\\\\[8]\\\\\\[n9]' declared with 1 unspecified variable bound\" \"pr?????\" { target *-*-* } .-1 }\n+void f (int[*][2][n3][4][n5][6][n7][8][n9]);   // { dg-warning \"argument 1 of type 'int\\\\\\[\\\\\\*]\\\\\\[2]\\\\\\[n3]\\\\\\[4]\\\\\\[n5]\\\\\\[6]\\\\\\[n7]\\\\\\[8]\\\\\\[n9]' declared with 1 unspecified variable bound\" }\n+\n+void f (int[n1][n2][n3][n4][n5][n6][n7][n8][n9]);   // { dg-warning \"argument 1 of type 'int\\\\\\[n1]\\\\\\[n2]\\\\\\[n3]\\\\\\[n4]\\\\\\[n5]\\\\\\[n6]\\\\\\[n7]\\\\\\[n8]\\\\\\[n9]' declared with 9 variable bounds\" }\n+\n+// Verify that arrays of pointers to arrays...etc are handled correctly.\n+void a2pampan (int (*(*(*[2])[n1])[n2]));\n+// { dg-message \"previously declared as 'int \\\\\\* \\\\\\(\\\\\\* \\\\\\(\\\\\\*\\\\\\[2]\\\\\\)\\\\\\[n1]\\\\\\)\\\\\\[n2]'\" \"note\" { target *-*-* } .-1 }\n+void a2pampan (int (*(*(*[2])[n1])[1]));\n+// { dg-warning \"argument 1 of type 'int \\\\\\* \\\\\\(\\\\\\* \\\\\\(\\\\\\*\\\\\\[2]\\\\\\)\\\\\\[n1]\\\\\\)\\\\\\[1]' declared with 1 variable bound\" \"\" { target *-*-* } .-1  }\n+void a2pampan (int (*(*(*[2])[1])[n2]));\n+// { dg-warning \"argument 1 of type 'int \\\\\\* \\\\\\(\\\\\\* \\\\\\(\\\\\\*\\\\\\[2]\\\\\\)\\\\\\[1]\\\\\\)\\\\\\[n2]' declared with 1 variable bound\" \"\" { target *-*-* } .-1  }\n+void a2pampan (int (*(*(*[2])[n1])[n1]));\n+// { dg-warning \"argument 1 of type 'int \\\\\\* \\\\\\(\\\\\\* \\\\\\(\\\\\\*\\\\\\[2]\\\\\\)\\\\\\[n1]\\\\\\)\\\\\\[n1]' declared with mismatched bound 'n1'\" \"\" { target *-*-* } .-1  }\n+void a2pampan (int (*(*(*[2])[n1])[n2]));\n+\n+\n+/* Verify that the presence or absence of static with VLA dooesn't cause\n+   unwanted warnings.  */\n+\n+int f2ia1_1 (int n, int [n][n]);            // { sg-message \"previously declared as 'int\\\\\\[n]\\\\\\[n]' with bound argument 1\" }\n+int f2ia1_1 (int n, int[static n][n]);\n+int f2ia1_1 (int n, int a[static n][n]) { return sizeof *a; }\n+int f2ia1_1 (int n, int[static n + 1][n]);  // { dg-warning \"argument 2 of type 'int\\\\\\[n \\\\\\+ 1]\\\\\\[n]' declared with mismatched bound 'n \\\\\\+ 1'\" }\n+\n+int f2ias1_1 (int n, int [static n][n]);    // { dg-message \"previously declared as 'int\\\\\\[n]\\\\\\[n]' with bound argument 1\" }\n+int f2ias1_1 (int n, int[n][n]);\n+int f2ias1_1 (int n, int a[++n][n])         // { dg-warning \"argument 2 of type 'int\\\\\\[\\\\\\+\\\\\\+n]\\\\\\[n]' declared with mismatched bound ' ?\\\\+\\\\+n'\" }\n+{ return sizeof *a; }"}, {"sha": "51f01729b1df4055f304d91d6b21624f0e558ebe", "filename": "gcc/testsuite/gcc.dg/Wvla-parameter-3.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-parameter-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-parameter-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-parameter-3.c?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -0,0 +1,68 @@\n+/* PR c/50584 - No warning for passing small array to C99 static array\n+   declarator\n+   Verify that redeclarations of functions with pointer parameters to\n+   arrays with variable bounds are diagnosed if the bounds don't match\n+   either in kind or in the variable expression.\n+   { dg-do compile }\n+   { dg-options \"-Wall -Wvla-parameter\" } */\n+\n+extern int m, n;\n+\n+void pa_ (int (*)[]);                   // { dg-message \"previously declared as 'int \\\\\\(\\\\\\*\\\\\\)\\\\\\[]'\" \"note\" }\n+void pa_ (int (*)[n]);                  // { dg-warning \"\\\\\\[-Wvla-parameter\" }\n+void pa_ (int (*)[n + 1]);              // { dg-warning \"mismatch in bound 1 of argument 1 declared as 'int *\\\\\\(\\\\\\*\\\\\\)\\\\\\[n \\\\\\+ 1\\\\\\]'\" }\n+\n+void ppa_ (int (**)[]);                 // { dg-message \"previously declared as 'int \\\\\\(\\\\\\*\\\\\\*\\\\\\)\\\\\\[]'\" \"note\" }\n+void ppa_ (int (**)[n]);                // { dg-warning \"\\\\\\[-Wvla-parameter\" }\n+void ppa_ (int (**)[n + 1]);            // { dg-warning \"mismatch in bound 1 of argument 1 declared as 'int \\\\\\(\\\\\\*\\\\\\*\\\\\\)\\\\\\[n \\\\\\+ 1\\\\\\]'\" }\n+\n+void pa1 (int (*)[1]);                  // { dg-message \"previously declared as 'int \\\\\\(\\\\\\*\\\\\\)\\\\\\[1]'\" \"note\" }\n+void pa1 (int (*)[n]);                  // { dg-warning \"\\\\\\[-Wvla-parameter\" }\n+void pa1 (int (*)[1]);\n+void pa1 (int (*)[n + 1]);              // { dg-warning \"mismatch in bound 1 of argument 1 declared as 'int *\\\\\\(\\\\\\*\\\\\\)\\\\\\[n \\\\\\+ 1\\\\\\]'\" }\n+\n+void ppax (int (**)[*]);                // { dg-message \"previously declared as 'int \\\\\\(\\\\\\*\\\\\\*\\\\\\)\\\\\\[.]'\" \"note\" }\n+void ppax (int (**)[n]);                // { dg-warning \"\\\\\\[-Wvla-parameter\" }\n+/* A VLA with an unspecified bound is represented the same as [0] so\n+   so the pretty printer can't differentiate between the two forms.  */\n+void ppax (int (**)[1]);                // { dg-bogus \"\\\\\\[-Warray-parameter\" \"pr?????\" { xfail *-*-* } }\n+                                        // { dg-warning \"\\\\\\[-Wvla-parameter\" \"pr?????\" { xfail *-*-* } .-1 }\n+void ppax (int (**)[n + 1]);            // { dg-warning \"mismatch in bound 1 of argument 1 declared as 'int *\\\\\\(\\\\\\*\\\\\\*\\\\\\)\\\\\\[n \\\\\\+ 1\\\\\\]'\" }\n+\n+\n+void pa1_n (int (*)[1][n]);\n+void pa1_n (int (*)[1][n]);\n+void pa1_n (int (*)[*][n]);             // { dg-warning \"mismatch in bound 1 of argument 1 declared as 'int \\\\\\(\\\\\\*\\\\\\)\\\\\\[\\\\\\*]\\\\\\[n]'\" \"pr?????\" { xfail *-*-*} }\n+                                        // { dg-warning \"mismatch in bound 1 of argument 1 declared as 'int \\\\\\(\\\\\\*\\\\\\)\\\\\\[0]\\\\\\[n]'\" \"pr?????\" { target *-*-* } .-1 }\n+\n+void pa1_n_2 (int (*)[1][n][2]);\n+void pa1_n_2 (int (*)[1][n][*]);        // { dg-warning \"mismatch in bound 3 of argument 1 declared as 'int \\\\\\(\\\\\\*\\\\\\)\\\\\\[1]\\\\\\[n]\\\\\\[\\\\\\*]'\" \"pr?????\" { xfail *-*-* } }\n+                                        // { dg-warning \"mismatch in bound 3 of argument 1 declared as 'int \\\\\\(\\\\\\*\\\\\\)\\\\\\[1]\\\\\\[n]\\\\\\[0]'\" \"pr?????\" { target *-*-* } .-1 }\n+\n+\n+void pa1_n_2_a1_n_2 (int (*)[1][n][2], int (*)[1][n][2]);\n+// { dg-message \"previously declared as 'int \\\\\\(\\\\\\*\\\\\\)\\\\\\[1]\\\\\\[n]\\\\\\[2]'\" \"note\" { target *-*-* } .-1 }\n+void pa1_n_2_a1_n_2 (int (*)[1][n][2], int (*)[1][n][n]);\n+// { dg-warning \"mismatch in bound 3 of argument 2 declared as 'int \\\\\\(\\\\\\*\\\\\\)\\\\\\[1]\\\\\\[n]\\\\\\[n]'\" \"\" { target *-*-* } .-1 }\n+void pa1_n_2_a1_n_2 (int (*)[1][n][2], int (*)[1][3][2]);\n+// { dg-warning \"mismatch in bound 2 of argument 2 declared as 'int \\\\\\(\\\\\\*\\\\\\)\\\\\\[1]\\\\\\[3]\\\\\\[2]'\" \"\" { target *-*-* } .-1 }\n+void pa1_n_2_a1_n_2 (int (*)[1][n][2], int (*)[n][n][2]);\n+// { dg-warning \"mismatch in bound 1 of argument 2 declared as 'int \\\\\\(\\\\\\*\\\\\\)\\\\\\[n]\\\\\\[n]\\\\\\[2]'\" \"\" { target *-*-* } .-1 }\n+void pa1_n_2_a1_n_2 (int (*)[1][n][n], int (*)[1][n][2]);\n+// { dg-warning \"mismatch in bound 3 of argument 1 declared as 'int \\\\\\(\\\\\\*\\\\\\)\\\\\\[1]\\\\\\[n]\\\\\\[n]'\" \"\" { target *-*-* } .-1 }\n+void pa1_n_2_a1_n_2 (int (*)[n][n][2], int (*)[1][n][2]);\n+// { dg-warning \"mismatch in bound 1 of argument 1 declared as 'int \\\\\\(\\\\\\*\\\\\\)\\\\\\[n]\\\\\\[n]\\\\\\[2]'\" \"\" { target *-*-* } .-1 }\n+void pa1_n_2_a1_n_2 (int (*)[*][*][*], int (*)[*][*][2]);\n+// { dg-warning \"mismatch in bounds 1, 2, 3 of argument 1 declared as 'int \\\\\\(\\\\\\*\\\\\\)\\\\\\[.]\\\\\\[.]\\\\\\[.]'\" \"\" { target *-*-* } .-1 }\n+// { dg-warning \"mismatch in bounds 1, 2 of argument 2 declared as 'int \\\\\\(\\\\\\*\\\\\\)\\\\\\[.]\\\\\\[.]\\\\\\[2]'\" \"\" { target *-*-* } .-2 }\n+void pa1_n_2_a1_n_2 (int (*)[1][n][2], int (*)[1][n][2]);\n+\n+/* Verify that pointers to arrays of pointers to arrays...etc are handled\n+   correctly.  */\n+void pa2pampan (int (*(*(*(*)[2])[m])[n]));\n+// { dg-message \"previously declared as 'int \\\\\\* \\\\\\(\\\\\\* \\\\\\(\\\\\\* \\\\\\(\\\\\\*\\\\\\)\\\\\\[2]\\\\\\)\\\\\\[m]\\\\\\)\\\\\\[n]'\" \"note\" { target *-*-* } .-1 }\n+void pa2pampan (int (*(*(*(*)[2])[m])[1]));\n+// { dg-warning \"mismatch in bound 3 of argument 1 declared as 'int \\\\\\* \\\\\\(\\\\\\* \\\\\\(\\\\\\* \\\\\\(\\\\\\*\\\\\\)\\\\\\[2]\\\\\\)\\\\\\[m]\\\\\\)\\\\\\[1]'\" \"\" { target *-*-* } .-1  }\n+void pa2pampan (int (*(*(*(*)[2])[1])[n]));\n+// { dg-warning \"mismatch in bound 2 of argument 1 declared as 'int \\\\\\* \\\\\\(\\\\\\* \\\\\\(\\\\\\* \\\\\\(\\\\\\*\\\\\\)\\\\\\[2]\\\\\\)\\\\\\[1]\\\\\\)\\\\\\[n]'\" \"\" { target *-*-* } .-1  }\n+void pa2pampan (int (*(*(*(*)[2])[m])[n]));"}, {"sha": "599ad19a3e43b2715717716c2ecab4c3a8cb3936", "filename": "gcc/testsuite/gcc.dg/Wvla-parameter-4.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-parameter-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-parameter-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-parameter-4.c?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -0,0 +1,99 @@\n+/* PR c/50584 - No warning for passing small array to C99 static array\n+   declarator\n+   Verify warnings for redeclarations of functions with pointer parameters\n+   to arrays with variable bounds involving typedefs.\n+   { dg-do compile }\n+   { dg-options \"-Wall -Wvla-parameter\" } */\n+\n+extern int m, n;\n+\n+typedef int IA3[3];\n+\n+/* Verify the warning points to the declaration with more unspecified\n+   bounds, guiding the user to specify them rather than making them all\n+   unspecified.  */\n+void* f_pIA3ax (IA3 *x[*]);             // { dg-warning \"argument 1 of type 'int \\\\\\(\\\\\\*\\\\\\[\\\\\\*]\\\\\\)\\\\\\[3]' .aka '\\[^\\n\\r\\}\\]+'. declared with 1 unspecified variable bound\" }\n+void* f_pIA3ax (IA3 *x[*]);\n+void* f_pIA3ax (IA3 *x[n]);             // { dg-message \"subsequently declared as 'int \\\\\\(\\\\\\*\\\\\\[n]\\\\\\)\\\\\\[3]' with 0 unspecified variable bounds\" \"note\" }\n+void* f_pIA3ax (IA3 *x[n]) { return x; }\n+\n+\n+void* f_pIA3an (IA3 *x[n]);              // { dg-message \"previously declared as 'int \\\\\\(\\\\\\*\\\\\\[n]\\\\\\)\\\\\\[3]' with 0 unspecified variable bounds\" \"note\" }\n+void* f_pIA3an (IA3 *x[n]);\n+void* f_pIA3an (IA3 *x[*]);              // { dg-warning \"argument 1 of type 'int \\\\\\(\\\\\\*\\\\\\[\\\\\\*]\\\\\\)\\\\\\[3]' .aka '\\[^\\n\\r\\}\\]+'. declared with 1 unspecified variable bound\" }\n+void* f_pIA3an (IA3 *x[n]) { return x; }\n+\n+\n+void nowarn_local_fndecl (void)\n+{\n+  typedef int IAm[m];\n+\n+  void* f_IAm (IAm);\n+  void* f_IAm (int[m]);\n+  void* f_IAm (IAm);\n+\n+  void* f_iam (int[m]);\n+  void* f_iam (IAm);\n+  void* f_iam (int[m]);\n+\n+  typedef int     IA3[3];\n+  typedef IA3     IAn_3[n];\n+  typedef IAn_3   IA2_n_3[2];\n+  typedef IA2_n_3 IAm_2_n_3[m];\n+\n+  void f_IAm_2_n_3 (IAm_2_n_3);\n+  void f_IAm_2_n_3 (IA2_n_3[m]);\n+  void f_IAm_2_n_3 (IAn_3[m][2]);\n+  void f_IAm_2_n_3 (IA3[m][2][n]);\n+  void f_IAm_2_n_3 (int[m][2][n][3]);\n+\n+  void f_iam_2_n_3 (int[m][2][n][3]);\n+  void f_iam_2_n_3 (IA3[m][2][n]);\n+  void f_iam_2_n_3 (IAn_3[m][2]);\n+  void f_iam_2_n_3 (IAm_2_n_3);\n+\n+  void f_IAx_m_2_n_3 (IAm_2_n_3[*]);\n+  void f_IAx_m_2_n_3 (IA2_n_3[*][m]);\n+  void f_IAx_m_2_n_3 (IAn_3[*][m][2]);\n+  void f_IAx_m_2_n_3 (IA3[*][m][2][n]);\n+  void f_IAx_m_2_n_3 (int[*][m][2][n][3]);\n+\n+  void f_IA__m_2_n_3 (IAm_2_n_3[]);\n+  void f_IA__m_2_n_3 (IA2_n_3[][m]);\n+  void f_IA__m_2_n_3 (IAn_3[][m][2]);\n+  void f_IA__m_2_n_3 (IA3[][m][2][n]);\n+  void f_IA__m_2_n_3 (int[][m][2][n][3]);\n+}\n+\n+\n+void warn_local_fndecl (void)\n+{\n+  typedef int IAm[m];\n+  typedef int IAn[n];\n+\n+  void* g_IAm (IAm);                    // { dg-message \"previously declared as 'int\\\\\\[m]' with bound 'm'\" }\n+  void* g_IAm (int[n]);                 // { dg-warning \"argument 1 of type 'int\\\\\\[n]' declared with mismatched bound 'n'\" }\n+  void* g_IAm (IAm);\n+\n+  void* g_iam (int[m]);                 // { dg-message \"previously declared as 'int\\\\\\[m]' with bound 'm'\" }\n+  void* g_iam (IAn);                    // { dg-warning \"argument 1 of type 'int\\\\\\[n]' declared with mismatched bound 'n'\" }\n+  void* g_iam (int[m]);\n+\n+\n+  typedef int     IA3[3];\n+  typedef IA3     IAn_3[n];\n+  typedef IAn_3   IA2_n_3[2];\n+  typedef IA2_n_3 IAm_2_n_3[m];\n+\n+  typedef IA3     IAm_3[m];\n+  typedef IAm_3   IA2_m_3[2];\n+  typedef IA2_m_3 IAm_2_m_3[m];\n+\n+  void* g_IAm_2_n_3 (IAm_2_n_3);\n+  void* g_IAm_2_n_3 (int[m][2][m][3]);  // { dg-warning \"argument 1 of type 'int\\\\\\[m]\\\\\\[2]\\\\\\[m]\\\\\\[3]' declared with mismatched bound 'm'\" }\n+  void* g_IAm_2_n_3 (IAm_2_n_3);\n+\n+  void* g_iam_2_n_2 (int[m][2][n][3]);\n+  void* g_iam_2_n_2 (IAm_2_m_3);        // { dg-warning \"argument 1 of type 'int\\\\\\[m]\\\\\\[2]\\\\\\[m]\\\\\\[3]' declared with mismatched bound 'm'\" }\n+  void* g_iam_2_n_2 (int[m][2][n][3]);\n+}"}, {"sha": "6e4df02969c56f00ee52ca400518d994c23b35ea", "filename": "gcc/testsuite/gcc.dg/Wvla-parameter.c", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-parameter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-parameter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWvla-parameter.c?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -0,0 +1,136 @@\n+/* PR c/50584 - No warning for passing small array to C99 static array\n+   declarator\n+   Verify the -Wvla-parameter warnings correctly diagnose mismatches\n+   between one-dimensional VLA and non-VLA arguments in redeclarations\n+   of the same function.\n+   Also verify that the array/pointer argument form in a mismatched\n+   redeclaration doesn't override the form in the initial declaration.\n+   { dg-do compile }\n+   { dg-options \"-Wall -Wvla-parameter\" } */\n+\n+/* Verify that redeclaring an argument as a VLA with an unspecified\n+   bound that was first declared as an ordinary array with an unspecified\n+   bound triggers a warning.  */\n+void f1ia_x (int[]);          // { dg-message \"previously declared as an ordinary array 'int\\\\\\[]'\" \"note\" }\n+void f1ia_x (int[*]);         // { dg-warning \"argument 1 of type 'int\\\\\\[\\\\\\*]' declared as a variable length array\" }\n+void f1ia_x (int[]);\n+void f1ia_x (int[*]);         // { dg-warning \"argument 1 of type 'int\\\\\\[\\\\\\*]' declared as a variable length array\" }\n+/* Also verify that a definition of the same form as the first declaration\n+   doesn't trigger a warning and doesn't prevent warnings for subsequent\n+   mismatches.  */\n+void f1ia_x (int a[]) { (void)&a;}\n+void f1ia_x (int[*]);         // { dg-warning \"argument 1 of type 'int\\\\\\[\\\\\\*]' declared as a variable length array\" }\n+\n+/* Repeat the above but starting with an ordinary array with a constant\n+   bound.  */\n+void f1ia1x (int[1]);          // { dg-message \"previously declared as an ordinary array 'int\\\\\\[1]'\" \"note\" }\n+void f1ia1x (int[*]);         // { dg-warning \"argument 1 of type 'int\\\\\\[\\\\\\*]' declared as a variable length array\" }\n+void f1ia1x (int a[1]) { (void)&a; }\n+void f1ia1x (int[1]);\n+void f1ia1x (int[*]);         // { dg-warning \"argument 1 of type 'int\\\\\\[\\\\\\*]' declared as a variable length array\" }\n+\n+void f1ipx (int*);            // { dg-message \"previously declared as a pointer 'int ?\\\\\\*'\" \"note\" }\n+void f1ipx (int[*]);          // { dg-warning \"argument 1 of type 'int\\\\\\[\\\\\\*]' declared as a variable length array\" }\n+void f1ipx (int*);\n+void f1ipx (int *p) { (void)&p; }\n+void f1ipx (int[*]);          // { dg-warning \"argument 1 of type 'int\\\\\\[\\\\\\*]' declared as a variable length array\" }\n+void f1ipx (int*);\n+\n+void f2ipx (int*, int*);      // { dg-message \"previously declared as a pointer 'int ?\\\\\\*'\" \"note\" }\n+void f2ipx (int*, int[*]);    // { dg-warning \"argument 2 of type 'int\\\\\\[\\\\\\*]' declared as a variable length array\" }\n+void f2ipx (int*, int*);\n+void f2ipx (int*, int[*]);    // { dg-warning \"argument 2 of type 'int\\\\\\[\\\\\\*]' declared as a variable length array\" }\n+void f2ipx (int *p, int *q) { (void)&p; (void)&q; }\n+void f2ipx (int*, int[*]);    // { dg-warning \"argument 2 of type 'int\\\\\\[\\\\\\*]' declared as a variable length array\" }\n+\n+void f1ias2x (int[static 2]); // { dg-message \"previously declared as an ordinary array 'int\\\\\\[static 2]'\" }\n+void f1ias2x (int[*]);        // { dg-warning \"argument 1 of type 'int\\\\\\[\\\\\\*]' declared as a variable length array\" }\n+void f1ias2x (int[static 2]);\n+void f1ias2x (int[*]);        // { dg-warning \"argument 1 of type 'int\\\\\\[\\\\\\*]' declared as a variable length array\" }\n+void f1ias2x (int a[static 2]) { (void)&a; }\n+void f1ias2x (int[*]);        // { dg-warning \"argument 1 of type 'int\\\\\\[\\\\\\*]' declared as a variable length array\" }\n+void f1ias2x (int[static 2]);\n+\n+extern int nelts;\n+\n+void f1sa_var (short[]);      // { dg-message \"previously declared as an ordinary array 'short int\\\\\\[]'\" }\n+void f1sa_var (short[nelts]); // { dg-warning \"argument 1 of type 'short int\\\\\\[nelts]' declared as a variable length array\" }\n+void f1sa_var (short[]);\n+void f1sa_var (short[nelts]); // { dg-warning \"argument 1 of type 'short int\\\\\\[nelts]' declared as a variable length array\" }\n+void f1sa_var (short a[]) { (void)&a; }\n+void f1sa_var (short[nelts]); // { dg-warning \"argument 1 of type 'short int\\\\\\[nelts]' declared as a variable length array\" }\n+void f1sa_var (short[]);\n+\n+void f1sa_expr (int[]);           // { dg-message \"previously declared as an ordinary array 'int\\\\\\[]'\" }\n+void f1sa_expr (int[nelts + 1]);  // { dg-warning \"argument 1 of type 'int\\\\\\[nelts \\\\\\+ 1]' declared as a variable length array\" }\n+void f1sa_expr (int[]);\n+void f1sa_expr (int[nelts * 2]);  // { dg-warning \"argument 1 of type 'int\\\\\\[nelts \\\\\\* 2]' declared as a variable length array\" }\n+void f1sa_expr (int a[]) { (void)&a; }\n+void f1sa_expr (int[nelts / 3]);  // { dg-warning \"argument 1 of type 'int\\\\\\[nelts / 3]' declared as a variable length array\" }\n+void f1sa_expr (int[]);\n+\n+extern int f (int);\n+\n+void f1ia_f (int[]);          // { dg-message \"previously declared as an ordinary array 'int\\\\\\[]'\" }\n+void f1ia_f (int[f (1)]);     // { dg-warning \"argument 1 of type 'int\\\\\\[f *\\\\\\(1\\\\\\)]' declared as a variable length array\" }\n+void f1ia_f (int[]);\n+void f1ia_f (int[f (2)]);     // { dg-warning \"argument 1 of type 'int\\\\\\[f *\\\\\\(2\\\\\\)]' declared as a variable length array\" }\n+void f1ia_f (int a[]) { (void)&a; }\n+void f1ia_f (int[f (3)]);     // { dg-warning \"argument 1 of type 'int\\\\\\[f *\\\\\\(3\\\\\\)]' declared as a variable length array\" }\n+void f1ia_f (int[f (4)]);     // { dg-warning \"argument 1 of type 'int\\\\\\[f *\\\\\\(4\\\\\\)]' declared as a variable length array\" }\n+void f1ia_f (int[]);\n+\n+void f1iaf0_f1 (int[f (0)]);  // { dg-message \"previously declared as 'int\\\\\\[f *\\\\\\(0\\\\\\)]'\" }\n+void f1iaf0_f1 (int[f (1)]);  // { dg-warning \"argument 1 of type 'int\\\\\\[f *\\\\\\(1\\\\\\)]' declared with mismatched bound\" }\n+void f1iaf0_f1 (int[f (0)]);\n+void f1iaf0_f1 (int[f (1)]);  // { dg-warning \"argument 1 of type 'int\\\\\\[f *\\\\\\(1\\\\\\)]' declared with mismatched bound\" }\n+void f1iaf0_f1 (int a[f (0)]) { (void)&a; }\n+void f1iaf0_f1 (int[f (1)]);  // { dg-warning \"argument 1 of type 'int\\\\\\[f *\\\\\\(1\\\\\\)]' declared with mismatched bound\" }\n+void f1iaf0_f1 (int[f (0)]);\n+\n+void f1la_ (long[]);         // { dg-message \"previously declared as an ordinary array 'long int\\\\\\[]'\" }\n+void f1la_ (long[nelts]);    // { dg-warning \"argument 1 of type 'long int\\\\\\[nelts]' declared as a variable length array\" }\n+void f1la_ (long[]);\n+void f1la_ (long a[nelts])   // { dg-warning \"argument 1 of type 'long int\\\\\\[nelts]' declared as a variable length array\" }\n+{ (void)&a; }\n+void f1la_ (long[]);\n+\n+void f2ca_ (int, char[]);     // { dg-message \"previously declared as an ordinary array 'char\\\\\\[]'\" }\n+void f2ca_ (int n, char[n]);  // { dg-warning \"argument 2 of type 'char\\\\\\[n]' declared as a variable length array\" }\n+void f2ca_ (int, char[]);\n+void f2ca_ (int n, char a[n]) // { dg-warning \"argument 2 of type 'char\\\\\\[n]' declared as a variable length array\" }\n+{ (void)&n; (void)&a; }\n+\n+void f2ia1_f (int n, int[n]);     // { dg-message \"previously declared as 'int\\\\\\[n]' with bound argument 1\" }\n+void f2ia1_f (int,   int[f (0)]); // { dg-warning \"argument 2 of type 'int\\\\\\[f *\\\\\\(0\\\\\\)]' declared with mismatched bound 'f *\\\\\\(0\\\\\\)'\" }\n+void f2ia1_f (int m, int[m]);\n+void f2ia1_f (int,   int[f (1)]); // { dg-warning \"argument 2 of type 'int\\\\\\[f *\\\\\\(1\\\\\\)]' declared with mismatched bound 'f *\\\\\\(1\\\\\\)'\" }\n+void f2ia1_f (int x, int a[x]) { (void)&x; (void)&a; }\n+void f2ia1_f (int,   int[f (2)]);   // { dg-warning \"argument 2 of type 'int\\\\\\[f *\\\\\\(2\\\\\\)]' declared with mismatched bound 'f *\\\\\\(2\\\\\\)'\" }\n+void f2ia1_f (int y, int[y]);\n+\n+void f2iaf_1 (int,   int[f (0)]); // { dg-message \"previously declared as 'int\\\\\\[f *\\\\\\(0\\\\\\)]'\" }\n+void f2iaf_1 (int n, int[n]);     // { dg-warning \"argument 2 of type 'int\\\\\\[n]' declared with mismatched bound argument 1\" }\n+void f2iaf_1 (int,   int[f (0)]);\n+void f2iaf_1 (int m, int[m]);     // { dg-warning \"argument 2 of type 'int\\\\\\[m]' declared with mismatched bound argument 1\" }\n+void f2iaf_1 (int x, int a[f (0)]) { (void)&x; (void)&a; }\n+void f2iaf_1 (int y, int[y]);     // { dg-warning \"argument 2 of type 'int\\\\\\[y]' declared with mismatched bound argument 1\" }\n+\n+\n+void f3ia1 (int n, int, int[n]);  // { dg-message \"previously declared as 'int\\\\\\[n]' with bound argument 1\" }\n+void f3ia1 (int, int n, int[n]);  // { dg-warning \"argument 3 of type 'int\\\\\\[n]' declared with mismatched bound argument 2\" }\n+void f3ia1 (int n, int, int[n]);\n+\n+\n+extern int g (int);\n+\n+void f1iaf_g (int[f (1)]);    // { dg-message \"previously declared as 'int\\\\\\[f *\\\\\\(1\\\\\\)]'\" }\n+void f1iaf_g (int[g (1)]);    // { dg-warning \"argument 1 of type 'int\\\\\\[g *\\\\\\(1\\\\\\)]' declared with mismatched bound\" }\n+void f1iaf_g (int[f (1)]);\n+\n+\n+void nrf1iaf_g (int[f (1)]);  // { dg-message \"previously declared as 'int\\\\\\[f *\\\\\\(1\\\\\\)]'\" }\n+__attribute__ ((nonnull))\n+void nrf1iaf_g (int[g (1)]);  // { dg-warning \"argument 1 of type 'int\\\\\\[g *\\\\\\(1\\\\\\)]' declared with mismatched bound\" }\n+__attribute__ ((noreturn))\n+void nrf1iaf_g (int[f (1)]);"}, {"sha": "deeee736eb8207d8bac853e69ec19f8978155e54", "filename": "gcc/testsuite/gcc.dg/attr-access-read-write-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-read-write-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-read-write-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-read-write-2.c?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -22,12 +22,12 @@ int RW (1) grdwr1_wr1 (void*, void*);           // { dg-message \"previous declar\n int WO (1) grdwr1_wr1 (void*, void*);         // { dg-warning \"attribute 'access\\\\(write_only, 1\\\\)' mismatch with mode 'read_write'\" }\n \n \n-int RW (1) RW (1, 2) frdwr1_rdwr1_1 (void*, int);   // { dg-warning \"attribute 'access\\\\(read_write, 1, 2\\\\)' positional argument 2 conflicts with previous designation\" }\n+int RW (1) RW (1, 2) frdwr1_rdwr1_1 (void*, int);   // { dg-warning \"attribute 'access\\\\(read_write, 1, 2\\\\)' positional argument 2 missing in previous designation\" }\n \n int RW (1, 2) RW (1) frdwr1_1_rdwr1 (void*, int);   // { dg-warning \"attribute 'access\\\\(read_write, 1\\\\)' missing positional argument 2 provided in previous designation\" }\n \n int RW (1)    grdwr1_rdwr1_1 (void*, int);   // { dg-message \"previous declaration here\" }\n-int RW (1, 2) grdwr1_rdwr1_1 (void*, int);   // { dg-warning \"attribute 'access\\\\(read_write, 1, 2\\\\)' positional argument 2 conflicts with previous designation\" }\n+int RW (1, 2) grdwr1_rdwr1_1 (void*, int);   // { dg-warning \"attribute 'access\\\\(read_write, 1, 2\\\\)' positional argument 2 missing in previous designation\" }\n \n \n typedef int *P;"}, {"sha": "ed6407c02225ec5ba2dce3e1d8a4021a225414e8", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -1704,9 +1704,9 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, dump_flags_t flags,\n \t  pp_string (pp, \"atomic \");\n \tif (quals & TYPE_QUAL_CONST)\n \t  pp_string (pp, \"const \");\n-\telse if (quals & TYPE_QUAL_VOLATILE)\n+\tif (quals & TYPE_QUAL_VOLATILE)\n \t  pp_string (pp, \"volatile \");\n-\telse if (quals & TYPE_QUAL_RESTRICT)\n+\tif (quals & TYPE_QUAL_RESTRICT)\n \t  pp_string (pp, \"restrict \");\n \n \tif (!ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (node)))"}, {"sha": "2cef5f3643f6381d61a4e5e57a4db3b566ac1727", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -474,7 +474,7 @@ maybe_warn_pass_by_reference (gimple *stmt, wlimits &wlims)\n \n   /* Map of attribute access specifications for function arguments.  */\n   rdwr_map rdwr_idx;\n-  init_attr_rdwr_indices (&rdwr_idx, fntype);\n+  init_attr_rdwr_indices (&rdwr_idx, TYPE_ATTRIBUTES (fntype));\n \n   tree argtype;\n   unsigned argno = 0;"}, {"sha": "5bb6e7bc000c92c50b4ab05e22910b97e67a2e67", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6450f07388f9fe575a489c9309c36012b17b88b0/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6450f07388f9fe575a489c9309c36012b17b88b0", "patch": "@@ -5351,7 +5351,8 @@ enum access_mode\n   access_none = 0,\n   access_read_only = 1,\n   access_write_only = 2,\n-  access_read_write = access_read_only | access_write_only\n+  access_read_write = access_read_only | access_write_only,\n+  access_deferred = 4\n };\n \n #define tree_map_eq tree_map_base_eq"}]}