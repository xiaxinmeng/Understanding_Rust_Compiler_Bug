{"sha": "b258210c50149d3c643aaa85e4ea60b9b366946b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI1ODIxMGM1MDE0OWQzYzY0M2FhYTg1ZTRlYTYwYjliMzY2OTQ2Yg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2010-05-17T19:43:40Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2010-05-17T19:43:40Z"}, "message": "cgraph.h (cgraph_indirect_call_info): New fields anc_offset, otr_token and polymorphic.\n\n2010-05-17  Martin Jambor  <mjambor@suse.cz>\n\n\t* cgraph.h (cgraph_indirect_call_info): New fields anc_offset,\n\totr_token and polymorphic.\n\t* cgraph.c (cgraph_create_indirect_edge): Inilialize the above fields.\n\t(cgraph_clone_edge): Copy the above fields.\n\t* tree.c (get_binfo_at_offset): New function.\n\t* tree.h (get_binfo_at_offset): Declare.\n\t* ipa-prop.h (enum jump_func_type): Added known_type jump function\n\ttype, reordered items, updated comments.\n\t(union jump_func_value): Added base_type field, reordered fields.\n\t(enum ipa_lattice_type): Moved down in the file.\n\t(struct ipa_param_descriptor): New field polymorphic.\n\t(ipa_is_param_polymorphic): New function.\n\t* ipa-prop.c: Include gimple.h and gimple-fold.h.\n\t(ipa_print_node_jump_functions): Print known type jump functions.\n\t(compute_complex_pass_through): Renamed to...\n\t(compute_complex_assign_jump_func): this.\n\t(compute_complex_ancestor_jump_func): New function.\n\t(compute_known_type_jump_func): Likewise.\n\t(compute_scalar_jump_functions): Create known type and complex ancestor\n\tjump functions.\n\t(ipa_note_param_call): New parameter polymorphic, set the corresponding\n\tflag in the call note accordingly.\n\t(ipa_analyze_call_uses): Renamed to...\n\t(ipa_analyze_indirect_call_uses): this.  New parameter target, define\n\tvariable var only in the block where it is used.\n\t(ipa_analyze_virtual_call_uses): New function.\n\t(ipa_analyze_call_uses): Likewise.\n\t(combine_known_type_and_ancestor_jfs): Likewise.\n\t(update_jump_functions_after_inlining): Implemented handling of a\n\tnumber of new jump function types combination.\n\t(print_edge_addition_message): Removed.\n\t(make_edge_direct_to_target): New function.\n\t(try_make_edge_direct_simple_call): Likewise.\n\t(try_make_edge_direct_virtual_call): Likewise.\n\t(update_call_notes_after_inlining): Renamed to...\n\t(update_indirect_edges_after_inlining): this.  Moved edge creation for\n\tindirect calls to try_make_edge_direct_simple_call, also calls\n\ttry_make_edge_direct_virtual_call for virtual calls.\n\t(ipa_print_node_params): Changed the header message.\n\t(ipa_write_jump_function): Stream also known type jump functions.\n\t(ipa_read_jump_function): Likewise.\n\t(ipa_write_indirect_edge_info): Stream new fields in\n\tcgraph_indirect_call_info.\n\t(ipa_read_indirect_edge_info): Likewise.\n\t* Makefile.in (ipa-prop.o): Add dependency to GIMPLE_H and\n\tGIMPLE_FOLD_H.\n\n\t* testsuite/g++.dg/ipa/ivinline-1.C: New test.\n\t* testsuite/g++.dg/ipa/ivinline-2.C: New test.\n\t* testsuite/g++.dg/ipa/ivinline-3.C: New test.\n\t* testsuite/g++.dg/ipa/ivinline-4.C: New test.\n\t* testsuite/g++.dg/ipa/ivinline-5.C: New test.\n\t* testsuite/g++.dg/ipa/ivinline-6.C: New test.\n\nFrom-SVN: r159507", "tree": {"sha": "d4ffa63f0aba29db3e92721d1dacf6c42dba6490", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4ffa63f0aba29db3e92721d1dacf6c42dba6490"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b258210c50149d3c643aaa85e4ea60b9b366946b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b258210c50149d3c643aaa85e4ea60b9b366946b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b258210c50149d3c643aaa85e4ea60b9b366946b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b258210c50149d3c643aaa85e4ea60b9b366946b/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d15bac214b2de189f37c17612dfa9f0e495e90f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d15bac214b2de189f37c17612dfa9f0e495e90f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d15bac214b2de189f37c17612dfa9f0e495e90f1"}], "stats": {"total": 1219, "additions": 1082, "deletions": 137}, "files": [{"sha": "a7037602628e61f40ac9d1b00219d7201714af4d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b258210c50149d3c643aaa85e4ea60b9b366946b", "patch": "@@ -1,3 +1,52 @@\n+2010-05-17  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* cgraph.h (cgraph_indirect_call_info): New fields anc_offset,\n+\totr_token and polymorphic.\n+\t* cgraph.c (cgraph_create_indirect_edge): Inilialize the above fields.\n+\t(cgraph_clone_edge): Copy the above fields.\n+\t* tree.c (get_binfo_at_offset): New function.\n+\t* tree.h (get_binfo_at_offset): Declare.\n+\t* ipa-prop.h (enum jump_func_type): Added known_type jump function\n+\ttype, reordered items, updated comments.\n+\t(union jump_func_value): Added base_type field, reordered fields.\n+\t(enum ipa_lattice_type): Moved down in the file.\n+\t(struct ipa_param_descriptor): New field polymorphic.\n+\t(ipa_is_param_polymorphic): New function.\n+\t* ipa-prop.c: Include gimple.h and gimple-fold.h.\n+\t(ipa_print_node_jump_functions): Print known type jump functions.\n+\t(compute_complex_pass_through): Renamed to...\n+\t(compute_complex_assign_jump_func): this.\n+\t(compute_complex_ancestor_jump_func): New function.\n+\t(compute_known_type_jump_func): Likewise.\n+\t(compute_scalar_jump_functions): Create known type and complex ancestor\n+\tjump functions.\n+\t(ipa_note_param_call): New parameter polymorphic, set the corresponding\n+\tflag in the call note accordingly.\n+\t(ipa_analyze_call_uses): Renamed to...\n+\t(ipa_analyze_indirect_call_uses): this.  New parameter target, define\n+\tvariable var only in the block where it is used.\n+\t(ipa_analyze_virtual_call_uses): New function.\n+\t(ipa_analyze_call_uses): Likewise.\n+\t(combine_known_type_and_ancestor_jfs): Likewise.\n+\t(update_jump_functions_after_inlining): Implemented handling of a\n+\tnumber of new jump function types combination.\n+\t(print_edge_addition_message): Removed.\n+\t(make_edge_direct_to_target): New function.\n+\t(try_make_edge_direct_simple_call): Likewise.\n+\t(try_make_edge_direct_virtual_call): Likewise.\n+\t(update_call_notes_after_inlining): Renamed to...\n+\t(update_indirect_edges_after_inlining): this.  Moved edge creation for\n+\tindirect calls to try_make_edge_direct_simple_call, also calls\n+\ttry_make_edge_direct_virtual_call for virtual calls.\n+\t(ipa_print_node_params): Changed the header message.\n+\t(ipa_write_jump_function): Stream also known type jump functions.\n+\t(ipa_read_jump_function): Likewise.\n+\t(ipa_write_indirect_edge_info): Stream new fields in\n+\tcgraph_indirect_call_info.\n+\t(ipa_read_indirect_edge_info): Likewise.\n+\t* Makefile.in (ipa-prop.o): Add dependency to GIMPLE_H and\n+\tGIMPLE_FOLD_H.\n+\n 2010-05-17  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* config/i386/sol2.h (TARGET_SUN_TLS): Remove duplicate definition."}, {"sha": "516ecae461fcec018d08017ccb56d315d3110ac8", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b258210c50149d3c643aaa85e4ea60b9b366946b", "patch": "@@ -2896,7 +2896,7 @@ ipa.o : ipa.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(CGRAPH_H) \\\n ipa-prop.o : ipa-prop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    langhooks.h $(GGC_H) $(TARGET_H) $(CGRAPH_H) $(IPA_PROP_H) $(DIAGNOSTIC_H) \\\n    $(TREE_FLOW_H) $(TM_H) $(TREE_PASS_H) $(FLAGS_H) $(TREE_H) \\\n-   $(TREE_INLINE_H) $(TIMEVAR_H)\n+   $(TREE_INLINE_H) $(GIMPLE_H) $(GIMPLE_FOLD_H) $(TIMEVAR_H)\n ipa-ref.o : ipa-ref.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    langhooks.h $(GGC_H) $(TARGET_H) $(CGRAPH_H)  $(TREE_H) $(TARGET_H) \\\n    $(TREE_FLOW_H) $(TM_H) $(TREE_PASS_H) $(FLAGS_H) $(TREE_H) $(GGC_H) "}, {"sha": "89e431a7a5371a0c7d7ed9cb47fbe6e92a5202a5", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=b258210c50149d3c643aaa85e4ea60b9b366946b", "patch": "@@ -1045,7 +1045,7 @@ cgraph_create_indirect_edge (struct cgraph_node *caller, gimple call_stmt,\n   edge->indirect_unknown_callee = 1;\n   initialize_inline_failed (edge);\n \n-  edge->indirect_info = GGC_NEW (struct cgraph_indirect_call_info);\n+  edge->indirect_info = GGC_CNEW (struct cgraph_indirect_call_info);\n   edge->indirect_info->param_index = -1;\n   edge->indirect_info->ecf_flags = ecf_flags;\n \n@@ -2026,7 +2026,7 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n \t\t\t\t\t\t  e->indirect_info->ecf_flags,\n \t\t\t\t\t\t  count, freq,\n \t\t\t\t\t\t  e->loop_nest + loop_nest);\n-\t  new_edge->indirect_info->param_index = e->indirect_info->param_index;\n+\t  *new_edge->indirect_info = *e->indirect_info;\n \t}\n     }\n   else"}, {"sha": "2841d25164d3e9ca1569bd1ec20935b3cdc5d179", "filename": "gcc/cgraph.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=b258210c50149d3c643aaa85e4ea60b9b366946b", "patch": "@@ -378,10 +378,21 @@ typedef enum {\n \n struct GTY(()) cgraph_indirect_call_info\n {\n+  /* Offset accumulated from ancestor jump functions of inlined call graph\n+     edges.  */\n+  HOST_WIDE_INT anc_offset;\n+  /* OBJ_TYPE_REF_TOKEN of a polymorphic call (if polymorphic is set).  */\n+  HOST_WIDE_INT otr_token;\n+  /* Type of the object from OBJ_TYPE_REF_OBJECT. */\n+  tree otr_type;\n   /* Index of the parameter that is called.  */\n   int param_index;\n   /* ECF flags determined from the caller.  */\n   int ecf_flags;\n+\n+  /* Set when the call is a virtual call with the parameter being the\n+     associated object pointer rather than a simple direct call.  */\n+  unsigned polymorphic : 1;\n };\n \n struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgraph_edge {"}, {"sha": "e66aab59e4d4c5f9908fed32216da8c3864867dc", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 451, "deletions": 105, "changes": 556, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=b258210c50149d3c643aaa85e4ea60b9b366946b", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-flow.h\"\n #include \"tree-pass.h\"\n #include \"tree-inline.h\"\n+#include \"gimple.h\"\n #include \"flags.h\"\n #include \"timevar.h\"\n #include \"flags.h\"\n@@ -290,6 +291,13 @@ ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node)\n \t  fprintf (f, \"       param %d: \", i);\n \t  if (type == IPA_JF_UNKNOWN)\n \t    fprintf (f, \"UNKNOWN\\n\");\n+\t  else if (type == IPA_JF_KNOWN_TYPE)\n+\t    {\n+\t      tree binfo_type = TREE_TYPE (jump_func->value.base_binfo);\n+\t      fprintf (f, \"KNOWN TYPE, type in binfo is: \");\n+\t      print_generic_expr (f, binfo_type, 0);\n+\t      fprintf (f, \" (%u)\\n\", TYPE_UID (binfo_type));\n+\t    }\n \t  else if (type == IPA_JF_CONST)\n  \t    {\n \t      tree val = jump_func->value.constant;\n@@ -327,9 +335,11 @@ ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node)\n \t  else if (type == IPA_JF_ANCESTOR)\n \t    {\n \t      fprintf (f, \"ANCESTOR: \");\n-\t      fprintf (f, \"%d, offset \"HOST_WIDE_INT_PRINT_DEC\"\\n\",\n+\t      fprintf (f, \"%d, offset \"HOST_WIDE_INT_PRINT_DEC\", \",\n \t\t       jump_func->value.ancestor.formal_id,\n \t\t       jump_func->value.ancestor.offset);\n+\t      print_generic_expr (f, jump_func->value.ancestor.type, 0);\n+\t      fprintf (dump_file, \"\\n\");\n \t    }\n \t}\n     }\n@@ -349,51 +359,60 @@ ipa_print_all_jump_functions (FILE *f)\n     }\n }\n \n-/* Determine whether passing ssa name NAME constitutes a polynomial\n-   pass-through function or getting an address of an acestor and if so, write\n-   such a jump function to JFUNC.  INFO describes the caller.  */\n+/* Given that an actual argument is an SSA_NAME (given in NAME) and is a result\n+   of an assignment statement STMT, try to find out whether NAME can be\n+   described by a (possibly polynomial) pass-through jump-function or an\n+   ancestor jump function and if so, write the appropriate function into\n+   JFUNC */\n \n static void\n-compute_complex_pass_through (struct ipa_node_params *info,\n-\t\t\t      struct ipa_jump_func *jfunc,\n-\t\t\t      tree name)\n+compute_complex_assign_jump_func (struct ipa_node_params *info,\n+\t\t\t\t  struct ipa_jump_func *jfunc,\n+\t\t\t\t  gimple stmt, tree name)\n {\n   HOST_WIDE_INT offset, size, max_size;\n   tree op1, op2, type;\n   int index;\n-  gimple stmt = SSA_NAME_DEF_STMT (name);\n \n-  if (!is_gimple_assign (stmt))\n-    return;\n   op1 = gimple_assign_rhs1 (stmt);\n   op2 = gimple_assign_rhs2 (stmt);\n \n-  if (op2)\n+  if (TREE_CODE (op1) == SSA_NAME\n+      && SSA_NAME_IS_DEFAULT_DEF (op1))\n     {\n-      if (TREE_CODE (op1) != SSA_NAME\n-\t  || !SSA_NAME_IS_DEFAULT_DEF (op1)\n-\t  || (TREE_CODE_CLASS (gimple_expr_code (stmt)) != tcc_comparison\n-\t      && !useless_type_conversion_p (TREE_TYPE (name),\n-\t\t\t\t\t     TREE_TYPE (op1)))\n-\t  || !is_gimple_ip_invariant (op2))\n+      index = ipa_get_param_decl_index (info, SSA_NAME_VAR (op1));\n+      if (index < 0)\n \treturn;\n \n-      index = ipa_get_param_decl_index (info, SSA_NAME_VAR (op1));\n-      if (index >= 0)\n+      if (op2)\n \t{\n+\t  if (!is_gimple_ip_invariant (op2)\n+\t      || (TREE_CODE_CLASS (gimple_expr_code (stmt)) != tcc_comparison\n+\t\t  && !useless_type_conversion_p (TREE_TYPE (name),\n+\t\t\t\t\t\t TREE_TYPE (op1))))\n+\t    return;\n+\n \t  jfunc->type = IPA_JF_PASS_THROUGH;\n \t  jfunc->value.pass_through.formal_id = index;\n \t  jfunc->value.pass_through.operation = gimple_assign_rhs_code (stmt);\n \t  jfunc->value.pass_through.operand = op2;\n \t}\n+      else if (gimple_assign_unary_nop_p (stmt))\n+\t{\n+\t  jfunc->type = IPA_JF_PASS_THROUGH;\n+\t  jfunc->value.pass_through.formal_id = index;\n+\t  jfunc->value.pass_through.operation = NOP_EXPR;\n+\t}\n       return;\n     }\n \n   if (TREE_CODE (op1) != ADDR_EXPR)\n     return;\n+\n   op1 = TREE_OPERAND (op1, 0);\n   type = TREE_TYPE (op1);\n-\n+  if (TREE_CODE (type) != RECORD_TYPE)\n+    return;\n   op1 = get_ref_base_and_extent (op1, &offset, &size, &max_size);\n   if (TREE_CODE (op1) != INDIRECT_REF\n       /* If this is a varying address, punt.  */\n@@ -416,6 +435,120 @@ compute_complex_pass_through (struct ipa_node_params *info,\n }\n \n \n+/* Given that an actual argument is an SSA_NAME that is a result of a phi\n+   statement PHI, try to find out whether NAME is in fact a\n+   multiple-inheritance typecast from a descendant into an ancestor of a formal\n+   parameter and thus can be described by an ancestor jump function and if so,\n+   write the appropriate function into JFUNC.\n+\n+   Essentially we want to match the following pattern:\n+\n+     if (obj_2(D) != 0B)\n+       goto <bb 3>;\n+     else\n+       goto <bb 4>;\n+\n+   <bb 3>:\n+     iftmp.1_3 = &obj_2(D)->D.1762;\n+\n+   <bb 4>:\n+     # iftmp.1_1 = PHI <iftmp.1_3(3), 0B(2)>\n+     D.1879_6 = middleman_1 (iftmp.1_1, i_5(D));\n+     return D.1879_6;  */\n+\n+static void\n+compute_complex_ancestor_jump_func (struct ipa_node_params *info,\n+\t\t\t\t    struct ipa_jump_func *jfunc,\n+\t\t\t\t    gimple phi)\n+{\n+  HOST_WIDE_INT offset, size, max_size;\n+  gimple assign, cond;\n+  basic_block phi_bb, assign_bb, cond_bb;\n+  tree tmp, parm, expr;\n+  int index, i;\n+\n+  if (gimple_phi_num_args (phi) != 2\n+      || !integer_zerop (PHI_ARG_DEF (phi, 1)))\n+    return;\n+\n+  tmp = PHI_ARG_DEF (phi, 0);\n+  if (TREE_CODE (tmp) != SSA_NAME\n+      || SSA_NAME_IS_DEFAULT_DEF (tmp)\n+      || !POINTER_TYPE_P (TREE_TYPE (tmp))\n+      || TREE_CODE (TREE_TYPE (TREE_TYPE (tmp))) != RECORD_TYPE)\n+    return;\n+\n+  assign = SSA_NAME_DEF_STMT (tmp);\n+  assign_bb = gimple_bb (assign);\n+  if (!single_pred_p (assign_bb)\n+      || !gimple_assign_single_p (assign))\n+    return;\n+  expr = gimple_assign_rhs1 (assign);\n+\n+  if (TREE_CODE (expr) != ADDR_EXPR)\n+    return;\n+  expr = TREE_OPERAND (expr, 0);\n+  expr = get_ref_base_and_extent (expr, &offset, &size, &max_size);\n+\n+  if (TREE_CODE (expr) != INDIRECT_REF\n+      /* If this is a varying address, punt.  */\n+      || max_size == -1\n+      || max_size != size)\n+    return;\n+  parm = TREE_OPERAND (expr, 0);\n+  if (TREE_CODE (parm) != SSA_NAME\n+      || !SSA_NAME_IS_DEFAULT_DEF (parm))\n+    return;\n+\n+  index = ipa_get_param_decl_index (info, SSA_NAME_VAR (parm));\n+  if (index < 0)\n+    return;\n+\n+  cond_bb = single_pred (assign_bb);\n+  cond = last_stmt (cond_bb);\n+  if (gimple_code (cond) != GIMPLE_COND\n+      || gimple_cond_code (cond) != NE_EXPR\n+      || gimple_cond_lhs (cond) != parm\n+      || !integer_zerop (gimple_cond_rhs (cond)))\n+    return;\n+\n+\n+  phi_bb = gimple_bb (phi);\n+  for (i = 0; i < 2; i++)\n+    {\n+      basic_block pred = EDGE_PRED (phi_bb, i)->src;\n+      if (pred != assign_bb && pred != cond_bb)\n+\treturn;\n+    }\n+\n+  jfunc->type = IPA_JF_ANCESTOR;\n+  jfunc->value.ancestor.formal_id = index;\n+  jfunc->value.ancestor.offset = offset;\n+  jfunc->value.ancestor.type = TREE_TYPE (TREE_TYPE (tmp));\n+}\n+\n+/* Given OP whch is passed as an actual argument to a called function,\n+   determine if it is possible to construct a KNOWN_TYPE jump function for it\n+   and if so, create one and store it to JFUNC.  */\n+\n+static void\n+compute_known_type_jump_func (tree op, struct ipa_jump_func *jfunc)\n+{\n+  tree binfo;\n+\n+  if (TREE_CODE (op) != ADDR_EXPR)\n+    return;\n+\n+  op = TREE_OPERAND (op, 0);\n+  binfo = gimple_get_relevant_ref_binfo (op, NULL_TREE);\n+  if (binfo)\n+    {\n+      jfunc->type = IPA_JF_KNOWN_TYPE;\n+      jfunc->value.base_binfo = binfo;\n+    }\n+}\n+\n+\n /* Determine the jump functions of scalar arguments.  Scalar means SSA names\n    and constants of a number of selected types.  INFO is the ipa_node_params\n    structure associated with the caller, FUNCTIONS is a pointer to an array of\n@@ -453,8 +586,18 @@ compute_scalar_jump_functions (struct ipa_node_params *info,\n \t\t}\n \t    }\n \t  else\n-\t    compute_complex_pass_through (info, &functions[num], arg);\n+\t    {\n+\t      gimple stmt = SSA_NAME_DEF_STMT (arg);\n+\t      if (is_gimple_assign (stmt))\n+\t\tcompute_complex_assign_jump_func (info, &functions[num],\n+\t\t\t\t\t\t  stmt, arg);\n+\t      else if (gimple_code (stmt) == GIMPLE_PHI)\n+\t\tcompute_complex_ancestor_jump_func (info, &functions[num],\n+\t\t\t\t\t\t    stmt);\n+\t    }\n \t}\n+      else\n+\tcompute_known_type_jump_func (arg, &functions[num]);\n     }\n }\n \n@@ -749,17 +892,29 @@ ipa_is_ssa_with_stmt_def (tree t)\n     return false;\n }\n \n-/* Create a new indirect call graph edge describing a call to a parameter\n-   number FORMAL_ID and and set the called flag of the parameter.  NODE is the\n-   caller.  STMT is the corresponding call statement.  */\n+/* Find the indirect call graph edge corresponding to STMT and add to it all\n+   information necessary to describe a call to a parameter number PARAM_INDEX.\n+   NODE is the caller.  POLYMORPHIC should be set to true iff the call is a\n+   virtual one.  */\n \n static void\n-ipa_note_param_call (struct cgraph_node *node, int formal_id, gimple stmt)\n+ipa_note_param_call (struct cgraph_node *node, int param_index, gimple stmt,\n+\t\t     bool polymorphic)\n {\n   struct cgraph_edge *cs;\n \n   cs = cgraph_edge (node, stmt);\n-  cs->indirect_info->param_index = formal_id;\n+  cs->indirect_info->param_index = param_index;\n+  cs->indirect_info->anc_offset = 0;\n+  cs->indirect_info->polymorphic = polymorphic;\n+  if (polymorphic)\n+    {\n+      tree otr = gimple_call_fn (stmt);\n+      tree type, token = OBJ_TYPE_REF_TOKEN (otr);\n+      cs->indirect_info->otr_token = tree_low_cst (token, 1);\n+      type = TREE_TYPE (TREE_TYPE (OBJ_TYPE_REF_OBJECT (otr)));\n+      cs->indirect_info->otr_type = type;\n+    }\n }\n \n /* Analyze the CALL and examine uses of formal parameters of the caller NODE\n@@ -809,29 +964,24 @@ ipa_note_param_call (struct cgraph_node *node, int formal_id, gimple stmt)\n */\n \n static void\n-ipa_analyze_call_uses (struct cgraph_node *node, struct ipa_node_params *info,\n-\t\t       gimple call)\n+ipa_analyze_indirect_call_uses (struct cgraph_node *node,\n+\t\t\t\tstruct ipa_node_params *info,\n+\t\t\t\tgimple call, tree target)\n {\n-  tree target = gimple_call_fn (call);\n   gimple def;\n-  tree var;\n   tree n1, n2;\n   gimple d1, d2;\n   tree rec, rec2, cond;\n   gimple branch;\n   int index;\n   basic_block bb, virt_bb, join;\n \n-  if (TREE_CODE (target) != SSA_NAME)\n-    return;\n-\n-  var = SSA_NAME_VAR (target);\n   if (SSA_NAME_IS_DEFAULT_DEF (target))\n     {\n-      /* assuming TREE_CODE (var) == PARM_DECL */\n+      tree var = SSA_NAME_VAR (target);\n       index = ipa_get_param_decl_index (info, var);\n       if (index >= 0)\n-\tipa_note_param_call (node, index, call);\n+\tipa_note_param_call (node, index, call, false);\n       return;\n     }\n \n@@ -928,11 +1078,63 @@ ipa_analyze_call_uses (struct cgraph_node *node, struct ipa_node_params *info,\n \n   index = ipa_get_param_decl_index (info, rec);\n   if (index >= 0 && !ipa_is_param_modified (info, index))\n-    ipa_note_param_call (node, index, call);\n+    ipa_note_param_call (node, index, call, false);\n \n   return;\n }\n \n+/* Analyze a CALL to an OBJ_TYPE_REF which is passed in TARGET and if the\n+   object referenced in the expression is a formal parameter of the caller\n+   (described by INFO), create a call note for the statement. */\n+\n+static void\n+ipa_analyze_virtual_call_uses (struct cgraph_node *node,\n+\t\t\t       struct ipa_node_params *info, gimple call,\n+\t\t\t       tree target)\n+{\n+  tree obj = OBJ_TYPE_REF_OBJECT (target);\n+  tree var;\n+  int index;\n+\n+  if (TREE_CODE (obj) == ADDR_EXPR)\n+    {\n+      do\n+\t{\n+\t  obj = TREE_OPERAND (obj, 0);\n+\t}\n+      while (TREE_CODE (obj) == COMPONENT_REF);\n+      if (TREE_CODE (obj) != INDIRECT_REF)\n+\treturn;\n+      obj = TREE_OPERAND (obj, 0);\n+    }\n+\n+  if (TREE_CODE (obj) != SSA_NAME\n+      || !SSA_NAME_IS_DEFAULT_DEF (obj))\n+    return;\n+\n+  var = SSA_NAME_VAR (obj);\n+  index = ipa_get_param_decl_index (info, var);\n+\n+  if (index >= 0)\n+    ipa_note_param_call (node, index, call, true);\n+}\n+\n+/* Analyze a call statement CALL whether and how it utilizes formal parameters\n+   of the caller (described by INFO). */\n+\n+static void\n+ipa_analyze_call_uses (struct cgraph_node *node,\n+\t\t       struct ipa_node_params *info, gimple call)\n+{\n+  tree target = gimple_call_fn (call);\n+\n+  if (TREE_CODE (target) == SSA_NAME)\n+    ipa_analyze_indirect_call_uses (node, info, call, target);\n+  else if (TREE_CODE (target) == OBJ_TYPE_REF)\n+    ipa_analyze_virtual_call_uses (node, info, call, target);\n+}\n+\n+\n /* Analyze the call statement STMT with respect to formal parameters (described\n    in INFO) of caller given by NODE.  Currently it only checks whether formal\n    parameters are called.  */\n@@ -974,12 +1176,31 @@ ipa_analyze_params_uses (struct cgraph_node *node)\n   info->uses_analysis_done = 1;\n }\n \n+/* Update the jump function DST when the call graph edge correspondng to SRC is\n+   is being inlined, knowing that DST is of type ancestor and src of known\n+   type.  */\n+\n+static void\n+combine_known_type_and_ancestor_jfs (struct ipa_jump_func *src,\n+\t\t\t\t     struct ipa_jump_func *dst)\n+{\n+  tree new_binfo;\n+\n+  new_binfo = get_binfo_at_offset (src->value.base_binfo,\n+\t\t\t\t   dst->value.ancestor.offset,\n+\t\t\t\t   dst->value.ancestor.type);\n+  if (new_binfo)\n+    {\n+      dst->type = IPA_JF_KNOWN_TYPE;\n+      dst->value.base_binfo = new_binfo;\n+    }\n+  else\n+    dst->type = IPA_JF_UNKNOWN;\n+}\n+\n /* Update the jump functions associated with call graph edge E when the call\n    graph edge CS is being inlined, assuming that E->caller is already (possibly\n-   indirectly) inlined into CS->callee and that E has not been inlined.\n-\n-   We keep pass through functions only if they do not contain any operation.\n-   This is sufficient for inlining and greately simplifies things.  */\n+   indirectly) inlined into CS->callee and that E has not been inlined.  */\n \n static void\n update_jump_functions_after_inlining (struct cgraph_edge *cs,\n@@ -992,51 +1213,161 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \n   for (i = 0; i < count; i++)\n     {\n-      struct ipa_jump_func *src, *dst = ipa_get_ith_jump_func (args, i);\n+      struct ipa_jump_func *dst = ipa_get_ith_jump_func (args, i);\n \n       if (dst->type == IPA_JF_ANCESTOR)\n \t{\n-\t  dst->type = IPA_JF_UNKNOWN;\n-\t  continue;\n-\t}\n+\t  struct ipa_jump_func *src;\n \n-      if (dst->type != IPA_JF_PASS_THROUGH)\n-\tcontinue;\n+\t  /* Variable number of arguments can cause havoc if we try to access\n+\t     one that does not exist in the inlined edge.  So make sure we\n+\t     don't.  */\n+\t  if (dst->value.ancestor.formal_id >= ipa_get_cs_argument_count (top))\n+\t    {\n+\t      dst->type = IPA_JF_UNKNOWN;\n+\t      continue;\n+\t    }\n \n-      /* We must check range due to calls with variable number of arguments and\n-\t we cannot combine jump functions with operations.  */\n-      if (dst->value.pass_through.operation != NOP_EXPR\n-\t  || (dst->value.pass_through.formal_id\n-\t      >= ipa_get_cs_argument_count (top)))\n+\t  src = ipa_get_ith_jump_func (top, dst->value.ancestor.formal_id);\n+\t  if (src->type == IPA_JF_KNOWN_TYPE)\n+\t    combine_known_type_and_ancestor_jfs (src, dst);\n+\t  else if (src->type == IPA_JF_CONST)\n+\t    {\n+\t      struct ipa_jump_func kt_func;\n+\n+\t      kt_func.type = IPA_JF_UNKNOWN;\n+\t      compute_known_type_jump_func (src->value.constant, &kt_func);\n+\t      if (kt_func.type == IPA_JF_KNOWN_TYPE)\n+\t\tcombine_known_type_and_ancestor_jfs (&kt_func, dst);\n+\t      else\n+\t\tdst->type = IPA_JF_UNKNOWN;\n+\t    }\n+\t  else if (src->type == IPA_JF_PASS_THROUGH\n+\t\t   && src->value.pass_through.operation == NOP_EXPR)\n+\t    dst->value.ancestor.formal_id = src->value.pass_through.formal_id;\n+\t  else if (src->type == IPA_JF_ANCESTOR)\n+\t    {\n+\t      dst->value.ancestor.formal_id = src->value.ancestor.formal_id;\n+\t      dst->value.ancestor.offset += src->value.ancestor.offset;\n+\t    }\n+\t  else\n+\t    dst->type = IPA_JF_UNKNOWN;\n+\t}\n+      else if (dst->type == IPA_JF_PASS_THROUGH)\n \t{\n-\t  dst->type = IPA_JF_UNKNOWN;\n-\t  continue;\n+\t  struct ipa_jump_func *src;\n+\t  /* We must check range due to calls with variable number of arguments\n+\t     and we cannot combine jump functions with operations.  */\n+\t  if (dst->value.pass_through.operation == NOP_EXPR\n+\t      && (dst->value.pass_through.formal_id\n+\t\t  < ipa_get_cs_argument_count (top)))\n+\t    {\n+\t      src = ipa_get_ith_jump_func (top,\n+\t\t\t\t\t   dst->value.pass_through.formal_id);\n+\t      *dst = *src;\n+\t    }\n+\t  else\n+\t    dst->type = IPA_JF_UNKNOWN;\n \t}\n+    }\n+}\n+\n+/* If TARGET is an addr_expr of a function declaration, make it the destination\n+   of an indirect edge IE and return the edge.  Otherwise, return NULL.  */\n \n-      src = ipa_get_ith_jump_func (top, dst->value.pass_through.formal_id);\n-      *dst = *src;\n+static struct cgraph_edge *\n+make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n+{\n+  struct cgraph_node *callee;\n+\n+  if (TREE_CODE (target) != ADDR_EXPR)\n+    return NULL;\n+  target = TREE_OPERAND (target, 0);\n+  if (TREE_CODE (target) != FUNCTION_DECL)\n+    return NULL;\n+  callee = cgraph_node (target);\n+  if (!callee)\n+    return NULL;\n+\n+  cgraph_make_edge_direct (ie, callee);\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"ipa-prop: Discovered %s call to a known target \"\n+\t       \"(%s/%i -> %s/%i) for stmt \",\n+\t       ie->indirect_info->polymorphic ? \"a virtual\" : \"an indirect\",\n+\t       cgraph_node_name (ie->caller), ie->caller->uid,\n+\t       cgraph_node_name (ie->callee), ie->callee->uid);\n+\n+      if (ie->call_stmt)\n+\tprint_gimple_stmt (dump_file, ie->call_stmt, 2, TDF_SLIM);\n+      else\n+\tfprintf (dump_file, \"with uid %i\\n\", ie->lto_stmt_uid);\n     }\n+  return ie;\n }\n \n-/* Print out a debug message to file F that we have discovered that an indirect\n-   call described by NT is in fact a call of a known constant function described\n-   by JFUNC.  NODE is the node where the call is.  */\n+/* Try to find a destination for indirect edge IE that corresponds to a simple\n+   call or a call of a member function pointer and where the destination is a\n+   pointer formal parameter described by jump function JFUNC.  If it can be\n+   determined, return the newly direct edge, otherwise return NULL.  */\n \n-static void\n-print_edge_addition_message (FILE *f, struct cgraph_edge *e,\n-\t\t\t     struct ipa_jump_func *jfunc)\n+static struct cgraph_edge *\n+try_make_edge_direct_simple_call (struct cgraph_edge *ie,\n+\t\t\t\t  struct ipa_jump_func *jfunc)\n {\n-  fprintf (f, \"ipa-prop: Discovered an indirect call to a known target (\");\n-  if (jfunc->type == IPA_JF_CONST_MEMBER_PTR)\n+  tree target;\n+\n+  if (jfunc->type == IPA_JF_CONST)\n+    target = jfunc->value.constant;\n+  else if (jfunc->type == IPA_JF_CONST_MEMBER_PTR)\n+    target = jfunc->value.member_cst.pfn;\n+  else\n+    return NULL;\n+\n+  return make_edge_direct_to_target (ie, target);\n+}\n+\n+/* Try to find a destination for indirect edge IE that corresponds to a\n+   virtuall call based on a formal parameter which is described by jump\n+   function JFUNC and if it can be determined, make it direct and return the\n+   direct edge.  Otherwise, return NULL.  */\n+\n+static struct cgraph_edge *\n+try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n+\t\t\t\t   struct ipa_jump_func *jfunc)\n+{\n+  tree binfo, type, target;\n+  HOST_WIDE_INT token;\n+\n+  if (jfunc->type == IPA_JF_KNOWN_TYPE)\n+    binfo = jfunc->value.base_binfo;\n+  else if (jfunc->type == IPA_JF_CONST)\n     {\n-      print_node_brief (f, \"\", jfunc->value.member_cst.pfn, 0);\n-      print_node_brief (f, \", \", jfunc->value.member_cst.delta, 0);\n+      tree cst = jfunc->value.constant;\n+      if (TREE_CODE (cst) == ADDR_EXPR)\n+\tbinfo = gimple_get_relevant_ref_binfo (TREE_OPERAND (cst, 0),\n+\t\t\t\t\t       NULL_TREE);\n+      else\n+  \treturn NULL;\n     }\n   else\n-    print_node_brief(f, \"\", jfunc->value.constant, 0);\n+    return NULL;\n \n-  fprintf (f, \") in %s: \", cgraph_node_name (e->caller));\n-  print_gimple_stmt (f, e->call_stmt, 2, TDF_SLIM);\n+  if (!binfo)\n+    return NULL;\n+\n+  token = ie->indirect_info->otr_token;\n+  type = ie->indirect_info->otr_type;\n+  binfo = get_binfo_at_offset (binfo, ie->indirect_info->anc_offset, type);\n+  if (binfo)\n+    target = gimple_fold_obj_type_ref_known_binfo (token, binfo);\n+  else\n+    return NULL;\n+\n+  if (target)\n+    return make_edge_direct_to_target (ie, target);\n+  else\n+    return NULL;\n }\n \n /* Update the param called notes associated with NODE when CS is being inlined,\n@@ -1051,7 +1382,7 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n \t\t\t\t      VEC (cgraph_edge_p, heap) **new_edges)\n {\n   struct ipa_edge_args *top = IPA_EDGE_REF (cs);\n-  struct cgraph_edge *ie, *next_ie;\n+  struct cgraph_edge *ie, *next_ie, *new_direct_edge;\n   bool res = false;\n \n   ipa_check_create_edge_args ();\n@@ -1081,44 +1412,30 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n       if (jfunc->type == IPA_JF_PASS_THROUGH\n \t  && jfunc->value.pass_through.operation == NOP_EXPR)\n \tici->param_index = jfunc->value.pass_through.formal_id;\n-      else if (jfunc->type == IPA_JF_CONST\n-\t       || jfunc->type == IPA_JF_CONST_MEMBER_PTR)\n+      else if (jfunc->type == IPA_JF_ANCESTOR)\n \t{\n-\t  struct cgraph_node *callee;\n-\t  tree decl;\n-\n-\t  bitmap_set_bit (iinlining_processed_edges, ie->uid);\n-\t  if (jfunc->type == IPA_JF_CONST_MEMBER_PTR)\n-\t    decl = jfunc->value.member_cst.pfn;\n-\t  else\n-\t    decl = jfunc->value.constant;\n-\n-\t  if (TREE_CODE (decl) != ADDR_EXPR)\n-\t    continue;\n-\t  decl = TREE_OPERAND (decl, 0);\n-\n-\t  if (TREE_CODE (decl) != FUNCTION_DECL)\n-\t    continue;\n-\t  callee = cgraph_node (decl);\n-\t  if (!callee || !callee->local.inlinable)\n-\t    continue;\n-\n-\t  res = true;\n-\t  if (dump_file)\n-\t    print_edge_addition_message (dump_file, ie, jfunc);\n-\n-\t  cgraph_make_edge_direct (ie, callee);\n-\t  ie->indirect_inlining_edge = 1;\n-\t  if (new_edges)\n-\t    VEC_safe_push (cgraph_edge_p, heap, *new_edges, ie);\n-\t  top = IPA_EDGE_REF (cs);\n+ \t  ici->param_index = jfunc->value.ancestor.formal_id;\n+ \t  ici->anc_offset += jfunc->value.ancestor.offset;\n \t}\n       else\n+\t/* Either we can find a destination for this edge now or never. */\n+\tbitmap_set_bit (iinlining_processed_edges, ie->uid);\n+\n+      if (ici->polymorphic)\n+\tnew_direct_edge = try_make_edge_direct_virtual_call (ie, jfunc);\n+      else\n+\tnew_direct_edge = try_make_edge_direct_simple_call (ie, jfunc);\n+\n+      if (new_direct_edge)\n \t{\n-\t  /* Ancestor jump functions and pass theoughs with operations should\n-\t     not be used on parameters that then get called.  */\n-\t  gcc_assert (jfunc->type == IPA_JF_UNKNOWN);\n-\t  bitmap_set_bit (iinlining_processed_edges, ie->uid);\n+\t  new_direct_edge->indirect_inlining_edge = 1;\n+\t  if (new_edges)\n+\t    {\n+\t      VEC_safe_push (cgraph_edge_p, heap, *new_edges,\n+\t\t\t     new_direct_edge);\n+\t      top = IPA_EDGE_REF (cs);\n+\t      res = true;\n+\t    }\n \t}\n     }\n \n@@ -1417,7 +1734,8 @@ ipa_print_node_params (FILE * f, struct cgraph_node *node)\n   if (!node->analyzed)\n     return;\n   info = IPA_NODE_REF (node);\n-  fprintf (f, \"  function  %s Trees :: \\n\", cgraph_node_name (node));\n+  fprintf (f, \"  function  %s parameter descriptors:\\n\",\n+\t   cgraph_node_name (node));\n   count = ipa_get_param_count (info);\n   for (i = 0; i < count; i++)\n     {\n@@ -1909,6 +2227,9 @@ ipa_write_jump_function (struct output_block *ob,\n     {\n     case IPA_JF_UNKNOWN:\n       break;\n+    case IPA_JF_KNOWN_TYPE:\n+      lto_output_tree (ob, jump_func->value.base_binfo, true);\n+      break;\n     case IPA_JF_CONST:\n       lto_output_tree (ob, jump_func->value.constant, true);\n       break;\n@@ -1946,6 +2267,9 @@ ipa_read_jump_function (struct lto_input_block *ib,\n     {\n     case IPA_JF_UNKNOWN:\n       break;\n+    case IPA_JF_KNOWN_TYPE:\n+      jump_func->value.base_binfo = lto_input_tree (ib, data_in);\n+      break;\n     case IPA_JF_CONST:\n       jump_func->value.constant = lto_input_tree (ib, data_in);\n       break;\n@@ -1974,8 +2298,20 @@ ipa_write_indirect_edge_info (struct output_block *ob,\n \t\t\t      struct cgraph_edge *cs)\n {\n   struct cgraph_indirect_call_info *ii = cs->indirect_info;\n+  struct bitpack_d *bp;\n \n   lto_output_sleb128_stream (ob->main_stream, ii->param_index);\n+  lto_output_sleb128_stream (ob->main_stream, ii->anc_offset);\n+  bp = bitpack_create ();\n+  bp_pack_value (bp, ii->polymorphic, 1);\n+  lto_output_bitpack (ob->main_stream, bp);\n+  bitpack_delete (bp);\n+\n+  if (ii->polymorphic)\n+    {\n+      lto_output_sleb128_stream (ob->main_stream, ii->otr_token);\n+      lto_output_tree (ob, ii->otr_type, true);\n+    }\n }\n \n /* Read in parts of cgraph_indirect_call_info corresponding to CS that are\n@@ -1987,8 +2323,18 @@ ipa_read_indirect_edge_info (struct lto_input_block *ib,\n \t\t\t     struct cgraph_edge *cs)\n {\n   struct cgraph_indirect_call_info *ii = cs->indirect_info;\n+  struct bitpack_d *bp;\n \n   ii->param_index = (int) lto_input_sleb128 (ib);\n+  ii->anc_offset = (HOST_WIDE_INT) lto_input_sleb128 (ib);\n+  bp = lto_input_bitpack (ib);\n+  ii->polymorphic = bp_unpack_value (bp, 1);\n+  bitpack_delete (bp);\n+  if (ii->polymorphic)\n+    {\n+      ii->otr_token = (HOST_WIDE_INT) lto_input_sleb128 (ib);\n+      ii->otr_type = lto_input_tree (ib, data_in);\n+    }\n }\n \n /* Stream out NODE info to OB.  */"}, {"sha": "0f9b5f39acc1df3e384c7301c0b08b4a9481a379", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 48, "deletions": 29, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=b258210c50149d3c643aaa85e4ea60b9b366946b", "patch": "@@ -39,38 +39,40 @@ along with GCC; see the file COPYING3.  If not see\n                   argument.\n    Unknown      - neither of the above.\n \n-   IPA_JF_CONST_MEMBER_PTR stands for C++ member pointers, other constants are\n-   represented with IPA_JF_CONST.\n+   IPA_JF_CONST_MEMBER_PTR stands for C++ member pointers, it is a special\n+   constant in this regard.  Other constants are represented with IPA_JF_CONST.\n+\n+   IPA_JF_ANCESTOR is a special pass-through jump function, which means that\n+   the result is an address of a part of the object pointed to by the formal\n+   parameter to which the function refers.  It is mainly intended to represent\n+   getting addresses of of ancestor fields in C++\n+   (e.g. &this_1(D)->D.1766.D.1756).  Note that if the original pointer is\n+   NULL, ancestor jump function must behave like a simple pass-through.\n+\n+   Other pass-through functions can either simply pass on an unchanged formal\n+   parameter or can apply one simple binary operation to it (such jump\n+   functions are called polynomial).\n+\n+   IPA_JF_KNOWN_TYPE is a special type of an \"unknown\" function that applies\n+   only to pointer parameters.  It means that even though we cannot prove that\n+   the passed value is an interprocedural constant, we still know the exact\n+   type of the containing object which may be valuable for devirtualization.\n+\n+   Jump functions are computed in ipa-prop.c by function\n+   update_call_notes_after_inlining.  Some information can be lost and jump\n+   functions degraded accordingly when inlining, see\n+   update_call_notes_after_inlining in the same file.  */\n \n-   In addition to \"ordinary\" pass through functions represented by\n-   IPA_JF_PASS_THROUGH, IPA_JF_ANCESTOR represents getting addresses of of\n-   ancestor fields in C++ (e.g. &this_1(D)->D.1766.D.1756).  */\n enum jump_func_type\n {\n   IPA_JF_UNKNOWN = 0,  /* newly allocated and zeroed jump functions default */\n-  IPA_JF_CONST,\n-  IPA_JF_CONST_MEMBER_PTR,\n-  IPA_JF_PASS_THROUGH,\n-  IPA_JF_ANCESTOR\n+  IPA_JF_KNOWN_TYPE,        /* represented by field base_binfo */\n+  IPA_JF_CONST,             /* represented by field costant */\n+  IPA_JF_CONST_MEMBER_PTR,  /* represented by field member_cst */\n+  IPA_JF_PASS_THROUGH,\t    /* represented by field pass_through */\n+  IPA_JF_ANCESTOR\t    /* represented by field ancestor */\n };\n \n-/* All formal parameters in the program have a lattice associated with it\n-   computed by the interprocedural stage of IPCP.\n-   There are three main values of the lattice:\n-   IPA_TOP - unknown,\n-   IPA_BOTTOM - non constant,\n-   IPA_CONST_VALUE - simple scalar constant,\n-   Cval of formal f will have a constant value if all callsites to this\n-   function have the same constant value passed to f.\n-   Integer and real constants are represented as IPA_CONST_VALUE.  */\n-enum ipa_lattice_type\n-{\n-  IPA_BOTTOM,\n-  IPA_CONST_VALUE,\n-  IPA_TOP\n-};\n-\n-\n /* Structure holding data required to describe a pass-through jump function.  */\n \n struct GTY(()) ipa_pass_through_data\n@@ -87,8 +89,8 @@ struct GTY(()) ipa_pass_through_data\n   enum tree_code operation;\n };\n \n-/* Structure holding data required to describe and ancestor pass throu\n-   funkci.  */\n+/* Structure holding data required to describe an ancestor pass-through\n+   jump function.  */\n \n struct GTY(()) ipa_ancestor_jf_data\n {\n@@ -119,13 +121,30 @@ struct GTY (()) ipa_jump_func\n      functions and member_cst holds constant c++ member functions.  */\n   union jump_func_value\n   {\n+    tree GTY ((tag (\"IPA_JF_KNOWN_TYPE\"))) base_binfo;\n     tree GTY ((tag (\"IPA_JF_CONST\"))) constant;\n+    struct ipa_member_ptr_cst GTY ((tag (\"IPA_JF_CONST_MEMBER_PTR\"))) member_cst;\n     struct ipa_pass_through_data GTY ((tag (\"IPA_JF_PASS_THROUGH\"))) pass_through;\n     struct ipa_ancestor_jf_data GTY ((tag (\"IPA_JF_ANCESTOR\"))) ancestor;\n-    struct ipa_member_ptr_cst GTY ((tag (\"IPA_JF_CONST_MEMBER_PTR\"))) member_cst;\n   } GTY ((desc (\"%1.type\"))) value;\n };\n \n+/* All formal parameters in the program have a lattice associated with it\n+   computed by the interprocedural stage of IPCP.\n+   There are three main values of the lattice:\n+   IPA_TOP - unknown,\n+   IPA_BOTTOM - non constant,\n+   IPA_CONST_VALUE - simple scalar constant,\n+   Cval of formal f will have a constant value if all callsites to this\n+   function have the same constant value passed to f.\n+   Integer and real constants are represented as IPA_CONST_VALUE.  */\n+enum ipa_lattice_type\n+{\n+  IPA_BOTTOM,\n+  IPA_CONST_VALUE,\n+  IPA_TOP\n+};\n+\n /* All formal parameters in the program have a cval computed by\n    the interprocedural stage of IPCP. See enum ipa_lattice_type for\n    the various types of lattices supported */"}, {"sha": "17b9c512f17b9821edc0f5e10626e7dcbe428f5d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b258210c50149d3c643aaa85e4ea60b9b366946b", "patch": "@@ -1,3 +1,12 @@\n+2010-05-17  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* g++.dg/ipa/ivinline-1.C: New test.\n+\t* g++.dg/ipa/ivinline-2.C: New test.\n+\t* g++.dg/ipa/ivinline-3.C: New test.\n+\t* g++.dg/ipa/ivinline-4.C: New test.\n+\t* g++.dg/ipa/ivinline-5.C: New test.\n+\t* g++.dg/ipa/ivinline-6.C: New test.\n+\n 2010-05-17  Dodji Seketeli  <dodji@redhat.com>\n \t    Jason Merrill  <jason@redhat.com>\n "}, {"sha": "fc63e60858d1ed64d949c1322accc7715197ff68", "filename": "gcc/testsuite/g++.dg/ipa/ivinline-1.C", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-1.C?ref=b258210c50149d3c643aaa85e4ea60b9b366946b", "patch": "@@ -0,0 +1,64 @@\n+/* Verify that simple virtual calls are inlined even without early\n+   inlining.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fdump-ipa-inline -fno-early-inlining -fno-ipa-cp\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class A\n+{\n+public:\n+  int data;\n+  virtual int foo (int i);\n+};\n+\n+class B : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+class C : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int C::foo (int i)\n+{\n+  return i + 3;\n+}\n+\n+int middleman (class A *obj, int i)\n+{\n+  return obj->foo (i);\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  class B b;\n+  int i;\n+\n+  for (i = 0; i < get_input (); i++)\n+    if (middleman (&b, get_input ()) != 3)\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"B::foo\\[^\\\\n\\]*inline copy in int main\"  \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "f99330361f10b5dc42d090cf190c9abd6fe1f75b", "filename": "gcc/testsuite/g++.dg/ipa/ivinline-2.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-2.C?ref=b258210c50149d3c643aaa85e4ea60b9b366946b", "patch": "@@ -0,0 +1,63 @@\n+/* Verify that simple virtual calls using this pointer are inlined\n+   even without early inlining..  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fdump-ipa-inline -fno-early-inlining -fno-ipa-cp\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class A\n+{\n+public:\n+  int data;\n+  virtual int foo (int i);\n+  int middleman (int i)\n+  {\n+    return foo (i);\n+  }\n+};\n+\n+class B : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+class C : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int C::foo (int i)\n+{\n+  return i + 3;\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  class B b;\n+  int i;\n+\n+  for (i = 0; i < get_input (); i++)\n+    if (b.middleman (get_input ()) != 3)\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"B::foo\\[^\\\\n\\]*inline copy in int main\"  \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "d9a47f860c8f090423074b3882a0aa40554de124", "filename": "gcc/testsuite/g++.dg/ipa/ivinline-3.C", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-3.C?ref=b258210c50149d3c643aaa85e4ea60b9b366946b", "patch": "@@ -0,0 +1,64 @@\n+/* Verify that simple virtual calls on an object refrence are inlined\n+   even without early inlining.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fdump-ipa-inline -fno-early-inlining -fno-ipa-cp\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class A\n+{\n+public:\n+  int data;\n+  virtual int foo (int i);\n+};\n+\n+class B : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+class C : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int C::foo (int i)\n+{\n+  return i + 3;\n+}\n+\n+int middleman (class A &obj, int i)\n+{\n+  return obj.foo (i);\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  class B b;\n+  int i;\n+\n+  for (i = 0; i < get_input (); i++)\n+    if (middleman (b, get_input ()) != 3)\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"B::foo\\[^\\\\n\\]*inline copy in int main\"  \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "93cbe0c7dc17c075e61ee481ebae0f7557429f4c", "filename": "gcc/testsuite/g++.dg/ipa/ivinline-4.C", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-4.C?ref=b258210c50149d3c643aaa85e4ea60b9b366946b", "patch": "@@ -0,0 +1,70 @@\n+/* Verify that simple virtual calls are inlined even without early\n+   inlining, even when a typecast to an ancestor is involved along the\n+   way.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fdump-ipa-inline -fno-early-inlining -fno-ipa-cp\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class A\n+{\n+public:\n+  int data;\n+  virtual int foo (int i);\n+};\n+\n+class B : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+class C : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int C::foo (int i)\n+{\n+  return i + 3;\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+static int middleman_1 (class A *obj, int i)\n+{\n+  return obj->foo (i);\n+}\n+\n+static int middleman_2 (class B *obj, int i)\n+{\n+  return middleman_1 (obj, i);\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  class B b;\n+  int i;\n+\n+  for (i = 0; i < get_input (); i++)\n+    if (middleman_2 (&b, get_input ()) != 3)\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"B::foo\\[^\\\\n\\]*inline copy in int main\"  \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "91e8f4e3e1d3399addd28488fabae340e7e7ccfe", "filename": "gcc/testsuite/g++.dg/ipa/ivinline-5.C", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-5.C?ref=b258210c50149d3c643aaa85e4ea60b9b366946b", "patch": "@@ -0,0 +1,55 @@\n+/* Verify that virtual call inlining does not pick a wrong method when\n+   there is a user defined ancestor in an object.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fdump-ipa-inline -fno-early-inlining -fno-ipa-cp\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class A\n+{\n+public:\n+  int data;\n+  virtual int foo (int i);\n+};\n+\n+class B : public A\n+{\n+public:\n+  class A confusion;\n+  virtual int foo (int i);\n+};\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int middleman (class A *obj, int i)\n+{\n+  return obj->foo (i);\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  class B b;\n+  int i, j = get_input ();\n+\n+  for (i = 0; i < j; i++)\n+    if ((middleman (&b, j) + 100 * middleman (&b.confusion, j)) != 203)\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"A::foo\\[^\\\\n\\]*inline copy in int main\"  \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump \"B::foo\\[^\\\\n\\]*inline copy in int main\"  \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "202e9e187694fa52857da851159a392503582a5e", "filename": "gcc/testsuite/g++.dg/ipa/ivinline-6.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-6.C?ref=b258210c50149d3c643aaa85e4ea60b9b366946b", "patch": "@@ -0,0 +1,58 @@\n+/* Verify that virtual call inlining works also when it has to get the\n+   type from an ipa invariant and that even in this case it does not\n+   pick a wrong method when there is a user defined ancestor in an\n+   object.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fdump-ipa-inline -fno-early-inlining -fno-ipa-cp\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class A\n+{\n+public:\n+  int data;\n+  virtual int foo (int i);\n+};\n+\n+class B : public A\n+{\n+public:\n+  class A confusion;\n+  virtual int foo (int i);\n+};\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int middleman (class A *obj, int i)\n+{\n+  return obj->foo (i);\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+class B b;\n+\n+int main (int argc, char *argv[])\n+{\n+  int i, j = get_input ();\n+\n+  for (i = 0; i < j; i++)\n+    if ((middleman (&b, j) + 100 * middleman (&b.confusion, j)) != 203)\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"A::foo\\[^\\\\n\\]*inline copy in int main\"  \"inline\"  } } */\n+/* { dg-final { scan-ipa-dump \"B::foo\\[^\\\\n\\]*inline copy in int main\"  \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "5f3596d8d6e074244e845d2544315414dae2e5b3", "filename": "gcc/testsuite/g++.dg/ipa/ivinline-7.C", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-7.C?ref=b258210c50149d3c643aaa85e4ea60b9b366946b", "patch": "@@ -0,0 +1,79 @@\n+/* Verify that simple virtual calls are inlined even without early\n+   inlining, even when a typecast to an ancestor is involved along the\n+   way and that ancestor is not the first one with virtual functions.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fdump-ipa-inline -fno-early-inlining -fno-ipa-cp\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class Distraction\n+{\n+public:\n+  float f;\n+  double d;\n+  Distraction ()\n+  {\n+    f = 8.3;\n+    d = 10.2;\n+  }\n+  virtual float bar (float z);\n+};\n+\n+class A\n+{\n+public:\n+  int data;\n+  virtual int foo (int i);\n+};\n+\n+\n+class B : public Distraction, public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+float Distraction::bar (float z)\n+{\n+  f += z;\n+  return f/2;\n+}\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+static int middleman_1 (class A *obj, int i)\n+{\n+  return obj->foo (i);\n+}\n+\n+static int middleman_2 (class B *obj, int i)\n+{\n+  return middleman_1 (obj, i);\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  class B b;\n+  int i;\n+\n+  for (i = 0; i < get_input (); i++)\n+    if (middleman_2 (&b, get_input ()) != 3)\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"B::foo\\[^\\\\n\\]*inline copy in int main\"  \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "f00f82e99956ef404bdd13bf82ff5b6de703087d", "filename": "gcc/tree.c", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=b258210c50149d3c643aaa85e4ea60b9b366946b", "patch": "@@ -10779,4 +10779,60 @@ lhd_gcc_personality (void)\n   return gcc_eh_personality_decl;\n }\n \n+/* Try to find a base info of BINFO that would have its field decl at offset\n+   OFFSET within the BINFO type and which is of EXPECTED_TYPE.  If it can be\n+   found, return, otherwise return NULL_TREE.  */\n+\n+tree\n+get_binfo_at_offset (tree binfo, HOST_WIDE_INT offset, tree expected_type)\n+{\n+  tree type;\n+\n+  if (offset == 0)\n+    return binfo;\n+\n+  type = TREE_TYPE (binfo);\n+  while (offset > 0)\n+    {\n+      tree base_binfo, found_binfo;\n+      HOST_WIDE_INT pos, size;\n+      tree fld;\n+      int i;\n+\n+      if (TREE_CODE (type) != RECORD_TYPE)\n+\treturn NULL_TREE;\n+\n+      for (fld = TYPE_FIELDS (type); fld; fld = TREE_CHAIN (fld))\n+\t{\n+\t  if (TREE_CODE (fld) != FIELD_DECL)\n+\t    continue;\n+\n+\t  pos = int_bit_position (fld);\n+\t  size = tree_low_cst (DECL_SIZE (fld), 1);\n+\t  if (pos <= offset && (pos + size) > offset)\n+\t    break;\n+\t}\n+      if (!fld)\n+\treturn NULL_TREE;\n+\n+      found_binfo = NULL_TREE;\n+      for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+\tif (TREE_TYPE (base_binfo) == TREE_TYPE (fld))\n+\t  {\n+\t    found_binfo = base_binfo;\n+\t    break;\n+\t  }\n+\n+      if (!found_binfo)\n+\treturn NULL_TREE;\n+\n+      type = TREE_TYPE (fld);\n+      binfo = found_binfo;\n+      offset -= pos;\n+    }\n+  if (type != expected_type)\n+    return NULL_TREE;\n+  return binfo;\n+}\n+\n #include \"gt-tree.h\""}, {"sha": "58088271c46926a2c521e1d3896fa25bd7332f65", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b258210c50149d3c643aaa85e4ea60b9b366946b/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b258210c50149d3c643aaa85e4ea60b9b366946b", "patch": "@@ -5073,6 +5073,8 @@ extern location_t tree_nonartificial_location (tree);\n \n extern tree block_ultimate_origin (const_tree);\n \n+extern tree get_binfo_at_offset (tree, HOST_WIDE_INT, tree);\n+\n /* In tree-nested.c */\n extern tree build_addr (tree, tree);\n "}]}