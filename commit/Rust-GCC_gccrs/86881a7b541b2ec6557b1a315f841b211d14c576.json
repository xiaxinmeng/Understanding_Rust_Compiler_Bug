{"sha": "86881a7b541b2ec6557b1a315f841b211d14c576", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY4ODFhN2I1NDFiMmVjNjU1N2IxYTMxNWY4NDFiMjExZDE0YzU3Ng==", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@gcc.gnu.org", "date": "2004-03-17T21:29:02Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@gcc.gnu.org", "date": "2004-03-17T21:29:02Z"}, "message": "[multiple changes]\n\n2004-03-12  Graydon Hoare  <graydon@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java: Clipping fixes.\n\t* javax/swing/JComponent.java (paint): Use persistent double buffer.\n\t* javax/swing/JList.java (ListListener): Revalidate on changes.\n\t* javax/swing/JScrollPane.java: Reimplement.\n\t* javax/swing/JViewport.java: Reimplement.\n\t* javax/swing/ScrollPaneLayout.java: Reimplement.\n\t* javax/swing/ViewportLayout.java: Tidy up.\n\t* javax/swing/plaf/basic/BasicButtonListener.java: Remove printlns.\n\t* javax/swing/plaf/basic/BasicScrollPaneUI.java: Reimplement.\n\t* javax/swing/plaf/basic/BasicSliderUI.java: Handle missing labels.\n\t* javax/swing/plaf/basic/BasicViewportUI.java: Implement in terms of\n\tbacking store only.\n\n2004-03-11  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c\n\t(window_wm_protocols_filter): New function.\n\t(window_focus_in_cb): Remove function.\n\t(window_focus_out_cb): Likewise.\n\t(window_focus_or_active_state_change_cb): New function.\n\t(create): Add filter that removes WM_TAKE_FOCUS client messages.\n\t(connectSignals): Don't attach handlers to focus-in-event or\n\tfocus-out-event signals.  Handle notify signal.\n\n2004-03-11  David Jee  <djee@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkCheckboxPeer.java\n\t(gtkSetLabel): New native method declaration.\n\t(setLabel): Use gtkSetLabel.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkCheckboxPeer.c\n\t(Java_gnu_java_awt_peer_gtk_GtkCheckboxPeer_gtkSetLabel): New method.\n\n2004-03-10  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GdkGraphics.java (setColor): Default to\n\tblack when color argument is null.\n\n2004-03-10  Kim Ho  <kho@redhat.com>\n\n\t* java/awt/Container.java: Remove check\n\tfor drag events.\n\n2004-03-10  Kim Ho  <kho@redhat.com>\n\n\t* java/awt/Container.java: (visitChild):\n\tRemove candidate clip. Use the component\n\tclip to intersect.\n\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java:\n\t(handleEvent): Use the PaintEvent's clip.\n\n2004-03-10  Kim Ho  <kho@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java:\n\t(handleEvent): Don't set the clip for the\n\tGraphics object.\n\n2004-03-09  Graydon Hoare  <graydon@redhat.com>\n\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGlyphVector.c:\n\tFix double <-> fixed macros, reset font transform.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkClasspathFontPeerMetrics.c:\n\tLikewise.\n\n2004-03-09\ufffd\ufffd Kim Ho  <kho@redhat.com>\n\n\t* java/awt/Container.java: (visitChild): Move\n\tthe x and y coordinate of the component rectangle\n\tto correct position.\n\t(handleEvent): Forward drag events to the pressed\n\tcomponent.\n\t* javax/swing/plaf/basic/BasicScrollBarUI.java:\n\tFix comments.\n\t(ArrowButtonListener::mousePressed): Stop the\n\texisting timer.\n\t(mouseDragged): Implement.\n\t(TrackListener::mousePressed): Only react if\n\tthe press doesn't occur on the thumb, otherwise\n\tjust set the offset.\n\t(TrackListener::mouseReleased): Unset the isAdjusting\n\tvalue.\n\t(createIncreaseIcon): Switch icon.\n\t(createDecreaseIcon): Switch icon.\n\t(calculatePreferredSize): Use width.\n\t(getThumbBounds): Use the top as the lower value.\n\t(layoutVScrollBar): Switch the button locations.\n\t(paintIncreaseHighlight): Paint correct side of thumb.\n\t(paintDecreaseHighlight): ditto.\n\t(valueForYPosition): Use top as the lower value.\n\t* javax/swing/plaf/basic/BasicSliderUI.java:\n\tFix comments.\n\t(mouseDragged): Implement.\n\t(mousePressed): Only react when the thumb isn't\n\tpressed, otherwise just set offset.\n\t(mouseReleased): Handle a release of the thumb.\n\t(scrollDueToClickInTrack): Stop the timer first.\n\t* javax/swing/JProgressBar.java:\n\t(setString): Fix change condition.\n\t* javax/swing/JSeparator.java:\n\tRemove println's.\n\n2004-03-08  David Jee  <djee@redhat.com>\n\n\t* java/awt/image/AffineTransformOp.java:\n\t(filter): Use Graphics2D interface instead of directly using the\n\tGdkGraphics2D peer.\n\n2004-03-05  David Jee  <djee@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkButtonPeer.java\n\t(handleEvent): Action events are generated upon MOUSE_RELEASED.\n\t* java/awt/Container.java\n\t(acquireComponentForMouseEvent): Fixed.\n\t(handleEvent): Fixed.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.c\n\t(state_to_awt_mods_with_button_states): New method.\n\t(pre_event_handler): Fixed mouse event generation.\n\n2004-03-05  Olga Rodimina  <rodimina@redhat.com>\n\n\tgnu/java/awt/peer/gtk/GdkGraphics2D.java\n\t(GdkGraphics2D (BufferedImage)): Initialize\n\tpixmap associated with specified BufferedImage.\n\t(setPaint): Changed implementation of Texture\n\tPaint to use AffineTransformOp.\n\t* java/awt/image/AffineTransformOp.java\n\t(createCompatibleDestRaster): Throw RasterFormatException\n\tif resulting width or height of raster is 0.\n\n2004-03-04  Olga Rodimina  <rodimina@redhat.com>\n\n\t* java/awt/image/AffineTransformOp.java:\n\tRemoved unnecessary field interpolationType.\n\tFormatted some of the lines to be consistent with\n\tthe GNU style.\n\t(AffineTransformOp): Create new RenderingHints\n\tcontaining specified interpolation type.\n\t(createCompatibleDestImage): Implemented.\n\t(createCompatibleDestRaster): Implemented.\n\t(filter): Implemented.\n\t(getBounds2D(BufferedImage)): Implemented.\n\t(getBounds2D(Raster)): Implemented.\n\t(getInterpolationType): Get interpolation value from\n\trendering hints.\n\n2004-03-04  David Jee  <djee@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkContainerPeer.java\n\t(setFont): Check if child peers are null.\n\n2004-03-04  Graydon Hoare  <graydon@redhat.com>\n\n\t* testsuite/lib/libjava.exp (libjava_find_lib): Don't include\n\t.libs in -L option.\n\t(libjava_arguments): Add new libraries to argument list.\n\n2004-03-04  Tom Tromey  <tromey@redhat.com>\n\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (toolexeclib_LTLIBRARIES): Added lib-java-awt.la,\n\tlib-javax-swing.la, lib-java-applet.la, lib-java-beans.la.\n\t(misc_java_source_files): New macro.\n\t(swing_java_source_files): Likewise.\n\t(awt_java_source_files): Pruned.\n\t(applet_java_source_files): New macro.\n\t(beans_java_source_files): Likewise.\n\t(lib_java_applet_la_SOURCES): Likewise.\n\t(lib_java_awt_la_SOURCES): Likewise.\n\t(lib_javax_swing_la_SOURCES): Likewise.\n\t(lib_java_beans_la_SOURCES): Likewise.\n\t(all_java_object_files): Likewise.\n\t(%.lo: %.java): Use all_java_object_files.\n\t(all_java_source_files): Added new _SOURCES.\n\t(ordinary_java_source_files): Removed awt_java_source_files.\n\n2004-03-02  Olga Rodimina  <rodimina@redhat.com>\n\n\t* Makefile.am: Added java/awt/image/AffineTransformOp.java\n\t* Makefile.in: Re-generated.\n\t* java/awt/image/AffineTransformOp.java: New Class.\n\n2004-03-01  Olga Rodimina  <rodimina@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java\n\t(setPaint): Interpret correctly TexturePaint's\n\tanchor rectangle.\n\t(drawImage): Fixed scale factors of the affine\n\ttransform.\n\n2004-02-27  David Jee  <djee@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GdkGraphics.java\n\t(GdkGraphics(Component)): Inherit font from component.\n\t(drawString): Use font style.\n\t* gnu/java/awt/peer/gtk/GtkCheckboxPeer.java\n\t(gtkSetFont): New native method declaration.\n\t(setFont): New method.\n\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java\n\t(gtkSetFont): New native method declaration.\n\t(setFont): Call new native method gtkSetFont.\n\t* gnu/java/awt/peer/gtk/GtkContainerPeer.java\n\t(setFont): For all child components who do not their fonts set,\n        set their peers' fonts with this container's font.\n\t* gnu/java/awt/peer/gtk/GtkLabelPeer.java:\n\tMove all native method declarations to the top for readability.\n\t(gtkSetFont): New native method declaration.\n\t(setFont): New method.\n\t* java/awt/Component.java\n\t(setFont): Invalidate after setting the font.\n\t* java/awt/Container.java\n\t(invalidateTree): New method.\n\t(setFont): Invalidate the container tree after setting the font.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics.c\n\t(Java_gnu_java_awt_peer_gtk_GdkGraphics_drawString): Use font style.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkCheckboxPeer.c\n\t(Java_gnu_java_awt_peer_gtk_GtkCheckboxPeer_gtkSetFont): New method.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n\t(Java_gnu_java_awt_peer_gtk_GtkComponentPeer_gtkSetFont): New method.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkLabelPeer.c\n\t(Java_gnu_java_awt_peer_gtk_GtkLabelPeer_gtkSetFont): New method.\n\n2004-02-27  Olga Rodimina <rodimina@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java\n\t(updateBufferedImage): New helper function.\n\tUpdates BufferedImage in memory if it was changed.\n\t(draw): changed to update BufferedImage in memory after\n\tthis drawing operation\n\t(fill): Ditto.\n\t(draw3DRect): Ditto.\n\t(fill3DRect): Ditto.\n\t(clearRect): Ditto.\n\t(drawRaster): Ditto.\n\t(drawImage) : Ditto. Update only in case of GtkOffScreenImage with\n\tno affine transformation.\n\t(drawGlyphVector): Ditto.\n\n2004-02-26  Olga Rodimina <rodimina@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java\n\t(isBufferedImageGraphics): New Helper function.\n\tReturns true if this graphics2d can be used to draw\n\tinto buffered image and false otherwise.\n\t(updateImagePixels): New Helper function.\n\tUpdates pixels in the BufferedImage.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics2D.c\n\t(getImagePixels): New function. Returns pixels\n\tof the buffered image associated with\n\tthis Graphics2D.\n\n2004-02-26  David Jee  <djee@redhat.com>\n\n\t* java/awt/BorderLayout.java\n\t(layoutContainer): Fix width and height calculations to ensure\n\tthat they're non-negative.\n\t* java/awt/Component.java\n\t(setBackground): If c is null, inherit from closest ancestor whose\n\tbackground color is set.\n\n2004-02-26\ufffd\ufffd Kim Ho\ufffd\ufffd <kho@redhat.com>\n\n\t* Makefile.am: Add new files.\n\t* Makefile.in: Re-generate.\n\t* javax/swing/JProgressBar.java:\n\t(JProgressBar(int, int int)): Throw\n\tIllegalArgumentException if orientation is\n\tinvalid.\n\t(JProgressBar(BoundedRangeModel)): Create\n\tChangeListener and register it. UpdateUI.\n\t(getChangeListeners): Implement.\n\t(setModel): Reset ChangeListener.\n\t* javax/swing/JScrollBar.java: Implement.\n\t* javax/swing/JSeparator.java: Implement.\n\t* javax/swing/JSlider.java:\n\t(JSlider(int, int, int, int)): Throw\n\tIllegalArgumentException if orientation\n\tis invalid.\n\t(getChangeListeners): Fix method name.\n\t* javax/swing/SwingUtilities.java:\n\t(layoutCompoundLabel): If there is no text,\n\tset the text rectangle dimensions to 0.\n\t* javax/swing/plaf/basic/BasicButtonUI.java:\n\t(paint): If there is no text, don't paint it.\n\t* javax/swing/plaf/basic/BasicScrollBarUI.java:\n\tImplement.\n\t* javax/swing/plaf/basic/BasicSeparatorUI.java:\n\tImplement.\n\t* javax/swing/plaf/basic/BasicSliderUI.java:\n\t(propertyChange): If the model changes, change\n\tthe listeners accordingly.\n\n2004-02-25  Graydon Hoare  <graydon@redhat.com>\n\n\t* javax/swing/AbstractButton.java: Add \"final\" qualifiers.\n\t* javax/swing/JList.java: Reimplement.\n\t* javax/swing/DefaultListSelectionModel.java: Reimplement.\n\t* javax/swing/plaf/basic/BasicListUI.java: Reimplement.\n\t* javax/swing/plaf/basic/BasicLookAndFeel.java: Add \"purple\" values.\n\t* javax/swing/ListModel.java: Javadoc.\n\t* javax/swing/ListSelectionModel.java: Add missing methods.\n\t* javax/swing/AbstractListModel.java: Javadoc and corrections.\n\t* javax/swing/DefaultListModel.java: Javadoc and corrections.\n\t* javax/swing/ListModel.java: Javadoc and corrections.\n\t* javax/swing/DefaultListCellRenderer.java: Minor tidying.\n\n2004-02-25  David Jee  <djee@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkFontPeer.java\n\t(GtkFontPeer): Change default size to 12.\n\t* gnu/java/awt/peer/gtk/GtkToolkit.java\n\t(getFontPeer): Change default size to 12.\n\t(getClasspathFontPeer): Likewise. Set default name to \"Default\".\n\t* java/awt/Font.java\n\t(Font(Map)): Call Font(String,Map).\n\t(Font(String,Map)): If attrs is null, initialize it as an empty\n\tHashMap, which will ensure that the Font will get default attributes.\n\n2004-02-25  David Jee  <djee@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GtkFontPeer.java\n\t(GtkFontPeer(String,int)): Call the new constructor with size 1.\n\t(GtkFontPeer(String,int,int)): New constructor with size attribute.\n\t* gnu/java/awt/peer/gtk/GtkToolkit.java\n\t(getFontPeer(String,int)): Call the new overload method with size 1.\n\t(getFontPeer(String,int,int)): New method. Overloaded with size\n\tattribute.\n\t(getClasspathFontPeer): Set the size of the font.\n\n2004-02-24  Olga Rodimina  <rodimina@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java\n\t(bimage): New field.\n\t(GdkGraphics2D): New Constructor. Constructs Graphics\n\tobject that can be used to draw into the Buffered Image.\n\t* gnu/java/awt/peer/gtk/GdkGraphicsEnvironment.java:\n\t(GdkGraphicsEnvironment): Fixed to include public\n\tkeyword.\n\t(createGraphics): Implemented.\n\t* gnu/java/awt/peer/gtk/GtkToolkit.java\n\t(getLocalGraphicsEnvironment): Implemented.\n\t* java/awt/GraphicsEnvironment.java:\n\t(getLocalGraphicsEnvironment): Implemented.\n\t* java/awt/image/BufferedImage.java:\n\t(createGraphics): Implemented.\n\n2004-02-24  David Jee  <djee@redhat.com>\n\n\t* java/awt/Component.java\n\t(eventTypeEnabled): Add MOUSE_MOVED and MOUSE_DRAGGED event types.\n\t* java/awt/Container.java\n\t(addNotifyContainerChildren): Fix event enabling.\n\n2004-02-23  Olga Rodimina  <rodimina@redhat.com>\n\n\t* Makefile.am: Added\n\tgnu/java/awt/peer/gtk/GdkGraphicsEnvironment.java\n\t* Makefile.in: Re-generated.\n\t* gnu/java/awt/peer/gtk/GdkGraphicsEnvironment.java:\n\tNew Class.\n\n2004-02-19  Kim Ho  <kho@redhat.com>\n\n\t* Makefile.am: Add BasicProgressBarUI\n\t* Makefile.in: Regenerate.\n\t* javax/swing/JProgressBar.java:\n\tRe-implement.\n\t* javax/swing/plaf/basic/BasicLookAndFeel.java\n\tAdd constants for JProgressBar.\n\t* javax/swing/plaf/basic/BasicProgressBarUI.java\n\tImplement.\n\t* javax/swing/plaf/basic/BasicSliderUI.java\n\tChange comments.\n\t(calculateGeometry): New method\n\t(paint): Remove unnecessary size calculations.\n\n2004-02-18  Olga Rodimina  <rodimina@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java\n\t(drawRaster): Fixed small error that caused\n\timageToUser transformation to be set incorrectly.\n\t(toString): Implemented.\n\n2004-02-18  David Jee  <djee@redhat.com>\n\n\t* java/awt/CardLayout.java\n\t(addLayoutComponent): Show the first component added as the default.\n\t(removeLayoutComponent): After removing, show the next component.\n\t(gotoComponent): If there is only one component, show it and return.\n\n2004-02-18  Kim Ho  <kho@redhat.com>\n\n\t* javax/swing/JSlider.java: Re-order\n\tmodifiers.\n\t* javax/swing/JLabel.java: Re-order\n\tmodifiers.\n\t* javax/swing/JComponent.java:\n\t(addPropertyChangeListener):\n\tImplement.\n\t(removePropertyChangeListener):\n\tditto.\n\t(firePropertyChangeEvent):\n\tditto.\n\n2004-02-17  David Jee  <djee@redhat.com>\n\n\t* java/awt/Component.java\n\t(show): Dispatch ComponentEvent via system event queue.\n\t(hide): Likewise.\n\t(move): Likewise.\n\t(resize): Likewise.\n\t(reshape): Likewise.\n\t* java/awt/Window.java\n\t(setBoundsCallback): Likewise.\n\n2004-02-17  David Jee  <djee@redhat.com>\n\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n\t(Java_gnu_java_awt_peer_gtk_GtkComponentPeer_setNativeBounds):\n\tUse gtk_widget_set_size_request() instead of the deprecated\n\tgtk_widget_set_usize().\n\n2004-02-17  Kim Ho  <kho@redhat.com>\n\n\t* javax/swing/JSlider.java: Fix comments and\n\tmake property strings constants.\n\t(createStandardLabels): Use the labels\n\tpreferred size as bounds.\n\t* javax/swing/plaf/basic/BasicSliderUI.java\n\tFix comments.\n\t(ScrollHandler::actionPerformed): Don't\n\tcalculate the timer stop value. Let the\n\tMouseListeners find the stop location.\n\t(getPreferredHorizontalSize): Re-implement.\n\t(getPreferredVerticalSize): ditto.\n\t(getMinimumHorizontalSize): ditto.\n\t(getMinimumVerticalSize): ditto.\n\t(getPreferredSize): ditto.\n\t(getMinimumSize): ditto.\n\t(getMaximumSize): ditto.\n\t(paintTicks): Use doubles to find the\n\ttick location.\n\t(paintHorizontalLabel):\ufffd\ufffd Use preferredSize\n\tas initial width and height.\n\t(paintVerticalLabel): ditto.\n\n2004-02-17  Kim Ho  <kho@redhat.com>\n\n\t* javax/swing/JLabel.java: Changed\n\tproperty strings to constants.\n\t(DISPLAYED_MNEMONIC_INDEX_CHANGED_PROPERTY):\n\tNew property.\n\t(setText): Change mnemonic index if\n\ttext is too short.\n\t(setDisplayedMnemonicIndex): Fire property\n\tchange event.\n\t(getDisplayedMnemonicIndex): Remove check\n\tagainst short text.\n\n2004-02-17 Olga Rodimina <rodimina@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java:\n\t(drawImage(img,xform,obs)): Invert xform before\n\tpassing the xform to cairo.\n\t(drawImage(img,x,y,bgcolor,obs)): Implemented.\n\t(drawImage (img,x,y,w,h,bgcolor,obs)): Partly\n\timplemented.\n\t(drawImage (img,x,y,w,h,obs)): Implemented.\n\t(drawImage (img,dx1,dy1,dx2,dy2,sx1,sy1,sx2,sy2,\n\tbgcolor,obs)): Partly implemented.\n\t(drawImage (img,dx1,dy1,dx2,dy2,sx1,sy1,sx2,sy2,obs)):\n\tImplemented.\n\t* java/awt/image/BufferedImage.java:\n\t(copyData): if dest is null, create raster with same\n\tdimensions as the current image.\n\n2004-02-16  Graydon Hoare  <graydon@redhat.com>\n\n\t* javax/swing/plaf/basic/BasicLabelUI.java\n\t(getPreferredSize): Use layoutCL.\n\t* javax/swing/plaf/basic/BasicGraphicsUtils.java\n\t(getPreferredButtonSize): Start with empty view rect, layout using\n\tcomponent's preferred alignment.\n\t* javax/swing/plaf/basic/BasicLookAndFeel.java: Add some Label and\n\tList defaults.\n\n2004-02-16  David Jee  <djee@redhat.com>\n\n\t* java/awt/Component.java\n\t(show): Dispatch COMPONENT_SHOWN ComponentEvent.\n\t(hide): Dispatch COMPONENT_HIDDEN ComponentEvent.\n\t(move): Erase old bounds and repaint new bounds. Dispatch\n\tCOMPONENT_MOVED ComponentEvent.\n\t(resize): Erase old bounds and repaint new bounds. Dispatch\n\tCOMPONENT_RESIZED ComponentEvent.\n\t(reshape): Dispatch COMPONENT_RESIZED and COMPONENT_MOVED\n\tComponentEvents.\n\t* java/awt/Window.java\n\t(setBoundsCallback): Dispatch COMPONENT_RESIZED and COMPONENT_MOVED\n\tComponentEvents.\n\n2004-02-16  Olga Rodimina  <rodimina@redhat.com>\n\n\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java:\n\t(setRenderingHint): Added implementation of\n\tInterpolation rendering hints.\n\t(setRenderingHints): Ditto.\n\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics2D.c:\n\t(drawPixels): fixed to allow user to choose type\n\tof filtering that should be used when displaying images.\n\t(cairoSurfaceSetFilter): New method. Sets filter type for\n\tinterpolation of pixel values.\n\n2004-02-16  David Jee  <djee@redhat.com>\n\n\t* java/awt/GridBagLayout.java\n\t(calcCellSizes): Rows or columns with zero sizes should still be\n\tconsidered for extra space distribution.\n\n2004-02-16  Kim Ho  <kho@redhat.com>\n\n\t* javax/swing/JLabel.java: Re-implement.\n\t* javax/swing/plaf/basic/BasicLabelUI.java\n\tRe-implement.\n\t* javax/swing/plaf/basic/BasicLookAndFeel.java:\n\tAdded constant.\n\n2004-02-16\ufffd\ufffd Kim Ho\ufffd\ufffd <kho@redhat.com>\n\n\t* javax/swing/JSlider.java: Fix indentation and comments.\n\t(setModel): Remove null check to conform with Sun's.\n\t(setOrientation): Throw exception if not\n\tHORIZONTAL or VERTICAL.\n\t(getInverted): Use private variable instead of\n\tComponentOrientation.\n\t(setInverted): ditto.\n\t* javax/swing/plaf/basic/BasicSliderUI.java:\n\tFix indentation and comments.\n\t(propertyChange): Remove check for inverted slider, handle\n\tin main paint.\n\t(getMinimumSize): Return preferred size.\n\t(getMaximumSize): ditto.\n\t(calculateFocusRect): Don't relocate rectangle.\n\t(drawInverted): Return XOR of the slider's inversion and\n\tthe component's orientation.\n\t(paint): Update leftToRightCache\n\n2004-02-13  David Jee  <djee@redhat.com>\n\n\t* java/awt/GridBagLayout.java\n\t(GetLayoutInfo): Fix weight and size distribution. Relocate repeated\n\tcode to helper methods.\n\t(sortBySpan): New helper method.\n\t(distributeSizeAndWeight): Likewise.\n\t(calcCellWeights): Likewise.\n\t(calcCellSizes): Add comments.\n\n2004-02-13  David Jee  <djee@redhat.com>\n\n\t* java/awt/Component.java\n        (show): Only do something if component is invisible at the moment.\n        (hide): Only do something if component is visible at the moment.\n        (reshape): If lightweight, erase old bounds and repaint new bounds.\n\n2004-02-13\ufffd\ufffd Kim Ho\ufffd\ufffd <kho@redhat.com>\n\n\t* Makefile.am: Updated for new file.\n\t* Makefile.in: Regenerated.\n\t* javax/swing/JSlider.java: Reimplement.\n\t* javax/swing/SwingUtilities.java\n\t(layoutCompoundLabel): Use icon height\n\tinstead of width.\n\t(paintComponent): Implement.\n\t* javax/swing/plaf/basic/BasicLookAndFeel.java:\n\tAdd JSlider defaults.\n\t* javax/swing/plaf/basic/BasicSliderUI.java:\n\tImplement. New file.\n\nFrom-SVN: r79607", "tree": {"sha": "02790a2b250b62643a1de68b63bd078238bfaf46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02790a2b250b62643a1de68b63bd078238bfaf46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86881a7b541b2ec6557b1a315f841b211d14c576", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86881a7b541b2ec6557b1a315f841b211d14c576", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86881a7b541b2ec6557b1a315f841b211d14c576", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86881a7b541b2ec6557b1a315f841b211d14c576/comments", "author": null, "committer": null, "parents": [{"sha": "ab3533d6559205bee768b8d9e359111d52d10733", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab3533d6559205bee768b8d9e359111d52d10733", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab3533d6559205bee768b8d9e359111d52d10733"}], "stats": {"total": 18019, "additions": 14344, "deletions": 3675}, "files": [{"sha": "df198b158954aa5dd7b36221c83a848d429a4884", "filename": "libjava/ChangeLog", "status": "modified", "additions": 578, "deletions": 0, "changes": 578, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -1,3 +1,581 @@\n+2004-03-12  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java: Clipping fixes.\n+\t* javax/swing/JComponent.java (paint): Use persistent double buffer. \n+\t* javax/swing/JList.java (ListListener): Revalidate on changes.\n+\t* javax/swing/JScrollPane.java: Reimplement.\n+\t* javax/swing/JViewport.java: Reimplement.\n+\t* javax/swing/ScrollPaneLayout.java: Reimplement.\n+\t* javax/swing/ViewportLayout.java: Tidy up.\n+\t* javax/swing/plaf/basic/BasicButtonListener.java: Remove printlns.\n+\t* javax/swing/plaf/basic/BasicScrollPaneUI.java: Reimplement.\n+\t* javax/swing/plaf/basic/BasicSliderUI.java: Handle missing labels.\n+\t* javax/swing/plaf/basic/BasicViewportUI.java: Implement in terms of\n+\tbacking store only.\n+\n+2004-03-11  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c\n+\t(window_wm_protocols_filter): New function.\n+\t(window_focus_in_cb): Remove function.\n+\t(window_focus_out_cb): Likewise.\n+\t(window_focus_or_active_state_change_cb): New function.\n+\t(create): Add filter that removes WM_TAKE_FOCUS client messages.\n+\t(connectSignals): Don't attach handlers to focus-in-event or\n+\tfocus-out-event signals.  Handle notify signal.\n+\n+2004-03-11  David Jee  <djee@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkCheckboxPeer.java\n+\t(gtkSetLabel): New native method declaration.\n+\t(setLabel): Use gtkSetLabel.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkCheckboxPeer.c\n+\t(Java_gnu_java_awt_peer_gtk_GtkCheckboxPeer_gtkSetLabel): New method.\n+\n+2004-03-10  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GdkGraphics.java (setColor): Default to\n+\tblack when color argument is null.\n+\n+2004-03-10  Kim Ho  <kho@redhat.com>\n+\n+\t* java/awt/Container.java: Remove check\n+\tfor drag events.\n+\n+2004-03-10  Kim Ho  <kho@redhat.com>\n+\n+\t* java/awt/Container.java: (visitChild):\n+\tRemove candidate clip. Use the component\n+\tclip to intersect.\n+\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java:\n+\t(handleEvent): Use the PaintEvent's clip.\n+\n+2004-03-10  Kim Ho  <kho@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java:\n+\t(handleEvent): Don't set the clip for the\n+\tGraphics object.\n+\n+2004-03-09  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGlyphVector.c: \n+\tFix double <-> fixed macros, reset font transform.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkClasspathFontPeerMetrics.c:\n+\tLikewise.\n+\n+2004-03-09\ufffd Kim Ho  <kho@redhat.com>\n+\n+\t* java/awt/Container.java: (visitChild): Move\n+\tthe x and y coordinate of the component rectangle\n+\tto correct position.\n+\t(handleEvent): Forward drag events to the pressed\n+\tcomponent.\n+\t* javax/swing/plaf/basic/BasicScrollBarUI.java:\n+\tFix comments.\n+\t(ArrowButtonListener::mousePressed): Stop the\n+\texisting timer.\n+\t(mouseDragged): Implement.\n+\t(TrackListener::mousePressed): Only react if\n+\tthe press doesn't occur on the thumb, otherwise\n+\tjust set the offset.\n+\t(TrackListener::mouseReleased): Unset the isAdjusting\n+\tvalue.\n+\t(createIncreaseIcon): Switch icon.\n+\t(createDecreaseIcon): Switch icon.\n+\t(calculatePreferredSize): Use width.\n+\t(getThumbBounds): Use the top as the lower value.\n+\t(layoutVScrollBar): Switch the button locations.\n+\t(paintIncreaseHighlight): Paint correct side of thumb.\n+\t(paintDecreaseHighlight): ditto.\n+\t(valueForYPosition): Use top as the lower value.\n+\t* javax/swing/plaf/basic/BasicSliderUI.java:\n+\tFix comments.\n+\t(mouseDragged): Implement.\n+\t(mousePressed): Only react when the thumb isn't\n+\tpressed, otherwise just set offset.\n+\t(mouseReleased): Handle a release of the thumb.\n+\t(scrollDueToClickInTrack): Stop the timer first.\n+\t* javax/swing/JProgressBar.java:\n+\t(setString): Fix change condition.\n+\t* javax/swing/JSeparator.java:\n+\tRemove println's.\n+\n+2004-03-08  David Jee  <djee@redhat.com>\n+\n+\t* java/awt/image/AffineTransformOp.java:\n+\t(filter): Use Graphics2D interface instead of directly using the\n+\tGdkGraphics2D peer.\n+\n+2004-03-05  David Jee  <djee@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkButtonPeer.java\n+\t(handleEvent): Action events are generated upon MOUSE_RELEASED.\n+\t* java/awt/Container.java\n+\t(acquireComponentForMouseEvent): Fixed.\n+\t(handleEvent): Fixed.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.c\n+\t(state_to_awt_mods_with_button_states): New method.\n+\t(pre_event_handler): Fixed mouse event generation.\n+\n+2004-03-05  Olga Rodimina  <rodimina@redhat.com>\n+\n+\tgnu/java/awt/peer/gtk/GdkGraphics2D.java\n+\t(GdkGraphics2D (BufferedImage)): Initialize\n+\tpixmap associated with specified BufferedImage.\n+\t(setPaint): Changed implementation of Texture\n+\tPaint to use AffineTransformOp.\n+\t* java/awt/image/AffineTransformOp.java\n+\t(createCompatibleDestRaster): Throw RasterFormatException \n+\tif resulting width or height of raster is 0.\n+\n+2004-03-04  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* java/awt/image/AffineTransformOp.java:\n+\tRemoved unnecessary field interpolationType.\n+\tFormatted some of the lines to be consistent with \n+\tthe GNU style.\n+\t(AffineTransformOp): Create new RenderingHints \n+\tcontaining specified interpolation type.\n+\t(createCompatibleDestImage): Implemented.\n+\t(createCompatibleDestRaster): Implemented.\n+\t(filter): Implemented.\n+\t(getBounds2D(BufferedImage)): Implemented.\n+\t(getBounds2D(Raster)): Implemented.\n+\t(getInterpolationType): Get interpolation value from \n+\trendering hints.\n+\n+2004-03-04  David Jee  <djee@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkContainerPeer.java\n+\t(setFont): Check if child peers are null.\n+\n+2004-03-04  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* testsuite/lib/libjava.exp (libjava_find_lib): Don't include\n+\t.libs in -L option.\n+\t(libjava_arguments): Add new libraries to argument list.\n+\n+2004-03-04  Tom Tromey  <tromey@redhat.com>\n+\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (toolexeclib_LTLIBRARIES): Added lib-java-awt.la,\n+\tlib-javax-swing.la, lib-java-applet.la, lib-java-beans.la.\n+\t(misc_java_source_files): New macro.\n+\t(swing_java_source_files): Likewise.\n+\t(awt_java_source_files): Pruned.\n+\t(applet_java_source_files): New macro.\n+\t(beans_java_source_files): Likewise.\n+\t(lib_java_applet_la_SOURCES): Likewise.\n+\t(lib_java_awt_la_SOURCES): Likewise.\n+\t(lib_javax_swing_la_SOURCES): Likewise.\n+\t(lib_java_beans_la_SOURCES): Likewise.\n+\t(all_java_object_files): Likewise.\n+\t(%.lo: %.java): Use all_java_object_files.\n+\t(all_java_source_files): Added new _SOURCES.\n+\t(ordinary_java_source_files): Removed awt_java_source_files.\n+\n+2004-03-02  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* Makefile.am: Added java/awt/image/AffineTransformOp.java\n+\t* Makefile.in: Re-generated.\n+\t* java/awt/image/AffineTransformOp.java: New Class.\n+\n+2004-03-01  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java\n+\t(setPaint): Interpret correctly TexturePaint's\n+\tanchor rectangle.\n+\t(drawImage): Fixed scale factors of the affine\n+\ttransform.\n+\n+2004-02-27  David Jee  <djee@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GdkGraphics.java\n+\t(GdkGraphics(Component)): Inherit font from component.\n+\t(drawString): Use font style.\n+\t* gnu/java/awt/peer/gtk/GtkCheckboxPeer.java\n+\t(gtkSetFont): New native method declaration.\n+\t(setFont): New method.\n+\t* gnu/java/awt/peer/gtk/GtkComponentPeer.java\n+\t(gtkSetFont): New native method declaration.\n+\t(setFont): Call new native method gtkSetFont.\n+\t* gnu/java/awt/peer/gtk/GtkContainerPeer.java\n+\t(setFont): For all child components who do not their fonts set,\n+        set their peers' fonts with this container's font.\n+\t* gnu/java/awt/peer/gtk/GtkLabelPeer.java:\n+\tMove all native method declarations to the top for readability.\n+\t(gtkSetFont): New native method declaration.\n+\t(setFont): New method.\n+\t* java/awt/Component.java\n+\t(setFont): Invalidate after setting the font.\n+\t* java/awt/Container.java\n+\t(invalidateTree): New method.\n+\t(setFont): Invalidate the container tree after setting the font.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics.c\n+\t(Java_gnu_java_awt_peer_gtk_GdkGraphics_drawString): Use font style.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkCheckboxPeer.c\n+\t(Java_gnu_java_awt_peer_gtk_GtkCheckboxPeer_gtkSetFont): New method.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n+\t(Java_gnu_java_awt_peer_gtk_GtkComponentPeer_gtkSetFont): New method.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkLabelPeer.c\n+\t(Java_gnu_java_awt_peer_gtk_GtkLabelPeer_gtkSetFont): New method.\n+\n+2004-02-27  Olga Rodimina <rodimina@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java\n+\t(updateBufferedImage): New helper function.\n+\tUpdates BufferedImage in memory if it was changed.\n+\t(draw): changed to update BufferedImage in memory after\n+\tthis drawing operation\n+\t(fill): Ditto.\n+\t(draw3DRect): Ditto.\n+\t(fill3DRect): Ditto.\n+\t(clearRect): Ditto.\n+\t(drawRaster): Ditto.\n+\t(drawImage) : Ditto. Update only in case of GtkOffScreenImage with \n+\tno affine transformation.\n+\t(drawGlyphVector): Ditto.\n+\n+2004-02-26  Olga Rodimina <rodimina@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java\n+\t(isBufferedImageGraphics): New Helper function. \n+\tReturns true if this graphics2d can be used to draw \n+\tinto buffered image and false otherwise.\n+\t(updateImagePixels): New Helper function. \n+\tUpdates pixels in the BufferedImage.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics2D.c\n+\t(getImagePixels): New function. Returns pixels\n+\tof the buffered image associated with \n+\tthis Graphics2D.\n+\n+2004-02-26  David Jee  <djee@redhat.com>\n+\n+\t* java/awt/BorderLayout.java\n+\t(layoutContainer): Fix width and height calculations to ensure\n+\tthat they're non-negative.\n+\t* java/awt/Component.java\n+\t(setBackground): If c is null, inherit from closest ancestor whose\n+\tbackground color is set.\n+\n+2004-02-26\ufffd Kim Ho\ufffd <kho@redhat.com>\n+\n+\t* Makefile.am: Add new files.\n+\t* Makefile.in: Re-generate.\n+\t* javax/swing/JProgressBar.java: \n+\t(JProgressBar(int, int int)): Throw\n+\tIllegalArgumentException if orientation is\n+\tinvalid.\n+\t(JProgressBar(BoundedRangeModel)): Create\n+\tChangeListener and register it. UpdateUI.\n+\t(getChangeListeners): Implement.\n+\t(setModel): Reset ChangeListener.\n+\t* javax/swing/JScrollBar.java: Implement.\n+\t* javax/swing/JSeparator.java: Implement.\n+\t* javax/swing/JSlider.java:\n+\t(JSlider(int, int, int, int)): Throw \n+\tIllegalArgumentException if orientation\n+\tis invalid.\n+\t(getChangeListeners): Fix method name.\n+\t* javax/swing/SwingUtilities.java:\n+\t(layoutCompoundLabel): If there is no text,\n+\tset the text rectangle dimensions to 0.\n+\t* javax/swing/plaf/basic/BasicButtonUI.java:\n+\t(paint): If there is no text, don't paint it.\n+\t* javax/swing/plaf/basic/BasicScrollBarUI.java:\n+\tImplement.\n+\t* javax/swing/plaf/basic/BasicSeparatorUI.java:\n+\tImplement.\n+\t* javax/swing/plaf/basic/BasicSliderUI.java: \n+\t(propertyChange): If the model changes, change\n+\tthe listeners accordingly.\n+\n+2004-02-25  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* javax/swing/AbstractButton.java: Add \"final\" qualifiers.\n+\t* javax/swing/JList.java: Reimplement.\n+\t* javax/swing/DefaultListSelectionModel.java: Reimplement.\n+\t* javax/swing/plaf/basic/BasicListUI.java: Reimplement.\n+\t* javax/swing/plaf/basic/BasicLookAndFeel.java: Add \"purple\" values.\n+\t* javax/swing/ListModel.java: Javadoc.\n+\t* javax/swing/ListSelectionModel.java: Add missing methods.\n+\t* javax/swing/AbstractListModel.java: Javadoc and corrections.\n+\t* javax/swing/DefaultListModel.java: Javadoc and corrections.\n+\t* javax/swing/ListModel.java: Javadoc and corrections.\n+\t* javax/swing/DefaultListCellRenderer.java: Minor tidying.\n+\n+2004-02-25  David Jee  <djee@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkFontPeer.java\n+\t(GtkFontPeer): Change default size to 12.\n+\t* gnu/java/awt/peer/gtk/GtkToolkit.java\n+\t(getFontPeer): Change default size to 12.\n+\t(getClasspathFontPeer): Likewise. Set default name to \"Default\".\n+\t* java/awt/Font.java\n+\t(Font(Map)): Call Font(String,Map).\n+\t(Font(String,Map)): If attrs is null, initialize it as an empty\n+\tHashMap, which will ensure that the Font will get default attributes.\n+\n+2004-02-25  David Jee  <djee@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GtkFontPeer.java\n+\t(GtkFontPeer(String,int)): Call the new constructor with size 1.\n+\t(GtkFontPeer(String,int,int)): New constructor with size attribute.\n+\t* gnu/java/awt/peer/gtk/GtkToolkit.java\n+\t(getFontPeer(String,int)): Call the new overload method with size 1.\n+\t(getFontPeer(String,int,int)): New method. Overloaded with size\n+\tattribute.\n+\t(getClasspathFontPeer): Set the size of the font.\n+\n+2004-02-24  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java\n+\t(bimage): New field.\n+\t(GdkGraphics2D): New Constructor. Constructs Graphics\n+\tobject that can be used to draw into the Buffered Image.\n+\t* gnu/java/awt/peer/gtk/GdkGraphicsEnvironment.java:\n+\t(GdkGraphicsEnvironment): Fixed to include public \n+\tkeyword.\n+\t(createGraphics): Implemented.\n+\t* gnu/java/awt/peer/gtk/GtkToolkit.java\n+\t(getLocalGraphicsEnvironment): Implemented.\n+\t* java/awt/GraphicsEnvironment.java:\n+\t(getLocalGraphicsEnvironment): Implemented.\n+\t* java/awt/image/BufferedImage.java:\n+\t(createGraphics): Implemented.\n+\t\t\n+2004-02-24  David Jee  <djee@redhat.com>\n+\n+\t* java/awt/Component.java\n+\t(eventTypeEnabled): Add MOUSE_MOVED and MOUSE_DRAGGED event types.\n+\t* java/awt/Container.java\n+\t(addNotifyContainerChildren): Fix event enabling.\n+\n+2004-02-23  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* Makefile.am: Added \n+\tgnu/java/awt/peer/gtk/GdkGraphicsEnvironment.java\n+\t* Makefile.in: Re-generated.\n+\t* gnu/java/awt/peer/gtk/GdkGraphicsEnvironment.java:\n+\tNew Class. \n+\t\n+2004-02-19  Kim Ho  <kho@redhat.com>\n+\n+\t* Makefile.am: Add BasicProgressBarUI\n+\t* Makefile.in: Regenerate.\n+\t* javax/swing/JProgressBar.java: \n+\tRe-implement.\n+\t* javax/swing/plaf/basic/BasicLookAndFeel.java\n+\tAdd constants for JProgressBar.\n+\t* javax/swing/plaf/basic/BasicProgressBarUI.java\n+\tImplement.\n+\t* javax/swing/plaf/basic/BasicSliderUI.java\n+\tChange comments.\n+\t(calculateGeometry): New method\n+\t(paint): Remove unnecessary size calculations.\n+\n+2004-02-18  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java\n+\t(drawRaster): Fixed small error that caused\n+\timageToUser transformation to be set incorrectly.\n+\t(toString): Implemented.\n+\n+2004-02-18  David Jee  <djee@redhat.com>\n+\n+\t* java/awt/CardLayout.java\n+\t(addLayoutComponent): Show the first component added as the default.\n+\t(removeLayoutComponent): After removing, show the next component.\n+\t(gotoComponent): If there is only one component, show it and return.\n+\n+2004-02-18  Kim Ho  <kho@redhat.com>\n+\n+\t* javax/swing/JSlider.java: Re-order\n+\tmodifiers.\n+\t* javax/swing/JLabel.java: Re-order\n+\tmodifiers.\n+\t* javax/swing/JComponent.java: \n+\t(addPropertyChangeListener):\n+\tImplement.\n+\t(removePropertyChangeListener):\n+\tditto.\n+\t(firePropertyChangeEvent):\n+\tditto.\n+\n+2004-02-17  David Jee  <djee@redhat.com>\n+\n+\t* java/awt/Component.java\n+\t(show): Dispatch ComponentEvent via system event queue.\n+\t(hide): Likewise.\n+\t(move): Likewise.\n+\t(resize): Likewise.\n+\t(reshape): Likewise.\n+\t* java/awt/Window.java\n+\t(setBoundsCallback): Likewise.\n+\n+2004-02-17  David Jee  <djee@redhat.com>\n+\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c\n+\t(Java_gnu_java_awt_peer_gtk_GtkComponentPeer_setNativeBounds):\n+\tUse gtk_widget_set_size_request() instead of the deprecated\n+\tgtk_widget_set_usize().\n+\n+2004-02-17  Kim Ho  <kho@redhat.com>\n+\n+\t* javax/swing/JSlider.java: Fix comments and\n+\tmake property strings constants.\n+\t(createStandardLabels): Use the labels\n+\tpreferred size as bounds.\n+\t* javax/swing/plaf/basic/BasicSliderUI.java\n+\tFix comments.\n+\t(ScrollHandler::actionPerformed): Don't\n+\tcalculate the timer stop value. Let the\n+\tMouseListeners find the stop location.\n+\t(getPreferredHorizontalSize): Re-implement.\n+\t(getPreferredVerticalSize): ditto.\n+\t(getMinimumHorizontalSize): ditto.\n+\t(getMinimumVerticalSize): ditto.\n+\t(getPreferredSize): ditto.\n+\t(getMinimumSize): ditto.\n+\t(getMaximumSize): ditto.\n+\t(paintTicks): Use doubles to find the\n+\ttick location.\n+\t(paintHorizontalLabel):\ufffd Use preferredSize\n+\tas initial width and height.\n+\t(paintVerticalLabel): ditto.\n+\n+2004-02-17  Kim Ho  <kho@redhat.com>\n+\n+\t* javax/swing/JLabel.java: Changed \n+\tproperty strings to constants.\n+\t(DISPLAYED_MNEMONIC_INDEX_CHANGED_PROPERTY):\n+\tNew property.\n+\t(setText): Change mnemonic index if\n+\ttext is too short.\n+\t(setDisplayedMnemonicIndex): Fire property\n+\tchange event.\n+\t(getDisplayedMnemonicIndex): Remove check\n+\tagainst short text.\n+\n+2004-02-17 Olga Rodimina <rodimina@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java:\n+\t(drawImage(img,xform,obs)): Invert xform before\n+\tpassing the xform to cairo.\n+\t(drawImage(img,x,y,bgcolor,obs)): Implemented.\n+\t(drawImage (img,x,y,w,h,bgcolor,obs)): Partly\n+\timplemented.\n+\t(drawImage (img,x,y,w,h,obs)): Implemented.\n+\t(drawImage (img,dx1,dy1,dx2,dy2,sx1,sy1,sx2,sy2,\n+\tbgcolor,obs)): Partly implemented.\n+\t(drawImage (img,dx1,dy1,dx2,dy2,sx1,sy1,sx2,sy2,obs)):\n+\tImplemented.\n+\t* java/awt/image/BufferedImage.java:\n+\t(copyData): if dest is null, create raster with same\n+\tdimensions as the current image.\n+\n+2004-02-16  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* javax/swing/plaf/basic/BasicLabelUI.java \n+\t(getPreferredSize): Use layoutCL.\n+\t* javax/swing/plaf/basic/BasicGraphicsUtils.java \n+\t(getPreferredButtonSize): Start with empty view rect, layout using\n+\tcomponent's preferred alignment.\n+\t* javax/swing/plaf/basic/BasicLookAndFeel.java: Add some Label and\n+\tList defaults.\n+\n+2004-02-16  David Jee  <djee@redhat.com>\n+\n+\t* java/awt/Component.java\n+\t(show): Dispatch COMPONENT_SHOWN ComponentEvent.\n+\t(hide): Dispatch COMPONENT_HIDDEN ComponentEvent.\n+\t(move): Erase old bounds and repaint new bounds. Dispatch\n+\tCOMPONENT_MOVED ComponentEvent.\n+\t(resize): Erase old bounds and repaint new bounds. Dispatch\n+\tCOMPONENT_RESIZED ComponentEvent.\n+\t(reshape): Dispatch COMPONENT_RESIZED and COMPONENT_MOVED\n+\tComponentEvents.\n+\t* java/awt/Window.java\n+\t(setBoundsCallback): Dispatch COMPONENT_RESIZED and COMPONENT_MOVED\n+\tComponentEvents.\n+\n+2004-02-16  Olga Rodimina  <rodimina@redhat.com>\n+\n+\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java:\n+\t(setRenderingHint): Added implementation of \n+\tInterpolation rendering hints.\n+\t(setRenderingHints): Ditto.\n+\t* jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics2D.c:\n+\t(drawPixels): fixed to allow user to choose type \n+\tof filtering that should be used when displaying images.\n+\t(cairoSurfaceSetFilter): New method. Sets filter type for \n+\tinterpolation of pixel values.\n+\n+2004-02-16  David Jee  <djee@redhat.com>\n+\n+\t* java/awt/GridBagLayout.java\n+\t(calcCellSizes): Rows or columns with zero sizes should still be\n+\tconsidered for extra space distribution.\n+\n+2004-02-16  Kim Ho  <kho@redhat.com>\n+\n+\t* javax/swing/JLabel.java: Re-implement.\n+\t* javax/swing/plaf/basic/BasicLabelUI.java\n+\tRe-implement.\n+\t* javax/swing/plaf/basic/BasicLookAndFeel.java:\n+\tAdded constant.\n+\n+2004-02-16\ufffd Kim Ho\ufffd <kho@redhat.com>\n+\n+\t* javax/swing/JSlider.java: Fix indentation and comments.\n+\t(setModel): Remove null check to conform with Sun's.\n+\t(setOrientation): Throw exception if not\n+\tHORIZONTAL or VERTICAL.\n+\t(getInverted): Use private variable instead of \n+\tComponentOrientation.\n+\t(setInverted): ditto.\n+\t* javax/swing/plaf/basic/BasicSliderUI.java:\n+\tFix indentation and comments.\n+\t(propertyChange): Remove check for inverted slider, handle\n+\tin main paint.\n+\t(getMinimumSize): Return preferred size.\n+\t(getMaximumSize): ditto.\n+\t(calculateFocusRect): Don't relocate rectangle.\n+\t(drawInverted): Return XOR of the slider's inversion and \n+\tthe component's orientation.\n+\t(paint): Update leftToRightCache\n+\n+2004-02-13  David Jee  <djee@redhat.com>\n+\n+\t* java/awt/GridBagLayout.java\n+\t(GetLayoutInfo): Fix weight and size distribution. Relocate repeated\n+\tcode to helper methods.\n+\t(sortBySpan): New helper method.\n+\t(distributeSizeAndWeight): Likewise.\n+\t(calcCellWeights): Likewise.\n+\t(calcCellSizes): Add comments.\n+\n+2004-02-13  David Jee  <djee@redhat.com>\n+\n+\t* java/awt/Component.java\n+        (show): Only do something if component is invisible at the moment.\n+        (hide): Only do something if component is visible at the moment.\n+        (reshape): If lightweight, erase old bounds and repaint new bounds.\n+\n+2004-02-13\ufffd Kim Ho\ufffd <kho@redhat.com>\n+\n+\t* Makefile.am: Updated for new file.\n+\t* Makefile.in: Regenerated.\n+\t* javax/swing/JSlider.java: Reimplement.\n+\t* javax/swing/SwingUtilities.java\n+\t(layoutCompoundLabel): Use icon height\n+\tinstead of width.\n+\t(paintComponent): Implement.\n+\t* javax/swing/plaf/basic/BasicLookAndFeel.java:\n+\tAdd JSlider defaults.\n+\t* javax/swing/plaf/basic/BasicSliderUI.java:\n+\tImplement. New file.\n+\n 2004-03-17  Michael Koch  <konqueror@gmx.de>\n \n \t* gnu/java/net/PlainDatagramSocketImpl.java"}, {"sha": "a5bef0a585fa79861b0763d47eb3b95cb30a4dac", "filename": "libjava/Makefile.am", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -227,6 +227,7 @@ gnu/java/awt/peer/gtk/GdkFontMetrics.java \\\n gnu/java/awt/peer/gtk/GdkGlyphVector.java \\\n gnu/java/awt/peer/gtk/GdkGraphics.java \\\n gnu/java/awt/peer/gtk/GdkGraphics2D.java \\\n+gnu/java/awt/peer/gtk/GdkGraphicsEnvironment.java \\\n gnu/java/awt/peer/gtk/GdkPixbufDecoder.java \\\n gnu/java/awt/peer/gtk/GtkArg.java \\\n gnu/java/awt/peer/gtk/GtkArgList.java \\\n@@ -1103,6 +1104,7 @@ java/awt/geom/CubicCurve2D.java \\\n java/awt/geom/FlatteningPathIterator.java \\\n java/awt/geom/GeneralPath.java \\\n java/awt/geom/QuadCurve2D.java \\\n+java/awt/image/AffineTransformOp.java \\\n java/awt/image/BufferedImage.java \\\n java/awt/image/ColorModel.java \\\n java/awt/image/ComponentColorModel.java \\\n@@ -1330,9 +1332,13 @@ javax/swing/plaf/basic/BasicLabelUI.java \\\n javax/swing/plaf/basic/BasicListUI.java \\\n javax/swing/plaf/basic/BasicOptionPaneUI.java \\\n javax/swing/plaf/basic/BasicPanelUI.java \\\n+javax/swing/plaf/basic/BasicProgressBarUI.java \\\n javax/swing/plaf/basic/BasicRootPaneUI.java \\\n javax/swing/plaf/basic/BasicRadioButtonUI.java \\\n+javax/swing/plaf/basic/BasicScrollBarUI.java \\\n javax/swing/plaf/basic/BasicScrollPaneUI.java \\\n+javax/swing/plaf/basic/BasicSeparatorUI.java \\\n+javax/swing/plaf/basic/BasicSliderUI.java \\\n javax/swing/plaf/basic/BasicSplitPaneDivider.java \\\n javax/swing/plaf/basic/BasicSplitPaneUI.java \\\n javax/swing/plaf/basic/BasicTabbedPaneUI.java \\"}, {"sha": "cf0fc0fa3de840ddf075ebe2de56603a343067e4", "filename": "libjava/Makefile.in", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -1,6 +1,6 @@\n-# Makefile.in generated automatically by automake 1.4 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4-p6 from Makefile.am\n \n-# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n+# Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -319,6 +319,7 @@ gnu/java/awt/peer/gtk/GdkFontMetrics.java \\\n gnu/java/awt/peer/gtk/GdkGlyphVector.java \\\n gnu/java/awt/peer/gtk/GdkGraphics.java \\\n gnu/java/awt/peer/gtk/GdkGraphics2D.java \\\n+gnu/java/awt/peer/gtk/GdkGraphicsEnvironment.java \\\n gnu/java/awt/peer/gtk/GdkPixbufDecoder.java \\\n gnu/java/awt/peer/gtk/GtkArg.java \\\n gnu/java/awt/peer/gtk/GtkArgList.java \\\n@@ -785,6 +786,7 @@ java/awt/geom/CubicCurve2D.java \\\n java/awt/geom/FlatteningPathIterator.java \\\n java/awt/geom/GeneralPath.java \\\n java/awt/geom/QuadCurve2D.java \\\n+java/awt/image/AffineTransformOp.java \\\n java/awt/image/BufferedImage.java \\\n java/awt/image/ColorModel.java \\\n java/awt/image/ComponentColorModel.java \\\n@@ -1012,9 +1014,13 @@ javax/swing/plaf/basic/BasicLabelUI.java \\\n javax/swing/plaf/basic/BasicListUI.java \\\n javax/swing/plaf/basic/BasicOptionPaneUI.java \\\n javax/swing/plaf/basic/BasicPanelUI.java \\\n+javax/swing/plaf/basic/BasicProgressBarUI.java \\\n javax/swing/plaf/basic/BasicRootPaneUI.java \\\n javax/swing/plaf/basic/BasicRadioButtonUI.java \\\n+javax/swing/plaf/basic/BasicScrollBarUI.java \\\n javax/swing/plaf/basic/BasicScrollPaneUI.java \\\n+javax/swing/plaf/basic/BasicSeparatorUI.java \\\n+javax/swing/plaf/basic/BasicSliderUI.java \\\n javax/swing/plaf/basic/BasicSplitPaneDivider.java \\\n javax/swing/plaf/basic/BasicSplitPaneUI.java \\\n javax/swing/plaf/basic/BasicTabbedPaneUI.java \\\n@@ -2779,6 +2785,7 @@ lib_gnu_java_awt_peer_gtk_la_DEPENDENCIES =\n @GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GdkGlyphVector.lo \\\n @GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GdkGraphics.lo \\\n @GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GdkGraphics2D.lo \\\n+@GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GdkGraphicsEnvironment.lo \\\n @GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GdkPixbufDecoder.lo \\\n @GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkArg.lo \\\n @GTK_CAIRO_FALSE@gnu/java/awt/peer/gtk/GtkArgList.lo \\\n@@ -2856,6 +2863,7 @@ lib_gnu_java_awt_peer_gtk_la_DEPENDENCIES =\n @GTK_CAIRO_TRUE@gnu/java/awt/peer/gtk/GdkGlyphVector.lo \\\n @GTK_CAIRO_TRUE@gnu/java/awt/peer/gtk/GdkGraphics.lo \\\n @GTK_CAIRO_TRUE@gnu/java/awt/peer/gtk/GdkGraphics2D.lo \\\n+@GTK_CAIRO_TRUE@gnu/java/awt/peer/gtk/GdkGraphicsEnvironment.lo \\\n @GTK_CAIRO_TRUE@gnu/java/awt/peer/gtk/GdkPixbufDecoder.lo \\\n @GTK_CAIRO_TRUE@gnu/java/awt/peer/gtk/GtkArg.lo \\\n @GTK_CAIRO_TRUE@gnu/java/awt/peer/gtk/GtkArgList.lo \\\n@@ -3073,6 +3081,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/java/awt/peer/gtk/GdkGlyphVector.P \\\n .deps/gnu/java/awt/peer/gtk/GdkGraphics.P \\\n .deps/gnu/java/awt/peer/gtk/GdkGraphics2D.P \\\n+.deps/gnu/java/awt/peer/gtk/GdkGraphicsEnvironment.P \\\n .deps/gnu/java/awt/peer/gtk/GdkPixbufDecoder.P \\\n .deps/gnu/java/awt/peer/gtk/GtkArg.P \\\n .deps/gnu/java/awt/peer/gtk/GtkArgList.P \\\n@@ -3562,6 +3571,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/awt/im/spi/InputMethod.P \\\n .deps/java/awt/im/spi/InputMethodContext.P \\\n .deps/java/awt/im/spi/InputMethodDescriptor.P \\\n+.deps/java/awt/image/AffineTransformOp.P \\\n .deps/java/awt/image/AreaAveragingScaleFilter.P \\\n .deps/java/awt/image/BufferStrategy.P \\\n .deps/java/awt/image/BufferedImage.P \\\n@@ -4528,9 +4538,13 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/javax/swing/plaf/basic/BasicLookAndFeel.P \\\n .deps/javax/swing/plaf/basic/BasicOptionPaneUI.P \\\n .deps/javax/swing/plaf/basic/BasicPanelUI.P \\\n+.deps/javax/swing/plaf/basic/BasicProgressBarUI.P \\\n .deps/javax/swing/plaf/basic/BasicRadioButtonUI.P \\\n .deps/javax/swing/plaf/basic/BasicRootPaneUI.P \\\n+.deps/javax/swing/plaf/basic/BasicScrollBarUI.P \\\n .deps/javax/swing/plaf/basic/BasicScrollPaneUI.P \\\n+.deps/javax/swing/plaf/basic/BasicSeparatorUI.P \\\n+.deps/javax/swing/plaf/basic/BasicSliderUI.P \\\n .deps/javax/swing/plaf/basic/BasicSplitPaneDivider.P \\\n .deps/javax/swing/plaf/basic/BasicSplitPaneUI.P \\\n .deps/javax/swing/plaf/basic/BasicTabbedPaneUI.P \\\n@@ -4963,7 +4977,7 @@ maintainer-clean-recursive:\n \tdot_seen=no; \\\n \trev=''; list='$(SUBDIRS)'; for subdir in $$list; do \\\n \t  rev=\"$$subdir $$rev\"; \\\n-\t  test \"$$subdir\" = \".\" && dot_seen=yes; \\\n+\t  test \"$$subdir\" != \".\" || dot_seen=yes; \\\n \tdone; \\\n \ttest \"$$dot_seen\" = \"no\" && rev=\". $$rev\"; \\\n \ttarget=`echo $@ | sed s/-recursive//`; \\\n@@ -5005,7 +5019,7 @@ TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) $(LISP)\n \t  awk '    { files[$$0] = 1; } \\\n \t       END { for (i in files) print i; }'`; \\\n \ttest -z \"$(ETAGS_ARGS)$$unique$(LISP)$$tags\" \\\n-\t  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags  $$unique $(LISP) -o $$here/TAGS)\n+\t  || (cd $(srcdir) && etags -o $$here/TAGS $(ETAGS_ARGS) $$tags  $$unique $(LISP))\n \n mostlyclean-tags:\n "}, {"sha": "9a262ce62d2dba2e1ab26a943adca5a312dbe59b", "filename": "libjava/gcj/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fgcj%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fgcj%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2FMakefile.in?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -1,6 +1,6 @@\n-# Makefile.in generated automatically by automake 1.4 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4-p6 from Makefile.am\n \n-# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n+# Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -260,7 +260,7 @@ TAGS:  $(HEADERS) $(SOURCES) libgcj-config.h.in $(TAGS_DEPENDENCIES) $(LISP)\n \t  awk '    { files[$$0] = 1; } \\\n \t       END { for (i in files) print i; }'`; \\\n \ttest -z \"$(ETAGS_ARGS)libgcj-config.h.in$$unique$(LISP)$$tags\" \\\n-\t  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags libgcj-config.h.in $$unique $(LISP) -o $$here/TAGS)\n+\t  || (cd $(srcdir) && etags -o $$here/TAGS $(ETAGS_ARGS) $$tags libgcj-config.h.in $$unique $(LISP))\n \n mostlyclean-tags:\n "}, {"sha": "d36ac2d5019b1a6860d4b953d5c5ed57296e9c29", "filename": "libjava/gnu/java/awt/peer/gtk/GdkGraphics.java", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -91,7 +91,7 @@ public class GdkGraphics extends Graphics\n     this.component = component;\n     int rgb[] = initState (component);\n     color = new Color (rgb[0], rgb[1], rgb[2]);\n-    font = new Font (\"Dialog\", Font.PLAIN, 10);\n+    font = component.awtComponent.getFont();\n     Dimension d = component.awtComponent.getSize ();\n     clip = new Rectangle (0, 0, d.width, d.height);\n   }\n@@ -212,10 +212,10 @@ native public void fillArc (int x, int y, int width, int height,\n   native public void drawRect(int x, int y, int width, int height);\n   native public void fillRect (int x, int y, int width, int height);\n \n-  native void drawString (String str, int x, int y, String fname, int size);\n+  native void drawString (String str, int x, int y, String fname, int style, int size);\n   public void drawString (String str, int x, int y)\n   {\n-    drawString (str, x, y, font.getName(), font.getSize());\n+    drawString (str, x, y, font.getName(), font.getStyle(), font.getSize());\n   }\n \n   public void drawString (AttributedCharacterIterator ci, int x, int y)\n@@ -287,7 +287,10 @@ public void setClip (Shape clip)\n \n   public void setColor (Color c)\n   {\n-    color = c;\n+    if (c == null)\n+      color = new Color (0, 0, 0);\n+    else\n+      color = c;\n \n     if (xorColor == null) /* paint mode */\n       setFGColor (color.getRed (), color.getGreen (), color.getBlue ());"}, {"sha": "8bae336c4def45aa8df521804425cf62af2dbed0", "filename": "libjava/gnu/java/awt/peer/gtk/GdkGraphics2D.java", "status": "modified", "additions": 305, "deletions": 32, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics2D.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics2D.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics2D.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -84,13 +84,16 @@ public class GdkGraphics2D extends Graphics2D\n   private GtkComponentPeer component;\n   private Font font;  \n   private RenderingHints hints;\n+  private BufferedImage bimage;\n \n   private Stack stateStack;\n   \n   native private int[] initState (GtkComponentPeer component);\n   native private void initState (int width, int height);\n   native private void copyState (GdkGraphics2D g);\n   native public void dispose ();\n+  native private int[] getImagePixels();\n+  native private void cairoSurfaceSetFilter(int filter);\n \n   public void finalize ()\n   {\n@@ -179,6 +182,28 @@ public Graphics create (int x, int y, int width, int height)\n     stateStack = new Stack ();\n   }\n \n+  GdkGraphics2D (BufferedImage bimage)\n+  {\n+    \n+    this.bimage = bimage;    \n+    initState (bimage.getWidth(), bimage.getHeight());\n+\n+    setColor(Color.black);\n+    setBackground (Color.black);\n+    setPaint (getColor());\n+    setFont (new Font(\"SansSerif\", Font.PLAIN, 12));\n+    setTransform (new AffineTransform ());\n+    setStroke (new BasicStroke ());\n+    setRenderingHints (getDefaultHints());\n+\n+    stateStack = new Stack();\n+    \n+    // draw current buffered image to the pixmap associated \n+    // with it.\n+    \n+    drawImage (bimage, new AffineTransform (1,0,0,1,0,0), null);\n+  }\n+\n \n   ////////////////////////////////////\n   ////// Native Drawing Methods //////\n@@ -364,6 +389,58 @@ private Map getDefaultHints()\n     \n   }\n \n+  private void updateBufferedImage()\n+  {\n+    int[] pixels = getImagePixels();\n+    updateImagePixels(pixels);\n+  }\n+\n+  \n+  private boolean isBufferedImageGraphics ()\n+  {\n+\n+    if (bimage != null)\n+      return true;\n+    else\n+      return false;\n+  }\n+    \n+  private void updateImagePixels (int[] pixels)\n+  {\n+\n+    // This function can only be used if \n+    // this graphics object is used to draw into \n+    // buffered image \n+\t\n+    if (! isBufferedImageGraphics ()) \n+      return;\n+\n+    WritableRaster raster = bimage.getRaster();\t\t      \n+    DataBuffer db = raster.getDataBuffer ();\n+\n+    // update pixels in the bufferedImage\n+\n+    if (raster.getSampleModel ().getDataType () == DataBuffer.TYPE_INT \n+        && db instanceof DataBufferInt \n+        && db.getNumBanks () == 1)\n+      {\n+\n+        // single bank, ARGB-ints buffer in sRGB space\n+        DataBufferInt dbi = (DataBufferInt) raster.getDataBuffer ();\n+\n+        for (int i=0; i < pixels.length; i++) \n+          dbi.setElem(i, pixels[i]);\n+\t \t\t\t\n+      }\n+    else \n+      {        \n+        bimage.getRaster().setPixels (0, 0, raster.getWidth (),\n+                                      raster.getHeight (), pixels);\n+      }\n+  }\n+\n+\n+\n   //////////////////////////////////////////////////\n   ////// Implementation of Graphics2D Methods //////\n   //////////////////////////////////////////////////\n@@ -401,6 +478,10 @@ public void draw (Shape s)\n       translate (-0.5,-0.5);\n       \n     stateRestore ();\n+    \n+    if (isBufferedImageGraphics ()) \n+      updateBufferedImage();   \n+\n   }\n \n   public void fill (Shape s)\n@@ -416,6 +497,10 @@ public void fill (Shape s)\n       walkPath (s.getPathIterator (null));\n     cairoFill ();\n     stateRestore ();\n+    \n+   if (isBufferedImageGraphics ()) \n+     updateBufferedImage();   \n+\n   }\n \n   public void clip (Shape s)\n@@ -475,11 +560,21 @@ else if (paint instanceof TexturePaint)\n       {\n         TexturePaint tp = (TexturePaint) paint;\n         BufferedImage img = tp.getImage ();\n-        int pixels[] = img.getRGB(0, 0, img.getWidth (), \n-                                  img.getHeight (), null, \n-                                  0, img.getWidth ());\n-        setTexturePixels (pixels, img.getWidth (), \n-                          img.getHeight (), img.getWidth ());\n+\t \n+        // map the image to the anchor rectangle  \n+\n+        int width = (int) tp.getAnchorRect ().getWidth ();\n+        int height = (int) tp.getAnchorRect ().getHeight ();\n+\t\n+        double scaleX = width / (double) img.getWidth ();\n+        double scaleY = width / (double) img.getHeight ();\n+\t \n+        AffineTransform at = new AffineTransform (scaleX, 0, 0, scaleY, 0, 0);\n+        AffineTransformOp op = new AffineTransformOp (at, getRenderingHints());\n+        BufferedImage texture = op.filter(img, null);\n+        int pixels[] = texture.getRGB (0, 0, width, height, null, 0, width);\n+        setTexturePixels (pixels, width, height, width);\n+\n       }\n     else if (paint instanceof GradientPaint)\n       {\n@@ -518,6 +613,26 @@ public void transform (AffineTransform tx)\n     else\n       transform.concatenate (tx);\n     setTransform (transform);\n+    if (clip != null)\n+      {\n+        // FIXME: this should actuall try to transform the shape\n+        // rather than degrade to bounds.\n+        Rectangle2D r = clip.getBounds2D();\n+        double[] coords = new double[] { r.getX(), r.getY(), \n+                                         r.getX() + r.getWidth(),\n+                                         r.getY() + r.getHeight() };\n+        try \n+          {\n+            tx.createInverse().transform(coords, 0, coords, 0, 2);\n+            r.setRect(coords[0], coords[1],\n+                      coords[2] - coords[0], \n+                      coords[3] - coords[1]);\n+            clip = r;\n+          }\n+        catch (java.awt.geom.NoninvertibleTransformException e)\n+          {\n+          }\n+      }\n   }\n \n   public void rotate(double theta)\n@@ -645,19 +760,29 @@ protected Rectangle2D getClipInDevSpace ()\n \n   public void setClip (int x, int y, int width, int height)\n   {\n-      cairoNewPath ();\n-      cairoRectangle (x, y, width, height);\n-      cairoClosePath ();\n-      cairoClip ();\n-      clip = new Rectangle2D.Double ((double)x, (double)y, \n-\t\t\t\t     (double)width, (double)height);\n+    clip = new Rectangle2D.Double ((double)x, (double)y, \n+                                   (double)width, (double)height);\n+    setClip(clip);\n   }\n-\n+  \n   public void setClip (Shape s)\n   {\n-    clip (s);\n+    if (s != null)\n+      {\n+        cairoNewPath ();\n+        if (s instanceof Rectangle2D)\n+          {\n+            Rectangle2D r = (Rectangle2D)s;\n+            cairoRectangle (r.getX (), r.getY (), \n+                            r.getWidth (), r.getHeight ());\n+          }\n+        else\n+          walkPath (s.getPathIterator (null));\n+        cairoClosePath ();\n+        cairoClip ();\n+      }\n   }\n-\n+  \n   public void draw3DRect(int x, int y, int width, \n                          int height, boolean raised)\n   {\n@@ -708,6 +833,10 @@ public void draw3DRect(int x, int y, int width,\n     cairoStroke ();\n     \n     stateRestore ();    \n+    \n+    if (isBufferedImageGraphics ()) \n+      updateBufferedImage();   \n+\n   }\n \n   public void fill3DRect(int x, int y, int width, \n@@ -734,6 +863,10 @@ public void fill3DRect(int x, int y, int width,\n     cairoClosePath ();\n     cairoFill ();\n     stateRestore ();\n+    \n+    if (isBufferedImageGraphics ()) \n+      updateBufferedImage();   \n+\n   }\n \n \n@@ -759,6 +892,10 @@ public void clearRect (int x, int y, int width, int height)\n     cairoClosePath ();\n     cairoFill ();\n     stateRestore ();\n+       \n+    if (isBufferedImageGraphics ()) \n+      updateBufferedImage();   \n+\n   }\n \n   public void setBackground(Color c)\n@@ -849,7 +986,7 @@ private boolean drawRaster (ColorModel cm, Raster r,\n       {\n         i2u[0] = 1; i2u[1] = 0;\n         i2u[2] = 0; i2u[3] = 1;\n-        i2u[2] = 0; i2u[3] = 0;\n+        i2u[4] = 0; i2u[5] = 0;\n       }\n \n     int pixels[] = null;\n@@ -879,6 +1016,10 @@ private boolean drawRaster (ColorModel cm, Raster r,\n     translate (x, y);\n     drawPixels (pixels, r.getWidth (), r.getHeight (), r.getWidth (), i2u);\n     stateRestore ();    \n+    \n+    if (isBufferedImageGraphics ()) \n+      updateBufferedImage();   \n+\n     return true;\n   }\n \n@@ -908,22 +1049,49 @@ public boolean drawImage(Image img,\n         // we are being asked to flush a double buffer from Gdk\n         GdkGraphics2D g2 = (GdkGraphics2D) img.getGraphics ();\n         gdkDrawDrawable (g2, (int)xform.getTranslateX(), (int)xform.getTranslateY());\n+        \n+        if (isBufferedImageGraphics ()) \n+          updateBufferedImage();   \n+\t \n         return true;\n       }\n     else\n       {\n-        if (img instanceof BufferedImage)\n-          {\n-            // draw an image which has actually been loaded into memory fully\n-            BufferedImage b = (BufferedImage) img;\n-            return drawRaster (b.getColorModel (), b.getData (), xform);\n-          }        \n-        else\n-          {\n-            // begin progressive loading in a separate thread\n-            new PainterThread (this, img, xform);\n-            return false;\n+      \n+        // In this case, xform is an AffineTransform that transforms bounding\n+        // box of the specified image from image space to user space. However\n+        // when we pass this transform to cairo, cairo will use this transform\n+        // to map \"user coordinates\" to \"pixel\" coordinates, which is the \n+        // other way around. Therefore to get the \"user -> pixel\" transform \n+        // that cairo wants from \"image -> user\" transform that we currently\n+        // have, we will need to invert the transformation matrix.\n+\t\n+        AffineTransform invertedXform = new AffineTransform();\n+\n+        try\n+          {             \n+\t      invertedXform = xform.createInverse();\n+             if (img instanceof BufferedImage)\n+               {\n+                   // draw an image which has actually been loaded \n+                   // into memory fully\n+                   BufferedImage b = (BufferedImage) img;\n+                   return drawRaster (b.getColorModel (), \n+                                      b.getData (), \n+                                      invertedXform);\n+               }\n+             else\n+               {\n+                   // begin progressive loading in a separate thread\n+                   new PainterThread (this, img, invertedXform);\n+                   return false;\n+               }\t       \n           }\n+        catch (NoninvertibleTransformException e)\n+          {\n+              throw new ImagingOpException(\"Unable to invert transform \" \n+                                           + xform.toString());\n+          } \t      \n       }\n   }\n \n@@ -1061,6 +1229,28 @@ public void setRenderingHint(RenderingHints.Key hintKey,\n                                Object hintValue)\n   {\n     hints.put (hintKey, hintValue);    \n+    \n+    if (hintKey.equals(RenderingHints.KEY_INTERPOLATION)\n+        || hintKey.equals(RenderingHints.KEY_ALPHA_INTERPOLATION)) \n+      {\n+\t\t\t\n+        if (hintValue.equals(RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR))\n+           cairoSurfaceSetFilter(0);\n+\t   \n+        else if (hintValue.equals(RenderingHints.VALUE_INTERPOLATION_BILINEAR))\n+           cairoSurfaceSetFilter(1); \n+\t   \n+        else if (hintValue.equals(RenderingHints.VALUE_ALPHA_INTERPOLATION_SPEED))\n+           cairoSurfaceSetFilter(2);\n+\t   \n+        else if (hintValue.equals(RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY))\n+           cairoSurfaceSetFilter(3);\n+\t   \n+        else if (hintValue.equals(RenderingHints.VALUE_ALPHA_INTERPOLATION_DEFAULT))\n+           cairoSurfaceSetFilter(4);\n+      \n+      } \n+\n   }\n \n   public Object getRenderingHint(RenderingHints.Key hintKey)\n@@ -1072,6 +1262,27 @@ public void setRenderingHints(Map hints)\n   {\n     this.hints = new RenderingHints (getDefaultHints ());\n     this.hints.add (new RenderingHints (hints));\n+        \n+    if (hints.containsKey(RenderingHints.KEY_INTERPOLATION)) \n+      {\n+         if(hints.containsValue(RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR)) \n+            cairoSurfaceSetFilter(0);\n+\t    \n+         else if(hints.containsValue(RenderingHints.VALUE_INTERPOLATION_BILINEAR)) \n+            cairoSurfaceSetFilter(1);  \n+      }\n+          \n+    if (hints.containsKey(RenderingHints.KEY_ALPHA_INTERPOLATION)) \n+      { \n+         if (hints.containsValue(RenderingHints.VALUE_ALPHA_INTERPOLATION_SPEED)) \n+            cairoSurfaceSetFilter(2);\n+\t    \n+         else if (hints.containsValue(RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY)) \n+            cairoSurfaceSetFilter(3);\n+\t    \n+         else if(hints.containsValue(RenderingHints.VALUE_ALPHA_INTERPOLATION_DEFAULT)) \n+            cairoSurfaceSetFilter(4);\n+      }      \n   }\n \n   public void addRenderingHints(Map hints)\n@@ -1104,6 +1315,10 @@ public void drawGlyphVector (GlyphVector g, float x, float y)\n     int codes[] = g.getGlyphCodes (0, nglyphs, (int []) null);\n     float posns[] = g.getGlyphPositions (0, nglyphs, (float []) null);\n     cairoShowGlyphs (codes, posns);\n+    \n+    if (isBufferedImageGraphics ()) \n+      updateBufferedImage();   \n+\n     stateRestore ();\n   }\n \n@@ -1124,33 +1339,89 @@ public void drawArc (int x, int y, int width, int height,\n   public boolean drawImage (Image img, int x, int y, Color bgcolor, \n                             ImageObserver observer)\n   {\n-    throw new java.lang.UnsupportedOperationException ();\n+    return drawImage (img, x, y, img.getWidth (observer), \n+                      img.getHeight (observer), bgcolor, observer);\n   }\n \n   public boolean drawImage (Image img, int x, int y, int width, int height, \n                             Color bgcolor, ImageObserver observer)\n   {\n-    throw new java.lang.UnsupportedOperationException ();\n+   \n+    // FIXME: change all the transparent pixels in the image to\n+    // bgcolor.\n+\n+    return drawImage (img, x, y, width, height, observer);\n   }\n \n   public boolean drawImage (Image img, int x, int y, int width, int height, \n                             ImageObserver observer)\n   {\n-    throw new java.lang.UnsupportedOperationException ();\n+\n+    double scaleX =  width / (double) img.getWidth (observer);           \n+    double scaleY =  height / (double) img.getHeight (observer);\n+\n+    return drawImage (img, \n+                      new AffineTransform(scaleX, 0f, 0f, scaleY, x, y),\n+                      observer);\n+\n   }\n \n   public boolean drawImage (Image img, int dx1, int dy1, int dx2, int dy2, \n                             int sx1, int sy1, int sx2, int sy2, \n                             Color bgcolor, ImageObserver observer)\n   {\n-    throw new java.lang.UnsupportedOperationException ();\n+  \n+    // FIXME: change all transparent pixels in the image to \n+    // bgcolor\n+       \n+    return drawImage (img, dx1, dy1, dx2, dy2, \n+                      sx1, sy1, sx2, sy2, observer);\t\n   }\n \n   public boolean drawImage (Image img, int dx1, int dy1, int dx2, int dy2, \n                             int sx1, int sy1, int sx2, int sy2, \n                             ImageObserver observer) \n   {\n-    throw new java.lang.UnsupportedOperationException ();\n+  \n+    Image subImage;\t\n+    \n+    int sourceWidth = sx2 - sx1;\n+    int sourceHeight = sy2 - sy1;     \n+    \n+    int destWidth = dx2 - dx1;\n+    int destHeight = dy2 - dy1;\n+    \n+    double scaleX = destWidth / (double) sourceWidth;\n+    double scaleY = destHeight / (double) sourceHeight;\n+\n+    // Get the subimage of the source enclosed in the \n+    // rectangle specified by sx1, sy1, sx2, sy2\n+\t\n+    if (img instanceof BufferedImage)\n+      {\n+\n+        BufferedImage b = (BufferedImage) img;\n+        subImage = b.getSubimage(sx1,sy1,sx2,sy2);  \n+      } \n+    else \n+      {\n+\n+        // FIXME: This code currently doesn't work. Null Pointer \n+        // exception is thrown in this case. This happens \n+        // because img.getSource() always returns null, since source gets \n+        // never initialized when it is created with the help of \n+        // createImage(int width, int height). \n+             \n+\t CropImageFilter filter = new CropImageFilter(sx1,sx2,sx2,sy2);\n+        FilteredImageSource src = new FilteredImageSource(img.getSource(), \n+                                                          filter);\t\n+\t\t\t\t\t\t\t  \t\t\t\t\t\t  \n+        subImage = Toolkit.getDefaultToolkit().createImage(src);\n+      }\n+\n+    return drawImage(subImage, new AffineTransform(scaleX, 0, 0,\n+                                                  scaleY, dx1, dy1), \n+                                                  observer);\n   }\n \n   public void drawOval(int x, int y, int width, int height)\n@@ -1251,7 +1522,9 @@ public void setFont (Font f)\n \n   public String toString()\n   {\n-    throw new java.lang.UnsupportedOperationException ();\n+    return  getClass ().getName () +\n+            \"[font=\" + font.toString () +\n+            \",color=\" + fg.toString () + \"]\";\n   }\n \n }"}, {"sha": "dbcd2d1c4372f359819fba507d93eebbed30dc02", "filename": "libjava/gnu/java/awt/peer/gtk/GdkGraphicsEnvironment.java", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphicsEnvironment.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphicsEnvironment.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphicsEnvironment.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -0,0 +1,87 @@\n+/* GdkGraphicsEnvironment.java -- information about the graphics environment\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.awt.peer.gtk;\n+\n+import java.awt.*;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.image.BufferedImage;\n+import java.util.Locale;\n+\n+\n+public class GdkGraphicsEnvironment extends GraphicsEnvironment\n+{\n+  \n+  public GdkGraphicsEnvironment ()\n+  {\n+  \tsuper();\n+  }\n+\n+  public GraphicsDevice[] getScreenDevices ()\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public GraphicsDevice getDefaultScreenDevice ()\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public Graphics2D createGraphics (BufferedImage image)\n+  {\n+    return new GdkGraphics2D (image);\n+  }\n+\n+  public Font[] getAllFonts ()\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public String[] getAvailableFontFamilyNames ()\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+  public String[] getAvailableFontFamilyNames (Locale l)\n+  {\n+    throw new java.lang.UnsupportedOperationException ();\n+  }\n+\n+\n+} // class GdkGraphicsEnvironment\n+"}, {"sha": "86c7c37e6dfd4aa73b8630cc46b4c247fd98d072", "filename": "libjava/gnu/java/awt/peer/gtk/GtkButtonPeer.java", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkButtonPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkButtonPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkButtonPeer.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -42,6 +42,7 @@\n import java.awt.Button;\n import java.awt.Component;\n import java.awt.Font;\n+import java.awt.Point;\n import java.awt.event.MouseEvent;\n import java.awt.event.KeyEvent;\n import java.awt.peer.ButtonPeer;\n@@ -69,11 +70,15 @@ public void setLabel (String label)\n \n   public void handleEvent (AWTEvent e)\n   {\n-    if (e.getID () == MouseEvent.MOUSE_CLICKED && isEnabled ())\n+    if (e.getID () == MouseEvent.MOUSE_RELEASED && isEnabled ())\n       {\n \tMouseEvent me = (MouseEvent) e;\n+\tPoint p = me.getPoint();\n+\tp.translate(((Component) me.getSource()).getX(),\n+\t            ((Component) me.getSource()).getY());\n \tif (!me.isConsumed ()\n-\t    && (me.getModifiers () & MouseEvent.BUTTON1_MASK) != 0)\n+\t    && (me.getModifiers () & MouseEvent.BUTTON1_MASK) != 0\n+\t    && awtComponent.getBounds().contains(p))\n \t  postActionEvent (((Button)awtComponent).getActionCommand (), \n \t\t\t   me.getModifiers ());\n       }"}, {"sha": "2cff9cc1016493c73767a2ba372f5651fa3d59bd", "filename": "libjava/gnu/java/awt/peer/gtk/GtkCheckboxPeer.java", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkCheckboxPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkCheckboxPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkCheckboxPeer.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -41,6 +41,7 @@\n import java.awt.Checkbox;\n import java.awt.CheckboxGroup;\n import java.awt.Component;\n+import java.awt.Font;\n import java.awt.peer.CheckboxPeer;\n \n public class GtkCheckboxPeer extends GtkComponentPeer\n@@ -55,6 +56,8 @@ public native void nativeCreate (GtkCheckboxGroupPeer group,\n                                    boolean state);\n   public native void nativeSetCheckboxGroup (GtkCheckboxGroupPeer group);\n   public native void connectSignals ();\n+  public native void gtkSetFont (String name, int style, int size);\n+  public native void gtkSetLabel (String label);\n \n   public GtkCheckboxPeer (Checkbox c)\n   {\n@@ -81,7 +84,12 @@ public void setState (boolean state)\n \n   public void setLabel (String label)\n   {\n-    set (\"label\", label);\n+    gtkSetLabel (label);\n+  }\n+\n+  public void setFont (Font f)\n+  {\n+    gtkSetFont(f.getName(), f.getStyle(), f.getSize());\n   }\n \n   public void setCheckboxGroup (CheckboxGroup group)"}, {"sha": "1a9d963b78e5a16649fa70565d997ccbc2083e62", "filename": "libjava/gnu/java/awt/peer/gtk/GtkComponentPeer.java", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkComponentPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkComponentPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkComponentPeer.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -91,6 +91,7 @@ public class GtkComponentPeer extends GtkGenericPeer\n   native void gtkWidgetSetCursor (int type);\n   native void gtkWidgetSetBackground (int red, int green, int blue);\n   native void gtkWidgetSetForeground (int red, int green, int blue);\n+  native void gtkSetFont (String name, int style, int size);\n   native void gtkWidgetQueueDrawArea(int x, int y, int width, int height);\n   native void addExposeFilter();\n   native void removeExposeFilter();\n@@ -234,7 +235,7 @@ public void handleEvent (AWTEvent event)\n               // Some peers like GtkFileDialogPeer are repainted by Gtk itself\n               if (g == null)\n                 break;\n-\n+\t\t\n               g.setClip (((PaintEvent)event).getUpdateRect());\n \n               if (id == PaintEvent.PAINT)\n@@ -403,6 +404,7 @@ public void setFont (Font f)\n     // FIXME: This should really affect the widget tree below me.\n     // Currently this is only handled if the call is made directly on\n     // a text widget, which implements setFont() itself.\n+    gtkSetFont(f.getName(), f.getStyle(), f.getSize());\n   }\n \n   public void setForeground (Color c) "}, {"sha": "32ac02f5abd9b8dc7144b8c1ea2110dadcd704d4", "filename": "libjava/gnu/java/awt/peer/gtk/GtkContainerPeer.java", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkContainerPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkContainerPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkContainerPeer.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -42,6 +42,7 @@\n import java.awt.Color;\n import java.awt.Component;\n import java.awt.Container;\n+import java.awt.Font;\n import java.awt.Graphics;\n import java.awt.Insets;\n import java.awt.event.PaintEvent;\n@@ -92,6 +93,18 @@ public void setBounds (int x, int y, int width, int height)\n     awtComponent.validate ();\n   }\n \n+  public void setFont(Font f)\n+  {\n+    super.setFont(f);\n+    Component[] components = ((Container) awtComponent).getComponents();\n+    for (int i = 0; i < components.length; i++)\n+      {\n+        GtkComponentPeer peer = (GtkComponentPeer) components[i].getPeer();\n+        if (peer != null && ! peer.awtComponent.isFontSet())\n+          peer.setFont(f);\n+      }\n+  }\n+\n   public Graphics getGraphics ()\n   {\n     if (GtkToolkit.useGraphics2D ())"}, {"sha": "1ab7bc13420bee01c41c038c8241ad27d46a65e3", "filename": "libjava/gnu/java/awt/peer/gtk/GtkFontPeer.java", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkFontPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkFontPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkFontPeer.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -62,11 +62,17 @@ public class GtkFontPeer extends ClasspathFontPeer\n       }\n   }\n \n-  final private String Xname; // uses %d for font size.\n+  final private String Xname;\n \n   public GtkFontPeer (String name, int style)\n   {\n-    super(name, style, 12 /* kludge */);\n+    // All fonts get a default size of 12 if size is not specified.\n+    this(name, style, 12);\n+  }\n+\n+  public GtkFontPeer (String name, int style, int size)\n+  {\n+    super(name, style, size);\n \n     if (bundle != null)\n       Xname = bundle.getString (name.toLowerCase () + \".\" + style);\n@@ -90,7 +96,7 @@ public GtkFontPeer (String name, int style)\n \telse\n \t  spacing = \"c\";\n \n-        Xname = \"-*-*-\" + weight + \"-\" + slant + \"-normal-*-%d-*-*-*-\" + spacing + \"-*-*-*\";\n+        Xname = \"-*-*-\" + weight + \"-\" + slant + \"-normal-*-*-\" + size + \"-*-*-\" + spacing + \"-*-*-*\";\n       }\n   }\n "}, {"sha": "cf39372ec2f985d7f956fb709204f6ee86f3ad32", "filename": "libjava/gnu/java/awt/peer/gtk/GtkLabelPeer.java", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkLabelPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkLabelPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkLabelPeer.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -39,28 +39,35 @@\n package gnu.java.awt.peer.gtk;\n \n import java.awt.Component;\n+import java.awt.Font;\n import java.awt.Label;\n import java.awt.peer.LabelPeer;\n \n public class GtkLabelPeer extends GtkComponentPeer\n     implements LabelPeer\n {\n+  native void create (String text, float alignment);\n+  native void gtkSetFont(String name, int style, int size);\n+  native void nativeSetAlignment (float alignment);\n+\n+  native public void setText (String text);\n+\n   void create ()\n   {\n     Label label = (Label) awtComponent;\n     create (label.getText (), getGtkAlignment (label.getAlignment ()));\n   }\n \n-  native void create (String text, float alignment);\n-\n   public GtkLabelPeer (Label l)\n   {\n     super (l);\n   }\n \n-  native public void setText (String text);\n+  public void setFont (Font f)\n+  {\n+    gtkSetFont(f.getName(), f.getStyle(), f.getSize());\n+  }\n \n-  native void nativeSetAlignment (float alignment);\n   public void setAlignment (int alignment)\n   {\n     nativeSetAlignment (getGtkAlignment (alignment));"}, {"sha": "1d961f2d5b79badfb0978b745801c24eb01dbc6a", "filename": "libjava/gnu/java/awt/peer/gtk/GtkToolkit.java", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkToolkit.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkToolkit.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkToolkit.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -47,6 +47,7 @@\n import java.awt.image.ColorModel;\n import java.awt.image.ImageObserver;\n import java.awt.image.ImageProducer;\n+import java.awt.GraphicsEnvironment;\n import java.awt.peer.*;\n import java.net.URL;\n import java.util.Hashtable;\n@@ -366,10 +367,18 @@ public EmbeddedWindowPeer createEmbeddedWindow (EmbeddedWindow w)\n    * @deprecated part of the older \"logical font\" system in earlier AWT\n    * implementations. Our newer Font class uses getClasspathFontPeer.\n    */\n-  protected FontPeer getFontPeer (String name, int style) \n+  protected FontPeer getFontPeer (String name, int style) {\n+    // All fonts get a default size of 12 if size is not specified.\n+    return getFontPeer(name, style, 12);\n+  }\n+\n+  /**\n+   * Private method that allows size to be set at initialization time.\n+   */\n+  private FontPeer getFontPeer (String name, int style, int size) \n   {\n     try {\n-      GtkFontPeer fp = new GtkFontPeer (name, style);\n+      GtkFontPeer fp = new GtkFontPeer (name, style, size);\n       return fp;\n     } catch (MissingResourceException ex) {\n       return null;\n@@ -388,7 +397,11 @@ public ClasspathFontPeer getClasspathFontPeer (String name, Map attrs)\n       return new GdkClasspathFontPeer (name, attrs);\n     else\n       {\n+        // Default values\n+        int size = 12;\n         int style = Font.PLAIN;\n+        if (name == null)\n+          name = \"Default\";\n \n         if (attrs.containsKey (TextAttribute.WEIGHT))\n           {\n@@ -404,7 +417,13 @@ public ClasspathFontPeer getClasspathFontPeer (String name, Map attrs)\n               style += Font.ITALIC;\n           }\n         \n-        return (ClasspathFontPeer) this.getFontPeer (name, style);\n+        if (attrs.containsKey (TextAttribute.SIZE))\n+          {\n+            Float fsize = (Float) attrs.get (TextAttribute.SIZE);\n+            size = fsize.intValue();\n+          }\n+ \n+        return (ClasspathFontPeer) this.getFontPeer (name, style, size);\n       }\n   }\n \n@@ -431,7 +450,9 @@ public Map mapInputMethodHighlight(InputMethodHighlight highlight)\n \n   public GraphicsEnvironment getLocalGraphicsEnvironment()\n   {\n-    throw new java.lang.UnsupportedOperationException ();\n+    GraphicsEnvironment ge;\n+    ge = new GdkGraphicsEnvironment ();  \n+    return ge;\n   }\n \n   public Font createFont(int format, java.io.InputStream stream)"}, {"sha": "e1e0955509a915f5551eee09750612b8b677c1b4", "filename": "libjava/include/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2FMakefile.in?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -1,6 +1,6 @@\n-# Makefile.in generated automatically by automake 1.4 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4-p6 from Makefile.am\n \n-# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n+# Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -241,7 +241,7 @@ TAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) $(LISP)\n \t  awk '    { files[$$0] = 1; } \\\n \t       END { for (i in files) print i; }'`; \\\n \ttest -z \"$(ETAGS_ARGS)config.h.in$$unique$(LISP)$$tags\" \\\n-\t  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags config.h.in $$unique $(LISP) -o $$here/TAGS)\n+\t  || (cd $(srcdir) && etags -o $$here/TAGS $(ETAGS_ARGS) $$tags config.h.in $$unique $(LISP))\n \n mostlyclean-tags:\n "}, {"sha": "38e4de742a00531d86547549f4241805dd2c1849", "filename": "libjava/java/awt/BorderLayout.java", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjava%2Fawt%2FBorderLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjava%2Fawt%2FBorderLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FBorderLayout.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -592,12 +592,13 @@ else if (str.equals(AFTER_LINE_ENDS))\n \n       int x1 = i.left;\n       int x2 = x1 + w.width + hgap;\n-      int x3 = t.width - i.right - e.width;\n+      int x3 = Math.max(x2 + w.width + hgap, t.width - i.right - e.width);\n       int ww = t.width - i.right - i.left;\n \n       int y1 = i.top;\n       int y2 = y1 + n.height + vgap;\n-      int y3 = t.height - i.bottom - s.height;\n+      int midh = Math.max(e.height, Math.max(w.height, c.height));\n+      int y3 = Math.max(y2 + midh + vgap, t.height - i.bottom - s.height);\n       int hh = y3-y2-vgap;\n \n       setBounds(center, x2, y2, x3-x2-hgap, hh);"}, {"sha": "fa4f4ec0fe757e616983afd7dc5941036841bc64", "filename": "libjava/java/awt/CardLayout.java", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjava%2Fawt%2FCardLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjava%2Fawt%2FCardLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FCardLayout.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -103,6 +103,11 @@ public void addLayoutComponent (Component comp, Object constraints)\n   public void addLayoutComponent (String name, Component comp)\n   {\n     tab.put (name, comp);\n+    // First component added is the default component.\n+    if (tab.size() == 1)\n+      comp.setVisible(true);\n+    else\n+      comp.setVisible(false);\n   }\n \n   /** Cause the first component in the container to be displayed.\n@@ -243,6 +248,8 @@ public void removeLayoutComponent (Component comp)\n \tif (tab.get (key) == comp)\n \t  {\n \t    tab.remove (key);\n+\t    Container parent = comp.getParent();\n+\t    next(parent);\n \t    break;\n \t  }\n       }\n@@ -311,6 +318,13 @@ private void gotoComponent (Container parent, int what)\n \tint num = parent.ncomponents;\n \t// This is more efficient than calling getComponents().\n \tComponent[] comps = parent.component;\n+\n+\tif (num == 1)\n+\t  {\n+\t    comps[0].setVisible(true);\n+\t    return;\n+\t  }\n+\n \tint choice = -1;\n \n \tif (what == FIRST)"}, {"sha": "8c75ba06eb28e4c01bb9680689a884d34839cc82", "filename": "libjava/java/awt/Component.java", "status": "modified", "additions": 90, "deletions": 9, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjava%2Fawt%2FComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjava%2Fawt%2FComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FComponent.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -876,10 +876,16 @@ public void show()\n     // case lightweight components are not initially painted --\n     // Container.paint first calls isShowing () before painting itself\n     // and its children.\n-    this.visible = true;\n-    if (peer != null)\n-      peer.setVisible(true);\n-    invalidate();\n+    if(!isVisible())\n+      {\n+        this.visible = true;\n+        if (peer != null)\n+          peer.setVisible(true);\n+        invalidate();\n+        ComponentEvent ce =\n+          new ComponentEvent(this,ComponentEvent.COMPONENT_SHOWN);\n+        getToolkit().getSystemEventQueue().postEvent(ce);\n+      }\n   }\n \n   /**\n@@ -903,10 +909,16 @@ public void show(boolean b)\n    */\n   public void hide()\n   {\n-    if (peer != null)\n-      peer.setVisible(false);\n-    this.visible = false;\n-    invalidate();\n+    if (isVisible())\n+      {\n+        if (peer != null)\n+          peer.setVisible(false);\n+        this.visible = false;\n+        invalidate();\n+        ComponentEvent ce =\n+          new ComponentEvent(this,ComponentEvent.COMPONENT_HIDDEN);\n+        getToolkit().getSystemEventQueue().postEvent(ce);\n+      }\n   }\n \n   /**\n@@ -974,8 +986,11 @@ public Color getBackground()\n    */\n   public void setBackground(Color c)\n   {\n+    // If c is null, inherit from closest ancestor whose bg is set.\n+    if (c == null && parent != null)\n+      c = parent.getBackground();\n     firePropertyChange(\"background\", background, c);\n-    if (peer != null)\n+    if (peer != null && c != null)\n       peer.setBackground(c);\n     background = c;\n   }\n@@ -1022,6 +1037,7 @@ public void setFont(Font f)\n     firePropertyChange(\"font\", font, f);\n     if (peer != null)\n       peer.setFont(f);\n+    invalidate();\n     font = f;\n   }\n \n@@ -1150,13 +1166,30 @@ public void setLocation(int x, int y)\n    */\n   public void move(int x, int y)\n   {\n+    int oldx = this.x;\n+    int oldy = this.y;\n+\n     if (this.x == x && this.y == y)\n       return;\n     invalidate ();\n     this.x = x;\n     this.y = y;\n     if (peer != null)\n       peer.setBounds (x, y, width, height);\n+\n+    // Erase old bounds and repaint new bounds for lightweights.\n+    if (isLightweight() && width != 0 && height !=0)\n+      {\n+        parent.repaint(oldx, oldy, width, height);\n+        repaint();\n+      }\n+\n+    if (oldx != x || oldy != y)\n+      {\n+        ComponentEvent ce = new ComponentEvent(this,\n+                                               ComponentEvent.COMPONENT_MOVED);\n+        getToolkit().getSystemEventQueue().postEvent(ce);\n+      }\n   }\n \n   /**\n@@ -1220,13 +1253,32 @@ public void setSize(int width, int height)\n    */\n   public void resize(int width, int height)\n   {\n+    int oldwidth = this.width;\n+    int oldheight = this.height;\n+\n     if (this.width == width && this.height == height)\n       return;\n     invalidate ();\n     this.width = width;\n     this.height = height;\n     if (peer != null)\n       peer.setBounds (x, y, width, height);\n+\n+    // Erase old bounds and repaint new bounds for lightweights.\n+    if (isLightweight())\n+      {\n+        if (oldwidth != 0 && oldheight != 0 && parent != null)\n+          parent.repaint(x, y, oldwidth, oldheight);\n+        if (width != 0 && height != 0)\n+          repaint();\n+      }\n+\n+    if (oldwidth != width || oldheight != height)\n+      {\n+        ComponentEvent ce =\n+          new ComponentEvent(this, ComponentEvent.COMPONENT_RESIZED);\n+        getToolkit().getSystemEventQueue().postEvent(ce);\n+      }\n   }\n \n   /**\n@@ -1315,6 +1367,11 @@ public void setBounds(int x, int y, int w, int h)\n    */\n   public void reshape(int x, int y, int width, int height)\n   {\n+    int oldx = this.x;\n+    int oldy = this.y;\n+    int oldwidth = this.width;\n+    int oldheight = this.height;\n+\n     if (this.x == x && this.y == y\n         && this.width == width && this.height == height)\n       return;\n@@ -1325,6 +1382,28 @@ public void reshape(int x, int y, int width, int height)\n     this.height = height;\n     if (peer != null)\n       peer.setBounds (x, y, width, height);\n+\n+    // Erase old bounds and repaint new bounds for lightweights.\n+    if (isLightweight())\n+      {\n+        if (oldwidth != 0 && oldheight != 0 && parent != null)\n+          parent.repaint(oldx, oldy, oldwidth, oldheight);\n+        if (width != 0 && height != 0)\n+          repaint();\n+      }\n+\n+    if (oldx != x || oldy != y)\n+      {\n+        ComponentEvent ce = new ComponentEvent(this,\n+                                               ComponentEvent.COMPONENT_MOVED);\n+        getToolkit().getSystemEventQueue().postEvent(ce);\n+      }\n+    if (oldwidth != width || oldheight != height)\n+      {\n+        ComponentEvent ce = new ComponentEvent(this,\n+                                               ComponentEvent.COMPONENT_RESIZED);\n+        getToolkit().getSystemEventQueue().postEvent(ce);\n+      }\n   }\n \n   /**\n@@ -4172,6 +4251,8 @@ boolean eventTypeEnabled (int type)\n       case MouseEvent.MOUSE_EXITED:\n       case MouseEvent.MOUSE_PRESSED:\n       case MouseEvent.MOUSE_RELEASED:\n+      case MouseEvent.MOUSE_MOVED:\n+      case MouseEvent.MOUSE_DRAGGED:\n         return (mouseListener != null\n                 || mouseMotionListener != null\n                 || (eventMask & AWTEvent.MOUSE_EVENT_MASK) != 0);"}, {"sha": "d66655934ac3857bfc20264a2230eef316d3a3d2", "filename": "libjava/java/awt/Container.java", "status": "modified", "additions": 98, "deletions": 46, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjava%2Fawt%2FContainer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjava%2Fawt%2FContainer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FContainer.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -501,6 +501,20 @@ public void validate()\n       }\n   }\n \n+  /**\n+   * Recursively invalidates the container tree.\n+   */\n+  private void invalidateTree()\n+  {\n+    for (int i = 0; i < ncomponents; i++)\n+      {\n+        Component comp = component[i];\n+        comp.invalidate();\n+        if (comp instanceof Container)\n+          ((Container) comp).invalidateTree();\n+      }\n+  }\n+\n   /**\n    * Recursively validates the container tree, recomputing any invalid\n    * layouts.\n@@ -546,7 +560,10 @@ protected void validateTree()\n   public void setFont(Font f)\n   {\n     super.setFont(f);\n-    // FIXME, should invalidate all children with font == null\n+    // FIXME: Although it might make more sense to invalidate only\n+    // those children whose font == null, Sun invalidates all children.\n+    // So we'll do the same.\n+    invalidateTree();\n   }\n \n   /**\n@@ -1234,6 +1251,7 @@ private void visitChild(Graphics gfx, GfxVisitor visitor,\n     Rectangle oldClip = gfx.getClipBounds();\n     if (oldClip == null)\n       oldClip = bounds;\n+\n     Rectangle clip = oldClip.intersection(bounds);\n \n     if (clip.isEmpty()) return;\n@@ -1337,10 +1355,10 @@ private void addNotifyContainerChildren()\n \n                 // If we're not lightweight, and we just got a lightweight\n                 // child, we need a lightweight dispatcher to feed it events.\n-                if (! this.isLightweight() \n-                    && dispatcher == null)\n+                if (! this.isLightweight()) \n                   {\n-                    dispatcher = new LightweightDispatcher (this);\n+                    if (dispatcher == null)\n+                      dispatcher = new LightweightDispatcher (this);\n                     dispatcher.enableEvents (component[i].eventMask);\n                   }\t\n \t  \n@@ -1536,6 +1554,9 @@ class LightweightDispatcher implements Serializable\n   private long eventMask;\n   \n   private transient Component mouseEventTarget;\n+  private transient Component pressedComponent;\n+  private transient Component lastComponentEntered;\n+  private transient int pressCount;\n   \n   LightweightDispatcher(Container c)\n   {\n@@ -1551,79 +1572,91 @@ void acquireComponentForMouseEvent(MouseEvent me)\n   {\n     int x = me.getX ();\n     int y = me.getY ();\n-    Component candidate = mouseEventTarget;\n-    \n-    while(candidate != null)\n-      {\n-        if (candidate.isShowing())\n-          {\n-            // Convert our point to the candidate's parent's space.\n-            Point cp = SwingUtilities.convertPoint(nativeContainer, x, y, candidate);\n-            \n-            // If the event lands inside candidate, we have a hit.\n-            if (candidate.contains(cp.x, cp.y))\n-              {\n-                // If candidate has children, we refine the hit.\n-                if (candidate instanceof Container &&\n-                    ((Container)candidate).getComponentCount() > 0)              \n-                  candidate = SwingUtilities.getDeepestComponentAt(candidate, cp.x, cp.y);\n-                break;\n-              }\n-          }        \n-        // If candidate isn't showing or doesn't contain point, we back out a level.\n-        candidate = candidate.getParent();\n-      }\n-    \n-    if (candidate == null)\n+\n+    // Find the candidate which should receive this event.\n+    Component parent = nativeContainer;\n+    Component candidate = null;\n+    Point p = me.getPoint();\n+    while (candidate == null && parent != null)\n       {\n-        // We either lost, or never had, a candidate; acquire from our native.\n-        candidate = \n-          SwingUtilities.getDeepestComponentAt(nativeContainer, x, y);\n+        candidate =\n+          SwingUtilities.getDeepestComponentAt(parent, p.x, p.y);\n+        if (candidate == null)\n+        {\n+          p = SwingUtilities.convertPoint(parent, p.x, p.y, parent.parent);\n+          parent = parent.parent;\n+        }\n       }\n \n+    // If the only candidate we found was the native container itself,\n+    // don't dispatch any event at all.  We only care about the lightweight\n+    // children here.\n+    if (candidate == nativeContainer)\n+      candidate = null;\n \n     // If our candidate is new, inform the old target we're leaving.\n-    if (mouseEventTarget != null\n-        && mouseEventTarget.isShowing()\n-        && mouseEventTarget != candidate)\n+    if (lastComponentEntered != null\n+        && lastComponentEntered.isShowing()\n+        && lastComponentEntered != candidate)\n       {\n         Point tp = \n           SwingUtilities.convertPoint(nativeContainer, \n-                                      x, y, mouseEventTarget);\n-        MouseEvent exited = new MouseEvent (mouseEventTarget, \n+                                      x, y, lastComponentEntered);\n+        MouseEvent exited = new MouseEvent (lastComponentEntered, \n                                             MouseEvent.MOUSE_EXITED,\n                                             me.getWhen (), \n                                             me.getModifiers (), \n                                             tp.x, tp.y,\n                                             me.getClickCount (),\n                                             me.isPopupTrigger (),\n                                             me.getButton ());\n-        mouseEventTarget.dispatchEvent (exited); \n-        mouseEventTarget = null;\n+        lastComponentEntered.dispatchEvent (exited); \n+        lastComponentEntered = null;\n       }\n \n     // If we have a candidate, maybe enter it.\n     if (candidate != null)\n       {\n+        mouseEventTarget = candidate;\n         if (candidate.isLightweight() \n             && candidate.isShowing()\n             && candidate != nativeContainer\n-            && candidate != mouseEventTarget)\n+            && candidate != lastComponentEntered)\n \t  {\t\t\t\n-            mouseEventTarget = candidate;\n+            lastComponentEntered = mouseEventTarget;\n             Point cp = SwingUtilities.convertPoint(nativeContainer, \n-                                                   x, y, candidate);\n-            MouseEvent entered = new MouseEvent (mouseEventTarget, \n+                                                   x, y, lastComponentEntered);\n+            MouseEvent entered = new MouseEvent (lastComponentEntered, \n                                                  MouseEvent.MOUSE_ENTERED,\n                                                  me.getWhen (), \n                                                  me.getModifiers (), \n                                                  cp.x, cp.y,\n                                                  me.getClickCount (),\n                                                  me.isPopupTrigger (),\n                                                  me.getButton ());\n-            mouseEventTarget.dispatchEvent (entered);\n+            lastComponentEntered.dispatchEvent (entered);\n           }\n       }\n+\n+    if (me.getID() == MouseEvent.MOUSE_RELEASED\n+        || me.getID() == MouseEvent.MOUSE_PRESSED && pressCount > 0\n+        || me.getID() == MouseEvent.MOUSE_DRAGGED)\n+      // If any of the following events occur while a button is held down,\n+      // they should be dispatched to the same component to which the\n+      // original MOUSE_PRESSED event was dispatched:\n+      //   - MOUSE_RELEASED\n+      //   - MOUSE_PRESSED: another button pressed while the first is held down\n+      //   - MOUSE_DRAGGED\n+      mouseEventTarget = pressedComponent;\n+    else if (me.getID() == MouseEvent.MOUSE_CLICKED)\n+      {\n+        // Don't dispatch CLICKED events whose target is not the same as the\n+        // target for the original PRESSED event.\n+        if (candidate != pressedComponent)\n+          mouseEventTarget = null;\n+        else if (pressCount == 0)\n+          pressedComponent = null;\n+      }\n   }\n \n   boolean handleEvent(AWTEvent e)\n@@ -1634,17 +1667,36 @@ boolean handleEvent(AWTEvent e)\n     if (e instanceof MouseEvent)\n       {\n         MouseEvent me = (MouseEvent) e;\n-        acquireComponentForMouseEvent(me);\n \n-        // Avoid dispatching an ENTERED event twice.\n+        acquireComponentForMouseEvent(me);\n+\t\n+        // Avoid dispatching ENTERED and EXITED events twice.\n         if (mouseEventTarget != null\n             && mouseEventTarget.isShowing()\n-            && e.getID() != MouseEvent.MOUSE_ENTERED)\n+            && e.getID() != MouseEvent.MOUSE_ENTERED\n+            && e.getID() != MouseEvent.MOUSE_EXITED)\n           {\n             MouseEvent newEvt = \n               SwingUtilities.convertMouseEvent(nativeContainer, me, \n                                                mouseEventTarget);\n             mouseEventTarget.dispatchEvent(newEvt);\n+\n+            switch (e.getID())\n+              {\n+                case MouseEvent.MOUSE_PRESSED:\n+                  if (pressCount++ == 0)\n+                    pressedComponent = mouseEventTarget;\n+                  break;\n+\n+                case MouseEvent.MOUSE_RELEASED:\n+                  // Clear our memory of the original PRESSED event, only if\n+                  // we're not expecting a CLICKED event after this. If\n+                  // there is a CLICKED event after this, it will do clean up.\n+                  if (--pressCount == 0\n+                      && mouseEventTarget != pressedComponent)\n+                    pressedComponent = null;\n+                  break;\n+              }\n           }\n       }\n     else if (e instanceof KeyEvent && focus != null)"}, {"sha": "42f9f7b85ebe794be304657dd72fcd576a8d3959", "filename": "libjava/java/awt/Font.java", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjava%2Fawt%2FFont.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjava%2Fawt%2FFont.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FFont.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -330,16 +330,20 @@ public Font (String name, int style, int size)\n   }\n \n   public Font (Map attrs)\n-{\n-    this.peer = getPeerFromToolkit (null, attrs);\n-}\n+  {\n+    this(null, attrs);\n+  }\n \n   /* This extra constructor is here to permit ClasspathToolkit and to build\n      a font with a \"logical name\" as well as attrs.  */\n   public Font (String name, Map attrs)\n-{\n+  {\n+    // If attrs is null, setting it to an empty HashMap will give this\n+    // Font default attributes.\n+    if (attrs == null)\n+      attrs = new HashMap();\n     this.peer = getPeerFromToolkit (name, attrs);\n-}\n+  }\n \n /*************************************************************************/\n "}, {"sha": "2b4ce512850a985c19409e9e00ca6c6761200961", "filename": "libjava/java/awt/GraphicsEnvironment.java", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjava%2Fawt%2FGraphicsEnvironment.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjava%2Fawt%2FGraphicsEnvironment.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FGraphicsEnvironment.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -40,6 +40,7 @@\n \n import java.awt.image.BufferedImage;\n import java.util.Locale;\n+import gnu.java.awt.ClasspathToolkit;\n \n /**\n  * This descibes the collection of GraphicsDevice and Font objects available\n@@ -70,7 +71,9 @@ protected GraphicsEnvironment()\n    */\n   public static GraphicsEnvironment getLocalGraphicsEnvironment()\n   {\n-    throw new Error(\"not implemented\");\n+    ClasspathToolkit tk;\n+    tk = ((ClasspathToolkit) Toolkit.getDefaultToolkit ());\n+    return tk.getLocalGraphicsEnvironment ();\n   }\n \n   /**"}, {"sha": "301e71318accd91ad4131c63ef76d7a4055202fd", "filename": "libjava/java/awt/GridBagLayout.java", "status": "modified", "additions": 258, "deletions": 145, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjava%2Fawt%2FGridBagLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjava%2Fawt%2FGridBagLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FGridBagLayout.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -39,6 +39,7 @@\n package java.awt;\n \n import java.io.Serializable;\n+import java.util.ArrayList;\n import java.util.Hashtable;\n import java.util.HashMap;\n \n@@ -468,8 +469,15 @@ protected GridBagLayoutInfo GetLayoutInfo (Container parent, int sizeflag)\n       HashMap lastInRow = new HashMap();\n       HashMap lastInCol = new HashMap();\n \n-      // STEP 1: first we figure out how many rows/columns\n       Component[] components = parent.getComponents();\n+\n+      // Components sorted by gridwidths/heights,\n+      // smallest to largest, with REMAINDER and RELATIVE at the end.\n+      // These are useful when determining sizes and weights.\n+      ArrayList sortedByWidth = new ArrayList(components.length);\n+      ArrayList sortedByHeight = new ArrayList(components.length);\n+\n+      // STEP 1: first we figure out how many rows/columns\n       for (int i = 0; i < components.length; i++)\n \t{\n           Component component = components [i];\n@@ -578,6 +586,9 @@ else if(constraints.gridy == GridBagConstraints.RELATIVE)\n           max_y = Math.max(max_y,\n                            constraints.gridy + Math.max(1, constraints.gridheight));\n \n+          sortBySpan(component, constraints.gridwidth, sortedByWidth, true);\n+          sortBySpan(component, constraints.gridheight, sortedByHeight, false);\n+\n           // Update our reference points for RELATIVE gridx and gridy.\n           if(constraints.gridwidth == GridBagConstraints.REMAINDER)\n \t    {\n@@ -621,10 +632,27 @@ else if (constraints.gridwidth != GridBagConstraints.REMAINDER)\n \t    }\n \t} // end of STEP 1\n \t\n-      boolean[] colIsOccupied = new boolean[max_x];\n-      boolean[] rowIsOccupied = new boolean[max_y];\n+      GridBagLayoutInfo info = new GridBagLayoutInfo(max_x, max_y);\n \n-      // STEP 2: Determine which cells the components occupy.\n+      // Check if column widths and row heights are overridden.\n+\n+      for (int x = 0; x < max_x; x++)\n+        {\n+          if(columnWidths != null && columnWidths.length > x)\n+            info.colWidths[x] = columnWidths[x];\n+          if(columnWeights != null && columnWeights.length > x)\n+            info.colWeights[x] = columnWeights[x];\n+        }\n+\n+      for (int y = 0; y < max_y; y++)\n+        {\n+          if(rowHeights != null && rowHeights.length > y)\n+            info.rowHeights[y] = rowHeights[y];\n+          if(rowWeights != null && rowWeights.length > y)\n+            info.rowWeights[y] = rowWeights[y];\n+        }\n+\n+      // STEP 2: Fix up any cells with width/height as REMAINDER/RELATIVE.\n       for (int i = 0; i < components.length; i++)\n         {\n           Component component = components [i];\n@@ -635,104 +663,87 @@ else if (constraints.gridwidth != GridBagConstraints.REMAINDER)\n \t\t\t\n           GridBagConstraints constraints = lookupInternalConstraints (component);\n \n-          // Fix up any REMAINDER and RELATIVE cells.\n-          if(constraints.gridwidth == GridBagConstraints.REMAINDER)\n+          if(constraints.gridwidth == GridBagConstraints.REMAINDER || constraints.gridwidth == GridBagConstraints.RELATIVE)\n             {\n-              for (int y = constraints.gridy; y < constraints.gridy + Math.max(1, constraints.gridheight); y++)\n+              if(constraints.gridwidth == GridBagConstraints.REMAINDER)\n                 {\n-                  if (lastInRow.containsKey(new Integer(y)))\n+                  for (int y = constraints.gridy; y < constraints.gridy + Math.max(1, constraints.gridheight); y++)\n                     {\n-                      Component lastComponent = (Component) lastInRow.get(new Integer(y));\n-                      GridBagConstraints lastConstraints = lookupInternalConstraints(lastComponent);\n-\n-                      if (lastConstraints.gridwidth == GridBagConstraints.RELATIVE)\n-                        {\n-                          constraints.gridx = max_x - 1;\n-                          break;\n-                        }\n-                      else\n+                      if (lastInRow.containsKey(new Integer(y)))\n                         {\n-                          constraints.gridx = Math.max (constraints.gridx,\n-                                                        lastConstraints.gridx + Math.max (1, lastConstraints.gridwidth));\n+                          Component lastComponent = (Component) lastInRow.get(new Integer(y));\n+                          GridBagConstraints lastConstraints = lookupInternalConstraints(lastComponent);\n+\n+                          if (lastConstraints.gridwidth == GridBagConstraints.RELATIVE)\n+                            {\n+                              constraints.gridx = max_x - 1;\n+                              break;\n+                            }\n+                          else\n+                            {\n+                              constraints.gridx = Math.max (constraints.gridx,\n+                                                            lastConstraints.gridx + Math.max (1, lastConstraints.gridwidth));\n+                            }\n                         }\n                     }\n+                  constraints.gridwidth = max_x - constraints.gridx;\n                 }\n-              constraints.gridwidth = max_x - constraints.gridx;\n-            }\n-          else if (constraints.gridwidth == GridBagConstraints.RELATIVE)\n-            {\n-              constraints.gridwidth = max_x - constraints.gridx - 1;\n+              else if (constraints.gridwidth == GridBagConstraints.RELATIVE)\n+                {\n+                  constraints.gridwidth = max_x - constraints.gridx - 1;\n+                }\n+\n+              // Re-sort\n+              sortedByWidth.remove(sortedByWidth.indexOf(component));\n+              sortBySpan(component, constraints.gridwidth, sortedByWidth, true);\n             }\n \n-          if(constraints.gridheight == GridBagConstraints.REMAINDER)\n+          if(constraints.gridheight == GridBagConstraints.REMAINDER || constraints.gridheight == GridBagConstraints.RELATIVE)\n             {\n-              for (int x = constraints.gridx; x < constraints.gridx + Math.max(1, constraints.gridwidth); x++)\n+              if(constraints.gridheight == GridBagConstraints.REMAINDER)\n                 {\n-                  if (lastInCol.containsKey(new Integer(x)))\n+                  for (int x = constraints.gridx; x < constraints.gridx + Math.max(1, constraints.gridwidth); x++)\n                     {\n-                      Component lastComponent = (Component) lastInRow.get(new Integer(x));\n-                      GridBagConstraints lastConstraints = lookupInternalConstraints(lastComponent);\n-\n-                      if (lastConstraints.gridheight == GridBagConstraints.RELATIVE)\n+                      if (lastInCol.containsKey(new Integer(x)))\n                         {\n-                          constraints.gridy = max_y - 1;\n-                          break;\n-                        }\n-                      else\n-                        {\n-                          constraints.gridy = Math.max (constraints.gridy,\n-                                                        lastConstraints.gridy + Math.max (1, lastConstraints.gridheight));\n+                          Component lastComponent = (Component) lastInRow.get(new Integer(x));\n+                          GridBagConstraints lastConstraints = lookupInternalConstraints(lastComponent);\n+\n+                          if (lastConstraints.gridheight == GridBagConstraints.RELATIVE)\n+                            {\n+                              constraints.gridy = max_y - 1;\n+                              break;\n+                            }\n+                          else\n+                            {\n+                              constraints.gridy = Math.max (constraints.gridy,\n+                                                            lastConstraints.gridy + Math.max (1, lastConstraints.gridheight));\n+                            }\n                         }\n                     }\n+                  constraints.gridheight = max_y - constraints.gridy;\n+                }\n+              else if (constraints.gridheight == GridBagConstraints.RELATIVE)\n+                {\n+                  constraints.gridheight = max_y - constraints.gridy - 1;\n                 }\n-              constraints.gridheight = max_y - constraints.gridy;\n-            }\n-          else if (constraints.gridheight == GridBagConstraints.RELATIVE)\n-            {\n-              constraints.gridheight = max_y - constraints.gridy - 1;\n-            }\n \n-          // For now, a row or a column is \"occupied\" iff a component\n-          // both begins and ends in that row or column.\n-          if (constraints.gridwidth == 1)\n-            colIsOccupied[constraints.gridx] = true;\n-          if (constraints.gridheight == 1)\n-            rowIsOccupied[constraints.gridy] = true;\n+              // Re-sort\n+              sortedByHeight.remove(sortedByHeight.indexOf(component));\n+              sortBySpan(component, constraints.gridheight, sortedByHeight, false);\n+            }\n         } // end of STEP 2\n \n-      GridBagLayoutInfo info = new GridBagLayoutInfo(max_x, max_y);\n-\n-      // Check if column widths and row heights are overridden.\n-\n-      for (int x = 0; x < max_x; x++)\n-        {\n-          if(columnWidths != null && columnWidths.length > x)\n-            info.colWidths[x] = columnWidths[x];\n-          if(columnWeights != null && columnWeights.length > x)\n-            info.colWeights[x] = columnWeights[x];\n-        }\n-\n-      for (int y = 0; y < max_y; y++)\n+      // STEP 3: Determine sizes and weights for columns.\n+      for (int i = 0; i < sortedByWidth.size(); i++)\n         {\n-          if(rowHeights != null && rowHeights.length > y)\n-            info.rowHeights[y] = rowHeights[y];\n-          if(rowWeights != null && rowWeights.length > y)\n-            info.rowWeights[y] = rowWeights[y];\n-        }\n-\n-      // STEP 3: Distribute the weights and min sizes among rows/columns.\n-      for (int i = 0; i < components.length; i++)\n-        {\n-          Component component = components [i];\n+          Component component = (Component) sortedByWidth.get(i);\n \t\t\t\n           // If component is not visible we dont have to care about it.\n           if (!component.isVisible())\n             continue;\n \n           GridBagConstraints constraints = lookupInternalConstraints (component);\n-          GridBagConstraints originalConstraints = lookupConstraints (component);\n-\n-          // Distribute the width.\n \n           int width = (sizeflag == PREFERREDSIZE) ?\n                       component.getPreferredSize().width :\n@@ -743,35 +754,24 @@ else if (constraints.gridheight == GridBagConstraints.RELATIVE)\n \n           width += constraints.ipadx;\n \n-          int occupiedCols = constraints.gridwidth;\n-          int lastOccupiedCol = -1;\n-\n-          for(int w = constraints.gridx; w < constraints.gridx + constraints.gridwidth; w++)\n-            {\n-              if(colIsOccupied[w])\n-                lastOccupiedCol = w;\n-              else\n-                occupiedCols--;\n-            }\n-\n-          // A component needs to occupy at least one column.\n-          if(occupiedCols == 0)\n-            {\n-              colIsOccupied[constraints.gridx + constraints.gridwidth - 1] = true;\n-              lastOccupiedCol = constraints.gridx + constraints.gridwidth - 1;\n-            }\n-\n-          for(int w = constraints.gridx; w < constraints.gridx + constraints.gridwidth - 1; w++)\n-            {\n-              if(colIsOccupied[w])\n-                width -= info.colWidths[w];\n-            }\n-\n-          info.colWidths[lastOccupiedCol] = Math.max(info.colWidths[lastOccupiedCol], width);\n-          info.colWeights[lastOccupiedCol] = Math.max(info.colWeights[lastOccupiedCol], constraints.weightx);\n+          distributeSizeAndWeight(width,\n+                                  constraints.weightx, \n+                                  constraints.gridx,\n+                                  constraints.gridwidth,\n+                                  info.colWidths,\n+                                  info.colWeights);\n+        } // end of STEP 3\n \n+      // STEP 4: Determine sizes and weights for rows.\n+      for (int i = 0; i < sortedByHeight.size(); i++)\n+        {\n+          Component component = (Component) sortedByHeight.get(i);\n+\t\t\t\n+          // If component is not visible we dont have to care about it.\n+          if (!component.isVisible())\n+            continue;\n \n-          // Distribute the height.\n+          GridBagConstraints constraints = lookupInternalConstraints (component);\n \n           int height = (sizeflag == PREFERREDSIZE) ?\n                        component.getPreferredSize().height :\n@@ -782,34 +782,13 @@ else if (constraints.gridheight == GridBagConstraints.RELATIVE)\n \n           height += constraints.ipady;\n \n-          int occupiedRows = constraints.gridheight;\n-          int lastOccupiedRow = -1;\n-\n-          for(int h = constraints.gridy; h < constraints.gridy + constraints.gridheight; h++)\n-            {\n-              if(rowIsOccupied[h])\n-                lastOccupiedRow = h;\n-              else\n-                occupiedRows--;\n-            }\n-\n-          // A component needs to occupy at least one row.\n-          if(occupiedRows == 0)\n-            {\n-              rowIsOccupied[constraints.gridy + constraints.gridheight - 1] = true;\n-              lastOccupiedRow = constraints.gridy + constraints.gridheight - 1;\n-            }\n-\n-          for(int h = constraints.gridy; h < constraints.gridy + constraints.gridheight; h++)\n-            {\n-              if(rowIsOccupied[h])\n-                height -= info.rowHeights[h];\n-            }\n-\n-          info.rowHeights[lastOccupiedRow] = Math.max(info.rowHeights[lastOccupiedRow], height);\n-          info.rowWeights[lastOccupiedRow] = Math.max(info.rowWeights[lastOccupiedRow], constraints.weighty);\n-\n-        } // end of STEP 3\n+          distributeSizeAndWeight(height,\n+                                  constraints.weighty, \n+                                  constraints.gridy,\n+                                  constraints.gridheight,\n+                                  info.rowHeights,\n+                                  info.rowWeights);\n+        } // end of STEP 4\n \n       calcCellSizes (info.colWidths, info.colWeights, parentDim.width);\n       calcCellSizes (info.rowHeights, info.rowWeights, parentDim.height);\n@@ -847,17 +826,155 @@ protected Dimension getMinSize (Container parent, GridBagLayoutInfo info)\n       return GetMinSize (parent, info);\n     }\n \n-    private void calcCellSizes (int[] sizes, double[] weights, int range)\n+    /**\n+     * Helper method used by GetLayoutInfo to keep components sorted, either\n+     * by gridwidth or gridheight.\n+     *\n+     * @param component   Component to add to the sorted list.\n+     * @param span        Either the component's gridwidth or gridheight.\n+     * @param list        <code>ArrayList</code> of components, sorted by\n+     *                    their span.\n+     * @param sortByWidth Flag indicating sorting index. If true, sort by\n+     *                    width. Otherwise, sort by height.\n+     * FIXME: Use a better sorting algorithm.\n+     */\n+    private void sortBySpan (Component component, int span, ArrayList list, boolean sortByWidth)\n     {\n-      int totalSize = sumIntArray (sizes);\n-      double totalWeight = sumDoubleArray (weights);\n+      if (span == GridBagConstraints.REMAINDER\n+          || span == GridBagConstraints.RELATIVE)\n+        {\n+          // Put all RELATIVE and REMAINDER components at the end.\n+          list.add(component);\n+        }\n+      else\n+        {\n+          int i = 0;\n+          if (list.size() > 0)\n+            {\n+              GridBagConstraints gbc = lookupInternalConstraints((Component) list.get(i));\n+              int otherspan = sortByWidth ?\n+                              gbc.gridwidth :\n+                              gbc.gridheight;\n+              while (otherspan != GridBagConstraints.REMAINDER\n+                     && otherspan != GridBagConstraints.RELATIVE\n+                     && span >= otherspan)\n+                {\n+                  i++;\n+                  if (i < list.size())\n+                    {\n+                      gbc = lookupInternalConstraints((Component) list.get(i));\n+                      otherspan = sortByWidth ?\n+                                  gbc.gridwidth :\n+                                  gbc.gridheight;\n+                    }\n+                  else\n+                    break;\n+                }\n+            }\n+          list.add(i, component);\n+        }\n+    }\n \n-      // Rows or columns with size 0 should not be weighted in the calculation.\n-      for (int i = 0; i < weights.length; i++)\n+    /**\n+     * Helper method used by GetLayoutInfo to distribute a component's size\n+     * and weight.\n+     *\n+     * @param size    Preferred size of component, with inset and padding\n+     *                already added.\n+     * @param weight  Weight of component.\n+     * @param start   Starting position of component. Either\n+     *                constraints.gridx or gridy.\n+     * @param span    Span of component. either contraints.gridwidth or\n+     *                gridheight.\n+     * @param sizes   Sizes of rows or columns.\n+     * @param weights Weights of rows or columns.\n+     */\n+    private void distributeSizeAndWeight (int size, double weight,\n+                                          int start, int span,\n+                                          int[] sizes, double[] weights)\n+    {\n+      if (span == 1)\n+        {\n+          sizes[start] = Math.max(sizes[start], size);\n+          weights[start] = Math.max(weights[start], weight);\n+        }\n+      else\n+        {\n+          int numOccupied = span;\n+          int lastOccupied = -1;\n+\n+          for(int i = start; i < start + span; i++)\n+            {\n+              if (sizes[i] == 0.0)\n+                numOccupied--;\n+              else\n+                {\n+                  size -= sizes[i];\n+                  lastOccupied = i;\n+                }\n+            }\n+\n+          // A component needs to occupy at least one row.\n+          if(numOccupied == 0)\n+            sizes[start + span - 1] = size;\n+          else if (size > 0)\n+            sizes[lastOccupied] += size;\n+\n+          calcCellWeights(weight, weights, start, span);\n+        }\n+    }\n+\n+    /**\n+     * Helper method used by GetLayoutInfo to calculate weight distribution.\n+     * @param weight  Weight of component.\n+     * @param weights Weights of rows/columns.\n+     * @param start   Starting position of component in grid (gridx/gridy).\n+     * @param span    Span of component (gridwidth/gridheight).\n+     */\n+    private void calcCellWeights (double weight, double[] weights, int start, int span)\n+    {\n+      double totalWeight = 0.0;\n+      for(int k = start; k < start + span; k++)\n+        totalWeight += weights[k];\n+\n+      if(weight > totalWeight)\n         {\n-          if (sizes[i] == 0)\n-            totalWeight -= weights[i];\n+          if (totalWeight == 0.0)\n+            {\n+              weights[start + span - 1] += weight;\n+            }\n+          else\n+            {\n+              double diff = weight - totalWeight ;\n+              double remaining = diff;\n+\n+              for(int k = start; k < start + span; k++)\n+                {\n+                  double extraWeight = diff * weights[k] / totalWeight;\n+                  weights[k] += extraWeight;\n+                  remaining -= extraWeight;\n+                } \n+\n+              if (remaining > 0.0 && weights[start + span - 1] != 0.0)\n+                {\n+                  weights[start + span - 1] += remaining;\n+                }\n+            }\n         }\n+    }\n+\n+    /**\n+     * Helper method used by GetLayoutInfo to distribute extra space\n+     * based on weight distribution.\n+     *\n+     * @param sizes   Sizes of rows/columns.\n+     * @param weights Weights of rows/columns.\n+     * @param range   Dimension of container.\n+     */\n+    private void calcCellSizes (int[] sizes, double[] weights, int range)\n+    {\n+      int totalSize = sumIntArray (sizes);\n+      double totalWeight = sumDoubleArray (weights);\n \n       int diff = range - totalSize;\n \n@@ -866,14 +983,10 @@ private void calcCellSizes (int[] sizes, double[] weights, int range)\n \n       for (int i = 0; i < sizes.length; i++)\n         {\n-          // A row or column with zero size cannot all of a sudden gain size.\n-          if (sizes[i] != 0.0)\n-            {\n-              int newsize = (int) (sizes[i] + (((double) diff) * weights [i] / totalWeight ));\n+          int newsize = (int) (sizes[i] + (((double) diff) * weights [i] / totalWeight ));\n \n-              if (newsize > 0)\n-                sizes[i] = newsize;\n-            }\n+          if (newsize > 0)\n+            sizes[i] = newsize;\n         }\n     }\n "}, {"sha": "81e37fc7d06145a2c2f21053a81258e880d1171c", "filename": "libjava/java/awt/Window.java", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjava%2Fawt%2FWindow.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjava%2Fawt%2FWindow.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FWindow.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -38,6 +38,7 @@\n \n package java.awt;\n \n+import java.awt.event.ComponentEvent;\n import java.awt.event.WindowEvent;\n import java.awt.event.WindowFocusListener;\n import java.awt.event.WindowListener;\n@@ -784,9 +785,23 @@ void setBoundsCallback (int x, int y, int w, int h)\n     if (this.x == x && this.y == y && width == w && height == h)\n       return;\n     invalidate();\n+    boolean resized = width != w || height != h;\n+    boolean moved = this.x != x || this.y != y;\n     this.x = x;\n     this.y = y;\n     width = w;\n     height = h;\n+    if (resized)\n+      {\n+        ComponentEvent ce =\n+          new ComponentEvent(this, ComponentEvent.COMPONENT_RESIZED);\n+        getToolkit().getSystemEventQueue().postEvent(ce);\n+      }\n+    if (moved)\n+      {\n+        ComponentEvent ce =\n+          new ComponentEvent(this, ComponentEvent.COMPONENT_MOVED);\n+        getToolkit().getSystemEventQueue().postEvent(ce);\n+      }\n   }\n }"}, {"sha": "ca662131e90e8683a8f12943a085e428f8a15011", "filename": "libjava/java/awt/image/AffineTransformOp.java", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjava%2Fawt%2Fimage%2FAffineTransformOp.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjava%2Fawt%2Fimage%2FAffineTransformOp.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FAffineTransformOp.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -0,0 +1,278 @@\n+/* AffineTransformOp.java --  This class performs affine \n+ * transformation between two images or rasters in 2 \n+ * dimensions. Copyright (C) 2004 Free Software Foundation\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.awt.image;\n+\n+import java.awt.*;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.geom.*;\n+\n+\n+/**\n+ * This class performs affine transformation between two images or \n+ * rasters in 2 dimensions. \n+ *\n+ * @author Olga Rodimina <rodimina@redhat.com> \n+ */\n+ \n+public class AffineTransformOp implements BufferedImageOp, RasterOp\n+{\n+\n+    public static final int TYPE_BILINEAR = 0;\n+    public static final int TYPE_NEAREST_NEIGHBOR = 1;\n+\n+    private AffineTransform transform;\n+    private RenderingHints hints;\n+\n+    \n+    /**\n+     * Construct AffineTransformOp with the given xform and interpolationType.\n+     * Interpolation type can be either TYPE_BILINEAR or TYPE_NEAREST_NEIGHBOR.\n+     *\n+     * @param xform AffineTransform that will applied to the source image \n+     * @param interpolationType type of interpolation used\n+     */\n+\n+    AffineTransformOp (AffineTransform xform, int interpolationType)\n+    {\n+      this.transform = xform;\n+\n+      if (interpolationType == 0) \n+        hints = new RenderingHints (RenderingHints.KEY_INTERPOLATION, \n+                                    RenderingHints.VALUE_INTERPOLATION_BILINEAR);\n+\t\t\t\t   \n+      else\n+        hints = new RenderingHints (RenderingHints.KEY_INTERPOLATION,\n+                                    RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);\n+\n+    }\n+\n+    /**\n+     * Construct AffineTransformOp with the given xform and rendering hints.\n+     * \n+     * @param xform AffineTransform that will applied to the source image\n+     * @param hints rendering hints that will be used during transformation\n+     */\n+\n+    AffineTransformOp (AffineTransform xform, RenderingHints hints)\n+    {\n+      this.transform = xform;\n+      this.hints = hints;\n+    }\n+\n+    /**\n+     * Creates empty BufferedImage with the size equal to that of the \n+     * transformed image and correct number of bands. The newly created \n+     * image is created with the specified ColorModel. \n+     * If the ColorModel is equal to null, then image is created \n+     * with the ColorModel of the source image.\n+     *\n+     * @param src source image\n+     * @param destCM color model for the destination image\n+     * @return new compatible destination image\n+     */\n+\n+    public BufferedImage createCompatibleDestImage (BufferedImage src,\n+                                                    ColorModel destCM)\n+    {\n+\n+      // if destCm is not specified, use color model of the source image\n+\n+      if (destCM == null) \n+        destCM = src.getColorModel ();\n+\n+      return new BufferedImage (destCM, \n+                                createCompatibleDestRaster (src.getRaster ()),\n+                                src.isAlphaPremultiplied (),\n+                                null);\t\t             \n+\n+    }\n+\n+    /**\n+     * Creates empty WritableRaster with the size equal to the transformed \n+     * source raster and correct number of bands \n+     *\n+     * @param src source raster\n+     * @throws RasterFormatException if resulting width or height of raster is 0\n+     * @return new compatible raster\n+     */\n+\n+    public WritableRaster createCompatibleDestRaster (Raster src)\n+    {\n+      Rectangle rect = (Rectangle) getBounds2D (src);\n+      \n+      // throw RasterFormatException if resulting width or height of the\n+      // transformed raster is 0\n+\n+      if (rect.getWidth () == 0 || rect.getHeight () == 0) \n+        throw new RasterFormatException(\"width or height is 0\");\n+\n+      return src.createCompatibleWritableRaster ((int) rect.getWidth (), \n+                                                (int) rect.getHeight ());\n+    }\n+\n+    /**\n+     * Transforms source image using transform specified at the constructor.\n+     * The resulting transformed image is stored in the destination image. \n+     *\n+     * @param src source image\n+     * @param dst destination image\n+     * @return transformed source image\n+     */\n+\n+    public BufferedImage filter (BufferedImage src, BufferedImage dst)\n+    {\n+\n+      if (dst == src)\n+        throw new IllegalArgumentException (\"src image cannot be the same as the dst image\");\n+\n+      // If the destination image is null, then BufferedImage is \n+      // created with ColorModel of the source image\n+\n+      if (dst == null)\n+        dst = createCompatibleDestImage(src, src.getColorModel ());\n+\n+      // FIXME: Must check if color models of src and dst images are the same.\n+      // If it is not, then source image should be converted to color model\n+      // of the destination image\n+\n+      Graphics2D gr = (Graphics2D) dst.createGraphics ();\n+      gr.setRenderingHints (hints);\t\n+      gr.drawImage (src, transform, null);\n+      return dst;\n+\n+    }\n+\n+    /**\n+     * Transforms source raster using transform specified at the constructor.\n+     * The resulting raster is stored in the destination raster.\n+     *\n+     * @param src source raster\n+     * @param dst destination raster\n+     * @return transformed raster\n+     */\n+\n+    public WritableRaster filter (Raster src, WritableRaster dst)\n+    {\n+      throw new UnsupportedOperationException (\"not implemented yet\");\t\n+    }\n+\n+    /**\n+     * Transforms source image using transform specified at the constructor and \n+     * returns bounds of the transformed image.\n+     *\n+     * @param src image to be transformed\n+     * @return bounds of the transformed image.\n+     */\n+\n+    public Rectangle2D getBounds2D (BufferedImage src)\n+    {\n+      return getBounds2D (src.getRaster());\n+    }\n+   \n+    /**\n+     * Returns bounds of the transformed raster.\n+     *\n+     * @param src raster to be transformed\n+     * @return bounds of the transformed raster.\n+     */\n+\n+    public Rectangle2D getBounds2D (Raster src)\n+    {\n+      // determine new size for the transformed raster.\n+      // Need to calculate transformed coordinates of the lower right\n+      // corner of the raster. The upper left corner is always (0,0)\n+              \n+      double x2 = (double) src.getWidth () + src.getMinX ();\n+      double y2 = (double) src.getHeight () + src.getMinY ();\n+      Point2D p2 = getPoint2D (new Point2D.Double (x2,y2), null);\n+\n+      Rectangle2D rect = new Rectangle (0, 0, (int) p2.getX (), (int) p2.getY ());\n+      return rect.getBounds ();\n+    }\n+\n+    /**\n+     * Returns interpolation type used during transformations\n+     *\n+     * @return interpolation type\n+     */\n+\n+    public int getInterpolationType ()\n+    {\n+      if(hints.containsValue (RenderingHints.VALUE_INTERPOLATION_BILINEAR))\n+        return TYPE_BILINEAR;\n+      else \n+        return TYPE_NEAREST_NEIGHBOR;\n+    }\n+\n+    /** \n+     * Returns location of the transformed source point. The resulting point \n+     * is stored in the dstPt if one is specified.\n+     *  \n+     * @param srcPt point to be transformed\n+     * @param dstPt destination point\n+     * @return the location of the transformed source point.\n+     */\n+     \n+    public Point2D getPoint2D (Point2D srcPt, Point2D dstPt)\n+    {\n+      return transform.transform (srcPt, dstPt);\n+    }\n+\n+    /** Returns rendering hints that are used during transformation.\n+     *\n+     * @return rendering hints\n+     */\n+\n+    public RenderingHints getRenderingHints ()\n+    {\n+      return hints;\n+    }\n+\n+    /** Returns transform used in transformation between source and destination\n+     * image.\n+     *\n+     * @return transform\n+     */\n+     \n+    public AffineTransform getTransform ()\n+    {\n+      return transform;\n+    }\n+}"}, {"sha": "547301da8d8ec9e447b8a66762feabc402d43bb1", "filename": "libjava/java/awt/image/BufferedImage.java", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjava%2Fawt%2Fimage%2FBufferedImage.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjava%2Fawt%2Fimage%2FBufferedImage.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FBufferedImage.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -39,6 +39,7 @@\n \n import java.awt.Graphics;\n import java.awt.Graphics2D;\n+import java.awt.GraphicsEnvironment;\n import java.awt.Image;\n import java.awt.Point;\n import java.awt.Rectangle;\n@@ -255,7 +256,8 @@ public void coerceData(boolean premultiplied)\n   public WritableRaster copyData(WritableRaster dest)\n   {\n     if (dest == null)\n-      dest = raster.createCompatibleWritableRaster();\n+      dest = raster.createCompatibleWritableRaster(getMinX(), getMinY(),\n+                                                   getWidth(),getHeight());\n \n     int x = dest.getMinX();\n     int y = dest.getMinY();\n@@ -282,8 +284,9 @@ public WritableRaster copyData(WritableRaster dest)\n \n   public Graphics2D createGraphics()\n   {\n-    throw new UnsupportedOperationException(\"not implemented\");\n-    // will require a lot of effort to implement\n+    GraphicsEnvironment env;\n+    env = GraphicsEnvironment.getLocalGraphicsEnvironment ();\n+    return env.createGraphics (this);\n   }\n \n   public void flush() {"}, {"sha": "4a5c14bed08671cdee675b10676f7318d6dc3927", "filename": "libjava/javax/swing/AbstractListModel.java", "status": "modified", "additions": 80, "deletions": 57, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FAbstractListModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FAbstractListModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FAbstractListModel.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -40,57 +40,64 @@\n import java.io.Serializable;\n import java.util.EventListener;\n import javax.swing.event.EventListenerList;\n-import javax.swing.event.ListDataListener;\n import javax.swing.event.ListDataEvent;\n+import javax.swing.event.ListDataListener;\n+\n \n /**\n  * AbstractListModel\n- * A2uthor\tRonald Veldema\n- * @author\tAndrew Selkirk\n- * @version\t1.0\n+ *\n+ * @author Ronald Veldema\n+ * @author Andrew Selkirk\n+ * @version 1.0\n  */\n-public abstract class AbstractListModel\n-  implements ListModel, Serializable\n+public abstract class AbstractListModel implements ListModel, Serializable\n {\n   static final long serialVersionUID = -3285184064379168730L;\n \n-  /**\n-   * listenerList\n-   */\n-  protected EventListenerList listenerList = new EventListenerList ();\n-  \n-  /**\n-   * Constructor AbstractListModel\n-   */\n-  public AbstractListModel ()\n+  /** List of ListDataListeners called for each change to the list. */\n+  protected EventListenerList listenerList;\n+\n+  public AbstractListModel()\n   {\n+    listenerList = new EventListenerList();\n   }\n \n   /**\n-   * addListDataListener\n-   * @param listener TODO\n+   * Add a listener object to this model. The listener will be called\n+   * any time the set of elements in the model is changed.\n+   *\n+   * @param listener The listener to add\n    */\n-  public void addListDataListener(ListDataListener listener) \n+  public void addListDataListener(ListDataListener listener)\n   {\n-    listenerList.add (ListDataListener.class, listener);\n+    listenerList.add(ListDataListener.class, listener);\n   }\n \n   /**\n-   * removeListDataListener\n-   * @param listener TODO\n+   * Add a listener object to this model. The listener will no longer be\n+   * called when the set of elements in the model is changed.\n+   *\n+   * @param listener The listener to remove\n    */\n   public void removeListDataListener(ListDataListener listener)\n   {\n-    listenerList.remove (ListDataListener.class, listener);\n+    listenerList.remove(ListDataListener.class, listener);\n   }\n \n   /**\n-   * fireContentsChanged\n-   * @param source TODO\n-   * @param startIndex TODO\n-   * @param endIndex TODO\n+   * Call {@link ListDataListener#contentsChanged} on each element of the\n+   * {@link listenerList} which is a {@link ListDataListener}. The event\n+   * fired has type {@ListDataEvent.CONTENTS_CHANGED} and represents a\n+   * change to the data elements in the range [startIndex, endIndex]\n+   * inclusive.\n+   *\n+   * @param source The source of the change, typically <code>this</code>\n+   * @param startIndex The index of the first element which changed\n+   * @param endIndex The index of the last element which changed\n    */\n-  protected void fireContentsChanged(Object source, int startIndex, int endIndex)\n+  protected void fireContentsChanged(Object source, int startIndex,\n+                                     int endIndex)\n   {\n     // Variables\n     ListDataEvent event;\n@@ -100,10 +107,10 @@ protected void fireContentsChanged(Object source, int startIndex, int endIndex)\n \n     // Create Event\n     event = new ListDataEvent(source, ListDataEvent.CONTENTS_CHANGED,\n-    startIndex, endIndex);\n+                              startIndex, endIndex);\n \n     // Get Listeners\n-    listeners = getListDataListeners ();\n+    listeners = getListDataListeners();\n \n     // Process Listeners\n     for (index = 0; index < listeners.length; index++)\n@@ -114,12 +121,17 @@ protected void fireContentsChanged(Object source, int startIndex, int endIndex)\n   }\n \n   /**\n-   * fireIntervalAdded\n-   * @param source TODO\n-   * @param startIndex TODO\n-   * @param endIndex TODO\n+   * Call {@link ListDataListener#intervalAdded} on each element of the\n+   * {@link listenerList} which is a {@link ListDataListener}. The event\n+   * fired has type {@ListDataEvent.INTERVAL_ADDED} and represents an\n+   * addition of the data elements in the range [startIndex, endIndex]\n+   * inclusive.\n+   *\n+   * @param source The source of the change, typically <code>this</code>\n+   * @param startIndex The index of the first new element\n+   * @param endIndex The index of the last new element\n    */\n-  protected void fireIntervalAdded (Object source, int startIndex, int endIndex)\n+  protected void fireIntervalAdded(Object source, int startIndex, int endIndex)\n   {\n     // Variables\n     ListDataEvent event;\n@@ -128,27 +140,32 @@ protected void fireIntervalAdded (Object source, int startIndex, int endIndex)\n     int index;\n \n     // Create Event\n-    event = new ListDataEvent (source, ListDataEvent.INTERVAL_ADDED, startIndex,\n-                               endIndex);\n+    event = new ListDataEvent(source, ListDataEvent.INTERVAL_ADDED,\n+                              startIndex, endIndex);\n \n     // Get Listeners\n-    listeners = getListDataListeners ();\n+    listeners = getListDataListeners();\n \n     // Process Listeners\n     for (index = 0; index < listeners.length; index++)\n       {\n-        listener = listeners [index];\n-        listener.intervalAdded (event);\n+        listener = listeners[index];\n+        listener.intervalAdded(event);\n       }\n   }\n \n   /**\n-   * fireIntervalRemoved\n-   * @param source TODO\n-   * @param startIndex TODO\n-   * @param endIndex TODO\n+   * Call {@link ListDataListener#intervalRemoved} on each element of the\n+   * {@link listenerList} which is a {@link ListDataListener}. The event\n+   * fired has type {@ListDataEvent.INTERVAL_REMOVED} and represents a\n+   * removal of the data elements in the range [startIndex, endIndex]\n+   * inclusive.\n+   *\n+   * @param source The source of the change, typically <code>this</code>\n+   * @param startIndex The index of the first element removed\n+   * @param endIndex The index of the last element removed\n    */\n-  protected void fireIntervalRemoved (Object source, int startIndex,\n+  protected void fireIntervalRemoved(Object source, int startIndex,\n                                      int endIndex)\n   {\n     // Variables\n@@ -158,35 +175,41 @@ protected void fireIntervalRemoved (Object source, int startIndex,\n     int index;\n \n     // Create Event\n-    event = new ListDataEvent (source, ListDataEvent.INTERVAL_REMOVED,\n-                               startIndex, endIndex);\n+    event = new ListDataEvent(source, ListDataEvent.INTERVAL_REMOVED,\n+                              startIndex, endIndex);\n \n     // Get Listeners\n-    listeners = getListDataListeners ();\n+    listeners = getListDataListeners();\n \n     // Process Listeners\n     for (index = 0; index < listeners.length; index++)\n       {\n-        listener = listeners [index];\n-        listener.intervalRemoved (event);\n+        listener = listeners[index];\n+        listener.intervalRemoved(event);\n       }\n   }\n \n   /**\n-   * getListeners\n-   * @param listenerType TODO\n-   * @returns EventListener[]\n+   * Return the subset of {@link EventListener} objects found in this\n+   * object's {@link listenerList} which are elements of the specified\n+   * type.\n+   *\n+   * @param listenerType The type of listeners to select\n+   *\n+   * @return The set of listeners of the specified type\n    */\n-  public EventListener[] getListeners (Class listenerType)\n+  public EventListener[] getListeners(Class listenerType)\n   {\n-    return listenerList.getListeners (listenerType);\n+    return listenerList.getListeners(listenerType);\n   }\n \n   /**\n-   * getListDataListeners\n+   * A synonym for <code>getListeners(ListDataListener.class)</code>.\n+   *\n+   * @return The set of ListDataListeners found in the {@link listenerList}\n    */\n-  public ListDataListener[] getListDataListeners ()\n+  public ListDataListener[] getListDataListeners()\n   {\n-    return (ListDataListener[]) getListeners (ListDataListener.class);\n+    return (ListDataListener[]) getListeners(ListDataListener.class);\n   }\n }"}, {"sha": "cfb1f409dd71f5751f42c310c40ad41b9416c8b7", "filename": "libjava/javax/swing/DefaultListCellRenderer.java", "status": "modified", "additions": 66, "deletions": 204, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FDefaultListCellRenderer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FDefaultListCellRenderer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FDefaultListCellRenderer.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -42,213 +42,75 @@\n import java.io.Serializable;\n import javax.swing.border.Border;\n \n+\n /**\n  * DefaultListCellRenderer\n- * @author\tAndrew Selkirk\n- * @version\t1.0\n+ *\n+ * @author Andrew Selkirk\n+ * @version 1.0\n  */\n-public class DefaultListCellRenderer extends JLabel \n-\t\timplements ListCellRenderer, Serializable\n+public class DefaultListCellRenderer \n+  extends JLabel implements ListCellRenderer, Serializable\n {\n   static final long serialVersionUID = 7708947179685189462L;\n \n-\t//-------------------------------------------------------------\n-\t// Classes ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * UIResource\n-\t */\n-\tpublic static class UIResource extends DefaultListCellRenderer \n-\t\t\timplements javax.swing.plaf.UIResource {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor UIResource\n-\t\t */\n-\t\tpublic UIResource() {\n-\t\t\t// TODO\n-\t\t} // UIResource()\n-\n-\n-\t} // UIResource\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * noFocusBorder\n-\t */\n-\tprotected static Border noFocusBorder = null; // TODO\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor DefaultListCellRenderer\n-\t */\n-\tpublic DefaultListCellRenderer() {\n-\t\t// TODO\n-\t} // DefaultListCellRenderer()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * getListCellRendererComponent\n-\t * @param list TODO\n-\t * @param value TODO\n-\t * @param index TODO\n-\t * @param isSelected TODO\n-\t * @param cellHasFocus TODO\n-\t * @returns Component\n-\t */\n-\tpublic Component getListCellRendererComponent(JList list,\n-\t\t\tObject value, int index, boolean isSelected, boolean cellHasFocus) {\n-\t\treturn null; // TODO\n-\t} // getListCellRendererComponent()\n-\n-\t/**\n-\t * validate\n-\t */\n-\tpublic void validate() {\n-\t\t// TODO\n-\t} // validate()\n-\n-\t/**\n-\t * revalidate\n-\t */\n-\tpublic void revalidate() {\n-\t\t// TODO\n-\t} // revalidate()\n-\n-\t/**\n-\t * repaint\n-\t * @param tm TODO\n-\t * @param x TODO\n-\t * @param y TODO\n-\t * @param w TODO\n-\t * @param h TODO\n-\t */\n-\tpublic void repaint(long tm, int x, int y, int w, int h) {\n-\t\t// TODO\n-\t} // repaint()\n-\n-\t/**\n-\t * repaint\n-\t * @param rect TODO\n-\t */\n-\tpublic void repaint(Rectangle rect) {\n-\t\t// TODO\n-\t} // repaint()\n-\n-\t/**\n-\t * firePropertyChange\n-\t * @param propertyName TODO\n-\t * @param oldValue TODO\n-\t * @param newValue TODO\n-\t */\n-\tprotected void firePropertyChange(String propertyName,\n-\t\t\tObject oldValue, Object newValue) {\n-\t\t// TODO\n-\t} // firePropertyChange()\n-\n-\t/**\n-\t * firePropertyChange\n-\t * @param propertyName TODO\n-\t * @param oldValue TODO\n-\t * @param newValue TODO\n-\t */\n-\tpublic void firePropertyChange(String propertyName, \n-\t\t\tbyte oldValue, byte newValue) {\n-\t\t// TODO\n-\t} // firePropertyChange()\n-\n-\t/**\n-\t * firePropertyChange\n-\t * @param propertyName TODO\n-\t * @param oldValue TODO\n-\t * @param newValue TODO\n-\t */\n-\tpublic void firePropertyChange(String propertyName, \n-\t\t\tchar oldValue, char newValue) {\n-\t\t// TODO\n-\t} // firePropertyChange()\n-\n-\t/**\n-\t * firePropertyChange\n-\t * @param propertyName TODO\n-\t * @param oldValue TODO\n-\t * @param newValue TODO\n-\t */\n-\tpublic void firePropertyChange(String propertyName, \n-\t\t\tshort oldValue, short newValue) {\n-\t\t// TODO\n-\t} // firePropertyChange()\n-\n-\t/**\n-\t * firePropertyChange\n-\t * @param propertyName TODO\n-\t * @param oldValue TODO\n-\t * @param newValue TODO\n-\t */\n-\tpublic void firePropertyChange(String propertyName, \n-\t\t\tint oldValue, int newValue) {\n-\t\t// TODO\n-\t} // firePropertyChange()\n-\n-\t/**\n-\t * firePropertyChange\n-\t * @param propertyName TODO\n-\t * @param oldValue TODO\n-\t * @param newValue TODO\n-\t */\n-\tpublic void firePropertyChange(String propertyName, \n-\t\t\tlong oldValue, long newValue) {\n-\t\t// TODO\n-\t} // firePropertyChange()\n-\n-\t/**\n-\t * firePropertyChange\n-\t * @param propertyName TODO\n-\t * @param oldValue TODO\n-\t * @param newValue TODO\n-\t */\n-\tpublic void firePropertyChange(String propertyName, \n-\t\t\tfloat oldValue, float newValue) {\n-\t\t// TODO\n-\t} // firePropertyChange()\n-\n-\t/**\n-\t * firePropertyChange\n-\t * @param propertyName TODO\n-\t * @param oldValue TODO\n-\t * @param newValue TODO\n-\t */\n-\tpublic void firePropertyChange(String propertyName, \n-\t\t\tdouble oldValue, double newValue) {\n-\t\t// TODO\n-\t} // firePropertyChange()\n-\n-\t/**\n-\t * firePropertyChange\n-\t * @param propertyName TODO\n-\t * @param oldValue TODO\n-\t * @param newValue TODO\n-\t */\n-\tpublic void firePropertyChange(String propertyName, \n-\t\t\tboolean oldValue, boolean newValue) {\n-\t\t// TODO\n-\t} // firePropertyChange()\n-\n-\n-} // DefaultListCellRenderer\n+  public static class UIResource extends DefaultListCellRenderer\n+    implements javax.swing.plaf.UIResource\n+  {\n+    public UIResource()\n+    {\n+    }\n+  }\n+\n+  /** noFocusBorder */\n+  protected static Border noFocusBorder = null; // TODO\n+\n+  /**\n+   * getListCellRendererComponent\n+   *\n+   * @param list TODO\n+   * @param value TODO\n+   * @param index TODO\n+   * @param isSelected TODO\n+   * @param cellHasFocus TODO\n+   *\n+   * @return Component\n+   */\n+  public Component getListCellRendererComponent(JList list, Object value,\n+                                                int index, boolean isSelected,\n+                                                boolean cellHasFocus)\n+  {\n+    String s = value.toString();\n+    setText(s);\n+    setOpaque(true);\n+\n+    if (isSelected)\n+      {\n+        setBackground(list.getSelectionBackground());\n+        setForeground(list.getSelectionForeground());\n+      }\n+    else\n+      {\n+        setBackground(list.getBackground());\n+        setForeground(list.getForeground());\n+      }\n+\n+    setEnabled(list.isEnabled());\n+    setFont(list.getFont());\n+    return this;\n+  }\n+\n+  public void validate() {}\n+  public void revalidate() {}\n+  public void repaint(long tm, int x, int y, int w, int h) {}\n+  public void repaint(Rectangle rect) {}\n+  protected void firePropertyChange(String propertyName, Object oldValue, Object newValue){}\n+  public void firePropertyChange(String propertyName, byte oldValue, byte newValue) {}\n+  public void firePropertyChange(String propertyName, char oldValue, char newValue) {} \n+  public void firePropertyChange(String propertyName, short oldValue, short newValue) {}\n+  public void firePropertyChange(String propertyName, int oldValue, int newValue) {}\n+  public void firePropertyChange(String propertyName, long oldValue, long newValue) {}\n+  public void firePropertyChange(String propertyName, float oldValue, float newValue) {}\n+  public void firePropertyChange(String propertyName, double oldValue, double newValue) {}\n+  public void firePropertyChange(String propertyName, boolean oldValue, boolean newValue) {}\n+}"}, {"sha": "23f135b2f6b6d074245938ec5bbaa305369f0907", "filename": "libjava/javax/swing/DefaultListModel.java", "status": "modified", "additions": 459, "deletions": 485, "changes": 944, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FDefaultListModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FDefaultListModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FDefaultListModel.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -35,500 +35,474 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n-import java.util.ArrayList;\n import java.util.Enumeration;\n import java.util.NoSuchElementException;\n import java.util.Vector;\n \n /**\n- * DefaultListModel\n- * @author\tAndrew Selkirk\n- * @version\t1.0\n+ * This is a default subclass of the {@link AbstractListModel}, used by\n+ * {@link javax.swing.JList} and similar objects as the model of a list of\n+ * values. The implementation is based on an underlying {@link\n+ * java.util.Vector}.\n+ *\n+ * @author Andrew Selkirk\n+ * @author Graydon Hoare (graydon&064;redhat.com)\n  */\n+\n public class DefaultListModel extends AbstractListModel\n {\n   private static final long serialVersionUID = 2315945659722172272L;\n \n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * elements.  Note: Sun obviously implemented the storage as a\n-\t * Vector according to the similar API on this class.  I choose\n-\t * instead to implement the model with a proper collection object.\n-\t * Is this a good choice?  Probably not (ya..I know there are\n-\t * sync issues by doing this)\n-\t */\n-\tprivate ArrayList elements = new ArrayList();\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor DefaultListModel\n-\t */\n-\tpublic DefaultListModel() {\n-\t\t// TODO\n-\t} // DefaultListModel()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * elementAt\n-\t * @param index TODO\n-\t * @returns Object\n-\t */\n-\tpublic Object elementAt(int index) {\n-\t\treturn elements.get(index);\n-\t} // elementAt()\n-\n-\t/**\n-\t * toString\n-\t * @returns String\n-\t */\n-\tpublic String toString() {\n-\t\treturn elements.toString();\n-\t} // toString()\n-\n-\t/**\n-\t * indexOf\n-\t * @param element TODO\n-\t * @returns int\n-\t */\n-\tpublic int indexOf(Object element) {\n-\t\treturn elements.indexOf(element);\n-\t} // indexOf()\n-\n-\t/**\n-\t * indexOf\n-\t * @param element TODO\n-\t * @param startIndex TODO\n-\t * @returns int\n-\t */\n-\tpublic int indexOf(Object element, int startIndex) {\n-\n-\t\t// Variables\n-\t\tint\t\tindex;\n-\t\tObject\ttest;\n-\n-\t\t// Process Elements\n-\t\tfor (index = startIndex; index < elements.size(); index++) {\n-\t\t\ttest = elements.get(index);\n-\t\t\tif (test.equals(element) == true) {\n-\t\t\t\treturn index;\n-\t\t\t} // if\n-\t\t} // for\n-\t\treturn -1;\n-\n-\t} // indexOf()\n-\n-\t/**\n-\t * lastIndexOf\n-\t * @param element TODO\n-\t * @returns int\n-\t */\n-\tpublic int lastIndexOf(Object element) {\n-\t\treturn elements.lastIndexOf(element);\n-\t} // lastIndexOf()\n-\n-\t/**\n-\t * lastIndexOf\n-\t * @param element TODO\n-\t * @param endIndex TODO\n-\t * @returns int\n-\t */\n-\tpublic int lastIndexOf(Object element, int endIndex) {\n-\n-\t\t// Variables\n-\t\tint\t\tindex;\n-\t\tObject\ttest;\n-\n-\t\t// Process Elements\n-\t\tfor (index = endIndex; index >= 0; index--) {\n-\t\t\ttest = elements.get(index);\n-\t\t\tif (test.equals(element) == true) {\n-\t\t\t\treturn index;\n-\t\t\t} // if\n-\t\t} // for\n-\t\treturn -1;\n-\n-\t} // lastIndexOf()\n-\n-\t/**\n-\t * get\n-\t * @param index TODO\n-\t * @returns Object\n-\t */\n-\tpublic Object get(int index) {\n-\t\treturn elements.get(index);\n-\t} // get()\n-\n-\t/**\n-\t * set\n-\t * @param index TODO\n-\t * @param element TODO\n-\t * @returns Object\n-\t */\n-\tpublic Object set(int index, Object element) {\n-\n-\t\t// Variables\n-\t\tObject\tresult;\n-\n-\t\t// Process Action\n-\t\tresult = elements.set(index, element);\n-\n-\t\t// Send event\n-\t\tfireContentsChanged(this, index, index);\n-\n-\t\treturn result;\n-\n-\t} // set()\n-\n-\t/**\n-\t * add\n-\t * @param index TODO\n-\t * @param element TODO\n-\t */\n-\tpublic void add(int index, Object element) {\n-\n-\t\t// Process Action\n-\t\telements.add(index, element);\n-\n-\t\t// Send event\n-\t\tfireContentsChanged(this, index, index);\n-\n-\t} // add()\n-\n-\t/**\n-\t * addElement\n-\t * @param element TODO\n-\t */\n-\tpublic void addElement(Object element) {\n-\n-\t\t// Process Action\n-\t\telements.add(element);\n-\n-\t\t// Send event\n-\t\tfireIntervalAdded(this, elements.size(), elements.size());\n-\n-\t} // addElement()\n-\n-\t/**\n-\t * size\n-\t * @returns int\n-\t */\n-\tpublic int size() {\n-\t\treturn elements.size();\n-\t} // size()\n-\n-\t/**\n-\t * toArray\n-\t * @returns Object[]\n-\t */\n-\tpublic Object[] toArray() {\n-\t\treturn elements.toArray();\n-\t} // toArray()\n-\n-\t/**\n-\t * contains\n-\t * @param element TODO\n-\t * @returns boolean\n-\t */\n-\tpublic boolean contains(Object element) {\n-\t\treturn elements.contains(element);\n-\t} // contains()\n-\n-\t/**\n-\t * copyInto\n-\t * @param array TODO\n-\t */\n-\tpublic void copyInto(Object[] array) {\n-\n-\t\t// Variables\n-\t\tint\t\tindex;\n-\t\tint\t\tsize;\n-\t\tObject[]\tsrcArray;\n-\n-\t\t// Initialize\n-\t\tsize = size();\n-\t\tsrcArray = toArray();\n-\n-\t\t// Process Elements\n-\t\tfor (index = 0; index < size; index++) {\n-\t\t\tarray[index] = srcArray[index];\n-\t\t} // for\n-\n-\t} // copyInto()\n-\n-\t/**\n-\t * clear\n-\t */\n-\tpublic void clear() {\n-\n-\t\t// Process Action\n-\t\telements.clear();\n-\n-\t\t// Send event\n-\t\tfireIntervalRemoved(this, 0, elements.size());\n-\n-\t} // clear()\n-\n-\t/**\n-\t * remove\n-\t * @param index TODO\n-\t * @returns Object\n-\t */\n-\tpublic Object remove(int index) {\n-\n-\t\t// Variables\n-\t\tObject\tresult;\n-\n-\t\t// Process Action\n-\t\tresult = elements.remove(index);\n-\n-\t\t// Send event\n-\t\tfireIntervalRemoved(this, index, index);\n-\n-\t\treturn result;\n-\n-\t} // remove()\n-\n-\t/**\n-\t * isEmpty\n-\t * @returns boolean\n-\t */\n-\tpublic boolean isEmpty() {\n-\t\treturn elements.isEmpty();\n-\t} // isEmpty()\n-\n-\t/**\n-\t * elements\n-\t * @returns Enumeration\n-\t */\n-\tpublic Enumeration elements() {\n-\n-\t\t// TODO\n-\t\t// Note: This is a pathetic implementation.  If Vector\n-\t\t// was used for storage, this wouldn't be an issue.  I'll\n-\t\t// have to implement an Enumeration inner class sometime.\n-\n-\t\t// Variables\n-\t\tVector\tvector;\n-\n-\t\t// Get Enumeration\n-\t\tvector = new Vector(elements);\n-\t\treturn vector.elements();\n-\n-\t} // elements()\n-\n-\t/**\n-\t * trimToSize\n-\t */\n-\tpublic void trimToSize() {\n-\t\telements.trimToSize();\n-\t} // trimToSize()\n-\n-\t/**\n-\t * ensureCapacity\n-\t * @param size TODO\n-\t */\n-\tpublic void ensureCapacity(int size) {\n-\t\telements.ensureCapacity(size);\n-\t} // ensureCapacity()\n-\n-\t/**\n-\t * setSize\n-\t * @param size TODO\n-\t */\n-\tpublic void setSize(int size) {\n-\t\telements.ensureCapacity(size);\n-\t} // setSize()\n-\n-\t/**\n-\t * capacity\n-\t * @returns int\n-\t */\n-\tpublic int capacity() {\n-\t\treturn elements.size();\n-\t} // capacity()\n-\n-\t/**\n-\t * firstElement\n-\t * @returns Object\n-\t */\n-\tpublic Object firstElement() {\n-\n-\t\t// Variables\n-\t\tObject\telement;\n-\n-\t\ttry {\n-\t\t\telement = elements.get(0);\n-\t\t\treturn element;\n-\t\t} catch (IndexOutOfBoundsException e) {\n-\t\t\tthrow new NoSuchElementException();\n-\t\t} // try\n-\n-\t} // firstElement()\n-\n-\t/**\n-\t * lastElement\n-\t * @returns Object\n-\t */\n-\tpublic Object lastElement() {\n-\n-\t\t// Variables\n-\t\tObject\telement;\n-\n-\t\ttry {\n-\t\t\telement = elements.get(elements.size() - 1);\n-\t\t\treturn element;\n-\t\t} catch (ArrayIndexOutOfBoundsException e) {\n-\t\t\tthrow new NoSuchElementException();\n-\t\t} // try\n-\n-\t} // lastElement()\n-\n-\t/**\n-\t * setElementAt\n-\t * @param element TODO\n-\t * @param index TODO\n-\t */\n-\tpublic void setElementAt(Object element, int index) {\n-\n-\t\t// Process Action\n-\t\telements.set(index, element);\n-\n-\t\t// Send event\n-\t\tfireContentsChanged(this, index, index);\n-\n-\t} // setElementAt()\n-\n-\t/**\n-\t * removeElementAt\n-\t * @param index TODO\n-\t */\n-\tpublic void removeElementAt(int index) {\n-\n-\t\t// Process Action\n-\t\telements.remove(index);\n-\n-\t\t// Send event\n-\t\tfireIntervalRemoved(this, index, index);\n-\n-\t} // removeElementAt()\n-\n-\t/**\n-\t * insertElementAt\n-\t * @param element TODO\n-\t * @param index TODO\n-\t */\n-\tpublic void insertElementAt(Object element, int index) {\n-\n-\t\t// Process Action\n-\t\telements.add(index, element);\n-\n-\t\t// Send event\n-\t\tfireIntervalRemoved(this, index, index);\n-\n-\t} // insertElementAt()\n-\n-\t/**\n-\t * removeElement\n-\t * @param element TODO\n-\t * @returns boolean\n-\t */\n-\tpublic boolean removeElement(Object element) {\n-\n-\t\t// Variables\n-\t\tint\t\tindex;\n-\n-\t\tindex = elements.indexOf(element);\n-\t\tif (index != -1) {\n-\t\t\telements.remove(index);\n-\n-\t\t\t// Send event\n-\t\t\tfireIntervalRemoved(this, index, index);\n-\n-\t\t\treturn true;\n-\n-\t\t} // if\n-\n-\t\treturn false;\n-\n-\t} // removeElement()\n-\n-\t/**\n-\t * removeAllElements\n-\t */\n-\tpublic void removeAllElements() {\n-\n-\t\t// Variables\n-\t\tint\t\tsize;\n-\n-\t\tsize = size();\n-\n-\t\tif (size > 0) {\n-\n-\t\t\t// Process Action\n-\t\t\telements.clear();\n-\n-\t\t\t// Send event\n-\t\t\tfireIntervalRemoved(this, 0, size - 1);\n-\n-\t\t} // if\n-\n-\t} // removeAllElements()\n-\n-\t/**\n-\t * removeRange\n-\t * @param startIndex TODO\n-\t * @param endIndex TODO\n-\t */\n-\tpublic void removeRange(int startIndex, int endIndex) {\n-\n-\t\t// Variables\n-\t\tint\t\tindex;\n-\n-\t\t// Check Indices\n-\t\tif (startIndex > endIndex) {\n-\t\t\tthrow new IllegalArgumentException();\n-\t\t} // if\n-\n-\t\t// Process Elements\n-\t\tfor (index = endIndex; index >= startIndex; index--) {\n-\t\t\telements.remove(index);\n-\t\t} // for\n-\n-\t\t// Send event\n-\t\tfireIntervalRemoved(this, startIndex, endIndex);\n-\n-\t} // removeRange()\n-\n-\t/**\n-\t * getSize\n-\t * @returns int\n-\t */\n-\tpublic int getSize() {\n-\t\treturn elements.size();\n-\t} // getSize()\n-\n-\t/**\n-\t * getElementAt\n-\t * @param index TODO\n-\t * @returns Object\n-\t */\n-\tpublic Object getElementAt(int index) {\n-\t\treturn elements.get(index);\n-\t} // getElementAt()\n-\n-\n-} // DefaultListModel\n+  /**\n+   * The vector of elements in this list model.\n+   */\n+  private Vector elements = new Vector();\n+\n+  /**\n+   * Gets an element of the list at the provided index.\n+   *\n+   * @param index The index of the element to get\n+   *\n+   * @return The object at the given index\n+   *\n+   * @throws ArrayIndexOutOfBoundsException If the provided index is\n+   * outside the bounds of the list <code>[0, size())</code>\n+   */\n+  public Object elementAt(int index)\n+  {\n+    return elements.elementAt(index);\n+  }\n+\n+  /**\n+   * Convert the list to a string representation.\n+   *\n+   * @return A string representation of the list\n+   */\n+  public String toString()\n+  {\n+    return elements.toString();\n+  }\n+\n+  /**\n+   * Gets the first index of a particular element in the list.\n+   *\n+   * @param element The element to search for\n+   *\n+   * @return The first index in the list at which an object\n+   * <code>obj</code> exists such that <code>obj.equals(element)</code> is\n+   * <code>true</code>; if no such object exists, the method returns\n+   * <code>-1</code>\n+   */\n+  public int indexOf(Object element)\n+  {\n+    return elements.indexOf(element);\n+  }\n+\n+  /**\n+   * Gets the first index of a particular element in a list which occurs\n+   * <em>at or after</em> a particular index.\n+   *\n+   * @param element The element to search for\n+   * @param startIndex The index to begin searching at\n+   *\n+   * @return The first index in the list, greater than or equal to\n+   * <code>startIndex</code>, at which an object <code>obj</code> exists\n+   * such that <code>obj.equals(element)</code> is <code>true</code>; if no\n+   * such object exists, the method returns <code>-1</code>\n+   */\n+  public int indexOf(Object element, int startIndex)\n+  {\n+    return elements.indexOf(element, startIndex);\n+  }\n+\n+  /**\n+   * Gets the last index of a particular element in the list.\n+   *\n+   * @param element The element to search for\n+   *\n+   * @return The last index in the list at which an object\n+   * <code>obj</code> exists such that <code>obj.equals(element)</code> is\n+   * <code>true</code>; if no such object exists, the method returns\n+   * <code>-1</code>\n+   */\n+  public int lastIndexOf(Object element)\n+  {\n+    return elements.lastIndexOf(element);\n+  }\n+\n+  /**\n+   * Gets the last index of a particular element in a list which occurs\n+   * <em>at or before</em> a particular index.\n+   *\n+   * @param element The element to search for\n+   * @param endIndex The index to finish searching at\n+   *\n+   * @return The last index in the list, less than to or equal to\n+   * <code>endIndexIndex</code>, at which an object <code>obj</code> exists\n+   * such that <code>obj.equals(element)</code> is <code>true</code>; if no\n+   * such object exists, the method returns <code>-1</code>\n+   */\n+  public int lastIndexOf(Object element, int endIndex)\n+  {\n+    return elements.lastIndexOf(element, endIndex);\n+  }\n+\n+  /**\n+   * Gets the list element at a particular index.\n+   *\n+   * @param index The index to get the list value at\n+   *\n+   * @return The list value at the provided index\n+   *\n+   * @throws ArrayIndexOutOfBoundsException If the provided index is\n+   * outside the bounds of the list <code>[0, size())</code>\n+   */\n+  public Object get(int index)\n+  {\n+    return elements.get(index);\n+  }\n+\n+  /**\n+   * Sets the list element at a particular index.\n+   *\n+   * @param index The list index at which to set a value \n+   * @param element The value to set at the specified index\n+   *\n+   * @return The value previously held at the specified index\n+   *\n+   * @throws ArrayIndexOutOfBoundsException If the provided index is\n+   * outside the bounds of the list <code>[0, size())</code>\n+   */\n+  public Object set(int index, Object element)\n+  {\n+    Object result;\n+    result = elements.set(index, element);\n+    fireContentsChanged(this, index, index);\n+    return result;\n+  }\n+\n+  /**\n+   * Inserts an element at a particular index in the list. Each element at\n+   * index <code>i >= index</code> is shifted to position <code>i+1</code>.\n+   * If <code>index</code> is equal to <code>size()</code>, this is\n+   * equivalent to appending an element to the array. Any\n+   * <code>index</code> greater than <code>size()</code> is illegal.\n+   *\n+   * @param index The index to insert the element at\n+   * @param element The element to insert at the index\n+   *\n+   * @throws ArrayIndexOutOfBoundsException If the provided index is\n+   * outside the bounds <code>[0, size()]</code>\n+   */\n+  public void add(int index, Object element)\n+  {\n+    elements.add(index, element);\n+    fireContentsChanged(this, index, index);\n+  }\n+\n+  /**\n+   * Inserts an element at the end of the list. This is equivalent to\n+   * calling <code>list.add(list.size(), element)</code>.\n+   *\n+   * @param element The element to add to the list\n+   */\n+  public void addElement(Object element)\n+  {\n+    elements.add(element);\n+    fireIntervalAdded(this, elements.size(), elements.size());\n+  }\n+\n+  /**\n+   * Gets the number of elements in the list.\n+   *\n+   * @return The number of elements in the list\n+   */\n+  public int size()\n+  {\n+    return elements.size();\n+  }\n+\n+  /**\n+   * Gets an array containing the elements of the list.\n+   *\n+   * @return An array of the objects in the list, in the order they occur\n+   * in the list\n+   */\n+  public Object[] toArray()\n+  {\n+    return elements.toArray();\n+  }\n+\n+  /**\n+   * Determines whether a particular element is a member of the list.\n+   *\n+   * @param element The element to search for\n+   *\n+   * @return <code>true</code> if <code>element</code> is a member of the\n+   * list, otherwise <code>false</code>\n+   */\n+  public boolean contains(Object element)\n+  {\n+    return elements.contains(element);\n+  }\n+\n+  /**\n+   * Copies the list into a provided array. The provided array must be at\n+   * least as large as the list.\n+   *\n+   * @param array The array to copy the list into\n+   * \n+   * @throws IndexOutOfBoundsException if the array is too small to hold the\n+   * elements of the list\n+   */\n+  public void copyInto(Object[] array)\n+  {\n+    elements.copyInto(array);\n+  }\n+\n+  /**\n+   * Erases all the elements of the list, setting the list's size to 0.\n+   */\n+  public void clear()\n+  {\n+    elements.clear();\n+    fireIntervalRemoved(this, 0, elements.size());\n+  }\n+\n+  /**\n+   * Removes the element at a particular index from the list.\n+   *\n+   * @param index The index of the element to remove\n+   *\n+   * @return The value at the index, which has been removed from the list\n+   *\n+   * @throws ArrayIndexOutOfBoundsException If the provided index is\n+   * outside the bounds of the list <code>[0, size())</code>\n+   */\n+  public Object remove(int index)\n+  {\n+    Object result;\n+    result = elements.remove(index);\n+    fireIntervalRemoved(this, index, index);\n+    return result;\n+  }\n+\n+  /**\n+   * Determines whether the list is empty.\n+   *\n+   * @return <code>true</code> if the list is empty, otherwise\n+   * <code>false</code>\n+   */\n+  public boolean isEmpty()\n+  {\n+    return elements.isEmpty();\n+  }\n+\n+  /**\n+   * Returns an {@link java.util.Enumeration} over the elements of the list.\n+   *\n+   * @return A new enumeration which iterates over the list\n+   */\n+  public Enumeration elements()\n+  {\n+    return elements.elements();\n+  }\n+\n+  /**\n+   * Sets the capacity of the list to be equal to its size. The list's capacity\n+   * is the number of elements it can hold before it needs to be reallocated.\n+   * The list's size is the number of elements it currently holds. \n+   */\n+  public void trimToSize()\n+  {\n+    elements.trimToSize();\n+  }\n+\n+  /**\n+   * Ensures that the list's capacity is at least equal to\n+   * <code>size</code>. The list's capacity is the number of elements it\n+   * can hold before it needs to be reallocated.\n+   *\n+   * @param size The capacity to ensure the list can hold\n+   */\n+  public void ensureCapacity(int size)\n+  {\n+    elements.ensureCapacity(size);\n+  }\n+\n+  /**\n+   * Sets the size of the list to a particular value. If the specified size\n+   * is greater than the current size, the values at the excess list\n+   * indices are set to <code>null</code>.  If the specified size is less\n+   * than the current size, the excess elements are removed from the list.\n+   *\n+   * @param size The new size to set the list to\n+   */\n+  public void setSize(int size)\n+  {\n+    elements.setSize(size);\n+  }\n+\n+  /**\n+   * Gets the capacity of the list. The list's capacity is the number of\n+   * elements it can hold before it needs to be reallocated. \n+   *\n+   * @return The capacity of the list\n+   */\n+  public int capacity()\n+  {\n+    return elements.capacity();\n+  }\n+\n+  /**\n+   * Gets the first element in the list.\n+   *\n+   * @return The first element in the list\n+   */\n+  public Object firstElement()\n+  {\n+    return elements.firstElement();\n+  }\n+\n+  /**\n+   * Gets the last element in the list.\n+   *\n+   * @return The last element in the list\n+   */\n+  public Object lastElement()\n+  {\n+    return elements.lastElement();\n+  }\n+\n+  /**\n+   * Sets the list element at a particular index.\n+   *\n+   * @param element The value to set at the specified index\n+   * @param index The list index at which to set a value \n+   *\n+   * @throws ArrayIndexOutOfBoundsException If the provided index is\n+   * outside the bounds of the list <code>[0, size())</code>\n+   */\n+  public void setElementAt(Object element, int index)\n+  {\n+    elements.setElementAt(element, index);\n+    fireContentsChanged(this, index, index);\n+  }\n+\n+  /**\n+   * Removes the element at a particular index from the list.\n+   *\n+   * @param index The index of the element to remove\n+   *\n+   * @throws ArrayIndexOutOfBoundsException If the provided index is\n+   * outside the bounds of the list <code>[0, size())</code>\n+   */\n+  public void removeElementAt(int index)\n+  {\n+    elements.remove(index);\n+    fireIntervalRemoved(this, index, index);\n+  }\n+\n+  /**\n+   * Inserts an element at a particular index in the list. Each element at\n+   * index <code>i >= index</code> is shifted to position <code>i+1</code>.\n+   * If <code>index</code> is equal to <code>size()</code>, this is\n+   * equivalent to appending an element to the array. Any\n+   * <code>index</code> greater than <code>size()</code> is illegal.\n+   *\n+   * @param element The element to insert at the index\n+   * @param index The index to insert the element at\n+   *\n+   * @throws ArrayIndexOutOfBoundsException If the provided index is\n+   * outside the bounds <code>[0, size()]</code>\n+   */\n+  public void insertElementAt(Object element, int index)\n+  {\n+    elements.insertElementAt(element, index);\n+    fireIntervalAdded(this, index, index);\n+  }\n+\n+  /**\n+   * Removes the first occurrence of a particular element in the list. If the\n+   * element does not exist in the list, nothing happens.\n+   *\n+   * @param element The element to remove\n+   *\n+   * @return <code>true</code> if the element existed in the list (and was\n+   * removed), <code>false</code> otherwise\n+   */\n+  public boolean removeElement(Object element)\n+  {\n+    int index;\n+    index = elements.indexOf(element);\n+    if (index != -1)\n+      {\n+        elements.remove(index);\n+        fireIntervalRemoved(this, index, index);\n+        return true;\n+      }\n+    return false;\n+  }\n+\n+  /**\n+   * Remove all elements in the list.\n+   */\n+  public void removeAllElements()\n+  {\n+    int size;\n+    size = size();\n+    if (size > 0)\n+      {\n+        elements.clear();\n+        fireIntervalRemoved(this, 0, size - 1);\n+      }\n+  }\n+\n+  /**\n+   * Remove all elements between <code>startIndex</code> and\n+   * <code>endIndex</code> inclusive.\n+   *\n+   * @param startIndex The first index in the range to remove\n+   * @param endIndex The last index in the range to remove\n+   *\n+   * @throws ArrayIndexOutOfBoundsException if either index is outside the\n+   * valid range of indices for this list <code>[0, size())</code>\n+   * @throws IllegalArgumentException if <code>startIndex > endIndex</code>\n+   */\n+  public void removeRange(int startIndex, int endIndex)\n+  {\n+    int index;\n+    if (startIndex > endIndex)\n+      throw new IllegalArgumentException();\n+    for (index = endIndex; index >= startIndex; index--)\n+      elements.remove(index);\n+    fireIntervalRemoved(this, startIndex, endIndex);\n+  }\n+\n+  /**\n+   * Gets the size of the list.\n+   *\n+   * @return The number of elements currently in the list\n+   */\n+  public int getSize()\n+  {\n+    return elements.size();\n+  }\n+\n+  /**\n+   * Gets the list element at a particular index.\n+   *\n+   * @param index The index to get the list value at\n+   *\n+   * @return The list value at the provided index\n+   *\n+   * @throws ArrayIndexOutOfBoundsException If the provided index is\n+   * outside the bounds of the list <code>[0, size())</code>\n+   */\n+  public Object getElementAt(int index)\n+  {\n+    return elements.get(index);\n+  }\n+}"}, {"sha": "fb60b85d42f9a1e19e72af2c5e7657b7edbb4477", "filename": "libjava/javax/swing/DefaultListSelectionModel.java", "status": "modified", "additions": 497, "deletions": 132, "changes": 629, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FDefaultListSelectionModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FDefaultListSelectionModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FDefaultListSelectionModel.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -1,4 +1,4 @@\n-/* DefaultListSelectionModel.java -- \n+/* DefaultListSelectionModel.java --\n    Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -35,190 +35,555 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n import java.io.Serializable;\n import java.util.EventListener;\n-import java.util.Vector;\n+import java.util.BitSet;\n import javax.swing.event.EventListenerList;\n import javax.swing.event.ListSelectionEvent;\n import javax.swing.event.ListSelectionListener;\n \n-public class DefaultListSelectionModel implements Cloneable, ListSelectionModel, Serializable\n+\n+/**\n+ * <p>This class provides a default implementation of {@link\n+ * ListSelectioModel}, which is used by {@link javax.swing.JList} and\n+ * similar classes to manage the selection status of a number of data\n+ * elements. </p>\n+ *\n+ * <p>The class is organized <em>abstractly</em> as a set of intervals of\n+ * integers. Each interval indicates an inclusive range of indices in a\n+ * list -- held by some other object and unknown to this class -- which is\n+ * considered \"selected\". There are various accessors for querying and\n+ * modifying the set of intervals, with simplified forms accepting a single\n+ * index, representing an interval with only one element. </p>\n+ */\n+public class DefaultListSelectionModel implements Cloneable,\n+                                                  ListSelectionModel,\n+                                                  Serializable\n {\n+\n+  /** The list of ListSelectionListeners subscribed to this selection model. */\n   protected EventListenerList listenerList = new EventListenerList();\n+\n+\n+  /** \n+   * The current list selection mode. Must be one of the numeric constants\n+   * <code>SINGLE_SELECTION</code>, <code>SINGLE_INTERVAL_SELECTION</code>\n+   * or <code>MULTIPLE_INTERVAL_SELECTION</code> from {@link\n+   * ListSelectionModel}. The default value is\n+   * <code>MULTIPLE_INTERVAL_SELECTION</code>.\n+   */\n+  int selectionMode = MULTIPLE_INTERVAL_SELECTION;\n+\n+\n+  /**\n+   * The index of the \"lead\" of the most recent selection. The lead is the\n+   * second argument in any call to {@link #setSelectionInterval}, {@link\n+   * #addSelectionInterval} or {@link #removeSelectionInterval}. Generally\n+   * the lead refers to the most recent position a user dragged their mouse\n+   * over.\n+   */\n+  int leadSelectionIndex = -1;\n+\n+\n+  /**\n+   * The index of the \"anchor\" of the most recent selection. The anchor is\n+   * the first argument in any call to {@link #setSelectionInterval},\n+   * {@link #addSelectionInterval} or {@link\n+   * #removeSelectionInterval}. Generally the anchor refers to the first\n+   * recent position a user clicks when they begin to drag their mouse over\n+   * a list.\n+   *\n+   * @see #getAnchorSelectionIndex\n+   * @see #setAnchorSelectionIndex\n+   */\n+  int anchorSelectionIndex = -1;\n+\n+\n+  /**\n+   * controls the range of indices provided in any {@link\n+   * ListSelectionEvent} fired by the selectionModel. Let\n+   * <code>[A,L]</code> be the range of indices between {@link\n+   * anchorSelectionIndex} and {@link leadSelectionIndex} inclusive, and\n+   * let <code>[i0,i1]</code> be the range of indices changed in a given\n+   * call which generates a {@link ListSelectionEvent}. Then when this\n+   * property is <code>true</code>, the {@link ListSelectionEvent} contains\n+   * the range <code>[A,L] union [i0,i1]</code>; when <code>false</code> it\n+   * will contain only <code>[i0,i1]</code>. The default is\n+   * <code>true</code>.\n+   *\n+   * @see #isLeadAnchorNotificationEnabled\n+   * @see #setLeadAnchorNotificationEnabled\n+   */\n+  boolean leadAnchorNotificationEnabled = true;\n+\n+\n+  /**\n+   * Whether the selection is currently \"adjusting\". Any {@link\n+   * ListSelectionEvent} events constructed in response to changes in this\n+   * list selection model will have their {@link\n+   * ListSelectionEvent#isAdjusting} field set to this value.\n+   *\n+   * @see #getValueIsAdjusting\n+   * @see #setValueIsAdjusting\n+   */\n+  boolean valueIsAdjusting = false;\n+\n+\n+  /** \n+   * The current set of \"intervals\", represented simply by a {@link\n+   * java.util.BitSet}. A set bit indicates a selected index, whereas a\n+   * cleared bit indicates a non-selected index.\n+   */\n+  BitSet sel = new BitSet();\n+\n+\n+  /**\n+   * Gets the value of the {@link #selectionMode} property.\n+   *\n+   * @return The current value of the property\n+   */\n+  public int getSelectionMode()\n+  {\n+    return selectionMode;\n+  }\n+\n+  /**\n+   * Sets the value of the {@link #selectionMode} property.\n+   *\n+   * @param a The new value of the property\n+   */\n+  public void setSelectionMode(int a)\n+  {\n+    selectionMode = a;\n+  }\n+\n+  /**\n+   * Gets the value of the {@link #anchorSelectionIndex} property.\n+   * \n+   * @return The current property value\n+   *\n+   * @see #setAnchorSelectionIndex\n+   */\n+  public int getAnchorSelectionIndex()\n+  {\n+    return anchorSelectionIndex;\n+  }\n+\n+  /**\n+   * Sets the value of the {@link #anchorSelectionIndex} property.\n+   * \n+   * @param anchorIndex The new property value\n+   *\n+   * @see #getAnchorSelectionIndex\n+   */\n+  public void setAnchorSelectionIndex(int anchorIndex)\n+  {\n+    anchorSelectionIndex = anchorIndex;\n+  }\n   \n-    int mode = SINGLE_SELECTION;\n-\n-    Vector sel = new Vector();\n-\n-    class Range\n-    {\n-\tint i0, i1;\n-\n-\tRange(int a, int b)\n-\t{\n-\t    if (a > b)\n-\t\t{\n-\t\t    i0 = b;\n-\t\t    i1 = a;\n-\t\t}\n-\t    else\n-\t\t{\n-\t\t    i0 = a; \n-\t\t    i1 = b;\n-\t\t}\n-\t}\n-    }\n+  /**\n+   * Gets the value of the {@link #leadSelectionIndex} property.\n+   * \n+   * @return The current property value\n+   *\n+   * @see #setLeadSelectionIndex\n+   */\n+  public int getLeadSelectionIndex()\n+  {\n+    return leadSelectionIndex;\n+  }\n+\n+  /**\n+   * <p>Sets the value of the {@link #anchorSelectionIndex} property. As a\n+   * side effect, alters the selection status of two ranges of indices. Let\n+   * <code>OL</code> be the old lead selection index, <code>NL</code> be\n+   * the new lead selection index, and <code>A</code> be the anchor\n+   * selection index. Then if <code>A</code> is a valid selection index,\n+   * one of two things happens depending on the seleciton status of\n+   * <code>A</code>:</p>\n+   *\n+   * <ul>\n+   *\n+   * <li><code>isSelectedIndex(A) == true</code>: set <code>[A,OL]</code>\n+   * to <em>deselected</em>, then set <code>[A,NL]</code> to\n+   * <em>selected</em>.</li>\n+   *\n+   * <li><code>isSelectedIndex(A) == false</code>: set <code>[A,OL]</code>\n+   * to <em>selected</em>, then set <code>[A,NL]</code> to\n+   * <em>deselected</em>.</li>\n+   *\n+   * </ul>\n+   *\n+   * <p>This method generates at most a single {@link ListSelectionEvent}\n+   * despite changing multiple ranges. The range of values provided to the\n+   * {@link ListSelectionEvent} includes only the minimum range of values\n+   * which changed selection status between the beginning and end of the\n+   * method.</p>\n+   * \n+   * @param anchorIndex The new property value\n+   *\n+   * @see #getAnchorSelectionIndex\n+   */\n+  public void setLeadSelectionIndex(int leadIndex)\n+  {\n+    int oldLeadIndex = leadSelectionIndex;\n+    leadSelectionIndex = leadIndex;\n+\n+    if (anchorSelectionIndex == -1)\n+      return;\n+\n+    int R1 = Math.min(anchorSelectionIndex, oldLeadIndex);\n+    int R2 = Math.max(anchorSelectionIndex, oldLeadIndex);\n+    int S1 = Math.min(anchorSelectionIndex, leadIndex);\n+    int S2 = Math.max(anchorSelectionIndex, leadIndex);\n+    \n+    int lo = Math.min(R1, S1);\n+    int hi = Math.max(R2, S2);\n+\n+    BitSet oldRange = sel.get(lo, hi+1);\n+\n+    if (isSelectedIndex(anchorSelectionIndex))\n+      {\n+        sel.clear(R1, R2+1);\n+        sel.set(S1, S2+1);\n+      }\n+    else\n+      {\n+        sel.set(R1, R2+1);\n+        sel.clear(S1, S2+1);\n+      }\n+    \n+    BitSet newRange = sel.get(lo, hi+1);\n+    newRange.xor(oldRange);\n+\n+    int beg = sel.nextSetBit(0), end = -1;\n+    for(int i=beg; i >= 0; i=sel.nextSetBit(i+1)) \n+      { \n+        end = i;\n+      }\n+    fireSelectionValueChanged(beg, end, valueIsAdjusting);    \n+  }\n+\n+  /**\n+   * Gets the value of the {@link #leadAnchorNotificationEnabled} property.\n+   * \n+   * @return The current property value\n+   *\n+   * @see #setLeadAnchorNotificationEnabled\n+   */\n+  public boolean isLeadAnchorNotificationEnabled()\n+  {\n+    return leadAnchorNotificationEnabled;\n+  }\n+\n+  /**\n+   * Sets the value of the {@link #leadAnchorNotificationEnabled} property.\n+   * \n+   * @param flag The new property value\n+   *\n+   * @see #getLeadAnchorNotificationEnabled\n+   */\n+  public void setLeadAnchorNotificationEnabled(boolean l)\n+  {\n+    leadAnchorNotificationEnabled = l;\n+  }\n+\n+\n+  /**\n+   * Gets the value of the {@link #valueIsAdjusting} property.\n+   *\n+   * @return The current property value\n+   *\n+   * @see #setValueIsAdjusting\n+   */\n+  public boolean getValueIsAdjusting()\n+  {\n+    return valueIsAdjusting;\n+  }\n+\n+  /**\n+   * Sets the value of the {@link #valueIsAdjusting} property.\n+   *\n+   * @param v The new property value\n+   *\n+   * @see #getValueIsAdjusting\n+   */\n+  public void setValueIsAdjusting(boolean v)\n+  {\n+    valueIsAdjusting = v;\n+  }\n+\n+  /**\n+   * Determines whether the selection is empty.\n+   *\n+   * @return <code>true</code> if the selection is empty, otherwise\n+   * <code>false</code>\n+   */\n+  public boolean isSelectionEmpty()\n+  {\n+    return sel.isEmpty();\n+  }\n+\n+\n+  /**\n+   * Gets the smallest index which is currently a member of a selection\n+   * interval.\n+   *\n+   * @return The least integer <code>i</code> such that <code>i >=\n+   * 0</code> and <code>i</code> is a member of a selected interval, or\n+   * <code>-1</code> if there are no selected intervals\n+   *\n+   * @see #getMaxSelectionIndex\n+   */\n+  public int getMinSelectionIndex()\n+  {\n+    if (isSelectionEmpty())\n+      return -1;\n+    \n+    return sel.nextSetBit(0);\n+  }\n \n+  /**\n+   * Gets the largest index which is currently a member of a selection\n+   * interval.\n+   *\n+   * @return The greatest integer <code>i</code> such that <code>i >=\n+   * 0</code> and <code>i</code> is a member of a selected interval, or\n+   * <code>-1</code> if there are no selected intervals\n+   *\n+   * @see #getMinSelectionIndex\n+   */\n+  public int getMaxSelectionIndex()\n+  {\n+    if (isSelectionEmpty())\n+      return -1;\n+\n+    int mx = -1;\n+    for(int i=sel.nextSetBit(0); i >= 0; i=sel.nextSetBit(i+1)) \n+      { \n+        mx = i;\n+      }\n+    return mx;\n+  }\n+\n+  /**\n+   * Determines whether a particular index is a member of a selection\n+   * interval.\n+   *\n+   * @param a The index to search for\n+   *\n+   * @return <code>true</code> if the index is a member of a selection interval,\n+   * otherwise <code>false</code>\n+   */\n+  public boolean isSelectedIndex(int a)\n+  {\n+    return sel.get(a);\n+  }\n+\n+  /**\n+   * If the {@link #selectionMode} property is equal to\n+   * <code>SINGLE_SELECTION</code> or\n+   * <code>SINGLE_INTERVAL_SELECTION</code>, equivalent to calling\n+   * <code>setSelectionInterval(index1, index2)</code>; otherwise adds the\n+   * range <code>[index0, index1]</code> to the selection interval set.\n+   *\n+   * @param index0 The beginning of the range of indices to select\n+   * @param index1 The end of the range of indices to select\n+   *\n+   * @see #setSelectionInterval\n+   * @see #removeSelectionInterval\n+   */\n+  public void addSelectionInterval(int index0, int index1) \n+  {\n+    if (selectionMode == SINGLE_SELECTION\n+        || selectionMode == SINGLE_INTERVAL_SELECTION)\n+      sel.clear();\n     \n-    public int getMinSelectionIndex()\n-    {\n-\tif (isSelectionEmpty())\n-\t    return -1;\n-\t\n-\tboolean first = true;\n-\tint min = -1;\n-\tfor (int i=0;i<sel.size();i++)\n-\t    {\n-\t\tRange r = (Range) sel.get(i);\n-\n-\t\tif (first)\n-\t\t    {\n-\t\t\tmin = r.i0;\n-\t\t\tfirst = false;\n-\t\t    }\t\n-\t\telse\n-\t\t    {\n-\t\t\tif (r.i0 > min)\n-\t\t\t    {\n-\t\t\t\tmin = r.i0;\n-\t\t\t    }\n-\t\t    }\n-\t    }\n-\treturn min;\n-    }\n-\n-    public int getMaxSelectionIndex()\n-    {\n-\tif (isSelectionEmpty())\n-\t    return -1;\n-\n-\tboolean first = true;\n-\tint max = -1;\n-\tfor (int i=1;i<sel.size();i++)\n-\t    {\n-\t\tRange r = (Range) sel.get(i);\n-\t\t\n-\t\tif (first)\n-\t\t    {\n-\t\t\tmax = r.i1;\n-\t\t    }\n-\t\telse\n-\t\t    {\n-\t\t\tif (r.i1 > max)\n-\t\t\t    {\n-\t\t\t\tmax = r.i1;\n-\t\t\t    }\n-\t\t    }\n-\t    }\n-\treturn max;\n-    }\n-\n-    public boolean isSelectedIndex(int a)\n-    {\n-\tfor (int i=0;i<sel.size();i++)\n-\t    {\n-\t\tRange r = (Range) sel.get(i);\n-\t\tif (r.i0 <= a &&\n-\t\t    r.i1 >= a)\n-\t\t    {\n-\t\t\treturn true;\n-\t\t    }\n-\t    }\n-\treturn false;\n-    }\n-\n-\n-    public int getSelectionMode()\n-    { return mode; }\n-    public void setSelectionMode(int a)\n-    {\tmode = a;    }\n-\n-    boolean isSelectionEmpty() \n-    {\n-\treturn sel.size() == 0;\n-    }\n-\n-    public void clearSelection()\n-    {\n-\tsel.removeAllElements();\n-    }\n-\n-    public void setSelectionInterval(int index0, int index1) \n-    {\n-\tif (mode == SINGLE_SELECTION)\n-\t    {\n-\t\tsel.removeAllElements();\n-\t    }\n-\n-\tsel.addElement(new Range(index0, index1));\n-    }\n+    if (selectionMode == SINGLE_SELECTION)\n+      index0 = index1;\n+\n+    int lo = Math.min(index0, index1);\n+    int hi = Math.max(index0, index1);\n+\n+    sel.set(lo, hi+1);\n+    fireSelectionValueChanged(lo, hi, valueIsAdjusting);\n+  }\n+\n+\n+  /**\n+   * Deselects all indices in the inclusive range\n+   * <code>[index0,index1]</code>.\n+   *\n+   * @param index0 The beginning of the range of indices to deselect\n+   * @param index1 The end of the range of indices to deselect\n+   *\n+   * @see #addSelectionInterval\n+   * @see #setSelectionInterval\n+   */\n+  public void removeSelectionInterval(int index0,\n+                                      int index1)\n+  {\n+    int lo = Math.min(index0, index1);\n+    int hi = Math.max(index0, index1);\n+    sel.clear(lo, hi+1); \n+    fireSelectionValueChanged(lo, hi, valueIsAdjusting);\n+  }\n+\n+  /**\n+   * Removes all intervals in the selection set.\n+   */\n+  public void clearSelection()\n+  {\n+    int sz = sel.size();\n+    sel.clear();\n+    fireSelectionValueChanged(0, sz, valueIsAdjusting);\n+  }\n+  \n+  /**\n+   * Clears the current selection and marks a given interval as\n+   * \"selected\". If the current selection mode is\n+   * <code>SINGLE_SELECTION</code> only the index <code>index2</code> is\n+   * selected.\n+   *\n+   * @param index0 The low end of the new selection \n+   * @param index1 The high end of the new selection\n+   */\n+  public void setSelectionInterval(int index0, int index1)\n+  {\n+    sel.clear();\n+    if (selectionMode == SINGLE_SELECTION)\n+      index0 = index1;\n+\n+    int lo = Math.min(index0, index1);\n+    int hi = Math.max(index0, index1);\n+    sel.set(lo, hi+1);\n+    fireSelectionValueChanged(lo, hi, valueIsAdjusting);\n+  }\n+\n+  /**\n+   * Inserts a number of indices either before or after a particular\n+   * position in the set of indices. Renumbers all indices after the\n+   * inserted range. The new indices in the inserted range are not\n+   * selected. This method is typically called to synchronize the selection\n+   * model with an inserted range of elements in a {@link ListModel}.\n+   *\n+   * @param index The position to insert indices at\n+   * @param length The number of indices to insert\n+   * @param before Indicates whether to insert the indices before the index\n+   * or after it\n+   */\n+  public void insertIndexInterval(int index,\n+                                  int length,\n+                                  boolean before)\n+  {\n+    if (!before)\n+      {        \n+        index++;\n+        length--;\n+      }\n+    BitSet tmp = sel.get(index, sel.size());\n+    sel.clear(index, sel.size());\n+    int n = tmp.size();\n+    for (int i = 0; i < n; ++i)\n+      sel.set(index + length + i, tmp.get(i));\n+  }\n+\n+  /**\n+   * Removes a range from the set of indices. Renumbers all indices after\n+   * the removed range. This method is typically called to synchronize the\n+   * selection model with a deleted range of elements in a {@link\n+   * ListModel}.\n+   *\n+   * @param index0 The first index to remove (inclusive)\n+   * @param index1 The last index to remove (inclusive)\n+   */\n+  public void removeIndexInterval(int index0,\n+                                  int index1)\n+  {\n+    int lo = Math.min(index0, index1);\n+    int hi = Math.max(index0, index1);\n+\n+    BitSet tmp = sel.get(hi, sel.size());\n+    sel.clear(lo, sel.size());\n+    int n = tmp.size();\n+    for (int i = 0; i < n; ++i)\n+      sel.set(lo + i, tmp.get(i));\n+  }\n+\n+  /**\n+   * Fires a {@link ListSelectionEvent} to all the listeners of type {@link\n+   * ListSelectionListener} registered with this selection model.\n+   *\n+   * @param firstIndex The low index of the changed range\n+   * @param lastIndex The high index of the changed range\n+   * @param isAdjusting Whether this change is part of a seqence of adjustments\n+   * made to the selection, such as during interactive scrolling\n+   */\n+  public void fireSelectionValueChanged(int firstIndex, int lastIndex,\n+                                        boolean isAdjusting)\n+  {\n+    ListSelectionEvent evt = new ListSelectionEvent(this, firstIndex,\n+                                                    lastIndex, isAdjusting);\n+    ListSelectionListener[] listeners = getListSelectionListeners();\n+    for (int i = 0; i < listeners.length; ++i)\n+      listeners[i].valueChanged(evt);\n+  }\n \n   /**\n    * Adds a listener.\n    *\n-   * @param listener the listener to add\n+   * @param listener The listener to add\n    *\n    * @see removeListSelectionListener\n    * @see getListSelectionListeners\n    */\n   public void addListSelectionListener(ListSelectionListener listener)\n   {\n-    listenerList.add (ListSelectionListener.class, listener);\n+    listenerList.add(ListSelectionListener.class, listener);\n   }\n \n   /**\n    * Removes a registered listener.\n    *\n-   * @param listener the listener to remove\n+   * @param listener The listener to remove\n    *\n    * @see addListSelectionListener\n    * @see getListSelectionListeners\n    */\n   public void removeListSelectionListener(ListSelectionListener listener)\n   {\n-    listenerList.remove (ListSelectionListener.class, listener);\n+    listenerList.remove(ListSelectionListener.class, listener);\n   }\n-  \n+\n   /**\n    * Returns an array of all registerers listeners.\n-   * \n-   * @return the array\n-   * \n-   * @since 1.3\n+   *\n+   * @param listenerType The type of listener to retrieve\n+   *\n+   * @return The array\n    *\n    * @see getListSelectionListener\n+   * @since 1.3\n    */\n-  public EventListener[] getListeners (Class listenerType)\n+  public EventListener[] getListeners(Class listenerType)\n   {\n-    return listenerList.getListeners (listenerType);\n+    return listenerList.getListeners(listenerType);\n   }\n \n   /**\n    * Returns an array of all registerd list selection listeners.\n    *\n    * @return the array\n-   * \n-   * @since 1.4\n    *\n    * @see addListSelectionListener\n    * @see removeListSelectionListener\n    * @see getListeners\n+   * @since 1.4\n    */\n   public ListSelectionListener[] getListSelectionListeners()\n   {\n-    return (ListSelectionListener[]) getListeners (ListSelectionListener.class);\n+    return (ListSelectionListener[]) getListeners(ListSelectionListener.class);\n   }\n }"}, {"sha": "fdc5dbcc8a90fb173db6046594e00eaef81bb007", "filename": "libjava/javax/swing/JComponent.java", "status": "modified", "additions": 72, "deletions": 33, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FJComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FJComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJComponent.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -75,6 +75,7 @@\n import javax.swing.event.EventListenerList;\n import javax.swing.border.Border;\n import javax.swing.plaf.ComponentUI;\n+import javax.swing.event.SwingPropertyChangeSupport;\n \n /**\n  * Every component in swing inherits from this class (JLabel, JButton, etc).\n@@ -88,21 +89,26 @@ public abstract class JComponent extends Container implements Serializable\n {\n   static final long serialVersionUID = -5242478962609715464L;\n \n-  protected EventListenerList listenerList = new EventListenerList();\n-\n-        /**\n-         * accessibleContext\n-         */\n-        protected AccessibleContext accessibleContext;\n-\n-\tDimension pref,min,max;\n-\tBorder border;\n-\tJToolTip tooltip;\n-\tString tool_tip_text;\n-\tboolean use_double_buffer, opaque;\n-\tprotected ComponentUI ui;\n-\n-\tHashtable prop_hash;\n+  EventListenerList listenerList = new EventListenerList();\n+  \n+  /**\n+   * accessibleContext\n+   */\n+  AccessibleContext accessibleContext;\n+  \n+  Dimension pref,min,max;\n+  Border border;\n+  JToolTip tooltip;\n+  String tool_tip_text;\n+  boolean use_double_buffer, opaque;\n+  Image doubleBuffer;\n+  int doubleBufferWidth = -1;\n+  int doubleBufferHeight = -1;\n+  ComponentUI ui;\n+  private SwingPropertyChangeSupport changeSupport;\n+  \n+  Hashtable prop_hash;\n+  \n \n \t/**\n \t * AccessibleJComponent\n@@ -195,7 +201,7 @@ protected AccessibleJComponent(JComponent component) {\n \t\t * addPropertyChangeListener\n \t\t * @param listener TODO\n \t\t */\n-\t\tpublic void addPropertyChangeListener(PropertyChangeListener listener) {\n+\t\tpublic void addPropertyChangeListener(PropertyChangeListener listener) { \n \t\t\t// TODO\n \t\t} // addPropertyChangeListener()\n \n@@ -318,7 +324,8 @@ public void removeAncestorListener(AncestorListener listener)\n    */\n   public void removePropertyChangeListener(PropertyChangeListener listener)\n   {\n-    listenerList.remove(PropertyChangeListener.class, listener);\n+    if (changeSupport != null)\n+      changeSupport.removePropertyChangeListener(listener);\n   }\n \n   /**\n@@ -350,7 +357,9 @@ public void addAncestorListener(AncestorListener listener)\n    */\n   public void addPropertyChangeListener(PropertyChangeListener listener)\n   {\n-    listenerList.add(PropertyChangeListener.class, listener);\n+    if (changeSupport == null)\n+      changeSupport = new SwingPropertyChangeSupport(this);\n+    changeSupport.addPropertyChangeListener(listener);\n   }\n \n   /**\n@@ -404,45 +413,68 @@ public void computeVisibleRect(Rectangle rect)\n \t\t//Returns the Component's \"visible rect rectangle\" - the intersection of the visible rectangles for this component and all of its ancestors.\n \t\t//super.computeVisibleRect(rect);\n \t}\n+\t\n+        public PropertyChangeListener[] getPropertyChangeListeners(String property)\n+        {\n+          return changeSupport == null ? new PropertyChangeListener[0]\n+                 : changeSupport.getPropertyChangeListeners(property);\n+        }\t\n \n \tpublic void firePropertyChange(String propertyName, boolean oldValue, boolean newValue)\n \t{\n-\t\t//Reports a bound property change.\n+          if (changeSupport != null)\n+            changeSupport.firePropertyChange(propertyName, new Boolean(oldValue), \n+\t                                     new Boolean(newValue));\n \t}\n \tpublic void firePropertyChange(String propertyName, byte oldValue, byte newValue)\n \t{\n-\t\t//    Reports a bound property change.\n+          if (changeSupport != null)\n+            changeSupport.firePropertyChange(propertyName, new Byte(oldValue), \n+\t                                     new Byte(newValue));\n \t}\n \tpublic void firePropertyChange(String propertyName, char oldValue, char newValue)\n \t{\n-\t\t//Reports a bound property change.\n+          if (changeSupport != null)\n+            changeSupport.firePropertyChange(propertyName, new Character(oldValue), \n+\t                                     new Character(newValue));\n \t}\n \n \tpublic void firePropertyChange(String propertyName, double oldValue, double newValue)\n \t{\n-\t\t//Reports a bound property change.\n+          if (changeSupport != null)\n+            changeSupport.firePropertyChange(propertyName, new Double(oldValue), \n+\t                                     new Double(newValue));\n \t}\n \n \tpublic void firePropertyChange(String propertyName, float oldValue, float newValue)\n \t{\n-\t\t//       Reports a bound property change.\n+          if (changeSupport != null)\n+            changeSupport.firePropertyChange(propertyName, new Float(oldValue), \n+\t                                     new Float(newValue));\n \t}\n \tpublic void firePropertyChange(String propertyName, int oldValue, int newValue)\n \t{\n-\t\t//       Reports a bound property change.\n+          if (changeSupport != null)\n+            changeSupport.firePropertyChange(propertyName, new Integer(oldValue), \n+\t                                     new Integer(newValue));\n \t}\n \tpublic void firePropertyChange(String propertyName, long oldValue, long newValue)\n \t{\n-\t\t//Reports a bound property change. protected\n+          if (changeSupport != null)\n+            changeSupport.firePropertyChange(propertyName, new Long(oldValue), \n+\t                                     new Long(newValue));\n \t}\n \n-  protected void firePropertyChange(String propertyName, Object oldValue, Object newValue)\n+        protected void firePropertyChange(String propertyName, Object oldValue, Object newValue)\n \t{\n-\t\t//       Support for reporting bound property changes.\n+          if (changeSupport != null)\n+            changeSupport.firePropertyChange(propertyName, oldValue, newValue);\n \t}\n \tpublic void firePropertyChange(String propertyName, short oldValue, short newValue)\n \t{\n-\t\t//       Reports a bound property change.\n+          if (changeSupport != null)\n+            changeSupport.firePropertyChange(propertyName, new Short(oldValue), \n+\t                                     new Short(newValue));\n \t}\n \n \tprotected  void fireVetoableChange(String propertyName, Object oldValue, Object newValue)\n@@ -757,14 +789,21 @@ public boolean isValidateRoot()\n \tpublic void paint(Graphics g)\n \t{\n \t\tGraphics g2 = g;\n-\t\tImage im = null;\n \t\tRectangle r = getBounds ();\n-\t\t// System.err.println(this + \".paint(...), bounds = \" + r);\n \t\t\n \t\tif (use_double_buffer)\n \t\t{\n-                  im = createImage (r.width, r.height);\n-                  g2 = im.getGraphics ();\n+\n+                  if (doubleBuffer == null \n+                      || doubleBufferWidth != r.width \n+                      || doubleBufferHeight != r.height)\n+                    {\n+                      doubleBuffer = createImage(r.width, r.height);\n+                      doubleBufferWidth = r.width;\n+                      doubleBufferHeight = r.height;\n+                    }\n+\n+                  g2 = doubleBuffer.getGraphics ();\n                   if (this.getBackground() != null)\n                     {\n                       Color save = g2.getColor();\n@@ -785,7 +824,7 @@ public void paint(Graphics g)\n \t\t\t// always draw at 0,0, because regardless of your current bounds,\n \t\t\t// the graphics object you were passed was positioned so the origin\n \t\t\t// was at the upper left corner of your bounds.\n-\t\t\tg.drawImage (im, 0, 0, (ImageObserver)null);\n+\t\t\tg.drawImage (doubleBuffer, 0, 0, (ImageObserver)null);\n \t\t}\n \t}\n "}, {"sha": "19f992c2f7f821f977efaffffca3ba9415f85c60", "filename": "libjava/javax/swing/JLabel.java", "status": "modified", "additions": 627, "deletions": 171, "changes": 798, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FJLabel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FJLabel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJLabel.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -1,5 +1,5 @@\n-/* JLabel.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+/* JLabel.java --\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,205 +35,661 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n import java.awt.Component;\n import java.awt.Image;\n+import java.awt.Font;\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n+import javax.swing.Icon;\n import javax.swing.plaf.LabelUI;\n \n+\n+/**\n+ * <p>\n+ * A swing widget that displays a text message and/or an icon. \n+ * </p>\n+ */\n public class JLabel extends JComponent implements Accessible, SwingConstants\n {\n+  /** DOCUMENT ME! */\n   private static final long serialVersionUID = 5496508283662221534L;\n+\n+  /**\n+   * The Component the label will give focus to when its mnemonic is\n+   * activated.\n+   */\n+  protected Component labelFor;\n+\n+  /** The label's text. */\n+  private transient String labelText;\n+\n+  /** Where the label will be positioned horizontally. */\n+  private transient int horizontalAlignment = CENTER;\n+\n+  /** Where the label text will be placed horizontally relative to the icon. */\n+  private transient int horizontalTextPosition = TRAILING;\n+\n+  /** Where the label will be positioned vertically. */\n+  private transient int verticalAlignment = CENTER;\n+\n+  /** Where the label text will be place vertically relative to the icon. */\n+  private transient int verticalTextPosition = CENTER;\n+\n+  /** The icon painted when the label is enabled. */\n+  private transient Icon activeIcon;\n+\n+  /** The icon painted when the label is disabled. */\n+  private transient Icon disabledIcon;\n+\n+  /** The label's mnemnonic key. */\n+  private transient char mnemonicKey;\n+\n+  /** The index of the menemonic character in the text. */\n+  private transient int underlinedChar = -1;\n+\n+  /** The gap between the icon and the text. */\n+  private transient int iconTextGap = 4;\n+\n+  /**\n+   * Fired in a PropertyChangeEvent when the \"disabledIcon\" property changes.\n+   */\n+  public static final String DISABLED_ICON_CHANGED_PROPERTY = \"disabledIcon\";\n+\n+  /**\n+   * Fired in a PropertyChangeEvent when the \"displayedMnemonic\" property\n+   * changes.\n+   */\n+  public static final String DISPLAYED_MNEMONIC_CHANGED_PROPERTY = \"displayedMnemonic\";\n   \n-    String text;\n-    Icon icon;\n-    int gap;\n-    int align;\n+  /**\n+   * Fired in a PropertyChangeEvent when the \"displayedMnemonicIndex\"\n+   * property changes. */\n+  public static final String DISPLAYED_MNEMONIC_INDEX_CHANGED_PROPERTY = \"displayedMnemonicIndex\";\n \n-    int hor_align;\n-    int hor_text_pos;\n+  /**\n+   * Fired in a PropertyChangeEvent when the \"horizontalAlignment\" property\n+   * changes.\n+   */\n+  public static final String HORIZONTAL_ALIGNMENT_CHANGED_PROPERTY = \"horizontalAlignment\";\n \n-    int vert_align;\n-    int vert_text_pos;\n+  /**\n+   * Fired in a PropertyChangeEvent when the \"horizontalTextPosition\" property\n+   * changes.\n+   */\n+  public static final String HORIZONTAL_TEXT_POSITION_CHANGED_PROPERTY = \"horizontalTextPosition\";\n \n-    public JLabel()\n-    {\n-\tthis(\"\", null, 0);\n-    }\n+  /** Fired in a PropertyChangeEvent when the \"icon\" property changes. */\n+  public static final String ICON_CHANGED_PROPERTY = \"icon\";\n \n-    public JLabel(Icon image)\n-    {\n-\tthis(\"\", image, 0);\n-    }\n+  /** Fired in a PropertyChangeEvent when the \"iconTextGap\" property changes. */\n+  public static final String ICON_TEXT_GAP_CHANGED_PROPERTY = \"iconTextGap\";\n \n-    public JLabel(Icon image, int horizontalAlignment)\n-    {\n-\tthis(\"\", image, horizontalAlignment);\n-    }\n+  /** Fired in a PropertyChangeEvent when the \"labelFor\" property changes. */\n+  public static final String LABEL_FOR_CHANGED_PROPERTY = \"labelFor\";\n \n-    public JLabel(String text)\n-    {\n-\tthis(text, null, 0);\n-    }\n+  /** Fired in a PropertyChangeEvent when the \"text\" property changes. */\n+  public static final String TEXT_CHANGED_PROPERTY = \"text\";\n \n-    public JLabel(String text, int horizontalAlignment)\n-    {\n-\tthis(text, null, horizontalAlignment);\n-    }\n+  /**\n+   * Fired in a PropertyChangeEvent when the \"verticalAlignment\" property\n+   * changes.\n+   */\n+  public static final String VERTICAL_ALIGNMENT_CHANGED_PROPERTY = \"verticalAlignment\";\n \n-    public JLabel(String text, Icon icon, int horizontalAlignment)\n-    {\n-\t// do the work.....\n-\tthis.text = text;\n-\tsetIcon(icon);\n-\tthis.align     = horizontalAlignment;\n+  /**\n+   * Fired in a PropertyChangeEvent when the \"verticalTextPosition\" property\n+   * changes.\n+   */\n+  public static final String VERTICAL_TEXT_POSITION_CHANGED_PROPERTY = \"verticalTextPosition\";\n \n-\tupdateUI(); // get a proper ui\n-    } \n+  /**\n+   * Creates a new horizontally and vertically centered JLabel object with no text and no\n+   * icon.\n+   */\n+  public JLabel()\n+  {\n+    this(null, null, CENTER);\n+  }\n \n+  /**\n+   * Creates a new horizontally and vertically centered JLabel object with no text and the\n+   * given icon.\n+   *\n+   * @param image The icon to use with the label.\n+   */\n+  public JLabel(Icon image)\n+  {\n+    this(null, image, CENTER);\n+  }\n \n-    protected  int checkHorizontalKey(int key, String message)\n-    {\n-\t//    Verify that key is a legal value for the horizontalAlignment properties. \n-\treturn 0;\n-    }\n-    protected  int checkVerticalKey(int key, String message)\n-    {\n-\t//      Verify that key is a legal value for the verticalAlignment or verticalTextPosition properties.  \n-\treturn 0;\n-    }\n-    public AccessibleContext getAccessibleContext()\n-    {\n-\t//          Get the AccessibleContext of this object \n-\treturn null;\n-    }\n-    public Icon getDisabledIcon()\n-    {\n-\t//          Returns the value of the disabledIcon property if it's been set, If it hasn't been set and the value of the icon property is an ImageIcon, we compute a \"grayed out\" version of the icon and update the disabledIcon property with that.  \n-\treturn null;\n-    }\n-    public int getDisplayedMnemonic()\n-    {\n-\t//          Return the keycode that indicates a mnemonic key.   \n-\treturn 0;\n-    }\n-    public int getHorizontalAlignment()\n-    {\n-\t//          Returns the alignment of the label's contents along the X axis.   \n-\treturn hor_align;\n-    }\n-    public int getHorizontalTextPosition()\n-    {\n-\t//          Returns the horizontal position of the label's text, relative to its image.    \n-\treturn hor_text_pos;\n-    }\n+  /**\n+   * Creates a new vertically centered JLabel object with no text and the given icon and\n+   * horizontal alignment. By default, the text is TRAILING the image.\n+   *\n+   * @param image The icon to use with the label.\n+   * @param horizontalAlignment The horizontal alignment of the label.\n+   */\n+  public JLabel(Icon image, int horizontalAlignment)\n+  {\n+    this(null, image, horizontalAlignment);\n+  }\n \n-    public Icon getIcon()\n-    {\treturn icon;    }\n+  /**\n+   * Creates a new horizontally and vertically centered JLabel object with no icon and the\n+   * given text.\n+   *\n+   * @param text The text to use with the label.\n+   */\n+  public JLabel(String text)\n+  {\n+    this(text, null, CENTER);\n+  }\n \n-    public int getIconTextGap()\n-    {\n-\t//          Returns the amount of space between the text and the icon displayed in this label.   \n-\treturn 0;\n-    }\n-    public Component getLabelFor()\n-    {\n-\t//          Get the component this is labelling.  \n-\treturn null;\n-    }\n-    public String getText()\n-    {\treturn text;    }\n+  /**\n+   * Creates a new vertically centered JLabel object with no icon and the given text and\n+   * horizontal alignment.\n+   *\n+   * @param text The text to use with the label.\n+   * @param horizontalAlignment The horizontal alignment of the label.\n+   */\n+  public JLabel(String text, int horizontalAlignment)\n+  {\n+    this(text, null, horizontalAlignment);\n+  }\n \n-    public String getUIClassID()\n-    {\treturn \"LabelUI\";    }\n+  /**\n+   * Creates a new vertically centered JLabel object with the given text, icon, and horizontal\n+   * alignment.\n+   *\n+   * @param text The text to use with the label.\n+   * @param icon The icon to use with the label.\n+   * @param horizontalAlignment The horizontal alignment of the label.\n+   */\n+  public JLabel(String text, Icon icon, int horizontalAlignment)\n+  {\n+    labelText = text;\n+    activeIcon = icon;\n+    this.horizontalAlignment = horizontalAlignment;\n+    updateUI();\n+  }\n \n-    public int getVerticalAlignment()\n-    {\n-\t//          Returns the alignment of the label's contents along the Y axis. \n-\treturn vert_align;\n-    }\n-    public int getVerticalTextPosition()\n-    {\n-\t//          Returns the vertical position of the label's text, relative to its image. \n-\treturn vert_text_pos;\n-    }\n+  /**\n+   * This method returns the label's UI delegate.\n+   *\n+   * @return The label's UI delegate.\n+   */\n+  public LabelUI getUI()\n+  {\n+    return (LabelUI) ui;\n+  }\n \n-    public boolean imageUpdate(Image img, int infoflags, int x, int y, int w, int h)\n-    {\n-\t//          This is overriden to return false if the current Icon's Image is not equal to the passed in Image img. \n-\treturn (img == icon);\n-    }\n-    protected  String paramString()\n-    {\n-\t//          Returns a string representation of this JLabel.  \n-\treturn \"JLabel\";\n-    }\n-    public void setDisabledIcon(Icon disabledIcon)\n-    {\n-\t//          Set the icon to be displayed if this JLabel is \"disabled\" (JLabel.setEnabled(false)).  \n-    }\n-    public void setDisplayedMnemonic(char aChar)\n-    {\n-\t//          Specifies the displayedMnemonic as a char value.  \n-    }\n-    public void setDisplayedMnemonic(int key)\n-    {\n-\t//          Specify a keycode that indicates a mnemonic key.  \n-    }\n-    public void setHorizontalAlignment(int alignment)\n-    {\n-\t//          Sets the alignment of the label's contents along the X axis.  \n-\thor_align = alignment;\n-    }\n-    public void setHorizontalTextPosition(int textPosition)\n-    {\n-\t//          Sets the horizontal position of the label's text, relative to its image.  \n-\thor_text_pos = textPosition;\n-    }\n-    public void setIcon(Icon icon)\n-    {\n-\tthis.icon = icon;\n-\tif (icon != null)\n-\t    {\n-                  // XXX FIXME - icons do not know their parent\n-//  \t\ticon.setParent(this);\n-\t    }\n-\trevalidate();\n-\trepaint();\n-    }\n+  /**\n+   * This method sets the label's UI delegate.\n+   *\n+   * @param ui The label's UI delegate.\n+   */\n+  public void setUI(LabelUI ui)\n+  {\n+    super.setUI(ui);\n+  }\n \n-    public void setIconTextGap(int iconTextGap)\n-    {\n-\tgap = iconTextGap;\n-    }\n-  \n-    public void setLabelFor(Component c)\n-    {\n-\t//          Set the component this is labelling.  \n-    }\n-    public void setText(String text)\n+  /**\n+   * This method resets the label's UI delegate to the default UI for the\n+   * current look and feel.\n+   */\n+  public void updateUI()\n+  {\n+    setUI((LabelUI) UIManager.getUI(this));\n+  }\n+\n+  /**\n+   * This method returns a name to identify which look and feel class will be\n+   * the UI delegate for this label.\n+   *\n+   * @return The UIClass identifier. \"LabelUI\"\n+   */\n+  public String getUIClassID()\n+  {\n+    return \"LabelUI\";\n+  }\n+\n+  /**\n+   * This method is used primarily for debugging purposes and returns a string\n+   * that can be used to represent this label.\n+   *\n+   * @return A string to represent this label.\n+   */\n+  protected String paramString()\n+  {\n+    return \"JLabel\";\n+  }\n+\n+  /**\n+   * This method returns the label text.\n+   *\n+   * @return The label text.\n+   */\n+  public String getText()\n+  {\n+    return labelText;\n+  }\n+\n+  /**\n+   * This method changes the \"text\" property. The given text will be painted\n+   * in the label.\n+   *\n+   * @param text The label's text.\n+   */\n+  public void setText(String text)\n+  {\n+    if (text != labelText)\n+      {\n+\tString oldText = labelText;\n+\tlabelText = text;\n+\tfirePropertyChange(TEXT_CHANGED_PROPERTY, oldText, labelText);\n+\tif (labelText.length() <= underlinedChar)\n+\t  setDisplayedMnemonicIndex(labelText.length() - 1);\n+      }\n+  }\n+\n+  /**\n+   * This method returns the active icon. The active icon is painted when the\n+   * label is enabled.\n+   *\n+   * @return The active icon.\n+   */\n+  public Icon getIcon()\n+  {\n+    return activeIcon;\n+  }\n+\n+  /**\n+   * This method changes the \"icon\" property. This icon (the active icon) will\n+   * be the one displayed when the label is enabled.\n+   *\n+   * @param icon The active icon.\n+   */\n+  public void setIcon(Icon icon)\n+  {\n+    if (icon != activeIcon)\n+      {\n+\tIcon oldIcon = activeIcon;\n+\tactiveIcon = icon;\n+\tfirePropertyChange(ICON_CHANGED_PROPERTY, oldIcon, activeIcon);\n+      }\n+  }\n+\n+  /**\n+   * This method returns the disabled icon. The disabled icon is painted when\n+   * the label is disabled. If the disabled icon is null and the active icon is\n+   * an ImageIcon, this method returns a grayed version of the icon. The grayed \n+   * version of the icon becomes the disabledIcon.\n+   *\n+   * @return The disabled icon.\n+   */\n+  public Icon getDisabledIcon()\n+  {\n+    //FIXME: We should be gray-scaling the active icon and then returning it\n+    if (disabledIcon == null && activeIcon instanceof ImageIcon)\n+      setDisabledIcon(activeIcon);\n+    return disabledIcon;\n+  }\n+\n+  /**\n+   * This method changes the \"disabledIcon\" property. This icon (the disabled\n+   * icon) will be the one displayed when the label is disabled.\n+   *\n+   * @param disabledIcon The disabled icon.\n+   */\n+  public void setDisabledIcon(Icon disabledIcon)\n+  {\n+    if (disabledIcon != this.disabledIcon)\n+      {\n+\tIcon oldDisabledIcon = this.disabledIcon;\n+\tthis.disabledIcon = disabledIcon;\n+\tfirePropertyChange(DISABLED_ICON_CHANGED_PROPERTY, oldDisabledIcon,\n+\t                   this.disabledIcon);\n+      }\n+  }\n+\n+  /**\n+   * This method sets the keycode that will be the label's mnemonic. If the\n+   * label is used as a label for another component, the label will give\n+   * focus to that component when the mnemonic is activated.\n+   *\n+   * @param key The keycode to use for the mnemonic.\n+   */\n+  public void setDisplayedMnemonic(int key)\n+  {\n+    setDisplayedMnemonic((char) key);\n+  }\n+\n+  /**\n+   * This method sets the character that will be the mnemonic used. If the\n+   * label is used as a label for another component, the label will give\n+   * focus to that component when the mnemonic is activated.\n+   *\n+   * @param aChar The character to use for the mnemonic.\n+   */\n+  public void setDisplayedMnemonic(char aChar)\n+  {\n+    if (aChar != mnemonicKey)\n+      {\n+\tchar oldKey = mnemonicKey;\n+\tmnemonicKey = aChar;\n+\tfirePropertyChange(DISPLAYED_MNEMONIC_CHANGED_PROPERTY, oldKey,\n+\t                   mnemonicKey);\n+\tif (labelText != null)\n+\t  setDisplayedMnemonicIndex(labelText.indexOf(mnemonicKey));\n+      }\n+  }\n+\n+  /**\n+   * This method returns the keycode that is used for the label's mnemonic.\n+   *\n+   * @return The keycode that is used for the label's mnemonic.\n+   */\n+  public int getDisplayedMnemonic()\n+  {\n+    return (int) mnemonicKey;\n+  }\n+\n+  /**\n+   * This method sets which character in the text will be  the underlined\n+   * character. If the given index is -1, then this indicates  that there is\n+   * no mnemonic. If the index is less than -1 or if the index is equal to\n+   * the length, this method will throw an IllegalArgumentException.\n+   *\n+   * @param index The index of the character to underline.\n+   *\n+   * @throws IllegalArgumentException If index less than -1 or index equals\n+   *         length.\n+   */\n+  public void setDisplayedMnemonicIndex(int index)\n+                                 throws IllegalArgumentException\n+  {\n+    if (index < -1 || labelText != null && index >= labelText.length())\n+      throw new IllegalArgumentException();\n+      \n+    if (labelText == null || labelText.charAt(index) != mnemonicKey)\n+      index = -1;\n+      \n+    if (index != underlinedChar)\n     {\n-\tthis.text = text;\n-\trevalidate();\n-\trepaint();\n+      int oldIndex = underlinedChar;  \n+      underlinedChar = index;\n+      firePropertyChange(DISPLAYED_MNEMONIC_INDEX_CHANGED_PROPERTY,\n+                         oldIndex, underlinedChar);\n     }\n+  }\n+\n+  /**\n+   * This method returns which character in the text will be  the underlined\n+   * character.\n+   *\n+   * @return The index of the character that will be underlined.\n+   */\n+  public int getDisplayedMnemonicIndex()\n+  {\n+    return underlinedChar;\n+  }\n+\n+  /**\n+   * This method ensures that the key is valid as a horizontal alignment.\n+   * Valid keys are: LEFT, CENTER, RIGHT, LEADING, TRAILING\n+   *\n+   * @param key The key to check.\n+   * @param message The message of the exception to be thrown if the key is\n+   *        invalid.\n+   *\n+   * @return The key if it's valid.\n+   *\n+   * @throws IllegalArgumentException If the key is invalid.\n+   */\n+  protected int checkHorizontalKey(int key, String message)\n+  {\n+    if (key != LEFT && key != CENTER && key != RIGHT && key != LEADING\n+        && key != TRAILING)\n+      throw new IllegalArgumentException(message);\n+    else\n+      return key;\n+  }\n+\n+  /**\n+   * This method ensures that the key is valid as a  vertical alignment. Valid\n+   * keys are: TOP, CENTER, and BOTTOM.\n+   *\n+   * @param key The key to check.\n+   * @param message The message of the exception to be thrown if the key is\n+   *        invalid.\n+   *\n+   * @return The key if it's valid.\n+   *\n+   * @throws IllegalArgumentException If the key is invalid.\n+   */\n+  protected int checkVerticalKey(int key, String message)\n+  {\n+    if (key != TOP && key != BOTTOM && key != CENTER)\n+      throw new IllegalArgumentException(message);\n+    else\n+      return key;\n+  }\n+\n+  /**\n+   * This method returns the gap between the icon and the text.\n+   *\n+   * @return The gap between the icon and the text.\n+   */\n+  public int getIconTextGap()\n+  {\n+    return iconTextGap;\n+  }\n+\n+  /**\n+   * This method changes the \"iconTextGap\" property. The iconTextGap\n+   * determines how much space there is between the icon and the text.\n+   *\n+   * @param iconTextGap The gap between the icon and the text.\n+   */\n+  public void setIconTextGap(int iconTextGap)\n+  {\n+    if (iconTextGap != this.iconTextGap)\n+      {\n+\tint oldIconTextGap = this.iconTextGap;\n+\tthis.iconTextGap = iconTextGap;\n+\tfirePropertyChange(ICON_TEXT_GAP_CHANGED_PROPERTY, oldIconTextGap,\n+\t                   iconTextGap);\n+      }\n+  }\n+\n+  /**\n+   * This method returns the vertical alignment of the label.\n+   *\n+   * @return The vertical alignment of the label.\n+   */\n+  public int getVerticalAlignment()\n+  {\n+    return verticalAlignment;\n+  }\n+\n+  /**\n+   * This method changes the \"verticalAlignment\" property of the label. The\n+   * vertical alignment determines how where the label will be placed\n+   * vertically. If the alignment is not valid, it will default to the\n+   * center.\n+   *\n+   * @param alignment The vertical alignment of the label.\n+   */\n+  public void setVerticalAlignment(int alignment)\n+  {\n+    if (alignment != verticalAlignment)\n+      {\n+\tint oldAlignment = verticalAlignment;\n+\tverticalAlignment = checkVerticalKey(alignment, \"verticalAlignment\");\n+\tfirePropertyChange(VERTICAL_ALIGNMENT_CHANGED_PROPERTY, oldAlignment,\n+\t                   verticalAlignment);\n+      }\n+  }\n+\n+  /**\n+   * This method returns the horziontal alignment of the label.\n+   *\n+   * @return The horizontal alignment of the label.\n+   */\n+  public int getHorizontalAlignment()\n+  {\n+    return horizontalAlignment;\n+  }\n+\n+  /**\n+   * This method changes the \"horizontalAlignment\" property. The horizontal\n+   * alignment determines where the label will be placed horizontally.\n+   *\n+   * @param alignment The horizontal alignment of the label.\n+   */\n+  public void setHorizontalAlignment(int alignment)\n+  {\n+    int oldAlignment = horizontalAlignment;\n+    horizontalAlignment = checkHorizontalKey(alignment, \"horizontalAlignment\");\n+    firePropertyChange(HORIZONTAL_ALIGNMENT_CHANGED_PROPERTY, oldAlignment,\n+                       horizontalAlignment);\n+  }\n+\n+  /**\n+   * This method returns the vertical text position of the label.\n+   *\n+   * @return The vertical text position of the label.\n+   */\n+  public int getVerticalTextPosition()\n+  {\n+    return verticalTextPosition;\n+  }\n+\n+  /**\n+   * This method changes the \"verticalTextPosition\" property of the label. The\n+   * vertical text position determines where the text will be placed\n+   * vertically relative to the icon.\n+   *\n+   * @param textPosition The vertical text position.\n+   */\n+  public void setVerticalTextPosition(int textPosition)\n+  {\n+    if (textPosition != verticalTextPosition)\n+      {\n+\tint oldPos = verticalTextPosition;\n+\tverticalTextPosition = checkVerticalKey(textPosition,\n+\t                                        \"verticalTextPosition\");\n+\tfirePropertyChange(VERTICAL_TEXT_POSITION_CHANGED_PROPERTY, oldPos,\n+\t                   verticalTextPosition);\n+      }\n+  }\n+\n+  /**\n+   * This method returns the horizontal text position of the label.\n+   *\n+   * @return The horizontal text position.\n+   */\n+  public int getHorizontalTextPosition()\n+  {\n+    return horizontalTextPosition;\n+  }\n+\n+  /**\n+   * This method changes the \"horizontalTextPosition\" property of the label.\n+   * The horizontal text position determines where the text will be placed\n+   * horizontally relative to the icon.\n+   *\n+   * @param textPosition The horizontal text position.\n+   */\n+  public void setHorizontalTextPosition(int textPosition)\n+  {\n+    if (textPosition != horizontalTextPosition)\n+      {\n+\tint oldPos = horizontalTextPosition;\n+\thorizontalTextPosition = checkHorizontalKey(textPosition,\n+\t                                            \"horizontalTextPosition\");\n+\tfirePropertyChange(HORIZONTAL_TEXT_POSITION_CHANGED_PROPERTY, oldPos,\n+\t                   horizontalTextPosition);\n+      }\n+  }\n+\n+  /**\n+   * This method simply returns false if the current icon image (current  icon\n+   * will depend on whether the label is enabled) is not equal to the passed\n+   * in image.\n+   *\n+   * @param img The image to check.\n+   * @param infoflags The bitwise inclusive OR of ABORT, ALLBITS, ERROR,\n+   *        FRAMEBITS, HEIGHT, PROPERTIES, SOMEBITS, and WIDTH\n+   * @param x The x position\n+   * @param y The y position\n+   * @param w The width\n+   * @param h The height\n+   *\n+   * @return Whether the current icon image is equal to the image given.\n+   */\n+  public boolean imageUpdate(Image img, int infoflags, int x, int y, int w,\n+                             int h)\n+  {\n+    Icon currIcon = (isEnabled()) ? activeIcon : disabledIcon;\n+\n+    //Is this the correct way to check for image equality?\n+    if (currIcon != null && currIcon instanceof ImageIcon)\n+      return (((ImageIcon) currIcon).getImage() == img);\n+    return false;\n+  }\n+\n+  /**\n+   * This method returns the component that the label gives focus to  when the\n+   * mnemonic is activated.\n+   *\n+   * @return The component that gets focus when the label's mnemonic is\n+   *         activated.\n+   */\n+  public Component getLabelFor()\n+  {\n+    return labelFor;\n+  }\n+\n+  /**\n+   * This method changes the \"labelFor\" property. The component that the label\n+   * is acting as a label for will request focus when the label's  mnemonic\n+   * is activated.\n+   *\n+   * @param c The component that gets focus when the label's mnemonic is\n+   *        activated.\n+   */\n+  public void setLabelFor(Component c)\n+  {\n+    if (c != labelFor)\n+      {\n+\tComponent oldLabelFor = labelFor;\n+\tlabelFor = c;\n+\tfirePropertyChange(LABEL_FOR_CHANGED_PROPERTY, oldLabelFor, labelFor);\n+      }\n+  }\n   \n-    public void setVerticalAlignment(int alignment)\n-    {\n-\t//          Sets the alignment of the label's contents along the Y axis.  \n-\tvert_align = alignment;\n-    }\n-    public void setVerticalTextPosition(int textPosition)\n-    {\n-\t//          Sets the vertical position of the label's text, relative to its image.  \n-\tvert_text_pos = textPosition;\n-    }\n-    public void updateUI()\n-    {\t\n-\tLabelUI b = (LabelUI)UIManager.getUI(this);\n-\tsetUI(b);\n-    }\n+  /**\n+   * This method overrides setFont so that we can call for a repaint\n+   * after the font is changed.\n+   *\n+   * @param f The font for this label.\n+   */\n+  public void setFont(Font f)\n+  {\n+    super.setFont(f);\n+    repaint();\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return\n+   */\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    return null;\n+  }\n }"}, {"sha": "92cce2240c17bc20fa4a81d5b3a83d508c1af053", "filename": "libjava/javax/swing/JList.java", "status": "modified", "additions": 845, "deletions": 163, "changes": 1008, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FJList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FJList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJList.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -1,4 +1,4 @@\n-/* JList.java -- \n+/* JList.java --\n    Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -35,219 +35,901 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n import java.awt.Color;\n+import java.awt.Component;\n import java.awt.Dimension;\n import java.awt.Rectangle;\n import java.util.Vector;\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n import javax.swing.event.ListDataEvent;\n import javax.swing.event.ListDataListener;\n+import javax.swing.event.ListSelectionEvent;\n import javax.swing.event.ListSelectionListener;\n import javax.swing.plaf.ListUI;\n \n+\n+/**\n+ * <p>This class is a facade over three separate objects: {@link\n+ * javax.swing.ListModel}, {@link javax.swing.ListSelectionModel} and\n+ * {@link javax.swing.plaf.ListUI}. The facade represents a unified \"list\"\n+ * concept, with independently replacable (possibly client-provided) models\n+ * for its contents and its current selection. In addition, each element in\n+ * the list is rendered via a strategy class {@link\n+ * javax.swing.ListCellRenderer}.</p>\n+ *\n+ * <p>Lists have many properties, some of which are stored in this class\n+ * while others are delegated to the list's model or selection. The\n+ * following properties are available:</p>\n+ *\n+ * <table>\n+ * <tr><th>Property                       </th><th>Stored in</th><th>Bound?</th></tr>\n+ * <tr><td>accessibleContext              </td><td>list     </td><td>no    </td></tr>\n+ * <tr><td>anchorSelectionIndex           </td><td>selection</td><td>no    </td></tr>\n+ * <tr><td>cellRenderer                   </td><td>list     </td><td>yes   </td></tr>\n+ * <tr><td>dragEnabled                    </td><td>list     </td><td>no    </td></tr>\n+ * <tr><td>firstVisibleIndex              </td><td>list     </td><td>no    </td></tr>\n+ * <tr><td>fixedCellHeight                </td><td>list     </td><td>yes   </td></tr>\n+ * <tr><td>fixedCellWidth                 </td><td>list     </td><td>yes   </td></tr>\n+ * <tr><td>lastVisibleIndex               </td><td>list     </td><td>no    </td></tr>\n+ * <tr><td>layoutOrientation              </td><td>list     </td><td>yes   </td></tr>\n+ * <tr><td>leadSelectionIndex             </td><td>selection</td><td>no    </td></tr>\n+ * <tr><td>maxSelectionIndex              </td><td>selection</td><td>no    </td></tr>\n+ * <tr><td>minSelectionIndex              </td><td>selection</td><td>no    </td></tr>\n+ * <tr><td>model                          </td><td>list     </td><td>yes   </td></tr>\n+ * <tr><td>opaque                         </td><td>list     </td><td>no    </td></tr>\n+ * <tr><td>preferredScrollableViewportSize</td><td>list     </td><td>no    </td></tr>\n+ * <tr><td>prototypeCellValue             </td><td>list     </td><td>yes   </td></tr>\n+ * <tr><td>scrollableTracksViewportHeight </td><td>list     </td><td>no    </td></tr>\n+ * <tr><td>scrollableTracksViewportWidth  </td><td>list     </td><td>no    </td></tr>\n+ * <tr><td>selectedIndex                  </td><td>selection</td><td>no    </td></tr>\n+ * <tr><td>selectedIndices                </td><td>selection</td><td>no    </td></tr>\n+ * <tr><td>selectedValue                  </td><td>model    </td><td>no    </td></tr>\n+ * <tr><td>selectedValues                 </td><td>model    </td><td>no    </td></tr>\n+ * <tr><td>selectionBackground            </td><td>list     </td><td>yes   </td></tr>\n+ * <tr><td>selectionEmpty                 </td><td>selection</td><td>no    </td></tr>\n+ * <tr><td>selectionForeground            </td><td>list     </td><td>yes   </td></tr>\n+ * <tr><td>selectionMode                  </td><td>selection</td><td>no    </td></tr>\n+ * <tr><td>selectionModel                 </td><td>list     </td><td>yes   </td></tr>\n+ * <tr><td>UI                             </td><td>list     </td><td>yes   </td></tr>\n+ * <tr><td>UIClassID                      </td><td>list     </td><td>no    </td></tr>\n+ * <tr><td>valueIsAdjusting               </td><td>list     </td><td>no    </td></tr>\n+ * <tr><td>visibleRowCount                </td><td>list     </td><td>no    </td></tr>\n+ * </table> \n+ *\n+ * @author Graydon Hoare (graydon&064;redhat.com)\n+ */\n+\n public class JList extends JComponent implements Accessible, Scrollable\n {\n   private static final long serialVersionUID = 4406629526391098046L;\n \n-    Color select_back, select_fore;\n-    ListCellRenderer render;\n-    int visibles = 8;\n-    \n-    ListModel          model;\n-    ListSelectionModel sel_model;\n+  /** \n+   * Constant value used in \"layoutOrientation\" property. This value means\n+   * that cells are laid out in multiple columns \"newspaper style\",\n+   * filling horizontally first, then vertically. \n+   */\n+  public static int HORIZONTAL_WRAP = 1;\n \n-    public JList()\n-    {\t\n-\tinit();\n-    }\n+  /** \n+   * Constant value used in \"layoutOrientation\" property. This value means\n+   * that cells are laid out in a single vertical column. This is the default. \n+   */\n+  public static int VERTICAL = 2;\n \n-    public JList(Object[] listData)\n-    {\n-\tinit();\n-\tsetListData(listData);\n-    }\n+  /** \n+   * Constant value used in \"layoutOrientation\" property. This value means\n+   * that cells are laid out in multiple columns \"newspaper style\", filling\n+   * vertically first, then horizontally. \n+   */\n+  public static int VERTICAL_WRAP = 3;\n+  \n+  /** Fired in a PropertyChangeEvent when the \"cellRenderer\" property changes. */\n+  public static final String CELL_RENDERER_PROPERTY_CHANGED = \"cellRenderer\";\n \n+  /** Fired in a PropertyChangeEvent when the \"fixedCellHeight\" property changes. */\n+  public static final String FIXED_CELL_HEIGHT_PROPERTY_CHANGED = \"fixedCellHeight\";\n \n-    public JList(Vector listData)\n-    {\n-\tinit();\n-\tsetListData(listData);\n-    }\n+  /** Fired in a PropertyChangeEvent when the \"fixedCellWidth\" property changes. */\n+  public static final String FIXED_CELL_WIDTH_PROPERTY_CHANGED = \"fixedCellWidth\";\n \n+  /** Fired in a PropertyChangeEvent when the \"layoutOrientation\" property changes. */\n+  public static final String LAYOUT_ORIENTATION_PROPERTY_CHANGED = \"layoutOrientation\";\n \n-    public JList(ListModel listData)\n-    {\n-\tinit();\n-\tsetModel(listData);\n-    }\n-    void init()\n-    {\n-\trender = new DefaultCellRenderer();\n-\t\n-\tsel_model = new DefaultListSelectionModel();\n-\tsetModel(new DefaultListModel());\n+  /** Fired in a PropertyChangeEvent when the \"model\" property changes. */\n+  public static final String MODEL_PROPERTY_CHANGED = \"model\";\n \n-\tselect_back = new Color(0,0,255);\n-\tselect_fore = new Color(255,255,255);\n+  /** Fired in a PropertyChangeEvent when the \"prototypeCellValue\" property changes. */\n+  public static final String PROTOTYPE_CELL_VALUE_PROPERTY_CHANGED = \"prototypeCellValue\";\n \n-\tupdateUI();\n-    }\n+  /** Fired in a PropertyChangeEvent when the \"selectionBackground\" property changes. */\n+  public static final String SELECTION_BACKGROUND_PROPERTY_CHANGED = \"selectionBackground\";\n \n-    \n-    public int getVisibleRowCount()\n-    { return visibles; }\n-    public void setVisibleRowCount(int visibleRowCount)\n-    {\n-\tvisibles =  visibleRowCount;\n-\tinvalidate();\n-\trepaint();\n-    }\n+  /** Fired in a PropertyChangeEvent when the \"selectionForeground\" property changes. */\n+  public static final String SELECTION_FOREGROUND_PROPERTY_CHANGED = \"selectionForeground\";\n \n-  public void addListSelectionListener (ListSelectionListener listener)\n-  {\n-    sel_model.addListSelectionListener (listener);\n-  }\n+  /** Fired in a PropertyChangeEvent when the \"selectionModel\" property changes. */\n+  public static final String SELECTION_MODEL_PROPERTY_CHANGED = \"selectionModel\";\n+\n+\n+  /**\n+   * This property indicates whether \"drag and drop\" functions are enabled\n+   * on the list.\n+   */\n+  boolean dragEnabled;\n+\n+  /** This property provides a strategy for rendering cells in the list. */\n+  ListCellRenderer cellRenderer;\n+\n+  /**\n+   * This property indicates an fixed width to assign to all cells in the\n+   * list. If its value is <code>-1</code>, no width has been\n+   * assigned. This value can be set explicitly, or implicitly by setting\n+   * the {@link #prototypeCellValue} property.\n+   */\n+  int fixedCellWidth;\n   \n-  public void removeListSelectionListener (ListSelectionListener listener)\n-  {\n-    sel_model.removeListSelectionListener (listener);\n-  }\n+  /**\n+   * This property indicates an fixed height to assign to all cells in the\n+   * list. If its value is <code>-1</code>, no height has been\n+   * assigned. This value can be set explicitly, or implicitly by setting\n+   * the {@link #prototypeCellValue} property.\n+   */\n+  int fixedCellHeight;\n+\n+  /** \n+   * This property holds the current layout orientation of the list, which\n+   * is one of the integer constants {@link #VERTICAL}, {@link\n+   * #VERTICAL_WRAP}, or {@link #HORIZONTAL_WRAP}. \n+   */\n+\n+  int layoutOrientation;\n+  \n+  /** This property holds the data elements displayed by the list. */\n+  ListModel model;\n \n   /**\n-   * @since 1.4\n+   * <p>This property holds a reference to a \"prototype\" data value --\n+   * typically a String -- which is used to calculate the {@link\n+   * #fixedCellWidth} and {@link #fixedCellHeight} properties, using the\n+   * {@link #cellRenderer} property to acquire a component to render the\n+   * prototype.</p>\n+   *\n+   * <p>It is important that you <em>not</em> set this value to a\n+   * component. It has to be a <em>data value</em> such as the objects you\n+   * would find in the list's model. Setting it to a component will have\n+   * undefined (and undesirable) affects. </p>\n    */\n-  public ListSelectionListener[] getListSelectionListeners()\n-  {\n-    throw new Error (\"not implemented\");\n-  }\n-\n-    void setSelectionMode(int a)\n-    {  sel_model.setSelectionMode(a);   }\n-    void setSelectedIndex(int a)\n-    {  sel_model.setSelectionInterval(a,a); }\n-    int getSelectedIndex()\n-    {\treturn sel_model.getMinSelectionIndex();    }\n-    Object getSelectedValue()\n-    {  \n-\tint index = getSelectedIndex();\n-\tif (index == -1)\n-\t    return null;\n-\treturn getModel().getElementAt(index);\n-    }\n+  Object prototypeCellValue;\n+\n+  /** \n+   * This property specifies a foreground color for the selected cells in\n+   * the list. When {@link ListCellRenderer.getListCellRendererComponent}\n+   * is called with a selected cell object, the component returned will\n+   * have its \"foreground\" set to this color.\n+   */\n+  Color selectionBackground;\n+\n+  /** \n+   * This property specifies a background color for the selected cells in\n+   * the list. When {@link ListCellRenderer.getListCellRendererComponent}\n+   * is called with a selected cell object, the component returned will\n+   * have its \"background\" property set to this color.\n+   */\n+  Color selectionForeground;\n+\n+  /** \n+   * This property holds a description of which data elements in the {@link\n+   * #model} property should be considered \"selected\", when displaying and\n+   * interacting with the list.\n+   */\n+  ListSelectionModel selectionModel;\n+\n \n-    Color getSelectionBackground()\n-    { return select_back;    }    \n-    Color getSelectionForeground()\n-    { return select_fore;    }\n+  /**\n+   * This property indicates that the list's selection is currently\n+   * \"adjusting\" -- perhaps due to a user actively dragging the mouse over\n+   * multiple list elements -- and is therefore likely to change again in\n+   * the near future. A {@link ListSelectionListener} might choose to delay\n+   * updating its view of the list's selection until this property is\n+   * false, meaning that the adjustment has completed.\n+   */\n+  boolean valueIsAdjusting;\n+\n+  /** \n+   * This property indicates a <em>preference</em> for the number of rows\n+   * displayed in the list, and will scale the\n+   * {@link #preferredScrollableViewportSize} property accordingly. The actual\n+   * number of displayed rows, when the list is placed in a real {@link\n+   * Viewport} or other component, may be greater or less than this number.\n+   */\n+  int visibleRowCount;\n+\n+\n+\n+  /**\n+   * Fire a {@link ListSelectionEvent} to all the registered ListSelectionListeners.\n+   */\n+  void fireSelectionValueChanged(int firstIndex, int lastIndex, boolean isAdjusting) \n+  {\n+    ListSelectionEvent evt = new ListSelectionEvent(this, firstIndex, lastIndex, isAdjusting);\n+    ListSelectionListener listeners[] = getListSelectionListeners();\n+    for (int i = 0; i < listeners.length; ++i)\n+      {\n+        listeners[i].valueChanged(evt);\n+      }\n+  }\n \n \n-    public void setListData(final Object[] listData)\n+  /**\n+   * This private listener propagates {@link ListSelectionEvent} events\n+   * from the list's \"selectionModel\" property to the list's {@link\n+   * ListSelectionListener} listeners. It also listens to {@link\n+   * ListDataEvent} events from the list's {@link #model} property. If this\n+   * class receives either type of event, it triggers repainting of the\n+   * list.\n+   */\n+  private class ListListener \n+    implements ListSelectionListener, ListDataListener\n+  {\n+    // ListDataListener events\n+    public void contentsChanged(ListDataEvent event)\n     {\n-\tclass AL extends AbstractListModel\n-\t{\n-\t    public int getSize()              { return listData.length; }\n-\t    public Object getElementAt(int i) { return listData[i];     }\n-\t};\n-\t\n-\tsetModel (new AL());\n+      JList.this.revalidate();\n+      JList.this.repaint();\n     }\n-    \n-    public void setListData(final Vector listData)\n+    public void intervalAdded(ListDataEvent event)\n     {\n-\tclass AL extends AbstractListModel \n-\t{\n-\t    public int getSize()              { return listData.size(); }\n-\t    public Object getElementAt(int i) { return listData.elementAt(i); }\n-\t};\n-\t\n-        setModel (new AL());\n+      JList.this.revalidate();\n+      JList.this.repaint();\n     }\n-    \n-    \n-    public ListCellRenderer getCellRenderer()\n-    {    return  render; }\n-    public void setCellRenderer(ListCellRenderer cellRenderer)\n+    public void intervalRemoved(ListDataEvent event)\n     {\n-\trender = cellRenderer;\n-\tinvalidate();\n-\trepaint();\n+      JList.this.revalidate();\n+      JList.this.repaint();\n     }\n-    \n-    public void setModel(ListModel model)\n+    // ListSelectionListener events\n+    public void valueChanged(ListSelectionEvent event)\n     {\n-\tListDataListener l = new ListDataListener()\n-\t    {\n-\t\tpublic void intervalAdded(ListDataEvent e) {\n-\t\t    repaint();\n-\t\t}\n-\t\tpublic void intervalRemoved(ListDataEvent e) {\n-\t\t    repaint();\n-\t\t}\n-\t\tpublic void contentsChanged(ListDataEvent e) {\n-\t\t    repaint();\n-\t\t}\n-\t    };\n-\t\n-\tthis.model = model;  \n-\tmodel.addListDataListener(l);\t\n+      JList.this.fireSelectionValueChanged(event.firstIndex,\n+                                           event.lastIndex,\n+                                           event.isAdjusting);\n+      JList.this.repaint();\n     }\n+  };\n \n-    public ListModel getModel() \n-    {  return model;        }\n-    \n-    \n-    public ListUI getUI()\n-    {  return (ListUI) ui;    }\n-    public void setUI(ListUI ui)\n-    {   super.setUI(ui);      }\n+  /** \n+   * Shared ListListener instance, subscribed to both the current {@link\n+   * #model} and {@link #selectionModel} properties of the list.\n+   */\n+  ListListener listListener;\n \n-    public void updateUI()\n-    {\n-        setUI((ListUI)UIManager.getUI(this));\n-    }\n \n-    public String getUIClassID()\n-    {\n-\treturn \"ListUI\";\n-    }\n+  /**\n+   * Creates a new JList object.\n+   */\n+  public JList()\n+  {\n+    init();\n+  }\n+\n+  /**\n+   * Creates a new JList object.\n+   *\n+   * @param listData Initial data to populate the list with\n+   */\n+  public JList(Object[] listData)\n+  {\n+    init();\n+    setListData(listData);\n+  }\n \n+  /**\n+   * Creates a new JList object.\n+   *\n+   * @param listData Initial data to populate the list with\n+   */\n+  public JList(Vector listData)\n+  {\n+    init();\n+    setListData(listData);\n+  }\n \n-    public AccessibleContext getAccessibleContext()\n-    {\n+  /**\n+   * Creates a new JList object.\n+   *\n+   * @param listData Initial data to populate the list with\n+   */\n+  public JList(ListModel listData)\n+  {\n+    init();\n+    setModel(listData);\n+  }\n+\n+  void init()\n+  {\n+    dragEnabled = false;\n+    fixedCellHeight = -1;\n+    fixedCellWidth = -1;\n+    layoutOrientation = VERTICAL;\n+    opaque = true;\n+    valueIsAdjusting = false;\n+    visibleRowCount = 8;\n+\n+    cellRenderer = new DefaultListCellRenderer();\n+    listListener = new ListListener();\n+\n+    setModel(new DefaultListModel());\n+    setSelectionModel(new DefaultListSelectionModel());\n+\n+    updateUI();\n+  }\n+\n+  /**\n+   * Gets the value of the {@link #fixedCellHeight} property. This property\n+   * may be <code>-1</code> to indicate that no cell height has been\n+   * set. This property is also set implicitly when the\n+   * {@link #prototypeCellValue} property is set.\n+   *\n+   * @return The current value of the property \n+   * \n+   * @see #fixedCellHeight\n+   * @see #setFixedCellHeight\n+   * @see #setPrototypeCellValue\n+   */\n+  public int getFixedCellHeight()\n+  {\n+    return fixedCellHeight;\n+  }\n+\n+  /**\n+   * Sets the value of the {@link #fixedCellHeight} property. This property\n+   * may be <code>-1</code> to indicate that no cell height has been\n+   * set. This property is also set implicitly when the {@link\n+   * #prototypeCellValue} property is set, but setting it explicitly\n+   * overrides the height computed from {@link #prototypeCellValue}.\n+   *\n+   * @see #getFixedCellHeight\n+   * @see #getPrototypeCellValue\n+   */\n+  public void setFixedCellHeight(int h)\n+  {\n+    int old = fixedCellHeight;\n+    fixedCellHeight = h;\n+    firePropertyChange(FIXED_CELL_WIDTH_PROPERTY_CHANGED, old, h);\n+  }\n+\n+\n+  /**\n+   * Gets the value of the {@link #fixedCellWidth} property. This property\n+   * may be <code>-1</code> to indicate that no cell width has been\n+   * set. This property is also set implicitly when the {@link\n+   * #prototypeCellValue} property is set.\n+   *\n+   * @return The current value of the property \n+   * \n+   * @see #setFixedCellWidth\n+   * @see #setPrototypeCellValue\n+   */\n+  public int getFixedCellWidth()\n+  {\n+    return fixedCellWidth;\n+  }\n+\n+  /**\n+   * Sets the value of the {@link #fixedCellWidth} property. This property\n+   * may be <code>-1</code> to indicate that no cell width has been\n+   * set. This property is also set implicitly when the {@link\n+   * #prototypeCellValue} property is set, but setting it explicitly\n+   * overrides the width computed from {@link #prototypeCellValue}.\n+   *\n+   * @see #getFixedCellWidth\n+   * @see #getPrototypeCellValue\n+   */\n+  public void setFixedCellWidth(int h)\n+  {\n+    int old = fixedCellHeight;\n+    fixedCellHeight = h;\n+    firePropertyChange(FIXED_CELL_HEIGHT_PROPERTY_CHANGED, old, h);\n+  }\n+\n+\n+  /** \n+   * Gets the value of the {@link #visibleRowCount} property. \n+   *\n+   * @return the current value of the property.\n+   */\n+\n+  public int getVisibleRowCount()\n+  {\n+    return visibleRowCount;\n+  }\n+\n+  /**\n+   * Sets the value of the {@link #visibleRowCount} property. \n+   *\n+   * @param visibleRowCount The new property value\n+   */\n+  public void setVisibleRowCount(int vc)\n+  {\n+    visibleRowCount = vc;\n+    revalidate();\n+    repaint();\n+  }\n+\n+  /**\n+   * Adds a {@link ListSelectionListener} to the listener list for this\n+   * list. The listener will be called back with a {@link\n+   * ListSelectionEvent} any time the list's {@link #selectionModel}\n+   * property changes. The source of such events will be the JList,\n+   * not the selection model.\n+   *\n+   * @param listener The new listener to add\n+   */\n+  public void addListSelectionListener(ListSelectionListener listener)\n+  {\n+    listenerList.add (ListSelectionListener.class, listener);\n+  }\n+\n+  /**\n+   * Removes a {@link ListSelectionListener} from the listener list for\n+   * this list. The listener will no longer be called when the list's\n+   * {@link #selectionModel} changes.\n+   *\n+   * @param listener The listener to remove\n+   */\n+  public void removeListSelectionListener(ListSelectionListener listener)\n+  {\n+    listenerList.remove(ListSelectionListener.class, listener);\n+  }\n+\n+  /**\n+   * Returns an array of all ListSelectionListeners subscribed to this\n+   * list. \n+   *\n+   * @return The current subscribed listeners\n+   *\n+   * @since 1.4\n+   */\n+  public ListSelectionListener[] getListSelectionListeners()\n+  {\n+    return (ListSelectionListener[]) getListeners(ListSelectionListener.class);\n+  }\n+\n+  /**\n+   * Sets the list's \"selectionMode\" property, which simply mirrors the\n+   * same property on the list's {@link #selectionModel} property. This\n+   * property should be one of the integer constants\n+   * <code>SINGLE_SELECTION</code>, <code>SINGLE_INTERVAL_SELECTION</code>,\n+   * or <code>MULTIPLE_INTERVAL_SELECTION</code> from the {@link\n+   * ListSelectionModel} interface.\n+   *\n+   * @param a The new selection mode\n+   */\n+  public void setSelectionMode(int a)\n+  {\n+    selectionModel.setSelectionMode(a);\n+  }\n+\n+  /**\n+   * Adds the interval <code>[a,a]</code> to the set of selections managed\n+   * by this list's {@link #selectionModel} property. Depending on the\n+   * selection mode, this may cause existing selections to become invalid,\n+   * or may simply expand the set of selections. \n+   *\n+   * @param a A number in the half-open range <code>[0, x)</code> where\n+   * <code>x = getModel.getSize()</code>, indicating the index of an\n+   * element in the list to select.\n+   *\n+   * @see #setSelectionMode\n+   * @see #selectionModel\n+   */\n+  public void setSelectedIndex(int a)\n+  {\n+    selectionModel.setSelectionInterval(a, a);\n+  }\n+\n+  /**\n+   * Returns the minimum index of an element in the list which is currently\n+   * selected.\n+   *\n+   * @return A number in the half-open range <code>[0, x)</code> where\n+   * <code>x = getModel.getSize()</code>, indicating the minimum index of\n+   * an element in the list for which the element is selected, or\n+   * <code>-1</code> if no elements are selected\n+   */\n+  public int getSelectedIndex()\n+  {\n+    return selectionModel.getMinSelectionIndex();\n+  }\n+\n+  /**\n+   * Indicates whether the list element at a given index value is\n+   * currently selected.\n+   *\n+   * @param a The index to check \n+   * @return <code>true</code> if <code>a</code> is the index of a selected\n+   * list element\n+   */\n+  public boolean isSelectedIndex(int a)\n+  {\n+    return selectionModel.isSelectedIndex(a);\n+  }\n+\n+  /**\n+   * Returns the first value in the list's {@link #model} property which is\n+   * selected, according to the list's {@link #selectionModel} property.\n+   * This is equivalent to calling\n+   * <code>getModel()getElementAt(getSelectedIndex())</code>, with a check\n+   * for the special index value of <code>-1</code> which returns null\n+   * <code>null</code>.\n+   *\n+   * @return The first selected element, or <code>null</code> if no element\n+   * is selected.\n+   */\n+  public Object getSelectedValue()\n+  {\n+    int index = getSelectedIndex();\n+    if (index == -1)\n       return null;\n-    }\n+    return getModel().getElementAt(index);\n+  }\n \n-    public Dimension getPreferredScrollableViewportSize()\n-    {\n-\treturn null;\n-    }\n+  /**\n+   * Gets the value of the {@link #selectionBackground} property.\n+   *\n+   * @return The current value of the property\n+   */\n+  public Color getSelectionBackground()\n+  {\n+    return selectionBackground;\n+  }\n \n-    public int getScrollableUnitIncrement(Rectangle visibleRect,\n-\t\t\t\t\t  int orientation,\n-\t\t\t\t\t  int direction)\n-    {\n-\treturn 1;\n-    }\n+  /**\n+   * Sets the value of the {@link #selectionBackground} property.\n+   *\n+   * @param c The new value of the property\n+   */\n+  public void setSelectionBackground(Color c)\n+  {\n+    Color old = selectionBackground;\n+    selectionBackground = c;\n+    firePropertyChange(SELECTION_BACKGROUND_PROPERTY_CHANGED, old, c);\n+    repaint();\n+  }\n \n-    public int getScrollableBlockIncrement(Rectangle visibleRect,\n-\t\t\t\t\t   int orientation,\n-\t\t\t\t\t   int direction)\n-    {\n-\treturn 1;\n-    }\n+  /**\n+   * Gets the value of the {@link #selectionForeground} property.\n+   *\n+   * @return The current value of the property\n+   */\n+  public Color getSelectionForeground()\n+  {\n+    return selectionForeground;\n+  }\n+  \n+  /**\n+   * Sets the value of the {@link #selectionForeground} property.\n+   *\n+   * @param c The new value of the property\n+   */\n+  public void setSelectionForeground(Color c)\n+  {\n+    Color old = selectionForeground;\n+    selectionForeground = c;\n+    firePropertyChange(SELECTION_FOREGROUND_PROPERTY_CHANGED, old, c);\n+  }\n \n-    public boolean getScrollableTracksViewportWidth()\n-    {\n-\treturn false;\n-    }\n+  /**\n+   * Sets the {@link #model} property of the list to a new anonymous\n+   * {@link AbstractListModel} subclass which accesses the provided Object\n+   * array directly.\n+   *\n+   * @param listData The object array to build a new list model on\n+   * @see #setModel\n+   */\n+  public void setListData(final Object[] listData)\n+  {\n+    setModel(new AbstractListModel()\n+        {\n+          public int getSize()\n+          {\n+            return listData.length;\n+          }\n+\n+          public Object getElementAt(int i)\n+          {\n+            return listData[i];\n+          }\n+        });\n+  }\n \n-    public boolean getScrollableTracksViewportHeight()\n-    {\n-\treturn false;\n-    }\n-    \n+  /**\n+   * Sets the {@link #model} property of the list to a new anonymous {@link\n+   * AbstractListModel} subclass which accesses the provided vector\n+   * directly.\n+   *\n+   * @param listData The object array to build a new list model on\n+   * @see #setModel\n+   */\n+  public void setListData(final Vector listData)\n+  {\n+    setModel(new AbstractListModel()\n+        {\n+          public int getSize()\n+          {\n+            return listData.size();\n+          }\n+\n+          public Object getElementAt(int i)\n+          {\n+            return listData.elementAt(i);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Gets the value of the {@link #cellRenderer} property. \n+   *\n+   * @return The current value of the property\n+   */\n+  public ListCellRenderer getCellRenderer()\n+  {\n+    return cellRenderer;\n+  }\n+\n+  /**\n+   * Sets the value of the {@link #celLRenderer} property.\n+   *\n+   * @param cellRenderer The new property value\n+   */\n+  public void setCellRenderer(ListCellRenderer cr)\n+  {\n+    ListCellRenderer old = cellRenderer;\n+    cellRenderer = cr;\n+    firePropertyChange(CELL_RENDERER_PROPERTY_CHANGED, old, cr);\n+    revalidate();\n+    repaint();\n+  }\n+\n+  /**\n+   * Gets the value of the {@link #model} property. \n+   *\n+   * @return The current value of the property\n+   */\n+  public ListModel getModel()\n+  {\n+    return model;\n+  }\n+\n+  /**\n+   * Sets the value of the {@link #model} property. The list's {@link\n+   * #listListener} is unsubscribed from the existing model, if it exists,\n+   * and re-subscribed to the new model.\n+   *\n+   * @param model The new property value\n+   */\n+  public void setModel(ListModel m)\n+  {\n+    ListModel old = model;\n+    if (old != null)\n+      old.removeListDataListener(listListener);\n+    model = m;\n+    if (model != null)\n+      model.addListDataListener(listListener);\n+    firePropertyChange(MODEL_PROPERTY_CHANGED, old, m);\n+  }\n+\n+\n+  public ListSelectionModel getSelectionModel()\n+  {\n+    return selectionModel;\n+  }\n+\n+  /**\n+   * Sets the value of the {@link #selectionModel} property. The list's\n+   * {@link #listListener} is unsubscribed from the existing selection\n+   * model, if it exists, and re-subscribed to the new selection model.\n+   *\n+   * @param l The new property value\n+   */\n+  public void setSelectionModel(ListSelectionModel l)\n+  {\n+    ListSelectionModel old = selectionModel;\n+    if (old != null)\n+      old.removeListSelectionListener(listListener);\n+    selectionModel = l;\n+    if (selectionModel != null)\n+      selectionModel.addListSelectionListener(listListener);\n+    firePropertyChange(SELECTION_MODEL_PROPERTY_CHANGED, old, l);\n+  }\n+\n+  /**\n+   * Gets the value of the UI property.\n+   *\n+   * @return The current property value\n+   */\n+  public ListUI getUI()\n+  {\n+    return (ListUI) ui;\n+  }\n+\n+  /**\n+   * Sets the value of the UI property.\n+   *\n+   * @param ui The new property value\n+   */\n+  public void setUI(ListUI ui)\n+  {\n+    super.setUI(ui);\n+  }\n+\n+  /**\n+   * Calls {@link #setUI} with the {@link ListUI} subclass\n+   * returned from calling {@link UIManager#getUI}.\n+   */\n+  public void updateUI()\n+  {\n+    setUI((ListUI) UIManager.getUI(this));\n+  }\n+\n+  /**\n+   * Return the class identifier for the list's UI property.  This should\n+   * be the constant string <code>\"ListUI\"</code>, and map to an\n+   * appropriate UI class in the {@link UIManager}.\n+   *\n+   * @return The class identifier\n+   */\n+  public String getUIClassID()\n+  {\n+    return \"ListUI\";\n+  }\n+\n+\n+  /**\n+   * Returns the current value of the {@link #prototypeCellValue}\n+   * property. This property holds a reference to a \"prototype\" data value\n+   * -- typically a String -- which is used to calculate the {@link\n+   * #fixedCellWidth} and {@link #fixedCellHeight} properties, using the\n+   * {@link #cellRenderer} property to acquire a component to render the\n+   * prototype.\n+   *\n+   * @return The current prototype cell value\n+   * @see #setPrototypeCellValue\n+   */\n+  public Object getPrototypeCellValue()\n+  {\n+    return prototypeCellValue;\n+  }\n+\n+  /**\n+   * <p>Set the {@link #prototypeCellValue} property. This property holds a\n+   * reference to a \"prototype\" data value -- typically a String -- which\n+   * is used to calculate the {@link #fixedCellWidth} and {@link\n+   * #fixedCellHeight} properties, using the {@link #cellRenderer} property\n+   * to acquire a component to render the prototype.</p>\n+   *\n+   * <p>It is important that you <em>not</em> set this value to a\n+   * component. It has to be a <em>data value</em> such as the objects you\n+   * would find in the list's model. Setting it to a component will have\n+   * undefined (and undesirable) affects. </p>\n+   *\n+   * @param obj The new prototype cell value\n+   * @see #getPrototypeCellValue\n+   */\n+  public void setPrototypeCellValue(Object obj)\n+  {\n+    Object old = prototypeCellValue;\n+    Component comp = getCellRenderer()\n+      .getListCellRendererComponent(this, obj, 0, false, false); \n+    Dimension d = comp.getPreferredSize();\n+    fixedCellWidth = d.width;\n+    fixedCellHeight = d.height;\n+    prototypeCellValue = obj;\n+    firePropertyChange(PROTOTYPE_CELL_VALUE_PROPERTY_CHANGED, old, obj);\n+  }\n+\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * Returns a size indicating how much space this list would like to\n+   * consume, when contained in a scrollable viewport. This is part of the\n+   * {@link Scrollable} interface, which interacts with {@link\n+   * ScrollPaneLayout} and {@link Viewport} to define scrollable objects.\n+   *\n+   * @return The preferred size, or <code>null</code>\n+   */\n+  public Dimension getPreferredScrollableViewportSize()\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * <p>Return the number of pixels the list must scroll in order to move a\n+   * \"unit\" of the list into the provided visible rectangle. When the\n+   * provided direction is positive, the call describes a \"downwards\"\n+   * scroll, which will be exposing a cell at a <em>greater</em> index in\n+   * the list than those elements currently showing. Then the provided\n+   * direction is negative, the call describes an \"upwards\" scroll, which\n+   * will be exposing a cell at a <em>lesser</em> index in the list than\n+   * those elements currently showing.</p>\n+   *\n+   * <p>If the provided orientation is <code>HORIZONTAL</code>, the above\n+   * comments refer to \"rightwards\" for positive direction, and \"leftwards\"\n+   * for negative.</p>\n+   * \n+   *\n+   * @param visibleRect The rectangle to scroll an element into\n+   * @param orientation One of the numeric consants <code>VERTICAL</code>\n+   * or <code>HORIZONTAL</code>\n+   * @param direction An integer indicating the scroll direction: positive means\n+   * forwards (down, right), negative means backwards (up, left)\n+   *\n+   * @return The scrollable unit increment, in pixels\n+   */\n+  public int getScrollableUnitIncrement(Rectangle visibleRect,\n+                                        int orientation, int direction)\n+  {\n+    return 1;\n+  }\n+\n+  /**\n+   * <p>Return the number of pixels the list must scroll in order to move a\n+   * \"block\" of the list into the provided visible rectangle. When the\n+   * provided direction is positive, the call describes a \"downwards\"\n+   * scroll, which will be exposing a cell at a <em>greater</em> index in\n+   * the list than those elements currently showing. Then the provided\n+   * direction is negative, the call describes an \"upwards\" scroll, which\n+   * will be exposing a cell at a <em>lesser</em> index in the list than\n+   * those elements currently showing.</p>\n+   *\n+   * <p>If the provided orientation is <code>HORIZONTAL</code>, the above\n+   * comments refer to \"rightwards\" for positive direction, and \"leftwards\"\n+   * for negative.</p>\n+   * \n+   *\n+   * @param visibleRect The rectangle to scroll an element into\n+   * @param orientation One of the numeric consants <code>VERTICAL</code>\n+   * or <code>HORIZONTAL</code>\n+   * @param direction An integer indicating the scroll direction: positive means\n+   * forwards (down, right), negative means backwards (up, left)\n+   *\n+   * @return The scrollable unit increment, in pixels\n+   */\n+  public int getScrollableBlockIncrement(Rectangle visibleRect,\n+                                         int orientation, int direction)\n+  {\n+    return 1;\n+  }\n+\n+  /**\n+   * Gets the value of the {@link #scrollableTracksViewportWidth} property.\n+   *\n+   * @return <code>true</code> if the viewport is larger (horizontally)\n+   * than the list and the list should be expanded to fit the viewport;\n+   * <code>false</code> if the viewport is smaller than the list and the\n+   * list should scroll (horizontally) within the viewport\n+   */\n+  public boolean getScrollableTracksViewportWidth()\n+  {\n+    return false;\n+  }\n+\n+  /**\n+   * Gets the value of the {@link #scrollableTracksViewportWidth} property.\n+   *\n+   * @return <code>true</code> if the viewport is larger (vertically)\n+   * than the list and the list should be expanded to fit the viewport;\n+   * <code>false</code> if the viewport is smaller than the list and the\n+   * list should scroll (vertically) within the viewport\n+   */\n+  public boolean getScrollableTracksViewportHeight()\n+  {\n+    return false;\n+  }\n }"}, {"sha": "f8bb4a5235bb88cd52dce5b558787f43cbeedf53", "filename": "libjava/javax/swing/JProgressBar.java", "status": "modified", "additions": 620, "deletions": 434, "changes": 1054, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FJProgressBar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FJProgressBar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJProgressBar.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -47,442 +47,628 @@\n import javax.accessibility.AccessibleValue;\n import javax.swing.event.ChangeEvent;\n import javax.swing.event.ChangeListener;\n+import javax.swing.event.EventListenerList;\n import javax.swing.plaf.ProgressBarUI;\n \n+\n /**\n- * JProgressBar\n- * @author\tAndrew Selkirk\n- * @version\t1.0\n+ * <p>\n+ * The ProgressBar is a widget that displays in two modes. In \n+ * determinate mode, it displays fills a percentage of its bar\n+ * based on its current value. In indeterminate mode, it creates\n+ * box and bounces it between its bounds.\n+ * </p>\n+ *\n+ * <p>\n+ * JProgressBars have the following properties:\n+ * </p>\n+ * \n+ * <table>\n+ * <tr><th> Property         </td><th> Stored in   </td><th> Bound? </td></tr>\n+ * <tr><td> borderPainted    </td><td> progressBar </td><td> yes    </td></tr>\n+ * <tr><td> changeListeners  </td><td> progressBar </td><td> no     </td></tr>\n+ * <tr><td> indeterminate    </td><td> progressBar </td><td> yes    </td></tr> \n+ * <tr><td> maximum          </td><td> model       </td><td> no     </td></tr>\n+ * <tr><td> minimum          </td><td> model       </td><td> no     </td></tr>\n+ * <tr><td> model            </td><td> progressBar </td><td> no     </td></tr> \n+ * <tr><td> orientation      </td><td> progressBar </td><td> yes    </td></tr>\n+ * <tr><td> percentComplete  </td><td> progressBar </td><td> no     </td></tr>\n+ * <tr><td> string           </td><td> progressBar </td><td> yes    </td></tr>\n+ * <tr><td> stringPainted    </td><td> progressBar </td><td> yes    </td></tr>\n+ * <tr><td> value            </td><td> model       </td><td> no     </td></tr>\n+ * </table>\n  */\n-public class JProgressBar extends JComponent implements SwingConstants, Accessible\n+public class JProgressBar extends JComponent implements SwingConstants,\n+                                                        Accessible\n {\n-\n-\t//-------------------------------------------------------------\n-\t// Classes ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\n-\t/**\n-\t * AccessibleJProgressBar\n-\t */\n-\tprotected class AccessibleJProgressBar extends AccessibleJComponent \n-\t\t\timplements AccessibleValue {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Variables --------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor AccessibleJProgressBar\n-\t\t * @param component TODO\n-\t\t */\n-\t\tprotected AccessibleJProgressBar(JProgressBar component) {\n-\t\t\tsuper(component);\n-\t\t\t// TODO\n-\t\t} // AccessibleJProgressBar()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * getAccessibleStateSet\n-\t\t * @returns AccessibleStateSet\n-\t\t */\n-\t\tpublic AccessibleStateSet getAccessibleStateSet() {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleStateSet()\n-\n-\t\t/**\n-\t\t * getAccessibleRole\n-\t\t * @returns AccessibleRole\n-\t\t */\n-\t\tpublic AccessibleRole getAccessibleRole() {\n-\t\t\treturn AccessibleRole.PROGRESS_BAR;\n-\t\t} // getAccessibleRole()\n-\n-\t\t/**\n-\t\t * getAccessibleValue\n-\t\t * @returns AccessibleValue\n-\t\t */\n-\t\tpublic AccessibleValue getAccessibleValue() {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleValue()\n-\n-\t\t/**\n-\t\t * getCurrentAccessibleValue\n-\t\t * @returns Number\n-\t\t */\n-\t\tpublic Number getCurrentAccessibleValue() {\n-\t\t\treturn null; // TODO\n-\t\t} // getCurrentAccessibleValue()\n-\n-\t\t/**\n-\t\t * setCurrentAccessibleValue\n-\t\t * @param value0 TODO\n-\t\t * @returns boolean\n-\t\t */\n-\t\tpublic boolean setCurrentAccessibleValue(Number value0) {\n-\t\t\treturn false; // TODO\n-\t\t} // setCurrentAccessibleValue()\n-\n-\t\t/**\n-\t\t * getMinimumAccessibleValue\n-\t\t * @returns Number\n-\t\t */\n-\t\tpublic Number getMinimumAccessibleValue() {\n-\t\t\treturn null; // TODO\n-\t\t} // getMinimumAccessibleValue()\n-\n-\t\t/**\n-\t\t * getMaximumAccessibleValue\n-\t\t * @returns Number\n-\t\t */\n-\t\tpublic Number getMaximumAccessibleValue() {\n-\t\t\treturn null; // TODO\n-\t\t} // getMaximumAccessibleValue()\n-\n-\n-\t} // AccessibleJProgressBar\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * uiClassID\n-\t */\n-\tprivate static final String uiClassID = \"ProgressBarUI\";\n-\n-\t/**\n-\t * orientation\n-\t */\n-\tprotected int orientation;\n-\n-\t/**\n-\t * paintBorder\n-\t */\n-\tprotected boolean paintBorder;\n-\n-\t/**\n-\t * model\n-\t */\n-\tprotected BoundedRangeModel model;\n-\n-\t/**\n-\t * progressString\n-\t */\n-\tprotected String progressString;\n-\n-\t/**\n-\t * paintString\n-\t */\n-\tprotected boolean paintString;\n-\n-\t/**\n-\t * changeEvent\n-\t */\n-\tprotected transient ChangeEvent changeEvent;\n-\n-\t/**\n-\t * changeListener\n-\t */\n-\tprotected ChangeListener changeListener;\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor JProgressBar\n-\t */\n-\tpublic JProgressBar() {\n-\t\t// TODO\n-\t} // JProgressBar()\n-\n-\t/**\n-\t * Constructor JProgressBar\n-\t * @param orientation TODO\n-\t */\n-\tpublic JProgressBar(int orientation) {\n-\t\t// TODO\n-\t} // JProgressBar()\n-\n-\t/**\n-\t * Constructor JProgressBar\n-\t * @param minimum TODO\n-\t * @param maximum TODO\n-\t */\n-\tpublic JProgressBar(int minimum, int maximum) {\n-\t\t// TODO\n-\t} // JProgressBar()\n-\n-\t/**\n-\t * Constructor JProgressBar\n-\t * @param minimum TODO\n-\t * @param maximum TODO\n-\t * @param orientation TODO\n-\t */\n-\tpublic JProgressBar(int minimum, int maximum, int orientation) {\n-\t\t// TODO\n-\t} // JProgressBar()\n-\n-\t/**\n-\t * Constructor JProgressBar\n-\t * @param model TODO\n-\t */\n-\tpublic JProgressBar(BoundedRangeModel model) {\n-\t\t// TODO\n-\t} // JProgressBar()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * writeObject\n-\t * @param stream TODO\n-\t * @exception IOException TODO\n-\t */\n-\tprivate void writeObject(ObjectOutputStream stream) throws IOException {\n-\t\t// TODO\n-\t} // writeObject()\n-\n-\t/**\n-\t * getValue\n-\t * @returns int\n-\t */\n-\tpublic int getValue() {\n-\t\treturn 0; // TODO\n-\t} // getValue()\n-\n-\t/**\n-\t * setValue\n-\t * @param value TODO\n-\t */\n-\tpublic void setValue(int value) {\n-\t\t// TODO\n-\t} // setValue()\n-\n-\t/**\n-\t * paintBorder\n-\t * @param graphics TODO\n-\t */\n-\tprotected void paintBorder(Graphics graphics) {\n-\t\t// TODO\n-\t} // paintBorder()\n-\n-\t/**\n-\t * getOrientation\n-\t * @returns int\n-\t */\n-\tpublic int getOrientation() {\n-\t\treturn 0; // TODO\n-\t} // getOrientation()\n-\n-\t/**\n-\t * setOrientation\n-\t * @param orientation TODO\n-\t */\n-\tpublic void setOrientation(int orientation) {\n-\t\t// TODO\n-\t} // setOrientation()\n-\n-\t/**\n-\t * isStringPainted\n-\t * @returns boolean\n-\t */\n-\tpublic boolean isStringPainted() {\n-\t\treturn false; // TODO\n-\t} // isStringPainted()\n-\n-\t/**\n-\t * setStringPainted\n-\t * @param painted TODO\n-\t */\n-\tpublic void setStringPainted(boolean painted) {\n-\t\t// TODO\n-\t} // setStringPainted()\n-\n-\t/**\n-\t * getString\n-\t * @returns String\n-\t */\n-\tpublic String getString() {\n-\t\treturn null; // TODO\n-\t} // getString()\n-\n-\t/**\n-\t * setString\n-\t * @param string TODO\n-\t */\n-\tpublic void setString(String string) {\n-\t\t// TODO\n-\t} // setString()\n-\n-\t/**\n-\t * getPercentComplete\n-\t * @returns double\n-\t */\n-\tpublic double getPercentComplete() {\n-\t\treturn 0.0; // TODO\n-\t} // getPercentComplete()\n-\n-\t/**\n-\t * isBorderPainted\n-\t * @returns boolean\n-\t */\n-\tpublic boolean isBorderPainted() {\n-\t\treturn false; // TODO\n-\t} // isBorderPainted()\n-\n-\t/**\n-\t * setBorderPainted\n-\t * @param painted TODO\n-\t */\n-\tpublic void setBorderPainted(boolean painted) {\n-\t\t// TODO\n-\t} // setBorderPainted()\n-\n-\t/**\n-\t * getUI\n-\t * @returns ProgressBarUI\n-\t */\n-\tpublic ProgressBarUI getUI() {\n-\t\treturn (ProgressBarUI) ui;\n-\t} // getUI()\n-\n-\t/**\n-\t * setUI\n-\t * @param ui TODO\n-\t */\n-\tpublic void setUI(ProgressBarUI ui) {\n-\t\tsuper.setUI(ui);\n-\t\t// TODO\n-\t} // setUI()\n-\n-\t/**\n-\t * updateUI\n-\t */\n-\tpublic void updateUI() {\n-\t\tsetUI((ProgressBarUI) UIManager.get(this));\n-\t\tinvalidate();\n-\t} // updateUI()\n-\n-\t/**\n-\t * getUIClassID\n-\t * @returns String\n-\t */\n-\tpublic String getUIClassID() {\n-\t\treturn uiClassID;\n-\t} // getUIClassID()\n-\n-\t/**\n-\t * createChangeListener\n-\t * @returns ChangeListener\n-\t */\n-\tprotected ChangeListener createChangeListener() {\n-\t\treturn null; // TODO\n-\t} // createChangeListener()\n-\n-\t/**\n-\t * addChangeListener\n-\t * @param listener TODO\n-\t */\n-\tpublic void addChangeListener(ChangeListener listener) {\n-\t\t// TODO\n-\t} // addChangeListener()\n-\n-\t/**\n-\t * removeChangeListener\n-\t * @param listener TODO\n-\t */\n-\tpublic void removeChangeListener(ChangeListener valulistener) {\n-\t\t// TODO\n-\t} // removeChangeListener()\n-\n-\t/**\n-\t * fireStateChanged\n-\t */\n-\tprotected void fireStateChanged() {\n-\t\t// TODO\n-\t} // fireStateChanged()\n-\n-\t/**\n-\t * getModel\n-\t * @returns BoundedRangeModel\n-\t */\n-\tpublic BoundedRangeModel getModel() {\n-\t\treturn null; // TODO\n-\t} // getModel()\n-\n-\t/**\n-\t * setModel\n-\t * @param model TODO\n-\t */\n-\tpublic void setModel(BoundedRangeModel model) {\n-\t\t// TODO\n-\t} // setModel()\n-\n-\t/**\n-\t * getMinimum\n-\t * @returns int\n-\t */\n-\tpublic int getMinimum() {\n-\t\treturn 0; // TODO\n-\t} // getMinimum()\n-\n-\t/**\n-\t * setMinimum\n-\t * @param minimum TODO\n-\t */\n-\tpublic void setMinimum(int minimum) {\n-\t\t// TODO\n-\t} // setMinimum()\n-\n-\t/**\n-\t * getMaximum\n-\t * @returns int\n-\t */\n-\tpublic int getMaximum() {\n-\t\treturn 0; // TODO\n-\t} // getMaximum()\n-\n-\t/**\n-\t * setMaximum\n-\t * @param maximum TODO\n-\t */\n-\tpublic void setMaximum(int maximum) {\n-\t\t// TODO\n-\t} // setMaximum()\n-\n-\t/**\n-\t * paramString\n-\t * @returns String\n-\t */\n-\tprotected String paramString() {\n-\t\treturn null; // TODO\n-\t} // paramString()\n-\n-\t/**\n-\t * getAccessibleContext\n-\t * @returns AccessibleContext\n-\t */\n-\tpublic AccessibleContext getAccessibleContext() {\n-\t\tif (accessibleContext == null) {\n-\t\t\taccessibleContext = new AccessibleJProgressBar(this);\n-\t\t} // if\n-\t\treturn accessibleContext;\n-\t} // getAccessibleContext()\n-\n-\n-} // JProgressBar\n+  /**\n+   * AccessibleJProgressBar\n+   */\n+  protected class AccessibleJProgressBar extends AccessibleJComponent\n+    implements AccessibleValue\n+  {\n+    /**\n+     * Constructor AccessibleJProgressBar\n+     *\n+     * @param component TODO\n+     */\n+    protected AccessibleJProgressBar(JProgressBar component)\n+    {\n+      super(component);\n+    } \n+\n+    /**\n+     * getAccessibleStateSet\n+     *\n+     * @return AccessibleStateSet\n+     */\n+    public AccessibleStateSet getAccessibleStateSet()\n+    {\n+      return null; \n+    } \n+\n+    /**\n+     * getAccessibleRole\n+     *\n+     * @return AccessibleRole\n+     */\n+    public AccessibleRole getAccessibleRole()\n+    {\n+      return AccessibleRole.PROGRESS_BAR;\n+    } \n+\n+    /**\n+     * getAccessibleValue\n+     *\n+     * @return AccessibleValue\n+     */\n+    public AccessibleValue getAccessibleValue()\n+    {\n+      return null;\n+    } \n+\n+    /**\n+     * getCurrentAccessibleValue\n+     *\n+     * @return Number\n+     */\n+    public Number getCurrentAccessibleValue()\n+    {\n+      return null;\n+    } \n+\n+    /**\n+     * setCurrentAccessibleValue\n+     *\n+     * @param value0 TODO\n+     *\n+     * @return boolean\n+     */\n+    public boolean setCurrentAccessibleValue(Number value0)\n+    {\n+      return false; \n+    } \n+\n+    /**\n+     * getMinimumAccessibleValue\n+     *\n+     * @return Number\n+     */\n+    public Number getMinimumAccessibleValue()\n+    {\n+      return null; \n+    } \n+\n+    /**\n+     * getMaximumAccessibleValue\n+     *\n+     * @return Number\n+     */\n+    public Number getMaximumAccessibleValue()\n+    {\n+      return null; \n+    } \n+  } \n+\n+  /** Fired in a PropertyChangeEvent when the \"borderPainted\" property changes. */\n+  public static final String BORDER_PAINTED_CHANGED_PROPERTY = \"borderPainted\";\n+  \n+  /** Fired in a PropertyChangeEvent when the \"orientation\" property changes. */\n+  public static final String ORIENTATION_CHANGED_PROPERTY = \"orientation\";\n+  \n+  /** Fired in a PropertyChangeEvent when the \"string\" property changes. */\n+  public static final String STRING_CHANGED_PROPERTY = \"string\";\n+  \n+  /** Fired in a PropertyChangeEvent when the \"stringPainted\" property changes. */\n+  public static final String STRING_PAINTED_CHANGED_PROPERTY = \"stringPainted\";\n+  \n+  /** Fired in a PropertyChangeEvent when the \"indeterminate\" property changes. */\n+  public static final String INDETERMINATE_CHANGED_PROPERTY = \"indeterminate\";\n+\n+  /** A list of ChangeListeners registered with this ProgressBar. */\n+  private transient EventListenerList changeListenerList;\n+\n+  /** Whether the ProgressBar is determinate. */\n+  private transient boolean indeterminate = false;\n+\n+  /** The orientation of the ProgressBar */\n+  protected int orientation = HORIZONTAL;\n+\n+  /** Whether borders should be painted. */\n+  protected boolean paintBorder = true;\n+\n+  /** The model describing this ProgressBar. */\n+  protected BoundedRangeModel model;\n+\n+  /** The string that is displayed by the ProgressBar. */\n+  protected String progressString;\n+\n+  /** Whether the string should be painted. */\n+  protected boolean paintString = false;\n+\n+  /** The static changeEvent passed to all ChangeListeners. */\n+  protected transient ChangeEvent changeEvent;\n+\n+  /** The ChangeListener that listens to the model. */\n+  protected ChangeListener changeListener;\n+\n+  /**\n+   * Creates a new horizontally oriented JProgressBar object \n+   * with a minimum of 0 and a maximum of 100.\n+   */\n+  public JProgressBar()\n+  {\n+    this(0, 100, HORIZONTAL);\n+  }\n+\n+  /**\n+   * Creates a new JProgressBar object with a minimum of 0,\n+   * a maximum of 100, and the given orientation.\n+   *\n+   * @param orientation The orientation of the JProgressBar.\n+   */\n+  public JProgressBar(int orientation)\n+  {\n+    this(0, 100, orientation);\n+  }\n+\n+  /**\n+   * Creates a new horizontally oriented JProgressBar object\n+   * with the given minimum and maximum.\n+   *\n+   * @param minimum The minimum of the JProgressBar.\n+   * @param maximum The maximum of the JProgressBar.\n+   */\n+  public JProgressBar(int minimum, int maximum)\n+  {\n+    this(minimum, maximum, HORIZONTAL);\n+  }\n+\n+  /**\n+   * Creates a new JProgressBar object with the given minimum,\n+   * maximum, and orientation.\n+   *\n+   * @param minimum The minimum of the JProgressBar.\n+   * @param maximum The maximum of the JProgressBar.\n+   * @param orientation The orientation of the JProgressBar.\n+   */\n+  public JProgressBar(int minimum, int maximum, int orientation)\n+  {\n+    model = new DefaultBoundedRangeModel(minimum, 0, minimum, maximum);\n+    if (orientation != HORIZONTAL && orientation != VERTICAL)\n+      throw new IllegalArgumentException(orientation + \" is not a legal orientation\");    \n+    this.orientation = orientation;\n+    changeListener = createChangeListener();\n+    model.addChangeListener(changeListener);\n+    changeListenerList = new EventListenerList();\n+    updateUI();\n+  }\n+\n+  /**\n+   * Creates a new horizontally oriented JProgressBar object \n+   * with the given model.\n+   *\n+   * @param model The model to be used with the JProgressBar.\n+   */\n+  public JProgressBar(BoundedRangeModel model)\n+  {\n+    this.model = model;\n+    changeListener = createChangeListener();\n+    model.addChangeListener(changeListener);\n+    changeListenerList = new EventListenerList();\n+    updateUI();    \n+  }\n+\n+  /**\n+   * This method returns the current value of the JProgressBar.\n+   *\n+   * @return The current value of the JProgressBar.\n+   */\n+  public int getValue()\n+  {\n+    return model.getValue();\n+  }\n+\n+  /**\n+   * This method sets the value of the JProgressBar.\n+   *\n+   * @param value The value of the JProgressBar.\n+   */\n+  public void setValue(int value)\n+  {\n+    model.setValue(value);\n+  }\n+\n+  /**\n+   * This method paints the border of the JProgressBar\n+   *\n+   * @param graphics The graphics object to paint with.\n+   */\n+  protected void paintBorder(Graphics graphics)\n+  {\n+    getBorder().paintBorder(this, graphics, 0, 0,\n+                            getWidth(),\n+                            getHeight());\n+  }\n+\n+  /**\n+   * This method returns the orientation of the JProgressBar.\n+   *\n+   * @return The orientation of the JProgressBar.\n+   */\n+  public int getOrientation()\n+  {\n+    return orientation;\n+  }\n+\n+  /**\n+   * This method changes the orientation property. The orientation of the \n+   * JProgressBar can be either horizontal or vertical.\n+   *\n+   * @param orientation The orientation of the JProgressBar.\n+   */\n+  public void setOrientation(int orientation)\n+  {\n+    if (orientation != VERTICAL && orientation != HORIZONTAL)\n+      throw new IllegalArgumentException(\"orientation must be one of VERTICAL or HORIZONTAL\");\n+    if (this.orientation != orientation)\n+      {\n+\tint oldOrientation = this.orientation;\n+\tthis.orientation = orientation;\n+\tfirePropertyChange(ORIENTATION_CHANGED_PROPERTY, oldOrientation,\n+\t                   this.orientation);\n+      }\n+  }\n+\n+  /**\n+   * This method returns whether the progressString will be painted.\n+   *\n+   * @return Whether the string is painted.\n+   */\n+  public boolean isStringPainted()\n+  {\n+    return paintString;\n+  }\n+\n+  /**\n+   * This method changes the stringPainted property.\n+   *\n+   * @param painted Whether the string is painted.\n+   */\n+  public void setStringPainted(boolean painted)\n+  {\n+    if (paintString != painted)\n+      {\n+\tboolean oldPainted = paintString;\n+\tpaintString = painted;\n+\tfirePropertyChange(STRING_PAINTED_CHANGED_PROPERTY, oldPainted,\n+\t                   paintString);\n+      }\n+  }\n+\n+  /**\n+   * This method returns the string that is painted if the \n+   * stringPainted property is set to true. If there is no\n+   * string set, it will return a string containing the \n+   * JProgressBar's value as a percent.\n+   *\n+   * @return The string that is painted.\n+   */\n+  public String getString()\n+  {\n+    if (progressString != null)\n+      return progressString;\n+    else\n+      return (int) (getPercentComplete() * 100) + \"%\";\n+  }\n+\n+  /**\n+   * This method changes the string property. The string\n+   * given will be the one painted. If you want to \n+   * revert to the default string given, set the\n+   * string to null.\n+   *\n+   * @param string The string to be painted.\n+   */\n+  public void setString(String string)\n+  {\n+    if (((string == null || progressString == null) &&\n+        string != progressString) || (string != null &&\n+\t! string.equals(progressString)))\n+      {\n+\tString oldString = progressString;\n+\tprogressString = string;\n+\tfirePropertyChange(STRING_CHANGED_PROPERTY, oldString, progressString);\n+      }\n+  }\n+\n+  /**\n+   * This method returns the percent of the bar\n+   * that is \"complete\". (This is the amount value / (max - min)).\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public double getPercentComplete()\n+  {\n+    if (getMaximum() == getMinimum())\n+      return 1.0;\n+    else\n+      return (double) (model.getValue() - model.getMinimum()) / (model\n+                                                                 .getMaximum()\n+             - model.getMinimum());\n+  }\n+\n+  /**\n+   * This method returns whether the border is painted.\n+   *\n+   * @return Whether the border is painted.\n+   */\n+  public boolean isBorderPainted()\n+  {\n+    return paintBorder;\n+  }\n+\n+  /**\n+   * This method changes the borderPainted property.\n+   *\n+   * @param painted Whether the border is painted.\n+   */\n+  public void setBorderPainted(boolean painted)\n+  {\n+    if (painted != paintBorder)\n+      {\n+\tboolean oldPainted = paintBorder;\n+\tpaintBorder = painted;\n+\tfirePropertyChange(BORDER_PAINTED_CHANGED_PROPERTY, oldPainted,\n+\t                   paintBorder);\n+      }\n+  }\n+\n+  /**\n+   * This method returns the JProgressBar's UI delegate.\n+   *\n+   * @return This JProgressBar's UI delegate.\n+   */\n+  public ProgressBarUI getUI()\n+  {\n+    return (ProgressBarUI) ui;\n+  }\n+\n+  /**\n+   * This method changes the UI property for this JProgressBar.\n+   *\n+   * @param ui The new UI delegate.\n+   */\n+  public void setUI(ProgressBarUI ui)\n+  {\n+    super.setUI(ui);\n+  }\n+\n+  /**\n+   * This method reverts the UI delegate for this JProgressBar\n+   * to the default for this Look and Feel.\n+   */\n+  public void updateUI()\n+  {\n+    setUI((ProgressBarUI) UIManager.getUI(this));\n+    invalidate();\n+  }\n+\n+  /**\n+   * This method returns the identifier to allow the UIManager\n+   * to pick the correct class to act as the UI for\n+   * this JProgressBar.\n+   *\n+   * @return The UIClassID: \"ProgressBarUI\".\n+   */\n+  public String getUIClassID()\n+  {\n+    return \"ProgressBarUI\";\n+  }\n+\n+  /**\n+   * This method returns a ChangeListener that gets registered\n+   * model. By default, the ChangeListener, propagates the \n+   * ChangeEvents to the ChangeListeners of the JProgressBar.\n+   *\n+   * @return A new ChangeListener.\n+   */\n+  protected ChangeListener createChangeListener()\n+  {\n+    return new ChangeListener()\n+      {\n+\tpublic void stateChanged(ChangeEvent ce)\n+\t{\n+\t  fireStateChanged();\n+\t}\n+      };\n+  }\n+\n+  /**\n+   * This method adds a ChangeListener to this JProgressBar.\n+   *\n+   * @param listener The ChangeListener to add to this JProgressBar.\n+   */\n+  public void addChangeListener(ChangeListener listener)\n+  {\n+    changeListenerList.add(ChangeListener.class, listener);\n+  }\n+\n+  /**\n+   * This method removes a ChangeListener from this JProgressBar.\n+   *\n+   * @param listener The ChangeListener to remove from this JProgressBar.\n+   */\n+  public void removeChangeListener(ChangeListener listener)\n+  {\n+    changeListenerList.remove(ChangeListener.class, listener);\n+  }\n+  \n+  /**\n+   * This method returns an array of all ChangeListeners listening to this\n+   * progress bar.\n+   *\n+   * @return An array of ChangeListeners listening to this progress bar.\n+   */\n+  public ChangeListener[] getChangeListeners()\n+  {\n+    return (ChangeListener[]) changeListenerList.getListenerList();\n+  }  \n+\n+  /**\n+   * This method is called when the JProgressBar receives a ChangeEvent\n+   * from its model. This simply propagates the event (changing the source\n+   * to the JProgressBar) to the JProgressBar's listeners.\n+   */\n+  protected void fireStateChanged()\n+  {\n+    Object[] changeListeners = changeListenerList.getListenerList();\n+    if (changeEvent == null)\n+      changeEvent = new ChangeEvent(this);\n+    for (int i = changeListeners.length - 2; i >= 0; i -= 2)\n+      {\n+\tif (changeListeners[i] == ChangeListener.class)\n+\t  ((ChangeListener) changeListeners[i + 1]).stateChanged(changeEvent);\n+      }\n+  }\n+\n+  /**\n+   * This method returns the model used with this JProgressBar.\n+   *\n+   * @return The model used with this JProgressBar.\n+   */\n+  public BoundedRangeModel getModel()\n+  {\n+    return model;\n+  }\n+\n+  /**\n+   * This method changes the model property for this JProgressBar.\n+   *\n+   * @param model The model to use with this JProgressBar.\n+   */\n+  public void setModel(BoundedRangeModel model)\n+  {\n+    if (model != this.model)\n+      {\n+        this.model.removeChangeListener(changeListener);\n+\tthis.model = model;\n+\tthis.model.addChangeListener(changeListener);\n+\tfireStateChanged();\n+      }\n+  }\n+\n+  /**\n+   * This method returns the minimum value of this JProgressBar.\n+   *\n+   * @return The minimum value of this JProgressBar.\n+   */\n+  public int getMinimum()\n+  {\n+    return model.getMinimum();\n+  }\n+\n+  /**\n+   * This method sets the minimum value of this JProgressBar.\n+   *\n+   * @param minimum The minimum value of this JProgressBar.\n+   */\n+  public void setMinimum(int minimum)\n+  {\n+    model.setMinimum(minimum);\n+  }\n+\n+  /**\n+   * This method returns the maximum value of this JProgressBar.\n+   *\n+   * @return The maximum value of this JProgressBar.\n+   */\n+  public int getMaximum()\n+  {\n+    return model.getMaximum();\n+  }\n+\n+  /**\n+   * This method sets the maximum value of this JProgressBar.\n+   *\n+   * @param maximum The maximum value of this JProgressBar.\n+   */\n+  public void setMaximum(int maximum)\n+  {\n+    model.setMaximum(maximum);\n+  }\n+\n+  /**\n+   * This method returns a string that can be used to \n+   * describe this JProgressBar. This method is usually\n+   * only used for debugging purposes.\n+   *\n+   * @return A string that describes this JProgressBar.\n+   */\n+  protected String paramString()\n+  {\n+    return \"JProgressBar\";\n+  }\n+\n+  /**\n+   * This method changes the indeterminate property. If the\n+   * JProgressBar is determinate, it paints a percentage\n+   * of the bar described by its value. If it is indeterminate,\n+   * it simply bounces a box between the ends of the bar; the \n+   * value of the JProgressBar is ignored.\n+   *\n+   * @param newValue Whether the JProgressBar is indeterminate.\n+   */\n+  public void setIndeterminate(boolean newValue)\n+  {\n+    if (indeterminate != newValue)\n+      {\n+\tboolean olddeter = indeterminate;\n+\tindeterminate = newValue;\n+\tfirePropertyChange(INDETERMINATE_CHANGED_PROPERTY, olddeter,\n+\t                   indeterminate);\n+      }\n+  }\n+\n+  /**\n+   * This method returns whether the JProgressBar is indeterminate.\n+   *\n+   * @return Whether this JProgressBar is indeterminate.\n+   */\n+  public boolean isIndeterminate()\n+  {\n+    return indeterminate;\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    if (accessibleContext == null)\n+      accessibleContext = new AccessibleJProgressBar(this);\n+    return accessibleContext;\n+  } \n+}"}, {"sha": "7ee0510fdc9a00c128167ea74953fe0d668521fd", "filename": "libjava/javax/swing/JScrollBar.java", "status": "modified", "additions": 698, "deletions": 4, "changes": 702, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FJScrollBar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FJScrollBar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJScrollBar.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -1,5 +1,5 @@\n-/* JScrollBar.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+/* JScrollBar.java --\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,13 +35,707 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n import java.awt.Adjustable;\n+import java.awt.Dimension;\n+import java.awt.event.AdjustmentEvent;\n import java.awt.event.AdjustmentListener;\n import javax.accessibility.Accessible;\n+import javax.accessibility.AccessibleContext;\n+import javax.accessibility.AccessibleRole;\n+import javax.accessibility.AccessibleStateSet;\n+import javax.accessibility.AccessibleValue;\n+import javax.swing.SwingConstants;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+import javax.swing.event.EventListenerList;\n+import javax.swing.plaf.ProgressBarUI;\n+import javax.swing.plaf.ScrollBarUI;\n+\n \n-public class JScrollBar extends JComponent\n+/**\n+ * The JScrollBar. Two buttons control how the values that the \n+ * scroll bar can take. You can also drag the thumb or click the track\n+ * to move the scroll bar. Typically, the JScrollBar is used with\n+ * other components to translate the value of the bar to the viewable\n+ * contents of the other components.\n+ */\n+public class JScrollBar extends JComponent implements Adjustable, Accessible\n {\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected class AccessibleJScrollBar extends JComponent.AccessibleJComponent\n+    implements AccessibleValue\n+  {\n+    /**\n+     * Creates a new AccessibleJSlider object.\n+     *\n+     * @param value0 DOCUMENT ME!\n+     */\n+    protected AccessibleJScrollBar(JScrollBar value0)\n+    {\n+      super(value0);\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public AccessibleStateSet getAccessibleStateSet()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public AccessibleRole getAccessibleRole()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public AccessibleValue getAccessibleValue()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public Number getCurrentAccessibleValue()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * setCurrentAccessibleValue\n+     *\n+     * @param value0 TODO\n+     *\n+     * @return boolean\n+     */\n+    public boolean setCurrentAccessibleValue(Number value0)\n+    {\n+      return false;\n+    }\n+\n+    /**\n+     * getMinimumAccessibleValue\n+     *\n+     * @return Number\n+     */\n+    public Number getMinimumAccessibleValue()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * getMaximumAccessibleValue\n+     *\n+     * @return Number\n+     */\n+    public Number getMaximumAccessibleValue()\n+    {\n+      return null;\n+    }\n+  }\n+\n+  /** Fired in a PropertyChangeEvent when the \"blockIncrement\" changes. */\n+  public static final String BLOCK_INCREMENT_CHANGED_PROPERTY = \"blockIncrement\";\n+\n+  /** Fired in a PropertyChangeEvent when the \"model\" changes. */\n+  public static final String MODEL_CHANGED_PROPERTY = \"model\";\n+\n+  /** Fired in a PropertyChangeEvent when the \"orientation\" changes. */\n+  public static final String ORIENTATION_CHANGED_PROPERTY = \"orientation\";\n+\n+  /** Fired in a PropertyChangeEvent when the \"unitIncrement\" changes. */\n+  public static final String UNIT_INCREMENT_CHANGED_PROPERTY = \"unitIncrement\";\n+\n+  /** How much the thumb moves when moving in a block. */\n+  protected int blockIncrement = 10;\n+\n+  /** The model that holds the scroll bar's data. */\n+  protected BoundedRangeModel model;\n+\n+  /** The orientation of the scroll bar. */\n+  protected int orientation = SwingConstants.HORIZONTAL;\n+\n+  /** How much the thumb moves when moving in a unit. */\n+  protected int unitIncrement = 1;\n+\n+  /** A list of all ChangeListeners attached to the scroll bar. */\n+  private transient EventListenerList changeListenerList;\n+\n+  /** A list of all AdjustmentListeners attached to the scroll bar. */\n+  private transient EventListenerList adjustmentListenerList;\n+\n+  /** The ChangeListener that listens to the model. */\n+  private transient ChangeListener changeListener;\n+\n+  /** The ChangeEvent that's fired. */\n+  private transient ChangeEvent changeEvent;\n+\n+  /** \n+   * Creates a new horizontal JScrollBar object with a minimum\n+   * of 0, a maxmium of 100, a value of 0 and an extent of 10.\n+   */\n+  public JScrollBar()\n+  {\n+    this(SwingConstants.HORIZONTAL, 0, 10, 0, 100);\n+  }\n+\n+  /**\n+   * Creates a new JScrollBar object with a minimum of 0, a \n+   * maximum of 100, a value of 0, an extent of 10 and the given\n+   * orientation.\n+   *\n+   * @param orientation The orientation of the JScrollBar.\n+   */\n+  public JScrollBar(int orientation)\n+  {\n+    this(orientation, 0, 10, 0, 100);\n+  }\n+\n+  /**\n+   * Creates a new JScrollBar object with the given orientation, \n+   * value, min, max, and extent.\n+   *\n+   * @param orientation The orientation to use.\n+   * @param value The value to use.\n+   * @param extent The extent to use.\n+   * @param min The minimum value of the scrollbar.\n+   * @param max The maximum value of the scrollbar.\n+   */\n+  public JScrollBar(int orientation, int value, int extent, int min, int max)\n+  {\n+    model = new DefaultBoundedRangeModel(value, extent, min, max);\n+    if (orientation != SwingConstants.HORIZONTAL\n+        && orientation != SwingConstants.VERTICAL)\n+      throw new IllegalArgumentException(orientation\n+                                         + \" is not a legal orientation\");\n+    this.orientation = orientation;\n+    changeListener = createChangeListener();\n+    changeListenerList = new EventListenerList();\n+    adjustmentListenerList = new EventListenerList();\n+    model.addChangeListener(changeListener);\n+    updateUI();\n+  }\n+\n+  /**\n+   * This method sets the UI of this scrollbar to\n+   * the given UI.\n+   *\n+   * @param ui The UI to use with this scrollbar.\n+   */\n+  public void setUI(ScrollBarUI ui)\n+  {\n+    super.setUI(ui);\n+  }\n+\n+  /**\n+   * This method returns the UI that is being used\n+   * with this scrollbar.\n+   *\n+   * @return The scrollbar's current UI.\n+   */\n+  public ScrollBarUI getUI()\n+  {\n+    return (ScrollBarUI) ui;\n+  }\n+\n+  /**\n+   * This method changes the UI to be the\n+   * default for the current look and feel.\n+   */\n+  public void updateUI()\n+  {\n+    setUI((ScrollBarUI) UIManager.getUI(this));\n+    invalidate();\n+    repaint();\n+  }\n+\n+  /**\n+   * This method returns an identifier to \n+   * choose the correct UI delegate for the\n+   * scrollbar.\n+   *\n+   * @return The identifer to choose the UI delegate; \"ScrollBarUI\"\n+   */\n+  public String getUIClassID()\n+  {\n+    return \"ScrollBarUI\";\n+  }\n+\n+  /**\n+   * This method returns the orientation of the scrollbar.\n+   *\n+   * @return The orientation of the scrollbar.\n+   */\n+  public int getOrientation()\n+  {\n+    return orientation;\n+  }\n+\n+  /**\n+   * This method sets the orientation of the scrollbar.\n+   *\n+   * @param orientation The orientation of the scrollbar.\n+   */\n+  public void setOrientation(int orientation)\n+  {\n+    if (orientation != SwingConstants.HORIZONTAL\n+        && orientation != SwingConstants.VERTICAL)\n+      throw new IllegalArgumentException(\"orientation must be one of HORIZONTAL or VERTICAL\");\n+    if (orientation != this.orientation)\n+      {\n+\tint oldOrientation = this.orientation;\n+\tthis.orientation = orientation;\n+\tfirePropertyChange(ORIENTATION_CHANGED_PROPERTY, oldOrientation,\n+\t                   this.orientation);\n+      }\n+  }\n+\n+  /**\n+   * This method returns the model being used with \n+   * the scrollbar.\n+   *\n+   * @return The scrollbar's model.\n+   */\n+  public BoundedRangeModel getModel()\n+  {\n+    return model;\n+  }\n+\n+  /**\n+   * This method sets the model to use with\n+   * the scrollbar.\n+   *\n+   * @param newModel The new model to use with the scrollbar.\n+   */\n+  public void setModel(BoundedRangeModel newModel)\n+  {\n+    if (model != newModel)\n+      {\n+\tBoundedRangeModel oldModel = model;\n+\tmodel = newModel;\n+\toldModel.removeChangeListener(changeListener);\n+\tmodel.addChangeListener(changeListener);\n+\tfirePropertyChange(MODEL_CHANGED_PROPERTY, oldModel, model);\n+      }\n+  }\n+\n+  /**\n+   * This method returns how much the scrollbar's value\n+   * should change for a unit increment depending on the \n+   * given direction.\n+   *\n+   * @param direction The direction to scroll in.\n+   *\n+   * @return The amount the scrollbar's value will change given the direction.\n+   */\n+  public int getUnitIncrement(int direction)\n+  {\n+    return direction * unitIncrement;\n+  }\n+\n+  /**\n+   * This method sets the unitIncrement property.\n+   *\n+   * @param unitIncrement The new unitIncrement.\n+   */\n+  public void setUnitIncrement(int unitIncrement)\n+  {\n+    if (unitIncrement != this.unitIncrement)\n+      {\n+\tint oldInc = this.unitIncrement;\n+\tthis.unitIncrement = unitIncrement;\n+\tfirePropertyChange(UNIT_INCREMENT_CHANGED_PROPERTY, oldInc,\n+\t                   this.unitIncrement);\n+      }\n+  }\n+\n+  /**\n+   * The method returns how much the scrollbar's value\n+   * should change for a block increment depending on\n+   * the given direction.\n+   *\n+   * @param direction The direction to scroll in.\n+   *\n+   * @return The amount the scrollbar's value will change given the direction.\n+   */\n+  public int getBlockIncrement(int direction)\n+  {\n+    return direction * blockIncrement;\n+  }\n+\n+  /**\n+   * This method sets the blockIncrement property.\n+   *\n+   * @param blockIncrement The new blockIncrement.\n+   */\n+  public void setBlockIncrement(int blockIncrement)\n+  {\n+    if (blockIncrement != this.blockIncrement)\n+      {\n+\tint oldInc = this.blockIncrement;\n+\tthis.blockIncrement = blockIncrement;\n+\tfirePropertyChange(BLOCK_INCREMENT_CHANGED_PROPERTY, oldInc,\n+\t                   this.blockIncrement);\n+      }\n+  }\n+\n+  /**\n+   * This method returns the unitIncrement.\n+   *\n+   * @return The unitIncrement.\n+   */\n+  public int getUnitIncrement()\n+  {\n+    return unitIncrement;\n+  }\n+\n+  /**\n+   * This method returns the blockIncrement.\n+   *\n+   * @return The blockIncrement.\n+   */\n+  public int getBlockIncrement()\n+  {\n+    return blockIncrement;\n+  }\n+\n+  /**\n+   * This method returns the value of the scrollbar.\n+   *\n+   * @return The value of the scrollbar.\n+   */\n+  public int getValue()\n+  {\n+    return model.getValue();\n+  }\n+\n+  /**\n+   * This method changes the value of the scrollbar.\n+   *\n+   * @param value The new value of the scrollbar.\n+   */\n+  public void setValue(int value)\n+  {\n+    if (isEnabled() && value != getValue())\n+    {\n+      model.setValue(value);\n+      fireAdjustmentValueChanged(AdjustmentEvent.ADJUSTMENT_VALUE_CHANGED,\n+                                 AdjustmentEvent.TRACK, value);\n+    }\n+  }\n+\n+  /**\n+   * This method returns the visible amount (AKA extent). \n+   * The visible amount can be used by UI delegates to \n+   * determine the size of the thumb.\n+   *\n+   * @return The visible amount (AKA extent).\n+   */\n+  public int getVisibleAmount()\n+  {\n+    return model.getExtent();\n+  }\n+\n+  /**\n+   * This method sets the visible amount (AKA extent).\n+   *\n+   * @param extent The visible amount (AKA extent).\n+   */\n+  public void setVisibleAmount(int extent)\n+  {\n+    if (extent != getVisibleAmount())\n+    {\n+      model.setExtent(extent);\n+      fireAdjustmentValueChanged(AdjustmentEvent.ADJUSTMENT_VALUE_CHANGED,\n+                                 AdjustmentEvent.TRACK, extent);\n+    }\n+  }\n+\n+  /**\n+   * This method returns the minimum value of the scrollbar.\n+   *\n+   * @return The minimum value of the scrollbar.\n+   */\n+  public int getMinimum()\n+  {\n+    return model.getMinimum();\n+  }\n+\n+  /**\n+   * This method sets the minimum value of the scrollbar.\n+   *\n+   * @param minimum The minimum value of the scrollbar.\n+   */\n+  public void setMinimum(int minimum)\n+  {\n+    if (minimum != getMinimum())\n+    {\n+      model.setMinimum(minimum);\n+      fireAdjustmentValueChanged(AdjustmentEvent.ADJUSTMENT_VALUE_CHANGED,\n+                                 AdjustmentEvent.TRACK, minimum);\n+    }\n+  }\n+\n+  /**\n+   * This method returns the maximum value of the scrollbar.\n+   *\n+   * @return The maximum value of the scrollbar.\n+   */\n+  public int getMaximum()\n+  {\n+    return model.getMaximum();\n+  }\n+\n+  /**\n+   * This method sets the maximum value of the scrollbar.\n+   *\n+   * @param maximum The maximum value of the scrollbar.\n+   */\n+  public void setMaximum(int maximum)\n+  {\n+    if (maximum != getMaximum())\n+    {\n+      model.setMaximum(maximum);\n+      fireAdjustmentValueChanged(AdjustmentEvent.ADJUSTMENT_VALUE_CHANGED,\n+                                 AdjustmentEvent.TRACK, maximum);\n+    }\n+  }\n+\n+  /**\n+   * This method returns the model's isAjusting value.\n+   *\n+   * @return The model's isAdjusting value.\n+   */\n+  public boolean getValueIsAdjusting()\n+  {\n+    return model.getValueIsAdjusting();\n+  }\n+\n+  /**\n+   * This method sets the model's isAdjusting value.\n+   *\n+   * @param b The new isAdjusting value.\n+   */\n+  public void setValueIsAdjusting(boolean b)\n+  {\n+    model.setValueIsAdjusting(b);\n+  }\n+\n+  /**\n+   * This method sets the value, extent, minimum and \n+   * maximum.\n+   *\n+   * @param newValue The new value.\n+   * @param newExtent The new extent.\n+   * @param newMin The new minimum.\n+   * @param newMax The new maximum.\n+   */\n+  public void setValue(int newValue, int newExtent, int newMin, int newMax)\n+  {\n+    if (!isEnabled())\n+      newValue = model.getValue();\n+    // It seems to be that on any change the value is fired.\n+    if (newValue != getValue() || newExtent != getVisibleAmount() ||\n+        newMin != getMinimum() || newMax != getMaximum())\n+    {\n+      model.setRangeProperties(newValue, newExtent, newMin, newMax,\n+                               model.getValueIsAdjusting());\n+      fireAdjustmentValueChanged(AdjustmentEvent.ADJUSTMENT_VALUE_CHANGED,\n+                                 AdjustmentEvent.TRACK, newValue);\n+    }\n+  }\n+\n+  /**\n+   * This method creates a new ChangeListener.\n+   *\n+   * @return A new ChangeListener.\n+   */\n+  private ChangeListener createChangeListener()\n+  {\n+    return new ChangeListener()\n+      {\n+\tpublic void stateChanged(ChangeEvent e)\n+\t{\n+\t  fireStateChanged();\n+\t}\n+      };\n+  }\n+\n+  /**\n+   * This method is called whenever the model fires a ChangeEvent. It should\n+   * propagate the ChangeEvent to its listeners with a new ChangeEvent that\n+   * identifies the scroll bar as the source.\n+   */\n+  private void fireStateChanged()\n+  {\n+    Object[] changeListeners = changeListenerList.getListenerList();\n+    if (changeEvent == null)\n+      changeEvent = new ChangeEvent(this);\n+    for (int i = changeListeners.length - 2; i >= 0; i -= 2)\n+      {\n+\tif (changeListeners[i] == ChangeListener.class)\n+\t  ((ChangeListener) changeListeners[i + 1]).stateChanged(changeEvent);\n+      }\n+  }\n+\n+  /**\n+   * This method adds a ChangeListener to the scroll bar.\n+   *\n+   * @param listener The listener to add.\n+   */\n+  public void addChangeListener(ChangeListener listener)\n+  {\n+    changeListenerList.add(ChangeListener.class, listener);\n+  }\n+\n+  /**\n+   * This method removes a ChangeListener from the scroll bar.\n+   *\n+   * @param listener The listener to remove.\n+   */\n+  public void removeChangeListener(ChangeListener listener)\n+  {\n+    changeListenerList.remove(ChangeListener.class, listener);\n+  }\n+\n+  /**\n+   * This method returns an array of all ChangeListeners listening to this\n+   * scroll bar.\n+   *\n+   * @return An array of ChangeListeners listening to this scroll bar.\n+   */\n+  public ChangeListener[] getChangeListeners()\n+  {\n+    return (ChangeListener[]) changeListenerList.getListenerList();\n+  }\n+\n+  /**\n+   * This method adds an AdjustmentListener to the scroll bar.\n+   *\n+   * @param listener The listener to add.\n+   */\n+  public void addAdjustmentListener(AdjustmentListener listener)\n+  {\n+    adjustmentListenerList.add(AdjustmentListener.class, listener);\n+  }\n+\n+  /**\n+   * This method removes an AdjustmentListener from the scroll bar. \n+   *\n+   * @param listener The listener to remove.\n+   */\n+  public void removeAdjustmentListener(AdjustmentListener listener)\n+  {\n+    adjustmentListenerList.remove(AdjustmentListener.class, listener);\n+  }\n+\n+  /**\n+   * This method returns an arry of all AdjustmentListeners listening to \n+   * this scroll bar.\n+   *\n+   * @return An array of AdjustmentListeners listening to this scroll bar.\n+   */\n+  public AdjustmentListener[] getAdjustmentListeners()\n+  {\n+    return (AdjustmentListener[]) adjustmentListenerList.getListenerList();\n+  }\n+\n+  /**\n+   * This method is called to fired AdjustmentEvents to the listeners\n+   * of this scroll bar. All AdjustmentEvents that are fired\n+   * will have an ID of ADJUSTMENT_VALUE_CHANGED and a type of\n+   * TRACK. \n+   *\n+   * @param id The ID of the adjustment event.\n+   * @param type The Type of change.\n+   * @param value The new value for the property that was changed..\n+   */\n+  protected void fireAdjustmentValueChanged(int id, int type, int value)\n+  {\n+    Object[] adjustmentListeners = adjustmentListenerList.getListenerList();\n+    AdjustmentEvent adjustmentEvent = new AdjustmentEvent(this, \n+                                            AdjustmentEvent.ADJUSTMENT_VALUE_CHANGED,\n+\t\t\t\t\t    AdjustmentEvent.TRACK,\n+\t\t\t\t\t    value);\n+    for (int i = adjustmentListeners.length - 2; i >= 0; i -= 2)\n+      {\n+\tif (adjustmentListeners[i] == AdjustmentListener.class)\n+\t  ((AdjustmentListener) adjustmentListeners[i + 1]).adjustmentValueChanged(adjustmentEvent);\n+      }\n+  }\n+\n+  /**\n+   * This method returns the minimum size for this scroll bar.\n+   *\n+   * @return The minimum size.\n+   */\n+  public Dimension getMinimumSize()\n+  {\n+    return ui.getMinimumSize(this);\n+  }\n+\n+  /**\n+   * This method returns the maximum size for this scroll bar.\n+   *\n+   * @return The maximum size.\n+   */\n+  public Dimension getMaximumSize()\n+  {\n+    return ui.getMaximumSize(this);\n+  }\n+\n+  /**\n+   * This method overrides the setEnabled in JComponent.\n+   * When the scroll bar is disabled, the knob cannot\n+   * be moved.\n+   *\n+   * @param x Whether the scrollbar is enabled.\n+   */\n+  public void setEnabled(boolean x)\n+  {\n+    // nothing special needs to be done here since we \n+    // just check the enabled setting before changing the value.\n+    super.setEnabled(x);\n+  }\n+\n+  /**\n+   * A string that describes this JScrollBar. Normally only used\n+   * for debugging.\n+   *\n+   * @return A string describing this JScrollBar.\n+   */\n+  protected String paramString()\n+  {\n+    return \"JScrollBar\";\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    if (accessibleContext == null)\n+      accessibleContext = new AccessibleJScrollBar(this);\n+    return accessibleContext;\n+  }\n }"}, {"sha": "f31da048abf35fb8418291e714ac1d8c91f44e55", "filename": "libjava/javax/swing/JScrollPane.java", "status": "modified", "additions": 516, "deletions": 72, "changes": 588, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FJScrollPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FJScrollPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJScrollPane.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -1,5 +1,5 @@\n /* JScrollPane.java -- \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -39,96 +39,540 @@\n package javax.swing;\n \n import java.awt.Component;\n+import java.awt.ComponentOrientation;\n+import java.awt.LayoutManager;\n+import java.awt.Insets;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+\n+import javax.swing.border.Border;\n import javax.accessibility.Accessible;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n import javax.swing.plaf.ScrollPaneUI;\n+import javax.swing.plaf.UIResource;\n \n-public class JScrollPane extends JComponent implements Accessible, ScrollPaneConstants\n+/**\n+ * <table>\n+ * <tr><th>Property                    </th><th>Stored in       </th><th>Bound?</th></tr>\n+ * <tr><td>columnHeader                </td><td>scrollPane      </td><td>yes   </td></tr>\n+ * <tr><td>columnHeaderView            </td><td>columnHeader    </td><td>no    </td></tr>\n+ * <tr><td>componentOrientation        </td><td>scrollPane      </td><td>yes   </td></tr>\n+ * <tr><td>horizontalScrollBar         </td><td>scrollPane      </td><td>yes   </td></tr>\n+ * <tr><td>horizontalScrollBarPolicy   </td><td>scrollPane      </td><td>yes   </td></tr>\n+ * <tr><td>layout                      </td><td>scrollPane      </td><td>yes   </td></tr>\n+ * <tr><td>rowHeader                   </td><td>scrollPane      </td><td>yes   </td></tr>\n+ * <tr><td>rowHeaderView               </td><td>rowHeader       </td><td>no    </td></tr>\n+ * <tr><td>validateRoot                </td><td>scrollPane      </td><td>no    </td></tr>\n+ * <tr><td>verticalScrollBar           </td><td>scrollPane      </td><td>yes   </td></tr>\n+ * <tr><td>verticalScrollBarPolicy     </td><td>scrollPane      </td><td>yes   </td></tr>\n+ * <tr><td>viewport                    </td><td>scrollPane      </td><td>yes   </td></tr>\n+ * <tr><td>viewportBorder              </td><td>scrollPane      </td><td>yes   </td></tr>\n+ * <tr><td>viewportBorderBounds        </td><td>scrollPane      </td><td>no    </td></tr>\n+ * <tr><td>viewportView                </td><td>viewport        </td><td>no    </td></tr>\n+ * <tr><td>wheelScrollingEnabled       </td><td>scrollPane      </td><td>yes   </td></tr>\n+ * </table>\n+ */\n+public class JScrollPane \n+  extends JComponent \n+  implements Accessible, ScrollPaneConstants\n {\n-    protected JViewport  columnHeader;\n-    protected JViewport  rowHeader;\n+  JViewport columnHeader;\n+  JViewport rowHeader;\n \n-    protected Component  lowerLeft;\n-    protected Component  lowerRight;\n-    protected Component  upperLeft;\n-    protected Component  upperRight;\n+  Component lowerLeft;\n+  Component lowerRight;\n+  Component upperLeft;\n+  Component upperRight;\n \n-    protected JScrollBar horizontalScrollBar;\n-    protected int        horizontalScrollBarPolicy;\n-    protected JScrollBar verticalScrollBar;\n-    protected int        verticalScrollBarPolicy;\n+  JScrollBar horizontalScrollBar;\n+  int horizontalScrollBarPolicy;\n+  JScrollBar verticalScrollBar;\n+  int verticalScrollBarPolicy;\n \n-    protected JViewport  viewport;\n+  JViewport viewport;\n+  Border viewportBorder;\n+  boolean wheelScrollingEnabled;\n+  ChangeListener scrollListener;  \n \n+  public static final String COLUMN_HEADER_CHANGED_PROPERTY = \"columnHeader\";\n+  public static final String COMPONENT_ORIENTATION_CHANGED_PROPERTY = \"componentOrientation\";\n+  public static final String HORIZONTAL_SCROLLBAR_CHANGED_PROPERTY = \"horizontalScrollBar\";\n+  public static final String HORIZONTAL_SCROLLBAR_POLICY_CHANGED_PROPERTY = \"horizontalScrollBarPolicy\";\n+  public static final String LAYOUT_CHANGED_PROPERTY = \"layout\";\n+  public static final String ROW_HEADER_CHANGED_PROPERTY = \"rowHeader\";\n+  public static final String VERTICAL_SCROLLBAR_CHANGED_PROPERTY = \"verticalScrollBar\";\n+  public static final String VERTICAL_SCROLLBAR_POLICY_CHANGED_PROPERTY = \"verticalScrollBarPolicy\";\n+  public static final String VIEWPORT_CHANGED_PROPERTY = \"viewport\";\n+  public static final String VIEWPORT_BORDER_CHANGED_PROPERTY = \"viewportBorder\";\n+  public static final String WHEEL_SCROLLING_ENABLED_CHANGED_PROPERTY = \"wheelScrollingEnabled\";\n \n-    public JScrollPane() \n-    {\n-\tthis(null, 0, 0);\n-    }\n-    \n-    public JScrollPane(Component view) \n-    {\n-\tthis(view, 0, 0);\n-    }\n-    \n+  public JViewport getColumnHeader()\n+  {\n+    return columnHeader;\n+  }\n+\n+  public Component getCorner(String key) {\n+    if (getComponentOrientation() \n+        == ComponentOrientation.LEFT_TO_RIGHT)\n+      {\n+        if (key == LOWER_LEADING_CORNER)\n+          key = LOWER_LEFT_CORNER;\n+        else if (key == LOWER_TRAILING_CORNER)\n+          key = LOWER_RIGHT_CORNER;\n+        else if (key == UPPER_LEADING_CORNER)\n+          key = UPPER_LEFT_CORNER;\n+        else if (key == UPPER_TRAILING_CORNER)\n+          key = UPPER_RIGHT_CORNER;\n+      }\n+    else if (getComponentOrientation() \n+             == ComponentOrientation.RIGHT_TO_LEFT)\n+      {\n+        if (key == LOWER_LEADING_CORNER)\n+          key = LOWER_RIGHT_CORNER;\n+        else if (key == LOWER_TRAILING_CORNER)\n+          key = LOWER_LEFT_CORNER;\n+        else if (key == UPPER_LEADING_CORNER)\n+          key = UPPER_RIGHT_CORNER;\n+        else if (key == UPPER_TRAILING_CORNER)\n+          key = UPPER_LEFT_CORNER;\n+      }\n+\n+    if (key == LOWER_RIGHT_CORNER)\n+      return lowerRight;\n+    else if (key == UPPER_RIGHT_CORNER)\n+      return upperRight;\n+    else if (key == LOWER_LEFT_CORNER)\n+      return lowerLeft;\n+    else if (key == UPPER_LEFT_CORNER)\n+      return upperLeft;\n+    return null;\n+  }\n+\n+  public JScrollBar getHorizontalScrollBar()\n+  {\n+    return horizontalScrollBar;\n+  }\n+\n+  public int getHorizontalScrollBarPolicy()\n+  {\n+    return horizontalScrollBarPolicy;\n+  }\n+\n+  public JViewport getRowHeader()\n+  {\n+    return rowHeader;\n+  }\n+\n+  public JScrollBar getVerticalScrollBar()\n+  {\n+    return verticalScrollBar;\n+  }\n+\n+  public int getVerticalScrollBarPolicy()\n+  {\n+    return verticalScrollBarPolicy;\n+  }\n+\n+  public JViewport getViewport()\n+  {\n+    return viewport;\n+  }\n+\n+  public Border getViewportBorder()\n+  {\n+    return viewportBorder;\n+  }\n+\n+  public Rectangle getViewportBorderBounds()\n+  {\n+    if (viewportBorder == null)\n+      {\n+        if (getViewport() == null)\n+          return new Rectangle(0,0,0,0);\n+        else\n+          return getViewport().getBounds();\n+      }\n+    else\n+      {\n+        Insets i = viewportBorder.getBorderInsets(getViewport());\n+        if (getViewport() == null)\n+          return new Rectangle(0,0,\n+                               i.left+i.right, i.top+i.bottom);\n+        else\n+          {\n+            Rectangle b = getViewport().getBounds();\n+            return new Rectangle(b.x - i.left, \n+                                 b.y - i.top,\n+                                 b.width + i.left + i.right, \n+                                 b.height + i.top + i.bottom);\n+          }\n+      }\n+  }\n+  \n+  public boolean isWheelScrollingEnabled()\n+  {\n+    return wheelScrollingEnabled;\n+  }\n+\n+\n+\n+  private void sync()\n+  {\n+    LayoutManager m = super.getLayout();\n+    if (m != null && m instanceof ScrollPaneLayout)\n+      {\n+        ScrollPaneLayout sl = (ScrollPaneLayout) m;\n+        sl.syncWithScrollPane(this);\n+      }\n+  }\n+\n+  private void removeNonNull(Component c)\n+  {\n+    if (c != null)\n+      remove(c);\n+  }\n+\n+  private void addNonNull(Component c)\n+  {\n+    if (c != null)\n+      add(c);\n+  }\n+\n+  public void setComponentOrientation(ComponentOrientation co)\n+  {\n+    ComponentOrientation old = super.getComponentOrientation();\n+    super.setComponentOrientation(co);\n+    firePropertyChange(COMPONENT_ORIENTATION_CHANGED_PROPERTY, old, co);\n+    sync();\n+  }\n+\n+  public void setColumnHeader(JViewport h)\n+  {\n+    JViewport old = columnHeader;\n+    removeNonNull(old);\n+    columnHeader = h;\n+    addNonNull(h);\n+    firePropertyChange(COLUMN_HEADER_CHANGED_PROPERTY, old, h);\n+    sync();\n+  }\n+\n+  public void setColumnHeaderView(Component c)\n+  {\n+    if (columnHeader == null)\n+      setColumnHeader(createViewport());\n+    columnHeader.setView(c);\n+    sync();\n+  }\n+\n+  public void setCorner(String key, Component c)\n+  {\n+    if (getComponentOrientation() \n+        == ComponentOrientation.LEFT_TO_RIGHT)\n+      {\n+        if (key == LOWER_LEADING_CORNER)\n+          key = LOWER_LEFT_CORNER;\n+        else if (key == LOWER_TRAILING_CORNER)\n+          key = LOWER_RIGHT_CORNER;\n+        else if (key == UPPER_LEADING_CORNER)\n+          key = UPPER_LEFT_CORNER;\n+        else if (key == UPPER_TRAILING_CORNER)\n+          key = UPPER_RIGHT_CORNER;\n+      }\n+    else if (getComponentOrientation() \n+             == ComponentOrientation.RIGHT_TO_LEFT)\n+      {\n+        if (key == LOWER_LEADING_CORNER)\n+          key = LOWER_RIGHT_CORNER;\n+        else if (key == LOWER_TRAILING_CORNER)\n+          key = LOWER_LEFT_CORNER;\n+        else if (key == UPPER_LEADING_CORNER)\n+          key = UPPER_RIGHT_CORNER;\n+        else if (key == UPPER_TRAILING_CORNER)\n+          key = UPPER_LEFT_CORNER;\n+      }\n+\n+    if (key == LOWER_RIGHT_CORNER)\n+      {\n+        removeNonNull(lowerRight);\n+        lowerRight = c;\n+        addNonNull(c);\n+      }\n+    else if (key == UPPER_RIGHT_CORNER)\n+      {\n+        removeNonNull(upperRight);\n+        upperRight = c;\n+        addNonNull(c);\n+      }\n+    else if (key == LOWER_LEFT_CORNER)\n+      {\n+        removeNonNull(lowerLeft);\n+        lowerLeft = c;\n+        addNonNull(c);\n+      }\n+    else if (key == UPPER_LEFT_CORNER)\n+      {\n+        removeNonNull(upperLeft);\n+        upperLeft = c;\n+        addNonNull(c);\n+      }\n+    else\n+      throw new IllegalArgumentException(\"unknown corner \" + key);\n+    sync();\n+  }\n+\n+  public void setHorizontalScrollBar(JScrollBar h)\n+  {\n+    JScrollBar old = horizontalScrollBar;\n+    removeNonNull(old);\n+    horizontalScrollBar = h;\n+    addNonNull(h);\n+    firePropertyChange(HORIZONTAL_SCROLLBAR_CHANGED_PROPERTY, old, h);\n+    sync();\n+\n+    if (old != null)\n+      {\n+        BoundedRangeModel model = old.getModel();\n+        if (model != null)\n+          model.removeChangeListener(scrollListener);\n+      }\n+    if (h != null)\n+      {\n+        BoundedRangeModel model = h.getModel();\n+        if (model != null)\n+          model.addChangeListener(scrollListener);\n+      }\n+  }\n+\n+  public void setHorizontalScrollBarPolicy(int h)\n+  {    \n+    if (h != HORIZONTAL_SCROLLBAR_AS_NEEDED\n+        && h != HORIZONTAL_SCROLLBAR_NEVER\n+        && h != HORIZONTAL_SCROLLBAR_ALWAYS)\n+      throw new IllegalArgumentException(\"unknown horizontal scrollbar policy\");    \n+    int old = horizontalScrollBarPolicy;\n+    horizontalScrollBarPolicy = h;\n+    firePropertyChange(HORIZONTAL_SCROLLBAR_POLICY_CHANGED_PROPERTY, old, h);\n+    sync();\n+  }\n+\n+  public void setLayout(LayoutManager l)\n+  {\n+    LayoutManager old = super.getLayout();\n+    ScrollPaneLayout tmp = (ScrollPaneLayout) l;\n+    super.setLayout(l);\n+    tmp.syncWithScrollPane(this);\n+    firePropertyChange(LAYOUT_CHANGED_PROPERTY, old, l);\n+    sync();\n+  }\n+\n+  public void setRowHeader(JViewport v)\n+  {\n+    JViewport old = rowHeader;\n+    removeNonNull(old);\n+    rowHeader = v;\n+    addNonNull(v);\n+    firePropertyChange(ROW_HEADER_CHANGED_PROPERTY, old, v);\n+    sync();\n+  }\n+\n+  public void setRowHeaderView(Component c)\n+  {\n+    if (rowHeader == null)\n+      setRowHeader(createViewport());\n+    rowHeader.setView(c);\n+    sync();\n+  }\n+\n+  public void setVerticalScrollBar(JScrollBar v)\n+  {\n+    JScrollBar old = verticalScrollBar;\n+    removeNonNull(old);\n+    verticalScrollBar = v;\n+    addNonNull(v);\n+    firePropertyChange(VERTICAL_SCROLLBAR_CHANGED_PROPERTY, old, v);\n+    sync();\n+\n+    if (old != null)\n+      {\n+        BoundedRangeModel model = old.getModel();\n+        if (model != null)\n+          model.removeChangeListener(scrollListener);\n+      }\n+    if (v != null)\n+      {\n+        BoundedRangeModel model = v.getModel();\n+        if (model != null)\n+          model.addChangeListener(scrollListener);\n+      }\n+  }\n+\n+  public void setVerticalScrollBarPolicy(int v)\n+  {\n+    if (v != VERTICAL_SCROLLBAR_AS_NEEDED\n+        && v != VERTICAL_SCROLLBAR_NEVER\n+        && v != VERTICAL_SCROLLBAR_ALWAYS)\n+      throw new IllegalArgumentException(\"unknown vertical scrollbar policy\");    \n+    int old = verticalScrollBarPolicy;\n+    verticalScrollBarPolicy = v;\n+    firePropertyChange(VERTICAL_SCROLLBAR_POLICY_CHANGED_PROPERTY, old, v);\n+    sync();\n+  }\n+\n+  public void setWheelScrollingEnabled(boolean b)\n+  {\n+    boolean old = wheelScrollingEnabled;\n+    wheelScrollingEnabled = b;\n+    firePropertyChange(WHEEL_SCROLLING_ENABLED_CHANGED_PROPERTY, old, b);\n+    sync();\n+  }\n+\n+  public void setViewport(JViewport v)\n+  {\n+    JViewport old = viewport;\n+    removeNonNull(old);\n+    viewport = v;\n+    addNonNull(v);\n+    revalidate();\n+    repaint();\n+    firePropertyChange(VIEWPORT_CHANGED_PROPERTY, old, v);\n+    sync();\n+  }\n+\n+  public void setViewportBorder(Border b)\n+  {\n+    Border old = viewportBorder;\n+    viewportBorder = b;\n+    firePropertyChange(VIEWPORT_BORDER_CHANGED_PROPERTY, old, b);\n+    sync();\n+  }\n     \n-    public JScrollPane(int vsbPolicy, int hsbPolicy) \n-    {\n-\tthis(null, 0, 0);\n-    }\n+  public void setViewportView(Component view)\n+  {\n+    if (getViewport() == null)\n+      {\n+        setViewport(createViewport());\n+      }\n+\t\n+    if (view != null)\n+      {\n+        getViewport().setView(view);\n+      }\n+    sync();\n+  }\n \n-    public JScrollPane(Component view, int vsbPolicy, int hsbPolicy) \n-    {\n-\tsetViewportView(view);\n-        setOpaque(true);\n-\tupdateUI();\n-    }\n+  public boolean isValidateRoot()\n+  {\n+    return true;\n+  }\n \n-    public String getUIClassID()\n-    {\n-\t//Returns a string that specifies the name of the L&F class that renders this component.  \n-\treturn \"ScrollPaneUI\";\n-    }\n+  ChangeListener createScrollListener()\n+  {\n+    return new ChangeListener() {\n+        public void stateChanged(ChangeEvent event)\n+        {\n+          int xpos = 0;\n+          int ypos = 0;\n+          JScrollBar vsb = JScrollPane.this.getVerticalScrollBar();\n+          JScrollBar hsb = JScrollPane.this.getHorizontalScrollBar();\n+          \n+          if (vsb != null)\n+            {\n+              BoundedRangeModel vmod = vsb.getModel();\n+              if (vmod != null)\n+                ypos = vmod.getValue();\n+            }\n \n-    public JViewport getViewport()\n-    {\n-\treturn viewport;\n-    }\n+          if (hsb != null)\n+            {\n+              BoundedRangeModel hmod = hsb.getModel();\n+              if (hmod != null)\n+                xpos = hmod.getValue();\n+            }\n+          if (JScrollPane.this.viewport != null)\n+            JScrollPane.this.viewport.setViewPosition(new Point(xpos, ypos));\n+        }\n+      };\n+  }\n \n-    public JViewport createViewport()\n-    {\n-\treturn new JViewport();\n-    }\n+\n+  public JScrollPane() \n+  {\n+    this(null);\n+  }\n     \n-    public void setViewport(JViewport v)\n-    {\n-\tif (viewport != null)\n-\t    remove(viewport);\n+  public JScrollPane(Component view) \n+  {\n+    this(view, \n+         VERTICAL_SCROLLBAR_AS_NEEDED, \n+         HORIZONTAL_SCROLLBAR_AS_NEEDED);\n+  }\n \n-\tviewport = v;\t\n-\t\n-\tadd(v);\n-\t\n-\trevalidate();\n-\trepaint();\n-    }\n+  public JScrollPane(int vsbPolicy, int hsbPolicy) \n+  {\n+    this(null, vsbPolicy, hsbPolicy);\n+  }\n+\n+  public JScrollPane(Component view, int vsbPolicy, int hsbPolicy) \n+  {\n+    scrollListener = createScrollListener();\n+    setVerticalScrollBarPolicy(vsbPolicy);\n+    setVerticalScrollBar(createVerticalScrollBar());\n+    setHorizontalScrollBarPolicy(hsbPolicy);\n+    setHorizontalScrollBar(createHorizontalScrollBar());\n+    setViewportView(view);\n+    setLayout(new ScrollPaneLayout());\n+    setOpaque(false);\n+    updateUI();\n+  }\n+\n+  \n+  public JScrollBar createHorizontalScrollBar()\n+  {\n+    return new JScrollBar(SwingConstants.HORIZONTAL);\n+  }\n+\n+  public JScrollBar createVerticalScrollBar()\n+  {\n+    return new JScrollBar(SwingConstants.VERTICAL);\n+  }\n     \n-   public  void updateUI()\n-    {\n-\tScrollPaneUI b = (ScrollPaneUI)UIManager.getUI(this);\n-\tsetUI(b);\n-    }\n+  public JViewport createViewport()\n+  {\n+    return new JViewport();\n+  }\n \n \n-    public void setViewportView(Component view)\n+  public String getUIClassID()\n+  {\n+    return \"ScrollPaneUI\";\n+  }\n+  \n+  public void updateUI()\n+  {\n+    ScrollPaneUI b = (ScrollPaneUI)UIManager.getUI(this);\n+    setUI(b);\n+  }  \n+\n+  /*\n+  class ScrollBar \n+    extends JScrollBar\n+    implements UIResource\n+  {\n+    public ScrollBar(int orientation)\n     {\n-\tif (getViewport() == null)\n-\t    {\n-\t\tsetViewport(createViewport());\n-\t    }\n-\t\n-\tif (view != null)\n-\t    {\n-\t\tgetViewport().setView(view);\n-\t    }\n+      super(orientation);\n+      Component view = this.JScrollPane.getViewportView();\n+      if (view == null)\n+        return;\n+      if (! view instanceof Scrollable)\n+        {\n+          Scrollable s = (Scrollable) view;\n+          s.\n+        }\n     }\n+\n+  }\n+  */\n+\n }"}, {"sha": "224280b35a6f32fc7940e2ff6d95c77530224d22", "filename": "libjava/javax/swing/JSeparator.java", "status": "modified", "additions": 157, "deletions": 177, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FJSeparator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FJSeparator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJSeparator.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -44,183 +44,163 @@\n import javax.accessibility.AccessibleRole;\n import javax.swing.plaf.SeparatorUI;\n \n+\n /**\n- * JSeparator\n- * @author\tAndrew Selkirk\n- * @version\t1.0\n+ * The JSeparator. It is mostly used to divide/space out\n+ * components.\n  */\n-public class JSeparator extends JComponent \n-  implements SwingConstants, Accessible\n+public class JSeparator extends JComponent implements SwingConstants,\n+                                                      Accessible\n {\n-\n-\t//-------------------------------------------------------------\n-\t// Classes ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * AccessibleJSeparator\n-\t */\n-\tprotected class AccessibleJSeparator extends AccessibleJComponent {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Variables --------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor AccessibleJSeparator\n-\t\t * @param component TODO\n-\t\t */\n-\t\tprotected AccessibleJSeparator(JSeparator component) {\n-\t\t\tsuper(component);\n-\t\t\t// TODO\n-\t\t} // AccessibleJSeparator()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * getAccessibleRole\n-\t\t * @returns AccessibleRole\n-\t\t */\n-\t\tpublic AccessibleRole getAccessibleRole() {\n-\t\t\treturn AccessibleRole.SEPARATOR;\n-\t\t} // getAccessibleRole()\n-\n-\n-\t} // AccessibleJSeparator\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * uiClassID\n-\t */\n-\tprivate static final String uiClassID = \"SeparatorUI\";\n-\n-\t/**\n-\t * orientation\n-\t */\n-\tprivate int orientation;\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor JSeparator\n-\t */\n-\tpublic JSeparator() {\n-\t\tthis(HORIZONTAL);\n-\t} // JSeparator()\n-\n-\t/**\n-\t * Constructor JSeparator\n-\t * @param value0 TODO\n-\t */\n-\tpublic JSeparator(int orientation) {\n-\t\tthis.orientation = orientation;\n-\t\t// TODO\n-\t} // JSeparator()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * writeObject\n-\t * @param stream TODO\n-\t * @exception IOException TODO\n-\t */\n-\tprivate void writeObject(ObjectOutputStream stream) throws IOException {\n-\t\t// TODO\n-\t} // writeObject()\n-\n-\t/**\n-\t * getUI\n-\t * @returns SeparatorUI\n-\t */\n-\tpublic SeparatorUI getUI() {\n-\t\treturn (SeparatorUI) ui;\n-\t} // getUI()\n-\n-\t/**\n-\t * setUI\n-\t * @param ui TODO\n-\t */\n-\tpublic void setUI(SeparatorUI ui) {\n-\t\tsuper.setUI(ui);\n-\t} // setUI()\n-\n-\t/**\n-\t * updateUI\n-\t */\n-\tpublic void updateUI() {\n-\t\tsetUI((SeparatorUI) UIManager.get(this));\n-\t\tinvalidate();\n-\t} // updateUI()\n-\n-\t/**\n-\t * getUIClassID\n-\t * @returns String\n-\t */\n-\tpublic String getUIClassID() {\n-\t\treturn uiClassID;\n-\t} // getUIClassID()\n-\n-\t/**\n-\t * getOrientation\n-\t * @returns int\n-\t */\n-\tpublic int getOrientation() {\n-\t\treturn orientation;\n-\t} // getOrientation()\n-\n-\t/**\n-\t * setOrientation\n-\t * @param orientation TODO\n-\t */\n-\tpublic void setOrientation(int orientation) {\n-\t\tthis.orientation = orientation;\n-\t\t// TODO\n-\t} // setOrientation()\n-\n-\t/**\n-\t * paramString\n-\t * @returns String\n-\t */\n-\tprotected String paramString() {\n-\t\treturn null; // TODO\n-\t} // paramString()\n-\n-\t/**\n-\t * isFocusTraversable\n-\t * @returns boolean\n-\t */\n-\tpublic boolean isFocusTraversable() {\n-\t\treturn false;\n-\t} // isFocusTraversable()\n-\n-\t/**\n-\t * getAccessibleContext\n-\t * @returns AccessibleContext\n-\t */\n-\tpublic AccessibleContext getAccessibleContext() {\n-\t\tif (accessibleContext == null) {\n-\t\t\taccessibleContext = new AccessibleJSeparator(this);\n-\t\t} // if\n-\t\treturn accessibleContext;\n-\t} // getAccessibleContext()\n-\n-\n-} // JSeparator\n+  /**\n+   * AccessibleJSeparator\n+   */\n+  protected class AccessibleJSeparator extends AccessibleJComponent\n+  {\n+    /**\n+     * Constructor AccessibleJSeparator\n+     *\n+     * @param component TODO\n+     */\n+    protected AccessibleJSeparator(JSeparator component)\n+    {\n+      super(component);\n+    }\n+\n+    /**\n+     * getAccessibleRole\n+     *\n+     * @return AccessibleRole\n+     */\n+    public AccessibleRole getAccessibleRole()\n+    {\n+      return AccessibleRole.SEPARATOR;\n+    }\n+  }\n+\n+  /** The orientation of the JSeparator. */\n+  private transient int orientation = HORIZONTAL;\n+\n+  /**\n+   * Creates a new horizontal JSeparator object.\n+   */\n+  public JSeparator()\n+  {\n+    this(HORIZONTAL);\n+  }\n+\n+  /**\n+   * Creates a new JSeparator object with the given orientation.\n+   *\n+   * @param orientation The orientation of the JSeparator.\n+   */\n+  public JSeparator(int orientation)\n+  {\n+    if (orientation != HORIZONTAL && orientation != VERTICAL)\n+      throw new IllegalArgumentException(orientation\n+                                         + \" is not a valid orientation.\");\n+    this.orientation = orientation;\n+    updateUI();\n+  }\n+\n+  /**\n+   * This method returns the UI delegate being\n+   * used with the JSeparator.\n+   *\n+   * @return SeparatorUI The JSeparator's UI delegate.\n+   */\n+  public SeparatorUI getUI()\n+  {\n+    return (SeparatorUI) ui;\n+  }\n+\n+  /**\n+   * This method sets the UI delegate to use\n+   * with the JSeparator.\n+   *\n+   * @param ui The UI delegate to use.\n+   */\n+  public void setUI(SeparatorUI ui)\n+  {\n+    super.setUI(ui);\n+  }\n+\n+  /**\n+   * This method resets the UI delegate to the \n+   * default for the current look and feel.\n+   */\n+  public void updateUI()\n+  {\n+    setUI((SeparatorUI) UIManager.getUI(this));\n+    invalidate();\n+  }\n+\n+  /**\n+   * This method returns the identifier string\n+   * that is used to determine the UI delegate\n+   * from the current look and feel.\n+   *\n+   * @return String The identifier string for the UI.\n+   */\n+  public String getUIClassID()\n+  {\n+    return \"SeparatorUI\";\n+  }\n+\n+  /**\n+   * This method returns the JSeparator's orientation.\n+   *\n+   * @return int The JSeparator's orientation.\n+   */\n+  public int getOrientation()\n+  {\n+    return orientation;\n+  }\n+\n+  /**\n+   * This method changes the JSeparator's orientation.\n+   *\n+   * @param orientation The JSeparator's orientation.\n+   */\n+  public void setOrientation(int orientation)\n+  {\n+    if (orientation != HORIZONTAL && orientation != VERTICAL)\n+      throw new IllegalArgumentException(orientation\n+                                         + \" is not a valid orientation.\");\n+    this.orientation = orientation;\n+  }\n+\n+  /**\n+   * This method returns a string desribing the JSeparator.\n+   * Normally only used in debugging.\n+   *\n+   * @return String A string describing the JSeparator.\n+   */\n+  protected String paramString()\n+  {\n+    return \"JSeparator\";\n+  }\n+\n+  /**\n+   * This method overrides the isFocusTraversable method from\n+   * Component to false. JSeparator cannot be focused on.\n+   *\n+   * @return boolean False.\n+   */\n+  public boolean isFocusTraversable()\n+  {\n+    return false;\n+  }\n+\n+  /**\n+   * getAccessibleContext\n+   *\n+   * @return AccessibleContext\n+   */\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    if (accessibleContext == null)\n+      accessibleContext = new AccessibleJSeparator(this);\n+    return accessibleContext;\n+  }\n+}"}, {"sha": "203dc4a61971c7968f4e371c56f502436f9b7527", "filename": "libjava/javax/swing/JSlider.java", "status": "modified", "additions": 890, "deletions": 644, "changes": 1534, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FJSlider.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FJSlider.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJSlider.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -1,5 +1,5 @@\n /* JSlider.java --\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,13 +35,17 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing;\n \n+import java.awt.ComponentOrientation;\n+import java.awt.MenuContainer;\n+import java.awt.Dimension;\n+import java.awt.image.ImageObserver;\n import java.io.IOException;\n import java.io.ObjectOutputStream;\n import java.io.Serializable;\n import java.util.Dictionary;\n+import java.util.Enumeration;\n import java.util.Hashtable;\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n@@ -50,652 +54,894 @@\n import javax.accessibility.AccessibleValue;\n import javax.swing.event.ChangeEvent;\n import javax.swing.event.ChangeListener;\n+import javax.swing.event.EventListenerList;\n import javax.swing.plaf.SliderUI;\n \n+\n /**\n- * JSlider\n- * @author\tAndrew Selkirk\n- * @version\t1.0\n+ * <p>\n+ * The JSlider is a Swing component that allows selection of a value within a\n+ * range by adjusting a thumb in a track. The values for the minimum,\n+ * maximum, extent and value are stored in a {@link\n+ * DefaultBoundedRangeModel}.\n+ * </p>\n+ * \n+ * <p>\n+ * JSliders have the following properties:\n+ * </p>\n+ * \n+ * <table>\n+ * <tr><th> Property         </td><th> Stored in </td><th> Bound? </td></tr>\n+ * <tr><td> extent           </td><td> model     </td><td> no     </td></tr>\n+ * <tr><td> inverted         </td><td> slider    </td><td> yes    </td></tr>\n+ * <tr><td> labelTable       </td><td> slider    </td><td> yes    </td></tr>\n+ * <tr><td> majorTickSpacing </td><td> slider    </td><td> yes    </td></tr> \n+ * <tr><td> maximum          </td><td> model     </td><td> no     </td></tr>\n+ * <tr><td> minimum          </td><td> model     </td><td> no     </td></tr>\n+ * <tr><td> minorTickSpacing </td><td> slider    </td><td> yes    </td></tr>\n+ * <tr><td> model            </td><td> slider    </td><td> yes    </td></tr> \n+ * <tr><td> orientation      </td><td> slider    </td><td> yes    </td></tr>\n+ * <tr><td> paintLabels      </td><td> slider    </td><td> yes    </td></tr>\n+ * <tr><td> paintTicks       </td><td> slider    </td><td> yes    </td></tr>\n+ * <tr><td> snapToTicks      </td><td> slider    </td><td> no     </td></tr>\n+ * <tr><td> value            </td><td> model     </td><td> no     </td></tr>\n+ * <tr><td> valueIsAdjusting </td><td> model     </td><td> no     </td></tr>\n+ * </table>\n+ * \n+ * <p>\n+ * The various behavioral aspects of these properties follows:\n+ * </p>\n+ * \n+ * <ul>\n+ * <li>\n+ * When non-bound properties stored in the slider change, the slider fires\n+ * ChangeEvents to its ChangeListeners.\n+ * </li>\n+ * <li>\n+ * When bound properties stored in the slider change, the slider fires\n+ * PropertyChangeEvents to its PropertyChangeListeners\n+ * </li>\n+ * <li>\n+ * If any of the model's properties change, it fires a ChangeEvent to its\n+ * ChangeListeners, which include the slider.\n+ * </li>\n+ * <li>\n+ * If the slider receives a ChangeEvent from its model, it will propagate the\n+ * ChangeEvent to its ChangeListeners, with the ChangeEvent's \"source\"\n+ * property set to refer to the slider, rather than the model.\n+ * </li>\n+ * </ul>\n  */\n-public class JSlider\n-  extends JComponent\n-  implements SwingConstants, Accessible\n+public class JSlider extends JComponent implements SwingConstants, Accessible,\n+                                                   ImageObserver,\n+                                                   MenuContainer, Serializable\n {\n+  /** DOCUMENT ME! */\n   static final long serialVersionUID = -1441275936141218479L;\n \n-\t//-------------------------------------------------------------\n-\t// Classes ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\n-\t/**\n-\t * AccessibleJSlider\n-\t */\n-\tprotected class AccessibleJSlider extends JComponent.AccessibleJComponent implements AccessibleValue {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Variables --------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor AccessibleJSlider\n-\t\t * @param value0 TODO\n-\t\t */\n-\t\tprotected AccessibleJSlider(JSlider value0) {\n-\t\t\tsuper(value0);\n-\t\t\t// TODO\n-\t\t} // AccessibleJSlider()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * getAccessibleStateSet\n-\t\t * @returns AccessibleStateSet\n-\t\t */\n-\t\tpublic AccessibleStateSet getAccessibleStateSet() {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleStateSet()\n-\n-\t\t/**\n-\t\t * getAccessibleRole\n-\t\t * @returns AccessibleRole\n-\t\t */\n-\t\tpublic AccessibleRole getAccessibleRole() {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleRole()\n-\n-\t\t/**\n-\t\t * getAccessibleValue\n-\t\t * @returns AccessibleValue\n-\t\t */\n-\t\tpublic AccessibleValue getAccessibleValue() {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleValue()\n-\n-\t\t/**\n-\t\t * getCurrentAccessibleValue\n-\t\t * @returns Number\n-\t\t */\n-\t\tpublic Number getCurrentAccessibleValue() {\n-\t\t\treturn null; // TODO\n-\t\t} // getCurrentAccessibleValue()\n-\n-\t\t/**\n-\t\t * setCurrentAccessibleValue\n-\t\t * @param value0 TODO\n-\t\t * @returns boolean\n-\t\t */\n-\t\tpublic boolean setCurrentAccessibleValue(Number value0) {\n-\t\t\treturn false; // TODO\n-\t\t} // setCurrentAccessibleValue()\n-\n-\t\t/**\n-\t\t * getMinimumAccessibleValue\n-\t\t * @returns Number\n-\t\t */\n-\t\tpublic Number getMinimumAccessibleValue() {\n-\t\t\treturn null; // TODO\n-\t\t} // getMinimumAccessibleValue()\n-\n-\t\t/**\n-\t\t * getMaximumAccessibleValue\n-\t\t * @returns Number\n-\t\t */\n-\t\tpublic Number getMaximumAccessibleValue() {\n-\t\t\treturn null; // TODO\n-\t\t} // getMaximumAccessibleValue()\n-\n-\n-\t} // AccessibleJSlider\n-\n-\t/**\n-\t * ModelListener\n-\t */\n-\tprivate class ModelListener implements ChangeListener, Serializable {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Variables --------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor ModelListener\n-\t\t * @param value0 TODO\n-\t\t */\n-\t\tprivate ModelListener(JSlider value0) {\n-\t\t\t// TODO\n-\t\t} // ModelListener()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * stateChanged\n-\t\t * @param value0 TODO\n-\t\t */\n-\t\tpublic void stateChanged(ChangeEvent value0) {\n-\t\t\t// TODO\n-\t\t} // stateChanged()\n-\n-\n-\t} // ModelListener\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * uiClassID\n-\t */\n-\tprivate static final String uiClassID = \"SliderUI\";\n-\n-\t/**\n-\t * paintTicks\n-\t */\n-\tprivate boolean paintTicks;\n-\n-\t/**\n-\t * paintTrack\n-\t */\n-\tprivate boolean paintTrack;\n-\n-\t/**\n-\t * paintLabels\n-\t */\n-\tprivate boolean paintLabels;\n-\n-\t/**\n-\t * isInverted\n-\t */\n-\tprivate boolean isInverted;\n-\n-\t/**\n-\t * sliderModel\n-\t */\n-\tprotected BoundedRangeModel sliderModel;\n-\n-\t/**\n-\t * majorTickSpacing\n-\t */\n-\tprotected int majorTickSpacing;\n-\n-\t/**\n-\t * minorTickSpacing\n-\t */\n-\tprotected int minorTickSpacing;\n-\n-\t/**\n-\t * snapToTicks\n-\t */\n-\tprotected boolean snapToTicks;\n-\n-\t/**\n-\t * snapToValue\n-\t */\n-\tboolean snapToValue;\n-\n-\t/**\n-\t * orientation\n-\t */\n-\tprotected int orientation;\n-\n-\t/**\n-\t * labelTable\n-\t */\n-\tprivate Dictionary labelTable;\n-\n-\t/**\n-\t * changeListener\n-\t */\n-\tprotected ChangeListener changeListener;\n-\n-\t/**\n-\t * changeEvent\n-\t */\n-\tprotected transient ChangeEvent changeEvent;\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor JSlider\n-\t */\n-\tpublic JSlider() {\n-\t\t// TODO\n-\t} // JSlider()\n-\n-\t/**\n-\t * Constructor JSlider\n-\t * @param value0 TODO\n-\t */\n-\tpublic JSlider(int orientation) {\n-\t\t// TODO\n-\t} // JSlider()\n-\n-\t/**\n-\t * Constructor JSlider\n-\t * @param minimum TODO\n-\t * @param maximum TODO\n-\t */\n-\tpublic JSlider(int minimum, int maximum) {\n-\t\t// TODO\n-\t} // JSlider()\n-\n-\t/**\n-\t * Constructor JSlider\n-\t * @param minimum TODO\n-\t * @param maximum TODO\n-\t * @param value TODO\n-\t */\n-\tpublic JSlider(int minimum, int maximum, int value) {\n-\t\t// TODO\n-\t} // JSlider()\n-\n-\t/**\n-\t * Constructor JSlider\n-\t * @param orientation TODO\n-\t * @param minimum TODO\n-\t * @param maximum TODO\n-\t * @param value TODO\n-\t */\n-\tpublic JSlider(int orientation, int minimum, int maximum, int value) {\n-\t\t// TODO\n-\t} // JSlider()\n-\n-\t/**\n-\t * Constructor JSlider\n-\t * @param value0 TODO\n-\t */\n-\tpublic JSlider(BoundedRangeModel model) {\n-\t\t// TODO\n-\t} // JSlider()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * writeObject\n-\t * @param stream TODO\n-\t * @exception IOException TODO\n-\t */\n-\tprivate void writeObject(ObjectOutputStream stream) throws IOException {\n-\t\t// TODO\n-\t} // writeObject()\n-\n-\t/**\n-\t * getValue\n-\t * @returns int\n-\t */\n-\tpublic int getValue() {\n-\t\treturn 0; // TODO\n-\t} // getValue()\n-\n-\t/**\n-\t * setValue\n-\t * @param value0 TODO\n-\t */\n-\tpublic void setValue(int value) {\n-\t\t// TODO\n-\t} // setValue()\n-\n-\t/**\n-\t * getUI\n-\t * @returns SliderUI\n-\t */\n-\tpublic SliderUI getUI() {\n-\t\treturn (SliderUI) ui;\n-\t} // getUI()\n-\n-\t/**\n-\t * setUI\n-\t * @param ui TODO\n-\t */\n-\tpublic void setUI(SliderUI ui) {\n-\t\tsuper.setUI(ui);\n-\t} // setUI()\n-\n-\t/**\n-\t * updateUI\n-\t */\n-\tpublic void updateUI() {\n-\t\tsetUI((SliderUI) UIManager.get(this));\n-\t\tinvalidate();\n-\t} // updateUI()\n-\n-\t/**\n-\t * getUIClassID\n-\t * @returns String\n-\t */\n-\tpublic String getUIClassID() {\n-\t\treturn uiClassID;\n-\t} // getUIClassID()\n-\n-\t/**\n-\t * createChangeListener\n-\t * @returns ChangeListener\n-\t */\n-\tprotected ChangeListener createChangeListener() {\n-\t\treturn null; // TODO\n-\t} // createChangeListener()\n-\n-\t/**\n-\t * addChangeListener\n-\t * @param listener TODO\n-\t */\n-\tpublic void addChangeListener(ChangeListener listener) {\n-\t\t// TODO\n-\t} // addChangeListener()\n-\n-\t/**\n-\t * removeChangeListener\n-\t * @param listener TODO\n-\t */\n-\tpublic void removeChangeListener(ChangeListener listener) {\n-\t\t// TODO\n-\t} // removeChangeListener()\n-\n-\t/**\n-\t * fireStateChanged\n-\t */\n-\tprotected void fireStateChanged() {\n-\t\t// TODO\n-\t} // fireStateChanged()\n-\n-\t/**\n-\t * getModel\n-\t * @returns BoundedRangeModel\n-\t */\n-\tpublic BoundedRangeModel getModel() {\n-\t\treturn null; // TODO\n-\t} // getModel()\n-\n-\t/**\n-\t * setModel\n-\t * @param model TODO\n-\t */\n-\tpublic void setModel(BoundedRangeModel model) {\n-\t\t// TODO\n-\t} // setModel()\n-\n-\t/**\n-\t * getMinimum\n-\t * @returns int\n-\t */\n-\tpublic int getMinimum() {\n-\t\treturn 0; // TODO\n-\t} // getMinimum()\n-\n-\t/**\n-\t * setMinimum\n-\t * @param minimum TODO\n-\t */\n-\tpublic void setMinimum(int minimum) {\n-\t\t// TODO\n-\t} // setMinimum()\n-\n-\t/**\n-\t * getMaximum\n-\t * @returns int\n-\t */\n-\tpublic int getMaximum() {\n-\t\treturn 0; // TODO\n-\t} // getMaximum()\n-\n-\t/**\n-\t * setMaximum\n-\t * @param maximum TODO\n-\t */\n-\tpublic void setMaximum(int maximum) {\n-\t\t// TODO\n-\t} // setMaximum()\n-\n-\t/**\n-\t * getValueIsAdjusting\n-\t * @returns boolean\n-\t */\n-\tpublic boolean getValueIsAdjusting() {\n-\t\treturn false; // TODO\n-\t} // getValueIsAdjusting()\n-\n-\t/**\n-\t * setValueIsAdjusting\n-\t * @param adjusting TODO\n-\t */\n-\tpublic void setValueIsAdjusting(boolean adjusting) {\n-\t\t// TODO\n-\t} // setValueIsAdjusting()\n-\n-\t/**\n-\t * getExtent\n-\t * @returns int\n-\t */\n-\tpublic int getExtent() {\n-\t\treturn 0; // TODO\n-\t} // getExtent()\n-\n-\t/**\n-\t * setExtent\n-\t * @param vextent TODO\n-\t */\n-\tpublic void setExtent(int extent) {\n-\t\t// TODO\n-\t} // setExtent()\n-\n-\t/**\n-\t * getOrientation\n-\t * @returns int\n-\t */\n-\tpublic int getOrientation() {\n-\t\treturn 0; // TODO\n-\t} // getOrientation()\n-\n-\t/**\n-\t * setOrientation\n-\t * @param orientation TODO\n-\t */\n-\tpublic void setOrientation(int orientation) {\n-\t\t// TODO\n-\t} // setOrientation()\n-\n-\t/**\n-\t * getLabelTable\n-\t * @returns Dictionary\n-\t */\n-\tpublic Dictionary getLabelTable() {\n-\t\treturn null; // TODO\n-\t} // getLabelTable()\n-\n-\t/**\n-\t * setLabelTable\n-\t * @param table TODO\n-\t */\n-\tpublic void setLabelTable(Dictionary table) {\n-\t\t// TODO\n-\t} // setLabelTable()\n-\n-\t/**\n-\t * updateLabelUIs\n-\t */\n-\tprotected void updateLabelUIs() {\n-\t\t// TODO\n-\t} // updateLabelUIs()\n-\n-\t/**\n-\t * createStandardLabels\n-\t * @param increment TODO\n-\t * @returns Hashtable\n-\t */\n-\tpublic Hashtable createStandardLabels(int increment) {\n-\t\treturn null; // TODO\n-\t} // createStandardLabels()\n-\n-\t/**\n-\t * createStandardLabels\n-\t * @param increment TODO\n-\t * @param start TODO\n-\t * @returns Hashtable\n-\t */\n-\tpublic Hashtable createStandardLabels(int increment, int start) {\n-\t\treturn null; // TODO\n-\t} // createStandardLabels()\n-\n-\t/**\n-\t * getInverted\n-\t * @returns boolean\n-\t */\n-\tpublic boolean getInverted() {\n-\t\treturn false; // TODO\n-\t} // getInverted()\n-\n-\t/**\n-\t * setInverted\n-\t * @param inverted TODO\n-\t */\n-\tpublic void setInverted(boolean inverted) {\n-\t\t// TODO\n-\t} // setInverted()\n-\n-\t/**\n-\t * getMajorTickSpacing\n-\t * @returns int\n-\t */\n-\tpublic int getMajorTickSpacing() {\n-\t\treturn 0; // TODO\n-\t} // getMajorTickSpacing()\n-\n-\t/**\n-\t * setMajorTickSpacing\n-\t * @param spacing TODO\n-\t */\n-\tpublic void setMajorTickSpacing(int spacing) {\n-\t\t// TODO\n-\t} // setMajorTickSpacing()\n-\n-\t/**\n-\t * getMinorTickSpacing\n-\t * @returns int\n-\t */\n-\tpublic int getMinorTickSpacing() {\n-\t\treturn 0; // TODO\n-\t} // getMinorTickSpacing()\n-\n-\t/**\n-\t * setMinorTickSpacing\n-\t * @param spacing TODO\n-\t */\n-\tpublic void setMinorTickSpacing(int spacing) {\n-\t\t// TODO\n-\t} // setMinorTickSpacing()\n-\n-\t/**\n-\t * getSnapToTicks\n-\t * @returns boolean\n-\t */\n-\tpublic boolean getSnapToTicks() {\n-\t\treturn false; // TODO\n-\t} // getSnapToTicks()\n-\n-\t/**\n-\t * getSnapToValue\n-\t * @returns boolean\n-\t */\n-\tboolean getSnapToValue() {\n-\t\treturn false; // TODO\n-\t} // getSnapToValue()\n-\n-\t/**\n-\t * setSnapToTicks\n-\t * @param snap TODO\n-\t */\n-\tpublic void setSnapToTicks(boolean snap) {\n-\t\t// TODO\n-\t} // setSnapToTicks()\n-\n-\t/**\n-\t * getPaintTicks\n-\t * @returns boolean\n-\t */\n-\tpublic boolean getPaintTicks() {\n-\t\treturn false; // TODO\n-\t} // getPaintTicks()\n-\n-\t/**\n-\t * setPaintTicks\n-\t * @param paint TODO\n-\t */\n-\tpublic void setPaintTicks(boolean paint) {\n-\t\t// TODO\n-\t} // setPaintTicks()\n-\n-\t/**\n-\t * getPaintTrack\n-\t * @returns boolean\n-\t */\n-\tpublic boolean getPaintTrack() {\n-\t\treturn false; // TODO\n-\t} // getPaintTrack()\n-\n-\t/**\n-\t * setPaintTrack\n-\t * @param paint TODO\n-\t */\n-\tpublic void setPaintTrack(boolean paint) {\n-\t\t// TODO\n-\t} // setPaintTrack()\n-\n-\t/**\n-\t * getPaintLabels\n-\t * @returns boolean\n-\t */\n-\tpublic boolean getPaintLabels() {\n-\t\treturn false; // TODO\n-\t} // getPaintLabels()\n-\n-\t/**\n-\t * setPaintLabels\n-\t * @param paint TODO\n-\t */\n-\tpublic void setPaintLabels(boolean paint) {\n-\t\t// TODO\n-\t} // setPaintLabels()\n-\n-\t/**\n-\t * paramString\n-\t * @returns String\n-\t */\n-\tprotected String paramString() {\n-\t\treturn null; // TODO\n-\t} // paramString()\n-\n-\t/**\n-\t * getAccessibleContext\n-\t * @returns AccessibleContext\n-\t */\n-\tpublic AccessibleContext getAccessibleContext() {\n-\t\tif (accessibleContext == null) {\n-\t\t\taccessibleContext = new AccessibleJSlider(this);\n-\t\t} // if\n-\t\treturn accessibleContext;\n-\t} // getAccessibleContext()\n-\n-\n-} // JSlider\n+  /**\n+   * DOCUMENT ME!\n+   */\n+  protected class AccessibleJSlider extends JComponent.AccessibleJComponent\n+    implements AccessibleValue\n+  {\n+    /**\n+     * Creates a new AccessibleJSlider object.\n+     *\n+     * @param value0 DOCUMENT ME!\n+     */\n+    protected AccessibleJSlider(JSlider value0)\n+    {\n+      super(value0);\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public AccessibleStateSet getAccessibleStateSet()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public AccessibleRole getAccessibleRole()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public AccessibleValue getAccessibleValue()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * DOCUMENT ME!\n+     *\n+     * @return DOCUMENT ME!\n+     */\n+    public Number getCurrentAccessibleValue()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * setCurrentAccessibleValue\n+     *\n+     * @param value0 TODO\n+     *\n+     * @return boolean\n+     */\n+    public boolean setCurrentAccessibleValue(Number value0)\n+    {\n+      return false;\n+    }\n+\n+    /**\n+     * getMinimumAccessibleValue\n+     *\n+     * @return Number\n+     */\n+    public Number getMinimumAccessibleValue()\n+    {\n+      return null;\n+    }\n+\n+    /**\n+     * getMaximumAccessibleValue\n+     *\n+     * @return Number\n+     */\n+    public Number getMaximumAccessibleValue()\n+    {\n+      return null;\n+    }\n+  }\n+\n+  /** Fired in a PropertyChangeEvent when the \"inverted\" property changes. */\n+  public static final String INVERTED_CHANGED_PROPERTY = \"inverted\";\n+\n+  /** Fired in a PropertyChangeEvent when the \"labelTable\" property changes. */\n+  public static final String LABEL_TABLE_CHANGED_PROPERTY = \"labelTable\";\n+\n+  /**\n+   * Fired in a PropertyChangeEvent when the \"majorTickSpacing\" property\n+   * changes.\n+   */\n+  public static final String MAJOR_TICK_SPACING_CHANGED_PROPERTY = \"majorTickSpacing\";\n+\n+  /**\n+   * Fired in a PropertyChangeEvent when the \"minorTickSpacing\" property\n+   * changes.\n+   */\n+  public static final String MINOR_TICK_SPACING_CHANGED_PROPERTY = \"minorTickSpacing\";\n+\n+  /** Fired in a PropertyChangeEvent when the \"model\" property changes. */\n+  public static final String MODEL_CHANGED_PROPERTY = \"model\";\n+\n+  /** Fired in a PropertyChangeEvent when the \"orientation\" property changes. */\n+  public static final String ORIENTATION_CHANGED_PROPERTY = \"orientation\";\n+\n+  /** Fired in a PropertyChangeEvent when the \"paintLabels\" property changes. */\n+  public static final String PAINT_LABELS_CHANGED_PROPERTY = \"paintLabels\";\n+\n+  /** Fired in a PropertyChangeEvent when the \"paintTicks\" property changes. */\n+  public static final String PAINT_TICKS_CHANGED_PROPERTY = \"paintTicks\";\n+  \n+  /** Whether or not this slider paints its ticks. */\n+  private transient boolean paintTicks = false;\n+\n+  /** Whether or not this slider paints its track. */\n+  private transient boolean paintTrack = true;\n+\n+  /** Whether or not this slider paints its labels. */\n+  private transient boolean paintLabels = false;\n+\n+  /**\n+   * A dictionary of (Integer, Component) pairs where each Component is a\n+   * JLabel and the Integer determines where the label will be painted.\n+   */\n+  private transient Dictionary labelTable;\n+\n+  /** A list of all ChangeListeners listening to this slider. */\n+  private transient EventListenerList changeListenerList;\n+\n+  /** The model used to describe the slider. */\n+  protected BoundedRangeModel sliderModel;\n+\n+  /** The space between major ticks. */\n+  protected int majorTickSpacing;\n+\n+  /** The space between minor ticks. */\n+  protected int minorTickSpacing;\n+\n+  /** Whether the slider snaps its values to ticks. */\n+  protected boolean snapToTicks = true;\n+\n+  /** The orientation of the slider. */\n+  protected int orientation = HORIZONTAL;\n+\n+  /** Whether the slider is inverted. */\n+  private transient boolean isInverted;\n+\n+  /** The ChangeListener that listens to the model. */\n+  protected ChangeListener changeListener;\n+\n+  /** The ChangeEvent that is passed to all listeners of this slider. */\n+  protected transient ChangeEvent changeEvent;\n+\n+  /**\n+   * Creates a new horizontal JSlider object with a minimum of 0, a maximum of\n+   * 100, and a value of 50.\n+   */\n+  public JSlider()\n+  {\n+    this(HORIZONTAL, 0, 100, 50);\n+  }\n+\n+  /**\n+   * Creates a new JSlider object with the given orientation and a minimum of\n+   * 0, a maximum of 100, and a value of 50.\n+   *\n+   * @param orientation The orientation of the slider.\n+   */\n+  public JSlider(int orientation)\n+  {\n+    this(orientation, 0, 100, 50);\n+  }\n+\n+  /**\n+   * Creates a new horizontal JSlider object with the given maximum and\n+   * minimum and a value that is  halfway between the minimum and the\n+   * maximum.\n+   *\n+   * @param minimum The minimum value of the JSlider.\n+   * @param maximum The maximum value of the JSlider.\n+   */\n+  public JSlider(int minimum, int maximum)\n+  {\n+    this(HORIZONTAL, minimum, maximum, (maximum - minimum) / 2);\n+  }\n+\n+  /**\n+   * Creates a new horizontal JSlider object with the given minimum, maximum,\n+   * and value.\n+   *\n+   * @param minimum The minimum value of the JSlider.\n+   * @param maximum The maximum value of the JSlider.\n+   * @param value The initial value of the JSlider.\n+   */\n+  public JSlider(int minimum, int maximum, int value)\n+  {\n+    this(HORIZONTAL, minimum, maximum, value);\n+  }\n+\n+  /**\n+   * Creates a new JSlider object with the given orientation, minimum,\n+   * maximum, and value.\n+   *\n+   * @param orientation The orientation of the JSlider.\n+   * @param minimum The minimum value of the JSlider.\n+   * @param maximum The maximum value of the JSlider.\n+   * @param value The initial value of the JSlider.\n+   */\n+  public JSlider(int orientation, int minimum, int maximum, int value)\n+  {\n+    sliderModel = new DefaultBoundedRangeModel(value, 0, minimum, maximum);\n+    if (orientation != HORIZONTAL && orientation != VERTICAL)\n+      throw new IllegalArgumentException(orientation + \" is not a legal orientation\");\n+    this.orientation = orientation;\n+    changeListener = createChangeListener();\n+    changeListenerList = new EventListenerList();\n+    sliderModel.addChangeListener(changeListener);\n+    updateUI();\n+  }\n+\n+  /**\n+   * Creates a new horizontal JSlider object with the given model.\n+   *\n+   * @param model The model the slider will be created with.\n+   */\n+  public JSlider(BoundedRangeModel model)\n+  {\n+    if (model == null)\n+      sliderModel = new DefaultBoundedRangeModel(50, 0, 0, 100);\n+    else\n+      sliderModel = model;\n+    changeListener = createChangeListener();\n+    changeListenerList = new EventListenerList();\n+    sliderModel.addChangeListener(changeListener);\n+    updateUI();\n+  }\n+\n+  /**\n+   * This method returns the current value of the slider.\n+   *\n+   * @return The value of the slider stored in the model.\n+   */\n+  public int getValue()\n+  {\n+    return sliderModel.getValue();\n+  }\n+\n+  /**\n+   * This method sets the value of the slider.\n+   *\n+   * @param value The slider's new value.\n+   */\n+  public void setValue(int value)\n+  {\n+    sliderModel.setValue(value);\n+  }\n+\n+  /**\n+   * This method returns the slider's UI delegate.\n+   *\n+   * @return The slider's UI delegate.\n+   */\n+  public SliderUI getUI()\n+  {\n+    return (SliderUI) ui;\n+  }\n+\n+  /**\n+   * This method sets the slider's UI delegate.\n+   *\n+   * @param ui A SliderUI object to use with this slider.\n+   */\n+  public void setUI(SliderUI ui)\n+  {\n+    super.setUI(ui);\n+  }\n+\n+  /**\n+   * This method sets this slider's UI to the UIManager's default for the\n+   * current look and feel.\n+   */\n+  public void updateUI()\n+  {\n+    setUI((SliderUI) UIManager.getUI(this));\n+    invalidate();\n+    repaint();\n+  }\n+\n+  /**\n+   * This method returns a name to identify which look and feel class will be\n+   * the UI delegate for the slider.\n+   *\n+   * @return The L&F classID. \"SliderUI\"\n+   */\n+  public String getUIClassID()\n+  {\n+    return \"SliderUI\";\n+  }\n+\n+  /**\n+   * Creates a ChangeListener for this Slider.\n+   *\n+   * @return A new ChangeListener.\n+   */\n+  protected ChangeListener createChangeListener()\n+  {\n+    return new ChangeListener()\n+      {\n+\tpublic void stateChanged(ChangeEvent ce)\n+\t{\n+\t  // No need to trigger a repaint since the UI listens to the model\n+\t  // as well. All we need to do is pass on the stateChanged event \n+\t  // to our listeners.\n+\t  fireStateChanged();\n+\t}\n+      };\n+  }\n+\n+  /**\n+   * This method registers a listener to this slider. The listener will be\n+   * informed of new ChangeEvents.\n+   *\n+   * @param listener The listener to register.\n+   */\n+  public void addChangeListener(ChangeListener listener)\n+  {\n+    changeListenerList.add(ChangeListener.class, listener);\n+  }\n+\n+  /**\n+   * This method removes a listener from this slider.\n+   *\n+   * @param listener The listener to remove.\n+   */\n+  public void removeChangeListener(ChangeListener listener)\n+  {\n+    changeListenerList.remove(ChangeListener.class, listener);\n+  }\n+\n+  /**\n+   * This method is called whenever the model fires a ChangeEvent. It should\n+   * propagate the ChangeEvent to its listeners with a new ChangeEvent that\n+   * identifies the slider as the source.\n+   */\n+  protected void fireStateChanged()\n+  {\n+    Object[] changeListeners = changeListenerList.getListenerList();\n+    if (changeEvent == null)\n+      changeEvent = new ChangeEvent(this);\n+    for (int i = changeListeners.length - 2; i >= 0; i -= 2)\n+      {\n+\tif (changeListeners[i] == ChangeListener.class)\n+\t  ((ChangeListener) changeListeners[i + 1]).stateChanged(changeEvent);\n+      }\n+  }\n+\n+  /**\n+   * This method returns an array of all ChangeListeners listening to this\n+   * slider.\n+   *\n+   * @return An array of ChangeListeners listening to this slider.\n+   */\n+  public ChangeListener[] getChangeListeners()\n+  {\n+    return (ChangeListener[]) changeListenerList.getListenerList();\n+  }\n+\n+  /**\n+   * This method returns the model of the slider.\n+   *\n+   * @return The slider's model.\n+   */\n+  public BoundedRangeModel getModel()\n+  {\n+    return sliderModel;\n+  }\n+\n+  /**\n+   * This method changes the \"model\" property. It also needs  to unregister\n+   * any listeners to the old model and register any listeners to the new\n+   * model.\n+   *\n+   * @param model The model to use with the slider.\n+   */\n+  public void setModel(BoundedRangeModel model)\n+  {\n+    // I didn't do the null pointer check on purpose.\n+    // If you try it with Sun's, it'll go ahead and set it to null\n+    // and bork the next time it tries to access the model.\n+    if (model != sliderModel)\n+      {\n+\tBoundedRangeModel oldModel = sliderModel;\n+\tsliderModel = model;\n+\toldModel.removeChangeListener(changeListener);\n+\tsliderModel.addChangeListener(changeListener);\n+\tfirePropertyChange(MODEL_CHANGED_PROPERTY, oldModel, sliderModel);\n+      }\n+  }\n+\n+  /**\n+   * This method returns the minimum value of the slider.\n+   *\n+   * @return The minimum value of the slider.\n+   */\n+  public int getMinimum()\n+  {\n+    return sliderModel.getMinimum();\n+  }\n+\n+  /**\n+   * This method sets the minimum value of the slider.\n+   *\n+   * @param minimum The minimum value of the slider.\n+   */\n+  public void setMinimum(int minimum)\n+  {\n+    sliderModel.setMinimum(minimum);\n+  }\n+\n+  /**\n+   * This method returns the maximum value of the slider.\n+   *\n+   * @return The maximum value of the slider.\n+   */\n+  public int getMaximum()\n+  {\n+    return sliderModel.getMaximum();\n+  }\n+\n+  /**\n+   * This method sets the maximum value of the slider.\n+   *\n+   * @param maximum The maximum value of the slider.\n+   */\n+  public void setMaximum(int maximum)\n+  {\n+    sliderModel.setMaximum(maximum);\n+  }\n+\n+  /**\n+   * This method returns this slider's isAdjusting value which is true if the\n+   * thumb is being dragged.\n+   *\n+   * @return The slider's isAdjusting value.\n+   */\n+  public boolean getValueIsAdjusting()\n+  {\n+    return sliderModel.getValueIsAdjusting();\n+  }\n+\n+  /**\n+   * This method sets the isAdjusting value for the slider.\n+   *\n+   * @param adjusting The slider's isAdjusting value.\n+   */\n+  public void setValueIsAdjusting(boolean adjusting)\n+  {\n+    sliderModel.setValueIsAdjusting(adjusting);\n+  }\n+\n+  /**\n+   * This method returns the extent value for this slider.\n+   *\n+   * @return The extent value for this slider.\n+   */\n+  public int getExtent()\n+  {\n+    return sliderModel.getExtent();\n+  }\n+\n+  /**\n+   * This method sets the extent value for this slider.\n+   *\n+   * @param extent The extent value for this slider.\n+   */\n+  public void setExtent(int extent)\n+  {\n+    sliderModel.setExtent(extent);\n+  }\n+\n+  /**\n+   * This method returns the slider orientation.\n+   *\n+   * @return The orientation of the slider.\n+   */\n+  public int getOrientation()\n+  {\n+    return orientation;\n+  }\n+\n+  /**\n+   * This method changes the \"orientation\" property of this slider. If the\n+   * orientation is not VERTICAL or HORIZONTAL, this method does nothing.\n+   *\n+   * @param orientation The orientation of this slider.\n+   */\n+  public void setOrientation(int orientation)\n+  {\n+    if (orientation != VERTICAL && orientation != HORIZONTAL)\n+      throw new IllegalArgumentException(\"orientation must be one of: VERTICAL, HORIZONTAL\");\n+    if (orientation != this.orientation)\n+      {\n+\tint oldOrientation = this.orientation;\n+\tthis.orientation = orientation;\n+\tfirePropertyChange(ORIENTATION_CHANGED_PROPERTY, oldOrientation,\n+\t                   this.orientation);\n+      }\n+  }\n+\n+  /**\n+   * This method returns the label table for this slider.\n+   *\n+   * @return The label table for this slider.\n+   */\n+  public Dictionary getLabelTable()\n+  {\n+    return labelTable;\n+  }\n+\n+  /**\n+   * This method changes the \"labelTable\" property of this slider.\n+   *\n+   * @param table The label table for this slider.\n+   */\n+  public void setLabelTable(Dictionary table)\n+  {\n+    if (table != labelTable)\n+      {\n+\tDictionary oldTable = labelTable;\n+\tlabelTable = table;\n+\tfirePropertyChange(LABEL_TABLE_CHANGED_PROPERTY, oldTable, labelTable);\n+      }\n+  }\n+\n+  /**\n+   * This method is called to reset UI delegates for the labels in the\n+   * labelTable to a default for the current look and feel.\n+   */\n+  protected void updateLabelUIs()\n+  {\n+    if (labelTable == null)\n+      return;\n+    for (Enumeration list = labelTable.elements(); list.hasMoreElements();)\n+      {\n+\tJLabel label = (JLabel) list.nextElement();\n+\tlabel.updateUI();\n+      }\n+  }\n+\n+  /**\n+   * Creates a hashtable of (Integer, JLabel) pairs that can be used as a\n+   * label table for this slider. The labels will start from the sliders\n+   * minimum and increase by the increment. Each  label will have a text\n+   * string indicating their integer value.\n+   *\n+   * @param increment The increment to between labels.\n+   *\n+   * @return A hashtable with the labels and their keys.\n+   */\n+  public Hashtable createStandardLabels(int increment)\n+  {\n+    return createStandardLabels(increment, sliderModel.getMinimum());\n+  }\n+\n+  /**\n+   * Creates a hashtable of (Integer, JLabel) pairs that can be used as a\n+   * label table for this slider. The labels will start from the given start\n+   * value and increase by the increment. Each  label will have a text string\n+   * indicating their integer value.\n+   *\n+   * @param increment The increment to between labels.\n+   * @param start The value to start from.\n+   *\n+   * @return A hashtable with the labels and their keys.\n+   */\n+  public Hashtable createStandardLabels(int increment, int start)\n+  {\n+    Hashtable table = new Hashtable();\n+    JLabel label;\n+    Dimension dim;\n+\n+    int max = sliderModel.getMaximum();\n+\n+    for (int i = start; i <= max; i += increment)\n+      {\n+\tlabel = new JLabel(String.valueOf(i));\n+\tlabel.setVerticalAlignment(CENTER);\n+\tlabel.setHorizontalAlignment(CENTER);\n+\t\n+\t// Make sure these labels have the width and height\n+\t// they want.\n+\tdim = label.getPreferredSize();\n+\tlabel.setBounds(label.getX(), label.getY(),\n+\t                (int) dim.getWidth(),\n+\t\t\t(int) dim.getHeight()); \n+\ttable.put(new Integer(i), label);\n+      }\n+    return table;\n+  }\n+\n+  /**\n+   * This method returns whether the slider is inverted. Horizontal sliders\n+   * that are not inverted will have the minimums on the left. If they are\n+   * inverted, the minimums will be  on the right. Vertical sliders that are\n+   * not inverted will have the minimums at the bottom. If they are inverted,\n+   * the minimums will be at the top.\n+   *\n+   * @return Whether this slider is inverted.\n+   */\n+  public boolean getInverted()\n+  {\n+    return isInverted;\n+  }\n+\n+  /**\n+   * This method changes the \"inverted\" property for this slider.Horizontal\n+   * sliders  that are not inverted will have the minimums on the left. If\n+   * they are inverted, the minimums will be  on the right. Vertical sliders\n+   * that are not inverted will have the minimums at the bottom. If they are\n+   * inverted, the minimums will be at the top. However, if the slider's\n+   * componentOrientation is set to RIGHT_TO_LEFT, then everything gets\n+   * reversed again.\n+   *\n+   * @param inverted Whether the slider should be inverted.\n+   */\n+  public void setInverted(boolean inverted)\n+  {\n+    if (isInverted != inverted)\n+      {\n+\tboolean oldInverted = isInverted;\n+\tisInverted = inverted;\n+\tfirePropertyChange(INVERTED_CHANGED_PROPERTY, oldInverted, isInverted);\n+      }\n+  }\n+\n+  /**\n+   * This method returns the amount of units between each major tick mark.\n+   *\n+   * @return The amount of units between each major tick mark.\n+   */\n+  public int getMajorTickSpacing()\n+  {\n+    return majorTickSpacing;\n+  }\n+\n+  /**\n+   * This method changes the \"majorTickSpacing\" property for this slider. The\n+   * major tick spacing is the amount of units between each major tick mark.\n+   *\n+   * @param spacing The amount of units between each major tick mark.\n+   */\n+  public void setMajorTickSpacing(int spacing)\n+  {\n+    if (majorTickSpacing != spacing)\n+      {\n+\tint oldSpacing = majorTickSpacing;\n+\tmajorTickSpacing = spacing;\n+\tfirePropertyChange(MAJOR_TICK_SPACING_CHANGED_PROPERTY, oldSpacing,\n+\t                   majorTickSpacing);\n+      }\n+  }\n+\n+  /**\n+   * This method returns the amount of units between each minor tick mark.\n+   *\n+   * @return The amount of units between each minor tick mark.\n+   */\n+  public int getMinorTickSpacing()\n+  {\n+    return minorTickSpacing;\n+  }\n+\n+  /**\n+   * This method changes the \"minorTickSpacing\" property for this slider. The\n+   * minor tick spacing is the amount of units between each minor tick mark.\n+   *\n+   * @param spacing The amount of units between each minor tick mark.\n+   */\n+  public void setMinorTickSpacing(int spacing)\n+  {\n+    if (minorTickSpacing != spacing)\n+      {\n+\tint oldSpacing = minorTickSpacing;\n+\tminorTickSpacing = spacing;\n+\tfirePropertyChange(MINOR_TICK_SPACING_CHANGED_PROPERTY, oldSpacing,\n+\t                   minorTickSpacing);\n+      }\n+  }\n+\n+  /**\n+   * This method returns whether this slider is snapping to ticks.  Sliders\n+   * that snap to ticks will automatically move the thumb to the nearest tick\n+   * mark.\n+   *\n+   * @return Whether this slider snaps to ticks.\n+   */\n+  public boolean getSnapToTicks()\n+  {\n+    return snapToTicks;\n+  }\n+\n+  /**\n+   * This method sets whether this slider will snap to ticks. Sliders that\n+   * snap to ticks will automatically move the thumb to the nearest tick\n+   * mark.\n+   *\n+   * @param snap Whether this slider snaps to ticks.\n+   */\n+  public void setSnapToTicks(boolean snap)\n+  {\n+    if (snap != snapToTicks)\n+      {\n+\tsnapToTicks = snap;\n+\tfireStateChanged();\n+      }\n+  }\n+\n+  /**\n+   * This method returns whether the slider will paint its tick marks. In\n+   * addition to setting this property to true, one of minor tick spacing  or\n+   * major tick spacing must be set to a value greater than 0 in order for\n+   * ticks to be painted.\n+   *\n+   * @return Whether ticks will be painted.\n+   */\n+  public boolean getPaintTicks()\n+  {\n+    return paintTicks;\n+  }\n+\n+  /**\n+   * This method changes the \"paintTicks\" property for this slider. In\n+   * addition to setting this property to true, one of minor tick spacing  or\n+   * major tick spacing must be set to a value greater than 0 in order for\n+   * ticks to be painted.\n+   *\n+   * @param paint Whether ticks will be painted.\n+   */\n+  public void setPaintTicks(boolean paint)\n+  {\n+    if (paint != paintTicks)\n+      {\n+\tboolean oldPaintTicks = paintTicks;\n+\tpaintTicks = paint;\n+\tfirePropertyChange(PAINT_TICKS_CHANGED_PROPERTY, oldPaintTicks,\n+\t                   paintTicks);\n+      }\n+  }\n+\n+  /**\n+   * This method returns whether the track will be painted.\n+   *\n+   * @return Whether the track will be painted.\n+   */\n+  public boolean getPaintTrack()\n+  {\n+    return paintTrack;\n+  }\n+\n+  /**\n+   * This method sets whether the track will be painted.\n+   *\n+   * @param paint Whether the track will be painted.\n+   */\n+  public void setPaintTrack(boolean paint)\n+  {\n+    paintTrack = paint;\n+  }\n+\n+  /**\n+   * This method returns whether labels will be painted.\n+   *\n+   * @return Whether labels will be painted.\n+   */\n+  public boolean getPaintLabels()\n+  {\n+    return paintLabels;\n+  }\n+\n+  /**\n+   * This method changes the \"paintLabels\" property.\n+   *\n+   * @param paint Whether labels will be painted.\n+   */\n+  public void setPaintLabels(boolean paint)\n+  {\n+    if (paint != paintLabels)\n+      {\n+\tboolean oldPaintLabels = paintLabels;\n+\tpaintLabels = paint;\n+\tfirePropertyChange(PAINT_LABELS_CHANGED_PROPERTY, oldPaintLabels,\n+\t                   paintLabels);\n+      }\n+  }\n+\n+  /**\n+   * This method is used primarily for debugging purposes and returns a string\n+   * that can be used to represent this slider.\n+   *\n+   * @return A string representing this slider.\n+   */\n+  protected String paramString()\n+  {\n+    return \"JSlider\";\n+  }\n+\n+  /**\n+   * DOCUMENT ME!\n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public AccessibleContext getAccessibleContext()\n+  {\n+    if (accessibleContext == null)\n+      accessibleContext = new AccessibleJSlider(this);\n+    return accessibleContext;\n+  }\n+}"}, {"sha": "9174a833b70bf4182b3c35f74afa6d40dac4712b", "filename": "libjava/javax/swing/JViewport.java", "status": "modified", "additions": 225, "deletions": 88, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FJViewport.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FJViewport.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FJViewport.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -40,103 +40,240 @@\n \n import java.awt.Component;\n import java.awt.Container;\n+import java.awt.Dimension;\n import java.awt.Graphics;\n import java.awt.Image;\n+import java.awt.Insets;\n import java.awt.Point;\n import java.awt.Rectangle;\n+import java.awt.image.ImageObserver;\n import javax.accessibility.Accessible;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n import javax.swing.plaf.ViewportUI;\n \n+\n+/**\n+ *  \n+ * <pre>\n+ *                                                     _\n+ *   +-------------------------------+    ...........Y1 \\\n+ *   |  view                         |                .  \\\n+ *   |  (this component's child)     |                .   > VY\n+ *   |                               |                .  / = Y2-Y1\n+ *   |         +------------------------------+  ....Y2_/\n+ *   |         | viewport            |        |       .\n+ *   |         | (this component)    |        |       .\n+ *   |         |                     |        |       .\n+ *   |         |                     |        |       .\n+ *   |         |                     |        |       .\n+ *   |         |                     |        |       .\n+ *   |         +------------------------------+  ....Y3\n+ *   |                               |                .\n+ *   |         .                     |        .       .\n+ *   |         .                     |        .       .\n+ *   +---------.---------------------+    ...........Y4\n+ *   .         .                     .        .\n+ *   .         .                     .        .\n+ *   .         .                     .        .\n+ *   X1.......X2.....................X3.......X4\n+ *   \\____  ___/\n+ *        \\/\n+ *        VX = X2-X1\n+ *</pre>\n+ *  \n+ * <p>A viewport is, like all swing components, located at some position in\n+ * the swing component tree; that location is exactly the same as any other\n+ * components: the viewport's \"bounds\".</p>\n+ *\n+ * <p>But in terms of drawing its child, the viewport thinks of itself as\n+ * covering a particular position <em>of the view's coordinate space</em>.\n+ * For example, the {@link javax.JViewPort.getViewPosition} method returns\n+ * the position <code>(VX,VY)</code> shown above, which is an position in\n+ * \"view space\", even though this is <em>implemented</em> by positioning\n+ * the underlying child at position <code>(-VX,-VY)</code></p>\n+ *\n+ */\n+\n public class JViewport extends JComponent\n {\n-    Component c;\n-\n-    JViewport()\n-    {\n-\tsetOpaque(true);\n-\tupdateUI();\n-    }\n-\n-    void setView(Component c)\n-    {\n-\tif (this.c != null)\n-\t    remove(c);\n-\n-\tthis.c = c;\n-\n-\tadd(c);\n-    }\n-\n-    public String getUIClassID()\n-    {\n-\treturn \"ViewportUI\";\n-    }\n-\n-    public void updateUI()\n-    {\n-\tViewportUI vp = (ViewportUI) UIManager.getUI(this);\n-\tsetUI(vp);\n-    }\n-\n-    Container GetHeavy(Container parent)\n-    {\n-\tif (parent == null)\n-\t    return null;\n-\n-\twhile (isLightweightComponent(parent))\n-\t    {\n-\t\tContainer p = parent.getParent();\n-\n-\t\tif (p == null)\n-\t\t    {\n-\t\t\tSystem.out.println(\"GetHeavy FAILED, no heavy weight component found\");\n-\t\t\treturn parent;\n-\t\t    }\n-\t\t\n-\t\tparent = p;\n-\t    }\n-\treturn parent;\n-    }\n+  public static int BACKINGSTORE_SCROLL_MODE = 1;\n+  public static int BLIT_SCROLL_MODE = 2;\n+  public static int SIMPLE_SCROLL_MODE = 3;\n+\n+  ChangeEvent changeEvent = new ChangeEvent(this);\n+\n+  int scrollMode;\n+\n+  boolean scrollUnderway;\n+  boolean isViewSizeSet;\n+\n+  /** \n+   * The width and height of the Viewport's area in terms of view\n+   * coordinates.  Typically this will be the same as the width and height\n+   * of the viewport's bounds, unless the viewport transforms units of\n+   * width and height, which it may do, for example if it magnifies or\n+   * rotates its view.\n+   *\n+   * @see #toViewCoordinates\n+   */\n+  Dimension viewExtent;\n+\n+  Point lastPaintPosition;\n+\n+  JViewport()\n+  {\n+    setOpaque(true);\n+    updateUI();\n+  }\n+\n+  public Dimension getViewSize()\n+  {\n+    if (viewExtent == null)\n+      return getPreferredSize();\n+    else\n+      return viewExtent;\n+  }\n+\n+  public void setViewSize(Dimension newSize)\n+  {\n+    viewExtent = newSize;\n+    fireStateChanged();\n+  }\n+\n+  public Point getViewPosition()\n+  {\n+    Component view = getView();\n+    if (view == null)\n+      return new Point(0,0);\n+    else\n+      {\n+        Point p = view.getLocation();\n+        p.x = -p.x;\n+        p.y = -p.y;\n+        return p;\n+      }\n+  }\n+\n+  public void setViewPosition(Point p)\n+  {\n+    Component view = getView();\n+    if (view != null)\n+      {\n+        Point q = new Point(-p.x, -p.y);\n+        view.setLocation(q);\n+        fireStateChanged();\n+      }\n+  }\n+\n+  public Rectangle getViewRect()\n+  {\n+    return new Rectangle(getViewPosition(), \n+                         getViewSize());\n+  }\n+\n+  public boolean isBackingStoreEnabled()\n+  {\n+    return scrollMode == BACKINGSTORE_SCROLL_MODE;\n+  }\n+\n+  public void setBackingStoreEnabled(boolean b)\n+  {\n+    if (b && scrollMode != BACKINGSTORE_SCROLL_MODE)\n+      {\n+        scrollMode = BACKINGSTORE_SCROLL_MODE;\n+        fireStateChanged();\n+      }\n+  }\n+\n+  public void setScrollMode(int mode)\n+  {\n+    scrollMode = mode;\n+    fireStateChanged();\n+  }\n+\n+  public int getScrollMode()\n+  {\n+    return scrollMode;\n+  }\n+\n+  public Component getView()\n+  {\n+    if (ncomponents > 0)\n+      return component[0];\n+    else\n+      return null;\n+  }\n+\n+  public void setView(Component v)\n+  {\n+    add(v);\n+    fireStateChanged();\n+  }\n     \n     \n-    public void paint(Graphics g)\n-    {\n-\tpaintChildren(g);\n-\n-\tSystem.out.println(\"XXXXXXXXXXXXXXXXXXXXXXXXXXXX   JViewport -----> paint()\");\n-\n-\tContainer parent = GetHeavy(getParent());\n-\t\n-\tSystem.out.println(\"parent = \" + parent + \", \" + getParent());\n-\n-\t//parent.paint();\n-\n-\tGraphics wg = parent.getGraphics();\n-\t\n-\tint x = 0;\n-\tint y = 0;\n-\tint w = getWidth();\n-\tint h = getHeight();\n-\n-\tRectangle r = new Rectangle(x, y, w, h);\n-\n-\tint ox = 0;\n-\tint oy = 0;\n-\n-\twg.copyArea(r.x,\n-\t\t    r.y,\n-\t\t    r.width,\n-\t\t    r.height,\n-\t\t    ox,\n-\t\t    oy);\n-\n-\twg.dispose();\n-    }\n+  public void addImpl(Component comp, Object constraints, int index)\n+  {\n+    if (ncomponents > 0)\n+      remove(component[0]);\n+    super.addImpl(comp, constraints, index);\n+  }\n+\n+  public final Insets getInsets() \n+  {\n+    return new Insets(0,0,0,0);\n+  }\n+\n+  public final Insets getInsets(Insets insets)\n+  {\n+    if (insets == null)\n+      return getInsets();\n+    insets.top = 0;\n+    insets.bottom = 0;\n+    insets.left = 0;\n+    insets.right = 0;\n+    return insets;\n+  }\n+    \n+  public boolean isOptimizedDrawingEnabled()\n+  {\n+    return false;\n+  }\n+\n+  public ChangeListener[] getChangeListeners() \n+  {\n+    return (ChangeListener[]) getListeners(ChangeListener.class);\n+  }\n+\n+  public void paint(Graphics g)\n+  {\n+    paintComponent(g);\n+  }\n+\n+  void fireStateChanged()\n+  {\n+    ChangeListener[] listeners = getChangeListeners();\n+    for (int i = 0; i < listeners.length; ++i)\n+      listeners[i].stateChanged(changeEvent);\n+  }\n+\n+  public void addChangeListener(ChangeListener listener)\n+  {\n+    listenerList.add(ChangeListener.class, listener);\n+  }\n+\n+  public void removeChangeListener(ChangeListener listener)\n+  {\n+    listenerList.remove(ChangeListener.class, listener);\n+  }\n+\n+  public String getUIClassID()\n+  {\n+    return \"ViewportUI\";\n+  }\n+\n+  public void updateUI()\n+  {\n+    setUI((ViewportUI) UIManager.getUI(this));\n+  }            \n }\n-\n-\n-\n-\n-\n-\n-"}, {"sha": "e11fc633c0e68ffd7b36f8e2050461e0f49ec5db", "filename": "libjava/javax/swing/ListModel.java", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FListModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FListModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FListModel.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -1,4 +1,4 @@\n-/* ListModel.java -- \n+/* ListModel.java --\n    Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -36,13 +36,45 @@\n exception statement from your version. */\n \n package javax.swing;\n-\n import javax.swing.event.ListDataListener;\n \n+/**\n+ * This is an interface to general list-like data, typically used as the\n+ * model object of a {@link JList} component.\n+ *\n+ * @author Graydon Hoare (graydon&064;redhat.com)\n+ */\n public interface ListModel\n-{    \n+{\n+  /**\n+   * Return the number of data elements in the list.\n+   *\n+   * @return The number of data elements in the list\n+   */\n   int getSize();\n+\n+  /**\n+   * Retrieves a data element at a specified index.\n+   *\n+   * @param index The index of the element to retrieve\n+   *\n+   * @return The data element at the specified index\n+   */\n   Object getElementAt(int index);\n+\n+  /**\n+   * Add a listener object to this model. The listener will be called\n+   * any time the set of elements in the model is changed.\n+   *\n+   * @param l The listener to add\n+   */\n   void addListDataListener(ListDataListener l);\n+\n+  /**\n+   * Add a listener object to this model. The listener will no longer be\n+   * called when the set of elements in the model is changed.\n+   *\n+   * @param l The listener to remove\n+   */\n   void removeListDataListener(ListDataListener l);\n }"}, {"sha": "c2e9648acd766b8ea2a624d14f980693187d9220", "filename": "libjava/javax/swing/ListSelectionModel.java", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FListSelectionModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FListSelectionModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FListSelectionModel.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -42,24 +42,41 @@\n \n public interface ListSelectionModel\n {\n-    int SINGLE_SELECTION = 0;\n-    int SINGLE_INTERVAL_SELECTION = 1;\n-    int MULTIPLE_INTERVAL_SELECTION = 1;\n-\n-    void setSelectionMode(int a);\n-    int getSelectionMode();\n-\n-    void clearSelection();\n-    \n-    int getMinSelectionIndex();\n-    int getMaxSelectionIndex();\n-    boolean isSelectedIndex(int a);\n-\n-    void setSelectionInterval(int index0, int index1);\n-\n+  int SINGLE_SELECTION = 0;\n+  int SINGLE_INTERVAL_SELECTION = 1;\n+  int MULTIPLE_INTERVAL_SELECTION = 2;\n+\n+  void setSelectionMode(int a);\n+  int getSelectionMode();\n+  \n+  void clearSelection();\n     \n-\n-    void addListSelectionListener(ListSelectionListener listener);\n-    void removeListSelectionListener(ListSelectionListener listener);    \n+  int getMinSelectionIndex();\n+  int getMaxSelectionIndex();\n+\n+  boolean isSelectedIndex(int a);\n+\n+  boolean isSelectionEmpty();\n+  void setSelectionInterval(int index0, int index1);\n+  void addSelectionInterval(int index0,\n+                            int index1);\n+  void removeSelectionInterval(int index0,\n+                               int index1);\n+  void insertIndexInterval(int index,\n+                           int length,\n+                           boolean before);\n+  void removeIndexInterval(int index0,\n+                           int index1);\n+\n+  int getAnchorSelectionIndex();\n+  void setAnchorSelectionIndex(int index);\n+  int getLeadSelectionIndex();\n+  void setLeadSelectionIndex(int index);\n+\n+  void setValueIsAdjusting(boolean valueIsAdjusting);\n+  boolean getValueIsAdjusting();\n+\n+  void addListSelectionListener(ListSelectionListener listener);\n+  void removeListSelectionListener(ListSelectionListener listener);    \n \n }"}, {"sha": "c8573589f290bbe3b84839286d11ba4387602224", "filename": "libjava/javax/swing/ScrollPaneLayout.java", "status": "modified", "additions": 367, "deletions": 255, "changes": 622, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FScrollPaneLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FScrollPaneLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FScrollPaneLayout.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -41,9 +41,11 @@\n import java.awt.Component;\n import java.awt.Container;\n import java.awt.Dimension;\n+import java.awt.Insets;\n import java.awt.LayoutManager;\n import java.awt.Rectangle;\n import java.io.Serializable;\n+import javax.swing.border.Border;\n \n /**\n  * ScrollPaneLayout\n@@ -55,258 +57,368 @@\n {\n   static final long serialVersionUID = -4480022884523193743L;\n \n-\t//-------------------------------------------------------------\n-\t// Classes ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * UIResource\n-\t */\n-\tpublic static class UIResource extends ScrollPaneLayout \n-\t\t\timplements javax.swing.plaf.UIResource {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor UIResource\n-\t\t */\n-\t\tpublic UIResource() {\n-\t\t\t// TODO\n-\t\t} // UIResource()\n-\n-\n-\t} // UIResource\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * viewport\n-\t */\n-\tprotected JViewport viewport;\n-\n-\t/**\n-\t * vsb\n-\t */\n-\tprotected JScrollBar vsb;\n-\n-\t/**\n-\t * hsb\n-\t */\n-\tprotected JScrollBar hsb;\n-\n-\t/**\n-\t * rowHead\n-\t */\n-\tprotected JViewport rowHead;\n-\n-\t/**\n-\t * colHead\n-\t */\n-\tprotected JViewport colHead;\n-\n-\t/**\n-\t * lowerLeft\n-\t */\n-\tprotected Component lowerLeft;\n-\n-\t/**\n-\t * lowerRight\n-\t */\n-\tprotected Component lowerRight;\n-\n-\t/**\n-\t * upperLeft\n-\t */\n-\tprotected Component upperLeft;\n-\n-\t/**\n-\t * upperRight\n-\t */\n-\tprotected Component upperRight;\n-\n-\t/**\n-\t * vsbPolicy\n-\t */\n-\tprotected int vsbPolicy;\n-\n-\t/**\n-\t * hsbPolicy\n-\t */\n-\tprotected int hsbPolicy;\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor ScrollPaneLayout\n-\t */\n-\tpublic ScrollPaneLayout() {\n-\t\t// TODO\n-\t} // ScrollPaneLayout()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * syncWithScrollPane\n-\t * @param scrollPane TODO\n-\t */\n-\tpublic void syncWithScrollPane(JScrollPane scrollPane) {\n-\t\t// TODO\n-\t} // syncWithScrollPane()\n-\n-\t/**\n-\t * addSingletonComponent\n-\t * @param oldComponent TODO\n-\t * @param newComponent TODO\n-\t * @returns Component\n-\t */\n-\tprotected Component addSingletonComponent(Component oldComponent,\n-\t\t\tComponent newComponent) {\n-\t\treturn null; // TODO\n-\t} // addSingletonComponent()\n-\n-\t/**\n-\t * addLayoutComponent\n-\t * @param string TODO\n-\t * @param component TODO\n-\t */\n-\tpublic void addLayoutComponent(String string, Component component) {\n-\t\t// TODO\n-\t} // addLayoutComponent()\n-\n-\t/**\n-\t * removeLayoutComponent\n-\t * @param component TODO\n-\t */\n-\tpublic void removeLayoutComponent(Component component) {\n-\t\t// TODO\n-\t} // removeLayoutComponent()\n-\n-\t/**\n-\t * getVerticalScrollBarPolicy\n-\t * @returns int\n-\t */\n-\tpublic int getVerticalScrollBarPolicy() {\n-\t\treturn 0; // TODO\n-\t} // getVerticalScrollBarPolicy()\n-\n-\t/**\n-\t * setVerticalScrollBarPolicy\n-\t * @param policy TODO\n-\t */\n-\tpublic void setVerticalScrollBarPolicy(int policy) {\n-\t\t// TODO\n-\t} // setVerticalScrollBarPolicy()\n-\n-\t/**\n-\t * getHorizontalScrollBarPolicy\n-\t * @returns int\n-\t */\n-\tpublic int getHorizontalScrollBarPolicy() {\n-\t\treturn 0; // TODO\n-\t} // getHorizontalScrollBarPolicy()\n-\n-\t/**\n-\t * setHorizontalScrollBarPolicy\n-\t * @param policy TODO\n-\t */\n-\tpublic void setHorizontalScrollBarPolicy(int policy) {\n-\t\t// TODO\n-\t} // setHorizontalScrollBarPolicy()\n-\n-\t/**\n-\t * getViewport\n-\t * @returns JViewport\n-\t */\n-\tpublic JViewport getViewport() {\n-\t\treturn null; // TODO\n-\t} // getViewport()\n-\n-\t/**\n-\t * getHorizontalScrollBar\n-\t * @returns JScrollBar\n-\t */\n-\tpublic JScrollBar getHorizontalScrollBar() {\n-\t\treturn null; // TODO\n-\t} // getHorizontalScrollBar()\n-\n-\t/**\n-\t * getVerticalScrollBar\n-\t * @returns JScrollBar\n-\t */\n-\tpublic JScrollBar getVerticalScrollBar() {\n-\t\treturn null; // TODO\n-\t} // getVerticalScrollBar()\n-\n-\t/**\n-\t * getRowHeader\n-\t * @returns JViewport\n-\t */\n-\tpublic JViewport getRowHeader() {\n-\t\treturn null; // TODO\n-\t} // getRowHeader()\n-\n-\t/**\n-\t * getColumnHeader\n-\t * @returns JViewport\n-\t */\n-\tpublic JViewport getColumnHeader() {\n-\t\treturn null; // TODO\n-\t} // getColumnHeader()\n-\n-\t/**\n-\t * getCorner\n-\t * @param key TODO\n-\t * @returns Component\n-\t */\n-\tpublic Component getCorner(String key) {\n-\t\treturn null; // TODO\n-\t} // getCorner()\n-\n-\t/**\n-\t * preferredLayoutSize\n-\t * @param parent TODO\n-\t * @returns Dimension\n-\t */\n-\tpublic Dimension preferredLayoutSize(Container parent) {\n-\t\treturn null; // TODO\n-\t} // preferredLayoutSize()\n-\n-\t/**\n-\t * minimumLayoutSize\n-\t * @param parent TODO\n-\t * @returns Dimension\n-\t */\n-\tpublic Dimension minimumLayoutSize(Container parent) {\n-\t\treturn null; // TODO\n-\t} // minimumLayoutSize()\n-\n-\t/**\n-\t * layoutContainer\n-\t * @param parent TODO\n-\t */\n-\tpublic void layoutContainer(Container parent) {\n-\t\t// TODO\n-\t} // layoutContainer()\n-\n-\t/**\n-\t * getViewportBorderBounds\n-\t * @param value0 TODO\n-\t * @returns Rectangle\n-\t */\n-\tpublic Rectangle getViewportBorderBounds(JScrollPane scrollPane) {\n-\t\treturn null; // TODO\n-\t} // getViewportBorderBounds()\n-\n-\n-} // ScrollPaneLayout\n+  public static class UIResource extends ScrollPaneLayout \n+    implements javax.swing.plaf.UIResource {\n+    public UIResource() {\n+    }\n+  }\n+\n+  JViewport viewport;\n+  JScrollBar verticalScrollBar;\n+  JScrollBar horizontalScrollBar;\n+  JViewport rowHeader;\n+  JViewport columnHeader;\n+  Component lowerLeft;\n+  Component lowerRight;\n+  Component upperLeft;\n+  Component upperRight;\n+  int verticalScrollBarPolicy;\n+  int horizontalScrollBarPolicy;\n+\n+  public ScrollPaneLayout() {\n+\t\t\n+  }\n+\n+  public void syncWithScrollPane(JScrollPane scrollPane) {\n+    viewport = scrollPane.getViewport();\n+    verticalScrollBar = scrollPane.getVerticalScrollBar();\n+    horizontalScrollBar = scrollPane.getHorizontalScrollBar();\n+    verticalScrollBarPolicy = scrollPane.getVerticalScrollBarPolicy();\n+    horizontalScrollBarPolicy = scrollPane.getHorizontalScrollBarPolicy();\n+    lowerLeft = scrollPane.getCorner(LOWER_LEFT_CORNER);\n+    lowerRight = scrollPane.getCorner(LOWER_RIGHT_CORNER);\n+    upperLeft = scrollPane.getCorner(UPPER_LEFT_CORNER);\n+    upperRight = scrollPane.getCorner(UPPER_RIGHT_CORNER);    \n+  }\n+\n+  protected Component addSingletonComponent(Component oldComponent,\n+                                            Component newComponent) {\n+    return null;\n+  }\n+\n+  public void addLayoutComponent(String key, Component component) \n+  {\n+    if (key == VIEWPORT)\n+      viewport = (JViewport) component;\n+    else if (key == VERTICAL_SCROLLBAR)\n+      verticalScrollBar = (JScrollBar) component;\n+    else if (key == HORIZONTAL_SCROLLBAR)\n+      horizontalScrollBar = (JScrollBar) component;\n+    else if (key == ROW_HEADER)\n+      rowHeader = (JViewport) component;\n+    else if (key == COLUMN_HEADER)\n+      columnHeader = (JViewport) component;\n+    else if (key == LOWER_RIGHT_CORNER)\n+      lowerRight = component;\n+    else if (key == UPPER_RIGHT_CORNER)\n+      upperRight = component;\n+    else if (key == LOWER_LEFT_CORNER)\n+      lowerLeft = component;\n+    else if (key == UPPER_LEFT_CORNER)\n+      upperLeft = component;\n+  }\n+\n+  public void removeLayoutComponent(Component component) {\n+    if (component == viewport)\n+      viewport = null;\n+    else if (component == verticalScrollBar)\n+      verticalScrollBar = null;\n+    else if (component == horizontalScrollBar)\n+      horizontalScrollBar = null;\n+    else if (component == rowHeader)\n+      rowHeader = null;\n+    else if (component == columnHeader)\n+      columnHeader = null;\n+    else if (component == lowerRight)\n+      lowerRight = null;\n+    else if (component == upperRight)\n+      upperRight = null;\n+    else if (component == lowerLeft)\n+      lowerLeft = null;\n+    else if (component == upperLeft)\n+      upperLeft = null;\n+  }\n+\n+  public int getVerticalScrollBarPolicy() {\n+    return verticalScrollBarPolicy;\n+  }\n+\n+  public void setVerticalScrollBarPolicy(int policy) {\n+    verticalScrollBarPolicy = policy;\n+  }\n+\n+  public int getHorizontalScrollBarPolicy() {\n+    return horizontalScrollBarPolicy;\n+  }\n+\n+  public void setHorizontalScrollBarPolicy(int policy) {\n+    horizontalScrollBarPolicy = policy;\n+  }\n+\n+  public JViewport getViewport() {\n+    return viewport;\n+  }\n+\n+  public JScrollBar getHorizontalScrollBar() {\n+    return horizontalScrollBar;\n+  }\n+\n+  public JScrollBar getVerticalScrollBar() {\n+    return verticalScrollBar;\n+  }\n+\n+  public JViewport getRowHeader() {\n+    return rowHeader;\n+  }\n+\n+  public JViewport getColumnHeader() {\n+    return columnHeader;\n+  }\n+\n+  public Component getCorner(String key) {\n+    if (key == LOWER_RIGHT_CORNER)\n+      return lowerRight;\n+    else if (key == UPPER_RIGHT_CORNER)\n+      return upperRight;\n+    else if (key == LOWER_LEFT_CORNER)\n+      return lowerLeft;\n+    else if (key == UPPER_LEFT_CORNER)\n+      return upperLeft;\n+    return null;\n+  }\n+\n+  public Dimension preferredLayoutSize(Container parent) \n+  {\n+    if (parent instanceof JScrollPane)\n+      {\n+        JScrollPane sc = (JScrollPane) parent;\n+        synchronized (sc.getTreeLock ())\n+          {\n+            Dimension insetsSize = new Dimension(0,0); \n+            Dimension viewportSize = new Dimension(0,0); \n+            Dimension viewportInsetsSize = new Dimension(0,0); \n+            Dimension columnHeaderSize = new Dimension(0,0); \n+            Dimension rowHeaderSize = new Dimension(0,0); \n+            Dimension verticalScrollBarSize = new Dimension(0,0); \n+            Dimension horizontalScrollBarSize = new Dimension(0,0); \n+\n+            Insets insets = sc.getInsets();\n+            Border viewportBorder = sc.getViewportBorder();\n+            Insets viewportInsets = null;\n+\n+            if (viewportBorder != null)\n+              viewportInsets = viewportBorder.getBorderInsets(parent);\n+\n+            if (insets != null)\n+              insetsSize.setSize(insets.left + insets.right,\n+                                 insets.top + insets.bottom);\n+\n+            if (viewport != null)\n+              viewportSize.setSize(viewport.getPreferredSize());\n+\n+            if (columnHeader != null)\n+              columnHeaderSize.setSize(columnHeader.getPreferredSize());\n+            \n+            if (rowHeader != null)\n+              rowHeaderSize.setSize(rowHeader.getPreferredSize());\n+\n+            if (verticalScrollBar != null)\n+              verticalScrollBarSize.setSize(verticalScrollBar.getPreferredSize());\n+\n+            if (horizontalScrollBar != null)\n+              horizontalScrollBarSize.setSize(horizontalScrollBar.getPreferredSize());\n+            \n+            return new Dimension(insetsSize.width \n+                                 + viewportSize.width\n+                                 + viewportInsetsSize.width\n+                                 + rowHeaderSize.width\n+                                 + verticalScrollBarSize.width,\n+                                 insetsSize.height\n+                                 + viewportSize.height\n+                                 + viewportInsetsSize.height\n+                                 + columnHeaderSize.height\n+                                 + horizontalScrollBarSize.height);\n+          }\n+      }\n+    else\n+      {\n+        return new Dimension(0,0);\n+      }\n+  }\n+\n+  public Dimension minimumLayoutSize(Container parent)\n+  {\n+    if (parent instanceof JScrollPane)\n+      {\n+        JScrollPane sc = (JScrollPane) parent;\n+        synchronized (sc.getTreeLock ())\n+          {\n+            Dimension insetsSize = new Dimension(0,0); \n+            Dimension viewportSize = new Dimension(0,0); \n+            Dimension viewportInsetsSize = new Dimension(0,0); \n+            Dimension columnHeaderSize = new Dimension(0,0); \n+            Dimension rowHeaderSize = new Dimension(0,0); \n+            Dimension verticalScrollBarSize = new Dimension(0,0); \n+            Dimension horizontalScrollBarSize = new Dimension(0,0); \n+\n+            Insets insets = sc.getInsets();\n+            Border viewportBorder = sc.getViewportBorder();\n+            Insets viewportInsets = null;\n+\n+            if (viewportBorder != null)\n+              viewportInsets = viewportBorder.getBorderInsets(parent);\n+\n+            if (insets != null)\n+              insetsSize.setSize(insets.left + insets.right,\n+                                 insets.top + insets.bottom);\n+\n+            if (viewport != null)\n+              viewportSize.setSize(viewport.getMinimumSize());\n+\n+            if (columnHeader != null)\n+              columnHeaderSize.setSize(columnHeader.getMinimumSize());\n+            \n+            if (rowHeader != null)\n+              rowHeaderSize.setSize(rowHeader.getMinimumSize());\n+\n+            if (verticalScrollBar != null\n+                && verticalScrollBarPolicy != VERTICAL_SCROLLBAR_NEVER)\n+              verticalScrollBarSize.setSize(verticalScrollBar.getMinimumSize());\n+\n+            if (horizontalScrollBar != null \n+                && horizontalScrollBarPolicy != HORIZONTAL_SCROLLBAR_NEVER)\n+              horizontalScrollBarSize.setSize(horizontalScrollBar.getMinimumSize());\n+            \n+            return new Dimension(insetsSize.width \n+                                 + viewportSize.width\n+                                 + viewportInsetsSize.width\n+                                 + rowHeaderSize.width\n+                                 + verticalScrollBarSize.width,\n+                                 insetsSize.height\n+                                 + viewportSize.height\n+                                 + viewportInsetsSize.height\n+                                 + columnHeaderSize.height\n+                                 + horizontalScrollBarSize.height);\n+          }\n+      }\n+    else\n+      {\n+        return new Dimension(0,0);\n+      }\n+  }\n+\n+  /**\n+   *\n+   *     +----+--------------------+----+ y1\n+   *     | c1 |   column header    | c2 |\n+   *     +----+--------------------+----+ y2\n+   *     | r  |                    | v  |\n+   *     | o  |                    |    |\n+   *     | w  |                    | s  |\n+   *     |    |                    | r  |\n+   *     | h  |                    | o  |\n+   *     | e  |      viewport      | l  |\n+   *     | a  |                    | l  |\n+   *     | d  |                    | b  |\n+   *     | e  |                    | a  |\n+   *     | r  |                    | r  |\n+   *     +----+--------------------+----+ y3\n+   *     | c3 |    h scrollbar     | c4 |\n+   *     +----+--------------------+----+ y4\n+   *    x1   x2                   x3   x4\n+   *   \n+   */\n+\n+  public void layoutContainer(Container parent) {\n+    if (parent instanceof JScrollPane)\n+      {\n+        JScrollPane sc = (JScrollPane) parent;\n+        synchronized (sc.getTreeLock ())\n+          {\n+            Rectangle scrollPaneBounds = sc.getBounds();\n+            Dimension viewportSize = new Dimension(0,0);\n+            Dimension viewSize = new Dimension(0,0);\n+            JViewport viewport = sc.getViewport();\n+\n+            int x1 = 0, x2 = 0, x3 = 0, x4 = 0;\n+            int y1 = 0, y2 = 0, y3 = 0, y4 = 0;\n+\n+            x1 = scrollPaneBounds.x;\n+            y1 = scrollPaneBounds.y;\n+            x4 = scrollPaneBounds.x + scrollPaneBounds.width;\n+            y4 = scrollPaneBounds.y + scrollPaneBounds.height;\n+            \n+            if (columnHeader != null)\n+              y2 = columnHeader.getPreferredSize().height;\n+            else\n+              y2 = y1;\n+\n+            if (rowHeader != null)\n+              x2 = rowHeader.getPreferredSize().width;\n+            else\n+              x2 = x1;\n+\n+            int vsbPolicy = sc.getVerticalScrollBarPolicy();\n+            int hsbPolicy = sc.getHorizontalScrollBarPolicy();\n+\n+            boolean showVsb = \n+              (verticalScrollBar != null)\n+              && ((vsbPolicy == VERTICAL_SCROLLBAR_ALWAYS)\n+                  || (vsbPolicy == VERTICAL_SCROLLBAR_AS_NEEDED \n+                      && viewSize.height > viewportSize.height));\n+\n+            boolean showHsb = \n+              (horizontalScrollBar != null)\n+              && ((hsbPolicy == HORIZONTAL_SCROLLBAR_ALWAYS)\n+                  || (hsbPolicy == HORIZONTAL_SCROLLBAR_AS_NEEDED \n+                      && viewSize.width > viewportSize.width));\n+            \n+            if (showVsb)\n+              x3 = x4 - verticalScrollBar.getPreferredSize().width;\n+            else\n+              x3 = x4;\n+\n+            if (showHsb)\n+              y3 = y4 - horizontalScrollBar.getPreferredSize().height;\n+            else\n+              y3 = y4;\n+\n+            // now set the layout\n+\n+            if (viewport != null)\n+              viewport.setBounds(new Rectangle(x2, y2, x3-x2, y3-y2));\n+\n+            if (columnHeader != null)\n+              columnHeader.setBounds(new Rectangle(x2, y1, x3-x2, y2-y1));\n+\n+            if (rowHeader != null)\n+              rowHeader.setBounds(new Rectangle(x1, y2, x2-x1, y3-y2));\n+\n+            if (showVsb)\n+              verticalScrollBar.setBounds(new Rectangle(x3, y2, x4-x3, y3-y2));\n+\n+            if (showHsb)\n+              horizontalScrollBar.setBounds(new Rectangle(x2, y3, x3-x2, y4-y3));\n+\n+            if (upperLeft != null)\n+              upperLeft.setBounds(new Rectangle(x1, y1, x2-x1, y2-y1));\n+\n+            if (upperRight != null)\n+              upperRight.setBounds(new Rectangle(x3, y1, x4-x3, y2-y1));\n+\n+            if (lowerLeft != null)\n+              lowerLeft.setBounds(new Rectangle(x1, y3, x2-x1, y4-y3));\n+\n+            if (lowerRight != null)\n+              lowerRight.setBounds(new Rectangle(x3, y3, x4-x3, y4-y3));\n+\n+          }\n+      }\n+  }\n+\n+  public Rectangle getViewportBorderBounds(JScrollPane scrollPane) {\n+    return null;\n+  }\n+\n+\n+}"}, {"sha": "36fe017c1ca6d0c6db5e11e6f3499781a8cd35d4", "filename": "libjava/javax/swing/SwingUtilities.java", "status": "modified", "additions": 61, "deletions": 3, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FSwingUtilities.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FSwingUtilities.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FSwingUtilities.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -48,6 +48,7 @@\n import java.awt.Insets;\n import java.awt.Point;\n import java.awt.Rectangle;\n+import java.awt.Shape;\n import java.awt.Toolkit;\n import java.awt.Window;\n import java.awt.event.KeyEvent;\n@@ -667,10 +668,19 @@ public static String layoutCompoundLabel(FontMetrics fm,\n     else\n       {\n         iconR.width = icon.getIconWidth();\n-        iconR.height = icon.getIconWidth();\n+        iconR.height = icon.getIconHeight();\n+      }\n+    if (text == null)\n+      {\n+        textIconGap = 0;\n+\ttextR.width = 0;\n+\ttextR.height = 0;\n+      }\n+    else\n+      {\n+        textR.width = fm.stringWidth(text);\n+        textR.height = fm.getHeight(); \n       }\n-    textR.width = fm.stringWidth(text);\n-    textR.height = fm.getHeight(); \n \n     // Work out the position of text and icon, assuming the top-left coord\n     // starts at (0,0). We will fix that up momentarily, after these\n@@ -776,5 +786,53 @@ public static boolean isEventDispatchThread()\n   {\n     return java.awt.EventQueue.isDispatchThread();\n   }\n+  \n+  /**\n+   * This method paints the given component at the given position and size.\n+   * The component will be reparented to the container given.\n+   * \n+   * @param g The Graphics object to draw with.\n+   * @param c The Component to draw\n+   * @param p The Container to reparent to.\n+   * @param x The x coordinate to draw at.\n+   * @param y The y coordinate to draw at.\n+   * @param w The width of the drawing area.\n+   * @param h The height of the drawing area.\n+   */\n+  public static void paintComponent(Graphics g, Component c, Container p, \n+                                    int x, int y, int w, int h)\n+  {       \n+    Container parent = c.getParent();\n+    if (parent != null)\n+      parent.remove(c);\n+    if (p != null)\n+      p.add(c);\n+    \n+    Shape savedClip = g.getClip();\n+    \n+    g.setClip(x, y, w, h);\n+    g.translate(x, y);\n+\n+    c.paint(g);\n+    \n+    g.translate(-x, -y);\n+    g.setClip(savedClip);\n+  }\n+\n+  /**\n+   * This method paints the given component in the given rectangle.\n+   * The component will be reparented to the container given.\n+   * \n+   * @param g The Graphics object to draw with.\n+   * @param c The Component to draw\n+   * @param p The Container to reparent to.\n+   * @param r The rectangle that describes the drawing area.\n+   */  \n+  public static void paintComponent(Graphics g, Component c, \n+                                    Container p, Rectangle r)\n+  {\n+    paintComponent(g, c, p, r.x, r.y, r.width, r.height);\n+  }\n+  \n \n }"}, {"sha": "4c774d59f4045b68c0d44baf232c47ec7baceabd", "filename": "libjava/javax/swing/ViewportLayout.java", "status": "modified", "additions": 17, "deletions": 55, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FViewportLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2FViewportLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FViewportLayout.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -52,64 +52,26 @@ public class ViewportLayout implements LayoutManager, Serializable\n {\n   static final long serialVersionUID = -788225906076097229L;\n \n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor ViewportLayout\n-\t */\n \tpublic ViewportLayout() {\n-\t\t// TODO\n-\t} // ViewportLayout()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * addLayoutComponent\n-\t * @param name TODO\n-\t * @param c TODO\n-\t */\n+\t}\n \tpublic void addLayoutComponent(String name, Component c) {\n-\t\t// TODO\n-\t} // addLayoutComponent()\n-\n-\t/**\n-\t * removeLayoutComponent\n-\t * @param c TODO\n-\t */\n+          // ignore\n+\t}\n \tpublic void removeLayoutComponent(Component c) {\n-\t\t// TODO\n-\t} // removeLayoutComponent()\n-\n-\t/**\n-\t * preferredLayoutSize\n-\t * @param parent TODO\n-\t * @returns Dimension\n-\t */\n+          // ignore\n+\t}\n \tpublic Dimension preferredLayoutSize(Container parent) {\n-\t\treturn null; // TODO\n-\t} // preferredLayoutSize()\n-\n-\t/**\n-\t * minimumLayoutSize\n-\t * @param parent TODO\n-\t * @returns Dimension\n-\t */\n+          return null;\n+\t}\n \tpublic Dimension minimumLayoutSize(Container parent) {\n-\t\treturn null; // TODO\n-\t} // minimumLayoutSize()\n-\n-\t/**\n-\t * layoutContainer\n-\t * @param parent TODO\n-\t */\n+          return null;\n+\t}\n \tpublic void layoutContainer(Container parent) {\n-\t\t// TODO\n-\t} // layoutContainer()\n-\n-\n-} // ViewportLayout\n+          if (parent.countComponents() == 1)\n+            {\n+              // This should usually be true, but if it's not it is\n+              // probably nicer if we do not panic.\n+              Component c = parent.getComponent(0);\n+            }\n+\t}\n+}"}, {"sha": "98b4c8b3c532b83f1b9e0b8374fe05bf729fab74", "filename": "libjava/javax/swing/plaf/basic/BasicButtonListener.java", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonListener.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonListener.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonListener.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -87,15 +87,12 @@ public void stateChanged(ChangeEvent e)\n   }\n   public void mouseMoved(MouseEvent e)\n   {\n-    System.err.println(\"button got mouse move\");\n   }\n   public void mouseDragged(MouseEvent e)\n   {\n-    System.err.println(\"button got mouse drag\");\n   }\n   public void mouseClicked(MouseEvent e)\n   {\n-    System.err.println(\"button got mouse click\");\n   }\n \n   /**"}, {"sha": "5dbd17ecfa8147b0dd2cc1da2f5acce5c10f179a", "filename": "libjava/javax/swing/plaf/basic/BasicButtonUI.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -250,7 +250,8 @@ public void paint(Graphics g, JComponent c)\n       paintButtonNormal(g, br, c);\n \t\n     paintIcon(g, c, ir);\n-    paintText(g, c, tr, b.getText());\n+    if (text != null)\n+      paintText(g, c, tr, b.getText());\n     paintFocus(g, c, vr, tr, ir);\n   }\n "}, {"sha": "1f2f7444db11a54a33875e314aa53dfda1b5fae2", "filename": "libjava/javax/swing/plaf/basic/BasicGraphicsUtils.java", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicGraphicsUtils.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicGraphicsUtils.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicGraphicsUtils.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -597,10 +597,7 @@ public static Dimension getPreferredButtonSize(AbstractButton b,\n     Insets insets = b.getInsets();\n     Insets margin = b.getMargin();\n     \n-    /* For determining the ideal size, do not assume a size restriction. */\n-    viewRect = new Rectangle(0, 0,\n-                             /* width */ Integer.MAX_VALUE,\n-                             /* height */ Integer.MAX_VALUE);\n+    viewRect = new Rectangle();\n \n      /* java.awt.Toolkit.getFontMetrics is deprecated. However, it\n      * seems not obvious how to get to the correct FontMetrics object\n@@ -614,21 +611,21 @@ public static Dimension getPreferredButtonSize(AbstractButton b,\n       b.getToolkit().getFontMetrics(b.getFont()), // see comment above\n       b.getText(),\n       b.getIcon(),\n-      SwingUtilities.TOP,    // important:\n-      SwingUtilities.LEFT,   // large vrect, stick to the top left\n+      b.getVerticalAlignment(), \n+      b.getHorizontalAlignment(),\n       b.getVerticalTextPosition(),\n       b.getHorizontalTextPosition(),\n       viewRect, iconRect, textRect,\n       textIconGap);\n \n-\n     /*  +------------------------+       +------------------------+\n      *  |                        |       |                        |\n      *  | ICON                   |       | CONTENTCONTENTCONTENT  |\n      *  |          TEXTTEXTTEXT  |  -->  | CONTENTCONTENTCONTENT  |\n      *  |          TEXTTEXTTEXT  |       | CONTENTCONTENTCONTENT  |\n      *  +------------------------+       +------------------------+\n      */\n+\n     contentRect = textRect.union(iconRect);\n \n     return new Dimension(insets.left + margin.left"}, {"sha": "219c6fab02eff0ab44baa92297ac21483a9ca13a", "filename": "libjava/javax/swing/plaf/basic/BasicLabelUI.java", "status": "modified", "additions": 360, "deletions": 133, "changes": 493, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLabelUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLabelUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLabelUI.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -1,5 +1,5 @@\n /* BasicLabelUI.java\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,7 +35,6 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing.plaf.basic;\n \n import java.awt.Color;\n@@ -47,156 +46,384 @@\n import java.awt.Rectangle;\n import java.beans.PropertyChangeEvent;\n import java.beans.PropertyChangeListener;\n+import javax.swing.Icon;\n import javax.swing.JComponent;\n import javax.swing.JLabel;\n+import javax.swing.SwingConstants;\n import javax.swing.SwingUtilities;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n import javax.swing.plaf.ComponentUI;\n import javax.swing.plaf.LabelUI;\n \n-public class BasicLabelUI extends LabelUI\n-  implements PropertyChangeListener\n+\n+/**\n+ * This is the Basic Look and Feel class for the JLabel.  One BasicLabelUI\n+ * object is used to paint all JLabels that utilize the Basic L&F.\n+ */\n+public class BasicLabelUI extends LabelUI implements PropertyChangeListener\n {\n-    int gap = 3;\n-    Color foreground;\n+  /** The labelUI that is shared by all labels. */\n+  protected static BasicLabelUI labelUI;\n \n-    \n-    public static ComponentUI createUI(final JComponent c)  {\n-\treturn new BasicLabelUI();\n-    }\n-    \n-    \n-    public void installUI(final JComponent c)  {\n-\tsuper.installUI(c);\n-\t\n-\tforeground = new Color(0,0,250);\n-    }\n-    \n+  /**\n+   * Creates a new BasicLabelUI object.\n+   */\n+  public BasicLabelUI()\n+  {\n+    super();\n+  }\n \n-    public Dimension getPreferredSize(JComponent c) \n-    {\n-\tJLabel b = (JLabel)c;\n-        /*\n-          We cannot use this method because it is not part of the\n-          official Swing API.\n-\n-\tDimension d = BasicGraphicsUtils.getPreferredSize(b, \n-\t\t\t\t\t\t\t  gap,\n-\t\t\t\t\t\t\t  b.getText(),\n-\t\t\t\t\t\t\t  b.getIcon(),\n-\t\t\t\t\t\t\t  b.getVerticalAlignment(),\n-\t\t\t\t\t\t\t  b.getHorizontalAlignment(),\n-\t\t\t\t\t\t\t  b.getHorizontalTextPosition(),\n-\t\t\t\t\t\t\t  b.getVerticalTextPosition());\n-\tSystem.out.println(\"JLABEL->^^^^^^^^^^^^^^^^^^^^^^   BASIC-PREF=\"+d + \",T=\"+b.getText());\n-        */\n-        return new Dimension(100, 30);\n-    }\n+  /**\n+   * Creates and returns a UI for the label. Since one UI is shared by  all\n+   * labels, this means creating only if necessary and returning the  shared\n+   * UI.\n+   *\n+   * @param c The {@link JComponent} that a UI is being created for.\n+   *\n+   * @return A label UI for the Basic L&F.\n+   */\n+  public static ComponentUI createUI(JComponent c)\n+  {\n+    if (labelUI == null)\n+      labelUI = new BasicLabelUI();\n+    return labelUI;\n+  }\n+\n+  /**\n+   * Returns the preferred size of this component as calculated by the\n+   * {@link layoutCL} method.\n+   *\n+   * @param c This {@link JComponent} to get a preferred size for.\n+   *\n+   * @return The preferred size.\n+   */\n+  public Dimension getPreferredSize(JComponent c) \n+  {\n+    JLabel lab = (JLabel)c;\n+    Rectangle vr = new Rectangle();\n+    Rectangle ir = new Rectangle();\n+    Rectangle tr = new Rectangle();\n+    Insets insets = lab.getInsets();      \n+    FontMetrics fm = lab.getToolkit().getFontMetrics(lab.getFont());\n+    layoutCL(lab, fm, lab.getText(), lab.getIcon(), vr, ir, tr);\n+    Rectangle cr = tr.union(ir);\n+    return new Dimension(insets.left + cr.width + insets.right,\n+                         insets.top + cr.height + insets.bottom);\n     \n+  }  \n \n-    public void paint(Graphics g, JComponent c)\n-    {      \n-\tJLabel b = (JLabel) c;\n-\n-\tRectangle tr = new Rectangle();\n-\tRectangle ir = new Rectangle();\n-\tRectangle vr = new Rectangle();\n-\n-        Font f = c.getFont();\n-\n-        g.setFont(f);\n-\n-        FontMetrics fm = g.getFontMetrics(f);\n-\n-        Insets i = c.getInsets();\n-\n-\tRectangle bound = c.getBounds();\n-\t\n-\tSystem.out.println(\"BOUND=\" + bound + \", insets = \" + i + \", \" + b.getText());\n-\t\n-\tif (bound == null)\n-\t    {\n-\t\tvr.x      = i.left;\n-\t\tvr.y      = i.top;\n-\t\tvr.width  = b.getWidth() - (i.right  + i.left);\n-\t\tvr.height = b.getHeight() - (i.bottom + i.top);\n-\t    }\n-\telse\n-\t    {\n-\t\tvr.x      = bound.x + i.left;\n-\t\tvr.y      = bound.y + i.top;\n-\t\tvr.width  = bound.width - (i.right  + i.left);\n-\t\tvr.height = bound.height - (i.bottom + i.top);\n-\t    }\n-\n-\tSystem.out.println(\"             VIEW-RECT-JLABEL=\"+vr+\", insets=\"+i+\", FONTM=\"+fm);\n-\n-\tString text = SwingUtilities.layoutCompoundLabel(c,\n-\t\t\t\t\t\t\t fm, \n-\t\t\t\t\t\t\t b.getText(),\n-\t\t\t\t\t\t\t b.getIcon(),\n-\t\t\t\t\t\t\t b.getVerticalAlignment(), \n-\t\t\t\t\t\t\t b.getHorizontalAlignment(),\n-\t\t\t\t\t\t\t b.getVerticalTextPosition(), \n-\t\t\t\t\t\t\t b.getHorizontalTextPosition(),\n-\t\t\t\t\t\t\t vr,\n-\t\t\t\t\t\t\t ir,\n-\t\t\t\t\t\t\t tr,\n-\t\t\t\t\t\t\t gap);\n-\n-\tpaintIcon(g, c, ir);\n-\tpaintText(g, c, tr, b.getText());\n-\tpaintFocus(g, c, vr, tr, ir);\n-    }\n+  /**\n+   * This method returns the minimum size of the {@link JComponent} given. If\n+   * this method returns null, then it is up to the Layout Manager to give\n+   * this component a minimum size.\n+   *\n+   * @param c The {@link JComponent} to get a minimum size for.\n+   *\n+   * @return The minimum size.\n+   */\n+  public Dimension getMinimumSize(JComponent c)\n+  {\n+    return getPreferredSize(c);\n+  }\n+\n+  /**\n+   * This method returns the maximum size of the {@link JComponent} given. If\n+   * this method returns null, then it is up to the Layout Manager to give\n+   * this component a maximum size.\n+   *\n+   * @param c The {@link JComponent} to get a maximum size for.\n+   *\n+   * @return The maximum size.\n+   */\n+  public Dimension getMaximumSize(JComponent c)\n+  {\n+    return getPreferredSize(c);\n+  }\n \n+  /**\n+   * The method that paints the label according to its current state.\n+   *\n+   * @param g The {@link Graphics} object to paint with.\n+   * @param c The {@link JComponent} to paint.\n+   */\n+  public void paint(Graphics g, JComponent c)\n+  {\n+    JLabel b = (JLabel) c;\n \n-    protected void paintFocus(Graphics g, \n-\t\t\t      JComponent c,\n-\t\t\t      Rectangle vr,\n-\t\t\t      Rectangle tr,\n-\t\t\t      Rectangle ir)\n-    {\n-    }\n+    Font saved_font = g.getFont();\n \n-    protected void paintIcon(Graphics g, \n-\t\t\t     JComponent c, \n-\t\t\t     Rectangle iconRect)\n-    {\n-\tJLabel b = (JLabel) c;\n-\tif (b.getIcon() != null)\n-\t    {\n-\t\tint x = iconRect.x;\n-\t\tint y = iconRect.y;\n-\n-\t\tSystem.out.println(\"WE HAVE AN ICON: \" + b.getIcon());\n- \n-\t\tb.getIcon().paintIcon(c, g, x, y);\n-\t    }\n-\telse\n-\t    {\n-\t\t//System.out.println(\"NO ICON FOR BUTTON:\" + b.text);\n-\t    }\n-    }\n+    Rectangle tr = new Rectangle();\n+    Rectangle ir = new Rectangle();\n+    Rectangle vr = new Rectangle();\n+\n+    Font f = c.getFont();\n+\n+    g.setFont(f);\n+    FontMetrics fm = g.getFontMetrics(f);\n+\n+    vr = SwingUtilities.calculateInnerArea(c, vr);\n+\n+    if (vr.width < 0)\n+      vr.width = 0;\n+    if (vr.height < 0)\n+      vr.height = 0;\n+\n+    Icon icon = (b.isEnabled()) ? b.getIcon() : b.getDisabledIcon();\n \n+    String text = layoutCL(b, fm, b.getText(), icon, vr, ir, tr);\n     \n-    protected void paintText(Graphics g,\n-\t\t\t     JComponent c,\n-\t\t\t     Rectangle textRect,\n-\t\t\t     String text) \n+    if (b.isOpaque())\n     {\n-\t//        AbstractLabel b = (AbstractLabel) c;\n-\t\n-\tSystem.out.println(\"JLabel: drawing string: \" + text + \", at:\" + textRect);\n-\t\n-\tg.setColor(foreground);\n-\t//g.setBackColor(new Color(190,190,190));\n-\n-\tg.drawLine(0,0,100,100);\n-\t\n-\tBasicGraphicsUtils.drawString(g, text, 0, 0 /*textRect.x*/, 0 /*textRect.y*/);\n+      g.setColor(b.getBackground());\n+      g.fillRect(vr.x, vr.y, vr.width, vr.height);\n     }\n \n-  public void propertyChange (PropertyChangeEvent event)\n+    if (icon != null)\n+      icon.paintIcon(b, g, ir.x, ir.y);\n+    if (b.isEnabled())\n+      paintEnabledText(b, g, text, tr.x, tr.y + fm.getAscent());\n+    else\n+      paintDisabledText(b, g, text, tr.x, tr.y + fm.getAscent());\n+    g.setFont(saved_font);\n+  }\n+\n+  /**\n+   * This method is simply calls SwingUtilities's layoutCompoundLabel.\n+   *\n+   * @param label The label to lay out.\n+   * @param fontMetrics The FontMetrics for the font used.\n+   * @param text The text to paint.\n+   * @param icon The icon to draw.\n+   * @param viewR The entire viewable rectangle.\n+   * @param iconR The icon bounds rectangle.\n+   * @param textR The text bounds rectangle.\n+   *\n+   * @return A possibly clipped version of the text.\n+   */\n+  protected String layoutCL(JLabel label, FontMetrics fontMetrics,\n+                            String text, Icon icon, Rectangle viewR,\n+                            Rectangle iconR, Rectangle textR)\n+  {\n+    return SwingUtilities.layoutCompoundLabel(label, fontMetrics, text, icon,\n+                                              label.getVerticalAlignment(),\n+                                              label.getHorizontalAlignment(),\n+                                              label.getVerticalTextPosition(),\n+                                              label.getHorizontalTextPosition(),\n+                                              viewR, iconR, textR,\n+                                              label.getIconTextGap());\n+  }\n+\n+  /**\n+   * Paints the text if the label is disabled. By default, this paints the\n+   * clipped text returned by layoutCompoundLabel using the\n+   * background.brighter() color. It also paints the same text using the\n+   * background.darker() color one pixel to the right and one pixel down.\n+   *\n+   * @param l The {@link JLabel} being painted.\n+   * @param g The {@link Graphics} object to paint with.\n+   * @param s The String to paint.\n+   * @param textX The x coordinate of the start of the baseline.\n+   * @param textY The y coordinate of the start of the baseline.\n+   */\n+  protected void paintDisabledText(JLabel l, Graphics g, String s, int textX,\n+                                   int textY)\n+  {\n+    Color saved_color = g.getColor();\n+\n+    g.setColor(l.getBackground().brighter());\n+\n+    int mnemIndex = l.getDisplayedMnemonicIndex();\n+\n+    if (mnemIndex != -1)\n+      BasicGraphicsUtils.drawStringUnderlineCharAt(g, s, mnemIndex, textX,\n+                                                   textY);\n+    else\n+      g.drawString(s, textX, textY);\n+\n+    g.setColor(l.getBackground().darker());\n+    if (mnemIndex != -1)\n+      BasicGraphicsUtils.drawStringUnderlineCharAt(g, s, mnemIndex, textX + 1,\n+                                                   textY + 1);\n+    else\n+      g.drawString(s, textX + 1, textY + 1);\n+\n+    g.setColor(saved_color);\n+  }\n+\n+  /**\n+   * Paints the text if the label is enabled. The text is painted using the\n+   * foreground color.\n+   *\n+   * @param l The {@link JLabel} being painted.\n+   * @param g The {@link Graphics} object to paint with.\n+   * @param s The String to paint.\n+   * @param textX The x coordinate of the start of the baseline.\n+   * @param textY The y coordinate of the start of the baseline.\n+   */\n+  protected void paintEnabledText(JLabel l, Graphics g, String s, int textX,\n+                                  int textY)\n+  {\n+    Color saved_color = g.getColor();\n+    g.setColor(l.getForeground());\n+\n+    int mnemIndex = l.getDisplayedMnemonicIndex();\n+\n+    if (mnemIndex != -1)\n+      BasicGraphicsUtils.drawStringUnderlineCharAt(g, s, mnemIndex, textX,\n+                                                   textY);\n+    else\n+      g.drawString(s, textX, textY);\n+\n+    g.setColor(saved_color);\n+  }\n+\n+  /**\n+   * This method installs the UI for the given {@link JComponent}.  This\n+   * method will install the component, defaults, listeners,  and keyboard\n+   * actions.\n+   *\n+   * @param c The {@link JComponent} that this UI is being installed on.\n+   */\n+  public void installUI(JComponent c)\n+  {\n+    super.installUI(c);\n+    if (c instanceof JLabel)\n+      {\n+\tJLabel l = (JLabel) c;\n+\n+\tinstallComponents(l);\n+\tinstallDefaults(l);\n+\tinstallListeners(l);\n+\tinstallKeyboardActions(l);\n+      }\n+  }\n+\n+  /**\n+   * This method uninstalls the UI for the given {@link JComponent}. This\n+   * method will uninstall the component, defaults, listeners,  and keyboard\n+   * actions.\n+   *\n+   * @param c The {@link JComponent} that this UI is being installed on.\n+   */\n+  public void uninstallUI(JComponent c)\n+  {\n+    super.uninstallUI(c);\n+    if (c instanceof JLabel)\n+      {\n+\tJLabel l = (JLabel) c;\n+\n+\tuninstallKeyboardActions(l);\n+\tuninstallListeners(l);\n+\tuninstallDefaults(l);\n+\tuninstallComponents(l);\n+      }\n+  }\n+\n+  /**\n+   * This method installs the components for this {@link JLabel}.\n+   *\n+   * @param c The {@link JLabel} to install components for.\n+   */\n+  protected void installComponents(JLabel c)\n+  {\n+    //FIXME: fix javadoc + implement.\n+  }\n+\n+  /**\n+   * This method uninstalls the components for this {@link JLabel}.\n+   *\n+   * @param c The {@link JLabel} to uninstall components for.\n+   */\n+  protected void uninstallComponents(JLabel c)\n+  {\n+    //FIXME: fix javadoc + implement.\n+  }\n+\n+  /**\n+   * This method installs the defaults that are defined in  the Basic look and\n+   * feel for this {@link JLabel}.\n+   *\n+   * @param c The {@link JLabel} to install defaults for.\n+   */\n+  protected void installDefaults(JLabel c)\n+  {\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+\n+    c.setForeground(defaults.getColor(\"Label.foreground\"));\n+    c.setBackground(defaults.getColor(\"Label.background\"));\n+    c.setFont(defaults.getFont(\"Label.font\"));\n+    c.setBorder(defaults.getBorder(\"Label.border\"));\n+    //XXX: There are properties we don't use called disabledForeground\n+    //and disabledShadow.\n+  }\n+\n+  /**\n+   * This method uninstalls the defaults that are defined in the Basic look\n+   * and feel for this {@link JLabel}.\n+   *\n+   * @param c The {@link JLabel} to uninstall defaults for.\n+   */\n+  protected void uninstallDefaults(JLabel c)\n+  {\n+    c.setForeground(null);\n+    c.setBackground(null);\n+    c.setFont(null);\n+    c.setBorder(null);\n+  }\n+\n+  /**\n+   * This method installs the keyboard actions for the given {@link JLabel}.\n+   *\n+   * @param l The {@link JLabel} to install keyboard actions for.\n+   */\n+  protected void installKeyboardActions(JLabel l)\n+  {\n+    //FIXME: implement.\n+  }\n+\n+  /**\n+   * This method uninstalls the keyboard actions for the given {@link JLabel}.\n+   *\n+   * @param l The {@link JLabel} to uninstall keyboard actions for.\n+   */\n+  protected void uninstallKeyboardActions(JLabel l)\n+  {\n+    //FIXME: implement.\n+  }\n+\n+  /**\n+   * This method installs the listeners for the  given {@link JLabel}. The UI\n+   * delegate only listens to  the label.\n+   *\n+   * @param c The {@link JLabel} to install listeners for.\n+   */\n+  protected void installListeners(JLabel c)\n+  {\n+    c.addPropertyChangeListener(this);\n+  }\n+\n+  /**\n+   * This method uninstalls the listeners for the given {@link JLabel}. The UI\n+   * delegate only listens to the label.\n+   *\n+   * @param c The {@link JLabel} to uninstall listeners for.\n+   */\n+  protected void uninstallListeners(JLabel c)\n+  {\n+    c.removePropertyChangeListener(this);\n+  }\n+\n+  /**\n+   * This method is called whenever any JLabel's that use this UI has one of\n+   * their properties change.\n+   *\n+   * @param e The {@link PropertyChangeEvent} that describes the change.\n+   */\n+  public void propertyChange(PropertyChangeEvent e)\n   {\n-    throw new Error (\"Not implemented\");\n+    JLabel c = (JLabel) e.getSource();\n+    c.revalidate();\n+    c.repaint();\n   }\n }"}, {"sha": "7a1f5a4a8203689aeb9b95c5bf5cfee6935f2448", "filename": "libjava/javax/swing/plaf/basic/BasicListUI.java", "status": "modified", "additions": 616, "deletions": 94, "changes": 710, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicListUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicListUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicListUI.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -35,7 +35,6 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package javax.swing.plaf.basic;\n \n import java.awt.Color;\n@@ -44,141 +43,664 @@\n import java.awt.Graphics;\n import java.awt.Point;\n import java.awt.Rectangle;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import java.awt.event.MouseEvent;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n import javax.swing.JComponent;\n import javax.swing.JList;\n import javax.swing.ListCellRenderer;\n+import javax.swing.ListModel;\n+import javax.swing.ListSelectionModel;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.event.ListDataEvent;\n+import javax.swing.event.ListDataListener;\n+import javax.swing.event.ListSelectionEvent;\n+import javax.swing.event.ListSelectionListener;\n+import javax.swing.event.MouseInputListener;\n import javax.swing.plaf.ComponentUI;\n import javax.swing.plaf.ListUI;\n \n+\n+/**\n+ * The Basic Look and Feel UI delegate for the \n+ * JList.\n+ */\n public class BasicListUI extends ListUI\n {\n-    int gap_between_cells;\n-    Color textColor, disabledTextColor, pressedBackgroundColor, normalBackgroundColor;\n-    \n+  /**\n+   * A helper class which listens for {@link FocusEvents}\n+   * from the JList.\n+   */\n+  class FocusHandler implements FocusListener\n+  {\n+    /**\n+     * Called when the JList acquires focus.\n+     *\n+     * @param e The FocusEvent representing focus acquisition\n+     */\n+    public void focusGained(FocusEvent e)\n+    {\n+      repaintCellFocus();\n+    }\n \n-    public static ComponentUI createUI(final JComponent c) \n+    /**\n+     * Called when the JList loses focus.\n+     *\n+     * @param e The FocusEvent representing focus loss\n+     */\n+    public void focusLost(FocusEvent e)\n     {\n-\treturn new BasicButtonUI();\n+      repaintCellFocus();\n     }\n \n-    \n-    public void installUI(final JComponent c) \n+    /**\n+     * Helper method to repaint the focused cell's \n+     * lost or acquired focus state.\n+     */\n+    void repaintCellFocus()\n     {\n-\tsuper.installUI(c);\n+    }\n+  }\n \n-\ttextColor                = new Color(0,0,0);\n-\tdisabledTextColor        = new Color(130, 130, 130);\n-\tpressedBackgroundColor   = new Color(150,150,150);\n-\tnormalBackgroundColor    = new Color(192,192,192);\n+  /**\n+   * A helper class which listens for {@link ListDataEvent}s generated by\n+   * the {@link JList}'s {@link ListModel}.\n+   *\n+   * @see javax.swing.JList#model\n+   */\n+  class ListDataHandler implements ListDataListener\n+  {\n+    /**\n+     * Called when a general change has happened in the model which cannot\n+     * be represented in terms of a simple addition or deletion.\n+     *\n+     * @param e The event representing the change\n+     */\n+    public void contentsChanged(ListDataEvent e)\n+    {\n+      // System.err.println(this + \".contentsChanged(\" + e + \")\");\n+      BasicListUI.this.damageLayout();\n     }\n \n-    public Dimension getPreferredSize(JComponent c) \n+    /**\n+     * Called when an interval of objects has been added to the model.\n+     *\n+     * @param e The event representing the addition\n+     */\n+    public void intervalAdded(ListDataEvent e)\n     {\n-\tJList l = (JList) c;\n-\n-\tSystem.out.println(\"XXXXXXXXXXXXXXXxx   getPreferredSize------------> \" + l);\n-\n-\t\n-\tint rows = l.getVisibleRowCount();\n-\n-\tListCellRenderer render = l.getCellRenderer();\n-\t\n-\tint width  = 200;\n-\tint height = rows * 16; \n-\t\n-\tif (l.getModel().getSize() == 0)\n-\t    {\n-\t\treturn new Dimension(width, height);\n-\t    }\n-\n-\tSystem.out.println(\"BASIC_LIST_UI ====-> \" + l.getModel().getElementAt(0));\n-\n-\tComponent elt = render.getListCellRendererComponent(l,\n-\t\t\t\t\t\t\t    l.getModel().getElementAt(0),\n-\t\t\t\t\t\t\t    0,            \n-\t\t\t\t\t\t\t    false,\n-\t\t\t\t\t\t\t    false);\n-\tDimension a = elt.getPreferredSize();\n-\tif (a == null)\n-\t    {\n-\t\treturn new Dimension(width, height);\n-\t    }\n-\n-\treturn new Dimension(a.width,\n-\t\t\t     a.height * rows);\n+      // System.err.println(this + \".intervalAdded(\" + e + \")\");\n+      BasicListUI.this.damageLayout();\n     }\n \n-    public void paintBackground(Graphics g,\n-\t\t\t JComponent c)\n+    /**\n+     * Called when an inteval of objects has been removed from the model.\n+     *\n+     * @param e The event representing the removal\n+     */\n+    public void intervalRemoved(ListDataEvent e)\n     {\n-\tDimension size = getPreferredSize(c);\n+      // System.err.println(this + \".intervalRemoved(\" + e + \")\");\n+      BasicListUI.this.damageLayout();\n+    }\n+  }\n \n-\tg.setColor(normalBackgroundColor);\n-\tg.fillRect(0,0,size.width, size.height);  \n+  /**\n+   * A helper class which listens for {@link ListSelectionEvent}s\n+   * from the {@link JList}'s {@link ListSelectionModel}.\n+   */\n+  class ListSelectionHandler implements ListSelectionListener\n+  {\n+    /**\n+     * Called when the list selection changes.  \n+     *\n+     * @param e The event representing the change\n+     */\n+    public void valueChanged(ListSelectionEvent e)\n+    {\n+      //       System.err.println(this + \".valueChanged(\" + e + \")\");\n     }\n+  }\n \n-    public void paint(Graphics g, \n-\t\t      JComponent c)\n-    {      \n-\tJList l = (JList) c;\n+  /**\n+   * A helper class which listens for {@link MouseEvent}s \n+   * from the {@link JList}.\n+   */\n+  class MouseInputHandler implements MouseInputListener\n+  {\n+    /**\n+     * Called when a mouse button press/release cycle completes\n+     * on the {@link JList}\n+     *\n+     * @param event The event representing the mouse click\n+     */\n+    public void mouseClicked(MouseEvent event)\n+    {\n+    }\n \n-\tint rows = l.getVisibleRowCount();\n+    /**\n+     * Called when a mouse button is pressed down on the\n+     * {@link JList}.\n+     *\n+     * @param event The event representing the mouse press\n+     */\n+    public void mousePressed(MouseEvent event)\n+    {\n+      // System.err.println(\"got mouse click event \" + event);\n+      int row = BasicListUI.this.convertYToRow(event.y);\n+      if (row == -1)\n+        return;\n \n-\tListCellRenderer render = l.getCellRenderer();\n+      // System.err.println(\"clicked on row \" + row);\n+      BasicListUI.this.list.setSelectedIndex(row);\n+    }\n \n-\tSystem.out.println(\"RENDER-JLIST: \" + rows + \", \" + l.getModel().getSize());\n+    /**\n+     * Called when a mouse button is released on\n+     * the {@link JList}\n+     *\n+     * @param event The event representing the mouse press\n+     */\n+    public void mouseReleased(MouseEvent event)\n+    {\n+    }\n \n-\tpaintBackground(g, c);\n+    /**\n+     * Called when the mouse pointer enters the area bounded\n+     * by the {@link JList}\n+     *\n+     * @param event The event representing the mouse entry\n+     */\n+    public void mouseEntered(MouseEvent event)\n+    {\n+    }\n \n-\tif (l.getModel().getSize() == 0)\n-\t    return;\n+    /**\n+     * Called when the mouse pointer leaves the area bounded\n+     * by the {@link JList}\n+     *\n+     * @param event The event representing the mouse exit\n+     */\n+    public void mouseExited(MouseEvent event)\n+    {\n+    }\n \n-\t// use element 0 to figure out how big we are:\n-\tComponent elt = render.getListCellRendererComponent(l,\n-\t\t\t\t\t\t\t    l.getModel().getElementAt(0),\n-\t\t\t\t\t\t\t    0,       \n-\t\t\t\t\t\t\t    false,\n-\t\t\t\t\t\t\t    false);\n-\tDimension dim = elt.getPreferredSize();\n-\t\n-\tRectangle a = new Rectangle(0,\n-\t\t\t\t    0,\n-\t\t\t\t    dim.width,\n-\t\t\t\t    dim.height);\n+    /**\n+     * Called when the mouse pointer moves over the area bounded\n+     * by the {@link JList} while a button is held down.\n+     *\n+     * @param event The event representing the mouse drag\n+     */\n+    public void mouseDragged(MouseEvent event)\n+    {\n+    }\n+\n+    /**\n+     * Called when the mouse pointer moves over the area bounded\n+     * by the {@link JList}.\n+     *\n+     * @param event The event representing the mouse move\n+     */\n+    public void mouseMoved(MouseEvent event)\n+    {\n+    }\n+  }\n \n-\tfor (int i=0;i<l.getModel().getSize();i++)\n-\t    {\n-\t\tboolean is_sel = false;\n-\t\tboolean has_focus = false;\n+  /**\n+   * Helper class which listens to {@link PropertyChangeEvent}s\n+   * from the {@link JList}.\n+   */\n+  class PropertyChangeHandler implements PropertyChangeListener\n+  {\n+    /**\n+     * Called when the {@link JList} changes one of its bound properties.\n+     *\n+     * @param e The event representing the property change\n+     */\n+    public void propertyChange(PropertyChangeEvent e)\n+    {\n+      // System.err.println(this + \".propertyChange(\" + e + \")\");\n+      if (e.source == BasicListUI.this.list)\n+        {\n+          if (e.oldValue != null && e.oldValue instanceof ListModel)\n+            ((ListModel) e.oldValue).removeListDataListener(BasicListUI.this.listDataListener);\n+\n+          if (e.newValue != null && e.newValue instanceof ListModel)\n+            ((ListModel) e.newValue).addListDataListener(BasicListUI.this.listDataListener);\n+        }\n+      BasicListUI.this.damageLayout();\n+    }\n+  }\n \n-\t\tComponent comp = render.getListCellRendererComponent(l,\n-\t\t\t\t\t\t\t\t     l.getModel().getElementAt(i),\n-\t\t\t\t\t\t\t\t     i,            \n-\t\t\t\t\t\t\t\t     is_sel,\n-\t\t\t\t\t\t\t\t     has_focus);\n+  /**\n+   * Creates a new BasicListUI for the component.\n+   *\n+   * @param c The component to create a UI for\n+   *\n+   * @return A new UI\n+   */\n+  public static ComponentUI createUI(final JComponent c)\n+  {\n+    return new BasicListUI();\n+  }\n \n-\t\t//System.out.println(\"AAAAA=> \" + a + \", \" + comp + \", index = \" + i);\n+  /** The current focus listener. */\n+  FocusHandler focusListener;\n+\n+  /** The data listener listening to the model. */\n+  ListDataHandler listDataListener;\n+\n+  /** The selection listener listening to the selection model. */\n+  ListSelectionHandler listSelectionListener;\n+\n+  /** The mouse listener listening to the list. */\n+  MouseInputHandler mouseInputListener;\n+\n+  /** The property change listener listening to the list. */\n+  PropertyChangeHandler propertyChangeListener;\n+\n+  /** Saved reference to the list this UI was created for. */\n+  JList list;\n+\n+  /** The height of a single cell in the list. */\n+  int cellHeight;\n+\n+  /** The width of a single cell in the list. */\n+  int cellWidth;\n+\n+  /** \n+   * An array of varying heights of cells in the list, in cases where each\n+   * cell might have a different height.\n+   */\n+  int[] cellHeights;\n+\n+  /**\n+   * A simple counter. When nonzero, indicates that the UI class is out of\n+   * date with respect to the underlying list, and must recalculate the\n+   * list layout before painting or performing size calculations.\n+   */\n+  int updateLayoutStateNeeded;\n+\n+  /**\n+   * Calculate the height of a particular row. If there is a fixed {@link\n+   * #cellHeight}, return it; otherwise return the specific row height\n+   * requested from the {@link #cellHeights} array. If the requested row\n+   * is invalid, return <code>-1</code>.\n+   *\n+   * @param row The row to get the height of\n+   *\n+   * @return The height, in pixels, of the specified row\n+   */\n+  int getRowHeight(int row)\n+  {\n+    if (row < 0 || row >= cellHeights.length)\n+      return -1;\n+    else if (cellHeight != -1)\n+      return cellHeight;\n+    else\n+      return cellHeights[row];\n+  }\n \n-\t\tcomp.setBounds(a);\n+  /**\n+   * Calculate the bounds of a particular cell, considering the upper left\n+   * corner of the list as the origin position <code>(0,0)</code>.\n+   *\n+   * @param l Ignored; calculates over <code>this.list</code>\n+   * @param index1 The first row to include in the bounds\n+   * @param index2 The last row to incude in the bounds\n+   *\n+   * @return A rectangle encompassing the range of rows between \n+   * <code>index1</code> and <code>index2</code> inclusive\n+   */\n+  public Rectangle getCellBounds(JList l, int index1, int index2)\n+  {\n+    if (l != list || cellWidth == -1)\n+      return null;\n+\n+    int lo = Math.min(index1, index2);\n+    int hi = Math.max(index1, index2);\n+    Rectangle lobounds = new Rectangle(0, convertRowToY(lo), cellWidth,\n+                                       getRowHeight(lo));\n+    Rectangle hibounds = new Rectangle(0, convertRowToY(hi), cellWidth,\n+                                       getRowHeight(hi));\n+    return lobounds.union(hibounds);\n+  }\n \n-\t\tcomp.paint(g);\n+  /**\n+   * Calculate the Y coordinate of the upper edge of a particular row,\n+   * considering the Y coordinate <code>0</code> to occur at the top of the\n+   * list.\n+   *\n+   * @param row The row to calculate the Y coordinate of\n+   *\n+   * @return The Y coordinate of the specified row, or <code>-1</code> if\n+   * the specified row number is invalid\n+   */\n+  int convertRowToY(int row)\n+  {\n+    int y = 0;\n+    for (int i = 0; i < row; ++i)\n+      {\n+        int h = getRowHeight(i);\n+        if (h == -1)\n+          return -1;\n+        y += h;\n+      }\n+    return y;\n+  }\n \n-\t\ta.y += dim.height + gap_between_cells;\n-\t    }\n-    }\n+  /**\n+   * Calculate the row number containing a particular Y coordinate,\n+   * considering the Y coodrinate <code>0</code> to occur at the top of the\n+   * list.\n+   *\n+   * @param y0 The Y coordinate to calculate the row number for\n+   *\n+   * @return The row number containing the specified Y value, or <code>-1</code>\n+   * if the specified Y coordinate is invalid\n+   */\n+  int convertYToRow(int y0)\n+  {\n+    for (int row = 0; row < cellHeights.length; ++row)\n+      {\n+        int h = getRowHeight(row);\n+\n+        // System.err.println(\"convertYToRow(\" + y0 + \") vs. \" + h);\n+        if (y0 < h)\n+          return row;\n+        y0 -= h;\n+      }\n+    return -1;\n+  }\n \n-  public int locationToIndex(JList list, Point location)\n+  /**\n+   * Recomputes the {@link #cellHeights}, {@link #cellHeight}, and {@link\n+   * #cellWidth} properties by examining the variouis properties of the\n+   * {@link JList}.\n+   */\n+  void updateLayoutState()\n   {\n-    throw new Error (\"Not implemented\");\n+    int nrows = list.getModel().getSize();\n+    cellHeight = -1;\n+    cellWidth = -1;\n+    if (cellHeights == null || cellHeights.length != nrows)\n+      cellHeights = new int[nrows];\n+    if (list.getFixedCellHeight() == -1 || list.getFixedCellWidth() == -1)\n+      {\n+        ListCellRenderer rend = list.getCellRenderer();\n+        for (int i = 0; i < nrows; ++i)\n+          {\n+            Component flyweight = rend.getListCellRendererComponent(list,\n+                                                                    list.getModel()\n+                                                                        .getElementAt(i),\n+                                                                    0, false,\n+                                                                    false);\n+            Dimension dim = flyweight.getPreferredSize();\n+            cellHeights[i] = dim.height;\n+            cellWidth = Math.max(cellWidth, dim.width);\n+          }\n+      }\n+    else\n+      {\n+        cellHeight = list.getFixedCellHeight();\n+        cellWidth = list.getFixedCellWidth();\n+      }\n   }\n \n-  public Point indexToLocation(JList list, int index)\n+  /**\n+   * Marks the current layout as damaged and requests revalidation from the\n+   * JList.\n+   *\n+   * @see #updateLayoutStateNeeded\n+   */\n+  void damageLayout()\n+  {\n+    updateLayoutStateNeeded = 1;\n+    list.revalidate();\n+  }\n+\n+  /**\n+   * Calls {@link #updateLayoutState} if {@link #updateLayoutStateNeeded}\n+   * is nonzero, then resets {@link #updateLayoutStateNeeded} to zero.\n+   */\n+  void maybeUpdateLayoutState()\n   {\n-    throw new Error (\"Not implemented\");\n+    // System.err.println(this + \".maybeUpdateLayoutState()\");\n+    if (updateLayoutStateNeeded != 0)\n+      {\n+        updateLayoutState();\n+        updateLayoutStateNeeded = 0;\n+      }\n   }\n \n-  public Rectangle getCellBounds(JList list, int index1, int index2)\n+  /**\n+   * Creates a new BasicListUI object.\n+   */\n+  public BasicListUI()\n+  {\n+    focusListener = new FocusHandler();\n+    listDataListener = new ListDataHandler();\n+    listSelectionListener = new ListSelectionHandler();\n+    mouseInputListener = new MouseInputHandler();\n+    propertyChangeListener = new PropertyChangeHandler();\n+    updateLayoutStateNeeded = 1;\n+  }\n+\n+  /**\n+   * Installs various default settings (mostly colors) from the {@link\n+   * UIDefaults} into the {@link JList}\n+   *\n+   * @see #uninstallDefaults\n+   */\n+  void installDefaults()\n+  {\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+    list.setForeground(defaults.getColor(\"List.foreground\"));\n+    list.setBackground(defaults.getColor(\"List.background\"));\n+    list.setSelectionForeground(defaults.getColor(\"List.selectionForeground\"));\n+    list.setSelectionBackground(defaults.getColor(\"List.selectionBackground\"));\n+  }\n+\n+  /**\n+   * Resets to <code>null</code> those defaults which were installed in \n+   * {@link #installDefaults}\n+   */\n+  void uninstallDefaults()\n+  {\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+    list.setForeground(null);\n+    list.setBackground(null);\n+    list.setSelectionForeground(null);\n+    list.setSelectionBackground(null);\n+  }\n+\n+  /**\n+   * Attaches all the listeners we have in the UI class to the {@link\n+   * JList}, its model and its selection model.\n+   *\n+   * @see #uninstallListeners\n+   */\n+  void installListeners()\n+  {\n+    list.addFocusListener(focusListener);\n+    list.getModel().addListDataListener(listDataListener);\n+    list.addListSelectionListener(listSelectionListener);\n+    list.addMouseListener(mouseInputListener);\n+    list.addMouseMotionListener(mouseInputListener);\n+    list.addPropertyChangeListener(propertyChangeListener);\n+  }\n+\n+  /**\n+   * Detaches all the listeners we attached in {@link #installListeners}.\n+   */\n+  void uninstallListeners()\n+  {\n+    list.removeFocusListener(focusListener);\n+    list.getModel().removeListDataListener(listDataListener);\n+    list.removeListSelectionListener(listSelectionListener);\n+    list.removeMouseListener(mouseInputListener);\n+    list.removeMouseMotionListener(mouseInputListener);\n+    list.removePropertyChangeListener(propertyChangeListener);\n+  }\n+\n+  /**\n+   * Installs keyboard actions for this UI in the {@link JList}.\n+   */\n+  void installKeyboardActions()\n+  {\n+  }\n+\n+  /**\n+   * Uninstalls keyboard actions for this UI in the {@link JList}.\n+   */\n+  void uninstallKeyboardActions()\n+  {\n+  }\n+\n+  /**\n+   * Installs the various aspects of the UI in the {@link JList}. In\n+   * particular, calls {@link #installDefaults}, {@link #installListeners}\n+   * and {@link #installKeyboardActions}. Also saves a reference to the\n+   * provided component, cast to a {@link JList}.\n+   *\n+   * @param c The {@link JList} to install the UI into\n+   */\n+  public void installUI(final JComponent c)\n+  {\n+    super.installUI(c);\n+    list = (JList) c;\n+    installDefaults();\n+    installListeners();\n+    installKeyboardActions();\n+    // System.err.println(this + \".installUI()\");\n+    maybeUpdateLayoutState();\n+  }\n+\n+  /**\n+   * Uninstalls all the aspects of the UI which were installed in {@link\n+   * #installUI}. When finished uninstalling, drops the saved reference to\n+   * the {@link JList}.\n+   *\n+   * @param c Ignored; the UI is uninstalled from the {@link JList}\n+   * reference saved during the call to {@link #installUI}\n+   */\n+  public void uninstallUI(final JComponent c)\n+  {\n+    uninstallKeyboardActions();\n+    uninstallListeners();\n+    uninstallDefaults();\n+    list = null;\n+  }\n+\n+  /**\n+   * Gets the maximum size this list can assume.\n+   *\n+   * @param c The component to measure the size of\n+   *\n+   * @return A new Dimension representing the component's maximum size\n+   */\n+  public Dimension getMaximumSize(JComponent c)\n+  {\n+    return new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE);\n+  }\n+\n+  /**\n+   * Gets the size this list would prefer to assume. This is calculated by\n+   * calling {@link #getCellBounds} over the entire list.\n+   *\n+   * @param c Ignored; uses the saved {@link JList} reference \n+   *\n+   * @return DOCUMENT ME!\n+   */\n+  public Dimension getPreferredSize(JComponent c)\n+  {\n+    maybeUpdateLayoutState();\n+    if (list.getModel().getSize() == 0)\n+      return new Dimension(0, 0);\n+    Rectangle bounds = getCellBounds(list, 0, list.getModel().getSize() - 1);\n+    return bounds.getSize();\n+  }\n+\n+  /**\n+   * Paints the packground of the list using the background color\n+   * of the specified component.\n+   *\n+   * @param g The graphics context to paint in\n+   * @param c The component to paint the background of\n+   */\n+  public void paintBackground(Graphics g, JComponent c)\n+  {\n+    Dimension size = getPreferredSize(c);\n+    Color save = g.getColor();\n+    g.setColor(c.getBackground());\n+    g.fillRect(0, 0, size.width, size.height);\n+    g.setColor(save);\n+  }\n+\n+  /**\n+   * Paints a single cell in the list.\n+   *\n+   * @param g The graphics context to paint in\n+   * @param row The row number to paint\n+   * @param bounds The bounds of the cell to paint, assuming a coordinate\n+   * system beginning at <code>(0,0)</code> in the upper left corner of the\n+   * list\n+   * @param rend A cell renderer to paint with\n+   * @param data The data to provide to the cell renderer\n+   * @param sel A selection model to provide to the cell renderer\n+   * @param lead The lead selection index of the list\n+   */\n+  void paintCell(Graphics g, int row, Rectangle bounds, ListCellRenderer rend,\n+                 ListModel data, ListSelectionModel sel, int lead)\n+  {\n+    boolean is_sel = list.isSelectedIndex(row);\n+    boolean has_focus = false;\n+    Component comp = rend.getListCellRendererComponent(list,\n+                                                       data.getElementAt(row),\n+                                                       0, is_sel, has_focus);\n+    g.translate(bounds.x, bounds.y);\n+    comp.setBounds(new Rectangle(0, 0, bounds.width, bounds.height));\n+    comp.paint(g);\n+    g.translate(-bounds.x, -bounds.y);\n+  }\n+\n+  /**\n+   * Paints the list by calling {@link #paintBackground} and then repeatedly\n+   * calling {@link #paintCell} for each visible cell in the list.\n+   *\n+   * @param g The graphics context to paint with\n+   * @param c Ignored; uses the saved {@link JList} reference \n+   */\n+  public void paint(Graphics g, JComponent c)\n+  {\n+    int nrows = Math.min(list.getVisibleRowCount(), list.getModel().getSize());\n+    if (nrows == 0)\n+      return;\n+\n+    maybeUpdateLayoutState();\n+    ListCellRenderer render = list.getCellRenderer();\n+    ListModel model = list.getModel();\n+    ListSelectionModel sel = list.getSelectionModel();\n+    int lead = sel.getLeadSelectionIndex();\n+    paintBackground(g, list);\n+\n+    for (int row = 0; row < nrows; ++row)\n+      {\n+        Rectangle bounds = getCellBounds(list, row, row);\n+        paintCell(g, row, bounds, render, model, sel, lead);\n+      }\n+  }\n+\n+  public int locationToIndex(JList list, Point location)\n+  {\n+    throw new Error(\"Not implemented\");\n+  }\n+\n+  public Point indexToLocation(JList list, int index)\n   {\n-    throw new Error (\"Not implemented\");\n+    throw new Error(\"Not implemented\");\n   }\n }"}, {"sha": "c4d3d80a77c39de67a448aba4b407db6cddf043e", "filename": "libjava/javax/swing/plaf/basic/BasicLookAndFeel.java", "status": "modified", "additions": 41, "deletions": 26, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLookAndFeel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLookAndFeel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLookAndFeel.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -226,6 +226,13 @@ private void loadResourceBundle(UIDefaults defaults)\n   protected void initComponentDefaults(UIDefaults defaults)\n   {\n     Object[] uiDefaults;\n+    \n+    // The JDK's default L&F happens to use these three purple shades\n+    // extensively.\n+    Color lightPurple = new Color(0xCC, 0xCC, 0xFF);\n+    Color midPurple = new Color(0x99, 0x99, 0xCC);\n+    Color darkPurple = new Color(0x66, 0x66, 0x99);\n+\n     uiDefaults = new Object[] {\n \n       \"AbstractUndoableEdit.undoText\", \"Undo\",\n@@ -275,8 +282,8 @@ protected void initComponentDefaults(UIDefaults defaults)\n       \"CheckBoxMenuItem.font\", new FontUIResource(\"Dialog\", Font.PLAIN, 12),\n       \"CheckBoxMenuItem.foreground\", new ColorUIResource(Color.black),\n       \"CheckBoxMenuItem.margin\", new InsetsUIResource(2, 2, 2, 2),\n-      \"CheckBoxMenuItem.selectionBackground\", new ColorUIResource(0, 0, 128),\n-      \"CheckBoxMenuItem.selectionForeground\", new ColorUIResource(Color.white),\n+      \"CheckBoxMenuItem.selectionBackground\", new ColorUIResource(lightPurple),\n+      \"CheckBoxMenuItem.selectionForeground\", new ColorUIResource(Color.black),\n       \"ColorChooser.background\", new ColorUIResource(Color.lightGray),\n       \"ColorChooser.cancelText\", \"Cancel\",\n       \"ColorChooser.font\", new FontUIResource(\"Dialog\", Font.PLAIN, 12),\n@@ -316,8 +323,8 @@ protected void initComponentDefaults(UIDefaults defaults)\n       \"ComboBox.disabledForeground\", new ColorUIResource(Color.gray),\n       \"ComboBox.font\", new FontUIResource(\"SansSerif\", Font.PLAIN, 12),\n       \"ComboBox.foreground\", new ColorUIResource(Color.black),\n-      \"ComboBox.selectionBackground\", new ColorUIResource(0, 0, 128),\n-      \"ComboBox.selectionForeground\", new ColorUIResource(Color.white),\n+      \"ComboBox.selectionBackground\", new ColorUIResource(lightPurple),\n+      \"ComboBox.selectionForeground\", new ColorUIResource(Color.black),\n       \"Desktop.ancestorInputMap\", new UIDefaults.LazyInputMap(new Object[] {\n         \"KP_LEFT\", \"left\",\n         \"KP_RIGHT\", \"right\",\n@@ -412,8 +419,8 @@ protected void initComponentDefaults(UIDefaults defaults)\n       \"FocusManagerClassName\", \"TODO\",\n       \"FormView.resetButtonText\", \"Reset\",\n       \"FormView.submitButtonText\", \"Submit Query\",\n-      \"InternalFrame.activeTitleBackground\", new ColorUIResource(0, 0, 128),\n-      \"InternalFrame.activeTitleForeground\", new ColorUIResource(Color.white),\n+      \"InternalFrame.activeTitleBackground\", new ColorUIResource(lightPurple),\n+      \"InternalFrame.activeTitleForeground\", new ColorUIResource(Color.black),\n       \"InternalFrame.border\", new BorderUIResource.CompoundBorderUIResource(null,\n                                                                             null),\n       \"InternalFrame.closeIcon\", BasicIconFactory.createEmptyFrameIcon(),\n@@ -434,6 +441,9 @@ protected void initComponentDefaults(UIDefaults defaults)\n       \"Label.disabledForeground\", new ColorUIResource(Color.white),\n       \"Label.disabledShadow\", new ColorUIResource(Color.gray),\n       \"Label.font\", new FontUIResource(\"Dialog\", Font.PLAIN, 12),\n+      \"Label.foreground\", new ColorUIResource(Color.black),\n+      \"List.background\", new ColorUIResource(Color.white),\n+      \"List.border\", new BasicBorders.MarginBorder(),\n       \"List.focusInputMap\", new UIDefaults.LazyInputMap(new Object[] {\n         \"PAGE_UP\", \"scrollUp\",\n         \"ctrl \\\\\", \"clearSelection\",\n@@ -455,8 +465,8 @@ protected void initComponentDefaults(UIDefaults defaults)\n         \"KP_DOWN\", \"selectNextRow\"\n       }),\n       \"List.foreground\", new ColorUIResource(Color.black),\n-      \"List.selectionBackground\", new ColorUIResource(0, 0, 128),\n-      \"List.selectionForeground\", new ColorUIResource(Color.white),\n+      \"List.selectionBackground\", new ColorUIResource(0xCC, 0xCC, 0xFF),\n+      \"List.selectionForeground\", new ColorUIResource(Color.black),\n       \"Menu.acceleratorFont\", new FontUIResource(\"Dialog\", Font.PLAIN, 12),\n       \"Menu.acceleratorForeground\", new ColorUIResource(Color.black),\n       \"Menu.acceleratorSelectionForeground\", new ColorUIResource(Color.white),\n@@ -482,8 +492,8 @@ protected void initComponentDefaults(UIDefaults defaults)\n         \"ENTER\", \"return\",\n         \"SPACE\", \"return\"\n       },\n-      \"Menutext.selectionBackground\", new ColorUIResource(0, 0, 128),\n-      \"Menu.selectionForeground\", new ColorUIResource(Color.white),\n+      \"Menutext.selectionBackground\", new ColorUIResource(lightPurple),\n+      \"Menu.selectionForeground\", new ColorUIResource(Color.black),\n       \"MenuBar.background\", new ColorUIResource(Color.lightGray),\n       \"MenuBar.border\", new BasicBorders.MenuBarBorder(null, null),\n       \"MenuBar.font\", new FontUIResource(\"Dialog\", Font.PLAIN, 12),\n@@ -503,8 +513,8 @@ protected void initComponentDefaults(UIDefaults defaults)\n       \"MenuItem.font\", new FontUIResource(\"Dialog\", Font.PLAIN, 12),\n       \"MenuItem.foreground\", new ColorUIResource(Color.black),\n       \"MenuItem.margin\", new InsetsUIResource(2, 2, 2, 2),\n-      \"MenuItem.selectionBackground\", new ColorUIResource(0, 0, 128),\n-      \"MenuItem.selectionForeground\", new ColorUIResource(Color.white),\n+      \"MenuItem.selectionBackground\", new ColorUIResource(lightPurple),\n+      \"MenuItem.selectionForeground\", new ColorUIResource(Color.black),\n       \"OptionPane.background\", new ColorUIResource(Color.lightGray),\n       \"OptionPane.border\", new BorderUIResource.EmptyBorderUIResource(0, 0, 0, 0),\n       \"OptionPane.buttonAreaBorder\", new BorderUIResource.EmptyBorderUIResource(0, 0, 0, 0),\n@@ -544,8 +554,8 @@ protected void initComponentDefaults(UIDefaults defaults)\n                                                              0),\n                                       \"notify-field-accept\")},\n       \"PasswordField.margin\", new InsetsUIResource(0, 0, 0, 0),\n-      \"PasswordField.selectionBackground\", new ColorUIResource(0, 0, 128),\n-      \"PasswordField.selectionForeground\", new ColorUIResource(Color.white),\n+      \"PasswordField.selectionBackground\", new ColorUIResource(lightPurple),\n+      \"PasswordField.selectionForeground\", new ColorUIResource(Color.black),\n       \"PopupMenu.background\", new ColorUIResource(Color.lightGray),\n       \"PopupMenu.border\", new BorderUIResource.BevelBorderUIResource(0),\n       \"PopupMenu.font\", new FontUIResource(\"Dialog\", Font.PLAIN, 12),\n@@ -555,9 +565,11 @@ protected void initComponentDefaults(UIDefaults defaults)\n       \"ProgressBar.cellLength\", new Integer(1),\n       \"ProgressBar.cellSpacing\", new Integer(0),\n       \"ProgressBar.font\", new FontUIResource(\"Dialog\", Font.PLAIN, 12),\n-      \"ProgressBar.foreground\", new ColorUIResource(0, 0, 128),\n-      \"ProgressBar.selectionBackground\", new ColorUIResource(0, 0, 128),\n+      \"ProgressBar.foreground\", new ColorUIResource(midPurple),\n+      \"ProgressBar.selectionBackground\", new ColorUIResource(lightPurple),\n       \"ProgressBar.selectionForeground\", new ColorUIResource(Color.lightGray),\n+      \"ProgressBar.repaintInterval\", new Integer(250),\n+      \"ProgressBar.cycleTime\", new Integer(6000),\n       \"RadioButton.background\", new ColorUIResource(Color.lightGray),\n       \"RadioButton.border\", new BorderUIResource.CompoundBorderUIResource(null,\n                                                                           null),\n@@ -587,8 +599,8 @@ protected void initComponentDefaults(UIDefaults defaults)\n       \"RadioButtonMenuItem.font\", new FontUIResource(\"Dialog\", Font.PLAIN, 12),\n       \"RadioButtonMenuItem.foreground\", new ColorUIResource(Color.black),\n       \"RadioButtonMenuItem.margin\", new InsetsUIResource(2, 2, 2, 2),\n-      \"RadioButtonMenuItem.selectionBackground\", new ColorUIResource(0, 0, 128),\n-      \"RadioButtonMenuItem.selectionForeground\", new ColorUIResource(Color.white),\n+      \"RadioButtonMenuItem.selectionBackground\", new ColorUIResource(lightPurple),\n+      \"RadioButtonMenuItem.selectionForeground\", new ColorUIResource(Color.black),\n       \"RootPane.defaultButtonWindowKeyBindings\", new Object[] {\n         \"ENTER\",  \"press\",\n         \"released ENTER\", \"release\",\n@@ -663,6 +675,9 @@ protected void initComponentDefaults(UIDefaults defaults)\n       \"Slider.foreground\", new ColorUIResource(Color.lightGray),\n       \"Slider.highlight\", new ColorUIResource(Color.white),\n       \"Slider.shadow\", new ColorUIResource(Color.gray),\n+      \"Slider.thumbHeight\", new Integer(20),\n+      \"Slider.thumbWidth\", new Integer(10),\n+      \"Slider.tickHeight\", new Integer(12),\n       \"SplitPane.ancestorInputMap\", new UIDefaults.LazyInputMap(new Object[] {\n         \"F6\",  \"toggleFocus\",\n         \"F8\",  \"startResize\",\n@@ -762,8 +777,8 @@ protected void initComponentDefaults(UIDefaults defaults)\n       \"Table.foreground\", new ColorUIResource(Color.black),\n       \"Table.gridColor\", new ColorUIResource(Color.gray),\n       \"Table.scrollPaneBorder\", new BorderUIResource.BevelBorderUIResource(0),\n-      \"Table.selectionBackground\", new ColorUIResource(0, 0, 128),\n-      \"Table.selectionForeground\", new ColorUIResource(Color.white),\n+      \"Table.selectionBackground\", new ColorUIResource(lightPurple),\n+      \"Table.selectionForeground\", new ColorUIResource(Color.black),\n       \"TableHeader.background\", new ColorUIResource(Color.lightGray),\n       \"TableHeader.cellBorder\", new BorderUIResource.BevelBorderUIResource(0),\n       \"TableHeader.font\", new FontUIResource(\"Dialog\", Font.PLAIN, 12),\n@@ -790,8 +805,8 @@ protected void initComponentDefaults(UIDefaults defaults)\n                                                              0), \"insert-tab\")\n           },\n       \"TextArea.margin\", new InsetsUIResource(0, 0, 0, 0),\n-      \"TextArea.selectionBackground\", new ColorUIResource(0, 0, 128),\n-      \"TextArea.selectionForeground\", new ColorUIResource(Color.white),\n+      \"TextArea.selectionBackground\", new ColorUIResource(lightPurple),\n+      \"TextArea.selectionForeground\", new ColorUIResource(Color.black),\n       \"TextField.background\", new ColorUIResource(Color.white),\n       \"TextField.border\", new BasicBorders.FieldBorder(null, null, null, null),\n       \"TextField.caretBlinkRate\", new Integer(500),\n@@ -804,8 +819,8 @@ protected void initComponentDefaults(UIDefaults defaults)\n                                                              0),\n                                       \"notify-field-accept\")},\n       \"TextField.margin\", new InsetsUIResource(0, 0, 0, 0),\n-      \"TextField.selectionBackground\", new ColorUIResource(0, 0, 128),\n-      \"TextField.selectionForeground\", new ColorUIResource(Color.white),\n+      \"TextField.selectionBackground\", new ColorUIResource(lightPurple),\n+      \"TextField.selectionForeground\", new ColorUIResource(Color.black),\n       \"TextPane.background\", new ColorUIResource(Color.white),\n       \"TextPane.border\", new BasicBorders.MarginBorder(),\n       \"TextPane.caretBlinkRate\", new Integer(500),\n@@ -931,9 +946,9 @@ protected void initComponentDefaults(UIDefaults defaults)\n       \"Tree.rightChildIndent\", new Integer(13),\n       \"Tree.rowHeight\", new Integer(16),\n       \"Tree.scrollsOnExpand\", Boolean.TRUE,\n-      \"Tree.selectionBackground\", new ColorUIResource(0, 0, 128),\n+      \"Tree.selectionBackground\", new ColorUIResource(lightPurple),\n       \"Tree.selectionBorderColor\", new ColorUIResource(Color.black),\n-      \"Tree.selectionForeground\", new ColorUIResource(Color.white),\n+      \"Tree.selectionForeground\", new ColorUIResource(Color.black),\n       \"Tree.textBackground\", new ColorUIResource(Color.lightGray),\n       \"Tree.textForeground\", new ColorUIResource(Color.black),\n       \"Viewport.background\", new ColorUIResource(Color.lightGray),"}, {"sha": "bf5cd0a7aa984938d41ae7ef78a13b83c2bcbdd7", "filename": "libjava/javax/swing/plaf/basic/BasicProgressBarUI.java", "status": "added", "additions": 820, "deletions": 0, "changes": 820, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicProgressBarUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicProgressBarUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicProgressBarUI.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -0,0 +1,820 @@\n+/* BasicProgressBarUI.java\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import javax.swing.JComponent;\n+import javax.swing.JProgressBar;\n+import javax.swing.SwingConstants;\n+import javax.swing.SwingUtilities;\n+import javax.swing.Timer;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.ProgressBarUI;\n+\n+\n+/**\n+ * The Basic Look and Feel UI delegate for the \n+ * JProgressBar.\n+ */\n+public class BasicProgressBarUI extends ProgressBarUI\n+{\n+  /**\n+   * A helper class that listens for ChangeEvents \n+   * from the progressBar's model.\n+   */\n+  protected class ChangeHandler implements ChangeListener\n+  {\n+    /**\n+     * Called every time the state of the model changes.\n+     *\n+     * @param e The ChangeEvent given by the model.\n+     */\n+    public void stateChanged(ChangeEvent e)\n+    {\n+      // Nothing to do but repaint.\n+      progressBar.repaint();\n+    }\n+  }\n+\n+  /**\n+   * This helper class is used to listen for \n+   * PropertyChangeEvents from the progressBar.\n+   */\n+  private class PropertyChangeHandler implements PropertyChangeListener\n+  {\n+    /**\n+     * Called every time the properties of the \n+     * progressBar change.\n+     *\n+     * @param e The PropertyChangeEvent given by the progressBar.\n+     */\n+    public void propertyChange(PropertyChangeEvent e)\n+    {\n+      // Only need to listen for indeterminate changes.\n+      // All other things are done on a repaint.\n+      if (e.getPropertyName().equals(JProgressBar.INDETERMINATE_CHANGED_PROPERTY))\n+\tif (((Boolean) e.getNewValue()).booleanValue())\n+\t  startAnimationTimer();\n+\telse\n+\t  stopAnimationTimer();\n+      else\n+        progressBar.repaint();\n+    }\n+  }\n+\n+  /**\n+   * This helper class is used to listen for \n+   * the animationTimer's intervals. On every interval,\n+   * the bouncing box should move.\n+   */\n+  private class Animator implements ActionListener\n+  {\n+    /**\n+     * Called every time the animationTimer reaches\n+     * its interval.\n+     *\n+     * @param e The ActionEvent given by the timer.\n+     */\n+    public void actionPerformed(ActionEvent e)\n+    {\n+      // Incrementing the animation index will cause\n+      // a repaint.\n+      incrementAnimationIndex();\n+    }\n+  }\n+\n+  /** The timer used to move the bouncing box. */\n+  private transient Timer animationTimer = new Timer();\n+\n+\n+  // The total number of frames must be an even number.\n+  // The total number of frames is calculated from\n+  // the cycleTime and repaintInterval given by\n+  // the basic L&F's defaults.\n+  //\n+  // +-----------------------------------------------+\n+  // | frame0 | frame1 | frame2 | frame 3 | frame 4  |\n+  // |        | frame7 | frame6 | frame 5 |          |\n+  // +-----------------------------------------------+\n+  \n+  /** The current animation index. */\n+  private transient int animationIndex;\n+\n+  /** The total number of frames.*/\n+  private transient int numFrames;\n+\n+  /** The helper that moves the bouncing box. */\n+  private transient Animator animation;\n+\n+  /** The helper that listens for property change events. */\n+  private transient PropertyChangeHandler propertyListener;\n+\n+  /** The Listener for the model. */\n+  protected ChangeListener changeListener;\n+\n+  /** The progressBar for this UI. */\n+  protected JProgressBar progressBar;\n+\n+  /** The length of the cell. The cell is the painted part. */\n+  private transient int cellLength;\n+\n+  /** The gap between cells. */\n+  private transient int cellSpacing;\n+\n+  /** The color of the text when the bar is not over it.*/\n+  private transient Color selectionBackground;\n+\n+  /** The color of the text when the bar is over it. */\n+  private transient Color selectionForeground;\n+\n+  /**\n+   * Creates a new BasicProgressBarUI object.\n+   */\n+  public BasicProgressBarUI()\n+  {\n+    super();\n+  }\n+\n+  /**\n+   * Creates a new BasicProgressBarUI for the component.\n+   *\n+   * @param x The JComponent to create the UI for.\n+   *\n+   * @return A new BasicProgressBarUI.\n+   */\n+  public static ComponentUI createUI(JComponent x)\n+  {\n+    return new BasicProgressBarUI();\n+  }\n+\n+  /**\n+   * This method returns the length of the bar (from the minimum)\n+   * in pixels (or units that the Graphics object draws in) based\n+   * on the progressBar's getPercentComplete() value.\n+   *\n+   * @param b The insets of the progressBar.\n+   * @param width The width of the progressBar.\n+   * @param height The height of the progressBar.\n+   *\n+   * @return The length of the bar that should be painted in pixels.\n+   */\n+  protected int getAmountFull(Insets b, int width, int height)\n+  {\n+    double percentDone = progressBar.getPercentComplete();\n+    if (progressBar.getOrientation() == JProgressBar.HORIZONTAL)\n+      return (int) (percentDone * (width - b.left - b.right));\n+    else\n+      return (int) (percentDone * (height - b.top - b.bottom));\n+  }\n+\n+  /**\n+   * The current animation index.\n+   *\n+   * @return The current animation index.\n+   */\n+  protected int getAnimationIndex()\n+  {\n+    return animationIndex;\n+  }\n+\n+  /**\n+   * This method returns the size and position of the bouncing box\n+   * for the current animation index. It stores the values in the \n+   * given rectangle and returns it. It returns null if no box should\n+   * be drawn.\n+   *\n+   * @param r The bouncing box rectangle.\n+   *\n+   * @return The bouncing box rectangle.\n+   */\n+  protected Rectangle getBox(Rectangle r)\n+  {\n+    if (!progressBar.isIndeterminate())\n+      return null;\n+    //numFrames has to be an even number as defined by spec.\n+    int iterations = numFrames / 2 + 1;\n+\n+    double boxDependent;\n+    double boxIndependent;\n+\n+    if (progressBar.getOrientation() == JProgressBar.HORIZONTAL)\n+      {\n+\tDimension dims = getPreferredInnerHorizontal();\n+\tboxDependent = (double) dims.width / iterations;\n+\tboxIndependent = dims.height;\n+      }\n+    else\n+      {\n+\tDimension dims = getPreferredInnerVertical();\n+\tboxDependent = (double) dims.height / iterations;\n+\tboxIndependent = dims.width;\n+      }\n+\n+    Rectangle vr = new Rectangle();\n+    SwingUtilities.calculateInnerArea(progressBar, vr);\n+\n+    int index = getAnimationIndex();\n+    if (animationIndex > (numFrames + 1) / 2)\n+      index = numFrames - getAnimationIndex();\n+\n+    if (progressBar.getOrientation() == JProgressBar.HORIZONTAL)\n+      {\n+\tr.x = vr.x + (int) (index * boxDependent);\n+\tr.y = vr.y;\n+\tr.width = (int) boxDependent;\n+\tr.height = (int) boxIndependent;\n+      }\n+    else\n+      {\n+\tindex++;\n+\tr.x = vr.x;\n+\tr.y = vr.height - (int) (index * boxDependent) + vr.y;\n+\tr.width = (int) boxIndependent;\n+\tr.height = (int) boxDependent;\n+      }\n+\n+    return r;\n+  }\n+\n+  /**\n+   * This method returns the length of the cells.\n+   *\n+   * @return The cell length.\n+   */\n+  protected int getCellLength()\n+  {\n+    return cellLength;\n+  }\n+\n+  /**\n+   * This method returns the spacing between cells.\n+   *\n+   * @return The cell gap.\n+   */\n+  protected int getCellSpacing()\n+  {\n+    return cellSpacing;\n+  }\n+\n+  /**\n+   * This method returns the maximum size of the JComponent.\n+   * If it returns null, it is up to the LayoutManager\n+   * to give it a size.\n+   *\n+   * @param c The component to find a maximum size for.\n+   *\n+   * @return The maximum size.\n+   */\n+  public Dimension getMaximumSize(JComponent c)\n+  {\n+    return getPreferredSize(c);\n+  }\n+\n+  /**\n+   * This method returns the minimum size of the JComponent.\n+   * If it returns null, it is up to the LayoutManager to\n+   * give it a size.\n+   *\n+   * @param c The component to find a minimum size for.\n+   *\n+   * @return The minimum size.\n+   */\n+  public Dimension getMinimumSize(JComponent c)\n+  {\n+    return getPreferredSize(c);\n+  }\n+\n+  /**\n+   * This method returns the preferred size of the inner\n+   * rectangle (the bounds without the insets) if the\n+   * progressBar is horizontal.\n+   *\n+   * @return The preferred size of the progressBar minus \n+   *         insets if it's horizontal.\n+   */\n+  protected Dimension getPreferredInnerHorizontal()\n+  {\n+    Rectangle vr = new Rectangle();\n+\n+    SwingUtilities.calculateInnerArea(progressBar, vr);\n+\n+    return new Dimension(vr.width, vr.height);\n+  }\n+\n+  /**\n+   * This method returns the preferred size of the inner\n+   * rectangle (the bounds without insets) if the \n+   * progressBar is vertical.\n+   *\n+   * @return The preferred size of the progressBar minus\n+   *         insets if it's vertical.\n+   */\n+  protected Dimension getPreferredInnerVertical()\n+  {\n+    Rectangle vr = new Rectangle();\n+\n+    SwingUtilities.calculateInnerArea(progressBar, vr);\n+\n+    return new Dimension(vr.width, vr.height);\n+  }\n+\n+  /**\n+   * This method returns the preferred size of the \n+   * given JComponent. If it returns null, then it\n+   * is up to the LayoutManager to give it a size.\n+   *\n+   * @param c The component to find the preferred size for.\n+   *\n+   * @return The preferred size of the component.\n+   */\n+  public Dimension getPreferredSize(JComponent c)\n+  {\n+    // The only thing we need to worry about is\n+    // the text size.\n+    Graphics g = progressBar.getGraphics();\n+\n+    Insets insets = c.getInsets();\n+\n+    FontMetrics fm = g.getFontMetrics(c.getFont());\n+\n+    int textW = fm.stringWidth(progressBar.getString());\n+    int textH = fm.getHeight();\n+\n+    g.dispose();\n+\n+    if (progressBar.getOrientation() == JProgressBar.HORIZONTAL)\n+      {\n+\tif (textH < 20)\n+\t  textH = 20;\n+\tif (textW < 200)\n+\t  textW = 200;\n+      }\n+    else\n+      {\n+\tif (textH < 200)\n+\t  textH = 200;\n+\tif (textW < 20)\n+\t  textW = 20;\n+      }\n+    textW += insets.left + insets.right;\n+    textH += insets.top + insets.bottom;\n+    return new Dimension(textW, textH);\n+  }\n+\n+  /**\n+   * This method returns the Color that the text is shown in when the bar is\n+   * not over the text.\n+   *\n+   * @return The color of the text when the bar is not over it.\n+   */\n+  protected Color getSelectionBackground()\n+  {\n+    return selectionBackground;\n+  }\n+\n+  /**\n+   * This method returns the Color that the text is shown in  when the bar is\n+   * over the text.\n+   *\n+   * @return The color of the text when the bar is over it.\n+   */\n+  protected Color getSelectionForeground()\n+  {\n+    return selectionForeground;\n+  }\n+\n+  /**\n+   * This method returns the point (the top left of the bounding box)\n+   * where the text should be painted. \n+   *\n+   * @param g The Graphics object to measure FontMetrics with.\n+   * @param progressString The string to paint.\n+   * @param x The x coordinate of the overall bounds box.\n+   * @param y The y coordinate of the overall bounds box.\n+   * @param width The width of the overall bounds box.\n+   * @param height The height of the overall bounds box.\n+   *\n+   * @return The top left of the bounding box where text should be painted.\n+   */\n+  protected Point getStringPlacement(Graphics g, String progressString, int x,\n+                                     int y, int width, int height)\n+  {\n+    Rectangle tr = new Rectangle();\n+    Rectangle vr = new Rectangle(x, y, width, height);\n+    Rectangle ir = new Rectangle();\n+\n+    Font f = g.getFont();\n+    FontMetrics fm = g.getFontMetrics(f);\n+\n+    SwingUtilities.layoutCompoundLabel(progressBar, fm, progressString, null,\n+                                       SwingConstants.CENTER,\n+                                       SwingConstants.CENTER,\n+                                       SwingConstants.CENTER,\n+                                       SwingConstants.CENTER, vr, ir, tr, 0);\n+    return new Point(tr.x, tr.y);\n+  }\n+\n+  /**\n+   * This method increments the animation index.\n+   */\n+  public void incrementAnimationIndex()\n+  {\n+    animationIndex++;\n+    //numFrames is like string length, it should be named numFrames or something\n+    if (animationIndex >= numFrames)\n+      animationIndex = 0;\n+    progressBar.repaint();\n+  }\n+\n+  /**\n+   * This method paints the progressBar. It delegates its responsibilities\n+   * to paintDeterminate and paintIndeterminate.\n+   *\n+   * @param g The Graphics object to paint with.\n+   * @param c The JComponent to paint.\n+   */\n+  public void paint(Graphics g, JComponent c)\n+  {\n+    if (! progressBar.isIndeterminate())\n+      paintDeterminate(g, c);\n+    else\n+      paintIndeterminate(g, c);\n+      \n+    if (progressBar.isBorderPainted())\n+      progressBar.getBorder().paintBorder(progressBar, g, 0, 0,\n+                                          progressBar.getWidth(),\n+\t\t\t\t\t  progressBar.getHeight());\n+  }\n+\n+  /**\n+   * This method is called if the painting to be done is \n+   * for a determinate progressBar.\n+   *\n+   * @param g The Graphics object to paint with.\n+   * @param c The JComponent to paint.\n+   */\n+  protected void paintDeterminate(Graphics g, JComponent c)\n+  {\n+    Color saved = g.getColor();\n+    int space = getCellSpacing();\n+    int len = getCellLength();\n+    int max = progressBar.getMaximum();\n+    int min = progressBar.getMinimum();\n+    int value = progressBar.getValue();\n+\n+    Rectangle vr = new Rectangle();\n+    SwingUtilities.calculateInnerArea(c, vr);\n+\n+    Rectangle or = c.getBounds();\n+\n+    Insets insets = c.getInsets();\n+\n+    int amountFull = getAmountFull(insets, or.width, or.height);\n+\n+    g.setColor(c.getBackground());\n+    g.fill3DRect(vr.x, vr.y, vr.width, vr.height, false);\n+\n+    if (max != min && len != 0 && value > min)\n+      {\n+\tint iterations = value / (space + len);\n+\n+\tif (progressBar.getOrientation() == JProgressBar.HORIZONTAL)\n+\t  {\n+\t    double spaceInUnits = space * (double) vr.width / (max - min);\n+\t    double lenInUnits = len * (double) vr.width / (max - min);\n+\t    double currX = vr.x;\n+\n+\t    g.setColor(c.getForeground());\n+\t    g.fill3DRect(vr.x, vr.y, amountFull, vr.height, true);\n+\n+\t    g.setColor(c.getBackground());\n+\t    if (spaceInUnits != 0)\n+\t      {\n+\t\tfor (int i = 0; i < iterations; i++)\n+\t\t  {\n+\t\t    currX += lenInUnits;\n+\t\t    g.fill3DRect((int) currX, vr.y, (int) spaceInUnits,\n+\t\t                 vr.height, true);\n+\t\t    currX += spaceInUnits;\n+\t\t  }\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    double currY = vr.y;\n+\t    double spaceInUnits = space * (double) vr.height / (max - min);\n+\t    double lenInUnits = len * (double) vr.height / (max - min);\n+\n+\t    g.setColor(c.getForeground());\n+\t    g.fill3DRect(vr.x, vr.y + vr.height - amountFull, vr.width,\n+\t                 amountFull, true);\n+\n+\t    g.setColor(c.getBackground());\n+\n+\t    if (spaceInUnits != 0)\n+\t      {\n+\t\tfor (int i = 0; i < iterations; i++)\n+\t\t  {\n+\t\t    currY -= lenInUnits + spaceInUnits;\n+\t\t    g.fill3DRect(vr.x, (int) currY, vr.width,\n+\t\t                 (int) spaceInUnits, true);\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+\n+    if (progressBar.isStringPainted())\n+      paintString(g, 0, 0, or.width, or.height, amountFull, insets);\n+    g.setColor(saved);\n+  }\n+\n+  /**\n+   * This method is called if the painting to be done is for\n+   * an indeterminate progressBar.\n+   *\n+   * @param g The Graphics object to paint with.\n+   * @param c The JComponent to paint.\n+   */\n+  protected void paintIndeterminate(Graphics g, JComponent c)\n+  {\n+    //need to paint the box at it's current position. no text is painted since\n+    //all we're doing is bouncing back and forth\n+    Color saved = g.getColor();\n+    Insets insets = c.getInsets();\n+\n+    Rectangle or = c.getBounds();\n+    Rectangle vr = new Rectangle();\n+    SwingUtilities.calculateInnerArea(c, vr);\n+\n+    g.setColor(c.getBackground());\n+    g.fill3DRect(vr.x, vr.y, vr.width, vr.height, false);\n+\n+    Rectangle box = new Rectangle();\n+    getBox(box);\n+\n+    g.setColor(c.getForeground());\n+    g.fill3DRect(box.x, box.y, box.width, box.height, true);\n+\n+    if (progressBar.isStringPainted())\n+      paintString(g, 0, 0, or.width, or.height,\n+                  getAmountFull(insets, or.width, or.height), insets);\n+\n+    g.setColor(saved);\n+  }\n+\n+  /**\n+   * This method paints the string for the progressBar.\n+   *\n+   * @param g The Graphics object to paint with.\n+   * @param x The x coordinate of the progressBar.\n+   * @param y The y coordinate of the progressBar.\n+   * @param width The width of the progressBar.\n+   * @param height The height of the progressBar.\n+   * @param amountFull The amount of the progressBar that has its bar filled.\n+   * @param b The insets of the progressBar.\n+   */\n+  protected void paintString(Graphics g, int x, int y, int width, int height,\n+                             int amountFull, Insets b)\n+  {\n+    // We want to place in the exact center of the bar.\n+    Point placement = getStringPlacement(g, progressBar.getString(),\n+                                         x + b.left, y + b.top,\n+                                         width - b.left - b.right,\n+                                         height - b.top - b.bottom);\n+    Color saved = g.getColor();\n+\n+    // FIXME: The Color of the text should use selectionForeground and selectionBackground\n+    // but that can't be done right now, so we'll use white in the mean time.\n+    g.setColor(Color.WHITE);\n+\n+    FontMetrics fm = g.getFontMetrics(progressBar.getFont());\n+\n+    g.drawString(progressBar.getString(), placement.x,\n+                 placement.y + fm.getAscent());\n+\n+    g.setColor(saved);\n+  }\n+\n+  /**\n+   * This method sets the current animation index. If the index\n+   * is greater than the number of frames, it resets to 0.\n+   *\n+   * @param newValue The new animation index.\n+   */\n+  protected void setAnimationIndex(int newValue)\n+  {\n+    animationIndex = (newValue <= numFrames) ? newValue : 0;\n+    progressBar.repaint();\n+  }\n+\n+  /**\n+   * This method sets the cell length.\n+   *\n+   * @param cellLen The cell length.\n+   */\n+  protected void setCellLength(int cellLen)\n+  {\n+    cellLength = cellLen;\n+  }\n+\n+  /**\n+   * This method sets the cell spacing.\n+   *\n+   * @param cellSpace The cell spacing.\n+   */\n+  protected void setCellSpacing(int cellSpace)\n+  {\n+    cellSpacing = cellSpace;\n+  }\n+\n+  /**\n+   * This method starts the animation timer. It is called\n+   * when the propertyChangeListener detects that the progressBar\n+   * has changed to indeterminate mode.\n+   */\n+  protected void startAnimationTimer()\n+  {\n+    if (animationTimer != null)\n+      animationTimer.start();\n+  }\n+\n+  /**\n+   * This method stops the animation timer. It is called when\n+   * the propertyChangeListener detects that the progressBar\n+   * has changed to determinate mode.\n+   */\n+  protected void stopAnimationTimer()\n+  {\n+    if (animationTimer != null)\n+      animationTimer.stop();\n+    setAnimationIndex(0);\n+  }\n+\n+  /**\n+   * This method changes the settings for the progressBar to\n+   * the defaults provided by the current Look and Feel.\n+   */\n+  protected void installDefaults()\n+  {\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+\n+    progressBar.setFont(defaults.getFont(\"ProgressBar.font\"));\n+    progressBar.setForeground(defaults.getColor(\"ProgressBar.foreground\"));\n+    progressBar.setBackground(defaults.getColor(\"ProgressBar.background\"));\n+    progressBar.setBorder(defaults.getBorder(\"ProgressBar.border\"));\n+\n+    selectionForeground = defaults.getColor(\"ProgressBar.selectionForeground\");\n+    selectionBackground = defaults.getColor(\"ProgressBar.selectionBackground\");\n+    cellLength = defaults.getInt(\"ProgressBar.cellLength\");\n+    cellSpacing = defaults.getInt(\"ProgressBar.cellSpacing\");\n+\n+    int repaintInterval = defaults.getInt(\"ProgressBar.repaintInterval\");\n+    int cycleTime = defaults.getInt(\"ProgressBar.cycleTime\");\n+\n+    if (cycleTime % repaintInterval != 0\n+        && (cycleTime / repaintInterval) % 2 != 0)\n+      {\n+\tint div = (cycleTime / repaintInterval) + 2;\n+\tdiv /= 2;\n+\tdiv *= 2;\n+\tcycleTime = div * repaintInterval;\n+      }\n+    setAnimationIndex(0);\n+    numFrames = cycleTime / repaintInterval;\n+    animationTimer.setDelay(repaintInterval);\n+  }\n+\n+  /**\n+   * The method uninstalls any defaults that were\n+   * set by the current Look and Feel.\n+   */\n+  protected void uninstallDefaults()\n+  {\n+    progressBar.setFont(null);\n+    progressBar.setForeground(null);\n+    progressBar.setBackground(null);\n+\n+    selectionForeground = null;\n+    selectionBackground = null;\n+  }\n+\n+  /**\n+   * This method registers listeners to all the \n+   * components that this UI delegate needs to listen to.\n+   */\n+  protected void installListeners()\n+  {\n+    changeListener = new ChangeHandler();\n+    propertyListener = new PropertyChangeHandler();\n+    animation = new Animator();\n+\n+    progressBar.addChangeListener(changeListener);\n+    progressBar.addPropertyChangeListener(propertyListener);\n+    animationTimer.addActionListener(animation);\n+  }\n+\n+  /**\n+   * This method unregisters listeners to all the \n+   * components that were listened to.\n+   */\n+  protected void uninstallListeners()\n+  {\n+    progressBar.removeChangeListener(changeListener);\n+    progressBar.removePropertyChangeListener(propertyListener);\n+    animationTimer.removeActionListener(animation);\n+\n+    changeListener = null;\n+    propertyListener = null;\n+    animation = null;\n+  }\n+\n+  /**\n+   * This method installs the UI for the given JComponent.\n+   * This includes setting up defaults and listeners as\n+   * well as initializing any values or objects that\n+   * the UI may need.\n+   *\n+   * @param c The JComponent that is having this UI installed.\n+   */\n+  public void installUI(JComponent c)\n+  {\n+    super.installUI(c);\n+    if (c instanceof JProgressBar)\n+      {\n+\tprogressBar = (JProgressBar) c;\n+\n+\tanimationTimer = new Timer();\n+\tanimationTimer.setRepeats(true);\n+\n+\tinstallDefaults();\n+\tinstallListeners();\n+      }\n+  }\n+\n+  /**\n+   * This method removes the UI for the given JComponent.\n+   * This includes removing any listeners or defaults\n+   * that the installUI may have set up.\n+   *\n+   * @param c The JComponent that is having this UI uninstalled.\n+   */\n+  public void uninstallUI(JComponent c)\n+  {\n+    super.uninstallUI(c);\n+    uninstallListeners();\n+    uninstallDefaults();\n+\n+    animationTimer = null;\n+    progressBar = null;\n+  }\n+}"}, {"sha": "2e9f76d2e5fce27f67723db73de8b03441eec5be", "filename": "libjava/javax/swing/plaf/basic/BasicScrollBarUI.java", "status": "added", "additions": 1397, "deletions": 0, "changes": 1397, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollBarUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollBarUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollBarUI.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -0,0 +1,1397 @@\n+/* BasicScrollBarUI.java\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Rectangle;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseMotionListener;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import javax.swing.BoundedRangeModel;\n+import javax.swing.Icon;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JScrollBar;\n+import javax.swing.SwingConstants;\n+import javax.swing.SwingUtilities;\n+import javax.swing.Timer;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.ScrollBarUI;\n+\n+\n+/**\n+ * The Basic Look and Feel UI delegate for JScrollBar.\n+ */\n+public class BasicScrollBarUI extends ScrollBarUI implements LayoutManager,\n+                                                             SwingConstants\n+{\n+  /**\n+   * A helper class that listens to the two JButtons on each end\n+   * of the JScrollBar.\n+   */\n+  protected class ArrowButtonListener extends MouseAdapter\n+  {\n+    /**\n+     * Move the thumb in the direction specified by the \n+     * button's arrow. If this button is held down, then\n+     * it should keep moving the thumb.\n+     *\n+     * @param e The MouseEvent fired by the JButton.\n+     */\n+    public void mousePressed(MouseEvent e)\n+    {\n+      scrollTimer.stop();\n+      scrollListener.setScrollByBlock(false);\n+      if (e.getSource() == incrButton)\n+\tscrollListener.setDirection(POSITIVE_SCROLL);\n+      else\n+\tscrollListener.setDirection(NEGATIVE_SCROLL);\n+      scrollTimer.start();\n+    }\n+\n+    /**\n+     * Stops the thumb when the JButton is released.\n+     *\n+     * @param e The MouseEvent fired by the JButton.\n+     */\n+    public void mouseReleased(MouseEvent e)\n+    {\n+      scrollTimer.stop();\n+    }\n+  }\n+\n+  /**\n+   * A helper class that listens to the ScrollBar's model\n+   * for ChangeEvents.\n+   */\n+  protected class ModelListener implements ChangeListener\n+  {\n+    /**\n+     * Called when the model changes.\n+     *\n+     * @param e The ChangeEvent fired by the model.\n+     */\n+    public void stateChanged(ChangeEvent e)\n+    {\n+      getThumbBounds();\n+      scrollbar.repaint();\n+    }\n+  }\n+\n+  /**\n+   * A helper class that listens to the ScrollBar's properties.\n+   */\n+  public class PropertyChangeHandler implements PropertyChangeListener\n+  {\n+    /**\n+     * Called when one of the ScrollBar's properties change.\n+     *\n+     * @param e The PropertyChangeEvent fired by the ScrollBar.\n+     */\n+    public void propertyChange(PropertyChangeEvent e)\n+    {\n+      if (e.getPropertyName().equals(JScrollBar.MODEL_CHANGED_PROPERTY))\n+        {\n+\t  ((BoundedRangeModel) e.getOldValue()).removeChangeListener(modelListener);\n+\t  scrollbar.getModel().addChangeListener(modelListener);\n+\t  getThumbBounds();\n+        }\n+      else if (e.getPropertyName().equals(JScrollBar.ORIENTATION_CHANGED_PROPERTY))\n+        {\n+\t  incrButton.removeMouseListener(buttonListener);\n+\t  decrButton.removeMouseListener(buttonListener);\n+\t  incrButton = createIncreaseButton(scrollbar.getOrientation());\n+\t  decrButton = createDecreaseButton(scrollbar.getOrientation());\n+          incrButton.addMouseListener(buttonListener);\n+          decrButton.addMouseListener(buttonListener);\t  \n+          calculatePreferredSize();\n+          layoutContainer(scrollbar);\t\t  \n+\t}\n+      layoutContainer(scrollbar);\n+      scrollbar.repaint();\n+    }\n+  }\n+\n+  /**\n+   * A helper class that listens for events from\n+   * the timer that is used to move the thumb.\n+   */\n+  protected class ScrollListener implements ActionListener\n+  {\n+    /** The direction the thumb moves in. */\n+    private transient int direction;\n+\n+    /** Whether movement will be in blocks. */\n+    private transient boolean block;\n+\n+    /**\n+     * Creates a new ScrollListener object.\n+     * The default is scrolling positively with block movement.\n+     */\n+    public ScrollListener()\n+    {\n+      direction = POSITIVE_SCROLL;\n+      block = true;\n+    }\n+\n+    /**\n+     * Creates a new ScrollListener object using\n+     * the given direction and block.\n+     *\n+     * @param dir The direction to move in.\n+     * @param block Whether movement will be in blocks.\n+     */\n+    public ScrollListener(int dir, boolean block)\n+    {\n+      direction = dir;\n+      this.block = block;\n+    }\n+\n+    /**\n+     * Sets the direction to scroll in.\n+     *\n+     * @param direction The direction to scroll in.\n+     */\n+    public void setDirection(int direction)\n+    {\n+      this.direction = direction;\n+    }\n+\n+    /**\n+     * Sets whether scrolling will be done in blocks.\n+     *\n+     * @param block Whether scrolling will be in blocks.\n+     */\n+    public void setScrollByBlock(boolean block)\n+    {\n+      this.block = block;\n+    }\n+\n+    /**\n+     * Called every time the timer reaches its interval.\n+     *\n+     * @param e The ActionEvent fired by the timer.\n+     */\n+    public void actionPerformed(ActionEvent e)\n+    {\n+      if (block)\n+        {\n+\t  // Only need to check it if it's block scrolling\n+\t  // We only block scroll if the click occurs\n+\t  // in the track.\n+\t  \n+\t  if (!trackListener.shouldScroll(direction))\n+\t    {\n+\t      trackHighlight = NO_HIGHLIGHT;\n+\t      scrollbar.repaint();\n+\t      return;\n+\t    }\n+\t  scrollByBlock(direction);\n+        }\n+      else\n+\tscrollByUnit(direction);\n+    }\n+  }\n+\n+  /**\n+   * Helper class that listens for movement on the track.\n+   */\n+  protected class TrackListener extends MouseAdapter\n+    implements MouseMotionListener\n+  {\n+    /** The current X coordinate of the mouse. */\n+    protected int currentMouseX;\n+\n+    /** The current Y coordinate of the mouse. */\n+    protected int currentMouseY;\n+\n+    /** The offset between the current mouse cursor and the \n+        current value of the scrollbar. */\n+    protected int offset;\n+\n+    /**\n+     * This method is called when the mouse is being\n+     * dragged.\n+     *\n+     * @param e The MouseEvent given.\n+     */\n+    public void mouseDragged(MouseEvent e)\n+    {\n+      currentMouseX = e.getX();\n+      currentMouseY = e.getY();\n+      if (scrollbar.getValueIsAdjusting())\n+      {\n+        int value;\n+        if (scrollbar.getOrientation() == SwingConstants.HORIZONTAL)\n+\t  value = valueForXPosition(currentMouseX) - offset;\n+\telse\n+\t  value = valueForYPosition(currentMouseY) - offset;\n+\t\n+\tscrollbar.setValue(value);\n+      }\n+    }\n+\n+    /**\n+     * This method is called when the mouse is moved.\n+     *\n+     * @param e The MouseEvent given.\n+     */\n+    public void mouseMoved(MouseEvent e)\n+    {\n+      // Not interested in where the mouse\n+      // is unless it is being dragged.\n+    }\n+\n+    /**\n+     * This method is called when the mouse is\n+     * pressed. When it is pressed, the thumb should\n+     * move in blocks towards the cursor.\n+     *\n+     * @param e The MouseEvent given.\n+     */\n+    public void mousePressed(MouseEvent e)\n+    {\n+      currentMouseX = e.getX();\n+      currentMouseY = e.getY();\n+\n+      int value;\n+      if (scrollbar.getOrientation() == SwingConstants.HORIZONTAL)\n+\tvalue = valueForXPosition(currentMouseX);\n+      else\n+\tvalue = valueForYPosition(currentMouseY);\n+\n+      if (value == scrollbar.getValue())\n+\treturn;\n+\n+      if (!thumbRect.contains(e.getPoint()))\n+        {\n+\t  scrollTimer.stop();\n+\t  scrollListener.setScrollByBlock(true);\n+\t  if (value > scrollbar.getValue())\n+\t    {\n+\t      trackHighlight = INCREASE_HIGHLIGHT;\n+\t      scrollListener.setDirection(POSITIVE_SCROLL);\n+\t    }\n+\t  else\n+\t    {\n+\t      trackHighlight = DECREASE_HIGHLIGHT;\n+\t      scrollListener.setDirection(NEGATIVE_SCROLL);\n+\t    }\n+\t  scrollTimer.start();\n+        }\n+      else\n+        {\n+\t  // We'd like to keep track of where the cursor\n+\t  // is inside the thumb.\n+\t  // This works because the scrollbar's value represents \n+\t  // \"lower\" edge of the thumb. The value at which\n+\t  // the cursor is at must be greater or equal\n+\t  // to that value.\n+\t  scrollbar.setValueIsAdjusting(true);\n+\t  offset = value - scrollbar.getValue();\n+\t}\n+      scrollbar.repaint();      \n+    }\n+\n+    /**\n+     * This method is called when the mouse is released.\n+     * It should stop movement on the thumb\n+     *\n+     * @param e The MouseEvent given.\n+     */\n+    public void mouseReleased(MouseEvent e)\n+    {\n+      trackHighlight = NO_HIGHLIGHT;\n+      scrollTimer.stop();\n+      \n+      if (scrollbar.getValueIsAdjusting())\n+        scrollbar.setValueIsAdjusting(false);\n+      scrollbar.repaint();\n+    }\n+    \n+    /**\n+     * A helper method that decides whether we should\n+     * keep scrolling in the given direction.\n+     *\n+     * @param direction The direction to check for.\n+     *\n+     * @return Whether the thumb should keep scrolling.\n+     */\n+    public boolean shouldScroll (int direction)\n+    {\n+      int value;\n+      if (scrollbar.getOrientation() == HORIZONTAL)\n+        value = valueForXPosition(currentMouseX);\n+      else\n+        value = valueForYPosition(currentMouseY);\n+\n+      if (direction == POSITIVE_SCROLL)\n+        return (value > scrollbar.getValue());\n+      else\n+        return (value < scrollbar.getValue());\n+    }\n+  }\n+\n+  /** The listener that listens to the JButtons. */\n+  protected ArrowButtonListener buttonListener;\n+\n+  /** The listener that listens to the model. */\n+  protected ModelListener modelListener;\n+\n+  /** The listener that listens to the scrollbar for property\n+      changes. */\n+  protected PropertyChangeListener propertyChangeListener;\n+\n+  /** The listener that listens to the timer. */\n+  protected ScrollListener scrollListener;\n+\n+  /** The listener that listens for MouseEvents on the track. */\n+  protected TrackListener trackListener;\n+\n+  /** The JButton that decrements the scrollbar's value. */\n+  protected JButton decrButton;\n+\n+  /** The JButton that increments the scrollbar's value. */\n+  protected JButton incrButton;\n+\n+  /** The dimensions of the maximum thumb size. */\n+  protected static Dimension maximumThumbSize;\n+\n+  /** The dimensions of the minimum thumb size. */\n+  protected static Dimension minimumThumbSize;\n+\n+  /** The color of the thumb. */\n+  protected Color thumbColor;\n+\n+  /** The outer shadow of the thumb. */\n+  protected Color thumbDarkShadowColor;\n+\n+  /** The top and left edge color for the thumb. */\n+  protected Color thumbHighlightColor;\n+\n+  /** The outer light shadow for the thumb. */\n+  protected Color thumbLightShadowColor;\n+\n+  /** The color that is used when the mouse press\n+      occurs in the track. */\n+  protected Color trackHighlightColor;\n+\n+  /** The color of the track. */\n+  protected Color trackColor;\n+\n+  /** The size and position of the track. */\n+  protected Rectangle trackRect;\n+\n+  /** The size and position of the thumb. */\n+  protected Rectangle thumbRect;\n+\n+  /** Indicates that the decrease highlight should be painted. */\n+  protected static int DECREASE_HIGHLIGHT = 1;\n+\n+  /** Indicates that the increase highlight should be painted. */\n+  protected static int INCREASE_HIGHLIGHT = 2;\n+\n+  /** Indicates that no highlight should be painted. */\n+  protected static int NO_HIGHLIGHT = 0;\n+\n+  /** Indicates that the scrolling direction is positive. */\n+  private static int POSITIVE_SCROLL = 1;\n+\n+  /** Indicates that the scrolling direction is negative. */\n+  private static int NEGATIVE_SCROLL = -1;\n+\n+  /** The cached preferred size for the scrollbar. */\n+  private transient Dimension preferredSize;\n+\n+  /** The current highlight status. */\n+  protected int trackHighlight;\n+\n+  /** FIXME: Use this for something (presumably mouseDragged) */\n+  protected boolean isDragging;\n+\n+  /** The timer used to move the thumb when the mouse is held. */\n+  protected Timer scrollTimer;\n+\n+  /** The scrollbar this UI is acting for. */\n+  protected JScrollBar scrollbar;\n+\n+  /**\n+   * A helper class that allows us to draw icons for \n+   * the JButton.\n+   */\n+  private class arrowIcon implements Icon\n+  {\n+    /** The polygon that describes the icon. */\n+    private Polygon arrow;\n+\n+    /**\n+     * Creates a new arrowIcon object.\n+     *\n+     * @param arrow The polygon that describes the arrow.\n+     */\n+    public arrowIcon(Polygon arrow)\n+    {\n+      this.arrow = arrow;\n+    }\n+\n+    /**\n+     * Returns the height of the icon.\n+     *\n+     * @return The height of the icon.\n+     */\n+    public int getIconHeight()\n+    {\n+      return 10;\n+    }\n+\n+    /**\n+     * Returns the width of the icon.\n+     *\n+     * @return The width of the icon.\n+     */\n+    public int getIconWidth()\n+    {\n+      return 10;\n+    }\n+\n+    /**\n+     * Paints the icon.\n+     *\n+     * @param c The Component to paint for.\n+     * @param g The Graphics object to draw with.\n+     * @param x The X coordinate to draw at.\n+     * @param y The Y coordinate to draw at.\n+     */\n+    public void paintIcon(Component c, Graphics g, int x, int y)\n+    {\n+      g.translate(x, y);\n+\n+      Color saved = g.getColor();\n+\n+      g.setColor(Color.BLACK);\n+\n+      g.fillPolygon(arrow);\n+\n+      g.setColor(saved);\n+      g.translate(-x, -y);\n+    }\n+  }\n+\n+  /** The Icon that points up. */\n+  private static Icon upIcon = new arrowIcon(new Polygon(new int[] { 2, 5, 8 },\n+                                                            new int[] { 7, 3, 7 },\n+                                                            3));\n+\n+  /** The Icon that points down. */\n+  private static Icon downIcon = new arrowIcon(new Polygon(new int[] { 2, 5, 8 },\n+                                                              new int[] { 3, 7, 3 },\n+                                                              3));\n+\n+  /** The Icon that points left. */\n+  private static Icon leftIcon = new arrowIcon(new Polygon(new int[] { 7, 3, 7 },\n+                                                              new int[] { 2, 5, 8 },\n+                                                              3));\n+\n+  /** The Icon that points right. */\n+  private static Icon rightIcon = new arrowIcon(new Polygon(new int[]\n+                                                               {\n+                                                                 3, 7, 3\n+                                                               },\n+                                                               new int[]\n+                                                               {\n+                                                                 2, 5, 8\n+                                                               }, 3));\n+\n+  /**\n+   * This method adds a component to the layout.\n+   *\n+   * @param name The name to associate with the component that is added.\n+   * @param child The Component to add.\n+   */\n+  public void addLayoutComponent(String name, Component child)\n+  {\n+    // You should not be adding stuff to this component.\n+    // The contents are fixed.\n+  }\n+\n+  /**\n+   * This method configures the scrollbar's colors. This can be \n+   * done by looking up the standard colors from the L&F defaults.\n+   */\n+  protected void configureScrollBarColors()\n+  {\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+  \n+    trackColor = defaults.getColor(\"ScrollBar.track\");\n+    trackHighlightColor = defaults.getColor(\"ScrollBar.trackHighlight\");\n+    thumbColor = defaults.getColor(\"ScrollBar.thumb\");\n+    thumbHighlightColor = defaults.getColor(\"ScrollBar.thumbHighlight\");\n+    thumbDarkShadowColor = defaults.getColor(\"ScrollBar.thumbDarkShadow\");\n+    thumbLightShadowColor = defaults.getColor(\"ScrollBar.thumbLightShadow\");  \n+  }\n+\n+  /**\n+   * This method creates an ArrowButtonListener.\n+   *\n+   * @return A new ArrowButtonListener.\n+   */\n+  protected ArrowButtonListener createArrowButtonListener()\n+  {\n+    return new ArrowButtonListener();\n+  }\n+\n+  /** \n+   * This method creates a new JButton with the appropriate\n+   * icon for the orientation.\n+   *\n+   * @param orientation The orientation this JButton uses.\n+   *\n+   * @return The increase JButton.\n+   */\n+  protected JButton createIncreaseButton(int orientation)\n+  {\n+    if (incrButton == null)\n+      incrButton = new JButton();\n+    if (orientation == SwingConstants.HORIZONTAL)\n+      incrButton.setIcon(rightIcon);\n+    else\n+      incrButton.setIcon(downIcon);\n+\n+    return incrButton;\n+  }\n+\n+  /**\n+   * This method creates a new JButton with the appropriate\n+   * icon for the orientation.\n+   *\n+   * @param orientation The orientation this JButton uses.\n+   *\n+   * @return The decrease JButton.\n+   */\n+  protected JButton createDecreaseButton(int orientation)\n+  {\n+    if (decrButton == null)\n+      decrButton = new JButton();\n+    if (orientation == SwingConstants.HORIZONTAL)\n+      decrButton.setIcon(leftIcon);\n+    else\n+      decrButton.setIcon(upIcon);\n+\n+    return decrButton;\n+  }\n+\n+  /**\n+   * This method creates a new ModelListener.\n+   *\n+   * @return A new ModelListener.\n+   */\n+  protected ModelListener createModelListener()\n+  {\n+    return new ModelListener();\n+  }\n+\n+  /**\n+   * This method creates a new PropertyChangeListener.\n+   *\n+   * @return A new PropertyChangeListener.\n+   */\n+  protected PropertyChangeListener createPropertyChangeListener()\n+  {\n+    return new PropertyChangeHandler();\n+  }\n+\n+  /**\n+   * This method creates a new ScrollListener.\n+   *\n+   * @return A new ScrollListener.\n+   */\n+  protected ScrollListener createScrollListener()\n+  {\n+    return new ScrollListener();\n+  }\n+\n+  /**\n+   * This method creates a new TrackListener.\n+   *\n+   * @return A new TrackListener.\n+   */\n+  protected TrackListener createTrackListener()\n+  {\n+    return new TrackListener();\n+  }\n+\n+  /**\n+   * This method returns a new BasicScrollBarUI.\n+   *\n+   * @param c The JComponent to create a UI for.\n+   *\n+   * @return A new BasicScrollBarUI.\n+   */\n+  public static ComponentUI createUI(JComponent c)\n+  {\n+    return new BasicScrollBarUI();\n+  }\n+\n+  /**\n+   * This method returns the maximum size for this JComponent.\n+   *\n+   * @param c The JComponent to measure the maximum size for.\n+   *\n+   * @return The maximum size for the component.\n+   */\n+  public Dimension getMaximumSize(JComponent c)\n+  {\n+    return getPreferredSize(c);\n+  }\n+\n+  /**\n+   * This method returns the maximum thumb size.\n+   *\n+   * @return The maximum thumb size.\n+   */\n+  protected Dimension getMaximumThumbSize()\n+  {\n+    return maximumThumbSize;\n+  }\n+\n+  /**\n+   * This method returns the minimum size for this JComponent.\n+   *\n+   * @param c The JComponent to measure the minimum size for.\n+   *\n+   * @return The minimum size for the component.\n+   */\n+  public Dimension getMinimumSize(JComponent c)\n+  {\n+    return getPreferredSize(c);\n+  }\n+\n+  /**\n+   * This method returns the minimum thumb size.\n+   *\n+   * @return The minimum thumb size.\n+   */\n+  protected Dimension getMinimumThumbSize()\n+  {\n+    return minimumThumbSize;\n+  }\n+\n+  /**\n+   * This method calculates the preferred size since\n+   * calling getPreferredSize() returns a cached value.\n+   */\n+  private void calculatePreferredSize()\n+  {\n+    int height;\n+    int width;\n+    height = width = 0;\n+\n+    if (scrollbar.getOrientation() == SwingConstants.HORIZONTAL)\n+      {\n+\twidth += incrButton.getPreferredSize().getWidth();\n+\twidth += decrButton.getPreferredSize().getWidth();\n+\n+\twidth += Math.max(200, scrollbar.getVisibleAmount());\n+\n+\theight = Math.max(incrButton.getPreferredSize().height,\n+\t                  decrButton.getPreferredSize().height);\n+\theight = Math.max(getMinimumThumbSize().height, height);\n+\theight = Math.max(20, height);\n+\theight = Math.min(getMaximumThumbSize().height, height);\n+      }\n+    else\n+      {\n+\theight += incrButton.getPreferredSize().getHeight();\n+\theight += decrButton.getPreferredSize().getHeight();\n+\n+\theight += Math.max(200, scrollbar.getVisibleAmount());\n+\n+\twidth = Math.max(incrButton.getPreferredSize().width,\n+\t                 decrButton.getPreferredSize().width);\n+\twidth = Math.max(getMinimumThumbSize().width, width);\n+\twidth = Math.max(20, width);\n+\twidth = Math.min(getMaximumThumbSize().width, width);\n+      }\n+\n+    Insets insets = scrollbar.getInsets();\n+\n+    height += insets.top + insets.bottom;\n+    width += insets.left + insets.right;\n+\n+    preferredSize = new Dimension(width, height);\n+  }\n+\n+  /**\n+   * This method returns a cached value of the preferredSize.\n+   * The only restrictions are: If the scrollbar is horizontal, the\n+   * height should be the maximum of the height of the JButtons and \n+   * the minimum width of the thumb. For vertical scrollbars, the \n+   * calculation is similar (swap width for height and vice versa).\n+   *\n+   * @param c The JComponent to measure.\n+   *\n+   * @return The preferredSize.\n+   */\n+  public Dimension getPreferredSize(JComponent c)\n+  {\n+    layoutContainer(scrollbar);\n+    return preferredSize;\n+  }\n+\n+  /**\n+   * This method returns the thumb's bounds based on the \n+   * current value of the scrollbar. This method updates the\n+   * cached value and returns that.\n+   *\n+   * @return The thumb bounds.\n+   */\n+  protected Rectangle getThumbBounds()\n+  {\n+    int max = scrollbar.getMaximum();\n+    int min = scrollbar.getMinimum();\n+    int value = scrollbar.getValue();\n+    int extent = scrollbar.getVisibleAmount();\n+\n+    if (max == min)\n+    {\n+      thumbRect.x = trackRect.x;\n+      thumbRect.y = trackRect.y;\n+      if (scrollbar.getOrientation() == HORIZONTAL)\n+      {\n+\tthumbRect.width = getMinimumThumbSize().width;\n+\tthumbRect.height = trackRect.height;\n+      }\n+      else\n+      {\n+        thumbRect.width = trackRect.width;\n+\tthumbRect.height = getMinimumThumbSize().height;\n+      }\n+      return thumbRect;\n+    }\n+               \n+\n+    if (scrollbar.getOrientation() == HORIZONTAL)\n+      {\n+\tthumbRect.x = trackRect.x;\n+\tthumbRect.x += (value - min) * trackRect.width / (max - min);\n+\tthumbRect.y = trackRect.y;\n+\n+\tthumbRect.width = extent * trackRect.width / (max - min);\n+\tthumbRect.height = trackRect.height;\n+      }\n+    else\n+      {\n+\tthumbRect.x = trackRect.x;\n+\tthumbRect.y = trackRect.y\n+\t              + value * trackRect.height / (max - min);\n+\n+\tthumbRect.width = trackRect.width;\n+\tthumbRect.height = extent * trackRect.height / (max - min);\n+      }\n+    return thumbRect;\n+  }\n+\n+  /**\n+   * This method calculates the bounds of the track. This method\n+   * updates the cached value and returns it.\n+   *\n+   * @return The track's bounds.\n+   */\n+  protected Rectangle getTrackBounds()\n+  {\n+    SwingUtilities.calculateInnerArea(scrollbar, trackRect);\n+\n+    if (scrollbar.getOrientation() == SwingConstants.HORIZONTAL)\n+      {\n+\ttrackRect.width -= incrButton.getPreferredSize().getWidth();\n+\ttrackRect.width -= decrButton.getPreferredSize().getWidth();\n+\n+\ttrackRect.x += decrButton.getPreferredSize().getWidth();\n+      }\n+    else\n+      {\n+\ttrackRect.height -= incrButton.getPreferredSize().getHeight();\n+\ttrackRect.height -= decrButton.getPreferredSize().getHeight();\n+\n+\ttrackRect.y += incrButton.getPreferredSize().getHeight();\n+      }\n+    return trackRect;\n+  }\n+\n+  /**\n+   * This method installs any addition Components that \n+   * are a part of or related to this scrollbar.\n+   */\n+  protected void installComponents()\n+  {\n+    incrButton = createIncreaseButton(scrollbar.getOrientation());\n+    scrollbar.add(incrButton);\n+    decrButton = createDecreaseButton(scrollbar.getOrientation());\n+    scrollbar.add(decrButton);\n+  }\n+\n+  /**\n+   * This method installs the defaults for the scrollbar specified\n+   * by the Basic L&F.\n+   */\n+  protected void installDefaults()\n+  {\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+\n+    scrollbar.setForeground(defaults.getColor(\"ScrollBar.foreground\"));\n+    scrollbar.setBackground(defaults.getColor(\"ScrollBar.background\"));\n+\n+    scrollbar.setBorder(defaults.getBorder(\"ScrollBar.border\"));\n+\n+    maximumThumbSize = defaults.getDimension(\"ScrollBar.maximumThumbSize\");\n+    minimumThumbSize = defaults.getDimension(\"ScrollBar.minimumThumbSize\");\n+  }\n+\n+  /**\n+   * This method installs the keyboard actions for the scrollbar.\n+   */\n+  protected void installKeyboardActions()\n+  {\n+    // FIXME: implement.\n+  }\n+\n+  /**\n+   * This method installs any listeners for the scrollbar.\n+   * This method also installs listeners for things such as\n+   * the JButtons and the timer.\n+   */\n+  protected void installListeners()\n+  {\n+    scrollListener = createScrollListener();\n+    trackListener = createTrackListener();\n+    buttonListener = createArrowButtonListener();\n+    modelListener = createModelListener();\n+    propertyChangeListener = createPropertyChangeListener();\n+\n+    scrollbar.addMouseMotionListener(trackListener);\n+    scrollbar.addMouseListener(trackListener);\n+\n+    incrButton.addMouseListener(buttonListener);\n+    decrButton.addMouseListener(buttonListener);\n+\n+    scrollbar.addPropertyChangeListener(propertyChangeListener);\n+    scrollbar.getModel().addChangeListener(modelListener);\n+\n+    scrollTimer.addActionListener(scrollListener);\n+  }\n+\n+  /**\n+   * This method installs the UI for the component.\n+   * This can include setting up listeners, defaults, \n+   * and components. This also includes initializing any data\n+   * objects.\n+   *\n+   * @param c The JComponent to install.\n+   */\n+  public void installUI(JComponent c)\n+  {\n+    super.installUI(c);\n+    if (c instanceof JScrollBar)\n+      {\n+\tscrollbar = (JScrollBar) c;\n+\n+\ttrackRect = new Rectangle();\n+\tthumbRect = new Rectangle();\n+\n+\tscrollTimer = new Timer();\n+\tscrollTimer.setDelay(200);\n+\tscrollTimer.setRepeats(true);\n+\n+\tinstallComponents();\n+\tinstallListeners();\n+\tinstallDefaults();\n+\tconfigureScrollBarColors();\n+\n+\tcalculatePreferredSize();\n+        layoutContainer(scrollbar);\t\n+      }\n+  }\n+\n+  /**\n+   * This method lays out the scrollbar.\n+   *\n+   * @param scrollbarContainer The Container to layout.\n+   */\n+  public void layoutContainer(Container scrollbarContainer)\n+  {\n+    if (scrollbarContainer instanceof JScrollBar)\n+      {\n+\tif (scrollbar.getOrientation() == SwingConstants.HORIZONTAL)\n+\t  layoutHScrollbar((JScrollBar) scrollbarContainer);\n+\telse\n+\t  layoutVScrollbar((JScrollBar) scrollbarContainer);\n+      }\n+  }\n+\n+  /**\n+   * This method lays out the scrollbar horizontally.\n+   *\n+   * @param sb The JScrollBar to layout.\n+   */\n+  protected void layoutHScrollbar(JScrollBar sb)\n+  {\n+    // All we have to do is layout the 2 buttons?\n+    Rectangle vr = new Rectangle();\n+    SwingUtilities.calculateInnerArea(scrollbar, vr);\n+\n+    // Update the rectangles.\n+    getTrackBounds();\n+    getThumbBounds();\n+\n+    Dimension incrDims = incrButton.getPreferredSize();\n+    Dimension decrDims = decrButton.getPreferredSize();\n+\n+    decrButton.setBounds(vr.x, vr.y, decrDims.width, trackRect.height);\n+    incrButton.setBounds(trackRect.x + trackRect.width, vr.y, incrDims.width,\n+                         trackRect.height);\n+  }\n+\n+  /**\n+   * This method lays out the scrollbar vertically.\n+   *\n+   * @param sb The JScrollBar to layout.\n+   */\n+  protected void layoutVScrollbar(JScrollBar sb)\n+  {\n+    Rectangle vr = new Rectangle();\n+    SwingUtilities.calculateInnerArea(scrollbar, vr);\n+\n+    // Update rectangles\n+    getTrackBounds();\n+    getThumbBounds();\n+\n+    Dimension incrDims = incrButton.getPreferredSize();\n+    Dimension decrDims = decrButton.getPreferredSize();\n+\n+    decrButton.setBounds(vr.x, vr.y, trackRect.width, decrDims.height);\n+    incrButton.setBounds(vr.x, trackRect.y + trackRect.height,\n+                         trackRect.width, incrDims.height);\n+  }\n+\n+  /**\n+   * This method returns the minimum size required for the layout.\n+   *\n+   * @param scrollbarContainer The Container that is laid out.\n+   *\n+   * @return The minimum size.\n+   */\n+  public Dimension minimumLayoutSize(Container scrollbarContainer)\n+  {\n+    return preferredLayoutSize(scrollbarContainer);\n+  }\n+\n+  /**\n+   * This method is called when the component is painted.\n+   *\n+   * @param g The Graphics object to paint with.\n+   * @param c The JComponent to paint.\n+   */\n+  public void paint(Graphics g, JComponent c)\n+  {\n+    layoutContainer(scrollbar);\n+    \n+//    Rectangle r = incrButton.getBounds();\n+//    SwingUtilities.paintComponent(g, incrButton, scrollbar, r.x, r.y, r.width,\n+//                                  r.height);\n+//    r = decrButton.getBounds();\n+//    SwingUtilities.paintComponent(g, decrButton, scrollbar, r.x, r.y, r.width,\n+//                                  r.height);\n+\n+    paintTrack(g, c, getTrackBounds());\n+    paintThumb(g, c, getThumbBounds());\n+\n+    if (trackHighlight == INCREASE_HIGHLIGHT)\n+      paintIncreaseHighlight(g);\n+    else if (trackHighlight == DECREASE_HIGHLIGHT)\n+      paintDecreaseHighlight(g);\n+  }\n+\n+  /**\n+   * This method is called when repainting and the mouse is \n+   * pressed in the track. It paints the track below the thumb\n+   * with the trackHighlight color.\n+   *\n+   * @param g The Graphics object to paint with.\n+   */\n+  protected void paintDecreaseHighlight(Graphics g)\n+  {\n+    Color saved = g.getColor();\n+\n+    g.setColor(trackHighlightColor);\n+    if (scrollbar.getOrientation() == HORIZONTAL)\n+      g.fillRect(trackRect.x, trackRect.y, thumbRect.x - trackRect.x,\n+                 trackRect.height);\n+    else\n+      g.fillRect(trackRect.x, trackRect.y, trackRect.width, \n+                 thumbRect.y - trackRect.y);\n+    g.setColor(saved);\n+  }\n+\n+  /**\n+   * This method is called when repainting and the mouse is \n+   * pressed in the track. It paints the track above the thumb\n+   * with the trackHighlight color.\n+   *\n+   * @param g The Graphics objet to paint with.\n+   */\n+  protected void paintIncreaseHighlight(Graphics g)\n+  {\n+    Color saved = g.getColor();\n+\n+    g.setColor(trackHighlightColor);\n+    if (scrollbar.getOrientation() == HORIZONTAL)\n+      g.fillRect(thumbRect.x + thumbRect.width, trackRect.y,\n+                 trackRect.x + trackRect.width - thumbRect.x - thumbRect.width,\n+                 trackRect.height);\n+    else   \n+      g.fillRect(trackRect.x, thumbRect.y + thumbRect.height, \n+                 trackRect.width,\n+                 trackRect.y + trackRect.height - thumbRect.y - \n+\t\t thumbRect.height);\n+    g.setColor(saved);\n+  }\n+\n+  /**\n+   * This method paints the thumb.\n+   *\n+   * @param g The Graphics object to paint with.\n+   * @param c The Component that is being painted.\n+   * @param thumbBounds The thumb bounds.\n+   */\n+  protected void paintThumb(Graphics g, JComponent c, Rectangle thumbBounds)\n+  {\n+    Color saved = g.getColor();\n+    Point x;\n+    Point y;\n+    Point z;\n+    Polygon lines;\n+\n+    g.setColor(thumbHighlightColor);\n+    x = new Point(thumbBounds.x + 1, thumbBounds.y + 1);\n+    y = new Point(x);\n+    y.translate(thumbBounds.width - 2, 0);\n+    z = new Point(x);\n+    z.translate(0, thumbBounds.height - 2);\n+\n+    lines = new Polygon(new int[] { x.x, y.x, z.x },\n+                        new int[] { x.y, y.y, z.y }, 3);\n+\n+    g.drawPolygon(lines);\n+\n+    g.setColor(thumbLightShadowColor);\n+    x = new Point(thumbBounds.x + thumbBounds.width - 1,\n+                  thumbBounds.y + thumbBounds.height - 1);\n+    y = new Point(x);\n+    y.translate(-(thumbBounds.width - 2), 0);\n+    z = new Point(x);\n+    z.translate(0, -(thumbBounds.height - 2));\n+\n+    lines = new Polygon(new int[] { x.x, y.x, z.x },\n+                        new int[] { x.y, y.y, z.y }, 3);\n+    g.drawPolygon(lines);\n+\n+    g.setColor(thumbDarkShadowColor);\n+    x = new Point(thumbBounds.x + thumbBounds.width,\n+                  thumbBounds.y + thumbBounds.height);\n+    y = new Point(x);\n+    y.translate(-thumbBounds.width, 0);\n+    z = new Point(x);\n+    z.translate(0, -thumbBounds.height);\n+\n+    lines = new Polygon(new int[] { x.x, y.x, z.x },\n+                        new int[] { x.y, y.y, z.y }, 3);\n+    g.drawPolygon(lines);\n+\n+    g.setColor(thumbColor);\n+    g.fillRect(thumbBounds.x, thumbBounds.y, thumbBounds.width,\n+               thumbBounds.height);\n+\n+    g.setColor(saved);\n+  }\n+\n+  /**\n+   * This method paints the track.\n+   *\n+   * @param g The Graphics object to paint with.\n+   * @param c The JComponent being painted.\n+   * @param trackBounds The track's bounds.\n+   */\n+  protected void paintTrack(Graphics g, JComponent c, Rectangle trackBounds)\n+  {\n+    Color saved = g.getColor();\n+    g.setColor(trackColor);\n+    g.fill3DRect(trackBounds.x, trackBounds.y, trackBounds.width,\n+                 trackBounds.height, false);\n+    g.setColor(saved);\n+  }\n+\n+  /**\n+   * This method returns the preferred size for the layout.\n+   *\n+   * @param scrollbarContainer The Container to find a size for.\n+   *\n+   * @return The preferred size for the layout.\n+   */\n+  public Dimension preferredLayoutSize(Container scrollbarContainer)\n+  {\n+    if (scrollbarContainer instanceof JComponent)\n+      return getPreferredSize((JComponent) scrollbarContainer);\n+    else\n+      return null;\n+  }\n+\n+  /**\n+   * This method removes a child component from the layout.\n+   *\n+   * @param child The child to remove.\n+   */\n+  public void removeLayoutComponent(Component child)\n+  {\n+    // You should not be removing stuff from this component.\n+  }\n+\n+  /**\n+   * The method scrolls the thumb by a block in the \n+   * direction specified.\n+   *\n+   * @param direction The direction to scroll.\n+   */\n+  protected void scrollByBlock(int direction)\n+  {\n+    scrollbar.setValue(scrollbar.getValue() + scrollbar.getBlockIncrement(direction));\n+  }\n+\n+  /**\n+   * The method scrolls the thumb by a unit in the\n+   * direction specified.\n+   *\n+   * @param direction The direction to scroll.\n+   */\n+  protected void scrollByUnit(int direction)\n+  {\n+    scrollbar.setValue(scrollbar.getValue() + scrollbar.getUnitIncrement(direction));\n+  }\n+\n+  /**\n+   * This method sets the thumb's bounds.\n+   *\n+   * @param x The X position of the thumb.\n+   * @param y The Y position of the thumb.\n+   * @param width The width of the thumb.\n+   * @param height The height of the thumb.\n+   */\n+  protected void setThumbBounds(int x, int y, int width, int height)\n+  {\n+    thumbRect.x = x;\n+    thumbRect.y = y;\n+    thumbRect.width = width;\n+    thumbRect.height = height;\n+  }\n+\n+  /**\n+   * This method uninstalls any components that \n+   * are a part of or related to this scrollbar.\n+   */\n+  protected void uninstallComponents()\n+  {\n+    scrollbar.remove(incrButton);\n+    scrollbar.remove(decrButton);\n+    incrButton = null;\n+    decrButton = null;\n+  }\n+\n+  /**\n+   * This method uninstalls any defaults that this\n+   * scrollbar acquired from the Basic L&F defaults.\n+   */\n+  protected void uninstallDefaults()\n+  {\n+    scrollbar.setForeground(null);\n+    scrollbar.setBackground(null);\n+    scrollbar.setBorder(null);\n+  }\n+\n+  /**\n+   * This method uninstalls any keyboard\n+   * actions this scrollbar acquired during install.\n+   */\n+  protected void uninstallKeyboardActions()\n+  {\n+    // FIXME: implement.\n+  }\n+\n+  /**\n+   * This method uninstalls any listeners that\n+   * were registered during install.\n+   */\n+  protected void uninstallListeners()\n+  {\n+    scrollTimer.removeActionListener(scrollListener);\n+    \n+    scrollbar.getModel().removeChangeListener(modelListener);\n+    scrollbar.removePropertyChangeListener(propertyChangeListener);\n+    \n+    decrButton.removeMouseListener(buttonListener);\n+    incrButton.removeMouseListener(buttonListener);\n+    \n+    scrollbar.removeMouseListener(trackListener);\n+    scrollbar.removeMouseMotionListener(trackListener);\n+    \n+    propertyChangeListener = null;\n+    modelListener = null;\n+    buttonListener = null;\n+    trackListener = null;\n+    scrollListener = null;\n+  }\n+\n+  /**\n+   * This method uninstalls the UI. This includes\n+   * removing any defaults, listeners, and components\n+   * that this UI may have initialized. It also nulls\n+   * any instance data.\n+   *\n+   * @param c The Component to uninstall for.\n+   */\n+  public void uninstallUI(JComponent c)\n+  {\n+    uninstallDefaults();\n+    uninstallListeners();\n+    uninstallComponents();\n+    \n+    scrollTimer = null;\n+    \n+    thumbRect = null;\n+    trackRect = null;\n+    \n+    trackColor = null;\n+    trackHighlightColor = null;\n+    thumbColor = null;\n+    thumbHighlightColor = null;\n+    thumbDarkShadowColor = null;\n+    thumbLightShadowColor = null;\n+    \n+    scrollbar = null;\n+  }\n+\n+  /**\n+   * This method returns the value in the scrollbar's range given the y\n+   * coordinate. If the value is out of range, it will return the closest\n+   * legal value.\n+   *\n+   * @param yPos The y coordinate to calculate a value for.\n+   *\n+   * @return The value for the y coordinate.\n+   */\n+  private int valueForYPosition(int yPos)\n+  {\n+    int min = scrollbar.getMinimum();\n+    int max = scrollbar.getMaximum();\n+    int len = trackRect.height;\n+\n+    int value;\n+\n+    // If the length is 0, you shouldn't be able to even see where the thumb is.\n+    // This really shouldn't ever happen, but just in case, we'll return the middle.\n+    if (len == 0)\n+      return ((max - min) / 2);\n+\n+    value = ((yPos - trackRect.y) * (max - min) / len + min);\n+\n+    // If this isn't a legal value, then we'll have to move to one now.\n+    if (value > max)\n+      value = max;\n+    else if (value < min)\n+      value = min;\n+    return value;\n+  }\n+\n+  /**\n+   * This method returns the value in the scrollbar's range given the x\n+   * coordinate. If the value is out of range, it will return the closest\n+   * legal value.\n+   *\n+   * @param xPos The x coordinate to calculate a value for.\n+   *\n+   * @return The value for the x coordinate.\n+   */\n+  private int valueForXPosition(int xPos)\n+  {\n+    int min = scrollbar.getMinimum();\n+    int max = scrollbar.getMaximum();\n+    int len = trackRect.width;\n+\n+    int value;\n+\n+    // If the length is 0, you shouldn't be able to even see where the slider is.\n+    // This really shouldn't ever happen, but just in case, we'll return the middle.\n+    if (len == 0)\n+      return ((max - min) / 2);\n+\n+    value = ((xPos - trackRect.x) * (max - min) / len + min);\n+\n+    // If this isn't a legal value, then we'll have to move to one now.\n+    if (value > max)\n+      value = max;\n+    else if (value < min)\n+      value = min;\n+    return value;\n+  }\n+}"}, {"sha": "4f60fb48dc556b79e8224994fcd4bc8bccb64f3a", "filename": "libjava/javax/swing/plaf/basic/BasicScrollPaneUI.java", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollPaneUI.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -41,14 +41,14 @@\n import java.awt.Dimension;\n import java.awt.Graphics;\n import javax.swing.JComponent;\n+import javax.swing.JScrollBar;\n import javax.swing.JScrollPane;\n+import javax.swing.ScrollPaneLayout;\n import javax.swing.plaf.ComponentUI;\n import javax.swing.plaf.ScrollPaneUI;\n \n public class BasicScrollPaneUI extends ScrollPaneUI\n {\n-    int min_w = 50;\n-    int min_h = 50;\n \n     public static ComponentUI createUI(final JComponent c) \n     {\n@@ -61,33 +61,25 @@ public void installUI(final JComponent c)\n \tsuper.installUI(c);\n     }\n     \n+    public Dimension getMinimumSize(JComponent c) \n+    {\n+\tJScrollPane p = (JScrollPane ) c;\n+        ScrollPaneLayout sl = (ScrollPaneLayout) p.getLayout();\n+        return sl.minimumLayoutSize(c);\n+    }\n \n     public Dimension getPreferredSize(JComponent c) \n     {\n \tJScrollPane p = (JScrollPane ) c;\n-\t\n-\tDimension d = new Dimension(min_w,\n-\t\t\t\t    min_h);\n-\t\n-\tDimension a = p.getViewport().getPreferredSize();\n-\n-\tif (a != null)\n-\t    {\n-\t\td.width = Math.max(d.width, a.width);\n-\t\td.height = Math.max(d.height, a.height);\n-\t    }\n-\t\t\t   \n-\n-\tSystem.out.println(\"BasicScrollPaneUI->preff->\"+d);\n-\treturn d;\n+        ScrollPaneLayout sl = (ScrollPaneLayout) p.getLayout();\n+        return sl.preferredLayoutSize(c);\n     }\n \n+\n     public void paint(Graphics g, JComponent c)\n     {      \n-\tSystem.out.println(\"BasicScrollPaneUI->paint()->\"+c);\n-\n-\tJScrollPane p = (JScrollPane ) c;\n-\tp.getViewport().paint(g);\n+      // do nothing; the normal painting-of-children algorithm, along with\n+      // ScrollPaneLayout, does all the relevant work.\n     }\n }\n "}, {"sha": "b7df0acb27deb55ff254e0df29daaf4ef17bf53b", "filename": "libjava/javax/swing/plaf/basic/BasicSeparatorUI.java", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSeparatorUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSeparatorUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSeparatorUI.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -0,0 +1,266 @@\n+/* BasicSeparatorUI.java\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.Dimension;\n+import java.awt.Color;\n+import java.awt.Rectangle;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.SeparatorUI;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.JComponent;\n+import javax.swing.JSeparator;\n+import javax.swing.SwingUtilities;\n+\n+/**\n+ * The Basic L&F UI delegate for JSeparator.\n+ */\n+public class BasicSeparatorUI extends SeparatorUI\n+{\n+  /** The shadow color. */\n+  protected Color shadow;\n+\n+  /** The highlight color. */\n+  protected Color highlight;\n+\n+  /**\n+   * Creates a new UI delegate for the given JComponent.\n+   *\n+   * @param c The JComponent to create a delegate for.\n+   *\n+   * @return A new BasicSeparatorUI.\n+   */\n+  public static ComponentUI createUI(JComponent c)\n+  {\n+    return new BasicSeparatorUI();\n+  }\n+\n+  /**\n+   * This method installs the UI for the given JComponent.\n+   * This can include installing defaults, listeners, and\n+   * initializing any instance data.\n+   *\n+   * @param c The JComponent that is having this UI installed.\n+   */\n+  public void installUI(JComponent c)\n+  {\n+    super.installUI(c);\n+\n+    if (c instanceof JSeparator)\n+      {\n+\tJSeparator s = (JSeparator) c;\n+\n+\tinstallDefaults(s);\n+\tinstallListeners(s);\n+      }\n+  }\n+\n+  /**\n+   * Uninstalls the UI for the given JComponent. This\n+   * method reverses what was done when installing\n+   * the UI on the JComponent.\n+   *\n+   * @param c The JComponent that is having this UI uninstalled.\n+   */\n+  public void uninstallUI(JComponent c)\n+  {\n+    if (c instanceof JSeparator)\n+      {\n+\tJSeparator s = (JSeparator) c;\n+\n+\tuninstallListeners(s);\n+\tuninstallDefaults(s);\n+      }\n+  }\n+\n+  /**\n+   * This method installs the defaults that are given by\n+   * the Basic L&F.\n+   *\n+   * @param s The JSeparator that is being installed.\n+   */\n+  protected void installDefaults(JSeparator s)\n+  {\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+\n+    shadow = defaults.getColor(\"Separator.shadow\");\n+    highlight = defaults.getColor(\"Separator.highlight\");\n+  }\n+\n+  /**\n+   * This method removes the defaults that were given\n+   * by the Basic L&F.\n+   *\n+   * @param s The JSeparator that is being uninstalled.\n+   */\n+  protected void uninstallDefaults(JSeparator s)\n+  {\n+    shadow = null;\n+    highlight = null;\n+  }\n+\n+  /**\n+   * This method installs any listeners that need\n+   * to be attached to the JSeparator or any of its \n+   * components.\n+   *\n+   * @param s The JSeparator that is being installed.\n+   */\n+  protected void installListeners(JSeparator s)\n+  {\n+    // Separators don't receive events.\n+  }\n+\n+  /**\n+   * This method uninstalls any listeners that\n+   * were installed during the install UI process.\n+   *\n+   * @param s The JSeparator that is being uninstalled.\n+   */\n+  protected void uninstallListeners(JSeparator s)\n+  {\n+    // Separators don't receive events.  \n+  }\n+\n+  /**\n+   * The separator is made of two lines. The top line will be \n+   * the highlight color (or left line if it's vertical). The bottom \n+   * or right line will be the shadow color. The two lines will \n+   * be centered inside the bounds box. If the separator is horizontal, \n+   * then it will be vertically centered, or if it's vertical, it will \n+   * be horizontally centered.\n+   *\n+   * @param g The Graphics object to paint with\n+   * @param c The JComponent to paint.\n+   */\n+  public void paint(Graphics g, JComponent c)\n+  {\n+    Rectangle r = new Rectangle();\n+    SwingUtilities.calculateInnerArea(c, r);\n+    Color saved = g.getColor();\n+    \n+    int midAB = r.width / 2 + r.x;\n+    int midAD = r.height / 2 + r.y;\n+  \n+    JSeparator s;\n+    if (c instanceof JSeparator)\n+      s = (JSeparator) c;\n+    else\n+      return;\n+      \n+    if (s.getOrientation() == JSeparator.HORIZONTAL)\n+    {    \n+      g.setColor(highlight);\n+      g.drawLine(r.x, midAD, r.x + r.width, midAD);\n+      \n+      g.setColor(shadow);\n+      g.drawLine(r.x, midAD + 1, r.x + r.width, midAD + 1);\n+    }\n+    else\n+    {\n+      g.setColor(highlight);\n+      g.drawLine(midAB, r.y, midAB, r.y + r.height);\n+      \n+      g.setColor(shadow);\n+      g.drawLine(midAB + 1, r.y, midAB + 1, r.y + r.height);\n+    }\n+  }\n+\n+  /**\n+   * This method returns the preferred size of the \n+   * JComponent.\n+   *\n+   * @param c The JComponent to measure.\n+   *\n+   * @return The preferred size.\n+   */\n+  public Dimension getPreferredSize(JComponent c)\n+  {\n+    Dimension dims = new Dimension(0, 0);\n+    Insets insets = c.getInsets();\n+\n+    if (c instanceof JSeparator)\n+      {\n+\tJSeparator s = (JSeparator) c;\n+\n+\tif (s.getOrientation() == JSeparator.HORIZONTAL)\n+\t{\n+\t  dims.height = 2;\n+\t  dims.width = 40;\n+\t}\n+\telse\n+\t{\n+\t  dims.width = 2;\n+\t  dims.height = 40;\n+\t}\n+      }\n+    dims.width += insets.left + insets.right;\n+    dims.height += insets.top + insets.bottom;\n+    \n+    return dims;\n+  }\n+\n+  /**\n+   * This method returns the minimum size of the\n+   * JComponent.\n+   *\n+   * @param c The JComponent to measure.\n+   *\n+   * @return The minimum size.\n+   */\n+  public Dimension getMinimumSize(JComponent c)\n+  {\n+    return getPreferredSize(c);\n+  }\n+\n+  /**\n+   * This method returns the maximum size of the\n+   * JComponent.\n+   *\n+   * @param c The JComponent to measure.\n+   *\n+   * @return The maximum size.\n+   */\n+  public Dimension getMaximumSize(JComponent c)\n+  {\n+    return getPreferredSize(c);\n+  }\n+}"}, {"sha": "2ee481e317d9594d9fae4cab6a6b6eb0f18ea1e6", "filename": "libjava/javax/swing/plaf/basic/BasicSliderUI.java", "status": "added", "additions": 2213, "deletions": 0, "changes": 2213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSliderUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSliderUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSliderUI.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -0,0 +1,2213 @@\n+/* BasicSliderUI.java\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package javax.swing.plaf.basic;\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.ComponentOrientation;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Rectangle;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.ComponentAdapter;\n+import java.awt.event.ComponentEvent;\n+import java.awt.event.ComponentListener;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseEvent;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.Dictionary;\n+import java.util.Enumeration;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JLabel;\n+import javax.swing.JSlider;\n+import javax.swing.KeyStroke;\n+import javax.swing.SwingUtilities;\n+import javax.swing.Timer;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.BoundedRangeModel;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+import javax.swing.event.MouseInputAdapter;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.SliderUI;\n+\n+\n+/**\n+ * <p>\n+ * BasicSliderUI.java This is the UI delegate in the Basic look and feel that\n+ * paints JSliders.\n+ * </p>\n+ * \n+ * <p>\n+ * The UI delegate keeps track of 6 rectangles that place the various parts of\n+ * the JSlider inside the component.\n+ * </p>\n+ * \n+ * <p>\n+ * The rectangles are organized as follows:\n+ * </p>\n+ * <pre>\n+ *     +-------------------------------------------------------+ <-- focusRect\n+ *     |                                                       |\n+ *     |  +==+-------------------+==+--------------------+==+<------ contentRect\n+ *     |  |  |                   |  |<---thumbRect       |  |  |\n+ *     |  |  |    TRACK          |  |                    |<--------- trackRect\n+ *     |  |  +-------------------+==+--------------------+  |  |\n+ *     |  |  |                                           |  |  |\n+ *     |  |  |          TICKS GO HERE                    |<-------- tickRect\n+ *     |  |  |                                           |  |  |\n+ *     |  +==+-------------------------------------------+==+  |\n+ *     |  |  |                                           |  |  |\n+ *     |  |  |                                           |  |<----- labelRect\n+ *     |  |  |                 LABELS GO HERE            |  |  |\n+ *     |  |  |                                           |  |  |\n+ *     |  |  |                                           |  |  |\n+ *     |  |  |                                           |  |  |\n+ *     |  |  |                                           |  |  |\n+ *     |  |                                              |  |  |\n+ * </pre>\n+ * \n+ * <p>\n+ * The space between the contentRect and the focusRect are the FocusInsets.\n+ * </p>\n+ * \n+ * <p>\n+ * The space between the focusRect and the component bounds is the insetCache\n+ * which are the component's insets.\n+ * </p>\n+ * \n+ * <p>\n+ * The top of the thumb is the top of the contentRect. The trackRect has to be\n+ * as tall as the thumb.\n+ * </p>\n+ * \n+ * <p>\n+ * The trackRect and tickRect do not start from the left edge of the\n+ * focusRect. They are trackBuffer away from each side of the focusRect. This\n+ * is so that the thumb has room to move.\n+ * </p>\n+ * \n+ * <p>\n+ * The labelRect does start right against the contentRect's left and right\n+ * edges and it gets all remaining space.\n+ * </p>\n+ */\n+public class BasicSliderUI extends SliderUI\n+{\n+  /**\n+   * Helper class that listens to the {@link JSlider}'s model for changes.\n+   */\n+  protected class ChangeHandler implements ChangeListener\n+  {\n+    /**\n+     * Called when the slider's model has been altered. The UI delegate should\n+     * recalculate any rectangles that are dependent on the model for their\n+     * positions and repaint.\n+     *\n+     * @param e A static {@link ChangeEvent} passed from the model.\n+     */\n+    public void stateChanged(ChangeEvent e)\n+    {\n+      // Maximum, minimum, and extent values will be taken\n+      // care of automatically when the slider is repainted.\n+      \n+      // Only thing that needs recalculation is the thumb.\n+      calculateThumbLocation();\n+      slider.repaint();\n+    }\n+  }\n+\n+  /**\n+   * Helper class that listens for resize events.\n+   */\n+  protected class ComponentHandler extends ComponentAdapter\n+  {\n+    /**\n+     * Called when the size of the component changes. The UI delegate should\n+     * recalculate any rectangles that are dependent on the model for their\n+     * positions and repaint.\n+     *\n+     * @param e A {@link ComponentEvent}.\n+     */\n+    public void componentResized(ComponentEvent e)\n+    {\n+      calculateGeometry();\n+\n+      slider.revalidate();\n+      slider.repaint();\n+    }\n+  }\n+\n+  /**\n+   * Helper class that listens for focus events.\n+   */\n+  protected class FocusHandler implements FocusListener\n+  {\n+    /**\n+     * Called when the {@link JSlider} has gained focus.  It should repaint\n+     * the slider with the focus drawn.\n+     *\n+     * @param e A {@link FocusEvent}.\n+     */\n+    public void focusGained(FocusEvent e)\n+    {\n+      // FIXME: implement.\n+    }\n+\n+    /**\n+     * Called when the {@link JSlider} has lost focus. It  should repaint the\n+     * slider without the focus drawn.\n+     *\n+     * @param e A {@link FocusEvent}.\n+     */\n+    public void focusLost(FocusEvent e)\n+    {\n+      // FIXME: implement.\n+    }\n+  }\n+\n+  /**\n+   * Helper class that listens for changes to the properties of the {@link\n+   * JSlider}.\n+   */\n+  protected class PropertyChangeHandler implements PropertyChangeListener\n+  {\n+    /**\n+     * Called when one of the properties change. The UI should recalculate any\n+     * rectangles if necessary and repaint.\n+     *\n+     * @param e A {@link PropertyChangeEvent}.\n+     */\n+    public void propertyChange(PropertyChangeEvent e)\n+    {\n+      // Check for orientation changes.\n+      if (e.getPropertyName().equals(JSlider.ORIENTATION_CHANGED_PROPERTY))\n+\trecalculateIfOrientationChanged();\n+      else if (e.getPropertyName().equals(JSlider.MODEL_CHANGED_PROPERTY))\n+      {\n+        BoundedRangeModel oldModel = (BoundedRangeModel) e.getOldValue();\n+\toldModel.removeChangeListener(changeListener);\n+\tslider.getModel().addChangeListener(changeListener);\n+\tcalculateThumbLocation();\n+      }\n+      // elif the componentOrientation changes (this is a bound property,\n+      // just undocumented) we change leftToRightCache. In Sun's \n+      // implementation, the LTR cache changes on a repaint. This is strange\n+      // since there is no need to do so. We could events here and \n+      // update the cache. \n+      \n+      // elif the border/insets change, we recalculateInsets.\n+      slider.repaint();\n+    }\n+  }\n+\n+  /**\n+   * Helper class that listens to our swing timer. This class is responsible\n+   * for listening to the timer and moving the thumb in the proper direction\n+   * every interval.\n+   */\n+  protected class ScrollListener implements ActionListener\n+  {\n+    /** Indicates which direction the thumb should scroll. */\n+    private transient int direction;\n+\n+    /** Indicates whether we should scroll in blocks or in units. */\n+    private transient boolean block;\n+\n+    /**\n+     * Creates a new ScrollListener object.\n+     */\n+    public ScrollListener()\n+    {\n+      direction = POSITIVE_SCROLL;\n+      block = false;\n+    }\n+\n+    /**\n+     * Creates a new ScrollListener object.\n+     *\n+     * @param dir The direction to scroll in.\n+     * @param block If movement will be in blocks.\n+     */\n+    public ScrollListener(int dir, boolean block)\n+    {\n+      direction = dir;\n+      this.block = block;\n+    }\n+\n+    /**\n+     * Called every time the swing timer reaches its interval. If the thumb\n+     * needs to move, then this method will move the thumb one block or  unit\n+     * in the direction desired. Otherwise, the timer can be stopped.\n+     *\n+     * @param e An {@link ActionEvent}.\n+     */\n+    public void actionPerformed(ActionEvent e)\n+    {\n+      if (! trackListener.shouldScroll(direction))\n+        {\n+\t  scrollTimer.stop();\n+\t  return;\n+        }\n+\n+      if (block)\n+\tscrollByBlock(direction);\n+      else\n+\tscrollByUnit(direction);\n+    }\n+\n+    /**\n+     * Sets the direction to scroll in.\n+     *\n+     * @param direction The direction to scroll in.\n+     */\n+    public void setDirection(int direction)\n+    {\n+      this.direction = direction;\n+    }\n+\n+    /**\n+     * Sets whether movement will be in blocks.\n+     *\n+     * @param block If movement will be in blocks.\n+     */\n+    public void setScrollByBlock(boolean block)\n+    {\n+      this.block = block;\n+    }\n+  }\n+\n+  /**\n+   * Helper class that listens for mouse events.\n+   */\n+  protected class TrackListener extends MouseInputAdapter\n+  {\n+    /** The current X position of the mouse. */\n+    protected int currentMouseX;\n+\n+    /** The current Y position of the mouse. */\n+    protected int currentMouseY;\n+\n+    /** The offset between the current slider value\n+        and the cursor's position. */\n+    protected int offset;\n+\n+    /**\n+     * Called when the mouse has been dragged. This should find the mouse's\n+     * current position and adjust the value of the {@link JSlider}\n+     * accordingly.\n+     *\n+     * @param e A {@link MouseEvent}\n+     */\n+    public void mouseDragged(MouseEvent e)\n+    {\n+      currentMouseX = e.getX();\n+      currentMouseY = e.getY();\n+      if (slider.getValueIsAdjusting())\n+      {\n+        int value;\n+        if (slider.getOrientation() == JSlider.HORIZONTAL)\n+\t  value = valueForXPosition(currentMouseX) - offset;\n+\telse\n+\t  value = valueForYPosition(currentMouseY) - offset;\n+\t\n+\tslider.setValue(value);\n+      }\n+    }\n+\n+    /**\n+     * Called when the mouse has moved over a component but no buttons have\n+     * been pressed yet.\n+     *\n+     * @param e A {@link MouseEvent}\n+     */\n+    public void mouseMoved(MouseEvent e)\n+    {\n+      // Don't care that we're moved unless we're dragging.\n+    }\n+\n+    /**\n+     * Called when the mouse is pressed. When the press occurs on the thumb\n+     * itself, the {@link JSlider} should have its value set to where the\n+     * mouse was pressed. If the press occurs on the track, then the thumb\n+     * should move one block towards the direction of the mouse.\n+     *\n+     * @param e A {@link MouseEvent}\n+     */\n+    public void mousePressed(MouseEvent e)\n+    {\n+      currentMouseX = e.getX();\n+      currentMouseY = e.getY();\n+\n+      int value;\n+      if (slider.getOrientation() == JSlider.HORIZONTAL)\n+\tvalue = valueForXPosition(currentMouseX);\n+      else\n+\tvalue = valueForYPosition(currentMouseY);\n+\n+      if (slider.getSnapToTicks())\n+\tvalue = findClosestTick(value);\n+\n+      if (value == slider.getValue())\n+\treturn;\n+\n+      // If the thumb is hit, then we don't need to set the timers to move it. \n+      if (!thumbRect.contains(e.getPoint()))\n+        {\n+\t  // The mouse has hit some other part of the slider.\n+\t  // The value moves no matter where in the slider you hit.\n+\t  if (value > slider.getValue())\n+\t    scrollDueToClickInTrack(POSITIVE_SCROLL);\n+\t  else\n+\t    scrollDueToClickInTrack(NEGATIVE_SCROLL);\n+        }\n+      else\n+        {\n+\t  slider.setValueIsAdjusting(true);\n+          offset = value - slider.getValue();\n+\t}\n+    }\n+\n+    /**\n+     * Called when the mouse is released.  This should stop the timer that\n+     * scrolls the thumb.\n+     *\n+     * @param e A {@link MouseEvent}\n+     */\n+    public void mouseReleased(MouseEvent e)\n+    {\n+      currentMouseX = e.getX();\n+      currentMouseY = e.getY();\n+\n+      if (slider.getValueIsAdjusting())\n+      {\n+        slider.setValueIsAdjusting(false);\n+\tif (slider.getSnapToTicks())\n+\t  slider.setValue(findClosestTick(slider.getValue()));\n+      }\n+      if (scrollTimer != null)\n+\tscrollTimer.stop();\n+    }\n+\n+    /**\n+     * Indicates whether the thumb should scroll in the given direction.\n+     *\n+     * @param direction The direction to check.\n+     *\n+     * @return True if the thumb should move in that direction.\n+     */\n+    public boolean shouldScroll(int direction)\n+    {\n+      int value;\n+      if (slider.getOrientation() == JSlider.HORIZONTAL)\n+\tvalue = valueForXPosition(currentMouseX);\n+      else\n+\tvalue = valueForYPosition(currentMouseY);\n+\n+      if (direction == POSITIVE_SCROLL)\n+\treturn (value > slider.getValue());\n+      else\n+\treturn (value < slider.getValue());\n+    }\n+  }\n+\n+  /** The preferred height of the thumb. */\n+  private transient int thumbHeight;\n+\n+  /** The preferred width of the thumb. */\n+  private transient int thumbWidth;\n+\n+  /** The preferred height of the tick rectangle. */\n+  private transient int tickHeight;\n+\n+  /** Listener for changes from the model. */\n+  protected ChangeListener changeListener;\n+\n+  /** Listener for changes to the {@link JSlider}. */\n+  protected PropertyChangeListener propertyChangeListener;\n+\n+  /** Listener for the scrollTimer. */\n+  protected ScrollListener scrollListener;\n+\n+  /** Listener for component resizing. */\n+  protected ComponentListener componentListener;\n+\n+  /** Listener for focus handling. */\n+  protected FocusListener focusListener;\n+\n+  /** Listener for mouse events. */\n+  protected TrackListener trackListener;\n+\n+  /** The insets between the FocusRectangle and the ContentRectangle. */\n+  protected Insets focusInsets;\n+\n+  /** The {@link JSlider}'s insets. */\n+  protected Insets insetCache;\n+\n+  /** Rectangle describing content bounds. See diagram above. */\n+  protected Rectangle contentRect;\n+\n+  /** Rectangle describing focus bounds. See diagram above. */\n+  protected Rectangle focusRect;\n+\n+  /** Rectangle describing the thumb's bounds. See diagram above. */\n+  protected Rectangle thumbRect;\n+\n+  /** Rectangle describing the tick bounds. See diagram above. */\n+  protected Rectangle tickRect;\n+\n+  /** Rectangle describing the label bounds. See diagram above. */\n+  protected Rectangle labelRect;\n+\n+  /** Rectangle describing the track bounds. See diagram above. */\n+  protected Rectangle trackRect;\n+\n+  /** FIXME: use this somewhere. */\n+  public static final int MAX_SCROLL = 2;\n+\n+  /** FIXME: use this somewhere. */\n+  public static final int MIN_SCROLL = -2;\n+\n+  /** A constant describing scrolling towards the minimum. */\n+  public static final int NEGATIVE_SCROLL = -1;\n+\n+  /** A constant describing scrolling towards the maximum. */\n+  public static final int POSITIVE_SCROLL = 1;\n+\n+  /** The gap between the edges of the contentRect and trackRect. */\n+  protected int trackBuffer;\n+\n+  /** Whether this slider is actually drawn left to right. */\n+  protected boolean leftToRightCache;\n+\n+  /** A timer that periodically moves the thumb. */\n+  protected Timer scrollTimer;\n+\n+  /** A reference to the {@link JSlider} that this UI was created for. */\n+  protected JSlider slider;\n+\n+  /** The shadow color. */\n+  private transient Color shadowColor;\n+\n+  /** The highlight color. */\n+  private transient Color highlightColor;\n+\n+  /** The focus color. */\n+  private transient Color focusColor;\n+\n+  /**\n+   * Creates a new Basic look and feel Slider UI.\n+   *\n+   * @param b The {@link JSlider} that this UI was created for.\n+   */\n+  public BasicSliderUI(JSlider b)\n+  {\n+    super();\n+  }\n+\n+  /**\n+   * Gets the shadow color to be used for this slider. The shadow color is the\n+   * color used for drawing the top and left edges of the track.\n+   *\n+   * @return The shadow color.\n+   */\n+  protected Color getShadowColor()\n+  {\n+    return shadowColor;\n+  }\n+\n+  /**\n+   * Gets the highlight color to be used for this slider. The highlight color\n+   * is the color used for drawing the bottom and right edges of the track.\n+   *\n+   * @return The highlight color.\n+   */\n+  protected Color getHighlightColor()\n+  {\n+    return highlightColor;\n+  }\n+\n+  /**\n+   * Gets the focus color to be used for this slider. The focus color is the\n+   * color used for drawing the focus rectangle when the component gains\n+   * focus.\n+   *\n+   * @return The focus color.\n+   */\n+  protected Color getFocusColor()\n+  {\n+    return focusColor;\n+  }\n+\n+  /**\n+   * Factory method to create a BasicSliderUI for the given {@link\n+   * JComponent}, which should be a {@link JSlider}.\n+   *\n+   * @param b The {@link JComponent} a UI is being created for.\n+   *\n+   * @return A BasicSliderUI for the {@link JComponent}.\n+   */\n+  public static ComponentUI createUI(JComponent b)\n+  {\n+    return new BasicSliderUI((JSlider) b);\n+  }\n+\n+  /**\n+   * Installs and initializes all fields for this UI delegate. Any properties\n+   * of the UI that need to be initialized and/or set to defaults will be\n+   * done now. It will also install any listeners necessary.\n+   *\n+   * @param c The {@link JComponent} that is having this UI installed.\n+   */\n+  public void installUI(JComponent c)\n+  {\n+    super.installUI(c);\n+    if (c instanceof JSlider)\n+      {\n+\tslider = (JSlider) c;\n+\n+\tfocusRect = new Rectangle();\n+\tcontentRect = new Rectangle();\n+\tthumbRect = new Rectangle();\n+\ttrackRect = new Rectangle();\n+\ttickRect = new Rectangle();\n+\tlabelRect = new Rectangle();\n+\n+\tinsetCache = slider.getInsets();\n+\tleftToRightCache = ! slider.getInverted();\n+\n+\tscrollTimer = new Timer();\n+\tscrollTimer.setDelay(200);\n+\tscrollTimer.setRepeats(true);\n+\n+\tinstallDefaults(slider);\n+\tinstallListeners(slider);\n+\tinstallKeyboardActions(slider);\n+\n+\tcalculateFocusRect();\n+\n+\tcalculateContentRect();\n+\tcalculateThumbSize();\n+\tcalculateTrackBuffer();\n+\tcalculateTrackRect();\n+\tcalculateThumbLocation();\n+\n+\tcalculateTickRect();\n+\tcalculateLabelRect();\n+      }\n+  }\n+\n+  /**\n+   * Performs the opposite of installUI. Any properties or resources that need\n+   * to be cleaned up will be done now. It will also uninstall any listeners\n+   * it has. In addition, any properties of this UI will be nulled.\n+   *\n+   * @param c The {@link JComponent} that is having this UI uninstalled.\n+   */\n+  public void uninstallUI(JComponent c)\n+  {\n+    super.uninstallUI(c);\n+\n+    uninstallKeyboardActions(slider);\n+    uninstallListeners(slider);\n+\n+    scrollTimer = null;\n+\n+    focusRect = null;\n+    contentRect = null;\n+    thumbRect = null;\n+    trackRect = null;\n+    tickRect = null;\n+    labelRect = null;\n+\n+    focusInsets = null;\n+  }\n+\n+  /**\n+   * Initializes any default properties that this UI has from the defaults for\n+   * the Basic look and feel.\n+   *\n+   * @param slider The {@link JSlider} that is having this UI installed.\n+   */\n+  protected void installDefaults(JSlider slider)\n+  {\n+    UIDefaults defaults = UIManager.getLookAndFeelDefaults();\n+\n+    slider.setForeground(defaults.getColor(\"Slider.foreground\"));\n+    slider.setBackground(defaults.getColor(\"Slider.background\"));\n+    shadowColor = defaults.getColor(\"Slider.shadow\");\n+    highlightColor = defaults.getColor(\"Slider.highlight\");\n+    focusColor = defaults.getColor(\"Slider.focus\");\n+    slider.setBorder(defaults.getBorder(\"Slider.border\"));\n+\n+    thumbHeight = defaults.getInt(\"Slider.thumbHeight\");\n+    thumbWidth = defaults.getInt(\"Slider.thumbWidth\");\n+    tickHeight = defaults.getInt(\"Slider.tickHeight\");\n+\n+    focusInsets = defaults.getInsets(\"Slider.focusInsets\");\n+  }\n+\n+  /**\n+   * Creates a new {@link TrackListener}.\n+   *\n+   * @param slider The {@link JSlider} that this {@link TrackListener} is\n+   *        created for.\n+   *\n+   * @return A new {@link TrackListener}.\n+   */\n+  protected TrackListener createTrackListener(JSlider slider)\n+  {\n+    return new TrackListener();\n+  }\n+\n+  /**\n+   * Creates a new {@link ChangeListener}.\n+   *\n+   * @param slider The {@link JSlider} that this {@link ChangeListener} is\n+   *        created for.\n+   *\n+   * @return A new {@link ChangeListener}.\n+   */\n+  protected ChangeListener createChangeListener(JSlider slider)\n+  {\n+    return new ChangeHandler();\n+  }\n+\n+  /**\n+   * Creates a new {@link ComponentListener}.\n+   *\n+   * @param slider The {@link JSlider} that this {@link ComponentListener} is\n+   *        created for.\n+   *\n+   * @return A new {@link ComponentListener}.\n+   */\n+  protected ComponentListener createComponentListener(JSlider slider)\n+  {\n+    return new ComponentHandler();\n+  }\n+\n+  /**\n+   * Creates a new {@link FocusListener}.\n+   *\n+   * @param slider The {@link JSlider} that this {@link FocusListener} is\n+   *        created for.\n+   *\n+   * @return A new {@link FocusListener}.\n+   */\n+  protected FocusListener createFocusListener(JSlider slider)\n+  {\n+    return new FocusHandler();\n+  }\n+\n+  /**\n+   * Creates a new {@link ScrollListener}.\n+   *\n+   * @param slider The {@link JSlider} that this {@link ScrollListener} is\n+   *        created for.\n+   *\n+   * @return A new {@link ScrollListener}.\n+   */\n+  protected ScrollListener createScrollListener(JSlider slider)\n+  {\n+    return new ScrollListener();\n+  }\n+\n+  /**\n+   * Creates a new {@link PropertyChangeListener}.\n+   *\n+   * @param slider The {@link JSlider} that this {@link\n+   *        PropertyChangeListener} is created for.\n+   *\n+   * @return A new {@link PropertyChangeListener}.\n+   */\n+  protected PropertyChangeListener createPropertyChangeListener(JSlider slider)\n+  {\n+    return new PropertyChangeHandler();\n+  }\n+\n+  /**\n+   * Creates and registers all the listeners for this UI delegate. This\n+   * includes creating the ScrollListener and registering it to the timer.\n+   *\n+   * @param slider The {@link JSlider} is having listeners installed.\n+   */\n+  protected void installListeners(JSlider slider)\n+  {\n+    propertyChangeListener = createPropertyChangeListener(slider);\n+    componentListener = createComponentListener(slider);\n+    trackListener = createTrackListener(slider);\n+    focusListener = createFocusListener(slider);\n+    changeListener = createChangeListener(slider);\n+    scrollListener = createScrollListener(slider);\n+\n+    slider.addPropertyChangeListener(propertyChangeListener);\n+    slider.addComponentListener(componentListener);\n+    slider.addMouseListener(trackListener);\n+    slider.addMouseMotionListener(trackListener);\n+    slider.addFocusListener(focusListener);\n+    slider.getModel().addChangeListener(changeListener);\n+\n+    scrollTimer.addActionListener(scrollListener);\n+  }\n+\n+  /**\n+   * Unregisters all the listeners that this UI delegate was using. In\n+   * addition, it will also null any listeners that it was using.\n+   *\n+   * @param slider The {@link JSlider} that is having listeners removed.\n+   */\n+  protected void uninstallListeners(JSlider slider)\n+  {\n+    slider.removePropertyChangeListener(propertyChangeListener);\n+    slider.removeComponentListener(componentListener);\n+    slider.removeMouseListener(trackListener);\n+    slider.removeMouseMotionListener(trackListener);\n+    slider.removeFocusListener(focusListener);\n+    slider.getModel().removeChangeListener(changeListener);\n+\n+    scrollTimer.removeActionListener(scrollListener);\n+\n+    propertyChangeListener = null;\n+    componentListener = null;\n+    trackListener = null;\n+    focusListener = null;\n+    changeListener = null;\n+    scrollListener = null;\n+  }\n+\n+  /**\n+   * Installs any keyboard actions. The list of keys that need to be bound are\n+   * listed in Basic look and feel's defaults.\n+   *\n+   * @param slider The {@link JSlider} that is having keyboard actions\n+   *        installed.\n+   */\n+  protected void installKeyboardActions(JSlider slider)\n+  {\n+    // FIXME: implement.\n+  }\n+\n+  /**\n+   * Uninstalls any keyboard actions. The list of keys used  are listed in\n+   * Basic look and feel's defaults.\n+   *\n+   * @param slider The {@link JSlider} that is having keyboard actions\n+   *        uninstalled.\n+   */\n+  protected void uninstallKeyboardActions(JSlider slider)\n+  {\n+    // FIXME: implement.\n+  }\n+\n+  /* XXX: This is all after experimentation with SUN's implementation.\n+\n+     PreferredHorizontalSize seems to be 200x21.\n+     PreferredVerticalSize seems to be 21x200.\n+\n+     MinimumHorizontalSize seems to be 36x21.\n+     MinimumVerticalSize seems to be 21x36.\n+\n+     PreferredSize seems to be 200x63. Or Components.getBounds?\n+\n+     MinimumSize seems to be 36x63.\n+\n+     MaximumSize seems to be 32767x63.\n+   */\n+\n+  /**\n+   * This method returns the preferred size when the slider is\n+   * horizontally oriented.\n+   *\n+   * @return The dimensions of the preferred horizontal size.\n+   */\n+  public Dimension getPreferredHorizontalSize()\n+  {\n+    Insets insets = slider.getInsets();\n+    \n+    // The width should cover all the labels (which are usually the\n+    // deciding factor of the width)\n+    int width = getWidthOfWidestLabel() * (slider.getLabelTable() == null ? \n+                                           0 : slider.getLabelTable().size());\n+    \n+    // If there are not enough labels.\n+    // This number is pretty much arbitrary, but it looks nice.\n+    if (width < 200)\n+      width = 200;\n+    \n+    // We can only draw inside of the focusRectangle, so we have to\n+    // pad it with insets.\n+    width += insets.left + insets.right + focusInsets.left + \n+             focusInsets.right;\n+      \n+    // Height is determined by the thumb, the ticks and the labels.\n+    int height = thumbHeight;\n+\n+    if (slider.getPaintTicks() && slider.getMajorTickSpacing() > 0 ||\n+        slider.getMinorTickSpacing() > 0)\n+      height += tickHeight;\n+\n+    if (slider.getPaintLabels())\n+      height += getHeightOfTallestLabel();\n+    \n+    height += insets.top + insets.bottom + focusInsets.top + \n+              focusInsets.bottom;\n+\t      \n+    return new Dimension(width, height);\n+  }\n+\n+  /**\n+   * This method returns the preferred size when the slider is\n+   * vertically oriented.\n+   *\n+   * @return The dimensions of the preferred vertical size.\n+   */\n+  public Dimension getPreferredVerticalSize()\n+  {\n+    Insets insets = slider.getInsets();\n+    \n+    int height = getHeightOfTallestLabel() * (slider.getLabelTable() == null ? \n+                                              0 : slider.getLabelTable().size());\n+    \n+    if (height < 200)\n+      height = 200;\n+      \n+    height += insets.top + insets.bottom + focusInsets.top + \n+             focusInsets.bottom;\n+\n+    int width = thumbHeight;\n+    \n+    if (slider.getPaintTicks() && slider.getMajorTickSpacing() > 0 ||\n+        slider.getMinorTickSpacing() > 0)\n+      width += tickHeight;\n+\n+    if (slider.getPaintLabels())\n+      width += getWidthOfWidestLabel();\n+\n+    width += insets.left + insets.right + focusInsets.left + \n+             focusInsets.right;\n+\t     \n+    return new Dimension(width, height);\n+  }\n+\n+  /**\n+   * This method returns the minimum size when the slider is\n+   * horizontally oriented.\n+   *\n+   * @return The dimensions of the minimum horizontal size.\n+   */\n+  public Dimension getMinimumHorizontalSize()\n+  {\n+    return getPreferredHorizontalSize();\n+  }\n+\n+  /**\n+   * This method returns the minimum size of the slider when it \n+   * is vertically oriented.\n+   *\n+   * @return The dimensions of the minimum vertical size.\n+   */\n+  public Dimension getMinimumVerticalSize()\n+  {\n+    return getPreferredVerticalSize();\n+  }\n+\n+  /**\n+   * This method returns the preferred size of the component. If it returns\n+   * null, then it is up to the Layout Manager to give the {@link JComponent}\n+   * a size.\n+   *\n+   * @param c The {@link JComponent} to find the preferred size for.\n+   *\n+   * @return The dimensions of the preferred size.\n+   */\n+  public Dimension getPreferredSize(JComponent c)\n+  {   \n+    if (slider.getOrientation() == JSlider.HORIZONTAL)\n+      return getPreferredHorizontalSize();\n+    else\n+      return getPreferredVerticalSize();\n+  }\n+\n+  /**\n+   * This method returns the minimum size for this {@link JSlider}  for this\n+   * look and feel. If it returns null, then it is up to the Layout Manager\n+   * to give the {@link JComponent} a size.\n+   *\n+   * @param c The {@link JComponent} to find the minimum size for.\n+   *\n+   * @return The dimensions of the minimum size.\n+   */\n+  public Dimension getMinimumSize(JComponent c)\n+  {\n+    if (slider.getOrientation() == JSlider.HORIZONTAL)\n+      return getPreferredHorizontalSize();\n+    else\n+      return getPreferredVerticalSize();\n+  }\n+\n+  /**\n+   * This method returns the maximum size for this {@link JSlider} for this\n+   * look and feel. If it returns null, then it is up to the Layout Manager\n+   * to give the {@link JComponent} a size.\n+   *\n+   * @param c The {@link JComponent} to find a maximum size for.\n+   *\n+   * @return The dimensions of the maximum size.\n+   */\n+  public Dimension getMaximumSize(JComponent c)\n+  {\n+    if (slider.getOrientation() == JSlider.HORIZONTAL)\n+      return getPreferredHorizontalSize();\n+    else\n+      return getPreferredVerticalSize();\n+  }\n+  \n+  /**\n+   * This method calculates all the sizes of the rectangles by delegating\n+   * to the helper methods calculateXXXRect.\n+   */\n+   protected void calculateGeometry()\n+   {\n+     calculateFocusRect();\n+     calculateContentRect();\n+     calculateThumbSize();\n+     calculateTrackBuffer();\n+     calculateTrackRect();\n+     calculateTickRect();\n+     calculateLabelRect();\n+     calculateThumbLocation();\n+   }\n+\n+  /**\n+   * This method calculates the size and position of the focusRect. This\n+   * method does not need to be called if the orientation changes.\n+   */\n+  protected void calculateFocusRect()\n+  {\n+    insetCache = slider.getInsets();\n+    focusRect = SwingUtilities.calculateInnerArea(slider, focusRect);\n+\n+    if (focusRect.width < 0)\n+      focusRect.width = 0;\n+    if (focusRect.height < 0)\n+      focusRect.height = 0;\n+  }\n+\n+  /**\n+   * This method calculates the size but not the position of the thumbRect. It\n+   * must take into account the orientation of the slider.\n+   */\n+  protected void calculateThumbSize()\n+  {\n+    if (slider.getOrientation() == JSlider.HORIZONTAL)\n+      {\n+\tif (thumbWidth > contentRect.width)\n+\t  thumbRect.width = contentRect.width / 4;\n+\telse\n+\t  thumbRect.width = thumbWidth;\n+\tif (thumbHeight > contentRect.height)\n+\t  thumbRect.height = contentRect.height;\n+\telse\n+\t  thumbRect.height = thumbHeight;\n+      }\n+    else\n+      {\n+\t// The thumb gets flipped when inverted, so thumbWidth \n+\t// actually is the height and vice versa.\n+\tif (thumbWidth > contentRect.height)\n+\t  thumbRect.height = contentRect.height / 4;\n+\telse\n+\t  thumbRect.height = thumbWidth;\n+\tif (thumbHeight > contentRect.width)\n+\t  thumbRect.width = contentRect.width;\n+\telse\n+\t  thumbRect.width = thumbHeight;\n+      }\n+  }\n+\n+  /**\n+   * This method calculates the size and position of the contentRect. This\n+   * method does not need to be  called if the orientation changes.\n+   */\n+  protected void calculateContentRect()\n+  {\n+    contentRect.x = focusRect.x + focusInsets.left;\n+    contentRect.y = focusRect.y + focusInsets.top;\n+    contentRect.width = focusRect.width - focusInsets.left - focusInsets.right;\n+    contentRect.height = focusRect.height - focusInsets.top\n+                         - focusInsets.bottom;\n+\n+    if (contentRect.width < 0)\n+      contentRect.width = 0;\n+    if (contentRect.height < 0)\n+      contentRect.height = 0;\n+  }\n+\n+  /**\n+   * Calculates the position of the thumbRect based on the current value of\n+   * the slider. It must take into  account the orientation of the slider.\n+   */\n+  protected void calculateThumbLocation()\n+  {\n+    int value = slider.getValue();\n+\n+    if (slider.getOrientation() == JSlider.HORIZONTAL)\n+      {\n+\tthumbRect.x = xPositionForValue(value) - thumbRect.width / 2;\n+\tthumbRect.y = contentRect.y;\n+      }\n+    else\n+      {\n+\tthumbRect.x = contentRect.x;\n+\tthumbRect.y = yPositionForValue(value) - thumbRect.height / 2;\n+      }\n+  }\n+\n+  /**\n+   * Calculates the gap size between the left edge of the contentRect and the\n+   * left edge of the trackRect.\n+   */\n+  protected void calculateTrackBuffer()\n+  {\n+    if (slider.getOrientation() == JSlider.HORIZONTAL)\n+      trackBuffer = thumbRect.width;\n+    else\n+      trackBuffer = thumbRect.height;\n+  }\n+\n+  /**\n+   * This method returns the size of the thumbRect.\n+   *\n+   * @return The dimensions of the thumb.\n+   */\n+  protected Dimension getThumbSize()\n+  {\n+    // This is really just the bounds box for the thumb.\n+    // The thumb will actually be pointed (like a rectangle + triangle at bottom)\n+    return thumbRect.getSize();\n+  }\n+\n+  /**\n+   * Calculates the size and position of the trackRect. It must take into\n+   * account the orientation of the slider.\n+   */\n+  protected void calculateTrackRect()\n+  {\n+    if (slider.getOrientation() == JSlider.HORIZONTAL)\n+      {\n+\ttrackRect.x = contentRect.x + trackBuffer;\n+\ttrackRect.y = contentRect.y;\n+\ttrackRect.width = contentRect.width - 2 * trackBuffer;\n+\ttrackRect.height = thumbRect.height;\n+      }\n+    else\n+      {\n+\ttrackRect.x = contentRect.x;\n+\ttrackRect.y = contentRect.y + trackBuffer;\n+\ttrackRect.width = thumbRect.width;\n+\ttrackRect.height = contentRect.height - 2 * trackBuffer;\n+      }\n+  }\n+\n+  /**\n+   * This method returns the height of the tick area box if the slider  is\n+   * horizontal and the width of the tick area box is the slider is vertical.\n+   * It not necessarily how long the ticks will be. If a gap between the edge\n+   * of tick box and the actual tick is desired, then that will need to be\n+   * handled in the tick painting methods.\n+   *\n+   * @return The height (or width if the slider is vertical) of the tick\n+   *         rectangle.\n+   */\n+  protected int getTickLength()\n+  {\n+    return tickHeight;\n+  }\n+\n+  /**\n+   * This method calculates the size and position of the tickRect. It must\n+   * take into account the orientation of the slider.\n+   */\n+  protected void calculateTickRect()\n+  {\n+    if (slider.getOrientation() == JSlider.HORIZONTAL)\n+      {\n+\ttickRect.x = trackRect.x;\n+\ttickRect.y = trackRect.y + trackRect.height;\n+\ttickRect.width = trackRect.width;\n+\ttickRect.height = getTickLength();\n+\n+\tif (tickRect.y + tickRect.height > contentRect.y + contentRect.height)\n+\t  tickRect.height = contentRect.y + contentRect.height - tickRect.y;\n+      }\n+    else\n+      {\n+\ttickRect.x = trackRect.x + trackRect.width;\n+\ttickRect.y = trackRect.y;\n+\ttickRect.width = getTickLength();\n+\ttickRect.height = trackRect.height;\n+\n+\tif (tickRect.x + tickRect.width > contentRect.x + contentRect.width)\n+\t  tickRect.width = contentRect.x + contentRect.width - tickRect.x;\n+      }\n+  }\n+\n+  /**\n+   * This method calculates the size and position of the labelRect. It must\n+   * take into account the orientation of the slider.\n+   */\n+  protected void calculateLabelRect()\n+  {\n+    if (slider.getOrientation() == JSlider.HORIZONTAL)\n+      {\n+\tlabelRect.x = contentRect.x;\n+\tlabelRect.y = tickRect.y + tickRect.height;\n+\tlabelRect.width = contentRect.width;\n+\tlabelRect.height = contentRect.height - labelRect.y;\n+      }\n+    else\n+      {\n+\tlabelRect.x = tickRect.x + tickRect.width;\n+\tlabelRect.y = contentRect.y;\n+\tlabelRect.width = contentRect.width - labelRect.x;\n+\tlabelRect.height = contentRect.height;\n+      }\n+  }\n+\n+  /**\n+   * This method returns the width of the widest label  in the slider's label\n+   * table.\n+   *\n+   * @return The width of the widest label or 0 if no label table exists.\n+   */\n+  protected int getWidthOfWidestLabel()\n+  {\n+    int widest = 0;\n+    Component label;\n+\n+    if (slider.getLabelTable() == null)\n+      return 0;\n+\n+    for (Enumeration list = slider.getLabelTable().elements();\n+         list.hasMoreElements();)\n+      {\n+\tObject comp = list.nextElement();\n+\tif (! (comp instanceof Component))\n+\t  continue;\n+\tlabel = (Component) comp;\n+\tif (label.getWidth() > widest)\n+\t  widest = label.getWidth();\n+      }\n+    return widest;\n+  }\n+\n+  /**\n+   * This method returns the height of the tallest label in the slider's label\n+   * table.\n+   *\n+   * @return The height of the tallest label or 0 if no label table exists.\n+   */\n+  protected int getHeightOfTallestLabel()\n+  {\n+    int tallest = 0;\n+    Component label;\n+\n+    if (slider.getLabelTable() == null)\n+      return 0;\n+\n+    for (Enumeration list = slider.getLabelTable().elements();\n+         list.hasMoreElements();)\n+      {\n+\tObject comp = list.nextElement();\n+\tif (! (comp instanceof Component))\n+\t  continue;\n+\tlabel = (Component) comp;\n+\tif (label.getHeight() > tallest)\n+\t  tallest = label.getHeight();\n+      }\n+    return tallest;\n+  }\n+\n+  /**\n+   * This method returns the width of the label whose key has the highest\n+   * value.\n+   *\n+   * @return The width of the high value label or 0 if no label table exists.\n+   */\n+  protected int getWidthOfHighValueLabel()\n+  {\n+    Component highValueLabel = getHighestValueLabel();\n+    if (highValueLabel != null)\n+      return highValueLabel.getWidth();\n+    else\n+      return 0;\n+  }\n+\n+  /**\n+   * This method returns the width of the label whose key has the lowest\n+   * value.\n+   *\n+   * @return The width of the low value label or 0 if no label table exists.\n+   */\n+  protected int getWidthOfLowValueLabel()\n+  {\n+    Component lowValueLabel = getLowestValueLabel();\n+    if (lowValueLabel != null)\n+      return lowValueLabel.getWidth();\n+    else\n+      return 0;\n+  }\n+\n+  /**\n+   * This method returns the height of the label whose key has the highest\n+   * value.\n+   *\n+   * @return The height of the high value label or 0 if no label table exists.\n+   */\n+  protected int getHeightOfHighValueLabel()\n+  {\n+    Component highValueLabel = getHighestValueLabel();\n+    if (highValueLabel != null)\n+      return highValueLabel.getHeight();\n+    else\n+      return 0;\n+  }\n+\n+  /**\n+   * This method returns the height of the label whose key has the lowest\n+   * value.\n+   *\n+   * @return The height of the low value label or 0 if no label table exists.\n+   */\n+  protected int getHeightOfLowValueLabel()\n+  {\n+    Component lowValueLabel = getLowestValueLabel();\n+    if (lowValueLabel != null)\n+      return lowValueLabel.getHeight();\n+    else\n+      return 0;\n+  }\n+\n+  /**\n+   * This method returns whether the slider is to be drawn inverted.\n+   *\n+   * @return True is the slider is to be drawn inverted.\n+   */\n+  protected boolean drawInverted()\n+  {\n+    return ! (slider.getInverted() ^ leftToRightCache);\n+  }\n+\n+  /**\n+   * This method returns the label whose key has the lowest value.\n+   *\n+   * @return The low value label or null if no label table exists.\n+   */\n+  protected Component getLowestValueLabel()\n+  {\n+    Integer key = new Integer(Integer.MAX_VALUE);\n+    Integer tmpKey;\n+    Dictionary labelTable = slider.getLabelTable();\n+\n+    if (labelTable == null)\n+      return null;\n+\n+    for (Enumeration list = labelTable.keys(); list.hasMoreElements();)\n+      {\n+\tObject value = list.nextElement();\n+\tif (! (value instanceof Integer))\n+\t  continue;\n+\ttmpKey = (Integer) value;\n+\tif (tmpKey.intValue() < key.intValue())\n+\t  key = tmpKey;\n+      }\n+    Object comp = labelTable.get(key);\n+    if (! (comp instanceof Component))\n+      return null;\n+    return (Component) comp;\n+  }\n+\n+  /**\n+   * This method returns the label whose  key has the highest value.\n+   *\n+   * @return The high value label or null if no label table exists.\n+   */\n+  protected Component getHighestValueLabel()\n+  {\n+    Integer key = new Integer(Integer.MIN_VALUE);\n+    Integer tmpKey;\n+    Dictionary labelTable = slider.getLabelTable();\n+\n+    if (labelTable == null)\n+      return null;\n+\n+    for (Enumeration list = labelTable.keys(); list.hasMoreElements();)\n+      {\n+\tObject value = list.nextElement();\n+\tif (! (value instanceof Integer))\n+\t  continue;\n+\ttmpKey = (Integer) value;\n+\tif (tmpKey.intValue() > key.intValue())\n+\t  key = tmpKey;\n+      }\n+    Object comp = labelTable.get(key);\n+    if (! (comp instanceof Component))\n+      return null;\n+    return (Component) comp;\n+  }\n+\n+  /**\n+   * This method is used to paint the {@link JSlider}. It delegates all its\n+   * duties to the various paint methods like paintTicks(),  paintTrack(),\n+   * paintThumb(), etc.\n+   *\n+   * @param g The {@link Graphics} object to paint with.\n+   * @param c The {@link JComponent} that is being painted.\n+   */\n+  public void paint(Graphics g, JComponent c)\n+  {\n+    // FIXME: Move this to propertyChangeEvent handler, when we get those.\n+    leftToRightCache = slider.getComponentOrientation() != ComponentOrientation.RIGHT_TO_LEFT;\n+    // FIXME: This next line is only here because the above line is here.\n+    calculateThumbLocation();\n+    \n+    if (slider.getPaintTrack())\n+      paintTrack(g);\n+    if (slider.getPaintTicks())\n+      paintTicks(g);\n+    if (slider.getPaintLabels())\n+      paintLabels(g);\n+\n+    //FIXME: Paint focus.\n+    paintThumb(g);\n+  }\n+\n+  /**\n+   * This method recalculates any rectangles that need to be recalculated\n+   * after the insets of the component have changed.\n+   */\n+  protected void recalculateIfInsetsChanged()\n+  {\n+    // Examining a test program shows that either Sun calls private\n+    // methods that we don't know about, or these don't do anything.\n+    calculateFocusRect();\n+\n+    calculateContentRect();\n+    calculateThumbSize();\n+    calculateTrackBuffer();\n+    calculateTrackRect();\n+    calculateThumbLocation();\n+\n+    calculateTickRect();\n+    calculateLabelRect();\n+  }\n+\n+  /**\n+   * This method recalculates any rectangles that need to be recalculated\n+   * after the orientation of the slider changes.\n+   */\n+  protected void recalculateIfOrientationChanged()\n+  {\n+    // Examining a test program shows that either Sun calls private\n+    // methods that we don't know about, or these don't do anything.  \n+    calculateThumbSize();\n+    calculateTrackBuffer();\n+    calculateTrackRect();\n+    calculateThumbLocation();\n+\n+    calculateTickRect();\n+    calculateLabelRect();\n+  }\n+\n+  /**\n+   * This method is called during a repaint if the slider has focus. It draws\n+   * an outline of the  focusRect using the color returned by\n+   * getFocusColor().\n+   *\n+   * @param g The {@link Graphics} object to draw with.\n+   */\n+  public void paintFocus(Graphics g)\n+  {\n+    Color saved_color = g.getColor();\n+\n+    g.setColor(getFocusColor());\n+\n+    g.drawRect(focusRect.x, focusRect.y, focusRect.width, focusRect.height);\n+\n+    g.setColor(saved_color);\n+  }\n+\n+  /**\n+   * <p>\n+   * This method is called during a repaint if the  track is to be drawn. It\n+   * draws a 3D rectangle to  represent the track. The track is not the size\n+   * of the trackRect. The top and left edges of the track should be outlined\n+   * with the shadow color. The bottom and right edges should be outlined\n+   * with the highlight color.\n+   * </p>\n+   * <pre>\n+   *    a---d   \n+   *    |   |   \n+   *    |   |   a------------------------d\n+   *    |   |   |                        |\n+   *    |   |   b------------------------c\n+   *    |   |\n+   *    |   |   \n+   *    b---c\n+   * </pre>\n+   * \n+   * <p>\n+   * The b-a-d path needs to be drawn with the shadow color and the b-c-d path\n+   * needs to be drawn with the highlight color.\n+   * </p>\n+   *\n+   * @param g The {@link Graphics} object to draw with.\n+   */\n+  public void paintTrack(Graphics g)\n+  {\n+    Color saved_color = g.getColor();\n+    int width;\n+    int height;\n+\n+    Point a = new Point(trackRect.x, trackRect.y);\n+    Point b = new Point(a);\n+    Point c = new Point(a);\n+    Point d = new Point(a);\n+\n+    Polygon high;\n+    Polygon shadow;\n+\n+    if (slider.getOrientation() == JSlider.HORIZONTAL)\n+      {\n+\twidth = trackRect.width;\n+\theight = (thumbRect.height / 4 == 0) ? 1 : thumbRect.height / 4;\n+\n+\ta.translate(0, (trackRect.height / 2) - (height / 2));\n+\tb.translate(0, (trackRect.height / 2) + (height / 2));\n+\tc.translate(trackRect.width, (trackRect.height / 2) + (height / 2));\n+\td.translate(trackRect.width, (trackRect.height / 2) - (height / 2));\n+      }\n+    else\n+      {\n+\twidth = (thumbRect.width / 4 == 0) ? 1 : thumbRect.width / 4;\n+\theight = trackRect.height;\n+\n+\ta.translate((trackRect.width / 2) - (width / 2), 0);\n+\tb.translate((trackRect.width / 2) - (width / 2), trackRect.height);\n+\tc.translate((trackRect.width / 2) + (width / 2), trackRect.height);\n+\td.translate((trackRect.width / 2) + (width / 2), 0);\n+      }\n+    high = new Polygon(new int[] { b.x, c.x, d.x },\n+                       new int[] { b.y, c.y, d.y }, 3);\n+    shadow = new Polygon(new int[] { b.x, a.x, d.x },\n+                         new int[] { b.y, a.y, d.y }, 3);\n+\n+    g.setColor(getHighlightColor());\n+    g.drawPolygon(high);\n+    g.setColor(getShadowColor());\n+    g.drawPolygon(shadow);\n+\n+    g.setColor(Color.GRAY);\n+    g.fillRect(a.x + 1, a.y + 1, width - 2, height - 2);\n+    g.setColor(saved_color);\n+  }\n+\n+  /**\n+   * This method is called during a repaint if the ticks are to be drawn. This\n+   * method must still verify that the majorTickSpacing and minorTickSpacing\n+   * are greater than zero before drawing the ticks.\n+   *\n+   * @param g The {@link Graphics} object to draw with.\n+   */\n+  public void paintTicks(Graphics g)\n+  {\n+    int max = slider.getMaximum();\n+    int min = slider.getMinimum();\n+    int majorSpace = slider.getMajorTickSpacing();\n+    int minorSpace = slider.getMinorTickSpacing();\n+\n+    if (majorSpace > 0)\n+      {\n+\tif (slider.getOrientation() == JSlider.HORIZONTAL)\n+\t  {\n+\t    double loc = tickRect.x;\n+\t    double increment = (max == min) ? 0\n+\t                                 : majorSpace * (double) tickRect.width / (max\n+\t                                 - min);\n+\t    if (drawInverted())\n+\t      {\n+\t\tloc += tickRect.width;\n+\t\tincrement *= -1;\n+\t      }\n+\t    for (int i = min; i <= max; i += majorSpace)\n+\t      {\n+\t\tpaintMajorTickForHorizSlider(g, tickRect, (int) loc);\n+\t\tloc += increment;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    double loc = tickRect.height + tickRect.y;\n+\t    double increment = (max == min) ? 0\n+\t                                 : -majorSpace * (double) tickRect.height / (max\n+\t                                 - min);\n+\t    if (drawInverted())\n+\t      {\n+\t\tloc = tickRect.y;\n+\t\tincrement *= -1;\n+\t      }\n+\t    for (int i = min; i <= max; i += majorSpace)\n+\t      {\n+\t\tpaintMajorTickForVertSlider(g, tickRect, (int) loc);\n+\t\tloc += increment;\n+\t      }\n+\t  }\n+      }\n+    if (minorSpace > 0)\n+      {\n+\tif (slider.getOrientation() == JSlider.HORIZONTAL)\n+\t  {\n+\t    double loc = tickRect.x;\n+\t    double increment = (max == min) ? 0\n+\t                                 : minorSpace * (double) tickRect.width / (max\n+\t                                 - min);\n+\t    if (drawInverted())\n+\t      {\n+\t\tloc += tickRect.width;\n+\t\tincrement *= -1;\n+\t      }\n+\t    for (int i = min; i <= max; i += minorSpace)\n+\t      {\n+\t\tpaintMinorTickForHorizSlider(g, tickRect, (int) loc);\n+\t\tloc += increment;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    double loc = tickRect.height + tickRect.y;\n+\t    double increment = (max == min) ? 0\n+\t                                 : -minorSpace * (double) tickRect.height / (max\n+\t                                 - min);\n+\t    if (drawInverted())\n+\t      {\n+\t\tloc = tickRect.y;\n+\t\tincrement *= -1;\n+\t      }\n+\t    for (int i = min; i <= max; i += minorSpace)\n+\t      {\n+\t\tpaintMinorTickForVertSlider(g, tickRect, (int) loc);\n+\t\tloc += increment;\n+\t      }\n+\t  }\n+      }\n+  }\n+\n+  /* Minor ticks start at 1/4 of the height (or width) of the tickRect and extend\n+     to 1/2 of the tickRect.\n+\n+     Major ticks start at 1/4 of the height and extend to 3/4.\n+   */\n+\n+  /**\n+   * This method paints a minor tick for a horizontal slider at the given x\n+   * value. x represents the x coordinate to paint at.\n+   *\n+   * @param g The {@link Graphics} object to draw with.\n+   * @param tickBounds The tickRect rectangle.\n+   * @param x The x coordinate to draw the tick at.\n+   */\n+  protected void paintMinorTickForHorizSlider(Graphics g,\n+                                              Rectangle tickBounds, int x)\n+  {\n+    int y = tickRect.y + tickRect.height / 4;\n+\n+    g.drawLine(x, y, x, y + tickRect.height / 4);\n+  }\n+\n+  /**\n+   * This method paints a major tick for a horizontal slider at the given x\n+   * value. x represents the x coordinate to paint at.\n+   *\n+   * @param g The {@link Graphics} object to draw with.\n+   * @param tickBounds The tickRect rectangle.\n+   * @param x The x coordinate to draw the tick at.\n+   */\n+  protected void paintMajorTickForHorizSlider(Graphics g,\n+                                              Rectangle tickBounds, int x)\n+  {\n+    int y = tickRect.y + tickRect.height / 4;\n+\n+    g.drawLine(x, y, x, y + tickRect.height / 2);\n+  }\n+\n+  /**\n+   * This method paints a minor tick for a vertical slider at the given y\n+   * value. y represents the y coordinate to paint at.\n+   *\n+   * @param g The {@link Graphics} object to draw with.\n+   * @param tickBounds The tickRect rectangle.\n+   * @param y The y coordinate to draw the tick at.\n+   */\n+  protected void paintMinorTickForVertSlider(Graphics g, Rectangle tickBounds,\n+                                             int y)\n+  {\n+    int x = tickRect.x + tickRect.width / 4;\n+\n+    g.drawLine(x, y, x + tickRect.width / 4, y);\n+  }\n+\n+  /**\n+   * This method paints a major tick for a vertical slider at the given y\n+   * value. y represents the y coordinate to paint at.\n+   *\n+   * @param g The {@link Graphics} object to draw with.\n+   * @param tickBounds The tickRect rectangle.\n+   * @param y The y coordinate to draw the tick at.\n+   */\n+  protected void paintMajorTickForVertSlider(Graphics g, Rectangle tickBounds,\n+                                             int y)\n+  {\n+    int x = tickRect.x + tickRect.width / 4;\n+\n+    g.drawLine(x, y, x + tickRect.width / 2, y);\n+  }\n+\n+  /**\n+   * This method paints all the labels from the slider's label table. This\n+   * method must make sure that the label table is not null before painting\n+   * the labels. Each entry in the label table is a (integer, component)\n+   * pair. Every label is painted at the value of the integer.\n+   *\n+   * @param g The {@link Graphics} object to draw with.\n+   */\n+  public void paintLabels(Graphics g)\n+  {\n+    if (slider.getLabelTable() != null)\n+      {\n+\tDictionary table = slider.getLabelTable();\n+\tInteger tmpKey;\n+\tObject key;\n+\tObject element;\n+\tComponent label;\n+\tif (slider.getOrientation() == JSlider.HORIZONTAL)\n+\t  {\n+\t    for (Enumeration list = table.keys(); list.hasMoreElements();)\n+\t      {\n+\t\tkey = list.nextElement();\n+\t\tif (! (key instanceof Integer))\n+\t\t  continue;\n+\t\ttmpKey = (Integer) key;\n+\t\telement = table.get(tmpKey);\n+\t\t// We won't paint them if they're not\n+\t\t// JLabels so continue anyway\n+\t\tif (! (element instanceof JLabel))\n+\t\t  continue;\n+\t\tlabel = (Component) element;\n+\t\tpaintHorizontalLabel(g, tmpKey.intValue(), label);\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    for (Enumeration list = table.keys(); list.hasMoreElements();)\n+\t      {\n+\t\tkey = list.nextElement();\n+\t\tif (! (key instanceof Integer))\n+\t\t  continue;\n+\t\ttmpKey = (Integer) key;\n+\t\telement = table.get(tmpKey);\n+\t\t// We won't paint them if they're not\n+\t\t// JLabels so continue anyway\n+\t\tif (! (element instanceof JLabel))\n+\t\t  continue;\n+\t\tlabel = (Component) element;\n+\t\tpaintVerticalLabel(g, tmpKey.intValue(), label);\n+\t      }\n+\t  }\n+      }\n+  }\n+\n+  /**\n+   * This method paints the label on the horizontal slider at the value\n+   * specified. The value is not a coordinate. It is a value within the range\n+   * of the  slider. If the value is not within the range of the slider, this\n+   * method will do nothing. This method should not paint outside the\n+   * boundaries of the labelRect.\n+   *\n+   * @param g The {@link Graphics} object to draw with.\n+   * @param value The value to paint at.\n+   * @param label The label to paint.\n+   */\n+  protected void paintHorizontalLabel(Graphics g, int value, Component label)\n+  {\n+    // This relies on clipping working properly or we'll end up\n+    // painting all over the place. If our preferred size is ignored, then\n+    // the labels may not fit inside the slider's bounds. Rather than mucking \n+    // with font sizes and possible icon sizes, we'll set the bounds for\n+    // the label and let it get clipped.\n+\n+    Dimension dim = label.getPreferredSize();\n+    int w = (int) dim.getWidth();\n+    int h = (int) dim.getHeight();\n+    \n+    int max = slider.getMaximum();\n+    int min = slider.getMinimum();\n+\n+    if (value > max || value < min)\n+      return;\n+    \n+    //           value\n+    //             |\n+    //        ------------\n+    //        |          |\n+    //        |          |\n+    //        |          |\n+    //  The label must move w/2 to the right to fit directly under the value.\n+    \n+    \n+    int xpos = xPositionForValue(value) - w / 2;\n+    int ypos = labelRect.y;\n+\n+    // We want to center the label around the xPositionForValue\n+    // So we use xpos - w / 2. However, if value is min and the label \n+    // is large, we run the risk of going out of bounds. So we bring it back\n+    // to 0 if it becomes negative.\n+    if (xpos < 0)\n+      xpos = 0;\n+\n+    // If the label + starting x position is greater than\n+    // the x space in the label rectangle, we reset it to the largest\n+    // amount possible in the rectangle. This means ugliness.\n+    if (xpos + w > labelRect.x + labelRect.width)\n+      w = labelRect.x + labelRect.width - xpos;\n+\n+    // If the label is too tall. We reset it to the height of the label\n+    // rectangle.\n+    if (h > labelRect.height)\n+      h = labelRect.height;\n+\n+    label.setBounds(xpos, ypos, w, h);\n+    javax.swing.SwingUtilities.paintComponent(g, label, null, label.getBounds());\n+  }\n+\n+  /**\n+   * This method paints the label on the vertical slider at the value\n+   * specified. The value is not a coordinate. It is a value within the range\n+   * of the  slider. If the value is not within the range of the slider, this\n+   * method will do nothing. This method should not paint outside the\n+   * boundaries of the labelRect.\n+   *\n+   * @param g The {@link Graphics} object to draw with.\n+   * @param value The value to paint at.\n+   * @param label The label to paint.\n+   */\n+  protected void paintVerticalLabel(Graphics g, int value, Component label)\n+  {\n+    Dimension dim = label.getPreferredSize();\n+    int w = (int) dim.getWidth();\n+    int h = (int) dim.getHeight();\n+\n+    int max = slider.getMaximum();\n+    int min = slider.getMinimum();\n+\n+    if (value > max || value < min)\n+      return;\n+\n+    int xpos = labelRect.x;\n+    int ypos = yPositionForValue(value) - h / 2;\n+\n+    if (ypos < 0)\n+      ypos = 0;\n+\n+    if (ypos + h > labelRect.y + labelRect.height)\n+      h = labelRect.y + labelRect.height - ypos;\n+\n+    if (w > labelRect.width)\n+      w = labelRect.width;\n+\n+    label.setBounds(xpos, ypos, w, h);\n+    javax.swing.SwingUtilities.paintComponent(g, label, null, label.getBounds());\n+  }\n+\n+  /**\n+   * <p>\n+   * This method paints a thumb. There are two types of thumb:\n+   * </p>\n+   * <pre>\n+   *   Vertical         Horizontal\n+   *    a---b            a-----b\n+   *    |   |            |      \\\n+   *    e   c            |       c\n+   *     \\ /             |      /\n+   *      d              e-----d\n+   *  </pre>\n+   * \n+   * <p>\n+   * In the case of vertical thumbs, we highlight the path b-a-e-d and shadow\n+   * the path b-c-d. In the case of horizontal thumbs, we highlight the path\n+   * c-b-a-e and shadow the path c-d-e. In both cases we fill the path\n+   * a-b-c-d-e before shadows and highlights are drawn.\n+   * </p>\n+   *\n+   * @param g The graphics object to paint with\n+   */\n+  public void paintThumb(Graphics g)\n+  {\n+    Color saved_color = g.getColor();\n+\n+    Polygon thumb = new Polygon();\n+\n+    Point a = new Point(thumbRect.x, thumbRect.y);\n+    Point b = new Point(a);\n+    Point c = new Point(a);\n+    Point d = new Point(a);\n+    Point e = new Point(a);\n+\n+    Polygon bright;\n+    Polygon dark;\n+    Polygon all;\n+\n+    // This will be in X-dimension if the slider is inverted and y if it isn't.\t  \t  \n+    int turnPoint;\n+\n+    if (slider.getOrientation() == JSlider.HORIZONTAL)\n+      {\n+\tturnPoint = thumbRect.height * 3 / 4;\n+\n+\tb.translate(thumbRect.width, 0);\n+\tc.translate(thumbRect.width, turnPoint);\n+\td.translate(thumbRect.width / 2, thumbRect.height);\n+\te.translate(0, turnPoint);\n+\n+\tbright = new Polygon(new int[] { b.x, a.x, e.x, d.x },\n+\t                     new int[] { b.y, a.y, e.y, d.y }, 4);\n+\n+\tdark = new Polygon(new int[] { b.x, c.x, d.x },\n+\t                   new int[] { b.y, c.y, d.y }, 3);\n+\tall = new Polygon(new int[] { a.x + 1, b.x, c.x, d.x, e.x + 1 },\n+\t                  new int[] { a.y + 1, b.y + 1, c.y, d.y + 1, e.y }, 5);\n+      }\n+    else\n+      {\n+\tturnPoint = thumbRect.width * 3 / 4;\n+\n+\tb.translate(turnPoint, 0);\n+\tc.translate(thumbRect.width, thumbRect.height / 2);\n+\td.translate(turnPoint, thumbRect.height);\n+\te.translate(0, thumbRect.height);\n+\n+\tbright = new Polygon(new int[] { c.x, b.x, a.x, e.x },\n+\t                     new int[] { c.y, b.y, a.y, e.y }, 4);\n+\n+\tdark = new Polygon(new int[] { c.x, d.x, e.x + 1 },\n+\t                   new int[] { c.y, d.y, e.y }, 3);\n+\n+\tall = new Polygon(new int[] { a.x + 1, b.x, c.x - 1, d.x, e.x + 1 },\n+\t                  new int[] { a.y + 1, b.y + 1, c.y, d.y, e.y }, 5);\n+      }\n+\n+    g.setColor(Color.WHITE);\n+    g.drawPolygon(bright);\n+\n+    g.setColor(Color.BLACK);\n+    g.drawPolygon(dark);\n+\n+    g.setColor(Color.GRAY);\n+    g.fillPolygon(all);\n+\n+    g.setColor(saved_color);\n+  }\n+\n+  /**\n+   * This method sets the position of the thumbRect.\n+   *\n+   * @param x The new x position.\n+   * @param y The new y position.\n+   */\n+  public void setThumbLocation(int x, int y)\n+  {\n+    thumbRect.x = x;\n+    thumbRect.y = y;\n+  }\n+\n+  /**\n+   * This method is used to move the thumb one  block in the direction\n+   * specified. If the slider  snaps to ticks, this method is responsible for\n+   * snapping it to a tick after the thumb  has been moved.\n+   *\n+   * @param direction The direction to move in.\n+   */\n+  public void scrollByBlock(int direction)\n+  {\n+    // The direction is -1 for backwards and 1 for forwards.\n+    int unit = direction * (slider.getMaximum() - slider.getMinimum()) / 10;\n+\n+    int moveTo = slider.getValue() + unit;\n+\n+    if (slider.getSnapToTicks())\n+      moveTo = findClosestTick(moveTo);\n+\n+    slider.setValue(moveTo);\n+  }\n+\n+  /**\n+   * This method is used to move the thumb one unit in the direction\n+   * specified. If the slider snaps to ticks, this method is responsible for\n+   * snapping it to a tick after the thumb has been moved.\n+   *\n+   * @param direction The direction to move in.\n+   */\n+  public void scrollByUnit(int direction)\n+  {\n+    // The direction is -1 for backwards and 1 for forwards.\n+    int moveTo = slider.getValue() + direction;\n+\n+    if (slider.getSnapToTicks())\n+      moveTo = findClosestTick(moveTo);\n+\n+    slider.setValue(moveTo);\n+  }\n+\n+  /**\n+   * This method is called when there has been a click in the track and the\n+   * thumb needs to be scrolled  on regular intervals. This method is only\n+   * responsible  for starting the timer and not for stopping it.\n+   *\n+   * @param dir The direction to move in.\n+   */\n+  protected void scrollDueToClickInTrack(int dir)\n+  {\n+    scrollTimer.stop();\n+  \n+    scrollListener.setDirection(dir);\n+    scrollListener.setScrollByBlock(true);\n+\n+    scrollTimer.start();\n+  }\n+\n+  /**\n+   * This method returns the X coordinate for the value passed in.\n+   *\n+   * @param value The value to calculate an x coordinate for.\n+   *\n+   * @return The x coordinate for the value.\n+   */\n+  protected int xPositionForValue(int value)\n+  {\n+    int min = slider.getMinimum();\n+    int max = slider.getMaximum();\n+    int extent = slider.getExtent();\n+    int len = trackRect.width;\n+\n+    int xPos = (max == min) ? 0 : (value - min) * len / (max - min);\n+\n+    if (! drawInverted())\n+      xPos += trackRect.x;\n+    else\n+      {\n+\txPos = trackRect.width - xPos;\n+\txPos += trackRect.x;\n+      }\n+    return xPos;\n+  }\n+\n+  /**\n+   * This method returns the y coordinate for the value passed in.\n+   *\n+   * @param value The value to calculate a y coordinate for.\n+   *\n+   * @return The y coordinate for the value.\n+   */\n+  protected int yPositionForValue(int value)\n+  {\n+    int min = slider.getMinimum();\n+    int max = slider.getMaximum();\n+    int extent = slider.getExtent();\n+    int len = trackRect.height;\n+\n+    int yPos = (max == min) ? 0 : (value - min) * len / (max - min);\n+\n+    if (! drawInverted())\n+      {\n+\tyPos = trackRect.height - yPos;\n+\tyPos += trackRect.y;\n+      }\n+    else\n+      yPos += trackRect.y;\n+    return yPos;\n+  }\n+\n+  /**\n+   * This method returns the value in the slider's range given the y\n+   * coordinate. If the value is out of range, it will  return the closest\n+   * legal value.\n+   *\n+   * @param yPos The y coordinate to calculate a value for.\n+   *\n+   * @return The value for the y coordinate.\n+   */\n+  public int valueForYPosition(int yPos)\n+  {\n+    int min = slider.getMinimum();\n+    int max = slider.getMaximum();\n+    int len = trackRect.height;\n+\n+    int value;\n+\n+    // If the length is 0, you shouldn't be able to even see where the slider is.\n+    // This really shouldn't ever happen, but just in case, we'll return the middle.\n+    if (len == 0)\n+      return ((max - min) / 2);\n+\n+    if (! drawInverted())\n+      value = ((len - (yPos - trackRect.y)) * (max - min) / len + min);\n+    else\n+      value = ((yPos - trackRect.y) * (max - min) / len + min);\n+\n+    // If this isn't a legal value, then we'll have to move to one now.\n+    if (value > max)\n+      value = max;\n+    else if (value < min)\n+      value = min;\n+    return value;\n+  }\n+\n+  /**\n+   * This method returns the value in the slider's range given the x\n+   * coordinate. If the value is out of range, it will return the closest\n+   * legal value.\n+   *\n+   * @param xPos The x coordinate to calculate a value for.\n+   *\n+   * @return The value for the x coordinate.\n+   */\n+  public int valueForXPosition(int xPos)\n+  {\n+    int min = slider.getMinimum();\n+    int max = slider.getMaximum();\n+    int len = trackRect.width;\n+\n+    int value;\n+\n+    // If the length is 0, you shouldn't be able to even see where the slider is.\n+    // This really shouldn't ever happen, but just in case, we'll return the middle.\n+    if (len == 0)\n+      return ((max - min) / 2);\n+\n+    if (! drawInverted())\n+      value = ((xPos - trackRect.x) * (max - min) / len + min);\n+    else\n+      value = ((len - (xPos - trackRect.x)) * (max - min) / len + min);\n+\n+    // If this isn't a legal value, then we'll have to move to one now.\n+    if (value > max)\n+      value = max;\n+    else if (value < min)\n+      value = min;\n+    return value;\n+  }\n+\n+  /**\n+   * This method finds the closest value that has a tick associated with it.\n+   *\n+   * @param value The value to search from.\n+   *\n+   * @return The closest value that has a tick associated with it.\n+   */\n+  private int findClosestTick(int value)\n+  {\n+    int min = slider.getMinimum();\n+    int max = slider.getMaximum();\n+    int majorSpace = slider.getMajorTickSpacing();\n+    int minorSpace = slider.getMinorTickSpacing();\n+\n+    // The default value to return is value + minor or\n+    // value + major. \n+    // Initializing at min - value leaves us with a default\n+    // return value of min, which always has tick marks\n+    // (if ticks are painted).\n+    int minor = min - value;\n+    int major = min - value;\n+\n+    // If there are no major tick marks or minor tick marks \n+    // e.g. snap is set to true but no ticks are set, then\n+    // we can just return the value.\n+    if (majorSpace <= 0 && minorSpace <= 0)\n+      return value;\n+\n+    // First check the major ticks.\n+    if (majorSpace > 0)\n+      {\n+\tint lowerBound = (value - min) / majorSpace;\n+\tint majLower = majorSpace * lowerBound + min;\n+\tint majHigher = majorSpace * (lowerBound + 1) + min;\n+\n+\tif (majHigher <= max && majHigher - value <= value - majLower)\n+\t  major = majHigher - value;\n+\telse\n+\t  major = majLower - value;\n+      }\n+\n+    if (minorSpace > 0)\n+      {\n+\tint lowerBound = value / minorSpace;\n+\tint minLower = minorSpace * lowerBound;\n+\tint minHigher = minorSpace * (lowerBound + 1);\n+\n+\tif (minHigher <= max && minHigher - value <= value - minLower)\n+\t  minor = minHigher - value;\n+\telse\n+\t  minor = minLower - value;\n+      }\n+\n+    // Give preference to minor ticks\n+    if (Math.abs(minor) > Math.abs(major))\n+      return value + major;\n+    else\n+      return value + minor;\n+  }\n+}"}, {"sha": "62e51e114ee73c93d97f8be7edd715458af3acc7", "filename": "libjava/javax/swing/plaf/basic/BasicViewportUI.java", "status": "modified", "additions": 91, "deletions": 17, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicViewportUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicViewportUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicViewportUI.java?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -38,36 +38,110 @@\n \n package javax.swing.plaf.basic;\n \n+import java.awt.Component;\n import java.awt.Dimension;\n import java.awt.Graphics;\n+import java.awt.Image;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.image.ImageObserver;\n import javax.swing.JComponent;\n+import javax.swing.JViewport;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n import javax.swing.plaf.ComponentUI;\n import javax.swing.plaf.ViewportUI;\n \n public class BasicViewportUI extends ViewportUI \n {\n \n-    public static ComponentUI createUI(final JComponent c)\n+  ChangeListener changeListener;\n+  Image backingStoreImage;\n+  int backingStoreWidth = -1;\n+  int backingStoreHeight = -1;\n+  \n+  class ChangeHandler implements ChangeListener\n+  {\n+    public void stateChanged(ChangeEvent event)\n     {\n-\treturn new BasicViewportUI();\n+      JViewport v = (JViewport)event.source;\n+      v.repaint();\n     }\n+  }\n \n-    \n-    public void installUI(final JComponent c) \n-    {\n-\tsuper.installUI(c);\n-    }\n+  void installDefaults(JComponent c)\n+  {\n+  }\n+\n+  void uninstallDefaults(JComponent c)\n+  {\n+  }\n+\n+  void installListeners(JComponent c)\n+  {\n+    ((JViewport)c).addChangeListener(changeListener);\n+  }\n+\n+  void uninstallListeners(JComponent c)\n+  {\n+    ((JViewport)c).removeChangeListener(changeListener);\n+  }\n+\n+  public BasicViewportUI()\n+  {\n+    changeListener = new ChangeHandler();\n+  }\n+\n+  public static ComponentUI createUI(JComponent c)\n+  {\n+    return new BasicViewportUI();\n+  }\n+\n+  public void installUI(JComponent c) \n+  {\n+    super.installUI(c);\n+    installListeners(c);\n+  }\n+\n+  public void uninstallUI(JComponent c) \n+  {\n+    uninstallListeners(c);\n+  }\n     \n \n-    public Dimension getPreferredSize(JComponent c) \n-    {\n-\tDimension d = new Dimension(100,100);\n-\tSystem.out.println(\"BasicViewportUI->preff->\"+d);\n-\treturn d;\n-    }\n+  public Dimension getPreferredSize(JComponent c) \n+  {\n+    // FIXME: integrate with Scrollable\n+    Dimension d = new Dimension(100,100);\n+    return d;\n+  }\n \n-    public void paint(Graphics g, JComponent c)\n-    {      \n-\tSystem.out.println(\"BasicViewportUI->paint->\"+c);\n-    }\n+  public void paint(Graphics g, JComponent c)\n+  {      \n+\n+    JViewport v = (JViewport)c;\n+    Component view = v.getView();\n+\n+    if (view == null)\n+      return;\n+\n+    Point pos = v.getViewPosition();\n+    Rectangle viewBounds = view.getBounds();\n+\n+    if (backingStoreImage == null \n+        || backingStoreWidth != viewBounds.width\n+        || backingStoreHeight != viewBounds.height)\n+      {\n+        backingStoreImage = v.createImage(viewBounds.width, viewBounds.height);\n+        backingStoreWidth = viewBounds.width;\n+        backingStoreHeight = viewBounds.height;\n+      }\n+\n+    Graphics g2 = backingStoreImage.getGraphics();\n+    view.paint(g2);\n+    g2 = null;\n+    g.drawImage(backingStoreImage, \n+                -pos.x, -pos.y, \n+                (ImageObserver)null);\n+  }\n }"}, {"sha": "cc09102debd005961cda87a8c7e47fb3a1b36eb3", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkClasspathFontPeerMetrics.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkClasspathFontPeerMetrics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkClasspathFontPeerMetrics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkClasspathFontPeerMetrics.c?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -53,6 +53,7 @@ JNIEXPORT jintArray JNICALL Java_gnu_java_awt_peer_gtk_GdkClasspathFontPeerMetri\n   jintArray array;\n   jint *metrics;\n   struct peerfont *pf = NULL;\n+  FT_Matrix mat;\n \n   pf = NSA_GET_FONT_PTR(env, font);\n   g_assert (pf != NULL);\n@@ -62,14 +63,21 @@ JNIEXPORT jintArray JNICALL Java_gnu_java_awt_peer_gtk_GdkClasspathFontPeerMetri\n \n   gdk_threads_enter ();\n \n-#define DOUBLE_TO_26_6(d) ((FT_F26Dot6)((d) * 63.0))\n-#define DOUBLE_FROM_26_6(t) (((double)((t) >> 6)) \\\n-\t\t\t     + ((double)((t) & 0x3F) / 63.0))\n+#define DOUBLE_TO_26_6(d) ((FT_F26Dot6)((d) * 64.0))\n+#define DOUBLE_FROM_26_6(t) ((double)(t) / 64.0)\n+#define DOUBLE_TO_16_16(d) ((FT_Fixed)((d) * 65536.0))\n+#define DOUBLE_FROM_16_16(t) ((double)(t) / 65536.0)\n \n   double pointsize = pango_font_description_get_size (pf->desc);\n   pointsize /= (double) PANGO_SCALE;\n \n+  mat.xx = DOUBLE_TO_16_16(1);\n+  mat.xy = DOUBLE_TO_16_16(0);\n+  mat.yx = DOUBLE_TO_16_16(0);\n+  mat.yy = DOUBLE_TO_16_16(1);  \n+  \n   FT_Face face = pango_ft2_font_get_face (pf->font);  \n+  FT_Set_Transform(face, &mat, NULL);\n   FT_Set_Char_Size( face, \n \t\t    DOUBLE_TO_26_6 (pointsize),\n \t\t    DOUBLE_TO_26_6 (pointsize),"}, {"sha": "b05d76ecb5347e8fdede1fc17713c8c4ccfa6e8c", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGlyphVector.c", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGlyphVector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGlyphVector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGlyphVector.c?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -47,10 +47,11 @@ typedef struct {\n   double height;\n } rect_t;\n \n-#define DOUBLE_TO_26_6(d) ((FT_F26Dot6)((d) * 63.0))\n-#define DOUBLE_FROM_26_6(t) (((double)((t) >> 6)) \\\n-\t\t\t     + ((double)((t) & 0x3F) / 63.0))\n-\n+#define DOUBLE_TO_26_6(d) ((FT_F26Dot6)((d) * 64.0))\n+#define DOUBLE_FROM_26_6(t) ((double)(t) / 64.0)\n+#define DOUBLE_TO_16_16(d) ((FT_Fixed)((d) * 65536.0))\n+#define DOUBLE_FROM_16_16(t) ((double)(t) / 65536.0)\n+ \n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGlyphVector_initStaticState \n   (JNIEnv *env, jclass clazz)\n {\n@@ -401,6 +402,21 @@ JNIEXPORT jint JNICALL Java_gnu_java_awt_peer_gtk_GdkGlyphVector_glyphCharIndex\n   return idx;\n }\n \n+static void \n+assume_pointsize_and_identity_transform(double pointsize,\n+\t\t\t\t\tFT_Face face)\n+{\n+  FT_Matrix mat;\n+  mat.xx = DOUBLE_TO_16_16(1);\n+  mat.xy = DOUBLE_TO_16_16(0);\n+  mat.yx = DOUBLE_TO_16_16(0);\n+  mat.yy = DOUBLE_TO_16_16(1);    \n+  FT_Set_Transform(face, &mat, NULL);\n+  FT_Set_Char_Size( face, \n+\t\t    DOUBLE_TO_26_6 (pointsize),\n+\t\t    DOUBLE_TO_26_6 (pointsize),\n+\t\t    0, 0);  \n+}\t\t\t\t    \n \n JNIEXPORT jdoubleArray JNICALL Java_gnu_java_awt_peer_gtk_GdkGlyphVector_allInkExtents \n   (JNIEnv *env, jobject self)\n@@ -432,10 +448,7 @@ JNIEXPORT jdoubleArray JNICALL Java_gnu_java_awt_peer_gtk_GdkGlyphVector_allInkE\n       g_assert (gi->glyphs != NULL);\n \n       face = pango_ft2_font_get_face (gi->item->analysis.font);\n-      FT_Set_Char_Size( face, \n-\t\t\tDOUBLE_TO_26_6 (pointsize),\n-\t\t\tDOUBLE_TO_26_6 (pointsize),\n-\t\t\t0, 0);\n+      assume_pointsize_and_identity_transform (pointsize, face);\n       \n       for (j = 0; j < gi->glyphs->num_glyphs; ++j)\n \t{\n@@ -487,10 +500,7 @@ JNIEXPORT jdoubleArray JNICALL Java_gnu_java_awt_peer_gtk_GdkGlyphVector_allLogi\n       g_assert (gi->glyphs != NULL);\n \n       face = pango_ft2_font_get_face (gi->item->analysis.font);\n-      FT_Set_Char_Size( face, \n-\t\t\tDOUBLE_TO_26_6 (pointsize),\n-\t\t\tDOUBLE_TO_26_6 (pointsize),\n-\t\t\t0, 0);\n+      assume_pointsize_and_identity_transform (pointsize, face);\n       \n       for (j = 0; j < gi->glyphs->num_glyphs; ++j)\n \t{\n@@ -541,11 +551,9 @@ JNIEXPORT jdoubleArray JNICALL Java_gnu_java_awt_peer_gtk_GdkGlyphVector_glyphLo\n   pointsize = pango_font_description_get_size (vec->desc);\n   pointsize /= (double) PANGO_SCALE;\n   face = pango_ft2_font_get_face (font);\n-  FT_Set_Char_Size( face, \n-\t\t    DOUBLE_TO_26_6 (pointsize),\n-\t\t    DOUBLE_TO_26_6 (pointsize),\n-\t\t    0, 0);\n-  \n+\n+  assume_pointsize_and_identity_transform (pointsize, face);  \n+\n   FT_Load_Glyph (face, gi->glyph, FT_LOAD_DEFAULT);\n \n   /* FIXME: this is probably not the correct set of metrics;\n@@ -588,10 +596,8 @@ JNIEXPORT jdoubleArray JNICALL Java_gnu_java_awt_peer_gtk_GdkGlyphVector_glyphIn\n   pointsize = pango_font_description_get_size (vec->desc);\n   pointsize /= (double) PANGO_SCALE;\n   face = pango_ft2_font_get_face (font);\n-  FT_Set_Char_Size( face, \n-\t\t    DOUBLE_TO_26_6 (pointsize),\n-\t\t    DOUBLE_TO_26_6 (pointsize),\n-\t\t    0, 0);\n+\n+  assume_pointsize_and_identity_transform (pointsize, face);  \n   \n   FT_Load_Glyph (face, gi->glyph, FT_LOAD_DEFAULT);\n   /* FIXME: this needs to change for vertical layouts */"}, {"sha": "9c370e936cc95fa1bb84e89cd3cb09de86559376", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics.c?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -188,7 +188,7 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics_translateNative\n \n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics_drawString\n   (JNIEnv *env, jobject obj, jstring str, jint x, jint y, \n-   jstring fname, jint size)\n+   jstring fname, jint style, jint size)\n {\n   struct graphics *g;\n   const char *cstr;\n@@ -209,6 +209,12 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics_drawString\n   font_desc = pango_font_description_from_string (font_name);\n   pango_font_description_set_size (font_desc, size * PANGO_SCALE);\n \n+  if (style & AWT_STYLE_BOLD)\n+    pango_font_description_set_weight (font_desc, PANGO_WEIGHT_BOLD);\n+\n+  if (style & AWT_STYLE_ITALIC)\n+    pango_font_description_set_style (font_desc, PANGO_STYLE_OBLIQUE);\n+\n   context = gdk_pango_context_get();\n   pango_context_set_font_description (context, font_desc);\n "}, {"sha": "f8ee342a033aa52ccac8dd52b755a26e4731d18e", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics2D.c", "status": "modified", "additions": 102, "deletions": 14, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics2D.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics2D.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics2D.c?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -114,6 +114,15 @@ enum java_awt_geom_path_iterator_winding_rule\n     java_awt_geom_path_iterator_WIND_NON_ZERO = 1\n   };\n \n+enum java_awt_rendering_hints_filter\n+  {\n+    java_awt_rendering_hints_VALUE_INTERPOLATION_NEAREST_NEIGHBOR = 0,    \n+    java_awt_rendering_hints_VALUE_INTERPOLATION_BILINEAR = 1,\n+    java_awt_rendering_hints_VALUE_ALPHA_INTERPOLATION_SPEED = 2,\n+    java_awt_rendering_hints_VALUE_ALPHA_INTERPOLATION_QUALITY = 3,\n+    java_awt_rendering_hints_VALUE_ALPHA_INTERPOLATION_DEFAULT = 4\n+ \n+  };\n \n static void \n grab_current_drawable (GtkWidget *widget, GdkDrawable **draw, GdkWindow **win)\n@@ -683,21 +692,8 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_drawPixels\n \t\t\t    native_matrix[2], native_matrix[3],\n \t\t\t    native_matrix[4], native_matrix[5]);\n    cairo_surface_set_matrix (surf, mat);\n-   if (native_matrix[0] != 1.\n-       || native_matrix[1] != 0.\n-       || native_matrix[2] != 0.\n-       || native_matrix[3] != 1.)\n-     {\n-       cairo_surface_set_filter (surf, CAIRO_FILTER_BILINEAR);\n-       cairo_surface_set_filter (gr->surface, CAIRO_FILTER_BILINEAR);\n-     }\n-   else\n-     {\n-       cairo_surface_set_filter (surf, CAIRO_FILTER_FAST);\n-       cairo_surface_set_filter (gr->surface, CAIRO_FILTER_FAST);\n-     }\n+   cairo_surface_set_filter (surf, cairo_surface_get_filter(gr->surface));\n    cairo_show_surface (gr->cr, surf, w, h);\n-   cairo_surface_set_filter (gr->surface, CAIRO_FILTER_FAST);\n    cairo_matrix_destroy (mat);\n    cairo_surface_destroy (surf);\n  }\n@@ -709,6 +705,71 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_drawPixels\n \n }\n \n+JNIEXPORT jintArray JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_getImagePixels \n+   (JNIEnv *env, jobject obj)\n+{\n+  struct graphics2d *gr = NULL;\n+  jintArray java_pixels;\n+  jint* native_pixels;\n+  GdkPixbuf *buf = NULL;\n+  gint width, height;\n+  gint bits_per_sample = 8;\n+  gboolean has_alpha = TRUE;\n+  gint total_channels = 4;\n+  jint i, px;\n+\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+  \n+  if (gr->debug) printf (\"getImagePixels\\n\");\n+  \n+  gdk_drawable_get_size (gr->drawable, &width, &height);\n+    \n+  buf = gdk_pixbuf_new (GDK_COLORSPACE_RGB, has_alpha, \n+                        bits_per_sample,\n+                        width, height);\n+  g_assert (buf != NULL);\n+  g_assert (gdk_pixbuf_get_bits_per_sample (buf) == bits_per_sample);\n+  g_assert (gdk_pixbuf_get_n_channels (buf) == total_channels);\n+  \n+      \n+  /* copy pixels from drawable to pixbuf */\n+  \n+  gdk_pixbuf_get_from_drawable (buf, gr->drawable,\n+                                NULL, \n+                                0, 0, 0, 0,\n+                                width, height);\n+ \t\t\t\t\t\t\t\t      \t\t\t\t      \n+  native_pixels= gdk_pixbuf_get_pixels (buf);\n+  \n+     \n+  /* NOTE: The pixels we got in the pixbuf are stored \n+     in reversed order. i.e 0xBBGGRRAA. \n+     We need to convert them to  0xAARRGGBB. */\n+   \n+  for (i=0; i<width * height; i++) \n+    {\t     \n+  \t      \n+        /* convert pixels from 0xBBGGRRAA to 0xAARRGGBB */\n+        \n+        px = native_pixels[i];\n+        px = ((px >> 24) & 0xff) | ((px << 8) & 0xffffff00); \n+        px = ((px >>  8) & 0x00ff00ff) | ((px <<  8) & 0xff00ff00); \n+        px = ((px >> 16) & 0x0000ffff) | ((px << 16) & 0xffff0000); \n+        native_pixels[i] = px;\n+      \n+    }\n+\n+   java_pixels = (*env) -> NewIntArray (env, width * height);   \n+   \n+   (*env)->SetIntArrayRegion(env, java_pixels, \n+                            (jsize)0, (jsize) width*height, \n+                            (jint*) native_pixels);\n+   \n+   return java_pixels;\n+  \n+}\n+\n /* passthrough methods to cairo */\n \n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoSave \n@@ -1157,3 +1218,30 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoClip\n   cairo_clip (gr->cr);\n }\n \n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoSurfaceSetFilter\n+   (JNIEnv *env, jobject obj, jint filter)\n+{\n+\n+   struct graphics2d *gr = NULL;   \n+   gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+   g_assert (gr != NULL);\n+   if (gr->debug) printf (\"cairo_surface_set_filter %d\\n\", filter);   \n+   switch ((enum java_awt_rendering_hints_filter) filter)\n+     {\n+     case java_awt_rendering_hints_VALUE_INTERPOLATION_NEAREST_NEIGHBOR:\n+       cairo_surface_set_filter (gr->surface, CAIRO_FILTER_NEAREST);\n+       break;\n+     case java_awt_rendering_hints_VALUE_INTERPOLATION_BILINEAR:\n+       cairo_surface_set_filter (gr->surface, CAIRO_FILTER_BILINEAR);\n+       break; \n+     case java_awt_rendering_hints_VALUE_ALPHA_INTERPOLATION_SPEED:\n+       cairo_surface_set_filter (gr->surface, CAIRO_FILTER_FAST);\n+       break;\n+     case java_awt_rendering_hints_VALUE_ALPHA_INTERPOLATION_DEFAULT:\n+       cairo_surface_set_filter (gr->surface, CAIRO_FILTER_NEAREST);\n+       break;\n+     case java_awt_rendering_hints_VALUE_ALPHA_INTERPOLATION_QUALITY:\n+       cairo_surface_set_filter (gr->surface, CAIRO_FILTER_BEST);\n+       break;\n+     }\n+}"}, {"sha": "b0582cbe57b6075edde4bf739b39d733c3b54dbe", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkCheckboxPeer.c", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkCheckboxPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkCheckboxPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkCheckboxPeer.c?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -164,6 +164,69 @@ Java_gnu_java_awt_peer_gtk_GtkCheckboxPeer_nativeSetCheckboxGroup\n     NSA_SET_PTR (env, group, native_group);\n }\n \n+JNIEXPORT void JNICALL\n+Java_gnu_java_awt_peer_gtk_GtkCheckboxPeer_gtkSetFont\n+  (JNIEnv *env, jobject obj, jstring name, jint style, jint size)\n+{\n+  const char *font_name;\n+  void *ptr;\n+  GtkWidget *button;\n+  GtkWidget *label;\n+  PangoFontDescription *font_desc;\n+\n+  ptr = NSA_GET_PTR (env, obj);\n+\n+  button = GTK_WIDGET (ptr);\n+  label = gtk_bin_get_child (GTK_BIN(button));\n+\n+  if (!label)\n+      return;\n+\n+  font_name = (*env)->GetStringUTFChars (env, name, NULL);\n+\n+  gdk_threads_enter();\n+\n+  font_desc = pango_font_description_from_string (font_name);\n+  pango_font_description_set_size (font_desc, size * PANGO_SCALE);\n+\n+  if (style & AWT_STYLE_BOLD)\n+    pango_font_description_set_weight (font_desc, PANGO_WEIGHT_BOLD);\n+\n+  if (style & AWT_STYLE_ITALIC)\n+    pango_font_description_set_style (font_desc, PANGO_STYLE_OBLIQUE);\n+  \n+  gtk_widget_modify_font (GTK_WIDGET(label), font_desc);\n+  \n+  pango_font_description_free (font_desc);\n+  \n+  gdk_threads_leave();\n+  \n+  (*env)->ReleaseStringUTFChars (env, name, font_name);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_gnu_java_awt_peer_gtk_GtkCheckboxPeer_gtkSetLabel\n+  (JNIEnv *env, jobject obj, jstring label)\n+{\n+  const char *str;\n+  void *ptr;\n+  GtkWidget *label_widget;\n+\n+  ptr = NSA_GET_PTR (env, obj);\n+\n+  label_widget = gtk_bin_get_child (GTK_BIN(ptr));\n+\n+  str = (*env)->GetStringUTFChars (env, label, 0);\n+\n+  gdk_threads_enter ();\n+\n+  gtk_label_set_label (GTK_LABEL (label_widget), str);\n+\n+  gdk_threads_leave ();\n+\n+  (*env)->ReleaseStringUTFChars (env, label, str);\n+}\n+\n static void\n item_toggled (GtkToggleButton *item, jobject peer)\n {"}, {"sha": "3bb957c92ac6d6824570e3e255c8b828bfa39a4d", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.c?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -260,11 +260,11 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkComponentPeer_setNativeBoun\n   widget = GTK_WIDGET (ptr);\n   if (GTK_IS_VIEWPORT (widget->parent))\n     {\n-      gtk_widget_set_usize (widget, width, height);\n+      gtk_widget_set_size_request (widget, width, height);\n     }\n   else\n     {\n-      gtk_widget_set_usize (widget, width, height);\n+      gtk_widget_set_size_request (widget, width, height);\n       gtk_layout_move (GTK_LAYOUT (widget->parent), widget, x, y);\n     }\n \n@@ -380,6 +380,39 @@ Java_gnu_java_awt_peer_gtk_GtkComponentPeer_gtkWidgetSetForeground\n   gdk_threads_leave ();\n }\n \n+JNIEXPORT void JNICALL\n+Java_gnu_java_awt_peer_gtk_GtkComponentPeer_gtkSetFont\n+  (JNIEnv *env, jobject obj, jstring name, jint style, jint size)\n+{\n+  const char *font_name;\n+  void *ptr;\n+  GtkWidget *label;\n+  PangoFontDescription *font_desc;\n+\n+  ptr = NSA_GET_PTR (env, obj);\n+\n+  font_name = (*env)->GetStringUTFChars (env, name, NULL);\n+\n+  gdk_threads_enter();\n+\n+  font_desc = pango_font_description_from_string (font_name);\n+  pango_font_description_set_size (font_desc, size * PANGO_SCALE);\n+\n+  if (style & AWT_STYLE_BOLD)\n+    pango_font_description_set_weight (font_desc, PANGO_WEIGHT_BOLD);\n+\n+  if (style & AWT_STYLE_ITALIC)\n+    pango_font_description_set_style (font_desc, PANGO_STYLE_OBLIQUE);\n+\n+  gtk_widget_modify_font (GTK_WIDGET(ptr), font_desc);\n+\n+  pango_font_description_free (font_desc);\n+\n+  gdk_threads_leave();\n+\n+  (*env)->ReleaseStringUTFChars (env, name, font_name);\n+}\n+\n void\n set_visible (GtkWidget *widget, jboolean visible)\n {"}, {"sha": "95f730111869f93e29ea95edd0f961f831db35ee", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkEvents.c", "status": "modified", "additions": 41, "deletions": 15, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkEvents.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkEvents.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkEvents.c?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -83,6 +83,27 @@ state_to_awt_mods (guint state)\n   return result;\n }\n \n+static jint\n+state_to_awt_mods_with_button_states (guint state)\n+{\n+  jint result = 0;\n+\n+  if (state & GDK_SHIFT_MASK)\n+    result |= AWT_SHIFT_MASK;\n+  if (state & GDK_CONTROL_MASK)\n+    result |= AWT_CTRL_MASK;\n+  if (state & GDK_MOD1_MASK)\n+    result |= AWT_ALT_MASK;\n+  if (state & GDK_BUTTON1_MASK)\n+    result |= AWT_BUTTON1_MASK;\n+  if (state & GDK_BUTTON2_MASK)\n+    result |= AWT_BUTTON2_MASK;\n+  if (state & GDK_BUTTON3_MASK)\n+    result |= AWT_BUTTON3_MASK;\n+\n+  return result;\n+}\n+\n /* Modifier key events need special treatment.  In Sun's peer\n    implementation, when a modifier key is pressed, the KEY_PRESSED\n    event has that modifier in its modifiers list.  The corresponding\n@@ -830,6 +851,7 @@ pre_event_handler (GtkWidget *widget, GdkEvent *event, jobject peer)\n   static GdkWindow *button_window = NULL;\n   static guint button_number = -1;\n   static jint click_count = 1;\n+  static int hasBeenDragged;\n \n   /* If it is not a focus change event, the widget must be realized already.\n      If not, ignore the event (Gtk+ will do the same). */\n@@ -895,6 +917,7 @@ pre_event_handler (GtkWidget *widget, GdkEvent *event, jobject peer)\n \t\t\t\t  click_count, \n \t\t\t\t  (event->button.button == 3) ? JNI_TRUE :\n \t\t\t\t                                JNI_FALSE);\n+      hasBeenDragged = FALSE;\n       break;\n     case GDK_BUTTON_RELEASE:\n       {\n@@ -911,10 +934,12 @@ pre_event_handler (GtkWidget *widget, GdkEvent *event, jobject peer)\n \t\t\t\t    click_count,\n \t\t\t\t    JNI_FALSE);\n \n-\t/* check to see if the release occured in the window it was pressed\n-\t   in, and if so, generate an AWT click event */\n+\t// Generate an AWT click event only if the release occured in the\n+\t// window it was pressed in, and the mouse has not been dragged since\n+\t// the last time it was pressed.\n \tgdk_window_get_size (event->any.window, &width, &height);\n-\tif (event->button.x >= 0\n+\tif (! hasBeenDragged\n+\t    && event->button.x >= 0\n             && event->button.y >= 0\n \t    && event->button.x <= width \n \t    && event->button.y <= height)\n@@ -933,15 +958,6 @@ pre_event_handler (GtkWidget *widget, GdkEvent *event, jobject peer)\n       }\n       break;\n     case GDK_MOTION_NOTIFY:\n-      (*gdk_env)->CallVoidMethod (gdk_env, peer, postMouseEventID,\n-\t\t\t\t  AWT_MOUSE_MOVED,\n-\t\t\t\t  (jlong)event->motion.time,\n-\t\t\t\t  state_to_awt_mods (event->motion.state),\n-\t\t\t\t  (jint)event->motion.x,\n-\t\t\t\t  (jint)event->motion.y,\n-\t\t\t\t  0,\n-\t\t\t\t  JNI_FALSE);\n-\n       if (event->motion.state & (GDK_BUTTON1_MASK\n \t\t\t\t | GDK_BUTTON2_MASK\n \t\t\t\t | GDK_BUTTON3_MASK\n@@ -952,12 +968,22 @@ pre_event_handler (GtkWidget *widget, GdkEvent *event, jobject peer)\n \t\t\t              postMouseEventID,\n \t\t\t\t      AWT_MOUSE_DRAGGED,\n \t\t\t\t      (jlong)event->motion.time,\n-\t\t\t\t      state_to_awt_mods (event->motion.state),\n+\t\t\t\t      state_to_awt_mods_with_button_states (event->motion.state),\n \t\t\t\t      (jint)event->motion.x,\n \t\t\t\t      (jint)event->motion.y,\n \t\t\t\t      0,\n \t\t\t\t      JNI_FALSE);\n+\t  hasBeenDragged = TRUE;\n \t}\n+      else\n+        (*gdk_env)->CallVoidMethod (gdk_env, peer, postMouseEventID,\n+\t\t\t\t    AWT_MOUSE_MOVED,\n+\t\t\t\t    (jlong)event->motion.time,\n+\t\t\t\t    state_to_awt_mods (event->motion.state),\n+\t\t\t\t    (jint)event->motion.x,\n+\t\t\t\t    (jint)event->motion.y,\n+\t\t\t\t    0,\n+\t\t\t\t    JNI_FALSE);\n       break;\n     case GDK_ENTER_NOTIFY:\n       /* We are not interested in enter events that are due to\n@@ -966,7 +992,7 @@ pre_event_handler (GtkWidget *widget, GdkEvent *event, jobject peer)\n         (*gdk_env)->CallVoidMethod (gdk_env, peer, postMouseEventID,\n \t\t\t\t    AWT_MOUSE_ENTERED, \n \t\t\t\t    (jlong)event->crossing.time,\n-\t\t\t\t    state_to_awt_mods (event->crossing.state), \n+\t\t\t\t    state_to_awt_mods_with_button_states (event->crossing.state), \n \t\t\t\t    (jint)event->crossing.x,\n \t\t\t\t    (jint)event->crossing.y, \n \t\t\t\t    0,\n@@ -980,7 +1006,7 @@ pre_event_handler (GtkWidget *widget, GdkEvent *event, jobject peer)\n \t\t\t\t    postMouseEventID,\n \t\t\t\t    AWT_MOUSE_EXITED, \n \t\t\t\t    (jlong)event->crossing.time,\n-\t\t\t\t    state_to_awt_mods (event->crossing.state),\n+\t\t\t\t    state_to_awt_mods_with_button_states (event->crossing.state),\n \t\t\t\t    (jint)event->crossing.x,\n \t\t\t\t    (jint)event->crossing.y, \n \t\t\t\t    0,"}, {"sha": "c5848baa130e371e2c2d74564a7ef8207d1e29d1", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkLabelPeer.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkLabelPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkLabelPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkLabelPeer.c?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -69,6 +69,44 @@ Java_gnu_java_awt_peer_gtk_GtkLabelPeer_create\n   NSA_SET_PTR (env, obj, ebox);\n }\n \n+JNIEXPORT void JNICALL\n+Java_gnu_java_awt_peer_gtk_GtkLabelPeer_gtkSetFont\n+  (JNIEnv *env, jobject obj, jstring name, jint style, jint size)\n+{\n+  const char *font_name;\n+  void *ptr;\n+  GtkWidget *label;\n+  PangoFontDescription *font_desc;\n+\n+  ptr = NSA_GET_PTR (env, obj);\n+\n+  label = gtk_bin_get_child (GTK_BIN(ptr));\n+\n+  if (!label)\n+      return;\n+\n+  font_name = (*env)->GetStringUTFChars (env, name, NULL);\n+\n+  gdk_threads_enter();\n+\n+  font_desc = pango_font_description_from_string (font_name);\n+  pango_font_description_set_size (font_desc, size * PANGO_SCALE);\n+\n+  if (style & AWT_STYLE_BOLD)\n+    pango_font_description_set_weight (font_desc, PANGO_WEIGHT_BOLD);\n+\n+  if (style & AWT_STYLE_ITALIC)\n+    pango_font_description_set_style (font_desc, PANGO_STYLE_OBLIQUE);\n+\n+  gtk_widget_modify_font (GTK_WIDGET(label), font_desc);\n+\n+  pango_font_description_free (font_desc);\n+\n+  gdk_threads_leave();\n+\n+  (*env)->ReleaseStringUTFChars (env, name, font_name);\n+}\n+\n JNIEXPORT void JNICALL\n Java_gnu_java_awt_peer_gtk_GtkLabelPeer_setText\n   (JNIEnv *env, jobject obj, jstring text)"}, {"sha": "80d9d5bfb1be7730cc359ae6d68e8f3c2e05f046", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkWindowPeer.c", "status": "modified", "additions": 68, "deletions": 44, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkWindowPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkWindowPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkWindowPeer.c?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -44,6 +44,12 @@ exception statement from your version. */\n #include <gdk/gdkx.h>\n #include <X11/Xatom.h>\n \n+static int filter_added = 0;\n+\n+static GdkFilterReturn window_wm_protocols_filter (GdkXEvent *xev,\n+                                                   GdkEvent  *event,\n+                                                   gpointer   data);\n+\n static void window_get_frame_extents (GtkWidget *window,\n                                       int *top, int *left,\n                                       int *bottom, int *right);\n@@ -59,12 +65,9 @@ static void window_delete_cb (GtkWidget *widget, GdkEvent *event,\n static void window_destroy_cb (GtkWidget *widget, GdkEvent *event,\n \t\t\t       jobject peer);\n static void window_show_cb (GtkWidget *widget, jobject peer);\n-static gboolean window_focus_in_cb (GtkWidget * widget,\n-\t\t\t\t    GdkEventFocus *event,\n-\t\t\t\t    jobject peer);\n-static gboolean window_focus_out_cb (GtkWidget * widget,\n-\t\t\t\t     GdkEventFocus *event,\n-\t\t\t\t     jobject peer);\n+static void window_focus_or_active_state_change_cb (GtkWidget *widget,\n+                                                    GParamSpec *pspec,\n+                                                    jobject peer);\n static gboolean window_window_state_cb (GtkWidget *widget,\n \t\t\t\t\tGdkEvent *event,\n \t\t\t\t\tjobject peer);\n@@ -147,6 +150,20 @@ Java_gnu_java_awt_peer_gtk_GtkWindowPeer_create\n   insets[2] = bottom;\n   insets[3] = right;\n \n+  /* We must filter out WM_TAKE_FOCUS messages.  Otherwise we get two\n+     focus in events when a window becomes active and two focus out\n+     events when a window becomes inactive. */\n+  if (!filter_added)\n+    {\n+      GdkAtom wm_protocols_atom =\n+        gdk_x11_xatom_to_atom (gdk_x11_get_xatom_by_name (\"WM_PROTOCOLS\"));\n+\n+      gdk_add_client_message_filter (wm_protocols_atom,\n+                                     window_wm_protocols_filter,\n+                                     NULL);\n+      filter_added = 1;\n+    }\n+\n   gdk_threads_leave ();\n \n   (*env)->ReleaseIntArrayElements (env, jinsets, insets, 0);\n@@ -251,11 +268,8 @@ Java_gnu_java_awt_peer_gtk_GtkWindowPeer_connectSignals\n   g_signal_connect (G_OBJECT (ptr), \"show\",\n \t\t    G_CALLBACK (window_show_cb), *gref);\n \n-  g_signal_connect (G_OBJECT (ptr), \"focus-in-event\",\n-\t\t    G_CALLBACK (window_focus_in_cb), *gref);\n-\n-  g_signal_connect (G_OBJECT (ptr), \"focus-out-event\",\n-\t\t    G_CALLBACK (window_focus_out_cb), *gref);\n+  g_signal_connect (G_OBJECT (ptr), \"notify\",\n+\t\t    G_CALLBACK (window_focus_or_active_state_change_cb), *gref);\n \n   g_signal_connect (G_OBJECT (ptr), \"window-state-event\",\n \t\t    G_CALLBACK (window_window_state_cb), *gref);\n@@ -661,40 +675,37 @@ window_show_cb (GtkWidget *widget __attribute__((unused)),\n \t\t\t      (jobject) NULL, (jint) 0);\n }\n \n-static gboolean\n-window_focus_in_cb (GtkWidget * widget __attribute__((unused)),\n-\t\t    GdkEventFocus *event __attribute__((unused)),\n-\t\t    jobject peer)\n-{\n-  /* FIXME: when hiding then showing, we get two sets of\n-     (LOST_FOCUS/DEACTIVATED, ACTIVATED/GAINED_FOCUS) events. */\n-  (*gdk_env)->CallVoidMethod (gdk_env, peer,\n-\t\t\t      postWindowEventID,\n-\t\t\t      (jint) AWT_WINDOW_ACTIVATED,\n-\t\t\t      (jobject) NULL, (jint) 0);\n-\n-  (*gdk_env)->CallVoidMethod (gdk_env, peer,\n-\t\t\t      postWindowEventID,\n-\t\t\t      (jint) AWT_WINDOW_GAINED_FOCUS,\n-\t\t\t      (jobject) NULL, (jint) 0);\n-  return TRUE;\n-}\n-\n-static gboolean\n-window_focus_out_cb (GtkWidget * widget __attribute__((unused)),\n-\t\t     GdkEventFocus *event __attribute__((unused)),\n-\t\t     jobject peer)\n+static void\n+window_focus_or_active_state_change_cb (GtkWidget *widget,\n+                                        GParamSpec *pspec,\n+                                        jobject peer)\n {\n-  (*gdk_env)->CallVoidMethod (gdk_env, peer,\n-\t\t\t      postWindowEventID,\n-\t\t\t      (jint) AWT_WINDOW_LOST_FOCUS,\n-\t\t\t      (jobject) NULL, (jint) 0);\n-\n-  (*gdk_env)->CallVoidMethod (gdk_env, peer,\n-\t\t\t      postWindowEventID,\n-\t\t\t      (jint) AWT_WINDOW_DEACTIVATED,\n-\t\t\t      (jobject) NULL, (jint) 0);\n-  return TRUE;\n+  if (!strcmp (g_param_spec_get_name (pspec), \"is-active\"))\n+    {\n+      if (GTK_WINDOW (widget)->is_active)\n+        (*gdk_env)->CallVoidMethod (gdk_env, peer,\n+                                    postWindowEventID,\n+                                    (jint) AWT_WINDOW_GAINED_FOCUS,\n+                                    (jobject) NULL, (jint) 0);\n+      else\n+        (*gdk_env)->CallVoidMethod (gdk_env, peer,\n+                                    postWindowEventID,\n+                                    (jint) AWT_WINDOW_DEACTIVATED,\n+                                    (jobject) NULL, (jint) 0);\n+    }\n+  else if (!strcmp (g_param_spec_get_name (pspec), \"has-toplevel-focus\"))\n+    {\n+      if (GTK_WINDOW (widget)->has_toplevel_focus)\n+        (*gdk_env)->CallVoidMethod (gdk_env, peer,\n+                                    postWindowEventID,\n+                                    (jint) AWT_WINDOW_ACTIVATED,\n+                                    (jobject) NULL, (jint) 0);\n+      else\n+        (*gdk_env)->CallVoidMethod (gdk_env, peer,\n+                                    postWindowEventID,\n+                                    (jint) AWT_WINDOW_LOST_FOCUS,\n+                                    (jobject) NULL, (jint) 0);\n+    }\n }\n \n static gboolean\n@@ -821,3 +832,16 @@ window_property_changed_cb (GtkWidget *widget __attribute__((unused)),\n \n   return FALSE;\n }\n+\n+static GdkFilterReturn\n+window_wm_protocols_filter (GdkXEvent *xev,\n+                            GdkEvent  *event __attribute__((unused)),\n+                            gpointer data __attribute__((unused)))\n+{\n+  XEvent *xevent = (XEvent *)xev;\n+\n+  if ((Atom) xevent->xclient.data.l[0] == gdk_x11_get_xatom_by_name (\"WM_TAKE_FOCUS\"))\n+    return GDK_FILTER_REMOVE;\n+\n+  return GDK_FILTER_CONTINUE;\n+}"}, {"sha": "129d25c647176dea660f78f416901565f0d15f9a", "filename": "libjava/testsuite/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86881a7b541b2ec6557b1a315f841b211d14c576/libjava%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2FMakefile.in?ref=86881a7b541b2ec6557b1a315f841b211d14c576", "patch": "@@ -1,6 +1,6 @@\n-# Makefile.in generated automatically by automake 1.4 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4-p6 from Makefile.am\n \n-# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n+# Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -172,7 +172,7 @@ RUNTEST = \"`if [ -f $(top_srcdir)/../dejagnu/runtest ] ; then \\\n AM_RUNTESTFLAGS = INTERPRETER=$(INTERPRETER)\n CONFIG_HEADER = ../include/config.h ../gcj/libgcj-config.h\n CONFIG_CLEAN_FILES = \n-DIST_COMMON =  ChangeLog Makefile.am Makefile.in\n+DIST_COMMON =  Makefile.am Makefile.in\n \n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)"}]}