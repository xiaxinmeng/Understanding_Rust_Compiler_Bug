{"sha": "961046eacb8593a573f43343167c965941baf2df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTYxMDQ2ZWFjYjg1OTNhNTczZjQzMzQzMTY3Yzk2NTk0MWJhZjJkZg==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2000-12-09T16:25:20Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2000-12-09T16:25:20Z"}, "message": "oops, that was a mistake\n\nFrom-SVN: r38156", "tree": {"sha": "68eae6522c44df69229293e0773506cd8087bab6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68eae6522c44df69229293e0773506cd8087bab6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/961046eacb8593a573f43343167c965941baf2df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/961046eacb8593a573f43343167c965941baf2df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/961046eacb8593a573f43343167c965941baf2df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/961046eacb8593a573f43343167c965941baf2df/comments", "author": null, "committer": null, "parents": [{"sha": "e14f8e28fcaea0477d6163b25d2d9f1bda584679", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e14f8e28fcaea0477d6163b25d2d9f1bda584679", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e14f8e28fcaea0477d6163b25d2d9f1bda584679"}], "stats": {"total": 146, "additions": 48, "deletions": 98}, "files": [{"sha": "89479eb819d1ae0c05e0d3c386d135e1541292a4", "filename": "gcc/Makefile.in", "status": "modified", "additions": 48, "deletions": 98, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/961046eacb8593a573f43343167c965941baf2df/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/961046eacb8593a573f43343167c965941baf2df/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=961046eacb8593a573f43343167c965941baf2df", "patch": "@@ -2264,9 +2264,8 @@ clean: mostlyclean $(INTL_CLEAN) lang.clean\n \tfi ; fi\n \t-rm -fr stage1 stage2 stage3 stage4\n # Delete stamps of bootstrap stages\n-\t-rm -f stage?_*\n-\t-rm -f clean?_*\n-\t-rm -f stage_last\n+\t-rm -f stage_*\n+\t-rm -f clean_*\n \n # Delete all files that users would normally create\n # while building and installing GCC.\n@@ -2781,133 +2780,84 @@ STAGE2_FLAGS_TO_PASS = \\\n # Only build the C compiler for stage1, because that is the only one that\n # we can guarantee will build with the native compiler, and also it is the\n # only thing useful for building stage2.\n-stage1_build:\n+stage_a: \n \t+$(MAKE) CC=\"$(CC)\" libdir=$(libdir) LANGUAGES=\"$(BOOT_LANGUAGES)\"\n-\ttouch stage1_build\n-\techo stage1_build > stage_last\n+\ttouch stage_a\n \n-stage1_copy: stage1_build\n+stage_b: stage_a\n \t$(MAKE) stage1\n-\ttouch stage1_copy\n-\techo stage2_build > stage_last\n+\ttouch stage_b\n \n # This used to define ALLOCA as empty, but that would lead to bad results\n # for a subsequent `make install' since that would not have ALLOCA empty.\n # To prevent `make install' from compiling alloca.o and then relinking cc1\n # because alloca.o is newer, we permit these recursive makes to compile\n # alloca.o.  Then cc1 is newer, so it won't have to be relinked.\n-stage2_build: stage1_copy\n+stage_c: stage_b\n \t+$(MAKE) CC=\"stage1/xgcc$(exeext) -Bstage1/ -B$(build_tooldir)/bin/\" \\\n \t\t STAGE_PREFIX=stage1/ \\\n \t\t $(STAGE2_FLAGS_TO_PASS)\n-\ttouch stage2_build\n-\techo stage2_build > stage_last\n+\ttouch stage_c\n \n-stage2_copy: stage2_build\n+stage_d: stage_c\n \t+$(MAKE) stage2\n-\ttouch stage2_copy\n-\techo stage3_build > stage_last\n+\ttouch stage_d\n \n-stage3_build: stage2_copy\n+stage_e: stage_d\n \t+$(MAKE) CC=\"stage2/xgcc$(exeext) -Bstage2/ -B$(build_tooldir)/bin/\" \\\n \t\t STAGE_PREFIX=stage2/ \\\n \t\t $(STAGE2_FLAGS_TO_PASS)\n-\ttouch stage3_build\n-\techo stage3_build > stage_last\n+\ttouch stage_e\n \n # For bootstrap4:\n-stage3_copy: stage3_build\n-\t+$(MAKE) stage3\n-\ttouch stage3_copy\n-\techo stage4_build > stage_last\n-\n-stage4_build: stage3_copy\n+stage_f: stage_e\n \t+$(MAKE) CC=\"stage3/xgcc$(exeext) -B$(build_tooldir)/bin/ -Bstage3/\" \\\n \t\t STAGE_PREFIX=stage3/ \\\n \t\t $(STAGE2_FLAGS_TO_PASS)\n-\ttouch stage4_build\n-\techo stage4_build > stage_last\n+\ttouch stage_f\n \n # Additional steps for *-lean targets:\n-clean_s1: stage1_copy\n+clean_s1: stage_b\n \t-(cd stage1 && rm -f $(VOL_FILES))\n \ttouch clean_s1\n \n-clean_s2: stage2_copy\n+clean_s2: stage_d\n \t-rm -rf stage1\n \ttouch clean_s2\n \n-# The various entry points for bootstrapping.\n-\n-bootstrap: stage3_build\n-\t@echo\n-\t@echo Bootstrap complete - make \\\"quickstrap\\\" to redo last build,\n-\t@echo \\\"restage1\\\" through \\\"restage3\\\" to rebuild specific stages,\n-\t@echo or \\\"cleanstrap\\\" to redo the bootstrap from scratch.\n-\n-bootstrap-lean : clean_s1 clean_s2 stage3_build\n-\t@echo\n-\t@echo Bootstrap complete - make \\\"quickstrap\\\" to redo last build,\n-\t@echo or \\\"cleanstrap\\\" to redo the bootstrap from scratch.\n-\n-bootstrap2: bootstrap\n-\n-bootstrap2-lean : bootstrap_lean\n-\n-bootstrap3 bootstrap3-lean: bootstrap\n+# This next little bit is the way it is for parallel builds.  It's simply\n+# a chain of stages which DO have to be done sequentially.\n+\n+bootstrap_a:              stage_a\n+bootstrap_b:  bootstrap_a stage_b\n+bootstrap_c:  bootstrap_b stage_c\n+bootstrap_d:  bootstrap_c stage_d\n+bootstrap_e:  bootstrap_d stage_e\n+bootstrap: force bootstrap_e\n+\n+bootstrap-lean_a:                   stage_a\n+bootstrap-lean_b:  bootstrap-lean_a stage_b\n+bootstrap-lean_c:  bootstrap-lean_b clean_s1 \n+bootstrap-lean_d:  bootstrap-lean_c stage_c\n+bootstrap-lean_e:  bootstrap-lean_d stage_d\n+bootstrap-lean_f:  bootstrap-lean_e clean_s2\n+bootstrap-lean_g:  bootstrap-lean_f stage_e\n+bootstrap-lean: force bootstrap-lean_g\n+\n+bootstrap2_c:               stage_c\n+bootstrap2_d:  bootstrap2_c stage_d\n+bootstrap2_e:  bootstrap2_d stage_e\n+bootstrap2: force bootstrap2_e\n+\n+bootstrap2-lean_c:                    stage_c\n+bootstrap2-lean_d:  bootstrap2-lean_c stage_d\n+bootstrap2-lean_e:  bootstrap2-lean_d clean_s2\n+bootstrap2-lean_f:  bootstrap2-lean_e stage_e\n+bootstrap2-lean: force bootstrap2-lean_f\n+\n+bootstrap3 bootstrap3-lean: force stage_e\n  \n-bootstrap4 bootstrap4-lean: stage4_build\n-\n-unstage1 unstage2 unstage3 unstage4:\n-\t-set -vx; stage=`echo $@ | sed -e 's/un//'`; \\\n-\tif test -d $$stage; then \\\n-\t  mv $$stage/* . 2>/dev/null; \\\n-\t  for i in `cd $$stage; echo *` ; do \\\n-\t    if test -d $$stage/$$i; then \\\n-\t      mv $$stage/$$i/* $$i/. 2>/dev/null; \\\n-\t    else \\\n-\t      mv $$stage/$$i .; \\\n-\t    fi \\\n-\t  done \\\n-\tfi ; \\\n-\trm -f $${stage}_build $${stage}_copy ;\\\n-\techo $${stage}_build > stage_last\n-\n-restage1: unstage1\n-\t$(MAKE) stage1_build\n-\n-restage2: unstage2\n-\t$(MAKE) LANGUAGES=\"$(LANGUAGES)\" stage2_build\n-\n-restage3: unstage3\n-\t$(MAKE) LANGUAGES=\"$(LANGUAGES)\" stage3_build\n-\n-restage4: unstage4\n-\t$(MAKE) LANGUAGES=\"$(LANGUAGES)\" stage4_build\n-\n-bubblestrap:\n-\tif test -f stage3_build; then true; else \\\n-\t  echo; echo You must \\\"make bootstrap\\\" first.; \\\n-\t  exit 1; \\\n-\tfi\n-\tfor i in stage3 \\\n-\t\tunstage1 stage1_build stage1_copy \\\n-\t\tunstage2 stage2_build stage2_copy \\\n-\t\tunstage3 stage3_build ; \\\n-\tdo \\\n-\t  $(MAKE) LANGUAGES=\"$(LANGUAGES)\" $$i || exit 1 ; \\\n-\tdone\n-\n-quickstrap:\n-\tif test -f stage_last ; then \\\n-\t  LAST=`cat stage_last`; rm $$LAST; $(MAKE) LANGUAGES=\"$(LANGUAGES)\" $$LAST; \\\n-\telse \\\n-\t  $(MAKE) stage1_build; \\\n-\tfi\n-\n-cleanstrap:\n-\t-$(MAKE) clean\n-\t$(MAKE) LANGUAGES=\"$(LANGUAGES)\" bootstrap\n+bootstrap4 bootstrap4-lean: force stage_f\n \n # Compare the object files in the current directory with those in the\n # stage2 directory."}]}