{"sha": "c24851dee56337fd1d88a87749792980cf0d30bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI0ODUxZGVlNTYzMzdmZDFkODhhODc3NDk3OTI5ODBjZjBkMzBiYw==", "commit": {"author": {"name": "Nathanael Nerode", "email": "neroden@gcc.gnu.org", "date": "2003-06-17T00:03:11Z"}, "committer": {"name": "Nathanael Nerode", "email": "neroden@gcc.gnu.org", "date": "2003-06-17T00:03:11Z"}, "message": "* config/ip2k/ip2k.h: Remove target-independent comments.\n\nFrom-SVN: r68046", "tree": {"sha": "66516d09d308ca4a016c67b156b2f9040b6d1e4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66516d09d308ca4a016c67b156b2f9040b6d1e4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c24851dee56337fd1d88a87749792980cf0d30bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c24851dee56337fd1d88a87749792980cf0d30bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c24851dee56337fd1d88a87749792980cf0d30bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c24851dee56337fd1d88a87749792980cf0d30bc/comments", "author": null, "committer": null, "parents": [{"sha": "9cd598aa72d6ea43a953037ad51ed6cbab1b068a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cd598aa72d6ea43a953037ad51ed6cbab1b068a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cd598aa72d6ea43a953037ad51ed6cbab1b068a"}], "stats": {"total": 1460, "additions": 3, "deletions": 1457}, "files": [{"sha": "b59a69a10634aecac0fb7d77720f711f13d18697", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c24851dee56337fd1d88a87749792980cf0d30bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c24851dee56337fd1d88a87749792980cf0d30bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c24851dee56337fd1d88a87749792980cf0d30bc", "patch": "@@ -1,5 +1,7 @@\n 2003-06-16  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n+\t* config/ip2k/ip2k.h: Remove target-independent comments.\n+\n \t* config.gcc: Explicitly mention elfos.h in ip2k entry.\n \t* config/ip2k/ip2k.h: Don't #include it here.\n "}, {"sha": "d0c8a676e96dc8e70ef097c32e304e2e5cf96bf9", "filename": "gcc/config/ip2k/ip2k.h", "status": "modified", "additions": 1, "deletions": 1457, "changes": 1458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c24851dee56337fd1d88a87749792980cf0d30bc/gcc%2Fconfig%2Fip2k%2Fip2k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c24851dee56337fd1d88a87749792980cf0d30bc/gcc%2Fconfig%2Fip2k%2Fip2k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k.h?ref=c24851dee56337fd1d88a87749792980cf0d30bc", "patch": "@@ -37,82 +37,9 @@ Boston, MA 02111-1307, USA.  */\n /* This declaration should be present.  */\n extern int target_flags;\n \n-/* `TARGET_...'\n-   This series of macros is to allow compiler command arguments to\n-   enable or disable the use of optional features of the target\n-   machine.  For example, one machine description serves both the\n-   68000 and the 68020; a command argument tells the compiler whether\n-   it should use 68020-only instructions or not.  This command\n-   argument works by means of a macro `TARGET_68020' that tests a bit\n-   in `target_flags'.\n-\n-   Define a macro `TARGET_FEATURENAME' for each such option.  Its\n-   definition should test a bit in `target_flags'; for example:\n-\n-   #define TARGET_68020 (target_flags & 1)\n-\n-   One place where these macros are used is in the\n-   condition-expressions of instruction patterns.  Note how\n-   `TARGET_68020' appears frequently in the 68000 machine description\n-   file, `m68k.md'.  Another place they are used is in the\n-   definitions of the other macros in the `MACHINE.h' file.  */\n-\n-\n-\n #define TARGET_SWITCHES {{\"\",0, NULL}}\n-/* This macro defines names of command options to set and clear bits\n-   in `target_flags'.  Its definition is an initializer with a\n-   subgrouping for each command option.\n-\n-   Each subgrouping contains a string constant, that defines the\n-   option name, and a number, which contains the bits to set in\n-   `target_flags'.  A negative number says to clear bits instead; the\n-   negative of the number is which bits to clear.  The actual option\n-   name is made by appending `-m' to the specified name.\n-\n-   One of the subgroupings should have a null string.  The number in\n-   this grouping is the default value for `target_flags'.  Any target\n-   options act starting with that value.\n-\n-   Here is an example which defines `-m68000' and `-m68020' with\n-   opposite meanings, and picks the latter as the default:\n-\n-   #define TARGET_SWITCHES \\\n-   { { \"68020\", 1},      \\\n-   { \"68000\", -1},     \\\n-   { \"\", 1}}  */\n-\n-\n-/* This macro is similar to `TARGET_SWITCHES' but defines names of\n-   command options that have values.  Its definition is an\n-   initializer with a subgrouping for each command option.\n-\n-   Each subgrouping contains a string constant, that defines the\n-   fixed part of the option name, and the address of a variable.  The\n-   variable, type `char *', is set to the variable part of the given\n-   option if the fixed part matches.  The actual option name is made\n-   by appending `-m' to the specified name.\n-\n-   Here is an example which defines `-mshort-data-NUMBER'.  If the\n-   given option is `-mshort-data-512', the variable `m88k_short_data'\n-   will be set to the string `\"512\"'.\n-\n-   extern char *m88k_short_data;\n-   #define TARGET_OPTIONS \\\n-   { { \"short-data-\", &m88k_short_data } }  */\n \n #define TARGET_VERSION fprintf (stderr, \" (ip2k, GNU assembler syntax)\")\n-/* This macro is a C statement to print on `stderr' a string\n-   describing the particular machine description choice.  Every\n-   machine description should define `TARGET_VERSION'. For example:\n-\n-   #ifdef MOTOROLA\n-   #define TARGET_VERSION \\\n-   fprintf (stderr, \" (68k, Motorola syntax)\")\n-   #else\n-   #define TARGET_VERSION \\\n-   fprintf (stderr, \" (68k, MIT syntax)\")\n-   #endif  */\n \n /* Caller-saves is not a win for the IP2K.  Pretty much anywhere that\n    a register is permitted allows SP-relative addresses too.\n@@ -125,16 +52,6 @@ extern int target_flags;\n \tflag_pic = 0;\t\t\\\n     } while (0)\n \n-/* `OVERRIDE_OPTIONS'\n-   Sometimes certain combinations of command options do not make\n-   sense on a particular target machine.  You can define a macro\n-   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n-   defined, is executed once just after all the command options have\n-   been parsed.\n-\n-   Don't use this macro to turn on various extra optimizations for\n-   `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */\n-\n /* Put each function in its own section so that PAGE-instruction\n    relaxation can do its best.  */\n #define OPTIMIZATION_OPTIONS(LEVEL, SIZEFLAG)\t\\\n@@ -143,24 +60,11 @@ extern int target_flags;\n \t    flag_function_sections = 1;\t\\\n     } while (0)\n \n-/* Define this if most significant byte of a word is the lowest numbered.  */\n #define BITS_BIG_ENDIAN 0\n-\n-/* Define this if most significant byte of a word is the lowest numbered.  */\n #define BYTES_BIG_ENDIAN 1\n-\n-/* Define this if most significant word of a multiword number is the lowest\n-   numbered.  */\n #define WORDS_BIG_ENDIAN 1\n-\n-/* Number of bits in an addressable storage unit.  */\n #define BITS_PER_UNIT 8\n-\n-/* Width in bits of a \"word\", which is the contents of a machine register.\n-   Note that this is not necessarily the width of data type `int';  */\n #define BITS_PER_WORD 8\n-\n-/* Width of a word, in units (bytes).  */\n #define UNITS_PER_WORD (BITS_PER_WORD / BITS_PER_UNIT)\n \n /* Width in bits of a pointer.\n@@ -170,131 +74,56 @@ extern int target_flags;\n /* Maximum sized of reasonable data type DImode or Dfmode ...  */\n #define MAX_FIXED_MODE_SIZE 64\n \n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n #define PARM_BOUNDARY 8\n-\n-/* Allocation boundary (in *bits*) for the code of a function.  */\n #define FUNCTION_BOUNDARY 16\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n #define EMPTY_FIELD_BOUNDARY 8\n-\n-/* No data type wants to be aligned rounder than this.  */\n-\n #define BIGGEST_ALIGNMENT 8\n \n #define STRICT_ALIGNMENT 0\n \n #define PCC_BITFIELD_TYPE_MATTERS 1\n \n-/* A C expression for the size in bits of the type `int' on the\n-     target machine.  If you don't define this, the default is one word.  */\n #undef INT_TYPE_SIZE\n #define INT_TYPE_SIZE 16\n \n-\n-/* A C expression for the size in bits of the type `short' on the\n-   target machine.  If you don't define this, the default is half a\n-   word.  (If this would be less than one storage unit, it is rounded\n-   up to one unit.)  */\n #undef SHORT_TYPE_SIZE\n #define SHORT_TYPE_SIZE 16\n \n-/* A C expression for the size in bits of the type `long' on the\n-   target machine.  If you don't define this, the default is one word.  */\n #undef LONG_TYPE_SIZE\n #define LONG_TYPE_SIZE 32\n-\n-\n-/* Maximum number for the size in bits of the type `long' on the\n-   target machine.  If this is undefined, the default is\n-   `LONG_TYPE_SIZE'.  Otherwise, it is the constant value that is the\n-   largest value that `LONG_TYPE_SIZE' can have at run-time.  This is\n-   used in `cpp'.  */\n #define MAX_LONG_TYPE_SIZE 32\n \n-/* A C expression for the size in bits of the type `long long' on the\n-   target machine.  If you don't define this, the default is two\n-   words.  If you want to support GNU Ada on your machine, the value\n-   of macro must be at least 64.  */\n #undef LONG_LONG_TYPE_SIZE\n #define LONG_LONG_TYPE_SIZE\t64\n \n #undef CHAR_TYPE_SIZE\n #define  CHAR_TYPE_SIZE 8\n-/* A C expression for the size in bits of the type `char' on the\n-   target machine.  If you don't define this, the default is one\n-   quarter of a word.  (If this would be less than one storage unit,\n-   it is rounded up to one unit.)  */\n \n #undef FLOAT_TYPE_SIZE\n #define FLOAT_TYPE_SIZE 32\n-/* A C expression for the size in bits of the type `float' on the\n-   target machine.  If you don't define this, the default is one word.  */\n \n #undef DOUBLE_TYPE_SIZE\n #define DOUBLE_TYPE_SIZE 32\n-/* A C expression for the size in bits of the type `double' on the\n-   target machine.  If you don't define this, the default is two\n-   words.  */\n \n-\n-/* A C expression for the size in bits of the type `long double' on\n-   the target machine.  If you don't define this, the default is two\n-   words.  */\n #undef LONG_DOUBLE_TYPE_SIZE\n #define LONG_DOUBLE_TYPE_SIZE\t32\n \n #define DEFAULT_SIGNED_CHAR 1\n-/* An expression whose value is 1 or 0, according to whether the type\n-   `char' should be signed or unsigned by default.  The user can\n-   always override this default with the options `-fsigned-char' and\n-   `-funsigned-char'.  */\n \n /* #define DEFAULT_SHORT_ENUMS\t1\n    This was the default for the IP2k but gcc has a bug (as of 17th May\n    2001) in the way that library calls to the memory checker functions\n    are issues that screws things up if an enum is not equivalent to\n    an int.  */\n-/* `DEFAULT_SHORT_ENUMS'\n-   A C expression to determine whether to give an `enum' type only as\n-   many bytes as it takes to represent the range of possible values\n-   of that type.  A nonzero value means to do that; a zero value\n-   means all `enum' types should be allocated like `int'.\n-\n-   If you don't define the macro, the default is 0.  */\n \n #define SIZE_TYPE \"unsigned int\"\n-/* A C expression for a string describing the name of the data type\n-   to use for size values.  The typedef name `size_t' is defined\n-   using the contents of the string.\n-   \n-   The string can contain more than one keyword.  If so, separate\n-   them with spaces, and write first any length keyword, then\n-   `unsigned' if appropriate, and finally `int'.  The string must\n-   exactly match one of the data type names defined in the function\n-   `init_decl_processing' in the file `c-decl.c'.  You may not omit\n-   `int' or change the order--that would cause the compiler to crash\n-   on startup.\n-   \n-   If you don't define this macro, the default is `\"long unsigned\n-   int\"'.  */\n \n #define PTRDIFF_TYPE \"int\"\n-/* A C expression for a string describing the name of the data type\n-   to use for the result of subtracting two pointers.  The typedef\n-   name `ptrdiff_t' is defined using the contents of the string.  See\n-   `SIZE_TYPE' above for more information.\n-   \n-   If you don't define this macro, the default is `\"long int\"'.  */\n \n #undef WCHAR_TYPE\n #define WCHAR_TYPE \"int\"\n #undef WCHAR_TYPE_SIZE\n #define WCHAR_TYPE_SIZE\t16\n-/* A C expression for the size in bits of the data type for wide\n-   characters.  This is used in `cpp', which cannot make use of\n-   `WCHAR_TYPE'.  */\n \n #define HARD_REG_SIZE           (UNITS_PER_WORD)\n /* Standard register usage.\n@@ -304,11 +133,6 @@ extern int target_flags;\n  \n #define FIRST_PSEUDO_REGISTER (0x104) /* Skip over physical regs, VFP, AP.  */\n \n-/* Number of hardware registers known to the compiler.  They receive\n-   numbers 0 through `FIRST_PSEUDO_REGISTER-1'; thus, the first\n-   pseudo register's number really is assigned the number\n-   `FIRST_PSEUDO_REGISTER'.  */\n-\n #define REG_IP\t\t0x4\n #define REG_IPH\t\tREG_IP\n #define REG_IPL\t\t0x5\n@@ -357,25 +181,6 @@ extern int target_flags;\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,/*r224..r255*/\\\n 1,1,1,1}\n \n-/* An initializer that says which registers are used for fixed\n-   purposes all throughout the compiled code and are therefore not\n-   available for general allocation.  These would include the stack\n-   pointer, the frame pointer (except on machines where that can be\n-   used as a general register when no frame pointer is needed), the\n-   program counter on machines where that is considered one of the\n-   addressable registers, and any other numbered register with a\n-   standard use.\n-\n-   This information is expressed as a sequence of numbers, separated\n-   by commas and surrounded by braces.  The Nth number is 1 if\n-   register N is fixed, 0 otherwise.\n-\n-   The table initialized from this macro, and the table initialized by\n-   the following one, may be overridden at run time either\n-   automatically, by the actions of the macro\n-   `CONDITIONAL_REGISTER_USAGE', or by the user with the command\n-   options `-ffixed-REG', `-fcall-used-REG' and `-fcall-saved-REG'.  */\n-\n #define CALL_USED_REGISTERS {\t\t\t\\\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,/*  r0.. r31*/\\\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,/* r32.. r63*/\\\n@@ -387,22 +192,7 @@ extern int target_flags;\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,/*r224..r255*/\\\n 1,1,1,1}\n \n-/* Like `FIXED_REGISTERS' but has 1 for each register that is\n-   clobbered (in general) by function calls as well as for fixed\n-   registers.  This macro therefore identifies the registers that are\n-   not available for general allocation of values that must live\n-   across function calls.\n-\n-   If a register has 0 in `CALL_USED_REGISTERS', the compiler\n-   automatically saves it on function entry and restores it on\n-   function exit, if the register is used within the function.  */\n-\n #define NON_SAVING_SETJMP 0\n-/* If this macro is defined and has a nonzero value, it means that\n-   `setjmp' and related functions fail to save the registers, or that\n-   `longjmp' fails to restore them.  To compensate, the compiler\n-   avoids putting variables in registers in functions that use\n-   `setjmp'.  */\n \n #define REG_ALLOC_ORDER {\t\t\t\\\n     0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,\t\\\n@@ -439,32 +229,8 @@ extern int target_flags;\n     0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,\t\\\n     0x100,0x101,0x102,0x103}\n \n-/* If defined, an initializer for a vector of integers, containing the\n-   numbers of hard registers in the order in which GNU CC should\n-   prefer to use them (from most preferred to least).\n-   \n-   If this macro is not defined, registers are used lowest numbered\n-   first (all else being equal).\n-   \n-   One use of this macro is on machines where the highest numbered\n-   registers must always be saved and the save-multiple-registers\n-   instruction supports only sequences of consecutive registers.  On\n-   such machines, define `REG_ALLOC_ORDER' to be an initializer that\n-   lists the highest numbered allocatable register first.  */\n \n #define ORDER_REGS_FOR_LOCAL_ALLOC ip2k_init_local_alloc (reg_alloc_order)\n-/* A C statement (sans semicolon) to choose the order in which to\n-   allocate hard registers for pseudo-registers local to a basic\n-   block.\n-\n-   Store the desired register order in the array `reg_alloc_order'.\n-   Element 0 should be the register to allocate first; element 1, the\n-   next register; and so on.\n-\n-   The macro body should not assume anything about the contents of\n-   `reg_alloc_order' before execution of the macro.\n-\n-   On most machines, it is not necessary to define this macro.  */\n \n /* Are we allowed to rename registers?  For some reason, regrename was\n    changing DP to IP (when it appeared in addresses like (plus:HI\n@@ -479,77 +245,7 @@ extern int target_flags;\n #define HARD_REGNO_NREGS(REGNO, MODE) \\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* A C expression for the number of consecutive hard registers,\n-   starting at register number REGNO, required to hold a value of mode\n-   MODE.\n-\n-   On a machine where all registers are exactly one word, a suitable\n-   definition of this macro is\n-\n-   #define HARD_REGNO_NREGS(REGNO, MODE)            \\\n-   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)  \\\n-   / UNITS_PER_WORD))  */\n-\n #define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n-/* A C expression that is nonzero if it is permissible to store a\n-   value of mode MODE in hard register number REGNO (or in several\n-   registers starting with that one).  For a machine where all\n-   registers are equivalent, a suitable definition is\n-\n-   #define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n-\n-   It is not necessary for this macro to check for the numbers of\n-   fixed registers, because the allocation mechanism considers them\n-   to be always occupied.\n-\n-   On some machines, double-precision values must be kept in even/odd\n-   register pairs.  The way to implement that is to define this macro\n-   to reject odd register numbers for such modes.\n-\n-   The minimum requirement for a mode to be OK in a register is that\n-   the `movMODE' instruction pattern support moves between the\n-   register and any other hard register for which the mode is OK; and\n-   that moving a value into the register and back out not alter it.\n-\n-   Since the same instruction used to move `SImode' will work for all\n-   narrower integer modes, it is not necessary on any machine for\n-   `HARD_REGNO_MODE_OK' to distinguish between these modes, provided\n-   you define patterns `movhi', etc., to take advantage of this.  This\n-   is useful because of the interaction between `HARD_REGNO_MODE_OK'\n-   and `MODES_TIEABLE_P'; it is very desirable for all integer modes\n-   to be tieable.\n-\n-   Many machines have special registers for floating point arithmetic.\n-   Often people assume that floating point machine modes are allowed\n-   only in floating point registers.  This is not true.  Any\n-   registers that can hold integers can safely *hold* a floating\n-   point machine mode, whether or not floating arithmetic can be done\n-   on it in those registers.  Integer move instructions can be used\n-   to move the values.\n-\n-   On some machines, though, the converse is true: fixed-point machine\n-   modes may not go in floating registers.  This is true if the\n-   floating registers normalize any value stored in them, because\n-   storing a non-floating value there would garble it.  In this case,\n-   `HARD_REGNO_MODE_OK' should reject fixed-point machine modes in\n-   floating registers.  But if the floating registers do not\n-   automatically normalize, if you can store any bit pattern in one\n-   and retrieve it unchanged without a trap, then any machine mode\n-   may go in a floating register, so you can define this macro to say\n-   so.\n-\n-   The primary significance of special floating registers is rather\n-   that they are the registers acceptable in floating point arithmetic\n-   instructions.  However, this is of no concern to\n-   `HARD_REGNO_MODE_OK'.  You handle it by writing the proper\n-   constraints for those instructions.\n-\n-   On some machines, the floating registers are especially slow to\n-   access, so that it is better to store a value in a stack frame\n-   than in such a register if floating point arithmetic is not being\n-   done.  As long as the floating registers are not in class\n-   `GENERAL_REGS', they will not be used unless some pattern's\n-   constraint asks for one.  */\n \n #define MODES_TIEABLE_P(MODE1, MODE2)\t\t\\\n    (((MODE1) == QImode && (MODE2) == HImode)\t\\\n@@ -561,14 +257,6 @@ extern int target_flags;\n     (((MODE1) > HImode && (MODE2) == HImode)\n      || ((MODE1) == HImode && (MODE2) > HImode))  */\n \n-/* A C expression that is nonzero if it is desirable to choose\n-   register allocation so as to avoid move instructions between a\n-   value of mode MODE1 and a value of mode MODE2.\n-\n-   If `HARD_REGNO_MODE_OK (R, MODE1)' and `HARD_REGNO_MODE_OK (R,\n-   MODE2)' are ever different for any R, then `MODES_TIEABLE_P (MODE1,\n-   MODE2)' must be zero.  */\n-\n enum reg_class {\n   NO_REGS,\n   DPH_REGS,\n@@ -587,21 +275,7 @@ enum reg_class {\n   LIM_REG_CLASSES\n };\n \n-/* An enumeral type that must be defined with all the register class\n-   names as enumeral values.  `NO_REGS' must be first.  `ALL_REGS'\n-   must be the last register class, followed by one more enumeral\n-   value, `LIM_REG_CLASSES', which is not a register class but rather\n-   tells how many classes there are.\n-\n-   Each register class has a number, which is the value of casting\n-   the class name to type `int'.  The number serves as an index in\n-   many of the tables described below.  */\n-\n-\n #define N_REG_CLASSES (int)LIM_REG_CLASSES\n-/* The number of distinct register classes, defined as follows:\n-\n-   #define N_REG_CLASSES (int) LIM_REG_CLASSES  */\n \n #define REG_CLASS_NAMES {\t\t\t\\\n \t\t\"NO_REGS\",\t\t\t\\\n@@ -618,9 +292,6 @@ enum reg_class {\n \t\t\"NONSP_REGS\",\t\t\t\\\n \t\t\"GENERAL_REGS\"\t\t\t\\\n \t\t}\n-/* An initializer containing the names of the register classes as C\n-   string constants.  These names are used in writing some of the\n-   debugging dumps.  */\n \n \n #define REG_CLASS_CONTENTS {\t\t\t \t\\\n@@ -639,17 +310,6 @@ enum reg_class {\n {0xffffffff,-1,-1,-1,-1,-1,-1,-1,15}  /* GENERAL_REGS */ \\\n }\n \n-/* An initializer containing the contents of the register classes, as\n-   integers which are bit masks.  The Nth integer specifies the\n-   contents of class N.  The way the integer MASK is interpreted is\n-   that register R is in the class if `MASK & (1 << R)' is 1.\n-\n-   When the machine has more than 32 registers, an integer does not\n-   suffice.  Then the integers are replaced by sub-initializers,\n-   braced groupings containing several integers.  Each\n-   sub-initializer must be suitable as an initializer for the type\n-   `HARD_REG_SET' which is defined in `hard-reg-set.h'.  */\n-\n #define REGNO_REG_CLASS(R)\t\\\n   ( (R) == REG_IPH ? IPH_REGS\t\\\n   : (R) == REG_IPL ? IPL_REGS\t\\\n@@ -659,28 +319,11 @@ enum reg_class {\n   : (R) == REG_SPL ? SP_REGS\t\\\n   : NONPTR_REGS)\n \n-/* A C expression whose value is a register class containing hard\n-   register REGNO.  In general there is more than one such class;\n-   choose a class which is \"minimal\", meaning that no smaller class\n-   also contains the register.  */\n-\n #define MODE_BASE_REG_CLASS(MODE) ((MODE) == QImode ? PTR_REGS : DP_SP_REGS)\n-/* This is a variation of the BASE_REG_CLASS macro which allows\n-   the selection of a base register in a mode dependent manner.\n-   If MODE is VOIDmode then it should return the same value as\n-   BASE_REG_CLASS.  */\n \n #define BASE_REG_CLASS PTR_REGS\n-/* A macro whose definition is the name of the class to which a valid\n-   base register must belong.  A base register is one used in an\n-   address which is the register value plus a displacement.  */\n \n #define INDEX_REG_CLASS NO_REGS\n-/* A macro whose definition is the name of the class to which a valid\n-   index register must belong.  An index register is one used in an\n-   address where its value is either multiplied by a scale factor or\n-   added to another register (as well as added to a displacement).  */\n-\n \n #define REG_CLASS_FROM_LETTER(C)\t\\\n   ( (C) == 'j' ? IPH_REGS\t\t\\\n@@ -696,219 +339,22 @@ enum reg_class {\n   : (C) == 'd' ? NONPTR_REGS \t\t\\\n   : NO_REGS)\n \n-/* A C expression which defines the machine-dependent operand\n-   constraint letters for register classes.  If CHAR is such a\n-   letter, the value should be the register class corresponding to\n-   it.  Otherwise, the value should be `NO_REGS'.  The register\n-   letter `r', corresponding to class `GENERAL_REGS', will not be\n-   passed to this macro; you do not need to handle it.  */\n-\n-\n #define REGNO_OK_FOR_BASE_P(R) \\\n   ((R) == REG_DP || (R) == REG_IP || (R) == REG_SP)\n-/* A C expression which is nonzero if register number R is suitable\n-   for use as a base register in operand addresses.  It may be either\n-   a suitable hard register or a pseudo register that has been\n-   allocated such a hard register.  */\n \n #define REGNO_MODE_OK_FOR_BASE_P(R,M) \t\t\\\n   ((R) == REG_DP || (R) == REG_SP\t\t\\\n    || ((R) == REG_IP && GET_MODE_SIZE (M) <= 1))\n-/* A C expression that is just like `REGNO_OK_FOR_BASE_P', except that\n-   that expression may examine the mode of the memory reference in\n-   MODE.  You should define this macro if the mode of the memory\n-   reference affects whether a register may be used as a base\n-   register.  If you define this macro, the compiler will use it\n-   instead of `REGNO_OK_FOR_BASE_P'.  */\n \n #define REGNO_OK_FOR_INDEX_P(NUM) 0\n-/* A C expression which is nonzero if register number NUM is suitable\n-   for use as an index register in operand addresses.  It may be\n-   either a suitable hard register or a pseudo register that has been\n-   allocated such a hard register.\n-\n-   The difference between an index register and a base register is\n-   that the index register may be scaled.  If an address involves the\n-   sum of two registers, neither one of them scaled, then either one\n-   may be labeled the \"base\" and the other the \"index\"; but whichever\n-   labeling is used must fit the machine's constraints of which\n-   registers may serve in each capacity.  The compiler will try both\n-   labelings, looking for one that is valid, and will reload one or\n-   both registers only if neither labeling works.  */\n \n #define PREFERRED_RELOAD_CLASS(X, CLASS) (CLASS)\n-/* A C expression that places additional restrictions on the register\n-   class to use when it is necessary to copy value X into a register\n-   in class CLASS.  The value is a register class; perhaps CLASS, or\n-   perhaps another, smaller class.  On many machines, the following\n-   definition is safe:\n-\n-   #define PREFERRED_RELOAD_CLASS(X,CLASS) (CLASS)\n-\n-   Sometimes returning a more restrictive class makes better code.\n-   For example, on the 68000, when X is an integer constant that is\n-   in range for a `moveq' instruction, the value of this macro is\n-   always `DATA_REGS' as long as CLASS includes the data registers.\n-   Requiring a data register guarantees that a `moveq' will be used.\n-\n-   If X is a `const_double', by returning `NO_REGS' you can force X\n-   into a memory constant.  This is useful on certain machines where\n-   immediate floating values cannot be loaded into certain kinds of\n-   registers.  */\n-\n-/* `PREFERRED_OUTPUT_RELOAD_CLASS (X, CLASS)'\n-   Like `PREFERRED_RELOAD_CLASS', but for output reloads instead of\n-   input reloads.  If you don't define this macro, the default is to\n-   use CLASS, unchanged.  */\n-\n-/* `LIMIT_RELOAD_CLASS (MODE, CLASS)'\n-   A C expression that places additional restrictions on the register\n-   class to use when it is necessary to be able to hold a value of\n-   mode MODE in a reload register for which class CLASS would\n-   ordinarily be used.\n-\n-   Unlike `PREFERRED_RELOAD_CLASS', this macro should be used when\n-   there are certain modes that simply can't go in certain reload\n-   classes.\n-\n-   The value is a register class; perhaps CLASS, or perhaps another,\n-   smaller class.\n-\n-   Don't define this macro unless the target machine has limitations\n-   which require the macro to do something nontrivial.  */\n-\n-/* SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X)\n-   `SECONDARY_RELOAD_CLASS (CLASS, MODE, X)'\n-   `SECONDARY_OUTPUT_RELOAD_CLASS (CLASS, MODE, X)'\n-   Many machines have some registers that cannot be copied directly\n-   to or from memory or even from other types of registers.  An\n-   example is the `MQ' register, which on most machines, can only be\n-   copied to or from general registers, but not memory.  Some\n-   machines allow copying all registers to and from memory, but\n-   require a scratch register for stores to some memory locations\n-   (e.g., those with symbolic address on the RT, and those with\n-   certain symbolic address on the SPARC when compiling PIC).  In\n-   some cases, both an intermediate and a scratch register are\n-   required.\n-\n-   You should define these macros to indicate to the reload phase\n-   that it may need to allocate at least one register for a reload in\n-   addition to the register to contain the data.  Specifically, if\n-   copying X to a register CLASS in MODE requires an intermediate\n-   register, you should define `SECONDARY_INPUT_RELOAD_CLASS' to\n-   return the largest register class all of whose registers can be\n-   used as intermediate registers or scratch registers.\n-\n-   If copying a register CLASS in MODE to X requires an intermediate\n-   or scratch register, `SECONDARY_OUTPUT_RELOAD_CLASS' should be\n-   defined to return the largest register class required.  If the\n-   requirements for input and output reloads are the same, the macro\n-   `SECONDARY_RELOAD_CLASS' should be used instead of defining both\n-   macros identically.\n-\n-   The values returned by these macros are often `GENERAL_REGS'.\n-   Return `NO_REGS' if no spare register is needed; i.e., if X can be\n-   directly copied to or from a register of CLASS in MODE without\n-   requiring a scratch register.  Do not define this macro if it\n-   would always return `NO_REGS'.\n-\n-   If a scratch register is required (either with or without an\n-   intermediate register), you should define patterns for\n-   `reload_inM' or `reload_outM', as required (*note Standard\n-   Names::..  These patterns, which will normally be implemented with\n-   a `define_expand', should be similar to the `movM' patterns,\n-   except that operand 2 is the scratch register.\n-\n-   Define constraints for the reload register and scratch register\n-   that contain a single register class.  If the original reload\n-   register (whose class is CLASS) can meet the constraint given in\n-   the pattern, the value returned by these macros is used for the\n-   class of the scratch register.  Otherwise, two additional reload\n-   registers are required.  Their classes are obtained from the\n-   constraints in the insn pattern.\n-\n-   X might be a pseudo-register or a `subreg' of a pseudo-register,\n-   which could either be in a hard register or in memory.  Use\n-   `true_regnum' to find out; it will return -1 if the pseudo is in\n-   memory and the hard register number if it is in a register.\n-\n-   These macros should not be used in the case where a particular\n-   class of registers can only be copied to memory and not to another\n-   class of registers.  In that case, secondary reload registers are\n-   not needed and would not be helpful.  Instead, a stack location\n-   must be used to perform the copy and the `movM' pattern should use\n-   memory as an intermediate storage.  This case often occurs between\n-   floating-point and general registers.  */\n-\n-/* `SECONDARY_MEMORY_NEEDED (CLASS1, CLASS2, M)'\n-   Certain machines have the property that some registers cannot be\n-   copied to some other registers without using memory.  Define this\n-   macro on those machines to be a C expression that is nonzero if\n-   objects of mode M in registers of CLASS1 can only be copied to\n-   registers of class CLASS2 by storing a register of CLASS1 into\n-   memory and loading that memory location into a register of CLASS2.\n-\n-   Do not define this macro if its value would always be zero.\n-\n-   `SECONDARY_MEMORY_NEEDED_RTX (MODE)'\n-   Normally when `SECONDARY_MEMORY_NEEDED' is defined, the compiler\n-   allocates a stack slot for a memory location needed for register\n-   copies.  If this macro is defined, the compiler instead uses the\n-   memory location defined by this macro.\n-\n-   Do not define this macro if you do not define\n-   `SECONDARY_MEMORY_NEEDED'.  */\n \n #define SMALL_REGISTER_CLASSES 1\n-/* Normally the compiler avoids choosing registers that have been\n-   explicitly mentioned in the rtl as spill registers (these\n-   registers are normally those used to pass parameters and return\n-   values).  However, some machines have so few registers of certain\n-   classes that there would not be enough registers to use as spill\n-   registers if this were done.\n-\n-   Define `SMALL_REGISTER_CLASSES' to be an expression with a nonzero\n-   value on these machines.  When this macro has a nonzero value, the\n-   compiler allows registers explicitly used in the rtl to be used as\n-   spill registers but avoids extending the lifetime of these\n-   registers.\n-\n-   It is always safe to define this macro with a nonzero value, but\n-   if you unnecessarily define it, you will reduce the amount of\n-   optimizations that can be performed in some cases.  If you do not\n-   define this macro with a nonzero value when it is required, the\n-   compiler will run out of spill registers and print a fatal error\n-   message.  For most machines, you should not define this macro at\n-   all.  */\n \n #define CLASS_LIKELY_SPILLED_P(CLASS)  class_likely_spilled_p(CLASS)\n-/* A C expression whose value is nonzero if pseudos that have been\n-   assigned to registers of class CLASS would likely be spilled\n-   because registers of CLASS are needed for spill registers.\n-\n-   The default value of this macro returns 1 if CLASS has exactly one\n-   register and zero otherwise.  On most machines, this default\n-   should be used.  Only define this macro to some other expression\n-   if pseudo allocated by `local-alloc.c' end up in memory because\n-   their hard registers were needed for spill registers.  If this\n-   macro returns nonzero for those classes, those pseudos will only\n-   be allocated by `global.c', which knows how to reallocate the\n-   pseudo to another register.  If there would not be another\n-   register available for reallocation, you should not change the\n-   definition of this macro since the only effect of such a\n-   definition would be to slow down register allocation.  */\n \n #define CLASS_MAX_NREGS(CLASS, MODE)   GET_MODE_SIZE (MODE)\n-/* A C expression for the maximum number of consecutive registers of\n-   class CLASS needed to hold a value of mode MODE.\n-\n-   This is closely related to the macro `HARD_REGNO_NREGS'.  In fact,\n-   the value of the macro `CLASS_MAX_NREGS (CLASS, MODE)' should be\n-   the maximum value of `HARD_REGNO_NREGS (REGNO, MODE)' for all\n-   REGNO values in the class CLASS.\n-\n-   This macro helps control the handling of multiple-word values in\n-   the reload pass.  */\n \n #define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n   ((C) == 'I' ? (VALUE) >= -255 && (VALUE) <= -1 :\t\t\\\n@@ -921,81 +367,20 @@ enum reg_class {\n    (C) == 'P' ? (VALUE) >= 0 && (VALUE) <= 255:\t\t\t\\\n    0)\n \n-/* A C expression that defines the machine-dependent operand\n-   constraint letters (`I', `J', `K', ... `P') that specify\n-   particular ranges of integer values.  If C is one of those\n-   letters, the expression should check that VALUE, an integer, is in\n-   the appropriate range and return 1 if so, 0 otherwise.  If C is\n-   not one of those letters, the value should be 0 regardless of\n-   VALUE.  */\n-\n #define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) 0\n \n-/* `CONST_DOUBLE_OK_FOR_LETTER_P (VALUE, C)'\n-   A C expression that defines the machine-dependent operand\n-   constraint letters that specify particular ranges of\n-   `const_double' values (`G' or `H').\n-\n-   If C is one of those letters, the expression should check that\n-   VALUE, an RTX of code `const_double', is in the appropriate range\n-   and return 1 if so, 0 otherwise.  If C is not one of those\n-   letters, the value should be 0 regardless of VALUE.\n-\n-   `const_double' is used for all floating-point constants and for\n-   `DImode' fixed-point constants.  A given letter can accept either\n-   or both kinds of values.  It can use `GET_MODE' to distinguish\n-   between these kinds.  */\n-\n #define EXTRA_CONSTRAINT(X, C) ip2k_extra_constraint (X, C)\n \n-/* A C expression that defines the optional machine-dependent\n-   constraint letters (``Q', `R', `S', `T', `U') that can'\n-   be used to segregate specific types of operands, usually memory\n-   references, for the target machine.  Normally this macro will not\n-   be defined.  If it is required for a particular target machine, it\n-   should return 1 if VALUE corresponds to the operand type\n-   represented by the constraint letter C.  If C is not defined as an\n-   extra constraint, the value returned should be 0 regardless of\n-   VALUE.\n-\n-   For example, on the ROMP, load instructions cannot have their\n-   output in r0 if the memory reference contains a symbolic address.\n-   Constraint letter `Q' is defined as representing a memory address\n-   that does *not* contain a symbolic address.  An alternative is\n-   specified with a `Q' constraint on the input and `r' on the\n-   output.  The next alternative specifies `m' on the input and a\n-   register class that does not include r0 on the output.  */\n-\n /* This is an undocumented variable which describes\n    how GCC will pop a data.  */\n #define STACK_POP_CODE PRE_INC\n \n #define STACK_PUSH_CODE POST_DEC\n-/* This macro defines the operation used when something is pushed on\n-   the stack.  In RTL, a push operation will be `(set (mem\n-   (STACK_PUSH_CODE (reg sp))) ...)'\n-  \n-   The choices are `PRE_DEC', `POST_DEC', `PRE_INC', and `POST_INC'.\n-   Which of these is correct depends on the stack direction and on\n-   whether the stack pointer points to the last item on the stack or\n-   whether it points to the space for the next item on the stack.\n-  \n-   The default is `PRE_DEC' when `STACK_GROWS_DOWNWARD' is defined,\n-   which is almost always right, and `PRE_INC' otherwise, which is\n-   often wrong.  */\n-\n \n #define STACK_CHECK_BUILTIN\t1\n /* Prologue code will do stack checking as necessary.  */\n   \n #define STARTING_FRAME_OFFSET (0)\t\n-/* Offset from the frame pointer to the first local variable slot to\n-   be allocated.\n-\n-   If `FRAME_GROWS_DOWNWARD', find the next slot's offset by\n-   subtracting the first slot's length from `STARTING_FRAME_OFFSET'.\n-   Otherwise, it is found by adding the length of the first slot to\n-   the value `STARTING_FRAME_OFFSET'.  */\n \n #define FRAME_GROWS_DOWNWARD\t1\n #define STACK_GROWS_DOWNWARD\t1\n@@ -1005,95 +390,29 @@ enum reg_class {\n    pc, etc.  */\n \n #define FIRST_PARM_OFFSET(FUNDECL) 0\n-/* Offset from the argument pointer register to the first argument's\n-   address.  On some machines it may depend on the data type of the\n-   function.\n-\n-   If `ARGS_GROW_DOWNWARD', this is the offset to the location above\n-   the first argument's address.  */\n-\n-/* `STACK_DYNAMIC_OFFSET (FUNDECL)'\n-   Offset from the stack pointer register to an item dynamically\n-   allocated on the stack, e.g., by `alloca'.\n-\n-   The default value for this macro is `STACK_POINTER_OFFSET' plus the\n-   length of the outgoing arguments.  The default is correct for most\n-   machines.  See `function.c' for details.  */\n \n #define STACK_POINTER_OFFSET 1\n /* IP2K stack is post-decremented, so 0(sp) is address of open space\n    and 1(sp) is offset to the location avobe the forst location at which\n    outgoing arguments are placed.  */\n \n #define STACK_BOUNDARY 8\n-/* Define this macro if there is a guaranteed alignment for the stack\n-   pointer on this machine.  The definition is a C expression for the\n-   desired alignment (measured in bits).  This value is used as a\n-   default if PREFERRED_STACK_BOUNDARY is not defined.  */\n \n #define STACK_POINTER_REGNUM REG_SP\n-/* The register number of the stack pointer register, which must also\n-   be a fixed register according to `FIXED_REGISTERS'.  On most\n-   machines, the hardware determines which register this is.  */\n \n #define FRAME_POINTER_REGNUM REG_VFP\n-/* The register number of the frame pointer register, which is used to\n-   access automatic variables in the stack frame.  On some machines,\n-   the hardware determines which register this is.  On other\n-   machines, you can choose any register you wish for this purpose.  */\n-\n #define HARD_FRAME_POINTER_REGNUM REG_FP\n \n #define ARG_POINTER_REGNUM  REG_AP\n-/* The register number of the arg pointer register, which is used to\n-   access the function's argument list.  On some machines, this is\n-   the same as the frame pointer register.  On some machines, the\n-   hardware determines which register this is.  On other machines,\n-   you can choose any register you wish for this purpose.  If this is\n-   not the same register as the frame pointer register, then you must\n-   mark it as a fixed register according to `FIXED_REGISTERS', or\n-   arrange to be able to eliminate it (*note Elimination::.).  */\n \n /* We don't really want to support nested functions.  But we'll crash\n    in various testsuite tests if we don't at least define the register\n    to contain the static chain. The return value register is about as\n    bad a place as any for this.  */\n \n #define STATIC_CHAIN_REGNUM\tREG_RESULT\n-/* Register numbers used for passing a function's static chain\n-   pointer.  If register windows are used, the register number as\n-   seen by the called function is `STATIC_CHAIN_INCOMING_REGNUM',\n-   while the register number as seen by the calling function is\n-   `STATIC_CHAIN_REGNUM'.  If these registers are the same,\n-   `STATIC_CHAIN_INCOMING_REGNUM' need not be defined.\n-\n-   The static chain register need not be a fixed register.\n-\n-   If the static chain is passed in memory, these macros should not be\n-   defined; instead, the next two macros should be defined.  */\n \n #define FRAME_POINTER_REQUIRED (!flag_omit_frame_pointer)\n-/* A C expression which is nonzero if a function must have and use a\n-   frame pointer.  This expression is evaluated  in the reload pass.\n-   If its value is nonzero the function will have a frame pointer.\n-\n-   The expression can in principle examine the current function and\n-   decide according to the facts, but on most machines the constant 0\n-   or the constant 1 suffices.  Use 0 when the machine allows code to\n-   be generated with no frame pointer, and doing so saves some time\n-   or space.  Use 1 when there is no possible advantage to avoiding a\n-   frame pointer.\n-\n-   In certain cases, the compiler does not know how to produce valid\n-   code without a frame pointer.  The compiler recognizes those cases\n-   and automatically gives the function a frame pointer regardless of\n-   what `FRAME_POINTER_REQUIRED' says.  You don't need to worry about\n-   them.\n-\n-   In a function that does not require a frame pointer, the frame\n-   pointer register can be allocated for ordinary usage, unless you\n-   mark it as a fixed register.  See `FIXED_REGISTERS' for more\n-   information.  */\n \n #define ELIMINABLE_REGS\t{ \t\t\t\t\t\\\n         {ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n@@ -1102,226 +421,35 @@ enum reg_class {\n \t{FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},\t\\\n \t{HARD_FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n }\n-/* If defined, this macro specifies a table of register pairs used to\n-   eliminate unneeded registers that point into the stack frame.  If\n-   it is not defined, the only elimination attempted by the compiler\n-   is to replace references to the frame pointer with references to\n-   the stack pointer.\n-\n-   The definition of this macro is a list of structure\n-   initializations, each of which specifies an original and\n-   replacement register.\n-\n-   On some machines, the position of the argument pointer is not\n-   known until the compilation is completed.  In such a case, a\n-   separate hard register must be used for the argument pointer.\n-   This register can be eliminated by replacing it with either the\n-   frame pointer or the argument pointer, depending on whether or not\n-   the frame pointer has been eliminated.\n-\n-   In this case, you might specify:\n-   #define ELIMINABLE_REGS  \\\n-   {{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM}, \\\n-   {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM}, \\\n-   {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n-\n-   Note that the elimination of the argument pointer with the stack\n-   pointer is specified first since that is the preferred elimination.  */\n-\n \n #define CAN_ELIMINATE(FROM, TO) \t\t\t\t\\\n   ((FROM) == HARD_FRAME_POINTER_REGNUM\t\t\t\t\\\n    ? (flag_omit_frame_pointer && !frame_pointer_needed) : 1)\n /* Don't eliminate FP unless we EXPLICITLY_ASKED  */\n \n-/* A C expression that returns nonzero if the compiler is allowed to\n-   try to replace register number FROM-REG with register number\n-   TO-REG.  This macro need only be defined if `ELIMINABLE_REGS' is\n-   defined, and will usually be the constant 1, since most of the\n-   cases preventing register elimination are things that the compiler\n-   already knows about.  */\n-\n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n   ((OFFSET) = ip2k_init_elim_offset ((FROM), (TO)))\n \n-/* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It\n-   specifies the initial difference between the specified pair of\n-   registers.  This macro must be defined if `ELIMINABLE_REGS' is\n-   defined.  */\n-\n #define RETURN_ADDR_RTX(COUNT, X) \\\n   (((COUNT) == 0) ? gen_rtx_REG (HImode, REG_CALLH) : NULL_RTX)\n-/*   A C expression whose value is RTL representing the value of the\n-     return address for the frame COUNT steps up from the current\n-     frame, after the prologue.  FRAMEADDR is the frame pointer of the\n-     COUNT frame, or the frame pointer of the COUNT - 1 frame if\n-     `RETURN_ADDR_IN_PREVIOUS_FRAME' is defined.\n-\n-     The value of the expression must always be the correct address when\n-     COUNT is zero, but may be `NULL_RTX' if there is not way to\n-     determine the return address of other frames.  */\n \n #define PUSH_ROUNDING(NPUSHED) (NPUSHED)\n-/* A C expression that is the number of bytes actually pushed onto the\n-   stack when an instruction attempts to push NPUSHED bytes.\n-\n-   If the target machine does not have a push instruction, do not\n-   define this macro.  That directs GNU CC to use an alternate\n-   strategy: to allocate the entire argument block and then store the\n-   arguments into it.\n-\n-   On some machines, the definition\n-\n-   #define PUSH_ROUNDING(BYTES) (BYTES)\n-\n-   will suffice.  But on other machines, instructions that appear to\n-   push one byte actually push two bytes in an attempt to maintain\n-   alignment.  Then the definition should be\n-\n-   #define PUSH_ROUNDING(BYTES) (((BYTES) + 1) & ~1)  */\n \n #define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) \\\n   ip2k_return_pops_args ((FUNDECL), (FUNTYPE), (SIZE))\n-/* A C expression that should indicate the number of bytes of its own\n-   arguments that a function pops on returning, or 0 if the function\n-   pops no arguments and the caller must therefore pop them all after\n-   the function returns.\n-\n-   FUNDECL is a C variable whose value is a tree node that describes\n-   the function in question.  Normally it is a node of type\n-   `FUNCTION_DECL' that describes the declaration of the function.\n-   From this you can obtain the DECL_MACHINE_ATTRIBUTES of the\n-   function.\n-\n-   FUNTYPE is a C variable whose value is a tree node that describes\n-   the function in question.  Normally it is a node of type\n-   `FUNCTION_TYPE' that describes the data type of the function.\n-   From this it is possible to obtain the data types of the value and\n-   arguments (if known).\n-\n-   When a call to a library function is being considered, FUNDECL\n-   will contain an identifier node for the library function.  Thus, if\n-   you need to distinguish among various library functions, you can\n-   do so by their names.  Note that \"library function\" in this\n-   context means a function used to perform arithmetic, whose name is\n-   known specially in the compiler and was not mentioned in the C\n-   code being compiled.\n-\n-   STACK-SIZE is the number of bytes of arguments passed on the\n-   stack.  If a variable number of bytes is passed, it is zero, and\n-   argument popping will always be the responsibility of the calling\n-   function.\n-\n-   On the VAX, all functions always pop their arguments, so the\n-   definition of this macro is STACK-SIZE.  On the 68000, using the\n-   standard calling convention, no functions pop their arguments, so\n-   the value of the macro is always 0 in this case.  But an\n-   alternative calling convention is available in which functions\n-   that take a fixed number of arguments pop them but other functions\n-   (such as `printf') pop nothing (the caller pops all).  When this\n-   convention is in use, FUNTYPE is examined to determine whether a\n-   function takes a fixed number of arguments.  */\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n-/* A C expression that controls whether a function argument is passed\n-   in a register, and which register.\n-\n-   The arguments are CUM, which summarizes all the previous\n-   arguments; MODE, the machine mode of the argument; TYPE, the data\n-   type of the argument as a tree node or 0 if that is not known\n-   (which happens for C support library functions); and NAMED, which\n-   is 1 for an ordinary argument and 0 for nameless arguments that\n-   correspond to `...' in the called function's prototype.\n-\n-   The value of the expression is usually either a `reg' RTX for the\n-   hard register in which to pass the argument, or zero to pass the\n-   argument on the stack.\n-\n-   For machines like the VAX and 68000, where normally all arguments\n-   are pushed, zero suffices as a definition.\n-\n-   The value of the expression can also be a `parallel' RTX.  This is\n-   used when an argument is passed in multiple locations.  The mode\n-   of the of the `parallel' should be the mode of the entire\n-   argument.  The `parallel' holds any number of `expr_list' pairs;\n-   each one describes where part of the argument is passed.  In each\n-   `expr_list', the first operand can be either a `reg' RTX for the\n-   hard register in which to pass this part of the argument, or zero\n-   to pass the argument on the stack.  If this operand is a `reg',\n-   then the mode indicates how large this part of the argument is.\n-   The second operand of the `expr_list' is a `const_int' which gives\n-   the offset in bytes into the entire argument where this part\n-   starts.\n-\n-   The usual way to make the ANSI library `stdarg.h' work on a machine\n-   where some arguments are usually passed in registers, is to \tcause\n-   nameless arguments to be passed on the stack instead.  This is done\n-   by making `FUNCTION_ARG' return 0 whenever NAMED is 0.\n-\n-   You may use the macro `MUST_PASS_IN_STACK (MODE, TYPE)' in the\n-   definition of this macro to determine if this argument is of a\n-   type that must be passed in the stack.  If `REG_PARM_STACK_SPACE'\n-   is not defined and `FUNCTION_ARG' returns nonzero for such an\n-   argument, the compiler will abort.  If `REG_PARM_STACK_SPACE' is\n-   defined, the argument will be computed in the stack and then\n-   loaded into a register.  */\n \n #define CUMULATIVE_ARGS\tint\n \n-/* A C type for declaring a variable that is used as the first\n-   argument of `FUNCTION_ARG' and other related values.  For some\n-   target machines, the type `int' suffices and can hold the number\n-   of bytes of argument so far.\n-\n-   There is no need to record in `CUMULATIVE_ARGS' anything about the\n-   arguments that have been passed on the stack.  The compiler has\n-   other variables to keep track of that.  For target machines on\n-   which all arguments are passed on the stack, there is no need to\n-   store anything in `CUMULATIVE_ARGS'; however, the data structure\n-   must exist and should not be empty, so use `int'.  */\n-\n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT) \\\n   ((CUM) = 0)\n \n-/* A C statement (sans semicolon) for initializing the variable CUM\n-   for the state at the beginning of the argument list.  The variable\n-   has type `CUMULATIVE_ARGS'.  The value of FNTYPE is the tree node\n-   for the data type of the function which will receive the args, or 0\n-   if the args are to a compiler support library function.  The value\n-   of INDIRECT is nonzero when processing an indirect call, for\n-   example a call through a function pointer.  The value of INDIRECT\n-   is zero for a call to an explicitly named function, a library\n-   function call, or when `INIT_CUMULATIVE_ARGS' is used to find\n-   arguments for the function being compiled.\n-   \n-   When processing a call to a compiler support library function,\n-   LIBNAME identifies which one.  It is a `symbol_ref' rtx which\n-   contains the name of the function, as a string.  LIBNAME is 0 when\n-   an ordinary C function call is being processed.  Thus, each time\n-   this macro is called, either LIBNAME or FNTYPE is nonzero, but\n-   never both of them at once.  */\n-\n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\n \n /* All arguments are passed on stack - do nothing here.  */\n \n-/* A C statement (sans semicolon) to update the summarizer variable\n-   CUM to advance past an argument in the argument list.  The values\n-   MODE, TYPE and NAMED describe that argument.  Once this is done,\n-   the variable CUM is suitable for analyzing the *following*\n-   argument with `FUNCTION_ARG', etc.\n-   \n-   This macro need not do anything if the argument in question was\n-   passed on the stack.  The compiler knows how to track the amount\n-   of stack space used for arguments without any special help.  */\n-\n #define FUNCTION_ARG_REGNO_P(R) 0\n-/* A C expression that is nonzero if REGNO is the number of a hard\n-   register in which function arguments are sometimes passed.  This\n-   does *not* include implicit arguments such as the static chain and\n-   the structure-value address.  On many machines, no registers can be\n-   used for this purpose since all function arguments are pushed on\n-   the stack.  */\n \n #define FUNCTION_VALUE(VALTYPE, FUNC) \t\t\t\t\\\n    ((TYPE_MODE (VALTYPE) == QImode)\t\t\t\t\\\n@@ -1331,115 +459,23 @@ enum reg_class {\n /* Because functions returning 'char' actually widen to 'int', we have to\n    use $81 as the return location if we think we only have a 'char'.  */\n \n-/* A C expression to create an RTX representing the place where a\n-   function returns a value of data type VALTYPE.  VALTYPE is a tree\n-   node representing a data type.  Write `TYPE_MODE (VALTYPE)' to get\n-   the machine mode used to represent that type.  On many machines,\n-   only the mode is relevant.  (Actually, on most machines, scalar\n-   values are returned in the same place regardless of mode).\n-\n-   The value of the expression is usually a `reg' RTX for the hard\n-   register where the return value is stored.  The value can also be a\n-   `parallel' RTX, if the return value is in multiple places.  See\n-   `FUNCTION_ARG' for an explanation of the `parallel' form.\n-\n-   If `PROMOTE_FUNCTION_RETURN' is defined, you must apply the same\n-   promotion rules specified in `PROMOTE_MODE' if VALTYPE is a scalar\n-   type.\n-\n-   If the precise function being called is known, FUNC is a tree node\n-   (`FUNCTION_DECL') for it; otherwise, FUNC is a null pointer.  This\n-   makes it possible to use a different value-returning convention\n-   for specific functions when all their calls are known.\n-\n-   `FUNCTION_VALUE' is not used for return vales with aggregate data\n-   types, because these are returned in another way.  See\n-   `STRUCT_VALUE_REGNUM' and related macros, below.  */\n-\n #define LIBCALL_VALUE(MODE)  gen_rtx_REG ((MODE), REG_RESULT)\n-/* A C expression to create an RTX representing the place where a\n-   library function returns a value of mode MODE.  If the precise\n-   function being called is known, FUNC is a tree node\n-   (`FUNCTION_DECL') for it; otherwise, FUNC is a null pointer.  This\n-   makes it possible to use a different value-returning convention\n-   for specific functions when all their calls are known.\n-\n-   Note that \"library function\" in this context means a compiler\n-   support routine, used to perform arithmetic, whose name is known\n-   specially by the compiler and was not mentioned in the C code being\n-   compiled.\n-\n-   The definition of `LIBRARY_VALUE' need not be concerned aggregate\n-   data types, because none of the library functions returns such\n-   types.  */\n \n #define FUNCTION_VALUE_REGNO_P(N) ((N) == REG_RESULT)\n-/* A C expression that is nonzero if REGNO is the number of a hard\n-   register in which the values of called function may come back.\n-\n-   A register whose use for returning values is limited to serving as\n-   the second of a pair (for a value of type `double', say) need not\n-   be recognized by this macro.  So for most machines, this definition\n-   suffices:\n-\n-   #define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)\n-\n-   If the machine has register windows, so that the caller and the\n-   called function use different registers for the return value, this\n-   macro should recognize only the caller's register numbers.  */\n \n #define RETURN_IN_MEMORY(TYPE) \\\n   ((TYPE_MODE (TYPE) == BLKmode) ? int_size_in_bytes (TYPE) > 8 : 0)\n-/* A C expression which can inhibit the returning of certain function\n-   values in registers, based on the type of value.  A nonzero value\n-   says to return the function value in memory, just as large\n-   structures are always returned.  Here TYPE will be a C expression\n-   of type `tree', representing the data type of the value.\n-\n-   Note that values of mode `BLKmode' must be explicitly handled by\n-   this macro.  Also, the option `-fpcc-struct-return' takes effect\n-   regardless of this macro.  On most systems, it is possible to\n-   leave the macro undefined; this causes a default definition to be\n-   used, whose value is the constant 1 for `BLKmode' values, and 0\n-   otherwise.\n-\n-   Do not use this macro to indicate that structures and unions\n-   should always be returned in memory.  You should instead use\n-   `DEFAULT_PCC_STRUCT_RETURN' to indicate this.  */\n \n /* Indicate that large structures are passed by reference.  */\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM,MODE,TYPE,NAMED)\t0\n \n-\n #define DEFAULT_PCC_STRUCT_RETURN 0\n-/* Define this macro to be 1 if all structure and union return values\n-   must be in memory.  Since this results in slower code, this should\n-   be defined only if needed for compatibility with other compilers\n-   or with an ABI.  If you define this macro to be 0, then the\n-   conventions used for structure and union return values are decided\n-   by the `RETURN_IN_MEMORY' macro.\n-\n-   If not defined, this defaults to the value 1.  */\n \n #define STRUCT_VALUE 0\n-/* If the structure value address is not passed in a register, define\n-   `STRUCT_VALUE' as an expression returning an RTX for the place\n-   where the address is passed.  If it returns 0, the address is\n-   passed as an \"invisible\" first argument.  */\n \n #define STRUCT_VALUE_INCOMING 0\n-/* If the incoming location is not a register, then you should define\n-   `STRUCT_VALUE_INCOMING' as an expression for an RTX for where the\n-   called function should find the value.  If it should find the\n-   value on the stack, define this to create a `mem' which refers to\n-   the frame pointer.  A definition of 0 means that the address is\n-   passed as an \"invisible\" first argument.  */\n \n #define EPILOGUE_USES(REGNO) 0\n-/* Define this macro as a C expression that is nonzero for registers\n-   are used by the epilogue or the `return' pattern.  The stack and\n-   frame pointer registers are already be assumed to be used as\n-   needed.  */\n \n #define SETUP_INCOMING_VARARGS(ARGS_SO_FAR,MODE,TYPE,\t\t\\\n \t\t\t       PRETEND_ARGS_SIZE,SECOND_TIME)\t\\\n@@ -1453,21 +489,7 @@ enum reg_class {\n \n #define CONSTANT_ADDRESS_P(X) CONSTANT_P (X)\n \n-/* A C expression that is 1 if the RTX X is a constant which is a\n-   valid address.  On most machines, this can be defined as\n-   `CONSTANT_P (X)', but a few machines are more restrictive in which\n-   constant addresses are supported.\n-\n-   `CONSTANT_P' accepts integer-values expressions whose values are\n-   not explicitly known, such as `symbol_ref', `label_ref', and\n-   `high' expressions and `const' arithmetic expressions, in addition\n-   to `const_int' and `const_double' expressions.  */\n-\n #define MAX_REGS_PER_ADDRESS 1\n-/* A number, the maximum number of registers that can appear in a\n-   valid memory address.  Note that it is up to you to specify a\n-   value equal to the maximum number that `GO_IF_LEGITIMATE_ADDRESS'\n-   would ever accept.  */\n \n #ifdef REG_OK_STRICT\n #  define GO_IF_LEGITIMATE_ADDRESS(MODE, OPERAND, ADDR)\t\\\n@@ -1482,74 +504,6 @@ enum reg_class {\n     goto ADDR;\t\t\t\t\t\t\\\n }\n #endif\n-/* A C compound statement with a conditional `goto LABEL;' executed\n-   if X (an RTX) is a legitimate memory address on the target machine\n-   for a memory operand of mode MODE.\n-\n-   It usually pays to define several simpler macros to serve as\n-   subroutines for this one.  Otherwise it may be too complicated to\n-   understand.\n-\n-   This macro must exist in two variants: a strict variant and a\n-   non-strict one.  The strict variant is used in the reload pass.  It\n-   must be defined so that any pseudo-register that has not been\n-   allocated a hard register is considered a memory reference.  In\n-   contexts where some kind of register is required, a pseudo-register\n-   with no hard register must be rejected.\n-\n-   The non-strict variant is used in other passes.  It must be\n-   defined to accept all pseudo-registers in every context where some\n-   kind of register is required.\n-\n-   Compiler source files that want to use the strict variant of this\n-   macro define the macro `REG_OK_STRICT'.  You should use an `#ifdef\n-   REG_OK_STRICT' conditional to define the strict variant in that\n-   case and the non-strict variant otherwise.\n-\n-   Subroutines to check for acceptable registers for various purposes\n-   (one for base registers, one for index registers, and so on) are\n-   typically among the subroutines used to define\n-   `GO_IF_LEGITIMATE_ADDRESS'.  Then only these subroutine macros\n-   need have two variants; the higher levels of macros may be the\n-   same whether strict or not.\n-\n-   Normally, constant addresses which are the sum of a `symbol_ref'\n-   and an integer are stored inside a `const' RTX to mark them as\n-   constant.  Therefore, there is no need to recognize such sums\n-   specifically as legitimate addresses.  Normally you would simply\n-   recognize any `const' as legitimate.\n-\n-   Usually `PRINT_OPERAND_ADDRESS' is not prepared to handle constant\n-   sums that are not marked with  `const'.  It assumes that a naked\n-   `plus' indicates indexing.  If so, then you *must* reject such\n-   naked constant sums as illegitimate addresses, so that none of\n-   them will be given to `PRINT_OPERAND_ADDRESS'.\n-\n-   On some machines, whether a symbolic address is legitimate depends\n-   on the section that the address refers to.  On these machines,\n-   define the macro `ENCODE_SECTION_INFO' to store the information\n-   into the `symbol_ref', and then check for it here.  When you see a\n-   `const', you will have to look inside it to find the `symbol_ref'\n-   in order to determine the section.  *Note Assembler Format::.\n-\n-   The best way to modify the name string is by adding text to the\n-   beginning, with suitable punctuation to prevent any ambiguity.\n-   Allocate the new name in `saveable_obstack'.  You will have to\n-   modify `ASM_OUTPUT_LABELREF' to remove and decode the added text\n-   and output the name accordingly, and define `STRIP_NAME_ENCODING'\n-   to access the original name string.\n-\n-   You can check the information stored here into the `symbol_ref' in\n-   the definitions of the macros `GO_IF_LEGITIMATE_ADDRESS' and\n-   `PRINT_OPERAND_ADDRESS'.  */\n-\n-/* A C expression that is nonzero if X (assumed to be a `reg' RTX) is\n-   valid for use as a base register.  For hard registers, it should\n-   always accept those which the hardware permits and reject the\n-   others.  Whether the macro accepts or rejects pseudo registers\n-   must be controlled by `REG_OK_STRICT' as described above.  This\n-   usually requires two variant definitions, of which `REG_OK_STRICT'\n-   controls the one actually used.  */\n \n #define REG_OK_FOR_BASE_STRICT_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n \n@@ -1567,39 +521,6 @@ enum reg_class {\n #endif\n \n #define REG_OK_FOR_INDEX_P(X) 0\n-/* A C expression that is nonzero if X (assumed to be a `reg' RTX) is\n-   valid for use as an index register.\n-\n-   The difference between an index register and a base register is\n-   that the index register may be scaled.  If an address involves the\n-   sum of two registers, neither one of them scaled, then either one\n-   may be labeled the \"base\" and the other the \"index\"; but whichever\n-   labeling is used must fit the machine's constraints of which\n-   registers may serve in each capacity.  The compiler will try both\n-   labelings, looking for one that is valid, and will reload one or\n-   both registers only if neither labeling works.  */\n-\n-\n-/* A C compound statement that attempts to replace X with a valid\n-   memory address for an operand of mode MODE.  WIN will be a C\n-   statement label elsewhere in the code; the macro definition may use\n-\n-   GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN);\n-\n-   to avoid further processing if the address has become legitimate.\n-\n-   X will always be the result of a call to `break_out_memory_refs',\n-   and OLDX will be the operand that was given to that function to\n-   produce X.\n-\n-   The code generated by this macro should not alter the substructure\n-   of X.  If it transforms X into a more legitimate form, it should\n-   assign X (which will always be a C variable) a new value.\n-\n-   It is not necessary for this macro to come up with a legitimate\n-   address.  The compiler has standard ways of doing so in all cases.\n-   In fact, it is safe for this macro to do nothing.  But often a\n-   machine-dependent strategy can generate better code.  */\n \n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\\\n do { rtx orig_x = (X);\t\t\t\t\t\\\n@@ -1681,302 +602,68 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t     \\\n    }\t\t\t\t\t\t\t\t\t     \\\n }\n-/* A C compound statement that attempts to replace X, which is an\n-   address that needs reloading, with a valid memory address for an\n-   operand of mode MODE.  WIN will be a C statement label elsewhere\n-   in the code.  It is not necessary to define this macro, but it \n-   might be useful for performance reasons.\n-\n-   For example, on the i386, it is sometimes possible to use a single\n-   reload register instead of two by reloading a sum of two pseudo\n-   registers into a register.  On the other hand, for number of RISC\n-   processors offsets are limited so that often an intermediate\n-   address needs to be generated in order to address a stack slot.\n-   By defining LEGITIMIZE_RELOAD_ADDRESS appropriately, the\n-   intermediate addresses generated for adjacent some stack slots can\n-   be made identical, and thus be shared.\n-\n-   *Note*: This macro should be used with caution.  It is necessary\n-   to know something of how reload works in order to effectively use\n-   this, and it is quite easy to produce macros that build in too\n-   much knowledge of reload internals.\n-\n-   *Note*: This macro must be able to reload an address created by a\n-   previous invocation of this macro.  If it fails to handle such\n-   addresses then the compiler may generate incorrect code or abort.\n-\n-   The macro definition should use `push_reload' to indicate parts\n-   that need reloading; OPNUM, TYPE and IND_LEVELS are usually\n-   suitable to be passed unaltered to `push_reload'.\n-\n-   The code generated by this macro must not alter the substructure of\n-   X.  If it transforms X into a more legitimate form, it should\n-   assign X (which will always be a C variable) a new value.  This\n-   also applies to parts that you change indirectly by calling\n-   `push_reload'.\n-\n-   The macro definition may use `strict_memory_address_p' to test if\n-   the address has become legitimate.\n-\n-   If you want to change only a part of X, one standard way of doing\n-   this is to use `copy_rtx'.  Note, however, that is unshares only a\n-   single level of rtl.  Thus, if the part to be changed is not at the\n-   top level, you'll need to replace first the top leve It is not\n-   necessary for this macro to come up with a legitimate address;\n-   but often a machine-dependent strategy can generate better code.  */\n-\t\n+\n #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\t\\\n     do {\t\t\t\t\t\t\t\\\n \tif (ip2k_mode_dependent_address (ADDR)) goto LABEL;\t\\\n     } while (0)\n \n-/* A C statement or compound statement with a conditional `goto\n-   LABEL;' executed if memory address X (an RTX) can have different\n-   meanings depending on the machine mode of the memory reference it\n-   is used for or if the address is valid for some modes but not\n-   others.\n-\n-   Autoincrement and autodecrement addresses typically have\n-   mode-dependent effects because the amount of the increment or\n-   decrement is the size of the operand being addressed.  Some\n-   machines have other mode-dependent addresses.  Many RISC machines\n-   have no mode-dependent addresses.\n-\n-   You may assume that ADDR is a valid address for the machine.  */\n-\n #define LEGITIMATE_CONSTANT_P(X) 1\n-/* A C expression that is nonzero if X is a legitimate constant for\n-   an immediate operand on the target machine.  You can assume that X\n-   satisfies `CONSTANT_P', so you need not check this.  In fact, `1'\n-   is a suitable definition for this macro on machines where anything\n-   `CONSTANT_P' is valid.  */\n \n #define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2) 7\n-/* A C expression for the cost of moving data from a register in class\n-   FROM to one in class TO.  The classes are expressed using the\n-   enumeration values such as `GENERAL_REGS'.  A value of 2 is the\n-   default; other values are interpreted relative to that.\n-\n-   It is not required that the cost always equal 2 when FROM is the\n-   same as TO; on some machines it is expensive to move between\n-   registers if they are not general registers.\n-\n-   If reload sees an insn consisting of a single `set' between two\n-   hard registers, and if `REGISTER_MOVE_COST' applied to their\n-   classes returns a value of 2, reload does not check to ensure that\n-   the constraints of the insn are met.  Setting a cost of other than\n-   2 will allow reload to verify that the constraints are met.  You\n-   should do this if the `movM' pattern's constraints do not allow\n-   such copying.  */\n \n #define MEMORY_MOVE_COST(MODE,CLASS,IN) 6\n-/* A C expression for the cost of moving data of mode M between a\n-   register and memory.  A value of 4 is the default; this cost is\n-   relative to those in `REGISTER_MOVE_COST'.\n-\n-   If moving between registers and memory is more expensive than\n-   between two registers, you should define this macro to express the\n-   relative cost.  */\n \n #define SLOW_BYTE_ACCESS 0\n-/* Define this macro as a C expression which is nonzero if accessing\n-   less than a word of memory (i.e. a `char' or a `short') is no\n-   faster than accessing a word of memory, i.e., if such access\n-   require more than one instruction or if there is no difference in\n-   cost between byte and (aligned) word loads.\n-\n-   When this macro is not defined, the compiler will access a field by\n-   finding the smallest containing object; when it is defined, a\n-   fullword load will be used if alignment permits.  Unless bytes\n-   accesses are faster than word accesses, using word accesses is\n-   preferable since it may eliminate subsequent memory access if\n-   subsequent accesses occur to other fields in the same word of the\n-   structure, but to different bytes.\n-\n-   `SLOW_ZERO_EXTEND'\n-   Define this macro if zero-extension (of a `char' or `short' to an\n-   `int') can be done faster if the destination is a register that is\n-   known to be zero.\n-\n-   If you define this macro, you must have instruction patterns that\n-   recognize RTL structures like this:\n-\n-   (set (strict_low_part (subreg:QI (reg:SI ...) 0)) ...)\n-\n-   and likewise for `HImode'.\n-\n-   `SLOW_UNALIGNED_ACCESS'\n-   Define this macro to be the value 1 if unaligned accesses have a\n-   cost many times greater than aligned accesses, for example if they\n-   are emulated in a trap handler.\n-\n-   When this macro is nonzero, the compiler will act as if\n-   `STRICT_ALIGNMENT' were nonzero when generating code for block\n-   moves.  This can cause significantly more instructions to be\n-   produced.  Therefore, do not set this macro nonzero if unaligned\n-   accesses only add a cycle or two to the time for a memory access.\n-\n-   If the value of this macro is always zero, it need not be defined.\n-\n-   `MOVE_RATIO'\n-   The number of scalar move insns which should be generated instead\n-   of a string move insn or a library call.  Increasing the value\n-   will always make code faster, but eventually incurs high cost in\n-   increased code size.\n-\n-   If you don't define this, a reasonable default is used.  */\n \n #define NO_FUNCTION_CSE\n-/* Define this macro if it is as good or better to call a constant\n-   function address than to call an address kept in a register.  */\n-\n #define NO_RECURSIVE_FUNCTION_CSE\n-/* Define this macro if it is as good or better for a function to call\n-   itself with an explicit address than to call an address kept in a\n-   register.\n-\n-   `ADJUST_COST (INSN, LINK, DEP_INSN, COST)'\n-   A C statement (sans semicolon) to update the integer variable COST\n-   based on the relationship between INSN that is dependent on\n-   DEP_INSN through the dependence LINK.  The default is to make no\n-   adjustment to COST.  This can be used for example to specify to\n-   the scheduler that an output- or anti-dependence does not incur\n-   the same cost as a data-dependence.\n-\n-   `ADJUST_PRIORITY (INSN)'\n-   A C statement (sans semicolon) to update the integer scheduling\n-   priority `INSN_PRIORITY(INSN)'.  Reduce the priority to execute\n-   the INSN earlier, increase the priority to execute INSN later.\n-   Do not define this macro if you do not need to adjust the\n-   scheduling priorities of insns.  */\n \n #define TEXT_SECTION_ASM_OP \".text\"\n-/* A C expression whose value is a string containing the assembler\n-   operation that should precede instructions and read-only data.\n-   Normally `\".text\"' is right.  */\n-\n #define DATA_SECTION_ASM_OP \".data\"\n-/* A C expression whose value is a string containing the assembler\n-   operation to identify the following data as writable initialized\n-   data.  Normally `\".data\"' is right.  */\n \n #define JUMP_TABLES_IN_TEXT_SECTION 1\n-/* Define this macro if jump tables (for `tablejump' insns) should be\n-   output in the text section, along with the assembler instructions.\n-   Otherwise, the readonly data section is used.\n-\n-   This macro is irrelevant if there is no separate readonly data\n-   section.  */\n \n #define ASM_COMMENT_START \" ; \"\n-/* A C string constant describing how to begin a comment in the target\n-   assembler language.  The compiler assumes that the comment will\n-   end at the end of the line.  */\n \n #define ASM_APP_ON \"/* #APP */\\n\"\n-/* A C string constant for text to be output before each `asm'\n-   statement or group of consecutive ones.  Normally this is\n-   `\"#APP\"', which is a comment that has no effect on most assemblers\n-   but tells the GNU assembler that it must check the lines that\n-   follow for all valid assembler constructs.  */\n \n #define ASM_APP_OFF \"/* #NOAPP */\\n\"\n-/* A C string constant for text to be output after each `asm'\n-   statement or group of consecutive ones.  Normally this is\n-   `\"#NO_APP\"', which tells the GNU assembler to resume making the\n-   time-saving assumptions that are valid for ordinary compiler\n-   output.  */\n \n #define ASM_OUTPUT_DOUBLE(STREAM, VALUE) \\\n   fprintf ((STREAM), \".double %.20e\\n\", (VALUE))\n #define ASM_OUTPUT_FLOAT(STREAM, VALUE) \\\n   asm_output_float ((STREAM), (VALUE))\n \n-/* `ASM_OUTPUT_LONG_DOUBLE (STREAM, VALUE)'\n-   `ASM_OUTPUT_THREE_QUARTER_FLOAT (STREAM, VALUE)'\n-   `ASM_OUTPUT_SHORT_FLOAT (STREAM, VALUE)'\n-   `ASM_OUTPUT_BYTE_FLOAT (STREAM, VALUE)'\n-   A C statement to output to the stdio stream STREAM an assembler\n-   instruction to assemble a floating-point constant of `TFmode',\n-   `DFmode', `SFmode', `TQFmode', `HFmode', or `QFmode',\n-   respectively, whose value is VALUE.  VALUE will be a C expression\n-   of type `REAL_VALUE_TYPE'.  Macros such as\n-   `REAL_VALUE_TO_TARGET_DOUBLE' are useful for writing these\n-   definitions.  */\n-\n #define ASM_OUTPUT_INT(FILE, VALUE)\t\t\t\\\n  ( fprintf ((FILE), \"\\t.long \"),\t\t\t\\\n    output_addr_const ((FILE), (VALUE)),\t\t\t\\\n    fputs (\"\\n\", (FILE)))\n \n- /* Likewise for `short' and `char' constants.  */\n-\n #define ASM_OUTPUT_SHORT(FILE,VALUE) \\\n   asm_output_short ((FILE), (VALUE))\n #define ASM_OUTPUT_CHAR(FILE,VALUE) \\\n   asm_output_char ((FILE), (VALUE))\n \n-/* `ASM_OUTPUT_QUADRUPLE_INT (STREAM, EXP)'\n-   A C statement to output to the stdio stream STREAM an assembler\n-   instruction to assemble an integer of 16, 8, 4, 2 or 1 bytes,\n-   respectively, whose value is VALUE.  The argument EXP will be an\n-   RTL expression which represents a constant value.  Use\n-   `output_addr_const (STREAM, EXP)' to output this value as an\n-   assembler expression.\n-\n-   For sizes larger than `UNITS_PER_WORD', if the action of a macro\n-   would be identical to repeatedly calling the macro corresponding to\n-   a size of `UNITS_PER_WORD', once for each word, you need not define\n-   the macro.  */\n-\n #define ASM_OUTPUT_BYTE(FILE,VALUE) \\\n   asm_output_byte ((FILE), (VALUE))\n-/* A C statement to output to the stdio stream STREAM an assembler\n-   instruction to assemble a single byte containing the number VALUE.  */\n \n #define IS_ASM_LOGICAL_LINE_SEPARATOR(C) \\\n   ((C) == '\\n' || ((C) == '$'))\n-/* Define this macro as a C expression which is nonzero if C is used\n-   as a logical line separator by the assembler.\n-\n-   If you do not define this macro, the default is that only the\n-   character `;' is treated as a logical line separator.  */\n \n #define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)\t\\\n do {\t\t\t\t\t\t\t\\\n      fputs (\"\\t.comm \", (STREAM));\t\t\t\\\n      assemble_name ((STREAM), (NAME));\t\t\t\\\n      fprintf ((STREAM), \",%d\\n\", (int)(SIZE));\t\t\\\n } while (0)\n-/* A C statement (sans semicolon) to output to the stdio stream\n-   STREAM the assembler definition of a common-label named NAME whose\n-   size is SIZE bytes.  The variable ROUNDED is the size rounded up\n-   to whatever alignment the caller wants.\n-\n-   Use the expression `assemble_name (STREAM, NAME)' to output the\n-   name itself; before and after that, output the additional\n-   assembler syntax for defining the name, and a newline.\n-\n-   This macro controls how the assembler definitions of uninitialized\n-   common global variables are output.  */\n \n #define ASM_OUTPUT_LOCAL(STREAM, NAME, SIZE, ROUNDED)\t\\\n do {\t\t\t\t\t\t\t\\\n      fputs (\"\\t.lcomm \", (STREAM));\t\t\t\\\n      assemble_name ((STREAM), (NAME));\t\t\t\\\n      fprintf ((STREAM), \",%d\\n\", (int)(SIZE));\t\t\\\n } while (0)\n-/* A C statement (sans semicolon) to output to the stdio stream\n-   STREAM the assembler definition of a local-common-label named NAME\n-   whose size is SIZE bytes.  The variable ROUNDED is the size\n-   rounded up to whatever alignment the caller wants.\n-\n-   Use the expression `assemble_name (STREAM, NAME)' to output the\n-   name itself; before and after that, output the additional\n-   assembler syntax for defining the name, and a newline.\n-\n-   This macro controls how the assembler definitions of uninitialized\n-   static variables are output.  */\n \n #undef WEAK_ASM_OP\n #define WEAK_ASM_OP\t\".weak\"\n@@ -1987,14 +674,6 @@ do {\t\t\t\t\t\t\t\\\n     if (!flag_inhibit_size_directive)\t\t\t\t\\\n       ASM_OUTPUT_MEASURED_SIZE (FILE, FNAME);\t\t\t\\\n   } while (0)\n-/* A C statement (sans semicolon) to output to the stdio stream\n-   STREAM any text necessary for declaring the size of a function\n-   which is being defined.  The argument NAME is the name of the\n-   function.  The argument DECL is the `FUNCTION_DECL' tree node\n-   representing the function.\n-\n-   If this macro is not defined, then the function size is not\n-   defined.  */\n \n #define ESCAPES \\\n \"\\1\\1\\1\\1\\1\\1\\1\\1btn\\1fr\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n@@ -2057,68 +736,20 @@ do {\t\t\t\t\t\t\t\\\n   \"$f8\",\"$f9\",\"$fa\",\"$fb\",\"$fc\",\"$fd\",\"$fe\",\"$ff\",\t\t\\\n   \"vfph\",\"vfpl\",\"vaph\",\"vapl\"}\n \n-/* A C initializer containing the assembler's names for the machine\n-   registers, each one as a C string constant.  This is what\n-   translates register numbers in the compiler into assembler\n-   language.  */\n-\n #define PRINT_OPERAND(STREAM, X, CODE) \\\n   print_operand ((STREAM), (X), (CODE))\n-/* A C compound statement to output to stdio stream STREAM the\n-   assembler syntax for an instruction operand X.  X is an RTL\n-   expression.\n-\n-   CODE is a value that can be used to specify one of several ways of\n-   printing the operand.  It is used when identical operands must be\n-   printed differently depending on the context.  CODE comes from the\n-   `%' specification that was used to request printing of the\n-   operand.  If the specification was just `%DIGIT' then CODE is 0;\n-   if the specification was `%LTR DIGIT' then CODE is the ASCII code\n-   for LTR.\n-\n-   If X is a register, this macro should print the register's name.\n-   The names can be found in an array `reg_names' whose type is `char\n-   *[]'.  `reg_names' is initialized from `REGISTER_NAMES'.\n-\n-   When the machine description has a specification `%PUNCT' (a `%'\n-   followed by a punctuation character), this macro is called with a\n-   null pointer for X and the punctuation character for CODE.  */\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CODE) \\\n   ((CODE) == '<' || (CODE) == '>')\n \n-/* A C expression which evaluates to true if CODE is a valid\n-   punctuation character for use in the `PRINT_OPERAND' macro.  If\n-   `PRINT_OPERAND_PUNCT_VALID_P' is not defined, it means that no\n-   punctuation characters (except for the standard one, `%') are used\n-   in this way.  */\n-\n #define PRINT_OPERAND_ADDRESS(STREAM, X) print_operand_address(STREAM, X)\n-/* A C compound statement to output to stdio stream STREAM the\n-   assembler syntax for an instruction operand that is a memory\n-   reference whose address is X.  X is an RTL expression.\n-\n-   On some machines, the syntax for a symbolic address depends on the\n-   section that the address refers to.  On these machines, define the\n-   macro `ENCODE_SECTION_INFO' to store the information into the\n-   `symbol_ref', and then check for it here.  *Note Assembler\n-   Format::.  */\n \n /* Since register names don't have a prefix, we must preface all\n    user identifiers with the '_' to prevent confusion.  */\n \n #undef USER_LABEL_PREFIX\n #define USER_LABEL_PREFIX \"_\"\n #define LOCAL_LABEL_PREFIX \".L\"\n-/* `LOCAL_LABEL_PREFIX'\n-   `REGISTER_PREFIX'\n-   `IMMEDIATE_PREFIX'\n-   If defined, C string expressions to be used for the `%R', `%L',\n-   `%U', and `%I' options of `asm_fprintf' (see `final.c').  These\n-   are useful when a single `md' file must support multiple assembler\n-   formats.  In that case, the various `tm.h' files can define these\n-   macros differently.  */\n-\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)\t\t\\\n   asm_fprintf ((STREAM), \"\\tpage\\t%L%d\\n\\tjmp\\t%L%d\\n\", (VALUE), (VALUE))\n@@ -2131,101 +762,34 @@ do {\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE)\t\t\t\t\\\n   asm_fprintf ((STREAM), \"\\tpage\\t%L%d\\n\\tjmp\\t%L%d\\n\", (VALUE), (VALUE))\n \n-/* This macro should be provided on machines where the addresses in a\n-   dispatch table are absolute.\n-\n-   The definition should be a C statement to output to the stdio\n-   stream STREAM an assembler pseudo-instruction to generate a\n-   reference to a label.  VALUE is the number of an internal label\n-   whose definition is output using `(*targetm.asm_out.internal_label)'.  For\n-   example,\n-\n-   fprintf ((STREAM), \"\\t.word L%d\\n\", (VALUE))  */\n-\n #define ASM_OUTPUT_ALIGN(STREAM, POWER) \\\n   fprintf ((STREAM), \"\\t.align %d\\n\", (POWER))\n-/* A C statement to output to the stdio stream STREAM an assembler\n-   command to advance the location counter to a multiple of 2 to the\n-   POWER bytes.  POWER will be a C expression of type `int'.  */\n \n /* Since instructions are 16 bit word addresses, we should lie and claim that\n    the dispatch vectors are in QImode.  Otherwise the offset into the jump\n    table will be scaled by the MODE_SIZE.  */\n \n #define CASE_VECTOR_MODE QImode\n-/* An alias for a machine mode name.  This is the machine mode that\n-   elements of a jump-table should have.  */\n-\n-\n-/* `CASE_VALUES_THRESHOLD'\n-   Define this to be the smallest number of different values for\n-   which it is best to use a jump-table instead of a tree of\n-   conditional branches.  The default is four for machines with a\n-   `casesi' instruction and five otherwise.  This is best for most\n-   machines.  */\n \n #undef WORD_REGISTER_OPERATIONS\n-/* Define this macro if operations between registers with integral\n-   mode smaller than a word are always performed on the entire\n-   register.  Most RISC machines have this property and most CISC\n-   machines do not.  */\n \n #define MOVE_MAX 1\n-/* The maximum number of bytes that a single instruction can move\n-   quickly between memory and registers or between two memory\n-   locations.  */\n \n #define MOVE_RATIO\t\t3\n /* MOVE_RATIO is the number of move instructions that is better than a\n    block move.  Make this small on the IP2k, since the code size grows very\n    large with each move.  */\n \n #define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-/* A C expression which is nonzero if on this machine it is safe to\n-   \"convert\" an integer of INPREC bits to one of OUTPREC bits (where\n-   OUTPREC is smaller than INPREC) by merely operating on it as if it\n-   had only OUTPREC bits.\n-\n-   On many machines, this expression can be 1.\n-\n-   When `TRULY_NOOP_TRUNCATION' returns 1 for a pair of sizes for\n-   modes for which `MODES_TIEABLE_P' is 0, suboptimal code can result.\n-   If this is the case, making `TRULY_NOOP_TRUNCATION' return 0 in\n-   such cases may improve things.  */\n \n #define Pmode HImode\n-/* An alias for the machine mode for pointers.  On most machines,\n-   define this to be the integer mode corresponding to the width of a\n-   hardware pointer; `SImode' on 32-bit machine or `DImode' on 64-bit\n-   machines.  On some machines you must define this to be one of the\n-   partial integer modes, such as `PSImode'.\n-\n-   The width of `Pmode' must be at least as large as the value of\n-   `POINTER_SIZE'.  If it is not equal, you must define the macro\n-   `POINTERS_EXTEND_UNSIGNED' to specify how pointers are extended to\n-   `Pmode'.  */\n \n #define FUNCTION_MODE HImode\n-/* An alias for the machine mode used for memory references to\n-   functions being called, in `call' RTL expressions.  On most\n-   machines this should be `QImode'.  */\n \n #define INTEGRATE_THRESHOLD(DECL) \\\n   (1 + (3 * list_length (DECL_ARGUMENTS (DECL)) / 2))\n-/* A C expression for the maximum number of instructions above which\n-   the function DECL should not be inlined.  DECL is a\n-   `FUNCTION_DECL' node.\n-\n-   The default definition of this macro is 64 plus 8 times the number\n-   of arguments that the function accepts.  Some people think a larger\n-   threshold should be used on RISC machines.  */\n \n #define DOLLARS_IN_IDENTIFIERS 0\n-/* Define this macro to control use of the character `$' in identifier\n-   names.  0 means `$' is not allowed by default; 1 means it is\n-   allowed.  1 is the default; there is no need to define this macro\n-   in that case.  This macro controls the compiler proper; it does\n-   not affect the preprocessor.  */\n \n extern int ip2k_reorg_in_progress;\n /* Flag if we're in the middle of IP2k-specific reorganization.  */\n@@ -2260,14 +824,8 @@ extern int ip2k_reorg_merge_qimode;\n \n #define TRAMPOLINE_TEMPLATE(FILE) abort ()\n \n-/* Length in units of the trampoline for entering a nested function.  */\n-\n #define TRAMPOLINE_SIZE 4\n \n-/* Emit RTL insns to initialize the variable parts of a trampoline.\n-   FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function.  */\n-\n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   emit_move_insn (gen_rtx_MEM (HImode, plus_constant ((TRAMP), 2)),\t\\\n@@ -2289,21 +847,11 @@ extern int ip2k_reorg_merge_qimode;\n   fprintf ((FILE), \"/* profiler %d */\", (LABELNO))\n \n #define TARGET_MEM_FUNCTIONS\n-/* Define this macro if GNU CC should generate calls to the System V\n-   (and ANSI C) library functions `memcpy' and `memset' rather than\n-   the BSD functions `bcopy' and `bzero'.  */\n-\n \n #undef ENDFILE_SPEC\n #undef LINK_SPEC\n #undef STARTFILE_SPEC\n \n-/* Another C string constant used much like `LINK_SPEC'.  The\n-   difference between the two is that `ENDFILE_SPEC' is used at the\n-   very end of the command given to the linker.\n-\n-   Do not define this macro if it does not need to do anything.  */\n-\n #if defined(__STDC__) || defined(ALMOST_STDC)\n #define AS2(a,b,c) #a \"\\t\" #b \",\" #c\n #define AS1(a,b) #a \"\\t\" #b\n@@ -2315,10 +863,6 @@ extern int ip2k_reorg_merge_qimode;\n #define OUT_AS2(a,b,c) output_asm_insn (AS2 (a,b,c), operands)\n #define CR_TAB \"\\n\\t\"\n \n-/* Define this macro as a C statement that declares additional library\n-   routines renames existing ones. `init_optabs' calls this macro\n-   after initializing all the normal library routines.  */\n-\n #define INIT_TARGET_OPTABS\t\t\t\t\\\n {\t\t\t\t\t\t\t\\\n   smul_optab->handlers[(int) SImode].libfunc\t\t\\"}]}