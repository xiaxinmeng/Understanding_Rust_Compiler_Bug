{"sha": "d8aeaba0c38b9e3bb986cb7a3b31b624811273be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhhZWFiYTBjMzhiOWUzYmI5ODZjYjdhM2IzMWI2MjQ4MTEyNzNiZQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-22T20:14:19Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-22T20:14:19Z"}, "message": "reg-stack.c: Use rtx_insn\n\ngcc/\n\t* reg-stack.c (next_flags_user): Strengthen return type and param\n\t\"insn\" from rtx to rtx_insn *.\n\t(straighten_stack): Likewise for param \"insn\".\n\t(check_asm_stack_operands): Likewise.\n\t(remove_regno_note): Likewise.\n\t(emit_pop_insn): Likewise for return type, param \"insn\", local\n\t\"pop_insn\".\n\t(emit_swap_insn):  Strengthen param \"insn\" and locals \"i1\", \"tmp\",\n\t\"limit\" from rtx to rtx_insn *.\n\t(swap_to_top): Likewise for param \"insn\".\n\t(move_for_stack_reg): Likewise.\n\t(move_nan_for_stack_reg): Likewise.\n\t(swap_rtx_condition): Likewise.\n\t(compare_for_stack_reg): Likewise.\n\t(subst_all_stack_regs_in_debug_insn): Likewise.\n\t(subst_stack_regs_pat): Likewise, and local \"insn2\".\n\t(subst_asm_stack_regs): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\t(subst_stack_regs): Likewise.\n\t(change_stack): Likewise.\n\t(convert_regs_1): Likewise for locals \"insn\", \"next\".\n\nFrom-SVN: r214365", "tree": {"sha": "62042e2b517980c4e4d3b7beef7a4e914408a4c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62042e2b517980c4e4d3b7beef7a4e914408a4c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8aeaba0c38b9e3bb986cb7a3b31b624811273be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8aeaba0c38b9e3bb986cb7a3b31b624811273be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8aeaba0c38b9e3bb986cb7a3b31b624811273be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8aeaba0c38b9e3bb986cb7a3b31b624811273be/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "59a0c0329b50bafca0060c015ae8eeb6fdabc67f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59a0c0329b50bafca0060c015ae8eeb6fdabc67f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59a0c0329b50bafca0060c015ae8eeb6fdabc67f"}], "stats": {"total": 110, "additions": 68, "deletions": 42}, "files": [{"sha": "f59b915929df7ab3abc7e1cb909e05906bca87e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aeaba0c38b9e3bb986cb7a3b31b624811273be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aeaba0c38b9e3bb986cb7a3b31b624811273be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d8aeaba0c38b9e3bb986cb7a3b31b624811273be", "patch": "@@ -1,3 +1,27 @@\n+2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* reg-stack.c (next_flags_user): Strengthen return type and param\n+\t\"insn\" from rtx to rtx_insn *.\n+\t(straighten_stack): Likewise for param \"insn\".\n+\t(check_asm_stack_operands): Likewise.\n+\t(remove_regno_note): Likewise.\n+\t(emit_pop_insn): Likewise for return type, param \"insn\", local\n+\t\"pop_insn\".\n+\t(emit_swap_insn):  Strengthen param \"insn\" and locals \"i1\", \"tmp\",\n+\t\"limit\" from rtx to rtx_insn *.\n+\t(swap_to_top): Likewise for param \"insn\".\n+\t(move_for_stack_reg): Likewise.\n+\t(move_nan_for_stack_reg): Likewise.\n+\t(swap_rtx_condition): Likewise.\n+\t(compare_for_stack_reg): Likewise.\n+\t(subst_all_stack_regs_in_debug_insn): Likewise.\n+\t(subst_stack_regs_pat): Likewise, and local \"insn2\".\n+\t(subst_asm_stack_regs): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\t(subst_stack_regs): Likewise.\n+\t(change_stack): Likewise.\n+\t(convert_regs_1): Likewise for locals \"insn\", \"next\".\n+\n 2014-08-22  David Malcolm  <dmalcolm@redhat.com>\n \n \t* ree.c (struct ext_cand): Strengthen field \"insn\" from rtx to"}, {"sha": "7e232f80ed249044d1dd554339820d6d58d74c5e", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8aeaba0c38b9e3bb986cb7a3b31b624811273be/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8aeaba0c38b9e3bb986cb7a3b31b624811273be/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=d8aeaba0c38b9e3bb986cb7a3b31b624811273be", "patch": "@@ -247,25 +247,25 @@ static int stack_regs_mentioned_p (const_rtx pat);\n static void pop_stack (stack_ptr, int);\n static rtx *get_true_reg (rtx *);\n \n-static int check_asm_stack_operands (rtx);\n+static int check_asm_stack_operands (rtx_insn *);\n static void get_asm_operands_in_out (rtx, int *, int *);\n static rtx stack_result (tree);\n static void replace_reg (rtx *, int);\n-static void remove_regno_note (rtx, enum reg_note, unsigned int);\n+static void remove_regno_note (rtx_insn *, enum reg_note, unsigned int);\n static int get_hard_regnum (stack_ptr, rtx);\n-static rtx emit_pop_insn (rtx, stack_ptr, rtx, enum emit_where);\n-static void swap_to_top (rtx, stack_ptr, rtx, rtx);\n-static bool move_for_stack_reg (rtx, stack_ptr, rtx);\n-static bool move_nan_for_stack_reg (rtx, stack_ptr, rtx);\n+static rtx_insn *emit_pop_insn (rtx_insn *, stack_ptr, rtx, enum emit_where);\n+static void swap_to_top (rtx_insn *, stack_ptr, rtx, rtx);\n+static bool move_for_stack_reg (rtx_insn *, stack_ptr, rtx);\n+static bool move_nan_for_stack_reg (rtx_insn *, stack_ptr, rtx);\n static int swap_rtx_condition_1 (rtx);\n-static int swap_rtx_condition (rtx);\n-static void compare_for_stack_reg (rtx, stack_ptr, rtx);\n-static bool subst_stack_regs_pat (rtx, stack_ptr, rtx);\n-static void subst_asm_stack_regs (rtx, stack_ptr);\n-static bool subst_stack_regs (rtx, stack_ptr);\n-static void change_stack (rtx, stack_ptr, stack_ptr, enum emit_where);\n+static int swap_rtx_condition (rtx_insn *);\n+static void compare_for_stack_reg (rtx_insn *, stack_ptr, rtx);\n+static bool subst_stack_regs_pat (rtx_insn *, stack_ptr, rtx);\n+static void subst_asm_stack_regs (rtx_insn *, stack_ptr);\n+static bool subst_stack_regs (rtx_insn *, stack_ptr);\n+static void change_stack (rtx_insn *, stack_ptr, stack_ptr, enum emit_where);\n static void print_stack (FILE *, stack_ptr);\n-static rtx next_flags_user (rtx);\n+static rtx_insn *next_flags_user (rtx_insn *);\n \f\n /* Return nonzero if any stack register is mentioned somewhere within PAT.  */\n \n@@ -330,8 +330,8 @@ stack_regs_mentioned (const_rtx insn)\n \f\n static rtx ix86_flags_rtx;\n \n-static rtx\n-next_flags_user (rtx insn)\n+static rtx_insn *\n+next_flags_user (rtx_insn *insn)\n {\n   /* Search forward looking for the first use of this value.\n      Stop at block boundaries.  */\n@@ -344,15 +344,15 @@ next_flags_user (rtx insn)\n \treturn insn;\n \n       if (CALL_P (insn))\n-\treturn NULL_RTX;\n+\treturn NULL;\n     }\n-  return NULL_RTX;\n+  return NULL;\n }\n \f\n /* Reorganize the stack into ascending numbers, before this insn.  */\n \n static void\n-straighten_stack (rtx insn, stack_ptr regstack)\n+straighten_stack (rtx_insn *insn, stack_ptr regstack)\n {\n   struct stack_def temp_stack;\n   int top;\n@@ -453,7 +453,7 @@ static bool any_malformed_asm;\n    numbers below refer to that explanation.  */\n \n static int\n-check_asm_stack_operands (rtx insn)\n+check_asm_stack_operands (rtx_insn *insn)\n {\n   int i;\n   int n_clobbers;\n@@ -695,7 +695,7 @@ replace_reg (rtx *reg, int regno)\n    number REGNO from INSN.  Remove only one such note.  */\n \n static void\n-remove_regno_note (rtx insn, enum reg_note note, unsigned int regno)\n+remove_regno_note (rtx_insn *insn, enum reg_note note, unsigned int regno)\n {\n   rtx *note_link, this_rtx;\n \n@@ -738,10 +738,11 @@ get_hard_regnum (stack_ptr regstack, rtx reg)\n    and source is the top of stack.  A death note for the top of stack\n    cases the movdf pattern to pop.  */\n \n-static rtx\n-emit_pop_insn (rtx insn, stack_ptr regstack, rtx reg, enum emit_where where)\n+static rtx_insn *\n+emit_pop_insn (rtx_insn *insn, stack_ptr regstack, rtx reg, enum emit_where where)\n {\n-  rtx pop_insn, pop_rtx;\n+  rtx_insn *pop_insn;\n+  rtx pop_rtx;\n   int hard_regno;\n \n   /* For complex types take care to pop both halves.  These may survive in\n@@ -751,7 +752,7 @@ emit_pop_insn (rtx insn, stack_ptr regstack, rtx reg, enum emit_where where)\n       rtx reg1 = FP_MODE_REG (REGNO (reg), DFmode);\n       rtx reg2 = FP_MODE_REG (REGNO (reg) + 1, DFmode);\n \n-      pop_insn = NULL_RTX;\n+      pop_insn = NULL;\n       if (get_hard_regnum (regstack, reg1) >= 0)\n \tpop_insn = emit_pop_insn (insn, regstack, reg1, where);\n       if (get_hard_regnum (regstack, reg2) >= 0)\n@@ -790,12 +791,12 @@ emit_pop_insn (rtx insn, stack_ptr regstack, rtx reg, enum emit_where where)\n    If REG is already at the top of the stack, no insn is emitted.  */\n \n static void\n-emit_swap_insn (rtx insn, stack_ptr regstack, rtx reg)\n+emit_swap_insn (rtx_insn *insn, stack_ptr regstack, rtx reg)\n {\n   int hard_regno;\n   rtx swap_rtx;\n   int tmp, other_reg;\t\t/* swap regno temps */\n-  rtx i1;\t\t\t/* the stack-reg insn prior to INSN */\n+  rtx_insn *i1;\t\t\t/* the stack-reg insn prior to INSN */\n   rtx i1set = NULL_RTX;\t\t/* the SET rtx within I1 */\n \n   hard_regno = get_hard_regnum (regstack, reg);\n@@ -825,8 +826,8 @@ emit_swap_insn (rtx insn, stack_ptr regstack, rtx reg)\n   i1 = NULL;\n   if (current_block && insn != BB_HEAD (current_block))\n     {\n-      rtx tmp = PREV_INSN (insn);\n-      rtx limit = PREV_INSN (BB_HEAD (current_block));\n+      rtx_insn *tmp = PREV_INSN (insn);\n+      rtx_insn *limit = PREV_INSN (BB_HEAD (current_block));\n       while (tmp != limit)\n \t{\n \t  if (LABEL_P (tmp)\n@@ -897,7 +898,7 @@ emit_swap_insn (rtx insn, stack_ptr regstack, rtx reg)\n    is emitted.  */\n \n static void\n-swap_to_top (rtx insn, stack_ptr regstack, rtx src1, rtx src2)\n+swap_to_top (rtx_insn *insn, stack_ptr regstack, rtx src1, rtx src2)\n {\n   struct stack_def temp_stack;\n   int regno, j, k, temp;\n@@ -938,7 +939,7 @@ swap_to_top (rtx insn, stack_ptr regstack, rtx src1, rtx src2)\n    was deleted in the process.  */\n \n static bool\n-move_for_stack_reg (rtx insn, stack_ptr regstack, rtx pat)\n+move_for_stack_reg (rtx_insn *insn, stack_ptr regstack, rtx pat)\n {\n   rtx *psrc =  get_true_reg (&SET_SRC (pat));\n   rtx *pdest = get_true_reg (&SET_DEST (pat));\n@@ -1089,7 +1090,7 @@ move_for_stack_reg (rtx insn, stack_ptr regstack, rtx pat)\n    a NaN into DEST, then invokes move_for_stack_reg.  */\n \n static bool\n-move_nan_for_stack_reg (rtx insn, stack_ptr regstack, rtx dest)\n+move_nan_for_stack_reg (rtx_insn *insn, stack_ptr regstack, rtx dest)\n {\n   rtx pat;\n \n@@ -1137,7 +1138,7 @@ swap_rtx_condition_1 (rtx pat)\n }\n \n static int\n-swap_rtx_condition (rtx insn)\n+swap_rtx_condition (rtx_insn *insn)\n {\n   rtx pat = PATTERN (insn);\n \n@@ -1228,7 +1229,7 @@ swap_rtx_condition (rtx insn)\n    set up.  */\n \n static void\n-compare_for_stack_reg (rtx insn, stack_ptr regstack, rtx pat_src)\n+compare_for_stack_reg (rtx_insn *insn, stack_ptr regstack, rtx pat_src)\n {\n   rtx *src1, *src2;\n   rtx src1_note, src2_note;\n@@ -1337,7 +1338,7 @@ subst_stack_regs_in_debug_insn (rtx *loc, void *data)\n    the REGs in it, reset the debug insn.  */\n \n static void\n-subst_all_stack_regs_in_debug_insn (rtx insn, struct stack_def *regstack)\n+subst_all_stack_regs_in_debug_insn (rtx_insn *insn, struct stack_def *regstack)\n {\n   int ret = for_each_rtx (&INSN_VAR_LOCATION_LOC (insn),\n \t\t\t  subst_stack_regs_in_debug_insn,\n@@ -1354,7 +1355,7 @@ subst_all_stack_regs_in_debug_insn (rtx insn, struct stack_def *regstack)\n    was deleted in the process.  */\n \n static bool\n-subst_stack_regs_pat (rtx insn, stack_ptr regstack, rtx pat)\n+subst_stack_regs_pat (rtx_insn *insn, stack_ptr regstack, rtx pat)\n {\n   rtx *dest, *src;\n   bool control_flow_insn_deleted = false;\n@@ -1431,7 +1432,7 @@ subst_stack_regs_pat (rtx insn, stack_ptr regstack, rtx pat)\n \t\t\tif (get_hard_regnum (regstack, u) == -1)\n \t\t\t  {\n \t\t\t    rtx pat2 = gen_rtx_CLOBBER (VOIDmode, u);\n-\t\t\t    rtx insn2 = emit_insn_before (pat2, insn);\n+\t\t\t    rtx_insn *insn2 = emit_insn_before (pat2, insn);\n \t\t\t    control_flow_insn_deleted\n \t\t\t      |= move_nan_for_stack_reg (insn2, regstack, u);\n \t\t\t  }\n@@ -1567,14 +1568,14 @@ subst_stack_regs_pat (rtx insn, stack_ptr regstack, rtx pat)\n \t\tif (src1_hard_regnum == -1)\n \t\t  {\n \t\t    rtx pat2 = gen_rtx_CLOBBER (VOIDmode, *src1);\n-\t\t    rtx insn2 = emit_insn_before (pat2, insn);\n+\t\t    rtx_insn *insn2 = emit_insn_before (pat2, insn);\n \t\t    control_flow_insn_deleted\n \t\t      |= move_nan_for_stack_reg (insn2, regstack, *src1);\n \t\t  }\n \t\tif (src2_hard_regnum == -1)\n \t\t  {\n \t\t    rtx pat2 = gen_rtx_CLOBBER (VOIDmode, *src2);\n-\t\t    rtx insn2 = emit_insn_before (pat2, insn);\n+\t\t    rtx_insn *insn2 = emit_insn_before (pat2, insn);\n \t\t    control_flow_insn_deleted\n \t\t      |= move_nan_for_stack_reg (insn2, regstack, *src2);\n \t\t  }\n@@ -2002,7 +2003,7 @@ subst_stack_regs_pat (rtx insn, stack_ptr regstack, rtx pat)\n    requirements, since record_asm_stack_regs removes any problem asm.  */\n \n static void\n-subst_asm_stack_regs (rtx insn, stack_ptr regstack)\n+subst_asm_stack_regs (rtx_insn *insn, stack_ptr regstack)\n {\n   rtx body = PATTERN (insn);\n \n@@ -2283,7 +2284,7 @@ subst_asm_stack_regs (rtx insn, stack_ptr regstack)\n    a control flow insn was deleted in the process.  */\n \n static bool\n-subst_stack_regs (rtx insn, stack_ptr regstack)\n+subst_stack_regs (rtx_insn *insn, stack_ptr regstack)\n {\n   rtx *note_link, note;\n   bool control_flow_insn_deleted = false;\n@@ -2395,7 +2396,8 @@ subst_stack_regs (rtx insn, stack_ptr regstack)\n    is no longer needed once this has executed.  */\n \n static void\n-change_stack (rtx insn, stack_ptr old, stack_ptr new_stack, enum emit_where where)\n+change_stack (rtx_insn *insn, stack_ptr old, stack_ptr new_stack,\n+\t      enum emit_where where)\n {\n   int reg;\n   int update_end = 0;\n@@ -2894,7 +2896,7 @@ convert_regs_1 (basic_block block)\n   struct stack_def regstack;\n   block_info bi = BLOCK_INFO (block);\n   int reg;\n-  rtx insn, next;\n+  rtx_insn *insn, *next;\n   bool control_flow_insn_deleted = false;\n   bool cfg_altered = false;\n   int debug_insns_with_starting_stack = 0;"}]}