{"sha": "15f6e0dac34a243341fba80f8ebdaeec78d766fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVmNmUwZGFjMzRhMjQzMzQxZmJhODBmOGViZGFlZWM3OGQ3NjZmZQ==", "commit": {"author": {"name": "Ramana Radhakrishnan", "email": "ramana.radhakrishnan@arm.com", "date": "2016-07-04T09:06:02Z"}, "committer": {"name": "Ramana Radhakrishnan", "email": "ramana@gcc.gnu.org", "date": "2016-07-04T09:06:02Z"}, "message": "[AArch64] Fix PR target/63874\n\n     In this PR we have a situation where we aren't really detecting\nweak references vs weak definitions. If one has a weak definition that\nbinds locally there's no reason not to put out PC relative\nrelocations.\n\nHowever if you have a genuine weak reference that is known not to bind\nlocally it makes very little sense to put out an entry into the\nliteral pool which doesn't always work with DSOs and shared objects.\n\nTested aarch64-none-linux-gnu bootstrap and regression test with no\nregressions\n\n2016-07-04  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n\n\tPR target/63874\n\t* config/aarch64/aarch64.c (aarch64_classify_symbol): Fix\n\ttypo in comment.  Only force to memory if it is a weak\n\texternal reference.\n\n2016-07-04  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n\n\tPR target/63874\n\t* gcc.target/aarch64/pr63874.c: New test.\n\nFrom-SVN: r237957", "tree": {"sha": "e92d0a15a4459d3e662684de30d415d75d78ffa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e92d0a15a4459d3e662684de30d415d75d78ffa8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15f6e0dac34a243341fba80f8ebdaeec78d766fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15f6e0dac34a243341fba80f8ebdaeec78d766fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15f6e0dac34a243341fba80f8ebdaeec78d766fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15f6e0dac34a243341fba80f8ebdaeec78d766fe/comments", "author": null, "committer": null, "parents": [{"sha": "c61465bda5ed50a1bf664211515436f884e6fa66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c61465bda5ed50a1bf664211515436f884e6fa66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c61465bda5ed50a1bf664211515436f884e6fa66"}], "stats": {"total": 46, "additions": 42, "deletions": 4}, "files": [{"sha": "c021b34409bf5f049c818d8548acdcbed6877d50", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15f6e0dac34a243341fba80f8ebdaeec78d766fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15f6e0dac34a243341fba80f8ebdaeec78d766fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15f6e0dac34a243341fba80f8ebdaeec78d766fe", "patch": "@@ -1,3 +1,10 @@\n+2016-07-04  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n+\n+\tPR target/63874\n+\t* config/aarch64/aarch64.c (aarch64_classify_symbol): Fix\n+\ttypo in comment.  Only force to memory if it is a weak\n+\texternal reference.\n+\n 2016-07-04  Matthew Wahab  <matthew.wahab@arm.com>\n \t    Jiong Wang  <jiong.wang@arm.com>\n "}, {"sha": "512ef10d158d2eaa1384d28c43b9a8f90387099d", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15f6e0dac34a243341fba80f8ebdaeec78d766fe/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15f6e0dac34a243341fba80f8ebdaeec78d766fe/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=15f6e0dac34a243341fba80f8ebdaeec78d766fe", "patch": "@@ -9423,23 +9423,27 @@ aarch64_classify_symbol (rtx x, rtx offset)\n       switch (aarch64_cmodel)\n \t{\n \tcase AARCH64_CMODEL_TINY:\n-\t  /* When we retreive symbol + offset address, we have to make sure\n+\t  /* When we retrieve symbol + offset address, we have to make sure\n \t     the offset does not cause overflow of the final address.  But\n \t     we have no way of knowing the address of symbol at compile time\n \t     so we can't accurately say if the distance between the PC and\n \t     symbol + offset is outside the addressible range of +/-1M in the\n \t     TINY code model.  So we rely on images not being greater than\n \t     1M and cap the offset at 1M and anything beyond 1M will have to\n-\t     be loaded using an alternative mechanism.  */\n-\t  if (SYMBOL_REF_WEAK (x)\n+\t     be loaded using an alternative mechanism.  Furthermore if the\n+\t     symbol is a weak reference to something that isn't known to\n+\t     resolve to a symbol in this module, then force to memory.  */\n+\t  if ((SYMBOL_REF_WEAK (x)\n+\t       && !aarch64_symbol_binds_local_p (x))\n \t      || INTVAL (offset) < -1048575 || INTVAL (offset) > 1048575)\n \t    return SYMBOL_FORCE_TO_MEM;\n \t  return SYMBOL_TINY_ABSOLUTE;\n \n \tcase AARCH64_CMODEL_SMALL:\n \t  /* Same reasoning as the tiny code model, but the offset cap here is\n \t     4G.  */\n-\t  if (SYMBOL_REF_WEAK (x)\n+\t  if ((SYMBOL_REF_WEAK (x)\n+\t       && !aarch64_symbol_binds_local_p (x))\n \t      || !IN_RANGE (INTVAL (offset), HOST_WIDE_INT_C (-4294967263),\n \t\t\t    HOST_WIDE_INT_C (4294967264)))\n \t    return SYMBOL_FORCE_TO_MEM;"}, {"sha": "23e010ed834af32f0ddf98c67833924858045946", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15f6e0dac34a243341fba80f8ebdaeec78d766fe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15f6e0dac34a243341fba80f8ebdaeec78d766fe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=15f6e0dac34a243341fba80f8ebdaeec78d766fe", "patch": "@@ -1,3 +1,8 @@\n+2016-07-04  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n+\n+\tPR target/63874\n+\t* gcc.target/aarch64/pr63874.c: New test.\n+\n 2016-07-04  Jan Beulich  <jbeulich@suse.com>\n \n \t* g++.dg/header.c: New."}, {"sha": "1a745a038a2c7bc01e536805da595cd78f39b2d5", "filename": "gcc/testsuite/gcc.target/aarch64/pr63874.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15f6e0dac34a243341fba80f8ebdaeec78d766fe/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr63874.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15f6e0dac34a243341fba80f8ebdaeec78d766fe/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr63874.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr63874.c?ref=15f6e0dac34a243341fba80f8ebdaeec78d766fe", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"Not applicable for mcmodel=large\" { aarch64*-*-* }  { \"-mcmodel=large\" } { \"\" } } */\n+\n+extern void __attribute__((weak)) foo_weakref (void);\n+void __attribute__((weak, noinline)) bar (void)\n+{\n+ return;\n+}\n+void (*f) (void);\n+void (*g) (void);\n+\n+int\n+main (void)\n+{\n+ f = &foo_weakref;\n+ g = &bar;\n+ return 0;\n+}\n+\n+/* { dg-final { scan-assembler-not \"adr*foo_weakref\" } } */\n+/* { dg-final { scan-assembler-not \"\\\\.(word|xword)\\tbar\" } } */"}]}