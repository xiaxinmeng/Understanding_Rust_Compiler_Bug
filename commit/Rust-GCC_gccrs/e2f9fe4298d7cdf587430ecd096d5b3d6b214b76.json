{"sha": "e2f9fe4298d7cdf587430ecd096d5b3d6b214b76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJmOWZlNDI5OGQ3Y2RmNTg3NDMwZWNkMDk2ZDViM2Q2YjIxNGI3Ng==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-10-06T20:46:53Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-10-06T20:46:53Z"}, "message": "re PR tree-optimization/22237 (struct copy inlining generates overlapping memcpy)\n\n        PR tree-opt/22237\n        * tree-inline.c (declare_return_variable): Handle modify_dest not\n        being a DECL.\n\nFrom-SVN: r105057", "tree": {"sha": "b27cc11783abb4d2a33638ffa8c39cee31924335", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b27cc11783abb4d2a33638ffa8c39cee31924335"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2f9fe4298d7cdf587430ecd096d5b3d6b214b76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2f9fe4298d7cdf587430ecd096d5b3d6b214b76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2f9fe4298d7cdf587430ecd096d5b3d6b214b76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2f9fe4298d7cdf587430ecd096d5b3d6b214b76/comments", "author": null, "committer": null, "parents": [{"sha": "0c7c1604de7009d820bba46fb102b8d3f7d691da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c7c1604de7009d820bba46fb102b8d3f7d691da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c7c1604de7009d820bba46fb102b8d3f7d691da"}], "stats": {"total": 96, "additions": 92, "deletions": 4}, "files": [{"sha": "79124ffdc85c5be3f5e96690ca16ad81fea7bde2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2f9fe4298d7cdf587430ecd096d5b3d6b214b76/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2f9fe4298d7cdf587430ecd096d5b3d6b214b76/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e2f9fe4298d7cdf587430ecd096d5b3d6b214b76", "patch": "@@ -1,3 +1,9 @@\n+2005-10-06  Richard Henderson  <rth@redhat.com>\n+\n+\tPR tree-opt/22237\n+\t* tree-inline.c (declare_return_variable): Handle modify_dest not\n+\tbeing a DECL.\n+\n 2005-10-06  Daniel Berlin  <dberlin@dberlin.org>\n \t\n \tFix PR tree-optimization/22488"}, {"sha": "44032357405618e9f7c9c3e9954ba8575e3b1788", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/pr22237-lib.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2f9fe4298d7cdf587430ecd096d5b3d6b214b76/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fpr22237-lib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2f9fe4298d7cdf587430ecd096d5b3d6b214b76/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fpr22237-lib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fpr22237-lib.c?ref=e2f9fe4298d7cdf587430ecd096d5b3d6b214b76", "patch": "@@ -0,0 +1,27 @@\n+extern void abort (void);\n+\n+void *\n+memcpy (void *dst, const void *src, __SIZE_TYPE__ n)\n+{\n+  const char *srcp;\n+  char *dstp;\n+\n+  srcp = src;\n+  dstp = dst;\n+\n+  if (dst < src)\n+    {\n+      if (dst + n > src)\n+\tabort ();\n+    }\n+  else\n+    {\n+      if (src + n > dst)\n+\tabort ();\n+    }\n+\n+  while (n-- != 0)\n+    *dstp++ = *srcp++;\n+\n+  return dst;\n+}"}, {"sha": "957a47c0f74c27e4a6158d0d31eb13555ab18edf", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/pr22237.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2f9fe4298d7cdf587430ecd096d5b3d6b214b76/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fpr22237.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2f9fe4298d7cdf587430ecd096d5b3d6b214b76/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fpr22237.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fpr22237.c?ref=e2f9fe4298d7cdf587430ecd096d5b3d6b214b76", "patch": "@@ -0,0 +1,44 @@\n+extern void abort (void);\n+extern void exit (int);\n+struct s { unsigned char a[256]; };\n+union u { struct { struct s b; int c; } d; struct { int c; struct s b; } e; };\n+static union u v;\n+static union u v0;\n+static struct s *p = &v.d.b;\n+static struct s *q = &v.e.b;\n+\n+static inline struct s rp (void) { return *p; }\n+static inline struct s rq (void) { return *q; }\n+static void pq (void) { *p = rq(); }\n+static void qp (void) { *q = rp(); }\n+\n+static void\n+init (struct s *sp)\n+{\n+  int i;\n+  for (i = 0; i < 256; i++)\n+    sp->a[i] = i;\n+}\n+\n+static void\n+check (struct s *sp)\n+{\n+  int i;\n+  for (i = 0; i < 256; i++)\n+    if (sp->a[i] != i)\n+      abort ();\n+}\n+\n+void\n+main_test (void)\n+{\n+  v = v0;\n+  init (p);\n+  qp ();\n+  check (q);\n+  v = v0;\n+  init (q);\n+  pq ();\n+  check (p);\n+  exit (0);\n+}"}, {"sha": "f22785c0e800f86b3749ce48213446c3bcacd207", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2f9fe4298d7cdf587430ecd096d5b3d6b214b76/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2f9fe4298d7cdf587430ecd096d5b3d6b214b76/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=e2f9fe4298d7cdf587430ecd096d5b3d6b214b76", "patch": "@@ -1260,10 +1260,21 @@ declare_return_variable (inline_data *id, tree return_slot_addr,\n       /* If the callee cannot possibly modify MODIFY_DEST, then we can\n \t reuse it as the result of the call directly.  Don't do this if\n \t it would promote MODIFY_DEST to addressable.  */\n-      else if (!TREE_STATIC (modify_dest)\n-\t       && !TREE_ADDRESSABLE (modify_dest)\n-\t       && !TREE_ADDRESSABLE (result))\n-\tuse_it = true;\n+      else if (TREE_ADDRESSABLE (result))\n+\tuse_it = false;\n+      else\n+\t{\n+\t  tree base_m = get_base_address (modify_dest);\n+\n+\t  /* If the base isn't a decl, then it's a pointer, and we don't\n+\t     know where that's going to go.  */\n+\t  if (!DECL_P (base_m))\n+\t    use_it = false;\n+\t  else if (is_global_var (base_m))\n+\t    use_it = false;\n+\t  else if (!TREE_ADDRESSABLE (base_m))\n+\t    use_it = true;\n+\t}\n \n       if (use_it)\n \t{"}]}