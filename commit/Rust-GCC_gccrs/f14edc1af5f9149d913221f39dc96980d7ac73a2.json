{"sha": "f14edc1af5f9149d913221f39dc96980d7ac73a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE0ZWRjMWFmNWY5MTQ5ZDkxMzIyMWYzOWRjOTY5ODBkN2FjNzNhMg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2012-10-25T15:54:00Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2012-10-25T15:54:00Z"}, "message": "Core 1402\n\n\tCore 1402\ncp/\n\t* call.c (joust): An implicitly deleted move function is\n\tworse than any non-deleted function.\n\t* method.c (process_subob_fn): No special rules for move.\n\t(synthesized_method_walk, implicitly_declare_fn): Likewise.\n\tWarn about virtual base with non-trivial move assignment.\n\t* cp-tree.h (struct lang_decl_fn): Remove suppress_implicit_decl.\n\t(FNDECL_SUPPRESS_IMPLICIT_DECL): Remove.\nc-family/\n\t* c.opt (Wvirtual-move-assign): New.\n\nFrom-SVN: r192813", "tree": {"sha": "bed8a193992a8a72ab5ff86d67559fc50a45b33e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bed8a193992a8a72ab5ff86d67559fc50a45b33e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f14edc1af5f9149d913221f39dc96980d7ac73a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f14edc1af5f9149d913221f39dc96980d7ac73a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f14edc1af5f9149d913221f39dc96980d7ac73a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f14edc1af5f9149d913221f39dc96980d7ac73a2/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "57c3feb40a875ec85620513b49c758c6076a289a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57c3feb40a875ec85620513b49c758c6076a289a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57c3feb40a875ec85620513b49c758c6076a289a"}], "stats": {"total": 213, "additions": 135, "deletions": 78}, "files": [{"sha": "f97057ec2c5b0e831f263ee01cd93e238a74084f", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14edc1af5f9149d913221f39dc96980d7ac73a2/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14edc1af5f9149d913221f39dc96980d7ac73a2/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=f14edc1af5f9149d913221f39dc96980d7ac73a2", "patch": "@@ -1,5 +1,7 @@\n 2012-10-25  Jason Merrill  <jason@redhat.com>\n \n+\t* c.opt (Wvirtual-move-assign): New.\n+\n \t* c.opt (Winherited-variadic-ctor): New.\n \n 2012-10-25  Marc Glisse  <marc.glisse@inria.fr>"}, {"sha": "7eb66c6175bb9f92bf7d8fa3d10a3162cadc62ae", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14edc1af5f9149d913221f39dc96980d7ac73a2/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14edc1af5f9149d913221f39dc96980d7ac73a2/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=f14edc1af5f9149d913221f39dc96980d7ac73a2", "patch": "@@ -741,6 +741,10 @@ Wvolatile-register-var\n C ObjC C++ ObjC++ Var(warn_volatile_register_var) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall)\n Warn when a register variable is declared volatile\n \n+Wvirtual-move-assign\n+C++ ObjC++ Var(warn_virtual_move_assign) Warning Init(1)\n+Warn if a virtual base has a non-trivial move assignment operator\n+\n Wwrite-strings\n C ObjC C++ ObjC++ Var(warn_write_strings) Warning\n In C++, nonzero means warn about deprecated conversion from string literals to 'char *'.  In C, similar warning, except that the conversion is of course not deprecated by the ISO C standard."}, {"sha": "458f39abc7e24943cd9045d88462441c6dff7fcf", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14edc1af5f9149d913221f39dc96980d7ac73a2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14edc1af5f9149d913221f39dc96980d7ac73a2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f14edc1af5f9149d913221f39dc96980d7ac73a2", "patch": "@@ -1,5 +1,14 @@\n 2012-10-25  Jason Merrill  <jason@redhat.com>\n \n+\tCore 1402\n+\t* call.c (joust): An implicitly deleted move function is\n+\tworse than any non-deleted function.\n+\t* method.c (process_subob_fn): No special rules for move.\n+\t(synthesized_method_walk, implicitly_declare_fn): Likewise.\n+\tWarn about virtual base with non-trivial move assignment.\n+\t* cp-tree.h (struct lang_decl_fn): Remove suppress_implicit_decl.\n+\t(FNDECL_SUPPRESS_IMPLICIT_DECL): Remove.\n+\n \t* semantics.c (finish_omp_threadprivate): Call complete_type.\n \n \t* class.c (one_inherited_ctor): Warn about variadic inherited ctor."}, {"sha": "fcc973505bea2874fa9b6c46909810efc6e31d52", "filename": "gcc/cp/call.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14edc1af5f9149d913221f39dc96980d7ac73a2/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14edc1af5f9149d913221f39dc96980d7ac73a2/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=f14edc1af5f9149d913221f39dc96980d7ac73a2", "patch": "@@ -8246,6 +8246,22 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n       && (IS_TYPE_OR_DECL_P (cand1->fn)))\n     return 1;\n \n+  /* Prefer a non-deleted function over an implicitly deleted move\n+     constructor or assignment operator.  This differs slightly from the\n+     wording for issue 1402 (which says the move op is ignored by overload\n+     resolution), but this way produces better error messages.  */\n+  if (TREE_CODE (cand1->fn) == FUNCTION_DECL\n+      && TREE_CODE (cand2->fn) == FUNCTION_DECL\n+      && DECL_DELETED_FN (cand1->fn) != DECL_DELETED_FN (cand2->fn))\n+    {\n+      if (DECL_DELETED_FN (cand1->fn) && DECL_DEFAULTED_FN (cand1->fn)\n+\t  && move_fn_p (cand1->fn))\n+\treturn -1;\n+      if (DECL_DELETED_FN (cand2->fn) && DECL_DEFAULTED_FN (cand2->fn)\n+\t  && move_fn_p (cand2->fn))\n+\treturn 1;\n+    }\n+\n   /* a viable function F1\n      is defined to be a better function than another viable function F2  if\n      for  all arguments i, ICSi(F1) is not a worse conversion sequence than"}, {"sha": "77508a10cb747d48868a1d277f3d60c49e04834a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14edc1af5f9149d913221f39dc96980d7ac73a2/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14edc1af5f9149d913221f39dc96980d7ac73a2/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f14edc1af5f9149d913221f39dc96980d7ac73a2", "patch": "@@ -1954,7 +1954,7 @@ struct GTY(()) lang_decl_fn {\n   unsigned thunk_p : 1;\n   unsigned this_thunk_p : 1;\n   unsigned hidden_friend_p : 1;\n-  unsigned suppress_implicit_decl : 1;\n+  /* 1 spare bit.  */\n \n   /* For a non-thunk function decl, this is a tree list of\n      friendly classes. For a thunk function decl, it is the\n@@ -3144,12 +3144,6 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define DECL_HIDDEN_FRIEND_P(NODE) \\\n   (LANG_DECL_FN_CHECK (DECL_COMMON_CHECK (NODE))->hidden_friend_p)\n \n-/* Nonzero if NODE is a FUNCTION_DECL generated by implicitly_declare_fn\n-   that we shouldn't actually declare implicitly; it is only used for\n-   comparing to an =default declaration.  */\n-#define FNDECL_SUPPRESS_IMPLICIT_DECL(NODE) \\\n-  (LANG_DECL_FN_CHECK (DECL_COMMON_CHECK (NODE))->suppress_implicit_decl)\n-\n /* Nonzero if DECL has been declared threadprivate by\n    #pragma omp threadprivate.  */\n #define CP_DECL_THREADPRIVATE_P(DECL) \\"}, {"sha": "8a7d7cbaf3b73aff317df17c08aa573dbdccf648", "filename": "gcc/cp/method.c", "status": "modified", "additions": 43, "deletions": 65, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14edc1af5f9149d913221f39dc96980d7ac73a2/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14edc1af5f9149d913221f39dc96980d7ac73a2/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=f14edc1af5f9149d913221f39dc96980d7ac73a2", "patch": "@@ -969,8 +969,8 @@ get_copy_assign (tree type)\n    DELETED_P or give an error message MSG with argument ARG.  */\n \n static void\n-process_subob_fn (tree fn, bool move_p, tree *spec_p, bool *trivial_p,\n-\t\t  bool *deleted_p, bool *constexpr_p, bool *no_implicit_p,\n+process_subob_fn (tree fn, tree *spec_p, bool *trivial_p,\n+\t\t  bool *deleted_p, bool *constexpr_p,\n \t\t  bool diag, tree arg)\n {\n   if (!fn || fn == error_mark_node)\n@@ -996,12 +996,6 @@ process_subob_fn (tree fn, bool move_p, tree *spec_p, bool *trivial_p,\n \t}\n     }\n \n-  /* Core 1402: A non-trivial non-move ctor suppresses the implicit\n-     declaration of the move ctor/op=.  */\n-  if (no_implicit_p && move_p && !move_signature_fn_p (fn)\n-      && !trivial_fn_p (fn))\n-    *no_implicit_p = true;\n-\n   if (constexpr_p && !DECL_DECLARED_CONSTEXPR_P (fn))\n     {\n       *constexpr_p = false;\n@@ -1027,7 +1021,7 @@ static void\n walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n \t\t   int quals, bool copy_arg_p, bool move_p,\n \t\t   bool assign_p, tree *spec_p, bool *trivial_p,\n-\t\t   bool *deleted_p, bool *constexpr_p, bool *no_implicit_p,\n+\t\t   bool *deleted_p, bool *constexpr_p,\n \t\t   bool diag, int flags, tsubst_flags_t complain)\n {\n   tree field;\n@@ -1126,7 +1120,7 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n \t{\n \t  walk_field_subobs (TYPE_FIELDS (mem_type), fnname, sfk, quals,\n \t\t\t     copy_arg_p, move_p, assign_p, spec_p, trivial_p,\n-\t\t\t     deleted_p, constexpr_p, no_implicit_p,\n+\t\t\t     deleted_p, constexpr_p,\n \t\t\t     diag, flags, complain);\n \t  continue;\n \t}\n@@ -1143,8 +1137,8 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n \n       rval = locate_fn_flags (mem_type, fnname, argtype, flags, complain);\n \n-      process_subob_fn (rval, move_p, spec_p, trivial_p, deleted_p,\n-\t\t\tconstexpr_p, no_implicit_p, diag, field);\n+      process_subob_fn (rval, spec_p, trivial_p, deleted_p,\n+\t\t\tconstexpr_p, diag, field);\n     }\n }\n \n@@ -1158,7 +1152,7 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n static void\n synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \t\t\t tree *spec_p, bool *trivial_p, bool *deleted_p,\n-\t\t\t bool *constexpr_p, bool *no_implicit_p, bool diag,\n+\t\t\t bool *constexpr_p, bool diag,\n \t\t\t tree inherited_base, tree inherited_parms)\n {\n   tree binfo, base_binfo, scope, fnname, rval, argtype;\n@@ -1171,9 +1165,6 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n   if (spec_p)\n     *spec_p = (cxx_dialect >= cxx0x ? noexcept_true_spec : empty_except_spec);\n \n-  if (no_implicit_p)\n-    *no_implicit_p = false;\n-\n   if (deleted_p)\n     {\n       /* \"The closure type associated with a lambda-expression has a deleted\n@@ -1314,8 +1305,8 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n       if (inherited_base)\n \targtype = NULL_TREE;\n \n-      process_subob_fn (rval, move_p, spec_p, trivial_p, deleted_p,\n-\t\t\tconstexpr_p, no_implicit_p, diag, basetype);\n+      process_subob_fn (rval, spec_p, trivial_p, deleted_p,\n+\t\t\tconstexpr_p, diag, basetype);\n       if (ctor_p && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (basetype))\n \t{\n \t  /* In a constructor we also need to check the subobject\n@@ -1327,8 +1318,8 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \t     do they affect constexpr-ness (a constant expression doesn't\n \t     throw) or exception-specification (a throw from one of the\n \t     dtors would be a double-fault).  */\n-\t  process_subob_fn (rval, false, NULL, NULL,\n-\t\t\t    deleted_p, NULL, NULL, false,\n+\t  process_subob_fn (rval, NULL, NULL,\n+\t\t\t    deleted_p, NULL, false,\n \t\t\t    basetype);\n \t}\n \n@@ -1342,31 +1333,20 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \t    *deleted_p = true;\n \t  check_vdtor = false;\n \t}\n+\n+      if (diag && assign_p && move_p\n+\t  && BINFO_VIRTUAL_P (base_binfo)\n+\t  && rval && TREE_CODE (rval) == FUNCTION_DECL\n+\t  && move_fn_p (rval) && !trivial_fn_p (rval))\n+\twarning (OPT_Wvirtual_move_assign,\n+\t\t \"defaulted move assignment for %qT calls a non-trivial \"\n+\t\t \"move assignment operator for virtual base %qT\",\n+\t\t ctype, basetype);\n     }\n \n   vbases = CLASSTYPE_VBASECLASSES (ctype);\n   if (vbases == NULL)\n     /* No virtual bases to worry about.  */;\n-  else if (assign_p && move_p && no_implicit_p)\n-    {\n-      /* Don't implicitly declare a defaulted move assignment if a virtual\n-\t base has non-trivial move assignment, since moving the same base\n-\t more than once is dangerous.  */\n-      /* Should the spec be changed to allow vbases that only occur once?  */\n-      FOR_EACH_VEC_ELT (tree, vbases, i, base_binfo)\n-\t{\n-\t  tree basetype = BINFO_TYPE (base_binfo);\n-\t  if (copy_arg_p)\n-\t    argtype = build_stub_type (basetype, quals, move_p);\n-\t  rval = locate_fn_flags (base_binfo, fnname, argtype, flags, complain);\n-\t  if (rval && rval != error_mark_node\n-\t      && move_fn_p (rval) && !trivial_fn_p (rval))\n-\t    {\n-\t      *no_implicit_p = true;\n-\t      break;\n-\t    }\n-\t}\n-    }\n   else if (!assign_p)\n     {\n       if (constexpr_p)\n@@ -1378,14 +1358,14 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \t    argtype = build_stub_type (basetype, quals, move_p);\n \t  rval = locate_fn_flags (base_binfo, fnname, argtype, flags, complain);\n \n-\t  process_subob_fn (rval, move_p, spec_p, trivial_p, deleted_p,\n-\t\t\t    constexpr_p, no_implicit_p, diag, basetype);\n+\t  process_subob_fn (rval, spec_p, trivial_p, deleted_p,\n+\t\t\t    constexpr_p, diag, basetype);\n \t  if (ctor_p && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (basetype))\n \t    {\n \t      rval = locate_fn_flags (base_binfo, complete_dtor_identifier,\n \t\t\t\t      NULL_TREE, flags, complain);\n-\t      process_subob_fn (rval, false, NULL, NULL,\n-\t\t\t\tdeleted_p, NULL, NULL, false,\n+\t      process_subob_fn (rval, NULL, NULL,\n+\t\t\t\tdeleted_p, NULL, false,\n \t\t\t\tbasetype);\n \t    }\n \t}\n@@ -1394,14 +1374,14 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n   /* Now handle the non-static data members.  */\n   walk_field_subobs (TYPE_FIELDS (ctype), fnname, sfk, quals,\n \t\t     copy_arg_p, move_p, assign_p, spec_p, trivial_p,\n-\t\t     deleted_p, constexpr_p, no_implicit_p,\n+\t\t     deleted_p, constexpr_p,\n \t\t     diag, flags, complain);\n   if (ctor_p)\n     walk_field_subobs (TYPE_FIELDS (ctype), complete_dtor_identifier,\n \t\t       sfk_destructor, TYPE_UNQUALIFIED, false,\n \t\t       false, false, NULL, NULL,\n \t\t       deleted_p, NULL,\n-\t\t       NULL, false, flags, complain);\n+\t\t       false, flags, complain);\n \n   pop_scope (scope);\n \n@@ -1473,7 +1453,7 @@ maybe_explain_implicit_delete (tree decl)\n \t\t \"definition would be ill-formed:\", decl);\n \t  pop_scope (scope);\n \t  synthesized_method_walk (ctype, sfk, const_p,\n-\t\t\t\t   NULL, NULL, NULL, NULL, NULL, true,\n+\t\t\t\t   NULL, NULL, NULL, NULL, true,\n \t\t\t\t   DECL_INHERITED_CTOR_BASE (decl), parms);\n \t}\n \n@@ -1494,7 +1474,7 @@ explain_implicit_non_constexpr (tree decl)\n   bool dummy;\n   synthesized_method_walk (DECL_CLASS_CONTEXT (decl),\n \t\t\t   special_function_p (decl), const_p,\n-\t\t\t   NULL, NULL, NULL, &dummy, NULL, true,\n+\t\t\t   NULL, NULL, NULL, &dummy, true,\n \t\t\t   NULL_TREE, NULL_TREE);\n }\n \n@@ -1507,10 +1487,10 @@ deduce_inheriting_ctor (tree decl)\n {\n   gcc_assert (DECL_INHERITED_CTOR_BASE (decl));\n   tree spec;\n-  bool trivial, constexpr_, deleted, no_implicit;\n+  bool trivial, constexpr_, deleted;\n   synthesized_method_walk (DECL_CONTEXT (decl), sfk_inheriting_constructor,\n \t\t\t   false, &spec, &trivial, &deleted, &constexpr_,\n-\t\t\t   &no_implicit, /*diag*/false,\n+\t\t\t   /*diag*/false,\n \t\t\t   DECL_INHERITED_CTOR_BASE (decl),\n \t\t\t   FUNCTION_FIRST_USER_PARMTYPE (decl));\n   DECL_DELETED_FN (decl) = deleted;\n@@ -1540,7 +1520,6 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n   bool deleted_p;\n   bool trivial_p;\n   bool constexpr_p;\n-  bool no_implicit_p;\n \n   /* Because we create declarations for implicitly declared functions\n      lazily, we may be creating the declaration for a member of TYPE\n@@ -1627,11 +1606,10 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n       deleted_p = DECL_DELETED_FN (DECL_TEMPLATE_RESULT (inherited_ctor));\n       constexpr_p\n \t= DECL_DECLARED_CONSTEXPR_P (DECL_TEMPLATE_RESULT (inherited_ctor));\n-      no_implicit_p = false;\n     }\n   else\n     synthesized_method_walk (type, kind, const_p, &raises, &trivial_p,\n-\t\t\t     &deleted_p, &constexpr_p, &no_implicit_p, false,\n+\t\t\t     &deleted_p, &constexpr_p, false,\n \t\t\t     inherited_base, inherited_parms);\n   /* Don't bother marking a deleted constructor as constexpr.  */\n   if (deleted_p)\n@@ -1719,7 +1697,6 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n       DECL_DELETED_FN (fn) = deleted_p;\n       DECL_DECLARED_CONSTEXPR_P (fn) = constexpr_p;\n     }\n-  FNDECL_SUPPRESS_IMPLICIT_DECL (fn) = no_implicit_p;\n   DECL_EXTERNAL (fn) = true;\n   DECL_NOT_REALLY_EXTERN (fn) = 1;\n   DECL_DECLARED_INLINE_P (fn) = 1;\n@@ -1731,6 +1708,18 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n   if (inherited_ctor && TREE_CODE (inherited_ctor) == TEMPLATE_DECL)\n     fn = add_inherited_template_parms (fn, inherited_ctor);\n \n+  /* Warn about calling a non-trivial move assignment in a virtual base.  */\n+  if (kind == sfk_move_assignment && !deleted_p && !trivial_p\n+      && CLASSTYPE_VBASECLASSES (type))\n+    {\n+      location_t loc = input_location;\n+      input_location = DECL_SOURCE_LOCATION (fn);\n+      synthesized_method_walk (type, kind, const_p,\n+\t\t\t       NULL, NULL, NULL, NULL, true,\n+\t\t\t       NULL_TREE, NULL_TREE);\n+      input_location = loc;\n+    }\n+\n   return fn;\n }\n \n@@ -1909,17 +1898,6 @@ lazily_declare_fn (special_function_kind sfk, tree type)\n \t  || type_has_user_declared_move_assign (type)))\n     DECL_DELETED_FN (fn) = true;\n \n-  /* For move variants, rather than declare them as deleted we just\n-     don't declare them at all.  */\n-  if (DECL_DELETED_FN (fn)\n-      && (sfk == sfk_move_constructor\n-\t  || sfk == sfk_move_assignment))\n-    return NULL_TREE;\n-\n-  /* We also suppress implicit move if it would call a non-trivial copy.  */\n-  if (FNDECL_SUPPRESS_IMPLICIT_DECL (fn))\n-    return NULL_TREE;\n-\n   /* A destructor may be virtual.  */\n   if (sfk == sfk_destructor\n       || sfk == sfk_move_assignment"}, {"sha": "afb9f21137877da956a41039eed5c19507f8485a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14edc1af5f9149d913221f39dc96980d7ac73a2/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14edc1af5f9149d913221f39dc96980d7ac73a2/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f14edc1af5f9149d913221f39dc96980d7ac73a2", "patch": "@@ -4722,6 +4722,16 @@ using scalars of wider type, which normally is more performance efficient;\n and @code{as a single scalar}, which means that vector fits into a\n scalar type.\n \n+@item -Wno-virtual-move-assign\n+@opindex Wvirtual-move-assign\n+@opindex Wno-virtual-move-assign\n+Suppress warnings about inheriting from a virtual base with a\n+non-trivial C++11 move assignment operator.  This is dangerous because\n+if the virtual base is reachable along more than one path, it will be\n+moved multiple times, which can mean both objects end up in the\n+moved-from state.  If the move assignment operator is written to avoid\n+moving from a moved-from object, this warning can be disabled.\n+\n @item -Wvla\n @opindex Wvla\n @opindex Wno-vla"}, {"sha": "1926f2eb4cc403eec67c80b8f237c7bfefbc0de4", "filename": "gcc/testsuite/g++.dg/cpp0x/defaulted37.C", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14edc1af5f9149d913221f39dc96980d7ac73a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted37.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14edc1af5f9149d913221f39dc96980d7ac73a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted37.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted37.C?ref=f14edc1af5f9149d913221f39dc96980d7ac73a2", "patch": "@@ -3,19 +3,17 @@\n \n struct A\n {\n-  int moved = 0;\n-  A& operator=(A&&) { ++moved; }\n-  ~A() { if (moved > 1) __builtin_abort(); }\n+  A& operator=(A&&);\n };\n \n-struct B: virtual A { B& operator=(B&&) = default; };\n-struct C: virtual A { };\t// { dg-error \"operator=.const A&\" }\n+struct B: virtual A { B& operator=(B&&) = default; }; // { dg-warning \"virtual base\" }\n+struct C: virtual A { };\t\t\t      // { dg-warning \"virtual base\" }\n \n int main()\n {\n   B b1, b2;\n   b2 = static_cast<B&&>(b1);\n \n   C c1, c2;\n-  c2 = static_cast<C&&>(c1);\t// { dg-error \"operator=.const C&\" }\n+  c2 = static_cast<C&&>(c1);\n }"}, {"sha": "fe847d4e8a9150cb5175421e089c07b20810990d", "filename": "gcc/testsuite/g++.dg/cpp0x/defaulted39.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14edc1af5f9149d913221f39dc96980d7ac73a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted39.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14edc1af5f9149d913221f39dc96980d7ac73a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted39.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted39.C?ref=f14edc1af5f9149d913221f39dc96980d7ac73a2", "patch": "@@ -0,0 +1,23 @@\n+// DR 1402\n+// { dg-options -std=c++11 }\n+\n+template <class T> T&& move(T& t);\n+\n+struct A\n+{\n+  A(const A&);\n+};\n+\n+struct B\n+{\n+  B(B&&);\n+};\n+\n+struct C\n+{\n+  A a;\n+  B b;\n+};\n+\n+extern C c1;\n+C c2(move(c1));"}, {"sha": "c160b397bd0c8b50fb1451bd620afc8c0c0c15c1", "filename": "gcc/testsuite/g++.dg/cpp0x/defaulted40.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f14edc1af5f9149d913221f39dc96980d7ac73a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted40.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f14edc1af5f9149d913221f39dc96980d7ac73a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted40.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted40.C?ref=f14edc1af5f9149d913221f39dc96980d7ac73a2", "patch": "@@ -0,0 +1,23 @@\n+// DR 1402\n+// { dg-options -std=c++11 }\n+\n+template <class T> T&& move(T& t);\n+\n+struct A\n+{\n+  A(const A&);\n+};\n+\n+struct B\n+{\n+  B(B&&) = delete;\t\t// { dg-prune-output \"declared\" }\n+};\n+\n+struct C\t\t\t// { dg-error \"deleted\" }\n+{\n+  A a;\n+  B b;\n+};\n+\n+extern C c1;\n+C c2(move(c1));\t\t\t// { dg-error \"deleted\" }"}]}