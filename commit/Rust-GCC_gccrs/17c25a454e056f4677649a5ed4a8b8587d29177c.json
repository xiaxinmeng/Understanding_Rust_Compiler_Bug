{"sha": "17c25a454e056f4677649a5ed4a8b8587d29177c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdjMjVhNDU0ZTA1NmY0Njc3NjQ5YTVlZDRhOGI4NTg3ZDI5MTc3Yw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-09T10:09:01Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-09T13:07:01Z"}, "message": "Use a per-edge PRE PHI translation cache\n\nThis changes the phi translation cache to be per edge which\npushes it off the profiling radar.  For larger testcases the\ncombined hashtable causes a load of cache misses and making it\nper edge allows to shrink the entry further.\n\n2020-11-09  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/97765\n\t* tree-ssa-pre.c (bb_bitmap_sets::phi_translate_table): Add.\n\t(PHI_TRANS_TABLE): New macro.\n\t(phi_translate_table): Remove.\n\t(expr_pred_trans_d::pred): Remove.\n\t(expr_pred_trans_d::hash): Simplify.\n\t(expr_pred_trans_d::equal): Likewise.\n\t(phi_trans_add): Adjust.\n\t(phi_translate): Likewise.  Remove hash-table expansion\n\tdetection and optimization.\n\t(phi_translate_set): Allocate PHI_TRANS_TABLE here.\n\t(init_pre): Adjsust.\n\t(fini_pre): Free PHI_TRANS_TABLE.", "tree": {"sha": "95e2f6dc3582c88083041588821e0d602940fb25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95e2f6dc3582c88083041588821e0d602940fb25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17c25a454e056f4677649a5ed4a8b8587d29177c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17c25a454e056f4677649a5ed4a8b8587d29177c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17c25a454e056f4677649a5ed4a8b8587d29177c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17c25a454e056f4677649a5ed4a8b8587d29177c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d4fa1f79c7b7a01e0b4fa27ee37b7030e6bf93f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d4fa1f79c7b7a01e0b4fa27ee37b7030e6bf93f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d4fa1f79c7b7a01e0b4fa27ee37b7030e6bf93f"}], "stats": {"total": 166, "additions": 81, "deletions": 85}, "files": [{"sha": "79bb9e2d712218e8b889209ad4de607c4aaea647", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 81, "deletions": 85, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17c25a454e056f4677649a5ed4a8b8587d29177c/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17c25a454e056f4677649a5ed4a8b8587d29177c/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=17c25a454e056f4677649a5ed4a8b8587d29177c", "patch": "@@ -448,63 +448,6 @@ static vec<bitmap> value_expressions;\n    value, one of kind CONSTANT.  */\n static vec<bitmap> constant_value_expressions;\n \n-/* Sets that we need to keep track of.  */\n-typedef struct bb_bitmap_sets\n-{\n-  /* The EXP_GEN set, which represents expressions/values generated in\n-     a basic block.  */\n-  bitmap_set_t exp_gen;\n-\n-  /* The PHI_GEN set, which represents PHI results generated in a\n-     basic block.  */\n-  bitmap_set_t phi_gen;\n-\n-  /* The TMP_GEN set, which represents results/temporaries generated\n-     in a basic block. IE the LHS of an expression.  */\n-  bitmap_set_t tmp_gen;\n-\n-  /* The AVAIL_OUT set, which represents which values are available in\n-     a given basic block.  */\n-  bitmap_set_t avail_out;\n-\n-  /* The ANTIC_IN set, which represents which values are anticipatable\n-     in a given basic block.  */\n-  bitmap_set_t antic_in;\n-\n-  /* The PA_IN set, which represents which values are\n-     partially anticipatable in a given basic block.  */\n-  bitmap_set_t pa_in;\n-\n-  /* The NEW_SETS set, which is used during insertion to augment the\n-     AVAIL_OUT set of blocks with the new insertions performed during\n-     the current iteration.  */\n-  bitmap_set_t new_sets;\n-\n-  /* A cache for value_dies_in_block_x.  */\n-  bitmap expr_dies;\n-\n-  /* The live virtual operand on successor edges.  */\n-  tree vop_on_exit;\n-\n-  /* True if we have visited this block during ANTIC calculation.  */\n-  unsigned int visited : 1;\n-\n-  /* True when the block contains a call that might not return.  */\n-  unsigned int contains_may_not_return_call : 1;\n-} *bb_value_sets_t;\n-\n-#define EXP_GEN(BB)\t((bb_value_sets_t) ((BB)->aux))->exp_gen\n-#define PHI_GEN(BB)\t((bb_value_sets_t) ((BB)->aux))->phi_gen\n-#define TMP_GEN(BB)\t((bb_value_sets_t) ((BB)->aux))->tmp_gen\n-#define AVAIL_OUT(BB)\t((bb_value_sets_t) ((BB)->aux))->avail_out\n-#define ANTIC_IN(BB)\t((bb_value_sets_t) ((BB)->aux))->antic_in\n-#define PA_IN(BB)\t((bb_value_sets_t) ((BB)->aux))->pa_in\n-#define NEW_SETS(BB)\t((bb_value_sets_t) ((BB)->aux))->new_sets\n-#define EXPR_DIES(BB)\t((bb_value_sets_t) ((BB)->aux))->expr_dies\n-#define BB_VISITED(BB)\t((bb_value_sets_t) ((BB)->aux))->visited\n-#define BB_MAY_NOTRETURN(BB) ((bb_value_sets_t) ((BB)->aux))->contains_may_not_return_call\n-#define BB_LIVE_VOP_ON_EXIT(BB) ((bb_value_sets_t) ((BB)->aux))->vop_on_exit\n-\n \n /* This structure is used to keep track of statistics on what\n    optimization PRE was able to perform.  */\n@@ -553,9 +496,6 @@ typedef struct expr_pred_trans_d : public typed_noop_remove <expr_pred_trans_d>\n   /* The expression ID.  */\n   unsigned e;\n \n-  /* The predecessor block index along which we translated the expression.  */\n-  int pred;\n-\n   /* The value expression ID that resulted from the translation.  */\n   unsigned v;\n \n@@ -597,41 +537,92 @@ expr_pred_trans_d::mark_deleted (expr_pred_trans_d &e)\n inline hashval_t\n expr_pred_trans_d::hash (const expr_pred_trans_d &e)\n {\n-  return iterative_hash_hashval_t (e.e, e.pred);\n+  return e.e;\n }\n \n inline int\n expr_pred_trans_d::equal (const expr_pred_trans_d &ve1,\n \t\t\t  const expr_pred_trans_d &ve2)\n {\n-  int b1 = ve1.pred;\n-  int b2 = ve2.pred;\n-\n-  /* If they are not translations for the same basic block, they can't\n-     be equal.  */\n-  if (b1 != b2)\n-    return false;\n-\n   return ve1.e == ve2.e;\n }\n \n-/* The phi_translate_table caches phi translations for a given\n-   expression and predecessor.  */\n-static hash_table<expr_pred_trans_d> *phi_translate_table;\n+/* Sets that we need to keep track of.  */\n+typedef struct bb_bitmap_sets\n+{\n+  /* The EXP_GEN set, which represents expressions/values generated in\n+     a basic block.  */\n+  bitmap_set_t exp_gen;\n+\n+  /* The PHI_GEN set, which represents PHI results generated in a\n+     basic block.  */\n+  bitmap_set_t phi_gen;\n+\n+  /* The TMP_GEN set, which represents results/temporaries generated\n+     in a basic block. IE the LHS of an expression.  */\n+  bitmap_set_t tmp_gen;\n+\n+  /* The AVAIL_OUT set, which represents which values are available in\n+     a given basic block.  */\n+  bitmap_set_t avail_out;\n+\n+  /* The ANTIC_IN set, which represents which values are anticipatable\n+     in a given basic block.  */\n+  bitmap_set_t antic_in;\n+\n+  /* The PA_IN set, which represents which values are\n+     partially anticipatable in a given basic block.  */\n+  bitmap_set_t pa_in;\n+\n+  /* The NEW_SETS set, which is used during insertion to augment the\n+     AVAIL_OUT set of blocks with the new insertions performed during\n+     the current iteration.  */\n+  bitmap_set_t new_sets;\n+\n+  /* A cache for value_dies_in_block_x.  */\n+  bitmap expr_dies;\n+\n+  /* The live virtual operand on successor edges.  */\n+  tree vop_on_exit;\n+\n+  /* PHI translate cache for the single successor edge.  */\n+  hash_table<expr_pred_trans_d> *phi_translate_table;\n+\n+  /* True if we have visited this block during ANTIC calculation.  */\n+  unsigned int visited : 1;\n+\n+  /* True when the block contains a call that might not return.  */\n+  unsigned int contains_may_not_return_call : 1;\n+} *bb_value_sets_t;\n+\n+#define EXP_GEN(BB)\t((bb_value_sets_t) ((BB)->aux))->exp_gen\n+#define PHI_GEN(BB)\t((bb_value_sets_t) ((BB)->aux))->phi_gen\n+#define TMP_GEN(BB)\t((bb_value_sets_t) ((BB)->aux))->tmp_gen\n+#define AVAIL_OUT(BB)\t((bb_value_sets_t) ((BB)->aux))->avail_out\n+#define ANTIC_IN(BB)\t((bb_value_sets_t) ((BB)->aux))->antic_in\n+#define PA_IN(BB)\t((bb_value_sets_t) ((BB)->aux))->pa_in\n+#define NEW_SETS(BB)\t((bb_value_sets_t) ((BB)->aux))->new_sets\n+#define EXPR_DIES(BB)\t((bb_value_sets_t) ((BB)->aux))->expr_dies\n+#define PHI_TRANS_TABLE(BB) ((bb_value_sets_t) ((BB)->aux))->phi_translate_table\n+#define BB_VISITED(BB)\t((bb_value_sets_t) ((BB)->aux))->visited\n+#define BB_MAY_NOTRETURN(BB) ((bb_value_sets_t) ((BB)->aux))->contains_may_not_return_call\n+#define BB_LIVE_VOP_ON_EXIT(BB) ((bb_value_sets_t) ((BB)->aux))->vop_on_exit\n+\n \n /* Add the tuple mapping from {expression E, basic block PRED} to\n    the phi translation table and return whether it pre-existed.  */\n \n static inline bool\n phi_trans_add (expr_pred_trans_t *entry, pre_expr e, basic_block pred)\n {\n+  if (!PHI_TRANS_TABLE (pred))\n+    PHI_TRANS_TABLE (pred) = new hash_table<expr_pred_trans_d> (11);\n+\n   expr_pred_trans_t slot;\n   expr_pred_trans_d tem;\n   unsigned id = get_expression_id (e);\n-  hashval_t hash = iterative_hash_hashval_t (id, pred->index);\n   tem.e = id;\n-  tem.pred = pred->index;\n-  slot = phi_translate_table->find_slot_with_hash (tem, hash, INSERT);\n+  slot = PHI_TRANS_TABLE (pred)->find_slot_with_hash (tem, id, INSERT);\n   if (slot->e)\n     {\n       *entry = slot;\n@@ -640,7 +631,6 @@ phi_trans_add (expr_pred_trans_t *entry, pre_expr e, basic_block pred)\n \n   *entry = slot;\n   slot->e = id;\n-  slot->pred = pred->index;\n   return false;\n }\n \n@@ -1702,7 +1692,6 @@ phi_translate (bitmap_set_t dest, pre_expr expr,\n \t       bitmap_set_t set1, bitmap_set_t set2, edge e)\n {\n   expr_pred_trans_t slot = NULL;\n-  size_t slot_size = 0;\n   pre_expr phitrans;\n \n   if (!expr)\n@@ -1723,7 +1712,6 @@ phi_translate (bitmap_set_t dest, pre_expr expr,\n       /* Store NULL for the value we want to return in the case of\n \t recursing.  */\n       slot->v = 0;\n-      slot_size = phi_translate_table->size ();\n     }\n \n   /* Translate.  */\n@@ -1734,15 +1722,14 @@ phi_translate (bitmap_set_t dest, pre_expr expr,\n \n   if (slot)\n     {\n-      /* Check for reallocation.  */\n-      if (phi_translate_table->size () != slot_size)\n-\tphi_trans_add (&slot, expr, e->src);\n+      /* We may have reallocated.  */\n+      phi_trans_add (&slot, expr, e->src);\n       if (phitrans)\n \tslot->v = get_expression_id (phitrans);\n       else\n \t/* Remove failed translations again, they cause insert\n \t   iteration to not pick up new opportunities reliably.  */\n-\tphi_translate_table->clear_slot (slot);\n+\tPHI_TRANS_TABLE (e->src)->clear_slot (slot);\n     }\n \n   return phitrans;\n@@ -1767,6 +1754,13 @@ phi_translate_set (bitmap_set_t dest, bitmap_set_t set, edge e)\n     }\n \n   exprs = sorted_array_from_bitmap_set (set);\n+  /* Allocate the phi-translation cache where we have an idea about\n+     its size.  hash-table implementation internals tell us that\n+     allocating the table to fit twice the number of elements will\n+     make sure we do not usually re-allocate.  */\n+  if (!PHI_TRANS_TABLE (e->src))\n+    PHI_TRANS_TABLE (e->src)\n+      = new hash_table<expr_pred_trans_d> (2 * exprs.length ());\n   FOR_EACH_VEC_ELT (exprs, i, expr)\n     {\n       pre_expr translated;\n@@ -4172,14 +4166,14 @@ init_pre (void)\n   calculate_dominance_info (CDI_DOMINATORS);\n \n   bitmap_obstack_initialize (&grand_bitmap_obstack);\n-  phi_translate_table = new hash_table<expr_pred_trans_d> (5110);\n   expression_to_id = new hash_table<pre_expr_d> (num_ssa_names * 3);\n   FOR_ALL_BB_FN (bb, cfun)\n     {\n       EXP_GEN (bb) = bitmap_set_new ();\n       PHI_GEN (bb) = bitmap_set_new ();\n       TMP_GEN (bb) = bitmap_set_new ();\n       AVAIL_OUT (bb) = bitmap_set_new ();\n+      PHI_TRANS_TABLE (bb) = NULL;\n     }\n }\n \n@@ -4196,12 +4190,14 @@ fini_pre ()\n   bitmap_obstack_release (&grand_bitmap_obstack);\n   bitmap_set_pool.release ();\n   pre_expr_pool.release ();\n-  delete phi_translate_table;\n-  phi_translate_table = NULL;\n   delete expression_to_id;\n   expression_to_id = NULL;\n   name_to_id.release ();\n \n+  basic_block bb;\n+  FOR_ALL_BB_FN (bb, cfun)\n+    if (PHI_TRANS_TABLE (bb))\n+      delete PHI_TRANS_TABLE (bb);\n   free_aux_for_blocks ();\n }\n "}]}