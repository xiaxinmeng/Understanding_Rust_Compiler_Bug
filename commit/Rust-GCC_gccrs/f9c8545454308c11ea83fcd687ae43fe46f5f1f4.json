{"sha": "f9c8545454308c11ea83fcd687ae43fe46f5f1f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjljODU0NTQ1NDMwOGMxMWVhODNmY2Q2ODdhZTQzZmU0NmY1ZjFmNA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchell@usa.net", "date": "1998-04-01T13:48:48Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-04-01T13:48:48Z"}, "message": "cplus-dem.c (optable): Add sizeof.\n\n\t* cplus-dem.c (optable): Add sizeof.\n\t(demangle_template_value_parm): New function containing code\n\tpreviously found in demangle_template.\n\t(demangle_integral_value): New function which handles complicated\n\tintegral expressions.\n\t(demangle_template): Use them.\n\nFrom-SVN: r18930", "tree": {"sha": "d0e07fbcb0ace24a88342beed1dc345aa4e928ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0e07fbcb0ace24a88342beed1dc345aa4e928ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9c8545454308c11ea83fcd687ae43fe46f5f1f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9c8545454308c11ea83fcd687ae43fe46f5f1f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9c8545454308c11ea83fcd687ae43fe46f5f1f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9c8545454308c11ea83fcd687ae43fe46f5f1f4/comments", "author": null, "committer": null, "parents": [{"sha": "c651e1e08571fdf59da9289e9fd97c0be84ec6b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c651e1e08571fdf59da9289e9fd97c0be84ec6b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c651e1e08571fdf59da9289e9fd97c0be84ec6b4"}], "stats": {"total": 487, "additions": 287, "deletions": 200}, "files": [{"sha": "6e6321b7fa9591993b1ed7867b51a8a96d35556e", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9c8545454308c11ea83fcd687ae43fe46f5f1f4/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9c8545454308c11ea83fcd687ae43fe46f5f1f4/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=f9c8545454308c11ea83fcd687ae43fe46f5f1f4", "patch": "@@ -1,3 +1,12 @@\n+1998-04-01  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* cplus-dem.c (optable): Add sizeof.\n+\t(demangle_template_value_parm): New function containing code\n+\tpreviously found in demangle_template.\n+\t(demangle_integral_value): New function which handles complicated \n+\tintegral expressions.\n+\t(demangle_template): Use them.\n+\n Thu Mar  5 09:23:28 1998  Manfred Hollstein  <manfred@s-direktnet.de>\n \n \t* config.table: Make locating frag files failsafe even for the"}, {"sha": "98e82eaa085a46d80f2bbaa6cbe999d110992270", "filename": "libiberty/cplus-dem.c", "status": "modified", "additions": 278, "deletions": 200, "changes": 478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9c8545454308c11ea83fcd687ae43fe46f5f1f4/libiberty%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9c8545454308c11ea83fcd687ae43fe46f5f1f4/libiberty%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcplus-dem.c?ref=f9c8545454308c11ea83fcd687ae43fe46f5f1f4", "patch": "@@ -192,7 +192,8 @@ static const struct optable\n   {\"min\",\t  \"<?\",\t\t0},\t\t/* old */\n   {\"mn\",\t  \"<?\",\t\tDMGL_ANSI},\t/* pseudo-ansi */\n   {\"nop\",\t  \"\",\t\t0},\t\t/* old (for operator=) */\n-  {\"rm\",\t  \"->*\",\tDMGL_ANSI}\t/* ansi */\n+  {\"rm\",\t  \"->*\",\tDMGL_ANSI},\t/* ansi */\n+  {\"sz\",          \"sizeof \",    DMGL_ANSI}      /* pseudo-ansi */\n };\n \n \n@@ -321,6 +322,10 @@ forget_types PARAMS ((struct work_stuff *));\n static void\n string_prepends PARAMS ((string *, string *));\n \n+static int \n+demangle_template_value_parm PARAMS ((struct work_stuff*, \n+\t\t\t\t      const char**, string*)); \n+\n /*  Translate count to integer, consuming tokens in the process.\n     Conversion terminates on the first non-digit character.\n     Trying to consume something that isn't a count results in\n@@ -922,6 +927,270 @@ demangle_method_args (work, mangled, declp)\n \n #endif\n \n+static int\n+demangle_integral_value (work, mangled, s)\n+     struct work_stuff *work;\n+     const char** mangled;\n+     string* s;\n+{\n+  int success;\n+\n+  if (**mangled == 'E')\n+    {\n+      int need_operator = 0;\n+      \n+      success = 1;\n+      string_appendn (s, \"(\", 1);\n+      (*mangled)++;\n+      while (success && **mangled != 'W' && **mangled != '\\0')\n+\t{\n+\t  if (need_operator)\n+\t    {\n+\t      size_t i;\n+\t      size_t len;\n+\n+\t      success = 0;\n+\n+\t      len = strlen (*mangled);\n+\n+\t      for (i = 0; \n+\t\t   i < sizeof (optable) / sizeof (optable [0]);\n+\t\t   ++i)\n+\t\t{\n+\t\t  size_t l = strlen (optable[i].in);\n+\n+\t\t  if (l <= len\n+\t\t      && memcmp (optable[i].in, *mangled, l) == 0)\n+\t\t    {\n+\t\t      string_appendn (s, \" \", 1);\n+\t\t      string_append (s, optable[i].out);\n+\t\t      string_appendn (s, \" \", 1);\n+\t\t      success = 1;\n+\t\t      (*mangled) += l;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\n+\t      if (!success)\n+\t\tbreak;\n+\t    }\n+\t  else\n+\t    need_operator = 1;\n+\n+\t  success = demangle_template_value_parm (work, mangled, s);\n+\t}\n+\n+      if (**mangled != 'W')\n+\t  success = 0;\n+      else \n+\t{\n+\t  string_appendn (s, \")\", 1);\n+\t  (*mangled)++;\n+\t}\n+    }\n+  else if (**mangled == 'Q')\n+    success = demangle_qualified (work, mangled, s, 0, 1);\n+  else\n+    {\n+      success = 0;\n+\n+      if (**mangled == 'm')\n+\t{\n+\t  string_appendn (s, \"-\", 1);\n+\t  (*mangled)++;\n+\t}\n+      while (isdigit (**mangled))\t\n+\t{\n+\t  string_appendn (s, *mangled, 1);\n+\t  (*mangled)++;\n+\t  success = 1;\n+\t}\n+    }\n+  \n+  return success;\n+}\n+\n+static int \n+demangle_template_value_parm (work, mangled, s)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string* s;\n+{\n+  const char *old_p = *mangled;\n+  int is_pointer = 0;\n+  int is_real = 0;\n+  int is_integral = 0;\n+  int is_char = 0;\n+  int is_bool = 0;\n+  int done = 0;\n+  int success = 1;\n+\n+  while (*old_p && !done)\n+    {\t\n+      switch (*old_p)\n+\t{\n+\tcase 'P':\n+\tcase 'p':\n+\tcase 'R':\n+\t  done = is_pointer = 1;\n+\t  break;\n+\tcase 'C':\t/* const */\n+\tcase 'S':\t/* explicitly signed [char] */\n+\tcase 'U':\t/* unsigned */\n+\tcase 'V':\t/* volatile */\n+\tcase 'F':\t/* function */\n+\tcase 'M':\t/* member function */\n+\tcase 'O':\t/* ??? */\n+\tcase 'J':\t/* complex */\n+\t  old_p++;\n+\t  continue;\n+\tcase 'E':       /* expression */\n+\tcase 'Q':\t/* qualified name */\n+\t  done = is_integral = 1;\n+\t  break;\n+\tcase 'T':\t/* remembered type */\n+\t  abort ();\n+\t  break;\n+\tcase 'v':\t/* void */\n+\t  abort ();\n+\t  break;\n+\tcase 'x':\t/* long long */\n+\tcase 'l':\t/* long */\n+\tcase 'i':\t/* int */\n+\tcase 's':\t/* short */\n+\tcase 'w':\t/* wchar_t */\n+\t  done = is_integral = 1;\n+\t  break;\n+\tcase 'b':\t/* bool */\n+\t  done = is_bool = 1;\n+\t  break;\n+\tcase 'c':\t/* char */\n+\t  done = is_char = 1;\n+\t  break;\n+\tcase 'r':\t/* long double */\n+\tcase 'd':\t/* double */\n+\tcase 'f':\t/* float */\n+\t  done = is_real = 1;\n+\t  break;\n+\tdefault:\n+\t  /* it's probably user defined type, let's assume\n+\t     it's integral, it seems hard to figure out\n+\t     what it really is */\n+\t  done = is_integral = 1;\n+\t}\n+    }\n+  if (**mangled == 'Y')\n+    {\n+      /* The next argument is a template parameter. */\n+      int idx;\n+\n+      (*mangled)++;\n+      idx = consume_count_with_underscores (mangled);\n+      if (idx == -1 \n+\t  || (work->tmpl_argvec && idx >= work->ntmpl_args)\n+\t  || consume_count_with_underscores (mangled) == -1)\n+\treturn -1;\n+      if (work->tmpl_argvec)\n+\tstring_append (s, work->tmpl_argvec[idx]);\n+      else\n+\t{\n+\t  char buf[10];\n+\t  sprintf(buf, \"T%d\", idx);\n+\t  string_append (s, buf);\n+\t}\n+    }\n+  else if (is_integral)\n+    success = demangle_integral_value (work, mangled, s);\n+  else if (is_char)\n+    {\n+      char tmp[2];\n+      int val;\n+      if (**mangled == 'm')\n+\t{\n+\t  string_appendn (s, \"-\", 1);\n+\t  (*mangled)++;\n+\t}\n+      string_appendn (s, \"'\", 1);\n+      val = consume_count(mangled);\n+      if (val == 0)\n+\treturn -1;\n+      tmp[0] = (char)val;\n+      tmp[1] = '\\0';\n+      string_appendn (s, &tmp[0], 1);\n+      string_appendn (s, \"'\", 1);\n+    }\n+  else if (is_bool)\n+    {\n+      int val = consume_count (mangled);\n+      if (val == 0)\n+\tstring_appendn (s, \"false\", 5);\n+      else if (val == 1)\n+\tstring_appendn (s, \"true\", 4);\n+      else\n+\tsuccess = 0;\n+    }\n+  else if (is_real)\n+    {\n+      if (**mangled == 'm')\n+\t{\n+\t  string_appendn (s, \"-\", 1);\n+\t  (*mangled)++;\n+\t}\n+      while (isdigit (**mangled))\t\n+\t{\n+\t  string_appendn (s, *mangled, 1);\n+\t  (*mangled)++;\n+\t}\n+      if (**mangled == '.') /* fraction */\n+\t{\n+\t  string_appendn (s, \".\", 1);\n+\t  (*mangled)++;\n+\t  while (isdigit (**mangled))\t\n+\t    {\n+\t      string_appendn (s, *mangled, 1);\n+\t      (*mangled)++;\n+\t    }\n+\t}\n+      if (**mangled == 'e') /* exponent */\n+\t{\n+\t  string_appendn (s, \"e\", 1);\n+\t  (*mangled)++;\n+\t  while (isdigit (**mangled))\t\n+\t    {\n+\t      string_appendn (s, *mangled, 1);\n+\t      (*mangled)++;\n+\t    }\n+\t}\n+    }\n+  else if (is_pointer)\n+    {\n+      int symbol_len = consume_count (mangled);\n+      if (symbol_len == 0)\n+\treturn -1;\n+      if (symbol_len == 0)\n+\tstring_appendn (s, \"0\", 1);\n+      else\n+\t{\n+\t  char *p = xmalloc (symbol_len + 1), *q;\n+\t  strncpy (p, *mangled, symbol_len);\n+\t  p [symbol_len] = '\\0';\n+\t  q = cplus_demangle (p, work->options);\n+\t  string_appendn (s, \"&\", 1);\n+\t  if (q)\n+\t    {\n+\t      string_append (s, q);\n+\t      free (q);\n+\t    }\n+\t  else\n+\t    string_append (s, p);\n+\t  free (p);\n+\t}\n+      *mangled += symbol_len;\n+    }\n+\n+  return success;\n+}\n+\n static int\n demangle_template (work, mangled, tname, trawname, is_type)\n      struct work_stuff *work;\n@@ -931,18 +1200,10 @@ demangle_template (work, mangled, tname, trawname, is_type)\n      int is_type;\n {\n   int i;\n-  int is_pointer;\n-  int is_real;\n-  int is_integral;\n-  int is_char;\n-  int is_bool;\n   int r;\n   int need_comma = 0;\n   int success = 0;\n-  int done;\n-  const char *old_p;\n   const char *start;\n-  int symbol_len;\n   int is_java_array = 0;\n   string temp;\n \n@@ -1017,13 +1278,7 @@ demangle_template (work, mangled, tname, trawname, is_type)\n \t  string* s;\n \n \t  /* otherwise, value parameter */\n-\t  old_p  = *mangled;\n-\t  is_pointer = 0;\n-\t  is_real = 0;\n-\t  is_integral = 0;\n-          is_char = 0;\n-\t  is_bool = 0;\n-\t  done = 0;\n+\n \t  /* temp is initialized in do_type */\n \t  success = do_type (work, mangled, &temp);\n \t  /*\n@@ -1049,193 +1304,16 @@ demangle_template (work, mangled, tname, trawname, is_type)\n \t  else\n \t    s = tname;\n \n-\t  while (*old_p && !done)\n-\t    {\t\n-\t      switch (*old_p)\n-\t\t{\n-\t\tcase 'P':\n-\t\tcase 'p':\n-\t\tcase 'R':\n-\t\t  done = is_pointer = 1;\n-\t\t  break;\n-\t\tcase 'C':\t/* const */\n-\t\tcase 'S':\t/* explicitly signed [char] */\n-\t\tcase 'U':\t/* unsigned */\n-\t\tcase 'V':\t/* volatile */\n-\t\tcase 'F':\t/* function */\n-\t\tcase 'M':\t/* member function */\n-\t\tcase 'O':\t/* ??? */\n-\t\tcase 'J':\t/* complex */\n-\t\t  old_p++;\n-\t\t  continue;\n-\t\tcase 'Q':\t/* qualified name */\n-\t\t  done = is_integral = 1;\n-\t\t  break;\n-\t\tcase 'T':\t/* remembered type */\n-\t\t  abort ();\n-\t\t  break;\n-\t\tcase 'v':\t/* void */\n-\t\t  abort ();\n-\t\t  break;\n-\t\tcase 'x':\t/* long long */\n-\t\tcase 'l':\t/* long */\n-\t\tcase 'i':\t/* int */\n-\t\tcase 's':\t/* short */\n-\t\tcase 'w':\t/* wchar_t */\n-\t\t  done = is_integral = 1;\n-\t\t  break;\n-\t\tcase 'b':\t/* bool */\n-\t\t  done = is_bool = 1;\n-\t\t  break;\n-\t\tcase 'c':\t/* char */\n-\t\t  done = is_char = 1;\n-\t\t  break;\n-\t\tcase 'r':\t/* long double */\n-\t\tcase 'd':\t/* double */\n-\t\tcase 'f':\t/* float */\n-\t\t  done = is_real = 1;\n-\t\t  break;\n-\t\tdefault:\n-\t\t  /* it's probably user defined type, let's assume\n-\t\t     it's integral, it seems hard to figure out\n-\t\t     what it really is */\n-\t\t  done = is_integral = 1;\n-\t\t}\n-\t    }\n-\t  if (**mangled == 'Y')\n-\t    {\n-\t      /* The next argument is a template parameter. */\n-\t      int idx;\n+\t  success = demangle_template_value_parm (work, mangled, s);\n \n-\t      (*mangled)++;\n-\t      idx = consume_count_with_underscores (mangled);\n-\t      if (idx == -1 \n-\t\t  || (work->tmpl_argvec && idx >= work->ntmpl_args)\n-\t\t  || consume_count_with_underscores (mangled) == -1)\n-\t\t{\n-\t\t  success = 0;\n-\t\t  if (!is_type)\n-\t\t    string_delete (s);\n-\t\t  break;\n-\t\t}\n-\t      if (work->tmpl_argvec)\n-\t\tstring_append (s, work->tmpl_argvec[idx]);\n-\t      else\n-\t\t{\n-\t\t  char buf[10];\n-\t\t  sprintf(buf, \"T%d\", idx);\n-\t\t  string_append (s, buf);\n-\t\t}\n-\t    }\n-\t  else if (is_integral)\n-\t    {\n-\t      if (**mangled == 'm')\n-\t\t{\n-\t\t  string_appendn (s, \"-\", 1);\n-\t\t  (*mangled)++;\n-\t\t}\n-\t      while (isdigit (**mangled))\t\n-\t\t{\n-\t\t  string_appendn (s, *mangled, 1);\n-\t\t  (*mangled)++;\n-\t\t}\n-\t    }\n-\t  else if (is_char)\n-\t    {\n-\t      char tmp[2];\n-\t      int val;\n-              if (**mangled == 'm')\n-                {\n-                  string_appendn (s, \"-\", 1);\n-                  (*mangled)++;\n-                }\n-\t      string_appendn (s, \"'\", 1);\n-              val = consume_count(mangled);\n-\t      if (val == 0)\n-\t\t{\n-\t\t  success = 0;\n-\t\t  if (!is_type)\n-\t\t    string_delete (s);\n-\t\t  break;\n-                }\n-              tmp[0] = (char)val;\n-              tmp[1] = '\\0';\n-              string_appendn (s, &tmp[0], 1);\n-\t      string_appendn (s, \"'\", 1);\n-\t    }\n-\t  else if (is_bool)\n-\t    {\n-\t      int val = consume_count (mangled);\n-\t      if (val == 0)\n-\t\tstring_appendn (s, \"false\", 5);\n-\t      else if (val == 1)\n-\t\tstring_appendn (s, \"true\", 4);\n-\t      else\n-\t\tsuccess = 0;\n-\t    }\n-\t  else if (is_real)\n-\t    {\n-\t      if (**mangled == 'm')\n-\t\t{\n-\t\t  string_appendn (s, \"-\", 1);\n-\t\t  (*mangled)++;\n-\t\t}\n-\t      while (isdigit (**mangled))\t\n-\t\t{\n-\t\t  string_appendn (s, *mangled, 1);\n-\t\t  (*mangled)++;\n-\t\t}\n-\t      if (**mangled == '.') /* fraction */\n-\t\t{\n-\t\t  string_appendn (s, \".\", 1);\n-\t\t  (*mangled)++;\n-\t\t  while (isdigit (**mangled))\t\n-\t\t    {\n-\t\t      string_appendn (s, *mangled, 1);\n-\t\t      (*mangled)++;\n-\t\t    }\n-\t\t}\n-\t      if (**mangled == 'e') /* exponent */\n-\t\t{\n-\t\t  string_appendn (s, \"e\", 1);\n-\t\t  (*mangled)++;\n-\t\t  while (isdigit (**mangled))\t\n-\t\t    {\n-\t\t      string_appendn (s, *mangled, 1);\n-\t\t      (*mangled)++;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  else if (is_pointer)\n+\t  if (!success)\n \t    {\n-\t      symbol_len = consume_count (mangled);\n-\t      if (symbol_len == 0)\n-\t\t{\n-\t\t  success = 0;\n-\t\t  if (!is_type)\n-\t\t    string_delete (s);\n-\t\t  break;\n-\t\t}\n-\t      if (symbol_len == 0)\n-\t\tstring_appendn (s, \"0\", 1);\n-\t      else\n-\t\t{\n-\t\t  char *p = xmalloc (symbol_len + 1), *q;\n-\t\t  strncpy (p, *mangled, symbol_len);\n-\t\t  p [symbol_len] = '\\0';\n-\t\t  q = cplus_demangle (p, work->options);\n-\t\t  string_appendn (s, \"&\", 1);\n-\t\t  if (q)\n-\t\t    {\n-\t\t      string_append (s, q);\n-\t\t      free (q);\n-\t\t    }\n-\t\t  else\n-\t\t    string_append (s, p);\n-\t\t  free (p);\n-\t\t}\n-\t      *mangled += symbol_len;\n+\t      if (!is_type)\n+\t\tstring_delete (s);\n+\t      success = 0;\n+\t      break;\n \t    }\n+\n \t  if (!is_type)\n \t    {\n \t      int len = s->p - s->b;"}]}