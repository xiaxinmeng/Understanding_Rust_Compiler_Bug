{"sha": "9e1376e94de56d624eb99bdcb5dff7a0bb03fc21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWUxMzc2ZTk0ZGU1NmQ2MjRlYjk5YmRjYjVkZmY3YTBiYjAzZmMyMQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-09-11T02:23:48Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-09-11T02:23:48Z"}, "message": "re PR tree-optimization/58380 (ice in fold_comparison)\n\n\tPR tree-optimization/58380\n\t* tree-ssa-threadupdate.c (thread_block): Recognize another case\n\tof threading through a buried loop header.\n\n\t* tree-ssa-threadedge.c (thread_around_empty_blocks): Correct\n\treturn value for single successor case.\n\n\t* g++.dg/torture/pr58380.C: New test.\n\n2013-09-10  Jeff Law  <law@redhat.com>\n\nFrom-SVN: r202489", "tree": {"sha": "2477817e3acba588af69e3d3c3b9166d7e6d8757", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2477817e3acba588af69e3d3c3b9166d7e6d8757"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e1376e94de56d624eb99bdcb5dff7a0bb03fc21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e1376e94de56d624eb99bdcb5dff7a0bb03fc21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e1376e94de56d624eb99bdcb5dff7a0bb03fc21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e1376e94de56d624eb99bdcb5dff7a0bb03fc21/comments", "author": null, "committer": null, "parents": [{"sha": "df7d9dfde3ac4d964866ce8867710dc788ecf3d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df7d9dfde3ac4d964866ce8867710dc788ecf3d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df7d9dfde3ac4d964866ce8867710dc788ecf3d7"}], "stats": {"total": 219, "additions": 209, "deletions": 10}, "files": [{"sha": "21c8538b3ab18e25aadf25951a6373c9fdea2aaa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1376e94de56d624eb99bdcb5dff7a0bb03fc21/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1376e94de56d624eb99bdcb5dff7a0bb03fc21/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e1376e94de56d624eb99bdcb5dff7a0bb03fc21", "patch": "@@ -1,3 +1,12 @@\n+2013-09-10  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/58380\n+\t* tree-ssa-threadupdate.c (thread_block): Recognize another case\n+\tof threading through a buried loop header.\n+\n+\t* tree-ssa-threadedge.c (thread_around_empty_blocks): Correct\n+\treturn value for single successor case.\n+\n 2013-09-10  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-devirt.c (ipa_devirt): Enable with LTO."}, {"sha": "ae9e6e2af623d07a649a18aaf6bbebad8f52e3d4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1376e94de56d624eb99bdcb5dff7a0bb03fc21/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1376e94de56d624eb99bdcb5dff7a0bb03fc21/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9e1376e94de56d624eb99bdcb5dff7a0bb03fc21", "patch": "@@ -1,3 +1,7 @@\n+2013-09-10  Jeff Law  <law@redhat.com>\n+\n+\t* g++.dg/torture/pr58380.C: New test.\n+\n 2013-09-10  Jan Hubicka  <jh@suse.cz>\n \t    Paolo Carlini  <paolo.carlini@oracle.com>\n "}, {"sha": "b2c185d8f0efee24cd6fd9f945108081e479c5c4", "filename": "gcc/testsuite/g++.dg/torture/pr58380.C", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1376e94de56d624eb99bdcb5dff7a0bb03fc21/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr58380.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1376e94de56d624eb99bdcb5dff7a0bb03fc21/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr58380.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr58380.C?ref=9e1376e94de56d624eb99bdcb5dff7a0bb03fc21", "patch": "@@ -0,0 +1,171 @@\n+// { dg-do compile }\n+class iplugin_factory;\n+class idocument_plugin_factory {\n+  virtual idocument_plugin_factory *create_plugin(iplugin_factory &, int &);\n+};\n+template <typename _Iterator, typename> class __normal_iterator {\n+  _Iterator _M_current;\n+\n+public:\n+  _Iterator iterator_type;\n+  __normal_iterator(const _Iterator &p1) : _M_current(p1) {}\n+  void operator++();\n+  _Iterator &base() { return _M_current; }\n+};\n+\n+template <typename _IteratorL, typename _IteratorR, typename _Container>\n+int operator!=(__normal_iterator<_IteratorL, _Container> &p1,\n+               __normal_iterator<_IteratorR, _Container> &p2) {\n+  return p1.base() != p2.base();\n+}\n+\n+class new_allocator {\n+public:\n+  typedef int *const_pointer;\n+  int *allocate();\n+};\n+template <typename> class allocator : public new_allocator {};\n+\n+class basic_string {\n+public:\n+  basic_string(char *);\n+};\n+struct __uninitialized_copy {\n+  template <typename _InputIterator, typename _ForwardIterator>\n+  static _ForwardIterator __uninit_copy(_InputIterator p1, _InputIterator p2,\n+                                        _ForwardIterator p3) try {\n+    for (; p1 != p2; ++p1, ++p3)\n+      ;\n+    return p3;\n+  }\n+  catch (...) {\n+  }\n+};\n+\n+template <typename _InputIterator, typename _ForwardIterator>\n+_ForwardIterator uninitialized_copy(_InputIterator p1, _InputIterator p2,\n+                                    _ForwardIterator p3) {\n+  return __uninitialized_copy::__uninit_copy(p1, p2, p3);\n+}\n+\n+template <typename _InputIterator, typename _ForwardIterator, typename _Tp>\n+_ForwardIterator __uninitialized_copy_a(_InputIterator p1, _InputIterator p2,\n+                                        _ForwardIterator p3, allocator<_Tp> &) {\n+  return uninitialized_copy(p1, p2, p3);\n+}\n+\n+struct _Vector_base {\n+  struct _Vector_impl : allocator<int> {\n+    int *_M_start;\n+    int *_M_finish;\n+  };\n+  allocator<int> &_M_get_Tp_allocator() {}\n+  _Vector_base() {}\n+  _Vector_base(int p1) { _M_create_storage(p1); }\n+  _Vector_impl _M_impl;\n+  int *_M_allocate(int p1) { p1 ? _M_impl.allocate() : 0; }\n+  void _M_create_storage(int p1) {\n+    this->_M_impl._M_start = this->_M_allocate(p1);\n+  }\n+};\n+\n+class vector : _Vector_base {\n+  _Vector_base _Base;\n+\n+public:\n+  vector() {}\n+  vector(const vector &p1) : _Base(p1.size()) {\n+    this->_M_impl._M_finish = __uninitialized_copy_a(\n+        p1.begin(), p1.end(), this->_M_impl._M_start, _M_get_Tp_allocator());\n+  }\n+  ~vector();\n+  __normal_iterator<typename allocator<int>::const_pointer, int> begin() const {\n+    return this->_M_impl._M_start;\n+  }\n+  __normal_iterator<typename allocator<int>::const_pointer, int> end() const {\n+    return this->_M_impl._M_finish;\n+  }\n+  int size() const { return this->_M_impl._M_finish - this->_M_impl._M_start; }\n+};\n+class iplugin_factory {\n+public:\n+  typedef enum {\n+    STABLE,\n+    EXPERIMENTAL\n+  } quality_t;\n+};\n+class plugin_factory : public iplugin_factory {\n+public:\n+  plugin_factory(const int &, const basic_string &, const basic_string &,\n+                 const basic_string &, quality_t);\n+};\n+template <typename plugin_t>\n+class document_plugin_factory : plugin_factory, idocument_plugin_factory {\n+public:\n+  document_plugin_factory(const int &p1, const basic_string &,\n+                          const basic_string &, const basic_string &, quality_t)\n+      : plugin_factory(0, 0, 0, 0, STABLE) {}\n+  idocument_plugin_factory *create_plugin(iplugin_factory &p1, int &p2) {\n+    plugin_t(p1, p2);\n+  }\n+};\n+\n+class container {\n+public:\n+  template <typename init_t> container(init_t &);\n+};\n+template <class init_t> class initializer_t : init_t {\n+public:\n+  initializer_t(const init_t &p1) : init_t(p1) {}\n+};\n+\n+class composition_t {};\n+template <typename lhs_t, typename rhs_t>\n+const initializer_t<composition_t> operator+(const initializer_t<lhs_t> &,\n+                                             const initializer_t<rhs_t> &);\n+template <typename value_t> class value_initializer_t {\n+public:\n+  value_initializer_t(const value_t &p1) : m_value(p1) {}\n+  value_t m_value;\n+};\n+\n+template <typename value_t>\n+initializer_t<value_initializer_t<value_t> > init_value(const value_t &p1) {\n+  initializer_t<value_initializer_t<value_t> >(\n+      value_initializer_t<value_t>(p1));\n+}\n+\n+class name_t {};\n+class label_t {};\n+class description_t {};\n+class owner_initializer_t {};\n+template <typename owner_t>\n+initializer_t<owner_initializer_t> init_owner(owner_t &);\n+class set : vector {};\n+class node {\n+public:\n+  node(iplugin_factory &, int &);\n+};\n+initializer_t<name_t> init_name();\n+initializer_t<label_t> init_label();\n+initializer_t<description_t> init_description();\n+template <typename base_t> class mesh_selection_sink : base_t {\n+public:\n+  mesh_selection_sink(iplugin_factory &p1, int &p2)\n+      : base_t(p1, p2),\n+        m_mesh_selection(init_owner(*this) + init_name() + init_label() +\n+                         init_description() + init_value(set())) {}\n+  container m_mesh_selection;\n+};\n+\n+class selection_to_stdout : mesh_selection_sink<node> {\n+public:\n+  selection_to_stdout(iplugin_factory &p1, int &p2)\n+      : mesh_selection_sink(p1, p2) {}\n+  static iplugin_factory &get_factory() {\n+    document_plugin_factory<selection_to_stdout>(0, \"\", 0, \"\",\n+                                                 iplugin_factory::EXPERIMENTAL);\n+  }\n+};\n+\n+void selection_to_stdout_factory() { selection_to_stdout::get_factory(); }"}, {"sha": "839f1859c1d2e5701cba4ccb33a34609da18df11", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1376e94de56d624eb99bdcb5dff7a0bb03fc21/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1376e94de56d624eb99bdcb5dff7a0bb03fc21/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=9e1376e94de56d624eb99bdcb5dff7a0bb03fc21", "patch": "@@ -770,7 +770,19 @@ thread_around_empty_blocks (edge taken_edge,\n   gsi = gsi_start_nondebug_bb (bb);\n \n   /* If the block has no statements, but does have a single successor, then\n-     it's just a forwarding block and we can thread through it trivially.  */\n+     it's just a forwarding block and we can thread through it trivially. \n+\n+     However, note that just threading through empty blocks with single\n+     successors is not inherently profitable.  For the jump thread to\n+     be profitable, we must avoid a runtime conditional.\n+\n+     By taking the return value from the recursive call, we get the\n+     desired effect of returning TRUE when we found a profitable jump\n+     threading opportunity and FALSE otherwise. \n+\n+     This is particularly important when this routine is called after\n+     processing a joiner block.  Returning TRUE too aggressively in\n+     that case results in pointless duplication of the joiner block.  */\n   if (gsi_end_p (gsi))\n     {\n       if (single_succ_p (bb))\n@@ -781,15 +793,16 @@ thread_around_empty_blocks (edge taken_edge,\n \t    {\n \t      bitmap_set_bit (visited, taken_edge->dest->index);\n \t      path->safe_push (taken_edge);\n-\t      thread_around_empty_blocks (taken_edge,\n-\t\t\t\t\t  dummy_cond,\n-\t\t\t\t\t  handle_dominating_asserts,\n-\t\t\t\t\t  simplify,\n-\t\t\t\t\t  visited,\n-\t\t\t\t\t  path);\n-\t      return true;\n+\t      return thread_around_empty_blocks (taken_edge,\n+\t\t\t\t\t\t dummy_cond,\n+\t\t\t\t\t\t handle_dominating_asserts,\n+\t\t\t\t\t\t simplify,\n+\t\t\t\t\t\t visited,\n+\t\t\t\t\t\t path);\n \t    }\n \t}\n+\n+      /* We have a block with no statements, but multiple successors?  */\n       return false;\n     }\n "}, {"sha": "6d43dc3c9474b07927f2a61db4ac93b1eaa32c4f", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e1376e94de56d624eb99bdcb5dff7a0bb03fc21/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e1376e94de56d624eb99bdcb5dff7a0bb03fc21/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=9e1376e94de56d624eb99bdcb5dff7a0bb03fc21", "patch": "@@ -659,8 +659,10 @@ thread_block (basic_block bb, bool noloop_only)\n \t     threading path.  We do not try and thread this elsewhere, so\n \t     just cancel the jump threading request by clearing the AUX\n \t     field now.  */\n-\t  if (bb->loop_father != e2->src->loop_father\n-\t      && !loop_exit_edge_p (e2->src->loop_father, e2))\n+\t  if ((bb->loop_father != e2->src->loop_father\n+\t       && !loop_exit_edge_p (e2->src->loop_father, e2))\n+\t      || (e2->src->loop_father != e2->dest->loop_father\n+\t\t  && !loop_exit_edge_p (e2->src->loop_father, e2)))\n \t    {\n \t      /* Since this case is not handled by our special code\n \t\t to thread through a loop header, we must explicitly"}]}