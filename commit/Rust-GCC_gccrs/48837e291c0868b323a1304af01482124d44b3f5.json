{"sha": "48837e291c0868b323a1304af01482124d44b3f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg4MzdlMjkxYzA4NjhiMzIzYTEzMDRhZjAxNDgyMTI0ZDQ0YjNmNQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-07-11T22:51:17Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-07-11T22:51:17Z"}, "message": "h8300.c (cpu_type, [...]): New variables.\n\n\t* h8300/h8300.c (cpu_type, names_extended, names_upper_extended,\n\th8_reg_names, h8_push_ops, h8_pop_ops, h8_mov_ops, h8_push_op,\n\th8_pop_op, h8_mov_op, current_function_anonymous_args, extra_pop,\n\thand_list): New variables.\n\t(h8300_init_once, asm_file_start, asm_file_end, ok_for_bclr, o_operand,\n\tp_operand, call_insn_operand, jump_address_operand, bit_operand,\n\teq_operator, const_costs, notice_update_cc, bit_operator,\n\tnshift_operator, expand_a_shift, get_shift_alg, emit_a_shift,\n\tfix_bit_operand): New functions.\n\t(shift_alg, shift_type, shift_mode): New enums.\n\t(shift_insn): New struct.\n\t(shift_n_bits, can_shift): Deleted.\n\t(shift_one, rotate_one): New variables.\n\t(WORD_REG_USED): New macro (was function word_reg_used).\n\t(dosize, function_prologue, function_epilogue, print_operand_address):\n\tAdd h8/300h support.\n\t(small_power_of_two): Renamed from potl8.\n\t(potg8): Deleted.\n\t(general_operand_src): Fix POST_INC case.\n\t(general_operand_dst): Fix PRE_DEC case.\n\t(function_arg): 3 regs of args are passed if -mquickcall.\n\t4 regs of args are passed to handwritten assembler routines.\n\t(print_operand): New cases 'A', 'P', 'S', 'U', 'W', 'b', 'c', 'd', 'g'.\n\tDelete case 'O'.  Sort cases.  Add h8/300h support.\n\t(do_movsi): Renamed from domovsi.\n\tHandle reload_in_progress and reload_completed.\n\t(initial_offset): Renamed from io.  Add h8/300h support.\n\nFrom-SVN: r7729", "tree": {"sha": "3394fc6112d3885681f8c8ef122478aeb8bc512c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3394fc6112d3885681f8c8ef122478aeb8bc512c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48837e291c0868b323a1304af01482124d44b3f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48837e291c0868b323a1304af01482124d44b3f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48837e291c0868b323a1304af01482124d44b3f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48837e291c0868b323a1304af01482124d44b3f5/comments", "author": null, "committer": null, "parents": [{"sha": "7bc8cb2b6be16ffbf5fbc3f0aebaa4203cc06f2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bc8cb2b6be16ffbf5fbc3f0aebaa4203cc06f2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bc8cb2b6be16ffbf5fbc3f0aebaa4203cc06f2e"}], "stats": {"total": 1848, "additions": 1484, "deletions": 364}, "files": [{"sha": "b559cef5b4db001140c8b9b7a82e10ba48eb1c01", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 1484, "deletions": 364, "changes": 1848, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48837e291c0868b323a1304af01482124d44b3f5/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48837e291c0868b323a1304af01482124d44b3f5/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=48837e291c0868b323a1304af01482124d44b3f5", "patch": "@@ -1,8 +1,7 @@\n /* Subroutines for insn-output.c for Hitachi H8/300.\n-   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n-\n-   Contributed by Steve Chamberlain (sac@cygnus.com) and\n-   Jim Wilson (wilson@cygnus.com).\n+   Copyright (C) 1992, 1993, 1994 Free Software Foundation, Inc.\n+   Contributed by Steve Chamberlain (sac@cygnus.com),\n+   Jim Wilson (wilson@cygnus.com), and Doug Evans (dje@cygnus.com).\n \n This file is part of GNU CC.\n \n@@ -40,42 +39,85 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n void print_operand_address ();\n char *index ();\n \n+/* CPU_TYPE, says what cpu we're compiling for.  */\n+int cpu_type;\n+\n /* True if a #pragma interrupt has been seen for the current function.  */\n int pragma_interrupt;\n \n /* True if a #pragma saveall has been seen for the current function.  */\n int pragma_saveall;\n \n-char *names_big[] \n- = {\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\"};\n+static char *names_big[] =\n+{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\"};\n+\n+static char *names_extended[] =\n+{\"er0\", \"er1\", \"er2\", \"er3\", \"er4\", \"er5\", \"er6\", \"er7\"};\n+\n+static char *names_upper_extended[] =\n+{\"e0\", \"e1\", \"e2\", \"e3\", \"e4\", \"e5\", \"e6\", \"e7\"};\n+\n+/* Points to one of the above.  */\n+/* ??? The above could be put in an array indexed by CPU_TYPE.  */\n+char **h8_reg_names;\n+\n+/* Various operations needed by the following, indexed by CPU_TYPE.  */\n+/* ??? The h8/300 assembler doesn't understand pop.w (yet).  */\n+\n+static char *h8_push_ops[2] =\n+{\"push\", \"push.l\"};\n+static char *h8_pop_ops[2] =\n+{\"pop\", \"pop.l\"};\n+static char *h8_mov_ops[2] =\n+{\"mov.w\", \"mov.l\"};\n+\n+char *h8_push_op, *h8_pop_op, *h8_mov_op;\n+\n+/* Initialize various cpu specific globals at start up.  */\n+\n+void\n+h8300_init_once ()\n+{\n+  if (TARGET_H8300)\n+    {\n+      cpu_type = (int) CPU_H8300;\n+      h8_reg_names = names_big;\n+    }\n+  else\n+    {\n+      cpu_type = (int) CPU_H8300H;\n+      h8_reg_names = names_extended;\n+    }\n+  h8_push_op = h8_push_ops[cpu_type];\n+  h8_pop_op = h8_pop_ops[cpu_type];\n+  h8_mov_op = h8_mov_ops[cpu_type];\n+}\n \n char *\n byte_reg (x, b)\n      rtx x;\n      int b;\n {\n-  static char *names_small[] \n-    =  {\"r0l\", \"r0h\", \"r1l\", \"r1h\", \"r2l\", \"r2h\", \"r3l\", \"r3h\",\n-\t\"r4l\", \"r4h\", \"r5l\", \"r5h\", \"r6l\", \"r6h\", \"r7lBAD\", \"r7hBAD\"};\n+  static char *names_small[] =\n+  {\"r0l\", \"r0h\", \"r1l\", \"r1h\", \"r2l\", \"r2h\", \"r3l\", \"r3h\",\n+   \"r4l\", \"r4h\", \"r5l\", \"r5h\", \"r6l\", \"r6h\", \"r7lBAD\", \"r7hBAD\"};\n \n   return names_small[REGNO (x) * 2 + b];\n }\n \n /* REGNO must be saved/restored across calls if this macro is true.  */\n-static int \n-word_reg_used (regno)\n-int regno;\n-{\n-  if (regno < 7  \n-      && (pragma_interrupt || pragma_saveall \n-\t  || (regno == FRAME_POINTER_REGNUM && regs_ever_live[regno])\n-\t  || (regs_ever_live[regno] & ! call_used_regs[regno])))\n-    return 1;\n-  return 0;\n-}\n+\n+#define WORD_REG_USED(regno)\t\t\t\t\t\\\n+  (regno < 7 &&\t\t\t\t\t\t\t\\\n+   (pragma_interrupt\t\t\t\t\t\t\\\n+    || pragma_saveall\t\t\t\t\t\t\\\n+    || (regno == FRAME_POINTER_REGNUM && regs_ever_live[regno])\t\\\n+    || (regs_ever_live[regno] & !call_used_regs[regno])))\n \n /* Output assembly language to FILE for the operation OP with operand size\n-   SIZE.  */\n+   SIZE to adjust the stack pointer.  */\n+/* ??? FPED is currently unused.  */\n+\n static void\n dosize (file, op, size, fped)\n      FILE *file;\n@@ -86,6 +128,7 @@ dosize (file, op, size, fped)\n   switch (size)\n     {\n     case 4:\n+      /* ??? TARGET_H8300H can do this in one insn.  */\n     case 3:\n       fprintf (file, \"\\t%ss\\t#%d,sp\\n\", op, 2);\n       size -= 2;\n@@ -98,66 +141,112 @@ dosize (file, op, size, fped)\n     case 0:\n       break;\n     default:\n-      fprintf (file, \"\\tmov.w\\t#%d,r5\\n\\t%s.w\\tr5,sp\\n\", size, op);\n+      if (TARGET_H8300)\n+\tfprintf (file, \"\\tmov.w\\t#%d,r3\\n\\t%s.w\\tr3,sp\\n\", size, op);\n+      else\n+\tfprintf (file, \"\\t%s\\t#%d,sp\\n\", op, size);\n       size = 0;\n       break;\n     }\n }\n \n /* Output assembly language code for the function prologue.  */\n-static int push_order[FIRST_PSEUDO_REGISTER] \n-  = {6, 5, 4, 3, 2, 1, 0, -1, -1};\n-static int pop_order[FIRST_PSEUDO_REGISTER] \n-  = {0, 1, 2, 3, 4, 5, 6, -1, -1};\n+static int push_order[FIRST_PSEUDO_REGISTER] =\n+{6, 5, 4, 3, 2, 1, 0, -1, -1};\n+static int pop_order[FIRST_PSEUDO_REGISTER] =\n+{0, 1, 2, 3, 4, 5, 6, -1, -1};\n \n /* This is what the stack looks like after the prolog of \n    a function with a frame has been set up:\n \n-\t<pushed args>\n-\treturn pc\n-   fp->\told fp\n-   \t<locals>\n-\t<saved register-0> \n-\t<saved register-1> \n-   sp->\t<saved register-n>\n-\n+   <args>\n+   PC\n+   FP\t\t\t<- fp\n+   <locals>\n+   <saved registers> \t<- sp\n \n    This is what the stack looks like after the prolog of\n    a function which doesn't have a frame:\n \n-   \t<pushed args>\n-   \treturn pc\n-\t<locals>\n-\t<saved register-0>\n-   sp-> <saved register-n>\n+   <args>\n+   PC\n+   <locals>\n+   <saved registers>   \t<- sp\n */\n \n+int current_function_anonymous_args;\n+\n+/* Extra arguments to pop, in words (IE: 2 bytes for 300, 4 for 300h */\n+static int extra_pop;\n+\n void\n function_prologue (file, size)\n      FILE *file;\n      int size;\n {\n   register int mask = 0;\n-  int fsize = (size + 1) & -2;\n+  int fsize = (size + STACK_BOUNDARY / 8 - 1) & -STACK_BOUNDARY / 8;\n   int idx;\n+  extra_pop = 0;\n \n-  if (frame_pointer_needed)\n+  if (current_function_anonymous_args && TARGET_QUICKCALL)\n     {\n-      /* Push the fp.  */\n-      fprintf (file, \"\\tpush\\t%s\\n\", names_big[FRAME_POINTER_REGNUM]);\n-      fprintf (file, \"\\tmov.w\\tr7,r6\\n\");\n+      /* Push regs as if done by caller, and move around return address.  */\n+\n+      switch (current_function_args_info.nbytes / UNITS_PER_WORD)\n+\t{\n+\tcase 0:\n+\t  /* get ret addr */\n+\t  fprintf (file, \"\\t%s\\t%s\\n\", h8_pop_op, h8_reg_names[3]);\n+\t  fprintf (file, \"\\t%s\\t%s\\n\", h8_push_op, h8_reg_names[2]);\n+\t  fprintf (file, \"\\t%s\\t%s\\n\", h8_push_op, h8_reg_names[1]);\n+\t  fprintf (file, \"\\t%s\\t%s\\n\", h8_push_op, h8_reg_names[0]);\n+\t  /* push it again */\n+\t  fprintf (file, \"\\t%s\\t%s\\n\", h8_push_op, h8_reg_names[3]);\n+\t  extra_pop = 3;\n+\t  break;\n+\tcase 1:\n+\t  /* get ret addr */\n+\t  fprintf (file, \"\\t%s\\t%s\\n\", h8_pop_op, h8_reg_names[3]);\n+\t  fprintf (file, \"\\t%s\\t%s\\n\", h8_push_op, h8_reg_names[2]);\n+\t  fprintf (file, \"\\t%s\\t%s\\n\", h8_push_op, h8_reg_names[1]);\n+\t  /* push it again */\n+\t  fprintf (file, \"\\t%s\\t%s\\n\", h8_push_op, h8_reg_names[3]);\n+\t  extra_pop = 2;\n+\t  break;\n+\tcase 2:\n+\t  /* get ret addr */\n+\t  fprintf (file, \"\\t%s\\t%s\\n\", h8_pop_op, h8_reg_names[3]);\n+\t  fprintf (file, \"\\t%s\\t%s\\n\", h8_push_op, h8_reg_names[2]);\n+\t  /* push it again */\n+\t  fprintf (file, \"\\t%s\\t%s\\n\", h8_push_op, h8_reg_names[3]);\n+\t  extra_pop = 1;\n+\t  break;\n+\tdefault:\n+\t  fprintf (file, \"; varargs\\n\");\n+\t  break;\n+\t}\n+    }\n \n-      /* Leave room for the locals.  */\n+  if (frame_pointer_needed)\n+    {\n+      /* Push fp */\n+      fprintf (file, \"\\t%s\\t%s\\n\", h8_push_op,\n+\t       h8_reg_names[FRAME_POINTER_REGNUM]);\n+      fprintf (file, \"\\t%s\\t%s,%s\\n\", h8_mov_op,\n+\t       h8_reg_names[STACK_POINTER_REGNUM],\n+\t       h8_reg_names[FRAME_POINTER_REGNUM]);\n+\n+      /* leave room for locals */\n       dosize (file, \"sub\", fsize, 1);\n \n-      /* Push the rest of the registers.  */\n-      for (idx = 0; idx < FIRST_PSEUDO_REGISTER; idx++) \n+      /* Push the rest of the registers */\n+      for (idx = 0; idx < FIRST_PSEUDO_REGISTER; idx++)\n \t{\n \t  int regno = push_order[idx];\n \n-\t  if (regno >= 0 && word_reg_used (regno)\n-\t      && regno != FRAME_POINTER_REGNUM)\n-\t    fprintf (file, \"\\tpush\\t%s\\n\", names_big[regno]);\n+\t  if (regno >= 0 && WORD_REG_USED (regno) && regno != FRAME_POINTER_REGNUM)\n+\t    fprintf (file, \"\\t%s\\t%s\\n\", h8_push_op, h8_reg_names[regno]);\n \t}\n     }\n   else\n@@ -167,8 +256,8 @@ function_prologue (file, size)\n \t{\n \t  int regno = push_order[idx];\n \n-\t  if (regno >= 0 && word_reg_used (regno))\n-\t    fprintf (file, \"\\tpush\\t%s\\n\", names_big[regno]);\n+\t  if (regno >= 0 && WORD_REG_USED (regno))\n+\t    fprintf (file, \"\\t%s\\t%s\\n\", h8_push_op, h8_reg_names[regno]);\n \t}\n     }\n }\n@@ -182,7 +271,7 @@ function_epilogue (file, size)\n {\n   register int regno;\n   register int mask = 0;\n-  int fsize = (size + 1) & -2;\n+  int fsize = (size + STACK_BOUNDARY / 8 - 1) & -STACK_BOUNDARY / 8;\n   int nregs;\n   int offset;\n   int idx;\n@@ -198,43 +287,87 @@ function_epilogue (file, size)\n \n   if (frame_pointer_needed)\n     {\n-      /* Pop saved registers.  */\n+      /* Pop saved registers */\n       for (idx = 0; idx < FIRST_PSEUDO_REGISTER; idx++)\n \t{\n \t  regno = pop_order[idx];\n-\t  if (regno >= 0 && regno != FRAME_POINTER_REGNUM\n-\t      && word_reg_used (regno))\n-\t    fprintf (file, \"\\tpop\\t%s\\n\", names_big[regno]);\n+\t  if (regno >= 0 && regno != FRAME_POINTER_REGNUM && WORD_REG_USED (regno))\n+\t    fprintf (file, \"\\t%s\\t%s\\n\", h8_pop_op, h8_reg_names[regno]);\n \t}\n-      /* Deallocate locals.  */\n+      /* deallocate locals */\n       dosize (file, \"add\", fsize, 1);\n-      /* Pop frame pointer.  */\n-      fprintf (file, \"\\tpop\\t%s\\n\", names_big[FRAME_POINTER_REGNUM]);\n+      /* pop frame pointer */\n+      fprintf (file, \"\\t%s\\t%s\\n\", h8_pop_op, h8_reg_names[FRAME_POINTER_REGNUM]);\n     }\n   else\n     {\n-      /* Deallocate locals and pop saved registers.  */\n+      /* pop saved registers */\n       for (idx = 0; idx < FIRST_PSEUDO_REGISTER; idx++)\n \t{\n \t  regno = pop_order[idx];\n-\t  if (regno >= 0 && word_reg_used (regno))\n-\t    fprintf (file, \"\\tpop\\t%s\\n\", names_big[regno]);\n+\t  if (regno >= 0 && WORD_REG_USED (regno))\n+\t    fprintf (file, \"\\t%s\\t%s\\n\", h8_pop_op, h8_reg_names[regno]);\n \t}\n+      /* deallocate locals */\n       dosize (file, \"add\", fsize, 0);\n     }\n-  if (pragma_interrupt)\n-    fprintf (file, \"\\trte\\n\");\n+\n+  if (extra_pop)\n+    {\n+      fprintf (file, \"\\t%s\\t%s\\n\", h8_pop_op, h8_reg_names[3]);\n+      while (extra_pop)\n+\t{\n+\t  fprintf (file, \"\\t%s\\t%s\\n\", h8_pop_op, h8_reg_names[2]);\n+\t  extra_pop--;\n+\t}\n+      fprintf (file, \"\\tjmp\t@%s\\n\", h8_reg_names[3]);\n+    }\n   else\n-    fprintf (file, \"\\trts\\n\");\n+    {\n+      if (pragma_interrupt)\n+\tfprintf (file, \"\\trte\\n\");\n+      else\n+\tfprintf (file, \"\\trts\\n\");\n+    }\n \n   pragma_interrupt = 0;\n   pragma_saveall = 0;\n+\n+  current_function_anonymous_args = 0;\n+}\n+\n+/* Output assembly code for the start of the file.  */\n+\n+asm_file_start (file)\n+     FILE *file;\n+{\n+  fprintf (file, \";\\tGCC For the Hitachi H8/300\\n\");\n+  fprintf (file, \";\\tBy Hitachi America Ltd and Cygnus Support\\n\");\n+  fprintf (file, \";\\trelease F-1\\n\");\n+  if (optimize)\n+    fprintf (file, \"; -O%d\\n\", optimize);\n+  if (TARGET_H8300H)\n+    fprintf (file, \"\\n\\t.h8300h\\n\");\n+  else\n+    fprintf (file, \"\\n\\n\");\n+  output_file_directive (file, main_input_filename);\n+}\n+\n+/* Output assembly language code for the end of file.  */\n+\n+void\n+asm_file_end (file)\n+     FILE *file;\n+{\n+  fprintf (file, \"\\t.end\\n\");\n }\n \f\n-/* Return true if VALUE is a valid constant for constraint 'P'.  */\n+/* Return true if VALUE is a valid constant for constraint 'P'.\n+   IE: VALUE is a power of two <= 2**15.  */\n \n int\n-potl8 (value)\n+small_power_of_two (value)\n+     int value;\n {\n   switch (value)\n     {\n@@ -246,18 +379,6 @@ potl8 (value)\n     case 32:\n     case 64:\n     case 128:\n-      return 1;\n-    }\n-  return 0;\n-}\n-\n-/* Return true if VALUE is a valid constant for constraint 'O'.  */\n-int\n-potg8 (value)\n-     int value;\n-{\n-  switch (value)\n-    {\n     case 256:\n     case 512:\n     case 1024:\n@@ -271,48 +392,167 @@ potg8 (value)\n   return 0;\n }\n \n+/* Return true if VALUE is a valid constant for constraint 'O', which\n+   means that the constant would be ok to use as a bit for a bclr\n+   instruction.  */\n+\n+int\n+ok_for_bclr (value)\n+     int value;\n+{\n+  return small_power_of_two ((~value) & 0xff);\n+}\n+\n /* Return true is OP is a valid source operand for an integer move\n    instruction.  */\n+\n int\n general_operand_src (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  /* We can't have a pre-dec as a source.  */\n-  if (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == PRE_DEC)\n-    return 0;\n+  if (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == POST_INC)\n+    return 1;\n   return general_operand (op, mode);\n }\n \n /* Return true if OP is a valid destination operand for an integer move\n    instruction.  */\n+\n int\n general_operand_dst (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  /* We can't have a post-inc as a dest.  */\n-  if (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == POST_INC)\n-    return 0;\n+  if (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == PRE_DEC)\n+    return 1;\n   return general_operand (op, mode);\n }\n-\f\n+\n+/* Return true if OP is a const valid for a bit clear instruction.  */\n+\n+int\n+o_operand (operand, mode)\n+     rtx operand;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (operand) == CONST_INT\n+\t  && CONST_OK_FOR_O (INTVAL (operand)));\n+}\n+\n+/* Return true if OP is a const valid for a bit set or bit xor instruction.  */\n+\n+int\n+p_operand (operand, mode)\n+     rtx operand;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (operand) == CONST_INT\n+\t  && CONST_OK_FOR_P (INTVAL (operand)));\n+}\n+\n+/* Return true if OP is a valid call operand.  */\n+\n+int\n+call_insn_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == MEM)\n+    {\n+      rtx inside = XEXP (op, 0);\n+      if (register_operand (inside, Pmode))\n+\treturn 1;\n+      if (CONSTANT_ADDRESS_P (inside))\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n+/* Return true if OP is a valid jump operand.  */\n+\n+int\n+jump_address_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == REG)\n+    return mode == Pmode;\n+\n+  if (GET_CODE (op) == MEM)\n+    {\n+      rtx inside = XEXP (op, 0);\n+      if (register_operand (inside, Pmode))\n+\treturn 1;\n+      if (CONSTANT_ADDRESS_P (inside))\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n+/* Recognize valid operands for bitfield instructions.  */\n+\n+extern int rtx_equal_function_value_matters;\n+\n+int\n+bit_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  /* We can except any general operand, expept that MEM operands must\n+     be limited to those that use addresses valid for the 'U' constraint.  */\n+  if (!general_operand (op, mode))\n+    return 0;\n+\n+  /* Accept any mem during RTL generation.  Otherwise, the code that does\n+     insv and extzv will think that we can not handle memory.  However,\n+     to avoid reload problems, we only accept 'U' MEM operands after RTL\n+     generation.  This means that any named pattern which uses this predicate\n+     must force its operands to match 'U' before emitting RTL.  */\n+\n+  if (GET_CODE (op) == REG)\n+    return 1;\n+  if (GET_CODE (op) == SUBREG)\n+    return 1;\n+  if (!rtx_equal_function_value_matters)\n+    {\n+      /* We're building rtl */\n+      return GET_CODE (op) == MEM;\n+    }\n+  else\n+    {\n+      return (GET_CODE (op) == MEM\n+\t      && EXTRA_CONSTRAINT (op, 'U'));\n+    }\n+}\n+\n+/* Recognize valid operators for bit test.  */\n+\n+int\n+eq_operator (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (x) == EQ || GET_CODE (x) == NE);\n+}\n+\n /* Handle machine specific pragmas for compatibility with existing\n-   compilers for the H8/300\n+   compilers for the H8/300.\n \n    pragma saveall generates prolog/epilog code which saves and\n    restores all the registers on function entry.\n-   \n+\n    pragma interrupt saves and restores all registers, and exits with\n    an rte instruction rather than an rts.  A pointer to a function\n    with this attribute may be safely used in an interrupt vector.  */\n+\n int\n handle_pragma (file)\n      FILE *file;\n {\n   int c;\n   char pbuf[20];\n-  int psize;\n+  int psize = 0;\n \n   c = getc (file);\n   while (c == ' ' || c == '\\t')\n@@ -321,12 +561,13 @@ handle_pragma (file)\n   if (c == '\\n' || c == EOF)\n     return c;\n \n-  for (psize = 0; psize < sizeof (pbuf) - 1 && isalpha (c); psize++)\n+  /* The only pragmas we understand are interrupt and saveall.  */\n+  while (psize < sizeof (pbuf) - 1\n+\t && isalpha (c))\n     {\n-      pbuf[psize] = c;\n+      pbuf[psize++] = c;\n       c = getc (file);\n     }\n-\n   pbuf[psize] = 0;\n \n   if (strcmp (pbuf, \"interrupt\") == 0)\n@@ -335,13 +576,52 @@ handle_pragma (file)\n   if (strcmp (pbuf, \"saveall\") == 0)\n     pragma_saveall = 1;\n \n+  /* ??? This is deprecated.  Use section attributes.  */\n+  if (strcmp (pbuf, \"section\") == 0)\n+    {\n+      while (c && !isalpha (c))\n+\tc = getc (file);\n+      psize = 0;\n+      while (psize < sizeof (pbuf) - 1\n+\t     && isalpha (c) || isdigit (c) || c == '_')\n+\t{\n+\t  pbuf[psize++] = c;\n+\t  c = getc (file);\n+\t}\n+      pbuf[psize] = 0;\n+      named_section (pbuf);\n+    }\n+  ungetc (c, file);\n   return c;\n }\n \f\n /* If the next arg with MODE and TYPE is to be passed in a register, return\n    the rtx to represent where it is passed.  CUM represents the state after\n    the last argument.  NAMED is not used.  */\n \n+static char *hand_list[] =\n+{\n+  \"__main\",\n+  \"__cmpsi2\",\n+  \"__divhi3\",\n+  \"__modhi3\",\n+  \"__udivhi3\",\n+  \"__umodhi3\",\n+  \"__divsi3\",\n+  \"__modsi3\",\n+  \"__udivsi3\",\n+  \"__umodsi3\",\n+  \"__mulhi3\",\n+  \"__mulsi3\",\n+  \"__reg_memcpy\",\n+  \"__reg_memset\",\n+  \"__ucmpsi2\",\n+  0,\n+};\n+\n+/* Return an RTX to represent where a value with mode MODE will be returned\n+   from a function.  If the result is 0, the argument is pushed.  */\n+\n rtx\n function_arg (cum, mode, type, named)\n      CUMULATIVE_ARGS *cum;\n@@ -350,83 +630,154 @@ function_arg (cum, mode, type, named)\n      int named;\n {\n   rtx result = 0;\n-  int libcall = 0;\n+  char *fname;\n+  int regpass = 0;\n+\n+  /* Pass 3 regs worth of data in regs when user asked on the command line.  */\n+  if (TARGET_QUICKCALL)\n+    regpass = 3;\n+\n+  /* If calling hand written assembler, use 4 regs of args.  */\n+\n+  if (cum->libcall)\n+    {\n+      char **p;\n+\n+      fname = XSTR (cum->libcall, 0);\n+\n+      /* See if this libcall is one of the hand coded ones.  */\n \n-  /* Right now reload has a problem with reg passing with small reg\n-     classes.  */\n+      for (p = hand_list; *p && strcmp (*p, fname) != 0; p++)\n+\t;\n \n-  if (cum->libcall || (named && TARGET_QUICKCALL))\n-    libcall = 1;\n+      if (*p)\n+\tregpass = 4;\n+    }\n+\n+  if (regpass)\n+    {\n+      int size;\n+\n+      if (mode == BLKmode)\n+\tsize = int_size_in_bytes (type);\n+      else\n+\tsize = GET_MODE_SIZE (mode);\n+\n+      if (size + cum->nbytes > regpass * UNITS_PER_WORD)\n+\t{\n+\t  result = 0;\n+\t}\n+      else\n+\t{\n+\t  switch (cum->nbytes / UNITS_PER_WORD)\n+\t    {\n+\t    case 0:\n+\t      result = gen_rtx (REG, mode, 0);\n+\t      break;\n+\t    case 1:\n+\t      result = gen_rtx (REG, mode, 1);\n+\t      break;\n+\t    case 2:\n+\t      result = gen_rtx (REG, mode, 2);\n+\t      break;\n+\t    case 3:\n+\t      result = gen_rtx (REG, mode, 3);\n+\t      break;\n+\t    default:\n+\t      result = 0;\n+\t    }\n+\t}\n+    }\n \n-  if (TARGET_NOQUICK)\n-    libcall = 0;\n+  return result;\n+}\n+\f\n+/* Return the cost of the rtx R with code CODE.  */\n \n-  if (mode != VOIDmode && libcall && mode != DFmode && mode != SFmode)\n+int\n+const_costs (r, c)\n+     rtx r;\n+     enum rtx_code c;\n+{\n+  switch (c)\n     {\n-      switch (cum->nbytes)\n+    case CONST_INT:\n+      switch (INTVAL (r))\n \t{\n \tcase 0:\n-\t  result = gen_rtx (REG, mode, 0);\n-\t  break;\n+\tcase 1:\n \tcase 2:\n-\t  result = gen_rtx (REG, mode, 1);\n-\t  break;\n-\tcase 4:\n-\t  result = gen_rtx (REG, mode, 4);\n-\t  break;\n-\tcase 6:\n-\t  result = gen_rtx (REG, mode, 5);\n-\t  break;\n-\tdefault:\n+\tcase -1:\n+\tcase -2:\n \t  return 0;\n+\tdefault:\n+\t  return 1;\n \t}\n+\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      return 3;\n+\n+    case CONST_DOUBLE:\n+      return 20;\n+\n+    default:\n+      return 4;\n     }\n-  return result;\n }\n-\n+\f\n /* Documentation for the machine specific operand escapes:\n \n+   'A' print rn in h8/300 mode, erN in H8/300H mode\n    'C' print (operand - 2).\n-   'E' low byte of reg or -ve lsb of constant\n-   'F' high byte of reg of -ve  msb of constant\n-\n-   'G' negate constant\n+   'E' like s but negative.\n+   'F' like t but negative.\n+   'G' constant just the negative\n    'L' fake label, changed after used twice.\n    'M' turn a 'M' constant into its negative mod 2.\n+   'P' if operand is incing/decing sp, print .w, otherwise .b.\n+   'S' print operand as a long word\n    'T' print operand as a word\n-   'V' print log2 of constant - used for bset instructions\n-   'X' 8 bit register or other operand\n-\n+   'U' if operand is incing/decing sp, print l, otherwise nothing.\n+   'V' find the set bit, and print its number.\n+   'W' find the clear bit, and print its number.\n+   'X' print operand as a byte\n    'Y' print either l or h depending on whether last 'Z' operand < 8 or >= 8.\n-   'Z' print int & 7\n-\n-   'e' first word of 32 bit value\n-   'f' second word of 32 bit value\n-\n+   'Z' print int & 7.\n+   'b' print the bit opcode\n+   'c' print the ibit opcode\n+   'd' bcc if EQ, bcs if NE\n+   'e' first word of 32 bit value - if reg, then least reg. if mem\n+       then least. if const then most sig word\n+   'f' second word of 32 bit value - if reg, then biggest reg. if mem\n+       then +2. if const then least sig word\n+   'g' bcs if EQ, bcc if NE\n    'j' print operand as condition code.\n    'k' print operand as reverse condition code.\n-\n-   's' low byte of 16 bit value\n-   't' high byte of 16 bit value\n-\n-   'w' 1st byte of 32 bit value           zzzzzzzz yyyyyyyy xxxxxxxx wwwwwwww\n-   'x' 2nd byte of 32 bit value\n-   'y' 3rd byte of 32 bit value\n-   'z' 4th byte of 32 bit value\n-\n- */\n+   's' print as low byte of 16 bit value\n+   't' print as high byte of 16 bit value\n+   'w' print as low byte of 32 bit value\n+   'x' print as 2nd byte of 32 bit value\n+   'y' print as 3rd byte of 32 bit value\n+   'z' print as msb of 32 bit value\n+*/\n \n /* Return assembly language string which identifies a comparison type.  */\n \n-char *\n+static char *\n cond_string (code)\n      enum rtx_code code;\n {\n   switch (code)\n     {\n     case NE:\n+      if (cc_prev_status.flags & CC_DONE_CBIT)\n+\treturn \"cs\";\n       return \"ne\";\n     case EQ:\n+      if (cc_prev_status.flags & CC_DONE_CBIT)\n+\treturn \"cc\";\n       return \"eq\";\n     case GE:\n       return \"ge\";\n@@ -465,149 +816,184 @@ print_operand (file, x, code)\n   static char *last_p;\n \n   /* This is used for communication between the 'Z' and 'Y' codes.  */\n+  /* ??? 'V' and 'W' use it too.  */\n   static int bitint;\n \n   switch (code)\n     {\n-    case 'L':\n-      /* 'L' must always be used twice in a single pattern.  It generates\n-\t the same lable twice, and then will generate a unique label the\n-\t next time it is used.  */\n-      asm_fprintf (file, \"tl%d\", (lab++) / 2);\n-      break;\n-\n-    case 'X':\n+    case 'A':\n       if (GET_CODE (x) == REG)\n-\tfprintf (file, \"%s\", byte_reg (x, 0));\n+\tfprintf (file, \"%s\", h8_reg_names[REGNO (x)]);\n       else\n \tgoto def;\n       break;\n-\n+    case 'C':\n+      fprintf (file, \"#%d\", INTVAL (x) - 2);\n+      break;\n+    case 'E':\n+      switch (GET_CODE (x))\n+\t{\n+\tcase REG:\n+\t  fprintf (file, \"%sl\", names_big[REGNO (x)]);\n+\t  break;\n+\tcase CONST_INT:\n+\t  fprintf (file, \"#%d\", (-INTVAL (x)) & 0xff);\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+    case 'F':\n+      switch (GET_CODE (x))\n+\t{\n+\tcase REG:\n+\t  fprintf (file, \"%sh\", names_big[REGNO (x)]);\n+\t  break;\n+\tcase CONST_INT:\n+\t  fprintf (file, \"#%d\", ((-INTVAL (x)) & 0xff00) >> 8);\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n     case 'G':\n       if (GET_CODE (x) != CONST_INT)\n \tabort ();\n       fprintf (file, \"#%d\", 0xff & (-INTVAL (x)));\n       break;\n-\n-    case 'T':\n-      if (GET_CODE (x) == REG)\n-\tfprintf (file, \"%s\", names_big[REGNO (x)]);\n-      else\n-\tgoto def;\n-      break;\n-\n-    case 'w':\n-      if (GET_CODE (x) == CONST_INT)\n-\tfprintf (file, \"#%d\", INTVAL (x) & 0xff);\n-      else\n-\tfprintf (file, \"%s\", byte_reg (x, 2));\n+    case 'L':\n+      /* 'L' must always be used twice in a single pattern.  It generates\n+\t the same lable twice, and then will generate a unique label the\n+\t next time it is used.  */\n+      asm_fprintf (file, \"tl%d\", (lab++) / 2);\n       break;\n-\n-    case 'x':\n-      if (GET_CODE (x) == CONST_INT)\n-\tfprintf (file, \"#%d\", (INTVAL (x) >> 8) & 0xff);\n-      else\n-\tfprintf (file, \"%s\", byte_reg (x, 3));\n+    case 'M':\n+      /* For 3/-3 and 4/-4, the other 2 is handled separately.  */\n+      switch (INTVAL (x))\n+\t{\n+\tcase 2:\n+\tcase 4:\n+\tcase -2:\n+\tcase -4:\n+\t  fprintf (file, \"#2\");\n+\t  break;\n+\tcase 1:\n+\tcase 3:\n+\tcase -1:\n+\tcase -3:\n+\t  fprintf (file, \"#1\");\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n       break;\n-\n-    case 'y':\n-      if (GET_CODE (x) == CONST_INT)\n-\tfprintf (file, \"#%d\", (INTVAL (x) >> 16) & 0xff);\n+    case 'P':\n+      if (REGNO (XEXP (XEXP (x, 0), 0)) == STACK_POINTER_REGNUM)\n+\t{\n+\t  last_p = \"\";\n+\t  fprintf (file, \".w\");\n+\t}\n       else\n-\tfprintf (file, \"%s\", byte_reg (x, 0));\n+\t{\n+\t  last_p = \"l\";\n+\t  fprintf (file, \".b\");\n+\t}\n       break;\n-\n-    case 'z':\n-      if (GET_CODE (x) == CONST_INT)\n-\tfprintf (file, \"#%d\", (INTVAL (x) >> 24) & 0xff);\n+    case 'S':\n+      if (GET_CODE (x) == REG)\n+\tfprintf (file, \"%s\", names_extended[REGNO (x)]);\n       else\n-\tfprintf (file, \"%s\", byte_reg (x, 1));\n+\tgoto def;\n       break;\n-\n-      /* FOR 16 bits.  */\n-    case 't':\n-      if (GET_CODE (x) == CONST_INT)\n-\tfprintf (file, \"#%d\", (INTVAL (x) >> 8) & 0xff);\n+    case 'T':\n+      if (GET_CODE (x) == REG)\n+\tfprintf (file, \"%s\", names_big[REGNO (x)]);\n       else\n-\tfprintf (file, \"%s\", byte_reg (x, 1));\n+\tgoto def;\n       break;\n-\n-    case 's':\n-      if (GET_CODE (x) == CONST_INT)\n-\tfprintf (file, \"#%d\", (INTVAL (x)) & 0xff);\n-      else\n-\tfprintf (file, \"%s\", byte_reg (x, 0));\n+    case 'U':\n+      fprintf (file, \"%s%s\", names_big[REGNO (x)], last_p);\n       break;\n-\n-    case 'u':\n-      if (GET_CODE (x) != CONST_INT)\n+    case 'V':\n+      bitint = exact_log2 (INTVAL (x));\n+      if (bitint == -1)\n \tabort ();\n-      fprintf (file, \"%d\", INTVAL (x));\n-      break;\n-\n-    case 'Z':\n-      bitint = INTVAL (x);\n       fprintf (file, \"#%d\", bitint & 7);\n       break;\n-\n-    case 'Y':\n-      fprintf (file, \"%c\", bitint > 7 ? 'h' : 'l');\n-      break;\n-\n-    case 'O':\n+    case 'W':\n       bitint = exact_log2 ((~INTVAL (x)) & 0xff);\n       if (bitint == -1)\n \tabort ();\n       fprintf (file, \"#%d\", bitint & 7);\n       break;\n-\n-    case 'V':\n-      bitint = exact_log2 (INTVAL (x));\n+    case 'X':\n+      if (GET_CODE (x) == REG)\n+\tfprintf (file, \"%s\", byte_reg (x, 0));\n+      else\n+\tgoto def;\n+      break;\n+    case 'Y':\n       if (bitint == -1)\n \tabort ();\n+      if (GET_CODE (x) == REG)\n+\tfprintf (file, \"%s%c\", names_big[REGNO (x)], bitint > 7 ? 'h' : 'l');\n+      else\n+\tprint_operand (file, x, 0);\n+      bitint = -1;\n+      break;\n+    case 'Z':\n+      bitint = INTVAL (x);\n       fprintf (file, \"#%d\", bitint & 7);\n       break;\n-\n-    case 'P':\n-      if (REGNO (XEXP (XEXP (x, 0), 0)) == STACK_POINTER_REGNUM)\n+    case 'b':\n+      switch (GET_CODE (x))\n \t{\n-\t  last_p = \"\";\n-\t  fprintf (file, \".w\");\n+\tcase IOR:\n+\t  fprintf (file, \"bor\");\n+\t  break;\n+\tcase XOR:\n+\t  fprintf (file, \"bxor\");\n+\t  break;\n+\tcase AND:\n+\t  fprintf (file, \"band\");\n+\t  break;\n \t}\n-      else\n+      break;\n+    case 'c':\n+      switch (GET_CODE (x))\n \t{\n-\t  last_p = \"l\";\n-\t  fprintf (file, \".b\");\n+\tcase IOR:\n+\t  fprintf (file, \"bior\");\n+\t  break;\n+\tcase XOR:\n+\t  fprintf (file, \"bixor\");\n+\t  break;\n+\tcase AND:\n+\t  fprintf (file, \"biand\");\n+\t  break;\n \t}\n       break;\n-\n-    case 'U':\n-      fprintf (file, \"%s%s\", names_big[REGNO (x)], last_p);\n-      break;\n-\n-    case 'M':\n-      /* For -4 and -2, the other 2 is handled separately.  */\n-      switch (INTVAL (x))\n+    case 'd':\n+      switch (GET_CODE (x))\n \t{\n-\tcase -2:\n-\tcase -4:\n-\t  fprintf (file, \"#2\");\n+\tcase EQ:\n+\t  fprintf (file, \"bcc\");\n \t  break;\n-\tcase -1:\n-\tcase -3:\n-\t  fprintf (file, \"#1\");\n+\tcase NE:\n+\t  fprintf (file, \"bcs\");\n \t  break;\n-\n \tdefault:\n \t  abort ();\n \t}\n       break;\n-\n     case 'e':\n       switch (GET_CODE (x))\n \t{\n \tcase REG:\n-\t  fprintf (file, \"%s\", names_big[REGNO (x)]);\n+\t  if (TARGET_H8300)\n+\t    fprintf (file, \"%s\", names_big[REGNO (x)]);\n+\t  else\n+\t    fprintf (file, \"%s\", names_upper_extended[REGNO (x)]);\n \t  break;\n \tcase MEM:\n \t  x = adj_offsettable_operand (x, 0);\n@@ -621,77 +1007,110 @@ print_operand (file, x, code)\n \t  break;\n \t}\n       break;\n-\n     case 'f':\n       switch (GET_CODE (x))\n \t{\n \tcase REG:\n-\t  fprintf (file, \"%s\", names_big[REGNO (x) + 1]);\n+\t  if (TARGET_H8300)\n+\t    fprintf (file, \"%s\", names_big[REGNO (x) + 1]);\n+\t  else\n+\t    fprintf (file, \"%s\", names_big[REGNO (x)]);\n \t  break;\n-\n \tcase MEM:\n \t  x = adj_offsettable_operand (x, 2);\n \t  print_operand (file, x, 0);\n \t  break;\n-\n \tcase CONST_INT:\n \t  fprintf (file, \"#%d\", INTVAL (x) & 0xffff);\n \t  break;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n-      break;\n-\n-    case 'C':\n-      fprintf (file, \"#%d\", INTVAL (x) - 2);\n-      break;\n-\n-    case 'E':\n-      switch (GET_CODE (x))\n-\t{\n-\tcase REG:\n-\t  fprintf (file, \"%sl\", names_big[REGNO (x)]);\n-\t  break;\n-\n-\tcase CONST_INT:\n-\t  fprintf (file, \"#%d\", (-INTVAL (x)) & 0xff);\n-\t  break;\n-\n \tdefault:\n \t  abort ();\n \t}\n       break;\n-\n-    case 'F':\n+    case 'g':\n       switch (GET_CODE (x))\n \t{\n-\tcase REG:\n-\t  fprintf (file, \"%sh\", names_big[REGNO (x)]);\n+\tcase NE:\n+\t  fprintf (file, \"bcc\");\n \t  break;\n-\n-\tcase CONST_INT:\n-\t  fprintf (file, \"#%d\", ((-INTVAL (x)) & 0xff00) >> 8);\n+\tcase EQ:\n+\t  fprintf (file, \"bcs\");\n \t  break;\n-\n \tdefault:\n \t  abort ();\n \t}\n       break;\n-\n     case 'j':\n       asm_fprintf (file, cond_string (GET_CODE (x)));\n       break;\n-\n     case 'k':\n       asm_fprintf (file, cond_string (reverse_condition (GET_CODE (x))));\n       break;\n-    def: ;\n+    case 's':\n+      if (GET_CODE (x) == CONST_INT)\n+\tfprintf (file, \"#%d\", (INTVAL (x)) & 0xff);\n+      else\n+\tfprintf (file, \"%s\", byte_reg (x, 0));\n+      break;\n+    case 't':\n+      if (GET_CODE (x) == CONST_INT)\n+\tfprintf (file, \"#%d\", (INTVAL (x) >> 8) & 0xff);\n+      else\n+\tfprintf (file, \"%s\", byte_reg (x, 1));\n+      break;\n+    case 'u':\n+      if (GET_CODE (x) != CONST_INT)\n+\tabort ();\n+      fprintf (file, \"%d\", INTVAL (x));\n+      break;\n+    case 'w':\n+      if (GET_CODE (x) == CONST_INT)\n+\tfprintf (file, \"#%d\", INTVAL (x) & 0xff);\n+      else\n+\tfprintf (file, \"%s\", byte_reg (x, TARGET_H8300 ? 2 : 0));\n+      break;\n+    case 'x':\n+      if (GET_CODE (x) == CONST_INT)\n+\tfprintf (file, \"#%d\", (INTVAL (x) >> 8) & 0xff);\n+      else\n+\tfprintf (file, \"%s\", byte_reg (x, TARGET_H8300 ? 3 : 1));\n+      break;\n+    case 'y':\n+      if (GET_CODE (x) == CONST_INT)\n+\tfprintf (file, \"#%d\", (INTVAL (x) >> 16) & 0xff);\n+      else\n+\tfprintf (file, \"%s\", byte_reg (x, 0));\n+      break;\n+    case 'z':\n+      if (GET_CODE (x) == CONST_INT)\n+\tfprintf (file, \"#%d\", (INTVAL (x) >> 24) & 0xff);\n+      else\n+\tfprintf (file, \"%s\", byte_reg (x, 1));\n+      break;\n+\n     default:\n+    def:\n       switch (GET_CODE (x))\n \t{\n \tcase REG:\n-\t  fprintf (file, \"%s\", names_big[REGNO (x)]);\n+\t  switch (GET_MODE (x))\n+\t    {\n+\t    case QImode:\n+#if 0\t\t\t\t/* Is it asm (\"mov.b %0,r2l\", ...) */\n+\t      fprintf (file, \"%s\", byte_reg (x, 0));\n+#else /* ... or is it asm (\"mov.b %0l,r2l\", ...) */\n+\t      fprintf (file, \"%s\", names_big[REGNO (x)]);\n+#endif\n+\t      break;\n+\t    case HImode:\n+\t      fprintf (file, \"%s\", names_big[REGNO (x)]);\n+\t      break;\n+\t    case SImode:\n+\t      fprintf (file, \"%s\", names_extended[REGNO (x)]);\n+\t      break;\n+\t    default:\n+\t      abort ();\n+\t    }\n \t  break;\n \n \tcase MEM:\n@@ -720,15 +1139,15 @@ print_operand_address (file, addr)\n   switch (GET_CODE (addr))\n     {\n     case REG:\n-      fprintf (file, \"%s\", names_big[REGNO (addr)]);\n+      fprintf (file, \"%s\", h8_reg_names[REGNO (addr)]);\n       break;\n \n     case PRE_DEC:\n-      fprintf (file, \"-%s\", names_big[REGNO (XEXP (addr, 0))]);\n+      fprintf (file, \"-%s\", h8_reg_names[REGNO (XEXP (addr, 0))]);\n       break;\n \n     case POST_INC:\n-      fprintf (file, \"%s+\", names_big[REGNO (XEXP (addr, 0))]);\n+      fprintf (file, \"%s+\", h8_reg_names[REGNO (XEXP (addr, 0))]);\n       break;\n \n     case PLUS:\n@@ -751,15 +1170,22 @@ print_operand_address (file, addr)\n       break;\n \n     case CONST_INT:\n-      if (INTVAL (addr) < 0)\n-\t{\n-\t  int v = -INTVAL (addr);\n-\n-\t  fprintf (file, \"-%d\", v);\n-\t}\n-      else\n-\tfprintf (file, \"%d\", INTVAL (addr));\n-      break;\n+      {\n+\t/* Since the h8/300 only has 16 bit pointers, negative values are also\n+\t   those >= 32768.  This happens for example with pointer minus a\n+\t   constant.  We don't want to turn (char *p - 2) into\n+\t   (char *p + 65534) because loop unrolling can build upon this\n+\t   (IE: char *p + 131068).  */\n+\tint n = INTVAL (addr);\n+\tif (TARGET_H8300)\n+\t  n = (int) (short) n;\n+\tif (n < 0)\n+\t  /* ??? Why the special case for -ve values? */\n+\t  fprintf (file, \"-%d\", -n);\n+\telse\n+\t  fprintf (file, \"%d\", n);\n+\tbreak;\n+      }\n \n     default:\n       output_addr_const (file, addr);\n@@ -782,139 +1208,833 @@ final_prescan_insn (insn, operand, num_operands)\n \n   int uid = INSN_UID (insn);\n \n+  if (TARGET_RTL_DUMP)\n+    {\n+      fprintf (asm_out_file, \"\\n****************\");\n+      print_rtl (asm_out_file, PATTERN (insn));\n+      fprintf (asm_out_file, \"\\n\");\n+    }\n+\n   if (TARGET_ADDRESSES)\n     {\n-      fprintf (asm_out_file, \"; %d %d\\n\", insn_addresses[uid],\n+      fprintf (asm_out_file, \"; 0x%x %d\\n\", insn_addresses[uid],\n \t       insn_addresses[uid] - last_insn_address);\n       last_insn_address = insn_addresses[uid];\n     }\n }\n \n-static void\n-shift_n_bits (lval, operand, f, notzero)\n-     rtx lval;\n-     rtx operand;\n-     rtx (*f) ();\n-     int notzero;\n+/* Prepare for an SI sized move.  */\n+\n+int\n+do_movsi (operands)\n+     rtx operands[];\n {\n-  rtx label = gen_label_rtx ();\n-  rtx bot = gen_label_rtx ();\n+  rtx src = operands[1];\n+  rtx dst = operands[0];\n+  if (!reload_in_progress && !reload_completed)\n+    {\n+      if (!register_operand (dst, GET_MODE (dst)))\n+\t{\n+\t  rtx tmp = gen_reg_rtx (GET_MODE (dst));\n+\t  emit_move_insn (tmp, src);\n+\t  operands[1] = tmp;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+/* Function for INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET).\n+   Define the offset between two registers, one to be eliminated, and the other\n+   its replacement, at the start of a routine.  */\n \n-  if (! notzero)\n+int\n+initial_offset (from, to)\n+{\n+  int offset = 0;\n+\n+  if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n+    offset = UNITS_PER_WORD + frame_pointer_needed * UNITS_PER_WORD;\n+  else\n     {\n-      /* Have to put a zero test at the top.  */\n-      emit_insn (gen_rtx (SET, VOIDmode, cc0_rtx, lval));\n-      emit_jump_insn (gen_beq (bot));\n+      int regno;\n+\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\tif ((regs_ever_live[regno]\n+\t     && (!call_used_regs[regno] || regno == FRAME_POINTER_REGNUM)))\n+\t  offset += UNITS_PER_WORD;\n+\n+      /* See the comments for get_frame_size.  We need to round it up to\n+\t STACK_BOUNDARY.  */\n+\n+      offset += ((get_frame_size () + STACK_BOUNDARY / BITS_PER_UNIT - 1)\n+\t\t & ~(STACK_BOUNDARY / BITS_PER_UNIT - 1));\n+\n+      if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+\toffset += UNITS_PER_WORD;\t/* Skip saved PC */\n+    }\n+  return offset;\n+}\n+\n+/* Update the condition code from the insn.  */\n+\n+int\n+notice_update_cc (body, insn)\n+     rtx body;\n+     rtx insn;\n+{\n+  switch (get_attr_cc (insn))\n+    {\n+    case CC_NONE:\n+      /* Insn does not affect the CC at all */\n+      break;\n+\n+    case CC_NONE_0HIT:\n+      /* Insn does not change the CC, but the 0't operand has been changed.  */\n+\n+      if (cc_status.value1 != 0\n+\t  && reg_overlap_mentioned_p (recog_operand[0], cc_status.value1))\n+\tcc_status.value1 = 0;\n+\n+      if (cc_status.value2 != 0\n+\t  && reg_overlap_mentioned_p (recog_operand[0], cc_status.value2))\n+\tcc_status.value2 = 0;\n+\n+      break;\n+\n+    case CC_SET:\n+      /* Insn sets CC to recog_operand[0], but overflow is impossible.  */\n+      CC_STATUS_INIT;\n+      cc_status.flags |= CC_NO_OVERFLOW;\n+      cc_status.value1 = recog_operand[0];\n+      break;\n+\n+    case CC_COMPARE:\n+      /* The insn is a compare instruction */\n+      CC_STATUS_INIT;\n+      cc_status.value1 = SET_SRC (body);\n+      break;\n+\n+    case CC_CBIT:\n+      CC_STATUS_INIT;\n+      cc_status.flags |= CC_DONE_CBIT;\n+      cc_status.value1 = 0;\n+      break;\n+\n+    case CC_WHOOPS:\n+    case CC_CLOBBER:\n+      /* Insn clobbers CC. */\n+      CC_STATUS_INIT;\n+      break;\n     }\n-  emit_label (label);\n-  f (operand);\n-  emit_insn (gen_rtx (SET, QImode, lval,\n-\t\t      gen_rtx (MINUS, QImode, lval, const1_rtx)));\n-  emit_insn (gen_rtx (SET, VOIDmode, cc0_rtx, lval));\n-  emit_jump_insn (gen_bne (label));\n+}\n+\n+/* Recognize valid operators for bit instructions */\n+\n+int\n+bit_operator (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n+{\n+  enum rtx_code code = GET_CODE (x);\n \n-  emit_label (bot);\n-  /* We can't end an expand with a label.  */\n-  emit_move_insn (operand, operand);\n+  return (code == XOR\n+\t  || code == AND\n+\t  || code == IOR);\n }\n+\f\n+/* Shifts.\n+\n+   We devote a fair bit of code to getting efficient shifts since we can only\n+   shift one bit at a time.  See the .md file for more comments.\n+\n+   Here are some thoughts on what the absolutely positively best code is.\n+   \"Best\" here means some rational trade-off between code size and speed,\n+   where speed is more preferred but not at the expense of generating 20 insns.\n+\n+   H8/300 QImode shifts\n+   1-4   - do them inline\n+   5-6   - ASHIFT | LSHIFTRT: rotate, mask off other bits\n+           ASHIFTRT: loop\n+   7     - ASHIFT | LSHIFTRT: rotate, mask off other bits\n+           ASHIFTRT: shll, subx (propagate carry bit to all bits)\n+\n+   H8/300 HImode shifts\n+   1-4   - do them inline\n+   5-6   - loop\n+   7     - shift other way once, move byte into place, move carry bit into place\n+   8     - move byte, zero (ASHIFT | LSHIFTRT) or sign extend other (ASHIFTRT)\n+   9     - inline shift 1-4, move byte, set other byte\n+   13-14 - ASHIFT | LSHIFTRT: rotate 3/2, mask, move byte, set other byte to 0\n+         - ASHIFTRT: loop\n+   15    - ASHIFT | LSHIFTRT: rotate 1, mask, move byte, set other byte to 0\n+         - ASHIFTRT: shll, subx, set other byte\n+\n+   H8/300 SImode shifts\n+   1-2   - do them inline\n+   3-6   - loop\n+   7     - shift other way once, move bytes into place,\n+           move carry into place (possibly with sign extension)\n+   8     - move bytes into place, zero or sign extend other\n+   9-14  - loop\n+   15    - shift other way once, move word into place, move carry into place\n+   16    - move word, zero or sign extend other\n+   17-23 - loop\n+   24    - move bytes into place, zero or sign extend other\n+   25-27 - loop\n+   28-30 - ASHIFT | LSHIFTRT: rotate top byte, mask, move byte into place,\n+                              zero others\n+           ASHIFTRT: loop\n+   31    - ASHIFT | LSHIFTRT: rotate top byte, mask, byte byte into place,\n+                              zero others\n+           ASHIFTRT: shll top byte, subx, copy to other bytes\n+\n+   H8/300H QImode shifts\n+   - same as H8/300\n+\n+   H8/300H HImode shifts\n+   - same as H8/300\n+\n+   H8/300H SImode shifts\n+   (These are complicated by the fact that we don't have byte level access to\n+   the top word.)\n+   A word is: bytes 3,2,1,0 (msb -> lsb), word 1,0 (msw -> lsw)\n+   1-4   - do them inline\n+   5-14  - loop\n+   15    - shift other way once, move word into place, move carry into place\n+           (with sign extension for ASHIFTRT)\n+   16    - move word into place, zero or sign extend other\n+   17-23 - loop\n+   24    - ASHIFT: move byte 0(msb) to byte 1, zero byte 0,\n+                   move word 0 to word 1, zero word 0\n+           LSHIFTRT: move word 1 to word 0, move byte 1 to byte 0,\n+                     zero word 1, zero byte 1\n+           ASHIFTRT: move word 1 to word 0, move byte 1 to byte 0,\n+                     sign extend byte 0, sign extend word 0\n+   25-27 - either loop, or\n+           do 24 bit shift, inline rest\n+   28-30 - ASHIFT: rotate 4/3/2, mask\n+           LSHIFTRT: rotate 4/3/2, mask\n+           ASHIFTRT: loop\n+   31    - shll, subx byte 0, sign extend byte 0, sign extend word 0\n+\n+   Don't Panic!!!\n+\n+   All of these haven't been implemented.  I've just documented them and\n+   provided hooks so they can be.\n+*/\n \n int\n-can_shift (code, operands, f, limit, fby_eight)\n+nshift_operator (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+    case ASHIFT:\n+      return 1;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Called from the .md file to emit code to do shifts.\n+   Returns a boolean indicating success\n+   (currently this is always TRUE).  */\n+\n+int\n+expand_a_shift (mode, code, operands)\n+     enum machine_mode mode;\n      int code;\n      rtx operands[];\n-     rtx (*f) ();\n-     int limit;\n-     rtx (*fby_eight) ();\n {\n   extern int rtx_equal_function_value_matters;\n \n   emit_move_insn (operands[0], operands[1]);\n \n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    {\n-      rtx lval;\n+  /* need a loop to get all the bits we want  - we generate the\n+     code at emit time, but need to allocate a scratch reg now  */\n+\n+  emit_insn (gen_rtx\n+\t     (PARALLEL, VOIDmode,\n+\t      gen_rtvec (2,\n+\t\t\t gen_rtx (SET, VOIDmode, operands[0],\n+\t\t\t\t  gen_rtx (code, mode, operands[0], operands[2])),\n+\t\t\t gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, QImode, 0)))));\n+\n+  return 1;\n+}\n+\n+/* Shift algorithm determination.\n+\n+   There are various ways of doing a shift:\n+   SHIFT_INLINE: If the amount is small enough, just generate as many one-bit\n+                 shifts as we need.\n+   SHIFT_ROT_AND: If the amount is large but close to either end, rotate the\n+                  necessary bits into position and then set the rest to zero.\n+   SHIFT_SPECIAL: Hand crafted assembler.\n+   SHIFT_LOOP:    If the above methods fail, just loop.  */\n+\n+enum shift_alg\n+{\n+  SHIFT_INLINE,\n+  SHIFT_ROT_AND,\n+  SHIFT_SPECIAL,\n+  SHIFT_LOOP,\n+  SHIFT_MAX\n+};\n+\n+/* Symbols of the various shifts which can be used as indices.  */\n+\n+enum shift_type\n+  {\n+    SHIFT_ASHIFT, SHIFT_LSHIFTRT, SHIFT_ASHIFTRT\n+  };\n+\n+/* Symbols of the various modes which can be used as indices.  */\n+\n+enum shift_mode\n+  {\n+    QIshift, HIshift, SIshift\n+  };\n+\n+/* For single bit shift insns, record assembler and whether the condition code\n+   is valid afterwards.  */\n+\n+struct shift_insn\n+{\n+  char *assembler;\n+  int cc_valid;\n+};\n+\n+/* Assembler instruction shift table.\n+\n+   These tables are used to look up the basic shifts.\n+   They are indexed by cpu, shift_type, and mode.\n+*/\n \n-      /* Can't define expand a loop after rtl generation.  */\n-      if (! rtx_equal_function_value_matters)\n-\treturn 0;\n+static const struct shift_insn shift_one[2][3][3] =\n+{\n+/* H8/300 */\n+  {\n+/* SHIFT_ASHIFT */\n+    {\n+      { \"shal %X0\", 1 },\n+      { \"add.w %T0,%T0\\t; shal.w\", 1 },\n+      { \"add.w %f0,%f0\\t; shal.l\\n\\taddx %y0,%y0\\n\\taddx %z0,%z0\\t; end shal.l\", 0 }\n+    },\n+/* SHIFT_LSHIFTRT */\n+    {\n+      { \"shlr %X0\", 1 },\n+      { \"shlr %t0\\t; shlr.w\\n\\trotxr %s0\\t; end shlr.w\", 0 },\n+      { \"shlr %z0\\t; shlr.l\\n\\trotxr %y0\\n\\trotxr %x0\\n\\trotxr %w0\\t; end shlr.l\", 0 }\n+    },\n+/* SHIFT_ASHIFTRT */\n+    {\n+      { \"shar %X0\", 1 },\n+      { \"shar %t0\\t; shar.w\\n\\trotxr %s0\\t; end shar.w\", 0 },\n+      { \"shar %z0\\t; shar.l\\n\\trotxr %y0\\n\\trotxr %x0\\n\\trotxr %w0\\t; end shar.l\", 0 }\n+    }\n+  },\n+/* H8/300H */\n+  {\n+/* SHIFT_ASHIFT */\n+    {\n+      { \"shal.b %X0\", 1 },\n+      { \"shal.w %T0\", 1 },\n+      { \"shal.l %S0\", 1 }\n+    },\n+/* SHIFT_LSHIFTRT */\n+    {\n+      { \"shlr.b %X0\", 1 },\n+      { \"shlr.w %T0\", 1 },\n+      { \"shlr.l %S0\", 1 }\n+    },\n+/* SHIFT_ASHIFTRT */\n+    {\n+      { \"shar.b %X0\", 1 },\n+      { \"shar.w %T0\", 1 },\n+      { \"shar.l %S0\", 1 }\n+    }\n+  }\n+};\n \n-      lval = gen_reg_rtx (QImode);\n+/* Rotates are organized by which shift they'll be used in implementing.\n+   There's no need to record whether the cc is valid afterwards because\n+   it is the AND insn that will decide this.  */\n \n-      convert_move (lval, operands[2], 1);\n-      shift_n_bits (lval, operands[0], f, 0);\n+static const char *const rotate_one[2][3][3] =\n+{\n+/* H8/300 */\n+  {\n+/* SHIFT_ASHIFT */\n+    {\n+      \"rotr %X0\",\n+      \"shlr %t0\\t; rotr.w\\n\\trotxr %s0\\n\\tbst #7,%t0\\t; end rotr.w\",\n+      0\n+    },\n+/* SHIFT_LSHIFTRT */\n+    {\n+      \"rotl %X0\",\n+      \"shll %s0\\t; rotl.w\\n\\trotxl %t0\\n\\tbst #0,%s0\\t; end rotl.w\",\n+      0\n+    },\n+/* SHIFT_ASHIFTRT */\n+    {\n+      \"rotl %X0\",\n+      \"shll %s0\\t; rotl.w\\n\\trotxl %t0\\n\\tbst #0,%s0\\t; end rotl.w\",\n+      0\n     }\n-  else\n+  },\n+/* H8/300H */\n+  {\n+/* SHIFT_ASHIFT */\n+    {\n+      \"rotr.b %X0\",\n+      \"rotr.w %T0\",\n+      \"rotr.l %S0\"\n+    },\n+/* SHIFT_LSHIFTRT */\n     {\n-      int i;\n+      \"rotl.b %X0\",\n+      \"rotl.w %T0\",\n+      \"rotl.l %S0\"\n+    },\n+/* SHIFT_ASHIFTRT */\n+    {\n+      \"rotl.b %X0\",\n+      \"rotl.w %T0\",\n+      \"rotl.l %S0\"\n+    }\n+  }\n+};\n+\n+/* Given CPU, MODE, SHIFT_TYPE, and shift count COUNT, determine the best\n+   algorithm for doing the shift.  The assembler code is stored in ASSEMBLER.\n+   We don't achieve maximum efficiency in all cases, but the hooks are here\n+   to do so.\n+\n+   For now we just use lots of switch statements.  Since we don't even come\n+   close to supporting all the cases, this is simplest.  If this function ever\n+   gets too big, perhaps resort to a more table based lookup.  Of course,\n+   at this point you may just wish to do it all in rtl.\n+\n+   WARNING: The constraints on insns shiftbyn_QI/HI/SI assume shifts of\n+   1,2,3,4 will be inlined (1,2 for SI).  */\n+\n+static enum shift_alg\n+get_shift_alg (cpu, shift_type, mode, count, assembler_p, cc_valid_p)\n+     enum attr_cpu cpu;\n+     enum shift_type shift_type;\n+     enum machine_mode mode;\n+     int count;\n+     const char **assembler_p;\n+     int *cc_valid_p;\n+{\n+  /* The default is to loop.  */\n+  enum shift_alg alg = SHIFT_LOOP;\n+  enum shift_mode shift_mode;\n+\n+  /* We don't handle negative shifts or shifts greater than the word size,\n+     they should have been handled already.  */\n \n-      i = INTVAL (operands[2]);\n-      if (i >= 8 && fby_eight)\n+  if (count < 0 || count > GET_MODE_BITSIZE (mode))\n+    abort ();\n+\n+  switch (mode)\n+    {\n+    case QImode:\n+      shift_mode = QIshift;\n+      break;\n+    case HImode:\n+      shift_mode = HIshift;\n+      break;\n+    case SImode:\n+      shift_mode = SIshift;\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  /* Assume either SHIFT_LOOP or SHIFT_INLINE.\n+     It is up to the caller to know that looping clobbers cc.  */\n+  *assembler_p = shift_one[cpu][shift_type][shift_mode].assembler;\n+  *cc_valid_p = shift_one[cpu][shift_type][shift_mode].cc_valid;\n+\n+  /* Now look for cases we want to optimize.  */\n+\n+  switch (shift_mode)\n+    {\n+    case QIshift:\n+      if (count <= 4)\n+\treturn SHIFT_INLINE;\n+      else if (count <= 6)\n \t{\n-\t  fby_eight (operands[0]);\n-\t  i -= 8;\n+\t  if (shift_type == SHIFT_ASHIFTRT)\n+\t    {\n+\t      return SHIFT_LOOP;\n+\t    }\n+\t  else\n+\t    {\n+\t      *assembler_p = rotate_one[cpu][shift_type][shift_mode];\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_ROT_AND;\n+\t    }\n \t}\n-      if (i > limit)\n+      else if (count == 7)\n \t{\n-\t  rtx lval;\n-\n-\t  /* Can't define expand a loop after rtl generation.  */\n-\t  if (! rtx_equal_function_value_matters)\n-\t    return 0;\n-\t  lval = gen_reg_rtx (QImode);\n-\t  emit_move_insn (lval, gen_rtx (CONST_INT, VOIDmode, i));\n-\t  shift_n_bits (lval, operands[0], f, 1);\n+\t  if (shift_type == SHIFT_ASHIFTRT)\n+\t    {\n+\t      *assembler_p = \"shll %X0\\t; shar.b(7)\\n\\tsubx %X0,%X0\\t; end shar.b(7)\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    }\n+\t  else\n+\t    {\n+\t      *assembler_p = rotate_one[cpu][shift_type][shift_mode];\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_ROT_AND;\n+\t    }\n \t}\n-      else\n+      break;\n+    case HIshift:\n+      if (count <= 4)\n+\treturn SHIFT_INLINE;\n+      else if (count == 8)\n+\t{\n+\t  switch (shift_type)\n+\t    {\n+\t    case SHIFT_ASHIFT:\n+\t      *assembler_p = \"mov.b %s0,%t0\\t; shal.w(8)\\n\\tsub.b %s0,%s0\\t; end shal.w(8)\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    case SHIFT_LSHIFTRT:\n+\t      *assembler_p = \"mov.b %t0,%s0\\t; shlr.w(8)\\n\\tsub.b %t0,%t0\\t; end shlr.w(8)\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    case SHIFT_ASHIFTRT:\n+\t      if (cpu == CPU_H8300)\n+\t\t*assembler_p = \"mov.b %t0,%s0\\t; shar.w(8)\\n\\tshll %t0\\n\\tsubx %t0,%t0\\t; end shar.w(8)\";\n+\t      else\n+\t\t*assembler_p = \"mov.b %t0,%s0\\t; shar.w(8)\\n\\texts.w %T0\\t; end shar.w(8)\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    }\n+\t  abort ();\n+\t}\n+      else if (count == 15)\n \t{\n-\t  while (i--)\n-\t    f (operands[0]);\n+\t  if (shift_type == SHIFT_ASHIFTRT)\n+\t    {\n+\t      *assembler_p = \"shll %t0,%t0\\t; shar.w(15)\\n\\tsubx %t0,%t0\\n\\tmov.b %t0,%s0\\t; end shar.w(15)\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    }\n+\t  else\n+\t    {\n+\t      *assembler_p = rotate_one[cpu][shift_type][shift_mode];\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_ROT_AND;\n+\t    }\n \t}\n+      break;\n+    case SIshift:\n+      if (count <= (cpu == CPU_H8300 ? 2 : 4))\n+\treturn SHIFT_INLINE;\n+      else if (count == 8)\n+\t{\n+\t  if (cpu == CPU_H8300)\n+\t    {\n+\t      switch (shift_type)\n+\t\t{\n+\t\tcase SHIFT_ASHIFT:\n+\t\t  *assembler_p = \"mov.b %y0,%z0\\t; shal.l(8)\\n\\tmov.b %x0,%y0\\n\\tmov.b %w0,%x0\\n\\tsub.b %w0,%w0\\t; end shal.l(8)\";\n+\t\t  *cc_valid_p = 0;\n+\t\t  return SHIFT_SPECIAL;\n+\t\tcase SHIFT_LSHIFTRT:\n+\t\t  *assembler_p = \"mov.b %x0,%w0\\t; shlr.l(8)\\n\\tmov.b %y0,%x0\\n\\tmov.b %z0,%y0\\n\\tsub.b %z0,%z0\\t; end shlr.l(8)\";\n+\t\t  *cc_valid_p = 0;\n+\t\t  return SHIFT_SPECIAL;\n+\t\tcase SHIFT_ASHIFTRT:\n+\t\t  *assembler_p = \"mov.b %x0,%w0\\t; shar.l(8)\\n\\tmov.b %y0,%x0\\n\\tmov.b %z0,%y0\\n\\tshll %z0\\n\\tsubx %z0,%z0; end shar.l(8)\";\n+\t\t  *cc_valid_p = 0;\n+\t\t  return SHIFT_SPECIAL;\n+\t\t}\n+\t    }\n+\t  else\t\t\t/* CPU_H8300H */\n+\t    /* We don't have byte level access to the high word so this isn't\n+\t       easy to do.  For now, just loop.  */\n+\t    ;\n+\t}\n+      else if (count == 16)\n+\t{\n+\t  switch (shift_type)\n+\t    {\n+\t    case SHIFT_ASHIFT:\n+\t      *assembler_p = \"mov.w %f0,%e0\\t; shal.l(16)\\n\\tsub.w %f0,%f0\\t; end shal.l(16)\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    case SHIFT_LSHIFTRT:\n+\t      *assembler_p = \"mov.w %e0,%f0\\t; shlr.l(16)\\n\\tsub.w %e0,%e0\\t; end shlr.l(16)\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    case SHIFT_ASHIFTRT:\n+\t      if (cpu == CPU_H8300)\n+\t\t*assembler_p = \"mov.w %e0,%f0\\t; shar.l(16)\\n\\tshll %z0\\n\\tsubx %z0,%z0\\n\\tmov.b %z0,%y0\\t; end shar.l(16)\";\n+\t      else\n+\t\t*assembler_p = \"mov.w %e0,%f0\\t; shar.l(16)\\n\\texts.l %S0\\t; end shar.l(16)\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    }\n+\t}\n+      else if (count >= 28 && count <= 30)\n+\t{\n+\t  if (shift_type == SHIFT_ASHIFTRT)\n+\t    {\n+\t      return SHIFT_LOOP;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (cpu == CPU_H8300)\n+\t\treturn SHIFT_LOOP;\n+\t      else\n+\t\t{\n+\t\t  *assembler_p = rotate_one[cpu][shift_type][shift_mode];\n+\t\t  *cc_valid_p = 0;\n+\t\t  return SHIFT_ROT_AND;\n+\t\t}\n+\t    }\n+\t}\n+      else if (count == 31)\n+\t{\n+\t  if (shift_type == SHIFT_ASHIFTRT)\n+\t    {\n+\t      if (cpu == CPU_H8300)\n+\t\t*assembler_p = \"shll %z0\\t; shar.l(31)\\n\\tsubx %w0,%w0\\n\\tmov.b %w0,%x0\\n\\tmov.w %f0,%e0\\t; end shar.l(31)\";\n+\t      else\n+\t\t*assembler_p = \"shll %e0\\t; shar.l(31)\\n\\tsubx %w0,%w0\\n\\tmov.b %w0,%x0\\n\\tmov.w %f0,%e0\\t; end shar.l(31)\";\n+\t      *cc_valid_p = 0;\n+\t      return SHIFT_SPECIAL;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (cpu == CPU_H8300)\n+\t\t{\n+\t\t  if (shift_type == SHIFT_ASHIFT)\n+\t\t    *assembler_p = \"sub.w %e0,%e0\\t; shal.l(31)\\n\\tshlr %w0\\n\\tmov.w %e0,%f0\\n\\trotxr %z0\\t; end shal.l(31)\";\n+\t\t  else\n+\t\t    *assembler_p = \"sub.w %f0,%f0\\t; shlr.l(31)\\n\\tshll %z0\\n\\tmov.w %f0,%e0\\n\\trotxl %w0\\t; end shlr.l(31)\";\n+\t\t  *cc_valid_p = 0;\n+\t\t  return SHIFT_SPECIAL;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  *assembler_p = rotate_one[cpu][shift_type][shift_mode];\n+\t\t  *cc_valid_p = 0;\n+\t\t  return SHIFT_ROT_AND;\n+\t\t}\n+\t    }\n+\t}\n+      break;\n+    default:\n+      abort ();\n     }\n-  return 1;\n+\n+  return alg;\n }\n \n-int\n-domovsi (operands)\n-     rtx operands[];\n+/* Emit the assembler code for doing shifts.  */\n+\n+char *\n+emit_a_shift (insn, operands)\n+     rtx insn;\n+     rtx *operands;\n {\n-  rtx src = operands[1];\n-  rtx dst = operands[0];\n+  static int loopend_lab;\n+  char *assembler;\n+  int cc_valid;\n+  rtx inside = PATTERN (insn);\n+  rtx shift = operands[3];\n+  enum machine_mode mode = GET_MODE (shift);\n+  enum rtx_code code = GET_CODE (shift);\n+  enum shift_type shift_type;\n+  enum shift_mode shift_mode;\n+\n+  loopend_lab++;\n+\n+  switch (mode)\n+    {\n+    case QImode:\n+      shift_mode = QIshift;\n+      break;\n+    case HImode:\n+      shift_mode = HIshift;\n+      break;\n+    case SImode:\n+      shift_mode = SIshift;\n+      break;\n+    default:\n+      abort ();\n+    }\n \n-  if (push_operand (dst, GET_MODE (dst)))\n+  switch (code)\n     {\n-      /* Source must be a reg.  */\n-      if (! REG_P (src))\n-\t{\n-\t  rtx tmp = gen_reg_rtx (GET_MODE (dst));\n+    case ASHIFTRT:\n+      shift_type = SHIFT_ASHIFTRT;\n+      break;\n+    case LSHIFTRT:\n+      shift_type = SHIFT_LSHIFTRT;\n+      break;\n+    case ASHIFT:\n+      shift_type = SHIFT_ASHIFT;\n+      break;\n+    default:\n+      abort ();\n+    }\n \n-\t  emit_move_insn (tmp, src);\n-\t  operands[1] = tmp;\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    {\n+      /* Indexing by reg, so have to loop and test at top */\n+      output_asm_insn (\"mov.b\t%X2,%X4\", operands);\n+      fprintf (asm_out_file, \"\\tble\t.Lle%d\\n\", loopend_lab);\n+\n+      /* Get the assembler code to do one shift.  */\n+      get_shift_alg (cpu_type, shift_type, mode, 1, &assembler, &cc_valid);\n+    }\n+  else\n+    {\n+      int n = INTVAL (operands[2]);\n+      enum shift_alg alg;\n+\n+      /* If the count is negative, make it 0.  */\n+      if (n < 0)\n+\tn = 0;\n+      /* If the count is too big, truncate it.\n+         ANSI says shifts of GET_MODE_BITSIZE are undefined - we choose to\n+\t do the intuitive thing.  */\n+      else if (n > GET_MODE_BITSIZE (mode))\n+\tn = GET_MODE_BITSIZE (mode);\n+\n+      alg = get_shift_alg (cpu_type, shift_type, mode, n, &assembler, &cc_valid);\n+\n+      switch (alg)\n+\t{\n+\tcase SHIFT_INLINE:\n+\t  while (--n >= 0)\n+\t    output_asm_insn (assembler, operands);\n+\t  if (cc_valid)\n+\t    cc_status.value1 = operands[0];\n+\t  return \"\";\n+\tcase SHIFT_ROT_AND:\n+\t  {\n+\t    int m = GET_MODE_BITSIZE (mode) - n;\n+\t    int mask = (shift_type == SHIFT_ASHIFT\n+\t\t\t? ((1 << GET_MODE_BITSIZE (mode) - n) - 1) << n\n+\t\t\t: (1 << GET_MODE_BITSIZE (mode) - n) - 1);\n+\t    char insn_buf[200];\n+\t    /* Not all possibilities of rotate are supported.  They shouldn't\n+\t       be generated, but let's watch for 'em.  */\n+\t    if (assembler == 0)\n+\t      abort ();\n+\t    while (--m >= 0)\n+\t      output_asm_insn (assembler, operands);\n+\t    if (TARGET_H8300)\n+\t      {\n+\t\tswitch (mode)\n+\t\t  {\n+\t\t  case QImode:\n+\t\t    sprintf (insn_buf, \"and #%d,%%X0\\t; end shift %d via rotate+and\",\n+\t\t\t     mask, n);\n+\t\t    cc_status.value1 = operands[0];\n+\t\t    break;\n+\t\t  case HImode:\n+\t\t    sprintf (insn_buf, \"and #%d,%%s0\\n\\tand #%d,%%t0\\t; end shift %d via rotate+and\",\n+\t\t\t     mask & 255, mask >> 8, n);\n+\t\t    break;\n+\t\t  case SImode:\n+\t\t    abort ();\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\tsprintf (insn_buf, \"and.%c #%d,%%%c0\",\n+\t\t\t \"bwl\"[shift_mode], mask,\n+\t\t\t mode == QImode ? 'X' : mode == HImode ? 'T' : 'S');\n+\t\tcc_status.value1 = operands[0];\n+\t      }\n+\t    output_asm_insn (insn_buf, operands);\n+\t    return \"\";\n+\t  }\n+\tcase SHIFT_SPECIAL:\n+\t  output_asm_insn (assembler, operands);\n+\t  return \"\";\n \t}\n+\n+      /* Need a loop, move limit to tmp reg */\n+      fprintf (asm_out_file, \"\\tmov.b\t#%d,%sl\\n\", n, names_big[REGNO (operands[4])]);\n     }\n-  return 0;\n+\n+  fprintf (asm_out_file, \".Llt%d:\\n\", loopend_lab);\n+  output_asm_insn (assembler, operands);\n+  output_asm_insn (\"add\t#0xff,%X4\", operands);\n+  fprintf (asm_out_file, \"\\tbne\t.Llt%d\\n\", loopend_lab);\n+  fprintf (asm_out_file, \".Lle%d:\\n\", loopend_lab);\n+\n+  return \"\";\n }\n+\f\n+/* Fix the operands of a gen_xxx so that it could become a bit\n+  operating insn.  */\n \n int\n-io (FROM, TO)\n+fix_bit_operand (operands, what, type)\n+     rtx *operands;\n+     char what;\n+     enum rtx_code type;\n {\n-  int OFFSET = 0;\n+  /* The bit_operand predicate accepts any memory durint RTL generation, but\n+     only 'U' memory afterwards, so if this is a MEM operand, we must force\n+     it to be valid for 'U' by reloading the address.  */\n \n-  if ((FROM) == ARG_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM)\n-    (OFFSET) = 2 + frame_pointer_needed * 2;\n-  else\n+  if (GET_CODE (operands[2]) == CONST_INT)\n     {\n-      int regno;\n-      int offset = 0;\n-\n-      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\tif ((regs_ever_live[regno]\n-\t     && (! call_used_regs[regno] || regno == FRAME_POINTER_REGNUM)))\n-\t  offset += 2;\n+      if (CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), what))\n+\t{\n+\t  /* Ok to have a memory dest.  */\n+\t  if (GET_CODE (operands[0]) == MEM && !EXTRA_CONSTRAINT (operands[0], 'U'))\n+\t    {\n+\t      rtx mem;\n+\t      mem = gen_rtx (MEM, GET_MODE (operands[0]),\n+\t\t\t   copy_to_mode_reg (Pmode, XEXP (operands[0], 0)));\n+\t      RTX_UNCHANGING_P (mem) = RTX_UNCHANGING_P (operands[0]);\n+\t      MEM_IN_STRUCT_P (mem) = MEM_IN_STRUCT_P (operands[0]);\n+\t      MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (operands[0]);\n+\t      operands[0] = mem;\n+\t    }\n+\n+\t  if (GET_CODE (operands[1]) == MEM && !EXTRA_CONSTRAINT (operands[1], 'U'))\n+\t    {\n+\t      rtx mem;\n+\t      mem = gen_rtx (MEM, GET_MODE (operands[1]),\n+\t\t\t   copy_to_mode_reg (Pmode, XEXP (operands[1], 0)));\n+\t      RTX_UNCHANGING_P (mem) = RTX_UNCHANGING_P (operands[1]);\n+\t      MEM_IN_STRUCT_P (mem) = MEM_IN_STRUCT_P (operands[1]);\n+\t      MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (operands[1]);\n+\t      operands[1] = mem;\n+\t    }\n+\t  return 0;\n+\t}\n+    }\n \n-      (OFFSET) = offset + get_frame_size ();\n+  /* Dest and src op must be register.  */\n \n-      if ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\n-\t(OFFSET) += 2;\t\t/* Skip saved PC.  */\n-    }\n-  return OFFSET;\n+  operands[1] = force_reg (QImode, operands[1]);\n+  {\n+    rtx res = gen_reg_rtx (QImode);\n+    emit_insn (gen_rtx (SET, VOIDmode, res, gen_rtx (type, QImode, operands[1], operands[2])));\n+    emit_insn (gen_rtx (SET, VOIDmode, operands[0], res));\n+  }\n+  return 1;\n }"}]}