{"sha": "6dbe4c9e2480349578199074b959502b859f7fcc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRiZTRjOWUyNDgwMzQ5NTc4MTk5MDc0Yjk1OTUwMmI4NTlmN2ZjYw==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2016-07-06T23:53:04Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2016-07-06T23:53:04Z"}, "message": "make antic_stores a vec<rtx_insn *>\n\ngcc/ChangeLog:\n\n2016-07-06  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* store-motion.c (struct st_expr): Make antic_stores a vector.\n\t(st_expr_entry): Adjust.\n\t(free_st_expr_entry): Likewise.\n\t(print_store_motion_mems): Likewise.\n\t(find_moveable_store): Likewise.\n\t(compute_store_table): Likewise.\n\t(remove_reachable_equiv_notes): Likewise.\n\t(replace_store_insn): Likewise.\n\t(build_store_vectors): Likewise.\n\nFrom-SVN: r238063", "tree": {"sha": "ee2558ea8cc21b5c5a6d356d11de1716c6764229", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee2558ea8cc21b5c5a6d356d11de1716c6764229"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6dbe4c9e2480349578199074b959502b859f7fcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dbe4c9e2480349578199074b959502b859f7fcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dbe4c9e2480349578199074b959502b859f7fcc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dbe4c9e2480349578199074b959502b859f7fcc/comments", "author": null, "committer": null, "parents": [{"sha": "52e862219926fb800c55cdf36cb2e18ac4555dac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52e862219926fb800c55cdf36cb2e18ac4555dac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52e862219926fb800c55cdf36cb2e18ac4555dac"}], "stats": {"total": 66, "additions": 37, "deletions": 29}, "files": [{"sha": "d0ff7faeb8442ad2d2fe59179484da2b1436a184", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dbe4c9e2480349578199074b959502b859f7fcc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dbe4c9e2480349578199074b959502b859f7fcc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6dbe4c9e2480349578199074b959502b859f7fcc", "patch": "@@ -1,3 +1,15 @@\n+2016-07-06  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* store-motion.c (struct st_expr): Make antic_stores a vector.\n+\t(st_expr_entry): Adjust.\n+\t(free_st_expr_entry): Likewise.\n+\t(print_store_motion_mems): Likewise.\n+\t(find_moveable_store): Likewise.\n+\t(compute_store_table): Likewise.\n+\t(remove_reachable_equiv_notes): Likewise.\n+\t(replace_store_insn): Likewise.\n+\t(build_store_vectors): Likewise.\n+\n 2016-07-06  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/driver-arm.c (arm_cpu_table): Add entries for cortex-a32,"}, {"sha": "6d7d37f694470be2768a942fa912975674a51006", "filename": "gcc/store-motion.c", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dbe4c9e2480349578199074b959502b859f7fcc/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dbe4c9e2480349578199074b959502b859f7fcc/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=6dbe4c9e2480349578199074b959502b859f7fcc", "patch": "@@ -46,7 +46,6 @@ along with GCC; see the file COPYING3.  If not see\n      a compile time hog that needs a rewrite (maybe cache st_exprs to\n      invalidate REG_EQUAL/REG_EQUIV notes for?).\n    - pattern_regs in st_expr should be a regset (on its own obstack).\n-   - antic_stores and avail_stores should be VECs instead of lists.\n    - store_motion_mems should be a vec instead of a list.\n    - there should be an alloc pool for struct st_expr objects.\n    - investigate whether it is helpful to make the address of an st_expr\n@@ -66,7 +65,7 @@ struct st_expr\n   /* List of registers mentioned by the mem.  */\n   rtx pattern_regs;\n   /* INSN list of stores that are locally anticipatable.  */\n-  rtx_insn_list *antic_stores;\n+  vec<rtx_insn *> antic_stores;\n   /* INSN list of stores that are locally available.  */\n   vec<rtx_insn *> avail_stores;\n   /* Next in the list.  */\n@@ -148,7 +147,7 @@ st_expr_entry (rtx x)\n   ptr->next         = store_motion_mems;\n   ptr->pattern      = x;\n   ptr->pattern_regs = NULL_RTX;\n-  ptr->antic_stores = NULL;\n+  ptr->antic_stores.create (0);\n   ptr->avail_stores.create (0);\n   ptr->reaching_reg = NULL_RTX;\n   ptr->index        = 0;\n@@ -164,8 +163,8 @@ st_expr_entry (rtx x)\n static void\n free_st_expr_entry (struct st_expr * ptr)\n {\n-  free_INSN_LIST_list (& ptr->antic_stores);\n-   ptr->avail_stores.release ();\n+  ptr->antic_stores.release ();\n+  ptr->avail_stores.release ();\n \n   free (ptr);\n }\n@@ -233,11 +232,7 @@ print_store_motion_mems (FILE * file)\n       print_rtl (file, ptr->pattern);\n \n       fprintf (file, \"\\n\t ANTIC stores : \");\n-\n-      if (ptr->antic_stores)\n-\tprint_rtl (file, ptr->antic_stores);\n-      else\n-\tfprintf (file, \"(nil)\");\n+      print_rtx_insn_vec (file, ptr->antic_stores);\n \n       fprintf (file, \"\\n\t AVAIL stores : \");\n \n@@ -566,11 +561,11 @@ find_moveable_store (rtx_insn *insn, int *regs_set_before, int *regs_set_after)\n   /* Do not check for anticipatability if we either found one anticipatable\n      store already, or tested for one and found out that it was killed.  */\n   check_anticipatable = 0;\n-  if (!ptr->antic_stores)\n+  if (ptr->antic_stores.is_empty ())\n     check_anticipatable = 1;\n   else\n     {\n-      rtx_insn *tmp = ptr->antic_stores->insn ();\n+      rtx_insn *tmp = ptr->antic_stores.last ();\n       if (tmp != NULL_RTX\n \t  && BLOCK_FOR_INSN (tmp) != bb)\n \tcheck_anticipatable = 1;\n@@ -582,7 +577,7 @@ find_moveable_store (rtx_insn *insn, int *regs_set_before, int *regs_set_after)\n \ttmp = NULL;\n       else\n \ttmp = insn;\n-      ptr->antic_stores = alloc_INSN_LIST (tmp, ptr->antic_stores);\n+      ptr->antic_stores.safe_push (tmp);\n     }\n \n   /* It is not necessary to check whether store is available if we did\n@@ -683,9 +678,9 @@ compute_store_table (void)\n       for (ptr = first_st_expr (); ptr != NULL; ptr = next_st_expr (ptr))\n \t{\n \t  LAST_AVAIL_CHECK_FAILURE (ptr) = NULL_RTX;\n-\t  if (ptr->antic_stores\n-\t      && (tmp = ptr->antic_stores->insn ()) == NULL_RTX)\n-\t    ptr->antic_stores = ptr->antic_stores->next ();\n+\t  if (!ptr->antic_stores.is_empty ()\n+\t      && (tmp = ptr->antic_stores.last ()) == NULL)\n+\t    ptr->antic_stores.pop ();\n \t}\n     }\n \n@@ -831,7 +826,7 @@ remove_reachable_equiv_notes (basic_block bb, struct st_expr *smexpr)\n   int sp;\n   edge act;\n   sbitmap visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n-  rtx last, note;\n+  rtx note;\n   rtx_insn *insn;\n   rtx mem = smexpr->pattern;\n \n@@ -866,13 +861,13 @@ remove_reachable_equiv_notes (basic_block bb, struct st_expr *smexpr)\n \t}\n       bitmap_set_bit (visited, bb->index);\n \n+      rtx_insn *last;\n       if (bitmap_bit_p (st_antloc[bb->index], smexpr->index))\n \t{\n-\t  for (last = smexpr->antic_stores;\n-\t       BLOCK_FOR_INSN (XEXP (last, 0)) != bb;\n-\t       last = XEXP (last, 1))\n-\t    continue;\n-\t  last = XEXP (last, 0);\n+\t  unsigned int i;\n+\t  FOR_EACH_VEC_ELT_REVERSE (smexpr->antic_stores, i, last)\n+\t    if (BLOCK_FOR_INSN (last) == bb)\n+\t      break;\n \t}\n       else\n \tlast = NEXT_INSN (BB_END (bb));\n@@ -911,15 +906,17 @@ replace_store_insn (rtx reg, rtx_insn *del, basic_block bb,\n \t\t    struct st_expr *smexpr)\n {\n   rtx_insn *insn;\n-  rtx mem, note, set, ptr;\n+  rtx mem, note, set;\n \n   mem = smexpr->pattern;\n   insn = gen_move_insn (reg, SET_SRC (single_set (del)));\n \n-  for (ptr = smexpr->antic_stores; ptr; ptr = XEXP (ptr, 1))\n-    if (XEXP (ptr, 0) == del)\n+  unsigned int i;\n+  rtx_insn *temp;\n+  FOR_EACH_VEC_ELT_REVERSE (smexpr->antic_stores, i, temp)\n+    if (temp == del)\n       {\n-\tXEXP (ptr, 0) = insn;\n+\tsmexpr->antic_stores[i] = insn;\n \tbreak;\n       }\n \n@@ -1001,7 +998,6 @@ build_store_vectors (void)\n   basic_block bb;\n   int *regs_set_in_block;\n   rtx_insn *insn;\n-  rtx_insn_list *st;\n   struct st_expr * ptr;\n   unsigned int max_gcse_regno = max_reg_num ();\n \n@@ -1038,9 +1034,9 @@ build_store_vectors (void)\n \t  bitmap_set_bit (st_avloc[bb->index], ptr->index);\n \t}\n \n-      for (st = ptr->antic_stores; st != NULL; st = st->next ())\n+      unsigned int i;\n+      FOR_EACH_VEC_ELT_REVERSE (ptr->antic_stores, i, insn)\n \t{\n-\t  insn = st->insn ();\n \t  bb = BLOCK_FOR_INSN (insn);\n \t  bitmap_set_bit (st_antloc[bb->index], ptr->index);\n \t}"}]}