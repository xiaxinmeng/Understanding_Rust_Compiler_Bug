{"sha": "f6cb56fa00cfe9cfab7e263361a13d6a2c6a851a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZjYjU2ZmEwMGNmZTljZmFiN2UyNjMzNjFhMTNkNmEyYzZhODUxYQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2003-01-07T17:05:16Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2003-01-07T17:05:16Z"}, "message": "cfg.c: Include alloc-pool.h\n\n2003-01-07  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* cfg.c: Include alloc-pool.h\n\t(edge_pool): New pool.\n\t(bb_pool): New pool.\n\t(first_deleted_edge): Remove.\n\t(first_deleted_block): Remove.\n\t(init_flow): Alloc/free the pools.\n\t(free_edge): Use pools.\n\t(alloc_block): Ditto.\n\t(expunge_block): Ditto.\n\t(cached_make_edge): Ditto.\n\n\t* Makefile.in (cfg.o): Add alloc-pool.h dependency.\n\n2003-01-07  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* et-forest.c: Include alloc-pool.h.\n\t(struct et_forest): Add node_pool and occur_pool.\n\t(et_forest_create): Create the new pools.\n\t(et_forest_delete): Delete them.\n\t(et_forest_add_node): Allocate and free using pools.\n\t(et_forest_add_edge): Ditto.\n\t(et_forest_remove_node): Ditto.\n\t(et_forest_remove_edge): Ditto.\n\n\t* Makefile.in (et-forest.o): Add alloc-pool.h dependency.\n\nFrom-SVN: r61001", "tree": {"sha": "d11f774feec9141299ef0fd12c1bdc066f115790", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d11f774feec9141299ef0fd12c1bdc066f115790"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6cb56fa00cfe9cfab7e263361a13d6a2c6a851a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6cb56fa00cfe9cfab7e263361a13d6a2c6a851a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6cb56fa00cfe9cfab7e263361a13d6a2c6a851a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6cb56fa00cfe9cfab7e263361a13d6a2c6a851a/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6ec628973a0ecba9905d9ad95ca0d8f3c79b7ded", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ec628973a0ecba9905d9ad95ca0d8f3c79b7ded", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ec628973a0ecba9905d9ad95ca0d8f3c79b7ded"}], "stats": {"total": 127, "additions": 72, "deletions": 55}, "files": [{"sha": "ac0a80d0747ea65f51fb63fc8268c6be95e2c213", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6cb56fa00cfe9cfab7e263361a13d6a2c6a851a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6cb56fa00cfe9cfab7e263361a13d6a2c6a851a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f6cb56fa00cfe9cfab7e263361a13d6a2c6a851a", "patch": "@@ -1,3 +1,31 @@\n+2003-01-07  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* cfg.c: Include alloc-pool.h\n+\t(edge_pool): New pool.\n+\t(bb_pool): New pool.\n+\t(first_deleted_edge): Remove.\n+\t(first_deleted_block): Remove.\n+\t(init_flow): Alloc/free the pools.\n+\t(free_edge): Use pools.\n+\t(alloc_block): Ditto.\n+\t(expunge_block): Ditto.\n+\t(cached_make_edge): Ditto.\n+\n+\t* Makefile.in (cfg.o): Add alloc-pool.h dependency.\n+\n+2003-01-07  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* et-forest.c: Include alloc-pool.h.\n+\t(struct et_forest): Add node_pool and occur_pool.\n+\t(et_forest_create): Create the new pools.\n+\t(et_forest_delete): Delete them.\n+\t(et_forest_add_node): Allocate and free using pools.\n+\t(et_forest_add_edge): Ditto.\n+\t(et_forest_remove_node): Ditto.\n+\t(et_forest_remove_edge): Ditto.\n+\n+\t* Makefile.in (et-forest.o): Add alloc-pool.h dependency.\n+\n 2003-01-07  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.c (output_logical_op): Simplify and"}, {"sha": "df2c65c96d0be91f0e78fca78ed4d8080d64dd59", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6cb56fa00cfe9cfab7e263361a13d6a2c6a851a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6cb56fa00cfe9cfab7e263361a13d6a2c6a851a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f6cb56fa00cfe9cfab7e263361a13d6a2c6a851a", "patch": "@@ -1547,7 +1547,7 @@ flow.o : flow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(RECOG_H) function.h except.h $(EXPR_H) ssa.h $(GGC_H) $(TM_P_H)\n cfg.o : cfg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h insn-config.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n-   function.h except.h $(GGC_H) $(TM_P_H)\n+   function.h except.h $(GGC_H) $(TM_P_H) alloc-pool.h\n cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h \\\n    insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n    function.h except.h $(GGC_H) $(TM_P_H) insn-config.h"}, {"sha": "1bfba7d111fab058f1e49429cb078305cd730eac", "filename": "gcc/cfg.c", "status": "modified", "additions": 23, "deletions": 41, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6cb56fa00cfe9cfab7e263361a13d6a2c6a851a/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6cb56fa00cfe9cfab7e263361a13d6a2c6a851a/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=f6cb56fa00cfe9cfab7e263361a13d6a2c6a851a", "patch": "@@ -57,12 +57,21 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"toplev.h\"\n #include \"tm_p.h\"\n #include \"obstack.h\"\n+#include \"alloc-pool.h\"\n \n /* The obstack on which the flow graph components are allocated.  */\n \n struct obstack flow_obstack;\n static char *flow_firstobj;\n \n+/* Basic block object pool.  */\n+\n+static alloc_pool bb_pool;\n+\n+/* Edge object pool.  */\n+\n+static alloc_pool edge_pool;\n+\n /* Number of basic blocks in the current function.  */\n \n int n_basic_blocks;\n@@ -75,11 +84,6 @@ int last_basic_block;\n \n int n_edges;\n \n-/* First edge in the deleted edges chain.  */\n-\n-edge first_deleted_edge;\n-static basic_block first_deleted_block;\n-\n /* The basic block array.  */\n \n varray_type basic_block_info;\n@@ -140,8 +144,6 @@ init_flow ()\n {\n   static int initialized;\n \n-  first_deleted_edge = 0;\n-  first_deleted_block = 0;\n   n_edges = 0;\n \n   if (!initialized)\n@@ -152,9 +154,15 @@ init_flow ()\n     }\n   else\n     {\n+      free_alloc_pool (bb_pool);\n+      free_alloc_pool (edge_pool);\n       obstack_free (&flow_obstack, flow_firstobj);\n       flow_firstobj = (char *) obstack_alloc (&flow_obstack, 0);\n     }\n+  bb_pool = create_alloc_pool (\"Basic block pool\", \n+\t\t\t       sizeof (struct basic_block_def), 100);\n+  edge_pool = create_alloc_pool (\"Edge pool\",\n+\t\t\t       sizeof (struct edge_def), 100);\n }\n \f\n /* Helper function for remove_edge and clear_edges.  Frees edge structure\n@@ -165,9 +173,7 @@ free_edge (e)\n      edge e;\n {\n   n_edges--;\n-  memset (e, 0, sizeof *e);\n-  e->succ_next = first_deleted_edge;\n-  first_deleted_edge = e;\n+  pool_free (edge_pool, e);\n }\n \n /* Free the memory associated with the edge structures.  */\n@@ -216,18 +222,8 @@ basic_block\n alloc_block ()\n {\n   basic_block bb;\n-\n-  if (first_deleted_block)\n-    {\n-      bb = first_deleted_block;\n-      first_deleted_block = (basic_block) bb->succ;\n-      bb->succ = NULL;\n-    }\n-  else\n-    {\n-      bb = (basic_block) obstack_alloc (&flow_obstack, sizeof *bb);\n-      memset (bb, 0, sizeof *bb);\n-    }\n+  bb = pool_alloc (bb_pool);\n+  memset (bb, 0, sizeof (*bb));\n   return bb;\n }\n \n@@ -272,7 +268,6 @@ compact_blocks ()\n   last_basic_block = n_basic_blocks;\n }\n \n-\n /* Remove block B from the basic block array.  */\n \n void\n@@ -282,12 +277,7 @@ expunge_block (b)\n   unlink_block (b);\n   BASIC_BLOCK (b->index) = NULL;\n   n_basic_blocks--;\n-\n-  /* Invalidate data to make bughunting easier.  */\n-  memset (b, 0, sizeof *b);\n-  b->index = -3;\n-  b->succ = (edge) first_deleted_block;\n-  first_deleted_block = (basic_block) b;\n+  pool_free (bb_pool, b);\n }\n \f\n /* Create an edge connecting SRC and DST with FLAGS optionally using\n@@ -329,17 +319,10 @@ cached_make_edge (edge_cache, src, dst, flags)\n \t  }\n       break;\n     }\n-\n-  if (first_deleted_edge)\n-    {\n-      e = first_deleted_edge;\n-      first_deleted_edge = e->succ_next;\n-    }\n-  else\n-    {\n-      e = (edge) obstack_alloc (&flow_obstack, sizeof *e);\n-      memset (e, 0, sizeof *e);\n-    }\n+  \n+  \n+  e = pool_alloc (edge_pool);\n+  memset (e, 0, sizeof (*e));\n   n_edges++;\n \n   e->succ_next = src->succ;\n@@ -504,7 +487,6 @@ dump_flow_info (file)\n      FILE *file;\n {\n   int i;\n-  int max_regno = max_reg_num ();\n   basic_block bb;\n   static const char * const reg_class_names[] = REG_CLASS_NAMES;\n "}, {"sha": "99653cedd150018ebad155f77c41855e1ec05a59", "filename": "gcc/et-forest.c", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6cb56fa00cfe9cfab7e263361a13d6a2c6a851a/gcc%2Fet-forest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6cb56fa00cfe9cfab7e263361a13d6a2c6a851a/gcc%2Fet-forest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.c?ref=f6cb56fa00cfe9cfab7e263361a13d6a2c6a851a", "patch": "@@ -28,6 +28,7 @@ Boston, MA 02111-1307, USA.\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"et-forest.h\"\n+#include \"alloc-pool.h\"\n \n struct et_forest_occurrence;\n typedef struct et_forest_occurrence* et_forest_occurrence_t;\n@@ -37,6 +38,8 @@ struct et_forest\n {\n   /* Linked list of nodes is used to destroy the structure.  */\n   int nnodes;\n+  alloc_pool node_pool;\n+  alloc_pool occur_pool;\n };\n \n /* Single occurrence of node in ET-forest.  \n@@ -73,7 +76,7 @@ struct et_forest_node\n \n \n static et_forest_occurrence_t splay PARAMS ((et_forest_occurrence_t));\n-static void remove_all_occurrences PARAMS ((et_forest_node_t));\n+static void remove_all_occurrences PARAMS ((et_forest_t, et_forest_node_t));\n static inline et_forest_occurrence_t find_leftmost_node \n                                PARAMS ((et_forest_occurrence_t));\n static inline et_forest_occurrence_t find_rightmost_node \n@@ -336,7 +339,8 @@ splay (node)\n \n /* Remove all occurences of the given node before destroying the node.  */\n static void\n-remove_all_occurrences (forest_node)\n+remove_all_occurrences (forest, forest_node)\n+     et_forest_t forest;\n      et_forest_node_t forest_node;\n {\n   et_forest_occurrence_t first = forest_node->first;\n@@ -381,7 +385,7 @@ remove_all_occurrences (forest_node)\n       if (prev_node->node->last == next_node)\n \tprev_node->node->last = prev_node;\n \n-      free (next_node);\n+      pool_free (forest->occur_pool, next_node);\n     }\n \n   if (first != last)\n@@ -400,14 +404,14 @@ remove_all_occurrences (forest_node)\n \t    node->right->parent = 0;\n \n \t  next_node = node->next;\n-\t  free (node);\n+\t  pool_free (forest->occur_pool, node);\n \t  node = next_node;\n \t}\n     }\n \n-  free (first);\n+  pool_free (forest->occur_pool, first);\n   if (first != last)\n-    free (last);\n+    pool_free (forest->occur_pool, last);\n }\n \n /* Calculate ET value of the given node.  */\n@@ -439,6 +443,8 @@ et_forest_create ()\n   et_forest_t forest = xmalloc (sizeof (struct et_forest));\n \n   forest->nnodes = 0;\n+  forest->occur_pool = create_alloc_pool (\"et_forest_occurrence pool\", sizeof (struct et_forest_occurrence), 300);\n+  forest->node_pool = create_alloc_pool (\"et_forest_node pool\", sizeof (struct et_forest_node), 300);\n   return forest;\n }\n \n@@ -451,7 +457,8 @@ et_forest_delete (forest)\n {\n   if (forest->nnodes)\n     abort ();\n-\n+  free_alloc_pool (forest->occur_pool);\n+  free_alloc_pool (forest->node_pool);\n   free (forest);\n }\n \n@@ -466,8 +473,8 @@ et_forest_add_node (forest, value)\n   et_forest_node_t node;\n   et_forest_occurrence_t occ;\n \n-  node = xmalloc (sizeof (struct et_forest_node));\n-  occ = xmalloc (sizeof (struct et_forest_occurrence));\n+  node = pool_alloc (forest->node_pool);\n+  occ = pool_alloc (forest->occur_pool);\n \n   node->first = node->last = occ;\n   node->value = value;\n@@ -505,7 +512,7 @@ et_forest_add_edge (forest, parent_node, child_node)\n   if (child_occ->left)\n     abort ();  /* child must be root of its containing tree.  */\n   \n-  new_occ = xmalloc (sizeof (struct et_forest_occurrence));\n+  new_occ = pool_alloc (forest->occur_pool);\n \n   new_occ->node = parent_node;\n   new_occ->left = child_occ;\n@@ -532,10 +539,10 @@ et_forest_remove_node (forest, node)\n      et_forest_t forest;\n      et_forest_node_t node;\n {\n-  remove_all_occurrences (node);\n+  remove_all_occurrences (forest, node);\n   forest->nnodes--;\n \n-  free (node);\n+  pool_free (forest->node_pool, node);\n }\n \n /* Remove edge from the tree, return 1 if sucesfull,\n@@ -575,7 +582,7 @@ et_forest_remove_edge (forest, parent_node, child_node)\n   if (parent_post_occ == parent_node->last)\n     parent_node->last = parent_pre_occ;\n \n-  free (parent_post_occ);\n+  pool_free (forest->occur_pool, parent_post_occ);\n   return 1;\n }\n "}]}