{"sha": "0f1723455cea2d51630be79aceddcfc3ed8a4771", "node_id": "C_kwDOANBUbNoAKDBmMTcyMzQ1NWNlYTJkNTE2MzBiZTc5YWNlZGRjZmMzZWQ4YTQ3NzE", "commit": {"author": {"name": "Pierre-Emmanuel Patry", "email": "pierre-emmanuel.patry@embecosm.com", "date": "2023-02-21T09:48:54Z"}, "committer": {"name": "Pierre-Emmanuel Patry", "email": "pierre-emmanuel.patry@embecosm.com", "date": "2023-03-30T11:52:32Z"}, "message": "libproc_macro: Add string length to ffi\n\nRust string are not null terminated and the C++ part will require a\nbound to know where a string type end. This means the length should be\ngiven as an argument in all ffi functions.\n\nChangeLog:\n\n\t* librust/proc_macro/rust/bridge/ident.rs: Add length to extern\n\tC functions.\n\t* librust/proc_macro/rust/bridge/literal.rs: Add length to\n\textern C functions.\n\t* librust/proc_macro/rust/bridge/token_stream.rs: Add length to\n\textern C functions.\n\nSigned-off-by: Pierre-Emmanuel Patry <pierre-emmanuel.patry@embecosm.com>", "tree": {"sha": "fad56de75936bb6c4605bf8100023093c8e340f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fad56de75936bb6c4605bf8100023093c8e340f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f1723455cea2d51630be79aceddcfc3ed8a4771", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f1723455cea2d51630be79aceddcfc3ed8a4771", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f1723455cea2d51630be79aceddcfc3ed8a4771", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f1723455cea2d51630be79aceddcfc3ed8a4771/comments", "author": {"login": "P-E-P", "id": 32375388, "node_id": "MDQ6VXNlcjMyMzc1Mzg4", "avatar_url": "https://avatars.githubusercontent.com/u/32375388?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P-E-P", "html_url": "https://github.com/P-E-P", "followers_url": "https://api.github.com/users/P-E-P/followers", "following_url": "https://api.github.com/users/P-E-P/following{/other_user}", "gists_url": "https://api.github.com/users/P-E-P/gists{/gist_id}", "starred_url": "https://api.github.com/users/P-E-P/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P-E-P/subscriptions", "organizations_url": "https://api.github.com/users/P-E-P/orgs", "repos_url": "https://api.github.com/users/P-E-P/repos", "events_url": "https://api.github.com/users/P-E-P/events{/privacy}", "received_events_url": "https://api.github.com/users/P-E-P/received_events", "type": "User", "site_admin": false}, "committer": {"login": "P-E-P", "id": 32375388, "node_id": "MDQ6VXNlcjMyMzc1Mzg4", "avatar_url": "https://avatars.githubusercontent.com/u/32375388?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P-E-P", "html_url": "https://github.com/P-E-P", "followers_url": "https://api.github.com/users/P-E-P/followers", "following_url": "https://api.github.com/users/P-E-P/following{/other_user}", "gists_url": "https://api.github.com/users/P-E-P/gists{/gist_id}", "starred_url": "https://api.github.com/users/P-E-P/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P-E-P/subscriptions", "organizations_url": "https://api.github.com/users/P-E-P/orgs", "repos_url": "https://api.github.com/users/P-E-P/repos", "events_url": "https://api.github.com/users/P-E-P/events{/privacy}", "received_events_url": "https://api.github.com/users/P-E-P/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3954270ee7fa782b64bc2f020056b7f6b58195b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3954270ee7fa782b64bc2f020056b7f6b58195b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3954270ee7fa782b64bc2f020056b7f6b58195b0"}], "stats": {"total": 58, "additions": 36, "deletions": 22}, "files": [{"sha": "1c08a003e021e333cf65f98fe13eef457852d795", "filename": "librust/proc_macro/rust/bridge/ident.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1723455cea2d51630be79aceddcfc3ed8a4771/librust%2Fproc_macro%2Frust%2Fbridge%2Fident.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1723455cea2d51630be79aceddcfc3ed8a4771/librust%2Fproc_macro%2Frust%2Fbridge%2Fident.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/librust%2Fproc_macro%2Frust%2Fbridge%2Fident.rs?ref=0f1723455cea2d51630be79aceddcfc3ed8a4771", "patch": "@@ -1,29 +1,29 @@\n use bridge::span::Span;\n-use std::ffi::{c_char, CStr, CString};\n+use std::convert::TryInto;\n+use std::ffi::c_uchar;\n use std::fmt;\n \n extern \"C\" {\n-    fn Ident__new(string: *const c_char) -> Ident;\n-    fn Ident__new_raw(string: *const c_char) -> Ident;\n+    fn Ident__new(string: *const c_uchar, len: u64) -> Ident;\n+    fn Ident__new_raw(string: *const c_uchar, len: u64) -> Ident;\n     fn Ident__drop(ident: *const Ident);\n }\n \n #[repr(C)]\n #[derive(Clone, Debug)]\n pub struct Ident {\n     pub(crate) is_raw: bool,\n-    pub(crate) val: *const c_char,\n+    pub(crate) val: *const c_uchar,\n+    len: u64,\n }\n \n impl Ident {\n     pub fn new(string: &str, _span: Span) -> Self {\n-        let string = CString::new(string).expect(\"Cannot convert to CString\");\n-        unsafe { Ident__new(string.as_ptr()) }\n+        unsafe { Ident__new(string.as_ptr(), string.len().try_into().unwrap()) }\n     }\n \n     pub fn new_raw(string: &str, _span: Span) -> Self {\n-        let string = CString::new(string).expect(\"Cannot convert to CString\");\n-        unsafe { Ident__new_raw(string.as_ptr()) }\n+        unsafe { Ident__new_raw(string.as_ptr(), string.len().try_into().unwrap()) }\n     }\n \n     pub fn span(&self) -> Span {\n@@ -49,9 +49,11 @@ impl fmt::Display for Ident {\n         }\n         fmt::Display::fmt(\n             unsafe {\n-                CStr::from_ptr(self.val)\n-                    .to_str()\n-                    .expect(\"Cannot convert back to rust string\")\n+                std::str::from_utf8(std::slice::from_raw_parts(\n+                    self.val,\n+                    self.len.try_into().unwrap(),\n+                ))\n+                .unwrap()\n             },\n             f,\n         )"}, {"sha": "e883e6b14e00d8191aec84abfc8668c774a7b75f", "filename": "librust/proc_macro/rust/bridge/literal.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1723455cea2d51630be79aceddcfc3ed8a4771/librust%2Fproc_macro%2Frust%2Fbridge%2Fliteral.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1723455cea2d51630be79aceddcfc3ed8a4771/librust%2Fproc_macro%2Frust%2Fbridge%2Fliteral.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/librust%2Fproc_macro%2Frust%2Fbridge%2Fliteral.rs?ref=0f1723455cea2d51630be79aceddcfc3ed8a4771", "patch": "@@ -7,9 +7,9 @@ use LexError;\n \n extern \"C\" {\n     fn Literal__drop(literal: *const Literal);\n-    fn Literal__string(str: *const c_uchar) -> Literal;\n-    fn Literal__byte_string(bytes: *const u8) -> Literal;\n-    fn Literal__from_string(str: *const c_uchar, lit: *mut Literal) -> bool;\n+    fn Literal__string(str: *const c_uchar, len: u64) -> Literal;\n+    fn Literal__byte_string(bytes: *const u8, len: u64) -> Literal;\n+    fn Literal__from_string(str: *const c_uchar, len: u64, lit: *mut Literal) -> bool;\n }\n \n #[repr(C)]\n@@ -46,7 +46,7 @@ pub enum Literal {\n     #[allow(dead_code)]\n     String {\n         data: *const c_uchar,\n-        size: u64,\n+        len: u64,\n     },\n     /// Bytestring literal internal representation\n     ///\n@@ -206,15 +206,15 @@ impl Literal {\n     }\n \n     pub fn string(string: &str) -> Self {\n-        unsafe { Literal__string(string.as_ptr()) }\n+        unsafe { Literal__string(string.as_ptr(), string.len().try_into().unwrap()) }\n     }\n \n     pub fn character(c: char) -> Self {\n         Literal::Char(c.into())\n     }\n \n     pub fn byte_string(bytes: &[u8]) -> Self {\n-        unsafe { Literal__byte_string(bytes.as_ptr()) }\n+        unsafe { Literal__byte_string(bytes.as_ptr(), bytes.len().try_into().unwrap()) }\n     }\n \n     pub fn span(&self) -> Span {\n@@ -240,9 +240,9 @@ impl Drop for Literal {\n impl fmt::Display for Literal {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            Literal::String { data, size } => {\n+            Literal::String { data, len } => {\n                 let slice =\n-                    unsafe { std::slice::from_raw_parts(*data, (*size).try_into().unwrap()) };\n+                    unsafe { std::slice::from_raw_parts(*data, (*len).try_into().unwrap()) };\n                 f.write_str(\"\\\"\")?;\n                 f.write_str(std::str::from_utf8(slice).unwrap())?;\n                 f.write_str(\"\\\"\")?;\n@@ -370,7 +370,13 @@ impl FromStr for Literal {\n         let mut lit = Literal::Char(0);\n         // TODO: We might want to pass a LexError by reference to retrieve\n         // error information\n-        if unsafe { Literal__from_string(string.as_ptr(), &mut lit as *mut Literal) } {\n+        if unsafe {\n+            Literal__from_string(\n+                string.as_ptr(),\n+                string.len().try_into().unwrap(),\n+                &mut lit as *mut Literal,\n+            )\n+        } {\n             Err(LexError)\n         } else {\n             Ok(lit)"}, {"sha": "afd986f68f5f65774a82bf699aea8f6fedeb13e3", "filename": "librust/proc_macro/rust/bridge/token_stream.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1723455cea2d51630be79aceddcfc3ed8a4771/librust%2Fproc_macro%2Frust%2Fbridge%2Ftoken_stream.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1723455cea2d51630be79aceddcfc3ed8a4771/librust%2Fproc_macro%2Frust%2Fbridge%2Ftoken_stream.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/librust%2Fproc_macro%2Frust%2Fbridge%2Ftoken_stream.rs?ref=0f1723455cea2d51630be79aceddcfc3ed8a4771", "patch": "@@ -13,7 +13,7 @@ extern \"C\" {\n     fn TokenStream__new() -> TokenStream;\n     fn TokenStream__with_capacity(capacity: u64) -> TokenStream;\n     fn TokenStream__push(stream: *mut TokenStream, tree: TokenTree);\n-    fn TokenStream__from_string(str: *const c_uchar, ts: *mut TokenStream) -> bool;\n+    fn TokenStream__from_string(str: *const c_uchar, len: u64, ts: *mut TokenStream) -> bool;\n }\n \n // TODO: There surely is a better way to achieve this. I don't like this\n@@ -138,7 +138,13 @@ impl FromStr for TokenStream {\n     type Err = LexError;\n     fn from_str(string: &str) -> Result<Self, LexError> {\n         let mut ts = TokenStream::new();\n-        if unsafe { TokenStream__from_string(string.as_ptr(), &mut ts as *mut TokenStream) } {\n+        if unsafe {\n+            TokenStream__from_string(\n+                string.as_ptr(),\n+                string.len().try_into().unwrap(),\n+                &mut ts as *mut TokenStream,\n+            )\n+        } {\n             Err(LexError)\n         } else {\n             Ok(ts)"}]}