{"sha": "d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM3OGMwN2ViYmIwY2Y1OWU5ZWJkNGIyZjU5MTJiNmNhNmY5MGYxYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2014-05-27T19:54:46Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-05-27T19:54:46Z"}, "message": "fold-const.c (fold_comparison): Clean up and extend X +- C1 CMP C2 to X CMP C2 -+ C1 transformation to...\n\n\t* fold-const.c (fold_comparison): Clean up and extend X +- C1 CMP C2\n\tto X CMP C2 -+ C1 transformation to EQ_EXPR/NE_EXPR.\n\tAdd X - Y CMP 0 to X CMP Y transformation.\n\t(fold_binary_loc) <EQ_EXPR/NE_EXPR>: Remove same transformations.\n\nFrom-SVN: r210979", "tree": {"sha": "e6ac227a3d7680dd7465cbd862d98caa0511d604", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6ac227a3d7680dd7465cbd862d98caa0511d604"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c/comments", "author": null, "committer": null, "parents": [{"sha": "3ce6c715378c93b5ec390b5e8f0732fa93ad9fc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ce6c715378c93b5ec390b5e8f0732fa93ad9fc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ce6c715378c93b5ec390b5e8f0732fa93ad9fc8"}], "stats": {"total": 140, "additions": 83, "deletions": 57}, "files": [{"sha": "9b8621e767b64f539aa6319d69b356155368a710", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c", "patch": "@@ -1,3 +1,10 @@\n+2014-05-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* fold-const.c (fold_comparison): Clean up and extend X +- C1 CMP C2\n+\tto X CMP C2 -+ C1 transformation to EQ_EXPR/NE_EXPR.\n+\tAdd X - Y CMP 0 to X CMP Y transformation.\n+\t(fold_binary_loc) <EQ_EXPR/NE_EXPR>: Remove same transformations.\n+\n 2014-05-27  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* stmt.c (dump_case_nodes): Don't convert values to HOST_WIDE_INT"}, {"sha": "b3009340e3ec202058b0ae3c79added67058ac65", "filename": "gcc/fold-const.c", "status": "modified", "additions": 49, "deletions": 57, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c", "patch": "@@ -8904,6 +8904,7 @@ static tree\n fold_comparison (location_t loc, enum tree_code code, tree type,\n \t\t tree op0, tree op1)\n {\n+  const bool equality_code = (code == EQ_EXPR || code == NE_EXPR);\n   tree arg0, arg1, tem;\n \n   arg0 = op0;\n@@ -8920,28 +8921,24 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n   if (tree_swap_operands_p (arg0, arg1, true))\n     return fold_build2_loc (loc, swap_tree_comparison (code), type, op1, op0);\n \n-  /* Transform comparisons of the form X +- C1 CMP C2 to X CMP C2 +- C1.  */\n+  /* Transform comparisons of the form X +- C1 CMP C2 to X CMP C2 -+ C1.  */\n   if ((TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n-      && (TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n-\t  && !TREE_OVERFLOW (TREE_OPERAND (arg0, 1))\n-\t  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg1)))\n-      && (TREE_CODE (arg1) == INTEGER_CST\n-\t  && !TREE_OVERFLOW (arg1)))\n+      && (equality_code || TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg0)))\n+      && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n+      && !TREE_OVERFLOW (TREE_OPERAND (arg0, 1))\n+      && TREE_CODE (arg1) == INTEGER_CST\n+      && !TREE_OVERFLOW (arg1))\n     {\n+      const enum tree_code\n+\treverse_op = TREE_CODE (arg0) == PLUS_EXPR ? MINUS_EXPR : PLUS_EXPR;\n       tree const1 = TREE_OPERAND (arg0, 1);\n-      tree const2 = arg1;\n+      tree const2 = fold_convert_loc (loc, TREE_TYPE (const1), arg1);\n       tree variable = TREE_OPERAND (arg0, 0);\n-      tree lhs;\n-      int lhs_add;\n-      lhs_add = TREE_CODE (arg0) != PLUS_EXPR;\n-\n-      lhs = fold_build2_loc (loc, lhs_add ? PLUS_EXPR : MINUS_EXPR,\n-\t\t\t TREE_TYPE (arg1), const2, const1);\n+      tree new_const = int_const_binop (reverse_op, const2, const1);\n \n       /* If the constant operation overflowed this can be\n \t simplified as a comparison against INT_MAX/INT_MIN.  */\n-      if (TREE_CODE (lhs) == INTEGER_CST\n-\t  && TREE_OVERFLOW (lhs))\n+      if (TREE_OVERFLOW (new_const))\n \t{\n \t  int const1_sgn = tree_int_cst_sgn (const1);\n \t  enum tree_code code2 = code;\n@@ -8961,29 +8958,48 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t  /* We now can look at the canonicalized case\n \t       VARIABLE + 1  CODE2  INT_MIN\n \t     and decide on the result.  */\n-\t  if (code2 == LT_EXPR\n-\t      || code2 == LE_EXPR\n-\t      || code2 == EQ_EXPR)\n-\t    return omit_one_operand_loc (loc, type, boolean_false_node, variable);\n-\t  else if (code2 == NE_EXPR\n-\t\t   || code2 == GE_EXPR\n-\t\t   || code2 == GT_EXPR)\n-\t    return omit_one_operand_loc (loc, type, boolean_true_node, variable);\n-\t}\n+\t  switch (code2)\n+\t    {\n+\t    case EQ_EXPR:\n+\t    case LT_EXPR:\n+\t    case LE_EXPR:\n+\t      return\n+\t\tomit_one_operand_loc (loc, type, boolean_false_node, variable);\n+\n+\t    case NE_EXPR:\n+\t    case GE_EXPR:\n+\t    case GT_EXPR:\n+\t      return\n+\t\tomit_one_operand_loc (loc, type, boolean_true_node, variable);\n \n-      if (TREE_CODE (lhs) == TREE_CODE (arg1)\n-\t  && (TREE_CODE (lhs) != INTEGER_CST\n-\t      || !TREE_OVERFLOW (lhs)))\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n+      else\n \t{\n-\t  if (code != EQ_EXPR && code != NE_EXPR)\n+\t  if (!equality_code)\n \t    fold_overflow_warning (\"assuming signed overflow does not occur \"\n \t\t\t\t   \"when changing X +- C1 cmp C2 to \"\n-\t\t\t\t   \"X cmp C1 +- C2\",\n+\t\t\t\t   \"X cmp C2 -+ C1\",\n \t\t\t\t   WARN_STRICT_OVERFLOW_COMPARISON);\n-\t  return fold_build2_loc (loc, code, type, variable, lhs);\n+\t  return fold_build2_loc (loc, code, type, variable, new_const);\n \t}\n     }\n \n+  /* Transform comparisons of the form X - Y CMP 0 to X CMP Y.  */\n+  if (TREE_CODE (arg0) == MINUS_EXPR\n+      && (equality_code || TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg0)))\n+      && integer_zerop (arg1))\n+    {\n+      if (!equality_code)\n+\tfold_overflow_warning (\"assuming signed overflow does not occur \"\n+\t\t\t       \"when changing X - Y cmp 0 to X cmp Y\",\n+\t\t\t       WARN_STRICT_OVERFLOW_COMPARISON);\n+      return fold_build2_loc (loc, code, type, TREE_OPERAND (arg0, 0),\n+\t\t\t      TREE_OPERAND (arg0, 1));\n+    }\n+\n   /* For comparisons of pointers we can decompose it to a compile time\n      comparison of the base objects and the offsets into the object.\n      This requires at least one operand being an ADDR_EXPR or a\n@@ -9111,8 +9127,7 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t\t  || POINTER_TYPE_OVERFLOW_UNDEFINED))\n \n \t    {\n-\t      if (code != EQ_EXPR\n-\t\t  && code != NE_EXPR\n+\t      if (!equality_code\n \t\t  && bitpos0 != bitpos1\n \t\t  && (pointer_may_wrap_p (base0, offset0, bitpos0)\n \t\t      || pointer_may_wrap_p (base1, offset1, bitpos1)))\n@@ -9146,7 +9161,7 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t     object and overflow on pointer differences is undefined as of\n \t     6.5.6/8 and /9 with respect to the signed ptrdiff_t.  */\n \t  else if (bitpos0 == bitpos1\n-\t\t   && ((code == EQ_EXPR || code == NE_EXPR)\n+\t\t   && (equality_code\n \t\t       || (indirect_base0 && DECL_P (base0))\n \t\t       || POINTER_TYPE_OVERFLOW_UNDEFINED))\n \t    {\n@@ -9164,8 +9179,7 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t      else\n \t\toffset1 = fold_convert_loc (loc, ssizetype, offset1);\n \n-\t      if (code != EQ_EXPR\n-\t\t  && code != NE_EXPR\n+\t      if (!equality_code\n \t\t  && (pointer_may_wrap_p (base0, offset0, bitpos0)\n \t\t      || pointer_may_wrap_p (base1, offset1, bitpos1)))\n \t\tfold_overflow_warning ((\"assuming pointer wraparound does not \"\n@@ -12888,21 +12902,6 @@ fold_binary_loc (location_t loc,\n \t\t\t\t        type);\n \t}\n \n-      /* If this is an EQ or NE comparison of a constant with a PLUS_EXPR or\n-\t a MINUS_EXPR of a constant, we can convert it into a comparison with\n-\t a revised constant as long as no overflow occurs.  */\n-      if (TREE_CODE (arg1) == INTEGER_CST\n-\t  && (TREE_CODE (arg0) == PLUS_EXPR\n-\t      || TREE_CODE (arg0) == MINUS_EXPR)\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n-\t  && 0 != (tem = const_binop (TREE_CODE (arg0) == PLUS_EXPR\n-\t\t\t\t      ? MINUS_EXPR : PLUS_EXPR,\n-\t\t\t\t      fold_convert_loc (loc, TREE_TYPE (arg0),\n-\t\t\t\t\t\t\targ1),\n-\t\t\t\t      TREE_OPERAND (arg0, 1)))\n-\t  && !TREE_OVERFLOW (tem))\n-\treturn fold_build2_loc (loc, code, type, TREE_OPERAND (arg0, 0), tem);\n-\n       /* Similarly for a NEGATE_EXPR.  */\n       if (TREE_CODE (arg0) == NEGATE_EXPR\n \t  && TREE_CODE (arg1) == INTEGER_CST\n@@ -12956,13 +12955,6 @@ fold_binary_loc (location_t loc,\n \t\t\t\t    TREE_OPERAND (arg0, 1), arg1);\n \t}\n \n-      /* If we have X - Y == 0, we can convert that to X == Y and similarly\n-\t for !=.  Don't do this for ordered comparisons due to overflow.  */\n-      if (TREE_CODE (arg0) == MINUS_EXPR\n-\t  && integer_zerop (arg1))\n-\treturn fold_build2_loc (loc, code, type,\n-\t\t\t    TREE_OPERAND (arg0, 0), TREE_OPERAND (arg0, 1));\n-\n       /* Convert ABS_EXPR<x> == 0 or ABS_EXPR<x> != 0 to x == 0 or x != 0.  */\n       if (TREE_CODE (arg0) == ABS_EXPR\n \t  && (integer_zerop (arg1) || real_zerop (arg1)))"}, {"sha": "e1e70c1b2673e013b60b20bba93af76915f1aee4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c", "patch": "@@ -1,3 +1,8 @@\n+2014-05-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.dg/fold-compare-8.c: New test.\n+\t* gcc.dg/Wstrict-overflow-25.c: Likewise.\n+\n 2014-05-27  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.dg/tree-ssa/vrp92.c: New testcase."}, {"sha": "00916446371a7399be5ae0807ad4b9113b017b62", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-25.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-25.c?ref=d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-overflow -O2 -Wstrict-overflow=3\" } */\n+\n+/* We can only simplify the conditional when using strict overflow\n+   semantics.  */\n+\n+int\n+foo (int x, int y)\n+{\n+  return x - y < 0; /* { dg-warning \"assuming signed overflow does not occur\" \"correct warning\" } */\n+}"}, {"sha": "b6e42fdef108ad5e8d99d47d5d52a58f603144a5", "filename": "gcc/testsuite/gcc.dg/fold-compare-8.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-compare-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-compare-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-compare-8.c?ref=d378c07ebbb0cf59e9ebd4b2f5912b6ca6f90f1c", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-original\" } */\n+\n+int\n+foo (int x, int y)\n+{\n+  return x - y < 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"x < y\" \"original\" } } */\n+/* { dg-final { cleanup-tree-dump \"original\" } } */"}]}