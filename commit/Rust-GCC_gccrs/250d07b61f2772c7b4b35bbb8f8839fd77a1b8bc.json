{"sha": "250d07b61f2772c7b4b35bbb8f8839fd77a1b8bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjUwZDA3YjYxZjI3NzJjN2I0YjM1YmJiOGY4ODM5ZmQ3N2ExYjhiYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2000-12-03T23:58:44Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-12-03T23:58:44Z"}, "message": "bb-reorder.c (reorder_basic_blocks): Don't check for EH edges unless exception handling is enabled...\n\n        * bb-reorder.c (reorder_basic_blocks): Don't check for EH edges\n        unless exception handling is enabled, and if not using sjlj.\n\n        * builtins.c (expand_builtin_setjmp_setup): New.\n        (expand_builtin_setjmp_receiver): New.\n        (expand_builtin_setjmp): Split out _setup and _receiver functions.\n        Move argument parsing in from ...\n        (expand_builtin): ... here.\n        * except.c (receive_exception_label): Branch around receiver\n        unless new-style exceptions.  Call expand_builtin_setjmp_receiver.\n        (start_dynamic_handler): Call expand_builtin_setjmp_setup.\n        * expr.h: Update builtin setjmp decls.\n\nFrom-SVN: r37982", "tree": {"sha": "0c8d554434d79763f71c942c0611cca67f9922f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c8d554434d79763f71c942c0611cca67f9922f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/250d07b61f2772c7b4b35bbb8f8839fd77a1b8bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/250d07b61f2772c7b4b35bbb8f8839fd77a1b8bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/250d07b61f2772c7b4b35bbb8f8839fd77a1b8bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/250d07b61f2772c7b4b35bbb8f8839fd77a1b8bc/comments", "author": null, "committer": null, "parents": [{"sha": "2702080f01f7aa733242b804de2d11f202b34276", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2702080f01f7aa733242b804de2d11f202b34276", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2702080f01f7aa733242b804de2d11f202b34276"}], "stats": {"total": 228, "additions": 143, "deletions": 85}, "files": [{"sha": "73ddb4cb55c2271637974277a3068075d0151cca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/250d07b61f2772c7b4b35bbb8f8839fd77a1b8bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/250d07b61f2772c7b4b35bbb8f8839fd77a1b8bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=250d07b61f2772c7b4b35bbb8f8839fd77a1b8bc", "patch": "@@ -1,3 +1,18 @@\n+2000-12-03  Richard Henderson  <rth@redhat.com>\n+\n+\t* bb-reorder.c (reorder_basic_blocks): Don't check for EH edges\n+\tunless exception handling is enabled, and if not using sjlj.\n+\n+\t* builtins.c (expand_builtin_setjmp_setup): New.\n+\t(expand_builtin_setjmp_receiver): New.\n+\t(expand_builtin_setjmp): Split out _setup and _receiver functions.\n+\tMove argument parsing in from ...\n+\t(expand_builtin): ... here.\n+\t* except.c (receive_exception_label): Branch around receiver\n+\tunless new-style exceptions.  Call expand_builtin_setjmp_receiver.\n+\t(start_dynamic_handler): Call expand_builtin_setjmp_setup.\n+\t* expr.h: Update builtin setjmp decls.\n+\n 2000-12-03  Bruce Korb  <bkorb@gcc.org>\n \n \t* fixinc/mkfixinc.sh(build machine): Sometimes, there is no canonical"}, {"sha": "45b5f2f680c482326934b828a14a821c55960606", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/250d07b61f2772c7b4b35bbb8f8839fd77a1b8bc/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/250d07b61f2772c7b4b35bbb8f8839fd77a1b8bc/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=250d07b61f2772c7b4b35bbb8f8839fd77a1b8bc", "patch": "@@ -1346,14 +1346,16 @@ reorder_basic_blocks ()\n   if (n_basic_blocks <= 1)\n     return;\n \n-  /* We do not currently handle correct re-placement of EH notes.  */\n-  for (i = 0; i < n_basic_blocks; i++)\n-    {\n-      edge e;\n-      for (e = BASIC_BLOCK (i)->succ; e ; e = e->succ_next)\n-        if (e->flags & EDGE_EH)\n-\t  return;\n-    }\n+  /* We do not currently handle correct re-placement of EH notes.\n+     But that does not matter unless we intend to use them.  */\n+  if (flag_exceptions && ! exceptions_via_longjmp)\n+    for (i = 0; i < n_basic_blocks; i++)\n+      {\n+\tedge e;\n+\tfor (e = BASIC_BLOCK (i)->succ; e ; e = e->succ_next)\n+\t  if (e->flags & EDGE_EH)\n+\t    return;\n+      }\n \n   for (i = 0; i < n_basic_blocks; i++)\n     BASIC_BLOCK (i)->aux = xcalloc (1, sizeof (struct reorder_block_def));"}, {"sha": "1d8e5e24dbd96e613d112ab22bba72cf78c746dd", "filename": "gcc/builtins.c", "status": "modified", "additions": 78, "deletions": 57, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/250d07b61f2772c7b4b35bbb8f8839fd77a1b8bc/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/250d07b61f2772c7b4b35bbb8f8839fd77a1b8bc/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=250d07b61f2772c7b4b35bbb8f8839fd77a1b8bc", "patch": "@@ -90,6 +90,7 @@ static int apply_result_size\t\tPARAMS ((void));\n #if defined (HAVE_untyped_call) || defined (HAVE_untyped_return)\n static rtx result_vector\t\tPARAMS ((int, rtx));\n #endif\n+static rtx expand_builtin_setjmp\tPARAMS ((tree, rtx));\n static rtx expand_builtin_apply_args\tPARAMS ((void));\n static rtx expand_builtin_apply_args_1\tPARAMS ((void));\n static rtx expand_builtin_apply\t\tPARAMS ((rtx, rtx, rtx));\n@@ -453,30 +454,19 @@ expand_builtin_return_addr (fndecl_code, count, tem)\n /* Alias set used for setjmp buffer.  */\n static HOST_WIDE_INT setjmp_alias_set = -1;\n \n-/* __builtin_setjmp is passed a pointer to an array of five words (not\n-   all will be used on all machines).  It operates similarly to the C\n-   library function of the same name, but is more efficient.  Much of\n-   the code below (and for longjmp) is copied from the handling of\n-   non-local gotos.\n+/* Construct the leading half of a __builtin_setjmp call.  Control will\n+   return to RECEIVER_LABEL.  This is used directly by sjlj exception\n+   handling code.  */\n \n-   NOTE: This is intended for use by GNAT and the exception handling\n-   scheme in the compiler and will only work in the method used by\n-   them.  */\n-\n-rtx\n-expand_builtin_setjmp (buf_addr, target, first_label, next_label)\n+void\n+expand_builtin_setjmp_setup (buf_addr, receiver_label)\n      rtx buf_addr;\n-     rtx target;\n-     rtx first_label, next_label;\n+     rtx receiver_label;\n {\n-  rtx lab1 = gen_label_rtx ();\n   enum machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n-  enum machine_mode value_mode;\n   rtx stack_save;\n   rtx mem;\n \n-  value_mode = TYPE_MODE (integer_type_node);\n-\n   if (setjmp_alias_set == -1)\n     setjmp_alias_set = new_alias_set ();\n \n@@ -486,15 +476,11 @@ expand_builtin_setjmp (buf_addr, target, first_label, next_label)\n \n   buf_addr = force_reg (Pmode, force_operand (buf_addr, NULL_RTX));\n \n-  if (target == 0 || GET_CODE (target) != REG\n-      || REGNO (target) < FIRST_PSEUDO_REGISTER)\n-    target = gen_reg_rtx (value_mode);\n-\n   emit_queue ();\n \n-  /* We store the frame pointer and the address of lab1 in the buffer\n-     and use the rest of it for the stack save area, which is\n-     machine-dependent.  */\n+  /* We store the frame pointer and the address of receiver_label in\n+     the buffer and use the rest of it for the stack save area, which\n+     is machine-dependent.  */\n \n #ifndef BUILTIN_SETJMP_FRAME_VALUE\n #define BUILTIN_SETJMP_FRAME_VALUE virtual_stack_vars_rtx\n@@ -508,7 +494,7 @@ expand_builtin_setjmp (buf_addr, target, first_label, next_label)\n   MEM_ALIAS_SET (mem) = setjmp_alias_set;\n \n   emit_move_insn (validize_mem (mem),\n-\t\t  force_reg (Pmode, gen_rtx_LABEL_REF (Pmode, lab1)));\n+\t\t  force_reg (Pmode, gen_rtx_LABEL_REF (Pmode, receiver_label)));\n \n   stack_save = gen_rtx_MEM (sa_mode,\n \t\t\t    plus_constant (buf_addr,\n@@ -522,21 +508,18 @@ expand_builtin_setjmp (buf_addr, target, first_label, next_label)\n     emit_insn (gen_builtin_setjmp_setup (buf_addr));\n #endif\n \n-  /* Set TARGET to zero and branch to the first-time-through label.  */\n-  emit_move_insn (target, const0_rtx);\n-  emit_jump_insn (gen_jump (first_label));\n-  emit_barrier ();\n-  emit_label (lab1);\n-\n-  /* Tell flow about the strange goings on.  Putting `lab1' on\n-     `nonlocal_goto_handler_labels' to indicates that function\n-     calls may traverse the arc back to this label.  */\n-\n-  current_function_has_nonlocal_label = 1;\n+  /* Tell optimize_save_area_alloca that extra work is going to\n+     need to go on during alloca.  */\n   current_function_calls_setjmp = 1;\n-  nonlocal_goto_handler_labels\n-    = gen_rtx_EXPR_LIST (VOIDmode, lab1, nonlocal_goto_handler_labels);\n+}\n \n+/* Construct the trailing part of a __builtin_setjmp call.\n+   This is used directly by sjlj exception handling code.  */\n+\n+void\n+expand_builtin_setjmp_receiver (receiver_label)\n+      rtx receiver_label ATTRIBUTE_UNUSED;\n+{\n   /* Clobber the FP when we get here, so we have to make sure it's\n      marked as used by this function.  */\n   emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));\n@@ -583,22 +566,68 @@ expand_builtin_setjmp (buf_addr, target, first_label, next_label)\n \n #ifdef HAVE_builtin_setjmp_receiver\n   if (HAVE_builtin_setjmp_receiver)\n-    emit_insn (gen_builtin_setjmp_receiver (lab1));\n+    emit_insn (gen_builtin_setjmp_receiver (receiver_label));\n   else\n #endif\n #ifdef HAVE_nonlocal_goto_receiver\n     if (HAVE_nonlocal_goto_receiver)\n       emit_insn (gen_nonlocal_goto_receiver ());\n     else\n #endif\n-      {\n-\t; /* Nothing */\n-      }\n+      { /* Nothing */ }\n+}\n \n-  /* Set TARGET, and branch to the next-time-through label.  */\n-  emit_move_insn (target, const1_rtx);\n-  emit_jump_insn (gen_jump (next_label));\n+/* __builtin_setjmp is passed a pointer to an array of five words (not\n+   all will be used on all machines).  It operates similarly to the C\n+   library function of the same name, but is more efficient.  Much of\n+   the code below (and for longjmp) is copied from the handling of\n+   non-local gotos.\n+\n+   NOTE: This is intended for use by GNAT and the exception handling\n+   scheme in the compiler and will only work in the method used by\n+   them.  */\n+\n+static rtx\n+expand_builtin_setjmp (arglist, target)\n+     tree arglist;\n+     rtx target;\n+{\n+  rtx buf_addr, next_lab, cont_lab;\n+\n+  if (arglist == 0\n+      || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)\n+    return NULL_RTX;\n+\n+  if (target == 0 || GET_CODE (target) != REG\n+      || REGNO (target) < FIRST_PSEUDO_REGISTER)\n+    target = gen_reg_rtx (TYPE_MODE (integer_type_node));\n+\n+  buf_addr = expand_expr (TREE_VALUE (arglist), NULL_RTX, VOIDmode, 0);\n+\n+  next_lab = gen_label_rtx ();\n+  cont_lab = gen_label_rtx ();\n+\n+  expand_builtin_setjmp_setup (buf_addr, next_lab);\n+\n+  /* Set TARGET to zero and branch to the continue label.  */\n+  emit_move_insn (target, const0_rtx);\n+  emit_jump_insn (gen_jump (cont_lab));\n   emit_barrier ();\n+  emit_label (next_lab);\n+\n+  expand_builtin_setjmp_receiver (next_lab);\n+\n+  /* Set TARGET to one.  */\n+  emit_move_insn (target, const1_rtx);\n+  emit_label (cont_lab);\n+\n+  /* Tell flow about the strange goings on.  Putting `next_lab' on\n+     `nonlocal_goto_handler_labels' to indicates that function\n+     calls may traverse the arc back to this label.  */\n+\n+  current_function_has_nonlocal_label = 1;\n+  nonlocal_goto_handler_labels\n+    = gen_rtx_EXPR_LIST (VOIDmode, next_lab, nonlocal_goto_handler_labels);\n \n   return target;\n }\n@@ -3569,18 +3598,10 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n #endif\n \n     case BUILT_IN_SETJMP:\n-      if (arglist == 0\n-\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)\n-\tbreak;\n-      else\n-\t{\n-\t  rtx buf_addr = expand_expr (TREE_VALUE (arglist), subtarget,\n-\t\t\t\t      VOIDmode, 0);\n-\t  rtx lab = gen_label_rtx ();\n-\t  rtx ret = expand_builtin_setjmp (buf_addr, target, lab, lab);\n-\t  emit_label (lab);\n-\t  return ret;\n-\t}\n+      target = expand_builtin_setjmp (arglist, target);\n+      if (target)\n+\treturn target;\n+      break;\n \n       /* __builtin_longjmp is passed a pointer to an array of five words.\n \t It's similar to the C library longjmp function but works with"}, {"sha": "c1dd0cbbe326c65de2540e16bd2397da5255270d", "filename": "gcc/except.c", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/250d07b61f2772c7b4b35bbb8f8839fd77a1b8bc/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/250d07b61f2772c7b4b35bbb8f8839fd77a1b8bc/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=250d07b61f2772c7b4b35bbb8f8839fd77a1b8bc", "patch": "@@ -672,19 +672,40 @@ static void\n receive_exception_label (handler_label)\n      rtx handler_label;\n {\n+  rtx around_label = NULL_RTX;\n+\n+  if (! flag_new_exceptions || exceptions_via_longjmp)\n+    {\n+      around_label = gen_label_rtx ();\n+      emit_jump (around_label);\n+      emit_barrier ();\n+    }\n+\n   emit_label (handler_label);\n   \n-#ifdef HAVE_exception_receiver\n   if (! exceptions_via_longjmp)\n-    if (HAVE_exception_receiver)\n-      emit_insn (gen_exception_receiver ());\n+    {\n+#ifdef HAVE_exception_receiver\n+      if (HAVE_exception_receiver)\n+\temit_insn (gen_exception_receiver ());\n+      else\n #endif\n-\n #ifdef HAVE_nonlocal_goto_receiver\n-  if (! exceptions_via_longjmp)\n-    if (HAVE_nonlocal_goto_receiver)\n-      emit_insn (gen_nonlocal_goto_receiver ());\n+      if (HAVE_nonlocal_goto_receiver)\n+\temit_insn (gen_nonlocal_goto_receiver ());\n+      else\n #endif\n+\t{ /* Nothing */ }\n+    }\n+  else\n+    {\n+#ifndef DONT_USE_BUILTIN_SETJMP\n+      expand_builtin_setjmp_receiver (handler_label);\n+#endif\n+    }\n+\n+  if (around_label)\n+    emit_label (around_label);\n }\n \n \n@@ -1304,7 +1325,7 @@ static void\n start_dynamic_handler ()\n {\n   rtx dhc, dcc;\n-  rtx x, arg, buf;\n+  rtx arg, buf;\n   int size;\n \n #ifndef DONT_USE_BUILTIN_SETJMP\n@@ -1351,19 +1372,17 @@ start_dynamic_handler ()\n   buf = plus_constant (XEXP (arg, 0), GET_MODE_SIZE (Pmode)*2);\n \n #ifdef DONT_USE_BUILTIN_SETJMP\n-  x = emit_library_call_value (setjmp_libfunc, NULL_RTX, LCT_CONST,\n-\t\t\t       TYPE_MODE (integer_type_node), 1,\n-\t\t\t       buf, Pmode);\n-  /* If we come back here for a catch, transfer control to the handler.  */\n-  jumpif_rtx (x, ehstack.top->entry->exception_handler_label);\n-#else\n   {\n-    /* A label to continue execution for the no exception case.  */\n-    rtx noex = gen_label_rtx();\n-    x = expand_builtin_setjmp (buf, NULL_RTX, noex,\n-\t\t\t       ehstack.top->entry->exception_handler_label);\n-    emit_label (noex);\n+    rtx x;\n+    x = emit_library_call_value (setjmp_libfunc, NULL_RTX, LCT_CONST,\n+\t\t\t         TYPE_MODE (integer_type_node), 1,\n+\t\t\t         buf, Pmode);\n+    /* If we come back here for a catch, transfer control to the handler.  */\n+    jumpif_rtx (x, ehstack.top->entry->exception_handler_label);\n   }\n+#else\n+  expand_builtin_setjmp_setup (buf,\n+\t\t\t       ehstack.top->entry->exception_handler_label);\n #endif\n \n   /* We are committed to this, so update the handler chain.  */"}, {"sha": "eea9b97f08aed5ae3bf2dd1f1e540d7c7a9c012c", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/250d07b61f2772c7b4b35bbb8f8839fd77a1b8bc/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/250d07b61f2772c7b4b35bbb8f8839fd77a1b8bc/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=250d07b61f2772c7b4b35bbb8f8839fd77a1b8bc", "patch": "@@ -924,7 +924,8 @@ extern rtx std_expand_builtin_va_arg PARAMS ((tree, tree));\n extern rtx expand_builtin_va_arg PARAMS ((tree, tree));\n #endif\n \n-extern rtx expand_builtin_setjmp PARAMS ((rtx, rtx, rtx, rtx));\n+extern void expand_builtin_setjmp_setup PARAMS ((rtx, rtx));\n+extern void expand_builtin_setjmp_receiver PARAMS ((rtx));\n extern void expand_builtin_longjmp PARAMS ((rtx, rtx));\n extern rtx expand_builtin_saveregs PARAMS ((void));\n extern HOST_WIDE_INT get_varargs_alias_set PARAMS ((void));"}]}