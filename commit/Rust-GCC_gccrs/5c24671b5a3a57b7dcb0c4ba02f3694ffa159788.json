{"sha": "5c24671b5a3a57b7dcb0c4ba02f3694ffa159788", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWMyNDY3MWI1YTNhNTdiN2RjYjBjNGJhMDJmMzY5NGZmYTE1OTc4OA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2011-04-29T05:22:08Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2011-04-29T05:22:08Z"}, "message": "haifa-sched.c (last_nondebug_scheduled_insn): New.\n\n* haifa-sched.c (last_nondebug_scheduled_insn): New.\n(rank_for_schedule): Use it.\n(schedule_block): Set it.\n\nFrom-SVN: r173150", "tree": {"sha": "79aca66fe5097fb58683c48d9aaf427a14f84fec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79aca66fe5097fb58683c48d9aaf427a14f84fec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c24671b5a3a57b7dcb0c4ba02f3694ffa159788", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c24671b5a3a57b7dcb0c4ba02f3694ffa159788", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c24671b5a3a57b7dcb0c4ba02f3694ffa159788", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c24671b5a3a57b7dcb0c4ba02f3694ffa159788/comments", "author": null, "committer": null, "parents": [{"sha": "10adac5108a971b2e4949508728251e587450595", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10adac5108a971b2e4949508728251e587450595", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10adac5108a971b2e4949508728251e587450595"}], "stats": {"total": 32, "additions": 17, "deletions": 15}, "files": [{"sha": "5bb003794073ad1ceed66329309045c96f5dcc47", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c24671b5a3a57b7dcb0c4ba02f3694ffa159788/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c24671b5a3a57b7dcb0c4ba02f3694ffa159788/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5c24671b5a3a57b7dcb0c4ba02f3694ffa159788", "patch": "@@ -1,3 +1,9 @@\n+2011-04-29  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* haifa-sched.c (last_nondebug_scheduled_insn): New.\n+\t(rank_for_schedule): Use it.\n+\t(schedule_block): Set it.\n+\n 2011-04-28  David Li  <davidxl@google.com>\n \n \t* tree.c (crc32_string): Use crc32_byte."}, {"sha": "15d8f65375f8d1e4fac971dd3095004dd4e3bdef", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c24671b5a3a57b7dcb0c4ba02f3694ffa159788/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c24671b5a3a57b7dcb0c4ba02f3694ffa159788/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=5c24671b5a3a57b7dcb0c4ba02f3694ffa159788", "patch": "@@ -783,6 +783,12 @@ print_curr_reg_pressure (void)\n /* Pointer to the last instruction scheduled.  */\n static rtx last_scheduled_insn;\n \n+/* Pointer to the last nondebug instruction scheduled within the\n+   block, or the prev_head of the scheduling block.  Used by\n+   rank_for_schedule, so that insns independent of the last scheduled\n+   insn will be preferred over dependent instructions.  */\n+static rtx last_nondebug_scheduled_insn;\n+\n /* Pointer that iterates through the list of unscheduled insns if we\n    have a dbg_cnt enabled.  It always points at an insn prior to the\n    first unscheduled one.  */\n@@ -1158,7 +1164,6 @@ rank_for_schedule (const void *x, const void *y)\n {\n   rtx tmp = *(const rtx *) y;\n   rtx tmp2 = *(const rtx *) x;\n-  rtx last;\n   int tmp_class, tmp2_class;\n   int val, priority_val, info_val;\n \n@@ -1239,24 +1244,13 @@ rank_for_schedule (const void *x, const void *y)\n   if(flag_sched_rank_heuristic && info_val)\n     return info_val;\n \n-  if (flag_sched_last_insn_heuristic)\n-    {\n-      int i = VEC_length (rtx, scheduled_insns);\n-      last = NULL_RTX;\n-      while (i-- > 0)\n-\t{\n-\t  last = VEC_index (rtx, scheduled_insns, i);\n-\t  if (NONDEBUG_INSN_P (last))\n-\t    break;\n-\t}\n-    }\n-\n   /* Compare insns based on their relation to the last scheduled\n      non-debug insn.  */\n-  if (flag_sched_last_insn_heuristic && last && NONDEBUG_INSN_P (last))\n+  if (flag_sched_last_insn_heuristic && last_nondebug_scheduled_insn)\n     {\n       dep_t dep1;\n       dep_t dep2;\n+      rtx last = last_nondebug_scheduled_insn;\n \n       /* Classify the instructions into three classes:\n          1) Data dependent on last schedule insn.\n@@ -2967,6 +2961,7 @@ schedule_block (basic_block *target_bb)\n \n   /* We start inserting insns after PREV_HEAD.  */\n   last_scheduled_insn = nonscheduled_insns_begin = prev_head;\n+  last_nondebug_scheduled_insn = NULL_RTX;\n \n   gcc_assert ((NOTE_P (last_scheduled_insn)\n \t       || DEBUG_INSN_P (last_scheduled_insn))\n@@ -3226,7 +3221,8 @@ schedule_block (basic_block *target_bb)\n \t  /* Update counters, etc in the scheduler's front end.  */\n \t  (*current_sched_info->begin_schedule_ready) (insn);\n \t  VEC_safe_push (rtx, heap, scheduled_insns, insn);\n-\t  last_scheduled_insn = insn;\n+\t  gcc_assert (NONDEBUG_INSN_P (insn));\n+\t  last_nondebug_scheduled_insn = last_scheduled_insn = insn;\n \n \t  if (recog_memoized (insn) >= 0)\n \t    {"}]}