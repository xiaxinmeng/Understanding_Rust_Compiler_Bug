{"sha": "2c088b53f9633f073f02656eba0033c68ab65f31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMwODhiNTNmOTYzM2YwNzNmMDI2NTZlYmEwMDMzYzY4YWI2NWYzMQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.co.uk", "date": "2002-06-24T05:46:51Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-06-24T05:46:51Z"}, "message": "cpptrad.c (scan_out_logical_line): Check recursing only when we know we have a macro invocation in the...\n\n\t* cpptrad.c (scan_out_logical_line): Check recursing only when\n\twe know we have a macro invocation in the function-like case.\n\tOnly call _cpp_handle_directive if we know we have a good\n\tdirective, or we want to reject a bad directive.\ntestsuite:\n\t* gcc.dg/cpp/trad/argcout.c, gcc.dg/cpp/trad/assembler.S,\n\tgcc.dg/cpp/trad/argcout.c, gcc.dg/cpp/trad/funlike-4.c,\n\tgcc.dg/cpp/trad/null-drctv.c, gcc.dg/cpp/trad/recurse-1.c,\n\tgcc.dg/cpp/trad/recurse-2.c, gcc.dg/cpp/trad/recurse-3.c:\n\tNew tests.\n\t* gcc.dg/cpp/trad/directive.c: Update.\n\nFrom-SVN: r54942", "tree": {"sha": "fcd033733bfffcb7d0c08d9fe7bd14f21ee3f9c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fcd033733bfffcb7d0c08d9fe7bd14f21ee3f9c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c088b53f9633f073f02656eba0033c68ab65f31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c088b53f9633f073f02656eba0033c68ab65f31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c088b53f9633f073f02656eba0033c68ab65f31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c088b53f9633f073f02656eba0033c68ab65f31/comments", "author": {"login": "neilb-xx", "id": 160762, "node_id": "MDQ6VXNlcjE2MDc2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/160762?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neilb-xx", "html_url": "https://github.com/neilb-xx", "followers_url": "https://api.github.com/users/neilb-xx/followers", "following_url": "https://api.github.com/users/neilb-xx/following{/other_user}", "gists_url": "https://api.github.com/users/neilb-xx/gists{/gist_id}", "starred_url": "https://api.github.com/users/neilb-xx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neilb-xx/subscriptions", "organizations_url": "https://api.github.com/users/neilb-xx/orgs", "repos_url": "https://api.github.com/users/neilb-xx/repos", "events_url": "https://api.github.com/users/neilb-xx/events{/privacy}", "received_events_url": "https://api.github.com/users/neilb-xx/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "66443ad2fda37477c32f6230d9d784717e167b9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66443ad2fda37477c32f6230d9d784717e167b9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66443ad2fda37477c32f6230d9d784717e167b9a"}], "stats": {"total": 196, "additions": 183, "deletions": 13}, "files": [{"sha": "717dcb0858109a8565871f42fecc32244b27afc5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c088b53f9633f073f02656eba0033c68ab65f31/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c088b53f9633f073f02656eba0033c68ab65f31/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c088b53f9633f073f02656eba0033c68ab65f31", "patch": "@@ -1,3 +1,10 @@\n+2002-06-24  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* cpptrad.c (scan_out_logical_line): Check recursing only when\n+\twe know we have a macro invocation in the function-like case.\n+\tOnly call _cpp_handle_directive if we know we have a good\n+\tdirective, or we want to reject a bad directive.\n+\n 2002-06-24  Alan Modra  <amodra@bigpond.net.au>\n \n \t* doloop.c (doloop_valid_p): Correct comment."}, {"sha": "7ae8819f028c809a9f64460cec395677763a53b7", "filename": "gcc/cpptrad.c", "status": "modified", "additions": 45, "deletions": 13, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c088b53f9633f073f02656eba0033c68ab65f31/gcc%2Fcpptrad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c088b53f9633f073f02656eba0033c68ab65f31/gcc%2Fcpptrad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpptrad.c?ref=2c088b53f9633f073f02656eba0033c68ab65f31", "patch": "@@ -579,8 +579,7 @@ scan_out_logical_line (pfile, macro)\n \t      if (node->type == NT_MACRO\n \t\t  /* Should we expand for ls_answer?  */\n \t\t  && (lex_state == ls_none || lex_state == ls_fun_open)\n-\t\t  && !pfile->state.prevent_expansion\n-\t\t  && !recursive_macro (pfile, node))\n+\t\t  && !pfile->state.prevent_expansion)\n \t\t{\n \t\t  /* Macros invalidate MI optimization.  */\n \t\t  pfile->mi_valid = false;\n@@ -592,7 +591,7 @@ scan_out_logical_line (pfile, macro)\n \t\t      fmacro.line = pfile->line;\n \t\t      continue;\n \t\t    }\n-\t\t  else\n+\t\t  else if (!recursive_macro (pfile, node))\n \t\t    {\n \t\t      /* Remove the object-like macro's name from the\n \t\t\t output, and push its replacement text.  */\n@@ -630,10 +629,15 @@ scan_out_logical_line (pfile, macro)\n \t      paren_depth++;\n \t      if (lex_state == ls_fun_open)\n \t\t{\n-\t\t  lex_state = ls_fun_close;\n-\t\t  paren_depth = 1;\n-\t\t  out = pfile->out.base + fmacro.offset;\n-\t\t  fmacro.args[0] = fmacro.offset;\n+\t\t  if (recursive_macro (pfile, fmacro.node))\n+\t\t    lex_state = ls_none;\n+\t\t  else\n+\t\t    {\n+\t\t      lex_state = ls_fun_close;\n+\t\t      paren_depth = 1;\n+\t\t      out = pfile->out.base + fmacro.offset;\n+\t\t      fmacro.args[0] = fmacro.offset;\n+\t\t    }\n \t\t}\n \t      else if (lex_state == ls_predicate)\n \t\tlex_state = ls_answer;\n@@ -681,15 +685,43 @@ scan_out_logical_line (pfile, macro)\n \t  break;\n \n \tcase '#':\n-\t  /* At start of a line it's a directive.  */\n \t  if (out - 1 == pfile->out.base && !pfile->state.in_directive)\n \t    {\n-\t      /* This is a kludge.  We want to have the ISO\n-\t\t preprocessor lex the next token.  */\n-\t      pfile->buffer->cur = cur;\n-\t      if (_cpp_handle_directive (pfile, false /* indented */))\n-\t\tgoto start_logical_line;\n+\t      /* A directive.  With the way _cpp_handle_directive\n+\t\t currently works, we only want to call it if either we\n+\t\t know the directive is OK, or we want it to fail and\n+\t\t be removed from the output.  If we want it to be\n+\t\t passed through (the assembler case) then we must not\n+\t\t call _cpp_handle_directive.  */\n+\t      pfile->out.cur = out;\n+\t      cur = skip_whitespace (pfile, cur, true /* skip_comments */);\n+\t      out = pfile->out.cur;\n+\n+\t      if (is_vspace (*cur))\n+\t\t/* Null directive ignored.  */\n+\t\tout = pfile->out.base;\n+\t      else\n+\t\t{\n+\t\t  bool do_it = false;\n+\n+\t\t  if (is_numstart (*cur))\n+\t\t    do_it = true;\n+\t\t  else if (is_idstart (*cur))\n+\t\t    /* Check whether we know this directive, but don't\n+\t\t       advance.  */\n+\t\t    do_it = lex_identifier (pfile, cur)->directive_index != 0;\n+\n+\t\t  if (do_it || CPP_OPTION (pfile, lang) != CLK_ASM)\n+\t\t    {\n+\t\t      /* This is a kludge.  We want to have the ISO\n+\t\t\t preprocessor lex the next token.  */\n+\t\t      pfile->buffer->cur = cur;\n+\t\t      _cpp_handle_directive (pfile, false /* indented */);\n+\t\t      goto start_logical_line;\n+\t\t    }\n+\t\t}\n \t    }\n+\n \t  if (pfile->state.in_expression)\n \t    {\n \t      lex_state = ls_hash;"}, {"sha": "32c90983f523977bbc5ff1e358250e8c0aef0737", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c088b53f9633f073f02656eba0033c68ab65f31/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c088b53f9633f073f02656eba0033c68ab65f31/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2c088b53f9633f073f02656eba0033c68ab65f31", "patch": "@@ -1,3 +1,12 @@\n+2002-06-24  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* gcc.dg/cpp/trad/argcout.c, gcc.dg/cpp/trad/assembler.S,\n+\tgcc.dg/cpp/trad/argcout.c, gcc.dg/cpp/trad/funlike-4.c,\n+\tgcc.dg/cpp/trad/null-drctv.c, gcc.dg/cpp/trad/recurse-1.c,\n+\tgcc.dg/cpp/trad/recurse-2.c, gcc.dg/cpp/trad/recurse-3.c:\n+\tNew tests.\n+\t* gcc.dg/cpp/trad/directive.c: Update.\n+\n 2002-06-23  Andreas Jaeger  <aj@suse.de>\n \n \t* gcc.c-torture/execute/complex-6.c: New."}, {"sha": "208cd44b3b075208cd88cab30fe1cbd4e650de38", "filename": "gcc/testsuite/gcc.dg/cpp/trad/argcount.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c088b53f9633f073f02656eba0033c68ab65f31/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fargcount.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c088b53f9633f073f02656eba0033c68ab65f31/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fargcount.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fargcount.c?ref=2c088b53f9633f073f02656eba0033c68ab65f31", "patch": "@@ -0,0 +1,21 @@\n+/* Test that we correctly complain about an invalid number of macro\n+   arguments.  */\n+\n+/* { dg-do preprocess } */\n+\n+#define f(x) x\n+#define g(x, y) x y\n+#define h()\n+\n+f(); \t\t/* { dg-bogus \"requires 1\" \"no arg is 1 empty arg\" } */\n+f( ); \t\t/* { dg-bogus \"macro\" \"1 arg to 1 param macro\" } */\n+f(1,); \t\t/* { dg-error \"passed 2\" \"2 args to 1 param macro\" } */\n+f(1,2);\t\t/* { dg-error \"passed 2\" \"2 args to 1 param macro\" } */\n+h();\t\t/* { dg-bogus \"macro\" \"no arg to 1 param macro\" } */\n+h( );\t\t/* { dg-error \"passed 1\" \"1 arg to 0 param macro\" } */\n+h(1,2);\t\t/* { dg-error \"passed 2\" \"2 args to 0 param macro\" } */\n+g();\t\t/* { dg-error \"requires 2\" \"0 args to 2 param macro\" } */\n+g( );\t\t/* { dg-error \"requires 2\" \"1 args to 2 param macro\" } */\n+g( ,2);\t\t/* { dg-bogus \"requires 2\" \"2 args to 2 param macro\" } */\n+g(,);\t\t/* { dg-bogus \"requires 2\" \"2 args to 2 param macro\" } */\n+g(1,2,3);\t/* { dg-error \"passed 3\" \"3 args to 2 param macro\" } */"}, {"sha": "729162a5120d8eea9b7467848722d538cfb1e1f5", "filename": "gcc/testsuite/gcc.dg/cpp/trad/assembler.S", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c088b53f9633f073f02656eba0033c68ab65f31/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fassembler.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c088b53f9633f073f02656eba0033c68ab65f31/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fassembler.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fassembler.S?ref=2c088b53f9633f073f02656eba0033c68ab65f31", "patch": "@@ -0,0 +1,25 @@\n+/* Regression test - in assembly language, # may have some significance\n+   other than 'stringize macro argument' and therefore must be preserved\n+   in the output, and should not be warned about.  */\n+\n+/* { dg-do preprocess } */\n+\n+#define foo() mov r0, #5  /* { dg-bogus \"not followed\" \"spurious warning\" } */\n+\n+entry:\n+\tfoo()\n+\n+/* Check we don't EOF on an unknown directive.  */\n+#unknown directive\n+#error a later diagnostic\t/* { dg-error \"diagnostic\" } */\n+\t\t\n+/*\n+   { dg-final { if ![file exists 20000510-1.i] { return }\t} }\n+   { dg-final { set tmp [grep 20000510-1.i # line]\t\t} }\n+   { dg-final { if {[string length $tmp] > 0} \\{\t\t} }\n+   { dg-final {     pass \"20000510-1.S: # preservation\"\t\t} }\n+   { dg-final { \\} else \\{\t\t\t\t\t} }\n+   { dg-final {     fail \"20000510-1.S: # preservation\"\t\t} }\n+   { dg-final { \\}\t\t\t\t\t\t} }\n+*/\n+"}, {"sha": "5139c3322f9f40459498d18d2de626a24686a112", "filename": "gcc/testsuite/gcc.dg/cpp/trad/directive.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c088b53f9633f073f02656eba0033c68ab65f31/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fdirective.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c088b53f9633f073f02656eba0033c68ab65f31/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fdirective.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fdirective.c?ref=2c088b53f9633f073f02656eba0033c68ab65f31", "patch": "@@ -8,3 +8,5 @@\n \n /* Directives with their #s indented are not recognized.  */\n  #if 0\t/* { dg-bogus \"unterminated\" } */\n+\n+#wrong\t/* { dg-error \"invalid\" } */"}, {"sha": "fcc65a8d60db7566a2ffe08635f1c55ff42be70d", "filename": "gcc/testsuite/gcc.dg/cpp/trad/funlike-4.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c088b53f9633f073f02656eba0033c68ab65f31/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Ffunlike-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c088b53f9633f073f02656eba0033c68ab65f31/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Ffunlike-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Ffunlike-4.c?ref=2c088b53f9633f073f02656eba0033c68ab65f31", "patch": "@@ -0,0 +1,26 @@\n+/* Test that undefined names evaluate to zero, that macros after a\n+   funlike macro are expanded, and that if it is a '(' the funlike\n+   macro is not treated as such.  */\n+\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+\n+#define f(x) x\n+\n+int main ()\n+{\n+#if f(1) == f /**/ (/**/1/**/)\n+  int x;\n+#endif\n+\n+  x = 0;\n+  if (f\n+      /**/   (\n+\t      /**/ 0/**/\n+\t      /**/)\n+      )\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "99fd251f2e3168488ab16d5a6b598078ff642434", "filename": "gcc/testsuite/gcc.dg/cpp/trad/null-drctv.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c088b53f9633f073f02656eba0033c68ab65f31/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fnull-drctv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c088b53f9633f073f02656eba0033c68ab65f31/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fnull-drctv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fnull-drctv.c?ref=2c088b53f9633f073f02656eba0033c68ab65f31", "patch": "@@ -0,0 +1,6 @@\n+/* Test that the null directive doesn't swallow the following line.  */\n+\n+/* { dg-do preprocess } */\n+\n+#\n+#error OK\t/* { dg-error \"OK\" } */"}, {"sha": "b5fd7af7f5ff5802a585740387b2a6631d33a384", "filename": "gcc/testsuite/gcc.dg/cpp/trad/recurse-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c088b53f9633f073f02656eba0033c68ab65f31/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Frecurse-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c088b53f9633f073f02656eba0033c68ab65f31/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Frecurse-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Frecurse-1.c?ref=2c088b53f9633f073f02656eba0033c68ab65f31", "patch": "@@ -0,0 +1,10 @@\n+/* Test for warning of and recovery from recursion in object-like\n+   macros.  */\n+\n+/* { dg-do preprocess } */\n+\n+#define foo foo\n+foo\t\t\t\t/* { dg-error \"detected recursion\" } */\n+\n+#define bar a bar b\n+bar\t\t\t\t/* { dg-error \"detected recursion\" } */"}, {"sha": "5c6550fae2acdc529379c52d698cc1c52ca52ec0", "filename": "gcc/testsuite/gcc.dg/cpp/trad/recurse-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c088b53f9633f073f02656eba0033c68ab65f31/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Frecurse-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c088b53f9633f073f02656eba0033c68ab65f31/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Frecurse-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Frecurse-2.c?ref=2c088b53f9633f073f02656eba0033c68ab65f31", "patch": "@@ -0,0 +1,16 @@\n+/* Test for warning of and recovery from recursion in function-like\n+   macros.  */\n+\n+/* { dg-do preprocess } */\n+\n+#define foo() foo()\n+foo();\t\t\t\t/* { dg-error \"detected recursion\" } */\n+\n+#define bar() bar baz() bar\n+bar();\t\t\t\t/* { dg-bogus \"detected recursion\" } */\n+\n+#define baz() foo()\n+baz();\t\t\t       /* { dg-error \"detected recursion\" } */\n+\n+#define a(x) x(a)\n+a(a);\t\t\t       /* { dg-error \"detected recursion\" } */"}, {"sha": "8ff65cc801f5858516bbe02b6365fff57353627e", "filename": "gcc/testsuite/gcc.dg/cpp/trad/recurse-3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c088b53f9633f073f02656eba0033c68ab65f31/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Frecurse-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c088b53f9633f073f02656eba0033c68ab65f31/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Frecurse-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Frecurse-3.c?ref=2c088b53f9633f073f02656eba0033c68ab65f31", "patch": "@@ -0,0 +1,16 @@\n+/* Tests that macros that look recursive but are not are accepted.  */\n+\n+/* { dg-do preprocess } */\n+\n+#define g(x) x\n+g(g(g(g(g(g(g))))));\t       /* { dg-bogus \"detected recursion\" } */\n+\n+/* This macro gets longer with each loop, to thwart tests for\n+   recursion based on length.  */\n+#define f(a,b,c,d,e,f,g,h,i) a(b,c,d,e,f,g,h,i,2 3 4 5)\n+f(f,f,f,f,f,f,f,f,f)\t       /* { dg-bogus \"detected recursion\" } */\n+\n+/* The above cases should be enough, but this is taken from cccp\n+   sources so let's try it too.  */\n+#define foo(x,y) bar (x (y,0), y)\n+foo (foo, baz);\t       /* { dg-bogus \"detected recursion\" } */"}]}