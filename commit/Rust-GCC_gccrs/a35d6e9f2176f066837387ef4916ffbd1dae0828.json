{"sha": "a35d6e9f2176f066837387ef4916ffbd1dae0828", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM1ZDZlOWYyMTc2ZjA2NjgzNzM4N2VmNDkxNmZmYmQxZGFlMDgyOA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-07-03T13:23:39Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-07-03T13:23:39Z"}, "message": "compiler: include transitive imports in the type descriptor list\n    \n    In CL 179598, we were using Gogo::packages_, when compiling the\n    main package, as the list of packages of which we need to\n    register the type descriptors. This is not complete. It only\n    includes main's direct import and one-level indirect imports. It\n    does not include all the packages transitively imported.\n    \n    To fix that, we need to track all the transitive imports. We\n    have almost already done that, for init functions. However, there\n    may be packages that don't need init functions but do need to\n    register type descriptors. For them, we add a dummy init function\n    to its export data. So when we compile the main package we will\n    see all the transitive imports. The dummy init functions are not\n    real functions and are not called.\n    \n    Fixes golang/go#32901.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/184717\n\nFrom-SVN: r273009", "tree": {"sha": "a9c23f12c4fc48f2f3bf04fa83301f4920a09362", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9c23f12c4fc48f2f3bf04fa83301f4920a09362"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a35d6e9f2176f066837387ef4916ffbd1dae0828", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a35d6e9f2176f066837387ef4916ffbd1dae0828", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a35d6e9f2176f066837387ef4916ffbd1dae0828", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a35d6e9f2176f066837387ef4916ffbd1dae0828/comments", "author": null, "committer": null, "parents": [{"sha": "6c47a87b661598cfba79925a6fdd1ebf7737bbdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c47a87b661598cfba79925a6fdd1ebf7737bbdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c47a87b661598cfba79925a6fdd1ebf7737bbdc"}], "stats": {"total": 98, "additions": 80, "deletions": 18}, "files": [{"sha": "cc157b704b164de9fd9be5b6308d21cc2d9ac577", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a35d6e9f2176f066837387ef4916ffbd1dae0828/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a35d6e9f2176f066837387ef4916ffbd1dae0828/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=a35d6e9f2176f066837387ef4916ffbd1dae0828", "patch": "@@ -1,4 +1,4 @@\n-aebd2d6303e4bb970b088e84f6c66279095dfea6\n+ae7d7e05bce19aefaa27efe2ee797933aafbef06\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "cb778a0fd8340d628568aa07d9ec05ceef3d3bc1", "filename": "gcc/go/gofrontend/export.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a35d6e9f2176f066837387ef4916ffbd1dae0828/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a35d6e9f2176f066837387ef4916ffbd1dae0828/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.cc?ref=a35d6e9f2176f066837387ef4916ffbd1dae0828", "patch": "@@ -909,6 +909,8 @@ Export::populate_init_graph(Init_graph* init_graph,\n        ++p)\n     {\n       const Import_init* ii = *p;\n+      if (ii->is_dummy())\n+        continue;\n       std::map<std::string, unsigned>::const_iterator srcit =\n           init_idx.find(ii->init_name());\n       go_assert(srcit != init_idx.end());\n@@ -1007,7 +1009,7 @@ Export::write_imported_init_fns(const std::string& package_name,\n \n   // Now add edges from the local init function to each of the\n   // imported fcns.\n-  if (!import_init_fn.empty())\n+  if (!import_init_fn.empty() && import_init_fn[0] != '~')\n     {\n       unsigned src = 0;\n       go_assert(init_idx[import_init_fn] == 0);\n@@ -1016,6 +1018,8 @@ Export::write_imported_init_fns(const std::string& package_name,\n            ++p)\n \t{\n           const Import_init* ii = *p;\n+          if (ii->is_dummy())\n+            continue;\n \t  unsigned sink = init_idx[ii->init_name()];\n \t  add_init_graph_edge(&init_graph, src, sink);\n \t}"}, {"sha": "fcf9a93c78530b214acf81a97031123e46ed1eef", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a35d6e9f2176f066837387ef4916ffbd1dae0828/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a35d6e9f2176f066837387ef4916ffbd1dae0828/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=a35d6e9f2176f066837387ef4916ffbd1dae0828", "patch": "@@ -724,6 +724,9 @@ Gogo::init_imports(std::vector<Bstatement*>& init_stmts, Bfunction *bfunction)\n        p != this->imported_init_fns_.end();\n        ++p)\n     {\n+      // Don't include dummy inits. They are not real functions.\n+      if ((*p)->is_dummy())\n+        continue;\n       if ((*p)->priority() < 0)\n \tgo_error_at(Linemap::unknown_location(),\n \t\t    \"internal error: failed to set init priority for %s\",\n@@ -941,7 +944,7 @@ Gogo::build_type_descriptor_list()\n   Btype* bat = list_type->field(1)->type()->get_backend(this);\n \n   // Create the variable\n-  std::string name = this->type_descriptor_list_symbol(this->package_);\n+  std::string name = this->type_descriptor_list_symbol(this->pkgpath_symbol());\n   Bvariable* bv = this->backend()->implicit_variable(name, name, bt,\n                                                      false, true, false,\n                                                      0);\n@@ -986,20 +989,29 @@ Gogo::register_type_descriptors(std::vector<Bstatement*>& init_stmts,\n   Struct_type* list_type = type_descriptor_list_type(1);\n   Btype* bt = list_type->get_backend(this);\n \n+  // Collect type lists from transitive imports.\n+  std::vector<std::string> list_names;\n+  for (Import_init_set::iterator it = this->imported_init_fns_.begin();\n+       it != this->imported_init_fns_.end();\n+       ++it)\n+    {\n+      std::string pkgpath =\n+        this->pkgpath_from_init_fn_name((*it)->init_name());\n+      list_names.push_back(this->type_descriptor_list_symbol(pkgpath));\n+    }\n+  // Add the main package itself.\n+  list_names.push_back(this->type_descriptor_list_symbol(\"main\"));\n+\n   // Build a list of lists.\n   std::vector<unsigned long> indexes;\n   std::vector<Bexpression*> vals;\n   unsigned long i = 0;\n-  for (Packages::iterator it = this->packages_.begin();\n-       it != this->packages_.end();\n-       ++it)\n+  for (std::vector<std::string>::iterator p = list_names.begin();\n+       p != list_names.end();\n+       ++p)\n     {\n-      if (it->second->pkgpath() == \"unsafe\")\n-        continue;\n-\n-      std::string name = this->type_descriptor_list_symbol(it->second);\n       Bvariable* bv =\n-        this->backend()->implicit_variable_reference(name, name, bt);\n+        this->backend()->implicit_variable_reference(*p, *p, bt);\n       Bexpression* bexpr = this->backend()->var_expression(bv, builtin_loc);\n       bexpr = this->backend()->address_expression(bexpr, builtin_loc);\n \n@@ -5158,16 +5170,22 @@ Gogo::do_exports()\n   else\n     prefix = \"go\";\n \n+  std::string init_fn_name;\n+  if (this->is_main_package())\n+    init_fn_name = \"\";\n+  else if (this->need_init_fn_)\n+    init_fn_name = this->get_init_fn_name();\n+  else\n+    init_fn_name = this->dummy_init_fn_name();\n+\n   Export exp(&stream);\n   exp.register_builtin_types(this);\n   exp.export_globals(this->package_name(),\n \t\t     prefix,\n \t\t     pkgpath,\n \t\t     this->packages_,\n \t\t     this->imports_,\n-\t\t     (this->need_init_fn_ && !this->is_main_package()\n-\t\t      ? this->get_init_fn_name()\n-\t\t      : \"\"),\n+\t\t     init_fn_name,\n \t\t     this->imported_init_fns_,\n \t\t     this->package_->bindings());\n "}, {"sha": "c4d5bab7681ee0dce123ebcb9ced26b83ba2d413", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a35d6e9f2176f066837387ef4916ffbd1dae0828/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a35d6e9f2176f066837387ef4916ffbd1dae0828/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=a35d6e9f2176f066837387ef4916ffbd1dae0828", "patch": "@@ -103,6 +103,11 @@ class Import_init\n   precursors() const\n   { return this->precursor_functions_; }\n \n+  // Whether this is a dummy init, which is used only to record transitive import.\n+  bool\n+  is_dummy() const\n+  { return this->init_name_[0] == '~'; }\n+\n  private:\n   // The name of the package being imported.\n   std::string package_name_;\n@@ -912,13 +917,23 @@ class Gogo\n   const std::string&\n   get_init_fn_name();\n \n+  // Return the name for a dummy init function, which is not a real\n+  // function but only for tracking transitive import.\n+  std::string\n+  dummy_init_fn_name();\n+\n+  // Return the package path symbol from an init function name, which\n+  // can be a real init function or a dummy one.\n+  std::string\n+  pkgpath_from_init_fn_name(std::string);\n+\n   // Return the name for a type descriptor symbol.\n   std::string\n   type_descriptor_name(const Type*, Named_type*);\n \n   // Return the name of the type descriptor list symbol of a package.\n   std::string\n-  type_descriptor_list_symbol(Package*);\n+  type_descriptor_list_symbol(std::string);\n \n   // Return the name of the list of all type descriptor lists.\n   std::string"}, {"sha": "91cbb4bcad0a758bae14f3eb679bd4fa86129a5c", "filename": "gcc/go/gofrontend/names.cc", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a35d6e9f2176f066837387ef4916ffbd1dae0828/gcc%2Fgo%2Fgofrontend%2Fnames.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a35d6e9f2176f066837387ef4916ffbd1dae0828/gcc%2Fgo%2Fgofrontend%2Fnames.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fnames.cc?ref=a35d6e9f2176f066837387ef4916ffbd1dae0828", "patch": "@@ -144,7 +144,8 @@\n //\n // The import function for the main package is referenced by C code,\n // and is named __go_init_main.  For other packages it is\n-// PKGPATH..import.\n+// PKGPATH..import.  If a package doesn't need an init function, it\n+// will have a dummy one, named ~PKGPATH.\n //\n // In each pacakge there is a list of all the type descriptors defined\n // in this package.  The name of the list is PKGPATH..types.\n@@ -531,6 +532,30 @@ Gogo::get_init_fn_name()\n   return this->init_fn_name_;\n }\n \n+// Return the name for a dummy init function, which is not a real\n+// function but only for tracking transitive import.\n+\n+std::string\n+Gogo::dummy_init_fn_name()\n+{\n+  return \"~\" + this->pkgpath_symbol();\n+}\n+\n+// Return the package path symbol from an init function name, which\n+// can be a real init function or a dummy one.\n+\n+std::string\n+Gogo::pkgpath_from_init_fn_name(std::string name)\n+{\n+  go_assert(!name.empty());\n+  if (name[0] == '~')\n+    return name.substr(1);\n+  size_t pos = name.find(\"..import\");\n+  if (pos != std::string::npos)\n+    return name.substr(0, pos);\n+  go_unreachable();\n+}\n+\n // Return a mangled name for a type.  These names appear in symbol\n // names in the assembler file for things like type descriptors and\n // methods.\n@@ -994,9 +1019,9 @@ Gogo::type_descriptor_name(const Type* type, Named_type* nt)\n // Return the name of the type descriptor list symbol of a package.\n \n std::string\n-Gogo::type_descriptor_list_symbol(Package* pkg)\n+Gogo::type_descriptor_list_symbol(std::string pkgpath)\n {\n-  return pkg->pkgpath_symbol() + \"..types\";\n+  return pkgpath + \"..types\";\n }\n \n // Return the name of the list of all type descriptor lists.  This is"}]}