{"sha": "d2d7ed3e171414e7ef911590bc0d0e1e2b05e232", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJkN2VkM2UxNzE0MTRlN2VmOTExNTkwYmMwZDBlMWUyYjA1ZTIzMg==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1995-02-23T08:14:12Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1995-02-23T08:14:12Z"}, "message": "Fix signed/unsigned comparison warning.\n\nFrom-SVN: r9045", "tree": {"sha": "5665ef005028b9a1fa6c10becfc6020b17e5f426", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5665ef005028b9a1fa6c10becfc6020b17e5f426"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2d7ed3e171414e7ef911590bc0d0e1e2b05e232", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2d7ed3e171414e7ef911590bc0d0e1e2b05e232", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2d7ed3e171414e7ef911590bc0d0e1e2b05e232", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2d7ed3e171414e7ef911590bc0d0e1e2b05e232/comments", "author": null, "committer": null, "parents": [{"sha": "71df911299f2944ab5c4bfc6d1fd3df5a23c7ca8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71df911299f2944ab5c4bfc6d1fd3df5a23c7ca8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71df911299f2944ab5c4bfc6d1fd3df5a23c7ca8"}], "stats": {"total": 40, "additions": 14, "deletions": 26}, "files": [{"sha": "b5cd340fa545fa1ce218485c7c3176130cb21c06", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2d7ed3e171414e7ef911590bc0d0e1e2b05e232/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2d7ed3e171414e7ef911590bc0d0e1e2b05e232/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=d2d7ed3e171414e7ef911590bc0d0e1e2b05e232", "patch": "@@ -2438,37 +2438,25 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \n \t  if (extra_warnings)\n \t    {\n-\t      tree op0_type = TREE_TYPE (orig_op0);\n-\t      tree op1_type = TREE_TYPE (orig_op1);\n-\t      int op0_unsigned = TREE_UNSIGNED (op0_type);\n-\t      int op1_unsigned = TREE_UNSIGNED (op1_type);\n- \n+\t      int op0_signed = ! TREE_UNSIGNED (TREE_TYPE (orig_op0));\n+\t      int op1_signed = ! TREE_UNSIGNED (TREE_TYPE (orig_op1));\n+\n+\t      tree comp_type = TREE_TYPE (op0);\n+\n \t      /* Give warnings for comparisons between signed and unsigned\n-\t\t quantities that will fail.  Do not warn if the signed quantity\n+\t\t quantities that may fail.  Do not warn if the signed quantity\n \t\t is an unsuffixed integer literal (or some static constant\n \t\t expression involving such literals) and it is positive.\n-\t\t Do not warn if the width of the unsigned quantity is less\n-\t\t than that of the signed quantity, since in this case all\n-\t\t values of the unsigned quantity fit in the signed quantity.\n-\t\t Do not warn if the signed type is the same size as the\n-\t\t result_type since sign extension does not cause trouble in\n-\t\t this case.  */\n+\t\t Do not warn if the comparison is being done in a signed type,\n+\t\t since the signed type will only be chosen if it can represent\n+\t\t all the values of the unsigned type.  */\n \t      /* Do the checking based on the original operand trees, so that\n \t\t casts will be considered, but default promotions won't be.  */\n-\t      if (op0_unsigned != op1_unsigned\n-\t\t  && ((op0_unsigned\n-\t\t       && TYPE_PRECISION (op0_type) >= TYPE_PRECISION (op1_type)\n-\t\t       && TYPE_PRECISION (op0_type) < TYPE_PRECISION (result_type)\n-\t\t       && (TREE_CODE (op1) != INTEGER_CST\n-\t\t\t   || (TREE_CODE (op1) == INTEGER_CST\n-\t\t\t       && INT_CST_LT (op1, integer_zero_node))))\n-\t\t      ||\n-\t\t      (op1_unsigned\n-\t\t       && TYPE_PRECISION (op1_type) >= TYPE_PRECISION (op0_type)\n-\t\t       && TYPE_PRECISION (op1_type) < TYPE_PRECISION (result_type)\n-\t\t       && (TREE_CODE (op0) != INTEGER_CST\n-\t\t\t   || (TREE_CODE (op0) == INTEGER_CST\n-\t\t\t       && INT_CST_LT (op0, integer_zero_node))))))\n+\t      if (TREE_UNSIGNED (comp_type)\n+\t\t  && ((op0_signed && (TREE_CODE (orig_op0) != INTEGER_CST\n+\t\t\t\t      || tree_int_cst_sgn (orig_op0) == -1))\n+\t\t      || (op1_signed && (TREE_CODE (orig_op1) != INTEGER_CST\n+\t\t\t\t       || tree_int_cst_sgn (orig_op1) == -1))))\n \t\twarning (\"comparison between signed and unsigned\");\n \t    }\n \t}"}]}