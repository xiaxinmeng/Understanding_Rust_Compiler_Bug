{"sha": "8dec06f23ab0d08496453f4b09bab2869dc4838e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRlYzA2ZjIzYWIwZDA4NDk2NDUzZjRiMDliYWIyODY5ZGM0ODM4ZQ==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2015-06-26T14:04:12Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2015-06-26T14:04:12Z"}, "message": "[Patch AArch64 4/4] Add -moverride tuning command, and wire it up for\n control of fusion and fma-steering\n\ngcc/\n\n\t* config/aarch64/aarch64.opt: (override): New.\n\t* doc/invoke.texi (override): Document.\n\t* config/aarch64/aarch64.c (aarch64_flag_desc): New\n\t(aarch64_fusible_pairs): Likewise.\n\t(aarch64_tuning_flags): Likewise.\n\t(aarch64_tuning_override_function): Likewise.\n\t(aarch64_tuning_override_functions): Likewise.\n\t(aarch64_parse_one_option_token): Likewise.\n\t(aarch64_parse_boolean_options): Likewise.\n\t(aarch64_parse_fuse_string): Likewise.\n\t(aarch64_parse_tune_string): Likewise.\n\t(aarch64_parse_one_override_token): Likewise.\n\t(aarch64_parse_override_string): Likewise.\n\t(aarch64_override_options): Parse the -override string if it\n\tis present.\n\nFrom-SVN: r225018", "tree": {"sha": "ed8c545d5c2fedb9a38ea9fde707fb5d1ce51408", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed8c545d5c2fedb9a38ea9fde707fb5d1ce51408"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dec06f23ab0d08496453f4b09bab2869dc4838e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dec06f23ab0d08496453f4b09bab2869dc4838e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dec06f23ab0d08496453f4b09bab2869dc4838e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dec06f23ab0d08496453f4b09bab2869dc4838e/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1b1e81f847a651bef0fff52d4dc5d09d9e521bcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b1e81f847a651bef0fff52d4dc5d09d9e521bcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b1e81f847a651bef0fff52d4dc5d09d9e521bcc"}], "stats": {"total": 255, "additions": 255, "deletions": 0}, "files": [{"sha": "460e78cbfc6254523fd5713639a08cc57506c2a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dec06f23ab0d08496453f4b09bab2869dc4838e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dec06f23ab0d08496453f4b09bab2869dc4838e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8dec06f23ab0d08496453f4b09bab2869dc4838e", "patch": "@@ -1,3 +1,21 @@\n+2015-06-26  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* config/aarch64/aarch64.opt: (override): New.\n+\t* doc/invoke.texi (override): Document.\n+\t* config/aarch64/aarch64.c (aarch64_flag_desc): New\n+\t(aarch64_fusible_pairs): Likewise.\n+\t(aarch64_tuning_flags): Likewise.\n+\t(aarch64_tuning_override_function): Likewise.\n+\t(aarch64_tuning_override_functions): Likewise.\n+\t(aarch64_parse_one_option_token): Likewise.\n+\t(aarch64_parse_boolean_options): Likewise.\n+\t(aarch64_parse_fuse_string): Likewise.\n+\t(aarch64_parse_tune_string): Likewise.\n+\t(aarch64_parse_one_override_token): Likewise.\n+\t(aarch64_parse_override_string): Likewise.\n+\t(aarch64_override_options): Parse the -override string if it\n+\tis present.\n+\n 2015-06-26  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* config/aarch64/aarch64-protos.h (tune_params): Remove"}, {"sha": "f130f8dea1da78a8cad86f08ee49816563fc5ed5", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dec06f23ab0d08496453f4b09bab2869dc4838e/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dec06f23ab0d08496453f4b09bab2869dc4838e/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=8dec06f23ab0d08496453f4b09bab2869dc4838e", "patch": "@@ -172,6 +172,36 @@ unsigned long aarch64_isa_flags = 0;\n /* Mask to specify which instruction scheduling options should be used.  */\n unsigned long aarch64_tune_flags = 0;\n \n+/* Support for command line parsing of boolean flags in the tuning\n+   structures.  */\n+struct aarch64_flag_desc\n+{\n+  const char* name;\n+  unsigned int flag;\n+};\n+\n+#define AARCH64_FUSION_PAIR(name, internal_name, y) \\\n+  { name, AARCH64_FUSE_##internal_name },\n+static const struct aarch64_flag_desc aarch64_fusible_pairs[] =\n+{\n+  { \"none\", AARCH64_FUSE_NOTHING },\n+#include \"aarch64-fusion-pairs.def\"\n+  { \"all\", AARCH64_FUSE_ALL },\n+  { NULL, AARCH64_FUSE_NOTHING }\n+};\n+#undef AARCH64_FUION_PAIR\n+\n+#define AARCH64_EXTRA_TUNING_OPTION(name, internal_name, y) \\\n+  { name, AARCH64_EXTRA_TUNE_##internal_name },\n+static const struct aarch64_flag_desc aarch64_tuning_flags[] =\n+{\n+  { \"none\", AARCH64_EXTRA_TUNE_NONE },\n+#include \"aarch64-tuning-flags.def\"\n+  { \"all\", AARCH64_EXTRA_TUNE_ALL },\n+  { NULL, AARCH64_EXTRA_TUNE_NONE }\n+};\n+#undef AARCH64_EXTRA_TUNING_OPTION\n+\n /* Tuning parameters.  */\n \n static const struct cpu_addrcost_table generic_addrcost_table =\n@@ -454,6 +484,24 @@ static const struct tune_params xgene1_tunings =\n   (AARCH64_EXTRA_TUNE_NONE)\t/* tune_flags.  */\n };\n \n+/* Support for fine-grained override of the tuning structures.  */\n+struct aarch64_tuning_override_function\n+{\n+  const char* name;\n+  void (*parse_override)(const char*, struct tune_params*);\n+};\n+\n+static void aarch64_parse_fuse_string (const char*, struct tune_params*);\n+static void aarch64_parse_tune_string (const char*, struct tune_params*);\n+\n+static const struct aarch64_tuning_override_function\n+aarch64_tuning_override_functions[] =\n+{\n+  { \"fuse\", aarch64_parse_fuse_string },\n+  { \"tune\", aarch64_parse_tune_string },\n+  { NULL, NULL }\n+};\n+\n /* A processor implementing AArch64.  */\n struct processor\n {\n@@ -7230,6 +7278,178 @@ aarch64_parse_tune (void)\n   return;\n }\n \n+/* Parse TOKEN, which has length LENGTH to see if it is an option\n+   described in FLAG.  If it is, return the index bit for that fusion type.\n+   If not, error (printing OPTION_NAME) and return zero.  */\n+\n+static unsigned int\n+aarch64_parse_one_option_token (const char *token,\n+\t\t\t\tsize_t length,\n+\t\t\t\tconst struct aarch64_flag_desc *flag,\n+\t\t\t\tconst char *option_name)\n+{\n+  for (; flag->name != NULL; flag++)\n+    {\n+      if (length == strlen (flag->name)\n+\t  && !strncmp (flag->name, token, length))\n+\treturn flag->flag;\n+    }\n+\n+  error (\"unknown flag passed in -moverride=%s (%s)\", option_name, token);\n+  return 0;\n+}\n+\n+/* Parse OPTION which is a comma-separated list of flags to enable.\n+   FLAGS gives the list of flags we understand, INITIAL_STATE gives any\n+   default state we inherit from the CPU tuning structures.  OPTION_NAME\n+   gives the top-level option we are parsing in the -moverride string,\n+   for use in error messages.  */\n+\n+static unsigned int\n+aarch64_parse_boolean_options (const char *option,\n+\t\t\t       const struct aarch64_flag_desc *flags,\n+\t\t\t       unsigned int initial_state,\n+\t\t\t       const char *option_name)\n+{\n+  const char separator = '.';\n+  const char* specs = option;\n+  const char* ntoken = option;\n+  unsigned int found_flags = initial_state;\n+\n+  while ((ntoken = strchr (specs, separator)))\n+    {\n+      size_t token_length = ntoken - specs;\n+      unsigned token_ops = aarch64_parse_one_option_token (specs,\n+\t\t\t\t\t\t\t   token_length,\n+\t\t\t\t\t\t\t   flags,\n+\t\t\t\t\t\t\t   option_name);\n+      /* If we find \"none\" (or, for simplicity's sake, an error) anywhere\n+\t in the token stream, reset the supported operations.  So:\n+\n+\t   adrp+add.cmp+branch.none.adrp+add\n+\n+\t   would have the result of turning on only adrp+add fusion.  */\n+      if (!token_ops)\n+\tfound_flags = 0;\n+\n+      found_flags |= token_ops;\n+      specs = ++ntoken;\n+    }\n+\n+  /* We ended with a comma, print something.  */\n+  if (!(*specs))\n+    {\n+      error (\"%s string ill-formed\\n\", option_name);\n+      return 0;\n+    }\n+\n+  /* We still have one more token to parse.  */\n+  size_t token_length = strlen (specs);\n+  unsigned token_ops = aarch64_parse_one_option_token (specs,\n+\t\t\t\t\t\t       token_length,\n+\t\t\t\t\t\t       flags,\n+\t\t\t\t\t\t       option_name);\n+   if (!token_ops)\n+     found_flags = 0;\n+\n+  found_flags |= token_ops;\n+  return found_flags;\n+}\n+\n+/* Support for overriding instruction fusion.  */\n+\n+static void\n+aarch64_parse_fuse_string (const char *fuse_string,\n+\t\t\t    struct tune_params *tune)\n+{\n+  tune->fusible_ops = aarch64_parse_boolean_options (fuse_string,\n+\t\t\t\t\t\t     aarch64_fusible_pairs,\n+\t\t\t\t\t\t     tune->fusible_ops,\n+\t\t\t\t\t\t     \"fuse=\");\n+}\n+\n+/* Support for overriding other tuning flags.  */\n+\n+static void\n+aarch64_parse_tune_string (const char *tune_string,\n+\t\t\t    struct tune_params *tune)\n+{\n+  tune->extra_tuning_flags\n+    = aarch64_parse_boolean_options (tune_string,\n+\t\t\t\t     aarch64_tuning_flags,\n+\t\t\t\t     tune->extra_tuning_flags,\n+\t\t\t\t     \"tune=\");\n+}\n+\n+/* Parse TOKEN, which has length LENGTH to see if it is a tuning option\n+   we understand.  If it is, extract the option string and handoff to\n+   the appropriate function.  */\n+\n+void\n+aarch64_parse_one_override_token (const char* token,\n+\t\t\t\t  size_t length,\n+\t\t\t\t  struct tune_params *tune)\n+{\n+  const struct aarch64_tuning_override_function *fn\n+    = aarch64_tuning_override_functions;\n+\n+  const char *option_part = strchr (token, '=');\n+  if (!option_part)\n+    {\n+      error (\"tuning string missing in option (%s)\", token);\n+      return;\n+    }\n+\n+  /* Get the length of the option name.  */\n+  length = option_part - token;\n+  /* Skip the '=' to get to the option string.  */\n+  option_part++;\n+\n+  for (; fn->name != NULL; fn++)\n+    {\n+      if (!strncmp (fn->name, token, length))\n+\t{\n+\t  fn->parse_override (option_part, tune);\n+\t  return;\n+\t}\n+    }\n+\n+  error (\"unknown tuning option (%s)\",token);\n+  return;\n+}\n+\n+/* Parse STRING looking for options in the format:\n+     string\t:: option:string\n+     option\t:: name=substring\n+     name\t:: {a-z}\n+     substring\t:: defined by option.  */\n+\n+static void\n+aarch64_parse_override_string (const char* input_string,\n+\t\t\t       struct tune_params* tune)\n+{\n+  const char separator = ':';\n+  size_t string_length = strlen (input_string) + 1;\n+  char *string_root = (char *) xmalloc (sizeof (*string_root) * string_length);\n+  char *string = string_root;\n+  strncpy (string, input_string, string_length);\n+  string[string_length - 1] = '\\0';\n+\n+  char* ntoken = string;\n+\n+  while ((ntoken = strchr (string, separator)))\n+    {\n+      size_t token_length = ntoken - string;\n+      /* Make this substring look like a string.  */\n+      *ntoken = '\\0';\n+      aarch64_parse_one_override_token (string, token_length, tune);\n+      string = ++ntoken;\n+    }\n+\n+  /* One last option to parse.  */\n+  aarch64_parse_one_override_token (string, strlen (string), tune);\n+  free (string_root);\n+}\n \n /* Implement TARGET_OPTION_OVERRIDE.  */\n \n@@ -7294,6 +7514,10 @@ aarch64_override_options (void)\n   aarch64_tune_params = *(selected_tune->tune);\n   aarch64_architecture_version = selected_cpu->architecture_version;\n \n+  if (aarch64_override_tune_string)\n+    aarch64_parse_override_string (aarch64_override_tune_string,\n+\t\t\t\t   &aarch64_tune_params);\n+\n   if (aarch64_fix_a53_err835769 == 2)\n     {\n #ifdef TARGET_FIX_ERR_A53_835769_DEFAULT"}, {"sha": "98ef9f6be9d70b8555de198d44a1fd327933355b", "filename": "gcc/config/aarch64/aarch64.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dec06f23ab0d08496453f4b09bab2869dc4838e/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dec06f23ab0d08496453f4b09bab2869dc4838e/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.opt?ref=8dec06f23ab0d08496453f4b09bab2869dc4838e", "patch": "@@ -111,6 +111,10 @@ mabi=\n Target RejectNegative Joined Enum(aarch64_abi) Var(aarch64_abi) Init(AARCH64_ABI_DEFAULT)\n -mabi=ABI\tGenerate code that conforms to the specified ABI\n \n+moverride=\n+Target RejectNegative ToLower Joined Var(aarch64_override_tune_string)\n+-moverride=STRING\tPower users only! Override CPU optimization parameters\n+\n Enum\n Name(aarch64_abi) Type(int)\n Known AArch64 ABIs (for use with the -mabi= option):"}, {"sha": "844d7edaecf2bc6642324ad8513f7c2add0ee486", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dec06f23ab0d08496453f4b09bab2869dc4838e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dec06f23ab0d08496453f4b09bab2869dc4838e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=8dec06f23ab0d08496453f4b09bab2869dc4838e", "patch": "@@ -12525,6 +12525,15 @@ Enable Privileged Access Never support.\n Enable Limited Ordering Regions support.\n @item rdma\n Enable ARMv8.1 Advanced SIMD instructions.\n+\n+@item -moverride=@var{string}\n+@opindex master\n+Override tuning decisions made by the back-end in response to a\n+@option{-mtune=} switch.  The syntax, semantics, and accepted values\n+for @var{string} in this option are not guaranteed to be consistent\n+across releases.\n+\n+This option is only intended to be useful when developing GCC.\n @end table\n \n That is, @option{crypto} implies @option{simd} implies @option{fp}."}]}