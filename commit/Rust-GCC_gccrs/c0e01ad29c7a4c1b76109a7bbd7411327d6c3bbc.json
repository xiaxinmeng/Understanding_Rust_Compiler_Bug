{"sha": "c0e01ad29c7a4c1b76109a7bbd7411327d6c3bbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBlMDFhZDI5YzdhNGMxYjc2MTA5YTdiYmQ3NDExMzI3ZDZjM2JiYw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2004-09-02T16:56:29Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-09-02T16:56:29Z"}, "message": "re PR libstdc++/16848 (code in /ext/demangle.h appears broken)\n\n\n2004-09-02  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tPR libstdc++/16848\n\t* include/Makefile.am (ext_headers): Remove demangle.h.\n\t* include/Makefile.in: Regenerate.\n\t* include/ext/demangle.h: Remove.\n\nFrom-SVN: r86968", "tree": {"sha": "00faf4bc00e83680ebb7412bc168bc02b296d4d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00faf4bc00e83680ebb7412bc168bc02b296d4d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0e01ad29c7a4c1b76109a7bbd7411327d6c3bbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e01ad29c7a4c1b76109a7bbd7411327d6c3bbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0e01ad29c7a4c1b76109a7bbd7411327d6c3bbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e01ad29c7a4c1b76109a7bbd7411327d6c3bbc/comments", "author": null, "committer": null, "parents": [{"sha": "e6fc6c9b86fc47df81a3258b4630fb68a6889c50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6fc6c9b86fc47df81a3258b4630fb68a6889c50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6fc6c9b86fc47df81a3258b4630fb68a6889c50"}], "stats": {"total": 2798, "additions": 7, "deletions": 2791}, "files": [{"sha": "aff78de24366ea676f753d1013562c85b02086c4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e01ad29c7a4c1b76109a7bbd7411327d6c3bbc/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e01ad29c7a4c1b76109a7bbd7411327d6c3bbc/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=c0e01ad29c7a4c1b76109a7bbd7411327d6c3bbc", "patch": "@@ -1,3 +1,10 @@\n+2004-09-02  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tPR libstdc++/16848\n+\t* include/Makefile.am (ext_headers): Remove demangle.h.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/ext/demangle.h: Remove.\n+\n 2004-09-01  Benjamin Kosnik  <bkoz@redhat.com>\n \n \tPR libstdc++/16614"}, {"sha": "3e99d3329f2de082afc0399ecb01d9c274158eb4", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e01ad29c7a4c1b76109a7bbd7411327d6c3bbc/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e01ad29c7a4c1b76109a7bbd7411327d6c3bbc/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=c0e01ad29c7a4c1b76109a7bbd7411327d6c3bbc", "patch": "@@ -203,7 +203,6 @@ ext_headers = \\\n \t${ext_srcdir}/algorithm \\\n \t${ext_srcdir}/bitmap_allocator.h \\\n \t${ext_srcdir}/debug_allocator.h \\\n-\t${ext_srcdir}/demangle.h \\\n \t${ext_srcdir}/enc_filebuf.h \\\n \t${ext_srcdir}/stdio_filebuf.h \\\n \t${ext_srcdir}/stdio_sync_filebuf.h \\"}, {"sha": "6f78ffac412fccff3d7346a922f68014b68057b1", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e01ad29c7a4c1b76109a7bbd7411327d6c3bbc/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e01ad29c7a4c1b76109a7bbd7411327d6c3bbc/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=c0e01ad29c7a4c1b76109a7bbd7411327d6c3bbc", "patch": "@@ -418,7 +418,6 @@ ext_headers = \\\n \t${ext_srcdir}/algorithm \\\n \t${ext_srcdir}/bitmap_allocator.h \\\n \t${ext_srcdir}/debug_allocator.h \\\n-\t${ext_srcdir}/demangle.h \\\n \t${ext_srcdir}/enc_filebuf.h \\\n \t${ext_srcdir}/stdio_filebuf.h \\\n \t${ext_srcdir}/stdio_sync_filebuf.h \\"}, {"sha": "5de4f04a22461e88fcaa15f9009f9fa9182b6cc9", "filename": "libstdc++-v3/include/ext/demangle.h", "status": "removed", "additions": 0, "deletions": 2789, "changes": 2789, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6fc6c9b86fc47df81a3258b4630fb68a6889c50/libstdc%2B%2B-v3%2Finclude%2Fext%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6fc6c9b86fc47df81a3258b4630fb68a6889c50/libstdc%2B%2B-v3%2Finclude%2Fext%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fdemangle.h?ref=e6fc6c9b86fc47df81a3258b4630fb68a6889c50", "patch": "@@ -1,2789 +0,0 @@\n-// C++ IA64 / g++ v3 demangler  -*- C++ -*-\n-\n-// Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n-// Written by Carlo Wood <carlo@alinoe.com>\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-// This file implements demangling of \"C++ ABI for Itanium\"-mangled symbol\n-// and type names as described in Revision 1.73 of the C++ ABI as can be found\n-// at http://www.codesourcery.com/cxx-abi/abi.html#mangling\n-\n-#ifndef _DEMANGLER_H\n-#define _DEMANGLER_H 1\n-\n-#include <vector>\n-#include <string>\n-#include <ext/new_allocator.h>\n-\n-#ifndef _GLIBCXX_DEMANGLER_DEBUG\n-#define _GLIBCXX_DEMANGLER_CWDEBUG 0\n-#define _GLIBCXX_DEMANGLER_DEBUG(x)\n-#define _GLIBCXX_DEMANGLER_DOUT(cntrl, data)\n-#define _GLIBCXX_DEMANGLER_DOUT_ENTERING(x)\n-#define _GLIBCXX_DEMANGLER_DOUT_ENTERING2(x)\n-#define _GLIBCXX_DEMANGLER_DOUT_ENTERING3(x)\n-#define _GLIBCXX_DEMANGLER_RETURN return M_result\n-#define _GLIBCXX_DEMANGLER_RETURN2 return M_result\n-#define _GLIBCXX_DEMANGLER_RETURN3\n-#define _GLIBCXX_DEMANGLER_FAILURE \\\n-    do { M_result = false; return false; } while(0)\n-#else\n-#define _GLIBCXX_DEMANGLER_CWDEBUG 1\n-#endif\n-\n-namespace __gnu_cxx\n-{\n-  namespace demangler\n-  {\n-    enum substitution_nt\n-    {\n-      type,\n-      template_template_param,\n-      nested_name_prefix,\n-      nested_name_template_prefix,\n-      unscoped_template_name\n-    };\n-\n-    struct substitution_st\n-    {\n-      int M_start_pos;\n-      substitution_nt M_type;\n-      int M_number_of_prefixes;\n-\n-      substitution_st(int start_pos,\n-\t\t      substitution_nt type,\n-\t\t      int number_of_prefixes)\n-      : M_start_pos(start_pos), M_type(type),\n-\tM_number_of_prefixes(number_of_prefixes)\n-      { }\n-    };\n-\n-    enum simple_qualifier_nt\n-    {\n-      complex_or_imaginary = 'G',\n-      pointer = 'P',\n-      reference = 'R'\n-    };\n-\n-    enum cv_qualifier_nt\n-    {\n-      cv_qualifier = 'K'\n-    };\n-\n-    enum param_qualifier_nt\n-    {\n-      vendor_extension = 'U',\n-      array = 'A',\n-      pointer_to_member = 'M'\n-    };\n-\n-    template<typename Tp, typename Allocator = __gnu_cxx::new_allocator<Tp> >\n-      class qualifier;\n-\n-    template<typename Tp, typename Allocator = __gnu_cxx::new_allocator<Tp> >\n-      class qualifier_list;\n-\n-    template<typename Tp, typename Allocator = __gnu_cxx::new_allocator<Tp> >\n-      class session;\n-\n-    template<typename Tp, typename Allocator>\n-      class qualifier\n-      {\n-\ttypedef typename Allocator::template rebind<char>::other\n-\t        char_Allocator;\n-\ttypedef std::basic_string<char, std::char_traits<char>, char_Allocator>\n-\t    string_type;\n-\n-      private:\n-\tchar M_qualifier1;\n-\tchar M_qualifier2;\n-\tchar M_qualifier3;\n-\tmutable unsigned char M_cnt;\n-\tstring_type M_optional_type;\n-\tint M_start_pos;\n-\tbool M_part_of_substitution;\n-\n-      public:\n-\tqualifier(int start_pos,\n-\t          simple_qualifier_nt simple_qualifier,\n-\t\t  int inside_substitution)\n-\t: M_qualifier1(simple_qualifier),\n-\t  M_start_pos(start_pos),\n-\t  M_part_of_substitution(inside_substitution)\n-\t{ }\n-\n-\tqualifier(int start_pos,\n-\t          cv_qualifier_nt,\n-\t\t  char const* start,\n-\t\t  int count,\n-\t\t  int inside_substitution)\n-\t: M_qualifier1(start[0]),\n-\t  M_qualifier2((count > 1) ? start[1] : '\\0'),\n-\t  M_qualifier3((count > 2) ? start[2] : '\\0'),\n-\t  M_start_pos(start_pos),\n-\t  M_part_of_substitution(inside_substitution)\n-\t{ }\n-\n-\tqualifier(int start_pos,\n-\t          param_qualifier_nt param_qualifier,\n-\t\t  string_type optional_type,\n-\t\t  int inside_substitution)\n-\t: M_qualifier1(param_qualifier),\n-\t  M_optional_type(optional_type),\n-\t  M_start_pos(start_pos),\n-\t  M_part_of_substitution(inside_substitution)\n-\t{ }\n-\n-\tint\n-\tget_start_pos(void) const\n-\t{ return M_start_pos; }\n-\n-\tchar\n-\tfirst_qualifier(void) const\n-\t{ M_cnt = 1; return M_qualifier1; }\n-\n-\tchar\n-\tnext_qualifier(void) const\n-\t{\n-\t  return (++M_cnt == 2) ? M_qualifier2\n-\t                        : ((M_cnt == 3) ? M_qualifier3 : 0);\n-\t}\n-\n-\tstring_type const&\n-\tget_optional_type(void) const\n-\t{ return M_optional_type; }\n-\n-\tbool\n-\tpart_of_substitution(void) const\n-\t{ return M_part_of_substitution; }\n-\n-#if _GLIBCXX_DEMANGLER_CWDEBUG\n-\tfriend std::ostream& operator<<(std::ostream& os, qualifier const& qual)\n-\t{\n-\t  os << (char)qual.M_qualifier1;\n-\t  if (qual.M_qualifier1 == vendor_extension ||\n-\t      qual.M_qualifier1 == array ||\n-\t      qual.M_qualifier1 == pointer_to_member)\n-\t    os << \" [\" << qual.M_optional_type << ']';\n-\t  else if (qual.M_qualifier1 == 'K' ||\n-\t\t   qual.M_qualifier1 == 'V' ||\n-\t\t   qual.M_qualifier1 == 'r')\n-\t  {\n-\t    if (qual.M_qualifier2)\n-\t    {\n-\t      os << (char)qual.M_qualifier2;\n-\t      if (qual.M_qualifier3)\n-\t\tos << (char)qual.M_qualifier3;\n-\t    }\n-\t  }\n-\t  return os;\n-\t}\n-#endif\n-      };\n-\n-    template<typename Tp, typename Allocator>\n-      class qualifier_list\n-      {\n-\ttypedef typename Allocator::template rebind<char>::other\n-\t  char_Allocator;\n-\ttypedef std::basic_string<char, std::char_traits<char>, char_Allocator>\n-\t  string_type;\n-\n-      private:\n-\tmutable bool M_printing_suppressed;\n-\ttypedef qualifier<Tp, Allocator> qual;\n-        typedef typename Allocator::template rebind<qual>::other qual_Allocator;\n-\ttypedef std::vector<qual, qual_Allocator> qual_vector;\n-\tqual_vector M_qualifier_starts;\n-\tsession<Tp, Allocator>& M_demangler;\n-\n-\tvoid decode_KVrA(string_type& prefix, string_type& postfix, int cvq,\n-\t\t\t typename qual_vector::\n-\t\t\t   const_reverse_iterator const& iter_array) const;\n-\n-      public:\n-\tqualifier_list(session<Tp, Allocator>& demangler_obj)\n-\t: M_printing_suppressed(false), M_demangler(demangler_obj)\n-\t{ }\n-\n-\tvoid\n-\tadd_qualifier_start(simple_qualifier_nt simple_qualifier,\n-\t\t\t    int start_pos,\n-\t\t\t    int inside_substitution)\n-\t{ M_qualifier_starts.\n-\t      push_back(qualifier<Tp, Allocator>(start_pos,\n-\t\t  simple_qualifier, inside_substitution)); }\n-\n-\tvoid\n-\tadd_qualifier_start(cv_qualifier_nt cv_qualifier,\n-\t\t\t    int start_pos,\n-\t\t\t    int count,\n-\t\t\t    int inside_substitution)\n-\t{ M_qualifier_starts.\n-\t      push_back(qualifier<Tp, Allocator>(start_pos,\n-\t\t    cv_qualifier, &M_demangler.M_str[start_pos],\n-\t\t    count, inside_substitution)); }\n-\n-\tvoid\n-\tadd_qualifier_start(param_qualifier_nt param_qualifier,\n-\t\t\t    int start_pos,\n-\t\t\t    string_type optional_type,\n-\t\t\t    int inside_substitution)\n-\t{ M_qualifier_starts.\n-\t      push_back(qualifier<Tp, Allocator>(start_pos,\n-\t\t    param_qualifier, optional_type, inside_substitution)); }\n-\n-\tvoid\n-\tdecode_qualifiers(string_type& prefix,\n-\t\t\t  string_type& postfix,\n-\t\t\t  bool member_function_pointer_qualifiers) const;\n-\n-\tbool\n-\tsuppressed(void) const\n-\t{ return M_printing_suppressed; }\n-\n-\tvoid\n-\tprinting_suppressed(void)\n-\t{ M_printing_suppressed = true; }\n-\n-\tsize_t\n-\tsize(void) const\n-\t{ return M_qualifier_starts.size(); }\n-\n-#if _GLIBCXX_DEMANGLER_CWDEBUG\n-\tfriend std::ostream& operator<<(std::ostream& os, qualifier_list const& list)\n-\t{\n-\t  typename qual_vector::const_iterator\n-\t      iter = list.M_qualifier_starts.begin();\n-\t  if (iter != list.M_qualifier_starts.end())\n-\t  {\n-\t    os << \"{ \" << *iter;\n-\t    while (++iter != list.M_qualifier_starts.end())\n-\t      os << \", \" << *iter;\n-\t    os << \" }\";\n-\t  }\n-\t  else\n-\t    os << \"{ }\";\n-\t  return os;\n-\t}\n-#endif\n-      };\n-\n-    struct implementation_details\n-    {\n-      private:\n-        unsigned int M_style;\n-\n-      public:\n-\t// The following flags change the behaviour of the demangler.  The\n-\t// default behaviour is that none of these flags is set.\n-\n-        static unsigned int const style_void = 1;\n-\t// Default behaviour:\t\t\t\tint f()\n-\t// Use (void) instead of ():\t\t\tint f(void)\n-\n-        static unsigned int const style_literal = 2;\n-\t// Default behaviour:\t\t\t\t(long)13,\n-\t//\t\t\t\t\t\t(unsigned long long)19\n-\t// Use extensions 'u', 'l' and 'll' for integral\n-\t// literals (as in template arguments):\t\t13l, 19ull\n-\n-        static unsigned int const style_literal_int = 4;\n-\t// Default behaviour:\t\t\t\t4\n-\t// Use also an explicit\n-\t//   cast for int in literals:\t\t\t(int)4\n-\n-        static unsigned int const style_compact_expr_ops = 8;\n-\t// Default behaviour:\t\t\t\t(i) < (3), sizeof (int)\n-\t// Don't output spaces around\n-\t//   operators in expressions:\t\t\t(i)<(3), sizeof(int)\n-\n-        static unsigned int const style_sizeof_typename = 16;\n-\t// Default behaviour:\t\t\t\tsizeof (X::t)\n-\t// Put 'typename' infront of <nested-name>\n-\t// types inside a 'sizeof':\t\t\tsizeof (typename X::t)\n-\n-      public:\n-\timplementation_details(unsigned int style_flags = 0) :\n-\t    M_style(style_flags) { }\n-\tvirtual ~implementation_details() { }\n-\tbool get_style_void(void) const\n-\t    { return (M_style & style_void); }\n-\tbool get_style_literal(void) const\n-\t    { return (M_style & style_literal); }\n-\tbool get_style_literal_int(void) const\n-\t    { return (M_style & style_literal_int); }\n-\tbool get_style_compact_expr_ops(void) const\n-\t    { return (M_style & style_compact_expr_ops); }\n-\tbool get_style_sizeof_typename(void) const\n-\t    { return (M_style & style_sizeof_typename); }\n-        // This can be overridden by user implementations.\n-        virtual bool decode_real(char* /* output */, unsigned long* /* input */,\n-\t\t\t\t size_t /* size_of_real */) const\n-            { return false; }\n-    };\n-\n-    template<typename Tp, typename Allocator>\n-      class session\n-      {\n-      public:\n-\tfriend class qualifier_list<Tp, Allocator>;\n-\ttypedef typename Allocator::template rebind<char>::other\n-\t    char_Allocator;\n-\ttypedef std::basic_string<char, std::char_traits<char>, char_Allocator>\n-\t    string_type;\n-\n-      private:\n-\tchar const* M_str;\n-\tint M_pos;\n-\tint M_maxpos;\n-\tbool M_result;\n-\tint M_inside_template_args;\n-\tint M_inside_type;\n-\tint M_inside_substitution;\n-\tbool M_saw_destructor;\n-\tbool M_name_is_cdtor;\n-\tbool M_name_is_template;\n-\tbool M_name_is_conversion_operator;\n-\tbool M_template_args_need_space;\n-\tstring_type M_function_name;\n-        typedef typename Allocator::template rebind<int>::other\n-                int_Allocator;\n-        typedef typename Allocator::template rebind<substitution_st>::other\n-                subst_Allocator;\n-\tstd::vector<int, int_Allocator> M_template_arg_pos;\n-\tint M_template_arg_pos_offset;\n-\tstd::vector<substitution_st, subst_Allocator> M_substitutions_pos;\n-\timplementation_details const& M_implementation_details;\n-\ttypedef typename Allocator::template\n-\t    rebind<qualifier_list<Allocator> >::other qualifier_list_Allocator;\n-\tqualifier_list_Allocator M_qualifier_list_alloc;\n-#if _GLIBCXX_DEMANGLER_CWDEBUG\n-\tbool M_inside_add_substitution;\n-#endif\n-\n-      public:\n-\texplicit session(char const* in, int len,\n-\t    implementation_details const& id = implementation_details())\n-\t: M_str(in), M_pos(0), M_maxpos(len - 1), M_result(true),\n-\t  M_inside_template_args(0), M_inside_type(0),\n-\t  M_inside_substitution(0), M_saw_destructor(false),\n-\t  M_name_is_cdtor(false), M_name_is_template(false),\n-\t  M_name_is_conversion_operator(false),\n-\t  M_template_args_need_space(false), M_template_arg_pos_offset(0),\n-\t  M_implementation_details(id)\n-#if _GLIBCXX_DEMANGLER_CWDEBUG\n-\t  , M_inside_add_substitution(false)\n-#endif\n-\t{ }\n-\n-\tstatic int\n-\tdecode_encoding(string_type& output, char const* input, int len,\n-\t  implementation_details const& id = implementation_details());\n-\n-\tbool\n-\tdecode_type(string_type& output,\n-\t            qualifier_list<Tp, Allocator>* qualifiers = NULL)\n-\t{\n-\t  string_type postfix;\n-\t  bool res = decode_type_with_postfix(output, postfix, qualifiers);\n-\t  output += postfix;\n-\t  return res;\n-\t}\n-\n-\tbool\n-\tremaining_input_characters(void) const\n-\t{ return current() != 0; }\n-\n-      private:\n-\tchar\n-\tcurrent(void) const\n-\t{ return (M_pos > M_maxpos) ? 0 : M_str[M_pos]; }\n-\n-\tchar\n-\tnext_peek(void) const\n-\t{ return (M_pos >= M_maxpos) ? 0 : M_str[M_pos + 1]; }\n-\n-\tchar\n-\tnext(void)\n-\t{ return (M_pos >= M_maxpos) ? 0 : M_str[++M_pos]; }\n-\n-\tchar\n-\teat_current(void)\n-\t{ return (M_pos > M_maxpos) ? 0 : M_str[M_pos++]; }\n-\n-\tvoid\n-\tstore(int& saved_pos)\n-\t{ saved_pos = M_pos; }\n-\n-\tvoid\n-\trestore(int saved_pos)\n-\t{ M_pos = saved_pos; M_result = true; }\n-\n-\tvoid\n-\tadd_substitution(int start_pos,\n-\t                 substitution_nt sub_type,\n-\t\t\t int number_of_prefixes);\n-\n-\tbool decode_type_with_postfix(string_type& prefix,\n-\t    string_type& postfix, qualifier_list<Tp, Allocator>* qualifiers = NULL);\n-\tbool decode_bare_function_type(string_type& output);\n-\tbool decode_builtin_type(string_type& output);\n-\tbool decode_call_offset(string_type& output);\n-\tbool decode_class_enum_type(string_type& output);\n-\tbool decode_expression(string_type& output);\n-\tbool decode_literal(string_type& output);\n-\tbool decode_local_name(string_type& output);\n-\tbool decode_name(string_type& output,\n-\t    string_type& nested_name_qualifiers);\n-\tbool decode_nested_name(string_type& output,\n-\t    string_type& qualifiers);\n-\tbool decode_number(string_type& output);\n-\tbool decode_operator_name(string_type& output);\n-\tbool decode_source_name(string_type& output);\n-\tbool decode_substitution(string_type& output,\n-\t    qualifier_list<Tp, Allocator>* qualifiers = NULL);\n-\tbool decode_template_args(string_type& output);\n-\tbool decode_template_param(string_type& output,\n-\t    qualifier_list<Tp, Allocator>* qualifiers = NULL);\n-\tbool decode_unqualified_name(string_type& output);\n-\tbool decode_unscoped_name(string_type& output);\n-\tbool decode_non_negative_decimal_integer(string_type& output);\n-\tbool decode_special_name(string_type& output);\n-        bool decode_real(string_type& output, size_t size_of_real);\n-      };\n-\n-    template<typename Tp, typename Allocator>\n-#if !_GLIBCXX_DEMANGLER_CWDEBUG\n-      inline\n-#endif\n-      void\n-      session<Tp, Allocator>::add_substitution(int start_pos,\n-\t\t\t\t\t   substitution_nt sub_type,\n-\t\t\t\t\t   int number_of_prefixes = 0)\n-      {\n-\tif (!M_inside_substitution)\n-\t{\n-#if _GLIBCXX_DEMANGLER_CWDEBUG\n-\t  if (M_inside_add_substitution)\n-\t    return;\n-#endif\n-\t  M_substitutions_pos.\n-\t      push_back(substitution_st(start_pos,\n-\t\t  sub_type, number_of_prefixes));\n-#if _GLIBCXX_DEMANGLER_CWDEBUG\n-\t  if (!DEBUGCHANNELS::dc::demangler.is_on())\n-\t    return;\n-\t  string_type substitution_name(\"S\");\n-\t  int n = M_substitutions_pos.size() - 1;\n-\t  if (n > 0)\n-\t    substitution_name += (n <= 10) ? (char)(n + '0' - 1)\n-\t\t\t\t\t   : (char)(n + 'A' - 11);\n-\t  substitution_name += '_';\n-\t  string_type subst;\n-\t  int saved_pos = M_pos;\n-\t  M_pos = start_pos;\n-\t  M_inside_add_substitution = true;\n-\t  _GLIBCXX_DEMANGLER_DEBUG( dc::demangler.off() );\n-\t  switch(sub_type)\n-\t  {\n-\t    case type:\n-\t      decode_type(subst);\n-\t      break;\n-\t    case template_template_param:\n-\t      decode_template_param(subst);\n-\t      break;\n-\t    case nested_name_prefix:\n-\t    case nested_name_template_prefix:\n-\t      for (int cnt = number_of_prefixes; cnt > 0; --cnt)\n-\t      {\n-\t\tif (current() == 'I')\n-\t\t{\n-\t\t  subst += ' ';\n-\t\t  decode_template_args(subst);\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t  if (cnt < number_of_prefixes)\n-\t\t    subst += \"::\";\n-\t\t  if (current() == 'S')\n-\t\t    decode_substitution(subst);\n-\t\t  else if (current() == 'T')\n-\t\t    decode_template_param(subst);\n-\t\t  else\n-\t\t    decode_unqualified_name(subst);\n-\t\t}\n-\t      }\n-\t      break;\n-\t    case unscoped_template_name:\n-\t      decode_unscoped_name(subst);\n-\t      break;\n-\t  }\n-\t  M_pos = saved_pos;\n-\t  _GLIBCXX_DEMANGLER_DEBUG( dc::demangler.on() );\n-\t  _GLIBCXX_DEMANGLER_DOUT(dc::demangler,\n-\t      \"Adding substitution \" << substitution_name\n-\t      << \" : \" << subst\n-\t      << \" (from \" << location_ct((char*)__builtin_return_address(0)\n-\t\t                          + builtin_return_address_offset)\n-\t      << \" <- \" << location_ct((char*)__builtin_return_address(1)\n-\t\t                       + builtin_return_address_offset)\n-\t      << \" <- \" << location_ct((char*)__builtin_return_address(2)\n-\t\t                       + builtin_return_address_offset)\n-\t      << \").\");\n-\t  M_inside_add_substitution = false;\n-#endif\n-\t}\n-      }\n-\n-    // We don't want to depend on locale (or include <cctype> for that matter).\n-    // We also don't want to use \"safe-ctype.h\" because that headerfile is not\n-    // available to the users.\n-    inline bool isdigit(char c) { return c >= '0' && c <= '9'; }\n-    inline bool islower(char c) { return c >= 'a' && c <= 'z'; }\n-    inline bool isupper(char c) { return c >= 'A' && c <= 'Z'; }\n-    inline char tolower(char c) { return isupper(c) ? c - 'A' + 'a' : c; }\n-\n-    //\n-    // <non-negative decimal integer> ::= 0\n-    //                                ::= 1|2|3|4|5|6|7|8|9 [<digit>+]\n-    // <digit>                        ::= 0|1|2|3|4|5|6|7|8|9\n-    //\n-    template<typename Tp, typename Allocator>\n-      bool\n-      session<Tp, Allocator>::\n-\t  decode_non_negative_decimal_integer(string_type& output)\n-      {\n-\tchar c = current();\n-\tif (c == '0')\n-\t{\n-\t  output += '0';\n-\t  eat_current();\n-\t}\n-\telse if (!isdigit(c))\n-\t  M_result = false;\n-\telse\n-\t{\n-\t  do\n-\t  {\n-\t    output += c;\n-\t  }\n-\t  while (isdigit((c = next())));\n-\t}\n-\treturn M_result;\n-      }\n-\n-    // <number> ::= [n] <non-negative decimal integer>\n-    //\n-    template<typename Tp, typename Allocator>\n-      bool\n-      session<Tp, Allocator>::decode_number(string_type& output)\n-      {\n-\t_GLIBCXX_DEMANGLER_DOUT_ENTERING(\"decode_number\");\n-\tif (current() != 'n')\n-\t  decode_non_negative_decimal_integer(output);\n-\telse\n-\t{\n-\t  output += '-';\n-\t  eat_current();\n-\t  decode_non_negative_decimal_integer(output);\n-\t}\n-\t_GLIBCXX_DEMANGLER_RETURN;\n-      }\n-\n-    // <builtin-type> ::= v  # void\n-    //                ::= w  # wchar_t\n-    //                ::= b  # bool\n-    //                ::= c  # char\n-    //                ::= a  # signed char\n-    //                ::= h  # unsigned char\n-    //                ::= s  # short\n-    //                ::= t  # unsigned short\n-    //                ::= i  # int\n-    //                ::= j  # unsigned int\n-    //                ::= l  # long\n-    //                ::= m  # unsigned long\n-    //                ::= x  # long long, __int64\n-    //                ::= y  # unsigned long long, __int64\n-    //                ::= n  # __int128\n-    //                ::= o  # unsigned __int128\n-    //                ::= f  # float\n-    //                ::= d  # double\n-    //                ::= e  # long double, __float80\n-    //                ::= g  # __float128\n-    //                ::= z  # ellipsis\n-    //                ::= u <source-name>    # vendor extended type\n-    //\n-    char const* const builtin_type_c[26] =\n-    {\n-      \"signed char\",\t// a\n-      \"bool\",\t\t// b\n-      \"char\",\t\t// c\n-      \"double\",\t\t// d\n-      \"long double\",\t// e\n-      \"float\",\t\t// f\n-      \"__float128\",\t\t// g\n-      \"unsigned char\",\t// h\n-      \"int\",\t\t// i\n-      \"unsigned int\",\t// j\n-      NULL,\t\t\t// k\n-      \"long\",\t\t// l\n-      \"unsigned long\",\t// m\n-      \"__int128\",\t\t// n\n-      \"unsigned __int128\",\t// o\n-      NULL,\t\t\t// p\n-      NULL,\t\t\t// q\n-      NULL,\t\t\t// r\n-      \"short\",\t\t// s\n-      \"unsigned short\",\t// t\n-      NULL,\t\t\t// u\n-      \"void\",\t\t// v\n-      \"wchar_t\",\t\t// w\n-      \"long long\",\t\t// x\n-      \"unsigned long long\",\t// y\n-      \"...\"\t\t\t// z\n-    };\n-\n-    //\n-    template<typename Tp, typename Allocator>\n-      bool\n-      session<Tp, Allocator>::decode_builtin_type(string_type& output)\n-      {\n-\t_GLIBCXX_DEMANGLER_DOUT_ENTERING(\"decode_builtin_type\");\n-\tchar const* bt;\n-\tif (!islower(current()) || !(bt = builtin_type_c[current() - 'a']))\n-\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\toutput += bt;\n-\teat_current();\n-\t_GLIBCXX_DEMANGLER_RETURN;\n-      }\n-\n-    // <class-enum-type> ::= <name>\n-    //\n-    template<typename Tp, typename Allocator>\n-      bool\n-      session<Tp, Allocator>::decode_class_enum_type(string_type& output)\n-      {\n-\t_GLIBCXX_DEMANGLER_DOUT_ENTERING(\"decode_class_enum_type\");\n-\tstring_type nested_name_qualifiers;\n-\tif (!decode_name(output, nested_name_qualifiers))\n-\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\toutput += nested_name_qualifiers;\n-\t_GLIBCXX_DEMANGLER_RETURN;\n-      }\n-\n-    // <substitution> ::=\n-    //   S <seq-id> _\n-    //   S_\n-    //   St # ::std::\n-    //   Sa # ::std::allocator\n-    //   Sb # ::std::basic_string\n-    //   Ss # ::std::basic_string<char, std::char_traits<char>,\n-    //                            std::allocator<char> >\n-    //   Si # ::std::basic_istream<char,  std::char_traits<char> >\n-    //   So # ::std::basic_ostream<char,  std::char_traits<char> >\n-    //   Sd # ::std::basic_iostream<char, std::char_traits<char> >\n-    //\n-    // <seq-id> ::=\n-    //   0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z\n-    //       [<seq-id>]\t# Base 36 number\n-    //\n-    template<typename Tp, typename Allocator>\n-      bool\n-      session<Tp, Allocator>::decode_substitution(string_type& output,\n-\t  qualifier_list<Tp, Allocator>* qualifiers)\n-      {\n-\t_GLIBCXX_DEMANGLER_DOUT_ENTERING(\"decode_substitution\");\n-\tunsigned int value = 0;\n-\tchar c = next();\n-\tif (c != '_')\n-\t{\n-\t  switch(c)\n-\t  {\n-\t    case 'a':\n-\t    {\n-\t      output += \"std::allocator\";\n-\t      if (!M_inside_template_args)\n-\t      {\n-\t\tM_function_name = \"allocator\";\n-\t\tM_name_is_template = true;\n-\t\tM_name_is_cdtor = false;\n-\t\tM_name_is_conversion_operator = false;\n-\t      }\n-\t      eat_current();\n-\t      if (qualifiers)\n-\t\tqualifiers->printing_suppressed();\n-\t      _GLIBCXX_DEMANGLER_RETURN;\n-\t    }\n-\t    case 'b':\n-\t    {\n-\t      output += \"std::basic_string\";\n-\t      if (!M_inside_template_args)\n-\t      {\n-\t\tM_function_name = \"basic_string\";\n-\t\tM_name_is_template = true;\n-\t\tM_name_is_cdtor = false;\n-\t\tM_name_is_conversion_operator = false;\n-\t      }\n-\t      eat_current();\n-\t      if (qualifiers)\n-\t\tqualifiers->printing_suppressed();\n-\t      _GLIBCXX_DEMANGLER_RETURN;\n-\t    }\n-\t    case 'd':\n-\t      output += \"std::iostream\";\n-\t      if (!M_inside_template_args)\n-\t      {\n-\t\tM_function_name = \"iostream\";\n-\t\tM_name_is_template = true;\n-\t\tM_name_is_cdtor = false;\n-\t\tM_name_is_conversion_operator = false;\n-\t      }\n-\t      eat_current();\n-\t      if (qualifiers)\n-\t\tqualifiers->printing_suppressed();\n-\t      _GLIBCXX_DEMANGLER_RETURN;\n-\t    case 'i':\n-\t      output += \"std::istream\";\n-\t      if (!M_inside_template_args)\n-\t      {\n-\t\tM_function_name = \"istream\";\n-\t\tM_name_is_template = true;\n-\t\tM_name_is_cdtor = false;\n-\t\tM_name_is_conversion_operator = false;\n-\t      }\n-\t      eat_current();\n-\t      if (qualifiers)\n-\t\tqualifiers->printing_suppressed();\n-\t      _GLIBCXX_DEMANGLER_RETURN;\n-\t    case 'o':\n-\t      output += \"std::ostream\";\n-\t      if (!M_inside_template_args)\n-\t      {\n-\t\tM_function_name = \"ostream\";\n-\t\tM_name_is_template = true;\n-\t\tM_name_is_cdtor = false;\n-\t\tM_name_is_conversion_operator = false;\n-\t      }\n-\t      eat_current();\n-\t      if (qualifiers)\n-\t\tqualifiers->printing_suppressed();\n-\t      _GLIBCXX_DEMANGLER_RETURN;\n-\t    case 's':\n-\t      output += \"std::string\";\n-\t      if (!M_inside_template_args)\n-\t      {\n-\t\tM_function_name = \"string\";\n-\t\tM_name_is_template = true;\n-\t\tM_name_is_cdtor = false;\n-\t\tM_name_is_conversion_operator = false;\n-\t      }\n-\t      eat_current();\n-\t      if (qualifiers)\n-\t\tqualifiers->printing_suppressed();\n-\t      _GLIBCXX_DEMANGLER_RETURN;\n-\t    case 't':\n-\t      output += \"std\";\n-\t      eat_current();\n-\t      if (qualifiers)\n-\t\tqualifiers->printing_suppressed();\n-\t      _GLIBCXX_DEMANGLER_RETURN;\n-\t    default:\n-\t      for(;; c = next())\n-\t      {\n-\t\tif (isdigit(c))\n-\t\t  value = value * 36 + c - '0';\n-\t\telse if (isupper(c))\n-\t\t  value = value * 36 + c - 'A' + 10;\n-\t\telse if (c == '_')\n-\t\t  break;\n-\t\telse\n-\t\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\t      }\n-\t      ++value;\n-\t      break;\n-\t  }\n-\t}\n-\teat_current();\n-\tif (value >= M_substitutions_pos.size() ||\n-\t    M_inside_type > 20)\t\t\t// Rather than core dump.\n-\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\t++M_inside_substitution;\n-\tint saved_pos = M_pos;\n-\tsubstitution_st& substitution(M_substitutions_pos[value]);\n-\tM_pos = substitution.M_start_pos;\n-\tswitch(substitution.M_type)\n-\t{\n-\t  case type:\n-\t    decode_type(output, qualifiers);\n-\t    break;\n-\t  case template_template_param:\n-\t    decode_template_param(output, qualifiers);\n-\t    break;\n-\t  case nested_name_prefix:\n-\t  case nested_name_template_prefix:\n-\t    for (int cnt = substitution.M_number_of_prefixes; cnt > 0; --cnt)\n-\t    {\n-\t      if (current() == 'I')\n-\t      {\n-\t\tif (M_template_args_need_space)\n-\t\t  output += ' ';\n-\t\tM_template_args_need_space = false;\n-\t\tif (!decode_template_args(output))\n-\t\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\t      }\n-\t      else\n-\t      {\n-\t\tif (cnt < substitution.M_number_of_prefixes)\n-\t\t  output += \"::\";\n-\t\tif (current() == 'S')\n-\t\t{\n-\t\t  if (!decode_substitution(output))\n-\t\t    _GLIBCXX_DEMANGLER_FAILURE;\n-\t\t}\n-\t\telse if (!decode_unqualified_name(output))\n-\t\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\t      }\n-\t    }\n-\t    if (qualifiers)\n-\t      qualifiers->printing_suppressed();\n-\t    break;\n-\t  case unscoped_template_name:\n-\t    decode_unscoped_name(output);\n-\t    if (qualifiers)\n-\t      qualifiers->printing_suppressed();\n-\t    break;\n-\t}\n-\tM_pos = saved_pos;\n-\t--M_inside_substitution;\n-\t_GLIBCXX_DEMANGLER_RETURN;\n-      }\n-\n-    // <template-param> ::= T_\t\t\t# first template parameter\n-    //                  ::= T <parameter-2 non-negative number> _\n-    //\n-    template<typename Tp, typename Allocator>\n-      bool\n-      session<Tp, Allocator>::decode_template_param(string_type& output,\n-\t  qualifier_list<Tp, Allocator>* qualifiers)\n-      {\n-\t_GLIBCXX_DEMANGLER_DOUT_ENTERING(\"decode_template_parameter\");\n-\tif (current() != 'T')\n-\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\tunsigned int value = 0;\n-\tchar c;\n-\tif ((c = next()) != '_')\n-\t{\n-\t  while(isdigit(c))\n-\t  {\n-\t    value = value * 10 + c - '0';\n-\t    c = next();\n-\t  }\n-\t  ++value;\n-\t}\n-\tif (eat_current() != '_')\n-\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\tvalue += M_template_arg_pos_offset;\n-\tif (value >= M_template_arg_pos.size())\n-\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\tint saved_pos = M_pos;\n-\tM_pos = M_template_arg_pos[value];\n-\tif (M_inside_type > 20)\t\t// Rather than core dump.\n-\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\t++M_inside_substitution;\n-\tif (current() == 'X')\n-\t{\n-\t  eat_current();\n-\t  decode_expression(output);\n-\t}\n-\telse if (current() == 'L')\n-\t  decode_literal(output);\n-\telse\n-\t  decode_type(output, qualifiers);\n-\t--M_inside_substitution;\n-\tM_pos = saved_pos;\n-\t_GLIBCXX_DEMANGLER_RETURN;\n-      }\n-\n-    template<typename Tp, typename Allocator>\n-      bool\n-      session<Tp, Allocator>::decode_real(string_type& output, size_t size_of_real)\n-      {\n-\t_GLIBCXX_DEMANGLER_DOUT_ENTERING(\"decode_real\");\n-\n-\tunsigned long words[4];\t// 32 bit per long, maximum of 128 bits.\n-\tunsigned long* word = &words[0];\n-\n-\tint saved_pos;\n-\tstore(saved_pos);\n-\n-\t// The following assumes that leading zeroes are also included in the\n-\t// mangled name, I am not sure that is conforming to the C++-ABI, but\n-\t// it is what g++ does.\n-\tunsigned char nibble, c = current();\n-\tfor(size_t word_cnt = size_of_real / 4; word_cnt > 0; --word_cnt)\n-\t{\n-\t  for (int nibble_cnt = 0; nibble_cnt < 8; ++nibble_cnt)\n-\t  {\n-\t    // Translate character into nibble.\n-\t    if (c < '0' || c > 'f')\n-\t      _GLIBCXX_DEMANGLER_FAILURE;\n-\t    if (c <= '9')\n-\t      nibble = c - '0';\n-\t    else if (c >= 'a')\n-\t      nibble = c - 'a' + 10;\n-\t    else\n-\t      _GLIBCXX_DEMANGLER_FAILURE;\n-\t    // Write nibble into word array.\n-\t    if (nibble_cnt == 0)\n-\t      *word = nibble << 28;\n-\t    else\n-\t      *word |= (nibble << (28 - 4 * nibble_cnt));\n-\t    c = next();\n-\t  }\n-\t  ++word;\n-\t}\n-\tchar buf[24];\n-\tif (M_implementation_details.decode_real(buf, words, size_of_real))\n-\t{\n-\t  output += buf;\n-\t  _GLIBCXX_DEMANGLER_RETURN;\n-\t}\n-\trestore(saved_pos);\n-\n-\toutput += '[';\n-\tc = current();\n-\tfor(size_t nibble_cnt = 0; nibble_cnt < 2 * size_of_real; ++nibble_cnt)\n-\t{\n-\t  if (c < '0' || c > 'f' || (c > '9' && c < 'a'))\n-\t    _GLIBCXX_DEMANGLER_FAILURE;\n-\t  output += c;\n-\t  c = next();\n-\t}\n-\toutput += ']';\n-\n-\t_GLIBCXX_DEMANGLER_RETURN;\n-      }\n-\n-    template<typename Tp, typename Allocator>\n-      bool\n-      session<Tp, Allocator>::decode_literal(string_type& output)\n-      {\n-\t_GLIBCXX_DEMANGLER_DOUT_ENTERING(\"decode_literal\");\n-\teat_current();\t// Eat the 'L'.\n-\tif (current() == '_')\n-\t{\n-\t  if (next() != 'Z')\n-\t    _GLIBCXX_DEMANGLER_FAILURE;\n-\t  eat_current();\n-\t  if ((M_pos += decode_encoding(output, M_str + M_pos,\n-\t\t  M_maxpos - M_pos + 1, M_implementation_details)) < 0)\n-\t    _GLIBCXX_DEMANGLER_FAILURE;\n-\t}\n-\telse\n-\t{\n-\t  // Special cases\n-\t  if (current() == 'b')\n-\t  {\n-\t    if (next() == '0')\n-\t      output += \"false\";\n-\t    else\n-\t      output += \"true\";\n-\t    eat_current();\n-\t    _GLIBCXX_DEMANGLER_RETURN;\n-\t  }\n-\t  char c = current();\n-\t  if ((c == 'i' || c == 'j' || c == 'l' ||\n-\t       c == 'm' || c == 'x' || c == 'y') &&\n-              M_implementation_details.get_style_literal())\n-\t    eat_current();\n-\t  else if (c == 'i' &&\n-\t      !M_implementation_details.get_style_literal_int())\n-\t    eat_current();\n-\t  else\n-\t  {\n-\t    output += '(';\n-\t    if (!decode_type(output))\n-\t      _GLIBCXX_DEMANGLER_FAILURE;\n-\t    output += ')';\n-\t  }\n-\t  if (c >= 'd' && c <= 'g')\n-\t  {\n-\t    size_t size_of_real = (c == 'd') ? sizeof(double) :\n-\t        ((c == 'f') ? sizeof(float) :\n-\t\t(c == 'e') ?  sizeof(long double) : 16);\n-\t    if (!decode_real(output, size_of_real))\n-\t\t_GLIBCXX_DEMANGLER_FAILURE;\n-\t  }\n-\t  else if (!decode_number(output))\n-\t    _GLIBCXX_DEMANGLER_FAILURE;\n-          if (M_implementation_details.get_style_literal())\n-\t  {\n-\t    if (c == 'j' || c == 'm' || c == 'y')\n-\t      output += 'u';\n-\t    if (c == 'l' || c == 'm')\n-\t      output += 'l';\n-\t    if (c == 'x' || c == 'y')\n-\t      output += \"ll\";\n-\t  }\n-\t}\n-\t_GLIBCXX_DEMANGLER_RETURN;\n-      }\n-\n-    // <operator-name> ::=\n-    //   nw\t\t\t\t# new\n-    //   na\t\t\t\t# new[]\n-    //   dl\t\t\t\t# delete\n-    //   da\t\t\t\t# delete[]\n-    //   ps\t\t\t\t# + (unary)\n-    //   ng\t\t\t\t# - (unary)\n-    //   ad\t\t\t\t# & (unary)\n-    //   de\t\t\t\t# * (unary)\n-    //   co\t\t\t\t# ~\n-    //   pl\t\t\t\t# +\n-    //   mi\t\t\t\t# -\n-    //   ml\t\t\t\t# *\n-    //   dv\t\t\t\t# /\n-    //   rm\t\t\t\t# %\n-    //   an\t\t\t\t# &\n-    //   or\t\t\t\t# |\n-    //   eo\t\t\t\t# ^\n-    //   aS\t\t\t\t# =\n-    //   pL\t\t\t\t# +=\n-    //   mI\t\t\t\t# -=\n-    //   mL\t\t\t\t# *=\n-    //   dV\t\t\t\t# /=\n-    //   rM\t\t\t\t# %=\n-    //   aN\t\t\t\t# &=\n-    //   oR\t\t\t\t# |=\n-    //   eO\t\t\t\t# ^=\n-    //   ls\t\t\t\t# <<\n-    //   rs\t\t\t\t# >>\n-    //   lS\t\t\t\t# <<=\n-    //   rS\t\t\t\t# >>=\n-    //   eq\t\t\t\t# ==\n-    //   ne\t\t\t\t# !=\n-    //   lt\t\t\t\t# <\n-    //   gt\t\t\t\t# >\n-    //   le\t\t\t\t# <=\n-    //   ge\t\t\t\t# >=\n-    //   nt\t\t\t\t# !\n-    //   aa\t\t\t\t# &&\n-    //   oo\t\t\t\t# ||\n-    //   pp\t\t\t\t# ++\n-    //   mm\t\t\t\t# --\n-    //   cm\t\t\t\t# ,\n-    //   pm\t\t\t\t# ->*\n-    //   pt\t\t\t\t# ->\n-    //   cl\t\t\t\t# ()\n-    //   ix\t\t\t\t# []\n-    //   qu\t\t\t\t# ?\n-    //   st\t\t\t\t# sizeof (a type)\n-    //   sz\t\t\t\t# sizeof (an expression)\n-    //   cv <type>\t\t\t# (cast)\n-    //   v <digit> <source-name>\t# vendor extended operator\n-    //\n-    // Symbol operator codes exist of two characters, we need to find a\n-    // quick hash so that their names can be looked up in a table.\n-    //\n-    // The puzzle :)\n-    // Shift the rows so that there is at most one character per column.\n-    //\n-    // A perfect solution (Oh no, it's THE MATRIX!):\n-    //                                              horizontal\n-    //    .......................................   offset + 'a'\n-    // a, a||d|||||||||n||||s||||||||||||||||||||       0\n-    // c,  || |||||||lm o||| ||||||||||||||||||||       0\n-    // d,  || a|||e||    l|| ||||||v|||||||||||||       4\n-    // e,  ||  ||| ||     || |||o|q |||||||||||||       8\n-    // g,  ||  ||| ||     || e|| |  ||||||||t||||      15\n-    // i,  ||  ||| ||     ||  || |  |||||||| |||x      15\n-    // l,  |e  ||| ||     st  || |  |||||||| |||       -2\n-    // m,  |   |i| lm         || |  |||||||| |||       -2\n-    // n,  a   e g            t| w  |||||||| |||        1\n-    // o,                      |    ||||o||r |||       16\n-    // p,                      |    ||lm |p  st|       17\n-    // q,                      |    u|   |     |        6\n-    // r,                      m     s   |     |        9\n-    // s,                                t     z       12\n-    //    .......................................\n-    // ^            ^__ second character\n-    // |___ first character\n-    //\n-\n-    // Putting that solution in tables:\n-\n-    char const offset_table_c [1 + CHAR_MAX - CHAR_MIN ] =\n-    {\n-      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-#if (CHAR_MIN < 0)\n-      // Add -CHAR_MIN extra zeroes (128):\n-      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-      //   a    b    c    d    e    f    g    h    i    j    k\n-      0, -97,   0, -97, -93, -89,   0, -82,   0, -82,   0,   0,\n-      //   l    m    n    o    p    q    r    s    t    u    v\n-\t -99, -99, -96, -81, -80, -91, -88, -85,   0,   0,   0,\n-#else\n-      //   a    b    c    d    e    f    g    h    i    j    k\n-      0, 159,   0, 159, 163, 167,   0, 174,   0, 174,   0,   0,\n-      //   l    m    n    o    p    q    r    s    t    u    v\n-\t 157, 157, 160, 175, 176, 165, 168, 171,   0,   0,   0,\n-#endif\n-      // ... more zeros\n-    };\n-\n-    enum xary_nt {\n-      unary,\n-      binary,\n-      trinary\n-    };\n-\n-    struct entry_st\n-    {\n-      char const* opcode;\n-      char const* symbol_name;\n-      xary_nt type;\n-    };\n-\n-    entry_st const symbol_name_table_c[39] = {\n-      { \"aa\",  \"operator&&\", binary },\n-      { \"na\",  \"operator new[]\", unary },\n-      { \"le\",  \"operator<=\", binary },\n-      { \"ad\",  \"operator&\", unary },\n-      { \"da\",  \"operator delete[]\", unary },\n-      { \"ne\",  \"operator!=\", binary },\n-      { \"mi=\", \"operator-\", binary },\n-      { \"ng\",  \"operator-\", unary },\n-      { \"de\",  \"operator*\", unary },\n-      { \"ml=\", \"operator*\", binary },\n-      { \"mm\",  \"operator--\", unary },\n-      { \"cl\",  \"operator()\", unary },\n-      { \"cm\",  \"operator,\", binary },\n-      { \"an=\", \"operator&\", binary },\n-      { \"co\",  \"operator~\", binary },\n-      { \"dl\",  \"operator delete\", unary },\n-      { \"ls=\", \"operator<<\", binary },\n-      { \"lt\",  \"operator<\", binary },\n-      { \"as=\", \"operator\", binary },\n-      { \"ge\",  \"operator>=\", binary },\n-      { \"nt\",  \"operator!\", unary },\n-      { \"rm=\", \"operator%\", binary },\n-      { \"eo=\", \"operator^\", binary },\n-      { \"nw\",  \"operator new\", unary },\n-      { \"eq\",  \"operator==\", binary },\n-      { \"dv=\", \"operator/\", binary },\n-      { \"qu\",  \"operator?\", trinary },\n-      { \"rs=\", \"operator>>\", binary },\n-      { \"pl=\", \"operator+\", binary },\n-      { \"pm\",  \"operator->*\", binary },\n-      { \"oo\",  \"operator||\", binary },\n-      { \"st\",  \"sizeof\", unary },\n-      { \"pp\",  \"operator++\", unary },\n-      { \"or=\", \"operator|\", binary },\n-      { \"gt\",  \"operator>\", binary },\n-      { \"ps\",  \"operator+\", unary },\n-      { \"pt\",  \"operator->\", binary },\n-      { \"sz\",  \"sizeof\", unary },\n-      { \"ix\",  \"operator[]\", unary }\n-    };\n-\n-    template<typename Tp, typename Allocator>\n-      bool\n-      session<Tp, Allocator>::decode_operator_name(string_type& output)\n-      {\n-\t_GLIBCXX_DEMANGLER_DOUT_ENTERING(\"decode_operator_name\");\n-\n-\tchar opcode0 = current();\n-\tchar opcode1 = tolower(next());\n-\n-\tregister char hash;\n-\tif ((hash = offset_table_c[opcode0 - CHAR_MIN]))\n-\t{\n-\t  hash += opcode1;\n-\t  if (\n-#if (CHAR_MIN < 0)\n-\t      hash >= 0 &&\n-#endif\n-\t      hash < 39)\n-\t  {\n-\t    int index = static_cast<int>(static_cast<unsigned char>(hash));\n-\t    entry_st entry = symbol_name_table_c[index];\n-\t    if (entry.opcode[0] == opcode0 && entry.opcode[1] == opcode1\n-\t\t&& (opcode1 == current() || entry.opcode[2] == '='))\n-\t    {\n-\t      output += entry.symbol_name;\n-\t      if (opcode1 != current())\n-\t\toutput += '=';\n-\t      eat_current();\n-\t      if (hash == 16 || hash == 17)\n-\t\tM_template_args_need_space = true;\n-\t      _GLIBCXX_DEMANGLER_RETURN;\n-\t    }\n-\t    else if (opcode0 == 'c' && opcode1 == 'v')\t// casting operator\n-\t    {\n-\t      eat_current();\n-\t      output += \"operator \";\n-\t      if (current() == 'T')\n-\t      {\n-\t\t// This is a templated cast operator.\n-\t\t// It must be of the form \"cvT_I...E\".\n-\t\t// Let M_template_arg_pos already point\n-\t\t// to the template argument.\n-\t\tM_template_arg_pos_offset = M_template_arg_pos.size();\n-\t\tM_template_arg_pos.push_back(M_pos + 3);\n-\t      }\n-\t      if (!decode_type(output))\n-\t\t_GLIBCXX_DEMANGLER_FAILURE;\n-\t      if (!M_inside_template_args)\n-\t\tM_name_is_conversion_operator = true;\n-\t      _GLIBCXX_DEMANGLER_RETURN;\n-\t    }\n-\t  }\n-\t}\n-\t_GLIBCXX_DEMANGLER_FAILURE;\n-      }\n-\n-    //\n-    // <expression> ::= <unary operator-name> <expression>\n-    //              ::= <binary operator-name> <expression> <expression>\n-    //              ::= <trinary operator-name> <expression> <expression> <expression>\n-    //              ::= st <type>\n-    //              ::= <template-param>\n-    //              ::= sr <type> <unqualified-name>                   # dependent name\n-    //              ::= sr <type> <unqualified-name> <template-args>   # dependent template-id\n-    //              ::= <expr-primary>\n-    //\n-    // <expr-primary> ::= L <type> <value number> E     # integer literal\n-    //                ::= L <type> <value float> E\t# floating literal\n-    //                ::= L <mangled-name> E\t\t# external name\n-    //\n-    template<typename Tp, typename Allocator>\n-      bool\n-      session<Tp, Allocator>::decode_expression(string_type& output)\n-      {\n-\t_GLIBCXX_DEMANGLER_DOUT_ENTERING(\"decode_expression\");\n-\tif (current() == 'T')\n-\t{\n-\t  if (!decode_template_param(output))\n-\t    _GLIBCXX_DEMANGLER_FAILURE;\n-\t  _GLIBCXX_DEMANGLER_RETURN;\n-\t}\n-\telse if (current() == 'L')\n-\t{\n-\t  if (!decode_literal(output))\n-\t    _GLIBCXX_DEMANGLER_FAILURE;\n-\t  if (current() != 'E')\n-\t    _GLIBCXX_DEMANGLER_FAILURE;\n-\t  eat_current();\n-\t  _GLIBCXX_DEMANGLER_RETURN;\n-\t}\n-\telse if (current() == 's')\n-\t{\n-\t  char opcode1 = next();\n-\t  if (opcode1 == 't' || opcode1 == 'z')\n-\t  {\n-\t    eat_current();\n-\t    if (M_implementation_details.get_style_compact_expr_ops())\n-\t      output += \"sizeof(\";\n-\t    else\n-\t      output += \"sizeof (\";\n-\t    if (opcode1 == 't')\n-\t    {\n-\t      // I cannot think of a mangled name that is valid for both cases\n-\t      // when just replacing the 't' by a 'z' or vica versa, which\n-\t      // indicates that there is no ambiguity that dictates the need\n-\t      // for a seperate \"st\" case, except to be able catch invalid\n-\t      // mangled names.  However there CAN be ambiguity in the demangled\n-\t      // name when there are both a type and a symbol of the same name,\n-\t      // which then leads to different encoding (of course) with\n-\t      // sizeof (type) or sizeof (expression) respectively, but that\n-\t      // ambiguity is not per se related to \"sizeof\" except that that\n-\t      // is the only place where both a type AND an expression are valid\n-\t      // in as part of a (template function) type.\n-\t      //\n-\t      // Example:\n-\t      //\n-\t      // struct B { typedef int t; };\n-\t      // struct A : public B { static int t[2]; };\n-\t      // template<int i, int j> struct C { typedef int q; };\n-\t      // template<int i, typename T>\n-\t      //   void f(typename C<sizeof (typename T::t),\n-\t      //                     sizeof (T::t)>::q) { }\n-\t      // void instantiate() { f<5, A>(0); }\n-\t      //\n-\t      // Leads to _Z1fILi5E1AEvN1CIXstN1T1tEEXszsrS2_1tEE1qE which\n-\t      // demangles as\n-\t      // void f<5, A>(C<sizeof (T::t), sizeof (T::t)>::q)\n-\t      //\n-\t      // This is ambiguity is very unlikely to happen and it is kind\n-\t      // of fuzzy to detect when adding a 'typename' makes sense.\n-\t      //\n-\t      if (M_implementation_details.get_style_sizeof_typename())\n-\t      {\n-\t\t// We can only get here inside a template parameter,\n-\t\t// so this is syntactically correct if the given type is\n-\t\t// a typedef.  The only disadvantage is that it is inconsistent\n-\t\t// with all other places where the 'typename' keyword should be\n-\t\t// used and we don't.\n-\t\t// With this, the above example will demangle as\n-\t\t// void f<5, A>(C<sizeof (typename T::t), sizeof (T::t)>::q)\n-\t\tif (current() == 'N' ||\t// <nested-name>\n-\t\t\t\t\t  // This should be a safe bet.\n-\t\t    (current() == 'S' &&\n-\t\t     next_peek() == 't'))\t// std::something, guess that\n-\t\t\t\t\t  // this involves a typedef.\n-\t\t  output += \"typename \";\n-\t      }\n-\t      if (!decode_type(output))\n-\t\t_GLIBCXX_DEMANGLER_FAILURE;\n-\t    }\n-\t    else\n-\t    {\n-\t      if (!decode_expression(output))\n-\t\t_GLIBCXX_DEMANGLER_FAILURE;\n-\t    }\n-\t    output += ')';\n-\t    _GLIBCXX_DEMANGLER_RETURN;\n-\t  }\n-\t  else if (current() == 'r')\n-\t  {\n-\t    eat_current();\n-\t    if (!decode_type(output))\n-\t      _GLIBCXX_DEMANGLER_FAILURE;\n-\t    output += \"::\";\n-\t    if (!decode_unqualified_name(output))\n-\t      _GLIBCXX_DEMANGLER_FAILURE;\n-\t    if (current() != 'I' || decode_template_args(output))\n-\t      _GLIBCXX_DEMANGLER_RETURN;\n-\t  }\n-\t}\n-\telse\n-\t{\n-\t  char opcode0 = current();\n-\t  char opcode1 = tolower(next());\n-\n-\t  register char hash;\n-\t  if ((hash = offset_table_c[opcode0 - CHAR_MIN]))\n-\t  {\n-\t    hash += opcode1;\n-\t    if (\n-#if (CHAR_MIN < 0)\n-\t\thash >= 0 &&\n-#endif\n-\t\thash < 39)\n-\t    {\n-\t      int index = static_cast<int>(static_cast<unsigned char>(hash));\n-\t      entry_st entry = symbol_name_table_c[index];\n-\t      if (entry.opcode[0] == opcode0 && entry.opcode[1] == opcode1\n-\t\t  && (opcode1 == current() || entry.opcode[2] == '='))\n-\t      {\n-\t\tchar const* op = entry.symbol_name + 8;\t// Skip \"operator\".\n-\t\tif (*op == ' ')\t\t\t\t// operator new and delete.\n-\t\t  ++op;\n-\t\tif (entry.type == unary)\n-\t\t  output += op;\n-\t\tbool is_eq = (opcode1 != current());\n-\t\teat_current();\n-\t\tif (index == 34 && M_inside_template_args)\t// operator>\n-\t\t  output += '(';\n-\t\toutput += '(';\n-\t\tif (!decode_expression(output))\n-\t\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\t\toutput += ')';\n-\t\tif (entry.type != unary)\n-\t\t{\n-\t          if (!M_implementation_details.get_style_compact_expr_ops())\n-\t\t    output += ' ';\n-\t\t  output += op;\n-\t\t  if (is_eq)\n-\t\t    output += '=';\n-\t          if (!M_implementation_details.get_style_compact_expr_ops())\n-\t\t    output += ' ';\n-\t\t  output += '(';\n-\t\t  if (!decode_expression(output))\n-\t\t    _GLIBCXX_DEMANGLER_FAILURE;\n-\t\t  output += ')';\n-\t\t  if (index == 34 && M_inside_template_args)\n-\t\t    output += ')';\n-\t\t  if (entry.type == trinary)\n-\t\t  {\n-\t\t    if (M_implementation_details.get_style_compact_expr_ops())\n-\t\t      output += \":(\";\n-\t\t    else\n-\t\t      output += \" : (\";\n-\t\t    if (!decode_expression(output))\n-\t\t      _GLIBCXX_DEMANGLER_FAILURE;\n-\t\t    output += ')';\n-\t\t  }\n-\t\t}\n-\t\t_GLIBCXX_DEMANGLER_RETURN;\n-\t      }\n-\t      else if (opcode0 == 'c' &&\n-\t               opcode1 == 'v')\t\t// casting operator.\n-\t      {\n-\t\teat_current();\n-\t\toutput += '(';\n-\t\tif (!decode_type(output))\n-\t\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\t\toutput += \")(\";\n-\t\tif (!decode_expression(output))\n-\t\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\t\toutput += ')';\n-\t\t_GLIBCXX_DEMANGLER_RETURN;\n-\t      }\n-\t    }\n-\t  }\n-\t}\n-\t_GLIBCXX_DEMANGLER_FAILURE;\n-      }\n-\n-    //\n-    // <template-args> ::= I <template-arg>+ E\n-    // <template-arg> ::= <type>\t\t\t# type or template\n-    //                ::= L <type> <value number> E\t# integer literal\n-    //                ::= L <type> <value float> E\t# floating literal\n-    //                ::= L <mangled-name> E\t\t# external name\n-    //                ::= X <expression> E\t\t# expression\n-    template<typename Tp, typename Allocator>\n-      bool\n-      session<Tp, Allocator>::decode_template_args(string_type& output)\n-      {\n-\t_GLIBCXX_DEMANGLER_DOUT_ENTERING(\"decode_template_args\");\n-\tif (eat_current() != 'I')\n-\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\tint prev_size = M_template_arg_pos.size();\n-\t++M_inside_template_args;\n-\tif (M_template_args_need_space)\n-\t{\n-\t  output += ' ';\n-\t  M_template_args_need_space = false;\n-\t}\n-\toutput += '<';\n-\tfor(;;)\n-\t{\n-\t  if (M_inside_template_args == 1 && !M_inside_type)\n-\t    M_template_arg_pos.push_back(M_pos);\n-\t  if (current() == 'X')\n-\t  {\n-\t    eat_current();\n-\t    if (!decode_expression(output))\n-\t      _GLIBCXX_DEMANGLER_FAILURE;\n-\t    if (current() != 'E')\n-\t      _GLIBCXX_DEMANGLER_FAILURE;\n-\t    eat_current();\n-\t  }\n-\t  else if (current() == 'L')\n-\t  {\n-\t    if (!decode_literal(output))\n-\t      _GLIBCXX_DEMANGLER_FAILURE;\n-\t    if (current() != 'E')\n-\t      _GLIBCXX_DEMANGLER_FAILURE;\n-\t    eat_current();\n-\t  }\n-\t  else if (!decode_type(output))\n-\t    _GLIBCXX_DEMANGLER_FAILURE;\n-\t  if (current() == 'E')\n-\t    break;\n-\t  output += \", \";\n-\t}\n-\teat_current();\n-\tif (*(output.rbegin()) == '>')\n-\t  output += ' ';\n-\toutput += '>';\n-\t--M_inside_template_args;\n-\tif (!M_inside_template_args && !M_inside_type)\n-\t{\n-\t  M_name_is_template = true;\n-\t  M_template_arg_pos_offset = prev_size;\n-\t}\n-\t_GLIBCXX_DEMANGLER_RETURN;\n-      }\n-\n-    // <bare-function-type> ::=\n-    //   <signature type>+\t\t# Types are parameter types.\n-    //\n-    // Note that the possible return type of the <bare-function-type>\n-    // has already been eaten before we call this function.  This makes\n-    // our <bare-function-type> slightly different from the one in\n-    // the C++-ABI description.\n-    //\n-    template<typename Tp, typename Allocator>\n-      bool\n-      session<Tp, Allocator>::decode_bare_function_type(string_type& output)\n-      {\n-\t_GLIBCXX_DEMANGLER_DOUT_ENTERING(\"decode_bare_function_type\");\n-\tif (M_saw_destructor)\n-\t{\n-\t  if (eat_current() != 'v' || (current() != 'E' && current() != 0))\n-\t    _GLIBCXX_DEMANGLER_FAILURE;\n-\t  output += \"()\";\n-\t  M_saw_destructor = false;\n-\t  _GLIBCXX_DEMANGLER_RETURN;\n-\t}\n-\tif (current() == 'v' && !M_implementation_details.get_style_void())\n-\t{\n-\t  eat_current();\n-\t  if (current() != 'E' && current() != 0)\n-\t    _GLIBCXX_DEMANGLER_FAILURE;\n-\t  output += \"()\";\n-\t  M_saw_destructor = false;\n-\t  _GLIBCXX_DEMANGLER_RETURN;\n-\t}\n-\toutput += '(';\n-\tM_template_args_need_space = false;\n-\tif (!decode_type(output))\t// Must have at least one parameter.\n-\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\twhile (current() != 'E' && current() != 0)\n-\t{\n-\t  output += \", \";\n-\t  if (!decode_type(output))\n-\t    _GLIBCXX_DEMANGLER_FAILURE;\n-\t}\n-\toutput += ')';\n-\t_GLIBCXX_DEMANGLER_RETURN;\n-      }\n-\n-    // <type> ::=\n-    //   <builtin-type>\t\t# Starts with a lower case character != r.\n-    //   <function-type>\t# Starts with F\n-    //   <class-enum-type>\t# Starts with N, S, C, D, Z, a digit or a lower\n-    //\t\t\t\t# case character.  Since a lower case character\n-    //\t\t\t\t# would be an operator name, that would be an\n-    //\t\t\t\t# error.  The S is a substitution or St\n-    //\t\t\t\t# (::std::).  A 'C' would be a constructor and\n-    //\t\t\t\t# thus also an error.\n-    //   <template-param>\t# Starts with T\n-    //   <substitution>         # Starts with S\n-    //   <template-template-param> <template-args>  # Starts with T or S,\n-    //\t\t\t\t\t\t    # equivalent with the above.\n-    //\n-    //   <array-type>\t\t\t# Starts with A\n-    //   <pointer-to-member-type>\t# Starts with M\n-    //   <CV-qualifiers> <type>\t\t# Starts with r, V or K\n-    //   P <type>   # pointer-to\t# Starts with P\n-    //   R <type>   # reference-to\t# Starts with R\n-    //   C <type>   # complex (C 2000)\t# Starts with C\n-    //   G <type>   # imaginary (C 2000)# Starts with G\n-    //   U <source-name> <type>\t\t# vendor extended type qualifier,\n-    //\t\t\t\t\t# starts with U\n-    //\n-    // <template-template-param> ::= <template-param>\n-    //                           ::= <substitution>\n-\n-    // My own analysis of how to decode qualifiers:\n-    //\n-    // F is a <function-type>, <T> is a <builtin-type>, <class-enum-type>,\n-    //   <template-param> or <template-template-param> <template-args>.\n-    // <Q> represents a series of qualifiers (not G or C).\n-    // <C> is an unqualified type.\n-    // <R> is a qualified type.\n-    // <B> is the bare-function-type without return type.\n-    // <I> is the array index.\n-    //\t\t\t\t\t\tSubstitutions:\n-    // <Q>M<C><Q2>F<R><B>E  ==> R (C::*Q)B Q2\t\"<C>\", \"F<R><B>E\"\n-    //\t\t\t\t\t\t    (<R> and <B> recursive),\n-    //\t\t\t\t\t\t    \"M<C><Q2>F<R><B>E\".\n-    // <Q>F<R><B>E\t    ==> R (Q)B\t\t\"<R>\", \"<B>\" (<B> recursive)\n-    //                                              and \"F<R><B>E\".\n-    //\n-    // Note that if <R> has postfix qualifiers (an array or function), then\n-    // those are added AFTER the (member) function type.  For example:\n-    // <Q>FPA<R><B>E ==> R (*(Q)B) [], where the PA added the prefix\n-    // \"(*\" and the postfix \") []\".\n-    //\n-    // <Q>G<T>\t\t    ==> imaginary T Q\t\"<T>\", \"G<T>\" (<T> recursive).\n-    // <Q>C<T>\t\t    ==> complex T Q\t\"<T>\", \"C<T>\" (<T> recursive).\n-    // <Q><T>\t\t    ==> T Q\t\t\"<T>\" (<T> recursive).\n-    //\n-    // where <Q> is any of:\n-    //\n-    // <Q>P\t\t==> *Q\t\t\t\t\"P...\"\n-    // <Q>R\t\t==> &Q\t\t\t\t\"R...\"\n-    // <Q>[K|V|r]+\t==> [ const| volatile| restrict]+Q\t\"KVr...\"\n-    // <Q>U<S>\t\t==>  SQ\t\t\t\t\"U<S>...\"\n-    // <Q>M<C>\t\t==> C::*Q\t\t\t\"M<C>...\" (<C> recurs.)\n-    // A<I>\t\t==>  [I]\t\t\t\"A<I>...\" (<I> recurs.)\n-    // <Q>A<I>\t\t==>  (Q) [I]\t\t\t\"A<I>...\" (<I> recurs.)\n-    //   Note that when <Q> ends on an A<I2> then the brackets are omitted\n-    //   and no space is written between the two:\n-    //   A<I2>A<I>\t==>  [I2][I]\n-    //   If <Q> ends on [KVr]+, which can happen in combination with\n-    //   substitutions only, then special handling is required, see below.\n-    //\n-    // A <substitution> is handled with an input position switch during which\n-    // new substitutions are turned off.  Because recursive handling of types\n-    // (and therefore the order in which substitutions must be generated) must\n-    // be done left to right, but the generation of Q needs processing right to\n-    // left, substitutions per <type> are generated by reading the input left\n-    // to right and marking the starts of all substitutions only - implicitly\n-    // finishing them at the end of the type.  Then the output and real\n-    // substitutions are generated.\n-    //\n-    // The following comment was for the demangling of g++ version 3.0.x.  The\n-    // mangling (and I believe even the ABI description) have been fixed now\n-    // (as of g++ version 3.1).\n-    //\n-    // g++ 3.0.x only:\n-    // The ABI specifies for pointer-to-member function types the format\n-    // <Q>M<T>F<R><B>E.  In other words, the qualifier <Q2> (see above) is\n-    // implicitely contained in <T> instead of explicitly part of the M format.\n-    // I am convinced that this is a bug in the ABI.  Unfortunately, this is\n-    // how we have to demangle things as it has a direct impact on the order\n-    // in which substitutions are stored.  This ill-formed design results in\n-    // rather ill-formed demangler code too however :/\n-    //\n-    // <Q2> is now explicitely part of the M format.\n-    // For some weird reason, g++ (3.2.1) does not add substitutions for\n-    // qualified member function pointers.  I think that is another bug.\n-    //\n-\n-    // In the case of\n-    // <Q>A<I>\n-    // where <Q> ends on [K|V|r]+ then that part should be processed as\n-    // if it was behind the A<I> instead of in front of it.  This is\n-    // because a constant array of ints is normally always mangled as\n-    // an array of constant ints.  KVr qualifiers can end up in front\n-    // of an array when the array is part of a substitution or template\n-    // parameter, but the demangling should still result in the same\n-    // syntax; thus KA2_i (const array of ints) must result in the same\n-    // demangling as A2_Ki (array of const ints).  As a result we must\n-    // demangle ...[...[[KVr]+A<I0>][KVr]+A<I1>]...[KVr]+A<In>[KVr]+\n-    // as A<I0>A<I1>...A<In>[KVr]+ where each K, V and r in the series\n-    // collapses to a single character at the right of the string.\n-    // For example:\n-    // VA9_KrA6_KVi --> A9_A6_KVri --> int volatile const restrict [9][6]\n-    // Note that substitutions are still added as usual (the translation\n-    // to A9_A6_KVri does not really happen).\n-    //\n-    // This decoding is achieved by delaying the decoding of any sequence\n-    // of [KVrA]'s and processing them together in the order: first the\n-    // short-circuited KVr part and then the arrays.\n-    static int const cvq_K = 1;\t\t// Saw at least one K\n-    static int const cvq_V = 2;\t\t// Saw at least one V\n-    static int const cvq_r = 4;\t\t// Saw at least one r\n-    static int const cvq_A = 8;\t\t// Saw at least one A\n-    static int const cvq_last = 16;\t// No remaining qualifiers.\n-    static int const cvq_A_cnt = 32;\t// Bit 5 and higher represent the\n-\t\t\t\t\t//   number of A's in the series.\n-    // In the function below, iter_array points to the first (right most)\n-    // A in the series, if any.\n-    template<typename Tp, typename Allocator>\n-      void\n-      qualifier_list<Tp, Allocator>::decode_KVrA(\n-          string_type& prefix, string_type& postfix, int cvq,\n-          typename qual_vector::const_reverse_iterator const& iter_array) const\n-\t{\n-\t  _GLIBCXX_DEMANGLER_DOUT_ENTERING3(\"decode_KVrA\");\n-\t  if ((cvq & cvq_K))\n-\t    prefix += \" const\";\n-\t  if ((cvq & cvq_V))\n-\t    prefix += \" volatile\";\n-\t  if ((cvq & cvq_r))\n-\t    prefix += \" restrict\";\n-\t  if ((cvq & cvq_A))\n-\t  {\n-\t    int n = cvq >> 5;\n-\t    for (typename qual_vector::\n-\t        const_reverse_iterator iter = iter_array;\n-\t\titer != M_qualifier_starts.rend(); ++iter)\n-\t    {\n-\t      switch((*iter).first_qualifier())\n-\t      {\n-\t\tcase 'K':\n-\t\tcase 'V':\n-\t\tcase 'r':\n-\t\t  break;\n-\t\tcase 'A':\n-\t\t{\n-\t\t  string_type index = (*iter).get_optional_type();\n-\t\t  if (--n == 0 && (cvq & cvq_last))\n-\t\t    postfix = \" [\" + index + \"]\" + postfix;\n-\t\t  else if (n > 0)\n-\t\t    postfix = \"[\" + index + \"]\" + postfix;\n-\t\t  else\n-\t\t  {\n-\t\t    prefix += \" (\";\n-\t\t    postfix = \") [\" + index + \"]\" + postfix;\n-\t\t  }\n-\t\t  break;\n-\t\t}\n-\t\tdefault:\n-\t\t  _GLIBCXX_DEMANGLER_RETURN3;\n-\t      }\n-\t    }\n-\t  }\n-\t  _GLIBCXX_DEMANGLER_RETURN3;\n-\t}\n-\n-    template<typename Tp, typename Allocator>\n-      void\n-      qualifier_list<Tp, Allocator>::decode_qualifiers(\n-\t  string_type& prefix,\n-\t  string_type& postfix,\n-\t  bool member_function_pointer_qualifiers = false) const\n-      {\n-\t_GLIBCXX_DEMANGLER_DOUT_ENTERING3(\"decode_qualifiers\");\n-\tint cvq = 0;\n-\ttypename qual_vector::const_reverse_iterator iter_array;\n-\tfor(typename qual_vector::\n-\t    const_reverse_iterator iter = M_qualifier_starts.rbegin();\n-\t    iter != M_qualifier_starts.rend(); ++iter)\n-\t{\n-\t  if (!member_function_pointer_qualifiers\n-\t      && !(*iter).part_of_substitution())\n-\t  {\n-\t    int saved_inside_substitution = M_demangler.M_inside_substitution;\n-\t    M_demangler.M_inside_substitution = 0;\n-\t    M_demangler.add_substitution((*iter).get_start_pos(), type);\n-\t    M_demangler.M_inside_substitution = saved_inside_substitution;\n-\t  }\n-\t  char qualifier_char = (*iter).first_qualifier();\n-\t  for(; qualifier_char; qualifier_char = (*iter).next_qualifier())\n-\t  {\n-\t    switch(qualifier_char)\n-\t    {\n-\t      case 'P':\n-\t\tif (cvq)\n-\t\t{\n-\t\t  decode_KVrA(prefix, postfix, cvq, iter_array);\n-\t\t  cvq = 0;\n-\t\t}\n-\t\tprefix += \"*\";\n-\t\tbreak;\n-\t      case 'R':\n-\t\tif (cvq)\n-\t\t{\n-\t\t  decode_KVrA(prefix, postfix, cvq, iter_array);\n-\t\t  cvq = 0;\n-\t\t}\n-\t\tprefix += \"&\";\n-\t\tbreak;\n-\t      case 'K':\n-\t\tcvq |= cvq_K;\n-\t\tcontinue;\n-\t      case 'V':\n-\t\tcvq |= cvq_V;\n-\t\tcontinue;\n-\t      case 'r':\n-\t\tcvq |= cvq_r;\n-\t\tcontinue;\n-\t      case 'A':\n-\t        if (!(cvq & cvq_A))\n-\t\t{\n-\t\t  cvq |= cvq_A;\n-\t\t  iter_array = iter;\n-\t\t}\n-\t\tcvq += cvq_A_cnt;\n-\t\tbreak;\n-\t      case 'M':\n-\t        if (cvq)\n-\t\t{\n-\t\t  decode_KVrA(prefix, postfix, cvq, iter_array);\n-\t\t  cvq = 0;\n-\t\t}\n-\t\tprefix += \" \";\n-\t\tprefix += (*iter).get_optional_type();\n-\t\tprefix += \"::*\";\n-\t\tbreak;\n-\t      case 'U':\n-\t        if (cvq)\n-\t\t{\n-\t\t  decode_KVrA(prefix, postfix, cvq, iter_array);\n-\t\t  cvq = 0;\n-\t\t}\n-\t\tprefix += \" \";\n-\t\tprefix += (*iter).get_optional_type();\n-\t\tbreak;\n-\t      case 'G':\t// Only here so we added a substitution.\n-\t\tbreak;\n-\t    }\n-\t    break;\n-\t  }\n-\t}\n-\tif (cvq)\n-\t  decode_KVrA(prefix, postfix, cvq|cvq_last, iter_array);\n-\tM_printing_suppressed = false;\n-\t_GLIBCXX_DEMANGLER_RETURN3;\n-      }\n-\n-    //\n-    template<typename Tp, typename Allocator>\n-      bool\n-      session<Tp, Allocator>::decode_type_with_postfix(\n-\t  string_type& prefix, string_type& postfix,\n-\t  qualifier_list<Tp, Allocator>* qualifiers)\n-      {\n-\t_GLIBCXX_DEMANGLER_DOUT_ENTERING2(\"decode_type\");\n-\t++M_inside_type;\n-\tbool recursive_template_param_or_substitution_call;\n-\tif (!(recursive_template_param_or_substitution_call = qualifiers))\n-\t{\n-          qualifier_list<Allocator>* raw_qualifiers = M_qualifier_list_alloc.allocate(1);\n-\t  qualifiers = new (raw_qualifiers) qualifier_list<Allocator>(*this);\n-\t}\n-\t// First eat all qualifiers.\n-\tbool failure = false;\n-\tfor(;;)\t\t// So we can use 'continue' to eat the next qualifier.\n-\t{\n-\t  int start_pos = M_pos;\n-\t  switch(current())\n-\t  {\n-\t    case 'P':\n-\t      qualifiers->add_qualifier_start(pointer, start_pos,\n-\t\t  M_inside_substitution);\n-\t      eat_current();\n-\t      continue;\n-\t    case 'R':\n-\t      qualifiers->add_qualifier_start(reference, start_pos,\n-\t\t  M_inside_substitution);\n-\t      eat_current();\n-\t      continue;\n-\t    case 'K':\n-\t    case 'V':\n-\t    case 'r':\n-\t    {\n-\t      char c;\n-\t      int count = 0;\n-\t      do\n-\t      {\n-\t\t++count;\n-\t\tc = next();\n-\t      }\n-\t      while(c == 'K' || c == 'V' || c == 'r');\n-\t      qualifiers->add_qualifier_start(cv_qualifier, start_pos, count,\n-\t\t  M_inside_substitution);\n-\t      continue;\n-\t    }\n-\t    case 'U':\n-\t    {\n-\t      eat_current();\n-\t      string_type source_name;\n-\t      if (!decode_source_name(source_name))\n-\t      {\n-\t\tfailure = true;\n-\t\tbreak;\n-\t      }\n-\t      qualifiers->add_qualifier_start(vendor_extension, start_pos,\n-\t\t  source_name, M_inside_substitution);\n-\t      continue;\n-\t    }\n-\t    case 'A':\n-\t    {\n-\t      // <array-type> ::= A <positive dimension number> _ <element type>\n-\t      //              ::= A [<dimension expression>] _ <element type>\n-\t      //\n-\t      string_type index;\n-\t      int saved_pos;\n-\t      store(saved_pos);\n-\t      if (next() == 'n' || !decode_number(index))\n-\t      {\n-\t\trestore(saved_pos);\n-\t\tif (next() != '_' && !decode_expression(index))\n-\t\t{\n-\t\t  failure = true;\n-\t\t  break;\n-\t\t}\n-\t      }\n-\t      if (eat_current() != '_')\n-\t      {\n-\t\tfailure = true;\n-\t\tbreak;\n-\t      }\n-\t      qualifiers->add_qualifier_start(array, start_pos, index,\n-\t\t  M_inside_substitution);\n-\t      continue;\n-\t    }\n-\t    case 'M':\n-\t    {\n-\t      // <pointer-to-member-type> ::= M <class type> <member type>\n-\t      // <Q>M<C> or <Q>M<C><Q2>F<R><B>E\n-\t      eat_current();\n-\t      string_type class_type;\n-\t      if (!decode_type(class_type))\t\t// Substitution: \"<C>\".\n-\t      {\n-\t\tfailure = true;\n-\t\tbreak;\n-\t      }\n-\t      char c = current();\n-\t      if (c == 'F' || c == 'K' || c == 'V' || c == 'r')\n-\t\t  // Must be CV-qualifiers and a member function pointer.\n-\t      {\n-\t\t// <Q>M<C><Q2>F<R><B>E\t==> R (C::*Q)B Q2\n-\t\t//     substitutions: \"<C>\", \"F<R><B>E\" (<R> and <B>\n-\t\t//                    recursive), \"M<C><Q2>F<R><B>E\".\n-\t\tint count = 0;\n-\t\tint Q2_start_pos = M_pos;\n-\t\twhile(c == 'K' || c == 'V' || c == 'r')\t\t// Decode <Q2>.\n-\t\t{\n-\t\t  ++count;\n-\t\t  c = next();\n-\t\t}\n-\t\tqualifier_list<Tp, Allocator> class_type_qualifiers(*this);\n-\t\tif (count)\n-\t\t  class_type_qualifiers.\n-\t\t      add_qualifier_start(cv_qualifier, Q2_start_pos,\n-\t\t\t  count, M_inside_substitution);\n-\t\tstring_type member_function_qualifiers;\n-\t\t// It is unclear why g++ doesn't add a substitution for\n-\t\t// \"<Q2>F<R><B>E\" as it should I think.\n-\t\tstring_type member_function_qualifiers_postfix;\n-\t\tclass_type_qualifiers.\n-\t\t    decode_qualifiers(member_function_qualifiers,\n-\t\t\tmember_function_qualifiers_postfix, true);\n-\t\tmember_function_qualifiers +=\n-\t\t    member_function_qualifiers_postfix;\n-\t\t// I don't think this substitution is actually ever used.\n-\t\tint function_pos = M_pos;\n-\t\tif (eat_current() != 'F')\n-\t\t{\n-\t\t  failure = true;\n-\t\t  break;\n-\t\t}\n-\t\t// Return type.\n-\t\t// Constructors, destructors and conversion operators don't\n-\t\t// have a return type, but seem to never get here.\n-\t\tstring_type return_type_postfix;\n-\t\tif (!decode_type_with_postfix(prefix, return_type_postfix))\n-\t\t    // substitution: <R> recursive\n-\t\t{\n-\t\t  failure = true;\n-\t\t  break;\n-\t\t}\n-\t\tprefix += \" (\";\n-\t\tprefix += class_type;\n-\t\tprefix += \"::*\";\n-\t\tstring_type bare_function_type;\n-\t\tif (!decode_bare_function_type(bare_function_type)\n-\t\t    || eat_current() != 'E')\t// Substitution: <B> recursive.\n-\t\t{\n-\t\t  failure = true;\n-\t\t  break;\n-\t\t}\n-\t\t// substitution: \"F<R><B>E\".\n-\t\tadd_substitution(function_pos, type);\n-\t\t// substitution: \"M<C><Q2>F<R><B>E\".\n-\t\tadd_substitution(start_pos, type);\n-\t\t// substitution: all qualified types if any.\n-\t\tqualifiers->decode_qualifiers(prefix, postfix);\n-\t\tpostfix += \")\";\n-\t\tpostfix += bare_function_type;\n-\t\tpostfix += member_function_qualifiers;\n-\t\tpostfix += return_type_postfix;\n-\t\tgoto decode_type_exit;\n-\t      }\n-\t      qualifiers->add_qualifier_start(pointer_to_member, start_pos,\n-\t\t  class_type, M_inside_substitution);\n-\t      continue;\n-\t    }\n-\t    default:\n-\t      break;\n-\t  }\n-\t  break;\n-\t}\n-\tif (!failure)\n-\t{\n-\t  // <Q>G<T>\t\t\t==> imaginary T Q\n-\t  //     substitutions: \"<T>\", \"G<T>\" (<T> recursive).\n-\t  // <Q>C<T>\t\t\t==> complex T Q\n-\t  //     substitutions: \"<T>\", \"C<T>\" (<T> recursive).\n-\t  if (current() == 'C' || current() == 'G')\n-\t  {\n-\t    prefix += current() == 'C' ? \"complex \" : \"imaginary \";\n-\t    qualifiers->add_qualifier_start(complex_or_imaginary, M_pos,\n-\t\tM_inside_substitution);\n-\t    eat_current();\n-\t  }\n-\t  int start_pos = M_pos;\n-\t  switch(current())\n-\t  {\n-\t    case 'F':\n-\t    {\n-\t      // <function-type> ::= F [Y] <bare-function-type> E\n-\t      //\n-\t      // Note that g++ never generates the 'Y', but we try to\n-\t      // demangle it anyway.\n-\t      bool extern_C = (next() == 'Y');\n-\t      if (extern_C)\n-\t\teat_current();\n-\n-\t      // <Q>F<R><B>E\t\t==> R (Q)B\n-\t      //     substitution: \"<R>\", \"<B>\" (<B> recursive) and \"F<R><B>E\".\n-\n-\t      // Return type.\n-\t      string_type return_type_postfix;\n-\t      if (!decode_type_with_postfix(prefix, return_type_postfix))\n-\t\t  // Substitution: \"<R>\".\n-\t      {\n-\t\tfailure = true;\n-\t\tbreak;\n-\t      }\n-\t      // Only array and function (pointer) types have a postfix.\n-\t      // In that case we don't want the space but expect something\n-\t      // like prefix is \"int (*\" and postfix is \") [1]\".\n-\t      // We do want the space if this pointer is qualified.\n-\t      if (return_type_postfix.size() == 0 ||\n-\t          (prefix.size() > 0 && *prefix.rbegin() != '*'))\n-\t\tprefix += ' ';\n-\t      prefix += '(';\n-\t      string_type bare_function_type;\n-\t      if (!decode_bare_function_type(bare_function_type)\n-\t\t  // substitution: \"<B>\" (<B> recursive).\n-\t\t  || eat_current() != 'E')\n-\t      {\n-\t\tfailure = true;\n-\t\tbreak;\n-\t      }\n-\t      add_substitution(start_pos, type);  // Substitution: \"F<R><B>E\".\n-\t      qualifiers->decode_qualifiers(prefix, postfix);\n-\t\t  // substitution: all qualified types, if any.\n-\t      postfix += \")\";\n-\t      if (extern_C)\n-\t        postfix += \" [extern \\\"C\\\"] \";\n-\t      postfix += bare_function_type;\n-\t      postfix += return_type_postfix;\n-\t      break;\n-\t    }\n-\t    case 'T':\n-\t      if (!decode_template_param(prefix, qualifiers))\n-\t      {\n-\t\tfailure = true;\n-\t\tbreak;\n-\t      }\n-\t      if (current() == 'I')\n-\t      {\n-\t\tadd_substitution(start_pos, template_template_param);\n-\t\t    // substitution: \"<template-template-param>\".\n-\t\tif (!decode_template_args(prefix))\n-\t\t{\n-\t\t  failure = true;\n-\t\t  break;\n-\t\t}\n-\t      }\n-\t      if (!recursive_template_param_or_substitution_call\n-\t\t  && qualifiers->suppressed())\n-\t      {\n-\t\tadd_substitution(start_pos, type);\n-\t\t    // substitution: \"<template-param>\" or\n-\t\t    // \"<template-template-param> <template-args>\".\n-\t\tqualifiers->decode_qualifiers(prefix, postfix);\n-\t\t    // substitution: all qualified types, if any.\n-\t      }\n-\t      break;\n-\t    case 'S':\n-\t      if (M_pos >= M_maxpos)\n-\t      {\n-\t\tfailure = true;\n-\t\tbreak;\n-\t      }\n-\t      if (M_str[M_pos + 1] != 't')\n-\t      {\n-\t\tif (!decode_substitution(prefix, qualifiers))\n-\t\t{\n-\t\t  failure = true;\n-\t\t  break;\n-\t\t}\n-\t\tif (current() == 'I')\n-\t\t{\n-\t\t  if (!decode_template_args(prefix))\n-\t\t  {\n-\t\t    failure = true;\n-\t\t    break;\n-\t\t  }\n-\t\t  if (!recursive_template_param_or_substitution_call\n-\t\t      && qualifiers->suppressed())\n-\t\t    add_substitution(start_pos, type);\n-\t\t\t// Substitution:\n-\t\t\t//   \"<template-template-param> <template-args>\".\n-\t\t}\n-\t\tif (!recursive_template_param_or_substitution_call\n-\t\t    && qualifiers->suppressed())\n-\t\t  qualifiers->decode_qualifiers(prefix, postfix);\n-\t\t      // Substitution: all qualified types, if any.\n-\t\tbreak;\n-\t      }\n-\t      /* Fall-through for St */\n-\t    case 'N':\n-\t    case 'Z':\n-\t    case '0':\n-\t    case '1':\n-\t    case '2':\n-\t    case '3':\n-\t    case '4':\n-\t    case '5':\n-\t    case '6':\n-\t    case '7':\n-\t    case '8':\n-\t    case '9':\n-\t      // <Q><T>\t\t\t==> T Q\n-\t      //     substitutions: \"<T>\" (<T> recursive).\n-\t      if (!decode_class_enum_type(prefix))\n-\t      {\n-\t\tfailure = true;\n-\t\tbreak;\n-\t      }\n-\t      if (!recursive_template_param_or_substitution_call)\n-\t      {\n-\t\tadd_substitution(start_pos, type);\n-\t\t    // substitution: \"<class-enum-type>\".\n-\t\tqualifiers->decode_qualifiers(prefix, postfix);\n-\t\t    // substitution: all qualified types, if any.\n-\t      }\n-\t      else\n-\t\tqualifiers->printing_suppressed();\n-\t      break;\n-\t    default:\n-\t      // <Q><T>\t\t\t==> T Q\n-\t      //     substitutions: \"<T>\" (<T> recursive).\n-\t      if (!decode_builtin_type(prefix))\n-\t      {\n-\t\tfailure = true;\n-\t\tbreak;\n-\t      }\n-\t      // If decode_type was called from decode_template_param then we\n-\t      // need to suppress calling qualifiers here in order to get a\n-\t      // substitution added anyway (for the <template-param>).\n-\t      if (!recursive_template_param_or_substitution_call)\n-\t\tqualifiers->decode_qualifiers(prefix, postfix);\n-\t      else\n-\t\tqualifiers->printing_suppressed();\n-\t      break;\n-\t  }\n-\t}\n-    decode_type_exit:\n-\t--M_inside_type;\n-\tif (!recursive_template_param_or_substitution_call)\n-\t{\n-\t  qualifiers->~qualifier_list<Allocator>();\n-\t  M_qualifier_list_alloc.deallocate(qualifiers, 1);\n-\t}\n-\tif (failure)\n-\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\t_GLIBCXX_DEMANGLER_RETURN2;\n-      }\n-\n-    // <nested-name> ::= N [<CV-qualifiers>] <prefix> <unqualified-name> E\n-    //               ::= N [<CV-qualifiers>] <template-prefix> <template-args> E\n-    //\n-    // <prefix> ::= <prefix> <unqualified-name>\n-    //          ::= <template-prefix> <template-args>\n-    //          ::= <template-param>\n-    //          ::= # empty\n-    //          ::= <substitution>\n-    //\n-    // <template-prefix> ::= <prefix> <template unqualified-name>\n-    //                   ::= <template-param>\n-    //                   ::= <substitution>\n-    //\n-    template<typename Tp, typename Allocator>\n-      bool\n-      session<Tp, Allocator>::decode_nested_name(string_type& output,\n-\t\t\t\t\t     string_type& qualifiers)\n-      {\n-\t_GLIBCXX_DEMANGLER_DOUT_ENTERING(\"decode_nested_name\");\n-\n-\tif (current() != 'N' || M_pos >= M_maxpos)\n-\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\n-\t// <CV-qualifiers> ::= [r] [V] [K]  # restrict (C99), volatile, const\n-\tchar const* qualifiers_start = &M_str[M_pos + 1];\n-\tfor (char c = next(); c == 'K' || c == 'V' || c == 'r'; c = next());\n-\tfor (char const* qualifier_ptr = &M_str[M_pos - 1];\n-\t     qualifier_ptr >= qualifiers_start; --qualifier_ptr)\n-\t  switch(*qualifier_ptr)\n-\t  {\n-\t    case 'K':\n-\t      qualifiers += \" const\";\n-\t      break;\n-\t    case 'V':\n-\t      qualifiers += \" volatile\";\n-\t      break;\n-\t    case 'r':\n-\t      qualifiers += \" restrict\";\n-\t      break;\n-\t  }\n-\n-\tint number_of_prefixes = 0;\n-\tint substitution_start = M_pos;\n-\tfor(;;)\n-\t{\n-\t  ++number_of_prefixes;\n-\t  if (current() == 'S')\n-\t  {\n-\t    if (!decode_substitution(output))\n-\t      _GLIBCXX_DEMANGLER_FAILURE;\n-\t  }\n-\t  else if (current() == 'I')\n-\t  {\n-\t    if (!decode_template_args(output))\n-\t      _GLIBCXX_DEMANGLER_FAILURE;\n-\t    if (current() != 'E')\n-\t    {\n-\t      // substitution: \"<template-prefix> <template-args>\".\n-\t      add_substitution(substitution_start, nested_name_prefix,\n-\t\t\t       number_of_prefixes);\n-\t    }\n-\t  }\n-\t  else\n-\t  {\n-\t    if (current() == 'T')\n-\t    {\n-\t      if (!decode_template_param(output))\n-\t\t_GLIBCXX_DEMANGLER_FAILURE;\n-\t    }\n-\t    else if (!decode_unqualified_name(output))\n-\t      _GLIBCXX_DEMANGLER_FAILURE;\n-\t    if (current() != 'E')\n-\t    {\n-\t      // substitution: \"<prefix> <unqualified-name>\" or\n-\t      // \"<prefix> <template unqualified-name>\".\n-\t      add_substitution(substitution_start,\n-\t\t  (current() == 'I') ?  nested_name_template_prefix\n-\t\t                     : nested_name_prefix,\n-\t\t  number_of_prefixes);\n-\t    }\n-\t  }\n-\t  if (current() == 'E')\n-\t  {\n-\t    eat_current();\n-\t    _GLIBCXX_DEMANGLER_RETURN;\n-\t  }\n-\t  if (current() != 'I')\n-\t    output += \"::\";\n-\t  else if (M_template_args_need_space)\n-\t    output += ' ';\n-\t  M_template_args_need_space = false;\n-\t}\n-\t_GLIBCXX_DEMANGLER_FAILURE;\n-      }\n-\n-    // <local-name> := Z <function encoding> E <entity name> [<discriminator>]\n-    //              := Z <function encoding> E s [<discriminator>]\n-    // <discriminator> := _ <non-negative number>\n-    //\n-    template<typename Tp, typename Allocator>\n-      bool\n-      session<Tp, Allocator>::decode_local_name(string_type& output)\n-      {\n-\t_GLIBCXX_DEMANGLER_DOUT_ENTERING(\"decode_local_name\");\n-\tif (current() != 'Z' || M_pos >= M_maxpos)\n-\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\tif ((M_pos += decode_encoding(output, M_str + M_pos + 1,\n-\t\tM_maxpos - M_pos, M_implementation_details) + 1) < 0 ||\n-\t\teat_current() != 'E')\n-\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\toutput += \"::\";\n-\tif (current() == 's')\n-\t{\n-\t  eat_current();\n-\t  output += \"string literal\";\n-\t}\n-\telse\n-\t{\n-\t  string_type nested_name_qualifiers;\n-\t  if (!decode_name(output, nested_name_qualifiers))\n-\t    _GLIBCXX_DEMANGLER_FAILURE;\n-\t  output += nested_name_qualifiers;\n-\t}\n-\tstring_type discriminator;\n-\tif (current() == '_' && next() != 'n' && !decode_number(discriminator))\n-\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\t_GLIBCXX_DEMANGLER_RETURN;\n-      }\n-\n-    // <source-name> ::= <positive length number> <identifier>\n-    //\n-    template<typename Tp, typename Allocator>\n-      bool\n-      session<Tp, Allocator>::decode_source_name(string_type& output)\n-      {\n-\t_GLIBCXX_DEMANGLER_DOUT_ENTERING(\"decode_source_name\");\n-\tint length = current() - '0';\n-\tif (length < 1 || length > 9)\n-\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\twhile(isdigit(next()))\n-\t  length = 10 * length + current() - '0';\n-\tchar const* ptr = &M_str[M_pos];\n-\tif (length > 11 && !strncmp(ptr, \"_GLOBAL_\", 8) && ptr[9] == 'N'\n-\t    && ptr[8] == ptr[10])\n-\t{\n-\t  output += \"(anonymous namespace)\";\n-\t  if ((M_pos += length) > M_maxpos + 1)\n-\t    _GLIBCXX_DEMANGLER_FAILURE;\n-\t}\n-\telse\n-\t  while(length--)\n-\t  {\n-\t    if (current() == 0)\n-\t      _GLIBCXX_DEMANGLER_FAILURE;\n-\t    output += eat_current();\n-\t  }\n-\t_GLIBCXX_DEMANGLER_RETURN;\n-      }\n-\n-    // <unqualified-name> ::= <operator-name>\t# Starts with lower case.\n-    //                    ::= <ctor-dtor-name>  # Starts with 'C' or 'D'.\n-    //                    ::= <source-name>\t# Starts with a digit.\n-    //\n-    template<typename Tp, typename Allocator>\n-      bool\n-      session<Tp, Allocator>::decode_unqualified_name(string_type& output)\n-      {\n-\t_GLIBCXX_DEMANGLER_DOUT_ENTERING(\"decode_unqualified_name\");\n-\tif (M_inside_template_args)\n-\t{\n-\t  if (!decode_source_name(output))\n-\t    _GLIBCXX_DEMANGLER_FAILURE;\n-\t}\n-\telse if (isdigit(current()))\n-\t{\n-\t  bool recursive_unqualified_name = (&M_function_name == &output);\n-\t  // This can be a recursive call when we are decoding\n-\t  // an <operator-name> that is a cast operator for a some\n-\t  // <unqualified-name>; for example \"operator Foo()\".\n-\t  // In that case this is thus not a ctor or dtor and we\n-\t  // are not interested in updating M_function_name.\n-\t  if (!recursive_unqualified_name)\n-\t    M_function_name.clear();\n-\t  M_name_is_template = false;\n-\t  M_name_is_cdtor = false;\n-\t  M_name_is_conversion_operator = false;\n-\t  if (!decode_source_name(M_function_name))\n-\t    _GLIBCXX_DEMANGLER_FAILURE;\n-\t  if (!recursive_unqualified_name)\n-\t    output += M_function_name;\n-\t}\n-\telse if (islower(current()))\n-\t{\n-\t  M_function_name.clear();\n-\t  M_name_is_template = false;\n-\t  M_name_is_cdtor = false;\n-\t  M_name_is_conversion_operator = false;\n-\t  if (!decode_operator_name(M_function_name))\n-\t    _GLIBCXX_DEMANGLER_FAILURE;\n-\t  output += M_function_name;\n-\t}\n-\telse if (current() == 'C' || current() == 'D')\n-\t{\n-\t  // <ctor-dtor-name> ::=\n-\t  //   C1\t# complete object (in-charge) constructor\n-\t  //   C2\t# base object (not-in-charge) constructor\n-\t  //   C3\t# complete object (in-charge) allocating constructor\n-\t  //   D0\t# deleting (in-charge) destructor\n-\t  //   D1\t# complete object (in-charge) destructor\n-\t  //   D2\t# base object (not-in-charge) destructor\n-\t  //\n-\t  if (current() == 'C')\n-\t  {\n-\t    char c = next();\n-\t    if (c < '1' || c > '3')\n-\t      _GLIBCXX_DEMANGLER_FAILURE;\n-\t  }\n-\t  else\n-\t  {\n-\t    char c = next();\n-\t    if (c < '0' || c > '2')\n-\t      _GLIBCXX_DEMANGLER_FAILURE;\n-\t    output += '~';\n-\t    M_saw_destructor = true;\n-\t  }\n-\t  M_name_is_cdtor = true;\n-\t  eat_current();\n-\t  output += M_function_name;\n-\t}\n-\telse\n-\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\t_GLIBCXX_DEMANGLER_RETURN;\n-      }\n-\n-    // <unscoped-name> ::=\n-    //   <unqualified-name>\t\t# Starts not with an 'S'\n-    //   St <unqualified-name>\t\t# ::std::\n-    //\n-    template<typename Tp, typename Allocator>\n-      bool\n-      session<Tp, Allocator>::decode_unscoped_name(string_type& output)\n-      {\n-\t_GLIBCXX_DEMANGLER_DOUT_ENTERING(\"decode_unscoped_name\");\n-\tif (current() == 'S')\n-\t{\n-\t  if (next() != 't')\n-\t    _GLIBCXX_DEMANGLER_FAILURE;\n-\t  eat_current();\n-\t  output += \"std::\";\n-\t}\n-\tdecode_unqualified_name(output);\n-\t_GLIBCXX_DEMANGLER_RETURN;\n-      }\n-\n-    // <name> ::=\n-    //   <nested-name>\t\t\t\t# Starts with 'N'\n-    //   <unscoped-template-name> <template-args> # idem\n-    //   <local-name>\t\t\t\t# Starts with 'Z'\n-    //   <unscoped-name>\t\t\t# Starts with 'S', 'C', 'D',\n-    //\t\t\t\t\t\t# a digit or a lower case\n-    //\t\t\t\t\t\t# character.\n-    //\n-    // <unscoped-template-name> ::= <unscoped-name>\n-    //                          ::= <substitution>\n-    template<typename Tp, typename Allocator>\n-      bool\n-      session<Tp, Allocator>::decode_name(string_type& output,\n-\t\t\t\t      string_type& nested_name_qualifiers)\n-      {\n-\t_GLIBCXX_DEMANGLER_DOUT_ENTERING(\"decode_name\");\n-\tint substitution_start = M_pos;\n-\tif (current() == 'S' && (M_pos >= M_maxpos || M_str[M_pos + 1] != 't'))\n-\t{\n-\t  if (!decode_substitution(output))\n-\t    _GLIBCXX_DEMANGLER_FAILURE;\n-\t}\n-\telse if (current() == 'N')\n-\t{\n-\t  decode_nested_name(output, nested_name_qualifiers);\n-\t  _GLIBCXX_DEMANGLER_RETURN;\n-\t}\n-\telse if (current() == 'Z')\n-\t{\n-\t  decode_local_name(output);\n-\t  _GLIBCXX_DEMANGLER_RETURN;\n-\t}\n-\telse if (!decode_unscoped_name(output))\n-\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\tif (current() == 'I')\n-\t{\n-\t  // Must have been an <unscoped-template-name>.\n-\t  add_substitution(substitution_start, unscoped_template_name);\n-\t  if (!decode_template_args(output))\n-\t    _GLIBCXX_DEMANGLER_FAILURE;\n-\t}\n-\tM_template_args_need_space = false;\n-\t_GLIBCXX_DEMANGLER_RETURN;\n-      }\n-\n-    // <call-offset> ::= h <nv-offset> _\n-    //               ::= v <v-offset> _\n-    // <nv-offset>   ::= <offset number>\n-    //     non-virtual base override\n-    //\n-    // <v-offset>    ::= <offset number> _ <virtual offset number>\n-    //     virtual base override, with vcall offset\n-    template<typename Tp, typename Allocator>\n-      bool\n-      session<Tp, Allocator>::decode_call_offset(string_type&\n-#if _GLIBCXX_DEMANGLER_CWDEBUG\n-\t  output\n-#endif\n-\t  )\n-      {\n-\t_GLIBCXX_DEMANGLER_DOUT_ENTERING(\"decode_call_offset\");\n-\tif (current() == 'h')\n-\t{\n-\t  string_type dummy;\n-\t  eat_current();\n-\t  if (decode_number(dummy) && current() == '_')\n-\t  {\n-\t    eat_current();\n-\t    _GLIBCXX_DEMANGLER_RETURN;\n-\t  }\n-\t}\n-\telse if (current() == 'v')\n-\t{\n-\t  string_type dummy;\n-\t  eat_current();\n-\t  if (decode_number(dummy) && current() == '_')\n-\t  {\n-\t    eat_current();\n-\t    if (decode_number(dummy) && current() == '_')\n-\t    {\n-\t      eat_current();\n-\t      _GLIBCXX_DEMANGLER_RETURN;\n-\t    }\n-\t  }\n-\t}\n-\t_GLIBCXX_DEMANGLER_FAILURE;\n-      }\n-\n-    //\n-    // <special-name> ::=\n-    //   TV <type>\t\t\t# virtual table\n-    //   TT <type>\t\t\t# VTT structure (construction\n-    //                                    vtable index).\n-    //   TI <type>\t\t\t# typeinfo structure\n-    //   TS <type>\t\t\t# typeinfo name (null-terminated\n-    //                                    byte string).\n-    //   GV <object name>\t\t# Guard variable for one-time\n-    //\t\t\t\t\t  initialization of static objects in\n-    //\t\t\t\t\t  a local scope.\n-    //   T <call-offset> <base encoding># base is the nominal target function\n-    //\t\t\t\t\t  of thunk.\n-    //   Tc <call-offset> <call-offset> <base encoding> # base is the nominal\n-    //                                    target function of thunk; first\n-    //                                    call-offset is 'this' adjustment;\n-    //\t\t\t\t\t  second call-offset is result\n-    //\t\t\t\t\t  adjustment\n-    //\n-    template<typename Tp, typename Allocator>\n-      bool\n-      session<Tp, Allocator>::decode_special_name(string_type& output)\n-      {\n-\t_GLIBCXX_DEMANGLER_DOUT_ENTERING(\"decode_special_name\");\n-\tif (current() == 'G')\n-\t{\n-\t  if (next() != 'V')\n-\t    _GLIBCXX_DEMANGLER_FAILURE;\n-\t  output += \"guard variable for \";\n-\t  string_type nested_name_qualifiers;\n-\t  eat_current();\n-\t  if (!decode_name(output, nested_name_qualifiers))\n-\t    _GLIBCXX_DEMANGLER_FAILURE;\n-\t  output += nested_name_qualifiers;\n-\t  _GLIBCXX_DEMANGLER_RETURN;\n-\t}\n-\telse if (current() != 'T')\n-\t  _GLIBCXX_DEMANGLER_FAILURE;\n-\tswitch(next())\n-\t{\n-\t  case 'V':\n-\t    output += \"vtable for \";\n-\t    eat_current();\n-\t    decode_type(output);\n-\t    _GLIBCXX_DEMANGLER_RETURN;\n-\t  case 'T':\n-\t    output += \"VTT for \";\n-\t    eat_current();\n-\t    decode_type(output);\n-\t    _GLIBCXX_DEMANGLER_RETURN;\n-\t  case 'I':\n-\t    output += \"typeinfo for \";\n-\t    eat_current();\n-\t    decode_type(output);\n-\t    _GLIBCXX_DEMANGLER_RETURN;\n-\t  case 'S':\n-\t    output += \"typeinfo name for \";\n-\t    eat_current();\n-\t    decode_type(output);\n-\t    _GLIBCXX_DEMANGLER_RETURN;\n-\t  case 'c':\n-\t    output += \"covariant return thunk to \";\n-\t    if (!decode_call_offset(output)\n-\t\t|| !decode_call_offset(output)\n-\t\t|| (M_pos += decode_encoding(output, M_str + M_pos,\n-\t\t    M_maxpos - M_pos + 1, M_implementation_details)) < 0)\n-\t      _GLIBCXX_DEMANGLER_FAILURE;\n-\t    _GLIBCXX_DEMANGLER_RETURN;\n-\t  case 'C':\t\t// GNU extension?\n-\t  {\n-\t    string_type first;\n-\t    output += \"construction vtable for \";\n-\t    eat_current();\n-\t    if (!decode_type(first))\n-\t      _GLIBCXX_DEMANGLER_FAILURE;\n-\t    while(isdigit(current()))\n-\t      eat_current();\n-\t    if (eat_current() != '_')\n-\t      _GLIBCXX_DEMANGLER_FAILURE;\n-\t    if (!decode_type(output))\n-\t      _GLIBCXX_DEMANGLER_FAILURE;\n-\t    output += \"-in-\";\n-\t    output += first;\n-\t    _GLIBCXX_DEMANGLER_RETURN;\n-\t  }\n-\t  default:\n-\t    if (current() == 'v')\n-\t      output += \"virtual thunk to \";\n-\t    else\n-\t      output += \"non-virtual thunk to \";\n-\t    if (!decode_call_offset(output)\n-\t\t|| (M_pos += decode_encoding(output, M_str + M_pos,\n-\t\t    M_maxpos - M_pos + 1, M_implementation_details)) < 0)\n-\t      _GLIBCXX_DEMANGLER_FAILURE;\n-\t    _GLIBCXX_DEMANGLER_RETURN;\n-\t}\n-      }\n-\n-    // <encoding> ::=\n-    //   <function name> <bare-function-type>\t# Starts with 'C', 'D', 'N',\n-    //\t\t\t\t\t\t  'S', a digit or a lower case\n-    //\t\t\t\t\t\t  character.\n-    //   <data name>\t\t\t\t# Idem.\n-    //   <special-name>\t\t\t\t# Starts with 'T' or 'G'.\n-    template<typename Tp, typename Allocator>\n-      int\n-      session<Tp, Allocator>::decode_encoding(string_type& output,\n-          char const* in, int len, implementation_details const& id)\n-      {\n-#if _GLIBCXX_DEMANGLER_CWDEBUG\n-\t_GLIBCXX_DEMANGLER_DOUT(dc::demangler,\n-\t    \"Output thus far: \\\"\" << output << '\"');\n-\tstring_type input(in, len > 0x40000000 ? strlen(in) : len);\n-\t_GLIBCXX_DEMANGLER_DOUT(\n-\t    dc::demangler, \"Entering decode_encoding(\\\"\" << input << \"\\\")\");\n-#endif\n-\tif (len <= 0)\n-\t  return INT_MIN;\n-\tsession<Tp, Allocator> demangler_session(in, len, id);\n-\tstring_type nested_name_qualifiers;\n-\tint saved_pos;\n-\tdemangler_session.store(saved_pos);\n-\tif (demangler_session.decode_special_name(output))\n-\t  return demangler_session.M_pos;\n-\tdemangler_session.restore(saved_pos);\n-\tstring_type name;\n-\tif (!demangler_session.decode_name(name, nested_name_qualifiers))\n-\t  return INT_MIN;\n-\tif (demangler_session.current() == 0\n-\t    || demangler_session.current() == 'E')\n-\t{\n-\t  output += name;\n-\t  output += nested_name_qualifiers;\n-\t  return demangler_session.M_pos;\n-\t}\n-\t// Must have been a <function name>.\n-\tstring_type return_type_postfix;\n-\tif (demangler_session.M_name_is_template\n-\t    && !(demangler_session.M_name_is_cdtor\n-\t         || demangler_session.M_name_is_conversion_operator))\n-\t{\n-\t  // Return type of function\n-\t  if (!demangler_session.decode_type_with_postfix(output,\n-\t      return_type_postfix))\n-\t    return INT_MIN;\n-\t  output += ' ';\n-\t}\n-\toutput += name;\n-\tif (!demangler_session.decode_bare_function_type(output))\n-\t  return INT_MIN;\n-\toutput += nested_name_qualifiers;\n-\toutput += return_type_postfix;\n-\treturn demangler_session.M_pos;\n-      }\n-\n-    } // namespace demangler\n-\n-  // Public interface\n-  template<typename Tp, typename Allocator>\n-    struct demangle\n-    {\n-      typedef typename Allocator::template rebind<char>::other char_Allocator;\n-      typedef std::basic_string<char, std::char_traits<char>, char_Allocator>\n-\t  string_type;\n-      static string_type symbol(char const* in,\n-                                demangler::implementation_details const& id);\n-      static string_type type(char const* in,\n-                              demangler::implementation_details const& id);\n-    };\n-\n-  // demangle::symbol()\n-  //\n-  // Demangle `input' which should be a mangled function name as for\n-  // instance returned by nm(1).\n-  template<typename Tp, typename Allocator>\n-    typename demangle<Tp, Allocator>::string_type\n-    demangle<Tp, Allocator>::symbol(char const* input,\n-                                demangler::implementation_details const& id)\n-    {\n-      // <mangled-name> ::= _Z <encoding>\n-      // <mangled-name> ::= _GLOBAL_ _<type>_ <disambiguation part>\n-      //                    <type> can be I or D (GNU extension)\n-      typedef demangler::session<Tp, Allocator> demangler_type;\n-      string_type result;\n-      bool failure = (input[0] != '_');\n-\n-      if (!failure)\n-      {\n-\tif (input[1] == 'G')\n-\t{\n-\t  if (!strncmp(input, \"_GLOBAL__\", 9)\n-\t      && (input[9] == 'D' || input[9] == 'I')\n-\t      && input[10] == '_')\n-\t  {\n-\t    if (input[9] == 'D')\n-\t      result.assign(\"global destructors keyed to \", 28);\n-\t    else\n-\t      result.assign(\"global constructors keyed to \", 29);\n-\t    // Output the disambiguation part as-is.\n-\t    result += input + 11;\n-\t  }\n-\t  else\n-\t    failure = true;\n-\t}\n-\telse if (input[1] == 'Z')\n-\t{\n-\t  int cnt =\n-\t      demangler_type::decode_encoding(result, input + 2, INT_MAX, id);\n-\t  if (cnt < 0 || input[cnt + 2] != 0)\n-\t    failure = true;\n-\t}\n-\telse\n-\t  failure = true;\n-      }\n-\n-      // Failure to demangle, return the mangled name.\n-      if (failure)\n-\tresult.assign(input, strlen(input));\n-\n-      return result;\n-    }\n-\n-  // demangle::type()\n-  // Demangle `input' which must be a zero terminated mangled type\n-  // name as for instance returned by std::type_info::name().\n-  template<typename Tp, typename Allocator>\n-    typename demangle<Tp, Allocator>::string_type\n-    demangle<Tp, Allocator>::type(char const* input,\n-                              demangler::implementation_details const& id)\n-    {\n-      std::basic_string<char, std::char_traits<char>, Allocator> result;\n-      if (input == NULL)\n-\tresult = \"(null)\";\n-      else\n-      {\n-\tdemangler::session<Tp, Allocator> demangler_session(input, INT_MAX, id);\n-\tif (!demangler_session.decode_type(result)\n-\t    || demangler_session.remaining_input_characters())\n-\t{\n-\t  // Failure to demangle, return the mangled name.\n-\t  result = input;\n-\t}\n-      }\n-      return result;\n-    }\n-} // namespace __gnu_cxx\n-\n-#endif // __DEMANGLE_H"}]}