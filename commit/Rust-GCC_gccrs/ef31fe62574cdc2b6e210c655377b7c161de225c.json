{"sha": "ef31fe62574cdc2b6e210c655377b7c161de225c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYzMWZlNjI1NzRjZGMyYjZlMjEwYzY1NTM3N2I3YzE2MWRlMjI1Yw==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "coudert@clipper.ens.fr", "date": "2006-06-16T17:03:43Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2006-06-16T17:03:43Z"}, "message": "re PR fortran/27965 (invalid \"Array bound mismatch\" runtime error)\n\n\tPR fortran/27965\n\t* trans-array.c (gfc_conv_ss_startstride): Correct the runtime\n\tconditions for bounds-checking. Check for nonzero stride.\n\tDon't check the last dimension of assumed-size arrays. Fix the\n\tdimension displayed in the error message.\n\nFrom-SVN: r114724", "tree": {"sha": "6a56f0f48524b0362136c39a3e17b13fd64e5701", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a56f0f48524b0362136c39a3e17b13fd64e5701"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef31fe62574cdc2b6e210c655377b7c161de225c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef31fe62574cdc2b6e210c655377b7c161de225c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef31fe62574cdc2b6e210c655377b7c161de225c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef31fe62574cdc2b6e210c655377b7c161de225c/comments", "author": null, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1af8dcbf0b77a3e7e99c586f5e6673eead8b53b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1af8dcbf0b77a3e7e99c586f5e6673eead8b53b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1af8dcbf0b77a3e7e99c586f5e6673eead8b53b1"}], "stats": {"total": 101, "additions": 89, "deletions": 12}, "files": [{"sha": "8ac4cef5c64401ccc30c6e51bc0c53906e378d81", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef31fe62574cdc2b6e210c655377b7c161de225c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef31fe62574cdc2b6e210c655377b7c161de225c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ef31fe62574cdc2b6e210c655377b7c161de225c", "patch": "@@ -1,3 +1,11 @@\n+2006-06-16  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\tPR fortran/27965\n+\t* trans-array.c (gfc_conv_ss_startstride): Correct the runtime\n+\tconditions for bounds-checking. Check for nonzero stride.\n+\tDon't check the last dimension of assumed-size arrays. Fix the\n+\tdimension displayed in the error message.\n+\n 2006-06-15  Thomas Koenig <Thomas.Koenig@online.de>\n \n \t* trans-array.h (gfc_trans_create_temp_array):  Add bool"}, {"sha": "941e7115281a2204792ae27c7550246af60d542a", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 81, "deletions": 12, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef31fe62574cdc2b6e210c655377b7c161de225c/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef31fe62574cdc2b6e210c655377b7c161de225c/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=ef31fe62574cdc2b6e210c655377b7c161de225c", "patch": "@@ -2524,9 +2524,10 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n   if (flag_bounds_check)\n     {\n       stmtblock_t block;\n-      tree bound;\n+      tree lbound, ubound;\n       tree end;\n       tree size[GFC_MAX_DIMENSIONS];\n+      tree stride_pos, stride_neg, non_zerosized, tmp2;\n       gfc_ss_info *info;\n       char *msg;\n       int dim;\n@@ -2551,25 +2552,93 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      dim = info->dim[n];\n \t      if (info->ref->u.ar.dimen_type[dim] != DIMEN_RANGE)\n \t\tcontinue;\n+\t      if (n == info->ref->u.ar.dimen - 1\n+\t\t  && (info->ref->u.ar.as->type == AS_ASSUMED_SIZE\n+\t\t      || info->ref->u.ar.as->cp_was_assumed))\n+\t\tcontinue;\n \n \t      desc = ss->data.info.descriptor;\n \n-\t      /* Check lower bound.  */\n-\t      bound = gfc_conv_array_lbound (desc, dim);\n-\t      tmp = info->start[n];\n-\t      tmp = fold_build2 (LT_EXPR, boolean_type_node, tmp, bound);\n+\t      /* This is the run-time equivalent of resolve.c's\n+\t         check_dimension().  The logical is more readable there\n+\t         than it is here, with all the trees.  */\n+\t      lbound = gfc_conv_array_lbound (desc, dim);\n+\t      ubound = gfc_conv_array_ubound (desc, dim);\n+\t      end = gfc_conv_section_upper_bound (ss, n, &block);\n+\n+\t      /* Zero stride is not allowed.  */\n+\t      tmp = fold_build2 (EQ_EXPR, boolean_type_node, info->stride[n],\n+\t\t\t\t gfc_index_zero_node);\n+\t      asprintf (&msg, \"Zero stride is not allowed, for dimension %d \"\n+\t\t\t\"of array '%s'\", info->dim[n]+1,\n+\t\t\tss->expr->symtree->name);\n+\t      gfc_trans_runtime_check (tmp, msg, &block, &ss->expr->where);\n+\t      gfc_free (msg);\n+\n+\t      /* non_zerosized is true when the selected range is not\n+\t         empty.  */\n+\t      stride_pos = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t\t\t\tinfo->stride[n], gfc_index_zero_node);\n+\t      tmp = fold_build2 (LE_EXPR, boolean_type_node, info->start[n],\n+\t\t\t\t end);\n+\t      stride_pos = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t\tstride_pos, tmp);\n+\n+\t      stride_neg = fold_build2 (LT_EXPR, boolean_type_node,\n+\t\t\t\t\tinfo->stride[n], gfc_index_zero_node);\n+\t      tmp = fold_build2 (GE_EXPR, boolean_type_node, info->start[n],\n+\t\t\t\t end);\n+\t      stride_neg = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t\tstride_neg, tmp);\n+\t      non_zerosized = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t\t\t   stride_pos, stride_neg);\n+\n+\t      /* Check the start of the range against the lower and upper\n+\t\t bounds of the array, if the range is not empty.  */\n+\t      tmp = fold_build2 (LT_EXPR, boolean_type_node, info->start[n],\n+\t\t\t\t lbound);\n+\t      tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t non_zerosized, tmp);\n \t      asprintf (&msg, \"%s, lower bound of dimension %d of array '%s'\"\n-\t\t\t\" exceeded\", gfc_msg_bounds, n+1,\n+\t\t\t\" exceeded\", gfc_msg_fault, info->dim[n]+1,\n \t\t\tss->expr->symtree->name);\n \t      gfc_trans_runtime_check (tmp, msg, &block, &ss->expr->where);\n \t      gfc_free (msg);\n \n-\t      /* Check the upper bound.  */\n-\t      bound = gfc_conv_array_ubound (desc, dim);\n-\t      end = gfc_conv_section_upper_bound (ss, n, &block);\n-\t      tmp = fold_build2 (GT_EXPR, boolean_type_node, end, bound);\n+\t      tmp = fold_build2 (GT_EXPR, boolean_type_node, info->start[n],\n+\t\t\t\t ubound);\n+\t      tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t non_zerosized, tmp);\n+\t      asprintf (&msg, \"%s, upper bound of dimension %d of array '%s'\"\n+\t\t\t\" exceeded\", gfc_msg_fault, info->dim[n]+1,\n+\t\t\tss->expr->symtree->name);\n+\t      gfc_trans_runtime_check (tmp, msg, &block, &ss->expr->where);\n+\t      gfc_free (msg);\n+\n+\t      /* Compute the last element of the range, which is not\n+\t\t necessarily \"end\" (think 0:5:3, which doesn't contain 5)\n+\t\t and check it against both lower and upper bounds.  */\n+\t      tmp2 = fold_build2 (MINUS_EXPR, gfc_array_index_type, end,\n+\t\t\t\t  info->start[n]);\n+\t      tmp2 = fold_build2 (TRUNC_MOD_EXPR, gfc_array_index_type, tmp2,\n+\t\t\t\t  info->stride[n]);\n+\t      tmp2 = fold_build2 (MINUS_EXPR, gfc_array_index_type, end,\n+\t\t\t\t  tmp2);\n+\n+\t      tmp = fold_build2 (LT_EXPR, boolean_type_node, tmp2, lbound);\n+\t      tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t non_zerosized, tmp);\n+\t      asprintf (&msg, \"%s, lower bound of dimension %d of array '%s'\"\n+\t\t\t\" exceeded\", gfc_msg_fault, info->dim[n]+1,\n+\t\t\tss->expr->symtree->name);\n+\t      gfc_trans_runtime_check (tmp, msg, &block, &ss->expr->where);\n+\t      gfc_free (msg);\n+\n+\t      tmp = fold_build2 (GT_EXPR, boolean_type_node, tmp2, ubound);\n+\t      tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t non_zerosized, tmp);\n \t      asprintf (&msg, \"%s, upper bound of dimension %d of array '%s'\"\n-\t\t\t\" exceeded\", gfc_msg_bounds, n+1,\n+\t\t\t\" exceeded\", gfc_msg_fault, info->dim[n]+1,\n \t\t\tss->expr->symtree->name);\n \t      gfc_trans_runtime_check (tmp, msg, &block, &ss->expr->where);\n \t      gfc_free (msg);\n@@ -2586,7 +2655,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t  tmp =\n \t\t    fold_build2 (NE_EXPR, boolean_type_node, tmp, size[n]);\n \t\t  asprintf (&msg, \"%s, size mismatch for dimension %d \"\n-\t\t\t    \"of array '%s'\", gfc_msg_bounds, n+1,\n+\t\t\t    \"of array '%s'\", gfc_msg_bounds, info->dim[n]+1,\n \t\t\t    ss->expr->symtree->name);\n \t\t  gfc_trans_runtime_check (tmp, msg, &block, &ss->expr->where);\n \t\t  gfc_free (msg);"}]}