{"sha": "789246d71aa4607e71ce1a87c2e044b5944e22ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg5MjQ2ZDcxYWE0NjA3ZTcxY2UxYTg3YzJlMDQ0YjU5NDRlMjJhYw==", "commit": {"author": {"name": "Sebastian Pop", "email": "pop@cri.ensmp.fr", "date": "2005-06-03T23:27:03Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-06-03T23:27:03Z"}, "message": "tree-data-ref.c (compute_self_dependence): New function.\n\n\n2005-06-03  Sebastian Pop  <pop@cri.ensmp.fr>\n\n\t* tree-data-ref.c (compute_self_dependence): New function.\n\t(compute_all_dependences): Use it.\n\nFrom-SVN: r100565", "tree": {"sha": "e8668484a32fe653ef2fa654205db61ca3a6e327", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8668484a32fe653ef2fa654205db61ca3a6e327"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/789246d71aa4607e71ce1a87c2e044b5944e22ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/789246d71aa4607e71ce1a87c2e044b5944e22ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/789246d71aa4607e71ce1a87c2e044b5944e22ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/789246d71aa4607e71ce1a87c2e044b5944e22ac/comments", "author": null, "committer": null, "parents": [{"sha": "dad732fa41f3ef745ee9dfcde49e6c5387dcef30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dad732fa41f3ef745ee9dfcde49e6c5387dcef30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dad732fa41f3ef745ee9dfcde49e6c5387dcef30"}], "stats": {"total": 45, "additions": 44, "deletions": 1}, "files": [{"sha": "fbdd7b1875b5d945072f64992c198be64d9d3672", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/789246d71aa4607e71ce1a87c2e044b5944e22ac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/789246d71aa4607e71ce1a87c2e044b5944e22ac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=789246d71aa4607e71ce1a87c2e044b5944e22ac", "patch": "@@ -1,3 +1,8 @@\n+2005-06-03  Sebastian Pop  <pop@cri.ensmp.fr>\n+\t\n+\t* tree-data-ref.c (compute_self_dependence): New function.\n+\t(compute_all_dependences): Use it.\n+\n 2005-06-03  Geoffrey Keating  <geoffk@apple.com>\n \n \t* config/darwin.h (LINK_SPEC): Pass -syslibroot to linker"}, {"sha": "50b805b876c22f5d7ed9f710f4fa481455135d59", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/789246d71aa4607e71ce1a87c2e044b5944e22ac/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/789246d71aa4607e71ce1a87c2e044b5944e22ac/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=789246d71aa4607e71ce1a87c2e044b5944e22ac", "patch": "@@ -2177,6 +2177,25 @@ compute_affine_dependence (struct data_dependence_relation *ddr)\n     fprintf (dump_file, \")\\n\");\n }\n \n+/* This computes the dependence relation for the same data\n+   reference into DDR.  */\n+\n+static void\n+compute_self_dependence (struct data_dependence_relation *ddr)\n+{\n+  unsigned int i;\n+\n+  for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n+    {\n+      struct subscript *subscript = DDR_SUBSCRIPT (ddr, i);\n+      \n+      /* The accessed index overlaps for each iteration.  */\n+      SUB_CONFLICTS_IN_A (subscript) = integer_zero_node;\n+      SUB_CONFLICTS_IN_B (subscript) = integer_zero_node;\n+      SUB_LAST_CONFLICT (subscript) = chrec_dont_know;\n+    }\n+}\n+\n \n typedef struct data_dependence_relation *ddr_p;\n DEF_VEC_P(ddr_p);\n@@ -2196,8 +2215,11 @@ compute_all_dependences (varray_type datarefs,\n \n   N = VARRAY_ACTIVE_SIZE (datarefs);\n \n+  /* Note that we specifically skip i == j because it's a self dependence, and\n+     use compute_self_dependence below.  */\n+\n   for (i = 0; i < N; i++)\n-    for (j = i; j < N; j++)\n+    for (j = i + 1; j < N; j++)\n       {\n \tstruct data_reference *a, *b;\n \tstruct data_dependence_relation *ddr;\n@@ -2210,6 +2232,22 @@ compute_all_dependences (varray_type datarefs,\n \tcompute_affine_dependence (ddr);\n \tcompute_subscript_distance (ddr);\n       }\n+\n+  /* Compute self dependence relation of each dataref to itself.  */\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      struct data_reference *a, *b;\n+      struct data_dependence_relation *ddr;\n+\n+      a = VARRAY_GENERIC_PTR (datarefs, i);\n+      b = VARRAY_GENERIC_PTR (datarefs, i);\n+      ddr = initialize_data_dependence_relation (a, b);\n+\n+      VEC_safe_push (ddr_p, heap, *dependence_relations, ddr);\n+      compute_self_dependence (ddr);\n+      compute_subscript_distance (ddr);\n+    }\n }\n \n /* Search the data references in LOOP, and record the information into"}]}