{"sha": "6dc29d3adcadf6f138898a3f43663f806c1a41ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRjMjlkM2FkY2FkZjZmMTM4ODk4YTNmNDM2NjNmODA2YzFhNDFjZQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-10-12T14:25:36Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-10-12T14:25:36Z"}, "message": "tree-loop-distribution.c (break_alias_scc_partitions): Add comment and set PTYPE_SEQUENTIAL for merged partition.\n\n\t* tree-loop-distribution.c (break_alias_scc_partitions): Add comment\n\tand set PTYPE_SEQUENTIAL for merged partition.\n\nFrom-SVN: r253678", "tree": {"sha": "eacd92a2484af59bbca3bd89ef85b70786163ba9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eacd92a2484af59bbca3bd89ef85b70786163ba9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6dc29d3adcadf6f138898a3f43663f806c1a41ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dc29d3adcadf6f138898a3f43663f806c1a41ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dc29d3adcadf6f138898a3f43663f806c1a41ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dc29d3adcadf6f138898a3f43663f806c1a41ce/comments", "author": null, "committer": null, "parents": [{"sha": "f0c216e1162d40748b3bc085146f386ca2109f46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0c216e1162d40748b3bc085146f386ca2109f46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0c216e1162d40748b3bc085146f386ca2109f46"}], "stats": {"total": 15, "additions": 13, "deletions": 2}, "files": [{"sha": "d0eb167072074e3fe2bbfe47d0a0108751ca31c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc29d3adcadf6f138898a3f43663f806c1a41ce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc29d3adcadf6f138898a3f43663f806c1a41ce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6dc29d3adcadf6f138898a3f43663f806c1a41ce", "patch": "@@ -1,3 +1,8 @@\n+2017-10-12  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-loop-distribution.c (break_alias_scc_partitions): Add comment\n+\tand set PTYPE_SEQUENTIAL for merged partition.\n+\n 2017-10-12  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/69728"}, {"sha": "8e8ac7ed5312a228112e2a6cd0923b735ecd7f19", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc29d3adcadf6f138898a3f43663f806c1a41ce/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc29d3adcadf6f138898a3f43663f806c1a41ce/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=6dc29d3adcadf6f138898a3f43663f806c1a41ce", "patch": "@@ -2066,7 +2066,7 @@ break_alias_scc_partitions (struct graph *rdg,\n       auto_vec<enum partition_type> scc_types;\n       struct partition *partition, *first;\n \n-      /* If all paritions in a SCC has the same type, we can simply merge the\n+      /* If all partitions in a SCC have the same type, we can simply merge the\n \t SCC.  This loop finds out such SCCS and record them in bitmap.  */\n       bitmap_set_range (sccs_to_merge, 0, (unsigned) num_sccs);\n       for (i = 0; i < num_sccs; ++i)\n@@ -2079,6 +2079,10 @@ break_alias_scc_partitions (struct graph *rdg,\n \t      if (pg->vertices[j].component != i)\n \t\tcontinue;\n \n+\t      /* Note we Merge partitions of parallel type on purpose, though\n+\t\t the result partition is sequential.  The reason is vectorizer\n+\t\t can do more accurate runtime alias check in this case.  Also\n+\t\t it results in more conservative distribution.  */\n \t      if (first->type != partition->type)\n \t\t{\n \t\t  bitmap_clear_bit (sccs_to_merge, i);\n@@ -2100,7 +2104,7 @@ break_alias_scc_partitions (struct graph *rdg,\n       if (bitmap_count_bits (sccs_to_merge) != (unsigned) num_sccs)\n \t{\n \t  /* Run SCC finding algorithm again, with alias dependence edges\n-\t     skipped.  This is to topologically sort paritions according to\n+\t     skipped.  This is to topologically sort partitions according to\n \t     compilation time known dependence.  Note the topological order\n \t     is stored in the form of pg's post order number.  */\n \t  num_sccs_no_alias = graphds_scc (pg, NULL, pg_skip_alias_edge);\n@@ -2143,6 +2147,8 @@ break_alias_scc_partitions (struct graph *rdg,\n \t      data = (struct pg_vdata *)pg->vertices[k].data;\n \t      gcc_assert (data->id == k);\n \t      data->partition = NULL;\n+\t      /* The result partition of merged SCC must be sequential.  */\n+\t      first->type = PTYPE_SEQUENTIAL;\n \t    }\n \t}\n     }"}]}