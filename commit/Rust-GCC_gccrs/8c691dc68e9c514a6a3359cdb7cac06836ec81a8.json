{"sha": "8c691dc68e9c514a6a3359cdb7cac06836ec81a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM2OTFkYzY4ZTljNTE0YTZhMzM1OWNkYjdjYWMwNjgzNmVjODFhOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-11-20T15:46:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-11-20T15:46:20Z"}, "message": "[multiple changes]\n\n2014-11-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch3.adb (Build_Initialization_Call): Reimplement the\n\tcircuitry which extraacts the [underlying] full view of a\n\tprivate type to handle a case where the private type acts as a\n\tgeneric actual.\n\t* exp_ch5.adb (Expand_Iterator_Loop_Over_Array): Inherit the\n\tloop label form the original loop regardless of whether it came\n\tfrom source.\n\t* sem_attr.adb (Analyze_Attribute): When taking 'Access of an\n\texpression function with a generated body that has not been\n\tanalyzed yet, analyze the body to freeze the expression.\n\t* sem_util.adb (Set_Public_Status_Of): New routine.\n\t(Transfer_Entities): Handle the case where a private type with\n\tan internally generated full view is being transfered and update\n\tits full view.\n\n2014-11-20  Vincent Celier  <celier@adacore.com>\n\n\t* prj-nmsc.adb (Check_Object): If a unit is in a multi-source\n\tfile, its object file is never the same as any other unit.\n\n2014-11-20  Bob Duff  <duff@adacore.com>\n\n\t* s-taskin.adb (Initialize_ATCB): Take into\n\taccount the fact that the domain of the activator can be null\n\tif we're initializing a foreign task.\n\nFrom-SVN: r217877", "tree": {"sha": "9af7a1db084ffb82dcc55272209843e4d28eac06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9af7a1db084ffb82dcc55272209843e4d28eac06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c691dc68e9c514a6a3359cdb7cac06836ec81a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c691dc68e9c514a6a3359cdb7cac06836ec81a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c691dc68e9c514a6a3359cdb7cac06836ec81a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c691dc68e9c514a6a3359cdb7cac06836ec81a8/comments", "author": null, "committer": null, "parents": [{"sha": "1e2d79e2b3c249697931b6bd0ea93f0a4091c2e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e2d79e2b3c249697931b6bd0ea93f0a4091c2e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e2d79e2b3c249697931b6bd0ea93f0a4091c2e6"}], "stats": {"total": 244, "additions": 164, "deletions": 80}, "files": [{"sha": "45870c365d8e1f6979b1fea2e92885775225b811", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c691dc68e9c514a6a3359cdb7cac06836ec81a8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c691dc68e9c514a6a3359cdb7cac06836ec81a8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8c691dc68e9c514a6a3359cdb7cac06836ec81a8", "patch": "@@ -1,3 +1,31 @@\n+2014-11-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch3.adb (Build_Initialization_Call): Reimplement the\n+\tcircuitry which extraacts the [underlying] full view of a\n+\tprivate type to handle a case where the private type acts as a\n+\tgeneric actual.\n+\t* exp_ch5.adb (Expand_Iterator_Loop_Over_Array): Inherit the\n+\tloop label form the original loop regardless of whether it came\n+\tfrom source.\n+\t* sem_attr.adb (Analyze_Attribute): When taking 'Access of an\n+\texpression function with a generated body that has not been\n+\tanalyzed yet, analyze the body to freeze the expression.\n+\t* sem_util.adb (Set_Public_Status_Of): New routine.\n+\t(Transfer_Entities): Handle the case where a private type with\n+\tan internally generated full view is being transfered and update\n+\tits full view.\n+\n+2014-11-20  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-nmsc.adb (Check_Object): If a unit is in a multi-source\n+\tfile, its object file is never the same as any other unit.\n+\n+2014-11-20  Bob Duff  <duff@adacore.com>\n+\n+\t* s-taskin.adb (Initialize_ATCB): Take into\n+\taccount the fact that the domain of the activator can be null\n+\tif we're initializing a foreign task.\n+\n 2014-11-20  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch12.adb: Minor reformatting."}, {"sha": "8bbbdc32374dddd359d8f99873d4ee5f4653ace8", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c691dc68e9c514a6a3359cdb7cac06836ec81a8/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c691dc68e9c514a6a3359cdb7cac06836ec81a8/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=8c691dc68e9c514a6a3359cdb7cac06836ec81a8", "patch": "@@ -1459,7 +1459,7 @@ package body Exp_Ch3 is\n       Discr          : Entity_Id;\n       First_Arg      : Node_Id;\n       Full_Init_Type : Entity_Id;\n-      Full_Type      : Entity_Id := Typ;\n+      Full_Type      : Entity_Id;\n       Init_Type      : Entity_Id;\n       Proc           : Entity_Id;\n \n@@ -1490,20 +1490,38 @@ package body Exp_Ch3 is\n          return Empty_List;\n       end if;\n \n-      --  Go to full view or underlying full view if private type. In the case\n-      --  of successive private derivations, this can require two steps.\n+      Full_Type := Typ;\n \n-      if Is_Private_Type (Full_Type)\n-        and then Present (Full_View (Full_Type))\n-      then\n-         Full_Type := Full_View (Full_Type);\n-      end if;\n+      --  Use the [underlying] full view when dealing with a private type. This\n+      --  may require several steps depending on derivations.\n \n-      if Is_Private_Type (Full_Type)\n-        and then Present (Underlying_Full_View (Full_Type))\n-      then\n-         Full_Type := Underlying_Full_View (Full_Type);\n-      end if;\n+      loop\n+         if Is_Private_Type (Full_Type) then\n+            if Present (Full_View (Full_Type)) then\n+               Full_Type := Full_View (Full_Type);\n+\n+            elsif Present (Underlying_Full_View (Full_Type)) then\n+               Full_Type := Underlying_Full_View (Full_Type);\n+\n+            --  When a private type acts as a generic actual and lacks a full\n+            --  view, use the base type.\n+\n+            elsif Is_Generic_Actual_Type (Full_Type) then\n+               Full_Type := Base_Type (Full_Type);\n+\n+            --  The loop has recovered the [underlying] full view, stop the\n+            --  traversal.\n+\n+            else\n+               exit;\n+            end if;\n+\n+         --  The type is not private, nothing to do\n+\n+         else\n+            exit;\n+         end if;\n+      end loop;\n \n       --  If Typ is derived, the procedure is the initialization procedure for\n       --  the root type. Wrap the argument in an conversion to make it type"}, {"sha": "fc6141a53ad6283bcb0569e226ed4c869bcec97a", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c691dc68e9c514a6a3359cdb7cac06836ec81a8/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c691dc68e9c514a6a3359cdb7cac06836ec81a8/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=8c691dc68e9c514a6a3359cdb7cac06836ec81a8", "patch": "@@ -3766,14 +3766,10 @@ package body Exp_Ch5 is\n          end loop;\n       end if;\n \n-      --  If original loop has a source name, preserve it so it can be\n-      --  recognized by an exit statement in the body of the rewritten loop.\n-      --  This only concerns source names: the generated name of an anonymous\n-      --  loop will be create again during the subsequent analysis below.\n+      --  Inherit the loop identifier from the original loop. This ensures that\n+      --  the scope stack is consistent after the rewriting.\n \n-      if Present (Identifier (N))\n-        and then Comes_From_Source (Identifier (N))\n-      then\n+      if Present (Identifier (N)) then\n          Set_Identifier (Core_Loop, Relocate_Node (Identifier (N)));\n       end if;\n "}, {"sha": "3bfe2d837edd8ea1edc5d0f15e1f29cc67fed509", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c691dc68e9c514a6a3359cdb7cac06836ec81a8/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c691dc68e9c514a6a3359cdb7cac06836ec81a8/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=8c691dc68e9c514a6a3359cdb7cac06836ec81a8", "patch": "@@ -2577,7 +2577,7 @@ package body Prj.Nmsc is\n             Error_Msg_Name_1 := Lang_Index.Display_Name;\n             Error_Msg\n               (Data.Flags,\n-               \"?no compiler specified for language %%\" &\n+               \"?\\no compiler specified for language %%\" &\n                  \", ignoring all its sources\",\n                No_Location, Project);\n \n@@ -2604,15 +2604,15 @@ package body Prj.Nmsc is\n             if Lang_Index.Config.Naming_Data.Spec_Suffix = No_File then\n                Error_Msg\n                  (Data.Flags,\n-                  \"Spec_Suffix not specified for \" &\n+                  \"\\Spec_Suffix not specified for \" &\n                   Get_Name_String (Lang_Index.Name),\n                   No_Location, Project);\n             end if;\n \n             if Lang_Index.Config.Naming_Data.Body_Suffix = No_File then\n                Error_Msg\n                  (Data.Flags,\n-                  \"Body_Suffix not specified for \" &\n+                  \"\\Body_Suffix not specified for \" &\n                   Get_Name_String (Lang_Index.Name),\n                   No_Location, Project);\n             end if;\n@@ -2630,7 +2630,7 @@ package body Prj.Nmsc is\n                Error_Msg_Name_1 := Lang_Index.Display_Name;\n                Error_Msg\n                  (Data.Flags,\n-                  \"no suffixes specified for %%\",\n+                  \"\\no suffixes specified for %%\",\n                   No_Location, Project);\n             end if;\n          end if;\n@@ -3770,7 +3770,7 @@ package body Prj.Nmsc is\n                if Switches /= No_Array_Element then\n                   Error_Msg\n                     (Data.Flags,\n-                     \"?Linker switches not taken into account in library \" &\n+                     \"?\\Linker switches not taken into account in library \" &\n                      \"projects\",\n                      No_Location, Project);\n                end if;\n@@ -6793,7 +6793,7 @@ package body Prj.Nmsc is\n                         Error_Msg_Name_2 := Source.Unit.Name;\n                         Error_Or_Warning\n                           (Data.Flags, Data.Flags.Missing_Source_Files,\n-                           \"source file %% for unit %% not found\",\n+                           \"\\source file %% for unit %% not found\",\n                            No_Location, Project.Project);\n                      end if;\n                   end if;\n@@ -7789,7 +7789,7 @@ package body Prj.Nmsc is\n             Error_Msg_File_1 := Source.File;\n             Error_Msg\n               (Data.Flags,\n-               \"{ cannot be both excluded and an exception file name\",\n+               \"\\{ cannot be both excluded and an exception file name\",\n                No_Location, Project.Project);\n          end if;\n \n@@ -7936,13 +7936,15 @@ package body Prj.Nmsc is\n          if Source /= No_Source\n            and then Source.Replaced_By = No_Source\n            and then Source.Path /= Src.Path\n+           and then Source.Index = 0\n+           and then Src.Index = 0\n            and then Is_Extending (Src.Project, Source.Project)\n          then\n             Error_Msg_File_1 := Src.File;\n             Error_Msg_File_2 := Source.File;\n             Error_Msg\n               (Data.Flags,\n-               \"{ and { have the same object file name\",\n+               \"\\{ and { have the same object file name\",\n                No_Location, Project.Project);\n \n          else"}, {"sha": "1c18a89d43be2409a6d5f55c55173a8874b6ebcb", "filename": "gcc/ada/s-taskin.adb", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c691dc68e9c514a6a3359cdb7cac06836ec81a8/gcc%2Fada%2Fs-taskin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c691dc68e9c514a6a3359cdb7cac06836ec81a8/gcc%2Fada%2Fs-taskin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.adb?ref=8c691dc68e9c514a6a3359cdb7cac06836ec81a8", "patch": "@@ -118,10 +118,17 @@ package body System.Tasking is\n       T.Common.Base_Priority            := Base_Priority;\n       T.Common.Base_CPU                 := Base_CPU;\n \n-      --  The Domain defaults to that of the activator\n-\n-      T.Common.Domain                   :=\n-        (if Domain = null then Self_ID.Common.Domain else Domain);\n+      --  The Domain defaults to that of the activator. But that can be null in\n+      --  the case of foreign threads (see Register_Foreign_Thread), in which\n+      --  case we default to the System_Domain.\n+\n+      if Domain /= null then\n+         T.Common.Domain := Domain;\n+      elsif Self_ID.Common.Domain /= null then\n+         T.Common.Domain := Self_ID.Common.Domain;\n+      else\n+         T.Common.Domain := System_Domain;\n+      end if;\n       pragma Assert (T.Common.Domain /= null);\n \n       T.Common.Current_Priority         := 0;"}, {"sha": "7ff79395be5f685896c141142879731634d8701c", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c691dc68e9c514a6a3359cdb7cac06836ec81a8/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c691dc68e9c514a6a3359cdb7cac06836ec81a8/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=8c691dc68e9c514a6a3359cdb7cac06836ec81a8", "patch": "@@ -10517,10 +10517,8 @@ package body Sem_Attr is\n                   Scop      : constant Entity_Id := Scope (Subp_Id);\n                   Subp_Decl : constant Node_Id   :=\n                                 Unit_Declaration_Node (Subp_Id);\n-\n-                  Flag_Id : Entity_Id;\n-                  HSS     : Node_Id;\n-                  Stmt    : Node_Id;\n+                  Flag_Id   : Entity_Id;\n+                  Subp_Body : Node_Id;\n \n                --  If the access has been taken and the body of the subprogram\n                --  has not been see yet, indirect calls must be protected with\n@@ -10571,24 +10569,20 @@ package body Sem_Attr is\n                   --  generated body is immediately analyzed and the expression\n                   --  is automatically frozen.\n \n-                  if Ekind (Subp_Id) = E_Function\n-                    and then Nkind (Subp_Decl) = N_Subprogram_Declaration\n-                    and then Nkind (Original_Node (Subp_Decl)) =\n-                                                        N_Expression_Function\n+                  if Is_Expression_Function (Subp_Id)\n                     and then Present (Corresponding_Body (Subp_Decl))\n-                    and then not Analyzed (Corresponding_Body (Subp_Decl))\n                   then\n-                     HSS :=\n-                       Handled_Statement_Sequence\n-                         (Unit_Declaration_Node\n-                            (Corresponding_Body (Subp_Decl)));\n+                     Subp_Body :=\n+                       Unit_Declaration_Node (Corresponding_Body (Subp_Decl));\n \n-                     if Present (HSS) then\n-                        Stmt := First (Statements (HSS));\n+                     --  Analyze the body of the expression function to freeze\n+                     --  the expression. This takes care of the case where the\n+                     --  'Access is part of dispatch table initialization and\n+                     --  the generated body of the expression function has not\n+                     --  been analyzed yet.\n \n-                        if Nkind (Stmt) = N_Simple_Return_Statement then\n-                           Freeze_Expression (Expression (Stmt));\n-                        end if;\n+                     if not Analyzed (Subp_Body) then\n+                        Analyze (Subp_Body);\n                      end if;\n                   end if;\n                end;"}, {"sha": "3ae7058c194454d9acce9aaeae132f80a29706b4", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 69, "deletions": 30, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c691dc68e9c514a6a3359cdb7cac06836ec81a8/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c691dc68e9c514a6a3359cdb7cac06836ec81a8/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=8c691dc68e9c514a6a3359cdb7cac06836ec81a8", "patch": "@@ -17619,48 +17619,87 @@ package body Sem_Util is\n    -----------------------\n \n    procedure Transfer_Entities (From : Entity_Id; To : Entity_Id) is\n-      Ent : Entity_Id := First_Entity (From);\n+      procedure Set_Public_Status_Of (Id : Entity_Id);\n+      --  Set the Is_Public attribute of arbitrary entity Id by calling routine\n+      --  Set_Public_Status. If successfull and Id denotes a record type, set\n+      --  the Is_Public attribute of its fields.\n+\n+      --------------------------\n+      -- Set_Public_Status_Of --\n+      --------------------------\n+\n+      procedure Set_Public_Status_Of (Id : Entity_Id) is\n+         Field : Entity_Id;\n+\n+      begin\n+         if not Is_Public (Id) then\n+            Set_Public_Status (Id);\n+\n+            --  When the input entity is a public record type, ensure that all\n+            --  its internal fields are also exposed to the linker. The fields\n+            --  of a class-wide type are never made public.\n+\n+            if Is_Public (Id)\n+              and then Is_Record_Type (Id)\n+              and then not Is_Class_Wide_Type (Id)\n+            then\n+               Field := First_Entity (Id);\n+               while Present (Field) loop\n+                  Set_Is_Public (Field);\n+                  Next_Entity (Field);\n+               end loop;\n+            end if;\n+         end if;\n+      end Set_Public_Status_Of;\n+\n+      --  Local variables\n+\n+      Full_Id : Entity_Id;\n+      Id      : Entity_Id;\n+\n+   --  Start of processing for Transfer_Entities\n \n    begin\n-      if No (Ent) then\n-         return;\n-      end if;\n+      Id := First_Entity (From);\n \n-      if (Last_Entity (To)) = Empty then\n-         Set_First_Entity (To, Ent);\n-      else\n-         Set_Next_Entity (Last_Entity (To), Ent);\n-      end if;\n+      if Present (Id) then\n \n-      Set_Last_Entity (To, Last_Entity (From));\n+         --  Merge the entity chain of the source scope with that of the\n+         --  destination scope.\n \n-      while Present (Ent) loop\n-         Set_Scope (Ent, To);\n+         if Present (Last_Entity (To)) then\n+            Set_Next_Entity (Last_Entity (To), Id);\n+         else\n+            Set_First_Entity (To, Id);\n+         end if;\n \n-         if not Is_Public (Ent) then\n-            Set_Public_Status (Ent);\n+         Set_Last_Entity (To, Last_Entity (From));\n \n-            if Is_Public (Ent) and then Ekind (Ent) = E_Record_Subtype then\n+         --  Inspect the entities of the source scope and update their Scope\n+         --  attribute.\n \n-               --  The components of the propagated Itype must also be public\n+         while Present (Id) loop\n+            Set_Scope            (Id, To);\n+            Set_Public_Status_Of (Id);\n \n-               declare\n-                  Comp : Entity_Id;\n-               begin\n-                  Comp := First_Entity (Ent);\n-                  while Present (Comp) loop\n-                     Set_Is_Public (Comp);\n-                     Next_Entity (Comp);\n-                  end loop;\n-               end;\n+            --  Handle an internally generated full view for a private type\n+\n+            if Is_Private_Type (Id)\n+              and then Present (Full_View (Id))\n+              and then Is_Itype (Full_View (Id))\n+            then\n+               Full_Id := Full_View (Id);\n+\n+               Set_Scope            (Full_Id, To);\n+               Set_Public_Status_Of (Full_Id);\n             end if;\n-         end if;\n \n-         Next_Entity (Ent);\n-      end loop;\n+            Next_Entity (Id);\n+         end loop;\n \n-      Set_First_Entity (From, Empty);\n-      Set_Last_Entity (From, Empty);\n+         Set_First_Entity (From, Empty);\n+         Set_Last_Entity  (From, Empty);\n+      end if;\n    end Transfer_Entities;\n \n    -----------------------"}]}