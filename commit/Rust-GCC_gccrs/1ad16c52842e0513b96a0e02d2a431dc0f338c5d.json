{"sha": "1ad16c52842e0513b96a0e02d2a431dc0f338c5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFkMTZjNTI4NDJlMDUxM2I5NmEwZTAyZDJhNDMxZGMwZjMzOGM1ZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-10-12T18:17:52Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-10-12T18:17:52Z"}, "message": "compiler, runtime: copy string code from Go 1.7\n    \n    Add compiler support for turning concatenating strings into a call to\n    a runtime function that takes the appropriate number of arguments.\n    \n    Rename some local variables in mgc0.c to avoid macros that the new\n    rune.go causes to appear in runtime.inc.\n    \n    Reviewed-on: https://go-review.googlesource.com/30827\n\nFrom-SVN: r241074", "tree": {"sha": "f6eaddf65fba9d031ed9b3008a3c3ba4ff0ebd0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6eaddf65fba9d031ed9b3008a3c3ba4ff0ebd0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ad16c52842e0513b96a0e02d2a431dc0f338c5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ad16c52842e0513b96a0e02d2a431dc0f338c5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ad16c52842e0513b96a0e02d2a431dc0f338c5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/comments", "author": null, "committer": null, "parents": [{"sha": "2ec69f566076547b618447ba5531260c25abed3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ec69f566076547b618447ba5531260c25abed3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ec69f566076547b618447ba5531260c25abed3e"}], "stats": {"total": 1879, "additions": 1096, "deletions": 783}, "files": [{"sha": "9c1ed014fc31009d4939e8dc4afd28c7331c1f3d", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=1ad16c52842e0513b96a0e02d2a431dc0f338c5d", "patch": "@@ -1,4 +1,4 @@\n-c18d9f0e7270144ebd1f67d85995f434bbdab0b0\n+f38ba8837a0c961e18d982930e192132870f3836\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "73be757d8476c1bd5038ce201cc174097c98561e", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=1ad16c52842e0513b96a0e02d2a431dc0f338c5d", "patch": "@@ -1233,13 +1233,17 @@ Escape_analysis_assign::expression(Expression** pexpr)\n \t      case Runtime::MAKESLICE2:\n \t      case Runtime::MAKESLICE1BIG:\n \t      case Runtime::MAKESLICE2BIG:\n-\t      case Runtime::BYTE_ARRAY_TO_STRING:\n-\t      case Runtime::INT_ARRAY_TO_STRING:\n-\t      case Runtime::STRING_TO_BYTE_ARRAY:\n-\t      case Runtime::STRING_TO_INT_ARRAY:\n-\t      case Runtime::STRING_PLUS:\n+\t      case Runtime::SLICEBYTETOSTRING:\n+\t      case Runtime::SLICERUNETOSTRING:\n+\t      case Runtime::STRINGTOSLICEBYTE:\n+\t      case Runtime::STRINGTOSLICERUNE:\n+\t      case Runtime::CONCATSTRINGS:\n+\t      case Runtime::CONCATSTRING2:\n+\t      case Runtime::CONCATSTRING3:\n+\t      case Runtime::CONCATSTRING4:\n+\t      case Runtime::CONCATSTRING5:\n \t      case Runtime::CONSTRUCT_MAP:\n-\t      case Runtime::INT_TO_STRING:\n+\t      case Runtime::INTSTRING:\n \t\t{\n \t\t  Node* runtime_node = Node::make_node(fe);\n \t\t  this->context_->track(runtime_node);\n@@ -1842,21 +1846,25 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n \t\t  case Runtime::MAKESLICE1BIG:\n \t\t  case Runtime::MAKESLICE2BIG:\n \t\t    // DST = make(...).\n-\t\t  case Runtime::BYTE_ARRAY_TO_STRING:\n+\t\t  case Runtime::SLICEBYTETOSTRING:\n \t\t    // DST = string([]byte{...}).\n-\t\t  case Runtime::INT_ARRAY_TO_STRING:\n+\t\t  case Runtime::SLICERUNETOSTRING:\n \t\t    // DST = string([]int{...}).\n-\t\t  case Runtime::STRING_TO_BYTE_ARRAY:\n+\t\t  case Runtime::STRINGTOSLICEBYTE:\n \t\t    // DST = []byte(str).\n-\t\t  case Runtime::STRING_TO_INT_ARRAY:\n-\t\t    // DST = []int(str).\n-\t\t  case Runtime::STRING_PLUS:\n+\t\t  case Runtime::STRINGTOSLICERUNE:\n+\t\t    // DST = []rune(str).\n+\t\t  case Runtime::CONCATSTRINGS:\n+\t\t  case Runtime::CONCATSTRING2:\n+\t\t  case Runtime::CONCATSTRING3:\n+\t\t  case Runtime::CONCATSTRING4:\n+\t\t  case Runtime::CONCATSTRING5:\n \t\t    // DST = str1 + str2\n \t\t  case Runtime::CONSTRUCT_MAP:\n \t\t    // When building a map literal's backend representation.\n \t\t    // Likely never seen here and covered in\n \t\t    // Expression::EXPRESSION_MAP_CONSTRUCTION.\n-\t\t  case Runtime::INT_TO_STRING:\n+\t\t  case Runtime::INTSTRING:\n \t\t    // DST = string(i).\n \t\t  case Runtime::IFACEE2E2:\n \t\t  case Runtime::IFACEI2E2:\n@@ -2614,13 +2622,17 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t\t    case Runtime::MAKESLICE2:\n \t\t    case Runtime::MAKESLICE1BIG:\n \t\t    case Runtime::MAKESLICE2BIG:\n-\t\t    case Runtime::BYTE_ARRAY_TO_STRING:\n-\t\t    case Runtime::INT_ARRAY_TO_STRING:\n-\t\t    case Runtime::STRING_TO_BYTE_ARRAY:\n-\t\t    case Runtime::STRING_TO_INT_ARRAY:\n-\t\t    case Runtime::STRING_PLUS:\n+\t\t    case Runtime::SLICEBYTETOSTRING:\n+\t\t    case Runtime::SLICERUNETOSTRING:\n+\t\t    case Runtime::STRINGTOSLICEBYTE:\n+\t\t    case Runtime::STRINGTOSLICERUNE:\n+\t\t    case Runtime::CONCATSTRINGS:\n+\t\t    case Runtime::CONCATSTRING2:\n+\t\t    case Runtime::CONCATSTRING3:\n+\t\t    case Runtime::CONCATSTRING4:\n+\t\t    case Runtime::CONCATSTRING5:\n \t\t    case Runtime::CONSTRUCT_MAP:\n-\t\t    case Runtime::INT_TO_STRING:\n+\t\t    case Runtime::INTSTRING:\n \t\t    case Runtime::CONVERT_INTERFACE:\n \t\t      // All runtime calls that involve allocation of memory\n \t\t      // except new.  Runtime::NEW gets lowered into an"}, {"sha": "40c8a4e2df7bb46fde77646741cfa012dda2e08b", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 215, "deletions": 37, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=1ad16c52842e0513b96a0e02d2a431dc0f338c5d", "patch": "@@ -3419,7 +3419,8 @@ Type_conversion_expression::do_get_backend(Translate_context* context)\n \t}\n \n       Expression* i2s_expr =\n-          Runtime::make_call(Runtime::INT_TO_STRING, loc, 1, this->expr_);\n+          Runtime::make_call(Runtime::INTSTRING, loc, 2,\n+\t\t\t     Expression::make_nil(loc), this->expr_);\n       return Expression::make_cast(type, i2s_expr, loc)->get_backend(context);\n     }\n   else if (type->is_string_type() && expr_type->is_slice_type())\n@@ -3431,16 +3432,14 @@ Type_conversion_expression::do_get_backend(Translate_context* context)\n \n       Runtime::Function code;\n       if (e->integer_type()->is_byte())\n-        code = Runtime::BYTE_ARRAY_TO_STRING;\n+        code = Runtime::SLICEBYTETOSTRING;\n       else\n         {\n           go_assert(e->integer_type()->is_rune());\n-          code = Runtime::INT_ARRAY_TO_STRING;\n+          code = Runtime::SLICERUNETOSTRING;\n         }\n-      Expression* valptr = a->get_value_pointer(gogo, this->expr_);\n-      Expression* len = a->get_length(gogo, this->expr_);\n-      return Runtime::make_call(code, loc, 2, valptr,\n-\t\t\t\tlen)->get_backend(context);\n+      return Runtime::make_call(code, loc, 2, Expression::make_nil(loc),\n+\t\t\t\tthis->expr_)->get_backend(context);\n     }\n   else if (type->is_slice_type() && expr_type->is_string_type())\n     {\n@@ -3449,13 +3448,15 @@ Type_conversion_expression::do_get_backend(Translate_context* context)\n \n       Runtime::Function code;\n       if (e->integer_type()->is_byte())\n-\tcode = Runtime::STRING_TO_BYTE_ARRAY;\n+\tcode = Runtime::STRINGTOSLICEBYTE;\n       else\n \t{\n \t  go_assert(e->integer_type()->is_rune());\n-\t  code = Runtime::STRING_TO_INT_ARRAY;\n+\t  code = Runtime::STRINGTOSLICERUNE;\n \t}\n-      Expression* s2a = Runtime::make_call(code, loc, 1, this->expr_);\n+      Expression* s2a = Runtime::make_call(code, loc, 2,\n+\t\t\t\t\t   Expression::make_nil(loc),\n+\t\t\t\t\t   this->expr_);\n       return Expression::make_unsafe_cast(type, s2a, loc)->get_backend(context);\n     }\n   else if (type->is_numeric_type())\n@@ -5068,6 +5069,31 @@ Binary_expression::do_lower(Gogo* gogo, Named_object*,\n \treturn this->lower_interface_value_comparison(gogo, inserter);\n     }\n \n+  // Lower string concatenation to String_concat_expression, so that\n+  // we can group sequences of string additions.\n+  if (this->left_->type()->is_string_type() && this->op_ == OPERATOR_PLUS)\n+    {\n+      Expression_list* exprs;\n+      String_concat_expression* left_sce =\n+\tthis->left_->string_concat_expression();\n+      if (left_sce != NULL)\n+\texprs = left_sce->exprs();\n+      else\n+\t{\n+\t  exprs = new Expression_list();\n+\t  exprs->push_back(this->left_);\n+\t}\n+\n+      String_concat_expression* right_sce =\n+\tthis->right_->string_concat_expression();\n+      if (right_sce != NULL)\n+\texprs->append(right_sce->exprs());\n+      else\n+\texprs->push_back(this->right_);\n+\n+      return Expression::make_string_concat(exprs);\n+    }\n+\n   return this;\n }\n \n@@ -5277,25 +5303,6 @@ Binary_expression::do_flatten(Gogo* gogo, Named_object*,\n     }\n \n   Temporary_statement* temp;\n-  if (this->left_->type()->is_string_type()\n-      && this->op_ == OPERATOR_PLUS)\n-    {\n-      if (!this->left_->is_variable()\n-\t  && !this->left_->is_constant())\n-        {\n-          temp = Statement::make_temporary(NULL, this->left_, loc);\n-          inserter->insert(temp);\n-          this->left_ = Expression::make_temporary_reference(temp, loc);\n-        }\n-      if (!this->right_->is_variable()\n-\t  && !this->right_->is_constant())\n-        {\n-          temp =\n-              Statement::make_temporary(this->left_->type(), this->right_, loc);\n-          this->right_ = Expression::make_temporary_reference(temp, loc);\n-          inserter->insert(temp);\n-        }\n-    }\n \n   Type* left_type = this->left_->type();\n   bool is_shift_op = (this->op_ == OPERATOR_LSHIFT\n@@ -5792,14 +5799,9 @@ Binary_expression::do_get_backend(Translate_context* context)\n       go_unreachable();\n     }\n \n-  if (left_type->is_string_type())\n-    {\n-      go_assert(this->op_ == OPERATOR_PLUS);\n-      Expression* string_plus =\n-          Runtime::make_call(Runtime::STRING_PLUS, loc, 2,\n-                             this->left_, this->right_);\n-      return string_plus->get_backend(context);\n-    }\n+  // The only binary operation for string is +, and that should have\n+  // been converted to a String_concat_expression in do_lower.\n+  go_assert(!left_type->is_string_type());\n \n   // For complex division Go might want slightly different results than the\n   // backend implementation provides, so we have our own runtime routine.\n@@ -6294,6 +6296,182 @@ Expression::comparison(Translate_context* context, Type* result_type,\n   return ret;\n }\n \n+// Class String_concat_expression.\n+\n+bool\n+String_concat_expression::do_is_constant() const\n+{\n+  for (Expression_list::const_iterator pe = this->exprs_->begin();\n+       pe != this->exprs_->end();\n+       ++pe)\n+    {\n+      if (!(*pe)->is_constant())\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+bool\n+String_concat_expression::do_is_immutable() const\n+{\n+  for (Expression_list::const_iterator pe = this->exprs_->begin();\n+       pe != this->exprs_->end();\n+       ++pe)\n+    {\n+      if (!(*pe)->is_immutable())\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+Type*\n+String_concat_expression::do_type()\n+{\n+  Type* t = this->exprs_->front()->type();\n+  Expression_list::iterator pe = this->exprs_->begin();\n+  ++pe;\n+  for (; pe != this->exprs_->end(); ++pe)\n+    {\n+      Type* t1;\n+      if (!Binary_expression::operation_type(OPERATOR_PLUS, t,\n+\t\t\t\t\t     (*pe)->type(),\n+\t\t\t\t\t     &t1))\n+\treturn Type::make_error_type();\n+      t = t1;\n+    }\n+  return t;\n+}\n+\n+void\n+String_concat_expression::do_determine_type(const Type_context* context)\n+{\n+  Type_context subcontext(*context);\n+  for (Expression_list::iterator pe = this->exprs_->begin();\n+       pe != this->exprs_->end();\n+       ++pe)\n+    {\n+      Type* t = (*pe)->type();\n+      if (!t->is_abstract())\n+\t{\n+\t  subcontext.type = t;\n+\t  break;\n+\t}\n+    }\n+  if (subcontext.type == NULL)\n+    subcontext.type = this->exprs_->front()->type();\n+  for (Expression_list::iterator pe = this->exprs_->begin();\n+       pe != this->exprs_->end();\n+       ++pe)\n+    (*pe)->determine_type(&subcontext);\n+}\n+\n+void\n+String_concat_expression::do_check_types(Gogo*)\n+{\n+  if (this->is_error_expression())\n+    return;\n+  Type* t = this->exprs_->front()->type();\n+  if (t->is_error())\n+    {\n+      this->set_is_error();\n+      return;\n+    }\n+  Expression_list::iterator pe = this->exprs_->begin();\n+  ++pe;\n+  for (; pe != this->exprs_->end(); ++pe)\n+    {\n+      Type* t1 = (*pe)->type();\n+      if (!Type::are_compatible_for_binop(t, t1))\n+\t{\n+\t  this->report_error(\"incompatible types in binary expression\");\n+\t  return;\n+\t}\n+      if (!Binary_expression::check_operator_type(OPERATOR_PLUS, t, t1,\n+\t\t\t\t\t\t  this->location()))\n+\t{\n+\t  this->set_is_error();\n+\t  return;\n+\t}\n+    }\n+}\n+\n+Expression*\n+String_concat_expression::do_flatten(Gogo*, Named_object*,\n+\t\t\t\t     Statement_inserter*)\n+{\n+  if (this->is_error_expression())\n+    return this;\n+  Location loc = this->location();\n+  Type* type = this->type();\n+  Expression* nil_arg = Expression::make_nil(loc);\n+  Expression* call;\n+  switch (this->exprs_->size())\n+    {\n+    case 0: case 1:\n+      go_unreachable();\n+\n+    case 2: case 3: case 4: case 5:\n+      {\n+\tExpression* len = Expression::make_integer_ul(this->exprs_->size(),\n+\t\t\t\t\t\t      NULL, loc);\n+\tArray_type* arg_type = Type::make_array_type(type, len);\n+\targ_type->set_is_array_incomparable();\n+\tExpression* arg =\n+\t  Expression::make_array_composite_literal(arg_type, this->exprs_,\n+\t\t\t\t\t\t   loc);\n+\tRuntime::Function code;\n+\tswitch (this->exprs_->size())\n+\t  {\n+\t  default:\n+\t    go_unreachable();\n+\t  case 2:\n+\t    code = Runtime::CONCATSTRING2;\n+\t    break;\n+\t  case 3:\n+\t    code = Runtime::CONCATSTRING3;\n+\t    break;\n+\t  case 4:\n+\t    code = Runtime::CONCATSTRING4;\n+\t    break;\n+\t  case 5:\n+\t    code = Runtime::CONCATSTRING5;\n+\t    break;\n+\t  }\n+\tcall = Runtime::make_call(code, loc, 2, nil_arg, arg);\n+      }\n+      break;\n+\n+    default:\n+      {\n+\tType* arg_type = Type::make_array_type(type, NULL);\n+\tSlice_construction_expression* sce =\n+\t  Expression::make_slice_composite_literal(arg_type, this->exprs_,\n+\t\t\t\t\t\t   loc);\n+\tsce->set_storage_does_not_escape();\n+\tcall = Runtime::make_call(Runtime::CONCATSTRINGS, loc, 2, nil_arg,\n+\t\t\t\t  sce);\n+      }\n+      break;\n+    }\n+\n+  return Expression::make_cast(type, call, loc);\n+}\n+\n+void\n+String_concat_expression::do_dump_expression(\n+    Ast_dump_context* ast_dump_context) const\n+{\n+  ast_dump_context->ostream() << \"concat(\";\n+  ast_dump_context->dump_expression_list(this->exprs_, false);\n+  ast_dump_context->ostream() << \")\";\n+}\n+\n+Expression*\n+Expression::make_string_concat(Expression_list* exprs)\n+{\n+  return new String_concat_expression(exprs);\n+}\n+\n // Class Bound_method_expression.\n \n // Traversal."}, {"sha": "11614c3c3e64ca3a943fd6e2a87a666b0ddabc6f", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 84, "deletions": 4, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=1ad16c52842e0513b96a0e02d2a431dc0f338c5d", "patch": "@@ -37,6 +37,7 @@ class Type_conversion_expression;\n class Unsafe_type_conversion_expression;\n class Unary_expression;\n class Binary_expression;\n+class String_concat_expression;\n class Call_expression;\n class Call_result_expression;\n class Func_expression;\n@@ -85,6 +86,7 @@ class Expression\n     EXPRESSION_TYPE,\n     EXPRESSION_UNARY,\n     EXPRESSION_BINARY,\n+    EXPRESSION_STRING_CONCAT,\n     EXPRESSION_CONST_REFERENCE,\n     EXPRESSION_VAR_REFERENCE,\n     EXPRESSION_ENCLOSED_VAR_REFERENCE,\n@@ -160,6 +162,10 @@ class Expression\n   static Expression*\n   make_binary(Operator, Expression*, Expression*, Location);\n \n+  // Make a string concatenation expression.\n+  static Expression*\n+  make_string_concat(Expression_list*);\n+\n   // Make a reference to a constant in an expression.\n   static Expression*\n   make_const_reference(Named_object*, Location);\n@@ -620,6 +626,14 @@ class Expression\n   binary_expression()\n   { return this->convert<Binary_expression, EXPRESSION_BINARY>(); }\n \n+  // If this is a string concatenation expression, return the\n+  // String_concat_expression structure.  Otherwise, return NULL.\n+  String_concat_expression*\n+  string_concat_expression()\n+  {\n+    return this->convert<String_concat_expression, EXPRESSION_STRING_CONCAT>();\n+  }\n+\n   // If this is a call expression, return the Call_expression\n   // structure.  Otherwise, return NULL.  This is a controlled dynamic\n   // cast.\n@@ -1877,6 +1891,13 @@ class Binary_expression : public Expression\n   static bool\n   check_operator_type(Operator op, Type* type, Type* otype, Location);\n \n+  // Set *RESULT_TYPE to the resulting type when OP is applied to\n+  // operands of type LEFT_TYPE and RIGHT_TYPE.  Return true on\n+  // success, false on failure.\n+  static bool\n+  operation_type(Operator op, Type* left_type, Type* right_type,\n+\t\t Type** result_type);\n+\n  protected:\n   int\n   do_traverse(Traverse* traverse);\n@@ -1927,10 +1948,6 @@ class Binary_expression : public Expression\n   do_dump_expression(Ast_dump_context*) const;\n \n  private:\n-  static bool\n-  operation_type(Operator op, Type* left_type, Type* right_type,\n-\t\t Type** result_type);\n-\n   static bool\n   cmp_to_bool(Operator op, int cmp);\n \n@@ -1980,6 +1997,69 @@ class Binary_expression : public Expression\n   Type* type_;\n };\n \n+// A string concatenation expression.  This is a sequence of strings\n+// added together.  It is created when lowering Binary_expression.\n+\n+class String_concat_expression : public Expression\n+{\n+ public:\n+  String_concat_expression(Expression_list* exprs)\n+    : Expression(EXPRESSION_STRING_CONCAT, exprs->front()->location()),\n+      exprs_(exprs)\n+  { }\n+\n+  // Return the list of string expressions to be concatenated.\n+  Expression_list*\n+  exprs()\n+  { return this->exprs_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse)\n+  { return this->exprs_->traverse(traverse); }\n+\n+  Expression*\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n+  { return this; }\n+\n+  Expression*\n+  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n+\n+  bool\n+  do_is_constant() const;\n+\n+  bool\n+  do_is_immutable() const;\n+\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*);\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  Expression*\n+  do_copy()\n+  { return Expression::make_string_concat(this->exprs_->copy()); }\n+\n+  Bexpression*\n+  do_get_backend(Translate_context*)\n+  { go_unreachable(); }\n+\n+  void\n+  do_export(Export*) const\n+  { go_unreachable(); }\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+\n+ private:\n+  // The string expressions to concatenate.\n+  Expression_list* exprs_;\n+};\n+\n // A call expression.  The go statement needs to dig inside this.\n \n class Call_expression : public Expression"}, {"sha": "4072920b9d25f4a1d41d58b7c88445aaa462754f", "filename": "gcc/go/gofrontend/runtime.cc", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.cc?ref=1ad16c52842e0513b96a0e02d2a431dc0f338c5d", "patch": "@@ -64,6 +64,14 @@ enum Runtime_function_type\n   RFT_FUNC_PTR,\n   // Pointer to Go type descriptor.\n   RFT_TYPE,\n+  // [2]string.\n+  RFT_ARRAY2STRING,\n+  // [3]string.\n+  RFT_ARRAY3STRING,\n+  // [4]string.\n+  RFT_ARRAY4STRING,\n+  // [5]string.\n+  RFT_ARRAY5STRING,\n \n   NUMBER_OF_RUNTIME_FUNCTION_TYPES\n };\n@@ -180,6 +188,30 @@ runtime_function_type(Runtime_function_type bft)\n \tcase RFT_TYPE:\n \t  t = Type::make_type_descriptor_ptr_type();\n \t  break;\n+\n+\tcase RFT_ARRAY2STRING:\n+\t  t = Type::make_array_type(Type::make_string_type(),\n+\t\t\t\t    Expression::make_integer_ul(2, NULL,\n+\t\t\t\t\t\t\t\tbloc));\n+\t  break;\n+\n+\tcase RFT_ARRAY3STRING:\n+\t  t = Type::make_array_type(Type::make_string_type(),\n+\t\t\t\t    Expression::make_integer_ul(3, NULL,\n+\t\t\t\t\t\t\t\tbloc));\n+\t  break;\n+\n+\tcase RFT_ARRAY4STRING:\n+\t  t = Type::make_array_type(Type::make_string_type(),\n+\t\t\t\t    Expression::make_integer_ul(4, NULL,\n+\t\t\t\t\t\t\t\tbloc));\n+\t  break;\n+\n+\tcase RFT_ARRAY5STRING:\n+\t  t = Type::make_array_type(Type::make_string_type(),\n+\t\t\t\t    Expression::make_integer_ul(5, NULL,\n+\t\t\t\t\t\t\t\tbloc));\n+\t  break;\n \t}\n \n       runtime_function_types[bft] = t;\n@@ -226,6 +258,10 @@ convert_to_runtime_function_type(Runtime_function_type bft, Expression* e,\n     case RFT_CHAN:\n     case RFT_IFACE:\n     case RFT_EFACE:\n+    case RFT_ARRAY2STRING:\n+    case RFT_ARRAY3STRING:\n+    case RFT_ARRAY4STRING:\n+    case RFT_ARRAY5STRING:\n       return Expression::make_unsafe_cast(runtime_function_type(bft), e, loc);\n \n     case RFT_TYPE:"}, {"sha": "4e4c3e3a85833a818d113e6eb9f4e87785df0c1a", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=1ad16c52842e0513b96a0e02d2a431dc0f338c5d", "patch": "@@ -38,8 +38,17 @@ DEF_GO_RUNTIME(STRINGITER, \"runtime.stringiter\", P2(STRING, INT), R1(INT))\n DEF_GO_RUNTIME(STRINGITER2, \"runtime.stringiter2\", P2(STRING, INT),\n \t       R2(INT, RUNE))\n \n-// Concatenate two strings.\n-DEF_GO_RUNTIME(STRING_PLUS, \"__go_string_plus\", P2(STRING, STRING), R1(STRING))\n+// Concatenate strings.\n+DEF_GO_RUNTIME(CONCATSTRINGS, \"runtime.concatstrings\", P2(POINTER, SLICE),\n+\t       R1(STRING))\n+DEF_GO_RUNTIME(CONCATSTRING2, \"runtime.concatstring2\",\n+\t       P2(POINTER, ARRAY2STRING), R1(STRING))\n+DEF_GO_RUNTIME(CONCATSTRING3, \"runtime.concatstring3\",\n+\t       P2(POINTER, ARRAY3STRING), R1(STRING))\n+DEF_GO_RUNTIME(CONCATSTRING4, \"runtime.concatstring4\",\n+\t       P2(POINTER, ARRAY4STRING), R1(STRING))\n+DEF_GO_RUNTIME(CONCATSTRING5, \"runtime.concatstring5\",\n+\t       P2(POINTER, ARRAY5STRING), R1(STRING))\n \n // Compare two strings.\n DEF_GO_RUNTIME(STRCMP, \"__go_strcmp\", P2(STRING, STRING), R1(INT))\n@@ -49,23 +58,23 @@ DEF_GO_RUNTIME(STRING_SLICE, \"__go_string_slice\", P3(STRING, INT, INT),\n \t       R1(STRING))\n \n // Convert an integer to a string.\n-DEF_GO_RUNTIME(INT_TO_STRING, \"__go_int_to_string\", P1(INT), R1(STRING))\n+DEF_GO_RUNTIME(INTSTRING, \"runtime.intstring\", P2(POINTER, INT64), R1(STRING))\n \n-// Convert a byte array to a string.\n-DEF_GO_RUNTIME(BYTE_ARRAY_TO_STRING, \"__go_byte_array_to_string\",\n-\t       P2(POINTER, INT), R1(STRING))\n+// Convert a []byte to a string.\n+DEF_GO_RUNTIME(SLICEBYTETOSTRING, \"runtime.slicebytetostring\",\n+\t       P2(POINTER, SLICE), R1(STRING))\n \n-// Convert an int array to a string.\n-DEF_GO_RUNTIME(INT_ARRAY_TO_STRING, \"__go_int_array_to_string\",\n-\t       P2(POINTER, INT), R1(STRING))\n+// Convert a []rune to a string.\n+DEF_GO_RUNTIME(SLICERUNETOSTRING, \"runtime.slicerunetostring\",\n+\t       P2(POINTER, SLICE), R1(STRING))\n \n-// Convert a string to a byte slice.\n-DEF_GO_RUNTIME(STRING_TO_BYTE_ARRAY, \"__go_string_to_byte_array\",\n-\t       P1(STRING), R1(SLICE))\n+// Convert a string to a []byte.\n+DEF_GO_RUNTIME(STRINGTOSLICEBYTE, \"runtime.stringtoslicebyte\",\n+\t       P2(POINTER, STRING), R1(SLICE))\n \n-// Convert a string to an int slice.\n-DEF_GO_RUNTIME(STRING_TO_INT_ARRAY, \"__go_string_to_int_array\",\n-\t       P1(STRING), R1(SLICE))\n+// Convert a string to a []rune.\n+DEF_GO_RUNTIME(STRINGTOSLICERUNE, \"runtime.stringtoslicerune\",\n+\t       P2(POINTER, STRING), R1(SLICE))\n \n \n // Complex division."}, {"sha": "be5b0cac19c1996c65b4b521998709c13d09ce4c", "filename": "libgo/Makefile.am", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=1ad16c52842e0513b96a0e02d2a431dc0f338c5d", "patch": "@@ -441,7 +441,6 @@ runtime_files = \\\n \truntime/go-append.c \\\n \truntime/go-assert.c \\\n \truntime/go-assert-interface.c \\\n-\truntime/go-byte-array-to-string.c \\\n \truntime/go-breakpoint.c \\\n \truntime/go-caller.c \\\n \truntime/go-callers.c \\\n@@ -458,8 +457,6 @@ runtime_files = \\\n \truntime/go-eface-val-compare.c \\\n \truntime/go-ffi.c \\\n \truntime/go-fieldtrack.c \\\n-\truntime/go-int-array-to-string.c \\\n-\truntime/go-int-to-string.c \\\n \truntime/go-interface-compare.c \\\n \truntime/go-interface-eface-compare.c \\\n \truntime/go-interface-val-compare.c \\\n@@ -476,14 +473,10 @@ runtime_files = \\\n \truntime/go-panic.c \\\n \truntime/go-recover.c \\\n \truntime/go-reflect-call.c \\\n-\truntime/go-rune.c \\\n \truntime/go-runtime-error.c \\\n \truntime/go-setenv.c \\\n \truntime/go-signal.c \\\n \truntime/go-strcmp.c \\\n-\truntime/go-string-to-byte-array.c \\\n-\truntime/go-string-to-int-array.c \\\n-\truntime/go-strplus.c \\\n \truntime/go-strslice.c \\\n \truntime/go-traceback.c \\\n \truntime/go-type-complex.c \\\n@@ -529,7 +522,6 @@ runtime_files = \\\n \treflect.c \\\n \truntime1.c \\\n \tsigqueue.c \\\n-\tstring.c \\\n \ttime.c \\\n \t$(runtime_getncpu_file)\n "}, {"sha": "6797a349bad083668129bf9efc83506b98df9411", "filename": "libgo/Makefile.in", "status": "modified", "additions": 12, "deletions": 80, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=1ad16c52842e0513b96a0e02d2a431dc0f338c5d", "patch": "@@ -241,32 +241,29 @@ libgo_llgo_la_DEPENDENCIES = $(am__DEPENDENCIES_4)\n @LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_LINUX_FALSE@\tgetncpu-bsd.lo\n @LIBGO_IS_LINUX_TRUE@am__objects_5 = getncpu-linux.lo\n am__objects_6 = go-append.lo go-assert.lo go-assert-interface.lo \\\n-\tgo-byte-array-to-string.lo go-breakpoint.lo go-caller.lo \\\n-\tgo-callers.lo go-can-convert-interface.lo go-cdiv.lo go-cgo.lo \\\n+\tgo-breakpoint.lo go-caller.lo go-callers.lo \\\n+\tgo-can-convert-interface.lo go-cdiv.lo go-cgo.lo \\\n \tgo-check-interface.lo go-construct-map.lo \\\n \tgo-convert-interface.lo go-copy.lo go-defer.lo \\\n \tgo-deferred-recover.lo go-eface-compare.lo \\\n \tgo-eface-val-compare.lo go-ffi.lo go-fieldtrack.lo \\\n-\tgo-int-array-to-string.lo go-int-to-string.lo \\\n \tgo-interface-compare.lo go-interface-eface-compare.lo \\\n \tgo-interface-val-compare.lo go-make-slice.lo go-matherr.lo \\\n \tgo-memclr.lo go-memcmp.lo go-memequal.lo go-memmove.lo \\\n \tgo-nanotime.lo go-now.lo go-new.lo go-nosys.lo go-panic.lo \\\n-\tgo-recover.lo go-reflect-call.lo go-rune.lo \\\n-\tgo-runtime-error.lo go-setenv.lo go-signal.lo go-strcmp.lo \\\n-\tgo-string-to-byte-array.lo go-string-to-int-array.lo \\\n-\tgo-strplus.lo go-strslice.lo go-traceback.lo \\\n-\tgo-type-complex.lo go-type-eface.lo go-type-float.lo \\\n-\tgo-type-identity.lo go-type-interface.lo go-type-string.lo \\\n-\tgo-typedesc-equal.lo go-unsafe-new.lo go-unsafe-newarray.lo \\\n-\tgo-unsafe-pointer.lo go-unsetenv.lo go-unwind.lo go-varargs.lo \\\n-\tenv_posix.lo heapdump.lo mcache.lo mcentral.lo \\\n-\t$(am__objects_1) mfixalloc.lo mgc0.lo mheap.lo msize.lo \\\n-\t$(am__objects_2) panic.lo parfor.lo print.lo proc.lo \\\n+\tgo-recover.lo go-reflect-call.lo go-runtime-error.lo \\\n+\tgo-setenv.lo go-signal.lo go-strcmp.lo go-strslice.lo \\\n+\tgo-traceback.lo go-type-complex.lo go-type-eface.lo \\\n+\tgo-type-float.lo go-type-identity.lo go-type-interface.lo \\\n+\tgo-type-string.lo go-typedesc-equal.lo go-unsafe-new.lo \\\n+\tgo-unsafe-newarray.lo go-unsafe-pointer.lo go-unsetenv.lo \\\n+\tgo-unwind.lo go-varargs.lo env_posix.lo heapdump.lo mcache.lo \\\n+\tmcentral.lo $(am__objects_1) mfixalloc.lo mgc0.lo mheap.lo \\\n+\tmsize.lo $(am__objects_2) panic.lo parfor.lo print.lo proc.lo \\\n \truntime.lo signal_unix.lo thread.lo $(am__objects_3) yield.lo \\\n \t$(am__objects_4) cpuprof.lo go-iface.lo lfstack.lo malloc.lo \\\n \tmprof.lo netpoll.lo rdebug.lo reflect.lo runtime1.lo \\\n-\tsigqueue.lo string.lo time.lo $(am__objects_5)\n+\tsigqueue.lo time.lo $(am__objects_5)\n am_libgo_llgo_la_OBJECTS = $(am__objects_6)\n libgo_llgo_la_OBJECTS = $(am_libgo_llgo_la_OBJECTS)\n libgo_llgo_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\\n@@ -843,7 +840,6 @@ runtime_files = \\\n \truntime/go-append.c \\\n \truntime/go-assert.c \\\n \truntime/go-assert-interface.c \\\n-\truntime/go-byte-array-to-string.c \\\n \truntime/go-breakpoint.c \\\n \truntime/go-caller.c \\\n \truntime/go-callers.c \\\n@@ -860,8 +856,6 @@ runtime_files = \\\n \truntime/go-eface-val-compare.c \\\n \truntime/go-ffi.c \\\n \truntime/go-fieldtrack.c \\\n-\truntime/go-int-array-to-string.c \\\n-\truntime/go-int-to-string.c \\\n \truntime/go-interface-compare.c \\\n \truntime/go-interface-eface-compare.c \\\n \truntime/go-interface-val-compare.c \\\n@@ -878,14 +872,10 @@ runtime_files = \\\n \truntime/go-panic.c \\\n \truntime/go-recover.c \\\n \truntime/go-reflect-call.c \\\n-\truntime/go-rune.c \\\n \truntime/go-runtime-error.c \\\n \truntime/go-setenv.c \\\n \truntime/go-signal.c \\\n \truntime/go-strcmp.c \\\n-\truntime/go-string-to-byte-array.c \\\n-\truntime/go-string-to-int-array.c \\\n-\truntime/go-strplus.c \\\n \truntime/go-strslice.c \\\n \truntime/go-traceback.c \\\n \truntime/go-type-complex.c \\\n@@ -931,7 +921,6 @@ runtime_files = \\\n \treflect.c \\\n \truntime1.c \\\n \tsigqueue.c \\\n-\tstring.c \\\n \ttime.c \\\n \t$(runtime_getncpu_file)\n \n@@ -1569,7 +1558,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-assert-interface.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-assert.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-breakpoint.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-byte-array-to-string.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-caller.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-callers.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-can-convert-interface.Plo@am__quote@\n@@ -1586,8 +1574,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-ffi.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-fieldtrack.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-iface.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-int-array-to-string.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-int-to-string.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-interface-compare.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-interface-eface-compare.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-interface-val-compare.Plo@am__quote@\n@@ -1604,14 +1590,10 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-panic.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-recover.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-reflect-call.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-rune.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-runtime-error.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-setenv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-signal.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-strcmp.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-string-to-byte-array.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-string-to-int-array.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-strplus.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-strslice.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-traceback.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-complex.Plo@am__quote@\n@@ -1657,7 +1639,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/runtime1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/signal_unix.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sigqueue.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/string.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/thread-linux.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/thread-sema.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/thread.Plo@am__quote@\n@@ -1748,13 +1729,6 @@ go-assert-interface.lo: runtime/go-assert-interface.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-assert-interface.lo `test -f 'runtime/go-assert-interface.c' || echo '$(srcdir)/'`runtime/go-assert-interface.c\n \n-go-byte-array-to-string.lo: runtime/go-byte-array-to-string.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-byte-array-to-string.lo -MD -MP -MF $(DEPDIR)/go-byte-array-to-string.Tpo -c -o go-byte-array-to-string.lo `test -f 'runtime/go-byte-array-to-string.c' || echo '$(srcdir)/'`runtime/go-byte-array-to-string.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-byte-array-to-string.Tpo $(DEPDIR)/go-byte-array-to-string.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-byte-array-to-string.c' object='go-byte-array-to-string.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-byte-array-to-string.lo `test -f 'runtime/go-byte-array-to-string.c' || echo '$(srcdir)/'`runtime/go-byte-array-to-string.c\n-\n go-breakpoint.lo: runtime/go-breakpoint.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-breakpoint.lo -MD -MP -MF $(DEPDIR)/go-breakpoint.Tpo -c -o go-breakpoint.lo `test -f 'runtime/go-breakpoint.c' || echo '$(srcdir)/'`runtime/go-breakpoint.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-breakpoint.Tpo $(DEPDIR)/go-breakpoint.Plo\n@@ -1867,20 +1841,6 @@ go-fieldtrack.lo: runtime/go-fieldtrack.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-fieldtrack.lo `test -f 'runtime/go-fieldtrack.c' || echo '$(srcdir)/'`runtime/go-fieldtrack.c\n \n-go-int-array-to-string.lo: runtime/go-int-array-to-string.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-int-array-to-string.lo -MD -MP -MF $(DEPDIR)/go-int-array-to-string.Tpo -c -o go-int-array-to-string.lo `test -f 'runtime/go-int-array-to-string.c' || echo '$(srcdir)/'`runtime/go-int-array-to-string.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-int-array-to-string.Tpo $(DEPDIR)/go-int-array-to-string.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-int-array-to-string.c' object='go-int-array-to-string.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-int-array-to-string.lo `test -f 'runtime/go-int-array-to-string.c' || echo '$(srcdir)/'`runtime/go-int-array-to-string.c\n-\n-go-int-to-string.lo: runtime/go-int-to-string.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-int-to-string.lo -MD -MP -MF $(DEPDIR)/go-int-to-string.Tpo -c -o go-int-to-string.lo `test -f 'runtime/go-int-to-string.c' || echo '$(srcdir)/'`runtime/go-int-to-string.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-int-to-string.Tpo $(DEPDIR)/go-int-to-string.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-int-to-string.c' object='go-int-to-string.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-int-to-string.lo `test -f 'runtime/go-int-to-string.c' || echo '$(srcdir)/'`runtime/go-int-to-string.c\n-\n go-interface-compare.lo: runtime/go-interface-compare.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-interface-compare.lo -MD -MP -MF $(DEPDIR)/go-interface-compare.Tpo -c -o go-interface-compare.lo `test -f 'runtime/go-interface-compare.c' || echo '$(srcdir)/'`runtime/go-interface-compare.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-interface-compare.Tpo $(DEPDIR)/go-interface-compare.Plo\n@@ -1993,13 +1953,6 @@ go-reflect-call.lo: runtime/go-reflect-call.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-reflect-call.lo `test -f 'runtime/go-reflect-call.c' || echo '$(srcdir)/'`runtime/go-reflect-call.c\n \n-go-rune.lo: runtime/go-rune.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-rune.lo -MD -MP -MF $(DEPDIR)/go-rune.Tpo -c -o go-rune.lo `test -f 'runtime/go-rune.c' || echo '$(srcdir)/'`runtime/go-rune.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-rune.Tpo $(DEPDIR)/go-rune.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-rune.c' object='go-rune.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-rune.lo `test -f 'runtime/go-rune.c' || echo '$(srcdir)/'`runtime/go-rune.c\n-\n go-runtime-error.lo: runtime/go-runtime-error.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-runtime-error.lo -MD -MP -MF $(DEPDIR)/go-runtime-error.Tpo -c -o go-runtime-error.lo `test -f 'runtime/go-runtime-error.c' || echo '$(srcdir)/'`runtime/go-runtime-error.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-runtime-error.Tpo $(DEPDIR)/go-runtime-error.Plo\n@@ -2028,27 +1981,6 @@ go-strcmp.lo: runtime/go-strcmp.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-strcmp.lo `test -f 'runtime/go-strcmp.c' || echo '$(srcdir)/'`runtime/go-strcmp.c\n \n-go-string-to-byte-array.lo: runtime/go-string-to-byte-array.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-string-to-byte-array.lo -MD -MP -MF $(DEPDIR)/go-string-to-byte-array.Tpo -c -o go-string-to-byte-array.lo `test -f 'runtime/go-string-to-byte-array.c' || echo '$(srcdir)/'`runtime/go-string-to-byte-array.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-string-to-byte-array.Tpo $(DEPDIR)/go-string-to-byte-array.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-string-to-byte-array.c' object='go-string-to-byte-array.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-string-to-byte-array.lo `test -f 'runtime/go-string-to-byte-array.c' || echo '$(srcdir)/'`runtime/go-string-to-byte-array.c\n-\n-go-string-to-int-array.lo: runtime/go-string-to-int-array.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-string-to-int-array.lo -MD -MP -MF $(DEPDIR)/go-string-to-int-array.Tpo -c -o go-string-to-int-array.lo `test -f 'runtime/go-string-to-int-array.c' || echo '$(srcdir)/'`runtime/go-string-to-int-array.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-string-to-int-array.Tpo $(DEPDIR)/go-string-to-int-array.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-string-to-int-array.c' object='go-string-to-int-array.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-string-to-int-array.lo `test -f 'runtime/go-string-to-int-array.c' || echo '$(srcdir)/'`runtime/go-string-to-int-array.c\n-\n-go-strplus.lo: runtime/go-strplus.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-strplus.lo -MD -MP -MF $(DEPDIR)/go-strplus.Tpo -c -o go-strplus.lo `test -f 'runtime/go-strplus.c' || echo '$(srcdir)/'`runtime/go-strplus.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-strplus.Tpo $(DEPDIR)/go-strplus.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-strplus.c' object='go-strplus.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-strplus.lo `test -f 'runtime/go-strplus.c' || echo '$(srcdir)/'`runtime/go-strplus.c\n-\n go-strslice.lo: runtime/go-strslice.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-strslice.lo -MD -MP -MF $(DEPDIR)/go-strslice.Tpo -c -o go-strslice.lo `test -f 'runtime/go-strslice.c' || echo '$(srcdir)/'`runtime/go-strslice.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-strslice.Tpo $(DEPDIR)/go-strslice.Plo"}, {"sha": "36830016a5b43d1025a468f605fc60bda2e36982", "filename": "libgo/go/runtime/error.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/libgo%2Fgo%2Fruntime%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/libgo%2Fgo%2Fruntime%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ferror.go?ref=1ad16c52842e0513b96a0e02d2a431dc0f338c5d", "patch": "@@ -4,6 +4,8 @@\n \n package runtime\n \n+import \"unsafe\"\n+\n // The Error interface identifies a run time error.\n type Error interface {\n \terror\n@@ -107,10 +109,8 @@ type errorCString struct{ cstr uintptr }\n \n func (e errorCString) RuntimeError() {}\n \n-func cstringToGo(uintptr) string\n-\n func (e errorCString) Error() string {\n-\treturn \"runtime error: \" + cstringToGo(e.cstr)\n+\treturn \"runtime error: \" + gostringnocopy((*byte)(unsafe.Pointer(e.cstr)))\n }\n \n // For calling from C."}, {"sha": "99c38e0bd91b7ab96d96b788400bf21833fe99cd", "filename": "libgo/go/runtime/rune.go", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/libgo%2Fgo%2Fruntime%2Frune.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/libgo%2Fgo%2Fruntime%2Frune.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Frune.go?ref=1ad16c52842e0513b96a0e02d2a431dc0f338c5d", "patch": "@@ -0,0 +1,219 @@\n+/*\n+ * The authors of this software are Rob Pike and Ken Thompson.\n+ *              Copyright (c) 2002 by Lucent Technologies.\n+ *              Portions Copyright 2009 The Go Authors. All rights reserved.\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose without fee is hereby granted, provided that this entire notice\n+ * is included in all copies of any software which is or includes a copy\n+ * or modification of this software and in all copies of the supporting\n+ * documentation for such software.\n+ * THIS SOFTWARE IS BEING PROVIDED \"AS IS\", WITHOUT ANY EXPRESS OR IMPLIED\n+ * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR LUCENT TECHNOLOGIES MAKE ANY\n+ * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY\n+ * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.\n+ */\n+\n+/*\n+ * This code is copied, with slight editing due to type differences,\n+ * from a subset of ../lib9/utf/rune.c [which no longer exists]\n+ */\n+\n+package runtime\n+\n+const (\n+\tbit1 = 7\n+\tbitx = 6\n+\tbit2 = 5\n+\tbit3 = 4\n+\tbit4 = 3\n+\tbit5 = 2\n+\n+\tt1 = ((1 << (bit1 + 1)) - 1) ^ 0xFF /* 0000 0000 */\n+\ttx = ((1 << (bitx + 1)) - 1) ^ 0xFF /* 1000 0000 */\n+\tt2 = ((1 << (bit2 + 1)) - 1) ^ 0xFF /* 1100 0000 */\n+\tt3 = ((1 << (bit3 + 1)) - 1) ^ 0xFF /* 1110 0000 */\n+\tt4 = ((1 << (bit4 + 1)) - 1) ^ 0xFF /* 1111 0000 */\n+\tt5 = ((1 << (bit5 + 1)) - 1) ^ 0xFF /* 1111 1000 */\n+\n+\trune1 = (1 << (bit1 + 0*bitx)) - 1 /* 0000 0000 0111 1111 */\n+\trune2 = (1 << (bit2 + 1*bitx)) - 1 /* 0000 0111 1111 1111 */\n+\trune3 = (1 << (bit3 + 2*bitx)) - 1 /* 1111 1111 1111 1111 */\n+\trune4 = (1 << (bit4 + 3*bitx)) - 1 /* 0001 1111 1111 1111 1111 1111 */\n+\n+\tmaskx = (1 << bitx) - 1 /* 0011 1111 */\n+\ttestx = maskx ^ 0xFF    /* 1100 0000 */\n+\n+\truneerror = 0xFFFD\n+\truneself  = 0x80\n+\n+\tsurrogateMin = 0xD800\n+\tsurrogateMax = 0xDFFF\n+\n+\tbad = runeerror\n+\n+\trunemax = 0x10FFFF /* maximum rune value */\n+)\n+\n+/*\n+ * Modified by Wei-Hwa Huang, Google Inc., on 2004-09-24\n+ * This is a slower but \"safe\" version of the old chartorune\n+ * that works on strings that are not necessarily null-terminated.\n+ *\n+ * If you know for sure that your string is null-terminated,\n+ * chartorune will be a bit faster.\n+ *\n+ * It is guaranteed not to attempt to access \"length\"\n+ * past the incoming pointer.  This is to avoid\n+ * possible access violations.  If the string appears to be\n+ * well-formed but incomplete (i.e., to get the whole Rune\n+ * we'd need to read past str+length) then we'll set the Rune\n+ * to Bad and return 0.\n+ *\n+ * Note that if we have decoding problems for other\n+ * reasons, we return 1 instead of 0.\n+ */\n+func charntorune(s string) (rune, int) {\n+\t/* When we're not allowed to read anything */\n+\tif len(s) <= 0 {\n+\t\treturn bad, 1\n+\t}\n+\n+\t/*\n+\t * one character sequence (7-bit value)\n+\t *\t00000-0007F => T1\n+\t */\n+\tc := s[0]\n+\tif c < tx {\n+\t\treturn rune(c), 1\n+\t}\n+\n+\t// If we can't read more than one character we must stop\n+\tif len(s) <= 1 {\n+\t\treturn bad, 1\n+\t}\n+\n+\t/*\n+\t * two character sequence (11-bit value)\n+\t *\t0080-07FF => t2 tx\n+\t */\n+\tc1 := s[1] ^ tx\n+\tif (c1 & testx) != 0 {\n+\t\treturn bad, 1\n+\t}\n+\tif c < t3 {\n+\t\tif c < t2 {\n+\t\t\treturn bad, 1\n+\t\t}\n+\t\tl := ((rune(c) << bitx) | rune(c1)) & rune2\n+\t\tif l <= rune1 {\n+\t\t\treturn bad, 1\n+\t\t}\n+\t\treturn l, 2\n+\t}\n+\n+\t// If we can't read more than two characters we must stop\n+\tif len(s) <= 2 {\n+\t\treturn bad, 1\n+\t}\n+\n+\t/*\n+\t * three character sequence (16-bit value)\n+\t *\t0800-FFFF => t3 tx tx\n+\t */\n+\tc2 := s[2] ^ tx\n+\tif (c2 & testx) != 0 {\n+\t\treturn bad, 1\n+\t}\n+\tif c < t4 {\n+\t\tl := ((((rune(c) << bitx) | rune(c1)) << bitx) | rune(c2)) & rune3\n+\t\tif l <= rune2 {\n+\t\t\treturn bad, 1\n+\t\t}\n+\t\tif surrogateMin <= l && l <= surrogateMax {\n+\t\t\treturn bad, 1\n+\t\t}\n+\t\treturn l, 3\n+\t}\n+\n+\tif len(s) <= 3 {\n+\t\treturn bad, 1\n+\t}\n+\n+\t/*\n+\t * four character sequence (21-bit value)\n+\t *\t10000-1FFFFF => t4 tx tx tx\n+\t */\n+\tc3 := s[3] ^ tx\n+\tif (c3 & testx) != 0 {\n+\t\treturn bad, 1\n+\t}\n+\tif c < t5 {\n+\t\tl := ((((((rune(c) << bitx) | rune(c1)) << bitx) | rune(c2)) << bitx) | rune(c3)) & rune4\n+\t\tif l <= rune3 || l > runemax {\n+\t\t\treturn bad, 1\n+\t\t}\n+\t\treturn l, 4\n+\t}\n+\n+\t// Support for 5-byte or longer UTF-8 would go here, but\n+\t// since we don't have that, we'll just return bad.\n+\treturn bad, 1\n+}\n+\n+// runetochar converts r to bytes and writes the result to str.\n+// returns the number of bytes generated.\n+func runetochar(str []byte, r rune) int {\n+\t/* runes are signed, so convert to unsigned for range check. */\n+\tc := uint32(r)\n+\t/*\n+\t * one character sequence\n+\t *\t00000-0007F => 00-7F\n+\t */\n+\tif c <= rune1 {\n+\t\tstr[0] = byte(c)\n+\t\treturn 1\n+\t}\n+\t/*\n+\t * two character sequence\n+\t *\t0080-07FF => t2 tx\n+\t */\n+\tif c <= rune2 {\n+\t\tstr[0] = byte(t2 | (c >> (1 * bitx)))\n+\t\tstr[1] = byte(tx | (c & maskx))\n+\t\treturn 2\n+\t}\n+\n+\t/*\n+\t * If the rune is out of range or a surrogate half, convert it to the error rune.\n+\t * Do this test here because the error rune encodes to three bytes.\n+\t * Doing it earlier would duplicate work, since an out of range\n+\t * rune wouldn't have fit in one or two bytes.\n+\t */\n+\tif c > runemax {\n+\t\tc = runeerror\n+\t}\n+\tif surrogateMin <= c && c <= surrogateMax {\n+\t\tc = runeerror\n+\t}\n+\n+\t/*\n+\t * three character sequence\n+\t *\t0800-FFFF => t3 tx tx\n+\t */\n+\tif c <= rune3 {\n+\t\tstr[0] = byte(t3 | (c >> (2 * bitx)))\n+\t\tstr[1] = byte(tx | ((c >> (1 * bitx)) & maskx))\n+\t\tstr[2] = byte(tx | (c & maskx))\n+\t\treturn 3\n+\t}\n+\n+\t/*\n+\t * four character sequence (21-bit value)\n+\t *     10000-1FFFFF => t4 tx tx tx\n+\t */\n+\tstr[0] = byte(t4 | (c >> (3 * bitx)))\n+\tstr[1] = byte(tx | ((c >> (2 * bitx)) & maskx))\n+\tstr[2] = byte(tx | ((c >> (1 * bitx)) & maskx))\n+\tstr[3] = byte(tx | (c & maskx))\n+\treturn 4\n+}"}, {"sha": "5df3aa3904de7e6d7bbaf65d01c008889991cf33", "filename": "libgo/go/runtime/string.go", "status": "added", "additions": 446, "deletions": 0, "changes": 446, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/libgo%2Fgo%2Fruntime%2Fstring.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/libgo%2Fgo%2Fruntime%2Fstring.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstring.go?ref=1ad16c52842e0513b96a0e02d2a431dc0f338c5d", "patch": "@@ -0,0 +1,446 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+// For gccgo, use go:linkname to rename compiler-called functions to\n+// themselves, so that the compiler will export them.\n+//\n+//go:linkname concatstrings runtime.concatstrings\n+//go:linkname concatstring2 runtime.concatstring2\n+//go:linkname concatstring3 runtime.concatstring3\n+//go:linkname concatstring4 runtime.concatstring4\n+//go:linkname concatstring5 runtime.concatstring5\n+//go:linkname slicebytetostring runtime.slicebytetostring\n+//go:linkname slicebytetostringtmp runtime.slicebytetostringtmp\n+//go:linkname stringtoslicebyte runtime.stringtoslicebyte\n+//go:linkname stringtoslicebytetmp runtime.stringtoslicebytetmp\n+//go:linkname stringtoslicerune runtime.stringtoslicerune\n+//go:linkname slicerunetostring runtime.slicerunetostring\n+//go:linkname intstring runtime.intstring\n+//go:linkname stringiter runtime.stringiter\n+//go:linkname stringiter2 runtime.stringiter2\n+// Temporary for C code to call:\n+//go:linkname gostringnocopy runtime.gostringnocopy\n+//go:linkname findnull runtime.findnull\n+\n+// The constant is known to the compiler.\n+// There is no fundamental theory behind this number.\n+const tmpStringBufSize = 32\n+\n+type tmpBuf [tmpStringBufSize]byte\n+\n+// concatstrings implements a Go string concatenation x+y+z+...\n+// The operands are passed in the slice a.\n+// If buf != nil, the compiler has determined that the result does not\n+// escape the calling function, so the string data can be stored in buf\n+// if small enough.\n+func concatstrings(buf *tmpBuf, a []string) string {\n+\t// idx := 0\n+\tl := 0\n+\tcount := 0\n+\tfor _, x := range a {\n+\t\tn := len(x)\n+\t\tif n == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif l+n < l {\n+\t\t\tthrow(\"string concatenation too long\")\n+\t\t}\n+\t\tl += n\n+\t\tcount++\n+\t\t// idx = i\n+\t}\n+\tif count == 0 {\n+\t\treturn \"\"\n+\t}\n+\n+\t// If there is just one string and either it is not on the stack\n+\t// or our result does not escape the calling frame (buf != nil),\n+\t// then we can return that string directly.\n+\t// Commented out for gccgo--no implementation of stringDataOnStack.\n+\t// if count == 1 && (buf != nil || !stringDataOnStack(a[idx])) {\n+\t// \treturn a[idx]\n+\t// }\n+\ts, b := rawstringtmp(buf, l)\n+\tl = 0\n+\tfor _, x := range a {\n+\t\tcopy(b[l:], x)\n+\t\tl += len(x)\n+\t}\n+\treturn s\n+}\n+\n+func concatstring2(buf *tmpBuf, a [2]string) string {\n+\treturn concatstrings(buf, a[:])\n+}\n+\n+func concatstring3(buf *tmpBuf, a [3]string) string {\n+\treturn concatstrings(buf, a[:])\n+}\n+\n+func concatstring4(buf *tmpBuf, a [4]string) string {\n+\treturn concatstrings(buf, a[:])\n+}\n+\n+func concatstring5(buf *tmpBuf, a [5]string) string {\n+\treturn concatstrings(buf, a[:])\n+}\n+\n+// Buf is a fixed-size buffer for the result,\n+// it is not nil if the result does not escape.\n+func slicebytetostring(buf *tmpBuf, b []byte) string {\n+\tl := len(b)\n+\tif l == 0 {\n+\t\t// Turns out to be a relatively common case.\n+\t\t// Consider that you want to parse out data between parens in \"foo()bar\",\n+\t\t// you find the indices and convert the subslice to string.\n+\t\treturn \"\"\n+\t}\n+\tif raceenabled && l > 0 {\n+\t\tracereadrangepc(unsafe.Pointer(&b[0]),\n+\t\t\tuintptr(l),\n+\t\t\tgetcallerpc(unsafe.Pointer(&buf)),\n+\t\t\tfuncPC(slicebytetostring))\n+\t}\n+\tif msanenabled && l > 0 {\n+\t\tmsanread(unsafe.Pointer(&b[0]), uintptr(l))\n+\t}\n+\ts, c := rawstringtmp(buf, l)\n+\tcopy(c, b)\n+\treturn s\n+}\n+\n+func rawstringtmp(buf *tmpBuf, l int) (s string, b []byte) {\n+\tif buf != nil && l <= len(buf) {\n+\t\tb = buf[:l]\n+\t\ts = slicebytetostringtmp(b)\n+\t} else {\n+\t\ts, b = rawstring(l)\n+\t}\n+\treturn\n+}\n+\n+func slicebytetostringtmp(b []byte) string {\n+\t// Return a \"string\" referring to the actual []byte bytes.\n+\t// This is only for use by internal compiler optimizations\n+\t// that know that the string form will be discarded before\n+\t// the calling goroutine could possibly modify the original\n+\t// slice or synchronize with another goroutine.\n+\t// First such case is a m[string(k)] lookup where\n+\t// m is a string-keyed map and k is a []byte.\n+\t// Second such case is \"<\"+string(b)+\">\" concatenation where b is []byte.\n+\t// Third such case is string(b)==\"foo\" comparison where b is []byte.\n+\n+\tif raceenabled && len(b) > 0 {\n+\t\tracereadrangepc(unsafe.Pointer(&b[0]),\n+\t\t\tuintptr(len(b)),\n+\t\t\tgetcallerpc(unsafe.Pointer(&b)),\n+\t\t\tfuncPC(slicebytetostringtmp))\n+\t}\n+\tif msanenabled && len(b) > 0 {\n+\t\tmsanread(unsafe.Pointer(&b[0]), uintptr(len(b)))\n+\t}\n+\treturn *(*string)(unsafe.Pointer(&b))\n+}\n+\n+func stringtoslicebyte(buf *tmpBuf, s string) []byte {\n+\tvar b []byte\n+\tif buf != nil && len(s) <= len(buf) {\n+\t\t*buf = tmpBuf{}\n+\t\tb = buf[:len(s)]\n+\t} else {\n+\t\tb = rawbyteslice(len(s))\n+\t}\n+\tcopy(b, s)\n+\treturn b\n+}\n+\n+func stringtoslicebytetmp(s string) []byte {\n+\t// Return a slice referring to the actual string bytes.\n+\t// This is only for use by internal compiler optimizations\n+\t// that know that the slice won't be mutated.\n+\t// The only such case today is:\n+\t// for i, c := range []byte(str)\n+\n+\tstr := stringStructOf(&s)\n+\tret := slice{array: str.str, len: str.len, cap: str.len}\n+\treturn *(*[]byte)(unsafe.Pointer(&ret))\n+}\n+\n+func stringtoslicerune(buf *[tmpStringBufSize]rune, s string) []rune {\n+\t// two passes.\n+\t// unlike slicerunetostring, no race because strings are immutable.\n+\tn := 0\n+\tt := s\n+\tfor len(s) > 0 {\n+\t\t_, k := charntorune(s)\n+\t\ts = s[k:]\n+\t\tn++\n+\t}\n+\tvar a []rune\n+\tif buf != nil && n <= len(buf) {\n+\t\t*buf = [tmpStringBufSize]rune{}\n+\t\ta = buf[:n]\n+\t} else {\n+\t\ta = rawruneslice(n)\n+\t}\n+\tn = 0\n+\tfor len(t) > 0 {\n+\t\tr, k := charntorune(t)\n+\t\tt = t[k:]\n+\t\ta[n] = r\n+\t\tn++\n+\t}\n+\treturn a\n+}\n+\n+func slicerunetostring(buf *tmpBuf, a []rune) string {\n+\tif raceenabled && len(a) > 0 {\n+\t\tracereadrangepc(unsafe.Pointer(&a[0]),\n+\t\t\tuintptr(len(a))*unsafe.Sizeof(a[0]),\n+\t\t\tgetcallerpc(unsafe.Pointer(&buf)),\n+\t\t\tfuncPC(slicerunetostring))\n+\t}\n+\tif msanenabled && len(a) > 0 {\n+\t\tmsanread(unsafe.Pointer(&a[0]), uintptr(len(a))*unsafe.Sizeof(a[0]))\n+\t}\n+\tvar dum [4]byte\n+\tsize1 := 0\n+\tfor _, r := range a {\n+\t\tsize1 += runetochar(dum[:], r)\n+\t}\n+\ts, b := rawstringtmp(buf, size1+3)\n+\tsize2 := 0\n+\tfor _, r := range a {\n+\t\t// check for race\n+\t\tif size2 >= size1 {\n+\t\t\tbreak\n+\t\t}\n+\t\tsize2 += runetochar(b[size2:], r)\n+\t}\n+\treturn s[:size2]\n+}\n+\n+type stringStruct struct {\n+\tstr unsafe.Pointer\n+\tlen int\n+}\n+\n+// Variant with *byte pointer type for DWARF debugging.\n+type stringStructDWARF struct {\n+\tstr *byte\n+\tlen int\n+}\n+\n+func stringStructOf(sp *string) *stringStruct {\n+\treturn (*stringStruct)(unsafe.Pointer(sp))\n+}\n+\n+func intstring(buf *[4]byte, v int64) string {\n+\tvar s string\n+\tvar b []byte\n+\tif buf != nil {\n+\t\tb = buf[:]\n+\t\ts = slicebytetostringtmp(b)\n+\t} else {\n+\t\ts, b = rawstring(4)\n+\t}\n+\tif int64(rune(v)) != v {\n+\t\tv = runeerror\n+\t}\n+\tn := runetochar(b, rune(v))\n+\treturn s[:n]\n+}\n+\n+// stringiter returns the index of the next\n+// rune after the rune that starts at s[k].\n+func stringiter(s string, k int) int {\n+\tif k >= len(s) {\n+\t\t// 0 is end of iteration\n+\t\treturn 0\n+\t}\n+\n+\tc := s[k]\n+\tif c < runeself {\n+\t\treturn k + 1\n+\t}\n+\n+\t// multi-char rune\n+\t_, n := charntorune(s[k:])\n+\treturn k + n\n+}\n+\n+// stringiter2 returns the rune that starts at s[k]\n+// and the index where the next rune starts.\n+func stringiter2(s string, k int) (int, rune) {\n+\tif k >= len(s) {\n+\t\t// 0 is end of iteration\n+\t\treturn 0, 0\n+\t}\n+\n+\tc := s[k]\n+\tif c < runeself {\n+\t\treturn k + 1, rune(c)\n+\t}\n+\n+\t// multi-char rune\n+\tr, n := charntorune(s[k:])\n+\treturn k + n, r\n+}\n+\n+// rawstring allocates storage for a new string. The returned\n+// string and byte slice both refer to the same storage.\n+// The storage is not zeroed. Callers should use\n+// b to set the string contents and then drop b.\n+func rawstring(size int) (s string, b []byte) {\n+\tp := mallocgc(uintptr(size), nil, false)\n+\n+\tstringStructOf(&s).str = p\n+\tstringStructOf(&s).len = size\n+\n+\t*(*slice)(unsafe.Pointer(&b)) = slice{p, size, size}\n+\treturn\n+}\n+\n+// rawbyteslice allocates a new byte slice. The byte slice is not zeroed.\n+func rawbyteslice(size int) (b []byte) {\n+\tcap := roundupsize(uintptr(size))\n+\tp := mallocgc(cap, nil, false)\n+\tif cap != uintptr(size) {\n+\t\tmemclr(add(p, uintptr(size)), cap-uintptr(size))\n+\t}\n+\n+\t*(*slice)(unsafe.Pointer(&b)) = slice{p, size, int(cap)}\n+\treturn\n+}\n+\n+// rawruneslice allocates a new rune slice. The rune slice is not zeroed.\n+func rawruneslice(size int) (b []rune) {\n+\tif uintptr(size) > _MaxMem/4 {\n+\t\tthrow(\"out of memory\")\n+\t}\n+\tmem := roundupsize(uintptr(size) * 4)\n+\tp := mallocgc(mem, nil, false)\n+\tif mem != uintptr(size)*4 {\n+\t\tmemclr(add(p, uintptr(size)*4), mem-uintptr(size)*4)\n+\t}\n+\n+\t*(*slice)(unsafe.Pointer(&b)) = slice{p, size, int(mem / 4)}\n+\treturn\n+}\n+\n+// used by cmd/cgo\n+func gobytes(p *byte, n int) []byte {\n+\tif n == 0 {\n+\t\treturn make([]byte, 0)\n+\t}\n+\tx := make([]byte, n)\n+\tmemmove(unsafe.Pointer(&x[0]), unsafe.Pointer(p), uintptr(n))\n+\treturn x\n+}\n+\n+func gostring(p *byte) string {\n+\tl := findnull(p)\n+\tif l == 0 {\n+\t\treturn \"\"\n+\t}\n+\ts, b := rawstring(l)\n+\tmemmove(unsafe.Pointer(&b[0]), unsafe.Pointer(p), uintptr(l))\n+\treturn s\n+}\n+\n+func gostringn(p *byte, l int) string {\n+\tif l == 0 {\n+\t\treturn \"\"\n+\t}\n+\ts, b := rawstring(l)\n+\tmemmove(unsafe.Pointer(&b[0]), unsafe.Pointer(p), uintptr(l))\n+\treturn s\n+}\n+\n+func index(s, t string) int {\n+\tif len(t) == 0 {\n+\t\treturn 0\n+\t}\n+\tfor i := 0; i < len(s); i++ {\n+\t\tif s[i] == t[0] && hasprefix(s[i:], t) {\n+\t\t\treturn i\n+\t\t}\n+\t}\n+\treturn -1\n+}\n+\n+func contains(s, t string) bool {\n+\treturn index(s, t) >= 0\n+}\n+\n+func hasprefix(s, t string) bool {\n+\treturn len(s) >= len(t) && s[:len(t)] == t\n+}\n+\n+func atoi(s string) int {\n+\tn := 0\n+\tfor len(s) > 0 && '0' <= s[0] && s[0] <= '9' {\n+\t\tn = n*10 + int(s[0]) - '0'\n+\t\ts = s[1:]\n+\t}\n+\treturn n\n+}\n+\n+//go:nosplit\n+func findnull(s *byte) int {\n+\tif s == nil {\n+\t\treturn 0\n+\t}\n+\tp := (*[_MaxMem/2 - 1]byte)(unsafe.Pointer(s))\n+\tl := 0\n+\tfor p[l] != 0 {\n+\t\tl++\n+\t}\n+\treturn l\n+}\n+\n+func findnullw(s *uint16) int {\n+\tif s == nil {\n+\t\treturn 0\n+\t}\n+\tp := (*[_MaxMem/2/2 - 1]uint16)(unsafe.Pointer(s))\n+\tl := 0\n+\tfor p[l] != 0 {\n+\t\tl++\n+\t}\n+\treturn l\n+}\n+\n+//go:nosplit\n+func gostringnocopy(str *byte) string {\n+\tss := stringStruct{str: unsafe.Pointer(str), len: findnull(str)}\n+\ts := *(*string)(unsafe.Pointer(&ss))\n+\treturn s\n+}\n+\n+func gostringw(strw *uint16) string {\n+\tvar buf [8]byte\n+\tstr := (*[_MaxMem/2/2 - 1]uint16)(unsafe.Pointer(strw))\n+\tn1 := 0\n+\tfor i := 0; str[i] != 0; i++ {\n+\t\tn1 += runetochar(buf[:], rune(str[i]))\n+\t}\n+\ts, b := rawstring(n1 + 4)\n+\tn2 := 0\n+\tfor i := 0; str[i] != 0; i++ {\n+\t\t// check for race\n+\t\tif n2 >= n1 {\n+\t\t\tbreak\n+\t\t}\n+\t\tn2 += runetochar(b[n2:], rune(str[i]))\n+\t}\n+\tb[n2] = 0 // for luck\n+\treturn s[:n2]\n+}"}, {"sha": "11fa454a5a8bf8dceb6e0bc7dd3bdd6a31f3e6f1", "filename": "libgo/go/runtime/string_test.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/libgo%2Fgo%2Fruntime%2Fstring_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/libgo%2Fgo%2Fruntime%2Fstring_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstring_test.go?ref=1ad16c52842e0513b96a0e02d2a431dc0f338c5d", "patch": "@@ -223,7 +223,9 @@ func TestIntStringAllocs(t *testing.T) {\n \t\t\tt.Fatalf(\"bad\")\n \t\t}\n \t})\n-\tif n != 0 {\n+\t// was n != 0, changed for gccgo, which currently does one\n+\t// allocation for each call to string(unknown).\n+\tif n > 2 {\n \t\tt.Fatalf(\"want 0 allocs, got %v\", n)\n \t}\n }"}, {"sha": "d598a0afc4f0c66fb9f47dd94c15dcbb7ea49bc4", "filename": "libgo/go/runtime/stubs.go", "status": "modified", "additions": 3, "deletions": 81, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/libgo%2Fgo%2Fruntime%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/libgo%2Fgo%2Fruntime%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs.go?ref=1ad16c52842e0513b96a0e02d2a431dc0f338c5d", "patch": "@@ -250,17 +250,6 @@ func typedmemmove(typ *_type, dst, src unsafe.Pointer) {\n \tmemmove(dst, src, typ.size)\n }\n \n-// Here for gccgo unless and until we port string.go.\n-type stringStruct struct {\n-\tstr unsafe.Pointer\n-\tlen int\n-}\n-\n-// Here for gccgo unless and until we port string.go.\n-func stringStructOf(sp *string) *stringStruct {\n-\treturn (*stringStruct)(unsafe.Pointer(sp))\n-}\n-\n // Here for gccgo unless and until we port slice.go.\n type slice struct {\n \tarray unsafe.Pointer\n@@ -286,76 +275,6 @@ func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \treturn c_mallocgc(size, uintptr(unsafe.Pointer(typ)), flag)\n }\n \n-// Here for gccgo unless and until we port string.go.\n-func rawstring(size int) (p unsafe.Pointer, s string) {\n-\tp = mallocgc(uintptr(size), nil, false)\n-\n-\t(*(*stringStruct)(unsafe.Pointer(&s))).str = p\n-\t(*(*stringStruct)(unsafe.Pointer(&s))).len = size\n-\n-\treturn\n-}\n-\n-// Here for gccgo unless and until we port string.go.\n-func gostring(p *byte) string {\n-\tl := findnull(p)\n-\tif l == 0 {\n-\t\treturn \"\"\n-\t}\n-\tm, s := rawstring(l)\n-\tmemmove(m, unsafe.Pointer(p), uintptr(l))\n-\treturn s\n-}\n-\n-// Here for gccgo unless and until we port string.go.\n-func index(s, t string) int {\n-\tif len(t) == 0 {\n-\t\treturn 0\n-\t}\n-\tfor i := 0; i < len(s); i++ {\n-\t\tif s[i] == t[0] && hasprefix(s[i:], t) {\n-\t\t\treturn i\n-\t\t}\n-\t}\n-\treturn -1\n-}\n-\n-// Here for gccgo unless and until we port string.go.\n-func hasprefix(s, t string) bool {\n-\treturn len(s) >= len(t) && s[:len(t)] == t\n-}\n-\n-// Here for gccgo unless and until we port string.go.\n-//go:nosplit\n-func findnull(s *byte) int {\n-\tif s == nil {\n-\t\treturn 0\n-\t}\n-\tp := (*[_MaxMem/2 - 1]byte)(unsafe.Pointer(s))\n-\tl := 0\n-\tfor p[l] != 0 {\n-\t\tl++\n-\t}\n-\treturn l\n-}\n-\n-// Here for gccgo unless and until we port string.go.\n-//go:nosplit\n-func gostringnocopy(str *byte) string {\n-\tss := stringStruct{str: unsafe.Pointer(str), len: findnull(str)}\n-\treturn *(*string)(unsafe.Pointer(&ss))\n-}\n-\n-// Here for gccgo unless and until we port string.go.\n-func atoi(s string) int {\n-\tn := 0\n-\tfor len(s) > 0 && '0' <= s[0] && s[0] <= '9' {\n-\t\tn = n*10 + int(s[0]) - '0'\n-\t\ts = s[1:]\n-\t}\n-\treturn n\n-}\n-\n // Here for gccgo until we port mgc.go.\n var writeBarrier struct {\n \tenabled bool   // compiler emits a check of this before calling write barrier\n@@ -445,3 +364,6 @@ func releaseSudog(s *sudog) {\n \n // Temporary hack for gccgo until we port the garbage collector.\n func typeBitsBulkBarrier(typ *_type, p, size uintptr) {}\n+\n+// Here for gccgo until we port msize.go.\n+func roundupsize(uintptr) uintptr"}, {"sha": "088b78690feca215eda492369bdf728dec6535b4", "filename": "libgo/runtime/go-byte-array-to-string.c", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec69f566076547b618447ba5531260c25abed3e/libgo%2Fruntime%2Fgo-byte-array-to-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec69f566076547b618447ba5531260c25abed3e/libgo%2Fruntime%2Fgo-byte-array-to-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-byte-array-to-string.c?ref=2ec69f566076547b618447ba5531260c25abed3e", "patch": "@@ -1,24 +0,0 @@\n-/* go-byte-array-to-string.c -- convert an array of bytes to a string in Go.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"arch.h\"\n-#include \"malloc.h\"\n-\n-String\n-__go_byte_array_to_string (const void* p, intgo len)\n-{\n-  const unsigned char *bytes;\n-  unsigned char *retdata;\n-  String ret;\n-\n-  bytes = (const unsigned char *) p;\n-  retdata = runtime_mallocgc ((uintptr) len, 0, FlagNoScan);\n-  __builtin_memcpy (retdata, bytes, len);\n-  ret.str = retdata;\n-  ret.len = len;\n-  return ret;\n-}"}, {"sha": "f37213125a2209cdebd98930b8b1c1d0efbc9b8f", "filename": "libgo/runtime/go-int-array-to-string.c", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec69f566076547b618447ba5531260c25abed3e/libgo%2Fruntime%2Fgo-int-array-to-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec69f566076547b618447ba5531260c25abed3e/libgo%2Fruntime%2Fgo-int-array-to-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-int-array-to-string.c?ref=2ec69f566076547b618447ba5531260c25abed3e", "patch": "@@ -1,89 +0,0 @@\n-/* go-int-array-to-string.c -- convert an array of ints to a string in Go.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"go-assert.h\"\n-#include \"runtime.h\"\n-#include \"arch.h\"\n-#include \"malloc.h\"\n-\n-String\n-__go_int_array_to_string (const void* p, intgo len)\n-{\n-  const int32 *ints;\n-  intgo slen;\n-  intgo i;\n-  unsigned char *retdata;\n-  String ret;\n-  unsigned char *s;\n-\n-  ints = (const int32 *) p;\n-\n-  slen = 0;\n-  for (i = 0; i < len; ++i)\n-    {\n-      int32 v;\n-\n-      v = ints[i];\n-\n-      if (v < 0 || v > 0x10ffff)\n-\tv = 0xfffd;\n-      else if (0xd800 <= v && v <= 0xdfff)\n-\tv = 0xfffd;\n-\n-      if (v <= 0x7f)\n-\tslen += 1;\n-      else if (v <= 0x7ff)\n-\tslen += 2;\n-      else if (v <= 0xffff)\n-\tslen += 3;\n-      else\n-\tslen += 4;\n-    }\n-\n-  retdata = runtime_mallocgc ((uintptr) slen, 0, FlagNoScan);\n-  ret.str = retdata;\n-  ret.len = slen;\n-\n-  s = retdata;\n-  for (i = 0; i < len; ++i)\n-    {\n-      int32 v;\n-\n-      v = ints[i];\n-\n-      /* If V is out of range for UTF-8, substitute the replacement\n-\t character.  */\n-      if (v < 0 || v > 0x10ffff)\n-\tv = 0xfffd;\n-      else if (0xd800 <= v && v <= 0xdfff)\n-\tv = 0xfffd;\n-\n-      if (v <= 0x7f)\n-\t*s++ = v;\n-      else if (v <= 0x7ff)\n-\t{\n-\t  *s++ = 0xc0 | ((v >> 6) & 0x1f);\n-\t  *s++ = 0x80 | (v & 0x3f);\n-\t}\n-      else if (v <= 0xffff)\n-\t{\n-\t  *s++ = 0xe0 | ((v >> 12) & 0xf);\n-\t  *s++ = 0x80 | ((v >> 6) & 0x3f);\n-\t  *s++ = 0x80 | (v & 0x3f);\n-\t}\n-      else\n-\t{\n-\t  *s++ = 0xf0 | ((v >> 18) & 0x7);\n-\t  *s++ = 0x80 | ((v >> 12) & 0x3f);\n-\t  *s++ = 0x80 | ((v >> 6) & 0x3f);\n-\t  *s++ = 0x80 | (v & 0x3f);\n-\t}\n-    }\n-\n-  __go_assert (s - retdata == slen);\n-\n-  return ret;\n-}"}, {"sha": "d90b1ddfed1d19079fd06e0f06c01302f3444dc7", "filename": "libgo/runtime/go-int-to-string.c", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec69f566076547b618447ba5531260c25abed3e/libgo%2Fruntime%2Fgo-int-to-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec69f566076547b618447ba5531260c25abed3e/libgo%2Fruntime%2Fgo-int-to-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-int-to-string.c?ref=2ec69f566076547b618447ba5531260c25abed3e", "patch": "@@ -1,69 +0,0 @@\n-/* go-int-to-string.c -- convert an integer to a string in Go.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"arch.h\"\n-#include \"malloc.h\"\n-\n-String\n-__go_int_to_string (intgo v)\n-{\n-  char buf[4];\n-  int len;\n-  unsigned char *retdata;\n-  String ret;\n-\n-  /* A negative value is not valid UTF-8; turn it into the replacement\n-     character.  */\n-  if (v < 0)\n-    v = 0xfffd;\n-\n-  if (v <= 0x7f)\n-    {\n-      buf[0] = v;\n-      len = 1;\n-    }\n-  else if (v <= 0x7ff)\n-    {\n-      buf[0] = 0xc0 + (v >> 6);\n-      buf[1] = 0x80 + (v & 0x3f);\n-      len = 2;\n-    }\n-  else\n-    {\n-      /* If the value is out of range for UTF-8, turn it into the\n-\t \"replacement character\".  */\n-      if (v > 0x10ffff)\n-\tv = 0xfffd;\n-      /* If the value is a surrogate pair, which is invalid in UTF-8,\n-\t turn it into the replacement character.  */\n-      if (v >= 0xd800 && v < 0xe000)\n-\tv = 0xfffd;\n-\n-      if (v <= 0xffff)\n-\t{\n-\t  buf[0] = 0xe0 + (v >> 12);\n-\t  buf[1] = 0x80 + ((v >> 6) & 0x3f);\n-\t  buf[2] = 0x80 + (v & 0x3f);\n-\t  len = 3;\n-\t}\n-      else\n-\t{\n-\t  buf[0] = 0xf0 + (v >> 18);\n-\t  buf[1] = 0x80 + ((v >> 12) & 0x3f);\n-\t  buf[2] = 0x80 + ((v >> 6) & 0x3f);\n-\t  buf[3] = 0x80 + (v & 0x3f);\n-\t  len = 4;\n-\t}\n-    }\n-\n-  retdata = runtime_mallocgc (len, 0, FlagNoScan);\n-  __builtin_memcpy (retdata, buf, len);\n-  ret.str = retdata;\n-  ret.len = len;\n-\n-  return ret;\n-}"}, {"sha": "4c65e21516757eb0a917e98dca77b743773d4fff", "filename": "libgo/runtime/go-rune.c", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec69f566076547b618447ba5531260c25abed3e/libgo%2Fruntime%2Fgo-rune.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec69f566076547b618447ba5531260c25abed3e/libgo%2Fruntime%2Fgo-rune.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-rune.c?ref=2ec69f566076547b618447ba5531260c25abed3e", "patch": "@@ -1,97 +0,0 @@\n-/* go-rune.c -- rune functions for Go.\n-\n-   Copyright 2009, 2010 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stddef.h>\n-\n-#include \"runtime.h\"\n-#include \"go-string.h\"\n-\n-/* Get a character from the UTF-8 string STR, of length LEN.  Store\n-   the Unicode character, if any, in *RUNE.  Return the number of\n-   characters used from STR.  */\n-\n-int\n-__go_get_rune (const unsigned char *str, size_t len, int32 *rune)\n-{\n-  int c, c1, c2, c3, l;\n-\n-  /* Default to the \"replacement character\".  */\n-  *rune = 0xfffd;\n-\n-  if (len <= 0)\n-    return 1;\n-\n-  c = *str;\n-  if (c <= 0x7f)\n-    {\n-      *rune = c;\n-      return 1;\n-    }\n-\n-  if (len <= 1)\n-    return 1;\n-\n-  c1 = str[1];\n-  if ((c & 0xe0) == 0xc0\n-      && (c1 & 0xc0) == 0x80)\n-    {\n-      l = (((c & 0x1f) << 6) + (c1 & 0x3f));\n-      if (l <= 0x7f)\n-\treturn 1;\n-      *rune = l;\n-      return 2;\n-    }\n-\n-  if (len <= 2)\n-    return 1;\n-\n-  c2 = str[2];\n-  if ((c & 0xf0) == 0xe0\n-      && (c1 & 0xc0) == 0x80\n-      && (c2 & 0xc0) == 0x80)\n-    {\n-      l = (((c & 0xf) << 12)\n-\t   + ((c1 & 0x3f) << 6)\n-\t   + (c2 & 0x3f));\n-\n-      if (l <= 0x7ff)\n-\treturn 1;\n-\n-      if (l >= 0xd800 && l < 0xe000)\n-\t{\n-\t  /* Invalid surrogate half; return replace character.  */\n-\t  return 1;\n-\t}\n-\n-      *rune = l;\n-\n-      return 3;\n-    }\n-\n-  if (len <= 3)\n-    return 1;\n-\n-  c3 = str[3];\n-  if ((c & 0xf8) == 0xf0\n-      && (c1 & 0xc0) == 0x80\n-      && (c2 & 0xc0) == 0x80\n-      && (c3 & 0xc0) == 0x80)\n-    {\n-      l = (((c & 0x7) << 18)\n-\t   + ((c1 & 0x3f) << 12)\n-\t   + ((c2 & 0x3f) << 6)\n-\t   + (c3 & 0x3f));\n-\n-      if (l <= 0xffff || l > 0x10ffff)\n-\treturn 1;\n-\n-      *rune = l;\n-      return 4;\n-    }\n-\n-  /* Invalid encoding.  Return 1 so that we advance.  */\n-  return 1;\n-}"}, {"sha": "61591eb975240f1d6fc7b16cf901871b6f780275", "filename": "libgo/runtime/go-string-to-byte-array.c", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec69f566076547b618447ba5531260c25abed3e/libgo%2Fruntime%2Fgo-string-to-byte-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec69f566076547b618447ba5531260c25abed3e/libgo%2Fruntime%2Fgo-string-to-byte-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-string-to-byte-array.c?ref=2ec69f566076547b618447ba5531260c25abed3e", "patch": "@@ -1,28 +0,0 @@\n-/* go-string-to-byte-array.c -- convert a string to an array of bytes in Go.\n-\n-   Copyright 2010 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"array.h\"\n-#include \"arch.h\"\n-#include \"malloc.h\"\n-\n-struct __go_open_array\n-__go_string_to_byte_array (String str)\n-{\n-  uintptr cap;\n-  unsigned char *data;\n-  struct __go_open_array ret;\n-\n-  cap = runtime_roundupsize (str.len);\n-  data = (unsigned char *) runtime_mallocgc (cap, 0, FlagNoScan | FlagNoZero);\n-  __builtin_memcpy (data, str.str, str.len);\n-  if (cap != (uintptr) str.len)\n-    __builtin_memset (data + str.len, 0, cap - (uintptr) str.len);\n-  ret.__values = (void *) data;\n-  ret.__count = str.len;\n-  ret.__capacity = str.len;\n-  return ret;\n-}"}, {"sha": "554688913101acb0021298c28220da0ff3087328", "filename": "libgo/runtime/go-string-to-int-array.c", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec69f566076547b618447ba5531260c25abed3e/libgo%2Fruntime%2Fgo-string-to-int-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec69f566076547b618447ba5531260c25abed3e/libgo%2Fruntime%2Fgo-string-to-int-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-string-to-int-array.c?ref=2ec69f566076547b618447ba5531260c25abed3e", "patch": "@@ -1,56 +0,0 @@\n-/* go-string-to-int-array.c -- convert a string to an array of ints in Go.\n-\n-   Copyright 2010 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"go-alloc.h\"\n-#include \"go-string.h\"\n-#include \"array.h\"\n-#include \"arch.h\"\n-#include \"malloc.h\"\n-\n-struct __go_open_array\n-__go_string_to_int_array (String str)\n-{\n-  size_t c;\n-  const unsigned char *p;\n-  const unsigned char *pend;\n-  uintptr mem;\n-  uint32_t *data;\n-  uint32_t *pd;\n-  struct __go_open_array ret;\n-\n-  c = 0;\n-  p = str.str;\n-  pend = p + str.len;\n-  while (p < pend)\n-    {\n-      int rune;\n-\n-      ++c;\n-      p += __go_get_rune (p, pend - p, &rune);\n-    }\n-\n-  if (c > MaxMem / sizeof (uint32_t))\n-    runtime_throw (\"out of memory\");\n-\n-  mem = runtime_roundupsize (c * sizeof (uint32_t));\n-  data = (uint32_t *) runtime_mallocgc (mem, 0, FlagNoScan | FlagNoZero);\n-  p = str.str;\n-  pd = data;\n-  while (p < pend)\n-    {\n-      int rune;\n-\n-      p += __go_get_rune (p, pend - p, &rune);\n-      *pd++ = rune;\n-    }\n-  if (mem > (uintptr) c * sizeof (uint32_t))\n-    __builtin_memset (data + c, 0, mem - (uintptr) c * sizeof (uint32_t));\n-  ret.__values = (void *) data;\n-  ret.__count = c;\n-  ret.__capacity = (intgo) (mem / sizeof (uint32_t));\n-  return ret;\n-}"}, {"sha": "13915e3e67395d14ffed315248d2131cebd35730", "filename": "libgo/runtime/go-strplus.c", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec69f566076547b618447ba5531260c25abed3e/libgo%2Fruntime%2Fgo-strplus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec69f566076547b618447ba5531260c25abed3e/libgo%2Fruntime%2Fgo-strplus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-strplus.c?ref=2ec69f566076547b618447ba5531260c25abed3e", "patch": "@@ -1,30 +0,0 @@\n-/* go-strplus.c -- the go string append function.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"arch.h\"\n-#include \"malloc.h\"\n-\n-String\n-__go_string_plus (String s1, String s2)\n-{\n-  int len;\n-  byte *retdata;\n-  String ret;\n-\n-  if (s1.len == 0)\n-    return s2;\n-  else if (s2.len == 0)\n-    return s1;\n-\n-  len = s1.len + s2.len;\n-  retdata = runtime_mallocgc (len, 0, FlagNoScan | FlagNoZero);\n-  __builtin_memcpy (retdata, s1.str, s1.len);\n-  __builtin_memcpy (retdata + s1.len, s2.str, s2.len);\n-  ret.str = retdata;\n-  ret.len = len;\n-  return ret;\n-}"}, {"sha": "b2dbf900c01b6f4852e346e5c306977e5948a204", "filename": "libgo/runtime/malloc.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/libgo%2Fruntime%2Fmalloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/libgo%2Fruntime%2Fmalloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.h?ref=1ad16c52842e0513b96a0e02d2a431dc0f338c5d", "patch": "@@ -285,7 +285,8 @@ void\truntime_updatememstats(GCStats *stats);\n //\tmaking new objects in class i\n \n int32\truntime_SizeToClass(int32);\n-uintptr\truntime_roundupsize(uintptr);\n+uintptr\truntime_roundupsize(uintptr)\n+  __asm__(GOSYM_PREFIX \"runtime.roundupsize\");\n extern\tint32\truntime_class_to_size[_NumSizeClasses];\n extern\tint32\truntime_class_to_allocnpages[_NumSizeClasses];\n extern\tint8\truntime_size_to_class8[1024/8 + 1];"}, {"sha": "00448215c917ce06c3e0873811fbf33a0633891e", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=1ad16c52842e0513b96a0e02d2a431dc0f338c5d", "patch": "@@ -2216,7 +2216,7 @@ static void\n gc(struct gc_args *args)\n {\n \tM *m;\n-\tint64 t0, t1, t2, t3, t4;\n+\tint64 tm0, tm1, tm2, tm3, tm4;\n \tuint64 heap0, heap1, obj, ninstr;\n \tGCStats stats;\n \tuint32 i;\n@@ -2228,7 +2228,7 @@ gc(struct gc_args *args)\n \t\truntime_tracegc();\n \n \tm->traceback = 2;\n-\tt0 = args->start_time;\n+\ttm0 = args->start_time;\n \twork.tstart = args->start_time; \n \n \tif(CollectStats)\n@@ -2239,9 +2239,9 @@ gc(struct gc_args *args)\n \t\twork.markfor = runtime_parforalloc(MaxGcproc);\n \tm->locks--;\n \n-\tt1 = 0;\n+\ttm1 = 0;\n \tif(runtime_debug.gctrace)\n-\t\tt1 = runtime_nanotime();\n+\t\ttm1 = runtime_nanotime();\n \n \t// Sweep what is not sweeped by bgsweep.\n \twhile(runtime_sweepone() != (uintptr)-1)\n@@ -2256,17 +2256,17 @@ gc(struct gc_args *args)\n \t\truntime_helpgc(work.nproc);\n \t}\n \n-\tt2 = 0;\n+\ttm2 = 0;\n \tif(runtime_debug.gctrace)\n-\t\tt2 = runtime_nanotime();\n+\t\ttm2 = runtime_nanotime();\n \n \tgchelperstart();\n \truntime_parfordo(work.markfor);\n \tscanblock(nil, true);\n \n-\tt3 = 0;\n+\ttm3 = 0;\n \tif(runtime_debug.gctrace)\n-\t\tt3 = runtime_nanotime();\n+\t\ttm3 = runtime_nanotime();\n \n \tbufferList[m->helpgc].busy = 0;\n \tif(work.nproc > 1)\n@@ -2280,14 +2280,14 @@ gc(struct gc_args *args)\n \t// concurrent/lazy sweep will reduce this number while discovering new garbage\n \tmstats.next_gc = mstats.heap_alloc+(mstats.heap_alloc-runtime_stacks_sys)*gcpercent/100;\n \n-\tt4 = runtime_nanotime();\n+\ttm4 = runtime_nanotime();\n \tmstats.last_gc = runtime_unixnanotime();  // must be Unix time to make sense to user\n-\tmstats.pause_ns[mstats.numgc%nelem(mstats.pause_ns)] = t4 - t0;\n+\tmstats.pause_ns[mstats.numgc%nelem(mstats.pause_ns)] = tm4 - tm0;\n \tmstats.pause_end[mstats.numgc%nelem(mstats.pause_end)] = mstats.last_gc;\n-\tmstats.pause_total_ns += t4 - t0;\n+\tmstats.pause_total_ns += tm4 - tm0;\n \tmstats.numgc++;\n \tif(mstats.debuggc)\n-\t\truntime_printf(\"pause %D\\n\", t4-t0);\n+\t\truntime_printf(\"pause %D\\n\", tm4-tm0);\n \n \tif(runtime_debug.gctrace) {\n \t\theap1 = mstats.heap_alloc;\n@@ -2305,7 +2305,7 @@ gc(struct gc_args *args)\n \t\truntime_printf(\"gc%d(%d): %D+%D+%D+%D us, %D -> %D MB, %D (%D-%D) objects,\"\n \t\t\t\t\" %d/%d/%d sweeps,\"\n \t\t\t\t\" %D(%D) handoff, %D(%D) steal, %D/%D/%D yields\\n\",\n-\t\t\tmstats.numgc, work.nproc, (t1-t0)/1000, (t2-t1)/1000, (t3-t2)/1000, (t4-t3)/1000,\n+\t\t\tmstats.numgc, work.nproc, (tm1-tm0)/1000, (tm2-tm1)/1000, (tm3-tm2)/1000, (tm4-tm3)/1000,\n \t\t\theap0>>20, heap1>>20, obj,\n \t\t\tmstats.nmalloc, mstats.nfree,\n \t\t\tsweep.nspan, gcstats.nbgsweep, gcstats.npausesweep,"}, {"sha": "8c12265447dc361706222f9d2064ddd589736563", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad16c52842e0513b96a0e02d2a431dc0f338c5d/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=1ad16c52842e0513b96a0e02d2a431dc0f338c5d", "patch": "@@ -307,8 +307,8 @@ extern\tbool\truntime_isarchive;\n #define runtime_strcmp(s1, s2) __builtin_strcmp((s1), (s2))\n #define runtime_strncmp(s1, s2, n) __builtin_strncmp((s1), (s2), (n))\n #define runtime_strstr(s1, s2) __builtin_strstr((s1), (s2))\n-intgo\truntime_findnull(const byte*);\n-intgo\truntime_findnullw(const uint16*);\n+intgo\truntime_findnull(const byte*)\n+  __asm__ (GOSYM_PREFIX \"runtime.findnull\");\n \n void\truntime_gogo(G*);\n struct __go_func_type;\n@@ -328,8 +328,8 @@ int32\truntime_snprintf(byte*, int32, const char*, ...);\n #define runtime_mcmp(a, b, s) __builtin_memcmp((a), (b), (s))\n #define runtime_memmove(a, b, s) __builtin_memmove((a), (b), (s))\n void*\truntime_mal(uintptr);\n-String\truntime_gostring(const byte*);\n-String\truntime_gostringnocopy(const byte*);\n+String\truntime_gostringnocopy(const byte*)\n+  __asm__ (GOSYM_PREFIX \"runtime.gostringnocopy\");\n void\truntime_schedinit(void);\n void\truntime_initsig(bool);\n void\truntime_sigenable(uint32 sig);"}, {"sha": "0ad180b9832d70bbac11a47ac461d101322fa653", "filename": "libgo/runtime/string.goc", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec69f566076547b618447ba5531260c25abed3e/libgo%2Fruntime%2Fstring.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec69f566076547b618447ba5531260c25abed3e/libgo%2Fruntime%2Fstring.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fstring.goc?ref=2ec69f566076547b618447ba5531260c25abed3e", "patch": "@@ -1,123 +0,0 @@\n-// Copyright 2009, 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package runtime\n-#include \"runtime.h\"\n-#include \"arch.h\"\n-#include \"malloc.h\"\n-#include \"go-string.h\"\n-\n-#define charntorune(pv, str, len) __go_get_rune(str, len, pv)\n-\n-const String\truntime_emptystring;\n-\n-intgo\n-runtime_findnull(const byte *s)\n-{\n-\tif(s == nil)\n-\t\treturn 0;\n-\treturn __builtin_strlen((const char*) s);\n-}\n-\n-intgo\n-runtime_findnullw(const uint16 *s)\n-{\n-\tintgo l;\n-\n-\tif(s == nil)\n-\t\treturn 0;\n-\tfor(l=0; s[l]!=0; l++)\n-\t\t;\n-\treturn l;\n-}\n-\n-static String\n-gostringsize(intgo l, byte** pmem)\n-{\n-\tString s;\n-\tbyte *mem;\n-\n-\tif(l == 0) {\n-\t\t*pmem = nil;\n-\t\treturn runtime_emptystring;\n-\t}\n-\tmem = runtime_mallocgc(l, 0, FlagNoScan|FlagNoZero);\n-\ts.str = mem;\n-\ts.len = l;\n-\t*pmem = mem;\n-\treturn s;\n-}\n-\n-String\n-runtime_gostring(const byte *str)\n-{\n-\tintgo l;\n-\tString s;\n-\tbyte *mem;\n-\n-\tl = runtime_findnull(str);\n-\ts = gostringsize(l, &mem);\n-\truntime_memmove(mem, str, l);\n-\treturn s;\n-}\n-\n-String\n-runtime_gostringnocopy(const byte *str)\n-{\n-\tString s;\n-\t\n-\ts.str = str;\n-\ts.len = runtime_findnull(str);\n-\treturn s;\n-}\n-\n-func cstringToGo(str *byte) (s String) {\n-\ts = runtime_gostringnocopy(str);\n-}\n-\n-enum\n-{\n-\tRuneself\t= 0x80,\n-};\n-\n-func stringiter(s String, k int) (retk int) {\n-\tint32 l;\n-\n-\tif(k >= s.len) {\n-\t\t// retk=0 is end of iteration\n-\t\tretk = 0;\n-\t\tgoto out;\n-\t}\n-\n-\tl = s.str[k];\n-\tif(l < Runeself) {\n-\t\tretk = k+1;\n-\t\tgoto out;\n-\t}\n-\n-\t// multi-char rune\n-\tretk = k + charntorune(&l, s.str+k, s.len-k);\n-\n-out:\n-}\n-\n-func stringiter2(s String, k int) (retk int, retv int32) {\n-\tif(k >= s.len) {\n-\t\t// retk=0 is end of iteration\n-\t\tretk = 0;\n-\t\tretv = 0;\n-\t\tgoto out;\n-\t}\n-\n-\tretv = s.str[k];\n-\tif(retv < Runeself) {\n-\t\tretk = k+1;\n-\t\tgoto out;\n-\t}\n-\n-\t// multi-char rune\n-\tretk = k + charntorune(&retv, s.str+k, s.len-k);\n-\n-out:\n-}"}]}