{"sha": "1dec70fa4cc518b6d823be7b643a39697cb4c625", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWRlYzcwZmE0Y2M1MThiNmQ4MjNiZTdiNjQzYTM5Njk3Y2I0YzYyNQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2012-08-31T21:35:33Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2012-08-31T21:35:33Z"}, "message": "re PR c++/18747 (\"template<> int i;\" accepted)\n\n\tPR c++/18747\n\t* pt.c (check_template_variable): New.\n\t(num_template_headers_for_class): Split out...\n\t* decl.c (grokdeclarator): ...from here.\n\t(start_decl): Remove redundant diagnostic.\n\t* cp-tree.h: Declare them\n\t* parser.c (cp_parser_single_declaration): Call check_template_variable.\n.\nCo-Authored-By: Jason Merrill <jason@redhat.com>\n\nFrom-SVN: r190842", "tree": {"sha": "1524695c56ed99a3ea06e58c582ae2814eb03a05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1524695c56ed99a3ea06e58c582ae2814eb03a05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1dec70fa4cc518b6d823be7b643a39697cb4c625", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dec70fa4cc518b6d823be7b643a39697cb4c625", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1dec70fa4cc518b6d823be7b643a39697cb4c625", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dec70fa4cc518b6d823be7b643a39697cb4c625/comments", "author": null, "committer": null, "parents": [{"sha": "be279f86519217092f8ddd89f4cc0688720d1730", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be279f86519217092f8ddd89f4cc0688720d1730", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be279f86519217092f8ddd89f4cc0688720d1730"}], "stats": {"total": 138, "additions": 103, "deletions": 35}, "files": [{"sha": "c36ed8888ddd9b38f854e001af04bef506eb209d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dec70fa4cc518b6d823be7b643a39697cb4c625/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dec70fa4cc518b6d823be7b643a39697cb4c625/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1dec70fa4cc518b6d823be7b643a39697cb4c625", "patch": "@@ -1,3 +1,14 @@\n+2012-08-31  Paolo Carlini  <paolo.carlini@oracle.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/18747\n+\t* pt.c (check_template_variable): New.\n+\t(num_template_headers_for_class): Split out...\n+\t* decl.c (grokdeclarator): ...from here.\n+\t(start_decl): Remove redundant diagnostic.\n+\t* cp-tree.h: Declare them\n+\t* parser.c (cp_parser_single_declaration): Call check_template_variable.\n+\n 2012-08-31  Ollie Wild  <aaw@google.com>\n \n \tPR c++/54197"}, {"sha": "bd57b92c961939540cc5cd1c8bfefe79ea687f3b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dec70fa4cc518b6d823be7b643a39697cb4c625/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dec70fa4cc518b6d823be7b643a39697cb4c625/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1dec70fa4cc518b6d823be7b643a39697cb4c625", "patch": "@@ -5316,6 +5316,8 @@ extern void end_specialization\t\t\t(void);\n extern void begin_explicit_instantiation\t(void);\n extern void end_explicit_instantiation\t\t(void);\n extern tree check_explicit_specialization\t(tree, tree, int, int);\n+extern int num_template_headers_for_class\t(tree);\n+extern void check_template_variable\t\t(tree);\n extern tree make_auto\t\t\t\t(void);\n extern tree do_auto_deduction\t\t\t(tree, tree, tree);\n extern tree type_uses_auto\t\t\t(tree);"}, {"sha": "8b94e26ac0ce67097b361bc25e8292274e9ca340", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dec70fa4cc518b6d823be7b643a39697cb4c625/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dec70fa4cc518b6d823be7b643a39697cb4c625/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=1dec70fa4cc518b6d823be7b643a39697cb4c625", "patch": "@@ -4461,11 +4461,6 @@ start_decl (const cp_declarator *declarator,\n \t\t\t       context, DECL_NAME (decl));\n \t\t  DECL_CONTEXT (decl) = DECL_CONTEXT (field);\n \t\t}\n-\t      if (processing_specialization\n-\t\t  && template_class_depth (context) == 0\n-\t\t  && CLASSTYPE_TEMPLATE_SPECIALIZATION (context))\n-\t\terror (\"template header not allowed in member definition \"\n-\t\t       \"of explicitly specialized class\");\n \t      /* Static data member are tricky; an in-class initialization\n \t\t still doesn't provide a definition, so the in-class\n \t\t declaration will have DECL_EXTERNAL set, but will have an\n@@ -9564,36 +9559,9 @@ grokdeclarator (const cp_declarator *declarator,\n       && declarator->u.id.qualifying_scope\n       && MAYBE_CLASS_TYPE_P (declarator->u.id.qualifying_scope))\n     {\n-      tree t;\n-\n       ctype = declarator->u.id.qualifying_scope;\n       ctype = TYPE_MAIN_VARIANT (ctype);\n-      t = ctype;\n-      while (t != NULL_TREE && CLASS_TYPE_P (t))\n-\t{\n-\t  /* You're supposed to have one `template <...>' for every\n-\t     template class, but you don't need one for a full\n-\t     specialization.  For example:\n-\n-\t       template <class T> struct S{};\n-\t       template <> struct S<int> { void f(); };\n-\t       void S<int>::f () {}\n-\n-\t     is correct; there shouldn't be a `template <>' for the\n-\t     definition of `S<int>::f'.  */\n-\t  if (CLASSTYPE_TEMPLATE_SPECIALIZATION (t)\n-\t      && !any_dependent_template_arguments_p (CLASSTYPE_TI_ARGS (t)))\n-\t    /* T is an explicit (not partial) specialization.  All\n-\t       containing classes must therefore also be explicitly\n-\t       specialized.  */\n-\t    break;\n-\t  if ((CLASSTYPE_USE_TEMPLATE (t) || CLASSTYPE_IS_TEMPLATE (t))\n-\t      && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (t)))\n-\t    template_count += 1;\n-\n-\t  t = TYPE_MAIN_DECL (t);\n-\t  t = DECL_CONTEXT (t);\n-\t}\n+      template_count = num_template_headers_for_class (ctype);\n \n       if (ctype == current_class_type)\n \t{"}, {"sha": "60ba380cf745c292063a5457138d002b2d7cbb71", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dec70fa4cc518b6d823be7b643a39697cb4c625/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dec70fa4cc518b6d823be7b643a39697cb4c625/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=1dec70fa4cc518b6d823be7b643a39697cb4c625", "patch": "@@ -21310,8 +21310,8 @@ cp_parser_perform_template_parameter_access_checks (VEC (deferred_access_check,g\n }\n \n /* Parse a `decl-specifier-seq [opt] init-declarator [opt] ;' or\n-   `function-definition' sequence.  MEMBER_P is true, this declaration\n-   appears in a class scope.\n+   `function-definition' sequence that follows a template header.\n+   If MEMBER_P is true, this declaration appears in a class scope.\n \n    Returns the DECL for the declared entity.  If FRIEND_P is non-NULL,\n    *FRIEND_P is set to TRUE iff the declaration is a friend.  */\n@@ -21431,6 +21431,9 @@ cp_parser_single_declaration (cp_parser* parser,\n \t\t  \"explicit template specialization cannot have a storage class\");\n         decl = error_mark_node;\n       }\n+\n+    if (decl && TREE_CODE (decl) == VAR_DECL)\n+      check_template_variable (decl);\n     }\n \n   /* Look for a trailing `;' after the declaration.  */"}, {"sha": "4a3942715b868a7cfbe5bc5ba1b127a54b9ae4ff", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dec70fa4cc518b6d823be7b643a39697cb4c625/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dec70fa4cc518b6d823be7b643a39697cb4c625/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=1dec70fa4cc518b6d823be7b643a39697cb4c625", "patch": "@@ -2208,6 +2208,66 @@ copy_default_args_to_explicit_spec (tree decl)\n   TREE_TYPE (decl) = new_type;\n }\n \n+/* Return the number of template headers we expect to see for a definition\n+   or specialization of CTYPE or one of its non-template members.  */\n+\n+int\n+num_template_headers_for_class (tree ctype)\n+{\n+  int template_count = 0;\n+  tree t = ctype;\n+  while (t != NULL_TREE && CLASS_TYPE_P (t))\n+    {\n+      /* You're supposed to have one `template <...>' for every\n+\t template class, but you don't need one for a full\n+\t specialization.  For example:\n+\n+\t template <class T> struct S{};\n+\t template <> struct S<int> { void f(); };\n+\t void S<int>::f () {}\n+\n+\t is correct; there shouldn't be a `template <>' for the\n+\t definition of `S<int>::f'.  */\n+      if (CLASSTYPE_TEMPLATE_SPECIALIZATION (t)\n+\t  && !any_dependent_template_arguments_p (CLASSTYPE_TI_ARGS (t)))\n+\t/* T is an explicit (not partial) specialization.  All\n+\t   containing classes must therefore also be explicitly\n+\t   specialized.  */\n+\tbreak;\n+      if ((CLASSTYPE_USE_TEMPLATE (t) || CLASSTYPE_IS_TEMPLATE (t))\n+\t  && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (t)))\n+\ttemplate_count += 1;\n+\n+      t = TYPE_MAIN_DECL (t);\n+      t = DECL_CONTEXT (t);\n+    }\n+\n+  return template_count;\n+}\n+\n+/* Do a simple sanity check on the template headers that precede the\n+   variable declaration DECL.  */\n+\n+void\n+check_template_variable (tree decl)\n+{\n+  tree ctx = CP_DECL_CONTEXT (decl);\n+  int wanted = num_template_headers_for_class (ctx);\n+  if (!TYPE_P (ctx) || !CLASSTYPE_TEMPLATE_INFO (ctx))\n+    permerror (DECL_SOURCE_LOCATION (decl),\n+\t       \"%qD is not a static data member of a class template\", decl);\n+  else if (template_header_count > wanted)\n+    {\n+      pedwarn (DECL_SOURCE_LOCATION (decl), 0,\n+\t       \"too many template headers for %D (should be %d)\",\n+\t       decl, wanted);\n+      if (CLASSTYPE_TEMPLATE_SPECIALIZATION (ctx))\n+\tinform (DECL_SOURCE_LOCATION (decl),\n+\t\t\"members of an explicitly specialized class are defined \"\n+\t\t\"without a template header\");\n+    }\n+}\n+\n /* Check to see if the function just declared, as indicated in\n    DECLARATOR, and in DECL, is a specialization of a function\n    template.  We may also discover that the declaration is an explicit"}, {"sha": "22fcd065e3c9b7dac15f8acb6c3e5ea8f81e9c07", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dec70fa4cc518b6d823be7b643a39697cb4c625/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dec70fa4cc518b6d823be7b643a39697cb4c625/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1dec70fa4cc518b6d823be7b643a39697cb4c625", "patch": "@@ -1,3 +1,9 @@\n+2012-08-31  Paolo Carlini  <paolo.carlini@oracle.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/18747\n+\t* g++.dg/parse/error50.C: New.\n+\n 2012-08-31  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/54428"}, {"sha": "dbd8958c360c62303ab3515ba6c2c93d5b97255b", "filename": "gcc/testsuite/g++.dg/parse/error50.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dec70fa4cc518b6d823be7b643a39697cb4c625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror50.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dec70fa4cc518b6d823be7b643a39697cb4c625/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror50.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror50.C?ref=1dec70fa4cc518b6d823be7b643a39697cb4c625", "patch": "@@ -0,0 +1,18 @@\n+// PR c++/18747\n+\n+template<> int i;   // { dg-error \"template\" }\n+\n+struct A\n+{\n+  static int i;\n+};\n+\n+template<> int A::i;     // { dg-error \"template\" }\n+\n+template <class T>\n+struct B\n+{\n+  static T i;\n+};\n+\n+template<> template <> int B<int>::i; // { dg-error \"should be 1\" }"}]}