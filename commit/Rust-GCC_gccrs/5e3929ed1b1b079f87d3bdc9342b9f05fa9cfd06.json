{"sha": "5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUzOTI5ZWQxYjFiMDc5Zjg3ZDNiZGM5MzQyYjlmMDVmYTljZmQwNg==", "commit": {"author": {"name": "Dimitrios Apostolou", "email": "jimis@gmx.net", "date": "2011-11-11T04:00:39Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-11-11T04:00:39Z"}, "message": "final.c, output.h (fprint_whex, [...]): New functions serving as fast replacements for fprintf() integer to string...\n\n\t* final.c, output.h (fprint_whex, fprint_w, fprint_ul, sprint_ul):\n\tNew functions serving as fast replacements for fprintf() integer\n\tto string conversions. They were used in the following changes.\n\t* final.c (sprint_ul_rev): Internal helper for the above.\n\t(output_addr_const): case CONST_INT: don't use fprintf().\n\t* elfos.h (ASM_GENERATE_INTERNAL_LABEL): Don't use sprintf(\"%u\"),\n\tuse sprint_ul() and stpcpy() which are much faster.\n\t(TARGET_ASM_INTERNAL_LABEL): Define as default_elf_internal_label.\n\t(ELF_ASCII_ESCAPES, ELF_STRING_LIMIT): Are the old ESCAPES and\n\tSTRING_LIMIT macros.\n\t(ASM_OUTPUT_LIMITED_STRING, ASM_OUTPUT_ASCII): Macros now just\n\tcall respective functions that provide the same\n\tfunctionality. Those are default_elf_asm_output_limited_string()\n\tand default_elf_asm_output_ascii() in varasm.c.\n\t* varasm.c: Fixed some whitespace inconsistencies.\n\t(default_elf_asm_output_limited_string)\n\t(default_elf_asm_output_ascii): The above macros from elfos.h are\n\timplemented here as these functions, avoiding superfluous calls to\n\tfprintf().\n\t(default_elf_internal_label): Hook for\n\ttargetm.asm_out.internal_label and ASM_OUTPUT_DEBUG_LABEL.\n\t* i386.c: Don't call fprintf(\"%u\") but fprint_ul() instead.\n\t* defaults.h (ASM_OUTPUT_LABEL, ASM_OUTPUT_INTERNAL_LABEL):\n\tExpanded the macros on multiple lines for readability.\n\t(ASM_OUTPUT_LABELREF): Have two calls to fputs() instead of one to\n\tasm_fprintf().\n\t* dwarf2asm.c (dw2_assemble_integer, dw2_asm_output_data)\n\t(dw2_asm_data_uleb128, dw2_asm_delta_uleb128)\n\t(dw2_asm_delta_sleb128): Convert fprintf() calls to the new\n\tfaster functions.\n\t* dwarf2out.c (dwarf2out_source_line): Convert fprintf() calls to\n\tthe new faster functions.\n\nFrom-SVN: r181279", "tree": {"sha": "048365acb120710e3f57953c76b1f455473b434d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/048365acb120710e3f57953c76b1f455473b434d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06/comments", "author": {"login": "jimis", "id": 3584514, "node_id": "MDQ6VXNlcjM1ODQ1MTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3584514?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jimis", "html_url": "https://github.com/jimis", "followers_url": "https://api.github.com/users/jimis/followers", "following_url": "https://api.github.com/users/jimis/following{/other_user}", "gists_url": "https://api.github.com/users/jimis/gists{/gist_id}", "starred_url": "https://api.github.com/users/jimis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jimis/subscriptions", "organizations_url": "https://api.github.com/users/jimis/orgs", "repos_url": "https://api.github.com/users/jimis/repos", "events_url": "https://api.github.com/users/jimis/events{/privacy}", "received_events_url": "https://api.github.com/users/jimis/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c63ee1b7f0785159d2188c2708100fc0e116f27e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c63ee1b7f0785159d2188c2708100fc0e116f27e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c63ee1b7f0785159d2188c2708100fc0e116f27e"}], "stats": {"total": 485, "additions": 353, "deletions": 132}, "files": [{"sha": "7fa232923bd4e00dfacd3b5a0f9a0c3fe4725298", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06", "patch": "@@ -1,3 +1,38 @@\n+2011-08-12  Dimitrios Apostolou  <jimis@gmx.net>\n+\n+\t* final.c, output.h (fprint_whex, fprint_w, fprint_ul, sprint_ul):\n+\tNew functions serving as fast replacements for fprintf() integer\n+\tto string conversions. They were used in the following changes.\n+\t* final.c (sprint_ul_rev): Internal helper for the above.\n+\t(output_addr_const): case CONST_INT: don't use fprintf().\n+\t* elfos.h (ASM_GENERATE_INTERNAL_LABEL): Don't use sprintf(\"%u\"),\n+\tuse sprint_ul() and stpcpy() which are much faster.\n+\t(TARGET_ASM_INTERNAL_LABEL): Define as default_elf_internal_label.\n+\t(ELF_ASCII_ESCAPES, ELF_STRING_LIMIT): Are the old ESCAPES and\n+\tSTRING_LIMIT macros.\n+\t(ASM_OUTPUT_LIMITED_STRING, ASM_OUTPUT_ASCII): Macros now just\n+\tcall respective functions that provide the same\n+\tfunctionality. Those are default_elf_asm_output_limited_string()\n+\tand default_elf_asm_output_ascii() in varasm.c.\n+\t* varasm.c: Fixed some whitespace inconsistencies.\n+\t(default_elf_asm_output_limited_string)\n+\t(default_elf_asm_output_ascii): The above macros from elfos.h are\n+\timplemented here as these functions, avoiding superfluous calls to\n+\tfprintf().\n+\t(default_elf_internal_label): Hook for\n+\ttargetm.asm_out.internal_label and ASM_OUTPUT_DEBUG_LABEL.\n+\t* i386.c: Don't call fprintf(\"%u\") but fprint_ul() instead.\n+\t* defaults.h (ASM_OUTPUT_LABEL, ASM_OUTPUT_INTERNAL_LABEL):\n+\tExpanded the macros on multiple lines for readability.\n+\t(ASM_OUTPUT_LABELREF): Have two calls to fputs() instead of one to\n+\tasm_fprintf().\n+\t* dwarf2asm.c (dw2_assemble_integer, dw2_asm_output_data)\n+\t(dw2_asm_data_uleb128, dw2_asm_delta_uleb128)\n+\t(dw2_asm_delta_sleb128): Convert fprintf() calls to the new\n+\tfaster functions.\n+\t* dwarf2out.c (dwarf2out_source_line): Convert fprintf() calls to\n+\tthe new faster functions.\n+\n 2011-11-10  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* doc/extend.texi: Document __atomic_test_and_set and __atomic_clear."}, {"sha": "42472024439384c2d8156267a6d9ec95fd3c5271", "filename": "gcc/config/elfos.h", "status": "modified", "additions": 13, "deletions": 105, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06/gcc%2Fconfig%2Felfos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06/gcc%2Fconfig%2Felfos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felfos.h?ref=5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06", "patch": "@@ -117,10 +117,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\t\\\n   do\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      sprintf (LABEL, \"*.%s%u\", PREFIX, (unsigned) (NUM));\t\\\n+      char *__p;\t\t\t\t\t\t\\\n+      (LABEL)[0] = '*';\t\t\t\t\t\t\\\n+      (LABEL)[1] = '.';\t\t\t\t\t\t\\\n+      __p = stpcpy (&(LABEL)[2], PREFIX);\t\t\t\\\n+      sprint_ul (__p, (unsigned long) (NUM));\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   while (0)\n \n+#undef TARGET_ASM_INTERNAL_LABEL\n+#define TARGET_ASM_INTERNAL_LABEL default_elf_internal_label\n+\n /* Output the label which precedes a jumptable.  Note that for all svr4\n    systems where we actually generate jumptables (which is to say every\n    svr4 target except i386, where we use casesi instead) we put the jump-\n@@ -371,7 +378,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    the i386) don't know about that.  Also, we don't use \\v\n    since some versions of gas, such as 2.2 did not accept it.  */\n \n-#define ESCAPES \\\n+#define ELF_ASCII_ESCAPES \\\n \"\\1\\1\\1\\1\\1\\1\\1\\1btn\\1fr\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n \\0\\0\\\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\\n \\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\\\\\0\\0\\0\\\n@@ -393,9 +400,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    should define this to zero.\n */\n \n-#define STRING_LIMIT\t((unsigned) 256)\n-\n-#define STRING_ASM_OP\t\"\\t.string\\t\"\n+#define ELF_STRING_LIMIT\t((unsigned) 256)\n \n /* The routine used to output NUL terminated strings.  We use a special\n    version of this for most svr4 targets because doing so makes the\n@@ -405,36 +410,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    comma separated lists of numbers).  */\n \n #define ASM_OUTPUT_LIMITED_STRING(FILE, STR)\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      register const unsigned char *_limited_str =\t\\\n-\t(const unsigned char *) (STR);\t\t\t\\\n-      register unsigned ch;\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-      fprintf ((FILE), \"%s\\\"\", STRING_ASM_OP);\t\t\\\n-\t\t\t\t\t\t\t\\\n-      for (; (ch = *_limited_str); _limited_str++)\t\\\n-        {\t\t\t\t\t\t\\\n-\t  register int escape;\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-\t  switch (escape = ESCAPES[ch])\t\t\t\\\n-\t    {\t\t\t\t\t\t\\\n-\t    case 0:\t\t\t\t\t\\\n-\t      putc (ch, (FILE));\t\t\t\\\n-\t      break;\t\t\t\t\t\\\n-\t    case 1:\t\t\t\t\t\\\n-\t      fprintf ((FILE), \"\\\\%03o\", ch);\t\t\\\n-\t      break;\t\t\t\t\t\\\n-\t    default:\t\t\t\t\t\\\n-\t      putc ('\\\\', (FILE));\t\t\t\\\n-\t      putc (escape, (FILE));\t\t\t\\\n-\t      break;\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\\\n-        }\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-      fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0)\n+  default_elf_asm_output_limited_string ((FILE), (STR))\n \n /* The routine used to output sequences of byte values.  We use a special\n    version of this for most svr4 targets because doing so makes the\n@@ -444,76 +420,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    STRING_LIMIT) we output those using ASM_OUTPUT_LIMITED_STRING.  */\n \n #undef  ASM_OUTPUT_ASCII\n-#define ASM_OUTPUT_ASCII(FILE, STR, LENGTH)\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      const unsigned char *_ascii_bytes =\t\t\t\t\\\n-\t(const unsigned char *) (STR);\t\t\t\t\t\\\n-      const unsigned char *limit = _ascii_bytes + (LENGTH);\t\t\\\n-      const unsigned char *last_null = NULL;\t\t\t\t\\\n-      unsigned bytes_in_chunk = 0;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      for (; _ascii_bytes < limit; _ascii_bytes++)\t\t\t\\\n-        {\t\t\t\t\t\t\t\t\\\n-\t  const unsigned char *p;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  if (bytes_in_chunk >= 60)\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\\\n-\t      bytes_in_chunk = 0;\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  if (_ascii_bytes > last_null)\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      for (p = _ascii_bytes; p < limit && *p != '\\0'; p++)\t\\\n-\t\tcontinue;\t\t\t\t\t\t\\\n-\t      last_null = p;\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    p = last_null;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t  if (p < limit && (p - _ascii_bytes) <= (long)STRING_LIMIT)\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      if (bytes_in_chunk > 0)\t\t\t\t\t\\\n-\t\t{\t\t\t\t\t\t\t\\\n-\t\t  fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\\\n-\t\t  bytes_in_chunk = 0;\t\t\t\t\t\\\n-\t\t}\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t      ASM_OUTPUT_LIMITED_STRING ((FILE), _ascii_bytes);\t\t\\\n-\t      _ascii_bytes = p;\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      register int escape;\t\t\t\t\t\\\n-\t      register unsigned ch;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t      if (bytes_in_chunk == 0)\t\t\t\t\t\\\n-\t\tfprintf ((FILE), \"%s\\\"\", ASCII_DATA_ASM_OP);\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t      switch (escape = ESCAPES[ch = *_ascii_bytes])\t\t\\\n-\t\t{\t\t\t\t\t\t\t\\\n-\t\tcase 0:\t\t\t\t\t\t\t\\\n-\t\t  putc (ch, (FILE));\t\t\t\t\t\\\n-\t\t  bytes_in_chunk++;\t\t\t\t\t\\\n-\t\t  break;\t\t\t\t\t\t\\\n-\t\tcase 1:\t\t\t\t\t\t\t\\\n-\t\t  fprintf ((FILE), \"\\\\%03o\", ch);\t\t\t\\\n-\t\t  bytes_in_chunk += 4;\t\t\t\t\t\\\n-\t\t  break;\t\t\t\t\t\t\\\n-\t\tdefault:\t\t\t\t\t\t\\\n-\t\t  putc ('\\\\', (FILE));\t\t\t\t\t\\\n-\t\t  putc (escape, (FILE));\t\t\t\t\\\n-\t\t  bytes_in_chunk += 2;\t\t\t\t\t\\\n-\t\t  break;\t\t\t\t\t\t\\\n-\t\t}\t\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (bytes_in_chunk > 0)\t\t\t\t\t\t\\\n-        fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n+#define ASM_OUTPUT_ASCII(FILE, STR, LENGTH)\t\t\t\\\n+  default_elf_asm_output_ascii ((FILE), (STR), (LENGTH));\n \n /* Allow the use of the -frecord-gcc-switches switch via the\n    elf_record_gcc_switches function defined in varasm.c.  */"}, {"sha": "f39eb116f7755a187cfc5c7d8e70071ec1b6f368", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06", "patch": "@@ -13539,26 +13539,28 @@ print_reg (rtx x, int code, FILE *file)\n     code = GET_MODE_SIZE (GET_MODE (x));\n \n   /* Irritatingly, AMD extended registers use different naming convention\n-     from the normal registers.  */\n+     from the normal registers: \"r%d[bwd]\"  */\n   if (REX_INT_REG_P (x))\n     {\n       gcc_assert (TARGET_64BIT);\n+      putc ('r', file);\n+      fprint_ul (file, REGNO (x) - FIRST_REX_INT_REG + 8);\n       switch (code)\n \t{\n \t  case 0:\n \t    error (\"extended registers have no high halves\");\n \t    break;\n \t  case 1:\n-\t    fprintf (file, \"r%ib\", REGNO (x) - FIRST_REX_INT_REG + 8);\n+\t    putc ('b', file);\n \t    break;\n \t  case 2:\n-\t    fprintf (file, \"r%iw\", REGNO (x) - FIRST_REX_INT_REG + 8);\n+\t    putc ('w', file);\n \t    break;\n \t  case 4:\n-\t    fprintf (file, \"r%id\", REGNO (x) - FIRST_REX_INT_REG + 8);\n+\t    putc ('d', file);\n \t    break;\n \t  case 8:\n-\t    fprintf (file, \"r%i\", REGNO (x) - FIRST_REX_INT_REG + 8);\n+\t    /* no suffix */\n \t    break;\n \t  default:\n \t    error (\"unsupported operand size for extended register\");"}, {"sha": "40e3263c9e17e9b2ecf31e451363ac171777be67", "filename": "gcc/defaults.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06", "patch": "@@ -142,7 +142,10 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #ifndef ASM_OUTPUT_LABEL\n #define ASM_OUTPUT_LABEL(FILE,NAME) \\\n-  do { assemble_name ((FILE), (NAME)); fputs (\":\\n\", (FILE)); } while (0)\n+  do {\t\t\t\t\t\t\\\n+    assemble_name ((FILE), (NAME));\t\t\\\n+    fputs (\":\\n\", (FILE));\t\t\t\\\n+  } while (0)\n #endif\n \n /* This is how to output the definition of a user-level label named\n@@ -165,7 +168,11 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n /* This is how to output a reference to a user-level label named NAME.  */\n \n #ifndef ASM_OUTPUT_LABELREF\n-#define ASM_OUTPUT_LABELREF(FILE,NAME)  asm_fprintf ((FILE), \"%U%s\", (NAME))\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)  \\\n+  do {\t\t\t\t\t\t\t\\\n+    fputs (user_label_prefix, (FILE));\t\t\t\\\n+    fputs ((NAME), (FILE));\t\t\t\t\\\n+  } while (0);\n #endif\n \n /* Allow target to print debug info labels specially.  This is useful for"}, {"sha": "fe305d3ed4e4e0786c32d9fadaf726539b7b6cab", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06", "patch": "@@ -47,8 +47,7 @@ dw2_assemble_integer (int size, rtx x)\n     {\n       fputs (op, asm_out_file);\n       if (CONST_INT_P (x))\n-\tfprintf (asm_out_file, HOST_WIDE_INT_PRINT_HEX,\n-\t\t (unsigned HOST_WIDE_INT) INTVAL (x));\n+\tfprint_whex (asm_out_file, (unsigned HOST_WIDE_INT) INTVAL (x));\n       else\n \toutput_addr_const (asm_out_file, x);\n     }\n@@ -100,16 +99,19 @@ dw2_asm_output_data (int size, unsigned HOST_WIDE_INT value,\n     value &= ~(~(unsigned HOST_WIDE_INT) 0 << (size * 8));\n \n   if (op)\n-    fprintf (asm_out_file, \"%s\" HOST_WIDE_INT_PRINT_HEX, op, value);\n+    {\n+      fputs (op, asm_out_file);\n+      fprint_whex (asm_out_file, value);\n+    }\n   else\n     assemble_integer (GEN_INT (value), size, BITS_PER_UNIT, 1);\n \n   if (flag_debug_asm && comment)\n     {\n-      fprintf (asm_out_file, \"\\t%s \", ASM_COMMENT_START);\n+      fputs (\"\\t\" ASM_COMMENT_START \" \", asm_out_file);\n       vfprintf (asm_out_file, comment, ap);\n     }\n-  fputc ('\\n', asm_out_file);\n+  putc ('\\n', asm_out_file);\n \n   va_end (ap);\n }\n@@ -590,7 +592,8 @@ dw2_asm_output_data_uleb128 (unsigned HOST_WIDE_INT value,\n   va_start (ap, comment);\n \n #ifdef HAVE_AS_LEB128\n-  fprintf (asm_out_file, \"\\t.uleb128 \" HOST_WIDE_INT_PRINT_HEX , value);\n+  fputs (\"\\t.uleb128 \", asm_out_file);\n+  fprint_whex (asm_out_file, value);\n \n   if (flag_debug_asm && comment)\n     {\n@@ -635,7 +638,7 @@ dw2_asm_output_data_uleb128 (unsigned HOST_WIDE_INT value,\n     }\n   }\n #endif\n-  fputc ('\\n', asm_out_file);\n+  putc ('\\n', asm_out_file);\n \n   va_end (ap);\n }\n@@ -739,7 +742,7 @@ dw2_asm_output_delta_uleb128 (const char *lab1 ATTRIBUTE_UNUSED,\n #ifdef HAVE_AS_LEB128\n   fputs (\"\\t.uleb128 \", asm_out_file);\n   assemble_name (asm_out_file, lab1);\n-  fputc ('-', asm_out_file);\n+  putc ('-', asm_out_file);\n   assemble_name (asm_out_file, lab2);\n #else\n   gcc_unreachable ();\n@@ -769,7 +772,7 @@ dw2_asm_output_delta_sleb128 (const char *lab1 ATTRIBUTE_UNUSED,\n #ifdef HAVE_AS_LEB128\n   fputs (\"\\t.sleb128 \", asm_out_file);\n   assemble_name (asm_out_file, lab1);\n-  fputc ('-', asm_out_file);\n+  putc ('-', asm_out_file);\n   assemble_name (asm_out_file, lab2);\n #else\n   gcc_unreachable ();"}, {"sha": "768ecaf6669fd62e1b9c3d84104dc6fa57e9d88f", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06", "patch": "@@ -20472,12 +20472,27 @@ dwarf2out_source_line (unsigned int line, const char *filename,\n   if (DWARF2_ASM_LINE_DEBUG_INFO)\n     {\n       /* Emit the .loc directive understood by GNU as.  */\n-      fprintf (asm_out_file, \"\\t.loc %d %d 0\", file_num, line);\n+      /* \"\\t.loc %u %u 0 is_stmt %u discriminator %u\",\n+\t file_num, line, is_stmt, discriminator */\n+      fputs (\"\\t.loc \", asm_out_file);\n+      fprint_ul (asm_out_file, file_num);\n+      putc (' ', asm_out_file);\n+      fprint_ul (asm_out_file, line);\n+      putc (' ', asm_out_file);\n+      putc ('0', asm_out_file);\n+\n       if (is_stmt != table->is_stmt)\n-\tfprintf (asm_out_file, \" is_stmt %d\", is_stmt ? 1 : 0);\n+\t{\n+\t  fputs (\" is_stmt \", asm_out_file);\n+\t  putc (is_stmt ? '1' : '0', asm_out_file);\n+\t}\n       if (SUPPORTS_DISCRIMINATOR && discriminator != 0)\n-\tfprintf (asm_out_file, \" discriminator %d\", discriminator);\n-      fputc ('\\n', asm_out_file);\n+\t{\n+\t  gcc_assert (discriminator > 0);\n+\t  fputs (\" discriminator \", asm_out_file);\n+\t  fprint_ul (asm_out_file, (unsigned long) discriminator);\n+\t}\n+      putc ('\\n', asm_out_file);\n     }\n   else\n     {"}, {"sha": "cc3a199692ee67baa388b20caf7804b74e17d12f", "filename": "gcc/final.c", "status": "modified", "additions": 119, "deletions": 1, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06", "patch": "@@ -3585,7 +3585,7 @@ output_addr_const (FILE *file, rtx x)\n       break;\n \n     case CONST_INT:\n-      fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (x));\n+      fprint_w (file, INTVAL (x));\n       break;\n \n     case CONST:\n@@ -3699,6 +3699,124 @@ output_quoted_string (FILE *asm_file, const char *string)\n #endif\n }\n \f\n+/* Write a HOST_WIDE_INT number in hex form 0x1234, fast. */\n+\n+void\n+fprint_whex (FILE *f, unsigned HOST_WIDE_INT value)\n+{\n+  char buf[2 + CHAR_BIT * sizeof (value) / 4];\n+  if (value == 0)\n+    putc ('0', f);\n+  else\n+    {\n+      char *p = buf + sizeof (buf);\n+      do\n+        *--p = \"0123456789abcdef\"[value % 16];\n+      while ((value /= 16) != 0);\n+      *--p = 'x';\n+      *--p = '0';\n+      fwrite (p, 1, buf + sizeof (buf) - p, f);\n+    }\n+}\n+\n+/* Internal function that prints an unsigned long in decimal in reverse.\n+   The output string IS NOT null-terminated. */\n+\n+static int\n+sprint_ul_rev (char *s, unsigned long value)\n+{\n+  int i = 0;\n+  do\n+    {\n+      s[i] = \"0123456789\"[value % 10];\n+      value /= 10;\n+      i++;\n+      /* alternate version, without modulo */\n+      /* oldval = value; */\n+      /* value /= 10; */\n+      /* s[i] = \"0123456789\" [oldval - 10*value]; */\n+      /* i++ */\n+    }\n+  while (value != 0);\n+  return i;\n+}\n+\n+/* Write a signed HOST_WIDE_INT as decimal to a file, fast. */\n+\n+void\n+fprint_w (FILE *f, HOST_WIDE_INT value)\n+{\n+  /* python says: len(str(2**64)) == 20 */\n+  char s[20];\n+  int i;\n+\n+  if (value >= 0)\n+    i = sprint_ul_rev (s, (unsigned long) value);\n+  else\n+    {\n+      /* Cast to long long to output max negative correctly! */\n+      i = sprint_ul_rev (s, ((unsigned long long) value) * -1);\n+      putc('-', f);\n+    }\n+\n+  /* It's probably too small to bother with string reversal and fputs. */\n+  do\n+    {\n+      i--;\n+      putc (s[i], f);\n+    }\n+  while (i != 0);\n+}\n+\n+/* Write an unsigned long as decimal to a file, fast. */\n+\n+void\n+fprint_ul (FILE *f, unsigned long value)\n+{\n+  /* python says: len(str(2**64)) == 20 */\n+  char s[20];\n+  int i;\n+\n+  i = sprint_ul_rev (s, value);\n+\n+  /* It's probably too small to bother with string reversal and fputs. */\n+  do\n+    {\n+      i--;\n+      putc (s[i], f);\n+    }\n+  while (i != 0);\n+}\n+\n+/* Write an unsigned long as decimal to a string, fast.\n+   s must be wide enough to not overflow, at least 21 chars.\n+   Returns the length of the string (without terminating '\\0'). */\n+\n+int\n+sprint_ul (char *s, unsigned long value)\n+{\n+  int len;\n+  char tmp_c;\n+  int i;\n+  int j;\n+\n+  len = sprint_ul_rev (s, value);\n+  s[len] = '\\0';\n+\n+  /* Reverse the string. */\n+  i = 0;\n+  j = len - 1;\n+  while (i < j)\n+    {\n+      tmp_c = s[i];\n+      s[i] = s[j];\n+      s[j] = tmp_c;\n+      i++; j--;\n+    }\n+\n+  return len;\n+}\n+\n /* A poor man's fprintf, with the added features of %I, %R, %L, and %U.\n    %R prints the value of REGISTER_PREFIX.\n    %L prints the value of LOCAL_LABEL_PREFIX."}, {"sha": "e73c4a4c6bca1e16ed1f839747babd884ecd9eab", "filename": "gcc/output.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06", "patch": "@@ -129,6 +129,11 @@ typedef HOST_WIDE_INT __gcc_host_wide_int__;\n #define ATTRIBUTE_ASM_FPRINTF(m, n) ATTRIBUTE_NONNULL(m)\n #endif\n \n+extern void fprint_w (FILE *, HOST_WIDE_INT);\n+extern void fprint_whex (FILE *, unsigned HOST_WIDE_INT);\n+extern void fprint_ul (FILE *, unsigned long);\n+extern int sprint_ul (char *, unsigned long);\n+\n extern void asm_fprintf (FILE *file, const char *p, ...)\n      ATTRIBUTE_ASM_FPRINTF(2, 3);\n \n@@ -659,6 +664,10 @@ extern void file_end_indicate_split_stack (void);\n \n extern void default_elf_asm_output_external (FILE *file, tree,\n \t\t\t\t\t     const char *);\n+extern void default_elf_asm_output_limited_string (FILE *, const char *);\n+extern void default_elf_asm_output_ascii (FILE *, const char *, unsigned int);\n+extern void default_elf_internal_label (FILE *, const char *, unsigned long);\n+\n extern void default_elf_init_array_asm_out_constructor (rtx, int);\n extern void default_elf_fini_array_asm_out_destructor (rtx, int);\n extern int maybe_assemble_visibility (tree);"}, {"sha": "8762a2eb3ac16bf604bd6fa0938c66dc108f0a14", "filename": "gcc/varasm.c", "status": "modified", "additions": 130, "deletions": 6, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=5e3929ed1b1b079f87d3bdc9342b9f05fa9cfd06", "patch": "@@ -564,7 +564,7 @@ default_function_section (tree decl, enum node_frequency freq,\n /* Return the section for function DECL.\n \n    If DECL is NULL_TREE, return the text section.  We can be passed\n-   NULL_TREE under some circumstances by dbxout.c at least. \n+   NULL_TREE under some circumstances by dbxout.c at least.\n \n    If FORCE_COLD is true, return cold function section ignoring\n    the frequency info of cgraph_node.  */\n@@ -1928,7 +1928,7 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n \n   /* Emulated TLS had better not get this far.  */\n   gcc_checking_assert (targetm.have_tls || !DECL_THREAD_LOCAL_P (decl));\n-              \n+\n   last_assemble_variable_decl = 0;\n \n   /* Normally no need to say anything here for external references,\n@@ -2852,7 +2852,7 @@ compare_constant (const tree t1, const tree t2)\n \t      return 0;\n \t    link2 = TREE_CHAIN (link2);\n \t  }\n-\t\n+\n \treturn 1;\n       }\n \n@@ -5754,7 +5754,7 @@ finish_aliases_1 (void)\n \t       && ! lookup_attribute (\"weakref\", DECL_ATTRIBUTES (p->decl)))\n \t{\n \t  error (\"%q+D aliased to external symbol %qE\",\n-\t\t p->decl, p->target);\t  \n+\t\t p->decl, p->target);\n \t  p->emitted_diags |= ALIAS_DIAG_TO_EXTERN;\n \t}\n     }\n@@ -5820,7 +5820,7 @@ assemble_alias (tree decl, tree target)\n \t  if (lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (decl)))\n \t    error_at (DECL_SOURCE_LOCATION (decl),\n \t\t      \"ifunc is not supported in this configuration\");\n-\t  else\t\n+\t  else\n \t    error_at (DECL_SOURCE_LOCATION (decl),\n \t\t      \"only weak aliases are supported in this configuration\");\n \t  return;\n@@ -6019,7 +6019,7 @@ finish_tm_clone_pairs (void)\n    the visibility type VIS, which must not be VISIBILITY_DEFAULT.  */\n \n void\n-default_assemble_visibility (tree decl ATTRIBUTE_UNUSED, \n+default_assemble_visibility (tree decl ATTRIBUTE_UNUSED,\n \t\t\t     int vis ATTRIBUTE_UNUSED)\n {\n #ifdef HAVE_GAS_HIDDEN\n@@ -7519,6 +7519,130 @@ make_debug_expr_from_rtl (const_rtx exp)\n   return dval;\n }\n \n+/* Default ASM_OUTPUT_LIMITED_STRING for ELF targets.  */\n+\n+void\n+default_elf_asm_output_limited_string (FILE *f, const char *s)\n+{\n+  int escape;\n+  unsigned char c;\n+\n+  fputs (\"\\t.string\\t\\\"\", f);\n+  while (*s != '\\0')\n+    {\n+      c = *s;\n+      escape = ELF_ASCII_ESCAPES[c];\n+      switch (escape)\n+\t{\n+\tcase 0:\n+\t  putc (c, f);\n+\t  break;\n+\tcase 1:\n+\t  /* TODO: Print in hex with fast function, important for -flto. */\n+\t  fprintf (f, \"\\\\%03o\", c);\n+\t  break;\n+\tdefault:\n+\t  putc ('\\\\', f);\n+\t  putc (escape, f);\n+\t  break;\n+\t}\n+      s++;\n+    }\n+  putc ('\\\"', f);\n+  putc ('\\n', f);\n+}\n+\n+/* Default ASM_OUTPUT_ASCII for ELF targets.  */\n+\n+void\n+default_elf_asm_output_ascii (FILE *f, const char *s, unsigned int len)\n+{\n+  const char *limit = s + len;\n+  const char *last_null = NULL;\n+  unsigned bytes_in_chunk = 0;\n+  unsigned char c;\n+  int escape;\n+\n+  for (; s < limit; s++)\n+    {\n+      const char *p;\n+\n+      if (bytes_in_chunk >= 60)\n+\t{\n+\t  putc ('\\\"', f);\n+\t  putc ('\\n', f);\n+\t  bytes_in_chunk = 0;\n+\t}\n+\n+      if (s > last_null)\n+\t{\n+\t  for (p = s; p < limit && *p != '\\0'; p++)\n+\t    continue;\n+\t  last_null = p;\n+\t}\n+      else\n+\tp = last_null;\n+\n+      if (p < limit && (p - s) <= (long) ELF_STRING_LIMIT)\n+\t{\n+\t  if (bytes_in_chunk > 0)\n+\t    {\n+\t      putc ('\\\"', f);\n+\t      putc ('\\n', f);\n+\t      bytes_in_chunk = 0;\n+\t    }\n+\n+\t  default_elf_asm_output_limited_string (f, s);\n+\t  s = p;\n+\t}\n+      else\n+\t{\n+\t  if (bytes_in_chunk == 0)\n+\t    fputs (ASCII_DATA_ASM_OP \"\\\"\", f);\n+\n+\t  c = *s;\n+\t  escape = ELF_ASCII_ESCAPES[c];\n+\t  switch (escape)\n+\t    {\n+\t    case 0:\n+\t      putc (c, f);\n+\t      bytes_in_chunk++;\n+\t      break;\n+\t    case 1:\n+\t      /* TODO: Print in hex with fast function, important for -flto. */\n+\t      fprintf (f, \"\\\\%03o\", c);\n+\t      bytes_in_chunk += 4;\n+\t      break;\n+\t    default:\n+\t      putc ('\\\\', f);\n+\t      putc (escape, f);\n+\t      bytes_in_chunk += 2;\n+\t      break;\n+\t    }\n+\n+\t}\n+    }\n+\n+  if (bytes_in_chunk > 0)\n+    {\n+      putc ('\\\"', f);\n+      putc ('\\n', f);\n+    }\n+}\n+\n+/* Default TARGET_ASM_INTERNAL_LABEL for ELF targets.  */\n+\n+void\n+default_elf_internal_label (FILE *f, const char *prefix,\n+\t\t\t    unsigned long labelno)\n+{\n+  putc ('.', f);\n+  fputs (prefix, f);\n+  fprint_ul (f, labelno);\n+  putc (':', f);\n+  putc ('\\n', f);\n+}\n+\n static GTY(()) section *elf_init_array_section;\n static GTY(()) section *elf_fini_array_section;\n "}]}