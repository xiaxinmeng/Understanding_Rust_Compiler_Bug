{"sha": "fc3ffe83097fb810cac84d2b2007a25833684d74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMzZmZlODMwOTdmYjgxMGNhYzg0ZDJiMjAwN2EyNTgzMzY4NGQ3NA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-17T02:05:56Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-17T02:05:56Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r754", "tree": {"sha": "62af3d4bd858f37543e61d1966c1a5b791e7d3af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62af3d4bd858f37543e61d1966c1a5b791e7d3af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc3ffe83097fb810cac84d2b2007a25833684d74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc3ffe83097fb810cac84d2b2007a25833684d74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc3ffe83097fb810cac84d2b2007a25833684d74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc3ffe83097fb810cac84d2b2007a25833684d74/comments", "author": null, "committer": null, "parents": [{"sha": "ee243aa8d00d007f0b12acd3d055b8b981e21839", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee243aa8d00d007f0b12acd3d055b8b981e21839", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee243aa8d00d007f0b12acd3d055b8b981e21839"}], "stats": {"total": 173, "additions": 114, "deletions": 59}, "files": [{"sha": "0a12aac86dcd086ee1fd24575e97124ce0ac6b10", "filename": "gcc/c-decl.c", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc3ffe83097fb810cac84d2b2007a25833684d74/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc3ffe83097fb810cac84d2b2007a25833684d74/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=fc3ffe83097fb810cac84d2b2007a25833684d74", "patch": "@@ -399,10 +399,15 @@ int flag_short_double;\n \n int flag_no_asm;\n \n-/* Nonzero means don't recognize the non-ANSI builtin functions.  */\n+/* Nonzero means don't recognize any builtin functions.  */\n \n int flag_no_builtin;\n \n+/* Nonzero means don't recognize the non-ANSI builtin functions.\n+   -ansi sets this.  */\n+\n+int flag_no_nonansi_builtin;\n+\n /* Nonzero means do some things the same way PCC does.  */\n \n int flag_traditional;\n@@ -547,7 +552,7 @@ c_decode_option (p)\n   else if (!strcmp (p, \"-fident\"))\n     flag_no_ident = 0;\n   else if (!strcmp (p, \"-ansi\"))\n-    flag_no_asm = 1, flag_no_builtin = 1, dollars_in_ident = 0;\n+    flag_no_asm = 1, flag_no_nonansi_builtin = 1, dollars_in_ident = 0;\n   else if (!strcmp (p, \"-Wimplicit\"))\n     warn_implicit = 1;\n   else if (!strcmp (p, \"-Wno-implicit\"))\n@@ -612,6 +617,10 @@ c_decode_option (p)\n     ; /* cpp handles this one.  */\n   else if (!strcmp (p, \"-Wno-trigraphs\"))\n     ; /* cpp handles this one.  */\n+  else if (!strcmp (p, \"-Wimport\"))\n+    ; /* cpp handles this one.  */\n+  else if (!strcmp (p, \"-Wno-import\"))\n+    ; /* cpp handles this one.  */\n   else if (!strcmp (p, \"-Wall\"))\n     {\n       extra_warnings = 1;\n@@ -1325,7 +1334,8 @@ duplicate_decls (newdecl, olddecl)\n \t    warning_with_decl (newdecl,\n \t\t\t       \"`%s' declared inline after being called\");\n \t  if (TREE_CODE (olddecl) == FUNCTION_DECL\n-\t      && TREE_INLINE (olddecl) != TREE_INLINE (newdecl))\n+\t      && TREE_INLINE (olddecl) != TREE_INLINE (newdecl)\n+\t      && ! (TREE_EXTERNAL (olddecl) && TREE_EXTERNAL (newdecl)))\n \t    warning_with_decl (newdecl,\n \t\t\t       \"`%s' declarations disagree about `inline'\");\n \t  /* It is nice to warn when a function is declared\n@@ -2474,7 +2484,7 @@ init_decl_processing ()\n \t\t\t\t\t\t    sizetype,\n \t\t\t\t\t\t    endlink)),\n \t\t    BUILT_IN_ALLOCA, \"alloca\");\n-  if (! flag_no_builtin)\n+  if (! flag_no_builtin && !flag_no_nonansi_builtin)\n     {\n       tree exit_type;\n       temp = builtin_function (\"alloca\",\n@@ -4177,11 +4187,18 @@ get_parm_info (void_at_end)\n \t\t\t\t saveable_tree_cons (NULL_TREE, void_type_node, NULL_TREE));\n     }\n \n-  /* Extract enumerator values and other non-parms declared with the parms.  */\n+  /* Extract enumerator values and other non-parms declared with the parms.\n+     Likewise any forward parm decls that didn't have real parm decls.  */\n   for (decl = parms; decl; )\n     {\n       tree next = TREE_CHAIN (decl);\n \n+      if (TREE_ASM_WRITTEN (decl))\n+\t{\n+\t  error_with_decl (decl, \"no real declaration for parameter `%s'\");\n+\t  TREE_CHAIN (decl) = new_parms;\n+\t  new_parms = decl;\n+\t}\n       if (TREE_CODE (decl) != PARM_DECL)\n \t{\n \t  TREE_CHAIN (decl) = new_parms;"}, {"sha": "fdf73dc0288aa8c55b8b420f12b4eb3f5ab6d40d", "filename": "gcc/config/a29k/a29k.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc3ffe83097fb810cac84d2b2007a25833684d74/gcc%2Fconfig%2Fa29k%2Fa29k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc3ffe83097fb810cac84d2b2007a25833684d74/gcc%2Fconfig%2Fa29k%2Fa29k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.c?ref=fc3ffe83097fb810cac84d2b2007a25833684d74", "patch": "@@ -876,11 +876,15 @@ print_operand (file, x, code)\n       \n     case 'F':\n       output_addr_const (file, x);\n-      if (! strcmp (XSTR (x, 0), current_function_name)\n-\t  && dbr_sequence_length () == 0)\n-\tfprintf (file, \"+4\\n\\t%s,%d\",\n-\t\t a29k_regstack_size >= 64 ? \"const gr121\" : \"sub gr1,gr1\",\n-\t\t a29k_regstack_size * 4);\n+      if (dbr_sequence_length () == 0)\n+\t{\n+\t  if (! strcmp (XSTR (x, 0), current_function_name))\n+\t    fprintf (file, \"+4\\n\\t%s,%d\",\n+\t\t     a29k_regstack_size >= 64 ? \"const gr121\" : \"sub gr1,gr1\",\n+\t\t     a29k_regstack_size * 4);\n+\t  else\n+\t    fprintf (file, \"\\n\\tnop\");\n+\t}\n       return;\n \n     case 'L':"}, {"sha": "727e1002b07ad480f10ca1b01bd10eaf89e65f11", "filename": "gcc/config/m68k/3b1.h", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc3ffe83097fb810cac84d2b2007a25833684d74/gcc%2Fconfig%2Fm68k%2F3b1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc3ffe83097fb810cac84d2b2007a25833684d74/gcc%2Fconfig%2Fm68k%2F3b1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2F3b1.h?ref=fc3ffe83097fb810cac84d2b2007a25833684d74", "patch": "@@ -369,10 +369,20 @@ do { union { float f; long l;} tem;\t\t\t\\\n \t     XVECLEN (PATTERN (TABLE), 1) + 1, (PREFIX), (NUM),\t\t\\\n \t     (PREFIX), (NUM), (PREFIX), (NUM))\n \n-/* At end of a switch table, define LD%n iff the symbol LI%n was defined.  */\n-#define ASM_OUTPUT_CASE_END(FILE,NUM,TABLE)\t\t\\\n-  if (RTX_INTEGRATED_P (TABLE))\t\t\t\t\\\n-    fprintf (FILE, \"\\tset LD%%%d,L%%%d-LI%%%d\\n\", (NUM), (NUM), (NUM))\n+/* At end of a switch table, define LDnnn iff the symbol LInnn was defined.\n+   Some SGS assemblers have a bug such that \"Lnnn-LInnn-2.b(pc,d0.l*2)\"\n+   fails to assemble.  Luckily \"LDnnn(pc,d0.l*2)\" produces the results\n+   we want.  This difference can be accommodated by making the assembler\n+   define such \"LDnnn\" to be either \"Lnnn-LInnn-2.b\", \"Lnnn\", or any other\n+   string, as necessary.  This is accomplished via the ASM_OUTPUT_CASE_END\n+   macro. */\n+\n+#define ASM_OUTPUT_CASE_END(FILE,NUM,TABLE)\t\t\t\t\\\n+{ if (switch_table_difference_label_flag)\t\t\t\t\\\n+    fprintf (FILE, \"\\tset LD%%%d,L%%%d-LI%%%d\\n\", (NUM), (NUM), (NUM))\t\\\n+  switch_table_difference_label_flag = 0; }\n+\n+int switch_table_difference_label_flag;\n \n #define ASM_OUTPUT_OPCODE(FILE, PTR)\t\t\t\\\n { if ((PTR)[0] == 'j' && (PTR)[1] == 'b')\t\t\\"}, {"sha": "38ac17da67d3889e83ba9001d0401e45a8304a38", "filename": "gcc/config/m68k/amix.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc3ffe83097fb810cac84d2b2007a25833684d74/gcc%2Fconfig%2Fm68k%2Famix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc3ffe83097fb810cac84d2b2007a25833684d74/gcc%2Fconfig%2Fm68k%2Famix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Famix.h?ref=fc3ffe83097fb810cac84d2b2007a25833684d74", "patch": "@@ -43,18 +43,21 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* At end of a switch table, define LDnnn iff the symbol LInnn was defined.\n    Some SGS assemblers have a bug such that \"Lnnn-LInnn-2.b(pc,d0.l*2)\"\n    fails to assemble.  Luckily \"Lnnn(pc,d0.l*2)\" produces the results\n-   we want.  This difference can be accommodated by using an assembler\n+   we want.  This difference can be accommodated by making the assembler\n    define such \"LDnnn\" to be either \"Lnnn-LInnn-2.b\", \"Lnnn\", or any other\n    string, as necessary.  This is accomplished via the ASM_OUTPUT_CASE_END\n    macro. (the Amiga assembler has this bug) */\n \n #undef ASM_OUTPUT_CASE_END\n #define ASM_OUTPUT_CASE_END(FILE,NUM,TABLE)\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n-  if (RTX_INTEGRATED_P (TABLE))\t\t\t\t\t\t\\\n+  if (switch_table_difference_label_flag)\t\t\t\t\\\n     asm_fprintf ((FILE), \"%s %LLD%d,%LL%d\\n\", SET_ASM_OP, (NUM), (NUM));\\\n+  switch_table_difference_label_flag = 0;\n } while (0)\n \n+int switch_table_difference_label_flag;\n+\n /* This says how to output assembler code to declare an\n    uninitialized external linkage data object.  Under SVR4,\n    the linker seems to want the alignment of data objects"}, {"sha": "3c016dc06475c14ff1ab30341521a3ca53179cfa", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc3ffe83097fb810cac84d2b2007a25833684d74/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc3ffe83097fb810cac84d2b2007a25833684d74/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=fc3ffe83097fb810cac84d2b2007a25833684d74", "patch": "@@ -872,9 +872,9 @@\n #else /* SGS_SWITCH_TABLES or not MOTOROLA */\n       ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"LI\\\",\n \t\t\t\t CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n-      /* For sake of 3b1, set flag saying we need to define the symbol\n-         LD%n (with value L%n-LI%n) at the end of the switch table.  */\n-      RTX_INTEGRATED_P (next_real_insn (XEXP (labelref, 0))) = 1;\n+      /* Set flag saying we need to define the symbol\n+\t LD%n (with value L%n-LI%n) at the end of the switch table.  */\n+      switch_table_difference_label_flag = 1;\n #endif /* SGS_SWITCH_TABLES or not MOTOROLA */\n     }\n #endif /* SGS_NO_LI */"}, {"sha": "2177083dc3b7191b85a05fba7e3a6218dac77357", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc3ffe83097fb810cac84d2b2007a25833684d74/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc3ffe83097fb810cac84d2b2007a25833684d74/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=fc3ffe83097fb810cac84d2b2007a25833684d74", "patch": "@@ -1307,7 +1307,6 @@ extern int rs6000_trunc_used;\n \t\t\t   main_input_filename, \".ro_\");\t\\\n \t\t\t\t\t\t\t\t\\\n   toc_section ();\t\t\t\t\t\t\\\n-  bss_section ();\t\t\t\t\t\t\\\n   if (write_symbols != NO_DEBUG)\t\t\t\t\\\n     private_data_section ();\t\t\t\t\t\\\n }\n@@ -1401,18 +1400,7 @@ toc_section ()\t\t\t\t\t\t\\\n     fprintf (asm_out_file, \"\\t.toc\\n\");\t\t\t\\\n \t\t\t\t\t\t\t\\\n   in_section = toc;\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\\\n-bss_section ()\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  if (in_section != bss)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"\\t.csect %s[BS]\\n\",\t\\\n-\t       xcoff_bss_section_name);\t\t\\\n-      in_section = bss;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\\\n+}\n \n /* This macro produces the initial definition of a function name.\n    On the RS/6000, we need to place an extra '.' in the function name and\n@@ -1637,7 +1625,8 @@ bss_section ()\t\t\t\t\t\t\\\n   \"fr28\", 60, \"fr29\", 61, \"fr30\", 62, \"fr31\", 63,\t\\\n   /* no additional names for: mq, lr, ctr, ap */\t\\\n   \"cr0\",  68, \"cr1\",  69, \"cr2\",  70, \"cr3\",  71,\t\\\n-  \"cr4\",  72, \"cr5\",  73, \"cr6\",  74, \"cr7\",  75 }\n+  \"cr4\",  72, \"cr5\",  73, \"cr6\",  74, \"cr7\",  75,\t\\\n+  \"cc\",   68 }\n \n /* How to renumber registers for dbx and gdb.  */\n \n@@ -1761,17 +1750,15 @@ bss_section ()\t\t\t\t\t\t\\\n    to define a global common symbol.  */\n \n #define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\\\n-  do { bss_section ();\t\t\t\t\t\\\n-       fputs (\".comm \", (FILE));\t\t\t\\\n+  do { fputs (\".comm \", (FILE));\t\t\t\\\n        RS6000_OUTPUT_BASENAME ((FILE), (NAME));\t\t\\\n        fprintf ((FILE), \",%d\\n\", (SIZE)); } while (0)\n \n /* This says how to output an assembler line\n    to define a local common symbol.  */\n \n #define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE,ROUNDED)\t\\\n-  do { bss_section ();\t\t\t\t\t\\\n-       fputs (\".lcomm \", (FILE));\t\t\t\\\n+  do { fputs (\".lcomm \", (FILE));\t\t\t\\\n        RS6000_OUTPUT_BASENAME ((FILE), (NAME));\t\t\\\n        fprintf ((FILE), \",%d,%s\\n\", (SIZE), xcoff_bss_section_name); \\\n      } while (0)"}, {"sha": "790696be2fb1d63649dc49b6796e861253e4222d", "filename": "gcc/cse.c", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc3ffe83097fb810cac84d2b2007a25833684d74/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc3ffe83097fb810cac84d2b2007a25833684d74/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=fc3ffe83097fb810cac84d2b2007a25833684d74", "patch": "@@ -620,6 +620,11 @@ rtx_cost (x)\n     case REG:\n       return 1;\n     case SUBREG:\n+      /* If we can't tie these modes, make this expensive.  The larger\n+\t the mode, the more expensive it is.  */\n+      if (! MODES_TIEABLE_P (GET_MODE (x), GET_MODE (SUBREG_REG (x))))\n+\treturn COSTS_N_INSNS (2\n+\t\t\t      + GET_MODE_SIZE (GET_MODE (x)) / UNITS_PER_WORD);\n       return 2;\n #ifdef RTX_COSTS\n       RTX_COSTS (x, code);\n@@ -4036,7 +4041,7 @@ simplify_ternary_operation (code, mode, op0_mode, op0, op1, op2)\n \t      val &= (1 << INTVAL (op1)) - 1;\n \t      /* If desired, propagate sign bit.  */\n \t      if (code == SIGN_EXTRACT && (val & (1 << (INTVAL (op1) - 1))))\n-\t\tval |= ~ (1 << INTVAL (op1));\n+\t\tval |= ~ ((1 << INTVAL (op1)) - 1);\n \t    }\n \n \t  /* Clear the bits that don't belong in our mode,\n@@ -4760,6 +4765,28 @@ equiv_constant (x)\n   if (x != 0 && CONSTANT_P (x))\n     return x;\n \n+  /* If X is a MEM, try to fold it outside the context of any insn to see if\n+     it might be equivalent to a constant.  That handles the case where it\n+     is a constant-pool reference.  Then try to look it up in the hash table\n+     in case it is something whose value we have seen before.  */\n+\n+  if (GET_CODE (x) == MEM)\n+    {\n+      struct table_elt *elt;\n+\n+      x = fold_rtx (x, 0);\n+      if (CONSTANT_P (x))\n+\treturn x;\n+\n+      elt = lookup (x, safe_hash (x, GET_MODE (x)) % NBUCKETS, GET_MODE (x));\n+      if (elt == 0)\n+\treturn 0;\n+\n+      for (elt = elt->first_same_value; elt; elt = elt->next_same_value)\n+\tif (elt->is_const && CONSTANT_P (elt->exp))\n+\t  return elt->exp;\n+    }\n+\n   return 0;\n }\n \f\n@@ -6191,10 +6218,10 @@ cse_insn (insn, in_libcall_block)\n \t\t\t      || sets[i].inner_dest != SET_DEST (sets[i].rtl));\n \t  }\n \n-\t/* If we have (set (subreg:m1 (reg:m2 foo) 0) (bar:m1)), M1 is wider\n-\t   than M2, and both M1 and M2 are a single word, we are also doing\n-\t   (set (reg:m2 foo) (subreg:m2 (bar:m1 0))) so make that equivalence\n-\t   as well.\n+\t/* If we have (set (subreg:m1 (reg:m2 foo) 0) (bar:m1)), M1 is no\n+\t   narrower than M2, and both M1 and M2 are the same number of words,\n+\t   we are also doing (set (reg:m2 foo) (subreg:m2 (bar:m1) 0)) so\n+\t   make that equivalence as well.\n \n \t   However, BAR may have equivalences for which gen_lowpart_if_possible\n \t   will produce a simpler value than gen_lowpart_if_possible applied to\n@@ -6207,8 +6234,8 @@ cse_insn (insn, in_libcall_block)\n \t   already entered SRC and DEST of the SET in the table.  */\n \n \tif (GET_CODE (dest) == SUBREG\n-\t    && GET_MODE_SIZE (GET_MODE (dest)) <= UNITS_PER_WORD\n-\t    && GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest))) <= UNITS_PER_WORD\n+\t    && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest))) / UNITS_PER_WORD\n+\t\t== GET_MODE_SIZE (GET_MODE (dest)) / UNITS_PER_WORD)\n \t    && (GET_MODE_SIZE (GET_MODE (dest))\n \t\t>= GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest))))\n \t    && sets[i].src_elt != 0)\n@@ -6813,6 +6840,7 @@ cse_end_of_basic_block (insn, data, follow_jumps, after_loop, skip_blocks)\n   rtx p = insn, q;\n   int nsets = 0;\n   int low_cuid = INSN_CUID (insn), high_cuid = INSN_CUID (insn);\n+  rtx next = GET_RTX_CLASS (GET_CODE (insn)) == 'i' ? insn : next_real_insn (insn);\n   int path_size = data->path_size;\n   int path_entry = 0;\n   int i;\n@@ -6913,8 +6941,11 @@ cse_end_of_basic_block (insn, data, follow_jumps, after_loop, skip_blocks)\n \t    {\n \t      /* Don't allow ourself to keep walking around an\n \t\t always-executed loop.  */\n-\t      if (next_real_insn (q) == next_real_insn (insn))\n-\t\tbreak;\n+\t      if (next_real_insn (q) == next)\n+\t\t{\n+\t\t  p = NEXT_INSN (p);\n+\t\t  continue;\n+\t\t}\n \n \t      /* Similarly, don't put a branch in our path more than once.  */\n \t      for (i = 0; i < path_entry; i++)\n@@ -6942,8 +6973,11 @@ cse_end_of_basic_block (insn, data, follow_jumps, after_loop, skip_blocks)\n \t    {\n \t      register rtx tmp;\n \n-\t      if (next_real_insn (q) == next_real_insn (insn))\n-\t\tbreak;\n+\t      if (next_real_insn (q) == next)\n+\t\t{\n+\t\t  p = NEXT_INSN (p);\n+\t\t  continue;\n+\t\t}\n \n \t      for (i = 0; i < path_entry; i++)\n \t\tif (data->path[i].branch == p)"}, {"sha": "c6b0f286ead87ac478804ef65cbdd639032c8495", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc3ffe83097fb810cac84d2b2007a25833684d74/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc3ffe83097fb810cac84d2b2007a25833684d74/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=fc3ffe83097fb810cac84d2b2007a25833684d74", "patch": "@@ -36,7 +36,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n  *\n  *      code generation `options':\n  *\n- *      - OBJC_INT_SELECTORS, OBJC_NONUNIQUE_SELECTORS, NEXT_OBJC_RUNTIME\n+ *      - OBJC_INT_SELECTORS, OBJC_SELECTORS_WITHOUT_LABELS, NEXT_OBJC_RUNTIME\n  */\n \n #include <stdio.h>\n@@ -238,7 +238,7 @@ static tree _OBJC_SYMBOLS_decl;\n static tree \t_OBJC_INSTANCE_VARIABLES_decl, _OBJC_CLASS_VARIABLES_decl;\n static tree \t_OBJC_INSTANCE_METHODS_decl, _OBJC_CLASS_METHODS_decl;\n static tree \t_OBJC_CLASS_decl, _OBJC_METACLASS_decl;\n-#ifdef OBJC_NONUNIQUE_SELECTORS\n+#ifdef OBJC_SELECTORS_WITHOUT_LABELS\n static tree \t_OBJC_SELECTOR_REFERENCES_decl;\n #endif\n static tree _OBJC_MODULES_decl;\n@@ -565,7 +565,7 @@ synth_module_prologue ()\n \n   /* extern SEL _OBJC_SELECTOR_REFERENCES[]; */\n \n-#ifdef OBJC_NONUNIQUE_SELECTORS\n+#ifdef OBJC_SELECTORS_WITHOUT_LABELS\n   _OBJC_SELECTOR_REFERENCES_decl\n     = create_builtin_decl (VAR_DECL, build_array_type (selector_type, NULLT),\n \t\t\t   \"_OBJC_SELECTOR_REFERENCES\");\n@@ -703,7 +703,7 @@ init_objc_symtab ()\n \n   /* refs = { ..., _OBJC_SELECTOR_REFERENCES, ... } */\n \n-#ifndef OBJC_NONUNIQUE_SELECTORS\n+#ifndef OBJC_SELECTORS_WITHOUT_LABELS\n   initlist = tree_cons (NULLT, build_int_2 (0, 0), initlist);\n #else\n   if (sel_ref_chain)\n@@ -1050,7 +1050,7 @@ build_msg_pool_reference (offset)\n   return expr;\n }\n \n-#ifndef OBJC_NONUNIQUE_SELECTORS\n+#ifndef OBJC_SELECTORS_WITHOUT_LABELS\n static tree\n build_selector_reference (idx)\n       int idx;\n@@ -1100,7 +1100,7 @@ build_selector_translation_table ()\n   tree sc_spec, decl_specs, expr_decl;\n   tree chain, initlist = NULLT;\n   int offset = 0;\n-#ifndef OBJC_NONUNIQUE_SELECTORS\n+#ifndef OBJC_SELECTORS_WITHOUT_LABELS\n   tree decl, var_decl;\n   int idx = 0;\n   char buf[256];\n@@ -1114,7 +1114,7 @@ build_selector_translation_table ()\n     {\n       tree expr;\n \n-#ifndef OBJC_NONUNIQUE_SELECTORS\n+#ifndef OBJC_SELECTORS_WITHOUT_LABELS\n       sprintf (buf, \"_OBJC_SELECTOR_REFERENCES_%d\", idx);\n       sc_spec = build_tree_list (NULLT, ridpointers[(int) RID_STATIC]);\n \n@@ -1133,15 +1133,15 @@ build_selector_translation_table ()\n       /* add one for the '\\0' character */\n       offset += IDENTIFIER_LENGTH (TREE_VALUE (chain)) + 1;\n \n-#ifndef OBJC_NONUNIQUE_SELECTORS\n+#ifndef OBJC_SELECTORS_WITHOUT_LABELS\n       finish_decl (decl, expr, NULLT);\n       idx++;\n #else\n       initlist = tree_cons (NULLT, expr, initlist);\n #endif\n     }\n \n-#ifdef OBJC_NONUNIQUE_SELECTORS\n+#ifdef OBJC_SELECTORS_WITHOUT_LABELS\n   DECL_INITIAL (_OBJC_SELECTOR_REFERENCES_decl) = (tree) 1;\n   initlist = build_nt (CONSTRUCTOR, NULLT, nreverse (initlist));\n   finish_decl (_OBJC_SELECTOR_REFERENCES_decl, initlist, NULLT);\n@@ -2623,7 +2623,7 @@ build_message_expr (mess)\n   /* Build the parameters list for looking up the method.\n      These are the object itself and the selector.  */\n   \n-#ifndef OBJC_NONUNIQUE_SELECTORS\n+#ifndef OBJC_SELECTORS_WITHOUT_LABELS\n   selector = build_selector_reference (selTransTbl_index);\n #else\n   selector = build_array_ref (_OBJC_SELECTOR_REFERENCES_decl,\n@@ -2895,7 +2895,7 @@ build_selector_expr (selnamelist)\n \n   selTransTbl_index = add_selector_reference (selname);\n \n-#ifndef OBJC_NONUNIQUE_SELECTORS\n+#ifndef OBJC_SELECTORS_WITHOUT_LABELS\n   return build_selector_reference (selTransTbl_index);\n #else\n   /* synthesize a reference into the selector translation table */"}]}