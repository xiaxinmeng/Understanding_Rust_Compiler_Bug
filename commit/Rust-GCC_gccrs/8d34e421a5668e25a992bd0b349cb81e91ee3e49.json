{"sha": "8d34e421a5668e25a992bd0b349cb81e91ee3e49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQzNGU0MjFhNTY2OGUyNWE5OTJiZDBiMzQ5Y2I4MWU5MWVlM2U0OQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-09-17T17:27:41Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-09-17T17:27:41Z"}, "message": "pr58387.c: New test.\n\n\t* gcc.c-torture/execute/pr58387.c: New test.\n\n\t* tree-ssa-dom.c (cprop_into_successor_phis): Also propagate\n\tedge implied equivalences into successor phis.\n\t* tree-ssa-threadupdate.c (phi_args_equal_on_edges): Moved into\n\there from tree-ssa-threadedge.c.\n\t(mark_threaded_blocks): When threading through a joiner, if both\n\tsuccessors of the joiner's clone reach the same block, verify the\n\tPHI arguments are equal.  If not, cancel the jump threading request.\n\t* tree-ssa-threadedge.c (phi_args_equal_on_edges): Moved into\n\ttree-ssa-threadupdate.c\n\t(thread_across_edge): Don't check PHI argument equality when\n\tthreading through joiner block here.\n\nFrom-SVN: r202660", "tree": {"sha": "94bfe22f7d19095ab53bd28cb6fb75e78e2f9196", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94bfe22f7d19095ab53bd28cb6fb75e78e2f9196"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d34e421a5668e25a992bd0b349cb81e91ee3e49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d34e421a5668e25a992bd0b349cb81e91ee3e49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d34e421a5668e25a992bd0b349cb81e91ee3e49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d34e421a5668e25a992bd0b349cb81e91ee3e49/comments", "author": null, "committer": null, "parents": [{"sha": "c152901f5e1082de4ede3bc98c7ede2dea361e8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c152901f5e1082de4ede3bc98c7ede2dea361e8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c152901f5e1082de4ede3bc98c7ede2dea361e8d"}], "stats": {"total": 154, "additions": 119, "deletions": 35}, "files": [{"sha": "78f4cbc6ce7d05e06fa6c5fc0f61b4ba99e93b3e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d34e421a5668e25a992bd0b349cb81e91ee3e49/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d34e421a5668e25a992bd0b349cb81e91ee3e49/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d34e421a5668e25a992bd0b349cb81e91ee3e49", "patch": "@@ -1,3 +1,17 @@\n+2013-09-17  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-dom.c (cprop_into_successor_phis): Also propagate\n+\tedge implied equivalences into successor phis.\n+\t* tree-ssa-threadupdate.c (phi_args_equal_on_edges): Moved into\n+\there from tree-ssa-threadedge.c.\n+\t(mark_threaded_blocks): When threading through a joiner, if both\n+\tsuccessors of the joiner's clone reach the same block, verify the\n+\tPHI arguments are equal.  If not, cancel the jump threading request.\n+\t* tree-ssa-threadedge.c (phi_args_equal_on_edges): Moved into\n+\ttree-ssa-threadupdate.c\n+\t(thread_across_edge): Don't check PHI argument equality when\n+\tthreading through joiner block here.\n+\t\n 2013-09-17  Andrew MacLeod <amacleod@redhat.com>\n \n \t* tree-flow.h (ssa_undefined_value_p): Remove prototype."}, {"sha": "d51c300bd1031a2cc49d820b452246af52ec9c6f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d34e421a5668e25a992bd0b349cb81e91ee3e49/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d34e421a5668e25a992bd0b349cb81e91ee3e49/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8d34e421a5668e25a992bd0b349cb81e91ee3e49", "patch": "@@ -1,3 +1,7 @@\n+2013-09-17  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.c-torture/execute/pr58387.c: New test.\n+\n 2013-09-17  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR tree-optimization/58088"}, {"sha": "74c32dfaf10d717df4ccf7a1be3f8a311cb25d41", "filename": "gcc/testsuite/gcc.c-torture/execute/pr58387.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d34e421a5668e25a992bd0b349cb81e91ee3e49/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr58387.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d34e421a5668e25a992bd0b349cb81e91ee3e49/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr58387.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr58387.c?ref=8d34e421a5668e25a992bd0b349cb81e91ee3e49", "patch": "@@ -0,0 +1,11 @@\n+extern void abort(void);\n+\n+int a = -1; \n+\n+int main ()\n+{\n+  int b = a == 0 ? 0 : -a;\n+  if (b < 1)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "4a2b48bd93d74576e5aab06bdb769412739dfc6e", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d34e421a5668e25a992bd0b349cb81e91ee3e49/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d34e421a5668e25a992bd0b349cb81e91ee3e49/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=8d34e421a5668e25a992bd0b349cb81e91ee3e49", "patch": "@@ -1235,7 +1235,7 @@ record_equivalences_from_incoming_edge (basic_block bb)\n \n \t\t  /* If the conversion widens the original value and\n \t\t     the constant is in the range of the type of OLD_RHS,\n-\t\t     then convert the constant and record the equivalence. \n+\t\t     then convert the constant and record the equivalence.\n \n \t\t     Note that int_fits_type_p does not check the precision\n \t\t     if the upper and lower bounds are OK.  */\n@@ -1642,6 +1642,28 @@ cprop_into_successor_phis (basic_block bb)\n       if (gsi_end_p (gsi))\n \tcontinue;\n \n+      /* We may have an equivalence associated with this edge.  While\n+\t we can not propagate it into non-dominated blocks, we can\n+\t propagate them into PHIs in non-dominated blocks.  */\n+\n+      /* Push the unwind marker so we can reset the const and copies\n+\t table back to its original state after processing this edge.  */\n+      const_and_copies_stack.safe_push (NULL_TREE);\n+\n+      /* Extract and record any simple NAME = VALUE equivalences.\n+\n+\t Don't bother with [01] = COND equivalences, they're not useful\n+\t here.  */\n+      struct edge_info *edge_info = (struct edge_info *) e->aux;\n+      if (edge_info)\n+\t{\n+\t  tree lhs = edge_info->lhs;\n+\t  tree rhs = edge_info->rhs;\n+\n+\t  if (lhs && TREE_CODE (lhs) == SSA_NAME)\n+\t    record_const_or_copy (lhs, rhs);\n+\t}\n+\n       indx = e->dest_idx;\n       for ( ; !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n@@ -1667,6 +1689,8 @@ cprop_into_successor_phis (basic_block bb)\n \t      && may_propagate_copy (orig_val, new_val))\n \t    propagate_value (orig_p, new_val);\n \t}\n+\n+      restore_vars_to_original_value ();\n     }\n }\n "}, {"sha": "47db280411713d5814c670eaad31c4802a3d429d", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 3, "deletions": 34, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d34e421a5668e25a992bd0b349cb81e91ee3e49/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d34e421a5668e25a992bd0b349cb81e91ee3e49/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=8d34e421a5668e25a992bd0b349cb81e91ee3e49", "patch": "@@ -841,28 +841,6 @@ thread_around_empty_blocks (edge taken_edge,\n   return false;\n }\n       \n-/* E1 and E2 are edges into the same basic block.  Return TRUE if the\n-   PHI arguments associated with those edges are equal or there are no\n-   PHI arguments, otherwise return FALSE.  */\n-\n-static bool\n-phi_args_equal_on_edges (edge e1, edge e2)\n-{\n-  gimple_stmt_iterator gsi;\n-  int indx1 = e1->dest_idx;\n-  int indx2 = e2->dest_idx;\n-\n-  for (gsi = gsi_start_phis (e1->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple phi = gsi_stmt (gsi);\n-\n-      if (!operand_equal_p (gimple_phi_arg_def (phi, indx1),\n-\t\t\t    gimple_phi_arg_def (phi, indx2), 0))\n-\treturn false;\n-    }\n-  return true;\n-}\n-\n /* We are exiting E->src, see if E->dest ends with a conditional\n    jump which has a known value when reached via E.\n \n@@ -1021,18 +999,9 @@ thread_across_edge (gimple dummy_cond,\n \t   record the jump threading opportunity.  */\n \tif (found)\n \t  {\n-\t    edge tmp;\n-\t    /* If there is already an edge from the block to be duplicated\n-\t       (E2->src) to the final target (E3->dest), then make sure that\n-\t       the PHI args associated with the edges E2 and E3 are the\n-\t       same.  */\n-\t    tmp = find_edge (taken_edge->src, path[path.length () - 1]->dest);\n-\t    if (!tmp || phi_args_equal_on_edges (tmp, path[path.length () - 1]))\n-\t      {\n-\t\tpropagate_threaded_block_debug_into (path[path.length () - 1]->dest,\n-\t\t\t\t\t\t     taken_edge->dest);\n-\t\tregister_jump_thread (path, true);\n-\t      }\n+\t    propagate_threaded_block_debug_into (path[path.length () - 1]->dest,\n+\t\t\t\t\t\t taken_edge->dest);\n+\t    register_jump_thread (path, true);\n \t  }\n \n         path.release();"}, {"sha": "413112814d6df5ac30abce13934164caa827fc5c", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d34e421a5668e25a992bd0b349cb81e91ee3e49/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d34e421a5668e25a992bd0b349cb81e91ee3e49/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=8d34e421a5668e25a992bd0b349cb81e91ee3e49", "patch": "@@ -1147,6 +1147,28 @@ thread_through_loop_header (struct loop *loop, bool may_peel_loop_headers)\n   return false;\n }\n \n+/* E1 and E2 are edges into the same basic block.  Return TRUE if the\n+   PHI arguments associated with those edges are equal or there are no\n+   PHI arguments, otherwise return FALSE.  */\n+\n+static bool\n+phi_args_equal_on_edges (edge e1, edge e2)\n+{\n+  gimple_stmt_iterator gsi;\n+  int indx1 = e1->dest_idx;\n+  int indx2 = e2->dest_idx;\n+\n+  for (gsi = gsi_start_phis (e1->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple phi = gsi_stmt (gsi);\n+\n+      if (!operand_equal_p (gimple_phi_arg_def (phi, indx1),\n+\t\t\t    gimple_phi_arg_def (phi, indx2), 0))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n /* Walk through the registered jump threads and convert them into a\n    form convenient for this pass.\n \n@@ -1219,6 +1241,46 @@ mark_threaded_blocks (bitmap threaded_blocks)\n \t}\n     }\n \n+  /* If we have a joiner block (J) which has two successors S1 and S2 and\n+     we are threading though S1 and the final destination of the thread\n+     is S2, then we must verify that any PHI nodes in S2 have the same\n+     PHI arguments for the edge J->S2 and J->S1->...->S2.\n+\n+     We used to detect this prior to registering the jump thread, but\n+     that prohibits propagation of edge equivalences into non-dominated\n+     PHI nodes as the equivalency test might occur before propagation. \n+\n+     This works for now, but will need improvement as part of the FSA\n+     optimization. \n+\n+     Note since we've moved the thread request data to the edges,\n+     we have to iterate on those rather than the threaded_edges vector.  */\n+  EXECUTE_IF_SET_IN_BITMAP (tmp, 0, i, bi)\n+    {\n+      bb = BASIC_BLOCK (i);\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\t{\n+\t  if (e->aux)\n+\t    {\n+\t      bool have_joiner = THREAD_TARGET2 (e) != NULL;\n+\n+\t      if (have_joiner)\n+\t\t{\n+\t\t  basic_block joiner = e->dest;\n+\t\t  edge final_edge = THREAD_TARGET2 (e);\n+\t\t  basic_block final_dest = final_edge->dest;\n+\t\t  edge e2 = find_edge (joiner, final_dest);\n+\n+\t\t  if (e2 && !phi_args_equal_on_edges (e2, final_edge))\n+\t\t    {\n+\t\t      free (e->aux);\n+\t\t      e->aux = NULL;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n \n   /* If optimizing for size, only thread through block if we don't have\n      to duplicate it or it's an otherwise empty redirection block.  */"}]}