{"sha": "ce2157a1a98c1f01e18b0aaa4a50efd51fff8d5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UyMTU3YTFhOThjMWYwMWUxOGIwYWFhNGE1MGVmZDUxZmZmOGQ1Yg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-09-23T18:35:51Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-09-23T18:35:51Z"}, "message": "fold-const.c (make_range): Correctly handle cases of converting from unsigned to signed type.\n\n        * fold-const.c (make_range): Correctly handle cases of converting\n        from unsigned to signed type.\n\n        * fold-const.c (merge_ranges): Make sure that if one range is subset\n        of another, it will always be the second range.  Correct (+,-) case to\n        account for this.\n\nBrought over from gcc2; fixes sparc bug.\n\nFrom-SVN: r15678", "tree": {"sha": "aefddc4f22b9283d6ac77cc07ba862d1cab55773", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aefddc4f22b9283d6ac77cc07ba862d1cab55773"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce2157a1a98c1f01e18b0aaa4a50efd51fff8d5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce2157a1a98c1f01e18b0aaa4a50efd51fff8d5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce2157a1a98c1f01e18b0aaa4a50efd51fff8d5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce2157a1a98c1f01e18b0aaa4a50efd51fff8d5b/comments", "author": null, "committer": null, "parents": [{"sha": "4bc8c3c1160be61c4d4d8f66ec9ca88151f60078", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bc8c3c1160be61c4d4d8f66ec9ca88151f60078", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bc8c3c1160be61c4d4d8f66ec9ca88151f60078"}], "stats": {"total": 115, "additions": 92, "deletions": 23}, "files": [{"sha": "6b7c829773563795cc2a715013a6ab3e6abfa61e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2157a1a98c1f01e18b0aaa4a50efd51fff8d5b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2157a1a98c1f01e18b0aaa4a50efd51fff8d5b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce2157a1a98c1f01e18b0aaa4a50efd51fff8d5b", "patch": "@@ -1,3 +1,14 @@\n+Tue Sep 23 12:34:51 1997  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* fold-const.c (make_range): Correctly handle cases of converting\n+\tfrom unsigned to signed type.\n+\n+Tue Sep 23 12:34:51 1997  Bernd Schmidt  <crux@pool.informatik.rwth-aachen.de>\n+\n+\t* fold-const.c (merge_ranges): Make sure that if one range is subset\n+\tof another, it will always be the second range.  Correct (+,-) case to\n+\taccount for this.\n+\n Tue Sep 23 01:15:50 1997  David S. Miller  <davem@tanya.rutgers.edu>\n \n \t* expmed.c (expand_divmod): If compute_mode is not the same as"}, {"sha": "def96bfa627a048a95ad5354d264366f85295123", "filename": "gcc/fold-const.c", "status": "modified", "additions": 81, "deletions": 23, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce2157a1a98c1f01e18b0aaa4a50efd51fff8d5b/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce2157a1a98c1f01e18b0aaa4a50efd51fff8d5b/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=ce2157a1a98c1f01e18b0aaa4a50efd51fff8d5b", "patch": "@@ -2863,14 +2863,62 @@ make_range (exp, pin_p, plow, phigh)\n \t      || (high != 0 && ! int_fits_type_p (high, type)))\n \t    break;\n \n-\t  if (low != 0)\n-\t    low = convert (type, low);\n+\t  n_low = low, n_high = high;\n \n-\t  if (high != 0)\n-\t    high = convert (type, high);\n+\t  if (n_low != 0)\n+\t    n_low = convert (type, n_low);\n+\n+\t  if (n_high != 0)\n+\t    n_high = convert (type, n_high);\n+\n+\t  /* If we're converting from an unsigned to a signed type,\n+\t     we will be doing the comparison as unsigned.  The tests above\n+\t     have already verified that LOW and HIGH are both positive.\n+\n+\t     So we have to make sure that the original unsigned value will\n+\t     be interpreted as positive.  */\n+\t  if (TREE_UNSIGNED (type) && ! TREE_UNSIGNED (TREE_TYPE (exp)))\n+\t    {\n+\t      tree equiv_type = type_for_mode (TYPE_MODE (type), 1);\n+\t      tree high_positive\n+\t\t= fold (build (RSHIFT_EXPR, type,\n+\t\t\t       convert (type,\n+\t\t\t\t\tTYPE_MAX_VALUE (equiv_type)),\n+\t\t\t       convert (type, integer_one_node)));\n+\t\t\t\n+\t      /* If the low bound is specified, \"and\" the range with the\n+\t\t range for which the original unsigned value will be\n+\t\t positive.  */\n+\t      if (low != 0)\n+\t\t{\n+\t\t  if (! merge_ranges (&n_in_p, &n_low, &n_high,\n+\t\t\t\t      1, n_low, n_high,\n+\t\t\t\t      1, convert (type, integer_zero_node),\n+\t\t\t\t      high_positive))\n+\t\t    break;\n+\n+\t\t  in_p = (n_in_p == in_p);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Otherwise, \"or\" the range with the range of the input\n+\t\t     that will be interpreted as negative.  */\n+\t\t  if (! merge_ranges (&n_in_p, &n_low, &n_high,\n+\t\t\t\t      0, n_low, n_high,\n+\t\t\t\t      1, convert (type, integer_zero_node),\n+\t\t\t\t      high_positive))\n+\t\t    break;\n+\n+\t\t  in_p = (in_p != n_in_p);\n+\t\t}\n+\t    }\n \n \t  exp = arg0;\n+\t  low = n_low, high = n_high;\n \t  continue;\n+\n+\tdefault:\n+\t  break;\n \t}\n \n       break;\n@@ -2956,15 +3004,20 @@ merge_ranges (pin_p, plow, phigh, in0_p, low0, high0, in1_p, low1, high1)\n   tree tem;\n   int in_p;\n   tree low, high;\n-\n-  /* Make range 0 be the range that starts first.  Swap them if it isn't.  */\n+  int lowequal = ((low0 == 0 && low1 == 0)\n+\t\t  || integer_onep (range_binop (EQ_EXPR, integer_type_node,\n+\t\t\t\t\t\tlow0, 0, low1, 0)));\n+  int highequal = ((high0 == 0 && high1 == 0)\n+\t\t   || integer_onep (range_binop (EQ_EXPR, integer_type_node,\n+\t\t\t\t\t\t high0, 1, high1, 1)));\n+\n+  /* Make range 0 be the range that starts first, or ends last if they\n+     start at the same value.  Swap them if it isn't.  */\n   if (integer_onep (range_binop (GT_EXPR, integer_type_node, \n \t\t\t\t low0, 0, low1, 0))\n-      || (((low0 == 0 && low1 == 0)\n-\t   || integer_onep (range_binop (EQ_EXPR, integer_type_node,\n-\t\t\t\t\t low0, 0, low1, 0)))\n+      || (lowequal\n \t  && integer_onep (range_binop (GT_EXPR, integer_type_node,\n-\t\t\t\t\thigh0, 1, high1, 1))))\n+\t\t\t\t\thigh1, 1, high0, 1))))\n     {\n       temp = in0_p, in0_p = in1_p, in1_p = temp;\n       tem = low0, low0 = low1, low1 = tem;\n@@ -2996,27 +3049,32 @@ merge_ranges (pin_p, plow, phigh, in0_p, low0, high0, in1_p, low1, high1)\n \n   else if (in0_p && ! in1_p)\n     {\n-      /* If they don't overlap, the result is the first range.  If the\n-\t second range is a subset of the first, we can't describe this as\n-\t a single range unless both ranges end at the same place.  If both\n-\t ranges start in the same place, then the result is false.\n-\t Otherwise, we go from the start of the first range to just before\n-\t the start of the second.  */\n+      /* If they don't overlap, the result is the first range.  If they are\n+\t equal, the result is false.  If the second range is a subset of the\n+\t first, and the ranges begin at the same place, we go from just after\n+\t the end of the first range to the end of the second.  If the second\n+\t range is not a subset of the first, or if it is a subset and both\n+\t ranges end at the same place, the range starts at the start of the\n+\t first range and ends just before the second range.\n+\t Otherwise, we can't describe this as a single range.  */\n       if (no_overlap)\n \tin_p = 1, low = low0, high = high0;\n-      else if (subset\n-\t       && integer_zerop (range_binop (EQ_EXPR, integer_type_node,\n-\t\t\t\t\t      high0, 1, high1, 0)))\n-\treturn 0;\n-      else if (integer_onep (range_binop (EQ_EXPR, integer_type_node,\n-\t\t\t\t\t  low0, 0, low1, 0)))\n+      else if (lowequal && highequal)\n \tin_p = 0, low = high = 0;\n-      else\n+      else if (subset && lowequal)\n+\t{\n+\t  in_p = 1, high = high0;\n+\t  low = range_binop (PLUS_EXPR, NULL_TREE, high1, 0,\n+\t\t\t     integer_one_node, 0);\t  \n+\t}\n+      else if (! subset || highequal)\n \t{\n \t  in_p = 1, low = low0;\n \t  high = range_binop (MINUS_EXPR, NULL_TREE, low1, 0,\n \t\t\t      integer_one_node, 0);\n \t}\n+      else\n+\treturn 0;\n     }\n \n   else if (! in0_p && in1_p)"}]}