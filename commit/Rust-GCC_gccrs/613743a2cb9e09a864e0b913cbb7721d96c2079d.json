{"sha": "613743a2cb9e09a864e0b913cbb7721d96c2079d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjEzNzQzYTJjYjllMDlhODY0ZTBiOTEzY2JiNzcyMWQ5NmMyMDc5ZA==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2015-10-19T09:23:07Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2015-10-19T09:23:07Z"}, "message": "[haifa-sched] model load/store multiples properly in autoprefetcher scheduling\n\n\t* sched-int.h (struct autopref_multipass_data_): Remove offset\n\tfield.  Add min_offset, max_offset, multi_mem_insn_p fields.\n\t* haifa-sched.c (analyze_set_insn_for_autopref): New function.\n\t(autopref_multipass_init): Use it.  Handle PARALLEL sets.\n\t(autopref_rank_data): New function.\n\t(autopref_rank_for_schedule): Use it.\n\t(autopref_multipass_dfa_lookahead_guard_1): Likewise.\n\nFrom-SVN: r228962", "tree": {"sha": "28d9759757f90c9e8bdef847447a24705e156f03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28d9759757f90c9e8bdef847447a24705e156f03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/613743a2cb9e09a864e0b913cbb7721d96c2079d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/613743a2cb9e09a864e0b913cbb7721d96c2079d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/613743a2cb9e09a864e0b913cbb7721d96c2079d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/613743a2cb9e09a864e0b913cbb7721d96c2079d/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eb5ea58e9edce24e6142e6f6f5d9ab0d1dfc4c84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb5ea58e9edce24e6142e6f6f5d9ab0d1dfc4c84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb5ea58e9edce24e6142e6f6f5d9ab0d1dfc4c84"}], "stats": {"total": 191, "additions": 174, "deletions": 17}, "files": [{"sha": "c9a1a11ca085af21590898c18d3f09fa99191ea3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/613743a2cb9e09a864e0b913cbb7721d96c2079d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/613743a2cb9e09a864e0b913cbb7721d96c2079d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=613743a2cb9e09a864e0b913cbb7721d96c2079d", "patch": "@@ -1,3 +1,13 @@\n+2015-10-19  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* sched-int.h (struct autopref_multipass_data_): Remove offset\n+\tfield.  Add min_offset, max_offset, multi_mem_insn_p fields.\n+\t* haifa-sched.c (analyze_set_insn_for_autopref): New function.\n+\t(autopref_multipass_init): Use it.  Handle PARALLEL sets.\n+\t(autopref_rank_data): New function.\n+\t(autopref_rank_for_schedule): Use it.\n+\t(autopref_multipass_dfa_lookahead_guard_1): Likewise. \n+\n 2015-10-18  Mikhail Maltsev  <maltsevm@gmail.com>\n \n \tPR other/65800"}, {"sha": "46751fe385fc4422c02e16e57160d65f6cc9dc99", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 153, "deletions": 15, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/613743a2cb9e09a864e0b913cbb7721d96c2079d/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/613743a2cb9e09a864e0b913cbb7721d96c2079d/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=613743a2cb9e09a864e0b913cbb7721d96c2079d", "patch": "@@ -5533,6 +5533,35 @@ insn_finishes_cycle_p (rtx_insn *insn)\n   return false;\n }\n \n+/* Helper for autopref_multipass_init.  Given a SET in PAT and whether\n+   we're expecting a memory WRITE or not, check that the insn is relevant to\n+   the autoprefetcher modelling code.  Return true iff that is the case.\n+   If it is relevant, record the base register of the memory op in BASE and\n+   the offset in OFFSET.  */\n+\n+static bool\n+analyze_set_insn_for_autopref (rtx pat, bool write, rtx *base, int *offset)\n+{\n+  if (GET_CODE (pat) != SET)\n+    return false;\n+\n+  rtx mem = write ? SET_DEST (pat) : SET_SRC (pat);\n+  if (!MEM_P (mem))\n+    return false;\n+\n+  struct address_info info;\n+  decompose_mem_address (&info, mem);\n+\n+  /* TODO: Currently only (base+const) addressing is supported.  */\n+  if (info.base == NULL || !REG_P (*info.base)\n+      || (info.disp != NULL && !CONST_INT_P (*info.disp)))\n+    return false;\n+\n+  *base = *info.base;\n+  *offset = info.disp ? INTVAL (*info.disp) : 0;\n+  return true;\n+}\n+\n /* Functions to model cache auto-prefetcher.\n \n    Some of the CPUs have cache auto-prefetcher, which /seems/ to initiate\n@@ -5557,30 +5586,139 @@ autopref_multipass_init (const rtx_insn *insn, int write)\n \n   gcc_assert (data->status == AUTOPREF_MULTIPASS_DATA_UNINITIALIZED);\n   data->base = NULL_RTX;\n-  data->offset = 0;\n+  data->min_offset = 0;\n+  data->max_offset = 0;\n+  data->multi_mem_insn_p = false;\n   /* Set insn entry initialized, but not relevant for auto-prefetcher.  */\n   data->status = AUTOPREF_MULTIPASS_DATA_IRRELEVANT;\n \n+  rtx pat = PATTERN (insn);\n+\n+  /* We have a multi-set insn like a load-multiple or store-multiple.\n+     We care about these as long as all the memory ops inside the PARALLEL\n+     have the same base register.  We care about the minimum and maximum\n+     offsets from that base but don't check for the order of those offsets\n+     within the PARALLEL insn itself.  */\n+  if (GET_CODE (pat) == PARALLEL)\n+    {\n+      int n_elems = XVECLEN (pat, 0);\n+\n+      int i = 0;\n+      rtx prev_base = NULL_RTX;\n+      int min_offset;\n+      int max_offset;\n+\n+      for (i = 0; i < n_elems; i++)\n+\t{\n+\t  rtx set = XVECEXP (pat, 0, i);\n+\t  if (GET_CODE (set) != SET)\n+\t    return;\n+\n+\t  rtx base = NULL_RTX;\n+\t  int offset = 0;\n+\t  if (!analyze_set_insn_for_autopref (set, write, &base, &offset))\n+\t    return;\n+\n+\t  if (i == 0)\n+\t    {\n+\t      prev_base = base;\n+\t      min_offset = offset;\n+\t      max_offset = offset;\n+\t    }\n+\t  /* Ensure that all memory operations in the PARALLEL use the same\n+\t     base register.  */\n+\t  else if (REGNO (base) != REGNO (prev_base))\n+\t    return;\n+\t  else\n+\t    {\n+\t      min_offset = MIN (min_offset, offset);\n+\t      max_offset = MAX (max_offset, offset);\n+\t    }\n+\t}\n+\n+      /* If we reached here then we have a valid PARALLEL of multiple memory\n+\t ops with prev_base as the base and min_offset and max_offset\n+\t containing the offsets range.  */\n+      gcc_assert (prev_base);\n+      data->base = prev_base;\n+      data->min_offset = min_offset;\n+      data->max_offset = max_offset;\n+      data->multi_mem_insn_p = true;\n+      data->status = AUTOPREF_MULTIPASS_DATA_NORMAL;\n+\n+      return;\n+    }\n+\n+  /* Otherwise this is a single set memory operation.  */\n   rtx set = single_set (insn);\n   if (set == NULL_RTX)\n     return;\n \n-  rtx mem = write ? SET_DEST (set) : SET_SRC (set);\n-  if (!MEM_P (mem))\n+  if (!analyze_set_insn_for_autopref (set, write, &data->base,\n+\t\t\t\t       &data->min_offset))\n     return;\n \n-  struct address_info info;\n-  decompose_mem_address (&info, mem);\n+  /* This insn is relevant for the auto-prefetcher.\n+     The base and offset fields will have been filled in the\n+     analyze_set_insn_for_autopref call above.  */\n+  data->status = AUTOPREF_MULTIPASS_DATA_NORMAL;\n+}\n \n-  /* TODO: Currently only (base+const) addressing is supported.  */\n-  if (info.base == NULL || !REG_P (*info.base)\n-      || (info.disp != NULL && !CONST_INT_P (*info.disp)))\n-    return;\n \n-  /* This insn is relevant for auto-prefetcher.  */\n-  data->base = *info.base;\n-  data->offset = info.disp ? INTVAL (*info.disp) : 0;\n-  data->status = AUTOPREF_MULTIPASS_DATA_NORMAL;\n+/* Helper for autopref_rank_for_schedule.  Given the data of two\n+   insns relevant to the auto-prefetcher modelling code DATA1 and DATA2\n+   return their comparison result.  Return 0 if there is no sensible\n+   ranking order for the two insns.  */\n+\n+static int\n+autopref_rank_data (autopref_multipass_data_t data1,\n+\t\t     autopref_multipass_data_t data2)\n+{\n+  /* Simple case when both insns are simple single memory ops.  */\n+  if (!data1->multi_mem_insn_p && !data2->multi_mem_insn_p)\n+    return data1->min_offset - data2->min_offset;\n+\n+  /* Two load/store multiple insns.  Return 0 if the offset ranges\n+     overlap and the difference between the minimum offsets otherwise.  */\n+  else if (data1->multi_mem_insn_p && data2->multi_mem_insn_p)\n+    {\n+      int min1 = data1->min_offset;\n+      int max1 = data1->max_offset;\n+      int min2 = data2->min_offset;\n+      int max2 = data2->max_offset;\n+\n+      if (max1 < min2 || min1 > max2)\n+\treturn min1 - min2;\n+      else\n+\treturn 0;\n+    }\n+\n+  /* The other two cases is a pair of a load/store multiple and\n+     a simple memory op.  Return 0 if the single op's offset is within the\n+     range of the multi-op insn and the difference between the single offset\n+     and the minimum offset of the multi-set insn otherwise.  */\n+  else if (data1->multi_mem_insn_p && !data2->multi_mem_insn_p)\n+    {\n+      int max1 = data1->max_offset;\n+      int min1 = data1->min_offset;\n+\n+      if (data2->min_offset >= min1\n+\t  && data2->min_offset <= max1)\n+\treturn 0;\n+      else\n+\treturn min1 - data2->min_offset;\n+    }\n+  else\n+    {\n+      int max2 = data2->max_offset;\n+      int min2 = data2->min_offset;\n+\n+      if (data1->min_offset >= min2\n+\t  && data1->min_offset <= max2)\n+\treturn 0;\n+      else\n+\treturn data1->min_offset - min2;\n+    }\n }\n \n /* Helper function for rank_for_schedule sorting.  */\n@@ -5607,7 +5745,7 @@ autopref_rank_for_schedule (const rtx_insn *insn1, const rtx_insn *insn2)\n       if (!rtx_equal_p (data1->base, data2->base))\n \tcontinue;\n \n-      return data1->offset - data2->offset;\n+      return autopref_rank_data (data1, data2);\n     }\n \n   return 0;\n@@ -5633,7 +5771,7 @@ autopref_multipass_dfa_lookahead_guard_1 (const rtx_insn *insn1,\n     return 0;\n \n   if (rtx_equal_p (data1->base, data2->base)\n-      && data1->offset > data2->offset)\n+      && autopref_rank_data (data1, data2) > 0)\n     {\n       if (sched_verbose >= 2)\n \t{"}, {"sha": "86f582105f8eb89d5ca29a4a1afe8f0586281de2", "filename": "gcc/sched-int.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/613743a2cb9e09a864e0b913cbb7721d96c2079d/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/613743a2cb9e09a864e0b913cbb7721d96c2079d/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=613743a2cb9e09a864e0b913cbb7721d96c2079d", "patch": "@@ -807,8 +807,17 @@ struct autopref_multipass_data_\n {\n   /* Base part of memory address.  */\n   rtx base;\n-  /* Memory offset.  */\n-  int offset;\n+\n+  /* Memory offsets from the base.  For single simple sets\n+     only min_offset is valid.  For multi-set insns min_offset\n+     and max_offset record the minimum and maximum offsets from the same\n+     base among the sets inside the PARALLEL.  */\n+  int min_offset;\n+  int max_offset;\n+\n+  /* True if this is a load/store-multiple instruction.  */\n+  bool multi_mem_insn_p;\n+\n   /* Entry status.  */\n   enum autopref_multipass_data_status status;\n };"}]}