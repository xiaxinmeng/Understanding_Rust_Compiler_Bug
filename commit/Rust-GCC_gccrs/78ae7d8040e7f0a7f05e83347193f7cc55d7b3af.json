{"sha": "78ae7d8040e7f0a7f05e83347193f7cc55d7b3af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhhZTdkODA0MGU3ZjBhN2YwNWU4MzM0NzE5M2Y3Y2M1NWQ3YjNhZg==", "commit": {"author": {"name": "Paul Eggert", "email": "eggert@gnu.org", "date": "1996-01-18T00:12:52Z"}, "committer": {"name": "Paul Eggert", "email": "eggert@gnu.org", "date": "1996-01-18T00:12:52Z"}, "message": "(HOST_WIDE_INT_MASK): Renamed from LONG_MASK; use HOST_WIDE_INT.\n\n(HOST_WIDE_INT, HOST_BITS_PER_WIDE_INT): New (actually resuscitated) macros.\n(parse_c_expression, expression_value, parse_escape, left_shift, right_shift,\nstruct constant, exp, parse_number, yylex): Replace `long' with\n`HOST_WIDE_INT'.\n\nFrom-SVN: r11061", "tree": {"sha": "e29f3fe95668094fde76f268dddbd148e6edab1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e29f3fe95668094fde76f268dddbd148e6edab1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78ae7d8040e7f0a7f05e83347193f7cc55d7b3af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78ae7d8040e7f0a7f05e83347193f7cc55d7b3af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78ae7d8040e7f0a7f05e83347193f7cc55d7b3af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78ae7d8040e7f0a7f05e83347193f7cc55d7b3af/comments", "author": null, "committer": null, "parents": [{"sha": "047380ca1327d6c7866182c715703d804931007d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/047380ca1327d6c7866182c715703d804931007d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/047380ca1327d6c7866182c715703d804931007d"}], "stats": {"total": 113, "additions": 70, "deletions": 43}, "files": [{"sha": "f3456442dc3a7f936c3d7a24e474aec953337d7c", "filename": "gcc/cexp.y", "status": "modified", "additions": 70, "deletions": 43, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ae7d8040e7f0a7f05e83347193f7cc55d7b3af/gcc%2Fcexp.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ae7d8040e7f0a7f05e83347193f7cc55d7b3af/gcc%2Fcexp.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcexp.y?ref=78ae7d8040e7f0a7f05e83347193f7cc55d7b3af", "patch": "@@ -82,12 +82,30 @@ struct arglist {\n #endif\n #endif\n \n-#define LONG_MASK(bits) ((bits) < HOST_BITS_PER_LONG ? ~(~0L << (bits)) : ~0L)\n-\n #ifndef NULL_PTR\n #define NULL_PTR ((GENERIC_PTR)0)\n #endif\n \n+/* Find the largest host integer type and set its size and type.\n+   Don't blindly use `long'; on some crazy hosts it is shorter than `int'.  */\n+\n+#ifndef HOST_BITS_PER_WIDE_INT\n+\n+#if HOST_BITS_PER_LONG > HOST_BITS_PER_INT\n+#define HOST_BITS_PER_WIDE_INT HOST_BITS_PER_LONG\n+#define HOST_WIDE_INT long\n+#else\n+#define HOST_BITS_PER_WIDE_INT HOST_BITS_PER_INT\n+#define HOST_WIDE_INT int\n+#endif\n+\n+#endif\n+\n+#define HOST_WIDE_INT_MASK(bits) \\\n+  ((bits) < HOST_BITS_PER_WIDE_INT \\\n+   ? ~ (~ (HOST_WIDE_INT) 0 << (bits)) \\\n+   : ~ (HOST_WIDE_INT) 0)\n+\n #if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 6)\n # define __attribute__(x)\n #endif\n@@ -124,11 +142,11 @@ struct arglist {\n \n #define PRINTF_PROTO_1(ARGS) PRINTF_PROTO(ARGS, 1, 2)\n \n-long parse_c_expression PROTO((char *));\n+HOST_WIDE_INT parse_c_expression PROTO((char *));\n \n static int yylex PROTO((void));\n static void yyerror PROTO((char *)) __attribute__ ((noreturn));\n-static long expression_value;\n+static HOST_WIDE_INT expression_value;\n \n static jmp_buf parse_return_error;\n \n@@ -193,16 +211,16 @@ extern int traditional;\n struct constant;\n \n GENERIC_PTR xmalloc PROTO((size_t));\n-long parse_escape PROTO((char **, long));\n+HOST_WIDE_INT parse_escape PROTO((char **, HOST_WIDE_INT));\n int check_assertion PROTO((U_CHAR *, int, int, struct arglist *));\n struct hashnode *lookup PROTO((U_CHAR *, int, int));\n void error PRINTF_PROTO_1((char *, ...));\n void pedwarn PRINTF_PROTO_1((char *, ...));\n void warning PRINTF_PROTO_1((char *, ...));\n \n static int parse_number PROTO((int));\n-static long left_shift PROTO((struct constant *, unsigned long));\n-static long right_shift PROTO((struct constant *, unsigned long));\n+static HOST_WIDE_INT left_shift PROTO((struct constant *, unsigned HOST_WIDE_INT));\n+static HOST_WIDE_INT right_shift PROTO((struct constant *, unsigned HOST_WIDE_INT));\n static void integer_overflow PROTO((void));\n \n /* `signedp' values */\n@@ -211,7 +229,7 @@ static void integer_overflow PROTO((void));\n %}\n \n %union {\n-  struct constant {long value; int signedp;} integer;\n+  struct constant {HOST_WIDE_INT value; int signedp;} integer;\n   struct name {U_CHAR *address; int length;} name;\n   struct arglist *keywords;\n }\n@@ -293,7 +311,8 @@ exp\t:\texp '*' exp\n \t\t\t\tinteger_overflow ();\n \t\t\t    }\n \t\t\t  else\n-\t\t\t    $$.value = (unsigned long) $1.value * $3.value; }\n+\t\t\t    $$.value = ((unsigned HOST_WIDE_INT) $1.value\n+\t\t\t\t\t* $3.value); }\n \t|\texp '/' exp\n \t\t\t{ if ($3.value == 0)\n \t\t\t    {\n@@ -309,7 +328,8 @@ exp\t:\texp '*' exp\n \t\t\t\tinteger_overflow ();\n \t\t\t    }\n \t\t\t  else\n-\t\t\t    $$.value = (unsigned long) $1.value / $3.value; }\n+\t\t\t    $$.value = ((unsigned HOST_WIDE_INT) $1.value\n+\t\t\t\t\t/ $3.value); }\n \t|\texp '%' exp\n \t\t\t{ if ($3.value == 0)\n \t\t\t    {\n@@ -321,7 +341,8 @@ exp\t:\texp '*' exp\n \t\t\t  if ($$.signedp)\n \t\t\t    $$.value = $1.value % $3.value;\n \t\t\t  else\n-\t\t\t    $$.value = (unsigned long) $1.value % $3.value; }\n+\t\t\t    $$.value = ((unsigned HOST_WIDE_INT) $1.value\n+\t\t\t\t\t% $3.value); }\n \t|\texp '+' exp\n \t\t\t{ $$.value = $1.value + $3.value;\n \t\t\t  $$.signedp = $1.signedp & $3.signedp;\n@@ -357,25 +378,29 @@ exp\t:\texp '*' exp\n \t\t\t  if ($1.signedp & $3.signedp)\n \t\t\t    $$.value = $1.value <= $3.value;\n \t\t\t  else\n-\t\t\t    $$.value = (unsigned long) $1.value <= $3.value; }\n+\t\t\t    $$.value = ((unsigned HOST_WIDE_INT) $1.value\n+\t\t\t\t\t<= $3.value); }\n \t|\texp GEQ exp\n \t\t\t{ $$.signedp = SIGNED;\n \t\t\t  if ($1.signedp & $3.signedp)\n \t\t\t    $$.value = $1.value >= $3.value;\n \t\t\t  else\n-\t\t\t    $$.value = (unsigned long) $1.value >= $3.value; }\n+\t\t\t    $$.value = ((unsigned HOST_WIDE_INT) $1.value\n+\t\t\t\t\t>= $3.value); }\n \t|\texp '<' exp\n \t\t\t{ $$.signedp = SIGNED;\n \t\t\t  if ($1.signedp & $3.signedp)\n \t\t\t    $$.value = $1.value < $3.value;\n \t\t\t  else\n-\t\t\t    $$.value = (unsigned long) $1.value < $3.value; }\n+\t\t\t    $$.value = ((unsigned HOST_WIDE_INT) $1.value\n+\t\t\t\t\t< $3.value); }\n \t|\texp '>' exp\n \t\t\t{ $$.signedp = SIGNED;\n \t\t\t  if ($1.signedp & $3.signedp)\n \t\t\t    $$.value = $1.value > $3.value;\n \t\t\t  else\n-\t\t\t    $$.value = (unsigned long) $1.value > $3.value; }\n+\t\t\t    $$.value = ((unsigned HOST_WIDE_INT) $1.value\n+\t\t\t\t\t> $3.value); }\n \t|\texp '&' exp\n \t\t\t{ $$.value = $1.value & $3.value;\n \t\t\t  $$.signedp = $1.signedp & $3.signedp; }\n@@ -454,7 +479,7 @@ parse_number (olen)\n {\n   register char *p = lexptr;\n   register int c;\n-  register unsigned long n = 0, nd, ULONG_MAX_over_base;\n+  register unsigned HOST_WIDE_INT n = 0, nd, max_over_base;\n   register int base = 10;\n   register int len = olen;\n   register int overflow = 0;\n@@ -472,7 +497,7 @@ parse_number (olen)\n     }\n   }\n \n-  ULONG_MAX_over_base = (unsigned long) -1 / base;\n+  max_over_base = (unsigned HOST_WIDE_INT) -1 / base;\n \n   for (; len > 0; len--) {\n     c = *p++;\n@@ -519,7 +544,7 @@ parse_number (olen)\n     if (largest_digit < digit)\n       largest_digit = digit;\n     nd = n * base + digit;\n-    overflow |= (ULONG_MAX_over_base < n) | (nd < n);\n+    overflow |= (max_over_base < n) | (nd < n);\n     n = nd;\n   }\n \n@@ -530,7 +555,7 @@ parse_number (olen)\n     warning (\"integer constant out of range\");\n \n   /* If too big to be signed, consider it unsigned.  */\n-  if (((long) n & yylval.integer.signedp) < 0)\n+  if (((HOST_WIDE_INT) n & yylval.integer.signedp) < 0)\n     {\n       if (base == 10)\n \twarning (\"integer constant is so large that it is unsigned\");\n@@ -571,7 +596,7 @@ yylex ()\n   register unsigned char *tokstart;\n   register struct token *toktab;\n   int wide_flag;\n-  long mask;\n+  HOST_WIDE_INT mask;\n \n  retry:\n \n@@ -607,21 +632,21 @@ yylex ()\n       {\n \tlexptr++;\n \twide_flag = 1;\n-\tmask = LONG_MASK (MAX_WCHAR_TYPE_SIZE);\n+\tmask = HOST_WIDE_INT_MASK (MAX_WCHAR_TYPE_SIZE);\n \tgoto char_constant;\n       }\n     if (lexptr[1] == '\"')\n       {\n \tlexptr++;\n \twide_flag = 1;\n-\tmask = LONG_MASK (MAX_WCHAR_TYPE_SIZE);\n+\tmask = HOST_WIDE_INT_MASK (MAX_WCHAR_TYPE_SIZE);\n \tgoto string_constant;\n       }\n     break;\n \n   case '\\'':\n     wide_flag = 0;\n-    mask = LONG_MASK (MAX_CHAR_TYPE_SIZE);\n+    mask = HOST_WIDE_INT_MASK (MAX_CHAR_TYPE_SIZE);\n   char_constant:\n     lexptr++;\n     if (keyword_parsing) {\n@@ -642,7 +667,7 @@ yylex ()\n        handles multicharacter constants and wide characters.\n        It is mostly copied from c-lex.c.  */\n     {\n-      register long result = 0;\n+      register HOST_WIDE_INT result = 0;\n       register num_chars = 0;\n       unsigned width = MAX_CHAR_TYPE_SIZE;\n       int max_chars;\n@@ -679,7 +704,7 @@ yylex ()\n \t  /* Merge character into result; ignore excess chars.  */\n \t  if (num_chars <= max_chars)\n \t    {\n-\t      if (width < HOST_BITS_PER_LONG)\n+\t      if (width < HOST_BITS_PER_WIDE_INT)\n \t\tresult = (result << width) | c;\n \t      else\n \t\tresult = c;\n@@ -709,10 +734,12 @@ yylex ()\n \t  if (lookup (\"__CHAR_UNSIGNED__\", sizeof (\"__CHAR_UNSIGNED__\")-1, -1)\n \t      || ((result >> (num_bits - 1)) & 1) == 0)\n \t    yylval.integer.value\n-\t      = result & (~ (unsigned long) 0 >> (HOST_BITS_PER_LONG - num_bits));\n+\t      = result & (~ (unsigned HOST_WIDE_INT) 0\n+\t\t\t  >> (HOST_BITS_PER_WIDE_INT - num_bits));\n \t  else\n \t    yylval.integer.value\n-\t      = result | ~(~ (unsigned long) 0 >> (HOST_BITS_PER_LONG - num_bits));\n+\t      = result | ~(~ (unsigned HOST_WIDE_INT) 0\n+\t\t\t   >> (HOST_BITS_PER_WIDE_INT - num_bits));\n \t}\n       else\n \t{\n@@ -774,7 +801,7 @@ yylex ()\n     return c;\n \n   case '\"':\n-    mask = LONG_MASK (MAX_CHAR_TYPE_SIZE);\n+    mask = HOST_WIDE_INT_MASK (MAX_CHAR_TYPE_SIZE);\n   string_constant:\n     if (keyword_parsing) {\n       char *start_ptr = lexptr;\n@@ -852,10 +879,10 @@ yylex ()\n    If \\ is followed by 000, we return 0 and leave the string pointer\n    after the zeros.  A value of 0 does not mean end of string.  */\n \n-long\n+HOST_WIDE_INT\n parse_escape (string_ptr, result_mask)\n      char **string_ptr;\n-     long result_mask;\n+     HOST_WIDE_INT result_mask;\n {\n   register int c = *(*string_ptr)++;\n   switch (c)\n@@ -894,7 +921,7 @@ parse_escape (string_ptr, result_mask)\n     case '6':\n     case '7':\n       {\n-\tregister long i = c - '0';\n+\tregister HOST_WIDE_INT i = c - '0';\n \tregister int count = 0;\n \twhile (++count < 3)\n \t  {\n@@ -916,7 +943,7 @@ parse_escape (string_ptr, result_mask)\n       }\n     case 'x':\n       {\n-\tregister unsigned long i = 0, overflow = 0;\n+\tregister unsigned HOST_WIDE_INT i = 0, overflow = 0;\n \tregister int digits_found = 0, digit;\n \tfor (;;)\n \t  {\n@@ -966,31 +993,31 @@ integer_overflow ()\n     pedwarn (\"integer overflow in preprocessor expression\");\n }\n \n-static long\n+static HOST_WIDE_INT\n left_shift (a, b)\n      struct constant *a;\n-     unsigned long b;\n+     unsigned HOST_WIDE_INT b;\n {\n    /* It's unclear from the C standard whether shifts can overflow.\n       The following code ignores overflow; perhaps a C standard\n       interpretation ruling is needed.  */\n-  if (b >= HOST_BITS_PER_LONG)\n+  if (b >= HOST_BITS_PER_WIDE_INT)\n     return 0;\n   else\n-    return (unsigned long) a->value << b;\n+    return (unsigned HOST_WIDE_INT) a->value << b;\n }\n \n-static long\n+static HOST_WIDE_INT\n right_shift (a, b)\n      struct constant *a;\n-     unsigned long b;\n+     unsigned HOST_WIDE_INT b;\n {\n-  if (b >= HOST_BITS_PER_LONG)\n-    return a->signedp ? a->value >> (HOST_BITS_PER_LONG - 1) : 0;\n+  if (b >= HOST_BITS_PER_WIDE_INT)\n+    return a->signedp ? a->value >> (HOST_BITS_PER_WIDE_INT - 1) : 0;\n   else if (a->signedp)\n     return a->value >> b;\n   else\n-    return (unsigned long) a->value >> b;\n+    return (unsigned HOST_WIDE_INT) a->value >> b;\n }\n \f\n /* This page contains the entry point to this file.  */\n@@ -1002,7 +1029,7 @@ right_shift (a, b)\n /* We do not support C comments.  They should be removed before\n    this function is called.  */\n \n-long\n+HOST_WIDE_INT\n parse_c_expression (string)\n      char *string;\n {\n@@ -1063,7 +1090,7 @@ main (argc, argv)\n       n++;\n     if (c == EOF)\n       break;\n-    printf (\"parser returned %ld\\n\", parse_c_expression (buf));\n+    printf (\"parser returned %ld\\n\", (long) parse_c_expression (buf));\n   }\n \n   return 0;"}]}