{"sha": "5164151f87bf8872c5e0749dd30730bce79cb5b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE2NDE1MWY4N2JmODg3MmM1ZTA3NDlkZDMwNzMwYmNlNzljYjViOA==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2013-10-14T13:13:55Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-14T13:13:55Z"}, "message": "errout.adb (Write_Error_Summary): Do not output the number of lines when Main_Source_File is unknown.\n\n2013-10-14  Vincent Celier  <celier@adacore.com>\n\n\t* errout.adb (Write_Error_Summary): Do not output the number\n\tof lines when Main_Source_File is unknown.\n\t(Output_Messages): Do not write the header when Main_Source_File is\n\tunknown.\n\n2013-10-14  Vincent Celier  <celier@adacore.com>\n\n\t* prep.adb (Expression): Accept terms of the form 'symbol <relop>\n\tinteger\", where relop is =, <, <=, > or >=.\n\t(Parse_Def_File): Accept literal integer values.\n\t* gcc-interface/Make-lang.in: Add s-valint.o, s-valuns.o and\n\ts-valuti.o to the compiler object files.\n\nFrom-SVN: r203540", "tree": {"sha": "aa13585022d1953d243192e708c2700f2c32e5c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa13585022d1953d243192e708c2700f2c32e5c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5164151f87bf8872c5e0749dd30730bce79cb5b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5164151f87bf8872c5e0749dd30730bce79cb5b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5164151f87bf8872c5e0749dd30730bce79cb5b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5164151f87bf8872c5e0749dd30730bce79cb5b8/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0247964def38159afff19aeeb79880d8aaa63a05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0247964def38159afff19aeeb79880d8aaa63a05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0247964def38159afff19aeeb79880d8aaa63a05"}], "stats": {"total": 230, "additions": 192, "deletions": 38}, "files": [{"sha": "695f9a29e38ddf196cc9574972fcb7feb5fc9027", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5164151f87bf8872c5e0749dd30730bce79cb5b8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5164151f87bf8872c5e0749dd30730bce79cb5b8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5164151f87bf8872c5e0749dd30730bce79cb5b8", "patch": "@@ -1,3 +1,18 @@\n+2013-10-14  Vincent Celier  <celier@adacore.com>\n+\n+\t* errout.adb (Write_Error_Summary): Do not output the number\n+\tof lines when Main_Source_File is unknown.\n+\t(Output_Messages): Do not write the header when Main_Source_File is\n+\tunknown.\n+\n+2013-10-14  Vincent Celier  <celier@adacore.com>\n+\n+\t* prep.adb (Expression): Accept terms of the form 'symbol <relop>\n+\tinteger\", where relop is =, <, <=, > or >=.\n+\t(Parse_Def_File): Accept literal integer values.\n+\t* gcc-interface/Make-lang.in: Add s-valint.o, s-valuns.o and\n+\ts-valuti.o to the compiler object files.\n+\n 2013-10-14  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_prag.adb, exp_ch11.adb, s-exctab.adb: Minor reformatting."}, {"sha": "222dffc75f877d1a5f54fd6ecb1328b40b047a0e", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 46, "deletions": 27, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5164151f87bf8872c5e0749dd30730bce79cb5b8/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5164151f87bf8872c5e0749dd30730bce79cb5b8/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=5164151f87bf8872c5e0749dd30730bce79cb5b8", "patch": "@@ -1625,15 +1625,18 @@ package body Errout is\n             Set_Standard_Error;\n          end if;\n \n-         --  Message giving total number of lines\n+         --  Message giving total number of lines, only when Main_Source_Line\n+         --  is known.\n \n-         Write_Str (\" \");\n-         Write_Int (Num_Source_Lines (Main_Source_File));\n+         if Main_Source_File /= No_Source_File then\n+            Write_Str (\" \");\n+            Write_Int (Num_Source_Lines (Main_Source_File));\n \n-         if Num_Source_Lines (Main_Source_File) = 1 then\n-            Write_Str (\" line: \");\n-         else\n-            Write_Str (\" lines: \");\n+            if Num_Source_Lines (Main_Source_File) = 1 then\n+               Write_Str (\" line: \");\n+            else\n+               Write_Str (\" lines: \");\n+            end if;\n          end if;\n \n          if Total_Errors_Detected = 0 then\n@@ -1831,8 +1834,13 @@ package body Errout is\n \n                begin\n                   Write_Eol;\n-                  Write_Header (Sfile);\n-                  Write_Eol;\n+\n+                  --  Only write the header if Sfile is known\n+\n+                  if Sfile /= No_Source_File then\n+                     Write_Header (Sfile);\n+                     Write_Eol;\n+                  end if;\n \n                   --  Normally, we don't want an \"error messages from file\"\n                   --  message when listing the entire file, so we set the\n@@ -1847,28 +1855,33 @@ package body Errout is\n                      Current_Error_Source_File := Sfile;\n                   end if;\n \n-                  for N in 1 .. Last_Source_Line (Sfile) loop\n-                     while E /= No_Error_Msg\n-                       and then Errors.Table (E).Deleted\n-                     loop\n-                        E := Errors.Table (E).Next;\n-                     end loop;\n+                  --  Only output the listing if Sfile is known, to avoid\n+                  --  crashing the compiler.\n \n-                     Err_Flag :=\n-                       E /= No_Error_Msg\n-                         and then Errors.Table (E).Line = N\n-                         and then Errors.Table (E).Sfile = Sfile;\n+                  if Sfile /= No_Source_File then\n+                     for N in 1 .. Last_Source_Line (Sfile) loop\n+                        while E /= No_Error_Msg\n+                          and then Errors.Table (E).Deleted\n+                        loop\n+                           E := Errors.Table (E).Next;\n+                        end loop;\n \n-                     Output_Source_Line (N, Sfile, Err_Flag);\n+                        Err_Flag :=\n+                          E /= No_Error_Msg\n+                          and then Errors.Table (E).Line = N\n+                          and then Errors.Table (E).Sfile = Sfile;\n \n-                     if Err_Flag then\n-                        Output_Error_Msgs (E);\n+                        Output_Source_Line (N, Sfile, Err_Flag);\n \n-                        if not Debug_Flag_2 then\n-                           Write_Eol;\n+                        if Err_Flag then\n+                           Output_Error_Msgs (E);\n+\n+                           if not Debug_Flag_2 then\n+                              Write_Eol;\n+                           end if;\n                         end if;\n-                     end if;\n-                  end loop;\n+                     end loop;\n+                  end if;\n                end;\n             end if;\n          end loop;\n@@ -1917,7 +1930,13 @@ package body Errout is\n         and then (not Full_List or else Full_List_File_Name /= null)\n       then\n          Write_Eol;\n-         Write_Header (Main_Source_File);\n+\n+         --  Output the header only when Main_Source_File is known\n+\n+         if Main_Source_File /= No_Source_File then\n+            Write_Header (Main_Source_File);\n+         end if;\n+\n          E := First_Error_Msg;\n \n          --  Loop through error lines"}, {"sha": "74eff6646180ec17348390096a412a75c794acd8", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5164151f87bf8872c5e0749dd30730bce79cb5b8/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5164151f87bf8872c5e0749dd30730bce79cb5b8/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=5164151f87bf8872c5e0749dd30730bce79cb5b8", "patch": "@@ -371,6 +371,9 @@ GNAT_ADA_OBJS =\t\\\n  ada/s-traent.o\t\\\n  ada/s-unstyp.o\t\\\n  ada/s-utf_32.o\t\\\n+ ada/s-valint.o\t\\\n+ ada/s-valuns.o\t\\\n+ ada/s-valuti.o\t\\\n  ada/s-wchcnv.o\t\\\n  ada/s-wchcon.o\t\\\n  ada/s-wchjis.o\t\\"}, {"sha": "b48286e65d97cd2ded5ace506e335520c0a5235e", "filename": "gcc/ada/prep.adb", "status": "modified", "additions": 128, "deletions": 11, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5164151f87bf8872c5e0749dd30730bce79cb5b8/gcc%2Fada%2Fprep.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5164151f87bf8872c5e0749dd30730bce79cb5b8/gcc%2Fada%2Fprep.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprep.adb?ref=5164151f87bf8872c5e0749dd30730bce79cb5b8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2002-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2002-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,6 +33,7 @@ with Snames;   use Snames;\n with Sinput;\n with Stringt;  use Stringt;\n with Table;\n+with Uintp;    use Uintp;\n \n with GNAT.Heap_Sort_G;\n \n@@ -268,9 +269,14 @@ package body Prep is\n \n          --  Check the syntax of the value\n \n-         if Definition (Index + 1) /= '\"'\n-           or else Definition (Definition'Last) /= '\"'\n+         if Definition (Index + 1) = '\"'\n+           and then Definition (Definition'Last) = '\"'\n          then\n+            Result.Is_A_String := True;\n+\n+         else\n+            Result.Is_A_String := False;\n+\n             for J in Index + 1 .. Definition'Last loop\n                case Definition (J) is\n                   when '_' | '.' | '0' .. '9' | 'a' .. 'z' | 'A' .. 'Z' =>\n@@ -286,7 +292,6 @@ package body Prep is\n \n          --  And put the value in the result\n \n-         Result.Is_A_String := False;\n          Start_String;\n          Store_String_Chars (Definition (Index + 1 .. Definition'Last));\n          Result.Value := End_String;\n@@ -390,6 +395,8 @@ package body Prep is\n       Symbol_Value1    : String_Id;\n       Symbol_Value2    : String_Id;\n \n+      Relop : Token_Type;\n+\n    begin\n       --  Loop for each term\n \n@@ -447,12 +454,96 @@ package body Prep is\n                      Current_Result := Index_Of (Symbol_Name1) /= No_Symbol;\n                   end if;\n \n-               elsif Token = Tok_Equal then\n+               elsif\n+                 Token = Tok_Equal or else\n+                 Token = Tok_Less or else\n+                 Token = Tok_Less_Equal or else\n+                 Token = Tok_Greater or else\n+                 Token = Tok_Greater_Equal\n+               then\n+                  Relop := Token;\n                   Scan.all;\n-\n                   Change_Reserved_Keyword_To_Symbol;\n \n-                  if Token = Tok_Identifier then\n+                  if Token = Tok_Integer_Literal then\n+\n+                     --  symbol =  integer\n+                     --  symbol <  integer\n+                     --  symbol <= integer\n+                     --  symbol >  integer\n+                     --  symbol >= integer\n+\n+                     declare\n+                        Value : constant Int := UI_To_Int (Int_Literal_Value);\n+                        Data  : Symbol_Data;\n+                        Symbol_Value : Int;\n+                     begin\n+                        if Evaluation then\n+                           Symbol1 := Index_Of (Symbol_Name1);\n+\n+                           if Symbol1 = No_Symbol then\n+                              Error_Msg_Name_1 := Symbol_Name1;\n+                              Error_Msg (\"unknown symbol %\", Symbol_Pos1);\n+                              Symbol_Value1 := No_String;\n+\n+                           else\n+                              Data := Mapping.Table (Symbol1);\n+\n+                              if Data.Is_A_String then\n+                                 Error_Msg_Name_1 := Symbol_Name1;\n+                                 Error_Msg\n+                                   (\"symbol % value is not integer\",\n+                                    Symbol_Pos1);\n+\n+                              else\n+                                 begin\n+                                    String_To_Name_Buffer (Data.Value);\n+                                    Symbol_Value :=\n+                                      Int'Value (Name_Buffer (1 .. Name_Len));\n+\n+                                    case Relop is\n+                                       when Tok_Equal =>\n+                                          Current_Result :=\n+                                            Symbol_Value = Value;\n+\n+                                       when Tok_Less =>\n+                                          Current_Result :=\n+                                            Symbol_Value < Value;\n+\n+                                       when Tok_Less_Equal =>\n+                                          Current_Result :=\n+                                            Symbol_Value <= Value;\n+\n+                                       when Tok_Greater =>\n+                                          Current_Result :=\n+                                            Symbol_Value > Value;\n+\n+                                       when Tok_Greater_Equal =>\n+                                          Current_Result :=\n+                                            Symbol_Value >= Value;\n+\n+                                       when others =>\n+                                          null;\n+                                    end case;\n+\n+                                 exception\n+                                    when Constraint_Error =>\n+                                       Error_Msg_Name_1 := Symbol_Name1;\n+                                       Error_Msg\n+                                         (\"symbol % value is not integer\",\n+                                          Symbol_Pos1);\n+                                 end;\n+                              end if;\n+                           end if;\n+                        end if;\n+\n+                        Scan.all;\n+                     end;\n+\n+                  elsif Relop /= Tok_Equal then\n+                     Error_Msg (\"number expected\", Token_Ptr);\n+\n+                  elsif Token = Tok_Identifier then\n \n                      --  symbol = symbol\n \n@@ -535,7 +626,8 @@ package body Prep is\n \n                   else\n                      Error_Msg\n-                       (\"symbol or literal string expected\", Token_Ptr);\n+                       (\"literal integer, symbol or literal string expected\",\n+                        Token_Ptr);\n                   end if;\n \n                else\n@@ -914,7 +1006,33 @@ package body Prep is\n \n             Scan.all;\n \n-            if Token = Tok_String_Literal then\n+            if Token = Tok_Integer_Literal then\n+               declare\n+                  Ptr : Source_Ptr := Token_Ptr;\n+\n+               begin\n+                  Start_String;\n+\n+                  while Ptr < Scan_Ptr loop\n+                     Store_String_Char (Sinput.Source (Ptr));\n+                     Ptr := Ptr + 1;\n+                  end loop;\n+\n+                  Data := (Symbol              => Symbol_Name,\n+                           Original            => Original_Name,\n+                           On_The_Command_Line => False,\n+                           Is_A_String         => False,\n+                           Value               => End_String);\n+               end;\n+\n+               Scan.all;\n+\n+               if Token /= Tok_End_Of_Line and then Token /= Tok_EOF then\n+                  Error_Msg (\"extraneous text in definition\", Token_Ptr);\n+                  goto Cleanup;\n+               end if;\n+\n+            elsif Token = Tok_String_Literal then\n                Data := (Symbol              => Symbol_Name,\n                         Original            => Original_Name,\n                         On_The_Command_Line => False,\n@@ -1088,8 +1206,7 @@ package body Prep is\n    begin\n       Start_Of_Processing := Scan_Ptr;\n \n-      --  We need to call Scan for the first time, because Initialize_Scanner\n-      --  is no longer doing it.\n+      --  First a call to Scan, because Initialize_Scanner is not doing it\n \n       Scan.all;\n "}]}