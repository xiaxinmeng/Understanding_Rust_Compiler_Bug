{"sha": "94252f4bcc0a3f487b804ce535cb77b8bef4db83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQyNTJmNGJjYzBhM2Y0ODdiODA0Y2U1MzVjYjc3YjhiZWY0ZGI4Mw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-02-09T08:19:58Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-02-09T08:19:58Z"}, "message": "libgo: Update to weekly.2012-02-07.\n\nFrom-SVN: r184034", "tree": {"sha": "7ca86535c5a6b99d4cc432ba5cfddabc5ee4ea16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ca86535c5a6b99d4cc432ba5cfddabc5ee4ea16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94252f4bcc0a3f487b804ce535cb77b8bef4db83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94252f4bcc0a3f487b804ce535cb77b8bef4db83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94252f4bcc0a3f487b804ce535cb77b8bef4db83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94252f4bcc0a3f487b804ce535cb77b8bef4db83/comments", "author": null, "committer": null, "parents": [{"sha": "cd6368115dbd75d9187877097c48a0d8d4c04fd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd6368115dbd75d9187877097c48a0d8d4c04fd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd6368115dbd75d9187877097c48a0d8d4c04fd4"}], "stats": {"total": 8048, "additions": 4340, "deletions": 3708}, "files": [{"sha": "2cbb86ec626c72390965b8e2db8405368608028b", "filename": "gcc/testsuite/go.test/test/chan/select2.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fselect2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fselect2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fselect2.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -35,14 +35,17 @@ func main() {\n \tgo sender(c, 100000)\n \treceiver(c, dummy, 100000)\n \truntime.GC()\n-\truntime.MemStats.Alloc = 0\n+\tmemstats := new(runtime.MemStats)\n+\truntime.ReadMemStats(memstats)\n+\talloc := memstats.Alloc\n \n \t// second time shouldn't increase footprint by much\n \tgo sender(c, 100000)\n \treceiver(c, dummy, 100000)\n \truntime.GC()\n+\truntime.ReadMemStats(memstats)\n \n-\tif runtime.MemStats.Alloc > 1e5 {\n-\t\tprintln(\"BUG: too much memory for 100,000 selects:\", runtime.MemStats.Alloc)\n+\tif memstats.Alloc-alloc > 1e5 {\n+\t\tprintln(\"BUG: too much memory for 100,000 selects:\", memstats.Alloc-alloc)\n \t}\n }"}, {"sha": "772f9810daaba053c60da480ede9e01b7874a531", "filename": "gcc/testsuite/go.test/test/gc2.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fgc2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fgc2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fgc2.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -19,7 +19,9 @@ import (\n \n func main() {\n \tconst N = 10000\n-\tst := runtime.MemStats\n+\tst := new(runtime.MemStats)\n+\tmemstats := new(runtime.MemStats)\n+\truntime.ReadMemStats(st)\n \tfor i := 0; i < N; i++ {\n \t\tc := make(chan int, 10)\n \t\t_ = c\n@@ -33,8 +35,8 @@ func main() {\n \t\t}\n \t}\n \n-\truntime.UpdateMemStats()\n-\tobj := runtime.MemStats.HeapObjects - st.HeapObjects\n+\truntime.ReadMemStats(memstats)\n+\tobj := memstats.HeapObjects - st.HeapObjects\n \tif obj > N/5 {\n \t\tfmt.Println(\"too many objects left:\", obj)\n \t\tos.Exit(1)"}, {"sha": "0f7f0b267a035ca1a1384f1beaac4dcec5ac1d00", "filename": "gcc/testsuite/go.test/test/malloc1.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmalloc1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmalloc1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmalloc1.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -17,9 +17,10 @@ import (\n var chatty = flag.Bool(\"v\", false, \"chatty\")\n \n func main() {\n+\tmemstats := new(runtime.MemStats)\n \truntime.Free(runtime.Alloc(1))\n-\truntime.UpdateMemStats()\n+\truntime.ReadMemStats(memstats)\n \tif *chatty {\n-\t\tfmt.Printf(\"%+v %v\\n\", runtime.MemStats, uint64(0))\n+\t\tfmt.Printf(\"%+v %v\\n\", memstats, uint64(0))\n \t}\n }"}, {"sha": "69d07cec5d2f93b2941c8782abf0da0dcac804ee", "filename": "gcc/testsuite/go.test/test/mallocrand.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmallocrand.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmallocrand.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmallocrand.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -21,8 +21,9 @@ var footprint uint64\n var allocated uint64\n \n func bigger() {\n-\truntime.UpdateMemStats()\n-\tif f := runtime.MemStats.Sys; footprint < f {\n+\tmemstats := new(runtime.MemStats)\n+\truntime.ReadMemStats(memstats)\n+\tif f := memstats.Sys; footprint < f {\n \t\tfootprint = f\n \t\tif *chatty {\n \t\t\tprintln(\"Footprint\", footprint, \" for \", allocated)"}, {"sha": "4188da9b833519c1b8d46608567a81a616857336", "filename": "gcc/testsuite/go.test/test/mallocrep.go", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmallocrep.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmallocrep.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmallocrep.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -16,10 +16,12 @@ import (\n var chatty = flag.Bool(\"v\", false, \"chatty\")\n \n var oldsys uint64\n+var memstats runtime.MemStats\n \n func bigger() {\n-\truntime.UpdateMemStats()\n-\tif st := runtime.MemStats; oldsys < st.Sys {\n+\tst := &memstats\n+\truntime.ReadMemStats(st)\n+\tif oldsys < st.Sys {\n \t\toldsys = st.Sys\n \t\tif *chatty {\n \t\t\tprintln(st.Sys, \" system bytes for \", st.Alloc, \" Go bytes\")\n@@ -32,26 +34,26 @@ func bigger() {\n }\n \n func main() {\n-\truntime.GC()               // clean up garbage from init\n-\truntime.UpdateMemStats()   // first call can do some allocations\n-\truntime.MemProfileRate = 0 // disable profiler\n-\truntime.MemStats.Alloc = 0 // ignore stacks\n+\truntime.GC()                    // clean up garbage from init\n+\truntime.ReadMemStats(&memstats) // first call can do some allocations\n+\truntime.MemProfileRate = 0      // disable profiler\n+\tstacks := memstats.Alloc        // ignore stacks\n \tflag.Parse()\n \tfor i := 0; i < 1<<7; i++ {\n \t\tfor j := 1; j <= 1<<22; j <<= 1 {\n \t\t\tif i == 0 && *chatty {\n \t\t\t\tprintln(\"First alloc:\", j)\n \t\t\t}\n-\t\t\tif a := runtime.MemStats.Alloc; a != 0 {\n+\t\t\tif a := memstats.Alloc - stacks; a != 0 {\n \t\t\t\tprintln(\"no allocations but stats report\", a, \"bytes allocated\")\n \t\t\t\tpanic(\"fail\")\n \t\t\t}\n \t\t\tb := runtime.Alloc(uintptr(j))\n-\t\t\truntime.UpdateMemStats()\n-\t\t\tduring := runtime.MemStats.Alloc\n+\t\t\truntime.ReadMemStats(&memstats)\n+\t\t\tduring := memstats.Alloc - stacks\n \t\t\truntime.Free(b)\n-\t\t\truntime.UpdateMemStats()\n-\t\t\tif a := runtime.MemStats.Alloc; a != 0 {\n+\t\t\truntime.ReadMemStats(&memstats)\n+\t\t\tif a := memstats.Alloc - stacks; a != 0 {\n \t\t\t\tprintln(\"allocated \", j, \": wrong stats: during=\", during, \" after=\", a, \" (want 0)\")\n \t\t\t\tpanic(\"fail\")\n \t\t\t}"}, {"sha": "f9d7286efd9d3a8aa59c64d701db484799ce598c", "filename": "gcc/testsuite/go.test/test/mallocrep1.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmallocrep1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmallocrep1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fmallocrep1.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -20,7 +20,7 @@ var reverse = flag.Bool(\"r\", false, \"reverse\")\n var longtest = flag.Bool(\"l\", false, \"long test\")\n \n var b []*byte\n-var stats = &runtime.MemStats\n+var stats = new(runtime.MemStats)\n \n func OkAmount(size, n uintptr) bool {\n \tif n < size {\n@@ -42,7 +42,7 @@ func AllocAndFree(size, count int) {\n \tif *chatty {\n \t\tfmt.Printf(\"size=%d count=%d ...\\n\", size, count)\n \t}\n-\truntime.UpdateMemStats()\n+\truntime.ReadMemStats(stats)\n \tn1 := stats.Alloc\n \tfor i := 0; i < count; i++ {\n \t\tb[i] = runtime.Alloc(uintptr(size))\n@@ -51,13 +51,13 @@ func AllocAndFree(size, count int) {\n \t\t\tprintln(\"lookup failed: got\", base, n, \"for\", b[i])\n \t\t\tpanic(\"fail\")\n \t\t}\n-\t\truntime.UpdateMemStats()\n+\t\truntime.ReadMemStats(stats)\n \t\tif stats.Sys > 1e9 {\n \t\t\tprintln(\"too much memory allocated\")\n \t\t\tpanic(\"fail\")\n \t\t}\n \t}\n-\truntime.UpdateMemStats()\n+\truntime.ReadMemStats(stats)\n \tn2 := stats.Alloc\n \tif *chatty {\n \t\tfmt.Printf(\"size=%d count=%d stats=%+v\\n\", size, count, *stats)\n@@ -75,17 +75,17 @@ func AllocAndFree(size, count int) {\n \t\t\tpanic(\"fail\")\n \t\t}\n \t\truntime.Free(b[i])\n-\t\truntime.UpdateMemStats()\n+\t\truntime.ReadMemStats(stats)\n \t\tif stats.Alloc != uint64(alloc-n) {\n \t\t\tprintln(\"free alloc got\", stats.Alloc, \"expected\", alloc-n, \"after free of\", n)\n \t\t\tpanic(\"fail\")\n \t\t}\n-\t\tif runtime.MemStats.Sys > 1e9 {\n+\t\tif stats.Sys > 1e9 {\n \t\t\tprintln(\"too much memory allocated\")\n \t\t\tpanic(\"fail\")\n \t\t}\n \t}\n-\truntime.UpdateMemStats()\n+\truntime.ReadMemStats(stats)\n \tn4 := stats.Alloc\n \n \tif *chatty {"}, {"sha": "569aa9c8f93e25f7499138601f453a9450b9f66a", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -1,4 +1,4 @@\n-1107a7d3cb07\n+52ba9506bd99\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "300d16bf263f3266cb7c8d01f4fa95372caf335d", "filename": "libgo/Makefile.am", "status": "modified", "additions": 19, "deletions": 59, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -226,6 +226,7 @@ toolexeclibgoexp_DATA = \\\n \t$(exp_inotify_gox) \\\n \texp/norm.gox \\\n \texp/proxy.gox \\\n+\texp/signal.gox \\\n \texp/terminal.gox \\\n \texp/types.gox \\\n \texp/utf8string.gox\n@@ -257,13 +258,11 @@ toolexeclibgohtml_DATA = \\\n toolexeclibgoimagedir = $(toolexeclibgodir)/image\n \n toolexeclibgoimage_DATA = \\\n-\timage/bmp.gox \\\n \timage/color.gox \\\n \timage/draw.gox \\\n \timage/gif.gox \\\n \timage/jpeg.gox \\\n-\timage/png.gox \\\n-\timage/tiff.gox\n+\timage/png.gox\n \n toolexeclibgoindexdir = $(toolexeclibgodir)/index\n \n@@ -327,8 +326,7 @@ toolexeclibgoosdir = $(toolexeclibgodir)/os\n \n toolexeclibgoos_DATA = \\\n \tos/exec.gox \\\n-\tos/user.gox \\\n-\tos/signal.gox\n+\tos/user.gox\n \n toolexeclibgopathdir = $(toolexeclibgodir)/path\n \n@@ -949,7 +947,6 @@ go_crypto_cipher_files = \\\n \tgo/crypto/cipher/cipher.go \\\n \tgo/crypto/cipher/ctr.go \\\n \tgo/crypto/cipher/io.go \\\n-\tgo/crypto/cipher/ocfb.go \\\n \tgo/crypto/cipher/ofb.go\n go_crypto_des_files = \\\n \tgo/crypto/des/block.go \\\n@@ -1107,6 +1104,8 @@ go_exp_proxy_files = \\\n \tgo/exp/proxy/per_host.go \\\n \tgo/exp/proxy/proxy.go \\\n \tgo/exp/proxy/socks5.go\n+go_exp_signal_files = \\\n+\tgo/exp/signal/signal.go\n go_exp_terminal_files = \\\n \tgo/exp/terminal/terminal.go \\\n \tgo/exp/terminal/util.go\n@@ -1179,9 +1178,6 @@ go_html_template_files = \\\n \tgo/html/template/transition.go \\\n \tgo/html/template/url.go\n \n-go_image_bmp_files = \\\n-\tgo/image/bmp/reader.go\n-\n go_image_color_files = \\\n \tgo/image/color/color.go \\\n \tgo/image/color/ycbcr.go\n@@ -1203,12 +1199,6 @@ go_image_png_files = \\\n \tgo/image/png/reader.go \\\n \tgo/image/png/writer.go\n \n-go_image_tiff_files = \\\n-\tgo/image/tiff/buffer.go \\\n-\tgo/image/tiff/compress.go \\\n-\tgo/image/tiff/consts.go \\\n-\tgo/image/tiff/reader.go\n-\n go_index_suffixarray_files = \\\n \tgo/index/suffixarray/qsufsort.go \\\n \tgo/index/suffixarray/suffixarray.go\n@@ -1317,9 +1307,6 @@ go_os_user_files = \\\n \tgo/os/user/user.go \\\n \tgo/os/user/lookup_unix.go\n \n-go_os_signal_files = \\\n-\tgo/os/signal/signal.go\n-\n go_path_filepath_files = \\\n \tgo/path/filepath/match.go \\\n \tgo/path/filepath/path.go \\\n@@ -1673,6 +1660,7 @@ libgo_go_objs = \\\n \texp/html.lo \\\n \texp/norm.lo \\\n \texp/proxy.lo \\\n+\texp/signal.lo \\\n \texp/terminal.lo \\\n \texp/types.lo \\\n \texp/utf8string.lo \\\n@@ -1693,13 +1681,11 @@ libgo_go_objs = \\\n \tnet/http/httptest.lo \\\n \tnet/http/httputil.lo \\\n \tnet/http/pprof.lo \\\n-\timage/bmp.lo \\\n \timage/color.lo \\\n \timage/draw.lo \\\n \timage/gif.lo \\\n \timage/jpeg.lo \\\n \timage/png.lo \\\n-\timage/tiff.lo \\\n \tindex/suffixarray.lo \\\n \tio/ioutil.lo \\\n \tlog/syslog.lo \\\n@@ -1720,7 +1706,6 @@ libgo_go_objs = \\\n \told/template.lo \\\n \t$(os_lib_inotify_lo) \\\n \tos/user.lo \\\n-\tos/signal.lo \\\n \tpath/filepath.lo \\\n \tregexp/syntax.lo \\\n \tnet/rpc/jsonrpc.lo \\\n@@ -2607,6 +2592,16 @@ exp/proxy/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/proxy/check\n \n+@go_include@ exp/signal.lo.dep\n+exp/signal.lo.dep: $(go_exp_signal_files)\n+\t$(BUILDDEPS)\n+exp/signal.lo: $(go_exp_signal_files)\n+\t$(BUILDPACKAGE)\n+exp/signal/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/signal\n+\t@$(CHECK)\n+.PHONY: exp/signal/check\n+\n @go_include@ exp/terminal.lo.dep\n exp/terminal.lo.dep: $(go_exp_terminal_files)\n \t$(BUILDDEPS)\n@@ -2776,16 +2771,6 @@ hash/fnv/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: hash/fnv/check\n \n-@go_include@ image/bmp.lo.dep\n-image/bmp.lo.dep: $(go_image_bmp_files)\n-\t$(BUILDDEPS)\n-image/bmp.lo: $(go_image_bmp_files)\n-\t$(BUILDPACKAGE)\n-image/bmp/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) image/bmp\n-\t@$(CHECK)\n-.PHONY: image/bmp/check\n-\n @go_include@ image/color.lo.dep\n image/color.lo.dep: $(go_image_color_files)\n \t$(BUILDDEPS)\n@@ -2836,16 +2821,6 @@ image/png/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: image/png/check\n \n-@go_include@ image/tiff.lo.dep\n-image/tiff.lo.dep: $(go_image_tiff_files)\n-\t$(BUILDDEPS)\n-image/tiff.lo: $(go_image_tiff_files)\n-\t$(BUILDPACKAGE)\n-image/tiff/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) image/tiff\n-\t@$(CHECK)\n-.PHONY: image/tiff/check\n-\n @go_include@ index/suffixarray.lo.dep\n index/suffixarray.lo.dep: $(go_index_suffixarray_files)\n \t$(BUILDDEPS)\n@@ -3088,16 +3063,6 @@ os/user/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: os/user/check\n \n-@go_include@ os/signal.lo.dep\n-os/signal.lo.dep: $(go_os_signal_files)\n-\t$(BUILDDEPS)\n-os/signal.lo: $(go_os_signal_files)\n-\t$(BUILDPACKAGE)\n-os/signal/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) os/signal\n-\t@$(CHECK)\n-.PHONY: os/signal/check\n-\n @go_include@ path/filepath.lo.dep\n path/filepath.lo.dep: $(go_path_filepath_files)\n \t$(BUILDDEPS)\n@@ -3412,6 +3377,8 @@ exp/norm.gox: exp/norm.lo\n \t$(BUILDGOX)\n exp/proxy.gox: exp/proxy.lo\n \t$(BUILDGOX)\n+exp/signal.gox: exp/signal.lo\n+\t$(BUILDGOX)\n exp/terminal.gox: exp/terminal.lo\n \t$(BUILDGOX)\n exp/types.gox: exp/types.lo\n@@ -3446,8 +3413,6 @@ hash/crc64.gox: hash/crc64.lo\n hash/fnv.gox: hash/fnv.lo\n \t$(BUILDGOX)\n \n-image/bmp.gox: image/bmp.lo\n-\t$(BUILDGOX)\n image/color.gox: image/color.lo\n \t$(BUILDGOX)\n image/draw.gox: image/draw.lo\n@@ -3458,8 +3423,6 @@ image/jpeg.gox: image/jpeg.lo\n \t$(BUILDGOX)\n image/png.gox: image/png.lo\n \t$(BUILDGOX)\n-image/tiff.gox: image/tiff.lo\n-\t$(BUILDGOX)\n \n index/suffixarray.gox: index/suffixarray.lo\n \t$(BUILDGOX)\n@@ -3518,8 +3481,6 @@ os/exec.gox: os/exec.lo\n \t$(BUILDGOX)\n os/user.gox: os/user.lo\n \t$(BUILDGOX)\n-os/signal.gox: os/signal.lo\n-\t$(BUILDGOX)\n \n path/filepath.gox: path/filepath.lo\n \t$(BUILDGOX)\n@@ -3637,6 +3598,7 @@ TEST_PACKAGES = \\\n \t$(exp_inotify_check) \\\n \texp/norm/check \\\n \texp/proxy/check \\\n+\texp/signal/check \\\n \texp/terminal/check \\\n \texp/utf8string/check \\\n \thtml/template/check \\\n@@ -3656,7 +3618,6 @@ TEST_PACKAGES = \\\n \timage/draw/check \\\n \timage/jpeg/check \\\n \timage/png/check \\\n-\timage/tiff/check \\\n \tindex/suffixarray/check \\\n \tio/ioutil/check \\\n \tlog/syslog/check \\\n@@ -3679,7 +3640,6 @@ TEST_PACKAGES = \\\n \told/template/check \\\n \tos/exec/check \\\n \tos/user/check \\\n-\tos/signal/check \\\n \tpath/filepath/check \\\n \tregexp/syntax/check \\\n \tsync/atomic/check \\"}, {"sha": "797cccac212457c363e2c37bf5793f2ad37c3b8e", "filename": "libgo/Makefile.in", "status": "modified", "additions": 40, "deletions": 79, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -154,26 +154,26 @@ am__DEPENDENCIES_2 = bufio/bufio.lo bytes/bytes.lo bytes/index.lo \\\n \tencoding/base32.lo encoding/base64.lo encoding/binary.lo \\\n \tencoding/csv.lo encoding/gob.lo encoding/hex.lo \\\n \tencoding/json.lo encoding/pem.lo encoding/xml.lo exp/ebnf.lo \\\n-\texp/html.lo exp/norm.lo exp/proxy.lo exp/terminal.lo \\\n-\texp/types.lo exp/utf8string.lo html/template.lo go/ast.lo \\\n-\tgo/build.lo go/doc.lo go/parser.lo go/printer.lo go/scanner.lo \\\n-\tgo/token.lo hash/adler32.lo hash/crc32.lo hash/crc64.lo \\\n-\thash/fnv.lo net/http/cgi.lo net/http/fcgi.lo \\\n-\tnet/http/httptest.lo net/http/httputil.lo net/http/pprof.lo \\\n-\timage/bmp.lo image/color.lo image/draw.lo image/gif.lo \\\n-\timage/jpeg.lo image/png.lo image/tiff.lo index/suffixarray.lo \\\n-\tio/ioutil.lo log/syslog.lo log/syslog/syslog_c.lo math/big.lo \\\n-\tmath/cmplx.lo math/rand.lo mime/mime.lo mime/multipart.lo \\\n-\tnet/http.lo net/mail.lo net/rpc.lo net/smtp.lo \\\n-\tnet/textproto.lo net/url.lo old/netchan.lo old/regexp.lo \\\n-\told/template.lo $(am__DEPENDENCIES_1) os/user.lo os/signal.lo \\\n-\tpath/filepath.lo regexp/syntax.lo net/rpc/jsonrpc.lo \\\n-\truntime/debug.lo runtime/pprof.lo sync/atomic.lo \\\n-\tsync/atomic_c.lo syscall/syscall.lo syscall/errno.lo \\\n-\tsyscall/wait.lo text/scanner.lo text/tabwriter.lo \\\n-\ttext/template.lo text/template/parse.lo testing/testing.lo \\\n-\ttesting/iotest.lo testing/quick.lo testing/script.lo \\\n-\tunicode/utf16.lo unicode/utf8.lo\n+\texp/html.lo exp/norm.lo exp/proxy.lo exp/signal.lo \\\n+\texp/terminal.lo exp/types.lo exp/utf8string.lo \\\n+\thtml/template.lo go/ast.lo go/build.lo go/doc.lo go/parser.lo \\\n+\tgo/printer.lo go/scanner.lo go/token.lo hash/adler32.lo \\\n+\thash/crc32.lo hash/crc64.lo hash/fnv.lo net/http/cgi.lo \\\n+\tnet/http/fcgi.lo net/http/httptest.lo net/http/httputil.lo \\\n+\tnet/http/pprof.lo image/color.lo image/draw.lo image/gif.lo \\\n+\timage/jpeg.lo image/png.lo index/suffixarray.lo io/ioutil.lo \\\n+\tlog/syslog.lo log/syslog/syslog_c.lo math/big.lo math/cmplx.lo \\\n+\tmath/rand.lo mime/mime.lo mime/multipart.lo net/http.lo \\\n+\tnet/mail.lo net/rpc.lo net/smtp.lo net/textproto.lo net/url.lo \\\n+\told/netchan.lo old/regexp.lo old/template.lo \\\n+\t$(am__DEPENDENCIES_1) os/user.lo path/filepath.lo \\\n+\tregexp/syntax.lo net/rpc/jsonrpc.lo runtime/debug.lo \\\n+\truntime/pprof.lo sync/atomic.lo sync/atomic_c.lo \\\n+\tsyscall/syscall.lo syscall/errno.lo syscall/wait.lo \\\n+\ttext/scanner.lo text/tabwriter.lo text/template.lo \\\n+\ttext/template/parse.lo testing/testing.lo testing/iotest.lo \\\n+\ttesting/quick.lo testing/script.lo unicode/utf16.lo \\\n+\tunicode/utf8.lo\n libgo_la_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1)\n@@ -679,6 +679,7 @@ toolexeclibgoexp_DATA = \\\n \t$(exp_inotify_gox) \\\n \texp/norm.gox \\\n \texp/proxy.gox \\\n+\texp/signal.gox \\\n \texp/terminal.gox \\\n \texp/types.gox \\\n \texp/utf8string.gox\n@@ -706,13 +707,11 @@ toolexeclibgohtml_DATA = \\\n \n toolexeclibgoimagedir = $(toolexeclibgodir)/image\n toolexeclibgoimage_DATA = \\\n-\timage/bmp.gox \\\n \timage/color.gox \\\n \timage/draw.gox \\\n \timage/gif.gox \\\n \timage/jpeg.gox \\\n-\timage/png.gox \\\n-\timage/tiff.gox\n+\timage/png.gox\n \n toolexeclibgoindexdir = $(toolexeclibgodir)/index\n toolexeclibgoindex_DATA = \\\n@@ -766,8 +765,7 @@ toolexeclibgoold_DATA = \\\n toolexeclibgoosdir = $(toolexeclibgodir)/os\n toolexeclibgoos_DATA = \\\n \tos/exec.gox \\\n-\tos/user.gox \\\n-\tos/signal.gox\n+\tos/user.gox\n \n toolexeclibgopathdir = $(toolexeclibgodir)/path\n toolexeclibgopath_DATA = \\\n@@ -1253,7 +1251,6 @@ go_crypto_cipher_files = \\\n \tgo/crypto/cipher/cipher.go \\\n \tgo/crypto/cipher/ctr.go \\\n \tgo/crypto/cipher/io.go \\\n-\tgo/crypto/cipher/ocfb.go \\\n \tgo/crypto/cipher/ofb.go\n \n go_crypto_des_files = \\\n@@ -1445,6 +1442,9 @@ go_exp_proxy_files = \\\n \tgo/exp/proxy/proxy.go \\\n \tgo/exp/proxy/socks5.go\n \n+go_exp_signal_files = \\\n+\tgo/exp/signal/signal.go\n+\n go_exp_terminal_files = \\\n \tgo/exp/terminal/terminal.go \\\n \tgo/exp/terminal/util.go\n@@ -1528,9 +1528,6 @@ go_html_template_files = \\\n \tgo/html/template/transition.go \\\n \tgo/html/template/url.go\n \n-go_image_bmp_files = \\\n-\tgo/image/bmp/reader.go\n-\n go_image_color_files = \\\n \tgo/image/color/color.go \\\n \tgo/image/color/ycbcr.go\n@@ -1552,12 +1549,6 @@ go_image_png_files = \\\n \tgo/image/png/reader.go \\\n \tgo/image/png/writer.go\n \n-go_image_tiff_files = \\\n-\tgo/image/tiff/buffer.go \\\n-\tgo/image/tiff/compress.go \\\n-\tgo/image/tiff/consts.go \\\n-\tgo/image/tiff/reader.go\n-\n go_index_suffixarray_files = \\\n \tgo/index/suffixarray/qsufsort.go \\\n \tgo/index/suffixarray/suffixarray.go\n@@ -1677,9 +1668,6 @@ go_os_user_files = \\\n \tgo/os/user/user.go \\\n \tgo/os/user/lookup_unix.go\n \n-go_os_signal_files = \\\n-\tgo/os/signal/signal.go\n-\n go_path_filepath_files = \\\n \tgo/path/filepath/match.go \\\n \tgo/path/filepath/path.go \\\n@@ -1924,6 +1912,7 @@ libgo_go_objs = \\\n \texp/html.lo \\\n \texp/norm.lo \\\n \texp/proxy.lo \\\n+\texp/signal.lo \\\n \texp/terminal.lo \\\n \texp/types.lo \\\n \texp/utf8string.lo \\\n@@ -1944,13 +1933,11 @@ libgo_go_objs = \\\n \tnet/http/httptest.lo \\\n \tnet/http/httputil.lo \\\n \tnet/http/pprof.lo \\\n-\timage/bmp.lo \\\n \timage/color.lo \\\n \timage/draw.lo \\\n \timage/gif.lo \\\n \timage/jpeg.lo \\\n \timage/png.lo \\\n-\timage/tiff.lo \\\n \tindex/suffixarray.lo \\\n \tio/ioutil.lo \\\n \tlog/syslog.lo \\\n@@ -1971,7 +1958,6 @@ libgo_go_objs = \\\n \told/template.lo \\\n \t$(os_lib_inotify_lo) \\\n \tos/user.lo \\\n-\tos/signal.lo \\\n \tpath/filepath.lo \\\n \tregexp/syntax.lo \\\n \tnet/rpc/jsonrpc.lo \\\n@@ -2175,6 +2161,7 @@ TEST_PACKAGES = \\\n \t$(exp_inotify_check) \\\n \texp/norm/check \\\n \texp/proxy/check \\\n+\texp/signal/check \\\n \texp/terminal/check \\\n \texp/utf8string/check \\\n \thtml/template/check \\\n@@ -2194,7 +2181,6 @@ TEST_PACKAGES = \\\n \timage/draw/check \\\n \timage/jpeg/check \\\n \timage/png/check \\\n-\timage/tiff/check \\\n \tindex/suffixarray/check \\\n \tio/ioutil/check \\\n \tlog/syslog/check \\\n@@ -2217,7 +2203,6 @@ TEST_PACKAGES = \\\n \told/template/check \\\n \tos/exec/check \\\n \tos/user/check \\\n-\tos/signal/check \\\n \tpath/filepath/check \\\n \tregexp/syntax/check \\\n \tsync/atomic/check \\\n@@ -5171,6 +5156,16 @@ exp/proxy/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/proxy/check\n \n+@go_include@ exp/signal.lo.dep\n+exp/signal.lo.dep: $(go_exp_signal_files)\n+\t$(BUILDDEPS)\n+exp/signal.lo: $(go_exp_signal_files)\n+\t$(BUILDPACKAGE)\n+exp/signal/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/signal\n+\t@$(CHECK)\n+.PHONY: exp/signal/check\n+\n @go_include@ exp/terminal.lo.dep\n exp/terminal.lo.dep: $(go_exp_terminal_files)\n \t$(BUILDDEPS)\n@@ -5340,16 +5335,6 @@ hash/fnv/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: hash/fnv/check\n \n-@go_include@ image/bmp.lo.dep\n-image/bmp.lo.dep: $(go_image_bmp_files)\n-\t$(BUILDDEPS)\n-image/bmp.lo: $(go_image_bmp_files)\n-\t$(BUILDPACKAGE)\n-image/bmp/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) image/bmp\n-\t@$(CHECK)\n-.PHONY: image/bmp/check\n-\n @go_include@ image/color.lo.dep\n image/color.lo.dep: $(go_image_color_files)\n \t$(BUILDDEPS)\n@@ -5400,16 +5385,6 @@ image/png/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: image/png/check\n \n-@go_include@ image/tiff.lo.dep\n-image/tiff.lo.dep: $(go_image_tiff_files)\n-\t$(BUILDDEPS)\n-image/tiff.lo: $(go_image_tiff_files)\n-\t$(BUILDPACKAGE)\n-image/tiff/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) image/tiff\n-\t@$(CHECK)\n-.PHONY: image/tiff/check\n-\n @go_include@ index/suffixarray.lo.dep\n index/suffixarray.lo.dep: $(go_index_suffixarray_files)\n \t$(BUILDDEPS)\n@@ -5652,16 +5627,6 @@ os/user/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: os/user/check\n \n-@go_include@ os/signal.lo.dep\n-os/signal.lo.dep: $(go_os_signal_files)\n-\t$(BUILDDEPS)\n-os/signal.lo: $(go_os_signal_files)\n-\t$(BUILDPACKAGE)\n-os/signal/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) os/signal\n-\t@$(CHECK)\n-.PHONY: os/signal/check\n-\n @go_include@ path/filepath.lo.dep\n path/filepath.lo.dep: $(go_path_filepath_files)\n \t$(BUILDDEPS)\n@@ -5971,6 +5936,8 @@ exp/norm.gox: exp/norm.lo\n \t$(BUILDGOX)\n exp/proxy.gox: exp/proxy.lo\n \t$(BUILDGOX)\n+exp/signal.gox: exp/signal.lo\n+\t$(BUILDGOX)\n exp/terminal.gox: exp/terminal.lo\n \t$(BUILDGOX)\n exp/types.gox: exp/types.lo\n@@ -6005,8 +5972,6 @@ hash/crc64.gox: hash/crc64.lo\n hash/fnv.gox: hash/fnv.lo\n \t$(BUILDGOX)\n \n-image/bmp.gox: image/bmp.lo\n-\t$(BUILDGOX)\n image/color.gox: image/color.lo\n \t$(BUILDGOX)\n image/draw.gox: image/draw.lo\n@@ -6017,8 +5982,6 @@ image/jpeg.gox: image/jpeg.lo\n \t$(BUILDGOX)\n image/png.gox: image/png.lo\n \t$(BUILDGOX)\n-image/tiff.gox: image/tiff.lo\n-\t$(BUILDGOX)\n \n index/suffixarray.gox: index/suffixarray.lo\n \t$(BUILDGOX)\n@@ -6077,8 +6040,6 @@ os/exec.gox: os/exec.lo\n \t$(BUILDGOX)\n os/user.gox: os/user.lo\n \t$(BUILDGOX)\n-os/signal.gox: os/signal.lo\n-\t$(BUILDGOX)\n \n path/filepath.gox: path/filepath.lo\n \t$(BUILDGOX)"}, {"sha": "c3009869b60a0d17d12fe49f27246c4a7625e7b1", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -117,7 +117,7 @@ func (rc *ReadCloser) Close() error {\n }\n \n // Open returns a ReadCloser that provides access to the File's contents.\n-// It is safe to Open and Read from files concurrently.\n+// Multiple files may be read concurrently.\n func (f *File) Open() (rc io.ReadCloser, err error) {\n \tbodyOffset, err := f.findBodyOffset()\n \tif err != nil {"}, {"sha": "935860e791efdd44b4229b6208e6d999afcf8b61", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -69,8 +69,23 @@ var tests = []ZipTest{\n \t\t\t},\n \t\t},\n \t},\n-\t{Name: \"readme.zip\"},\n-\t{Name: \"readme.notzip\", Error: ErrFormat},\n+\t{\n+\t\tName: \"symlink.zip\",\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:    \"symlink\",\n+\t\t\t\tContent: []byte(\"../target\"),\n+\t\t\t\tMode:    0777 | os.ModeSymlink,\n+\t\t\t},\n+\t\t},\n+\t},\n+\t{\n+\t\tName: \"readme.zip\",\n+\t},\n+\t{\n+\t\tName:  \"readme.notzip\",\n+\t\tError: ErrFormat,\n+\t},\n \t{\n \t\tName: \"dd.zip\",\n \t\tFile: []ZipTestFile{"}, {"sha": "35dcec6468b2aff7b2dd664adb8b4abb1074d314", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 54, "deletions": 14, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -57,8 +57,8 @@ type FileHeader struct {\n }\n \n // FileInfo returns an os.FileInfo for the FileHeader.\n-func (fh *FileHeader) FileInfo() os.FileInfo {\n-\treturn headerFileInfo{fh}\n+func (h *FileHeader) FileInfo() os.FileInfo {\n+\treturn headerFileInfo{h}\n }\n \n // headerFileInfo implements os.FileInfo.\n@@ -71,6 +71,7 @@ func (fi headerFileInfo) Size() int64        { return int64(fi.fh.UncompressedSi\n func (fi headerFileInfo) IsDir() bool        { return fi.Mode().IsDir() }\n func (fi headerFileInfo) ModTime() time.Time { return fi.fh.ModTime() }\n func (fi headerFileInfo) Mode() os.FileMode  { return fi.fh.Mode() }\n+func (fi headerFileInfo) Sys() interface{}   { return fi.fh }\n \n // FileInfoHeader creates a partially-populated FileHeader from an\n // os.FileInfo.\n@@ -151,13 +152,20 @@ func (h *FileHeader) SetModTime(t time.Time) {\n \th.ModifiedDate, h.ModifiedTime = timeToMsDosTime(t)\n }\n \n-// traditional names for Unix constants\n const (\n-\ts_IFMT  = 0xf000\n-\ts_IFDIR = 0x4000\n-\ts_IFREG = 0x8000\n-\ts_ISUID = 0x800\n-\ts_ISGID = 0x400\n+\t// Unix constants. The specification doesn't mention them,\n+\t// but these seem to be the values agreed on by tools.\n+\ts_IFMT   = 0xf000\n+\ts_IFSOCK = 0xc000\n+\ts_IFLNK  = 0xa000\n+\ts_IFREG  = 0x8000\n+\ts_IFBLK  = 0x6000\n+\ts_IFDIR  = 0x4000\n+\ts_IFCHR  = 0x2000\n+\ts_IFIFO  = 0x1000\n+\ts_ISUID  = 0x800\n+\ts_ISGID  = 0x400\n+\ts_ISVTX  = 0x200\n \n \tmsdosDir      = 0x10\n \tmsdosReadOnly = 0x01\n@@ -205,30 +213,62 @@ func msdosModeToFileMode(m uint32) (mode os.FileMode) {\n \n func fileModeToUnixMode(mode os.FileMode) uint32 {\n \tvar m uint32\n-\tif mode&os.ModeDir != 0 {\n-\t\tm = s_IFDIR\n-\t} else {\n+\tswitch mode & os.ModeType {\n+\tdefault:\n \t\tm = s_IFREG\n+\tcase os.ModeDir:\n+\t\tm = s_IFDIR\n+\tcase os.ModeSymlink:\n+\t\tm = s_IFLNK\n+\tcase os.ModeNamedPipe:\n+\t\tm = s_IFIFO\n+\tcase os.ModeSocket:\n+\t\tm = s_IFSOCK\n+\tcase os.ModeDevice:\n+\t\tif mode&os.ModeCharDevice != 0 {\n+\t\t\tm = s_IFCHR\n+\t\t} else {\n+\t\t\tm = s_IFBLK\n+\t\t}\n \t}\n \tif mode&os.ModeSetuid != 0 {\n \t\tm |= s_ISUID\n \t}\n \tif mode&os.ModeSetgid != 0 {\n \t\tm |= s_ISGID\n \t}\n+\tif mode&os.ModeSticky != 0 {\n+\t\tm |= s_ISVTX\n+\t}\n \treturn m | uint32(mode&0777)\n }\n \n func unixModeToFileMode(m uint32) os.FileMode {\n-\tvar mode os.FileMode\n-\tif m&s_IFMT == s_IFDIR {\n+\tmode := os.FileMode(m & 0777)\n+\tswitch m & s_IFMT {\n+\tcase s_IFBLK:\n+\t\tmode |= os.ModeDevice\n+\tcase s_IFCHR:\n+\t\tmode |= os.ModeDevice | os.ModeCharDevice\n+\tcase s_IFDIR:\n \t\tmode |= os.ModeDir\n+\tcase s_IFIFO:\n+\t\tmode |= os.ModeNamedPipe\n+\tcase s_IFLNK:\n+\t\tmode |= os.ModeSymlink\n+\tcase s_IFREG:\n+\t\t// nothing to do\n+\tcase s_IFSOCK:\n+\t\tmode |= os.ModeSocket\n \t}\n \tif m&s_ISGID != 0 {\n \t\tmode |= os.ModeSetgid\n \t}\n \tif m&s_ISUID != 0 {\n \t\tmode |= os.ModeSetuid\n \t}\n-\treturn mode | os.FileMode(m&0777)\n+\tif m&s_ISVTX != 0 {\n+\t\tmode |= os.ModeSticky\n+\t}\n+\treturn mode\n }"}, {"sha": "af846938cde293ccc3dfb310fdfbda641382dd3f", "filename": "libgo/go/archive/zip/testdata/symlink.zip", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fsymlink.zip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fsymlink.zip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fsymlink.zip?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83"}, {"sha": "a4f0654474a6711f097da434fdd3e3abfcd8e330", "filename": "libgo/go/archive/zip/writer.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -19,7 +19,7 @@ import (\n \n // Writer implements a zip file writer.\n type Writer struct {\n-\t*countWriter\n+\tcountWriter\n \tdir    []*header\n \tlast   *fileWriter\n \tclosed bool\n@@ -32,7 +32,7 @@ type header struct {\n \n // NewWriter returns a new Writer writing a zip file to w.\n func NewWriter(w io.Writer) *Writer {\n-\treturn &Writer{countWriter: &countWriter{w: bufio.NewWriter(w)}}\n+\treturn &Writer{countWriter: countWriter{w: bufio.NewWriter(w)}}\n }\n \n // Close finishes writing the zip file by writing the central directory."}, {"sha": "ce93fae19e53da3508c67166945b2133c5aaa72d", "filename": "libgo/go/archive/zip/writer_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -47,10 +47,10 @@ var writeTests = []WriteTest{\n \t\tMode:   0755 | os.ModeSetgid,\n \t},\n \t{\n-\t\tName:   \"setgid\",\n-\t\tData:   []byte(\"setgid file\"),\n+\t\tName:   \"symlink\",\n+\t\tData:   []byte(\"../link/target\"),\n \t\tMethod: Deflate,\n-\t\tMode:   0755 | os.ModeSetgid,\n+\t\tMode:   0755 | os.ModeSymlink,\n \t},\n }\n "}, {"sha": "1a260cc569fa56572d8a5d25a4a67353fa597b31", "filename": "libgo/go/archive/zip/zip_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -85,4 +85,7 @@ func TestFileHeaderRoundTrip(t *testing.T) {\n \tif !reflect.DeepEqual(fh, fh2) {\n \t\tt.Errorf(\"mismatch\\n input=%#v\\noutput=%#v\\nerr=%v\", fh, fh2, err)\n \t}\n+\tif sysfh, ok := fi.Sys().(*FileHeader); !ok && sysfh != fh {\n+\t\tt.Errorf(\"Sys didn't return original *FileHeader\")\n+\t}\n }"}, {"sha": "156dddfcf071f37d527b929ad33a202a44e4de3f", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 35, "deletions": 58, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -9,37 +9,23 @@ package bufio\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"io\"\n-\t\"strconv\"\n \t\"unicode/utf8\"\n )\n \n const (\n \tdefaultBufSize = 4096\n )\n \n-// Errors introduced by this package.\n-type Error struct {\n-\tErrorString string\n-}\n-\n-func (err *Error) Error() string { return err.ErrorString }\n-\n var (\n-\tErrInvalidUnreadByte error = &Error{\"bufio: invalid use of UnreadByte\"}\n-\tErrInvalidUnreadRune error = &Error{\"bufio: invalid use of UnreadRune\"}\n-\tErrBufferFull        error = &Error{\"bufio: buffer full\"}\n-\tErrNegativeCount     error = &Error{\"bufio: negative count\"}\n-\terrInternal          error = &Error{\"bufio: internal error\"}\n+\tErrInvalidUnreadByte = errors.New(\"bufio: invalid use of UnreadByte\")\n+\tErrInvalidUnreadRune = errors.New(\"bufio: invalid use of UnreadRune\")\n+\tErrBufferFull        = errors.New(\"bufio: buffer full\")\n+\tErrNegativeCount     = errors.New(\"bufio: negative count\")\n+\terrInternal          = errors.New(\"bufio: internal error\")\n )\n \n-// BufSizeError is the error representing an invalid buffer size.\n-type BufSizeError int\n-\n-func (b BufSizeError) Error() string {\n-\treturn \"bufio: bad buffer size \" + strconv.Itoa(int(b))\n-}\n-\n // Buffered input.\n \n // Reader implements buffering for an io.Reader object.\n@@ -54,35 +40,29 @@ type Reader struct {\n \n const minReadBufferSize = 16\n \n-// NewReaderSize creates a new Reader whose buffer has the specified size,\n-// which must be at least 16 bytes.  If the argument io.Reader is already a\n-// Reader with large enough size, it returns the underlying Reader.\n-// It returns the Reader and any error.\n-func NewReaderSize(rd io.Reader, size int) (*Reader, error) {\n-\tif size < minReadBufferSize {\n-\t\treturn nil, BufSizeError(size)\n-\t}\n+// NewReaderSize returns a new Reader whose buffer has at least the specified\n+// size. If the argument io.Reader is already a Reader with large enough\n+// size, it returns the underlying Reader.\n+func NewReaderSize(rd io.Reader, size int) *Reader {\n \t// Is it already a Reader?\n \tb, ok := rd.(*Reader)\n \tif ok && len(b.buf) >= size {\n-\t\treturn b, nil\n+\t\treturn b\n+\t}\n+\tif size < minReadBufferSize {\n+\t\tsize = minReadBufferSize\n+\t}\n+\treturn &Reader{\n+\t\tbuf:          make([]byte, size),\n+\t\trd:           rd,\n+\t\tlastByte:     -1,\n+\t\tlastRuneSize: -1,\n \t}\n-\tb = new(Reader)\n-\tb.buf = make([]byte, size)\n-\tb.rd = rd\n-\tb.lastByte = -1\n-\tb.lastRuneSize = -1\n-\treturn b, nil\n }\n \n // NewReader returns a new Reader whose buffer has the default size.\n func NewReader(rd io.Reader) *Reader {\n-\tb, err := NewReaderSize(rd, defaultBufSize)\n-\tif err != nil {\n-\t\t// cannot happen - defaultBufSize is a valid size\n-\t\tpanic(err)\n-\t}\n-\treturn b\n+\treturn NewReaderSize(rd, defaultBufSize)\n }\n \n // fill reads a new chunk into the buffer.\n@@ -208,7 +188,8 @@ func (b *Reader) UnreadByte() error {\n }\n \n // ReadRune reads a single UTF-8 encoded Unicode character and returns the\n-// rune and its size in bytes.\n+// rune and its size in bytes. If the encoded rune is invalid, it consumes one byte\n+// and returns unicode.ReplacementChar (U+FFFD) with a size of 1.\n func (b *Reader) ReadRune() (r rune, size int, err error) {\n \tfor b.r+utf8.UTFMax > b.w && !utf8.FullRune(b.buf[b.r:b.w]) && b.err == nil {\n \t\tb.fill()\n@@ -392,40 +373,36 @@ func (b *Reader) ReadString(delim byte) (line string, err error) {\n // buffered output\n \n // Writer implements buffering for an io.Writer object.\n+// If an error occurs writing to a Writer, no more data will be\n+// accepted and all subsequent writes will return the error.\n type Writer struct {\n \terr error\n \tbuf []byte\n \tn   int\n \twr  io.Writer\n }\n \n-// NewWriterSize creates a new Writer whose buffer has the specified size,\n-// which must be greater than zero. If the argument io.Writer is already a\n-// Writer with large enough size, it returns the underlying Writer.\n-// It returns the Writer and any error.\n-func NewWriterSize(wr io.Writer, size int) (*Writer, error) {\n-\tif size <= 0 {\n-\t\treturn nil, BufSizeError(size)\n-\t}\n+// NewWriterSize returns a new Writer whose buffer has at least the specified\n+// size. If the argument io.Writer is already a Writer with large enough\n+// size, it returns the underlying Writer.\n+func NewWriterSize(wr io.Writer, size int) *Writer {\n \t// Is it already a Writer?\n \tb, ok := wr.(*Writer)\n \tif ok && len(b.buf) >= size {\n-\t\treturn b, nil\n+\t\treturn b\n+\t}\n+\tif size <= 0 {\n+\t\tsize = defaultBufSize\n \t}\n \tb = new(Writer)\n \tb.buf = make([]byte, size)\n \tb.wr = wr\n-\treturn b, nil\n+\treturn b\n }\n \n // NewWriter returns a new Writer whose buffer has the default size.\n func NewWriter(wr io.Writer) *Writer {\n-\tb, err := NewWriterSize(wr, defaultBufSize)\n-\tif err != nil {\n-\t\t// cannot happen - defaultBufSize is valid size\n-\t\tpanic(err)\n-\t}\n-\treturn b\n+\treturn NewWriterSize(wr, defaultBufSize)\n }\n \n // Flush writes any buffered data to the underlying io.Writer."}, {"sha": "9aec61ec426c9a65715f5d7f3943b355be686fd9", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 18, "deletions": 49, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -161,7 +161,7 @@ func TestReader(t *testing.T) {\n \t\t\t\t\tbufreader := bufreaders[j]\n \t\t\t\t\tbufsize := bufsizes[k]\n \t\t\t\t\tread := readmaker.fn(bytes.NewBufferString(text))\n-\t\t\t\t\tbuf, _ := NewReaderSize(read, bufsize)\n+\t\t\t\t\tbuf := NewReaderSize(read, bufsize)\n \t\t\t\t\ts := bufreader.fn(buf)\n \t\t\t\t\tif s != text {\n \t\t\t\t\t\tt.Errorf(\"reader=%s fn=%s bufsize=%d want=%q got=%q\",\n@@ -379,18 +379,14 @@ func TestWriter(t *testing.T) {\n \t\t\t// and that the data is correct.\n \n \t\t\tw.Reset()\n-\t\t\tbuf, e := NewWriterSize(w, bs)\n+\t\t\tbuf := NewWriterSize(w, bs)\n \t\t\tcontext := fmt.Sprintf(\"nwrite=%d bufsize=%d\", nwrite, bs)\n-\t\t\tif e != nil {\n-\t\t\t\tt.Errorf(\"%s: NewWriterSize %d: %v\", context, bs, e)\n-\t\t\t\tcontinue\n-\t\t\t}\n \t\t\tn, e1 := buf.Write(data[0:nwrite])\n \t\t\tif e1 != nil || n != nwrite {\n \t\t\t\tt.Errorf(\"%s: buf.Write %d = %d, %v\", context, nwrite, n, e1)\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif e = buf.Flush(); e != nil {\n+\t\t\tif e := buf.Flush(); e != nil {\n \t\t\t\tt.Errorf(\"%s: buf.Flush = %v\", context, e)\n \t\t\t}\n \n@@ -447,47 +443,29 @@ func TestWriteErrors(t *testing.T) {\n \n func TestNewReaderSizeIdempotent(t *testing.T) {\n \tconst BufSize = 1000\n-\tb, err := NewReaderSize(bytes.NewBufferString(\"hello world\"), BufSize)\n-\tif err != nil {\n-\t\tt.Error(\"NewReaderSize create fail\", err)\n-\t}\n+\tb := NewReaderSize(bytes.NewBufferString(\"hello world\"), BufSize)\n \t// Does it recognize itself?\n-\tb1, err2 := NewReaderSize(b, BufSize)\n-\tif err2 != nil {\n-\t\tt.Error(\"NewReaderSize #2 create fail\", err2)\n-\t}\n+\tb1 := NewReaderSize(b, BufSize)\n \tif b1 != b {\n \t\tt.Error(\"NewReaderSize did not detect underlying Reader\")\n \t}\n \t// Does it wrap if existing buffer is too small?\n-\tb2, err3 := NewReaderSize(b, 2*BufSize)\n-\tif err3 != nil {\n-\t\tt.Error(\"NewReaderSize #3 create fail\", err3)\n-\t}\n+\tb2 := NewReaderSize(b, 2*BufSize)\n \tif b2 == b {\n \t\tt.Error(\"NewReaderSize did not enlarge buffer\")\n \t}\n }\n \n func TestNewWriterSizeIdempotent(t *testing.T) {\n \tconst BufSize = 1000\n-\tb, err := NewWriterSize(new(bytes.Buffer), BufSize)\n-\tif err != nil {\n-\t\tt.Error(\"NewWriterSize create fail\", err)\n-\t}\n+\tb := NewWriterSize(new(bytes.Buffer), BufSize)\n \t// Does it recognize itself?\n-\tb1, err2 := NewWriterSize(b, BufSize)\n-\tif err2 != nil {\n-\t\tt.Error(\"NewWriterSize #2 create fail\", err2)\n-\t}\n+\tb1 := NewWriterSize(b, BufSize)\n \tif b1 != b {\n \t\tt.Error(\"NewWriterSize did not detect underlying Writer\")\n \t}\n \t// Does it wrap if existing buffer is too small?\n-\tb2, err3 := NewWriterSize(b, 2*BufSize)\n-\tif err3 != nil {\n-\t\tt.Error(\"NewWriterSize #3 create fail\", err3)\n-\t}\n+\tb2 := NewWriterSize(b, 2*BufSize)\n \tif b2 == b {\n \t\tt.Error(\"NewWriterSize did not enlarge buffer\")\n \t}\n@@ -496,10 +474,7 @@ func TestNewWriterSizeIdempotent(t *testing.T) {\n func TestWriteString(t *testing.T) {\n \tconst BufSize = 8\n \tbuf := new(bytes.Buffer)\n-\tb, err := NewWriterSize(buf, BufSize)\n-\tif err != nil {\n-\t\tt.Error(\"NewWriterSize create fail\", err)\n-\t}\n+\tb := NewWriterSize(buf, BufSize)\n \tb.WriteString(\"0\")                         // easy\n \tb.WriteString(\"123456\")                    // still easy\n \tb.WriteString(\"7890\")                      // easy after flush\n@@ -516,10 +491,7 @@ func TestWriteString(t *testing.T) {\n \n func TestBufferFull(t *testing.T) {\n \tconst longString = \"And now, hello, world! It is the time for all good men to come to the aid of their party\"\n-\tbuf, err := NewReaderSize(strings.NewReader(longString), minReadBufferSize)\n-\tif err != nil {\n-\t\tt.Fatal(\"NewReaderSize:\", err)\n-\t}\n+\tbuf := NewReaderSize(strings.NewReader(longString), minReadBufferSize)\n \tline, err := buf.ReadSlice('!')\n \tif string(line) != \"And now, hello, \" || err != ErrBufferFull {\n \t\tt.Errorf(\"first ReadSlice(,) = %q, %v\", line, err)\n@@ -533,7 +505,7 @@ func TestBufferFull(t *testing.T) {\n func TestPeek(t *testing.T) {\n \tp := make([]byte, 10)\n \t// string is 16 (minReadBufferSize) long.\n-\tbuf, _ := NewReaderSize(strings.NewReader(\"abcdefghijklmnop\"), minReadBufferSize)\n+\tbuf := NewReaderSize(strings.NewReader(\"abcdefghijklmnop\"), minReadBufferSize)\n \tif s, err := buf.Peek(1); string(s) != \"a\" || err != nil {\n \t\tt.Fatalf(\"want %q got %q, err=%v\", \"a\", string(s), err)\n \t}\n@@ -609,7 +581,7 @@ func testReadLine(t *testing.T, input []byte) {\n \tfor stride := 1; stride < 2; stride++ {\n \t\tdone := 0\n \t\treader := testReader{input, stride}\n-\t\tl, _ := NewReaderSize(&reader, len(input)+1)\n+\t\tl := NewReaderSize(&reader, len(input)+1)\n \t\tfor {\n \t\t\tline, isPrefix, err := l.ReadLine()\n \t\t\tif len(line) > 0 && err != nil {\n@@ -646,7 +618,7 @@ func TestLineTooLong(t *testing.T) {\n \t\tdata = append(data, '0'+byte(i%10))\n \t}\n \tbuf := bytes.NewBuffer(data)\n-\tl, _ := NewReaderSize(buf, minReadBufferSize)\n+\tl := NewReaderSize(buf, minReadBufferSize)\n \tline, isPrefix, err := l.ReadLine()\n \tif !isPrefix || !bytes.Equal(line, data[:minReadBufferSize]) || err != nil {\n \t\tt.Errorf(\"bad result for first line: got %q want %q %v\", line, data[:minReadBufferSize], err)\n@@ -673,7 +645,7 @@ func TestReadAfterLines(t *testing.T) {\n \tinbuf := bytes.NewBuffer([]byte(line1 + \"\\n\" + restData))\n \toutbuf := new(bytes.Buffer)\n \tmaxLineLength := len(line1) + len(restData)/2\n-\tl, _ := NewReaderSize(inbuf, maxLineLength)\n+\tl := NewReaderSize(inbuf, maxLineLength)\n \tline, isPrefix, err := l.ReadLine()\n \tif isPrefix || err != nil || string(line) != line1 {\n \t\tt.Errorf(\"bad result for first line: isPrefix=%v err=%v line=%q\", isPrefix, err, string(line))\n@@ -688,15 +660,15 @@ func TestReadAfterLines(t *testing.T) {\n }\n \n func TestReadEmptyBuffer(t *testing.T) {\n-\tl, _ := NewReaderSize(bytes.NewBuffer(nil), minReadBufferSize)\n+\tl := NewReaderSize(new(bytes.Buffer), minReadBufferSize)\n \tline, isPrefix, err := l.ReadLine()\n \tif err != io.EOF {\n \t\tt.Errorf(\"expected EOF from ReadLine, got '%s' %t %s\", line, isPrefix, err)\n \t}\n }\n \n func TestLinesAfterRead(t *testing.T) {\n-\tl, _ := NewReaderSize(bytes.NewBuffer([]byte(\"foo\")), minReadBufferSize)\n+\tl := NewReaderSize(bytes.NewBuffer([]byte(\"foo\")), minReadBufferSize)\n \t_, err := ioutil.ReadAll(l)\n \tif err != nil {\n \t\tt.Error(err)\n@@ -752,10 +724,7 @@ func TestReadLineNewlines(t *testing.T) {\n }\n \n func testReadLineNewlines(t *testing.T, input string, expect []readLineResult) {\n-\tb, err := NewReaderSize(strings.NewReader(input), minReadBufferSize)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n+\tb := NewReaderSize(strings.NewReader(input), minReadBufferSize)\n \tfor i, e := range expect {\n \t\tline, isPrefix, err := b.ReadLine()\n \t\tif bytes.Compare(line, e.line) != 0 {"}, {"sha": "a95c2afd005fe302b8b6e557481d11a2f8e6847d", "filename": "libgo/go/bytes/buffer.go", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fbytes%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fbytes%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -57,10 +57,13 @@ func (b *Buffer) String() string {\n func (b *Buffer) Len() int { return len(b.buf) - b.off }\n \n // Truncate discards all but the first n unread bytes from the buffer.\n-// It is an error to call b.Truncate(n) with n > b.Len().\n+// It panics if n is negative or greater than the length of the buffer.\n func (b *Buffer) Truncate(n int) {\n \tb.lastRead = opInvalid\n-\tif n == 0 {\n+\tswitch {\n+\tcase n < 0 || n > b.Len():\n+\t\tpanic(\"bytes.Buffer: truncation out of range\")\n+\tcase n == 0:\n \t\t// Reuse buffer space.\n \t\tb.off = 0\n \t}\n@@ -366,14 +369,15 @@ func (b *Buffer) ReadString(delim byte) (line string, err error) {\n // buf should have the desired capacity but a length of zero.\n //\n // In most cases, new(Buffer) (or just declaring a Buffer variable) is\n-// preferable to NewBuffer.  In particular, passing a non-empty buf to\n-// NewBuffer and then writing to the Buffer will overwrite buf, not append to\n-// it.\n+// sufficient to initialize a Buffer.\n func NewBuffer(buf []byte) *Buffer { return &Buffer{buf: buf} }\n \n // NewBufferString creates and initializes a new Buffer using string s as its\n-// initial contents.  It is intended to prepare a buffer to read an existing\n-// string.  See the warnings about NewBuffer; similar issues apply here.\n+// initial contents. It is intended to prepare a buffer to read an existing\n+// string.\n+//\n+// In most cases, new(Buffer) (or just declaring a Buffer variable) is\n+// sufficient to initialize a Buffer.\n func NewBufferString(s string) *Buffer {\n \treturn &Buffer{buf: []byte(s)}\n }"}, {"sha": "8505da706c9aa5e01ee67871749b8940f3c3200f", "filename": "libgo/go/compress/flate/deflate.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -102,7 +102,7 @@ func (d *compressor) fillDeflate(b []byte) int {\n \t\tif d.blockStart >= windowSize {\n \t\t\td.blockStart -= windowSize\n \t\t} else {\n-\t\t\td.blockStart = skipNever\n+\t\t\td.blockStart = math.MaxInt32\n \t\t}\n \t\td.hashOffset += windowSize\n \t}"}, {"sha": "75d801df4053230e095b23825c76f770d02148a6", "filename": "libgo/go/compress/flate/deflate_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -229,14 +229,14 @@ func testToFromWithLevel(t *testing.T, level int, input []byte, name string) err\n }\n \n func testToFromWithLevelAndLimit(t *testing.T, level int, input []byte, name string, limit int) error {\n-\tbuffer := bytes.NewBuffer(nil)\n-\tw := NewWriter(buffer, level)\n+\tvar buffer bytes.Buffer\n+\tw := NewWriter(&buffer, level)\n \tw.Write(input)\n \tw.Close()\n \tif limit > 0 && buffer.Len() > limit {\n \t\tt.Errorf(\"level: %d, len(compress(data)) = %d > limit = %d\", level, buffer.Len(), limit)\n \t}\n-\tr := NewReader(buffer)\n+\tr := NewReader(&buffer)\n \tout, err := ioutil.ReadAll(r)\n \tif err != nil {\n \t\tt.Errorf(\"read: %s\", err)"}, {"sha": "009cce6267a1c9c26597174f03a79a14802345b7", "filename": "libgo/go/compress/flate/huffman_code.go", "status": "modified", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_code.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_code.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_code.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -121,61 +121,6 @@ func (h *huffmanEncoder) bitLength(freq []int32) int64 {\n \treturn total\n }\n \n-// Generate elements in the chain using an iterative algorithm.\n-func (h *huffmanEncoder) generateChains(top *levelInfo, list []literalNode) {\n-\tn := len(list)\n-\tlist = list[0 : n+1]\n-\tlist[n] = maxNode()\n-\n-\tl := top\n-\tfor {\n-\t\tif l.nextPairFreq == math.MaxInt32 && l.nextCharFreq == math.MaxInt32 {\n-\t\t\t// We've run out of both leafs and pairs.\n-\t\t\t// End all calculations for this level.\n-\t\t\t// To m sure we never come back to this level or any lower level,\n-\t\t\t// set nextPairFreq impossibly large.\n-\t\t\tl.lastChain = nil\n-\t\t\tl.needed = 0\n-\t\t\tl = l.up\n-\t\t\tl.nextPairFreq = math.MaxInt32\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tprevFreq := l.lastChain.freq\n-\t\tif l.nextCharFreq < l.nextPairFreq {\n-\t\t\t// The next item on this row is a leaf node.\n-\t\t\tn := l.lastChain.leafCount + 1\n-\t\t\tl.lastChain = &chain{l.nextCharFreq, n, l.lastChain.up}\n-\t\t\tl.nextCharFreq = list[n].freq\n-\t\t} else {\n-\t\t\t// The next item on this row is a pair from the previous row.\n-\t\t\t// nextPairFreq isn't valid until we generate two\n-\t\t\t// more values in the level below\n-\t\t\tl.lastChain = &chain{l.nextPairFreq, l.lastChain.leafCount, l.down.lastChain}\n-\t\t\tl.down.needed = 2\n-\t\t}\n-\n-\t\tif l.needed--; l.needed == 0 {\n-\t\t\t// We've done everything we need to do for this level.\n-\t\t\t// Continue calculating one level up.  Fill in nextPairFreq\n-\t\t\t// of that level with the sum of the two nodes we've just calculated on\n-\t\t\t// this level.\n-\t\t\tup := l.up\n-\t\t\tif up == nil {\n-\t\t\t\t// All done!\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tup.nextPairFreq = prevFreq + l.lastChain.freq\n-\t\t\tl = up\n-\t\t} else {\n-\t\t\t// If we stole from below, move down temporarily to replenish it.\n-\t\t\tfor l.down.needed > 0 {\n-\t\t\t\tl = l.down\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n // Return the number of literals assigned to each bit size in the Huffman encoding\n //\n // This method is only called when list.length >= 3"}, {"sha": "e5be12f54e8d0cd65fecadbc603a6b76098e8ea0", "filename": "libgo/go/compress/lzw/reader_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -81,7 +81,7 @@ var lzwTests = []lzwTest{\n }\n \n func TestReader(t *testing.T) {\n-\tb := bytes.NewBuffer(nil)\n+\tvar b bytes.Buffer\n \tfor _, tt := range lzwTests {\n \t\td := strings.Split(tt.desc, \";\")\n \t\tvar order Order\n@@ -97,7 +97,7 @@ func TestReader(t *testing.T) {\n \t\trc := NewReader(strings.NewReader(tt.compressed), order, litWidth)\n \t\tdefer rc.Close()\n \t\tb.Reset()\n-\t\tn, err := io.Copy(b, rc)\n+\t\tn, err := io.Copy(&b, rc)\n \t\tif err != nil {\n \t\t\tif err != tt.err {\n \t\t\t\tt.Errorf(\"%s: io.Copy: %v want %v\", tt.desc, err, tt.err)\n@@ -116,7 +116,7 @@ func benchmarkDecoder(b *testing.B, n int) {\n \tb.SetBytes(int64(n))\n \tbuf0, _ := ioutil.ReadFile(\"../testdata/e.txt\")\n \tbuf0 = buf0[:10000]\n-\tcompressed := bytes.NewBuffer(nil)\n+\tcompressed := new(bytes.Buffer)\n \tw := NewWriter(compressed, LSB, 8)\n \tfor i := 0; i < n; i += len(buf0) {\n \t\tio.Copy(w, bytes.NewBuffer(buf0))"}, {"sha": "1c75d088ddf2879a172a6640354012999a38d408", "filename": "libgo/go/compress/zlib/writer_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -124,8 +124,8 @@ func TestWriterDict(t *testing.T) {\n \n func TestWriterDictIsUsed(t *testing.T) {\n \tvar input = []byte(\"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\")\n-\tbuf := bytes.NewBuffer(nil)\n-\tcompressor, err := NewWriterDict(buf, BestCompression, input)\n+\tvar buf bytes.Buffer\n+\tcompressor, err := NewWriterDict(&buf, BestCompression, input)\n \tif err != nil {\n \t\tt.Errorf(\"error in NewWriterDict: %s\", err)\n \t\treturn"}, {"sha": "a48929cf5d56cb1538fc9460bfa1d63f1c00ecb2", "filename": "libgo/go/crypto/cipher/cbc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcbc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcbc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fcbc.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -56,7 +56,7 @@ type cbcDecrypter cbc\n \n // NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining\n // mode, using the given Block. The length of iv must be the same as the\n-// Block's block size as must match the iv used to encrypt the data.\n+// Block's block size and must match the iv used to encrypt the data.\n func NewCBCDecrypter(b Block, iv []byte) BlockMode {\n \treturn (*cbcDecrypter)(newCBC(b, iv))\n }"}, {"sha": "76048fbf33953684faa83e44103b3110f59add7c", "filename": "libgo/go/crypto/cipher/io.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Fcipher%2Fio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Fcipher%2Fio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Fio.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -9,7 +9,7 @@ import \"io\"\n // The Stream* objects are so simple that all their members are public. Users\n // can create them themselves.\n \n-// StreamReader wraps a Stream into an io.Reader. It simply calls XORKeyStream\n+// StreamReader wraps a Stream into an io.Reader. It calls XORKeyStream\n // to process each slice of data which passes through.\n type StreamReader struct {\n \tS Stream\n@@ -22,7 +22,7 @@ func (r StreamReader) Read(dst []byte) (n int, err error) {\n \treturn\n }\n \n-// StreamWriter wraps a Stream into an io.Writer. It simply calls XORKeyStream\n+// StreamWriter wraps a Stream into an io.Writer. It calls XORKeyStream\n // to process each slice of data which passes through. If any Write call\n // returns short then the StreamWriter is out of sync and must be discarded.\n type StreamWriter struct {"}, {"sha": "031e74a9dca1633bb20a2eb8528538093e81a785", "filename": "libgo/go/crypto/cipher/ocfb.go", "status": "removed", "additions": 0, "deletions": 138, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fcrypto%2Fcipher%2Focfb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fcrypto%2Fcipher%2Focfb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Focfb.go?ref=cd6368115dbd75d9187877097c48a0d8d4c04fd4", "patch": "@@ -1,138 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// OpenPGP CFB Mode. http://tools.ietf.org/html/rfc4880#section-13.9\n-\n-package cipher\n-\n-type ocfbEncrypter struct {\n-\tb       Block\n-\tfre     []byte\n-\toutUsed int\n-}\n-\n-// An OCFBResyncOption determines if the \"resynchronization step\" of OCFB is\n-// performed.\n-type OCFBResyncOption bool\n-\n-const (\n-\tOCFBResync   OCFBResyncOption = true\n-\tOCFBNoResync OCFBResyncOption = false\n-)\n-\n-// NewOCFBEncrypter returns a Stream which encrypts data with OpenPGP's cipher\n-// feedback mode using the given Block, and an initial amount of ciphertext.\n-// randData must be random bytes and be the same length as the Block's block\n-// size. Resync determines if the \"resynchronization step\" from RFC 4880, 13.9\n-// step 7 is performed. Different parts of OpenPGP vary on this point.\n-func NewOCFBEncrypter(block Block, randData []byte, resync OCFBResyncOption) (Stream, []byte) {\n-\tblockSize := block.BlockSize()\n-\tif len(randData) != blockSize {\n-\t\treturn nil, nil\n-\t}\n-\n-\tx := &ocfbEncrypter{\n-\t\tb:       block,\n-\t\tfre:     make([]byte, blockSize),\n-\t\toutUsed: 0,\n-\t}\n-\tprefix := make([]byte, blockSize+2)\n-\n-\tblock.Encrypt(x.fre, x.fre)\n-\tfor i := 0; i < blockSize; i++ {\n-\t\tprefix[i] = randData[i] ^ x.fre[i]\n-\t}\n-\n-\tblock.Encrypt(x.fre, prefix[:blockSize])\n-\tprefix[blockSize] = x.fre[0] ^ randData[blockSize-2]\n-\tprefix[blockSize+1] = x.fre[1] ^ randData[blockSize-1]\n-\n-\tif resync {\n-\t\tblock.Encrypt(x.fre, prefix[2:])\n-\t} else {\n-\t\tx.fre[0] = prefix[blockSize]\n-\t\tx.fre[1] = prefix[blockSize+1]\n-\t\tx.outUsed = 2\n-\t}\n-\treturn x, prefix\n-}\n-\n-func (x *ocfbEncrypter) XORKeyStream(dst, src []byte) {\n-\tfor i := 0; i < len(src); i++ {\n-\t\tif x.outUsed == len(x.fre) {\n-\t\t\tx.b.Encrypt(x.fre, x.fre)\n-\t\t\tx.outUsed = 0\n-\t\t}\n-\n-\t\tx.fre[x.outUsed] ^= src[i]\n-\t\tdst[i] = x.fre[x.outUsed]\n-\t\tx.outUsed++\n-\t}\n-}\n-\n-type ocfbDecrypter struct {\n-\tb       Block\n-\tfre     []byte\n-\toutUsed int\n-}\n-\n-// NewOCFBDecrypter returns a Stream which decrypts data with OpenPGP's cipher\n-// feedback mode using the given Block. Prefix must be the first blockSize + 2\n-// bytes of the ciphertext, where blockSize is the Block's block size. If an\n-// incorrect key is detected then nil is returned. On successful exit,\n-// blockSize+2 bytes of decrypted data are written into prefix. Resync\n-// determines if the \"resynchronization step\" from RFC 4880, 13.9 step 7 is\n-// performed. Different parts of OpenPGP vary on this point.\n-func NewOCFBDecrypter(block Block, prefix []byte, resync OCFBResyncOption) Stream {\n-\tblockSize := block.BlockSize()\n-\tif len(prefix) != blockSize+2 {\n-\t\treturn nil\n-\t}\n-\n-\tx := &ocfbDecrypter{\n-\t\tb:       block,\n-\t\tfre:     make([]byte, blockSize),\n-\t\toutUsed: 0,\n-\t}\n-\tprefixCopy := make([]byte, len(prefix))\n-\tcopy(prefixCopy, prefix)\n-\n-\tblock.Encrypt(x.fre, x.fre)\n-\tfor i := 0; i < blockSize; i++ {\n-\t\tprefixCopy[i] ^= x.fre[i]\n-\t}\n-\n-\tblock.Encrypt(x.fre, prefix[:blockSize])\n-\tprefixCopy[blockSize] ^= x.fre[0]\n-\tprefixCopy[blockSize+1] ^= x.fre[1]\n-\n-\tif prefixCopy[blockSize-2] != prefixCopy[blockSize] ||\n-\t\tprefixCopy[blockSize-1] != prefixCopy[blockSize+1] {\n-\t\treturn nil\n-\t}\n-\n-\tif resync {\n-\t\tblock.Encrypt(x.fre, prefix[2:])\n-\t} else {\n-\t\tx.fre[0] = prefix[blockSize]\n-\t\tx.fre[1] = prefix[blockSize+1]\n-\t\tx.outUsed = 2\n-\t}\n-\tcopy(prefix, prefixCopy)\n-\treturn x\n-}\n-\n-func (x *ocfbDecrypter) XORKeyStream(dst, src []byte) {\n-\tfor i := 0; i < len(src); i++ {\n-\t\tif x.outUsed == len(x.fre) {\n-\t\t\tx.b.Encrypt(x.fre, x.fre)\n-\t\t\tx.outUsed = 0\n-\t\t}\n-\n-\t\tc := src[i]\n-\t\tdst[i] = x.fre[x.outUsed] ^ src[i]\n-\t\tx.fre[x.outUsed] = c\n-\t\tx.outUsed++\n-\t}\n-}"}, {"sha": "40938b589233819bdbadbee3c6f51faebcda1293", "filename": "libgo/go/crypto/cipher/ocfb_test.go", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fcrypto%2Fcipher%2Focfb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fcrypto%2Fcipher%2Focfb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcipher%2Focfb_test.go?ref=cd6368115dbd75d9187877097c48a0d8d4c04fd4", "patch": "@@ -1,44 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package cipher\n-\n-import (\n-\t\"bytes\"\n-\t\"crypto/aes\"\n-\t\"crypto/rand\"\n-\t\"testing\"\n-)\n-\n-func testOCFB(t *testing.T, resync OCFBResyncOption) {\n-\tblock, err := aes.NewCipher(commonKey128)\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t\treturn\n-\t}\n-\n-\tplaintext := []byte(\"this is the plaintext, which is long enough to span several blocks.\")\n-\trandData := make([]byte, block.BlockSize())\n-\trand.Reader.Read(randData)\n-\tocfb, prefix := NewOCFBEncrypter(block, randData, resync)\n-\tciphertext := make([]byte, len(plaintext))\n-\tocfb.XORKeyStream(ciphertext, plaintext)\n-\n-\tocfbdec := NewOCFBDecrypter(block, prefix, resync)\n-\tif ocfbdec == nil {\n-\t\tt.Errorf(\"NewOCFBDecrypter failed (resync: %t)\", resync)\n-\t\treturn\n-\t}\n-\tplaintextCopy := make([]byte, len(plaintext))\n-\tocfbdec.XORKeyStream(plaintextCopy, ciphertext)\n-\n-\tif !bytes.Equal(plaintextCopy, plaintext) {\n-\t\tt.Errorf(\"got: %x, want: %x (resync: %t)\", plaintextCopy, plaintext, resync)\n-\t}\n-}\n-\n-func TestOCFB(t *testing.T) {\n-\ttestOCFB(t, OCFBNoResync)\n-\ttestOCFB(t, OCFBResync)\n-}"}, {"sha": "ecefc6572545ef8d20ffc7500e523b60c2e34277", "filename": "libgo/go/crypto/crypto.go", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Fcrypto.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Fcrypto.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcrypto.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -14,15 +14,15 @@ import (\n type Hash uint\n \n const (\n-\tMD4       Hash = 1 + iota // in package crypto/md4\n-\tMD5                       // in package crypto/md5\n-\tSHA1                      // in package crypto/sha1\n-\tSHA224                    // in package crypto/sha256\n-\tSHA256                    // in package crypto/sha256\n-\tSHA384                    // in package crypto/sha512\n-\tSHA512                    // in package crypto/sha512\n+\tMD4       Hash = 1 + iota // import code.google.com/p/go.crypto/md4\n+\tMD5                       // import crypto/md5\n+\tSHA1                      // import crypto/sha1\n+\tSHA224                    // import crypto/sha256\n+\tSHA256                    // import crypto/sha256\n+\tSHA384                    // import crypto/sha512\n+\tSHA512                    // import crypto/sha512\n \tMD5SHA1                   // no implementation; MD5+SHA1 used for TLS RSA\n-\tRIPEMD160                 // in package crypto/ripemd160\n+\tRIPEMD160                 // import code.google.com/p/go.crypto/ripemd160\n \tmaxHash\n )\n \n@@ -50,16 +50,21 @@ func (h Hash) Size() int {\n \n var hashes = make([]func() hash.Hash, maxHash)\n \n-// New returns a new hash.Hash calculating the given hash function. If the\n-// hash function is not linked into the binary, New returns nil.\n+// New returns a new hash.Hash calculating the given hash function. New panics\n+// if the hash function is not linked into the binary.\n func (h Hash) New() hash.Hash {\n \tif h > 0 && h < maxHash {\n \t\tf := hashes[h]\n \t\tif f != nil {\n \t\t\treturn f()\n \t\t}\n \t}\n-\treturn nil\n+\tpanic(\"crypto: requested hash function is unavailable\")\n+}\n+\n+// Available reports whether the given hash function is linked into the binary.\n+func (h Hash) Available() bool {\n+\treturn h < maxHash && hashes[h] != nil\n }\n \n // RegisterHash registers a function that returns a new instance of the given"}, {"sha": "1c41e29a8bd9fd8af6fb91a8e5ca7c6830ec2689", "filename": "libgo/go/crypto/des/cipher.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Fdes%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Fdes%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdes%2Fcipher.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -34,13 +34,13 @@ func NewCipher(key []byte) (*Cipher, error) {\n // BlockSize returns the DES block size, 8 bytes.\n func (c *Cipher) BlockSize() int { return BlockSize }\n \n-// Encrypts the 8-byte buffer src and stores the result in dst.\n+// Encrypt encrypts the 8-byte buffer src and stores the result in dst.\n // Note that for amounts of data larger than a block,\n // it is not safe to just call Encrypt on successive blocks;\n // instead, use an encryption mode like CBC (see crypto/cipher/cbc.go).\n func (c *Cipher) Encrypt(dst, src []byte) { encryptBlock(c.subkeys[:], dst, src) }\n \n-// Decrypts the 8-byte buffer src and stores the result in dst.\n+// Decrypt decrypts the 8-byte buffer src and stores the result in dst.\n func (c *Cipher) Decrypt(dst, src []byte) { decryptBlock(c.subkeys[:], dst, src) }\n \n // Reset zeros the key data, so that it will no longer"}, {"sha": "81487f68f41160e7c16785b6a014c9eeb88fdd2f", "filename": "libgo/go/crypto/dsa/dsa.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -102,7 +102,7 @@ GeneratePrimes:\n \t\tqBytes[0] |= 0x80\n \t\tq.SetBytes(qBytes)\n \n-\t\tif !big.ProbablyPrime(q, numMRTests) {\n+\t\tif !q.ProbablyPrime(numMRTests) {\n \t\t\tcontinue\n \t\t}\n \n@@ -123,7 +123,7 @@ GeneratePrimes:\n \t\t\t\tcontinue\n \t\t\t}\n \n-\t\t\tif !big.ProbablyPrime(p, numMRTests) {\n+\t\t\tif !p.ProbablyPrime(numMRTests) {\n \t\t\t\tcontinue\n \t\t\t}\n "}, {"sha": "1e3407ee0e7c15f5bcf2f58d0c9450d9966c1400", "filename": "libgo/go/crypto/elliptic/elliptic_test.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -6,6 +6,7 @@ package elliptic\n \n import (\n \t\"crypto/rand\"\n+\t\"encoding/hex\"\n \t\"fmt\"\n \t\"math/big\"\n \t\"testing\"\n@@ -350,3 +351,13 @@ func TestMarshal(t *testing.T) {\n \t\treturn\n \t}\n }\n+\n+func TestP224Overflow(t *testing.T) {\n+\t// This tests for a specific bug in the P224 implementation.\n+\tp224 := P224()\n+\tpointData, _ := hex.DecodeString(\"049B535B45FB0A2072398A6831834624C7E32CCFD5A4B933BCEAF77F1DD945E08BBE5178F5EDF5E733388F196D2A631D2E075BB16CBFEEA15B\")\n+\tx, y := Unmarshal(p224, pointData)\n+\tif !p224.IsOnCurve(x, y) {\n+\t\tt.Error(\"P224 failed to validate a correct point\")\n+\t}\n+}"}, {"sha": "17571c252884cc49286061e284320a381a922046", "filename": "libgo/go/crypto/elliptic/p224.go", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Fp224.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -225,7 +225,7 @@ func p224ReduceLarge(out *p224FieldElement, in *p224LargeFieldElement) {\n \t\tin[i] += p224ZeroModP63[i]\n \t}\n \n-\t// Elimintate the coefficients at 2**224 and greater.\n+\t// Eliminate the coefficients at 2**224 and greater.\n \tfor i := 14; i >= 8; i-- {\n \t\tin[i-8] -= in[i]\n \t\tin[i-5] += (in[i] & 0xffff) << 12\n@@ -288,7 +288,7 @@ func p224Reduce(a *p224FieldElement) {\n \ta[0] += mask & (1 << 28)\n }\n \n-// p224Invert calcuates *out = in**-1 by computing in**(2**224 - 2**96 - 1),\n+// p224Invert calculates *out = in**-1 by computing in**(2**224 - 2**96 - 1),\n // i.e. Fermat's little theorem.\n func p224Invert(out, in *p224FieldElement) {\n \tvar f1, f2, f3, f4 p224FieldElement\n@@ -341,7 +341,7 @@ func p224Invert(out, in *p224FieldElement) {\n \n // p224Contract converts a FieldElement to its unique, minimal form.\n //\n-// On entry, in[i] < 2**32\n+// On entry, in[i] < 2**29\n // On exit, in[i] < 2**28\n func p224Contract(out, in *p224FieldElement) {\n \tcopy(out[:], in[:])\n@@ -365,6 +365,39 @@ func p224Contract(out, in *p224FieldElement) {\n \t\tout[i+1] -= 1 & mask\n \t}\n \n+\t// We might have pushed out[3] over 2**28 so we perform another, partial,\n+\t// carry chain.\n+\tfor i := 3; i < 7; i++ {\n+\t\tout[i+1] += out[i] >> 28\n+\t\tout[i] &= bottom28Bits\n+\t}\n+\ttop = out[7] >> 28\n+\tout[7] &= bottom28Bits\n+\n+\t// Eliminate top while maintaining the same value mod p.\n+\tout[0] -= top\n+\tout[3] += top << 12\n+\n+\t// There are two cases to consider for out[3]:\n+\t//   1) The first time that we eliminated top, we didn't push out[3] over\n+\t//      2**28. In this case, the partial carry chain didn't change any values\n+\t//      and top is zero.\n+\t//   2) We did push out[3] over 2**28 the first time that we eliminated top.\n+\t//      The first value of top was in [0..16), therefore, prior to eliminating\n+\t//      the first top, 0xfff1000 <= out[3] <= 0xfffffff. Therefore, after\n+\t//      overflowing and being reduced by the second carry chain, out[3] <=\n+\t//      0xf000. Thus it cannot have overflowed when we eliminated top for the\n+\t//      second time.\n+\n+\t// Again, we may just have made out[0] negative, so do the same carry down.\n+\t// As before, if we made out[0] negative then we know that out[3] is\n+\t// sufficiently positive.\n+\tfor i := 0; i < 3; i++ {\n+\t\tmask := uint32(int32(out[i]) >> 31)\n+\t\tout[i] += (1 << 28) & mask\n+\t\tout[i+1] -= 1 & mask\n+\t}\n+\n \t// Now we see if the value is >= p and, if so, subtract p.\n \n \t// First we build a mask from the top four limbs, which must all be"}, {"sha": "5391c1829b918275b8ba458516fd1f3f3833aa50", "filename": "libgo/go/crypto/rand/util.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Frand%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Frand%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Futil.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -39,7 +39,7 @@ func Prime(rand io.Reader, bits int) (p *big.Int, err error) {\n \t\tbytes[len(bytes)-1] |= 1\n \n \t\tp.SetBytes(bytes)\n-\t\tif big.ProbablyPrime(p, 20) {\n+\t\tif p.ProbablyPrime(20) {\n \t\t\treturn\n \t\t}\n \t}"}, {"sha": "4f12cbea5c5a094e11dbddf764ade2da2aebfad9", "filename": "libgo/go/crypto/rsa/pkcs1v15.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -65,7 +65,7 @@ func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (out [\n // about the plaintext.\n // See ``Chosen Ciphertext Attacks Against Protocols Based on the RSA\n // Encryption Standard PKCS #1'', Daniel Bleichenbacher, Advances in Cryptology\n-// (Crypto '98),\n+// (Crypto '98).\n func DecryptPKCS1v15SessionKey(rand io.Reader, priv *PrivateKey, ciphertext []byte, key []byte) (err error) {\n \tk := (priv.N.BitLen() + 7) / 8\n \tif k-(len(key)+3+8) < 0 {"}, {"sha": "677d27be5d27b2aac17db8554b6639077eff0283", "filename": "libgo/go/crypto/rsa/rsa.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -62,7 +62,7 @@ func (priv *PrivateKey) Validate() error {\n \t// ProbablyPrime are deterministic, given the candidate number, it's\n \t// easy for an attack to generate composites that pass this test.\n \tfor _, prime := range priv.Primes {\n-\t\tif !big.ProbablyPrime(prime, 20) {\n+\t\tif !prime.ProbablyPrime(20) {\n \t\t\treturn errors.New(\"prime factor is composite\")\n \t\t}\n \t}\n@@ -85,7 +85,7 @@ func (priv *PrivateKey) Validate() error {\n \tgcd := new(big.Int)\n \tx := new(big.Int)\n \ty := new(big.Int)\n-\tbig.GcdInt(gcd, x, y, totient, e)\n+\tgcd.GCD(x, y, totient, e)\n \tif gcd.Cmp(bigOne) != 0 {\n \t\treturn errors.New(\"invalid public exponent E\")\n \t}\n@@ -156,7 +156,7 @@ NextSetOfPrimes:\n \t\tpriv.D = new(big.Int)\n \t\ty := new(big.Int)\n \t\te := big.NewInt(int64(priv.E))\n-\t\tbig.GcdInt(g, priv.D, y, e, totient)\n+\t\tg.GCD(priv.D, y, e, totient)\n \n \t\tif g.Cmp(bigOne) == 0 {\n \t\t\tpriv.D.Add(priv.D, totient)\n@@ -284,7 +284,7 @@ func modInverse(a, n *big.Int) (ia *big.Int, ok bool) {\n \tg := new(big.Int)\n \tx := new(big.Int)\n \ty := new(big.Int)\n-\tbig.GcdInt(g, x, y, a, n)\n+\tg.GCD(x, y, a, n)\n \tif g.Cmp(bigOne) != 0 {\n \t\t// In this case, a and n aren't coprime and we cannot calculate\n \t\t// the inverse. This happens because the values of n are nearly\n@@ -412,7 +412,7 @@ func decrypt(random io.Reader, priv *PrivateKey, c *big.Int) (m *big.Int, err er\n }\n \n // DecryptOAEP decrypts ciphertext using RSA-OAEP.\n-// If rand != nil, DecryptOAEP uses RSA blinding to avoid timing side-channel attacks.\n+// If random != nil, DecryptOAEP uses RSA blinding to avoid timing side-channel attacks.\n func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) (msg []byte, err error) {\n \tk := (priv.N.BitLen() + 7) / 8\n \tif len(ciphertext) > k ||"}, {"sha": "687e5ef11b462baab95cf01ce36f1ce74e1fe10d", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -59,7 +59,8 @@ func (c *Conn) clientHandshake() error {\n \tfinishedHash.Write(serverHello.marshal())\n \n \tvers, ok := mutualVersion(serverHello.vers)\n-\tif !ok {\n+\tif !ok || vers < versionTLS10 {\n+\t\t// TLS 1.0 is the minimum version supported as a client.\n \t\treturn c.sendAlert(alertProtocolVersion)\n \t}\n \tc.vers = vers"}, {"sha": "9184e8e8118483cf97cdf0bdd84fb0c9dec01b9d", "filename": "libgo/go/crypto/tls/tls.go", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -33,45 +33,39 @@ func Client(conn net.Conn, config *Config) *Conn {\n \treturn &Conn{conn: conn, config: config, isClient: true}\n }\n \n-// A Listener implements a network listener (net.Listener) for TLS connections.\n-type Listener struct {\n-\tlistener net.Listener\n-\tconfig   *Config\n+// A listener implements a network listener (net.Listener) for TLS connections.\n+type listener struct {\n+\tnet.Listener\n+\tconfig *Config\n }\n \n // Accept waits for and returns the next incoming TLS connection.\n // The returned connection c is a *tls.Conn.\n-func (l *Listener) Accept() (c net.Conn, err error) {\n-\tc, err = l.listener.Accept()\n+func (l *listener) Accept() (c net.Conn, err error) {\n+\tc, err = l.Listener.Accept()\n \tif err != nil {\n \t\treturn\n \t}\n \tc = Server(c, l.config)\n \treturn\n }\n \n-// Close closes the listener.\n-func (l *Listener) Close() error { return l.listener.Close() }\n-\n-// Addr returns the listener's network address.\n-func (l *Listener) Addr() net.Addr { return l.listener.Addr() }\n-\n // NewListener creates a Listener which accepts connections from an inner\n // Listener and wraps each connection with Server.\n // The configuration config must be non-nil and must have\n // at least one certificate.\n-func NewListener(listener net.Listener, config *Config) (l *Listener) {\n-\tl = new(Listener)\n-\tl.listener = listener\n+func NewListener(inner net.Listener, config *Config) net.Listener {\n+\tl := new(listener)\n+\tl.Listener = inner\n \tl.config = config\n-\treturn\n+\treturn l\n }\n \n // Listen creates a TLS listener accepting connections on the\n // given network address using net.Listen.\n // The configuration config must be non-nil and must have\n // at least one certificate.\n-func Listen(network, laddr string, config *Config) (*Listener, error) {\n+func Listen(network, laddr string, config *Config) (net.Listener, error) {\n \tif config == nil || len(config.Certificates) == 0 {\n \t\treturn nil, errors.New(\"tls.Listen: no certificates in configuration\")\n \t}"}, {"sha": "3aaa8c5832a26aac09c6d353efa7868269d7557b", "filename": "libgo/go/crypto/x509/pkcs1.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs1.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -40,7 +40,7 @@ func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err error) {\n \tvar priv pkcs1PrivateKey\n \trest, err := asn1.Unmarshal(der, &priv)\n \tif len(rest) > 0 {\n-\t\terr = asn1.SyntaxError{\"trailing data\"}\n+\t\terr = asn1.SyntaxError{Msg: \"trailing data\"}\n \t\treturn\n \t}\n \tif err != nil {"}, {"sha": "738659011fad129d6e321420d0937c520176a8af", "filename": "libgo/go/crypto/x509/pkix/pkix.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkix%2Fpkix.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -23,6 +23,8 @@ type RDNSequence []RelativeDistinguishedNameSET\n \n type RelativeDistinguishedNameSET []AttributeTypeAndValue\n \n+// AttributeTypeAndValue mirrors the ASN.1 structure of the same name in\n+// http://tools.ietf.org/html/rfc5280#section-4.1.2.4\n type AttributeTypeAndValue struct {\n \tType  asn1.ObjectIdentifier\n \tValue interface{}"}, {"sha": "87b1cb7bb1c35ecad92703a3ace72c3bba19ab05", "filename": "libgo/go/crypto/x509/verify.go", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -7,6 +7,7 @@ package x509\n import (\n \t\"strings\"\n \t\"time\"\n+\t\"unicode/utf8\"\n )\n \n type InvalidReason int\n@@ -225,17 +226,51 @@ func matchHostnames(pattern, host string) bool {\n \treturn true\n }\n \n+// toLowerCaseASCII returns a lower-case version of in. See RFC 6125 6.4.1. We use\n+// an explicitly ASCII function to avoid any sharp corners resulting from\n+// performing Unicode operations on DNS labels.\n+func toLowerCaseASCII(in string) string {\n+\t// If the string is already lower-case then there's nothing to do.\n+\tisAlreadyLowerCase := true\n+\tfor _, c := range in {\n+\t\tif c == utf8.RuneError {\n+\t\t\t// If we get a UTF-8 error then there might be\n+\t\t\t// upper-case ASCII bytes in the invalid sequence.\n+\t\t\tisAlreadyLowerCase = false\n+\t\t\tbreak\n+\t\t}\n+\t\tif 'A' <= c && c <= 'Z' {\n+\t\t\tisAlreadyLowerCase = false\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\tif isAlreadyLowerCase {\n+\t\treturn in\n+\t}\n+\n+\tout := []byte(in)\n+\tfor i, c := range out {\n+\t\tif 'A' <= c && c <= 'Z' {\n+\t\t\tout[i] += 'a' - 'A'\n+\t\t}\n+\t}\n+\treturn string(out)\n+}\n+\n // VerifyHostname returns nil if c is a valid certificate for the named host.\n // Otherwise it returns an error describing the mismatch.\n func (c *Certificate) VerifyHostname(h string) error {\n+\tlowered := toLowerCaseASCII(h)\n+\n \tif len(c.DNSNames) > 0 {\n \t\tfor _, match := range c.DNSNames {\n-\t\t\tif matchHostnames(match, h) {\n+\t\t\tif matchHostnames(toLowerCaseASCII(match), lowered) {\n \t\t\t\treturn nil\n \t\t\t}\n \t\t}\n \t\t// If Subject Alt Name is given, we ignore the common name.\n-\t} else if matchHostnames(c.Subject.CommonName, h) {\n+\t} else if matchHostnames(toLowerCaseASCII(c.Subject.CommonName), lowered) {\n \t\treturn nil\n \t}\n "}, {"sha": "2cdd66a5589d689531f9e2b2f0f9739867a91dfe", "filename": "libgo/go/crypto/x509/verify_test.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -37,6 +37,17 @@ var verifyTests = []verifyTest{\n \t\t\t{\"Google\", \"Thawte\", \"VeriSign\"},\n \t\t},\n \t},\n+\t{\n+\t\tleaf:          googleLeaf,\n+\t\tintermediates: []string{thawteIntermediate},\n+\t\troots:         []string{verisignRoot},\n+\t\tcurrentTime:   1302726541,\n+\t\tdnsName:       \"WwW.GooGLE.coM\",\n+\n+\t\texpectedChains: [][]string{\n+\t\t\t{\"Google\", \"Thawte\", \"VeriSign\"},\n+\t\t},\n+\t},\n \t{\n \t\tleaf:          googleLeaf,\n \t\tintermediates: []string{thawteIntermediate},"}, {"sha": "7b45ba51f43ff995311ba04a503d53835edd70f4", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -592,7 +592,7 @@ func parseCertificate(in *certificate) (*Certificate, error) {\n \t\t\t\t\treturn nil, err\n \t\t\t\t}\n \t\t\t\tif !seq.IsCompound || seq.Tag != 16 || seq.Class != 0 {\n-\t\t\t\t\treturn nil, asn1.StructuralError{\"bad SAN sequence\"}\n+\t\t\t\t\treturn nil, asn1.StructuralError{Msg: \"bad SAN sequence\"}\n \t\t\t\t}\n \n \t\t\t\tparsedName := false\n@@ -744,7 +744,7 @@ func ParseCertificate(asn1Data []byte) (*Certificate, error) {\n \t\treturn nil, err\n \t}\n \tif len(rest) > 0 {\n-\t\treturn nil, asn1.SyntaxError{\"trailing data\"}\n+\t\treturn nil, asn1.SyntaxError{Msg: \"trailing data\"}\n \t}\n \n \treturn parseCertificate(&cert)"}, {"sha": "4924ac14e468c0102beb7abcc436b86e5b09648e", "filename": "libgo/go/database/sql/convert.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -49,6 +49,11 @@ func convertAssign(dest, src interface{}) error {\n \t\tcase *string:\n \t\t\t*d = string(s)\n \t\t\treturn nil\n+\t\tcase *interface{}:\n+\t\t\tbcopy := make([]byte, len(s))\n+\t\t\tcopy(bcopy, s)\n+\t\t\t*d = bcopy\n+\t\t\treturn nil\n \t\tcase *[]byte:\n \t\t\t*d = s\n \t\t\treturn nil\n@@ -80,6 +85,9 @@ func convertAssign(dest, src interface{}) error {\n \t\t\t*d = bv.(bool)\n \t\t}\n \t\treturn err\n+\tcase *interface{}:\n+\t\t*d = src\n+\t\treturn nil\n \t}\n \n \tif scanner, ok := dest.(ScannerInto); ok {"}, {"sha": "34ee93987fc2cbd75748398097703aed8847f403", "filename": "libgo/go/database/sql/convert_test.go", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -18,14 +18,15 @@ type conversionTest struct {\n \ts, d interface{} // source and destination\n \n \t// following are used if they're non-zero\n-\twantint  int64\n-\twantuint uint64\n-\twantstr  string\n-\twantf32  float32\n-\twantf64  float64\n-\twanttime time.Time\n-\twantbool bool // used if d is of type *bool\n-\twanterr  string\n+\twantint   int64\n+\twantuint  uint64\n+\twantstr   string\n+\twantf32   float32\n+\twantf64   float64\n+\twanttime  time.Time\n+\twantbool  bool // used if d is of type *bool\n+\twanterr   string\n+\twantiface interface{}\n }\n \n // Target variables for scanning into.\n@@ -41,6 +42,7 @@ var (\n \tscanf32    float32\n \tscanf64    float64\n \tscantime   time.Time\n+\tscaniface  interface{}\n )\n \n var conversionTests = []conversionTest{\n@@ -95,6 +97,14 @@ var conversionTests = []conversionTest{\n \t{s: float64(1.5), d: &scanf32, wantf32: float32(1.5)},\n \t{s: \"1.5\", d: &scanf32, wantf32: float32(1.5)},\n \t{s: \"1.5\", d: &scanf64, wantf64: float64(1.5)},\n+\n+\t// To interface{}\n+\t{s: float64(1.5), d: &scaniface, wantiface: float64(1.5)},\n+\t{s: int64(1), d: &scaniface, wantiface: int64(1)},\n+\t{s: \"str\", d: &scaniface, wantiface: \"str\"},\n+\t{s: []byte(\"byteslice\"), d: &scaniface, wantiface: []byte(\"byteslice\")},\n+\t{s: true, d: &scaniface, wantiface: true},\n+\t{s: nil, d: &scaniface},\n }\n \n func intValue(intptr interface{}) int64 {\n@@ -152,6 +162,18 @@ func TestConversions(t *testing.T) {\n \t\tif !ct.wanttime.IsZero() && !ct.wanttime.Equal(timeValue(ct.d)) {\n \t\t\terrf(\"want time %v, got %v\", ct.wanttime, timeValue(ct.d))\n \t\t}\n+\t\tif ifptr, ok := ct.d.(*interface{}); ok {\n+\t\t\tif !reflect.DeepEqual(ct.wantiface, scaniface) {\n+\t\t\t\terrf(\"want interface %#v, got %#v\", ct.wantiface, scaniface)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif srcBytes, ok := ct.s.([]byte); ok {\n+\t\t\t\tdstBytes := (*ifptr).([]byte)\n+\t\t\t\tif &dstBytes[0] == &srcBytes[0] {\n+\t\t\t\t\terrf(\"copy into interface{} didn't copy []byte data\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t}\n }\n "}, {"sha": "b930077605047591d3cc40ab3ee4c1ac435fa73e", "filename": "libgo/go/database/sql/driver/driver.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -5,7 +5,7 @@\n // Package driver defines interfaces to be implemented by database\n // drivers as used by package sql.\n //\n-// Code simply using databases should use package sql.\n+// Most code should use package sql.\n //\n // Drivers only need to be aware of a subset of Go's types.  The sql package\n // will convert all types into one of the following:"}, {"sha": "889e2a25232290562e9373bab72588c0a00ad6c3", "filename": "libgo/go/database/sql/fakedb_test.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -586,25 +586,25 @@ func converterForType(typ string) driver.ValueConverter {\n \tcase \"bool\":\n \t\treturn driver.Bool\n \tcase \"nullbool\":\n-\t\treturn driver.Null{driver.Bool}\n+\t\treturn driver.Null{Converter: driver.Bool}\n \tcase \"int32\":\n \t\treturn driver.Int32\n \tcase \"string\":\n-\t\treturn driver.NotNull{driver.String}\n+\t\treturn driver.NotNull{Converter: driver.String}\n \tcase \"nullstring\":\n-\t\treturn driver.Null{driver.String}\n+\t\treturn driver.Null{Converter: driver.String}\n \tcase \"int64\":\n \t\t// TODO(coopernurse): add type-specific converter\n-\t\treturn driver.NotNull{driver.DefaultParameterConverter}\n+\t\treturn driver.NotNull{Converter: driver.DefaultParameterConverter}\n \tcase \"nullint64\":\n \t\t// TODO(coopernurse): add type-specific converter\n-\t\treturn driver.Null{driver.DefaultParameterConverter}\n+\t\treturn driver.Null{Converter: driver.DefaultParameterConverter}\n \tcase \"float64\":\n \t\t// TODO(coopernurse): add type-specific converter\n-\t\treturn driver.NotNull{driver.DefaultParameterConverter}\n+\t\treturn driver.NotNull{Converter: driver.DefaultParameterConverter}\n \tcase \"nullfloat64\":\n \t\t// TODO(coopernurse): add type-specific converter\n-\t\treturn driver.Null{driver.DefaultParameterConverter}\n+\t\treturn driver.Null{Converter: driver.DefaultParameterConverter}\n \tcase \"datetime\":\n \t\treturn driver.DefaultParameterConverter\n \t}"}, {"sha": "436d4953ecd2393251f8d67a57910185668ceb47", "filename": "libgo/go/database/sql/sql.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -880,6 +880,10 @@ func (rs *Rows) Columns() ([]string, error) {\n // be modified and held indefinitely. The copy can be avoided by using\n // an argument of type *RawBytes instead; see the documentation for\n // RawBytes for restrictions on its use.\n+//\n+// If an argument has type *interface{}, Scan copies the value\n+// provided by the underlying driver without conversion. If the value\n+// is of type []byte, a copy is made and the caller owns the result.\n func (rs *Rows) Scan(dest ...interface{}) error {\n \tif rs.closed {\n \t\treturn errors.New(\"sql: Rows closed\")"}, {"sha": "774bee74baacbd67ce8eff74523afdd5fca41c6a", "filename": "libgo/go/encoding/asn1/marshal.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -24,7 +24,7 @@ type forkableWriter struct {\n }\n \n func newForkableWriter() *forkableWriter {\n-\treturn &forkableWriter{bytes.NewBuffer(nil), nil, nil}\n+\treturn &forkableWriter{new(bytes.Buffer), nil, nil}\n }\n \n func (f *forkableWriter) fork() (pre, post *forkableWriter) {"}, {"sha": "71da6e22b120f8c95c83d8df9b0a41b84aea1c7b", "filename": "libgo/go/encoding/base32/base32.go", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -125,6 +125,13 @@ func (enc *Encoding) Encode(dst, src []byte) {\n \t}\n }\n \n+// EncodeToString returns the base32 encoding of src.\n+func (enc *Encoding) EncodeToString(src []byte) string {\n+\tbuf := make([]byte, enc.EncodedLen(len(src)))\n+\tenc.Encode(buf, src)\n+\treturn string(buf)\n+}\n+\n type encoder struct {\n \terr  error\n \tenc  *Encoding\n@@ -221,24 +228,32 @@ func (e CorruptInputError) Error() string {\n \n // decode is like Decode but returns an additional 'end' value, which\n // indicates if end-of-message padding was encountered and thus any\n-// additional data is an error.  decode also assumes len(src)%8==0,\n-// since it is meant for internal use.\n+// additional data is an error.\n func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err error) {\n-\tfor i := 0; i < len(src)/8 && !end; i++ {\n+\tosrc := src\n+\tfor len(src) > 0 && !end {\n \t\t// Decode quantum using the base32 alphabet\n \t\tvar dbuf [8]byte\n \t\tdlen := 8\n \n \t\t// do the top bytes contain any data?\n \tdbufloop:\n-\t\tfor j := 0; j < 8; j++ {\n-\t\t\tin := src[i*8+j]\n-\t\t\tif in == '=' && j >= 2 && i == len(src)/8-1 {\n+\t\tfor j := 0; j < 8; {\n+\t\t\tif len(src) == 0 {\n+\t\t\t\treturn n, false, CorruptInputError(len(osrc) - len(src) - j)\n+\t\t\t}\n+\t\t\tin := src[0]\n+\t\t\tsrc = src[1:]\n+\t\t\tif in == '\\r' || in == '\\n' {\n+\t\t\t\t// Ignore this character.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif in == '=' && j >= 2 && len(src) < 8 {\n \t\t\t\t// We've reached the end and there's\n \t\t\t\t// padding, the rest should be padded\n-\t\t\t\tfor k := j; k < 8; k++ {\n-\t\t\t\t\tif src[i*8+k] != '=' {\n-\t\t\t\t\t\treturn n, false, CorruptInputError(i*8 + j)\n+\t\t\t\tfor k := 0; k < 8-j-1; k++ {\n+\t\t\t\t\tif len(src) > k && src[k] != '=' {\n+\t\t\t\t\t\treturn n, false, CorruptInputError(len(osrc) - len(src) + k - 1)\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tdlen = j\n@@ -247,28 +262,30 @@ func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err error) {\n \t\t\t}\n \t\t\tdbuf[j] = enc.decodeMap[in]\n \t\t\tif dbuf[j] == 0xFF {\n-\t\t\t\treturn n, false, CorruptInputError(i*8 + j)\n+\t\t\t\treturn n, false, CorruptInputError(len(osrc) - len(src) - 1)\n \t\t\t}\n+\t\t\tj++\n \t\t}\n \n \t\t// Pack 8x 5-bit source blocks into 5 byte destination\n \t\t// quantum\n \t\tswitch dlen {\n \t\tcase 7, 8:\n-\t\t\tdst[i*5+4] = dbuf[6]<<5 | dbuf[7]\n+\t\t\tdst[4] = dbuf[6]<<5 | dbuf[7]\n \t\t\tfallthrough\n \t\tcase 6, 5:\n-\t\t\tdst[i*5+3] = dbuf[4]<<7 | dbuf[5]<<2 | dbuf[6]>>3\n+\t\t\tdst[3] = dbuf[4]<<7 | dbuf[5]<<2 | dbuf[6]>>3\n \t\t\tfallthrough\n \t\tcase 4:\n-\t\t\tdst[i*5+2] = dbuf[3]<<4 | dbuf[4]>>1\n+\t\t\tdst[2] = dbuf[3]<<4 | dbuf[4]>>1\n \t\t\tfallthrough\n \t\tcase 3:\n-\t\t\tdst[i*5+1] = dbuf[1]<<6 | dbuf[2]<<1 | dbuf[3]>>4\n+\t\t\tdst[1] = dbuf[1]<<6 | dbuf[2]<<1 | dbuf[3]>>4\n \t\t\tfallthrough\n \t\tcase 2:\n-\t\t\tdst[i*5+0] = dbuf[0]<<3 | dbuf[1]>>2\n+\t\t\tdst[0] = dbuf[0]<<3 | dbuf[1]>>2\n \t\t}\n+\t\tdst = dst[5:]\n \t\tswitch dlen {\n \t\tcase 2:\n \t\t\tn += 1\n@@ -289,15 +306,19 @@ func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err error) {\n // DecodedLen(len(src)) bytes to dst and returns the number of bytes\n // written.  If src contains invalid base32 data, it will return the\n // number of bytes successfully written and CorruptInputError.\n+// New line characters (\\r and \\n) are ignored.\n func (enc *Encoding) Decode(dst, src []byte) (n int, err error) {\n-\tif len(src)%8 != 0 {\n-\t\treturn 0, CorruptInputError(len(src) / 8 * 8)\n-\t}\n-\n \tn, _, err = enc.decode(dst, src)\n \treturn\n }\n \n+// DecodeString returns the bytes represented by the base32 string s.\n+func (enc *Encoding) DecodeString(s string) ([]byte, error) {\n+\tdbuf := make([]byte, enc.DecodedLen(len(s)))\n+\tn, err := enc.Decode(dbuf, []byte(s))\n+\treturn dbuf[:n], err\n+}\n+\n type decoder struct {\n \terr    error\n \tenc    *Encoding"}, {"sha": "98365e18cfc9f28927e911444b1b0eb4fc75bb60", "filename": "libgo/go/encoding/base32/base32_test.go", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -51,9 +51,8 @@ func testEqual(t *testing.T, msg string, args ...interface{}) bool {\n \n func TestEncode(t *testing.T) {\n \tfor _, p := range pairs {\n-\t\tbuf := make([]byte, StdEncoding.EncodedLen(len(p.decoded)))\n-\t\tStdEncoding.Encode(buf, []byte(p.decoded))\n-\t\ttestEqual(t, \"Encode(%q) = %q, want %q\", p.decoded, string(buf), p.encoded)\n+\t\tgot := StdEncoding.EncodeToString([]byte(p.decoded))\n+\t\ttestEqual(t, \"Encode(%q) = %q, want %q\", p.decoded, got, p.encoded)\n \t}\n }\n \n@@ -99,6 +98,10 @@ func TestDecode(t *testing.T) {\n \t\ttestEqual(t, \"Decode(%q) = %q, want %q\", p.encoded,\n \t\t\tstring(dbuf[0:count]),\n \t\t\tp.decoded)\n+\n+\t\tdbuf, err = StdEncoding.DecodeString(p.encoded)\n+\t\ttestEqual(t, \"DecodeString(%q) = error %v, want %v\", p.encoded, err, error(nil))\n+\t\ttestEqual(t, \"DecodeString(%q) = %q, want %q\", p.encoded, string(dbuf), p.decoded)\n \t}\n }\n \n@@ -191,3 +194,29 @@ func TestBig(t *testing.T) {\n \t\tt.Errorf(\"Decode(Encode(%d-byte string)) failed at offset %d\", n, i)\n \t}\n }\n+\n+func TestNewLineCharacters(t *testing.T) {\n+\t// Each of these should decode to the string \"sure\", without errors.\n+\tconst expected = \"sure\"\n+\texamples := []string{\n+\t\t\"ON2XEZI=\",\n+\t\t\"ON2XEZI=\\r\",\n+\t\t\"ON2XEZI=\\n\",\n+\t\t\"ON2XEZI=\\r\\n\",\n+\t\t\"ON2XEZ\\r\\nI=\",\n+\t\t\"ON2X\\rEZ\\nI=\",\n+\t\t\"ON2X\\nEZ\\rI=\",\n+\t\t\"ON2XEZ\\nI=\",\n+\t\t\"ON2XEZI\\n=\",\n+\t}\n+\tfor _, e := range examples {\n+\t\tbuf, err := StdEncoding.DecodeString(e)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Decode(%q) failed: %v\", e, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif s := string(buf); s != expected {\n+\t\t\tt.Errorf(\"Decode(%q) = %q, want %q\", e, s, expected)\n+\t\t}\n+\t}\n+}"}, {"sha": "55f9f67a43a566bcd466193dc1404a4f55ee7aae", "filename": "libgo/go/encoding/base64/base64.go", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -208,45 +208,55 @@ func (e CorruptInputError) Error() string {\n \n // decode is like Decode but returns an additional 'end' value, which\n // indicates if end-of-message padding was encountered and thus any\n-// additional data is an error.  decode also assumes len(src)%4==0,\n-// since it is meant for internal use.\n+// additional data is an error.\n func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err error) {\n-\tfor i := 0; i < len(src)/4 && !end; i++ {\n+\tosrc := src\n+\tfor len(src) > 0 && !end {\n \t\t// Decode quantum using the base64 alphabet\n \t\tvar dbuf [4]byte\n \t\tdlen := 4\n \n \tdbufloop:\n-\t\tfor j := 0; j < 4; j++ {\n-\t\t\tin := src[i*4+j]\n-\t\t\tif in == '=' && j >= 2 && i == len(src)/4-1 {\n+\t\tfor j := 0; j < 4; {\n+\t\t\tif len(src) == 0 {\n+\t\t\t\treturn n, false, CorruptInputError(len(osrc) - len(src) - j)\n+\t\t\t}\n+\t\t\tin := src[0]\n+\t\t\tsrc = src[1:]\n+\t\t\tif in == '\\r' || in == '\\n' {\n+\t\t\t\t// Ignore this character.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif in == '=' && j >= 2 && len(src) < 4 {\n \t\t\t\t// We've reached the end and there's\n \t\t\t\t// padding\n-\t\t\t\tif src[i*4+3] != '=' {\n-\t\t\t\t\treturn n, false, CorruptInputError(i*4 + 2)\n+\t\t\t\tif len(src) > 0 && src[0] != '=' {\n+\t\t\t\t\treturn n, false, CorruptInputError(len(osrc) - len(src) - 1)\n \t\t\t\t}\n \t\t\t\tdlen = j\n \t\t\t\tend = true\n \t\t\t\tbreak dbufloop\n \t\t\t}\n \t\t\tdbuf[j] = enc.decodeMap[in]\n \t\t\tif dbuf[j] == 0xFF {\n-\t\t\t\treturn n, false, CorruptInputError(i*4 + j)\n+\t\t\t\treturn n, false, CorruptInputError(len(osrc) - len(src) - 1)\n \t\t\t}\n+\t\t\tj++\n \t\t}\n \n \t\t// Pack 4x 6-bit source blocks into 3 byte destination\n \t\t// quantum\n \t\tswitch dlen {\n \t\tcase 4:\n-\t\t\tdst[i*3+2] = dbuf[2]<<6 | dbuf[3]\n+\t\t\tdst[2] = dbuf[2]<<6 | dbuf[3]\n \t\t\tfallthrough\n \t\tcase 3:\n-\t\t\tdst[i*3+1] = dbuf[1]<<4 | dbuf[2]>>2\n+\t\t\tdst[1] = dbuf[1]<<4 | dbuf[2]>>2\n \t\t\tfallthrough\n \t\tcase 2:\n-\t\t\tdst[i*3+0] = dbuf[0]<<2 | dbuf[1]>>4\n+\t\t\tdst[0] = dbuf[0]<<2 | dbuf[1]>>4\n \t\t}\n+\t\tdst = dst[3:]\n \t\tn += dlen - 1\n \t}\n \n@@ -257,11 +267,8 @@ func (enc *Encoding) decode(dst, src []byte) (n int, end bool, err error) {\n // DecodedLen(len(src)) bytes to dst and returns the number of bytes\n // written.  If src contains invalid base64 data, it will return the\n // number of bytes successfully written and CorruptInputError.\n+// New line characters (\\r and \\n) are ignored.\n func (enc *Encoding) Decode(dst, src []byte) (n int, err error) {\n-\tif len(src)%4 != 0 {\n-\t\treturn 0, CorruptInputError(len(src) / 4 * 4)\n-\t}\n-\n \tn, _, err = enc.decode(dst, src)\n \treturn\n }"}, {"sha": "3e9a84393b60150f22eb88d0bc60342daeba82c1", "filename": "libgo/go/encoding/base64/base64_test.go", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -197,3 +197,29 @@ func TestBig(t *testing.T) {\n \t\tt.Errorf(\"Decode(Encode(%d-byte string)) failed at offset %d\", n, i)\n \t}\n }\n+\n+func TestNewLineCharacters(t *testing.T) {\n+\t// Each of these should decode to the string \"sure\", without errors.\n+\tconst expected = \"sure\"\n+\texamples := []string{\n+\t\t\"c3VyZQ==\",\n+\t\t\"c3VyZQ==\\r\",\n+\t\t\"c3VyZQ==\\n\",\n+\t\t\"c3VyZQ==\\r\\n\",\n+\t\t\"c3VyZ\\r\\nQ==\",\n+\t\t\"c3V\\ryZ\\nQ==\",\n+\t\t\"c3V\\nyZ\\rQ==\",\n+\t\t\"c3VyZ\\nQ==\",\n+\t\t\"c3VyZQ\\n==\",\n+\t}\n+\tfor _, e := range examples {\n+\t\tbuf, err := StdEncoding.DecodeString(e)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Decode(%q) failed: %v\", e, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif s := string(buf); s != expected {\n+\t\t\tt.Errorf(\"Decode(%q) = %q, want %q\", e, s, expected)\n+\t\t}\n+\t}\n+}"}, {"sha": "4be83f53bd489f51f9b84b7ac3cb3bf835663e1d", "filename": "libgo/go/encoding/binary/binary.go", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -163,7 +163,7 @@ func Read(r io.Reader, order ByteOrder, data interface{}) error {\n \tdefault:\n \t\treturn errors.New(\"binary.Read: invalid type \" + d.Type().String())\n \t}\n-\tsize := TotalSize(v)\n+\tsize := dataSize(v)\n \tif size < 0 {\n \t\treturn errors.New(\"binary.Read: invalid type \" + v.Type().String())\n \t}\n@@ -242,7 +242,7 @@ func Write(w io.Writer, order ByteOrder, data interface{}) error {\n \t\treturn err\n \t}\n \tv := reflect.Indirect(reflect.ValueOf(data))\n-\tsize := TotalSize(v)\n+\tsize := dataSize(v)\n \tif size < 0 {\n \t\treturn errors.New(\"binary.Write: invalid type \" + v.Type().String())\n \t}\n@@ -253,7 +253,11 @@ func Write(w io.Writer, order ByteOrder, data interface{}) error {\n \treturn err\n }\n \n-func TotalSize(v reflect.Value) int {\n+// dataSize returns the number of bytes the actual data represented by v occupies in memory.\n+// For compound structures, it sums the sizes of the elements. Thus, for instance, for a slice\n+// it returns the length of the slice times the element size and does not count the memory\n+// occupied by the header.\n+func dataSize(v reflect.Value) int {\n \tif v.Kind() == reflect.Slice {\n \t\telem := sizeof(v.Type().Elem())\n \t\tif elem < 0 {"}, {"sha": "ff361b7e379f93a740246dc451596299f404568a", "filename": "libgo/go/encoding/binary/binary_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -187,7 +187,7 @@ func BenchmarkReadStruct(b *testing.B) {\n \tbsr := &byteSliceReader{}\n \tvar buf bytes.Buffer\n \tWrite(&buf, BigEndian, &s)\n-\tn := TotalSize(reflect.ValueOf(s))\n+\tn := dataSize(reflect.ValueOf(s))\n \tb.SetBytes(int64(n))\n \tt := s\n \tb.ResetTimer()"}, {"sha": "9aa398e58b28d30efc77ea4b0c53b0b440c5b5d3", "filename": "libgo/go/encoding/csv/reader.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fcsv%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fcsv%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fcsv%2Freader.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -156,6 +156,9 @@ func (r *Reader) Read() (record []string, err error) {\n \n // ReadAll reads all the remaining records from r.\n // Each record is a slice of fields.\n+// A successful call returns err == nil, not err == EOF. Because ReadAll is\n+// defined to read until EOF, it does not treat end of file as an error to be\n+// reported.\n func (r *Reader) ReadAll() (records [][]string, err error) {\n \tfor {\n \t\trecord, err := r.Read()"}, {"sha": "d365f82634553912242a3d27d8b657434d3ce179", "filename": "libgo/go/encoding/gob/codec_test.go", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -8,9 +8,11 @@ import (\n \t\"bytes\"\n \t\"errors\"\n \t\"math\"\n+\t\"math/rand\"\n \t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n+\t\"time\"\n \t\"unsafe\"\n )\n \n@@ -1407,3 +1409,60 @@ func TestDebugStruct(t *testing.T) {\n \t}\n \tdebugFunc(debugBuffer)\n }\n+\n+func encFuzzDec(rng *rand.Rand, in interface{}) error {\n+\tbuf := new(bytes.Buffer)\n+\tenc := NewEncoder(buf)\n+\tif err := enc.Encode(&in); err != nil {\n+\t\treturn err\n+\t}\n+\n+\tb := buf.Bytes()\n+\tfor i, bi := range b {\n+\t\tif rng.Intn(10) < 3 {\n+\t\t\tb[i] = bi + uint8(rng.Intn(256))\n+\t\t}\n+\t}\n+\n+\tdec := NewDecoder(buf)\n+\tvar e interface{}\n+\tif err := dec.Decode(&e); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+// This does some \"fuzz testing\" by attempting to decode a sequence of random bytes.\n+func TestFuzz(t *testing.T) {\n+\tif testing.Short() {\n+\t\treturn\n+\t}\n+\n+\t// all possible inputs\n+\tinput := []interface{}{\n+\t\tnew(int),\n+\t\tnew(float32),\n+\t\tnew(float64),\n+\t\tnew(complex128),\n+\t\t&ByteStruct{255},\n+\t\t&ArrayStruct{},\n+\t\t&StringStruct{\"hello\"},\n+\t\t&GobTest1{0, &StringStruct{\"hello\"}},\n+\t}\n+\ttestFuzz(t, time.Now().UnixNano(), 100, input...)\n+}\n+\n+func TestFuzzRegressions(t *testing.T) {\n+\t// An instance triggering a type name of length ~102 GB.\n+\ttestFuzz(t, 1328492090837718000, 100, new(float32))\n+}\n+\n+func testFuzz(t *testing.T, seed int64, n int, input ...interface{}) {\n+\tt.Logf(\"seed=%d n=%d\\n\", seed, n)\n+\tfor _, e := range input {\n+\t\trng := rand.New(rand.NewSource(seed))\n+\t\tfor i := 0; i < n; i++ {\n+\t\t\tencFuzzDec(rng, e)\n+\t\t}\n+\t}\n+}"}, {"sha": "b54ef46f52c29b72b1c87e016b7b7f149edc4dd5", "filename": "libgo/go/encoding/gob/debug.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fgob%2Fdebug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fgob%2Fdebug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdebug.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -2,8 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Delete the next line to include this file in the gob package.\n-// +build ignore\n+// Delete the next line to include in the gob package.\n+// +build gob-debug\n \n package gob\n "}, {"sha": "8191062d30930303a85086c539c6b962735316bd", "filename": "libgo/go/encoding/gob/decode.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -690,7 +690,11 @@ func (dec *Decoder) decodeInterface(ityp reflect.Type, state *decoderState, p ui\n \t// Create a writable interface reflect.Value.  We need one even for the nil case.\n \tivalue := allocValue(ityp)\n \t// Read the name of the concrete type.\n-\tb := make([]byte, state.decodeUint())\n+\tnr := state.decodeUint()\n+\tif nr < 0 || nr > 1<<31 { // zero is permissible for anonymous types\n+\t\terrorf(\"invalid type name length %d\", nr)\n+\t}\n+\tb := make([]byte, nr)\n \tstate.b.Read(b)\n \tname := string(b)\n \tif name == \"\" {"}, {"sha": "c5c7d3fdb10ddc7d3c4f1defb703d839a7d1e3db", "filename": "libgo/go/encoding/gob/decoder.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fgob%2Fdecoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fgob%2Fdecoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdecoder.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -135,7 +135,7 @@ func (dec *Decoder) nextUint() uint64 {\n // and returns the type id of the next value.  It returns -1 at\n // EOF.  Upon return, the remainder of dec.buf is the value to be\n // decoded.  If this is an interface value, it can be ignored by\n-// simply resetting that buffer.\n+// resetting that buffer.\n func (dec *Decoder) decodeTypeSequence(isInterface bool) typeId {\n \tfor dec.err == nil {\n \t\tif dec.buf.Len() == 0 {"}, {"sha": "c9ad18e764199a243e7386bd0680692cf4400698", "filename": "libgo/go/encoding/gob/doc.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -70,7 +70,7 @@ operation will fail.\n Structs, arrays and slices are also supported.  Strings and arrays of bytes are\n supported with a special, efficient representation (see below).  When a slice is\n decoded, if the existing slice has capacity the slice will be extended in place;\n-if not, a new array is allocated.  Regardless, the length of the resuling slice\n+if not, a new array is allocated.  Regardless, the length of the resulting slice\n reports the number of elements decoded.\n \n Functions and channels cannot be sent in a gob.  Attempting\n@@ -162,7 +162,7 @@ description, constructed from these types:\n \t\tStructT *StructType\n \t\tMapT    *MapType\n \t}\n-\ttype ArrayType struct {\n+\ttype arrayType struct {\n \t\tCommonType\n \t\tElem typeId\n \t\tLen  int\n@@ -171,19 +171,19 @@ description, constructed from these types:\n \t\tName string // the name of the struct type\n \t\tId  int    // the id of the type, repeated so it's inside the type\n \t}\n-\ttype SliceType struct {\n+\ttype sliceType struct {\n \t\tCommonType\n \t\tElem typeId\n \t}\n-\ttype StructType struct {\n+\ttype structType struct {\n \t\tCommonType\n \t\tField []*fieldType // the fields of the struct.\n \t}\n-\ttype FieldType struct {\n+\ttype fieldType struct {\n \t\tName string // the name of the field.\n \t\tId   int    // the type id of the field, which must be already defined\n \t}\n-\ttype MapType struct {\n+\ttype mapType struct {\n \t\tCommonType\n \t\tKey  typeId\n \t\tElem typeId\n@@ -308,15 +308,15 @@ reserved).\n \t// Set the field number implicitly to -1; this is done at the beginning\n \t// of every struct, including nested structs.\n \t03\t// Add 3 to field number; now 2 (wireType.structType; this is a struct).\n-\t\t// structType starts with an embedded commonType, which appears\n+\t\t// structType starts with an embedded CommonType, which appears\n \t\t// as a regular structure here too.\n-\t01\t// add 1 to field number (now 0); start of embedded commonType.\n+\t01\t// add 1 to field number (now 0); start of embedded CommonType.\n \t01\t// add 1 to field number (now 0, the name of the type)\n \t05\t// string is (unsigned) 5 bytes long\n-\t50 6f 69 6e 74\t// wireType.structType.commonType.name = \"Point\"\n+\t50 6f 69 6e 74\t// wireType.structType.CommonType.name = \"Point\"\n \t01\t// add 1 to field number (now 1, the id of the type)\n-\tff 82\t// wireType.structType.commonType._id = 65\n-\t00\t// end of embedded wiretype.structType.commonType struct\n+\tff 82\t// wireType.structType.CommonType._id = 65\n+\t00\t// end of embedded wiretype.structType.CommonType struct\n \t01\t// add 1 to field number (now 1, the field array in wireType.structType)\n \t02\t// There are two fields in the type (len(structType.field))\n \t01\t// Start of first field structure; add 1 to get field number 0: field[0].name"}, {"sha": "9a62cf9c2ade63cf7aa658fe4c20facd5c8d4394", "filename": "libgo/go/encoding/gob/encoder_test.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -570,16 +570,15 @@ func TestGobMapInterfaceEncode(t *testing.T) {\n \t\t\"bo\": []bool{false},\n \t\t\"st\": []string{\"s\"},\n \t}\n-\tbuf := bytes.NewBuffer(nil)\n-\tenc := NewEncoder(buf)\n+\tenc := NewEncoder(new(bytes.Buffer))\n \terr := enc.Encode(m)\n \tif err != nil {\n \t\tt.Errorf(\"encode map: %s\", err)\n \t}\n }\n \n func TestSliceReusesMemory(t *testing.T) {\n-\tbuf := bytes.NewBuffer(nil)\n+\tbuf := new(bytes.Buffer)\n \t// Bytes\n \t{\n \t\tx := []byte(\"abcd\")"}, {"sha": "92cc0c615e3bd94bd286700ac510705c5b1cac2a", "filename": "libgo/go/encoding/gob/error.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fgob%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fgob%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Ferror.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -33,7 +33,11 @@ func error_(err error) {\n // plain error.  It overwrites the error return of the function that deferred its call.\n func catchError(err *error) {\n \tif e := recover(); e != nil {\n-\t\t*err = e.(gobError).err // Will re-panic if not one of our errors, such as a runtime error.\n+\t\tge, ok := e.(gobError)\n+\t\tif !ok {\n+\t\t\tpanic(e)\n+\t\t}\n+\t\t*err = ge.err\n \t}\n \treturn\n }"}, {"sha": "b9371c42309eec79e858001e423ac106afcc1468", "filename": "libgo/go/encoding/gob/timing_test.go", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fgob%2Ftiming_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fgob%2Ftiming_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Ftiming_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -53,17 +53,18 @@ func TestCountEncodeMallocs(t *testing.T) {\n \tvar buf bytes.Buffer\n \tenc := NewEncoder(&buf)\n \tbench := &Bench{7, 3.2, \"now is the time\", []byte(\"for all good men\")}\n-\truntime.UpdateMemStats()\n-\tmallocs := 0 - runtime.MemStats.Mallocs\n+\tmemstats := new(runtime.MemStats)\n+\truntime.ReadMemStats(memstats)\n+\tmallocs := 0 - memstats.Mallocs\n \tconst count = 1000\n \tfor i := 0; i < count; i++ {\n \t\terr := enc.Encode(bench)\n \t\tif err != nil {\n \t\t\tt.Fatal(\"encode:\", err)\n \t\t}\n \t}\n-\truntime.UpdateMemStats()\n-\tmallocs += runtime.MemStats.Mallocs\n+\truntime.ReadMemStats(memstats)\n+\tmallocs += memstats.Mallocs\n \tfmt.Printf(\"mallocs per encode of type Bench: %d\\n\", mallocs/count)\n }\n \n@@ -79,16 +80,17 @@ func TestCountDecodeMallocs(t *testing.T) {\n \t\t}\n \t}\n \tdec := NewDecoder(&buf)\n-\truntime.UpdateMemStats()\n-\tmallocs := 0 - runtime.MemStats.Mallocs\n+\tmemstats := new(runtime.MemStats)\n+\truntime.ReadMemStats(memstats)\n+\tmallocs := 0 - memstats.Mallocs\n \tfor i := 0; i < count; i++ {\n \t\t*bench = Bench{}\n \t\terr := dec.Decode(&bench)\n \t\tif err != nil {\n \t\t\tt.Fatal(\"decode:\", err)\n \t\t}\n \t}\n-\truntime.UpdateMemStats()\n-\tmallocs += runtime.MemStats.Mallocs\n+\truntime.ReadMemStats(memstats)\n+\tmallocs += memstats.Mallocs\n \tfmt.Printf(\"mallocs per decode of type Bench: %d\\n\", mallocs/count)\n }"}, {"sha": "39006efdb2d596a553899fa778df42cb1e91cd84", "filename": "libgo/go/encoding/gob/type.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -180,7 +180,10 @@ func (t typeId) name() string {\n \treturn t.gobType().name()\n }\n \n-// Common elements of all types.\n+// CommonType holds elements of all types.\n+// It is a historical artifact, kept for binary compatibility and exported\n+// only for the benefit of the package's encoding of type descriptors. It is\n+// not intended for direct use by clients.\n type CommonType struct {\n \tName string\n \tId   typeId"}, {"sha": "167d00e032aec9a56be8fb728fc415426d54bdc4", "filename": "libgo/go/encoding/hex/hex.go", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fhex%2Fhex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fhex%2Fhex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fhex%2Fhex.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -7,8 +7,9 @@ package hex\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n+\t\"fmt\"\n \t\"io\"\n-\t\"strconv\"\n )\n \n const hextable = \"0123456789abcdef\"\n@@ -29,38 +30,35 @@ func Encode(dst, src []byte) int {\n \treturn len(src) * 2\n }\n \n-// OddLengthInputError results from decoding an odd length slice.\n-type OddLengthInputError struct{}\n+// ErrLength results from decoding an odd length slice.\n+var ErrLength = errors.New(\"encoding/hex: odd length hex string\")\n \n-func (OddLengthInputError) Error() string { return \"odd length hex string\" }\n+// InvalidByteError values describe errors resulting from an invalid byte in a hex string.\n+type InvalidByteError byte\n \n-// InvalidHexCharError results from finding an invalid character in a hex string.\n-type InvalidHexCharError byte\n-\n-func (e InvalidHexCharError) Error() string {\n-\treturn \"invalid hex char: \" + strconv.Itoa(int(e))\n+func (e InvalidByteError) Error() string {\n+\treturn fmt.Sprintf(\"encoding/hex: invalid byte: %#U\", rune(e))\n }\n \n func DecodedLen(x int) int { return x / 2 }\n \n // Decode decodes src into DecodedLen(len(src)) bytes, returning the actual\n // number of bytes written to dst.\n //\n-// If Decode encounters invalid input, it returns an OddLengthInputError or an\n-// InvalidHexCharError.\n+// If Decode encounters invalid input, it returns an error describing the failure.\n func Decode(dst, src []byte) (int, error) {\n \tif len(src)%2 == 1 {\n-\t\treturn 0, OddLengthInputError{}\n+\t\treturn 0, ErrLength\n \t}\n \n \tfor i := 0; i < len(src)/2; i++ {\n \t\ta, ok := fromHexChar(src[i*2])\n \t\tif !ok {\n-\t\t\treturn 0, InvalidHexCharError(src[i*2])\n+\t\t\treturn 0, InvalidByteError(src[i*2])\n \t\t}\n \t\tb, ok := fromHexChar(src[i*2+1])\n \t\tif !ok {\n-\t\t\treturn 0, InvalidHexCharError(src[i*2+1])\n+\t\t\treturn 0, InvalidByteError(src[i*2+1])\n \t\t}\n \t\tdst[i] = (a << 4) | b\n \t}\n@@ -103,8 +101,8 @@ func DecodeString(s string) ([]byte, error) {\n // Dump returns a string that contains a hex dump of the given data. The format\n // of the hex dump matches the output of `hexdump -C` on the command line.\n func Dump(data []byte) string {\n-\tbuf := bytes.NewBuffer(nil)\n-\tdumper := Dumper(buf)\n+\tvar buf bytes.Buffer\n+\tdumper := Dumper(&buf)\n \tdumper.Write(data)\n \tdumper.Close()\n \treturn string(buf.Bytes())"}, {"sha": "2d24fd0a146109adcaf87e7a2d1122060fc0c7aa", "filename": "libgo/go/encoding/hex/hex_test.go", "status": "modified", "additions": 64, "deletions": 107, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fhex%2Fhex_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fhex%2Fhex_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fhex%2Fhex_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -9,141 +9,98 @@ import (\n \t\"testing\"\n )\n \n-type encodeTest struct {\n-\tin, out []byte\n+type encDecTest struct {\n+\tenc string\n+\tdec []byte\n }\n \n-var encodeTests = []encodeTest{\n-\t{[]byte{}, []byte{}},\n-\t{[]byte{0x01}, []byte{'0', '1'}},\n-\t{[]byte{0xff}, []byte{'f', 'f'}},\n-\t{[]byte{0xff, 00}, []byte{'f', 'f', '0', '0'}},\n-\t{[]byte{0}, []byte{'0', '0'}},\n-\t{[]byte{1}, []byte{'0', '1'}},\n-\t{[]byte{2}, []byte{'0', '2'}},\n-\t{[]byte{3}, []byte{'0', '3'}},\n-\t{[]byte{4}, []byte{'0', '4'}},\n-\t{[]byte{5}, []byte{'0', '5'}},\n-\t{[]byte{6}, []byte{'0', '6'}},\n-\t{[]byte{7}, []byte{'0', '7'}},\n-\t{[]byte{8}, []byte{'0', '8'}},\n-\t{[]byte{9}, []byte{'0', '9'}},\n-\t{[]byte{10}, []byte{'0', 'a'}},\n-\t{[]byte{11}, []byte{'0', 'b'}},\n-\t{[]byte{12}, []byte{'0', 'c'}},\n-\t{[]byte{13}, []byte{'0', 'd'}},\n-\t{[]byte{14}, []byte{'0', 'e'}},\n-\t{[]byte{15}, []byte{'0', 'f'}},\n+var encDecTests = []encDecTest{\n+\t{\"\", []byte{}},\n+\t{\"0001020304050607\", []byte{0, 1, 2, 3, 4, 5, 6, 7}},\n+\t{\"08090a0b0c0d0e0f\", []byte{8, 9, 10, 11, 12, 13, 14, 15}},\n+\t{\"f0f1f2f3f4f5f6f7\", []byte{0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7}},\n+\t{\"f8f9fafbfcfdfeff\", []byte{0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff}},\n+\t{\"67\", []byte{'g'}},\n+\t{\"e3a1\", []byte{0xe3, 0xa1}},\n }\n \n func TestEncode(t *testing.T) {\n-\tfor i, test := range encodeTests {\n-\t\tdst := make([]byte, EncodedLen(len(test.in)))\n-\t\tn := Encode(dst, test.in)\n+\tfor i, test := range encDecTests {\n+\t\tdst := make([]byte, EncodedLen(len(test.dec)))\n+\t\tn := Encode(dst, test.dec)\n \t\tif n != len(dst) {\n \t\t\tt.Errorf(\"#%d: bad return value: got: %d want: %d\", i, n, len(dst))\n \t\t}\n-\t\tif bytes.Compare(dst, test.out) != 0 {\n-\t\t\tt.Errorf(\"#%d: got: %#v want: %#v\", i, dst, test.out)\n+\t\tif string(dst) != test.enc {\n+\t\t\tt.Errorf(\"#%d: got: %#v want: %#v\", i, dst, test.enc)\n \t\t}\n \t}\n }\n \n-type decodeTest struct {\n-\tin, out []byte\n-\tok      bool\n-}\n-\n-var decodeTests = []decodeTest{\n-\t{[]byte{}, []byte{}, true},\n-\t{[]byte{'0'}, []byte{}, false},\n-\t{[]byte{'0', 'g'}, []byte{}, false},\n-\t{[]byte{'0', '\\x01'}, []byte{}, false},\n-\t{[]byte{'0', '0'}, []byte{0}, true},\n-\t{[]byte{'0', '1'}, []byte{1}, true},\n-\t{[]byte{'0', '2'}, []byte{2}, true},\n-\t{[]byte{'0', '3'}, []byte{3}, true},\n-\t{[]byte{'0', '4'}, []byte{4}, true},\n-\t{[]byte{'0', '5'}, []byte{5}, true},\n-\t{[]byte{'0', '6'}, []byte{6}, true},\n-\t{[]byte{'0', '7'}, []byte{7}, true},\n-\t{[]byte{'0', '8'}, []byte{8}, true},\n-\t{[]byte{'0', '9'}, []byte{9}, true},\n-\t{[]byte{'0', 'a'}, []byte{10}, true},\n-\t{[]byte{'0', 'b'}, []byte{11}, true},\n-\t{[]byte{'0', 'c'}, []byte{12}, true},\n-\t{[]byte{'0', 'd'}, []byte{13}, true},\n-\t{[]byte{'0', 'e'}, []byte{14}, true},\n-\t{[]byte{'0', 'f'}, []byte{15}, true},\n-\t{[]byte{'0', 'A'}, []byte{10}, true},\n-\t{[]byte{'0', 'B'}, []byte{11}, true},\n-\t{[]byte{'0', 'C'}, []byte{12}, true},\n-\t{[]byte{'0', 'D'}, []byte{13}, true},\n-\t{[]byte{'0', 'E'}, []byte{14}, true},\n-\t{[]byte{'0', 'F'}, []byte{15}, true},\n-}\n-\n func TestDecode(t *testing.T) {\n-\tfor i, test := range decodeTests {\n-\t\tdst := make([]byte, DecodedLen(len(test.in)))\n-\t\tn, err := Decode(dst, test.in)\n-\t\tif err == nil && n != len(dst) {\n+\tfor i, test := range encDecTests {\n+\t\tdst := make([]byte, DecodedLen(len(test.enc)))\n+\t\tn, err := Decode(dst, []byte(test.enc))\n+\t\tif err != nil {\n \t\t\tt.Errorf(\"#%d: bad return value: got:%d want:%d\", i, n, len(dst))\n-\t\t}\n-\t\tif test.ok != (err == nil) {\n-\t\t\tt.Errorf(\"#%d: unexpected err value: %s\", i, err)\n-\t\t}\n-\t\tif err == nil && bytes.Compare(dst, test.out) != 0 {\n-\t\t\tt.Errorf(\"#%d: got: %#v want: %#v\", i, dst, test.out)\n+\t\t} else if !bytes.Equal(dst, test.dec) {\n+\t\t\tt.Errorf(\"#%d: got: %#v want: %#v\", i, dst, test.dec)\n \t\t}\n \t}\n }\n \n-type encodeStringTest struct {\n-\tin  []byte\n-\tout string\n-}\n-\n-var encodeStringTests = []encodeStringTest{\n-\t{[]byte{}, \"\"},\n-\t{[]byte{0}, \"00\"},\n-\t{[]byte{0, 1}, \"0001\"},\n-\t{[]byte{0, 1, 255}, \"0001ff\"},\n+func TestEncodeToString(t *testing.T) {\n+\tfor i, test := range encDecTests {\n+\t\ts := EncodeToString(test.dec)\n+\t\tif s != test.enc {\n+\t\t\tt.Errorf(\"#%d got:%s want:%s\", i, s, test.enc)\n+\t\t}\n+\t}\n }\n \n-func TestEncodeToString(t *testing.T) {\n-\tfor i, test := range encodeStringTests {\n-\t\ts := EncodeToString(test.in)\n-\t\tif s != test.out {\n-\t\t\tt.Errorf(\"#%d got:%s want:%s\", i, s, test.out)\n+func TestDecodeString(t *testing.T) {\n+\tfor i, test := range encDecTests {\n+\t\tdst, err := DecodeString(test.enc)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"#%d: unexpected err value: %s\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif bytes.Compare(dst, test.dec) != 0 {\n+\t\t\tt.Errorf(\"#%d: got: %#v want: #%v\", i, dst, test.dec)\n \t\t}\n \t}\n }\n \n-type decodeStringTest struct {\n+type errTest struct {\n \tin  string\n-\tout []byte\n-\tok  bool\n+\terr string\n }\n \n-var decodeStringTests = []decodeStringTest{\n-\t{\"\", []byte{}, true},\n-\t{\"0\", []byte{}, false},\n-\t{\"00\", []byte{0}, true},\n-\t{\"0\\x01\", []byte{}, false},\n-\t{\"0g\", []byte{}, false},\n-\t{\"00ff00\", []byte{0, 255, 0}, true},\n-\t{\"0000ff\", []byte{0, 0, 255}, true},\n+var errTests = []errTest{\n+\t{\"0\", \"encoding/hex: odd length hex string\"},\n+\t{\"0g\", \"encoding/hex: invalid byte: U+0067 'g'\"},\n+\t{\"0\\x01\", \"encoding/hex: invalid byte: U+0001\"},\n }\n \n-func TestDecodeString(t *testing.T) {\n-\tfor i, test := range decodeStringTests {\n-\t\tdst, err := DecodeString(test.in)\n-\t\tif test.ok != (err == nil) {\n-\t\t\tt.Errorf(\"#%d: unexpected err value: %s\", i, err)\n+func TestInvalidErr(t *testing.T) {\n+\tfor i, test := range errTests {\n+\t\tdst := make([]byte, DecodedLen(len(test.in)))\n+\t\t_, err := Decode(dst, []byte(test.in))\n+\t\tif err == nil {\n+\t\t\tt.Errorf(\"#%d: expected error; got none\")\n+\t\t} else if err.Error() != test.err {\n+\t\t\tt.Errorf(\"#%d: got: %v want: %v\", i, err, test.err)\n \t\t}\n-\t\tif err == nil && bytes.Compare(dst, test.out) != 0 {\n-\t\t\tt.Errorf(\"#%d: got: %#v want: #%v\", i, dst, test.out)\n+\t}\n+}\n+\n+func TestInvalidStringErr(t *testing.T) {\n+\tfor i, test := range errTests {\n+\t\t_, err := DecodeString(test.in)\n+\t\tif err == nil {\n+\t\t\tt.Errorf(\"#%d: expected error; got none\")\n+\t\t} else if err.Error() != test.err {\n+\t\t\tt.Errorf(\"#%d: got: %v want: %v\", i, err, test.err)\n \t\t}\n \t}\n }\n@@ -155,8 +112,8 @@ func TestDumper(t *testing.T) {\n \t}\n \n \tfor stride := 1; stride < len(in); stride++ {\n-\t\tout := bytes.NewBuffer(nil)\n-\t\tdumper := Dumper(out)\n+\t\tvar out bytes.Buffer\n+\t\tdumper := Dumper(&out)\n \t\tdone := 0\n \t\tfor done < len(in) {\n \t\t\ttodo := done + stride"}, {"sha": "775becfa7c9be2699e127a088f1cc3f5feeaefa6", "filename": "libgo/go/encoding/json/decode_test.go", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -598,3 +598,24 @@ var pallValueIndent = `{\n }`\n \n var pallValueCompact = strings.Map(noSpace, pallValueIndent)\n+\n+func TestRefUnmarshal(t *testing.T) {\n+\ttype S struct {\n+\t\t// Ref is defined in encode_test.go.\n+\t\tR0 Ref\n+\t\tR1 *Ref\n+\t}\n+\twant := S{\n+\t\tR0: 12,\n+\t\tR1: new(Ref),\n+\t}\n+\t*want.R1 = 12\n+\n+\tvar got S\n+\tif err := Unmarshal([]byte(`{\"R0\":\"ref\",\"R1\":\"ref\"}`), &got); err != nil {\n+\t\tt.Fatalf(\"Unmarshal: %v\", err)\n+\t}\n+\tif !reflect.DeepEqual(got, want) {\n+\t\tt.Errorf(\"got %+v, want %+v\", got, want)\n+\t}\n+}"}, {"sha": "83e73c09cb41c8d3bb80b5dae92e5c29a6487cb4", "filename": "libgo/go/encoding/json/encode.go", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -262,8 +262,18 @@ func (e *encodeState) reflectValueQuoted(v reflect.Value, quoted bool) {\n \t\treturn\n \t}\n \n-\tif j, ok := v.Interface().(Marshaler); ok && (v.Kind() != reflect.Ptr || !v.IsNil()) {\n-\t\tb, err := j.MarshalJSON()\n+\tm, ok := v.Interface().(Marshaler)\n+\tif !ok {\n+\t\t// T doesn't match the interface. Check against *T too.\n+\t\tif v.Kind() != reflect.Ptr && v.CanAddr() {\n+\t\t\tm, ok = v.Addr().Interface().(Marshaler)\n+\t\t\tif ok {\n+\t\t\t\tv = v.Addr()\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif ok && (v.Kind() != reflect.Ptr || !v.IsNil()) {\n+\t\tb, err := m.MarshalJSON()\n \t\tif err == nil {\n \t\t\t// copy JSON into buffer, checking validity.\n \t\t\terr = Compact(&e.Buffer, b)"}, {"sha": "7a726a91c47bb47816e42e761de3944ebb4ca8ea", "filename": "libgo/go/encoding/json/encode_test.go", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -126,3 +126,44 @@ func TestUnsupportedValues(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// Ref has Marshaler and Unmarshaler methods with pointer receiver.\n+type Ref int\n+\n+func (*Ref) MarshalJSON() ([]byte, error) {\n+\treturn []byte(`\"ref\"`), nil\n+}\n+\n+func (r *Ref) UnmarshalJSON([]byte) error {\n+\t*r = 12\n+\treturn nil\n+}\n+\n+// Val has Marshaler methods with value receiver.\n+type Val int\n+\n+func (Val) MarshalJSON() ([]byte, error) {\n+\treturn []byte(`\"val\"`), nil\n+}\n+\n+func TestRefValMarshal(t *testing.T) {\n+\tvar s = struct {\n+\t\tR0 Ref\n+\t\tR1 *Ref\n+\t\tV0 Val\n+\t\tV1 *Val\n+\t}{\n+\t\tR0: 12,\n+\t\tR1: new(Ref),\n+\t\tV0: 13,\n+\t\tV1: new(Val),\n+\t}\n+\tconst want = `{\"R0\":\"ref\",\"R1\":\"ref\",\"V0\":\"val\",\"V1\":\"val\"}`\n+\tb, err := Marshal(&s)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Marshal: %v\", err)\n+\t}\n+\tif got := string(b); got != want {\n+\t\tt.Errorf(\"got %q, want %q\", got, want)\n+\t}\n+}"}, {"sha": "054b6b3d564e1dbc7d96ee19276fd150f69c83a9", "filename": "libgo/go/encoding/json/scanner.go", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -185,18 +185,9 @@ func isSpace(c rune) bool {\n \treturn c == ' ' || c == '\\t' || c == '\\r' || c == '\\n'\n }\n \n-// NOTE(rsc): The various instances of\n-//\n-//\tif c <= ' ' && (c == ' ' || c == '\\t' || c == '\\r' || c == '\\n')\n-//\n-// below should all be if c <= ' ' && isSpace(c), but inlining\n-// the checks makes a significant difference (>10%) in tight loops\n-// such as nextValue.  These should be rewritten with the clearer\n-// function call once 6g knows to inline the call.\n-\n // stateBeginValueOrEmpty is the state after reading `[`.\n func stateBeginValueOrEmpty(s *scanner, c int) int {\n-\tif c <= ' ' && (c == ' ' || c == '\\t' || c == '\\r' || c == '\\n') {\n+\tif c <= ' ' && isSpace(rune(c)) {\n \t\treturn scanSkipSpace\n \t}\n \tif c == ']' {\n@@ -207,7 +198,7 @@ func stateBeginValueOrEmpty(s *scanner, c int) int {\n \n // stateBeginValue is the state at the beginning of the input.\n func stateBeginValue(s *scanner, c int) int {\n-\tif c <= ' ' && (c == ' ' || c == '\\t' || c == '\\r' || c == '\\n') {\n+\tif c <= ' ' && isSpace(rune(c)) {\n \t\treturn scanSkipSpace\n \t}\n \tswitch c {\n@@ -247,7 +238,7 @@ func stateBeginValue(s *scanner, c int) int {\n \n // stateBeginStringOrEmpty is the state after reading `{`.\n func stateBeginStringOrEmpty(s *scanner, c int) int {\n-\tif c <= ' ' && (c == ' ' || c == '\\t' || c == '\\r' || c == '\\n') {\n+\tif c <= ' ' && isSpace(rune(c)) {\n \t\treturn scanSkipSpace\n \t}\n \tif c == '}' {\n@@ -260,7 +251,7 @@ func stateBeginStringOrEmpty(s *scanner, c int) int {\n \n // stateBeginString is the state after reading `{\"key\": value,`.\n func stateBeginString(s *scanner, c int) int {\n-\tif c <= ' ' && (c == ' ' || c == '\\t' || c == '\\r' || c == '\\n') {\n+\tif c <= ' ' && isSpace(rune(c)) {\n \t\treturn scanSkipSpace\n \t}\n \tif c == '\"' {\n@@ -280,7 +271,7 @@ func stateEndValue(s *scanner, c int) int {\n \t\ts.endTop = true\n \t\treturn stateEndTop(s, c)\n \t}\n-\tif c <= ' ' && (c == ' ' || c == '\\t' || c == '\\r' || c == '\\n') {\n+\tif c <= ' ' && isSpace(rune(c)) {\n \t\ts.step = stateEndValue\n \t\treturn scanSkipSpace\n \t}"}, {"sha": "38afbb42aff1ff1fa103d88b1a843f3c0eea47f3", "filename": "libgo/go/encoding/pem/pem.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fpem%2Fpem.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fpem%2Fpem.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fpem%2Fpem.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -251,7 +251,7 @@ func Encode(out io.Writer, b *Block) (err error) {\n }\n \n func EncodeToMemory(b *Block) []byte {\n-\tbuf := bytes.NewBuffer(nil)\n-\tEncode(buf, b)\n+\tvar buf bytes.Buffer\n+\tEncode(&buf, b)\n \treturn buf.Bytes()\n }"}, {"sha": "9ae1578a501a30ce823163c0a318ed027c214c29", "filename": "libgo/go/encoding/pem/pem_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fpem%2Fpem_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fpem%2Fpem_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fpem%2Fpem_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -73,7 +73,7 @@ var lineBreakerTests = []lineBreakerTest{\n \n func TestLineBreaker(t *testing.T) {\n \tfor i, test := range lineBreakerTests {\n-\t\tbuf := bytes.NewBuffer(nil)\n+\t\tbuf := new(bytes.Buffer)\n \t\tvar breaker lineBreaker\n \t\tbreaker.out = buf\n \t\t_, err := breaker.Write([]byte(test.in))\n@@ -93,7 +93,7 @@ func TestLineBreaker(t *testing.T) {\n \t}\n \n \tfor i, test := range lineBreakerTests {\n-\t\tbuf := bytes.NewBuffer(nil)\n+\t\tbuf := new(bytes.Buffer)\n \t\tvar breaker lineBreaker\n \t\tbreaker.out = buf\n "}, {"sha": "0f6c0f0795d7734467cfca0822612548181d180a", "filename": "libgo/go/encoding/xml/marshal_test.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -532,6 +532,11 @@ var marshalTests = []struct {\n \t\tValue:     &NameInField{Name{Space: \"ns\", Local: \"foo\"}},\n \t\tExpectXML: `<NameInField><foo xmlns=\"ns\"></foo></NameInField>`,\n \t},\n+\t{\n+\t\tValue:         &NameInField{Name{Space: \"ns\", Local: \"foo\"}},\n+\t\tExpectXML:     `<NameInField><foo xmlns=\"ns\"><ignore></ignore></foo></NameInField>`,\n+\t\tUnmarshalOnly: true,\n+\t},\n \n \t// Marshaling zero xml.Name uses the tag or field name.\n \t{"}, {"sha": "bde875a012303ab840bbfb2ddc2d83eeb98b3c49", "filename": "libgo/go/encoding/xml/read.go", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -265,12 +265,13 @@ func (p *Decoder) unmarshal(val reflect.Value, start *StartElement) error {\n \t\tsaveData = v\n \n \tcase reflect.Struct:\n-\t\tsv = v\n-\t\ttyp := sv.Type()\n+\t\ttyp := v.Type()\n \t\tif typ == nameType {\n \t\t\tv.Set(reflect.ValueOf(start.Name))\n \t\t\tbreak\n \t\t}\n+\n+\t\tsv = v\n \t\ttinfo, err = getTypeInfo(typ)\n \t\tif err != nil {\n \t\t\treturn err\n@@ -541,19 +542,21 @@ Loop:\n \tpanic(\"unreachable\")\n }\n \n-// Have already read a start element.\n-// Read tokens until we find the end element.\n-// Token is taking care of making sure the\n-// end element matches the start element we saw.\n-func (p *Decoder) Skip() error {\n+// Skip reads tokens until it has consumed the end element\n+// matching the most recent start element already consumed.\n+// It recurs if it encounters a start element, so it can be used to\n+// skip nested structures.\n+// It returns nil if it finds an end element matching the start\n+// element; otherwise it returns an error describing the problem.\n+func (d *Decoder) Skip() error {\n \tfor {\n-\t\ttok, err := p.Token()\n+\t\ttok, err := d.Token()\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n \t\tswitch tok.(type) {\n \t\tcase StartElement:\n-\t\t\tif err := p.Skip(); err != nil {\n+\t\t\tif err := d.Skip(); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\tcase EndElement:"}, {"sha": "5475f290d18dca4d439835523954bd3662a63215", "filename": "libgo/go/encoding/xml/typeinfo.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -193,7 +193,7 @@ func structFieldInfo(typ reflect.Type, f *reflect.StructField) (*fieldInfo, erro\n \n \t// If the field type has an XMLName field, the names must match\n \t// so that the behavior of both marshalling and unmarshalling\n-\t// is straighforward and unambiguous.\n+\t// is straightforward and unambiguous.\n \tif finfo.flags&fElement != 0 {\n \t\tftyp := f.Type\n \t\txmlname := lookupXMLName(ftyp)"}, {"sha": "4bb22a4cb8098d4dc9f5f88be56df78902812912", "filename": "libgo/go/exp/ebnflint/doc.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Febnflint%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Febnflint%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Febnflint%2Fdoc.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -4,7 +4,7 @@\n \n /*\n \n-Ebnflint verifies that EBNF productions are consistent and gramatically correct.\n+Ebnflint verifies that EBNF productions are consistent and grammatically correct.\n It reads them from an HTML document such as the Go specification.\n \n Grammar productions are grouped in boxes demarcated by the HTML elements\n@@ -13,7 +13,7 @@ Grammar productions are grouped in boxes demarcated by the HTML elements\n \n \n Usage:\n-\tebnflint [--start production] [file]\n+\tgo tool ebnflint [--start production] [file]\n \n The --start flag specifies the name of the start production for\n the grammar; it defaults to \"Start\"."}, {"sha": "d54fb229d03a5b15ad60ce3e5ff068ca621b6f96", "filename": "libgo/go/exp/ebnflint/ebnflint.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Febnflint%2Febnflint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Febnflint%2Febnflint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Febnflint%2Febnflint.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -21,7 +21,7 @@ var fset = token.NewFileSet()\n var start = flag.String(\"start\", \"Start\", \"name of start production\")\n \n func usage() {\n-\tfmt.Fprintf(os.Stderr, \"usage: ebnflint [flags] [filename]\\n\")\n+\tfmt.Fprintf(os.Stderr, \"usage: go tool ebnflint [flags] [filename]\\n\")\n \tflag.PrintDefaults()\n \tos.Exit(1)\n }"}, {"sha": "8f62a8c288079fb8110b73fe1cf9afa815e2d359", "filename": "libgo/go/exp/html/escape.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fhtml%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fhtml%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fescape.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -233,8 +233,8 @@ func EscapeString(s string) string {\n \tif strings.IndexAny(s, escapedChars) == -1 {\n \t\treturn s\n \t}\n-\tbuf := bytes.NewBuffer(nil)\n-\tescape(buf, s)\n+\tvar buf bytes.Buffer\n+\tescape(&buf, s)\n \treturn buf.String()\n }\n "}, {"sha": "f3f966cf58e73771f3811ab99ffe216669892c12", "filename": "libgo/go/exp/html/parse_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fhtml%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fhtml%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Fparse_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -159,9 +159,9 @@ func dump(n *Node) (string, error) {\n \tif n == nil || len(n.Child) == 0 {\n \t\treturn \"\", nil\n \t}\n-\tb := bytes.NewBuffer(nil)\n+\tvar b bytes.Buffer\n \tfor _, child := range n.Child {\n-\t\tif err := dumpLevel(b, child, 0); err != nil {\n+\t\tif err := dumpLevel(&b, child, 0); err != nil {\n \t\t\treturn \"\", err\n \t\t}\n \t}"}, {"sha": "b5e9c2d6ea34c274effe074a8fbce9d113230019", "filename": "libgo/go/exp/html/token.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -77,8 +77,7 @@ func (t Token) tagString() string {\n \tif len(t.Attr) == 0 {\n \t\treturn t.Data\n \t}\n-\tbuf := bytes.NewBuffer(nil)\n-\tbuf.WriteString(t.Data)\n+\tbuf := bytes.NewBufferString(t.Data)\n \tfor _, a := range t.Attr {\n \t\tbuf.WriteByte(' ')\n \t\tbuf.WriteString(a.Key)"}, {"sha": "61d74006eab6154664dee216cf3759a07d5e4b71", "filename": "libgo/go/exp/html/token_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fhtml%2Ftoken_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -555,8 +555,8 @@ func TestUnescapeEscape(t *testing.T) {\n \n func TestBufAPI(t *testing.T) {\n \ts := \"0<a>1</a>2<b>3<a>4<a>5</a>6</b>7</a>8<a/>9\"\n-\tz := NewTokenizer(bytes.NewBuffer([]byte(s)))\n-\tresult := bytes.NewBuffer(nil)\n+\tz := NewTokenizer(bytes.NewBufferString(s))\n+\tvar result bytes.Buffer\n \tdepth := 0\n loop:\n \tfor {"}, {"sha": "912cf5db820c672e72888aba96db8cf134907ec8", "filename": "libgo/go/exp/inotify/inotify_linux.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -107,7 +107,11 @@ func (w *Watcher) AddWatch(path string, flags uint32) error {\n \t}\n \twd, err := syscall.InotifyAddWatch(w.fd, path, flags)\n \tif err != nil {\n-\t\treturn &os.PathError{\"inotify_add_watch\", path, err}\n+\t\treturn &os.PathError{\n+\t\t\tOp:   \"inotify_add_watch\",\n+\t\t\tPath: path,\n+\t\t\tErr:  err,\n+\t\t}\n \t}\n \n \tif !found {"}, {"sha": "5b48292cc3bc6e2cd8ec7cfcb9967e7c6eb2bbf7", "filename": "libgo/go/exp/norm/composition.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -98,10 +98,10 @@ func (rb *reorderBuffer) insertOrdered(info runeInfo) bool {\n func (rb *reorderBuffer) insert(src input, i int, info runeInfo) bool {\n \tif info.size == 3 {\n \t\tif rune := src.hangul(i); rune != 0 {\n-\t\t\treturn rb.decomposeHangul(uint32(rune))\n+\t\t\treturn rb.decomposeHangul(rune)\n \t\t}\n \t}\n-\tif info.flags.hasDecomposition() {\n+\tif info.hasDecomposition() {\n \t\tdcomp := rb.f.decompose(src, i)\n \t\trb.tmpBytes = inputBytes(dcomp)\n \t\tfor i := 0; i < len(dcomp); {\n@@ -126,26 +126,26 @@ func (rb *reorderBuffer) insert(src input, i int, info runeInfo) bool {\n }\n \n // appendRune inserts a rune at the end of the buffer. It is used for Hangul.\n-func (rb *reorderBuffer) appendRune(r uint32) {\n+func (rb *reorderBuffer) appendRune(r rune) {\n \tbn := rb.nbyte\n \tsz := utf8.EncodeRune(rb.byte[bn:], rune(r))\n \trb.nbyte += utf8.UTFMax\n-\trb.rune[rb.nrune] = runeInfo{bn, uint8(sz), 0, 0}\n+\trb.rune[rb.nrune] = runeInfo{pos: bn, size: uint8(sz)}\n \trb.nrune++\n }\n \n // assignRune sets a rune at position pos. It is used for Hangul and recomposition.\n-func (rb *reorderBuffer) assignRune(pos int, r uint32) {\n+func (rb *reorderBuffer) assignRune(pos int, r rune) {\n \tbn := rb.rune[pos].pos\n \tsz := utf8.EncodeRune(rb.byte[bn:], rune(r))\n-\trb.rune[pos] = runeInfo{bn, uint8(sz), 0, 0}\n+\trb.rune[pos] = runeInfo{pos: bn, size: uint8(sz)}\n }\n \n // runeAt returns the rune at position n. It is used for Hangul and recomposition.\n-func (rb *reorderBuffer) runeAt(n int) uint32 {\n+func (rb *reorderBuffer) runeAt(n int) rune {\n \tinf := rb.rune[n]\n \tr, _ := utf8.DecodeRune(rb.byte[inf.pos : inf.pos+inf.size])\n-\treturn uint32(r)\n+\treturn r\n }\n \n // bytesAt returns the UTF-8 encoding of the rune at position n.\n@@ -237,7 +237,7 @@ func isHangulWithoutJamoT(b []byte) bool {\n // decomposeHangul algorithmically decomposes a Hangul rune into\n // its Jamo components.\n // See http://unicode.org/reports/tr15/#Hangul for details on decomposing Hangul.\n-func (rb *reorderBuffer) decomposeHangul(r uint32) bool {\n+func (rb *reorderBuffer) decomposeHangul(r rune) bool {\n \tb := rb.rune[:]\n \tn := rb.nrune\n \tif n+3 > len(b) {\n@@ -319,7 +319,7 @@ func (rb *reorderBuffer) compose() {\n \t\t// get the info for the combined character. This is more\n \t\t// expensive than using the filter. Using combinesBackward()\n \t\t// is safe.\n-\t\tif ii.flags.combinesBackward() {\n+\t\tif ii.combinesBackward() {\n \t\t\tcccB := b[k-1].ccc\n \t\t\tcccC := ii.ccc\n \t\t\tblocked := false // b[i] blocked by starter or greater or equal CCC?"}, {"sha": "bf4443c991609283077ec7993a62c4ec70ddf1e6", "filename": "libgo/go/exp/norm/forminfo.go", "status": "modified", "additions": 21, "deletions": 39, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fforminfo.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -14,7 +14,6 @@ type runeInfo struct {\n }\n \n // functions dispatchable per form\n-type boundaryFunc func(f *formInfo, info runeInfo) bool\n type lookupFunc func(b input, i int) runeInfo\n type decompFunc func(b input, i int) []byte\n \n@@ -24,10 +23,8 @@ type formInfo struct {\n \n \tcomposing, compatibility bool // form type\n \n-\tdecompose      decompFunc\n-\tinfo           lookupFunc\n-\tboundaryBefore boundaryFunc\n-\tboundaryAfter  boundaryFunc\n+\tdecompose decompFunc\n+\tinfo      lookupFunc\n }\n \n var formTable []*formInfo\n@@ -49,27 +46,17 @@ func init() {\n \t\t}\n \t\tif Form(i) == NFC || Form(i) == NFKC {\n \t\t\tf.composing = true\n-\t\t\tf.boundaryBefore = compBoundaryBefore\n-\t\t\tf.boundaryAfter = compBoundaryAfter\n-\t\t} else {\n-\t\t\tf.boundaryBefore = decompBoundary\n-\t\t\tf.boundaryAfter = decompBoundary\n \t\t}\n \t}\n }\n \n-func decompBoundary(f *formInfo, info runeInfo) bool {\n-\tif info.ccc == 0 && info.flags.isYesD() { // Implies isHangul(b) == true\n-\t\treturn true\n-\t}\n-\t// We assume that the CCC of the first character in a decomposition\n-\t// is always non-zero if different from info.ccc and that we can return\n-\t// false at this point. This is verified by maketables.\n-\treturn false\n-}\n-\n-func compBoundaryBefore(f *formInfo, info runeInfo) bool {\n-\tif info.ccc == 0 && !info.flags.combinesBackward() {\n+// We do not distinguish between boundaries for NFC, NFD, etc. to avoid\n+// unexpected behavior for the user.  For example, in NFD, there is a boundary\n+// after 'a'.  However, a might combine with modifiers, so from the application's\n+// perspective it is not a good boundary. We will therefore always use the \n+// boundaries for the combining variants.\n+func (i runeInfo) boundaryBefore() bool {\n+\tif i.ccc == 0 && !i.combinesBackward() {\n \t\treturn true\n \t}\n \t// We assume that the CCC of the first character in a decomposition\n@@ -78,15 +65,13 @@ func compBoundaryBefore(f *formInfo, info runeInfo) bool {\n \treturn false\n }\n \n-func compBoundaryAfter(f *formInfo, info runeInfo) bool {\n-\t// This misses values where the last char in a decomposition is a\n-\t// boundary such as Hangul with JamoT.\n-\treturn info.isInert()\n+func (i runeInfo) boundaryAfter() bool {\n+\treturn i.isInert()\n }\n \n // We pack quick check data in 4 bits:\n //   0:    NFD_QC Yes (0) or No (1). No also means there is a decomposition.\n-//   1..2: NFC_QC Yes(00), No (01), or Maybe (11)\n+//   1..2: NFC_QC Yes(00), No (10), or Maybe (11)\n //   3:    Combines forward  (0 == false, 1 == true)\n // \n // When all 4 bits are zero, the character is inert, meaning it is never\n@@ -95,23 +80,20 @@ func compBoundaryAfter(f *formInfo, info runeInfo) bool {\n // We pack the bits for both NFC/D and NFKC/D in one byte.\n type qcInfo uint8\n \n-func (i qcInfo) isYesC() bool  { return i&0x2 == 0 }\n-func (i qcInfo) isNoC() bool   { return i&0x6 == 0x2 }\n-func (i qcInfo) isMaybe() bool { return i&0x4 != 0 }\n-func (i qcInfo) isYesD() bool  { return i&0x1 == 0 }\n-func (i qcInfo) isNoD() bool   { return i&0x1 != 0 }\n+func (i runeInfo) isYesC() bool { return i.flags&0x4 == 0 }\n+func (i runeInfo) isYesD() bool { return i.flags&0x1 == 0 }\n \n-func (i qcInfo) combinesForward() bool  { return i&0x8 != 0 }\n-func (i qcInfo) combinesBackward() bool { return i&0x4 != 0 } // == isMaybe\n-func (i qcInfo) hasDecomposition() bool { return i&0x1 != 0 } // == isNoD\n+func (i runeInfo) combinesForward() bool  { return i.flags&0x8 != 0 }\n+func (i runeInfo) combinesBackward() bool { return i.flags&0x2 != 0 } // == isMaybe\n+func (i runeInfo) hasDecomposition() bool { return i.flags&0x1 != 0 } // == isNoD\n \n func (r runeInfo) isInert() bool {\n \treturn r.flags&0xf == 0 && r.ccc == 0\n }\n \n // Wrappers for tables.go\n \n-// The 16-bit value of the decompostion tries is an index into a byte\n+// The 16-bit value of the decomposition tries is an index into a byte\n // array of UTF-8 decomposition sequences. The first byte is the number\n // of bytes in the decomposition (excluding this length byte). The actual\n // sequence starts at the offset+1.\n@@ -137,7 +119,7 @@ func decomposeNFKC(s input, i int) []byte {\n // Note that the recomposition map for NFC and NFKC are identical.\n \n // combine returns the combined rune or 0 if it doesn't exist.\n-func combine(a, b uint32) uint32 {\n+func combine(a, b rune) rune {\n \tkey := uint32(uint16(a))<<16 + uint32(uint16(b))\n \treturn recompMap[key]\n }\n@@ -148,10 +130,10 @@ func combine(a, b uint32) uint32 {\n //   12..15  qcInfo for NFKC/NFKD\n func lookupInfoNFC(b input, i int) runeInfo {\n \tv, sz := b.charinfo(i)\n-\treturn runeInfo{0, uint8(sz), uint8(v), qcInfo(v >> 8)}\n+\treturn runeInfo{size: uint8(sz), ccc: uint8(v), flags: qcInfo(v >> 8)}\n }\n \n func lookupInfoNFKC(b input, i int) runeInfo {\n \tv, sz := b.charinfo(i)\n-\treturn runeInfo{0, uint8(sz), uint8(v), qcInfo(v >> 12)}\n+\treturn runeInfo{size: uint8(sz), ccc: uint8(v), flags: qcInfo(v >> 12)}\n }"}, {"sha": "7276c66cc123ff00525a721d7801c65ab999cc77", "filename": "libgo/go/exp/norm/input.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fnorm%2Finput.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fnorm%2Finput.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Finput.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -14,7 +14,7 @@ type input interface {\n \tcharinfo(p int) (uint16, int)\n \tdecomposeNFC(p int) uint16\n \tdecomposeNFKC(p int) uint16\n-\thangul(p int) uint32\n+\thangul(p int) rune\n }\n \n type inputString string\n@@ -54,12 +54,12 @@ func (s inputString) decomposeNFKC(p int) uint16 {\n \treturn nfkcDecompTrie.lookupStringUnsafe(string(s[p:]))\n }\n \n-func (s inputString) hangul(p int) uint32 {\n+func (s inputString) hangul(p int) rune {\n \tif !isHangulString(string(s[p:])) {\n \t\treturn 0\n \t}\n \trune, _ := utf8.DecodeRuneInString(string(s[p:]))\n-\treturn uint32(rune)\n+\treturn rune\n }\n \n type inputBytes []byte\n@@ -96,10 +96,10 @@ func (s inputBytes) decomposeNFKC(p int) uint16 {\n \treturn nfkcDecompTrie.lookupUnsafe(s[p:])\n }\n \n-func (s inputBytes) hangul(p int) uint32 {\n+func (s inputBytes) hangul(p int) rune {\n \tif !isHangul(s[p:]) {\n \t\treturn 0\n \t}\n \trune, _ := utf8.DecodeRune(s[p:])\n-\treturn uint32(rune)\n+\treturn rune\n }"}, {"sha": "43e1429c1b1b1b415719b38ace2ca90ab3beb3ca", "filename": "libgo/go/exp/norm/maketables.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -562,7 +562,7 @@ func makeEntry(f *FormInfo) uint16 {\n \tswitch f.quickCheck[MComposed] {\n \tcase QCYes:\n \tcase QCNo:\n-\t\te |= 0x2\n+\t\te |= 0x4\n \tcase QCMaybe:\n \t\te |= 0x6\n \tdefault:\n@@ -718,7 +718,7 @@ func makeTables() {\n \t\tsz := nrentries * 8\n \t\tsize += sz\n \t\tfmt.Printf(\"// recompMap: %d bytes (entries only)\\n\", sz)\n-\t\tfmt.Println(\"var recompMap = map[uint32]uint32{\")\n+\t\tfmt.Println(\"var recompMap = map[uint32]rune{\")\n \t\tfor i, c := range chars {\n \t\t\tf := c.forms[FCanonical]\n \t\t\td := f.decomp"}, {"sha": "26bb4a0dc47b8de3bb74893840898ef5365db803", "filename": "libgo/go/exp/norm/normalize.go", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -188,11 +188,11 @@ func doAppend(rb *reorderBuffer, out []byte, p int) []byte {\n \t\tvar info runeInfo\n \t\tif p < n {\n \t\t\tinfo = fd.info(src, p)\n-\t\t\tif p == 0 && !fd.boundaryBefore(fd, info) {\n+\t\t\tif p == 0 && !info.boundaryBefore() {\n \t\t\t\tout = decomposeToLastBoundary(rb, out)\n \t\t\t}\n \t\t}\n-\t\tif info.size == 0 || fd.boundaryBefore(fd, info) {\n+\t\tif info.size == 0 || info.boundaryBefore() {\n \t\t\tif fd.composing {\n \t\t\t\trb.compose()\n \t\t\t}\n@@ -257,11 +257,11 @@ func quickSpan(rb *reorderBuffer, i int) int {\n \t\t}\n \t\tcc := info.ccc\n \t\tif rb.f.composing {\n-\t\t\tif !info.flags.isYesC() {\n+\t\t\tif !info.isYesC() {\n \t\t\t\tbreak\n \t\t\t}\n \t\t} else {\n-\t\t\tif !info.flags.isYesD() {\n+\t\t\tif !info.isYesD() {\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n@@ -316,13 +316,13 @@ func firstBoundary(rb *reorderBuffer) int {\n \t}\n \tfd := &rb.f\n \tinfo := fd.info(src, i)\n-\tfor n := 0; info.size != 0 && !fd.boundaryBefore(fd, info); {\n+\tfor n := 0; info.size != 0 && !info.boundaryBefore(); {\n \t\ti += int(info.size)\n \t\tif n++; n >= maxCombiningChars {\n \t\t\treturn i\n \t\t}\n \t\tif i >= nsrc {\n-\t\t\tif !fd.boundaryAfter(fd, info) {\n+\t\t\tif !info.boundaryAfter() {\n \t\t\t\treturn -1\n \t\t\t}\n \t\t\treturn nsrc\n@@ -368,11 +368,11 @@ func lastBoundary(fd *formInfo, b []byte) int {\n \tif p+int(info.size) != i { // trailing non-starter bytes: illegal UTF-8\n \t\treturn i\n \t}\n-\tif fd.boundaryAfter(fd, info) {\n+\tif info.boundaryAfter() {\n \t\treturn i\n \t}\n \ti = p\n-\tfor n := 0; i >= 0 && !fd.boundaryBefore(fd, info); {\n+\tfor n := 0; i >= 0 && !info.boundaryBefore(); {\n \t\tinfo, p = lastRuneStart(fd, b[:i])\n \t\tif n++; n >= maxCombiningChars {\n \t\t\treturn len(b)\n@@ -404,7 +404,7 @@ func decomposeSegment(rb *reorderBuffer, sp int) int {\n \t\t\tbreak\n \t\t}\n \t\tinfo = rb.f.info(rb.src, sp)\n-\t\tbound := rb.f.boundaryBefore(&rb.f, info)\n+\t\tbound := info.boundaryBefore()\n \t\tif bound || info.size == 0 {\n \t\t\tbreak\n \t\t}\n@@ -419,7 +419,7 @@ func lastRuneStart(fd *formInfo, buf []byte) (runeInfo, int) {\n \tfor ; p >= 0 && !utf8.RuneStart(buf[p]); p-- {\n \t}\n \tif p < 0 {\n-\t\treturn runeInfo{0, 0, 0, 0}, -1\n+\t\treturn runeInfo{}, -1\n \t}\n \treturn fd.info(inputBytes(buf), p), p\n }\n@@ -433,21 +433,21 @@ func decomposeToLastBoundary(rb *reorderBuffer, buf []byte) []byte {\n \t\t// illegal trailing continuation bytes\n \t\treturn buf\n \t}\n-\tif rb.f.boundaryAfter(fd, info) {\n+\tif info.boundaryAfter() {\n \t\treturn buf\n \t}\n \tvar add [maxBackRunes]runeInfo // stores runeInfo in reverse order\n \tadd[0] = info\n \tpadd := 1\n \tn := 1\n \tp := len(buf) - int(info.size)\n-\tfor ; p >= 0 && !rb.f.boundaryBefore(fd, info); p -= int(info.size) {\n+\tfor ; p >= 0 && !info.boundaryBefore(); p -= int(info.size) {\n \t\tinfo, i = lastRuneStart(fd, buf[:p])\n \t\tif int(info.size) != p-i {\n \t\t\tbreak\n \t\t}\n \t\t// Check that decomposition doesn't result in overflow.\n-\t\tif info.flags.hasDecomposition() {\n+\t\tif info.hasDecomposition() {\n \t\t\tdcomp := rb.f.decompose(inputBytes(buf), p-int(info.size))\n \t\t\tfor i := 0; i < len(dcomp); {\n \t\t\t\tinf := rb.f.info(inputBytes(dcomp), i)"}, {"sha": "c7d5e08fca0a6321d7155a8f9fa057c39655d91a", "filename": "libgo/go/exp/norm/normalize_test.go", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -495,11 +495,11 @@ func TestAppend(t *testing.T) {\n \trunAppendTests(t, \"TestString\", NFKC, stringF, appendTests)\n }\n \n-func doFormBenchmark(b *testing.B, f Form, s string) {\n+func doFormBenchmark(b *testing.B, inf, f Form, s string) {\n \tb.StopTimer()\n-\tin := []byte(s)\n+\tin := inf.Bytes([]byte(s))\n \tbuf := make([]byte, 2*len(in))\n-\tb.SetBytes(int64(len(s)))\n+\tb.SetBytes(int64(len(in)))\n \tb.StartTimer()\n \tfor i := 0; i < b.N; i++ {\n \t\tbuf = f.Append(buf[0:0], in...)\n@@ -510,16 +510,43 @@ func doFormBenchmark(b *testing.B, f Form, s string) {\n var ascii = strings.Repeat(\"There is nothing to change here! \", 500)\n \n func BenchmarkNormalizeAsciiNFC(b *testing.B) {\n-\tdoFormBenchmark(b, NFC, ascii)\n+\tdoFormBenchmark(b, NFC, NFC, ascii)\n }\n func BenchmarkNormalizeAsciiNFD(b *testing.B) {\n-\tdoFormBenchmark(b, NFD, ascii)\n+\tdoFormBenchmark(b, NFC, NFD, ascii)\n }\n func BenchmarkNormalizeAsciiNFKC(b *testing.B) {\n-\tdoFormBenchmark(b, NFKC, ascii)\n+\tdoFormBenchmark(b, NFC, NFKC, ascii)\n }\n func BenchmarkNormalizeAsciiNFKD(b *testing.B) {\n-\tdoFormBenchmark(b, NFKD, ascii)\n+\tdoFormBenchmark(b, NFC, NFKD, ascii)\n+}\n+\n+func BenchmarkNormalizeNFC2NFC(b *testing.B) {\n+\tdoFormBenchmark(b, NFC, NFC, txt_all)\n+}\n+func BenchmarkNormalizeNFC2NFD(b *testing.B) {\n+\tdoFormBenchmark(b, NFC, NFD, txt_all)\n+}\n+func BenchmarkNormalizeNFD2NFC(b *testing.B) {\n+\tdoFormBenchmark(b, NFD, NFC, txt_all)\n+}\n+func BenchmarkNormalizeNFD2NFD(b *testing.B) {\n+\tdoFormBenchmark(b, NFD, NFD, txt_all)\n+}\n+\n+// Hangul is often special-cased, so we test it separately.\n+func BenchmarkNormalizeHangulNFC2NFC(b *testing.B) {\n+\tdoFormBenchmark(b, NFC, NFC, txt_kr)\n+}\n+func BenchmarkNormalizeHangulNFC2NFD(b *testing.B) {\n+\tdoFormBenchmark(b, NFC, NFD, txt_kr)\n+}\n+func BenchmarkNormalizeHangulNFD2NFC(b *testing.B) {\n+\tdoFormBenchmark(b, NFD, NFC, txt_kr)\n+}\n+func BenchmarkNormalizeHangulNFD2NFD(b *testing.B) {\n+\tdoFormBenchmark(b, NFD, NFD, txt_kr)\n }\n \n func doTextBenchmark(b *testing.B, s string) {\n@@ -657,3 +684,6 @@ const txt_cn = `\u60a8\u53ef\u4ee5\u81ea\u7531\uff1a \u590d\u5236\u3001\u53d1\u884c\u3001\u5c55\u89c8\u3001\u8868\u6f14\u3001\u653e\u6620\u3001\n \u7f72\u540d \u2014 \u60a8\u5fc5\u987b\u6309\u7167\u4f5c\u8005\u6216\u8005\u8bb8\u53ef\u4eba\u6307\u5b9a\u7684\u65b9\u5f0f\u5bf9\u4f5c\u54c1\u8fdb\u884c\u7f72\u540d\u3002\n \u76f8\u540c\u65b9\u5f0f\u5171\u4eab \u2014 \u5982\u679c\u60a8\u6539\u53d8\u3001\u8f6c\u6362\u672c\u4f5c\u54c1\u6216\u8005\u4ee5\u672c\u4f5c\u54c1\u4e3a\u57fa\u7840\u8fdb\u884c\u521b\u4f5c\uff0c\n \u60a8\u53ea\u80fd\u91c7\u7528\u4e0e\u672c\u534f\u8bae\u76f8\u540c\u7684\u8bb8\u53ef\u534f\u8bae\u53d1\u5e03\u57fa\u4e8e\u672c\u4f5c\u54c1\u7684\u6f14\u7ece\u4f5c\u54c1\u3002`\n+\n+const txt_cjk = txt_cn + txt_jp + txt_kr\n+const txt_all = txt_vn + twoByteUtf8 + threeByteUtf8 + txt_cjk"}, {"sha": "02a481b3b3d29149a44093b6a4d4fd6adf35dfd6", "filename": "libgo/go/exp/norm/tables.go", "status": "modified", "additions": 244, "deletions": 244, "changes": 488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftables.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -4661,7 +4661,7 @@ var nfkcDecompLookup = [960]uint8{\n var nfkcDecompTrie = trie{nfkcDecompLookup[:], nfkcDecompValues[:], nfkcDecompSparseValues[:], nfkcDecompSparseOffset[:], 66}\n \n // recompMap: 7448 bytes (entries only)\n-var recompMap = map[uint32]uint32{\n+var recompMap = map[uint32]rune{\n \t0x00410300: 0x00C0,\n \t0x00410301: 0x00C1,\n \t0x00410302: 0x00C2,\n@@ -5637,20 +5637,20 @@ var charInfoValues = [1024]uint16{\n \t0x0136: 0x0001, 0x0137: 0x0001, 0x0138: 0x6601, 0x0139: 0x00dc, 0x013a: 0x00dc, 0x013b: 0x00dc,\n \t0x013c: 0x00dc, 0x013d: 0x00e6, 0x013e: 0x00e6, 0x013f: 0x00e6,\n \t// Block 0x5, offset 0x140\n-\t0x0140: 0x33e6, 0x0141: 0x33e6, 0x0142: 0x66e6, 0x0143: 0x33e6, 0x0144: 0x33e6, 0x0145: 0x66f0,\n+\t0x0140: 0x55e6, 0x0141: 0x55e6, 0x0142: 0x66e6, 0x0143: 0x55e6, 0x0144: 0x55e6, 0x0145: 0x66f0,\n \t0x0146: 0x00e6, 0x0147: 0x00dc, 0x0148: 0x00dc, 0x0149: 0x00dc, 0x014a: 0x00e6, 0x014b: 0x00e6,\n \t0x014c: 0x00e6, 0x014d: 0x00dc, 0x014e: 0x00dc, 0x0150: 0x00e6, 0x0151: 0x00e6,\n \t0x0152: 0x00e6, 0x0153: 0x00dc, 0x0154: 0x00dc, 0x0155: 0x00dc, 0x0156: 0x00dc, 0x0157: 0x00e6,\n \t0x0158: 0x00e8, 0x0159: 0x00dc, 0x015a: 0x00dc, 0x015b: 0x00e6, 0x015c: 0x00e9, 0x015d: 0x00ea,\n \t0x015e: 0x00ea, 0x015f: 0x00e9, 0x0160: 0x00ea, 0x0161: 0x00ea, 0x0162: 0x00e9, 0x0163: 0x00e6,\n \t0x0164: 0x00e6, 0x0165: 0x00e6, 0x0166: 0x00e6, 0x0167: 0x00e6, 0x0168: 0x00e6, 0x0169: 0x00e6,\n \t0x016a: 0x00e6, 0x016b: 0x00e6, 0x016c: 0x00e6, 0x016d: 0x00e6, 0x016e: 0x00e6, 0x016f: 0x00e6,\n-\t0x0174: 0x3300,\n-\t0x017a: 0x3000,\n-\t0x017e: 0x3300,\n+\t0x0174: 0x5500,\n+\t0x017a: 0x5000,\n+\t0x017e: 0x5500,\n \t// Block 0x6, offset 0x180\n-\t0x0184: 0x3000, 0x0185: 0x3100,\n-\t0x0186: 0x1100, 0x0187: 0x3300, 0x0188: 0x1100, 0x0189: 0x1100, 0x018a: 0x1100,\n+\t0x0184: 0x5000, 0x0185: 0x5100,\n+\t0x0186: 0x1100, 0x0187: 0x5500, 0x0188: 0x1100, 0x0189: 0x1100, 0x018a: 0x1100,\n \t0x018c: 0x1100, 0x018e: 0x1100, 0x018f: 0x1100, 0x0190: 0x1100, 0x0191: 0x8800,\n \t0x0195: 0x8800, 0x0197: 0x8800,\n \t0x0199: 0x8800,\n@@ -5673,7 +5673,7 @@ var charInfoValues = [1024]uint16{\n \t0x01f6: 0x8800, 0x01f7: 0x8800, 0x01f8: 0x8800, 0x01f9: 0x1100, 0x01fa: 0x8800,\n \t0x01fe: 0x8800,\n \t// Block 0x8, offset 0x200\n-\t0x0207: 0x3000,\n+\t0x0207: 0x5000,\n \t0x0211: 0x00dc,\n \t0x0212: 0x00e6, 0x0213: 0x00e6, 0x0214: 0x00e6, 0x0215: 0x00e6, 0x0216: 0x00dc, 0x0217: 0x00e6,\n \t0x0218: 0x00e6, 0x0219: 0x00e6, 0x021a: 0x00de, 0x021b: 0x00dc, 0x021c: 0x00e6, 0x021d: 0x00e6,\n@@ -5689,8 +5689,8 @@ var charInfoValues = [1024]uint16{\n \t0x0252: 0x0022, 0x0253: 0x66e6, 0x0254: 0x66e6, 0x0255: 0x66dc, 0x0256: 0x00dc, 0x0257: 0x00e6,\n \t0x0258: 0x00e6, 0x0259: 0x00e6, 0x025a: 0x00e6, 0x025b: 0x00e6, 0x025c: 0x00dc, 0x025d: 0x00e6,\n \t0x025e: 0x00e6, 0x025f: 0x00dc,\n-\t0x0270: 0x0023, 0x0275: 0x3000,\n-\t0x0276: 0x3000, 0x0277: 0x3000, 0x0278: 0x3000,\n+\t0x0270: 0x0023, 0x0275: 0x5000,\n+\t0x0276: 0x5000, 0x0277: 0x5000, 0x0278: 0x5000,\n \t// Block 0xa, offset 0x280\n \t0x0280: 0x9900, 0x0281: 0x9900, 0x0282: 0x1100, 0x0283: 0x1100, 0x0284: 0x1100, 0x0285: 0x1100,\n \t0x0288: 0x9900, 0x0289: 0x9900, 0x028a: 0x1100, 0x028b: 0x1100,\n@@ -5700,21 +5700,21 @@ var charInfoValues = [1024]uint16{\n \t0x029f: 0x1100, 0x02a0: 0x9900, 0x02a1: 0x9900, 0x02a2: 0x9900, 0x02a3: 0x9900,\n \t0x02a4: 0x9900, 0x02a5: 0x9900, 0x02a6: 0x9900, 0x02a7: 0x9900, 0x02a8: 0x9900, 0x02a9: 0x9900,\n \t0x02aa: 0x9900, 0x02ab: 0x9900, 0x02ac: 0x9900, 0x02ad: 0x9900, 0x02ae: 0x9900, 0x02af: 0x9900,\n-\t0x02b0: 0x9900, 0x02b1: 0x3300, 0x02b2: 0x1100, 0x02b3: 0x3300, 0x02b4: 0x9900, 0x02b5: 0x3300,\n-\t0x02b6: 0x1100, 0x02b7: 0x3300, 0x02b8: 0x1100, 0x02b9: 0x3300, 0x02ba: 0x1100, 0x02bb: 0x3300,\n-\t0x02bc: 0x9900, 0x02bd: 0x3300,\n+\t0x02b0: 0x9900, 0x02b1: 0x5500, 0x02b2: 0x1100, 0x02b3: 0x5500, 0x02b4: 0x9900, 0x02b5: 0x5500,\n+\t0x02b6: 0x1100, 0x02b7: 0x5500, 0x02b8: 0x1100, 0x02b9: 0x5500, 0x02ba: 0x1100, 0x02bb: 0x5500,\n+\t0x02bc: 0x9900, 0x02bd: 0x5500,\n \t// Block 0xb, offset 0x2c0\n-\t0x02c0: 0x3000, 0x02c1: 0x3100, 0x02c2: 0x1100, 0x02c3: 0x1100, 0x02c4: 0x1100,\n-\t0x02c6: 0x9900, 0x02c7: 0x1100, 0x02c8: 0x1100, 0x02c9: 0x3300, 0x02ca: 0x1100, 0x02cb: 0x3300,\n-\t0x02cc: 0x1100, 0x02cd: 0x3100, 0x02ce: 0x3100, 0x02cf: 0x3100, 0x02d0: 0x1100, 0x02d1: 0x1100,\n-\t0x02d2: 0x1100, 0x02d3: 0x3300, 0x02d6: 0x1100, 0x02d7: 0x1100,\n-\t0x02d8: 0x1100, 0x02d9: 0x1100, 0x02da: 0x1100, 0x02db: 0x3300, 0x02dd: 0x3100,\n-\t0x02de: 0x3100, 0x02df: 0x3100, 0x02e0: 0x1100, 0x02e1: 0x1100, 0x02e2: 0x1100, 0x02e3: 0x3300,\n+\t0x02c0: 0x5000, 0x02c1: 0x5100, 0x02c2: 0x1100, 0x02c3: 0x1100, 0x02c4: 0x1100,\n+\t0x02c6: 0x9900, 0x02c7: 0x1100, 0x02c8: 0x1100, 0x02c9: 0x5500, 0x02ca: 0x1100, 0x02cb: 0x5500,\n+\t0x02cc: 0x1100, 0x02cd: 0x5100, 0x02ce: 0x5100, 0x02cf: 0x5100, 0x02d0: 0x1100, 0x02d1: 0x1100,\n+\t0x02d2: 0x1100, 0x02d3: 0x5500, 0x02d6: 0x1100, 0x02d7: 0x1100,\n+\t0x02d8: 0x1100, 0x02d9: 0x1100, 0x02da: 0x1100, 0x02db: 0x5500, 0x02dd: 0x5100,\n+\t0x02de: 0x5100, 0x02df: 0x5100, 0x02e0: 0x1100, 0x02e1: 0x1100, 0x02e2: 0x1100, 0x02e3: 0x5500,\n \t0x02e4: 0x1100, 0x02e5: 0x1100, 0x02e6: 0x1100, 0x02e7: 0x1100, 0x02e8: 0x1100, 0x02e9: 0x1100,\n-\t0x02ea: 0x1100, 0x02eb: 0x3300, 0x02ec: 0x1100, 0x02ed: 0x3100, 0x02ee: 0x3300, 0x02ef: 0x3300,\n+\t0x02ea: 0x1100, 0x02eb: 0x5500, 0x02ec: 0x1100, 0x02ed: 0x5100, 0x02ee: 0x5500, 0x02ef: 0x5500,\n \t0x02f2: 0x1100, 0x02f3: 0x1100, 0x02f4: 0x1100,\n-\t0x02f6: 0x9900, 0x02f7: 0x1100, 0x02f8: 0x1100, 0x02f9: 0x3300, 0x02fa: 0x1100, 0x02fb: 0x3300,\n-\t0x02fc: 0x1100, 0x02fd: 0x3300, 0x02fe: 0x3800,\n+\t0x02f6: 0x9900, 0x02f7: 0x1100, 0x02f8: 0x1100, 0x02f9: 0x5500, 0x02fa: 0x1100, 0x02fb: 0x5500,\n+\t0x02fc: 0x1100, 0x02fd: 0x5500, 0x02fe: 0x5800,\n \t// Block 0xc, offset 0x300\n \t0x0301: 0x1100, 0x0303: 0x8800, 0x0304: 0x1100, 0x0305: 0x8800,\n \t0x0307: 0x1100, 0x0308: 0x8800, 0x0309: 0x1100,\n@@ -5738,8 +5738,8 @@ var charInfoValues = [1024]uint16{\n \t0x037c: 0x1100, 0x037d: 0x1100,\n \t// Block 0xe, offset 0x380\n \t0x0394: 0x1100,\n-\t0x0399: 0x6608, 0x039a: 0x6608, 0x039b: 0x3000, 0x039c: 0x3000, 0x039d: 0x8800,\n-\t0x039e: 0x1100, 0x039f: 0x3000,\n+\t0x0399: 0x6608, 0x039a: 0x6608, 0x039b: 0x5000, 0x039c: 0x5000, 0x039d: 0x8800,\n+\t0x039e: 0x1100, 0x039f: 0x5000,\n \t0x03a6: 0x8800,\n \t0x03ab: 0x8800, 0x03ac: 0x1100, 0x03ad: 0x8800, 0x03ae: 0x1100, 0x03af: 0x8800,\n \t0x03b0: 0x1100, 0x03b1: 0x8800, 0x03b2: 0x1100, 0x03b3: 0x8800, 0x03b4: 0x1100, 0x03b5: 0x8800,\n@@ -5754,7 +5754,7 @@ var charInfoValues = [1024]uint16{\n \t0x03ef: 0x8800,\n \t0x03f0: 0x8800, 0x03f1: 0x8800, 0x03f2: 0x8800, 0x03f4: 0x1100,\n \t0x03f7: 0x1100, 0x03f8: 0x1100, 0x03f9: 0x1100, 0x03fa: 0x1100,\n-\t0x03fd: 0x8800, 0x03fe: 0x1100, 0x03ff: 0x3000,\n+\t0x03fd: 0x8800, 0x03fe: 0x1100, 0x03ff: 0x5000,\n }\n \n // charInfoSparseOffset: 156 entries, 312 bytes\n@@ -5764,13 +5764,13 @@ var charInfoSparseOffset = []uint16{0x0, 0x8, 0x13, 0x21, 0x25, 0x2f, 0x36, 0x39\n var charInfoSparseValues = [757]valueRange{\n \t// Block 0x0, offset 0x1\n \t{value: 0x0000, lo: 0x07},\n-\t{value: 0x3000, lo: 0xa0, hi: 0xa0},\n-\t{value: 0x3800, lo: 0xa8, hi: 0xa8},\n-\t{value: 0x3000, lo: 0xaa, hi: 0xaa},\n-\t{value: 0x3000, lo: 0xaf, hi: 0xaf},\n-\t{value: 0x3000, lo: 0xb2, hi: 0xb5},\n-\t{value: 0x3000, lo: 0xb8, hi: 0xba},\n-\t{value: 0x3000, lo: 0xbc, hi: 0xbe},\n+\t{value: 0x5000, lo: 0xa0, hi: 0xa0},\n+\t{value: 0x5800, lo: 0xa8, hi: 0xa8},\n+\t{value: 0x5000, lo: 0xaa, hi: 0xaa},\n+\t{value: 0x5000, lo: 0xaf, hi: 0xaf},\n+\t{value: 0x5000, lo: 0xb2, hi: 0xb5},\n+\t{value: 0x5000, lo: 0xb8, hi: 0xba},\n+\t{value: 0x5000, lo: 0xbc, hi: 0xbe},\n \t// Block 0x1, offset 0x2\n \t{value: 0x0000, lo: 0x0a},\n \t{value: 0x1100, lo: 0x80, hi: 0x81},\n@@ -5779,15 +5779,15 @@ var charInfoSparseValues = [757]valueRange{\n \t{value: 0x9900, lo: 0x92, hi: 0x93},\n \t{value: 0x1100, lo: 0x94, hi: 0xa5},\n \t{value: 0x1100, lo: 0xa8, hi: 0xb0},\n-\t{value: 0x3000, lo: 0xb2, hi: 0xb3},\n+\t{value: 0x5000, lo: 0xb2, hi: 0xb3},\n \t{value: 0x1100, lo: 0xb4, hi: 0xb7},\n \t{value: 0x1100, lo: 0xb9, hi: 0xbe},\n-\t{value: 0x3000, lo: 0xbf, hi: 0xbf},\n+\t{value: 0x5000, lo: 0xbf, hi: 0xbf},\n \t// Block 0x2, offset 0x3\n \t{value: 0x0000, lo: 0x0d},\n-\t{value: 0x3000, lo: 0x80, hi: 0x80},\n+\t{value: 0x5000, lo: 0x80, hi: 0x80},\n \t{value: 0x1100, lo: 0x83, hi: 0x88},\n-\t{value: 0x3000, lo: 0x89, hi: 0x89},\n+\t{value: 0x5000, lo: 0x89, hi: 0x89},\n \t{value: 0x9900, lo: 0x8c, hi: 0x8d},\n \t{value: 0x1100, lo: 0x8e, hi: 0x91},\n \t{value: 0x1100, lo: 0x94, hi: 0x99},\n@@ -5797,21 +5797,21 @@ var charInfoSparseValues = [757]valueRange{\n \t{value: 0x1100, lo: 0xa2, hi: 0xa5},\n \t{value: 0x9900, lo: 0xa8, hi: 0xab},\n \t{value: 0x1100, lo: 0xac, hi: 0xbe},\n-\t{value: 0x3800, lo: 0xbf, hi: 0xbf},\n+\t{value: 0x5800, lo: 0xbf, hi: 0xbf},\n \t// Block 0x3, offset 0x4\n \t{value: 0x0000, lo: 0x03},\n \t{value: 0x9900, lo: 0xa0, hi: 0xa1},\n \t{value: 0x9900, lo: 0xaf, hi: 0xb0},\n \t{value: 0x8800, lo: 0xb7, hi: 0xb7},\n \t// Block 0x4, offset 0x5\n \t{value: 0x0000, lo: 0x09},\n-\t{value: 0x3000, lo: 0x84, hi: 0x8c},\n+\t{value: 0x5000, lo: 0x84, hi: 0x8c},\n \t{value: 0x1100, lo: 0x8d, hi: 0x9c},\n \t{value: 0x1100, lo: 0x9e, hi: 0xa3},\n \t{value: 0x1100, lo: 0xa6, hi: 0xa9},\n \t{value: 0x9900, lo: 0xaa, hi: 0xab},\n \t{value: 0x1100, lo: 0xac, hi: 0xb0},\n-\t{value: 0x3000, lo: 0xb1, hi: 0xb3},\n+\t{value: 0x5000, lo: 0xb1, hi: 0xb3},\n \t{value: 0x1100, lo: 0xb4, hi: 0xb5},\n \t{value: 0x1100, lo: 0xb8, hi: 0xbf},\n \t// Block 0x5, offset 0x6\n@@ -5825,11 +5825,11 @@ var charInfoSparseValues = [757]valueRange{\n \t// Block 0x6, offset 0x7\n \t{value: 0x0000, lo: 0x02},\n \t{value: 0x8800, lo: 0x92, hi: 0x92},\n-\t{value: 0x3000, lo: 0xb0, hi: 0xb8},\n+\t{value: 0x5000, lo: 0xb0, hi: 0xb8},\n \t// Block 0x7, offset 0x8\n \t{value: 0x0000, lo: 0x02},\n-\t{value: 0x3000, lo: 0x98, hi: 0x9d},\n-\t{value: 0x3000, lo: 0xa0, hi: 0xa4},\n+\t{value: 0x5000, lo: 0x98, hi: 0x9d},\n+\t{value: 0x5000, lo: 0xa0, hi: 0xa4},\n \t// Block 0x8, offset 0x9\n \t{value: 0x0000, lo: 0x0d},\n \t{value: 0x8800, lo: 0x81, hi: 0x81},\n@@ -5838,13 +5838,13 @@ var charInfoSparseValues = [757]valueRange{\n \t{value: 0x9900, lo: 0x8a, hi: 0x8b},\n \t{value: 0x1100, lo: 0x8c, hi: 0x8d},\n \t{value: 0x9900, lo: 0x8e, hi: 0x8e},\n-\t{value: 0x3000, lo: 0x90, hi: 0x91},\n-\t{value: 0x3800, lo: 0x92, hi: 0x92},\n-\t{value: 0x3100, lo: 0x93, hi: 0x94},\n-\t{value: 0x3000, lo: 0x95, hi: 0x96},\n-\t{value: 0x3000, lo: 0xb0, hi: 0xb2},\n-\t{value: 0x3000, lo: 0xb4, hi: 0xb5},\n-\t{value: 0x3000, lo: 0xb9, hi: 0xb9},\n+\t{value: 0x5000, lo: 0x90, hi: 0x91},\n+\t{value: 0x5800, lo: 0x92, hi: 0x92},\n+\t{value: 0x5100, lo: 0x93, hi: 0x94},\n+\t{value: 0x5000, lo: 0x95, hi: 0x96},\n+\t{value: 0x5000, lo: 0xb0, hi: 0xb2},\n+\t{value: 0x5000, lo: 0xb4, hi: 0xb5},\n+\t{value: 0x5000, lo: 0xb9, hi: 0xb9},\n \t// Block 0x9, offset 0xa\n \t{value: 0x0000, lo: 0x0b},\n \t{value: 0x8800, lo: 0x83, hi: 0x83},\n@@ -5954,7 +5954,7 @@ var charInfoSparseValues = [757]valueRange{\n \t{value: 0x00e6, lo: 0x91, hi: 0x91},\n \t{value: 0x00dc, lo: 0x92, hi: 0x92},\n \t{value: 0x00e6, lo: 0x93, hi: 0x94},\n-\t{value: 0x3300, lo: 0x98, hi: 0x9f},\n+\t{value: 0x5500, lo: 0x98, hi: 0x9f},\n \t// Block 0x16, offset 0x17\n \t{value: 0x0000, lo: 0x02},\n \t{value: 0x0007, lo: 0xbc, hi: 0xbc},\n@@ -5965,18 +5965,18 @@ var charInfoSparseValues = [757]valueRange{\n \t{value: 0x1100, lo: 0x8b, hi: 0x8c},\n \t{value: 0x0009, lo: 0x8d, hi: 0x8d},\n \t{value: 0x6600, lo: 0x97, hi: 0x97},\n-\t{value: 0x3300, lo: 0x9c, hi: 0x9d},\n-\t{value: 0x3300, lo: 0x9f, hi: 0x9f},\n+\t{value: 0x5500, lo: 0x9c, hi: 0x9d},\n+\t{value: 0x5500, lo: 0x9f, hi: 0x9f},\n \t// Block 0x18, offset 0x19\n \t{value: 0x0000, lo: 0x03},\n-\t{value: 0x3300, lo: 0xb3, hi: 0xb3},\n-\t{value: 0x3300, lo: 0xb6, hi: 0xb6},\n+\t{value: 0x5500, lo: 0xb3, hi: 0xb3},\n+\t{value: 0x5500, lo: 0xb6, hi: 0xb6},\n \t{value: 0x0007, lo: 0xbc, hi: 0xbc},\n \t// Block 0x19, offset 0x1a\n \t{value: 0x0000, lo: 0x03},\n \t{value: 0x0009, lo: 0x8d, hi: 0x8d},\n-\t{value: 0x3300, lo: 0x99, hi: 0x9b},\n-\t{value: 0x3300, lo: 0x9e, hi: 0x9e},\n+\t{value: 0x5500, lo: 0x99, hi: 0x9b},\n+\t{value: 0x5500, lo: 0x9e, hi: 0x9e},\n \t// Block 0x1a, offset 0x1b\n \t{value: 0x0000, lo: 0x01},\n \t{value: 0x0007, lo: 0xbc, hi: 0xbc},\n@@ -5990,7 +5990,7 @@ var charInfoSparseValues = [757]valueRange{\n \t{value: 0x1100, lo: 0x8b, hi: 0x8c},\n \t{value: 0x0009, lo: 0x8d, hi: 0x8d},\n \t{value: 0x6600, lo: 0x96, hi: 0x97},\n-\t{value: 0x3300, lo: 0x9c, hi: 0x9d},\n+\t{value: 0x5500, lo: 0x9c, hi: 0x9d},\n \t// Block 0x1d, offset 0x1e\n \t{value: 0x0000, lo: 0x03},\n \t{value: 0x8800, lo: 0x92, hi: 0x92},\n@@ -6036,57 +6036,57 @@ var charInfoSparseValues = [757]valueRange{\n \t{value: 0x6600, lo: 0x9f, hi: 0x9f},\n \t// Block 0x24, offset 0x25\n \t{value: 0x0000, lo: 0x03},\n-\t{value: 0x3000, lo: 0xb3, hi: 0xb3},\n+\t{value: 0x5000, lo: 0xb3, hi: 0xb3},\n \t{value: 0x0067, lo: 0xb8, hi: 0xb9},\n \t{value: 0x0009, lo: 0xba, hi: 0xba},\n \t// Block 0x25, offset 0x26\n \t{value: 0x0000, lo: 0x01},\n \t{value: 0x006b, lo: 0x88, hi: 0x8b},\n \t// Block 0x26, offset 0x27\n \t{value: 0x0000, lo: 0x02},\n-\t{value: 0x3000, lo: 0xb3, hi: 0xb3},\n+\t{value: 0x5000, lo: 0xb3, hi: 0xb3},\n \t{value: 0x0076, lo: 0xb8, hi: 0xb9},\n \t// Block 0x27, offset 0x28\n \t{value: 0x0000, lo: 0x02},\n \t{value: 0x007a, lo: 0x88, hi: 0x8b},\n-\t{value: 0x3000, lo: 0x9c, hi: 0x9d},\n+\t{value: 0x5000, lo: 0x9c, hi: 0x9d},\n \t// Block 0x28, offset 0x29\n \t{value: 0x0000, lo: 0x05},\n-\t{value: 0x3000, lo: 0x8c, hi: 0x8c},\n+\t{value: 0x5000, lo: 0x8c, hi: 0x8c},\n \t{value: 0x00dc, lo: 0x98, hi: 0x99},\n \t{value: 0x00dc, lo: 0xb5, hi: 0xb5},\n \t{value: 0x00dc, lo: 0xb7, hi: 0xb7},\n \t{value: 0x00d8, lo: 0xb9, hi: 0xb9},\n \t// Block 0x29, offset 0x2a\n \t{value: 0x0000, lo: 0x0f},\n-\t{value: 0x3300, lo: 0x83, hi: 0x83},\n-\t{value: 0x3300, lo: 0x8d, hi: 0x8d},\n-\t{value: 0x3300, lo: 0x92, hi: 0x92},\n-\t{value: 0x3300, lo: 0x97, hi: 0x97},\n-\t{value: 0x3300, lo: 0x9c, hi: 0x9c},\n-\t{value: 0x3300, lo: 0xa9, hi: 0xa9},\n+\t{value: 0x5500, lo: 0x83, hi: 0x83},\n+\t{value: 0x5500, lo: 0x8d, hi: 0x8d},\n+\t{value: 0x5500, lo: 0x92, hi: 0x92},\n+\t{value: 0x5500, lo: 0x97, hi: 0x97},\n+\t{value: 0x5500, lo: 0x9c, hi: 0x9c},\n+\t{value: 0x5500, lo: 0xa9, hi: 0xa9},\n \t{value: 0x0081, lo: 0xb1, hi: 0xb1},\n \t{value: 0x0082, lo: 0xb2, hi: 0xb2},\n-\t{value: 0x3300, lo: 0xb3, hi: 0xb3},\n+\t{value: 0x5500, lo: 0xb3, hi: 0xb3},\n \t{value: 0x0084, lo: 0xb4, hi: 0xb4},\n-\t{value: 0x3300, lo: 0xb5, hi: 0xb6},\n-\t{value: 0x3000, lo: 0xb7, hi: 0xb7},\n-\t{value: 0x3300, lo: 0xb8, hi: 0xb8},\n-\t{value: 0x3000, lo: 0xb9, hi: 0xb9},\n+\t{value: 0x5500, lo: 0xb5, hi: 0xb6},\n+\t{value: 0x5000, lo: 0xb7, hi: 0xb7},\n+\t{value: 0x5500, lo: 0xb8, hi: 0xb8},\n+\t{value: 0x5000, lo: 0xb9, hi: 0xb9},\n \t{value: 0x0082, lo: 0xba, hi: 0xbd},\n \t// Block 0x2a, offset 0x2b\n \t{value: 0x0000, lo: 0x0b},\n \t{value: 0x0082, lo: 0x80, hi: 0x80},\n-\t{value: 0x3300, lo: 0x81, hi: 0x81},\n+\t{value: 0x5500, lo: 0x81, hi: 0x81},\n \t{value: 0x00e6, lo: 0x82, hi: 0x83},\n \t{value: 0x0009, lo: 0x84, hi: 0x84},\n \t{value: 0x00e6, lo: 0x86, hi: 0x87},\n-\t{value: 0x3300, lo: 0x93, hi: 0x93},\n-\t{value: 0x3300, lo: 0x9d, hi: 0x9d},\n-\t{value: 0x3300, lo: 0xa2, hi: 0xa2},\n-\t{value: 0x3300, lo: 0xa7, hi: 0xa7},\n-\t{value: 0x3300, lo: 0xac, hi: 0xac},\n-\t{value: 0x3300, lo: 0xb9, hi: 0xb9},\n+\t{value: 0x5500, lo: 0x93, hi: 0x93},\n+\t{value: 0x5500, lo: 0x9d, hi: 0x9d},\n+\t{value: 0x5500, lo: 0xa2, hi: 0xa2},\n+\t{value: 0x5500, lo: 0xa7, hi: 0xa7},\n+\t{value: 0x5500, lo: 0xac, hi: 0xac},\n+\t{value: 0x5500, lo: 0xb9, hi: 0xb9},\n \t// Block 0x2b, offset 0x2c\n \t{value: 0x0000, lo: 0x01},\n \t{value: 0x00dc, lo: 0x86, hi: 0x86},\n@@ -6102,7 +6102,7 @@ var charInfoSparseValues = [757]valueRange{\n \t{value: 0x00dc, lo: 0x8d, hi: 0x8d},\n \t// Block 0x2e, offset 0x2f\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3000, lo: 0xbc, hi: 0xbc},\n+\t{value: 0x5000, lo: 0xbc, hi: 0xbc},\n \t// Block 0x2f, offset 0x30\n \t{value: 0x0000, lo: 0x01},\n \t{value: 0x8800, lo: 0x80, hi: 0x92},\n@@ -6189,17 +6189,17 @@ var charInfoSparseValues = [757]valueRange{\n \t{value: 0x00dc, lo: 0xad, hi: 0xad},\n \t// Block 0x40, offset 0x41\n \t{value: 0x0000, lo: 0x03},\n-\t{value: 0x3000, lo: 0xac, hi: 0xae},\n-\t{value: 0x3000, lo: 0xb0, hi: 0xba},\n-\t{value: 0x3000, lo: 0xbc, hi: 0xbf},\n+\t{value: 0x5000, lo: 0xac, hi: 0xae},\n+\t{value: 0x5000, lo: 0xb0, hi: 0xba},\n+\t{value: 0x5000, lo: 0xbc, hi: 0xbf},\n \t// Block 0x41, offset 0x42\n \t{value: 0x0000, lo: 0x03},\n-\t{value: 0x3000, lo: 0x80, hi: 0x8d},\n-\t{value: 0x3000, lo: 0x8f, hi: 0xaa},\n-\t{value: 0x3000, lo: 0xb8, hi: 0xb8},\n+\t{value: 0x5000, lo: 0x80, hi: 0x8d},\n+\t{value: 0x5000, lo: 0x8f, hi: 0xaa},\n+\t{value: 0x5000, lo: 0xb8, hi: 0xb8},\n \t// Block 0x42, offset 0x43\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3000, lo: 0x9b, hi: 0xbf},\n+\t{value: 0x5000, lo: 0x9b, hi: 0xbf},\n \t// Block 0x43, offset 0x44\n \t{value: 0x0000, lo: 0x0e},\n \t{value: 0x00e6, lo: 0x80, hi: 0x81},\n@@ -6231,8 +6231,8 @@ var charInfoSparseValues = [757]valueRange{\n \t// Block 0x46, offset 0x47\n \t{value: 0x0000, lo: 0x07},\n \t{value: 0x1100, lo: 0x80, hi: 0x99},\n-\t{value: 0x3000, lo: 0x9a, hi: 0x9a},\n-\t{value: 0x3100, lo: 0x9b, hi: 0x9b},\n+\t{value: 0x5000, lo: 0x9a, hi: 0x9a},\n+\t{value: 0x5100, lo: 0x9b, hi: 0x9b},\n \t{value: 0x9900, lo: 0xa0, hi: 0xa1},\n \t{value: 0x1100, lo: 0xa2, hi: 0xb7},\n \t{value: 0x9900, lo: 0xb8, hi: 0xb9},\n@@ -6257,35 +6257,35 @@ var charInfoSparseValues = [757]valueRange{\n \t{value: 0x1100, lo: 0x80, hi: 0xb4},\n \t{value: 0x9900, lo: 0xb6, hi: 0xb6},\n \t{value: 0x1100, lo: 0xb7, hi: 0xba},\n-\t{value: 0x3300, lo: 0xbb, hi: 0xbb},\n+\t{value: 0x5500, lo: 0xbb, hi: 0xbb},\n \t{value: 0x1100, lo: 0xbc, hi: 0xbc},\n-\t{value: 0x3000, lo: 0xbd, hi: 0xbd},\n-\t{value: 0x3300, lo: 0xbe, hi: 0xbe},\n-\t{value: 0x3800, lo: 0xbf, hi: 0xbf},\n+\t{value: 0x5000, lo: 0xbd, hi: 0xbd},\n+\t{value: 0x5500, lo: 0xbe, hi: 0xbe},\n+\t{value: 0x5800, lo: 0xbf, hi: 0xbf},\n \t// Block 0x4a, offset 0x4b\n \t{value: 0x0000, lo: 0x0a},\n-\t{value: 0x3300, lo: 0x80, hi: 0x81},\n-\t{value: 0x3000, lo: 0x82, hi: 0x8a},\n-\t{value: 0x3000, lo: 0x91, hi: 0x91},\n-\t{value: 0x3000, lo: 0x97, hi: 0x97},\n-\t{value: 0x3000, lo: 0xa4, hi: 0xa6},\n-\t{value: 0x3000, lo: 0xaf, hi: 0xaf},\n-\t{value: 0x3000, lo: 0xb3, hi: 0xb4},\n-\t{value: 0x3000, lo: 0xb6, hi: 0xb7},\n-\t{value: 0x3000, lo: 0xbc, hi: 0xbc},\n-\t{value: 0x3000, lo: 0xbe, hi: 0xbe},\n+\t{value: 0x5500, lo: 0x80, hi: 0x81},\n+\t{value: 0x5000, lo: 0x82, hi: 0x8a},\n+\t{value: 0x5000, lo: 0x91, hi: 0x91},\n+\t{value: 0x5000, lo: 0x97, hi: 0x97},\n+\t{value: 0x5000, lo: 0xa4, hi: 0xa6},\n+\t{value: 0x5000, lo: 0xaf, hi: 0xaf},\n+\t{value: 0x5000, lo: 0xb3, hi: 0xb4},\n+\t{value: 0x5000, lo: 0xb6, hi: 0xb7},\n+\t{value: 0x5000, lo: 0xbc, hi: 0xbc},\n+\t{value: 0x5000, lo: 0xbe, hi: 0xbe},\n \t// Block 0x4b, offset 0x4c\n \t{value: 0x0000, lo: 0x05},\n-\t{value: 0x3000, lo: 0x87, hi: 0x89},\n-\t{value: 0x3000, lo: 0x97, hi: 0x97},\n-\t{value: 0x3000, lo: 0x9f, hi: 0x9f},\n-\t{value: 0x3000, lo: 0xb0, hi: 0xb1},\n-\t{value: 0x3000, lo: 0xb4, hi: 0xbf},\n+\t{value: 0x5000, lo: 0x87, hi: 0x89},\n+\t{value: 0x5000, lo: 0x97, hi: 0x97},\n+\t{value: 0x5000, lo: 0x9f, hi: 0x9f},\n+\t{value: 0x5000, lo: 0xb0, hi: 0xb1},\n+\t{value: 0x5000, lo: 0xb4, hi: 0xbf},\n \t// Block 0x4c, offset 0x4d\n \t{value: 0x0000, lo: 0x03},\n-\t{value: 0x3000, lo: 0x80, hi: 0x8e},\n-\t{value: 0x3000, lo: 0x90, hi: 0x9c},\n-\t{value: 0x3000, lo: 0xa8, hi: 0xa8},\n+\t{value: 0x5000, lo: 0x80, hi: 0x8e},\n+\t{value: 0x5000, lo: 0x90, hi: 0x9c},\n+\t{value: 0x5000, lo: 0xa8, hi: 0xa8},\n \t// Block 0x4d, offset 0x4e\n \t{value: 0x0000, lo: 0x0d},\n \t{value: 0x00e6, lo: 0x90, hi: 0x91},\n@@ -6303,28 +6303,28 @@ var charInfoSparseValues = [757]valueRange{\n \t{value: 0x00e6, lo: 0xb0, hi: 0xb0},\n \t// Block 0x4e, offset 0x4f\n \t{value: 0x0000, lo: 0x0e},\n-\t{value: 0x3000, lo: 0x80, hi: 0x83},\n-\t{value: 0x3000, lo: 0x85, hi: 0x87},\n-\t{value: 0x3000, lo: 0x89, hi: 0x93},\n-\t{value: 0x3000, lo: 0x95, hi: 0x96},\n-\t{value: 0x3000, lo: 0x99, hi: 0x9d},\n-\t{value: 0x3000, lo: 0xa0, hi: 0xa2},\n-\t{value: 0x3000, lo: 0xa4, hi: 0xa4},\n-\t{value: 0x3300, lo: 0xa6, hi: 0xa6},\n-\t{value: 0x3000, lo: 0xa8, hi: 0xa8},\n-\t{value: 0x3300, lo: 0xaa, hi: 0xab},\n-\t{value: 0x3000, lo: 0xac, hi: 0xad},\n-\t{value: 0x3000, lo: 0xaf, hi: 0xb1},\n-\t{value: 0x3000, lo: 0xb3, hi: 0xb9},\n-\t{value: 0x3000, lo: 0xbb, hi: 0xbf},\n+\t{value: 0x5000, lo: 0x80, hi: 0x83},\n+\t{value: 0x5000, lo: 0x85, hi: 0x87},\n+\t{value: 0x5000, lo: 0x89, hi: 0x93},\n+\t{value: 0x5000, lo: 0x95, hi: 0x96},\n+\t{value: 0x5000, lo: 0x99, hi: 0x9d},\n+\t{value: 0x5000, lo: 0xa0, hi: 0xa2},\n+\t{value: 0x5000, lo: 0xa4, hi: 0xa4},\n+\t{value: 0x5500, lo: 0xa6, hi: 0xa6},\n+\t{value: 0x5000, lo: 0xa8, hi: 0xa8},\n+\t{value: 0x5500, lo: 0xaa, hi: 0xab},\n+\t{value: 0x5000, lo: 0xac, hi: 0xad},\n+\t{value: 0x5000, lo: 0xaf, hi: 0xb1},\n+\t{value: 0x5000, lo: 0xb3, hi: 0xb9},\n+\t{value: 0x5000, lo: 0xbb, hi: 0xbf},\n \t// Block 0x4f, offset 0x50\n \t{value: 0x0000, lo: 0x03},\n-\t{value: 0x3000, lo: 0x80, hi: 0x80},\n-\t{value: 0x3000, lo: 0x85, hi: 0x89},\n-\t{value: 0x3000, lo: 0x90, hi: 0xbf},\n+\t{value: 0x5000, lo: 0x80, hi: 0x80},\n+\t{value: 0x5000, lo: 0x85, hi: 0x89},\n+\t{value: 0x5000, lo: 0x90, hi: 0xbf},\n \t// Block 0x50, offset 0x51\n \t{value: 0x0000, lo: 0x06},\n-\t{value: 0x3000, lo: 0x89, hi: 0x89},\n+\t{value: 0x5000, lo: 0x89, hi: 0x89},\n \t{value: 0x8800, lo: 0x90, hi: 0x90},\n \t{value: 0x8800, lo: 0x92, hi: 0x92},\n \t{value: 0x8800, lo: 0x94, hi: 0x94},\n@@ -6348,8 +6348,8 @@ var charInfoSparseValues = [757]valueRange{\n \t{value: 0x1100, lo: 0xa4, hi: 0xa4},\n \t{value: 0x8800, lo: 0xa5, hi: 0xa5},\n \t{value: 0x1100, lo: 0xa6, hi: 0xa6},\n-\t{value: 0x3000, lo: 0xac, hi: 0xad},\n-\t{value: 0x3000, lo: 0xaf, hi: 0xb0},\n+\t{value: 0x5000, lo: 0xac, hi: 0xad},\n+\t{value: 0x5000, lo: 0xaf, hi: 0xb0},\n \t{value: 0x8800, lo: 0xbc, hi: 0xbc},\n \t// Block 0x53, offset 0x54\n \t{value: 0x0000, lo: 0x0b},\n@@ -6370,75 +6370,75 @@ var charInfoSparseValues = [757]valueRange{\n \t{value: 0x1100, lo: 0xaa, hi: 0xad},\n \t// Block 0x55, offset 0x56\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3300, lo: 0xa9, hi: 0xaa},\n+\t{value: 0x5500, lo: 0xa9, hi: 0xaa},\n \t// Block 0x56, offset 0x57\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3000, lo: 0xa0, hi: 0xbf},\n+\t{value: 0x5000, lo: 0xa0, hi: 0xbf},\n \t// Block 0x57, offset 0x58\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3000, lo: 0x80, hi: 0xbf},\n+\t{value: 0x5000, lo: 0x80, hi: 0xbf},\n \t// Block 0x58, offset 0x59\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3000, lo: 0x80, hi: 0xaa},\n+\t{value: 0x5000, lo: 0x80, hi: 0xaa},\n \t// Block 0x59, offset 0x5a\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3000, lo: 0x8c, hi: 0x8c},\n+\t{value: 0x5000, lo: 0x8c, hi: 0x8c},\n \t// Block 0x5a, offset 0x5b\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3000, lo: 0xb4, hi: 0xb6},\n+\t{value: 0x5000, lo: 0xb4, hi: 0xb6},\n \t// Block 0x5b, offset 0x5c\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3300, lo: 0x9c, hi: 0x9c},\n+\t{value: 0x5500, lo: 0x9c, hi: 0x9c},\n \t// Block 0x5c, offset 0x5d\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3000, lo: 0xbc, hi: 0xbd},\n+\t{value: 0x5000, lo: 0xbc, hi: 0xbd},\n \t// Block 0x5d, offset 0x5e\n \t{value: 0x0000, lo: 0x01},\n \t{value: 0x00e6, lo: 0xaf, hi: 0xb1},\n \t// Block 0x5e, offset 0x5f\n \t{value: 0x0000, lo: 0x02},\n-\t{value: 0x3000, lo: 0xaf, hi: 0xaf},\n+\t{value: 0x5000, lo: 0xaf, hi: 0xaf},\n \t{value: 0x0009, lo: 0xbf, hi: 0xbf},\n \t// Block 0x5f, offset 0x60\n \t{value: 0x0000, lo: 0x01},\n \t{value: 0x00e6, lo: 0xa0, hi: 0xbf},\n \t// Block 0x60, offset 0x61\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3000, lo: 0x9f, hi: 0x9f},\n+\t{value: 0x5000, lo: 0x9f, hi: 0x9f},\n \t// Block 0x61, offset 0x62\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3000, lo: 0xb3, hi: 0xb3},\n+\t{value: 0x5000, lo: 0xb3, hi: 0xb3},\n \t// Block 0x62, offset 0x63\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3000, lo: 0x80, hi: 0x95},\n+\t{value: 0x5000, lo: 0x80, hi: 0x95},\n \t// Block 0x63, offset 0x64\n \t{value: 0x0000, lo: 0x08},\n-\t{value: 0x3000, lo: 0x80, hi: 0x80},\n+\t{value: 0x5000, lo: 0x80, hi: 0x80},\n \t{value: 0x00da, lo: 0xaa, hi: 0xaa},\n \t{value: 0x00e4, lo: 0xab, hi: 0xab},\n \t{value: 0x00e8, lo: 0xac, hi: 0xac},\n \t{value: 0x00de, lo: 0xad, hi: 0xad},\n \t{value: 0x00e0, lo: 0xae, hi: 0xaf},\n-\t{value: 0x3000, lo: 0xb6, hi: 0xb6},\n-\t{value: 0x3000, lo: 0xb8, hi: 0xba},\n+\t{value: 0x5000, lo: 0xb6, hi: 0xb6},\n+\t{value: 0x5000, lo: 0xb8, hi: 0xba},\n \t// Block 0x64, offset 0x65\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3000, lo: 0xb1, hi: 0xbf},\n+\t{value: 0x5000, lo: 0xb1, hi: 0xbf},\n \t// Block 0x65, offset 0x66\n \t{value: 0x0000, lo: 0x02},\n-\t{value: 0x3000, lo: 0x80, hi: 0x8e},\n-\t{value: 0x3000, lo: 0x92, hi: 0x9f},\n+\t{value: 0x5000, lo: 0x80, hi: 0x8e},\n+\t{value: 0x5000, lo: 0x92, hi: 0x9f},\n \t// Block 0x66, offset 0x67\n \t{value: 0x0000, lo: 0x02},\n-\t{value: 0x3000, lo: 0x80, hi: 0x9e},\n-\t{value: 0x3000, lo: 0xa0, hi: 0xbf},\n+\t{value: 0x5000, lo: 0x80, hi: 0x9e},\n+\t{value: 0x5000, lo: 0xa0, hi: 0xbf},\n \t// Block 0x67, offset 0x68\n \t{value: 0x0000, lo: 0x02},\n-\t{value: 0x3000, lo: 0x80, hi: 0x87},\n-\t{value: 0x3000, lo: 0x90, hi: 0xbe},\n+\t{value: 0x5000, lo: 0x80, hi: 0x87},\n+\t{value: 0x5000, lo: 0x90, hi: 0xbe},\n \t// Block 0x68, offset 0x69\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3000, lo: 0x80, hi: 0xbe},\n+\t{value: 0x5000, lo: 0x80, hi: 0xbe},\n \t// Block 0x69, offset 0x6a\n \t{value: 0x0000, lo: 0x02},\n \t{value: 0x00e6, lo: 0xaf, hi: 0xaf},\n@@ -6448,7 +6448,7 @@ var charInfoSparseValues = [757]valueRange{\n \t{value: 0x00e6, lo: 0xb0, hi: 0xb1},\n \t// Block 0x6b, offset 0x6c\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3000, lo: 0xb0, hi: 0xb0},\n+\t{value: 0x5000, lo: 0xb0, hi: 0xb0},\n \t// Block 0x6c, offset 0x6d\n \t{value: 0x0000, lo: 0x01},\n \t{value: 0x0009, lo: 0x86, hi: 0x86},\n@@ -6489,90 +6489,90 @@ var charInfoSparseValues = [757]valueRange{\n \t{value: 0x1100, lo: 0x80, hi: 0xa3},\n \t// Block 0x77, offset 0x78\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3300, lo: 0x80, hi: 0xbf},\n+\t{value: 0x5500, lo: 0x80, hi: 0xbf},\n \t// Block 0x78, offset 0x79\n \t{value: 0x0000, lo: 0x09},\n-\t{value: 0x3300, lo: 0x80, hi: 0x8d},\n-\t{value: 0x3300, lo: 0x90, hi: 0x90},\n-\t{value: 0x3300, lo: 0x92, hi: 0x92},\n-\t{value: 0x3300, lo: 0x95, hi: 0x9e},\n-\t{value: 0x3300, lo: 0xa0, hi: 0xa0},\n-\t{value: 0x3300, lo: 0xa2, hi: 0xa2},\n-\t{value: 0x3300, lo: 0xa5, hi: 0xa6},\n-\t{value: 0x3300, lo: 0xaa, hi: 0xad},\n-\t{value: 0x3300, lo: 0xb0, hi: 0xbf},\n+\t{value: 0x5500, lo: 0x80, hi: 0x8d},\n+\t{value: 0x5500, lo: 0x90, hi: 0x90},\n+\t{value: 0x5500, lo: 0x92, hi: 0x92},\n+\t{value: 0x5500, lo: 0x95, hi: 0x9e},\n+\t{value: 0x5500, lo: 0xa0, hi: 0xa0},\n+\t{value: 0x5500, lo: 0xa2, hi: 0xa2},\n+\t{value: 0x5500, lo: 0xa5, hi: 0xa6},\n+\t{value: 0x5500, lo: 0xaa, hi: 0xad},\n+\t{value: 0x5500, lo: 0xb0, hi: 0xbf},\n \t// Block 0x79, offset 0x7a\n \t{value: 0x0000, lo: 0x02},\n-\t{value: 0x3300, lo: 0x80, hi: 0xad},\n-\t{value: 0x3300, lo: 0xb0, hi: 0xbf},\n+\t{value: 0x5500, lo: 0x80, hi: 0xad},\n+\t{value: 0x5500, lo: 0xb0, hi: 0xbf},\n \t// Block 0x7a, offset 0x7b\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3300, lo: 0x80, hi: 0x99},\n+\t{value: 0x5500, lo: 0x80, hi: 0x99},\n \t// Block 0x7b, offset 0x7c\n \t{value: 0x0000, lo: 0x09},\n-\t{value: 0x3000, lo: 0x80, hi: 0x86},\n-\t{value: 0x3000, lo: 0x93, hi: 0x97},\n-\t{value: 0x3300, lo: 0x9d, hi: 0x9d},\n+\t{value: 0x5000, lo: 0x80, hi: 0x86},\n+\t{value: 0x5000, lo: 0x93, hi: 0x97},\n+\t{value: 0x5500, lo: 0x9d, hi: 0x9d},\n \t{value: 0x001a, lo: 0x9e, hi: 0x9e},\n-\t{value: 0x3300, lo: 0x9f, hi: 0x9f},\n-\t{value: 0x3000, lo: 0xa0, hi: 0xa9},\n-\t{value: 0x3300, lo: 0xaa, hi: 0xb6},\n-\t{value: 0x3300, lo: 0xb8, hi: 0xbc},\n-\t{value: 0x3300, lo: 0xbe, hi: 0xbe},\n+\t{value: 0x5500, lo: 0x9f, hi: 0x9f},\n+\t{value: 0x5000, lo: 0xa0, hi: 0xa9},\n+\t{value: 0x5500, lo: 0xaa, hi: 0xb6},\n+\t{value: 0x5500, lo: 0xb8, hi: 0xbc},\n+\t{value: 0x5500, lo: 0xbe, hi: 0xbe},\n \t// Block 0x7c, offset 0x7d\n \t{value: 0x0000, lo: 0x04},\n-\t{value: 0x3300, lo: 0x80, hi: 0x81},\n-\t{value: 0x3300, lo: 0x83, hi: 0x84},\n-\t{value: 0x3300, lo: 0x86, hi: 0x8e},\n-\t{value: 0x3000, lo: 0x8f, hi: 0xbf},\n+\t{value: 0x5500, lo: 0x80, hi: 0x81},\n+\t{value: 0x5500, lo: 0x83, hi: 0x84},\n+\t{value: 0x5500, lo: 0x86, hi: 0x8e},\n+\t{value: 0x5000, lo: 0x8f, hi: 0xbf},\n \t// Block 0x7d, offset 0x7e\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3000, lo: 0x80, hi: 0xb1},\n+\t{value: 0x5000, lo: 0x80, hi: 0xb1},\n \t// Block 0x7e, offset 0x7f\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3000, lo: 0x93, hi: 0xbf},\n+\t{value: 0x5000, lo: 0x93, hi: 0xbf},\n \t// Block 0x7f, offset 0x80\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3000, lo: 0x80, hi: 0xbd},\n+\t{value: 0x5000, lo: 0x80, hi: 0xbd},\n \t// Block 0x80, offset 0x81\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3000, lo: 0x90, hi: 0xbf},\n+\t{value: 0x5000, lo: 0x90, hi: 0xbf},\n \t// Block 0x81, offset 0x82\n \t{value: 0x0000, lo: 0x02},\n-\t{value: 0x3000, lo: 0x80, hi: 0x8f},\n-\t{value: 0x3000, lo: 0x92, hi: 0xbf},\n+\t{value: 0x5000, lo: 0x80, hi: 0x8f},\n+\t{value: 0x5000, lo: 0x92, hi: 0xbf},\n \t// Block 0x82, offset 0x83\n \t{value: 0x0000, lo: 0x02},\n-\t{value: 0x3000, lo: 0x80, hi: 0x87},\n-\t{value: 0x3000, lo: 0xb0, hi: 0xbc},\n+\t{value: 0x5000, lo: 0x80, hi: 0x87},\n+\t{value: 0x5000, lo: 0xb0, hi: 0xbc},\n \t// Block 0x83, offset 0x84\n \t{value: 0x0000, lo: 0x03},\n-\t{value: 0x3000, lo: 0x90, hi: 0x99},\n+\t{value: 0x5000, lo: 0x90, hi: 0x99},\n \t{value: 0x00e6, lo: 0xa0, hi: 0xa6},\n-\t{value: 0x3000, lo: 0xb0, hi: 0xbf},\n+\t{value: 0x5000, lo: 0xb0, hi: 0xbf},\n \t// Block 0x84, offset 0x85\n \t{value: 0x0000, lo: 0x07},\n-\t{value: 0x3000, lo: 0x80, hi: 0x84},\n-\t{value: 0x3000, lo: 0x87, hi: 0x92},\n-\t{value: 0x3000, lo: 0x94, hi: 0xa6},\n-\t{value: 0x3000, lo: 0xa8, hi: 0xab},\n-\t{value: 0x3000, lo: 0xb0, hi: 0xb2},\n-\t{value: 0x3000, lo: 0xb4, hi: 0xb4},\n-\t{value: 0x3000, lo: 0xb6, hi: 0xbf},\n+\t{value: 0x5000, lo: 0x80, hi: 0x84},\n+\t{value: 0x5000, lo: 0x87, hi: 0x92},\n+\t{value: 0x5000, lo: 0x94, hi: 0xa6},\n+\t{value: 0x5000, lo: 0xa8, hi: 0xab},\n+\t{value: 0x5000, lo: 0xb0, hi: 0xb2},\n+\t{value: 0x5000, lo: 0xb4, hi: 0xb4},\n+\t{value: 0x5000, lo: 0xb6, hi: 0xbf},\n \t// Block 0x85, offset 0x86\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3000, lo: 0x80, hi: 0xbc},\n+\t{value: 0x5000, lo: 0x80, hi: 0xbc},\n \t// Block 0x86, offset 0x87\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3000, lo: 0x81, hi: 0xbf},\n+\t{value: 0x5000, lo: 0x81, hi: 0xbf},\n \t// Block 0x87, offset 0x88\n \t{value: 0x0000, lo: 0x06},\n-\t{value: 0x3000, lo: 0x82, hi: 0x87},\n-\t{value: 0x3000, lo: 0x8a, hi: 0x8f},\n-\t{value: 0x3000, lo: 0x92, hi: 0x97},\n-\t{value: 0x3000, lo: 0x9a, hi: 0x9c},\n-\t{value: 0x3000, lo: 0xa0, hi: 0xa6},\n-\t{value: 0x3000, lo: 0xa8, hi: 0xae},\n+\t{value: 0x5000, lo: 0x82, hi: 0x87},\n+\t{value: 0x5000, lo: 0x8a, hi: 0x8f},\n+\t{value: 0x5000, lo: 0x92, hi: 0x97},\n+\t{value: 0x5000, lo: 0x9a, hi: 0x9c},\n+\t{value: 0x5000, lo: 0xa0, hi: 0xa6},\n+\t{value: 0x5000, lo: 0xa8, hi: 0xae},\n \t// Block 0x88, offset 0x89\n \t{value: 0x0000, lo: 0x01},\n \t{value: 0x00dc, lo: 0xbd, hi: 0xbd},\n@@ -6594,7 +6594,7 @@ var charInfoSparseValues = [757]valueRange{\n \t{value: 0x0009, lo: 0xb9, hi: 0xba},\n \t// Block 0x8b, offset 0x8c\n \t{value: 0x0000, lo: 0x06},\n-\t{value: 0x3300, lo: 0x9e, hi: 0xa4},\n+\t{value: 0x5500, lo: 0x9e, hi: 0xa4},\n \t{value: 0x00d8, lo: 0xa5, hi: 0xa6},\n \t{value: 0x0001, lo: 0xa7, hi: 0xa9},\n \t{value: 0x00e2, lo: 0xad, hi: 0xad},\n@@ -6606,75 +6606,75 @@ var charInfoSparseValues = [757]valueRange{\n \t{value: 0x00e6, lo: 0x85, hi: 0x89},\n \t{value: 0x00dc, lo: 0x8a, hi: 0x8b},\n \t{value: 0x00e6, lo: 0xaa, hi: 0xad},\n-\t{value: 0x3300, lo: 0xbb, hi: 0xbf},\n+\t{value: 0x5500, lo: 0xbb, hi: 0xbf},\n \t// Block 0x8d, offset 0x8e\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3300, lo: 0x80, hi: 0x80},\n+\t{value: 0x5500, lo: 0x80, hi: 0x80},\n \t// Block 0x8e, offset 0x8f\n \t{value: 0x0000, lo: 0x01},\n \t{value: 0x00e6, lo: 0x82, hi: 0x84},\n \t// Block 0x8f, offset 0x90\n \t{value: 0x0000, lo: 0x02},\n-\t{value: 0x3000, lo: 0x80, hi: 0x94},\n-\t{value: 0x3000, lo: 0x96, hi: 0xbf},\n+\t{value: 0x5000, lo: 0x80, hi: 0x94},\n+\t{value: 0x5000, lo: 0x96, hi: 0xbf},\n \t// Block 0x90, offset 0x91\n \t{value: 0x0000, lo: 0x08},\n-\t{value: 0x3000, lo: 0x80, hi: 0x9c},\n-\t{value: 0x3000, lo: 0x9e, hi: 0x9f},\n-\t{value: 0x3000, lo: 0xa2, hi: 0xa2},\n-\t{value: 0x3000, lo: 0xa5, hi: 0xa6},\n-\t{value: 0x3000, lo: 0xa9, hi: 0xac},\n-\t{value: 0x3000, lo: 0xae, hi: 0xb9},\n-\t{value: 0x3000, lo: 0xbb, hi: 0xbb},\n-\t{value: 0x3000, lo: 0xbd, hi: 0xbf},\n+\t{value: 0x5000, lo: 0x80, hi: 0x9c},\n+\t{value: 0x5000, lo: 0x9e, hi: 0x9f},\n+\t{value: 0x5000, lo: 0xa2, hi: 0xa2},\n+\t{value: 0x5000, lo: 0xa5, hi: 0xa6},\n+\t{value: 0x5000, lo: 0xa9, hi: 0xac},\n+\t{value: 0x5000, lo: 0xae, hi: 0xb9},\n+\t{value: 0x5000, lo: 0xbb, hi: 0xbb},\n+\t{value: 0x5000, lo: 0xbd, hi: 0xbf},\n \t// Block 0x91, offset 0x92\n \t{value: 0x0000, lo: 0x02},\n-\t{value: 0x3000, lo: 0x80, hi: 0x83},\n-\t{value: 0x3000, lo: 0x85, hi: 0xbf},\n+\t{value: 0x5000, lo: 0x80, hi: 0x83},\n+\t{value: 0x5000, lo: 0x85, hi: 0xbf},\n \t// Block 0x92, offset 0x93\n \t{value: 0x0000, lo: 0x06},\n-\t{value: 0x3000, lo: 0x80, hi: 0x85},\n-\t{value: 0x3000, lo: 0x87, hi: 0x8a},\n-\t{value: 0x3000, lo: 0x8d, hi: 0x94},\n-\t{value: 0x3000, lo: 0x96, hi: 0x9c},\n-\t{value: 0x3000, lo: 0x9e, hi: 0xb9},\n-\t{value: 0x3000, lo: 0xbb, hi: 0xbe},\n+\t{value: 0x5000, lo: 0x80, hi: 0x85},\n+\t{value: 0x5000, lo: 0x87, hi: 0x8a},\n+\t{value: 0x5000, lo: 0x8d, hi: 0x94},\n+\t{value: 0x5000, lo: 0x96, hi: 0x9c},\n+\t{value: 0x5000, lo: 0x9e, hi: 0xb9},\n+\t{value: 0x5000, lo: 0xbb, hi: 0xbe},\n \t// Block 0x93, offset 0x94\n \t{value: 0x0000, lo: 0x04},\n-\t{value: 0x3000, lo: 0x80, hi: 0x84},\n-\t{value: 0x3000, lo: 0x86, hi: 0x86},\n-\t{value: 0x3000, lo: 0x8a, hi: 0x90},\n-\t{value: 0x3000, lo: 0x92, hi: 0xbf},\n+\t{value: 0x5000, lo: 0x80, hi: 0x84},\n+\t{value: 0x5000, lo: 0x86, hi: 0x86},\n+\t{value: 0x5000, lo: 0x8a, hi: 0x90},\n+\t{value: 0x5000, lo: 0x92, hi: 0xbf},\n \t// Block 0x94, offset 0x95\n \t{value: 0x0000, lo: 0x02},\n-\t{value: 0x3000, lo: 0x80, hi: 0xa5},\n-\t{value: 0x3000, lo: 0xa8, hi: 0xbf},\n+\t{value: 0x5000, lo: 0x80, hi: 0xa5},\n+\t{value: 0x5000, lo: 0xa8, hi: 0xbf},\n \t// Block 0x95, offset 0x96\n \t{value: 0x0000, lo: 0x02},\n-\t{value: 0x3000, lo: 0x80, hi: 0x8b},\n-\t{value: 0x3000, lo: 0x8e, hi: 0xbf},\n+\t{value: 0x5000, lo: 0x80, hi: 0x8b},\n+\t{value: 0x5000, lo: 0x8e, hi: 0xbf},\n \t// Block 0x96, offset 0x97\n \t{value: 0x0000, lo: 0x03},\n-\t{value: 0x3000, lo: 0x80, hi: 0x8a},\n-\t{value: 0x3000, lo: 0x90, hi: 0xae},\n-\t{value: 0x3000, lo: 0xb0, hi: 0xbf},\n+\t{value: 0x5000, lo: 0x80, hi: 0x8a},\n+\t{value: 0x5000, lo: 0x90, hi: 0xae},\n+\t{value: 0x5000, lo: 0xb0, hi: 0xbf},\n \t// Block 0x97, offset 0x98\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3000, lo: 0x80, hi: 0x8f},\n+\t{value: 0x5000, lo: 0x80, hi: 0x8f},\n \t// Block 0x98, offset 0x99\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3000, lo: 0x90, hi: 0x90},\n+\t{value: 0x5000, lo: 0x90, hi: 0x90},\n \t// Block 0x99, offset 0x9a\n \t{value: 0x0000, lo: 0x02},\n-\t{value: 0x3000, lo: 0x80, hi: 0x82},\n-\t{value: 0x3000, lo: 0x90, hi: 0xba},\n+\t{value: 0x5000, lo: 0x80, hi: 0x82},\n+\t{value: 0x5000, lo: 0x90, hi: 0xba},\n \t// Block 0x9a, offset 0x9b\n \t{value: 0x0000, lo: 0x02},\n-\t{value: 0x3000, lo: 0x80, hi: 0x88},\n-\t{value: 0x3000, lo: 0x90, hi: 0x91},\n+\t{value: 0x5000, lo: 0x80, hi: 0x88},\n+\t{value: 0x5000, lo: 0x90, hi: 0x91},\n \t// Block 0x9b, offset 0x9c\n \t{value: 0x0000, lo: 0x01},\n-\t{value: 0x3300, lo: 0x80, hi: 0x9d},\n+\t{value: 0x5500, lo: 0x80, hi: 0x9d},\n }\n \n // charInfoLookup: 1152 bytes"}, {"sha": "bce4530e7bc73c2a05fc65f83f9ea4c5ba079551", "filename": "libgo/go/exp/signal/signal.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fsignal%2Fsignal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fsignal%2Fsignal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsignal%2Fsignal.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "previous_filename": "libgo/go/os/signal/signal.go"}, {"sha": "a7cecb38256313caf9222e5fff40c5f211c33733", "filename": "libgo/go/exp/signal/signal_test.go", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fsignal%2Fsignal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Fsignal%2Fsignal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsignal%2Fsignal_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -12,11 +12,13 @@ import (\n \t\"testing\"\n )\n \n+const sighup = os.UnixSignal(syscall.SIGHUP)\n+\n func TestSignal(t *testing.T) {\n \t// Send this process a SIGHUP.\n \tsyscall.Syscall(syscall.SYS_KILL, uintptr(syscall.Getpid()), syscall.SIGHUP, 0)\n \n-\tif sig := (<-Incoming).(os.UnixSignal); sig != os.SIGHUP {\n-\t\tt.Errorf(\"signal was %v, want %v\", sig, os.SIGHUP)\n+\tif sig := (<-Incoming).(os.UnixSignal); sig != sighup {\n+\t\tt.Errorf(\"signal was %v, want %v\", sig, sighup)\n \t}\n }", "previous_filename": "libgo/go/os/signal/signal_test.go"}, {"sha": "912d467ea08ca87077bd2d035eff1f1956bcd190", "filename": "libgo/go/exp/types/gcimporter_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -31,7 +31,7 @@ func init() {\n \t\tgcPath = gcName\n \t\treturn\n \t}\n-\tgcPath, _ = exec.LookPath(gcName)\n+\tgcPath = filepath.Join(runtime.GOROOT(), \"/bin/tool/\", gcName)\n }\n \n func compile(t *testing.T, dirname, filename string) {"}, {"sha": "1919296ea8f6495f0d72f7671dabc100509dce86", "filename": "libgo/go/expvar/expvar.go", "status": "modified", "additions": 51, "deletions": 49, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexpvar%2Fexpvar.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexpvar%2Fexpvar.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexpvar%2Fexpvar.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -16,7 +16,7 @@\n //\n // The package is sometimes only imported for the side effect of\n // registering its HTTP handler and the above variables.  To use it\n-// this way, simply link this package into your program:\n+// this way, link this package into your program:\n //\timport _ \"expvar\"\n //\n package expvar\n@@ -83,7 +83,7 @@ func (v *Float) Set(value float64) {\n // Map is a string-to-Var map variable that satisfies the Var interface.\n type Map struct {\n \tm  map[string]Var\n-\tmu sync.Mutex\n+\tmu sync.RWMutex\n }\n \n // KeyValue represents a single entry in a Map.\n@@ -93,8 +93,8 @@ type KeyValue struct {\n }\n \n func (v *Map) String() string {\n-\tv.mu.Lock()\n-\tdefer v.mu.Unlock()\n+\tv.mu.RLock()\n+\tdefer v.mu.RUnlock()\n \tb := new(bytes.Buffer)\n \tfmt.Fprintf(b, \"{\")\n \tfirst := true\n@@ -115,8 +115,8 @@ func (v *Map) Init() *Map {\n }\n \n func (v *Map) Get(key string) Var {\n-\tv.mu.Lock()\n-\tdefer v.mu.Unlock()\n+\tv.mu.RLock()\n+\tdefer v.mu.RUnlock()\n \treturn v.m[key]\n }\n \n@@ -127,12 +127,17 @@ func (v *Map) Set(key string, av Var) {\n }\n \n func (v *Map) Add(key string, delta int64) {\n-\tv.mu.Lock()\n-\tdefer v.mu.Unlock()\n+\tv.mu.RLock()\n \tav, ok := v.m[key]\n+\tv.mu.RUnlock()\n \tif !ok {\n-\t\tav = new(Int)\n-\t\tv.m[key] = av\n+\t\t// check again under the write lock\n+\t\tv.mu.Lock()\n+\t\tif _, ok = v.m[key]; !ok {\n+\t\t\tav = new(Int)\n+\t\t\tv.m[key] = av\n+\t\t}\n+\t\tv.mu.Unlock()\n \t}\n \n \t// Add to Int; ignore otherwise.\n@@ -143,12 +148,17 @@ func (v *Map) Add(key string, delta int64) {\n \n // AddFloat adds delta to the *Float value stored under the given map key.\n func (v *Map) AddFloat(key string, delta float64) {\n-\tv.mu.Lock()\n-\tdefer v.mu.Unlock()\n+\tv.mu.RLock()\n \tav, ok := v.m[key]\n+\tv.mu.RUnlock()\n \tif !ok {\n-\t\tav = new(Float)\n-\t\tv.m[key] = av\n+\t\t// check again under the write lock\n+\t\tv.mu.Lock()\n+\t\tif _, ok = v.m[key]; !ok {\n+\t\t\tav = new(Float)\n+\t\t\tv.m[key] = av\n+\t\t}\n+\t\tv.mu.Unlock()\n \t}\n \n \t// Add to Float; ignore otherwise.\n@@ -157,18 +167,15 @@ func (v *Map) AddFloat(key string, delta float64) {\n \t}\n }\n \n-// TODO(rsc): Make sure map access in separate thread is safe.\n-func (v *Map) iterate(c chan<- KeyValue) {\n+// Do calls f for each entry in the map.\n+// The map is locked during the iteration,\n+// but existing entries may be concurrently updated.\n+func (v *Map) Do(f func(KeyValue)) {\n+\tv.mu.RLock()\n+\tdefer v.mu.RUnlock()\n \tfor k, v := range v.m {\n-\t\tc <- KeyValue{k, v}\n+\t\tf(KeyValue{k, v})\n \t}\n-\tclose(c)\n-}\n-\n-func (v *Map) Iter() <-chan KeyValue {\n-\tc := make(chan KeyValue)\n-\tgo v.iterate(c)\n-\treturn c\n }\n \n // String is a string variable, and satisfies the Var interface.\n@@ -190,8 +197,10 @@ func (f Func) String() string {\n }\n \n // All published variables.\n-var vars map[string]Var = make(map[string]Var)\n-var mutex sync.Mutex\n+var (\n+\tmutex sync.RWMutex\n+\tvars  map[string]Var = make(map[string]Var)\n+)\n \n // Publish declares a named exported variable. This should be called from a\n // package's init function when it creates its Vars. If the name is already\n@@ -207,17 +216,11 @@ func Publish(name string, v Var) {\n \n // Get retrieves a named exported variable.\n func Get(name string) Var {\n+\tmutex.RLock()\n+\tdefer mutex.RUnlock()\n \treturn vars[name]\n }\n \n-// RemoveAll removes all exported variables.\n-// This is for tests; don't call this on a real server.\n-func RemoveAll() {\n-\tmutex.Lock()\n-\tdefer mutex.Unlock()\n-\tvars = make(map[string]Var)\n-}\n-\n // Convenience functions for creating new exported variables.\n \n func NewInt(name string) *Int {\n@@ -244,31 +247,28 @@ func NewString(name string) *String {\n \treturn v\n }\n \n-// TODO(rsc): Make sure map access in separate thread is safe.\n-func iterate(c chan<- KeyValue) {\n+// Do calls f for each exported variable.\n+// The global variable map is locked during the iteration,\n+// but existing entries may be concurrently updated.\n+func Do(f func(KeyValue)) {\n+\tmutex.RLock()\n+\tdefer mutex.RUnlock()\n \tfor k, v := range vars {\n-\t\tc <- KeyValue{k, v}\n+\t\tf(KeyValue{k, v})\n \t}\n-\tclose(c)\n-}\n-\n-func Iter() <-chan KeyValue {\n-\tc := make(chan KeyValue)\n-\tgo iterate(c)\n-\treturn c\n }\n \n func expvarHandler(w http.ResponseWriter, r *http.Request) {\n \tw.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n \tfmt.Fprintf(w, \"{\\n\")\n \tfirst := true\n-\tfor name, value := range vars {\n+\tDo(func(kv KeyValue) {\n \t\tif !first {\n \t\t\tfmt.Fprintf(w, \",\\n\")\n \t\t}\n \t\tfirst = false\n-\t\tfmt.Fprintf(w, \"%q: %s\", name, value)\n-\t}\n+\t\tfmt.Fprintf(w, \"%q: %s\", kv.Key, kv.Value)\n+\t})\n \tfmt.Fprintf(w, \"\\n}\\n\")\n }\n \n@@ -277,11 +277,13 @@ func cmdline() interface{} {\n }\n \n func memstats() interface{} {\n-\treturn runtime.MemStats\n+\tstats := new(runtime.MemStats)\n+\truntime.ReadMemStats(stats)\n+\treturn *stats\n }\n \n func init() {\n-\thttp.Handle(\"/debug/vars\", http.HandlerFunc(expvarHandler))\n+\thttp.HandleFunc(\"/debug/vars\", expvarHandler)\n \tPublish(\"cmdline\", Func(cmdline))\n \tPublish(\"memstats\", Func(memstats))\n }"}, {"sha": "bbd9dd8d6e94308d085cff3e5ea3c5b0cb7c19c4", "filename": "libgo/go/expvar/expvar_test.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexpvar%2Fexpvar_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fexpvar%2Fexpvar_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexpvar%2Fexpvar_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -9,6 +9,14 @@ import (\n \t\"testing\"\n )\n \n+// RemoveAll removes all exported variables.\n+// This is for tests only.\n+func RemoveAll() {\n+\tmutex.Lock()\n+\tdefer mutex.Unlock()\n+\tvars = make(map[string]Var)\n+}\n+\n func TestInt(t *testing.T) {\n \treqs := NewInt(\"requests\")\n \tif reqs.i != 0 {"}, {"sha": "c28d0e7207428b23060575193ebe4b0b6fb5082f", "filename": "libgo/go/flag/flag.go", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -49,6 +49,7 @@\n \n \tInteger flags accept 1234, 0664, 0x1234 and may be negative.\n \tBoolean flags may be 1, 0, t, f, true, false, TRUE, FALSE, True, False.\n+\tDuration flags accept any input valid for time.ParseDuration.\n \n \tThe default set of command-line flags is controlled by\n \ttop-level functions.  The FlagSet type allows one to define\n@@ -62,6 +63,7 @@ package flag\n import (\n \t\"errors\"\n \t\"fmt\"\n+\t\"io\"\n \t\"os\"\n \t\"sort\"\n \t\"strconv\"\n@@ -228,6 +230,7 @@ type FlagSet struct {\n \targs          []string // arguments after flags\n \texitOnError   bool     // does the program exit if there's an error?\n \terrorHandling ErrorHandling\n+\toutput        io.Writer // nil means stderr; use out() accessor\n }\n \n // A Flag represents the state of a flag.\n@@ -254,6 +257,19 @@ func sortFlags(flags map[string]*Flag) []*Flag {\n \treturn result\n }\n \n+func (f *FlagSet) out() io.Writer {\n+\tif f.output == nil {\n+\t\treturn os.Stderr\n+\t}\n+\treturn f.output\n+}\n+\n+// SetOutput sets the destination for usage and error messages.\n+// If output is nil, os.Stderr is used.\n+func (f *FlagSet) SetOutput(output io.Writer) {\n+\tf.output = output\n+}\n+\n // VisitAll visits the flags in lexicographical order, calling fn for each.\n // It visits all flags, even those not set.\n func (f *FlagSet) VisitAll(fn func(*Flag)) {\n@@ -315,15 +331,16 @@ func Set(name, value string) error {\n \treturn commandLine.Set(name, value)\n }\n \n-// PrintDefaults prints to standard error the default values of all defined flags in the set.\n+// PrintDefaults prints, to standard error unless configured\n+// otherwise, the default values of all defined flags in the set.\n func (f *FlagSet) PrintDefaults() {\n-\tf.VisitAll(func(f *Flag) {\n+\tf.VisitAll(func(flag *Flag) {\n \t\tformat := \"  -%s=%s: %s\\n\"\n-\t\tif _, ok := f.Value.(*stringValue); ok {\n+\t\tif _, ok := flag.Value.(*stringValue); ok {\n \t\t\t// put quotes on the value\n \t\t\tformat = \"  -%s=%q: %s\\n\"\n \t\t}\n-\t\tfmt.Fprintf(os.Stderr, format, f.Name, f.DefValue, f.Usage)\n+\t\tfmt.Fprintf(f.out(), format, flag.Name, flag.DefValue, flag.Usage)\n \t})\n }\n \n@@ -334,7 +351,7 @@ func PrintDefaults() {\n \n // defaultUsage is the default function to print a usage message.\n func defaultUsage(f *FlagSet) {\n-\tfmt.Fprintf(os.Stderr, \"Usage of %s:\\n\", f.name)\n+\tfmt.Fprintf(f.out(), \"Usage of %s:\\n\", f.name)\n \tf.PrintDefaults()\n }\n \n@@ -601,7 +618,7 @@ func (f *FlagSet) Var(value Value, name string, usage string) {\n \tflag := &Flag{name, usage, value, value.String()}\n \t_, alreadythere := f.formal[name]\n \tif alreadythere {\n-\t\tfmt.Fprintf(os.Stderr, \"%s flag redefined: %s\\n\", f.name, name)\n+\t\tfmt.Fprintf(f.out(), \"%s flag redefined: %s\\n\", f.name, name)\n \t\tpanic(\"flag redefinition\") // Happens only if flags are declared with identical names\n \t}\n \tif f.formal == nil {\n@@ -624,7 +641,7 @@ func Var(value Value, name string, usage string) {\n // returns the error.\n func (f *FlagSet) failf(format string, a ...interface{}) error {\n \terr := fmt.Errorf(format, a...)\n-\tfmt.Fprintln(os.Stderr, err)\n+\tfmt.Fprintln(f.out(), err)\n \tf.usage()\n \treturn err\n }"}, {"sha": "a9561f269f91ff32bfc31f1f820b28f626407985", "filename": "libgo/go/flag/flag_test.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fflag%2Fflag_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fflag%2Fflag_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -5,10 +5,12 @@\n package flag_test\n \n import (\n+\t\"bytes\"\n \t. \"flag\"\n \t\"fmt\"\n \t\"os\"\n \t\"sort\"\n+\t\"strings\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -206,6 +208,17 @@ func TestUserDefined(t *testing.T) {\n \t}\n }\n \n+func TestSetOutput(t *testing.T) {\n+\tvar flags FlagSet\n+\tvar buf bytes.Buffer\n+\tflags.SetOutput(&buf)\n+\tflags.Init(\"test\", ContinueOnError)\n+\tflags.Parse([]string{\"-unknown\"})\n+\tif out := buf.String(); !strings.Contains(out, \"-unknown\") {\n+\t\tt.Logf(\"expected output mentioning unknown; got %q\", out)\n+\t}\n+}\n+\n // This tests that one can reset the flags. This still works but not well, and is\n // superseded by FlagSet.\n func TestChangingArgs(t *testing.T) {"}, {"sha": "1b02f52baa9fcd2121f987f278c40c1667ee9d70", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -443,6 +443,14 @@ var fmttests = []struct {\n \t{\"%s\", nil, \"%!s(<nil>)\"},\n \t{\"%T\", nil, \"<nil>\"},\n \t{\"%-1\", 100, \"%!(NOVERB)%!(EXTRA int=100)\"},\n+\n+\t// The \"<nil>\" show up because maps are printed by\n+\t// first obtaining a list of keys and then looking up\n+\t// each key.  Since NaNs can be map keys but cannot\n+\t// be fetched directly, the lookup fails and returns a\n+\t// zero reflect.Value, which formats as <nil>.\n+\t// This test is just to check that it shows the two NaNs at all.\n+\t{\"%v\", map[float64]int{math.NaN(): 1, math.NaN(): 2}, \"map[NaN:<nil> NaN:<nil>]\"},\n }\n \n func TestSprintf(t *testing.T) {\n@@ -532,13 +540,14 @@ var _ bytes.Buffer\n func TestCountMallocs(t *testing.T) {\n \tfor _, mt := range mallocTest {\n \t\tconst N = 100\n-\t\truntime.UpdateMemStats()\n-\t\tmallocs := 0 - runtime.MemStats.Mallocs\n+\t\tmemstats := new(runtime.MemStats)\n+\t\truntime.ReadMemStats(memstats)\n+\t\tmallocs := 0 - memstats.Mallocs\n \t\tfor i := 0; i < N; i++ {\n \t\t\tmt.fn()\n \t\t}\n-\t\truntime.UpdateMemStats()\n-\t\tmallocs += runtime.MemStats.Mallocs\n+\t\truntime.ReadMemStats(memstats)\n+\t\tmallocs += memstats.Mallocs\n \t\tif mallocs/N > uint64(mt.count) {\n \t\t\tt.Errorf(\"%s: expected %d mallocs, got %d\", mt.desc, mt.count, mallocs/N)\n \t\t}"}, {"sha": "36c6aebad0e12f244a7b89384d579e87bbd5d9c4", "filename": "libgo/go/fmt/scan.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Ffmt%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Ffmt%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -366,6 +366,7 @@ func newScanState(r io.Reader, nlIsSpace, nlIsEnd bool) (s *ss, old ssave) {\n \ts.fieldLimit = hugeWid\n \ts.maxWid = hugeWid\n \ts.validSave = true\n+\ts.count = 0\n \treturn\n }\n "}, {"sha": "3c706a46edda484793f4e7da866e1c89ff112e2e", "filename": "libgo/go/go/build/build_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -71,6 +71,8 @@ func TestBuild(t *testing.T) {\n \t\t\tt.Errorf(\"ScanDir(%#q): %v\", tt.dir, err)\n \t\t\tcontinue\n \t\t}\n+\t\t// Don't bother testing import positions.\n+\t\ttt.info.ImportPos, tt.info.TestImportPos = info.ImportPos, info.TestImportPos\n \t\tif !reflect.DeepEqual(info, tt.info) {\n \t\t\tt.Errorf(\"ScanDir(%#q) = %#v, want %#v\\n\", tt.dir, info, tt.info)\n \t\t\tcontinue"}, {"sha": "0917e736aa46d17b856feed8fd8b26dd0281508a", "filename": "libgo/go/go/build/dir.go", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -116,10 +116,11 @@ func envOr(name, def string) string {\n }\n \n type DirInfo struct {\n-\tPackage        string            // Name of package in dir\n-\tPackageComment *ast.CommentGroup // Package comments from GoFiles\n-\tImportPath     string            // Import path of package in dir\n-\tImports        []string          // All packages imported by GoFiles\n+\tPackage        string                      // Name of package in dir\n+\tPackageComment *ast.CommentGroup           // Package comments from GoFiles\n+\tImportPath     string                      // Import path of package in dir\n+\tImports        []string                    // All packages imported by GoFiles\n+\tImportPos      map[string][]token.Position // Source code location of imports\n \n \t// Source files\n \tGoFiles  []string // .go files in dir (excluding CgoFiles, TestGoFiles, XTestGoFiles)\n@@ -134,9 +135,10 @@ type DirInfo struct {\n \tCgoLDFLAGS   []string // Cgo LDFLAGS directives\n \n \t// Test information\n-\tTestGoFiles  []string // _test.go files in package\n-\tXTestGoFiles []string // _test.go files outside package\n-\tTestImports  []string // All packages imported by (X)TestGoFiles\n+\tTestGoFiles   []string // _test.go files in package\n+\tXTestGoFiles  []string // _test.go files outside package\n+\tTestImports   []string // All packages imported by (X)TestGoFiles\n+\tTestImportPos map[string][]token.Position\n }\n \n func (d *DirInfo) IsCommand() bool {\n@@ -223,8 +225,8 @@ func (ctxt *Context) ScanDir(dir string) (info *DirInfo, err error) {\n \n \tvar Sfiles []string // files with \".S\" (capital S)\n \tvar di DirInfo\n-\timported := make(map[string]bool)\n-\ttestImported := make(map[string]bool)\n+\timported := make(map[string][]token.Position)\n+\ttestImported := make(map[string][]token.Position)\n \tfset := token.NewFileSet()\n \tfor _, d := range dirs {\n \t\tif d.IsDir() {\n@@ -327,9 +329,9 @@ func (ctxt *Context) ScanDir(dir string) (info *DirInfo, err error) {\n \t\t\t\t\tlog.Panicf(\"%s: parser returned invalid quoted string: <%s>\", filename, quoted)\n \t\t\t\t}\n \t\t\t\tif isTest {\n-\t\t\t\t\ttestImported[path] = true\n+\t\t\t\t\ttestImported[path] = append(testImported[path], fset.Position(spec.Pos()))\n \t\t\t\t} else {\n-\t\t\t\t\timported[path] = true\n+\t\t\t\t\timported[path] = append(imported[path], fset.Position(spec.Pos()))\n \t\t\t\t}\n \t\t\t\tif path == \"C\" {\n \t\t\t\t\tif isTest {\n@@ -366,12 +368,14 @@ func (ctxt *Context) ScanDir(dir string) (info *DirInfo, err error) {\n \t\treturn nil, fmt.Errorf(\"%s: no Go source files\", dir)\n \t}\n \tdi.Imports = make([]string, len(imported))\n+\tdi.ImportPos = imported\n \ti := 0\n \tfor p := range imported {\n \t\tdi.Imports[i] = p\n \t\ti++\n \t}\n \tdi.TestImports = make([]string, len(testImported))\n+\tdi.TestImportPos = testImported\n \ti = 0\n \tfor p := range testImported {\n \t\tdi.TestImports[i] = p"}, {"sha": "6f0edd4bade3b7fb78dcfe148d018cef9ef89ba5", "filename": "libgo/go/go/doc/comment.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -56,7 +56,7 @@ const (\n \t\tfilePart + `([:.,]` + filePart + `)*`\n )\n \n-var matchRx = regexp.MustCompile(`(` + identRx + `)|(` + urlRx + `)`)\n+var matchRx = regexp.MustCompile(`(` + urlRx + `)|(` + identRx + `)`)\n \n var (\n \thtml_a      = []byte(`<a href=\"`)\n@@ -87,7 +87,7 @@ func emphasize(w io.Writer, line string, words map[string]string, nice bool) {\n \t\tif m == nil {\n \t\t\tbreak\n \t\t}\n-\t\t// m >= 6 (two parenthesized sub-regexps in matchRx, 1st one is identRx)\n+\t\t// m >= 6 (two parenthesized sub-regexps in matchRx, 1st one is urlRx)\n \n \t\t// write text before match\n \t\tcommentEscape(w, line[0:m[0]], nice)\n@@ -99,8 +99,8 @@ func emphasize(w io.Writer, line string, words map[string]string, nice bool) {\n \t\tif words != nil {\n \t\t\turl, italics = words[string(match)]\n \t\t}\n-\t\tif m[2] < 0 {\n-\t\t\t// didn't match against first parenthesized sub-regexp; must be match against urlRx\n+\t\tif m[2] >= 0 {\n+\t\t\t// match against first parenthesized sub-regexp; must be match against urlRx\n \t\t\tif !italics {\n \t\t\t\t// no alternative URL in words list, use match instead\n \t\t\t\turl = string(match)\n@@ -336,7 +336,7 @@ func blocks(text string) []block {\n \n \t\tif lastWasBlank && !lastWasHeading && i+2 < len(lines) &&\n \t\t\tisBlank(lines[i+1]) && !isBlank(lines[i+2]) && indentLen(lines[i+2]) == 0 {\n-\t\t\t// current line is non-blank, sourounded by blank lines\n+\t\t\t// current line is non-blank, surrounded by blank lines\n \t\t\t// and the next non-blank line is not indented: this\n \t\t\t// might be a heading.\n \t\t\tif head := heading(line); head != \"\" {"}, {"sha": "aa21b8d1b30765e8699445f97f8f105f1ee19721", "filename": "libgo/go/go/doc/comment_test.go", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -5,6 +5,7 @@\n package doc\n \n import (\n+\t\"bytes\"\n \t\"reflect\"\n \t\"testing\"\n )\n@@ -81,3 +82,28 @@ func TestBlocks(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+var emphasizeTests = []struct {\n+\tin  string\n+\tout string\n+}{\n+\t{\"http://www.google.com/\", `<a href=\"http://www.google.com/\">http://www.google.com/</a>`},\n+\t{\"https://www.google.com/\", `<a href=\"https://www.google.com/\">https://www.google.com/</a>`},\n+\t{\"http://www.google.com/path.\", `<a href=\"http://www.google.com/path\">http://www.google.com/path</a>.`},\n+\t{\"(http://www.google.com/)\", `(<a href=\"http://www.google.com/\">http://www.google.com/</a>)`},\n+\t{\"Foo bar http://example.com/ quux!\", `Foo bar <a href=\"http://example.com/\">http://example.com/</a> quux!`},\n+\t{\"Hello http://example.com/%2f/ /world.\", `Hello <a href=\"http://example.com/%2f/\">http://example.com/%2f/</a> /world.`},\n+\t{\"Lorem http: ipsum //host/path\", \"Lorem http: ipsum //host/path\"},\n+\t{\"javascript://is/not/linked\", \"javascript://is/not/linked\"},\n+}\n+\n+func TestEmphasize(t *testing.T) {\n+\tfor i, tt := range emphasizeTests {\n+\t\tvar buf bytes.Buffer\n+\t\temphasize(&buf, tt.in, nil, true)\n+\t\tout := buf.String()\n+\t\tif out != tt.out {\n+\t\t\tt.Errorf(\"#%d: mismatch\\nhave: %v\\nwant: %v\", i, out, tt.out)\n+\t\t}\n+\t}\n+}"}, {"sha": "9c606315d406f5a498338258cd6491d7c0c4350f", "filename": "libgo/go/go/doc/doc.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -68,6 +68,10 @@ const (\n \t// extract documentation for all package-level declarations,\n \t// not just exported ones\n \tAllDecls Mode = 1 << iota\n+\n+\t// show all embedded methods, not just the ones of\n+\t// invisible (unexported) anonymous fields\n+\tAllMethods\n )\n \n // New computes the package documentation for the given package AST.\n@@ -86,8 +90,8 @@ func New(pkg *ast.Package, importPath string, mode Mode) *Package {\n \t\tFilenames:  r.filenames,\n \t\tBugs:       r.bugs,\n \t\tConsts:     sortedValues(r.values, token.CONST),\n-\t\tTypes:      sortedTypes(r.types),\n+\t\tTypes:      sortedTypes(r.types, mode&AllMethods != 0),\n \t\tVars:       sortedValues(r.values, token.VAR),\n-\t\tFuncs:      sortedFuncs(r.funcs),\n+\t\tFuncs:      sortedFuncs(r.funcs, true),\n \t}\n }"}, {"sha": "9ffe72032c23acc54394dd53faaeff6c4788885c", "filename": "libgo/go/go/doc/doc_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -118,4 +118,5 @@ func test(t *testing.T, mode Mode) {\n func Test(t *testing.T) {\n \ttest(t, 0)\n \ttest(t, AllDecls)\n+\ttest(t, AllMethods)\n }"}, {"sha": "d5b58d266436ed8247fd8c3abe44d637888eaa2b", "filename": "libgo/go/go/doc/example.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -33,8 +33,11 @@ func Examples(pkg *ast.Package) []*Example {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\texamples = append(examples, &Example{\n-\t\t\t\tName:   name[len(\"Example\"):],\n-\t\t\t\tBody:   &printer.CommentedNode{f.Body, src.Comments},\n+\t\t\t\tName: name[len(\"Example\"):],\n+\t\t\t\tBody: &printer.CommentedNode{\n+\t\t\t\t\tNode:     f.Body,\n+\t\t\t\t\tComments: src.Comments,\n+\t\t\t\t},\n \t\t\t\tOutput: f.Doc.Text(),\n \t\t\t})\n \t\t}"}, {"sha": "68dd3841bed2bb59efaebedfbfe6dfa0000b7f66", "filename": "libgo/go/go/doc/exports.go", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -23,11 +23,11 @@ func filterIdentList(list []*ast.Ident) []*ast.Ident {\n }\n \n // filterFieldList removes unexported fields (field names) from the field list\n-// in place and returns true if fields were removed. Removed fields that are\n-// anonymous (embedded) fields are added as embedded types to base. filterType\n-// is called with the types of all remaining fields.\n+// in place and returns true if fields were removed. Anonymous fields are\n+// recorded with the parent type. filterType is called with the types of\n+// all remaining fields.\n //\n-func (r *reader) filterFieldList(base *baseType, fields *ast.FieldList) (removedFields bool) {\n+func (r *reader) filterFieldList(parent *namedType, fields *ast.FieldList) (removedFields bool) {\n \tif fields == nil {\n \t\treturn\n \t}\n@@ -37,18 +37,9 @@ func (r *reader) filterFieldList(base *baseType, fields *ast.FieldList) (removed\n \t\tkeepField := false\n \t\tif n := len(field.Names); n == 0 {\n \t\t\t// anonymous field\n-\t\t\tname, imp := baseTypeName(field.Type)\n+\t\t\tname := r.recordAnonymousField(parent, field.Type)\n \t\t\tif ast.IsExported(name) {\n-\t\t\t\t// we keep the field - in this case r.readDecl\n-\t\t\t\t// will take care of adding the embedded type\n \t\t\t\tkeepField = true\n-\t\t\t} else if base != nil && !imp {\n-\t\t\t\t// we don't keep the field - add it as an embedded\n-\t\t\t\t// type so we won't loose its methods, if any\n-\t\t\t\tif embedded := r.lookupType(name); embedded != nil {\n-\t\t\t\t\t_, ptr := field.Type.(*ast.StarExpr)\n-\t\t\t\t\tbase.addEmbeddedType(embedded, ptr)\n-\t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\tfield.Names = filterIdentList(field.Names)\n@@ -86,7 +77,7 @@ func (r *reader) filterParamList(fields *ast.FieldList) {\n // in place. If fields (or methods) have been removed, the corresponding\n // struct or interface type has the Incomplete field set to true. \n //\n-func (r *reader) filterType(base *baseType, typ ast.Expr) {\n+func (r *reader) filterType(parent *namedType, typ ast.Expr) {\n \tswitch t := typ.(type) {\n \tcase *ast.Ident:\n \t\t// nothing to do\n@@ -95,14 +86,14 @@ func (r *reader) filterType(base *baseType, typ ast.Expr) {\n \tcase *ast.ArrayType:\n \t\tr.filterType(nil, t.Elt)\n \tcase *ast.StructType:\n-\t\tif r.filterFieldList(base, t.Fields) {\n+\t\tif r.filterFieldList(parent, t.Fields) {\n \t\t\tt.Incomplete = true\n \t\t}\n \tcase *ast.FuncType:\n \t\tr.filterParamList(t.Params)\n \t\tr.filterParamList(t.Results)\n \tcase *ast.InterfaceType:\n-\t\tif r.filterFieldList(base, t.Methods) {\n+\t\tif r.filterFieldList(parent, t.Methods) {\n \t\t\tt.Incomplete = true\n \t\t}\n \tcase *ast.MapType:\n@@ -150,6 +141,10 @@ func (r *reader) filterDecl(decl ast.Decl) bool {\n \t\td.Specs = r.filterSpecList(d.Specs)\n \t\treturn len(d.Specs) > 0\n \tcase *ast.FuncDecl:\n+\t\t// ok to filter these methods early because any\n+\t\t// conflicting method will be filtered here, too -\n+\t\t// thus, removing these methods early will not lead\n+\t\t// to the false removal of possible conflicts\n \t\treturn ast.IsExported(d.Name.Name)\n \t}\n \treturn false"}, {"sha": "dcf49f68fd378d5e070fd7dc3cf38f2a876db2a9", "filename": "libgo/go/go/doc/reader.go", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -89,7 +89,7 @@ func (mset methodSet) add(m *Func) {\n }\n \n // ----------------------------------------------------------------------------\n-// Base types\n+// Named types\n \n // baseTypeName returns the name of the base type of x (or \"\")\n // and whether the type is imported or not.\n@@ -110,31 +110,23 @@ func baseTypeName(x ast.Expr) (name string, imported bool) {\n \treturn\n }\n \n-// embeddedType describes the type of an anonymous field.\n+// A namedType represents a named unqualified (package local, or possibly\n+// predeclared) type. The namedType for a type name is always found via\n+// reader.lookupType.\n //\n-type embeddedType struct {\n-\ttyp *baseType // the corresponding base type\n-\tptr bool      // if set, the anonymous field type is a pointer\n-}\n-\n-type baseType struct {\n+type namedType struct {\n \tdoc  string       // doc comment for type\n-\tname string       // local type name (excluding package qualifier)\n+\tname string       // type name\n \tdecl *ast.GenDecl // nil if declaration hasn't been seen yet\n \n+\tisEmbedded bool                // true if this type is embedded\n+\tisStruct   bool                // true if this type is a struct\n+\tembedded   map[*namedType]bool // true if the embedded type is a pointer\n+\n \t// associated declarations\n \tvalues  []*Value // consts and vars\n \tfuncs   methodSet\n \tmethods methodSet\n-\n-\tisEmbedded bool           // true if this type is embedded\n-\tisStruct   bool           // true if this type is a struct\n-\tembedded   []embeddedType // list of embedded types\n-}\n-\n-func (typ *baseType) addEmbeddedType(e *baseType, isPtr bool) {\n-\te.isEmbedded = true\n-\ttyp.embedded = append(typ.embedded, embeddedType{e, isPtr})\n }\n \n // ----------------------------------------------------------------------------\n@@ -158,12 +150,10 @@ type reader struct {\n \t// declarations\n \timports map[string]int\n \tvalues  []*Value // consts and vars\n-\ttypes   map[string]*baseType\n+\ttypes   map[string]*namedType\n \tfuncs   methodSet\n }\n \n-// isVisible reports whether name is visible in the documentation.\n-//\n func (r *reader) isVisible(name string) bool {\n \treturn r.mode&AllDecls != 0 || ast.IsExported(name)\n }\n@@ -173,23 +163,42 @@ func (r *reader) isVisible(name string) bool {\n // type with the given name but no associated declaration\n // is added to the type map.\n //\n-func (r *reader) lookupType(name string) *baseType {\n+func (r *reader) lookupType(name string) *namedType {\n \tif name == \"\" || name == \"_\" {\n \t\treturn nil // no type docs for anonymous types\n \t}\n \tif typ, found := r.types[name]; found {\n \t\treturn typ\n \t}\n \t// type not found - add one without declaration\n-\ttyp := &baseType{\n-\t\tname:    name,\n-\t\tfuncs:   make(methodSet),\n-\t\tmethods: make(methodSet),\n+\ttyp := &namedType{\n+\t\tname:     name,\n+\t\tembedded: make(map[*namedType]bool),\n+\t\tfuncs:    make(methodSet),\n+\t\tmethods:  make(methodSet),\n \t}\n \tr.types[name] = typ\n \treturn typ\n }\n \n+// recordAnonymousField registers fieldType as the type of an\n+// anonymous field in the parent type. If the field is imported\n+// (qualified name) or the parent is nil, the field is ignored.\n+// The function returns the field name.\n+//\n+func (r *reader) recordAnonymousField(parent *namedType, fieldType ast.Expr) (fname string) {\n+\tfname, imp := baseTypeName(fieldType)\n+\tif parent == nil || imp {\n+\t\treturn\n+\t}\n+\tif ftype := r.lookupType(fname); ftype != nil {\n+\t\tftype.isEmbedded = true\n+\t\t_, ptr := fieldType.(*ast.StarExpr)\n+\t\tparent.embedded[ftype] = ptr\n+\t}\n+\treturn\n+}\n+\n func (r *reader) readDoc(comment *ast.CommentGroup) {\n \t// By convention there should be only one package comment\n \t// but collect all of them if there are more then one.\n@@ -232,7 +241,7 @@ func (r *reader) readValue(decl *ast.GenDecl) {\n \t\tswitch {\n \t\tcase s.Type != nil:\n \t\t\t// a type is present; determine its name\n-\t\t\tif n, imp := baseTypeName(s.Type); !imp && r.isVisible(n) {\n+\t\t\tif n, imp := baseTypeName(s.Type); !imp {\n \t\t\t\tname = n\n \t\t\t}\n \t\tcase decl.Tok == token.CONST:\n@@ -267,8 +276,7 @@ func (r *reader) readValue(decl *ast.GenDecl) {\n \tconst threshold = 0.75\n \tif domName != \"\" && domFreq >= int(float64(len(decl.Specs))*threshold) {\n \t\t// typed entries are sufficiently frequent\n-\t\ttyp := r.lookupType(domName)\n-\t\tif typ != nil {\n+\t\tif typ := r.lookupType(domName); typ != nil {\n \t\t\tvalues = &typ.values // associate with that type\n \t\t}\n \t}\n@@ -321,22 +329,14 @@ func (r *reader) readType(decl *ast.GenDecl, spec *ast.TypeSpec) {\n \tdecl.Doc = nil // doc consumed - remove from AST\n \ttyp.doc = doc.Text()\n \n-\t// look for anonymous fields that might contribute methods\n+\t// record anonymous fields (they may contribute methods)\n+\t// (some fields may have been recorded already when filtering\n+\t// exports, but that's ok)\n \tvar list []*ast.Field\n \tlist, typ.isStruct = fields(spec.Type)\n \tfor _, field := range list {\n \t\tif len(field.Names) == 0 {\n-\t\t\t// anonymous field - add corresponding field type to typ\n-\t\t\tn, imp := baseTypeName(field.Type)\n-\t\t\tif imp {\n-\t\t\t\t// imported type - we don't handle this case\n-\t\t\t\t// at the moment\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tif embedded := r.lookupType(n); embedded != nil {\n-\t\t\t\t_, ptr := field.Type.(*ast.StarExpr)\n-\t\t\t\ttyp.addEmbeddedType(embedded, ptr)\n-\t\t\t}\n+\t\t\tr.recordAnonymousField(typ, field.Type)\n \t\t}\n \t}\n }\n@@ -347,7 +347,7 @@ func (r *reader) readFunc(fun *ast.FuncDecl) {\n \t// strip function body\n \tfun.Body = nil\n \n-\t// determine if it should be associated with a type\n+\t// associate methods with the receiver type, if any\n \tif fun.Recv != nil {\n \t\t// method\n \t\trecvTypeName, imp := baseTypeName(fun.Recv.List[0].Type)\n@@ -356,33 +356,18 @@ func (r *reader) readFunc(fun *ast.FuncDecl) {\n \t\t\t// don't show this method\n \t\t\treturn\n \t\t}\n-\t\tvar typ *baseType\n-\t\tif r.isVisible(recvTypeName) {\n-\t\t\t// visible recv type: if not found, add it to r.types\n-\t\t\ttyp = r.lookupType(recvTypeName)\n-\t\t} else {\n-\t\t\t// invisible recv type: if not found, do not add it\n-\t\t\t// (invisible embedded types are added before this\n-\t\t\t// phase, so if the type doesn't exist yet, we don't\n-\t\t\t// care about this method)\n-\t\t\ttyp = r.types[recvTypeName]\n-\t\t}\n-\t\tif typ != nil {\n-\t\t\t// associate method with the type\n-\t\t\t// (if the type is not exported, it may be embedded\n-\t\t\t// somewhere so we need to collect the method anyway)\n+\t\tif typ := r.lookupType(recvTypeName); typ != nil {\n \t\t\ttyp.methods.set(fun)\n \t\t}\n-\t\t// otherwise don't show the method\n+\t\t// otherwise ignore the method\n \t\t// TODO(gri): There may be exported methods of non-exported types\n \t\t// that can be called because of exported values (consts, vars, or\n \t\t// function results) of that type. Could determine if that is the\n \t\t// case and then show those methods in an appropriate section.\n \t\treturn\n \t}\n \n-\t// perhaps a factory function\n-\t// determine result type, if any\n+\t// associate factory functions with the first visible result type, if any\n \tif fun.Type.Results.NumFields() >= 1 {\n \t\tres := fun.Type.Results.List[0]\n \t\tif len(res.Names) <= 1 {\n@@ -391,7 +376,7 @@ func (r *reader) readFunc(fun *ast.FuncDecl) {\n \t\t\t// be more than one result)\n \t\t\tif n, imp := baseTypeName(res.Type); !imp && r.isVisible(n) {\n \t\t\t\tif typ := r.lookupType(n); typ != nil {\n-\t\t\t\t\t// associate Func with typ\n+\t\t\t\t\t// associate function with typ\n \t\t\t\t\ttyp.funcs.set(fun)\n \t\t\t\t\treturn\n \t\t\t\t}\n@@ -476,7 +461,7 @@ func (r *reader) readPackage(pkg *ast.Package, mode Mode) {\n \tr.filenames = make([]string, len(pkg.Files))\n \tr.imports = make(map[string]int)\n \tr.mode = mode\n-\tr.types = make(map[string]*baseType)\n+\tr.types = make(map[string]*namedType)\n \tr.funcs = make(methodSet)\n \n \t// sort package files before reading them so that the\n@@ -506,13 +491,15 @@ var predeclaredTypes = map[string]bool{\n \t\"byte\":       true,\n \t\"complex64\":  true,\n \t\"complex128\": true,\n+\t\"error\":      true,\n \t\"float32\":    true,\n \t\"float64\":    true,\n \t\"int\":        true,\n \t\"int8\":       true,\n \t\"int16\":      true,\n \t\"int32\":      true,\n \t\"int64\":      true,\n+\t\"rune\":       true,\n \t\"string\":     true,\n \t\"uint\":       true,\n \t\"uint8\":      true,\n@@ -554,24 +541,23 @@ func customizeRecv(f *Func, recvTypeName string, embeddedIsPtr bool, level int)\n \treturn &newF\n }\n \n-// collectEmbeddedMethods collects the embedded methods from\n-// all processed embedded types found in info in mset.\n+// collectEmbeddedMethods collects the embedded methods of typ in mset.\n //\n-func collectEmbeddedMethods(mset methodSet, typ *baseType, recvTypeName string, embeddedIsPtr bool, level int) {\n-\tfor _, e := range typ.embedded {\n+func (r *reader) collectEmbeddedMethods(mset methodSet, typ *namedType, recvTypeName string, embeddedIsPtr bool, level int) {\n+\tfor embedded, isPtr := range typ.embedded {\n \t\t// Once an embedded type is embedded as a pointer type\n \t\t// all embedded types in those types are treated like\n \t\t// pointer types for the purpose of the receiver type\n \t\t// computation; i.e., embeddedIsPtr is sticky for this\n \t\t// embedding hierarchy.\n-\t\tthisEmbeddedIsPtr := embeddedIsPtr || e.ptr\n-\t\tfor _, m := range e.typ.methods {\n+\t\tthisEmbeddedIsPtr := embeddedIsPtr || isPtr\n+\t\tfor _, m := range embedded.methods {\n \t\t\t// only top-level methods are embedded\n \t\t\tif m.Level == 0 {\n \t\t\t\tmset.add(customizeRecv(m, recvTypeName, thisEmbeddedIsPtr, level))\n \t\t\t}\n \t\t}\n-\t\tcollectEmbeddedMethods(mset, e.typ, recvTypeName, thisEmbeddedIsPtr, level+1)\n+\t\tr.collectEmbeddedMethods(mset, embedded, recvTypeName, thisEmbeddedIsPtr, level+1)\n \t}\n }\n \n@@ -582,7 +568,7 @@ func (r *reader) computeMethodSets() {\n \t\t// collect embedded methods for t\n \t\tif t.isStruct {\n \t\t\t// struct\n-\t\t\tcollectEmbeddedMethods(t.methods, t, t.name, false, 1)\n+\t\t\tr.collectEmbeddedMethods(t.methods, t, t.name, false, 1)\n \t\t} else {\n \t\t\t// interface\n \t\t\t// TODO(gri) fix this\n@@ -607,6 +593,8 @@ func (r *reader) cleanupTypes() {\n \t\t\tr.values = append(r.values, t.values...)\n \t\t\t// 2) move factory functions\n \t\t\tfor name, f := range t.funcs {\n+\t\t\t\t// in a correct AST, package-level function names\n+\t\t\t\t// are all different - no need to check for conflicts\n \t\t\t\tr.funcs[name] = f\n \t\t\t}\n \t\t\t// 3) move methods\n@@ -689,7 +677,7 @@ func sortedValues(m []*Value, tok token.Token) []*Value {\n \treturn list\n }\n \n-func sortedTypes(m map[string]*baseType) []*Type {\n+func sortedTypes(m map[string]*namedType, allMethods bool) []*Type {\n \tlist := make([]*Type, len(m))\n \ti := 0\n \tfor _, t := range m {\n@@ -699,8 +687,8 @@ func sortedTypes(m map[string]*baseType) []*Type {\n \t\t\tDecl:    t.decl,\n \t\t\tConsts:  sortedValues(t.values, token.CONST),\n \t\t\tVars:    sortedValues(t.values, token.VAR),\n-\t\t\tFuncs:   sortedFuncs(t.funcs),\n-\t\t\tMethods: sortedFuncs(t.methods),\n+\t\t\tFuncs:   sortedFuncs(t.funcs, true),\n+\t\t\tMethods: sortedFuncs(t.methods, allMethods),\n \t\t}\n \t\ti++\n \t}\n@@ -714,12 +702,24 @@ func sortedTypes(m map[string]*baseType) []*Type {\n \treturn list\n }\n \n-func sortedFuncs(m methodSet) []*Func {\n+func removeStar(s string) string {\n+\tif len(s) > 0 && s[0] == '*' {\n+\t\treturn s[1:]\n+\t}\n+\treturn s\n+}\n+\n+func sortedFuncs(m methodSet, allMethods bool) []*Func {\n \tlist := make([]*Func, len(m))\n \ti := 0\n \tfor _, m := range m {\n-\t\t// exclude conflict entries\n-\t\tif m.Decl != nil {\n+\t\t// determine which methods to include\n+\t\tswitch {\n+\t\tcase m.Decl == nil:\n+\t\t\t// exclude conflict entry\n+\t\tcase allMethods, m.Level == 0, !ast.IsExported(removeStar(m.Orig)):\n+\t\t\t// forced inclusion, method not embedded, or method\n+\t\t\t// embedded but original receiver type not exported\n \t\t\tlist[i] = m\n \t\t\ti++\n \t\t}"}, {"sha": "24db02d348f5cc81cdabfb978d126d185d74a710", "filename": "libgo/go/go/doc/testdata/a.2.golden", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa.2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa.2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fa.2.golden?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -0,0 +1,13 @@\n+// comment 0  comment 1 \n+PACKAGE a\n+\n+IMPORTPATH\n+\ttestdata/a\n+\n+FILENAMES\n+\ttestdata/a0.go\n+\ttestdata/a1.go\n+\n+BUGS\n+\t// bug0 \n+\t// bug1 "}, {"sha": "7c33300616d2b87549e6c86a431c3d61a035a8ba", "filename": "libgo/go/go/doc/testdata/b.2.golden", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fb.2.golden?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -0,0 +1,43 @@\n+// \n+PACKAGE b\n+\n+IMPORTPATH\n+\ttestdata/b\n+\n+IMPORTS\n+\ta\n+\n+FILENAMES\n+\ttestdata/b.go\n+\n+CONSTANTS\n+\t// \n+\tconst Pi = 3.14\t// Pi\n+\n+\n+VARIABLES\n+\t// \n+\tvar MaxInt int\t// MaxInt\n+\n+\n+FUNCTIONS\n+\t// \n+\tfunc F(x int) int\n+\n+\t// Always under the package functions list. \n+\tfunc NotAFactory() int\n+\n+\t// Associated with uint type if AllDecls is set. \n+\tfunc UintFactory() uint\n+\n+\n+TYPES\n+\t// \n+\ttype T struct{}\t// T\n+\n+\t// \n+\tvar V T\t// v\n+\n+\t// \n+\tfunc (x *T) M()\n+"}, {"sha": "e21959b1950dc58cfc863c4ae96fec3b45ac0bbf", "filename": "libgo/go/go/doc/testdata/c.2.golden", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fc.2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fc.2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fc.2.golden?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -0,0 +1,48 @@\n+// \n+PACKAGE c\n+\n+IMPORTPATH\n+\ttestdata/c\n+\n+IMPORTS\n+\ta\n+\n+FILENAMES\n+\ttestdata/c.go\n+\n+TYPES\n+\t// A (should see this) \n+\ttype A struct{}\n+\n+\t// B (should see this) \n+\ttype B struct{}\n+\n+\t// C (should see this) \n+\ttype C struct{}\n+\n+\t// D (should see this) \n+\ttype D struct{}\n+\n+\t// E1 (should see this) \n+\ttype E1 struct{}\n+\n+\t// E (should see this for E2 and E3) \n+\ttype E2 struct{}\n+\n+\t// E (should see this for E2 and E3) \n+\ttype E3 struct{}\n+\n+\t// E4 (should see this) \n+\ttype E4 struct{}\n+\n+\t// \n+\ttype T1 struct{}\n+\n+\t// \n+\tfunc (t1 *T1) M()\n+\n+\t// T2 must not show methods of local T1 \n+\ttype T2 struct {\n+\t\ta.T1\t// not the same as locally declared T1\n+\t}\n+"}, {"sha": "c0051995334af6ae93a4aa150e70a7026d6d9c1b", "filename": "libgo/go/go/doc/testdata/d.2.golden", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fd.2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fd.2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fd.2.golden?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -0,0 +1,104 @@\n+// \n+PACKAGE d\n+\n+IMPORTPATH\n+\ttestdata/d\n+\n+FILENAMES\n+\ttestdata/d1.go\n+\ttestdata/d2.go\n+\n+CONSTANTS\n+\t// CBx constants should appear before CAx constants. \n+\tconst (\n+\t\tCB2\t= iota\t// before CB1\n+\t\tCB1\t\t// before CB0\n+\t\tCB0\t\t// at end\n+\t)\n+\n+\t// CAx constants should appear after CBx constants. \n+\tconst (\n+\t\tCA2\t= iota\t// before CA1\n+\t\tCA1\t\t// before CA0\n+\t\tCA0\t\t// at end\n+\t)\n+\n+\t// C0 should be first. \n+\tconst C0 = 0\n+\n+\t// C1 should be second. \n+\tconst C1 = 1\n+\n+\t// C2 should be third. \n+\tconst C2 = 2\n+\n+\t// \n+\tconst (\n+\t\t// Single const declarations inside ()'s are considered ungrouped\n+\t\t// and show up in sorted order.\n+\t\tCungrouped = 0\n+\t)\n+\n+\n+VARIABLES\n+\t// VBx variables should appear before VAx variables. \n+\tvar (\n+\t\tVB2\tint\t// before VB1\n+\t\tVB1\tint\t// before VB0\n+\t\tVB0\tint\t// at end\n+\t)\n+\n+\t// VAx variables should appear after VBx variables. \n+\tvar (\n+\t\tVA2\tint\t// before VA1\n+\t\tVA1\tint\t// before VA0\n+\t\tVA0\tint\t// at end\n+\t)\n+\n+\t// V0 should be first. \n+\tvar V0 uintptr\n+\n+\t// V1 should be second. \n+\tvar V1 uint\n+\n+\t// V2 should be third. \n+\tvar V2 int\n+\n+\t// \n+\tvar (\n+\t\t// Single var declarations inside ()'s are considered ungrouped\n+\t\t// and show up in sorted order.\n+\t\tVungrouped = 0\n+\t)\n+\n+\n+FUNCTIONS\n+\t// F0 should be first. \n+\tfunc F0()\n+\n+\t// F1 should be second. \n+\tfunc F1()\n+\n+\t// F2 should be third. \n+\tfunc F2()\n+\n+\n+TYPES\n+\t// T0 should be first. \n+\ttype T0 struct{}\n+\n+\t// T1 should be second. \n+\ttype T1 struct{}\n+\n+\t// T2 should be third. \n+\ttype T2 struct{}\n+\n+\t// TG0 should be first. \n+\ttype TG0 struct{}\n+\n+\t// TG1 should be second. \n+\ttype TG1 struct{}\n+\n+\t// TG2 should be third. \n+\ttype TG2 struct{}\n+"}, {"sha": "096a50ff41f9b2ecb21073759676c6a10285a0ac", "filename": "libgo/go/go/doc/testdata/e.0.golden", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.0.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.0.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.0.golden?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -1,4 +1,4 @@\n-// \n+// The package e is a go/doc test for embedded methods. \n PACKAGE e\n \n IMPORTPATH\n@@ -8,7 +8,7 @@ FILENAMES\n \ttestdata/e.go\n \n TYPES\n-\t// T1 has no (top-level) M method due to conflict. \n+\t// T1 has no embedded (level 1) M method due to conflict. \n \ttype T1 struct {\n \t\t// contains filtered or unexported fields\n \t}\n@@ -29,3 +29,14 @@ TYPES\n \t// T3.M should appear as method of T3. \n \tfunc (T3) M()\n \n+\t// \n+\ttype T4 struct{}\n+\n+\t// T4.M should appear as method of T5 only if AllMethods is set. \n+\tfunc (*T4) M()\n+\n+\t// \n+\ttype T5 struct {\n+\t\tT4\n+\t}\n+"}, {"sha": "28be74a1fd6a52c70974f35218cd0b4222f0081e", "filename": "libgo/go/go/doc/testdata/e.1.golden", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.1.golden?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -1,4 +1,4 @@\n-// \n+// The package e is a go/doc test for embedded methods. \n PACKAGE e\n \n IMPORTPATH\n@@ -8,7 +8,7 @@ FILENAMES\n \ttestdata/e.go\n \n TYPES\n-\t// T1 has no (top-level) M method due to conflict. \n+\t// T1 has no embedded (level 1) M method due to conflict. \n \ttype T1 struct {\n \t\tt1\n \t\tt2\n@@ -31,6 +31,17 @@ TYPES\n \t// T3.M should appear as method of T3. \n \tfunc (T3) M()\n \n+\t// \n+\ttype T4 struct{}\n+\n+\t// T4.M should appear as method of T5 only if AllMethods is set. \n+\tfunc (*T4) M()\n+\n+\t// \n+\ttype T5 struct {\n+\t\tT4\n+\t}\n+\n \t// \n \ttype t1 struct{}\n "}, {"sha": "f9a2b816774999bbb921774c11089ba9bd188f03", "filename": "libgo/go/go/doc/testdata/e.2.golden", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.2.golden?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -0,0 +1,45 @@\n+// The package e is a go/doc test for embedded methods. \n+PACKAGE e\n+\n+IMPORTPATH\n+\ttestdata/e\n+\n+FILENAMES\n+\ttestdata/e.go\n+\n+TYPES\n+\t// T1 has no embedded (level 1) M method due to conflict. \n+\ttype T1 struct {\n+\t\t// contains filtered or unexported fields\n+\t}\n+\n+\t// T2 has only M as top-level method. \n+\ttype T2 struct {\n+\t\t// contains filtered or unexported fields\n+\t}\n+\n+\t// T2.M should appear as method of T2. \n+\tfunc (T2) M()\n+\n+\t// T3 has only M as top-level method. \n+\ttype T3 struct {\n+\t\t// contains filtered or unexported fields\n+\t}\n+\n+\t// T3.M should appear as method of T3. \n+\tfunc (T3) M()\n+\n+\t// \n+\ttype T4 struct{}\n+\n+\t// T4.M should appear as method of T5 only if AllMethods is set. \n+\tfunc (*T4) M()\n+\n+\t// \n+\ttype T5 struct {\n+\t\tT4\n+\t}\n+\n+\t// T4.M should appear as method of T5 only if AllMethods is set. \n+\tfunc (*T5) M()\n+"}, {"sha": "526a91f4f00b8706fb4c218218cc4a7af1d0eb69", "filename": "libgo/go/go/doc/testdata/e.go", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Fe.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -2,9 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Embedding tests.\n-// TODO(gri): This should be comprehensive.\n-\n+// The package e is a go/doc test for embedded methods.\n package e\n \n // ----------------------------------------------------------------------------\n@@ -20,7 +18,7 @@ type t2 struct{}\n // t2.M should not appear as method in a Tx type.\n func (t2) M() {}\n \n-// T1 has no (top-level) M method due to conflict.\n+// T1 has no embedded (level 1) M method due to conflict.\n type T1 struct {\n \tt1\n \tt2\n@@ -56,3 +54,26 @@ type T3 struct {\n \n // T3.M should appear as method of T3.\n func (T3) M() {}\n+\n+// ----------------------------------------------------------------------------\n+// Don't show conflicting methods M embedded via an exported and non-exported\n+// type.\n+\n+// T1 has no embedded (level 1) M method due to conflict.\n+type T4 struct {\n+\tt2\n+\tT2\n+}\n+\n+// ----------------------------------------------------------------------------\n+// Don't show embedded methods of exported anonymous fields unless AllMethods\n+// is set.\n+\n+type T4 struct{}\n+\n+// T4.M should appear as method of T5 only if AllMethods is set.\n+func (*T4) M() {}\n+\n+type T5 struct {\n+\tT4\n+}"}, {"sha": "81759018613d0a9c9af207e51523a1d68245ff47", "filename": "libgo/go/go/doc/testdata/f.0.golden", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ff.0.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ff.0.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ff.0.golden?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -0,0 +1,13 @@\n+// The package f is a go/doc test for functions and factory ...\n+PACKAGE f\n+\n+IMPORTPATH\n+\ttestdata/f\n+\n+FILENAMES\n+\ttestdata/f.go\n+\n+FUNCTIONS\n+\t// Exported must always be visible. Was issue 2824. \n+\tfunc Exported() private\n+"}, {"sha": "ba68e884c2b0a70e647832919c091827d254ee57", "filename": "libgo/go/go/doc/testdata/f.1.golden", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ff.1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ff.1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ff.1.golden?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -0,0 +1,16 @@\n+// The package f is a go/doc test for functions and factory ...\n+PACKAGE f\n+\n+IMPORTPATH\n+\ttestdata/f\n+\n+FILENAMES\n+\ttestdata/f.go\n+\n+TYPES\n+\t// \n+\ttype private struct{}\n+\n+\t// Exported must always be visible. Was issue 2824. \n+\tfunc Exported() private\n+"}, {"sha": "81759018613d0a9c9af207e51523a1d68245ff47", "filename": "libgo/go/go/doc/testdata/f.2.golden", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ff.2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ff.2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ff.2.golden?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -0,0 +1,13 @@\n+// The package f is a go/doc test for functions and factory ...\n+PACKAGE f\n+\n+IMPORTPATH\n+\ttestdata/f\n+\n+FILENAMES\n+\ttestdata/f.go\n+\n+FUNCTIONS\n+\t// Exported must always be visible. Was issue 2824. \n+\tfunc Exported() private\n+"}, {"sha": "a3051e1fb3bda54a4c1ebf0b2457e6a87918a7f1", "filename": "libgo/go/go/doc/testdata/f.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ff.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ff.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ff.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// The package f is a go/doc test for functions and factory methods.\n+package f\n+\n+// ----------------------------------------------------------------------------\n+// Factory functions for non-exported types must not get lost.\n+\n+type private struct{}\n+\n+// Exported must always be visible. Was issue 2824.\n+func Exported() private {}"}, {"sha": "15a90398664c504dab7ecfa89c143e8cc2516ac1", "filename": "libgo/go/go/doc/testdata/testing.2.golden", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ftestdata%2Ftesting.2.golden?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -0,0 +1,156 @@\n+// Package testing provides support for automated testing of Go ...\n+PACKAGE testing\n+\n+IMPORTPATH\n+\ttestdata/testing\n+\n+IMPORTS\n+\tbytes\n+\tflag\n+\tfmt\n+\tio\n+\tos\n+\truntime\n+\truntime/pprof\n+\tstrconv\n+\tstrings\n+\ttime\n+\n+FILENAMES\n+\ttestdata/benchmark.go\n+\ttestdata/example.go\n+\ttestdata/testing.go\n+\n+FUNCTIONS\n+\t// An internal function but exported because it is cross-package; ...\n+\tfunc Main(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)\n+\n+\t// An internal function but exported because it is cross-package; ...\n+\tfunc RunBenchmarks(matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark)\n+\n+\t// \n+\tfunc RunExamples(examples []InternalExample) (ok bool)\n+\n+\t// \n+\tfunc RunTests(matchString func(pat, str string) (bool, error), tests []InternalTest) (ok bool)\n+\n+\t// Short reports whether the -test.short flag is set. \n+\tfunc Short() bool\n+\n+\n+TYPES\n+\t// B is a type passed to Benchmark functions to manage benchmark ...\n+\ttype B struct {\n+\t\tN int\n+\t\t// contains filtered or unexported fields\n+\t}\n+\n+\t// Error is equivalent to Log() followed by Fail(). \n+\tfunc (c *B) Error(args ...interface{})\n+\n+\t// Errorf is equivalent to Logf() followed by Fail(). \n+\tfunc (c *B) Errorf(format string, args ...interface{})\n+\n+\t// Fail marks the function as having failed but continues ...\n+\tfunc (c *B) Fail()\n+\n+\t// FailNow marks the function as having failed and stops its ...\n+\tfunc (c *B) FailNow()\n+\n+\t// Failed returns whether the function has failed. \n+\tfunc (c *B) Failed() bool\n+\n+\t// Fatal is equivalent to Log() followed by FailNow(). \n+\tfunc (c *B) Fatal(args ...interface{})\n+\n+\t// Fatalf is equivalent to Logf() followed by FailNow(). \n+\tfunc (c *B) Fatalf(format string, args ...interface{})\n+\n+\t// Log formats its arguments using default formatting, analogous ...\n+\tfunc (c *B) Log(args ...interface{})\n+\n+\t// Logf formats its arguments according to the format, analogous ...\n+\tfunc (c *B) Logf(format string, args ...interface{})\n+\n+\t// ResetTimer sets the elapsed benchmark time to zero. It does not ...\n+\tfunc (b *B) ResetTimer()\n+\n+\t// SetBytes records the number of bytes processed in a single ...\n+\tfunc (b *B) SetBytes(n int64)\n+\n+\t// StartTimer starts timing a test.  This function is called ...\n+\tfunc (b *B) StartTimer()\n+\n+\t// StopTimer stops timing a test.  This can be used to pause the ...\n+\tfunc (b *B) StopTimer()\n+\n+\t// The results of a benchmark run. \n+\ttype BenchmarkResult struct {\n+\t\tN\tint\t\t// The number of iterations.\n+\t\tT\ttime.Duration\t// The total time taken.\n+\t\tBytes\tint64\t\t// Bytes processed in one iteration.\n+\t}\n+\n+\t// Benchmark benchmarks a single function. Useful for creating ...\n+\tfunc Benchmark(f func(b *B)) BenchmarkResult\n+\n+\t// \n+\tfunc (r BenchmarkResult) NsPerOp() int64\n+\n+\t// \n+\tfunc (r BenchmarkResult) String() string\n+\n+\t// An internal type but exported because it is cross-package; part ...\n+\ttype InternalBenchmark struct {\n+\t\tName\tstring\n+\t\tF\tfunc(b *B)\n+\t}\n+\n+\t// \n+\ttype InternalExample struct {\n+\t\tName\tstring\n+\t\tF\tfunc()\n+\t\tOutput\tstring\n+\t}\n+\n+\t// An internal type but exported because it is cross-package; part ...\n+\ttype InternalTest struct {\n+\t\tName\tstring\n+\t\tF\tfunc(*T)\n+\t}\n+\n+\t// T is a type passed to Test functions to manage test state and ...\n+\ttype T struct {\n+\t\t// contains filtered or unexported fields\n+\t}\n+\n+\t// Error is equivalent to Log() followed by Fail(). \n+\tfunc (c *T) Error(args ...interface{})\n+\n+\t// Errorf is equivalent to Logf() followed by Fail(). \n+\tfunc (c *T) Errorf(format string, args ...interface{})\n+\n+\t// Fail marks the function as having failed but continues ...\n+\tfunc (c *T) Fail()\n+\n+\t// FailNow marks the function as having failed and stops its ...\n+\tfunc (c *T) FailNow()\n+\n+\t// Failed returns whether the function has failed. \n+\tfunc (c *T) Failed() bool\n+\n+\t// Fatal is equivalent to Log() followed by FailNow(). \n+\tfunc (c *T) Fatal(args ...interface{})\n+\n+\t// Fatalf is equivalent to Logf() followed by FailNow(). \n+\tfunc (c *T) Fatalf(format string, args ...interface{})\n+\n+\t// Log formats its arguments using default formatting, analogous ...\n+\tfunc (c *T) Log(args ...interface{})\n+\n+\t// Logf formats its arguments according to the format, analogous ...\n+\tfunc (c *T) Logf(format string, args ...interface{})\n+\n+\t// Parallel signals that this test is to be run in parallel with ...\n+\tfunc (t *T) Parallel()\n+"}, {"sha": "25935fb42bb8b369be3791b28c2cb83224f0b5c0", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -76,6 +76,7 @@ func (p *printer) setComment(g *ast.CommentGroup) {\n \t}\n \tp.comments[0] = g\n \tp.cindex = 0\n+\tp.nextComment() // get comment ready for use\n }\n \n type exprListMode uint"}, {"sha": "fe99e675eb05653a301d5c1cd0c67534825df8bf", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 115, "deletions": 40, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -12,7 +12,6 @@ import (\n \t\"go/token\"\n \t\"io\"\n \t\"os\"\n-\t\"path/filepath\"\n \t\"strconv\"\n \t\"strings\"\n \t\"text/tabwriter\"\n@@ -52,11 +51,12 @@ type printer struct {\n \tfset *token.FileSet\n \n \t// Current state\n-\toutput  bytes.Buffer // raw printer result\n-\tindent  int          // current indentation\n-\tmode    pmode        // current printer mode\n-\tlastTok token.Token  // the last token printed (token.ILLEGAL if it's whitespace)\n-\twsbuf   []whiteSpace // delayed white space\n+\toutput      bytes.Buffer // raw printer result\n+\tindent      int          // current indentation\n+\tmode        pmode        // current printer mode\n+\timpliedSemi bool         // if set, a linebreak implies a semicolon\n+\tlastTok     token.Token  // the last token printed (token.ILLEGAL if it's whitespace)\n+\twsbuf       []whiteSpace // delayed white space\n \n \t// The (possibly estimated) position in the generated output;\n \t// in AST space (i.e., pos is set whenever a token position is\n@@ -73,6 +73,11 @@ type printer struct {\n \tcindex          int                 // current comment index\n \tuseNodeComments bool                // if not set, ignore lead and line comments of nodes\n \n+\t// Information about p.comments[p.cindex]; set up by nextComment.\n+\tcomment        *ast.CommentGroup // = p.comments[p.cindex]; or nil\n+\tcommentOffset  int               // = p.posFor(p.comments[p.cindex].List[0].Pos()).Offset; or infinity\n+\tcommentNewline bool              // true if the comment group contains newlines\n+\n \t// Cache of already computed node sizes.\n \tnodeSizes map[ast.Node]int\n \n@@ -89,6 +94,42 @@ func (p *printer) init(cfg *Config, fset *token.FileSet, nodeSizes map[ast.Node]\n \tp.cachedPos = -1\n }\n \n+// commentsHaveNewline reports whether a list of comments belonging to\n+// an *ast.CommentGroup contains newlines. Because the position information\n+// may only be partially correct, we also have to read the comment text.\n+func (p *printer) commentsHaveNewline(list []*ast.Comment) bool {\n+\t// len(list) > 0\n+\tline := p.lineFor(list[0].Pos())\n+\tfor i, c := range list {\n+\t\tif i > 0 && p.lineFor(list[i].Pos()) != line {\n+\t\t\t// not all comments on the same line\n+\t\t\treturn true\n+\t\t}\n+\t\tif t := c.Text; len(t) >= 2 && (t[1] == '/' || strings.Contains(t, \"\\n\")) {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\t_ = line\n+\treturn false\n+}\n+\n+func (p *printer) nextComment() {\n+\tfor p.cindex < len(p.comments) {\n+\t\tc := p.comments[p.cindex]\n+\t\tp.cindex++\n+\t\tif list := c.List; len(list) > 0 {\n+\t\t\tp.comment = c\n+\t\t\tp.commentOffset = p.posFor(list[0].Pos()).Offset\n+\t\t\tp.commentNewline = p.commentsHaveNewline(list)\n+\t\t\treturn\n+\t\t}\n+\t\t// we should not reach here (correct ASTs don't have empty\n+\t\t// ast.CommentGroup nodes), but be conservative and try again\n+\t}\n+\t// no more comments\n+\tp.commentOffset = infinity\n+}\n+\n func (p *printer) internalError(msg ...interface{}) {\n \tif debug {\n \t\tfmt.Print(p.pos.String() + \": \")\n@@ -204,8 +245,7 @@ func (p *printer) writeItem(pos token.Position, data string, isLit bool) {\n \t}\n \tif debug {\n \t\t// do not update p.pos - use write0\n-\t\t_, filename := filepath.Split(pos.Filename)\n-\t\tfmt.Fprintf(&p.output, \"[%s:%d:%d]\", filename, pos.Line, pos.Column)\n+\t\tfmt.Fprintf(&p.output, \"/*%s*/\", pos)\n \t}\n \tp.writeString(data, isLit)\n \tp.last = p.pos\n@@ -618,12 +658,13 @@ func (p *printer) writeCommentSuffix(needsLinebreak bool) (wroteNewline, dropped\n //\n func (p *printer) intersperseComments(next token.Position, tok token.Token) (wroteNewline, droppedFF bool) {\n \tvar last *ast.Comment\n-\tfor ; p.commentBefore(next); p.cindex++ {\n-\t\tfor _, c := range p.comments[p.cindex].List {\n+\tfor p.commentBefore(next) {\n+\t\tfor _, c := range p.comment.List {\n \t\t\tp.writeCommentPrefix(p.posFor(c.Pos()), next, last, c, tok.IsKeyword())\n \t\t\tp.writeComment(c)\n \t\t\tlast = c\n \t\t}\n+\t\tp.nextComment()\n \t}\n \n \tif last != nil {\n@@ -735,22 +776,24 @@ func mayCombine(prev token.Token, next byte) (b bool) {\n // printed, followed by the actual token.\n //\n func (p *printer) print(args ...interface{}) {\n-\tfor _, f := range args {\n-\t\tnext := p.pos // estimated position of next item\n-\t\tdata := \"\"\n-\t\tisLit := false\n-\t\tvar tok token.Token\n+\tfor _, arg := range args {\n+\t\t// information about the current arg\n+\t\tvar data string\n+\t\tvar isLit bool\n+\t\tvar impliedSemi bool // value for p.impliedSemi after this arg\n \n-\t\tswitch x := f.(type) {\n+\t\tswitch x := arg.(type) {\n \t\tcase pmode:\n \t\t\t// toggle printer mode\n \t\t\tp.mode ^= x\n+\t\t\tcontinue\n+\n \t\tcase whiteSpace:\n \t\t\tif x == ignore {\n \t\t\t\t// don't add ignore's to the buffer; they\n \t\t\t\t// may screw up \"correcting\" unindents (see\n \t\t\t\t// LabeledStmt)\n-\t\t\t\tbreak\n+\t\t\t\tcontinue\n \t\t\t}\n \t\t\ti := len(p.wsbuf)\n \t\t\tif i == cap(p.wsbuf) {\n@@ -762,13 +805,27 @@ func (p *printer) print(args ...interface{}) {\n \t\t\t}\n \t\t\tp.wsbuf = p.wsbuf[0 : i+1]\n \t\t\tp.wsbuf[i] = x\n+\t\t\tif x == newline || x == formfeed {\n+\t\t\t\t// newlines affect the current state (p.impliedSemi)\n+\t\t\t\t// and not the state after printing arg (impliedSemi)\n+\t\t\t\t// because comments can be interspersed before the arg\n+\t\t\t\t// in this case\n+\t\t\t\tp.impliedSemi = false\n+\t\t\t}\n+\t\t\tp.lastTok = token.ILLEGAL\n+\t\t\tcontinue\n+\n \t\tcase *ast.Ident:\n \t\t\tdata = x.Name\n-\t\t\ttok = token.IDENT\n+\t\t\timpliedSemi = true\n+\t\t\tp.lastTok = token.IDENT\n+\n \t\tcase *ast.BasicLit:\n \t\t\tdata = x.Value\n \t\t\tisLit = true\n-\t\t\ttok = x.Kind\n+\t\t\timpliedSemi = true\n+\t\t\tp.lastTok = x.Kind\n+\n \t\tcase token.Token:\n \t\t\ts := x.String()\n \t\t\tif mayCombine(p.lastTok, s[0]) {\n@@ -785,30 +842,40 @@ func (p *printer) print(args ...interface{}) {\n \t\t\t\tp.wsbuf[0] = ' '\n \t\t\t}\n \t\t\tdata = s\n-\t\t\ttok = x\n+\t\t\t// some keywords followed by a newline imply a semicolon\n+\t\t\tswitch x {\n+\t\t\tcase token.BREAK, token.CONTINUE, token.FALLTHROUGH, token.RETURN,\n+\t\t\t\ttoken.INC, token.DEC, token.RPAREN, token.RBRACK, token.RBRACE:\n+\t\t\t\timpliedSemi = true\n+\t\t\t}\n+\t\t\tp.lastTok = x\n+\n \t\tcase token.Pos:\n \t\t\tif x.IsValid() {\n-\t\t\t\tnext = p.posFor(x) // accurate position of next item\n+\t\t\t\tp.pos = p.posFor(x) // accurate position of next item\n \t\t\t}\n-\t\t\ttok = p.lastTok\n+\t\t\tcontinue\n+\n \t\tcase string:\n \t\t\t// incorrect AST - print error message\n \t\t\tdata = x\n \t\t\tisLit = true\n-\t\t\ttok = token.STRING\n+\t\t\timpliedSemi = true\n+\t\t\tp.lastTok = token.STRING\n+\n \t\tdefault:\n-\t\t\tfmt.Fprintf(os.Stderr, \"print: unsupported argument %v (%T)\\n\", f, f)\n+\t\t\tfmt.Fprintf(os.Stderr, \"print: unsupported argument %v (%T)\\n\", arg, arg)\n \t\t\tpanic(\"go/printer type\")\n \t\t}\n-\t\tp.lastTok = tok\n-\t\tp.pos = next\n+\t\t// data != \"\"\n \n-\t\tif data != \"\" {\n-\t\t\twroteNewline, droppedFF := p.flush(next, tok)\n+\t\tnext := p.pos // estimated/accurate position of next item\n+\t\twroteNewline, droppedFF := p.flush(next, p.lastTok)\n \n-\t\t\t// intersperse extra newlines if present in the source\n-\t\t\t// (don't do this in flush as it will cause extra newlines\n-\t\t\t// at the end of a file)\n+\t\t// intersperse extra newlines if present in the source and\n+\t\t// if they don't cause extra semicolons (don't do this in\n+\t\t// flush as it will cause extra newlines at the end of a file)\n+\t\tif !p.impliedSemi {\n \t\t\tn := nlimit(next.Line - p.pos.Line)\n \t\t\t// don't exceed maxNewlines if we already wrote one\n \t\t\tif wroteNewline && n == maxNewlines {\n@@ -820,22 +887,25 @@ func (p *printer) print(args ...interface{}) {\n \t\t\t\t\tch = '\\f' // use formfeed since we dropped one before\n \t\t\t\t}\n \t\t\t\tp.writeByteN(ch, n)\n+\t\t\t\timpliedSemi = false\n \t\t\t}\n-\n-\t\t\tp.writeItem(next, data, isLit)\n \t\t}\n+\n+\t\tp.writeItem(next, data, isLit)\n+\t\tp.impliedSemi = impliedSemi\n \t}\n }\n \n-// commentBefore returns true iff the current comment occurs\n-// before the next position in the source code.\n+// commentBefore returns true iff the current comment group occurs\n+// before the next position in the source code and printing it does\n+// not introduce implicit semicolons.\n //\n-func (p *printer) commentBefore(next token.Position) bool {\n-\treturn p.cindex < len(p.comments) && p.posFor(p.comments[p.cindex].List[0].Pos()).Offset < next.Offset\n+func (p *printer) commentBefore(next token.Position) (result bool) {\n+\treturn p.commentOffset < next.Offset && (!p.impliedSemi || !p.commentNewline)\n }\n \n-// Flush prints any pending comments and whitespace occurring textually\n-// before the position of the next token tok. The Flush result indicates\n+// flush prints any pending comments and whitespace occurring textually\n+// before the position of the next token tok. The flush result indicates\n // if a newline was written or if a formfeed was dropped from the whitespace\n // buffer.\n //\n@@ -915,6 +985,9 @@ func (p *printer) printNode(node interface{}) error {\n \t// if there are no comments, use node comments\n \tp.useNodeComments = p.comments == nil\n \n+\t// get comments ready for use\n+\tp.nextComment()\n+\n \t// format node\n \tswitch n := node.(type) {\n \tcase ast.Expr:\n@@ -1068,6 +1141,8 @@ func (cfg *Config) fprint(output io.Writer, fset *token.FileSet, node interface{\n \tif err = p.printNode(node); err != nil {\n \t\treturn\n \t}\n+\t// print outstanding comments\n+\tp.impliedSemi = false // EOF acts like a newline\n \tp.flush(token.Position{Offset: infinity, Line: infinity}, token.EOF)\n \n \t// redirect output through a trimmer to eliminate trailing whitespace\n@@ -1108,7 +1183,7 @@ func (cfg *Config) fprint(output io.Writer, fset *token.FileSet, node interface{\n }\n \n // A CommentedNode bundles an AST node and corresponding comments.\n-// It may be provided as argument to any of the FPrint functions.\n+// It may be provided as argument to any of the Fprint functions.\n //\n type CommentedNode struct {\n \tNode     interface{} // *ast.File, or ast.Expr, ast.Decl, ast.Spec, or ast.Stmt"}, {"sha": "9adf48cda6136e496edb45cc3d5822e0783d5286", "filename": "libgo/go/go/printer/printer_test.go", "status": "modified", "additions": 68, "deletions": 7, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -171,14 +171,14 @@ func TestLineComments(t *testing.T) {\n \t`\n \n \tfset := token.NewFileSet()\n-\tast1, err1 := parser.ParseFile(fset, \"\", src, parser.ParseComments)\n-\tif err1 != nil {\n-\t\tpanic(err1)\n+\tf, err := parser.ParseFile(fset, \"\", src, parser.ParseComments)\n+\tif err != nil {\n+\t\tpanic(err) // error in test\n \t}\n \n \tvar buf bytes.Buffer\n \tfset = token.NewFileSet() // use the wrong file set\n-\tFprint(&buf, fset, ast1)\n+\tFprint(&buf, fset, f)\n \n \tnlines := 0\n \tfor _, ch := range buf.Bytes() {\n@@ -190,6 +190,7 @@ func TestLineComments(t *testing.T) {\n \tconst expected = 3\n \tif nlines < expected {\n \t\tt.Errorf(\"got %d, expected %d\\n\", nlines, expected)\n+\t\tt.Errorf(\"result:\\n%s\", buf.Bytes())\n \t}\n }\n \n@@ -198,9 +199,11 @@ func init() {\n \tconst name = \"foobar\"\n \tvar buf bytes.Buffer\n \tif err := Fprint(&buf, fset, &ast.Ident{Name: name}); err != nil {\n-\t\tpanic(err)\n+\t\tpanic(err) // error in test\n \t}\n-\tif s := buf.String(); s != name {\n+\t// in debug mode, the result contains additional information;\n+\t// ignore it\n+\tif s := buf.String(); !debug && s != name {\n \t\tpanic(\"got \" + s + \", want \" + name)\n \t}\n }\n@@ -211,11 +214,69 @@ func TestBadNodes(t *testing.T) {\n \tconst res = \"package p\\nBadDecl\\n\"\n \tf, err := parser.ParseFile(fset, \"\", src, parser.ParseComments)\n \tif err == nil {\n-\t\tt.Errorf(\"expected illegal program\")\n+\t\tt.Error(\"expected illegal program\") // error in test\n \t}\n \tvar buf bytes.Buffer\n \tFprint(&buf, fset, f)\n \tif buf.String() != res {\n \t\tt.Errorf(\"got %q, expected %q\", buf.String(), res)\n \t}\n }\n+\n+// Print and parse f with \n+func testComment(t *testing.T, f *ast.File, srclen int, comment *ast.Comment) {\n+\tf.Comments[0].List[0] = comment\n+\tvar buf bytes.Buffer\n+\tfor offs := 0; offs <= srclen; offs++ {\n+\t\tbuf.Reset()\n+\t\t// Printing f should result in a correct program no\n+\t\t// matter what the (incorrect) comment position is.\n+\t\tif err := Fprint(&buf, fset, f); err != nil {\n+\t\t\tt.Error(err)\n+\t\t}\n+\t\tif _, err := parser.ParseFile(fset, \"\", buf.Bytes(), 0); err != nil {\n+\t\t\tt.Fatalf(\"incorrect program for pos = %d:\\n%s\", comment.Slash, buf.String())\n+\t\t}\n+\t\t// Position information is just an offset.\n+\t\t// Move comment one byte down in the source.\n+\t\tcomment.Slash++\n+\t}\n+}\n+\n+// Verify that the printer produces always produces a correct program\n+// even if the position information of comments introducing newlines\n+// is incorrect.\n+func TestBadComments(t *testing.T) {\n+\tconst src = `\n+// first comment - text and position changed by test\n+package p\n+import \"fmt\"\n+const pi = 3.14 // rough circle\n+var (\n+\tx, y, z int = 1, 2, 3\n+\tu, v float64\n+)\n+func fibo(n int) {\n+\tif n < 2 {\n+\t\treturn n /* seed values */\n+\t}\n+\treturn fibo(n-1) + fibo(n-2)\n+}\n+`\n+\n+\tf, err := parser.ParseFile(fset, \"\", src, parser.ParseComments)\n+\tif err != nil {\n+\t\tt.Error(err) // error in test\n+\t}\n+\n+\tcomment := f.Comments[0].List[0]\n+\tpos := comment.Pos()\n+\tif fset.Position(pos).Offset != 1 {\n+\t\tt.Error(\"expected offset 1\") // error in test\n+\t}\n+\n+\ttestComment(t, f, len(src), &ast.Comment{pos, \"//-style comment\"})\n+\ttestComment(t, f, len(src), &ast.Comment{pos, \"/*-style comment */\"})\n+\ttestComment(t, f, len(src), &ast.Comment{pos, \"/*-style \\n comment */\"})\n+\ttestComment(t, f, len(src), &ast.Comment{pos, \"/*-style comment \\n\\n\\n */\"})\n+}"}, {"sha": "c85297f58314248b1ea3092b5716799d19b70d10", "filename": "libgo/go/go/printer/testdata/parser.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fparser.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -6,7 +6,7 @@\n // provided in a variety of forms (see the various Parse* functions); the\n // output is an abstract syntax tree (AST) representing the Go source. The\n // parser is invoked through one of the Parse* functions.\n-//\n+\n package parser\n \n import ("}, {"sha": "0aabfe34c416d89632a0cca1eac5d7ef1fe49fdc", "filename": "libgo/go/go/scanner/scanner.go", "status": "modified", "additions": 226, "deletions": 226, "changes": 452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -8,7 +8,7 @@\n //\n //\tvar s scanner.Scanner\n //\tfset := token.NewFileSet()  // position information is relative to fset\n-//      file := fset.AddFile(filename, fset.Base(), len(src))  // register file\n+//\tfile := fset.AddFile(filename, fset.Base(), len(src))  // register file\n //\ts.Init(file, src, nil /* no error handler */, 0)\n //\tfor {\n //\t\tpos, tok, lit := s.Scan()\n@@ -53,36 +53,36 @@ type Scanner struct {\n \tErrorCount int // number of errors encountered\n }\n \n-// Read the next Unicode char into S.ch.\n-// S.ch < 0 means end-of-file.\n+// Read the next Unicode char into s.ch.\n+// s.ch < 0 means end-of-file.\n //\n-func (S *Scanner) next() {\n-\tif S.rdOffset < len(S.src) {\n-\t\tS.offset = S.rdOffset\n-\t\tif S.ch == '\\n' {\n-\t\t\tS.lineOffset = S.offset\n-\t\t\tS.file.AddLine(S.offset)\n+func (s *Scanner) next() {\n+\tif s.rdOffset < len(s.src) {\n+\t\ts.offset = s.rdOffset\n+\t\tif s.ch == '\\n' {\n+\t\t\ts.lineOffset = s.offset\n+\t\t\ts.file.AddLine(s.offset)\n \t\t}\n-\t\tr, w := rune(S.src[S.rdOffset]), 1\n+\t\tr, w := rune(s.src[s.rdOffset]), 1\n \t\tswitch {\n \t\tcase r == 0:\n-\t\t\tS.error(S.offset, \"illegal character NUL\")\n+\t\t\ts.error(s.offset, \"illegal character NUL\")\n \t\tcase r >= 0x80:\n \t\t\t// not ASCII\n-\t\t\tr, w = utf8.DecodeRune(S.src[S.rdOffset:])\n+\t\t\tr, w = utf8.DecodeRune(s.src[s.rdOffset:])\n \t\t\tif r == utf8.RuneError && w == 1 {\n-\t\t\t\tS.error(S.offset, \"illegal UTF-8 encoding\")\n+\t\t\t\ts.error(s.offset, \"illegal UTF-8 encoding\")\n \t\t\t}\n \t\t}\n-\t\tS.rdOffset += w\n-\t\tS.ch = r\n+\t\ts.rdOffset += w\n+\t\ts.ch = r\n \t} else {\n-\t\tS.offset = len(S.src)\n-\t\tif S.ch == '\\n' {\n-\t\t\tS.lineOffset = S.offset\n-\t\t\tS.file.AddLine(S.offset)\n+\t\ts.offset = len(s.src)\n+\t\tif s.ch == '\\n' {\n+\t\t\ts.lineOffset = s.offset\n+\t\t\ts.file.AddLine(s.offset)\n \t\t}\n-\t\tS.ch = -1 // eof\n+\t\ts.ch = -1 // eof\n \t}\n }\n \n@@ -96,7 +96,7 @@ const (\n \tdontInsertSemis                  // do not automatically insert semicolons - for testing only\n )\n \n-// Init prepares the scanner S to tokenize the text src by setting the\n+// Init prepares the scanner s to tokenize the text src by setting the\n // scanner at the beginning of src. The scanner uses the file set file\n // for position information and it adds line information for each line.\n // It is ok to re-use the same file when re-scanning the same file as\n@@ -111,37 +111,37 @@ const (\n // Note that Init may call err if there is an error in the first character\n // of the file.\n //\n-func (S *Scanner) Init(file *token.File, src []byte, err ErrorHandler, mode Mode) {\n+func (s *Scanner) Init(file *token.File, src []byte, err ErrorHandler, mode Mode) {\n \t// Explicitly initialize all fields since a scanner may be reused.\n \tif file.Size() != len(src) {\n \t\tpanic(\"file size does not match src len\")\n \t}\n-\tS.file = file\n-\tS.dir, _ = filepath.Split(file.Name())\n-\tS.src = src\n-\tS.err = err\n-\tS.mode = mode\n+\ts.file = file\n+\ts.dir, _ = filepath.Split(file.Name())\n+\ts.src = src\n+\ts.err = err\n+\ts.mode = mode\n \n-\tS.ch = ' '\n-\tS.offset = 0\n-\tS.rdOffset = 0\n-\tS.lineOffset = 0\n-\tS.insertSemi = false\n-\tS.ErrorCount = 0\n+\ts.ch = ' '\n+\ts.offset = 0\n+\ts.rdOffset = 0\n+\ts.lineOffset = 0\n+\ts.insertSemi = false\n+\ts.ErrorCount = 0\n \n-\tS.next()\n+\ts.next()\n }\n \n-func (S *Scanner) error(offs int, msg string) {\n-\tif S.err != nil {\n-\t\tS.err.Error(S.file.Position(S.file.Pos(offs)), msg)\n+func (s *Scanner) error(offs int, msg string) {\n+\tif s.err != nil {\n+\t\ts.err.Error(s.file.Position(s.file.Pos(offs)), msg)\n \t}\n-\tS.ErrorCount++\n+\ts.ErrorCount++\n }\n \n var prefix = []byte(\"//line \")\n \n-func (S *Scanner) interpretLineComment(text []byte) {\n+func (s *Scanner) interpretLineComment(text []byte) {\n \tif bytes.HasPrefix(text, prefix) {\n \t\t// get filename and line number, if any\n \t\tif i := bytes.LastIndex(text, []byte{':'}); i > 0 {\n@@ -150,88 +150,88 @@ func (S *Scanner) interpretLineComment(text []byte) {\n \t\t\t\tfilename := filepath.Clean(string(text[len(prefix):i]))\n \t\t\t\tif !filepath.IsAbs(filename) {\n \t\t\t\t\t// make filename relative to current directory\n-\t\t\t\t\tfilename = filepath.Join(S.dir, filename)\n+\t\t\t\t\tfilename = filepath.Join(s.dir, filename)\n \t\t\t\t}\n \t\t\t\t// update scanner position\n-\t\t\t\tS.file.AddLineInfo(S.lineOffset+len(text)+1, filename, line) // +len(text)+1 since comment applies to next line\n+\t\t\t\ts.file.AddLineInfo(s.lineOffset+len(text)+1, filename, line) // +len(text)+1 since comment applies to next line\n \t\t\t}\n \t\t}\n \t}\n }\n \n-func (S *Scanner) scanComment() string {\n-\t// initial '/' already consumed; S.ch == '/' || S.ch == '*'\n-\toffs := S.offset - 1 // position of initial '/'\n+func (s *Scanner) scanComment() string {\n+\t// initial '/' already consumed; s.ch == '/' || s.ch == '*'\n+\toffs := s.offset - 1 // position of initial '/'\n \n-\tif S.ch == '/' {\n+\tif s.ch == '/' {\n \t\t//-style comment\n-\t\tS.next()\n-\t\tfor S.ch != '\\n' && S.ch >= 0 {\n-\t\t\tS.next()\n+\t\ts.next()\n+\t\tfor s.ch != '\\n' && s.ch >= 0 {\n+\t\t\ts.next()\n \t\t}\n-\t\tif offs == S.lineOffset {\n+\t\tif offs == s.lineOffset {\n \t\t\t// comment starts at the beginning of the current line\n-\t\t\tS.interpretLineComment(S.src[offs:S.offset])\n+\t\t\ts.interpretLineComment(s.src[offs:s.offset])\n \t\t}\n \t\tgoto exit\n \t}\n \n \t/*-style comment */\n-\tS.next()\n-\tfor S.ch >= 0 {\n-\t\tch := S.ch\n-\t\tS.next()\n-\t\tif ch == '*' && S.ch == '/' {\n-\t\t\tS.next()\n+\ts.next()\n+\tfor s.ch >= 0 {\n+\t\tch := s.ch\n+\t\ts.next()\n+\t\tif ch == '*' && s.ch == '/' {\n+\t\t\ts.next()\n \t\t\tgoto exit\n \t\t}\n \t}\n \n-\tS.error(offs, \"comment not terminated\")\n+\ts.error(offs, \"comment not terminated\")\n \n exit:\n-\treturn string(S.src[offs:S.offset])\n+\treturn string(s.src[offs:s.offset])\n }\n \n-func (S *Scanner) findLineEnd() bool {\n+func (s *Scanner) findLineEnd() bool {\n \t// initial '/' already consumed\n \n \tdefer func(offs int) {\n \t\t// reset scanner state to where it was upon calling findLineEnd\n-\t\tS.ch = '/'\n-\t\tS.offset = offs\n-\t\tS.rdOffset = offs + 1\n-\t\tS.next() // consume initial '/' again\n-\t}(S.offset - 1)\n+\t\ts.ch = '/'\n+\t\ts.offset = offs\n+\t\ts.rdOffset = offs + 1\n+\t\ts.next() // consume initial '/' again\n+\t}(s.offset - 1)\n \n \t// read ahead until a newline, EOF, or non-comment token is found\n-\tfor S.ch == '/' || S.ch == '*' {\n-\t\tif S.ch == '/' {\n+\tfor s.ch == '/' || s.ch == '*' {\n+\t\tif s.ch == '/' {\n \t\t\t//-style comment always contains a newline\n \t\t\treturn true\n \t\t}\n \t\t/*-style comment: look for newline */\n-\t\tS.next()\n-\t\tfor S.ch >= 0 {\n-\t\t\tch := S.ch\n+\t\ts.next()\n+\t\tfor s.ch >= 0 {\n+\t\t\tch := s.ch\n \t\t\tif ch == '\\n' {\n \t\t\t\treturn true\n \t\t\t}\n-\t\t\tS.next()\n-\t\t\tif ch == '*' && S.ch == '/' {\n-\t\t\t\tS.next()\n+\t\t\ts.next()\n+\t\t\tif ch == '*' && s.ch == '/' {\n+\t\t\t\ts.next()\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n-\t\tS.skipWhitespace() // S.insertSemi is set\n-\t\tif S.ch < 0 || S.ch == '\\n' {\n+\t\ts.skipWhitespace() // s.insertSemi is set\n+\t\tif s.ch < 0 || s.ch == '\\n' {\n \t\t\treturn true\n \t\t}\n-\t\tif S.ch != '/' {\n+\t\tif s.ch != '/' {\n \t\t\t// non-comment token\n \t\t\treturn false\n \t\t}\n-\t\tS.next() // consume '/'\n+\t\ts.next() // consume '/'\n \t}\n \n \treturn false\n@@ -245,12 +245,12 @@ func isDigit(ch rune) bool {\n \treturn '0' <= ch && ch <= '9' || ch >= 0x80 && unicode.IsDigit(ch)\n }\n \n-func (S *Scanner) scanIdentifier() string {\n-\toffs := S.offset\n-\tfor isLetter(S.ch) || isDigit(S.ch) {\n-\t\tS.next()\n+func (s *Scanner) scanIdentifier() string {\n+\toffs := s.offset\n+\tfor isLetter(s.ch) || isDigit(s.ch) {\n+\t\ts.next()\n \t}\n-\treturn string(S.src[offs:S.offset])\n+\treturn string(s.src[offs:s.offset])\n }\n \n func digitVal(ch rune) int {\n@@ -265,176 +265,176 @@ func digitVal(ch rune) int {\n \treturn 16 // larger than any legal digit val\n }\n \n-func (S *Scanner) scanMantissa(base int) {\n-\tfor digitVal(S.ch) < base {\n-\t\tS.next()\n+func (s *Scanner) scanMantissa(base int) {\n+\tfor digitVal(s.ch) < base {\n+\t\ts.next()\n \t}\n }\n \n-func (S *Scanner) scanNumber(seenDecimalPoint bool) (token.Token, string) {\n-\t// digitVal(S.ch) < 10\n-\toffs := S.offset\n+func (s *Scanner) scanNumber(seenDecimalPoint bool) (token.Token, string) {\n+\t// digitVal(s.ch) < 10\n+\toffs := s.offset\n \ttok := token.INT\n \n \tif seenDecimalPoint {\n \t\toffs--\n \t\ttok = token.FLOAT\n-\t\tS.scanMantissa(10)\n+\t\ts.scanMantissa(10)\n \t\tgoto exponent\n \t}\n \n-\tif S.ch == '0' {\n+\tif s.ch == '0' {\n \t\t// int or float\n-\t\toffs := S.offset\n-\t\tS.next()\n-\t\tif S.ch == 'x' || S.ch == 'X' {\n+\t\toffs := s.offset\n+\t\ts.next()\n+\t\tif s.ch == 'x' || s.ch == 'X' {\n \t\t\t// hexadecimal int\n-\t\t\tS.next()\n-\t\t\tS.scanMantissa(16)\n-\t\t\tif S.offset-offs <= 2 {\n+\t\t\ts.next()\n+\t\t\ts.scanMantissa(16)\n+\t\t\tif s.offset-offs <= 2 {\n \t\t\t\t// only scanned \"0x\" or \"0X\"\n-\t\t\t\tS.error(offs, \"illegal hexadecimal number\")\n+\t\t\t\ts.error(offs, \"illegal hexadecimal number\")\n \t\t\t}\n \t\t} else {\n \t\t\t// octal int or float\n \t\t\tseenDecimalDigit := false\n-\t\t\tS.scanMantissa(8)\n-\t\t\tif S.ch == '8' || S.ch == '9' {\n+\t\t\ts.scanMantissa(8)\n+\t\t\tif s.ch == '8' || s.ch == '9' {\n \t\t\t\t// illegal octal int or float\n \t\t\t\tseenDecimalDigit = true\n-\t\t\t\tS.scanMantissa(10)\n+\t\t\t\ts.scanMantissa(10)\n \t\t\t}\n-\t\t\tif S.ch == '.' || S.ch == 'e' || S.ch == 'E' || S.ch == 'i' {\n+\t\t\tif s.ch == '.' || s.ch == 'e' || s.ch == 'E' || s.ch == 'i' {\n \t\t\t\tgoto fraction\n \t\t\t}\n \t\t\t// octal int\n \t\t\tif seenDecimalDigit {\n-\t\t\t\tS.error(offs, \"illegal octal number\")\n+\t\t\t\ts.error(offs, \"illegal octal number\")\n \t\t\t}\n \t\t}\n \t\tgoto exit\n \t}\n \n \t// decimal int or float\n-\tS.scanMantissa(10)\n+\ts.scanMantissa(10)\n \n fraction:\n-\tif S.ch == '.' {\n+\tif s.ch == '.' {\n \t\ttok = token.FLOAT\n-\t\tS.next()\n-\t\tS.scanMantissa(10)\n+\t\ts.next()\n+\t\ts.scanMantissa(10)\n \t}\n \n exponent:\n-\tif S.ch == 'e' || S.ch == 'E' {\n+\tif s.ch == 'e' || s.ch == 'E' {\n \t\ttok = token.FLOAT\n-\t\tS.next()\n-\t\tif S.ch == '-' || S.ch == '+' {\n-\t\t\tS.next()\n+\t\ts.next()\n+\t\tif s.ch == '-' || s.ch == '+' {\n+\t\t\ts.next()\n \t\t}\n-\t\tS.scanMantissa(10)\n+\t\ts.scanMantissa(10)\n \t}\n \n-\tif S.ch == 'i' {\n+\tif s.ch == 'i' {\n \t\ttok = token.IMAG\n-\t\tS.next()\n+\t\ts.next()\n \t}\n \n exit:\n-\treturn tok, string(S.src[offs:S.offset])\n+\treturn tok, string(s.src[offs:s.offset])\n }\n \n-func (S *Scanner) scanEscape(quote rune) {\n-\toffs := S.offset\n+func (s *Scanner) scanEscape(quote rune) {\n+\toffs := s.offset\n \n \tvar i, base, max uint32\n-\tswitch S.ch {\n+\tswitch s.ch {\n \tcase 'a', 'b', 'f', 'n', 'r', 't', 'v', '\\\\', quote:\n-\t\tS.next()\n+\t\ts.next()\n \t\treturn\n \tcase '0', '1', '2', '3', '4', '5', '6', '7':\n \t\ti, base, max = 3, 8, 255\n \tcase 'x':\n-\t\tS.next()\n+\t\ts.next()\n \t\ti, base, max = 2, 16, 255\n \tcase 'u':\n-\t\tS.next()\n+\t\ts.next()\n \t\ti, base, max = 4, 16, unicode.MaxRune\n \tcase 'U':\n-\t\tS.next()\n+\t\ts.next()\n \t\ti, base, max = 8, 16, unicode.MaxRune\n \tdefault:\n-\t\tS.next() // always make progress\n-\t\tS.error(offs, \"unknown escape sequence\")\n+\t\ts.next() // always make progress\n+\t\ts.error(offs, \"unknown escape sequence\")\n \t\treturn\n \t}\n \n \tvar x uint32\n-\tfor ; i > 0 && S.ch != quote && S.ch >= 0; i-- {\n-\t\td := uint32(digitVal(S.ch))\n+\tfor ; i > 0 && s.ch != quote && s.ch >= 0; i-- {\n+\t\td := uint32(digitVal(s.ch))\n \t\tif d >= base {\n-\t\t\tS.error(S.offset, \"illegal character in escape sequence\")\n+\t\t\ts.error(s.offset, \"illegal character in escape sequence\")\n \t\t\tbreak\n \t\t}\n \t\tx = x*base + d\n-\t\tS.next()\n+\t\ts.next()\n \t}\n \t// in case of an error, consume remaining chars\n-\tfor ; i > 0 && S.ch != quote && S.ch >= 0; i-- {\n-\t\tS.next()\n+\tfor ; i > 0 && s.ch != quote && s.ch >= 0; i-- {\n+\t\ts.next()\n \t}\n \tif x > max || 0xd800 <= x && x < 0xe000 {\n-\t\tS.error(offs, \"escape sequence is invalid Unicode code point\")\n+\t\ts.error(offs, \"escape sequence is invalid Unicode code point\")\n \t}\n }\n \n-func (S *Scanner) scanChar() string {\n+func (s *Scanner) scanChar() string {\n \t// '\\'' opening already consumed\n-\toffs := S.offset - 1\n+\toffs := s.offset - 1\n \n \tn := 0\n-\tfor S.ch != '\\'' {\n-\t\tch := S.ch\n+\tfor s.ch != '\\'' {\n+\t\tch := s.ch\n \t\tn++\n-\t\tS.next()\n+\t\ts.next()\n \t\tif ch == '\\n' || ch < 0 {\n-\t\t\tS.error(offs, \"character literal not terminated\")\n+\t\t\ts.error(offs, \"character literal not terminated\")\n \t\t\tn = 1\n \t\t\tbreak\n \t\t}\n \t\tif ch == '\\\\' {\n-\t\t\tS.scanEscape('\\'')\n+\t\t\ts.scanEscape('\\'')\n \t\t}\n \t}\n \n-\tS.next()\n+\ts.next()\n \n \tif n != 1 {\n-\t\tS.error(offs, \"illegal character literal\")\n+\t\ts.error(offs, \"illegal character literal\")\n \t}\n \n-\treturn string(S.src[offs:S.offset])\n+\treturn string(s.src[offs:s.offset])\n }\n \n-func (S *Scanner) scanString() string {\n+func (s *Scanner) scanString() string {\n \t// '\"' opening already consumed\n-\toffs := S.offset - 1\n+\toffs := s.offset - 1\n \n-\tfor S.ch != '\"' {\n-\t\tch := S.ch\n-\t\tS.next()\n+\tfor s.ch != '\"' {\n+\t\tch := s.ch\n+\t\ts.next()\n \t\tif ch == '\\n' || ch < 0 {\n-\t\t\tS.error(offs, \"string not terminated\")\n+\t\t\ts.error(offs, \"string not terminated\")\n \t\t\tbreak\n \t\t}\n \t\tif ch == '\\\\' {\n-\t\t\tS.scanEscape('\"')\n+\t\t\ts.scanEscape('\"')\n \t\t}\n \t}\n \n-\tS.next()\n+\ts.next()\n \n-\treturn string(S.src[offs:S.offset])\n+\treturn string(s.src[offs:s.offset])\n }\n \n func stripCR(b []byte) []byte {\n@@ -449,36 +449,36 @@ func stripCR(b []byte) []byte {\n \treturn c[:i]\n }\n \n-func (S *Scanner) scanRawString() string {\n+func (s *Scanner) scanRawString() string {\n \t// '`' opening already consumed\n-\toffs := S.offset - 1\n+\toffs := s.offset - 1\n \n \thasCR := false\n-\tfor S.ch != '`' {\n-\t\tch := S.ch\n-\t\tS.next()\n+\tfor s.ch != '`' {\n+\t\tch := s.ch\n+\t\ts.next()\n \t\tif ch == '\\r' {\n \t\t\thasCR = true\n \t\t}\n \t\tif ch < 0 {\n-\t\t\tS.error(offs, \"string not terminated\")\n+\t\t\ts.error(offs, \"string not terminated\")\n \t\t\tbreak\n \t\t}\n \t}\n \n-\tS.next()\n+\ts.next()\n \n-\tlit := S.src[offs:S.offset]\n+\tlit := s.src[offs:s.offset]\n \tif hasCR {\n \t\tlit = stripCR(lit)\n \t}\n \n \treturn string(lit)\n }\n \n-func (S *Scanner) skipWhitespace() {\n-\tfor S.ch == ' ' || S.ch == '\\t' || S.ch == '\\n' && !S.insertSemi || S.ch == '\\r' {\n-\t\tS.next()\n+func (s *Scanner) skipWhitespace() {\n+\tfor s.ch == ' ' || s.ch == '\\t' || s.ch == '\\n' && !s.insertSemi || s.ch == '\\r' {\n+\t\ts.next()\n \t}\n }\n \n@@ -488,35 +488,35 @@ func (S *Scanner) skipWhitespace() {\n // respectively. Otherwise, the result is tok0 if there was no other\n // matching character, or tok2 if the matching character was ch2.\n \n-func (S *Scanner) switch2(tok0, tok1 token.Token) token.Token {\n-\tif S.ch == '=' {\n-\t\tS.next()\n+func (s *Scanner) switch2(tok0, tok1 token.Token) token.Token {\n+\tif s.ch == '=' {\n+\t\ts.next()\n \t\treturn tok1\n \t}\n \treturn tok0\n }\n \n-func (S *Scanner) switch3(tok0, tok1 token.Token, ch2 rune, tok2 token.Token) token.Token {\n-\tif S.ch == '=' {\n-\t\tS.next()\n+func (s *Scanner) switch3(tok0, tok1 token.Token, ch2 rune, tok2 token.Token) token.Token {\n+\tif s.ch == '=' {\n+\t\ts.next()\n \t\treturn tok1\n \t}\n-\tif S.ch == ch2 {\n-\t\tS.next()\n+\tif s.ch == ch2 {\n+\t\ts.next()\n \t\treturn tok2\n \t}\n \treturn tok0\n }\n \n-func (S *Scanner) switch4(tok0, tok1 token.Token, ch2 rune, tok2, tok3 token.Token) token.Token {\n-\tif S.ch == '=' {\n-\t\tS.next()\n+func (s *Scanner) switch4(tok0, tok1 token.Token, ch2 rune, tok2, tok3 token.Token) token.Token {\n+\tif s.ch == '=' {\n+\t\ts.next()\n \t\treturn tok1\n \t}\n-\tif S.ch == ch2 {\n-\t\tS.next()\n-\t\tif S.ch == '=' {\n-\t\t\tS.next()\n+\tif s.ch == ch2 {\n+\t\ts.next()\n+\t\tif s.ch == '=' {\n+\t\t\ts.next()\n \t\t\treturn tok3\n \t\t}\n \t\treturn tok2\n@@ -553,63 +553,63 @@ func (S *Scanner) switch4(tok0, tok1 token.Token, ch2 rune, tok2, tok3 token.Tok\n // set with Init. Token positions are relative to that file\n // and thus relative to the file set.\n //\n-func (S *Scanner) Scan() (pos token.Pos, tok token.Token, lit string) {\n+func (s *Scanner) Scan() (pos token.Pos, tok token.Token, lit string) {\n scanAgain:\n-\tS.skipWhitespace()\n+\ts.skipWhitespace()\n \n \t// current token start\n-\tpos = S.file.Pos(S.offset)\n+\tpos = s.file.Pos(s.offset)\n \n \t// determine token value\n \tinsertSemi := false\n-\tswitch ch := S.ch; {\n+\tswitch ch := s.ch; {\n \tcase isLetter(ch):\n-\t\tlit = S.scanIdentifier()\n+\t\tlit = s.scanIdentifier()\n \t\ttok = token.Lookup(lit)\n \t\tswitch tok {\n \t\tcase token.IDENT, token.BREAK, token.CONTINUE, token.FALLTHROUGH, token.RETURN:\n \t\t\tinsertSemi = true\n \t\t}\n \tcase digitVal(ch) < 10:\n \t\tinsertSemi = true\n-\t\ttok, lit = S.scanNumber(false)\n+\t\ttok, lit = s.scanNumber(false)\n \tdefault:\n-\t\tS.next() // always make progress\n+\t\ts.next() // always make progress\n \t\tswitch ch {\n \t\tcase -1:\n-\t\t\tif S.insertSemi {\n-\t\t\t\tS.insertSemi = false // EOF consumed\n+\t\t\tif s.insertSemi {\n+\t\t\t\ts.insertSemi = false // EOF consumed\n \t\t\t\treturn pos, token.SEMICOLON, \"\\n\"\n \t\t\t}\n \t\t\ttok = token.EOF\n \t\tcase '\\n':\n-\t\t\t// we only reach here if S.insertSemi was\n+\t\t\t// we only reach here if s.insertSemi was\n \t\t\t// set in the first place and exited early\n-\t\t\t// from S.skipWhitespace()\n-\t\t\tS.insertSemi = false // newline consumed\n+\t\t\t// from s.skipWhitespace()\n+\t\t\ts.insertSemi = false // newline consumed\n \t\t\treturn pos, token.SEMICOLON, \"\\n\"\n \t\tcase '\"':\n \t\t\tinsertSemi = true\n \t\t\ttok = token.STRING\n-\t\t\tlit = S.scanString()\n+\t\t\tlit = s.scanString()\n \t\tcase '\\'':\n \t\t\tinsertSemi = true\n \t\t\ttok = token.CHAR\n-\t\t\tlit = S.scanChar()\n+\t\t\tlit = s.scanChar()\n \t\tcase '`':\n \t\t\tinsertSemi = true\n \t\t\ttok = token.STRING\n-\t\t\tlit = S.scanRawString()\n+\t\t\tlit = s.scanRawString()\n \t\tcase ':':\n-\t\t\ttok = S.switch2(token.COLON, token.DEFINE)\n+\t\t\ttok = s.switch2(token.COLON, token.DEFINE)\n \t\tcase '.':\n-\t\t\tif digitVal(S.ch) < 10 {\n+\t\t\tif digitVal(s.ch) < 10 {\n \t\t\t\tinsertSemi = true\n-\t\t\t\ttok, lit = S.scanNumber(true)\n-\t\t\t} else if S.ch == '.' {\n-\t\t\t\tS.next()\n-\t\t\t\tif S.ch == '.' {\n-\t\t\t\t\tS.next()\n+\t\t\t\ttok, lit = s.scanNumber(true)\n+\t\t\t} else if s.ch == '.' {\n+\t\t\t\ts.next()\n+\t\t\t\tif s.ch == '.' {\n+\t\t\t\t\ts.next()\n \t\t\t\t\ttok = token.ELLIPSIS\n \t\t\t\t}\n \t\t\t} else {\n@@ -636,73 +636,73 @@ scanAgain:\n \t\t\tinsertSemi = true\n \t\t\ttok = token.RBRACE\n \t\tcase '+':\n-\t\t\ttok = S.switch3(token.ADD, token.ADD_ASSIGN, '+', token.INC)\n+\t\t\ttok = s.switch3(token.ADD, token.ADD_ASSIGN, '+', token.INC)\n \t\t\tif tok == token.INC {\n \t\t\t\tinsertSemi = true\n \t\t\t}\n \t\tcase '-':\n-\t\t\ttok = S.switch3(token.SUB, token.SUB_ASSIGN, '-', token.DEC)\n+\t\t\ttok = s.switch3(token.SUB, token.SUB_ASSIGN, '-', token.DEC)\n \t\t\tif tok == token.DEC {\n \t\t\t\tinsertSemi = true\n \t\t\t}\n \t\tcase '*':\n-\t\t\ttok = S.switch2(token.MUL, token.MUL_ASSIGN)\n+\t\t\ttok = s.switch2(token.MUL, token.MUL_ASSIGN)\n \t\tcase '/':\n-\t\t\tif S.ch == '/' || S.ch == '*' {\n+\t\t\tif s.ch == '/' || s.ch == '*' {\n \t\t\t\t// comment\n-\t\t\t\tif S.insertSemi && S.findLineEnd() {\n+\t\t\t\tif s.insertSemi && s.findLineEnd() {\n \t\t\t\t\t// reset position to the beginning of the comment\n-\t\t\t\t\tS.ch = '/'\n-\t\t\t\t\tS.offset = S.file.Offset(pos)\n-\t\t\t\t\tS.rdOffset = S.offset + 1\n-\t\t\t\t\tS.insertSemi = false // newline consumed\n+\t\t\t\t\ts.ch = '/'\n+\t\t\t\t\ts.offset = s.file.Offset(pos)\n+\t\t\t\t\ts.rdOffset = s.offset + 1\n+\t\t\t\t\ts.insertSemi = false // newline consumed\n \t\t\t\t\treturn pos, token.SEMICOLON, \"\\n\"\n \t\t\t\t}\n-\t\t\t\tlit = S.scanComment()\n-\t\t\t\tif S.mode&ScanComments == 0 {\n+\t\t\t\tlit = s.scanComment()\n+\t\t\t\tif s.mode&ScanComments == 0 {\n \t\t\t\t\t// skip comment\n-\t\t\t\t\tS.insertSemi = false // newline consumed\n+\t\t\t\t\ts.insertSemi = false // newline consumed\n \t\t\t\t\tgoto scanAgain\n \t\t\t\t}\n \t\t\t\ttok = token.COMMENT\n \t\t\t} else {\n-\t\t\t\ttok = S.switch2(token.QUO, token.QUO_ASSIGN)\n+\t\t\t\ttok = s.switch2(token.QUO, token.QUO_ASSIGN)\n \t\t\t}\n \t\tcase '%':\n-\t\t\ttok = S.switch2(token.REM, token.REM_ASSIGN)\n+\t\t\ttok = s.switch2(token.REM, token.REM_ASSIGN)\n \t\tcase '^':\n-\t\t\ttok = S.switch2(token.XOR, token.XOR_ASSIGN)\n+\t\t\ttok = s.switch2(token.XOR, token.XOR_ASSIGN)\n \t\tcase '<':\n-\t\t\tif S.ch == '-' {\n-\t\t\t\tS.next()\n+\t\t\tif s.ch == '-' {\n+\t\t\t\ts.next()\n \t\t\t\ttok = token.ARROW\n \t\t\t} else {\n-\t\t\t\ttok = S.switch4(token.LSS, token.LEQ, '<', token.SHL, token.SHL_ASSIGN)\n+\t\t\t\ttok = s.switch4(token.LSS, token.LEQ, '<', token.SHL, token.SHL_ASSIGN)\n \t\t\t}\n \t\tcase '>':\n-\t\t\ttok = S.switch4(token.GTR, token.GEQ, '>', token.SHR, token.SHR_ASSIGN)\n+\t\t\ttok = s.switch4(token.GTR, token.GEQ, '>', token.SHR, token.SHR_ASSIGN)\n \t\tcase '=':\n-\t\t\ttok = S.switch2(token.ASSIGN, token.EQL)\n+\t\t\ttok = s.switch2(token.ASSIGN, token.EQL)\n \t\tcase '!':\n-\t\t\ttok = S.switch2(token.NOT, token.NEQ)\n+\t\t\ttok = s.switch2(token.NOT, token.NEQ)\n \t\tcase '&':\n-\t\t\tif S.ch == '^' {\n-\t\t\t\tS.next()\n-\t\t\t\ttok = S.switch2(token.AND_NOT, token.AND_NOT_ASSIGN)\n+\t\t\tif s.ch == '^' {\n+\t\t\t\ts.next()\n+\t\t\t\ttok = s.switch2(token.AND_NOT, token.AND_NOT_ASSIGN)\n \t\t\t} else {\n-\t\t\t\ttok = S.switch3(token.AND, token.AND_ASSIGN, '&', token.LAND)\n+\t\t\t\ttok = s.switch3(token.AND, token.AND_ASSIGN, '&', token.LAND)\n \t\t\t}\n \t\tcase '|':\n-\t\t\ttok = S.switch3(token.OR, token.OR_ASSIGN, '|', token.LOR)\n+\t\t\ttok = s.switch3(token.OR, token.OR_ASSIGN, '|', token.LOR)\n \t\tdefault:\n-\t\t\tS.error(S.file.Offset(pos), fmt.Sprintf(\"illegal character %#U\", ch))\n-\t\t\tinsertSemi = S.insertSemi // preserve insertSemi info\n+\t\t\ts.error(s.file.Offset(pos), fmt.Sprintf(\"illegal character %#U\", ch))\n+\t\t\tinsertSemi = s.insertSemi // preserve insertSemi info\n \t\t\ttok = token.ILLEGAL\n \t\t\tlit = string(ch)\n \t\t}\n \t}\n-\tif S.mode&dontInsertSemis == 0 {\n-\t\tS.insertSemi = insertSemi\n+\tif s.mode&dontInsertSemis == 0 {\n+\t\ts.insertSemi = insertSemi\n \t}\n \n \treturn"}, {"sha": "e7f7cd1c1e9af43655a9cb32ef3bed8b77025780", "filename": "libgo/go/go/scanner/scanner_test.go", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -230,7 +230,13 @@ func TestScan(t *testing.T) {\n \tvar s Scanner\n \ts.Init(fset.AddFile(\"\", fset.Base(), len(source)), source, &testErrorHandler{t}, ScanComments|dontInsertSemis)\n \tindex := 0\n-\tepos := token.Position{\"\", 0, 1, 1} // expected position\n+\t// epos is the expected position\n+\tepos := token.Position{\n+\t\tFilename: \"\",\n+\t\tOffset:   0,\n+\t\tLine:     1,\n+\t\tColumn:   1,\n+\t}\n \tfor {\n \t\tpos, tok, lit := s.Scan()\n \t\tif lit == \"\" {\n@@ -505,7 +511,12 @@ func TestLineComments(t *testing.T) {\n \tfor _, s := range segs {\n \t\tp, _, lit := S.Scan()\n \t\tpos := file.Position(p)\n-\t\tcheckPos(t, lit, p, token.Position{s.filename, pos.Offset, s.line, pos.Column})\n+\t\tcheckPos(t, lit, p, token.Position{\n+\t\t\tFilename: s.filename,\n+\t\t\tOffset:   pos.Offset,\n+\t\t\tLine:     s.line,\n+\t\t\tColumn:   pos.Column,\n+\t\t})\n \t}\n \n \tif S.ErrorCount != 0 {"}, {"sha": "4adc8f9e33422f656039c98a50c65713b3734698", "filename": "libgo/go/go/token/serialize.go", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Ftoken%2Fserialize.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Ftoken%2Fserialize.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fserialize.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -4,11 +4,6 @@\n \n package token\n \n-import (\n-\t\"encoding/gob\"\n-\t\"io\"\n-)\n-\n type serializedFile struct {\n \t// fields correspond 1:1 to fields with same (lower-case) name in File\n \tName  string\n@@ -23,19 +18,10 @@ type serializedFileSet struct {\n \tFiles []serializedFile\n }\n \n-func (s *serializedFileSet) Read(r io.Reader) error {\n-\treturn gob.NewDecoder(r).Decode(s)\n-}\n-\n-func (s *serializedFileSet) Write(w io.Writer) error {\n-\treturn gob.NewEncoder(w).Encode(s)\n-}\n-\n-// Read reads the fileset from r into s; s must not be nil.\n-// If r does not also implement io.ByteReader, it will be wrapped in a bufio.Reader.\n-func (s *FileSet) Read(r io.Reader) error {\n+// Read calls decode to deserialize a file set into s; s must not be nil.\n+func (s *FileSet) Read(decode func(interface{}) error) error {\n \tvar ss serializedFileSet\n-\tif err := ss.Read(r); err != nil {\n+\tif err := decode(&ss); err != nil {\n \t\treturn err\n \t}\n \n@@ -53,8 +39,8 @@ func (s *FileSet) Read(r io.Reader) error {\n \treturn nil\n }\n \n-// Write writes the fileset s to w.\n-func (s *FileSet) Write(w io.Writer) error {\n+// Write calls encode to serialize the file set s.\n+func (s *FileSet) Write(encode func(interface{}) error) error {\n \tvar ss serializedFileSet\n \n \ts.mutex.Lock()\n@@ -66,5 +52,5 @@ func (s *FileSet) Write(w io.Writer) error {\n \tss.Files = files\n \ts.mutex.Unlock()\n \n-\treturn ss.Write(w)\n+\treturn encode(ss)\n }"}, {"sha": "4e925adb6f26406df05ae62582ab866e1b95c8be", "filename": "libgo/go/go/token/serialize_test.go", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Ftoken%2Fserialize_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fgo%2Ftoken%2Fserialize_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fserialize_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -6,6 +6,7 @@ package token\n \n import (\n \t\"bytes\"\n+\t\"encoding/gob\"\n \t\"fmt\"\n \t\"testing\"\n )\n@@ -69,12 +70,18 @@ func equal(p, q *FileSet) error {\n \n func checkSerialize(t *testing.T, p *FileSet) {\n \tvar buf bytes.Buffer\n-\tif err := p.Write(&buf); err != nil {\n+\tencode := func(x interface{}) error {\n+\t\treturn gob.NewEncoder(&buf).Encode(x)\n+\t}\n+\tif err := p.Write(encode); err != nil {\n \t\tt.Errorf(\"writing fileset failed: %s\", err)\n \t\treturn\n \t}\n \tq := NewFileSet()\n-\tif err := q.Read(&buf); err != nil {\n+\tdecode := func(x interface{}) error {\n+\t\treturn gob.NewDecoder(&buf).Decode(x)\n+\t}\n+\tif err := q.Read(decode); err != nil {\n \t\tt.Errorf(\"reading fileset failed: %s\", err)\n \t\treturn\n \t}"}, {"sha": "fee771a5784e200eb47d42072ebb463e78aaaef9", "filename": "libgo/go/html/escape.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fhtml%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fhtml%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fescape.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -2,6 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// Package html provides functions for escaping and unescaping HTML text.\n package html\n \n import (\n@@ -237,8 +238,8 @@ func EscapeString(s string) string {\n \tif strings.IndexAny(s, escapedChars) == -1 {\n \t\treturn s\n \t}\n-\tbuf := bytes.NewBuffer(nil)\n-\tescape(buf, s)\n+\tvar buf bytes.Buffer\n+\tescape(&buf, s)\n \treturn buf.String()\n }\n "}, {"sha": "70cada3f50b07a62258bf3d39e04f1ab674d7e92", "filename": "libgo/go/html/template/escape_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -1471,7 +1471,7 @@ func TestEscapeText(t *testing.T) {\n \n \tfor _, test := range tests {\n \t\tb, e := []byte(test.input), newEscaper(nil)\n-\t\tc := e.escapeText(context{}, &parse.TextNode{parse.NodeText, b})\n+\t\tc := e.escapeText(context{}, &parse.TextNode{NodeType: parse.NodeText, Text: b})\n \t\tif !test.output.eq(c) {\n \t\t\tt.Errorf(\"input %q: want context\\n\\t%v\\ngot\\n\\t%v\", test.input, test.output, c)\n \t\t\tcontinue"}, {"sha": "a895a50aa9025da8b72482ad9045d84fb5a52e67", "filename": "libgo/go/html/template/js.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fhtml%2Ftemplate%2Fjs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fhtml%2Ftemplate%2Fjs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fjs.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -154,7 +154,7 @@ func jsValEscaper(args ...interface{}) string {\n \t\ta = fmt.Sprint(args...)\n \t}\n \t// TODO: detect cycles before calling Marshal which loops infinitely on\n-\t// cyclic data. This may be an unnacceptable DoS risk.\n+\t// cyclic data. This may be an unacceptable DoS risk.\n \n \tb, err := json.Marshal(a)\n \tif err != nil {"}, {"sha": "58bd7812ffd0dd7f28cbba820249b232dd0b3ac3", "filename": "libgo/go/image/bmp/reader.go", "status": "removed", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Fbmp%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Fbmp%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fbmp%2Freader.go?ref=cd6368115dbd75d9187877097c48a0d8d4c04fd4", "patch": "@@ -1,152 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package bmp implements a BMP image decoder.\n-//\n-// The BMP specification is at http://www.digicamsoft.com/bmp/bmp.html.\n-package bmp\n-\n-import (\n-\t\"errors\"\n-\t\"image\"\n-\t\"image/color\"\n-\t\"io\"\n-)\n-\n-// ErrUnsupported means that the input BMP image uses a valid but unsupported\n-// feature.\n-var ErrUnsupported = errors.New(\"bmp: unsupported BMP image\")\n-\n-func readUint16(b []byte) uint16 {\n-\treturn uint16(b[0]) | uint16(b[1])<<8\n-}\n-\n-func readUint32(b []byte) uint32 {\n-\treturn uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24\n-}\n-\n-// decodePaletted reads an 8 bit-per-pixel BMP image from r.\n-func decodePaletted(r io.Reader, c image.Config) (image.Image, error) {\n-\tvar tmp [4]byte\n-\tpaletted := image.NewPaletted(image.Rect(0, 0, c.Width, c.Height), c.ColorModel.(color.Palette))\n-\t// BMP images are stored bottom-up rather than top-down.\n-\tfor y := c.Height - 1; y >= 0; y-- {\n-\t\tp := paletted.Pix[y*paletted.Stride : y*paletted.Stride+c.Width]\n-\t\t_, err := io.ReadFull(r, p)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\t// Each row is 4-byte aligned.\n-\t\tif c.Width%4 != 0 {\n-\t\t\t_, err := io.ReadFull(r, tmp[:4-c.Width%4])\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn paletted, nil\n-}\n-\n-// decodeRGBA reads a 24 bit-per-pixel BMP image from r.\n-func decodeRGBA(r io.Reader, c image.Config) (image.Image, error) {\n-\trgba := image.NewRGBA(image.Rect(0, 0, c.Width, c.Height))\n-\t// There are 3 bytes per pixel, and each row is 4-byte aligned.\n-\tb := make([]byte, (3*c.Width+3)&^3)\n-\t// BMP images are stored bottom-up rather than top-down.\n-\tfor y := c.Height - 1; y >= 0; y-- {\n-\t\t_, err := io.ReadFull(r, b)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tp := rgba.Pix[y*rgba.Stride : y*rgba.Stride+c.Width*4]\n-\t\tfor i, j := 0, 0; i < len(p); i, j = i+4, j+3 {\n-\t\t\t// BMP images are stored in BGR order rather than RGB order.\n-\t\t\tp[i+0] = b[j+2]\n-\t\t\tp[i+1] = b[j+1]\n-\t\t\tp[i+2] = b[j+0]\n-\t\t\tp[i+3] = 0xFF\n-\t\t}\n-\t}\n-\treturn rgba, nil\n-}\n-\n-// Decode reads a BMP image from r and returns it as an image.Image.\n-// Limitation: The file must be 8 or 24 bits per pixel.\n-func Decode(r io.Reader) (image.Image, error) {\n-\tc, err := DecodeConfig(r)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tif c.ColorModel == color.RGBAModel {\n-\t\treturn decodeRGBA(r, c)\n-\t}\n-\treturn decodePaletted(r, c)\n-}\n-\n-// DecodeConfig returns the color model and dimensions of a BMP image without\n-// decoding the entire image.\n-// Limitation: The file must be 8 or 24 bits per pixel.\n-func DecodeConfig(r io.Reader) (config image.Config, err error) {\n-\t// We only support those BMP images that are a BITMAPFILEHEADER\n-\t// immediately followed by a BITMAPINFOHEADER.\n-\tconst (\n-\t\tfileHeaderLen = 14\n-\t\tinfoHeaderLen = 40\n-\t)\n-\tvar b [1024]byte\n-\tif _, err = io.ReadFull(r, b[:fileHeaderLen+infoHeaderLen]); err != nil {\n-\t\treturn\n-\t}\n-\tif string(b[:2]) != \"BM\" {\n-\t\terr = errors.New(\"bmp: invalid format\")\n-\t\treturn\n-\t}\n-\toffset := readUint32(b[10:14])\n-\tif readUint32(b[14:18]) != infoHeaderLen {\n-\t\terr = ErrUnsupported\n-\t\treturn\n-\t}\n-\twidth := int(readUint32(b[18:22]))\n-\theight := int(readUint32(b[22:26]))\n-\tif width < 0 || height < 0 {\n-\t\terr = ErrUnsupported\n-\t\treturn\n-\t}\n-\t// We only support 1 plane, 8 or 24 bits per pixel and no compression.\n-\tplanes, bpp, compression := readUint16(b[26:28]), readUint16(b[28:30]), readUint32(b[30:34])\n-\tif planes != 1 || compression != 0 {\n-\t\terr = ErrUnsupported\n-\t\treturn\n-\t}\n-\tswitch bpp {\n-\tcase 8:\n-\t\tif offset != fileHeaderLen+infoHeaderLen+256*4 {\n-\t\t\terr = ErrUnsupported\n-\t\t\treturn\n-\t\t}\n-\t\t_, err = io.ReadFull(r, b[:256*4])\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tpcm := make(color.Palette, 256)\n-\t\tfor i := range pcm {\n-\t\t\t// BMP images are stored in BGR order rather than RGB order.\n-\t\t\t// Every 4th byte is padding.\n-\t\t\tpcm[i] = color.RGBA{b[4*i+2], b[4*i+1], b[4*i+0], 0xFF}\n-\t\t}\n-\t\treturn image.Config{pcm, width, height}, nil\n-\tcase 24:\n-\t\tif offset != fileHeaderLen+infoHeaderLen {\n-\t\t\terr = ErrUnsupported\n-\t\t\treturn\n-\t\t}\n-\t\treturn image.Config{color.RGBAModel, width, height}, nil\n-\t}\n-\terr = ErrUnsupported\n-\treturn\n-}\n-\n-func init() {\n-\timage.RegisterFormat(\"bmp\", \"BM????\\x00\\x00\\x00\\x00\", Decode, DecodeConfig)\n-}"}, {"sha": "d659867243fbc0b3cdd93e27061bca774434f165", "filename": "libgo/go/image/decode_test.go", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdecode_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -11,11 +11,9 @@ import (\n \t\"os\"\n \t\"testing\"\n \n-\t_ \"image/bmp\"\n \t_ \"image/gif\"\n \t_ \"image/jpeg\"\n \t_ \"image/png\"\n-\t_ \"image/tiff\"\n )\n \n type imageTest struct {\n@@ -25,18 +23,15 @@ type imageTest struct {\n }\n \n var imageTests = []imageTest{\n-\t{\"testdata/video-001.png\", \"testdata/video-001.bmp\", 0},\n+\t{\"testdata/video-001.png\", \"testdata/video-001.png\", 0},\n \t// GIF images are restricted to a 256-color palette and the conversion\n \t// to GIF loses significant image quality.\n \t{\"testdata/video-001.png\", \"testdata/video-001.gif\", 64 << 8},\n \t{\"testdata/video-001.png\", \"testdata/video-001.interlaced.gif\", 64 << 8},\n \t{\"testdata/video-001.png\", \"testdata/video-001.5bpp.gif\", 128 << 8},\n \t// JPEG is a lossy format and hence needs a non-zero tolerance.\n \t{\"testdata/video-001.png\", \"testdata/video-001.jpeg\", 8 << 8},\n-\t{\"testdata/video-001.png\", \"testdata/video-001.png\", 0},\n-\t{\"testdata/video-001.png\", \"testdata/video-001.tiff\", 0},\n-\n-\t// Test grayscale images.\n+\t// Grayscale images.\n \t{\"testdata/video-005.gray.png\", \"testdata/video-005.gray.jpeg\", 8 << 8},\n \t{\"testdata/video-005.gray.png\", \"testdata/video-005.gray.png\", 0},\n }"}, {"sha": "cc62e25f1bbfcedfdacca70f464aa9796c2d24b0", "filename": "libgo/go/image/draw/bench_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fdraw%2Fbench_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fdraw%2Fbench_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdraw%2Fbench_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -56,7 +56,7 @@ func bench(b *testing.B, dcm, scm, mcm color.Model, op Op) {\n \tvar src image.Image\n \tswitch scm {\n \tcase nil:\n-\t\tsrc = &image.Uniform{color.RGBA{0x11, 0x22, 0x33, 0xff}}\n+\t\tsrc = &image.Uniform{C: color.RGBA{0x11, 0x22, 0x33, 0xff}}\n \tcase color.RGBAModel:\n \t\tsrc1 := image.NewRGBA(image.Rect(0, 0, srcw, srch))\n \t\tfor y := 0; y < srch; y++ {\n@@ -145,7 +145,7 @@ func bench(b *testing.B, dcm, scm, mcm color.Model, op Op) {\n \t\tx := 3 * i % (dstw - srcw)\n \t\ty := 7 * i % (dsth - srch)\n \n-\t\tDrawMask(dst, dst.Bounds().Add(image.Point{x, y}), src, image.ZP, mask, image.ZP, op)\n+\t\tDrawMask(dst, dst.Bounds().Add(image.Pt(x, y)), src, image.ZP, mask, image.ZP, op)\n \t}\n }\n "}, {"sha": "1db75b3e3f63ad28ec92249915c64c700ecc360f", "filename": "libgo/go/image/draw/draw_test.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdraw%2Fdraw_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -168,15 +168,15 @@ func makeGolden(dst image.Image, r image.Rectangle, src image.Image, sp image.Po\n \t\tsy := y + sp.Y - r.Min.Y\n \t\tmy := y + mp.Y - r.Min.Y\n \t\tfor x := r.Min.X; x < r.Max.X; x++ {\n-\t\t\tif !(image.Point{x, y}.In(b)) {\n+\t\t\tif !(image.Pt(x, y).In(b)) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tsx := x + sp.X - r.Min.X\n-\t\t\tif !(image.Point{sx, sy}.In(sb)) {\n+\t\t\tif !(image.Pt(sx, sy).In(sb)) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tmx := x + mp.X - r.Min.X\n-\t\t\tif !(image.Point{mx, my}.In(mb)) {\n+\t\t\tif !(image.Pt(mx, my).In(mb)) {\n \t\t\t\tcontinue\n \t\t\t}\n \n@@ -313,7 +313,7 @@ func TestFill(t *testing.T) {\n \t\tm := image.NewRGBA(image.Rect(0, 0, 40, 30)).SubImage(r).(*image.RGBA)\n \t\tb := m.Bounds()\n \t\tc := color.RGBA{11, 0, 0, 255}\n-\t\tsrc := &image.Uniform{c}\n+\t\tsrc := &image.Uniform{C: c}\n \t\tcheck := func(desc string) {\n \t\t\tfor y := b.Min.Y; y < b.Max.Y; y++ {\n \t\t\t\tfor x := b.Min.X; x < b.Max.X; x++ {\n@@ -333,21 +333,21 @@ func TestFill(t *testing.T) {\n \t\tcheck(\"pixel\")\n \t\t// Draw 1 row at a time.\n \t\tc = color.RGBA{0, 22, 0, 255}\n-\t\tsrc = &image.Uniform{c}\n+\t\tsrc = &image.Uniform{C: c}\n \t\tfor y := b.Min.Y; y < b.Max.Y; y++ {\n \t\t\tDrawMask(m, image.Rect(b.Min.X, y, b.Max.X, y+1), src, image.ZP, nil, image.ZP, Src)\n \t\t}\n \t\tcheck(\"row\")\n \t\t// Draw 1 column at a time.\n \t\tc = color.RGBA{0, 0, 33, 255}\n-\t\tsrc = &image.Uniform{c}\n+\t\tsrc = &image.Uniform{C: c}\n \t\tfor x := b.Min.X; x < b.Max.X; x++ {\n \t\t\tDrawMask(m, image.Rect(x, b.Min.Y, x+1, b.Max.Y), src, image.ZP, nil, image.ZP, Src)\n \t\t}\n \t\tcheck(\"column\")\n \t\t// Draw the whole image at once.\n \t\tc = color.RGBA{44, 55, 66, 77}\n-\t\tsrc = &image.Uniform{c}\n+\t\tsrc = &image.Uniform{C: c}\n \t\tDrawMask(m, b, src, image.ZP, nil, image.ZP, Src)\n \t\tcheck(\"whole\")\n \t}"}, {"sha": "f93d356b041465d85f0a37fdd9b34003ee9842e2", "filename": "libgo/go/image/format.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fformat.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -10,8 +10,8 @@ import (\n \t\"io\"\n )\n \n-// An UnknownFormatErr indicates that decoding encountered an unknown format.\n-var UnknownFormatErr = errors.New(\"image: unknown format\")\n+// ErrFormat indicates that decoding encountered an unknown format.\n+var ErrFormat = errors.New(\"image: unknown format\")\n \n // A format holds an image format's name, magic header and how to decode it.\n type format struct {\n@@ -79,7 +79,7 @@ func Decode(r io.Reader) (Image, string, error) {\n \trr := asReader(r)\n \tf := sniff(rr)\n \tif f.decode == nil {\n-\t\treturn nil, \"\", UnknownFormatErr\n+\t\treturn nil, \"\", ErrFormat\n \t}\n \tm, err := f.decode(rr)\n \treturn m, f.name, err\n@@ -93,7 +93,7 @@ func DecodeConfig(r io.Reader) (Config, string, error) {\n \trr := asReader(r)\n \tf := sniff(rr)\n \tif f.decodeConfig == nil {\n-\t\treturn Config{}, \"\", UnknownFormatErr\n+\t\treturn Config{}, \"\", ErrFormat\n \t}\n \tc, err := f.decodeConfig(rr)\n \treturn c, f.name, err"}, {"sha": "8b36948d6993b9bbd84fcfd8ce16bbc96f5196bc", "filename": "libgo/go/image/gif/reader.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fgif%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fgif%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fgif%2Freader.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -416,7 +416,11 @@ func DecodeConfig(r io.Reader) (image.Config, error) {\n \tif err := d.decode(r, true); err != nil {\n \t\treturn image.Config{}, err\n \t}\n-\treturn image.Config{d.globalColorMap, d.width, d.height}, nil\n+\treturn image.Config{\n+\t\tColorModel: d.globalColorMap,\n+\t\tWidth:      d.width,\n+\t\tHeight:     d.height,\n+\t}, nil\n }\n \n func init() {"}, {"sha": "63bfb7d59e40c58c3055b84a35407c03cea7e562", "filename": "libgo/go/image/image.go", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fimage.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fimage.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fimage.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -4,7 +4,20 @@\n \n // Package image implements a basic 2-D image library.\n //\n-// See \"The Go image package\" for an introduction to this package:\n+// The fundamental interface is called Image. An Image contains colors, which\n+// are described in the image/color package.\n+//\n+// Values of the Image interface are created either by calling functions such\n+// as NewRGBA and NewPaletted, or by calling Decode on an io.Reader containing\n+// image data in a format such as GIF, JPEG or PNG. Decoding any particular\n+// image format requires the prior registration of a decoder function.\n+// Registration is typically automatic as a side effect of initializing that\n+// format's package so that, to decode a PNG image, it suffices to have\n+//\timport _ \"image/png\"\n+// in a program's main package. The _ means to import a package purely for its\n+// initialization side effects.\n+//\n+// See \"The Go image package\" for more details:\n // http://blog.golang.org/2011/09/go-image-package.html\n package image\n \n@@ -18,7 +31,8 @@ type Config struct {\n \tWidth, Height int\n }\n \n-// Image is a finite rectangular grid of Colors drawn from a color model.\n+// Image is a finite rectangular grid of color.Color values taken from a color\n+// model.\n type Image interface {\n \t// ColorModel returns the Image's color model.\n \tColorModel() color.Model\n@@ -42,7 +56,7 @@ type PalettedImage interface {\n \tImage\n }\n \n-// RGBA is an in-memory image of RGBAColor values.\n+// RGBA is an in-memory image whose At method returns color.RGBA values.\n type RGBA struct {\n \t// Pix holds the image's pixels, in R, G, B, A order. The pixel at\n \t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4].\n@@ -137,7 +151,7 @@ func NewRGBA(r Rectangle) *RGBA {\n \treturn &RGBA{buf, 4 * w, r}\n }\n \n-// RGBA64 is an in-memory image of RGBA64Color values.\n+// RGBA64 is an in-memory image whose At method returns color.RGBA64 values.\n type RGBA64 struct {\n \t// Pix holds the image's pixels, in R, G, B, A order and big-endian format. The pixel at\n \t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*8].\n@@ -245,7 +259,7 @@ func NewRGBA64(r Rectangle) *RGBA64 {\n \treturn &RGBA64{pix, 8 * w, r}\n }\n \n-// NRGBA is an in-memory image of NRGBAColor values.\n+// NRGBA is an in-memory image whose At method returns color.NRGBA values.\n type NRGBA struct {\n \t// Pix holds the image's pixels, in R, G, B, A order. The pixel at\n \t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4].\n@@ -340,7 +354,7 @@ func NewNRGBA(r Rectangle) *NRGBA {\n \treturn &NRGBA{pix, 4 * w, r}\n }\n \n-// NRGBA64 is an in-memory image of NRGBA64Color values.\n+// NRGBA64 is an in-memory image whose At method returns color.NRGBA64 values.\n type NRGBA64 struct {\n \t// Pix holds the image's pixels, in R, G, B, A order and big-endian format. The pixel at\n \t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*8].\n@@ -448,7 +462,7 @@ func NewNRGBA64(r Rectangle) *NRGBA64 {\n \treturn &NRGBA64{pix, 8 * w, r}\n }\n \n-// Alpha is an in-memory image of AlphaColor values.\n+// Alpha is an in-memory image whose At method returns color.Alpha values.\n type Alpha struct {\n \t// Pix holds the image's pixels, as alpha values. The pixel at\n \t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1].\n@@ -536,7 +550,7 @@ func NewAlpha(r Rectangle) *Alpha {\n \treturn &Alpha{pix, 1 * w, r}\n }\n \n-// Alpha16 is an in-memory image of Alpha16Color values.\n+// Alpha16 is an in-memory image whose At method returns color.Alpha64 values.\n type Alpha16 struct {\n \t// Pix holds the image's pixels, as alpha values in big-endian format. The pixel at\n \t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*2].\n@@ -627,7 +641,7 @@ func NewAlpha16(r Rectangle) *Alpha16 {\n \treturn &Alpha16{pix, 2 * w, r}\n }\n \n-// Gray is an in-memory image of GrayColor values.\n+// Gray is an in-memory image whose At method returns color.Gray values.\n type Gray struct {\n \t// Pix holds the image's pixels, as gray values. The pixel at\n \t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1].\n@@ -702,7 +716,7 @@ func NewGray(r Rectangle) *Gray {\n \treturn &Gray{pix, 1 * w, r}\n }\n \n-// Gray16 is an in-memory image of Gray16Color values.\n+// Gray16 is an in-memory image whose At method returns color.Gray16 values.\n type Gray16 struct {\n \t// Pix holds the image's pixels, as gray values in big-endian format. The pixel at\n \t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*2]."}, {"sha": "d9adf6e587627b89f7902c81fa00fe2ba5f4a663", "filename": "libgo/go/image/jpeg/reader.go", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Freader.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -454,9 +454,17 @@ func DecodeConfig(r io.Reader) (image.Config, error) {\n \t}\n \tswitch d.nComp {\n \tcase nGrayComponent:\n-\t\treturn image.Config{color.GrayModel, d.width, d.height}, nil\n+\t\treturn image.Config{\n+\t\t\tColorModel: color.GrayModel,\n+\t\t\tWidth:      d.width,\n+\t\t\tHeight:     d.height,\n+\t\t}, nil\n \tcase nColorComponent:\n-\t\treturn image.Config{color.YCbCrModel, d.width, d.height}, nil\n+\t\treturn image.Config{\n+\t\t\tColorModel: color.YCbCrModel,\n+\t\t\tWidth:      d.width,\n+\t\t\tHeight:     d.height,\n+\t\t}, nil\n \t}\n \treturn image.Config{}, FormatError(\"missing SOF marker\")\n }"}, {"sha": "3322c09fe71a81ed685b6146e75082d6ed995ce4", "filename": "libgo/go/image/jpeg/writer.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -458,7 +458,7 @@ func (e *encoder) writeSOS(m image.Image) {\n \t\t\tfor i := 0; i < 4; i++ {\n \t\t\t\txOff := (i & 1) * 8\n \t\t\t\tyOff := (i & 2) * 4\n-\t\t\t\tp := image.Point{x + xOff, y + yOff}\n+\t\t\t\tp := image.Pt(x+xOff, y+yOff)\n \t\t\t\tif rgba != nil {\n \t\t\t\t\trgbaToYCbCr(rgba, p, &yBlock, &cbBlock[i], &crBlock[i])\n \t\t\t\t} else {"}, {"sha": "b8e8fa34e189ce97857f9e3c3a662a0b3288ded8", "filename": "libgo/go/image/jpeg/writer_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fjpeg%2Fwriter_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -54,14 +54,14 @@ func TestWriter(t *testing.T) {\n \t\t\tcontinue\n \t\t}\n \t\t// Encode that image as JPEG.\n-\t\tbuf := bytes.NewBuffer(nil)\n-\t\terr = Encode(buf, m0, &Options{Quality: tc.quality})\n+\t\tvar buf bytes.Buffer\n+\t\terr = Encode(&buf, m0, &Options{Quality: tc.quality})\n \t\tif err != nil {\n \t\t\tt.Error(tc.filename, err)\n \t\t\tcontinue\n \t\t}\n \t\t// Decode that JPEG.\n-\t\tm1, err := Decode(buf)\n+\t\tm1, err := Decode(&buf)\n \t\tif err != nil {\n \t\t\tt.Error(tc.filename, err)\n \t\t\tcontinue"}, {"sha": "55f634c17c1d73af843418e1941c392756d18571", "filename": "libgo/go/image/names.go", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fnames.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fnames.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fnames.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -50,26 +50,3 @@ func (c *Uniform) Opaque() bool {\n func NewUniform(c color.Color) *Uniform {\n \treturn &Uniform{c}\n }\n-\n-// Repeated is an infinite-sized Image that repeats another Image in both\n-// directions. Repeated{i, p}.At(x, y) will equal i.At(x+p.X, y+p.Y) for all\n-// points {x+p.X, y+p.Y} within i's Bounds.\n-type Repeated struct {\n-\tI      Image\n-\tOffset Point\n-}\n-\n-func (r *Repeated) ColorModel() color.Model {\n-\treturn r.I.ColorModel()\n-}\n-\n-func (r *Repeated) Bounds() Rectangle { return Rectangle{Point{-1e9, -1e9}, Point{1e9, 1e9}} }\n-\n-func (r *Repeated) At(x, y int) color.Color {\n-\tp := Point{x, y}.Add(r.Offset).Mod(r.I.Bounds())\n-\treturn r.I.At(p.X, p.Y)\n-}\n-\n-func NewRepeated(i Image, offset Point) *Repeated {\n-\treturn &Repeated{i, offset}\n-}"}, {"sha": "fe07d60a91adc5635588467f803c114a4a78f062", "filename": "libgo/go/image/png/reader.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fpng%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fpng%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Freader.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -690,7 +690,11 @@ func DecodeConfig(r io.Reader) (image.Config, error) {\n \tcase cbTCA16:\n \t\tcm = color.NRGBA64Model\n \t}\n-\treturn image.Config{cm, d.width, d.height}, nil\n+\treturn image.Config{\n+\t\tColorModel: cm,\n+\t\tWidth:      d.width,\n+\t\tHeight:     d.height,\n+\t}, nil\n }\n \n func init() {"}, {"sha": "286a3bc15db33393e0f8adb327671a78b191cf4c", "filename": "libgo/go/image/png/writer.go", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fpng%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fpng%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Fwriter.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -408,10 +408,7 @@ func (e *encoder) writeIDATs() {\n \t\treturn\n \t}\n \tvar bw *bufio.Writer\n-\tbw, e.err = bufio.NewWriterSize(e, 1<<15)\n-\tif e.err != nil {\n-\t\treturn\n-\t}\n+\tbw = bufio.NewWriterSize(e, 1<<15)\n \te.err = writeImage(bw, e.m, e.cb)\n \tif e.err != nil {\n \t\treturn"}, {"sha": "644c4fb44b39a6a9fb4732213fae53f32dcf2d6a", "filename": "libgo/go/image/png/writer_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fpng%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fimage%2Fpng%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Fwriter_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -35,12 +35,12 @@ func diff(m0, m1 image.Image) error {\n }\n \n func encodeDecode(m image.Image) (image.Image, error) {\n-\tb := bytes.NewBuffer(nil)\n-\terr := Encode(b, m)\n+\tvar b bytes.Buffer\n+\terr := Encode(&b, m)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tm, err = Decode(b)\n+\tm, err = Decode(&b)\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "ca3dd42a7c9157d2cd4c6775c91968c8867dd7f7", "filename": "libgo/go/image/testdata/video-001.bmp", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.bmp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.bmp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.bmp?ref=cd6368115dbd75d9187877097c48a0d8d4c04fd4"}, {"sha": "0dd6cd9313321bc05f1c51c113e8bd20326dcd1d", "filename": "libgo/go/image/testdata/video-001.tiff", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.tiff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.tiff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftestdata%2Fvideo-001.tiff?ref=cd6368115dbd75d9187877097c48a0d8d4c04fd4"}, {"sha": "27533c6047d5579eab29e4aad71db5dc558c0d08", "filename": "libgo/go/image/tiff/buffer.go", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftiff%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftiff%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Fbuffer.go?ref=cd6368115dbd75d9187877097c48a0d8d4c04fd4", "patch": "@@ -1,54 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package tiff\n-\n-import \"io\"\n-\n-// buffer buffers an io.Reader to satisfy io.ReaderAt.\n-type buffer struct {\n-\tr   io.Reader\n-\tbuf []byte\n-}\n-\n-func (b *buffer) ReadAt(p []byte, off int64) (int, error) {\n-\to := int(off)\n-\tend := o + len(p)\n-\tif int64(end) != off+int64(len(p)) {\n-\t\treturn 0, io.ErrUnexpectedEOF\n-\t}\n-\n-\tm := len(b.buf)\n-\tif end > m {\n-\t\tif end > cap(b.buf) {\n-\t\t\tnewcap := 1024\n-\t\t\tfor newcap < end {\n-\t\t\t\tnewcap *= 2\n-\t\t\t}\n-\t\t\tnewbuf := make([]byte, end, newcap)\n-\t\t\tcopy(newbuf, b.buf)\n-\t\t\tb.buf = newbuf\n-\t\t} else {\n-\t\t\tb.buf = b.buf[:end]\n-\t\t}\n-\t\tif n, err := io.ReadFull(b.r, b.buf[m:end]); err != nil {\n-\t\t\tend = m + n\n-\t\t\tb.buf = b.buf[:end]\n-\t\t\treturn copy(p, b.buf[o:end]), err\n-\t\t}\n-\t}\n-\n-\treturn copy(p, b.buf[o:end]), nil\n-}\n-\n-// newReaderAt converts an io.Reader into an io.ReaderAt.\n-func newReaderAt(r io.Reader) io.ReaderAt {\n-\tif ra, ok := r.(io.ReaderAt); ok {\n-\t\treturn ra\n-\t}\n-\treturn &buffer{\n-\t\tr:   r,\n-\t\tbuf: make([]byte, 0, 1024),\n-\t}\n-}"}, {"sha": "e13afb36192b2e71820dd0b187495dada9bea93e", "filename": "libgo/go/image/tiff/buffer_test.go", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftiff%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftiff%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Fbuffer_test.go?ref=cd6368115dbd75d9187877097c48a0d8d4c04fd4", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package tiff\n-\n-import (\n-\t\"io\"\n-\t\"strings\"\n-\t\"testing\"\n-)\n-\n-var readAtTests = []struct {\n-\tn   int\n-\toff int64\n-\ts   string\n-\terr error\n-}{\n-\t{2, 0, \"ab\", nil},\n-\t{6, 0, \"abcdef\", nil},\n-\t{3, 3, \"def\", nil},\n-\t{3, 5, \"f\", io.EOF},\n-\t{3, 6, \"\", io.EOF},\n-}\n-\n-func TestReadAt(t *testing.T) {\n-\tr := newReaderAt(strings.NewReader(\"abcdef\"))\n-\tb := make([]byte, 10)\n-\tfor _, test := range readAtTests {\n-\t\tn, err := r.ReadAt(b[:test.n], test.off)\n-\t\ts := string(b[:n])\n-\t\tif s != test.s || err != test.err {\n-\t\t\tt.Errorf(\"buffer.ReadAt(<%v bytes>, %v): got %v, %q; want %v, %q\", test.n, test.off, err, s, test.err, test.s)\n-\t\t}\n-\t}\n-}"}, {"sha": "40c7fd86c3001806423b1a7e26eeaec292d83470", "filename": "libgo/go/image/tiff/compress.go", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftiff%2Fcompress.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftiff%2Fcompress.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Fcompress.go?ref=cd6368115dbd75d9187877097c48a0d8d4c04fd4", "patch": "@@ -1,59 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package tiff\n-\n-import (\n-\t\"bufio\"\n-\t\"io\"\n-)\n-\n-type byteReader interface {\n-\tio.Reader\n-\tio.ByteReader\n-}\n-\n-// unpackBits decodes the PackBits-compressed data in src and returns the\n-// uncompressed data.\n-//\n-// The PackBits compression format is described in section 9 (p. 42)\n-// of the TIFF spec.\n-func unpackBits(r io.Reader) ([]byte, error) {\n-\tbuf := make([]byte, 128)\n-\tdst := make([]byte, 0, 1024)\n-\tbr, ok := r.(byteReader)\n-\tif !ok {\n-\t\tbr = bufio.NewReader(r)\n-\t}\n-\n-\tfor {\n-\t\tb, err := br.ReadByte()\n-\t\tif err != nil {\n-\t\t\tif err == io.EOF {\n-\t\t\t\treturn dst, nil\n-\t\t\t}\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tcode := int(int8(b))\n-\t\tswitch {\n-\t\tcase code >= 0:\n-\t\t\tn, err := io.ReadFull(br, buf[:code+1])\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t\tdst = append(dst, buf[:n]...)\n-\t\tcase code == -128:\n-\t\t\t// No-op.\n-\t\tdefault:\n-\t\t\tif b, err = br.ReadByte(); err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t\tfor j := 0; j < 1-code; j++ {\n-\t\t\t\tbuf[j] = b\n-\t\t\t}\n-\t\t\tdst = append(dst, buf[:1-code]...)\n-\t\t}\n-\t}\n-\tpanic(\"unreachable\")\n-}"}, {"sha": "169ba27721d3291c31677fc365c050a5e66dd8d1", "filename": "libgo/go/image/tiff/consts.go", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftiff%2Fconsts.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftiff%2Fconsts.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Fconsts.go?ref=cd6368115dbd75d9187877097c48a0d8d4c04fd4", "patch": "@@ -1,103 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package tiff\n-\n-// A tiff image file contains one or more images. The metadata\n-// of each image is contained in an Image File Directory (IFD),\n-// which contains entries of 12 bytes each and is described\n-// on page 14-16 of the specification. An IFD entry consists of\n-//\n-//  - a tag, which describes the signification of the entry,\n-//  - the data type and length of the entry,\n-//  - the data itself or a pointer to it if it is more than 4 bytes.\n-//\n-// The presence of a length means that each IFD is effectively an array.\n-\n-const (\n-\tleHeader = \"II\\x2A\\x00\" // Header for little-endian files.\n-\tbeHeader = \"MM\\x00\\x2A\" // Header for big-endian files.\n-\n-\tifdLen = 12 // Length of an IFD entry in bytes.\n-)\n-\n-// Data types (p. 14-16 of the spec).\n-const (\n-\tdtByte     = 1\n-\tdtASCII    = 2\n-\tdtShort    = 3\n-\tdtLong     = 4\n-\tdtRational = 5\n-)\n-\n-// The length of one instance of each data type in bytes.\n-var lengths = [...]uint32{0, 1, 1, 2, 4, 8}\n-\n-// Tags (see p. 28-41 of the spec).\n-const (\n-\ttImageWidth                = 256\n-\ttImageLength               = 257\n-\ttBitsPerSample             = 258\n-\ttCompression               = 259\n-\ttPhotometricInterpretation = 262\n-\n-\ttStripOffsets    = 273\n-\ttSamplesPerPixel = 277\n-\ttRowsPerStrip    = 278\n-\ttStripByteCounts = 279\n-\n-\ttXResolution    = 282\n-\ttYResolution    = 283\n-\ttResolutionUnit = 296\n-\n-\ttPredictor    = 317\n-\ttColorMap     = 320\n-\ttExtraSamples = 338\n-\ttSampleFormat = 339\n-)\n-\n-// Compression types (defined in various places in the spec and supplements).\n-const (\n-\tcNone       = 1\n-\tcCCITT      = 2\n-\tcG3         = 3 // Group 3 Fax.\n-\tcG4         = 4 // Group 4 Fax.\n-\tcLZW        = 5\n-\tcJPEGOld    = 6 // Superseded by cJPEG.\n-\tcJPEG       = 7\n-\tcDeflate    = 8 // zlib compression.\n-\tcPackBits   = 32773\n-\tcDeflateOld = 32946 // Superseded by cDeflate.\n-)\n-\n-// Photometric interpretation values (see p. 37 of the spec).\n-const (\n-\tpWhiteIsZero = 0\n-\tpBlackIsZero = 1\n-\tpRGB         = 2\n-\tpPaletted    = 3\n-\tpTransMask   = 4 // transparency mask\n-\tpCMYK        = 5\n-\tpYCbCr       = 6\n-\tpCIELab      = 8\n-)\n-\n-// Values for the tPredictor tag (page 64-65 of the spec).\n-const (\n-\tprNone       = 1\n-\tprHorizontal = 2\n-)\n-\n-// imageMode represents the mode of the image.\n-type imageMode int\n-\n-const (\n-\tmBilevel imageMode = iota\n-\tmPaletted\n-\tmGray\n-\tmGrayInvert\n-\tmRGB\n-\tmRGBA\n-\tmNRGBA\n-)"}, {"sha": "dc5a87a9fb93e1cb844dec1eeae8dfb901300000", "filename": "libgo/go/image/tiff/reader.go", "status": "removed", "additions": 0, "deletions": 430, "changes": 430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftiff%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftiff%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Freader.go?ref=cd6368115dbd75d9187877097c48a0d8d4c04fd4", "patch": "@@ -1,430 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Package tiff implements a TIFF image decoder.\n-//\n-// The TIFF specification is at http://partners.adobe.com/public/developer/en/tiff/TIFF6.pdf\n-package tiff\n-\n-import (\n-\t\"compress/lzw\"\n-\t\"compress/zlib\"\n-\t\"encoding/binary\"\n-\t\"image\"\n-\t\"image/color\"\n-\t\"io\"\n-\t\"io/ioutil\"\n-)\n-\n-// A FormatError reports that the input is not a valid TIFF image.\n-type FormatError string\n-\n-func (e FormatError) Error() string {\n-\treturn \"tiff: invalid format: \" + string(e)\n-}\n-\n-// An UnsupportedError reports that the input uses a valid but\n-// unimplemented feature.\n-type UnsupportedError string\n-\n-func (e UnsupportedError) Error() string {\n-\treturn \"tiff: unsupported feature: \" + string(e)\n-}\n-\n-// An InternalError reports that an internal error was encountered.\n-type InternalError string\n-\n-func (e InternalError) Error() string {\n-\treturn \"tiff: internal error: \" + string(e)\n-}\n-\n-type decoder struct {\n-\tr         io.ReaderAt\n-\tbyteOrder binary.ByteOrder\n-\tconfig    image.Config\n-\tmode      imageMode\n-\tfeatures  map[int][]uint\n-\tpalette   []color.Color\n-\n-\tbuf   []byte\n-\toff   int    // Current offset in buf.\n-\tv     uint32 // Buffer value for reading with arbitrary bit depths.\n-\tnbits uint   // Remaining number of bits in v.\n-}\n-\n-// firstVal returns the first uint of the features entry with the given tag,\n-// or 0 if the tag does not exist.\n-func (d *decoder) firstVal(tag int) uint {\n-\tf := d.features[tag]\n-\tif len(f) == 0 {\n-\t\treturn 0\n-\t}\n-\treturn f[0]\n-}\n-\n-// ifdUint decodes the IFD entry in p, which must be of the Byte, Short\n-// or Long type, and returns the decoded uint values.\n-func (d *decoder) ifdUint(p []byte) (u []uint, err error) {\n-\tvar raw []byte\n-\tdatatype := d.byteOrder.Uint16(p[2:4])\n-\tcount := d.byteOrder.Uint32(p[4:8])\n-\tif datalen := lengths[datatype] * count; datalen > 4 {\n-\t\t// The IFD contains a pointer to the real value.\n-\t\traw = make([]byte, datalen)\n-\t\t_, err = d.r.ReadAt(raw, int64(d.byteOrder.Uint32(p[8:12])))\n-\t} else {\n-\t\traw = p[8 : 8+datalen]\n-\t}\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tu = make([]uint, count)\n-\tswitch datatype {\n-\tcase dtByte:\n-\t\tfor i := uint32(0); i < count; i++ {\n-\t\t\tu[i] = uint(raw[i])\n-\t\t}\n-\tcase dtShort:\n-\t\tfor i := uint32(0); i < count; i++ {\n-\t\t\tu[i] = uint(d.byteOrder.Uint16(raw[2*i : 2*(i+1)]))\n-\t\t}\n-\tcase dtLong:\n-\t\tfor i := uint32(0); i < count; i++ {\n-\t\t\tu[i] = uint(d.byteOrder.Uint32(raw[4*i : 4*(i+1)]))\n-\t\t}\n-\tdefault:\n-\t\treturn nil, UnsupportedError(\"data type\")\n-\t}\n-\treturn u, nil\n-}\n-\n-// parseIFD decides whether the the IFD entry in p is \"interesting\" and\n-// stows away the data in the decoder.\n-func (d *decoder) parseIFD(p []byte) error {\n-\ttag := d.byteOrder.Uint16(p[0:2])\n-\tswitch tag {\n-\tcase tBitsPerSample,\n-\t\ttExtraSamples,\n-\t\ttPhotometricInterpretation,\n-\t\ttCompression,\n-\t\ttPredictor,\n-\t\ttStripOffsets,\n-\t\ttStripByteCounts,\n-\t\ttRowsPerStrip,\n-\t\ttImageLength,\n-\t\ttImageWidth:\n-\t\tval, err := d.ifdUint(p)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\td.features[int(tag)] = val\n-\tcase tColorMap:\n-\t\tval, err := d.ifdUint(p)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tnumcolors := len(val) / 3\n-\t\tif len(val)%3 != 0 || numcolors <= 0 || numcolors > 256 {\n-\t\t\treturn FormatError(\"bad ColorMap length\")\n-\t\t}\n-\t\td.palette = make([]color.Color, numcolors)\n-\t\tfor i := 0; i < numcolors; i++ {\n-\t\t\td.palette[i] = color.RGBA64{\n-\t\t\t\tuint16(val[i]),\n-\t\t\t\tuint16(val[i+numcolors]),\n-\t\t\t\tuint16(val[i+2*numcolors]),\n-\t\t\t\t0xffff,\n-\t\t\t}\n-\t\t}\n-\tcase tSampleFormat:\n-\t\t// Page 27 of the spec: If the SampleFormat is present and\n-\t\t// the value is not 1 [= unsigned integer data], a Baseline\n-\t\t// TIFF reader that cannot handle the SampleFormat value\n-\t\t// must terminate the import process gracefully.\n-\t\tval, err := d.ifdUint(p)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tfor _, v := range val {\n-\t\t\tif v != 1 {\n-\t\t\t\treturn UnsupportedError(\"sample format\")\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn nil\n-}\n-\n-// readBits reads n bits from the internal buffer starting at the current offset.\n-func (d *decoder) readBits(n uint) uint32 {\n-\tfor d.nbits < n {\n-\t\td.v <<= 8\n-\t\td.v |= uint32(d.buf[d.off])\n-\t\td.off++\n-\t\td.nbits += 8\n-\t}\n-\td.nbits -= n\n-\trv := d.v >> d.nbits\n-\td.v &^= rv << d.nbits\n-\treturn rv\n-}\n-\n-// flushBits discards the unread bits in the buffer used by readBits.\n-// It is used at the end of a line.\n-func (d *decoder) flushBits() {\n-\td.v = 0\n-\td.nbits = 0\n-}\n-\n-// decode decodes the raw data of an image.\n-// It reads from d.buf and writes the strip with ymin <= y < ymax into dst.\n-func (d *decoder) decode(dst image.Image, ymin, ymax int) error {\n-\td.off = 0\n-\n-\t// Apply horizontal predictor if necessary.\n-\t// In this case, p contains the color difference to the preceding pixel.\n-\t// See page 64-65 of the spec.\n-\tif d.firstVal(tPredictor) == prHorizontal && d.firstVal(tBitsPerSample) == 8 {\n-\t\tvar off int\n-\t\tspp := len(d.features[tBitsPerSample]) // samples per pixel\n-\t\tfor y := ymin; y < ymax; y++ {\n-\t\t\toff += spp\n-\t\t\tfor x := 0; x < (dst.Bounds().Dx()-1)*spp; x++ {\n-\t\t\t\td.buf[off] += d.buf[off-spp]\n-\t\t\t\toff++\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tswitch d.mode {\n-\tcase mGray, mGrayInvert:\n-\t\timg := dst.(*image.Gray)\n-\t\tbpp := d.firstVal(tBitsPerSample)\n-\t\tmax := uint32((1 << bpp) - 1)\n-\t\tfor y := ymin; y < ymax; y++ {\n-\t\t\tfor x := img.Rect.Min.X; x < img.Rect.Max.X; x++ {\n-\t\t\t\tv := uint8(d.readBits(bpp) * 0xff / max)\n-\t\t\t\tif d.mode == mGrayInvert {\n-\t\t\t\t\tv = 0xff - v\n-\t\t\t\t}\n-\t\t\t\timg.SetGray(x, y, color.Gray{v})\n-\t\t\t}\n-\t\t\td.flushBits()\n-\t\t}\n-\tcase mPaletted:\n-\t\timg := dst.(*image.Paletted)\n-\t\tbpp := d.firstVal(tBitsPerSample)\n-\t\tfor y := ymin; y < ymax; y++ {\n-\t\t\tfor x := img.Rect.Min.X; x < img.Rect.Max.X; x++ {\n-\t\t\t\timg.SetColorIndex(x, y, uint8(d.readBits(bpp)))\n-\t\t\t}\n-\t\t\td.flushBits()\n-\t\t}\n-\tcase mRGB:\n-\t\timg := dst.(*image.RGBA)\n-\t\tmin := img.PixOffset(0, ymin)\n-\t\tmax := img.PixOffset(0, ymax)\n-\t\tvar off int\n-\t\tfor i := min; i < max; i += 4 {\n-\t\t\timg.Pix[i+0] = d.buf[off+0]\n-\t\t\timg.Pix[i+1] = d.buf[off+1]\n-\t\t\timg.Pix[i+2] = d.buf[off+2]\n-\t\t\timg.Pix[i+3] = 0xff\n-\t\t\toff += 3\n-\t\t}\n-\tcase mNRGBA:\n-\t\timg := dst.(*image.NRGBA)\n-\t\tmin := img.PixOffset(0, ymin)\n-\t\tmax := img.PixOffset(0, ymax)\n-\t\tif len(d.buf) != max-min {\n-\t\t\treturn FormatError(\"short data strip\")\n-\t\t}\n-\t\tcopy(img.Pix[min:max], d.buf)\n-\tcase mRGBA:\n-\t\timg := dst.(*image.RGBA)\n-\t\tmin := img.PixOffset(0, ymin)\n-\t\tmax := img.PixOffset(0, ymax)\n-\t\tif len(d.buf) != max-min {\n-\t\t\treturn FormatError(\"short data strip\")\n-\t\t}\n-\t\tcopy(img.Pix[min:max], d.buf)\n-\t}\n-\n-\treturn nil\n-}\n-\n-func newDecoder(r io.Reader) (*decoder, error) {\n-\td := &decoder{\n-\t\tr:        newReaderAt(r),\n-\t\tfeatures: make(map[int][]uint),\n-\t}\n-\n-\tp := make([]byte, 8)\n-\tif _, err := d.r.ReadAt(p, 0); err != nil {\n-\t\treturn nil, err\n-\t}\n-\tswitch string(p[0:4]) {\n-\tcase leHeader:\n-\t\td.byteOrder = binary.LittleEndian\n-\tcase beHeader:\n-\t\td.byteOrder = binary.BigEndian\n-\tdefault:\n-\t\treturn nil, FormatError(\"malformed header\")\n-\t}\n-\n-\tifdOffset := int64(d.byteOrder.Uint32(p[4:8]))\n-\n-\t// The first two bytes contain the number of entries (12 bytes each).\n-\tif _, err := d.r.ReadAt(p[0:2], ifdOffset); err != nil {\n-\t\treturn nil, err\n-\t}\n-\tnumItems := int(d.byteOrder.Uint16(p[0:2]))\n-\n-\t// All IFD entries are read in one chunk.\n-\tp = make([]byte, ifdLen*numItems)\n-\tif _, err := d.r.ReadAt(p, ifdOffset+2); err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tfor i := 0; i < len(p); i += ifdLen {\n-\t\tif err := d.parseIFD(p[i : i+ifdLen]); err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t}\n-\n-\td.config.Width = int(d.firstVal(tImageWidth))\n-\td.config.Height = int(d.firstVal(tImageLength))\n-\n-\tif _, ok := d.features[tBitsPerSample]; !ok {\n-\t\treturn nil, FormatError(\"BitsPerSample tag missing\")\n-\t}\n-\n-\t// Determine the image mode.\n-\tswitch d.firstVal(tPhotometricInterpretation) {\n-\tcase pRGB:\n-\t\tfor _, b := range d.features[tBitsPerSample] {\n-\t\t\tif b != 8 {\n-\t\t\t\treturn nil, UnsupportedError(\"non-8-bit RGB image\")\n-\t\t\t}\n-\t\t}\n-\t\td.config.ColorModel = color.RGBAModel\n-\t\t// RGB images normally have 3 samples per pixel.\n-\t\t// If there are more, ExtraSamples (p. 31-32 of the spec)\n-\t\t// gives their meaning (usually an alpha channel).\n-\t\t//\n-\t\t// This implementation does not support extra samples\n-\t\t// of an unspecified type.\n-\t\tswitch len(d.features[tBitsPerSample]) {\n-\t\tcase 3:\n-\t\t\td.mode = mRGB\n-\t\tcase 4:\n-\t\t\tswitch d.firstVal(tExtraSamples) {\n-\t\t\tcase 1:\n-\t\t\t\td.mode = mRGBA\n-\t\t\tcase 2:\n-\t\t\t\td.mode = mNRGBA\n-\t\t\t\td.config.ColorModel = color.NRGBAModel\n-\t\t\tdefault:\n-\t\t\t\treturn nil, FormatError(\"wrong number of samples for RGB\")\n-\t\t\t}\n-\t\tdefault:\n-\t\t\treturn nil, FormatError(\"wrong number of samples for RGB\")\n-\t\t}\n-\tcase pPaletted:\n-\t\td.mode = mPaletted\n-\t\td.config.ColorModel = color.Palette(d.palette)\n-\tcase pWhiteIsZero:\n-\t\td.mode = mGrayInvert\n-\t\td.config.ColorModel = color.GrayModel\n-\tcase pBlackIsZero:\n-\t\td.mode = mGray\n-\t\td.config.ColorModel = color.GrayModel\n-\tdefault:\n-\t\treturn nil, UnsupportedError(\"color model\")\n-\t}\n-\n-\treturn d, nil\n-}\n-\n-// DecodeConfig returns the color model and dimensions of a TIFF image without\n-// decoding the entire image.\n-func DecodeConfig(r io.Reader) (image.Config, error) {\n-\td, err := newDecoder(r)\n-\tif err != nil {\n-\t\treturn image.Config{}, err\n-\t}\n-\treturn d.config, nil\n-}\n-\n-// Decode reads a TIFF image from r and returns it as an image.Image.\n-// The type of Image returned depends on the contents of the TIFF.\n-func Decode(r io.Reader) (img image.Image, err error) {\n-\td, err := newDecoder(r)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\t// Check if we have the right number of strips, offsets and counts.\n-\trps := int(d.firstVal(tRowsPerStrip))\n-\tif rps == 0 {\n-\t\t// Assume only one strip.\n-\t\trps = d.config.Height\n-\t}\n-\tnumStrips := (d.config.Height + rps - 1) / rps\n-\tif rps == 0 || len(d.features[tStripOffsets]) < numStrips || len(d.features[tStripByteCounts]) < numStrips {\n-\t\treturn nil, FormatError(\"inconsistent header\")\n-\t}\n-\n-\tswitch d.mode {\n-\tcase mGray, mGrayInvert:\n-\t\timg = image.NewGray(image.Rect(0, 0, d.config.Width, d.config.Height))\n-\tcase mPaletted:\n-\t\timg = image.NewPaletted(image.Rect(0, 0, d.config.Width, d.config.Height), d.palette)\n-\tcase mNRGBA:\n-\t\timg = image.NewNRGBA(image.Rect(0, 0, d.config.Width, d.config.Height))\n-\tcase mRGB, mRGBA:\n-\t\timg = image.NewRGBA(image.Rect(0, 0, d.config.Width, d.config.Height))\n-\t}\n-\n-\tfor i := 0; i < numStrips; i++ {\n-\t\tymin := i * rps\n-\t\t// The last strip may be shorter.\n-\t\tif i == numStrips-1 && d.config.Height%rps != 0 {\n-\t\t\trps = d.config.Height % rps\n-\t\t}\n-\t\toffset := int64(d.features[tStripOffsets][i])\n-\t\tn := int64(d.features[tStripByteCounts][i])\n-\t\tswitch d.firstVal(tCompression) {\n-\t\tcase cNone:\n-\t\t\t// TODO(bsiegert): Avoid copy if r is a tiff.buffer.\n-\t\t\td.buf = make([]byte, n)\n-\t\t\t_, err = d.r.ReadAt(d.buf, offset)\n-\t\tcase cLZW:\n-\t\t\tr := lzw.NewReader(io.NewSectionReader(d.r, offset, n), lzw.MSB, 8)\n-\t\t\td.buf, err = ioutil.ReadAll(r)\n-\t\t\tr.Close()\n-\t\tcase cDeflate, cDeflateOld:\n-\t\t\tr, err := zlib.NewReader(io.NewSectionReader(d.r, offset, n))\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t\td.buf, err = ioutil.ReadAll(r)\n-\t\t\tr.Close()\n-\t\tcase cPackBits:\n-\t\t\td.buf, err = unpackBits(io.NewSectionReader(d.r, offset, n))\n-\t\tdefault:\n-\t\t\terr = UnsupportedError(\"compression\")\n-\t\t}\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\terr = d.decode(img, ymin, ymin+rps)\n-\t}\n-\treturn\n-}\n-\n-func init() {\n-\timage.RegisterFormat(\"tiff\", leHeader, Decode, DecodeConfig)\n-\timage.RegisterFormat(\"tiff\", beHeader, Decode, DecodeConfig)\n-}"}, {"sha": "ee5dafd9962a75ed37b7fb6dc66587169a356b2a", "filename": "libgo/go/image/tiff/reader_test.go", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftiff%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftiff%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Freader_test.go?ref=cd6368115dbd75d9187877097c48a0d8d4c04fd4", "patch": "@@ -1,119 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package tiff\n-\n-import (\n-\t\"image\"\n-\t\"io/ioutil\"\n-\t\"os\"\n-\t\"strings\"\n-\t\"testing\"\n-)\n-\n-// Read makes *buffer implements io.Reader, so that we can pass one to Decode.\n-func (*buffer) Read([]byte) (int, error) {\n-\tpanic(\"unimplemented\")\n-}\n-\n-// TestNoRPS tries to decode an image that has no RowsPerStrip tag.\n-// The tag is mandatory according to the spec but some software omits\n-// it in the case of a single strip.\n-func TestNoRPS(t *testing.T) {\n-\tf, err := os.Open(\"testdata/no_rps.tiff\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tdefer f.Close()\n-\t_, err = Decode(f)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-}\n-\n-// TestUnpackBits tests the decoding of PackBits-encoded data.\n-func TestUnpackBits(t *testing.T) {\n-\tvar unpackBitsTests = []struct {\n-\t\tcompressed   string\n-\t\tuncompressed string\n-\t}{{\n-\t\t// Example data from Wikipedia.\n-\t\t\"\\xfe\\xaa\\x02\\x80\\x00\\x2a\\xfd\\xaa\\x03\\x80\\x00\\x2a\\x22\\xf7\\xaa\",\n-\t\t\"\\xaa\\xaa\\xaa\\x80\\x00\\x2a\\xaa\\xaa\\xaa\\xaa\\x80\\x00\\x2a\\x22\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\",\n-\t}}\n-\tfor _, u := range unpackBitsTests {\n-\t\tbuf, err := unpackBits(strings.NewReader(u.compressed))\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\t\tif string(buf) != u.uncompressed {\n-\t\t\tt.Fatalf(\"unpackBits: want %x, got %x\", u.uncompressed, buf)\n-\t\t}\n-\t}\n-}\n-\n-// TestDecompress tests that decoding some TIFF images that use different\n-// compression formats result in the same pixel data.\n-func TestDecompress(t *testing.T) {\n-\tvar decompressTests = []string{\n-\t\t\"bw-uncompressed.tiff\",\n-\t\t\"bw-deflate.tiff\",\n-\t\t\"bw-packbits.tiff\",\n-\t}\n-\tvar img0 image.Image\n-\tfor _, name := range decompressTests {\n-\t\tf, err := os.Open(\"testdata/\" + name)\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\t\tdefer f.Close()\n-\t\tif img0 == nil {\n-\t\t\timg0, err = Decode(f)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatalf(\"decoding %s: %v\", name, err)\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\timg1, err := Decode(f)\n-\t\tif err != nil {\n-\t\t\tt.Fatalf(\"decoding %s: %v\", name, err)\n-\t\t}\n-\t\tb := img1.Bounds()\n-\t\t// Compare images.\n-\t\tif !b.Eq(img0.Bounds()) {\n-\t\t\tt.Fatalf(\"wrong image size: want %s, got %s\", img0.Bounds(), b)\n-\t\t}\n-\t\tfor y := b.Min.Y; y < b.Max.Y; y++ {\n-\t\t\tfor x := b.Min.X; x < b.Max.X; x++ {\n-\t\t\t\tc0 := img0.At(x, y)\n-\t\t\t\tc1 := img1.At(x, y)\n-\t\t\t\tr0, g0, b0, a0 := c0.RGBA()\n-\t\t\t\tr1, g1, b1, a1 := c1.RGBA()\n-\t\t\t\tif r0 != r1 || g0 != g1 || b0 != b1 || a0 != a1 {\n-\t\t\t\t\tt.Fatalf(\"pixel at (%d, %d) has wrong color: want %v, got %v\", x, y, c0, c1)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-const filename = \"testdata/video-001-uncompressed.tiff\"\n-\n-// BenchmarkDecode benchmarks the decoding of an image.\n-func BenchmarkDecode(b *testing.B) {\n-\tb.StopTimer()\n-\tcontents, err := ioutil.ReadFile(filename)\n-\tif err != nil {\n-\t\tpanic(err)\n-\t}\n-\tr := &buffer{buf: contents}\n-\tb.StartTimer()\n-\tfor i := 0; i < b.N; i++ {\n-\t\t_, err := Decode(r)\n-\t\tif err != nil {\n-\t\t\tb.Fatal(\"Decode:\", err)\n-\t\t}\n-\t}\n-}"}, {"sha": "137a0c3ef1f669b7c51a5d437160e6784675e68c", "filename": "libgo/go/image/tiff/testdata/bw-deflate.tiff", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fbw-deflate.tiff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fbw-deflate.tiff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fbw-deflate.tiff?ref=cd6368115dbd75d9187877097c48a0d8d4c04fd4"}, {"sha": "d59fa4aeed32c855d74bec465904dd7474243fd0", "filename": "libgo/go/image/tiff/testdata/bw-packbits.tiff", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fbw-packbits.tiff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fbw-packbits.tiff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fbw-packbits.tiff?ref=cd6368115dbd75d9187877097c48a0d8d4c04fd4"}, {"sha": "8390f11357f9c3b38464b17a08d4cdd111b7d5ce", "filename": "libgo/go/image/tiff/testdata/bw-uncompressed.tiff", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fbw-uncompressed.tiff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fbw-uncompressed.tiff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fbw-uncompressed.tiff?ref=cd6368115dbd75d9187877097c48a0d8d4c04fd4"}, {"sha": "3280cf8e344b0ff0b6b98a1c3ca0029174eb82ef", "filename": "libgo/go/image/tiff/testdata/no_rps.tiff", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fno_rps.tiff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fno_rps.tiff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fno_rps.tiff?ref=cd6368115dbd75d9187877097c48a0d8d4c04fd4"}, {"sha": "fad147107b25464111b7b34d7728e99f84fe522a", "filename": "libgo/go/image/tiff/testdata/video-001-uncompressed.tiff", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fvideo-001-uncompressed.tiff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd6368115dbd75d9187877097c48a0d8d4c04fd4/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fvideo-001-uncompressed.tiff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Ftestdata%2Fvideo-001-uncompressed.tiff?ref=cd6368115dbd75d9187877097c48a0d8d4c04fd4"}, {"sha": "bbfa6c2b2aadf71a0053bcb3c670bc3a500f5528", "filename": "libgo/go/io/io.go", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fio%2Fio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fio%2Fio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fio.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -8,30 +8,27 @@\n // abstract the functionality, plus some other related primitives.\n package io\n \n-// Error represents an unexpected I/O behavior.\n-type Error struct {\n-\tErrorString string\n-}\n-\n-func (err *Error) Error() string { return err.ErrorString }\n+import (\n+\t\"errors\"\n+)\n \n // ErrShortWrite means that a write accepted fewer bytes than requested\n // but failed to return an explicit error.\n-var ErrShortWrite error = &Error{\"short write\"}\n+var ErrShortWrite = errors.New(\"short write\")\n \n // ErrShortBuffer means that a read required a longer buffer than was provided.\n-var ErrShortBuffer error = &Error{\"short buffer\"}\n+var ErrShortBuffer = errors.New(\"short buffer\")\n \n // EOF is the error returned by Read when no more input is available.\n // Functions should return EOF only to signal a graceful end of input.\n // If the EOF occurs unexpectedly in a structured data stream,\n // the appropriate error is either ErrUnexpectedEOF or some other error\n // giving more detail.\n-var EOF error = &Error{\"EOF\"}\n+var EOF = errors.New(\"EOF\")\n \n // ErrUnexpectedEOF means that EOF was encountered in the\n // middle of reading a fixed-size block or data structure.\n-var ErrUnexpectedEOF error = &Error{\"unexpected EOF\"}\n+var ErrUnexpectedEOF = errors.New(\"unexpected EOF\")\n \n // Reader is the interface that wraps the basic Read method.\n //\n@@ -220,6 +217,7 @@ type stringWriter interface {\n }\n \n // WriteString writes the contents of the string s to w, which accepts an array of bytes.\n+// If w already implements a WriteString method, it is invoked directly.\n func WriteString(w Writer, s string) (n int, err error) {\n \tif sw, ok := w.(stringWriter); ok {\n \t\treturn sw.WriteString(s)\n@@ -268,7 +266,7 @@ func ReadFull(r Reader, buf []byte) (n int, err error) {\n // (including EOF), so can CopyN.\n //\n // If dst implements the ReaderFrom interface,\n-// the copy is implemented by calling dst.ReadFrom(src).\n+// the copy is implemented using it.\n func CopyN(dst Writer, src Reader, n int64) (written int64, err error) {\n \t// If the writer has a ReadFrom method, use it to do the copy.\n \t// Avoids a buffer allocation and a copy.\n@@ -411,8 +409,8 @@ func (s *SectionReader) Read(p []byte) (n int, err error) {\n \treturn\n }\n \n-var errWhence = &Error{\"Seek: invalid whence\"}\n-var errOffset = &Error{\"Seek: invalid offset\"}\n+var errWhence = errors.New(\"Seek: invalid whence\")\n+var errOffset = errors.New(\"Seek: invalid offset\")\n \n func (s *SectionReader) Seek(offset int64, whence int) (ret int64, err error) {\n \tswitch whence {"}, {"sha": "180afc2c221459f39a4d20d89b55e3540d8efb79", "filename": "libgo/go/io/ioutil/ioutil.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -34,11 +34,17 @@ func readAll(r io.Reader, capacity int64) (b []byte, err error) {\n }\n \n // ReadAll reads from r until an error or EOF and returns the data it read.\n+// A successful call returns err == nil, not err == EOF. Because ReadAll is\n+// defined to read from src until EOF, it does not treat an EOF from Read\n+// as an error to be reported.\n func ReadAll(r io.Reader) ([]byte, error) {\n \treturn readAll(r, bytes.MinRead)\n }\n \n // ReadFile reads the file named by filename and returns the contents.\n+// A successful call returns err == nil, not err == EOF. Because ReadFile\n+// reads the whole file, it does not treat an EOF from Read as an error\n+// to be reported.\n func ReadFile(filename string) ([]byte, error) {\n \tf, err := os.Open(filename)\n \tif err != nil {"}, {"sha": "cf05e0c1ad7e3b5fb1a906942c7583a768a12bd8", "filename": "libgo/go/io/pipe.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fio%2Fpipe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fio%2Fpipe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fpipe.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -7,10 +7,13 @@\n \n package io\n \n-import \"sync\"\n+import (\n+\t\"errors\"\n+\t\"sync\"\n+)\n \n // ErrClosedPipe is the error used for read or write operations on a closed pipe.\n-var ErrClosedPipe = &Error{\"io: read/write on closed pipe\"}\n+var ErrClosedPipe = errors.New(\"io: read/write on closed pipe\")\n \n type pipeResult struct {\n \tn   int"}, {"sha": "c6c8645e1ae81c631d3ceed0c6f2a6cd8fd8bef8", "filename": "libgo/go/math/acosh.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Facosh.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Facosh.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Facosh.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -44,11 +44,9 @@ func Acosh(x float64) float64 {\n \t\tLn2   = 6.93147180559945286227e-01 // 0x3FE62E42FEFA39EF\n \t\tLarge = 1 << 28                    // 2**28\n \t)\n-\t// TODO(rsc): Remove manual inlining of IsNaN\n-\t// when compiler does it for us\n \t// first case is special case\n \tswitch {\n-\tcase x < 1 || x != x: // x < 1 || IsNaN(x):\n+\tcase x < 1 || IsNaN(x):\n \t\treturn NaN()\n \tcase x == 1:\n \t\treturn 0"}, {"sha": "0defbb9bef26c7f4c2ffb39c76436e5b1346a169", "filename": "libgo/go/math/asinh.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fasinh.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fasinh.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fasinh.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -42,10 +42,8 @@ func Asinh(x float64) float64 {\n \t\tNearZero = 1.0 / (1 << 28)            // 2**-28\n \t\tLarge    = 1 << 28                    // 2**28\n \t)\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n-\tif x != x || x > MaxFloat64 || x < -MaxFloat64 { // IsNaN(x) || IsInf(x, 0)\n+\tif IsNaN(x) || IsInf(x, 0) {\n \t\treturn x\n \t}\n \tsign := false"}, {"sha": "48ed9a986b89723779de81ba282070b1e414844e", "filename": "libgo/go/math/atan2.go", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fatan2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fatan2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fatan2.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -35,11 +35,9 @@ func Atan2(y, x float64) float64 {\n }\n \n func atan2(y, x float64) float64 {\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n-\tcase y != y || x != x: // IsNaN(y) || IsNaN(x):\n+\tcase IsNaN(y) || IsNaN(x):\n \t\treturn NaN()\n \tcase y == 0:\n \t\tif x >= 0 && !Signbit(x) {\n@@ -48,22 +46,22 @@ func atan2(y, x float64) float64 {\n \t\treturn Copysign(Pi, y)\n \tcase x == 0:\n \t\treturn Copysign(Pi/2, y)\n-\tcase x < -MaxFloat64 || x > MaxFloat64: // IsInf(x, 0):\n-\t\tif x > MaxFloat64 { // IsInf(x, 1) {\n+\tcase IsInf(x, 0):\n+\t\tif IsInf(x, 1) {\n \t\t\tswitch {\n-\t\t\tcase y < -MaxFloat64 || y > MaxFloat64: // IsInf(y, -1) || IsInf(y, 1):\n+\t\t\tcase IsInf(y, 0):\n \t\t\t\treturn Copysign(Pi/4, y)\n \t\t\tdefault:\n \t\t\t\treturn Copysign(0, y)\n \t\t\t}\n \t\t}\n \t\tswitch {\n-\t\tcase y < -MaxFloat64 || y > MaxFloat64: // IsInf(y, -1) || IsInf(y, 1):\n+\t\tcase IsInf(y, 0):\n \t\t\treturn Copysign(3*Pi/4, y)\n \t\tdefault:\n \t\t\treturn Copysign(Pi, y)\n \t\t}\n-\tcase y < -MaxFloat64 || y > MaxFloat64: //IsInf(y, 0):\n+\tcase IsInf(y, 0):\n \t\treturn Copysign(Pi/2, y)\n \t}\n "}, {"sha": "5b5d468559bd066e658628e0db86bcdec3d3d3b4", "filename": "libgo/go/math/atanh.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fatanh.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fatanh.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fatanh.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -46,11 +46,9 @@ package math\n //\tAtanh(NaN) = NaN\n func Atanh(x float64) float64 {\n \tconst NearZero = 1.0 / (1 << 28) // 2**-28\n-\t// TODO(rsc): Remove manual inlining of IsNaN\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n-\tcase x < -1 || x > 1 || x != x: // x < -1 || x > 1 || IsNaN(x):\n+\tcase x < -1 || x > 1 || IsNaN(x):\n \t\treturn NaN()\n \tcase x == 1:\n \t\treturn Inf(1)"}, {"sha": "306bf0ac65bcad7e58d44031c60996913f4de1ab", "filename": "libgo/go/math/big/arith.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fbig%2Farith.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fbig%2Farith.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Farith.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -8,8 +8,7 @@\n \n package big\n \n-// TODO(gri) Decide if Word needs to remain exported.\n-\n+// A Word represents a single digit of a multi-precision unsigned integer.\n type Word uintptr\n \n const ("}, {"sha": "cd2cd0e2da0bcff313bec421e11b827ecbeb3365", "filename": "libgo/go/math/big/int.go", "status": "modified", "additions": 53, "deletions": 30, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fbig%2Fint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fbig%2Fint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fint.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -65,6 +65,26 @@ func (z *Int) Set(x *Int) *Int {\n \treturn z\n }\n \n+// Bits provides raw (unchecked but fast) access to x by returning its\n+// absolute value as a little-endian Word slice. The result and x share\n+// the same underlying array.\n+// Bits is intended to support implementation of missing low-level Int\n+// functionality outside this package; it should be avoided otherwise.\n+func (x *Int) Bits() []Word {\n+\treturn x.abs\n+}\n+\n+// SetBits provides raw (unchecked but fast) access to z by setting its\n+// value to abs, interpreted as a little-endian Word slice, and returning\n+// z. The result and abs share the same underlying array.\n+// SetBits is intended to support implementation of missing low-level Int\n+// functionality outside this package; it should be avoided otherwise.\n+func (z *Int) SetBits(abs []Word) *Int {\n+\tz.abs = nat(abs).norm()\n+\tz.neg = false\n+\treturn z\n+}\n+\n // Abs sets z to |x| (the absolute value of x) and returns z.\n func (z *Int) Abs(x *Int) *Int {\n \tz.Set(x)\n@@ -191,6 +211,7 @@ func (z *Int) Rem(x, y *Int) *Int {\n //\tr = x - y*q\n //\n // (See Daan Leijen, ``Division and Modulus for Computer Scientists''.)\n+// See DivMod for Euclidean division and modulus (unlike Go).\n //\n func (z *Int) QuoRem(x, y, r *Int) (*Int, *Int) {\n \tz.abs, r.abs = z.abs.div(r.abs, x.abs, y.abs)\n@@ -248,6 +269,7 @@ func (z *Int) Mod(x, y *Int) *Int {\n // div and mod''. ACM Transactions on Programming Languages and\n // Systems (TOPLAS), 14(2):127-144, New York, NY, USA, 4/1992.\n // ACM press.)\n+// See QuoRem for T-division and modulus (like Go).\n //\n func (z *Int) DivMod(x, y, m *Int) (*Int, *Int) {\n \ty0 := y // save y\n@@ -528,18 +550,18 @@ func (z *Int) SetBytes(buf []byte) *Int {\n }\n \n // Bytes returns the absolute value of z as a big-endian byte slice.\n-func (z *Int) Bytes() []byte {\n-\tbuf := make([]byte, len(z.abs)*_S)\n-\treturn buf[z.abs.bytes(buf):]\n+func (x *Int) Bytes() []byte {\n+\tbuf := make([]byte, len(x.abs)*_S)\n+\treturn buf[x.abs.bytes(buf):]\n }\n \n // BitLen returns the length of the absolute value of z in bits.\n // The bit length of 0 is 0.\n-func (z *Int) BitLen() int {\n-\treturn z.abs.bitLen()\n+func (x *Int) BitLen() int {\n+\treturn x.abs.bitLen()\n }\n \n-// Exp sets z = x**y mod m. If m is nil, z = x**y.\n+// Exp sets z = x**y mod m and returns z. If m is nil, z = x**y.\n // See Knuth, volume 2, section 4.6.3.\n func (z *Int) Exp(x, y, m *Int) *Int {\n \tif y.neg || len(y.abs) == 0 {\n@@ -559,20 +581,20 @@ func (z *Int) Exp(x, y, m *Int) *Int {\n \treturn z\n }\n \n-// GcdInt sets d to the greatest common divisor of a and b, which must be\n-// positive numbers.\n-// If x and y are not nil, GcdInt sets x and y such that d = a*x + b*y.\n-// If either a or b is not positive, GcdInt sets d = x = y = 0.\n-func GcdInt(d, x, y, a, b *Int) {\n+// GCD sets z to the greatest common divisor of a and b, which must be\n+// positive numbers, and returns z.\n+// If x and y are not nil, GCD sets x and y such that z = a*x + b*y.\n+// If either a or b is not positive, GCD sets z = x = y = 0.\n+func (z *Int) GCD(x, y, a, b *Int) *Int {\n \tif a.neg || b.neg {\n-\t\td.SetInt64(0)\n+\t\tz.SetInt64(0)\n \t\tif x != nil {\n \t\t\tx.SetInt64(0)\n \t\t}\n \t\tif y != nil {\n \t\t\ty.SetInt64(0)\n \t\t}\n-\t\treturn\n+\t\treturn z\n \t}\n \n \tA := new(Int).Set(a)\n@@ -614,14 +636,15 @@ func GcdInt(d, x, y, a, b *Int) {\n \t\t*y = *lastY\n \t}\n \n-\t*d = *A\n+\t*z = *A\n+\treturn z\n }\n \n-// ProbablyPrime performs n Miller-Rabin tests to check whether z is prime.\n-// If it returns true, z is prime with probability 1 - 1/4^n.\n-// If it returns false, z is not prime.\n-func ProbablyPrime(z *Int, n int) bool {\n-\treturn !z.neg && z.abs.probablyPrime(n)\n+// ProbablyPrime performs n Miller-Rabin tests to check whether x is prime.\n+// If it returns true, x is prime with probability 1 - 1/4^n.\n+// If it returns false, x is not prime.\n+func (x *Int) ProbablyPrime(n int) bool {\n+\treturn !x.neg && x.abs.probablyPrime(n)\n }\n \n // Rand sets z to a pseudo-random number in [0, n) and returns z.\n@@ -639,7 +662,7 @@ func (z *Int) Rand(rnd *rand.Rand, n *Int) *Int {\n // p is a prime) and returns z.\n func (z *Int) ModInverse(g, p *Int) *Int {\n \tvar d Int\n-\tGcdInt(&d, z, nil, g, p)\n+\td.GCD(z, nil, g, p)\n \t// x and y are such that g*x + p*y = d. Since p is prime, d = 1. Taking\n \t// that modulo p results in g*x = 1, therefore x is the inverse element.\n \tif z.neg {\n@@ -671,18 +694,18 @@ func (z *Int) Rsh(x *Int, n uint) *Int {\n \treturn z\n }\n \n-// Bit returns the value of the i'th bit of z. That is, it\n-// returns (z>>i)&1. The bit index i must be >= 0.\n-func (z *Int) Bit(i int) uint {\n+// Bit returns the value of the i'th bit of x. That is, it\n+// returns (x>>i)&1. The bit index i must be >= 0.\n+func (x *Int) Bit(i int) uint {\n \tif i < 0 {\n \t\tpanic(\"negative bit index\")\n \t}\n-\tif z.neg {\n-\t\tt := nat(nil).sub(z.abs, natOne)\n+\tif x.neg {\n+\t\tt := nat(nil).sub(x.abs, natOne)\n \t\treturn t.bit(uint(i)) ^ 1\n \t}\n \n-\treturn z.abs.bit(uint(i))\n+\treturn x.abs.bit(uint(i))\n }\n \n // SetBit sets z to x, with x's i'th bit set to b (0 or 1).\n@@ -847,11 +870,11 @@ func (z *Int) Not(x *Int) *Int {\n const intGobVersion byte = 1\n \n // GobEncode implements the gob.GobEncoder interface.\n-func (z *Int) GobEncode() ([]byte, error) {\n-\tbuf := make([]byte, 1+len(z.abs)*_S) // extra byte for version and sign bit\n-\ti := z.abs.bytes(buf) - 1            // i >= 0\n+func (x *Int) GobEncode() ([]byte, error) {\n+\tbuf := make([]byte, 1+len(x.abs)*_S) // extra byte for version and sign bit\n+\ti := x.abs.bytes(buf) - 1            // i >= 0\n \tb := intGobVersion << 1              // make space for sign bit\n-\tif z.neg {\n+\tif x.neg {\n \t\tb |= 1\n \t}\n \tbuf[i] = b"}, {"sha": "9700a9b5a7ce875e206893093d61d6075958fa32", "filename": "libgo/go/math/big/int_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fint_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -824,7 +824,7 @@ func checkGcd(aBytes, bBytes []byte) bool {\n \ty := new(Int)\n \td := new(Int)\n \n-\tGcdInt(d, x, y, a, b)\n+\td.GCD(x, y, a, b)\n \tx.Mul(x, a)\n \ty.Mul(y, b)\n \tx.Add(x, y)\n@@ -852,7 +852,7 @@ func TestGcd(t *testing.T) {\n \t\texpectedY := NewInt(test.y)\n \t\texpectedD := NewInt(test.d)\n \n-\t\tGcdInt(d, x, y, a, b)\n+\t\td.GCD(x, y, a, b)\n \n \t\tif expectedX.Cmp(x) != 0 ||\n \t\t\texpectedY.Cmp(y) != 0 ||\n@@ -903,14 +903,14 @@ func TestProbablyPrime(t *testing.T) {\n \t}\n \tfor i, s := range primes {\n \t\tp, _ := new(Int).SetString(s, 10)\n-\t\tif !ProbablyPrime(p, nreps) {\n+\t\tif !p.ProbablyPrime(nreps) {\n \t\t\tt.Errorf(\"#%d prime found to be non-prime (%s)\", i, s)\n \t\t}\n \t}\n \n \tfor i, s := range composites {\n \t\tc, _ := new(Int).SetString(s, 10)\n-\t\tif ProbablyPrime(c, nreps) {\n+\t\tif c.ProbablyPrime(nreps) {\n \t\t\tt.Errorf(\"#%d composite found to be prime (%s)\", i, s)\n \t\t}\n \t\tif testing.Short() {"}, {"sha": "6e1c7ffde4efded972547353485dd01005bea77c", "filename": "libgo/go/math/big/nat.go", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -8,9 +8,15 @@\n //\t- Int\tsigned integers\n //\t- Rat\trational numbers\n //\n-// All methods on Int take the result as the receiver; if it is one\n-// of the operands it may be overwritten (and its memory reused).\n-// To enable chaining of operations, the result is also returned.\n+// Methods are typically of the form:\n+//\n+//\tfunc (z *Int) Op(x, y *Int) *Int\t(similar for *Rat)\n+//\n+// and implement operations z = x Op y with the result as receiver; if it\n+// is one of the operands it may be overwritten (and its memory reused).\n+// To enable chaining of operations, the result is also returned. Methods\n+// returning a result other than *Int or *Rat take one of the operands as\n+// the receiver.\n //\n package big\n "}, {"sha": "7bd83fc0fb2820b688f0e23c5c648ad104d6d748", "filename": "libgo/go/math/big/rat.go", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fbig%2Frat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fbig%2Frat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Frat.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -328,48 +328,48 @@ func (z *Rat) SetString(s string) (*Rat, bool) {\n }\n \n // String returns a string representation of z in the form \"a/b\" (even if b == 1).\n-func (z *Rat) String() string {\n+func (x *Rat) String() string {\n \ts := \"/1\"\n-\tif len(z.b) != 0 {\n-\t\ts = \"/\" + z.b.decimalString()\n+\tif len(x.b) != 0 {\n+\t\ts = \"/\" + x.b.decimalString()\n \t}\n-\treturn z.a.String() + s\n+\treturn x.a.String() + s\n }\n \n // RatString returns a string representation of z in the form \"a/b\" if b != 1,\n // and in the form \"a\" if b == 1.\n-func (z *Rat) RatString() string {\n-\tif z.IsInt() {\n-\t\treturn z.a.String()\n+func (x *Rat) RatString() string {\n+\tif x.IsInt() {\n+\t\treturn x.a.String()\n \t}\n-\treturn z.String()\n+\treturn x.String()\n }\n \n // FloatString returns a string representation of z in decimal form with prec\n // digits of precision after the decimal point and the last digit rounded.\n-func (z *Rat) FloatString(prec int) string {\n-\tif z.IsInt() {\n-\t\ts := z.a.String()\n+func (x *Rat) FloatString(prec int) string {\n+\tif x.IsInt() {\n+\t\ts := x.a.String()\n \t\tif prec > 0 {\n \t\t\ts += \".\" + strings.Repeat(\"0\", prec)\n \t\t}\n \t\treturn s\n \t}\n-\t// z.b != 0\n+\t// x.b != 0\n \n-\tq, r := nat(nil).div(nat(nil), z.a.abs, z.b)\n+\tq, r := nat(nil).div(nat(nil), x.a.abs, x.b)\n \n \tp := natOne\n \tif prec > 0 {\n \t\tp = nat(nil).expNN(natTen, nat(nil).setUint64(uint64(prec)), nil)\n \t}\n \n \tr = r.mul(r, p)\n-\tr, r2 := r.div(nat(nil), r, z.b)\n+\tr, r2 := r.div(nat(nil), r, x.b)\n \n \t// see if we need to round up\n \tr2 = r2.add(r2, r2)\n-\tif z.b.cmp(r2) <= 0 {\n+\tif x.b.cmp(r2) <= 0 {\n \t\tr = r.add(r, natOne)\n \t\tif r.cmp(p) >= 0 {\n \t\t\tq = nat(nil).add(q, natOne)\n@@ -378,7 +378,7 @@ func (z *Rat) FloatString(prec int) string {\n \t}\n \n \ts := q.decimalString()\n-\tif z.a.neg {\n+\tif x.a.neg {\n \t\ts = \"-\" + s\n \t}\n \n@@ -395,10 +395,10 @@ func (z *Rat) FloatString(prec int) string {\n const ratGobVersion byte = 1\n \n // GobEncode implements the gob.GobEncoder interface.\n-func (z *Rat) GobEncode() ([]byte, error) {\n-\tbuf := make([]byte, 1+4+(len(z.a.abs)+len(z.b))*_S) // extra bytes for version and sign bit (1), and numerator length (4)\n-\ti := z.b.bytes(buf)\n-\tj := z.a.abs.bytes(buf[0:i])\n+func (x *Rat) GobEncode() ([]byte, error) {\n+\tbuf := make([]byte, 1+4+(len(x.a.abs)+len(x.b))*_S) // extra bytes for version and sign bit (1), and numerator length (4)\n+\ti := x.b.bytes(buf)\n+\tj := x.a.abs.bytes(buf[0:i])\n \tn := i - j\n \tif int(uint32(n)) != n {\n \t\t// this should never happen\n@@ -407,7 +407,7 @@ func (z *Rat) GobEncode() ([]byte, error) {\n \tbinary.BigEndian.PutUint32(buf[j-4:j], uint32(n))\n \tj -= 1 + 4\n \tb := ratGobVersion << 1 // make space for sign bit\n-\tif z.a.neg {\n+\tif x.a.neg {\n \t\tb |= 1\n \t}\n \tbuf[j] = b"}, {"sha": "8c43f0afbc8858f997d481741cca63fb345573a8", "filename": "libgo/go/math/cbrt.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fcbrt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fcbrt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fcbrt.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -33,11 +33,9 @@ func Cbrt(x float64) float64 {\n \t\tC3 = 6.46502159e-02\n \t\tC4 = 1.412333954e-01\n \t)\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n-\tcase x == 0 || x != x || x < -MaxFloat64 || x > MaxFloat64: // x == 0 || IsNaN(x) || IsInf(x, 0):\n+\tcase x == 0 || IsNaN(x) || IsInf(x, 0):\n \t\treturn x\n \t}\n \tsign := false"}, {"sha": "37ab5388073b97cc71b4d7d602fdc595d98a40fd", "filename": "libgo/go/math/dim.go", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fdim.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fdim.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fdim.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -30,13 +30,11 @@ func Max(x, y float64) float64 {\n }\n \n func max(x, y float64) float64 {\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n-\tcase x > MaxFloat64 || y > MaxFloat64: // IsInf(x, 1) || IsInf(y, 1):\n+\tcase IsInf(x, 1) || IsInf(y, 1):\n \t\treturn Inf(1)\n-\tcase x != x || y != y: // IsNaN(x) || IsNaN(y):\n+\tcase IsNaN(x) || IsNaN(y):\n \t\treturn NaN()\n \tcase x == 0 && x == y:\n \t\tif Signbit(x) {\n@@ -61,13 +59,11 @@ func Min(x, y float64) float64 {\n }\n \n func min(x, y float64) float64 {\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n-\tcase x < -MaxFloat64 || y < -MaxFloat64: // IsInf(x, -1) || IsInf(y, -1):\n+\tcase IsInf(x, -1) || IsInf(y, -1):\n \t\treturn Inf(-1)\n-\tcase x != x || y != y: // IsNaN(x) || IsNaN(y):\n+\tcase IsNaN(x) || IsNaN(y):\n \t\treturn NaN()\n \tcase x == 0 && x == y:\n \t\tif Signbit(x) {"}, {"sha": "87c70c2512f616a869d911d4996b35650eb0369e", "filename": "libgo/go/math/erf.go", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Ferf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Ferf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Ferf.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -191,14 +191,12 @@ func Erf(x float64) float64 {\n \t\tSmall    = 1.0 / (1 << 28)        // 2**-28\n \t)\n \t// special cases\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \tswitch {\n-\tcase x != x: // IsNaN(x):\n+\tcase IsNaN(x):\n \t\treturn NaN()\n-\tcase x > MaxFloat64: // IsInf(x, 1):\n+\tcase IsInf(x, 1):\n \t\treturn 1\n-\tcase x < -MaxFloat64: // IsInf(x, -1):\n+\tcase IsInf(x, -1):\n \t\treturn -1\n \t}\n \tsign := false\n@@ -267,14 +265,12 @@ func Erf(x float64) float64 {\n func Erfc(x float64) float64 {\n \tconst Tiny = 1.0 / (1 << 56) // 2**-56\n \t// special cases\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \tswitch {\n-\tcase x != x: // IsNaN(x):\n+\tcase IsNaN(x):\n \t\treturn NaN()\n-\tcase x > MaxFloat64: // IsInf(x, 1):\n+\tcase IsInf(x, 1):\n \t\treturn 0\n-\tcase x < -MaxFloat64: // IsInf(x, -1):\n+\tcase IsInf(x, -1):\n \t\treturn 2\n \t}\n \tsign := false"}, {"sha": "51330c21dc8cdc05749bbff3bbc259ea1578c76d", "filename": "libgo/go/math/exp.go", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fexp.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -106,13 +106,11 @@ func exp(x float64) float64 {\n \t\tNearZero  = 1.0 / (1 << 28) // 2**-28\n \t)\n \n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n-\tcase x != x || x > MaxFloat64: // IsNaN(x) || IsInf(x, 1):\n+\tcase IsNaN(x) || IsInf(x, 1):\n \t\treturn x\n-\tcase x < -MaxFloat64: // IsInf(x, -1):\n+\tcase IsInf(x, -1):\n \t\treturn 0\n \tcase x > Overflow:\n \t\treturn Inf(1)\n@@ -153,13 +151,11 @@ func exp2(x float64) float64 {\n \t\tUnderflow = -1.0740e+03\n \t)\n \n-\t// TODO: remove manual inlining of IsNaN and IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n-\tcase x != x || x > MaxFloat64: // IsNaN(x) || IsInf(x, 1):\n+\tcase IsNaN(x) || IsInf(x, 1):\n \t\treturn x\n-\tcase x < -MaxFloat64: // IsInf(x, -1):\n+\tcase IsInf(x, -1):\n \t\treturn 0\n \tcase x > Overflow:\n \t\treturn Inf(1)"}, {"sha": "f7e15dbbc9d491427574d70421d798e7c96b241b", "filename": "libgo/go/math/expm1.go", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fexpm1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fexpm1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fexpm1.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -148,12 +148,10 @@ func expm1(x float64) float64 {\n \t)\n \n \t// special cases\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \tswitch {\n-\tcase x > MaxFloat64 || x != x: // IsInf(x, 1) || IsNaN(x):\n+\tcase IsInf(x, 1) || IsNaN(x):\n \t\treturn x\n-\tcase x < -MaxFloat64: // IsInf(x, -1):\n+\tcase IsInf(x, -1):\n \t\treturn -1\n \t}\n "}, {"sha": "b35066e58cbb9031fc8a67d97502d7716889b6d1", "filename": "libgo/go/math/floor.go", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Ffloor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Ffloor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Ffloor.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -19,9 +19,7 @@ func Floor(x float64) float64 {\n }\n \n func floor(x float64) float64 {\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n-\tif x == 0 || x != x || x > MaxFloat64 || x < -MaxFloat64 { // x == 0 || IsNaN(x) || IsInf(x, 0)\n+\tif x == 0 || IsNaN(x) || IsInf(x, 0) {\n \t\treturn x\n \t}\n \tif x < 0 {\n@@ -68,9 +66,7 @@ func Trunc(x float64) float64 {\n }\n \n func trunc(x float64) float64 {\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n-\tif x == 0 || x != x || x > MaxFloat64 || x < -MaxFloat64 { // x == 0 || IsNaN(x) || IsInf(x, 0)\n+\tif x == 0 || IsNaN(x) || IsInf(x, 0) {\n \t\treturn x\n \t}\n \td, _ := Modf(x)"}, {"sha": "4ad0aee54a42f80f0e4dbf0e3359c87043ac47a9", "filename": "libgo/go/math/frexp.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Ffrexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Ffrexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Ffrexp.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -18,13 +18,11 @@ func Frexp(f float64) (frac float64, exp int) {\n }\n \n func frexp(f float64) (frac float64, exp int) {\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n \tcase f == 0:\n \t\treturn f, 0 // correctly return -0\n-\tcase f < -MaxFloat64 || f > MaxFloat64 || f != f: // IsInf(f, 0) || IsNaN(f):\n+\tcase IsInf(f, 0) || IsNaN(f):\n \t\treturn f, 0\n \t}\n \tf, exp = normalize(f)"}, {"sha": "2385a53b8a5cc7819525b85dda1378440918d325", "filename": "libgo/go/math/gamma.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fgamma.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fgamma.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fgamma.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -121,7 +121,7 @@ func Gamma(x float64) float64 {\n \tconst Euler = 0.57721566490153286060651209008240243104215933593992 // A001620\n \t// special cases\n \tswitch {\n-\tcase x < -MaxFloat64 || x != x: // IsInf(x, -1) || IsNaN(x):\n+\tcase IsInf(x, -1) || IsNaN(x):\n \t\treturn x\n \tcase x < -170.5674972726612 || x > 171.61447887182298:\n \t\treturn Inf(1)"}, {"sha": "57d8e3437207a6f033aabf08252b1a6839c420bf", "filename": "libgo/go/math/hypot.go", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fhypot.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fhypot.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fhypot.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -19,13 +19,11 @@ func Hypot(p, q float64) float64 {\n }\n \n func hypot(p, q float64) float64 {\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n-\tcase p < -MaxFloat64 || p > MaxFloat64 || q < -MaxFloat64 || q > MaxFloat64: // IsInf(p, 0) || IsInf(q, 0):\n+\tcase IsInf(p, 0) || IsInf(q, 0):\n \t\treturn Inf(1)\n-\tcase p != p || q != q: // IsNaN(p) || IsNaN(q):\n+\tcase IsNaN(p) || IsNaN(q):\n \t\treturn NaN()\n \t}\n \tif p < 0 {"}, {"sha": "c20a9b22a89a761731b6adafe4a3839c1cfa5838", "filename": "libgo/go/math/j0.go", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fj0.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fj0.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fj0.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -89,13 +89,11 @@ func J0(x float64) float64 {\n \t\tS03 = 5.13546550207318111446e-07  // 0x3EA13B54CE84D5A9\n \t\tS04 = 1.16614003333790000205e-09  // 0x3E1408BCF4745D8F\n \t)\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n-\tcase x != x: // IsNaN(x)\n+\tcase IsNaN(x):\n \t\treturn x\n-\tcase x < -MaxFloat64 || x > MaxFloat64: // IsInf(x, 0):\n+\tcase IsInf(x, 0):\n \t\treturn 0\n \tcase x == 0:\n \t\treturn 1\n@@ -171,13 +169,11 @@ func Y0(x float64) float64 {\n \t\tV03    = 2.59150851840457805467e-07  // 0x3E91642D7FF202FD\n \t\tV04    = 4.41110311332675467403e-10  // 0x3DFE50183BD6D9EF\n \t)\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n-\tcase x < 0 || x != x: // x < 0 || IsNaN(x):\n+\tcase x < 0 || IsNaN(x):\n \t\treturn NaN()\n-\tcase x > MaxFloat64: // IsInf(x, 1):\n+\tcase IsInf(x, 1):\n \t\treturn 0\n \tcase x == 0:\n \t\treturn Inf(-1)"}, {"sha": "7ac186b72aa26cc0f92adf8c15e664708f54f099", "filename": "libgo/go/math/j1.go", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fj1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fj1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fj1.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -86,13 +86,11 @@ func J1(x float64) float64 {\n \t\tS04 = 5.04636257076217042715e-09  // 0x3E35AC88C97DFF2C\n \t\tS05 = 1.23542274426137913908e-11  // 0x3DAB2ACFCFB97ED8\n \t)\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n-\tcase x != x: // IsNaN(x)\n+\tcase IsNaN(x):\n \t\treturn x\n-\tcase x < -MaxFloat64 || x > MaxFloat64 || x == 0: // IsInf(x, 0) || x == 0:\n+\tcase IsInf(x, 0) || x == 0:\n \t\treturn 0\n \t}\n \n@@ -168,13 +166,11 @@ func Y1(x float64) float64 {\n \t\tV03    = 6.22741452364621501295e-09  // 0x3E3ABF1D5BA69A86\n \t\tV04    = 1.66559246207992079114e-11  // 0x3DB25039DACA772A\n \t)\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n-\tcase x < 0 || x != x: // x < 0 || IsNaN(x):\n+\tcase x < 0 || IsNaN(x):\n \t\treturn NaN()\n-\tcase x > MaxFloat64: // IsInf(x, 1):\n+\tcase IsInf(x, 1):\n \t\treturn 0\n \tcase x == 0:\n \t\treturn Inf(-1)"}, {"sha": "a7909eb24cdd3f5e1fb23e4db7f996b230b8152d", "filename": "libgo/go/math/jn.go", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fjn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fjn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fjn.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -55,13 +55,11 @@ func Jn(n int, x float64) float64 {\n \t\tTwoM29 = 1.0 / (1 << 29) // 2**-29 0x3e10000000000000\n \t\tTwo302 = 1 << 302        // 2**302 0x52D0000000000000\n \t)\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n-\tcase x != x: // IsNaN(x)\n+\tcase IsNaN(x):\n \t\treturn x\n-\tcase x < -MaxFloat64 || x > MaxFloat64: // IsInf(x, 0):\n+\tcase IsInf(x, 0):\n \t\treturn 0\n \t}\n \t// J(-n, x) = (-1)**n * J(n, x), J(n, -x) = (-1)**n * J(n, x)\n@@ -236,13 +234,11 @@ func Jn(n int, x float64) float64 {\n //\tY1(n, NaN) = NaN\n func Yn(n int, x float64) float64 {\n \tconst Two302 = 1 << 302 // 2**302 0x52D0000000000000\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n-\tcase x < 0 || x != x: // x < 0 || IsNaN(x):\n+\tcase x < 0 || IsNaN(x):\n \t\treturn NaN()\n-\tcase x > MaxFloat64: // IsInf(x, 1)\n+\tcase IsInf(x, 1):\n \t\treturn 0\n \t}\n \n@@ -299,7 +295,7 @@ func Yn(n int, x float64) float64 {\n \t\ta := Y0(x)\n \t\tb = Y1(x)\n \t\t// quit if b is -inf\n-\t\tfor i := 1; i < n && b >= -MaxFloat64; i++ { // for i := 1; i < n && !IsInf(b, -1); i++ {\n+\t\tfor i := 1; i < n && !IsInf(b, -1); i++ {\n \t\t\ta, b = b, (float64(i+i)/x)*b-a\n \t\t}\n \t}"}, {"sha": "32c9853204d267947436d6d6bfe53758146f0651", "filename": "libgo/go/math/ldexp.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fldexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fldexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fldexp.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -20,13 +20,11 @@ func Ldexp(frac float64, exp int) float64 {\n }\n \n func ldexp(frac float64, exp int) float64 {\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n \tcase frac == 0:\n \t\treturn frac // correctly return -0\n-\tcase frac < -MaxFloat64 || frac > MaxFloat64 || frac != frac: // IsInf(frac, 0) || IsNaN(frac):\n+\tcase IsInf(frac, 0) || IsNaN(frac):\n \t\treturn frac\n \t}\n \tfrac, e := normalize(frac)"}, {"sha": "6a02c412d93b603cc6d0abd3e0514ef9e2763a0b", "filename": "libgo/go/math/lgamma.go", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Flgamma.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Flgamma.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Flgamma.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -183,15 +183,13 @@ func Lgamma(x float64) (lgamma float64, sign int) {\n \t\t// Tt = -(tail of Tf)\n \t\tTt = -3.63867699703950536541e-18 // 0xBC50C7CAA48A971F\n \t)\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tsign = 1\n \tswitch {\n-\tcase x != x: // IsNaN(x):\n+\tcase IsNaN(x):\n \t\tlgamma = x\n \t\treturn\n-\tcase x < -MaxFloat64 || x > MaxFloat64: // IsInf(x, 0):\n+\tcase IsInf(x, 0):\n \t\tlgamma = x\n \t\treturn\n \tcase x == 0:"}, {"sha": "60b57552d8bc747ab62723360854387c76531a36", "filename": "libgo/go/math/log.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Flog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Flog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Flog.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -98,11 +98,9 @@ func log(x float64) float64 {\n \t\tL7    = 1.479819860511658591e-01   /* 3FC2F112 DF3E5244 */\n \t)\n \n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n-\tcase x != x || x > MaxFloat64: // IsNaN(x) || IsInf(x, 1):\n+\tcase IsNaN(x) || IsInf(x, 1):\n \t\treturn x\n \tcase x < 0:\n \t\treturn NaN()"}, {"sha": "c8daaaa1c95ab2293a690a93877cf31439943a82", "filename": "libgo/go/math/log1p.go", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Flog1p.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Flog1p.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Flog1p.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -119,14 +119,12 @@ func log1p(x float64) float64 {\n \t)\n \n \t// special cases\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \tswitch {\n-\tcase x < -1 || x != x: // x < -1 || IsNaN(x): // includes -Inf\n+\tcase x < -1 || IsNaN(x): // includes -Inf\n \t\treturn NaN()\n \tcase x == -1:\n \t\treturn Inf(-1)\n-\tcase x > MaxFloat64: // IsInf(x, 1):\n+\tcase IsInf(x, 1):\n \t\treturn Inf(1)\n \t}\n "}, {"sha": "d32f9f1000c790d042cb586c7e7e47c7af9b7c27", "filename": "libgo/go/math/logb.go", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Flogb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Flogb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Flogb.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -11,15 +11,13 @@ package math\n //\tLogb(0) = -Inf\n //\tLogb(NaN) = NaN\n func Logb(x float64) float64 {\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n \tcase x == 0:\n \t\treturn Inf(-1)\n-\tcase x < -MaxFloat64 || x > MaxFloat64: // IsInf(x, 0):\n+\tcase IsInf(x, 0):\n \t\treturn Inf(1)\n-\tcase x != x: // IsNaN(x):\n+\tcase IsNaN(x):\n \t\treturn x\n \t}\n \treturn float64(ilogb(x))\n@@ -32,15 +30,13 @@ func Logb(x float64) float64 {\n //\tIlogb(0) = MinInt32\n //\tIlogb(NaN) = MaxInt32\n func Ilogb(x float64) int {\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n \tcase x == 0:\n \t\treturn MinInt32\n-\tcase x != x: // IsNaN(x):\n+\tcase IsNaN(x):\n \t\treturn MaxInt32\n-\tcase x < -MaxFloat64 || x > MaxFloat64: // IsInf(x, 0):\n+\tcase IsInf(x, 0):\n \t\treturn MaxInt32\n \t}\n \treturn ilogb(x)"}, {"sha": "0b208f4eda3b43e12fa94efb4b8c83f86334746d", "filename": "libgo/go/math/mod.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fmod.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fmod.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fmod.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -27,9 +27,7 @@ func Mod(x, y float64) float64 {\n }\n \n func mod(x, y float64) float64 {\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us.\n-\tif y == 0 || x > MaxFloat64 || x < -MaxFloat64 || x != x || y != y { // y == 0 || IsInf(x, 0) || IsNaN(x) || IsNan(y)\n+\tif y == 0 || IsInf(x, 0) || IsNaN(x) || IsNaN(y) {\n \t\treturn NaN()\n \t}\n \tif y < 0 {"}, {"sha": "7c4b5bcdfef7eb2a5a58e0a73d285aada804f01c", "filename": "libgo/go/math/nextafter.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fnextafter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fnextafter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fnextafter.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -11,10 +11,8 @@ package math\n //      Nextafter(NaN, y) = NaN\n //      Nextafter(x, NaN) = NaN\n func Nextafter(x, y float64) (r float64) {\n-\t// TODO(rsc): Remove manual inlining of IsNaN\n-\t// when compiler does it for us\n \tswitch {\n-\tcase x != x || y != y: // IsNaN(x) || IsNaN(y): // special case\n+\tcase IsNaN(x) || IsNaN(y): // special case\n \t\tr = NaN()\n \tcase x == y:\n \t\tr = x"}, {"sha": "77af25648abf9d3c24c9828e6b6e8883dd484b1e", "filename": "libgo/go/math/pow.go", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fpow.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fpow.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fpow.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -36,8 +36,6 @@ func isOddInt(x float64) bool {\n //\tPow(-Inf, y) = Pow(-0, -y)\n //\tPow(x, y) = NaN for finite x < 0 and finite non-integer y\n func Pow(x, y float64) float64 {\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \tswitch {\n \tcase y == 0 || x == 1:\n \t\treturn 1\n@@ -47,7 +45,7 @@ func Pow(x, y float64) float64 {\n \t\treturn Sqrt(x)\n \tcase y == -0.5:\n \t\treturn 1 / Sqrt(x)\n-\tcase x != x || y != y: // IsNaN(x) || IsNaN(y):\n+\tcase IsNaN(x) || IsNaN(y):\n \t\treturn NaN()\n \tcase x == 0:\n \t\tswitch {\n@@ -62,7 +60,7 @@ func Pow(x, y float64) float64 {\n \t\t\t}\n \t\t\treturn 0\n \t\t}\n-\tcase y > MaxFloat64 || y < -MaxFloat64: // IsInf(y, 0):\n+\tcase IsInf(y, 0):\n \t\tswitch {\n \t\tcase x == -1:\n \t\t\treturn 1\n@@ -71,7 +69,7 @@ func Pow(x, y float64) float64 {\n \t\tdefault:\n \t\t\treturn Inf(1)\n \t\t}\n-\tcase x > MaxFloat64 || x < -MaxFloat64: // IsInf(x, 0):\n+\tcase IsInf(x, 0):\n \t\tif IsInf(x, -1) {\n \t\t\treturn Pow(1/x, -y) // Pow(-0, -y)\n \t\t}"}, {"sha": "a233e8ef188dfa86e1db7904d088e73d713d39cf", "filename": "libgo/go/math/remainder.go", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fremainder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fremainder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fremainder.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -43,13 +43,11 @@ func remainder(x, y float64) float64 {\n \t\tTiny    = 4.45014771701440276618e-308 // 0x0020000000000000\n \t\tHalfMax = MaxFloat64 / 2\n \t)\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n-\tcase x != x || y != y || x < -MaxFloat64 || x > MaxFloat64 || y == 0: // IsNaN(x) || IsNaN(y) || IsInf(x, 0) || y == 0:\n+\tcase IsNaN(x) || IsNaN(y) || IsInf(x, 0) || y == 0:\n \t\treturn NaN()\n-\tcase y < -MaxFloat64 || y > MaxFloat64: // IsInf(y):\n+\tcase IsInf(y, 0):\n \t\treturn x\n \t}\n \tsign := false"}, {"sha": "13fe408ba06f06d19be7f7dbfdba6478f0511809", "filename": "libgo/go/math/sin.go", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fsin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fsin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fsin.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -129,11 +129,9 @@ func cos(x float64) float64 {\n \t\tPI4C = 2.69515142907905952645E-15                            // 0x3ce8469898cc5170,\n \t\tM4PI = 1.273239544735162542821171882678754627704620361328125 // 4/pi\n \t)\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n-\tcase x != x || x < -MaxFloat64 || x > MaxFloat64: // IsNaN(x) || IsInf(x, 0):\n+\tcase IsNaN(x) || IsInf(x, 0):\n \t\treturn NaN()\n \t}\n \n@@ -194,13 +192,11 @@ func sin(x float64) float64 {\n \t\tPI4C = 2.69515142907905952645E-15                            // 0x3ce8469898cc5170,\n \t\tM4PI = 1.273239544735162542821171882678754627704620361328125 // 4/pi\n \t)\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n-\tcase x == 0 || x != x: // x == 0 || IsNaN():\n+\tcase x == 0 || IsNaN(x):\n \t\treturn x // return \u00b10 || NaN()\n-\tcase x < -MaxFloat64 || x > MaxFloat64: // IsInf(x, 0):\n+\tcase IsInf(x, 0):\n \t\treturn NaN()\n \t}\n "}, {"sha": "75e6e7541e63dc77427bf2f5aec37af1155459cb", "filename": "libgo/go/math/sincos.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fsincos.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fsincos.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fsincos.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -23,13 +23,11 @@ func sincos(x float64) (sin, cos float64) {\n \t\tPI4C = 2.69515142907905952645E-15                            // 0x3ce8469898cc5170,\n \t\tM4PI = 1.273239544735162542821171882678754627704620361328125 // 4/pi\n \t)\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n \tcase x == 0:\n \t\treturn x, 1 // return \u00b10.0, 1.0\n-\tcase x != x || x < -MaxFloat64 || x > MaxFloat64: // IsNaN(x) || IsInf(x, 0):\n+\tcase IsNaN(x) || IsInf(x, 0):\n \t\treturn NaN(), NaN()\n \t}\n "}, {"sha": "b5f297c84b6a3b7d9f35147740aef8d95f6793ce", "filename": "libgo/go/math/sqrt.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fsqrt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Fsqrt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fsqrt.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -106,10 +106,8 @@ func Sqrt(x float64) float64 {\n //\tSqrt(NaN) = NaN\n func sqrt(x float64) float64 {\n \t// special cases\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \tswitch {\n-\tcase x == 0 || x != x || x > MaxFloat64: // x == 0 || IsNaN(x) || IsInf(x, 1):\n+\tcase x == 0 || IsNaN(x) || IsInf(x, 1):\n \t\treturn x\n \tcase x < 0:\n \t\treturn NaN()"}, {"sha": "640f404fbe620fd68dc8574a403da571778874dd", "filename": "libgo/go/math/tan.go", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Ftan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmath%2Ftan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Ftan.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -94,13 +94,11 @@ func tan(x float64) float64 {\n \t\tPI4C = 2.69515142907905952645E-15                            // 0x3ce8469898cc5170,\n \t\tM4PI = 1.273239544735162542821171882678754627704620361328125 // 4/pi\n \t)\n-\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n-\t// when compiler does it for us\n \t// special cases\n \tswitch {\n-\tcase x == 0 || x != x: // x == 0 || IsNaN():\n+\tcase x == 0 || IsNaN(x):\n \t\treturn x // return \u00b10 || NaN()\n-\tcase x < -MaxFloat64 || x > MaxFloat64: // IsInf(x, 0):\n+\tcase IsInf(x, 0):\n \t\treturn NaN()\n \t}\n "}, {"sha": "d733130abb2e0dbe32857191e0563ffe0e6405a7", "filename": "libgo/go/mime/multipart/multipart.go", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -112,13 +112,13 @@ func (bp *Part) populateHeaders() error {\n \n // Read reads the body of a part, after its headers and before the\n // next part (if any) begins.\n-func (bp *Part) Read(p []byte) (n int, err error) {\n-\tif bp.buffer.Len() >= len(p) {\n+func (p *Part) Read(d []byte) (n int, err error) {\n+\tif p.buffer.Len() >= len(d) {\n \t\t// Internal buffer of unconsumed data is large enough for\n \t\t// the read request.  No need to parse more at the moment.\n-\t\treturn bp.buffer.Read(p)\n+\t\treturn p.buffer.Read(d)\n \t}\n-\tpeek, err := bp.mr.bufReader.Peek(4096) // TODO(bradfitz): add buffer size accessor\n+\tpeek, err := p.mr.bufReader.Peek(4096) // TODO(bradfitz): add buffer size accessor\n \tunexpectedEof := err == io.EOF\n \tif err != nil && !unexpectedEof {\n \t\treturn 0, fmt.Errorf(\"multipart: Part Read: %v\", err)\n@@ -133,10 +133,10 @@ func (bp *Part) Read(p []byte) (n int, err error) {\n \t// string.\n \tnCopy := 0\n \tfoundBoundary := false\n-\tif idx := bytes.Index(peek, bp.mr.nlDashBoundary); idx != -1 {\n+\tif idx := bytes.Index(peek, p.mr.nlDashBoundary); idx != -1 {\n \t\tnCopy = idx\n \t\tfoundBoundary = true\n-\t} else if safeCount := len(peek) - len(bp.mr.nlDashBoundary); safeCount > 0 {\n+\t} else if safeCount := len(peek) - len(p.mr.nlDashBoundary); safeCount > 0 {\n \t\tnCopy = safeCount\n \t} else if unexpectedEof {\n \t\t// If we've run out of peek buffer and the boundary\n@@ -145,11 +145,11 @@ func (bp *Part) Read(p []byte) (n int, err error) {\n \t\treturn 0, io.ErrUnexpectedEOF\n \t}\n \tif nCopy > 0 {\n-\t\tif _, err := io.CopyN(bp.buffer, bp.mr.bufReader, int64(nCopy)); err != nil {\n+\t\tif _, err := io.CopyN(p.buffer, p.mr.bufReader, int64(nCopy)); err != nil {\n \t\t\treturn 0, err\n \t\t}\n \t}\n-\tn, err = bp.buffer.Read(p)\n+\tn, err = p.buffer.Read(d)\n \tif err == io.EOF && !foundBoundary {\n \t\t// If the boundary hasn't been reached there's more to\n \t\t// read, so don't pass through an EOF from the buffer\n@@ -158,8 +158,8 @@ func (bp *Part) Read(p []byte) (n int, err error) {\n \treturn\n }\n \n-func (bp *Part) Close() error {\n-\tio.Copy(ioutil.Discard, bp)\n+func (p *Part) Close() error {\n+\tio.Copy(ioutil.Discard, p)\n \treturn nil\n }\n \n@@ -177,29 +177,29 @@ type Reader struct {\n \n // NextPart returns the next part in the multipart or an error.\n // When there are no more parts, the error io.EOF is returned.\n-func (mr *Reader) NextPart() (*Part, error) {\n-\tif mr.currentPart != nil {\n-\t\tmr.currentPart.Close()\n+func (r *Reader) NextPart() (*Part, error) {\n+\tif r.currentPart != nil {\n+\t\tr.currentPart.Close()\n \t}\n \n \texpectNewPart := false\n \tfor {\n-\t\tline, err := mr.bufReader.ReadSlice('\\n')\n+\t\tline, err := r.bufReader.ReadSlice('\\n')\n \t\tif err != nil {\n \t\t\treturn nil, fmt.Errorf(\"multipart: NextPart: %v\", err)\n \t\t}\n \n-\t\tif mr.isBoundaryDelimiterLine(line) {\n-\t\t\tmr.partsRead++\n-\t\t\tbp, err := newPart(mr)\n+\t\tif r.isBoundaryDelimiterLine(line) {\n+\t\t\tr.partsRead++\n+\t\t\tbp, err := newPart(r)\n \t\t\tif err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n-\t\t\tmr.currentPart = bp\n+\t\t\tr.currentPart = bp\n \t\t\treturn bp, nil\n \t\t}\n \n-\t\tif hasPrefixThenNewline(line, mr.dashBoundaryDash) {\n+\t\tif hasPrefixThenNewline(line, r.dashBoundaryDash) {\n \t\t\t// Expected EOF\n \t\t\treturn nil, io.EOF\n \t\t}\n@@ -208,7 +208,7 @@ func (mr *Reader) NextPart() (*Part, error) {\n \t\t\treturn nil, fmt.Errorf(\"multipart: expecting a new Part; got line %q\", string(line))\n \t\t}\n \n-\t\tif mr.partsRead == 0 {\n+\t\tif r.partsRead == 0 {\n \t\t\t// skip line\n \t\t\tcontinue\n \t\t}\n@@ -217,7 +217,7 @@ func (mr *Reader) NextPart() (*Part, error) {\n \t\t// body of the previous part and the boundary line we\n \t\t// now expect will follow. (either a new part or the\n \t\t// end boundary)\n-\t\tif bytes.Equal(line, mr.nl) {\n+\t\tif bytes.Equal(line, r.nl) {\n \t\t\texpectNewPart = true\n \t\t\tcontinue\n \t\t}"}, {"sha": "de35ec9f940583ab6c54bd7e3331b9cc05d3c1a3", "filename": "libgo/go/net/dial_test.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fdial_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fdial_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -43,18 +43,17 @@ func TestDialTimeout(t *testing.T) {\n \t\t\t\terrc <- err\n \t\t\t}()\n \t\t}\n-\tcase \"darwin\":\n+\tcase \"darwin\", \"windows\":\n \t\t// At least OS X 10.7 seems to accept any number of\n \t\t// connections, ignoring listen's backlog, so resort\n \t\t// to connecting to a hopefully-dead 127/8 address.\n+\t\t// Same for windows.\n \t\tgo func() {\n \t\t\t_, err := DialTimeout(\"tcp\", \"127.0.71.111:80\", 200*time.Millisecond)\n \t\t\terrc <- err\n \t\t}()\n \tdefault:\n-\t\t// TODO(bradfitz): this probably doesn't work on\n-\t\t// Windows? SOMAXCONN is huge there.  I'm not sure how\n-\t\t// listen works there.\n+\t\t// TODO(bradfitz):\n \t\t// OpenBSD may have a reject route to 10/8.\n \t\t// FreeBSD likely works, but is untested.\n \t\tt.Logf(\"skipping test on %q; untested.\", runtime.GOOS)"}, {"sha": "bb46cc9007c621b2fa7121e23f5004fba8e7c948", "filename": "libgo/go/net/dnsconfig.go", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fdnsconfig.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fdnsconfig.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsconfig.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -17,19 +17,6 @@ type dnsConfig struct {\n \trotate   bool     // round robin among servers\n }\n \n-var dnsconfigError error\n-\n-type DNSConfigError struct {\n-\tErr error\n-}\n-\n-func (e *DNSConfigError) Error() string {\n-\treturn \"error reading DNS config: \" + e.Err.Error()\n-}\n-\n-func (e *DNSConfigError) Timeout() bool   { return false }\n-func (e *DNSConfigError) Temporary() bool { return false }\n-\n // See resolv.conf(5) on a Linux machine.\n // TODO(rsc): Supposed to call uname() and chop the beginning\n // of the host name to get the default search domain."}, {"sha": "97c5062103fe0f72920e9fe1589ff9265d9dd26c", "filename": "libgo/go/net/dnsmsg.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fdnsmsg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fdnsmsg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsmsg.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -4,7 +4,7 @@\n \n // DNS packet assembly.  See RFC 1035.\n //\n-// This is intended to support name resolution during net.Dial.\n+// This is intended to support name resolution during Dial.\n // It doesn't have to be blazing fast.\n //\n // Rather than write the usual handful of routines to pack and"}, {"sha": "2352d22e115d6461acbb9a12dccee0ff882dc721", "filename": "libgo/go/net/fd.go", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Ffd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Ffd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -43,12 +43,6 @@ type netFD struct {\n \tncr, ncw int\n }\n \n-type InvalidConnError struct{}\n-\n-func (e *InvalidConnError) Error() string   { return \"invalid net.Conn\" }\n-func (e *InvalidConnError) Temporary() bool { return false }\n-func (e *InvalidConnError) Timeout() bool   { return false }\n-\n // A pollServer helps FDs determine when to retry a non-blocking\n // read or write after they get EAGAIN.  When an FD needs to wait,\n // send the fd on s.cr (for a read) or s.cw (for a write) to pass the\n@@ -275,20 +269,20 @@ func startServer() {\n \tpollserver = p\n }\n \n-func newFD(fd, family, sotype int, net string) (f *netFD, err error) {\n+func newFD(fd, family, sotype int, net string) (*netFD, error) {\n \tonceStartServer.Do(startServer)\n-\tif e := syscall.SetNonblock(fd, true); e != nil {\n-\t\treturn nil, e\n+\tif err := syscall.SetNonblock(fd, true); err != nil {\n+\t\treturn nil, err\n \t}\n-\tf = &netFD{\n+\tnetfd := &netFD{\n \t\tsysfd:  fd,\n \t\tfamily: family,\n \t\tsotype: sotype,\n \t\tnet:    net,\n \t}\n-\tf.cr = make(chan bool, 1)\n-\tf.cw = make(chan bool, 1)\n-\treturn f, nil\n+\tnetfd.cr = make(chan bool, 1)\n+\tnetfd.cw = make(chan bool, 1)\n+\treturn netfd, nil\n }\n \n func (fd *netFD) setAddr(laddr, raddr Addr) {\n@@ -304,8 +298,8 @@ func (fd *netFD) setAddr(laddr, raddr Addr) {\n \tfd.sysfile = os.NewFile(fd.sysfd, fd.net+\":\"+ls+\"->\"+rs)\n }\n \n-func (fd *netFD) connect(ra syscall.Sockaddr) (err error) {\n-\terr = syscall.Connect(fd.sysfd, ra)\n+func (fd *netFD) connect(ra syscall.Sockaddr) error {\n+\terr := syscall.Connect(fd.sysfd, ra)\n \tif err == syscall.EINPROGRESS {\n \t\tpollserver.WaitWrite(fd)\n \t\tvar e int\n@@ -466,7 +460,7 @@ func (fd *netFD) ReadMsg(p []byte, oob []byte) (n, oobn, flags int, sa syscall.S\n \treturn\n }\n \n-func (fd *netFD) Write(p []byte) (n int, err error) {\n+func (fd *netFD) Write(p []byte) (int, error) {\n \tif fd == nil {\n \t\treturn 0, os.EINVAL\n \t}\n@@ -477,8 +471,9 @@ func (fd *netFD) Write(p []byte) (n int, err error) {\n \tif fd.sysfile == nil {\n \t\treturn 0, os.EINVAL\n \t}\n-\tnn := 0\n \n+\tvar err error\n+\tnn := 0\n \tfor {\n \t\tvar n int\n \t\tn, err = syscall.Write(fd.sysfile.Fd(), p[nn:])\n@@ -565,7 +560,7 @@ func (fd *netFD) WriteMsg(p []byte, oob []byte, sa syscall.Sockaddr) (n int, oob\n \treturn\n }\n \n-func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (nfd *netFD, err error) {\n+func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (netfd *netFD, err error) {\n \tif fd == nil || fd.sysfile == nil {\n \t\treturn nil, os.EINVAL\n \t}\n@@ -600,13 +595,13 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (nfd *netFD, err err\n \tsyscall.CloseOnExec(s)\n \tsyscall.ForkLock.RUnlock()\n \n-\tif nfd, err = newFD(s, fd.family, fd.sotype, fd.net); err != nil {\n+\tif netfd, err = newFD(s, fd.family, fd.sotype, fd.net); err != nil {\n \t\tsyscall.Close(s)\n \t\treturn nil, err\n \t}\n-\tlsa, _ := syscall.Getsockname(nfd.sysfd)\n-\tnfd.setAddr(toAddr(lsa), toAddr(rsa))\n-\treturn nfd, nil\n+\tlsa, _ := syscall.Getsockname(netfd.sysfd)\n+\tnetfd.setAddr(toAddr(lsa), toAddr(rsa))\n+\treturn netfd, nil\n }\n \n func (fd *netFD) dup() (f *os.File, err error) {"}, {"sha": "a1d62acc7840dc68127ed1dabb9c07f7028ea6ef", "filename": "libgo/go/net/fd_linux.go", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Ffd_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Ffd_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_linux.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -35,17 +35,15 @@ type pollster struct {\n \n func newpollster() (p *pollster, err error) {\n \tp = new(pollster)\n-\tvar e error\n-\n-\tif p.epfd, e = syscall.EpollCreate1(syscall.EPOLL_CLOEXEC); e != nil {\n-\t\tif e != syscall.ENOSYS {\n-\t\t\treturn nil, os.NewSyscallError(\"epoll_create1\", e)\n+\tif p.epfd, err = syscall.EpollCreate1(syscall.EPOLL_CLOEXEC); err != nil {\n+\t\tif err != syscall.ENOSYS {\n+\t\t\treturn nil, os.NewSyscallError(\"epoll_create1\", err)\n \t\t}\n \t\t// The arg to epoll_create is a hint to the kernel\n \t\t// about the number of FDs we will care about.\n \t\t// We don't know, and since 2.6.8 the kernel ignores it anyhow.\n-\t\tif p.epfd, e = syscall.EpollCreate(16); e != nil {\n-\t\t\treturn nil, os.NewSyscallError(\"epoll_create\", e)\n+\t\tif p.epfd, err = syscall.EpollCreate(16); err != nil {\n+\t\t\treturn nil, os.NewSyscallError(\"epoll_create\", err)\n \t\t}\n \t\tsyscall.CloseOnExec(p.epfd)\n \t}\n@@ -74,8 +72,8 @@ func (p *pollster) AddFD(fd int, mode int, repeat bool) (bool, error) {\n \t} else {\n \t\top = syscall.EPOLL_CTL_ADD\n \t}\n-\tif e := syscall.EpollCtl(p.epfd, op, fd, &p.ctlEvent); e != nil {\n-\t\treturn false, os.NewSyscallError(\"epoll_ctl\", e)\n+\tif err := syscall.EpollCtl(p.epfd, op, fd, &p.ctlEvent); err != nil {\n+\t\treturn false, os.NewSyscallError(\"epoll_ctl\", err)\n \t}\n \tp.events[fd] = p.ctlEvent.Events\n \treturn false, nil\n@@ -103,13 +101,13 @@ func (p *pollster) StopWaiting(fd int, bits uint) {\n \tif int32(events)&^syscall.EPOLLONESHOT != 0 {\n \t\tp.ctlEvent.Fd = int32(fd)\n \t\tp.ctlEvent.Events = events\n-\t\tif e := syscall.EpollCtl(p.epfd, syscall.EPOLL_CTL_MOD, fd, &p.ctlEvent); e != nil {\n-\t\t\tprint(\"Epoll modify fd=\", fd, \": \", e.Error(), \"\\n\")\n+\t\tif err := syscall.EpollCtl(p.epfd, syscall.EPOLL_CTL_MOD, fd, &p.ctlEvent); err != nil {\n+\t\t\tprint(\"Epoll modify fd=\", fd, \": \", err.Error(), \"\\n\")\n \t\t}\n \t\tp.events[fd] = events\n \t} else {\n-\t\tif e := syscall.EpollCtl(p.epfd, syscall.EPOLL_CTL_DEL, fd, nil); e != nil {\n-\t\t\tprint(\"Epoll delete fd=\", fd, \": \", e.Error(), \"\\n\")\n+\t\tif err := syscall.EpollCtl(p.epfd, syscall.EPOLL_CTL_DEL, fd, nil); err != nil {\n+\t\t\tprint(\"Epoll delete fd=\", fd, \": \", err.Error(), \"\\n\")\n \t\t}\n \t\tdelete(p.events, fd)\n \t}\n@@ -144,14 +142,14 @@ func (p *pollster) WaitFD(s *pollServer, nsec int64) (fd int, mode int, err erro\n \t\t}\n \n \t\ts.Unlock()\n-\t\tn, e := syscall.EpollWait(p.epfd, p.waitEventBuf[0:], msec)\n+\t\tn, err := syscall.EpollWait(p.epfd, p.waitEventBuf[0:], msec)\n \t\ts.Lock()\n \n-\t\tif e != nil {\n-\t\t\tif e == syscall.EAGAIN || e == syscall.EINTR {\n+\t\tif err != nil {\n+\t\t\tif err == syscall.EAGAIN || err == syscall.EINTR {\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\treturn -1, 0, os.NewSyscallError(\"epoll_wait\", e)\n+\t\t\treturn -1, 0, os.NewSyscallError(\"epoll_wait\", err)\n \t\t}\n \t\tif n == 0 {\n \t\t\treturn -1, 0, nil"}, {"sha": "35d84c30ef61122bffed2a81882a15d12a99f531", "filename": "libgo/go/net/fd_netbsd.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Ffd_netbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Ffd_netbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_netbsd.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -49,12 +49,12 @@ func (p *pollster) AddFD(fd int, mode int, repeat bool) (bool, error) {\n \t}\n \tsyscall.SetKevent(ev, fd, kmode, flags)\n \n-\tn, e := syscall.Kevent(p.kq, p.kbuf[:], nil, nil)\n-\tif e != nil {\n-\t\treturn false, os.NewSyscallError(\"kevent\", e)\n+\tn, err := syscall.Kevent(p.kq, p.kbuf[:], nil, nil)\n+\tif err != nil {\n+\t\treturn false, os.NewSyscallError(\"kevent\", err)\n \t}\n \tif n != 1 || (ev.Flags&syscall.EV_ERROR) == 0 || int(ev.Ident) != fd || int(ev.Filter) != kmode {\n-\t\treturn false, os.NewSyscallError(\"kqueue phase error\", e)\n+\t\treturn false, os.NewSyscallError(\"kqueue phase error\", err)\n \t}\n \tif ev.Data != 0 {\n \t\treturn false, syscall.Errno(int(ev.Data))\n@@ -88,19 +88,19 @@ func (p *pollster) WaitFD(s *pollServer, nsec int64) (fd int, mode int, err erro\n \t\t}\n \n \t\ts.Unlock()\n-\t\tnn, e := syscall.Kevent(p.kq, nil, p.eventbuf[:], t)\n+\t\tn, err := syscall.Kevent(p.kq, nil, p.eventbuf[:], t)\n \t\ts.Lock()\n \n-\t\tif e != nil {\n-\t\t\tif e == syscall.EINTR {\n+\t\tif err != nil {\n+\t\t\tif err == syscall.EINTR {\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\treturn -1, 0, os.NewSyscallError(\"kevent\", e)\n+\t\t\treturn -1, 0, os.NewSyscallError(\"kevent\", err)\n \t\t}\n-\t\tif nn == 0 {\n+\t\tif n == 0 {\n \t\t\treturn -1, 0, nil\n \t\t}\n-\t\tp.events = p.eventbuf[0:nn]\n+\t\tp.events = p.eventbuf[:n]\n \t}\n \tev := &p.events[0]\n \tp.events = p.events[1:]"}, {"sha": "35d84c30ef61122bffed2a81882a15d12a99f531", "filename": "libgo/go/net/fd_openbsd.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Ffd_openbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Ffd_openbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_openbsd.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -49,12 +49,12 @@ func (p *pollster) AddFD(fd int, mode int, repeat bool) (bool, error) {\n \t}\n \tsyscall.SetKevent(ev, fd, kmode, flags)\n \n-\tn, e := syscall.Kevent(p.kq, p.kbuf[:], nil, nil)\n-\tif e != nil {\n-\t\treturn false, os.NewSyscallError(\"kevent\", e)\n+\tn, err := syscall.Kevent(p.kq, p.kbuf[:], nil, nil)\n+\tif err != nil {\n+\t\treturn false, os.NewSyscallError(\"kevent\", err)\n \t}\n \tif n != 1 || (ev.Flags&syscall.EV_ERROR) == 0 || int(ev.Ident) != fd || int(ev.Filter) != kmode {\n-\t\treturn false, os.NewSyscallError(\"kqueue phase error\", e)\n+\t\treturn false, os.NewSyscallError(\"kqueue phase error\", err)\n \t}\n \tif ev.Data != 0 {\n \t\treturn false, syscall.Errno(int(ev.Data))\n@@ -88,19 +88,19 @@ func (p *pollster) WaitFD(s *pollServer, nsec int64) (fd int, mode int, err erro\n \t\t}\n \n \t\ts.Unlock()\n-\t\tnn, e := syscall.Kevent(p.kq, nil, p.eventbuf[:], t)\n+\t\tn, err := syscall.Kevent(p.kq, nil, p.eventbuf[:], t)\n \t\ts.Lock()\n \n-\t\tif e != nil {\n-\t\t\tif e == syscall.EINTR {\n+\t\tif err != nil {\n+\t\t\tif err == syscall.EINTR {\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\treturn -1, 0, os.NewSyscallError(\"kevent\", e)\n+\t\t\treturn -1, 0, os.NewSyscallError(\"kevent\", err)\n \t\t}\n-\t\tif nn == 0 {\n+\t\tif n == 0 {\n \t\t\treturn -1, 0, nil\n \t\t}\n-\t\tp.events = p.eventbuf[0:nn]\n+\t\tp.events = p.eventbuf[:n]\n \t}\n \tev := &p.events[0]\n \tp.events = p.events[1:]"}, {"sha": "78168eb6c861436f43bdd8ee5c6e6753eaa66bc1", "filename": "libgo/go/net/fd_windows.go", "status": "modified", "additions": 40, "deletions": 45, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Ffd_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Ffd_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_windows.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -14,12 +14,6 @@ import (\n \t\"unsafe\"\n )\n \n-type InvalidConnError struct{}\n-\n-func (e *InvalidConnError) Error() string   { return \"invalid net.Conn\" }\n-func (e *InvalidConnError) Temporary() bool { return false }\n-func (e *InvalidConnError) Timeout() bool   { return false }\n-\n var initErr error\n \n func init() {\n@@ -30,15 +24,15 @@ func init() {\n \t}\n }\n \n-func closesocket(s syscall.Handle) (err error) {\n+func closesocket(s syscall.Handle) error {\n \treturn syscall.Closesocket(s)\n }\n \n // Interface for all io operations.\n type anOpIface interface {\n \tOp() *anOp\n \tName() string\n-\tSubmit() (err error)\n+\tSubmit() error\n }\n \n // IO completion result parameters.\n@@ -153,24 +147,25 @@ func (s *ioSrv) ProcessRemoteIO() {\n // inline, or, if a deadline is employed, passes the request onto\n // a special goroutine and waits for completion or cancels request.\n // deadline is unix nanos.\n-func (s *ioSrv) ExecIO(oi anOpIface, deadline int64) (n int, err error) {\n-\tvar e error\n+func (s *ioSrv) ExecIO(oi anOpIface, deadline int64) (int, error) {\n+\tvar err error\n \to := oi.Op()\n \tif deadline != 0 {\n \t\t// Send request to a special dedicated thread,\n \t\t// so it can stop the io with CancelIO later.\n \t\ts.submchan <- oi\n-\t\te = <-o.errnoc\n+\t\terr = <-o.errnoc\n \t} else {\n-\t\te = oi.Submit()\n+\t\terr = oi.Submit()\n \t}\n-\tswitch e {\n+\tswitch err {\n \tcase nil:\n \t\t// IO completed immediately, but we need to get our completion message anyway.\n \tcase syscall.ERROR_IO_PENDING:\n \t\t// IO started, and we have to wait for its completion.\n+\t\terr = nil\n \tdefault:\n-\t\treturn 0, &OpError{oi.Name(), o.fd.net, o.fd.laddr, e}\n+\t\treturn 0, &OpError{oi.Name(), o.fd.net, o.fd.laddr, err}\n \t}\n \t// Wait for our request to complete.\n \tvar r ioResult\n@@ -245,25 +240,25 @@ type netFD struct {\n \twio       sync.Mutex\n }\n \n-func allocFD(fd syscall.Handle, family, sotype int, net string) (f *netFD) {\n-\tf = &netFD{\n+func allocFD(fd syscall.Handle, family, sotype int, net string) *netFD {\n+\tnetfd := &netFD{\n \t\tsysfd:  fd,\n \t\tfamily: family,\n \t\tsotype: sotype,\n \t\tnet:    net,\n \t}\n-\truntime.SetFinalizer(f, (*netFD).Close)\n-\treturn f\n+\truntime.SetFinalizer(netfd, (*netFD).Close)\n+\treturn netfd\n }\n \n-func newFD(fd syscall.Handle, family, proto int, net string) (f *netFD, err error) {\n+func newFD(fd syscall.Handle, family, proto int, net string) (*netFD, error) {\n \tif initErr != nil {\n \t\treturn nil, initErr\n \t}\n \tonceStartServer.Do(startServer)\n \t// Associate our socket with resultsrv.iocp.\n-\tif _, e := syscall.CreateIoCompletionPort(syscall.Handle(fd), resultsrv.iocp, 0, 0); e != nil {\n-\t\treturn nil, e\n+\tif _, err := syscall.CreateIoCompletionPort(syscall.Handle(fd), resultsrv.iocp, 0, 0); err != nil {\n+\t\treturn nil, err\n \t}\n \treturn allocFD(fd, family, proto, net), nil\n }\n@@ -273,7 +268,7 @@ func (fd *netFD) setAddr(laddr, raddr Addr) {\n \tfd.raddr = raddr\n }\n \n-func (fd *netFD) connect(ra syscall.Sockaddr) (err error) {\n+func (fd *netFD) connect(ra syscall.Sockaddr) error {\n \treturn syscall.Connect(fd.sysfd, ra)\n }\n \n@@ -340,7 +335,7 @@ type readOp struct {\n \tbufOp\n }\n \n-func (o *readOp) Submit() (err error) {\n+func (o *readOp) Submit() error {\n \tvar d, f uint32\n \treturn syscall.WSARecv(syscall.Handle(o.fd.sysfd), &o.buf, 1, &d, &f, &o.o, nil)\n }\n@@ -349,7 +344,7 @@ func (o *readOp) Name() string {\n \treturn \"WSARecv\"\n }\n \n-func (fd *netFD) Read(buf []byte) (n int, err error) {\n+func (fd *netFD) Read(buf []byte) (int, error) {\n \tif fd == nil {\n \t\treturn 0, os.EINVAL\n \t}\n@@ -362,11 +357,11 @@ func (fd *netFD) Read(buf []byte) (n int, err error) {\n \t}\n \tvar o readOp\n \to.Init(fd, buf, 'r')\n-\tn, err = iosrv.ExecIO(&o, fd.rdeadline)\n+\tn, err := iosrv.ExecIO(&o, fd.rdeadline)\n \tif err == nil && n == 0 {\n \t\terr = io.EOF\n \t}\n-\treturn\n+\treturn n, err\n }\n \n // ReadFrom from network.\n@@ -377,7 +372,7 @@ type readFromOp struct {\n \trsan int32\n }\n \n-func (o *readFromOp) Submit() (err error) {\n+func (o *readFromOp) Submit() error {\n \tvar d, f uint32\n \treturn syscall.WSARecvFrom(o.fd.sysfd, &o.buf, 1, &d, &f, &o.rsa, &o.rsan, &o.o, nil)\n }\n@@ -417,7 +412,7 @@ type writeOp struct {\n \tbufOp\n }\n \n-func (o *writeOp) Submit() (err error) {\n+func (o *writeOp) Submit() error {\n \tvar d uint32\n \treturn syscall.WSASend(o.fd.sysfd, &o.buf, 1, &d, 0, &o.o, nil)\n }\n@@ -426,7 +421,7 @@ func (o *writeOp) Name() string {\n \treturn \"WSASend\"\n }\n \n-func (fd *netFD) Write(buf []byte) (n int, err error) {\n+func (fd *netFD) Write(buf []byte) (int, error) {\n \tif fd == nil {\n \t\treturn 0, os.EINVAL\n \t}\n@@ -449,7 +444,7 @@ type writeToOp struct {\n \tsa syscall.Sockaddr\n }\n \n-func (o *writeToOp) Submit() (err error) {\n+func (o *writeToOp) Submit() error {\n \tvar d uint32\n \treturn syscall.WSASendto(o.fd.sysfd, &o.buf, 1, &d, 0, o.sa, &o.o, nil)\n }\n@@ -458,7 +453,7 @@ func (o *writeToOp) Name() string {\n \treturn \"WSASendto\"\n }\n \n-func (fd *netFD) WriteTo(buf []byte, sa syscall.Sockaddr) (n int, err error) {\n+func (fd *netFD) WriteTo(buf []byte, sa syscall.Sockaddr) (int, error) {\n \tif fd == nil {\n \t\treturn 0, os.EINVAL\n \t}\n@@ -486,7 +481,7 @@ type acceptOp struct {\n \tattrs   [2]syscall.RawSockaddrAny // space for local and remote address only\n }\n \n-func (o *acceptOp) Submit() (err error) {\n+func (o *acceptOp) Submit() error {\n \tvar d uint32\n \tl := uint32(unsafe.Sizeof(o.attrs[0]))\n \treturn syscall.AcceptEx(o.fd.sysfd, o.newsock,\n@@ -497,7 +492,7 @@ func (o *acceptOp) Name() string {\n \treturn \"AcceptEx\"\n }\n \n-func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (nfd *netFD, err error) {\n+func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (*netFD, error) {\n \tif fd == nil || fd.sysfd == syscall.InvalidHandle {\n \t\treturn nil, os.EINVAL\n \t}\n@@ -507,18 +502,18 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (nfd *netFD, err err\n \t// Get new socket.\n \t// See ../syscall/exec.go for description of ForkLock.\n \tsyscall.ForkLock.RLock()\n-\ts, e := syscall.Socket(fd.family, fd.sotype, 0)\n-\tif e != nil {\n+\ts, err := syscall.Socket(fd.family, fd.sotype, 0)\n+\tif err != nil {\n \t\tsyscall.ForkLock.RUnlock()\n-\t\treturn nil, e\n+\t\treturn nil, err\n \t}\n \tsyscall.CloseOnExec(s)\n \tsyscall.ForkLock.RUnlock()\n \n \t// Associate our new socket with IOCP.\n \tonceStartServer.Do(startServer)\n-\tif _, e = syscall.CreateIoCompletionPort(s, resultsrv.iocp, 0, 0); e != nil {\n-\t\treturn nil, &OpError{\"CreateIoCompletionPort\", fd.net, fd.laddr, e}\n+\tif _, err := syscall.CreateIoCompletionPort(s, resultsrv.iocp, 0, 0); err != nil {\n+\t\treturn nil, &OpError{\"CreateIoCompletionPort\", fd.net, fd.laddr, err}\n \t}\n \n \t// Submit accept request.\n@@ -532,10 +527,10 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (nfd *netFD, err err\n \t}\n \n \t// Inherit properties of the listening socket.\n-\te = syscall.Setsockopt(s, syscall.SOL_SOCKET, syscall.SO_UPDATE_ACCEPT_CONTEXT, (*byte)(unsafe.Pointer(&fd.sysfd)), int32(unsafe.Sizeof(fd.sysfd)))\n-\tif e != nil {\n+\terr = syscall.Setsockopt(s, syscall.SOL_SOCKET, syscall.SO_UPDATE_ACCEPT_CONTEXT, (*byte)(unsafe.Pointer(&fd.sysfd)), int32(unsafe.Sizeof(fd.sysfd)))\n+\tif err != nil {\n \t\tclosesocket(s)\n-\t\treturn nil, e\n+\t\treturn nil, err\n \t}\n \n \t// Get local and peer addr out of AcceptEx buffer.\n@@ -547,14 +542,14 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (nfd *netFD, err err\n \tlsa, _ := lrsa.Sockaddr()\n \trsa, _ := rrsa.Sockaddr()\n \n-\tnfd = allocFD(s, fd.family, fd.sotype, fd.net)\n-\tnfd.setAddr(toAddr(lsa), toAddr(rsa))\n-\treturn nfd, nil\n+\tnetfd := allocFD(s, fd.family, fd.sotype, fd.net)\n+\tnetfd.setAddr(toAddr(lsa), toAddr(rsa))\n+\treturn netfd, nil\n }\n \n // Unimplemented functions.\n \n-func (fd *netFD) dup() (f *os.File, err error) {\n+func (fd *netFD) dup() (*os.File, error) {\n \t// TODO: Implement this\n \treturn nil, os.NewSyscallError(\"dup\", syscall.EWINDOWS)\n }"}, {"sha": "901b8565995278353353107061763ba8f903749f", "filename": "libgo/go/net/file.go", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffile.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -11,15 +11,15 @@ import (\n \t\"syscall\"\n )\n \n-func newFileFD(f *os.File) (nfd *netFD, err error) {\n-\tfd, errno := syscall.Dup(f.Fd())\n-\tif errno != nil {\n-\t\treturn nil, os.NewSyscallError(\"dup\", errno)\n+func newFileFD(f *os.File) (*netFD, error) {\n+\tfd, err := syscall.Dup(f.Fd())\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"dup\", err)\n \t}\n \n-\tproto, errno := syscall.GetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_TYPE)\n-\tif errno != nil {\n-\t\treturn nil, os.NewSyscallError(\"getsockopt\", errno)\n+\tproto, err := syscall.GetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_TYPE)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"getsockopt\", err)\n \t}\n \n \tfamily := syscall.AF_UNSPEC\n@@ -56,11 +56,12 @@ func newFileFD(f *os.File) (nfd *netFD, err error) {\n \tsa, _ = syscall.Getpeername(fd)\n \traddr := toAddr(sa)\n \n-\tif nfd, err = newFD(fd, family, proto, laddr.Network()); err != nil {\n+\tnetfd, err := newFD(fd, family, proto, laddr.Network())\n+\tif err != nil {\n \t\treturn nil, err\n \t}\n-\tnfd.setAddr(laddr, raddr)\n-\treturn nfd, nil\n+\tnetfd.setAddr(laddr, raddr)\n+\treturn netfd, nil\n }\n \n // FileConn returns a copy of the network connection corresponding to"}, {"sha": "d27cc4dc9a8abfb6ba474cf85f26488d7903f6a2", "filename": "libgo/go/net/http/cgi/host.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -217,7 +217,7 @@ func (h *Handler) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n \tdefer cmd.Wait()\n \tdefer stdoutRead.Close()\n \n-\tlinebody, _ := bufio.NewReaderSize(stdoutRead, 1024)\n+\tlinebody := bufio.NewReaderSize(stdoutRead, 1024)\n \theaders := make(http.Header)\n \tstatusCode := 0\n \tfor {"}, {"sha": "5d450258bd37798b035e15c891c02429375dbb29", "filename": "libgo/go/net/http/client.go", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -245,7 +245,11 @@ func (c *Client) doFollowingRedirects(ireq *Request) (r *Response, err error) {\n \t}\n \n \tmethod := ireq.Method\n-\terr = &url.Error{method[0:1] + strings.ToLower(method[1:]), urlStr, err}\n+\terr = &url.Error{\n+\t\tOp:  method[0:1] + strings.ToLower(method[1:]),\n+\t\tURL: urlStr,\n+\t\tErr: err,\n+\t}\n \treturn\n }\n \n@@ -274,7 +278,11 @@ func (c *Client) Post(url string, bodyType string, body io.Reader) (r *Response,\n \t\treturn nil, err\n \t}\n \treq.Header.Set(\"Content-Type\", bodyType)\n-\treturn send(req, c.Transport)\n+\tr, err = send(req, c.Transport)\n+\tif err == nil && c.Jar != nil {\n+\t\tc.Jar.SetCookies(req.URL, r.Cookies())\n+\t}\n+\treturn r, err\n }\n \n // PostForm issues a POST to the specified URL, "}, {"sha": "06bba0488a20f897936a2489dfef46ff8fbba72c", "filename": "libgo/go/net/http/fcgi/fcgi.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Ffcgi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Ffcgi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Ffcgi.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -240,7 +240,7 @@ func (w *bufWriter) Close() error {\n \n func newWriter(c *conn, recType recType, reqId uint16) *bufWriter {\n \ts := &streamWriter{c: c, recType: recType, reqId: reqId}\n-\tw, _ := bufio.NewWriterSize(s, maxWrite)\n+\tw := bufio.NewWriterSize(s, maxWrite)\n \treturn &bufWriter{s, w}\n }\n "}, {"sha": "feea9209e6a362e1ec087a6111c38a4612575062", "filename": "libgo/go/net/http/fs_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -190,7 +190,7 @@ func TestDirJoin(t *testing.T) {\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"stat of %s: %v\", name, err)\n \t\t}\n-\t\tif !gfi.(*os.FileStat).SameFile(wfi.(*os.FileStat)) {\n+\t\tif !os.SameFile(gfi, wfi) {\n \t\t\tt.Errorf(\"%s got different file\", name)\n \t\t}\n \t}"}, {"sha": "c853066f1cffa06f17a0f9f76091babe13e474d4", "filename": "libgo/go/net/http/httputil/dump.go", "status": "modified", "additions": 37, "deletions": 18, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fdump.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fdump.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fdump.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -5,8 +5,8 @@\n package httputil\n \n import (\n+\t\"bufio\"\n \t\"bytes\"\n-\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n@@ -47,40 +47,59 @@ func (c *dumpConn) SetWriteDeadline(t time.Time) error { return nil }\n // DumpRequestOut is like DumpRequest but includes\n // headers that the standard http.Transport adds,\n // such as User-Agent.\n-func DumpRequestOut(req *http.Request, body bool) (dump []byte, err error) {\n+func DumpRequestOut(req *http.Request, body bool) ([]byte, error) {\n \tsave := req.Body\n \tif !body || req.Body == nil {\n \t\treq.Body = nil\n \t} else {\n+\t\tvar err error\n \t\tsave, req.Body, err = drainBody(req.Body)\n \t\tif err != nil {\n-\t\t\treturn\n+\t\t\treturn nil, err\n \t\t}\n \t}\n \n-\tvar b bytes.Buffer\n-\tdialed := false\n+\t// Use the actual Transport code to record what we would send\n+\t// on the wire, but not using TCP.  Use a Transport with a\n+\t// customer dialer that returns a fake net.Conn that waits\n+\t// for the full input (and recording it), and then responds\n+\t// with a dummy response.\n+\tvar buf bytes.Buffer // records the output\n+\tpr, pw := io.Pipe()\n+\tdr := &delegateReader{c: make(chan io.Reader)}\n+\t// Wait for the request before replying with a dummy response:\n+\tgo func() {\n+\t\thttp.ReadRequest(bufio.NewReader(pr))\n+\t\tdr.c <- strings.NewReader(\"HTTP/1.1 204 No Content\\r\\n\\r\\n\")\n+\t}()\n+\n \tt := &http.Transport{\n-\t\tDial: func(net, addr string) (c net.Conn, err error) {\n-\t\t\tif dialed {\n-\t\t\t\treturn nil, errors.New(\"unexpected second dial\")\n-\t\t\t}\n-\t\t\tc = &dumpConn{\n-\t\t\t\tWriter: &b,\n-\t\t\t\tReader: strings.NewReader(\"HTTP/1.1 500 Fake Error\\r\\n\\r\\n\"),\n-\t\t\t}\n-\t\t\treturn\n+\t\tDial: func(net, addr string) (net.Conn, error) {\n+\t\t\treturn &dumpConn{io.MultiWriter(pw, &buf), dr}, nil\n \t\t},\n \t}\n \n-\t_, err = t.RoundTrip(req)\n+\t_, err := t.RoundTrip(req)\n \n \treq.Body = save\n \tif err != nil {\n-\t\treturn\n+\t\treturn nil, err\n \t}\n-\tdump = b.Bytes()\n-\treturn\n+\treturn buf.Bytes(), nil\n+}\n+\n+// delegateReader is a reader that delegates to another reader,\n+// once it arrives on a channel.\n+type delegateReader struct {\n+\tc chan io.Reader\n+\tr io.Reader // nil until received from c\n+}\n+\n+func (r *delegateReader) Read(p []byte) (int, error) {\n+\tif r.r == nil {\n+\t\tr.r = <-r.c\n+\t}\n+\treturn r.r.Read(p)\n }\n \n // Return value if nonempty, def otherwise."}, {"sha": "c065ccfb499a4d4d8f78836cf18431de437080be", "filename": "libgo/go/net/http/httputil/persist.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fpersist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fpersist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fpersist.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -18,8 +18,8 @@ import (\n )\n \n var (\n-\tErrPersistEOF = &http.ProtocolError{\"persistent connection closed\"}\n-\tErrPipeline   = &http.ProtocolError{\"pipeline error\"}\n+\tErrPersistEOF = &http.ProtocolError{ErrorString: \"persistent connection closed\"}\n+\tErrPipeline   = &http.ProtocolError{ErrorString: \"pipeline error\"}\n )\n \n // This is an API usage error - the local side is closed."}, {"sha": "9c4bd6e09a5c81aa09c9ea264b597b19ab21a2d0", "filename": "libgo/go/net/http/httputil/reverseproxy.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -55,11 +55,16 @@ func singleJoiningSlash(a, b string) string {\n // target's path is \"/base\" and the incoming request was for \"/dir\",\n // the target request will be for /base/dir.\n func NewSingleHostReverseProxy(target *url.URL) *ReverseProxy {\n+\ttargetQuery := target.RawQuery\n \tdirector := func(req *http.Request) {\n \t\treq.URL.Scheme = target.Scheme\n \t\treq.URL.Host = target.Host\n \t\treq.URL.Path = singleJoiningSlash(target.Path, req.URL.Path)\n-\t\treq.URL.RawQuery = target.RawQuery\n+\t\tif targetQuery == \"\" || req.URL.RawQuery == \"\" {\n+\t\t\treq.URL.RawQuery = targetQuery + req.URL.RawQuery\n+\t\t} else {\n+\t\t\treq.URL.RawQuery = targetQuery + \"&\" + req.URL.RawQuery\n+\t\t}\n \t}\n \treturn &ReverseProxy{Director: director}\n }"}, {"sha": "28e9c90ad36cdac93a4550a4384b1a481edbf1b6", "filename": "libgo/go/net/http/httputil/reverseproxy_test.go", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -69,3 +69,41 @@ func TestReverseProxy(t *testing.T) {\n \t\tt.Errorf(\"got body %q; expected %q\", g, e)\n \t}\n }\n+\n+var proxyQueryTests = []struct {\n+\tbaseSuffix string // suffix to add to backend URL\n+\treqSuffix  string // suffix to add to frontend's request URL\n+\twant       string // what backend should see for final request URL (without ?)\n+}{\n+\t{\"\", \"\", \"\"},\n+\t{\"?sta=tic\", \"?us=er\", \"sta=tic&us=er\"},\n+\t{\"\", \"?us=er\", \"us=er\"},\n+\t{\"?sta=tic\", \"\", \"sta=tic\"},\n+}\n+\n+func TestReverseProxyQuery(t *testing.T) {\n+\tbackend := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tw.Header().Set(\"X-Got-Query\", r.URL.RawQuery)\n+\t\tw.Write([]byte(\"hi\"))\n+\t}))\n+\tdefer backend.Close()\n+\n+\tfor i, tt := range proxyQueryTests {\n+\t\tbackendURL, err := url.Parse(backend.URL + tt.baseSuffix)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tfrontend := httptest.NewServer(NewSingleHostReverseProxy(backendURL))\n+\t\treq, _ := http.NewRequest(\"GET\", frontend.URL+tt.reqSuffix, nil)\n+\t\treq.Close = true\n+\t\tres, err := http.DefaultClient.Do(req)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"%d. Get: %v\", i, err)\n+\t\t}\n+\t\tif g, e := res.Header.Get(\"X-Got-Query\"), tt.want; g != e {\n+\t\t\tt.Errorf(\"%d. got query %q; expected %q\", i, g, e)\n+\t\t}\n+\t\tres.Body.Close()\n+\t\tfrontend.Close()\n+\t}\n+}"}, {"sha": "0bbec53be71d50d3bc233d3e1785cd47a3068566", "filename": "libgo/go/net/http/request.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -272,7 +272,7 @@ func valueOrDefault(value, def string) string {\n const defaultUserAgent = \"Go http package\"\n \n // Write writes an HTTP/1.1 request -- header and body -- in wire format.\n-// This method consults the following fields of req:\n+// This method consults the following fields of the request:\n //\tHost\n //\tURL\n //\tMethod (defaults to \"GET\")\n@@ -284,18 +284,18 @@ const defaultUserAgent = \"Go http package\"\n // If Body is present, Content-Length is <= 0 and TransferEncoding\n // hasn't been set to \"identity\", Write adds \"Transfer-Encoding:\n // chunked\" to the header. Body is closed after it is sent.\n-func (req *Request) Write(w io.Writer) error {\n-\treturn req.write(w, false, nil)\n+func (r *Request) Write(w io.Writer) error {\n+\treturn r.write(w, false, nil)\n }\n \n // WriteProxy is like Write but writes the request in the form\n // expected by an HTTP proxy.  In particular, WriteProxy writes the\n // initial Request-URI line of the request with an absolute URI, per\n-// section 5.1.2 of RFC 2616, including the scheme and host. In\n-// either case, WriteProxy also writes a Host header, using either\n-// req.Host or req.URL.Host.\n-func (req *Request) WriteProxy(w io.Writer) error {\n-\treturn req.write(w, true, nil)\n+// section 5.1.2 of RFC 2616, including the scheme and host.\n+// In either case, WriteProxy also writes a Host header, using\n+// either r.Host or r.URL.Host.\n+func (r *Request) WriteProxy(w io.Writer) error {\n+\treturn r.write(w, true, nil)\n }\n \n // extraHeaders may be nil"}, {"sha": "b79022097867992c5b6c011dec4ae9b9ea6df76d", "filename": "libgo/go/net/http/response.go", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -174,7 +174,7 @@ func (r *Response) ProtoAtLeast(major, minor int) bool {\n }\n \n // Writes the response (header, body and trailer) in wire format. This method\n-// consults the following fields of resp:\n+// consults the following fields of the response:\n //\n //  StatusCode\n //  ProtoMajor\n@@ -186,28 +186,28 @@ func (r *Response) ProtoAtLeast(major, minor int) bool {\n //  ContentLength\n //  Header, values for non-canonical keys will have unpredictable behavior\n //\n-func (resp *Response) Write(w io.Writer) error {\n+func (r *Response) Write(w io.Writer) error {\n \n \t// RequestMethod should be upper-case\n-\tif resp.Request != nil {\n-\t\tresp.Request.Method = strings.ToUpper(resp.Request.Method)\n+\tif r.Request != nil {\n+\t\tr.Request.Method = strings.ToUpper(r.Request.Method)\n \t}\n \n \t// Status line\n-\ttext := resp.Status\n+\ttext := r.Status\n \tif text == \"\" {\n \t\tvar ok bool\n-\t\ttext, ok = statusText[resp.StatusCode]\n+\t\ttext, ok = statusText[r.StatusCode]\n \t\tif !ok {\n-\t\t\ttext = \"status code \" + strconv.Itoa(resp.StatusCode)\n+\t\t\ttext = \"status code \" + strconv.Itoa(r.StatusCode)\n \t\t}\n \t}\n-\tio.WriteString(w, \"HTTP/\"+strconv.Itoa(resp.ProtoMajor)+\".\")\n-\tio.WriteString(w, strconv.Itoa(resp.ProtoMinor)+\" \")\n-\tio.WriteString(w, strconv.Itoa(resp.StatusCode)+\" \"+text+\"\\r\\n\")\n+\tio.WriteString(w, \"HTTP/\"+strconv.Itoa(r.ProtoMajor)+\".\")\n+\tio.WriteString(w, strconv.Itoa(r.ProtoMinor)+\" \")\n+\tio.WriteString(w, strconv.Itoa(r.StatusCode)+\" \"+text+\"\\r\\n\")\n \n \t// Process Body,ContentLength,Close,Trailer\n-\ttw, err := newTransferWriter(resp)\n+\ttw, err := newTransferWriter(r)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -217,7 +217,7 @@ func (resp *Response) Write(w io.Writer) error {\n \t}\n \n \t// Rest of header\n-\terr = resp.Header.WriteSubset(w, respExcludeHeader)\n+\terr = r.Header.WriteSubset(w, respExcludeHeader)\n \tif err != nil {\n \t\treturn err\n \t}"}, {"sha": "e2860c3edcf55fbd9eaa0cf80637716fa8517fd3", "filename": "libgo/go/net/http/serve_test.go", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -504,8 +504,9 @@ func Test304Responses(t *testing.T) {\n }\n \n // TestHeadResponses verifies that responses to HEAD requests don't\n-// declare that they're chunking in their response headers and aren't\n-// allowed to produce output.\n+// declare that they're chunking in their response headers, aren't\n+// allowed to produce output, and don't set a Content-Type since\n+// the real type of the body data cannot be inferred.\n func TestHeadResponses(t *testing.T) {\n \tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n \t\t_, err := w.Write([]byte(\"Ignored body\"))\n@@ -527,6 +528,10 @@ func TestHeadResponses(t *testing.T) {\n \tif len(res.TransferEncoding) > 0 {\n \t\tt.Errorf(\"expected no TransferEncoding; got %v\", res.TransferEncoding)\n \t}\n+\tct := res.Header.Get(\"Content-Type\")\n+\tif ct != \"\" {\n+\t\tt.Errorf(\"expected no Content-Type; got %s\", ct)\n+\t}\n \tbody, err := ioutil.ReadAll(res.Body)\n \tif err != nil {\n \t\tt.Error(err)"}, {"sha": "288539ba5760745a5f0b50dc45905a57675acb2b", "filename": "libgo/go/net/http/server.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -341,7 +341,7 @@ func (w *response) WriteHeader(code int) {\n \t\t}\n \t} else {\n \t\t// If no content type, apply sniffing algorithm to body.\n-\t\tif w.header.Get(\"Content-Type\") == \"\" {\n+\t\tif w.header.Get(\"Content-Type\") == \"\" && w.req.Method != \"HEAD\" {\n \t\t\tw.needSniff = true\n \t\t}\n \t}\n@@ -1078,8 +1078,8 @@ func ListenAndServeTLS(addr string, certFile string, keyFile string, handler Han\n // of the server's certificate followed by the CA's certificate.\n //\n // If srv.Addr is blank, \":https\" is used.\n-func (s *Server) ListenAndServeTLS(certFile, keyFile string) error {\n-\taddr := s.Addr\n+func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error {\n+\taddr := srv.Addr\n \tif addr == \"\" {\n \t\taddr = \":https\"\n \t}\n@@ -1101,7 +1101,7 @@ func (s *Server) ListenAndServeTLS(certFile, keyFile string) error {\n \t}\n \n \ttlsListener := tls.NewListener(conn, config)\n-\treturn s.Serve(tlsListener)\n+\treturn srv.Serve(tlsListener)\n }\n \n // TimeoutHandler returns a Handler that runs h with the given time limit."}, {"sha": "693215edd4fcbce040a10b517a29e1dc4b58bc20", "filename": "libgo/go/net/http/transport.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -535,7 +535,9 @@ func (pc *persistConn) readLoop() {\n \t\t}\n \t\tresp, err := ReadResponse(pc.br, rc.req)\n \n-\t\tif err == nil {\n+\t\tif err != nil {\n+\t\t\tpc.close()\n+\t\t} else {\n \t\t\thasBody := rc.req.Method != \"HEAD\" && resp.ContentLength != 0\n \t\t\tif rc.addedGzip && hasBody && resp.Header.Get(\"Content-Encoding\") == \"gzip\" {\n \t\t\t\tresp.Header.Del(\"Content-Encoding\")"}, {"sha": "caf81d6e46b28b853627b19fa467969557273568", "filename": "libgo/go/net/http/transport_test.go", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -441,7 +441,11 @@ func TestRoundTripGzip(t *testing.T) {\n \t\t}\n \t\tif accept == \"gzip\" {\n \t\t\trw.Header().Set(\"Content-Encoding\", \"gzip\")\n-\t\t\tgz, _ := gzip.NewWriter(rw)\n+\t\t\tgz, err := gzip.NewWriter(rw)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"gzip NewWriter: %v\", err)\n+\t\t\t\treturn\n+\t\t\t}\n \t\t\tgz.Write([]byte(responseBody))\n \t\t\tgz.Close()\n \t\t} else {\n@@ -460,7 +464,11 @@ func TestRoundTripGzip(t *testing.T) {\n \t\tres, err := DefaultTransport.RoundTrip(req)\n \t\tvar body []byte\n \t\tif test.compressed {\n-\t\t\tgzip, _ := gzip.NewReader(res.Body)\n+\t\t\tgzip, err := gzip.NewReader(res.Body)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"%d. gzip NewReader: %v\", i, err)\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\tbody, err = ioutil.ReadAll(gzip)\n \t\t\tres.Body.Close()\n \t\t} else {"}, {"sha": "7f090d8d40699323f6dc590866312bd073e38e0a", "filename": "libgo/go/net/interface_bsd.go", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Finterface_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Finterface_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_bsd.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -15,11 +15,9 @@ import (\n )\n \n // If the ifindex is zero, interfaceTable returns mappings of all\n-// network interfaces.  Otheriwse it returns a mapping of a specific\n+// network interfaces.  Otherwise it returns a mapping of a specific\n // interface.\n func interfaceTable(ifindex int) ([]Interface, error) {\n-\tvar ift []Interface\n-\n \ttab, err := syscall.RouteRIB(syscall.NET_RT_IFLIST, ifindex)\n \tif err != nil {\n \t\treturn nil, os.NewSyscallError(\"route rib\", err)\n@@ -30,6 +28,7 @@ func interfaceTable(ifindex int) ([]Interface, error) {\n \t\treturn nil, os.NewSyscallError(\"route message\", err)\n \t}\n \n+\tvar ift []Interface\n \tfor _, m := range msgs {\n \t\tswitch v := m.(type) {\n \t\tcase *syscall.InterfaceMessage:\n@@ -42,18 +41,16 @@ func interfaceTable(ifindex int) ([]Interface, error) {\n \t\t\t}\n \t\t}\n \t}\n-\n \treturn ift, nil\n }\n \n func newLink(m *syscall.InterfaceMessage) ([]Interface, error) {\n-\tvar ift []Interface\n-\n \tsas, err := syscall.ParseRoutingSockaddr(m)\n \tif err != nil {\n \t\treturn nil, os.NewSyscallError(\"route sockaddr\", err)\n \t}\n \n+\tvar ift []Interface\n \tfor _, s := range sas {\n \t\tswitch v := s.(type) {\n \t\tcase *syscall.SockaddrDatalink:\n@@ -75,7 +72,6 @@ func newLink(m *syscall.InterfaceMessage) ([]Interface, error) {\n \t\t\tift = append(ift, ifi)\n \t\t}\n \t}\n-\n \treturn ift, nil\n }\n \n@@ -103,8 +99,6 @@ func linkFlags(rawFlags int32) Flags {\n // for all network interfaces.  Otherwise it returns addresses\n // for a specific interface.\n func interfaceAddrTable(ifindex int) ([]Addr, error) {\n-\tvar ifat []Addr\n-\n \ttab, err := syscall.RouteRIB(syscall.NET_RT_IFLIST, ifindex)\n \tif err != nil {\n \t\treturn nil, os.NewSyscallError(\"route rib\", err)\n@@ -115,6 +109,7 @@ func interfaceAddrTable(ifindex int) ([]Addr, error) {\n \t\treturn nil, os.NewSyscallError(\"route message\", err)\n \t}\n \n+\tvar ifat []Addr\n \tfor _, m := range msgs {\n \t\tswitch v := m.(type) {\n \t\tcase *syscall.InterfaceAddrMessage:\n@@ -127,18 +122,16 @@ func interfaceAddrTable(ifindex int) ([]Addr, error) {\n \t\t\t}\n \t\t}\n \t}\n-\n \treturn ifat, nil\n }\n \n func newAddr(m *syscall.InterfaceAddrMessage) (Addr, error) {\n-\tifa := &IPNet{}\n-\n \tsas, err := syscall.ParseRoutingSockaddr(m)\n \tif err != nil {\n \t\treturn nil, os.NewSyscallError(\"route sockaddr\", err)\n \t}\n \n+\tifa := &IPNet{}\n \tfor i, s := range sas {\n \t\tswitch v := s.(type) {\n \t\tcase *syscall.SockaddrInet4:\n@@ -166,6 +159,5 @@ func newAddr(m *syscall.InterfaceAddrMessage) (Addr, error) {\n \t\t\t}\n \t\t}\n \t}\n-\n \treturn ifa, nil\n }"}, {"sha": "0b5fb5fb9da11b7b3abfaa659b9f5a3ec0de70de", "filename": "libgo/go/net/interface_darwin.go", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Finterface_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Finterface_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_darwin.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -15,23 +15,17 @@ import (\n // addresses for all network interfaces.  Otherwise it returns\n // addresses for a specific interface.\n func interfaceMulticastAddrTable(ifindex int) ([]Addr, error) {\n-\tvar (\n-\t\ttab   []byte\n-\t\te     error\n-\t\tmsgs  []syscall.RoutingMessage\n-\t\tifmat []Addr\n-\t)\n-\n-\ttab, e = syscall.RouteRIB(syscall.NET_RT_IFLIST2, ifindex)\n-\tif e != nil {\n-\t\treturn nil, os.NewSyscallError(\"route rib\", e)\n+\ttab, err := syscall.RouteRIB(syscall.NET_RT_IFLIST2, ifindex)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"route rib\", err)\n \t}\n \n-\tmsgs, e = syscall.ParseRoutingMessage(tab)\n-\tif e != nil {\n-\t\treturn nil, os.NewSyscallError(\"route message\", e)\n+\tmsgs, err := syscall.ParseRoutingMessage(tab)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"route message\", err)\n \t}\n \n+\tvar ifmat []Addr\n \tfor _, m := range msgs {\n \t\tswitch v := m.(type) {\n \t\tcase *syscall.InterfaceMulticastAddrMessage:\n@@ -44,18 +38,16 @@ func interfaceMulticastAddrTable(ifindex int) ([]Addr, error) {\n \t\t\t}\n \t\t}\n \t}\n-\n \treturn ifmat, nil\n }\n \n func newMulticastAddr(m *syscall.InterfaceMulticastAddrMessage) ([]Addr, error) {\n-\tvar ifmat []Addr\n-\n-\tsas, e := syscall.ParseRoutingSockaddr(m)\n-\tif e != nil {\n-\t\treturn nil, os.NewSyscallError(\"route sockaddr\", e)\n+\tsas, err := syscall.ParseRoutingSockaddr(m)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"route sockaddr\", err)\n \t}\n \n+\tvar ifmat []Addr\n \tfor _, s := range sas {\n \t\tswitch v := s.(type) {\n \t\tcase *syscall.SockaddrInet4:\n@@ -75,6 +67,5 @@ func newMulticastAddr(m *syscall.InterfaceMulticastAddrMessage) ([]Addr, error)\n \t\t\tifmat = append(ifmat, ifma.toAddr())\n \t\t}\n \t}\n-\n \treturn ifmat, nil\n }"}, {"sha": "3cba28fc6961d896d5cac4b2d1aa19c553c7ab0b", "filename": "libgo/go/net/interface_freebsd.go", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Finterface_freebsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Finterface_freebsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_freebsd.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -15,23 +15,17 @@ import (\n // addresses for all network interfaces.  Otherwise it returns\n // addresses for a specific interface.\n func interfaceMulticastAddrTable(ifindex int) ([]Addr, error) {\n-\tvar (\n-\t\ttab   []byte\n-\t\te     error\n-\t\tmsgs  []syscall.RoutingMessage\n-\t\tifmat []Addr\n-\t)\n-\n-\ttab, e = syscall.RouteRIB(syscall.NET_RT_IFMALIST, ifindex)\n-\tif e != nil {\n-\t\treturn nil, os.NewSyscallError(\"route rib\", e)\n+\ttab, err := syscall.RouteRIB(syscall.NET_RT_IFMALIST, ifindex)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"route rib\", err)\n \t}\n \n-\tmsgs, e = syscall.ParseRoutingMessage(tab)\n-\tif e != nil {\n-\t\treturn nil, os.NewSyscallError(\"route message\", e)\n+\tmsgs, err := syscall.ParseRoutingMessage(tab)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"route message\", err)\n \t}\n \n+\tvar ifmat []Addr\n \tfor _, m := range msgs {\n \t\tswitch v := m.(type) {\n \t\tcase *syscall.InterfaceMulticastAddrMessage:\n@@ -44,18 +38,16 @@ func interfaceMulticastAddrTable(ifindex int) ([]Addr, error) {\n \t\t\t}\n \t\t}\n \t}\n-\n \treturn ifmat, nil\n }\n \n func newMulticastAddr(m *syscall.InterfaceMulticastAddrMessage) ([]Addr, error) {\n-\tvar ifmat []Addr\n-\n-\tsas, e := syscall.ParseRoutingSockaddr(m)\n-\tif e != nil {\n-\t\treturn nil, os.NewSyscallError(\"route sockaddr\", e)\n+\tsas, err := syscall.ParseRoutingSockaddr(m)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"route sockaddr\", err)\n \t}\n \n+\tvar ifmat []Addr\n \tfor _, s := range sas {\n \t\tswitch v := s.(type) {\n \t\tcase *syscall.SockaddrInet4:\n@@ -75,6 +67,5 @@ func newMulticastAddr(m *syscall.InterfaceMulticastAddrMessage) ([]Addr, error)\n \t\t\tifmat = append(ifmat, ifma.toAddr())\n \t\t}\n \t}\n-\n \treturn ifmat, nil\n }"}, {"sha": "21038c629b13e42e1e1e52bbdf87e78eee1f89ec", "filename": "libgo/go/net/interface_linux.go", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Finterface_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Finterface_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_linux.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -17,8 +17,6 @@ import (\n // network interfaces.  Otheriwse it returns a mapping of a specific\n // interface.\n func interfaceTable(ifindex int) ([]Interface, error) {\n-\tvar ift []Interface\n-\n \ttab, err := syscall.NetlinkRIB(syscall.RTM_GETLINK, syscall.AF_UNSPEC)\n \tif err != nil {\n \t\treturn nil, os.NewSyscallError(\"netlink rib\", err)\n@@ -29,6 +27,7 @@ func interfaceTable(ifindex int) ([]Interface, error) {\n \t\treturn nil, os.NewSyscallError(\"netlink message\", err)\n \t}\n \n+\tvar ift []Interface\n \tfor _, m := range msgs {\n \t\tswitch m.Header.Type {\n \t\tcase syscall.NLMSG_DONE:\n@@ -45,7 +44,6 @@ func interfaceTable(ifindex int) ([]Interface, error) {\n \t\t\t}\n \t\t}\n \t}\n-\n done:\n \treturn ift, nil\n }\n@@ -111,13 +109,11 @@ func interfaceAddrTable(ifindex int) ([]Addr, error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\n \treturn ifat, nil\n }\n \n func addrTable(msgs []syscall.NetlinkMessage, ifindex int) ([]Addr, error) {\n \tvar ifat []Addr\n-\n \tfor _, m := range msgs {\n \t\tswitch m.Header.Type {\n \t\tcase syscall.NLMSG_DONE:\n@@ -133,7 +129,6 @@ func addrTable(msgs []syscall.NetlinkMessage, ifindex int) ([]Addr, error) {\n \t\t\t}\n \t\t}\n \t}\n-\n done:\n \treturn ifat, nil\n }\n@@ -165,32 +160,28 @@ func interfaceMulticastAddrTable(ifindex int) ([]Addr, error) {\n \t\terr error\n \t\tifi *Interface\n \t)\n-\n \tif ifindex > 0 {\n \t\tifi, err = InterfaceByIndex(ifindex)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n \t}\n-\n \tifmat4 := parseProcNetIGMP(ifi)\n \tifmat6 := parseProcNetIGMP6(ifi)\n-\n \treturn append(ifmat4, ifmat6...), nil\n }\n \n func parseProcNetIGMP(ifi *Interface) []Addr {\n-\tvar (\n-\t\tifmat []Addr\n-\t\tname  string\n-\t)\n-\n \tfd, err := open(\"/proc/net/igmp\")\n \tif err != nil {\n \t\treturn nil\n \t}\n \tdefer fd.close()\n \n+\tvar (\n+\t\tifmat []Addr\n+\t\tname  string\n+\t)\n \tfd.readLine() // skip first line\n \tb := make([]byte, IPv4len)\n \tfor l, ok := fd.readLine(); ok; l, ok = fd.readLine() {\n@@ -206,19 +197,17 @@ func parseProcNetIGMP(ifi *Interface) []Addr {\n \t\t\tname = f[1]\n \t\t}\n \t}\n-\n \treturn ifmat\n }\n \n func parseProcNetIGMP6(ifi *Interface) []Addr {\n-\tvar ifmat []Addr\n-\n \tfd, err := open(\"/proc/net/igmp6\")\n \tif err != nil {\n \t\treturn nil\n \t}\n \tdefer fd.close()\n \n+\tvar ifmat []Addr\n \tb := make([]byte, IPv6len)\n \tfor l, ok := fd.readLine(); ok; l, ok = fd.readLine() {\n \t\tf := getFields(l)\n@@ -229,6 +218,5 @@ func parseProcNetIGMP6(ifi *Interface) []Addr {\n \n \t\t}\n \t}\n-\n \treturn ifmat\n }"}, {"sha": "d0c97532699bd411a7a65a3c522cda5ae937d087", "filename": "libgo/go/net/interface_windows.go", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Finterface_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Finterface_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_windows.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -25,31 +25,31 @@ func getAdapterList() (*syscall.IpAdapterInfo, error) {\n \tb := make([]byte, 1000)\n \tl := uint32(len(b))\n \ta := (*syscall.IpAdapterInfo)(unsafe.Pointer(&b[0]))\n-\te := syscall.GetAdaptersInfo(a, &l)\n-\tif e == syscall.ERROR_BUFFER_OVERFLOW {\n+\terr := syscall.GetAdaptersInfo(a, &l)\n+\tif err == syscall.ERROR_BUFFER_OVERFLOW {\n \t\tb = make([]byte, l)\n \t\ta = (*syscall.IpAdapterInfo)(unsafe.Pointer(&b[0]))\n-\t\te = syscall.GetAdaptersInfo(a, &l)\n+\t\terr = syscall.GetAdaptersInfo(a, &l)\n \t}\n-\tif e != nil {\n-\t\treturn nil, os.NewSyscallError(\"GetAdaptersInfo\", e)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"GetAdaptersInfo\", err)\n \t}\n \treturn a, nil\n }\n \n func getInterfaceList() ([]syscall.InterfaceInfo, error) {\n-\ts, e := syscall.Socket(syscall.AF_INET, syscall.SOCK_DGRAM, syscall.IPPROTO_UDP)\n-\tif e != nil {\n-\t\treturn nil, os.NewSyscallError(\"Socket\", e)\n+\ts, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_DGRAM, syscall.IPPROTO_UDP)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"Socket\", err)\n \t}\n \tdefer syscall.Closesocket(s)\n \n \tii := [20]syscall.InterfaceInfo{}\n \tret := uint32(0)\n \tsize := uint32(unsafe.Sizeof(ii))\n-\te = syscall.WSAIoctl(s, syscall.SIO_GET_INTERFACE_LIST, nil, 0, (*byte)(unsafe.Pointer(&ii[0])), size, &ret, nil, 0)\n-\tif e != nil {\n-\t\treturn nil, os.NewSyscallError(\"WSAIoctl\", e)\n+\terr = syscall.WSAIoctl(s, syscall.SIO_GET_INTERFACE_LIST, nil, 0, (*byte)(unsafe.Pointer(&ii[0])), size, &ret, nil, 0)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"WSAIoctl\", err)\n \t}\n \tc := ret / uint32(unsafe.Sizeof(ii[0]))\n \treturn ii[:c-1], nil\n@@ -59,14 +59,14 @@ func getInterfaceList() ([]syscall.InterfaceInfo, error) {\n // network interfaces.  Otheriwse it returns a mapping of a specific\n // interface.\n func interfaceTable(ifindex int) ([]Interface, error) {\n-\tai, e := getAdapterList()\n-\tif e != nil {\n-\t\treturn nil, e\n+\tai, err := getAdapterList()\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n \n-\tii, e := getInterfaceList()\n-\tif e != nil {\n-\t\treturn nil, e\n+\tii, err := getInterfaceList()\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n \n \tvar ift []Interface\n@@ -130,9 +130,9 @@ func interfaceTable(ifindex int) ([]Interface, error) {\n // for all network interfaces.  Otherwise it returns addresses\n // for a specific interface.\n func interfaceAddrTable(ifindex int) ([]Addr, error) {\n-\tai, e := getAdapterList()\n-\tif e != nil {\n-\t\treturn nil, e\n+\tai, err := getAdapterList()\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n \n \tvar ifat []Addr"}, {"sha": "382a4402770c29ed561400885087114eb9e4429b", "filename": "libgo/go/net/iprawsock_plan9.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -15,17 +15,17 @@ import (\n // interfaces for IP network connections.\n type IPConn bool\n \n-// SetDeadline implements the net.Conn SetDeadline method.\n+// SetDeadline implements the Conn SetDeadline method.\n func (c *IPConn) SetDeadline(t time.Time) error {\n \treturn os.EPLAN9\n }\n \n-// SetReadDeadline implements the net.Conn SetReadDeadline method.\n+// SetReadDeadline implements the Conn SetReadDeadline method.\n func (c *IPConn) SetReadDeadline(t time.Time) error {\n \treturn os.EPLAN9\n }\n \n-// SetWriteDeadline implements the net.Conn SetWriteDeadline method.\n+// SetWriteDeadline implements the Conn SetWriteDeadline method.\n func (c *IPConn) SetWriteDeadline(t time.Time) error {\n \treturn os.EPLAN9\n }"}, {"sha": "bfbce18a4147f432a3acbe0a2a5163589898f77b", "filename": "libgo/go/net/ipsock.go", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fipsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fipsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -99,16 +99,12 @@ func JoinHostPort(host, port string) string {\n \n // Convert \"host:port\" into IP address and port.\n func hostPortToIP(net, hostport string) (ip IP, iport int, err error) {\n-\tvar (\n-\t\taddr IP\n-\t\tp, i int\n-\t\tok   bool\n-\t)\n \thost, port, err := SplitHostPort(hostport)\n \tif err != nil {\n-\t\tgoto Error\n+\t\treturn nil, 0, err\n \t}\n \n+\tvar addr IP\n \tif host != \"\" {\n \t\t// Try as an IP address.\n \t\taddr = ParseIP(host)\n@@ -121,34 +117,29 @@ func hostPortToIP(net, hostport string) (ip IP, iport int, err error) {\n \t\t\t\tfilter = ipv6only\n \t\t\t}\n \t\t\t// Not an IP address.  Try as a DNS name.\n-\t\t\taddrs, err1 := LookupHost(host)\n-\t\t\tif err1 != nil {\n-\t\t\t\terr = err1\n-\t\t\t\tgoto Error\n+\t\t\taddrs, err := LookupHost(host)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, 0, err\n \t\t\t}\n \t\t\taddr = firstFavoriteAddr(filter, addrs)\n \t\t\tif addr == nil {\n \t\t\t\t// should not happen\n-\t\t\t\terr = &AddrError{\"LookupHost returned no suitable address\", addrs[0]}\n-\t\t\t\tgoto Error\n+\t\t\t\treturn nil, 0, &AddrError{\"LookupHost returned no suitable address\", addrs[0]}\n \t\t\t}\n \t\t}\n \t}\n \n-\tp, i, ok = dtoi(port, 0)\n+\tp, i, ok := dtoi(port, 0)\n \tif !ok || i != len(port) {\n \t\tp, err = LookupPort(net, port)\n \t\tif err != nil {\n-\t\t\tgoto Error\n+\t\t\treturn nil, 0, err\n \t\t}\n \t}\n \tif p < 0 || p > 0xFFFF {\n-\t\terr = &AddrError{\"invalid port\", port}\n-\t\tgoto Error\n+\t\treturn nil, 0, &AddrError{\"invalid port\", port}\n \t}\n \n \treturn addr, p, nil\n \n-Error:\n-\treturn nil, 0, err\n }"}, {"sha": "597b1277544791d1e9ab80a3ff6dac4366029f23", "filename": "libgo/go/net/ipsock_plan9.go", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fipsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fipsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock_plan9.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -22,33 +22,22 @@ func probeIPv6Stack() (supportsIPv6, supportsIPv4map bool) {\n \n // parsePlan9Addr parses address of the form [ip!]port (e.g. 127.0.0.1!80).\n func parsePlan9Addr(s string) (ip IP, iport int, err error) {\n-\tvar (\n-\t\taddr IP\n-\t\tp, i int\n-\t\tok   bool\n-\t)\n-\taddr = IPv4zero // address contains port only\n-\ti = byteIndex(s, '!')\n+\taddr := IPv4zero // address contains port only\n+\ti := byteIndex(s, '!')\n \tif i >= 0 {\n \t\taddr = ParseIP(s[:i])\n \t\tif addr == nil {\n-\t\t\terr = errors.New(\"net: parsing IP failed\")\n-\t\t\tgoto Error\n+\t\t\treturn nil, 0, errors.New(\"net: parsing IP failed\")\n \t\t}\n \t}\n-\tp, _, ok = dtoi(s[i+1:], 0)\n+\tp, _, ok := dtoi(s[i+1:], 0)\n \tif !ok {\n-\t\terr = errors.New(\"net: parsing port failed\")\n-\t\tgoto Error\n+\t\treturn nil, 0, errors.New(\"net: parsing port failed\")\n \t}\n \tif p < 0 || p > 0xFFFF {\n-\t\terr = &AddrError{\"invalid port\", string(p)}\n-\t\tgoto Error\n+\t\treturn nil, 0, &AddrError{\"invalid port\", string(p)}\n \t}\n \treturn addr, p, nil\n-\n-Error:\n-\treturn nil, 0, err\n }\n \n func readPlan9Addr(proto, filename string) (addr Addr, err error) {\n@@ -91,7 +80,7 @@ func (c *plan9Conn) ok() bool { return c != nil && c.ctl != nil }\n \n // Implementation of the Conn interface - see Conn for documentation.\n \n-// Read implements the net.Conn Read method.\n+// Read implements the Conn Read method.\n func (c *plan9Conn) Read(b []byte) (n int, err error) {\n \tif !c.ok() {\n \t\treturn 0, os.EINVAL\n@@ -110,7 +99,7 @@ func (c *plan9Conn) Read(b []byte) (n int, err error) {\n \treturn\n }\n \n-// Write implements the net.Conn Write method.\n+// Write implements the Conn Write method.\n func (c *plan9Conn) Write(b []byte) (n int, err error) {\n \tif !c.ok() {\n \t\treturn 0, os.EINVAL\n@@ -157,17 +146,17 @@ func (c *plan9Conn) RemoteAddr() Addr {\n \treturn c.raddr\n }\n \n-// SetDeadline implements the net.Conn SetDeadline method.\n+// SetDeadline implements the Conn SetDeadline method.\n func (c *plan9Conn) SetDeadline(t time.Time) error {\n \treturn os.EPLAN9\n }\n \n-// SetReadDeadline implements the net.Conn SetReadDeadline method.\n+// SetReadDeadline implements the Conn SetReadDeadline method.\n func (c *plan9Conn) SetReadDeadline(t time.Time) error {\n \treturn os.EPLAN9\n }\n \n-// SetWriteDeadline implements the net.Conn SetWriteDeadline method.\n+// SetWriteDeadline implements the Conn SetWriteDeadline method.\n func (c *plan9Conn) SetWriteDeadline(t time.Time) error {\n \treturn os.EPLAN9\n }"}, {"sha": "99783e975679634bea09e95ce99c7996d23749d4", "filename": "libgo/go/net/lookup_windows.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Flookup_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Flookup_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_windows.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -21,9 +21,9 @@ var (\n func lookupProtocol(name string) (proto int, err error) {\n \tprotoentLock.Lock()\n \tdefer protoentLock.Unlock()\n-\tp, e := syscall.GetProtoByName(name)\n-\tif e != nil {\n-\t\treturn 0, os.NewSyscallError(\"GetProtoByName\", e)\n+\tp, err := syscall.GetProtoByName(name)\n+\tif err != nil {\n+\t\treturn 0, os.NewSyscallError(\"GetProtoByName\", err)\n \t}\n \treturn int(p.Proto), nil\n }\n@@ -43,9 +43,9 @@ func lookupHost(name string) (addrs []string, err error) {\n func lookupIP(name string) (addrs []IP, err error) {\n \thostentLock.Lock()\n \tdefer hostentLock.Unlock()\n-\th, e := syscall.GetHostByName(name)\n-\tif e != nil {\n-\t\treturn nil, os.NewSyscallError(\"GetHostByName\", e)\n+\th, err := syscall.GetHostByName(name)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"GetHostByName\", err)\n \t}\n \tswitch h.AddrType {\n \tcase syscall.AF_INET:\n@@ -70,9 +70,9 @@ func lookupPort(network, service string) (port int, err error) {\n \t}\n \tserventLock.Lock()\n \tdefer serventLock.Unlock()\n-\ts, e := syscall.GetServByName(service, network)\n-\tif e != nil {\n-\t\treturn 0, os.NewSyscallError(\"GetServByName\", e)\n+\ts, err := syscall.GetServByName(service, network)\n+\tif err != nil {\n+\t\treturn 0, os.NewSyscallError(\"GetServByName\", err)\n \t}\n \treturn int(syscall.Ntohs(s.Port)), nil\n }"}, {"sha": "bf0fe4d8d0a20e28334836a3a7fae487bc8d7169", "filename": "libgo/go/net/multicast_test.go", "status": "modified", "additions": 33, "deletions": 53, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fmulticast_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fmulticast_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmulticast_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -5,54 +5,48 @@\n package net\n \n import (\n-\t\"flag\"\n \t\"os\"\n \t\"runtime\"\n \t\"testing\"\n )\n \n-var multicast = flag.Bool(\"multicast\", false, \"enable multicast tests\")\n-\n-var multicastUDPTests = []struct {\n+var listenMulticastUDPTests = []struct {\n \tnet   string\n-\tladdr IP\n-\tgaddr IP\n+\tgaddr *UDPAddr\n \tflags Flags\n \tipv6  bool\n }{\n \t// cf. RFC 4727: Experimental Values in IPv4, IPv6, ICMPv4, ICMPv6, UDP, and TCP Headers\n-\t{\"udp\", IPv4zero, IPv4(224, 0, 0, 254), (FlagUp | FlagLoopback), false},\n-\t{\"udp4\", IPv4zero, IPv4(224, 0, 0, 254), (FlagUp | FlagLoopback), false},\n-\t{\"udp\", IPv6unspecified, ParseIP(\"ff0e::114\"), (FlagUp | FlagLoopback), true},\n-\t{\"udp6\", IPv6unspecified, ParseIP(\"ff01::114\"), (FlagUp | FlagLoopback), true},\n-\t{\"udp6\", IPv6unspecified, ParseIP(\"ff02::114\"), (FlagUp | FlagLoopback), true},\n-\t{\"udp6\", IPv6unspecified, ParseIP(\"ff04::114\"), (FlagUp | FlagLoopback), true},\n-\t{\"udp6\", IPv6unspecified, ParseIP(\"ff05::114\"), (FlagUp | FlagLoopback), true},\n-\t{\"udp6\", IPv6unspecified, ParseIP(\"ff08::114\"), (FlagUp | FlagLoopback), true},\n-\t{\"udp6\", IPv6unspecified, ParseIP(\"ff0e::114\"), (FlagUp | FlagLoopback), true},\n+\t{\"udp\", &UDPAddr{IPv4(224, 0, 0, 254), 12345}, FlagUp | FlagLoopback, false},\n+\t{\"udp4\", &UDPAddr{IPv4(224, 0, 0, 254), 12345}, FlagUp | FlagLoopback, false},\n+\t{\"udp\", &UDPAddr{ParseIP(\"ff0e::114\"), 12345}, FlagUp | FlagLoopback, true},\n+\t{\"udp6\", &UDPAddr{ParseIP(\"ff01::114\"), 12345}, FlagUp | FlagLoopback, true},\n+\t{\"udp6\", &UDPAddr{ParseIP(\"ff02::114\"), 12345}, FlagUp | FlagLoopback, true},\n+\t{\"udp6\", &UDPAddr{ParseIP(\"ff04::114\"), 12345}, FlagUp | FlagLoopback, true},\n+\t{\"udp6\", &UDPAddr{ParseIP(\"ff05::114\"), 12345}, FlagUp | FlagLoopback, true},\n+\t{\"udp6\", &UDPAddr{ParseIP(\"ff08::114\"), 12345}, FlagUp | FlagLoopback, true},\n+\t{\"udp6\", &UDPAddr{ParseIP(\"ff0e::114\"), 12345}, FlagUp | FlagLoopback, true},\n }\n \n-func TestMulticastUDP(t *testing.T) {\n-\tif runtime.GOOS == \"plan9\" || runtime.GOOS == \"windows\" {\n-\t\treturn\n-\t}\n-\tif !*multicast {\n-\t\tt.Logf(\"test disabled; use --multicast to enable\")\n+func TestListenMulticastUDP(t *testing.T) {\n+\tswitch runtime.GOOS {\n+\tcase \"netbsd\", \"openbsd\", \"plan9\", \"windows\":\n \t\treturn\n+\tcase \"linux\":\n+\t\tif runtime.GOARCH == \"arm\" {\n+\t\t\treturn\n+\t\t}\n \t}\n \n-\tfor _, tt := range multicastUDPTests {\n-\t\tvar (\n-\t\t\tifi   *Interface\n-\t\t\tfound bool\n-\t\t)\n+\tfor _, tt := range listenMulticastUDPTests {\n \t\tif tt.ipv6 && (!supportsIPv6 || os.Getuid() != 0) {\n \t\t\tcontinue\n \t\t}\n \t\tift, err := Interfaces()\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"Interfaces failed: %v\", err)\n \t\t}\n+\t\tvar ifi *Interface\n \t\tfor _, x := range ift {\n \t\t\tif x.Flags&tt.flags == tt.flags {\n \t\t\t\tifi = &x\n@@ -63,14 +57,11 @@ func TestMulticastUDP(t *testing.T) {\n \t\t\tt.Logf(\"an appropriate multicast interface not found\")\n \t\t\treturn\n \t\t}\n-\t\tc, err := ListenUDP(tt.net, &UDPAddr{IP: tt.laddr})\n+\t\tc, err := ListenMulticastUDP(tt.net, ifi, tt.gaddr)\n \t\tif err != nil {\n-\t\t\tt.Fatalf(\"ListenUDP failed: %v\", err)\n-\t\t}\n-\t\tdefer c.Close()\n-\t\tif err := c.JoinGroup(ifi, tt.gaddr); err != nil {\n-\t\t\tt.Fatalf(\"JoinGroup failed: %v\", err)\n+\t\t\tt.Fatalf(\"ListenMulticastUDP failed: %v\", err)\n \t\t}\n+\t\tdefer c.Close() // test to listen concurrently across multiple listeners\n \t\tif !tt.ipv6 {\n \t\t\ttestIPv4MulticastSocketOptions(t, c.fd, ifi)\n \t\t} else {\n@@ -80,32 +71,26 @@ func TestMulticastUDP(t *testing.T) {\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"MulticastAddrs failed: %v\", err)\n \t\t}\n+\t\tvar found bool\n \t\tfor _, ifma := range ifmat {\n-\t\t\tif ifma.(*IPAddr).IP.Equal(tt.gaddr) {\n+\t\t\tif ifma.(*IPAddr).IP.Equal(tt.gaddr.IP) {\n \t\t\t\tfound = true\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n \t\tif !found {\n \t\t\tt.Fatalf(\"%q not found in RIB\", tt.gaddr.String())\n \t\t}\n-\t\tif err := c.LeaveGroup(ifi, tt.gaddr); err != nil {\n-\t\t\tt.Fatalf(\"LeaveGroup failed: %v\", err)\n-\t\t}\n \t}\n }\n \n-func TestSimpleMulticastUDP(t *testing.T) {\n-\tif runtime.GOOS == \"plan9\" {\n-\t\treturn\n-\t}\n-\tif !*multicast {\n-\t\tt.Logf(\"test disabled; use --multicast to enable\")\n+func TestSimpleListenMulticastUDP(t *testing.T) {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\":\n \t\treturn\n \t}\n \n-\tfor _, tt := range multicastUDPTests {\n-\t\tvar ifi *Interface\n+\tfor _, tt := range listenMulticastUDPTests {\n \t\tif tt.ipv6 {\n \t\t\tcontinue\n \t\t}\n@@ -114,6 +99,7 @@ func TestSimpleMulticastUDP(t *testing.T) {\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"Interfaces failed: %v\", err)\n \t\t}\n+\t\tvar ifi *Interface\n \t\tfor _, x := range ift {\n \t\t\tif x.Flags&tt.flags == tt.flags {\n \t\t\t\tifi = &x\n@@ -124,17 +110,11 @@ func TestSimpleMulticastUDP(t *testing.T) {\n \t\t\tt.Logf(\"an appropriate multicast interface not found\")\n \t\t\treturn\n \t\t}\n-\t\tc, err := ListenUDP(tt.net, &UDPAddr{IP: tt.laddr})\n+\t\tc, err := ListenMulticastUDP(tt.net, ifi, tt.gaddr)\n \t\tif err != nil {\n-\t\t\tt.Fatalf(\"ListenUDP failed: %v\", err)\n-\t\t}\n-\t\tdefer c.Close()\n-\t\tif err := c.JoinGroup(ifi, tt.gaddr); err != nil {\n-\t\t\tt.Fatalf(\"JoinGroup failed: %v\", err)\n-\t\t}\n-\t\tif err := c.LeaveGroup(ifi, tt.gaddr); err != nil {\n-\t\t\tt.Fatalf(\"LeaveGroup failed: %v\", err)\n+\t\t\tt.Fatalf(\"ListenMulticastUDP failed: %v\", err)\n \t\t}\n+\t\tc.Close()\n \t}\n }\n "}, {"sha": "79d36a2a8136d00a2d5f6290e95e18cc8e9e5e28", "filename": "libgo/go/net/net.go", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fnet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fnet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -23,12 +23,12 @@ type Addr interface {\n // Conn is a generic stream-oriented network connection.\n type Conn interface {\n \t// Read reads data from the connection.\n-\t// Read can be made to time out and return a net.Error with Timeout() == true\n+\t// Read can be made to time out and return a Error with Timeout() == true\n \t// after a fixed time limit; see SetDeadline and SetReadDeadline.\n \tRead(b []byte) (n int, err error)\n \n \t// Write writes data to the connection.\n-\t// Write can be made to time out and return a net.Error with Timeout() == true\n+\t// Write can be made to time out and return a Error with Timeout() == true\n \t// after a fixed time limit; see SetDeadline and SetWriteDeadline.\n \tWrite(b []byte) (n int, err error)\n \n@@ -201,3 +201,15 @@ type UnknownNetworkError string\n func (e UnknownNetworkError) Error() string   { return \"unknown network \" + string(e) }\n func (e UnknownNetworkError) Temporary() bool { return false }\n func (e UnknownNetworkError) Timeout() bool   { return false }\n+\n+// DNSConfigError represents an error reading the machine's DNS configuration.\n+type DNSConfigError struct {\n+\tErr error\n+}\n+\n+func (e *DNSConfigError) Error() string {\n+\treturn \"error reading DNS config: \" + e.Err.Error()\n+}\n+\n+func (e *DNSConfigError) Timeout() bool   { return false }\n+func (e *DNSConfigError) Temporary() bool { return false }"}, {"sha": "1bc997754bb37ac6311e244d248c2b8f6af9615c", "filename": "libgo/go/net/net_test.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fnet_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fnet_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -71,15 +71,15 @@ func TestDialError(t *testing.T) {\n \t\treturn\n \t}\n \tfor i, tt := range dialErrorTests {\n-\t\tc, e := Dial(tt.Net, tt.Raddr)\n+\t\tc, err := Dial(tt.Net, tt.Raddr)\n \t\tif c != nil {\n \t\t\tc.Close()\n \t\t}\n-\t\tif e == nil {\n+\t\tif err == nil {\n \t\t\tt.Errorf(\"#%d: nil error, want match for %#q\", i, tt.Pattern)\n \t\t\tcontinue\n \t\t}\n-\t\ts := e.Error()\n+\t\ts := err.Error()\n \t\tmatch, _ := regexp.MatchString(tt.Pattern, s)\n \t\tif !match {\n \t\t\tt.Errorf(\"#%d: %q, want match for %#q\", i, s, tt.Pattern)\n@@ -111,16 +111,16 @@ var revAddrTests = []struct {\n \n func TestReverseAddress(t *testing.T) {\n \tfor i, tt := range revAddrTests {\n-\t\ta, e := reverseaddr(tt.Addr)\n-\t\tif len(tt.ErrPrefix) > 0 && e == nil {\n+\t\ta, err := reverseaddr(tt.Addr)\n+\t\tif len(tt.ErrPrefix) > 0 && err == nil {\n \t\t\tt.Errorf(\"#%d: expected %q, got <nil> (error)\", i, tt.ErrPrefix)\n \t\t\tcontinue\n \t\t}\n-\t\tif len(tt.ErrPrefix) == 0 && e != nil {\n-\t\t\tt.Errorf(\"#%d: expected <nil>, got %q (error)\", i, e)\n+\t\tif len(tt.ErrPrefix) == 0 && err != nil {\n+\t\t\tt.Errorf(\"#%d: expected <nil>, got %q (error)\", i, err)\n \t\t}\n-\t\tif e != nil && e.(*DNSError).Err != tt.ErrPrefix {\n-\t\t\tt.Errorf(\"#%d: expected %q, got %q (mismatched error)\", i, tt.ErrPrefix, e.(*DNSError).Err)\n+\t\tif err != nil && err.(*DNSError).Err != tt.ErrPrefix {\n+\t\t\tt.Errorf(\"#%d: expected %q, got %q (mismatched error)\", i, tt.ErrPrefix, err.(*DNSError).Err)\n \t\t}\n \t\tif a != tt.Reverse {\n \t\t\tt.Errorf(\"#%d: expected %q, got %q (reverse address)\", i, tt.Reverse, a)"}, {"sha": "06bc24cd8a23178df388cf27e1487daaa5eddcda", "filename": "libgo/go/net/newpollserver.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fnewpollserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fnewpollserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnewpollserver.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -36,7 +36,11 @@ func newPollServer() (s *pollServer, err error) {\n \treturn s, nil\n \n Errno:\n-\terr = &os.PathError{\"setnonblock\", s.pr.Name(), err}\n+\terr = &os.PathError{\n+\t\tOp:   \"setnonblock\",\n+\t\tPath: s.pr.Name(),\n+\t\tErr:  err,\n+\t}\n Error:\n \ts.pr.Close()\n \ts.pw.Close()"}, {"sha": "34f9ae317e28822925c6d94ee1279daa4849754e", "filename": "libgo/go/net/rpc/client.go", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Frpc%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Frpc%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Frpc%2Fclient.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -31,8 +31,7 @@ type Call struct {\n \tArgs          interface{} // The argument to the function (*struct).\n \tReply         interface{} // The reply from the function (*struct).\n \tError         error       // After completion, the error status.\n-\tDone          chan *Call  // Strobes when call is complete; value is the error status.\n-\tseq           uint64\n+\tDone          chan *Call  // Strobes when call is complete.\n }\n \n // Client represents an RPC Client.\n@@ -65,28 +64,33 @@ type ClientCodec interface {\n \tClose() error\n }\n \n-func (client *Client) send(c *Call) {\n+func (client *Client) send(call *Call) {\n+\tclient.sending.Lock()\n+\tdefer client.sending.Unlock()\n+\n \t// Register this call.\n \tclient.mutex.Lock()\n \tif client.shutdown {\n-\t\tc.Error = ErrShutdown\n+\t\tcall.Error = ErrShutdown\n \t\tclient.mutex.Unlock()\n-\t\tc.done()\n+\t\tcall.done()\n \t\treturn\n \t}\n-\tc.seq = client.seq\n+\tseq := client.seq\n \tclient.seq++\n-\tclient.pending[c.seq] = c\n+\tclient.pending[seq] = call\n \tclient.mutex.Unlock()\n \n \t// Encode and send the request.\n-\tclient.sending.Lock()\n-\tdefer client.sending.Unlock()\n-\tclient.request.Seq = c.seq\n-\tclient.request.ServiceMethod = c.ServiceMethod\n-\tif err := client.codec.WriteRequest(&client.request, c.Args); err != nil {\n-\t\tc.Error = err\n-\t\tc.done()\n+\tclient.request.Seq = seq\n+\tclient.request.ServiceMethod = call.ServiceMethod\n+\terr := client.codec.WriteRequest(&client.request, call.Args)\n+\tif err != nil {\n+\t\tclient.mutex.Lock()\n+\t\tdelete(client.pending, seq)\n+\t\tclient.mutex.Unlock()\n+\t\tcall.Error = err\n+\t\tcall.done()\n \t}\n }\n \n@@ -104,36 +108,39 @@ func (client *Client) input() {\n \t\t}\n \t\tseq := response.Seq\n \t\tclient.mutex.Lock()\n-\t\tc := client.pending[seq]\n+\t\tcall := client.pending[seq]\n \t\tdelete(client.pending, seq)\n \t\tclient.mutex.Unlock()\n \n \t\tif response.Error == \"\" {\n-\t\t\terr = client.codec.ReadResponseBody(c.Reply)\n+\t\t\terr = client.codec.ReadResponseBody(call.Reply)\n \t\t\tif err != nil {\n-\t\t\t\tc.Error = errors.New(\"reading body \" + err.Error())\n+\t\t\t\tcall.Error = errors.New(\"reading body \" + err.Error())\n \t\t\t}\n \t\t} else {\n \t\t\t// We've got an error response. Give this to the request;\n \t\t\t// any subsequent requests will get the ReadResponseBody\n \t\t\t// error if there is one.\n-\t\t\tc.Error = ServerError(response.Error)\n+\t\t\tcall.Error = ServerError(response.Error)\n \t\t\terr = client.codec.ReadResponseBody(nil)\n \t\t\tif err != nil {\n \t\t\t\terr = errors.New(\"reading error body: \" + err.Error())\n \t\t\t}\n \t\t}\n-\t\tc.done()\n+\t\tcall.done()\n \t}\n \t// Terminate pending calls.\n+\tclient.sending.Lock()\n \tclient.mutex.Lock()\n \tclient.shutdown = true\n+\tclosing := client.closing\n \tfor _, call := range client.pending {\n \t\tcall.Error = err\n \t\tcall.done()\n \t}\n \tclient.mutex.Unlock()\n-\tif err != io.EOF || !client.closing {\n+\tclient.sending.Unlock()\n+\tif err != io.EOF || !closing {\n \t\tlog.Println(\"rpc: client protocol error:\", err)\n \t}\n }\n@@ -225,7 +232,12 @@ func DialHTTPPath(network, address, path string) (*Client, error) {\n \t\terr = errors.New(\"unexpected HTTP response: \" + resp.Status)\n \t}\n \tconn.Close()\n-\treturn nil, &net.OpError{\"dial-http\", network + \" \" + address, nil, err}\n+\treturn nil, &net.OpError{\n+\t\tOp:   \"dial-http\",\n+\t\tNet:  network + \" \" + address,\n+\t\tAddr: nil,\n+\t\tErr:  err,\n+\t}\n }\n \n // Dial connects to an RPC server at the specified network address.\n@@ -269,20 +281,12 @@ func (client *Client) Go(serviceMethod string, args interface{}, reply interface\n \t\t}\n \t}\n \tcall.Done = done\n-\tif client.shutdown {\n-\t\tcall.Error = ErrShutdown\n-\t\tcall.done()\n-\t\treturn call\n-\t}\n \tclient.send(call)\n \treturn call\n }\n \n // Call invokes the named function, waits for it to complete, and returns its error status.\n func (client *Client) Call(serviceMethod string, args interface{}, reply interface{}) error {\n-\tif client.shutdown {\n-\t\treturn ErrShutdown\n-\t}\n \tcall := <-client.Go(serviceMethod, args, reply, make(chan *Call, 1)).Done\n \treturn call.Error\n }"}, {"sha": "8cfa033ccc3be0adf8a62e712a86115a9f41371e", "filename": "libgo/go/net/rpc/server_test.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Frpc%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Frpc%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Frpc%2Fserver_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -442,8 +442,9 @@ func countMallocs(dial func() (*Client, error), t *testing.T) uint64 {\n \t}\n \targs := &Args{7, 8}\n \treply := new(Reply)\n-\truntime.UpdateMemStats()\n-\tmallocs := 0 - runtime.MemStats.Mallocs\n+\tmemstats := new(runtime.MemStats)\n+\truntime.ReadMemStats(memstats)\n+\tmallocs := 0 - memstats.Mallocs\n \tconst count = 100\n \tfor i := 0; i < count; i++ {\n \t\terr := client.Call(\"Arith.Add\", args, reply)\n@@ -454,8 +455,8 @@ func countMallocs(dial func() (*Client, error), t *testing.T) uint64 {\n \t\t\tt.Errorf(\"Add: expected %d got %d\", reply.C, args.A+args.B)\n \t\t}\n \t}\n-\truntime.UpdateMemStats()\n-\tmallocs += runtime.MemStats.Mallocs\n+\truntime.ReadMemStats(memstats)\n+\tmallocs += memstats.Mallocs\n \treturn mallocs / count\n }\n "}, {"sha": "7f51519b2ed13912407fd305a52f250e8c202503", "filename": "libgo/go/net/sendfile_linux.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fsendfile_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fsendfile_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsendfile_linux.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -48,23 +48,23 @@ func sendFile(c *netFD, r io.Reader) (written int64, err error, handled bool) {\n \t\tif int64(n) > remain {\n \t\t\tn = int(remain)\n \t\t}\n-\t\tn, errno := syscall.Sendfile(dst, src, nil, n)\n+\t\tn, err1 := syscall.Sendfile(dst, src, nil, n)\n \t\tif n > 0 {\n \t\t\twritten += int64(n)\n \t\t\tremain -= int64(n)\n \t\t}\n-\t\tif n == 0 && errno == nil {\n+\t\tif n == 0 && err1 == nil {\n \t\t\tbreak\n \t\t}\n-\t\tif errno == syscall.EAGAIN && c.wdeadline >= 0 {\n+\t\tif err1 == syscall.EAGAIN && c.wdeadline >= 0 {\n \t\t\tpollserver.WaitWrite(c)\n \t\t\tcontinue\n \t\t}\n-\t\tif errno != nil {\n+\t\tif err1 != nil {\n \t\t\t// This includes syscall.ENOSYS (no kernel\n \t\t\t// support) and syscall.EINVAL (fd types which\n \t\t\t// don't implement sendfile together)\n-\t\t\terr = &OpError{\"sendfile\", c.net, c.raddr, errno}\n+\t\t\terr = &OpError{\"sendfile\", c.net, c.raddr, err1}\n \t\t\tbreak\n \t\t}\n \t}"}, {"sha": "f600cc8648212182d99520f6464a2c2e7e248b51", "filename": "libgo/go/net/smtp/smtp.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fsmtp%2Fsmtp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fsmtp%2Fsmtp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsmtp%2Fsmtp.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -155,7 +155,7 @@ func (c *Client) Auth(a Auth) error {\n \t\t\t// the last message isn't base64 because it isn't a challenge\n \t\t\tmsg = []byte(msg64)\n \t\tdefault:\n-\t\t\terr = &textproto.Error{code, msg64}\n+\t\t\terr = &textproto.Error{Code: code, Msg: msg64}\n \t\t}\n \t\tresp, err = a.Next(msg, code == 334)\n \t\tif err != nil {"}, {"sha": "70064c307ef36b5319d3a341c5829ecf318325b7", "filename": "libgo/go/net/sock.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -10,7 +10,6 @@ package net\n \n import (\n \t\"io\"\n-\t\"reflect\"\n \t\"syscall\"\n )\n \n@@ -28,9 +27,18 @@ func socket(net string, f, t, p int, la, ra syscall.Sockaddr, toAddr func(syscal\n \tsyscall.CloseOnExec(s)\n \tsyscall.ForkLock.RUnlock()\n \n-\tsetDefaultSockopts(s, f, t)\n+\terr = setDefaultSockopts(s, f, t)\n+\tif err != nil {\n+\t\tclosesocket(s)\n+\t\treturn nil, err\n+\t}\n \n \tif la != nil {\n+\t\tla, err = listenerSockaddr(s, f, la, toAddr)\n+\t\tif err != nil {\n+\t\t\tclosesocket(s)\n+\t\t\treturn nil, err\n+\t\t}\n \t\terr = syscall.Bind(s, la)\n \t\tif err != nil {\n \t\t\tclosesocket(s)\n@@ -61,14 +69,6 @@ func socket(net string, f, t, p int, la, ra syscall.Sockaddr, toAddr func(syscal\n \treturn fd, nil\n }\n \n-type UnknownSocketError struct {\n-\tsa syscall.Sockaddr\n-}\n-\n-func (e *UnknownSocketError) Error() string {\n-\treturn \"unknown socket address type \" + reflect.TypeOf(e.sa).String()\n-}\n-\n type writerOnly struct {\n \tio.Writer\n }"}, {"sha": "7c693a271f7898adf5475fe5977055a09127bfe5", "filename": "libgo/go/net/sock_bsd.go", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fsock_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fsock_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock_bsd.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -31,3 +31,27 @@ func maxListenerBacklog() int {\n \t}\n \treturn int(n)\n }\n+\n+func listenerSockaddr(s, f int, la syscall.Sockaddr, toAddr func(syscall.Sockaddr) Addr) (syscall.Sockaddr, error) {\n+\ta := toAddr(la)\n+\tif a == nil {\n+\t\treturn la, nil\n+\t}\n+\tswitch v := a.(type) {\n+\tcase *UDPAddr:\n+\t\tif v.IP.IsMulticast() {\n+\t\t\terr := setDefaultMulticastSockopts(s)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tswitch f {\n+\t\t\tcase syscall.AF_INET:\n+\t\t\t\tv.IP = IPv4zero\n+\t\t\tcase syscall.AF_INET6:\n+\t\t\t\tv.IP = IPv6unspecified\n+\t\t\t}\n+\t\t\treturn v.sockaddr(f)\n+\t\t}\n+\t}\n+\treturn la, nil\n+}"}, {"sha": "0743843bf2807421611f62a44fbf2404837128ce", "filename": "libgo/go/net/sock_linux.go", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fsock_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fsock_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock_linux.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -25,3 +25,27 @@ func maxListenerBacklog() int {\n \t}\n \treturn n\n }\n+\n+func listenerSockaddr(s, f int, la syscall.Sockaddr, toAddr func(syscall.Sockaddr) Addr) (syscall.Sockaddr, error) {\n+\ta := toAddr(la)\n+\tif a == nil {\n+\t\treturn la, nil\n+\t}\n+\tswitch v := a.(type) {\n+\tcase *UDPAddr:\n+\t\tif v.IP.IsMulticast() {\n+\t\t\terr := setDefaultMulticastSockopts(s)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tswitch f {\n+\t\t\tcase syscall.AF_INET:\n+\t\t\t\tv.IP = IPv4zero\n+\t\t\tcase syscall.AF_INET6:\n+\t\t\t\tv.IP = IPv6unspecified\n+\t\t\t}\n+\t\t\treturn v.sockaddr(f)\n+\t\t}\n+\t}\n+\treturn la, nil\n+}"}, {"sha": "434122c9e46b9c572427b3a95bc356e5d7d87542", "filename": "libgo/go/net/sock_windows.go", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fsock_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fsock_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock_windows.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -12,3 +12,27 @@ func maxListenerBacklog() int {\n \t// TODO: Implement this\n \treturn syscall.SOMAXCONN\n }\n+\n+func listenerSockaddr(s syscall.Handle, f int, la syscall.Sockaddr, toAddr func(syscall.Sockaddr) Addr) (syscall.Sockaddr, error) {\n+\ta := toAddr(la)\n+\tif a == nil {\n+\t\treturn la, nil\n+\t}\n+\tswitch v := a.(type) {\n+\tcase *UDPAddr:\n+\t\tif v.IP.IsMulticast() {\n+\t\t\terr := setDefaultMulticastSockopts(s)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tswitch f {\n+\t\t\tcase syscall.AF_INET:\n+\t\t\t\tv.IP = IPv4zero\n+\t\t\tcase syscall.AF_INET6:\n+\t\t\t\tv.IP = IPv6unspecified\n+\t\t\t}\n+\t\t\treturn v.sockaddr(f)\n+\t\t}\n+\t}\n+\treturn la, nil\n+}"}, {"sha": "b5b75a2745ac80a609f42c04ccb6d49afcc06e7f", "filename": "libgo/go/net/sockopt.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fsockopt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fsockopt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -135,8 +135,8 @@ func setWriteDeadline(fd *netFD, t time.Time) error {\n }\n \n func setDeadline(fd *netFD, t time.Time) error {\n-\tif e := setReadDeadline(fd, t); e != nil {\n-\t\treturn e\n+\tif err := setReadDeadline(fd, t); err != nil {\n+\t\treturn err\n \t}\n \treturn setWriteDeadline(fd, t)\n }"}, {"sha": "bc764650627579600de41933879622883cec986d", "filename": "libgo/go/net/sockopt_bsd.go", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fsockopt_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fsockopt_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt_bsd.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -9,37 +9,55 @@\n package net\n \n import (\n+\t\"os\"\n \t\"syscall\"\n )\n \n-func setDefaultSockopts(s, f, t int) {\n+func setDefaultSockopts(s, f, t int) error {\n \tswitch f {\n \tcase syscall.AF_INET6:\n \t\t// Allow both IP versions even if the OS default is otherwise.\n+\t\t// Note that some operating systems never admit this option.\n \t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 0)\n \t}\n \n \tif f == syscall.AF_UNIX ||\n \t\t(f == syscall.AF_INET || f == syscall.AF_INET6) && t == syscall.SOCK_STREAM {\n \t\t// Allow reuse of recently-used addresses.\n-\t\tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n+\t\terr := syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n+\t\tif err != nil {\n+\t\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t\t}\n \n \t\t// Allow reuse of recently-used ports.\n \t\t// This option is supported only in descendants of 4.4BSD,\n \t\t// to make an effective multicast application and an application\n \t\t// that requires quick draw possible.\n-\t\tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEPORT, 1)\n+\t\terr = syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEPORT, 1)\n+\t\tif err != nil {\n+\t\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t\t}\n \t}\n \n \t// Allow broadcast.\n-\tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1)\n+\terr := syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\n+\treturn nil\n }\n \n-func setDefaultMulticastSockopts(fd *netFD) {\n-\tfd.incref()\n-\tdefer fd.decref()\n+func setDefaultMulticastSockopts(s int) error {\n \t// Allow multicast UDP and raw IP datagram sockets to listen\n \t// concurrently across multiple listeners.\n-\tsyscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n-\tsyscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_REUSEPORT, 1)\n+\terr := syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\terr = syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEPORT, 1)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n }"}, {"sha": "67c1dc87a7a0099b0c09a530cccfa056a4ed2ef2", "filename": "libgo/go/net/sockopt_linux.go", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fsockopt_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fsockopt_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt_linux.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -7,31 +7,43 @@\n package net\n \n import (\n+\t\"os\"\n \t\"syscall\"\n )\n \n-func setDefaultSockopts(s, f, t int) {\n+func setDefaultSockopts(s, f, t int) error {\n \tswitch f {\n \tcase syscall.AF_INET6:\n \t\t// Allow both IP versions even if the OS default is otherwise.\n+\t\t// Note that some operating systems never admit this option.\n \t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 0)\n \t}\n \n \tif f == syscall.AF_UNIX ||\n \t\t(f == syscall.AF_INET || f == syscall.AF_INET6) && t == syscall.SOCK_STREAM {\n \t\t// Allow reuse of recently-used addresses.\n-\t\tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n+\t\terr := syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n+\t\tif err != nil {\n+\t\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t\t}\n+\n \t}\n \n \t// Allow broadcast.\n-\tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1)\n+\terr := syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n \n+\treturn nil\n }\n \n-func setDefaultMulticastSockopts(fd *netFD) {\n-\tfd.incref()\n-\tdefer fd.decref()\n+func setDefaultMulticastSockopts(s int) error {\n \t// Allow multicast UDP and raw IP datagram sockets to listen\n \t// concurrently across multiple listeners.\n-\tsyscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n+\terr := syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n }"}, {"sha": "842bccc8f40fe92ae827868d6ed9267e41abb8f9", "filename": "libgo/go/net/sockopt_windows.go", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fsockopt_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fsockopt_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt_windows.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -7,13 +7,15 @@\n package net\n \n import (\n+\t\"os\"\n \t\"syscall\"\n )\n \n-func setDefaultSockopts(s syscall.Handle, f, t int) {\n+func setDefaultSockopts(s syscall.Handle, f, t int) error {\n \tswitch f {\n \tcase syscall.AF_INET6:\n \t\t// Allow both IP versions even if the OS default is otherwise.\n+\t\t// Note that some operating systems never admit this option.\n \t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 0)\n \t}\n \n@@ -26,13 +28,15 @@ func setDefaultSockopts(s syscall.Handle, f, t int) {\n \n \t// Allow broadcast.\n \tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1)\n-\n+\treturn nil\n }\n \n-func setDefaultMulticastSockopts(fd *netFD) {\n-\tfd.incref()\n-\tdefer fd.decref()\n+func setDefaultMulticastSockopts(s syscall.Handle) error {\n \t// Allow multicast UDP and raw IP datagram sockets to listen\n \t// concurrently across multiple listeners.\n-\tsyscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n+\terr := syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n }"}, {"sha": "a8a9d1c2bfb4787501ebd3312de3806732a34397", "filename": "libgo/go/net/sockoptip_windows.go", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fsockoptip_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fsockoptip_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockoptip_windows.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -7,6 +7,7 @@\n package net\n \n import (\n+\t\"os\"\n \t\"syscall\"\n )\n \n@@ -16,8 +17,19 @@ func ipv4MulticastInterface(fd *netFD) (*Interface, error) {\n }\n \n func setIPv4MulticastInterface(fd *netFD, ifi *Interface) error {\n-\t// TODO: Implement this\n-\treturn syscall.EWINDOWS\n+\tip, err := interfaceToIPv4Addr(ifi)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\tvar x [4]byte\n+\tcopy(x[:], ip.To4())\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr = syscall.SetsockoptInet4Addr(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_IF, x)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n }\n \n func ipv4MulticastTTL(fd *netFD) (int, error) {\n@@ -26,8 +38,14 @@ func ipv4MulticastTTL(fd *netFD) (int, error) {\n }\n \n func setIPv4MulticastTTL(fd *netFD, v int) error {\n-\t// TODO: Implement this\n-\treturn syscall.EWINDOWS\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_TTL, v)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+\n }\n \n func ipv4MulticastLoopback(fd *netFD) (bool, error) {\n@@ -36,8 +54,14 @@ func ipv4MulticastLoopback(fd *netFD) (bool, error) {\n }\n \n func setIPv4MulticastLoopback(fd *netFD, v bool) error {\n-\t// TODO: Implement this\n-\treturn syscall.EWINDOWS\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_LOOP, boolint(v))\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+\n }\n \n func ipv4ReceiveInterface(fd *netFD) (bool, error) {"}, {"sha": "128766144ddc3ba42151f6af29696971e9928bf4", "filename": "libgo/go/net/tcpsock_plan9.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Ftcpsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Ftcpsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock_plan9.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -17,17 +17,17 @@ type TCPConn struct {\n \tplan9Conn\n }\n \n-// SetDeadline implements the net.Conn SetDeadline method.\n+// SetDeadline implements the Conn SetDeadline method.\n func (c *TCPConn) SetDeadline(t time.Time) error {\n \treturn os.EPLAN9\n }\n \n-// SetReadDeadline implements the net.Conn SetReadDeadline method.\n+// SetReadDeadline implements the Conn SetReadDeadline method.\n func (c *TCPConn) SetReadDeadline(t time.Time) error {\n \treturn os.EPLAN9\n }\n \n-// SetWriteDeadline implements the net.Conn SetWriteDeadline method.\n+// SetWriteDeadline implements the Conn SetWriteDeadline method.\n func (c *TCPConn) SetWriteDeadline(t time.Time) error {\n \treturn os.EPLAN9\n }"}, {"sha": "51a5d6f0ed8240fee42cee03e7557ffa898bb48f", "filename": "libgo/go/net/tcpsock_posix.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -67,7 +67,7 @@ func (c *TCPConn) ok() bool { return c != nil && c.fd != nil }\n \n // Implementation of the Conn interface - see Conn for documentation.\n \n-// Read implements the net.Conn Read method.\n+// Read implements the Conn Read method.\n func (c *TCPConn) Read(b []byte) (n int, err error) {\n \tif !c.ok() {\n \t\treturn 0, os.EINVAL\n@@ -83,7 +83,7 @@ func (c *TCPConn) ReadFrom(r io.Reader) (int64, error) {\n \treturn genericReadFrom(c, r)\n }\n \n-// Write implements the net.Conn Write method.\n+// Write implements the Conn Write method.\n func (c *TCPConn) Write(b []byte) (n int, err error) {\n \tif !c.ok() {\n \t\treturn 0, os.EINVAL\n@@ -135,23 +135,23 @@ func (c *TCPConn) RemoteAddr() Addr {\n \treturn c.fd.raddr\n }\n \n-// SetDeadline implements the net.Conn SetDeadline method.\n+// SetDeadline implements the Conn SetDeadline method.\n func (c *TCPConn) SetDeadline(t time.Time) error {\n \tif !c.ok() {\n \t\treturn os.EINVAL\n \t}\n \treturn setDeadline(c.fd, t)\n }\n \n-// SetReadDeadline implements the net.Conn SetReadDeadline method.\n+// SetReadDeadline implements the Conn SetReadDeadline method.\n func (c *TCPConn) SetReadDeadline(t time.Time) error {\n \tif !c.ok() {\n \t\treturn os.EINVAL\n \t}\n \treturn setReadDeadline(c.fd, t)\n }\n \n-// SetWriteDeadline implements the net.Conn SetWriteDeadline method.\n+// SetWriteDeadline implements the Conn SetWriteDeadline method.\n func (c *TCPConn) SetWriteDeadline(t time.Time) error {\n \tif !c.ok() {\n \t\treturn os.EINVAL\n@@ -223,13 +223,13 @@ func (c *TCPConn) File() (f *os.File, err error) { return c.fd.dup() }\n // DialTCP connects to the remote address raddr on the network net,\n // which must be \"tcp\", \"tcp4\", or \"tcp6\".  If laddr is not nil, it is used\n // as the local address for the connection.\n-func DialTCP(net string, laddr, raddr *TCPAddr) (c *TCPConn, err error) {\n+func DialTCP(net string, laddr, raddr *TCPAddr) (*TCPConn, error) {\n \tif raddr == nil {\n \t\treturn nil, &OpError{\"dial\", net, nil, errMissingAddress}\n \t}\n-\tfd, e := internetSocket(net, laddr.toAddr(), raddr.toAddr(), syscall.SOCK_STREAM, 0, \"dial\", sockaddrToTCP)\n-\tif e != nil {\n-\t\treturn nil, e\n+\tfd, err := internetSocket(net, laddr.toAddr(), raddr.toAddr(), syscall.SOCK_STREAM, 0, \"dial\", sockaddrToTCP)\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n \treturn newTCPConn(fd), nil\n }\n@@ -245,7 +245,7 @@ type TCPListener struct {\n // Net must be \"tcp\", \"tcp4\", or \"tcp6\".\n // If laddr has a port of 0, it means to listen on some available port.\n // The caller can use l.Addr() to retrieve the chosen address.\n-func ListenTCP(net string, laddr *TCPAddr) (l *TCPListener, err error) {\n+func ListenTCP(net string, laddr *TCPAddr) (*TCPListener, error) {\n \tfd, err := internetSocket(net, laddr.toAddr(), nil, syscall.SOCK_STREAM, 0, \"listen\", sockaddrToTCP)\n \tif err != nil {\n \t\treturn nil, err\n@@ -255,7 +255,7 @@ func ListenTCP(net string, laddr *TCPAddr) (l *TCPListener, err error) {\n \t\tclosesocket(fd.sysfd)\n \t\treturn nil, &OpError{\"listen\", net, laddr, err}\n \t}\n-\tl = new(TCPListener)\n+\tl := new(TCPListener)\n \tl.fd = fd\n \treturn l, nil\n }"}, {"sha": "f90a5fe9ab853c24b4b94df09babb322a9b5d7db", "filename": "libgo/go/net/udpsock_plan9.go", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fudpsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fudpsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock_plan9.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -18,17 +18,17 @@ type UDPConn struct {\n \tplan9Conn\n }\n \n-// SetDeadline implements the net.Conn SetDeadline method.\n+// SetDeadline implements the Conn SetDeadline method.\n func (c *UDPConn) SetDeadline(t time.Time) error {\n \treturn os.EPLAN9\n }\n \n-// SetReadDeadline implements the net.Conn SetReadDeadline method.\n+// SetReadDeadline implements the Conn SetReadDeadline method.\n func (c *UDPConn) SetReadDeadline(t time.Time) error {\n \treturn os.EPLAN9\n }\n \n-// SetWriteDeadline implements the net.Conn SetWriteDeadline method.\n+// SetWriteDeadline implements the Conn SetWriteDeadline method.\n func (c *UDPConn) SetWriteDeadline(t time.Time) error {\n \treturn os.EPLAN9\n }\n@@ -66,7 +66,7 @@ func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error) {\n \treturn n, &UDPAddr{h.raddr, int(h.rport)}, nil\n }\n \n-// ReadFrom implements the net.PacketConn ReadFrom method.\n+// ReadFrom implements the PacketConn ReadFrom method.\n func (c *UDPConn) ReadFrom(b []byte) (n int, addr Addr, err error) {\n \tif !c.ok() {\n \t\treturn 0, nil, os.EINVAL\n@@ -103,7 +103,7 @@ func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (n int, err error) {\n \treturn c.data.Write(buf)\n }\n \n-// WriteTo implements the net.PacketConn WriteTo method.\n+// WriteTo implements the PacketConn WriteTo method.\n func (c *UDPConn) WriteTo(b []byte, addr Addr) (n int, err error) {\n \tif !c.ok() {\n \t\treturn 0, os.EINVAL\n@@ -186,20 +186,10 @@ func ListenUDP(net string, laddr *UDPAddr) (c *UDPConn, err error) {\n \treturn &UDPConn{*l.plan9Conn()}, nil\n }\n \n-// JoinGroup joins the IP multicast group named by addr on ifi,\n-// which specifies the interface to join.  JoinGroup uses the\n-// default multicast interface if ifi is nil.\n-func (c *UDPConn) JoinGroup(ifi *Interface, addr IP) error {\n-\tif !c.ok() {\n-\t\treturn os.EINVAL\n-\t}\n-\treturn os.EPLAN9\n-}\n-\n-// LeaveGroup exits the IP multicast group named by addr on ifi.\n-func (c *UDPConn) LeaveGroup(ifi *Interface, addr IP) error {\n-\tif !c.ok() {\n-\t\treturn os.EINVAL\n-\t}\n-\treturn os.EPLAN9\n+// ListenMulticastUDP listens for incoming multicast UDP packets\n+// addressed to the group address gaddr on ifi, which specifies\n+// the interface to join.  ListenMulticastUDP uses default\n+// multicast interface if ifi is nil.\n+func ListenMulticastUDP(net string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error) {\n+\treturn nil, os.EPLAN9\n }"}, {"sha": "6108373568a9d2f0abd245223f2b97303a20f2bb", "filename": "libgo/go/net/udpsock_posix.go", "status": "modified", "additions": 81, "deletions": 37, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fudpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Fudpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock_posix.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -60,16 +60,16 @@ func (c *UDPConn) ok() bool { return c != nil && c.fd != nil }\n \n // Implementation of the Conn interface - see Conn for documentation.\n \n-// Read implements the net.Conn Read method.\n-func (c *UDPConn) Read(b []byte) (n int, err error) {\n+// Read implements the Conn Read method.\n+func (c *UDPConn) Read(b []byte) (int, error) {\n \tif !c.ok() {\n \t\treturn 0, os.EINVAL\n \t}\n \treturn c.fd.Read(b)\n }\n \n-// Write implements the net.Conn Write method.\n-func (c *UDPConn) Write(b []byte) (n int, err error) {\n+// Write implements the Conn Write method.\n+func (c *UDPConn) Write(b []byte) (int, error) {\n \tif !c.ok() {\n \t\treturn 0, os.EINVAL\n \t}\n@@ -102,23 +102,23 @@ func (c *UDPConn) RemoteAddr() Addr {\n \treturn c.fd.raddr\n }\n \n-// SetDeadline implements the net.Conn SetDeadline method.\n+// SetDeadline implements the Conn SetDeadline method.\n func (c *UDPConn) SetDeadline(t time.Time) error {\n \tif !c.ok() {\n \t\treturn os.EINVAL\n \t}\n \treturn setDeadline(c.fd, t)\n }\n \n-// SetReadDeadline implements the net.Conn SetReadDeadline method.\n+// SetReadDeadline implements the Conn SetReadDeadline method.\n func (c *UDPConn) SetReadDeadline(t time.Time) error {\n \tif !c.ok() {\n \t\treturn os.EINVAL\n \t}\n \treturn setReadDeadline(c.fd, t)\n }\n \n-// SetWriteDeadline implements the net.Conn SetWriteDeadline method.\n+// SetWriteDeadline implements the Conn SetWriteDeadline method.\n func (c *UDPConn) SetWriteDeadline(t time.Time) error {\n \tif !c.ok() {\n \t\treturn os.EINVAL\n@@ -166,8 +166,8 @@ func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error) {\n \treturn\n }\n \n-// ReadFrom implements the net.PacketConn ReadFrom method.\n-func (c *UDPConn) ReadFrom(b []byte) (n int, addr Addr, err error) {\n+// ReadFrom implements the PacketConn ReadFrom method.\n+func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error) {\n \tif !c.ok() {\n \t\treturn 0, nil, os.EINVAL\n \t}\n@@ -195,7 +195,7 @@ func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error) {\n \treturn c.fd.WriteTo(b, sa)\n }\n \n-// WriteTo implements the net.PacketConn WriteTo method.\n+// WriteTo implements the PacketConn WriteTo method.\n func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error) {\n \tif !c.ok() {\n \t\treturn 0, os.EINVAL\n@@ -207,10 +207,15 @@ func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error) {\n \treturn c.WriteToUDP(b, a)\n }\n \n+// File returns a copy of the underlying os.File, set to blocking mode.\n+// It is the caller's responsibility to close f when finished.\n+// Closing c does not affect f, and closing f does not affect c.\n+func (c *UDPConn) File() (f *os.File, err error) { return c.fd.dup() }\n+\n // DialUDP connects to the remote address raddr on the network net,\n // which must be \"udp\", \"udp4\", or \"udp6\".  If laddr is not nil, it is used\n // as the local address for the connection.\n-func DialUDP(net string, laddr, raddr *UDPAddr) (c *UDPConn, err error) {\n+func DialUDP(net string, laddr, raddr *UDPAddr) (*UDPConn, error) {\n \tswitch net {\n \tcase \"udp\", \"udp4\", \"udp6\":\n \tdefault:\n@@ -219,9 +224,9 @@ func DialUDP(net string, laddr, raddr *UDPAddr) (c *UDPConn, err error) {\n \tif raddr == nil {\n \t\treturn nil, &OpError{\"dial\", net, nil, errMissingAddress}\n \t}\n-\tfd, e := internetSocket(net, laddr.toAddr(), raddr.toAddr(), syscall.SOCK_DGRAM, 0, \"dial\", sockaddrToUDP)\n-\tif e != nil {\n-\t\treturn nil, e\n+\tfd, err := internetSocket(net, laddr.toAddr(), raddr.toAddr(), syscall.SOCK_DGRAM, 0, \"dial\", sockaddrToUDP)\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n \treturn newUDPConn(fd), nil\n }\n@@ -246,36 +251,75 @@ func ListenUDP(net string, laddr *UDPAddr) (*UDPConn, error) {\n \treturn newUDPConn(fd), nil\n }\n \n-// File returns a copy of the underlying os.File, set to blocking mode.\n-// It is the caller's responsibility to close f when finished.\n-// Closing c does not affect f, and closing f does not affect c.\n-func (c *UDPConn) File() (f *os.File, err error) { return c.fd.dup() }\n+// ListenMulticastUDP listens for incoming multicast UDP packets\n+// addressed to the group address gaddr on ifi, which specifies\n+// the interface to join.  ListenMulticastUDP uses default\n+// multicast interface if ifi is nil.\n+func ListenMulticastUDP(net string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error) {\n+\tswitch net {\n+\tcase \"udp\", \"udp4\", \"udp6\":\n+\tdefault:\n+\t\treturn nil, UnknownNetworkError(net)\n+\t}\n+\tif gaddr == nil || gaddr.IP == nil {\n+\t\treturn nil, &OpError{\"listenmulticastudp\", \"udp\", nil, errMissingAddress}\n+\t}\n+\tfd, err := internetSocket(net, gaddr.toAddr(), nil, syscall.SOCK_DGRAM, 0, \"listen\", sockaddrToUDP)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tc := newUDPConn(fd)\n+\tip4 := gaddr.IP.To4()\n+\tif ip4 != nil {\n+\t\terr := listenIPv4MulticastUDP(c, ifi, ip4)\n+\t\tif err != nil {\n+\t\t\tc.Close()\n+\t\t\treturn nil, err\n+\t\t}\n+\t} else {\n+\t\terr := listenIPv6MulticastUDP(c, ifi, gaddr.IP)\n+\t\tif err != nil {\n+\t\t\tc.Close()\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\treturn c, nil\n+}\n \n-// JoinGroup joins the IP multicast group named by addr on ifi,\n-// which specifies the interface to join.  JoinGroup uses the\n-// default multicast interface if ifi is nil.\n-func (c *UDPConn) JoinGroup(ifi *Interface, addr IP) error {\n-\tif !c.ok() {\n-\t\treturn os.EINVAL\n+func listenIPv4MulticastUDP(c *UDPConn, ifi *Interface, ip IP) error {\n+\tif ifi != nil {\n+\t\terr := setIPv4MulticastInterface(c.fd, ifi)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\terr := setIPv4MulticastLoopback(c.fd, false)\n+\tif err != nil {\n+\t\treturn err\n \t}\n-\tsetDefaultMulticastSockopts(c.fd)\n-\tip := addr.To4()\n-\tif ip != nil {\n-\t\treturn joinIPv4GroupUDP(c, ifi, ip)\n+\terr = joinIPv4GroupUDP(c, ifi, ip)\n+\tif err != nil {\n+\t\treturn err\n \t}\n-\treturn joinIPv6GroupUDP(c, ifi, addr)\n+\treturn nil\n }\n \n-// LeaveGroup exits the IP multicast group named by addr on ifi.\n-func (c *UDPConn) LeaveGroup(ifi *Interface, addr IP) error {\n-\tif !c.ok() {\n-\t\treturn os.EINVAL\n+func listenIPv6MulticastUDP(c *UDPConn, ifi *Interface, ip IP) error {\n+\tif ifi != nil {\n+\t\terr := setIPv6MulticastInterface(c.fd, ifi)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n \t}\n-\tip := addr.To4()\n-\tif ip != nil {\n-\t\treturn leaveIPv4GroupUDP(c, ifi, ip)\n+\terr := setIPv6MulticastLoopback(c.fd, false)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\terr = joinIPv6GroupUDP(c, ifi, ip)\n+\tif err != nil {\n+\t\treturn err\n \t}\n-\treturn leaveIPv6GroupUDP(c, ifi, addr)\n+\treturn nil\n }\n \n func joinIPv4GroupUDP(c *UDPConn, ifi *Interface, ip IP) error {"}, {"sha": "1d9d7578f4fff0ff3692dd5164831775258f4562", "filename": "libgo/go/net/unixsock_plan9.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Funixsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Funixsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Funixsock_plan9.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -17,12 +17,12 @@ type UnixConn bool\n \n // Implementation of the Conn interface - see Conn for documentation.\n \n-// Read implements the net.Conn Read method.\n+// Read implements the Conn Read method.\n func (c *UnixConn) Read(b []byte) (n int, err error) {\n \treturn 0, os.EPLAN9\n }\n \n-// Write implements the net.Conn Write method.\n+// Write implements the Conn Write method.\n func (c *UnixConn) Write(b []byte) (n int, err error) {\n \treturn 0, os.EPLAN9\n }\n@@ -45,28 +45,28 @@ func (c *UnixConn) RemoteAddr() Addr {\n \treturn nil\n }\n \n-// SetDeadline implements the net.Conn SetDeadline method.\n+// SetDeadline implements the Conn SetDeadline method.\n func (c *UnixConn) SetDeadline(t time.Time) error {\n \treturn os.EPLAN9\n }\n \n-// SetReadDeadline implements the net.Conn SetReadDeadline method.\n+// SetReadDeadline implements the Conn SetReadDeadline method.\n func (c *UnixConn) SetReadDeadline(t time.Time) error {\n \treturn os.EPLAN9\n }\n \n-// SetWriteDeadline implements the net.Conn SetWriteDeadline method.\n+// SetWriteDeadline implements the Conn SetWriteDeadline method.\n func (c *UnixConn) SetWriteDeadline(t time.Time) error {\n \treturn os.EPLAN9\n }\n \n-// ReadFrom implements the net.PacketConn ReadFrom method.\n+// ReadFrom implements the PacketConn ReadFrom method.\n func (c *UnixConn) ReadFrom(b []byte) (n int, addr Addr, err error) {\n \terr = os.EPLAN9\n \treturn\n }\n \n-// WriteTo implements the net.PacketConn WriteTo method.\n+// WriteTo implements the PacketConn WriteTo method.\n func (c *UnixConn) WriteTo(b []byte, addr Addr) (n int, err error) {\n \terr = os.EPLAN9\n \treturn"}, {"sha": "10b7966851155045b8ab988af7fcfd906f885f25", "filename": "libgo/go/net/unixsock_posix.go", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Funixsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Funixsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Funixsock_posix.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -120,15 +120,15 @@ func (c *UnixConn) ok() bool { return c != nil && c.fd != nil }\n \n // Implementation of the Conn interface - see Conn for documentation.\n \n-// Read implements the net.Conn Read method.\n+// Read implements the Conn Read method.\n func (c *UnixConn) Read(b []byte) (n int, err error) {\n \tif !c.ok() {\n \t\treturn 0, os.EINVAL\n \t}\n \treturn c.fd.Read(b)\n }\n \n-// Write implements the net.Conn Write method.\n+// Write implements the Conn Write method.\n func (c *UnixConn) Write(b []byte) (n int, err error) {\n \tif !c.ok() {\n \t\treturn 0, os.EINVAL\n@@ -165,23 +165,23 @@ func (c *UnixConn) RemoteAddr() Addr {\n \treturn c.fd.raddr\n }\n \n-// SetDeadline implements the net.Conn SetDeadline method.\n+// SetDeadline implements the Conn SetDeadline method.\n func (c *UnixConn) SetDeadline(t time.Time) error {\n \tif !c.ok() {\n \t\treturn os.EINVAL\n \t}\n \treturn setDeadline(c.fd, t)\n }\n \n-// SetReadDeadline implements the net.Conn SetReadDeadline method.\n+// SetReadDeadline implements the Conn SetReadDeadline method.\n func (c *UnixConn) SetReadDeadline(t time.Time) error {\n \tif !c.ok() {\n \t\treturn os.EINVAL\n \t}\n \treturn setReadDeadline(c.fd, t)\n }\n \n-// SetWriteDeadline implements the net.Conn SetWriteDeadline method.\n+// SetWriteDeadline implements the Conn SetWriteDeadline method.\n func (c *UnixConn) SetWriteDeadline(t time.Time) error {\n \tif !c.ok() {\n \t\treturn os.EINVAL\n@@ -226,7 +226,7 @@ func (c *UnixConn) ReadFromUnix(b []byte) (n int, addr *UnixAddr, err error) {\n \treturn\n }\n \n-// ReadFrom implements the net.PacketConn ReadFrom method.\n+// ReadFrom implements the PacketConn ReadFrom method.\n func (c *UnixConn) ReadFrom(b []byte) (n int, addr Addr, err error) {\n \tif !c.ok() {\n \t\treturn 0, nil, os.EINVAL\n@@ -252,7 +252,7 @@ func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (n int, err error) {\n \treturn c.fd.WriteTo(b, sa)\n }\n \n-// WriteTo implements the net.PacketConn WriteTo method.\n+// WriteTo implements the PacketConn WriteTo method.\n func (c *UnixConn) WriteTo(b []byte, addr Addr) (n int, err error) {\n \tif !c.ok() {\n \t\treturn 0, os.EINVAL\n@@ -298,10 +298,10 @@ func (c *UnixConn) File() (f *os.File, err error) { return c.fd.dup() }\n // DialUnix connects to the remote address raddr on the network net,\n // which must be \"unix\" or \"unixgram\".  If laddr is not nil, it is used\n // as the local address for the connection.\n-func DialUnix(net string, laddr, raddr *UnixAddr) (c *UnixConn, err error) {\n-\tfd, e := unixSocket(net, laddr, raddr, \"dial\")\n-\tif e != nil {\n-\t\treturn nil, e\n+func DialUnix(net string, laddr, raddr *UnixAddr) (*UnixConn, error) {\n+\tfd, err := unixSocket(net, laddr, raddr, \"dial\")\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n \treturn newUnixConn(fd), nil\n }\n@@ -337,15 +337,15 @@ func ListenUnix(net string, laddr *UnixAddr) (*UnixListener, error) {\n \n // AcceptUnix accepts the next incoming call and returns the new connection\n // and the remote address.\n-func (l *UnixListener) AcceptUnix() (c *UnixConn, err error) {\n+func (l *UnixListener) AcceptUnix() (*UnixConn, error) {\n \tif l == nil || l.fd == nil {\n \t\treturn nil, os.EINVAL\n \t}\n-\tfd, e := l.fd.accept(sockaddrToUnix)\n-\tif e != nil {\n-\t\treturn nil, e\n+\tfd, err := l.fd.accept(sockaddrToUnix)\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n-\tc = newUnixConn(fd)\n+\tc := newUnixConn(fd)\n \treturn c, nil\n }\n \n@@ -405,7 +405,7 @@ func (l *UnixListener) File() (f *os.File, err error) { return l.fd.dup() }\n // local address laddr.  The returned connection c's ReadFrom\n // and WriteTo methods can be used to receive and send UDP\n // packets with per-packet addressing.  The network net must be \"unixgram\".\n-func ListenUnixgram(net string, laddr *UnixAddr) (c *UDPConn, err error) {\n+func ListenUnixgram(net string, laddr *UnixAddr) (*UDPConn, error) {\n \tswitch net {\n \tcase \"unixgram\":\n \tdefault:\n@@ -414,9 +414,9 @@ func ListenUnixgram(net string, laddr *UnixAddr) (c *UDPConn, err error) {\n \tif laddr == nil {\n \t\treturn nil, &OpError{\"listen\", net, nil, errMissingAddress}\n \t}\n-\tfd, e := unixSocket(net, laddr, nil, \"listen\")\n-\tif e != nil {\n-\t\treturn nil, e\n+\tfd, err := unixSocket(net, laddr, nil, \"listen\")\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n \treturn newUDPConn(fd), nil\n }"}, {"sha": "a9ce3b31e24ecfb3c4c05e3653163d83cde0ba64", "filename": "libgo/go/net/url/url.go", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Furl%2Furl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fnet%2Furl%2Furl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Furl%2Furl.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -431,30 +431,30 @@ func ParseWithReference(rawurlref string) (url *URL, err error) {\n \treturn url, nil\n }\n \n-// String reassembles url into a valid URL string.\n-func (url *URL) String() string {\n+// String reassembles the URL into a valid URL string.\n+func (u *URL) String() string {\n \t// TODO: Rewrite to use bytes.Buffer\n \tresult := \"\"\n-\tif url.Scheme != \"\" {\n-\t\tresult += url.Scheme + \":\"\n+\tif u.Scheme != \"\" {\n+\t\tresult += u.Scheme + \":\"\n \t}\n-\tif url.Opaque != \"\" {\n-\t\tresult += url.Opaque\n+\tif u.Opaque != \"\" {\n+\t\tresult += u.Opaque\n \t} else {\n-\t\tif url.Host != \"\" || url.User != nil {\n+\t\tif u.Host != \"\" || u.User != nil {\n \t\t\tresult += \"//\"\n-\t\t\tif u := url.User; u != nil {\n+\t\t\tif u := u.User; u != nil {\n \t\t\t\tresult += u.String() + \"@\"\n \t\t\t}\n-\t\t\tresult += url.Host\n+\t\t\tresult += u.Host\n \t\t}\n-\t\tresult += escape(url.Path, encodePath)\n+\t\tresult += escape(u.Path, encodePath)\n \t}\n-\tif url.RawQuery != \"\" {\n-\t\tresult += \"?\" + url.RawQuery\n+\tif u.RawQuery != \"\" {\n+\t\tresult += \"?\" + u.RawQuery\n \t}\n-\tif url.Fragment != \"\" {\n-\t\tresult += \"#\" + escape(url.Fragment, encodeFragment)\n+\tif u.Fragment != \"\" {\n+\t\tresult += \"#\" + escape(u.Fragment, encodeFragment)\n \t}\n \treturn result\n }\n@@ -585,8 +585,8 @@ func resolvePath(basepath string, refpath string) string {\n }\n \n // IsAbs returns true if the URL is absolute.\n-func (url *URL) IsAbs() bool {\n-\treturn url.Scheme != \"\"\n+func (u *URL) IsAbs() bool {\n+\treturn u.Scheme != \"\"\n }\n \n // Parse parses a URL in the context of a base URL.  The URL in ref"}, {"sha": "854a548e5aafd7dc43ee752fb2be3b80116d1127", "filename": "libgo/go/old/template/template_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fold%2Ftemplate%2Ftemplate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fold%2Ftemplate%2Ftemplate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fold%2Ftemplate%2Ftemplate_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -795,8 +795,8 @@ func TestFormatters(t *testing.T) {\n \t\t\t\tt.Errorf(\"For %q, expected error, got none.\", c.in)\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tbuf := bytes.NewBuffer(nil)\n-\t\t\terr = tmpl.Execute(buf, data)\n+\t\t\tvar buf bytes.Buffer\n+\t\t\terr = tmpl.Execute(&buf, data)\n \t\t\tif err != nil {\n \t\t\t\tt.Error(\"unexpected Execute error: \", err)\n \t\t\t\tcontinue"}, {"sha": "6e0f168c76739513dd5b527fb802dada94e7b4ad", "filename": "libgo/go/os/exec.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -12,11 +12,11 @@ import (\n // Process stores the information about a process created by StartProcess.\n type Process struct {\n \tPid    int\n-\thandle int\n+\thandle uintptr\n \tdone   bool // process has been successfuly waited on\n }\n \n-func newProcess(pid, handle int) *Process {\n+func newProcess(pid int, handle uintptr) *Process {\n \tp := &Process{Pid: pid, handle: handle}\n \truntime.SetFinalizer(p, (*Process).Release)\n \treturn p"}, {"sha": "d00d12008f75030117144987d5ff01d67ac7e49f", "filename": "libgo/go/os/exec/exec_test.go", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fexec%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fexec%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Fexec_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -17,6 +17,7 @@ import (\n \t\"runtime\"\n \t\"strconv\"\n \t\"strings\"\n+\t\"syscall\"\n \t\"testing\"\n )\n \n@@ -150,6 +151,15 @@ func TestExtraFiles(t *testing.T) {\n \t\treturn\n \t}\n \n+\t// Ensure that file descriptors have not already been leaked into\n+\t// our environment.\n+\tfor fd := os.Stderr.Fd() + 1; fd <= 101; fd++ {\n+\t\terr := syscall.Close(fd)\n+\t\tif err == nil {\n+\t\t\tt.Logf(\"Something already leaked - closed fd %d\", fd)\n+\t\t}\n+\t}\n+\n \t// Force network usage, to verify the epoll (or whatever) fd\n \t// doesn't leak to the child,\n \tln, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n@@ -202,6 +212,13 @@ func TestHelperProcess(*testing.T) {\n \t}\n \tdefer os.Exit(0)\n \n+\t// Determine which command to use to display open files.\n+\tofcmd := \"lsof\"\n+\tswitch runtime.GOOS {\n+\tcase \"freebsd\", \"netbsd\", \"openbsd\":\n+\t\tofcmd = \"fstat\"\n+\t}\n+\n \targs := os.Args\n \tfor len(args) > 0 {\n \t\tif args[0] == \"--\" {\n@@ -282,7 +299,7 @@ func TestHelperProcess(*testing.T) {\n \t\t\t\t}\n \t\t\t\tif got := f.Fd(); got != wantfd {\n \t\t\t\t\tfmt.Printf(\"leaked parent file. fd = %d; want %d\\n\", got, wantfd)\n-\t\t\t\t\tout, _ := Command(\"lsof\", \"-p\", fmt.Sprint(os.Getpid())).CombinedOutput()\n+\t\t\t\t\tout, _ := Command(ofcmd, \"-p\", fmt.Sprint(os.Getpid())).CombinedOutput()\n \t\t\t\t\tfmt.Print(string(out))\n \t\t\t\t\tos.Exit(1)\n \t\t\t\t}\n@@ -292,6 +309,11 @@ func TestHelperProcess(*testing.T) {\n \t\t\t\tf.Close()\n \t\t\t}\n \t\t}\n+\t\t// Referring to fd3 here ensures that it is not\n+\t\t// garbage collected, and therefore closed, while\n+\t\t// executing the wantfd loop above.  It doesn't matter\n+\t\t// what we do with fd3 as long as we refer to it;\n+\t\t// closing it is the easy choice.\n \t\tfd3.Close()\n \t\tos.Stderr.Write(bs)\n \tcase \"exit\":"}, {"sha": "6465bfbb65376341dc41ee8d4ddbbae6bfff9b86", "filename": "libgo/go/os/exec_posix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fexec_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fexec_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_posix.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -48,7 +48,7 @@ func StartProcess(name string, argv []string, attr *ProcAttr) (p *Process, err e\n \n // Kill causes the Process to exit immediately.\n func (p *Process) Kill() error {\n-\treturn p.Signal(SIGKILL)\n+\treturn p.Signal(UnixSignal(syscall.SIGKILL))\n }\n \n // Exec replaces the current process with an execution of the"}, {"sha": "9463d2c0e3ffd3bc7e8395a519c01fe7865b44a5", "filename": "libgo/go/os/exec_windows.go", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fexec_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fexec_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_windows.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -29,16 +29,15 @@ func (p *Process) Wait(options int) (w *Waitmsg, err error) {\n \t\treturn nil, NewSyscallError(\"GetExitCodeProcess\", e)\n \t}\n \tp.done = true\n-\treturn &Waitmsg{p.Pid, syscall.WaitStatus{s, ec}, new(syscall.Rusage)}, nil\n+\treturn &Waitmsg{p.Pid, syscall.WaitStatus{Status: s, ExitCode: ec}, new(syscall.Rusage)}, nil\n }\n \n // Signal sends a signal to the Process.\n func (p *Process) Signal(sig Signal) error {\n \tif p.done {\n \t\treturn errors.New(\"os: process already finished\")\n \t}\n-\tswitch sig.(UnixSignal) {\n-\tcase SIGKILL:\n+\tif us, ok := sig.(UnixSignal); ok && us == syscall.SIGKILL {\n \t\te := syscall.TerminateProcess(syscall.Handle(p.handle), 1)\n \t\treturn NewSyscallError(\"TerminateProcess\", e)\n \t}\n@@ -47,14 +46,14 @@ func (p *Process) Signal(sig Signal) error {\n \n // Release releases any resources associated with the Process.\n func (p *Process) Release() error {\n-\tif p.handle == -1 {\n+\tif p.handle == uintptr(syscall.InvalidHandle) {\n \t\treturn EINVAL\n \t}\n \te := syscall.CloseHandle(syscall.Handle(p.handle))\n \tif e != nil {\n \t\treturn NewSyscallError(\"CloseHandle\", e)\n \t}\n-\tp.handle = -1\n+\tp.handle = uintptr(syscall.InvalidHandle)\n \t// no need for a finalizer anymore\n \truntime.SetFinalizer(p, nil)\n \treturn nil\n@@ -67,7 +66,7 @@ func findProcess(pid int) (p *Process, err error) {\n \tif e != nil {\n \t\treturn nil, NewSyscallError(\"OpenProcess\", e)\n \t}\n-\treturn newProcess(pid, int(h)), nil\n+\treturn newProcess(pid, uintptr(h)), nil\n }\n \n func init() {"}, {"sha": "8c61a82248f0cc8723d74976f22fea3a96b0ede2", "filename": "libgo/go/os/file_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Ffile_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Ffile_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_unix.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -158,7 +158,7 @@ func (f *File) readdir(n int) (fi []FileInfo, err error) {\n \t\tif err == nil {\n \t\t\tfi[i] = fip\n \t\t} else {\n-\t\t\tfi[i] = &FileStat{name: filename}\n+\t\t\tfi[i] = &fileStat{name: filename}\n \t\t}\n \t}\n \treturn fi, err"}, {"sha": "56836434dbe3f94a7f92d8333897d77e98a87f1f", "filename": "libgo/go/os/getwd.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fgetwd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fgetwd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fgetwd.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -30,7 +30,7 @@ func Getwd() (pwd string, err error) {\n \tpwd = Getenv(\"PWD\")\n \tif len(pwd) > 0 && pwd[0] == '/' {\n \t\td, err := Stat(pwd)\n-\t\tif err == nil && dot.(*FileStat).SameFile(d.(*FileStat)) {\n+\t\tif err == nil && SameFile(dot, d) {\n \t\t\treturn pwd, nil\n \t\t}\n \t}\n@@ -42,7 +42,7 @@ func Getwd() (pwd string, err error) {\n \t\t// Can't stat root - no hope.\n \t\treturn \"\", err\n \t}\n-\tif root.(*FileStat).SameFile(dot.(*FileStat)) {\n+\tif SameFile(root, dot) {\n \t\treturn \"/\", nil\n \t}\n \n@@ -67,7 +67,7 @@ func Getwd() (pwd string, err error) {\n \t\t\t}\n \t\t\tfor _, name := range names {\n \t\t\t\td, _ := Lstat(parent + \"/\" + name)\n-\t\t\t\tif d.(*FileStat).SameFile(dot.(*FileStat)) {\n+\t\t\t\tif SameFile(d, dot) {\n \t\t\t\t\tpwd = \"/\" + name + pwd\n \t\t\t\t\tgoto Found\n \t\t\t\t}\n@@ -82,7 +82,7 @@ func Getwd() (pwd string, err error) {\n \t\t\treturn \"\", err\n \t\t}\n \t\tfd.Close()\n-\t\tif pd.(*FileStat).SameFile(root.(*FileStat)) {\n+\t\tif SameFile(pd, root) {\n \t\t\tbreak\n \t\t}\n \t\t// Set up for next round."}, {"sha": "36bb496d9791814b5135572eb4ab2d00595835ab", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -406,7 +406,7 @@ func TestHardLink(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatalf(\"stat %q failed: %v\", from, err)\n \t}\n-\tif !tostat.(*FileStat).SameFile(fromstat.(*FileStat)) {\n+\tif !SameFile(tostat, fromstat) {\n \t\tt.Errorf(\"link %q, %q did not create hard link\", to, from)\n \t}\n }\n@@ -442,7 +442,7 @@ func TestSymLink(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatalf(\"stat %q failed: %v\", from, err)\n \t}\n-\tif !tostat.(*FileStat).SameFile(fromstat.(*FileStat)) {\n+\tif !SameFile(tostat, fromstat) {\n \t\tt.Errorf(\"symlink %q, %q did not create symlink\", to, from)\n \t}\n \tfromstat, err = Lstat(from)\n@@ -656,7 +656,7 @@ func TestChtimes(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatalf(\"Stat %s: %s\", f.Name(), err)\n \t}\n-\tpreStat := st.(*FileStat)\n+\tpreStat := st\n \n \t// Move access and modification time back a second\n \tat := Atime(preStat)\n@@ -670,7 +670,7 @@ func TestChtimes(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatalf(\"second Stat %s: %s\", f.Name(), err)\n \t}\n-\tpostStat := st.(*FileStat)\n+\tpostStat := st\n \n \t/* Plan 9:\n \t\tMtime is the time of the last change of content.  Similarly, atime is set whenever the"}, {"sha": "f8e330beba468994b7c0d0cf374ff97b2096a477", "filename": "libgo/go/os/os_unix_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fos_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fos_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_unix_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -18,7 +18,7 @@ func checkUidGid(t *testing.T, path string, uid, gid int) {\n \tif err != nil {\n \t\tt.Fatalf(\"Stat %q (looking for uid/gid %d/%d): %s\", path, uid, gid, err)\n \t}\n-\tsys := dir.(*FileStat).Sys.(*syscall.Stat_t)\n+\tsys := dir.Sys().(*syscall.Stat_t)\n \tif int(sys.Uid) != uid {\n \t\tt.Errorf(\"Stat %q: uid %d want %d\", path, sys.Uid, uid)\n \t}\n@@ -52,7 +52,7 @@ func TestChown(t *testing.T) {\n \tif err = Chown(f.Name(), -1, gid); err != nil {\n \t\tt.Fatalf(\"chown %s -1 %d: %s\", f.Name(), gid, err)\n \t}\n-\tsys := dir.(*FileStat).Sys.(*syscall.Stat_t)\n+\tsys := dir.Sys().(*syscall.Stat_t)\n \tcheckUidGid(t, f.Name(), int(sys.Uid), gid)\n \n \t// Then try all the auxiliary groups."}, {"sha": "789007206fa51f7bf1fe6729c9064be26379782f", "filename": "libgo/go/os/stat.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fstat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fstat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fstat.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -9,18 +9,18 @@ import (\n \t\"time\"\n )\n \n-func sameFile(fs1, fs2 *FileStat) bool {\n-\tsys1 := fs1.Sys.(*syscall.Stat_t)\n-\tsys2 := fs2.Sys.(*syscall.Stat_t)\n-\treturn sys1.Dev == sys2.Dev && sys1.Ino == sys2.Ino\n+func sameFile(sys1, sys2 interface{}) bool {\n+\tstat1 := sys1.(*syscall.Stat_t)\n+\tstat2 := sys2.(*syscall.Stat_t)\n+\treturn stat1.Dev == stat2.Dev && stat1.Ino == stat2.Ino\n }\n \n func fileInfoFromStat(st *syscall.Stat_t, name string) FileInfo {\n-\tfs := &FileStat{\n+\tfs := &fileStat{\n \t\tname:    basename(name),\n \t\tsize:    int64(st.Size),\n \t\tmodTime: timespecToTime(st.Mtime),\n-\t\tSys:     st,\n+\t\tsys:     st,\n \t}\n \tfs.mode = FileMode(st.Mode & 0777)\n \tswitch st.Mode & syscall.S_IFMT {\n@@ -52,5 +52,5 @@ func timespecToTime(ts syscall.Timespec) time.Time {\n \n // For testing.\n func atime(fi FileInfo) time.Time {\n-\treturn timespecToTime(fi.(*FileStat).Sys.(*syscall.Stat_t).Atime)\n+\treturn timespecToTime(fi.Sys().(*syscall.Stat_t).Atime)\n }"}, {"sha": "00506b2b6095dd6e35df7097eb0b451d1c5e8e20", "filename": "libgo/go/os/stat_openbsd.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fstat_openbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fstat_openbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fstat_openbsd.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -9,18 +9,18 @@ import (\n \t\"time\"\n )\n \n-func sameFile(fs1, fs2 *FileStat) bool {\n-\tsys1 := fs1.Sys.(*syscall.Stat_t)\n-\tsys2 := fs2.Sys.(*syscall.Stat_t)\n-\treturn sys1.Dev == sys2.Dev && sys1.Ino == sys2.Ino\n+func sameFile(sys1, sys2 interface{}) bool {\n+\tstat1 := sys1.(*syscall.Stat_t)\n+\tstat2 := sys2.(*syscall.Stat_t)\n+\treturn stat1.Dev == stat2.Dev && stat1.Ino == stat2.Ino\n }\n \n func fileInfoFromStat(st *syscall.Stat_t, name string) FileInfo {\n-\tfs := &FileStat{\n+\tfs := &fileStat{\n \t\tname:    basename(name),\n \t\tsize:    int64(st.Size),\n \t\tmodTime: timespecToTime(st.Mtim),\n-\t\tSys:     st,\n+\t\tsys:     st,\n \t}\n \tfs.mode = FileMode(st.Mode & 0777)\n \tswitch st.Mode & syscall.S_IFMT {\n@@ -57,5 +57,5 @@ func timespecToTime(ts syscall.Timespec) time.Time {\n \n // For testing.\n func atime(fi FileInfo) time.Time {\n-\treturn timespecToTime(fi.(*FileStat).Sys.(*syscall.Stat_t).Atim)\n+\treturn timespecToTime(fi.Sys().(*syscall.Stat_t).Atim)\n }"}, {"sha": "7c2d1bd4efc421ea796c4f8d6ac8de09ede9649d", "filename": "libgo/go/os/stat_plan9.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fstat_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fstat_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fstat_plan9.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -9,18 +9,18 @@ import (\n \t\"time\"\n )\n \n-func sameFile(fs1, fs2 *FileStat) bool {\n-\ta := fs1.Sys.(*Dir)\n-\tb := fs2.Sys.(*Dir)\n+func sameFile(sys1, sys2 interface{}) bool {\n+\ta := sys1.(*Dir)\n+\tb := sys2.(*Dir)\n \treturn a.Qid.Path == b.Qid.Path && a.Type == b.Type && a.Dev == b.Dev\n }\n \n func fileInfoFromStat(d *Dir) FileInfo {\n-\tfs := &FileStat{\n+\tfs := &fileStat{\n \t\tname:    d.Name,\n \t\tsize:    int64(d.Length),\n \t\tmodTime: time.Unix(int64(d.Mtime), 0),\n-\t\tSys:     d,\n+\t\tsys:     d,\n \t}\n \tfs.mode = FileMode(d.Mode & 0777)\n \tif d.Mode&syscall.DMDIR != 0 {\n@@ -100,5 +100,5 @@ func Lstat(name string) (FileInfo, error) {\n \n // For testing.\n func atime(fi FileInfo) time.Time {\n-\treturn time.Unix(int64(fi.(*FileStat).Sys.(*Dir).Atime), 0)\n+\treturn time.Unix(int64(fi.Sys().(*Dir).Atime), 0)\n }"}, {"sha": "c7c5199be1c04365815e838e5a83335356d13074", "filename": "libgo/go/os/types.go", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ftypes.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -19,6 +19,7 @@ type FileInfo interface {\n \tMode() FileMode     // file mode bits\n \tModTime() time.Time // modification time\n \tIsDir() bool        // abbreviation for Mode().IsDir()\n+\tSys() interface{}   // underlying data source (can return nil)\n }\n \n // A FileMode represents a file's mode and permission bits.\n@@ -92,28 +93,33 @@ func (m FileMode) Perm() FileMode {\n \treturn m & ModePerm\n }\n \n-// A FileStat is the implementation of FileInfo returned by Stat and Lstat.\n-// Clients that need access to the underlying system-specific stat information\n-// can test for *os.FileStat and then consult the Sys field.\n-type FileStat struct {\n+// A fileStat is the implementation of FileInfo returned by Stat and Lstat.\n+type fileStat struct {\n \tname    string\n \tsize    int64\n \tmode    FileMode\n \tmodTime time.Time\n-\n-\tSys interface{}\n+\tsys     interface{}\n }\n \n-func (fs *FileStat) Name() string       { return fs.name }\n-func (fs *FileStat) Size() int64        { return fs.size }\n-func (fs *FileStat) Mode() FileMode     { return fs.mode }\n-func (fs *FileStat) ModTime() time.Time { return fs.modTime }\n-func (fs *FileStat) IsDir() bool        { return fs.mode.IsDir() }\n+func (fs *fileStat) Name() string       { return fs.name }\n+func (fs *fileStat) Size() int64        { return fs.size }\n+func (fs *fileStat) Mode() FileMode     { return fs.mode }\n+func (fs *fileStat) ModTime() time.Time { return fs.modTime }\n+func (fs *fileStat) IsDir() bool        { return fs.mode.IsDir() }\n+func (fs *fileStat) Sys() interface{}   { return fs.sys }\n \n-// SameFile reports whether fs and other describe the same file.\n+// SameFile reports whether fi1 and fi2 describe the same file.\n // For example, on Unix this means that the device and inode fields\n // of the two underlying structures are identical; on other systems\n // the decision may be based on the path names.\n-func (fs *FileStat) SameFile(other *FileStat) bool {\n-\treturn sameFile(fs, other)\n+// SameFile only applies to results returned by this package's Stat.\n+// It returns false in other cases.\n+func SameFile(fi1, fi2 FileInfo) bool {\n+\tfs1, ok1 := fi1.(*fileStat)\n+\tfs2, ok2 := fi2.(*fileStat)\n+\tif !ok1 || !ok2 {\n+\t\treturn false\n+\t}\n+\treturn sameFile(fs1.sys, fs2.sys)\n }"}, {"sha": "415f869f2291b358a1592d20320093dc1e701862", "filename": "libgo/go/os/user/lookup_stubs.go", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fuser%2Flookup_stubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fuser%2Flookup_stubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Flookup_stubs.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !cgo windows\n+// +build !cgo,!windows\n \n package user\n \n@@ -11,10 +11,18 @@ import (\n \t\"runtime\"\n )\n \n+func init() {\n+\timplemented = false\n+}\n+\n+func Current() (*User, error) {\n+\treturn nil, fmt.Errorf(\"user: Current not implemented on %s/%s\", runtime.GOOS, runtime.GOARCH)\n+}\n+\n func Lookup(username string) (*User, error) {\n \treturn nil, fmt.Errorf(\"user: Lookup not implemented on %s/%s\", runtime.GOOS, runtime.GOARCH)\n }\n \n-func LookupId(int) (*User, error) {\n+func LookupId(string) (*User, error) {\n \treturn nil, fmt.Errorf(\"user: LookupId not implemented on %s/%s\", runtime.GOOS, runtime.GOARCH)\n }"}, {"sha": "68f8914d089c5911e11642023bf011727c4e9cd8", "filename": "libgo/go/os/user/lookup_unix.go", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -9,6 +9,7 @@ package user\n \n import (\n \t\"fmt\"\n+\t\"strconv\"\n \t\"strings\"\n \t\"syscall\"\n \t\"unsafe\"\n@@ -43,8 +44,9 @@ func bytePtrToString(p *byte) string {\n \treturn string(a[:i])\n }\n \n-func init() {\n-\timplemented = true\n+// Current returns the current user. \n+func Current() (*User, error) {\n+\treturn lookup(syscall.Getuid(), \"\", false)\n }\n \n // Lookup looks up a user by username. If the user cannot be found,\n@@ -55,8 +57,12 @@ func Lookup(username string) (*User, error) {\n \n // LookupId looks up a user by userid. If the user cannot be found,\n // the returned error is of type UnknownUserIdError.\n-func LookupId(uid int) (*User, error) {\n-\treturn lookup(uid, \"\", false)\n+func LookupId(uid string) (*User, error) {\n+\ti, e := strconv.Atoi(uid)\n+\tif e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn lookup(i, \"\", false)\n }\n \n func lookup(uid int, username string, lookupByName bool) (*User, error) {\n@@ -92,8 +98,8 @@ func lookup(uid int, username string, lookupByName bool) (*User, error) {\n \t\t}\n \t}\n \tu := &User{\n-\t\tUid:      int(pwd.Pw_uid),\n-\t\tGid:      int(pwd.Pw_gid),\n+\t\tUid:      strconv.Itoa(int(pwd.Pw_uid)),\n+\t\tGid:      strconv.Itoa(int(pwd.Pw_gid)),\n \t\tUsername: bytePtrToString((*byte)(unsafe.Pointer(pwd.Pw_name))),\n \t\tName:     bytePtrToString((*byte)(unsafe.Pointer(pwd.Pw_gecos))),\n \t\tHomeDir:  bytePtrToString((*byte)(unsafe.Pointer(pwd.Pw_dir))),"}, {"sha": "993687115945483c94841713efcdb0b413d01a4e", "filename": "libgo/go/os/user/lookup_windows.go", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fuser%2Flookup_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fuser%2Flookup_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Flookup_windows.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -0,0 +1,117 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package user\n+\n+import (\n+\t\"fmt\"\n+\t\"syscall\"\n+\t\"unsafe\"\n+)\n+\n+func lookupFullName(domain, username, domainAndUser string) (string, error) {\n+\t// try domain controller first\n+\tname, e := syscall.TranslateAccountName(domainAndUser,\n+\t\tsyscall.NameSamCompatible, syscall.NameDisplay, 50)\n+\tif e != nil {\n+\t\t// domain lookup failed, perhaps this pc is not part of domain\n+\t\td := syscall.StringToUTF16Ptr(domain)\n+\t\tu := syscall.StringToUTF16Ptr(username)\n+\t\tvar p *byte\n+\t\te := syscall.NetUserGetInfo(d, u, 10, &p)\n+\t\tif e != nil {\n+\t\t\treturn \"\", e\n+\t\t}\n+\t\tdefer syscall.NetApiBufferFree(p)\n+\t\ti := (*syscall.UserInfo10)(unsafe.Pointer(p))\n+\t\tif i.FullName == nil {\n+\t\t\treturn \"\", nil\n+\t\t}\n+\t\tname = syscall.UTF16ToString((*[1024]uint16)(unsafe.Pointer(i.FullName))[:])\n+\t}\n+\treturn name, nil\n+}\n+\n+func newUser(usid *syscall.SID, gid, dir string) (*User, error) {\n+\tusername, domain, t, e := usid.LookupAccount(\"\")\n+\tif e != nil {\n+\t\treturn nil, e\n+\t}\n+\tif t != syscall.SidTypeUser {\n+\t\treturn nil, fmt.Errorf(\"user: should be user account type, not %d\", t)\n+\t}\n+\tdomainAndUser := domain + `\\` + username\n+\tuid, e := usid.String()\n+\tif e != nil {\n+\t\treturn nil, e\n+\t}\n+\tname, e := lookupFullName(domain, username, domainAndUser)\n+\tif e != nil {\n+\t\treturn nil, e\n+\t}\n+\tu := &User{\n+\t\tUid:      uid,\n+\t\tGid:      gid,\n+\t\tUsername: domainAndUser,\n+\t\tName:     name,\n+\t\tHomeDir:  dir,\n+\t}\n+\treturn u, nil\n+}\n+\n+// Current returns the current user.\n+func Current() (*User, error) {\n+\tt, e := syscall.OpenCurrentProcessToken()\n+\tif e != nil {\n+\t\treturn nil, e\n+\t}\n+\tu, e := t.GetTokenUser()\n+\tif e != nil {\n+\t\treturn nil, e\n+\t}\n+\tpg, e := t.GetTokenPrimaryGroup()\n+\tif e != nil {\n+\t\treturn nil, e\n+\t}\n+\tgid, e := pg.PrimaryGroup.String()\n+\tif e != nil {\n+\t\treturn nil, e\n+\t}\n+\tdir, e := t.GetUserProfileDirectory()\n+\tif e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn newUser(u.User.Sid, gid, dir)\n+}\n+\n+// BUG(brainman): Lookup and LookupId functions do not set\n+// Gid and HomeDir fields in the User struct returned on windows.\n+\n+func newUserFromSid(usid *syscall.SID) (*User, error) {\n+\t// TODO(brainman): do not know where to get gid and dir fields\n+\tgid := \"unknown\"\n+\tdir := \"Unknown directory\"\n+\treturn newUser(usid, gid, dir)\n+}\n+\n+// Lookup looks up a user by username.\n+func Lookup(username string) (*User, error) {\n+\tsid, _, t, e := syscall.LookupSID(\"\", username)\n+\tif e != nil {\n+\t\treturn nil, e\n+\t}\n+\tif t != syscall.SidTypeUser {\n+\t\treturn nil, fmt.Errorf(\"user: should be user account type, not %d\", t)\n+\t}\n+\treturn newUserFromSid(sid)\n+}\n+\n+// LookupId looks up a user by userid.\n+func LookupId(uid string) (*User, error) {\n+\tsid, e := syscall.StringToSid(uid)\n+\tif e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn newUserFromSid(sid)\n+}"}, {"sha": "841f2263f95f9819fef4c172c98a2d7cbfc63538", "filename": "libgo/go/os/user/user.go", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fuser%2Fuser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fuser%2Fuser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Fuser.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -9,12 +9,16 @@ import (\n \t\"strconv\"\n )\n \n-var implemented = false // set to true by lookup_unix.go's init\n+var implemented = true // set to false by lookup_stubs.go's init\n \n // User represents a user account.\n+//\n+// On posix systems Uid and Gid contain a decimal number\n+// representing uid and gid. On windows Uid and Gid\n+// contain security identifier (SID) in a string format.\n type User struct {\n-\tUid      int // user id\n-\tGid      int // primary group id\n+\tUid      string // user id\n+\tGid      string // primary group id\n \tUsername string\n \tName     string\n \tHomeDir  string"}, {"sha": "b812ebce79a100fcc3e05b08120b9577b3aec4de", "filename": "libgo/go/os/user/user_test.go", "status": "modified", "additions": 56, "deletions": 18, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fuser%2Fuser_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fos%2Fuser%2Fuser_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Fuser_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -6,9 +6,7 @@ package user\n \n import (\n \t\"os\"\n-\t\"reflect\"\n \t\"runtime\"\n-\t\"syscall\"\n \t\"testing\"\n )\n \n@@ -18,44 +16,84 @@ func skip(t *testing.T) bool {\n \t\treturn true\n \t}\n \n-\tif runtime.GOOS == \"linux\" || runtime.GOOS == \"freebsd\" || runtime.GOOS == \"darwin\" {\n+\tswitch runtime.GOOS {\n+\tcase \"linux\", \"freebsd\", \"darwin\", \"windows\":\n \t\treturn false\n \t}\n \n \tt.Logf(\"user: Lookup not implemented on %s; skipping test\", runtime.GOOS)\n \treturn true\n }\n \n-func TestLookup(t *testing.T) {\n+func TestCurrent(t *testing.T) {\n \tif skip(t) {\n \t\treturn\n \t}\n \n-\t// Test LookupId on the current user\n-\tuid := syscall.Getuid()\n-\tu, err := LookupId(uid)\n+\tu, err := Current()\n \tif err != nil {\n-\t\tt.Fatalf(\"LookupId: %v\", err)\n-\t}\n-\tif e, g := uid, u.Uid; e != g {\n-\t\tt.Errorf(\"expected Uid of %d; got %d\", e, g)\n+\t\tt.Fatalf(\"Current: %v\", err)\n \t}\n \tfi, err := os.Stat(u.HomeDir)\n \tif err != nil || !fi.IsDir() {\n-\t\tt.Errorf(\"expected a valid HomeDir; stat(%q): err=%v, IsDir=%v\", u.HomeDir, err, fi.IsDir())\n+\t\tt.Errorf(\"expected a valid HomeDir; stat(%q): err=%v\", u.HomeDir, err)\n \t}\n \tif u.Username == \"\" {\n \t\tt.Fatalf(\"didn't get a username\")\n \t}\n+}\n+\n+func compare(t *testing.T, want, got *User) {\n+\tif want.Uid != got.Uid {\n+\t\tt.Errorf(\"got Uid=%q; want %q\", got.Uid, want.Uid)\n+\t}\n+\tif want.Username != got.Username {\n+\t\tt.Errorf(\"got Username=%q; want %q\", got.Username, want.Username)\n+\t}\n+\tif want.Name != got.Name {\n+\t\tt.Errorf(\"got Name=%q; want %q\", got.Name, want.Name)\n+\t}\n+\t// TODO(brainman): fix it once we know how.\n+\tif runtime.GOOS == \"windows\" {\n+\t\tt.Log(\"skipping Gid and HomeDir comparisons\")\n+\t\treturn\n+\t}\n+\tif want.Gid != got.Gid {\n+\t\tt.Errorf(\"got Gid=%q; want %q\", got.Gid, want.Gid)\n+\t}\n+\tif want.HomeDir != got.HomeDir {\n+\t\tt.Errorf(\"got HomeDir=%q; want %q\", got.HomeDir, want.HomeDir)\n+\t}\n+}\n+\n+func TestLookup(t *testing.T) {\n+\tif skip(t) {\n+\t\treturn\n+\t}\n \n-\t// Test Lookup by username, using the username from LookupId\n-\tun, err := Lookup(u.Username)\n+\twant, err := Current()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Current: %v\", err)\n+\t}\n+\tgot, err := Lookup(want.Username)\n \tif err != nil {\n \t\tt.Fatalf(\"Lookup: %v\", err)\n \t}\n-\tif !reflect.DeepEqual(u, un) {\n-\t\tt.Errorf(\"Lookup by userid vs. name didn't match\\n\"+\n-\t\t\t\"LookupId(%d): %#v\\n\"+\n-\t\t\t\"Lookup(%q): %#v\\n\", uid, u, u.Username, un)\n+\tcompare(t, want, got)\n+}\n+\n+func TestLookupId(t *testing.T) {\n+\tif skip(t) {\n+\t\treturn\n+\t}\n+\n+\twant, err := Current()\n+\tif err != nil {\n+\t\tt.Fatalf(\"Current: %v\", err)\n+\t}\n+\tgot, err := LookupId(want.Uid)\n+\tif err != nil {\n+\t\tt.Fatalf(\"LookupId: %v\", err)\n \t}\n+\tcompare(t, want, got)\n }"}, {"sha": "fdcc637759c082f2816f9fed8d856c547d1c9b88", "filename": "libgo/go/path/filepath/path_test.go", "status": "modified", "additions": 41, "deletions": 34, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -5,6 +5,7 @@\n package filepath_test\n \n import (\n+\t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"reflect\"\n@@ -547,6 +548,7 @@ func TestIsAbs(t *testing.T) {\n }\n \n type EvalSymlinksTest struct {\n+\t// If dest is empty, the path is created; otherwise the dest is symlinked to the path.\n \tpath, dest string\n }\n \n@@ -574,31 +576,42 @@ var EvalSymlinksAbsWindowsTests = []EvalSymlinksTest{\n \t{`c:\\`, `c:\\`},\n }\n \n-func testEvalSymlinks(t *testing.T, tests []EvalSymlinksTest) {\n-\tfor _, d := range tests {\n-\t\tif p, err := filepath.EvalSymlinks(d.path); err != nil {\n-\t\t\tt.Errorf(\"EvalSymlinks(%q) error: %v\", d.path, err)\n-\t\t} else if filepath.Clean(p) != filepath.Clean(d.dest) {\n-\t\t\tt.Errorf(\"EvalSymlinks(%q)=%q, want %q\", d.path, p, d.dest)\n-\t\t}\n-\t}\n+// simpleJoin builds a file name from the directory and path.\n+// It does not use Join because we don't want \"..\" to be evaluated.\n+func simpleJoin(dir, path string) string {\n+\treturn dir + string(filepath.Separator) + path\n }\n \n func TestEvalSymlinks(t *testing.T) {\n-\tdefer os.RemoveAll(\"test\")\n+\ttmpDir, err := ioutil.TempDir(\"\", \"evalsymlink\")\n+\tif err != nil {\n+\t\tt.Fatal(\"creating temp dir:\", err)\n+\t}\n+\tdefer os.RemoveAll(tmpDir)\n+\n+\t// /tmp may itself be a symlink! Avoid the confusion, although\n+\t// it means trusting the thing we're testing.\n+\ttmpDir, err = filepath.EvalSymlinks(tmpDir)\n+\tif err != nil {\n+\t\tt.Fatal(\"eval symlink for tmp dir:\", err)\n+\t}\n+\n+\t// Create the symlink farm using relative paths.\n \tfor _, d := range EvalSymlinksTestDirs {\n \t\tvar err error\n+\t\tpath := simpleJoin(tmpDir, d.path)\n \t\tif d.dest == \"\" {\n-\t\t\terr = os.Mkdir(d.path, 0755)\n+\t\t\terr = os.Mkdir(path, 0755)\n \t\t} else {\n \t\t\tif runtime.GOOS != \"windows\" {\n-\t\t\t\terr = os.Symlink(d.dest, d.path)\n+\t\t\t\terr = os.Symlink(d.dest, path)\n \t\t\t}\n \t\t}\n \t\tif err != nil {\n \t\t\tt.Fatal(err)\n \t\t}\n \t}\n+\n \tvar tests []EvalSymlinksTest\n \tif runtime.GOOS == \"windows\" {\n \t\tfor _, d := range EvalSymlinksTests {\n@@ -610,26 +623,17 @@ func TestEvalSymlinks(t *testing.T) {\n \t} else {\n \t\ttests = EvalSymlinksTests\n \t}\n-\t// relative\n-\ttestEvalSymlinks(t, tests)\n-\t// absolute\n-\t/* These tests do not work in the gccgo test environment.\n-\tgoroot, err := filepath.EvalSymlinks(os.Getenv(\"GOROOT\"))\n-\tif err != nil {\n-\t\tt.Fatalf(\"EvalSymlinks(%q) error: %v\", os.Getenv(\"GOROOT\"), err)\n-\t}\n-\ttestroot := filepath.Join(goroot, \"src\", \"pkg\", \"path\", \"filepath\")\n-\tfor i, d := range tests {\n-\t\ttests[i].path = filepath.Join(testroot, d.path)\n-\t\ttests[i].dest = filepath.Join(testroot, d.dest)\n-\t}\n-\tif runtime.GOOS == \"windows\" {\n-\t\tfor _, d := range EvalSymlinksAbsWindowsTests {\n-\t\t\ttests = append(tests, d)\n+\n+\t// Evaluate the symlink farm.\n+\tfor _, d := range tests {\n+\t\tpath := simpleJoin(tmpDir, d.path)\n+\t\tdest := simpleJoin(tmpDir, d.dest)\n+\t\tif p, err := filepath.EvalSymlinks(path); err != nil {\n+\t\t\tt.Errorf(\"EvalSymlinks(%q) error: %v\", d.path, err)\n+\t\t} else if filepath.Clean(p) != filepath.Clean(dest) {\n+\t\t\tt.Errorf(\"Clean(%q)=%q, want %q\", path, p, dest)\n \t\t}\n \t}\n-\ttestEvalSymlinks(t, tests)\n-\t*/\n }\n \n /* These tests do not work in the gccgo test environment.\n@@ -638,16 +642,19 @@ func TestEvalSymlinks(t *testing.T) {\n var abstests = []string{\n \t\"../AUTHORS\",\n \t\"pkg/../../AUTHORS\",\n-\t\"Make.pkg\",\n-\t\"pkg/Makefile\",\n+\t\"Make.inc\",\n+\t\"pkg/math\",\n \t\".\",\n-\t\"$GOROOT/src/Make.pkg\",\n-\t\"$GOROOT/src/../src/Make.pkg\",\n+\t\"$GOROOT/src/Make.inc\",\n+\t\"$GOROOT/src/../src/Make.inc\",\n \t\"$GOROOT/misc/cgo\",\n \t\"$GOROOT\",\n }\n \n func TestAbs(t *testing.T) {\n+\tt.Logf(\"test needs to be rewritten; disabled\")\n+\treturn\n+\n \toldwd, err := os.Getwd()\n \tif err != nil {\n \t\tt.Fatal(\"Getwd failed: \" + err.Error())\n@@ -670,7 +677,7 @@ func TestAbs(t *testing.T) {\n \t\t\tcontinue\n \t\t}\n \t\tabsinfo, err := os.Stat(abspath)\n-\t\tif err != nil || !absinfo.(*os.FileStat).SameFile(info.(*os.FileStat)) {\n+\t\tif err != nil || !os.SameFile(absinfo, info) {\n \t\t\tt.Errorf(\"Abs(%q)=%q, not the same file\", path, abspath)\n \t\t}\n \t\tif !filepath.IsAbs(abspath) {"}, {"sha": "557fb8e843eb4ca4515e50168ba29f6ae6b1f872", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -1547,15 +1547,19 @@ func TestAddr(t *testing.T) {\n func noAlloc(t *testing.T, n int, f func(int)) {\n \t// once to prime everything\n \tf(-1)\n-\truntime.MemStats.Mallocs = 0\n+\tmemstats := new(runtime.MemStats)\n+\truntime.ReadMemStats(memstats)\n+\toldmallocs := memstats.Mallocs\n \n \tfor j := 0; j < n; j++ {\n \t\tf(j)\n \t}\n \t// A few allocs may happen in the testing package when GOMAXPROCS > 1, so don't\n \t// require zero mallocs.\n-\tif runtime.MemStats.Mallocs > 5 {\n-\t\tt.Fatalf(\"%d mallocs after %d iterations\", runtime.MemStats.Mallocs, n)\n+\truntime.ReadMemStats(memstats)\n+\tmallocs := memstats.Mallocs - oldmallocs\n+\tif mallocs > 5 {\n+\t\tt.Fatalf(\"%d mallocs after %d iterations\", mallocs, n)\n \t}\n }\n "}, {"sha": "1bb0a26b7a6bfcab7d99f1de4c25cd53a7136699", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -789,6 +789,14 @@ func (t *structType) Field(i int) (f StructField) {\n \t\tf.Tag = StructTag(*p.tag)\n \t}\n \tf.Offset = p.offset\n+\n+\t// NOTE(rsc): This is the only allocation in the interface\n+\t// presented by a reflect.Type.  It would be nice to avoid,\n+\t// at least in the common cases, but we need to make sure\n+\t// that misbehaving clients of reflect cannot affect other\n+\t// uses of reflect.  One possibility is CL 5371098, but we\n+\t// postponed that ugliness until there is a demonstrated\n+\t// need for the performance.  This is issue 2320.\n \tf.Index = []int{i}\n \treturn\n }"}, {"sha": "07688bef9c4b0864b507a330febba30e569490ab", "filename": "libgo/go/regexp/syntax/parse.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -1377,8 +1377,8 @@ func (p *parser) appendGroup(r []rune, g charGroup) []rune {\n }\n \n var anyTable = &unicode.RangeTable{\n-\t[]unicode.Range16{{0, 1<<16 - 1, 1}},\n-\t[]unicode.Range32{{1 << 16, unicode.MaxRune, 1}},\n+\tR16: []unicode.Range16{{Lo: 0, Hi: 1<<16 - 1, Stride: 1}},\n+\tR32: []unicode.Range32{{Lo: 1 << 16, Hi: unicode.MaxRune, Stride: 1}},\n }\n \n // unicodeTable returns the unicode.RangeTable identified by name"}, {"sha": "739ebcba2ff81e1580959ac784471869734b3fdf", "filename": "libgo/go/runtime/gc_test.go", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fruntime%2Fgc_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fruntime%2Fgc_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fgc_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -10,20 +10,21 @@ import (\n )\n \n func TestGcSys(t *testing.T) {\n+\tmemstats := new(runtime.MemStats)\n \truntime.GC()\n-\truntime.UpdateMemStats()\n-\tsys := runtime.MemStats.Sys\n+\truntime.ReadMemStats(memstats)\n+\tsys := memstats.Sys\n \n \tfor i := 0; i < 1000000; i++ {\n \t\tworkthegc()\n \t}\n \n \t// Should only be using a few MB.\n-\truntime.UpdateMemStats()\n-\tif sys > runtime.MemStats.Sys {\n+\truntime.ReadMemStats(memstats)\n+\tif sys > memstats.Sys {\n \t\tsys = 0\n \t} else {\n-\t\tsys = runtime.MemStats.Sys - sys\n+\t\tsys = memstats.Sys - sys\n \t}\n \tt.Logf(\"used %d extra bytes\", sys)\n \tif sys > 4<<20 {"}, {"sha": "1301674c027adc923d2a377510ec0a2b808a82b5", "filename": "libgo/go/runtime/mem.go", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fruntime%2Fmem.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fruntime%2Fmem.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmem.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -6,9 +6,9 @@ package runtime\n \n import \"unsafe\"\n \n-type MemStatsType struct {\n+// A MemStats records statistics about the memory allocator.\n+type MemStats struct {\n \t// General statistics.\n-\t// Not locked during update; approximate.\n \tAlloc      uint64 // bytes allocated and still in use\n \tTotalAlloc uint64 // bytes allocated (even if freed)\n \tSys        uint64 // bytes obtained from system (should be sum of XxxSys below)\n@@ -43,7 +43,6 @@ type MemStatsType struct {\n \tDebugGC      bool\n \n \t// Per-size allocation statistics.\n-\t// Not locked during update; approximate.\n \t// 61 is NumSizeClasses in the C code.\n \tBySize [61]struct {\n \t\tSize    uint32\n@@ -54,21 +53,17 @@ type MemStatsType struct {\n \n var Sizeof_C_MStats uintptr // filled in by malloc.goc\n \n+var VmemStats MemStats\n+\n func init() {\n-\tif Sizeof_C_MStats != unsafe.Sizeof(MemStats) {\n-\t\tprintln(Sizeof_C_MStats, unsafe.Sizeof(MemStats))\n+\tif Sizeof_C_MStats != unsafe.Sizeof(VmemStats) {\n+\t\tprintln(Sizeof_C_MStats, unsafe.Sizeof(VmemStats))\n \t\tpanic(\"MStats vs MemStatsType size mismatch\")\n \t}\n }\n \n-// MemStats holds statistics about the memory system.\n-// The statistics may be out of date, as the information is\n-// updated lazily from per-thread caches.\n-// Use UpdateMemStats to bring the statistics up to date.\n-var MemStats MemStatsType\n-\n-// UpdateMemStats brings MemStats up to date.\n-func UpdateMemStats()\n+// ReadMemStats populates m with memory allocator statistics.\n+func ReadMemStats(m *MemStats)\n \n // GC runs a garbage collection.\n func GC()"}, {"sha": "a8e78e0ea754ad81ff933ad166178ff2a1a4b62b", "filename": "libgo/go/runtime/pprof/pprof.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -75,7 +75,8 @@ func WriteHeapProfile(w io.Writer) error {\n \n \t// Print memstats information too.\n \t// Pprof will ignore, but useful for people.\n-\ts := &runtime.MemStats\n+\ts := new(runtime.MemStats)\n+\truntime.ReadMemStats(s)\n \tfmt.Fprintf(b, \"\\n# runtime.MemStats\\n\")\n \tfmt.Fprintf(b, \"# Alloc = %d\\n\", s.Alloc)\n \tfmt.Fprintf(b, \"# TotalAlloc = %d\\n\", s.TotalAlloc)"}, {"sha": "bac23e6ea6742c816ca9f10367f82e22c193e72c", "filename": "libgo/go/strconv/itoa_test.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fstrconv%2Fitoa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fstrconv%2Fitoa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fitoa_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -127,11 +127,12 @@ func TestUitoa(t *testing.T) {\n }\n \n func numAllocations(f func()) int {\n-\truntime.UpdateMemStats()\n-\tn0 := runtime.MemStats.Mallocs\n+\tmemstats := new(runtime.MemStats)\n+\truntime.ReadMemStats(memstats)\n+\tn0 := memstats.Mallocs\n \tf()\n-\truntime.UpdateMemStats()\n-\treturn int(runtime.MemStats.Mallocs - n0)\n+\truntime.ReadMemStats(memstats)\n+\treturn int(memstats.Mallocs - n0)\n }\n \n /* This test relies on escape analysis which gccgo does not yet do."}, {"sha": "16e53678b20c71da9c8c5a6f9307f0454eef7d69", "filename": "libgo/go/strings/example_test.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fstrings%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fstrings%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fexample_test.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package strings_test\n+\n+import (\n+\t\"fmt\"\n+\t\"strings\"\n+)\n+\n+// Fields are: [\"foo\" \"bar\" \"baz\"]\n+func ExampleFields() {\n+\tfmt.Printf(\"Fields are: %q\", strings.Fields(\"  foo bar  baz   \"))\n+}"}, {"sha": "2848d9b32b87864e03e879d704fb958e2dd7dfb6", "filename": "libgo/go/syscall/env_plan9.go", "status": "modified", "additions": 95, "deletions": 41, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fsyscall%2Fenv_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fsyscall%2Fenv_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fenv_plan9.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -6,69 +6,123 @@\n \n package syscall\n \n-import \"errors\"\n+import (\n+\t\"errors\"\n+\t\"sync\"\n+)\n \n-func Getenv(key string) (value string, found bool) {\n-\tif len(key) == 0 {\n-\t\treturn \"\", false\n+var (\n+\t// envOnce guards initialization by copyenv, which populates env.\n+\tenvOnce sync.Once\n+\n+\t// envLock guards env.\n+\tenvLock sync.RWMutex\n+\n+\t// env maps from an environment variable to its value.\n+\tenv map[string]string\n+)\n+\n+func readenv(key string) (string, error) {\n+\tfd, err := Open(\"/env/\"+key, O_RDONLY)\n+\tif err != nil {\n+\t\treturn \"\", err\n \t}\n-\tf, e := Open(\"/env/\"+key, O_RDONLY)\n-\tif e != nil {\n-\t\treturn \"\", false\n+\tdefer Close(fd)\n+\tl, _ := Seek(fd, 0, 2)\n+\tSeek(fd, 0, 0)\n+\tbuf := make([]byte, l)\n+\tn, err := Read(fd, buf)\n+\tif err != nil {\n+\t\treturn \"\", err\n \t}\n-\tdefer Close(f)\n+\tif n > 0 && buf[n-1] == 0 {\n+\t\tbuf = buf[:n-1]\n+\t}\n+\treturn string(buf), nil\n+}\n \n-\tl, _ := Seek(f, 0, 2)\n-\tSeek(f, 0, 0)\n-\tbuf := make([]byte, l)\n-\tn, e := Read(f, buf)\n-\tif e != nil {\n+func writeenv(key, value string) error {\n+\tfd, err := Create(\"/env/\"+key, O_RDWR, 0666)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer Close(fd)\n+\t_, err = Write(fd, []byte(value))\n+\treturn err\n+}\n+\n+func copyenv() {\n+\tenv = make(map[string]string)\n+\tfd, err := Open(\"/env\", O_RDONLY)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tdefer Close(fd)\n+\tfiles, err := readdirnames(fd)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tfor _, key := range files {\n+\t\tv, err := readenv(key)\n+\t\tif err != nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tenv[key] = v\n+\t}\n+}\n+\n+func Getenv(key string) (value string, found bool) {\n+\tenvOnce.Do(copyenv)\n+\tif len(key) == 0 {\n \t\treturn \"\", false\n \t}\n \n-\tif n > 0 && buf[n-1] == 0 {\n-\t\tbuf = buf[:n-1]\n+\tenvLock.RLock()\n+\tdefer envLock.RUnlock()\n+\n+\tv, ok := env[key]\n+\tif !ok {\n+\t\treturn \"\", false\n \t}\n-\treturn string(buf), true\n+\treturn v, true\n }\n \n func Setenv(key, value string) error {\n+\tenvOnce.Do(copyenv)\n \tif len(key) == 0 {\n-\t\treturn errors.New(\"bad arg in system call\")\n+\t\treturn errors.New(\"zero length key\")\n \t}\n \n-\tf, e := Create(\"/env/\"+key, O_RDWR, 0666)\n-\tif e != nil {\n-\t\treturn e\n-\t}\n-\tdefer Close(f)\n+\tenvLock.Lock()\n+\tdefer envLock.Unlock()\n \n-\t_, e = Write(f, []byte(value))\n+\terr := writeenv(key, value)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tenv[key] = value\n \treturn nil\n }\n \n func Clearenv() {\n+\tenvOnce.Do(copyenv) // prevent copyenv in Getenv/Setenv\n+\n+\tenvLock.Lock()\n+\tdefer envLock.Unlock()\n+\n+\tenv = make(map[string]string)\n \tRawSyscall(SYS_RFORK, RFCENVG, 0, 0)\n }\n \n func Environ() []string {\n-\tenv := make([]string, 0, 100)\n-\n-\tf, e := Open(\"/env\", O_RDONLY)\n-\tif e != nil {\n-\t\tpanic(e)\n-\t}\n-\tdefer Close(f)\n-\n-\tnames, e := readdirnames(f)\n-\tif e != nil {\n-\t\tpanic(e)\n-\t}\n-\n-\tfor _, k := range names {\n-\t\tif v, ok := Getenv(k); ok {\n-\t\t\tenv = append(env, k+\"=\"+v)\n-\t\t}\n+\tenvOnce.Do(copyenv)\n+\tenvLock.RLock()\n+\tdefer envLock.RUnlock()\n+\ta := make([]string, len(env))\n+\ti := 0\n+\tfor k, v := range env {\n+\t\ta[i] = k + \"=\" + v\n+\t\ti++\n \t}\n-\treturn env[0:len(env)]\n+\treturn a\n }"}, {"sha": "75f0f45adaff6a25143f87784147e41e16b61f6f", "filename": "libgo/go/syscall/exec_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fsyscall%2Fexec_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fsyscall%2Fexec_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_unix.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -244,7 +244,7 @@ func ForkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err error)\n }\n \n // StartProcess wraps ForkExec for package os.\n-func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid, handle int, err error) {\n+func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid int, handle uintptr, err error) {\n \tpid, err = forkExec(argv0, argv, attr)\n \treturn pid, 0, err\n }"}, {"sha": "6cb25a7d00a9362bbfca5641eebe89bfca3b1042", "filename": "libgo/go/syscall/exec_windows.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fsyscall%2Fexec_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fsyscall%2Fexec_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_windows.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -232,7 +232,7 @@ type SysProcAttr struct {\n var zeroProcAttr ProcAttr\n var zeroSysProcAttr SysProcAttr\n \n-func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid, handle int, err error) {\n+func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid int, handle uintptr, err error) {\n \tif len(argv0) == 0 {\n \t\treturn 0, 0, EWINDOWS\n \t}\n@@ -319,7 +319,7 @@ func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid, handle int,\n \t}\n \tdefer CloseHandle(Handle(pi.Thread))\n \n-\treturn int(pi.ProcessId), int(pi.Process), nil\n+\treturn int(pi.ProcessId), uintptr(pi.Process), nil\n }\n \n func Exec(argv0 string, argv []string, envv []string) (err error) {"}, {"sha": "bd40fe5867605e6415947108ef2f4de2bb41903f", "filename": "libgo/go/syscall/security_windows.go", "status": "added", "additions": 359, "deletions": 0, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fsyscall%2Fsecurity_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fsyscall%2Fsecurity_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsecurity_windows.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -0,0 +1,359 @@\n+// Copyright 2012 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package syscall\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+const (\n+\tSTANDARD_RIGHTS_REQUIRED = 0xf0000\n+\tSTANDARD_RIGHTS_READ     = 0x20000\n+\tSTANDARD_RIGHTS_WRITE    = 0x20000\n+\tSTANDARD_RIGHTS_EXECUTE  = 0x20000\n+\tSTANDARD_RIGHTS_ALL      = 0x1F0000\n+)\n+\n+const (\n+\tNameUnknown          = 0\n+\tNameFullyQualifiedDN = 1\n+\tNameSamCompatible    = 2\n+\tNameDisplay          = 3\n+\tNameUniqueId         = 6\n+\tNameCanonical        = 7\n+\tNameUserPrincipal    = 8\n+\tNameCanonicalEx      = 9\n+\tNameServicePrincipal = 10\n+\tNameDnsDomain        = 12\n+)\n+\n+// This function returns 1 byte BOOLEAN rather than the 4 byte BOOL.\n+// http://blogs.msdn.com/b/drnick/archive/2007/12/19/windows-and-upn-format-credentials.aspx\n+//sys\tTranslateName(accName *uint16, accNameFormat uint32, desiredNameFormat uint32, translatedName *uint16, nSize *uint32) (err error) [failretval&0xff==0] = secur32.TranslateNameW\n+//sys\tGetUserNameEx(nameFormat uint32, nameBuffre *uint16, nSize *uint32) (err error) [failretval&0xff==0] = secur32.GetUserNameExW\n+\n+// TranslateAccountName converts a directory service\n+// object name from one format to another.\n+func TranslateAccountName(username string, from, to uint32, initSize int) (string, error) {\n+\tu := StringToUTF16Ptr(username)\n+\tb := make([]uint16, 50)\n+\tn := uint32(len(b))\n+\te := TranslateName(u, from, to, &b[0], &n)\n+\tif e != nil {\n+\t\tif e != ERROR_INSUFFICIENT_BUFFER {\n+\t\t\treturn \"\", e\n+\t\t}\n+\t\t// make receive buffers of requested size and try again\n+\t\tb = make([]uint16, n)\n+\t\te = TranslateName(u, from, to, &b[0], &n)\n+\t\tif e != nil {\n+\t\t\treturn \"\", e\n+\t\t}\n+\t}\n+\treturn UTF16ToString(b), nil\n+}\n+\n+type UserInfo10 struct {\n+\tName       *uint16\n+\tComment    *uint16\n+\tUsrComment *uint16\n+\tFullName   *uint16\n+}\n+\n+//sys\tNetUserGetInfo(serverName *uint16, userName *uint16, level uint32, buf **byte) (neterr error) = netapi32.NetUserGetInfo\n+//sys\tNetApiBufferFree(buf *byte) (neterr error) = netapi32.NetApiBufferFree\n+\n+const (\n+\t// do not reorder\n+\tSidTypeUser = 1 << iota\n+\tSidTypeGroup\n+\tSidTypeDomain\n+\tSidTypeAlias\n+\tSidTypeWellKnownGroup\n+\tSidTypeDeletedAccount\n+\tSidTypeInvalid\n+\tSidTypeUnknown\n+\tSidTypeComputer\n+\tSidTypeLabel\n+)\n+\n+//sys\tLookupAccountSid(systemName *uint16, sid *SID, name *uint16, nameLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) = advapi32.LookupAccountSidW\n+//sys\tLookupAccountName(systemName *uint16, accountName *uint16, sid *SID, sidLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) = advapi32.LookupAccountNameW\n+//sys\tConvertSidToStringSid(sid *SID, stringSid **uint16) (err error) = advapi32.ConvertSidToStringSidW\n+//sys\tConvertStringSidToSid(stringSid *uint16, sid **SID) (err error) = advapi32.ConvertStringSidToSidW\n+//sys\tGetLengthSid(sid *SID) (len uint32) = advapi32.GetLengthSid\n+//sys\tCopySid(destSidLen uint32, destSid *SID, srcSid *SID) (err error) = advapi32.CopySid\n+\n+// The security identifier (SID) structure is a variable-length\n+// structure used to uniquely identify users or groups.\n+type SID struct{}\n+\n+// StringToSid converts a string-format security identifier\n+// sid into a valid, functional sid.\n+func StringToSid(s string) (*SID, error) {\n+\tvar sid *SID\n+\te := ConvertStringSidToSid(StringToUTF16Ptr(s), &sid)\n+\tif e != nil {\n+\t\treturn nil, e\n+\t}\n+\tdefer LocalFree((Handle)(unsafe.Pointer(sid)))\n+\treturn sid.Copy()\n+}\n+\n+// LookupSID retrieves a security identifier sid for the account\n+// and the name of the domain on which the account was found.\n+// System specify target computer to search.\n+func LookupSID(system, account string) (sid *SID, domain string, accType uint32, err error) {\n+\tif len(account) == 0 {\n+\t\treturn nil, \"\", 0, EINVAL\n+\t}\n+\tacc := StringToUTF16Ptr(account)\n+\tvar sys *uint16\n+\tif len(system) > 0 {\n+\t\tsys = StringToUTF16Ptr(system)\n+\t}\n+\tdb := make([]uint16, 50)\n+\tdn := uint32(len(db))\n+\tb := make([]byte, 50)\n+\tn := uint32(len(b))\n+\tsid = (*SID)(unsafe.Pointer(&b[0]))\n+\te := LookupAccountName(sys, acc, sid, &n, &db[0], &dn, &accType)\n+\tif e != nil {\n+\t\tif e != ERROR_INSUFFICIENT_BUFFER {\n+\t\t\treturn nil, \"\", 0, e\n+\t\t}\n+\t\t// make receive buffers of requested size and try again\n+\t\tb = make([]byte, n)\n+\t\tsid = (*SID)(unsafe.Pointer(&b[0]))\n+\t\tdb = make([]uint16, dn)\n+\t\te = LookupAccountName(sys, acc, sid, &n, &db[0], &dn, &accType)\n+\t\tif e != nil {\n+\t\t\treturn nil, \"\", 0, e\n+\t\t}\n+\t}\n+\treturn sid, UTF16ToString(db), accType, nil\n+}\n+\n+// String converts sid to a string format\n+// suitable for display, storage, or transmission.\n+func (sid *SID) String() (string, error) {\n+\tvar s *uint16\n+\te := ConvertSidToStringSid(sid, &s)\n+\tif e != nil {\n+\t\treturn \"\", e\n+\t}\n+\tdefer LocalFree((Handle)(unsafe.Pointer(s)))\n+\treturn UTF16ToString((*[256]uint16)(unsafe.Pointer(s))[:]), nil\n+}\n+\n+// Len returns the length, in bytes, of a valid security identifier sid.\n+func (sid *SID) Len() int {\n+\treturn int(GetLengthSid(sid))\n+}\n+\n+// Copy creates a duplicate of security identifier sid.\n+func (sid *SID) Copy() (*SID, error) {\n+\tb := make([]byte, sid.Len())\n+\tsid2 := (*SID)(unsafe.Pointer(&b[0]))\n+\te := CopySid(uint32(len(b)), sid2, sid)\n+\tif e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn sid2, nil\n+}\n+\n+// LookupAccount retrieves the name of the account for this sid\n+// and the name of the first domain on which this sid is found.\n+// System specify target computer to search for.\n+func (sid *SID) LookupAccount(system string) (account, domain string, accType uint32, err error) {\n+\tvar sys *uint16\n+\tif len(system) > 0 {\n+\t\tsys = StringToUTF16Ptr(system)\n+\t}\n+\tb := make([]uint16, 50)\n+\tn := uint32(len(b))\n+\tdb := make([]uint16, 50)\n+\tdn := uint32(len(db))\n+\te := LookupAccountSid(sys, sid, &b[0], &n, &db[0], &dn, &accType)\n+\tif e != nil {\n+\t\tif e != ERROR_INSUFFICIENT_BUFFER {\n+\t\t\treturn \"\", \"\", 0, e\n+\t\t}\n+\t\t// make receive buffers of requested size and try again\n+\t\tb = make([]uint16, n)\n+\t\tdb = make([]uint16, dn)\n+\t\te = LookupAccountSid(nil, sid, &b[0], &n, &db[0], &dn, &accType)\n+\t\tif e != nil {\n+\t\t\treturn \"\", \"\", 0, e\n+\t\t}\n+\t}\n+\treturn UTF16ToString(b), UTF16ToString(db), accType, nil\n+}\n+\n+const (\n+\t// do not reorder\n+\tTOKEN_ASSIGN_PRIMARY = 1 << iota\n+\tTOKEN_DUPLICATE\n+\tTOKEN_IMPERSONATE\n+\tTOKEN_QUERY\n+\tTOKEN_QUERY_SOURCE\n+\tTOKEN_ADJUST_PRIVILEGES\n+\tTOKEN_ADJUST_GROUPS\n+\tTOKEN_ADJUST_DEFAULT\n+\n+\tTOKEN_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED |\n+\t\tTOKEN_ASSIGN_PRIMARY |\n+\t\tTOKEN_DUPLICATE |\n+\t\tTOKEN_IMPERSONATE |\n+\t\tTOKEN_QUERY |\n+\t\tTOKEN_QUERY_SOURCE |\n+\t\tTOKEN_ADJUST_PRIVILEGES |\n+\t\tTOKEN_ADJUST_GROUPS |\n+\t\tTOKEN_ADJUST_DEFAULT\n+\tTOKEN_READ  = STANDARD_RIGHTS_READ | TOKEN_QUERY\n+\tTOKEN_WRITE = STANDARD_RIGHTS_WRITE |\n+\t\tTOKEN_ADJUST_PRIVILEGES |\n+\t\tTOKEN_ADJUST_GROUPS |\n+\t\tTOKEN_ADJUST_DEFAULT\n+\tTOKEN_EXECUTE = STANDARD_RIGHTS_EXECUTE\n+)\n+\n+const (\n+\t// do not reorder\n+\tTokenUser = 1 + iota\n+\tTokenGroups\n+\tTokenPrivileges\n+\tTokenOwner\n+\tTokenPrimaryGroup\n+\tTokenDefaultDacl\n+\tTokenSource\n+\tTokenType\n+\tTokenImpersonationLevel\n+\tTokenStatistics\n+\tTokenRestrictedSids\n+\tTokenSessionId\n+\tTokenGroupsAndPrivileges\n+\tTokenSessionReference\n+\tTokenSandBoxInert\n+\tTokenAuditPolicy\n+\tTokenOrigin\n+\tTokenElevationType\n+\tTokenLinkedToken\n+\tTokenElevation\n+\tTokenHasRestrictions\n+\tTokenAccessInformation\n+\tTokenVirtualizationAllowed\n+\tTokenVirtualizationEnabled\n+\tTokenIntegrityLevel\n+\tTokenUIAccess\n+\tTokenMandatoryPolicy\n+\tTokenLogonSid\n+\tMaxTokenInfoClass\n+)\n+\n+type SIDAndAttributes struct {\n+\tSid        *SID\n+\tAttributes uint32\n+}\n+\n+type Tokenuser struct {\n+\tUser SIDAndAttributes\n+}\n+\n+type Tokenprimarygroup struct {\n+\tPrimaryGroup *SID\n+}\n+\n+//sys\tOpenProcessToken(h Handle, access uint32, token *Token) (err error) = advapi32.OpenProcessToken\n+//sys\tGetTokenInformation(t Token, infoClass uint32, info *byte, infoLen uint32, returnedLen *uint32) (err error) = advapi32.GetTokenInformation\n+//sys\tGetUserProfileDirectory(t Token, dir *uint16, dirLen *uint32) (err error) = userenv.GetUserProfileDirectoryW\n+\n+// An access token contains the security information for a logon session.\n+// The system creates an access token when a user logs on, and every\n+// process executed on behalf of the user has a copy of the token.\n+// The token identifies the user, the user's groups, and the user's\n+// privileges. The system uses the token to control access to securable\n+// objects and to control the ability of the user to perform various\n+// system-related operations on the local computer.\n+type Token Handle\n+\n+// OpenCurrentProcessToken opens the access token\n+// associated with current process.\n+func OpenCurrentProcessToken() (Token, error) {\n+\tp, e := GetCurrentProcess()\n+\tif e != nil {\n+\t\treturn 0, e\n+\t}\n+\tvar t Token\n+\te = OpenProcessToken(p, TOKEN_QUERY, &t)\n+\tif e != nil {\n+\t\treturn 0, e\n+\t}\n+\treturn t, nil\n+}\n+\n+// Close releases access to access token.\n+func (t Token) Close() error {\n+\treturn CloseHandle(Handle(t))\n+}\n+\n+// getInfo retrieves a specified type of information about an access token.\n+func (t Token) getInfo(class uint32, initSize int) (unsafe.Pointer, error) {\n+\tb := make([]byte, initSize)\n+\tvar n uint32\n+\te := GetTokenInformation(t, class, &b[0], uint32(len(b)), &n)\n+\tif e != nil {\n+\t\tif e != ERROR_INSUFFICIENT_BUFFER {\n+\t\t\treturn nil, e\n+\t\t}\n+\t\t// make receive buffers of requested size and try again\n+\t\tb = make([]byte, n)\n+\t\te = GetTokenInformation(t, class, &b[0], uint32(len(b)), &n)\n+\t\tif e != nil {\n+\t\t\treturn nil, e\n+\t\t}\n+\t}\n+\treturn unsafe.Pointer(&b[0]), nil\n+}\n+\n+// GetTokenUser retrieves access token t user account information.\n+func (t Token) GetTokenUser() (*Tokenuser, error) {\n+\ti, e := t.getInfo(TokenUser, 50)\n+\tif e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn (*Tokenuser)(i), nil\n+}\n+\n+// GetTokenPrimaryGroup retrieves access token t primary group information.\n+// A pointer to a SID structure representing a group that will become\n+// the primary group of any objects created by a process using this access token.\n+func (t Token) GetTokenPrimaryGroup() (*Tokenprimarygroup, error) {\n+\ti, e := t.getInfo(TokenPrimaryGroup, 50)\n+\tif e != nil {\n+\t\treturn nil, e\n+\t}\n+\treturn (*Tokenprimarygroup)(i), nil\n+}\n+\n+// GetUserProfileDirectory retrieves path to the\n+// root directory of the access token t user's profile.\n+func (t Token) GetUserProfileDirectory() (string, error) {\n+\tb := make([]uint16, 100)\n+\tn := uint32(len(b))\n+\te := GetUserProfileDirectory(t, &b[0], &n)\n+\tif e != nil {\n+\t\tif e != ERROR_INSUFFICIENT_BUFFER {\n+\t\t\treturn \"\", e\n+\t\t}\n+\t\t// make receive buffers of requested size and try again\n+\t\tb = make([]uint16, n)\n+\t\te = GetUserProfileDirectory(t, &b[0], &n)\n+\t\tif e != nil {\n+\t\t\treturn \"\", e\n+\t\t}\n+\t}\n+\treturn UTF16ToString(b), nil\n+}"}, {"sha": "4efaaec3bd28ed3a4d6b8b586d2d58d8ff94a8a7", "filename": "libgo/go/syscall/syscall.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fsyscall%2Fsyscall.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Fsyscall%2Fsyscall.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -33,6 +33,7 @@ func StringBytePtr(s string) *byte { return &StringByteSlice(s)[0] }\n var _zero uintptr\n \n var dummy *byte\n+\n const sizeofPtr uintptr = uintptr(unsafe.Sizeof(dummy))\n \n func (ts *Timespec) Unix() (sec int64, nsec int64) {\n@@ -42,3 +43,11 @@ func (ts *Timespec) Unix() (sec int64, nsec int64) {\n func (tv *Timeval) Unix() (sec int64, nsec int64) {\n \treturn int64(tv.Sec), int64(tv.Usec) * 1000\n }\n+\n+func (ts *Timespec) Nano() int64 {\n+\treturn int64(ts.Sec)*1e9 + int64(ts.Nsec)\n+}\n+\n+func (tv *Timeval) Nano() int64 {\n+\treturn int64(tv.Sec)*1e9 + int64(tv.Usec)*1000\n+}"}, {"sha": "68ecebb36f44ba2365699a10756b90b22bbbbcbd", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -225,6 +225,19 @@ func (c *common) Fatalf(format string, args ...interface{}) {\n \tc.FailNow()\n }\n \n+// TODO(dsymonds): Consider hooking into runtime\u00b7traceback instead.\n+func (c *common) stack() {\n+\tfor i := 2; ; i++ { // Caller we care about is the user, 2 frames up\n+\t\tpc, file, line, ok := runtime.Caller(i)\n+\t\tf := runtime.FuncForPC(pc)\n+\t\tif !ok || f == nil {\n+\t\t\tbreak\n+\t\t}\n+\t\tc.Logf(\"%s:%d (0x%x)\", file, line, pc)\n+\t\tc.Logf(\"\\t%s\", f.Name())\n+\t}\n+}\n+\n // Parallel signals that this test is to be run in parallel with (and only with) \n // other parallel tests in this CPU group.\n func (t *T) Parallel() {\n@@ -247,6 +260,13 @@ func tRunner(t *T, test *InternalTest) {\n \t// a call to runtime.Goexit, record the duration and send\n \t// a signal saying that the test is done.\n \tdefer func() {\n+\t\t// Consider any uncaught panic a failure.\n+\t\tif err := recover(); err != nil {\n+\t\t\tt.failed = true\n+\t\t\tt.Log(err)\n+\t\t\tt.stack()\n+\t\t}\n+\n \t\tt.duration = time.Now().Sub(t.start)\n \t\tt.signal <- t\n \t}()"}, {"sha": "ea7c40081115b3f58be753d00e1d8b7624f2e31a", "filename": "libgo/go/text/tabwriter/tabwriter.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Ftext%2Ftabwriter%2Ftabwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Ftext%2Ftabwriter%2Ftabwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftabwriter%2Ftabwriter.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -52,7 +52,7 @@ type cell struct {\n // this flag.\n //\n // If a Writer is configured to filter HTML, HTML tags and entities\n-// are simply passed through. The widths of tags and entities are\n+// are passed through. The widths of tags and entities are\n // assumed to be zero (tags) and one (entities) for formatting purposes.\n //\n // A segment of text may be escaped by bracketing it with Escape\n@@ -448,7 +448,7 @@ func handlePanic(err *error) {\n \n // Flush should be called after the last call to Write to ensure\n // that any data buffered in the Writer is written to output. Any\n-// incomplete escape sequence at the end is simply considered\n+// incomplete escape sequence at the end is considered\n // complete for formatting purposes.\n //\n func (b *Writer) Flush() (err error) {"}, {"sha": "29bf167e56b62039930cf275e4e807cda7da20da", "filename": "libgo/go/unicode/casetables.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Funicode%2Fcasetables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Funicode%2Fcasetables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Fcasetables.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -9,12 +9,12 @@\n \n package unicode\n \n-var TurkishCase = _TurkishCase\n+var TurkishCase SpecialCase = _TurkishCase\n var _TurkishCase = SpecialCase{\n \tCaseRange{0x0049, 0x0049, d{0, 0x131 - 0x49, 0}},\n \tCaseRange{0x0069, 0x0069, d{0x130 - 0x69, 0, 0x130 - 0x69}},\n \tCaseRange{0x0130, 0x0130, d{0, 0x69 - 0x130, 0}},\n \tCaseRange{0x0131, 0x0131, d{0x49 - 0x131, 0, 0x49 - 0x131}},\n }\n \n-var AzeriCase = _TurkishCase\n+var AzeriCase SpecialCase = _TurkishCase"}, {"sha": "978c48ae43ee9115e6932208cdbe895bf1a8da26", "filename": "libgo/go/unicode/tables.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Funicode%2Ftables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fgo%2Funicode%2Ftables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Ftables.go?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -2701,6 +2701,7 @@ var _Zs = &RangeTable{\n \t},\n }\n \n+// The following variables are of type *RangeTable:\n var (\n \tCc     = _Cc // Cc is the set of Unicode characters in category Cc.\n \tCf     = _Cf // Cf is the set of Unicode characters in category Cf.\n@@ -4053,6 +4054,7 @@ var _Yi = &RangeTable{\n \t},\n }\n \n+// The following variables are of type *RangeTable:\n var (\n \tArabic                 = _Arabic                 // Arabic is the set of Unicode characters in script Arabic.\n \tArmenian               = _Armenian               // Armenian is the set of Unicode characters in script Armenian.\n@@ -5114,6 +5116,7 @@ var _White_Space = &RangeTable{\n \t},\n }\n \n+// The following variables are of type *RangeTable:\n var (\n \tASCII_Hex_Digit                    = _ASCII_Hex_Digit                    // ASCII_Hex_Digit is the set of Unicode characters with property ASCII_Hex_Digit.\n \tBidi_Control                       = _Bidi_Control                       // Bidi_Control is the set of Unicode characters with property Bidi_Control."}, {"sha": "c1cf02c6debf973b65546d3d951af305547df144", "filename": "libgo/runtime/malloc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fruntime%2Fmalloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fruntime%2Fmalloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.h?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -235,7 +235,7 @@ struct MStats\n };\n \n extern MStats mstats\n-  __asm__ (\"libgo_runtime.runtime.MemStats\");\n+  __asm__ (\"libgo_runtime.runtime.VmemStats\");\n \n \n // Size classes.  Computed and initialized by InitSizes."}, {"sha": "bd634d533e9461680358a5f6b92ceef86b558c82", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -1061,11 +1061,11 @@ runtime_gc(int32 force)\n \t\truntime_gc(1);\n }\n \n-void runtime_UpdateMemStats(void)\n-  __asm__(\"libgo_runtime.runtime.UpdateMemStats\");\n+void runtime_ReadMemStats(MStats *)\n+  __asm__(\"libgo_runtime.runtime.ReadMemStats\");\n \n void\n-runtime_UpdateMemStats(void)\n+runtime_ReadMemStats(MStats *stats)\n {\n \tM *m;\n \n@@ -1078,6 +1078,7 @@ runtime_UpdateMemStats(void)\n \tm->gcing = 1;\n \truntime_stoptheworld();\n \tcachestats();\n+\t*stats = mstats;\n \tm->gcing = 0;\n \truntime_semrelease(&gcsema);\n \truntime_starttheworld(false);"}, {"sha": "42a5779bc992c1f564338a49a1002bb9371a5934", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -525,7 +525,7 @@ mcommoninit(M *m)\n \truntime_atomicstorep((void**)&runtime_allm, m);\n \n \tm->id = runtime_sched.mcount++;\n-\tm->fastrand = 0x49f6428aUL + m->id;\n+\tm->fastrand = 0x49f6428aUL + m->id + runtime_cputicks();\n \n \tif(m->mcache == nil)\n \t\tm->mcache = runtime_allocmcache();"}, {"sha": "7c8c436deebeae19fcb9124f4ea81320acb4efa1", "filename": "libgo/runtime/runtime.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fruntime%2Fruntime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fruntime%2Fruntime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.c?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -184,6 +184,19 @@ runtime_fastrand1(void)\n \treturn x;\n }\n \n+int64\n+runtime_cputicks(void)\n+{\n+#if defined(__386__) || defined(__x86_64__)\n+  uint32 low, high;\n+  asm(\"rdtsc\" : \"=a\" (low), \"=d\" (high));\n+  return (int64)(((uint64)high << 32) | (uint64)low);\n+#else\n+  // FIXME: implement for other processors.\n+  return 0;\n+#endif\n+}\n+\n struct funcline_go_return\n {\n   String retfile;"}, {"sha": "41b0ef5f00734c5abe5536a7a9a18b810a83f086", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94252f4bcc0a3f487b804ce535cb77b8bef4db83/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=94252f4bcc0a3f487b804ce535cb77b8bef4db83", "patch": "@@ -286,6 +286,7 @@ void\truntime_exitsyscall(void) __asm__(\"libgo_syscall.syscall.exitsyscall\");\n void\tsiginit(void);\n bool\t__go_sigsend(int32 sig);\n int64\truntime_nanotime(void);\n+int64\truntime_cputicks(void);\n \n void\truntime_stoptheworld(void);\n void\truntime_starttheworld(bool);"}]}