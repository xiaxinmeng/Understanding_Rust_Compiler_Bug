{"sha": "82ebe78b9e94cf6a7ba8a9b77f76eefab318fd49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJlYmU3OGI5ZTk0Y2Y2YTdiYThhOWI3N2Y3NmVlZmFiMzE4ZmQ0OQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-12-27T17:24:51Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-12-27T17:24:51Z"}, "message": "2003-12-27  Michael Koch  <konqueror@gmx.de>\n\n\t* gnu/java/net/protocol/http/Connection.java\n\t(connect): Call receiveReply().\n\t(receiveReply): Renamed from getHttpHeaders().\n\t(getOutputStream): Moved check on doOutput before check for connection\n\tstate.\n\nFrom-SVN: r75172", "tree": {"sha": "229ae20fc934b92566fd1b035f78d736cb4d53d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/229ae20fc934b92566fd1b035f78d736cb4d53d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82ebe78b9e94cf6a7ba8a9b77f76eefab318fd49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82ebe78b9e94cf6a7ba8a9b77f76eefab318fd49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82ebe78b9e94cf6a7ba8a9b77f76eefab318fd49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82ebe78b9e94cf6a7ba8a9b77f76eefab318fd49/comments", "author": null, "committer": null, "parents": [{"sha": "5bd1d00e5cfef62321cedf3e377806824145145d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bd1d00e5cfef62321cedf3e377806824145145d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bd1d00e5cfef62321cedf3e377806824145145d"}], "stats": {"total": 137, "additions": 77, "deletions": 60}, "files": [{"sha": "3714570ccad1a771287d31faa667674a99a13030", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82ebe78b9e94cf6a7ba8a9b77f76eefab318fd49/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82ebe78b9e94cf6a7ba8a9b77f76eefab318fd49/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=82ebe78b9e94cf6a7ba8a9b77f76eefab318fd49", "patch": "@@ -1,3 +1,11 @@\n+2003-12-27  Michael Koch  <konqueror@gmx.de>\n+\n+\t* gnu/java/net/protocol/http/Connection.java\n+\t(connect): Call receiveReply().\n+\t(receiveReply): Renamed from getHttpHeaders().\n+\t(getOutputStream): Moved check on doOutput before check for connection\n+\tstate.\n+\n 2003-12-27  Michael Koch  <konqueror@gmx.de>\n \n \t* javax/print/attribute/ResolutionSyntax.java,"}, {"sha": "632a20a81bcfb999d50aab891888304209226cfe", "filename": "libjava/gnu/java/net/protocol/http/Connection.java", "status": "modified", "additions": 69, "deletions": 60, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82ebe78b9e94cf6a7ba8a9b77f76eefab318fd49/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82ebe78b9e94cf6a7ba8a9b77f76eefab318fd49/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Fprotocol%2Fhttp%2FConnection.java?ref=82ebe78b9e94cf6a7ba8a9b77f76eefab318fd49", "patch": "@@ -172,7 +172,8 @@ public void connect() throws IOException\n     inputStream = new BufferedInputStream(socket.getInputStream());\n \n     sendRequest();\n-    getHttpHeaders();\n+    receiveReply();\n+\n     connected = true;\n   }\n \n@@ -225,6 +226,62 @@ void sendRequest() throws IOException\n     outputWriter.flush();\n   }\n \n+  /**\n+   * Read HTTP reply from inputStream.\n+   */\n+  private void receiveReply() throws IOException\n+  {\n+    int buflen = 100;\n+    byte[] buf = new byte[buflen];\n+    String line = \"\";\n+    boolean gotnl = false;\n+    byte[] ch = new byte[1];\n+    ch[0] = (byte) '\\n';\n+\n+    while (true)\n+      {\n+\t// Check for leftover byte from non-'\\n' after a '\\r'.\n+\tif (ch[0] != '\\n')\n+\t  line = line + '\\r' + new String(ch, 0, 1);\n+\n+\tint i;\n+\t// FIXME: This is rather inefficient.\n+\tfor (i = 0; i < buflen; i++)\n+\t  {\n+\t    buf[i] = (byte) inputStream.read();\n+\t    if (buf[i] == -1)\n+\t      throw new IOException(\"Malformed HTTP header\");\n+\t    if (buf[i] == '\\r')\n+\t      {\n+\t        inputStream.read(ch, 0, 1);\n+\t\tif (ch[0] == '\\n')\n+\t\t  gotnl = true;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\tline = line + new String(buf, 0, i);\n+\n+\t// A '\\r' '\\n' combo indicates the end of the header entry.\n+\t// If it wasn't found, cycle back through the loop and append\n+\t// to 'line' until one is found.\n+\tif (gotnl)\n+\t  {\n+\t    // A zero length entry signals the end of the headers.\n+\t    if (line.length() == 0)\n+\t      break;\n+\n+\t    // Store the header and reinitialize for next cycle.\n+\t    hdrVec.addElement(line);\n+\t    String key = getKey(line);\n+\t    if (key != null)\n+\t      hdrHash.put(key.toLowerCase(), getField(line));\n+\t    line = \"\";\n+\t    ch[0] = (byte) '\\n';\n+\t    gotnl = false;\n+\t  }\n+      }\n+  }\n+\n   /**\n    * Return a boolean indicating whether or not this connection is\n    * going through a proxy\n@@ -256,13 +313,21 @@ public InputStream getInputStream() throws IOException\n     return inputStream;\n   }\n \n+  /**\n+   * Returns on OutputStream for writing to this connection.\n+   *\n+   * @return An OutputStream for this connection.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   public OutputStream getOutputStream() throws IOException\n   {\n+    if (!doOutput)\n+      throw new ProtocolException\n+        (\"Want output stream while haven't setDoOutput(true)\");\n+    \n     if (!connected)\n       connect();\n-\n-    if (! doOutput)\n-      throw new ProtocolException(\"Can't open OutputStream if doOutput is false\");\n     \n     return socket.getOutputStream();\n   }\n@@ -389,60 +454,4 @@ private String getField(String str)\n     else\n       return str;\n   }\n-\n-  /**\n-   * Read HTTP reply from inputStream.\n-   */\n-  private void getHttpHeaders() throws IOException\n-  {\n-    int buflen = 100;\n-    byte[] buf = new byte[buflen];\n-    String line = \"\";\n-    boolean gotnl = false;\n-    byte[] ch = new byte[1];\n-    ch[0] = (byte) '\\n';\n-\n-    while (true)\n-      {\n-\t// Check for leftover byte from non-'\\n' after a '\\r'.\n-\tif (ch[0] != '\\n')\n-\t  line = line + '\\r' + new String(ch, 0, 1);\n-\n-\tint i;\n-\t// FIXME: This is rather inefficient.\n-\tfor (i = 0; i < buflen; i++)\n-\t  {\n-\t    buf[i] = (byte) inputStream.read();\n-\t    if (buf[i] == -1)\n-\t      throw new IOException(\"Malformed HTTP header\");\n-\t    if (buf[i] == '\\r')\n-\t      {\n-\t        inputStream.read(ch, 0, 1);\n-\t\tif (ch[0] == '\\n')\n-\t\t  gotnl = true;\n-\t\tbreak;\n-\t      }\n-\t  }\n-\tline = line + new String(buf, 0, i);\n-\n-\t// A '\\r' '\\n' combo indicates the end of the header entry.\n-\t// If it wasn't found, cycle back through the loop and append\n-\t// to 'line' until one is found.\n-\tif (gotnl)\n-\t  {\n-\t    // A zero length entry signals the end of the headers.\n-\t    if (line.length() == 0)\n-\t      break;\n-\n-\t    // Store the header and reinitialize for next cycle.\n-\t    hdrVec.addElement(line);\n-\t    String key = getKey(line);\n-\t    if (key != null)\n-\t      hdrHash.put(key.toLowerCase(), getField(line));\n-\t    line = \"\";\n-\t    ch[0] = (byte) '\\n';\n-\t    gotnl = false;\n-\t  }\n-      }\n-  }\n }"}]}