{"sha": "a21856f76bb601b3dd4f1a180ff07c5420075756", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTIxODU2Zjc2YmI2MDFiM2RkNGYxYTE4MGZmMDdjNTQyMDA3NTc1Ng==", "commit": {"author": {"name": "Stephen M. Webb", "email": "stephen.webb@bregmasoft.com", "date": "2007-03-12T21:57:51Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2007-03-12T21:57:51Z"}, "message": "regex: Add \"boilerplate\" implementations.\n\n2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n\n\t* include/tr1/regex: Add \"boilerplate\" implementations.\n\t* testsuite/tr1/7_regular_expressions/regex_traits/wchar_t/\n\ttranslate_nocase.cc: New.\n\t* testsuite/tr1/7_regular_expressions/regex_traits/wchar_t/\n\tctor.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/regex_traits/char/\n\ttranslate_nocase.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/regex_traits/char/\n\tctor.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/regex/cons/char/\n\tc_string_ecma.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/regex/cons/char/\n\tdefault.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/regex/cons/char/\n\tc_string_grep.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/regex/cons/char/\n\tc_string_extended.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/regex/cons/char/\n\tc_string_basic.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/regex/cons/char/\n\tc_string_awk.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/regex/cons/char/\n\tc_string_egrep.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/wchar_t/\n\trange.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/wchar_t/\n\tstring_op.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/wchar_t/\n\tstring.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/wchar_t/\n\tpstring.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/wchar_t/\n\tcstring_op.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/wchar_t/\n\tcstring.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/char/\n\trange.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/char/\n\tstring_op.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/char/\n\tstring.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/char/\n\tpstring.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/char/\n\tcstring_op.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/char/\n\tcstring.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/basic_regex/ctors/wchar_t/\n\trange.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/basic_regex/ctors/wchar_t/\n\tdefault.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/basic_regex/ctors/wchar_t/\n\tstring.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/basic_regex/ctors/wchar_t/\n\tpstring.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/basic_regex/ctors/wchar_t/\n\tcstring.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/basic_regex/ctors/char/\n\trange.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/basic_regex/ctors/char/\n\tdefault.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/basic_regex/ctors/char/\n\tstring.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/basic_regex/ctors/char/\n\tpstring.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/basic_regex/ctors/char/\n\tcstring.cc: Likewise.\n\t* testsuite/tr1/7_regular_expressions/match_results/ctors/char/\n\tdefault.cc: Likewise.\n\nFrom-SVN: r122867", "tree": {"sha": "eaa89ab318e50e578425a151d300e369b806401d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eaa89ab318e50e578425a151d300e369b806401d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a21856f76bb601b3dd4f1a180ff07c5420075756", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a21856f76bb601b3dd4f1a180ff07c5420075756", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a21856f76bb601b3dd4f1a180ff07c5420075756", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a21856f76bb601b3dd4f1a180ff07c5420075756/comments", "author": null, "committer": null, "parents": [{"sha": "fbb0d4f87836abb8c0fee3ac8308c80460ecef8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbb0d4f87836abb8c0fee3ac8308c80460ecef8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbb0d4f87836abb8c0fee3ac8308c80460ecef8c"}], "stats": {"total": 3929, "additions": 3926, "deletions": 3}, "files": [{"sha": "dbb4714dd501c22c708328059a772d7ad9bbefe9", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -1,3 +1,75 @@\n+2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+\n+\t* include/tr1/regex: Add \"boilerplate\" implementations.\n+\t* testsuite/tr1/7_regular_expressions/regex_traits/wchar_t/\n+\ttranslate_nocase.cc: New.\n+\t* testsuite/tr1/7_regular_expressions/regex_traits/wchar_t/\n+\tctor.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/regex_traits/char/\n+\ttranslate_nocase.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/regex_traits/char/\n+\tctor.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/regex/cons/char/\n+\tc_string_ecma.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/regex/cons/char/\n+\tdefault.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/regex/cons/char/\n+\tc_string_grep.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/regex/cons/char/\n+\tc_string_extended.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/regex/cons/char/\n+\tc_string_basic.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/regex/cons/char/\n+\tc_string_awk.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/regex/cons/char/\n+\tc_string_egrep.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/wchar_t/\n+\trange.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/wchar_t/\n+\tstring_op.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/wchar_t/\n+\tstring.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/wchar_t/\n+\tpstring.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/wchar_t/\n+\tcstring_op.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/wchar_t/\n+\tcstring.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/char/\n+\trange.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/char/\n+\tstring_op.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/char/\n+\tstring.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/char/\n+\tpstring.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/char/\n+\tcstring_op.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/basic_regex/assign/char/\n+\tcstring.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/basic_regex/ctors/wchar_t/\n+\trange.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/basic_regex/ctors/wchar_t/\n+\tdefault.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/basic_regex/ctors/wchar_t/\n+\tstring.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/basic_regex/ctors/wchar_t/\n+\tpstring.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/basic_regex/ctors/wchar_t/\n+\tcstring.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/basic_regex/ctors/char/\n+\trange.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/basic_regex/ctors/char/\n+\tdefault.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/basic_regex/ctors/char/\n+\tstring.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/basic_regex/ctors/char/\n+\tpstring.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/basic_regex/ctors/char/\n+\tcstring.cc: Likewise.\n+\t* testsuite/tr1/7_regular_expressions/match_results/ctors/char/\n+\tdefault.cc: Likewise.\n+\n 2007-03-12  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/bits/stl_algo.h (swap_ranges): Move..."}, {"sha": "3b8f03feb41e1e786b5ac8db074bfb2a1dcd9030", "filename": "libstdc++-v3/include/tr1/regex", "status": "modified", "additions": 2395, "deletions": 3, "changes": 2398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fregex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fregex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fregex?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -27,11 +27,2403 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-/** @file tr1/regex\n-*  This is a TR1 C++ Library header.\n-*/\n+/**\n+ * @file tr1/regex\n+ * @author Stephen M. Webb  <stephen.webb@bregmasoft.ca>\n+ * This is a TR1 C++ Library header. \n+ */\n \n #ifndef _TR1_REGEX\n #define _TR1_REGEX 1\n \n+#include <bits/c++config.h>\n+#include <algorithm>\n+#include <bitset>\n+#include <iterator>\n+#include <locale>\n+#include <stdexcept>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE(_GLIBCXX_TR1)\n+\n+/**\n+ * @addtogroup tr1_regex Regular Expressions\n+ * A facility for performing regular expression pattern matching.\n+ * @{\n+ */\n+\n+namespace regex_constants\n+{\n+  // [7.5.1] Bitmask Type syntax_option_type\n+  enum __syntax_option\n+    {\n+      _S_icase,\n+      _S_nosubs,\n+      _S_optimize,\n+      _S_collate,\n+      _S_ECMAScript,\n+      _S_basic,\n+      _S_extended,\n+      _S_awk,\n+      _S_grep,\n+      _S_egrep,\n+      _S_syntax_last\n+    };\n+\n+  /**\n+   * @brief This is a bitmask type indicating how to interpret the regex.\n+   *\n+   * The @c syntax_option_type is implementation defined but it is valid to\n+   * perform bitwise operations on these values and expect the right thing to\n+   * happen.\n+   *\n+   * A valid value of type syntax_option_type shall have exactly one of the\n+   * elements @c ECMAScript, @c basic, @c extended, @c awk, @c grep, @c egrep\n+   * set.\n+   */\n+  typedef unsigned int syntax_option_type;\n+\n+  /// Specifies that the matching of regular expressions against a character\n+  /// sequence shall be performed without regard to case.\n+  static const syntax_option_type icase      = 1 << _S_icase;\n+\n+  /// Specifies that when a regular expression is matched against a character\n+  /// container sequence, no sub-expression matches are to be stored in the\n+  /// supplied match_results structure.\n+  static const syntax_option_type nosubs     = 1 << _S_nosubs;\n+\n+  /// Specifies that the regular expression engine should pay more attention to\n+  /// the speed with which regular expressions are matched, and less to the\n+  /// speed with which regular expression objects are constructed. Otherwise\n+  /// it has no detectable effect on the program output.\n+  static const syntax_option_type optimize   = 1 << _S_optimize;\n+\n+  /// Specifies that character ranges of the form [a-b] should be locale\n+  /// sensitive.\n+  static const syntax_option_type collate    = 1 << _S_collate;\n+\n+  /// Specifies that the grammar recognized by the regular expression engine is\n+  /// that used by ECMAScript in ECMA-262 [Ecma International, ECMAScript\n+  /// Language Specification, Standard Ecma-262, third edition, 1999], as\n+  /// modified in tr1 section [7.13].  This grammar is similar to that defined\n+  /// in the PERL scripting language but extended with elements found in the\n+  /// POSIX regular expression grammar.\n+  static const syntax_option_type ECMAScript = 1 << _S_ECMAScript;\n+\n+  /// Specifies that the grammar recognized by the regular expression engine is\n+  /// that used by POSIX basic regular expressions in IEEE Std 1003.1-2001,\n+  /// Portable Operating System Interface (POSIX), Base Definitions and\n+  /// Headers, Section 9, Regular Expressions [IEEE, Information Technology --\n+  /// Portable Operating System Interface (POSIX), IEEE Standard 1003.1-2001].\n+  static const syntax_option_type basic      = 1 << _S_basic;\n+\n+  /// Specifies that the grammar recognized by the regular expression engine is\n+  /// that used by POSIX extended regular expressions in IEEE Std 1003.1-2001,\n+  /// Portable Operating System Interface (POSIX), Base Definitions and Headers,\n+  /// Section 9, Regular Expressions.\n+  static const syntax_option_type extended   = 1 << _S_extended;\n+\n+  /// Specifies that the grammar recognized by the regular expression engine is\n+  /// that used by POSIX utility awk in IEEE Std 1003.1-2001.  This option is\n+  /// identical to syntax_option_type extended, except that C-style escape\n+  /// sequences are supported.  These sequences are, explicitly, '\\\\', '\\a',\n+  /// '\\b', '\\f', '\\n', '\\r', '\\t' , '\\v', '\\\"', '\\\\', and '\\ddd' (where ddd is\n+  /// one, two, or three octal digits).  \n+  static const syntax_option_type awk        = 1 << _S_awk;\n+\n+  /// Specifies that the grammar recognized by the regular expression engine is\n+  /// that used by POSIX utility grep in IEEE Std 1003.1-2001.  This option is\n+  /// identical to syntax_option_type basic, except that newlines are treated\n+  /// as whitespace.\n+  static const syntax_option_type grep       = 1 << _S_grep;\n+\n+  /// Specifies that the grammar recognized by the regular expression engine is\n+  /// that used by POSIX utility grep when given the -E option in\n+  /// IEEE Std 1003.1-2001.  This option is identical to syntax_option_type \n+  /// extended, except that newlines are treated as whitespace.\n+  static const syntax_option_type egrep      = 1 << _S_egrep;\n+\n+\n+  // [7.5.2] Bitmask Type match_flag_type\n+  enum __match_flag\n+    {\n+      _S_not_bol,\n+      _S_not_eol,\n+      _S_not_bow,\n+      _S_not_eow,\n+      _S_any,\n+      _S_not_null,\n+      _S_continuous,\n+      _S_prev_avail,\n+      _S_sed,\n+      _S_no_copy,\n+      _S_first_only,\n+      _S_match_flag_last\n+    };\n+\n+  /**\n+   * @brief This is a bitmask type indicating regex matching rules.\n+   *\n+   * Matching a regular expression against a sequence of characters [first,\n+   * last) proceeds according to the rules of the grammar specified for the\n+   * regular expression object, modified according to the effects listed\n+   * below for any bitmask elements set.\n+   *\n+   * The @c match_flag_type is implementation defined but it is valid to\n+   * perform bitwise operations on these values and expect the right thing to\n+   * happen.\n+   */\n+  typedef std::bitset<_S_match_flag_last> match_flag_type;\n+\n+  static const match_flag_type match_default     = 0;\n+\n+  /// The first character in the sequence [first, last) is treated as though it\n+  /// is not at the beginning of a line, so the character \"^\" in the regular\n+  /// expression shall not match [first, first).\n+  static const match_flag_type match_not_bol     = 1 << _S_not_bol;\n+\n+  /// The last character in the sequence [first, last) is treated as though it\n+  /// is not at the end of a line, so the character \"$\" in the regular\n+  /// expression shall not match [last, last).\n+  static const match_flag_type match_not_eol     = 1 << _S_not_eol;\n+   \n+  /// The expression \"\\b\" is not matched against the sub-sequence\n+  /// [first,first).\n+  static const match_flag_type match_not_bow     = 1 << _S_not_bow;\n+   \n+  /// The expression \"\\b\" should not be matched against the sub-sequence\n+  /// [last,last).\n+  static const match_flag_type match_not_eow     = 1 << _S_not_eow;\n+   \n+  /// If more than one match is possible then any match is an acceptable\n+  /// result.\n+  static const match_flag_type match_any         = 1 << _S_any;\n+   \n+  /// The expression does not match an empty sequence.\n+  static const match_flag_type match_not_null    = 1 << _S_not_null;\n+   \n+  /// The expression only matchs a sub-sequence that begins at first .\n+  static const match_flag_type match_continuous  = 1 << _S_continuous;\n+   \n+  /// --first is a valid iterator position.  When this flag is set then the\n+  /// flags match_not_bol and match_not_bow are ignored by the regular\n+  /// expression algorithms 7.11 and iterators 7.12.\n+  static const match_flag_type match_prev_avail  = 1 << _S_prev_avail;\n+\n+  /// When a regular expression match is to be replaced by a new string, the\n+  /// new string is constructed using the rules used by the ECMAScript replace\n+  /// function in ECMA- 262 [Ecma International, ECMAScript Language\n+  /// Specification, Standard Ecma-262, third edition, 1999], part 15.5.4.11\n+  /// String.prototype.replace. In addition, during search and replace\n+  /// operations all non-overlapping occurrences of the regular expression\n+  /// are located and replaced, and sections of the input that did not match\n+  /// the expression are copied unchanged to the output string.\n+  ///\n+  /// Format strings (from ECMA-262 [15.5.4.11]):\n+  /// $$  $\n+  /// $&  The matched substring.\n+  /// $`  The portion of <em>string</em> that preceeds the matched substring.\n+  /// $'  The portion of <em>string</em> that follows the matched substring.\n+  /// $n  The nth capture, where n is in [1,9] and $n is not followed by a\n+  ///     decimal digit.  If n <= m and the nth capture is undefined, use the\n+  ///     empty string\n+  ///     instead. If n > m, the result is implementation-defined.\n+  /// $nn The nnth capture, where nn is a two-digit decimal number on [01, 99].\n+  ///     If nn <= m and the nth capture is undefined, use the empty string\n+  ///     instead. If nn > m, the result is implementation-defined.\n+  ///\n+  static const match_flag_type format_default    = 0;\n+\n+  /// When a regular expression match is to be replaced by a new string, the\n+  /// new string is constructed using the rules used by the POSIX sed utility\n+  /// in IEEE Std 1003.1- 2001 [IEEE, Information Technology -- Portable\n+  /// Operating System Interface (POSIX), IEEE Standard 1003.1-2001].\n+  static const match_flag_type format_sed        = 1 << _S_sed;\n+\n+  /// During a search and replace operation, sections of the character\n+  /// container sequence being searched that do not match the regular\n+  /// expression shall not be copied to the output string.\n+  static const match_flag_type format_no_copy    = 1 << _S_no_copy;\n+\n+  /// When specified during a search and replace operation, only the first\n+  /// occurrence of the regular expression shall be replaced.\n+  static const match_flag_type format_first_only = 1 << _S_first_only;\n+\n+\n+  // [7.5.3] implementation-defined error type\n+  enum error_type\n+    {\n+      _S_error_collate,\n+      _S_error_ctype,\n+      _S_error_escape,\n+      _S_error_backref,\n+      _S_error_brack,\n+      _S_error_paren,\n+      _S_error_brace,\n+      _S_error_badbrace,\n+      _S_error_range,\n+      _S_error_space,\n+      _S_error_badrepeat,\n+      _S_error_complexity,\n+      _S_error_stack,\n+      _S_error_last\n+    };\n+\n+  /// The expression contained an invalid collating element name.\n+  static const error_type error_collate(_S_error_collate);\n+\n+  /// The expression contained an invalid character class name.\n+  static const error_type error_ctype(_S_error_ctype);\n+\n+  /// The expression contained an invalid escaped character, or a trailing\n+  /// escape.\n+  static const error_type error_escape(_S_error_escape);\n+\n+  /// The expression contained an invalid back reference.\n+  static const error_type error_backref(_S_error_backref);\n+\n+  /// The expression contained mismatched [ and ].\n+  static const error_type error_brack(_S_error_brack);\n+\n+  /// The expression contained mismatched ( and ).\n+  static const error_type error_paren(_S_error_paren);\n+\n+  /// The expression contained mismatched { and }\n+  static const error_type error_brace(_S_error_brace);\n+\n+  /// The expression contained an invalid range in a {} expression.\n+  static const error_type error_badbrace(_S_error_badbrace);\n+\n+  /// The expression contained an invalid character range,\n+  /// such as [b-a] in most encodings.\n+  static const error_type error_range(_S_error_range);\n+\n+  /// There was insufficient memory to convert the expression into a\n+  /// finite state machine.\n+  static const error_type error_space(_S_error_space);\n+\n+  /// One of *?+{ was not preceded by a valid regular expression.\n+  static const error_type error_badrepeat(_S_error_badrepeat);\n+\n+  /// The complexity of an attempted match against a regular expression\n+  /// exceeded a pre-set level.\n+  static const error_type error_complexity(_S_error_complexity);\n+\n+  /// There was insufficient memory to determine whether the\n+  /// regular expression could match the specified character sequence.\n+  static const error_type error_stack(_S_error_stack);\n+}\n+\n+\n+  // [7.8] Class regex_error\n+  /**\n+   * Defines the type of objects thrown as exceptions to report errors from the\n+   * regular expression library.\n+   */\n+  class regex_error\n+  : public std::runtime_error\n+  {\n+  public:\n+    /**\n+     * @brief constructs a regex_error object.\n+     *\n+     * @param ecode the regex error code.\n+     */\n+    explicit\n+    regex_error(regex_constants::error_type __ecode)\n+    : std::runtime_error(\"regex_error\"), _M_code(__ecode)\n+    { }\n+\n+    /**\n+     * @brief gets the regex error code.\n+     *\n+     * @returns the regex error code.\n+     */\n+    regex_constants::error_type\n+    code() const\n+    { return _M_code; }\n+\n+  protected:\n+    regex_constants::error_type _M_code;\n+  };\n+\n+\n+  // [7.7] Class regex_traits\n+  /**\n+   * A regular expression traits class that satisfies the requirements of tr1\n+   * section [7.2].\n+   *\n+   * The class %regex is parameterized around a set of related types and\n+   * functions used to complete the definition of its semantics.  This class\n+   * satisfies the requirements of such a traits class.\n+   */\n+  template<typename _Ch_type>\n+    struct regex_traits\n+    {\n+    public:\n+      typedef _Ch_type                     char_type;\n+      typedef std::basic_string<char_type> string_type;\n+      typedef std::locale                  locale_type;\n+      typedef std::ctype_base::mask        char_class_type;\n+\n+    public:\n+      /**\n+       * @brief Constructs a default traits object.\n+       */\n+      regex_traits()\n+      { }\n+      \n+      /**\n+       * @brief Gives the length of a C-style string starting at @p __p.\n+       *\n+       * @param __p a pointer to the start of a character sequence.\n+       *\n+       * @returns the number of characters between @p *__p and the first\n+       * default-initialized value of type @p char_type.  In other words, uses\n+       * the C-string algorithm for determiining the length of a sequence of\n+       * characters.\n+       */\n+      static std::size_t\n+      length(const char_type* __p)\n+      { return string_type::traits_type::length(__p); }\n+\n+      /**\n+       * @brief Performs the identity translation.\n+       *\n+       * @param c A character to the locale-specific character set.\n+       *\n+       * @returns c.\n+       */\n+      char_type\n+      translate(char_type __c) const\n+      { return __c; }\n+      \n+      /**\n+       * @brief Translates a character into a case-insensitive equivalent.\n+       *\n+       * @param c A character to the locale-specific character set.\n+       *\n+       * @returns the locale-specific lower-case equivalent of c.\n+       * @throws std::bad_cast if the imbued locale does not support the ctype\n+       *         facet.\n+       */\n+      char_type\n+      translate_nocase(char_type __c) const\n+      {\n+\tusing std::ctype;\n+\tusing std::use_facet;\n+\treturn use_facet<ctype<char_type> >(_M_locale).tolower(__c);\n+      }\n+      \n+      /**\n+       * @brief Gets a sort key for a character sequence.\n+       *\n+       * @param first beginning of the character sequence.\n+       * @param last  one-past-the-end of the character sequence.\n+       *\n+       * Returns a sort key for the character sequence designated by the\n+       * iterator range [F1, F2) such that if the character sequence [G1, G2)\n+       * sorts before the character sequence [H1, H2) then\n+       * v.transform(G1, G2) < v.transform(H1, H2).\n+       *\n+       * What this really does is provide a more efficient way to compare a\n+       * string to multiple other strings in locales with fancy collation\n+       * rules and equivalence classes.\n+       *\n+       * @returns a locale-specific sort key equivalent to the input range.\n+       *\n+       * @throws std::bad_cast if the current locale does not have a collate\n+       *         facet.\n+       */\n+      template<typename _Fwd_iter>\n+        string_type\n+        transform(_Fwd_iter __first, _Fwd_iter __last) const\n+        {\n+\t  using std::collate;\n+\t  using std::use_facet;\n+\t  const collate<_Ch_type>& __c(use_facet<\n+\t\t\t\t       collate<_Ch_type> >(_M_locale));\n+\t  string_type __s(__first, __last);\n+\t  return __c.transform(__s.data(), __s.data() + __s.size());\n+\t}\n+\n+      /**\n+       * @brief Dunno.\n+       *\n+       * @param first beginning of the character sequence.\n+       * @param last  one-past-the-end of the character sequence.\n+       *\n+       * Effects: if typeid(use_facet<collate<_Ch_type> >) ==\n+       * typeid(collate_byname<_Ch_type>) and the form of the sort key\n+       * returned by collate_byname<_Ch_type>::transform(first, last) is known\n+       * and can be converted into a primary sort key then returns that key,\n+       * otherwise returns an empty string. WTF??\n+       *\n+       * @todo Implement this function.\n+       */\n+      template<typename _Fwd_iter>\n+        string_type\n+        transform_primary(_Fwd_iter __first, _Fwd_iter __last) const\n+        { return string_type(); }\n+\n+      /**\n+       * @breief Gets a collation element by name.\n+       *\n+       * @param first beginning of the collation element name.\n+       * @param last  one-past-the-end of the collation element name.\n+       * \n+       * @returns a sequence of one or more characters that represents the\n+       * collating element consisting of the character sequence designated by\n+       * the iterator range [first, last). Returns an empty string if the\n+       * character sequence is not a valid collating element.\n+       *\n+       * @todo Implement this function.\n+       */\n+      template<typename _Fwd_iter>\n+        string_type\n+        lookup_collatename(_Fwd_iter __first, _Fwd_iter __last) const\n+        { return string_type(); }\n+\n+      /**\n+       * @brief Maps one or mire characters to a named character\n+       *        classification.\n+       *\n+       * @param first beginning of the character sequence.\n+       * @param last  one-past-the-end of the character sequence.\n+       *\n+       * @returns an unspecified value that represents the character\n+       * classification named by the character sequence designated by the\n+       * iterator range [first, last). The value returned shall be independent\n+       * of the case of the characters in the character sequence. If the name\n+       * is not recognized then returns a value that compares equal to 0.\n+       *\n+       * At least the following names (or their wide-character equivalent) are\n+       * supported.\n+       * - d\n+       * - w\n+       * - s\n+       * - alnum\n+       * - alpha\n+       * - blank\n+       * - cntrl\n+       * - digit\n+       * - graph\n+       * - lower\n+       * - print\n+       * - punct\n+       * - space\n+       * - upper\n+       * - xdigit\n+       *\n+       * @todo Implement this function.\n+       */\n+      template<typename _Fwd_iter>\n+        char_class_type\n+        lookup_classname(_Fwd_iter __first, _Fwd_iter __last) const\n+        { return 0; }\n+\n+      /**\n+       * @brief Determines if @p c is a member of an identified class.\n+       *\n+       * @param c a character.\n+       * @param f a class type (as returned from lookup_classname).\n+       *\n+       * @returns true if the character @p c is a member of the classification\n+       * represented by @p f, false otherwise.\n+       *\n+       * @throws std::bad_cast if the current locale does not have a ctype\n+       *         facet.\n+       */\n+      bool\n+      isctype(_Ch_type __c, char_class_type __f) const\n+      {\n+\tusing std::ctype;\n+\tusing std::use_facet;\n+\tconst ctype<_Ch_type>& __ctype(use_facet<\n+\t\t\t\t       ctype<_Ch_type> >(_M_locale));\n+\t\n+\tif (__ctype.is(__c, __f))\n+\t  return true;\n+\t\n+\t// special case of underscore in [[:w:]]\n+\tif (__c == __ctype.widen('_'))\n+\t  {\n+\t    const char* const __wb[] = \"w\";\n+\t    char_class_type __wt = this->lookup_classname(__wb,\n+\t\t\t\t\t\t\t  __wb + sizeof(__wb));\n+\t    if (__f | __wt)\n+\t      return true;\n+\t  }\n+      \n+\t// special case of [[:space:]] in [[:blank:]]\n+\tif (__c == __ctype.isspace(__c))\n+\t  {\n+\t    const char* const __bb[] = \"blank\";\n+\t    char_class_type __bt = this->lookup_classname(__bb,\n+\t\t\t\t\t\t\t  __bb + sizeof(__bb));\n+\t    if (__f | __bt)\n+\t      return true;\n+\t  }\n+\t\n+\treturn false;\n+      }\n+\n+      /**\n+       * @brief Converts a digit to an int.\n+       *\n+       * @param ch    a character representing a digit.\n+       * @param radix the radix if the numeric conversion (limited to 8, 10,\n+       *              or 16).\n+       * \n+       * @returns the value represented by the digit ch in base radix if the\n+       * character ch is a valid digit in base radix; otherwise returns -1.\n+       *\n+       * @todo Implement this function.\n+       */\n+      int\n+      value(_Ch_type __ch, int __radix) const;\n+      \n+      /**\n+       * @brief Imbues the regex_traits object with a copy of a new locale.\n+       *\n+       * @param loc A locale.\n+       *\n+       * @returns a copy of the previous locale in use by the regex_traits\n+       *          object.\n+       *\n+       * @note Calling imbue with a different locale than the one currently in\n+       *       use invalidates all cached data held by *this.\n+       */\n+      locale_type\n+      imbue(locale_type __loc)\n+      {\n+\tstd::swap(_M_locale, __loc);\n+\treturn __loc;\n+      }\n+      \n+      /**\n+       * @brief Gets a copy of the current locale in use by the regex_traits\n+       * object.\n+       */\n+      locale_type\n+      getloc() const\n+      { return _M_locale; }\n+      \n+    protected:\n+      locale_type _M_locale;\n+    };\n+\n+\n+  // [7.8] Class basic_regex\n+  /**\n+   * Objects of specializations of this class represent regular expressions\n+   * constructed from sequences of character type @p _Ch_type.\n+   *\n+   * Storage for the regular expression is allocated and deallocated as\n+   * necessary by the member functions of this class.\n+   */\n+  template<typename _Ch_type, typename _Rx_traits = regex_traits<_Ch_type> >\n+    class basic_regex\n+    {\n+    public:\n+      // types:\n+      typedef _Ch_type                              value_type;\n+      typedef regex_constants::syntax_option_type flag_type;\n+      typedef typename _Rx_traits::locale_type  locale_type;\n+      typedef typename _Rx_traits::string_type  string_type;\n+\n+      // [7.8.1] constants\n+      static const regex_constants::syntax_option_type icase\n+        = regex_constants::icase;\n+      static const regex_constants::syntax_option_type nosubs\n+        = regex_constants::nosubs;\n+      static const regex_constants::syntax_option_type optimize\n+        = regex_constants::optimize;\n+      static const regex_constants::syntax_option_type collate\n+        = regex_constants::collate;\n+      static const regex_constants::syntax_option_type ECMAScript\n+        = regex_constants::ECMAScript;\n+      static const regex_constants::syntax_option_type basic\n+        = regex_constants::basic;\n+      static const regex_constants::syntax_option_type extended\n+        = regex_constants::extended;\n+      static const regex_constants::syntax_option_type awk\n+        = regex_constants::awk;\n+      static const regex_constants::syntax_option_type grep\n+        = regex_constants::grep;\n+      static const regex_constants::syntax_option_type egrep\n+        = regex_constants::egrep;\n+\n+      // [7.8.2] construct/copy/destroy\n+      /**\n+       * Constructs a basic regular expression that does not match any\n+       * character sequence.\n+       */\n+      basic_regex()\n+      : _M_flags(regex_constants::ECMAScript), _M_pattern(), _M_mark_count(0)\n+      { _M_compile(); }\n+\n+      /**\n+       * @brief Constructs a basic regular expression from the sequence\n+       * [p, p + char_traits<_Ch_type>::length(p)) interpreted according to the\n+       * flags in @p f.\n+       *\n+       * @param p A pointer to the start of a C-style null-terminated string\n+       *          containing a regular expression.\n+       * @param f Flags indicating the syntax rules and options.\n+       *\n+       * @throws regex_error if @p p is not a valid regular expression.\n+       */\n+      explicit\n+      basic_regex(const _Ch_type* __p,\n+\t\t  flag_type __f = regex_constants::ECMAScript)\n+      : _M_flags(__f), _M_pattern(__p), _M_mark_count(0)\n+      { _M_compile(); }\n+\n+      /**\n+       * @brief Constructs a basic regular expression from the sequence\n+       * [p, p + len) interpreted according to the flags in @p f.\n+       *\n+       * @param p   A pointer to the start of a string containing a regular\n+       *            expression.\n+       * @param len The length of the string containing the regular expression.\n+       * @param f   Flags indicating the syntax rules and options.\n+       *\n+       * @throws regex_error if @p p is not a valid regular expression.\n+       */\n+      basic_regex(const _Ch_type* __p, std::size_t __len, flag_type __f)\n+      : _M_flags(__f) , _M_pattern(__p, __len), _M_mark_count(0)\n+      { _M_compile(); }\n+\n+      /**\n+       * @brief Copy-contructs a basic regular expression.\n+       *\n+       * @param rhs A @p regex object.\n+     */\n+      basic_regex(const basic_regex& __rhs)\n+      : _M_flags(__rhs._M_flags), _M_pattern(__rhs._M_pattern),\n+\t_M_mark_count(__rhs._M_mark_count)\n+      { _M_compile(); }\n+\n+      /**\n+       * @brief Constructs a basic regular expression from the string\n+       * @p interpreted according to the flags in @p f.\n+       *\n+       * @param p A string containing a regular expression.\n+       * @param f Flags indicating the syntax rules and options.\n+       *\n+       * @throws regex_error if @p p is not a valid regular expression.\n+       */\n+      template<typename _Ch_traits, typename _Ch_alloc>\n+        explicit\n+        basic_regex(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,\n+\t\t    flag_type __f = regex_constants::ECMAScript)\n+\t: _M_flags(__f), _M_pattern(__s), _M_mark_count(0)\n+        { _M_compile(); }\n+\n+      /**\n+       * @brief Constructs a basic regular expression from the range\n+       * [first, last) interpreted according to the flags in @p f.\n+       *\n+       * @param first The start of arange containing a valid regular\n+       *              expression.\n+       * @param last  The end of a range containing a valid regular\n+       *              expression.\n+       * @param f     The format flags of the regular expression.\n+       *\n+       * @throws regex_error if @p p is not a valid regular expression.\n+       */\n+      template<typename _InputIterator>\n+        basic_regex(_InputIterator __first, _InputIterator __last, \n+\t\t    flag_type __f = regex_constants::ECMAScript)\n+\t: _M_flags(__f), _M_pattern(__first, __last), _M_mark_count(0)\n+        { _M_compile(); }\n+\n+      /**\n+       * @brief Destroys a basic regular expression.\n+       */\n+      ~basic_regex()\n+      { }\n+      \n+      /**\n+       * @brief Assigns one regular expression to another.\n+       */\n+      basic_regex&\n+      operator=(const basic_regex& __rhs)\n+      { return this->assign(__rhs); }\n+\n+      /**\n+       * @brief Replaces a regular expression with a new one constructed from\n+       * a C-style null-terminated string.\n+       *\n+       * @param A pointer to the start of a null-terminated C-style string\n+       *        containing a regular expression.\n+       */\n+      basic_regex&\n+      operator=(const _Ch_type* __p)\n+      { return this->assign(__p, flags()); }\n+      \n+      /**\n+       * @brief Replaces a regular expression with a new one constructed from\n+       * a string.\n+       *\n+       * @param A pointer to a string containing a regular expression.\n+       */\n+      template<typename _Ch_typeraits, typename _Allocator>\n+        basic_regex&\n+        operator=(const basic_string<_Ch_type, _Ch_typeraits, _Allocator>& __s)\n+        { return this->assign(__s, flags()); }\n+\n+      // [7.8.3] assign\n+      /**\n+       * @brief the real assignment operator.\n+       *\n+       * @param that Another regular expression object.\n+       */\n+      basic_regex&\n+      assign(const basic_regex& __that)\n+      {\n+\tbasic_regex __tmp(__that);\n+\tthis->swap(__tmp);\n+\treturn *this;\n+      }\n+      \n+      /**\n+       * @brief Assigns a new regular expression to a regex object from a\n+       * C-style null-terminated string containing a regular expression\n+       * pattern.\n+       *\n+       * @param p     A pointer to a C-style null-terminated string containing\n+       *              a regular expression pattern.\n+       * @param flags Syntax option flags.\n+       *\n+       * @throws regex_error if p does not contain a valid regular expression\n+       * pattern interpreted according to @p flags.  If regex_error is thrown,\n+       * *this remains unchanged.\n+       */\n+      basic_regex&\n+      assign(const _Ch_type* __p,\n+\t     flag_type __flags = regex_constants::ECMAScript)\n+      { return this->assign(string_type(__p), __flags); }\n+\n+      /**\n+       * @brief Assigns a new regular expression to a regex object from a\n+       * C-style string containing a regular expression pattern.\n+       *\n+       * @param p     A pointer to a C-style string containing a\n+       *              regular expression pattern.\n+       * @param len   The length of the regular expression pattern string.\n+       * @param flags Syntax option flags.\n+       *\n+       * @throws regex_error if p does not contain a valid regular expression\n+       * pattern interpreted according to @p flags.  If regex_error is thrown,\n+       * *this remains unchanged.\n+       */\n+      basic_regex&\n+      assign(const _Ch_type* __p, std::size_t __len, flag_type __flags)\n+      { return this->assign(string_type(__p, __len), __flags); }\n+\n+      /**\n+       * @brief Assigns a new regular expression to a regex object from a \n+       * string containing a regular expression pattern.\n+       *\n+       * @param s     A string containing a regular expression pattern.\n+       * @param flags Syntax option flags.\n+       *\n+       * @throws regex_error if p does not contain a valid regular expression\n+       * pattern interpreted according to @p flags.  If regex_error is thrown,\n+       * *this remains unchanged.\n+       */\n+      template<typename _Ch_typeraits, typename _Allocator>\n+        basic_regex&\n+        assign(const basic_string<_Ch_type, _Ch_typeraits, _Allocator>& __s,\n+\t       flag_type __f = regex_constants::ECMAScript)\n+        { \n+\t  basic_regex __tmp(__s, __f);\n+\t  this->swap(__tmp);\n+\t  return *this;\n+\t}\n+\n+      /**\n+       * @brief Assigns a new regular expression to a regex object.\n+       *\n+       * @param first The start of a range containing a valid regular\n+       *              expression.\n+       * @param last  The end of a range containing a valid regular\n+       *              expression.\n+       * @param flags Syntax option flags.\n+       *\n+       * @throws regex_error if p does not contain a valid regular expression\n+       * pattern interpreted according to @p flags.  If regex_error is thrown,\n+       * *this remains unchanged.\n+       */\n+      template<typename _InputIterator>\n+        basic_regex&\n+        assign(_InputIterator __first, _InputIterator __last,\n+\t       flag_type __flags = regex_constants::ECMAScript)\n+        { return this->assign(string_type(__first, __last), __flags); }\n+\n+      // [7.8.4] const operations\n+      /**\n+       * @brief Gets the number of marked subexpressions within the regular\n+       * expresison.\n+       */\n+      unsigned int\n+      mark_count() const\n+      { return _M_mark_count; }\n+      \n+      /**\n+       * @brief Gets the flags used to construct the regular expression\n+       * or in the last call to assign().\n+       */\n+      flag_type\n+      flags() const\n+      { return _M_flags; }\n+      \n+      // [7.8.5] locale\n+      /**\n+       * @brief Imbues the regular expression object with the given locale.\n+       *\n+       * @param loc A locale.\n+       */\n+      locale_type\n+      imbue(locale_type __loc)\n+      { return _M_traits.imbue(__loc); }\n+      \n+      /**\n+       * @brief Gets the locale currently imbued in the regular expression\n+       *        object.\n+       */\n+      locale_type\n+      getloc() const\n+      { return _M_traits.getloc(); }\n+      \n+      // [7.8.6] swap\n+      /**\n+       * @brief Swaps the contents of two regular expression obects.\n+       *\n+       * @param rhs Another regular expression object.\n+       */\n+      void\n+      swap(basic_regex& __rhs)\n+      {\n+\tstd::swap(_M_flags,      __rhs._M_flags);\n+\tstd::swap(_M_pattern,    __rhs._M_pattern);\n+\tstd::swap(_M_mark_count, __rhs._M_mark_count);\n+\tstd::swap(_M_traits,     __rhs._M_traits);\n+      }\n+      \n+    private:\n+      /**\n+       * @brief Compiles a regular expression pattern into a NFA.\n+       * @todo Implement this function.\n+       */\n+      void _M_compile()\n+      { }\n+\n+    protected:\n+      flag_type    _M_flags;\n+      string_type  _M_pattern;\n+      unsigned int _M_mark_count;\n+      _Rx_traits   _M_traits;\n+    };\n+  \n+  typedef basic_regex<char>    regex;\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  typedef basic_regex<wchar_t> wregex;\n+#endif\n+\n+\n+  // [7.8.6] basic_regex swap\n+  /**\n+   * @brief Swaps the contents of two regular expression objects.\n+   * @param lhs First regular expression.\n+   * @param rhs Second regular expression.\n+   */\n+  template<typename _Ch_type, typename _Rx_traits>\n+    inline void\n+    swap(basic_regex<_Ch_type, _Rx_traits>& __lhs,\n+\t basic_regex<_Ch_type, _Rx_traits>& __rhs)\n+    { return __lhs.swap(__rhs); }\n+\n+\n+  // [7.9] Class template sub_match\n+  /**\n+   * A sequence of characters matched by a particular marked sub-expression.\n+   *\n+   * An object of this class is essentially a pair of iterators marking a\n+   * matched subexpression within a regular expression pattern match. Such\n+   * objects can be converted to and compared with std::basic_string objects\n+   * of a similar base character type as the pattern matched by the regular\n+   * expression.\n+   *\n+   * The iterators that make up the pair are the usual half-open interval\n+   * referencing the actual original pattern matched.\n+   */\n+  template<typename _BiIter>\n+    class sub_match : public std::pair<_BiIter, _BiIter>\n+    {\n+    public:\n+      typedef typename iterator_traits<_BiIter>::value_type      value_type;\n+      typedef typename iterator_traits<_BiIter>::difference_type\n+                                                            difference_type;\n+      typedef _BiIter                                              iterator;\n+\n+    public:\n+      bool matched;\n+      \n+      /**\n+       * Gets the length of the matching sequence.\n+       */\n+      difference_type\n+      length() const\n+      { return this->matched ? std::distance(this->first, this->second) : 0; }\n+\n+      /**\n+       * @brief Gets the matching sequence as a string.\n+       *\n+       * @returns the matching sequence as a string.\n+       *\n+       * This is the implicit conversion operator.  It is identical to the\n+       * str() member function except that it will want to pop up in\n+       * unexpected places and cause a great deal of confusion and cursing\n+       * from the unwary.\n+       */\n+      operator basic_string<value_type>() const\n+      {\n+\treturn this->matched\n+\t  ? std::basic_string<value_type>(this->first, this->second)\n+\t  : std::basic_string<value_type>();\n+      }\n+      \n+      /**\n+       * @brief Gets the matching sequence as a string.\n+       *\n+       * @returns the matching sequence as a string.\n+       */\n+      basic_string<value_type>\n+      str() const\n+      {\n+\treturn this->matched\n+\t  ? std::basic_string<value_type>(this->first, this->second)\n+\t  : std::basic_string<value_type>();\n+      }\n+      \n+      /**\n+       * @brief Compares this and another matched sequence.\n+       *\n+       * @param s Another matched sequence to compare to this one.\n+       *\n+       * @retval <0 this matched sequence will collate before @p s.\n+       * @retval =0 this matched sequence is equivalent to @p s.\n+       * @retval <0 this matched sequence will collate after @p s.\n+       */\n+      int\n+      compare(const sub_match& __s) const\n+      { return this->str().compare(__s.str()); }\n+\n+      /**\n+       * @brief Compares this sub_match to a string.\n+       *\n+       * @param s A string to compare to this sub_match.\n+       *\n+       * @retval <0 this matched sequence will collate before @p s.\n+       * @retval =0 this matched sequence is equivalent to @p s.\n+       * @retval <0 this matched sequence will collate after @p s.\n+       */\n+      int\n+      compare(const basic_string<value_type>& __s) const\n+      { return this->str().compare(__s); }\n+      \n+      /**\n+       * @brief Compares this sub_match to a C-style string.\n+       *\n+       * @param s A C-style string to compare to this sub_match.\n+       *\n+       * @retval <0 this matched sequence will collate before @p s.\n+       * @retval =0 this matched sequence is equivalent to @p s.\n+       * @retval <0 this matched sequence will collate after @p s.\n+       */\n+      int\n+      compare(const value_type* __s) const\n+      { return this->str().compare(__s); }\n+    };\n+  \n+  \n+  typedef sub_match<const char*>             csub_match;\n+  typedef sub_match<string::const_iterator>  ssub_match;\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  typedef sub_match<const wchar_t*>          wcsub_match;\n+  typedef sub_match<wstring::const_iterator> wssub_match;\n #endif\n+\n+  // [7.9.2] sub_match non-member operators\n+  \n+  /**\n+   * @brief Tests the equivalence of two regular expression submatches.\n+   * @param lhs First regular expression submatch.\n+   * @param rhs Second regular expression submatch.\n+   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _BiIter>\n+    inline bool\n+    operator==(const sub_match<_BiIter>& __lhs,\n+\t       const sub_match<_BiIter>& __rhs)\n+    { return __lhs.compare(__rhs) == 0; }\n+\n+  /**\n+   * @brief Tests the inequivalence of two regular expression submatches.\n+   * @param lhs First regular expression submatch.\n+   * @param rhs Second regular expression submatch.\n+   * @returns true if @a lhs  is not equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _BiIter>\n+    inline bool\n+    operator!=(const sub_match<_BiIter>& __lhs,\n+\t       const sub_match<_BiIter>& __rhs)\n+    { return __lhs.compare(__rhs) != 0; }\n+\n+  /**\n+   * @brief Tests the ordering of two regular expression submatches.\n+   * @param lhs First regular expression submatch.\n+   * @param rhs Second regular expression submatch.\n+   * @returns true if @a lhs precedes @a rhs, false otherwise.\n+   */\n+  template<typename _BiIter>\n+    inline bool\n+    operator<(const sub_match<_BiIter>& __lhs,\n+\t      const sub_match<_BiIter>& __rhs)\n+    { return __lhs.compare(__rhs) < 0; }\n+\n+  /**\n+   * @brief Tests the ordering of two regular expression submatches.\n+   * @param lhs First regular expression submatch.\n+   * @param rhs Second regular expression submatch.\n+   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n+   */\n+  template<typename _BiIter>\n+    inline bool\n+    operator<=(const sub_match<_BiIter>& __lhs,\n+\t       const sub_match<_BiIter>& __rhs)\n+    { return __lhs.compare(__rhs) <= 0; }\n+\n+  /**\n+   * @brief Tests the ordering of two regular expression submatches.\n+   * @param lhs First regular expression submatch.\n+   * @param rhs Second regular expression submatch.\n+   * @returns true if @a lhs does not preceed @a rhs, false otherwise.\n+   */\n+  template<typename _BiIter>\n+    inline bool\n+    operator>=(const sub_match<_BiIter>& __lhs,\n+\t       const sub_match<_BiIter>& __rhs)\n+    { return __lhs.compare(__rhs) >= 0; }\n+\n+  /**\n+   * @brief Tests the ordering of two regular expression submatches.\n+   * @param lhs First regular expression submatch.\n+   * @param rhs Second regular expression submatch.\n+   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n+   */\n+  template<typename _BiIter>\n+    inline bool\n+    operator>(const sub_match<_BiIter>& __lhs,\n+\t      const sub_match<_BiIter>& __rhs)\n+    { return __lhs.compare(__rhs) > 0; }\n+\n+  /**\n+   * @brief Tests the equivalence of a string and a regular expression\n+   *        submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator==(const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs == __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the inequivalence of a string and a regular expression\n+   *        submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs  is not equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator!=(const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs != __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs precedes @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator<(const basic_string<\n+\t      typename iterator_traits<_Bi_iter>::value_type,\n+\t      _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n+     { return __lhs < __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator>(const basic_string<\n+\t      typename iterator_traits<_Bi_iter>::value_type, \n+\t      _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs > __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs does not preceed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator>=(const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs >= __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator<=(const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __lhs, const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs <= __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the equivalence of a regular expression submatch and a\n+   *        string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs is equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator==(const sub_match<_Bi_iter>& __lhs,\n+\t       const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __rhs)\n+    { return __lhs.str() == __rhs; }\n+\n+  /**\n+   * @brief Tests the inequivalence of a regular expression submatch and a\n+   *        string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_traits, typename _Ch_alloc>\n+    inline bool\n+    operator!=(const sub_match<_Bi_iter>& __lhs,\n+\t       const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __rhs)\n+    { return __lhs.str() != __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs precedes @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n+    inline bool\n+    operator<(const sub_match<_Bi_iter>& __lhs,\n+\t      const basic_string<\n+\t      typename iterator_traits<_Bi_iter>::value_type,\n+\t      _Ch_traits, _Ch_alloc>& __rhs)\n+    { return __lhs.str() < __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n+    inline bool\n+    operator>(const sub_match<_Bi_iter>& __lhs,\n+\t      const basic_string<\n+\t      typename iterator_traits<_Bi_iter>::value_type,\n+\t      _Ch_traits, _Ch_alloc>& __rhs)\n+    { return __lhs.str() > __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs does not preceed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n+    inline bool\n+    operator>=(const sub_match<_Bi_iter>& __lhs,\n+\t       const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __rhs)\n+    { return __lhs.str() >= __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter, class _Ch_traits, class _Ch_alloc>\n+    inline bool\n+    operator<=(const sub_match<_Bi_iter>& __lhs,\n+\t       const basic_string<\n+\t       typename iterator_traits<_Bi_iter>::value_type,\n+\t       _Ch_traits, _Ch_alloc>& __rhs)\n+    { return __lhs.str() <= __rhs; }\n+\n+  /**\n+   * @brief Tests the equivalence of a C string and a regular expression\n+   *        submatch.\n+   * @param lhs A C string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator==(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs == __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the inequivalence of an iterator value and a regular\n+   *        expression submatch.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator!=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs != __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs precedes @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n+\t      const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs < __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n+\t      const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs > __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs does not preceed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs >= __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<=(typename iterator_traits<_Bi_iter>::value_type const* __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs <= __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the equivalence of a regular expression submatch and a\n+   *        string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A pointer to a string?\n+   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator==(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n+    { return __lhs.str() == __rhs; }\n+\n+  /**\n+   * @brief Tests the inequivalence of a regular expression submatch and a\n+   *        string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A pointer to a string.\n+   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator!=(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n+    { return __lhs.str() != __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs precedes @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<(const sub_match<_Bi_iter>& __lhs,\n+\t      typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n+    { return __lhs.str() < __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>(const sub_match<_Bi_iter>& __lhs,\n+\t      typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n+    { return __lhs.str() > __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs does not precede @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>=(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n+    { return __lhs.str() >= __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A string.\n+   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<=(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const* __rhs)\n+    { return __lhs.str() <= __rhs; }\n+\n+  /**\n+   * @brief Tests the equivalence of a string and a regular expression\n+   *        submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs is equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator==(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs == __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the inequivalence of a string and a regular expression\n+   *        submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator!=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs != __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs precedes @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n+\t      const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs < __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n+\t      const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs > __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs does not preceed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs >= __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the ordering of a string and a regular expression submatch.\n+   * @param lhs A string.\n+   * @param rhs A regular expression submatch.\n+   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<=(typename iterator_traits<_Bi_iter>::value_type const& __lhs,\n+\t       const sub_match<_Bi_iter>& __rhs)\n+    { return __lhs <= __rhs.str(); }\n+\n+  /**\n+   * @brief Tests the equivalence of a regular expression submatch and a\n+   *        string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A const string reference.\n+   * @returns true if @a lhs  is equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator==(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n+    { return __lhs.str() == __rhs; }\n+\n+  /**\n+   * @brief Tests the inequivalence of a regular expression submatch and a\n+   *        string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A const string reference.\n+   * @returns true if @a lhs is not equivalent to @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator!=(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n+    { return __lhs.str() != __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A const string reference.\n+   * @returns true if @a lhs preceeds @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<(const sub_match<_Bi_iter>& __lhs,\n+\t      typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n+    { return __lhs.str() < __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A const string reference.\n+   * @returns true if @a lhs succeeds @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>(const sub_match<_Bi_iter>& __lhs,\n+\t      typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n+    { return __lhs.str() > __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A const string reference.\n+   * @returns true if @a lhs does not preceed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator>=(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n+    { return __lhs.str() >= __rhs; }\n+\n+  /**\n+   * @brief Tests the ordering of a regular expression submatch and a string.\n+   * @param lhs A regular expression submatch.\n+   * @param rhs A const string reference.\n+   * @returns true if @a lhs does not succeed @a rhs, false otherwise.\n+   */\n+  template<typename _Bi_iter>\n+    inline bool\n+    operator<=(const sub_match<_Bi_iter>& __lhs,\n+\t       typename iterator_traits<_Bi_iter>::value_type const& __rhs)\n+    { return __lhs.str() <= __rhs; }\n+\n+  /**\n+   * @brief Inserts a matched string into an output stream.\n+   *\n+   * @param os The output stream.\n+   * @param m  A submatch string.\n+   *\n+   * @returns the output stream with the submatch string inserted.\n+   */\n+  template<typename _Ch_type, typename _Ch_traits, typename _Bi_iter>\n+    inline\n+    basic_ostream<_Ch_type, _Ch_traits>&\n+    operator<<(basic_ostream<_Ch_type, _Ch_traits>& __os,\n+\t       const sub_match<_Bi_iter>& __m)\n+    { return __os << __m.str(); }\n+\n+  // [7.10] Class template match_results\n+  /**\n+   * A collection of character sequences representing the result of a regular\n+   * expression match.  Storage for the collection is allocated and freed as\n+   * necessary by the member functions of class template match_results.\n+   *\n+   * This class satisfies the Sequence requirements, with the exception that\n+   * only the operations defined for a const-qualified Sequence are supported.\n+   *\n+   * The sub_match object stored at index 0 represents sub-expression 0, i.e.\n+   * the whole match. In this case the sub_match member matched is always true.\n+   * The sub_match object stored at index n denotes what matched the marked\n+   * sub-expression n within the matched expression. If the sub-expression n\n+   * participated in a regular expression match then the sub_match member\n+   * matched evaluates to true, and members first and second denote the range\n+   * of characters [first, second) which formed that match. Otherwise matched\n+   * is false, and members first and second point to the end of the sequence\n+   * that was searched.\n+   */\n+  template<typename _Bi_iter,\n+\t   typename _Allocator = allocator<sub_match<_Bi_iter> > >\n+    class match_results\n+    : private std::vector<std::_GLIBCXX_TR1::sub_match<_Bi_iter>, _Allocator>\n+    {\n+    private:\n+      typedef std::vector<std::_GLIBCXX_TR1::sub_match<_Bi_iter>, _Allocator>\n+                                                              _Base_type;\n+\n+    public:\n+      typedef sub_match<_Bi_iter>                             value_type;\n+      typedef typename _Allocator::const_reference            const_reference;\n+      typedef const_reference                                 reference;\n+      typedef typename _Base_type::const_iterator             const_iterator;\n+      typedef const_iterator                                  iterator;\n+      typedef typename iterator_traits<_Bi_iter>::difference_type\n+                                                              difference_type;\n+      typedef typename _Allocator::size_type                  size_type;\n+      typedef _Allocator                                      allocator_type;\n+      typedef typename iterator_traits<_Bi_iter>::value_type  char_type;\n+      typedef basic_string<char_type>                         string_type;\n+  \n+    public:\n+      // [7.10.1] construct/copy/destroy\n+      /**\n+       * @brief Constructs a default match_results container.\n+       */\n+      explicit\n+      match_results(const _Allocator& __a = _Allocator())\n+      : _Base_type(__a), _M_matched(false)\n+      { }\n+\n+      /**\n+       * @brief Copy constructs a match_result.\n+       */\n+      match_results(const match_results& __rhs)\n+      : _Base_type(__rhs), _M_matched(__rhs._M_matched),\n+\t_M_prefix(__rhs._M_prefix), _M_suffix(__rhs._M_suffix)\n+      { }\n+\n+      /**\n+       * @brief Assigns rhs to *this.\n+       */\n+      match_results&\n+      operator=(const match_results& __rhs)\n+      {\n+\tmatch_results __tmp(__rhs);\n+\tthis->swap(__tmp);\n+      }\n+\n+      /**\n+       * @todo Implement this function.\n+       */\n+      ~match_results()\n+      { }\n+      \n+      // [7.10.2] size\n+      /**\n+       * @todo Document this function.\n+       */\n+      size_type\n+      size() const\n+      { return _M_matched ? _Base_type::size() + 1 : 0; }\n+      \n+      /**\n+       * @todo Implement this function.\n+       */\n+      //size_type\n+      //max_size() const;\n+      using _Base_type::max_size;\n+\n+      /**\n+       * @todo Document this function.\n+       */\n+      bool\n+      empty() const\n+      { return size() == 0; }\n+      \n+      // [7.10.3] element access\n+      /**\n+       * @brief Gets the length of the indicated submatch.\n+       * @param sub indicates the submatch.\n+       */\n+      difference_type\n+      length(size_type __sub = 0) const\n+      { return _M_matched ? this->str(__sub).length() : 0; }\n+\n+      /**\n+       * @todo Document this function.\n+       */\n+      difference_type\n+      position(size_type __sub = 0) const\n+      {\n+\treturn _M_matched ? std::distance(this->prefix().first,\n+\t\t\t\t\t  (*this)[__sub].first) : 0;\n+      }\n+\n+      /**\n+       * @todo Document this function.\n+       */\n+      string_type\n+      str(size_type __sub = 0) const\n+      { return _M_matched ? (*this)[__sub].str() : string_type(); }\n+      \n+      /**\n+       * @todo Document this function.\n+       */\n+      const_reference\n+      operator[](size_type __n) const\n+      { return _Base_type::operator[](__n); }\n+\n+      /**\n+       * @todo Document this function.\n+       */\n+      const_reference\n+      prefix() const\n+      { return _M_prefix; }\n+\n+      /**\n+       * @todo Document this function.\n+       */\n+      const_reference\n+      suffix() const\n+      { return _M_suffix; }\n+\n+      /**\n+       * @todo Document this function.\n+       */\n+      const_iterator\n+      begin() const\n+      { return _Base_type::begin(); }\n+      \n+      /**\n+       * @todo Document this function.\n+       */\n+      const_iterator\n+      end() const\n+      { return _Base_type::end(); }\n+      \n+      // [7.10.4] format\n+      /**\n+       * @todo Implement this function.\n+       */\n+      template<typename _Out_iter>\n+        _Out_iter\n+        format(_Out_iter __out, const string_type& __fmt,\n+\t       regex_constants::match_flag_type __flags\n+\t       = regex_constants::format_default) const\n+        { return __out; }\n+\n+      /**\n+       * @todo Implement this function.\n+       */\n+      string_type\n+      format(const string_type& __fmt,\n+\t     regex_constants::match_flag_type __flags\n+\t     = regex_constants::format_default) const;\n+\n+      // [7.10.5] allocator\n+      /**\n+       * @todo Document this function.\n+       */\n+      //allocator_type\n+      //get_allocator() const;\n+      using _Base_type::get_allocator;\n+      \n+      // [7.10.6] swap\n+      /**\n+       * @todo Document this function.\n+       */\n+      void\n+      swap(match_results& __that)\n+      {\n+\t_Base_type::swap(__that);\n+\tstd::swap(_M_matched, __that._M_matched);\n+\tstd::swap(_M_prefix,  __that._M_prefix);\n+\tstd::swap(_M_suffix,  __that._M_suffix);\n+      }\n+      \n+    private:\n+      bool       _M_matched;\n+      value_type _M_prefix;\n+      value_type _M_suffix;\n+    };\n+  \n+  typedef match_results<const char*>             cmatch;\n+  typedef match_results<string::const_iterator>  smatch;\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  typedef match_results<const wchar_t*>          wcmatch;\n+  typedef match_results<wstring::const_iterator> wsmatch;\n+#endif\n+\n+  // match_results comparisons\n+  /**\n+   * @todo Implement this function.\n+   */\n+  template<typename _Bi_iter, typename _Allocator>\n+    inline bool\n+    operator==(const match_results<_Bi_iter, _Allocator>& __m1,\n+\t       const match_results<_Bi_iter, _Allocator>& __m2);\n+\n+  /**\n+   * @todo Implement this function.\n+   */\n+  template<typename _Bi_iter, class _Allocator>\n+    inline bool\n+    operator!=(const match_results<_Bi_iter, _Allocator>& __m1,\n+\t       const match_results<_Bi_iter, _Allocator>& __m2);\n+\n+  // [7.10.6] match_results swap\n+  /**\n+   * @brief Swaps two match results.\n+   * @param lhs A match result.\n+   * @param rhs A match result.\n+   *\n+   * The contents of the two match_results objects are swapped.\n+   */\n+  template<typename _Bi_iter, typename _Allocator>\n+    inline void\n+    swap(match_results<_Bi_iter, _Allocator>& __lhs,\n+\t match_results<_Bi_iter, _Allocator>& __rhs)\n+    { return __lhs.swap(__rhs); }\n+\n+  // [7.11.2] Function template regex_match\n+  /**\n+   * @brief Determines if there is a match between the regular expression @p e\n+   * and all of the character sequence [first, last).\n+   *\n+   * @param first Beginning of the character sequence to match.\n+   * @param last  One-past-the-end of the character sequence to match.\n+   * @param m     The match results.\n+   * @param re    The regular expression.\n+   * @param flags Controls how the regular expression is matched.\n+   *\n+   * @retval true  A match exists.\n+   * @retval false Otherwise.\n+   *\n+   * @todo Implement this function.\n+   */\n+  template<typename _Bi_iter, typename _Allocator,\n+\t   typename _Ch_type, typename _Rx_traits>\n+    bool\n+    regex_match(_Bi_iter __first, _Bi_iter __last,\n+\t\tmatch_results<_Bi_iter, _Allocator>& __m,\n+\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\tregex_constants::match_flag_type __flags\n+\t\t= regex_constants::match_default)\n+    { return false; }\n+\n+  /**\n+   * @brief Indicates if there is a match between the regular expression @p e\n+   * and all of the character sequence [first, last).\n+   *\n+   * @param first Beginning of the character sequence to match.\n+   * @param last  One-past-the-end of the character sequence to match.\n+   * @param re    The regular expression.\n+   * @param flags Controls how the regular expression is matched.\n+   *\n+   * @retval true  A match exists.\n+   * @retval false Otherwise.\n+   */\n+  template<typename _Bi_iter, typename _Ch_type, typename _Rx_traits>\n+    bool\n+    regex_match(_Bi_iter __first, _Bi_iter __last,\n+\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\tregex_constants::match_flag_type __flags\n+\t\t= regex_constants::match_default)\n+    { \n+      match_results<_Bi_iter> __what;\n+      return regex_match(__first, __last, __what, __re, __flags);\n+    }\n+\n+  /**\n+   * @brief Determines if there is a match between the regular expression @p e\n+   * and a C-style null-terminated string.\n+   *\n+   * @param s  The C-style null-terminated string to match.\n+   * @param m  The match results.\n+   * @param re The regular expression.\n+   * @param f  Controls how the regular expression is matched.\n+   *\n+   * @retval true  A match exists.\n+   * @retval false Otherwise.\n+   */\n+  template<typename _Ch_type, typename _Allocator, typename _Rx_traits>\n+    inline bool\n+    regex_match(const _Ch_type* __s,\n+\t\tmatch_results<const _Ch_type*, _Allocator>& __m,\n+\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\tregex_constants::match_flag_type __f\n+\t\t= regex_constants::match_default)\n+    { return regex_match(__s, __s + _Rx_traits::length(__s), __m, __re, __f); }\n+\n+  /**\n+   * @brief Determines if there is a match between the regular expression @p e\n+   * and a string.\n+   *\n+   * @param s     The string to match.\n+   * @param m     The match results.\n+   * @param re    The regular expression.\n+   * @param flags Controls how the regular expression is matched.\n+   *\n+   * @retval true  A match exists.\n+   * @retval false Otherwise.\n+   */\n+  template<typename _Ch_traits, typename _Ch_alloc,\n+\t   typename _Allocator, typename _Ch_type, typename _Rx_traits>\n+    inline bool\n+    regex_match(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,\n+\t\tmatch_results<typename basic_string<_Ch_type, \n+\t\t_Ch_traits, _Ch_alloc>::const_iterator, _Allocator>& __m,\n+\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\tregex_constants::match_flag_type __flags\n+\t\t= regex_constants::match_default)\n+    { return regex_match(__s.begin(), __s.end(), __m, __re, __flags); }\n+\n+  /**\n+   * @brief Indicates if there is a match between the regular expression @p e\n+   * and a C-style null-terminated string.\n+   *\n+   * @param s  The C-style null-terminated string to match.\n+   * @param re The regular expression.\n+   * @param f  Controls how the regular expression is matched.\n+   *\n+   * @retval true  A match exists.\n+   * @retval false Otherwise.\n+   */\n+  template<typename _Ch_type, class _Rx_traits>\n+    inline bool\n+    regex_match(const _Ch_type* __s,\n+\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\tregex_constants::match_flag_type __f\n+\t\t= regex_constants::match_default)\n+    { return regex_match(__s, __s + _Rx_traits::length(__s), __re, __f); }\n+\n+  /**\n+   * @brief Indicates if there is a match between the regular expression @p e\n+   * and a string.\n+   *\n+   * @param s     [IN] The string to match.\n+   * @param re    [IN] The regular expression.\n+   * @param flags [IN] Controls how the regular expression is matched.\n+   *\n+   * @retval true  A match exists.\n+   * @retval false Otherwise.\n+   */\n+  template<typename _Ch_traits, typename _Str_allocator,\n+\t   typename _Ch_type, typename _Rx_traits>\n+    inline bool\n+    regex_match(const basic_string<_Ch_type, _Ch_traits, _Str_allocator>& __s,\n+\t\tconst basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\tregex_constants::match_flag_type __flags\n+\t\t= regex_constants::match_default)\n+    { return regex_match(__s.begin(), __s.end(), __re, __flags); }\n+\n+  // [7.11.3] Function template regex_search\n+  /**\n+   * Searches for a regular expression within a range.\n+   * @param first [IN]  The start of the string to search.\n+   * @param last  [IN]  One-past-the-end of the string to search.\n+   * @param m     [OUT] The match results.\n+   * @param re    [IN]  The regular expression to search for.\n+   * @param flags [IN]  Search policy flags.\n+   * @retval true  A match was found within the string.\n+   * @retval false No match was found within the string, the content of %m is\n+   *               undefined.\n+   * @todo Implement this function.\n+   */\n+  template<typename _Bi_iter, typename _Allocator,\n+\t   typename _Ch_type, typename _Rx_traits>\n+    inline bool\n+    regex_search(_Bi_iter __first, _Bi_iter __last,\n+\t\t match_results<_Bi_iter, _Allocator>& __m,\n+\t\t const basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\t regex_constants::match_flag_type __flags\n+\t\t = regex_constants::match_default)\n+    { return false; }\n+\n+  /**\n+   * Searches for a regular expression within a range.\n+   * @param first [IN]  The start of the string to search.\n+   * @param last  [IN]  One-past-the-end of the string to search.\n+   * @param re    [IN]  The regular expression to search for.\n+   * @param flags [IN]  Search policy flags.\n+   * @retval true  A match was found within the string.\n+   * @retval false No match was found within the string.\n+   * @todo Document me.\n+   */\n+  template<typename _Bi_iter, typename _Ch_type, typename _Rx_traits>\n+    inline bool\n+    regex_search(_Bi_iter __first, _Bi_iter __last,\n+\t\t const basic_regex<_Ch_type, _Rx_traits>& __re,\n+\t\t regex_constants::match_flag_type __flags\n+\t\t = regex_constants::match_default)\n+    {\n+      match_results<_Bi_iter> __what;\n+      return regex_search(__first, __last, __what, __re, __flags);\n+    }\n+\n+  /**\n+   * @brief Searches for a regular expression within a C-string.\n+   * @param s [IN]  A C-string to search for the regex.\n+   * @param m [OUT] The set of regex mnatches.\n+   * @param e [IN]  The regex to search for in @p s.\n+   * @param f [IN]  The search flags.\n+   * @retval true  A match was found within the string.\n+   * @retval false No match was found within the string, the content of %m is\n+   *               undefined.\n+   * @todo Document me.\n+   */\n+  template<typename _Ch_type, class _Allocator, class _Rx_traits>\n+    inline bool\n+    regex_search(const _Ch_type* __s,\n+\t\t match_results<const _Ch_type*, _Allocator>& __m,\n+\t\t const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t regex_constants::match_flag_type __f\n+\t\t = regex_constants::match_default)\n+    { return regex_search(__s, __s + _Rx_traits::length(__s), __m, __e, __f); }\n+\n+  /**\n+   * @brief Searches for a regular expression within a C-string.\n+   * @param s [IN]  The C-string to search.\n+   * @param e [IN]  The regular expressioon to search for.\n+   * @param f [IN]  Search policy flags.\n+   * @retval true  A match was found within the string.\n+   * @retval false No match was found within the string.\n+   * @todo Document me.\n+   */\n+  template<typename _Ch_type, typename _Rx_traits>\n+    inline bool\n+    regex_search(const _Ch_type* __s,\n+\t\t const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t regex_constants::match_flag_type __f\n+\t\t = regex_constants::match_default)\n+    { return regex_search(__s, __s + _Rx_traits::length(__s), __e, __f); }\n+\n+  /**\n+   * @brief Searches for a regular expression within a string.\n+   * @param s     [IN]  The string to search.\n+   * @param e     [IN]  The regular expressioon to search for.\n+   * @param flags [IN]  Search policy flags.\n+   * @retval true  A match was found within the string.\n+   * @retval false No match was found within the string.\n+   * @todo Document me.\n+   */\n+  template<typename _Ch_traits, typename _String_allocator,\n+\t   typename _Ch_type, typename _Rx_traits>\n+    inline bool\n+    regex_search(const basic_string<_Ch_type, _Ch_traits,\n+\t\t _String_allocator>& __s,\n+\t\t const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t regex_constants::match_flag_type __flags\n+\t\t = regex_constants::match_default)\n+    { return regex_search(__s.begin(), __s.end(), __e, __flags); }\n+\n+  /**\n+   * @brief Searches for a regular expression within a string.\n+   * @param s [IN]  A C++ string to search for the regex.\n+   * @param m [OUT] The set of regex mnatches.\n+   * @param e [IN]  The regex to search for in @p s.\n+   * @param f [IN]  The search flags.\n+   * @retval true  A match was found within the string.\n+   * @retval false No match was found within the string, the content of %m is\n+   *               undefined.\n+   */\n+  template<typename _Ch_traits, typename _Ch_alloc,\n+\t   typename _Allocator, typename _Ch_type,\n+\t   typename _Rx_traits>\n+    inline bool\n+    regex_search(const basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,\n+\t\t match_results<typename basic_string<_Ch_type,\n+\t\t _Ch_traits, _Ch_alloc>::const_iterator, _Allocator>& __m,\n+\t\t const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t regex_constants::match_flag_type __f\n+\t\t = regex_constants::match_default)\n+    { return regex_search(__s.begin(), __s.end(), __m, __e, __f); }\n+\n+  // [7.11.4] Function template regex_replace\n+  /**\n+   * @todo Implement this function.\n+   * @todo Document this function.\n+   */\n+  template<typename _Out_iter, typename _Bi_iter,\n+\t   typename _Rx_traits, typename _Ch_type>\n+    inline _Out_iter\n+    regex_replace(_Out_iter __out, _Bi_iter __first, _Bi_iter __last,\n+\t\t  const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t  const basic_string<_Ch_type>& __fmt,\n+\t\t  regex_constants::match_flag_type __flags\n+\t\t  = regex_constants::match_default)\n+    { return __out; }\n+\n+  /**\n+   * @todo Document me.\n+   */\n+  template<typename _Rx_traits, typename _Ch_type>\n+    inline basic_string<_Ch_type>\n+    regex_replace(const basic_string<_Ch_type>& __s,\n+\t\t  const basic_regex<_Ch_type, _Rx_traits>& __e,\n+\t\t  const basic_string<_Ch_type>& __fmt,\n+\t\t  regex_constants::match_flag_type __flags\n+\t\t  = regex_constants::match_default)\n+    {\n+      std::string __result;\n+      regex_replace(std::back_inserter(__result),\n+\t\t    __s.begin(), __s.end(), __e, __fmt, __flags);\n+      return __result;\n+    }\n+\n+  // [7.12.1] Class template regex_iterator\n+  /**\n+   * An iterator adaptor that will provide repeated calls of regex_search over \n+   * a range until no more matches remain.\n+   */\n+  template<typename _Bi_iter,\n+\t   typename _Ch_type = typename iterator_traits<_Bi_iter>::value_type,\n+\t   typename _Rx_traits = regex_traits<_Ch_type> >\n+    class regex_iterator\n+    {\n+    public:\n+      typedef basic_regex<_Ch_type, _Rx_traits>  regex_type;\n+      typedef match_results<_Bi_iter>            value_type;\n+      typedef std::ptrdiff_t                     difference_type;\n+      typedef const value_type*                  pointer;\n+      typedef const value_type&                  reference;\n+      typedef std::forward_iterator_tag          iterator_category;\n+\n+    public:\n+      /**\n+       * @brief Provides a singular iterator, useful for indicating\n+       * one-past-the-end of a range.\n+       * @todo Implement this function.\n+       * @todo Document this function.\n+       */\n+      regex_iterator();\n+      \n+      /**\n+       * Constructs a %regex_iterator...\n+       * @param a  [IN] The start of a text range to search.\n+       * @param b  [IN] One-past-the-end of the text range to search.\n+       * @param re [IN] The regular expression to match.\n+       * @param m  [IN] Policy flags for match rules.\n+       * @todo Implement this function.\n+       * @todo Document this function.\n+       */\n+      regex_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type& __re,\n+\t\t     regex_constants::match_flag_type __m\n+\t\t     = regex_constants::match_default);\n+\n+      /**\n+       * Copy constructs a %regex_iterator.\n+       * @todo Implement this function.\n+       * @todo Document this function.\n+       */\n+      regex_iterator(const regex_iterator& __rhs);\n+      \n+      /**\n+       * @todo Implement this function.\n+       * @todo Document this function.\n+       */\n+      regex_iterator&\n+      operator=(const regex_iterator& __rhs);\n+      \n+      /**\n+       * @todo Implement this function.\n+       * @todo Document this function.\n+       */\n+      bool\n+      operator==(const regex_iterator& __rhs);\n+      \n+      /**\n+       * @todo Implement this function.\n+       * @todo Document this function.\n+       */\n+      bool\n+      operator!=(const regex_iterator& __rhs);\n+      \n+      /**\n+       * @todo Implement this function.\n+       * @todo Document this function.\n+       */\n+      const value_type&\n+      operator*();\n+      \n+      /**\n+       * @todo Implement this function.\n+       * @todo Document this function.\n+       */\n+      const value_type*\n+      operator->();\n+      \n+      /**\n+       * @todo Implement this function.\n+       * @todo Document this function.\n+       */\n+      regex_iterator&\n+      operator++();\n+      \n+      /**\n+       * @todo Implement this function.\n+       * @todo Document this function.\n+       */\n+      regex_iterator\n+      operator++(int);\n+      \n+    private:\n+      // these members are shown for exposition only:\n+      _Bi_iter                         begin;\n+      _Bi_iter                         end;\n+      const regex_type*                pregex;\n+      regex_constants::match_flag_type flags;\n+      match_results<_Bi_iter>          match;\n+    };\n+  \n+  typedef regex_iterator<const char*>             cregex_iterator;\n+  typedef regex_iterator<string::const_iterator>  sregex_iterator;\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  typedef regex_iterator<const wchar_t*>          wcregex_iterator;\n+  typedef regex_iterator<wstring::const_iterator> wsregex_iterator;\n+#endif\n+\n+  // [7.12.2] Class template regex_token_iterator\n+  /**\n+   * Iterates over submatches in a range (or \"splits\" a text string).\n+   *\n+   * The purpose of this iterator is to enumerate all, or all specified,\n+   * matches of a regular expression within a text range.  The dereferenced\n+   * value of an iterator of this class is a std::tr1::sub_match object.\n+   */\n+  template<typename _Bi_iter,\n+\t   typename _Ch_type = typename iterator_traits<_Bi_iter>::value_type,\n+\t   typename _Rx_traits = regex_traits<_Ch_type> >\n+    class regex_token_iterator\n+    {\n+    public:\n+      typedef basic_regex<_Ch_type, _Rx_traits> regex_type;\n+      typedef sub_match<_Bi_iter>               value_type;\n+      typedef std::ptrdiff_t                    difference_type;\n+      typedef const value_type*                 pointer;\n+      typedef const value_type&                 reference;\n+      typedef std::forward_iterator_tag         iterator_category;\n+      \n+    public:\n+      /**\n+       * @brief Default constructs a %regex_token_iterator.\n+       * @todo Implement this function.\n+       * \n+       * A default-constructed %regex_token_iterator is a singular iterator\n+       * that will compare equal to the one-past-the-end value for any\n+       * iterator of the same type.\n+       */\n+      regex_token_iterator();\n+      \n+      /**\n+       * Constrcts a %regex_token_iterator...\n+       * @param a          [IN] The start of the text to search.\n+       * @param b          [IN] One-past-the-eend of the text to search.\n+       * @param re         [IN] The regular expression to search for.\n+       * @param submatch   [IN] Which submatch to return.  There are some\n+       *                        special values for thsi parameter:\n+       *                        - -1 each enumerated subexpression does NOT\n+       *                          match the regular expression (aka field\n+       *                          splitting)\n+       *                        - 0 the entire string matching the\n+       *                          subexpression is returned for each match\n+       *                          within the text.\n+       *                        - >0 enumerates only the indicated\n+       *                          subexpression from a match within the text.\n+       * @param m          [IN] Policy flags for match rules.\n+       *\n+       * @todo Implement this function.\n+       * @todo Document this function.\n+       */\n+      regex_token_iterator(_Bi_iter __a, _Bi_iter __b, const regex_type& __re,\n+\t\t\t   int __submatch = 0,\n+\t\t\t   regex_constants::match_flag_type __m\n+\t\t\t   = regex_constants::match_default);\n+\n+      /**\n+       * Constrcts a %regex_token_iterator...\n+       * @param a          [IN] The start of the text to search.\n+       * @param b          [IN] One-past-the-eend of the text to search.\n+       * @param re         [IN] The regular expression to search for.\n+       * @param submatches [IN] A list of subexpressions to return for each\n+       *                        regular expression match within the text.\n+       * @param m          [IN] Policy flags for match rules.\n+       *\n+       * @todo Implement this function.\n+       * @todo Document this function.\n+       */\n+      regex_token_iterator(_Bi_iter __a, _Bi_iter __b,\n+\t\t\t   const regex_type& __re,\n+\t\t\t   const std::vector<int>& __submatches,\n+\t\t\t   regex_constants::match_flag_type __m\n+\t\t\t     = regex_constants::match_default);\n+\n+      /**\n+       * Constrcts a %regex_token_iterator...\n+       * @param a          [IN] The start of the text to search.\n+       * @param b          [IN] One-past-the-eend of the text to search.\n+       * @param re         [IN] The regular expression to search for.\n+       * @param submatches [IN] A list of subexpressions to return for each\n+       *                        regular expression match within the text.\n+       * @param m          [IN] Policy flags for match rules.\n+       \n+       * @todo Implement this function.\n+       * @todo Document this function.\n+       */\n+      template<std::size_t _Nm>\n+        regex_token_iterator(_Bi_iter __a, _Bi_iter __b,\n+\t\t\t     const regex_type& __re,\n+\t\t\t     const int (&__submatches)[_Nm],\n+\t\t\t     regex_constants::match_flag_type __m\n+\t\t\t     = regex_constants::match_default);\n+\n+      /**\n+       * @brief Copy constructs a %regex_token_iterator.\n+       * @param rhs [IN] A %regex_token_iterator to copy.\n+       * @todo Implement this function.\n+       */\n+      regex_token_iterator(const regex_token_iterator& __rhs);\n+      \n+      /**\n+       * @brief Assigns a %regex_token_iterator to another.\n+       * @param rhs [IN] A %regex_token_iterator to copy.\n+       * @todo Implement this function.\n+       */\n+      regex_token_iterator&\n+      operator=(const regex_token_iterator& __rhs);\n+      \n+      /**\n+       * @brief Compares a %regex_token_iterator to another for equality.\n+       * @todo Implement this function.\n+       */\n+      bool\n+      operator==(const regex_token_iterator& __rhs);\n+      \n+      /**\n+       * @brief Compares a %regex_token_iterator to another for inequality.\n+       * @todo Implement this function.\n+       */\n+      bool\n+      operator!=(const regex_token_iterator& __rhs);\n+      \n+      /**\n+       * @brief Dereferences a %regex_token_iterator.\n+       * @todo Implement this function.\n+       */\n+      const value_type&\n+      operator*();\n+      \n+      /**\n+       * @brief Selects a %regex_token_iterator member.\n+       * @todo Implement this function.\n+       */\n+      const value_type*\n+      operator->();\n+      \n+      /**\n+       * @brief Increments a %regex_token_iterator.\n+       * @todo Implement this function.\n+       */\n+      regex_token_iterator&\n+      operator++();\n+      \n+      /**\n+       * @brief Postincrements a %regex_token_iterator.\n+       * @todo Implement this function.\n+       */\n+      regex_token_iterator\n+      operator++(int);\n+      \n+    private: // data members for exposition only:\n+      typedef regex_iterator<_Bi_iter, _Ch_type, _Rx_traits> position_iterator;\n+\n+      position_iterator __position;\n+      const value_type* __result;\n+      value_type        __suffix;\n+      std::size_t       __n;\n+      std::vector<int>  __subs;\n+    };\n+\n+  typedef regex_token_iterator<const char*>             cregex_token_iterator;\n+  typedef regex_token_iterator<string::const_iterator>  sregex_token_iterator;\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  typedef regex_token_iterator<const wchar_t*>          wcregex_token_iterator;\n+  typedef regex_token_iterator<wstring::const_iterator> wsregex_token_iterator;\n+#endif\n+  \n+  /** @} */ // group tr1_regex\n+  \n+_GLIBCXX_END_NAMESPACE\n+}\n+\n+#endif // _TR1_REGEX"}, {"sha": "6594b286adcabfcd33351d93a172b5d2aed1b54f", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/basic_regex/assign/char/cstring.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fchar%2Fcstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fchar%2Fcstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fchar%2Fcstring.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.8.3] class template basic_regex assign()\n+\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests assign operation from a C-style null-terminated-string.  \n+void test01()\n+{\n+  typedef std::tr1::basic_regex<char> test_type;\n+\n+  const char* cs = \"aab\";\n+  test_type re;\n+  re.assign(cs);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "d8db3933b1850b8cb55c3710dfe062c6554ba2d9", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/basic_regex/assign/char/cstring_op.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fchar%2Fcstring_op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fchar%2Fcstring_op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fchar%2Fcstring_op.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.8.3] class template basic_regex assign()\n+\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests basic_regex assign operator from a C-style null-terminated-string.  \n+void test01()\n+{\n+  typedef std::tr1::basic_regex<char> test_type;\n+\n+  const char* cs = \"aab\";\n+  test_type re;\n+  re = cs;\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "fd48a46623a11c270f0bbcabab8c022da298f6ac", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/basic_regex/assign/char/pstring.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fchar%2Fpstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fchar%2Fpstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fchar%2Fpstring.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.8.3] class template basic_regex assign()\n+\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests assign operation from a Pascal-style counted-string.  \n+void test01()\n+{\n+  typedef std::tr1::basic_regex<char> test_type;\n+\n+  const char cs[] = \"aab\";\n+  test_type re;\n+  re.assign(cs, sizeof(cs)-1, std::tr1::regex_constants::basic);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "e96e169463c189cccd25cf6bc1bbb444fb586055", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/basic_regex/assign/char/range.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fchar%2Frange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fchar%2Frange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fchar%2Frange.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.8.3] class template basic_regex assign()\n+\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests range assign of the basic_regex class.  \n+void test01()\n+{\n+  typedef std::tr1::basic_regex<char> test_type;\n+\n+  char s[] = \"a+b|c\";\n+  test_type re;\n+  re.assign(s, s + sizeof(s));\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "57e9a6b1dfdb27bf71727d26cb7a49a7b6db9b46", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/basic_regex/assign/char/string.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fchar%2Fstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fchar%2Fstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fchar%2Fstring.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.8.3] class template basic_regex assign()\n+\n+#include <string>\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests C++ string assignment of the basic_regex class.  \n+void test01()\n+{\n+  typedef std::tr1::basic_regex<char> test_type;\n+\n+  std::string s(\"a*b\");\n+  test_type re;\n+  re.assign(s);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "a653fbc6f53272ecfdc82759f1fef8367e21b3f2", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/basic_regex/assign/char/string_op.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fchar%2Fstring_op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fchar%2Fstring_op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fchar%2Fstring_op.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.8.3] class template basic_regex assign()\n+\n+#include <string>\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests basic_regex assignment operator from a C++ string;\n+void test01()\n+{\n+  typedef std::tr1::basic_regex<char> test_type;\n+\n+  std::string s(\"a*b\");\n+  test_type re;\n+  re = s;\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "755434044fe0efea8f7e49c55a3bf82aa73d2e03", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/basic_regex/assign/wchar_t/cstring.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fwchar_t%2Fcstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fwchar_t%2Fcstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fwchar_t%2Fcstring.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.8.3] class template basic_regex assign()\n+\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests assign operation from a C-style null-terminated-string.  \n+void test01()\n+{\n+  typedef std::tr1::basic_regex<wchar_t> test_type;\n+\n+  const wchar_t* cs = L\"aab\";\n+  test_type re;\n+  re.assign(cs);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "f61dbcf22d7dac856e9138ada4584b202a195cfc", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/basic_regex/assign/wchar_t/cstring_op.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fwchar_t%2Fcstring_op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fwchar_t%2Fcstring_op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fwchar_t%2Fcstring_op.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.8.3] class template basic_regex assign()\n+\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests basic_regex assign operator from a C-style null-terminated-string.  \n+void test01()\n+{\n+  typedef std::tr1::basic_regex<wchar_t> test_type;\n+\n+  const wchar_t* cs = L\"aab\";\n+  test_type re;\n+  re = cs;\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "bf3de48e94a6312d8ed24376f4eabdb50aefa2a9", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/basic_regex/assign/wchar_t/pstring.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fwchar_t%2Fpstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fwchar_t%2Fpstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fwchar_t%2Fpstring.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.8.3] class template basic_regex assign()\n+\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests assign operation from a Pascal-style counted-string.  \n+void test01()\n+{\n+  typedef std::tr1::basic_regex<wchar_t> test_type;\n+\n+  const wchar_t cs[] = L\"aab\";\n+  test_type re;\n+  re.assign(cs, sizeof(cs)-1, std::tr1::regex_constants::basic);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "ca48cadf880ad1c816a3cc4facecec6058080bdd", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/basic_regex/assign/wchar_t/range.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fwchar_t%2Frange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fwchar_t%2Frange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fwchar_t%2Frange.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.8.3] class template basic_regex assign()\n+\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests range assign of the basic_regex class.  \n+void test01()\n+{\n+  typedef std::tr1::basic_regex<wchar_t> test_type;\n+\n+  wchar_t s[] = L\"a+b|c\";\n+  test_type re;\n+  re.assign(s, s + sizeof(s));\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "a5303e267eb4698b296d42f3b66c12993faa6056", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/basic_regex/assign/wchar_t/string.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fwchar_t%2Fstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fwchar_t%2Fstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fwchar_t%2Fstring.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.8.3] class template basic_regex assign()\n+\n+#include <string>\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests C++ string assignment of the basic_regex class.  \n+void test01()\n+{\n+  typedef std::tr1::basic_regex<wchar_t> test_type;\n+\n+  std::wstring s(L\"a*b\");\n+  test_type re;\n+  re.assign(s);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "78ac26d8dfe60e37d37e4a5c8b0ceabcc62d0e91", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/basic_regex/assign/wchar_t/string_op.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fwchar_t%2Fstring_op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fwchar_t%2Fstring_op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fassign%2Fwchar_t%2Fstring_op.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.8.3] class template basic_regex assign()\n+\n+#include <string>\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests basic_regex assignment operator from a C++ string;\n+void test01()\n+{\n+  typedef std::tr1::basic_regex<wchar_t> test_type;\n+\n+  std::wstring s(L\"a*b\");\n+  test_type re;\n+  re = s;\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "a349acd8d20fdffcbf42866c8b791c3b0d37b461", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/basic_regex/ctors/char/cstring.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fchar%2Fcstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fchar%2Fcstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fchar%2Fcstring.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.8.2] class template basic_regex constructor\n+\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests C-style null-terminated-string constructor of the basic_regex class.  \n+void test01()\n+{\n+  typedef std::tr1::basic_regex<char> test_type;\n+\n+  const char* cs = \"aab\";\n+  test_type re(cs);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "b499a282b7efbbef8c5cc2f781c103356b6957f5", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/basic_regex/ctors/char/default.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fchar%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fchar%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fchar%2Fdefault.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,47 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.8.2] class template basic_regex constructor\n+\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests default constructor of the basic_regex class.  \n+void test01()\n+{\n+  typedef std::tr1::basic_regex<char> test_type;\n+\n+  // default constructor\n+  test_type re;\n+  \n+  // Check for required typedefs\n+  typedef test_type::value_type  value_type;\n+  typedef test_type::flag_type   flag_type;\n+  typedef test_type::locale_type locale_type;\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "827c8bf6af7418779b6d126f90a76a43fb541555", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/basic_regex/ctors/char/pstring.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fchar%2Fpstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fchar%2Fpstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fchar%2Fpstring.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.8.2] class template basic_regex constructor\n+\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests Pascal-style counted-string constructor of the basic_regex class.  \n+void test01()\n+{\n+  typedef std::tr1::basic_regex<char> test_type;\n+\n+  const char* cs = \"aab\";\n+  test_type re(cs, 3, std::tr1::regex_constants::basic);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "53f1f4fc1c874d34371a3256e42a31af987173ce", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/basic_regex/ctors/char/range.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fchar%2Frange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fchar%2Frange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fchar%2Frange.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.8.2] class template basic_regex constructor\n+\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests range constructor of the basic_regex class.  \n+void test01()\n+{\n+  typedef std::tr1::basic_regex<char> test_type;\n+\n+  char s[] = \"a+b|c\";\n+  test_type re(s, s + sizeof(s));\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "0924b1c20153441ba4e203809a4decb82d57a180", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/basic_regex/ctors/char/string.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fchar%2Fstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fchar%2Fstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fchar%2Fstring.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.8.2] class template basic_regex constructor\n+\n+#include <string>\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests C++ string constructor of the basic_regex class.  \n+void test01()\n+{\n+  typedef std::tr1::basic_regex<char> test_type;\n+\n+  std::string s(\"a*b\");\n+  test_type re(s);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "5e8e70347c39a6b76d6f381991585cca44d4878b", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/basic_regex/ctors/wchar_t/cstring.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fwchar_t%2Fcstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fwchar_t%2Fcstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fwchar_t%2Fcstring.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.8.2] class template basic_regex constructor\n+\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests C-style null-terminated-string constructor of the basic_regex class.  \n+void test01()\n+{\n+  typedef std::tr1::basic_regex<wchar_t> test_type;\n+\n+  const wchar_t* cs = L\"aab\";\n+  test_type re(cs);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "efdd81a6e14f3cee2e37b7a45b9be9ef26e891d9", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/basic_regex/ctors/wchar_t/default.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fwchar_t%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fwchar_t%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fwchar_t%2Fdefault.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,47 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.8.2] class template basic_regex constructor\n+\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests default constructor of the basic_regex class.  \n+void test01()\n+{\n+  typedef std::tr1::basic_regex<wchar_t> test_type;\n+\n+  // default constructor\n+  test_type re;\n+  \n+  // Check for required typedefs\n+  typedef test_type::value_type  value_type;\n+  typedef test_type::flag_type   flag_type;\n+  typedef test_type::locale_type locale_type;\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "f25dee605d814d4dc27937385c39ad2b79a04ac8", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/basic_regex/ctors/wchar_t/pstring.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fwchar_t%2Fpstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fwchar_t%2Fpstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fwchar_t%2Fpstring.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.8.2] class template basic_regex constructor\n+\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests Pascal-style counted-string constructor of the basic_regex class.  \n+void test01()\n+{\n+  typedef std::tr1::basic_regex<wchar_t> test_type;\n+\n+  const wchar_t* cs = L\"aab\";\n+  test_type re(cs, 3, std::tr1::regex_constants::basic);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "eb9139a903898b813382c5b55f1dc72690ba7ae1", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/basic_regex/ctors/wchar_t/range.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fwchar_t%2Frange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fwchar_t%2Frange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fwchar_t%2Frange.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.8.2] class template basic_regex constructor\n+\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests range constructor of the basic_regex class.  \n+void test01()\n+{\n+  typedef std::tr1::basic_regex<wchar_t> test_type;\n+\n+  wchar_t s[] = L\"a+b|c\";\n+  test_type re(s, s + sizeof(s));\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "6379fecefc453f59197bb0632b3431d9c5328595", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/basic_regex/ctors/wchar_t/string.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fwchar_t%2Fstring.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fwchar_t%2Fstring.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fbasic_regex%2Fctors%2Fwchar_t%2Fstring.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.8.2] class template basic_regex constructor\n+\n+#include <string>\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests C++ string constructor of the basic_regex class.  \n+void test01()\n+{\n+  typedef std::tr1::basic_regex<wchar_t> test_type;\n+\n+  std::wstring s(L\"a*b\");\n+  test_type re(s);\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "124e7acde54226a521e5faae28ae5725cc872826", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/match_results/ctors/char/default.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fmatch_results%2Fctors%2Fchar%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fmatch_results%2Fctors%2Fchar%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fmatch_results%2Fctors%2Fchar%2Fdefault.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,58 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.10.1] class template match_results constructor\n+\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests default constructor of the match_result class.  \n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef std::tr1::match_results<char*> test_type;\n+\n+  // default constructor\n+  test_type m;\n+  \n+  // Check for required typedefs\n+  typedef test_type::value_type      value_type;\n+  typedef test_type::const_reference const_reference;\n+  typedef test_type::reference       reference;\n+  typedef test_type::const_iterator  const_iterator;\n+  typedef test_type::iterator        iterator;\n+  typedef test_type::difference_type difference_type;\n+  typedef test_type::size_type       size_type;\n+  typedef test_type::allocator_type  allocator_type;\n+  typedef test_type::char_type       char_type;\n+  typedef test_type::string_type     string_type;\n+\n+  VERIFY( m.size() == 0 );\n+  VERIFY( m.str() == std::basic_string<char_type>() );\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "0b90859f8dc9f5f463b707273c94542344ac86c1", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/regex/cons/char/c_string_awk.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex%2Fcons%2Fchar%2Fc_string_awk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex%2Fcons%2Fchar%2Fc_string_awk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex%2Fcons%2Fchar%2Fc_string_awk.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 7.8.2 basic_regex constructors\n+\n+#include <tr1/regex>\n+\n+void\n+test01() \n+{ \n+  std::tr1::regex re(\"(a|b)*abb\", std::tr1::regex::awk);\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "7451f3bd35176622f22a6fd20737aa71d5700ff1", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/regex/cons/char/c_string_basic.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex%2Fcons%2Fchar%2Fc_string_basic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex%2Fcons%2Fchar%2Fc_string_basic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex%2Fcons%2Fchar%2Fc_string_basic.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 7.8.2 basic_regex constructors\n+\n+#include <tr1/regex>\n+\n+void\n+test01() \n+{ \n+  std::tr1::regex re(\"(a|b)*abb\", std::tr1::regex::basic);\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "8713e64240f1aaf6fa641912d8a0e41e071d056f", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/regex/cons/char/c_string_ecma.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex%2Fcons%2Fchar%2Fc_string_ecma.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex%2Fcons%2Fchar%2Fc_string_ecma.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex%2Fcons%2Fchar%2Fc_string_ecma.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 7.8.2 basic_regex constructors\n+\n+#include <tr1/regex>\n+\n+void\n+test01() \n+{ \n+  std::tr1::regex re(\"(a|b)*abb\");\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "dd308cfd4a1aa02c3ebfa7d764a4d197bb14f61d", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/regex/cons/char/c_string_egrep.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex%2Fcons%2Fchar%2Fc_string_egrep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex%2Fcons%2Fchar%2Fc_string_egrep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex%2Fcons%2Fchar%2Fc_string_egrep.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 7.8.2 basic_regex constructors\n+\n+#include <tr1/regex>\n+\n+void\n+test01() \n+{ \n+  std::tr1::regex re(\"(a|b)*abb\", std::tr1::regex::egrep);\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "68e7709722d08512f27ef991a74953580eeb7a5e", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/regex/cons/char/c_string_extended.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex%2Fcons%2Fchar%2Fc_string_extended.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex%2Fcons%2Fchar%2Fc_string_extended.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex%2Fcons%2Fchar%2Fc_string_extended.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do run }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 7.8.2 basic_regex constructors\n+\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01() \n+{ \n+  bool test __attribute__((unused)) = true;\n+\n+  std::tr1::regex re(\"(wee|week)(knights|night)\", std::tr1::regex::extended);\n+  \n+  VERIFY( re.flags() == std::tr1::regex::extended );\n+  VERIFY( re.mark_count() == 0 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "d49e31ce8b4b074fb501936338b0cd51480b5e06", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/regex/cons/char/c_string_grep.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex%2Fcons%2Fchar%2Fc_string_grep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex%2Fcons%2Fchar%2Fc_string_grep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex%2Fcons%2Fchar%2Fc_string_grep.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,39 @@\n+// { dg-do compile }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 7.8.2 basic_regex constructors\n+\n+#include <tr1/regex>\n+\n+void\n+test01() \n+{ \n+  using std::tr1::regex;\n+\n+  regex re(\"(a|b)*abb\", regex::grep);\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "d2568119633b66bf5a86bcc7dc527a3f3ff98918", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/regex/cons/char/default.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex%2Fcons%2Fchar%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex%2Fcons%2Fchar%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex%2Fcons%2Fchar%2Fdefault.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do compile }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 7.8.2 basic_regex constructors\n+\n+#include <tr1/regex>\n+\n+void\n+test01() \n+{ \n+  std::tr1::regex re;\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "1efb8676517ab233e90c1df7ee1ef36251430d1b", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/regex_traits/char/ctor.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex_traits%2Fchar%2Fctor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex_traits%2Fchar%2Fctor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex_traits%2Fchar%2Fctor.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.7] class template regex_traits\n+\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests default constructor of the regex_traits class.  There is only the\n+// default constructor.\n+void test01()\n+{\n+  typedef std::tr1::regex_traits<char> test_type;\n+\n+  // required default constructor\n+  test_type t;\n+  \n+  // Check for required typedefs\n+  typedef test_type::char_type       char_type;\n+  typedef test_type::string_type     string_type;\n+  typedef test_type::locale_type     locale_type;\n+  typedef test_type::char_class_type char_class_type;\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "14d99dd4588171f4c121952075bc0e795e8c4c44", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/regex_traits/char/translate_nocase.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex_traits%2Fchar%2Ftranslate_nocase.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex_traits%2Fchar%2Ftranslate_nocase.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex_traits%2Fchar%2Ftranslate_nocase.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do run }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.7] class template regex_traits (5) translate_nocase\n+\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests default constructor of the regex_traits class.  There is only the\n+// default constructor.\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  std::tr1::regex_traits<char> t;\n+  VERIFY( t.translate_nocase('A') == 'a' );\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "4ba65c511852a2fc9bbf79cd6f0d5db76f326dc0", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/regex_traits/wchar_t/ctor.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex_traits%2Fwchar_t%2Fctor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex_traits%2Fwchar_t%2Fctor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex_traits%2Fwchar_t%2Fctor.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do link }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.7] class template regex_traits\n+\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests default constructor of the regex_traits class.  There is only the\n+// default constructor.\n+void test01()\n+{\n+  typedef std::tr1::regex_traits<wchar_t> test_type;\n+\n+  // required default constructor\n+  test_type t;\n+  \n+  // Check for required typedefs\n+  typedef test_type::char_type       char_type;\n+  typedef test_type::string_type     string_type;\n+  typedef test_type::locale_type     locale_type;\n+  typedef test_type::char_class_type char_class_type;\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}, {"sha": "cb6d9b8c5daee625c40d1fb59d317d4bcf16362e", "filename": "libstdc++-v3/testsuite/tr1/7_regular_expressions/regex_traits/wchar_t/translate_nocase.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex_traits%2Fwchar_t%2Ftranslate_nocase.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a21856f76bb601b3dd4f1a180ff07c5420075756/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex_traits%2Fwchar_t%2Ftranslate_nocase.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F7_regular_expressions%2Fregex_traits%2Fwchar_t%2Ftranslate_nocase.cc?ref=a21856f76bb601b3dd4f1a180ff07c5420075756", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do run }\n+\n+// 2007-03-12  Stephen M. Webb  <stephen.webb@bregmasoft.com>\n+//\n+// Copyright (C) 2007 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// tr1 [7.7] class template regex_traits (5) translate_nocase\n+\n+#include <tr1/regex>\n+#include <testsuite_hooks.h>\n+\n+// Tests default constructor of the regex_traits class.  There is only the\n+// default constructor.\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  std::tr1::regex_traits<wchar_t> t;\n+  VERIFY( t.translate_nocase(L'A') == L'a' );\n+}\n+\n+int\n+main()\n+{ \n+  test01();\n+  return 0;\n+};"}]}