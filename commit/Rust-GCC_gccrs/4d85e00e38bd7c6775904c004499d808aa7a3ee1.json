{"sha": "4d85e00e38bd7c6775904c004499d808aa7a3ee1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ4NWUwMGUzOGJkN2M2Nzc1OTA0YzAwNDQ5OWQ4MDhhYTdhM2VlMQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-08-20T13:46:53Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-08-20T13:46:53Z"}, "message": "decl.c (duplicate_decls): Always merge the old and new patterns for templates...\n\n\t* decl.c (duplicate_decls): Always merge the old and new patterns\n\tfor templates, regardless of whether or not the new one has\n\tDECL_INITIAL.  Don't throw away specializations.  Merge\n\tDECL_SAVED_TREE.\n\t* pt.c (tsubst_decl): Use the right pattern when calculating the\n\tcomplete args for a new template instance.\n\t(do_decl_instantiation): Fix typo in comment.\n\t(regenerate_decl_from_template): Deal with tricky friend template\n\tcase.\n\t(instantiate_decl): Likewise.\n\nFrom-SVN: r21876", "tree": {"sha": "0e96b25738fc8d44f5034c0ec7390633c1d566da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e96b25738fc8d44f5034c0ec7390633c1d566da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d85e00e38bd7c6775904c004499d808aa7a3ee1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d85e00e38bd7c6775904c004499d808aa7a3ee1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d85e00e38bd7c6775904c004499d808aa7a3ee1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d85e00e38bd7c6775904c004499d808aa7a3ee1/comments", "author": null, "committer": null, "parents": [{"sha": "293bcdc970c9509e8079c4ee96efc1c693be2d9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/293bcdc970c9509e8079c4ee96efc1c693be2d9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/293bcdc970c9509e8079c4ee96efc1c693be2d9d"}], "stats": {"total": 166, "additions": 141, "deletions": 25}, "files": [{"sha": "942db4bef26715c0bf63b699d41670159960a464", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d85e00e38bd7c6775904c004499d808aa7a3ee1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d85e00e38bd7c6775904c004499d808aa7a3ee1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4d85e00e38bd7c6775904c004499d808aa7a3ee1", "patch": "@@ -1,3 +1,16 @@\n+1998-08-20  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* decl.c (duplicate_decls): Always merge the old and new patterns\n+\tfor templates, regardless of whether or not the new one has\n+\tDECL_INITIAL.  Don't throw away specializations.  Merge\n+\tDECL_SAVED_TREE.\n+\t* pt.c (tsubst_decl): Use the right pattern when calculating the\n+\tcomplete args for a new template instance.\n+\t(do_decl_instantiation): Fix typo in comment.\n+\t(regenerate_decl_from_template): Deal with tricky friend template\n+\tcase.\n+\t(instantiate_decl): Likewise.\n+\t\n Thu Aug 20 09:09:45 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* init.c (build_builtin_delete_call): Add missing assemble_external"}, {"sha": "ad3585b20ab1f708f5d84ee4e974395d3bf00786", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d85e00e38bd7c6775904c004499d808aa7a3ee1/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d85e00e38bd7c6775904c004499d808aa7a3ee1/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4d85e00e38bd7c6775904c004499d808aa7a3ee1", "patch": "@@ -2982,17 +2982,15 @@ duplicate_decls (newdecl, olddecl)\n \n   if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n     {\n-      if (DECL_INITIAL (DECL_TEMPLATE_RESULT (olddecl)) == NULL_TREE)\n-\t{\n-\t  if (! duplicate_decls (DECL_TEMPLATE_RESULT (newdecl),\n-\t\t\t\t DECL_TEMPLATE_RESULT (olddecl)))\n-\t    cp_error (\"invalid redeclaration of %D\", newdecl);\n-\t  TREE_TYPE (olddecl) = TREE_TYPE (DECL_TEMPLATE_RESULT (olddecl));\n-\t  DECL_TEMPLATE_PARMS (olddecl) = DECL_TEMPLATE_PARMS (newdecl);\n-\t  DECL_TEMPLATE_INFO (olddecl) = DECL_TEMPLATE_INFO (newdecl);\n-\t}\n-      DECL_TEMPLATE_SPECIALIZATIONS (newdecl)\n-\t= DECL_TEMPLATE_SPECIALIZATIONS (olddecl);\n+      if (! duplicate_decls (DECL_TEMPLATE_RESULT (newdecl),\n+\t\t\t     DECL_TEMPLATE_RESULT (olddecl)))\n+\tcp_error (\"invalid redeclaration of %D\", newdecl);\n+      TREE_TYPE (olddecl) = TREE_TYPE (DECL_TEMPLATE_RESULT (olddecl));\n+      DECL_TEMPLATE_PARMS (olddecl) = DECL_TEMPLATE_PARMS (newdecl);\n+      DECL_TEMPLATE_INFO (olddecl) = DECL_TEMPLATE_INFO (newdecl);\n+      DECL_TEMPLATE_SPECIALIZATIONS (olddecl) \n+\t= chainon (DECL_TEMPLATE_SPECIALIZATIONS (olddecl),\n+\t\t   DECL_TEMPLATE_SPECIALIZATIONS (newdecl));\n  \n       return 1;\n     }\n@@ -3067,6 +3065,9 @@ duplicate_decls (newdecl, olddecl)\n \t  DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n \t  DECL_SOURCE_FILE (newdecl) = DECL_SOURCE_FILE (olddecl);\n \t  DECL_SOURCE_LINE (newdecl) = DECL_SOURCE_LINE (olddecl);\n+\t  if (DECL_LANG_SPECIFIC (newdecl)\n+\t      && DECL_LANG_SPECIFIC (olddecl))\n+\t    DECL_SAVED_TREE (newdecl) = DECL_SAVED_TREE (olddecl);\n \t}\n \n       /* Merge the section attribute."}, {"sha": "a04921cfb81799174a66aa92d02e8e69420b0dbd", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 98, "deletions": 14, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d85e00e38bd7c6775904c004499d808aa7a3ee1/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d85e00e38bd7c6775904c004499d808aa7a3ee1/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4d85e00e38bd7c6775904c004499d808aa7a3ee1", "patch": "@@ -4847,7 +4847,8 @@ tsubst_decl (t, args, type, in_decl)\n \t       specialization, and the complete set of arguments used to\n \t       specialize R.  */\n \t    gen_tmpl = most_general_template (DECL_TI_TEMPLATE (t));\n-\t    argvec = tsubst (DECL_TI_ARGS (t), args, in_decl);\n+\t    argvec = tsubst (DECL_TI_ARGS (DECL_TEMPLATE_RESULT (gen_tmpl)),\n+\t\t\t     args, in_decl); \n \n \t    /* Check to see if we already have this specialization.  */\n \t    spec = retrieve_specialization (gen_tmpl, argvec);\n@@ -7460,7 +7461,7 @@ do_decl_instantiation (declspecs, declarator, storage)\n   else if (DECL_TEMPLATE_SPECIALIZATION (decl))\n     /* [temp.spec]\n \n-       No program shall both explicit instantiation and explicit\n+       No program shall both explicitly instantiate and explicitly\n        specialize a template.  */\n     {\n       cp_error (\"explicit instantiation of `%#D' after\", decl);\n@@ -7649,6 +7650,9 @@ regenerate_decl_from_template (decl, tmpl)\n   tree code_pattern;\n   tree new_decl;\n   tree gen_tmpl;\n+  tree subst_args;\n+  int args_depth;\n+  int parms_depth;\n   int unregistered;\n \n   args = DECL_TI_ARGS (decl);\n@@ -7667,15 +7671,51 @@ regenerate_decl_from_template (decl, tmpl)\n      register_specialization for it.  */\n   my_friendly_assert (unregistered, 0);\n \n-  /* Do the substitution to get the new declaration.  */\n-  new_decl = tsubst (code_pattern, args, NULL_TREE);\n+  /* Do the substitution to get the new declaration.  Normally, of\n+     course, we want the full set of ARGS.  However, one peculiar case\n+     is code like this: \n+\n+       template <class T> struct S { \n+\t template <class U> friend void f();\n+       };\n+       template <class U> friend void f() {}\n+       template S<int>;\n+       template void f<double>();\n+\n+     Here, the ARGS for the instantiation of will be {int, double}.\n+     But, we only need as many ARGS as there are levels of template\n+     parameters in CODE_PATTERN.  We are careful not to get fooled\n+     into reducing the ARGS in situations like:\n+\n+       template <class T> struct S { template <class U> void f(U); }\n+       template <class T> template <> void S<T>::f(int) {}\n+\n+     which we can spot because the innermost template args for the\n+     CODE_PATTERN don't use any template parameters.  */\n+  args_depth = TMPL_ARGS_DEPTH (args);\n+  parms_depth = \n+    TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (DECL_TI_TEMPLATE (code_pattern)));\n+  if (args_depth > parms_depth\n+      && !DECL_TEMPLATE_SPECIALIZATION (code_pattern))\n+    {\n+      int i;\n+\n+      subst_args = make_temp_vec (parms_depth);\n+      for (i = 0; i < parms_depth; ++i)\n+\tTREE_VEC_ELT (subst_args, i) = \n+\t  TREE_VEC_ELT (args, i + (args_depth - parms_depth));\n+    }\n+  else\n+    subst_args = args;\n+\n+  new_decl = tsubst (code_pattern, subst_args, NULL_TREE);\n \n   if (TREE_CODE (decl) == VAR_DECL)\n     {\n       /* Set up DECL_INITIAL, since tsubst doesn't.  */\n       pushclass (DECL_CONTEXT (decl), 2);\n       DECL_INITIAL (new_decl) = \n-\ttsubst_expr (DECL_INITIAL (code_pattern), args, \n+\ttsubst_expr (DECL_INITIAL (code_pattern), subst_args, \n \t\t     DECL_TI_TEMPLATE (decl));\n       popclass (1);\n     }\n@@ -7747,16 +7787,60 @@ instantiate_decl (d)\n   if (! push_tinst_level (d))\n     return d;\n \n-  for (td = tmpl; \n-       DECL_TEMPLATE_INSTANTIATION (td) \n-\t /* This next clause handles friend templates defined inside\n-\t    class templates.  The friend templates are not really\n-\t    instantiations from the point of view of the language, but\n-\t    they are instantiations from the point of view of the\n-\t    compiler.  */\n-\t || (DECL_TEMPLATE_INFO (td) && !DECL_TEMPLATE_SPECIALIZATION (td)); \n+  /* Set TD to the template whose DECL_TEMPLATE_RESULT is the pattern\n+     for the instantiation.  This is not always the most general\n+     template.  Consider, for example:\n+\n+        template <class T>\n+\tstruct S { template <class U> void f();\n+\t           template <> void f<int>(); };\n+\n+     and an instantiation of S<double>::f<int>.  We want TD to be the\n+     specialization S<T>::f<int>, not the more general S<T>::f<U>.  */\n+  td = tmpl;\n+  for (td = tmpl;\n+       /* An instantiation cannot have a definition, so we need a\n+\t  more general template.  */\n+       DECL_TEMPLATE_INSTANTIATION (td)\n+\t /* We must also deal with friend templates.  Given:\n+\n+\t      template <class T> struct S { \n+\t\ttemplate <class U> friend void f() {};\n+\t      };\n+\t \n+\t    S<int>::f<U> say, is not an instantiation of S<T>::f<U>,\n+\t    so far as the language is concerned, but that's still\n+\t    where we get the pattern for the instantiation from.  On\n+\t    ther hand, if the definition comes outside the class, say:\n+\n+ \t      template <class T> struct S { \n+\t        template <class U> friend void f();\n+              };\n+\t      template <class U> friend void f() {}\n+\n+\t    we don't need to look any further.  That's what the check for\n+\t    DECL_INITIAL is for.  */\n+\t|| (TREE_CODE (d) == FUNCTION_DECL\n+\t    && DECL_TEMPLATE_INFO (td) \n+\t    && !DECL_TEMPLATE_SPECIALIZATION (td)\n+\t    && !DECL_INITIAL (DECL_TEMPLATE_RESULT (td)));\n        )\n-    td = DECL_TI_TEMPLATE (td);\n+    {\n+      /* The present template, TD, should not be a definition.  If it\n+\t were a definition, we should be using it!  Note that we\n+\t cannot restructure the loop to just keep going until we find\n+\t a template with a definition, since that might go too far if\n+\t a specialization was declared, but not defined.  */\n+      my_friendly_assert (!(TREE_CODE (d) == FUNCTION_DECL\n+\t\t\t    && DECL_INITIAL (DECL_TEMPLATE_RESULT (td))),\n+\t\t\t  0);\n+      my_friendly_assert (!(TREE_CODE (d) == VAR_DECL\n+\t\t\t    && !DECL_IN_AGGR_P (DECL_TEMPLATE_RESULT (td))), \n+\t\t\t  0); \n+      \n+      /* Fetch the more general template.  */\n+      td = DECL_TI_TEMPLATE (td);\n+    }\n \n   code_pattern = DECL_TEMPLATE_RESULT (td);\n "}, {"sha": "61dd8fcb8e9fe3d9cdf2d159dcd2b2e598ee3356", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend30.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d85e00e38bd7c6775904c004499d808aa7a3ee1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend30.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d85e00e38bd7c6775904c004499d808aa7a3ee1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend30.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend30.C?ref=4d85e00e38bd7c6775904c004499d808aa7a3ee1", "patch": "@@ -0,0 +1,18 @@\n+// Build don't link:\n+\n+template <class T, class U>\n+struct S {\n+  template <class X, class Y, class Z>\n+  friend X f(X, Y, Z);\n+};\n+\n+template <class X, class Y, class Z>\n+X f(X x, Y, Z) {\n+  return x;\n+}\n+\n+template char f(char, long, short);\n+template char* f(char*, long*, short*);\n+template class S<int, double>;\n+template class S<void*, double>;\n+template double* f(double*, long*, short*);"}]}