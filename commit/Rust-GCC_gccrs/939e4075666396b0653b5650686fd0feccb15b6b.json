{"sha": "939e4075666396b0653b5650686fd0feccb15b6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM5ZTQwNzU2NjYzOTZiMDY1M2I1NjUwNjg2ZmQwZmVjY2IxNWI2Yg==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-12-23T06:01:43Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-12-23T06:01:43Z"}, "message": "In gcc/: 2010-12-23 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/:\n2010-12-23  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* doc/objc.texi (Modern GNU Objective-C runtime API): Mention that\n\treference documentation for functions in the API is in the header\n\tfiles.\n\t(Messaging with the GNU Objective-C runtime, Dynamically\n\tregistering methods, Forwarding hook): New sections.\n\nFrom-SVN: r168200", "tree": {"sha": "02acd49c175f64cae2699b1b3f80c50fd717fb85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02acd49c175f64cae2699b1b3f80c50fd717fb85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/939e4075666396b0653b5650686fd0feccb15b6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/939e4075666396b0653b5650686fd0feccb15b6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/939e4075666396b0653b5650686fd0feccb15b6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/939e4075666396b0653b5650686fd0feccb15b6b/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "828839869831f7b3426b1924cb29b837237d019f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/828839869831f7b3426b1924cb29b837237d019f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/828839869831f7b3426b1924cb29b837237d019f"}], "stats": {"total": 146, "additions": 146, "deletions": 0}, "files": [{"sha": "c780a7a380509f4bbfae2b26f7bb8d9f7eba2cba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939e4075666396b0653b5650686fd0feccb15b6b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939e4075666396b0653b5650686fd0feccb15b6b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=939e4075666396b0653b5650686fd0feccb15b6b", "patch": "@@ -1,3 +1,11 @@\n+2010-12-23  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* doc/objc.texi (Modern GNU Objective-C runtime API): Mention that\n+\treference documentation for functions in the API is in the header\n+\tfiles.\n+\t(Messaging with the GNU Objective-C runtime, Dynamically\n+\tregistering methods, Forwarding hook): New sections.\n+\n 2010-12-22  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tPR tree-optimization/47019"}, {"sha": "93b5ec513a2279b1c2f01af1c26b29b0cc2bd93d", "filename": "gcc/doc/objc.texi", "status": "modified", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939e4075666396b0653b5650686fd0feccb15b6b/gcc%2Fdoc%2Fobjc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939e4075666396b0653b5650686fd0feccb15b6b/gcc%2Fdoc%2Fobjc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fobjc.texi?ref=939e4075666396b0653b5650686fd0feccb15b6b", "patch": "@@ -22,6 +22,7 @@ several resources on the Internet that present the language.\n * Exceptions::\n * Synchronization::\n * Fast enumeration::\n+* Messaging with the GNU Objective-C runtime::\n @end menu\n \n @c =========================================================================\n@@ -104,6 +105,9 @@ platform-independent set of threading functions.\n \n @end itemize\n \n+The header files contain detailed documentation for each function in\n+the GNU Objective-C runtime API.\n+\n @c =========================================================================\n @node Traditional GNU Objective-C runtime API\n @subsection Traditional GNU Objective-C runtime API\n@@ -1086,3 +1090,137 @@ Finally, note how we declared the @code{len} argument and the return\n value to be of type @code{unsigned long}.  They could also be declared\n to be of type @code{unsigned int} and everything would still work.\n \n+@c =========================================================================\n+@node Messaging with the GNU Objective-C runtime\n+@section Messaging with the GNU Objective-C runtime\n+\n+This section is specific for the GNU Objective-C runtime.  If you are\n+using a different runtime, you can skip it.\n+\n+The implementation of messaging in the GNU Objective-C runtime is\n+designed to be portable, and so is based on standard C.\n+\n+Sending a message in the GNU Objective-C runtime is composed of two\n+separate steps.  First, there is a call to the lookup function,\n+@code{objc_msg_lookup ()} (or, in the case of messages to super,\n+@code{objc_msg_lookup_super ()}).  This runtime function takes as\n+argument the receiver and the selector of the method to be called; it\n+returns the @code{IMP}, that is a pointer to the function implementing\n+the method.  The second step of method invocation consists of casting\n+this pointer function to the appropriate function pointer type, and\n+calling the function pointed to it with the right arguments.\n+\n+For example, when the compiler encounters a method invocation such as\n+@code{[object init]}, it compiles it into a call to\n+@code{objc_msg_lookup (object, @@selector(init))} followed by a cast\n+of the returned value to the appropriate function pointer type, and\n+then it calls it.\n+\n+@menu\n+* Dynamically registering methods::\n+* Forwarding hook::\n+@end menu\n+\n+@c =========================================================================\n+@node Dynamically registering methods\n+@subsection Dynamically registering methods\n+\n+If @code{objc_msg_lookup()} does not find a suitable method\n+implementation, because the receiver does not implement the required\n+method, it tries to see if the class can dynamically register the\n+method.\n+\n+To do so, the runtime checks if the class of the receiver implements\n+the method\n+\n+@smallexample\n++ (BOOL) resolveInstanceMethod: (SEL)selector;\n+@end smallexample\n+\n+in the case of an instance method, or \n+\n+@smallexample\n++ (BOOL) resolveClassMethod: (SEL)selector;\n+@end smallexample\n+\n+in the case of a class method.  If the class implements it, the\n+runtime invokes it, passing as argument the selector of the original\n+method, and if it returns @code{YES}, the runtime tries the lookup\n+again, which could now succeed if a matching method was added\n+dynamically by @code{+resolveInstanceMethod:} or\n+@code{+resolveClassMethod:}.\n+\n+This allows classes to dynamically register methods (by adding them to\n+the class using @code{class_addMethod}) when they are first called.\n+To do so, a class should implement @code{+resolveInstanceMethod:} (or,\n+depending on the case, @code{+resolveClassMethod:}) and have it\n+recognize the selectors of methods that can be registered dynamically\n+at runtime, register them, and return @code{YES}.  It should return\n+@code{NO} for methods that it does not dynamically registered at\n+runtime.\n+\n+If @code{+resolveInstanceMethod:} (or @code{+resolveClassMethod:}) is\n+not implemented or returns @code{NO}, the runtime then tries the\n+forwarding hook.\n+\n+Support for @code{+resolveInstanceMethod:} and\n+@code{resolveClassMethod:} was added to the GNU Objective-C runtime in\n+GCC version 4.6.\n+\n+@c =========================================================================\n+@node Forwarding hook\n+@subsection Forwarding hook\n+\n+The GNU Objective-C runtime provides a hook, called\n+@code{__objc_msg_forward2}, which is called by\n+@code{objc_msg_lookup()} when it can't find a method implementation in\n+the runtime tables and after calling @code{+resolveInstanceMethod:}\n+and @code{+resolveClassMethod:} has been attempted and did not succeed\n+in dynamically registering the method.\n+\n+To configure the hook, you set the global variable\n+@code{__objc_msg_foward2} to a function with the same argument and\n+return types of @code{objc_msg_lookup()}.  When\n+@code{objc_msg_lookup()} can not find a method implementation, it\n+invokes the hook function you provided to get a method implementation\n+to return.  So, in practice @code{__objc_msg_forward2} allows you to\n+extend @code{objc_msg_lookup()} by adding some custom code that is\n+called to do a further lookup when no standard method implementation\n+can be found using the normal lookup.\n+\n+This hook is generally reserved for ``Foundation'' libraries such as\n+GNUstep Base, which use it to implement their high-level method\n+forwarding API, typically based around the @code{forwardInvocation:}\n+method.  So, unless you are implementing your own ``Foundation''\n+library, you should not set this hook.\n+\n+In a typical forwarding implementation, the @code{__objc_msg_forward2}\n+hook function determines the argument and return type of the method\n+that is being looked up, and then creates a function that takes these\n+arguments and has that return type, and returns it to the caller.\n+Creating this function is non-trivial and is typically performed using\n+a dedicated library such as @code{libffi}.\n+\n+The forwarding method implementation thus created is returned by\n+@code{objc_msg_lookup()} and is executed as if it was a normal method\n+implementation.  When the forwarding method implementation is called,\n+it is usually expected to pack all arguments into some sort of object\n+(typically, an @code{NSInvocation} in a ``Foundation'' library), and\n+hand it over to the programmer (@code{forwardInvocation:}) who is then\n+allowed to manipulate the method invocation using a high-level API\n+provided by the ``Foundation'' library.  For example, the programmer\n+may want to examine the method invocation arguments and name and\n+potentially change them before forwarding the method invocation to one\n+or more local objects (@code{performInvocation:}) or even to remote\n+objects (by using Distributed Objects or some other mechanism).  When\n+all this completes, the return value is passed back and must be\n+returned correctly to the original caller.\n+\n+Note that the GNU Objective-C runtime currently provides no support\n+for method forwarding or method invocations other than the\n+@code{__objc_msg_forward2} hook.\n+\n+If the forwarding hook does not exist or returns @code{NULL}, the\n+runtime currently attempts forwarding using an older, deprecated API,\n+and if that fails, it aborts the program.  In future versions of the\n+GNU Objective-C runtime, the runtime will immediately abort."}]}