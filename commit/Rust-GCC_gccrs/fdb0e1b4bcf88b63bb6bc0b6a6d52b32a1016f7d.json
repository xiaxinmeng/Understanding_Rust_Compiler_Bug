{"sha": "fdb0e1b4bcf88b63bb6bc0b6a6d52b32a1016f7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRiMGUxYjRiY2Y4OGI2M2JiNmJjMGI2YTZkNTJiMzJhMTAxNmY3ZA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2011-10-31T17:43:25Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2011-10-31T17:43:25Z"}, "message": "ipa-prop.c (mark_modified): Moved up in the file.\n\n2011-10-31  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.c (mark_modified): Moved up in the file.\n\t(is_parm_modified_before_call): Renamed to\n\tis_parm_modified_before_stmt, moved up in the file.\n\t(load_from_unmodified_param): New function.\n\t(compute_complex_assign_jump_func): Also attempt to create pass\n\tthrough jump functions for values loaded from (addressable)\n\tparameters.\n\n\t* testsuite/gcc.dg/ipa/ipcp-4.c: New test.\n\nFrom-SVN: r180705", "tree": {"sha": "da3bd2dc3dd46e767ec18d23ff88e2960eda5373", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da3bd2dc3dd46e767ec18d23ff88e2960eda5373"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdb0e1b4bcf88b63bb6bc0b6a6d52b32a1016f7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdb0e1b4bcf88b63bb6bc0b6a6d52b32a1016f7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdb0e1b4bcf88b63bb6bc0b6a6d52b32a1016f7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdb0e1b4bcf88b63bb6bc0b6a6d52b32a1016f7d/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aa9480274fb3ad710e1afc6558c09e1ab0e7d468", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa9480274fb3ad710e1afc6558c09e1ab0e7d468", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa9480274fb3ad710e1afc6558c09e1ab0e7d468"}], "stats": {"total": 285, "additions": 228, "deletions": 57}, "files": [{"sha": "28112f7acb668983deb0c7ac9453f2a59cec25aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb0e1b4bcf88b63bb6bc0b6a6d52b32a1016f7d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb0e1b4bcf88b63bb6bc0b6a6d52b32a1016f7d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fdb0e1b4bcf88b63bb6bc0b6a6d52b32a1016f7d", "patch": "@@ -1,3 +1,13 @@\n+2011-10-31  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.c (mark_modified): Moved up in the file.\n+\t(is_parm_modified_before_call): Renamed to\n+\tis_parm_modified_before_stmt, moved up in the file.\n+\t(load_from_unmodified_param): New function.\n+\t(compute_complex_assign_jump_func): Also attempt to create pass\n+\tthrough jump functions for values loaded from (addressable)\n+\tparameters.\n+\n 2011-10-31  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree-vect-stmts.c (vectorizable_shift): If op1 is vect_external_def"}, {"sha": "e624426d698fd678479a5f302c44c2b4cc645ef9", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 146, "deletions": 57, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb0e1b4bcf88b63bb6bc0b6a6d52b32a1016f7d/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb0e1b4bcf88b63bb6bc0b6a6d52b32a1016f7d/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=fdb0e1b4bcf88b63bb6bc0b6a6d52b32a1016f7d", "patch": "@@ -419,31 +419,154 @@ detect_type_change_ssa (tree arg, gimple call, struct ipa_jump_func *jfunc)\n   return detect_type_change (arg, arg, call, jfunc, 0);\n }\n \n+/* Callback of walk_aliased_vdefs.  Flags that it has been invoked to the\n+   boolean variable pointed to by DATA.  */\n+\n+static bool\n+mark_modified (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef ATTRIBUTE_UNUSED,\n+\t\t     void *data)\n+{\n+  bool *b = (bool *) data;\n+  *b = true;\n+  return true;\n+}\n+\n+/* Return true if the formal parameter PARM might have been modified in this\n+   function before reaching the statement STMT.  PARM_AINFO is a pointer to a\n+   structure containing temporary information about PARM.  */\n+\n+static bool\n+is_parm_modified_before_stmt (struct param_analysis_info *parm_ainfo,\n+\t\t\t      gimple stmt, tree parm)\n+{\n+  bool modified = false;\n+  ao_ref refd;\n+\n+  if (parm_ainfo->modified)\n+    return true;\n+\n+  gcc_checking_assert (gimple_vuse (stmt) != NULL_TREE);\n+  ao_ref_init (&refd, parm);\n+  walk_aliased_vdefs (&refd, gimple_vuse (stmt), mark_modified,\n+\t\t      &modified, &parm_ainfo->visited_statements);\n+  if (modified)\n+    {\n+      parm_ainfo->modified = true;\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* If STMT is an assignment that loads a value from an parameter declaration,\n+   return the index of the parameter in ipa_node_params which has not been\n+   modified.  Otherwise return -1.  */\n+\n+static int\n+load_from_unmodified_param (struct ipa_node_params *info,\n+\t\t\t    struct param_analysis_info *parms_ainfo,\n+\t\t\t    gimple stmt)\n+{\n+  int index;\n+  tree op1;\n+\n+  if (!gimple_assign_single_p (stmt))\n+    return -1;\n+\n+  op1 = gimple_assign_rhs1 (stmt);\n+  if (TREE_CODE (op1) != PARM_DECL)\n+    return -1;\n+\n+  index = ipa_get_param_decl_index (info, op1);\n+  if (index < 0\n+      || is_parm_modified_before_stmt (&parms_ainfo[index], stmt, op1))\n+    return -1;\n+\n+  return index;\n+}\n \n /* Given that an actual argument is an SSA_NAME (given in NAME) and is a result\n-   of an assignment statement STMT, try to find out whether NAME can be\n-   described by a (possibly polynomial) pass-through jump-function or an\n-   ancestor jump function and if so, write the appropriate function into\n-   JFUNC */\n+   of an assignment statement STMT, try to determine whether we are actually\n+   handling any of the following cases and construct an appropriate jump\n+   function into JFUNC if so:\n+\n+   1) The passed value is loaded from a formal parameter which is not a gimple\n+   register (most probably because it is addressable, the value has to be\n+   scalar) and we can guarantee the value has not changed.  This case can\n+   therefore be described by a simple pass-through jump function.  For example:\n+\n+      foo (int a)\n+      {\n+        int a.0;\n+\n+        a.0_2 = a;\n+        bar (a.0_2);\n+\n+   2) The passed value can be described by a simple arithmetic pass-through\n+   jump function. E.g.\n+\n+      foo (int a)\n+      {\n+        int D.2064;\n+\n+        D.2064_4 = a.1(D) + 4;\n+        bar (D.2064_4);\n+\n+   This case can also occur in combination of the previous one, e.g.:\n+\n+      foo (int a, int z)\n+      {\n+        int a.0;\n+        int D.2064;\n+\n+\ta.0_3 = a;\n+\tD.2064_4 = a.0_3 + 4;\n+\tfoo (D.2064_4);\n+\n+   3) The passed value is an address of an object within another one (which\n+   also passed by reference).  Such situations are described by an ancestor\n+   jump function and describe situations such as:\n+\n+     B::foo() (struct B * const this)\n+     {\n+       struct A * D.1845;\n+\n+       D.1845_2 = &this_1(D)->D.1748;\n+       A::bar (D.1845_2);\n+\n+   INFO is the structure describing individual parameters access different\n+   stages of IPA optimizations.  PARMS_AINFO contains the information that is\n+   only needed for intraprocedural analysis.  */\n \n static void\n compute_complex_assign_jump_func (struct ipa_node_params *info,\n+\t\t\t\t  struct param_analysis_info *parms_ainfo,\n \t\t\t\t  struct ipa_jump_func *jfunc,\n \t\t\t\t  gimple call, gimple stmt, tree name)\n {\n   HOST_WIDE_INT offset, size, max_size;\n-  tree op1, op2, base, ssa;\n+  tree op1, tc_ssa, base, ssa;\n   int index;\n \n   op1 = gimple_assign_rhs1 (stmt);\n-  op2 = gimple_assign_rhs2 (stmt);\n \n-  if (TREE_CODE (op1) == SSA_NAME\n-      && SSA_NAME_IS_DEFAULT_DEF (op1))\n+  if (TREE_CODE (op1) == SSA_NAME)\n     {\n-      index = ipa_get_param_decl_index (info, SSA_NAME_VAR (op1));\n-      if (index < 0)\n-\treturn;\n+      if (SSA_NAME_IS_DEFAULT_DEF (op1))\n+\tindex = ipa_get_param_decl_index (info, SSA_NAME_VAR (op1));\n+      else\n+\tindex = load_from_unmodified_param (info, parms_ainfo,\n+\t\t\t\t\t    SSA_NAME_DEF_STMT (op1));\n+      tc_ssa = op1;\n+    }\n+  else\n+    {\n+      index = load_from_unmodified_param (info, parms_ainfo, stmt);\n+      tc_ssa = gimple_assign_lhs (stmt);\n+    }\n+\n+  if (index >= 0)\n+    {\n+      tree op2 = gimple_assign_rhs2 (stmt);\n \n       if (op2)\n \t{\n@@ -458,8 +581,8 @@ compute_complex_assign_jump_func (struct ipa_node_params *info,\n \t  jfunc->value.pass_through.operation = gimple_assign_rhs_code (stmt);\n \t  jfunc->value.pass_through.operand = op2;\n \t}\n-      else if (gimple_assign_unary_nop_p (stmt)\n-\t       && !detect_type_change_ssa (op1, call, jfunc))\n+      else if (gimple_assign_single_p (stmt)\n+\t       && !detect_type_change_ssa (tc_ssa, call, jfunc))\n \t{\n \t  jfunc->type = IPA_JF_PASS_THROUGH;\n \t  jfunc->value.pass_through.formal_id = index;\n@@ -665,12 +788,14 @@ compute_known_type_jump_func (tree op, struct ipa_jump_func *jfunc,\n \n /* Determine the jump functions of scalar arguments.  Scalar means SSA names\n    and constants of a number of selected types.  INFO is the ipa_node_params\n-   structure associated with the caller, FUNCTIONS is a pointer to an array of\n-   jump function structures associated with CALL which is the call statement\n-   being examined.*/\n+   structure associated with the caller, PARMS_AINFO describes state of\n+   analysis with respect to individual formal parameters.  ARGS is the\n+   ipa_edge_args structure describing the callsite CALL which is the call\n+   statement being examined.*/\n \n static void\n compute_scalar_jump_functions (struct ipa_node_params *info,\n+\t\t\t       struct param_analysis_info *parms_ainfo,\n \t\t\t       struct ipa_edge_args *args,\n \t\t\t       gimple call)\n {\n@@ -705,7 +830,8 @@ compute_scalar_jump_functions (struct ipa_node_params *info,\n \t    {\n \t      gimple stmt = SSA_NAME_DEF_STMT (arg);\n \t      if (is_gimple_assign (stmt))\n-\t\tcompute_complex_assign_jump_func (info, jfunc, call, stmt, arg);\n+\t\tcompute_complex_assign_jump_func (info, parms_ainfo, jfunc,\n+\t\t\t\t\t\t  call, stmt, arg);\n \t      else if (gimple_code (stmt) == GIMPLE_PHI)\n \t\tcompute_complex_ancestor_jump_func (info, jfunc, call, stmt);\n \t    }\n@@ -748,43 +874,6 @@ type_like_member_ptr_p (tree type, tree *method_ptr, tree *delta)\n   return true;\n }\n \n-/* Callback of walk_aliased_vdefs.  Flags that it has been invoked to the\n-   boolean variable pointed to by DATA.  */\n-\n-static bool\n-mark_modified (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef ATTRIBUTE_UNUSED,\n-\t\t     void *data)\n-{\n-  bool *b = (bool *) data;\n-  *b = true;\n-  return true;\n-}\n-\n-/* Return true if the formal parameter PARM might have been modified in this\n-   function before reaching the statement CALL.  PARM_INFO is a pointer to a\n-   structure containing intermediate information about PARM.  */\n-\n-static bool\n-is_parm_modified_before_call (struct param_analysis_info *parm_info,\n-\t\t\t      gimple call, tree parm)\n-{\n-  bool modified = false;\n-  ao_ref refd;\n-\n-  if (parm_info->modified)\n-    return true;\n-\n-  ao_ref_init (&refd, parm);\n-  walk_aliased_vdefs (&refd, gimple_vuse (call), mark_modified,\n-\t\t      &modified, &parm_info->visited_statements);\n-  if (modified)\n-    {\n-      parm_info->modified = true;\n-      return true;\n-    }\n-  return false;\n-}\n-\n /* Go through arguments of the CALL and for every one that looks like a member\n    pointer, check whether it can be safely declared pass-through and if so,\n    mark that to the corresponding item of jump FUNCTIONS.  Return true iff\n@@ -813,7 +902,7 @@ compute_pass_through_member_ptrs (struct ipa_node_params *info,\n \t      int index = ipa_get_param_decl_index (info, arg);\n \n \t      gcc_assert (index >=0);\n-\t      if (!is_parm_modified_before_call (&parms_ainfo[index], call,\n+\t      if (!is_parm_modified_before_stmt (&parms_ainfo[index], call,\n \t\t\t\t\t\t arg))\n \t\t{\n \t\t  struct ipa_jump_func *jfunc = ipa_get_ith_jump_func (args,\n@@ -982,7 +1071,7 @@ ipa_compute_jump_functions_for_edge (struct param_analysis_info *parms_ainfo,\n   VEC_safe_grow_cleared (ipa_jump_func_t, gc, args->jump_functions, arg_num);\n \n   /* We will deal with constants and SSA scalars first:  */\n-  compute_scalar_jump_functions (info, args, call);\n+  compute_scalar_jump_functions (info, parms_ainfo, args, call);\n \n   /* Let's check whether there are any potential member pointers and if so,\n      whether we can determine their functions as pass_through.  */\n@@ -1284,7 +1373,7 @@ ipa_analyze_indirect_call_uses (struct cgraph_node *node,\n     return;\n \n   index = ipa_get_param_decl_index (info, rec);\n-  if (index >= 0 && !is_parm_modified_before_call (&parms_ainfo[index],\n+  if (index >= 0 && !is_parm_modified_before_stmt (&parms_ainfo[index],\n \t\t\t\t\t\t   call, rec))\n     ipa_note_param_call (node, index, call);\n "}, {"sha": "244a665487df2746f9dd32f766dc6d3f529a8df1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb0e1b4bcf88b63bb6bc0b6a6d52b32a1016f7d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb0e1b4bcf88b63bb6bc0b6a6d52b32a1016f7d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fdb0e1b4bcf88b63bb6bc0b6a6d52b32a1016f7d", "patch": "@@ -1,3 +1,7 @@\n+2011-10-31  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* gcc.dg/ipa/ipcp-4.c: New test.\n+\n 2011-10-31  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/vshift-3.c: New test."}, {"sha": "59018ca6b1e2ac9fcae0014463015b02c02177ae", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-4.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdb0e1b4bcf88b63bb6bc0b6a6d52b32a1016f7d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdb0e1b4bcf88b63bb6bc0b6a6d52b32a1016f7d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-4.c?ref=fdb0e1b4bcf88b63bb6bc0b6a6d52b32a1016f7d", "patch": "@@ -0,0 +1,68 @@\n+/* Test that IPA-CP is able to produce a pass-through jump function for the\n+   call of g1 and g2 even though a is addressable.  Also test that h is not\n+   cloned.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fipa-cp -fipa-cp-clone -fdump-ipa-cp -fno-early-inlining\"  } */\n+/* { dg-add-options bind_pic_locally } */\n+\n+extern void use_stuff (int);\n+extern void use_pointer (int *);\n+\n+static int\n+h (int a, int b)\n+{\n+  int i;\n+\n+  for (i = 8; i <= b; i++)\n+    use_stuff (a+8);\n+}\n+\n+static int\n+g1 (int a, int b)\n+{\n+  int i;\n+\n+  for (i = 0; i <= b; i++)\n+    use_pointer (&a);\n+  h (a, b);\n+}\n+\n+static int\n+g2 (int a, int b)\n+{\n+  int i;\n+\n+  for (i = 4; i <= b; i += 2)\n+    use_stuff (a);\n+}\n+\n+\n+static void\n+f (int a, int z)\n+{\n+  if (z > 1)\n+    g1 (a, z);\n+  else\n+    g2 (a + 4, z);\n+  use_pointer (&a);\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  int i;\n+  for (i = 0; i < 100; i++)\n+    f (7, argc);\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-ipa-dump \"Creating a specialized node of g1.*for all known contexts\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"Creating a specialized node of g2.*for all known contexts\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-not \"Creating a specialized node of h.*for all known contexts\" \"cp\" } } */\n+/* { dg-final { scan-ipa-dump-times \"replacing param a with const 7\" 2 \"cp\"  } } */\n+/* { dg-final { scan-ipa-dump \"replacing param a with const 11\" \"cp\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */\n+\n+"}]}